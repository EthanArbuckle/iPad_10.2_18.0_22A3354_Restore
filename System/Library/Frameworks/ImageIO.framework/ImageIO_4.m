uint64_t putspan(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  char v17;
  uint64_t result;
  _BYTE *v19;
  _BYTE *v20;
  unsigned int v21;
  uint64_t v22;
  __int16 *v23;
  int v24;
  unsigned __int16 *v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  char v29;
  _BYTE *v30;
  _BYTE *v31;
  unsigned __int16 *v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  char v36;
  _BYTE *v37;
  int v38;
  int v39;
  _BYTE *v40;

  v9 = a2;
  v11 = a1[137];
  v12 = *(_DWORD *)(v11 + 72);
  v13 = *(_DWORD *)(v11 + 76);
  if ((int)a2 < 2624)
  {
LABEL_14:
    if (v9 >= 64)
    {
      v21 = (v9 >> 6) + 63;
      v22 = a3 + 6 * v21;
      v24 = *(__int16 *)(v22 + 4);
      v23 = (__int16 *)(v22 + 4);
      if ((v9 & 0xFFFFFFC0) != v24)
        putspan_cold_3();
      v25 = (unsigned __int16 *)(a3 + 6 * v21);
      v26 = v25[1];
      v27 = *v25;
      if (v13 < v27)
      {
        v28 = a1[145];
        v29 = v12;
        while (1)
        {
          if (v28 >= a1[141])
          {
            result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!(_DWORD)result)
              return result;
          }
          v12 = 0;
          v27 -= v13;
          v30 = (_BYTE *)a1[144];
          a1[144] = v30 + 1;
          *v30 = (v26 >> v27) | v29;
          v28 = a1[145] + 1;
          a1[145] = v28;
          v13 = 8;
          v29 = 0;
          if (v27 <= 8)
            goto LABEL_23;
        }
      }
      if (v27 >= 9)
        putspan_cold_2();
LABEL_23:
      v13 -= v27;
      v12 |= (_msbmask[v27] & v26) << v13;
      if (!v13)
      {
        if (a1[145] >= a1[141])
        {
          result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!(_DWORD)result)
            return result;
        }
        v31 = (_BYTE *)a1[144];
        a1[144] = v31 + 1;
        *v31 = v12;
        ++a1[145];
        v13 = 8;
        v12 = 0;
      }
      v9 -= *v23;
    }
    v32 = (unsigned __int16 *)(a3 + 6 * v9);
    v33 = v32[1];
    v34 = *v32;
    if (v13 >= v34)
    {
      if (v34 >= 9)
        putspan_cold_1();
LABEL_35:
      v38 = v13 - v34;
      v39 = ((_msbmask[v34] & v33) << (v13 - v34)) | v12;
      if (v13 == v34)
      {
        if (a1[145] >= a1[141])
        {
          result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!(_DWORD)result)
            return result;
        }
        v40 = (_BYTE *)a1[144];
        a1[144] = v40 + 1;
        *v40 = v39;
        ++a1[145];
        v38 = 8;
        v39 = 0;
      }
      *(_DWORD *)(v11 + 72) = v39;
      *(_DWORD *)(v11 + 76) = v38;
      return 1;
    }
    v35 = a1[145];
    v36 = v12;
    while (1)
    {
      if (v35 >= a1[141])
      {
        result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!(_DWORD)result)
          break;
      }
      v12 = 0;
      v34 -= v13;
      v37 = (_BYTE *)a1[144];
      a1[144] = v37 + 1;
      *v37 = (v33 >> v34) | v36;
      v35 = a1[145] + 1;
      a1[145] = v35;
      v13 = 8;
      v36 = 0;
      if (v34 <= 8)
        goto LABEL_35;
    }
  }
  else
  {
    while (1)
    {
      v14 = *(unsigned __int16 *)(a3 + 620);
      v15 = *(unsigned __int16 *)(a3 + 618);
      if (v13 < v15)
        break;
      if (v15 >= 9)
        putspan_cold_4();
LABEL_9:
      v13 -= v15;
      v12 |= (_msbmask[v15] & v14) << v13;
      if (!v13)
      {
        if (a1[145] >= a1[141])
        {
          result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!(_DWORD)result)
            return result;
        }
        v20 = (_BYTE *)a1[144];
        a1[144] = v20 + 1;
        *v20 = v12;
        ++a1[145];
        v13 = 8;
        v12 = 0;
      }
      v9 -= *(__int16 *)(a3 + 622);
      if (v9 <= 2623)
        goto LABEL_14;
    }
    v16 = a1[145];
    v17 = v12;
    while (1)
    {
      if (v16 >= a1[141])
      {
        result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!(_DWORD)result)
          break;
      }
      v12 = 0;
      v15 -= v13;
      v19 = (_BYTE *)a1[144];
      a1[144] = v19 + 1;
      *v19 = (v14 >> v15) | v17;
      v16 = a1[145] + 1;
      a1[145] = v16;
      v13 = 8;
      v17 = 0;
      if (v15 <= 8)
        goto LABEL_9;
    }
  }
  return result;
}

uint64_t Fax3PutBits(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  uint64_t v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  uint64_t result;
  _BYTE *v17;
  BOOL v18;
  int v19;
  int v20;
  _BYTE *v21;

  v8 = a3;
  v9 = a2;
  v11 = a1[137];
  v12 = *(_DWORD *)(v11 + 72);
  v13 = *(_DWORD *)(v11 + 76);
  if (v13 >= a3)
  {
    if (a3 >= 9)
      Fax3PutBits_cold_1();
LABEL_8:
    v19 = v13 - v8;
    v18 = v13 == v8;
    v20 = ((_msbmask[v8] & v9) << (v13 - v8)) | v12;
    if (v18)
    {
      if (a1[145] >= a1[141])
      {
        result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!(_DWORD)result)
          return result;
      }
      v21 = (_BYTE *)a1[144];
      a1[144] = v21 + 1;
      *v21 = v20;
      ++a1[145];
      v19 = 8;
      v20 = 0;
    }
    *(_DWORD *)(v11 + 72) = v20;
    *(_DWORD *)(v11 + 76) = v19;
    return 1;
  }
  v14 = a1[145];
  v15 = *(_DWORD *)(v11 + 72);
  while (1)
  {
    if (v14 >= a1[141])
    {
      result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
      if (!(_DWORD)result)
        return result;
    }
    v12 = 0;
    v8 -= v13;
    v17 = (_BYTE *)a1[144];
    a1[144] = v17 + 1;
    *v17 = (v9 >> v8) | v15;
    v14 = a1[145] + 1;
    a1[145] = v14;
    v13 = 8;
    LOBYTE(v15) = 0;
    if (v8 <= 8)
      goto LABEL_8;
  }
}

void IIOIncrementIdentifyCallCount()
{
  ++gCallCounts;
}

void IIOIncrementImageCountCallCount()
{
  ++qword_1EDF09468;
}

void IIOIncrementSourcePropertiesCallCount()
{
  ++qword_1EDF09470;
}

void IIOIncrementInitImageCallCount()
{
  ++qword_1EDF09478;
}

void IIOIncrementCopyIOSurfaceCallCount()
{
  ++qword_1EDF09488;
}

uint64_t IIO_XPCServer()
{
  return gRunningInXPCService;
}

xpc_object_t IIOProcessEvent(_xpc_connection_s *a1, void *a2)
{
  xpc_object_t source_dict;
  uint64_t uint64;
  uint64_t v6;
  int v7;
  IIO_ReaderHandler *v8;
  os_unfair_lock_s *ReaderHandler;
  IIO_ReaderHandler *v10;
  IIO_ReaderHandler *v11;
  IIO_ReaderHandler *v12;
  IIO_ReaderHandler *v13;
  IIO_ReaderHandler *v14;
  IIO_ReaderHandler *v15;
  xpc_object_t reply;
  xpc_object_t v17;
  xpc_object_t v18;
  IIO_ReaderHandler *v19;
  IIO_ReaderHandler *v20;
  double Current;
  IIO_ReaderHandler *v23;
  CFAbsoluteTime v24;
  xpc_object_t v25;
  xpc_object_t v26;
  double v27;
  _QWORD v28[5];
  int v29;
  _QWORD v30[5];
  int v31;
  _QWORD v32[5];
  int v33;
  _QWORD v34[5];
  int v35;
  _QWORD v36[5];
  int v37;

  if (!gRunningInXPCService)
    return 0;
  source_dict = iio_xpc_get_source_dict(a2);
  uint64 = xpc_dictionary_get_uint64(a2, "iio_xpc_message_id");
  v6 = xpc_dictionary_get_uint64(a2, "iio_xpc_transacion_id");
  IIOXPCUpdatePermissions(a2);
  IIOXPCUpdateAllowableTypes(a2);
  if (source_dict)
    v7 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
  else
    v7 = 774778414;
  switch(uint64)
  {
    case 1uLL:
      kdebug_trace();
      IIOXPCLog("➡️ XPC_READPLUGIN_IDENTIFY [%lld]\n", v6);
      ReaderHandler = (os_unfair_lock_s *)IIO_ReaderHandler::GetReaderHandler(v8);
      v36[0] = MEMORY[0x1E0C809B0];
      v36[1] = 0x40000000;
      v36[2] = __IIOProcessEvent_block_invoke;
      v36[3] = &__block_descriptor_tmp_9_1;
      v36[4] = v6;
      v37 = v7;
      IIO_ReaderHandler::xpcTestHeader(ReaderHandler, (int)a1, a2, (uint64_t)v36);
      return 0;
    case 2uLL:
      kdebug_trace();
      IIOXPCLog("➡️ XPC_READPLUGIN_IMAGECOUNT [%lld]\n", v6);
      v11 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v10);
      v34[0] = MEMORY[0x1E0C809B0];
      v34[1] = 0x40000000;
      v34[2] = __IIOProcessEvent_block_invoke_2;
      v34[3] = &__block_descriptor_tmp_12_1;
      v34[4] = v6;
      v35 = v7;
      IIO_ReaderHandler::xpcGetImageCount(v11, a1, a2, (uint64_t)v34);
      return 0;
    case 3uLL:
      kdebug_trace();
      IIOXPCLog("➡️ XPC_READPLUGIN_SOURCEPROPERTIES [%lld]\n", v6);
      v13 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v12);
      v32[0] = MEMORY[0x1E0C809B0];
      v32[1] = 0x40000000;
      v32[2] = __IIOProcessEvent_block_invoke_3;
      v32[3] = &__block_descriptor_tmp_15_1;
      v32[4] = v6;
      v33 = v7;
      IIO_ReaderHandler::xpcUpdateSourceProperties(v13, a1, a2, (uint64_t)v32);
      return 0;
    case 4uLL:
      kdebug_trace();
      IIOXPCLog("➡️ XPC_READPLUGIN_INITIMAGE [%lld]\n", v6);
      v15 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v14);
      v30[0] = MEMORY[0x1E0C809B0];
      v30[1] = 0x40000000;
      v30[2] = __IIOProcessEvent_block_invoke_4;
      v30[3] = &__block_descriptor_tmp_18_0;
      v30[4] = v6;
      v31 = v7;
      IIO_ReaderHandler::xpcInitImage(v15, a1, a2, (uint64_t)v30);
      return 0;
    case 5uLL:
      kdebug_trace();
      IIOXPCLog("➡️ XPC_READPLUGIN_DEBUG [%lld]\n", v6);
      reply = xpc_dictionary_create_reply(a2);
      v17 = reply;
      if (reply)
      {
        v18 = iio_xpc_add_message_dict(reply);
        iio_xpc_dictionary_add_databuffer(v18, "iio_xpc_msg_call_counts", &gCallCounts, 0x30uLL);
      }
      IIOXPCLog("⬅️ XPC_READPLUGIN_DEBUG [%lld]\n", v6);
      break;
    case 6uLL:
      kdebug_trace();
      IIOXPCLog("➡️ XPC_READPLUGIN_DECODE_IMAGE [%lld]\n", v6);
      v20 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v19);
      v28[0] = MEMORY[0x1E0C809B0];
      v28[1] = 0x40000000;
      v28[2] = __IIOProcessEvent_block_invoke_5;
      v28[3] = &__block_descriptor_tmp_23_0;
      v28[4] = v6;
      v29 = v7;
      IIO_ReaderHandler::xpcDecodeImage(v20, a1, a2, (uint64_t)v28);
      return 0;
    case 8uLL:
      kdebug_trace();
      IIOXPCLog("➡️ XPC_READPLUGIN_WAKEUP [%lld]\n", v6);
      if (gRunningInXPCService)
      {
        gIIODebugFlags = xpc_dictionary_get_uint64(a2, "iio_xpc_msg_debugflags");
        xpc_dictionary_get_uint64(a2, "iio_xpc_msg_pid");
        Current = CFAbsoluteTimeGetCurrent();
        if (IIO_ReaderHandler::GetReaderHandler(v23))
        {
          v24 = CFAbsoluteTimeGetCurrent();
          IIOXPCLog("    IIO_ReaderHandler::buildPluginList: %g ms\n", (v24 - Current) * 1000.0);
        }
        v25 = xpc_dictionary_create_reply(a2);
        v17 = v25;
        if (v25)
        {
          v26 = iio_xpc_add_message_dict(v25);
          v27 = CFAbsoluteTimeGetCurrent();
          xpc_dictionary_set_double(v26, "iio_xpc_msg_wakeup_time", v27);
          iio_xpc_dictionary_set_error_code(v26, 0);
        }
      }
      else
      {
        v17 = 0;
      }
      IIOXPCLog("⬅️ XPC_READPLUGIN_WAKEUP [%lld]\n", v6);
      break;
    default:
      IIOXPCLog("🔺 message [%d] not handled...\n", uint64);
      return 0;
  }
  kdebug_trace();
  return v17;
}

void UpdateRunningInXPCService()
{
  if (UpdateRunningInXPCService::onceToken != -1)
    dispatch_once(&UpdateRunningInXPCService::onceToken, &__block_literal_global_28);
}

uint64_t IIO_Reader_ASTC::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  ASTCReadPlugin::ASTCReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FF5D30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F05BA732);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ASTC::updateSourceProperties(__CFString ***this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v13;

  if (this[1] != kCGImageTypeIdentifierKTX)
    return 4294967246;
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)this);
  v13 = IIO_ReaderHandler::readerForType(ReaderHandler, 1263818784);
  return (*(uint64_t (**)(IIO_Reader *, IIOImageReadSession *, IIODictionary *, IIODictionary *, IIODictionary *, CGImageSourceStatus *))(*(_QWORD *)v13 + 56))(v13, a2, a3, a4, a5, a6);
}

uint64_t IIO_Reader_ASTC::hasCustomSourcePropertiesProc(IIO_Reader_ASTC *this)
{
  return 1;
}

uint64_t ERROR_ImageIO_DataBufferIsNotBigEnough(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a1 + a2);
}

void ImageIO_saveImageData(const char *a1, CFDataRef theData)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  size_t v6;
  unsigned int v7;
  const char *v8;
  const char *v9;
  int v10;
  FILE *v11;
  FILE *v12;
  int *v13;
  char *__filename;

  if (!theData)
    return;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  __filename = 0;
  if (Length < 21)
    return;
  v6 = Length;
  v7 = *BytePtr;
  v8 = "data";
  if (v7 > 0x4C)
  {
    if (*BytePtr > 0x88u)
    {
      if (v7 == 137)
      {
        if (BytePtr[1] == 80 && BytePtr[2] == 78 && BytePtr[3] == 71)
          v8 = "png";
      }
      else if (v7 == 255 && BytePtr[1] == 216 && BytePtr[2] == 255)
      {
        v8 = "jpg";
      }
      goto LABEL_46;
    }
    if (v7 != 77)
    {
      if (v7 == 105 && BytePtr[1] == 99 && BytePtr[2] == 110 && BytePtr[3] == 115)
        v8 = "icns";
      goto LABEL_46;
    }
    if (BytePtr[1] != 77)
      goto LABEL_46;
LABEL_37:
    v8 = "tif";
    goto LABEL_46;
  }
  if (*BytePtr <= 0x46u)
  {
    if (*BytePtr)
    {
      if (v7 == 56 && BytePtr[1] == 66 && BytePtr[2] == 80 && BytePtr[3] == 83)
        v8 = "psd";
    }
    else if (!BytePtr[1]
           && !BytePtr[2]
           && BytePtr[3] == 12
           && BytePtr[4] == 106
           && BytePtr[5] == 80
           && BytePtr[8] == 13
           && BytePtr[9] == 10)
    {
      v8 = "jp2";
    }
    goto LABEL_46;
  }
  if (v7 == 71)
  {
    if (BytePtr[1] == 73 && BytePtr[2] == 70 && BytePtr[3] == 56)
      v8 = "gif";
    goto LABEL_46;
  }
  if (v7 == 73 && BytePtr[1] == 73)
    goto LABEL_37;
LABEL_46:
  v9 = (const char *)ImageIOTempDirPath();
  v10 = ImageIO_saveImageData::fileIndex++;
  asprintf(&__filename, "%s/IIO-%03d-%s.%s", v9, v10, a1, v8);
  ImageIOLog("*** writing imagedata to '%s'\n", __filename);
  v11 = fopen(__filename, "w");
  if (v11)
  {
    v12 = v11;
    CFLog();
    fwrite(BytePtr, v6, 1uLL, v12);
    fclose(v12);
  }
  else
  {
    __error();
    v13 = __error();
    strerror(*v13);
    CFLog();
  }
  free(__filename);
}

uint64_t ImageIOTempDirPath()
{
  uint64_t result;
  char v1[1024];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  result = ImageIOTempDirPath::tempDirPath;
  if (!ImageIOTempDirPath::tempDirPath)
  {
    bzero(v1, 0x400uLL);
    if (confstr(65537, v1, 0x400uLL))
      asprintf((char **)&ImageIOTempDirPath::tempDirPath, "%s", v1);
    return ImageIOTempDirPath::tempDirPath;
  }
  return result;
}

uint64_t IIO_HardwareEncoderDefaultValue()
{
  if (IIO_HardwareEncoderDefaultValue::onceToken != -1)
    dispatch_once(&IIO_HardwareEncoderDefaultValue::onceToken, &__block_literal_global_30_0);
  return IIO_HardwareEncoderDefaultValue::hwEncoderDefaultValue;
}

void sub_187FF62A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

__int128 *CGGetImageIOVersion()
{
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGGetImageIOVersion", 0, 0, -1, 0);
  if (CGGetImageIOVersion::onceToken != -1)
    dispatch_once(&CGGetImageIOVersion::onceToken, &__block_literal_global_36);
  return &CGGetImageIOVersion::gIIOVersion;
}

void sub_187FF63CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

__int128 *GetPBMLookupTable(void)
{
  if (GetPBMLookupTable(void)::onceToken != -1)
    dispatch_once(&GetPBMLookupTable(void)::onceToken, &__block_literal_global_23);
  return &gPBMLookupTable;
}

double ___Z17GetPBMLookupTablev_block_invoke()
{
  __int128 v0;
  double result;

  *(_QWORD *)&v0 = -1;
  *((_QWORD *)&v0 + 1) = -1;
  xmmword_1EDF0A5E8 = v0;
  unk_1EDF0A5F8 = v0;
  xmmword_1EDF0A5C8 = v0;
  unk_1EDF0A5D8 = v0;
  xmmword_1EDF0A5A8 = v0;
  unk_1EDF0A5B8 = v0;
  xmmword_1EDF0A588 = v0;
  unk_1EDF0A598 = v0;
  xmmword_1EDF0A568 = v0;
  unk_1EDF0A578 = v0;
  xmmword_1EDF0A548 = v0;
  unk_1EDF0A558 = v0;
  xmmword_1EDF0A528 = v0;
  *(_OWORD *)&qword_1EDF0A538 = v0;
  gPBMLookupTable = v0;
  unk_1EDF0A518 = v0;
  BYTE3(xmmword_1EDF0A528) = -2;
  BYTE13(gPBMLookupTable) = -3;
  *(_WORD *)((char *)&gPBMLookupTable + 9) = -771;
  LOBYTE(xmmword_1EDF0A528) = -3;
  BYTE13(xmmword_1EDF0A528) = 45;
  result = 7.9499289e-275;
  qword_1EDF0A538 = 0x706050403020100;
  word_1EDF0A540 = 2312;
  return result;
}

_DWORD *png_save_uint_32(_DWORD *result, unsigned int a2)
{
  *result = bswap32(a2);
  return result;
}

uint64_t png_write_PLTE(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3;
  int v6;
  BOOL v7;
  char *v8;
  uint64_t result;
  _WORD v10[2];

  v3 = a3;
  v6 = *(unsigned __int8 *)(a1 + 391);
  if (v6 == 3)
  {
    if (*(_DWORD *)(a1 + 760) & 1 | a3)
      v7 = 1 << *(_BYTE *)(a1 + 392) >= a3;
    else
      v7 = 0;
    if (!v7)
      _cg_png_error((void (**)(void))a1, "Invalid number of colors in palette");
    goto LABEL_11;
  }
  if (a3 > 0x100 || !(*(_DWORD *)(a1 + 760) & 1 | a3))
  {
    v8 = "Invalid number of colors in palette";
    return png_warning(a1, v8);
  }
  if ((v6 & 2) == 0)
  {
    v8 = "Ignoring request to write a PLTE chunk in grayscale PNG";
    return png_warning(a1, v8);
  }
LABEL_11:
  memset(v10, 0, 3);
  *(_WORD *)(a1 + 376) = a3;
  _cg_png_write_chunk_header(a1, 1347179589);
  for (; v3; --v3)
  {
    LOBYTE(v10[0]) = *(_BYTE *)a2;
    *(_WORD *)((char *)v10 + 1) = *(_WORD *)(a2 + 1);
    _cg_png_write_chunk_data(a1, (Bytef *)v10, 3);
    a2 += 3;
  }
  result = _cg_png_write_chunk_end(a1);
  *(_DWORD *)(a1 + 76) |= 2u;
  return result;
}

uint64_t png_write_fdAT(uint64_t a1, Bytef *a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v7;

  _cg_png_write_chunk_header(a1, 1717846356);
  v7 = bswap32(*(_DWORD *)(a1 + 772));
  _cg_png_write_chunk_data(a1, (Bytef *)&v7, 4);
  _cg_png_write_chunk_data(a1, a2, a3);
  result = _cg_png_write_chunk_end(a1);
  ++*(_DWORD *)(a1 + 772);
  return result;
}

void (**png_write_gAMA_fixed(void (**a1)(void), unsigned int a2))(void)
{
  unsigned int v3;

  v3 = bswap32(a2);
  return _cg_png_write_complete_chunk(a1, 1732332865, (Bytef *)&v3, 4uLL);
}

uint64_t png_write_sPLT(void (**a1)(void), uint64_t a2)
{
  Bytef *v4;
  uint64_t v5;
  int v6;
  int v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  unsigned __int16 v10;
  __int16 *v11;
  _BYTE *v12;
  _BYTE *v13;
  unsigned __int16 v14;
  uint64_t v16;
  __int16 v17;
  _OWORD v18[5];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  memset(v18, 0, sizeof(v18));
  v17 = 0;
  v16 = 0;
  v4 = (Bytef *)(a2 + 16);
  if (*(_BYTE *)(a2 + 16) == 8)
    v5 = 6;
  else
    v5 = 10;
  v6 = png_check_keyword((uint64_t)a1, *(unsigned __int8 **)a2, v18);
  if (!v6)
    _cg_png_error(a1, "sPLT: invalid keyword");
  v7 = v6;
  _cg_png_write_chunk_header((uint64_t)a1, 1934642260);
  _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)v18, (v7 + 1));
  _cg_png_write_chunk_data((uint64_t)a1, v4, 1);
  if (*(int *)(a2 + 32) >= 1)
  {
    v8 = (unsigned __int16 *)(*(_QWORD *)(a2 + 24) + 4);
    do
    {
      v9 = v8 - 2;
      if (*v4 == 8)
      {
        LOBYTE(v16) = *(v8 - 2);
        BYTE1(v16) = *((_BYTE *)v8 - 2);
        BYTE2(v16) = *(_BYTE *)v8;
        v10 = v8[1];
        v11 = (__int16 *)&v16 + 2;
        v12 = (char *)&v16 + 3;
        v13 = (char *)&v16 + 5;
      }
      else
      {
        LOWORD(v16) = __rev16(*(v8 - 2));
        WORD1(v16) = bswap32(*(v8 - 1)) >> 16;
        WORD2(v16) = bswap32(*v8) >> 16;
        v10 = v8[1];
        BYTE6(v16) = HIBYTE(v10);
        v12 = (char *)&v16 + 7;
        v11 = &v17;
        v13 = (char *)&v17 + 1;
      }
      *v12 = v10;
      v14 = v8[2];
      *(_BYTE *)v11 = HIBYTE(v14);
      *v13 = v14;
      _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)&v16, v5);
      v8 += 5;
    }
    while ((unint64_t)(v9 + 5) < *(_QWORD *)(a2 + 24) + 10 * *(int *)(a2 + 32));
  }
  return _cg_png_write_chunk_end((uint64_t)a1);
}

void (**png_write_sBIT(uint64_t a1, unsigned __int8 *a2, int a3))(void)
{
  unint64_t v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  _BYTE *v10;
  int v11;

  v11 = 0;
  if ((a3 & 2) != 0)
  {
    if (a3 == 3)
      v4 = 8;
    else
      v4 = *(unsigned __int8 *)(a1 + 393);
    if (*a2)
      v5 = v4 >= *a2;
    else
      v5 = 0;
    if (!v5)
      return (void (**)(void))png_warning(a1, "Invalid sBIT depth specified");
    v6 = a2[1];
    if (!a2[1])
      return (void (**)(void))png_warning(a1, "Invalid sBIT depth specified");
    if (v4 < v6)
      return (void (**)(void))png_warning(a1, "Invalid sBIT depth specified");
    v7 = a2[2];
    if (!a2[2] || v4 < v7)
      return (void (**)(void))png_warning(a1, "Invalid sBIT depth specified");
    LOBYTE(v11) = *a2;
    BYTE1(v11) = v6;
    v3 = 3;
    BYTE2(v11) = v7;
    if ((a3 & 4) == 0)
      return _cg_png_write_complete_chunk((void (**)(void))a1, 1933723988, (Bytef *)&v11, v3);
  }
  else
  {
    if (!a2[3] || a2[3] > *(unsigned __int8 *)(a1 + 393))
      return (void (**)(void))png_warning(a1, "Invalid sBIT depth specified");
    LOBYTE(v11) = a2[3];
    v3 = 1;
    if ((a3 & 4) == 0)
      return _cg_png_write_complete_chunk((void (**)(void))a1, 1933723988, (Bytef *)&v11, v3);
  }
  v8 = a2[4];
  if (!a2[4] || v8 > *(unsigned __int8 *)(a1 + 393))
    return (void (**)(void))png_warning(a1, "Invalid sBIT depth specified");
  v10 = (_BYTE *)((unint64_t)&v11 | v3++);
  *v10 = v8;
  return _cg_png_write_complete_chunk((void (**)(void))a1, 1933723988, (Bytef *)&v11, v3);
}

void (**png_write_cHRM_fixed(void (**a1)(void), unsigned int *a2))(void)
{
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5 = 0u;
  v6 = 0u;
  png_save_int_32(&v5, a2[6]);
  png_save_int_32((char *)&v5 + 4, a2[7]);
  png_save_int_32((char *)&v5 + 8, *a2);
  png_save_int_32((unint64_t)&v5 | 0xC, a2[1]);
  png_save_int_32(&v6, a2[2]);
  png_save_int_32((char *)&v6 + 4, a2[3]);
  png_save_int_32((char *)&v6 + 8, a2[4]);
  png_save_int_32((char *)&v6 + 12, a2[5]);
  return _cg_png_write_complete_chunk(a1, 1665684045, (Bytef *)&v5, 0x20uLL);
}

void (**png_write_tRNS(uint64_t a1, Bytef *a2, unsigned __int16 *a3, int a4, int a5))(void)
{
  char *v5;
  signed int v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v16;
  __int16 v17;

  v17 = 0;
  v16 = 0;
  switch(a5)
  {
    case 0:
      v6 = a3[4];
      if (1 << *(_BYTE *)(a1 + 392) <= v6)
      {
        v5 = "Ignoring attempt to write tRNS chunk out-of-range for bit_depth";
        return (void (**)(void))png_app_warning(a1, v5);
      }
      LOWORD(v16) = __rev16(v6);
      v7 = 2;
      return _cg_png_write_complete_chunk((void (**)(void))a1, 1951551059, (Bytef *)&v16, v7);
    case 2:
      v8 = a3[1];
      v9 = v8 >> 8;
      LOWORD(v16) = __rev16(v8);
      v10 = a3[2];
      v11 = v10 >> 8;
      HIWORD(v16) = __rev16(v10);
      v12 = a3[3];
      v17 = __rev16(v12);
      v13 = v11 | (v12 >> 8) | v9;
      if (*(_BYTE *)(a1 + 392) == 8 && v13 != 0)
      {
        v5 = "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8";
        return (void (**)(void))png_app_warning(a1, v5);
      }
      v7 = 6;
      return _cg_png_write_complete_chunk((void (**)(void))a1, 1951551059, (Bytef *)&v16, v7);
    case 3:
      if (a4 >= 1 && *(unsigned __int16 *)(a1 + 376) >= a4)
        return _cg_png_write_complete_chunk((void (**)(void))a1, 1951551059, a2, a4);
      v5 = "Invalid number of transparent colors specified";
      break;
    default:
      v5 = "Can't write tRNS with an alpha channel";
      break;
  }
  return (void (**)(void))png_app_warning(a1, v5);
}

void (**png_write_bKGD(uint64_t a1, unsigned __int8 *a2, int a3))(void)
{
  unsigned int v3;
  char *v4;
  signed int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v15;
  __int16 v16;

  v16 = 0;
  v15 = 0;
  if (a3 != 3)
  {
    if ((a3 & 2) != 0)
    {
      v7 = *((unsigned __int16 *)a2 + 1);
      v8 = v7 >> 8;
      LOWORD(v15) = __rev16(v7);
      v9 = *((unsigned __int16 *)a2 + 2);
      v10 = v9 >> 8;
      HIWORD(v15) = __rev16(v9);
      v11 = *((unsigned __int16 *)a2 + 3);
      v16 = __rev16(v11);
      v12 = v10 | (v11 >> 8) | v8;
      if (*(_BYTE *)(a1 + 392) == 8 && v12 != 0)
      {
        v4 = "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8";
        return (void (**)(void))png_warning(a1, v4);
      }
      v6 = 6;
    }
    else
    {
      v5 = *((unsigned __int16 *)a2 + 4);
      if (1 << *(_BYTE *)(a1 + 392) <= v5)
      {
        v4 = "Ignoring attempt to write bKGD chunk out-of-range for bit_depth";
        return (void (**)(void))png_warning(a1, v4);
      }
      LOWORD(v15) = __rev16(v5);
      v6 = 2;
    }
    return _cg_png_write_complete_chunk((void (**)(void))a1, 1649100612, (Bytef *)&v15, v6);
  }
  if (!*(_WORD *)(a1 + 376) && (*(_BYTE *)(a1 + 760) & 1) != 0)
  {
    LOBYTE(v3) = *a2;
    goto LABEL_17;
  }
  v3 = *a2;
  if (*(unsigned __int16 *)(a1 + 376) > v3)
  {
LABEL_17:
    LOBYTE(v15) = v3;
    v6 = 1;
    return _cg_png_write_complete_chunk((void (**)(void))a1, 1649100612, (Bytef *)&v15, v6);
  }
  v4 = "Invalid background palette index";
  return (void (**)(void))png_warning(a1, v4);
}

uint64_t png_write_hIST(uint64_t a1, unsigned __int16 *a2, int a3)
{
  uint64_t v5;
  unsigned int v7;
  __int16 v8;
  char v9;

  if (*(unsigned __int16 *)(a1 + 376) < a3)
    return png_warning(a1, "Invalid number of histogram entries specified");
  LODWORD(v5) = a3;
  v9 = 0;
  v8 = 0;
  _cg_png_write_chunk_header(a1, 1749635924);
  if ((int)v5 >= 1)
  {
    v5 = v5;
    do
    {
      v7 = *a2++;
      v8 = bswap32(v7) >> 16;
      _cg_png_write_chunk_data(a1, (Bytef *)&v8, 2);
      --v5;
    }
    while (v5);
  }
  return _cg_png_write_chunk_end(a1);
}

uint64_t png_write_tEXt(void (**a1)(void), unsigned __int8 *a2, char *a3)
{
  int v5;
  int v6;
  size_t v7;
  const char *v8;
  _OWORD v10[5];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  memset(v10, 0, sizeof(v10));
  v5 = png_check_keyword((uint64_t)a1, a2, v10);
  if (!v5)
  {
    v8 = "tEXt: invalid keyword";
LABEL_11:
    _cg_png_error(a1, v8);
  }
  v6 = v5;
  if (a3 && *a3)
  {
    v7 = strlen(a3);
    if (v7 > (2147483646 - v6))
    {
      v8 = "tEXt: text too long";
      goto LABEL_11;
    }
  }
  else
  {
    v7 = 0;
  }
  _cg_png_write_chunk_header((uint64_t)a1, 1950701684);
  _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)v10, (v6 + 1));
  if (v7)
    _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)a3, v7);
  return _cg_png_write_chunk_end((uint64_t)a1);
}

uint64_t png_write_zTXt(uint64_t a1, unsigned __int8 *a2, char *a3, int a4)
{
  int v8;
  uint64_t v9;
  size_t v10;
  const char *v11;
  _QWORD v12[2];
  _DWORD v13[258];
  Bytef v14[88];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    if (a4 == -1)
      return png_write_tEXt((void (**)(void))a1, a2, a3);
    v11 = "zTXt: invalid compression type";
LABEL_13:
    _cg_png_error((void (**)(void))a1, v11);
  }
  memset(v14, 0, 81);
  bzero(v13, 0x408uLL);
  v8 = png_check_keyword(a1, a2, v14);
  if (!v8)
  {
    v11 = "zTXt: invalid keyword";
    goto LABEL_13;
  }
  v14[v8 + 1] = 0;
  v9 = (v8 + 2);
  if (a3)
    v10 = strlen(a3);
  else
    v10 = 0;
  v12[0] = a3;
  v12[1] = v10;
  v13[0] = 0;
  if (png_text_compress(a1, 2052348020, (uint64_t)v12, v9))
  {
    v11 = *(const char **)(a1 + 144);
    goto LABEL_13;
  }
  _cg_png_write_chunk_header(a1, 2052348020);
  _cg_png_write_chunk_data(a1, v14, v9);
  png_write_compressed_data_out(a1, (uint64_t)v12);
  return _cg_png_write_chunk_end(a1);
}

uint64_t png_write_iTXt(uint64_t a1, int a2, unsigned __int8 *a3, char *a4, char *a5, char *a6)
{
  int v12;
  char v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  size_t v22;
  const char *v24;
  _QWORD v25[2];
  _DWORD v26[258];
  Bytef v27[80];
  __int16 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v28 = 0;
  memset(v27, 0, sizeof(v27));
  bzero(v26, 0x408uLL);
  v12 = png_check_keyword(a1, a3, v27);
  if (!v12)
  {
    v24 = "iTXt: invalid keyword";
    goto LABEL_26;
  }
  v13 = a2 + 1;
  if ((a2 + 1) >= 4)
  {
    v24 = "iTXt: invalid compression";
    goto LABEL_26;
  }
  v14 = v12;
  v27[v12 + 1] = 0x1000100u >> (8 * v13);
  v27[v12 + 2] = 0;
  v15 = (v12 + 3);
  if (!a4)
    a4 = "";
  v16 = strlen(a4) + 1;
  if (!a5)
    a5 = "";
  v17 = strlen(a5) + 1;
  if (!a6)
    a6 = "";
  v18 = v15 + v16;
  if (v16 > (2147483644 - v14))
    v18 = 0x7FFFFFFF;
  v19 = v18 ^ 0x7FFFFFFFu;
  v20 = v18 + v17;
  if (v17 <= v19)
    v21 = v20;
  else
    v21 = 0x7FFFFFFF;
  v22 = strlen(a6);
  v25[0] = a6;
  v25[1] = v22;
  v26[0] = 0;
  if ((v13 & 1) == 0)
  {
    if (v22 <= (v21 ^ 0x7FFFFFFFu))
    {
      v26[0] = v22;
      goto LABEL_18;
    }
    v24 = "iTXt: uncompressed text too long";
LABEL_26:
    _cg_png_error((void (**)(void))a1, v24);
  }
  if (png_text_compress(a1, 1767135348, (uint64_t)v25, v21))
  {
    v24 = *(const char **)(a1 + 144);
    goto LABEL_26;
  }
LABEL_18:
  _cg_png_write_chunk_header(a1, 1767135348);
  _cg_png_write_chunk_data(a1, v27, v15);
  _cg_png_write_chunk_data(a1, (Bytef *)a4, v16);
  _cg_png_write_chunk_data(a1, (Bytef *)a5, v17);
  if ((v13 & 1) != 0)
    png_write_compressed_data_out(a1, (uint64_t)v25);
  else
    _cg_png_write_chunk_data(a1, (Bytef *)a6, v26[0]);
  return _cg_png_write_chunk_end(a1);
}

void (**png_write_oFFs(void (**a1)(void), uint64_t a2, uint64_t a3, int a4))(void)
{
  char v4;
  uint64_t v9;
  char v10;
  uint64_t v11;

  v4 = a4;
  v11 = *MEMORY[0x1E0C80C00];
  if (a4 >= 2)
    png_warning((uint64_t)a1, "Unrecognized unit type for oFFs chunk");
  v10 = 0;
  v9 = 0;
  png_save_int_32(&v9, a2);
  png_save_int_32((char *)&v9 + 4, a3);
  v10 = v4;
  return _cg_png_write_complete_chunk(a1, 1866876531, (Bytef *)&v9, 9uLL);
}

uint64_t png_write_pCAL(void (**a1)(void), unsigned __int8 *a2, unsigned int a3, unsigned int a4, int a5, int a6, const char *a7, const char **a8)
{
  char v12;
  int v15;
  uint64_t v16;
  size_t v17;
  size_t v18;
  uint64_t v19;
  void (**v20)(void);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char **v24;
  void (**v25)(void);
  const char *v26;
  size_t v27;
  BOOL v28;
  size_t v29;
  uint64_t *v30;
  Bytef *v31;
  Bytef *v32;
  uint64_t v33;
  const char *v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t *v39;
  char v40;
  Bytef *v41;
  _OWORD v42[5];
  uint64_t v43;
  __int16 v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (a5 >= 4)
  {
    v35 = "Unrecognized equation type for pCAL chunk";
    goto LABEL_18;
  }
  v12 = a5;
  v44 = 0;
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  v15 = png_check_keyword((uint64_t)a1, a2, v42);
  if (!v15)
  {
    v35 = "pCAL: invalid keyword";
LABEL_18:
    _cg_png_error(a1, v35);
  }
  v37 = a3;
  v38 = a4;
  v40 = v12;
  v16 = (v15 + 1);
  v41 = (Bytef *)a7;
  v17 = strlen(a7);
  if (a6)
    v18 = v17 + 1;
  else
    v18 = v17;
  v36 = v18;
  v19 = v16 + v18 + 10;
  v20 = png_malloc(a1, 8 * a6);
  v21 = a6;
  v22 = (a6 - 1);
  v39 = (uint64_t *)v20;
  if (a6 >= 1)
  {
    v23 = a6;
    v24 = a8;
    v25 = v20;
    do
    {
      v26 = *v24++;
      v27 = strlen(v26);
      v28 = v22-- != 0;
      if (v28)
        v29 = v27 + 1;
      else
        v29 = v27;
      *v25++ = (void (*)(void))v29;
      v19 += v27 + v28;
      --v23;
    }
    while (v23);
  }
  _cg_png_write_chunk_header((uint64_t)a1, 1883455820);
  _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)v42, v16);
  png_save_int_32(&v43, v37);
  png_save_int_32((char *)&v43 + 4, v38);
  LOBYTE(v44) = v40;
  HIBYTE(v44) = a6;
  _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)&v43, 10);
  _cg_png_write_chunk_data((uint64_t)a1, v41, v36);
  if (a6 >= 1)
  {
    v30 = v39;
    do
    {
      v32 = (Bytef *)*a8++;
      v31 = v32;
      v33 = *v30++;
      _cg_png_write_chunk_data((uint64_t)a1, v31, v33);
      --v21;
    }
    while (v21);
  }
  png_free((uint64_t)a1, v39);
  return _cg_png_write_chunk_end((uint64_t)a1);
}

void (**png_write_sCAL_s(void (**a1)(void), Bytef a2, char *__s, const char *a4))(void)
{
  size_t v7;
  size_t v8;
  unint64_t v9;
  size_t v11;
  Bytef v12[64];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v7 = strlen(__s);
  v8 = strlen(a4);
  v9 = v7 + v8 + 2;
  if (v9 >= 0x41)
    return (void (**)(void))png_warning((uint64_t)a1, "Can't write sCAL (buffer too small)");
  v11 = v8;
  memset(&v12[1], 0, 63);
  v12[0] = a2;
  __memcpy_chk();
  memcpy(&v12[v7 + 2], a4, v11);
  return _cg_png_write_complete_chunk(a1, 1933787468, v12, v9);
}

void (**png_write_tIME(void (**a1)(void), unsigned __int16 *a2))(void)
{
  int v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned __int16 v7;
  Bytef v8[7];

  v2 = *((unsigned __int8 *)a2 + 2);
  if ((v2 - 13) < 0xFFFFFFF4)
    return (void (**)(void))png_warning((uint64_t)a1, "Invalid time specified for tIME chunk");
  v3 = *((unsigned __int8 *)a2 + 3);
  if ((v3 - 32) < 0xFFFFFFE1)
    return (void (**)(void))png_warning((uint64_t)a1, "Invalid time specified for tIME chunk");
  v4 = *((unsigned __int8 *)a2 + 4);
  if (v4 > 0x17)
    return (void (**)(void))png_warning((uint64_t)a1, "Invalid time specified for tIME chunk");
  v5 = *((unsigned __int8 *)a2 + 6);
  if (v5 >= 0x3D)
    return (void (**)(void))png_warning((uint64_t)a1, "Invalid time specified for tIME chunk");
  v7 = *a2;
  v8[0] = HIBYTE(*a2);
  v8[1] = v7;
  v8[2] = v2;
  v8[3] = v3;
  v8[4] = v4;
  v8[5] = *((_BYTE *)a2 + 5);
  v8[6] = v5;
  return _cg_png_write_complete_chunk(a1, 1950960965, v8, 7uLL);
}

void (**png_write_acTL(uint64_t a1, int a2, int a3))(void)
{
  int v3;
  Bytef v5[8];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 808) = a2;
  v3 = a2 - (*(_DWORD *)(a1 + 768) & 1);
  v5[0] = HIBYTE(v3);
  v5[1] = BYTE2(v3);
  v5[2] = BYTE1(v3);
  v5[3] = v3;
  v5[4] = HIBYTE(a3);
  v5[5] = BYTE2(a3);
  v5[6] = BYTE1(a3);
  v5[7] = a3;
  return _cg_png_write_complete_chunk((void (**)(void))a1, 1633899596, v5, 8uLL);
}

void (**png_write_fcTL(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, Bytef a8, unsigned __int8 a9))(void)
{
  __int16 v10;
  __int16 v11;
  int v17;
  int v18;
  void (**result)(void);
  const char *v20;
  Bytef v21[26];
  uint64_t v22;

  v10 = a7;
  v11 = a6;
  v22 = *MEMORY[0x1E0C80C00];
  v17 = *(_DWORD *)(a1 + 812);
  if (a5 | a4 && !v17)
  {
    v20 = "x and/or y offset for the first frame aren't 0";
    goto LABEL_9;
  }
  if (!v17 && (*(_DWORD *)(a1 + 776) != a2 || *(_DWORD *)(a1 + 780) != a3))
  {
    v20 = "width and/or height in the first frame's fcTL don't match the ones in IHDR";
LABEL_9:
    _cg_png_error((void (**)(void))a1, v20);
  }
  png_ensure_fcTL_is_valid(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v18 = *(_DWORD *)(a1 + 772);
  v21[0] = HIBYTE(v18);
  v21[1] = BYTE2(v18);
  v21[2] = BYTE1(v18);
  v21[3] = v18;
  v21[4] = HIBYTE(a2);
  v21[5] = BYTE2(a2);
  v21[6] = BYTE1(a2);
  v21[7] = a2;
  v21[8] = HIBYTE(a3);
  v21[9] = BYTE2(a3);
  v21[10] = BYTE1(a3);
  v21[11] = a3;
  v21[12] = HIBYTE(a4);
  v21[13] = BYTE2(a4);
  v21[14] = BYTE1(a4);
  v21[15] = a4;
  v21[16] = HIBYTE(a5);
  v21[17] = BYTE2(a5);
  v21[18] = BYTE1(a5);
  v21[19] = a5;
  v21[20] = HIBYTE(v11);
  v21[21] = v11;
  v21[22] = HIBYTE(v10);
  v21[23] = v10;
  v21[24] = a8;
  v21[25] = a9;
  result = _cg_png_write_complete_chunk((void (**)(void))a1, 1717785676, v21, 0x1AuLL);
  ++*(_DWORD *)(a1 + 772);
  return result;
}

uint64_t png_do_write_interlace(uint64_t result, unsigned __int8 *__dst, int a3)
{
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  _BYTE *v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  size_t v25;
  int v26;
  unsigned int v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  unsigned int v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;

  if (a3 > 5)
    return result;
  v4 = result;
  v5 = *(unsigned __int8 *)(result + 19);
  if ((_DWORD)v5 == 4)
  {
    v14 = *(_DWORD *)result;
    v7 = a3;
    v8 = png_do_write_interlace_png_pass_start[a3];
    if (*(_DWORD *)result <= v8)
      goto LABEL_34;
    v9 = 0;
    v15 = png_do_write_interlace_png_pass_inc[a3];
    v16 = 4 * v8;
    v17 = png_do_write_interlace_png_pass_start[a3];
    v18 = 4;
    v13 = __dst;
    do
    {
      result = ~v16 & 4;
      v9 |= ((__dst[(unint64_t)v17 >> 1] >> (~(_BYTE)v16 & 4)) & 0xF) << v18;
      if (v18)
      {
        v18 -= 4;
      }
      else
      {
        *v13++ = v9;
        v18 = 4;
        v9 = 0;
      }
      v17 += v15;
      v16 += 4 * v15;
    }
    while (v17 < v14);
    if (v18 == 4)
      goto LABEL_34;
    goto LABEL_28;
  }
  if ((_DWORD)v5 == 2)
  {
    v19 = *(_DWORD *)result;
    v7 = a3;
    v8 = png_do_write_interlace_png_pass_start[a3];
    if (*(_DWORD *)result <= v8)
      goto LABEL_34;
    v9 = 0;
    v20 = png_do_write_interlace_png_pass_inc[a3];
    v21 = 2 * v8;
    v22 = png_do_write_interlace_png_pass_start[a3];
    v23 = 6;
    v13 = __dst;
    do
    {
      result = ~v21 & 6;
      v9 |= ((__dst[(unint64_t)v22 >> 2] >> (~(_BYTE)v21 & 6)) & 3) << v23;
      if (v23)
      {
        v23 -= 2;
      }
      else
      {
        *v13++ = v9;
        v23 = 6;
        v9 = 0;
      }
      v22 += v20;
      v21 += 2 * v20;
    }
    while (v22 < v19);
    if (v23 == 6)
      goto LABEL_34;
    goto LABEL_28;
  }
  if ((_DWORD)v5 != 1)
  {
    v24 = *(_DWORD *)result;
    v7 = a3;
    v8 = png_do_write_interlace_png_pass_start[a3];
    if (*(_DWORD *)result > v8)
    {
      v25 = v5 >> 3;
      v26 = png_do_write_interlace_png_pass_inc[a3];
      v27 = png_do_write_interlace_png_pass_start[a3];
      v28 = __dst;
      do
      {
        v29 = &__dst[v25 * (unint64_t)v27];
        if (v28 != v29)
          result = (uint64_t)memcpy(v28, v29, v25);
        v28 += v25;
        v27 += v26;
      }
      while (v27 < v24);
    }
    goto LABEL_34;
  }
  v6 = *(_DWORD *)result;
  v7 = a3;
  v8 = png_do_write_interlace_png_pass_start[a3];
  if (*(_DWORD *)result > v8)
  {
    v9 = 0;
    v10 = png_do_write_interlace_png_pass_inc[a3];
    v11 = png_do_write_interlace_png_pass_start[a3];
    v12 = 7;
    v13 = __dst;
    do
    {
      v9 |= ((__dst[(unint64_t)v11 >> 3] >> (~(_BYTE)v11 & 7)) & 1) << v12;
      if (v12)
      {
        --v12;
      }
      else
      {
        *v13++ = v9;
        v12 = 7;
        v9 = 0;
      }
      v11 += v10;
    }
    while (v11 < v6);
    if (v12 != 7)
LABEL_28:
      *v13 = v9;
  }
LABEL_34:
  v30 = (*(_DWORD *)v4 + ~v8 + png_do_write_interlace_png_pass_inc[v7]) / png_do_write_interlace_png_pass_inc[v7];
  *(_DWORD *)v4 = v30;
  v31 = *(unsigned __int8 *)(v4 + 19);
  v32 = (v31 * v30 + 7) >> 3;
  v33 = (v31 >> 3) * (unint64_t)v30;
  if (v31 < 8)
    v33 = v32;
  *(_QWORD *)(v4 + 8) = v33;
  return result;
}

uint64_t png_write_reset(uint64_t result)
{
  *(_DWORD *)(result + 308) = 0;
  *(_BYTE *)(result + 389) = 0;
  *(_DWORD *)(result + 76) &= ~4u;
  return result;
}

uint64_t png_write_reinit(uint64_t a1, unsigned __int8 *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v7;
  uint64_t result;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;
  const char *v12;

  v7 = *(_DWORD *)(a1 + 776);
  if (*(_DWORD *)(a1 + 812))
  {
    if (v7 < a3)
      goto LABEL_10;
  }
  else if (v7 != a3 || *(_DWORD *)(a1 + 780) != a4)
  {
    v12 = "width and/or height in the first frame's fcTL don't match the ones in IHDR";
LABEL_12:
    _cg_png_error((void (**)(void))a1, v12);
  }
  if (*(_DWORD *)(a1 + 780) < a4)
  {
LABEL_10:
    v12 = "width and/or height for a frame greater thanthe ones in IHDR";
    goto LABEL_12;
  }
  result = _cg_png_set_IHDR(a1, (uint64_t)a2, a3, a4, a2[36], a2[37], a2[40], a2[38], a2[39]);
  *(_DWORD *)(a1 + 280) = a3;
  *(_DWORD *)(a1 + 284) = a4;
  v9 = *(unsigned __int8 *)(a1 + 394);
  v10 = v9 >= 8;
  v11 = (v9 >> 3) * (unint64_t)a3;
  if (!v10)
    v11 = (*(unsigned __int8 *)(a1 + 394) * (unint64_t)a3 + 7) >> 3;
  *(_QWORD *)(a1 + 296) = v11;
  *(_DWORD *)(a1 + 292) = a3;
  return result;
}

uint64_t _cg_TIFFReadScanline(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 *v32;
  int v33;
  unint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;

  v9 = a3;
  if (!TIFFCheckRead(a1, 0, a3, a4, a5, a6, a7, a8))
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)(a1 + 92) <= v9)
  {
    TIFFErrorExtR(a1, *(const char **)a1, "%u: Row out of range, max %u", v13, v14, v15, v16, v17, v9);
LABEL_7:
    v20 = _cg_TIFFScanlineSize(a1, v19, v12, v13, v14, v15, v16, v17);
    bzero(a2, v20);
    return 0xFFFFFFFFLL;
  }
  if (*(_WORD *)(a1 + 170) == 2)
  {
    if (*(unsigned __int16 *)(a1 + 130) <= a4)
    {
      TIFFErrorExtR(a1, *(const char **)a1, "%hu: Sample out of range, max %hu", v13, v14, v15, v16, v17, a4);
      goto LABEL_7;
    }
    v18 = v9 / *(_DWORD *)(a1 + 132) + *(_DWORD *)(a1 + 224) * (_DWORD)a4;
  }
  else
  {
    v18 = v9 / *(_DWORD *)(a1 + 132);
  }
  if ((_DWORD)v18 != *(_DWORD *)(a1 + 884) && !TIFFFillStrip(a1, v18, v12, v13, v14, v15, v16, v17))
    goto LABEL_7;
  if (*(_DWORD *)(a1 + 876) > v9)
  {
    if (!*(_QWORD *)(a1 + 1136))
      goto LABEL_31;
    if ((*(_QWORD *)(a1 + 1128) & 0x8000000000000000) != 0)
    {
      *(_DWORD *)(a1 + 884) = -1;
      if ((*(_BYTE *)(a1 + 17) & 2) == 0)
      {
        TIFFErrorExtR(a1, "TIFFFillStripPartial", "Data buffer too small to hold part of strip %d", v13, v14, v15, v16, v17, v18);
        goto LABEL_7;
      }
    }
    *(_QWORD *)(a1 + 1136) = 0;
    *(_QWORD *)(a1 + 1144) = 0;
    v23 = TIFFGetStrileOffset(a1, v18);
    if (!_TIFFSeekOK(a1, *(_QWORD *)(a1 + 1136) + *(_QWORD *)(a1 + 1144) + v23))
    {
      TIFFErrorExtR(a1, "TIFFFillStripPartial", "Seek error at scanline %u, strip %d", v24, v25, v26, v27, v28, *(_DWORD *)(a1 + 876));
      goto LABEL_7;
    }
    v29 = *(_QWORD *)(a1 + 1128) & ~(*(uint64_t *)(a1 + 1128) >> 63);
    if (v29 > TIFFGetStrileByteCount(a1, v18) - (*(_QWORD *)(a1 + 1136) + *(_QWORD *)(a1 + 1144)))
      v29 = TIFFGetStrileByteCount(a1, v18) - (*(_QWORD *)(a1 + 1136) + *(_QWORD *)(a1 + 1144));
    if ((*(_BYTE *)(a1 + 18) & 0x80) != 0)
      _cg_TIFFReadScanline_cold_2();
    if (!TIFFReadAndRealloc(a1, v29, 0, 1, 0, "TIFFFillStripPartial", v30, v31))
      goto LABEL_7;
    *(_QWORD *)(a1 + 1136) += *(_QWORD *)(a1 + 1144);
    *(_QWORD *)(a1 + 1144) = v29;
    *(_QWORD *)(a1 + 1160) = v29;
    v32 = *(unsigned __int8 **)(a1 + 1120);
    *(_QWORD *)(a1 + 1152) = v32;
    v33 = *(_DWORD *)(a1 + 16);
    if (((unsigned __int16)v33 & (*(_WORD *)(a1 + 126) | 0x100)) == 0)
    {
      if ((v33 & 0x800000) != 0)
        _cg_TIFFReadScanline_cold_1();
      TIFFReverseBits(v32, v29);
    }
    if (*(_WORD *)(a1 + 120) == 7
      && (v34 = *(_QWORD *)(a1 + 1160), v34 < TIFFGetStrileByteCount(a1, v18))
      && TIFFJPEGIsFullStripRequired(a1))
    {
      v35 = TIFFFillStrip(a1, v18, v12, v13, v14, v15, v16, v17);
    }
    else
    {
LABEL_31:
      v35 = TIFFStartStrip(a1, v18, v12, v13, v14, v15, v16, v17);
    }
    if (!v35)
      goto LABEL_7;
  }
  v36 = *(_DWORD *)(a1 + 876);
  if (v9 != v36)
  {
    if (!(*(unsigned int (**)(uint64_t, _QWORD))(a1 + 1064))(a1, v9 - v36))
      goto LABEL_7;
    *(_DWORD *)(a1 + 876) = v9;
  }
  v37 = (*(uint64_t (**)(uint64_t, void *, _QWORD, uint64_t))(a1 + 1008))(a1, a2, *(_QWORD *)(a1 + 1104), a4);
  *(_DWORD *)(a1 + 876) = v9 + 1;
  v21 = 0xFFFFFFFFLL;
  if (v37)
  {
    v38 = v37;
    (*(void (**)(uint64_t, void *, _QWORD))(a1 + 1248))(a1, a2, *(_QWORD *)(a1 + 1104));
    if (v38 < 1)
      return 0xFFFFFFFFLL;
    else
      return 1;
  }
  return v21;
}

uint64_t TIFFReadRawStrip1(uint64_t a1, uint64_t a2, void *a3, size_t a4, const char *a5)
{
  int v5;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int64_t v28;
  size_t v29;
  size_t v30;
  size_t v31;

  v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x20000) != 0)
    TIFFReadRawStrip1_cold_1();
  v11 = TIFFGetStrileOffset(a1, a2);
  if ((v5 & 0x800) != 0)
  {
    if (v11 < 0)
    {
      v27 = 0;
      v31 = 0;
    }
    else
    {
      v27 = TIFFGetStrileOffset(a1, a2);
      v28 = *(_QWORD *)(a1 + 1176);
      if ((uint64_t)(v27 + a4) <= v28)
        v29 = a4;
      else
        v29 = v28 - v27;
      if (v27 <= (uint64_t)(a4 ^ 0x7FFFFFFFFFFFFFFFLL))
        v30 = v29;
      else
        v30 = 0;
      if (v28 >= v27)
        v31 = v30;
      else
        v31 = 0;
    }
    if (v31 != a4)
    {
      TIFFErrorExtR(a1, a5, "Read error at scanline %u, strip %u; got %lld bytes, expected %lld",
        v12,
        v13,
        v14,
        v15,
        v16,
        *(_DWORD *)(a1 + 876));
      return -1;
    }
    _TIFFmemcpy(a3, (const void *)(*(_QWORD *)(a1 + 1168) + v27), a4);
  }
  else
  {
    if (!_TIFFSeekOK(a1, v11))
    {
      TIFFErrorExtR(a1, a5, "Seek error at scanline %u, strip %u", v17, v18, v19, v20, v21, *(_DWORD *)(a1 + 876));
      return -1;
    }
    if ((*(uint64_t (**)(_QWORD, void *, size_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), a3, a4) != a4)
    {
      TIFFErrorExtR(a1, a5, "Read error at scanline %u; got %lld bytes, expected %lld",
        v22,
        v23,
        v24,
        v25,
        v26,
        *(_DWORD *)(a1 + 876));
      return -1;
    }
  }
  return a4;
}

uint64_t _TIFFReadEncodedStripAndAllocBuffer(uint64_t a1, uint64_t a2, _QWORD *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void *v12;
  uint64_t StripSize;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  unsigned __int16 v37;

  v8 = a5;
  v12 = (void *)*a3;
  if (v12)
    return _cg_TIFFReadEncodedStrip(a1, a2, v12, a5, a5, a6, a7, a8);
  v37 = 0;
  StripSize = TIFFReadEncodedStripGetStripSize((_DWORD *)a1, a2, &v37, a4, a5, a6, a7, a8);
  if (StripSize == -1)
    return -1;
  if (StripSize <= v8 || v8 == -1)
    v8 = StripSize;
  if (!TIFFFillStrip(a1, a2, v16, v17, v18, v19, v20, v21))
    return -1;
  v29 = _TIFFmallocExt((_QWORD *)a1, a4, v23, v24, v25, v26, v27, v28);
  *a3 = v29;
  if (!v29)
  {
    v30 = (const char *)TIFFFileName(a1);
    TIFFErrorExtR(a1, v30, "No space for strip buffer", v31, v32, v33, v34, v35, v36);
    return -1;
  }
  _TIFFmemset(v29, 0, a4);
  if ((*(int (**)(uint64_t, _QWORD, uint64_t, _QWORD))(a1 + 1024))(a1, *a3, v8, v37) < 1)
    return -1;
  (*(void (**)(uint64_t, _QWORD, uint64_t))(a1 + 1248))(a1, *a3, v8);
  return v8;
}

uint64_t TIFFReadBufferSetup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;

  v8 = *(_DWORD *)(a1 + 16);
  if ((v8 & 0x20000) != 0)
    TIFFReadBufferSetup_cold_1();
  *(_DWORD *)(a1 + 16) = v8 & 0xFF7FFFFF;
  v12 = *(char **)(a1 + 1120);
  if (v12)
  {
    v13 = (_QWORD *)(a1 + 1120);
    if ((v8 & 0x200) != 0)
      _TIFFfreeExt(a1, v12);
    *v13 = 0;
    *(_QWORD *)(a1 + 1128) = 0;
  }
  if (a2)
  {
    *(_QWORD *)(a1 + 1128) = a3;
    *(_QWORD *)(a1 + 1120) = a2;
    *(_DWORD *)(a1 + 16) &= ~0x200u;
    return 1;
  }
  else
  {
    v16 = (a3 + 1023) & 0xFFFFFFFFFFFFFC00;
    *(_QWORD *)(a1 + 1128) = v16;
    if (v16)
    {
      v14 = 1;
      v17 = _TIFFcallocExt((_QWORD *)a1, 1, v16, a4, a5, a6, a7, a8);
      *(_QWORD *)(a1 + 1120) = v17;
      *(_DWORD *)(a1 + 16) |= 0x200u;
      if (!v17)
      {
        TIFFErrorExtR(a1, "TIFFReadBufferSetup", "No space for data buffer at scanline %u", v18, v19, v20, v21, v22, *(_DWORD *)(a1 + 876));
        v14 = 0;
        *(_QWORD *)(a1 + 1128) = 0;
      }
    }
    else
    {
      TIFFErrorExtR(a1, "TIFFReadBufferSetup", "Invalid buffer size", a4, a5, a6, a7, a8, v23);
      return 0;
    }
  }
  return v14;
}

uint64_t _cg_TIFFReadTileWithSize(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int v11;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v10 = a5;
  v11 = a4;
  if (!TIFFCheckRead(a1, 1, a3, a4, a5, a6, a7, a8)
    || !TIFFCheckTile(a1, v11, v10, a6, a7, v15, v16, v17))
  {
    return -1;
  }
  v18 = _cg_TIFFComputeTile(a1, v11, v10, a6, a7);
  return TIFFReadEncodedTile(a1, v18, a2, a3, v19, v20, v21, v22);
}

uint64_t TIFFReadEncodedTile(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;

  v12 = *(_QWORD *)(a1 + 936);
  if (!TIFFCheckRead(a1, 1, (uint64_t)a3, a4, a5, a6, a7, a8))
    return -1;
  if (*(_DWORD *)(a1 + 228) <= a2)
  {
    TIFFErrorExtR(a1, "TIFFReadEncodedTile", "%u: Tile out of range, max %u", v14, v15, v16, v17, v18, a2);
    return -1;
  }
  if (a4 != -1 && *(_WORD *)(a1 + 120) == 1 && v12 <= a4 && (*(_DWORD *)(a1 + 16) & 0x20800) == 0)
  {
    if (TIFFReadRawTile1(a1, a2, a3, v12, "TIFFReadEncodedTile") == v12)
    {
      if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0)
        TIFFReverseBits(a3, v12);
      goto LABEL_14;
    }
    return -1;
  }
  if (v12 >= a4)
    v19 = a4;
  else
    v19 = v12;
  if (a4 != -1)
    v12 = v19;
  if (!TIFFFillTile(a1, a2, v13, v14, v15, v16, v17, v18))
  {
    bzero(a3, v12);
    return -1;
  }
  if (!(*(unsigned int (**)(uint64_t, unsigned __int8 *, int64_t, _QWORD))(a1 + 1040))(a1, a3, v12, (unsigned __int16)(a2 / *(_DWORD *)(a1 + 224))))return -1;
LABEL_14:
  (*(void (**)(uint64_t, unsigned __int8 *, int64_t))(a1 + 1248))(a1, a3, v12);
  return v12;
}

uint64_t _cg_TIFFReadTile(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _cg_TIFFReadTileWithSize(a1, a2, -1, a3, a4, a5, a6, a8);
}

uint64_t TIFFReadRawTile1(uint64_t a1, uint64_t a2, void *a3, size_t a4, const char *a5)
{
  int v5;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int64_t v27;
  int64_t v28;

  v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x20000) != 0)
    TIFFReadRawTile1_cold_1();
  v11 = TIFFGetStrileOffset(a1, a2);
  if ((v5 & 0x800) != 0)
  {
    if (TIFFGetStrileOffset(a1, a2) < 0 || (v27 = *(_QWORD *)(a1 + 1176), v28 = v27 - v11, v27 < v11))
    {
      v28 = 0;
    }
    else if ((a4 & 0x8000000000000000) == 0 && (v11 & 0x8000000000000000) == 0 && (uint64_t)(v11 + a4) <= v27)
    {
      goto LABEL_16;
    }
    if (v28 != a4)
    {
      TIFFErrorExtR(a1, a5, "Read error at row %u, col %u, tile %u; got %lld bytes, expected %lld",
        v22,
        v23,
        v24,
        v25,
        v26,
        *(_DWORD *)(a1 + 876));
      return -1;
    }
LABEL_16:
    _TIFFmemcpy(a3, (const void *)(*(_QWORD *)(a1 + 1168) + v11), a4);
    return a4;
  }
  if (!_TIFFSeekOK(a1, v11))
  {
    TIFFErrorExtR(a1, a5, "Seek error at row %u, col %u, tile %u", v12, v13, v14, v15, v16, *(_DWORD *)(a1 + 876));
    return -1;
  }
  if ((*(uint64_t (**)(_QWORD, void *, size_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), a3, a4) != a4)
  {
    TIFFErrorExtR(a1, a5, "Read error at row %u, col %u; got %lld bytes, expected %lld",
      v17,
      v18,
      v19,
      v20,
      v21,
      *(_DWORD *)(a1 + 876));
    return -1;
  }
  return a4;
}

uint64_t TIFFFillTile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  int64_t v22;
  uint64_t v23;
  unsigned __int8 *v24;
  char *v26;
  uint64_t v27;

  if ((*(_BYTE *)(a1 + 18) & 2) == 0)
  {
    v10 = TIFFGetStrileByteCount(a1, a2);
    v18 = v10;
    if (v10 <= 0)
    {
      TIFFErrorExtR(a1, "TIFFFillTile", "%llu: Invalid tile byte count, tile %u", v13, v14, v15, v16, v17, v10);
      return 0;
    }
    if ((unint64_t)v10 > 0x100000)
    {
      v19 = _cg_TIFFTileSize(a1, v11, v12, v13, v14, v15, v16, v17);
      if (v19)
      {
        if (v19 < (v18 - 4096) / 0xAuLL)
        {
          v20 = 10 * v19 + 4096;
          TIFFErrorExtR(a1, "TIFFFillTile", "Too large tile byte count %llu, tile %u. Limiting to %llu", v13, v14, v15, v16, v17, v18);
          v18 = v20;
        }
      }
    }
    v21 = *(_DWORD *)(a1 + 16);
    if ((v21 & 0x800) != 0)
    {
      if ((unint64_t)v18 > *(_QWORD *)(a1 + 1176)
        || TIFFGetStrileOffset(a1, a2) > (unint64_t)(*(_QWORD *)(a1 + 1176) - v18))
      {
        *(_DWORD *)(a1 + 932) = -1;
        return 0;
      }
      v21 = *(_DWORD *)(a1 + 16);
      if ((v21 & 0x800) != 0 && ((unsigned __int16)v21 & (*(_WORD *)(a1 + 126) | 0x100)) != 0)
      {
        if ((v21 & 0x200) != 0)
        {
          v26 = *(char **)(a1 + 1120);
          if (v26)
          {
            _TIFFfreeExt(a1, v26);
            *(_QWORD *)(a1 + 1120) = 0;
            v21 = *(_DWORD *)(a1 + 16);
          }
        }
        *(_DWORD *)(a1 + 16) = v21 & 0xFFFFFDFF;
        *(_QWORD *)(a1 + 1128) = v18;
        v27 = *(_QWORD *)(a1 + 1168);
        *(_QWORD *)(a1 + 1120) = v27 + TIFFGetStrileOffset(a1, a2);
        *(_QWORD *)(a1 + 1136) = 0;
        *(_QWORD *)(a1 + 1144) = v18;
        *(_DWORD *)(a1 + 16) |= 0x800000u;
        return TIFFStartTile(a1, a2, a3, a4, a5, a6, a7, a8);
      }
    }
    v22 = *(_QWORD *)(a1 + 1128);
    if (v18 > v22)
    {
      *(_DWORD *)(a1 + 932) = -1;
      if ((v21 & 0x200) == 0)
      {
        TIFFErrorExtR(a1, "TIFFFillTile", "Data buffer too small to hold tile %u", v13, v14, v15, v16, v17, a2);
        return 0;
      }
    }
    if ((v21 & 0x800000) != 0)
    {
      v22 = 0;
      *(_DWORD *)(a1 + 932) = -1;
      v21 &= ~0x800000u;
      *(_OWORD *)(a1 + 1120) = 0u;
      *(_DWORD *)(a1 + 16) = v21;
    }
    if ((v21 & 0x800) != 0)
    {
      if (v18 > v22 && !TIFFReadBufferSetup(a1, 0, v18, v13, v14, v15, v16, v17))
        return 0;
      v23 = TIFFReadRawTile1(a1, a2, *(void **)(a1 + 1120), v18, "TIFFFillTile");
    }
    else
    {
      v23 = TIFFReadRawStripOrTile2(a1, a2, 0, v18, "TIFFFillTile");
    }
    if (v23 != v18)
      return 0;
    *(_QWORD *)(a1 + 1136) = 0;
    *(_QWORD *)(a1 + 1144) = v18;
    v24 = *(unsigned __int8 **)(a1 + 1120);
    if (v24)
    {
      if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0)
        TIFFReverseBits(v24, v18);
    }
  }
  return TIFFStartTile(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t _TIFFReadTileAndAllocBuffer(uint64_t a1, unsigned __int8 **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned int v11;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v10 = a5;
  v11 = a4;
  if (!TIFFCheckRead(a1, 1, a3, a4, a5, a6, a7, a8)
    || !TIFFCheckTile(a1, v11, v10, a6, a7, v15, v16, v17))
  {
    return -1;
  }
  v18 = _cg_TIFFComputeTile(a1, v11, v10, a6, a7);
  return _TIFFReadEncodedTileAndAllocBuffer(a1, v18, a2, a3, -1, v19, v20, v21);
}

uint64_t _TIFFReadEncodedTileAndAllocBuffer(uint64_t a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *v12;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  BOOL v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int8 *v46;
  uint64_t v47;
  char v48;

  v12 = *a3;
  if (v12)
    return TIFFReadEncodedTile(a1, a2, v12, a5, a5, a6, a7, a8);
  v15 = *(_QWORD *)(a1 + 936);
  if (!TIFFCheckRead(a1, 1, 0, a4, a5, a6, a7, a8))
    return -1;
  if (*(_DWORD *)(a1 + 228) <= a2)
  {
    v35 = "_TIFFReadEncodedTileAndAllocBuffer";
    v48 = a2;
    v36 = "%u: Tile out of range, max %u";
LABEL_12:
    TIFFErrorExtR(a1, v35, v36, v17, v18, v19, v20, v21, v48);
    return -1;
  }
  if (!TIFFFillTile(a1, a2, v16, v17, v18, v19, v20, v21))
    return -1;
  v28 = *(unsigned __int16 *)(a1 + 120);
  if (v28 == 50002)
  {
    if (*(_WORD *)(a1 + 170) == 1)
      v38 = 25000 * *(unsigned __int16 *)(a1 + 130);
    else
      v38 = 25000;
    goto LABEL_22;
  }
  if (v28 == 50000)
  {
    v38 = 33000;
    goto LABEL_22;
  }
  if (v28 != 1)
  {
    v39 = v28 == 34925;
    v38 = 1000;
    if (v39)
      v38 = 7000;
LABEL_22:
    if (a4 >= 100000001 && *(_QWORD *)(a1 + 1128) < v15 / v38)
    {
      v40 = (const char *)TIFFFileName(a1);
      TIFFErrorExtR(a1, v40, "Likely invalid tile byte count for tile %u. Uncompressed tile size is %llu, compressed one is %llu", v41, v42, v43, v44, v45, a2);
      return -1;
    }
    goto LABEL_25;
  }
  if (*(_QWORD *)(a1 + 1128) != v15)
  {
    v29 = (const char *)TIFFFileName(a1);
    TIFFErrorExtR(a1, v29, "Invalid tile byte count for tile %u. Expected %llu, got %llu", v30, v31, v32, v33, v34, a2);
    return -1;
  }
LABEL_25:
  v46 = (unsigned __int8 *)_TIFFmallocExt((_QWORD *)a1, a4, v22, v23, v24, v25, v26, v27);
  *a3 = v46;
  if (!v46)
  {
    v35 = (const char *)TIFFFileName(a1);
    v36 = "No space for tile buffer";
    goto LABEL_12;
  }
  _TIFFmemset(v46, 0, a4);
  if (v15 >= a5)
    v47 = a5;
  else
    v47 = v15;
  if (a5 == -1)
    v37 = v15;
  else
    v37 = v47;
  if ((*(unsigned int (**)(uint64_t, unsigned __int8 *, uint64_t, _QWORD))(a1 + 1040))(a1, *a3, v37, (unsigned __int16)(a2 / *(_DWORD *)(a1 + 224))))
  {
    (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(a1 + 1248))(a1, *a3, v37);
    return v37;
  }
  return -1;
}

uint64_t TIFFStartTile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  char *v18;
  uint64_t v20;
  char v21;

  v10 = *(_DWORD *)(a1 + 16);
  if ((v10 & 0x20) == 0)
  {
    if (!(*(unsigned int (**)(uint64_t))(a1 + 960))(a1))
      return 0;
    v10 = *(_DWORD *)(a1 + 16) | 0x20;
    *(_DWORD *)(a1 + 16) = v10;
  }
  *(_DWORD *)(a1 + 932) = a2;
  v11 = *(_DWORD *)(a1 + 100);
  if (!v11)
  {
    v18 = "Zero tilewidth";
    goto LABEL_11;
  }
  v12 = *(_DWORD *)(a1 + 88);
  if (v12 >= -v11
    || (v13 = v11 + v12 - 1, v11 > v13)
    || (v14 = a2 % (v13 / v11),
        v15 = *(_DWORD *)(a1 + 104),
        *(_DWORD *)(a1 + 876) = v15 * v14,
        v16 = *(_DWORD *)(a1 + 92),
        v16 >= -v15)
    || (v17 = v15 + v16 - 1, v15 > v17))
  {
    v18 = "Zero tiles";
LABEL_11:
    TIFFErrorExtR(a1, "TIFFStartTile", v18, a4, a5, a6, a7, a8, v21);
    return 0;
  }
  *(_DWORD *)(a1 + 928) = a2 % (v17 / v15) * v11;
  *(_DWORD *)(a1 + 16) = v10 & 0xFFEFFFFF;
  if ((v10 & 0x20000) != 0)
  {
    *(_OWORD *)(a1 + 1152) = 0u;
  }
  else
  {
    *(_QWORD *)(a1 + 1152) = *(_QWORD *)(a1 + 1120);
    v20 = *(_QWORD *)(a1 + 1144);
    if (v20 < 1)
      *(_QWORD *)(a1 + 1160) = TIFFGetStrileByteCount(a1, a2);
    else
      *(_QWORD *)(a1 + 1160) = v20;
  }
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 968))(a1, (unsigned __int16)(a2 / *(_DWORD *)(a1 + 224)));
}

uint64_t _TIFFSwab16BitData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if ((a3 & 1) != 0)
    _TIFFSwab16BitData_cold_1();
  if (a3 >= 0)
    v3 = a3;
  else
    v3 = a3 + 1;
  return TIFFSwabArrayOfShort(a2, v3 >> 1);
}

uint64_t _TIFFSwab24BitData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 3 * (a3 / 3))
    _TIFFSwab24BitData_cold_1();
  return TIFFSwabArrayOfTriples(a2, a3 / 3);
}

__int32 *_TIFFSwab32BitData(uint8x8_t a1, uint64_t a2, __int32 *a3, uint64_t a4)
{
  if ((a4 & 3) != 0)
    _TIFFSwab32BitData_cold_1();
  return TIFFSwabArrayOfLong(a3, a4 / 4, a1);
}

int8x8_t *_TIFFSwab64BitData(uint64_t a1, int8x8_t *a2, uint64_t a3)
{
  if ((a3 & 7) != 0)
    _TIFFSwab64BitData_cold_1();
  return TIFFSwabArrayOfLong8(a2, a3 / 8);
}

uint64_t IIO_Reader_WebP::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  WebPReadPlugin::WebPReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FF8E70(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40EF6C0303);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_WebP::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  WebPReadPlugin::WebPReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187FF8F0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40EF6C0303);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_WebP::validateVP8_VP8L(IIO_Reader_WebP *this, IIOScanner *a2, unsigned int a3, int a4)
{
  uint64_t v4;
  double v7;
  char v8;
  int v9;
  uint64_t result;
  _BYTE *v11;
  int v12;
  _OWORD v13[2];
  uint64_t v14;

  v4 = *((_QWORD *)a2 + 3);
  if (v4 + (unint64_t)a3 - 8 > *((_QWORD *)a2 + 2))
  {
    _cg_jpeg_mem_term("validateVP8_VP8L", 80, "*** ERROR: bad 'VP8/VP8L' chunkSize\n");
    return 1;
  }
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  WebPGetFeaturesInternal(*((_QWORD *)a2 + 1) + v4 - 8, a3, (uint64_t)v13, 521);
  if (*((_BYTE *)this + 116))
  {
    ++*((_DWORD *)this + (a4 != 1448097824) + 22);
    if (a4 == 1448097868)
    {
      v8 = *((_BYTE *)this + 117);
      if (v8)
      {
        _cg_jpeg_mem_term("validateVP8_VP8L", 90, "ERROR: VP8L and ALPH sub-chunks in ANMF are not allowed\n");
        v8 = 1;
      }
    }
    else
    {
      v8 = 0;
    }
    if (*(_QWORD *)&v13[0] != *(_QWORD *)((char *)this + 108))
    {
      _cg_jpeg_mem_term("validateVP8_VP8L", 95, "ERROR: frame size VP8/VP8L sub-chunk does not match ANMF header frame size\n");
      v12 = *((unsigned __int8 *)this + 119);
      v11 = (char *)this + 119;
      if (!v12)
      {
LABEL_19:
        result = 0;
        *v11 = 1;
        return result;
      }
LABEL_18:
      _cg_jpeg_mem_term("validateVP8_VP8L", 101, "ERROR: more than one VP8/VP8L chunks in ANMF are not allowed\n");
      goto LABEL_19;
    }
    if (*((_BYTE *)this + 119))
    {
      v11 = (char *)this + 119;
      goto LABEL_18;
    }
    *((_BYTE *)this + 119) = 1;
    if ((v8 & 1) == 0)
      goto LABEL_24;
    return 0;
  }
  if (*((_DWORD *)this + 13) || *((_DWORD *)this + 14))
  {
    *(_QWORD *)&v7 = _cg_jpeg_mem_term("validateVP8_VP8L", 111, "*** ERROR: multiple VP8/VP8L chunks not allowed\n").n128_u64[0];
    v9 = 0;
  }
  else
  {
    v9 = 1;
  }
  if (*((_DWORD *)this + 17) || *((_DWORD *)this + 18))
  {
    _cg_jpeg_mem_term("validateVP8_VP8L", 117, "*** ERROR: VP8/VP8L and ANIM/ANMF chunks are not allowed\n", v7);
    return 0;
  }
  if (!v9)
    return 0;
LABEL_24:
  ++*((_DWORD *)this + 26);
  return 1;
}

BOOL IIO_Reader_WebP::validateALPH(IIO_Reader_WebP *this, IIOScanner *a2)
{
  _BOOL8 v3;

  if (*((_BYTE *)this + 116))
  {
    ++*((_DWORD *)this + 24);
    v3 = *((_BYTE *)this + 118) == 0;
    if (*((_BYTE *)this + 118))
      _cg_jpeg_mem_term("validateALPH", 153, "*** ERROR: more than one ALPH sub-chunks in an ANMF chunk\n");
    *((_BYTE *)this + 118) = 1;
    if (*((_BYTE *)this + 119))
    {
      _cg_jpeg_mem_term("validateALPH", 160, "*** ERROR: ALPHA sub-chunk detected after VP8 sub-chunk in an ANMF chunk\n");
      return 0;
    }
  }
  else
  {
    if (*((_DWORD *)this + 17) || *((_DWORD *)this + 18))
    {
      _cg_jpeg_mem_term("validateALPH", 168, "*** ERROR: ALPHA chunk and ANIM/ANMF chunk are both detected\n");
      v3 = 0;
    }
    else
    {
      v3 = 1;
    }
    if (!*((_DWORD *)this + 15))
    {
      _cg_jpeg_mem_term("validateALPH", 173, "*** ERROR: ALPHA chunk detected before VP8X chunk\n");
      v3 = 0;
    }
    if (*((_DWORD *)this + 13))
    {
      _cg_jpeg_mem_term("validateALPH", 178, "*** ERROR: ALPHA chunk detected after VP8 chunk\n");
      v3 = 0;
    }
    if (*((_DWORD *)this + 16))
    {
      _cg_jpeg_mem_term("validateALPH", 183, "*** ERROR: Multiple ALPHA chunks detected\n");
      return 0;
    }
  }
  return v3;
}

BOOL IIO_Reader_WebP::validateANMF(IIO_Reader_WebP *this, IIOScanner *a2, unsigned int a3)
{
  _BOOL8 v6;

  v6 = *((_BYTE *)this + 116) == 0;
  if (*((_BYTE *)this + 116))
    _cg_jpeg_mem_term("validateANMF", 211, "ERROR: nested ANMF chunks are not allowed\n");
  if (!*((_DWORD *)this + 17))
  {
    _cg_jpeg_mem_term("validateANMF", 216, "*** ERROR: ANMF without ANIM are not allowed\n");
    v6 = 0;
  }
  if (a3 > 0x10)
  {
    IIOScanner::getVal24(a2);
    IIOScanner::getVal24(a2);
    *((_DWORD *)this + 27) = IIOScanner::getVal24(a2) + 1;
    *((_DWORD *)this + 28) = IIOScanner::getVal24(a2) + 1;
    IIOScanner::getVal24(a2);
    *((_QWORD *)this + 11) = 0;
    *((_DWORD *)this + 24) = 0;
    *((_WORD *)this + 59) = 0;
  }
  else
  {
    _cg_jpeg_mem_term("validateANMF", 232, "*** ERROR: ANMF chunk size too small (%d)\n", a3);
    v6 = 0;
  }
  *((_BYTE *)this + 116) = 1;
  return v6;
}

BOOL IIO_Reader_WebP::validateICCP(IIO_Reader_WebP *this, IIOScanner *a2)
{
  int v3;
  _BOOL8 v4;

  v3 = *((_DWORD *)this + 15);
  v4 = v3 != 0;
  if (!v3)
    _cg_jpeg_mem_term("validateICCP", 260, "*** ERROR: ICCP chunk detected before VP8X chunk.");
  if (*((_DWORD *)this + 13) || *((_DWORD *)this + 14) || *((_DWORD *)this + 17))
  {
    _cg_jpeg_mem_term("validateICCP", 267, "*** ERROR: ICCP chunk detected after image data.");
    return 0;
  }
  return v4;
}

BOOL IIO_Reader_WebP::validateWebP(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v5;
  BOOL v6;
  int Val32;
  unint64_t v8;
  int OSType;
  unint64_t v11;
  BOOL v12;
  int v13;
  IIOScanner *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  int v19;
  unsigned int v20;
  BOOL v21;
  int v22;
  BOOL v23;
  _BOOL8 v24;
  unint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v38;
  int v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;

  v65 = 0;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v61, *(unsigned __int8 **)a3, *(_QWORD *)(a3 + 8), 1);
  *(_OWORD *)(a1 + 52) = 0u;
  v5 = (_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + 68) = 0u;
  *(_QWORD *)(a1 + 100) = 0;
  *(_WORD *)(a1 + 116) = 0;
  v6 = IIOScanner::getOSType((IIOScanner *)&v61) == 1380533830;
  Val32 = IIOScanner::getVal32((IIOScanner *)&v61);
  v8 = (Val32 + 8);
  if ((unint64_t)v62 >= v8)
  {
    if ((unint64_t)v62 > v8)
    {
      _cg_jpeg_mem_term("validateWebP", 318, "*** webP contains additional data (%d bytes) - original: '%d'   new: '%d'\n", (_DWORD)v62 - v8, (_DWORD)v62, Val32 + 8);
      if ((unint64_t)v62 > v8)
        *(_QWORD *)&v62 = v8;
    }
  }
  else
  {
    v6 = 0;
  }
  if (IIOScanner::getOSType((IIOScanner *)&v61) != 1464156752 || !v6)
  {
    v24 = 0;
    v11 = _cg_jpeg_mem_term("validateWebP", 325, "*** ERROR: bad webp header\n").n128_u64[0];
    goto LABEL_86;
  }
  OSType = IIOScanner::getOSType((IIOScanner *)&v61);
  v12 = 1;
  while (1)
  {
    if (!OSType)
    {
      v24 = v12;
      goto LABEL_86;
    }
    v13 = IIOScanner::getVal32((IIOScanner *)&v61);
    v15 = (v13 + 8);
    v16 = *((_QWORD *)&v62 + 1) - 8;
    if (*(_QWORD *)(a3 + 8) <= v15)
      break;
    if ((v13 & 1) != 0)
      v17 = (v13 + 9);
    else
      v17 = v15;
    if (v16 + v17 > (unint64_t)v62)
    {
      v40 = OSType >> 24;
      if (OSType < 0)
        v41 = __maskrune(OSType >> 24, 0x40000uLL);
      else
        v41 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v40 + 60) & 0x40000;
      if (v41)
        v51 = v40;
      else
        v51 = 46;
      v52 = OSType << 8 >> 24;
      if (OSType << 8 < 0)
        v53 = __maskrune(OSType << 8 >> 24, 0x40000uLL);
      else
        v53 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v52 + 60) & 0x40000;
      if (v53)
        v54 = v52;
      else
        v54 = 46;
      v55 = (__int16)OSType >> 8;
      if (OSType << 16 < 0)
        v56 = __maskrune((__int16)OSType >> 8, 0x40000uLL);
      else
        v56 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v55 + 60) & 0x40000;
      if ((OSType << 24) <= 0x7F000000)
        v57 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)OSType + 60) & 0x40000;
      else
        v57 = __maskrune((char)OSType, 0x40000uLL);
      if (v56)
        v58 = v55;
      else
        v58 = 46;
      if (v57)
        v59 = (char)OSType;
      else
        v59 = 46;
      v11 = _cg_jpeg_mem_term("validateWebP", 340, "*** ERROR: bad chunk size [%d,%d] for '%c%c%c%c' (%d bytes)\n", v16, v17, v51, v54, v58, v59, (_DWORD)v62).n128_u64[0];
      goto LABEL_139;
    }
    if (OSType <= 1229144911)
    {
      if (OSType > 1095650629)
      {
        if (OSType == 1095650630)
        {
          v23 = IIO_Reader_WebP::validateANMF((IIO_Reader_WebP *)a1, (IIOScanner *)&v61, v17);
          *(_DWORD *)(a1 + 100) = v17 - 24;
          ++*(_DWORD *)(a1 + 72);
          LODWORD(v17) = 24;
          v12 = v23;
          goto LABEL_54;
        }
        if (OSType != 1163413830)
          goto LABEL_57;
        ++*(_DWORD *)(a1 + 80);
        goto LABEL_35;
      }
      if (OSType != 1095520328)
      {
        if (OSType == 1095649613)
        {
          if ((_DWORD)v17 != 14)
            v11 = _cg_jpeg_mem_term("validateANIM", 197, "*** ERROR: corrupt ANIM chunk (%d bytes, expected: %d)\n", v17, 14).n128_u64[0];
          v12 = (_DWORD)v17 == 14;
          ++*(_DWORD *)(a1 + 68);
          goto LABEL_45;
        }
LABEL_57:
        v26 = OSType >> 24;
        if (OSType < 0)
          v27 = __maskrune(OSType >> 24, 0x40000uLL);
        else
          v27 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v26 + 60) & 0x40000;
        if (v27)
          v28 = v26;
        else
          v28 = 46;
        v29 = OSType << 8 >> 24;
        v60 = v28;
        if (OSType << 8 < 0)
          v30 = __maskrune(OSType << 8 >> 24, 0x40000uLL);
        else
          v30 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v29 + 60) & 0x40000;
        if (v30)
          v31 = v29;
        else
          v31 = 46;
        v32 = (__int16)OSType >> 8;
        if (OSType << 16 < 0)
          v33 = __maskrune((__int16)OSType >> 8, 0x40000uLL);
        else
          v33 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v32 + 60) & 0x40000;
        if ((OSType << 24) <= 0x7F000000)
          v34 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)OSType + 60) & 0x40000;
        else
          v34 = __maskrune((char)OSType, 0x40000uLL);
        if (v33)
          v35 = v32;
        else
          v35 = 46;
        if (v34)
          v36 = (char)OSType;
        else
          v36 = 46;
        v11 = _cg_jpeg_mem_term("validateWebP", 385, "*** ERROR: unknown chunk '%c%c%c%c' at offset 0x%08x  size: %d\n", v60, v31, v35, v36, v16, v17).n128_u64[0];
        if (!(_DWORD)v17)
          v12 = 0;
        v5 = (_DWORD *)(a1 + 52);
        goto LABEL_45;
      }
      v18 = IIO_Reader_WebP::validateALPH((IIO_Reader_WebP *)a1, v14);
      ++*(_DWORD *)(a1 + 64);
      goto LABEL_44;
    }
    if (OSType <= 1448097867)
    {
      if (OSType == 1229144912)
      {
        v18 = IIO_Reader_WebP::validateICCP((IIO_Reader_WebP *)a1, v14);
        ++*(_DWORD *)(a1 + 76);
      }
      else
      {
        if (OSType != 1448097824)
          goto LABEL_57;
        v18 = IIO_Reader_WebP::validateVP8_VP8L((IIO_Reader_WebP *)a1, (IIOScanner *)&v61, v17, 1448097824);
        ++*v5;
      }
      goto LABEL_44;
    }
    if (OSType == 1448097868)
    {
      v18 = IIO_Reader_WebP::validateVP8_VP8L((IIO_Reader_WebP *)a1, (IIOScanner *)&v61, v17, 1448097868);
      ++*(_DWORD *)(a1 + 56);
LABEL_44:
      v12 = v18;
      goto LABEL_45;
    }
    if (OSType != 1448097880)
    {
      if (OSType != 1481461792)
        goto LABEL_57;
      ++*(_DWORD *)(a1 + 84);
LABEL_35:
      v12 = 1;
      goto LABEL_45;
    }
    if (*v5 || *(_DWORD *)(a1 + 56) || (v19 = *(_DWORD *)(a1 + 60)) != 0)
    {
      v11 = _cg_jpeg_mem_term("validateVP8X", 136, "*** ERROR: 'VP8X' - not allowed - VP8/VP8L/VP8X already present\n").n128_u64[0];
      v12 = 0;
      v19 = *(_DWORD *)(a1 + 60);
    }
    else
    {
      v12 = 1;
    }
    *(_DWORD *)(a1 + 60) = v19 + 1;
LABEL_45:
    if (*(_BYTE *)(a1 + 116))
    {
      v20 = *(_DWORD *)(a1 + 100);
      v21 = v20 >= v17;
      v22 = v20 - v17;
      if (v22)
      {
        if (v22 != 0 && v21)
          *(_DWORD *)(a1 + 100) = v22;
      }
      else
      {
        if (!*(_BYTE *)(a1 + 119))
        {
          v11 = _cg_jpeg_mem_term("validateWebP", 397, "*** ERROR: no VP8/VP8L chunk detected in ANMF chunk\n", *(double *)&v11).n128_u64[0];
          v12 = 0;
        }
        *(_BYTE *)(a1 + 116) = 0;
      }
    }
LABEL_54:
    v24 = v12;
    if (!v12)
      goto LABEL_86;
    v25 = v16 + v17;
    if (v25 >= (unint64_t)v62)
      goto LABEL_86;
    IIOScanner::seek((IIOScanner *)&v61, v25);
    OSType = IIOScanner::getOSType((IIOScanner *)&v61);
  }
  v38 = OSType >> 24;
  if (OSType < 0)
    v39 = __maskrune(OSType >> 24, 0x40000uLL);
  else
    v39 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v38 + 60) & 0x40000;
  if (v39)
    v42 = v38;
  else
    v42 = 46;
  v43 = OSType << 8 >> 24;
  if (OSType << 8 < 0)
    v44 = __maskrune(OSType << 8 >> 24, 0x40000uLL);
  else
    v44 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v43 + 60) & 0x40000;
  if (v44)
    v45 = v43;
  else
    v45 = 46;
  v46 = (__int16)OSType >> 8;
  if (OSType << 16 < 0)
    v47 = __maskrune((__int16)OSType >> 8, 0x40000uLL);
  else
    v47 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v46 + 60) & 0x40000;
  if ((OSType << 24) <= 0x7F000000)
    v48 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)OSType + 60) & 0x40000;
  else
    v48 = __maskrune((char)OSType, 0x40000uLL);
  if (v47)
    v49 = v46;
  else
    v49 = 46;
  if (v48)
    v50 = (char)OSType;
  else
    v50 = 46;
  v11 = _cg_jpeg_mem_term("validateWebP", 335, "*** ERROR: bad chunk size [%d,%d] for '%c%c%c%c' (%d bytes)\n", v16, v15, v42, v45, v49, v50, (_DWORD)v62).n128_u64[0];
LABEL_139:
  v24 = 0;
LABEL_86:
  if (!*(_DWORD *)(a1 + 104))
  {
    _cg_jpeg_mem_term("validateWebP", 423, "*** ERROR: no VP8/VP8L chunk detected\n", *(double *)&v11);
    v24 = 0;
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v61);
  return v24;
}

void sub_187FF9B9C(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  *(_DWORD *)(v1 + 104) = 0;
  __cxa_end_catch();
  JUMPOUT(0x187FF98E0);
}

void sub_187FF9BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_WebP::getImageCount(IIO_Reader_WebP *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  IIOImageRead *v8;
  const UInt8 *BytePtr;
  const __CFData *v10;
  const __CFData *v11;
  char *v12;
  uint64_t v13;
  unsigned int *v14;
  _BOOL4 v15;
  _QWORD v17[2];
  _OWORD v18[2];
  int v19;
  void *v20;

  v20 = 0;
  v19 = 0;
  memset(v18, 0, sizeof(v18));
  if (a5)
    *a5 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&IIO_Reader_WebP::getImageCount(IIOImageReadSession *,IIODictionary *,CGImageSourceStatus *,unsigned int *)::mutex);
  WebPAnimDecoderOptionsInitInternal(v18, 263);
  v8 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v20, 0);
  if (v8)
  {
    BytePtr = (const UInt8 *)v8;
    v10 = 0;
  }
  else
  {
    v11 = IIOImageReadSession::copyData((IIOImageRead **)a2);
    if (!v11)
      return 0;
    v10 = v11;
    BytePtr = CFDataGetBytePtr(v11);
  }
  v17[0] = BytePtr;
  v17[1] = IIOImageReadSession::getSize(a2);
  v12 = WebPDemuxInternal((uint64_t)v17, 0, 0, 263);
  if (v12)
  {
    v14 = (unsigned int *)v12;
    v15 = IIO_Reader_WebP::validateWebP((uint64_t)this, v13, (uint64_t)v17);
    if (a5 && v15)
      *a5 = WebPDemuxGetI(v14, 5);
    os_unfair_lock_unlock((os_unfair_lock_t)&IIO_Reader_WebP::getImageCount(IIOImageReadSession *,IIODictionary *,CGImageSourceStatus *,unsigned int *)::mutex);
    WebPDemuxDelete(v14);
    if (v10)
      goto LABEL_12;
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&IIO_Reader_WebP::getImageCount(IIOImageReadSession *,IIODictionary *,CGImageSourceStatus *,unsigned int *)::mutex);
    if (v10)
    {
LABEL_12:
      CFRelease(v10);
      return 0;
    }
  }
  if (a2 && BytePtr)
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v20);
  return 0;
}

uint64_t IIO_Reader_WebP::updateSourceProperties(IIO_Reader_WebP *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  IIOImageRead *v8;
  const UInt8 *BytePtr;
  const __CFData *v10;
  const __CFData *v11;
  unsigned int *v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int i;
  int v17;
  int v18;
  IIODictionary *v20;
  unsigned int v21;
  _BYTE v22[24];
  _BYTE v23[24];
  _BYTE v24[24];
  uint64_t v25;
  void *v26;
  uint64_t v27;
  CFMutableArrayRef v28;
  void *value;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _BYTE v36[24];
  _BYTE v37[24];
  uint64_t v38;
  const void *v39;
  uint64_t v40;
  const UInt8 *v41;
  IIOImageRead *Size;
  _QWORD v43[4];
  int v44;
  void *v45;

  v45 = 0;
  v44 = 0;
  memset(v43, 0, sizeof(v43));
  v41 = 0;
  Size = 0;
  WebPAnimDecoderOptionsInitInternal(v43, 263);
  v8 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v45, 0);
  if (v8)
  {
    BytePtr = (const UInt8 *)v8;
    v20 = a3;
    v10 = 0;
  }
  else
  {
    v11 = IIOImageReadSession::copyData((IIOImageRead **)a2);
    if (!v11)
      return 0;
    v10 = v11;
    v20 = a3;
    BytePtr = CFDataGetBytePtr(v11);
  }
  v41 = BytePtr;
  Size = IIOImageReadSession::getSize(a2);
  v12 = (unsigned int *)WebPDemuxInternal((uint64_t)&v41, 0, 0, 263);
  v13 = WebPDemuxGetI(v12, 5);
  v14 = WebPDemuxGetI(v12, 1);
  v15 = WebPDemuxGetI(v12, 2);
  v21 = WebPDemuxGetI(v12, 3);
  v38 = 0;
  v39 = 0;
  v40 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v38);
  IIONumber::IIONumber((IIONumber *)v37, v14);
  IIODictionary::setObjectForKey((uint64_t)&v38, (uint64_t)v37, CFSTR("CanvasPixelWidth"));
  IIONumber::~IIONumber((IIONumber *)v37);
  IIONumber::IIONumber((IIONumber *)v36, v15);
  IIODictionary::setObjectForKey((uint64_t)&v38, (uint64_t)v36, CFSTR("CanvasPixelHeight"));
  IIONumber::~IIONumber((IIONumber *)v36);
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v31 = 0u;
  v28 = 0;
  value = 0;
  v30 = 0;
  IIOArray::IIOArray((IIOArray *)&v28);
  if (v13)
  {
    for (i = 1; i <= v13; ++i)
    {
      WebPDemuxGetFrame((uint64_t)v12, i, (uint64_t)&v31);
      v25 = 0;
      v26 = 0;
      v27 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v25);
      v17 = DWORD2(v32);
      if (SDWORD2(v32) >= 11)
        v18 = DWORD2(v32);
      else
        v18 = 100;
      IIONumber::IIONumber((IIONumber *)v24, (double)v18 / 1000.0);
      IIODictionary::setObjectForKey((uint64_t)&v25, (uint64_t)v24, CFSTR("DelayTime"));
      IIONumber::~IIONumber((IIONumber *)v24);
      IIONumber::IIONumber((IIONumber *)v23, (double)v17 / 1000.0);
      IIODictionary::setObjectForKey((uint64_t)&v25, (uint64_t)v23, CFSTR("UnclampedDelayTime"));
      IIONumber::~IIONumber((IIONumber *)v23);
      IIOArray::addObject(&v28, v26);
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
    }
  }
  IIODictionary::setObjectForKey((IIODictionary *)&v38, value, CFSTR("FrameInfo"));
  IIONumber::IIONumber((IIONumber *)v22, v21);
  IIODictionary::setObjectForKey((uint64_t)&v38, (uint64_t)v22, CFSTR("LoopCount"));
  IIONumber::~IIONumber((IIONumber *)v22);
  IIODictionary::setObjectForKey(v20, v39, CFSTR("{WebP}"));
  if (v12)
    WebPDemuxDelete(v12);
  if (v10)
  {
    CFRelease(v10);
  }
  else if (a2 && BytePtr)
  {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v45);
  }
  IIOArray::~IIOArray((IIOArray *)&v28);
  IIODictionary::~IIODictionary((IIODictionary *)&v38);
  return 0;
}

void sub_187FFA050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v4 - 200));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_WebP::hasCustomImageCountProc(IIO_Reader_WebP *this)
{
  return 1;
}

uint64_t IIO_Reader_WebP::hasCustomSourcePropertiesProc(IIO_Reader_WebP *this)
{
  return 1;
}

void IIOImageDestination::IIOImageDestination(IIOImageDestination *this, CGDataConsumer *a2, IIO_Writer *a3, const __CFString *a4, uint64_t a5, const __CFDictionary **a6)
{
  uint64_t v11;

  *(_QWORD *)this = &off_1E1BB1BB0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  IIOImageDestination::setup(this, 2);
  v11 = CGImageWriteSessionCreateWithConsumer(a2);
  *((_QWORD *)this + 2) = v11;
  *((_QWORD *)this + 3) = CGImageSourceGetSource(v11);
  *((_QWORD *)this + 8) = a3;
  *((_QWORD *)this + 9) = IIO_Writer::utType(a3);
  *((_QWORD *)this + 5) = a5;
  IIOImageDestination::setProperties(this, a6);
}

void sub_187FFA184(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = (void *)v1[16];
  if (v4)
  {
    v1[17] = v4;
    operator delete(v4);
  }
  v5 = *v2;
  if (*v2)
  {
    v1[14] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IIOImageDestination::getDepthArray(IIOImageDestination *this)
{
  return *((_QWORD *)this + 19);
}

uint64_t IIOImageDestination::utType(IIOImageDestination *this)
{
  return *((_QWORD *)this + 9);
}

uint64_t IIOImageDestination::createPixelDataProviderForExtendedRange(uint64_t a1, CGImage *a2, vImage_CGImageFormat *a3, void *a4, int a5, IIODictionary *a6)
{
  double Current;
  CGColorSpace *v12;
  IIODictionary *v13;
  const __CFString *ObjectForKey;
  const __CFString *v15;
  _BOOL4 v16;
  const __CFString *ObjectForKeyGroup;
  int v18;
  const __CFNumber *Property;
  uint64_t IOSurfaceFromImage;
  size_t BitsPerComponent;
  __int16 BitmapInfo;
  int v23;
  __IOSurface *v24;
  size_t Width;
  size_t Height;
  unsigned int v27;
  __IOSurface *IOSurfaceWithFormat;
  __IOSurface *v29;
  CFPropertyListRef v30;
  const void *v31;
  int v32;
  CGImageAlphaInfo AlphaInfo;
  int Alpha;
  char v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  CGImage *v41;
  uint64_t v42;
  size_t v43;
  CGImageAlphaInfo v44;
  CGBitmapInfo v45;
  int v46;
  uint64_t v47;
  CFAbsoluteTime v48;
  const __CFDictionary *v50;
  int v51;
  int v52;
  const char *v53;
  const char *v54;
  _BOOL4 v55;
  void *v56;
  _BOOL4 v57;
  vImage_CGImageFormat *v58;
  _BYTE v60[16];
  void *v61;
  uint64_t v62;
  const __CFDictionary *v63;
  void *value;
  uint64_t valuePtr;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];

  Current = CFAbsoluteTimeGetCurrent();
  IIO_LoadHEIFSymbols();
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s - input is extended range\n", "createPixelDataProviderForExtendedRange");
  if (CFStringCompare(*(CFStringRef *)(a1 + 72), CFSTR("com.apple.atx"), 0) && CGImageIsInside_sRGB(a2))
  {
    if ((gIIODebugFlags & 0x8000300000) != 0)
      ImageIOLog("COL extended range image is inside sRGB -- converting to 8-bit\n");
    v12 = 0;
    v13 = 0;
    goto LABEL_67;
  }
  ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a6, CFSTR("kCGImageDestinationEncodeRequest"));
  if (!ObjectForKey)
  {
    v55 = 0;
    v16 = 0;
LABEL_13:
    v12 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D908]);
    goto LABEL_14;
  }
  v15 = ObjectForKey;
  v16 = CFStringCompare(ObjectForKey, CFSTR("kCGImageDestinationEncodeToISOHDR"), 0) == kCFCompareEqualTo;
  v55 = CFStringCompare(v15, CFSTR("kCGImageDestinationEncodeToISOGainmap"), 0) == kCFCompareEqualTo;
  ObjectForKeyGroup = (const __CFString *)IIODictionary::getObjectForKeyGroup(a6, CFSTR("kCGTargetColorSpace"), CFSTR("kCGImageDestinationEncodeRequestOptions"));
  if (!ObjectForKeyGroup)
    goto LABEL_13;
  v12 = CGColorSpaceCreateWithName(ObjectForKeyGroup);
  if (!v12)
    goto LABEL_13;
LABEL_14:
  v13 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v13);
  v57 = v16;
  if ((a5 & 0x4000) != 0)
  {
    Property = (const __CFNumber *)CGImageGetProperty();
    if (!Property
      || (LODWORD(valuePtr) = 0,
          CFNumberGetValue(Property, kCFNumberSInt32Type, &valuePtr),
          v18 = 0,
          (_DWORD)valuePtr == 2))
    {
      IIONumber::IIONumber((IIONumber *)v68, 16);
      IIODictionary::setObjectForKey((uint64_t)v13, (uint64_t)v68, CFSTR("Depth"));
      IIONumber::~IIONumber((IIONumber *)v68);
      v18 = 1;
    }
  }
  else
  {
    v18 = 0;
  }
  if (a4 && (a5 & 0x1E000000) == 0)
    IIODictionary::setObjectForKey(v13, a4, CFSTR("backgroundColor"));
  if ((gIIODebugFlags & 0x8000300000) != 0)
    ImageIOLog("COL extended-sRGB --> P3 converting\n");
  v58 = a3;
  if (IIO_CGImageWrapsIOSurface((uint64_t)a2, 1))
  {
    CGImageGetImageProvider();
    IOSurfaceFromImage = CGImageProviderCopyIOSurface();
  }
  else
  {
    BitsPerComponent = CGImageGetBitsPerComponent(a2);
    BitmapInfo = CGImageGetBitmapInfo(a2);
    switch(BitsPerComponent)
    {
      case 0x20uLL:
        v23 = 1380410945;
        break;
      case 0x10uLL:
        if ((BitmapInfo & 0xF00) == 0x100)
          v23 = 1380411457;
        else
          v23 = 1815491698;
        break;
      case 8uLL:
        if ((BitmapInfo & 0x7000) == 0x2000)
          v23 = 1111970369;
        else
          v23 = 1380401729;
        break;
      default:
        _cg_jpeg_mem_term("createPixelDataProviderForExtendedRange", 777, "*** ERROR: unhandled bitDepth '%d'\n", BitsPerComponent);
        v23 = 0;
        break;
    }
    IOSurfaceFromImage = (uint64_t)IIO_CreateIOSurfaceFromImage(a2, v23, 0);
  }
  v24 = (__IOSurface *)IOSurfaceFromImage;
  if (IOSurfaceFromImage)
  {
    v56 = a4;
    Width = CGImageGetWidth(a2);
    Height = CGImageGetHeight(a2);
    if (v18)
      v27 = 1380411457;
    else
      v27 = 1111970369;
    IOSurfaceWithFormat = IIO_CreateIOSurfaceWithFormat(Width, Height, 0, v27, 0, 0);
    if (IOSurfaceWithFormat)
    {
      v29 = IOSurfaceWithFormat;
      v30 = CGColorSpaceCopyPropertyList(v12);
      if (v30)
      {
        v31 = v30;
        IOSurfaceSetValue(v29, (CFStringRef)*MEMORY[0x1E0CBBF90], v30);
        CFRelease(v31);
      }
      if (v57)
      {
        valuePtr = 0;
        v66 = 0;
        v67 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&valuePtr);
        v32 = IIOCallConvertHDRData(v24, v29, v66);
        if (v32 && (gIIODebugFlags & 0x300000) != 0)
          ImageIOLog("☀️  ERROR: IIOCallConvertHDRData failed (%d)\n", v32);
        v62 = 0;
        v63 = 0;
        value = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v62);
        AlphaInfo = CGImageGetAlphaInfo(a2);
        Alpha = IIO_IOSurfaceGetAlpha(v29);
        if (AlphaInfo != Alpha)
        {
          if (Alpha)
            v35 = 0;
          else
            v35 = v18;
          if ((v35 & 1) != 0)
          {
            AlphaInfo = kCGImageAlphaNone;
          }
          else
          {
            if ((gIIODebugFlags & 0x300000) != 0)
            {
              v53 = IIO_AlphaInfoString(Alpha);
              v54 = IIO_AlphaInfoString(AlphaInfo);
              ImageIOLog("☀️  ERROR:  surfaceAlpha: %s        imgAlpha: %s\n", v53, v54);
            }
            IIO_IOSurfaceSetAlpha(v29, AlphaInfo);
          }
        }
        IIONumber::IIONumber((IIONumber *)v60, AlphaInfo);
        IIODictionary::setObjectForKey((IIODictionary *)&v62, v61, CFSTR("CGImageAlphaInfo"));
        IIONumber::~IIONumber((IIONumber *)v60);
        v41 = CGImageCreateFromIOSurface(v29, v63);
        IIODictionary::~IIODictionary((IIODictionary *)&v62);
      }
      else
      {
        if (v55)
        {
          LogError("createPixelDataProviderForExtendedRange", 830, "*** ERROR: IIOCallConvertHDRData - failed to create ISOGainmap\n");
          v41 = 0;
          goto LABEL_102;
        }
        if (v18)
        {
          v41 = CGImageRetain(a2);
          if ((gIIODebugFlags & 0x300000) != 0)
            ImageIOLog("☀️  wrappingIOSurface - using original images/IOSurface...\n");
LABEL_102:
          CFRelease(v29);
          CFRelease(v24);
          a4 = v56;
          a3 = v58;
          if (v41)
            goto LABEL_68;
          goto LABEL_67;
        }
        if ((gIIODebugFlags & 0x300000) != 0)
          ImageIOLog("☀️  %s - using 'IIOCallConvertHDRData'\n", "createPixelDataProviderForExtendedRange");
        v50 = IIODictionary::getObjectForKey(a6, CFSTR("kCGImageDestinationToneMapExtendedRangeToSDR"));
        valuePtr = 0;
        v66 = 0;
        v67 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&valuePtr);
        if (v50 == (const __CFDictionary *)*MEMORY[0x1E0C9AE50])
          v51 = 2;
        else
          v51 = 5;
        IIONumber::IIONumber((IIONumber *)&v62, v51);
        IIODictionary::setObjectForKey((IIODictionary *)&valuePtr, value, CFSTR("kCGToneMappingMode"));
        IIONumber::~IIONumber((IIONumber *)&v62);
        v52 = IIOCallConvertHDRData(v24, v29, v66);
        if (v52)
        {
          LogError("createPixelDataProviderForExtendedRange", 849, "*** ERROR: IIOCallConvertHDRData returned: %d\n", v52);
          v41 = 0;
        }
        else
        {
          v41 = CGImageCreateFromIOSurface(v29, 0);
        }
      }
      IIODictionary::~IIODictionary((IIODictionary *)&valuePtr);
      goto LABEL_102;
    }
    LODWORD(v36) = HIBYTE(v27);
    v37 = 46;
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * HIBYTE(v27)) & 0x40000) != 0)
      v36 = v36;
    else
      v36 = 46;
    v38 = (v27 >> 8) & 0x7A;
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * v38) & 0x40000) != 0)
      v39 = v38;
    else
      v39 = 46;
    v40 = 65;
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 320) & 0x40000) == 0)
      v40 = 46;
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 344) & 0x40000) != 0)
      v37 = 71;
    LogError("createPixelDataProviderForExtendedRange", 860, "*** ERROR: failed to create IOSurface %dx%d  '%c%c%c%c'\n", Width, Height, v36, v37, v39, v40);
    CFRelease(v24);
  }
  a3 = v58;
LABEL_67:
  v41 = CGImageCreateByConvertingExtendedSRGBToColorspace(a2, v12, v13);
LABEL_68:
  v42 = 0;
  if ((a5 & 0x1A000) == 0 && v41)
  {
    v43 = CGImageGetBitsPerComponent(v41);
    v44 = CGImageGetAlphaInfo(v41);
    v45 = CGImageGetBitmapInfo(v41);
    v46 = v45 | 5;
    if (v44)
      v46 = v45;
    a3->bitmapInfo = v46;
    a3->colorSpace = v12;
    v47 = gIIODebugFlags & 0x8000300000;
    if (v43 == 16)
    {
      if (v47)
      {
        ImageIOLog("COL extended-sRGB --> P3 16-bit\n");
        v46 = a3->bitmapInfo;
      }
      *(_QWORD *)&a3->bitsPerComponent = 0x4000000010;
      a3->bitmapInfo = v46 & 0xFFFFF0FF;
    }
    else
    {
      if (v47)
        ImageIOLog("COL extended-sRGB --> P3 8-bit\n");
      *(_QWORD *)&a3->bitsPerComponent = 0x2000000008;
    }
    v42 = CGImagePixelDataProviderCreate(v41, a3, (CGColor *)a4);
    CGImageRelease(v41);
  }
  if (v13)
    (*(void (**)(IIODictionary *))(*(_QWORD *)v13 + 8))(v13);
  CGColorSpaceRelease(v12);
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    v48 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    IIOImageDestination::createPixelDataProviderForExtendedRange - %g ms\n", (v48 - Current) * 1000.0);
  }
  return v42;
}

void sub_187FFA9A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26)
{
  IIONumber::~IIONumber((IIONumber *)&a23);
  IIODictionary::~IIODictionary((IIODictionary *)&a26);
  _Unwind_Resume(a1);
}

CGImage *IIOImageDestination::createCGImageConforming(uint64_t a1, CGImageRef image, unint64_t a3, CGColor *a4, uint64_t a5)
{
  size_t Width;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  const CGFloat *v11;
  double Current;
  const __CFString *v13;
  BOOL v14;
  CGImage *CopyWithColorSpace;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  char v20;
  const char *v21;
  unsigned int v22;
  BOOL v23;
  BOOL v24;
  BOOL v25;
  BOOL v26;
  _BOOL4 v27;
  CGColorSpace *v28;
  const char *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unint64_t v34;
  const char *v35;
  int v36;
  _BOOL4 v38;
  BOOL v39;
  int v40;
  _BOOL4 v41;
  _BOOL4 v43;
  char v44;
  int v45;
  const char *v46;
  _BOOL4 v47;
  unsigned int v48;
  const char *v49;
  unsigned int v50;
  const char *v51;
  _BOOL4 HasMask;
  _BOOL4 v53;
  CGColorSpace *v54;
  size_t MinimalPixelSize;
  size_t v56;
  const char *v57;
  __int128 v58;
  unint64_t v59;
  unint64_t v60;
  __int128 *v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  size_t v65;
  const char *v66;
  int v67;
  int v68;
  char v69;
  int BitmapInfo;
  CGColorSpaceRef v71;
  CGBitmapInfo v72;
  CGDataProvider *DataProvider;
  const CGFloat *decode;
  BOOL shouldInterpolate;
  CGColorRenderingIntent RenderingIntent;
  CGColorSpace *v77;
  int v78;
  unint64_t v79;
  unsigned int v80;
  BOOL v81;
  CGColor *v82;
  int v83;
  unsigned int v84;
  int v85;
  char v86;
  int v87;
  BOOL v88;
  int v89;
  CGBitmapInfo v90;
  int v91;
  CGColor *v92;
  CGColorSpace *v93;
  unint64_t v94;
  char v95;
  CFStringRef *v96;
  CGColorSpaceRef v97;
  BOOL v98;
  size_t v99;
  unint64_t v100;
  uint64_t v101;
  BOOL v102;
  CGColorRenderingIntent v103;
  CGImageRef CopyWithBitmapInfo;
  BOOL v105;
  CGColorRenderingIntent v106;
  CFAbsoluteTime v107;
  size_t bytesPerRow;
  size_t v110;
  size_t v111;
  int v112;
  int v113;
  BOOL v114;
  CGColorSpace *space;
  int v116;
  int IsFloat;
  _BOOL4 v119;
  int v120;
  unint64_t v122;
  size_t BitsPerPixel;
  int v124;
  unint64_t Height;
  size_t v126;
  uint64_t EndianInfo;
  int v128;
  int AlphaInfo;
  size_t BitsPerComponent;
  unsigned int Type;
  CGBitmapInfo v132;
  CGAffineTransform v133;
  CGAffineTransform v134;
  _QWORD v135[5];
  __int128 v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  double v140;
  double v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  __int128 v145;
  double v146;
  __int128 v147;
  __int128 v148;
  double v149;
  double v150;
  __int128 v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  double v155;
  __int128 v156;
  uint64_t v157;
  __int128 v158;
  __int128 v159;
  uint64_t v160;
  __int128 v161;
  double v162;
  uint64_t v163;
  uint64_t v164;

  v164 = *MEMORY[0x1E0C80C00];
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  BitsPerPixel = CGImageGetBitsPerPixel(image);
  ColorSpace = CGImageGetColorSpace(image);
  Model = CGColorSpaceGetModel(ColorSpace);
  Type = CGColorSpaceGetType();
  v11 = CGImageGetDecode(image);
  AlphaInfo = _ImageGetAlphaInfo(image);
  EndianInfo = _ImageGetEndianInfo(image);
  IsFloat = _ImageIsFloat(image);
  memset(&v134, 0, sizeof(v134));
  Current = CFAbsoluteTimeGetCurrent();
  v13 = *(const __CFString **)(a1 + 72);
  if (v13)
    v14 = CFStringCompare(v13, CFSTR("public.jpeg"), 0) == kCFCompareEqualTo;
  else
    v14 = 0;
  CopyWithColorSpace = 0;
  if ((a5 & 0x7F000000) == 0 || (a5 & 0x1FF00) == 0 || !image || (a5 & 0x7F) == 0)
    goto LABEL_333;
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("CGImageDestination - CGImageCreateConforming\n");
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      ImageIOLog("--------------------------------------------\n");
      if ((gIIODebugFlags & 0x10000000000) != 0)
        ImageIOLog("           writerMode: %s [0x%X]\n", IIO_WriterModeString(CGImagePluginWriteModes)::output, a5);
    }
  }
  v16 = Type;
  if (Type == 7)
  {
    ColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
    v16 = CGColorSpaceGetType();
    Model = CGColorSpaceGetModel(ColorSpace);
  }
  v17 = IIOImageDestination::adjustWriteModesForWriter(a1, a5, BitsPerComponent, Model, AlphaInfo, *(_DWORD *)(a1 + 40), ColorSpace, 0);
  v18 = v17;
  if ((gIIODebugFlags & 0x10000000000) != 0)
    ImageIOLog("       new writerMode: %s [0x%X]\n", IIO_WriterModeString(CGImagePluginWriteModes)::output, v17);
  if ((a5 & 0x10) != 0 && Type == 7 && Model == kCGColorSpaceModelRGB
    || ((v128 = 0, (a5 & 1) == 0) ? (v19 = Model == kCGColorSpaceModelRGB) : (v19 = 0),
        !v19 ? (v20 = 0) : (v20 = 1),
        Type != 7 && (v20 & 1) == 0))
  {
    v128 = 1;
  }
  space = ColorSpace;
  v126 = Width;
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("            csIndexed: %d\n", Type == 7);
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      v21 = IIO_ColorModelString(Model);
      ImageIOLog("              csModel: %d = %s\n", Model, v21);
      if ((gIIODebugFlags & 0x10000000000) != 0)
        ImageIOLog("            indexedOK: %d\n", v128);
    }
  }
  if (((Type == 7) & (a5 >> 4)) != 0)
    v22 = v18 & 0xF9FFFFFF;
  else
    v22 = v18;
  v23 = Model != kCGColorSpaceModelRGB || (a5 & 0x11) == 0;
  v27 = 1;
  if (v23 && ((Model == kCGColorSpaceModelCMYK) & (a5 >> 1)) == 0)
  {
    v24 = (a5 & 8) != 0 && v16 == 5;
    v25 = !v24;
    v26 = Model || (a5 & 0x24) == 0;
    if (v26 && v25)
      v27 = 0;
  }
  if (Model != kCGColorSpaceModelDeviceN || v27 || BitsPerComponent != 1 || (v22 & 0x100) == 0)
  {
    v114 = !v27;
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      v29 = "no <<<";
      if (v27)
        v29 = "yes";
      ImageIOLog("         spaceModelOK: %s\n", v29);
    }
    if (v16 <= 5 && ((1 << v16) & 0x27) != 0 || (v31 = 0, v30 = v22 & 0x40000, (v22 & 0x40000) != 0) && v16 != 9)
    {
      v30 = v22 & 0x40000;
      v31 = 1;
    }
    if (v16 == 6)
      v32 = v31;
    else
      v32 = 1;
    if (v30)
      v33 = v32;
    else
      v33 = 1;
    v124 = v31 | v33 ^ 1;
    if (Model == kCGColorSpaceModelRGB)
    {
      v34 = BitsPerComponent;
    }
    else
    {
      v34 = BitsPerComponent;
      if ((v33 & 1) == 0)
        v124 = (Model & 0xFFFFFFFD) == 0;
    }
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      v35 = "no <<<";
      if (v124)
        v35 = "yes";
      ImageIOLog("          spaceTypeOK: %s\n", v35);
    }
    if (BitsPerComponent == 1 && (v22 & 0x100) != 0)
      goto LABEL_106;
    if (BitsPerComponent == 2 && (v22 & 0x200) != 0)
      goto LABEL_106;
    if (BitsPerComponent == 4 && (v22 & 0x400) != 0)
      goto LABEL_106;
    if (BitsPerComponent == 8 && (v22 & 0x800) != 0)
      goto LABEL_106;
    if (BitsPerComponent == 16 && (v22 & 0x1000) != 0)
      goto LABEL_106;
    if (BitsPerComponent == 16 && (v22 & 0x4000) != 0)
      goto LABEL_106;
    if (BitsPerComponent == 16 && (v22 & 0x10000) != 0)
      goto LABEL_106;
    v36 = IsFloat ^ 1;
    if (BitsPerComponent == 32 && (v22 & 0x2000) != 0 && !v36)
      goto LABEL_106;
    if ((v22 & 0x8000) == 0 || BitsPerComponent != 32)
      LOBYTE(v36) = 1;
    if ((v36 & 1) == 0)
LABEL_106:
      v120 = 1;
    else
      v120 = 0;
    v119 = v27;
    if ((gIIODebugFlags & 0x10000000000) != 0
      && (ImageIOLog("          bitsPerComp: %d\n", v34), (gIIODebugFlags & 0x10000000000) != 0))
    {
      v49 = "no <<<";
      if (v120)
        v49 = "yes";
      ImageIOLog("              depthOK: %s\n", v49);
      v38 = ((1 << (AlphaInfo + 24)) & v22 & 0x7F000000) != 0;
      if ((gIIODebugFlags & 0x10000000000) != 0)
        ImageIOLog("              alphaOK: %d\n", ((1 << (AlphaInfo + 24)) & v22 & 0x7F000000) != 0);
    }
    else
    {
      v38 = ((1 << (AlphaInfo + 24)) & v22 & 0x7F000000) != 0;
    }
    if (BitsPerComponent == 1 && !(_DWORD)EndianInfo && (v22 & 0x100) != 0)
      goto LABEL_155;
    if (BitsPerComponent == 2 && !(_DWORD)EndianInfo && (v22 & 0x200) != 0)
      goto LABEL_155;
    if (BitsPerComponent == 4 && !(_DWORD)EndianInfo && (v22 & 0x400) != 0)
      goto LABEL_155;
    if (BitsPerComponent == 8 && !(_DWORD)EndianInfo && (v22 & 0x800) != 0)
      goto LABEL_155;
    v39 = BitsPerComponent != 16;
    if (BitsPerComponent == 16 && (_DWORD)EndianInfo == 12288 && (v22 & 0x1000) != 0)
      goto LABEL_155;
    if (BitsPerComponent == 16 && !(_DWORD)EndianInfo && (v22 & 0x1000) != 0)
      goto LABEL_155;
    if ((_DWORD)EndianInfo != 4096)
      v39 = 1;
    if (!v39 && (v22 & 0x4000) != 0)
      goto LABEL_155;
    v40 = IsFloat ^ 1;
    v41 = BitsPerComponent != 32;
    if (BitsPerComponent == 32 && (_DWORD)EndianInfo == 0x4000 && (v22 & 0x2000) != 0 && !v40)
      goto LABEL_155;
    v43 = BitsPerComponent != 32 || (_DWORD)EndianInfo != 0;
    if ((v22 & 0x2000) == 0)
      v43 = 1;
    if ((v43 | v40) != 1)
      goto LABEL_155;
    if ((_DWORD)EndianInfo != 0x2000)
      v41 = 1;
    if ((v22 & 0x8000) == 0)
      v41 = 1;
    if ((v41 | v40) != 1)
    {
LABEL_155:
      v45 = 1;
    }
    else
    {
      v44 = !v14;
      if (BitsPerComponent != 8)
        v44 = 1;
      if ((v44 & 1) != 0 || (EndianInfo | 0x2000) != 0x2000)
        v45 = 0;
      else
        v45 = (v22 >> 11) & 1;
    }
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      ImageIOLog("          bitsPerComp: %d\n", v34);
      if ((gIIODebugFlags & 0x10000000000) != 0)
      {
        ImageIOLog("           endianInfo: %d [%p]\n", EndianInfo, (const void *)EndianInfo);
        if ((gIIODebugFlags & 0x10000000000) != 0)
        {
          v46 = "no <<<";
          if (v45)
            v46 = "yes";
          ImageIOLog("             endianOK: %s\n", v46);
        }
      }
    }
    v116 = v45;
    if (v11)
    {
      v47 = *v11 == 1.0 && v11[1] == 0.0;
      if (*v11 == 0.0)
      {
        v48 = v11[1] == 1.0;
        if (Model)
          goto LABEL_177;
      }
      else
      {
        v48 = 0;
        if (Model)
          goto LABEL_177;
      }
    }
    else
    {
      v47 = 0;
      v48 = 1;
      if (Model)
        goto LABEL_177;
    }
    v50 = v47 & (a5 >> 5);
    if (BitsPerComponent == 1)
      v50 = 1;
    v48 = v50 | v48 & (a5 >> 2);
LABEL_177:
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      v51 = "no <<<";
      if (v48)
        v51 = "yes";
      ImageIOLog("             decodeOK: %s\n", v51);
    }
    HasMask = _ImageHasMask();
    v53 = HasMask;
    if ((gIIODebugFlags & 0x10000000000) != 0)
      ImageIOLog("               maskOK: %d\n", !HasMask);
    v54 = CGImageGetColorSpace(image);
    MinimalPixelSize = _GetMinimalPixelSize(v54, v34, AlphaInfo);
    v56 = MinimalPixelSize;
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      v57 = "yes";
      if (BitsPerPixel != MinimalPixelSize)
        v57 = "no <<<";
      ImageIOLog("                bppOK: %s\n", v57);
    }
    v58 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
    *(_OWORD *)&v134.a = *MEMORY[0x1E0C9BAA8];
    *(_OWORD *)&v134.c = v58;
    *(_OWORD *)&v134.tx = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
    v59 = a3 - 2;
    if (a3 - 2 <= 6)
    {
      v135[0] = 0xBFF0000000000000;
      v135[1] = 0;
      v135[2] = 0;
      v135[3] = 0x3FF0000000000000;
      v60 = Height;
      *(double *)&v135[4] = (double)v126;
      v136 = xmmword_18820F310;
      v137 = 0;
      v138 = 0;
      v139 = 0xBFF0000000000000;
      v140 = (double)v126;
      v141 = (double)Height;
      v143 = 0;
      v144 = 0;
      v142 = 0x3FF0000000000000;
      v145 = xmmword_18820F330;
      v147 = xmmword_18820F310;
      v148 = xmmword_18820F330;
      v146 = (double)Height;
      v149 = (double)Height;
      v150 = (double)v126;
      v151 = xmmword_18820F310;
      v154 = 0;
      v152 = 0x3FF0000000000000;
      v153 = 0;
      v155 = (double)v126;
      v156 = xmmword_18820F320;
      v158 = 0u;
      v159 = 0u;
      v157 = 0x3FF0000000000000;
      v160 = 0x3FF0000000000000;
      v161 = xmmword_18820F330;
      v162 = (double)Height;
      v163 = 0;
      v61 = (__int128 *)&v135[6 * v59];
      v62 = v61[2];
      v64 = *v61;
      v63 = v61[1];
      if (a3 <= 4)
        v65 = v126;
      else
        v65 = Height;
      if (a3 > 4)
        v60 = v126;
      Height = v60;
      v126 = v65;
      *(_OWORD *)&v134.c = v63;
      *(_OWORD *)&v134.tx = v62;
      *(_OWORD *)&v134.a = v64;
    }
    v122 = a3 - 2;
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      v66 = "yes";
      if (v59 < 7)
        v66 = "no";
      ImageIOLog("             orientOK: %s\n", v66);
      v59 = v122;
    }
    v67 = v48 ^ 1;
    v68 = v128 & v119 & v124 & v120;
    v69 = v116;
    v113 = v68 ^ 1;
    if (v59 >= 7
      && ((v67 | v53) & 1) == 0
      && ((v68 ^ 1) & 1) == 0
      && v38
      && ((v116 ^ 1) & 1) == 0
      && BitsPerPixel == v56)
    {
      v112 = v67;
      BitmapInfo = _ImageGetBitmapInfo(image);
      if (BitmapInfo == CGImageGetBitmapInfo(image))
      {
        CopyWithColorSpace = CGImageRetain(image);
      }
      else
      {
        v111 = CGImageGetBitsPerComponent(image);
        v110 = CGImageGetBitsPerPixel(image);
        bytesPerRow = CGImageGetBytesPerRow(image);
        v71 = CGImageGetColorSpace(image);
        v72 = _ImageGetBitmapInfo(image);
        DataProvider = CGImageGetDataProvider(image);
        decode = CGImageGetDecode(image);
        shouldInterpolate = CGImageGetShouldInterpolate(image);
        RenderingIntent = CGImageGetRenderingIntent(image);
        v77 = v71;
        v69 = v116;
        CopyWithColorSpace = CGImageCreate(v126, Height, v111, v110, bytesPerRow, v77, v72, DataProvider, decode, shouldInterpolate, RenderingIntent);
        CGImageSetProperty();
        CGImageSetProperty();
      }
      v67 = v112;
      if (CopyWithColorSpace)
      {
        v28 = 0;
        goto LABEL_327;
      }
      v34 = BitsPerComponent;
      if ((gIIODebugFlags & 0x10000000000) != 0)
      {
        ImageIOLog("*** CGImageCreate failed\n");
        v67 = v112;
      }
    }
    v78 = v67;
    if (_ImageIsOpaque(image))
    {
      v79 = BitsPerComponent;
      v80 = Type;
      v81 = v119;
      if ((v22 & 0x40000000) != 0 && BitsPerPixel > 8)
      {
        v82 = 0;
        v83 = 6;
      }
      else if ((v22 & 0x20000000) != 0 && BitsPerPixel > 8)
      {
        v82 = 0;
        v83 = 5;
      }
      else if ((v22 & 0x1000000) != 0)
      {
        v83 = 0;
        v82 = 0;
      }
      else
      {
        v82 = 0;
        if ((v22 & 0x8000000) != 0)
        {
          v83 = 3;
        }
        else if ((v22 & 0x10000000) != 0)
        {
          v83 = 4;
        }
        else if ((v22 & 0x2000000) != 0)
        {
          v83 = 1;
        }
        else
        {
          v83 = 2;
        }
      }
    }
    else
    {
      v84 = AlphaInfo - 3;
      v79 = BitsPerComponent;
      v80 = Type;
      v81 = v119;
      if ((v22 & 0x2000000) != 0 && v84 > 0xFFFFFFFD)
      {
        v83 = 1;
      }
      else if ((v22 & 0x4000000) != 0 && v84 > 0xFFFFFFFD)
      {
        v83 = 2;
      }
      else if ((v22 & 0x8000000) != 0)
      {
        v83 = 3;
      }
      else
      {
        if ((v22 & 0x2000000) != 0)
          v85 = 1;
        else
          v85 = 2;
        if ((v22 & 0x10000000) != 0)
          v83 = 4;
        else
          v83 = v85;
        if ((v22 & 0x16000000) == 0)
        {
          if ((v22 & 0x40000000) != 0 && BitsPerPixel > 8)
          {
            v83 = 6;
          }
          else if (((BitsPerPixel > 8) & (v22 >> 29)) != 0)
          {
            v83 = 5;
          }
          else
          {
            v83 = 0;
          }
        }
      }
      if ((v22 & 0x1E000000) != 0)
        v82 = 0;
      else
        v82 = a4;
    }
    if ((v120 & 1) == 0)
    {
      if ((v22 & 0x1FF00) == 0x2000)
        goto LABEL_256;
      v86 = IsFloat;
      if ((v22 & 0xA000) == 0)
        v86 = 0;
      if ((v86 & 1) != 0)
      {
LABEL_256:
        v34 = 32;
      }
      else if (v79 < 9 || (v34 = 16, v22 != 0x4000) && (v22 & 0x11000) == 0)
      {
        v34 = 8;
      }
    }
    if ((v69 & 1) == 0)
    {
      if (v34 == 16 && (v22 & 0x4000) != 0)
      {
        v87 = 4096;
      }
      else
      {
        v88 = (v22 & 0x8000) != 0 && v34 == 32;
        v89 = IsFloat ^ 1;
        if (!v88)
          v89 = 1;
        if (v89)
          v87 = 0;
        else
          v87 = 0x2000;
      }
      LODWORD(EndianInfo) = v87;
    }
    v90 = EndianInfo | v83;
    if (v34 == 32)
      v90 = EndianInfo | v83 | 0x100;
    v132 = v90;
    v91 = v128;
    if (v80 != 7)
      v91 = 0;
    if (((v114 | v124 ^ 1) & 1) == 0 && v91)
    {
      v92 = v82;
      v93 = CGImageGetColorSpace(image);
      v28 = CGColorSpaceRetain(v93);
      v94 = v126;
      if ((a5 & 2) != 0)
        goto LABEL_305;
      goto LABEL_304;
    }
    v94 = v126;
    if (((v114 | v124 ^ 1) & 1) == 0)
    {
      v92 = v82;
      v97 = CGColorSpaceRetain(space);
      goto LABEL_303;
    }
    v95 = !v81;
    if (Model != kCGColorSpaceModelCMYK)
      v95 = 1;
    if ((v95 & 1) == 0)
    {
      v92 = v82;
      v96 = (CFStringRef *)MEMORY[0x1E0C9D968];
LABEL_302:
      v97 = CGColorSpaceCreateWithName(*v96);
LABEL_303:
      v28 = v97;
      if ((a5 & 2) != 0)
        goto LABEL_305;
      goto LABEL_304;
    }
    if (Model)
      v98 = 0;
    else
      v98 = v81;
    v96 = (CFStringRef *)MEMORY[0x1E0C9D978];
    if (!v98)
    {
      if ((a5 & 1) != 0 && v79 >= 8)
      {
        v92 = v82;
        v96 = (CFStringRef *)MEMORY[0x1E0C9DA10];
        goto LABEL_302;
      }
      if ((a5 & 2) == 0 || v79 <= 7)
      {
        v92 = v82;
        if ((a5 & 4) == 0)
        {
          v28 = 0;
          if ((a5 & 2) != 0)
          {
LABEL_305:
            if (a5 & 4 | Model)
            {
LABEL_307:
              v99 = _GetMinimalPixelSize(v28, v34, v83);
              v100 = (v99 * v94 + 7) >> 3;
              v101 = gIIODebugFlags;
              if (v122 >= 7 && ((v113 | v78) & 1) == 0)
              {
                if ((gIIODebugFlags & 0x10000000000) != 0)
                {
                  ImageIOLog("CGImageCreateCopyWithBitmapInfo\n");
                  if ((gIIODebugFlags & 0x10000000000) != 0)
                  {
                    ImageIOLog("        newbits/Pixel: %zd\n", v99);
                    if ((gIIODebugFlags & 0x10000000000) != 0)
                    {
                      ImageIOLog("         newbytes/Row: %zd\n", v100);
                      if ((gIIODebugFlags & 0x10000000000) != 0)
                        ImageIOLog("        newBitmapInfo: %d\n", v132);
                    }
                  }
                }
                v102 = CGImageGetShouldInterpolate(image);
                v103 = CGImageGetRenderingIntent(image);
                CopyWithBitmapInfo = CGImageCreateCopyWithBitmapInfo(image, v92, v99, v100, v132, v102, v103);
                if (CopyWithBitmapInfo)
                {
                  CopyWithColorSpace = CopyWithBitmapInfo;
LABEL_327:
                  CGImageSetProperty();
                  if ((gIIODebugFlags & 0x10000000000) != 0)
                  {
                    if (CopyWithColorSpace == image)
                      ImageIOLog("CGImageCreateConforming - newImage == input image\n");
                    else
                      ImageIOLog("CGImageCreateConforming - newImage:\n");
                  }
                  goto LABEL_331;
                }
                v101 = gIIODebugFlags;
                if ((gIIODebugFlags & 0x10000000000) != 0)
                {
                  ImageIOLog("*** CGImageCreateCopyWithBitmapInfo failed\n");
                  v101 = gIIODebugFlags;
                }
              }
              if ((v101 & 0x10000000000) != 0)
              {
                ImageIOLog("CGImageCreateCopyWithParametersNew\n");
                if ((gIIODebugFlags & 0x10000000000) != 0)
                {
                  ImageIOLog("                 size: %zd x %zd\n", v94, Height);
                  if ((gIIODebugFlags & 0x10000000000) != 0)
                  {
                    ImageIOLog("        newbits/Pixel: %zd\n", v99);
                    if ((gIIODebugFlags & 0x10000000000) != 0)
                    {
                      ImageIOLog("         newbytes/Row: %zd\n", v100);
                      if ((gIIODebugFlags & 0x10000000000) != 0)
                      {
                        ImageIOLog("        newBitmapInfo: %d\n", v132);
                        if ((gIIODebugFlags & 0x10000000000) != 0)
                          ImageIOLog("        newcolorspace: ");
                      }
                    }
                  }
                }
                CFShow(v28);
              }
              v133 = v134;
              v105 = CGImageGetShouldInterpolate(image);
              v106 = CGImageGetRenderingIntent(image);
              CopyWithColorSpace = CGImageCreateCopyWithParametersNew(image, v92, &v133, v94, Height, v34, v99, v100, v28, v132, v105, v106, kCGInterpolationDefault, 0);
              if (!CopyWithColorSpace)
              {
                if ((gIIODebugFlags & 0x10000000000) != 0)
                  ImageIOLog("*** CGImageCreateCopyWithParametersNew failed\n");
                goto LABEL_331;
              }
              goto LABEL_327;
            }
LABEL_306:
            v28 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
            goto LABEL_307;
          }
LABEL_304:
          if (Model == kCGColorSpaceModelCMYK)
            goto LABEL_306;
          goto LABEL_305;
        }
        goto LABEL_302;
      }
      v96 = (CFStringRef *)MEMORY[0x1E0C9D968];
    }
    v92 = v82;
    v28 = CGColorSpaceCreateWithName(*v96);
    goto LABEL_305;
  }
  v28 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  CopyWithColorSpace = CGImageCreateCopyWithColorSpace(image, v28);
  if (CopyWithColorSpace)
    goto LABEL_327;
LABEL_331:
  if (v28)
    CGColorSpaceRelease(v28);
LABEL_333:
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    v107 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    IIOImageDestination::createCGImageConforming - %g ms\n", (v107 - Current) * 1000.0);
  }
  return CopyWithColorSpace;
}

BOOL IIOImageDestination::copyImageSource(CFStringRef *this, CGImageSourceRef isrc, IIODictionary *a3, BOOL a4, __CFError **a5)
{
  const __CFString *Type;
  IIOImageSource *Source;
  _BOOL8 updated;
  _OWORD v14[3];
  __CFError *v15;

  v15 = 0;
  Type = CGImageSourceGetType(isrc);
  if (!Type)
  {
    IIOLogAndCreateError(&v15, (const __CFString *)*MEMORY[0x1E0C9AFC8], -50, "copyImageSource", 1934, "CGImageDestinationCopyImageSource: source is corrupt\n");
    goto LABEL_10;
  }
  if (CFStringCompare(Type, this[9], 0))
  {
    IIOLogAndCreateError(&v15, (const __CFString *)*MEMORY[0x1E0C9AFC8], -50, "copyImageSource", 1936, "image destination UTType does not match image source UTType\n");
LABEL_10:
    updated = 0;
    if (!a5)
      return updated;
    goto LABEL_6;
  }
  Source = (IIOImageSource *)CGImageSourceGetSource((uint64_t)isrc);
  memset(v14, 0, sizeof(v14));
  IIOMetadataUpdater::IIOMetadataUpdater((IIOMetadataUpdater *)v14, Source, (IIOImageDestination *)this, a3, a4);
  updated = IIOMetadataUpdater::updateDestination((IIOImageSource **)v14, &v15);
  if (updated)
    *((_BYTE *)this + 224) = 1;
  IIOMetadataUpdater::~IIOMetadataUpdater((IIOMetadataUpdater *)v14);
  if (a5)
LABEL_6:
    *a5 = v15;
  return updated;
}

void sub_187FFBBF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOMetadataUpdater::~IIOMetadataUpdater((IIOMetadataUpdater *)&a9);
  _Unwind_Resume(a1);
}

double IIOImageDestination::handlePerFrameGIFSaving(IIOImageDestination *this, CGImage *a2, IIODictionary *a3)
{
  unsigned int v6;
  IIODictionary *v7;
  unsigned __int8 BoolForKeyGroup;
  double result;
  IIODictionary *v10;
  _BYTE *v11;
  const void *v12;
  uint64_t v13;
  size_t v14;
  IIODictionary *v15;
  unsigned int v16;
  IIODictionary *v17;
  const __CFDictionary *ObjectForKey;
  _QWORD v19[3];

  if (*((_QWORD *)this + 6) != 1)
    goto LABEL_9;
  v6 = IIODictionary::containsKey(*((IIODictionary **)this + 11), CFSTR("HasGlobalColorMap"));
  v7 = (IIODictionary *)*((_QWORD *)this + 11);
  if (v6)
    goto LABEL_3;
  if (IIODictionary::containsKeyGroup(v7, CFSTR("HasGlobalColorMap"), CFSTR("{GIF}")))
  {
    v10 = (IIODictionary *)*((_QWORD *)this + 11);
LABEL_6:
    BoolForKeyGroup = IIODictionary::getBoolForKeyGroup(v10, CFSTR("HasGlobalColorMap"), CFSTR("{GIF}"));
    goto LABEL_7;
  }
  if (!IIODictionary::containsKey(a3, CFSTR("HasGlobalColorMap")))
  {
    if (!IIODictionary::containsKeyGroup(a3, CFSTR("HasGlobalColorMap"), CFSTR("{GIF}")))
    {
      v11 = (char *)this + 223;
      if (!*((_BYTE *)this + 223))
      {
        v15 = (IIODictionary *)*((_QWORD *)this + 11);
        if (v15)
        {
          v16 = IIODictionary::containsKey(v15, CFSTR("HasGlobalColorMap"));
          v17 = (IIODictionary *)*((_QWORD *)this + 11);
          if (v16)
          {
            *((_BYTE *)this + 222) = !IIODictionary::getBoolForKey(v17, CFSTR("HasGlobalColorMap"));
            *((_BYTE *)this + 223) = 1;
          }
          else if (IIODictionary::containsKey(v17, CFSTR("{GIF}")))
          {
            ObjectForKey = IIODictionary::getObjectForKey(a3, CFSTR("{GIF}"));
            if (ObjectForKey)
            {
              memset(v19, 0, sizeof(v19));
              IIODictionary::IIODictionary((IIODictionary *)v19, ObjectForKey);
              if (IIODictionary::containsKey((IIODictionary *)v19, CFSTR("HasGlobalColorMap")))
              {
                *((_BYTE *)this + 222) = !IIODictionary::getBoolForKey((IIODictionary *)v19, CFSTR("HasGlobalColorMap"));
                *((_BYTE *)this + 223) = 1;
              }
              IIODictionary::~IIODictionary((IIODictionary *)v19);
            }
          }
        }
      }
      goto LABEL_8;
    }
    v10 = a3;
    goto LABEL_6;
  }
  v7 = a3;
LABEL_3:
  BoolForKeyGroup = IIODictionary::getBoolForKey(v7, CFSTR("HasGlobalColorMap"));
LABEL_7:
  *((_BYTE *)this + 223) = 1;
  v11 = (char *)this + 223;
  *((_BYTE *)this + 222) = BoolForKeyGroup ^ 1;
LABEL_8:
  if (!*((_BYTE *)this + 222))
  {
    if (*v11)
    {
      v13 = *((_QWORD *)this + 5);
      v14 = CGImageGetWidth(a2) * v13;
      if (v14 * CGImageGetHeight(a2) >= 0x5F5E101)
      {
        *((_WORD *)this + 111) = 257;
        LogWarning("handlePerFrameGIFSaving", 2324, "*** NOTE: Global colormap was requested when saving GIF, but memory exceeds limit. Enabling local colormaps.\n");
      }
    }
  }
LABEL_9:
  if (*((_BYTE *)this + 222) && *((_BYTE *)this + 223))
  {
    v12 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
    IIODebugCallbackPriv(v12, "write");
    IIO_Reader::osType(*((IIO_Reader **)this + 8));
    kdebug_trace();
    if ((***((unsigned int (****)(_QWORD, _QWORD, IIOImageDestination *))this + 8))(*((_QWORD *)this + 8), *((_QWORD *)this + 3), this))
    {
      *((_BYTE *)this + 223) = 0;
    }
    IIO_Reader::osType(*((IIO_Reader **)this + 8));
    kdebug_trace();
    if (!*((_BYTE *)this + 223))
      _cg_jpeg_mem_term("handlePerFrameGIFSaving", 2347, "*** failed to write GIF frame #%d\n", *((_QWORD *)this + 7));
    IIOImageDestination::setPixelProviderAtIndex((uint64_t)this, 0, *((_QWORD *)this + 7));
    IIOImageDestination::setImagePropertiesAtIndex(this, 0, *((_QWORD *)this + 7));
    *(_QWORD *)&result = IIOImageDestination::setSourceImageAtIndex(this, 0, *((_QWORD *)this + 7)).n128_u64[0];
  }
  return result;
}

void sub_187FFBEEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIOImageDestination::handlePerFrameHEICSSaving(IIOImageDestination *this, CGImage *a2, IIODictionary *a3)
{
  const void *v4;
  uint64_t v5;
  uint64_t PixelProviderAtIndex;
  uint64_t ImagePropertiesAtIndex;
  BOOL v8;
  char v9;
  __n128 v10;

  if (*((_QWORD *)this + 6) == 1)
  {
    *((_WORD *)this + 111) = 257;
    if (!*((_QWORD *)this + 4))
      *((_QWORD *)this + 4) = (*(uint64_t (**)(_QWORD, _QWORD, IIOImageDestination *))(**((_QWORD **)this + 8)
                                                                                               + 8))(*((_QWORD *)this + 8), *((_QWORD *)this + 3), this);
  }
  v4 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
  IIODebugCallbackPriv(v4, "write");
  v5 = *((_QWORD *)this + 7);
  PixelProviderAtIndex = IIOImageDestination::getPixelProviderAtIndex((CFArrayRef *)this, v5);
  ImagePropertiesAtIndex = IIOImageDestination::getImagePropertiesAtIndex(this, v5);
  if ((*(unsigned int (**)(_QWORD, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD))(**((_QWORD **)this + 4)
                                                                                                 + 40))(*((_QWORD *)this + 4), PixelProviderAtIndex, 0, ImagePropertiesAtIndex, *((_QWORD *)this + 11), v5, 0))
  {
    v8 = 1;
  }
  else
  {
    v8 = *((_BYTE *)this + 223) == 0;
  }
  v9 = !v8;
  *((_BYTE *)this + 223) = v9;
  if (v8)
    _cg_jpeg_mem_term("handlePerFrameHEICSSaving", 2383, "*** failed to write HEICS frame #%d\n", *((_QWORD *)this + 7));
  IIOImageDestination::setPixelProviderAtIndex((uint64_t)this, 0, v5);
  v10 = IIOImageDestination::setImagePropertiesAtIndex(this, 0, v5);
  if (v5 == *((_QWORD *)this + 5) - 1)
    (*(void (**)(_QWORD, __n128))(**((_QWORD **)this + 4) + 48))(*((_QWORD *)this + 4), v10);
}

uint64_t IIOImageDestination::updateCreateHDRGainMapFlag(IIOImageDestination *this, CGImage *a2, IIODictionary *a3)
{
  CGColorSpace *ColorSpace;
  _BOOL4 v7;

  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s\n", "updateCreateHDRGainMapFlag");
  *((_BYTE *)this + 219) = -1;
  if (IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationCreateHDRGainMap")))
  {
    ColorSpace = CGImageGetColorSpace(a2);
    if (CGColorSpaceUsesITUR_2100TF(ColorSpace) || (v7 = CGColorSpaceUsesExtendedRange(ColorSpace)))
      LOBYTE(v7) = IIODictionary::getBoolForKey(a3, CFSTR("kCGImageDestinationCreateHDRGainMap"));
    *((_BYTE *)this + 219) = v7;
  }
  return 0;
}

uint64_t IIOImageDestination::updateCreateISOGainMapFlag(IIOImageDestination *this, CGImage *a2, IIODictionary *a3)
{
  CGColorSpace *ColorSpace;
  const __CFString *ObjectForKey;

  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s\n", "updateCreateISOGainMapFlag");
  *((_BYTE *)this + 220) = -1;
  if (IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationEncodeRequest")))
  {
    *((_BYTE *)this + 220) = 0;
    ColorSpace = CGImageGetColorSpace(a2);
    if (CGColorSpaceUsesITUR_2100TF(ColorSpace) || CGColorSpaceUsesExtendedRange(ColorSpace))
    {
      ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a3, CFSTR("kCGImageDestinationEncodeRequest"));
      if (CFStringCompare(ObjectForKey, CFSTR("kCGImageDestinationEncodeToISOGainmap"), 0) == kCFCompareEqualTo)
        *((_BYTE *)this + 220) = 1;
    }
  }
  return 0;
}

uint64_t IIOImageDestination::createCreateSDRandHDRGainMapFromHDR(IIOImageDestination *this, CGImageRef image, void **a3, CGImage **a4, IIODictionary *a5)
{
  CGColorSpace *ColorSpace;
  __IOSurface *IOSurfaceFromImage;
  size_t BitsPerComponent;
  __int16 BitmapInfo;
  BOOL v12;
  int v13;
  int v14;
  uint64_t HDRGainmap;
  int v16;
  int Width;
  int Height;
  OSType PixelFormat;
  __IOSurface *IOSurfaceWithPixelBufferAttributes;
  __IOSurface *v21;
  IIODictionary *v22;
  void **v23;
  float v24;
  float v25;
  const __CFDictionary *ObjectForKey;
  const UInt8 *BaseAddress;
  int v28;
  int v29;
  int BytesPerRow;
  OSType v31;
  CFDataRef v32;
  int Uint32ForKey;
  double DoubleForKey;
  CFTypeRef cf;
  _BYTE v38[24];
  _BYTE v39[24];
  _BYTE v40[24];
  _BYTE v41[24];
  _BYTE v42[24];
  uint64_t v43;
  void *v44;
  void *value;
  _BYTE v46[24];
  _BYTE v47[24];
  _BYTE v48[24];
  _BYTE v49[24];
  uint64_t v50;
  void *v51;
  uint64_t v52;
  const __CFDictionary *v53;
  const __CFDictionary *v54;

  v53 = 0;
  v54 = 0;
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s ☀️\n", "createCreateSDRandHDRGainMapFromHDR");
  ColorSpace = CGImageGetColorSpace(image);
  if (!CGColorSpaceUsesITUR_2100TF(ColorSpace) && !CGColorSpaceUsesExtendedRange(ColorSpace))
  {
    _cg_jpeg_mem_term("createCreateSDRandHDRGainMapFromHDR", 3102, "*** ERROR: input image is not HDR\n");
    return 4294967246;
  }
  if (!CGImageGetImageProvider() || CGImageProviderGetCallbackVersion() < 2)
  {
    BitsPerComponent = CGImageGetBitsPerComponent(image);
    BitmapInfo = CGImageGetBitmapInfo(image);
    switch(BitsPerComponent)
    {
      case 0x20uLL:
        v16 = 1380410945;
        break;
      case 0x10uLL:
        v14 = 1380411457;
        v12 = (BitmapInfo & 0xF00) == 256;
        v13 = 1815491698;
LABEL_16:
        if (v12)
          v16 = v14;
        else
          v16 = v13;
        break;
      case 8uLL:
        v12 = (BitmapInfo & 0x7000) == 0x2000;
        v13 = 1380401729;
        v14 = 1111970369;
        goto LABEL_16;
      default:
        v16 = 0;
        break;
    }
    IOSurfaceFromImage = IIO_CreateIOSurfaceFromImage(image, v16, 0);
    goto LABEL_21;
  }
  v50 = 0;
  v51 = 0;
  v52 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v50);
  IIONumber::IIONumber((IIONumber *)v49, 2019963440);
  IIODictionary::setObjectForKey((uint64_t)&v50, (uint64_t)v49, CFSTR("kCGImageSurfaceFormatRequest"));
  IIONumber::~IIONumber((IIONumber *)v49);
  IOSurfaceFromImage = (__IOSurface *)CGImageProviderCopyIOSurface();
  if (!IOSurfaceFromImage)
  {
    _cg_jpeg_mem_term("createCreateSDRandHDRGainMapFromHDR", 3121, "*** ERROR: failed to get IOSurface from image (%p)\n", image);
    IIODictionary::~IIODictionary((IIODictionary *)&v50);
    return 4294967292;
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v50);
LABEL_21:
  IIO_LoadHEIFSymbols();
  v50 = 0;
  v51 = 0;
  v52 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v50);
  Width = IOSurfaceGetWidth(IOSurfaceFromImage);
  IIONumber::IIONumber((IIONumber *)v48, Width);
  IIODictionary::setObjectForKey((uint64_t)&v50, (uint64_t)v48, *(const void **)gIIO_kCVPixelBufferWidthKey);
  IIONumber::~IIONumber((IIONumber *)v48);
  Height = IOSurfaceGetHeight(IOSurfaceFromImage);
  IIONumber::IIONumber((IIONumber *)v47, Height);
  IIODictionary::setObjectForKey((uint64_t)&v50, (uint64_t)v47, *(const void **)gIIO_kCVPixelBufferHeightKey);
  IIONumber::~IIONumber((IIONumber *)v47);
  PixelFormat = IOSurfaceGetPixelFormat(IOSurfaceFromImage);
  IIONumber::IIONumber((IIONumber *)v46, PixelFormat);
  IIODictionary::setObjectForKey((uint64_t)&v50, (uint64_t)v46, *(const void **)gIIO_kCVPixelBufferPixelFormatTypeKey);
  IIONumber::~IIONumber((IIONumber *)v46);
  IIODictionary::setObjectForKey((IIODictionary *)&v50, ColorSpace, *(const __CFString **)gIIO_kCVImageBufferCGColorSpaceKey);
  HDRGainmap = IIOCreatePixelBufferAttributesForHDRType(1, v51, a3[1], &v54);
  if ((_DWORD)HDRGainmap)
  {
    LogError("createCreateSDRandHDRGainMapFromHDR", 3156, "*** ERROR: failed to create output pixel buffer attributes (%d)\n", HDRGainmap);
    IOSurfaceWithPixelBufferAttributes = 0;
  }
  else
  {
    IOSurfaceWithPixelBufferAttributes = IIO_CreateIOSurfaceWithPixelBufferAttributes(v54);
    if (!IOSurfaceWithPixelBufferAttributes)
    {
      LogError("createCreateSDRandHDRGainMapFromHDR", 3159, "*** ERROR: failed to create output IOSurface\n");
      IOSurfaceWithPixelBufferAttributes = 0;
      goto LABEL_43;
    }
    HDRGainmap = IIOCreatePixelBufferAttributesForHDRType(3, v51, a3[1], &v53);
    if (!(_DWORD)HDRGainmap)
    {
      v21 = IIO_CreateIOSurfaceWithPixelBufferAttributes(v53);
      if (v21)
      {
        v22 = (IIODictionary *)operator new();
        IIODictionary::IIODictionary(v22);
        v23 = (void **)operator new();
        IIODictionary::IIODictionary((IIODictionary *)v23);
        CGImageGetContentHeadroom();
        v25 = v24;
        if (v24 == 0.0)
        {
          v25 = 8.0;
          if ((gIIODebugFlags & 0x300000) != 0)
            ImageIOLog("☀️  %s - srcImage has headroom '0.0' --> using 8.0 \n", "createCreateSDRandHDRGainMapFromHDR");
        }
        IIONumber::IIONumber((IIONumber *)&v43, v25);
        IIODictionary::setObjectForKey((IIODictionary *)v23, value, CFSTR("kCGTargetHeadroom"));
        IIONumber::~IIONumber((IIONumber *)&v43);
        if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGToneMappingMode")))
        {
          ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)a3, CFSTR("kCGToneMappingMode"));
          IIODictionary::setObjectForKey((IIODictionary *)v23, ObjectForKey, CFSTR("kCGToneMappingMode"));
        }
        HDRGainmap = IIOCallCreateHDRGainmap(IOSurfaceFromImage, IOSurfaceWithPixelBufferAttributes, (uint64_t)v21, v23[1]);
        if ((_DWORD)HDRGainmap)
        {
          LogError("createCreateSDRandHDRGainMapFromHDR", 3190, "*** ERROR: failed to create HDR gain map (%d)\n", HDRGainmap);
          goto LABEL_45;
        }
        if (a4)
          *a4 = CGImageCreateFromIOSurface(IOSurfaceWithPixelBufferAttributes, 0);
        if (a5)
        {
          IOSurfaceLock(v21, 1u, 0);
          BaseAddress = (const UInt8 *)IOSurfaceGetBaseAddress(v21);
          v28 = IOSurfaceGetWidth(v21);
          v29 = IOSurfaceGetHeight(v21);
          BytesPerRow = IOSurfaceGetBytesPerRow(v21);
          v31 = IOSurfaceGetPixelFormat(v21);
          v32 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], BaseAddress, (BytesPerRow * v29));
          IOSurfaceUnlock(v21, 1u, 0);
          IIODictionary::setObjectForKey(a5, v32, CFSTR("kCGImageAuxiliaryDataInfoData"));
          CFRelease(v32);
          v43 = 0;
          v44 = 0;
          value = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v43);
          IIONumber::IIONumber((IIONumber *)v42, v28);
          IIODictionary::setObjectForKey((uint64_t)&v43, (uint64_t)v42, CFSTR("Width"));
          IIONumber::~IIONumber((IIONumber *)v42);
          IIONumber::IIONumber((IIONumber *)v41, v29);
          IIODictionary::setObjectForKey((uint64_t)&v43, (uint64_t)v41, CFSTR("Height"));
          IIONumber::~IIONumber((IIONumber *)v41);
          IIONumber::IIONumber((IIONumber *)v40, BytesPerRow);
          IIODictionary::setObjectForKey((uint64_t)&v43, (uint64_t)v40, CFSTR("BytesPerRow"));
          IIONumber::~IIONumber((IIONumber *)v40);
          IIONumber::IIONumber((IIONumber *)v39, v31);
          IIODictionary::setObjectForKey((uint64_t)&v43, (uint64_t)v39, CFSTR("PixelFormat"));
          IIONumber::~IIONumber((IIONumber *)v39);
          Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)a3, CFSTR("Orientation"));
          IIONumber::IIONumber((IIONumber *)v38, Uint32ForKey);
          IIODictionary::setObjectForKey((uint64_t)&v43, (uint64_t)v38, CFSTR("Orientation"));
          IIONumber::~IIONumber((IIONumber *)v38);
          IIODictionary::setObjectForKey(a5, v44, CFSTR("kCGImageAuxiliaryDataInfoDataDescription"));
          cf = 0;
          DoubleForKey = IIODictionary::getDoubleForKey((IIODictionary *)v23, CFSTR("kCGTargetHeadroom"));
          HDRGainmap = IIOCreateHDRGainMapMetadata((CGImageMetadata **)&cf, DoubleForKey);
          if (!(_DWORD)HDRGainmap)
          {
            IIODictionary::setObjectForKey(a5, cf, CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
            CFRelease(cf);
          }
          IIODictionary::~IIODictionary((IIODictionary *)&v43);
          goto LABEL_45;
        }
        goto LABEL_44;
      }
      LogError("createCreateSDRandHDRGainMapFromHDR", 3166, "*** ERROR: fail to create gain map IOSurface\n");
LABEL_43:
      v21 = 0;
      v23 = 0;
LABEL_44:
      HDRGainmap = 0;
      goto LABEL_45;
    }
    LogError("createCreateSDRandHDRGainMapFromHDR", 3163, "*** ERROR: fail to create gain map pixel buffer attributes (%d)\n", HDRGainmap);
  }
  v21 = 0;
  v23 = 0;
LABEL_45:
  if (IOSurfaceFromImage)
    CFRelease(IOSurfaceFromImage);
  if (IOSurfaceWithPixelBufferAttributes)
    CFRelease(IOSurfaceWithPixelBufferAttributes);
  if (v21)
    CFRelease(v21);
  if (v54)
    CFRelease(v54);
  if (v53)
    CFRelease(v53);
  if (v23)
    (*((void (**)(void **))*v23 + 1))(v23);
  IIODictionary::~IIODictionary((IIODictionary *)&v50);
  return HDRGainmap;
}

void sub_187FFC91C(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIONumber::~IIONumber((IIONumber *)(v1 - 168));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 144));
  _Unwind_Resume(a1);
}

void IIOImageDestination::addAuxiliaryDataInfo(IIOImageDestination *this, const __CFString *a2, const void **a3)
{
  const __CFString *v6;
  int v7;
  char v8;
  int v9;
  int v10;
  uint64_t *v11;
  CFComparisonResult v12;
  char v13;
  uint64_t v14;
  int v15;
  __CFArray *Mutable;
  const void *v17;
  IIOString *v18;
  const char *v19;
  IIOString *v20;
  const char *v21;
  _BYTE v22[24];
  _BYTE v23[24];
  _BYTE v24[24];
  uint64_t v25;
  void *v26;
  uint64_t v27;
  CFMutableArrayRef v28;
  uint64_t v29;
  uint64_t v30;

  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeDisparity"), a2, 0) == kCFCompareEqualTo)
  {
    v9 = 0;
    v6 = 0;
    v10 = 1;
    goto LABEL_35;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeDepth"), a2, 0) == kCFCompareEqualTo)
  {
    v9 = 0;
    v6 = 0;
    v10 = 2;
    goto LABEL_35;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeAlpha"), a2, 0) == kCFCompareEqualTo)
  {
    v9 = 0;
    v6 = 0;
    v10 = 3;
    goto LABEL_35;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypePortraitEffectsMatte"), a2, 0) == kCFCompareEqualTo)
  {
    v9 = 0;
    v6 = 0;
    v10 = 5;
    goto LABEL_35;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationSkinMatte"), a2, 0) == kCFCompareEqualTo)
  {
    v7 = 0;
    v8 = 1;
    v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte;
LABEL_27:
    v9 = 0;
    v6 = *(const __CFString **)*v11;
    goto LABEL_28;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationHairMatte"), a2, 0) == kCFCompareEqualTo)
  {
    v7 = 0;
    v8 = 1;
    v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte;
    goto LABEL_27;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationTeethMatte"), a2, 0) == kCFCompareEqualTo)
  {
    v7 = 0;
    v8 = 1;
    v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte;
    goto LABEL_27;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationGlassesMatte"), a2, 0) == kCFCompareEqualTo)
  {
    v8 = 0;
    v7 = 1;
    v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte;
    goto LABEL_27;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationSkyMatte"), a2, 0) == kCFCompareEqualTo)
  {
    v8 = 0;
    v7 = 2;
    v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte;
    goto LABEL_27;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), a2, 0) == kCFCompareEqualTo)
  {
    v8 = 0;
    v7 = 3;
    v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap;
    goto LABEL_27;
  }
  v6 = CFSTR("kCGImageAuxiliaryDataTypeISOGainMap");
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"), a2, 0))
  {
    if (!IIO_OSAppleInternalBuild()
      || !CFStringHasPrefix(a2, CFSTR("http:"))
      && !CFStringHasPrefix(a2, CFSTR("https:"))
      && !CFStringHasPrefix(a2, CFSTR("urn:")))
    {
      goto LABEL_59;
    }
    v7 = 0;
    v8 = 1;
    v6 = a2;
    v9 = 1;
LABEL_28:
    if (v6)
    {
      v12 = CFStringCompare(v6, CFSTR("FIG_STRING_SYMBOL_NOT_FOUND"), 0);
      if (v12)
        v13 = 1;
      else
        v13 = v8;
      if ((v13 & 1) != 0)
      {
        if (v12)
        {
          v10 = 4;
          goto LABEL_35;
        }
      }
      else
      {
        LogError("addAuxiliaryDataInfo", 4401, "*** ERROR: addAuxiliaryDataInfo - MediaToolbox symbol not found [%d]\n", v7);
      }
    }
LABEL_59:
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v20 = IIOString::IIOString((IIOString *)&v28, a2);
    v21 = (const char *)IIOString::utf8String(v20);
    LogError("addAuxiliaryDataInfo", 4483, "*** ERROR: unsupported auxiliaryDataType: '%s'\n", v21);
    goto LABEL_60;
  }
  v9 = 0;
  v10 = 98;
LABEL_35:
  IIOImageDestination::swapWriterIfNeeded((IIO_Writer **)this, 0, 1);
  v14 = *((_QWORD *)this + 8);
  if (!v14)
  {
    LogError("addAuxiliaryDataInfo", 4415, "*** ERROR: depth/disparity is not supported on this platform\n");
    return;
  }
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14) & 1) == 0)
  {
    v17 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
    v18 = IIOString::IIOString((IIOString *)&v28, v17);
    v19 = (const char *)IIOString::utf8String(v18);
    LogError("addAuxiliaryDataInfo", 4421, "*** ERROR: can't add depth/disparity to '%s'\n", v19);
LABEL_60:
    IIOString::~IIOString((IIOString *)&v28);
    return;
  }
  if (*((_BYTE *)this + 226))
  {
    if ((IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageAuxiliaryDataInfoData")) & 1) != 0
      || (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageAuxiliaryDataInfoImage")) & 1) != 0
      || (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageAuxiliaryDataInfoPixelBuffer")) & 1) != 0|| (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageAuxiliaryDataInfoIOSurface")) & 1) != 0)
    {
      v15 = 1;
    }
    else
    {
      LogError("addAuxiliaryDataInfo", 4441, "*** ERROR: 'auxiliaryDataInfoDictionary' is missing 'kCGImageAuxiliaryDataInfoData' key\n");
      v15 = 0;
    }
    if ((IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageAuxiliaryDataInfoDataDescription")) & 1) == 0&& IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageAuxiliaryDataInfoData")))
    {
      LogError("addAuxiliaryDataInfo", 4447, "*** ERROR: 'auxiliaryDataInfoDictionary' is missing 'kCGImageAuxiliaryDataInfoDataDescription' key\n");
      v15 = 0;
    }
    if ((IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageAuxiliaryDataInfoMetadata")) & 1) == 0)
      _cg_jpeg_mem_term("addAuxiliaryDataInfo", 4452, "*** 'auxiliaryDataInfoDictionary' is missing (optional) 'kCGImageAuxiliaryDataInfoMetadata' key\n");
    if (v15)
    {
      Mutable = (__CFArray *)*((_QWORD *)this + 19);
      if (!Mutable)
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        *((_QWORD *)this + 19) = Mutable;
      }
      v28 = 0;
      v29 = 0;
      v30 = 0;
      IIOArray::IIOArray((IIOArray *)&v28, Mutable);
      v25 = 0;
      v26 = 0;
      v27 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v25);
      IIODictionary::setObjectForKey((IIODictionary *)&v25, a3[1], a2);
      IIONumber::IIONumber((IIONumber *)v24, *((_DWORD *)this + 14));
      IIODictionary::setObjectForKey((uint64_t)&v25, (uint64_t)v24, CFSTR("ImageIndex"));
      IIONumber::~IIONumber((IIONumber *)v24);
      IIONumber::IIONumber((IIONumber *)v23, v10);
      IIODictionary::setObjectForKey((uint64_t)&v25, (uint64_t)v23, "AuxiliaryImageType");
      IIONumber::~IIONumber((IIONumber *)v23);
      IIONumber::IIONumber((IIONumber *)v22, v9);
      IIODictionary::setObjectForKey((uint64_t)&v25, (uint64_t)v22, "customMetadata");
      IIONumber::~IIONumber((IIONumber *)v22);
      if (v6)
        IIODictionary::setObjectForKey((IIODictionary *)&v25, v6, "AuxiliaryImageURN");
      IIOArray::addObject(&v28, v26);
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
      IIOArray::~IIOArray((IIOArray *)&v28);
    }
  }
  else
  {
    LogError("addAuxiliaryDataInfo", 4428, "*** ERROR: please add an image before calling CGImageDestinationAddAuxiliaryDataInfo\n");
  }
}

void sub_187FFCFF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIOArray::~IIOArray((IIOArray *)(v2 - 88));
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::createCreateSDRandISOGainMapFromHDR(IIOImageDestination *this, CGImageRef image, void **a3, CGImage **a4, IIODictionary *a5)
{
  CGColorSpace *ColorSpace;
  __IOSurface *IOSurfaceFromImage;
  size_t BitsPerComponent;
  __int16 BitmapInfo;
  int v12;
  int v13;
  int v14;
  int Width;
  int Height;
  OSType PixelFormat;
  uint64_t v18;
  __IOSurface *IOSurfaceWithPixelBufferAttributes;
  CGImageAlphaInfo AlphaInfo;
  __IOSurface *v21;
  void **v22;
  float v23;
  float v24;
  const void *v25;
  int BoolForKeyGroup;
  const UInt8 *BaseAddress;
  int v28;
  int v29;
  int BytesPerRow;
  OSType v31;
  CFDataRef v32;
  int Uint32ForKey;
  _BYTE v36[24];
  _BYTE v37[24];
  _BYTE v38[24];
  _BYTE v39[24];
  _BYTE v40[24];
  uint64_t v41;
  void *v42;
  void *value;
  _BYTE v44[24];
  _BYTE v45[24];
  _BYTE v46[24];
  _BYTE v47[24];
  uint64_t v48;
  void *v49;
  uint64_t v50;
  CGImageMetadata *v51;
  const __CFDictionary *v52;
  const __CFDictionary *v53;

  v52 = 0;
  v53 = 0;
  v51 = 0;
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s\n", "createCreateSDRandISOGainMapFromHDR");
  ColorSpace = CGImageGetColorSpace(image);
  if (!CGColorSpaceUsesITUR_2100TF(ColorSpace) && !CGColorSpaceUsesExtendedRange(ColorSpace))
  {
    _cg_jpeg_mem_term("createCreateSDRandISOGainMapFromHDR", 2929, "*** ERROR: input image is not HDR\n");
    return 4294967246;
  }
  if (CGImageGetImageProvider() && CGImageProviderGetCallbackVersion() >= 2)
  {
    v48 = 0;
    v49 = 0;
    v50 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v48);
    IIONumber::IIONumber((IIONumber *)v47, 2019963440);
    IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v47, CFSTR("kCGImageSurfaceFormatRequest"));
    IIONumber::~IIONumber((IIONumber *)v47);
    IOSurfaceFromImage = (__IOSurface *)CGImageProviderCopyIOSurface();
    if (!IOSurfaceFromImage)
    {
      _cg_jpeg_mem_term("createCreateSDRandISOGainMapFromHDR", 2945, "*** ERROR: failed to get IOSurface from image (%p)\n", image);
      IIODictionary::~IIODictionary((IIODictionary *)&v48);
      return 4294967292;
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v48);
  }
  else
  {
    BitsPerComponent = CGImageGetBitsPerComponent(image);
    BitmapInfo = CGImageGetBitmapInfo(image);
    if ((BitmapInfo & 0xF00) == 0x100)
      v12 = 1380411457;
    else
      v12 = 1815491698;
    if ((BitmapInfo & 0x7000) == 0x2000)
      v13 = 1111970369;
    else
      v13 = 1380401729;
    if (BitsPerComponent != 8)
      v13 = 0;
    if (BitsPerComponent == 16)
      v14 = v12;
    else
      v14 = v13;
    IOSurfaceFromImage = IIO_CreateIOSurfaceFromImage(image, v14, 0);
  }
  IIO_LoadHEIFSymbols();
  v48 = 0;
  v49 = 0;
  v50 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v48);
  Width = IOSurfaceGetWidth(IOSurfaceFromImage);
  IIONumber::IIONumber((IIONumber *)v46, Width);
  IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v46, *(const void **)gIIO_kCVPixelBufferWidthKey);
  IIONumber::~IIONumber((IIONumber *)v46);
  Height = IOSurfaceGetHeight(IOSurfaceFromImage);
  IIONumber::IIONumber((IIONumber *)v45, Height);
  IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v45, *(const void **)gIIO_kCVPixelBufferHeightKey);
  IIONumber::~IIONumber((IIONumber *)v45);
  PixelFormat = IOSurfaceGetPixelFormat(IOSurfaceFromImage);
  IIONumber::IIONumber((IIONumber *)v44, PixelFormat);
  IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v44, *(const void **)gIIO_kCVPixelBufferPixelFormatTypeKey);
  IIONumber::~IIONumber((IIONumber *)v44);
  IIODictionary::setObjectForKey((IIODictionary *)&v48, ColorSpace, *(const __CFString **)gIIO_kCVImageBufferCGColorSpaceKey);
  v18 = IIOCreatePixelBufferAttributesForHDRType(1, v49, a3[1], &v53);
  if ((_DWORD)v18)
  {
    LogError("createCreateSDRandISOGainMapFromHDR", 2977, "*** ERROR: failed to create output pixel buffer attributes (%d)\n", v18);
    IOSurfaceWithPixelBufferAttributes = 0;
LABEL_55:
    v21 = 0;
    v22 = 0;
    goto LABEL_34;
  }
  IOSurfaceWithPixelBufferAttributes = IIO_CreateIOSurfaceWithPixelBufferAttributes(v53);
  if (!IOSurfaceWithPixelBufferAttributes)
  {
    LogError("createCreateSDRandISOGainMapFromHDR", 2980, "*** ERROR: failed to create output IOSurface\n");
    IOSurfaceWithPixelBufferAttributes = 0;
    goto LABEL_57;
  }
  AlphaInfo = CGImageGetAlphaInfo(image);
  IIO_IOSurfaceSetAlpha(IOSurfaceWithPixelBufferAttributes, AlphaInfo);
  v18 = IIOCreatePixelBufferAttributesForHDRType(3, v49, a3[1], &v52);
  if ((_DWORD)v18)
  {
    LogError("createCreateSDRandISOGainMapFromHDR", 2984, "*** ERROR: fail to create iso gain map pixel buffer attributes (%d)\n", v18);
    goto LABEL_55;
  }
  v21 = IIO_CreateIOSurfaceWithPixelBufferAttributes(v52);
  if (v21)
  {
    v22 = (void **)operator new();
    IIODictionary::IIODictionary((IIODictionary *)v22);
    CGImageGetContentHeadroom();
    v24 = v23;
    if (v23 == 0.0)
    {
      v24 = 8.0;
      if ((gIIODebugFlags & 0x300000) != 0)
        ImageIOLog("☀️  %s - srcImage has headroom '0.0' --> using 8.0 \n", "createCreateSDRandISOGainMapFromHDR");
    }
    IIONumber::IIONumber((IIONumber *)&v41, v24);
    IIODictionary::setObjectForKey((IIODictionary *)v22, value, CFSTR("kCGTargetHeadroom"));
    IIONumber::~IIONumber((IIONumber *)&v41);
    IIODictionary::setObjectForKeyGroup((IIODictionary *)v22, (const void *)*MEMORY[0x1E0C9D9E0], CFSTR("kCGFlexRangeAlternateColorSpace"), CFSTR("kCGFlexRangeOptions"));
    v25 = (const void *)*MEMORY[0x1E0C9AE40];
    IIODictionary::setObjectForKeyGroup((IIODictionary *)v22, (const void *)*MEMORY[0x1E0C9AE40], CFSTR("kCGFlexRangeBaseIsHDR"), CFSTR("kCGFlexRangeOptions"));
    IIONumber::IIONumber((IIONumber *)&v41, 1);
    IIODictionary::setObjectForKeyGroup((IIODictionary *)v22, value, CFSTR("kCGFlexRangeSubsample"), CFSTR("kCGFlexRangeOptions"));
    IIONumber::~IIONumber((IIONumber *)&v41);
    BoolForKeyGroup = IIODictionary::getBoolForKeyGroup((IIODictionary *)a3, CFSTR("kCGDisableMetal"), CFSTR("kCGImageDestinationEncodeRequestOptions"));
    IIONumber::IIONumber((IIONumber *)&v41, BoolForKeyGroup);
    IIODictionary::setObjectForKey((IIODictionary *)v22, value, CFSTR("kCGDisableMetal"));
    IIONumber::~IIONumber((IIONumber *)&v41);
    IIODictionary::setObjectForKey((IIODictionary *)v22, v25, CFSTR("kCGFlexRangeUseAlternateColor"));
    IIONumber::IIONumber((IIONumber *)&v41, 1278226488);
    IIODictionary::setObjectForKey((IIODictionary *)v22, value, CFSTR("kCGTargetPixelFormat"));
    IIONumber::~IIONumber((IIONumber *)&v41);
    v18 = IIOCallConvertHDRGainMap(IOSurfaceFromImage, 0, IOSurfaceWithPixelBufferAttributes, (uint64_t)v21, &v51, v22[1]);
    if ((_DWORD)v18)
    {
      LogError("createCreateSDRandISOGainMapFromHDR", 3012, "*** ERROR: failed to create HDR gain map (%d)\n", v18);
      goto LABEL_34;
    }
    if (a4)
      *a4 = CGImageCreateFromIOSurface(IOSurfaceWithPixelBufferAttributes, 0);
    if (a5)
    {
      IOSurfaceLock(v21, 1u, 0);
      BaseAddress = (const UInt8 *)IOSurfaceGetBaseAddress(v21);
      v28 = IOSurfaceGetWidth(v21);
      v29 = IOSurfaceGetHeight(v21);
      BytesPerRow = IOSurfaceGetBytesPerRow(v21);
      v31 = IOSurfaceGetPixelFormat(v21);
      v32 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], BaseAddress, (BytesPerRow * v29));
      IOSurfaceUnlock(v21, 1u, 0);
      IIODictionary::setObjectForKey(a5, v32, CFSTR("kCGImageAuxiliaryDataInfoData"));
      CFRelease(v32);
      v41 = 0;
      v42 = 0;
      value = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v41);
      IIONumber::IIONumber((IIONumber *)v40, v28);
      IIODictionary::setObjectForKey((uint64_t)&v41, (uint64_t)v40, CFSTR("Width"));
      IIONumber::~IIONumber((IIONumber *)v40);
      IIONumber::IIONumber((IIONumber *)v39, v29);
      IIODictionary::setObjectForKey((uint64_t)&v41, (uint64_t)v39, CFSTR("Height"));
      IIONumber::~IIONumber((IIONumber *)v39);
      IIONumber::IIONumber((IIONumber *)v38, BytesPerRow);
      IIODictionary::setObjectForKey((uint64_t)&v41, (uint64_t)v38, CFSTR("BytesPerRow"));
      IIONumber::~IIONumber((IIONumber *)v38);
      IIONumber::IIONumber((IIONumber *)v37, v31);
      IIODictionary::setObjectForKey((uint64_t)&v41, (uint64_t)v37, CFSTR("PixelFormat"));
      IIONumber::~IIONumber((IIONumber *)v37);
      Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)a3, CFSTR("Orientation"));
      IIONumber::IIONumber((IIONumber *)v36, Uint32ForKey);
      IIODictionary::setObjectForKey((uint64_t)&v41, (uint64_t)v36, CFSTR("Orientation"));
      IIONumber::~IIONumber((IIONumber *)v36);
      IIODictionary::setObjectForKey(a5, v42, CFSTR("kCGImageAuxiliaryDataInfoDataDescription"));
      IIODictionary::setObjectForKey(a5, v51, CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
      IIODictionary::~IIODictionary((IIODictionary *)&v41);
    }
    goto LABEL_33;
  }
  LogError("createCreateSDRandISOGainMapFromHDR", 2987, "*** ERROR: fail to create iso gain map IOSurface\n");
LABEL_57:
  v21 = 0;
  v22 = 0;
LABEL_33:
  v18 = 0;
LABEL_34:
  if (v51)
    CFRelease(v51);
  if (IOSurfaceFromImage)
    CFRelease(IOSurfaceFromImage);
  if (IOSurfaceWithPixelBufferAttributes)
    CFRelease(IOSurfaceWithPixelBufferAttributes);
  if (v21)
    CFRelease(v21);
  if (v53)
    CFRelease(v53);
  if (v52)
    CFRelease(v52);
  if (v22)
    (*((void (**)(void **))*v22 + 1))(v22);
  IIODictionary::~IIODictionary((IIODictionary *)&v48);
  return v18;
}

void sub_187FFD83C(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIONumber::~IIONumber((IIONumber *)(v1 - 176));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 152));
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::updatePreserveGainMapFlag(IIOImageDestination *this, IIOImageSource *a2, IIODictionary *a3)
{
  _BOOL4 BoolForKey;
  IIODictionary *Properties;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFArray *v9;
  const __CFDictionary *ValueAtIndex;
  const __CFArray *Value;
  const __CFArray *v12;
  CFIndex Count;
  CFIndex v14;
  CFIndex v15;
  const __CFDictionary *v16;
  const __CFString *v17;
  const __CFString *v18;
  char v19;

  *((_BYTE *)this + 218) = -1;
  if (IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationPreserveGainMap")))
  {
    BoolForKey = IIODictionary::getBoolForKey(a3, CFSTR("kCGImageDestinationPreserveGainMap"));
    *((_BYTE *)this + 218) = 0;
    if (BoolForKey)
    {
      Properties = (IIODictionary *)IIOImageSource::getProperties(a2, 0);
      if (Properties)
      {
        ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(Properties, CFSTR("Images"), CFSTR("{FileContents}"));
        if (ObjectForKeyGroup)
        {
          v9 = ObjectForKeyGroup;
          if (CFArrayGetCount(ObjectForKeyGroup))
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, 0);
            if (ValueAtIndex)
            {
              Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, CFSTR("AuxiliaryData"));
              if (Value)
              {
                v12 = Value;
                Count = CFArrayGetCount(Value);
                if (Count < 1)
                {
LABEL_15:
                  v19 = 0;
                }
                else
                {
                  v14 = Count;
                  v15 = 0;
                  while (1)
                  {
                    v16 = (const __CFDictionary *)CFArrayGetValueAtIndex(v12, v15);
                    if (v16)
                    {
                      v17 = (const __CFString *)CFDictionaryGetValue(v16, CFSTR("AuxiliaryDataType"));
                      if (v17)
                      {
                        v18 = v17;
                        if (CFStringCompare(v17, CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), 0) == kCFCompareEqualTo
                          || CFStringCompare(v18, CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"), 0) == kCFCompareEqualTo)
                        {
                          break;
                        }
                      }
                    }
                    if (v14 == ++v15)
                      goto LABEL_15;
                  }
                  v19 = 1;
                }
                *((_BYTE *)this + 218) = v19;
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t IIOImageDestination::createImageFromSource(CGImageSourceRef *this, size_t a2, IIODictionary *a3, IIODictionary *a4, CGImage **a5)
{
  unsigned int Uint32ForKey;
  _BOOL4 BoolForKey;
  unsigned int v11;
  CGImage *ImageAtIndex;
  size_t Width;
  size_t Height;
  size_t v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;
  uint64_t v19;
  const __CFDictionary *ObjectForKey;
  CGImage *ThumbnailAtIndex;
  const __CFDictionary *v22;
  _BYTE v25[24];
  _BYTE v26[16];
  void *value;
  uint64_t v28;
  CFDictionaryRef options;
  uint64_t v30;

  Uint32ForKey = IIODictionary::getUint32ForKey(a3, CFSTR("kCGImageSourceSubsampleFactor"));
  BoolForKey = IIODictionary::getBoolForKey(a3, CFSTR("kCGImageSourceEnableRestrictedDecoding"));
  v11 = IIODictionary::getUint32ForKey(a3, CFSTR("kCGImageDestinationImageMaxPixelSize"));
  v28 = 0;
  options = 0;
  v30 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v28);
  IIODictionary::setObjectForKey((IIODictionary *)&v28, (const void *)*MEMORY[0x1E0C9AE40], CFSTR("kCGImageSourceUseHardwareAcceleration"));
  if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
    ImageIOLog("••• ❌ UseHardwareAcceleration  | %s:%d\n", "createImageFromSource", 3273);
  if (BoolForKey)
    IIODictionary::setObjectForKey((IIODictionary *)&v28, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageSourceEnableRestrictedDecoding"));
  if (!v11)
    goto LABEL_33;
  IIONumber::IIONumber((IIONumber *)v26, v11);
  IIODictionary::setObjectForKey((IIODictionary *)&v28, value, CFSTR("kCGImageDestinationImageMaxPixelSize"));
  IIONumber::~IIONumber((IIONumber *)v26);
  ImageAtIndex = CGImageSourceCreateImageAtIndex(this[20], a2, options);
  Width = CGImageGetWidth(ImageAtIndex);
  Height = CGImageGetHeight(ImageAtIndex);
  if (ImageAtIndex)
    CFRelease(ImageAtIndex);
  if (Width >= Height)
    v15 = Height;
  else
    v15 = Width;
  if (v11 < v15 >> 3)
  {
    v16 = 8;
    goto LABEL_16;
  }
  if (v11 < v15 >> 2)
  {
    v16 = 4;
LABEL_16:
    if (v16 > Uint32ForKey)
      Uint32ForKey = v16;
    goto LABEL_26;
  }
  v17 = v11 >= v15 >> 1;
  if (v17)
    v18 = 0;
  else
    v18 = 2;
  if (v18 <= Uint32ForKey)
    v18 = Uint32ForKey;
  if (!v17)
    Uint32ForKey = v18;
LABEL_26:
  if (*((_BYTE *)this + 219) != 1
    || (v19 = IIOImageSource::reader(*((IIOImageSource **)this[20] + 3)),
        !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v19 + 208))(v19)))
  {
LABEL_33:
    if (Uint32ForKey)
    {
      IIONumber::IIONumber((IIONumber *)v26, Uint32ForKey);
      IIODictionary::setObjectForKey((IIODictionary *)&v28, value, CFSTR("kCGImageSourceSubsampleFactor"));
      IIONumber::~IIONumber((IIONumber *)v26);
      v22 = options;
    }
    else
    {
      v22 = 0;
    }
    ThumbnailAtIndex = CGImageSourceCreateImageAtIndex(this[20], a2, v22);
    goto LABEL_37;
  }
  IIODictionary::setObjectForKey((IIODictionary *)&v28, CFSTR("kCGImageSourceDecodeToHDR"), CFSTR("kCGImageSourceDecodeRequest"));
  if (Uint32ForKey)
  {
    IIONumber::IIONumber((IIONumber *)v26, Uint32ForKey);
    IIODictionary::setObjectForKey((IIODictionary *)&v28, value, CFSTR("kCGImageSourceSubsampleFactor"));
    IIONumber::~IIONumber((IIONumber *)v26);
  }
  IIONumber::IIONumber((IIONumber *)v26, v11);
  IIODictionary::setObjectForKey((IIODictionary *)&v28, value, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
  IIONumber::~IIONumber((IIONumber *)v26);
  IIODictionary::setObjectForKey((IIODictionary *)&v28, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageSourceCreateThumbnailFromImageAlways"));
  if (IIODictionary::containsKey(a3, CFSTR("kCGImageSourceCreateThumbnailWithTransform")))
  {
    ObjectForKey = IIODictionary::getObjectForKey(a3, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
    IIODictionary::setObjectForKey((IIODictionary *)&v28, ObjectForKey, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
    IIONumber::IIONumber((IIONumber *)v25, 1);
    IIODictionary::setObjectForKey((uint64_t)a4, (uint64_t)v25, CFSTR("Orientation"));
    IIONumber::~IIONumber((IIONumber *)v25);
  }
  ThumbnailAtIndex = CGImageSourceCreateThumbnailAtIndex(this[20], a2, options);
LABEL_37:
  *a5 = ThumbnailAtIndex;
  IIODictionary::~IIODictionary((IIODictionary *)&v28);
  return 0;
}

void sub_187FFDE14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

void IIOImageDestination::updateDateTime(IIOImageDestination *this, IIODictionary *a2, IIODictionary *a3)
{
  const __CFString *ObjectForKey;
  CFStringRef IPTCDateStringWithXMPDateTimeString;
  CFStringRef IPTCTimeStringWithXMPDateTimeString;

  if (a2)
  {
    if (a3)
    {
      if (IIODictionary::containsKey(a2, CFSTR("{IPTC}")))
      {
        ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a3, CFSTR("DateTimeDigitized"));
        if (ObjectForKey
          || (ObjectForKey = (const __CFString *)IIODictionary::getObjectForKeyGroup(a3, CFSTR("DateTimeDigitized"), CFSTR("{Exif}"))) != 0)
        {
          IPTCDateStringWithXMPDateTimeString = CreateIPTCDateStringWithXMPDateTimeString(ObjectForKey);
          IPTCTimeStringWithXMPDateTimeString = CreateIPTCTimeStringWithXMPDateTimeString(ObjectForKey);
          IIODictionary::setObjectForKeyGroup(a2, IPTCDateStringWithXMPDateTimeString, CFSTR("DateCreated"), CFSTR("{IPTC}"));
          IIODictionary::setObjectForKeyGroup(a2, IPTCDateStringWithXMPDateTimeString, CFSTR("DigitalCreationDate"), CFSTR("{IPTC}"));
          IIODictionary::setObjectForKeyGroup(a2, IPTCTimeStringWithXMPDateTimeString, CFSTR("TimeCreated"), CFSTR("{IPTC}"));
          IIODictionary::setObjectForKeyGroup(a2, IPTCTimeStringWithXMPDateTimeString, CFSTR("DigitalCreationTime"), CFSTR("{IPTC}"));
        }
      }
    }
  }
}

uint64_t IIOImageDestination::addImageFromSource(IIOImageDestination *this, void *cf, unint64_t a3, IIODictionary *a4)
{
  IIOImageSource *Source;
  IIODictionary *v9;
  IIODictionary *PropertiesAtIndexInternal;
  IIODictionary *v11;
  const __CFDictionary **v12;
  uint64_t v13;
  void **v14;
  IIOImageDestination *v15;
  CGImage *v16;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v18;
  const __CFDictionary *ObjectForKeyGroup;
  IIO_ReaderHandler *Type;
  CFComparisonResult v22;
  CFComparisonResult v23;
  uint64_t v24;
  IIODictionary *v25;
  size_t v26;
  CGImageSource *isrc;
  unsigned int Uint32ForKey;
  CGImage *v29;

  v29 = 0;
  if (!*((_QWORD *)this + 2))
  {
    LogError("addImageFromSource", 3391, "*** ERROR: cannot add image from source - invalid image destination\n", a4);
    return 0;
  }
  if (!*((_QWORD *)this + 8))
  {
    LogError("addImageFromSource", 3392, "*** ERROR: image destination format unknown\n", a4);
    return 0;
  }
  if (!a4)
  {
    LogError("addImageFromSource", 3393, "*** ERROR: image properties are NULL\n", 0);
    return 0;
  }
  if (*((_BYTE *)this + 225))
  {
    LogError("addImageFromSource", 3394, "*** ERROR: image destination was already finalized\n", a4);
    return 0;
  }
  if (*((_BYTE *)this + 224))
  {
    LogError("addImageFromSource", 3395, "*** ERROR: CGImageDestinationAddImageFromSource call is not allowed for this image destination (destination was updated with CGImageDestinationCopyImageSource)\n");
    return 0;
  }
  *((_QWORD *)this + 20) = CFRetain(cf);
  Source = (IIOImageSource *)CGImageSourceGetSource((uint64_t)cf);
  if ((gIIODebugFlags & 0x2000000000000) != 0)
    IIODebugOrientation("addImageFromSource", 3400, a4);
  if (IIODictionary::containsKey(a4, CFSTR("kCGImageDestinationImageMaxPixelSize")))
    Uint32ForKey = IIODictionary::getUint32ForKey(a4, CFSTR("kCGImageDestinationImageMaxPixelSize"));
  else
    Uint32ForKey = 0;
  isrc = (CGImageSource *)cf;
  IIOImageDestination::updatePreserveGainMapFlag(this, Source, a4);
  if (*((_BYTE *)this + 218) == 1)
  {
    IIODictionary::removeObjectForKey(a4, CFSTR("kCGImageDestinationCreateHDRGainMap"));
    IIODictionary::removeObjectForKey(a4, CFSTR("kCGImageSourceDecodeRequest"));
  }
  IIOImageDestination::updateCreateHDRGainMapFlag(this, 0, a4);
  v9 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v9, *((const __CFDictionary **)a4 + 1), 1);
  IIODictionary::removeObjectForKey(v9, CFSTR("kCGImageDestinationImageMaxPixelSize"));
  IIODictionary::removeObjectForKey(v9, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways"));
  IIODictionary::removeObjectForKey(v9, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent"));
  IIODictionary::removeObjectForKey(v9, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
  IIODictionary::removeObjectForKey(v9, CFSTR("kCGImageSourceDecodeRequest"));
  IIODictionary::removeObjectForKey(v9, CFSTR("kCGImageSourceDecodeRequestOptions"));
  IIODictionary::removeObjectForKey(v9, CFSTR("kCGImageDestinationPreserveGainMap"));
  IIODictionary::removeObjectForKey(v9, CFSTR("kCGImageDestinationCreateHDRGainMap"));
  PropertiesAtIndexInternal = IIOImageSource::getPropertiesAtIndexInternal(Source, a3, (const __CFDictionary **)v9);
  if (PropertiesAtIndexInternal)
  {
    v11 = PropertiesAtIndexInternal;
    v12 = (const __CFDictionary **)operator new();
    IIODictionary::IIODictionary((IIODictionary *)v12, *((const __CFDictionary **)v11 + 1), 1);
  }
  else
  {
    v12 = 0;
  }
  if ((gIIODebugFlags & 0x2000000000000) != 0)
    IIODebugOrientation("addImageFromSource", 3436, (IIODictionary *)v12);
  (*(void (**)(IIODictionary *))(*(_QWORD *)v9 + 8))(v9);
  if (!v12)
  {
    LogError("addImageFromSource", 3441, "*** ERROR: image %ld properties of source is nil\n", v13);
    return 0;
  }
  v14 = (void **)operator new();
  IIODictionary::IIODictionary((IIODictionary *)v14, v12[1], 1);
  v26 = a3;
  v15 = (IIOImageDestination *)IIOImageDestination::createImageFromSource((CGImageSourceRef *)this, a3, a4, (IIODictionary *)v14, &v29);
  v16 = v29;
  if (v29)
  {
    IIOImageDestination::updateDateTime(v15, (IIODictionary *)v14, a4);
    CFDictionaryApplyFunction(*((CFDictionaryRef *)a4 + 1), (CFDictionaryApplierFunction)dictionaryApplier, v14[1]);
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v14, CFSTR("Orientation"));
    if (ObjectForKey)
    {
      v18 = ObjectForKey;
      ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v14, CFSTR("Orientation"), CFSTR("{TIFF}"));
      if (!ObjectForKeyGroup || !CFEqual(v18, ObjectForKeyGroup))
        IIODictionary::setObjectForKeyGroup((IIODictionary *)v14, v18, CFSTR("Orientation"), CFSTR("{TIFF}"));
    }
    if (!Uint32ForKey || *((_BYTE *)this + 219) == 1)
    {
      *((_QWORD *)this + 23) = Uint32ForKey;
      goto LABEL_27;
    }
    Type = (IIO_ReaderHandler *)CGImageSourceGetType(isrc);
    if (IIO_ReaderHandler::UseAppleJPEG(Type)
      && IIOImageSource::imageSourceCanBeUsedForJPEGResize((IIO_Reader **)Source, Uint32ForKey))
    {
      v22 = CFStringCompare(*((CFStringRef *)this + 9), CFSTR("public.jpeg"), 0);
      *((_BYTE *)this + 214) = v22 == kCFCompareEqualTo;
      if (v22 == kCFCompareEqualTo)
      {
        *((_QWORD *)this + 21) = 0;
        *((_QWORD *)this + 23) = Uint32ForKey;
        if (IIOImageSource::isRAWFile(Source))
        {
          *((_DWORD *)this + 52) = 5;
          goto LABEL_27;
        }
        *((_BYTE *)this + 212) = 1;
        *((_DWORD *)this + 52) = 1;
        goto LABEL_48;
      }
    }
    else
    {
      *((_BYTE *)this + 214) = 0;
    }
    if (!IIOImageSource::imageSourceCanBeUsedForHEICResize((IIO_Reader **)Source))
    {
      *((_BYTE *)this + 215) = 0;
      goto LABEL_27;
    }
    v23 = CFStringCompare(*((CFStringRef *)this + 9), CFSTR("public.jpeg"), 0);
    *((_BYTE *)this + 215) = v23 == kCFCompareEqualTo;
    if (v23)
    {
LABEL_27:
      if ((gIIODebugFlags & 0x2000000000000) != 0)
        IIODebugOrientation("addImageFromSource", 3535, (IIODictionary *)v14);
      IIOImageDestination::addImageInternal(this, v16, (IIODictionary *)v14, 0);
LABEL_30:
      if (*((_BYTE *)this + 218) == 1)
      {
        IIOImageDestination::swapWriterIfNeeded((IIO_Writer **)this, 0, 1);
        if (!*((_BYTE *)this + 213) || *((_DWORD *)this + 52) == 6)
        {
          IIOImageDestination::preserveGainMapFromSource(this, isrc, v26, CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), (IIODictionary *)v12, a4);
          IIOImageDestination::preserveGainMapFromSource(this, isrc, v26, CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"), (IIODictionary *)v12, a4);
        }
      }
      CFRelease(v16);
      goto LABEL_35;
    }
    *((_QWORD *)this + 21) = 0;
    *((_QWORD *)this + 23) = Uint32ForKey;
    *((_BYTE *)this + 213) = 1;
LABEL_48:
    if (IIODictionary::getBoolForKey(a4, CFSTR("kCGImageMetadataShouldExcludeGPS")))
      IIODictionary::removeObjectForKey(a4, CFSTR("{GPS}"));
    v24 = *((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v24 + 1;
    *((_QWORD *)this + 7) = v24;
    v25 = (IIODictionary *)IIODictionary::copy((CFTypeRef *)a4);
    IIOImageDestination::setImagePropertiesAtIndex(this, v25, *((_QWORD *)this + 7));
    *((_BYTE *)this + 226) = 1;
    goto LABEL_30;
  }
  LogError("addImageFromSource", 3465, "*** ERROR: image %ld of source is nil (err=%d)\n", v26, 0);
LABEL_35:
  (*((void (**)(void **))*v14 + 1))(v14);
  (*((void (**)(const __CFDictionary **))*v12 + 1))(v12);
  return 0;
}

void sub_187FFE5BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void dictionaryApplier(const void *key, const __CFDictionary *a2, CFMutableDictionaryRef theDict)
{
  void *Value;
  void *v7;
  CFTypeID v8;
  CFTypeID v9;

  if (theDict)
  {
    if ((const __CFDictionary *)*MEMORY[0x1E0C9B0D0] == a2)
    {
      CFDictionaryRemoveValue(theDict, key);
    }
    else
    {
      Value = (void *)CFDictionaryGetValue(theDict, key);
      if (Value
        && (v7 = Value, v8 = CFGetTypeID(Value), v8 == CFDictionaryGetTypeID())
        && (v9 = CFGetTypeID(a2), v9 == CFDictionaryGetTypeID()))
      {
        CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)dictionaryApplier, v7);
      }
      else
      {
        CFDictionarySetValue(theDict, key, a2);
      }
    }
  }
}

void IIOImageDestination::preserveGainMapFromSource(IIOImageDestination *this, CGImageSourceRef isrc, size_t index, CFStringRef auxiliaryImageDataType, IIODictionary *a5, IIODictionary *a6)
{
  CFDictionaryRef v10;
  const __CFDictionary *v11;
  unsigned int v12;
  const __CFData *v13;
  const __CFDictionary *v14;
  void *v15;
  unsigned int Uint32ForKey;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  _BOOL4 v24;
  int v25;
  int v26;
  const UInt8 *BytePtr;
  UInt8 *v28;
  void *v29;
  vImagePixelCount v30;
  vImagePixelCount v31;
  unsigned int v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  double v44;
  vImage_Error v45;
  vImagePixelCount v46;
  vImagePixelCount v47;
  unsigned int v48;
  void *v49;
  uint8_t v50;
  uint64_t v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  CFDataRef v61;
  IIODictionary *v62;
  void *v63;
  void *value;
  IIOImageDestination *v65;
  const __CFString *v66;
  __CFDictionary *v67;
  unsigned int v68;
  unsigned int v69;
  uint64_t v70;
  const __CFDictionary *cf;
  _BYTE v72[24];
  _BYTE v73[24];
  _BYTE v74[24];
  _BYTE v75[24];
  vImage_Buffer v76;
  vImage_Buffer dest;
  vImage_Buffer src;
  _QWORD v79[4];

  v10 = CGImageSourceCopyAuxiliaryDataInfoAtIndex(isrc, index, auxiliaryImageDataType);
  if (v10)
  {
    v11 = v10;
    v65 = this;
    v66 = auxiliaryImageDataType;
    if (CFStringCompare(auxiliaryImageDataType, CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), 0))
      v12 = 1179408416;
    else
      v12 = 1294674720;
    kdebug_trace();
    v13 = (const __CFData *)CFDictionaryGetValue(v11, CFSTR("kCGImageAuxiliaryDataInfoData"));
    v14 = (const __CFDictionary *)CFDictionaryGetValue(v11, CFSTR("kCGImageAuxiliaryDataInfoDataDescription"));
    cf = v11;
    v15 = (void *)CFDictionaryGetValue(v11, CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
    memset(v79, 0, 24);
    v67 = v14;
    IIODictionary::IIODictionary((IIODictionary *)v79, v14);
    Uint32ForKey = IIODictionary::getUint32ForKey(a5, CFSTR("PixelWidth"));
    v17 = IIODictionary::getUint32ForKey(a5, CFSTR("PixelHeight"));
    v68 = IIODictionary::getUint32ForKey(a5, CFSTR("Orientation"));
    v18 = IIODictionary::getUint32ForKey((IIODictionary *)v79, CFSTR("Width"));
    v19 = IIODictionary::getUint32ForKey((IIODictionary *)v79, CFSTR("Height"));
    value = v15;
    v20 = IIODictionary::getUint32ForKey((IIODictionary *)v79, CFSTR("BytesPerRow"));
    if (Uint32ForKey <= v17)
      v21 = v17;
    else
      v21 = Uint32ForKey;
    if (a6)
    {
      v22 = IIODictionary::containsKey(a6, CFSTR("kCGImageDestinationImageMaxPixelSize"));
      v23 = v21;
      if (v22)
        v23 = IIODictionary::getUint32ForKey(a6, CFSTR("kCGImageDestinationImageMaxPixelSize"));
      v24 = v23 == v21;
      if (v68 == 1)
        v69 = 0;
      else
        v69 = IIODictionary::containsKey(a6, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
    }
    else
    {
      v69 = 0;
      v24 = 1;
    }
    v25 = IIODictionary::getUint32ForKey((IIODictionary *)v79, CFSTR("PixelFormat"));
    v26 = v25;
    if (v25 == 1278226488)
    {
      BytePtr = CFDataGetBytePtr(v13);
      v28 = (UInt8 *)BytePtr;
      if (v24)
      {
        v29 = 0;
        LODWORD(v30) = v18;
        LODWORD(v31) = v19;
        v32 = v20;
        v33 = (void *)BytePtr;
      }
      else
      {
        v43 = IIODictionary::getUint32ForKey(a6, CFSTR("kCGImageDestinationImageMaxPixelSize"));
        v44 = (double)v43 / (double)v17;
        if ((double)v43 / (double)Uint32ForKey < v44)
          v44 = (double)v43 / (double)Uint32ForKey;
        v30 = (v44 * (double)Uint32ForKey) >> 1;
        v31 = (v44 * (double)v17) >> 1;
        v32 = (v30 + 15) & 0xFFFFFFF0;
        v33 = malloc_type_malloc(v32 * v31, 0xDD64A15DuLL);
        src.data = v28;
        src.height = v19;
        src.width = v18;
        src.rowBytes = v20;
        dest.data = v33;
        dest.height = v31;
        dest.width = v30;
        dest.rowBytes = v32;
        v45 = vImageScale_Planar8(&src, &dest, 0, 0x20u);
        if (v45)
          _cg_jpeg_mem_term("preserveGainMapFromSource", 3667, "*** ERROR: vImageScale_Planar8 failed: %ld\n", v45);
        v29 = v33;
      }
      if (v69)
      {
        v63 = v29;
        if (v68 <= 4)
          v46 = v30;
        else
          v46 = v31;
        if (v68 <= 4)
          v47 = v31;
        else
          v47 = v30;
        v48 = (v46 + 15) & 0xFFFFFFF0;
        v49 = malloc_type_malloc(v48 * v47, 0x178181A2uLL);
        src.data = v33;
        src.height = v31;
        src.width = v30;
        src.rowBytes = v32;
        dest.data = v49;
        dest.height = v47;
        dest.width = v46;
        dest.rowBytes = v48;
        v50 = 2;
        switch(v68)
        {
          case 2u:
            vImageHorizontalReflect_Planar8(&src, &dest, 0x10u);
            v33 = v49;
            break;
          case 3u:
            goto LABEL_76;
          case 4u:
            vImageVerticalReflect_Planar8(&src, &dest, 0x10u);
            v33 = v49;
            break;
          case 5u:
            v60 = malloc_type_malloc(v48 * v47, 0x3751B7F9uLL);
            v76.data = v60;
            v76.height = v47;
            v76.width = v46;
            v76.rowBytes = ((_DWORD)v46 + 15) & 0xFFFFFFF0;
            vImageRotate90_Planar8(&src, &v76, 3u, 0, 0x10u);
            vImageHorizontalReflect_Planar8(&v76, &dest, 0x10u);
            goto LABEL_74;
          case 6u:
            v50 = 3;
            goto LABEL_76;
          case 7u:
            v60 = malloc_type_malloc(v48 * v47, 0x823C74EDuLL);
            v76.data = v60;
            v76.height = v47;
            v76.width = v46;
            v76.rowBytes = ((_DWORD)v46 + 15) & 0xFFFFFFF0;
            vImageRotate90_Planar8(&src, &v76, 1u, 0, 0x10u);
            vImageHorizontalReflect_Planar8(&v76, &dest, 0x10u);
LABEL_74:
            free(v60);
            v33 = v49;
            break;
          case 8u:
            v50 = 1;
LABEL_76:
            vImageRotate90_Planar8(&src, &dest, v50, 0, 0x10u);
            v33 = v49;
            break;
          default:
            break;
        }
        LODWORD(v30) = v46;
        LODWORD(v31) = v47;
        v32 = (v46 + 15) & 0xFFFFFFF0;
        v29 = v63;
      }
      else
      {
        v49 = 0;
      }
      memset(&src, 0, 24);
      IIODictionary::IIODictionary((IIODictionary *)&src, v67);
      if ((!v24 | v69) == 1)
      {
        IIONumber::IIONumber((IIONumber *)v75, v30);
        IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v75, CFSTR("Width"));
        IIONumber::~IIONumber((IIONumber *)v75);
        IIONumber::IIONumber((IIONumber *)v74, v31);
        IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v74, CFSTR("Height"));
        IIONumber::~IIONumber((IIONumber *)v74);
        IIONumber::IIONumber((IIONumber *)v73, v32);
        IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v73, CFSTR("BytesPerRow"));
        IIONumber::~IIONumber((IIONumber *)v73);
        IIONumber::IIONumber((IIONumber *)v72, 1278226488);
        IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v72, CFSTR("PixelFormat"));
        IIONumber::~IIONumber((IIONumber *)v72);
      }
      v61 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v33, v32 * v31);
      if (v61)
      {
        memset(&dest, 0, 24);
        IIODictionary::IIODictionary((IIODictionary *)&dest);
        IIODictionary::setObjectForKey(v62, (const void *)src.height, CFSTR("kCGImageAuxiliaryDataInfoDataDescription"));
        IIODictionary::setObjectForKey((IIODictionary *)&dest, value, CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
        IIODictionary::setObjectForKey((IIODictionary *)&dest, v61, CFSTR("kCGImageAuxiliaryDataInfoData"));
        IIOImageDestination::addAuxiliaryDataInfo(v65, v66, (const void **)&dest.data);
        CFRelease(v61);
        IIODictionary::~IIODictionary((IIODictionary *)&dest);
      }
      if (v29)
        free(v29);
      if (v49)
        free(v49);
      IIODictionary::~IIODictionary((IIODictionary *)&src);
    }
    else
    {
      v34 = MEMORY[0x1E0C80978];
      v35 = MEMORY[0x1E0C80978] + 60;
      if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * HIBYTE(v12)) & 0x40000) != 0)
        v36 = HIBYTE(v12);
      else
        v36 = 46;
      LODWORD(v37) = HIWORD(v12) & 0x6F;
      if ((*(_DWORD *)(v35 + 4 * v37) & 0x40000) != 0)
        v37 = v37;
      else
        v37 = 46;
      v70 = v37;
      v38 = (v12 >> 8) & 0x7B;
      if ((*(_DWORD *)(v35 + 4 * v38) & 0x40000) != 0)
        v39 = v38;
      else
        v39 = 46;
      if ((*(_BYTE *)(MEMORY[0x1E0C80978] + 190) & 4) != 0)
        v40 = 32;
      else
        v40 = 46;
      v41 = v25 >> 24;
      if (v25 < 0)
        v42 = __maskrune(v25 >> 24, 0x40000uLL);
      else
        v42 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v41 + 60) & 0x40000;
      if (v42)
        v51 = v41;
      else
        v51 = 46;
      v52 = v26 << 8 >> 24;
      if (v26 << 8 < 0)
        v53 = __maskrune(v26 << 8 >> 24, 0x40000uLL);
      else
        v53 = *(_DWORD *)(v34 + 4 * v52 + 60) & 0x40000;
      if (v53)
        v54 = v52;
      else
        v54 = 46;
      v55 = (__int16)v26 >> 8;
      if (v26 << 16 < 0)
        v56 = __maskrune((__int16)v26 >> 8, 0x40000uLL);
      else
        v56 = *(_DWORD *)(v34 + 4 * v55 + 60) & 0x40000;
      if ((v26 << 24) <= 0x7F000000)
        v57 = *(_DWORD *)(v34 + 4 * (char)v26 + 60) & 0x40000;
      else
        v57 = __maskrune((char)v26, 0x40000uLL);
      if (v56)
        v58 = v55;
      else
        v58 = 46;
      if (v57)
        v59 = (char)v26;
      else
        v59 = 46;
      _cg_jpeg_mem_term("preserveGainMapFromSource", 3768, "*** ERROR: preserveGainMapFromSource for '%c%c%c%c' - unhandled pixelformat: '%c%c%c%c'\n", v36, v70, v39, v40, v51, v54, v58, v59);
    }
    CFRelease(cf);
    IIODictionary::~IIODictionary((IIODictionary *)v79);
  }
}

void sub_187FFEE70(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 112));
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::addImageAndMetadata(IIOImageDestination *this, CGImage *a2, const CGImageMetadata *a3, IIODictionary *a4)
{
  IIODictionary *v8;
  IIODictionary *v9;
  CGMutableImageMetadataRef MutableCopy;
  const __CFDictionary **v11;
  const __CFDictionary **v12;
  const __CFDictionary **v13;

  if (!*((_QWORD *)this + 2))
  {
    LogError("addImageAndMetadata", 3783, "*** ERROR: cannot add image and metadata - invalid image destination\n", a4);
    return 4294967246;
  }
  if (*((_BYTE *)this + 225))
  {
    LogError("addImageAndMetadata", 3784, "*** ERROR: image destination was already finalized\n", a4);
    return 4294967246;
  }
  if (*((_BYTE *)this + 224))
  {
    LogError("addImageAndMetadata", 3785, "*** ERROR: CGImageDestinationAddImageAndMetadata call is not allowed for this image destination (destination was updated with CGImageDestinationCopyImageSource)\n", a4);
    return 4294967246;
  }
  v8 = (IIODictionary *)operator new();
  v9 = v8;
  if (a4)
    IIODictionary::IIODictionary(v8, *((const __CFDictionary **)a4 + 1), 1);
  else
    IIODictionary::IIODictionary(v8);
  if (a3)
  {
    MutableCopy = CGImageMetadataCreateMutableCopy(a3);
    if (MutableCopy)
    {
      v11 = (const __CFDictionary **)MutableCopy;
      if (IIODictionary::getBoolForKey(a4, CFSTR("kCGImageMetadataShouldExcludeGPS")))
        CGImageMetadataRemoveGPS((uint64_t)v11);
      v12 = (const __CFDictionary **)CGImagePropertiesCreateFromMetadata(v11);
      if (v12)
      {
        v13 = v12;
        IIODictionary::appendDictionary(v9, v12);
        (*((void (**)(const __CFDictionary **))*v13 + 1))(v13);
      }
      IIODictionary::setObjectForKey(v9, v11, CFSTR("{MetaData}"));
      CFRelease(v11);
    }
  }
  IIOImageDestination::addImageInternal(this, a2, v9, 0);
  (*(void (**)(IIODictionary *))(*(_QWORD *)v9 + 8))(v9);
  return 0;
}

void sub_187FFF0A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::finalizeUsingPixelProvider(IIOImageDestination *this)
{
  CGImageSource *v2;
  IIOImageDestination *ImagePropertiesAtIndex;
  BOOL *v4;
  IIODictionary *v5;
  int OptimizeForSharing;
  _BOOL4 BoolForKey;
  const char *v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;
  const char *v12;
  int v13;
  CGImage *v14;
  CGImageRef *v15;
  unint64_t v16;
  CGImage *v17;
  __CFDictionary *ObjectForKey;
  CGImage *ThumbNew;
  uint64_t v20;
  const void *PixelDataProviderConforming;
  const void *v22;

  *((_BYTE *)this + 216) = 0;
  IIOImageWriteSession::seek(*((IIOImageWriteSession **)this + 3), 0, 0);
  v2 = (CGImageSource *)*((_QWORD *)this + 20);
  if (v2)
    *((_QWORD *)this + 21) = CGImageSourceCreateImageAtIndex(v2, 0, 0);
  ImagePropertiesAtIndex = (IIOImageDestination *)IIOImageDestination::getImagePropertiesAtIndex(this, 0);
  if (!ImagePropertiesAtIndex)
  {
    v13 = 0;
    v15 = (CGImageRef *)((char *)this + 168);
    v14 = (CGImage *)*((_QWORD *)this + 21);
    v16 = *((_QWORD *)this + 23);
    goto LABEL_26;
  }
  v5 = ImagePropertiesAtIndex;
  OptimizeForSharing = IIOImageDestination::GetOptimizeForSharing(ImagePropertiesAtIndex, 0, v4);
  BoolForKey = IIODictionary::getBoolForKey(v5, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v8 = "off";
    if (OptimizeForSharing)
      v8 = "on";
    ImageIOLog("COL finalizing image [%p] with optimizeColorForSharing turned %s\n", *((const void **)this + 21), v8);
  }
  if (BoolForKey)
  {
    v9 = IIOGetExifOrientation(v5, 0);
    v10 = v9 > 1;
    if (v9 <= 1)
      v11 = 1;
    else
      v11 = v9;
    if ((gIIODebugFlags & 0x2000000000000) != 0)
    {
      v12 = "NO";
      if (v9 > 1)
        v12 = "YES";
      ImageIOLog("%s finalize: bakeInOrientation-%s:  %d\n", "-o- ", v12, v11);
      if ((gIIODebugFlags & 0x2000000000000) != 0)
      {
        IIODebugOrientation("finalizeUsingPixelProvider", 3861, v5);
        if ((OptimizeForSharing & 1) == 0)
          goto LABEL_17;
        goto LABEL_22;
      }
    }
  }
  else
  {
    v10 = 0;
    v11 = 1;
  }
  if (OptimizeForSharing)
  {
LABEL_22:
    v15 = (CGImageRef *)((char *)this + 168);
    v14 = (CGImage *)*((_QWORD *)this + 21);
    v16 = *((_QWORD *)this + 23);
    v13 = 2;
    if (v10)
      goto LABEL_23;
LABEL_26:
    ThumbNew = CGImageCreateThumbNew(v14, v16, 0, -1, v13);
    if (!ThumbNew)
      ThumbNew = CGImageRetain(*v15);
    v17 = ThumbNew;
    goto LABEL_29;
  }
LABEL_17:
  v13 = 0;
  v15 = (CGImageRef *)((char *)this + 168);
  v14 = (CGImage *)*((_QWORD *)this + 21);
  v16 = *((_QWORD *)this + 23);
  if (!v10)
    goto LABEL_26;
LABEL_23:
  v17 = CGImageCreateThumbNew(v14, v16, v11, -1, v13);
  if (v17)
  {
    IIODictionary::removeObjectForKey(v5, CFSTR("Orientation"));
    ObjectForKey = IIODictionary::getObjectForKey(v5, CFSTR("{TIFF}"));
    if (ObjectForKey)
      CFDictionaryRemoveValue(ObjectForKey, CFSTR("Orientation"));
  }
LABEL_29:
  v20 = HEIFAuxImage::auxiliaryPixelFormat(*((HEIFAuxImage **)this + 8));
  PixelDataProviderConforming = (const void *)IIOImageDestination::createPixelDataProviderConforming((uint64_t)this, v17, 1, 0, 0, v20, 0);
  if (PixelDataProviderConforming)
  {
    v22 = PixelDataProviderConforming;
    IIOImageDestination::setPixelProviderAtIndex((uint64_t)this, PixelDataProviderConforming, 0);
    CFRelease(v22);
  }
  else
  {
    _cg_jpeg_mem_term("finalizeUsingPixelProvider", 3890, "*** createPixelDataProviderConforming failed (nil)\n");
  }
  CGImageRelease(v17);
  if (*v15)
  {
    CGImageRelease(*v15);
    *v15 = 0;
  }
  return 0;
}

uint64_t IIOImageDestination::finalizeUsingAppleJPEGRecode(IIOImageDestination *this)
{
  IIOImageDestination *Source;
  double Current;
  IIOImageSource *v4;
  _BOOL4 v5;
  CFAbsoluteTime v6;
  uint64_t v7;

  Source = (IIOImageDestination *)CGImageSourceGetSource(*((_QWORD *)this + 20));
  if ((gIIODebugFlags & 0xC) != 0)
    Current = CFAbsoluteTimeGetCurrent();
  else
    Current = 0.0;
  kdebug_trace();
  v5 = AppleJPEGReadPlugin::IIORecodeAppleJPEG_to_JPEG(this, Source, v4);
  kdebug_trace();
  if (v5)
  {
    if ((gIIODebugFlags & 0xC) != 0)
    {
      v6 = CFAbsoluteTimeGetCurrent();
      ImageIOLog("    'jpeg' RecodeAppleJPEG  \ttime: %g ms\n", (v6 - Current) * 1000.0);
    }
    return 0;
  }
  else
  {
    v7 = 4294967246;
    LogWarning("finalizeUsingAppleJPEGRecode", 3938, "*** NOTE: CGImageDestinationRecodeJPEG failed [%d] - falling back to full transcode\n", -50);
  }
  return v7;
}

uint64_t IIOImageDestination::finalizeUsingHEIFRecode(IIOImageDestination *this)
{
  IIOImageDestination *Source;
  uint64_t v3;

  Source = (IIOImageDestination *)CGImageSourceGetSource(*((_QWORD *)this + 20));
  kdebug_trace();
  v3 = HEIFReadPlugin::IIORecodeHEIF_to_JPEG(this, Source, (IIOImageSource *)*((unsigned int *)this + 49));
  kdebug_trace();
  if ((_DWORD)v3)
  {
    if ((_DWORD)v3 == -15470)
      LogError("finalizeUsingHEIFRecode", 3965, "*** ERROR: media server is NOT running [kCMPhotoError_XPCError / -15470]\n");
    else
      _cg_jpeg_mem_term("finalizeUsingHEIFRecode", 3973, "*** NOTE: CMPhotoDecompressionContainerJFIFTranscode failed [0x%08X] - falling back to full transcode\n", v3);
  }
  return v3;
}

uint64_t IIOImageDestination::finalizeDestination(IIOImageDestination *this, CFIndex *a2)
{
  double Current;
  uint64_t v5;
  const void *v6;
  CFIndex Length;
  const __CFData *v8;
  const __CFData *v9;
  int v10;
  char v11;
  const __CFArray *v12;
  int v13;
  int v14;
  const __CFArray *v15;
  unint64_t Count;
  int v17;
  const __CFArray *v18;
  unint64_t v19;
  const void *v20;
  const void *v21;
  const char *v22;
  const char *v23;
  __CFData *v24;
  CFAbsoluteTime v25;
  const void *v27;
  const char *v28;
  char buffer[16];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  if (!*((_QWORD *)this + 2))
  {
    LogError("finalizeDestination", 3991, "*** ERROR: cannot finalize - invalid image destination\n");
LABEL_77:
    v5 = 4294967246;
    goto LABEL_64;
  }
  if (*((_BYTE *)this + 225))
  {
    LogError("finalizeDestination", 3992, "*** ERROR: image destination was already finalized\n");
    goto LABEL_77;
  }
  if (*((_BYTE *)this + 224))
  {
    LogError("finalizeDestination", 3993, "*** ERROR: CGImageDestinationFinalize call is not allowed for this image destination (destination was updated with CGImageDestinationCopyImageSource)\n");
    goto LABEL_77;
  }
  if (*((_DWORD *)this + 51))
  {
    LogError("finalizeDestination", 3994, "*** ERROR: CGImageDestinationFinalize was called, but there were no images added [%d]\n");
    goto LABEL_77;
  }
  if (*((_QWORD *)this + 14) == *((_QWORD *)this + 13) && !*((_QWORD *)this + 20) && !*((_QWORD *)this + 21))
  {
    LogError("finalizeDestination", 3995, "*** ERROR: CGImageDestinationFinalize was called, but there were no images added\n");
    goto LABEL_77;
  }
  *((_BYTE *)this + 225) = 1;
  if (*((_BYTE *)this + 222))
  {
    if (*((_BYTE *)this + 223))
      v5 = 0;
    else
      v5 = 4294967246;
    goto LABEL_12;
  }
  v10 = *((unsigned __int8 *)this + 212);
  if (*((_BYTE *)this + 212))
  {
    if (*((_QWORD *)this + 20))
      v10 = 1;
    else
      v10 = *((_QWORD *)this + 21) != 0;
  }
  *((_BYTE *)this + 216) = v10;
  v11 = *((_BYTE *)this + 213);
  if (v11)
  {
    if (*((_QWORD *)this + 20))
      v11 = 1;
    else
      v11 = *((_QWORD *)this + 21) != 0;
  }
  *((_BYTE *)this + 217) = v11;
  v12 = (const __CFArray *)*((_QWORD *)this + 19);
  if (v12)
  {
    if (CFArrayGetCount(v12))
    {
      v13 = 0;
      *((_WORD *)this + 108) = 0;
      goto LABEL_43;
    }
    v10 = *((unsigned __int8 *)this + 216);
  }
  if (v10)
    v14 = IIOImageDestination::finalizeUsingAppleJPEGRecode(this);
  else
    v14 = 0;
  if (*((_BYTE *)this + 217))
    v14 = IIOImageDestination::finalizeUsingHEIFRecode(this);
  if (v14)
  {
    v13 = 1;
  }
  else
  {
    if (*((_BYTE *)this + 216))
    {
      v5 = 0;
      goto LABEL_12;
    }
    v5 = 0;
    if (*((_BYTE *)this + 217))
      goto LABEL_12;
    v13 = 0;
  }
LABEL_43:
  v15 = (const __CFArray *)*((_QWORD *)this + 12);
  if (!v15 || ((Count = CFArrayGetCount(v15)) == 0 ? (v17 = 1) : (v17 = v13), v17 == 1))
  {
    IIOImageDestination::finalizeUsingPixelProvider(this);
    v18 = (const __CFArray *)*((_QWORD *)this + 12);
    if (!v18 || (Count = CFArrayGetCount(v18)) == 0)
    {
      LogError("finalizeDestination", 4045, "*** ERROR: image destination must have at least one image\n");
      v5 = 4294967228;
LABEL_64:
      if (IIOImageSource::count(*((IIOImageSource **)this + 3)))
      {
        v24 = (__CFData *)IIOImageSource::count(*((IIOImageSource **)this + 3));
        CFDataSetLength(v24, 0);
      }
      if ((gIIODebugFlags & 0x3000) != 0)
      {
        v31 = 0u;
        v32 = 0u;
        *(_OWORD *)buffer = 0u;
        v30 = 0u;
        CFStringGetCString(*((CFStringRef *)this + 9), buffer, 64, 0x8000100u);
        ImageIOLog("*** %s - failed - '%s' (err: %d)\n", "finalizeDestination", buffer, v5);
      }
      goto LABEL_68;
    }
  }
  v19 = *((_QWORD *)this + 5);
  if (v19)
  {
    if (Count > v19)
    {
      LogError("finalizeDestination", 4052, "*** ERROR: image destination does not have enough images (%d/%d)\n", Count, v19);
LABEL_80:
      v5 = 0;
      goto LABEL_68;
    }
  }
  else if (IIO_Reader::testHeaderSize(*((IIO_Reader **)this + 8)) != -1
         && IIO_Reader::testHeaderSize(*((IIO_Reader **)this + 8)) < Count)
  {
    v27 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
    IIOString::IIOString((IIOString *)buffer, v27);
    v28 = (const char *)IIOString::utf8String((IIOString *)buffer);
    LogError("finalizeDestination", 4049, "*** ERROR: image destination count %d is too large for format '%s'\n", Count, v28);
    IIOString::~IIOString((IIOString *)buffer);
    goto LABEL_80;
  }
  v20 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
  IIODebugCallbackPriv(v20, "write");
  IIO_Reader::osType(*((IIO_Reader **)this + 8));
  kdebug_trace();
  v5 = (***((uint64_t (****)(_QWORD, _QWORD, IIOImageDestination *))this + 8))(*((_QWORD *)this + 8), *((_QWORD *)this + 3), this);
  IIO_Reader::osType(*((IIO_Reader **)this + 8));
  kdebug_trace();
  if ((_DWORD)v5)
  {
    v21 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
    IIOString::IIOString((IIOString *)buffer, v21);
    v22 = (const char *)IIOString::utf8String((IIOString *)buffer);
    _cg_jpeg_mem_term("finalizeDestination", 4065, "*** ERROR: '%s' - write failed (err: %d)\n", v22, v5);
    IIOString::~IIOString((IIOString *)buffer);
  }
  if (v13)
  {
    v23 = "with error";
    if (!(_DWORD)v5)
      v23 = "OK";
    _cg_jpeg_mem_term("finalizeDestination", 4069, "*** NOTE: full transcode fallback completed: %s\n", v23);
  }
LABEL_12:
  v6 = (const void *)*((_QWORD *)this + 12);
  if (v6)
  {
    CFRelease(v6);
    *((_QWORD *)this + 12) = 0;
  }
  if ((_DWORD)v5)
    goto LABEL_64;
  v5 = CGImageWriteSessionFinalize(*((_QWORD *)this + 2), 0);
  if (a2)
  {
    Length = IIOImageSource::count(*((IIOImageSource **)this + 3));
    if (Length)
    {
      v8 = (const __CFData *)IIOImageSource::count(*((IIOImageSource **)this + 3));
      Length = CFDataGetLength(v8);
    }
    *a2 = Length;
  }
  if ((gIIODebugFlags & 0x10000000) != 0 && IIOImageSource::count(*((IIOImageSource **)this + 3)))
  {
    v9 = (const __CFData *)IIOImageSource::count(*((IIOImageSource **)this + 3));
    ImageIO_saveImageData("finalOut", v9);
  }
  if ((_DWORD)v5)
    goto LABEL_64;
LABEL_68:
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    v25 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    IIOImageDestination::finalize - %g ms\n", (v25 - Current) * 1000.0);
  }
  return v5;
}

void sub_187FFFA80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CGColorSpaceRef IIOImageDestination::getResizeSourceColorSpace(IIOImageDestination *this)
{
  CGImage *v2;
  IIOImageSource *Source;
  IIOImagePlus *ImagePlus;

  v2 = (CGImage *)*((_QWORD *)this + 21);
  if (v2)
    return CGImageGetColorSpace(v2);
  Source = (IIOImageSource *)CGImageSourceGetSource(*((_QWORD *)this + 20));
  if (Source && (ImagePlus = (IIOImagePlus *)IIOImageSource::getImagePlus(Source, 0)) != 0)
    return (CGColorSpaceRef)IIOImagePlus::getSourceGeomColorSpace(ImagePlus);
  else
    return 0;
}

uint64_t IIOImageDestination::getSourceImageAtIndex(IIOImageDestination *this, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  v2 = *((_QWORD *)this + 13);
  v3 = (*((_QWORD *)this + 14) - v2) >> 3;
  if (v3 > a2)
    return *(_QWORD *)(v2 + 8 * a2);
  _cg_jpeg_mem_term("getSourceImageAtIndex", 4200, "getSourceImageAtIndex index (%d) larger than vector size (%d)\n", a2, v3);
  return 0;
}

CFTypeID CGImageDestinationGetTypeID(void)
{
  if (CGImageDestinationGetTypeID::once != -1)
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_24);
  return CGImageDestinationGetTypeID::id;
}

CFStringRef _CGImageDestinationCopyDescription(_QWORD *a1)
{
  uint64_t v2;
  IIO_Writer *v3;
  uint64_t v4;

  if (a1)
  {
    v2 = a1[3];
    if (v2)
    {
      v3 = *(IIO_Writer **)(v2 + 64);
      if (v3)
      {
        v4 = IIO_Writer::utType(v3);
        if (v4)
          return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CGImageDestination: %p> %p '%@'"), a1, v2, v4);
      }
    }
  }
  else
  {
    v2 = 0;
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CGImageDestination: %p> %p"), a1, v2);
}

CFMutableArrayRef CGImageDestinationCopyImageFormats(const __CFString *a1)
{
  IIO_WriterHandler *v2;
  IIO_WriterHandler *WriterHandler;
  CFMutableArrayRef v4;

  kdebug_trace();
  IIOInitDebugFlags();
  v2 = (IIO_WriterHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((int)v2, "S", "CGImageDestinationCopyImageFormats", 0, 0, -1, 0);
  WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v2);
  v4 = IIO_WriterHandler::copyImageFormats(WriterHandler, a1);
  kdebug_trace();
  return v4;
}

CGImageDestinationRef CGImageDestinationCreateWithDataConsumer(CGDataConsumerRef consumer, CFStringRef type, size_t count, CFDictionaryRef options)
{
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  unsigned int v11;
  IIO_WriterHandler *v12;
  IIO_WriterHandler *WriterHandler;
  IIODictionary *v14;
  IIO_Reader *WriterForType;
  uint64_t v16;
  const __CFString *v17;
  CGImageDestination *v18;
  IIO_Reader *v20;
  char buffer[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  IIOInitDebugFlags();
  if (!consumer)
  {
    LogError("CGImageDestinationCreateWithDataConsumer", 4818, "*** ERROR: CGImageDestinationCreateWithDataConsumer: dataConsumer is nil\n");
    goto LABEL_17;
  }
  if (!type)
  {
    LogError("CGImageDestinationCreateWithDataConsumer", 4819, "*** ERROR: CGImageDestinationCreateWithDataConsumer: type is nil\n");
    goto LABEL_17;
  }
  if (!count)
    LogError("CGImageDestinationCreateWithDataConsumer", 4821, "*** ERROR: CGImageDestinationCreateWithDataConsumer: invalid capacity (%zu)\n", 0);
  v8 = CFGetTypeID(consumer);
  if (v8 != CGDataConsumerGetTypeID())
  {
    LogError("CGImageDestinationCreateWithDataConsumer", 4822, "*** ERROR: CGImageDestinationCreateWithDataConsumer: dataConsumer is not a CGDataConsumerRef\n");
    goto LABEL_17;
  }
  v9 = CFGetTypeID(type);
  if (v9 != CFStringGetTypeID())
  {
    LogError("CGImageDestinationCreateWithDataConsumer", 4823, "*** ERROR: CGImageDestinationCreateWithDataConsumer: type is not a CFStringRef\n");
    goto LABEL_17;
  }
  if (options)
  {
    v10 = CFGetTypeID(options);
    if (v10 != CFDictionaryGetTypeID())
    {
      LogError("CGImageDestinationCreateWithDataConsumer", 4826, "*** ERROR: CGImageDestinationCreateWithDataConsumer: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    v23 = 0u;
    v24 = 0u;
    *(_OWORD *)buffer = 0u;
    v22 = 0u;
    CFStringGetCString(type, buffer, 64, 0x600u);
    v11 = (gIIODebugFlags >> 12) & 3;
    if (v11)
      ImageIODebugOptions(v11, "A", "CGImageDestinationCreateWithDataConsumer", 0, buffer, -1, options);
  }
  memset(buffer, 0, sizeof(buffer));
  *(_QWORD *)&v22 = 0;
  v12 = IIODictionary::IIODictionary((IIODictionary *)buffer, options);
  WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v12);
  WriterForType = IIO_WriterHandler::findWriterForType(WriterHandler, type, (const __CFString *)count, (IIODictionary *)buffer, v14);
  if (!WriterForType)
    goto LABEL_16;
  v16 = operator new();
  IIOImageDestination::IIOImageDestination((IIOImageDestination *)v16, consumer, WriterForType, v17, count, (const __CFDictionary **)buffer);
  if (*(_DWORD *)(v16 + 228))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
LABEL_16:
    IIODictionary::~IIODictionary((IIODictionary *)buffer);
    LogError("CGImageDestinationCreateWithDataConsumer", 4842, "*** ERROR: CGImageDestinationCreateWithDataConsumer: failed to create 'CGImageDestinationRef'\n");
    goto LABEL_17;
  }
  IIODictionary::~IIODictionary((IIODictionary *)buffer);
  v18 = (CGImageDestination *)CGImageDestinationRefCreateWith_ImageDestination((IIOImageDestination *)v16);
  v20 = *(IIO_Reader **)(v16 + 64);
  if (v20)
  {
    IIO_Reader::osType(v20);
    if (v18)
      goto LABEL_20;
  }
  else if (v18)
  {
    goto LABEL_20;
  }
  LogError("CGImageDestinationCreateWithDataConsumer", 4839, "*** ERROR: CGImageDestinationCreateWithDataConsumer: failed to create 'CGImageDestinationRef' object\n");
LABEL_17:
  if ((gIIODebugFlags & 0x800000000000) != 0)
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageDestinationCreateWithDataConsumer", 4845, "could not create CGImageDestinationRef");
  kdebug_trace();
  v18 = 0;
LABEL_20:
  kdebug_trace();
  return v18;
}

void sub_188000000(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  va_list va;

  va_start(va, a5);
  MEMORY[0x18D761C30](v5, 0x10E1C40255C1624);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationSetProperties(CGImageDestinationRef idst, CFDictionaryRef properties)
{
  unsigned int v4;
  CFTypeID v5;
  CFTypeID v6;
  IIOImageDestination *v7;
  IIO_Reader *v8;
  const __CFDictionary *v9[3];

  kdebug_trace();
  v4 = (gIIODebugFlags >> 12) & 3;
  if (v4)
    ImageIODebugOptions(v4, "A", "CGImageDestinationSetProperties", idst, 0, -1, properties);
  if (idst)
  {
    v5 = CFGetTypeID(idst);
    if (CGImageDestinationGetTypeID::once != -1)
      dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_24);
    if (v5 == CGImageDestinationGetTypeID::id)
    {
      if (properties)
      {
        v6 = CFGetTypeID(properties);
        if (v6 != CFDictionaryGetTypeID())
        {
          LogError("CGImageDestinationSetProperties", 4969, "*** ERROR: CGImageDestinationSetProperties: properties parameter is not a CFDictionaryRef - ignoring\n");
          properties = 0;
        }
      }
      v7 = (IIOImageDestination *)*((_QWORD *)idst + 3);
      if (v7)
      {
        memset(v9, 0, sizeof(v9));
        IIODictionary::IIODictionary((IIODictionary *)v9, properties);
        IIOImageDestination::setProperties(v7, v9);
        v8 = (IIO_Reader *)*((_QWORD *)v7 + 8);
        if (v8)
          IIO_Reader::osType(v8);
        IIODictionary::~IIODictionary((IIODictionary *)v9);
      }
    }
    else
    {
      LogError("CGImageDestinationSetProperties", 4966, "*** ERROR: CGImageDestinationSetProperties: type is not a CGImageDestinationRef\n");
    }
  }
  else
  {
    LogError("CGImageDestinationSetProperties", 4965, "*** ERROR: CGImageDestinationSetProperties: destination is nil\n");
  }
  kdebug_trace();
}

void sub_1880001E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOPackDstInputInfo(IIODictionary *a1)
{
  unint64_t v2;
  unint64_t v3;
  const __CFString *ObjectForKey;
  uint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int Uint32ForKey;

  if (!a1)
    return 0xFFA800000000;
  v2 = ((unint64_t)IIODictionary::getUint32ForKey(a1, CFSTR("Orientation")) & 0xF) << 52;
  v3 = v2 | (((unint64_t)IIODictionary::getUint32ForKeyGroup(a1, CFSTR("Orientation"), CFSTR("{TIFF}")) & 0xF) << 48);
  if (IIODictionary::containsKey(a1, CFSTR("kCGImageDestinationEncodeRequest")))
  {
    ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a1, CFSTR("kCGImageDestinationEncodeRequest"));
    if (CFStringCompare(ObjectForKey, CFSTR("kCGImageDestinationEncodeToSDR"), 0))
    {
      if (CFStringCompare(ObjectForKey, CFSTR("kCGImageDestinationEncodeToISOHDR"), 0))
      {
        if (CFStringCompare(ObjectForKey, CFSTR("kCGImageDestinationEncodeToISOGainmap"), 0))
          v5 = 0;
        else
          v5 = 0x300000000000;
      }
      else
      {
        v5 = 0x200000000000;
      }
    }
    else
    {
      v5 = 0x100000000000;
    }
    if (IIODictionary::containsKeyGroup(a1, CFSTR("kCGToneMappingMode"), CFSTR("kCGImageDestinationEncodeRequestOptions")))v8 = ((unint64_t)IIODictionary::getUint32ForKeyGroup(a1, CFSTR("kCGToneMappingMode"), CFSTR("kCGImageDestinationEncodeRequestOptions")) & 0xF) << 40;
    else
      v8 = 0xF0000000000;
    v9 = v5 | v8 | v3;
    if (IIODictionary::containsKeyGroup(a1, CFSTR("kCGImageDestinationCreateHDRGainMap"), CFSTR("kCGImageDestinationEncodeRequestOptions")))
    {
      if (IIODictionary::getBoolForKeyGroup(a1, CFSTR("kCGImageDestinationCreateHDRGainMap"), CFSTR("kCGImageDestinationEncodeRequestOptions")))v7 = v9 | 0x4000000000;
      else
        v7 = v9;
    }
    else
    {
      v7 = v9 | 0x8000000000;
    }
  }
  else
  {
    v7 = v3 | 0xFF8000000000;
  }
  if (IIODictionary::containsKey(a1, CFSTR("kCGImageDestinationPreserveGainMap")))
  {
    if (IIODictionary::getBoolForKey(a1, CFSTR("kCGImageDestinationPreserveGainMap")))
      v7 |= 0x1000000000uLL;
  }
  else
  {
    v7 |= 0x2000000000uLL;
  }
  if (IIODictionary::containsKey(a1, CFSTR("kCGImageDestinationOptimizeColorForSharing")))
  {
    if (IIODictionary::getBoolForKey(a1, CFSTR("kCGImageDestinationOptimizeColorForSharing")))
      v10 = v7 | 0x400000000;
    else
      v10 = v7;
  }
  else
  {
    v10 = v7 | 0x800000000;
  }
  Uint32ForKey = IIODictionary::getUint32ForKey(a1, CFSTR("kCGImageDestinationImageMaxPixelSize"));
  if (!Uint32ForKey)
    LOWORD(Uint32ForKey) = (unsigned __int16)IIODictionary::getUint32ForKey(a1, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
  return v10 | (unsigned __int16)Uint32ForKey;
}

void CGImageDestinationAddImageFromSource(CGImageDestinationRef idst, CGImageSourceRef isrc, size_t index, CFDictionaryRef properties)
{
  unsigned int v8;
  CFStringRef v9;
  unsigned int v10;
  const char *v11;
  uint64_t v12;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  size_t Count;
  IIO_Reader *v17;
  int v18;
  _QWORD v19[3];
  _QWORD v20[3];

  memset(v20, 0, sizeof(v20));
  IIODictionary::IIODictionary((IIODictionary *)v20, properties, 1);
  IIOPackDstInputInfo((IIODictionary *)v20);
  kdebug_trace();
  v8 = (gIIODebugFlags >> 12) & 3;
  if (v8 < 2)
  {
    if (v8)
      ImageIODebugOptions(1, "A", "CGImageDestinationAddImageFromSource", idst, 0, -1, properties);
  }
  else
  {
    if (!isrc)
    {
      ImageIODebugOptions(v8, "A", "CGImageDestinationAddImageFromSource", idst, 0, -1, properties);
      if (idst)
      {
        v12 = *((_QWORD *)idst + 3);
        goto LABEL_26;
      }
LABEL_30:
      LogError("CGImageDestinationAddImageFromSource", 5110, "*** ERROR: CGImageDestinationAddImageFromSource: destination is nil\n");
      goto LABEL_31;
    }
    v9 = CFCopyDescription(isrc);
    memset(v19, 0, sizeof(v19));
    IIOString::IIOString((IIOString *)v19, v9);
    v10 = (gIIODebugFlags >> 12) & 3;
    if (v10)
    {
      v11 = (const char *)IIOString::utf8String((IIOString *)v19);
      ImageIODebugOptions(v10, "A", "CGImageDestinationAddImageFromSource", idst, v11, -1, properties);
    }
    CFRelease(v9);
    IIOString::~IIOString((IIOString *)v19);
  }
  if (!idst)
    goto LABEL_30;
  v12 = *((_QWORD *)idst + 3);
  if (!isrc)
  {
LABEL_26:
    LogError("CGImageDestinationAddImageFromSource", 5112, "*** ERROR: CGImageDestinationAddImageFromSource: source is nil\n");
    goto LABEL_27;
  }
  v13 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1)
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_24);
  if (v13 == CGImageDestinationGetTypeID::id)
  {
    v14 = CFGetTypeID(isrc);
    if (v14 == CGImageSourceGetTypeID())
    {
      if (properties)
      {
        v15 = CFGetTypeID(properties);
        if (v15 != CFDictionaryGetTypeID())
          LogError("CGImageDestinationAddImageFromSource", 5117, "*** ERROR: CGImageDestinationAddImageFromSource: properties parameter is not a CFDictionaryRef - ignoring\n");
      }
      if (!CGImageSourceGetType(isrc))
      {
        LogError("CGImageDestinationAddImageFromSource", 5125, "*** ERROR: CGImageDestinationAddImageFromSource: source is not an image -- (CGImageSourceGetType() returned NULL)\n");
        v18 = -65;
        goto LABEL_28;
      }
      Count = CGImageSourceGetCount(isrc);
      if (Count > index)
      {
        if (v12)
        {
          IIOImageDestination::addImageFromSource((IIOImageDestination *)v12, isrc, index, (IIODictionary *)v20);
          v17 = *(IIO_Reader **)(v12 + 64);
          if (v17)
            IIO_Reader::osType(v17);
          v18 = 0;
          goto LABEL_29;
        }
        goto LABEL_31;
      }
      LogError("CGImageDestinationAddImageFromSource", 5131, "*** ERROR: srcIndex (%ld) >= CGImageSourceGetCount (%ld)\n", index, Count);
    }
    else
    {
      LogError("CGImageDestinationAddImageFromSource", 5114, "*** ERROR: CGImageDestinationAddImageFromSource: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageDestinationAddImageFromSource", 5113, "*** ERROR: CGImageDestinationAddImageFromSource: destination is not a CGImageDestinationRef\n");
  }
LABEL_27:
  v18 = -50;
LABEL_28:
  if (v12)
LABEL_29:
    *(_DWORD *)(v12 + 204) = v18;
LABEL_31:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v20);
}

void sub_188000774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationAddImageAndMetadata(CGImageDestinationRef idst, CGImageRef image, CGImageMetadataRef metadata, CFDictionaryRef options)
{
  CGColorSpace *ColorSpace;
  unsigned int v9;
  int v10;
  const char *v11;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  uint64_t v16;
  IIO_Reader *v17;
  _QWORD v18[3];

  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, options);
  if (image)
  {
    CGImageGetWidth(image);
    CGImageGetHeight(image);
  }
  IIOPackDstInputInfo((IIODictionary *)v18);
  if (image)
  {
    CGImageGetBitsPerPixel(image);
    CGImageGetBitsPerComponent(image);
    ColorSpace = CGImageGetColorSpace(image);
    CGColorSpaceGetModel(ColorSpace);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(image);
  }
  kdebug_trace();
  v9 = (gIIODebugFlags >> 12) & 3;
  if (v9)
    ImageIODebugOptions(v9, "A", "CGImageDestinationAddImageAndMetadata", idst, 0, -1, options);
  if (idst)
    v10 = 5168;
  else
    v10 = 5167;
  if (idst)
    v11 = "*** ERROR: CGImageDestinationAddImageAndMetadata: image is nil\n";
  else
    v11 = "*** ERROR: CGImageDestinationAddImageAndMetadata: destination is nil\n";
  if (!idst || !image)
    goto LABEL_31;
  v12 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1)
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_24);
  if (v12 != CGImageDestinationGetTypeID::id)
  {
    LogError("CGImageDestinationAddImageAndMetadata", 5169, "*** ERROR: CGImageDestinationAddImageAndMetadata: destination is not a CGImageDestinationRef\n");
    goto LABEL_32;
  }
  v13 = CFGetTypeID(image);
  if (v13 != CGImageGetTypeID())
  {
    v11 = "*** ERROR: CGImageDestinationAddImageAndMetadata: image is not a CGImageRef\n";
    v10 = 5170;
LABEL_31:
    LogError("CGImageDestinationAddImageAndMetadata", v10, v11);
    goto LABEL_32;
  }
  if (metadata)
  {
    v14 = CFGetTypeID(metadata);
    if (v14 != CGImageMetadataGetTypeID())
    {
      LogError("CGImageDestinationAddImageAndMetadata", 5173, "*** ERROR: CGImageDestinationAddImageAndMetadata: metadata parameter is not a CGImageMetadataRef - ignoring\n");
      metadata = 0;
    }
  }
  if (options)
  {
    v15 = CFGetTypeID(options);
    if (v15 != CFDictionaryGetTypeID())
      LogError("CGImageDestinationAddImageAndMetadata", 5178, "*** ERROR: CGImageDestinationAddImageAndMetadata: options parameter is not a CFDictionaryRef - ignoring\n");
  }
  v16 = *((_QWORD *)idst + 3);
  if (v16)
  {
    IIOImageDestination::addImageAndMetadata(*((IIOImageDestination **)idst + 3), image, metadata, (IIODictionary *)v18);
    v17 = *(IIO_Reader **)(v16 + 64);
    if (v17)
      IIO_Reader::osType(v17);
  }
LABEL_32:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v18);
}

void sub_188000A90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

BOOL CGImageDestinationCopyImageSource(CGImageDestinationRef idst, CGImageSourceRef isrc, CFDictionaryRef options, CFErrorRef *err)
{
  const __CFDictionary *v5;
  unsigned int v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  uint64_t v12;
  BOOL v13;
  IIO_Reader *v14;
  _QWORD v16[3];

  v5 = options;
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, options);
  IIOPackDstInputInfo((IIODictionary *)v16);
  kdebug_trace();
  IIOInitDebugFlags();
  v8 = (gIIODebugFlags >> 12) & 3;
  if (v8)
    ImageIODebugOptions(v8, "A", "CGImageDestinationCopyImageSource", idst, 0, -1, v5);
  if (!idst)
  {
    IIOLogAndCreateError(err, (const __CFString *)*MEMORY[0x1E0C9AFC8], -50, "CGImageDestinationCopyImageSource", 5212, "CGImageDestinationCopyImageSource: destination is nil\n");
LABEL_20:
    v13 = 0;
    goto LABEL_21;
  }
  if (!isrc)
  {
    IIOLogAndCreateError(err, (const __CFString *)*MEMORY[0x1E0C9AFC8], -50, "CGImageDestinationCopyImageSource", 5213, "CGImageDestinationCopyImageSource: source is nil\n");
    goto LABEL_20;
  }
  v9 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1)
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_24);
  if (v9 != CGImageDestinationGetTypeID::id)
  {
    IIOLogAndCreateError(err, (const __CFString *)*MEMORY[0x1E0C9AFC8], -50, "CGImageDestinationCopyImageSource", 5214, "*** ERROR: CGImageDestinationCopyImageSource: destination is not a CGImageDestinationRef\n");
    goto LABEL_20;
  }
  v10 = CFGetTypeID(isrc);
  if (v10 != CGImageSourceGetTypeID())
  {
    IIOLogAndCreateError(err, (const __CFString *)*MEMORY[0x1E0C9AFC8], -50, "CGImageDestinationCopyImageSource", 5215, "*** ERROR: CGImageDestinationCopyImageSource: source is not a CGImageSourceRef\n");
    goto LABEL_20;
  }
  if (v5)
  {
    v11 = CFGetTypeID(v5);
    if (v11 != CFDictionaryGetTypeID())
    {
      LogError("CGImageDestinationCopyImageSource", 5218, "*** ERROR: CGImageDestinationCopyImageSource: options parameter is not a CFDictionaryRef - ignoring\n");
      v5 = 0;
    }
  }
  v12 = *((_QWORD *)idst + 3);
  if (!v12)
    goto LABEL_20;
  v13 = IIOImageDestination::copyImageSource(*((CFStringRef **)idst + 3), isrc, (IIODictionary *)v16, v5 != 0, err);
  v14 = *(IIO_Reader **)(v12 + 64);
  if (v14)
    IIO_Reader::osType(v14);
LABEL_21:
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v13)
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageDestinationCopyImageSource", 5232, "could not copy from imageSource");
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  return v13;
}

void sub_188000CF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationAddAuxiliaryDataInfo(CGImageDestinationRef idst, CFStringRef auxiliaryImageDataType, CFDictionaryRef auxiliaryDataInfoDictionary)
{
  unsigned int v6;
  const char *v7;
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  IIOImageDestination *v11;
  IIO_Reader *v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;

  IIOInitDebugFlags();
  if (auxiliaryImageDataType
    && CFStringCompare(auxiliaryImageDataType, CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), 0))
  {
    CFStringCompare(auxiliaryImageDataType, CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"), 0);
  }
  kdebug_trace();
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    IIOString::IIOString((IIOString *)&v13, auxiliaryImageDataType);
    v6 = (gIIODebugFlags >> 12) & 3;
    if (v6)
    {
      v7 = (const char *)IIOString::utf8String((IIOString *)&v13);
      ImageIODebugOptions(v6, "A", "CGImageDestinationAddAuxiliaryDataInfo", idst, v7, -1, 0);
    }
    IIOString::~IIOString((IIOString *)&v13);
  }
  if (idst)
  {
    if (auxiliaryImageDataType)
    {
      if (auxiliaryDataInfoDictionary)
      {
        v8 = CFGetTypeID(idst);
        if (CGImageDestinationGetTypeID::once != -1)
          dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_24);
        if (v8 == CGImageDestinationGetTypeID::id)
        {
          v9 = CFGetTypeID(auxiliaryImageDataType);
          if (v9 == CFStringGetTypeID())
          {
            v10 = CFGetTypeID(auxiliaryDataInfoDictionary);
            if (v10 == CFDictionaryGetTypeID())
            {
              v11 = (IIOImageDestination *)*((_QWORD *)idst + 3);
              if (v11)
              {
                v13 = 0;
                v14 = 0;
                v15 = 0;
                IIODictionary::IIODictionary((IIODictionary *)&v13, auxiliaryDataInfoDictionary);
                IIOImageDestination::addAuxiliaryDataInfo(v11, auxiliaryImageDataType, &v13);
                v12 = (IIO_Reader *)*((_QWORD *)v11 + 8);
                if (v12)
                  IIO_Reader::osType(v12);
                IIODictionary::~IIODictionary((IIODictionary *)&v13);
              }
            }
            else
            {
              LogError("CGImageDestinationAddAuxiliaryDataInfo", 5282, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: auxiliaryDataInfoDictionary is not a CFDictionaryRef\n");
            }
          }
          else
          {
            LogError("CGImageDestinationAddAuxiliaryDataInfo", 5281, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: auxiliaryDataType is not a CFStringRef\n");
          }
        }
        else
        {
          LogError("CGImageDestinationAddAuxiliaryDataInfo", 5280, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: destination is not a CGImageDestinationRef\n");
        }
      }
      else
      {
        LogError("CGImageDestinationAddAuxiliaryDataInfo", 5279, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: auxiliaryDataInfoDictionary is nil\n");
      }
    }
    else
    {
      LogError("CGImageDestinationAddAuxiliaryDataInfo", 5278, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: auxiliaryDataType is nil\n");
    }
  }
  else
  {
    LogError("CGImageDestinationAddAuxiliaryDataInfo", 5277, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: destination is nil\n");
  }
  kdebug_trace();
}

void sub_188000FB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationAddImageWithMetadata(CGImageDestinationRef idst, CGImageRef image, __CFArray *a3)
{
  CGImageMetadata *v6;
  CGImageMetadata *v7;
  const __CFDictionary *v8;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageDestinationAddImageWithMetadata", 0, 0, -1, 0);
  keys[0] = CFSTR("{MetaData}");
  if (a3 && (v6 = CGImageMetadataCreateFromMetadataProperties(a3)) != 0)
  {
    v7 = v6;
    values = v6;
    v8 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFRelease(v7);
    CGImageDestinationAddImage(idst, image, v8);
    if (v8)
      CFRelease(v8);
  }
  else
  {
    CGImageDestinationAddImage(idst, image, 0);
  }
}

void CGImageDestinationAddImageFromSourceWithMetadata(CGImageDestinationRef idst, CGImageSourceRef isrc, size_t index, __CFArray *a4)
{
  CGImageMetadata *v8;
  CGImageMetadata *v9;
  const __CFDictionary *v10;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageDestinationAddImageFromSourceWithMetadata", 0, 0, -1, 0);
  keys[0] = CFSTR("{MetaData}");
  if (a4 && (v8 = CGImageMetadataCreateFromMetadataProperties(a4)) != 0)
  {
    v9 = v8;
    values = v8;
    v10 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFRelease(v9);
    CGImageDestinationAddImageFromSource(idst, isrc, index, v10);
    if (v10)
      CFRelease(v10);
  }
  else
  {
    CGImageDestinationAddImageFromSource(idst, isrc, index, 0);
  }
}

uint64_t TIFFInitNeXT(_QWORD *a1)
{
  a1[121] = NeXTPreDecode;
  a1[126] = NeXTDecode;
  a1[128] = NeXTDecode;
  a1[130] = NeXTDecode;
  return 1;
}

uint64_t NeXTPreDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 116) == 2)
    return 1;
  TIFFErrorExtR(a1, "NeXTPreDecode", "Unsupported BitsPerSample = %hu", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
  return 0;
}

uint64_t NeXTDecode(uint64_t a1, char *__b, int64_t __len, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char *v9;
  int64_t v11;
  uint64_t i;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  size_t v20;
  BOOL v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;

  v8 = __len;
  v9 = __b;
  if (__len >= 1)
    memset(__b, 255, __len);
  v11 = *(_QWORD *)(a1 + 1104);
  if (v8 % v11)
  {
    TIFFErrorExtR(a1, "NeXTDecode", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v25);
    return 0;
  }
  i = *(_QWORD *)(a1 + 1160);
  v14 = *(unsigned __int8 **)(a1 + 1152);
  if (i < 1 || v8 < 1)
  {
LABEL_35:
    *(_QWORD *)(a1 + 1152) = v14;
    *(_QWORD *)(a1 + 1160) = i;
    return 1;
  }
  while (1)
  {
    v16 = v14 + 1;
    v15 = *v14;
    v17 = i - 1;
    if (v15 != 64)
      break;
    if ((unint64_t)i < 5
      || ((v18 = __rev16(*(unsigned __int16 *)(v14 + 1)),
           v19 = __rev16(*(unsigned __int16 *)(v14 + 3)),
           v20 = v19 + 4,
           i > v19 + 4)
        ? (v21 = (uint64_t)(v19 + v18) <= v11)
        : (v21 = 0),
          !v21))
    {
LABEL_36:
      TIFFErrorExtR(a1, "NeXTDecode", "Not enough data for scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
      return 0;
    }
    _TIFFmemcpy(&v9[v18], v14 + 5, v19);
    v14 = &v16[v20];
    i = v17 - v20;
LABEL_32:
    if (i >= 1)
    {
      v9 += v11;
      v21 = v8 <= v11;
      v8 -= v11;
      if (!v21)
        continue;
    }
    goto LABEL_35;
  }
  if (!*v14)
  {
    if (i <= v11)
      goto LABEL_36;
    _TIFFmemcpy(v9, v14 + 1, v11);
    v14 = &v16[v11];
    i = v17 - v11;
    goto LABEL_32;
  }
  if ((*(_BYTE *)(a1 + 17) & 4) != 0)
    v22 = 100;
  else
    v22 = 88;
  v23 = *(_DWORD *)(a1 + v22);
  for (i = v17; ; --i)
  {
    if ((v15 & 0x3F) != 0 && v23 && v11 > 0)
      __asm { BR              X1 }
    if (!v23)
    {
      v14 = v16;
      goto LABEL_32;
    }
    if (v11 <= 0)
      break;
    if (!i)
      goto LABEL_36;
    v24 = *v16++;
    LOBYTE(v15) = v24;
  }
  TIFFErrorExtR(a1, "NeXTDecode", "Invalid data for scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
  return 0;
}

size_t png_default_read_data(size_t result, void *__ptr, size_t a3)
{
  void (**v4)(void);

  if (result)
  {
    v4 = (void (**)(void))result;
    result = fread(__ptr, 1uLL, a3, *(FILE **)(result + 40));
    if (result != a3)
      _cg_png_error(v4, "Read Error");
  }
  return result;
}

_QWORD *MPOReadPlugin::MPOReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *result = &off_1E1BAD3F8;
  return result;
}

_QWORD *MPOReadPlugin::MPOReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *result = &off_1E1BAD3F8;
  return result;
}

void MPOReadPlugin::~MPOReadPlugin(MPOReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t MPOReadPlugin::loadDataFromXPCObject(MPOReadPlugin *this, void *a2)
{
  uint64_t result;
  _BYTE *data;
  _BYTE *v6;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_mpo", &length);
    if (length == 1)
    {
      v6 = data;
      result = 0;
      *((_BYTE *)this + 436) = *v6;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t MPOReadPlugin::saveDataToXPCObject(MPOReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_mpo", (char *)this + 436, 1uLL);
  return v4;
}

uint64_t MPOReadPlugin::initialize(MPOReadPlugin *this, IIODictionary *a2)
{
  IIODictionary *v4;
  IIOImageRead *v5;
  GlobalMPOInfo *v6;
  unsigned int v7;
  _MPEntry *EntryAtIndex;
  _MPEntry *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  const __CFArray *Metadata;
  const void *ValueAtIndex;
  _BYTE v16[16];
  void *value;

  v4 = (IIODictionary *)*((_QWORD *)this + 7);
  v5 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1297108768);
  if (v5)
  {
    v6 = v5;
    v7 = *((_DWORD *)this + 52);
    if (v7 < GlobalMPOInfo::getEntryCount(v5))
    {
      EntryAtIndex = (_MPEntry *)GlobalMPOInfo::getEntryAtIndex(v6, *((_DWORD *)this + 52));
      if (EntryAtIndex)
      {
        v9 = EntryAtIndex;
        v10 = _MPEntry::imageSize(EntryAtIndex);
        v11 = _MPEntry::imageOffset(v9);
        v12 = v11;
        if (v11)
        {
          v11 = IIOImageSource::cf(v6);
          v12 += v11;
        }
        if (IIO_ReaderHandler::UseAppleJPEG((IIO_ReaderHandler *)v11))
          IIONumber::IIONumber((IIONumber *)v16, 1246774599);
        else
          IIONumber::IIONumber((IIONumber *)v16, 1279938631);
        IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_ostype"));
        IIONumber::~IIONumber((IIONumber *)v16);
        IIONumber::IIONumber((IIONumber *)v16, v12);
        IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_dataOffset"));
        IIONumber::~IIONumber((IIONumber *)v16);
        IIONumber::IIONumber((IIONumber *)v16, v10);
        IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_dataSize"));
        IIONumber::~IIONumber((IIONumber *)v16);
        Metadata = (const __CFArray *)GlobalMPOInfo::getMetadata(v6);
        if (Metadata)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(Metadata, *((unsigned int *)this + 52));
          if (ValueAtIndex)
            IIODictionary::setObjectForKey(v4, ValueAtIndex, CFSTR("{MPO}"));
        }
      }
    }
  }
  else
  {
    _cg_jpeg_mem_term("initialize", 91, "could not get globalMPOInfo\n");
  }
  kdebug_trace();
  kdebug_trace();
  return 4294967247;
}

void sub_1880018D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AppleJPEG::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  AppleJPEGReadPlugin::AppleJPEGReadPlugin(v4, a2, v5);
  return v4;
}

void sub_18800195C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40C020E1A5);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AppleJPEG::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  AppleJPEGReadPlugin::AppleJPEGReadPlugin(v8, a2, a3, a4, 0, 0, 1246774599, 0, v9);
  return v8;
}

void sub_188001A14(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40C020E1A5);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AppleJPEG::updateSourceProperties(IIO_Reader_AppleJPEG *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  unsigned __int16 i;
  unsigned int Val16;
  unsigned int v8;
  unint64_t v9;
  uint64_t v10;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = 0;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v12, a2);
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)&v12, 0);
  if (IIOScanner::getVal16((IIOScanner *)&v12) == 65496)
  {
    for (i = IIOScanner::getVal16((IIOScanner *)&v12); (i & 0xFFF0) == 0xFFE0; i = IIOScanner::getVal16((IIOScanner *)&v12))
    {
      Val16 = IIOScanner::getVal16((IIOScanner *)&v12);
      v8 = Val16;
      if (i == 65506 && Val16 >= 5)
      {
        v9 = *((_QWORD *)&v13 + 1);
        if (IIOScanner::getVal32((IIOScanner *)&v12) == 1297106432)
        {
          kdebug_trace();
          v10 = 4294967248;
          goto LABEL_11;
        }
        IIOScanner::seek((IIOScanner *)&v12, v9);
      }
      IIOScanner::skip((uint64_t)&v12, v8 - 2);
    }
  }
  v10 = 0;
LABEL_11:
  IIOScanner::~IIOScanner((IIOScanner *)&v12);
  return v10;
}

uint64_t IIO_Reader_AppleJPEG::initThumbnail(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  IIOImagePlus *Source;
  IIODictionary *Properties;
  uint64_t Session;
  IIOImageReadSession *v9;
  IIOImageReadSession *v10;
  unint64_t Size;
  IIOImageRead *v12;
  IIOImageRead *v13;
  unsigned __int8 *v14;
  uint64_t result;
  unint64_t v16;
  unsigned __int8 *v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unsigned __int8 *v23;
  int v24;
  unsigned int v25;
  unint64_t v26;
  unsigned int v27;
  unsigned __int8 *v28;
  unsigned __int16 *v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  __int16 v37;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unint64_t v43;
  int64_t BytesAtOffset;
  int v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v49;
  unint64_t v50;
  unsigned __int8 *v51;
  unsigned __int8 *v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int *v58;
  unsigned int v59;
  __int16 v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  int v67;
  _BYTE v68[24];
  _BYTE v69[24];
  void *v70;

  Source = (IIOImagePlus *)CGImageSourceGetSource(a2);
  Properties = (IIODictionary *)IIOImagePlus::getProperties(Source);
  Session = CGImagePluginGetSession(a2);
  v9 = (IIOImageReadSession *)CGImageSourceGetSource(Session);
  if (!Session)
    return 4294967245;
  v10 = v9;
  Size = (unint64_t)IIOImageReadSession::getSize(v9);
  v70 = 0;
  v12 = IIOImageReadSession::retainBytePointer(v10, (const __CFData **)&v70, 0);
  v13 = v12;
  if (v12)
  {
    v14 = (unsigned __int8 *)v12;
  }
  else
  {
    v14 = (unsigned __int8 *)malloc_type_malloc(0x1000uLL, 0x4397639FuLL);
    Size = IIOImageReadSession::getBytesAtOffset(v10, v14, 0, 0x1000uLL);
  }
  if (Size < 0x1000 || *v14 != 255 || v14[1] != 216)
    goto LABEL_17;
  if (v14[2] == 255 && v14[3] == 224)
    v16 = __rev16(*((unsigned __int16 *)v14 + 2)) + 4;
  else
    v16 = 2;
  if (v16 < Size - 10)
  {
    if (v14[v16] != 255)
      goto LABEL_17;
    v17 = &v14[v16];
    if (v14[v16 + 1] != 225)
      goto LABEL_17;
    v18 = *((unsigned __int16 *)v17 + 1);
    if (strncmp((const char *)v17 + 4, "Exif", 4uLL))
      goto LABEL_17;
    v22 = (unint64_t)&v14[Size];
    v19 = v16 + 10;
    v23 = &v14[v16 + 10];
    v24 = *v23;
    if (v24 == 77)
    {
      if (v23[1] != 77 || v23[2])
        goto LABEL_18;
      v25 = v18;
      v20 = 0;
      if (v23[3] != 42)
        goto LABEL_47;
    }
    else
    {
      if (v24 != 73 || v23[1] != 73 || v23[2] != 42)
        goto LABEL_18;
      v25 = v18;
      v20 = 0;
      if (v23[3])
        goto LABEL_47;
    }
    if ((unint64_t)(v23 + 8) <= v22)
    {
      v20 = 0;
      LODWORD(v26) = *((_DWORD *)v23 + 1);
      v27 = bswap32(v26);
      v26 = v24 == 77 ? v27 : v26;
      if (v26 >= 8 && (unint64_t)__rev16(v25) - 4 >= v26)
      {
        v28 = &v23[v26];
        v29 = (unsigned __int16 *)(v28 + 2);
        if ((unint64_t)(v28 + 2) <= v22)
        {
          v30 = *(unsigned __int16 *)v28;
          v31 = bswap32(v30) >> 16;
          if (v24 == 77)
            v32 = v31;
          else
            v32 = v30;
          if ((Size - v16 - v26 - 12) / 0xC <= (unsigned __int16)v32)
            goto LABEL_18;
          if ((_WORD)v32)
          {
            v65 = v24;
            do
            {
              if ((unint64_t)(v29 + 1) <= v22)
              {
                v33 = *v29;
                v34 = bswap32(v33) >> 16;
                if (v24 == 77)
                  LOWORD(v33) = v34;
              }
              else
              {
                LOWORD(v33) = 0;
              }
              if ((unint64_t)(v29 + 2) <= v22)
              {
                v35 = bswap32(v29[1]) >> 16;
                if (v24 != 77)
                  LOWORD(v35) = v29[1];
              }
              else
              {
                LOWORD(v35) = 0;
              }
              if ((unint64_t)(v29 + 4) <= v22)
              {
                v36 = *((_DWORD *)v29 + 1);
                v37 = bswap32(v36);
                if (v24 == 77)
                  LOWORD(v36) = v37;
                if ((unsigned __int16)v33 == 274
                  && (unsigned __int16)v35 == 3
                  && (unsigned __int16)v36 == 1
                  && (unint64_t)(v29 + 5) <= v22)
                {
                  v39 = v29[4];
                  v40 = bswap32(v39) >> 16;
                  if (v24 == 77)
                    LOWORD(v39) = v40;
                  if ((unsigned __int16)(v39 - 1) <= 7u)
                  {
                    v66 = v32;
                    v67 = (unsigned __int16)v39;
                    IIONumber::IIONumber((IIONumber *)v69, (unsigned __int16)v39);
                    IIODictionary::setObjectForKey((uint64_t)Properties, (uint64_t)v69, CFSTR("Orientation"));
                    IIONumber::~IIONumber((IIONumber *)v69);
                    IIONumber::IIONumber((IIONumber *)v68, v67);
                    IIODictionary::setObjectForKeyGroup(Properties, (uint64_t)v68, CFSTR("Orientation"), CFSTR("{TIFF}"));
                    IIONumber::~IIONumber((IIONumber *)v68);
                    v24 = v65;
                    v22 = (unint64_t)&v14[Size];
                    v32 = v66;
                  }
                }
              }
              --v32;
              v29 += 6;
            }
            while ((_WORD)v32);
          }
        }
        else if (Size - v16 - v26 - 12 < 0xC)
        {
          goto LABEL_18;
        }
        if ((unint64_t)(v29 + 2) > v22)
          goto LABEL_18;
        v41 = *(_DWORD *)v29;
        v42 = bswap32(*(_DWORD *)v29);
        if (v24 == 77)
          v41 = v42;
        if (!v41)
          goto LABEL_18;
        v43 = v19 + v41;
        if (v70)
        {
          if (Size <= v43 + 2)
            goto LABEL_18;
          v14 = (unsigned __int8 *)v13 + v43;
          BytesAtOffset = Size - v43;
        }
        else
        {
          v45 = v24;
          BytesAtOffset = IIOImageReadSession::getBytesAtOffset(v10, v14, v43, 0x1000uLL);
          if ((unint64_t)BytesAtOffset < 2)
            goto LABEL_18;
          v24 = v45;
        }
        if (BytesAtOffset >= 2)
        {
          v46 = *(unsigned __int16 *)v14;
          v47 = bswap32(v46) >> 16;
          if (v24 == 77)
            v46 = v47;
          if ((BytesAtOffset - 2) / 0xCuLL > (unsigned __int16)v46 && (unsigned __int16)v46 != 0)
          {
            v49 = 0;
            v21 = 0;
            v20 = 0;
            v50 = (unint64_t)&v14[BytesAtOffset];
            do
            {
              v51 = &v14[v49];
              v52 = &v14[v49 + 4];
              if ((unint64_t)v52 <= v50)
              {
                v53 = *((unsigned __int16 *)v51 + 1);
                v54 = bswap32(v53) >> 16;
                if (v24 == 77)
                  LOWORD(v53) = v54;
              }
              else
              {
                LOWORD(v53) = 0;
              }
              v55 = (unsigned int *)(v51 + 6);
              if ((unint64_t)(v51 + 6) <= v50)
              {
                v57 = *(unsigned __int16 *)v52;
                v56 = bswap32(v57) >> 16;
                if (v24 != 77)
                  LOWORD(v56) = v57;
              }
              else
              {
                LOWORD(v56) = 0;
              }
              v58 = (unsigned int *)&v14[v49 + 10];
              if ((unint64_t)v58 <= v50)
              {
                v59 = *v55;
                v60 = bswap32(v59);
                if (v24 != 77)
                  v60 = v59;
                if ((unsigned __int16)v53 == 513 && (unsigned __int16)v56 == 4 && v60 == 1)
                {
                  if ((unint64_t)&v14[v49 + 14] <= v50)
                  {
                    v61 = *v58;
                    v63 = bswap32(v61);
                    if (v24 == 77)
                      v61 = v63;
                  }
                  else
                  {
                    v61 = 0;
                  }
                  v20 = v61;
                }
                else if ((unsigned __int16)v53 == 514 && (unsigned __int16)v56 == 4 && v60 == 1)
                {
                  if ((unint64_t)&v14[v49 + 14] <= v50)
                  {
                    v62 = *v58;
                    v64 = bswap32(v62);
                    if (v24 == 77)
                      v62 = v64;
                  }
                  else
                  {
                    v62 = 0;
                  }
                  v21 = v62;
                }
              }
              --v46;
              v49 += 12;
            }
            while ((_WORD)v46);
            goto LABEL_19;
          }
        }
        goto LABEL_18;
      }
    }
LABEL_47:
    v21 = 0;
    goto LABEL_19;
  }
  _cg_jpeg_mem_term("initThumbnail", 311, "*** ERROR: bad APP marker offset (%ld)\n", v16);
LABEL_17:
  v19 = 0;
LABEL_18:
  v20 = 0;
  v21 = 0;
LABEL_19:
  if (v70)
  {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)v10, v70);
  }
  else if (v14)
  {
    free(v14);
  }
  result = 4294967245;
  if (v20 && v21)
  {
    if (CGImagePluginInitThumbJPEGAtOffset(a2, (IIOImageReadSession *)(v20 + v19), v21, a4))
      return 0;
    else
      return 4294967245;
  }
  return result;
}

void sub_1880021A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AppleJPEG::hasCustomSourcePropertiesProc(IIO_Reader_AppleJPEG *this)
{
  return 1;
}

uint64_t IIO_Reader_AppleJPEG::canCreateCustomThumbnailSizes(IIO_Reader_AppleJPEG *this)
{
  return 1;
}

uint64_t png_icc_profile_error(uint64_t a1, uint64_t a2, _BYTE *a3, unint64_t a4, _BYTE *a5)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  char *v20;
  char v21;
  char v22;
  unsigned int v23;
  char v24;
  _QWORD v25[3];
  _OWORD v26[12];
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a2)
    *(_WORD *)(a2 + 74) |= 0x8000u;
  v27 = 0;
  memset(v26, 0, sizeof(v26));
  v10 = png_safecat((uint64_t)v26, 0xC4uLL, 0, "profile '");
  v11 = png_safecat((uint64_t)v26, v10 + 79, v10, a3);
  v12 = png_safecat((uint64_t)v26, 0xC4uLL, v11, "': ");
  v13 = v12;
  v14 = a4 >> 24;
  if ((a4 >> 24 == 32 || v14 - 48 < 0xA || (v14 & 0xFFFFFFFFFFFFFFDFLL) - 65 <= 0x19)
    && (((a4 >> 16) & 0xDF) - 65 < 0x1A || BYTE2(a4) == 32 || (unint64_t)BYTE2(a4) - 48 <= 9)
    && (((a4 >> 8) & 0xDF) - 65 < 0x1A || BYTE1(a4) == 32 || (unint64_t)BYTE1(a4) - 48 <= 9)
    && ((unint64_t)(a4 & 0xDF) - 65 < 0x1A
     || a4 == 32
     || (unint64_t)a4 - 48 <= 9))
  {
    v20 = (char *)v26 + v12;
    *((_BYTE *)v26 + v12) = 39;
    v21 = BYTE3(a4);
    if (BYTE3(a4) - 32 >= 0x5F)
      v21 = 63;
    v20[1] = v21;
    v22 = BYTE2(a4);
    if (BYTE2(a4) - 32 >= 0x5F)
      v22 = 63;
    v20[2] = v22;
    v23 = a4 >> 8;
    if (BYTE1(a4) - 32 >= 0x5F)
      LOBYTE(v23) = 63;
    v20[3] = v23;
    if (a4 - 32 >= 0x5F)
      v24 = 63;
    else
      v24 = a4;
    v20[4] = v24;
    *(_WORD *)(v20 + 5) = 14887;
    v17 = v12 + 8;
    v20[7] = 32;
  }
  else
  {
    memset(v25, 0, sizeof(v25));
    v15 = (_BYTE *)png_format_number((unint64_t)v25, (uint64_t)v26, 3, a4);
    v16 = png_safecat((uint64_t)v26, 0xC4uLL, v13, v15);
    v17 = png_safecat((uint64_t)v26, 0xC4uLL, v16, "h: ");
  }
  png_safecat((uint64_t)v26, 0xC4uLL, v17, a5);
  if (a2)
    v18 = 2;
  else
    v18 = 1;
  return png_chunk_report(a1, (char *)v26, v18);
}

uint64_t png_colorspace_set_rgb_coefficients(uint64_t result)
{
  int v1;
  int v2;
  int v3;
  int v4;
  double v5;
  double v6;
  BOOL v7;
  unsigned int v8;
  double v9;
  double v10;
  BOOL v11;
  unsigned int v12;
  double v13;
  double v14;
  unsigned int v16;
  unsigned int v17;
  int v18;

  if (*(_BYTE *)(result + 753) || (*(_WORD *)(result + 1074) & 2) == 0)
    return result;
  v1 = *(_DWORD *)(result + 1040);
  if (v1 < 0)
    goto LABEL_46;
  v2 = *(_DWORD *)(result + 1052);
  v3 = *(_DWORD *)(result + 1064);
  v4 = v2 + v1 + v3;
  if (v4 < 1)
    goto LABEL_46;
  if (v1)
  {
    v5 = (double)v1 * 32768.0 / (double)v4 + 0.5;
    v6 = floor(v5);
    v7 = v6 <= 2147483650.0 && v6 >= -2147483650.0;
    v8 = vcvtmd_s64_f64(v5);
    if (v7)
      v1 = v8;
    if (v2 < 0)
LABEL_46:
      _cg_png_error((void (**)(void))result, "internal error handling cHRM->XYZ");
  }
  else
  {
    v7 = 1;
    if (v2 < 0)
      goto LABEL_46;
  }
  if (!v7 || v1 < 0 || v1 > 0x8000)
    goto LABEL_46;
  if (v2)
  {
    v9 = (double)v2 * 32768.0 / (double)v4 + 0.5;
    v10 = floor(v9);
    v11 = v10 <= 2147483650.0 && v10 >= -2147483650.0;
    v12 = vcvtmd_s64_f64(v9);
    if (v11)
      v2 = v12;
    if (v3 < 0)
      goto LABEL_46;
  }
  else
  {
    v11 = 1;
    if (v3 < 0)
      goto LABEL_46;
  }
  if (!v11 || v2 < 0 || v2 > 0x8000)
    goto LABEL_46;
  if (v3)
  {
    v13 = (double)v3 * 32768.0 / (double)v4 + 0.5;
    v14 = floor(v13);
    if (v14 > 2147483650.0 || v14 < -2147483650.0)
      goto LABEL_46;
    v16 = vcvtmd_s64_f64(v13);
    if (v16 > 0x8000)
      goto LABEL_46;
  }
  else
  {
    v16 = 0;
  }
  v17 = v2 + v1 + v16;
  if (v17 > 0x8001)
    goto LABEL_46;
  if (v17 == 32769)
  {
    v18 = -1;
LABEL_36:
    if (v2 < v1 || v2 < v16)
    {
      if (v1 < v2 || v1 < v16)
        v16 += v18;
      else
        v1 += v18;
    }
    else
    {
      v2 += v18;
    }
    goto LABEL_43;
  }
  if (!(v17 >> 15))
  {
    v18 = 1;
    goto LABEL_36;
  }
LABEL_43:
  if (v2 + v1 + v16 != 0x8000)
    _cg_png_error((void (**)(void))result, "internal error handling cHRM coefficients");
  *(_WORD *)(result + 754) = v1;
  *(_WORD *)(result + 756) = v2;
  return result;
}

uint64_t png_muldiv(int *a1, int a2, int a3, int a4)
{
  int v4;
  double v5;

  if (!a4)
    return 0;
  v4 = 0;
  if (!a2 || !a3)
    goto LABEL_10;
  v5 = floor((double)a2 * (double)a3 / (double)a4 + 0.5);
  if (v5 > 2147483650.0 || v5 < -2147483650.0)
    return 0;
  v4 = (int)v5;
LABEL_10:
  *a1 = v4;
  return 1;
}

uint64_t png_check_fp_number(uint64_t a1, unint64_t a2, unsigned int *a3, unint64_t *a4)
{
  unsigned int v4;
  unint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;

  v4 = *a3;
  v5 = *a4;
  if (*a4 < a2)
  {
    while (2)
    {
      v6 = 4;
      switch(*(_BYTE *)(a1 + v5))
      {
        case '+':
          goto LABEL_4;
        case '-':
          v6 = 132;
          goto LABEL_4;
        case '.':
          v6 = 16;
          goto LABEL_4;
        case '0':
          v6 = 8;
          goto LABEL_4;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          v6 = 264;
          goto LABEL_4;
        case 'E':
          v6 = 32;
LABEL_4:
          v7 = v6 & 0x3C | v4 & 3;
          switch(v7)
          {
            case 4:
              if ((v4 & 0x3C) == 0)
              {
                v4 |= v6;
                break;
              }
              goto LABEL_27;
            case 5:
            case 7:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
              goto LABEL_27;
            case 6:
              if ((v4 & 0x3C) == 0)
              {
                v4 |= 4u;
                break;
              }
              goto LABEL_27;
            case 8:
              if ((v4 & 0x10) != 0)
                v4 = v4 & 0x180 | 0x11;
              goto LABEL_15;
            case 9:
LABEL_15:
              v4 |= v6 | 0x40;
              break;
            case 10:
              v4 |= 0x48u;
              break;
            case 16:
              if ((v4 & 0x10) != 0)
                goto LABEL_27;
              v8 = v4 & 0x1C0 | v6 | 1;
              v9 = v6 | v4;
              if ((v4 & 8) != 0)
                v4 = v9;
              else
                v4 = v8;
              break;
            default:
              if (v7 != 32 && v7 != 33 || (v4 & 8) == 0)
                goto LABEL_27;
              v4 = v4 & 0x1C0 | 2;
              break;
          }
          if (a2 != ++v5)
            continue;
          v5 = a2;
          break;
        default:
          goto LABEL_27;
      }
      break;
    }
  }
LABEL_27:
  *a3 = v4;
  *a4 = v5;
  return (v4 >> 3) & 1;
}

uint64_t png_check_fp_string(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unsigned int v6;

  v6 = 0;
  v5 = 0;
  result = png_check_fp_number(a1, a2, &v6, &v5);
  if ((_DWORD)result)
  {
    if (v5 == a2 || !*(_BYTE *)(a1 + v5))
      return v6;
    else
      return 0;
  }
  return result;
}

uint64_t png_fixed(void (**a1)(void), uint64_t a2, double a3)
{
  double v3;

  v3 = floor(a3 * 100000.0 + 0.5);
  if (v3 > 2147483650.0 || v3 < -2147483650.0)
    png_fixed_error(a1, a2);
  return (int)v3;
}

unsigned int png_reciprocal2(int a1, int a2)
{
  double v2;
  double v3;
  BOOL v4;

  if (a1
    && a2
    && ((v2 = 1.0e15 / (double)a1 / (double)a2 + 0.5, v3 = floor(v2), v3 <= 2147483650.0)
      ? (v4 = v3 < -2147483650.0)
      : (v4 = 1),
        !v4))
  {
    return vcvtmd_s64_f64(v2);
  }
  else
  {
    return 0;
  }
}

uint64_t png_gamma_8bit_correct(uint64_t result, int a2)
{
  if ((result - 1) <= 0xFD)
    LOBYTE(result) = vcvtmd_s64_f64(pow((double)(int)result / 255.0, (double)a2 * 0.00001) * 255.0 + 0.5);
  return result;
}

uint64_t png_gamma_correct(uint64_t a1, int a2, int a3)
{
  unsigned int v3;

  v3 = a2 - 1;
  if (*(_BYTE *)(a1 + 392) == 8)
  {
    if (v3 <= 0xFD)
      LOBYTE(a2) = vcvtmd_s64_f64(pow((double)a2 / 255.0, (double)a3 * 0.00001) * 255.0 + 0.5);
    LOWORD(a2) = a2;
  }
  else if (v3 <= 0xFFFD)
  {
    LOWORD(a2) = vcvtmd_s64_f64(pow((double)a2 / 65535.0, (double)a3 * 0.00001) * 65535.0 + 0.5);
  }
  return (unsigned __int16)a2;
}

void png_build_gamma_table(uint64_t a1, int a2)
{
  int v4;
  int v5;
  double v6;
  double v7;
  BOOL v8;
  unsigned int v9;
  unsigned int v10;
  unsigned __int8 v11;
  char v12;
  int v13;
  int v14;
  int v15;
  double *v16;
  double v17;
  double v18;
  int v19;
  double v21;
  int v22;
  double v23;
  double v24;
  BOOL v25;
  char v26;
  uint64_t v27;
  void (**v28)(void);
  void (***v29)(void);
  unsigned int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  double v36;
  double v37;
  BOOL v38;
  unsigned int v39;
  int v40;
  int v41;
  double v42;
  double v43;
  BOOL v44;
  unsigned int v45;
  int v46;
  int v47;
  double v48;
  double v49;
  double v50;
  BOOL v51;
  unsigned int v52;
  int v53;
  int v54;
  double v55;
  double v56;
  BOOL v57;
  unsigned int v58;
  int v59;

  if (*(_QWORD *)(a1 + 456) || *(_QWORD *)(a1 + 464))
  {
    png_warning(a1, "gamma table being rebuilt");
    png_destroy_gamma_table(a1);
  }
  if (a2 > 8)
  {
    if ((*(_BYTE *)(a1 + 391) & 2) != 0)
    {
      v9 = *(unsigned __int8 *)(a1 + 504);
      if (*(unsigned __int8 *)(a1 + 505) > v9)
        v9 = *(unsigned __int8 *)(a1 + 505);
      if (*(unsigned __int8 *)(a1 + 506) > v9)
        v9 = *(unsigned __int8 *)(a1 + 506);
    }
    else
    {
      v9 = *(unsigned __int8 *)(a1 + 507);
    }
    v10 = v9 - 1;
    v11 = 16 - v9;
    if (v10 >= 0xF)
      v11 = 0;
    v12 = v11;
    if (v11 <= 5u)
      v12 = 5;
    v13 = *(_DWORD *)(a1 + 88) & 0x4000400;
    if (v13)
      v11 = v12;
    if ((v11 & 0xF8) != 0)
      v14 = 8;
    else
      v14 = v11;
    *(_DWORD *)(a1 + 448) = v14;
    v15 = *(_DWORD *)(a1 + 452);
    v16 = (double *)&unk_188210000;
    if (v13)
    {
      if (v15 < 1)
      {
        v21 = 1.0;
      }
      else
      {
        v17 = (double)*(int *)(a1 + 1000) * 0.00001 * (double)v15 + 0.5;
        v18 = floor(v17);
        v19 = vcvtmd_s64_f64(v17);
        if (v18 < -2147483650.0 || v18 > 2147483650.0)
          v21 = 0.0;
        else
          v21 = (double)v19 * 0.00001;
      }
      v26 = 8 - v14;
      v27 = (1 << (8 - v14));
      v28 = png_calloc((void (**)(void))a1, 8 * v27);
      *(_QWORD *)(a1 + 464) = v28;
      v29 = (void (***)(void))v28;
      do
      {
        *v29++ = png_malloc((void (**)(void))a1, 0x200uLL);
        --v27;
      }
      while (v27);
      v30 = 0;
      v31 = 0;
      v32 = 0xFFu >> v14;
      do
      {
        v33 = vcvtmd_s64_f64(pow((double)((unsigned __int16)(257 * v31) + 128) / 65535.0, v21) * 65535.0 + 0.5);
        v34 = ((v33 << (16 - v14)) - v33 + 0x8000) / 0xFFFF;
        if (v30 <= v34)
        {
          do
          {
            *((_WORD *)v28[v30 & v32] + (v30 >> v26)) = 257 * v31;
            ++v30;
          }
          while (v34 + 1 != v30);
          v30 = v34 + 1;
        }
        ++v31;
      }
      while (v31 != 255);
      v16 = (double *)&unk_188210000;
      if (v30 < 256 << v26)
      {
        do
        {
          *((_WORD *)v28[v30 & v32] + (v30 >> v26)) = -1;
          ++v30;
        }
        while (256 << v26 != v30);
      }
    }
    else
    {
      if (v15 < 1)
      {
        v47 = 100000;
      }
      else
      {
        v22 = *(_DWORD *)(a1 + 1000);
        if (!v22
          || ((v23 = 1.0e15 / (double)v22 / (double)v15 + 0.5, v24 = floor(v23), v24 <= 2147483650.0)
            ? (v25 = v24 < -2147483650.0)
            : (v25 = 1),
              v25))
        {
          v47 = 0;
        }
        else
        {
          v47 = vcvtmd_s64_f64(v23);
        }
      }
      png_build_16bit_table((void (**)(void))a1, (void (***)(void))(a1 + 464), v14, v47);
    }
    if ((*(_DWORD *)(a1 + 88) & 0x600080) != 0)
    {
      v48 = 1.0e10 / (double)*(int *)(a1 + 1000) + 0.5;
      v49 = floor(v48);
      v50 = v16[458];
      v51 = v49 < -2147483650.0 || v49 > v50;
      v52 = vcvtmd_s64_f64(v48);
      if (v51)
        v53 = 0;
      else
        v53 = v52;
      png_build_16bit_table((void (**)(void))a1, (void (***)(void))(a1 + 496), v14, v53);
      v54 = *(_DWORD *)(a1 + 452);
      if (v54 < 1)
      {
        v59 = *(_DWORD *)(a1 + 1000);
      }
      else
      {
        v55 = 1.0e10 / (double)v54 + 0.5;
        v56 = floor(v55);
        v57 = v56 < -2147483650.0 || v56 > v50;
        v58 = vcvtmd_s64_f64(v55);
        if (v57)
          v59 = 0;
        else
          v59 = v58;
      }
      png_build_16bit_table((void (**)(void))a1, (void (***)(void))(a1 + 488), v14, v59);
    }
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 452);
    if (v4 < 1)
    {
      v35 = 100000;
    }
    else
    {
      v5 = *(_DWORD *)(a1 + 1000);
      if (!v5
        || ((v6 = 1.0e15 / (double)v5 / (double)v4 + 0.5, v7 = floor(v6), v7 <= 2147483650.0)
          ? (v8 = v7 < -2147483650.0)
          : (v8 = 1),
            v8))
      {
        v35 = 0;
      }
      else
      {
        v35 = vcvtmd_s64_f64(v6);
      }
    }
    png_build_8bit_table((void (**)(void))a1, (void (***)(void))(a1 + 456), v35);
    if ((*(_DWORD *)(a1 + 88) & 0x600080) != 0)
    {
      v36 = 1.0e10 / (double)*(int *)(a1 + 1000) + 0.5;
      v37 = floor(v36);
      v38 = v37 < -2147483650.0 || v37 > 2147483650.0;
      v39 = vcvtmd_s64_f64(v36);
      if (v38)
        v40 = 0;
      else
        v40 = v39;
      png_build_8bit_table((void (**)(void))a1, (void (***)(void))(a1 + 480), v40);
      v41 = *(_DWORD *)(a1 + 452);
      if (v41 < 1)
      {
        v46 = *(_DWORD *)(a1 + 1000);
      }
      else
      {
        v42 = 1.0e10 / (double)v41 + 0.5;
        v43 = floor(v42);
        v44 = v43 < -2147483650.0 || v43 > 2147483650.0;
        v45 = vcvtmd_s64_f64(v42);
        if (v44)
          v46 = 0;
        else
          v46 = v45;
      }
      png_build_8bit_table((void (**)(void))a1, (void (***)(void))(a1 + 472), v46);
    }
  }
}

void png_build_8bit_table(void (**a1)(void), void (***a2)(void), int a3)
{
  void (**v5)(void);
  void (**v6)(void);
  uint64_t v7;
  int8x16_t v8;
  int8x16_t v9;
  uint64_t i;
  char v11;

  v5 = png_malloc(a1, 0x100uLL);
  v6 = v5;
  *a2 = v5;
  if ((a3 - 95000) > 0x2710)
  {
    for (i = 0; i != 256; ++i)
    {
      if ((i - 1) > 0xFD)
        v11 = i;
      else
        v11 = vcvtmd_s64_f64(pow((double)(int)i / 255.0, (double)a3 * 0.00001) * 255.0 + 0.5);
      *((_BYTE *)v6 + i) = v11;
    }
  }
  else
  {
    v7 = 0;
    v8 = (int8x16_t)xmmword_18820EE20;
    v9.i64[0] = 0x1010101010101010;
    v9.i64[1] = 0x1010101010101010;
    do
    {
      *(int8x16_t *)&v5[v7] = v8;
      v7 += 2;
      v8 = vaddq_s8(v8, v9);
    }
    while (v7 != 32);
  }
}

void png_build_16bit_table(void (**a1)(void), void (***a2)(void), int a3, int a4)
{
  unsigned int v7;
  int v8;
  int v9;
  void (**v11)(void);
  uint64_t v12;
  unsigned int v13;
  double v14;
  void (**v20)(void);
  void (**v21)(void);
  uint64_t i;
  unsigned int v23;
  uint64_t v24;
  uint32x4_t v25;
  uint32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  uint64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;
  long double v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  uint64_t v39;
  float64x2_t v40;
  float64x2_t v41;
  uint32x4_t v42;
  double v43;
  int32x4_t v44;
  long double v45;
  long double v46;
  long double v47;
  float64x2_t v48;
  long double v49;
  int32x4_t v50;
  int32x4_t v51;
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  int8x16x4_t v55;

  v7 = 8 - a3;
  v8 = ~(-1 << (16 - a3));
  v43 = 1.0 / (double)v8;
  v9 = 1 << (15 - a3);
  v39 = (1 << (8 - a3));
  v11 = png_calloc(a1, 8 * v39);
  v12 = 0;
  *a2 = v11;
  v13 = a4 - 95000;
  v14 = (double)a4 * 0.00001;
  v42 = (uint32x4_t)vdupq_n_s32(v7);
  v41 = (float64x2_t)vdupq_n_s64(0x40EFFFE000000000uLL);
  __asm { FMOV            V0.2D, #0.5 }
  v40 = _Q0;
  do
  {
    v20 = png_malloc(a1, 0x200uLL);
    v21 = v20;
    v11[v12] = (void (*)(void))v20;
    if (v13 > 0x2710)
    {
      v24 = 0;
      v44 = vdupq_n_s32(v12);
      v25 = (uint32x4_t)xmmword_18820BF90;
      v26 = (uint32x4_t)xmmword_18822AB70;
      do
      {
        v50 = (int32x4_t)v26;
        v51 = (int32x4_t)v25;
        v27 = vaddq_s32((int32x4_t)vshlq_u32(v26, v42), v44);
        v28 = vaddq_s32((int32x4_t)vshlq_u32(v25, v42), v44);
        v29.i64[0] = v28.u32[0];
        v29.i64[1] = v28.u32[1];
        v30 = vcvtq_f64_u64(v29);
        v29.i64[0] = v28.u32[2];
        v29.i64[1] = v28.u32[3];
        v31 = vcvtq_f64_u64(v29);
        v29.i64[0] = v27.u32[0];
        v29.i64[1] = v27.u32[1];
        v32 = vcvtq_f64_u64(v29);
        v29.i64[0] = v27.u32[2];
        v29.i64[1] = v27.u32[3];
        v53 = vmulq_n_f64(v32, v43);
        v54 = vmulq_n_f64(vcvtq_f64_u64(v29), v43);
        v52 = vmulq_n_f64(v31, v43);
        v48 = vmulq_n_f64(v30, v43);
        v49 = pow(v48.f64[0], v14);
        v47 = pow(v48.f64[1], v14);
        v48.f64[0] = pow(v52.f64[0], v14);
        v52.f64[0] = pow(v52.f64[1], v14);
        v46 = pow(v53.f64[0], v14);
        v45 = pow(v53.f64[1], v14);
        v53.f64[0] = pow(v54.f64[0], v14);
        v33 = pow(v54.f64[1], v14);
        *(long double *)v55.val[2].i64 = v46;
        *(long double *)&v55.val[2].i64[1] = v45;
        *(long double *)v55.val[1].i64 = v49;
        *(long double *)&v55.val[1].i64[1] = v47;
        v34.f64[0] = v53.f64[0];
        v34.f64[1] = v33;
        v35.f64[0] = v48.f64[0];
        v35.f64[1] = v52.f64[0];
        v55.val[0].i64[1] = *(_QWORD *)&v41.f64[1];
        v36 = vmlaq_f64(v40, v41, v35);
        v37 = vmlaq_f64(v40, v41, v34);
        v38 = vrndmq_f64(vmlaq_f64(v40, v41, (float64x2_t)v55.val[1]));
        *(int32x2_t *)v55.val[1].i8 = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(v36)));
        *(int32x2_t *)v55.val[3].i8 = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(v37)));
        *(int32x2_t *)v55.val[0].i8 = vmovn_s64(vcvtq_s64_f64(v38));
        *(int32x2_t *)v55.val[2].i8 = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vmlaq_f64(v40, v41, (float64x2_t)v55.val[2]))));
        *(int8x16_t *)&v21[v24] = vqtbl4q_s8(v55, (int8x16_t)xmmword_18822AB80);
        *(_QWORD *)&v36.f64[0] = 0x800000008;
        *(_QWORD *)&v36.f64[1] = 0x800000008;
        v25 = (uint32x4_t)vaddq_s32(v51, (int32x4_t)v36);
        v26 = (uint32x4_t)vaddq_s32(v50, (int32x4_t)v36);
        v24 += 2;
      }
      while (v24 != 64);
    }
    else
    {
      for (i = 0; i != 256; ++i)
      {
        v23 = ((_DWORD)i << v7) + v12;
        if (a3)
          v23 = (v9 - v23 + (v23 << 16)) / v8;
        *((_WORD *)v20 + i) = v23;
      }
    }
    ++v12;
  }
  while (v12 != v39);
}

void TIFFWritePlugin::TIFFWritePlugin(TIFFWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  _QWORD *v3;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 0x1Du);
  *v3 = &off_1E1BB0C40;
}

void TIFFWritePlugin::~TIFFWritePlugin(TIFFWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t TIFFWritePlugin::writeICCData(uint64_t a1, uint64_t a2, CGColorSpace *a3, int a4)
{
  __CFData *v5;
  const __CFData *v6;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v5 = CGColorSpaceCopyData(a3, a4);
  if (!v5)
    return 4294967246;
  v6 = v5;
  BytePtr = CFDataGetBytePtr(v5);
  Length = CFDataGetLength(v6);
  v15 = 4294967246;
  if (BytePtr && Length)
  {
    _cg_TIFFSetField(a2, 34675, v9, v10, v11, v12, v13, v14, Length);
    v15 = 0;
  }
  CFRelease(v6);
  return v15;
}

uint64_t TIFFWritePlugin::writeIPTCData(int a1, uint64_t a2, IIODictionary *this)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v5;
  IIODictionary *v6;
  size_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (this)
  {
    ObjectForKey = IIODictionary::getObjectForKey(this, CFSTR("{IPTC}"));
    if (ObjectForKey)
    {
      v5 = ObjectForKey;
      v6 = (IIODictionary *)operator new();
      IIODictionary::IIODictionary(v6, v5);
      v7 = SizeOfIPTCData(v6);
      if (v7)
      {
        v8 = v7;
        v9 = (unsigned __int8 *)malloc_type_calloc(v7, 1uLL, 0xAA7D7B25uLL);
        if (v9)
        {
          WriteIPTCData((CFDictionaryRef *)v6, v9);
          _cg_TIFFSetField(a2, 33723, v10, v11, v12, v13, v14, v15, v8);
        }
      }
      else
      {
        v9 = 0;
      }
      (*(void (**)(IIODictionary *))(*(_QWORD *)v6 + 8))(v6);
      if (v9)
        free(v9);
    }
  }
  return 0;
}

void sub_188003494(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t TIFFWritePlugin::writeXMPData(int a1, uint64_t a2, IIODictionary *this)
{
  const __CFDictionary *ObjectForKey;
  const CGImageMetadata *v6;
  const __CFData *XMPWithEXIFFiltered;
  const __CFData *v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (this)
  {
    ObjectForKey = IIODictionary::getObjectForKey(this, CFSTR("{MetaData}"));
    if (ObjectForKey)
    {
      v6 = ObjectForKey;
      CFRetain(ObjectForKey);
    }
    else
    {
      v6 = (const CGImageMetadata *)CGImageMetadataCreateFromLegacyProps(this);
    }
    XMPWithEXIFFiltered = CGImageMetadataCreateXMPWithEXIFFiltered(v6);
    v8 = XMPWithEXIFFiltered;
    if (XMPWithEXIFFiltered)
    {
      BytePtr = CFDataGetBytePtr(XMPWithEXIFFiltered);
      Length = CFDataGetLength(v8);
      if (BytePtr && Length != 0)
        _cg_TIFFSetField(a2, 700, v11, v12, v13, v14, v15, v16, Length);
    }
    if (v6)
      CFRelease(v6);
    if (v8)
      CFRelease(v8);
  }
  return 0;
}

uint64_t TIFFWritePlugin::fixScanlineForCIELab(TIFFWritePlugin *this, char *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  unint64_t v5;
  _BYTE *v6;
  _WORD *v7;

  v5 = (a5 * (unint64_t)a4) >> 3;
  if (a3 && a5 == 8)
  {
    v6 = a2 + 2;
    do
    {
      *(v6 - 1) ^= 0x80u;
      *v6 ^= 0x80u;
      v6 += v5;
      --a3;
    }
    while (a3);
  }
  else if (a3 && a5 == 16)
  {
    v7 = a2 + 4;
    do
    {
      *(v7 - 1) ^= 0x8000u;
      *v7 ^= 0x8000u;
      v7 = (_WORD *)((char *)v7 + v5);
      --a3;
    }
    while (a3);
  }
  return 0;
}

uint64_t TIFFWritePlugin::writeOneImage(TIFFWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t TIFFWritePlugin::writeOne(uint64_t a1, uint64_t a2, IIOImageReadSession **a3, IIOImagePixelDataProvider *this, IIODictionary *a5)
{
  int AlphaInfo;
  __int16 BitmapInfo;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  CGColorSpace *SourceGeomColorSpace;
  uint64_t v25;
  CGColorSpace *v26;
  unsigned __int16 NumberOfComponents;
  CGColorSpaceModel Model;
  IIOImageReadSession **v29;
  CGColorSpace *BaseColorSpace;
  size_t v31;
  size_t ColorTableCount;
  CGColorSpace *v33;
  uint64_t v34;
  const __CFDictionary *v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned __int16 v64;
  uint64_t v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  unsigned int Uint32ForKey;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  __int16 v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unsigned __int16 v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  BOOL v111;
  unsigned __int16 v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  BOOL v126;
  int v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  char v131;
  float FloatForKey;
  float v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  float FloatForKeyGroup;
  float v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  _BYTE *v183;
  _BYTE *v184;
  char *v185;
  _BYTE *v186;
  char v187;
  char v188;
  char v189;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFString *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  const char *v198;
  const __CFDictionary *v199;
  const __CFString *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  const char *v207;
  const __CFDictionary *v208;
  const __CFString *v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  const char *v216;
  const __CFDictionary *v217;
  const __CFString *v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  const char *v225;
  const __CFDictionary *v226;
  const __CFString *v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  const __CFDictionary *v235;
  const __CFString *v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  const char *v243;
  const __CFDictionary *v244;
  const __CFString *v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  const char *v252;
  const __CFDictionary *v253;
  const __CFString *v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  const char *v261;
  int v262;
  const __CFDictionary *v263;
  const __CFString *v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  const char *v271;
  _BOOL4 BoolForKey;
  CGImage *Ref;
  uint64_t RenderingIntent;
  unint64_t v275;
  char *ExifBufferFromPropertiesTIFF;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  char *v283;
  unint64_t v284;
  unint64_t *v285;
  _WORD *v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  void *v293;
  void *v294;
  int v295;
  unsigned int v296;
  unint64_t v297;
  uint64_t Bytes;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  unint64_t v303;
  char *v304;
  unsigned int v305;
  unint64_t v306;
  uint8_t *v307;
  unint64_t v308;
  char *v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  unsigned int v322;
  unsigned int v323;
  int v324;
  uint64_t v325;
  uint64_t v326;
  int v327;
  unsigned int v328;
  unsigned int v329;
  int v330;
  uint64_t v331;
  char *v332;
  unsigned int v334;
  uint8_t *v335;
  unsigned int v336;
  uint64_t v337;
  uint64_t v338;
  IIOImagePlus *v339;
  CGColorSpace *v340;
  int v341;
  char v342;
  size_t v343;
  __int16 v344;
  int v345;
  int Type;
  char *v347;
  IIOImageReadSession **v348;
  unsigned int v349;
  uint64_t v350;
  uint64_t Uint32ForKeyGroup;
  unsigned __int16 __n;
  unsigned int __na;
  size_t __n_4;
  unint64_t v356;
  unint64_t v357;
  unint64_t v358;
  unint64_t v359[129];
  _OWORD v360[32];
  uint64_t v361;

  v361 = *MEMORY[0x1E0C80C00];
  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(this);
  v339 = this;
  BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(this);
  v356 = 0;
  v357 = 0;
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    v11 = *(_DWORD *)(a1 + 32);
    v12 = v11 >> 24;
    v13 = MEMORY[0x1E0C80978];
    if (v11 < 0)
    {
      v14 = __maskrune(v12, 0x40000uLL);
      v11 = *(_DWORD *)(a1 + 32);
    }
    else
    {
      v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v11 >> 24);
    else
      v15 = 46;
    v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v11 = *(_DWORD *)(a1 + 32);
    }
    else
    {
      v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = (v11 << 8 >> 24);
    else
      v18 = 46;
    v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      v20 = __maskrune(v19, 0x40000uLL);
      v11 = *(_DWORD *)(a1 + 32);
    }
    else
    {
      v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20)
      v21 = ((__int16)v11 >> 8);
    else
      v21 = 46;
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      v22 = *(_DWORD *)(a1 + 32);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' TIFFWritePlugin::writeOne\n", v15, v18, v21, (char)v22);
      goto LABEL_26;
    }
    LOBYTE(v22) = 46;
    goto LABEL_25;
  }
LABEL_26:
  v23 = IIOImagePlus::sourceImageProvider(v339);
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(v339);
  v25 = 4294967246;
  __n_4 = v23;
  if (!v23)
    return v25;
  v26 = SourceGeomColorSpace;
  if (!SourceGeomColorSpace)
    return v25;
  v344 = BitmapInfo;
  NumberOfComponents = CGColorSpaceGetNumberOfComponents(SourceGeomColorSpace);
  Model = CGColorSpaceGetModel(v26);
  Type = CGColorSpaceGetType();
  if (Type != 7)
  {
    v340 = v26;
    if (Model != kCGColorSpaceModelRGB)
    {
      v29 = a3;
      v342 = 0;
      v335 = 0;
      ColorTableCount = 0;
      Uint32ForKeyGroup = 0;
      v34 = 0;
      goto LABEL_48;
    }
    if (IIODictionary::containsKeyGroup(a5, CFSTR("TileWidth"), CFSTR("{TIFF}")))
      Uint32ForKeyGroup = (uint64_t)IIODictionary::getUint32ForKeyGroup(a5, CFSTR("TileWidth"), CFSTR("{TIFF}"));
    else
      Uint32ForKeyGroup = 0;
    if (IIODictionary::containsKeyGroup(a5, CFSTR("TileLength"), CFSTR("{TIFF}")))
    {
      v35 = IIODictionary::getUint32ForKeyGroup(a5, CFSTR("TileLength"), CFSTR("{TIFF}"));
      v34 = (uint64_t)v35;
      v335 = 0;
      if (!(_DWORD)Uint32ForKeyGroup || !(_DWORD)v35)
      {
        v342 = 1;
        v29 = a3;
        ColorTableCount = 0;
        goto LABEL_47;
      }
      v29 = a3;
      v335 = 0;
      ColorTableCount = 0;
      v36 = ((v35 | Uint32ForKeyGroup) & 0xF) == 0;
      if (((v35 | Uint32ForKeyGroup) & 0xF) != 0)
        v37 = 256;
      else
        v37 = Uint32ForKeyGroup;
      Uint32ForKeyGroup = v37;
      if (v36)
        v34 = v35;
      else
        v34 = 256;
    }
    else
    {
      v29 = a3;
      v335 = 0;
      ColorTableCount = 0;
      v34 = 0;
    }
    v342 = 1;
LABEL_47:
    Model = kCGColorSpaceModelRGB;
    goto LABEL_48;
  }
  v29 = a3;
  BaseColorSpace = CGColorSpaceGetBaseColorSpace(v26);
  v31 = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
  ColorTableCount = CGColorSpaceGetColorTableCount(v26);
  v335 = (uint8_t *)malloc_type_malloc(ColorTableCount * v31, 0x100004077774924uLL);
  CGColorSpaceGetColorTable(v26, v335);
  v33 = CGColorSpaceGetBaseColorSpace(v26);
  CGColorSpaceGetType();
  v340 = v33;
  Model = CGColorSpaceGetModel(v33);
  Uint32ForKeyGroup = 0;
  v34 = 0;
  v342 = 1;
LABEL_48:
  v38 = IIOImageSource::count(v339);
  v39 = IIO_Reader::testHeaderSize(v339);
  v349 = v38;
  _cg_TIFFSetField(a2, 256, v40, v41, v42, v43, v44, v45, v38);
  v338 = v39;
  _cg_TIFFSetField(a2, 257, v46, v47, v48, v49, v50, v51, v39);
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("\n");
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    TIFFTAG_IMAGEWIDTH/TIFFTAG_IMAGEHEIGHT: %dx%d\n", v38, v39);
  }
  _cg_TIFFSetField(a2, 284, v52, v53, v54, v55, v56, v57, 1);
  if (AlphaInfo)
    v64 = NumberOfComponents + 1;
  else
    v64 = NumberOfComponents;
  v65 = v64;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("                   TIFFTAG_SAMPLESPERPIXEL: %d\n", v64);
  v66 = v65;
  _cg_TIFFSetField(a2, 277, v58, v59, v60, v61, v62, v63, v65);
  v73 = v349;
  v348 = v29;
  if (IIODictionary::containsKey(a5, CFSTR("Orientation")))
    Uint32ForKey = IIODictionary::getUint32ForKey(a5, CFSTR("Orientation"));
  else
    Uint32ForKey = 1;
  if (Uint32ForKey - 9 < 0xFFFFFFF8)
    v75 = 1;
  else
    v75 = Uint32ForKey;
  _cg_TIFFSetField(a2, 274, v67, v68, v69, v70, v71, v72, (unsigned __int16)v75);
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("                       TIFFTAG_ORIENTATION: %d\n", v75);
  v337 = v34;
  v358 = 0;
  v359[0] = 0;
  if (AlphaInfo)
  {
    v82 = AlphaInfo == 3 ? 2 : 1;
    LOWORD(v360[0]) = v82;
    _cg_TIFFSetField(a2, 338, v76, v77, v78, v79, v80, v81, 1);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                      TIFFTAG_EXTRASAMPLES: %d\n", LOWORD(v360[0]));
  }
  __n = _cg_GifLastError((uint64_t)v339);
  _cg_TIFFSetField(a2, 258, v83, v84, v85, v86, v87, v88, __n);
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("                     TIFFTAG_BITSPERSAMPLE: %d\n", __n);
  v95 = 3;
  if ((v344 & 0x100) != 0)
    v96 = 3;
  else
    v96 = 1;
  if ((v344 & 0x100) == 0)
    v95 = 1;
  _cg_TIFFSetField(a2, 339, v89, v90, v91, v92, v93, v94, v95);
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("                      TIFFTAG_SAMPLEFORMAT: %d\n", v96);
  if (Type == 7)
    v103 = 3;
  else
    v103 = 2;
  if ((v342 & 1) == 0)
  {
    if (Model == kCGColorSpaceModelLab)
    {
      v103 = 8;
    }
    else if (Model == kCGColorSpaceModelCMYK)
    {
      v103 = 5;
    }
    else if (Model)
    {
      v103 = 2;
    }
    else
    {
      v103 = IIOImagePixelDataProvider::getDecode(v339) == 0;
    }
  }
  _cg_TIFFSetField(a2, 262, v97, v98, v99, v100, v101, v102, v103);
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("                       TIFFTAG_PHOTOMETRIC: %d\n", v103);
  v104 = (unsigned __int16)IIODictionary::getUint32ForKeyGroup(a5, CFSTR("Compression"), CFSTR("{TIFF}"));
  if ((_DWORD)v337)
    v111 = (_DWORD)Uint32ForKeyGroup == 0;
  else
    v111 = 1;
  if (v111)
    v112 = v104;
  else
    v112 = 1;
  if (v112 > 7u)
  {
    if (v112 == 8 || v112 == 32773)
      goto LABEL_106;
LABEL_103:
    if (Model == kCGColorSpaceModelMonochrome && __n == 1 && v66 == 1)
      goto LABEL_106;
    goto LABEL_107;
  }
  if (v112 == 5)
  {
LABEL_106:
    _cg_TIFFSetField(a2, 259, v105, v106, v107, v108, v109, v110, v112);
    goto LABEL_107;
  }
  if (v112 != 7)
    goto LABEL_103;
  v112 = 1;
  if (__n == 8 && Model < kCGColorSpaceModelCMYK)
  {
    v112 = 7;
    goto LABEL_106;
  }
LABEL_107:
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("                       TIFFTAG_COMPRESSION: %d\n", v112);
  _cg_TIFFSetField(a2, 266, v105, v106, v107, v108, v109, v110, 1);
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("                         TIFFTAG_FILLORDER: %d\n", 1);
  if (__n == 8 && v112 == 5)
  {
    _cg_TIFFSetField(a2, 317, v114, v115, v116, v117, v118, v119, 2);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                         TIFFTAG_PREDICTOR: %d\n", 2);
  }
  if (_cg_TIFFScanlineSize(a2, v113, v114, v115, v116, v117, v118, v119) > __n_4)
    goto LABEL_244;
  if ((_DWORD)Uint32ForKeyGroup)
    v126 = (_DWORD)v337 == 0;
  else
    v126 = 1;
  v127 = v126;
  v345 = v127;
  if (v126)
  {
    if (__n < 2u)
    {
      if ((unsigned __int16)(v112 - 3) > 1u)
        TIFFWritePlugin::writeOne(v112, __n);
      _cg_TIFFSetField(a2, 278, v120, v121, v122, v123, v124, v125, v338);
      v131 = BYTE2(gIIODebugFlags);
      LODWORD(v130) = v338;
    }
    else
    {
      v128 = 0x20000 / __n_4;
      v129 = (0x20000 / __n_4) & 0x3FFF8;
      if (((0x20000 / __n_4) & 0x3FFF8) == 0)
        LODWORD(v129) = 8;
      if (v112 == 7)
        LODWORD(v128) = v129;
      if (v128 <= 1)
        v130 = 1;
      else
        v130 = v128;
      _cg_TIFFSetField(a2, 278, v120, v121, v122, v123, v124, v125, v130);
      v131 = BYTE2(gIIODebugFlags);
    }
    if ((v131 & 3) != 0)
      ImageIOLog("                      TIFFTAG_ROWSPERSTRIP: %d\n", v130);
  }
  if (IIODictionary::containsKey(a5, CFSTR("DPIWidth"))
    && IIODictionary::containsKey(a5, CFSTR("DPIHeight")))
  {
    FloatForKey = IIODictionary::getFloatForKey(a5, CFSTR("DPIWidth"));
    v133 = IIODictionary::getFloatForKey(a5, CFSTR("DPIHeight"));
    *(double *)&v134 = FloatForKey;
    _cg_TIFFSetField(a2, 282, v135, v136, v137, v138, v139, v140, v134);
    *(double *)&v141 = v133;
    _cg_TIFFSetField(a2, 283, v142, v143, v144, v145, v146, v147, v141);
    _cg_TIFFSetField(a2, 296, v148, v149, v150, v151, v152, v153, 2);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("   TIFFTAG_XRESOLUTION/TIFFTAG_YRESOLUTION: %g %g\n", *(double *)&v134, *(double *)&v141);
  }
  else
  {
    if (IIODictionary::containsKeyGroup(a5, CFSTR("ResolutionUnit"), CFSTR("{TIFF}")))
      v166 = IIODictionary::getUint32ForKeyGroup(a5, CFSTR("ResolutionUnit"), CFSTR("{TIFF}"));
    else
      v166 = 2;
    _cg_TIFFSetField(a2, 296, v160, v161, v162, v163, v164, v165, v166);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                    TIFFTAG_RESOLUTIONUNIT: %d\n", v166);
    if (IIODictionary::containsKeyGroup(a5, CFSTR("DPIWidth"), CFSTR("{TIFF}")))
    {
      if (IIODictionary::containsKeyGroup(a5, CFSTR("DPIHeight"), CFSTR("{TIFF}")))
      {
        FloatForKeyGroup = IIODictionary::getFloatForKeyGroup(a5, CFSTR("DPIWidth"), CFSTR("{TIFF}"));
        v168 = IIODictionary::getFloatForKeyGroup(a5, CFSTR("DPIHeight"), CFSTR("{TIFF}"));
        *(double *)&v169 = FloatForKeyGroup;
        _cg_TIFFSetField(a2, 282, v170, v171, v172, v173, v174, v175, v169);
        *(double *)&v176 = v168;
        _cg_TIFFSetField(a2, 283, v177, v178, v179, v180, v181, v182, v176);
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("   TIFFTAG_XRESOLUTION/TIFFTAG_YRESOLUTION: %d %d\n", v169, v176);
      }
    }
  }
  if (Type == 7)
  {
    if (ColorTableCount > 0x100 || (1 << *(_WORD *)(a2 + 116)) > 0x100)
    {
      _cg_jpeg_mem_term("writeOne", 538, "bitsPerSample: %d  colorTableCount: %d\n", *(unsigned __int16 *)(a2 + 116), ColorTableCount);
      goto LABEL_244;
    }
    memset(v360, 0, sizeof(v360));
    memset(&v359[1], 0, 1024);
    if (ColorTableCount)
    {
      v183 = (char *)&v359[1] + 1;
      v184 = (char *)&v359[65] + 1;
      v185 = (char *)(v335 + 2);
      v186 = (char *)v360 + 1;
      do
      {
        v187 = *(v185 - 2);
        *v186 = v187;
        *(v186 - 1) = v187;
        v188 = *(v185 - 1);
        *v184 = v188;
        *(v184 - 1) = v188;
        v189 = *v185;
        v185 += 3;
        *v183 = v189;
        *(v183 - 1) = v189;
        v183 += 2;
        v184 += 2;
        v186 += 2;
        --ColorTableCount;
      }
      while (ColorTableCount);
    }
    _cg_TIFFSetField(a2, 320, v154, v155, v156, v157, v158, v159, (uint64_t)v360);
  }
  if (IIODictionary::containsKeyGroup(a5, CFSTR("DocumentName"), CFSTR("{TIFF}")))
  {
    ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(a5, CFSTR("DocumentName"), CFSTR("{TIFF}"));
    IIOString::IIOString((IIOString *)v360, ObjectForKeyGroup);
    v191 = IIOString::utf8String((IIOString *)v360);
    _cg_TIFFSetField(a2, 269, v192, v193, v194, v195, v196, v197, (uint64_t)v191);
    IIOString::~IIOString((IIOString *)v360);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v360, ObjectForKeyGroup);
      v198 = (const char *)IIOString::utf8String((IIOString *)v360);
      ImageIOLog("                      TIFFTAG_DOCUMENTNAME: %s\n", v198);
      IIOString::~IIOString((IIOString *)v360);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, CFSTR("ImageDescription"), CFSTR("{TIFF}")))
  {
    v199 = IIODictionary::getObjectForKeyGroup(a5, CFSTR("ImageDescription"), CFSTR("{TIFF}"));
    IIOString::IIOString((IIOString *)v360, v199);
    v200 = IIOString::utf8String((IIOString *)v360);
    _cg_TIFFSetField(a2, 270, v201, v202, v203, v204, v205, v206, (uint64_t)v200);
    IIOString::~IIOString((IIOString *)v360);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v360, v199);
      v207 = (const char *)IIOString::utf8String((IIOString *)v360);
      ImageIOLog("                  TIFFTAG_IMAGEDESCRIPTION: %s\n", v207);
      IIOString::~IIOString((IIOString *)v360);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, CFSTR("Make"), CFSTR("{TIFF}")))
  {
    v208 = IIODictionary::getObjectForKeyGroup(a5, CFSTR("Make"), CFSTR("{TIFF}"));
    IIOString::IIOString((IIOString *)v360, v208);
    v209 = IIOString::utf8String((IIOString *)v360);
    _cg_TIFFSetField(a2, 271, v210, v211, v212, v213, v214, v215, (uint64_t)v209);
    IIOString::~IIOString((IIOString *)v360);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v360, v208);
      v216 = (const char *)IIOString::utf8String((IIOString *)v360);
      ImageIOLog("                              TIFFTAG_MAKE: %s\n", v216);
      IIOString::~IIOString((IIOString *)v360);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, CFSTR("Model"), CFSTR("{TIFF}")))
  {
    v217 = IIODictionary::getObjectForKeyGroup(a5, CFSTR("Model"), CFSTR("{TIFF}"));
    IIOString::IIOString((IIOString *)v360, v217);
    v218 = IIOString::utf8String((IIOString *)v360);
    _cg_TIFFSetField(a2, 272, v219, v220, v221, v222, v223, v224, (uint64_t)v218);
    IIOString::~IIOString((IIOString *)v360);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v360, v217);
      v225 = (const char *)IIOString::utf8String((IIOString *)v360);
      ImageIOLog("                             TIFFTAG_MODEL: %s\n", v225);
      IIOString::~IIOString((IIOString *)v360);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, CFSTR("Software"), CFSTR("{TIFF}")))
  {
    v226 = IIODictionary::getObjectForKeyGroup(a5, CFSTR("Software"), CFSTR("{TIFF}"));
    IIOString::IIOString((IIOString *)v360, v226);
    v227 = IIOString::utf8String((IIOString *)v360);
    _cg_TIFFSetField(a2, 305, v228, v229, v230, v231, v232, v233, (uint64_t)v227);
    IIOString::~IIOString((IIOString *)v360);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v360, v226);
      v234 = (const char *)IIOString::utf8String((IIOString *)v360);
      ImageIOLog("                          TIFFTAG_SOFTWARE: %s\n", v234);
      IIOString::~IIOString((IIOString *)v360);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, CFSTR("Artist"), CFSTR("{TIFF}")))
  {
    v235 = IIODictionary::getObjectForKeyGroup(a5, CFSTR("Artist"), CFSTR("{TIFF}"));
    IIOString::IIOString((IIOString *)v360, v235);
    v236 = IIOString::utf8String((IIOString *)v360);
    _cg_TIFFSetField(a2, 315, v237, v238, v239, v240, v241, v242, (uint64_t)v236);
    IIOString::~IIOString((IIOString *)v360);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v360, v235);
      v243 = (const char *)IIOString::utf8String((IIOString *)v360);
      ImageIOLog("                            TIFFTAG_ARTIST: %s\n", v243);
      IIOString::~IIOString((IIOString *)v360);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, CFSTR("HostComputer"), CFSTR("{TIFF}")))
  {
    v244 = IIODictionary::getObjectForKeyGroup(a5, CFSTR("HostComputer"), CFSTR("{TIFF}"));
    IIOString::IIOString((IIOString *)v360, v244);
    v245 = IIOString::utf8String((IIOString *)v360);
    _cg_TIFFSetField(a2, 316, v246, v247, v248, v249, v250, v251, (uint64_t)v245);
    IIOString::~IIOString((IIOString *)v360);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v360, v244);
      v252 = (const char *)IIOString::utf8String((IIOString *)v360);
      ImageIOLog("                      TIFFTAG_HOSTCOMPUTER: %s\n", v252);
      IIOString::~IIOString((IIOString *)v360);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, CFSTR("Copyright"), CFSTR("{TIFF}")))
  {
    v253 = IIODictionary::getObjectForKeyGroup(a5, CFSTR("Copyright"), CFSTR("{TIFF}"));
    IIOString::IIOString((IIOString *)v360, v253);
    v254 = IIOString::utf8String((IIOString *)v360);
    _cg_TIFFSetField(a2, 33432, v255, v256, v257, v258, v259, v260, (uint64_t)v254);
    IIOString::~IIOString((IIOString *)v360);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v360, v253);
      v261 = (const char *)IIOString::utf8String((IIOString *)v360);
      ImageIOLog("                         TIFFTAG_COPYRIGHT: %s\n", v261);
      IIOString::~IIOString((IIOString *)v360);
    }
  }
  v262 = IIODictionary::containsKeyGroup(a5, CFSTR("DateTime"), CFSTR("{TIFF}"));
  if (v262)
  {
    v263 = IIODictionary::getObjectForKeyGroup(a5, CFSTR("DateTime"), CFSTR("{TIFF}"));
    IIOString::IIOString((IIOString *)v360, v263);
    v264 = IIOString::utf8String((IIOString *)v360);
    _cg_TIFFSetField(a2, 306, v265, v266, v267, v268, v269, v270, (uint64_t)v264);
    IIOString::~IIOString((IIOString *)v360);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v360, v263);
      v271 = (const char *)IIOString::utf8String((IIOString *)v360);
      ImageIOLog("                          TIFFTAG_DATETIME: %s\n", v271);
      IIOString::~IIOString((IIOString *)v360);
    }
  }
  TIFFWritePlugin::writeIPTCData(v262, a2, a5);
  BoolForKey = IIODictionary::getBoolForKey(a5, CFSTR("kCGImageMetadataShouldExcludeXMP"));
  if (!BoolForKey)
    TIFFWritePlugin::writeXMPData(BoolForKey, a2, a5);
  Ref = (CGImage *)IIOImageSource::imageReadRef(v339);
  RenderingIntent = CGImageGetRenderingIntent(Ref);
  TIFFWritePlugin::writeICCData(RenderingIntent, a2, v340, RenderingIntent);
  v275 = myTIFFSeekProc(v29, 0, 2);
  v359[0] = 0;
  ExifBufferFromPropertiesTIFF = CreateExifBufferFromPropertiesTIFF(a5, v349, v338, v275, v359);
  if (v359[0])
  {
    v283 = ExifBufferFromPropertiesTIFF;
    if (ExifBufferFromPropertiesTIFF)
    {
      if (_cg_TIFFSetField(a2, 34665, v277, v278, v279, v280, v281, v282, v275))
        myTIFFWriteProc(v348, v283, v359[0]);
      free(v283);
    }
  }
  v284 = myTIFFSeekProc(v348, 0, 2);
  v358 = 0;
  v286 = CreateGPSBufferFromPropertiesTIFF(a5, v349, v338, v284, &v358, v285);
  if (v358)
  {
    v293 = v286;
    if (v286)
    {
      if (_cg_TIFFSetField(a2, 34853, v287, v288, v289, v290, v291, v292, v284))
        myTIFFWriteProc(v348, v293, v358);
      free(v293);
    }
  }
  if (v345)
  {
    v294 = IIOImagePixelDataProvider::createEncodingTempBuffer(v339, &v357, &v356);
    v295 = v338;
    if ((_DWORD)v338)
    {
      v296 = 0;
      v297 = v357;
      while (1)
      {
        if (v297 + v296 > v338)
        {
          v356 = __n_4 * (v295 - v296);
          v357 = v295 - v296;
        }
        Bytes = IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v339, v294);
        if (Bytes != v356)
        {
          _cg_jpeg_mem_term("writeOne", 703, "CGImagePixelDataProviderGetBytes returned: %ld - expected: %ld\n", Bytes, v356);
          v295 = v338;
          goto LABEL_214;
        }
        v297 = v357;
        if (v357)
          break;
LABEL_208:
        v296 += v297;
        v295 = v338;
        if (v296 >= v338)
          goto LABEL_214;
      }
      v303 = 0;
      v304 = (char *)v294;
      while (1)
      {
        if ((_DWORD)v103 == 8)
          TIFFWritePlugin::fixScanlineForCIELab((TIFFWritePlugin *)Bytes, v304, v349, v66, __n);
        Bytes = _cg_TIFFWriteScanline(a2, (uint64_t)v304, v296 + v303, 0, v299, v300, v301, v302);
        if ((Bytes & 0x80000000) != 0)
          goto LABEL_245;
        ++v303;
        v304 += __n_4;
        v297 = v357;
        if (v357 <= v303)
          goto LABEL_208;
      }
    }
    v296 = 0;
LABEL_214:
    if (v296 != v295 || !_cg_TIFFWriteDirectory(a2))
    {
LABEL_245:
      v25 = 4294967246;
      v307 = v335;
      goto LABEL_246;
    }
    goto LABEL_241;
  }
  v305 = (__n + 7) >> 3;
  v341 = v305 * v66;
  v306 = Uint32ForKeyGroup * (unint64_t)(v305 * v66);
  v307 = v335;
  if ((v306 & 0xFFFFFFFF00000000) == 0)
  {
    v308 = v306 * (unint64_t)v337;
    if ((v308 & 0xFFFFFFFF00000000) == 0)
    {
      v334 = Uint32ForKeyGroup * v305 * v66;
      v356 = (__n_4 * v337);
      if (((__n_4 * (unint64_t)v337) & 0xFFFFFFFF00000000) == 0)
      {
        v343 = v308;
        v309 = (char *)malloc_type_malloc(v308, 0xD29E41A2uLL);
        v347 = (char *)malloc_type_malloc((__n_4 * v337), 0xB8721C3uLL);
        _cg_TIFFSetField(a2, 322, v310, v311, v312, v313, v314, v315, Uint32ForKeyGroup);
        _cg_TIFFSetField(a2, 323, v316, v317, v318, v319, v320, v321, v337);
        v322 = v338;
        if ((_DWORD)v338)
        {
          v323 = 0;
          v324 = Uint32ForKeyGroup * v305 * v66;
          LODWORD(v350) = v337;
          do
          {
            v336 = v323 + v337;
            if (v323 + v337 > v322)
            {
              v350 = v322 - v323;
              v356 = __n_4 * v350;
              bzero(v309, v343);
            }
            IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v339, v347);
            if (v73)
            {
              v327 = 0;
              v328 = 0;
              __na = v334;
              do
              {
                v329 = v328 + Uint32ForKeyGroup;
                if (v328 + Uint32ForKeyGroup > v73)
                {
                  __na = (v73 - v328) * v341;
                  bzero(v309, v343);
                }
                if ((_DWORD)v350)
                {
                  v330 = 0;
                  v331 = v350;
                  v332 = &v347[v327];
                  do
                  {
                    memcpy(&v309[v330], v332, __na);
                    v330 += v324;
                    v332 += __n_4;
                    --v331;
                  }
                  while (v331);
                }
                v73 = v349;
                if (_cg_TIFFWriteTile(a2, (unsigned __int8 *)v309, v328, v323, 0, 0, v325, v326) == -1)
                  LogError("writeOne", 792, "*** TIFFWriteTile returned: %d\n", -1);
                v327 += v324;
                v328 += Uint32ForKeyGroup;
              }
              while (v329 < v349);
            }
            v323 += v337;
            v322 = v338;
          }
          while (v336 < v338);
        }
        if (v309)
          free(v309);
        if (v347)
          free(v347);
        v294 = 0;
        if (!_cg_TIFFWriteDirectory(a2))
          goto LABEL_245;
LABEL_241:
        v307 = v335;
        v25 = 0;
        goto LABEL_246;
      }
LABEL_244:
      v294 = 0;
      goto LABEL_245;
    }
  }
  v294 = 0;
  v25 = 4294967246;
LABEL_246:
  if (v307)
    free(v307);
  if (v294)
    free(v294);
  return v25;
}

void sub_188004C44(_Unwind_Exception *a1)
{
  IIOString::~IIOString((IIOString *)&STACK[0x4D0]);
  _Unwind_Resume(a1);
}

uint64_t TIFFWritePlugin::writeAll(IIOImageDestination **this)
{
  unsigned int ImageCount;
  unsigned int v3;
  IOTiffClientData *v4;
  uint64_t v5;
  uint64_t v6;
  IIOImagePixelDataProvider *PixelDataProviderAtIndex;
  uint64_t PropertiesAtIndex;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  IIODictionary *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;

  ImageCount = IIOWritePlugin::getImageCount(this);
  if (!ImageCount)
    return 4294967246;
  v3 = ImageCount;
  v4 = (IOTiffClientData *)operator new();
  IOTiffClientData::IOTiffClientData(v4, 0);
  *((_QWORD *)v4 + 3) = this[2];
  SetupTIFFErrorHandler();
  v5 = _cg_TIFFClientOpen("tiff data provider", "wb4", (uint64_t)v4, (uint64_t)myTIFFReadProc, (uint64_t)myTIFFWriteProc, (uint64_t)myTIFFSeekProc, (uint64_t)myTIFFCloseProc, (uint64_t)myTIFFSizeProc, (uint64_t (*)())myTIFFMapFileProc, (uint64_t (*)())myTIFFUnmapFileProc);
  if (!v5)
    return 4294967246;
  v6 = v5;
  PixelDataProviderAtIndex = (IIOImagePixelDataProvider *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
  PropertiesAtIndex = IIOWritePlugin::getPropertiesAtIndex(this, 0);
  v16 = 4294967246;
  if (PixelDataProviderAtIndex)
  {
    v12 = (IIODictionary *)PropertiesAtIndex;
    if (PropertiesAtIndex)
    {
      v17 = v3;
      v18 = 1;
      while (1)
      {
        v19 = TIFFWritePlugin::writeOne((uint64_t)this, v6, (IIOImageReadSession **)v4, PixelDataProviderAtIndex, v12);
        if ((_DWORD)v19)
        {
          v16 = v19;
          goto LABEL_14;
        }
        if (v17 == v18)
          break;
        PixelDataProviderAtIndex = (IIOImagePixelDataProvider *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v18);
        v20 = IIOWritePlugin::getPropertiesAtIndex(this, v18);
        v16 = 0;
        if (PixelDataProviderAtIndex)
        {
          v12 = (IIODictionary *)v20;
          ++v18;
          if (v20)
            continue;
        }
        goto LABEL_14;
      }
      v16 = 0;
    }
  }
LABEL_14:
  _cg_TIFFClose(v6, v9, v10, v11, (uint64_t)v12, v13, v14, v15);
  return v16;
}

void sub_188004E20(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40F2E54FF0);
  _Unwind_Resume(a1);
}

uint64_t TIFFWritePlugin::writeOne(TIFFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

void IIO_ReaderHandler::~IIO_ReaderHandler(IIO_ReaderHandler *this)
{
  void **v1;
  void **v2;

  *(_QWORD *)this = off_1E1BB10D0;
  v1 = (void **)((char *)this + 16);
  std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::~__hash_table((uint64_t)this + 40);
  v2 = v1;
  std::vector<std::unique_ptr<IIO_Reader>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

{
  void **v2;
  void **v3;

  *(_QWORD *)this = off_1E1BB10D0;
  v2 = (void **)((char *)this + 16);
  std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::~__hash_table((uint64_t)this + 40);
  v3 = v2;
  std::vector<std::unique_ptr<IIO_Reader>>::__destroy_vector::operator()[abi:ne180100](&v3);
  MEMORY[0x18D761C30](this, 0x10A1C40EEBF52FBLL);
}

CFMutableArrayRef IIO_ReaderHandler::copyTypeExtensions(IIO_ReaderHandler *this, const __CFString *a2)
{
  CFMutableArrayRef Mutable;
  IIO_Reader **v5;
  IIO_Reader **v6;
  CFComparisonResult v7;
  const __CFString *v8;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v5 = (IIO_Reader **)*((_QWORD *)this + 2);
  v6 = (IIO_Reader **)*((_QWORD *)this + 3);
  if (v5 != v6)
  {
    while (1)
    {
      if (!a2)
        goto LABEL_5;
      v7 = CFStringCompare(a2, CFSTR("public.camera-raw-image"), 0);
      v8 = (const __CFString *)IIO_Reader::utType(*v5);
      if (v7 == kCFCompareEqualTo)
        break;
      if (CFStringCompare(v8, a2, 0) == kCFCompareEqualTo)
        goto LABEL_5;
LABEL_6:
      if (++v5 == v6)
        return Mutable;
    }
    if (!CFStringHasSuffix(v8, CFSTR("raw-image")))
      goto LABEL_6;
LABEL_5:
    (*(void (**)(IIO_Reader *, CFMutableArrayRef))(*(_QWORD *)*v5 + 136))(*v5, Mutable);
    goto LABEL_6;
  }
  return Mutable;
}

IIO_Reader *IIO_ReaderHandler::readerForUTTypeAndOSType(IIO_ReaderHandler *this, const __CFString *a2, int a3)
{
  IIO_Reader **v3;
  IIO_Reader **v4;
  const __CFString *v7;

  v3 = (IIO_Reader **)*((_QWORD *)this + 2);
  v4 = (IIO_Reader **)*((_QWORD *)this + 3);
  if (v3 == v4)
    return 0;
  while (1)
  {
    v7 = (const __CFString *)IIO_Reader::utType(*v3);
    if (CFStringCompare(v7, a2, 0) == kCFCompareEqualTo && IIO_Reader::osType(*v3) == a3)
      break;
    if (++v3 == v4)
      return 0;
  }
  return *v3;
}

const __CFString *IIO_ReaderHandler::typeForPathExtension(IIO_ReaderHandler *this, CFStringRef theString)
{
  IIO_Reader **v3;
  IIO_Reader **v4;
  __int128 v6;
  char v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = xmmword_18822ABA2;
  v7 = 0;
  if (!theString || !CFStringGetCString(theString, (char *)&v6 + 1, 15, 0x600u))
    return 0;
  if (strcasecmp((const char *)&v6, ".tif"))
  {
    v4 = (IIO_Reader **)*((_QWORD *)this + 2);
    v3 = (IIO_Reader **)*((_QWORD *)this + 3);
    while (v4 != v3)
    {
      if ((*(unsigned int (**)(IIO_Reader *, __int128 *))(*(_QWORD *)*v4 + 144))(*v4, &v6))
        return (const __CFString *)IIO_Reader::utType(*v4);
      ++v4;
    }
    return 0;
  }
  if (IIO_ReaderHandler::readerForUTType(this, CFSTR("public.tiff")))
    return CFSTR("public.tiff");
  else
    return 0;
}

IIO_Reader *IIO_ReaderHandler::typeFromDataAtPath(IIO_ReaderHandler *a1, const __CFString *a2, const __CFString *a3, unsigned int a4)
{
  size_t v8;
  void *v9;
  void *v10;
  int v11;
  int v12;
  ssize_t v13;
  unint64_t v14;
  const __CFURL *v15;
  const __CFURL *v16;
  const __CFString *v17;
  const __CFString *v18;
  IIO_Reader *v19;
  char v21[1024];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    LogError("typeFromDataAtPath", 548, "*** ERROR: path parameter is nil\n");
    return 0;
  }
  bzero(v21, 0x400uLL);
  v8 = *((_QWORD *)a1 + 1);
  v9 = malloc_type_malloc(v8, 0x46177AEEuLL);
  if (!v9)
    return 0;
  v10 = v9;
  if (!_CFStringGetFileSystemRepresentation())
    goto LABEL_15;
  v11 = open(v21, 0, 0);
  v12 = v11;
  if ((gIIODebugFlags & 0x200000000000) != 0)
    ImageIOLog(">>> %s: opening file [%d] '%s'\n", "typeFromDataAtPath", v11, v21);
  if (v12 < 0)
  {
LABEL_15:
    v19 = 0;
  }
  else
  {
    v13 = pread(v12, v10, v8, 0);
    if (v13 < 1)
    {
      v19 = 0;
    }
    else
    {
      v14 = v13;
      if (!a3 && (a4 & 2) != 0)
      {
        v15 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, kCFURLPOSIXPathStyle, 0);
        if (v15)
        {
          v16 = v15;
          v17 = CFURLCopyPathExtension(v15);
          if (v17)
          {
            v18 = v17;
            a3 = IIO_ReaderHandler::typeForPathExtension(a1, v17);
            CFRelease(v18);
          }
          else
          {
            a3 = 0;
          }
          CFRelease(v16);
        }
        else
        {
          a3 = 0;
        }
      }
      v19 = IIO_ReaderHandler::typeForBytes((IIO_Reader ***)a1, (uint64_t)v10, v14, a3, a4);
    }
    if ((gIIODebugFlags & 0x200000000000) != 0)
      ImageIOLog("<<< %s: closing file [%d] '%s'\n", "typeFromDataAtPath", v12, v21);
    close(v12);
  }
  free(v10);
  return v19;
}

IIO_Reader *IIO_ReaderHandler::typeFromURL(IIO_ReaderHandler *a1, const void *a2, const __CFString *a3, unsigned int a4)
{
  CFTypeID v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  IIO_Reader *v12;
  CGDataProviderRef v13;
  CGDataProvider *v14;

  if (!a2)
  {
    LogError("typeFromURL", 612, "*** Error: url parameter is nil\n");
    return 0;
  }
  v8 = CFURLGetTypeID();
  if (v8 != CFGetTypeID(a2))
  {
    LogError("typeFromURL", 613, "*** Error: url parameter is not a CFURLRef\n");
    return 0;
  }
  v9 = CFURLCopyPathExtension((CFURLRef)a2);
  if (!a3)
    a3 = IIO_ReaderHandler::typeForPathExtension(a1, v9);
  v10 = IIO_CFURLCopyResolvedFileSystemPath((const __CFURL *)a2);
  if (v10)
  {
    v11 = v10;
    v12 = IIO_ReaderHandler::typeFromDataAtPath(a1, v10, a3, a4);
    CFRelease(v11);
    if (!v9)
      return v12;
    goto LABEL_12;
  }
  v13 = CGDataProviderCreateWithURL((CFURLRef)a2);
  if (v13)
  {
    v14 = v13;
    v12 = IIO_ReaderHandler::typeForDataProvider((uint64_t)a1, (uint64_t)v13, 0, a4, 0);
    CGDataProviderRelease(v14);
    if (!v9)
      return v12;
    goto LABEL_12;
  }
  v12 = 0;
  if (v9)
LABEL_12:
    CFRelease(v9);
  return v12;
}

IIO_Reader *IIO_ReaderHandler::typeForDataProvider(uint64_t a1, uint64_t a2, const __CFString *a3, unsigned int a4, BOOL *a5)
{
  size_t v9;
  void *v10;
  void *v11;
  unint64_t BytesAtPosition;
  IIO_Reader *v13;

  if (!a2)
  {
    LogError("typeForDataProvider", 675, "*** ERROR: provider parameter is nil\n");
    return 0;
  }
  if (a5)
    *a5 = 1;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = malloc_type_malloc(v9, 0x953E8722uLL);
  if (!v10)
    return 0;
  v11 = v10;
  BytesAtPosition = CGDataProviderGetBytesAtPosition();
  if (a5)
    *a5 = BytesAtPosition < v9;
  v13 = IIO_ReaderHandler::typeForBytes((IIO_Reader ***)a1, (uint64_t)v11, BytesAtPosition, a3, a4);
  free(v11);
  return v13;
}

void ___ZN17IIO_ReaderHandler18copySupportedTypesEv_block_invoke(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
      IIOArray::addObject(*(CFMutableArrayRef **)(a1 + 32), cf);
  }
}

void ___ZN17IIO_ReaderHandler15buildPluginListEv_block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  _QWORD *v3;
  IIOReader_RawCamera *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  __int128 v19;
  char *v20;
  _QWORD v21[3];
  uint64_t v22;
  __int128 v23;
  char *v24;
  _QWORD *v25;

  v3 = *(_QWORD **)(a1 + 40);
  memset(v21, 0, sizeof(v21));
  IIODictionary::IIODictionary((IIODictionary *)v21, a2);
  if (IIODictionary::getBoolForKey((IIODictionary *)v21, CFSTR("IsPreTiff")))
  {
    v4 = (IIOReader_RawCamera *)operator new();
    IIOReader_RawCamera::IIOReader_RawCamera(v4, (IIODictionary *)v21);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v6 = *(_QWORD *)(v5 + 24);
    if (v6)
    {
      v7 = v3[4];
      v8 = (_QWORD *)v3[3];
      if ((unint64_t)v8 >= v7)
      {
        v10 = (_QWORD *)v3[2];
        v11 = v8 - v10;
        if ((unint64_t)(v11 + 1) >> 61)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v12 = v7 - (_QWORD)v10;
        v13 = (uint64_t)(v7 - (_QWORD)v10) >> 2;
        if (v13 <= v11 + 1)
          v13 = v11 + 1;
        if (v12 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v13;
        v25 = v3 + 4;
        if (v14)
        {
          v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(v3 + 4), v14);
          v10 = (_QWORD *)v3[2];
          v8 = (_QWORD *)v3[3];
          v6 = *(_QWORD *)(v5 + 24);
        }
        else
        {
          v15 = 0;
        }
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        v24 = v17;
        *(_QWORD *)v16 = v6;
        *((_QWORD *)&v23 + 1) = v16 + 8;
        if (v8 == v10)
        {
          v9 = v16 + 8;
        }
        else
        {
          do
          {
            v18 = *--v8;
            *v8 = 0;
            *((_QWORD *)v16 - 1) = v18;
            v16 -= 8;
          }
          while (v8 != v10);
          v9 = (_QWORD *)*((_QWORD *)&v23 + 1);
          v17 = v24;
        }
        v19 = *((_OWORD *)v3 + 1);
        v3[2] = v16;
        v3[3] = v9;
        v23 = v19;
        v20 = (char *)v3[4];
        v3[4] = v17;
        v24 = v20;
        v22 = v19;
        std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)&v22);
      }
      else
      {
        *v8 = v6;
        v9 = v8 + 1;
      }
      v3[3] = v9;
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)v21);
}

void sub_188005758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  MEMORY[0x18D761C30](v9, 0x10F1C409D307853);
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  _Unwind_Resume(a1);
}

uint64_t IIO_ReaderHandler::disableRAWPlugins(IIO_ReaderHandler *this)
{
  uint64_t *v1;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = (uint64_t *)*((_QWORD *)this + 2);
  if (v1 != *((uint64_t **)this + 3))
  {
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)*v1 + 152))(*v1))
      {
        std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,0>(v1 + 1, *((uint64_t **)this + 3), v1);
        v4 = v3;
        v5 = (uint64_t *)*((_QWORD *)this + 3);
        if (v5 != v3)
        {
          do
          {
            v7 = *--v5;
            v6 = v7;
            *v5 = 0;
            if (v7)
              (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
          }
          while (v5 != v4);
        }
        *((_QWORD *)this + 3) = v4;
      }
      else
      {
        ++v1;
        v4 = (uint64_t *)*((_QWORD *)this + 3);
      }
    }
    while (v1 != v4);
  }
  return 0;
}

uint64_t IIO_ReaderHandler::xpcQueueForReader(os_unfair_lock_s *this, IIO_Reader *a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  char *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  const __CFString *v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  signed int v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  dispatch_workloop_t v24;
  unint64_t v25;
  dispatch_workloop_t *v26;
  NSObject *v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  void **v33;
  void **v34;
  uint64_t (*v35)(_QWORD);
  unint64_t v36;
  uint64_t v37;
  IIO_Reader *v39;
  void **v40[5];
  char __str[16];
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v39 = a2;
  if (IIO_ReaderHandler::xpcQueueForReader(IIO_Reader *)::poolSizeCheck != -1)
    dispatch_once(&IIO_ReaderHandler::xpcQueueForReader(IIO_Reader *)::poolSizeCheck, &__block_literal_global_52);
  v3 = this + 20;
  os_unfair_lock_lock(this + 20);
  v4 = this + 10;
  v5 = (char *)std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::find<IIO_Reader *>(&this[10]._os_unfair_lock_opaque, &v39);
  if (!v5)
  {
    *(_OWORD *)__str = 0u;
    v42 = 0u;
    v5 = std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__emplace_unique_key_args<IIO_Reader *,IIO_Reader *&,IIO_ReaderHandler::QueuePool>((uint64_t)v4, &v39, (uint64_t *)&v39, (__int128 *)__str);
    v40[0] = (void **)__str;
    std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destroy_vector::operator()[abi:ne180100](v40);
  }
  v6 = *((_QWORD *)v5 + 3);
  v7 = v5 + 24;
  v8 = (*((_QWORD *)v5 + 4) - v6) >> 4;
  if (v8 < IIO_ReaderHandler::xpcQueueForReader(IIO_Reader *)::gPoolSize)
  {
    bzero(__str, 0x400uLL);
    if (!v39)
    {
      snprintf(__str, 0x400uLL, "com.apple.ImageIOXPCService.General.%zu");
LABEL_30:
      v24 = dispatch_workloop_create(__str);
      v25 = *((_QWORD *)v5 + 5);
      v26 = (dispatch_workloop_t *)*((_QWORD *)v5 + 4);
      if ((unint64_t)v26 >= v25)
      {
        v29 = ((uint64_t)v26 - *v7) >> 4;
        v30 = v29 + 1;
        if ((unint64_t)(v29 + 1) >> 60)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v31 = v25 - *v7;
        if (v31 >> 3 > v30)
          v30 = v31 >> 3;
        if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF0)
          v32 = 0xFFFFFFFFFFFFFFFLL;
        else
          v32 = v30;
        v40[4] = (void **)(v5 + 40);
        if (v32)
          v33 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>>((uint64_t)(v5 + 40), v32);
        else
          v33 = 0;
        v34 = &v33[2 * v29];
        v40[0] = v33;
        v40[1] = v34;
        v40[3] = &v33[2 * v32];
        v35 = MEMORY[0x1E0C82E98];
        *v34 = v24;
        v34[1] = v35;
        v40[2] = v34 + 2;
        std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__swap_out_circular_buffer((uint64_t *)v5 + 3, v40);
        v28 = (_QWORD *)*((_QWORD *)v5 + 4);
        std::__split_buffer<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::~__split_buffer((uint64_t)v40);
      }
      else
      {
        v27 = MEMORY[0x1E0C82E98];
        *v26 = v24;
        v26[1] = v27;
        v28 = v26 + 2;
        *((_QWORD *)v5 + 4) = v26 + 2;
      }
      *((_QWORD *)v5 + 4) = v28;
      v6 = *((_QWORD *)v5 + 3);
      v8 = ((uint64_t)v28 - v6) >> 4;
      goto LABEL_43;
    }
    v9 = (const __CFString *)IIO_Reader::utType(v39);
    CFStringGetCStringPtr(v9, 0x600u);
    v10 = IIO_Reader::osType(v39);
    v11 = v10 >> 24;
    v12 = MEMORY[0x1E0C80978];
    if (v10 < 0)
      v13 = __maskrune(v11, 0x40000uLL);
    else
      v13 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v11 + 60) & 0x40000;
    if (v13)
      v14 = ((int)IIO_Reader::osType(v39) >> 24);
    else
      v14 = 46;
    v15 = IIO_Reader::osType(v39) << 8;
    v16 = v15 >> 24;
    if (v15 < 0)
      v17 = __maskrune(v16, 0x40000uLL);
    else
      v17 = *(_DWORD *)(v12 + 4 * v16 + 60) & 0x40000;
    if (v17)
      v18 = ((int)(IIO_Reader::osType(v39) << 8) >> 24);
    else
      v18 = 46;
    v19 = IIO_Reader::osType(v39);
    v20 = v19 << 16;
    v21 = (__int16)v19 >> 8;
    if (v20 < 0)
      v22 = __maskrune(v21, 0x40000uLL);
    else
      v22 = *(_DWORD *)(v12 + 4 * v21 + 60) & 0x40000;
    if (v22)
      IIO_Reader::osType(v39);
    v23 = IIO_Reader::osType(v39);
    if ((v23 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v12 + 4 * (char)v23 + 60) & 0x40000) == 0)
        goto LABEL_29;
    }
    else if (!__maskrune((char)v23, 0x40000uLL))
    {
LABEL_29:
      snprintf(__str, 0x400uLL, "com.apple.ImageIOXPCService.'%c%c%c%c'.%s%s%zu", v14, v18);
      goto LABEL_30;
    }
    IIO_Reader::osType(v39);
    goto LABEL_29;
  }
LABEL_43:
  v36 = (*((_QWORD *)v5 + 6) + 1) % v8;
  *((_QWORD *)v5 + 6) = v36;
  v37 = *(_QWORD *)(v6 + 16 * v36);
  os_unfair_lock_unlock(v3);
  return v37;
}

void sub_188005BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  std::__split_buffer<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN17IIO_ReaderHandler17xpcQueueForReaderEP10IIO_Reader_block_invoke()
{
  size_t v1;

  v1 = 4;
  return sysctlbyname("hw.activecpu", &IIO_ReaderHandler::xpcQueueForReader(IIO_Reader *)::gPoolSize, &v1, 0, 0);
}

void IIO_ReaderHandler::xpcReply(int a1, xpc_connection_t connection, xpc_object_t message, uint64_t a4)
{
  if (message)
  {
    xpc_connection_send_message(connection, message);
    xpc_release(message);
  }
  if (a4)
    (*(void (**)(uint64_t))(a4 + 16))(a4);
}

uint64_t IIO_ReaderHandler::xpcTestHeader(os_unfair_lock_s *a1, int a2, xpc_object_t original, uint64_t a4)
{
  if (!xpc_dictionary_create_reply(original))
    return (*(uint64_t (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
  xpc_retain(original);
  IIO_ReaderHandler::xpcQueueForReader(a1, 0);
  return xpc_dictionary_handoff_reply();
}

void ___ZN17IIO_ReaderHandler13xpcTestHeaderEP17_xpc_connection_sPvU13block_pointerFvPjE_block_invoke(uint64_t a1)
{
  IIO_Reader ***v2;
  xpc_object_t source_dict;
  xpc_object_t v4;
  xpc_object_t v5;
  void *v6;
  const void *data;
  BOOL v8;
  int v9;
  int *v10;
  uint64_t v11;
  const char *string;
  uint64_t uint64;
  unsigned int v14;
  size_t v15;
  const __CFString *v16;
  IIO_Reader *v17;
  const void *v18;
  uint64_t v19;
  const char *v20;
  _xpc_connection_s *v21;
  void *v22;
  _QWORD v23[6];
  _QWORD v24[3];
  _BYTE v25[16];
  const __CFString *v26;
  size_t length;
  unsigned int v28;
  int v29;

  v2 = *(IIO_Reader ****)(a1 + 40);
  source_dict = iio_xpc_get_source_dict(*(void **)(a1 + 48));
  v4 = iio_xpc_add_message_dict(*(void **)(a1 + 56));
  v5 = iio_xpc_add_source_dict(*(void **)(a1 + 56));
  v28 = 0;
  v29 = 774778414;
  length = 0;
  if (!source_dict
    || ((v6 = v5, (data = xpc_dictionary_get_data(source_dict, "iio_xpc_src_header_data", &length)) != 0)
      ? (v8 = length == 0)
      : (v8 = 1),
        v8))
  {
    iio_xpc_dictionary_set_error_code(v4, 0xFFFFFA86);
    v10 = 0;
  }
  else
  {
    v11 = (uint64_t)data;
    string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_hint_string");
    uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_file_size");
    v14 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_header_options");
    v15 = length;
    if (string)
    {
      IIOString::IIOString((IIOString *)v25, string);
      v16 = v26;
    }
    else
    {
      v16 = 0;
    }
    v17 = IIO_ReaderHandler::readerForBytesImp(v2, v11, v15, v16, uint64, v14, 0, (int *)&v28);
    if (string)
      IIOString::~IIOString((IIOString *)v25);
    if (v17)
    {
      v18 = (const void *)IIO_Reader::utType(v17);
      LODWORD(v19) = IIO_Reader::osType(v17);
      v29 = v19;
      IIOIncrementIdentifyCallCount();
      v19 = v19;
      v10 = &v29;
    }
    else
    {
      v10 = 0;
      v18 = 0;
      v19 = 774778414;
    }
    memset(v24, 0, sizeof(v24));
    IIOString::IIOString((IIOString *)v24, v18);
    if (v18)
    {
      v20 = (const char *)IIOString::utf8String((IIOString *)v24);
      xpc_dictionary_set_string(v6, "iio_xpc_src_utitype", v20);
    }
    else
    {
      xpc_dictionary_set_string(v6, "iio_xpc_src_utitype", "unknown");
    }
    xpc_dictionary_set_uint64(v6, "iio_xpc_src_ostype", v19);
    iio_xpc_dictionary_set_error_code(v4, v28);
    IIOString::~IIOString((IIOString *)v24);
  }
  v22 = *(void **)(a1 + 56);
  v21 = *(_xpc_connection_s **)(a1 + 64);
  v23[0] = MEMORY[0x1E0C809B0];
  v23[1] = 0x40000000;
  v23[2] = ___ZN17IIO_ReaderHandler13xpcTestHeaderEP17_xpc_connection_sPvU13block_pointerFvPjE_block_invoke_2;
  v23[3] = &unk_1E1BC9738;
  v23[4] = *(_QWORD *)(a1 + 32);
  v23[5] = v10;
  IIO_ReaderHandler::xpcReply(v9, v21, v22, (uint64_t)v23);
  xpc_release(*(xpc_object_t *)(a1 + 48));
}

void sub_188005FB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18)
{
  uint64_t v18;

  if (v18)
    IIOString::~IIOString((IIOString *)&a18);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN17IIO_ReaderHandler13xpcTestHeaderEP17_xpc_connection_sPvU13block_pointerFvPjE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void IIO_ReaderHandler::xpcGetImageCount(IIO_ReaderHandler *a1, _xpc_connection_s *a2, xpc_object_t original, uint64_t a4)
{
  xpc_object_t reply;
  void *v9;
  xpc_object_t source_dict;
  xpc_object_t v11;
  const char *string;
  int uint64;
  IIO_Reader *v14;
  _QWORD v15[2];
  __CFString *v16;

  reply = xpc_dictionary_create_reply(original);
  v9 = reply;
  if (reply)
  {
    source_dict = iio_xpc_get_source_dict(original);
    v11 = iio_xpc_add_message_dict(v9);
    if (source_dict)
    {
      string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
      uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
      v15[0] = 0;
      v15[1] = 0;
      v16 = 0;
      IIOString::IIOString((IIOString *)v15, string);
      v14 = IIO_ReaderHandler::readerForUTTypeAndOSType(a1, v16, uint64);
      IIOString::~IIOString((IIOString *)v15);
      if (v14)
      {
        xpc_retain(original);
        IIO_ReaderHandler::xpcQueueForReader((os_unfair_lock_s *)a1, v14);
        xpc_dictionary_handoff_reply();
        return;
      }
    }
    iio_xpc_dictionary_set_error_code(v11, 0xFFFFFA85);
  }
  IIO_ReaderHandler::xpcReply((int)reply, a2, v9, a4);
}

void sub_188006134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZN17IIO_ReaderHandler16xpcGetImageCountEP17_xpc_connection_sPvU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  unsigned int v2;
  int v3;

  v2 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72));
  iio_xpc_dictionary_set_error_code(*(void **)(a1 + 80), v2);
  IIO_ReaderHandler::xpcReply(v3, *(xpc_connection_t *)(a1 + 56), *(xpc_object_t *)(a1 + 72), *(_QWORD *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 64));
}

void IIO_ReaderHandler::xpcUpdateSourceProperties(IIO_ReaderHandler *a1, _xpc_connection_s *a2, xpc_object_t original, uint64_t a4)
{
  xpc_object_t reply;
  void *v9;
  xpc_object_t source_dict;
  xpc_object_t v11;
  const char *string;
  int uint64;
  IIO_Reader *v14;
  _QWORD v15[2];
  __CFString *v16;

  reply = xpc_dictionary_create_reply(original);
  v9 = reply;
  if (reply)
  {
    source_dict = iio_xpc_get_source_dict(original);
    v11 = iio_xpc_add_message_dict(v9);
    if (source_dict)
    {
      string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
      uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
      v15[0] = 0;
      v15[1] = 0;
      v16 = 0;
      IIOString::IIOString((IIOString *)v15, string);
      v14 = IIO_ReaderHandler::readerForUTTypeAndOSType(a1, v16, uint64);
      IIOString::~IIOString((IIOString *)v15);
      if (v14)
      {
        xpc_retain(original);
        IIO_ReaderHandler::xpcQueueForReader((os_unfair_lock_s *)a1, v14);
        xpc_dictionary_handoff_reply();
        return;
      }
    }
    iio_xpc_dictionary_set_error_code(v11, 0xFFFFFA84);
  }
  IIO_ReaderHandler::xpcReply((int)reply, a2, v9, a4);
}

void sub_1880062EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZN17IIO_ReaderHandler25xpcUpdateSourcePropertiesEP17_xpc_connection_sPvU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  unsigned int v2;
  int v3;

  v2 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 64))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72));
  iio_xpc_dictionary_set_error_code(*(void **)(a1 + 80), v2);
  IIO_ReaderHandler::xpcReply(v3, *(xpc_connection_t *)(a1 + 56), *(xpc_object_t *)(a1 + 72), *(_QWORD *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 64));
}

void IIO_ReaderHandler::xpcInitImage(IIO_ReaderHandler *a1, _xpc_connection_s *a2, xpc_object_t original, uint64_t a4)
{
  xpc_object_t reply;
  void *v9;
  xpc_object_t source_dict;
  xpc_object_t v11;
  const char *string;
  int uint64;
  IIO_Reader *v14;
  _QWORD v15[2];
  __CFString *v16;

  reply = xpc_dictionary_create_reply(original);
  v9 = reply;
  if (reply)
  {
    source_dict = iio_xpc_get_source_dict(original);
    v11 = iio_xpc_add_message_dict(v9);
    if (source_dict)
    {
      string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
      uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
      v15[0] = 0;
      v15[1] = 0;
      v16 = 0;
      IIOString::IIOString((IIOString *)v15, string);
      v14 = IIO_ReaderHandler::readerForUTTypeAndOSType(a1, v16, uint64);
      IIOString::~IIOString((IIOString *)v15);
      if (v14)
      {
        xpc_retain(original);
        IIO_ReaderHandler::xpcQueueForReader((os_unfair_lock_s *)a1, v14);
        xpc_dictionary_handoff_reply();
        return;
      }
    }
    iio_xpc_dictionary_set_error_code(v11, 0xFFFFFA83);
  }
  IIO_ReaderHandler::xpcReply((int)reply, a2, v9, a4);
}

void sub_1880064A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZN17IIO_ReaderHandler12xpcInitImageEP17_xpc_connection_sPvU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  unsigned int v2;
  int v3;

  v2 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 256))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72));
  iio_xpc_dictionary_set_error_code(*(void **)(a1 + 80), v2);
  IIO_ReaderHandler::xpcReply(v3, *(xpc_connection_t *)(a1 + 56), *(xpc_object_t *)(a1 + 72), *(_QWORD *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 64));
}

void IIO_ReaderHandler::xpcDecodeImage(IIO_ReaderHandler *a1, _xpc_connection_s *a2, xpc_object_t original, uint64_t a4)
{
  xpc_object_t reply;
  void *v9;
  xpc_object_t source_dict;
  xpc_object_t v11;
  const char *string;
  int uint64;
  IIO_Reader *v14;
  _QWORD v15[2];
  __CFString *v16;

  reply = xpc_dictionary_create_reply(original);
  v9 = reply;
  if (reply)
  {
    source_dict = iio_xpc_get_source_dict(original);
    v11 = iio_xpc_add_message_dict(v9);
    if (source_dict)
    {
      string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
      uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
      v15[0] = 0;
      v15[1] = 0;
      v16 = 0;
      IIOString::IIOString((IIOString *)v15, string);
      v14 = IIO_ReaderHandler::readerForUTTypeAndOSType(a1, v16, uint64);
      IIOString::~IIOString((IIOString *)v15);
      if (v14)
      {
        xpc_retain(original);
        IIO_ReaderHandler::xpcQueueForReader((os_unfair_lock_s *)a1, v14);
        xpc_dictionary_handoff_reply();
        return;
      }
    }
    iio_xpc_dictionary_set_error_code(v11, 0xFFFFFA80);
  }
  IIO_ReaderHandler::xpcReply((int)reply, a2, v9, a4);
}

void sub_18800665C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZN17IIO_ReaderHandler14xpcDecodeImageEP17_xpc_connection_sPvU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  unsigned int v2;
  int v3;

  v2 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 264))(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72));
  iio_xpc_dictionary_set_error_code(*(void **)(a1 + 80), v2);
  IIO_ReaderHandler::xpcReply(v3, *(xpc_connection_t *)(a1 + 56), *(xpc_object_t *)(a1 + 72), *(_QWORD *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 64));
}

void std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    operator delete(**a1);
  }
}

uint64_t std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__base_destruct_at_end[abi:ne180100](uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  v3 = result;
  v4 = *(_QWORD **)(result + 8);
  if (v4 != a2)
  {
    v5 = *(_QWORD **)(result + 8);
    do
    {
      v6 = *(v5 - 2);
      v5 -= 2;
      result = v6;
      *v5 = 0;
      if (v6)
        result = ((uint64_t (*)(void))*(v4 - 1))();
      v4 = v5;
    }
    while (v5 != a2);
  }
  *(_QWORD *)(v3 + 8) = a2;
  return result;
}

void std::vector<std::unique_ptr<IIO_Reader>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__deallocate_node(a1, *(char **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__deallocate_node(uint64_t a1, char *a2)
{
  char *v2;
  char *v3;
  void **v4;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = *(char **)v2;
      v4 = (void **)(v2 + 24);
      std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destroy_vector::operator()[abi:ne180100](&v4);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  uint64_t v6;
  uint64_t v7;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      v6 = *v4;
      *v4 = 0;
      v7 = *a3;
      *a3 = v6;
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      ++v4;
      ++a3;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

_QWORD *std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::find<IIO_Reader *>(_QWORD *a1, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

char *std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__emplace_unique_key_args<IIO_Reader *,IIO_Reader *&,IIO_ReaderHandler::QueuePool>(uint64_t a1, _QWORD *a2, uint64_t *a3, __int128 *a4)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  void **v13;
  char *v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  float v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  size_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;

  v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v12 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10)
        v12 = v9 % v10;
    }
    else
    {
      v12 = v9 & (v10 - 1);
    }
    v13 = *(void ***)(*(_QWORD *)a1 + 8 * v12);
    if (v13)
    {
      v14 = (char *)*v13;
      if (*v13)
      {
        do
        {
          v15 = *((_QWORD *)v14 + 1);
          if (v15 == v9)
          {
            if (*((_QWORD *)v14 + 2) == *a2)
              return v14;
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v15 >= v10)
                v15 %= v10;
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v12)
              break;
          }
          v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
  else
  {
    v12 = 0;
  }
  v16 = (_QWORD *)(a1 + 16);
  v14 = (char *)operator new(0x38uLL);
  v17 = *a3;
  *((_QWORD *)v14 + 1) = v9;
  *((_QWORD *)v14 + 2) = v17;
  v18 = *a4;
  *(_QWORD *)a4 = 0;
  *((_QWORD *)a4 + 1) = 0;
  v19 = *((_QWORD *)a4 + 2);
  v20 = *((_QWORD *)a4 + 3);
  *((_QWORD *)a4 + 2) = 0;
  *(_QWORD *)v14 = 0;
  *(_OWORD *)(v14 + 24) = v18;
  *((_QWORD *)v14 + 5) = v19;
  *((_QWORD *)v14 + 6) = v20;
  v21 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v22 = *(float *)(a1 + 32);
  if (!v10 || (float)(v22 * (float)v10) < v21)
  {
    v23 = 1;
    if (v10 >= 3)
      v23 = (v10 & (v10 - 1)) != 0;
    v24 = v23 | (2 * v10);
    v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25)
      v26 = v25;
    else
      v26 = v24;
    std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__rehash<true>(a1, v26);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v12 = v9 % v10;
      else
        v12 = v9;
    }
    else
    {
      v12 = (v10 - 1) & v9;
    }
  }
  v27 = *(_QWORD *)a1;
  v28 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
  if (v28)
  {
    *(_QWORD *)v14 = *v28;
LABEL_38:
    *v28 = v14;
    goto LABEL_39;
  }
  *(_QWORD *)v14 = *v16;
  *v16 = v14;
  *(_QWORD *)(v27 + 8 * v12) = v16;
  if (*(_QWORD *)v14)
  {
    v29 = *(_QWORD *)(*(_QWORD *)v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v29 >= v10)
        v29 %= v10;
    }
    else
    {
      v29 &= v10 - 1;
    }
    v28 = (_QWORD *)(*(_QWORD *)a1 + 8 * v29);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v14;
}

void sub_188006C44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void **v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  void **v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = __p + 3;
    std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  if (__p)
    operator delete(__p);
}

uint64_t std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v8 = (_QWORD *)(a7 - 16);
    do
    {
      v9 = *(a3 - 2);
      a3 -= 2;
      *a3 = 0;
      *v8 = v9;
      v8[1] = a3[1];
      *((_QWORD *)&v15 + 1) = v8;
      v7 -= 16;
      v8 -= 2;
    }
    while (a3 != a5);
    v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

uint64_t std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v9[8];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE v14[8];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v15 = v3;
  v16 = v2;
  v17 = v3;
  v18 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v10 = v7;
  v11 = v6;
  v12 = v7;
  v13 = v6;
  return std::__allocator_destroy[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>>(v4, (uint64_t)v14, (uint64_t)v9);
}

uint64_t std::__allocator_destroy[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;
  uint64_t result;

  for (i = *(_QWORD *)(a2 + 32); i != *(_QWORD *)(a3 + 32); *(_QWORD *)(a2 + 32) = i)
  {
    result = *(_QWORD *)i;
    *(_QWORD *)i = 0;
    if (result)
      result = (*(uint64_t (**)(void))(i + 8))();
    i = *(_QWORD *)(a2 + 32) + 16;
  }
  return result;
}

uint64_t std::__split_buffer<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::__split_buffer<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destruct_at_end[abi:ne180100](uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *(_QWORD *)(result + 16);
  if (v2 != a2)
  {
    v4 = result;
    do
    {
      *(_QWORD *)(v4 + 16) = v2 - 16;
      result = *(_QWORD *)(v2 - 16);
      *(_QWORD *)(v2 - 16) = 0;
      if (result)
        result = (*(uint64_t (**)(void))(v2 - 8))();
      v2 = *(_QWORD *)(v4 + 16);
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t CreateKtxStream(uint64_t a1, IIOImageReadSession *this)
{
  uint64_t result;

  if (!a1)
    return 11;
  IIOImageReadSession::setOffset((uint64_t)this, 0);
  result = 0;
  *(_QWORD *)(a1 + 64) = this;
  *(_DWORD *)(a1 + 56) = 3;
  *(_QWORD *)a1 = IIOktxStream_read;
  *(_QWORD *)(a1 + 8) = IIOktxStream_skip;
  *(_QWORD *)(a1 + 16) = IIOktxStream_write;
  *(_QWORD *)(a1 + 24) = IIOktxStream_getpos;
  *(_QWORD *)(a1 + 32) = IIOktxStream_setpos;
  *(_QWORD *)(a1 + 40) = IIOktxStream_getsize;
  *(_QWORD *)(a1 + 48) = IIOktxStream_destruct;
  *(_BYTE *)(a1 + 96) = 0;
  return result;
}

uint64_t IIOktxStream_read(uint64_t a1, _BYTE *a2, unint64_t a3)
{
  IIOImageReadSession *v3;

  if (!a1)
    return 11;
  v3 = *(IIOImageReadSession **)(a1 + 64);
  if (!v3)
    return 11;
  if (IIOImageReadSession::getBytes(v3, a2, a3) == a3)
    return 0;
  return 7;
}

uint64_t IIOktxStream_skip(uint64_t a1, unint64_t a2)
{
  IIOImageReadSession *v2;

  if (!a1)
    return 11;
  v2 = *(IIOImageReadSession **)(a1 + 64);
  if (!v2)
    return 11;
  if (IIOImageReadSession::seek(v2, a2, 1) == -1)
    return 7;
  return 0;
}

uint64_t IIOktxStream_write(uint64_t a1)
{
  if (!a1)
    return 11;
  if (*(_QWORD *)(a1 + 64))
    return 10;
  return 11;
}

uint64_t IIOktxStream_getpos(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  IIO_Reader *v5;
  uint64_t v6;

  result = 11;
  if (a1 && a2)
  {
    v5 = *(IIO_Reader **)(a1 + 64);
    if (v5)
    {
      v6 = IIO_Reader::minimumFileSize(v5);
      result = 0;
      *a2 = v6;
    }
    else
    {
      return 11;
    }
  }
  return result;
}

uint64_t IIOktxStream_setpos(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (!a1)
    return 11;
  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
    return 11;
  IIOImageReadSession::setOffset(v2, a2);
  return 0;
}

uint64_t IIOktxStream_getsize(uint64_t a1, IIOImageRead **a2)
{
  uint64_t result;
  IIOImageReadSession *v5;
  IIOImageRead *Size;

  result = 11;
  if (a1 && a2)
  {
    v5 = *(IIOImageReadSession **)(a1 + 64);
    if (v5)
    {
      Size = IIOImageReadSession::getSize(v5);
      result = 0;
      *a2 = Size;
    }
    else
    {
      return 11;
    }
  }
  return result;
}

uint64_t TIFFInitPixarLog(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  char *v68;
  uint64_t v69;
  uint64x2_t v70;
  int64x2_t v71;
  int64x2_t v72;
  float v73;
  float v74;
  unint64_t v75;
  int32x2_t v76;
  int64x2_t v77;
  float64x2_t v78;
  float *v79;
  float v80;
  float v81;
  uint64_t v82;
  double v83;
  double v84;
  double v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  int v89;
  float v90;
  uint64_t v91;
  float v92;
  BOOL v93;
  uint64_t v94;
  int v95;
  float v96;
  uint64_t v97;
  float v98;
  uint64_t result;
  char *v100;
  char v101;
  float64x2_t v102;
  long double v103;
  float64x2_t __x;

  if (a2 != 32909)
    TIFFInitPixarLog_cold_1();
  if (!_TIFFMergeFields((uint64_t)a1, pixarlogFields, 2, a4, a5, a6, a7, a8))
  {
    v100 = "Merging PixarLog codec-specific tags failed";
LABEL_43:
    TIFFErrorExtR((uint64_t)a1, "TIFFInitPixarLog", v100, v10, v11, v12, v13, v14, v101);
    return 0;
  }
  v15 = _TIFFmallocExt(a1, 336, v9, v10, v11, v12, v13, v14);
  a1[137] = v15;
  if (!v15)
  {
    v100 = "No space for PixarLog state block";
    goto LABEL_43;
  }
  v16 = v15;
  _TIFFmemset(v15, 0, 0x150uLL);
  *((_DWORD *)v16 + 54) = 0;
  a1[119] = PixarLogFixupTags;
  a1[120] = PixarLogSetupDecode;
  a1[121] = PixarLogPreDecode;
  a1[126] = PixarLogDecode;
  a1[128] = PixarLogDecode;
  a1[130] = PixarLogDecode;
  a1[122] = PixarLogSetupEncode;
  a1[124] = PixarLogPreEncode;
  a1[125] = PixarLogPostEncode;
  a1[127] = PixarLogEncode;
  a1[129] = PixarLogEncode;
  a1[131] = PixarLogEncode;
  a1[132] = PixarLogClose;
  a1[134] = PixarLogCleanup;
  v17 = a1[161];
  a1[161] = PixarLogVGetField;
  v18 = a1[160];
  v16[34] = v17;
  v16[35] = v18;
  a1[160] = PixarLogVSetField;
  v16[33] = -1;
  *((_DWORD *)v16 + 65) = 0;
  TIFFPredictorInit((uint64_t)a1, v19, v20, v21, v22, v23, v24, v25);
  LogK1 = 1132068864;
  LogK2 = 1125411269;
  v32 = (char *)_TIFFmallocExt(a1, 54600, v26, v27, v28, v29, v30, v31);
  v39 = (char *)_TIFFmallocExt(a1, 0x8000, v33, v34, v35, v36, v37, v38);
  v46 = (char *)_TIFFmallocExt(a1, 512, v40, v41, v42, v43, v44, v45);
  v53 = _TIFFmallocExt(a1, 8196, v47, v48, v49, v50, v51, v52);
  v60 = (char *)_TIFFmallocExt(a1, 4098, v54, v55, v56, v57, v58, v59);
  v67 = (char *)_TIFFmallocExt(a1, 2049, v61, v62, v63, v64, v65, v66);
  v68 = v67;
  if (v32 && v39 && v46 && v53 && v60 && v67)
  {
    v69 = 0;
    v70 = (uint64x2_t)vdupq_n_s64(0xFAuLL);
    v71 = (int64x2_t)xmmword_18820C490;
    v72 = vdupq_n_s64(2uLL);
    do
    {
      if ((vmovn_s64((int64x2_t)vcgtq_u64(v70, (uint64x2_t)v71)).u8[0] & 1) != 0)
      {
        v73 = (double)(int)(v69 * 2) * 0.0000732625556;
        *(float *)&v53[v69] = v73;
      }
      if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0xFAuLL), *(uint64x2_t *)&v71)).i32[1] & 1) != 0)
      {
        v74 = (double)((int)(v69 * 2) + 1) * 0.0000732625556;
        *((float *)&v53[v69] + 1) = v74;
      }
      ++v69;
      v71 = vaddq_s64(v71, v72);
    }
    while (v69 != 125);
    v75 = 0;
    v102 = (float64x2_t)vdupq_n_s64(0x3F70624DD2F1A9FCuLL);
    do
    {
      v76 = vadd_s32(vdup_n_s32(v75), (int32x2_t)0xFB000000FALL);
      v77.i64[0] = v76.i32[0];
      v77.i64[1] = v76.i32[1];
      __x = vmulq_f64(vcvtq_f64_s64(v77), v102);
      v103 = exp(__x.f64[1]);
      v78.f64[0] = exp(__x.f64[0]);
      if (v75 <= 0x705)
      {
        v78.f64[1] = v103;
        v79 = (float *)&v53[v75 / 2];
        v80 = 0.006737947 * v78.f64[0];
        v79[250] = v80;
        v81 = vmuld_lane_f64(0.006737947, v78, 1);
        v79[251] = v81;
      }
      v75 += 2;
    }
    while (v75 != 1798);
    v82 = 0;
    *((_DWORD *)v53 + 2048) = *((_DWORD *)v53 + 2047);
    do
    {
      v83 = *((float *)v53 + v82);
      v84 = v83 * 65535.0 + 0.5;
      if (v84 >= 65535.0)
        v84 = 65535.0;
      *(_WORD *)&v60[2 * v82] = (int)v84;
      v85 = v83 * 255.0 + 0.5;
      if (v85 >= 255.0)
        v85 = 255.0;
      v68[v82++] = (int)v85;
    }
    while (v82 != 2049);
    v86 = 0;
    v87 = 0;
    do
    {
      if ((double)(int)v86 * 0.0000732625556 * ((double)(int)v86 * 0.0000732625556) > (float)(*((float *)v53 + v87)
                                                                                             * *((float *)v53 + v87 + 1)))
        ++v87;
      *(_WORD *)&v32[2 * v86++] = v87;
    }
    while (v86 != 27300);
    v88 = 0;
    v89 = 0;
    do
    {
      v90 = *((float *)v53 + v89);
      v91 = v89 + 1;
      do
      {
        v92 = *((float *)v53 + v91++);
        v93 = (double)(int)v88 / 16383.0 * ((double)(int)v88 / 16383.0) <= (float)(v90 * v92);
        v90 = v92;
      }
      while (!v93);
      v89 = v91 - 2;
      *(_WORD *)&v39[2 * v88++] = v89;
    }
    while (v88 != 0x4000);
    v94 = 0;
    v95 = 0;
    do
    {
      v96 = *((float *)v53 + v95);
      v97 = v95 + 1;
      do
      {
        v98 = *((float *)v53 + v97++);
        v93 = (double)(int)v94 / 255.0 * ((double)(int)v94 / 255.0) <= (float)(v96 * v98);
        v96 = v98;
      }
      while (!v93);
      v95 = v97 - 2;
      *(_WORD *)&v46[2 * v94++] = v95;
    }
    while (v94 != 256);
    Fltsize = 1179994112;
    v16[36] = v53;
    v16[37] = v60;
    v16[38] = v68;
    v16[39] = v32;
    result = 1;
    v16[40] = v39;
    v16[41] = v46;
  }
  else
  {
    if (v32)
      _TIFFfreeExt((uint64_t)a1, v32);
    if (v39)
      _TIFFfreeExt((uint64_t)a1, v39);
    if (v46)
      _TIFFfreeExt((uint64_t)a1, v46);
    if (v53)
      _TIFFfreeExt((uint64_t)a1, (char *)v53);
    if (v60)
      _TIFFfreeExt((uint64_t)a1, v60);
    if (v68)
      _TIFFfreeExt((uint64_t)a1, v68);
    *((_OWORD *)v16 + 19) = 0u;
    *((_OWORD *)v16 + 20) = 0u;
    *((_OWORD *)v16 + 18) = 0u;
    return 1;
  }
  return result;
}

uint64_t PixarLogFixupTags()
{
  return 1;
}

uint64_t PixarLogSetupDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  int64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t result;
  _QWORD *v36;
  char *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;

  v8 = *(_QWORD *)(a1 + 1096);
  if (!v8)
    PixarLogSetupDecode_cold_1();
  if ((*(_BYTE *)(v8 + 260) & 1) != 0)
    return 1;
  v10 = *(_DWORD *)(a1 + 132);
  v11 = *(_DWORD *)(a1 + 92);
  if (v10 >= v11)
    v12 = v11;
  else
    v12 = v10;
  *(_QWORD *)(a1 + 1248) = _TIFFNoPostDecode;
  if (*(_WORD *)(a1 + 170) == 1)
    v13 = *(unsigned __int16 *)(a1 + 130);
  else
    v13 = 1;
  *(_WORD *)(v8 + 256) = v13;
  v14 = _TIFFMultiplySSize(0, v13, *(unsigned int *)(a1 + 88), 0, a5, a6, a7, a8);
  v19 = _TIFFMultiplySSize(0, v14, v12, 0, v15, v16, v17, v18);
  v24 = _TIFFMultiplySSize(0, v19, 2, 0, v20, v21, v22, v23);
  if ((v24 & 0x8000000000000000) != 0)
    PixarLogSetupDecode_cold_2();
  v31 = v24 + 2 * *(unsigned __int16 *)(v8 + 256);
  if (v24)
    v32 = *(unsigned __int16 *)(v8 + 256) == 0;
  else
    v32 = 1;
  if (v32 || ((2 * *(unsigned __int16 *)(v8 + 256)) ^ 0x7FFFFFFFFFFFFFFFuLL) < v24 || v31 == 0)
    return 0;
  result = (uint64_t)_TIFFmallocExt((_QWORD *)a1, v31, v25, v26, v27, v28, v29, v30);
  *(_QWORD *)(v8 + 248) = result;
  if (!result)
    return result;
  *(_QWORD *)(v8 + 240) = v31;
  v36 = (_QWORD *)(v8 + 240);
  if (*(_DWORD *)(v8 + 264) != -1
    || (v37 = (char *)result, v38 = PixarLogGuessDataFmt(a1 + 72), *(_DWORD *)(v8 + 264) = v38, v38 != -1))
  {
    if (inflateInit_((z_streamp)(v8 + 128), "1.2.12", 112))
    {
      _TIFFfreeExt(a1, *(char **)(v8 + 248));
      *v36 = 0;
      *(_QWORD *)(v8 + 248) = 0;
      v44 = *(const char **)(v8 + 176);
      if (!v44)
        v44 = "(null)";
      TIFFErrorExtR(a1, "PixarLogSetupDecode", "%s", v39, v40, v41, v42, v43, (char)v44);
      return 0;
    }
    *(_DWORD *)(v8 + 260) |= 1u;
    return 1;
  }
  _TIFFfreeExt(a1, v37);
  *v36 = 0;
  *(_QWORD *)(v8 + 248) = 0;
  TIFFErrorExtR(a1, "PixarLogSetupDecode", "PixarLog compression can't handle bits depth/data format combination (depth: %hu)", v45, v46, v47, v48, v49, *(_WORD *)(a1 + 116));
  return 0;
}

BOOL PixarLogPreDecode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  z_stream *v9;
  unint64_t v10;
  char vars0;

  v8 = a1[137];
  if (!v8)
    PixarLogPreDecode_cold_1();
  *(_QWORD *)(v8 + 128) = a1[140];
  v9 = (z_stream *)(v8 + 128);
  v10 = a1[145];
  v9->avail_in = v10;
  if (!HIDWORD(v10))
    return inflateReset(v9) == 0;
  TIFFErrorExtR((uint64_t)a1, "PixarLogPreDecode", "ZLib cannot deal with buffers this size", a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t PixarLogDecode(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  int v15;
  char *v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  int8x16_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  _BYTE *v34;
  unsigned __int16 *v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint16x4_t v41;
  char v42;
  char v43;
  char v44;
  int8x16_t v45;
  _BYTE *v46;
  unsigned int v47;
  uint64_t v48;
  int8x16_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint16x4_t v59;
  __int32 *v60;
  int8x16_t v61;
  int8x16_t v62;
  float32x4_t v63;
  __int32 *v64;
  __int32 *v65;
  unsigned int v66;
  uint64_t v67;
  float32x4_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _WORD *v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  uint16x4_t v80;
  int v81;
  int8x16_t v82;
  int8x16_t v83;
  int8x16_t v84;
  int v85;
  _DWORD *v86;
  unsigned int v87;
  uint64_t v88;
  int8x16_t v89;
  int v90;
  int v91;
  int v92;
  uint64_t v93;
  _BYTE *v94;
  unsigned __int16 *v95;
  unsigned int v96;
  int v97;
  unsigned int v98;
  __int16 v99;
  int v100;
  __int16 v101;
  BOOL v102;
  uint64_t v103;
  char v104;
  char v105;
  _BYTE *v106;
  unsigned __int16 *v107;
  unsigned int v108;
  unsigned int v109;
  __int16 v110;
  int v111;
  __int16 v112;
  uint64_t v113;
  int v114;
  int v115;
  unsigned int v116;
  uint64_t v117;
  unsigned int v118;
  unsigned __int16 *v119;
  char *v120;
  __int16 v121;
  uint64_t v122;
  uint64_t v123;
  float v124;
  uint64_t v125;
  float v126;
  uint64_t v127;
  float v128;
  float v129;
  unsigned int v130;
  char *v131;
  __int16 v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unsigned int v137;
  char *v138;
  __int16 v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  uint64_t v143;
  int v144;
  _DWORD *v145;
  int v146;
  int v147;
  int v148;
  unsigned int v149;
  __int16 v150;
  int v151;
  __int16 v152;
  const char *v154;
  char v155;

  v11 = *(_QWORD *)(a1 + 1096);
  v12 = *(_DWORD *)(v11 + 264);
  if (v12 - 2 < 3)
  {
    v13 = a3 >> 1;
  }
  else
  {
    v13 = a3;
    if (v12 >= 2)
    {
      if (v12 != 5)
      {
        TIFFErrorExtR(a1, "PixarLogDecode", "%hu bit input not supported in PixarLog", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
        goto LABEL_150;
      }
      v13 = a3 >> 2;
    }
  }
  *(_QWORD *)(v11 + 128) = *(_QWORD *)(a1 + 1152);
  v14 = *(unsigned __int16 *)(v11 + 256);
  v15 = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(v11 + 136) = *(_QWORD *)(a1 + 1160);
  *(_QWORD *)(v11 + 152) = *(_QWORD *)(v11 + 248);
  *(_DWORD *)(v11 + 160) = 2 * v13;
  if (((unint64_t)v13 >> 31))
  {
    v16 = "ZLib cannot deal with buffers this size";
  }
  else if (2 * v13 <= *(_QWORD *)(v11 + 240))
  {
    v17 = v15 * v14;
    while (1)
    {
      v18 = inflate((z_streamp)(v11 + 128), 1);
      if (v18)
        break;
      if (!*(_DWORD *)(v11 + 160))
        goto LABEL_20;
    }
    if (v18 == 1)
    {
      if (*(_DWORD *)(v11 + 160))
      {
        TIFFErrorExtR(a1, "PixarLogDecode", "Not enough data at scanline %u (short %u bytes)", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
        goto LABEL_150;
      }
LABEL_20:
      *(_QWORD *)(a1 + 1152) = *(_QWORD *)(v11 + 128);
      *(_QWORD *)(a1 + 1160) = *(unsigned int *)(v11 + 136);
      v19 = *(_QWORD *)(v11 + 248);
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabArrayOfShort(*(_QWORD *)(v11 + 248), v13);
      v20 = v13 % v17;
      if (v20)
      {
        TIFFWarningExtR(a1, "PixarLogDecode", "stride %d is not a multiple of sample count, %lld, data truncated.", a4, a5, a6, a7, a8, v17);
        v13 -= v20;
      }
      if (v13 >= 1)
      {
        v21 = 0;
        v22 = 2 * v17;
        v23 = (unsigned __int16 *)(v19 + 10);
        v24 = (unsigned __int16 *)(v19 + 14);
        v25.i64[0] = 0x700000007;
        v25.i64[1] = 0x700000007;
        v26 = (float32x4_t)vdupq_n_s32(0x453FF000u);
        v27.i64[0] = 0xFFFFLL;
        v27.i64[1] = 0xFFFFLL;
        v28.i64[0] = 0x4500000045000000;
        v28.i64[1] = 0x4500000045000000;
        while (1)
        {
          switch(*(_DWORD *)(v11 + 264))
          {
            case 0:
              v29 = *(unsigned __int16 *)(v11 + 256);
              v30 = v17;
              v31 = v17 - v29;
              if (v17 < (int)v29)
                goto LABEL_144;
              v32 = *(_QWORD *)(v11 + 304);
              if ((_DWORD)v29 == 3)
              {
                a5 = *(_WORD *)v19 & 0x7FF;
                *a2 = *(_BYTE *)(v32 + a5);
                a4 = *(_WORD *)(v19 + 2) & 0x7FF;
                a2[1] = *(_BYTE *)(v32 + a4);
                v93 = *(_WORD *)(v19 + 4) & 0x7FF;
                a2[2] = *(_BYTE *)(v32 + v93);
                v30 = v17;
                if (v17 < 4)
                  goto LABEL_144;
                v94 = a2 + 5;
                v95 = v23;
                v96 = v17 + 3;
                do
                {
                  a5 = a5 + *(v95 - 2);
                  *(v94 - 2) = *(_BYTE *)(v32 + (a5 & 0x7FF));
                  a4 = a4 + *(v95 - 1);
                  *(v94 - 1) = *(_BYTE *)(v32 + (a4 & 0x7FF));
                  v97 = *v95;
                  v95 += 3;
                  LODWORD(v93) = v93 + v97;
                  a6 = *(unsigned __int8 *)(v32 + (v93 & 0x7FF));
                  *v94 = a6;
                  v94 += 3;
                  v96 -= 3;
                }
                while (v96 > 6);
              }
              else if ((_DWORD)v29 == 4)
              {
                a6 = *(_WORD *)v19 & 0x7FF;
                *a2 = *(_BYTE *)(v32 + a6);
                a5 = *(_WORD *)(v19 + 2) & 0x7FF;
                a2[1] = *(_BYTE *)(v32 + a5);
                a4 = *(_WORD *)(v19 + 4) & 0x7FF;
                a2[2] = *(_BYTE *)(v32 + a4);
                v33 = *(_WORD *)(v19 + 6) & 0x7FF;
                a2[3] = *(_BYTE *)(v32 + v33);
                v30 = v17;
                if (v17 < 5)
                  goto LABEL_144;
                v34 = a2 + 7;
                v35 = v24;
                v36 = v17 + 4;
                do
                {
                  a6 = a6 + *(v35 - 3);
                  *(v34 - 3) = *(_BYTE *)(v32 + (a6 & 0x7FF));
                  a5 = a5 + *(v35 - 2);
                  *(v34 - 2) = *(_BYTE *)(v32 + (a5 & 0x7FF));
                  a4 = a4 + *(v35 - 1);
                  *(v34 - 1) = *(_BYTE *)(v32 + (a4 & 0x7FF));
                  v37 = *v35;
                  v35 += 4;
                  LODWORD(v33) = v33 + v37;
                  a7 = *(unsigned __int8 *)(v32 + (v33 & 0x7FF));
                  *v34 = a7;
                  v34 += 4;
                  v36 -= 4;
                }
                while (v36 > 8);
              }
              else
              {
                v98 = v29 + 1;
                a4 = (uint64_t)a2;
                a5 = v19;
                do
                {
                  v99 = *(_WORD *)a5;
                  a5 += 2;
                  a6 = *(unsigned __int8 *)(v32 + (v99 & 0x7FF));
                  *(_BYTE *)a4++ = a6;
                  --v98;
                }
                while (v98 > 1);
                v30 = v17;
                if (v31 < 1)
                  goto LABEL_144;
                do
                {
                  v100 = v29 + 1;
                  do
                  {
                    a7 = *(unsigned __int16 *)(a5 + 2 * v29);
                    *(_WORD *)(a5 + 2 * v29) = a7 + *(_WORD *)a5;
                    v101 = *(_WORD *)a5;
                    a5 += 2;
                    a6 = *(unsigned __int8 *)(v32 + (v101 & 0x7FF));
                    *(_BYTE *)a4++ = a6;
                    --v100;
                  }
                  while (v100 > 1);
                  v102 = __OFSUB__(v31, (_DWORD)v29);
                  v31 -= v29;
                }
                while (!((v31 < 0) ^ v102 | (v31 == 0)));
              }
              goto LABEL_92;
            case 1:
              v38 = *(unsigned __int16 *)(v11 + 256);
              v30 = v17;
              v39 = v17 - v38;
              if (v17 < (int)v38)
                goto LABEL_144;
              v40 = *(_QWORD *)(v11 + 304);
              if ((_DWORD)v38 == 3)
              {
                *a2 = 0;
                v103 = *(_WORD *)(v19 + 4) & 0x7FF;
                a4 = *(_WORD *)(v19 + 2) & 0x7FF;
                v104 = *(_BYTE *)(v40 + a4);
                a5 = *(_WORD *)v19 & 0x7FF;
                v105 = *(_BYTE *)(v40 + a5);
                a2[1] = *(_BYTE *)(v40 + v103);
                a2[2] = v104;
                a2[3] = v105;
                v30 = v17;
                if (v17 < 4)
                  goto LABEL_144;
                v106 = a2 + 7;
                v107 = v23;
                v108 = v17 + 3;
                do
                {
                  *(v106 - 3) = 0;
                  LODWORD(v103) = v103 + *v107;
                  a6 = *(unsigned __int8 *)(v40 + (v103 & 0x7FF));
                  a4 = a4 + *(v107 - 1);
                  a7 = *(unsigned __int8 *)(v40 + (a4 & 0x7FF));
                  a5 = a5 + *(v107 - 2);
                  a8 = *(unsigned __int8 *)(v40 + (a5 & 0x7FF));
                  *(v106 - 2) = a6;
                  *(v106 - 1) = a7;
                  *v106 = a8;
                  v106 += 4;
                  v108 -= 3;
                  v107 += 3;
                }
                while (v108 > 6);
                goto LABEL_92;
              }
              if ((_DWORD)v38 == 4)
              {
                v41.i32[0] = *(_QWORD *)v19 & 0x7FF07FF;
                v41.i16[2] = HIDWORD(*(_QWORD *)v19) & 0x7FF;
                v41.i16[3] = v41.i16[2];
                v42 = *(_BYTE *)(v40 + v41.u16[2]);
                v43 = *(_BYTE *)(v40 + v41.u16[1]);
                v44 = *(_BYTE *)(v40 + (*(_QWORD *)v19 & 0x7FFLL));
                *a2 = v42;
                a2[1] = v42;
                a2[2] = v43;
                a2[3] = v44;
                v30 = v17;
                if (v17 < 5)
                  goto LABEL_144;
                v45 = (int8x16_t)vmovl_u16(v41);
                v46 = a2 + 7;
                v47 = v17 + 4;
                v48 = 8;
                do
                {
                  v45 = (int8x16_t)vaddw_u16((uint32x4_t)v45, *(uint16x4_t *)(v19 + v48));
                  v49 = vandq_s8(v45, v25);
                  a4 = *(unsigned __int8 *)(v40 + v49.u32[2]);
                  a5 = *(unsigned __int8 *)(v40 + v49.u32[1]);
                  a6 = *(unsigned __int8 *)(v40 + v49.u32[0]);
                  *(v46 - 3) = *(_BYTE *)(v40 + v49.u32[3]);
                  *(v46 - 2) = a4;
                  *(v46 - 1) = a5;
                  *v46 = a6;
                  v46 += 4;
                  v48 += 8;
                  v47 -= 4;
                }
                while (v47 > 8);
                goto LABEL_92;
              }
              v109 = v38 + 1;
              a4 = (uint64_t)a2;
              a5 = v19;
              do
              {
                v110 = *(_WORD *)a5;
                a5 += 2;
                a6 = *(unsigned __int8 *)(v40 + (v110 & 0x7FF));
                *(_BYTE *)a4++ = a6;
                --v109;
              }
              while (v109 > 1);
              v30 = v17;
              if (v39 >= 1)
              {
                do
                {
                  v111 = v38 + 1;
                  do
                  {
                    a7 = *(unsigned __int16 *)(a5 + 2 * v38);
                    *(_WORD *)(a5 + 2 * v38) = a7 + *(_WORD *)a5;
                    v112 = *(_WORD *)a5;
                    a5 += 2;
                    a6 = *(unsigned __int8 *)(v40 + (v112 & 0x7FF));
                    *(_BYTE *)a4++ = a6;
                    --v111;
                  }
                  while (v111 > 1);
                  v102 = __OFSUB__(v39, (_DWORD)v38);
                  v39 -= v38;
                }
                while (!((v39 < 0) ^ v102 | (v39 == 0)));
LABEL_92:
                v30 = v17;
              }
LABEL_144:
              a2 += v30;
              v21 += v17;
              v19 += v22;
              v23 = (unsigned __int16 *)((char *)v23 + v22);
              v24 = (unsigned __int16 *)((char *)v24 + v22);
              if (v21 >= v13)
                return 1;
              break;
            case 2:
              v50 = *(unsigned __int16 *)(v11 + 256);
              v30 = 2 * v17;
              v51 = v17 - v50;
              if (v17 < (int)v50)
                goto LABEL_144;
              if ((_DWORD)v50 == 3)
              {
                *(_WORD *)a2 = *(_WORD *)v19;
                *((_WORD *)a2 + 1) = *(_WORD *)(v19 + 2);
                *((_WORD *)a2 + 2) = *(_WORD *)(v19 + 4);
                v30 = 2 * v17;
                if (v17 < 4)
                  goto LABEL_144;
                v113 = 0;
                v114 = *(unsigned __int16 *)(v19 + 4);
                v115 = *(unsigned __int16 *)(v19 + 2);
                v116 = v17 + 3;
                LODWORD(a4) = *(unsigned __int16 *)v19;
                do
                {
                  a6 = (uint64_t)&a2[v113 * 2 + 6];
                  a4 = a4 + v23[v113 - 2];
                  *(_WORD *)a6 = a4 & 0x7FF;
                  v115 += v23[v113 - 1];
                  a7 = v115 & 0x7FF;
                  *(_WORD *)(a6 + 2) = v115 & 0x7FF;
                  v114 += v23[v113];
                  a5 = v114 & 0x7FF;
                  *(_WORD *)(a6 + 4) = v114 & 0x7FF;
                  v116 -= 3;
                  v113 += 3;
                }
                while (v116 > 6);
              }
              else if ((_DWORD)v50 == 4)
              {
                *(_WORD *)a2 = *(_WORD *)v19;
                *((_WORD *)a2 + 1) = *(_WORD *)(v19 + 2);
                *((_WORD *)a2 + 2) = *(_WORD *)(v19 + 4);
                *((_WORD *)a2 + 3) = *(_WORD *)(v19 + 6);
                v30 = 2 * v17;
                if (v17 < 5)
                  goto LABEL_144;
                v52 = 0;
                v53 = *(unsigned __int16 *)(v19 + 6);
                v54 = *(unsigned __int16 *)(v19 + 4);
                v55 = *(unsigned __int16 *)(v19 + 2);
                LODWORD(a4) = v17 + 4;
                LODWORD(a5) = *(unsigned __int16 *)v19;
                do
                {
                  a7 = (uint64_t)&a2[v52 * 2 + 8];
                  a5 = a5 + v24[v52 - 3];
                  *(_WORD *)a7 = a5 & 0x7FF;
                  v55 += v24[v52 - 2];
                  *(_WORD *)(a7 + 2) = v55 & 0x7FF;
                  v54 += v24[v52 - 1];
                  a8 = v54 & 0x7FF;
                  *(_WORD *)(a7 + 4) = v54 & 0x7FF;
                  v53 += v24[v52];
                  a6 = v53 & 0x7FF;
                  *(_WORD *)(a7 + 6) = v53 & 0x7FF;
                  a4 = (a4 - 4);
                  v52 += 4;
                }
                while (a4 > 8);
              }
              else
              {
                v117 = 0;
                v118 = v50 + 1;
                do
                {
                  a4 = *(_WORD *)(v19 + v117) & 0x7FF;
                  *(_WORD *)&a2[v117] = a4;
                  v117 += 2;
                  --v118;
                }
                while (v118 > 1);
                v30 = 2 * v17;
                if (v51 < 1)
                  goto LABEL_144;
                v119 = (unsigned __int16 *)(v19 + v117);
                v120 = &a2[v117];
                do
                {
                  LODWORD(a4) = v50 + 1;
                  do
                  {
                    a6 = v119[v50];
                    v119[v50] = a6 + *v119;
                    v121 = *v119++;
                    a5 = v121 & 0x7FF;
                    *(_WORD *)v120 = a5;
                    v120 += 2;
                    a4 = (a4 - 1);
                  }
                  while ((int)a4 > 1);
                  v102 = __OFSUB__(v51, (_DWORD)v50);
                  v51 -= v50;
                }
                while (!((v51 < 0) ^ v102 | (v51 == 0)));
              }
              goto LABEL_131;
            case 3:
              v56 = *(unsigned __int16 *)(v11 + 256);
              v30 = 2 * v17;
              v57 = v17 - v56;
              if (v17 < (int)v56)
                goto LABEL_144;
              v58 = *(_QWORD *)(v11 + 288);
              if ((_DWORD)v56 == 3)
              {
                v122 = *(_WORD *)v19 & 0x7FF;
                v123 = *(_WORD *)(v19 + 2) & 0x7FF;
                v124 = *(float *)(v58 + 4 * v123) * 2048.0;
                v125 = *(_WORD *)(v19 + 4) & 0x7FF;
                v126 = *(float *)(v58 + 4 * v125);
                *(_WORD *)a2 = (int)fminf(*(float *)(v58 + 4 * v122) * 2048.0, 3071.0);
                *((_WORD *)a2 + 1) = (int)fminf(v124, 3071.0);
                *((_WORD *)a2 + 2) = (int)fminf(v126 * 2048.0, 3071.0);
                v30 = 2 * v17;
                if (v17 < 4)
                  goto LABEL_144;
                v127 = 0;
                a4 = (uint64_t)(a2 + 10);
                LODWORD(a5) = v17 + 3;
                do
                {
                  a7 = a4 + v127;
                  LODWORD(v122) = v122 + *(unsigned __int16 *)(v19 + v127 + 6);
                  LODWORD(v123) = v123 + *(unsigned __int16 *)(v19 + v127 + 8);
                  a8 = v123 & 0x7FF;
                  v128 = *(float *)(v58 + 4 * a8) * 2048.0;
                  LODWORD(v125) = v125 + *(unsigned __int16 *)(v19 + v127 + 10);
                  v129 = *(float *)(v58 + 4 * (v125 & 0x7FF)) * 2048.0;
                  *(_WORD *)(a7 - 4) = (int)fminf(*(float *)(v58 + 4 * (v122 & 0x7FF)) * 2048.0, 3071.0);
                  *(_WORD *)(a7 - 2) = (int)fminf(v128, 3071.0);
                  a6 = (int)fminf(v129, 3071.0);
                  *(_WORD *)a7 = a6;
                  a5 = (a5 - 3);
                  v127 += 6;
                }
                while (a5 > 6);
              }
              else if ((_DWORD)v56 == 4)
              {
                v59.i32[0] = *(_QWORD *)v19 & 0x7FF07FF;
                v59.i16[2] = HIDWORD(*(_QWORD *)v19) & 0x7FF;
                v59.i16[3] = v59.i16[2];
                v60 = (__int32 *)(v58 + 4 * v59.u16[1]);
                v61 = (int8x16_t)vmovl_u16(v59);
                v62.i64[0] = v61.u32[2];
                v62.i64[1] = v61.u32[3];
                v63 = (float32x4_t)vandq_s8(v62, v27);
                v64 = (__int32 *)(v58 + 4 * v63.i64[0]);
                v63.i32[0] = *(_DWORD *)(v58 + 4 * (*(_QWORD *)v19 & 0x7FFLL));
                v63.i32[1] = *v60;
                v65 = (__int32 *)(v58 + 4 * v63.i64[1]);
                v63.i32[2] = *v64;
                v63.i32[3] = *v65;
                *(int16x4_t *)a2 = vmovn_s32((int32x4_t)vcvtq_u32_f32(vminnmq_f32(vmulq_f32(v63, v28), v26)));
                v30 = 2 * v17;
                if (v17 < 5)
                  goto LABEL_144;
                v66 = v17 + 4;
                v67 = 8;
                do
                {
                  v61 = (int8x16_t)vaddw_u16((uint32x4_t)v61, *(uint16x4_t *)(v19 + v67));
                  v68 = (float32x4_t)vandq_s8(v61, v25);
                  a4 = v68.u32[3];
                  a5 = v58 + 4 * v68.u32[2];
                  v68.i32[0] = *(_DWORD *)(v58 + 4 * v68.u32[0]);
                  v68.i32[1] = *(_DWORD *)(v58 + 4 * v68.u32[1]);
                  v68.i32[2] = *(_DWORD *)a5;
                  v68.i32[3] = *(_DWORD *)(v58 + 4 * v68.u32[3]);
                  *(int16x4_t *)&a2[v67] = vmovn_s32((int32x4_t)vcvtq_u32_f32(vminnmq_f32(vmulq_f32(v68, v28), v26)));
                  v67 += 8;
                  v66 -= 4;
                }
                while (v66 > 8);
              }
              else
              {
                a4 = 0;
                v130 = v56 + 1;
                do
                {
                  a5 = (int)fminf(*(float *)(v58 + 4 * (*(_WORD *)(v19 + a4) & 0x7FF)) * 2048.0, 3071.0);
                  *(_WORD *)&a2[a4] = a5;
                  a4 += 2;
                  --v130;
                }
                while (v130 > 1);
                v30 = 2 * v17;
                if (v57 < 1)
                  goto LABEL_144;
                v131 = &a2[a4];
                a4 += v19;
                do
                {
                  LODWORD(a5) = v56 + 1;
                  do
                  {
                    a7 = *(unsigned __int16 *)(a4 + 2 * v56);
                    v132 = a7 + *(_WORD *)a4;
                    *(_WORD *)(a4 + 2 * v56) = v132;
                    a6 = (int)fminf(*(float *)(v58 + 4 * (v132 & 0x7FF)) * 2048.0, 3071.0);
                    *(_WORD *)v131 = a6;
                    v131 += 2;
                    a4 += 2;
                    a5 = (a5 - 1);
                  }
                  while ((int)a5 > 1);
                  v102 = __OFSUB__(v57, (_DWORD)v56);
                  v57 -= v56;
                }
                while (!((v57 < 0) ^ v102 | (v57 == 0)));
              }
              goto LABEL_131;
            case 4:
              v69 = *(unsigned __int16 *)(v11 + 256);
              v30 = 2 * v17;
              v70 = v17 - v69;
              if (v17 < (int)v69)
                goto LABEL_144;
              v71 = *(_QWORD *)(v11 + 296);
              if ((_DWORD)v69 == 3)
              {
                v133 = *(_WORD *)v19 & 0x7FF;
                *(_WORD *)a2 = *(_WORD *)(v71 + 2 * v133);
                v134 = *(_WORD *)(v19 + 2) & 0x7FF;
                *((_WORD *)a2 + 1) = *(_WORD *)(v71 + 2 * v134);
                v135 = *(_WORD *)(v19 + 4) & 0x7FF;
                *((_WORD *)a2 + 2) = *(_WORD *)(v71 + 2 * v135);
                v30 = 2 * v17;
                if (v17 < 4)
                  goto LABEL_144;
                v136 = 0;
                a4 = (uint64_t)(a2 + 10);
                LODWORD(a5) = v17 + 3;
                do
                {
                  LODWORD(v133) = v133 + *(unsigned __int16 *)(v19 + v136 + 6);
                  a8 = a4 + v136;
                  *(_WORD *)(a8 - 4) = *(_WORD *)(v71 + 2 * (v133 & 0x7FF));
                  LODWORD(v134) = v134 + *(unsigned __int16 *)(v19 + v136 + 8);
                  a7 = *(unsigned __int16 *)(v71 + 2 * (v134 & 0x7FF));
                  *(_WORD *)(a8 - 2) = a7;
                  LODWORD(v135) = v135 + *(unsigned __int16 *)(v19 + v136 + 10);
                  a6 = *(unsigned __int16 *)(v71 + 2 * (v135 & 0x7FF));
                  *(_WORD *)a8 = a6;
                  a5 = (a5 - 3);
                  v136 += 6;
                }
                while (a5 > 6);
                goto LABEL_131;
              }
              if ((_DWORD)v69 == 4)
              {
                v72 = *(_WORD *)v19 & 0x7FF;
                *(_WORD *)a2 = *(_WORD *)(v71 + 2 * v72);
                v73 = *(_WORD *)(v19 + 2) & 0x7FF;
                *((_WORD *)a2 + 1) = *(_WORD *)(v71 + 2 * v73);
                v74 = *(_WORD *)(v19 + 4) & 0x7FF;
                *((_WORD *)a2 + 2) = *(_WORD *)(v71 + 2 * v74);
                a4 = *(_WORD *)(v19 + 6) & 0x7FF;
                *((_WORD *)a2 + 3) = *(_WORD *)(v71 + 2 * a4);
                v30 = 2 * v17;
                if (v17 < 5)
                  goto LABEL_144;
                v75 = 0;
                a5 = (uint64_t)(a2 + 14);
                LODWORD(a6) = v17 + 4;
                do
                {
                  LODWORD(v72) = v72 + *(unsigned __int16 *)(v19 + v75 + 8);
                  v76 = (_WORD *)(a5 + v75);
                  *(v76 - 3) = *(_WORD *)(v71 + 2 * (v72 & 0x7FF));
                  LODWORD(v73) = v73 + *(unsigned __int16 *)(v19 + v75 + 10);
                  *(v76 - 2) = *(_WORD *)(v71 + 2 * (v73 & 0x7FF));
                  LODWORD(v74) = v74 + *(unsigned __int16 *)(v19 + v75 + 12);
                  a8 = *(unsigned __int16 *)(v71 + 2 * (v74 & 0x7FF));
                  *(v76 - 1) = a8;
                  a4 = a4 + *(unsigned __int16 *)(v19 + v75 + 14);
                  a7 = *(unsigned __int16 *)(v71 + 2 * (a4 & 0x7FF));
                  *v76 = a7;
                  a6 = (a6 - 4);
                  v75 += 8;
                }
                while (a6 > 8);
                goto LABEL_131;
              }
              a4 = 0;
              v137 = v69 + 1;
              do
              {
                a5 = *(unsigned __int16 *)(v71 + 2 * (*(_WORD *)(v19 + a4) & 0x7FF));
                *(_WORD *)&a2[a4] = a5;
                a4 += 2;
                --v137;
              }
              while (v137 > 1);
              v30 = 2 * v17;
              if (v70 >= 1)
              {
                v138 = &a2[a4];
                a4 += v19;
                do
                {
                  LODWORD(a5) = v69 + 1;
                  do
                  {
                    a7 = *(unsigned __int16 *)(a4 + 2 * v69);
                    *(_WORD *)(a4 + 2 * v69) = a7 + *(_WORD *)a4;
                    v139 = *(_WORD *)a4;
                    a4 += 2;
                    a6 = *(unsigned __int16 *)(v71 + 2 * (v139 & 0x7FF));
                    *(_WORD *)v138 = a6;
                    v138 += 2;
                    a5 = (a5 - 1);
                  }
                  while ((int)a5 > 1);
                  v102 = __OFSUB__(v70, (_DWORD)v69);
                  v70 -= v69;
                }
                while (!((v70 < 0) ^ v102 | (v70 == 0)));
LABEL_131:
                v30 = 2 * v17;
                goto LABEL_144;
              }
              goto LABEL_144;
            case 5:
              v77 = *(unsigned __int16 *)(v11 + 256);
              v30 = 4 * v17;
              v78 = v17 - v77;
              if (v17 < (int)v77)
                goto LABEL_144;
              v79 = *(_QWORD *)(v11 + 288);
              if ((_DWORD)v77 == 3)
              {
                v140 = *(_WORD *)v19 & 0x7FF;
                v141 = *(_WORD *)(v19 + 2) & 0x7FF;
                v142 = *(_DWORD *)(v79 + 4 * v141);
                v143 = *(_WORD *)(v19 + 4) & 0x7FF;
                v144 = *(_DWORD *)(v79 + 4 * v143);
                *(_DWORD *)a2 = *(_DWORD *)(v79 + 4 * v140);
                *((_DWORD *)a2 + 1) = v142;
                *((_DWORD *)a2 + 2) = v144;
                v30 = 4 * v17;
                if (v17 < 4)
                  goto LABEL_144;
                v145 = a2 + 20;
                a4 = (uint64_t)v23;
                LODWORD(a5) = v17 + 3;
                do
                {
                  LODWORD(v140) = v140 + *(unsigned __int16 *)(a4 - 4);
                  LODWORD(v141) = v141 + *(unsigned __int16 *)(a4 - 2);
                  v146 = *(_DWORD *)(v79 + 4 * (v141 & 0x7FF));
                  v147 = *(unsigned __int16 *)a4;
                  a4 += 6;
                  LODWORD(v143) = v143 + v147;
                  a6 = v143 & 0x7FF;
                  v148 = *(_DWORD *)(v79 + 4 * a6);
                  *(v145 - 2) = *(_DWORD *)(v79 + 4 * (v140 & 0x7FF));
                  *(v145 - 1) = v146;
                  *v145 = v148;
                  v145 += 3;
                  a5 = (a5 - 3);
                }
                while (a5 > 6);
                goto LABEL_143;
              }
              if ((_DWORD)v77 == 4)
              {
                v80.i32[0] = *(_QWORD *)v19 & 0x7FF07FF;
                v80.i16[2] = HIDWORD(*(_QWORD *)v19) & 0x7FF;
                v80.i16[3] = v80.i16[2];
                v81 = *(_DWORD *)(v79 + 4 * v80.u16[1]);
                v82 = (int8x16_t)vmovl_u16(v80);
                v83.i64[0] = v82.u32[2];
                v83.i64[1] = v82.u32[3];
                v84 = vandq_s8(v83, v27);
                v84.i32[0] = *(_DWORD *)(v79 + 4 * v84.i64[0]);
                v85 = *(_DWORD *)(v79 + 4 * v84.i64[1]);
                *(_DWORD *)a2 = *(_DWORD *)(v79 + 4 * (*(_QWORD *)v19 & 0x7FFLL));
                *((_DWORD *)a2 + 1) = v81;
                *((_DWORD *)a2 + 2) = v84.i32[0];
                *((_DWORD *)a2 + 3) = v85;
                v30 = 4 * v17;
                if (v17 < 5)
                  goto LABEL_144;
                v86 = a2 + 28;
                v87 = v17 + 4;
                v88 = 8;
                do
                {
                  v82 = (int8x16_t)vaddw_u16((uint32x4_t)v82, *(uint16x4_t *)(v19 + v88));
                  v89 = vandq_s8(v82, v25);
                  v90 = *(_DWORD *)(v79 + 4 * v89.u32[0]);
                  v91 = *(_DWORD *)(v79 + 4 * v89.u32[1]);
                  a4 = v89.u32[2];
                  v89.i32[0] = *(_DWORD *)(v79 + 4 * v89.u32[2]);
                  v92 = *(_DWORD *)(v79 + 4 * v89.u32[3]);
                  *(v86 - 3) = v90;
                  *(v86 - 2) = v91;
                  *(v86 - 1) = v89.i32[0];
                  *v86 = v92;
                  v88 += 8;
                  v86 += 4;
                  v87 -= 4;
                }
                while (v87 > 8);
                goto LABEL_143;
              }
              v149 = v77 + 1;
              a4 = (uint64_t)a2;
              a5 = v19;
              do
              {
                v150 = *(_WORD *)a5;
                a5 += 2;
                a6 = v150 & 0x7FF;
                *(_DWORD *)a4 = *(_DWORD *)(v79 + 4 * a6);
                a4 += 4;
                --v149;
              }
              while (v149 > 1);
              v30 = 4 * v17;
              if (v78 >= 1)
              {
                do
                {
                  v151 = v77 + 1;
                  do
                  {
                    a7 = *(unsigned __int16 *)(a5 + 2 * v77);
                    *(_WORD *)(a5 + 2 * v77) = a7 + *(_WORD *)a5;
                    v152 = *(_WORD *)a5;
                    a5 += 2;
                    a6 = v152 & 0x7FF;
                    *(_DWORD *)a4 = *(_DWORD *)(v79 + 4 * a6);
                    a4 += 4;
                    --v151;
                  }
                  while (v151 > 1);
                  v102 = __OFSUB__(v78, (_DWORD)v77);
                  v78 -= v77;
                }
                while (!((v78 < 0) ^ v102 | (v78 == 0)));
LABEL_143:
                v30 = 4 * v17;
                goto LABEL_144;
              }
              goto LABEL_144;
            default:
              TIFFErrorExtR(a1, "PixarLogDecode", "Unsupported bits/sample: %hu", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
              goto LABEL_150;
          }
        }
      }
      return 1;
    }
    if (v18 == -3)
    {
      TIFFErrorExtR(a1, "PixarLogDecode", "Decoding error at scanline %u, %s", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
      goto LABEL_150;
    }
    v154 = *(const char **)(v11 + 176);
    if (!v154)
      v154 = "(null)";
    v155 = (char)v154;
    v16 = "ZLib error: %s";
  }
  else
  {
    v16 = "sp->stream.avail_out > sp->tbuf_size";
  }
  TIFFErrorExtR(a1, "PixarLogDecode", v16, a4, a5, a6, a7, a8, v155);
LABEL_150:
  bzero(a2, a3);
  return 0;
}

uint64_t PixarLogSetupEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int v10;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;

  v8 = *(_QWORD *)(a1 + 1096);
  if (!v8)
    PixarLogSetupEncode_cold_1();
  if (*(_WORD *)(a1 + 170) == 1)
    v10 = *(unsigned __int16 *)(a1 + 130);
  else
    v10 = 1;
  *(_WORD *)(v8 + 256) = v10;
  v11 = _TIFFMultiplySSize(0, v10, *(unsigned int *)(a1 + 88), 0, a5, a6, a7, a8);
  v16 = _TIFFMultiplySSize(0, v11, *(unsigned int *)(a1 + 132), 0, v12, v13, v14, v15);
  result = _TIFFMultiplySSize(0, v16, 2, 0, v17, v18, v19, v20);
  if (result)
  {
    result = (uint64_t)_TIFFmallocExt((_QWORD *)a1, result, v22, v23, v24, v25, v26, v27);
    *(_QWORD *)(v8 + 248) = result;
    if (result)
    {
      if (*(_DWORD *)(v8 + 264) == -1 && (v28 = PixarLogGuessDataFmt(a1 + 72), *(_DWORD *)(v8 + 264) = v28, v28 == -1))
      {
        TIFFErrorExtR(a1, "PixarLogSetupEncode", "PixarLog compression can't handle %hu bit linear encodings", v29, v30, v31, v32, v33, *(_WORD *)(a1 + 116));
      }
      else
      {
        if (!deflateInit_((z_streamp)(v8 + 128), *(_DWORD *)(v8 + 268), "1.2.12", 112))
        {
          *(_DWORD *)(v8 + 260) |= 1u;
          return 1;
        }
        v39 = *(const char **)(v8 + 176);
        if (!v39)
          v39 = "(null)";
        TIFFErrorExtR(a1, "PixarLogSetupEncode", "%s", v34, v35, v36, v37, v38, (char)v39);
      }
      return 0;
    }
  }
  return result;
}

BOOL PixarLogPreEncode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  char vars0;

  v8 = a1[137];
  if (!v8)
    PixarLogPreEncode_cold_1();
  *(_QWORD *)(v8 + 152) = a1[140];
  v9 = a1[141];
  *(_DWORD *)(v8 + 160) = v9;
  if (!HIDWORD(v9))
    return deflateReset((z_streamp)(v8 + 128)) == 0;
  TIFFErrorExtR((uint64_t)a1, "PixarLogPreEncode", "ZLib cannot deal with buffers this size", a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t PixarLogPostEncode(_QWORD *a1)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t result;
  const char *v14;

  v2 = a1[137];
  *(_DWORD *)(v2 + 136) = 0;
  while (1)
  {
    v3 = deflate((z_streamp)(v2 + 128), 4);
    if (v3 > 1)
      break;
    v11 = v3;
    v12 = a1[141] - *(unsigned int *)(v2 + 160);
    if (v12)
    {
      a1[145] = v12;
      result = TIFFFlushData1((uint64_t)a1, v4, v5, v6, v7, v8, v9, v10);
      if (!(_DWORD)result)
        return result;
      *(_QWORD *)(v2 + 152) = a1[140];
      *(_DWORD *)(v2 + 160) = a1[141];
    }
    if (v11 == 1)
      return 1;
  }
  v14 = *(const char **)(v2 + 176);
  if (!v14)
    v14 = "(null)";
  TIFFErrorExtR((uint64_t)a1, "PixarLogPostEncode", "ZLib error: %s", v6, v7, v8, v9, v10, (char)v14);
  return 0;
}

uint64_t PixarLogEncode(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  uint64_t v13;
  float v14;
  double v15;
  _WORD *v16;
  long double v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  double v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  __int16 v27;
  __int16 v28;
  __int16 v29;
  uint64_t v30;
  unsigned __int16 *v31;
  unsigned int v32;
  _WORD *v33;
  __int16 v34;
  __int16 v35;
  __int16 v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;
  __int16 v40;
  __int16 v41;
  __int16 v42;
  __int16 v43;
  _WORD *v44;
  unsigned __int8 *v45;
  unsigned int v46;
  __int16 v47;
  __int16 v48;
  __int16 v49;
  unsigned int v50;
  __int16 v51;
  double v52;
  double v53;
  double v54;
  float v55;
  unsigned int v56;
  _WORD *v57;
  _DWORD *v58;
  double v59;
  int v60;
  int v61;
  double v62;
  double v63;
  BOOL v64;
  __int16 v65;
  __int16 v66;
  __int16 v67;
  uint64_t v68;
  unsigned __int16 *v69;
  unsigned int v70;
  _WORD *v71;
  __int16 v72;
  __int16 v73;
  __int16 v74;
  uint64_t v75;
  unsigned int v76;
  int v77;
  _WORD *v78;
  unsigned __int16 *v79;
  int v80;
  __int16 v81;
  __int16 v82;
  __int16 v83;
  unsigned __int8 *v84;
  _WORD *v85;
  unsigned int v86;
  __int16 v87;
  __int16 v88;
  unsigned int v89;
  __int16 v90;
  unsigned int v91;
  _WORD *v92;
  unsigned __int8 *v93;
  unsigned int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  double v99;
  int v100;
  double v101;
  float v102;
  _DWORD *v103;
  _WORD *v104;
  unsigned int v105;
  double v106;
  double v107;
  int v108;
  double v109;
  int v110;
  int v111;
  double v112;
  double v113;
  int v114;
  int v115;
  double v116;
  float v117;
  _WORD *v118;
  _DWORD *v119;
  unsigned int v120;
  double v121;
  double v122;
  int v123;
  double v124;
  double v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t result;
  const char *v134;
  __int16 v135;
  double v136;
  float v137;
  unsigned int v138;
  unsigned int v139;
  _QWORD *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unsigned int v144;
  uint64_t v145;
  _QWORD *v146;
  uint64_t v147;
  uint64_t v148;
  _WORD *v149;
  _WORD *v150;
  _DWORD *v151;

  v8 = *(_QWORD **)(a1 + 1096);
  v9 = *((_DWORD *)v8 + 66);
  if (v9 - 2 < 3)
  {
    a3 = (unint64_t)a3 >> 1;
  }
  else if (v9 >= 2)
  {
    if (v9 != 5)
      goto LABEL_183;
    a3 = (unint64_t)a3 >> 2;
  }
  v10 = *(_DWORD *)(a1 + 88) * *((unsigned __int16 *)v8 + 128);
  if (a3 > *(unsigned int *)(a1 + 132) * v10)
  {
    v11 = "Too many input bytes provided";
LABEL_184:
    TIFFErrorExtR(a1, "PixarLogEncode", v11, a4, a5, a6, a7, a8, v135);
    return 0;
  }
  v140 = (_QWORD *)a1;
  v141 = v8[31];
  if (a3 >= 1)
  {
    if (v9 <= 5 && ((1 << v9) & 0x31) != 0)
    {
      v13 = 0;
      v147 = 2 * v10;
      v14 = *(float *)&Fltsize;
      v15 = *(float *)&LogK1;
      v137 = *(float *)&LogK2;
      v142 = 4 * v10;
      v139 = v10 + 4;
      v138 = v10 + 3;
      v16 = (_WORD *)v8[31];
      v150 = (_WORD *)(v141 + 14);
      v149 = (_WORD *)(v141 + 10);
      HIDWORD(v17) = 1084226560;
      v145 = a3;
      v146 = *(_QWORD **)(a1 + 1096);
      v144 = *((_DWORD *)v8 + 66);
      v143 = *(_DWORD *)(a1 + 88) * *((unsigned __int16 *)v8 + 128);
      v136 = *(float *)&LogK1;
      while (1)
      {
        v151 = a2;
        v148 = v13;
        if (v9 == 4)
        {
          v24 = *((unsigned __int16 *)v8 + 128);
          v19 = v147;
          v20 = v10;
          if ((int)v10 >= v24)
          {
            v25 = v146[40];
            if (v24 == 3)
            {
              v65 = *(_WORD *)(v25 + (((unint64_t)*a2 >> 1) & 0x7FFE));
              *v16 = v65;
              v66 = *(_WORD *)(v25 + (((unint64_t)a2[1] >> 1) & 0x7FFE));
              v16[1] = v66;
              v67 = *(_WORD *)(v25 + (((unint64_t)a2[2] >> 1) & 0x7FFE));
              v16[2] = v67;
              v19 = v147;
              v20 = v143;
              if ((int)v143 >= 4)
              {
                v68 = 0;
                v69 = a2 + 3;
                v70 = v138;
                do
                {
                  v71 = &v16[v68];
                  v72 = *(_WORD *)(v25 + (((unint64_t)v69[v68] >> 1) & 0x7FFE));
                  v71[3] = (v72 - v65) & 0x7FF;
                  v73 = *(_WORD *)(v25 + (((unint64_t)v69[v68 + 1] >> 1) & 0x7FFE));
                  v71[4] = (v73 - v66) & 0x7FF;
                  v74 = *(_WORD *)(v25 + (((unint64_t)v69[v68 + 2] >> 1) & 0x7FFE));
                  v70 -= 3;
                  v71[5] = (v74 - v67) & 0x7FF;
                  v68 += 3;
                  v67 = v74;
                  v66 = v73;
                  v65 = v72;
                }
                while (v70 > 6);
                goto LABEL_77;
              }
            }
            else
            {
              if (v24 != 4)
              {
                v75 = 0;
                v76 = v24 + 1;
                do
                {
                  v16[v75] = *(_WORD *)(v25 + (((unint64_t)a2[v75] >> 1) & 0x7FFE));
                  ++v75;
                  --v76;
                }
                while (v76 > 1);
                v20 = v143;
                v77 = v143 - v24;
                v19 = v147;
                if ((int)v143 - v24 < 1)
                  goto LABEL_171;
                v78 = &v16[v75];
                v79 = &a2[v75];
                do
                {
                  v80 = v24 + 1;
                  do
                  {
                    *v78++ = (*(_WORD *)(v25 + (((unint64_t)*v79 >> 1) & 0x7FFE))
                            - *(_WORD *)(v25 + (((unint64_t)v79[-v24] >> 1) & 0x7FFE))) & 0x7FF;
                    ++v79;
                    --v80;
                  }
                  while (v80 > 1);
                  v64 = __OFSUB__(v77, v24);
                  v77 -= v24;
                }
                while (!((v77 < 0) ^ v64 | (v77 == 0)));
LABEL_77:
                v19 = v147;
LABEL_170:
                v20 = v143;
                goto LABEL_171;
              }
              v26 = *(_WORD *)(v25 + (((unint64_t)*a2 >> 1) & 0x7FFE));
              *v16 = v26;
              v27 = *(_WORD *)(v25 + (((unint64_t)a2[1] >> 1) & 0x7FFE));
              v16[1] = v27;
              v28 = *(_WORD *)(v25 + (((unint64_t)a2[2] >> 1) & 0x7FFE));
              v16[2] = v28;
              v29 = *(_WORD *)(v25 + (((unint64_t)a2[3] >> 1) & 0x7FFE));
              v16[3] = v29;
              v19 = v147;
              v20 = v143;
              if ((int)v143 >= 5)
              {
                v30 = 0;
                v31 = a2 + 4;
                v32 = v139;
                do
                {
                  v33 = &v16[v30];
                  v34 = *(_WORD *)(v25 + (((unint64_t)v31[v30] >> 1) & 0x7FFE));
                  v33[4] = (v34 - v26) & 0x7FF;
                  v35 = *(_WORD *)(v25 + (((unint64_t)v31[v30 + 1] >> 1) & 0x7FFE));
                  v33[5] = (v35 - v27) & 0x7FF;
                  v36 = *(_WORD *)(v25 + (((unint64_t)v31[v30 + 2] >> 1) & 0x7FFE));
                  v33[6] = (v36 - v28) & 0x7FF;
                  v37 = *(_WORD *)(v25 + (((unint64_t)v31[v30 + 3] >> 1) & 0x7FFE));
                  v32 -= 4;
                  v30 += 4;
                  v33[7] = (v37 - v29) & 0x7FF;
                  v29 = v37;
                  v28 = v36;
                  v27 = v35;
                  v26 = v34;
                }
                while (v32 > 8);
                goto LABEL_77;
              }
            }
          }
        }
        else if (v9 == 5)
        {
          v18 = *((unsigned __int16 *)v8 + 128);
          v19 = v142;
          v20 = v10;
          if ((int)v10 >= v18)
          {
            v21 = v146[39];
            if (v18 == 3)
            {
              LODWORD(v17) = *(_DWORD *)a2;
              v52 = 0.0;
              v53 = 0.0;
              if (*(float *)a2 >= 0.0)
              {
                if (*(float *)&v17 >= 2.0)
                {
                  v53 = 2047.0;
                  if (*(float *)&v17 <= 24.2)
                  {
                    v17 = log((float)(*(float *)&v17 * v137));
                    v53 = v15 * v17 + 0.5;
                  }
                }
                else
                {
                  *(float *)&v17 = v14 * *(float *)&v17;
                  LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                  v53 = (double)*(unint64_t *)&v17;
                }
              }
              v97 = (int)v53;
              *v16 = (int)v53;
              LODWORD(v17) = v151[1];
              if (*(float *)&v17 >= 0.0)
              {
                if (*(float *)&v17 >= 2.0)
                {
                  v52 = 2047.0;
                  if (*(float *)&v17 <= 24.2)
                  {
                    v17 = log((float)(*(float *)&v17 * v137));
                    v52 = v15 * v17 + 0.5;
                  }
                }
                else
                {
                  *(float *)&v17 = v14 * *(float *)&v17;
                  LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                  v52 = (double)*(unint64_t *)&v17;
                }
              }
              v98 = (int)v52;
              v16[1] = (int)v52;
              LODWORD(v17) = v151[2];
              v99 = 0.0;
              if (*(float *)&v17 >= 0.0)
              {
                if (*(float *)&v17 >= 2.0)
                {
                  v99 = 2047.0;
                  if (*(float *)&v17 <= 24.2)
                  {
                    v17 = log((float)(*(float *)&v17 * v137));
                    v99 = v15 * v17 + 0.5;
                  }
                }
                else
                {
                  *(float *)&v17 = v14 * *(float *)&v17;
                  LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                  v99 = (double)*(unint64_t *)&v17;
                }
              }
              v100 = (int)v99;
              v16[2] = (int)v99;
              v19 = v142;
              v20 = v143;
              if ((int)v143 < 4)
                goto LABEL_171;
              v101 = *(float *)&LogK1;
              v102 = *(float *)&LogK2;
              v103 = v151 + 5;
              v104 = v149;
              v105 = v138;
              do
              {
                LODWORD(v17) = *(v103 - 2);
                v106 = 0.0;
                v107 = 0.0;
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    v107 = 2047.0;
                    if (*(float *)&v17 <= 24.2)
                    {
                      v17 = log((float)(v102 * *(float *)&v17));
                      v107 = v101 * v17 + 0.5;
                    }
                  }
                  else
                  {
                    *(float *)&v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    v107 = (double)*(unint64_t *)&v17;
                  }
                }
                v108 = (int)v107;
                *(v104 - 2) = ((int)v107 - v97) & 0x7FF;
                LODWORD(v17) = *(v103 - 1);
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    v106 = 2047.0;
                    if (*(float *)&v17 <= 24.2)
                    {
                      v17 = log((float)(v102 * *(float *)&v17));
                      v106 = v101 * v17 + 0.5;
                    }
                  }
                  else
                  {
                    *(float *)&v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    v106 = (double)*(unint64_t *)&v17;
                  }
                }
                *(v104 - 1) = ((int)v106 - v98) & 0x7FF;
                LODWORD(v17) = *v103;
                v109 = 0.0;
                if (*(float *)v103 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    v109 = 2047.0;
                    if (*(float *)&v17 <= 24.2)
                    {
                      v17 = log((float)(v102 * *(float *)&v17));
                      v109 = v101 * v17 + 0.5;
                    }
                  }
                  else
                  {
                    *(float *)&v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    v109 = (double)*(unint64_t *)&v17;
                  }
                }
                *v104 = ((int)v109 - v100) & 0x7FF;
                v104 += 3;
                v105 -= 3;
                v103 += 3;
                v100 = (int)v109;
                v98 = (int)v106;
                LOWORD(v97) = v108;
              }
              while (v105 > 6);
LABEL_169:
              v19 = v142;
              goto LABEL_170;
            }
            if (v18 != 4)
            {
              v54 = *(float *)&LogK1;
              v55 = *(float *)&LogK2;
              v56 = v18 + 1;
              v57 = v16;
              v58 = a2;
              do
              {
                LODWORD(v17) = *v58;
                v59 = 0.0;
                if (*(float *)v58 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      v17 = log((float)(v55 * *(float *)&v17));
                      v59 = v54 * v17 + 0.5;
                    }
                    else
                    {
                      v59 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    v59 = (double)*(unint64_t *)&v17;
                  }
                }
                *v57++ = (int)v59;
                ++v58;
                --v56;
              }
              while (v56 > 1);
              v20 = v143;
              v60 = v143 - v18;
              v19 = v142;
              if ((int)v143 - v18 >= 1)
              {
                do
                {
                  v61 = v18 + 1;
                  do
                  {
                    LODWORD(v17) = *v58;
                    v62 = 0.0;
                    v63 = 0.0;
                    if (*(float *)v58 >= 0.0)
                    {
                      if (*(float *)&v17 >= 2.0)
                      {
                        if (*(float *)&v17 <= 24.2)
                        {
                          v17 = log((float)(v55 * *(float *)&v17));
                          v63 = v54 * v17 + 0.5;
                        }
                        else
                        {
                          v63 = 2047.0;
                        }
                      }
                      else
                      {
                        *(float *)&v17 = v14 * *(float *)&v17;
                        LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                        v63 = (double)*(unint64_t *)&v17;
                      }
                    }
                    LODWORD(v17) = v58[-v18];
                    if (*(float *)&v17 >= 0.0)
                    {
                      if (*(float *)&v17 >= 2.0)
                      {
                        if (*(float *)&v17 <= 24.2)
                        {
                          v17 = log((float)(v55 * *(float *)&v17));
                          v62 = v54 * v17 + 0.5;
                        }
                        else
                        {
                          v62 = 2047.0;
                        }
                      }
                      else
                      {
                        *(float *)&v17 = v14 * *(float *)&v17;
                        LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                        v62 = (double)*(unint64_t *)&v17;
                      }
                    }
                    *v57++ = ((int)v63 - (int)v62) & 0x7FF;
                    ++v58;
                    --v61;
                  }
                  while (v61 > 1);
                  v64 = __OFSUB__(v60, v18);
                  v60 -= v18;
                }
                while (!((v60 < 0) ^ v64 | (v60 == 0)));
                v19 = v142;
                v20 = v143;
                v15 = v136;
              }
              goto LABEL_171;
            }
            LODWORD(v17) = *(_DWORD *)a2;
            v22 = 0.0;
            v23 = 0.0;
            if (*(float *)a2 >= 0.0)
            {
              if (*(float *)&v17 >= 2.0)
              {
                if (*(float *)&v17 <= 24.2)
                {
                  v17 = log((float)(*(float *)&v17 * v137));
                  v23 = v15 * v17 + 0.5;
                }
                else
                {
                  v23 = 2047.0;
                }
              }
              else
              {
                *(float *)&v17 = v14 * *(float *)&v17;
                LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                v23 = (double)*(unint64_t *)&v17;
              }
            }
            v110 = (int)v23;
            *v16 = (int)v23;
            LODWORD(v17) = v151[1];
            if (*(float *)&v17 >= 0.0)
            {
              if (*(float *)&v17 >= 2.0)
              {
                if (*(float *)&v17 <= 24.2)
                {
                  v17 = log((float)(*(float *)&v17 * v137));
                  v22 = v15 * v17 + 0.5;
                }
                else
                {
                  v22 = 2047.0;
                }
              }
              else
              {
                *(float *)&v17 = v14 * *(float *)&v17;
                LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                v22 = (double)*(unint64_t *)&v17;
              }
            }
            v111 = (int)v22;
            v16[1] = (int)v22;
            LODWORD(v17) = v151[2];
            v112 = 0.0;
            v113 = 0.0;
            if (*(float *)&v17 >= 0.0)
            {
              if (*(float *)&v17 >= 2.0)
              {
                if (*(float *)&v17 <= 24.2)
                {
                  v17 = log((float)(*(float *)&v17 * v137));
                  v113 = v15 * v17 + 0.5;
                }
                else
                {
                  v113 = 2047.0;
                }
              }
              else
              {
                *(float *)&v17 = v14 * *(float *)&v17;
                LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                v113 = (double)*(unint64_t *)&v17;
              }
            }
            v114 = (int)v113;
            v16[2] = (int)v113;
            LODWORD(v17) = v151[3];
            if (*(float *)&v17 >= 0.0)
            {
              if (*(float *)&v17 >= 2.0)
              {
                if (*(float *)&v17 <= 24.2)
                {
                  v17 = log((float)(*(float *)&v17 * v137));
                  v112 = v15 * v17 + 0.5;
                }
                else
                {
                  v112 = 2047.0;
                }
              }
              else
              {
                *(float *)&v17 = v14 * *(float *)&v17;
                LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                v112 = (double)*(unint64_t *)&v17;
              }
            }
            v115 = (int)v112;
            v16[3] = (int)v112;
            v19 = v142;
            v20 = v143;
            if ((int)v143 >= 5)
            {
              v116 = *(float *)&LogK1;
              v117 = *(float *)&LogK2;
              v118 = v150;
              v119 = v151 + 7;
              v120 = v139;
              do
              {
                LODWORD(v17) = *(v119 - 3);
                v121 = 0.0;
                v122 = 0.0;
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      v17 = log((float)(v117 * *(float *)&v17));
                      v122 = v116 * v17 + 0.5;
                    }
                    else
                    {
                      v122 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    v122 = (double)*(unint64_t *)&v17;
                  }
                }
                v123 = (int)v122;
                *(v118 - 3) = ((int)v122 - v110) & 0x7FF;
                LODWORD(v17) = *(v119 - 2);
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      v17 = log((float)(v117 * *(float *)&v17));
                      v121 = v116 * v17 + 0.5;
                    }
                    else
                    {
                      v121 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    v121 = (double)*(unint64_t *)&v17;
                  }
                }
                v110 = (int)v121;
                *(v118 - 2) = ((int)v121 - v111) & 0x7FF;
                LODWORD(v17) = *(v119 - 1);
                v124 = 0.0;
                v125 = 0.0;
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      v17 = log((float)(v117 * *(float *)&v17));
                      v125 = v116 * v17 + 0.5;
                    }
                    else
                    {
                      v125 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    v125 = (double)*(unint64_t *)&v17;
                  }
                }
                v111 = (int)v125;
                *(v118 - 1) = ((int)v125 - v114) & 0x7FF;
                LODWORD(v17) = *v119;
                if (*(float *)v119 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      v17 = log((float)(v117 * *(float *)&v17));
                      v124 = v116 * v17 + 0.5;
                    }
                    else
                    {
                      v124 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    v124 = (double)*(unint64_t *)&v17;
                  }
                }
                *v118 = ((int)v124 - v115) & 0x7FF;
                v118 += 4;
                v120 -= 4;
                v119 += 4;
                v115 = (int)v124;
                LOWORD(v114) = v111;
                LOWORD(v111) = v110;
                LOWORD(v110) = v123;
              }
              while (v120 > 8);
              goto LABEL_169;
            }
          }
        }
        else
        {
          v38 = *((unsigned __int16 *)v8 + 128);
          v19 = v10;
          v20 = v10;
          if ((int)v10 >= (int)v38)
          {
            v39 = v146[41];
            if ((_DWORD)v38 == 3)
            {
              v81 = *(_WORD *)(v39 + 2 * *(unsigned __int8 *)a2);
              *v16 = v81;
              v82 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 1));
              v16[1] = v82;
              v83 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 2));
              v16[2] = v83;
              v20 = v143;
              v19 = v143;
              if ((int)v143 >= 4)
              {
                v84 = (unsigned __int8 *)a2 + 5;
                v85 = v149;
                v86 = v138;
                do
                {
                  v87 = *(_WORD *)(v39 + 2 * *(v84 - 2));
                  *(v85 - 2) = (v87 - v81) & 0x7FF;
                  v88 = *(_WORD *)(v39 + 2 * *(v84 - 1));
                  *(v85 - 1) = (v88 - v82) & 0x7FF;
                  v89 = *v84;
                  v84 += 3;
                  v90 = *(_WORD *)(v39 + 2 * v89);
                  *v85 = (v90 - v83) & 0x7FF;
                  v85 += 3;
                  v86 -= 3;
                  v83 = v90;
                  v82 = v88;
                  v81 = v87;
                }
                while (v86 > 6);
                goto LABEL_81;
              }
            }
            else
            {
              if ((_DWORD)v38 != 4)
              {
                v91 = v38 + 1;
                v92 = v16;
                v93 = (unsigned __int8 *)a2;
                do
                {
                  v94 = *v93++;
                  *v92++ = *(_WORD *)(v39 + 2 * v94);
                  --v91;
                }
                while (v91 > 1);
                v20 = v143;
                v95 = v143 - v38;
                v19 = v143;
                if ((int)v143 - (int)v38 >= 1)
                {
                  do
                  {
                    v96 = v38 + 1;
                    do
                    {
                      *v92++ = (*(_WORD *)(v39 + 2 * *v93) - *(_WORD *)(v39 + 2 * v93[-v38])) & 0x7FF;
                      ++v93;
                      --v96;
                    }
                    while (v96 > 1);
                    v64 = __OFSUB__(v95, (_DWORD)v38);
                    v95 -= v38;
                  }
                  while (!((v95 < 0) ^ v64 | (v95 == 0)));
                  v19 = v143;
                }
                goto LABEL_171;
              }
              v40 = *(_WORD *)(v39 + 2 * *(unsigned __int8 *)a2);
              *v16 = v40;
              v41 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 1));
              v16[1] = v41;
              v42 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 2));
              v16[2] = v42;
              v43 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 3));
              v16[3] = v43;
              v20 = v143;
              v19 = v143;
              if ((int)v143 >= 5)
              {
                v44 = v150;
                v45 = (unsigned __int8 *)a2 + 7;
                v46 = v139;
                do
                {
                  v47 = *(_WORD *)(v39 + 2 * *(v45 - 3));
                  *(v44 - 3) = (v47 - v40) & 0x7FF;
                  v48 = *(_WORD *)(v39 + 2 * *(v45 - 2));
                  *(v44 - 2) = (v48 - v41) & 0x7FF;
                  v49 = *(_WORD *)(v39 + 2 * *(v45 - 1));
                  *(v44 - 1) = (v49 - v42) & 0x7FF;
                  v50 = *v45;
                  v45 += 4;
                  v51 = *(_WORD *)(v39 + 2 * v50);
                  *v44 = (v51 - v43) & 0x7FF;
                  v44 += 4;
                  v46 -= 4;
                  v43 = v51;
                  v42 = v49;
                  v41 = v48;
                  v40 = v47;
                }
                while (v46 > 8);
LABEL_81:
                v20 = v143;
                v19 = v143;
              }
            }
          }
        }
LABEL_171:
        a2 = (unsigned __int16 *)((char *)v151 + v19);
        v13 = v148 + v20;
        v16 = (_WORD *)((char *)v16 + v147);
        v150 = (_WORD *)((char *)v150 + v147);
        v149 = (_WORD *)((char *)v149 + v147);
        LODWORD(a3) = v145;
        v8 = v146;
        v9 = v144;
        v10 = v20;
        if (v148 + v20 >= v145)
          goto LABEL_172;
      }
    }
LABEL_183:
    v135 = *(_WORD *)(a1 + 116);
    v11 = "%hu bit input not supported in PixarLog";
    goto LABEL_184;
  }
LABEL_172:
  v8[16] = v141;
  *((_DWORD *)v8 + 34) = 2 * a3;
  if ((a3 & 0x80000000) != 0)
  {
    v11 = "ZLib cannot deal with buffers this size";
    a1 = (uint64_t)v140;
    goto LABEL_184;
  }
  while (!deflate((z_streamp)(v8 + 16), 0))
  {
    if (!*((_DWORD *)v8 + 40))
    {
      v140[145] = v140[141];
      result = TIFFFlushData1((uint64_t)v140, v126, v127, v128, v129, v130, v131, v132);
      if (!(_DWORD)result)
        return result;
      v8[19] = v140[140];
      *((_DWORD *)v8 + 40) = v140[141];
    }
    if (!*((_DWORD *)v8 + 34))
      return 1;
  }
  v134 = (const char *)v8[22];
  if (!v134)
    v134 = "(null)";
  TIFFErrorExtR((uint64_t)v140, "PixarLogEncode", "Encoder error: %s", v128, v129, v130, v131, v132, (char)v134);
  return 0;
}

uint64_t PixarLogClose(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 1096);
  if (!v1)
    PixarLogClose_cold_1();
  if ((*(_BYTE *)(v1 + 260) & 1) != 0)
    *(_DWORD *)(result + 116) = 65544;
  return result;
}

uint64_t PixarLogCleanup(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  z_stream *v10;
  char *v11;

  v1 = *(_QWORD *)(a1 + 1096);
  if (!v1)
    PixarLogCleanup_cold_1();
  TIFFPredictorCleanup((_QWORD *)a1);
  v3 = *(_QWORD *)(v1 + 280);
  *(_QWORD *)(a1 + 1288) = *(_QWORD *)(v1 + 272);
  *(_QWORD *)(a1 + 1280) = v3;
  v4 = *(char **)(v1 + 312);
  if (v4)
    _TIFFfreeExt(a1, v4);
  v5 = *(char **)(v1 + 320);
  if (v5)
    _TIFFfreeExt(a1, v5);
  v6 = *(char **)(v1 + 328);
  if (v6)
    _TIFFfreeExt(a1, v6);
  v7 = *(char **)(v1 + 288);
  if (v7)
    _TIFFfreeExt(a1, v7);
  v8 = *(char **)(v1 + 296);
  if (v8)
    _TIFFfreeExt(a1, v8);
  v9 = *(char **)(v1 + 304);
  if (v9)
    _TIFFfreeExt(a1, v9);
  if ((*(_BYTE *)(v1 + 260) & 1) != 0)
  {
    v10 = (z_stream *)(v1 + 128);
    if (*(_DWORD *)(a1 + 12))
      deflateEnd(v10);
    else
      inflateEnd(v10);
  }
  v11 = *(char **)(v1 + 248);
  if (v11)
    _TIFFfreeExt(a1, v11);
  _TIFFfreeExt(a1, (char *)v1);
  *(_QWORD *)(a1 + 1096) = 0;
  return _TIFFSetDefaultCompressionState(a1);
}

uint64_t PixarLogVGetField(uint64_t a1, int a2, _DWORD **a3)
{
  uint64_t v3;
  int v4;

  v3 = *(_QWORD *)(a1 + 1096);
  if (a2 == 65549)
  {
    v4 = *(_DWORD *)(v3 + 264);
    goto LABEL_5;
  }
  if (a2 == 65558)
  {
    v4 = *(_DWORD *)(v3 + 268);
LABEL_5:
    **a3 = v4;
    return 1;
  }
  return (*(uint64_t (**)(void))(v3 + 272))();
}

uint64_t PixarLogVSetField(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v9 = *(_QWORD *)(a1 + 1096);
  if ((_DWORD)a2 == 65549)
  {
    v18 = *a3;
    *(_DWORD *)(v9 + 264) = *a3;
    if (v18 <= 5)
    {
      _cg_TIFFSetField(a1, 258, (uint64_t)a3, a4, a5, a6, a7, a8, *(unsigned int *)&asc_18822ACB0[4 * v18]);
      _cg_TIFFSetField(a1, 339, v19, v20, v21, v22, v23, v24, dword_18822ACC8[v18]);
    }
    if ((*(_BYTE *)(a1 + 17) & 4) != 0)
      v25 = _cg_TIFFTileSize(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    else
      v25 = -1;
    *(_QWORD *)(a1 + 936) = v25;
    *(_QWORD *)(a1 + 1104) = _cg_TIFFScanlineSize(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    return 1;
  }
  if ((_DWORD)a2 != 65558)
    return (*(uint64_t (**)(uint64_t))(v9 + 280))(a1);
  v10 = *a3;
  *(_DWORD *)(v9 + 268) = *a3;
  if (!*(_DWORD *)(a1 + 12) || (*(_BYTE *)(v9 + 260) & 1) == 0 || !deflateParams((z_streamp)(v9 + 128), v10, 0))
    return 1;
  v16 = *(const char **)(v9 + 176);
  if (!v16)
    v16 = "(null)";
  TIFFErrorExtR(a1, "PixarLogVSetField", "ZLib error: %s", v11, v12, v13, v14, v15, (char)v16);
  return 0;
}

uint64_t PixarLogGuessDataFmt(uint64_t a1)
{
  int v1;
  int v2;
  uint64_t result;
  int v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;

  v1 = *(unsigned __int16 *)(a1 + 46);
  v2 = *(unsigned __int16 *)(a1 + 44);
  result = 0xFFFFFFFFLL;
  switch(v2)
  {
    case 8:
      v5 = v1 != 4 && v1 != 1;
      return (v5 << 31 >> 31);
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
      return result;
    case 11:
      v7 = v1 == 1 || v1 == 4;
      v8 = 2;
      goto LABEL_24;
    case 12:
      v7 = (((_WORD)v1 - 2) & 0xFFFD) == 0;
      v8 = 3;
      goto LABEL_24;
    case 16:
      v7 = v1 == 1 || v1 == 4;
      v8 = 4;
LABEL_24:
      if (v7)
        result = v8;
      else
        result = 0xFFFFFFFFLL;
      break;
    default:
      if (v1 == 3)
        v6 = 5;
      else
        v6 = -1;
      if (v2 == 32)
        result = v6;
      else
        result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t IIO_Reader_TIFF::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  TIFFReadPlugin::TIFFReadPlugin(v4, a2, v5);
  return v4;
}

void sub_188009E94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40FF4BE457);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_TIFF::createGlobalInfoData(IIO_Reader_TIFF *this, IIOImageReadSession *a2)
{
  IIOImageRead *result;

  result = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (result)
    return (IIOImageRead *)GlobalTIFFInfo::createDataRepresentation(result);
  return result;
}

uint64_t IIO_Reader_TIFF::updateGlobalInfo(IIO_Reader_TIFF *this, IIOImageRead **a2, unsigned __int8 *a3, unint64_t a4)
{
  GlobalTIFFInfo *v8;

  v8 = (GlobalTIFFInfo *)operator new();
  GlobalTIFFInfo::GlobalTIFFInfo(v8, a3, a4);
  IIOImageReadSession::setGlobalInfo(a2, *((_DWORD *)this + 6), v8, (void (*)(void *))ReleaseTIFFGlobalInfo);
  return 0;
}

void sub_188009F60(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C4016865251);
  _Unwind_Resume(a1);
}

GlobalTIFFInfo *IIO_Reader_TIFF::deserializeGlobalInfo(IIO_Reader_TIFF *this, unsigned __int8 *a2, unint64_t a3)
{
  GlobalTIFFInfo *v5;

  v5 = (GlobalTIFFInfo *)operator new();
  GlobalTIFFInfo::GlobalTIFFInfo(v5, a2, a3);
  return v5;
}

void sub_188009FD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C4016865251);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_TIFF::initThumbnail(IIO_Reader *a1, uint64_t a2, int a3, int a4)
{
  IIOReadPlugin *v8;
  int v9;

  v8 = (IIOReadPlugin *)operator new();
  v9 = IIO_Reader::osType(a1);
  TIFFReadPlugin::TIFFReadPlugin((uint64_t)v8, a2, a3, 0, 0, v9);
  IIOReadPlugin::setDecodeMode((uint64_t)v8, 2);
  IIOReadPlugin::setDestMaxPixelSize((uint64_t)v8, a4);
  return IIOReadPlugin::callInitialize(v8);
}

void sub_18800A094(void *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40FF4BE457);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18800A080);
}

uint64_t IIO_Reader_TIFF::hasCustomThumbnailProc(IIO_Reader_TIFF *this)
{
  return 1;
}

char *std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned long long>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<unsigned long long>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

_QWORD *std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_18800A278(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AppleJPEGWritePlugin::get_encoding_format(AppleJPEGWritePlugin *this, IIODictionary *a2)
{
  int EncodingHorizontalSubsamplingFactor;
  uint64_t result;

  EncodingHorizontalSubsamplingFactor = JPEGWritePlugin::getEncodingHorizontalSubsamplingFactor(this, a2);
  result = JPEGWritePlugin::getEncodingVerticalSubsamplingFactor(this, a2);
  if (EncodingHorizontalSubsamplingFactor == 2 && (_DWORD)result == 2)
    return 3;
  if (EncodingHorizontalSubsamplingFactor == 1 && (_DWORD)result == 1)
    return 0;
  if ((EncodingHorizontalSubsamplingFactor != 2 || (_DWORD)result != 1)
    && (EncodingHorizontalSubsamplingFactor != 1 || (_DWORD)result != 2))
  {
    _cg_jpeg_mem_term("get_encoding_format", 133, "Unsupported chroma subsampling combination: H=%d,V=%d - using 4:2:0\n", EncodingHorizontalSubsamplingFactor, result);
    return 3;
  }
  return result;
}

void AppleJPEGWritePlugin::~AppleJPEGWritePlugin(AppleJPEGWritePlugin *this)
{
  JPEGWritePlugin::~JPEGWritePlugin(this);
  JUMPOUT(0x18D761C30);
}

CFDataRef AppleJPEGWritePlugin::createJpegDataFromIOSurface(AppleJPEGWritePlugin *this, __IOSurface *a2, IIODictionary *a3)
{
  signed int PixelFormat;
  signed int v7;
  int v8;
  const __CFAllocator *v9;
  __CFDictionary *Mutable;
  float DoubleForKey;
  CFDataRef LumaQuantizationTableFromImageIOQuality;
  CFDataRef ChromaQuantizationTableFromImageIOQuality;
  int v14;
  const UInt8 *BaseAddress;
  CFDataRef v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  IOSurfaceRef buffer;
  CFIndex length;

  IIO_LoadCMPhotoSymbols();
  LODWORD(length) = 0;
  buffer = 0;
  if (!a2)
    return 0;
  PixelFormat = IOSurfaceGetPixelFormat(a2);
  v7 = PixelFormat;
  if (PixelFormat > 1111970368)
  {
    if (PixelFormat == 1111970369)
      goto LABEL_8;
    v8 = 1380401729;
  }
  else
  {
    if (PixelFormat == 875704422)
      goto LABEL_8;
    v8 = 875704438;
  }
  if (PixelFormat != v8)
  {
    if ((gIIODebugFlags & 0x1000000000) != 0)
    {
      v17 = PixelFormat >> 24;
      v18 = MEMORY[0x1E0C80978];
      if (PixelFormat < 0)
        v19 = __maskrune(PixelFormat >> 24, 0x40000uLL);
      else
        v19 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v17 + 60) & 0x40000;
      if (v19)
        v20 = v17;
      else
        v20 = 46;
      v21 = v7 << 8 >> 24;
      if (v7 << 8 < 0)
        v22 = __maskrune(v7 << 8 >> 24, 0x40000uLL);
      else
        v22 = *(_DWORD *)(v18 + 4 * v21 + 60) & 0x40000;
      if (v22)
        v23 = v21;
      else
        v23 = 46;
      v24 = (__int16)v7 >> 8;
      if (v7 << 16 < 0)
        v25 = __maskrune((__int16)v7 >> 8, 0x40000uLL);
      else
        v25 = *(_DWORD *)(v18 + 4 * v24 + 60) & 0x40000;
      if (v25)
        v26 = v24;
      else
        v26 = 46;
      if ((v7 << 24) <= 0x7F000000)
        v27 = *(_DWORD *)(v18 + 4 * (char)v7 + 60) & 0x40000;
      else
        v27 = __maskrune((char)v7, 0x40000uLL);
      if (v27)
        v28 = (char)v7;
      else
        v28 = 46;
      ImageIOLog("H   ERROR: Pixel format '%c%c%c%c' not natively supported for encoding, conversion will occur.\n", v20, v23, v26, v28);
    }
    return 0;
  }
LABEL_8:
  if (!gFunc_CMPhotoJPEGCreateJPEGFromIOSurface)
    return 0;
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  DoubleForKey = 0.75;
  if (IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationLossyCompressionQuality")))
    DoubleForKey = IIODictionary::getDoubleForKey(a3, CFSTR("kCGImageDestinationLossyCompressionQuality"));
  if (gIIO_kCMPhotoJPEGCustomLumaQuantTable)
  {
    LumaQuantizationTableFromImageIOQuality = JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality(this, DoubleForKey, 0);
    CFDictionarySetValue(Mutable, *(const void **)gIIO_kCMPhotoJPEGCustomLumaQuantTable, LumaQuantizationTableFromImageIOQuality);
    CFRelease(LumaQuantizationTableFromImageIOQuality);
  }
  if (gIIO_kCMPhotoJPEGCustomChromaQuantTable)
  {
    ChromaQuantizationTableFromImageIOQuality = JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality(this, DoubleForKey, 0);
    CFDictionarySetValue(Mutable, *(const void **)gIIO_kCMPhotoJPEGCustomChromaQuantTable, ChromaQuantizationTableFromImageIOQuality);
    CFRelease(ChromaQuantizationTableFromImageIOQuality);
  }
  v14 = gFunc_CMPhotoJPEGCreateJPEGFromIOSurface(a2, Mutable, &buffer, &length);
  if (Mutable)
    CFRelease(Mutable);
  if (v14 || !buffer || (int)length < 1)
  {
    if ((gIIODebugFlags & 0x1000000000) != 0)
      ImageIOLog("H   ERROR: Hardware encode failed: err=%d, surface=%p, jpeg size = %d\n");
  }
  else
  {
    BaseAddress = (const UInt8 *)IOSurfaceGetBaseAddress(buffer);
    if (BaseAddress)
    {
      v16 = CFDataCreate(v9, BaseAddress, (int)length);
      goto LABEL_61;
    }
    if ((gIIODebugFlags & 0x1000000000) != 0)
    {
      if (v7 << 8 < 0)
        __maskrune(v7 << 8 >> 24, 0x40000uLL);
      if (v7 << 16 < 0)
        __maskrune((__int16)v7 >> 8, 0x40000uLL);
      if ((v7 << 24) > 0x7F000000)
        __maskrune((char)v7, 0x40000uLL);
      ImageIOLog("H   ERROR: cannot get base address for '%c%c%c%c' IOSurface.\n");
    }
  }
  v16 = 0;
LABEL_61:
  if (buffer)
    IIO_IOSurfaceRelease(buffer);
  return v16;
}

__IOSurface *AppleJPEGWritePlugin::copyIOSurfaceFromPixelProvider(AppleJPEGWritePlugin *this, IIOImagePixelDataProvider *a2)
{
  uint64_t Ref;
  int BitmapInfo;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __IOSurface *OutputSurfaceWithFormat;
  __IOSurface *v10;
  size_t BytesPerRow;
  __IOSurface *Property;
  char *BaseAddress;
  char *v14;
  unsigned int v15;
  int Bytes;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  _BYTE v21[24];

  Ref = IIOImageSource::imageReadRef(a2);
  if (_ImageHasMask())
    goto LABEL_2;
  Property = (__IOSurface *)CGImageGetProperty();
  if (Property)
  {
    v10 = Property;
    IIOFrameBufferRetain(Property);
    return v10;
  }
  CGImageGetImageProvider();
  if (!Ref
    || (memset(&dest, 0, 24),
        IIODictionary::IIODictionary((IIODictionary *)&dest),
        IIONumber::IIONumber((IIONumber *)v21, 875704422),
        IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v21, CFSTR("kCGImageSurfaceFormatRequest")),
        IIONumber::~IIONumber((IIONumber *)v21),
        v10 = (__IOSurface *)CGImageProviderCopyIOSurface(),
        IIODictionary::~IIODictionary((IIODictionary *)&dest),
        !v10))
  {
LABEL_2:
    BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
    v5 = BitmapInfo;
    if (BitmapInfo == 8198 || BitmapInfo == 5)
    {
      v6 = IIOImageSource::count(a2);
      v7 = IIO_Reader::testHeaderSize(a2);
      v8 = IIOImagePlus::sourceImageProvider(a2);
      OutputSurfaceWithFormat = IIO_CreateOutputSurfaceWithFormat(v6, v7, v8, 1111970369);
      v10 = OutputSurfaceWithFormat;
      if (OutputSurfaceWithFormat)
      {
        BytesPerRow = IOSurfaceGetBytesPerRow(OutputSurfaceWithFormat);
        if (IOSurfaceLock(v10, 0, 0))
        {
          IIO_IOSurfaceRelease(v10);
          v10 = 0;
        }
        else
        {
          BaseAddress = (char *)IOSurfaceGetBaseAddress(v10);
          if (v7)
          {
            v14 = BaseAddress;
            v15 = 1;
            while (1)
            {
              Bytes = IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v14);
              if (v8 != Bytes)
                break;
              v14 += BytesPerRow;
              if (v7 <= v15++)
                goto LABEL_19;
            }
            _cg_jpeg_mem_term("copyIOSurfaceFromPixelProvider", 338, "*** copyIOSurfaceFromPixelProvider expected: %d   got: %d\n", v8, Bytes);
          }
LABEL_19:
          if (v5 == 5)
          {
            dest.data = IOSurfaceGetBaseAddress(v10);
            dest.height = v7;
            dest.width = v6;
            dest.rowBytes = BytesPerRow;
            *(_DWORD *)permuteMap = 50331906;
            vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0);
          }
          IOSurfaceUnlock(v10, 0, 0);
        }
        IIOImagePixelDataProvider::rewind(a2);
      }
    }
    else
    {
      return 0;
    }
  }
  return v10;
}

void sub_18800A9D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t AppleJPEGWritePlugin::writeOneImage(AppleJPEGWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t AppleJPEGWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  int AlphaInfo;
  CGColorSpace *SourceGeomColorSpace;
  CGColorSpaceModel Model;
  IIODictionary *v9;
  const __CFDictionary *QuantizationTableFromPropertiesForComponentIndex;
  const __CFData *LumaQuantizationTableFromImageIOQuality;
  const UInt8 *BytePtr;
  const __CFData *ChromaQuantizationTableFromImageIOQuality;
  float ImageIOCompressionQuality;
  uint64_t v15;
  IIODictionary *v16;
  float v17;
  JPEGWritePlugin *v18;
  size_t v19;
  size_t v20;
  IIOImageWriteSession *v21;
  uint64_t v22;
  float FloatForKey;
  float v24;
  unsigned int v25;
  unsigned int v26;
  IIODictionary *v27;
  IIODictionary *v28;
  IIODictionary *v29;
  CGColorSpace *v30;
  uint64_t v31;
  uint64_t Bytes;
  _BYTE *v33;
  size_t v34;
  const __CFData *theData;
  uint64_t v38;
  uint64_t v39;
  __int16 v40;
  __int16 __ptr;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  void *v47[2];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  __int128 v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v65 = 0;
  v63 = 0u;
  v64 = xmmword_1E1BC9880;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v56 = 0;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  *(_OWORD *)v47 = 0u;
  v45 = 0;
  v46 = 0;
  v43 = 0u;
  v44 = 0u;
  v42 = 0u;
  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  __ptr = -9985;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  if (!applejpeg_encode_create())
  {
    _cg_jpeg_mem_term("writeOne", 416, "*** ERROR: applejpeg_encode_create returned NULL\n");
LABEL_75:
    v22 = 4294967246;
    goto LABEL_62;
  }
  applejpeg_encode_options_init();
  if (!IIODictionary::getObjectForKeyGroup(a3, CFSTR("Quantization"), CFSTR("{JPEG}")))
  {
    LODWORD(v58) = 0;
    ImageIOCompressionQuality = JPEGWritePlugin::GetImageIOCompressionQuality(a3, v9);
    LumaQuantizationTableFromImageIOQuality = JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality((JPEGWritePlugin *)this, ImageIOCompressionQuality, 0);
    BytePtr = CFDataGetBytePtr(LumaQuantizationTableFromImageIOQuality);
    *((_QWORD *)&v58 + 1) = BytePtr;
    if (Model == kCGColorSpaceModelRGB)
    {
      ChromaQuantizationTableFromImageIOQuality = JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality((JPEGWritePlugin *)this, ImageIOCompressionQuality, 0);
      BytePtr = CFDataGetBytePtr(ChromaQuantizationTableFromImageIOQuality);
LABEL_14:
      theData = 0;
      goto LABEL_15;
    }
LABEL_13:
    ChromaQuantizationTableFromImageIOQuality = 0;
    goto LABEL_14;
  }
  QuantizationTableFromPropertiesForComponentIndex = createQuantizationTableFromPropertiesForComponentIndex(a3, 0);
  LumaQuantizationTableFromImageIOQuality = QuantizationTableFromPropertiesForComponentIndex;
  if (QuantizationTableFromPropertiesForComponentIndex)
  {
    LODWORD(v58) = 0;
    BytePtr = CFDataGetBytePtr(QuantizationTableFromPropertiesForComponentIndex);
    *((_QWORD *)&v58 + 1) = BytePtr;
    if (Model == kCGColorSpaceModelRGB)
    {
      ChromaQuantizationTableFromImageIOQuality = createQuantizationTableFromPropertiesForComponentIndex(a3, 1u);
      theData = createQuantizationTableFromPropertiesForComponentIndex(a3, 2u);
      if (ChromaQuantizationTableFromImageIOQuality && !theData)
        theData = (const __CFData *)CFRetain(ChromaQuantizationTableFromImageIOQuality);
      if (ChromaQuantizationTableFromImageIOQuality && theData)
      {
        *(_QWORD *)&v59 = CFDataGetBytePtr(ChromaQuantizationTableFromImageIOQuality);
        BytePtr = CFDataGetBytePtr(theData);
LABEL_16:
        *((_QWORD *)&v59 + 1) = BytePtr;
        goto LABEL_18;
      }
      BytePtr = (const UInt8 *)*((_QWORD *)&v58 + 1);
LABEL_15:
      *(_QWORD *)&v59 = BytePtr;
      goto LABEL_16;
    }
    goto LABEL_13;
  }
  ChromaQuantizationTableFromImageIOQuality = 0;
  theData = 0;
LABEL_18:
  if (IIODictionary::getBoolForKeyGroup(a3, CFSTR("IsProgressive"), CFSTR("{JFIF}")))
    HIDWORD(v60) = 1;
  LODWORD(v57) = 1;
  DWORD2(v60) = AppleJPEGWritePlugin::get_encoding_format((AppleJPEGWritePlugin *)this, a3);
  LODWORD(v62) = 1;
  v15 = IIO_Reader::testHeaderSize(a2);
  DWORD2(v49) = IIOImageSource::count(a2);
  HIDWORD(v49) = v15;
  switch(Model)
  {
    case kCGColorSpaceModelCMYK:
      if (!AlphaInfo)
        LODWORD(v50) = 15;
      v17 = JPEGWritePlugin::GetImageIOCompressionQuality(a3, v16);
      LODWORD(v58) = JPEGWritePlugin::JPEGQualityFromLossyCompressionQuality(v18, v17);
      break;
    case kCGColorSpaceModelRGB:
      if (AlphaInfo)
        LODWORD(v50) = 3;
      else
        LODWORD(v50) = 0;
      break;
    case kCGColorSpaceModelMonochrome:
      if (!AlphaInfo)
        LODWORD(v50) = 5;
      DWORD2(v60) = 4;
      break;
  }
  v19 = IIOImagePlus::sourceImageProvider(a2);
  v20 = v19;
  if (!v19)
  {
    _cg_jpeg_mem_term("writeOne", 501, "*** ERROR: iPixelDataProvider bytesPerRow = %d\n", 0);
LABEL_69:
    if (LumaQuantizationTableFromImageIOQuality)
      CFRelease(LumaQuantizationTableFromImageIOQuality);
    if (ChromaQuantizationTableFromImageIOQuality)
      CFRelease(ChromaQuantizationTableFromImageIOQuality);
    if (theData)
      CFRelease(theData);
    goto LABEL_75;
  }
  LODWORD(v49) = 1;
  v47[0] = malloc_type_malloc(v19, 0x2A022FCBuLL);
  if (!v47[0])
  {
    _cg_jpeg_mem_term("writeOne", 506, "*** ERROR: malloc(%d) failed\n", v20);
    goto LABEL_69;
  }
  v21 = this[2];
  *((_QWORD *)&v42 + 1) = iioWriteCallback;
  *(_QWORD *)&v44 = v21;
  v22 = applejpeg_encode_set_options_file();
  if (LumaQuantizationTableFromImageIOQuality)
    CFRelease(LumaQuantizationTableFromImageIOQuality);
  if (ChromaQuantizationTableFromImageIOQuality)
    CFRelease(ChromaQuantizationTableFromImageIOQuality);
  if (theData)
    CFRelease(theData);
  if ((_DWORD)v22)
  {
    _cg_jpeg_mem_term("writeOne", 527, "*** ERROR applejpeg_encode_set_options_file returned: %d\n", v22);
  }
  else
  {
    iioWriteCallback(&__ptr, 2, this[2]);
    v38 = 0x4649464A1000E0FFLL;
    *(_WORD *)((char *)&v39 + 1) = 257;
    if (a3
      && IIODictionary::containsKey(a3, CFSTR("DPIHeight"))
      && IIODictionary::containsKey(a3, CFSTR("DPIWidth")))
    {
      FloatForKey = IIODictionary::getFloatForKey(a3, CFSTR("DPIWidth"));
      v24 = IIODictionary::getFloatForKey(a3, CFSTR("DPIHeight"));
      v25 = vcvtmd_s64_f64(FloatForKey + 0.5);
      v26 = vcvtmd_s64_f64(v24 + 0.5);
    }
    else
    {
      v25 = 72;
      v26 = 72;
    }
    WORD2(v39) = __rev16(v25);
    HIWORD(v39) = __rev16(v26);
    v40 = 0;
    iioWriteCallback(&v38, 18, this[2]);
    AppleJPEGWritePlugin::WriteExifData(this[2], a2, a3, v27);
    if (!IIODictionary::getBoolForKey(a3, CFSTR("kCGImageMetadataShouldExcludeXMP")))
    {
      IIODictionary::removeObjectForKeyGroup(a3, CFSTR("Software"), CFSTR("{TIFF}"));
      JPEGWritePlugin::WriteExtendedXMPData(this[2], a3, v29);
    }
    JPEGWritePlugin::WriteIPTCData(this[2], a2, a3, v28);
    JPEGWritePlugin::WriteICCData(this[2], a2, 0, v30);
    HIDWORD(v49) = 1;
    if (Model == kCGColorSpaceModelCMYK)
    {
      v66 = xmmword_18822AD00;
      iioWriteCallback(&v66, 16, this[2]);
    }
    if (v15)
    {
      v31 = 0;
      while (1)
      {
        Bytes = IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v47[0]);
        if (Bytes != v20)
        {
          _cg_jpeg_mem_term("writeOne", 591, "*** ERROR: CGImagePixelDataProviderGetBytes failed (%d/%d) - expected: %ld  got: %ld\n", v31, v15, v20, Bytes);
          goto LABEL_61;
        }
        if (Model == kCGColorSpaceModelCMYK)
        {
          v33 = v47[0];
          v34 = v20;
          do
          {
            *v33 = ~*v33;
            ++v33;
            --v34;
          }
          while (v34);
        }
        v22 = applejpeg_encode_image_row();
        if ((_DWORD)v22)
          break;
        if (++v31 == v15)
          goto LABEL_61;
      }
      _cg_jpeg_mem_term("writeOne", 602, "*** ERROR: applejpeg_encode_image_row  err = %d\n", v22);
    }
    else
    {
LABEL_61:
      v22 = 0;
    }
  }
LABEL_62:
  applejpeg_encode_destroy();
  if (v47[0])
    free(v47[0]);
  return v22;
}

void sub_18800B068(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x18800AF44);
  }
  _Unwind_Resume(a1);
}

__n128 AppleJPEGWritePlugin::WriteExifData(AppleJPEGWritePlugin *this, IIOImageWriteSession *SourceGeomColorSpace, IIOImagePixelDataProvider *a3, IIODictionary *a4)
{
  CGImage *Ref;
  CGImage *Thumb;
  CGImage *v9;
  const __CFData *JPEGDataFromImage;
  uint64_t v11;
  unsigned int v12;
  char *v13;
  BOOL v14;
  __n128 result;
  int __ptr;
  unint64_t v17;

  v17 = 0;
  __ptr = 57855;
  if (!this || !a3)
    return _cg_jpeg_mem_term("WriteExifData", 871, "*** WARNING: cannot write Exif data\n", a4);
  if (!IIODictionary::getBoolForKey(a3, CFSTR("kCGImageDestinationEmbedThumbnail")))
  {
    Thumb = 0;
    JPEGDataFromImage = 0;
    if (SourceGeomColorSpace)
      goto LABEL_5;
LABEL_7:
    v11 = 0;
    v12 = 0;
    goto LABEL_8;
  }
  Ref = (CGImage *)IIOImageSource::imageReadRef(SourceGeomColorSpace);
  Thumb = CGImageCreateThumb(Ref, 0xA0uLL);
  JPEGDataFromImage = AppleJPEGReadPlugin::CreateJPEGDataFromImage(SourceGeomColorSpace, a3, Thumb, v9);
  if (!SourceGeomColorSpace)
    goto LABEL_7;
LABEL_5:
  v11 = IIOImageSource::count(SourceGeomColorSpace);
  v12 = IIO_Reader::testHeaderSize(SourceGeomColorSpace);
  SourceGeomColorSpace = (IIOImageWriteSession *)IIOImagePlus::getSourceGeomColorSpace(SourceGeomColorSpace);
LABEL_8:
  if ((gIIODebugFlags & 0x2000000000000) != 0)
  {
    ImageIOLog("%s WriteExifData: writing Exif data\n", "-o- ");
    if ((gIIODebugFlags & 0x2000000000000) != 0)
      IIODebugOrientation("WriteExifData", 895, a3);
  }
  v13 = CreateExifBufferFromPropertiesJPEG(a3, v11, v12, SourceGeomColorSpace, JPEGDataFromImage, CFSTR("public.jpeg"), &v17);
  if (v13)
    v14 = v17 == 0;
  else
    v14 = 1;
  if (v14)
  {
    result = _cg_jpeg_mem_term("WriteExifData", 899, "*** WARNING: CreateExifBufferFromPropertiesJPEG returned NULL\n");
    if (!JPEGDataFromImage)
      goto LABEL_17;
    goto LABEL_16;
  }
  HIWORD(__ptr) = bswap32(v17 + 2) >> 16;
  iioWriteCallback(&__ptr, 4, this);
  iioWriteCallback(v13, v17, this);
  if (JPEGDataFromImage)
LABEL_16:
    CFRelease(JPEGDataFromImage);
LABEL_17:
  if (Thumb)
    CGImageRelease(Thumb);
  if (v13)
    free(v13);
  return result;
}

uint64_t AppleJPEGWritePlugin::writeAll(IIOImageDestination **this)
{
  IIOImageSource *PixelDataProviderAtIndex;
  const __CFDictionary **PropertiesAtIndex;
  uint64_t ContainerProperties;
  uint64_t v5;
  int v6;
  unsigned int BoolForKey;
  CGImage *Ref;
  CGImage *Thumb;
  CGImage *v10;
  const __CFData *JPEGDataFromImage;
  int v12;

  if (!IIOWritePlugin::getImageCount(this))
    return 4294967246;
  PixelDataProviderAtIndex = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
  PropertiesAtIndex = (const __CFDictionary **)IIOWritePlugin::getPropertiesAtIndex(this, 0);
  ContainerProperties = IIOWritePlugin::getContainerProperties(this);
  if (!PixelDataProviderAtIndex)
  {
    _cg_jpeg_mem_term("writeAll", 645, "*** iPixelDataProvider is nil");
    return 4294967246;
  }
  v5 = ContainerProperties;
  v6 = IIO_HardwareEncoderDefaultValue();
  BoolForKey = IIODictionary::containsKey((IIODictionary *)PropertiesAtIndex, CFSTR("kCGImageDestinationUseHardwareAcceleration"));
  if (BoolForKey)
    BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)PropertiesAtIndex, CFSTR("kCGImageDestinationUseHardwareAcceleration"));
  if (!v6 || v6 != 1 && !BoolForKey)
    return (*((uint64_t (**)(IIOImageDestination **, IIOImageSource *, const __CFDictionary **, uint64_t, _QWORD))*this
            + 3))(this, PixelDataProviderAtIndex, PropertiesAtIndex, v5, 0);
  if (IIODictionary::getBoolForKey((IIODictionary *)PropertiesAtIndex, CFSTR("kCGImageDestinationEmbedThumbnail")))
  {
    Ref = (CGImage *)IIOImageSource::imageReadRef(PixelDataProviderAtIndex);
    Thumb = CGImageCreateThumb(Ref, 0xA0uLL);
    JPEGDataFromImage = AppleJPEGReadPlugin::CreateJPEGDataFromImage(PixelDataProviderAtIndex, (IIOImagePixelDataProvider *)PropertiesAtIndex, Thumb, v10);
  }
  else
  {
    Thumb = 0;
    JPEGDataFromImage = 0;
  }
  if ((gIIODebugFlags & 0x1000000000) != 0)
    ImageIOLog("H   writeJpegWithHardwareEncoding\n");
  v12 = AppleJPEGWritePlugin::writeJpegWithHardwareEncoding((AppleJPEGWritePlugin *)this, this[2], PixelDataProviderAtIndex, JPEGDataFromImage, PropertiesAtIndex[1]);
  if (v12 && (gIIODebugFlags & 0x1000000000) != 0)
    ImageIOLog("H   writeJpegWithHardwareEncoding failed. Trying SW encode...\n");
  if (JPEGDataFromImage)
    CFRelease(JPEGDataFromImage);
  if (Thumb)
    CFRelease(Thumb);
  if (!v12)
    return 0;
  else
    return (*((uint64_t (**)(IIOImageDestination **, IIOImageSource *, const __CFDictionary **, uint64_t, _QWORD))*this
            + 3))(this, PixelDataProviderAtIndex, PropertiesAtIndex, v5, 0);
}

void sub_18800B428(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18800B40CLL);
}

uint64_t AppleJPEGWritePlugin::writeJpegWithHardwareEncoding(AppleJPEGWritePlugin *this, IIOImageWriteSession *a2, IIOImagePixelDataProvider *a3, const __CFData *a4, const __CFDictionary *a5)
{
  __IOSurface *v10;
  __IOSurface *v11;
  signed int PixelFormat;
  signed int v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  const __CFData *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  CFDataRef JpegDataFromIOSurface;
  const __CFAllocator *v32;
  __CFWriteStream *v33;
  __CFWriteStream *v34;
  __CFDictionary *MutableCopy;
  CFMutableDictionaryRef v36;
  CGColorSpace *SourceGeomColorSpace;
  CFDataRef v38;
  CFMutableDictionaryRef Mutable;
  const __CFData *v40;
  const __CFData *v41;
  const UInt8 *BytePtr;
  size_t Length;
  IIOImageWriteSession *v45;
  void *value;
  _QWORD v47[3];

  v10 = AppleJPEGWritePlugin::copyIOSurfaceFromPixelProvider(this, a3);
  if (v10)
  {
    v11 = v10;
    PixelFormat = IOSurfaceGetPixelFormat(v10);
    if ((gIIODebugFlags & 0x1000000000) != 0)
    {
      v13 = PixelFormat;
      v14 = PixelFormat >> 24;
      v15 = MEMORY[0x1E0C80978];
      if (PixelFormat < 0)
      {
        v18 = MEMORY[0x1E0C80978];
        v16 = __maskrune(PixelFormat >> 24, 0x40000uLL);
        v15 = v18;
      }
      else
      {
        v16 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v14 + 60) & 0x40000;
      }
      if (v16)
        v19 = v14;
      else
        v19 = 46;
      v20 = v13 << 8 >> 24;
      v45 = a2;
      if (v13 << 8 < 0)
      {
        v22 = v15;
        v21 = __maskrune(v13 << 8 >> 24, 0x40000uLL);
        v15 = v22;
      }
      else
      {
        v21 = *(_DWORD *)(v15 + 4 * v20 + 60) & 0x40000;
      }
      if (v21)
        v23 = v20;
      else
        v23 = 46;
      v24 = (__int16)v13 >> 8;
      v25 = a4;
      if (v13 << 16 < 0)
      {
        v27 = v15;
        v26 = __maskrune((__int16)v13 >> 8, 0x40000uLL);
        v15 = v27;
      }
      else
      {
        v26 = *(_DWORD *)(v15 + 4 * v24 + 60) & 0x40000;
      }
      if (v26)
        v28 = v24;
      else
        v28 = 46;
      if ((v13 << 24) <= 0x7F000000)
        v29 = *(_DWORD *)(v15 + 4 * (char)v13 + 60) & 0x40000;
      else
        v29 = __maskrune((char)v13, 0x40000uLL);
      if (v29)
        v30 = (char)v13;
      else
        v30 = 46;
      ImageIOLog("H   copyIOSurfaceFromPixelProvider - <IOSurface:%p> '%c%c%c%c'\n", v11, v19, v23, v28, v30);
      a2 = v45;
      a4 = v25;
    }
    memset(v47, 0, sizeof(v47));
    IIODictionary::IIODictionary((IIODictionary *)v47, a5);
    JpegDataFromIOSurface = AppleJPEGWritePlugin::createJpegDataFromIOSurface(this, v11, (IIODictionary *)v47);
    if (!JpegDataFromIOSurface)
    {
      v17 = 0;
LABEL_67:
      IIO_IOSurfaceRelease(v11);
      IIODictionary::~IIODictionary((IIODictionary *)v47);
      return v17;
    }
    v32 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v33 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
    v34 = v33;
    if (!v33)
    {
      v17 = 0;
LABEL_66:
      CFRelease(JpegDataFromIOSurface);
      goto LABEL_67;
    }
    if (!CFWriteStreamOpen(v33))
    {
      v17 = 0;
LABEL_65:
      CFRelease(v34);
      goto LABEL_66;
    }
    value = 0;
    if (a5)
    {
      if (CFDictionaryGetValueIfPresent(a5, CFSTR("{MetaData}"), (const void **)&value)
        && (MutableCopy = CFDictionaryCreateMutableCopy(v32, 0, a5)) != 0)
      {
        CFRetain(value);
        CFDictionaryRemoveValue(MutableCopy, CFSTR("{MetaData}"));
        v36 = MutableCopy;
      }
      else
      {
        v36 = 0;
        MutableCopy = a5;
      }
    }
    else
    {
      MutableCopy = 0;
      v36 = 0;
    }
    SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a3);
    if (CGColorSpaceGetType() != 6 && CGColorSpaceGetType() != 10
      || IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E0C9DA10])
      || (v38 = CGColorSpaceCopyICCData(SourceGeomColorSpace)) == 0)
    {
LABEL_54:
      if (CGImageWriteEXIFJPEGWithMetadata(v34, JpegDataFromIOSurface, a4, MutableCopy, (const CGImageMetadata *)value, 0)&& (v40 = (const __CFData *)CFWriteStreamCopyProperty(v34, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]), (v41 = v40) != 0))
      {
        BytePtr = CFDataGetBytePtr(v40);
        Length = CFDataGetLength(v41);
        if (IIOImageWriteSession::putBytes(a2, BytePtr, Length) == Length)
        {
          v17 = 0;
        }
        else
        {
          _cg_jpeg_mem_term("writeJpegWithHardwareEncoding", 824, "*** ERROR: failed to write %ld bytes\n", Length);
          v17 = 4294967246;
        }
        CFRelease(v41);
      }
      else
      {
        v17 = 0;
      }
      if (v36)
        CFRelease(v36);
      if (value)
        CFRelease(value);
      goto LABEL_65;
    }
    if (!MutableCopy || v36)
    {
      if ((unint64_t)MutableCopy | (unint64_t)v36)
      {
LABEL_51:
        if (v36)
          CFDictionarySetValue(v36, CFSTR("kCGImageDestinationICCProfile"), v38);
        CFRelease(v38);
        goto LABEL_54;
      }
      Mutable = CFDictionaryCreateMutable(v32, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    else
    {
      Mutable = CFDictionaryCreateMutableCopy(v32, 0, MutableCopy);
    }
    MutableCopy = Mutable;
    v36 = Mutable;
    goto LABEL_51;
  }
  return 0;
}

void sub_18800B84C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *createQuantizationTableFromPropertiesForComponentIndex(IIODictionary *a1, unsigned int a2)
{
  const __CFDictionary *result;
  const __CFData *ValueAtIndex;
  BOOL v5;
  const __CFData *v6;
  CFTypeID v7;
  const UInt8 *BytePtr;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  int8x16_t *v14;
  int8x16_t v15;
  int8x16_t v16;
  _OWORD v17[8];
  UInt8 bytes[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = IIODictionary::getObjectForKeyGroup(a1, CFSTR("Quantization"), CFSTR("{JPEG}"));
  if (result)
  {
    ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(result, a2);
    if (ValueAtIndex)
      v5 = ValueAtIndex == (const __CFData *)*MEMORY[0x1E0C9B0D0];
    else
      v5 = 1;
    if (!v5
      && (v6 = ValueAtIndex, v7 = CFGetTypeID(ValueAtIndex), v7 == CFDataGetTypeID())
      && CFDataGetLength(v6) == 128)
    {
      v20 = 0u;
      v21 = 0u;
      *(_OWORD *)bytes = 0u;
      v19 = 0u;
      BytePtr = CFDataGetBytePtr(v6);
      v9 = 0;
      v10 = *((_OWORD *)BytePtr + 5);
      v17[4] = *((_OWORD *)BytePtr + 4);
      v17[5] = v10;
      v11 = *((_OWORD *)BytePtr + 7);
      v17[6] = *((_OWORD *)BytePtr + 6);
      v17[7] = v11;
      v12 = *((_OWORD *)BytePtr + 1);
      v17[0] = *(_OWORD *)BytePtr;
      v17[1] = v12;
      v13 = *((_OWORD *)BytePtr + 3);
      v14 = (int8x16_t *)v17;
      v17[2] = *((_OWORD *)BytePtr + 2);
      v17[3] = v13;
      do
      {
        v16 = *v14;
        v15 = v14[1];
        v14 += 2;
        *(int8x16_t *)&bytes[v9] = vuzp1q_s8(v16, v15);
        v9 += 16;
      }
      while (v9 != 64);
      return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 64);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void IIO_Writer_AppleJPEG::~IIO_Writer_AppleJPEG(IIO_Writer_AppleJPEG *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t IIO_Writer_AppleJPEG::write(IIO_Writer_AppleJPEG *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v3;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  JPEGWritePlugin::JPEGWritePlugin((JPEGWritePlugin *)v5, a2, a3, 0xDu);
  *(_QWORD *)&v5[0] = &off_1E1BB1DB8;
  v3 = AppleJPEGWritePlugin::writeAll((IIOImageDestination **)v5);
  JPEGWritePlugin::~JPEGWritePlugin((JPEGWritePlugin *)v5);
  return v3;
}

void sub_18800BA34(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  JPEGWritePlugin::~JPEGWritePlugin((JPEGWritePlugin *)&a9);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18800BA20);
}

uint64_t IIO_Writer_AppleJPEG::canWriteDepth(IIO_Writer_AppleJPEG *this)
{
  return 1;
}

_QWORD *pvrtcCompress(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5, _DWORD *a6)
{
  int v6;
  uint64_t v12;
  unsigned int v13;
  size_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  char v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unsigned int v42;
  int v43;
  unsigned int v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  unint64_t v57;
  int v58;
  int v59;
  unsigned int v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  unsigned __int8 *v68;
  unsigned __int8 *v69;
  _QWORD *v70;
  int v71;
  int v72;
  uint64_t v73;
  int v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  void *v81;
  unsigned __int8 *v82;
  unsigned __int8 *v83;
  unsigned __int8 *v84;

  v6 = *(_BYTE *)(a1 + 8) & 7;
  if (v6 == 4 || v6 == 2)
  {
    v83 = 0;
    v84 = 0;
    v81 = 0;
    v82 = 0;
    v67 = v6;
    v61 = a3 >> 2;
    v62 = a3 >> 3;
    if (v6 == 2)
      v12 = a3 >> 3;
    else
      v12 = a3 >> 2;
    v13 = a4 >> 2;
    v73 = v12;
    v14 = 8 * (a4 >> 2) * v12;
    *a6 = v14;
    v70 = malloc_type_malloc(v14, 0x2AF610E3uLL);
    pvrtcCompressUnpacked(a1, a2, a3, a4, v15, &v84, &v83, (uint64_t *)&v82, (uint64_t *)&v81);
    v16 = v82;
    v68 = v84;
    v69 = v83;
    v75 = v81;
    if (a4 < 4)
    {
LABEL_82:
      free(v68);
      free(v69);
      free(v16);
      free(v75);
      return v70;
    }
    v74 = 0;
    v72 = v73 - 1;
    v66 = 31 - __clz(v73);
    if (v13 <= 1)
      v17 = 1;
    else
      v17 = v13;
    v63 = v17;
    v64 = 0;
LABEL_14:
    if (!(_DWORD)v73)
      goto LABEL_81;
    v18 = 0;
    v79 = 0;
    v19 = (v74 & v72 | ((v74 & v72) << 8)) & 0xFF00FF;
    v20 = (v19 | (16 * v19)) & 0x3030303 | (4 * ((v19 | (16 * v19)) & 0xF0F0F0F)) & 0x33333333;
    v71 = (v20 | (2 * v20)) & 0x55555555;
    v21 = 4 * v74;
    v65 = v74 * v62;
    v78 = v64;
LABEL_16:
    v77 = v18;
    if (v67 == 2)
    {
      v22 = *((_BYTE *)v75 + (v65 + v18));
      if (!v22)
      {
        v32 = 0;
        v31 = 0;
        v33 = 8 * v18;
        do
        {
          if (v16[4 * (v32 & 7 | v33) + 4 * (v21 + (v32 >> 3)) * a3] != 255)
          {
            if (v16[4 * (v32 & 7 | v33) + 4 * (v21 + (v32 >> 3)) * a3])
              printf("Bad threshold mod value %d (this isn't supposed to happen!)\n", v16[4 * (v32 & 7 | v33) + 4 * (v21 + (v32 >> 3)) * a3]);
            else
              v31 |= 1 << v32;
          }
          ++v32;
        }
        while (v32 != 32);
        goto LABEL_74;
      }
      if (v21 == 2147483644)
      {
        v23 = 0;
        if ((*((_BYTE *)v75 + (v65 + v18)) & 2) == 0)
          goto LABEL_72;
LABEL_20:
        v24 = v23 & 0xFFFFFFFFFFEFFFFFLL | ((v22 & 1) << 20) | 1;
        goto LABEL_73;
      }
      v76 = (v65 + v18);
      v37 = 0;
      v23 = 0;
      v80 = 8 * v18;
      v38 = 8 * v18 + 8;
      v39 = v78;
      v40 = 4 * v74;
      while (1)
      {
        v41 = v40 & 1;
        if ((v41 | v80) < v38)
          break;
LABEL_70:
        ++v40;
        v39 += a3;
        if (v40 >= v21 + 4)
        {
          v22 = *((_BYTE *)v75 + v76);
          LODWORD(v18) = v77;
          if ((v22 & 2) != 0)
            goto LABEL_20;
LABEL_72:
          v24 = v23 & 0xFFFFFFFFFFFFFFFELL;
LABEL_73:
          v31 = v24 | 0x100000000;
LABEL_74:
          v47 = (4 * (v74 * v73 + v18));
          v48 = v69[v47];
          v49 = v69[v47 | 1];
          v50 = v69[v47 | 2];
          v51 = v69[v47 | 3];
          if (v51 == 255)
          {
            checkBitReplication(v48, 5, 0);
            checkBitReplication(v49, 5, 0);
            checkBitReplication(v50, 4, 1);
            v52 = (v49 << 34) & 0x3E000000000 | ((unint64_t)(v48 >> 3) << 42) | ((unint64_t)(v50 >> 4) << 33) | v31 | 0x800000000000;
          }
          else
          {
            checkBitReplication(v48, 4, 1);
            checkBitReplication(v49, 4, 1);
            checkBitReplication(v50, 3, 2);
            v52 = (v48 << 36) & 0xF0000000000 | ((unint64_t)(v49 >> 4) << 36) & 0xFFFF8FFFFFFFFFFFLL | ((unint64_t)(v50 >> 5) << 33) & 0xFFFF8FFFFFFFFFFFLL | ((unint64_t)(v51 >> 5) << 44) | v31;
          }
          v53 = v68[v47];
          v54 = v68[v47 | 1];
          v55 = v68[v47 | 2];
          v56 = v68[v47 | 3];
          if (v56 == 255)
          {
            checkBitReplication(v53, 5, 0);
            checkBitReplication(v54, 5, 0);
            checkBitReplication(v55, 5, 0);
            v57 = (v54 << 50) & 0x3E0000000000000 | ((unint64_t)(v53 >> 3) << 58) | ((unint64_t)(v55 >> 3) << 48) | v52 | 0x8000000000000000;
          }
          else
          {
            checkBitReplication(v53, 4, 1);
            checkBitReplication(v54, 4, 1);
            checkBitReplication(v55, 4, 1);
            v57 = (v53 << 52) & 0xF00000000000000 | ((unint64_t)(v54 >> 4) << 52) & 0x8FFFFFFFFFFFFFFFLL | ((unint64_t)(v55 >> 4) << 48) & 0x8FFFFFFFFFFFFFFFLL | ((unint64_t)(v56 >> 5) << 60) | v52;
          }
          v58 = (v72 & v77 | ((v72 & v77) << 8)) & 0xFF00FF;
          v59 = (v58 | (16 * v58)) & 0x3030303 | (4 * ((v58 | (16 * v58)) & 0xF0F0F0F)) & 0x33333333;
          v70[(((v74 | v77) & -(int)v73) << v66) | v71 | ((4 * v59) | (2 * v59)) & 0xAAAAAAAA] = v57;
          v18 = v77 + 1;
          v78 += 8;
          v79 += 8;
          if (v77 + 1 == v73)
          {
LABEL_81:
            v64 += 4 * a3;
            if (++v74 == v63)
              goto LABEL_82;
            goto LABEL_14;
          }
          goto LABEL_16;
        }
      }
      v42 = 4 * (v39 + v41);
      v43 = v79 + v41;
      while (1)
      {
        v44 = v16[v42];
        if (v44 <= 0x9E)
          break;
        if (v44 == 159)
        {
          v45 = 2 * v37++;
          v46 = 1;
LABEL_67:
          v23 |= v46 << v45;
          goto LABEL_69;
        }
        if (v44 != 255)
        {
LABEL_68:
          printf("Bad checkerboard mod value %d (this isn't supposed to happen!)\n", v16[v42]);
          goto LABEL_69;
        }
        ++v37;
LABEL_69:
        v42 += 8;
        v43 += 2;
        if (v38 <= v43)
          goto LABEL_70;
      }
      if (v16[v42])
      {
        if (v44 != 95)
          goto LABEL_68;
        v45 = 2 * v37++;
        v46 = 2;
      }
      else
      {
        v45 = 2 * v37++;
        v46 = 3;
      }
      goto LABEL_67;
    }
    v25 = 4 * v18;
    v26 = 0;
    if (*((_BYTE *)v75 + v74 * v61 + v18))
    {
      v27 = 0;
      v28 = 0;
      while (1)
      {
        v29 = v16[4 * (v27 & 3 | v25) + 4 * (v21 + (v27 >> 2)) * a3];
        if (v29 <= 0x7F)
          break;
        if (v29 == 128)
        {
          v30 = 2;
          goto LABEL_32;
        }
        if (v29 != 255)
          goto LABEL_29;
LABEL_33:
        ++v27;
        v26 += 2;
        if (v27 == 16)
        {
          v31 = v28 | 0x100000000;
          goto LABEL_74;
        }
      }
      if (!v16[4 * (v27 & 3 | v25) + 4 * (v21 + (v27 >> 2)) * a3])
      {
        v30 = 3;
        goto LABEL_32;
      }
      if (v29 == 127)
      {
        v30 = 1;
LABEL_32:
        v28 |= v30 << v26;
        goto LABEL_33;
      }
LABEL_29:
      printf("Bad mod value %d (this isn't supposed to happen!)\n", v16[4 * (v27 & 3 | v25) + 4 * (v21 + (v27 >> 2)) * a3]);
      goto LABEL_33;
    }
    v34 = 0;
    v31 = 0;
    while (1)
    {
      v35 = v16[4 * (v34 & 3 | v25) + 4 * (v21 + (v34 >> 2)) * a3];
      if (v35 <= 0x9E)
        break;
      if (v35 == 159)
      {
        v36 = 1;
        goto LABEL_52;
      }
      if (v35 != 255)
        goto LABEL_49;
LABEL_53:
      ++v34;
      v26 += 2;
      if (v34 == 16)
        goto LABEL_74;
    }
    if (!v16[4 * (v34 & 3 | v25) + 4 * (v21 + (v34 >> 2)) * a3])
    {
      v36 = 3;
      goto LABEL_52;
    }
    if (v35 == 95)
    {
      v36 = 2;
LABEL_52:
      v31 |= v36 << v26;
      goto LABEL_53;
    }
LABEL_49:
    printf("Bad mod value %d (this isn't supposed to happen!)\n", v16[4 * (v34 & 3 | v25) + 4 * (v21 + (v34 >> 2)) * a3]);
    goto LABEL_53;
  }
  return 0;
}

void pvrtcCompressUnpacked(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5, _QWORD *a6, _QWORD *a7, uint64_t *a8, uint64_t *a9)
{
  int v9;
  char v11;
  uint64_t v14;
  void *(*v15)(const unsigned __int8 *, unsigned int, unsigned int);
  unsigned int v16;
  uint64_t (*v17)(uint64_t, float *, unsigned int, unsigned int, int, int);
  float (*v18)(float *, float *, unsigned int, unsigned int, int, int);
  uint64_t (*v19)(uint64_t, uint64_t, unsigned int, unsigned int, int, int, float);
  unsigned __int8 *v20;
  float *v21;
  unsigned __int8 *v22;
  float *v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  size_t v27;
  float *v28;
  float *v29;
  unsigned __int8 *v30;
  float *v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  float32x4_t *v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t n;
  float *v45;
  float *v46;
  float *v47;
  unsigned int v48;
  unsigned int v49;
  float v50;
  unsigned int v51;
  int v52;
  unint64_t v53;
  int v54;
  int v55;
  int v56;
  float32x4_t v57;
  int v58;
  int32x2_t v59;
  uint64_t v60;
  int v61;
  int v62;
  char *v63;
  int v64;
  int v65;
  int v66;
  int v67;
  float v68;
  float32x4_t v69;
  unint64_t v70;
  float32x4_t v71;
  float v72;
  uint64_t v73;
  int v74;
  float32x4_t *v75;
  float v76;
  float v77;
  float v78;
  double v79;
  float *v80;
  float v81;
  float v82;
  float v83;
  uint64_t v84;
  float v85;
  float *v86;
  float v87;
  float v88;
  float v89;
  float *v90;
  float v91;
  float v92;
  float v94;
  float v95;
  float *v96;
  float v97;
  float v98;
  int v99;
  float v100;
  uint64_t v101;
  float v102;
  float v103;
  float v104;
  uint64_t v105;
  float v106;
  float v107;
  float v108;
  float v109;
  int v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float *v122;
  uint64_t v123;
  unsigned __int8 *v124;
  float *v125;
  uint64_t v126;
  unsigned int v127;
  void *v128;
  void *v129;
  void *v130;
  void *v131;
  void *v132;
  void *v133;
  int32x4_t v134;
  int32x4_t v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  uint64_t v139;
  int v140;
  float v141;
  float v142;
  uint64_t v143;
  float v151;
  float v152;
  uint64_t v153;
  float *v154;
  float *v155;
  char *v156;
  char *v157;
  unsigned int v158;
  void (*v159)(void *, float32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v160;
  uint64_t v161;
  uint64_t v162;
  int32x4_t v163;
  int32x4_t v164;
  int v165;
  void (*v166)(float32x4_t *, uint64_t, uint64_t, uint64_t);
  uint64_t v167;
  uint64_t v168;
  unsigned int v169;
  uint64_t ii;
  int v171;
  uint64_t v172;
  char *v173;
  char *v174;
  uint64_t v175;
  float v176;
  uint64_t jj;
  uint64_t v178;
  float *v179;
  float *v180;
  float v181;
  float v182;
  float v183;
  float v184;
  float v185;
  float v186;
  size_t count;
  unsigned __int8 *v188;
  int v192;
  size_t v193;
  void (*v194)(void *, float32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  void (*v195)(float32x4_t *, uint64_t, uint64_t, uint64_t);
  uint64_t v196;
  int v197;
  int v198;
  int v199;
  int v200;
  int v201;
  uint64_t v202;
  _BYTE *v203;
  uint64_t v204;
  _BYTE *v205;
  uint64_t v206;
  uint64_t v207;
  float *v208;
  void *v209;
  float *v210;
  void *v211;
  char v212;
  uint64_t v213;
  int v214;
  void *v215;
  uint64_t v216;
  void (*v217)(float32x4_t *, uint64_t, uint64_t, uint64_t);
  size_t size;
  float v220;
  void *v221;
  unsigned int __K;
  int __Ka;
  int __Kb[2];
  float *v225;
  void *v226;
  unsigned int v227;
  unint64_t v228;
  int v229;
  int v230;
  __CLPK_integer __info;
  __CLPK_integer __lwork;
  __CLPK_integer __lda;
  __CLPK_integer __n;
  __CLPK_real __work[4];
  _BYTE v236[28];
  _OWORD v237[26];
  int v238;
  _OWORD __Y[26];
  int v240;
  __CLPK_real __w[2];
  uint64_t v242;
  _OWORD __C[4];
  float32x4_t v244;
  float __A[420];
  uint64_t v246;

  v246 = *MEMORY[0x1E0C80C00];
  v9 = *(_BYTE *)(a1 + 8) & 7;
  if (v9 != 4 && v9 != 2)
    return;
  if (v9 == 2)
    v11 = 3;
  else
    v11 = 2;
  v212 = v11;
  if ((a3 & ((_DWORD)a3 - 1)) != 0 || (a4 & (a4 - 1)) != 0)
  {
    *a6 = 0;
    *a7 = 0;
    *a8 = 0;
    *a9 = 0;
    return;
  }
  v14 = a3 >> v11;
  v208 = *(float **)a1;
  v15 = lanczosDownsample4;
  v16 = a4 >> 2;
  v192 = *(_BYTE *)(a1 + 8) & 7;
  if (v9 == 2)
  {
    v15 = lanczosDownsample84;
    v17 = bilinearUpsample84f;
  }
  else
  {
    v17 = bilinearUpsample4f;
  }
  v217 = (void (*)(float32x4_t *, uint64_t, uint64_t, uint64_t))v17;
  if (v9 == 2)
    v18 = bilinearUpsample84fq;
  else
    v18 = bilinearUpsample4fq;
  if (v9 == 2)
    v19 = errorAccumulateBilinear84;
  else
    v19 = errorAccumulateBilinear4;
  v227 = a3;
  v20 = (unsigned __int8 *)((uint64_t (*)(unsigned __int8 *, uint64_t))v15)(a2, a3);
  v216 = v14;
  __K = v16;
  size = v14 * v16;
  v21 = (float *)malloc_type_calloc((4 * size), 4uLL, 0x100004052888210uLL);
  v193 = (4 * size);
  if ((_DWORD)v193)
  {
    v22 = v20;
    v23 = v21;
    v24 = (4 * size);
    do
    {
      v25 = *v22++;
      *v23++ = (float)v25;
      --v24;
    }
    while (v24);
  }
  v225 = v21;
  free(v20);
  v26 = a4 * v227;
  v27 = (4 * v26);
  v28 = (float *)malloc_type_calloc(v27, 4uLL, 0x100004052888210uLL);
  v29 = v28;
  if ((_DWORD)v27)
  {
    v30 = a2;
    v31 = v28;
    v32 = (4 * v26);
    do
    {
      v33 = *v30++;
      *v31++ = (float)v33;
      --v32;
    }
    while (v32);
  }
  if ((_DWORD)v26)
  {
    for (i = 0; i != v26; ++i)
    {
      for (j = 0; j != 4; ++j)
        v28[4 * (i & 0x3FFFFFFF) + j] = v208[j] * v28[4 * (i & 0x3FFFFFFF) + j];
    }
  }
  v194 = (void (*)(void *, float32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t))v19;
  if ((_DWORD)size)
  {
    for (k = 0; k != size; ++k)
    {
      for (m = 0; m != 4; ++m)
        v225[4 * (k & 0x3FFFFFFF) + m] = v208[m] * v225[4 * (k & 0x3FFFFFFF) + m];
    }
  }
  count = (4 * v26);
  v188 = a2;
  v195 = (void (*)(float32x4_t *, uint64_t, uint64_t, uint64_t))v18;
  v196 = a1;
  v38 = (float32x4_t *)malloc_type_malloc(4 * v27, 0x100004052888210uLL);
  v39 = v227;
  if (a4)
  {
    v40 = 0;
    v41 = 0;
    do
    {
      if (v39)
      {
        v42 = 0;
        v43 = v40;
        do
        {
          *(_OWORD *)__A = 0uLL;
          ((void (*)(float *, float *))v217)(__A, v225);
          for (n = 0; n != 4; ++n)
            v38->f32[v43 + n] = v29[v43 + n] - __A[n];
          ++v42;
          v43 += 4;
          v39 = v227;
        }
        while (v42 != v227);
      }
      ++v41;
      v40 += 4 * v227;
    }
    while (v41 != a4);
  }
  free(v29);
  v210 = (float *)malloc_type_malloc(4 * v193, 0x100004052888210uLL);
  v45 = (float *)malloc_type_malloc(4 * v193, 0x100004052888210uLL);
  v46 = (float *)malloc_type_malloc(4 * v193, 0x100004052888210uLL);
  v47 = v225;
  if (a4 >= 4)
  {
    v200 = 0;
    v201 = 0;
    v48 = a4 + 0x3FFFFFFF;
    if (v192 == 2)
      v49 = 8;
    else
      v49 = 4;
    if (v192 == 2)
      v50 = 0.03125;
    else
      v50 = 0.0625;
    if (v192 == 2)
      v51 = 105;
    else
      v51 = 49;
    v52 = __K;
    if (__K <= 1)
      v52 = 1;
    v197 = v52;
    v204 = 16 * v51;
    __Ka = v51;
    v202 = 4 * v51;
    while (!(_DWORD)v216)
    {
LABEL_128:
      v200 += 4 * v216;
      if (++v201 == v197)
        goto LABEL_129;
    }
    v53 = 0;
    v214 = v201 * v216;
    v54 = (v201 + 0x3FFFFFFF) * v216;
    v198 = v54 + 1;
    v199 = v54 + 0x3FFFFFFF;
    v55 = v200;
    while (1)
    {
      v228 = v53;
      bzero(__A, 0x690uLL);
      v56 = 0;
      v244 = 0uLL;
      memset(__C, 0, sizeof(__C));
      v242 = 0;
      *(_QWORD *)__w = 0;
      v240 = 0;
      memset(__Y, 0, sizeof(__Y));
      v238 = 0;
      memset(v237, 0, sizeof(v237));
      __n = 4;
      __lda = 4;
      __lwork = 11;
      __info = 0;
      v57 = 0uLL;
      v58 = -3;
      v59.i32[0] = 0;
      *(_OWORD *)__work = 0u;
      memset(v236, 0, sizeof(v236));
      do
      {
        v60 = 0;
        if (v58 >= 0)
          v61 = v58;
        else
          v61 = -v58;
        v62 = 4 - v61;
        v63 = (char *)v237 + 4 * v56;
        v64 = 4 * v56;
        v65 = 2 * v49 - 1;
        v66 = 1 - v49;
        do
        {
          if (v66 >= 0)
            v67 = v66;
          else
            v67 = -v66;
          v68 = v50 * (float)(int)((v49 - v67) * v62);
          *(float *)&v63[v60] = v68;
          v69 = vmulq_n_f32(v38[(((v49 >> 1) + ((_DWORD)v228 << v212) + v66) & (v227 + 0x3FFFFFFF))+ ((((4 * v201) | 2) + v58) & v48) * v227], v68);
          __A[v64 + (int)v60] = v69.f32[0];
          __A[v64 + 1 + (int)v60] = v69.f32[1];
          __A[v64 + 2 + (int)v60] = v69.f32[2];
          __A[v64 + 3 + (int)v60] = v69.f32[3];
          *(float *)v59.i32 = *(float *)v59.i32 + v68;
          ++v56;
          v57 = vaddq_f32(v69, v57);
          ++v66;
          v60 += 4;
          --v65;
        }
        while (v65);
        ++v58;
      }
      while (v58 != 4);
      v70 = 0;
      v220 = *(float *)v59.i32;
      v71 = vdivq_f32(v57, (float32x4_t)vdupq_lane_s32(v59, 0));
      v244 = v71;
      do
      {
        *(float32x4_t *)&__A[v70 / 4] = vsubq_f32(*(float32x4_t *)&__A[v70 / 4], v71);
        v70 += 16;
      }
      while (v204 != v70);
      v72 = 0.0;
      cblas_ssyrk(CblasColMajor, CblasUpper, CblasNoTrans, 4, __Ka, 1.0, __A, 4, 0.0, (float *)__C, 4);
      ssyev_("V", "U", &__n, (__CLPK_real *)__C, &__lda, __w, __work, &__lwork, &__info);
      v73 = 0;
      v74 = 0;
      do
      {
        if (__w[v73] > v72)
        {
          v72 = __w[v73];
          v74 = v73;
        }
        ++v73;
      }
      while (v73 != 4);
      v75 = (float32x4_t *)((char *)__C + 4 * (4 * v74));
      v76 = v75->f32[0];
      v77 = v75->f32[1];
      v78 = v75->f32[2];
      v79 = (float)((float)(v75->f32[0] + v77) + v78);
      if (v79 > 0.15)
        goto LABEL_112;
      if (v79 >= -0.15)
      {
        if (v201 | v228)
        {
          if (v228)
          {
            v80 = &v210[(4 * (v201 * v216 + 0x3FFFFFFF + v228))];
            v81 = (float)((float)((float)(v77 * v80[1]) + (float)(v76 * *v80)) + (float)(v78 * v80[2]))
                + (float)(v75->f32[3] * v80[3]);
            v82 = 0.0;
            if (v81 <= 0.2)
              v83 = 0.0;
            else
              v83 = v81 + 0.0;
            if (v81 < 0.2)
              v82 = 0.0 - v81;
          }
          else
          {
            v83 = 0.0;
            v82 = 0.0;
          }
          if (v201)
          {
            v86 = &v210[(4 * ((v201 + 0x3FFFFFFF) * v216 + v228))];
            v87 = v75->f32[3];
            v88 = (float)((float)((float)(v77 * v86[1]) + (float)(v76 * *v86)) + (float)(v78 * v86[2]))
                + (float)(v87 * v86[3]);
            if (v88 <= 0.2)
              v89 = -0.0;
            else
              v89 = (float)((float)((float)(v77 * v86[1]) + (float)(v76 * *v86)) + (float)(v78 * v86[2]))
                  + (float)(v87 * v86[3]);
            v83 = v83 + v89;
            if (v88 >= 0.2)
              v88 = 0.0;
            v82 = v82 - v88;
            if (v228)
            {
              v90 = &v210[(4 * (v199 + v228))];
              v91 = v90[3];
              v92 = (float)((float)((float)(v77 * v90[1]) + (float)(v76 * *v90)) + (float)(v78 * v90[2]))
                  + (float)(v87 * v91);
              _NF = v92 < 0.2;
              v94 = v92 <= 0.2
                  ? -0.0
                  : (float)((float)((float)(v77 * v90[1]) + (float)(v76 * *v90)) + (float)(v78 * v90[2]))
                  + (float)(v87 * v91);
              v83 = v83 + v94;
              v95 = v82 - v92;
              if (_NF)
                v82 = v95;
            }
            if (v228 < (v216 - 1))
            {
              v96 = &v210[(4 * (v198 + v228))];
              v97 = (float)((float)((float)(v77 * v96[1]) + (float)(v76 * *v96)) + (float)(v78 * v96[2]))
                  + (float)(v87 * v96[3]);
              v98 = v97 <= 0.2 ? -0.0 : v97;
              v83 = v83 + v98;
              if (v97 < 0.2)
                v82 = v82 - v97;
            }
          }
          if (v83 + 0.3 >= v82)
            goto LABEL_112;
        }
        else
        {
          v84 = 0;
          v85 = 0.0;
          do
          {
            if (fabsf(v75->f32[v84]) > fabsf(v85))
              v85 = v75->f32[v84];
            ++v84;
          }
          while (v84 != 4);
          if (v85 >= 0.0)
            goto LABEL_112;
        }
      }
      *v75 = vnegq_f32(*v75);
      v76 = v75->f32[0];
LABEL_112:
      v99 = v214 + v228;
      v210[(4 * (v214 + v228))] = v76;
      v210[(4 * v99) | 1] = v75->f32[1];
      v210[(4 * v99) | 2] = v75->f32[2];
      v210[(4 * v99) | 3] = v75->f32[3];
      v100 = 0.0;
      cblas_sgemv(CblasRowMajor, CblasNoTrans, __Ka, 4, 1.0, __A, 4, v75->f32, 1, 0.0, (float *)__Y, 1);
      v101 = 0;
      v102 = 0.0;
      do
      {
        v103 = *(float *)((char *)__Y + v101);
        v104 = *(float *)((char *)v237 + v101);
        v102 = v102 + (float)(v103 * v104);
        v100 = v100 + (float)((float)(v103 * v103) * v104);
        v101 += 4;
      }
      while (v202 != v101);
      v105 = 0;
      v106 = v102 / v220;
      v107 = sqrtf((float)(v100 / v220) - (float)(v106 * v106)) * 1.312;
      v108 = (float)(v102 / v220) - v107;
      v109 = v106 + v107;
      v47 = v225;
      do
      {
        v110 = v55 + v105;
        v111 = v225[(v55 + v105)] + v244.f32[v105];
        v112 = v75->f32[v105];
        v113 = v111 + (float)(v108 * v112);
        v114 = v208[v105];
        v115 = v111 + (float)(v109 * v112);
        v116 = v113 / v114;
        v117 = v115 / v114;
        v118 = 255.0;
        if (v116 <= 255.0)
          v119 = v116;
        else
          v119 = 255.0;
        if (v116 >= 0.0)
          v120 = v119;
        else
          v120 = 0.0;
        if (v117 <= 255.0)
          v118 = v117;
        if (v117 >= 0.0)
          v121 = v118;
        else
          v121 = 0.0;
        v45[v110] = v120;
        v46[v110] = v121;
        ++v105;
      }
      while (v105 != 4);
      v53 = v228 + 1;
      v55 += 4;
      v48 = a4 + 0x3FFFFFFF;
      if (v228 + 1 == v216)
        goto LABEL_128;
    }
  }
LABEL_129:
  free(v47);
  free(v38);
  free(v210);
  v122 = (float *)malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
  v123 = (uint64_t)v122;
  v124 = v188;
  if ((_DWORD)count)
  {
    v125 = v122;
    v126 = (4 * v26);
    do
    {
      v127 = *v124++;
      *v125++ = (float)v127;
      --v126;
    }
    while (v126);
  }
  v128 = malloc_type_malloc(count, 0x100004077774924uLL);
  v129 = malloc_type_malloc(size, 0x100004077774924uLL);
  v130 = malloc_type_malloc(4 * a4 * v227, 0x100004052888210uLL);
  v131 = malloc_type_malloc(20 * a4 * v227, 0x100004052888210uLL);
  v132 = malloc_type_malloc(count, 0x100004077774924uLL);
  v133 = malloc_type_malloc(count, 0x100004077774924uLL);
  v226 = malloc_type_malloc(116 * size, 0x1000040DB6AEB77uLL);
  v211 = v132;
  v213 = (uint64_t)v129;
  v206 = (uint64_t)v128;
  v207 = v123;
  v209 = v133;
  v215 = v130;
  v221 = v131;
  updateModulationError(v196, v227, a4, v123, (uint64_t)v45, (uint64_t)v46, (uint64_t)v130, (uint64_t)v131, (uint64_t)v132, (uint64_t)v133, (uint64_t)v128, (uint64_t)v129, v226, v195, v194);
  if ((_DWORD)size)
  {
    v136 = 0;
    v137 = (uint64_t)v226;
    do
    {
      errorApply(v196, v137, (float32x4_t *)((char *)v45 + ((4 * v136) & 0x3FFFFFFF0)), (float32x4_t *)((char *)v46 + ((4 * v136) & 0x3FFFFFFF0)), v134, v135);
      v136 += 4;
      v137 += 116;
    }
    while (4 * size != v136);
  }
  v205 = malloc_type_malloc(v193, 0x100004077774924uLL);
  v203 = malloc_type_malloc(v193, 0x100004077774924uLL);
  if ((_DWORD)size)
  {
    v138 = 0;
    v139 = 0;
    do
    {
      v140 = (4 * v139) | 3;
      v141 = v45[v140];
      v142 = v46[v140];
      v143 = (4 * v139);
      *(_OWORD *)__A = *(_OWORD *)&v45[v143];
      __Y[0] = *(_OWORD *)&v46[v143];
      _Q2 = vsubq_f32(*(float32x4_t *)&v46[v143], *(float32x4_t *)&v45[v143]);
      _S4 = _Q2.i32[2];
      __asm { FMLA            S3, S4, V2.S[2] }
      _S4 = _Q2.i32[3];
      __asm { FMLA            S3, S4, V2.S[3] }
      v151 = 0.0;
      v152 = 0.0;
      if (_S3 < 64.0)
      {
        v151 = flt_18822ADC4[64 * (unint64_t)(v192 == 2)
                           + 8 * ((v139 % v216) & 7)
                           + ((v139 / v216) & 7)]
             + -32.5;
        v152 = -v151;
      }
      *(_QWORD *)__Kb = v139;
      v153 = 0;
      v154 = &v45[v138];
      v229 = v138;
      v155 = &v46[v138];
      v156 = (char *)&unk_18822AD68 + 4 * (v141 < 236.785714);
      v157 = (char *)&unk_18822AD70 + 4 * (v142 < 236.785714);
      do
      {
        v158 = v157[v153];
        v154[v153] = quantize(__A[v153] + (float)(v151 * flt_18822AFC4[v156[v153]]), v156[v153], v153 == 3);
        v155[v153] = quantize(*((float *)__Y + v153) + (float)(v152 * flt_18822AFC4[v158]), v158, v153 == 3);
        ++v153;
      }
      while (v153 != 4);
      v139 = *(_QWORD *)__Kb + 1;
      v138 = v229 + 4;
    }
    while (*(_QWORD *)__Kb + 1 != size);
  }
  v159 = v194;
  v161 = v206;
  v160 = (void *)v207;
  v162 = v196;
  updateModulationError(v196, v227, a4, v207, (uint64_t)v45, (uint64_t)v46, (uint64_t)v215, (uint64_t)v221, (uint64_t)v211, (uint64_t)v209, v206, (uint64_t)v129, v226, v217, v194);
  v165 = 0;
  v166 = v195;
  do
  {
    while (1)
    {
      v230 = v165;
      if ((_DWORD)size)
        break;
      updateModulationError(v162, v227, a4, (uint64_t)v160, (uint64_t)v45, (uint64_t)v46, (uint64_t)v215, (uint64_t)v221, (uint64_t)v211, (uint64_t)v209, v161, v213, v226, v166, v159);
      v165 = v230 + 1;
      if (v230 == 3)
        goto LABEL_169;
    }
    v167 = 0;
    v168 = (uint64_t)v226;
    do
    {
      errorApply(v162, v168, (float32x4_t *)((char *)v45 + ((4 * v167) & 0x3FFFFFFF0)), (float32x4_t *)((char *)v46 + ((4 * v167) & 0x3FFFFFFF0)), v163, v164);
      v167 += 4;
      v168 += 116;
    }
    while (4 * size != v167);
    v169 = 0;
    for (ii = 0; ii != size; ++ii)
    {
      v171 = (4 * ii) | 3;
      v172 = v169;
      v173 = (char *)&unk_18822AD68 + 4 * (v45[v171] < 236.785714);
      v174 = (char *)&unk_18822AD70 + 4 * (v46[v171] < 236.785714);
      v175 = -4;
      do
      {
        v176 = v46[v172];
        v45[v172] = quantize(v45[v172], v173[v175 + 4], v175 == -1);
        v46[v172++] = quantize(v176, v174[v175 + 4], v175 == -1);
        ++v175;
      }
      while (v175);
      v169 += 4;
    }
    v159 = v194;
    v166 = v195;
    v161 = v206;
    v160 = (void *)v207;
    v162 = v196;
    updateModulationError(v196, v227, a4, v207, (uint64_t)v45, (uint64_t)v46, (uint64_t)v215, (uint64_t)v221, (uint64_t)v211, (uint64_t)v209, v206, v213, v226, v195, v194);
    v165 = v230 + 1;
  }
  while (v230 != 3);
  for (jj = 0; jj != size; ++jj)
  {
    v178 = 0;
    v180 = &v46[4 * (jj & 0x3FFFFFFF)];
    do
    {
      v179 = &v45[4 * (jj & 0x3FFFFFFF)];
      v181 = v179[v178];
      v182 = v180[v178];
      v183 = 255.0;
      if (v181 <= 255.0)
        v184 = v179[v178];
      else
        v184 = 255.0;
      if (v181 >= 0.0)
        v185 = v184;
      else
        v185 = 0.0;
      if (v182 <= 255.0)
        v183 = v180[v178];
      if (v182 >= 0.0)
        v186 = v183;
      else
        v186 = 0.0;
      v205[4 * (jj & 0x3FFFFFFF) + v178] = (uint64_t)rintf(v185);
      v203[4 * (jj & 0x3FFFFFFF) + v178++] = (uint64_t)rintf(v186);
    }
    while (v178 != 4);
  }
LABEL_169:
  *a6 = v205;
  *a7 = v203;
  *a8 = v161;
  *a9 = v213;
  free(v160);
  free(v45);
  free(v46);
  free(v215);
  free(v211);
  free(v209);
  free(v226);
  free(v221);
}

uint64_t checkBitReplication(uint64_t result, int a2, int a3)
{
  unsigned int v5;
  char v6;
  FILE **v7;

  v5 = result;
  v6 = 8 - (a3 + a2);
  v7 = (FILE **)MEMORY[0x1E0C80C10];
  if (result >> (a3 + a2) != (result & ~(-1 << v6)))
    result = fprintf((FILE *)*MEMORY[0x1E0C80C10], "Bit replication is wrong! (%d, %d)\n", result, a2);
  if (v5 >> v6 >> a2 != ((v5 >> v6) & ~(-1 << a3)))
    return fprintf(*v7, "Bit extra replication is wrong! (%d, %d, %d, %d)\n", v5, v5 >> v6, a2, a3);
  return result;
}

void *lanczosDownsample84(const unsigned __int8 *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3;
  vImagePixelCount v7;
  vImagePixelCount v8;
  vImagePixelCount v9;
  vImagePixelCount v10;
  void *v11;
  void *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t i;
  void *v18;
  vImage_Buffer v20;
  vImage_Buffer src;

  v3 = a3 * (unint64_t)a2;
  if (v3 >> 62)
    return 0;
  v7 = a2 >> 3;
  v8 = a3 >> 2;
  v9 = a2;
  v10 = a3;
  v11 = malloc_type_malloc(4 * v3, 0x34BF888BuLL);
  v12 = v11;
  if (a3)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      if (a2)
      {
        v15 = 0;
        v16 = v13;
        do
        {
          for (i = 0; i != 4; ++i)
            *((_BYTE *)v11 + v16 + i) = a1[4 * (v14 + 2) % a3 * a2 + 4 * (((int)v15 + 4) % a2) + i];
          ++v15;
          v16 += 4;
        }
        while (v15 != v9);
      }
      ++v14;
      v13 += 4 * a2;
    }
    while (v14 != a3);
  }
  src.data = v11;
  src.height = v10;
  src.width = v9;
  src.rowBytes = 4 * a2;
  v18 = malloc_type_malloc((4 * v7 * v8), 0x100004077774924uLL);
  v20.data = v18;
  v20.height = v8;
  v20.width = v7;
  v20.rowBytes = (4 * v7);
  vImageScale_ARGB8888(&src, &v20, 0, 0x20u);
  free(v12);
  return v18;
}

uint64_t bilinearUpsample84f(uint64_t result, float *a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;

  v6 = 0;
  v7 = 0;
  v10 = ((a5 - 4) & (a3 - 1)) >> 3;
  v11 = ((a6 - 2) & (a4 - 1)) >> 2;
  v12 = v11 % (a4 >> 2) * (a3 >> 3);
  v13 = v10 % (a3 >> 3);
  v14 = (v11 + 1) % (a4 >> 2);
  v15 = v12 + v13;
  v16 = (v10 + 1) % (a3 >> 3);
  v17 = v14 * (a3 >> 3);
  v18 = v17 + v13;
  do
  {
    v8 = (a5 - 4) & 7;
    v9 = (a6 - 2) & 3;
    *(float *)(result + v6) = (float)((float)((float)((float)(a2[4 * v16 + 4 * v12 + v7] * (float)((4 - v9) * v8))
                                                    + (float)((float)((4 - v9) * (8 - v8))
                                                            * a2[v7 + (4 * v15)]))
                                            + (float)((float)((8 - v8) * v9) * a2[v7 + (4 * v18)]))
                                    + (float)((float)(v9 * v8) * a2[4 * v17 + 4 * v16 + v7]))
                            * 0.03125;
    ++v7;
    v6 += 4;
  }
  while (v6 != 16);
  return result;
}

float bilinearUpsample84fq(float *a1, float *a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  float result;
  _QWORD v18[2];

  v6 = 0;
  v18[1] = *MEMORY[0x1E0C80C00];
  v7 = ((a5 - 4) & (a3 - 1)) >> 3;
  v8 = ((a6 - 2) & (a4 - 1)) >> 2;
  v9 = v8 % (a4 >> 2) * (a3 >> 3);
  v10 = v7 % (a3 >> 3);
  v11 = (v7 + 1) % (a3 >> 3);
  v12 = (v8 + 1) % (a4 >> 2) * (a3 >> 3);
  v13 = vdupq_n_s32((a5 - 4) & 7);
  v14 = (int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * (v9 + v10)]))), (uint32x4_t)xmmword_18822AD90);
  v15 = (int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v12 + 4 * v10]))), (uint32x4_t)xmmword_18822AD90);
  v16 = vmlaq_s32(vshlq_n_s32(v14, 3uLL), vshrq_n_s32(vshlq_n_s32(vsubq_s32((int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v11 + 4 * v9]))), (uint32x4_t)xmmword_18822AD90), v14), 0x18uLL), 0x18uLL), v13);
  v18[0] = vmovn_s32(vmlaq_s32(vshlq_n_s32(v16, 2uLL), vmlaq_s32(vsubq_s32(vshlq_n_s32(v15, 3uLL), v16), vshrq_n_s32(vshlq_n_s32(vsubq_s32((int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v12 + 4 * v11]))), (uint32x4_t)xmmword_18822AD90), v15), 0x18uLL), 0x18uLL), v13), vdupq_n_s32((a6 - 2) & 3)));
  do
  {
    a1[v6] = (float)((*((__int16 *)v18 + v6) >> 7) + (*((__int16 *)v18 + v6) >> 2));
    ++v6;
  }
  while (v6 != 3);
  result = (float)((SHIWORD(v18[0]) >> 5) + (SHIWORD(v18[0]) >> 1));
  a1[3] = result;
  return result;
}

uint64_t errorAccumulateBilinear84(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, int a5, int a6, float a7)
{
  uint64_t v7;
  int v8;
  int v9;
  int32x2_t v10;
  float v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  float v20;
  char v21;
  uint64_t v22;
  char v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  _DWORD v28[4];
  float32x2_t v29;
  __int32 v30;
  float v31;
  float v32[2];
  uint64_t v33;

  v7 = 0;
  v33 = *MEMORY[0x1E0C80C00];
  v8 = (a6 - 2) & 3;
  v32[0] = 1.0 - a7;
  v32[1] = a7;
  v9 = (a5 - 4) & 7;
  v10.i32[0] = 8 - v9;
  v10.i32[1] = v9;
  v29 = vmul_f32(vcvt_f32_s32(vmul_s32(vdup_n_s32(4 - v8), v10)), (float32x2_t)0x3D0000003D000000);
  *(float *)v10.i32 = (float)((8 - v9) * v8) * 0.03125;
  v11 = (float)(v8 * v9) * 0.03125;
  v12 = ((a5 - 4) & (a3 - 1)) >> 3;
  v13 = ((a6 - 2) & (a4 - 1)) >> 2;
  v14 = v13 % (a4 >> 2) * (a3 >> 3);
  v15 = v12 % (a3 >> 3);
  v16 = (v12 + 1) % (a3 >> 3);
  v28[0] = v14 + v15;
  v28[1] = v16 + v14;
  v17 = (v13 + 1) % (a4 >> 2) * (a3 >> 3);
  v28[2] = v17 + v15;
  v28[3] = v17 + v16;
  v30 = v10.i32[0];
  v31 = v11;
  do
  {
    v18 = 0;
    v19 = v28[v7];
    *(float *)(result + 116 * v19) = *(float *)(result + 116 * v19) + 1.0;
    v20 = v29.f32[v7];
    v21 = 1;
    do
    {
      v22 = 0;
      v23 = v21;
      v24 = v20 * v32[v18];
      v25 = result + 116 * v19 + 4 * v18;
      *(float *)(v25 + 4) = *(float *)(v25 + 4) + v24;
      *(float *)(v25 + 12) = *(float *)(v25 + 12) + (float)(v24 * v24);
      v26 = result + 84 + 116 * v19 + 16 * v18;
      do
      {
        v27 = (float *)(v26 + v22);
        *(v27 - 16) = *(float *)(a2 + v22) + *(float *)(v26 + v22 - 64);
        *(v27 - 8) = *(float *)(v26 + v22 - 32) + (float)(*(float *)(a2 + v22) * *(float *)(a2 + v22));
        *v27 = *(float *)(v26 + v22) + (float)(v24 * *(float *)(a2 + v22));
        v22 += 4;
      }
      while (v22 != 16);
      v21 = 0;
      v18 = 1;
    }
    while ((v23 & 1) != 0);
    ++v7;
  }
  while (v7 != 4);
  return result;
}

void *lanczosDownsample4(const unsigned __int8 *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3;
  vImagePixelCount v7;
  vImagePixelCount v8;
  vImagePixelCount v9;
  vImagePixelCount v10;
  void *v11;
  void *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t i;
  size_t v18;
  void *v19;
  vImage_Buffer v21;
  vImage_Buffer src;

  v3 = a3 * (unint64_t)a2;
  if (v3 >> 62)
    return 0;
  v7 = a2 >> 2;
  v8 = a3 >> 2;
  v9 = a2;
  v10 = a3;
  v11 = malloc_type_malloc(4 * v3, 0x8EEDB46EuLL);
  v12 = v11;
  if (a3)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      if (a2)
      {
        v15 = 0;
        v16 = v13;
        do
        {
          for (i = 0; i != 4; ++i)
            *((_BYTE *)v11 + v16 + i) = a1[4 * (v14 + 2) % a3 * a2 + 4 * (((int)v15 + 2) % a2) + i];
          ++v15;
          v16 += 4;
        }
        while (v15 != v9);
      }
      ++v14;
      v13 += 4 * a2;
    }
    while (v14 != a3);
  }
  src.data = v11;
  src.height = v10;
  src.width = v9;
  src.rowBytes = 4 * a2;
  v18 = a2 & 0xFFFFFFFC;
  v19 = malloc_type_malloc((v18 * v8), 0x100004077774924uLL);
  v21.data = v19;
  v21.height = v8;
  v21.width = v7;
  v21.rowBytes = v18;
  vImageScale_ARGB8888(&src, &v21, 0, 0x20u);
  free(v12);
  return v19;
}

uint64_t bilinearUpsample4f(uint64_t result, float *a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;

  v6 = 0;
  v7 = 0;
  v10 = ((a5 - 2) & (a3 - 1)) >> 2;
  v11 = ((a6 - 2) & (a4 - 1)) >> 2;
  v12 = v11 % (a4 >> 2) * (a3 >> 2);
  v13 = v10 % (a3 >> 2);
  v14 = (v11 + 1) % (a4 >> 2);
  v15 = v12 + v13;
  v16 = (v10 + 1) % (a3 >> 2);
  v17 = v14 * (a3 >> 2);
  v18 = v17 + v13;
  do
  {
    v8 = (a5 - 2) & 3;
    v9 = (a6 - 2) & 3;
    *(float *)(result + v6) = (float)((float)((float)((float)(a2[4 * v16 + 4 * v12 + v7] * (float)((4 - v9) * v8))
                                                    + (float)((float)((4 - v9) * (4 - v8))
                                                            * a2[v7 + (4 * v15)]))
                                            + (float)((float)((4 - v8) * v9) * a2[v7 + (4 * v18)]))
                                    + (float)((float)(v9 * v8) * a2[4 * v17 + 4 * v16 + v7]))
                            * 0.0625;
    ++v7;
    v6 += 4;
  }
  while (v6 != 16);
  return result;
}

float bilinearUpsample4fq(float *a1, float *a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  float result;
  _QWORD v18[2];

  v6 = 0;
  v18[1] = *MEMORY[0x1E0C80C00];
  v7 = ((a5 - 2) & (a3 - 1)) >> 2;
  v8 = ((a6 - 2) & (a4 - 1)) >> 2;
  v9 = v8 % (a4 >> 2) * (a3 >> 2);
  v10 = v7 % (a3 >> 2);
  v11 = (v7 + 1) % (a3 >> 2);
  v12 = (v8 + 1) % (a4 >> 2) * (a3 >> 2);
  v13 = vdupq_n_s32((a5 - 2) & 3);
  v14 = (int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * (v9 + v10)]))), (uint32x4_t)xmmword_18822AD90);
  v15 = (int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v12 + 4 * v10]))), (uint32x4_t)xmmword_18822AD90);
  v16 = vmlaq_s32(vshlq_n_s32(v14, 2uLL), vshrq_n_s32(vshlq_n_s32(vsubq_s32((int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v11 + 4 * v9]))), (uint32x4_t)xmmword_18822AD90), v14), 0x18uLL), 0x18uLL), v13);
  v18[0] = vmovn_s32(vmlaq_s32(vshlq_n_s32(v16, 2uLL), vmlaq_s32(vsubq_s32(vshlq_n_s32(v15, 2uLL), v16), vshrq_n_s32(vshlq_n_s32(vsubq_s32((int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v12 + 4 * v11]))), (uint32x4_t)xmmword_18822AD90), v15), 0x18uLL), 0x18uLL), v13), vdupq_n_s32((a6 - 2) & 3)));
  do
  {
    a1[v6] = (float)((*((__int16 *)v18 + v6) >> 6) + (*((__int16 *)v18 + v6) >> 1));
    ++v6;
  }
  while (v6 != 3);
  result = (float)(SHIWORD(v18[0]) + (SHIWORD(v18[0]) >> 4));
  a1[3] = result;
  return result;
}

uint64_t errorAccumulateBilinear4(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, int a5, int a6, float a7)
{
  uint64_t v7;
  int v8;
  int v9;
  int32x2_t v10;
  float v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  float v20;
  char v21;
  uint64_t v22;
  char v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  _DWORD v28[4];
  float32x2_t v29;
  __int32 v30;
  float v31;
  float v32[2];
  uint64_t v33;

  v7 = 0;
  v33 = *MEMORY[0x1E0C80C00];
  v8 = (a6 - 2) & 3;
  v32[0] = 1.0 - a7;
  v32[1] = a7;
  v9 = (a5 - 2) & 3;
  v10.i32[0] = 4 - v9;
  v10.i32[1] = v9;
  v29 = vmul_f32(vcvt_f32_s32(vmul_s32(vdup_n_s32(4 - v8), v10)), (float32x2_t)vdup_n_s32(0x3D800000u));
  *(float *)v10.i32 = (float)((4 - v9) * v8) * 0.0625;
  v11 = (float)(v8 * v9) * 0.0625;
  v12 = ((a5 - 2) & (a3 - 1)) >> 2;
  v13 = ((a6 - 2) & (a4 - 1)) >> 2;
  v14 = v13 % (a4 >> 2) * (a3 >> 2);
  v15 = v12 % (a3 >> 2);
  v16 = (v12 + 1) % (a3 >> 2);
  v28[0] = v14 + v15;
  v28[1] = v16 + v14;
  v17 = (v13 + 1) % (a4 >> 2) * (a3 >> 2);
  v28[2] = v17 + v15;
  v28[3] = v17 + v16;
  v30 = v10.i32[0];
  v31 = v11;
  do
  {
    v18 = 0;
    v19 = v28[v7];
    *(float *)(result + 116 * v19) = *(float *)(result + 116 * v19) + 1.0;
    v20 = v29.f32[v7];
    v21 = 1;
    do
    {
      v22 = 0;
      v23 = v21;
      v24 = v20 * v32[v18];
      v25 = result + 116 * v19 + 4 * v18;
      *(float *)(v25 + 4) = *(float *)(v25 + 4) + v24;
      *(float *)(v25 + 12) = *(float *)(v25 + 12) + (float)(v24 * v24);
      v26 = result + 84 + 116 * v19 + 16 * v18;
      do
      {
        v27 = (float *)(v26 + v22);
        *(v27 - 16) = *(float *)(a2 + v22) + *(float *)(v26 + v22 - 64);
        *(v27 - 8) = *(float *)(v26 + v22 - 32) + (float)(*(float *)(a2 + v22) * *(float *)(a2 + v22));
        *v27 = *(float *)(v26 + v22) + (float)(v24 * *(float *)(a2 + v22));
        v22 += 4;
      }
      while (v22 != 16);
      v21 = 0;
      v18 = 1;
    }
    while ((v23 & 1) != 0);
    ++v7;
  }
  while (v7 != 4);
  return result;
}

void updateModulationError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void (*a14)(float32x4_t *, uint64_t, uint64_t, uint64_t), void (*a15)(void *, float32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v20;
  char v21;
  unsigned int v22;
  double v23;
  float v24;
  double v25;
  float v26;
  uint8x8_t v27;
  uint8x8_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  float v39;
  float v40;
  float v41;
  int v42;
  uint64_t v43;
  unint64_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  float v57;
  int v58;
  float v59;
  float v60;
  BOOL v62;
  int v63;
  float v64;
  float v65;
  float v66;
  int v67;
  char v68;
  uint64_t v69;
  unint64_t v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  float v80;
  float v81;
  float v82;
  uint64_t v83;
  float v84;
  float v85;
  float v86;
  int v87;
  unsigned int v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int *v93;
  int *v94;
  float *v95;
  unsigned int v96;
  uint64_t v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  int v103;
  unsigned int v104;
  int v105;
  unsigned int v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  int v113;
  char v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  uint64_t v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  float v128;
  float v129;
  float v130;
  uint64_t v131;
  float v132;
  float v133;
  float v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  int v138;
  unsigned int v139;
  unint64_t v140;
  float v141;
  float v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  unint64_t v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  unsigned __int8 v152;
  uint64_t i;
  unsigned int v154;
  unsigned int v155;
  unsigned int v156;
  unint64_t v157;
  float v158;
  unsigned int v159;
  unsigned int v160;
  int v161;
  unint64_t v162;
  uint64_t v163;
  float v164;
  unsigned int v165;
  unsigned int v166;
  int v167;
  unint64_t v168;
  uint64_t v169;
  float v170;
  unsigned int v171;
  unsigned int v172;
  int v173;
  unint64_t v174;
  uint64_t v175;
  float v176;
  float v177;
  int v178;
  float v179;
  float v180;
  float v181;
  float v182;
  uint64_t v183;
  uint64_t v184;
  int v185;
  int v186;
  unsigned int v187;
  float v188;
  float v189;
  unsigned int v190;
  float v191;
  float v192;
  unsigned int v193;
  float v194;
  float v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  float32x4_t *v200;
  float v201;
  BOOL v202;
  unsigned int k;
  unsigned int v204;
  unsigned int j;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  int v209;
  unsigned int v210;
  int v211;
  int v212;
  unsigned int v213;
  _BOOL4 v214;
  float v215;
  int v216;
  float v217;
  float v218;
  int v219;
  unsigned int v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  unsigned int v224;
  int v225;
  uint64_t v226;
  unsigned int v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  int v234;
  unsigned int v235;
  unsigned int v236;
  int v237;
  unsigned int v238;
  int v239;
  uint64_t v240;
  int v241;
  uint64_t v243;
  __int128 *v244;
  uint64_t *v245;
  uint64_t *v246;
  float32x4_t v247;
  unint64_t *v248;
  float32x4_t v249;
  uint64_t *v250;
  float32x4_t v251;
  uint64_t v252;
  uint64_t v253;
  int v254;
  unint64_t v255;
  int v256;
  uint64_t v257;
  int v258;
  uint64_t v259;
  int v260;
  uint64_t v261;
  int v262;
  unint64_t v263;
  int v264;
  __int128 v265;
  int v266;
  __int128 v267;
  int v268;
  __int128 v269;
  int v270;
  uint64_t v271;

  v271 = *MEMORY[0x1E0C80C00];
  v20 = *(_QWORD *)a1;
  v234 = *(_BYTE *)(a1 + 8) & 7;
  if (v234 == 2)
    v21 = 3;
  else
    v21 = 2;
  v22 = a3 >> 2;
  v228 = a2 >> v21;
  bzero(a13, 116 * v228 * (a3 >> 2));
  if ((_DWORD)a3)
  {
    v224 = v22;
    v226 = a1;
    v243 = a7;
    v227 = 0;
    v238 = 0;
    v229 = a8 + 4 * (a3 * a2);
    v231 = a8 + 4 * (2 * a3 * a2);
    v30 = a9;
    v29 = a10;
    v230 = a8 + 4 * (3 * a3 * a2);
    v31 = a8 + 4 * (4 * a3 * a2);
    v225 = 4 * a2;
    do
    {
      if ((_DWORD)a2)
      {
        v32 = 0;
        v33 = v227;
        do
        {
          v240 = v32;
          v251 = 0uLL;
          v34 = v30 + v33;
          v249 = 0uLL;
          v35 = v29 + v33;
          v247 = 0uLL;
          v235 = v33;
          v36 = a4 + 4 * v33;
          v244 = 0;
          v245 = 0;
          a14(&v251, a5, a2, a3);
          ((void (*)(float32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))a14)(&v249, a6, a2, a3, v240, v238);
          v37 = 0;
          v38 = v238 * a2 + v240;
          do
          {
            v39 = v251.f32[v37];
            *(_BYTE *)(v34 + v37) = (int)v39;
            v40 = v249.f32[v37];
            *(_BYTE *)(v35 + v37) = (int)v40;
            v41 = *(float *)(v20 + 4 * v37);
            v247.f32[v37] = (float)(v40 - v39) * v41;
            *((float *)&v244 + v37) = v41 * (float)(*(float *)(v36 + 4 * v37) - v39);
            ++v37;
          }
          while (v37 != 4);
          v27.i32[0] = v247.i32[3];
          v26 = v247.f32[2];
          *(float *)&v25 = (float)((float)((float)(v247.f32[1] * v247.f32[1]) + (float)(v247.f32[0] * v247.f32[0]))
                                 + (float)(v247.f32[2] * v247.f32[2]))
                         + (float)(v247.f32[3] * v247.f32[3]);
          v24 = *(float *)&v245;
          *(float *)&v23 = (float)((float)((float)((float)(v247.f32[1] * *((float *)&v244 + 1))
                                                 + (float)(*(float *)&v244 * v247.f32[0]))
                                         + (float)(*(float *)&v245 * v247.f32[2]))
                                 + (float)(*((float *)&v245 + 1) * v247.f32[3]))
                         / *(float *)&v25;
          *(_DWORD *)(a8 + 4 * v38) = LODWORD(v23);
          *(_DWORD *)(v31 + 4 * v38) = LODWORD(v25);
          v32 = v240 + 1;
          v33 = v235 + 4;
          v30 = a9;
          v29 = a10;
        }
        while (v240 + 1 != a2);
      }
      v227 += v225;
      ++v238;
    }
    while (v238 != (_DWORD)a3);
    if (v234 == 2)
    {
      v42 = 0;
      v43 = a2 - 1;
      do
      {
        v44 = v42 & 1;
        if (v44 >= a2)
        {
          v47 = v42 + 1;
        }
        else
        {
          v45 = v42 * a2;
          v46 = (v42 - 1) % a3 * a2;
          v47 = v42 + 1;
          if (v42 + 1 == (_DWORD)a3)
            v48 = 0;
          else
            v48 = v42 + 1;
          v49 = v48 * a2;
          v50 = v42 & 3;
          do
          {
            v51 = (v45 + v44);
            v52 = ((int)v44 - 1) % a2 + v45;
            v53 = (v46 + v44);
            if (v43 == v44)
              v54 = 0;
            else
              v54 = v44 + 1;
            v55 = (v45 + v54);
            v56 = (v49 + v44);
            v57 = (float)((float)((float)((float)(*(float *)(a8 + 4 * v52)
                                                + *(float *)(a8 + 4 * v53))
                                        + *(float *)(a8 + 4 * v55))
                                + *(float *)(a8 + 4 * v56))
                        * 0.125)
                + (float)(*(float *)(a8 + 4 * v51) * 0.5);
            v58 = v44 & 7 | v50;
            if (v58)
            {
              v59 = 0.0;
              if (v57 >= 0.1875)
              {
                v59 = 0.375;
                if (v57 >= 0.5)
                {
                  if (v57 >= 0.8125)
                    v59 = 1.0;
                  else
                    v59 = 0.625;
                }
              }
            }
            else if (v57 >= 0.5)
            {
              v59 = 1.0;
            }
            else
            {
              v59 = 0.0;
            }
            *(float *)(v229 + 4 * v51) = v59;
            v60 = (float)((float)(*(float *)(a8 + 4 * v52) + *(float *)(a8 + 4 * v55)) * 0.25)
                + (float)(*(float *)(a8 + 4 * v51) * 0.5);
            v62 = v50 == 2 && (v44 & 7) == 4 || v58 == 0;
            v63 = v62;
            if (v62)
            {
              if (v60 >= 0.5)
                v64 = 1.0;
              else
                v64 = 0.0;
            }
            else
            {
              v64 = 0.0;
              if (v60 >= 0.1875)
              {
                v64 = 0.375;
                if (v60 >= 0.5)
                {
                  if (v60 >= 0.8125)
                    v64 = 1.0;
                  else
                    v64 = 0.625;
                }
              }
            }
            *(float *)(v231 + 4 * v51) = v64;
            v65 = (float)((float)(*(float *)(a8 + 4 * v53) + *(float *)(a8 + 4 * v56)) * 0.25)
                + (float)(*(float *)(a8 + 4 * v51) * 0.5);
            if (v63)
            {
              if (v65 >= 0.5)
                v66 = 1.0;
              else
                v66 = 0.0;
            }
            else
            {
              v66 = 0.0;
              if (v65 >= 0.1875)
              {
                v66 = 0.375;
                if (v65 >= 0.5)
                {
                  if (v65 >= 0.8125)
                    v66 = 1.0;
                  else
                    v66 = 0.625;
                }
              }
            }
            *(float *)(v230 + 4 * v51) = v66;
            v44 += 2;
          }
          while (v44 < a2);
        }
        v42 = v47;
      }
      while (v47 != (_DWORD)a3);
      v67 = 0;
      v68 = 1;
      v69 = a8 + 4 * (a3 * a2);
      do
      {
        if (((v67 & 1) == 0) >= a2)
        {
          v73 = v67 + 1;
        }
        else
        {
          v70 = v68 & 1;
          v71 = v67 * a2;
          v72 = (v67 - 1) % a3 * a2;
          v73 = v67 + 1;
          if (v67 + 1 == (_DWORD)a3)
            v74 = 0;
          else
            v74 = v67 + 1;
          v75 = v74 * a2;
          do
          {
            v76 = v71 + ((int)v70 - 1) % a2;
            if (v43 == v70)
              v77 = 0;
            else
              v77 = v70 + 1;
            v78 = (v71 + v77);
            v79 = (v75 + v70);
            v80 = (float)((float)((float)(*(float *)(v229 + 4 * v76)
                                        + *(float *)(v229 + 4 * (v72 + v70)))
                                + *(float *)(v229 + 4 * v78))
                        + *(float *)(v229 + 4 * v79))
                * 0.25;
            v81 = 0.0;
            v82 = 0.0;
            if (v80 >= 0.0)
            {
              v82 = 1.0;
              if (v80 < 1.0)
                v82 = roundf(v80 * 8.0) * 0.125;
            }
            v83 = (v71 + v70);
            *(float *)(v229 + 4 * v83) = v82;
            v84 = (float)(*(float *)(v231 + 4 * v76) + *(float *)(v231 + 4 * v78)) * 0.5;
            if (v84 >= 0.0)
            {
              v81 = 1.0;
              if (v84 < 1.0)
                v81 = roundf(v84 * 8.0) * 0.125;
            }
            *(float *)(v231 + 4 * v83) = v81;
            v85 = (float)(*(float *)(v230 + 4 * v79) + *(float *)(v230 + 4 * v79)) * 0.5;
            v86 = 0.0;
            if (v85 >= 0.0)
            {
              v86 = 1.0;
              if (v85 < 1.0)
                v86 = roundf(v85 * 8.0) * 0.125;
            }
            *(float *)(v230 + 4 * v83) = v86;
            v70 += 2;
          }
          while (v70 < a2);
        }
        v68 ^= 1u;
        v67 = v73;
      }
      while (v73 != (_DWORD)a3);
      v87 = 0;
      do
      {
        v88 = v87 & 1;
        if (v88 < a2)
        {
          v89 = v87 & 3;
          do
          {
            v90 = 0;
            v270 = 0;
            v269 = xmmword_18822AFE8;
            v267 = xmmword_18822AFFC;
            v268 = 1;
            v265 = xmmword_18822B010;
            v266 = 1048576000;
            v264 = 1;
            v263 = 0xFFFFFFFF00000000;
            v262 = 0;
            v261 = 0;
            v260 = 1056964608;
            v259 = 0x3F0000003F800000;
            v258 = 0;
            v257 = 0;
            v256 = 1;
            v255 = 0xFFFFFFFF00000000;
            v254 = 1056964608;
            v253 = 0x3F0000003F800000;
            v251.i64[0] = v69;
            v251.i64[1] = a8 + 4 * (2 * a3 * a2);
            v252 = a8 + 4 * (3 * a3 * a2);
            v249.i64[0] = (uint64_t)&v269;
            v249.i64[1] = (uint64_t)&v263;
            v250 = &v257;
            v247.i64[0] = (uint64_t)&v267;
            v247.i64[1] = (uint64_t)&v261;
            v248 = &v255;
            v244 = &v265;
            v245 = &v259;
            v91 = v88 + v87 * (_DWORD)a2;
            v246 = &v253;
            do
            {
              v92 = v251.i64[v90];
              v93 = (int *)v249.i64[v90];
              v94 = (int *)v247.i64[v90];
              v95 = (float *)*(&v244 + v90);
              v96 = dword_18822B030[v90];
              if (v96 <= 1)
                v97 = 1;
              else
                v97 = v96;
              v98 = 0.0;
              v99 = 0.0;
              v100 = 0.0;
              v101 = 0.0;
              v102 = 0.0;
              do
              {
                v103 = *v94++;
                v104 = (v103 + v87) % a3;
                v105 = *v93++;
                v106 = (v105 + v88) % a2 + v104 * a2;
                v107 = *(float *)(v31 + 4 * v106);
                v108 = *(float *)(a8 + 4 * v106) - *(float *)(v92 + 4 * v106);
                v109 = *v95++;
                v102 = v102 + v107;
                v101 = v101 + (float)(v107 * v109);
                v100 = v100 + (float)(v107 * (float)(v109 * v109));
                v99 = v99 + (float)(v107 * v108);
                v98 = v98 + (float)((float)(v107 * v109) * v108);
                --v97;
              }
              while (v97);
              v110 = (float)((float)(1.0 / (float)((float)(v102 * v100) - (float)(v101 * v101)))
                           * (float)((float)(v102 * v98) - (float)(v101 * v99)))
                   + (float)((float)((float)(1.0 / (float)((float)(v102 * v100) - (float)(v101 * v101)))
                                   * (float)((float)(v100 * v99) - (float)(v101 * v98)))
                           + *(float *)(v92 + 4 * v91));
              if (!(v88 & 7 | v89) || v89 == 2 && (v88 & 7) == 4 && v90)
              {
                if (v110 >= 0.5)
                  v111 = 1.0;
                else
                  v111 = 0.0;
              }
              else
              {
                if (v110 >= 0.8125)
                  v112 = 1.0;
                else
                  v112 = 0.625;
                if (v110 < 0.5)
                  v112 = 0.375;
                if (v110 >= 0.1875)
                  v111 = v112;
                else
                  v111 = 0.0;
              }
              *(float *)(v92 + 4 * v91) = v111;
              ++v90;
            }
            while (v90 != 3);
            v88 += 2;
            v69 = a8 + 4 * (a3 * a2);
          }
          while (v88 < a2);
        }
        ++v87;
      }
      while (v87 != (_DWORD)a3);
      v113 = 0;
      LODWORD(v25) = 8.0;
      v114 = 1;
      v26 = 0.125;
      v115 = v243;
      v30 = a9;
      v29 = a10;
      v117 = a8 + 4 * (3 * a3 * a2);
      v116 = a8 + 4 * (2 * a3 * a2);
      do
      {
        if (((v113 & 1) == 0) >= a2)
        {
          v121 = v113 + 1;
        }
        else
        {
          v118 = v114 & 1;
          v119 = v113 * a2;
          v120 = (v113 - 1) % a3 * a2;
          v121 = v113 + 1;
          if (v113 + 1 == (_DWORD)a3)
            v122 = 0;
          else
            v122 = v113 + 1;
          v123 = v122 * a2;
          do
          {
            v124 = v119 + ((int)v118 - 1) % a2;
            if (v43 == v118)
              v125 = 0;
            else
              v125 = v118 + 1;
            v126 = (v119 + v125);
            v127 = (v123 + v118);
            v128 = (float)((float)((float)(*(float *)(v69 + 4 * v124)
                                         + *(float *)(v69 + 4 * (v120 + v118)))
                                 + *(float *)(v69 + 4 * v126))
                         + *(float *)(v69 + 4 * v127))
                 * 0.25;
            v129 = 0.0;
            v130 = 0.0;
            if (v128 >= 0.0)
            {
              v130 = 1.0;
              if (v128 < 1.0)
                v130 = roundf(v128 * 8.0) * 0.125;
            }
            v131 = (v119 + v118);
            *(float *)(v69 + 4 * v131) = v130;
            v132 = (float)(*(float *)(v231 + 4 * v124) + *(float *)(v231 + 4 * v126)) * 0.5;
            if (v132 >= 0.0)
            {
              v129 = 1.0;
              if (v132 < 1.0)
                v129 = roundf(v132 * 8.0) * 0.125;
            }
            *(float *)(v231 + 4 * v131) = v129;
            v133 = (float)(*(float *)(v230 + 4 * v127) + *(float *)(v230 + 4 * v127)) * 0.5;
            v134 = 0.0;
            if (v133 >= 0.0)
            {
              v134 = 1.0;
              if (v133 < 1.0)
                v134 = roundf(v133 * 8.0) * 0.125;
            }
            *(float *)(v230 + 4 * v131) = v134;
            v118 += 2;
          }
          while (v118 < a2);
        }
        v114 ^= 1u;
        v113 = v121;
      }
      while (v121 != (_DWORD)a3);
      v236 = 0;
      v135 = 0;
      do
      {
        v136 = v135 + 4;
        if ((_DWORD)a2)
        {
          v137 = 0;
          v138 = (v135 >> 2) * v228;
          v139 = v236;
          do
          {
            v140 = v137;
            v251.i32[3] = 0;
            *(uint64_t *)((char *)v251.i64 + 4) = 0;
            v141 = 0.0;
            if (v135 != -4)
            {
              v142 = 0.0;
              v143 = v139;
              LODWORD(v25) = 0;
              v26 = 0.0;
              v144 = v135;
              do
              {
                if (v137 != -8)
                {
                  v145 = v143;
                  v146 = v137;
                  do
                  {
                    v147 = *(float *)(a8 + 4 * v145);
                    v148 = *(float *)(v31 + 4 * v145);
                    if (v147 >= 0.5)
                      v149 = 1.0;
                    else
                      v149 = 0.0;
                    v150 = *(float *)(v69 + 4 * v145) - v147;
                    v151 = *(float *)(v116 + 4 * v145) - v147;
                    v141 = v141 + (float)((float)((float)(v149 - v147) * (float)(v149 - v147)) * v148);
                    v26 = v26 + (float)((float)(v150 * v150) * v148);
                    *(float *)&v25 = *(float *)&v25 + (float)((float)(v151 * v151) * v148);
                    v142 = v142
                         + (float)((float)((float)(*(float *)(v117 + 4 * v145) - v147)
                                         * (float)(*(float *)(v117 + 4 * v145) - v147))
                                 * v148);
                    ++v146;
                    ++v145;
                  }
                  while (v146 < v137 + 8);
                }
                ++v144;
                v143 += a2;
              }
              while (v144 < v136);
              *(uint64_t *)((char *)v251.i64 + 4) = __PAIR64__(LODWORD(v25), LODWORD(v26));
              v251.f32[3] = v142;
            }
            v152 = 0;
            for (i = 1; i != 4; ++i)
            {
              if (v251.f32[i] <= v141)
              {
                v141 = v251.f32[i];
                v152 = i;
              }
            }
            *(_BYTE *)(a12 + v138 + (v140 >> 3)) = v152;
            switch(v152)
            {
              case 0u:
                if (v135 != -4)
                {
                  v154 = v139;
                  v155 = v135;
                  do
                  {
                    if ((_DWORD)v140 != -8)
                    {
                      v156 = v154;
                      v157 = v140;
                      do
                      {
                        if (*(float *)(a8 + 4 * v156) >= 0.5)
                          v158 = 1.0;
                        else
                          v158 = 0.0;
                        *(float *)(v115 + 4 * v156) = v158;
                        ++v157;
                        ++v156;
                      }
                      while (v157 < (v140 + 8));
                    }
                    ++v155;
                    v154 += a2;
                  }
                  while (v155 < v136);
                }
                break;
              case 1u:
                if (v135 != -4)
                {
                  v159 = v139;
                  v160 = v135;
                  do
                  {
                    if ((_DWORD)v140 != -8)
                    {
                      v161 = 0;
                      v162 = v140;
                      do
                      {
                        v163 = v159 + v161;
                        v164 = -1.0;
                        if (((v160 ^ ((_DWORD)v140 + v161)) & 1) == 0)
                          v164 = *(float *)(v69 + 4 * v163);
                        *(float *)(v115 + 4 * v163) = v164;
                        ++v162;
                        ++v161;
                      }
                      while (v162 < (v140 + 8));
                    }
                    ++v160;
                    v159 += a2;
                  }
                  while (v160 < v136);
                }
                break;
              case 2u:
                if (v135 != -4)
                {
                  v165 = v139;
                  v166 = v135;
                  do
                  {
                    if ((_DWORD)v140 != -8)
                    {
                      v167 = 0;
                      v168 = v140;
                      do
                      {
                        v169 = v165 + v167;
                        v170 = -2.0;
                        if (((v166 ^ ((_DWORD)v140 + v167)) & 1) == 0)
                          v170 = *(float *)(v116 + 4 * v169);
                        *(float *)(v115 + 4 * v169) = v170;
                        ++v168;
                        ++v167;
                      }
                      while (v168 < (v140 + 8));
                    }
                    ++v166;
                    v165 += a2;
                  }
                  while (v166 < v136);
                }
                break;
              case 3u:
                if (v135 != -4)
                {
                  v171 = v139;
                  v172 = v135;
                  do
                  {
                    if ((_DWORD)v140 != -8)
                    {
                      v173 = 0;
                      v174 = v140;
                      do
                      {
                        v175 = v171 + v173;
                        v176 = -3.0;
                        if (((v172 ^ ((_DWORD)v140 + v173)) & 1) == 0)
                          v176 = *(float *)(v117 + 4 * v175);
                        *(float *)(v115 + 4 * v175) = v176;
                        ++v174;
                        ++v173;
                      }
                      while (v174 < (v140 + 8));
                    }
                    ++v172;
                    v171 += a2;
                  }
                  while (v172 < v136);
                }
                break;
              default:
                printf("Bad block mode %d (this isn't supposed to happen!)\n", v152);
                v138 = (v135 >> 2) * v228;
                v117 = a8 + 4 * (3 * a3 * a2);
                v116 = a8 + 4 * (2 * a3 * a2);
                v30 = a9;
                v29 = a10;
                v115 = v243;
                break;
            }
            v137 = v140 + 8;
            v139 += 8;
          }
          while ((int)v140 + 8 < a2);
        }
        v236 += v225;
        v135 += 4;
      }
      while (v136 < a3);
LABEL_236:
      v207 = 0;
      while (!(_DWORD)a2)
      {
        v223 = (v207 + 1);
LABEL_272:
        v207 = v223;
        if ((_DWORD)v223 == (_DWORD)a3)
          return;
      }
      v208 = 0;
      v209 = v207 * a2;
      v210 = v207 - 1;
      if ((_DWORD)v207 + 1 == (_DWORD)a3)
        v211 = 0;
      else
        v211 = v207 + 1;
      v212 = v211 * a2;
      v213 = v225 * v207;
      while (1)
      {
        v251 = 0uLL;
        v214 = v234 == 4 && *(_BYTE *)(a12 + (v207 >> 2) * (_DWORD)v228 + (v208 >> 2)) != 0;
        v215 = *(float *)(v115 + 4 * (v209 + v208));
        if (v215 == -1.0)
          break;
        if (v215 == -2.0)
        {
          v218 = *(float *)(v115 + 4 * (v209 + ((int)v208 - 1) % a2));
          v219 = v208 + 1;
          if (v208 + 1 == a2)
            v219 = 0;
          v220 = v219 + v209;
LABEL_255:
          v217 = (float)(v218 + *(float *)(v115 + 4 * v220)) * 0.5;
LABEL_256:
          v215 = 0.0;
          if (v217 >= 0.0)
          {
            v215 = 1.0;
            if (v217 < 1.0)
              v215 = roundf(v217 * 8.0) * 0.125;
          }
          goto LABEL_259;
        }
        if (v215 == -3.0)
        {
          v218 = *(float *)(v115 + 4 * (v208 + v210 % a3 * (_DWORD)a2));
          v220 = v212 + v208;
          goto LABEL_255;
        }
LABEL_259:
        v221 = 0;
        v222 = (4 * (v209 + v208));
        do
        {
          LOBYTE(v25) = *(_BYTE *)(v30 + v213 + v221);
          LOBYTE(v26) = *(_BYTE *)(v29 + v213 + v221);
          *(_BYTE *)(a11 + v213 + v221) = (int)(float)(v215 * 255.0);
          *(float *)&v25 = (float)((float)(1.0 - v215) * (float)LODWORD(v25)) + (float)(v215 * (float)LODWORD(v26));
          v26 = 0.0;
          if (*(float *)&v25 >= 0.0)
          {
            v26 = 255.0;
            if (*(float *)&v25 <= 255.0)
              v26 = *(float *)&v25;
          }
          *(float *)&v25 = *(float *)(a4 + 4 * v213 + 4 * v221) - v26;
          v251.i32[v221++] = LODWORD(v25);
        }
        while (v221 != 4);
        if (!v214
          || *(unsigned __int8 *)(a11 + v222) != 128
          || *(float *)(a4 + 4 * (v222 | 3)) >= 0.033333
          || (*(_BYTE *)(v226 + 8) & 8) == 0)
        {
          a15(a13, &v251, a2, a3, v208, v207);
          v30 = a9;
          v29 = a10;
          v115 = v243;
        }
        ++v208;
        v213 += 4;
        if (v208 == a2)
        {
          v223 = (v207 + 1);
          goto LABEL_272;
        }
      }
      v216 = v208 + 1;
      if (v208 + 1 == a2)
        v216 = 0;
      v217 = (float)((float)((float)(*(float *)(v115 + 4 * (v209 + ((int)v208 - 1) % a2))
                                   + *(float *)(v115 + 4 * (v208 + v210 % a3 * (_DWORD)a2)))
                           + *(float *)(v115 + 4 * (v216 + v209)))
                   + *(float *)(v115 + 4 * (v212 + v208)))
           * 0.25;
      goto LABEL_256;
    }
    v115 = v243;
    if (a3 < 4)
      goto LABEL_236;
    v239 = 0;
    v177 = 0.1875;
    v178 = v224;
    v179 = 0.375;
    if (v224 <= 1)
      v178 = 1;
    v237 = v178;
    v180 = 0.5;
    v181 = 0.8125;
    v182 = 0.625;
    while (1)
    {
      v183 = v228;
      if ((_DWORD)v228)
        break;
LABEL_235:
      if (++v239 == v237)
        goto LABEL_236;
    }
    v184 = 0;
    v241 = v239 * v228;
    v185 = 4 * v239;
    while (1)
    {
      v186 = (*(unsigned __int8 *)(a1 + 8) >> 4) & 3;
      if (v186 == 2)
      {
        *(_BYTE *)(a12 + (v241 + v184)) = 1;
      }
      else
      {
        if (v186 != 1)
        {
          *(_BYTE *)(a12 + (v241 + v184)) = 0;
LABEL_225:
          for (j = 0; j != 16; ++j)
          {
            v206 = (j & 3 | (4 * (_DWORD)v184)) + (v185 + (j >> 2)) * (_DWORD)a2;
            if ((*(_BYTE *)(a1 + 8) & 8) != 0)
            {
              findBestQuantizer(a1, 0xFu, (float32x4_t *)(a4 + 4 * (4 * v206)), (_BYTE *)(v30 + (4 * v206)), (_BYTE *)(a10 + (4 * v206)), v23, v24, v25, v26, *(float *)v27.i32);
              v30 = a9;
              v29 = a10;
              v115 = v243;
            }
            else
            {
              v24 = *(float *)(a8 + 4 * v206);
              LODWORD(v23) = 0;
              if (v24 >= v177)
              {
                LODWORD(v23) = 0.375;
                if (v24 >= v180)
                {
                  if (v24 >= v181)
                    *(float *)&v23 = 1.0;
                  else
                    *(float *)&v23 = v182;
                }
              }
            }
            *(_DWORD *)(v115 + 4 * v206) = LODWORD(v23);
          }
          goto LABEL_234;
        }
        v187 = 0;
        v188 = 0.0;
        v189 = 0.0;
        do
        {
          v251 = 0uLL;
          v249 = 0uLL;
          v190 = (v187 & 3 | (4 * v184)) + (v185 + (v187 >> 2)) * a2;
          v191 = *(float *)(a8 + 4 * v190);
          v247 = 0uLL;
          if (v191 >= 0.8125)
            v192 = 1.0;
          else
            v192 = 0.625;
          if (v191 < 0.5)
            v192 = v179;
          if (v191 < 0.1875)
            v192 = 0.0;
          v193 = 4 * v190;
          if (v191 >= 0.75)
            v194 = 1.0;
          else
            v194 = 0.5;
          if (v191 <= 0.25)
            v195 = 0.0;
          else
            v195 = v194;
          v27.i32[0] = *(_DWORD *)(v30 + v193);
          v196 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v27)));
          v28.i32[0] = *(_DWORD *)(v29 + v193);
          v197 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v28)));
          v251 = vmlaq_n_f32(vmulq_n_f32(v196, 1.0 - v192), v197, v192);
          v249 = vmlaq_n_f32(vmulq_n_f32(v196, 1.0 - v195), v197, v195);
          v198.i64[0] = 0x3F0000003F000000;
          v198.i64[1] = 0x3F0000003F000000;
          v199 = vmulq_f32(vaddq_f32(v196, v197), v198);
          v199.i32[3] = 0;
          v247 = v199;
          v200 = (float32x4_t *)(a4 + 4 * v193);
          v189 = v189 + errorSquared(a1, v200, &v251);
          v201 = errorSquared(a1, v200, &v249);
          *(float *)&v23 = errorSquared(a1, v200, &v247);
          v30 = a9;
          v29 = a10;
          if (*(float *)&v23 >= v201)
            *(float *)&v23 = v201;
          v179 = 0.375;
          v188 = v188 + *(float *)&v23;
          ++v187;
        }
        while (v187 != 16);
        v202 = v188 < v189;
        *(_BYTE *)(a12 + (v241 + v184)) = v188 < v189;
        v115 = v243;
        v183 = v228;
        v181 = 0.8125;
        v182 = 0.625;
        v177 = 0.1875;
        v180 = 0.5;
        if (!v202)
          goto LABEL_225;
      }
      for (k = 0; k != 16; ++k)
      {
        v204 = (k & 3 | (4 * v184)) + (v185 + (k >> 2)) * a2;
        findBestQuantizer(a1, 0x33u, (float32x4_t *)(a4 + 16 * v204), (_BYTE *)(v30 + 4 * v204), (_BYTE *)(a10 + 4 * v204), v23, v24, v25, v26, *(float *)v27.i32);
        v30 = a9;
        v29 = a10;
        v115 = v243;
        *(_DWORD *)(v243 + 4 * v204) = LODWORD(v23);
      }
LABEL_234:
      if (++v184 == v183)
        goto LABEL_235;
    }
  }
}

uint64_t errorApply(uint64_t result, uint64_t a2, float32x4_t *a3, float32x4_t *a4, int32x4_t a5, int32x4_t a6)
{
  float32x4_t v6;
  float32x4_t v7;
  uint64_t v8;
  char v9;
  int8x16_t v10;
  float64x2_t v16;
  float32x4_t v17;
  char v18;
  uint64_t v19;
  float v20;
  float v21;
  float32x4_t v22;
  uint64_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t *v31;
  float v32;
  float v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;

  v8 = 0;
  a5.i32[0] = 4;
  v9 = 1;
  a6.i32[0] = *(_BYTE *)(result + 8) & 7;
  v10 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(a6, a5), 0);
  __asm { FMOV            V1.4S, #1.0 }
  v16 = (float64x2_t)vdupq_n_s64(0x4000ECF52B90A783uLL);
  v17 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  do
  {
    v18 = v9;
    v19 = a2 + 4 * v8;
    v20 = *(float *)(v19 + 4);
    if (v20 != 0.0)
    {
      v21 = *(float *)(v19 + 12);
      v6.i32[0] = *(_DWORD *)a2;
      v22 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0);
      v23 = a2 + 16 * v8;
      v24 = *(float32x4_t *)(v23 + 20);
      v25 = *(float32x4_t *)(v23 + 84);
      v26 = vmulq_n_f32(v24, v20);
      v27 = vdivq_f32(vmulq_f32(v24, v24), v22);
      v28 = vsubq_f32(v25, vdivq_f32(v26, v22));
      v29 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v23 + 52), v27), v21 - (float)((float)(v20 * v20) / *(float *)a2));
      v30 = (float32x4_t)vbslq_s8(v10, _Q1, vbslq_s8(vandq_s8((int8x16_t)vceqzq_f32(v28), (int8x16_t)vceqzq_f32(v29)), _Q1, (int8x16_t)vdivq_f32(vmulq_f32(v28, v28), v29)));
      if ((v18 & 1) != 0)
        v31 = a3;
      else
        v31 = a4;
      v7.f32[0] = *(float *)(a2 + 4) + *(float *)(a2 + 8);
      v32 = 1.0 / (float)-(float)((float)(v20 * v20) - (float)(v6.f32[0] * v21));
      v33 = 0.05 / (float)(v32 + 0.05);
      v7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
      v34 = vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v25, -v20), v24, v21), v32);
      v35 = vmulq_n_f32(vmlaq_n_f32(vnegq_f32(v26), v25, v6.f32[0]), v32);
      v36 = vdivq_f32(v25, v7);
      v37 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v36.f32), v16)), vmulq_f64(vcvt_hight_f64_f32(v36), v16));
      v6 = vmlaq_f32(v37, vsubq_f32(vaddq_f32(v35, v34), v37), vmulq_n_f32(v30, v33));
      v38 = vaddq_f32(*v31, v6);
      *(int8x16_t *)v31 = vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v38, v17), (int8x16_t)v17, (int8x16_t)v38), (int8x16_t)vcltzq_f32(v38));
    }
    v9 = 0;
    v8 = 1;
  }
  while ((v18 & 1) != 0);
  return result;
}

float quantize(float a1, int a2, int a3)
{
  float v3;
  BOOL v4;
  float v5;
  float v6;
  int v7;
  float v8;
  unsigned int v9;
  int v10;

  if (!a2)
    return 255.0;
  v3 = 255.0;
  if (a1 <= 255.0)
    v3 = a1;
  v4 = a1 < 0.0;
  v5 = 0.0;
  if (!v4)
    v5 = v3;
  v6 = rintf((float)((float)(v5 * 15.0) / 255.0) * 0.5);
  v7 = (uint64_t)v6 | (32 * (uint64_t)v6);
  v8 = rintf((float)(v5 * (float)~(-1 << a2)) / 255.0);
  v9 = ((uint64_t)v8 << (5 - a2)) | ((uint64_t)v8 >> (a2 - (5 - a2)));
  v10 = (8 * v9) | (v9 >> 2);
  if (!a3)
    LOBYTE(v7) = v10;
  return (float)v7;
}

char *pvrtcDecompress(const unsigned __int8 *a1, unint64_t a2, unsigned int a3, unsigned int a4, int a5, unsigned __int8 **a6, unsigned __int8 **a7, signed __int8 **a8)
{
  char v13;
  uint64_t v14;
  size_t v15;
  _BYTE *v16;
  _BYTE *v17;
  _BYTE *v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  __int16 v30;
  __int16 v31;
  int v32;
  int v33;
  uint64_t v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  unsigned int v49;
  uint64_t i;
  uint64_t v51;
  uint64_t v52;
  _BYTE *v53;
  char v54;
  unint64_t v55;
  unsigned __int8 v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  _BYTE *v61;
  uint64_t v62;
  _BYTE *v63;
  uint64_t v64;
  _BYTE *v65;
  uint64_t v66;
  _BYTE *v67;
  int v71;

  if (a5 != 4 && a5 != 2)
    return 0;
  if (a5 == 2)
    v13 = 3;
  else
    v13 = 2;
  v14 = a3 >> v13;
  v15 = (a4 & 0xFFFFFFFC) * v14;
  v16 = malloc_type_malloc(v15, 0x100004077774924uLL);
  v17 = malloc_type_malloc(v15, 0x100004077774924uLL);
  v18 = malloc_type_malloc(a4 * a3, 0x100004077774924uLL);
  if (a4 >= 4)
  {
    v71 = 0;
    v35 = 0;
    v36 = v14 - 1;
    v37 = 31 - __clz(v14);
    while (!(_DWORD)v14)
    {
LABEL_68:
      ++v35;
      v71 += 4 * a3;
      if (v35 == a4 >> 2)
        goto LABEL_7;
    }
    v38 = 0;
    v39 = (v36 & v35 | ((v36 & v35) << 8)) & 0xFF00FF;
    v40 = (v39 | (16 * v39)) & 0x3030303 | (4 * ((v39 | (16 * v39)) & 0xF0F0F0F)) & 0x33333333;
    v41 = (v40 | (2 * v40)) & 0x55555555;
    v42 = v14 * v35;
    v43 = 4 * v35;
    v44 = v71;
    while (1)
    {
      v45 = (v36 & v38 | ((v36 & v38) << 8)) & 0xFF00FF;
      v46 = (v45 | (16 * v45)) & 0x3030303 | (4 * ((v45 | (16 * v45)) & 0xF0F0F0F)) & 0x33333333;
      v47 = 8
          * ((((v38 | v35) & -(int)v14) << v37) | v41 | ((4 * v46) | (2 * v46)) & 0xAAAAAAAA);
      if (v47 >= a2)
        break;
      v48 = *(_QWORD *)&a1[v47];
      if (a5 == 2)
      {
        v49 = 8 * v38;
        if ((v48 & 0x100000000) != 0)
        {
          if ((v48 & 0x100000) != 0)
            v54 = 17;
          else
            v54 = 16;
          if ((v48 & 1) != 0)
            v55 = v48 & 0xFFFFFFFFFFEFFFFFLL | (((v48 >> 21) & 1) << 20);
          else
            v55 = v48;
          if ((v48 & 1) != 0)
            v56 = v54;
          else
            v56 = 18;
          v57 = 4;
          v58 = v44;
          do
          {
            *(_QWORD *)&v18[v58] = 0x101010101010101 * v56;
            v58 += a3;
            --v57;
          }
          while (v57);
          v59 = 0;
          v48 = (v55 >> 1) & 1 | v55 & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            v18[(v59 & 6 | (v57 >> 2) & 1 | v49) + (v43 + (v57 >> 2)) * a3] = standardMod[(v48 >> v59) & 3];
            ++v57;
            v59 += 2;
          }
          while (v57 != 16);
        }
        else
        {
          for (i = 0; i != 32; ++i)
            v18[(i & 7 | v49) + (v43 + (i >> 3)) * a3] = binaryMod[(v48 >> i) & 1];
        }
      }
      else
      {
        v51 = 0;
        v52 = 0;
        if ((v48 & 0x100000000) != 0)
          v53 = &punchthroughMod;
        else
          v53 = standardMod;
        do
        {
          v18[(v52 & 3 | (4 * v38)) + (v43 + (v52 >> 2)) * a3] = v53[(v48 >> v51) & 3];
          ++v52;
          v51 += 2;
        }
        while (v52 != 16);
      }
      v60 = (4 * (v42 + v38));
      if ((v48 & 0x800000000000) != 0)
      {
        v63 = &v16[v60];
        *v63 = (v48 >> 42) & 0x1F;
        v63[1] = (v48 >> 37) & 0x1F;
        v63[2] = BYTE4(v48) & 0x1E | ((v48 & 0x1000000000) != 0);
        LOBYTE(v62) = 15;
      }
      else
      {
        v61 = &v16[v60];
        *v61 = (v48 >> 39) & 0x1E | ((v48 & 0x80000000000) != 0);
        v61[1] = (v48 >> 35) & 0x1E | ((v48 & 0x8000000000) != 0);
        v61[2] = (v48 >> 31) & 0x1C | (v48 >> 34) & 3;
        v62 = (v48 >> 43) & 0xE;
      }
      v16[v60 | 3] = v62;
      v64 = (4 * (v42 + v38));
      if ((v48 & 0x8000000000000000) != 0)
      {
        v67 = &v17[v64];
        *v67 = (v48 >> 58) & 0x1F;
        v67[1] = (v48 >> 53) & 0x1F;
        v67[2] = BYTE6(v48) & 0x1F;
        LOBYTE(v66) = 15;
      }
      else
      {
        v65 = &v17[v64];
        *v65 = (v48 >> 55) & 0x1E | ((v48 & 0x800000000000000) != 0);
        v65[1] = (v48 >> 51) & 0x1E | ((v48 & 0x80000000000000) != 0);
        v65[2] = (v48 >> 47) & 0x1E | ((v48 & 0x8000000000000) != 0);
        v66 = (v48 >> 59) & 0xE;
      }
      v17[v64 | 3] = v66;
      ++v38;
      v44 += 8;
      if (v38 == v14)
        goto LABEL_68;
    }
    free(v16);
    free(v17);
    free(v18);
    return 0;
  }
LABEL_7:
  if (a5 == 2 && a4)
  {
    v19 = 0;
    while (!a3)
    {
      v23 = v19 + 1;
LABEL_32:
      v19 = v23;
      if (v23 == a4)
        goto LABEL_33;
    }
    v20 = 0;
    v21 = v19 * a3;
    v22 = v19 - 1;
    v23 = v19 + 1;
    if (v19 + 1 == a4)
      v24 = 0;
    else
      v24 = v19 + 1;
    v25 = v24 * a3;
    v26 = 1 - a3;
    while (1)
    {
      v27 = (v21 + v20);
      v28 = v18[v27];
      if (v28 == 16)
        break;
      if (v28 == 17)
      {
        v31 = (char)v18[v20 + v22 % a4 * a3];
        v32 = v25 + v20;
LABEL_27:
        v30 = (unsigned __int16)(v31 + (char)v18[v32] + 1) >> 1;
LABEL_28:
        v18[v27] = v30;
        goto LABEL_29;
      }
      if (v28 == 18)
      {
        if (v26)
          v29 = v20 + 1;
        else
          v29 = 0;
        v30 = (unsigned __int16)((char)v18[v21 + (v20 - 1) % a3]
                               + (char)v18[v29 + v21]
                               + (char)v18[v25 + v20]
                               + (char)v18[v20 + v22 % a4 * a3]
                               + 2) >> 2;
        goto LABEL_28;
      }
LABEL_29:
      ++v20;
      if (++v26 == 1)
        goto LABEL_32;
    }
    v31 = (char)v18[v21 + (v20 - 1) % a3];
    if (v26)
      v33 = v20 + 1;
    else
      v33 = 0;
    v32 = v33 + v21;
    goto LABEL_27;
  }
LABEL_33:
  *a6 = v16;
  *a7 = v17;
  *a8 = v18;
  return pvrtcDecompressUnpacked(v16, v17, v18, a3, a4, a5);
}

char *pvrtcDecompressUnpacked(const unsigned __int8 *a1, const unsigned __int8 *a2, const signed __int8 *a3, unsigned int a4, unsigned int a5, int a6)
{
  uint64_t (*v7)(uint64_t, const unsigned __int8 *, unsigned int, unsigned int, int, int, double, double, uint8x8_t, uint8x8_t, double, uint8x8_t, double, uint8x8_t);
  char *result;
  uint64_t v9;
  int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  int v17;
  char *v18;
  uint64_t (*v19)(uint64_t, const unsigned __int8 *, unsigned int, unsigned int, int, int, double, double, uint8x8_t, uint8x8_t, double, uint8x8_t, double, uint8x8_t);
  unsigned int v23;
  int v24;
  int v25;

  v7 = bilinearUpsample4u;
  if (a6 == 2)
    v7 = bilinearUpsample84u;
  v19 = v7;
  result = (char *)malloc_type_malloc(4 * a4 * a5, 0x100004077774924uLL);
  if (a5)
  {
    v17 = 0;
    v23 = 0;
    v18 = result;
    do
    {
      if (a4)
      {
        v9 = 0;
        v10 = v17;
        do
        {
          v11 = &result[v10];
          v25 = 0;
          v24 = 0;
          ((void (*)(int *, const unsigned __int8 *, _QWORD, _QWORD, uint64_t, _QWORD))v19)(&v25, a1, a4, a5, v9, v23);
          ((void (*)(int *, const unsigned __int8 *, _QWORD, _QWORD, uint64_t, _QWORD))v19)(&v24, a2, a4, a5, v9, v23);
          v12 = 0;
          v13 = v23 * a4 + v9;
          v14 = a3[v13] & 0xF;
          do
          {
            v11[v12] = *((_BYTE *)&v25 + v12)
                     + (((*((unsigned __int8 *)&v24 + v12) - *((unsigned __int8 *)&v25 + v12)) * v14) >> 3);
            ++v12;
          }
          while (v12 != 3);
          v15 = HIBYTE(v25) + (((HIBYTE(v24) - HIBYTE(v25)) * v14) >> 3);
          if (a3[v13] < 0)
            LOBYTE(v15) = 0;
          result = v18;
          v18[(4 * v13) | 3] = v15;
          ++v9;
          v10 += 4;
        }
        while (v9 != a4);
      }
      v17 += 4 * a4;
      ++v23;
    }
    while (v23 != a5);
  }
  return result;
}

uint64_t bilinearUpsample84u(uint64_t result, const unsigned __int8 *a2, unsigned int a3, unsigned int a4, int a5, int a6, double a7, double a8, uint8x8_t a9, uint8x8_t a10, double a11, uint8x8_t a12, double a13, uint8x8_t a14)
{
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int32x4_t v21;
  int32x4_t v22;
  _QWORD v23[2];

  v14 = 0;
  v23[1] = *MEMORY[0x1E0C80C00];
  v15 = ((a5 - 4) & (a3 - 1)) >> 3;
  v16 = ((a6 - 2) & (a4 - 1)) >> 2;
  v17 = v16 % (a4 >> 2) * (a3 >> 3);
  v18 = v15 % (a3 >> 3);
  v19 = (v15 + 1) % (a3 >> 3);
  v20 = (v16 + 1) % (a4 >> 2) * (a3 >> 3);
  v21 = vdupq_n_s32((a5 - 4) & 7);
  a9.i32[0] = *(_DWORD *)&a2[4 * (v17 + v18)];
  a10.i32[0] = *(_DWORD *)&a2[4 * v19 + 4 * v17];
  a12.i32[0] = *(_DWORD *)&a2[4 * v20 + 4 * v18];
  a14.i32[0] = *(_DWORD *)&a2[4 * v20 + 4 * v19];
  v22 = vmlaq_s32((int32x4_t)vshll_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a9), 3uLL), v21, vshrq_n_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vsubl_u8(a10, a9)), 0x18uLL), 0x18uLL));
  v23[0] = vmovn_s32(vmlaq_s32(vshlq_n_s32(v22, 2uLL), vmlaq_s32(vsubq_s32((int32x4_t)vshll_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a12), 3uLL), v22), v21, vshrq_n_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vsubl_u8(a14, a12)), 0x18uLL), 0x18uLL)), vdupq_n_s32((a6 - 2) & 3)));
  do
  {
    *(_BYTE *)(result + v14) = (*((unsigned __int16 *)v23 + v14) >> 7) + (*((unsigned __int16 *)v23 + v14) >> 2);
    ++v14;
  }
  while (v14 != 3);
  *(_BYTE *)(result + 3) = (HIWORD(v23[0]) >> 5) + (HIWORD(v23[0]) >> 1);
  return result;
}

uint64_t bilinearUpsample4u(uint64_t result, const unsigned __int8 *a2, unsigned int a3, unsigned int a4, int a5, int a6, double a7, double a8, uint8x8_t a9, uint8x8_t a10, double a11, uint8x8_t a12, double a13, uint8x8_t a14)
{
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int32x4_t v21;
  int32x4_t v22;
  _QWORD v23[2];

  v14 = 0;
  v23[1] = *MEMORY[0x1E0C80C00];
  v15 = ((a5 - 2) & (a3 - 1)) >> 2;
  v16 = ((a6 - 2) & (a4 - 1)) >> 2;
  v17 = v16 % (a4 >> 2) * (a3 >> 2);
  v18 = v15 % (a3 >> 2);
  v19 = (v15 + 1) % (a3 >> 2);
  v20 = (v16 + 1) % (a4 >> 2) * (a3 >> 2);
  v21 = vdupq_n_s32((a5 - 2) & 3);
  a9.i32[0] = *(_DWORD *)&a2[4 * (v17 + v18)];
  a10.i32[0] = *(_DWORD *)&a2[4 * v19 + 4 * v17];
  a12.i32[0] = *(_DWORD *)&a2[4 * v20 + 4 * v18];
  a14.i32[0] = *(_DWORD *)&a2[4 * v20 + 4 * v19];
  v22 = vmlaq_s32((int32x4_t)vshll_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a9), 2uLL), v21, vshrq_n_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vsubl_u8(a10, a9)), 0x18uLL), 0x18uLL));
  v23[0] = vmovn_s32(vmlaq_s32(vshlq_n_s32(v22, 2uLL), vmlaq_s32(vsubq_s32((int32x4_t)vshll_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a12), 2uLL), v22), v21, vshrq_n_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vsubl_u8(a14, a12)), 0x18uLL), 0x18uLL)), vdupq_n_s32((a6 - 2) & 3)));
  do
  {
    *(_BYTE *)(result + v14) = (*((unsigned __int16 *)v23 + v14) >> 6) + (*((unsigned __int16 *)v23 + v14) >> 1);
    ++v14;
  }
  while (v14 != 3);
  *(_BYTE *)(result + 3) = BYTE6(v23[0]) + (HIWORD(v23[0]) >> 4);
  return result;
}

uint64_t encodePVRTC(_QWORD *a1, int8x8_t *a2, unsigned int a3, uint64_t a4, int a5, char a6, char a7)
{
  uint64_t result;
  int8x8_t v10;
  unsigned __int8 *v12;
  BOOL v13;
  uint8x8_t v14;
  BOOL v15;
  __int128 *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v24;
  float v25;
  uint64_t v26;
  unint64_t v27;
  int8x8_t v28;
  char *v29;
  float v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  float v34;
  float v35;
  uint64_t v36;
  int8x8_t v37;
  float v38;
  int8x8_t v39;
  _QWORD *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  float v46;
  float v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  float v51;
  size_t v52;
  _QWORD *v53;
  _QWORD *v54;
  unint64_t i;
  unint64_t v56;
  _QWORD v57[2];
  unsigned int v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  result = 0;
  v61 = *MEMORY[0x1E0C80C00];
  v58 = 0;
  v59 = xmmword_18822ADB0;
  v60 = xmmword_18822ADA0;
  v10 = a2[2];
  if (*(_QWORD *)&v10 == *(_QWORD *)&a2[1])
  {
    v12 = (unsigned __int8 *)*a2;
    if (a3 == 2 && *(_QWORD *)&v10 < 0x10uLL)
      return 0;
    v13 = *(_QWORD *)&v10 < 8uLL && a3 == 4;
    v14 = (uint8x8_t)vcnt_s8(v10);
    v14.i16[0] = vaddlv_u8(v14);
    v15 = v13 || v14.u32[0] > 1uLL;
    if (v15 || v12 == 0)
    {
      return 0;
    }
    else
    {
      v17 = &v59;
      if (!a5)
        v17 = &v60;
      v57[0] = v17;
      v57[1] = a3 & 7 | (8 * (a6 & 1)) & 0xCF | (16 * (a7 & 3));
      v18 = 0x10u >> (a3 >> 1);
      if (*(_QWORD *)&v10 / v18 <= 1)
        v19 = 1;
      else
        v19 = *(_QWORD *)&v10 / v18;
      if (*(_QWORD *)&v10 <= 7uLL)
        v20 = 1;
      else
        v20 = *(_QWORD *)&v10 >> 2;
      v21 = v19 * v18;
      v22 = 4 * v20;
      if (v19 * v18 == *(_QWORD *)&v10 && v22 == *(_QWORD *)&v10)
      {
        v40 = pvrtcCompress((uint64_t)v57, v12, *(_QWORD *)&v10, v10.u32[0], 0, &v58);
      }
      else
      {
        v56 = v19;
        v24 = (char *)malloc_type_malloc(16 * v20 * v21, 0x71F07AD6uLL);
        bzero(v24, 16 * v20 * v21);
        v26 = 4 * v21;
        if (a2[1])
        {
          v27 = 0;
          v28 = a2[2];
          do
          {
            v29 = &v24[v26 * v27];
            memcpy(v29, &v12[4 * v27 * *(_QWORD *)&v28], 4 * *(_QWORD *)&v28);
            v28 = a2[2];
            v31 = v21 - *(_QWORD *)&v28;
            if (v21 != *(_QWORD *)&v28)
            {
              v32 = 0;
              do
              {
                v33 = 0;
                v34 = (float)(unint64_t)(v31 + 1);
                v35 = (float)((float)v32 + 1.0) / v34;
                v36 = 4;
                do
                {
                  v37 = a2[2];
                  LOBYTE(v34) = v29[4 * *(_QWORD *)&v37 - 4 + v33];
                  v38 = (float)LODWORD(v34);
                  LOBYTE(v30) = v29[v33];
                  v30 = (float)LODWORD(v30) - v38;
                  v34 = (float)(v38 + (float)(v30 * v35)) + 0.5;
                  v29[4 * *(_QWORD *)&v37 + 4 * v32 + v33++] = (int)v34;
                  --v36;
                }
                while (v36);
                ++v32;
                v28 = a2[2];
                v31 = v21 - *(_QWORD *)&v28;
              }
              while (v32 < v21 - *(_QWORD *)&v28);
            }
            ++v27;
            v39 = a2[1];
          }
          while (v27 < *(_QWORD *)&v39);
        }
        else
        {
          v39 = 0;
        }
        v41 = v22 - *(_QWORD *)&v39;
        v19 = v56;
        if (v22 != *(_QWORD *)&v39)
        {
          v42 = 0;
          do
          {
            if (v21)
            {
              v43 = 0;
              v44 = &v24[v26 * (*(_QWORD *)&v39 + v42)];
              v45 = &v24[v26 * (*(_QWORD *)&v39 + 0x3FFFFFFFFFFFFFFFLL)];
              v46 = (float)(unint64_t)(v41 + 1);
              v47 = (float)((float)v42 + 1.0) / v46;
              v48 = v24;
              do
              {
                v49 = 0;
                v50 = 4 * v43;
                do
                {
                  LOBYTE(v46) = v45[v49 + v50];
                  v51 = (float)LODWORD(v46);
                  LOBYTE(v25) = v48[v49];
                  v25 = (float)LODWORD(v25) - v51;
                  v46 = (float)(v51 + (float)(v25 * v47)) + 0.5;
                  v44[v49 + v50] = (int)v46;
                  ++v49;
                }
                while (v49 != 4);
                ++v43;
                v48 += 4;
              }
              while (v43 != v21);
              v39 = a2[1];
            }
            ++v42;
            v41 = v22 - *(_QWORD *)&v39;
          }
          while (v42 < v22 - *(_QWORD *)&v39);
        }
        v40 = pvrtcCompress((uint64_t)v57, (unsigned __int8 *)v24, v21, 4 * (int)v20, 0, &v58);
        if (v24)
          free(v24);
      }
      if (v40 && (v52 = v58) != 0 && v58 <= 0x1F)
      {
        v53 = malloc_type_malloc(0x20uLL, 0x504FAF6BuLL);
        v54 = v53;
        if (v19 <= v20)
        {
          for (i = 0; i < 0x20; i += v52)
            memcpy((char *)v54 + i, v40, v52);
        }
        else
        {
          *v53 = *v40;
          v53[1] = *v40;
          v53[2] = v40[8];
          v53[3] = v40[8];
        }
        free(v40);
      }
      else
      {
        v54 = v40;
      }
      *a1 = v54;
      a1[1] = v22;
      result = 1;
      a1[2] = v21;
      a1[3] = 0;
    }
  }
  return result;
}

uint64_t decodePVRTC(vImage_Buffer *a1, const unsigned __int8 *a2, unint64_t a3, int a4, int a5, unsigned int a6, unsigned int a7)
{
  unsigned int v7;
  char v8;
  unsigned int v9;
  signed int v10;
  vImagePixelCount v11;
  char *v14;
  signed __int8 *v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;

  v16 = 0;
  v17 = 0;
  v15 = 0;
  if (a5)
    v7 = 1;
  else
    v7 = 2;
  if (a4 == 4)
    v8 = 2;
  else
    v8 = 3;
  if (a4 == 2)
    v8 = 1;
  v9 = a6 >> v8;
  if (a6 >> v8 <= v7)
    v9 = v7;
  if (a7 >> 2 > v7)
    v7 = a7 >> 2;
  if (!a2)
    return 0;
  v10 = v9 << v8;
  v11 = 4 * v7;
  if (((_DWORD)v11 * a4 * (v9 << v8)) >> 3 > a3)
    return 0;
  v14 = pvrtcDecompress(a2, a3, v10, 4 * v7, a4, &v17, &v16, &v15);
  a1->width = v10;
  a1->rowBytes = 4 * v10;
  a1->data = v14;
  a1->height = v11;
  if (v17)
    free(v17);
  if (v16)
    free(v16);
  if (v15)
    free(v15);
  return 1;
}

float errorSquared(uint64_t a1, float32x4_t *a2, float32x4_t *a3)
{
  float32x4_t *v3;
  float32x4_t v4;
  float32x4_t v5;
  float result;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;

  v3 = *(float32x4_t **)a1;
  if ((*(_BYTE *)(a1 + 8) & 8) != 0)
  {
    v7 = 0;
    v8 = a3->f32[3];
    v9 = a2->f32[3];
    v10 = v8 - v9;
    v11 = -v8;
    result = 0.0;
    do
    {
      v12 = (float)((float)(a3->f32[v7] * v11) + (float)(v9 * a2->f32[v7])) * 0.0039216;
      v13 = v12 * v12;
      v14 = (float)(v10 + v12) * (float)(v10 + v12);
      if (v13 > v14)
        v14 = v13;
      result = result + (float)((float)(v3->f32[v7] * v3->f32[v7]) * v14);
      ++v7;
    }
    while (v7 != 3);
  }
  else
  {
    v4 = vmulq_f32(vsubq_f32(*a2, *a3), *v3);
    v5 = vmulq_f32(v4, v4);
    return (float)((float)((float)(v5.f32[0] + 0.0) + v5.f32[1]) + v5.f32[2]) + v5.f32[3];
  }
  return result;
}

void findBestQuantizer(uint64_t a1, unsigned int a2, float32x4_t *a3, _BYTE *a4, _BYTE *a5, double a6, float a7, double a8, float a9, float a10)
{
  uint64_t v15;
  float v16;
  float v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  float v21;
  float v22;
  float v23;
  float32x4_t v24;
  uint64_t v25;

  v15 = 0;
  v25 = *MEMORY[0x1E0C80C00];
  v16 = 3.4028e38;
  do
  {
    if (((a2 >> v15) & 1) != 0)
    {
      v17 = findBestQuantizer(pvrtc_ctx_t *,unsigned int,float *,unsigned char *,unsigned char *)::quants[v15];
      LOBYTE(a7) = *a5;
      LOBYTE(a9) = *a4;
      *(float *)&v18 = (float)(1.0 - v17) * (float)LODWORD(a9);
      *(float *)&v19 = *(float *)&v18 + (float)(v17 * (float)LODWORD(a7));
      LOBYTE(v18) = a5[1];
      LOBYTE(a10) = a4[1];
      *(float *)&v20 = (float)((float)(1.0 - v17) * (float)LODWORD(a10)) + (float)(v17 * (float)v18);
      v24.i64[0] = __PAIR64__(v20, v19);
      LOBYTE(v19) = a5[2];
      LOBYTE(v20) = a4[2];
      v21 = (float)(1.0 - v17) * (float)v20;
      v24.f32[2] = v21 + (float)(v17 * (float)v19);
      v22 = 0.0;
      if (v15 != 5)
      {
        LOBYTE(v22) = a5[3];
        LOBYTE(v21) = a4[3];
        v22 = (float)((float)(1.0 - v17) * (float)LODWORD(v21)) + (float)(v17 * (float)LODWORD(v22));
      }
      v24.f32[3] = v22;
      v23 = errorSquared(a1, a3, &v24);
      if (v23 < v16)
        v16 = v23;
    }
    ++v15;
  }
  while (v15 != 6);
}

_OWORD *jinit_arith_encoder(uint64_t a1)
{
  uint64_t v2;
  _OWORD *result;

  v2 = (**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 560) = v2;
  *(_QWORD *)v2 = start_pass_1;
  *(_QWORD *)(v2 + 16) = finish_pass_0;
  *(_OWORD *)(v2 + 248) = 0u;
  *(_OWORD *)(v2 + 232) = 0u;
  *(_OWORD *)(v2 + 216) = 0u;
  *(_OWORD *)(v2 + 200) = 0u;
  *(_OWORD *)(v2 + 184) = 0u;
  *(_OWORD *)(v2 + 168) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_BYTE *)(v2 + 360) = 113;
  *(_OWORD *)(v2 + 104) = 0u;
  result = (_OWORD *)(v2 + 104);
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  return result;
}

double start_pass_1(uint64_t a1, int a2)
{
  uint64_t v3;
  void (**v4)(uint64_t);
  int v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  void (**v10)(uint64_t);
  uint64_t v11;
  _OWORD *v12;
  _QWORD *v13;
  _OWORD *v14;
  uint64_t v15;
  unsigned int v16;
  void (**v17)(uint64_t);
  uint64_t v18;
  _OWORD *v19;
  _QWORD *v20;
  _OWORD *v21;
  double result;

  v3 = *(_QWORD *)(a1 + 560);
  if (a2)
  {
    v4 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v4 + 10) = 49;
    (*v4)(a1);
  }
  if (*(_DWORD *)(a1 + 348))
  {
    v5 = *(_DWORD *)(a1 + 460);
    if (*(_DWORD *)(a1 + 468))
    {
      if (v5)
        v6 = encode_mcu_AC_refine_0;
      else
        v6 = encode_mcu_DC_refine_0;
    }
    else if (v5)
    {
      v6 = encode_mcu_AC_first_0;
    }
    else
    {
      v6 = encode_mcu_DC_first_0;
    }
  }
  else
  {
    v6 = encode_mcu;
  }
  *(_QWORD *)(v3 + 8) = v6;
  if (*(int *)(a1 + 372) >= 1)
  {
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)(a1 + 8 * v7 + 376);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468))
      {
        v9 = *(_DWORD *)(v8 + 20);
        if (v9 >= 0x10)
        {
          v10 = *(void (***)(uint64_t))a1;
          *((_DWORD *)v10 + 10) = 50;
          *((_DWORD *)v10 + 12) = v9;
          (**(void (***)(uint64_t))a1)(a1);
        }
        v11 = v3 + 8 * (int)v9;
        v14 = *(_OWORD **)(v11 + 104);
        v13 = (_QWORD *)(v11 + 104);
        v12 = v14;
        if (!v14)
        {
          v12 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 64);
          *v13 = v12;
        }
        v12[2] = 0u;
        v12[3] = 0u;
        *v12 = 0u;
        v12[1] = 0u;
        v15 = v3 + 4 * v7;
        *(_DWORD *)(v15 + 64) = 0;
        *(_DWORD *)(v15 + 80) = 0;
      }
      if (*(_DWORD *)(a1 + 464))
      {
        v16 = *(_DWORD *)(v8 + 24);
        if (v16 >= 0x10)
        {
          v17 = *(void (***)(uint64_t))a1;
          *((_DWORD *)v17 + 10) = 50;
          *((_DWORD *)v17 + 12) = v16;
          (**(void (***)(uint64_t))a1)(a1);
        }
        v18 = v3 + 8 * (int)v16;
        v21 = *(_OWORD **)(v18 + 232);
        v20 = (_QWORD *)(v18 + 232);
        v19 = v21;
        if (!v21)
        {
          v19 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 256);
          *v20 = v19;
        }
        v19[14] = 0u;
        v19[15] = 0u;
        v19[12] = 0u;
        v19[13] = 0u;
        v19[10] = 0u;
        v19[11] = 0u;
        v19[8] = 0u;
        v19[9] = 0u;
        v19[6] = 0u;
        v19[7] = 0u;
        v19[4] = 0u;
        v19[5] = 0u;
        v19[2] = 0u;
        v19[3] = 0u;
        *v19 = 0u;
        v19[1] = 0u;
      }
      ++v7;
    }
    while (v7 < *(int *)(a1 + 372));
  }
  *(_OWORD *)(v3 + 24) = xmmword_18822B060;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 48) = 0;
  result = NAN;
  *(_QWORD *)(v3 + 56) = -4294967285;
  *(_QWORD *)(v3 + 96) = *(unsigned int *)(a1 + 316);
  return result;
}

uint64_t finish_pass_0(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v2 = a1[70];
  v3 = *(_QWORD *)(v2 + 24);
  v4 = (*(_DWORD *)(v2 + 32) + (_DWORD)v3 - 1) & 0xFFFF0000;
  if (v4 < v3)
    v4 |= 0x8000uLL;
  result = *(unsigned int *)(v2 + 60);
  v6 = v4 << *(_DWORD *)(v2 + 56);
  *(_QWORD *)(v2 + 24) = v6;
  if ((v6 & 0xF8000000) != 0)
  {
    if ((result & 0x80000000) == 0)
    {
      if (*(_QWORD *)(v2 + 48))
      {
        do
        {
          emit_byte_0(0, a1);
          v7 = *(_QWORD *)(v2 + 48) - 1;
          *(_QWORD *)(v2 + 48) = v7;
        }
        while (v7);
        LODWORD(result) = *(_DWORD *)(v2 + 60);
      }
      result = emit_byte_0((result + 1), a1);
      if (*(_DWORD *)(v2 + 60) == 254)
        result = emit_byte_0(0, a1);
    }
    v8 = *(_QWORD *)(v2 + 48) + *(_QWORD *)(v2 + 40);
    *(_QWORD *)(v2 + 40) = 0;
    *(_QWORD *)(v2 + 48) = v8;
  }
  else
  {
    if ((_DWORD)result)
    {
      if ((result & 0x80000000) == 0)
      {
        if (*(_QWORD *)(v2 + 48))
        {
          do
          {
            emit_byte_0(0, a1);
            v9 = *(_QWORD *)(v2 + 48) - 1;
            *(_QWORD *)(v2 + 48) = v9;
          }
          while (v9);
          result = *(unsigned int *)(v2 + 60);
        }
        result = emit_byte_0(result, a1);
      }
    }
    else
    {
      ++*(_QWORD *)(v2 + 48);
    }
    if (*(_QWORD *)(v2 + 40))
    {
      if (*(_QWORD *)(v2 + 48))
      {
        do
        {
          emit_byte_0(0, a1);
          v10 = *(_QWORD *)(v2 + 48) - 1;
          *(_QWORD *)(v2 + 48) = v10;
        }
        while (v10);
      }
      do
      {
        emit_byte_0(255, a1);
        result = emit_byte_0(0, a1);
        v11 = *(_QWORD *)(v2 + 40) - 1;
        *(_QWORD *)(v2 + 40) = v11;
      }
      while (v11);
    }
  }
  v12 = *(_QWORD *)(v2 + 24);
  if ((v12 & 0x7FFF800) != 0)
  {
    if (*(_QWORD *)(v2 + 48))
    {
      do
      {
        emit_byte_0(0, a1);
        v13 = *(_QWORD *)(v2 + 48) - 1;
        *(_QWORD *)(v2 + 48) = v13;
      }
      while (v13);
      v12 = *(_QWORD *)(v2 + 24);
    }
    result = emit_byte_0((v12 >> 19), a1);
    v14 = *(_QWORD *)(v2 + 24);
    if ((~*(_DWORD *)(v2 + 24) & 0x7F80000) == 0)
    {
      result = emit_byte_0(0, a1);
      v14 = *(_QWORD *)(v2 + 24);
    }
    if ((v14 & 0x7F800) != 0)
    {
      result = emit_byte_0((v14 >> 11), a1);
      if ((~*(_DWORD *)(v2 + 24) & 0x7F800) == 0)
        return emit_byte_0(0, a1);
    }
  }
  return result;
}

uint64_t encode_mcu_DC_first_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  int v14;
  int *v15;
  _BYTE *v16;
  int v17;
  _BOOL4 v18;
  uint64_t v19;
  int v20;
  _BYTE *v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  BOOL v25;
  int v26;
  _BYTE *v27;

  v3 = *(_QWORD *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    v4 = *(_DWORD *)(v3 + 96);
    if (!v4)
    {
      emit_restart(a1, *(_DWORD *)(v3 + 100));
      v4 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v3 + 100) = (*(_DWORD *)(v3 + 100) + 1) & 7;
    }
    *(_DWORD *)(v3 + 96) = v4 - 1;
  }
  if (*(int *)(a1 + 416) >= 1)
  {
    v5 = 0;
    while (1)
    {
      v6 = *(int *)(a1 + 4 * v5 + 420);
      v7 = *(int *)(*(_QWORD *)(a1 + 8 * v6 + 376) + 20);
      v8 = v3 + 8 * v7;
      v11 = *(_QWORD *)(v8 + 104);
      v10 = (_QWORD *)(v8 + 104);
      v9 = v11;
      v12 = v3 + 4 * v6;
      LODWORD(v11) = *(_DWORD *)(v12 + 64);
      v13 = (int *)(v12 + 64);
      v14 = **(__int16 **)(a2 + 8 * v5) >> *(_DWORD *)(a1 + 472);
      v15 = v13 + 4;
      v16 = (_BYTE *)(v9 + v13[4]);
      v17 = v14 - v11;
      if (v14 != (_DWORD)v11)
        break;
      arith_encode(a1, (_BYTE *)(v9 + v13[4]), 0);
      *v15 = 0;
LABEL_30:
      if (++v5 >= *(int *)(a1 + 416))
        return 1;
    }
    *v13 = v14;
    arith_encode(a1, v16, 1);
    v18 = v17 <= 0;
    if (v17 <= 0)
      v19 = 3;
    else
      v19 = 2;
    if (v17 <= 0)
      v20 = 8;
    else
      v20 = 4;
    if (v17 <= 0)
      v17 = -v17;
    arith_encode(a1, v16 + 1, v18);
    v21 = &v16[v19];
    *v15 = v20;
    v22 = v17 - 1;
    if (v22)
    {
      v23 = 1;
      arith_encode(a1, v21, 1);
      v21 = (_BYTE *)(*v10 + 20);
      if (v22 != 1)
      {
        v24 = v22;
        do
        {
          arith_encode(a1, v21, 1);
          v23 *= 2;
          ++v21;
          v25 = v24 > 3;
          v24 >>= 1;
        }
        while (v25);
      }
    }
    else
    {
      v23 = 0;
    }
    arith_encode(a1, v21, 0);
    v26 = 0;
    if (v23 >= (int)((unint64_t)(1 << *(_BYTE *)(a1 + v7 + 224)) >> 1))
    {
      if (v23 <= (int)((unint64_t)(1 << *(_BYTE *)(a1 + v7 + 240)) >> 1))
        goto LABEL_27;
      v26 = *v15 + 8;
    }
    *v15 = v26;
LABEL_27:
    if (v23 >= 2)
    {
      v27 = v21 + 14;
      do
      {
        arith_encode(a1, v27, (v22 & (v23 >> 1)) != 0);
        v25 = v23 > 3;
        v23 >>= 1;
      }
      while (v25);
    }
    goto LABEL_30;
  }
  return 1;
}

uint64_t encode_mcu_AC_first_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  int v16;
  int v17;
  int v18;
  uint64_t *v19;
  _BYTE *v20;
  int *v21;
  _BYTE *v22;
  int i;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  _BYTE *v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  _BYTE *v33;
  int v34;
  unsigned int v35;
  BOOL v36;
  uint64_t v38;
  uint64_t v39;
  unsigned __int8 *v40;
  uint64_t v41;
  _BYTE *v42;

  v4 = *(_QWORD *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    v5 = *(_DWORD *)(v4 + 96);
    if (!v5)
    {
      emit_restart(a1, *(_DWORD *)(v4 + 100));
      v5 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v4 + 100) = (*(_DWORD *)(v4 + 100) + 1) & 7;
    }
    *(_DWORD *)(v4 + 96) = v5 - 1;
  }
  v6 = 0;
  v7 = *(_QWORD *)(a1 + 480);
  v8 = *a2;
  v9 = *(int *)(*(_QWORD *)(a1 + 376) + 24);
  v10 = *(int *)(a1 + 464);
  v11 = *(_DWORD *)(a1 + 464);
  v12 = v7 + 4 * v10;
  v13 = v10 - 1;
  while (1)
  {
    v14 = *(__int16 *)(v8 + 2 * *(int *)(v12 + 4 * v6));
    if ((v14 & 0x80000000) != 0)
      v14 = -v14;
    if (v14 >> *(_DWORD *)(a1 + 472))
      break;
    if (!(v13 + (_DWORD)v6--))
    {
      v16 = 0;
      goto LABEL_12;
    }
  }
  v16 = v11 + v6;
LABEL_12:
  v17 = *(_DWORD *)(a1 + 460);
  v18 = v17 - 1;
  if (v17 > v16)
    goto LABEL_35;
  v19 = (uint64_t *)(v4 + 8 * v9 + 232);
  v38 = *(int *)(*(_QWORD *)(a1 + 376) + 24);
  v39 = v4;
  v40 = (unsigned __int8 *)(a1 + v9 + 256);
  v41 = v7 + 4;
  v42 = (_BYTE *)(v4 + 360);
  do
  {
    v20 = (_BYTE *)(*v19 + 3 * v18);
    arith_encode(a1, v20, 0);
    v21 = (int *)(v41 + 4 * v18);
    v22 = v20 + 1;
    for (i = v18; ; ++i)
    {
      v24 = *v21++;
      v25 = *(__int16 *)(v8 + 2 * v24);
      if ((v25 & 0x80000000) != 0)
        break;
      v26 = v25 >> *(_DWORD *)(a1 + 472);
      if (v26)
      {
        v27 = 0;
        goto LABEL_21;
      }
LABEL_19:
      arith_encode(a1, v22, 0);
      v22 += 3;
    }
    v26 = -v25 >> *(_DWORD *)(a1 + 472);
    if (!v26)
      goto LABEL_19;
    v27 = 1;
LABEL_21:
    arith_encode(a1, v22, 1);
    arith_encode(a1, v42, v27);
    v28 = v22 + 1;
    v29 = v26 - 1;
    if (v26 == 1 || (arith_encode(a1, v28, 1), v26 == 2))
    {
      arith_encode(a1, v28, 0);
      goto LABEL_33;
    }
    arith_encode(a1, v28, 1);
    v30 = *v19;
    v31 = 217;
    if (i < *v40)
      v31 = 189;
    v32 = (_BYTE *)(v30 + v31);
    if (v26 >= 5)
    {
      v34 = 2;
      v35 = v29;
      do
      {
        arith_encode(a1, v32, 1);
        v34 *= 2;
        ++v32;
        v36 = v35 >= 8;
        v35 >>= 1;
      }
      while (v36);
      arith_encode(a1, v32, 0);
      if (v34)
      {
        v33 = v32 + 14;
        goto LABEL_32;
      }
    }
    else
    {
      arith_encode(a1, (_BYTE *)(v30 + v31), 0);
      v33 = v32 + 14;
      v34 = 2;
      do
      {
LABEL_32:
        arith_encode(a1, v33, (v29 & (v34 >> 1)) != 0);
        v36 = v34 >= 4;
        v34 >>= 1;
      }
      while (v36);
    }
LABEL_33:
    v18 = i + 1;
  }
  while (v16 > i + 1);
  v11 = *(_DWORD *)(a1 + 464);
  v18 = i + 1;
  v9 = v38;
  v4 = v39;
LABEL_35:
  if (v18 < v11)
    arith_encode(a1, (_BYTE *)(*(_QWORD *)(v4 + 8 * v9 + 232) + 3 * v18), 1);
  return 1;
}

uint64_t encode_mcu_DC_refine_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  _BYTE *v7;
  int v8;

  v4 = *(_QWORD *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    v5 = *(_DWORD *)(v4 + 96);
    if (!v5)
    {
      emit_restart(a1, *(_DWORD *)(v4 + 100));
      v5 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v4 + 100) = (*(_DWORD *)(v4 + 100) + 1) & 7;
    }
    *(_DWORD *)(v4 + 96) = v5 - 1;
  }
  if (*(int *)(a1 + 416) >= 1)
  {
    v6 = 0;
    v7 = (_BYTE *)(v4 + 360);
    v8 = *(_DWORD *)(a1 + 472);
    do
      arith_encode(a1, v7, (**(__int16 **)(a2 + 8 * v6++) >> v8) & 1);
    while (v6 < *(int *)(a1 + 416));
  }
  return 1;
}

uint64_t encode_mcu_AC_refine_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v18;
  int v19;
  uint64_t *v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int *v26;
  _BYTE *i;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  _BYTE *v32;
  int v33;
  uint64_t v35;
  uint64_t v36;

  v4 = *(_QWORD *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    v5 = *(_DWORD *)(v4 + 96);
    if (!v5)
    {
      emit_restart(a1, *(_DWORD *)(v4 + 100));
      v5 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v4 + 100) = (*(_DWORD *)(v4 + 100) + 1) & 7;
    }
    *(_DWORD *)(v4 + 96) = v5 - 1;
  }
  v6 = 0;
  v7 = *(_QWORD *)(a1 + 480);
  v8 = *a2;
  v9 = *(int *)(*(_QWORD *)(a1 + 376) + 24);
  v10 = *(int *)(a1 + 464);
  v11 = *(_DWORD *)(a1 + 464);
  while (1)
  {
    v12 = *(__int16 *)(v8 + 2 * *(int *)(v7 + 4 * v10 + 4 * v6));
    if ((v12 & 0x80000000) != 0)
      v12 = -v12;
    if (v12 >> *(_DWORD *)(a1 + 472))
      break;
    v13 = v10 + v6--;
    if (v13 == 1)
    {
      v14 = 0;
LABEL_18:
      LODWORD(v15) = 0;
      goto LABEL_20;
    }
  }
  v14 = v11 + v6;
  if (v11 + (int)v6 <= 0)
  {
    LODWORD(v15) = v11 + v6;
  }
  else
  {
    v15 = (v10 + v6);
    while (1)
    {
      v16 = *(__int16 *)(v8 + 2 * *(int *)(v7 + 4 * v15));
      if ((v16 & 0x80000000) != 0)
        v16 = -v16;
      if (v16 >> *(_DWORD *)(a1 + 468))
        break;
      if (v15-- <= 1)
        goto LABEL_18;
    }
  }
LABEL_20:
  v18 = *(_DWORD *)(a1 + 460);
  v19 = v18 - 1;
  if (v18 > v14)
    goto LABEL_37;
  v35 = *(int *)(*(_QWORD *)(a1 + 376) + 24);
  v36 = v4;
  v20 = (uint64_t *)(v4 + 8 * v9 + 232);
  v21 = (_BYTE *)(v4 + 360);
  v22 = v7 + 4;
  do
  {
    v23 = *v20;
    v24 = 3 * v19;
    if (v19 >= (int)v15)
      arith_encode(a1, (_BYTE *)(v23 + v24), 0);
    v25 = v24;
    v26 = (int *)(v22 + 4 * v19++);
    for (i = (_BYTE *)(v23 + v25 + 1); ; i += 3)
    {
      v28 = *v26++;
      v29 = *(__int16 *)(v8 + 2 * v28);
      if ((v29 & 0x80000000) != 0)
        break;
      v30 = v29 >> *(_DWORD *)(a1 + 472);
      if (v30)
      {
        if (v30 == 1)
        {
          arith_encode(a1, i, 1);
          v31 = a1;
          v32 = v21;
          v33 = 0;
          goto LABEL_35;
        }
        goto LABEL_34;
      }
LABEL_29:
      arith_encode(a1, i, 0);
      ++v19;
    }
    v30 = -v29 >> *(_DWORD *)(a1 + 472);
    if (!v30)
      goto LABEL_29;
    if (v30 == 1)
    {
      arith_encode(a1, i, 1);
      v31 = a1;
      v32 = v21;
      v33 = 1;
      goto LABEL_35;
    }
LABEL_34:
    v32 = i + 1;
    v33 = v30 & 1;
    v31 = a1;
LABEL_35:
    arith_encode(v31, v32, v33);
  }
  while (v14 > v19);
  v11 = *(_DWORD *)(a1 + 464);
  v9 = v35;
  v4 = v36;
LABEL_37:
  if (v19 < v11)
    arith_encode(a1, (_BYTE *)(*(_QWORD *)(v4 + 8 * v9 + 232) + 3 * v19), 1);
  return 1;
}

uint64_t encode_mcu(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  __int16 *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int *v16;
  _BYTE *v17;
  int v18;
  int v19;
  _BOOL4 v20;
  uint64_t v21;
  int v22;
  _BYTE *v23;
  int v24;
  unsigned int v25;
  BOOL v26;
  int v27;
  _BYTE *v28;
  int v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  int v34;
  uint64_t *v35;
  _BYTE *v36;
  int v37;
  int v38;
  int *v39;
  uint64_t v40;
  _BOOL4 v41;
  _BYTE *v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  _BYTE *v46;
  _BYTE *v47;
  int v48;
  int v49;
  BOOL v50;
  uint64_t v52;
  uint64_t v54;
  unsigned __int8 *v55;
  uint64_t v56;
  int v57;
  uint64_t v58;

  v3 = *(_QWORD *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    v4 = *(_DWORD *)(v3 + 96);
    if (!v4)
    {
      emit_restart(a1, *(_DWORD *)(v3 + 100));
      v4 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v3 + 100) = (*(_DWORD *)(v3 + 100) + 1) & 7;
    }
    *(_DWORD *)(v3 + 96) = v4 - 1;
  }
  if (*(int *)(a1 + 416) < 1)
    return 1;
  v5 = 0;
  v58 = *(_QWORD *)(a1 + 480);
  do
  {
    v6 = *(__int16 **)(a2 + 8 * v5);
    v7 = *(int *)(a1 + 4 * v5 + 420);
    v8 = *(_QWORD *)(a1 + 8 * v7 + 376);
    v9 = *(int *)(v8 + 20);
    v10 = v3 + 8 * v9;
    v13 = *(_QWORD *)(v10 + 104);
    v12 = (_QWORD *)(v10 + 104);
    v11 = v13;
    v14 = v3 + 4 * v7;
    LODWORD(v13) = *(_DWORD *)(v14 + 64);
    v15 = (_DWORD *)(v14 + 64);
    v16 = v15 + 4;
    v17 = (_BYTE *)(v11 + (int)v15[4]);
    v18 = *v6;
    v19 = v18 - v13;
    v54 = v5;
    v56 = v8;
    if (v18 == (_DWORD)v13)
    {
      arith_encode(a1, v17, 0);
      *v16 = 0;
      goto LABEL_30;
    }
    *v15 = v18;
    arith_encode(a1, v17, 1);
    v20 = v19 <= 0;
    if (v19 <= 0)
      v21 = 3;
    else
      v21 = 2;
    if (v19 <= 0)
      v22 = 8;
    else
      v22 = 4;
    if (v19 <= 0)
      v19 = -v19;
    arith_encode(a1, v17 + 1, v20);
    v23 = &v17[v21];
    *v16 = v22;
    if (v19 == 1)
    {
      v24 = 0;
    }
    else
    {
      v24 = 1;
      arith_encode(a1, v23, 1);
      v23 = (_BYTE *)(*v12 + 20);
      if (v19 != 2)
      {
        v25 = v19 - 1;
        do
        {
          arith_encode(a1, v23, 1);
          v24 *= 2;
          ++v23;
          v26 = v25 > 3;
          v25 >>= 1;
        }
        while (v26);
      }
    }
    arith_encode(a1, v23, 0);
    v27 = 0;
    if (v24 >= (int)((unint64_t)(1 << *(_BYTE *)(a1 + v9 + 224)) >> 1))
    {
      if (v24 <= (int)((unint64_t)(1 << *(_BYTE *)(a1 + v9 + 240)) >> 1))
        goto LABEL_27;
      v27 = *v16 + 8;
    }
    *v16 = v27;
LABEL_27:
    if (v24 >= 2)
    {
      v28 = v23 + 14;
      do
      {
        arith_encode(a1, v28, ((v19 - 1) & (v24 >> 1)) != 0);
        v26 = v24 > 3;
        v24 >>= 1;
      }
      while (v26);
    }
LABEL_30:
    v29 = *(_DWORD *)(a1 + 488);
    v30 = (_BYTE *)(v3 + 360);
    if (!v29)
      goto LABEL_62;
    v31 = 0;
    v32 = *(int *)(v56 + 24);
    while (!v6[*(int *)(v58 + 4 * v29 + 4 * v31)])
    {
      if (!(v29 - 1 + (_DWORD)v31--))
        goto LABEL_59;
    }
    if (v29 + (int)v31 <= 0)
    {
LABEL_59:
      v34 = 0;
      goto LABEL_60;
    }
    v34 = 0;
    v57 = v29 + v31;
    v35 = (uint64_t *)(v3 + 8 * v32 + 232);
    v52 = v32;
    v55 = (unsigned __int8 *)(a1 + v32 + 256);
    do
    {
      v36 = (_BYTE *)(*v35 + 3 * v34);
      arith_encode(a1, v36, 0);
      LOWORD(v37) = v6[*(int *)(v58 + 4 * (v34 + 1))];
      if ((_WORD)v37)
      {
        v38 = v34++;
      }
      else
      {
        v39 = (int *)(v58 + 4 + 4 * (v34 + 1));
        do
        {
          arith_encode(a1, v36 + 1, 0);
          v36 += 3;
          v40 = *v39++;
          LOWORD(v37) = v6[v40];
          ++v34;
        }
        while (!(_WORD)v37);
        v38 = v34++;
      }
      arith_encode(a1, v36 + 1, 1);
      v41 = (__int16)v37 < 1;
      if ((v37 & 0x8000u) == 0)
        v37 = (__int16)v37;
      else
        v37 = -(__int16)v37;
      arith_encode(a1, v30, v41);
      v42 = v36 + 2;
      v43 = v37 - 1;
      if (v37 == 1 || (arith_encode(a1, v42, 1), v37 == 2))
      {
        arith_encode(a1, v42, 0);
        continue;
      }
      arith_encode(a1, v42, 1);
      v44 = *v35;
      v45 = 217;
      if (v38 < *v55)
        v45 = 189;
      v46 = (_BYTE *)(v44 + v45);
      if (v43 < 4)
      {
        arith_encode(a1, (_BYTE *)(v44 + v45), 0);
        v47 = v46 + 14;
        v48 = 2;
        goto LABEL_56;
      }
      v48 = 2;
      v49 = v37 - 1;
      do
      {
        arith_encode(a1, v46, 1);
        v48 *= 2;
        ++v46;
        v50 = v49 >= 8;
        v49 >>= 1;
      }
      while (v50);
      arith_encode(a1, v46, 0);
      v30 = (_BYTE *)(v3 + 360);
      if (v48)
      {
        v47 = v46 + 14;
        do
        {
LABEL_56:
          arith_encode(a1, v47, (v43 & (v48 >> 1)) != 0);
          v50 = v48 >= 4;
          v48 >>= 1;
        }
        while (v50);
      }
    }
    while (v34 < v57);
    v29 = *(_DWORD *)(a1 + 488);
    v32 = v52;
LABEL_60:
    if (v34 < v29)
      arith_encode(a1, (_BYTE *)(*(_QWORD *)(v3 + 8 * v32 + 232) + 3 * v34), 1);
LABEL_62:
    v5 = v54 + 1;
  }
  while (v54 + 1 < *(int *)(a1 + 416));
  return 1;
}

double emit_restart(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD *v7;
  uint64_t v8;
  _OWORD *v9;
  double result;

  v4 = *(_QWORD *)(a1 + 560);
  finish_pass_0((uint64_t *)a1);
  emit_byte_0(255, (uint64_t *)a1);
  emit_byte_0((a2 + 208), (uint64_t *)a1);
  if (*(int *)(a1 + 372) >= 1)
  {
    v5 = 0;
    do
    {
      v6 = *(_QWORD *)(a1 + 376 + 8 * v5);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468))
      {
        v7 = *(_OWORD **)(v4 + 8 * *(int *)(v6 + 20) + 104);
        v7[2] = 0uLL;
        v7[3] = 0uLL;
        *v7 = 0uLL;
        v7[1] = 0uLL;
        v8 = v4 + 4 * v5;
        *(_DWORD *)(v8 + 64) = 0;
        *(_DWORD *)(v8 + 80) = 0;
      }
      if (*(_DWORD *)(a1 + 464))
      {
        v9 = *(_OWORD **)(v4 + 8 * *(int *)(v6 + 24) + 232);
        v9[14] = 0uLL;
        v9[15] = 0uLL;
        v9[12] = 0uLL;
        v9[13] = 0uLL;
        v9[10] = 0uLL;
        v9[11] = 0uLL;
        v9[8] = 0uLL;
        v9[9] = 0uLL;
        v9[6] = 0uLL;
        v9[7] = 0uLL;
        v9[4] = 0uLL;
        v9[5] = 0uLL;
        v9[2] = 0uLL;
        v9[3] = 0uLL;
        *v9 = 0uLL;
        v9[1] = 0uLL;
      }
      ++v5;
    }
    while (v5 < *(int *)(a1 + 372));
  }
  *(_OWORD *)(v4 + 24) = xmmword_18822B060;
  *(_QWORD *)(v4 + 40) = 0;
  *(_QWORD *)(v4 + 48) = 0;
  result = NAN;
  *(_QWORD *)(v4 + 56) = -4294967285;
  return result;
}

uint64_t arith_encode(uint64_t result, _BYTE *a2, int a3)
{
  uint64_t *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v3 = (uint64_t *)result;
  v4 = *a2;
  v5 = jpeg_aritab[v4 & 0x7F];
  v6 = *(_QWORD *)(result + 560);
  v7 = v5 >> 16;
  v8 = *(_QWORD *)(v6 + 32) - (v5 >> 16);
  *(_QWORD *)(v6 + 32) = v8;
  if (a3 != v4 >> 7)
  {
    if (v8 >= v7)
    {
      *(_QWORD *)(v6 + 24) += v8;
      *(_QWORD *)(v6 + 32) = v7;
    }
    v10 = v5 ^ v4 & 0x80;
    goto LABEL_9;
  }
  if (v8 < 0x8000)
  {
    v9 = v5 >> 8;
    if (v8 < v7)
    {
      *(_QWORD *)(v6 + 24) += v8;
      *(_QWORD *)(v6 + 32) = v7;
    }
    v10 = v9 ^ v4 & 0x80;
LABEL_9:
    *a2 = v10;
    v12 = *(_QWORD *)(v6 + 24);
    v11 = *(_QWORD *)(v6 + 32);
    v13 = *(_DWORD *)(v6 + 56);
    while (1)
    {
      v11 *= 2;
      v12 *= 2;
      *(_QWORD *)(v6 + 24) = v12;
      *(_QWORD *)(v6 + 32) = v11;
      *(_DWORD *)(v6 + 56) = --v13;
      if (!v13)
        break;
LABEL_34:
      if (v11 >= 0x8000)
        return result;
    }
    if (v12 < 0x8000000)
    {
      if (v12 >> 19 == 255)
      {
        ++*(_QWORD *)(v6 + 40);
LABEL_33:
        v11 = *(_QWORD *)(v6 + 32);
        v12 = *(_QWORD *)(v6 + 24) & 0x7FFFFLL;
        *(_QWORD *)(v6 + 24) = v12;
        v13 = *(_DWORD *)(v6 + 56) + 8;
        *(_DWORD *)(v6 + 56) = v13;
        goto LABEL_34;
      }
      result = *(unsigned int *)(v6 + 60);
      if ((_DWORD)result)
      {
        if ((result & 0x80000000) == 0)
        {
          if (*(_QWORD *)(v6 + 48))
          {
            do
            {
              emit_byte_0(0, v3);
              v17 = *(_QWORD *)(v6 + 48) - 1;
              *(_QWORD *)(v6 + 48) = v17;
            }
            while (v17);
            result = *(unsigned int *)(v6 + 60);
          }
          result = emit_byte_0(result, v3);
        }
      }
      else
      {
        ++*(_QWORD *)(v6 + 48);
      }
      if (*(_QWORD *)(v6 + 40))
      {
        if (*(_QWORD *)(v6 + 48))
        {
          do
          {
            emit_byte_0(0, v3);
            v18 = *(_QWORD *)(v6 + 48) - 1;
            *(_QWORD *)(v6 + 48) = v18;
          }
          while (v18);
        }
        do
        {
          emit_byte_0(255, v3);
          result = emit_byte_0(0, v3);
          v19 = *(_QWORD *)(v6 + 40) - 1;
          *(_QWORD *)(v6 + 40) = v19;
        }
        while (v19);
      }
    }
    else
    {
      v14 = *(_DWORD *)(v6 + 60);
      if ((v14 & 0x80000000) == 0)
      {
        if (*(_QWORD *)(v6 + 48))
        {
          do
          {
            emit_byte_0(0, v3);
            v15 = *(_QWORD *)(v6 + 48) - 1;
            *(_QWORD *)(v6 + 48) = v15;
          }
          while (v15);
          v14 = *(_DWORD *)(v6 + 60);
        }
        result = emit_byte_0((v14 + 1), v3);
        if (*(_DWORD *)(v6 + 60) == 254)
          result = emit_byte_0(0, v3);
      }
      v16 = *(_QWORD *)(v6 + 48) + *(_QWORD *)(v6 + 40);
      *(_QWORD *)(v6 + 40) = 0;
      *(_QWORD *)(v6 + 48) = v16;
    }
    *(_DWORD *)(v6 + 60) = (v12 >> 19);
    goto LABEL_33;
  }
  return result;
}

uint64_t emit_byte_0(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t v6;

  v2 = a2[5];
  v3 = (_BYTE *)(*(_QWORD *)v2)++;
  *v3 = result;
  v4 = *(_QWORD *)(v2 + 8) - 1;
  *(_QWORD *)(v2 + 8) = v4;
  if (!v4)
  {
    result = (*(uint64_t (**)(uint64_t *))(v2 + 24))(a2);
    if (!(_DWORD)result)
    {
      v6 = *a2;
      *(_DWORD *)(v6 + 40) = 25;
      return (*(uint64_t (**)(uint64_t *))v6)(a2);
    }
  }
  return result;
}

void ETCTextureImp::~ETCTextureImp(ETCTextureImp *this, uint64_t a2, const char *a3)
{
  IIOImageRead **Source;
  const void *v5;

  *(_QWORD *)this = &off_1E1BAC908;
  if (*((_QWORD *)this + 3))
  {
    Source = (IIOImageRead **)CGImageSourceGetSource(*((_QWORD *)this + 4));
    if (Source)
      IIOImageReadSession::releaseBytePointer(Source, *((void **)this + 3));
  }
  v5 = (const void *)*((_QWORD *)this + 4);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 4) = 0;
  _cg_jpeg_mem_term(this, a2, a3);
}

{
  ETCTextureImp::~ETCTextureImp(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t ETCTextureImp::loadDataFromXPCObject(ETCTextureImp *this, xpc_object_t xdict)
{
  const void *data;
  size_t length;

  length = 0;
  data = xpc_dictionary_get_data(xdict, "iio_xpc_plugin_data_etc_imp", &length);
  if (length == 544)
  {
    memcpy((char *)this + 16, data, 0x220uLL);
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 2) = 0;
  }
  return 0;
}

uint64_t ETCTextureImp::saveDataToXPCObject(ETCTextureImp *this, void *a2)
{
  iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_etc_imp", (char *)this + 16, 0x220uLL);
  return 0;
}

uint64_t ETCTextureImp::textureDataLockData(ETCTextureImp *this, IIOImageReadSession *a2, unint64_t a3, unint64_t a4, IIOImageRead **a5, unint64_t *a6, unint64_t *a7)
{
  const void *v13;
  uint64_t result;
  char *v15;

  if (!*((_QWORD *)this + 2))
  {
    *((_QWORD *)this + 2) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 3, 1);
    v13 = (const void *)IIOImageSource::cf(a2);
    *((_QWORD *)this + 4) = v13;
    CFRetain(v13);
    if (!*((_QWORD *)this + 2))
      _cg_jpeg_mem_term("textureDataLockData", 168, "*** Can't access image data\n");
  }
  if (a3 >= 0x1F)
    a3 = 31;
  *a5 = IIOImageReadSession::getSize(a2);
  result = *((_QWORD *)this + 2);
  v15 = (char *)this + 8 * a3 + 16;
  *a6 = *((_QWORD *)v15 + 4);
  *a7 = *((_QWORD *)v15 + 36);
  return result;
}

uint64_t ETCReadPlugin::ETCReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v13;

  v6 = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *v6 = &off_1E1BAC7E8;
  v7 = (uint64_t)(v6 + 62);
  v6[62] = 0;
  v6[63] = 0;
  v8 = operator new(0x248uLL);
  v8[1] = 0;
  v8[2] = 0;
  *v8 = &off_1E1BBC260;
  *((_DWORD *)v8 + 8) = *(_DWORD *)(a1 + 208);
  v8[3] = &off_1E1BAC908;
  bzero(v8 + 5, 0x220uLL);
  *(_QWORD *)&v13 = v8 + 3;
  *((_QWORD *)&v13 + 1) = v8;
  std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>(v7, &v13);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
  if (*((_QWORD *)&v13 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  *(_QWORD *)(a1 + 488) = 0;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  return a1;
}

void sub_188011CD4(_Unwind_Exception *a1)
{
  IIOReadPlugin *v1;
  uint64_t v2;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v2);
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

uint64_t ETCReadPlugin::ETCReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v11;

  v4 = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *v4 = &off_1E1BAC7E8;
  v5 = (uint64_t)(v4 + 62);
  v4[62] = 0;
  v4[63] = 0;
  v6 = operator new(0x248uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1E1BBC260;
  *((_DWORD *)v6 + 8) = *(_DWORD *)(a1 + 208);
  v6[3] = &off_1E1BAC908;
  bzero(v6 + 5, 0x220uLL);
  *(_QWORD *)&v11 = v6 + 3;
  *((_QWORD *)&v11 + 1) = v6;
  std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>(v5, &v11);
  v7 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
  if (*((_QWORD *)&v11 + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  *(_QWORD *)(a1 + 488) = 0;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  return a1;
}

void sub_188011DD8(_Unwind_Exception *a1)
{
  IIOReadPlugin *v1;
  uint64_t v2;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v2);
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void ETCReadPlugin::~ETCReadPlugin(ETCReadPlugin *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E1BAC7E8;
  v2 = (const void *)*((_QWORD *)this + 61);
  if (v2)
    CFRelease(v2);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)this + 496);
  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  ETCReadPlugin::~ETCReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t ETCReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 13)
    return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, 0, 0, (uint64_t)IIO_Reader::CopyImageTextureDataProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t ETCReadPlugin::loadDataFromXPCObject(ETCReadPlugin *this, void *a2)
{
  uint64_t result;
  __int128 *data;
  __int128 v6;
  __int128 v7;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = (__int128 *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_etc", &length);
    if (length == 48)
    {
      v6 = *data;
      v7 = data[2];
      *(_OWORD *)((char *)this + 456) = data[1];
      *(_OWORD *)((char *)this + 472) = v7;
      *(_OWORD *)((char *)this + 440) = v6;
      *((_QWORD *)this + 59) = 0;
      return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 62) + 16))(*((_QWORD *)this + 62), a2);
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t ETCReadPlugin::saveDataToXPCObject(ETCReadPlugin *this, void *a2)
{
  uint64_t result;

  result = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_etc", (char *)this + 440, 0x30uLL);
    return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 62) + 24))(*((_QWORD *)this + 62), a2);
  }
  return result;
}

uint64_t ETCReadPlugin::initialize(ETCReadPlugin *this, IIODictionary *a2)
{
  uint64_t v3;
  IIOImageRead *Size;
  uint64_t v5;
  int v7;
  unint64_t v8;
  __int32 v9;
  int v10;
  int v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  unint64_t v25;
  int v26;
  unint64_t v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  char v31;
  unsigned int v32;
  CFStringRef *v33;
  char *v34;
  __int16 v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  IIOImageRead *v40;
  uint64_t v41;
  _OWORD v42[6];
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t v48;
  int __dst;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  int8x16_t v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  __dst = 0;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v48 = 0;
  v46 = 0u;
  v47 = 0u;
  v45 = 0u;
  v44 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v44, *((IIOImageReadSession **)this + 3));
  if (!*((_BYTE *)this + 341))
    goto LABEL_4;
  v3 = *((_QWORD *)this + 62);
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v44, &__dst, *((_QWORD *)this + 24), 4uLL) != 4)
    goto LABEL_4;
  Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  if (__dst == 542327876)
    goto LABEL_4;
  v7 = *((_DWORD *)this + 51);
  if (v7 == 1261585748)
  {
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v50 = 0u;
    if (IIOScanner::getBytesAtOffset((IIOScanner *)&v44, &v50, *((_QWORD *)this + 24), 0x50uLL) != 80
      || !IsKTX2Header(&v50))
    {
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= v52)
    {
      _cg_jpeg_mem_term("initialize", 421, "*** ERROR: Invalid numberOfArrayElements (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= v53)
    {
      _cg_jpeg_mem_term("initialize", 422, "*** ERROR: Invalid dfdOffset (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= DWORD1(v53))
    {
      _cg_jpeg_mem_term("initialize", 423, "*** ERROR: Invalid dfdLength (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= DWORD2(v53))
    {
      _cg_jpeg_mem_term("initialize", 424, "*** ERROR: Invalid kvdOffset (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= HIDWORD(v53))
    {
      _cg_jpeg_mem_term("initialize", 425, "*** ERROR: Invalid kvdLength (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v54 >= (unint64_t)v45)
    {
      _cg_jpeg_mem_term("initialize", 426, "*** ERROR: Invalid scgdOffset (%d).");
      goto LABEL_4;
    }
    if (*((_QWORD *)&v54 + 1) >= (unint64_t)v45)
    {
      _cg_jpeg_mem_term("initialize", 427, "*** ERROR: Invalid scgdLength (%d).");
      goto LABEL_4;
    }
    v43 = 0;
    memset(v42, 0, sizeof(v42));
    v41 = 0;
    if (!CreateKtxStream((uint64_t)v42, *((IIOImageReadSession **)this + 3)))
    {
      v21 = ktxTexture2_CreateFromStream((uint64_t (**)(_QWORD, _OWORD *, uint64_t))v42, 0, &v41);
      if (v21)
      {
        _cg_jpeg_mem_term("initialize", 436, "*** ERROR: ktxTexture2_CreateFromStream failed [%d]\n", v21);
        goto LABEL_4;
      }
      *((_QWORD *)this + 59) = v41;
      v22 = HIDWORD(v50);
      *((_DWORD *)this + 120) = HIDWORD(v50);
      v23 = v22 - 147;
      if (v23 >= 0xA)
        v24 = 0;
      else
        v24 = dword_18822B120[v23];
      *((_DWORD *)this + 113) = v24;
      *((_BYTE *)this + 344) = 0;
      v36 = *(_QWORD *)((char *)&v51 + 4);
      *((uint32x2_t *)this + 57) = vshr_n_u32((uint32x2_t)vadd_s32(*(int32x2_t *)((char *)&v51 + 4), (int32x2_t)0x300000003), 2uLL);
      v37 = DWORD2(v52);
      if (DWORD2(v52) >= 0x1F)
        v37 = 31;
      *((_DWORD *)this + 112) = v37;
      v11 = HIDWORD(v36);
      v10 = v36;
      goto LABEL_46;
    }
LABEL_4:
    kdebug_trace();
    v5 = 4294967246;
    goto LABEL_5;
  }
  if (v7 != 1262834755)
  {
    v10 = 0;
    v11 = 0;
    goto LABEL_46;
  }
  v8 = (unint64_t)Size;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v44, &v55, *((_QWORD *)this + 24), 0x40uLL) != 64)
    goto LABEL_4;
  SwapKTXHeader(&v55);
  v9 = v55.i32[3];
  *((_DWORD *)this + 113) = HIDWORD(v56);
  *((_BYTE *)this + 344) = v9 == 67305985;
  v10 = DWORD1(v57);
  if (v8 <= DWORD1(v57))
  {
    v39 = 349;
LABEL_71:
    _cg_jpeg_mem_term("initialize", v39, "*** bad dimension: %d x %d  (fileSize: %d)\n", DWORD1(v57), DWORD2(v57), v8);
    goto LABEL_4;
  }
  v11 = DWORD2(v57);
  if (v8 <= DWORD2(v57))
  {
    v39 = 350;
    goto LABEL_71;
  }
  *((uint32x2_t *)this + 57) = vshr_n_u32((uint32x2_t)vadd_s32(*(int32x2_t *)((char *)&v57 + 4), (int32x2_t)0x300000003), 2uLL);
  v12 = DWORD2(v58);
  v13 = HIDWORD(v58) + 64;
  *((_QWORD *)this + 24) = v13;
  if (v12 >= 0x1F)
    v14 = 31;
  else
    v14 = v12;
  *((_DWORD *)this + 112) = v14;
  if (v14)
  {
    v15 = 0;
    v16 = v45;
    v17 = v13;
    while (1)
    {
      *(_QWORD *)&v42[0] = 0;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v44, v42, v17, 8uLL) != 8)
        break;
      v18 = v17 + 4;
      v19 = v16 - (v17 + 4);
      if (v16 <= v17 + 4)
      {
        *((_DWORD *)this + 112) = v15;
        goto LABEL_39;
      }
      if (*(_QWORD *)&v42[0] < v19)
        v19 = *(_QWORD *)&v42[0];
      if (v15 <= 0x1F)
      {
        v20 = v3 + 8 * v15;
        *(_QWORD *)(v20 + 48) = v18;
        *(_QWORD *)(v20 + 304) = v19;
      }
      v13 = v19 + v18;
      v17 = ((v19 + 3) & 0xFFFFFFFFFFFFFFFCLL) + v18;
      if (++v15 >= *((unsigned int *)this + 112))
        goto LABEL_39;
    }
    _cg_jpeg_mem_term("initialize", 368, "*** ETC - failed to read %d bytes\n", 8);
    goto LABEL_4;
  }
LABEL_39:
  v25 = *((unsigned int *)this + 115) * (unint64_t)*((unsigned int *)this + 114);
  v26 = *((_DWORD *)this + 113) - 37490;
  if (v26 >= 8)
    v27 = 8;
  else
    v27 = qword_18822B0E0[v26];
  if (!is_mul_ok(v25, v27))
  {
    _cg_jpeg_mem_term("initialize", 398, "*** ERROR: ETC-image too big\n");
    goto LABEL_4;
  }
  if (*(_QWORD *)(v3 + 304) < v25 * v27)
  {
    _cg_jpeg_mem_term("initialize", 400, "*** ERROR: ETC-levelSize too small\n");
    goto LABEL_4;
  }
  if (v13 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3)))
  {
    v40 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
    _cg_jpeg_mem_term("initialize", 401, "***ERROR: ETC (KTX) file truncated. File Size: %lu, expected %lu\n", v40, v13);
    goto LABEL_4;
  }
  *((_QWORD *)this + 55) = *(_QWORD *)(v3 + 304);
  *((_QWORD *)this + 24) += 4;
LABEL_46:
  *((_DWORD *)this + 57) = v10;
  *((_DWORD *)this + 58) = v11;
  v28 = *((_DWORD *)this + 114);
  *((_DWORD *)this + 73) = 4 * v28;
  if (v28 >> 30)
  {
    v38 = 461;
LABEL_68:
    _cg_jpeg_mem_term("initialize", v38, "*** ERROR: ETC-image too big\n");
    goto LABEL_4;
  }
  v29 = *((_DWORD *)this + 115);
  *((_DWORD *)this + 74) = 4 * v29;
  if (v29 >> 30)
  {
    v38 = 463;
    goto LABEL_68;
  }
  *(_WORD *)((char *)this + 345) = 1;
  *((_DWORD *)this + 81) = 1380401696;
  *((_WORD *)this + 122) = 4;
  *((_BYTE *)this + 247) = 2;
  *((_DWORD *)this + 59) = 16 * v10;
  *((_DWORD *)this + 60) = 8388640;
  v30 = *((_DWORD *)this + 113);
  if ((v30 - 37494) >= 4)
    v31 = 5;
  else
    v31 = 3;
  *((_BYTE *)this + 246) = v31;
  v32 = v30 - 37493;
  if (v32 > 4)
    v33 = (CFStringRef *)MEMORY[0x1E0C9D990];
  else
    v33 = (CFStringRef *)qword_1E1BC98B8[v32];
  *((_QWORD *)this + 20) = CGColorSpaceCreateWithName(*v33);
  v34 = getenv("IIO_useV3");
  if (v34 && !atoi(v34))
    v35 = 1;
  else
    v35 = 13;
  *((_WORD *)this + 188) = v35;
  if (*((_BYTE *)this + 177))
    ImageIOLog("    ETC:\n");
  v5 = 0;
LABEL_5:
  IIOScanner::~IIOScanner((IIOScanner *)&v44);
  return v5;
}

void sub_188012604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a27);
  _Unwind_Resume(a1);
}

uint64_t ETCReadPlugin::decodeETCtoRGBX(ETCReadPlugin *this, unint64_t *a2, uint64_t a3, vImage_Buffer *a4)
{
  int v4;

  v4 = *((_DWORD *)this + 113) - 37488;
  if (v4 >= 0xA)
  {
    _cg_jpeg_mem_term("decodeETCtoRGBX", 559, "*** ETC - unknown GL pixel format\n", a4);
    return 4294967246;
  }
  else if (nv::DecompressETC_EAC(dword_18822B148[v4], a4->width, a4->height, a2, a3, (uint64_t)a4->data))
  {
    return 0;
  }
  else
  {
    return 4294967246;
  }
}

uint64_t ETCReadPlugin::decodeETCtoRGBX(ETCReadPlugin *this, IIOImageReadSession *a2, vImage_Buffer *a3)
{
  uint64_t v6;
  IIOImageRead *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  IIOImageRead *Size;
  uint64_t v14;
  IIOImageRead *v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t BytesAtOffset;
  uint64_t v20;
  void *v22;

  v6 = *((_QWORD *)this + 62);
  v22 = 0;
  v7 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v22, 0);
  v8 = *((unsigned int *)this + 52);
  if (v8 > 0x1F)
  {
    if (!v7)
      goto LABEL_8;
    v10 = 0;
    v11 = 0;
  }
  else
  {
    if (!v7)
      goto LABEL_8;
    v9 = v6 + 8 * v8;
    v10 = *(_QWORD *)(v9 + 304);
    v11 = *(_QWORD *)(v9 + 48);
  }
  v12 = (unint64_t *)((char *)v7 + v11);
  if ((((unint64_t)v7 + v11) & 0xF) == 0)
  {
    v16 = 0;
    goto LABEL_19;
  }
  IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v22);
  v22 = 0;
LABEL_8:
  Size = IIOImageReadSession::getSize(a2);
  v14 = *((unsigned int *)this + 52);
  if (v14 > 0x1F)
    v15 = 0;
  else
    v15 = *(IIOImageRead **)(v6 + 8 * v14 + 48);
  v10 = Size - v15;
  if (Size == v15)
    goto LABEL_17;
  v16 = (unint64_t *)malloc_type_malloc(Size - v15, 0xD6692E6uLL);
  v17 = *((unsigned int *)this + 52);
  if (v17 > 0x1F)
    v18 = 0;
  else
    v18 = *(_QWORD *)(v6 + 8 * v17 + 48);
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, v18, v10);
  if (v10 == BytesAtOffset)
  {
    v12 = v16;
    if (!v16)
    {
LABEL_17:
      _cg_jpeg_mem_term("decodeETCtoRGBX", 606, "*** tempLinearBuffer is nil\n");
      v20 = 0;
      goto LABEL_21;
    }
LABEL_19:
    v20 = ETCReadPlugin::decodeETCtoRGBX(this, v12, v10, a3);
    if (!v16)
      goto LABEL_21;
    goto LABEL_20;
  }
  _cg_jpeg_mem_term("decodeETCtoRGBX", 603, "got: %ld expected: %ld\n", BytesAtOffset, v10);
  v20 = 0;
  if (v16)
LABEL_20:
    free(v16);
LABEL_21:
  if (v22)
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v22);
  return v20;
}

uint64_t ETCReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t BlockArray;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v20;
  IIOImageRead **v21;
  _BOOL4 v22;
  vImagePixelCount v23;
  vImagePixelCount v24;
  size_t v25;
  void *BaseAddress;
  size_t Height;
  double v28;
  double v29;
  unsigned int v30;
  unint64_t v31;
  unsigned int DataSize;
  _BOOL4 v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t *v36;
  uint64_t KTXTexture;
  IIOImageReadSession *v38;
  uint64_t v39;
  int8x16_t v40;
  const char **v41;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  double v46;
  double v47;
  IOSurfaceRef *v48;
  size_t v49;
  vImage_Buffer dest;
  int v51;
  unint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  size_t v55[2];
  CGRect v56;
  CGRect v57;

  v55[0] = 0;
  if (*((_BYTE *)this + 410) == 1 && *((_QWORD *)this + 49) != 16)
    return 4294967246;
  *((_QWORD *)this + 49) = 16;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v8 = *((_DWORD *)this + 51);
    v9 = v8 >> 24;
    v10 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v11 = __maskrune(v9, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    }
    if (v11)
      v13 = (v8 >> 24);
    else
      v13 = 46;
    v14 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v15 = __maskrune(v14, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v15 = *(_DWORD *)(v10 + 4 * v14 + 60) & 0x40000;
    }
    if (v15)
      v16 = (v8 << 8 >> 24);
    else
      v16 = 46;
    v17 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v18 = __maskrune(v17, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v18 = *(_DWORD *)(v10 + 4 * v17 + 60) & 0x40000;
    }
    if (v18)
      v19 = ((__int16)v8 >> 8);
    else
      v19 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_25;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_25:
      v20 = *((_DWORD *)this + 51);
LABEL_28:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v13, v16, v19, (char)v20, iioTypeStr[a3], "virtual OSStatus ETCReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_29;
    }
    LOBYTE(v20) = 46;
    goto LABEL_28;
  }
LABEL_29:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v21 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v21)
    v22 = IIOImageReadSession::mapData(v21);
  else
    v22 = 0;
  v23 = *((unsigned int *)this + 73);
  v24 = *((unsigned int *)this + 74);
  v25 = *((unsigned int *)this + 75);
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    v30 = *((_DWORD *)this + 74);
    LODWORD(v31) = *((_DWORD *)this + 73);
    v28 = (double)v30;
    v29 = (double)v31;
    v49 = *((unsigned int *)this + 75) * (unint64_t)v30;
    BaseAddress = (void *)_ImageIO_Malloc(v49, *((_QWORD *)this + 48), v55, (uint64_t)kImageMalloc_ETC_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      BlockArray = 0;
      goto LABEL_65;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v49 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v55[0] = v49;
    v28 = 0.0;
    v29 = 0.0;
  }
  if (!BaseAddress)
    goto LABEL_65;
  if (*((_DWORD *)this + 51) != 1261585748)
  {
    dest.data = BaseAddress;
    dest.height = v24;
    dest.width = v23;
    dest.rowBytes = v25;
    v38 = (IIOImageReadSession *)*((_QWORD *)this + 3);
    if (v38)
      BlockArray = ETCReadPlugin::decodeETCtoRGBX(this, v38, &dest);
    v36 = 0;
    if (!(_DWORD)BlockArray)
      goto LABEL_57;
LABEL_50:
    *((_DWORD *)this + 26) = 0;
    goto LABEL_51;
  }
  DataSize = Ktx2GetDataSize(*((_DWORD *)this + 120), v23, v24);
  if (DataSize)
  {
    v48 = a4;
    v33 = v22;
    v34 = DataSize;
    v35 = (unint64_t *)malloc_type_calloc(DataSize, 1uLL, 0xA75C1443uLL);
    v36 = v35;
    if (v35)
    {
      v51 = *((_DWORD *)this + 52);
      v52 = v35;
      v53 = v34;
      v54 = 0;
      KTXTexture = *((_QWORD *)this + 59);
      if (!KTXTexture)
      {
        KTXTexture = CreateKTXTexture(*((IIOImageReadSession **)this + 3));
        *((_QWORD *)this + 59) = KTXTexture;
      }
      v22 = v33;
      if ((*(unsigned int (**)(void))(*(_QWORD *)(KTXTexture + 8) + 40))())
      {
        BlockArray = 4294967246;
        goto LABEL_51;
      }
      dest.data = BaseAddress;
      dest.height = v24;
      dest.width = v23;
      dest.rowBytes = v25;
      if (*((_QWORD *)this + 3))
        BlockArray = ETCReadPlugin::decodeETCtoRGBX(this, v52, v54, &dest);
      a4 = v48;
      if (!(_DWORD)BlockArray)
      {
LABEL_57:
        if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8 && *((_BYTE *)this + 406) == 1)
        {
          dest.data = BaseAddress;
          v39 = *(_QWORD *)((char *)this + 292);
          v40.i64[0] = v39;
          v40.i64[1] = HIDWORD(v39);
          *(int8x16_t *)&dest.height = vextq_s8(v40, v40, 8uLL);
          dest.rowBytes = *((unsigned int *)this + 75);
          vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        }
        if (a3 == 3)
        {
          v43 = 0;
          v56.origin.x = 0.0;
          v56.origin.y = 0.0;
          v56.size.width = v29;
          v56.size.height = v28;
          **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v49, v56, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
          if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
          {
            v44 = 0;
          }
          else
          {
            v57.origin.x = 0.0;
            v57.origin.y = 0.0;
            v57.size.width = v29;
            v57.size.height = v28;
            *(CGRect *)(&v44 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v57);
            v43 = v45;
            v29 = v46;
            v28 = v47;
          }
          BlockArray = 0;
          *((_QWORD *)this + 15) = v43;
          *((_QWORD *)this + 16) = v44;
          *((double *)this + 17) = v29;
          *((double *)this + 18) = v28;
          if (!v36)
            goto LABEL_65;
          goto LABEL_64;
        }
        IOSurfaceUnlock(*a4, 0, 0);
        BlockArray = 0;
        goto LABEL_63;
      }
      goto LABEL_50;
    }
    BlockArray = 4294967188;
    v22 = v33;
  }
  else
  {
    v36 = 0;
    BlockArray = 4294967229;
  }
LABEL_51:
  if (a3 == 3)
  {
    _ImageIO_Free((unint64_t)BaseAddress, v55[0]);
    if (!v36)
      goto LABEL_65;
    goto LABEL_64;
  }
LABEL_63:
  if (v36)
LABEL_64:
    free(v36);
LABEL_65:
  if (v22)
  {
    v41 = (const char **)*((_QWORD *)this + 3);
    if (v41)
      IIOImageReadSession::unmapData(v41);
  }
  return BlockArray;
}

uint64_t ETCReadPlugin::copyImageTextureData(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  int v4;
  int v5;
  const void *ColorSpace;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v18;
  std::__shared_weak_count *v19;
  _BYTE v20[24];
  _BYTE v21[24];
  _BYTE v22[24];
  _BYTE v23[24];
  _BYTE v24[24];
  _BYTE v25[24];
  _BYTE v26[24];
  _BYTE v27[24];
  _QWORD v28[3];
  __int128 v29;
  __int128 v30;

  v2 = *(const void **)(a1 + 488);
  if (!v2)
  {
    v29 = xmmword_1E1BC9898;
    v30 = *(_OWORD *)off_1E1BC98A8;
    v3 = IIOImageRead::imageCount(*(IIOImageRead **)(a1 + 32));
    memset(v28, 0, sizeof(v28));
    IIODictionary::IIODictionary((IIODictionary *)v28);
    IIONumber::IIONumber((IIONumber *)v27, *(_DWORD *)(a1 + 228));
    IIODictionary::setObjectForKey((uint64_t)v28, (uint64_t)v27, CFSTR("width"));
    IIONumber::~IIONumber((IIONumber *)v27);
    IIONumber::IIONumber((IIONumber *)v26, *(_DWORD *)(a1 + 232));
    IIODictionary::setObjectForKey((uint64_t)v28, (uint64_t)v26, CFSTR("height"));
    IIONumber::~IIONumber((IIONumber *)v26);
    v4 = *(_DWORD *)(a1 + 452) - 37488;
    if (v4 > 9)
      v5 = 0;
    else
      v5 = dword_18822B170[v4];
    IIONumber::IIONumber((IIONumber *)v25, v5 * *(_DWORD *)(a1 + 456));
    IIODictionary::setObjectForKey((uint64_t)v28, (uint64_t)v25, CFSTR("rowBytes"));
    IIONumber::~IIONumber((IIONumber *)v25);
    IIONumber::IIONumber((IIONumber *)v24, *(_DWORD *)(a1 + 452));
    IIODictionary::setObjectForKey((uint64_t)v28, (uint64_t)v24, CFSTR("glInternalFormat"));
    IIONumber::~IIONumber((IIONumber *)v24);
    IIONumber::IIONumber((IIONumber *)v23, v3);
    IIODictionary::setObjectForKey((uint64_t)v28, (uint64_t)v23, CFSTR("mipmapLevelCount"));
    IIONumber::~IIONumber((IIONumber *)v23);
    IIONumber::IIONumber((IIONumber *)v22, 1);
    IIODictionary::setObjectForKey((uint64_t)v28, (uint64_t)v22, CFSTR("faceCount"));
    IIONumber::~IIONumber((IIONumber *)v22);
    ColorSpace = (const void *)CGImageProviderGetColorSpace();
    IIODictionary::setObjectForKey((IIODictionary *)v28, ColorSpace, CFSTR("colorSpace"));
    IIODictionary::setObjectForKey((IIODictionary *)v28, (const void *)*MEMORY[0x1E0C9AE40], CFSTR("supportsTiledLayout"));
    IIONumber::IIONumber((IIONumber *)v21, *(_DWORD *)(a1 + 452));
    IIODictionary::setObjectForKey((uint64_t)v28, (uint64_t)v21, CFSTR("pixelFormatGL"));
    IIONumber::~IIONumber((IIONumber *)v21);
    v7 = *(_DWORD *)(a1 + 452) - 37488;
    if (v7 > 9)
      v8 = 0;
    else
      v8 = dword_18822B198[v7];
    IIONumber::IIONumber((IIONumber *)v20, v8);
    IIODictionary::setObjectForKey((uint64_t)v28, (uint64_t)v20, CFSTR("pixelFormatMetal"));
    IIONumber::~IIONumber((IIONumber *)v20);
    v9 = IIOImageSource::cf(*(IIOImageSource **)(a1 + 32));
    v10 = operator new();
    IIOTextureHandler::IIOTextureHandler(v10, v9);
    *(_QWORD *)(a1 + 488) = CGImageTextureDataCreate();
    v11 = *(std::__shared_weak_count **)(a1 + 504);
    v18 = *(_QWORD *)(a1 + 496);
    v19 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    IIOTextureHandler::setImp(v10, &v18);
    v14 = v19;
    if (v19)
    {
      v15 = (unint64_t *)&v19->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    IIODictionary::~IIODictionary((IIODictionary *)v28);
    v2 = *(const void **)(a1 + 488);
  }
  CFRetain(v2);
  return *(_QWORD *)(a1 + 488);
}

void sub_18801306C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 104));
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ETCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E1BBC260;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ETCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E1BBC260;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x18D761C30);
}

uint64_t std::__shared_ptr_emplace<ETCTextureImp>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

__CFString *CGImageMetadataDefaultPrefixForSchema(const __CFString *a1)
{
  __CFString **v2;
  __CFString *result;
  const char *v4;
  _BYTE v5[24];

  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/exif/1.0/aux/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixExifAux;
    goto LABEL_21;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/camera-raw-settings/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = xmpCRSPrefix;
    goto LABEL_21;
  }
  if (CFStringCompare(a1, CFSTR("http://purl.org/dc/elements/1.1/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixDublinCore;
    goto LABEL_21;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/exif/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixExif;
    goto LABEL_21;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/photoshop/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixPhotoshop;
    goto LABEL_21;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixTIFF;
    goto LABEL_21;
  }
  if (CFStringCompare(a1, CFSTR("http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixIPTCCore;
    goto LABEL_21;
  }
  if (CFStringCompare(a1, CFSTR("http://iptc.org/std/Iptc4xmpExt/2008-02-29/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixIPTCExtension;
    goto LABEL_21;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/xap/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixXMPBasic;
LABEL_21:
    result = *v2;
    if (*v2)
      return result;
    goto LABEL_22;
  }
  if (CFStringCompare(a1, CFSTR("http://www.metadataworkinggroup.com/schemas/regions/"), 0) == kCFCompareEqualTo)
  {
    v2 = xmpMWGRegionsPrefix;
    goto LABEL_21;
  }
LABEL_22:
  IIOString::IIOString((IIOString *)v5, a1);
  v4 = (const char *)IIOString::utf8String((IIOString *)v5);
  _cg_jpeg_mem_term("CGImageMetadataDefaultPrefixForSchema", 52, "*** unknown schema '%s'\n", v4);
  IIOString::~IIOString((IIOString *)v5);
  return 0;
}

void sub_188013364(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t GetMetadataPropertyMatchingSchemaAndPropertyName(const void *a1, const __CFString *a2, const __CFString *a3)
{
  CFTypeID v6;
  CFTypeID TypeID;
  uint64_t v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const void *ValueAtIndex;
  CFTypeID v13;
  const __CFString *Schema;
  const __CFString *PropertyName;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "GetMetadataPropertyMatchingSchemaAndPropertyName", 0, 0, -1, 0);
  if (!a1)
    return 0;
  v6 = CFGetTypeID(a1);
  TypeID = CFArrayGetTypeID();
  v8 = 0;
  if (!a3 || !a2 || v6 != TypeID)
    return v8;
  Count = CFArrayGetCount((CFArrayRef)a1);
  if (Count < 1)
    return 0;
  v10 = Count;
  v11 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v11);
    v8 = (uint64_t)ValueAtIndex;
    if (!ValueAtIndex)
      break;
    v13 = CFGetTypeID(ValueAtIndex);
    if (v13 != CGImageMetadataPropertyGetTypeID())
      return 0;
    Schema = (const __CFString *)CGImageMetadataPropertyGetSchema(v8);
    if (CFStringCompare(Schema, a2, 0) == kCFCompareEqualTo)
    {
      PropertyName = (const __CFString *)CGImageMetadataPropertyGetPropertyName(v8);
      if (CFStringCompare(PropertyName, a3, 0) == kCFCompareEqualTo)
        break;
    }
    if (v10 == ++v11)
      return 0;
  }
  return v8;
}

CGImageMetadata *CGImageMetadataCreateSerializedData(__CFArray *a1)
{
  CGImageMetadata *result;
  CGImageMetadata *v3;
  CFDataRef XMPData;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageMetadataCreateSerializedData", 0, 0, -1, 0);
  result = CGImageMetadataCreateFromMetadataProperties(a1);
  if (result)
  {
    v3 = result;
    XMPData = CGImageMetadataCreateXMPData(result, 0);
    CFRelease(v3);
    return XMPData;
  }
  return result;
}

CGImageMetadata *CGImageMetadataCreateFromMetadataProperties(__CFArray *MetadataProperties)
{
  CFIndex Count;
  const void *ValueAtIndex;
  CFTypeID v4;
  CFIndex v5;
  __CFArray *v6;
  CFIndex i;
  const void *v9;
  uint64_t v10;
  CFTypeID v11;
  const void *Value;
  uint64_t v13;
  CFTypeID v14;
  const __CFString *Schema;
  const __CFString *SuggestedPrefix;
  const __CFString *PropertyName;
  CGImageMetadataType TagTypeForMetadataValue;
  CFStringRef TagValueFromMetadataValue;
  CFStringRef v20;
  CGImageMetadataTagRef v21;
  CGImageMetadataTagRef v22;
  __CFArray *v23;
  CGImageMetadata *metadata;

  metadata = CGImageMetadataCreateMutable();
  Count = CFArrayGetCount(MetadataProperties);
  if (Count == 1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(MetadataProperties, 0);
    v4 = CFGetTypeID(ValueAtIndex);
    if (v4 != CGImageMetadataGetTypeID())
    {
      v6 = 0;
      v5 = 1;
      goto LABEL_10;
    }
    _cg_jpeg_mem_term("CGImageMetadataCreateFromMetadataProperties", 404, "*** expected 'CGImageMetadataPropertyRef' but got 'CGImageMetadataRef'");
    MetadataProperties = CGImageMetadataCreateMetadataProperties((uint64_t)ValueAtIndex);
    v5 = CFArrayGetCount(MetadataProperties);
    v6 = MetadataProperties;
  }
  else
  {
    v5 = Count;
    v6 = 0;
  }
  if (v5 >= 1)
  {
LABEL_10:
    v23 = v6;
    for (i = 0; i != v5; ++i)
    {
      v9 = CFArrayGetValueAtIndex(MetadataProperties, i);
      if (v9)
      {
        v10 = (uint64_t)v9;
        v11 = CFGetTypeID(v9);
        if (v11 == CGImageMetadataPropertyGetTypeID())
        {
          Value = (const void *)CGImageMetadataPropertyGetValue(v10);
          if (Value)
          {
            v13 = (uint64_t)Value;
            v14 = CFGetTypeID(Value);
            if (v14 == CGImageMetadataValueGetTypeID())
            {
              Schema = (const __CFString *)CGImageMetadataPropertyGetSchema(v10);
              SuggestedPrefix = (const __CFString *)CGImageMetadataPropertyGetSuggestedPrefix(v10);
              CGImageMetadataRegisterNamespaceForPrefix(metadata, Schema, SuggestedPrefix, 0);
              PropertyName = (const __CFString *)CGImageMetadataPropertyGetPropertyName(v10);
              TagTypeForMetadataValue = GetTagTypeForMetadataValue(v13);
              TagValueFromMetadataValue = CreateTagValueFromMetadataValue((uint64_t)Schema, (uint64_t)SuggestedPrefix, v13);
              if (TagValueFromMetadataValue)
              {
                v20 = TagValueFromMetadataValue;
                v21 = CGImageMetadataTagCreate(Schema, SuggestedPrefix, PropertyName, TagTypeForMetadataValue, TagValueFromMetadataValue);
                if (v21)
                {
                  v22 = v21;
                  SyncMetadataValueQualifiersToTag(v13, (uint64_t)v21);
                  CGImageMetadataAddTag((uint64_t)metadata, v22);
                  CFRelease(v22);
                }
                CFRelease(v20);
              }
            }
          }
        }
        else
        {
          _cg_jpeg_mem_term("CGImageMetadataCreateFromMetadataProperties", 442, "*** expected 'CGImageMetadataPropertyRef' but got unknown type...\n");
        }
      }
    }
    v6 = v23;
    if (v23)
      goto LABEL_7;
    return metadata;
  }
  if (v6)
LABEL_7:
    CFRelease(v6);
  return metadata;
}

CGImageMetadata *CGImageMetadataSerialize(__CFArray *a1)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageMetadataSerialize", 0, 0, -1, 0);
  return CGImageMetadataCreateSerializedData(a1);
}

__CFArray *CGImageMetadataCreateFromData(const __CFData *a1)
{
  CGImageMetadataRef v2;
  CGImageMetadataRef v3;
  __CFArray *MetadataProperties;

  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageMetadataCreateFromData", 0, 0, -1, 0);
  v2 = CGImageMetadataCreateFromXMPData(a1);
  if (v2)
  {
    v3 = v2;
    MetadataProperties = CGImageMetadataCreateMetadataProperties((uint64_t)v2);
    CFRelease(v3);
  }
  else
  {
    MetadataProperties = 0;
  }
  kdebug_trace();
  return MetadataProperties;
}

__CFArray *CGImageMetadataCreateMetadataProperties(uint64_t a1)
{
  const __CFAllocator *v2;
  CFIndex Count;
  __CFArray *Mutable;
  int64_t v5;
  const void **v6;
  const void **v7;
  uint64_t *v8;
  CGImageMetadataTag *v9;
  uint64_t Source;
  uint64_t v11;
  const void *v12;
  CFStringRef PropertyValueFromTag;
  CFStringRef v14;
  _QWORD *v15;
  const void *v16;
  int v17;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
  Mutable = CFArrayCreateMutable(v2, Count, MEMORY[0x1E0C9B378]);
  v5 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
  v6 = (const void **)malloc_type_calloc(8uLL, v5, 0x2E9BD831uLL);
  v7 = (const void **)malloc_type_calloc(8uLL, v5, 0xF742F9FDuLL);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 24), v6, v7);
  if (v5 >= 1)
  {
    v8 = (uint64_t *)v7;
    do
    {
      v9 = (CGImageMetadataTag *)*v8;
      Source = CGImageSourceGetSource(*v8);
      v11 = CGImageMetadataPropertyCreate(*(const __CFString **)(Source + 16), *(const void **)(Source + 24), *(const void **)(Source + 32));
      if (v11)
      {
        v12 = (const void *)v11;
        PropertyValueFromTag = CreatePropertyValueFromTag(v9);
        if (PropertyValueFromTag)
        {
          v14 = PropertyValueFromTag;
          v15 = (_QWORD *)CGImageMetadataValueCreate(PropertyValueFromTag);
          if (v15)
          {
            v16 = v15;
            SyncTagQualifiersToMetadataValue((uint64_t)v9, v15);
            v17 = *(_DWORD *)(Source + 40);
            if (v17 == 4)
            {
              CGImageMetadataValueSetIsAlternate((uint64_t)v16, 1);
            }
            else if (v17 == 5)
            {
              CGImageMetadataValueSetIsAlternateText((uint64_t)v16, 1);
            }
            CGImageMetadataPropertySetValue((uint64_t)v12, v16);
            CFArrayAppendValue(Mutable, v12);
            CFRelease(v16);
          }
          CFRelease(v14);
        }
        CFRelease(v12);
      }
      ++v8;
      --v5;
    }
    while (v5);
  }
  if (v6)
    free(v6);
  if (v7)
    free(v7);
  return Mutable;
}

uint64_t GetTagTypeForMetadataValue(uint64_t a1)
{
  const void *Value;
  CFTypeID v3;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;

  Value = (const void *)CGImageMetadataValueGetValue(a1);
  v3 = CFGetTypeID(Value);
  if (v3 == CFStringGetTypeID())
    return 1;
  v5 = CFGetTypeID(Value);
  if (v5 == CFArrayGetTypeID())
  {
    if ((CGImageMetadataValueIsAlternateText(a1) & 1) != 0)
    {
      return 5;
    }
    else if (CGImageMetadataValueIsAlternate(a1))
    {
      return 4;
    }
    else
    {
      return 3;
    }
  }
  else
  {
    v6 = CFGetTypeID(Value);
    if (v6 == CFBagGetTypeID())
    {
      return 2;
    }
    else
    {
      v7 = CFGetTypeID(Value);
      if (v7 == CFDictionaryGetTypeID())
        return 6;
      else
        return 0xFFFFFFFFLL;
    }
  }
}

CFStringRef CreateTagValueFromMetadataValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int TagTypeForMetadataValue;
  const __CFString *Value;
  const __CFString *v6;
  uint64_t Count;
  const __CFAllocator *v8;
  CFIndex v9;
  const __CFAllocator *v10;
  const void *ValueAtIndex;
  uint64_t v12;
  CFTypeID v13;
  CGImageMetadataType v14;
  uint64_t v15;
  const __CFString *v16;
  uint64_t v17;
  const __CFString *v18;
  CFStringRef v19;
  const __CFString *v20;
  const void *v21;
  const void *v22;
  CGImageMetadataTagRef v23;
  CGImageMetadataTagRef v24;
  const __CFAllocator *v25;
  uint64_t v27;
  const void **v28;
  const __CFAllocator *v29;
  uint64_t v30;
  const __CFAllocator *v31;
  uint64_t v32;
  CFTypeID v33;
  CGImageMetadataType v34;
  uint64_t NamespaceURI;
  const __CFString *v36;
  uint64_t SuggestedNamespacePrefix;
  const __CFString *v38;
  CFStringRef v39;
  const __CFString *v40;
  const void *TagValueFromMetadataValue;
  const void *v42;
  CGImageMetadataTagRef v43;
  CGImageMetadataTagRef v44;
  int64_t v45;
  const void **v46;
  const void **v47;
  const __CFString **v48;
  CFTypeRef *v49;
  CFTypeRef v50;
  const __CFString *v51;
  CFTypeID v52;
  CGImageMetadataType v53;
  uint64_t v54;
  const __CFString *v55;
  uint64_t v56;
  const __CFString *v57;
  const void *v58;
  const void *v59;
  CGImageMetadataTagRef v60;
  CGImageMetadataTagRef v61;
  const void **v62;
  __CFArray *theArray;

  TagTypeForMetadataValue = GetTagTypeForMetadataValue(a3);
  Value = (const __CFString *)CGImageMetadataValueGetValue(a3);
  v6 = Value;
  switch(TagTypeForMetadataValue)
  {
    case 1:
      v25 = CFGetAllocator(Value);
      return CFStringCreateCopy(v25, v6);
    case 2:
      v27 = MEMORY[0x18D76043C](Value);
      v28 = (const void **)malloc_type_calloc(8uLL, v27, 0x99664D1uLL);
      v29 = CFGetAllocator(v6);
      theArray = CFArrayCreateMutable(v29, v27, MEMORY[0x1E0C9B378]);
      if (!v28)
        return 0;
      CFBagGetValues((CFBagRef)v6, v28);
      if (v27 >= 1)
      {
        v30 = 0;
        v31 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        do
        {
          v32 = (uint64_t)v28[v30];
          if (v32)
          {
            v33 = CFGetTypeID(v28[v30]);
            if (v33 == CGImageMetadataValueGetTypeID())
            {
              v34 = GetTagTypeForMetadataValue(v32);
              NamespaceURI = CGImageMetadataValueGetNamespaceURI(v32);
              v36 = (const __CFString *)(NamespaceURI ? NamespaceURI : a1);
              SuggestedNamespacePrefix = CGImageMetadataValueGetSuggestedNamespacePrefix(v32);
              v38 = (const __CFString *)(SuggestedNamespacePrefix ? SuggestedNamespacePrefix : a2);
              v39 = CFStringCreateWithFormat(v31, 0, CFSTR("[%ld]"), v30);
              if (v39)
              {
                v40 = v39;
                TagValueFromMetadataValue = (const void *)CreateTagValueFromMetadataValue(v36, v38, v32);
                if (TagValueFromMetadataValue)
                {
                  v42 = TagValueFromMetadataValue;
                  v43 = CGImageMetadataTagCreate(v36, v38, v40, v34, TagValueFromMetadataValue);
                  if (v43)
                  {
                    v44 = v43;
                    SyncMetadataValueQualifiersToTag(v32, (uint64_t)v43);
                    CFArrayAppendValue(theArray, v44);
                    CFRelease(v44);
                  }
                  CFRelease(v42);
                }
                CFRelease(v40);
              }
            }
          }
          ++v30;
        }
        while (v27 != v30);
      }
      goto LABEL_62;
    case 3:
    case 4:
    case 5:
      Count = CFArrayGetCount((CFArrayRef)Value);
      v8 = CFGetAllocator(v6);
      theArray = CFArrayCreateMutable(v8, Count, MEMORY[0x1E0C9B378]);
      if (Count >= 1)
      {
        v9 = 0;
        v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v6, v9);
          if (ValueAtIndex)
          {
            v12 = (uint64_t)ValueAtIndex;
            v13 = CFGetTypeID(ValueAtIndex);
            if (v13 == CGImageMetadataValueGetTypeID())
            {
              v14 = GetTagTypeForMetadataValue(v12);
              v15 = CGImageMetadataValueGetNamespaceURI(v12);
              v16 = (const __CFString *)(v15 ? v15 : a1);
              v17 = CGImageMetadataValueGetSuggestedNamespacePrefix(v12);
              v18 = (const __CFString *)(v17 ? v17 : a2);
              v19 = CFStringCreateWithFormat(v10, 0, CFSTR("[%ld]"), v9);
              if (v19)
              {
                v20 = v19;
                v21 = (const void *)CreateTagValueFromMetadataValue(v16, v18, v12);
                if (v21)
                {
                  v22 = v21;
                  v23 = CGImageMetadataTagCreate(v16, v18, v20, v14, v21);
                  if (v23)
                  {
                    v24 = v23;
                    SyncMetadataValueQualifiersToTag(v12, (uint64_t)v23);
                    CFArrayAppendValue(theArray, v24);
                    CFRelease(v24);
                  }
                  CFRelease(v22);
                }
                CFRelease(v20);
              }
            }
          }
          ++v9;
        }
        while (Count != v9);
      }
      return (CFStringRef)theArray;
    case 6:
      v45 = CFDictionaryGetCount((CFDictionaryRef)Value);
      theArray = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v46 = (const void **)malloc_type_calloc(8uLL, v45, 0x4942AB70uLL);
      v47 = (const void **)malloc_type_calloc(8uLL, v45, 0x8A9DFF05uLL);
      v28 = v47;
      v62 = v46;
      if (v46 && v47)
      {
        CFDictionaryGetKeysAndValues((CFDictionaryRef)v6, v46, v47);
        if (v45 >= 1)
        {
          v48 = (const __CFString **)v46;
          v49 = v28;
          do
          {
            v50 = *v49;
            if (*v49)
            {
              v51 = *v48;
              v52 = CFGetTypeID(*v49);
              if (v52 == CGImageMetadataValueGetTypeID())
              {
                v53 = GetTagTypeForMetadataValue((uint64_t)v50);
                v54 = CGImageMetadataValueGetNamespaceURI((uint64_t)v50);
                v55 = (const __CFString *)(v54 ? v54 : a1);
                v56 = CGImageMetadataValueGetSuggestedNamespacePrefix((uint64_t)v50);
                v57 = (const __CFString *)(v56 ? v56 : a2);
                v58 = (const void *)CreateTagValueFromMetadataValue(v55, v57, v50);
                if (v58)
                {
                  v59 = v58;
                  v60 = CGImageMetadataTagCreate(v55, v57, v51, v53, v58);
                  if (v60)
                  {
                    v61 = v60;
                    SyncMetadataValueQualifiersToTag((uint64_t)v50, (uint64_t)v60);
                    CFDictionarySetValue(theArray, v51, v61);
                    CFRelease(v61);
                  }
                  CFRelease(v59);
                }
              }
            }
            ++v49;
            ++v48;
            --v45;
          }
          while (v45);
        }
      }
      else if (!v46)
      {
        goto LABEL_61;
      }
      free(v62);
LABEL_61:
      if (v28)
LABEL_62:
        free(v28);
      return (CFStringRef)theArray;
    default:
      return 0;
  }
}

void SyncMetadataValueQualifiersToTag(uint64_t a1, uint64_t a2)
{
  uint64_t Source;
  const __CFArray *v4;
  uint64_t Count;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID v8;
  CGImageMetadataTagRef v9;
  CGImageMetadataTagRef v10;

  Source = CGImageSourceGetSource(a2);
  v4 = *(const __CFArray **)(a1 + 48);
  if (v4 && CFArrayGetCount(v4) >= 1)
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
    if (!*(_QWORD *)(Source + 56))
      *(_QWORD *)(Source + 56) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), i);
        if (CGImageMetadataValueIsAlternateText(a1))
        {
          v8 = CFGetTypeID(ValueAtIndex);
          if (v8 == CFStringGetTypeID())
          {
            v9 = CGImageMetadataTagCreate(CFSTR("http://www.w3.org/XML/1998/namespace"), CFSTR("xml"), CFSTR("lang"), kCGImageMetadataTypeString, ValueAtIndex);
            if (v9)
            {
              v10 = v9;
              CFArrayAppendValue(*(CFMutableArrayRef *)(Source + 56), v9);
              CFRelease(v10);
            }
          }
        }
      }
    }
  }
}

CFStringRef CreatePropertyValueFromTag(CGImageMetadataTag *a1)
{
  uint64_t Source;
  int v2;
  const __CFString *v3;
  uint64_t v4;
  const __CFAllocator *v5;
  __CFBag *Mutable;
  CFIndex j;
  CGImageMetadataTag *v8;
  CGImageMetadataTag *v9;
  CFTypeID v10;
  const void *v11;
  const void *v12;
  _QWORD *v13;
  const void *v14;
  const __CFAllocator *v15;
  uint64_t Count;
  const __CFAllocator *v18;
  CFIndex i;
  CGImageMetadataTag *ValueAtIndex;
  CGImageMetadataTag *v21;
  CFTypeID v22;
  const void *PropertyValueFromTag;
  const void *v24;
  _QWORD *v25;
  const void *v26;
  int64_t v27;
  const void **v28;
  const void **v29;
  const void **v30;
  BOOL v31;
  const void **v32;
  CFTypeRef *v33;
  CGImageMetadataTag *v34;
  const void *v35;
  CFTypeID v36;
  const void *v37;
  const void *v38;
  uint64_t v39;
  _QWORD *v40;
  const void *Namespace;

  Source = CGImageSourceGetSource((uint64_t)a1);
  v2 = *(_DWORD *)(Source + 40);
  v3 = *(const __CFString **)(Source + 48);
  switch(v2)
  {
    case 1:
      v15 = CFGetAllocator(*(CFTypeRef *)(Source + 48));
      return CFStringCreateCopy(v15, v3);
    case 2:
      Count = CFArrayGetCount(*(CFArrayRef *)(Source + 48));
      v18 = CFGetAllocator(v3);
      Mutable = CFBagCreateMutable(v18, Count, MEMORY[0x1E0C9B388]);
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (CGImageMetadataTag *)CFArrayGetValueAtIndex((CFArrayRef)v3, i);
          if (ValueAtIndex)
          {
            v21 = ValueAtIndex;
            v22 = CFGetTypeID(ValueAtIndex);
            if (v22 == CGImageMetadataTagGetTypeID())
            {
              PropertyValueFromTag = (const void *)CreatePropertyValueFromTag(v21);
              if (PropertyValueFromTag)
              {
                v24 = PropertyValueFromTag;
                v25 = (_QWORD *)CGImageMetadataValueCreate(PropertyValueFromTag);
                if (v25)
                {
                  v26 = v25;
                  SyncTagQualifiersToMetadataValue((uint64_t)v21, v25);
                  CFBagAddValue(Mutable, v26);
                  CFRelease(v26);
                }
                CFRelease(v24);
              }
            }
          }
        }
      }
      return (CFStringRef)Mutable;
    case 3:
    case 4:
    case 5:
      v4 = CFArrayGetCount(*(CFArrayRef *)(Source + 48));
      v5 = CFGetAllocator(v3);
      Mutable = CFArrayCreateMutable(v5, v4, MEMORY[0x1E0C9B378]);
      if (v4 >= 1)
      {
        for (j = 0; j != v4; ++j)
        {
          v8 = (CGImageMetadataTag *)CFArrayGetValueAtIndex((CFArrayRef)v3, j);
          if (v8)
          {
            v9 = v8;
            v10 = CFGetTypeID(v8);
            if (v10 == CGImageMetadataTagGetTypeID())
            {
              v11 = (const void *)CreatePropertyValueFromTag(v9);
              if (v11)
              {
                v12 = v11;
                v13 = (_QWORD *)CGImageMetadataValueCreate(v11);
                if (v13)
                {
                  v14 = v13;
                  SyncTagQualifiersToMetadataValue((uint64_t)v9, v13);
                  if (v2 == 4)
                  {
                    CGImageMetadataValueSetIsAlternate((uint64_t)v14, 1);
                  }
                  else if (v2 == 5)
                  {
                    CGImageMetadataValueSetIsAlternateText((uint64_t)v14, 1);
                  }
                  CFArrayAppendValue(Mutable, v14);
                  CFRelease(v14);
                }
                CFRelease(v12);
              }
            }
          }
        }
      }
      return (CFStringRef)Mutable;
    case 6:
      v27 = CFDictionaryGetCount(*(CFDictionaryRef *)(Source + 48));
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v28 = (const void **)malloc_type_calloc(8uLL, v27, 0xDD4A3F04uLL);
      v29 = (const void **)malloc_type_calloc(8uLL, v27, 0xC2425E9DuLL);
      v30 = v29;
      if (v28)
        v31 = v29 == 0;
      else
        v31 = 1;
      if (v31)
      {
        if (!v28)
          goto LABEL_45;
      }
      else
      {
        CFDictionaryGetKeysAndValues((CFDictionaryRef)v3, v28, v29);
        if (v27 >= 1)
        {
          v32 = v28;
          v33 = v30;
          do
          {
            v34 = (CGImageMetadataTag *)*v33;
            if (*v33)
            {
              v35 = *v32;
              v36 = CFGetTypeID(*v33);
              if (v36 == CGImageMetadataTagGetTypeID())
              {
                v37 = (const void *)CreatePropertyValueFromTag(v34);
                if (v37)
                {
                  v38 = v37;
                  v39 = CGImageMetadataValueCreate(v37);
                  if (v39)
                  {
                    v40 = (_QWORD *)v39;
                    Namespace = (const void *)CGImageMetadataTagGetNamespace((uint64_t)v34);
                    CGImageMetadataValueSetNamespaceURI((uint64_t)v40, Namespace);
                    SyncTagQualifiersToMetadataValue((uint64_t)v34, v40);
                    CFDictionarySetValue(Mutable, v35, v40);
                    CFRelease(v40);
                  }
                  CFRelease(v38);
                }
              }
            }
            ++v33;
            ++v32;
            --v27;
          }
          while (v27);
        }
      }
      free(v28);
LABEL_45:
      if (v30)
        free(v30);
      return (CFStringRef)Mutable;
    default:
      return 0;
  }
}

void SyncTagQualifiersToMetadataValue(uint64_t a1, _QWORD *a2)
{
  uint64_t Source;
  uint64_t v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID v11;
  uint64_t v12;
  const void *v13;
  CFTypeID v14;

  Source = CGImageSourceGetSource(a1);
  if (a1)
  {
    v5 = Source;
    v6 = *(const __CFArray **)(Source + 56);
    if (v6)
    {
      Count = CFArrayGetCount(v6);
      if (Count >= 1)
      {
        v8 = Count;
        for (i = 0; i != v8; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v5 + 56), i);
          if (ValueAtIndex)
          {
            v11 = CFGetTypeID(ValueAtIndex);
            if (v11 == CGImageMetadataTagGetTypeID())
            {
              v12 = CGImageSourceGetSource(a1);
              if (*(_DWORD *)(v12 + 40) == 1)
              {
                v13 = *(const void **)(v12 + 48);
                v14 = CFGetTypeID(v13);
                if (v14 == CFStringGetTypeID())
                  CGImageMetadataValueAddQualifier(a2, v13);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t CGImageMetadataCreateSidecar(void *a1, uint64_t a2)
{
  uint64_t v4;
  CFTypeID v5;
  CGImageMetadata *v6;
  const __CFData *v7;
  FILE *v8;
  FILE *v9;
  const UInt8 *BytePtr;
  size_t Length;
  char __filename[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageMetadataCreateSidecar", 0, 0, -1, 0);
  v4 = 0;
  if (a1 && a2)
  {
    v5 = CFGetTypeID(a1);
    if (v5 == CFArrayGetTypeID())
    {
      v6 = CGImageMetadataSerialize((__CFArray *)a1);
      if (v6)
      {
        v7 = v6;
        bzero(__filename, 0x400uLL);
        if (_CFStringGetFileSystemRepresentation() && (v8 = fopen(__filename, "w")) != 0)
        {
          v9 = v8;
          BytePtr = CFDataGetBytePtr(v7);
          Length = CFDataGetLength(v7);
          v4 = 1;
          fwrite(BytePtr, Length, 1uLL, v9);
          fclose(v9);
        }
        else
        {
          v4 = 0;
        }
        CFRelease(v7);
        goto LABEL_14;
      }
    }
    else
    {
      LogError("CGImageMetadataCreateSidecar", 706, "*** ERROR: 'metadata' is not a CFArrayRef\n");
    }
    v4 = 0;
  }
LABEL_14:
  kdebug_trace();
  return v4;
}

uint64_t CGImageCreateColorSpaceFromExifOrData(const void *a1, const void *a2, _QWORD *a3)
{
  uint64_t ColorSpaceFromDataArray;
  CFMutableArrayRef v8;
  const void *v9;
  uint64_t v10;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageCreateColorSpaceFromExifOrData", 0, 0, -1, 0);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  IIOArray::IIOArray((IIOArray *)&v8);
  if (a1)
    IIOArray::addObject(&v8, a1);
  if (a2)
    IIOArray::addObject(&v8, a2);
  if (IIOArray::getCount((IIOArray *)&v8))
    ColorSpaceFromDataArray = CGImageCreateColorSpaceFromDataArray(v9, a3);
  else
    ColorSpaceFromDataArray = 4294967246;
  IIOArray::~IIOArray((IIOArray *)&v8);
  return ColorSpaceFromDataArray;
}

void sub_188014774(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateColorSpaceFromDataArray(const void *a1, _QWORD *a2)
{
  CFTypeID v4;
  IIOArray *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];

  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_DWORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageCreateColorSpaceFromDataArray", 0, 0, -1, 0);
  if (!a1)
  {
    LogError("CGImageCreateColorSpaceFromDataArray", 778, "*** ERROR: dataArray is nil\n");
    goto LABEL_14;
  }
  v4 = CFGetTypeID(a1);
  if (v4 != CFArrayGetTypeID())
  {
    LogError("CGImageCreateColorSpaceFromDataArray", 779, "*** ERROR: dataArray is not a CFArrayRef\n");
    goto LABEL_14;
  }
  if (!a2)
  {
    LogError("CGImageCreateColorSpaceFromDataArray", 780, "*** ERROR: colorSpaceOut is nil\n");
    goto LABEL_14;
  }
  if (!CFArrayGetCount((CFArrayRef)a1))
  {
LABEL_14:
    v7 = 4294967246;
    goto LABEL_15;
  }
  memset(v14, 0, sizeof(v14));
  v5 = IIOArray::IIOArray((IIOArray *)v14, (const __CFArray *)a1);
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __CGImageCreateColorSpaceFromDataArray_block_invoke;
  v9[3] = &unk_1E1BBD200;
  v9[4] = &v10;
  IIOArray::enumerate((uint64_t)v5, (uint64_t)v9);
  v6 = v11[3];
  if (v6)
  {
    v7 = 0;
    *a2 = v6;
  }
  else
  {
    v7 = 4294967246;
  }
  _Block_object_dispose(&v10, 8);
  IIOArray::~IIOArray((IIOArray *)v14);
LABEL_15:
  kdebug_trace();
  return v7;
}

void sub_18801494C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  IIOArray::~IIOArray((IIOArray *)(v6 - 56));
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18801491CLL);
}

void GPSCopy::~GPSCopy(GPSCopy *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 7);
  if (v3)
    free(v3);
}

uint64_t GPSCopy::read32(GPSCopy *this, unsigned __int8 *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;

  v2 = *a2;
  v3 = a2[1];
  v4 = a2[2];
  v5 = a2[3];
  v6 = (v2 << 24) | (v3 << 16) | (v4 << 8) | v5;
  v7 = v2 | (v3 << 8) | (v4 << 16) | (v5 << 24);
  if (*((_BYTE *)this + 24))
    return v7;
  else
    return v6;
}

uint64_t GPSCopy::adjustIFDOffsets(uint64_t result, uint64_t a2, int a3, int a4)
{
  int v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned __int16 v10;
  unsigned int v11;
  unsigned int v14;
  unsigned int v15;

  if (a3 >= 1)
  {
    v4 = *(unsigned __int8 *)(result + 24);
    v5 = (unsigned int *)(a2 + 8);
    do
    {
      v6 = bswap32(*((unsigned __int16 *)v5 - 4)) >> 16;
      if (v4)
        LOWORD(v6) = *((_WORD *)v5 - 4);
      v7 = bswap32(*((unsigned __int16 *)v5 - 3)) >> 16;
      if (v4)
        LOWORD(v7) = *((_WORD *)v5 - 3);
      v8 = *v5;
      v9 = bswap32(*v5);
      if (!v4)
        v8 = v9;
      v10 = v7 - 1;
      result = v10;
      if (v10 > 0xBu
        || ((LODWORD(result) = *(v5 - 1), v11 = bswap32(result), v4) ? (result = result) : (result = v11),
            (int)result * dword_18822B1E0[v10] <= 4))
      {
        if ((unsigned __int16)v6 > 0x8824u)
        {
          if ((unsigned __int16)v6 != 40965 && (unsigned __int16)v6 != 34853)
            goto LABEL_28;
        }
        else if ((unsigned __int16)v6 != 513 && (unsigned __int16)v6 != 34665)
        {
          goto LABEL_28;
        }
      }
      v14 = v8 + a4;
      v15 = bswap32(v14);
      if (!v4)
        v14 = v15;
      *v5 = v14;
LABEL_28:
      v5 += 3;
      --a3;
    }
    while (a3);
  }
  return result;
}

uint64_t GPSCopy::readInputFile(GPSCopy *this, CFStringRef string)
{
  CFIndex MaximumSizeOfFileSystemRepresentation;
  char *v5;
  FILE *v6;
  uint64_t v7;
  off_t st_size;
  void *v10;
  stat v11;

  MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(string);
  v5 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0x9671A779uLL);
  memset(&v11, 0, sizeof(v11));
  if (CFStringGetFileSystemRepresentation(string, v5, MaximumSizeOfFileSystemRepresentation))
  {
    if (stat(v5, &v11))
    {
      v6 = 0;
LABEL_4:
      v7 = 1;
      goto LABEL_6;
    }
    v6 = fopen(v5, "r");
    if (!v6)
      goto LABEL_4;
    st_size = v11.st_size;
    *((_QWORD *)this + 5) = v11.st_size;
    if (st_size)
    {
      v10 = malloc_type_malloc(st_size, 0x15A650E8uLL);
      *((_QWORD *)this + 4) = v10;
      if (v10)
      {
        v7 = 1;
        fread(v10, *((_QWORD *)this + 5), 1uLL, v6);
      }
      else
      {
        v7 = 0;
      }
    }
    else
    {
      v7 = 0;
      *((_QWORD *)this + 4) = 0;
    }
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
LABEL_6:
  if (v5)
    free(v5);
  if (v6)
    fclose(v6);
  return v7;
}

BOOL GPSCopy::writeOutputFile(GPSCopy *this, CFStringRef string)
{
  CFIndex MaximumSizeOfFileSystemRepresentation;
  char *v5;
  int FileSystemRepresentation;
  FILE *v7;

  MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(string);
  v5 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0xE153EB21uLL);
  FileSystemRepresentation = CFStringGetFileSystemRepresentation(string, v5, MaximumSizeOfFileSystemRepresentation);
  if (FileSystemRepresentation)
  {
    v7 = fopen(v5, "w");
    if (v7)
      fwrite(*((const void **)this + 4), *((_QWORD *)this + 6), 1uLL, v7);
    if (v5)
      goto LABEL_5;
  }
  else
  {
    v7 = 0;
    if (v5)
LABEL_5:
      free(v5);
  }
  if (v7)
    fclose(v7);
  return FileSystemRepresentation != 0;
}

uint64_t GPSCopy::processData(GPSCopy *this)
{
  unsigned __int8 *v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unint64_t v21;
  unsigned __int8 *v22;
  unsigned int v23;
  unsigned __int8 *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  char *v34;
  unsigned __int8 *v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  char *v40;
  uint64_t v41;
  unsigned int v42;
  unsigned __int8 *v43;
  unsigned __int16 v44;
  unsigned int v45;
  __int16 v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  unsigned __int8 *v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  __int16 v62;
  __int16 v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  int v73;
  unsigned __int8 *v74;
  unsigned __int8 *v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;

  v1 = (unsigned __int8 *)*((_QWORD *)this + 4);
  v2 = *v1;
  v3 = v1[1];
  v4 = *((unsigned __int8 *)this + 24);
  v5 = v2 | (v3 << 8);
  v6 = v3 | (v2 << 8);
  if (*((_BYTE *)this + 24))
    v6 = v5;
  if (v6 != 65496)
    return 0;
  v7 = v1[2];
  v8 = v1[3];
  v9 = v7 | (v8 << 8);
  v10 = v8 | (v7 << 8);
  if (*((_BYTE *)this + 24))
    v10 = v9;
  if (v10 != 65505)
    return 0;
  v12 = v1[4];
  v13 = v1[5];
  v14 = v12 | (v13 << 8);
  v15 = v13 | (v12 << 8);
  if (*((_BYTE *)this + 24))
    v16 = v14;
  else
    v16 = v15;
  v17 = v1[12];
  v18 = v1[13];
  v19 = v17 | (v18 << 8);
  v20 = v18 | (v17 << 8);
  if (*((_BYTE *)this + 24))
    v20 = v19;
  if (v20 != 19789)
  {
    if (v20 != 18761)
      return 0;
    v4 = 1;
    *((_BYTE *)this + 24) = 1;
  }
  *((_QWORD *)this + 7) = CreateGPSBufferFromPropertiesTIFFNew(*((IIODictionary **)this + 2), 0, 0, 0, v4 != 0, (unint64_t *)this + 8);
  v21 = (*((_QWORD *)this + 8) & 1) + *((_QWORD *)this + 8);
  v22 = (unsigned __int8 *)reallocf(*((void **)this + 4), v21 + *((_QWORD *)this + 5) + 12);
  *((_QWORD *)this + 4) = v22;
  v23 = GPSCopy::read32(this, v22 + 16);
  v24 = &v22[v23];
  v25 = v24[12];
  v26 = v24[13];
  v27 = *((unsigned __int8 *)this + 24);
  v28 = v25 | (v26 << 8);
  v29 = v26 | (v25 << 8);
  if (*((_BYTE *)this + 24))
    v29 = v28;
  if (!v29)
    return 0;
  v30 = 0;
  v31 = v23;
  while (1)
  {
    v32 = *(unsigned __int16 *)&v24[v30 + 14];
    v33 = bswap32(v32) >> 16;
    if (!*((_BYTE *)this + 24))
      LOWORD(v32) = v33;
    if ((unsigned __int16)v32 != 34665)
      break;
    if (12 * v29 - 12 == (_DWORD)v30)
    {
      v40 = (char *)&v24[v30];
      LODWORD(v41) = *(_DWORD *)&v24[v30 + 22];
      v42 = bswap32(v41);
      if (*((_BYTE *)this + 24))
        v41 = v41;
      else
        v41 = v42;
      v81 = v16;
      v43 = &v22[v41];
      v44 = v29 + 1;
      v45 = bswap32(v29 + 1) >> 16;
      if (*((_BYTE *)this + 24))
        v46 = v29 + 1;
      else
        v46 = v45;
      *((_WORD *)v24 + 6) = v46;
      GPSCopy::adjustIFDOffsets((uint64_t)this, (uint64_t)(v24 + 14), v44, 12);
      v47 = v43[12];
      v48 = v43[13];
      v49 = v47 | (v48 << 8);
      v50 = v48 | (v47 << 8);
      if (*((_BYTE *)this + 24))
        v51 = v49;
      else
        v51 = v50;
      GPSCopy::adjustIFDOffsets((uint64_t)this, (uint64_t)(v43 + 14), v51, 12);
      v52 = GPSCopy::read32(this, (unsigned __int8 *)v40 + 26) + 12;
      v53 = (unsigned __int8 *)*((_QWORD *)this + 7);
      v54 = *v53;
      v55 = v53[1];
      v56 = v54 | (v55 << 8);
      v57 = v55 | (v54 << 8);
      if (*((_BYTE *)this + 24))
        v58 = v56;
      else
        v58 = v57;
      GPSCopy::adjustIFDOffsets((uint64_t)this, (uint64_t)(v53 + 2), v58, v52);
      v60 = *((_QWORD *)this + 4);
      v59 = *((_QWORD *)this + 5);
      memmove(v40 + 38, v40 + 26, v60 + v59 - (_QWORD)&v22[v31] - v30 - 26);
      v61 = *((_BYTE *)this + 24) == 0;
      *((_QWORD *)this + 5) = v59 + 12;
      if (v61)
        v62 = 9608;
      else
        v62 = -30683;
      if (v61)
        v63 = 1024;
      else
        v63 = 4;
      if (v61)
        v64 = 0x1000000;
      else
        v64 = 1;
      v65 = bswap32(v52);
      if (!v61)
        v65 = v52;
      *((_WORD *)v40 + 13) = v62;
      *((_WORD *)v40 + 14) = v63;
      *(_DWORD *)(v40 + 30) = v64;
      *(_DWORD *)(v40 + 34) = v65;
      v66 = v52 + v21;
      v67 = bswap32(v52 + v21);
      if (v61)
        v66 = v67;
      *(_DWORD *)(v40 + 38) = v66;
      memmove((void *)(v60 + v52 + 12 + v21), (const void *)(v60 + v52 + 12), v59 - v52);
      memcpy((void *)(v60 + v52 + 12), *((const void **)this + 7), *((_QWORD *)this + 8));
      v68 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 6) = *((_QWORD *)this + 5) + v21;
      v69 = v68 + v21 + v52;
      LODWORD(v68) = *(unsigned __int8 *)(v69 + 12);
      v70 = *(unsigned __int8 *)(v69 + 13);
      v71 = v68 | (v70 << 8);
      v72 = v70 | ((_DWORD)v68 << 8);
      if (*((_BYTE *)this + 24))
        v73 = v71;
      else
        v73 = v72;
      GPSCopy::adjustIFDOffsets((uint64_t)this, v69 + 14, v73, v21 + 12);
      *(_WORD *)(*((_QWORD *)this + 4) + 4) = bswap32(v21 + 12 + v81) >> 16;
      return 1;
    }
LABEL_25:
    v30 += 12;
    if (12 * v29 == (_DWORD)v30)
      return 0;
  }
  if ((unsigned __int16)v32 != 34853)
    goto LABEL_25;
  v34 = (char *)&v24[v30];
  v35 = (unsigned __int8 *)(v34 + 26);
  v36 = *(_DWORD *)(v34 + 22);
  v37 = bswap32(v36);
  if (*((_BYTE *)this + 24))
    v38 = v36;
  else
    v38 = v37;
  if (v21 < GPSCopy::read32(this, v35) - v38)
  {
    LogError("processData", 379, "GPS info is already present...\n");
    return 0;
  }
  v74 = &v22[v38 + 12];
  v75 = (unsigned __int8 *)*((_QWORD *)this + 7);
  v76 = *v75;
  v77 = v75[1];
  v78 = v76 | (v77 << 8);
  v79 = v77 | (v76 << 8);
  if (v27)
    v80 = v78;
  else
    v80 = v79;
  GPSCopy::adjustIFDOffsets((uint64_t)this, (uint64_t)(v75 + 2), v80, v38);
  memcpy(v74, *((const void **)this + 7), *((_QWORD *)this + 8));
  *((_QWORD *)this + 6) = *((_QWORD *)this + 5);
  return 1;
}

BOOL GPSCopy::copyFileWithGPSInformation(const __CFString **this)
{
  const __CFString *v2;

  if (!GPSCopy::readInputFile((GPSCopy *)this, *this)
    || !GPSCopy::processData((GPSCopy *)this))
  {
    return 0;
  }
  v2 = this[1];
  if (!v2)
    v2 = *this;
  return GPSCopy::writeOutputFile((GPSCopy *)this, v2);
}

BOOL CGImageCopyFileWithGPSInformation(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  uint64_t v6;
  _BOOL8 v7;
  _QWORD v9[3];

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopyFileWithGPSInformation", 0, 0, -1, a3);
  if (a1)
  {
    memset(v9, 0, sizeof(v9));
    IIODictionary::IIODictionary((IIODictionary *)v9, a3);
    v6 = operator new();
    *(_QWORD *)v6 = a1;
    *(_QWORD *)(v6 + 8) = a2;
    *(_QWORD *)(v6 + 16) = v9;
    *(_BYTE *)(v6 + 24) = 0;
    *(_QWORD *)(v6 + 32) = 0;
    *(_QWORD *)(v6 + 40) = 0;
    *(_QWORD *)(v6 + 56) = 0;
    *(_QWORD *)(v6 + 64) = 0;
    v7 = GPSCopy::copyFileWithGPSInformation((const __CFString **)v6);
    GPSCopy::~GPSCopy((GPSCopy *)v6);
    MEMORY[0x18D761C30]();
    IIODictionary::~IIODictionary((IIODictionary *)v9);
  }
  else
  {
    v7 = 0;
  }
  kdebug_trace();
  return v7;
}

void sub_18801538C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_KTX::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  KTXReadPlugin::KTXReadPlugin(v4, a2, v5);
  return v4;
}

void sub_188015404(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C400F943309);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_KTX::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  KTXReadPlugin::KTXReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_1880154A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C400F943309);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_KTX::updateSourceProperties(IIO_Reader_KTX *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  _BYTE v15[16];
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  CFMutableArrayRef v20;
  void *v21;
  uint64_t v22;
  CFMutableArrayRef v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  int8x16_t __dst[2];
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v33 = 0;
  v31 = 0u;
  v32 = 0u;
  v30 = 0u;
  v29 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v29, a2);
  v35 = 0u;
  v36 = 0u;
  v7 = 4294967246;
  memset(__dst, 0, sizeof(__dst));
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v29, __dst, 0, 0x40uLL) == 64)
  {
    SwapKTXHeader(__dst);
    v7 = ValidateKTXHeader(__dst, v30);
    if (!(_DWORD)v7)
    {
      GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)&v29, __dst[0].i32[3] == 67305985);
      if (DWORD1(v36) == 1)
        v8 = v36;
      else
        v8 = 1;
      if ((_DWORD)v36)
        v9 = v8;
      else
        v9 = DWORD1(v36);
      IIONumber::IIONumber((IIONumber *)&v26, v9);
      IIODictionary::setObjectForKeyGroup(a3, v28, "ImageCount", "{FilesContents}");
      IIONumber::~IIONumber((IIONumber *)&v26);
      v26 = 0;
      v27 = 0;
      v28 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v26);
      IIONumber::IIONumber((IIONumber *)&v23, SDWORD1(v35));
      IIODictionary::setObjectForKey((IIODictionary *)&v26, v25, "Width");
      IIONumber::~IIONumber((IIONumber *)&v23);
      IIONumber::IIONumber((IIONumber *)&v23, SDWORD2(v35));
      IIODictionary::setObjectForKey((IIODictionary *)&v26, v25, "Height");
      IIONumber::~IIONumber((IIONumber *)&v23);
      v23 = 0;
      v24 = 0;
      v25 = 0;
      IIOArray::IIOArray((IIOArray *)&v23);
      for (; v9; --v9)
        IIOArray::addObject(&v23, v27);
      IIODictionary::setObjectForKeyGroup(a3, v24, "Images", "{FilesContents}");
      v10 = DWORD2(v36);
      v20 = 0;
      v21 = 0;
      v22 = 0;
      IIOArray::IIOArray((IIOArray *)&v20);
      if (v10)
      {
        v12 = DWORD1(v35);
        v11 = DWORD2(v35);
        v13 = v10;
        do
        {
          v17 = 0;
          v18 = 0;
          v19 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v17);
          IIONumber::IIONumber((IIONumber *)v15, v12);
          IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, "Width");
          IIONumber::~IIONumber((IIONumber *)v15);
          IIONumber::IIONumber((IIONumber *)v15, v11);
          IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, "Height");
          IIONumber::~IIONumber((IIONumber *)v15);
          IIOArray::addObject(&v20, v18);
          IIODictionary::~IIODictionary((IIODictionary *)&v17);
          if (v12 < 2)
            break;
          if (v11 <= 1)
            break;
          v11 >>= 1;
          v12 >>= 1;
          --v13;
        }
        while (v13);
      }
      IIONumber::IIONumber((IIONumber *)&v17, v10);
      IIODictionary::setObjectForKeyGroup(a3, v19, "MipMapCount", "{MipMapInfo}");
      IIONumber::~IIONumber((IIONumber *)&v17);
      IIODictionary::setObjectForKeyGroup(a3, v21, "MipMaps", "{MipMapInfo}");
      IIOArray::~IIOArray((IIOArray *)&v20);
      IIOArray::~IIOArray((IIOArray *)&v23);
      IIODictionary::~IIODictionary((IIODictionary *)&v26);
      v7 = 0;
    }
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v29);
  return v7;
}

void sub_1880157C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a2)
  {
    IIOArray::~IIOArray((IIOArray *)&a16);
    IIOArray::~IIOArray((IIOArray *)&a19);
    IIODictionary::~IIODictionary((IIODictionary *)&a22);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x188015784);
  }
  _Unwind_Resume(exception_object);
}

void sub_1880158C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x188015840);
}

uint64_t IIO_Reader_KTX::hasCustomImageCountProc(IIO_Reader_KTX *this)
{
  return 1;
}

uint64_t IIO_Reader_KTX::hasCustomSourcePropertiesProc(IIO_Reader_KTX *this)
{
  return 1;
}

void ATXWritePlugin::~ATXWritePlugin(ATXWritePlugin *this, uint64_t a2, const char *a3)
{
  uint64_t v4;

  *(_QWORD *)this = &off_1E1BADFF0;
  v4 = *((_QWORD *)this + 9);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  CommonASTCWritePlugin::~CommonASTCWritePlugin(this, a2, a3);
}

{
  uint64_t v4;

  *(_QWORD *)this = &off_1E1BADFF0;
  v4 = *((_QWORD *)this + 9);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  CommonASTCWritePlugin::~CommonASTCWritePlugin(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t ATXWritePlugin::updateHeader(ASTCTwiddler **a1, IIOImageSource *a2, uint64_t a3, uint64_t a4)
{
  int AlphaInfo;
  int v8;
  int v9;
  CGColorSpace *SourceGeomColorSpace;
  uint64_t result;
  int v12;
  int v13;

  (*((void (**)(ASTCTwiddler **, uint64_t))*a1 + 7))(a1, a3);
  if (gUseATXForKTX)
    *(_WORD *)((char *)a1 + 57) = 256;
  *(_DWORD *)a4 = 1;
  *((_DWORD *)a1 + 16) = IIOImageSource::count(a2);
  *((_DWORD *)a1 + 17) = IIO_Reader::testHeaderSize(a2);
  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  *(_QWORD *)(a4 + 24) = a1[8];
  *(_DWORD *)(a4 + 32) = 1;
  *(_DWORD *)(a4 + 4) = 0;
  *(_QWORD *)(a4 + 8) = 0;
  v8 = *((_DWORD *)a1 + 11);
  if (v8 == 68)
  {
    v9 = 37808;
  }
  else
  {
    if (v8 != 136)
      goto LABEL_8;
    v9 = 37815;
  }
  *(_DWORD *)(a4 + 16) = v9;
LABEL_8:
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  result = IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E0C9D908]);
  if ((result & 1) != 0)
  {
    v12 = 3;
  }
  else
  {
    result = IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E0C9D960]);
    if ((result & 1) != 0)
    {
      v12 = 4;
    }
    else
    {
      result = IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E0C9D8F8]);
      if ((_DWORD)result)
        v12 = 2;
      else
        v12 = 1;
    }
  }
  *(_DWORD *)(a4 + 20) = 6408;
  *(_QWORD *)(a4 + 36) = 0x100000000;
  v13 = *((unsigned __int8 *)a1 + 58);
  *(_DWORD *)(a4 + 44) = 1;
  *(_DWORD *)(a4 + 48) = v13;
  *(_DWORD *)(a4 + 52) = *((unsigned __int8 *)a1 + 57);
  *(_DWORD *)(a4 + 56) = 1;
  if (v13)
  {
    ATXWritePlugin::createASTCTwiddler((ASTCTwiddler *)a1);
    result = ASTCTwiddler::getWatermark(a1[9], (unsigned __int8 *)(a4 + 60));
  }
  else
  {
    memset((void *)(a4 + 60), 85, 16);
  }
  *(_DWORD *)(a4 + 76) = v12;
  *(_DWORD *)(a4 + 80) = AlphaInfo;
  return result;
}

ASTCTwiddler *ATXWritePlugin::createASTCTwiddler(ASTCTwiddler *this)
{
  ASTCTwiddler *v1;
  int v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  ASTCTwiddler *v6;

  if (!*((_QWORD *)this + 9))
  {
    v1 = this;
    v2 = *((_DWORD *)this + 11);
    if (v2 == 136)
      v3 = 37815;
    else
      v3 = 0;
    if (v2 == 68)
      v4 = 37808;
    else
      v4 = v3;
    v5 = ASTCTextureImp::MetalFormatForGLFormat((ASTCTextureImp *)v4);
    v6 = (ASTCTwiddler *)operator new();
    this = ASTCTwiddler::ASTCTwiddler(v6, v5, *((unsigned int *)v1 + 16), *((unsigned int *)v1 + 17), 1uLL, 1);
    *((_QWORD *)v1 + 9) = v6;
  }
  return this;
}

void sub_188015B7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t ATXWritePlugin::writeASTCData(ATXWritePlugin *this, IIOImageWriteSession *a2, IIOImagePixelDataProvider *a3, IIODictionary *a4)
{
  unsigned int AlphaInfo;
  __int16 BitmapInfo;
  at_alpha_t v9;
  const char *v10;
  int v11;
  int v12;
  at_block_format_t v13;
  CGColorSpace *SourceGeomColorSpace;
  CGColorSpaceModel Model;
  int Error;
  at_texel_format_t v17;
  uint64_t v18;
  at_encoder_t v19;
  NSObject *v20;
  size_t v21;
  size_t v22;
  void *v23;
  void *v24;
  unint64_t block_counts;
  unsigned int v26;
  unint64_t v27;
  size_t block_size;
  size_t v29;
  void *v30;
  void *v31;
  at_flags_t v32;
  float v33;
  uint64_t v34;
  const void *v35;
  uint64_t v36;
  size_t v37;
  _BOOL4 v38;
  size_t v39;
  uint64_t v41;
  uint64_t v42;
  size_t __nitems;
  at_block_buffer_t dest;
  at_texel_region_t src;
  unsigned __int8 *v46;
  uint64_t __ptr;
  int v48;
  uint64_t v49;
  at_size_t v50;

  v49 = *MEMORY[0x1E0C80C00];
  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a3);
  BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a3);
  if (AlphaInfo >= 7)
  {
    _cg_jpeg_mem_term("writeASTCData", 225, "### alpha not handled: %X\n", AlphaInfo);
    v9 = at_alpha_opaque;
  }
  else
  {
    v9 = dword_18822B29C[AlphaInfo];
  }
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    v10 = IIO_AlphaInfoString(AlphaInfo);
    ImageIOLog("    writeASTCData: alpha = %s\n", v10);
  }
  v11 = *((_DWORD *)this + 11);
  if (v11 == 68)
  {
    v12 = 4;
  }
  else
  {
    if (v11 == 136)
    {
      v12 = 8;
      v13 = at_block_format_astc_8x8_ldr;
      goto LABEL_12;
    }
    LogError("writeASTCData", 252, "blockSize: '%02X' not yet supported - falling back to '44'\n", *((_DWORD *)this + 11));
    *(_QWORD *)((char *)this + 44) = 0x400000044;
    v12 = 4;
    *((_DWORD *)this + 13) = 4;
  }
  v13 = at_block_format_astc_4x4_ldr;
LABEL_12:
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    writeASTCData: blockSize = %dx%d\n", v12, v12);
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a3);
  Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  Error = _cg_GifLastError((uint64_t)a3);
  if (Model == kCGColorSpaceModelRGB)
  {
    v18 = 10;
    if ((BitmapInfo & 0x100) == 0)
      v18 = 7;
    if (Error == 16)
      v17 = v18;
    else
      v17 = at_texel_format_rgba8_unorm;
  }
  else if (Model)
  {
    v17 = at_texel_format_invalid;
  }
  else if (Error == 16)
  {
    if (AlphaInfo)
      v17 = at_texel_format_la16_unorm;
    else
      v17 = at_texel_format_l16_unorm;
  }
  else if (AlphaInfo)
  {
    v17 = at_texel_format_la8_unorm;
  }
  else
  {
    v17 = at_texel_format_l8_unorm;
  }
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    writeASTCData: bpc = %d\n", Error);
  v46 = 0;
  v19 = at_encoder_create(v17, v9, v13, v9, 0);
  if (!v19)
    return 4294967246;
  v20 = v19;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    writeASTCData: astcEncoder = %p\n", v19);
  v21 = IIOImagePlus::sourceImageProvider(a3);
  v22 = v21 * *((unsigned int *)this + 17);
  v23 = malloc_type_malloc(v22, 0xAEE1A442uLL);
  if (!v23)
  {
    CFRelease(v20);
    return 4294967246;
  }
  v24 = v23;
  if (IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a3, v23) != v22)
  {
    LogError("writeASTCData", 330, "*** ERROR: failed to read %ld bytes\n", v22);
    CFRelease(v20);
    free(v24);
    return 4294967185;
  }
  src.texels = v24;
  *(_QWORD *)&src.validSize.x = *((_QWORD *)this + 8);
  *((_DWORD *)&src.validSize + 3) = 0;
  src.rowBytes = v21;
  src.validSize.z = 1;
  src.sliceBytes = 0;
  *(_QWORD *)&v50.x = *(_QWORD *)&src.validSize.x;
  v50.z = 1;
  block_counts = (unint64_t)at_encoder_get_block_counts(v20, v50);
  v26 = block_counts;
  v27 = HIDWORD(block_counts);
  block_size = at_encoder_get_block_size(v20);
  v29 = v27 * v26 * block_size;
  dest.rowBytes = v26 * block_size;
  dest.sliceBytes = v29;
  v30 = malloc_type_calloc(v29, 1uLL, 0x63F854FEuLL);
  v31 = v30;
  if (!v30)
    goto LABEL_44;
  dest.blocks = v30;
  if (*((_BYTE *)this + 61))
    v32 = (16 * *((unsigned __int8 *)this + 60)) | 0x40;
  else
    v32 = 16 * *((unsigned __int8 *)this + 60);
  v33 = at_encoder_compress_texels(v20, &src, &dest, *((float *)this + 10), v32);
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    writeASTCData: at_encoder_compress_texels = %g\n", v33);
  if (v33 >= 0.0)
  {
    __nitems = 0;
    v48 = 0;
    __ptr = 0;
    if (*((_BYTE *)this + 58))
    {
      ATXWritePlugin::createASTCTwiddler(this);
      ASTCTwiddler::copyFromLinearData(*((ASTCTwiddler **)this + 9), v31, 0, v29, dest.rowBytes, 0);
      ASTCTwiddler::finalizeTwiddling(*((ASTCTwiddler **)this + 9));
      v35 = (const void *)ASTCTwiddler::twiddledData(*((ASTCTwiddler **)this + 9));
      v36 = ASTCTwiddler::twiddledDataSize(*((ASTCTwiddler **)this + 9));
      *((_BYTE *)this + 57) = 0;
      HIDWORD(__ptr) = 1668576097;
      if (v35)
      {
        v37 = v36;
        LODWORD(__ptr) = v36 + 4;
        v48 = v36;
        if (IIOImageWriteSession::putBytes(a2, &__ptr, 0xCuLL) != 12)
        {
          LogError("writeASTCData", 455, "*** failed to write 'astc' header\n", v41, v42);
          goto LABEL_44;
        }
        if (IIOImageWriteSession::putBytes(a2, v35, v37) != v37)
        {
          LogError("writeASTCData", 461, "*** failed to write 'astc' data\n", v41, v42);
          goto LABEL_44;
        }
LABEL_59:
        v34 = 0;
        goto LABEL_60;
      }
    }
    else if (*((_BYTE *)this + 57))
    {
      v38 = IIOWritePlugin::createLZFSECompressedData(this, (unsigned __int8 *)v31, v29, &v46, (unsigned __int8 **)&__nitems);
      HIDWORD(__ptr) = 1397119564;
      if (v38)
      {
        LODWORD(__ptr) = __nitems + 4;
        v48 = __nitems;
        if (IIOImageWriteSession::putBytes(a2, &__ptr, 0xCuLL) != 12)
        {
          LogError("writeASTCData", 471, "*** failed to write 'LZFSE' header\n");
          goto LABEL_44;
        }
        v39 = IIOImageWriteSession::putBytes(a2, v46, __nitems);
        if (v39 != __nitems)
        {
          LogError("writeASTCData", 477, "*** failed to write 'LZFSE' data\n", v41, v42);
          goto LABEL_44;
        }
        goto LABEL_59;
      }
    }
    else
    {
      HIDWORD(__ptr) = 1129599809;
    }
    LODWORD(__ptr) = v29 + 4;
    v48 = v29;
    if (IIOImageWriteSession::putBytes(a2, &__ptr, 0xCuLL) != 12)
    {
      LogError("writeASTCData", 487, "*** failed to write 'ASTC' header\n", v41, v42);
      goto LABEL_44;
    }
    if (IIOImageWriteSession::putBytes(a2, v31, v29) != v29)
    {
      LogError("writeASTCData", 493, "*** failed to write 'ASTC' data\n", v41, v42);
      goto LABEL_44;
    }
    goto LABEL_59;
  }
  LogError("writeASTCData", 377, "at_encoder_compress_texels - %g (%ld)\n");
LABEL_44:
  v34 = 4294967246;
LABEL_60:
  if (v46)
    free(v46);
  CFRelease(v20);
  if (v31)
    free(v31);
  free(v24);
  return v34;
}

uint64_t ATXWritePlugin::convertAndWrite420fData(ATXWritePlugin *this, IIOImagePixelDataProvider *a2, unsigned __int8 *a3, unsigned int a4, char a5, double a6, double a7)
{
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char v14;
  void *v15;
  void *v16;
  void *v17;
  BOOL v18;
  vImagePixelCount v19;
  vImagePixelCount v20;
  int8x16_t v21;
  vImage_Error v22;
  vImage_Error v23;
  const char *v24;
  unint64_t v26;
  unsigned __int8 *v27;
  vImage_Buffer destCbCr;
  vImage_Buffer destYp;
  vImage_Buffer src;
  float64x2_t v31;
  __int128 v32;
  float64x2_t v33[2];
  uint8_t permuteMap[4];
  _BYTE __ptr[12];
  int32x2_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)permuteMap = 33619971;
  memset(v33, 0, sizeof(v33));
  v31 = 0u;
  v32 = 0u;
  LODWORD(a7) = *((_DWORD *)this + 17);
  v11 = IIO_FillGeometry420(875704422, 0x10u, (uint64_t)&v31, (double)*((unsigned int *)this + 16), (double)*(unint64_t *)&a7, 16.0, 16.0);
  if ((_DWORD)v11)
  {
    _cg_jpeg_mem_term("convertAndWrite420fData", 532, "*** ERROR: bad input for creating '420f' data (%dx%d)\n");
    return v11;
  }
  v12 = DWORD1(v32) * (unint64_t)v31.f64[1];
  if ((v12 & 0xFFFFFFFF00000000) != 0 || !(_DWORD)v12)
  {
    _cg_jpeg_mem_term("convertAndWrite420fData", 535, "*** ERROR: convertAndWrite420fData unsupported lumaSize (%d)\n");
    return v11;
  }
  v13 = LODWORD(v33[1].f64[1]) * (unint64_t)v33[1].f64[0];
  if ((v13 & 0xFFFFFFFF00000000) != 0 || !(_DWORD)v13)
  {
    _cg_jpeg_mem_term("convertAndWrite420fData", 538, "*** ERROR: convertAndWrite420fData unsupported chromaSize (%d)\n");
    return v11;
  }
  v14 = a5;
  v15 = malloc_type_malloc(v12, 0x2ED60EF6uLL);
  v16 = malloc_type_malloc(v13, 0x3FB7FD39uLL);
  v17 = v16;
  if (v15)
    v18 = v16 == 0;
  else
    v18 = 1;
  if (!v18)
  {
    v20 = *((unsigned int *)this + 16);
    v19 = *((unsigned int *)this + 17);
    src.data = a3;
    src.height = v19;
    src.width = v20;
    src.rowBytes = a4;
    destYp.data = v15;
    destYp.height = v19;
    destYp.width = v20;
    destYp.rowBytes = DWORD1(v32);
    destCbCr.data = v16;
    v21 = (int8x16_t)vcvtq_u64_f64(*(float64x2_t *)((char *)v33 + 8));
    *(int8x16_t *)&destCbCr.height = vextq_s8(v21, v21, 8uLL);
    destCbCr.rowBytes = LODWORD(v33[1].f64[1]);
    if (ATXWritePlugin::convertAndWrite420fData(IIOImagePixelDataProvider *,unsigned char *,unsigned int,BOOL)::ARGBToYpCbCrCreate != -1)
      dispatch_once(&ATXWritePlugin::convertAndWrite420fData(IIOImagePixelDataProvider *,unsigned char *,unsigned int,BOOL)::ARGBToYpCbCrCreate, &__block_literal_global_26);
    v22 = vImageConvert_ARGB8888To420Yp8_CbCr8(&src, &destYp, &destCbCr, &ATXWritePlugin::convertAndWrite420fData(IIOImagePixelDataProvider *,unsigned char *,unsigned int,BOOL)::conversion, permuteMap, 0x10u);
    if (v22)
    {
      v23 = v22;
      v24 = IIO_vImageErrorString(v22);
      _cg_jpeg_mem_term("convertAndWrite420fData", 574, "*** ERROR: vImageConvert_ARGB8888To420Yp8_CbCr8 returned %ld (%s)\n", v23, v24);
    }
    else if ((v14 & 1) != 0)
    {
      v26 = 0;
      v27 = 0;
      *(_QWORD *)&__ptr[4] = 0x616D756C5A303234;
      v36 = vmovn_s64((int64x2_t)vcvtq_u64_f64(v31));
      v37 = DWORD1(v32);
      LODWORD(v38) = 1397119564;
      IIOWritePlugin::createLZFSECompressedData(this, (unsigned __int8 *)destYp.data, v12, &v27, (unsigned __int8 **)&v26);
      *(_DWORD *)__ptr = v26 + 24;
      HIDWORD(v38) = v26;
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), __ptr, 0x20uLL);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v27, v26);
      free(v27);
      ATXWritePlugin::writeFiller((IIOImageWriteSession **)this, 0x40u, 0x20u);
      *(_QWORD *)__ptr = 0x5A30323400000000;
      v36 = vmovn_s64((int64x2_t)vcvtq_u64_f64(*(float64x2_t *)((char *)v33 + 8)));
      *(_DWORD *)&__ptr[8] = 1836214371;
      v37 = LODWORD(v33[1].f64[1]);
      v38 = 1397119564;
      IIOWritePlugin::createLZFSECompressedData(this, (unsigned __int8 *)destCbCr.data, v13, &v27, (unsigned __int8 **)&v26);
      *(_DWORD *)__ptr = v26 + 24;
      HIDWORD(v38) = v26;
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), __ptr, 0x20uLL);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v27, v26);
      free(v27);
    }
    else
    {
      *(_QWORD *)&__ptr[4] = 0x414D554C66303234;
      v36 = vmovn_s64((int64x2_t)vcvtq_u64_f64(v31));
      *(_DWORD *)__ptr = v12 + 16;
      v37 = DWORD1(v32);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), __ptr, 0x18uLL);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), destYp.data, v12);
      ATXWritePlugin::writeFiller((IIOImageWriteSession **)this, 0x100u, 0x18u);
      *(_QWORD *)&__ptr[4] = 0x4D52484366303234;
      v36 = vmovn_s64((int64x2_t)vcvtq_u64_f64(*(float64x2_t *)((char *)v33 + 8)));
      *(_DWORD *)__ptr = v13 + 16;
      v37 = LODWORD(v33[1].f64[1]);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), __ptr, 0x18uLL);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), destCbCr.data, v13);
    }
    goto LABEL_20;
  }
  if (v15)
LABEL_20:
    free(v15);
  v11 = 0;
  if (v17)
    free(v17);
  return v11;
}

__n128 ___ZN14ATXWritePlugin23convertAndWrite420fDataEP25IIOImagePixelDataProviderPhjb_block_invoke()
{
  vImage_Error v0;
  __n128 result;
  vImage_Error v2;
  const char *v3;
  vImage_YpCbCrPixelRange pixelRange;

  pixelRange = *(vImage_YpCbCrPixelRange *)ymmword_18822B268;
  v0 = vImageConvert_ARGBToYpCbCr_GenerateConversion((const vImage_ARGBToYpCbCrMatrix *)*MEMORY[0x1E0C8BD98], &pixelRange, &ATXWritePlugin::convertAndWrite420fData(IIOImagePixelDataProvider *,unsigned char *,unsigned int,BOOL)::conversion, kvImageARGB8888, kvImage420Yp8_CbCr8, 0);
  if (v0)
  {
    v2 = v0;
    v3 = IIO_vImageErrorString(v0);
    return _cg_jpeg_mem_term("convertAndWrite420fData_block_invoke", 567, "*** ERROR: vImageConvert_ARGBToYpCbCr_GenerateConversion returned %ld (%s)\n", v2, v3);
  }
  return result;
}

uint64_t ATXWritePlugin::writeFiller(IIOImageWriteSession **this, unsigned int a2, unsigned int a3)
{
  unint64_t Position;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  void *v11;
  size_t v12;
  _DWORD __ptr[2];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2 <= a3)
    return 0;
  Position = IIOImageWriteSession::getPosition(this[2]);
  v7 = Position + a2 - 1 - ((Position + a2 - 1) % a2 + a3);
  do
  {
    v8 = v7;
    v9 = v7 - 8;
    v7 += a2;
  }
  while (v9 < Position);
  v10 = v8 - Position - 8;
  if (v10 > a2)
    LogError("writeFiller", 705, "    bad fillSize: %d   alignment: %d   prefix: %d\n", v10, a2, a3);
  __ptr[0] = v10;
  __ptr[1] = 1280067910;
  IIOImageWriteSession::putBytes(this[2], __ptr, 8uLL);
  v11 = malloc_type_calloc(v10, 1uLL, 0x67B8C3CAuLL);
  v12 = IIOImageWriteSession::putBytes(this[2], v11, v10);
  free(v11);
  if (v10 == v12)
    return 0;
  else
    return 4294967246;
}

uint64_t ATXWritePlugin::write420fData(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, char a4)
{
  uint64_t Ref;
  __IOSurface *v8;
  __IOSurface *v9;
  int PlaneCount;
  OSType PixelFormat;
  unsigned __int8 *BaseAddressOfPlane;
  unsigned int BytesPerRowOfPlane;
  int WidthOfPlane;
  unsigned int HeightOfPlane;
  unsigned __int8 *v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  size_t v20;
  uint64_t v21;
  void *v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  size_t v26;
  void *v27;
  int v28;
  unsigned int v29;
  size_t v30;
  unsigned __int8 *BaseAddress;
  unsigned int BytesPerRow;
  IIOImagePixelDataProvider *v33;
  double v34;
  double v35;
  int v36;
  int v37;
  void *v38;
  IIOImagePixelDataProvider *v39;
  double v40;
  double v41;
  int v43;
  unint64_t v44;
  unsigned __int8 *v45;
  _QWORD v46[3];
  int __ptr;
  uint64_t v48;
  int v49;
  void *value;
  int v51;
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  Ref = IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  if (IIO_CGImageWrapsIOSurface(Ref, 1))
  {
    memset(v46, 0, sizeof(v46));
    IIODictionary::IIODictionary((IIODictionary *)v46);
    IIONumber::IIONumber((IIONumber *)&__ptr, 875704422);
    IIODictionary::setObjectForKey((IIODictionary *)v46, value, CFSTR("kCGImageSurfaceFormatRequest"));
    IIONumber::~IIONumber((IIONumber *)&__ptr);
    v8 = (__IOSurface *)CGImageProviderCopyIOSurface();
    v9 = v8;
    if (v8)
    {
      PlaneCount = IOSurfaceGetPlaneCount(v8);
      PixelFormat = IOSurfaceGetPixelFormat(v9);
      if (PixelFormat == 875704422)
      {
        if ((a4 & 1) != 0)
        {
          v51 = 0;
          v44 = 0;
          v45 = 0;
          BaseAddressOfPlane = (unsigned __int8 *)IOSurfaceGetBaseAddressOfPlane(v9, 0);
          BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(v9, 0);
          WidthOfPlane = IOSurfaceGetWidthOfPlane(v9, 0);
          HeightOfPlane = IOSurfaceGetHeightOfPlane(v9, 0);
          v48 = 0x616D756C5A303234;
          v49 = WidthOfPlane;
          value = (void *)__PAIR64__(BytesPerRowOfPlane, HeightOfPlane);
          IIOWritePlugin::createLZFSECompressedData((IIOWritePlugin *)this, BaseAddressOfPlane, HeightOfPlane * BytesPerRowOfPlane, &v45, (unsigned __int8 **)&v44);
          __ptr = v44 + 24;
          v52 = v44;
          IIOImageWriteSession::putBytes(this[2], &__ptr, 0x20uLL);
          IIOImageWriteSession::putBytes(this[2], v45, v44);
          free(v45);
          ATXWritePlugin::writeFiller(this, 0x40u, 0x20u);
          v16 = (unsigned __int8 *)IOSurfaceGetBaseAddressOfPlane(v9, 1uLL);
          v17 = IOSurfaceGetBytesPerRowOfPlane(v9, 1uLL);
          v18 = IOSurfaceGetWidthOfPlane(v9, 1uLL);
          v19 = IOSurfaceGetHeightOfPlane(v9, 1uLL);
          v20 = v19 * v17;
          __ptr = v20 + 16;
          v48 = 0x6D7268635A303234;
          v49 = v18;
          value = (void *)__PAIR64__(v17, v19);
          v21 = IIOWritePlugin::createLZFSECompressedData((IIOWritePlugin *)this, v16, v20, &v45, (unsigned __int8 **)&v44);
          __ptr = v44 + 24;
          v52 = v44;
          IIOImageWriteSession::putBytes(this[2], &__ptr, 0x20uLL);
          IIOImageWriteSession::putBytes(this[2], v45, v44);
          free(v45);
          if (!(_DWORD)v21)
            goto LABEL_15;
        }
        else
        {
          v43 = PlaneCount;
          v22 = IOSurfaceGetBaseAddressOfPlane(v9, 0);
          v23 = IOSurfaceGetBytesPerRowOfPlane(v9, 0);
          v24 = IOSurfaceGetWidthOfPlane(v9, 0);
          v25 = IOSurfaceGetHeightOfPlane(v9, 0);
          v26 = v25 * v23;
          __ptr = v26 + 16;
          v48 = 0x414D554C66303234;
          v49 = v24;
          value = (void *)__PAIR64__(v23, v25);
          IIOImageWriteSession::putBytes(this[2], &__ptr, 0x18uLL);
          IIOImageWriteSession::putBytes(this[2], v22, v26);
          v21 = ATXWritePlugin::writeFiller(this, 0x100u, 0x18u);
          v27 = IOSurfaceGetBaseAddressOfPlane(v9, 1uLL);
          LODWORD(v26) = IOSurfaceGetBytesPerRowOfPlane(v9, 1uLL);
          v28 = IOSurfaceGetWidthOfPlane(v9, 1uLL);
          v29 = IOSurfaceGetHeightOfPlane(v9, 1uLL);
          v30 = v29 * v26;
          __ptr = v30 + 16;
          v48 = 0x4D52484366303234;
          v49 = v28;
          value = (void *)__PAIR64__(v26, v29);
          IIOImageWriteSession::putBytes(this[2], &__ptr, 0x18uLL);
          IIOImageWriteSession::putBytes(this[2], v27, v30);
          PlaneCount = v43;
          if (!(_DWORD)v21)
            goto LABEL_15;
        }
      }
      else
      {
        v21 = 4294967246;
      }
      if ((PlaneCount & 0xFFFFFFFE) == 0 && (PixelFormat == 1380401729 || PixelFormat == 1111970369))
      {
        BaseAddress = (unsigned __int8 *)IOSurfaceGetBaseAddress(v9);
        BytesPerRow = IOSurfaceGetBytesPerRow(v9);
        v21 = ATXWritePlugin::convertAndWrite420fData((ATXWritePlugin *)this, v33, BaseAddress, BytesPerRow, a4, v34, v35);
      }
LABEL_15:
      IIODictionary::~IIODictionary((IIODictionary *)v46);
      if (!(_DWORD)v21)
        return v21;
      goto LABEL_16;
    }
    IIODictionary::~IIODictionary((IIODictionary *)v46);
  }
  v21 = 4294967246;
LABEL_16:
  v36 = *((_DWORD *)this + 16);
  v37 = *((_DWORD *)this + 17);
  if (IIOImagePixelDataProvider::getAlphaInfo(a2))
  {
    v38 = malloc_type_malloc((4 * v36 * v37), 0x434E5738uLL);
    IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v38);
    v21 = ATXWritePlugin::convertAndWrite420fData((ATXWritePlugin *)this, v39, (unsigned __int8 *)v38, 4 * *((_DWORD *)this + 16), a4, v40, v41);
    free(v38);
  }
  return v21;
}

void sub_188016BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t ATXWritePlugin::write420f(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  IIODictionary *v8;
  _BOOL4 BoolForKey;
  unsigned int v10;
  unsigned int v11;
  IIODictionary *v12;
  uint64_t v13;
  uint64_t __ptr;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v16 = 0u;
  if (a4 && IIODictionary::containsKey(a4, CFSTR("kCGImageProperty420fUseLZFSE")))
  {
    v8 = a4;
LABEL_7:
    BoolForKey = IIODictionary::getBoolForKey(v8, CFSTR("kCGImageProperty420fUseLZFSE"));
    goto LABEL_9;
  }
  if (a3 && IIODictionary::containsKey(a3, CFSTR("kCGImageProperty420fUseLZFSE")))
  {
    v8 = a3;
    goto LABEL_7;
  }
  BoolForKey = 0;
LABEL_9:
  __ptr = 0xA1A0A0D4C504141;
  IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
  ATXWritePlugin::updateHeader(this, a2, (uint64_t)a3, (uint64_t)&v16);
  *(int32x2_t *)&v17 = vdup_n_s32(0x66303234u);
  DWORD1(v19) = BoolForKey;
  __ptr = 0x4441454800000054;
  IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
  IIOImageWriteSession::putBytes(this[2], &v16, 0x54uLL);
  if (BoolForKey)
  {
    v10 = 64;
    v11 = 32;
  }
  else
  {
    v10 = 256;
    v11 = 24;
  }
  ATXWritePlugin::writeFiller(this, v10, v11);
  v13 = ATXWritePlugin::write420fData(this, a2, v12, BoolForKey);
  if (!(_DWORD)v13)
  {
    __ptr = 0x20444E4500000000;
    IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
  }
  return v13;
}

uint64_t ATXWritePlugin::writeOneImage(ATXWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t ATXWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  unsigned __int8 v8;
  IIODictionary *v9;
  unsigned int v10;
  const __CFDictionary *ObjectForKey;
  uint64_t result;
  unsigned int Position;
  int v14;
  int v15;
  size_t v16;
  void *v17;
  size_t v18;
  IIODictionary *v19;
  uint64_t __ptr;
  _OWORD v21[5];
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((a4
     && (v8 = IIODictionary::containsKey(a4, CFSTR("kCGImagePropertyEncoder")), v9 = a4, (v8 & 1) != 0)
     || a3 && (v10 = IIODictionary::containsKey(a3, CFSTR("kCGImagePropertyEncoder")), v9 = a3, v10))
    && (ObjectForKey = IIODictionary::getObjectForKey(v9, CFSTR("kCGImagePropertyEncoder")),
        CFEqual(ObjectForKey, CFSTR("kCGImageProperty420fEncoder"))))
  {
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    saving ATX-420f image\n");
    return ATXWritePlugin::write420f(this, a2, a3, a4);
  }
  else
  {
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    saving ATX-ASTC image\n");
    v22 = 0;
    memset(v21, 0, sizeof(v21));
    __ptr = 0xA1A0A0D4C504141;
    IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
    ATXWritePlugin::updateHeader(this, a2, (uint64_t)a3, (uint64_t)v21);
    __ptr = 0x4441454800000054;
    IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
    IIOImageWriteSession::putBytes(this[2], v21, 0x54uLL);
    Position = IIOImageWriteSession::getPosition(this[2]);
    if (*((_BYTE *)this + 58))
      v14 = 0x4000;
    else
      v14 = 256;
    v15 = -20;
    do
      v15 += v14;
    while (v15 + 8 < Position);
    v16 = v15 - Position;
    LODWORD(__ptr) = v15 - Position;
    HIDWORD(__ptr) = 1280067910;
    IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
    v17 = malloc_type_calloc(v16, 1uLL, 0xC622C4CBuLL);
    v18 = IIOImageWriteSession::putBytes(this[2], v17, v16);
    free(v17);
    if (v18 == v16)
    {
      result = ATXWritePlugin::writeASTCData((ATXWritePlugin *)this, this[2], a2, v19);
      if (!(_DWORD)result)
      {
        __ptr = 0x20444E4500000000;
        IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
        return 0;
      }
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t ATXWritePlugin::WriteProc(ATXWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  _OWORD v9[3];
  __int128 v10;
  __int128 v11;

  v10 = 0u;
  v11 = 0u;
  memset(v9, 0, sizeof(v9));
  CommonASTCWritePlugin::CommonASTCWritePlugin((CommonASTCWritePlugin *)v9, this, a2, 3u);
  *(_QWORD *)&v9[0] = &off_1E1BADFF0;
  BYTE10(v10) = 0;
  *((_QWORD *)&v11 + 1) = 0;
  v7 = IIOWritePlugin::writeAll((IIOImageDestination **)v9);
  *(_QWORD *)&v9[0] = &off_1E1BADFF0;
  if (*((_QWORD *)&v11 + 1))
    (*(void (**)(_QWORD))(**((_QWORD **)&v11 + 1) + 8))(*((_QWORD *)&v11 + 1));
  CommonASTCWritePlugin::~CommonASTCWritePlugin((CommonASTCWritePlugin *)v9, v5, v6);
  return v7;
}

void sub_188017104(void *a1, uint64_t a2, const char *a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a18)
    (*(void (**)(uint64_t))(*(_QWORD *)a18 + 8))(a18);
  CommonASTCWritePlugin::~CommonASTCWritePlugin((CommonASTCWritePlugin *)&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1880170F0);
}

uint64_t kdc_flow_control::kdc_flow_control(uint64_t a1, uint64_t a2, unsigned int *a3, int a4, int a5, uint64_t a6)
{
  uint64_t **v10;
  uint64_t *v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  int32x4_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  unsigned int *v23;

  *(_QWORD *)(a1 + 88) = 0;
  v23 = a3;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  v10 = (uint64_t **)(a1 + 120);
  *(_QWORD *)(a1 + 144) = 0;
  v11 = (uint64_t *)(a1 + 144);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 80) = a3;
  v13 = *(_OWORD *)(a2 + 16);
  v12 = *(_OWORD *)(a2 + 32);
  v14 = *(_QWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 64) = v14;
  *(_OWORD *)(a1 + 48) = v12;
  *(_OWORD *)(a1 + 32) = v13;
  *(_DWORD *)(a1 + 112) = a4;
  kdu_codestream::get_valid_tiles((kdu_codestream *)&v23, (int32x4_t *)(a1 + 88));
  if (a4 < 0 || *(_DWORD *)(a1 + 100) <= a4)
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in kdc_flow_control:\n");
    (*(void (**)(__int128 *, const char *))(v20 + 16))(&v20, "Bad kdc_flow_control c'tor x_tnum parameter");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  v15 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 104) = v15;
  *(_DWORD *)(a1 + 108) = HIDWORD(v15) + a4;
  *(_QWORD *)(a1 + 120) = kdu_codestream::open_tile((uint64_t *)&v23, *(_QWORD *)(a1 + 104), 0);
  *(_QWORD *)(a1 + 136) = a6;
  *(_BYTE *)(a1 + 128) = a5;
  v19 = 0uLL;
  kdu_codestream::get_tile_dims((uint64_t *)&v23, *(_QWORD *)(a1 + 104), 0, &v19, 1);
  *(_DWORD *)(a1 + 72) = v19.i32[2];
  *(_DWORD *)(a1 + 8) = kdu_codestream::get_num_components(&v23, 1);
  v16 = (void *)operator new[]();
  *(_QWORD *)a1 = v16;
  *(_DWORD *)(a1 + 132) = 0;
  v17 = *(unsigned int *)(a1 + 8);
  if ((int)v17 <= 0)
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in kdc_flow_control:\n");
    (*(void (**)(__int128 *, const char *))(v20 + 16))(&v20, "kdc_flow_control c'tor: num_components <= 0");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  bzero(v16, 8 * v17);
  kdu_tile::set_components_of_interest(v10, v17, 0);
  *(_QWORD *)(a1 + 152) = kdu_multi_analysis::create(v11, (uint64_t)v23, *v10, a5 ^ 1u, a6, 0, 1, 0, 0, 0);
  return a1;
}

void sub_188017358(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188017364(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Exception *v13;

  _Unwind_Resume(v13);
}

void kdc_flow_control::~kdc_flow_control(kdc_flow_control *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)this;
  if (v2)
    MEMORY[0x18D761C18](v2, 0x20C8093837F09);
  v3 = *((_QWORD *)this + 18);
  if (v3)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 16))(v3, 0);
    v4 = *((_QWORD *)this + 18);
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    *((_QWORD *)this + 18) = 0;
  }
}

uint64_t kdc_flow_control::advance_components(kdc_flow_control *this)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  float v7;
  _OWORD v9[2];
  uint64_t v10;

  if (*((int *)this + 18) < 1)
    return 0;
  v2 = (char *)this + 16;
  if (*((_DWORD *)this + 9) != (*((unsigned int (**)(_QWORD, _QWORD, _QWORD))this + 2))(*((_QWORD *)this + 3), *((_QWORD *)this + 6), *((int *)this + 9)))return 0;
  if (*((int *)this + 2) >= 1)
  {
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)this;
      v5 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(**((_QWORD **)this + 18) + 32))(*((_QWORD *)this + 18), v3, 0, 0);
      *(_QWORD *)(v4 + 8 * v3) = v5;
      if (!v5)
      {
        v10 = 0;
        memset(v9, 0, sizeof(v9));
        kdu_error::kdu_error((kdu_error *)v9, "Error in kdc_flow_control:\n");
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v9[0] + 16))(v9, "advance_components: comp->line == NULL");
        kdu_error::~kdu_error((kdu_error *)v9);
      }
      kdu_image_in::get((uint64_t)v2, v3++, v5, v6, v7);
    }
    while (v3 < *((int *)this + 2));
  }
  return 1;
}

void sub_188017518(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_188017524()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdc_flow_control::process_components(uint64_t this)
{
  int v1;
  BOOL v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v1 = *(_DWORD *)(this + 72);
  v2 = __OFSUB__(v1--, 1);
  *(_DWORD *)(this + 72) = v1;
  if (v1 < 0 == v2)
  {
    v3 = this;
    if (*(int *)(this + 8) >= 1)
    {
      v4 = 0;
      do
      {
        v5 = *(_QWORD *)v3;
        v6 = *(_QWORD *)(*(_QWORD *)v3 + 8 * v4);
        if (!v6)
        {
          v8 = 0;
          memset(v7, 0, sizeof(v7));
          kdu_error::kdu_error((kdu_error *)v7, "Error in kdc_flow_control:\n");
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, "process_components: comp->line == NULL");
          kdu_error::~kdu_error((kdu_error *)v7);
        }
        this = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v3 + 144) + 32))(*(_QWORD *)(v3 + 144), v4, v6, 0);
        *(_QWORD *)(v5 + 8 * v4++) = 0;
      }
      while (v4 < *(int *)(v3 + 8));
    }
  }
  return this;
}

void sub_188017604(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_188017610()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdc_flow_control::advance_tile(kdc_flow_control *this)
{
  uint64_t **v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;
  uint64_t v8;
  int32x4_t v9;

  v1 = (uint64_t **)((char *)this + 120);
  if (!*((_QWORD *)this + 15))
    return 0;
  v4 = (uint64_t *)((char *)this + 144);
  v3 = *((_QWORD *)this + 18);
  if (v3)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 16))(v3, 0);
    if (*v4)
      (*(void (**)(uint64_t))(*(_QWORD *)*v4 + 8))(*v4);
  }
  *((_QWORD *)this + 18) = 0;
  v5 = *((unsigned int *)this + 2);
  if ((int)v5 < 1)
    LODWORD(v5) = 0;
  else
    bzero(*(void **)this, 8 * v5);
  kdu_tile::close(v1, 0);
  *((_QWORD *)this + 15) = 0;
  v6 = *((_DWORD *)this + 26) + 1;
  *((_DWORD *)this + 26) = v6;
  if (v6 - *((_DWORD *)this + 22) == *((_DWORD *)this + 24))
    return 0;
  *((_QWORD *)this + 15) = kdu_codestream::open_tile((uint64_t *)this + 10, *((_QWORD *)this + 13), 0);
  v9 = 0uLL;
  kdu_codestream::get_tile_dims((uint64_t *)this + 10, *((_QWORD *)this + 13), v5, &v9, 1);
  *((_DWORD *)this + 18) = v9.i32[2];
  kdu_tile::set_components_of_interest(v1, *((_DWORD *)this + 2), 0);
  v8 = kdu_multi_analysis::create(v4, *((_QWORD *)this + 10), *((uint64_t **)this + 15), *((_BYTE *)this + 128) == 0, *((_QWORD *)this + 17), 0, 1, 0, 0, 0);
  if (v8 > *((_QWORD *)this + 19))
    *((_QWORD *)this + 19) = v8;
  return 1;
}

_QWORD *ICNSReadPlugin::ICNSReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *result = &off_1E1BAE278;
  return result;
}

_QWORD *ICNSReadPlugin::ICNSReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *result = &off_1E1BAE278;
  return result;
}

void ICNSReadPlugin::~ICNSReadPlugin(ICNSReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t ICNSReadPlugin::loadDataFromXPCObject(ICNSReadPlugin *this, void *a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_icns", &length);
    if (length == 56)
    {
      v6 = data;
      result = 0;
      v7 = *v6;
      v8 = v6[1];
      v9 = v6[2];
      *((_QWORD *)this + 61) = *((_QWORD *)v6 + 6);
      *(_OWORD *)((char *)this + 456) = v8;
      *(_OWORD *)((char *)this + 472) = v9;
      *(_OWORD *)((char *)this + 440) = v7;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t ICNSReadPlugin::saveDataToXPCObject(ICNSReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_icns", (char *)this + 440, 0x38uLL);
  return v4;
}

uint64_t ICNSReadPlugin::initialize(ICNSReadPlugin *this, IIODictionary *a2)
{
  IIODictionary *v4;
  IIOImageRead *v5;
  double v6;
  double v7;
  CFStringRef v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  __int16 v14;
  unsigned __int16 v15;
  int v16;
  int v17;
  BOOL v18;
  char v19;
  CGColorSpaceRef v20;
  CGColorSpace *v21;
  __int128 v22;
  _BYTE v24[24];
  UInt8 v25[24];
  UInt8 bytes[4];
  char v27;
  uint64_t v28[2];
  uint64_t v29[2];
  __int128 v30;
  uint64_t v31;
  void *__dst[97];

  __dst[96] = *(void **)MEMORY[0x1E0C80C00];
  v31 = 0;
  *(_OWORD *)v29 = 0u;
  v30 = 0u;
  *(_OWORD *)v28 = 0u;
  v27 = 0;
  *(_DWORD *)bytes = 0;
  if (!*((_BYTE *)this + 341))
    goto LABEL_32;
  v4 = (IIODictionary *)*((_QWORD *)this + 7);
  v5 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1229147731);
  if (!v5)
  {
    _cg_jpeg_mem_term("initialize", 147, "*** ERROR: globalICNSInfo is NULL for index: %d\n", *((_DWORD *)this + 52));
    goto LABEL_32;
  }
  GlobalICNSInfo::getICNSImageInfoAtIndex(v5, *((_DWORD *)this + 52), (uint64_t)v28);
  if (SLOWORD(v28[0]) < 0)
  {
LABEL_32:
    v9 = 4294967246;
    goto LABEL_33;
  }
  v6 = 72.0;
  if (BYTE1(v31) == 2)
    v6 = 144.0;
  IIONumber::IIONumber((IIONumber *)v25, v6);
  IIODictionary::setObjectForKey((uint64_t)v4, (uint64_t)v25, CFSTR("DPIWidth"));
  IIONumber::~IIONumber((IIONumber *)v25);
  v7 = 72.0;
  if (BYTE1(v31) == 2)
    v7 = 144.0;
  IIONumber::IIONumber((IIONumber *)v24, v7);
  IIODictionary::setObjectForKey((uint64_t)v4, (uint64_t)v24, CFSTR("DPIHeight"));
  IIONumber::~IIONumber((IIONumber *)v24);
  *(_DWORD *)bytes = bswap32(v30);
  v8 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 4, 0, 0);
  if (v8)
  {
    IIODictionary::setObjectForKey(v4, v8, CFSTR("kCGImagePropertyICNSIndexSelector"));
    CFRelease(v8);
  }
  if (BYTE2(v31) == 4)
  {
    IIONumber::IIONumber((IIONumber *)__dst, 1246769696);
    IIODictionary::setObjectForKey(a2, __dst[2], CFSTR("NEW_PLUGIN_ostype"));
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, v28[1]);
    IIODictionary::setObjectForKey(a2, __dst[2], CFSTR("NEW_PLUGIN_dataOffset"));
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, LOWORD(v29[1]));
    IIODictionary::setObjectForKey(a2, __dst[2], CFSTR("NEW_PLUGIN_expectedWidth"));
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, WORD1(v29[1]));
    IIODictionary::setObjectForKey(a2, __dst[2], CFSTR("NEW_PLUGIN_expectedHeight"));
    goto LABEL_14;
  }
  if (BYTE2(v31) == 2)
  {
    IIONumber::IIONumber((IIONumber *)__dst, 1347307296);
    IIODictionary::setObjectForKey(a2, __dst[2], CFSTR("NEW_PLUGIN_ostype"));
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, v28[1]);
    IIODictionary::setObjectForKey(a2, __dst[2], CFSTR("NEW_PLUGIN_dataOffset"));
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, LOWORD(v29[1]));
    IIODictionary::setObjectForKey(a2, __dst[2], CFSTR("NEW_PLUGIN_expectedWidth"));
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, WORD1(v29[1]));
    IIODictionary::setObjectForKey(a2, __dst[2], CFSTR("NEW_PLUGIN_expectedHeight"));
LABEL_14:
    IIONumber::~IIONumber((IIONumber *)__dst);
    v9 = 4294967247;
LABEL_33:
    kdebug_trace();
    return v9;
  }
  v10 = LOWORD(v29[1]);
  v11 = WORD1(v29[1]);
  *((_DWORD *)this + 57) = LOWORD(v29[1]);
  *((_DWORD *)this + 58) = v11;
  *((_WORD *)this + 120) = 8;
  v12 = HIWORD(v29[1]);
  v13 = WORD2(v29[1]);
  if (WORD2(v29[1]) <= 8u)
    v14 = 8;
  else
    v14 = WORD2(v29[1]);
  v15 = v14 * HIWORD(v29[1]);
  *((_WORD *)this + 121) = v15;
  *((_WORD *)this + 122) = v12;
  *((_DWORD *)this + 59) = (v15 * (unint64_t)v10 + 7) >> 3;
  *((_DWORD *)this + 81) = 1380401696;
  *((_QWORD *)this + 20) = 0;
  *((_BYTE *)this + 246) = 3;
  if (v15 == 32)
  {
    v16 = 4;
    *((_BYTE *)this + 247) = 4;
  }
  else
  {
    v16 = *((unsigned __int8 *)this + 247);
  }
  v17 = *((unsigned __int8 *)this + 248);
  v18 = *((_BYTE *)this + 249) == 0;
  *((_BYTE *)this + 278) = 3;
  v19 = !v18;
  *((_BYTE *)this + 279) = v16 & 7;
  *((_BYTE *)this + 280) = (((v16 << 12) | (v17 << 16)) >> 16) & 0xF;
  *((_BYTE *)this + 281) = v19;
  *((_BYTE *)this + 350) = 1;
  *((_BYTE *)this + 344) = 0;
  *((_BYTE *)this + 346) = 0;
  if (v13 == 1)
  {
    *((_DWORD *)this + 81) = 1196573017;
    v20 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D970]);
LABEL_29:
    *((_QWORD *)this + 20) = v20;
    goto LABEL_30;
  }
  if (v12 != 2)
  {
    v20 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
    goto LABEL_29;
  }
  memcpy(__dst, &unk_18822B2E0, 0x300uLL);
  v21 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  *((_QWORD *)this + 20) = CGColorSpaceCreateIndexed(v21, 0xFFuLL, (const unsigned __int8 *)__dst);
  CGColorSpaceRelease(v21);
LABEL_30:
  v9 = 0;
  *((_QWORD *)this + 61) = v31;
  v22 = *(_OWORD *)v29;
  *(_OWORD *)((char *)this + 440) = *(_OWORD *)v28;
  *(_OWORD *)((char *)this + 456) = v22;
  *(_OWORD *)((char *)this + 472) = v30;
  *((_QWORD *)this + 45) = 1;
  *((_WORD *)this + 188) = 1;
  return v9;
}

void sub_188017D74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t ICNSReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t ICNSReadPlugin::decode_ic04_ic05(IIOImageReadSession **this, unsigned __int8 *a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 v14;
  char v15;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  int v20;
  unsigned __int8 v21;

  if (a5 == 4)
    return 0;
  if (a5 - 4 >= (unint64_t)IIOImageReadSession::getSize(this[3]))
    return 0;
  v10 = (*((_DWORD *)this + 58) * *((_DWORD *)this + 57));
  if (4 * (_DWORD)v10 != a3)
    return 0;
  v11 = 0;
  v12 = a4 + 4;
  v13 = &a4[a5];
  while (!(_DWORD)v10)
  {
LABEL_22:
    if (++v11 == 4)
      return 0;
  }
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = &a2[byte_18822B5F4[v11]];
  v18 = v10;
  while (!v16)
  {
    if (v12 >= v13)
      return 4294967243;
    v19 = v12 + 1;
    v20 = *v12;
    if (((char)*v12 & 0x80000000) == 0)
    {
      if (v19 >= v13)
        return 4294967243;
      v16 = v20 + 1;
      ++v12;
      goto LABEL_15;
    }
    if (v19 >= v13 || v12 + 2 > v13)
      return 4294967243;
    v16 = v20 - 125;
    v14 = v12[1];
    v15 = 1;
    v12 += 2;
LABEL_21:
    --v16;
    *v17 = v14;
    v17 += 4;
    if (!--v18)
      goto LABEL_22;
  }
  if (v12 > v13)
    return 4294967240;
  if ((v15 & 1) != 0)
  {
    v15 = 1;
    goto LABEL_21;
  }
LABEL_15:
  if (v12 < v13)
  {
    v21 = *v12++;
    v14 = v21;
    if (v12 > v13)
      return 4294967243;
    v15 = 0;
    goto LABEL_21;
  }
  return 4294967239;
}

uint64_t ICNSReadPlugin::decodeImageData(ICNSReadPlugin *this, unsigned __int8 *a2, size_t a3)
{
  unint64_t v6;
  size_t v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  IIOImageRead *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unint64_t Bytes;
  uint64_t v16;
  unint64_t v17;
  int32x4_t v18;
  unint64_t v19;
  int v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  int v24;
  unsigned int v25;
  int v26;
  char *v27;
  char *v28;
  unint64_t v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unint64_t v32;
  unint64_t i;
  int v34;
  int v35;
  unsigned __int8 v36;
  unsigned __int8 v37;
  uint64_t v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  unsigned __int8 v47;
  unsigned __int8 *v48;
  unint64_t v49;
  unsigned __int8 *v50;
  unsigned __int8 v51;
  unint64_t v52;
  unsigned __int8 *v53;
  char v54;
  unsigned __int8 *v55;
  unsigned __int8 v56;
  int v57;
  unint64_t v58;
  unsigned __int8 *v59;
  char *v60;
  char v61;
  char v62;
  unint64_t v63;
  unsigned __int8 *v64;
  char v65;
  __int32 v66;
  unsigned __int8 *v67;
  int32x4_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unsigned __int8 *v72;
  unint64_t v73;
  unsigned __int8 *v74;
  int v75;
  int v76;
  unsigned __int8 v77;
  unsigned __int8 v78;
  int v79;
  uint64_t v81;
  int v82;
  int v83;
  uint64_t v84[2];
  size_t count[2];
  __int128 v86;
  uint64_t v87;
  int8x16_t v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v6 = *((_QWORD *)this + 56);
  v7 = *((_QWORD *)this + 57);
  v8 = *((unsigned __int16 *)this + 232);
  v9 = *((unsigned __int16 *)this + 233);
  v82 = *((unsigned __int16 *)this + 235);
  v83 = *((unsigned __int16 *)this + 234);
  v81 = *((unsigned int *)this + 119);
  v10 = *((_DWORD *)this + 120);
  v11 = *((_DWORD *)this + 121);
  v87 = 0;
  *(_OWORD *)count = 0u;
  v86 = 0u;
  *(_OWORD *)v84 = 0u;
  v12 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1229147731);
  IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v6, 0);
  v13 = (unsigned __int8 *)malloc_type_calloc(v7, 1uLL, 0x55D18D30uLL);
  if (!v13)
    return 4294967246;
  v14 = v13;
  Bytes = IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), v13, v7);
  if (Bytes != v7)
  {
    _cg_jpeg_mem_term("decodeImageData", 425, "*** failed to read imageData (requested %d bytes - got %d)\n", v7, Bytes);
    goto LABEL_73;
  }
  if (*((_DWORD *)this + 118) >> 1 == 884054042)
  {
    v16 = ICNSReadPlugin::decode_ic04_ic05((IIOImageReadSession **)this, a2, a3, v14, v7);
LABEL_150:
    free(v14);
    return v16;
  }
  v17 = v9 * (unint64_t)v8;
  if (GlobalICNSInfo::getICNSMaskInfoForType((uint64_t)v12, v10, (uint64_t)v84))
  {
    if (count[0])
    {
      IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v84[1], 0);
      v19 = count[0];
      if (count[0] < WORD1(count[1]) * (unint64_t)LOWORD(count[1]))
      {
        v20 = v86;
        v21 = (int)v86 >> 24;
        if ((v86 & 0x80000000) != 0)
        {
          v22 = __maskrune(v21, 0x40000uLL);
          v20 = v86;
          v21 = (int)v86 >> 24;
        }
        else
        {
          v22 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v21 + 60) & 0x40000;
        }
        if (v22)
          v42 = v21;
        else
          v42 = 46;
        if (v20 << 8 < 0)
        {
          __maskrune(v20 << 8 >> 24, 0x40000uLL);
          v20 = v86;
        }
        if (v20 << 16 < 0)
        {
          __maskrune((__int16)v20 >> 8, 0x40000uLL);
          v20 = v86;
        }
        if ((v20 << 24) > 0x7F000000)
          __maskrune((char)v20, 0x40000uLL);
        LogError("decodeImageData", 447, "bad ICNS data - invalid size for '%c%c%c%c' (got: %ld  expected: %ld)\n", v42);
        goto LABEL_73;
      }
      v28 = (char *)malloc_type_calloc(count[0], 1uLL, 0xEE7A97DBuLL);
      if (v28)
      {
        v27 = v28;
        v29 = IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), v28, v19);
        if (v29 != v19)
        {
          _cg_jpeg_mem_term("decodeImageData", 454, "*** failed to read deep maskData (requested %d bytes - got %d)\n", v19, v29);
          v30 = 0;
          v16 = 4294967246;
          goto LABEL_148;
        }
        goto LABEL_17;
      }
LABEL_73:
      v16 = 4294967246;
      goto LABEL_150;
    }
LABEL_14:
    v27 = 0;
LABEL_17:
    v30 = 0;
    v23 = 0;
    goto LABEL_21;
  }
  GlobalICNSInfo::getICNSMaskInfoForType((uint64_t)v12, v11, (uint64_t)v84);
  if (!count[0])
    goto LABEL_14;
  IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v84[1], 0);
  v23 = count[0];
  if (count[0] < ((v17 >> 2) & 0x3FFFFFFE))
  {
    v24 = v86;
    v25 = (int)v86 >> 24;
    if ((v86 & 0x80000000) != 0)
    {
      v26 = __maskrune(v25, 0x40000uLL);
      v24 = v86;
      v25 = (int)v86 >> 24;
    }
    else
    {
      v26 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v25 + 60) & 0x40000;
    }
    if (v26)
      v43 = v25;
    else
      v43 = 46;
    if (v24 << 8 < 0)
    {
      __maskrune(v24 << 8 >> 24, 0x40000uLL);
      v24 = v86;
    }
    if (v24 << 16 < 0)
    {
      __maskrune((__int16)v24 >> 8, 0x40000uLL);
      v24 = v86;
    }
    if ((v24 << 24) > 0x7F000000)
      __maskrune((char)v24, 0x40000uLL);
    LogError("decodeImageData", 469, "bad ICNS data - invalid size for '%c%c%c%c' (got: %d  expected: %ld)\n", v43);
    goto LABEL_73;
  }
  v31 = (unsigned __int8 *)malloc_type_calloc(count[0], 1uLL, 0x3975F7E7uLL);
  if (!v31)
    goto LABEL_73;
  v30 = v31;
  v32 = IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), v31, v23);
  if (v32 != v23)
  {
    _cg_jpeg_mem_term("decodeImageData", 476, "*** failed to read 1-bit maskData (requested %d bytes - got %d)\n", v23, v32);
    free(v14);
    v16 = 4294967246;
    v14 = v30;
    goto LABEL_150;
  }
  v27 = 0;
LABEL_21:
  if (v83 != 1)
  {
    if (v82 != 4)
    {
      if (v82 != 2)
        goto LABEL_156;
      if (v83 == 4)
      {
        if (v7 < v17 >> 1)
        {
          LogError("decodeImageData", 528, "corrupted 4-bit icns data");
          goto LABEL_156;
        }
        if (v17 >= 2)
        {
          v38 = v17 >> 1;
          if (v17 >> 1 <= 1)
            v38 = 1;
          v39 = v14;
          v40 = a2;
          do
          {
            v41 = *v39++;
            *v40 = v41 & 0xF0 | (v41 >> 4);
            v40[2] = v41 & 0xF | (16 * v41);
            v40 += 4;
            --v38;
          }
          while (v38);
        }
      }
      else
      {
        if (v7 < v17)
        {
          LogError("decodeImageData", 547, "corrupted icns data, insufficient data for %zu pixels");
          goto LABEL_156;
        }
        if (!v17)
        {
          if (!v30)
            goto LABEL_147;
          goto LABEL_79;
        }
        v44 = v17;
        v45 = v14;
        v46 = a2;
        do
        {
          v47 = *v45++;
          *v46 = v47;
          v46 += 2;
          --v44;
        }
        while (v44);
      }
      if (v30)
      {
LABEL_79:
        if (v17 <= 8 * v23)
        {
          v57 = v23 - (v17 >> 3);
          v58 = (8 * v57);
          if (v17 <= v58)
            v58 = v17;
          else
            _cg_jpeg_mem_term("decodeImageData", 563, "*** Adjusting pixelCount: %d to %d\n", v17, 8 * v57);
          if (v58)
          {
            v63 = 0;
            v64 = a2 + 1;
            do
            {
              if (((v30[(v17 >> 3) + (v63 >> 3)] >> (~(_BYTE)v63 & 7)) & 1) != 0)
                v65 = -1;
              else
                v65 = 0;
              *v64 = v65;
              v64 += 2;
              ++v63;
            }
            while (v58 != v63);
          }
        }
        else
        {
          _cg_jpeg_mem_term("decodeImageData", 573, "[2] maskLen1Bit = %ld   pixelCount = %ld", v23, v17);
        }
        goto LABEL_147;
      }
      if (v17)
      {
        v59 = a2 + 1;
        v60 = v27;
        do
        {
          if (v27)
          {
            v62 = *v60++;
            v61 = v62;
          }
          else
          {
            v61 = -1;
          }
          *v59 = v61;
          v59 += 2;
          --v17;
        }
        while (v17);
      }
LABEL_147:
      v16 = 0;
      if (!v27)
        goto LABEL_149;
      goto LABEL_148;
    }
    if (v30)
    {
      if (v17 <= 8 * v23)
      {
        if (!v17)
        {
          if (!v7)
            goto LABEL_147;
LABEL_117:
          v66 = *((_DWORD *)this + 118);
          if (v66 == 1769222962 || (v67 = v14, v66 == 1768125282))
            v67 = v14 + 4;
          v68 = (int32x4_t)xmmword_18822B2D0;
          v88 = (int8x16_t)xmmword_18822B2D0;
          v69 = 3;
          if (v66 == 1768125282)
            v69 = 4;
          if (*((_BYTE *)this + 405) || v66 == 1768125282)
          {
            v68.i32[0] = 1768125282;
            v18.i32[0] = v66;
            v88 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v18, v68), 0), (int8x16_t)xmmword_18822B2C0, (int8x16_t)xmmword_18820BF90);
          }
          v70 = 0;
          v71 = (unint64_t)&v14[v7];
          do
          {
            if (v17)
            {
              v72 = v67 + 1;
              if ((unint64_t)(v67 + 1) < v71)
              {
                v73 = 0;
                v74 = &a2[v88.i32[v70]];
                do
                {
                  v75 = (char)*v67;
                  if (v75 < 0)
                  {
                    v67 += 2;
                    if (v73 < v17 && (unint64_t)v67 <= v71)
                    {
                      v78 = *v72;
                      v79 = v75 - 125;
                      do
                      {
                        *v74 = v78;
                        v74 += 4;
                        --v79;
                        ++v73;
                      }
                      while ((_BYTE)v79 && v73 < v17);
                    }
                  }
                  else if (v73 >= v17 || (unint64_t)v72 >= v71)
                  {
                    v67 = v72;
                  }
                  else
                  {
                    v76 = v75 + 1;
                    v67 = v72;
                    do
                    {
                      v77 = *v67++;
                      *v74 = v77;
                      v74 += 4;
                      --v76;
                      ++v73;
                    }
                    while ((_BYTE)v76 && v73 < v17 && (unint64_t)v67 < v71);
                  }
                  if (v73 >= v17)
                    break;
                  v72 = v67 + 1;
                }
                while ((unint64_t)(v67 + 1) < v71);
              }
            }
            ++v70;
          }
          while (v70 != v69);
          goto LABEL_147;
        }
        v52 = 0;
        v53 = a2 + 3;
        do
        {
          if (((v30[(v17 >> 3) + (v52 >> 3)] >> (~(_BYTE)v52 & 7)) & 1) != 0)
            v54 = -1;
          else
            v54 = 0;
          *v53 = v54;
          v53 += 4;
          ++v52;
        }
        while (v17 != v52);
      }
      else
      {
        _cg_jpeg_mem_term("decodeImageData", 605, "[4] maskLen1Bit = %ld   pixelCount = %ld", v23, v17);
      }
    }
    else if (v27 && v17)
    {
      v48 = a2 + 3;
      v49 = v17;
      v50 = (unsigned __int8 *)v27;
      do
      {
        v51 = *v50++;
        *v48 = v51;
        v48 += 4;
        --v49;
      }
      while (v49);
    }
    if (v7 == 4 * v17)
    {
      if (v17)
      {
        v55 = v14 + 3;
        do
        {
          *a2 = *(v55 - 2);
          a2[1] = *(v55 - 1);
          v56 = *v55;
          v55 += 4;
          a2[2] = v56;
          a2 += 4;
          --v17;
        }
        while (v17);
      }
      goto LABEL_147;
    }
    goto LABEL_117;
  }
  bzero(a2, a3);
  if ((uint64_t)(v17 >> 3) > (uint64_t)v7)
  {
    LogError("decodeImageData", 499, "corrupted 1-bit icns data");
  }
  else
  {
    if (v7 == v81)
    {
      if (v17)
      {
        for (i = 0; i != v17; ++i)
        {
          v34 = v14[(v17 >> 3) + (i >> 3)];
          v35 = 1 << (~(_BYTE)i & 7);
          if ((v35 & v14[i >> 3]) != 0)
            v36 = 0;
          else
            v36 = -1;
          *a2 = v36;
          if ((v35 & v34) != 0)
            v37 = -1;
          else
            v37 = 0;
          a2[1] = v37;
          a2 += 2;
        }
      }
      goto LABEL_147;
    }
    LogError("decodeImageData", 500, "corrupted 1-bit icns data");
  }
LABEL_156:
  v16 = 4294967246;
  if (v27)
LABEL_148:
    free(v27);
LABEL_149:
  free(v14);
  v14 = v30;
  if (v30)
    goto LABEL_150;
  return v16;
}

uint64_t ICNSReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  IIOImageRead **v20;
  _BOOL4 v21;
  void *BaseAddress;
  size_t Height;
  size_t v24;
  double v25;
  uint64_t BlockArray;
  double v27;
  unint64_t v28;
  unsigned int v29;
  uint64_t v30;
  vImagePixelCount v31;
  size_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  double v37;
  const char **v38;
  vImage_Buffer dest;
  size_t v41;
  CGRect v42;
  CGRect v43;

  v41 = 0;
  if ((gIIODebugFlags & 0x20000) == 0)
    goto LABEL_26;
  v8 = *((_DWORD *)this + 51);
  v9 = v8 >> 24;
  v10 = MEMORY[0x1E0C80978];
  if (v8 < 0)
  {
    v11 = __maskrune(v9, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
  }
  if (v11)
    v12 = (v8 >> 24);
  else
    v12 = 46;
  v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    v14 = __maskrune(v13, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14)
    v15 = (v8 << 8 >> 24);
  else
    v15 = 46;
  v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    v17 = __maskrune(v16, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17)
    v18 = ((__int16)v8 >> 8);
  else
    v18 = 46;
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
      goto LABEL_22;
LABEL_24:
    v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL))
    goto LABEL_24;
LABEL_22:
  v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus ICNSReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v20 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v20)
    v21 = IIOImageReadSession::mapData(v20);
  else
    v21 = 0;
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    v27 = (double)v28;
    v29 = *((_DWORD *)this + 74);
    v25 = (double)v29;
    v24 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v24, *((_QWORD *)this + 48), &v41, (uint64_t)kImageMalloc_ICNS_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      BlockArray = 1;
      goto LABEL_46;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    v24 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v41 = v24;
    v25 = 0.0;
    BlockArray = 1;
    v27 = 0.0;
  }
  if (BaseAddress)
  {
    bzero(BaseAddress, v24);
    v30 = (*(uint64_t (**)(IIOReadPlugin *, void *, size_t))(*(_QWORD *)this + 112))(this, BaseAddress, v24);
    if ((_DWORD)v30)
    {
      BlockArray = v30;
      if (a3 == 3)
        _ImageIO_Free((unint64_t)BaseAddress, v41);
    }
    else
    {
      if (*((_BYTE *)this + 406) == 1)
      {
        v31 = *((unsigned int *)this + 74);
        dest.data = BaseAddress;
        dest.height = v31;
        v32 = *((unsigned int *)this + 75);
        dest.width = *((unsigned int *)this + 73);
        dest.rowBytes = v32;
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
      }
      if (a3 == 3)
      {
        v33 = 0;
        v42.origin.x = 0.0;
        v42.origin.y = 0.0;
        v42.size.width = v27;
        v42.size.height = v25;
        **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v24, v42, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
        if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
        {
          v34 = 0;
        }
        else
        {
          v43.origin.x = 0.0;
          v43.origin.y = 0.0;
          v43.size.width = v27;
          v43.size.height = v25;
          *(CGRect *)(&v34 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v43);
          v33 = v35;
          v27 = v36;
          v25 = v37;
        }
        BlockArray = 0;
        *((_QWORD *)this + 15) = v33;
        *((_QWORD *)this + 16) = v34;
        *((double *)this + 17) = v27;
        *((double *)this + 18) = v25;
      }
      else
      {
        IOSurfaceUnlock(*a4, 0, 0);
        BlockArray = 0;
      }
    }
  }
LABEL_46:
  if (v21)
  {
    v38 = (const char **)*((_QWORD *)this + 3);
    if (v38)
      IIOImageReadSession::unmapData(v38);
  }
  return BlockArray;
}

void _JPEGFile::_JPEGFile(_JPEGFile *this, CFDataRef theData, char a3, char a4)
{
  *(_QWORD *)this = &off_1E1BB30A8;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 3) = CFDataGetBytePtr(theData);
  *((_QWORD *)this + 4) = CFDataGetLength(theData);
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 96) = a3;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_BYTE *)this + 50) = __PAIR64__(*(unsigned __int8 *)(*((_QWORD *)this + 3) + 1), **((unsigned __int8 **)this + 3)) == 0xD8000000FFLL;
  *((_BYTE *)this + 51) = 0;
  *((_BYTE *)this + 48) = 0;
  *((_BYTE *)this + 49) = a4;
}

void sub_188018D78(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 80) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void _JPEGFile::_JPEGFile(_JPEGFile *this, unsigned __int8 *a2, uint64_t a3, char a4, char a5)
{
  *(_QWORD *)this = &off_1E1BB30A8;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 3) = a2;
  *((_QWORD *)this + 4) = a3;
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 96) = a4;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_BYTE *)this + 50) = __PAIR64__(a2[1], *a2) == 0xD8000000FFLL;
  *((_BYTE *)this + 51) = 0;
  *((_BYTE *)this + 48) = 0;
  *((_BYTE *)this + 49) = a5;
}

void _JPEGFile::~_JPEGFile(_JPEGFile *this)
{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = &off_1E1BB30A8;
  v2 = (_QWORD *)*((_QWORD *)this + 9);
  v3 = (_QWORD *)*((_QWORD *)this + 10);
  if (v2 != v3)
  {
    do
    {
      if (*v2)
        (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 8))(*v2);
      ++v2;
    }
    while (v2 != v3);
    v2 = (_QWORD *)*((_QWORD *)this + 9);
  }
  if (v2)
  {
    *((_QWORD *)this + 10) = v2;
    operator delete(v2);
  }
}

{
  _JPEGFile::~_JPEGFile(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _JPEGFile::findAppMarker(_JPEGFile *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *((_QWORD *)this + 9);
  v3 = *((_QWORD *)this + 10);
  while (v2 != v3)
  {
    result = *(_QWORD *)v2;
    if (*(unsigned __int16 *)(*(_QWORD *)v2 + 56) == a2)
      return result;
    v2 += 8;
  }
  return 0;
}

uint64_t _JPEGFile::appMarkerAtIndex(_JPEGFile *this, int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 9);
  if (a2 >= (unint64_t)((*((_QWORD *)this + 10) - v2) >> 3))
    return 0;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

uint64_t _JPEGFile::findApp1ExifMarker(_JPEGFile *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;

  v1 = *((_QWORD *)this + 9);
  v2 = *((_QWORD *)this + 10);
  while (v1 != v2)
  {
    result = *(_QWORD *)v1;
    if (*(__int16 *)(*(_QWORD *)v1 + 56) == -31 && *(_BYTE *)(result + 68))
      return result;
    v1 += 8;
  }
  return 0;
}

void _JPEGFile::mergeWithFile(_JPEGFile *this, _JPEGFile *a2)
{
  _APPx **v4;
  _APPx **v5;
  _APPx *v6;
  uint64_t v7;
  uint64_t v8;
  _APP1 **i;
  _APP1 *v10;
  _APP1 **v11;
  _APP1 **v12;
  _APP1 *v13;

  if (a2)
  {
    v4 = (_APPx **)*((_QWORD *)a2 + 9);
    v5 = (_APPx **)*((_QWORD *)a2 + 10);
    while (v4 != v5)
    {
      v6 = *v4;
      v7 = *((_QWORD *)this + 9);
      v8 = *((_QWORD *)this + 10);
      if (v7 == v8)
      {
LABEL_7:
        _JPEGFile::insertAppMarker(this, *v4);
        *((_BYTE *)v6 + 8) |= 0x10u;
        _JPEGFile::removeAppMarker((uint64_t)a2, (uint64_t)v6);
      }
      else
      {
        while (*(unsigned __int16 *)(*(_QWORD *)v7 + 56) != *((unsigned __int16 *)v6 + 28))
        {
          v7 += 8;
          if (v7 == v8)
            goto LABEL_7;
        }
      }
      ++v4;
    }
    for (i = (_APP1 **)*((_QWORD *)this + 9); i != *((_APP1 ***)this + 10); ++i)
    {
      v10 = *i;
      if (*((__int16 *)*i + 28) == -31 && *((_BYTE *)v10 + 68))
        goto LABEL_15;
    }
    v10 = 0;
LABEL_15:
    v11 = (_APP1 **)*((_QWORD *)a2 + 9);
    v12 = (_APP1 **)*((_QWORD *)a2 + 10);
    while (v11 != v12)
    {
      v13 = *v11;
      if (*((__int16 *)*v11 + 28) == -31 && *((_BYTE *)v13 + 68))
      {
        if (!v10)
        {
          v10 = (_APP1 *)operator new();
          _APP1::_APP1(v10, 0xFFE1u, *((_BYTE *)this + 96));
          _JPEGFile::insertAppMarker(this, v10);
        }
        *((_BYTE *)v10 + 8) |= 0x20u;
        _APP1::mergeWithApp1(v10, v13);
        return;
      }
      ++v11;
    }
  }
}

void sub_188019064(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C401EC73DA2);
  _Unwind_Resume(a1);
}

char *_JPEGFile::insertAppMarker(_JPEGFile *this, _APPx *a2)
{
  char *v3;
  char *v4;
  char *v5;
  unint64_t v6;
  unsigned int v7;
  unint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  _APPx *v13;

  v13 = a2;
  v5 = (char *)*((_QWORD *)this + 9);
  v4 = (char *)*((_QWORD *)this + 10);
  v3 = (char *)this + 72;
  if (v4 != v5)
  {
    v6 = (v4 - v5) >> 3;
    v7 = *((unsigned __int16 *)a2 + 29);
    do
    {
      v8 = v6 >> 1;
      v9 = &v5[8 * (v6 >> 1)];
      v11 = *(_QWORD *)v9;
      v10 = v9 + 8;
      v6 += ~(v6 >> 1);
      if (*(unsigned __int16 *)(v11 + 58) <= v7)
        v5 = v10;
      else
        v6 = v8;
    }
    while (v6);
    v4 = v5;
  }
  return std::vector<_APPx *>::insert((uint64_t)v3, v4, (char *)&v13);
}

uint64_t _JPEGFile::removeAppMarker(uint64_t result, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;

  v3 = *(_QWORD **)(result + 72);
  v2 = *(_QWORD **)(result + 80);
  if (v3 != v2)
  {
    while (*v3 != a2)
    {
      if (++v3 == v2)
        return result;
    }
    if (v3 != v2)
    {
      v4 = v3 + 1;
      if (v3 + 1 != v2)
      {
        do
        {
          if (*v4 != a2)
            *v3++ = *v4;
          ++v4;
        }
        while (v4 != v2);
        v2 = *(_QWORD **)(result + 80);
      }
    }
    if (v3 != v2)
      *(_QWORD *)(result + 80) = v3;
  }
  return result;
}

_TAGList *_JPEGFile::copyThumbnail(_TAGList *this, _JPEGFile *a2)
{
  uint64_t v2;
  _TAGList **j;
  unsigned int *TagByID;
  _TAGList *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  BOOL v12;
  _TAGList **i;
  _TAGList *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _APP1 **k;
  _APP1 *v19;

  v2 = (uint64_t)this;
  if (!a2)
  {
    TagByID = 0;
    v6 = 0;
LABEL_26:
    for (i = *(_TAGList ***)(v2 + 72); i != *(_TAGList ***)(v2 + 80); ++i)
    {
      this = *i;
      if (*((__int16 *)*i + 28) == -31 && *((_BYTE *)this + 68))
      {
        this = (_TAGList *)(*(uint64_t (**)(_TAGList *))(*(_QWORD *)this + 48))(this);
        if (this)
        {
          v14 = this;
          TagByID = (unsigned int *)_TAGList::findTagByID(this, 513);
          this = (_TAGList *)_TAGList::findTagByID(v14, 514);
          v6 = this;
        }
        goto LABEL_33;
      }
    }
    goto LABEL_33;
  }
  for (j = (_TAGList **)*((_QWORD *)a2 + 9); ; ++j)
  {
    if (j == *((_TAGList ***)a2 + 10))
    {
      TagByID = 0;
      v6 = 0;
      goto LABEL_8;
    }
    this = *j;
    if (*((__int16 *)*j + 28) == -31)
    {
      if (*((_BYTE *)this + 68))
        break;
    }
  }
  this = (_TAGList *)(*(uint64_t (**)(_TAGList *))(*(_QWORD *)this + 48))(this);
  v6 = this;
  if (this)
  {
    TagByID = (unsigned int *)_TAGList::findTagByID(this, 513);
    this = (_TAGList *)_TAGList::findTagByID(v6, 514);
    v6 = this;
    if (TagByID)
      v12 = this == 0;
    else
      v12 = 1;
    if (!v12)
      goto LABEL_24;
  }
  else
  {
    TagByID = 0;
  }
LABEL_8:
  v7 = *((_QWORD *)a2 + 9);
  v8 = *((_QWORD *)a2 + 10);
  if (v7 != v8)
  {
    v9 = *((_QWORD *)a2 + 9);
    while (1)
    {
      v10 = *(_QWORD **)v9;
      if (*(__int16 *)(*(_QWORD *)v9 + 56) == -64)
        break;
      v9 += 8;
      if (v9 == v8)
      {
        while (1)
        {
          v10 = *(_QWORD **)v7;
          if (*(__int16 *)(*(_QWORD *)v7 + 56) == -37)
            goto LABEL_15;
          v7 += 8;
          if (v7 == v8)
            goto LABEL_24;
        }
      }
    }
LABEL_15:
    if ((*(unsigned int (**)(_QWORD *))(*v10 + 24))(v10) >> 6 <= 0x270)
    {
      *(_QWORD *)(v2 + 56) = v10[5] + v10[2];
      this = (_TAGList *)(*(uint64_t (**)(_QWORD *))(*v10 + 24))(v10);
      goto LABEL_36;
    }
    v11 = (*(uint64_t (**)(_QWORD *))(*v10 + 24))(v10);
    this = (_TAGList *)LogError("copyThumbnail", 292, "*** ERROR: skipping thumbnail -- too big [%d bytes]\n", v11);
  }
LABEL_24:
  if (!TagByID || !v6)
    goto LABEL_26;
LABEL_33:
  if (TagByID && v6)
  {
    v15 = *(_QWORD *)(v2 + 24);
    *(_QWORD *)(v2 + 56) = v15 + _TAG::nativeDataOrOffset((_TAG *)TagByID) + TagByID[7];
    this = (_TAGList *)_TAG::nativeDataOrOffset(v6);
LABEL_36:
    *(_DWORD *)(v2 + 64) = (_DWORD)this;
  }
  v16 = *(_QWORD *)(v2 + 56);
  if (v16)
  {
    v17 = *(unsigned int *)(v2 + 64);
    if ((_DWORD)v17)
    {
      for (k = *(_APP1 ***)(v2 + 72); k != *(_APP1 ***)(v2 + 80); ++k)
      {
        v19 = *k;
        if (*((__int16 *)*k + 28) == -31 && *((_BYTE *)v19 + 68))
          return (_TAGList *)(*(uint64_t (**)(_APP1 *, uint64_t, uint64_t))(*(_QWORD *)v19 + 56))(v19, v16, v17);
      }
      v19 = (_APP1 *)operator new();
      _APP1::_APP1(v19, 0xFFE1u, *(_BYTE *)(v2 + 96));
      _JPEGFile::insertAppMarker((_JPEGFile *)v2, v19);
      v16 = *(_QWORD *)(v2 + 56);
      v17 = *(unsigned int *)(v2 + 64);
      return (_TAGList *)(*(uint64_t (**)(_APP1 *, uint64_t, uint64_t))(*(_QWORD *)v19 + 56))(v19, v16, v17);
    }
  }
  return this;
}

void sub_188019448(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C401EC73DA2);
  _Unwind_Resume(a1);
}

CGImageMetadata *_JPEGFile::copyXMPProperties(_JPEGFile *this)
{
  unsigned int v1;
  uint64_t v2;
  unint64_t v4;
  unsigned int Length;
  uint64_t v6;
  IIOImageSource *v7;
  const __CFData *v8;
  const __CFData *v9;
  const __CFData *v10;
  const __CFData *GUID;
  const UInt8 *v12;
  unsigned int TotalXMPLength;
  int XmpOffset;
  unsigned int v15;
  unsigned int v16;
  const UInt8 *v17;
  CGImageMetadata *MetadataFromExtendedXMPData;
  CGImageMetadata *result;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  const char *BytePtr;
  __int128 v24;
  __int128 v25;

  v24 = 0u;
  v25 = 0u;
  v1 = *((_DWORD *)this + 20) - *((_DWORD *)this + 18);
  v2 = (unsigned __int16)(v1 >> 3);
  if (!(unsigned __int16)(v1 >> 3))
    return 0;
  v4 = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  Length = 0;
  BytePtr = 0;
  do
  {
    v6 = *((_QWORD *)this + 9);
    if (v4 >= (*((_QWORD *)this + 10) - v6) >> 3)
      v7 = 0;
    else
      v7 = *(IIOImageSource **)(v6 + 8 * v4);
    if (*((_BYTE *)v7 + 69))
    {
      v8 = (const __CFData *)IIOImageSource::reader(v7);
      if (v8)
      {
        v9 = v8;
        BytePtr = (const char *)CFDataGetBytePtr(v8);
        Length = CFDataGetLength(v9);
      }
    }
    else
    {
      if (!*((_BYTE *)v7 + 70))
        goto LABEL_21;
      v10 = (const __CFData *)IIOImageSource::reader(v7);
      GUID = (const __CFData *)_APP1ExtendedXMP::getGUID(v7);
      v12 = CFDataGetBytePtr(GUID);
      TotalXMPLength = _APP1ExtendedXMP::getTotalXMPLength(v7);
      XmpOffset = _APP1ExtendedXMP::getXmpOffset(v7);
      v15 = CFDataGetLength(v10);
      if (GUID)
      {
        v16 = v15;
        if (CFDataGetLength(GUID) == 32)
        {
          if ((v22 & 0x100000000) == 0)
          {
            v24 = *(_OWORD *)v12;
            v25 = *((_OWORD *)v12 + 1);
            LODWORD(v22) = TotalXMPLength;
            v21 = (char *)malloc_type_calloc(1uLL, TotalXMPLength, 0x78D15197uLL);
            if (!v21)
            {
              v21 = 0;
              BYTE4(v22) = 0;
              goto LABEL_18;
            }
          }
          BYTE4(v22) = 1;
          if (!((unint64_t)v24 ^ *(_QWORD *)v12 | *((_QWORD *)&v24 + 1) ^ *((_QWORD *)v12 + 1) | (unint64_t)v25 ^ *((_QWORD *)v12 + 2) | *((_QWORD *)&v25 + 1) ^ *((_QWORD *)v12 + 3))
            && TotalXMPLength == (_DWORD)v22
            && XmpOffset + v16 <= v22)
          {
            v17 = CFDataGetBytePtr(v10);
            memcpy(&v21[XmpOffset], v17, v16);
            v20 += v16;
            BYTE4(v22) = 1;
LABEL_18:
            LODWORD(v22) = TotalXMPLength;
          }
        }
        else
        {
          LogError("copyXMPProperties", 396, "*** ERROR: Extended XMP marker GUID length is not 32, skipping marker\n", v20);
        }
      }
      else
      {
        LogError("copyXMPProperties", 401, "*** ERROR: Extended XMP marker GUID data is NULL, skipping marker\n", v20);
      }
    }
LABEL_21:
    ++v4;
  }
  while (v2 != v4);
  if (v21 && (_DWORD)v22 && v20 == v22 && BytePtr && Length)
  {
    MetadataFromExtendedXMPData = CreateMetadataFromExtendedXMPData(BytePtr, Length, v21, v20);
    goto LABEL_36;
  }
  if (!BytePtr || !Length)
  {
    MetadataFromExtendedXMPData = 0;
    result = 0;
    if (!v21)
      return result;
    goto LABEL_36;
  }
  result = CreateMetadataFromXMPBuffer(BytePtr, Length);
  MetadataFromExtendedXMPData = result;
  if (v21)
  {
LABEL_36:
    free(v21);
    return MetadataFromExtendedXMPData;
  }
  return result;
}

void _JPEGFile::setXMPProperties(_JPEGFile *this, CFDictionaryRef *a2)
{
  unsigned int v3;
  int v4;
  int v5;
  uint64_t v6;
  _BYTE *v7;
  CFIndex Length;
  _APP1XMP *v9;
  CFTypeRef v10;
  CFIndex v11;
  const UInt8 *BytePtr;
  const UInt8 *v13;
  CFIndex v14;
  const __CFAllocator *v15;
  uint64_t v16;
  CFIndex v17;
  const __CFData *v18;
  _APP1ExtendedXMP *v19;
  CFTypeRef v20;
  CFTypeRef cf;
  CFDataRef theData;

  cf = 0;
  theData = 0;
  v20 = 0;
  CGImageMetadataCreateSerializedDataAndExtendedData(a2, &theData, (CFDataRef *)&cf, (CFDataRef *)&v20);
  v3 = *((_DWORD *)this + 20) - *((_DWORD *)this + 18);
  v4 = (unsigned __int16)(v3 >> 3);
  if ((unsigned __int16)(v3 >> 3))
  {
    v5 = 0;
    do
    {
      v6 = *((_QWORD *)this + 9);
      if (v5 >= (unint64_t)((*((_QWORD *)this + 10) - v6) >> 3))
        v7 = 0;
      else
        v7 = *(_BYTE **)(v6 + 8 * v5);
      if (v7[69] || v7[70])
      {
        _JPEGFile::removeAppMarker((uint64_t)this, (uint64_t)v7);
        --v5;
        --v4;
        (*(void (**)(_BYTE *))(*(_QWORD *)v7 + 8))(v7);
      }
      ++v5;
    }
    while (v5 < v4);
  }
  if (theData && CFDataGetLength(theData) >= 65501)
  {
    Length = CFDataGetLength(theData);
    LogError("setXMPProperties", 473, "*** ERROR: xmpData size exceeds 64KB limit (%ld)\n", Length);
    CFRelease(theData);
    theData = 0;
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
  }
  else
  {
    v9 = (_APP1XMP *)operator new();
    _APP1XMP::_APP1XMP(v9, theData);
    _JPEGFile::insertAppMarker(this, v9);
    if (theData)
      CFRelease(theData);
    theData = 0;
    v10 = cf;
    if (cf && v20)
    {
      v11 = CFDataGetLength((CFDataRef)cf);
      BytePtr = CFDataGetBytePtr((CFDataRef)cf);
      if (v11 >= 1)
      {
        v13 = BytePtr;
        v14 = 0;
        v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v16 = v11;
        do
        {
          if (v16 >= 65000)
            v17 = 65000;
          else
            v17 = v16;
          v18 = CFDataCreate(v15, &v13[v14], v17);
          v19 = (_APP1ExtendedXMP *)operator new();
          _APP1ExtendedXMP::_APP1ExtendedXMP(v19, v18, v14, v11, (const __CFData *)v20);
          CFRelease(v18);
          _JPEGFile::insertAppMarker(this, v19);
          v14 += 65000;
          v16 -= 65000;
        }
        while (v14 < v11);
      }
      v10 = cf;
    }
    if (v10)
      CFRelease(v10);
  }
  if (v20)
    CFRelease(v20);
}

void sub_188019988(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C4027C9E144);
  _Unwind_Resume(a1);
}

IIODictionary *_JPEGFile::copyIPTCProperties(_JPEGFile *this)
{
  IIODictionary *v2;
  unsigned int v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  IIODictionary *v8;
  const __CFDictionary *ObjectForKey;

  v2 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v2);
  v3 = *((_DWORD *)this + 20) - *((_DWORD *)this + 18);
  v4 = (unsigned __int16)(v3 >> 3);
  if ((unsigned __int16)(v3 >> 3))
  {
    v5 = 0;
    do
    {
      v6 = *((_QWORD *)this + 9);
      if (v5 < (*((_QWORD *)this + 10) - v6) >> 3)
      {
        v7 = *(_QWORD *)(v6 + 8 * v5);
        if (v7)
        {
          if (*(__int16 *)(v7 + 56) == -19)
          {
            v8 = *(IIODictionary **)(v7 + 152);
            if (v8)
            {
              ObjectForKey = IIODictionary::getObjectForKey(v8, CFSTR("{IPTC}"));
              if (ObjectForKey)
                IIODictionary::appendDictionary(v2, ObjectForKey);
            }
          }
        }
      }
      ++v5;
    }
    while (v4 != v5);
  }
  return v2;
}

void sub_188019A84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t _JPEGFile::setICCProfile(_JPEGFile *this, CFDataRef theData)
{
  unsigned int v4;
  int v5;
  int v6;
  _BYTE *v7;
  CFIndex Length;
  unint64_t v9;
  CFIndex v10;
  const UInt8 *BytePtr;
  const UInt8 *v12;
  uint64_t v13;
  unint64_t v14;
  BOOL v15;
  const __CFAllocator *v16;
  uint64_t v17;
  unsigned __int8 v18;
  CFIndex v19;
  CFDataRef v20;
  const __CFData *v21;
  _APP2ICC *v22;
  unint64_t v24;

  v4 = *((_DWORD *)this + 20) - *((_DWORD *)this + 18);
  v5 = (unsigned __int16)(v4 >> 3);
  if ((unsigned __int16)(v4 >> 3))
  {
    v6 = 0;
    do
    {
      v7 = *(_BYTE **)(*((_QWORD *)this + 9) + 8 * v6);
      if (v7[71])
      {
        _JPEGFile::removeAppMarker((uint64_t)this, *(_QWORD *)(*((_QWORD *)this + 9) + 8 * v6--));
        --v5;
        (*(void (**)(_BYTE *))(*(_QWORD *)v7 + 8))(v7);
      }
      ++v6;
    }
    while (v6 < v5);
  }
  if (!theData)
    return 0;
  Length = CFDataGetLength(theData);
  v9 = Length + 65518;
  if ((unint64_t)(Length + 65518) >= 0xFFEF00)
  {
    LogError("setICCProfile", 590, "*** ERROR: iccData exceeds maximum size of %d bytes\n", 16707345);
    return 0;
  }
  v10 = Length;
  BytePtr = CFDataGetBytePtr(theData);
  if (v9 >= 0xFFEF)
  {
    v12 = BytePtr;
    v13 = 0;
    v14 = v9 / 0xFFEF;
    v15 = v9 / 0xFFEF > 1;
    v24 = v9 / 0xFFEF - 1;
    v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v15)
      v17 = v14;
    else
      v17 = 1;
    v18 = v14;
    do
    {
      if (v24 == v13)
        v19 = v10;
      else
        v19 = 65519;
      v20 = CFDataCreate(v16, v12, v19);
      if (!v20)
        break;
      v21 = v20;
      v22 = (_APP2ICC *)operator new();
      _APP2ICC::_APP2ICC(v22, v21, v13 + 1, v18);
      v12 += v19;
      _JPEGFile::insertAppMarker(this, v22);
      CFRelease(v21);
      ++v13;
      v10 -= 65519;
    }
    while (v17 != v13);
  }
  return 1;
}

void sub_188019C7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C406AB96B01);
  _Unwind_Resume(a1);
}

uint64_t _JPEGFile::addMissingIFDTags(_JPEGFile *this)
{
  _APP1 **i;
  _APP1 *v3;
  unsigned int v5;
  unsigned int v6[2];

  for (i = (_APP1 **)*((_QWORD *)this + 9); i != *((_APP1 ***)this + 10); ++i)
  {
    v3 = *i;
    if (*((__int16 *)*i + 28) == -31 && *((_BYTE *)v3 + 68))
      goto LABEL_7;
  }
  v3 = (_APP1 *)operator new();
  _APP1::_APP1(v3, 0xFFE1u, *((_BYTE *)this + 96));
  _JPEGFile::insertAppMarker(this, v3);
LABEL_7:
  *(_QWORD *)v6 = 0;
  v5 = 0;
  _JPEGFile::getImageDimension(this, &v6[1], v6, &v5);
  return (*(uint64_t (**)(_APP1 *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v3 + 64))(v3, v6[1], v6[0], v5);
}

void sub_188019D58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C401EC73DA2);
  _Unwind_Resume(a1);
}

_QWORD *_JPEGFile::getImageDimension(_QWORD *this, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = this[9];
  v5 = this[10];
  if (v4 != v5)
  {
    v6 = this[9];
    while (1)
    {
      this = *(_QWORD **)v6;
      if (*(__int16 *)(*(_QWORD *)v6 + 56) == -64)
        break;
      v6 += 8;
      if (v6 == v5)
      {
        while (1)
        {
          this = *(_QWORD **)v4;
          if (*(__int16 *)(*(_QWORD *)v4 + 56) == -37)
            break;
          v4 += 8;
          if (v4 == v5)
            return this;
        }
        return (_QWORD *)(*(uint64_t (**)(_QWORD *, unsigned int *, unsigned int *, unsigned int *))(*this + 72))(this, a2, a3, a4);
      }
    }
    return (_QWORD *)(*(uint64_t (**)(_QWORD *, unsigned int *, unsigned int *, unsigned int *))(*this + 72))(this, a2, a3, a4);
  }
  return this;
}

char *std::vector<_APPx *>::insert(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = std::vector<_APPx *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_188019FE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

__n128 _JPEGFile::processData(_JPEGFile *this)
{
  __n128 result;
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _APP0 *v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  const char *v19;
  _APPx *v20;
  unsigned int v21;
  uint64_t v22;
  const char *v23;
  size_t v24;
  _APP2ICC *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  _APPData *v31;

  std::vector<_APPx *>::resize((uint64_t)this + 72, 0);
  *((_QWORD *)this + 5) = 0;
  v3 = *((_QWORD *)this + 4);
  if (v3 <= 1)
    goto LABEL_9;
  v4 = (unsigned __int16 *)*((_QWORD *)this + 3);
  v5 = __rev16(*v4);
  *((_QWORD *)this + 5) = 2;
  if (*((_BYTE *)this + 48))
    v6 = 0;
  else
    v6 = v5 == 65496;
  if (!v6)
    return result;
  if ((unint64_t)v3 <= 3 || (v7 = v4[1], *((_QWORD *)this + 5) = 4, (unint64_t)v3 <= 5))
  {
LABEL_9:
    *((_BYTE *)this + 48) = 1;
    return result;
  }
  v8 = __rev16(v4[2]);
  *((_QWORD *)this + 5) = 6;
  if (v8 <= 1)
    return _cg_jpeg_mem_term("processData", 692, "*** ERROR: markerLength too small (%d)\n");
  v9 = bswap32(v7) >> 16;
  v10 = v3 - 10;
  if (v10 <= v8)
    LogWarning("processData", 695, "*** WARNING: check markerLength: %d - expected max: %d\n", v8, v10);
  *((_QWORD *)this + 5) = 4;
  if (v9 >> 8 >= 0xFF)
  {
    LODWORD(v11) = 2;
    v12 = 4;
    LODWORD(v13) = 4;
    while (1)
    {
      switch((__int16)v9)
      {
        case -64:
        case -63:
        case -62:
        case -61:
        case -60:
        case -59:
        case -58:
        case -57:
        case -37:
        case -35:
          v30 = *((_QWORD *)this + 4);
          v31 = (_APPData *)operator new();
          _APPData::_APPData(v31, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, (unsigned __int16)v9, v30 - v11, *((_BYTE *)this + 96));
          (*(void (**)(_APPData *))(*(_QWORD *)v31 + 16))(v31);
          _JPEGFile::insertAppMarker(this, v31);
          *((_QWORD *)this + 5) = v30;
          return result;
        case -56:
        case -55:
        case -54:
        case -53:
        case -52:
        case -51:
        case -50:
        case -49:
        case -48:
        case -47:
        case -46:
        case -45:
        case -44:
        case -43:
        case -42:
        case -41:
        case -40:
        case -38:
        case -36:
        case -34:
        case -33:
          goto LABEL_21;
        case -39:
          return result;
        case -32:
          v14 = v8 + 2;
          v15 = (_APP0 *)operator new();
          _APP0::_APP0(v15, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, 65504, v14, *((_BYTE *)this + 96));
          goto LABEL_36;
        case -31:
          v16 = v8 + 2;
          v17 = (v13 + 2);
          if (*((_QWORD *)this + 4) - 4 <= v17)
          {
            if (v8 == 2)
              goto LABEL_38;
            _cg_jpeg_mem_term("processData", 776, "*** WARNING: APP1 marker with unknown signature, does not match EXIF, XMP, or Extended XMP. (size:%d marker: %d)\n", 0, v8 + 2);
            v20 = (_APPx *)operator new();
            _APPx::_APPx(v20, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, 0xFFE1u, v16, *((_BYTE *)this + 96));
          }
          else
          {
            v18 = v8 - 2;
            if (v8 - 2 < 4)
              goto LABEL_38;
            v19 = (const char *)(*((_QWORD *)this + 3) + v17);
            if (!strncmp(v19, "Exif", 4uLL))
            {
              v20 = (_APPx *)operator new();
              _APP1::_APP1(v20, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, 65505, v16, *((_BYTE *)this + 96));
            }
            else
            {
              if (v18 < 0x1C)
                goto LABEL_38;
              if (!strncmp(v19, "http://ns.adobe.com/xap/1.0/", 0x1CuLL))
              {
                v20 = (_APPx *)operator new();
                _APP1XMP::_APP1XMP(v20, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, 65505, v16, *((_BYTE *)this + 96));
                *((_BYTE *)v20 + 69) = 1;
              }
              else
              {
                if (v18 < 0x22 || strncmp(v19, "http://ns.adobe.com/xmp/extension/", 0x22uLL))
                {
LABEL_38:
                  result = _cg_jpeg_mem_term("processData", 783, "*** ERROR: unknown APP1 marker - skipping\n");
                  goto LABEL_47;
                }
                v20 = (_APPx *)operator new();
                _APP1ExtendedXMP::_APP1ExtendedXMP(v20, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, 65505, v16, *((_BYTE *)this + 96));
              }
            }
          }
          (*(void (**)(_APPx *))(*(_QWORD *)v20 + 16))(v20);
          _JPEGFile::insertAppMarker(this, v20);
LABEL_47:
          v11 = v16 + v11;
LABEL_48:
          *((_QWORD *)this + 5) = v11;
          v26 = *((_QWORD *)this + 4);
          if (v11 > v26 - 2)
            goto LABEL_9;
          v27 = *((_QWORD *)this + 3);
          v28 = *(unsigned __int16 *)(v27 + v11);
          v13 = v11 + 2;
          *((_QWORD *)this + 5) = v11 + 2;
          if (*((_BYTE *)this + 48))
            return result;
          if (v13 > v26 - 2)
            goto LABEL_9;
          v8 = __rev16(*(unsigned __int16 *)(v27 + v13));
          *((_QWORD *)this + 5) = v11 + 4;
          if (!v8)
            return result;
          if (v8 == 1)
            return _cg_jpeg_mem_term("processData", 927, "*** ERROR: markerLength too small (%d)\n");
          v29 = v26 - (v11 + 4) - 4;
          if (v29 <= v8)
            LogWarning("processData", 930, "*** WARNING: check markerLength: %d - expected max: %d\n", v8, v29);
          v9 = bswap32(v28) >> 16;
          v12 = v11;
          *((_QWORD *)this + 5) = v11;
          if (v9 >> 8 <= 0xFE)
            return result;
          break;
        case -30:
          v21 = v8 + 2;
          v22 = *((_QWORD *)this + 3);
          v23 = (const char *)(v22 + (v13 + 2));
          v24 = v8 - 2;
          if (v24 >= 0xC
            && !strncmp((const char *)(v22 + (v13 + 2)), "ICC_PROFILE", 0xBuLL))
          {
            v25 = (_APP2ICC *)operator new();
            _APP2ICC::_APP2ICC(v25, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, 65506, v21, *((_BYTE *)this + 96));
          }
          else
          {
            if (strlen(v23) >= v24)
            {
              result = _cg_jpeg_mem_term("processData", 822, "*** ERROR: unknown APP2 marker - skipping\n");
              goto LABEL_43;
            }
            v25 = (_APP2ICC *)operator new();
            _APPx::_APPx(v25, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, 0xFFE2u, v21, *((_BYTE *)this + 96));
          }
          (*(void (**)(_APP2ICC *))(*(_QWORD *)v25 + 16))(v25);
          _JPEGFile::insertAppMarker(this, v25);
LABEL_43:
          v11 = v21 + v11;
          goto LABEL_48;
        default:
          if ((unsigned __int16)v9 == 65517)
          {
            v14 = v8 + 2;
            v15 = (_APP0 *)operator new();
            _APP13::_APP13(v15, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, 65517, v14, *((_BYTE *)this + 96));
          }
          else
          {
            if ((unsigned __int16)v9 == 0xFFFF)
            {
              v11 = v12 + 1;
              goto LABEL_48;
            }
LABEL_21:
            v14 = v8 + 2;
            v15 = (_APP0 *)operator new();
            _APPx::_APPx(v15, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), v11, v9, v14, *((_BYTE *)this + 96));
          }
          (*(void (**)(_APP0 *))(*(_QWORD *)v15 + 16))(v15);
LABEL_36:
          _JPEGFile::insertAppMarker(this, v15);
          v11 = v14 + v11;
          goto LABEL_48;
      }
    }
  }
  return result;
}

void sub_18801A640(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C407B1DB21FLL);
  _Unwind_Resume(a1);
}

uint64_t _JPEGFile::getshort(_JPEGFile *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 5);
  if (v1 <= *((_QWORD *)this + 4) - 2)
  {
    v2 = bswap32(*(unsigned __int16 *)(*((_QWORD *)this + 3) + v1)) >> 16;
    *((_QWORD *)this + 5) = v1 + 2;
  }
  else
  {
    v2 = 0;
    *((_BYTE *)this + 48) = 1;
  }
  return v2;
}

char *_JPEGFile::createExtendedAPP0(char *this)
{
  _QWORD *v1;
  _JPEGFile *v2;
  _APP0 *v3;

  v1 = (_QWORD *)*((_QWORD *)this + 9);
  if (v1 != *((_QWORD **)this + 10))
  {
    v2 = (_JPEGFile *)this;
    if (*(__int16 *)(*v1 + 56) == -32)
    {
      return (char *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v1 + 128))(*v1);
    }
    else
    {
      v3 = (_APP0 *)operator new();
      _APP0::_APP0(v3, 65504, 1, 20);
      return _JPEGFile::insertAppMarker(v2, v3);
    }
  }
  return this;
}

void sub_18801A7D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C4040CFD0ABLL);
  _Unwind_Resume(a1);
}

_QWORD *_JPEGFile::writeToStream(_QWORD *this, __CFWriteStream *a2)
{
  _QWORD *v3;
  char *v4;
  char *v5;
  int v6;
  int v7;
  int v8;
  char *v9;
  uint64_t v10;
  __int16 *v11;
  char *v12;
  uint64_t v13;

  v3 = this;
  v5 = (char *)this[9];
  v4 = (char *)this[10];
  if (v5 == v4)
  {
    v6 = 0;
    v8 = -1;
    v7 = -1;
  }
  else
  {
    v6 = 0;
    v7 = -1;
    v8 = -1;
    v9 = (char *)this[9];
    do
    {
      if (*(__int16 *)(*(_QWORD *)v9 + 56) == -31)
      {
        if (*(_BYTE *)(*(_QWORD *)v9 + 68))
          v7 = v6;
        else
          v8 = v6;
        ++v6;
      }
      v9 += 8;
    }
    while (v9 != v4);
  }
  if (v6 == 2 && v8 != -1 && v7 != -1 && v8 < v7)
  {
    v10 = *(_QWORD *)&v5[8 * v8];
    *(_QWORD *)&v5[8 * v8] = *(_QWORD *)&v5[8 * v7];
    *(_QWORD *)&v5[8 * v7] = v10;
    v5 = (char *)this[9];
    v4 = (char *)this[10];
  }
  if (v4 - v5 == 16)
  {
    v11 = (__int16 *)*((_QWORD *)v5 + 1);
    if (v11[28] == -37)
    {
      this = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v11 + 24))(*((_QWORD *)v5 + 1));
      v5 = (char *)v3[9];
      if (this > 0x3000)
      {
        this = *(_QWORD **)v5;
        if (*(__int16 *)(*(_QWORD *)v5 + 56) == -31)
        {
          (*(void (**)(_QWORD *))(*this + 88))(this);
          this = (_QWORD *)(*(uint64_t (**)(__int16 *))(*(_QWORD *)v11 + 88))(v11);
          v5 = (char *)v3[9];
        }
      }
    }
  }
  v12 = (char *)v3[10];
  while (v5 != v12)
  {
    v13 = *(_QWORD *)v5;
    this = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)v5 + 24))(*(_QWORD *)v5);
    if ((_DWORD)this)
      this = (_QWORD *)(*(uint64_t (**)(uint64_t, __CFWriteStream *))(*(_QWORD *)v13 + 32))(v13, a2);
    v5 += 8;
  }
  return this;
}

uint64_t _JPEGFile::dump(uint64_t this, const char *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t i;

  v3 = *(uint64_t **)(this + 72);
  v2 = *(uint64_t **)(this + 80);
  if (v2 != v3)
  {
    v4 = this;
    v5 = 1;
    do
    {
      v6 = *v3++;
      this = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 80))(v6, v5 & 1);
      v5 = 0;
    }
    while (v3 != v2);
    for (i = *(_QWORD *)(v4 + 72); i != *(_QWORD *)(v4 + 80); i += 8)
    {
      this = *(_QWORD *)i;
      if (*(__int16 *)(*(_QWORD *)i + 56) == -31 && *(_BYTE *)(this + 68))
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 128))(this);
    }
  }
  return this;
}

void _JPEGWriter::_JPEGWriter(_JPEGWriter *this, CGImage *a2, const __CFData *a3, const __CFData *a4, IIODictionary *a5, const CGImageMetadata *a6, char a7)
{
  uint64_t Mutable;

  *(_QWORD *)this = &off_1E1BABF80;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = a4;
  Mutable = CGImageMetadataCreateFromLegacyProps(a5);
  if (!Mutable)
    Mutable = (uint64_t)CGImageMetadataCreateMutable();
  CGImageMetadataMerge(Mutable, (uint64_t)a6, 0);
  *((_QWORD *)this + 4) = a5;
  *((_QWORD *)this + 5) = Mutable;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_BYTE *)this + 66) = a7;
  *((_OWORD *)this + 3) = 0u;
  *((_BYTE *)this + 65) = 0;
  *((_BYTE *)this + 67) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  if (a5)
  {
    if (IIODictionary::containsKey(a5, CFSTR("kCGImageWriteExtendedAPP0")))
      *((_BYTE *)this + 67) = IIODictionary::getBoolForKey(*((IIODictionary **)this + 4), CFSTR("kCGImageWriteExtendedAPP0"));
  }
}

void _JPEGWriter::~_JPEGWriter(_JPEGWriter *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  uint64_t v8;

  *(_QWORD *)this = &off_1E1BABF80;
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 10) = 0;
  }
  v3 = *((_QWORD *)this + 11);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    *((_QWORD *)this + 11) = 0;
  }
  v4 = *((_QWORD *)this + 12);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    *((_QWORD *)this + 12) = 0;
  }
  v5 = *((_QWORD *)this + 7);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    *((_QWORD *)this + 7) = 0;
  }
  v6 = (const void *)*((_QWORD *)this + 5);
  if (v6)
  {
    CFRelease(v6);
    *((_QWORD *)this + 5) = 0;
  }
  v7 = (const void *)*((_QWORD *)this + 9);
  if (v7)
  {
    CFRelease(v7);
    *((_QWORD *)this + 9) = 0;
  }
  v8 = *((_QWORD *)this + 6);
  if (v8)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    *((_QWORD *)this + 6) = 0;
  }
}

{
  _JPEGWriter::~_JPEGWriter(this);
  JUMPOUT(0x18D761C30);
}

void _JPEGWriter::processInput(_JPEGWriter *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  IIODictionary *v7;
  uint64_t v8;
  uint64_t v9;
  const __CFData *v10;
  uint64_t v11;
  IIODictionary *v12;
  const __CFDictionary *ObjectForKey;
  __CFDictionary *v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  IIODictionary *v17;
  const __CFDictionary *v18;
  const __CFDictionary **v19;
  const __CFDictionary **v20;
  const __CFDictionary **v21;
  IIODictionary *v22;
  char *ExifBufferFromPropertiesJPEG;
  BOOL v24;
  const __CFDictionary *v25;
  __CFDictionary *v26;
  BOOL v27;
  char *v28;
  size_t v29;
  char *v30;
  CFDataRef v31;
  uint64_t v32;
  _JPEGFile *v33;
  _JPEGFile *v34;
  _TAGList *v35;
  _JPEGFile *v36;
  unsigned __int8 *v37;
  _APP13 *v38;
  uint64_t v39;
  const void *v40;
  CGMutableImageMetadataRef Mutable;
  const CGImageMetadata *v42;
  const void *v43;
  uint64_t v44;
  uint64_t v45;
  _BYTE *v46;
  const __CFData *XMPWithEXIFFiltered;
  const __CFData *v48;
  _APP1XMP *v49;
  _JPEGFile *v50;
  size_t __len[3];
  unint64_t v52;
  _BYTE v53[24];
  _BYTE v54[24];
  _BYTE v55[24];

  if (*((_QWORD *)this + 2))
  {
    v2 = operator new();
    _JPEGFile::_JPEGFile((_JPEGFile *)v2, *((CFDataRef *)this + 2), 1, *((_BYTE *)this + 67));
    *((_QWORD *)this + 10) = v2;
    *(_OWORD *)(v2 + 8) = *(_OWORD *)"JPEGData";
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
    if (*((_BYTE *)this + 65))
    {
      v3 = *((_QWORD *)this + 10);
      v4 = *(_QWORD *)(v3 + 72);
      v5 = *(_QWORD *)(v3 + 80);
      while (v4 != v5)
      {
        if (*(__int16 *)(*(_QWORD *)v4 + 56) == -31 && *(_BYTE *)(*(_QWORD *)v4 + 68))
          goto LABEL_12;
        v4 += 8;
      }
      if (!*((_QWORD *)this + 4))
      {
        v6 = *((_QWORD *)this + 6);
        if (!v6)
        {
          v7 = (IIODictionary *)operator new();
          IIODictionary::IIODictionary(v7);
          *((_QWORD *)this + 6) = v7;
          IIONumber::IIONumber((IIONumber *)v55, 72);
          IIODictionary::setObjectForKey((uint64_t)v7, (uint64_t)v55, CFSTR("DPIHeight"));
          IIONumber::~IIONumber((IIONumber *)v55);
          v8 = *((_QWORD *)this + 6);
          IIONumber::IIONumber((IIONumber *)v54, 72);
          IIODictionary::setObjectForKey(v8, (uint64_t)v54, CFSTR("DPIWidth"));
          IIONumber::~IIONumber((IIONumber *)v54);
          v9 = *((_QWORD *)this + 6);
          IIONumber::IIONumber((IIONumber *)v53, 1);
          IIODictionary::setObjectForKey(v9, (uint64_t)v53, CFSTR("Orientation"));
          IIONumber::~IIONumber((IIONumber *)v53);
          v6 = *((_QWORD *)this + 6);
        }
        *((_QWORD *)this + 4) = v6;
      }
    }
  }
LABEL_12:
  v10 = (const __CFData *)*((_QWORD *)this + 3);
  if (v10 && CFDataGetLength(v10))
  {
    v11 = operator new();
    _JPEGFile::_JPEGFile((_JPEGFile *)v11, *((CFDataRef *)this + 3), 2, 0);
    *((_QWORD *)this + 11) = v11;
    *(_OWORD *)(v11 + 8) = *(_OWORD *)"ThumbnailData";
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 16))(v11);
  }
  if (*((_QWORD *)this + 4))
  {
    v12 = (IIODictionary *)operator new();
    IIODictionary::IIODictionary(v12, *(const __CFDictionary **)(*((_QWORD *)this + 4) + 8), 1);
    *((_QWORD *)this + 7) = v12;
    _JPEGWriter::cleanupProperties((_JPEGFile **)this, v12);
    ObjectForKey = IIODictionary::getObjectForKey(*((IIODictionary **)this + 7), CFSTR("{IPTC}"));
    v14 = ObjectForKey;
    if (ObjectForKey)
    {
      CFRetain(ObjectForKey);
      IIODictionary::removeObjectForKey(*((IIODictionary **)this + 7), CFSTR("{IPTC}"));
    }
    v15 = IIODictionary::getObjectForKey(*((IIODictionary **)this + 7), CFSTR("{ExifAux}"));
    if (v15)
    {
      v16 = v15;
      v17 = (IIODictionary *)operator new();
      IIODictionary::IIODictionary(v17);
      IIODictionary::setObjectForKey(v17, v16, CFSTR("{ExifAux}"));
      IIODictionary::removeObjectForKey(*((IIODictionary **)this + 7), CFSTR("{ExifAux}"));
    }
    else
    {
      v17 = 0;
    }
    v18 = IIODictionary::getObjectForKey(*((IIODictionary **)this + 7), CFSTR("kCGImageDestinationICCProfile"));
  }
  else
  {
    v18 = 0;
    v17 = 0;
    v14 = 0;
  }
  v19 = (const __CFDictionary **)*((_QWORD *)this + 5);
  if (v19)
  {
    v20 = (const __CFDictionary **)CGImagePropertiesCreateFromMetadata(v19);
    if (v20)
    {
      v21 = v20;
      IIODictionary::appendDictionary(*((IIODictionary **)this + 7), v20);
      (*((void (**)(const __CFDictionary **))*v21 + 1))(v21);
    }
  }
  v22 = (IIODictionary *)*((_QWORD *)this + 7);
  if (v22)
  {
    __len[0] = 0;
    ExifBufferFromPropertiesJPEG = CreateExifBufferFromPropertiesJPEG(v22, 0, 0, 0, 0, CFSTR("public.jpeg"), __len);
    if (ExifBufferFromPropertiesJPEG)
      v24 = __len[0] >= 0xFFFA;
    else
      v24 = 0;
    if (v24)
    {
      v25 = IIODictionary::getObjectForKey(*((IIODictionary **)this + 7), CFSTR("{Exif}"));
      if (v25)
      {
        v26 = v25;
        if (CFDictionaryGetValue(v25, CFSTR("UserComment")))
        {
          CFDictionaryRemoveValue(v26, CFSTR("UserComment"));
          free(ExifBufferFromPropertiesJPEG);
          ExifBufferFromPropertiesJPEG = CreateExifBufferFromPropertiesJPEG(*((IIODictionary **)this + 7), 0, 0, 0, 0, CFSTR("public.jpeg"), __len);
        }
      }
    }
    if (ExifBufferFromPropertiesJPEG)
      v27 = __len[0] > 0xFFF9;
    else
      v27 = 1;
    if (!v27)
    {
      v28 = (char *)reallocf(ExifBufferFromPropertiesJPEG, __len[0] + 18);
      if (!v28)
        goto LABEL_78;
      ExifBufferFromPropertiesJPEG = v28;
      v29 = __len[0];
      memmove(v28 + 6, v28, __len[0]);
      *(_DWORD *)ExifBufferFromPropertiesJPEG = -503326465;
      ExifBufferFromPropertiesJPEG[4] = (unsigned __int16)(v29 + 6) >> 8;
      ExifBufferFromPropertiesJPEG[5] = v29 + 6;
      __len[0] = v29 + 18;
      v30 = &ExifBufferFromPropertiesJPEG[v29 + 18];
      *((_DWORD *)v30 - 1) = 0;
      *(_QWORD *)(v30 - 12) = 0;
      v31 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)ExifBufferFromPropertiesJPEG, v29 + 18);
      *((_QWORD *)this + 9) = v31;
      if (v31)
      {
        v32 = operator new();
        _JPEGFile::_JPEGFile((_JPEGFile *)v32, *((CFDataRef *)this + 9), 4, *((_BYTE *)this + 67));
        *((_QWORD *)this + 12) = v32;
        *(_OWORD *)(v32 + 8) = *(_OWORD *)"PropertyData";
        (*(void (**)(uint64_t))(*(_QWORD *)v32 + 16))(v32);
      }
    }
    free(ExifBufferFromPropertiesJPEG);
    v33 = (_JPEGFile *)*((_QWORD *)this + 10);
    if (v33)
    {
      v34 = (_JPEGFile *)*((_QWORD *)this + 12);
      if (v34)
        _JPEGFile::mergeWithFile(v33, v34);
    }
  }
  v35 = (_TAGList *)*((_QWORD *)this + 10);
  if (v35)
  {
    v36 = (_JPEGFile *)*((_QWORD *)this + 11);
    if (v36)
    {
LABEL_47:
      _JPEGFile::copyThumbnail(v35, v36);
    }
    else if (*((_BYTE *)this + 65))
    {
      v44 = *((_QWORD *)v35 + 9);
      v45 = *((_QWORD *)v35 + 10);
      while (v44 != v45)
      {
        v46 = *(_BYTE **)v44;
        if (*(__int16 *)(*(_QWORD *)v44 + 56) == -31 && v46[68])
        {
          if (!(*(uint64_t (**)(_BYTE *))(*(_QWORD *)v46 + 48))(v46))
            break;
          v35 = (_TAGList *)*((_QWORD *)this + 10);
          v36 = v35;
          goto LABEL_47;
        }
        v44 += 8;
      }
    }
    _JPEGFile::addMissingIFDTags(*((_JPEGFile **)this + 10));
  }
  if (v14 && *((_QWORD *)this + 10))
  {
    v52 = 0;
    memset(__len, 0, sizeof(__len));
    IIODictionary::IIODictionary((IIODictionary *)__len, v14);
    v37 = (unsigned __int8 *)CreateIPTCDataFromProperties(0, (IIODictionary *)__len, &v52);
    if (v37)
    {
      v38 = (_APP13 *)operator new();
      _APP13::_APP13(v38, v37, v52);
      _JPEGFile::insertAppMarker(*((_JPEGFile **)this + 10), v38);
    }
    CFRelease(v14);
    IIODictionary::~IIODictionary((IIODictionary *)__len);
  }
  if (v17)
  {
    if (*((_QWORD *)this + 10))
    {
      v39 = CGImageMetadataCreateFromLegacyProps(v17);
      v40 = (const void *)v39;
      if (*((_QWORD *)this + 5))
      {
        Mutable = CGImageMetadataCreateMutable();
        if (Mutable)
        {
          v42 = Mutable;
          CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)v40, 0);
          CGImageMetadataMerge((uint64_t)v42, *((_QWORD *)this + 5), 0);
LABEL_70:
          XMPWithEXIFFiltered = CGImageMetadataCreateXMPWithEXIFFiltered(v42);
          if (XMPWithEXIFFiltered)
          {
            v48 = XMPWithEXIFFiltered;
            v49 = (_APP1XMP *)operator new();
            _APP1XMP::_APP1XMP(v49, v48);
            _JPEGFile::insertAppMarker(*((_JPEGFile **)this + 10), v49);
            CFRelease(v48);
          }
          CFRelease(v42);
        }
LABEL_73:
        if (v40)
          CFRelease(v40);
        goto LABEL_75;
      }
      v43 = (const void *)v39;
      if (v39)
      {
LABEL_69:
        v42 = (const CGImageMetadata *)CFRetain(v40);
        v40 = v43;
        if (v42)
          goto LABEL_70;
        goto LABEL_73;
      }
    }
  }
  else
  {
    v40 = (const void *)*((_QWORD *)this + 5);
    if (v40 && *((_QWORD *)this + 10))
    {
      v43 = 0;
      goto LABEL_69;
    }
  }
LABEL_75:
  if (v18)
  {
    v50 = (_JPEGFile *)*((_QWORD *)this + 10);
    if (v50)
      _JPEGFile::setICCProfile(v50, v18);
  }
LABEL_78:
  if (v17)
    (*(void (**)(IIODictionary *))(*(_QWORD *)v17 + 8))(v17);
  if (*((_BYTE *)this + 67))
    _JPEGFile::createExtendedAPP0(*((char **)this + 10));
}

void sub_18801B278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::cleanupProperties(_JPEGFile **this, IIODictionary *a2)
{
  const __CFDictionary *ObjectForKey;
  _APPx *v5;
  const __CFDictionary *v6;
  _APPx *v7;
  __CFDictionary *v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  __CFDictionary *v11;
  _JPEGWriter *v12;
  __CFDictionary *v13;
  _JPEGWriter *v14;
  IIODictionary *v15;
  const __CFDictionary *v16;
  _JPEGWriter *v17;
  IIODictionary *v18;
  _JPEGWriter *v19;
  IIODictionary *v20;
  _JPEGWriter *v21;
  IIODictionary *v22;
  _JPEGWriter *v23;
  IIODictionary *v24;
  _JPEGWriter *v25;
  IIODictionary *v26;
  IIODictionary *v27;
  _QWORD v28[3];
  uint64_t v29;
  void *value;
  uint64_t v31;

  IIODictionary::removeObjectForKey(a2, CFSTR("{Diagnostic}"));
  if (IIODictionary::containsKey(a2, CFSTR("iOS_Debug")))
  {
    ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("iOS_Debug"));
    v5 = (_APPx *)operator new();
    _APP3::_APP3(v5, ObjectForKey, 1);
    _JPEGFile::insertAppMarker(this[10], v5);
    IIODictionary::removeObjectForKey(a2, CFSTR("iOS_Debug"));
  }
  if (IIODictionary::containsKey(a2, CFSTR("iOSCustom")))
  {
    v6 = IIODictionary::getObjectForKey(a2, CFSTR("iOSCustom"));
    v7 = (_APPx *)operator new();
    _APP3::_APP3(v7, v6, 2);
    _JPEGFile::insertAppMarker(this[10], v7);
    IIODictionary::removeObjectForKey(a2, CFSTR("iOSCustom"));
  }
  if ((IIODictionary::containsKey(a2, CFSTR("{TIFF}")) & 1) == 0)
  {
    IIODictionary::IIODictionary((IIODictionary *)&v29);
    IIODictionary::setObjectForKey(a2, value, CFSTR("{TIFF}"));
    IIODictionary::~IIODictionary((IIODictionary *)&v29);
  }
  if ((IIODictionary::containsKey(a2, CFSTR("{Exif}")) & 1) != 0)
  {
    v8 = IIODictionary::getObjectForKey(a2, CFSTR("{Exif}"));
    v29 = 0;
    value = 0;
    v31 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v29, v8);
    IIODictionary::removeObjectForKey((IIODictionary *)&v29, CFSTR("ThumbnailOffset"));
    IIODictionary::removeObjectForKey((IIODictionary *)&v29, CFSTR("ThumbnailSize"));
    v9 = IIODictionary::getObjectForKey((IIODictionary *)&v29, CFSTR("{GPS}"));
    if (v9)
    {
      IIODictionary::setObjectForKey(a2, v9, CFSTR("{GPS}"));
      IIODictionary::removeObjectForKey((IIODictionary *)&v29, CFSTR("{GPS}"));
    }
    v10 = IIODictionary::getObjectForKey((IIODictionary *)&v29, CFSTR("{ExifAux}"));
    if (v10)
    {
      IIODictionary::setObjectForKey(a2, v10, CFSTR("{ExifAux}"));
      IIODictionary::removeObjectForKey((IIODictionary *)&v29, CFSTR("{ExifAux}"));
    }
  }
  else
  {
    IIODictionary::IIODictionary((IIODictionary *)&v29);
    IIODictionary::setObjectForKey(a2, value, CFSTR("{Exif}"));
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v29);
  v11 = IIODictionary::getObjectForKey(a2, CFSTR("{TIFF}"));
  v29 = 0;
  value = 0;
  v31 = 0;
  v12 = IIODictionary::IIODictionary((IIODictionary *)&v29, v11);
  _JPEGWriter::syncTopLevelAndSubDictionaries(v12, a2, (IIODictionary *)&v29);
  v13 = IIODictionary::getObjectForKey(a2, CFSTR("{Exif}"));
  memset(v28, 0, sizeof(v28));
  IIODictionary::IIODictionary((IIODictionary *)v28, v13);
  v14 = IIODictionary::containsKey(a2, CFSTR("Orientation"));
  if ((v14 & 1) == 0)
  {
    v14 = IIODictionary::containsKey((IIODictionary *)v28, CFSTR("Orientation"));
    if ((v14 & 1) == 0)
    {
      v14 = IIODictionary::containsKey(a2, CFSTR("kCGImageCopyFileSetOrientation"));
      if ((_DWORD)v14)
      {
        v16 = IIODictionary::getObjectForKey(a2, CFSTR("kCGImageCopyFileSetOrientation"));
        IIODictionary::setObjectForKey(a2, v16, CFSTR("Orientation"));
      }
    }
  }
  if (*((_BYTE *)this + 66))
  {
    _JPEGWriter::addExifVersionIfNeeded(v14, v15, (IIODictionary *)v28);
    _JPEGWriter::addExifFlashPixVersionIfNeeded(v17, v18, (IIODictionary *)v28);
    _JPEGWriter::addExifColorSpaceIfNeeded(v19, v20, (IIODictionary *)v28);
    _JPEGWriter::addExifSceneCaptureTypeIfNeeded(v21, v22, (IIODictionary *)v28);
    _JPEGWriter::addTIFFYCbCrPositioningIfNeeded(v23, v24, (IIODictionary *)&v29);
    _JPEGWriter::addExifComponentsConfigurationIfNeeded(v25, v26, (IIODictionary *)v28);
    _JPEGWriter::addExifPixelDimensionsIfNeeded((_JPEGWriter *)this, v27, (IIODictionary *)v28);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v28);
  IIODictionary::~IIODictionary((IIODictionary *)&v29);
}

void sub_18801B6A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::syncTopLevelAndSubDictionaries(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  BOOL v10;
  int v11;
  const __CFDictionary *v14;
  BOOL v15;
  _BYTE v16[24];
  _BYTE v17[24];
  _BYTE v18[24];
  _BYTE v19[24];

  ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("Orientation"));
  if (ObjectForKey)
    IIODictionary::setObjectForKey(a3, ObjectForKey, CFSTR("Orientation"));
  v6 = IIODictionary::getObjectForKey(a2, CFSTR("DPIWidth"));
  v7 = IIODictionary::getObjectForKey(a2, CFSTR("DPIHeight"));
  v8 = IIODictionary::getObjectForKey(a3, CFSTR("XResolution"));
  v9 = IIODictionary::getObjectForKey(a3, CFSTR("YResolution"));
  if (v6)
    v10 = v7 == 0;
  else
    v10 = 1;
  v11 = !v10;
  if (v11 != 1 || v8 == 0 || v9 == 0)
  {
    if (v11)
    {
      IIODictionary::setObjectForKey(a3, v6, CFSTR("XResolution"));
      IIODictionary::setObjectForKey(a3, v7, CFSTR("YResolution"));
    }
    else
    {
      v14 = v9;
      if (v8)
        v15 = v9 == 0;
      else
        v15 = 1;
      if (v15)
      {
        IIONumber::IIONumber((IIONumber *)v19, 72.0);
        IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v19, CFSTR("DPIWidth"));
        IIONumber::~IIONumber((IIONumber *)v19);
        IIONumber::IIONumber((IIONumber *)v18, 72.0);
        IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v18, CFSTR("DPIHeight"));
        IIONumber::~IIONumber((IIONumber *)v18);
        IIONumber::IIONumber((IIONumber *)v17, 72.0);
        IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v17, CFSTR("XResolution"));
        IIONumber::~IIONumber((IIONumber *)v17);
        IIONumber::IIONumber((IIONumber *)v16, 72.0);
        IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v16, CFSTR("YResolution"));
        IIONumber::~IIONumber((IIONumber *)v16);
      }
      else
      {
        IIODictionary::setObjectForKey(a2, v8, CFSTR("DPIWidth"));
        IIODictionary::setObjectForKey(a2, v14, CFSTR("DPIHeight"));
      }
    }
  }
}

void sub_18801B918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIONumber::~IIONumber((IIONumber *)&a9);
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifVersionIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  _BYTE v4[24];
  _BYTE v5[24];
  _BYTE v6[24];
  CFMutableArrayRef v7;
  const void *v8;
  uint64_t v9;

  if ((IIODictionary::containsKey(a3, CFSTR("ExifVersion")) & 1) == 0)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    IIOArray::IIOArray((IIOArray *)&v7);
    IIONumber::IIONumber((IIONumber *)v6, 2);
    IIOArray::addObject(&v7, (uint64_t)v6);
    IIONumber::~IIONumber((IIONumber *)v6);
    IIONumber::IIONumber((IIONumber *)v5, 2);
    IIOArray::addObject(&v7, (uint64_t)v5);
    IIONumber::~IIONumber((IIONumber *)v5);
    IIONumber::IIONumber((IIONumber *)v4, 1);
    IIOArray::addObject(&v7, (uint64_t)v4);
    IIONumber::~IIONumber((IIONumber *)v4);
    IIODictionary::setObjectForKey(a3, v8, CFSTR("ExifVersion"));
    IIOArray::~IIOArray((IIOArray *)&v7);
  }
}

void sub_18801BA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  IIONumber::~IIONumber((IIONumber *)&a9);
  IIOArray::~IIOArray((IIOArray *)(v9 - 40));
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifFlashPixVersionIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  _BYTE v4[24];
  _BYTE v5[24];
  CFMutableArrayRef v6;
  const void *v7;
  uint64_t v8;

  if ((IIODictionary::containsKey(a3, CFSTR("FlashPixVersion")) & 1) == 0)
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    IIOArray::IIOArray((IIOArray *)&v6);
    IIONumber::IIONumber((IIONumber *)v5, 1);
    IIOArray::addObject(&v6, (uint64_t)v5);
    IIONumber::~IIONumber((IIONumber *)v5);
    IIONumber::IIONumber((IIONumber *)v4, 0);
    IIOArray::addObject(&v6, (uint64_t)v4);
    IIONumber::~IIONumber((IIONumber *)v4);
    IIODictionary::setObjectForKey(a3, v7, CFSTR("FlashPixVersion"));
    IIOArray::~IIOArray((IIOArray *)&v6);
  }
}

void sub_18801BAFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)(v2 - 40));
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifColorSpaceIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  _BYTE v4[24];

  if ((IIODictionary::containsKey(a3, CFSTR("ColorSpace")) & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v4, 1);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v4, CFSTR("ColorSpace"));
    IIONumber::~IIONumber((IIONumber *)v4);
  }
}

void sub_18801BB90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifSceneCaptureTypeIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  _BYTE v4[24];

  if ((IIODictionary::containsKey(a3, CFSTR("SceneCaptureType")) & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v4, 0);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v4, CFSTR("SceneCaptureType"));
    IIONumber::~IIONumber((IIONumber *)v4);
  }
}

void sub_18801BC08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::addTIFFYCbCrPositioningIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  _BYTE v4[24];

  if ((IIODictionary::containsKey(a3, CFSTR("_YCbCrPositioning")) & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v4, 1);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v4, CFSTR("_YCbCrPositioning"));
    IIONumber::~IIONumber((IIONumber *)v4);
  }
}

void sub_18801BC80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifComponentsConfigurationIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  _BYTE v4[24];

  if ((IIODictionary::containsKey(a3, CFSTR("ComponentsConfiguration")) & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v4, 16909056);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v4, CFSTR("ComponentsConfiguration"));
    IIONumber::~IIONumber((IIONumber *)v4);
  }
}

void sub_18801BCFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifPixelDimensionsIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  _BYTE v5[24];
  _BYTE v6[24];
  unsigned int v7[2];

  if (*((_QWORD *)this + 10)
    && (!IIODictionary::containsKey(a3, CFSTR("PixelXDimension"))
     || (IIODictionary::containsKey(a3, CFSTR("PixelYDimension")) & 1) == 0))
  {
    *(_QWORD *)v7 = 0;
    _JPEGFile::getImageDimension(*((_QWORD **)this + 10), &v7[1], v7, 0);
    IIONumber::IIONumber((IIONumber *)v6, v7[1]);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v6, CFSTR("PixelXDimension"));
    IIONumber::~IIONumber((IIONumber *)v6);
    IIONumber::IIONumber((IIONumber *)v5, v7[0]);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v5, CFSTR("PixelYDimension"));
    IIONumber::~IIONumber((IIONumber *)v5);
  }
}

void sub_18801BDDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t _JPEGWriter::writePropertiesAndData(_JPEGWriter *this, __CFWriteStream *a2)
{
  const __CFData *v3;
  const UInt8 *BytePtr;

  *((_BYTE *)this + 64) = 0;
  if (*((_QWORD *)this + 10))
  {
    v3 = (const __CFData *)*((_QWORD *)this + 2);
    if (v3)
    {
      BytePtr = CFDataGetBytePtr(v3);
      if ((unint64_t)CFDataGetLength(*((CFDataRef *)this + 2)) >= 2 && *BytePtr == 255 && BytePtr[1] == 216)
      {
        CFWriteStreamWrite(a2, BytePtr, 2);
        _JPEGFile::writeToStream(*((_QWORD **)this + 10), a2);
      }
    }
  }
  return 1;
}

CFTypeRef _JPEGWriter::createData(_JPEGWriter *this)
{
  __CFWriteStream *v2;
  __CFWriteStream *v3;
  CFTypeRef v4;

  v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (!v2)
    return 0;
  v3 = v2;
  if (CFWriteStreamOpen(v2))
  {
    _JPEGWriter::writePropertiesAndData(this, v3);
    v4 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
    CFWriteStreamClose(v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

void _JPEGWriter::writeToPath(_JPEGWriter *this, const __CFString *a2)
{
  const __CFURL *v3;
  const __CFURL *v4;
  __CFWriteStream *v5;
  __CFWriteStream *v6;
  const __CFData *v7;
  const __CFData *v8;
  UInt8 buffer[4];
  CFRange v10;

  v3 = CFURLCreateWithFileSystemPath(0, a2, kCFURLPOSIXPathStyle, 0);
  if (v3)
  {
    v4 = v3;
    v5 = CFWriteStreamCreateWithFile(0, v3);
    if (v5)
    {
      v6 = v5;
      if (CFWriteStreamOpen(v5))
      {
        v7 = (const __CFData *)CFWriteStreamCopyProperty(v6, CFSTR("_kCFStreamPropertyFileNativeHandle"));
        if (v7)
        {
          v8 = v7;
          *(_DWORD *)buffer = 0;
          v10.location = 0;
          v10.length = 4;
          CFDataGetBytes(v7, v10, buffer);
          fcntl(*(int *)buffer, 48, 1);
          fcntl(*(int *)buffer, 62, 1);
          CFRelease(v8);
        }
        _JPEGWriter::writePropertiesAndData(this, v6);
        CFWriteStreamClose(v6);
      }
      else
      {
        LogError("writeToPath", 1945, "*** ERROR: CFWriteStreamOpen failed\n");
      }
      CFRelease(v6);
    }
    else
    {
      LogError("writeToPath", 1950, "*** ERROR: CFWriteStreamCreateWithFile failed\n");
    }
    CFRelease(v4);
  }
  else
  {
    LogError("writeToPath", 1955, "*** ERROR: CFURLCreateWithFileSystemPath failed\n");
  }
}

uint64_t CGImageWriteEXIFJPEGToPath(CGImage *a1, CFDataRef theData, const __CFData *a3, const __CFString *a4, const __CFDictionary *a5)
{
  _OWORD v11[6];
  uint64_t v12;
  _QWORD v13[3];

  if (theData)
  {
    CFDataGetLength(theData);
    if (!a3)
      goto LABEL_5;
    goto LABEL_3;
  }
  if (a3)
LABEL_3:
    CFDataGetLength(a3);
LABEL_5:
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageWriteEXIFJPEGToPath", 0, 0, -1, a5);
  memset(v13, 0, sizeof(v13));
  IIODictionary::IIODictionary((IIODictionary *)v13, a5);
  v12 = 0;
  memset(v11, 0, sizeof(v11));
  _JPEGWriter::_JPEGWriter((_JPEGWriter *)v11, a1, theData, a3, (IIODictionary *)v13, 0, 1);
  _JPEGWriter::processInput((_JPEGWriter *)v11);
  _JPEGWriter::writeToPath((_JPEGWriter *)v11, a4);
  _JPEGWriter::~_JPEGWriter((_JPEGWriter *)v11);
  IIODictionary::~IIODictionary((IIODictionary *)v13);
  return kdebug_trace();
}

void sub_18801C1B4(void *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 88));
  __cxa_begin_catch(a1);
  syslog(3, "*** ERROR: ImageIO - CGImageWriteEXIFJPEGToPath failed\n");
  __cxa_end_catch();
  JUMPOUT(0x18801C180);
}

void sub_18801C1F8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

CFTypeRef CGImageCreateEXIFJPEGData(CGImage *a1, const __CFData *a2, const __CFData *a3, const __CFDictionary *a4)
{
  _JPEGWriter *v8;
  CFTypeRef Data;
  _QWORD v11[3];

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateEXIFJPEGData", 0, 0, -1, a4);
  if (!((unint64_t)a2 | (unint64_t)a3))
    goto LABEL_7;
  memset(v11, 0, sizeof(v11));
  IIODictionary::IIODictionary((IIODictionary *)v11, a4);
  v8 = (_JPEGWriter *)operator new();
  _JPEGWriter::_JPEGWriter(v8, a1, a2, a3, (IIODictionary *)v11, 0, 1);
  _JPEGWriter::processInput(v8);
  Data = _JPEGWriter::createData(v8);
  (*(void (**)(_JPEGWriter *))(*(_QWORD *)v8 + 8))(v8);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  if (!Data)
  {
LABEL_7:
    syslog(3, "*** ERROR: ImageIO - CGImageCreateEXIFJPEGData failed (jpegData and thumbnailData are nil)\n");
    goto LABEL_8;
  }
  if (!CFDataGetLength((CFDataRef)Data))
  {
    syslog(3, "*** ERROR: ImageIO - CGImageCreateEXIFJPEGData failed (zero-length)\n");
    CFRelease(Data);
LABEL_8:
    Data = 0;
  }
  kdebug_trace();
  return Data;
}

void sub_18801C3E0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

BOOL CGImageWriteEXIFJPEGWithMetadata(__CFWriteStream *a1, const __CFData *a2, const __CFData *a3, const __CFDictionary *a4, const CGImageMetadata *a5, CFErrorRef *a6)
{
  CFErrorRef v12;
  _BOOL8 v13;
  _OWORD v15[6];
  uint64_t v16;
  _QWORD v17[3];

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageWriteEXIFJPEGWithMetadata", 0, 0, -1, 0);
  if ((unint64_t)a2 | (unint64_t)a3)
  {
    memset(v17, 0, sizeof(v17));
    IIODictionary::IIODictionary((IIODictionary *)v17, a4);
    v16 = 0;
    memset(v15, 0, sizeof(v15));
    _JPEGWriter::_JPEGWriter((_JPEGWriter *)v15, 0, a2, a3, (IIODictionary *)v17, a5, 1);
    _JPEGWriter::processInput((_JPEGWriter *)v15);
    _JPEGWriter::writePropertiesAndData((_JPEGWriter *)v15, a1);
    v12 = CFWriteStreamCopyError(a1);
    v13 = v12 == 0;
    if (v12)
    {
      if (a6)
        *a6 = v12;
      else
        CFRelease(v12);
    }
    _JPEGWriter::~_JPEGWriter((_JPEGWriter *)v15);
    IIODictionary::~IIODictionary((IIODictionary *)v17);
  }
  else
  {
    v13 = 1;
  }
  kdebug_trace();
  return v13;
}

void sub_18801C560(void *a1)
{
  CFErrorRef *v1;
  uint64_t v2;

  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 88));
  __cxa_begin_catch(a1);
  CGImageMetadataCreateAndLogUTF8Error(0, 0, 0, "CGImageWriteEXIFJPEGWithMetadata failed with unknown error.", v1);
  __cxa_end_catch();
  JUMPOUT(0x18801C528);
}

void sub_18801C5B8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

BOOL CGImageCopyFileWithParameters(__CFString *a1, const __CFString *a2, const __CFDictionary *a3)
{
  CFTypeID v6;
  __CFString *v7;
  CFTypeID TypeID;
  CFTypeID v9;
  int v10;
  int v11;
  unsigned __int8 *v12;
  const __CFData *v13;
  const __CFData *v14;
  uint64_t v15;
  unsigned __int8 v16;
  const __CFDictionary **v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFData *v22;
  _APP13 *v23;
  _BOOL8 v24;
  CGImageMetadata *v25;
  __CFData *v26;
  IIODictionary *v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  IIODictionary *v35;
  const __CFDictionary *ObjectForKey;
  char v37;
  CFIndex v38;
  __CFData *Mutable;
  __CFData *v40;
  unsigned __int8 *MutableBytePtr;
  uint64_t v42;
  uint64_t v43;
  const void *v44;
  CFTypeRef *v45;
  CFTypeRef *v46;
  uint64_t v47;
  _APP1 **v48;
  _APP1 **v49;
  _APP1 *v50;
  const __CFData *v51;
  _JPEGFile *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  uint64_t v57;
  _BYTE *v58;
  CFIndex Length;
  _APP1XMP *v60;
  CFIndex v61;
  const UInt8 *BytePtr;
  const UInt8 *v63;
  CFIndex v64;
  const __CFAllocator *v65;
  uint64_t v66;
  CFIndex v67;
  const __CFData *v68;
  _APP1ExtendedXMP *v69;
  const char *v70;
  CFIndex v71;
  CGImageMetadata *MetadataFromXMPBuffer;
  CGImageMetadata *v73;
  const void *Copy;
  _APP1XMP *v75;
  CFIndex v76;
  const UInt8 *v77;
  const UInt8 *v78;
  CFIndex v79;
  const __CFAllocator *v80;
  uint64_t v81;
  CFIndex v82;
  const __CFData *v83;
  _APP1ExtendedXMP *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  _BYTE *v88;
  __CFString *v89;
  char v90;
  const __CFData *Data;
  const UInt8 *v92;
  CFIndex v93;
  CGImageMetadata *v95;
  unsigned __int8 *v96;
  unsigned __int8 *v97;
  const __CFData *v98;
  const __CFData *v99;
  __CFString *v100;
  __CFString *v101;
  CFTypeID v102;
  CFTypeRef v103;
  __int16 v104;
  CFTypeRef cf;
  CFDataRef v106;
  CFDataRef theData;
  _QWORD v108[3];
  stat v109;
  char v110[8];
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;

  v113 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopyFileWithParameters", 0, 0, -1, a3);
  memset(v108, 0, sizeof(v108));
  IIODictionary::IIODictionary((IIODictionary *)v108, a3);
  v106 = 0;
  theData = 0;
  cf = 0;
  if (!a1)
  {
    LogError("CGImageCopyFileWithParameters", 2207, "*** ERROR: srcPath is nil\n");
    goto LABEL_45;
  }
  v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID() && v6 != CFDataGetTypeID() && v6 != CGDataProviderGetTypeID())
  {
    LogError("CGImageCopyFileWithParameters", 2214, "*** ERROR: srcPath is wrong type\n");
    goto LABEL_45;
  }
  v7 = (__CFString *)a2;
  if (!a2)
  {
    TypeID = CFStringGetTypeID();
    v7 = a1;
    if (v6 != TypeID)
      goto LABEL_45;
  }
  v100 = v7;
  v102 = CFGetTypeID(v7);
  if (v102 != CFStringGetTypeID() && v102 != CFDataGetTypeID())
  {
    LogError("CGImageCopyFileWithParameters", 2235, "*** ERROR: dstPath is wrong type\n");
    goto LABEL_45;
  }
  if (!a3)
  {
    _cg_jpeg_mem_term("CGImageCopyFileWithParameters", 2238, "*** ERROR: no options specified?\n");
    goto LABEL_45;
  }
  v9 = CFGetTypeID(a3);
  if (v9 != CFDictionaryGetTypeID())
  {
    LogError("CGImageCopyFileWithParameters", 2239, "*** ERROR: parameters is wrong type\n");
    goto LABEL_45;
  }
  if (v6 == CFStringGetTypeID())
  {
    bzero(v110, 0x400uLL);
    memset(&v109, 0, sizeof(v109));
    if (_CFStringGetFileSystemRepresentation())
    {
      v10 = open(v110, 0, 0);
      v11 = v10;
      if ((gIIODebugFlags & 0x200000000000) != 0)
        ImageIOLog(">>> %s: opening file [%d] '%s'\n", "CGImageCopyFileWithParameters", v10, v110);
      if ((v11 & 0x80000000) == 0)
      {
        if (fstat(v11, &v109) < 0)
        {
          if ((gIIODebugFlags & 0x200000000000) != 0)
            ImageIOLog("<<< %s: closing file [%d] '%s'\n", "CGImageCopyFileWithParameters", v11, v110);
          close(v11);
        }
        else
        {
          v12 = (unsigned __int8 *)malloc_type_malloc(v109.st_size, 0x7BA9BA60uLL);
          if (v12)
          {
            read(v11, v12, v109.st_size);
            if (*v12 == 255 && v12[1] == 216)
              v13 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v12, v109.st_size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
            else
              v13 = 0;
            if ((gIIODebugFlags & 0x200000000000) != 0)
              ImageIOLog("<<< %s: closing file [%d] '%s'\n", "CGImageCopyFileWithParameters", v11, v110);
            close(v11);
            goto LABEL_32;
          }
          _cg_jpeg_mem_term("CGImageCopyFileWithParameters", 2286, "*** ERROR: cannot allocate srcBuffer [%ld bytes]\n", v109.st_size);
        }
      }
    }
LABEL_45:
    v24 = 0;
    v12 = 0;
    v13 = 0;
    v25 = 0;
    v26 = 0;
    goto LABEL_155;
  }
  if (v6 == CFDataGetTypeID())
  {
    v12 = 0;
    v14 = (const __CFData *)CFRetain(a1);
  }
  else
  {
    if (v6 != CGDataProviderGetTypeID())
    {
      v12 = 0;
      goto LABEL_41;
    }
    v12 = 0;
    v14 = CGDataProviderCopyData((CGDataProviderRef)a1);
  }
  v13 = v14;
LABEL_32:
  if (!v13)
  {
LABEL_41:
    v13 = 0;
    v24 = CGImageCopyFileWithParametersOLD(a1, a2, (IIODictionary *)v108);
    v25 = 0;
    v26 = 0;
    goto LABEL_155;
  }
  v15 = operator new();
  _JPEGWriter::_JPEGWriter((_JPEGWriter *)v15, 0, v13, 0, 0, 0, 1);
  v104 = 0;
  memset(&v109, 0, 20);
  *(_BYTE *)(v15 + 65) = 1;
  _JPEGWriter::processInput((_JPEGWriter *)v15);
  v16 = IIODictionary::containsKey((IIODictionary *)v108, CFSTR("kCGImageCopyFileSetIPTC"));
  v17 = (const __CFDictionary **)copyIPTCDictFromParams((IIODictionary *)v108);
  if (v17)
  {
    v96 = v12;
    v18 = *(_QWORD *)(v15 + 80);
    v20 = *(_QWORD *)(v18 + 72);
    v19 = *(_QWORD *)(v18 + 80);
    if (v19 == v20)
    {
LABEL_38:
      v22 = copyIPTCFromParams((IIODictionary *)v108);
      v12 = v96;
      if (v22)
      {
        v23 = (_APP13 *)operator new();
        _APP13::_APP13(v23, v22);
        _JPEGFile::insertAppMarker(*(_JPEGFile **)(v15 + 80), v23);
        CFRelease(v22);
      }
    }
    else
    {
      v21 = (unsigned __int16)((v19 - v20) >> 3);
      while (*(__int16 *)(*(_QWORD *)v20 + 56) != -19)
      {
        v20 += 8;
        if (v20 == v19)
          goto LABEL_38;
      }
      v27 = (IIODictionary *)operator new();
      IIODictionary::IIODictionary(v27);
      if ((_DWORD)v21)
      {
        v28 = 0;
        v29 = 0;
        v30 = *(_QWORD *)(v18 + 72);
        do
        {
          if ((*(_QWORD *)(v18 + 80) - v30) >> 3 > v28)
          {
            v31 = *(_QWORD *)(v30 + 8 * v28);
            if (v31)
            {
              if (*(__int16 *)(v31 + 56) == -19)
                ++v29;
            }
          }
          ++v28;
        }
        while (v21 != v28);
        v32 = 0;
        do
        {
          v33 = *(_QWORD *)(v18 + 72);
          if (v32 < (unint64_t)((*(_QWORD *)(v18 + 80) - v33) >> 3))
          {
            v34 = *(_QWORD *)(v33 + 8 * v32);
            if (v34)
            {
              if (*(__int16 *)(v34 + 56) == -19)
              {
                v35 = *(IIODictionary **)(v34 + 152);
                if (v35)
                {
                  ObjectForKey = IIODictionary::getObjectForKey(v35, CFSTR("{IPTC}"));
                  if (ObjectForKey)
                    v37 = v16;
                  else
                    v37 = 1;
                  if ((v37 & 1) == 0)
                    IIODictionary::appendDictionary(v27, ObjectForKey);
                  if (v29 >= 2)
                  {
                    _JPEGFile::removeAppMarker(v18, v34);
                    (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
                    --v32;
                    LODWORD(v21) = v21 - 1;
                    --v29;
                  }
                }
              }
            }
          }
          ++v32;
        }
        while (v32 < (int)v21);
      }
      IIODictionary::appendDictionary(v27, v17);
      v38 = SizeOfIPTCData(v27);
      if (v38)
      {
        Mutable = CFDataCreateMutable(0, v38);
        v40 = Mutable;
        if (!Mutable || (CFDataSetLength(Mutable, v38), (MutableBytePtr = CFDataGetMutableBytePtr(v40)) == 0))
        {
          v24 = 0;
          v25 = 0;
          v98 = 0;
          v12 = v96;
          goto LABEL_151;
        }
        WriteIPTCData((CFDictionaryRef *)v27, MutableBytePtr);
        v42 = *(_QWORD *)(v18 + 72);
        v43 = *(_QWORD *)(v18 + 80);
        if (v42 == v43)
        {
          v44 = 0;
          v12 = v96;
        }
        else
        {
          v12 = v96;
          while (1)
          {
            v44 = *(const void **)v42;
            if (*(__int16 *)(*(_QWORD *)v42 + 56) == -19)
              break;
            v42 += 8;
            if (v42 == v43)
            {
              v44 = 0;
              break;
            }
          }
        }
        _APP13::setIPTCData(v44, v40);
        CFRelease(v40);
      }
      else
      {
        v45 = *(CFTypeRef **)(v18 + 72);
        v46 = *(CFTypeRef **)(v18 + 80);
        v12 = v96;
        if (v45 != v46)
        {
          while (*((__int16 *)*v45 + 28) != -19)
          {
            if (++v45 == v46)
              goto LABEL_80;
          }
          _APP13::setIPTCData(*v45, 0);
        }
      }
LABEL_80:
      (*(void (**)(IIODictionary *))(*(_QWORD *)v27 + 8))(v27);
    }
    v47 = *(_QWORD *)(v15 + 80);
    v48 = *(_APP1 ***)(v47 + 72);
    v49 = *(_APP1 ***)(v47 + 80);
    while (v48 != v49)
    {
      v50 = *v48;
      if (*((__int16 *)*v48 + 28) == -31 && *((_BYTE *)v50 + 68))
      {
        _APP1::mergeWithIPTCProps(v50, (IIODictionary *)v17);
        break;
      }
      ++v48;
    }
    (*((void (**)(const __CFDictionary **))*v17 + 1))(v17);
  }
  v51 = CopyXMPFromIPTCParams((IIODictionary *)v108);
  CopyJPEGXMPFromXMPParams((IIODictionary *)v108, &theData, &v106, (CFDataRef *)&cf);
  if ((unint64_t)theData | (unint64_t)v51)
  {
    v101 = (__CFString *)v15;
    v52 = *(_JPEGFile **)(v15 + 80);
    v54 = *((_QWORD *)v52 + 9);
    v53 = *((_QWORD *)v52 + 10);
    v25 = _JPEGFile::copyXMPProperties(v52);
    v55 = (unsigned __int16)((v53 - v54) >> 3);
    if ((unsigned __int16)((v53 - v54) >> 3))
    {
      v56 = 0;
      do
      {
        v57 = *((_QWORD *)v52 + 9);
        if (v56 >= (unint64_t)((*((_QWORD *)v52 + 10) - v57) >> 3))
          v58 = 0;
        else
          v58 = *(_BYTE **)(v57 + 8 * v56);
        if (v58[69] || v58[70])
        {
          _JPEGFile::removeAppMarker((uint64_t)v52, (uint64_t)v58);
          --v56;
          --v55;
          (*(void (**)(_BYTE *))(*(_QWORD *)v58 + 8))(v58);
        }
        ++v56;
      }
      while (v56 < v55);
    }
    if (theData)
    {
      if (CFDataGetLength(theData) >= 65501)
      {
        Length = CFDataGetLength(theData);
        syslog(3, "*** ERROR: ImageIO - xmpData size exceeds 64KB limit (%ld)\n", Length);
        v98 = v51;
        v24 = 0;
        v40 = 0;
        v15 = (uint64_t)v101;
LABEL_151:
        v26 = v40;
        v51 = v98;
        goto LABEL_153;
      }
      if (theData)
      {
        v15 = (uint64_t)v101;
        v60 = (_APP1XMP *)operator new();
        _APP1XMP::_APP1XMP(v60, theData);
        _JPEGFile::insertAppMarker((_JPEGFile *)v101[2].data, v60);
        CFRelease(theData);
        theData = 0;
        (*(void (**)(_APP1XMP *))(*(_QWORD *)v60 + 8))(v60);
        if (!v106 || !cf)
          goto LABEL_130;
        v95 = v25;
        v97 = v12;
        v99 = v51;
        v61 = CFDataGetLength(v106);
        BytePtr = CFDataGetBytePtr(v106);
        if (v61 >= 1)
        {
          v63 = BytePtr;
          v64 = 0;
          v65 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v66 = v61;
          do
          {
            if (v66 >= 65000)
              v67 = 65000;
            else
              v67 = v66;
            v68 = CFDataCreate(v65, &v63[v64], v67);
            v69 = (_APP1ExtendedXMP *)operator new();
            _APP1ExtendedXMP::_APP1ExtendedXMP(v69, v68, v64, v61, (const __CFData *)cf);
            CFRelease(v68);
            _JPEGFile::insertAppMarker((_JPEGFile *)v101[2].data, v69);
            v64 += 65000;
            v66 -= 65000;
          }
          while (v64 < v61);
        }
        CFRelease(v106);
        v106 = 0;
        CFRelease(cf);
        goto LABEL_129;
      }
    }
    if (v51)
    {
      v103 = 0;
      v15 = (uint64_t)v101;
      if (v25)
      {
        v70 = (const char *)CFDataGetBytePtr(v51);
        v71 = CFDataGetLength(v51);
        MetadataFromXMPBuffer = CreateMetadataFromXMPBuffer(v70, v71);
        v73 = MetadataFromXMPBuffer;
        if (MetadataFromXMPBuffer)
        {
          metadataSetSource((uint64_t)MetadataFromXMPBuffer, 4);
          *(_QWORD *)v110 = 0;
          v111 = 0;
          v112 = 0;
          IIODictionary::IIODictionary((IIODictionary *)v110);
          IIODictionary::setObjectForKey((IIODictionary *)v110, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageMetadataMergeOverwrite"));
          CGImageMetadataMerge((uint64_t)v25, (uint64_t)v73, (IIODictionary *)v110);
          CFRelease(v73);
          IIODictionary::~IIODictionary((IIODictionary *)v110);
        }
        CGImageMetadataCreateSerializedDataAndExtendedData((CFDictionaryRef *)v25, (CFDataRef *)&v103, &v106, (CFDataRef *)&cf);
        Copy = v103;
      }
      else
      {
        Copy = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v51);
        v103 = Copy;
      }
      if (!Copy)
      {
LABEL_174:
        v98 = v51;
        v24 = 0;
        v40 = 0;
        goto LABEL_151;
      }
      v75 = (_APP1XMP *)operator new();
      _APP1XMP::_APP1XMP(v75, (const __CFData *)v103);
      _JPEGFile::insertAppMarker((_JPEGFile *)v101[2].data, v75);
      CFRelease(v103);
      if (v106 && cf)
      {
        v95 = v25;
        v97 = v12;
        v99 = v51;
        v76 = CFDataGetLength(v106);
        v77 = CFDataGetBytePtr(v106);
        if (v76 >= 1)
        {
          v78 = v77;
          v79 = 0;
          v80 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v81 = v76;
          do
          {
            if (v81 >= 65000)
              v82 = 65000;
            else
              v82 = v81;
            v83 = CFDataCreate(v80, &v78[v79], v82);
            v84 = (_APP1ExtendedXMP *)operator new();
            _APP1ExtendedXMP::_APP1ExtendedXMP(v84, v83, v79, v76, (const __CFData *)cf);
            CFRelease(v83);
            _JPEGFile::insertAppMarker((_JPEGFile *)v101[2].data, v84);
            v79 += 65000;
            v81 -= 65000;
          }
          while (v79 < v76);
        }
        CFRelease(v106);
        v106 = 0;
        CFRelease(cf);
LABEL_129:
        cf = 0;
        v25 = v95;
        v12 = v97;
        v15 = (uint64_t)v101;
        v51 = v99;
      }
    }
    else
    {
      v15 = (uint64_t)v101;
    }
  }
  else
  {
    v25 = 0;
  }
LABEL_130:
  v85 = *(_QWORD *)(v15 + 80);
  v86 = *(_QWORD *)(v85 + 72);
  v87 = *(_QWORD *)(v85 + 80);
  while (v86 != v87)
  {
    v88 = *(_BYTE **)v86;
    if (*(__int16 *)(*(_QWORD *)v86 + 56) == -31 && v88[68])
      goto LABEL_136;
    v86 += 8;
  }
  v88 = 0;
LABEL_136:
  if (CopyOrientationFromParams((IIODictionary *)v108, &v104))
  {
    if ((unsigned __int16)(v104 - 9) <= 0xFFF7u)
      v104 = 1;
    if (v88)
      (*(void (**)(_BYTE *))(*(_QWORD *)v88 + 152))(v88);
  }
  if (!CopyDateTimeFromParams((IIODictionary *)v108, (char *)&v109)
    || v88
    && LOBYTE(v109.st_dev)
    && !(*(unsigned int (**)(_BYTE *, stat *))(*(_QWORD *)v88 + 136))(v88, &v109))
  {
    goto LABEL_174;
  }
  v89 = CopyProfileFromParams((IIODictionary *)v108);
  if (!v89
    || (v90 = _JPEGFile::setICCProfile(*(_JPEGFile **)(v15 + 80), (CFDataRef)v89), CFRelease(v89), (v90 & 1) != 0))
  {
    v98 = v51;
    if (v102 == CFStringGetTypeID())
    {
      _JPEGWriter::writeToPath((_JPEGWriter *)v15, v100);
    }
    else
    {
      Data = (const __CFData *)_JPEGWriter::createData((_JPEGWriter *)v15);
      v92 = CFDataGetBytePtr(Data);
      v93 = CFDataGetLength(Data);
      CFDataAppendBytes((CFMutableDataRef)v100, v92, v93);
      CFRelease(Data);
    }
    v40 = 0;
    v24 = 1;
    goto LABEL_151;
  }
  v26 = 0;
  v24 = 0;
LABEL_153:
  (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  if (v51)
    CFRelease(v51);
LABEL_155:
  if (theData)
    CFRelease(theData);
  if (v106)
    CFRelease(v106);
  if (cf)
    CFRelease(cf);
  if (v26)
    CFRelease(v26);
  if (v13)
    CFRelease(v13);
  if (v12)
    free(v12);
  if (v25)
    CFRelease(v25);
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v108);
  return v24;
}

void sub_18801D3B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  uint64_t v45;

  if (a2)
  {
    __cxa_begin_catch(exception_object);
    syslog(3, "*** ERROR: ImageIO - CGImageCopyFileWithParameters failed\n");
    __cxa_end_catch();
    if (!v45)
      JUMPOUT(0x18801D230);
    JUMPOUT(0x18801D220);
  }
  _Unwind_Resume(exception_object);
}

void ExifScanner::~ExifScanner(ExifScanner *this)
{
  void *v1;

  *(_QWORD *)this = &off_1E1BABDA0;
  v1 = (void *)*((_QWORD *)this + 4);
  if (v1)
    free(v1);
}

{
  void *v1;

  *(_QWORD *)this = &off_1E1BABDA0;
  v1 = (void *)*((_QWORD *)this + 4);
  if (v1)
    free(v1);
  JUMPOUT(0x18D761C30);
}

uint64_t ExifScanner::setup(ExifScanner *this, uint64_t a2)
{
  size_t v3;
  uint64_t result;
  unsigned int v5;

  *((_BYTE *)this + 24) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_BYTE *)this + 80) = 0;
  if (a2 >= 0x4000)
    v3 = 0x4000;
  else
    v3 = a2;
  *((_QWORD *)this + 5) = v3;
  *((_QWORD *)this + 6) = a2;
  *((_QWORD *)this + 4) = malloc_type_malloc(v3, 0x805AAED5uLL);
  (*(void (**)(ExifScanner *))(*(_QWORD *)this + 16))(this);
  result = ExifScanner::read16(this);
  if ((_DWORD)result == 65496)
  {
    result = ExifScanner::read16(this);
    if (result >= 0x100)
    {
      *((_BYTE *)this + 80) = 1;
      if ((_DWORD)result == 65505)
      {
        v5 = ExifScanner::read16(this);
        result = (*(uint64_t (**)(ExifScanner *, uint64_t))(*(_QWORD *)this + 32))(this, *((_QWORD *)this + 7) + v5 + 12);
      }
    }
  }
  *((_QWORD *)this + 7) = 0;
  return result;
}

uint64_t ExifScanner::read16(ExifScanner *this)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  uint64_t v4;

  v1 = *((_QWORD *)this + 7);
  if (v1 < 0 || v1 >= *((_QWORD *)this + 5) - 2)
    return 0;
  v4 = *((_QWORD *)this + 4) + v1;
  v2 = *(unsigned __int8 *)v4;
  LODWORD(v4) = *(unsigned __int8 *)(v4 + 1);
  v3 = v2 | ((_DWORD)v4 << 8);
  LODWORD(v4) = v4 | (v2 << 8);
  if (*((_BYTE *)this + 24))
    v4 = v3;
  else
    v4 = v4;
  *((_QWORD *)this + 7) = v1 + 2;
  return v4;
}

ssize_t ExifScanner::fillBuffer(ExifScanner *this)
{
  return read(*((_DWORD *)this + 2), *((void **)this + 4), *((_QWORD *)this + 5));
}

BOOL ExifScanner::growBufferSize(ExifScanner *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  _BOOL8 v5;
  size_t v6;
  uint64_t v7;
  char *v8;

  v2 = *((_QWORD *)this + 5);
  if (a2 - v2 < 1)
    return 1;
  v4 = *((_QWORD *)this + 6);
  v5 = v4 >= a2;
  if (v4 < a2)
    v6 = v4 - v2;
  else
    v6 = a2 - v2;
  if (v4 > v2)
  {
    v7 = v4 >= a2 ? a2 : *((_QWORD *)this + 6);
    *((_QWORD *)this + 5) = v7;
    _cg_jpeg_mem_term("growBufferSize", 2878, "growBufferSize %p - from %6ld to %6ld (max = %ld)\n", *((const void **)this + 4), v2, v7, v4);
    v8 = (char *)reallocf(*((void **)this + 4), *((_QWORD *)this + 5));
    *((_QWORD *)this + 4) = v8;
    if (v8)
    {
      if (read(*((_DWORD *)this + 2), &v8[v2], v6) != v6)
      {
        _cg_jpeg_mem_term("growBufferSize", 2886, "growBufferSize - failed to read %zu bytes\n", v6);
        return 0;
      }
      return 1;
    }
  }
  return v5;
}

uint64_t ExifScanner::read32(ExifScanner *this)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  unsigned int v5;
  uint64_t v6;

  v1 = *((_QWORD *)this + 7);
  if (v1 < 0 || v1 >= *((_QWORD *)this + 5) - 4)
    return 0;
  v6 = *((_QWORD *)this + 4) + v1;
  v2 = *(unsigned __int8 *)v6;
  v3 = *(unsigned __int8 *)(v6 + 1);
  v4 = *(unsigned __int8 *)(v6 + 2);
  LODWORD(v6) = *(unsigned __int8 *)(v6 + 3);
  v5 = (v2 << 24) | (v3 << 16) | (v4 << 8) | v6;
  LODWORD(v6) = v2 | (v3 << 8) | (v4 << 16) | ((_DWORD)v6 << 24);
  if (*((_BYTE *)this + 24))
    v6 = v6;
  else
    v6 = v5;
  *((_QWORD *)this + 7) = v1 + 4;
  return v6;
}

void ExifScanner::addTag(ExifScanner *this, int a2, const __CFString *a3)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  unsigned __int16 v14;
  unsigned int v15;
  const __CFAllocator *v16;
  unsigned __int16 *p_valuePtr;
  CFNumberType v18;
  unsigned int v19;
  IIODictionary *PropertiesFromAppleMakerNote;
  IIODictionary *v21;
  __CFDictionary *v22;
  const __CFDictionary *ObjectForKey;
  uint64_t v24;
  uint64_t v25;
  const void *v26;
  const void *v27;
  unsigned int v28;
  unsigned __int16 valuePtr;

  v6 = *((_QWORD *)this + 7);
  v7 = ExifScanner::read16(this);
  v8 = ExifScanner::read32(this);
  v9 = v8;
  switch(v7)
  {
    case 2:
      if (v8 < 5)
      {
        if (v8 < 2)
          goto LABEL_27;
        v24 = *((_QWORD *)this + 4);
        v25 = *((_QWORD *)this + 7);
        *((_QWORD *)this + 7) = v25 + 4;
        if (!v24)
          goto LABEL_27;
        v13 = (const char *)(v24 + v25);
      }
      else
      {
        v10 = ExifScanner::read32(this);
        v11 = *((_QWORD *)this + 8);
        if ((int64_t)(v10 + (unint64_t)v9 + v11) >= *((_QWORD *)this + 5))
          goto LABEL_27;
        v12 = *((_QWORD *)this + 4);
        v13 = (const char *)(v12 + v11 + v10);
        if ((unsigned __int16)(a2 + 28669) <= 2u && v9 == 20 && v12)
        {
          if (!strncmp(v13, "                   ", 0x14uLL))
            goto LABEL_27;
        }
        else if (!v12)
        {
          goto LABEL_27;
        }
      }
      if (strlen(v13) == v9 - 1)
      {
        v26 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v13, 0x8000100u);
        if (v26)
          goto LABEL_26;
      }
LABEL_27:
      *((_QWORD *)this + 7) = v6 + 10;
      return;
    case 3:
      v14 = ExifScanner::read16(this);
      valuePtr = v14;
      if (a2 == 274)
      {
        if ((unsigned __int16)(v14 - 9) <= 0xFFF7u)
          valuePtr = 1;
      }
      else if (a2 == 513)
      {
        valuePtr = v14 + *((_WORD *)this + 32);
        *((_QWORD *)this + 9) = valuePtr;
      }
      v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      p_valuePtr = &valuePtr;
      v18 = kCFNumberSInt16Type;
      goto LABEL_25;
    case 4:
      v15 = ExifScanner::read32(this);
      v28 = v15;
      if (a2 == 513)
      {
        v28 = v15 + *((_DWORD *)this + 16);
        *((_QWORD *)this + 9) = v28;
      }
      v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      p_valuePtr = (unsigned __int16 *)&v28;
      v18 = kCFNumberSInt32Type;
LABEL_25:
      v26 = CFNumberCreate(v16, v18, p_valuePtr);
      if (v26)
      {
LABEL_26:
        v27 = v26;
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), a3, v26);
        CFRelease(v27);
      }
      goto LABEL_27;
    case 7:
      if (a2 == 37500)
      {
        v19 = ExifScanner::read32(this);
        PropertiesFromAppleMakerNote = CreatePropertiesFromAppleMakerNote((unsigned __int8 *)(*((_QWORD *)this + 4) + *((_QWORD *)this + 8) + v19), v9);
        if (PropertiesFromAppleMakerNote)
        {
          v21 = PropertiesFromAppleMakerNote;
          v22 = (__CFDictionary *)*((_QWORD *)this + 2);
          ObjectForKey = IIODictionary::getObjectForKey(PropertiesFromAppleMakerNote, CFSTR("{MakerApple}"));
          CFDictionaryAddValue(v22, a3, ObjectForKey);
          (*(void (**)(IIODictionary *))(*(_QWORD *)v21 + 8))(v21);
        }
      }
      goto LABEL_27;
    default:
      _cg_jpeg_mem_term("addTag", 3066, "ExifScanner::addTag: unknown tag type: %d\n", v7);
      goto LABEL_27;
  }
}

void ExifScanner::handleThumbnailIFD(ExifScanner *this)
{
  unsigned int v2;
  unsigned int v4;
  unsigned int i;
  int v6;
  ExifScanner *v7;
  int v8;
  const __CFString *v9;

  v2 = ExifScanner::read16(this);
  if (*((_QWORD *)this + 7) + 12 * v2 + 4 <= *((_QWORD *)this + 5) && v2 != 0)
  {
    v4 = v2;
    for (i = 0; i < v4; ++i)
    {
      v6 = ExifScanner::read16(this);
      if (v6 == 514)
      {
        v7 = this;
        v8 = 514;
        v9 = CFSTR("ThumbnailSize");
      }
      else
      {
        if (v6 != 513)
        {
          *((_QWORD *)this + 7) += 10;
          continue;
        }
        v7 = this;
        v8 = 513;
        v9 = CFSTR("ThumbnailOffset");
      }
      ExifScanner::addTag(v7, v8, v9);
    }
  }
}

void ExifScanner::handleExifIFD(ExifScanner *this)
{
  unsigned int v2;
  unsigned int v4;
  unsigned int i;
  int v6;
  ExifScanner *v7;
  int v8;
  const __CFString *v9;

  v2 = ExifScanner::read16(this);
  if (*((_QWORD *)this + 7) + 12 * v2 + 4 <= *((_QWORD *)this + 5) && v2 != 0)
  {
    v4 = v2;
    for (i = 0; i < v4; ++i)
    {
      v6 = ExifScanner::read16(this);
      if (v6 <= 37499)
      {
        if (v6 <= 36879)
        {
          if (v6 == 36867)
          {
            v7 = this;
            v8 = 36867;
            v9 = CFSTR("DateTimeOriginal");
          }
          else
          {
            if (v6 != 36868)
            {
LABEL_35:
              *((_QWORD *)this + 7) += 10;
              continue;
            }
            v7 = this;
            v8 = 36868;
            v9 = CFSTR("DateTimeDigitized");
          }
        }
        else
        {
          switch(v6)
          {
            case 36880:
              v7 = this;
              v8 = 36880;
              v9 = CFSTR("OffsetTime");
              break;
            case 36881:
              v7 = this;
              v8 = 36881;
              v9 = CFSTR("OffsetTimeOriginal");
              break;
            case 36882:
              v7 = this;
              v8 = 36882;
              v9 = CFSTR("OffsetTimeDigitized");
              break;
            default:
              goto LABEL_35;
          }
        }
      }
      else if (v6 > 37521)
      {
        switch(v6)
        {
          case 37522:
            v7 = this;
            v8 = 37522;
            v9 = CFSTR("SubsecTimeDigitized");
            break;
          case 40962:
            v7 = this;
            v8 = 40962;
            v9 = CFSTR("PixelXDimension");
            break;
          case 40963:
            v7 = this;
            v8 = 40963;
            v9 = CFSTR("PixelYDimension");
            break;
          default:
            goto LABEL_35;
        }
      }
      else
      {
        switch(v6)
        {
          case 37500:
            v7 = this;
            v8 = 37500;
            v9 = CFSTR("{MakerApple}");
            break;
          case 37520:
            v7 = this;
            v8 = 37520;
            v9 = CFSTR("SubsecTime");
            break;
          case 37521:
            v7 = this;
            v8 = 37521;
            v9 = CFSTR("SubsecTimeOriginal");
            break;
          default:
            goto LABEL_35;
        }
      }
      ExifScanner::addTag(v7, v8, v9);
    }
  }
}

void ExifScanner::handleIFD(ExifScanner *this)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int i;
  int v5;
  ExifScanner *v6;
  int v7;
  const __CFString *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;

  v2 = ExifScanner::read16(this);
  if (*((_QWORD *)this + 7) + 12 * v2 + 4 <= *((_QWORD *)this + 5))
  {
    v3 = v2;
    if (v2)
    {
      for (i = 0; i < v3; ++i)
      {
        v5 = ExifScanner::read16(this);
        if (v5 <= 273)
        {
          switch(v5)
          {
            case 256:
              v6 = this;
              v7 = 256;
              v8 = CFSTR("PixelWidth");
              goto LABEL_24;
            case 257:
              v6 = this;
              v7 = 257;
              v8 = CFSTR("PixelHeight");
              goto LABEL_24;
            case 258:
              v6 = this;
              v7 = 258;
              v8 = CFSTR("Depth");
              goto LABEL_24;
          }
        }
        else if (v5 > 305)
        {
          if (v5 == 306)
          {
            v6 = this;
            v7 = 306;
            v8 = CFSTR("DateTime");
            goto LABEL_24;
          }
          if (v5 == 34665)
          {
            ExifScanner::read16(this);
            ExifScanner::read32(this);
            v9 = ExifScanner::read32(this);
            if (v9)
            {
              v10 = *((_QWORD *)this + 7);
              v11 = *((_QWORD *)this + 8) + v9;
              *((_QWORD *)this + 7) = v11;
              if (v11 < *((_QWORD *)this + 5))
                ExifScanner::handleExifIFD(this);
              *((_QWORD *)this + 7) = v10;
            }
            continue;
          }
        }
        else
        {
          if (v5 == 274)
          {
            v6 = this;
            v7 = 274;
            v8 = CFSTR("Orientation");
            goto LABEL_24;
          }
          if (v5 == 277)
          {
            v6 = this;
            v7 = 277;
            v8 = CFSTR("SamplesPerPixel");
LABEL_24:
            ExifScanner::addTag(v6, v7, v8);
            continue;
          }
        }
        *((_QWORD *)this + 7) += 10;
      }
    }
    v12 = ExifScanner::read32(this);
    if (v12)
    {
      v13 = *((_QWORD *)this + 7);
      v14 = *((_QWORD *)this + 8) + v12;
      *((_QWORD *)this + 7) = v14;
      if (v14 < *((_QWORD *)this + 5))
        ExifScanner::handleThumbnailIFD(this);
      *((_QWORD *)this + 7) = v13;
    }
  }
}

void ExifScanner::addExifMetaData(ExifScanner *this, unsigned __int16 a2, uint64_t a3)
{
  *((_QWORD *)this + 7) = a3 + 8;
  *((_QWORD *)this + 8) = a3 + 8;
  if (a3 + 18 <= *((_QWORD *)this + 5))
  {
    *((_BYTE *)this + 24) = ExifScanner::read16(this) == 18761;
    *((_QWORD *)this + 7) += 2;
    *((_QWORD *)this + 7) = *((_QWORD *)this + 8) + ExifScanner::read32(this);
    ExifScanner::handleIFD(this);
  }
}

void ExifScanner::addThumbnailSizes(ExifScanner *this)
{
  uint64_t v1;
  int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;
  const __CFAllocator *v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  __int16 v17;
  __int16 v18;
  __int16 valuePtr;

  v1 = *((_QWORD *)this + 9);
  if (v1 <= *((_QWORD *)this + 5))
  {
    *((_BYTE *)this + 24) = 0;
    *((_QWORD *)this + 7) = v1;
    if (ExifScanner::read16(this) == 65496)
    {
      v3 = ExifScanner::read16(this);
      v4 = ExifScanner::read16(this);
      if ((v3 & 0xFFFFFFFD) == 0xFFC0)
      {
LABEL_7:
        v8 = *((_QWORD *)this + 4);
        v9 = *((_QWORD *)this + 7);
        *((_QWORD *)this + 7) = v9 + 1;
        v10 = *(unsigned __int8 *)(v8 + v9);
        v17 = ExifScanner::read16(this);
        v18 = ExifScanner::read16(this);
        v11 = *((_QWORD *)this + 4);
        v12 = *((_QWORD *)this + 7);
        *((_QWORD *)this + 7) = v12 + 1;
        valuePtr = *(unsigned __int8 *)(v11 + v12) * v10;
        v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt16Type, &valuePtr);
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), CFSTR("BitsPerPixel"), v14);
        CFRelease(v14);
        v15 = CFNumberCreate(v13, kCFNumberSInt16Type, &v18);
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), CFSTR("ThumbnailWidth"), v15);
        CFRelease(v15);
        v16 = CFNumberCreate(v13, kCFNumberSInt16Type, &v17);
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), CFSTR("ThumbnailHeight"), v16);
        CFRelease(v16);
      }
      else
      {
        v5 = v4;
        while (1)
        {
          v6 = v5 + *((_QWORD *)this + 7) - 2;
          *((_QWORD *)this + 7) = v6;
          if (v6 > *((_QWORD *)this + 5) - 4)
            break;
          v7 = ExifScanner::read16(this);
          v5 = ExifScanner::read16(this);
          if ((v7 & 0xFFFFFFFD) == 0xFFC0)
            goto LABEL_7;
        }
      }
    }
  }
}

void ExifScanner::addMetaData(ExifScanner *this, __CFDictionary *a2)
{
  unsigned __int16 v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  *((_QWORD *)this + 2) = a2;
  if (!a2 || ExifScanner::read16(this) != 65496)
    return;
  while (1)
  {
    v3 = ExifScanner::read16(this);
    v4 = ExifScanner::read16(this);
    if (v3 != 65505)
    {
      if (v3 == 65475 || v3 == 65499)
        return;
      goto LABEL_8;
    }
    v5 = *((_QWORD *)this + 7);
    if (!strncmp((const char *)(*((_QWORD *)this + 4) + v5), "Exif", 4uLL))
      break;
LABEL_8:
    if (v4 <= 2)
    {
      v7 = *((_QWORD *)this + 4);
      v6 = *((_QWORD *)this + 7);
      while (*(unsigned __int8 *)(v7 + v6) != 255)
      {
        if (v6 >= *((_QWORD *)this + 5) - 4)
        {
          v8 = (*(uint64_t (**)(ExifScanner *, uint64_t))(*(_QWORD *)this + 32))(this, v6 + 0x4000);
          v6 = *((_QWORD *)this + 7);
          if (!v8)
            break;
          v7 = *((_QWORD *)this + 4);
        }
        else
        {
          *((_QWORD *)this + 7) = ++v6;
        }
      }
    }
    else
    {
      v6 = *((_QWORD *)this + 7) + v4 - 2;
      *((_QWORD *)this + 7) = v6;
    }
    if (!(*(unsigned int (**)(ExifScanner *, uint64_t))(*(_QWORD *)this + 32))(this, v6 + 10)
      || *((_QWORD *)this + 7) > *((_QWORD *)this + 5) - 4)
    {
      return;
    }
  }
  if ((*(unsigned int (**)(ExifScanner *, uint64_t))(*(_QWORD *)this + 32))(this, v5 + v4 - 2))
  {
    ExifScanner::addExifMetaData(this, 0, *((_QWORD *)this + 7) - 2);
    if (*((_QWORD *)this + 9))
      ExifScanner::addThumbnailSizes(this);
  }
}

void ExifScannerDP::ExifScannerDP(ExifScannerDP *this, CGDataProviderSequentialCallbacks *a2, void *a3, uint64_t a4)
{
  __int128 v4;
  CGDataProviderReleaseInfoCallback releaseInfo;

  *(_QWORD *)this = &off_1E1BACA70;
  *((_DWORD *)this + 2) = 0;
  v4 = *(_OWORD *)&a2->version;
  releaseInfo = a2->releaseInfo;
  *(_OWORD *)((char *)this + 104) = *(_OWORD *)&a2->skipForward;
  *(_OWORD *)((char *)this + 88) = v4;
  *((_QWORD *)this + 15) = releaseInfo;
  *((_QWORD *)this + 16) = a3;
  ExifScanner::setup(this, a4);
}

void sub_18801E53C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void *v3;

  *v1 = &off_1E1BABDA0;
  v3 = (void *)v1[4];
  if (v3)
    free(v3);
  _Unwind_Resume(exception_object);
}

void ExifScannerDP::~ExifScannerDP(ExifScannerDP *this)
{
  void *v1;

  *(_QWORD *)this = &off_1E1BABDA0;
  v1 = (void *)*((_QWORD *)this + 4);
  if (v1)
    free(v1);
}

{
  void *v1;

  *(_QWORD *)this = &off_1E1BABDA0;
  v1 = (void *)*((_QWORD *)this + 4);
  if (v1)
    free(v1);
  JUMPOUT(0x18D761C30);
}

unint64_t ExifScannerDP::fillBuffer(ExifScannerDP *this)
{
  void (*v2)(_QWORD);
  uint64_t (*v3)(_QWORD, _QWORD, _QWORD);
  unint64_t v4;
  unint64_t v5;

  v2 = (void (*)(_QWORD))*((_QWORD *)this + 14);
  if (v2)
    v2(*((_QWORD *)this + 16));
  v3 = (uint64_t (*)(_QWORD, _QWORD, _QWORD))*((_QWORD *)this + 12);
  if (v3)
    v4 = v3(*((_QWORD *)this + 16), *((_QWORD *)this + 4), *((_QWORD *)this + 5));
  else
    v4 = 0;
  v5 = *((_QWORD *)this + 5);
  if (v4 < v5)
    LogError("fillBuffer", 3417, "*** ERROR: 'getBytes' returned %zu bytes (expected: %zu bytes)", v4, v5);
  return v4;
}

BOOL ExifScannerDP::growBufferSize(ExifScannerDP *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  _BOOL8 v6;
  char *v7;

  v2 = *((_QWORD *)this + 5);
  v3 = a2 - v2;
  if (a2 - v2 < 1)
    return 1;
  v5 = *((_QWORD *)this + 6);
  v6 = v5 >= a2;
  if (v2 < v5)
  {
    if (v5 >= a2)
      v5 = a2;
    *((_QWORD *)this + 5) = v5;
    _cg_jpeg_mem_term("growBufferSize", 3444, "growBufferSize - from %6ld to %6ld\n", v2, v5);
    v7 = (char *)reallocf(*((void **)this + 4), *((_QWORD *)this + 5));
    *((_QWORD *)this + 4) = v7;
    if (v7)
    {
      if ((*((uint64_t (**)(_QWORD, char *, uint64_t))this + 12))(*((_QWORD *)this + 16), &v7[v2], v3) != v3)
      {
        _cg_jpeg_mem_term("growBufferSize", 3454, "growBufferSize - failed to read %zu bytes\n", v3);
        return 0;
      }
      return 1;
    }
  }
  return v6;
}

void ExifScannerCFData::ExifScannerCFData(ExifScannerCFData *this, CFTypeRef cf, int a3, __CFDictionary *a4)
{
  const __CFData *v6;
  CFIndex Length;

  *(_QWORD *)this = &off_1E1BB1008;
  *((_QWORD *)this + 2) = a4;
  v6 = (const __CFData *)CFRetain(cf);
  *((_QWORD *)this + 11) = v6;
  *((_DWORD *)this + 24) = a3;
  Length = CFDataGetLength(v6);
  (*(void (**)(ExifScannerCFData *, CFIndex))(*(_QWORD *)this + 24))(this, Length);
  *((_QWORD *)this + 5) = Length;
}

void sub_18801E798(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void *v3;

  *v1 = &off_1E1BABDA0;
  v3 = (void *)v1[4];
  if (v3)
    free(v3);
  _Unwind_Resume(exception_object);
}

void ExifScannerCFData::ExifScannerCFData(ExifScannerCFData *this, CFTypeRef cf)
{
  CFIndex Length;

  *(_QWORD *)this = &off_1E1BB1008;
  *((_QWORD *)this + 11) = CFRetain(cf);
  Length = CFDataGetLength((CFDataRef)cf);
  (*(void (**)(ExifScannerCFData *, CFIndex))(*(_QWORD *)this + 24))(this, Length);
  *((_QWORD *)this + 5) = Length;
}

void sub_18801E820(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void *v3;

  *v1 = &off_1E1BABDA0;
  v3 = (void *)v1[4];
  if (v3)
    free(v3);
  _Unwind_Resume(exception_object);
}

void ExifScannerCFData::~ExifScannerCFData(CFTypeRef *this)
{
  void *v2;

  *this = &off_1E1BB1008;
  CFRelease(this[11]);
  *this = &off_1E1BABDA0;
  v2 = (void *)this[4];
  if (v2)
    free(v2);
}

{
  ExifScannerCFData::~ExifScannerCFData(this);
  JUMPOUT(0x18D761C30);
}

uint64_t ExifScannerCFData::fillBuffer(ExifScannerCFData *this)
{
  void *v2;
  const UInt8 *BytePtr;

  v2 = (void *)*((_QWORD *)this + 4);
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 11));
  memcpy(v2, BytePtr, *((_QWORD *)this + 5));
  return *((_QWORD *)this + 5);
}

BOOL ExifScannerCFData::growBufferSize(ExifScannerCFData *this, unint64_t a2)
{
  return *((_QWORD *)this + 5) > a2;
}

__CFDictionary *CopyMetadataFromFileAtPath(const void *a1, off_t a2)
{
  CFTypeID v4;
  __CFDictionary *v5;
  char v7[1024];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyMetadataFromFileAtPath", 0, 0, -1, 0);
  if (a1
    && (v4 = CFGetTypeID(a1), v4 == CFStringGetTypeID())
    && (bzero(v7, 0x400uLL), _CFStringGetFileSystemRepresentation()))
  {
    v5 = _copyMetadataFromFileAtPath(v7, a2);
  }
  else
  {
    v5 = 0;
  }
  kdebug_trace();
  return v5;
}

__CFDictionary *_copyMetadataFromFileAtPath(const char *a1, off_t st_size)
{
  int v4;
  int v5;
  IIO_ReaderHandler *v6;
  uint8x8_t v7;
  uint64_t v8;
  __CFDictionary *Mutable;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v11;
  void *v12;
  int v13;
  int v14;
  uint64_t v15;
  unsigned int v17;
  CFDataRef theData;
  stat v19;
  _OWORD v20[4];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = open(a1, 0, 0);
  v5 = v4;
  if ((gIIODebugFlags & 0x200000000000) != 0)
    ImageIOLog(">>> %s: opening file [%d] '%s'\n", "_copyMetadataFromFileAtPath", v4, a1);
  memset(v20, 0, sizeof(v20));
  if (v5 < 0)
  {
    Mutable = 0;
    if (v5 == -1)
      return Mutable;
    goto LABEL_22;
  }
  fcntl(v5, 48, 1);
  fcntl(v5, 62, 1);
  if (!st_size)
  {
    memset(&v19, 0, sizeof(v19));
    if (fstat(v5, &v19) < 0)
    {
LABEL_19:
      Mutable = 0;
      goto LABEL_22;
    }
    st_size = v19.st_size;
  }
  if (st_size < 201)
    goto LABEL_19;
  read(v5, v20, 0x40uLL);
  v6 = (IIO_ReaderHandler *)lseek(v5, 0, 0);
  if (LOBYTE(v20[0]) != 255 || BYTE1(v20[0]) != 216)
  {
    v7.i32[0] = DWORD1(v20[0]);
    if (vmovn_s16((int16x8_t)vmovl_u8(v7)).u32[0] == 1887007846)
    {
      ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v6);
      v11 = IIO_ReaderHandler::readerForUTType(ReaderHandler, CFSTR("public.heic"));
      if (v11)
      {
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v12 = malloc_type_malloc(0x19000uLL, 0x124C548uLL);
        theData = 0;
        v17 = 0;
        read(v5, v12, 0x19000uLL);
        v13 = (*(uint64_t (**)(IIO_Reader *, void *, uint64_t, __CFDictionary *, unsigned int *, CFDataRef *))(*(_QWORD *)v11 + 224))(v11, v12, 102400, Mutable, &v17, &theData);
        if (theData)
          v14 = v13;
        else
          v14 = 0;
        if (v14 == 1)
        {
          memset(&v19, 0, 104);
          ExifScannerCFData::ExifScannerCFData((ExifScannerCFData *)&v19, theData, v17, Mutable);
          v15 = v17;
          CFDataGetLength(theData);
          ExifScanner::addExifMetaData((ExifScanner *)&v19, 0, v15 - 8);
          ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)&v19);
        }
        goto LABEL_22;
      }
    }
    goto LABEL_19;
  }
  v8 = operator new();
  *(_QWORD *)v8 = &off_1E1BABDA0;
  *(_DWORD *)(v8 + 8) = v5;
  ExifScanner::setup((ExifScanner *)v8, st_size);
  if (*(_BYTE *)(v8 + 80))
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    ExifScanner::addMetaData((ExifScanner *)v8, Mutable);
  }
  else
  {
    Mutable = 0;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
LABEL_22:
  if ((gIIODebugFlags & 0x200000000000) != 0)
    ImageIOLog("<<< %s: closing file [%d] '%s'\n", "_copyMetadataFromFileAtPath", v5, a1);
  close(v5);
  return Mutable;
}

void sub_18801ED80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)va);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef CopyMetadataFromCFData(CFMutableDictionaryRef Mutable)
{
  CFTypeID v2;
  CFIndex Length;
  CFIndex v4;
  ExifScannerCFData *v5;
  UInt8 *BytePtr;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v8;
  IIO_Reader *v9;
  const UInt8 *v10;
  uint64_t v12;
  _OWORD v14[6];
  uint64_t v15;
  unsigned int v16;
  CFTypeRef v17;

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyMetadataFromCFData", 0, 0, -1, 0);
  if (Mutable)
  {
    v2 = CFGetTypeID(Mutable);
    if (v2 == CFDataGetTypeID())
    {
      Length = CFDataGetLength(Mutable);
      if (Length >= 201)
      {
        v4 = Length;
        if (*CFDataGetBytePtr(Mutable) == 255 && CFDataGetBytePtr(Mutable)[1] == 216)
        {
          v5 = (ExifScannerCFData *)operator new();
          ExifScannerCFData::ExifScannerCFData(v5, Mutable);
          if (*((_BYTE *)v5 + 80))
          {
            Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            ExifScanner::addMetaData(v5, Mutable);
          }
          else
          {
            Mutable = 0;
          }
          (*(void (**)(ExifScannerCFData *))(*(_QWORD *)v5 + 8))(v5);
          goto LABEL_21;
        }
        if (CFDataGetBytePtr(Mutable)[4] == 102
          && CFDataGetBytePtr(Mutable)[5] == 116
          && CFDataGetBytePtr(Mutable)[6] == 121)
        {
          BytePtr = (UInt8 *)CFDataGetBytePtr(Mutable);
          if (BytePtr[7] == 112)
          {
            ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)BytePtr);
            v8 = IIO_ReaderHandler::readerForUTType(ReaderHandler, CFSTR("public.heic"));
            if (v8)
            {
              v9 = v8;
              v17 = 0;
              v16 = 0;
              v10 = CFDataGetBytePtr(Mutable);
              if ((*(unsigned int (**)(IIO_Reader *, const UInt8 *, CFIndex, _QWORD, unsigned int *, CFTypeRef *))(*(_QWORD *)v9 + 224))(v9, v10, v4, 0, &v16, &v17)&& v17 != 0)
              {
                v15 = 0;
                memset(v14, 0, sizeof(v14));
                ExifScannerCFData::ExifScannerCFData((ExifScannerCFData *)v14, v17, v16, 0);
                v12 = v16;
                CFDataGetLength((CFDataRef)v17);
                ExifScanner::addExifMetaData((ExifScanner *)v14, 0, v12 - 8);
                ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)v14);
              }
            }
          }
        }
      }
    }
    Mutable = 0;
  }
LABEL_21:
  kdebug_trace();
  return Mutable;
}

void sub_18801F034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CFTypeRef a9)
{
  ExifScannerCFData::~ExifScannerCFData(&a9);
  _Unwind_Resume(a1);
}

__CFDictionary *CopyMetadataFromSequentialDataProviderCallbacks(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  uint8x8_t v7;
  uint64_t (*v8)(void *);
  uint64_t (*v9)(void *, _DWORD *, uint64_t);
  uint64_t (*v10)(void *);
  ExifScannerDP *v11;
  __int128 v12;
  __CFDictionary *Mutable;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v15;
  void *v16;
  void (*v17)(void *, void *, uint64_t);
  int v18;
  int v19;
  uint64_t v20;
  _OWORD v22[6];
  uint64_t v23;
  unsigned int v24;
  CFDataRef theData;
  CGDataProviderSequentialCallbacks v26;
  _DWORD v27[18];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  IIOInitDebugFlags();
  v6 = (unsigned __int16)gIIODebugFlags >> 14;
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions(v6, "S", "CopyMetadataFromSequentialDataProviderCallbacks", 0, 0, -1, 0);
  if (a3 < 201)
    return 0;
  v7.i32[1] = 0;
  memset(v27, 0, 64);
  v8 = *(uint64_t (**)(void *))(a1 + 24);
  if (v8)
    v6 = v8(a2);
  v9 = *(uint64_t (**)(void *, _DWORD *, uint64_t))(a1 + 8);
  if (v9)
    v6 = v9(a2, v27, 64);
  v10 = *(uint64_t (**)(void *))(a1 + 24);
  if (v10)
    v6 = v10(a2);
  if (LOBYTE(v27[0]) == 255 && BYTE1(v27[0]) == 216)
  {
    v11 = (ExifScannerDP *)operator new();
    v12 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&v26.version = *(_OWORD *)a1;
    *(_OWORD *)&v26.skipForward = v12;
    v26.releaseInfo = *(CGDataProviderReleaseInfoCallback *)(a1 + 32);
    ExifScannerDP::ExifScannerDP(v11, &v26, a2, a3);
    if (*((_BYTE *)v11 + 80))
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      ExifScanner::addMetaData(v11, Mutable);
    }
    else
    {
      Mutable = 0;
    }
    (*(void (**)(ExifScannerDP *))(*(_QWORD *)v11 + 8))(v11);
    return Mutable;
  }
  v7.i32[0] = v27[1];
  if (vmovn_s16((int16x8_t)vmovl_u8(v7)).u32[0] != 1887007846)
    return 0;
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)v6);
  v15 = IIO_ReaderHandler::readerForUTType(ReaderHandler, CFSTR("public.heic"));
  if (!v15)
    return 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v16 = malloc_type_malloc(0x19000uLL, 0x6DE9ECF6uLL);
  theData = 0;
  v24 = 0;
  v17 = *(void (**)(void *, void *, uint64_t))(a1 + 8);
  if (v17)
    v17(a2, v16, 102400);
  v18 = (*(uint64_t (**)(IIO_Reader *, void *, uint64_t, __CFDictionary *, unsigned int *, CFDataRef *))(*(_QWORD *)v15 + 224))(v15, v16, 102400, Mutable, &v24, &theData);
  if (theData)
    v19 = v18;
  else
    v19 = 0;
  if (v19 == 1)
  {
    v23 = 0;
    memset(v22, 0, sizeof(v22));
    ExifScannerCFData::ExifScannerCFData((ExifScannerCFData *)v22, theData, v24, Mutable);
    v20 = v24;
    CFDataGetLength(theData);
    ExifScanner::addExifMetaData((ExifScanner *)v22, 0, v20 - 8);
    ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)v22);
  }
  return Mutable;
}

void sub_18801F338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)va);
  _Unwind_Resume(a1);
}

__CFDictionary *CGCopyBasicPropertiesOfImageAtPath(const char *a1, const __CFDictionary *a2)
{
  const __CFNumber *Value;
  const __CFNumber *v5;
  off_t v6;
  __CFDictionary *v7;
  off_t v9;
  unsigned int v10;
  unsigned __int16 v11;
  unsigned __int8 valuePtr;

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGCopyBasicPropertiesOfImageAtPath", 0, a1, -1, a2);
  if (a2 && (Value = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("size"))) != 0)
  {
    v5 = Value;
    switch(CFNumberGetType(Value))
    {
      case kCFNumberSInt8Type:
        valuePtr = 0;
        CFNumberGetValue(v5, kCFNumberSInt8Type, &valuePtr);
        v6 = valuePtr;
        break;
      case kCFNumberSInt16Type:
        v11 = 0;
        CFNumberGetValue(v5, kCFNumberSInt16Type, &v11);
        v6 = v11;
        break;
      case kCFNumberSInt32Type:
        v10 = 0;
        CFNumberGetValue(v5, kCFNumberSInt32Type, &v10);
        v6 = v10;
        break;
      case kCFNumberSInt64Type:
        v9 = 0;
        CFNumberGetValue(v5, kCFNumberSInt64Type, &v9);
        v6 = v9;
        break;
      default:
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    v6 = 0;
  }
  v7 = _copyMetadataFromFileAtPath(a1, v6);
  kdebug_trace();
  return v7;
}

CFDataRef CGImageCreateEXIFDataFromProperties(const __CFDictionary *a1, const __CFDictionary *a2)
{
  _BOOL4 BoolForKey;
  char v5;
  _JPEGWriter *v6;
  const __CFData *v7;
  CFAllocatorRef *v8;
  const __CFData *Copy;
  uint64_t v10;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFDataRef v13;
  _QWORD v15[3];
  _QWORD v16[3];

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateEXIFDataFromProperties", 0, 0, -1, a2);
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, a1);
  memset(v15, 0, sizeof(v15));
  IIODictionary::IIODictionary((IIODictionary *)v15, a2);
  if (IIODictionary::containsKey((IIODictionary *)v15, CFSTR("kCGImageEXIFDataIncludeEXIFHeader")))
    BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v15, CFSTR("kCGImageEXIFDataIncludeEXIFHeader"));
  else
    BoolForKey = 1;
  if (IIODictionary::containsKey((IIODictionary *)v15, CFSTR("kCGImageEXIFDataAddMissingTags")))
  {
    v5 = IIODictionary::getBoolForKey((IIODictionary *)v15, CFSTR("kCGImageEXIFDataAddMissingTags"));
    if (!a1)
      goto LABEL_20;
  }
  else
  {
    v5 = 1;
    if (!a1)
    {
LABEL_20:
      LogError("CGImageCreateEXIFDataFromProperties", 3932, "*** ERROR: CGImageCreateEXIFDataFromProperties failed (properties is nil)\n");
      goto LABEL_21;
    }
  }
  v6 = (_JPEGWriter *)operator new();
  _JPEGWriter::_JPEGWriter(v6, 0, 0, 0, (IIODictionary *)v16, 0, v5);
  _JPEGWriter::processInput(v6);
  v7 = (const __CFData *)*((_QWORD *)v6 + 9);
  v8 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v7)
    Copy = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7);
  else
    Copy = 0;
  (*(void (**)(_JPEGWriter *))(*(_QWORD *)v6 + 8))(v6);
  if (!Copy)
    goto LABEL_20;
  v10 = BoolForKey ? 6 : 12;
  BytePtr = CFDataGetBytePtr(Copy);
  Length = CFDataGetLength(Copy);
  v13 = CFDataCreate(*v8, &BytePtr[v10], Length - v10);
  CFRelease(Copy);
  if (!v13)
    goto LABEL_20;
  if (!CFDataGetLength(v13))
  {
    LogError("CGImageCreateEXIFDataFromProperties", 3926, "*** ERROR: CGImageCreateEXIFDataFromProperties failed (zero-length)\n");
    CFRelease(v13);
LABEL_21:
    v13 = 0;
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v15);
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  return v13;
}

void sub_18801F790()
{
  __cxa_end_catch();
  JUMPOUT(0x18801F7A4);
}

char *std::vector<_APPx *>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_QWORD *)v8 - 1);
      v8 -= 8;
      *((_QWORD *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

void std::vector<_APPx *>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *((_QWORD *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

uint64_t TIFFInitZIP(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v20;
  char v21;

  if (a2 != 8 && a2 != 32946)
    TIFFInitZIP_cold_1();
  if (_TIFFMergeFields((uint64_t)a1, zipFields, 2, a4, a5, a6, a7, a8))
  {
    v14 = _TIFFcallocExt(a1, 272, 1, v9, v10, v11, v12, v13);
    a1[137] = v14;
    if (v14)
    {
      v14[24] = 0;
      v14[25] = 0;
      *((_DWORD *)v14 + 54) = 0;
      v14[26] = 0;
      v17 = a1[161];
      a1[161] = ZIPVGetField;
      v18 = a1[160];
      v14[32] = v17;
      v14[33] = v18;
      a1[160] = ZIPVSetField;
      *(_QWORD *)((char *)v14 + 244) = 0xFFFFFFFFLL;
      *((_DWORD *)v14 + 63) = 0;
      a1[119] = ZIPFixupTags;
      a1[120] = ZIPSetupDecode;
      a1[121] = ZIPPreDecode;
      a1[126] = ZIPDecode;
      a1[128] = ZIPDecode;
      a1[130] = ZIPDecode;
      a1[122] = ZIPSetupEncode;
      a1[124] = ZIPPreEncode;
      a1[125] = ZIPPostEncode;
      a1[127] = ZIPEncode;
      a1[129] = ZIPEncode;
      a1[131] = ZIPEncode;
      a1[134] = ZIPCleanup;
      TIFFPredictorInit((uint64_t)a1, v15, v16, v9, v10, v11, v12, v13);
      return 1;
    }
    v20 = "No space for ZIP state block";
  }
  else
  {
    v20 = "Merging Deflate codec-specific tags failed";
  }
  TIFFErrorExtR((uint64_t)a1, "TIFFInitZIP", v20, v9, v10, v11, v12, v13, v21);
  return 0;
}

uint64_t ZIPVGetField(uint64_t a1, int a2, _DWORD **a3)
{
  uint64_t v3;
  int v4;

  v3 = *(_QWORD *)(a1 + 1096);
  if (a2 == 65570)
  {
    v4 = *(_DWORD *)(v3 + 252);
    goto LABEL_5;
  }
  if (a2 == 65557)
  {
    v4 = *(_DWORD *)(v3 + 244);
LABEL_5:
    **a3 = v4;
    return 1;
  }
  return (*(uint64_t (**)(void))(v3 + 256))();
}

uint64_t ZIPVSetField(uint64_t a1, int a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  unsigned int v11;
  char *v12;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  char v21;

  v9 = *(_QWORD *)(a1 + 1096);
  if (a2 == 65570)
  {
    v11 = *a3;
    *(_DWORD *)(v9 + 252) = *a3;
    if (v11 >= 2)
    {
      v12 = "Invalid DeflateCodec value.";
    }
    else
    {
      if (v11 != 1)
        return 1;
      v12 = "DeflateCodec = DEFLATE_SUBCODEC_LIBDEFLATE unsupported in this build";
    }
    TIFFErrorExtR(a1, "ZIPVSetField", v12, a4, a5, a6, a7, a8, v21);
    return 0;
  }
  if (a2 != 65557)
    return (*(uint64_t (**)(uint64_t))(v9 + 264))(a1);
  v10 = *a3;
  *(_DWORD *)(v9 + 244) = *a3;
  if ((v10 - 13) > 0xFFFFFFF1)
  {
    if ((*(_BYTE *)(v9 + 248) & 2) != 0)
    {
      v14 = v10 >= 9 ? 9 : v10;
      if (deflateParams((z_streamp)(v9 + 128), v14, 0))
      {
        v20 = *(const char **)(v9 + 176);
        if (!v20)
          v20 = "";
        TIFFErrorExtR(a1, "ZIPVSetField", "ZLib error: %s", v15, v16, v17, v18, v19, (char)v20);
        return 0;
      }
    }
    return 1;
  }
  TIFFErrorExtR(a1, "ZIPVSetField", "Invalid ZipQuality value. Should be in [-1,%d] range", a4, a5, a6, a7, a8, 12);
  return 0;
}

uint64_t ZIPFixupTags()
{
  return 1;
}

uint64_t ZIPSetupDecode(uint64_t a1)
{
  uint64_t v1;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;

  v1 = *(_QWORD *)(a1 + 1096);
  if (!v1)
    ZIPSetupDecode_cold_1();
  v3 = *(_DWORD *)(v1 + 248);
  if ((v3 & 2) != 0)
  {
    deflateEnd((z_streamp)(v1 + 128));
    *(_DWORD *)(v1 + 248) = 0;
  }
  else if ((v3 & 1) != 0)
  {
    goto LABEL_11;
  }
  if (!inflateInit_((z_streamp)(v1 + 128), "1.2.12", 112))
  {
    v3 = *(_DWORD *)(v1 + 248);
LABEL_11:
    *(_DWORD *)(v1 + 248) = v3 | 1;
    return 1;
  }
  v9 = *(const char **)(v1 + 176);
  if (!v9)
    v9 = "";
  TIFFErrorExtR(a1, "ZIPSetupDecode", "%s", v4, v5, v6, v7, v8, (char)v9);
  return 0;
}

uint64_t ZIPPreDecode(uint64_t a1)
{
  uint64_t v1;
  unint64_t v3;

  v1 = *(_QWORD *)(a1 + 1096);
  if (!v1)
    ZIPPreDecode_cold_1();
  if ((*(_BYTE *)(v1 + 248) & 1) == 0)
    (*(void (**)(uint64_t))(a1 + 960))(a1);
  *(_QWORD *)(v1 + 128) = *(_QWORD *)(a1 + 1120);
  v3 = *(_QWORD *)(a1 + 1160);
  if (v3 >= 0xFFFFFFFF)
    LODWORD(v3) = -1;
  *(_DWORD *)(v1 + 136) = v3;
  if (inflateReset((z_streamp)(v1 + 128)))
    return 0;
  *(_DWORD *)(v1 + 240) = 0;
  return 1;
}

uint64_t ZIPDecode(uint64_t a1, void *a2, size_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  unint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;

  v3 = *(_QWORD *)(a1 + 1096);
  if (!v3)
    ZIPDecode_cold_1();
  if (*(_DWORD *)(v3 + 248) != 1)
    ZIPDecode_cold_2();
  v4 = a3;
  if (*(_DWORD *)(v3 + 240))
  {
    bzero(a2, a3);
    TIFFErrorExtR(a1, "ZIPDecode", "ZIPDecode: Scanline %u cannot be read due to previous error", v6, v7, v8, v9, v10, *(_DWORD *)(a1 + 876));
    return 0;
  }
  *(_QWORD *)(v3 + 128) = *(_QWORD *)(a1 + 1152);
  *(_QWORD *)(v3 + 152) = a2;
  v12 = *(_QWORD *)(a1 + 1160);
  while (1)
  {
    v13 = HIDWORD(v12) ? -1 : v12;
    v14 = (unint64_t)v4 >= 0xFFFFFFFF ? -1 : v4;
    *(_DWORD *)(v3 + 136) = v13;
    *(_DWORD *)(v3 + 160) = v14;
    v15 = inflate((z_streamp)(v3 + 128), 1);
    v12 = *(_QWORD *)(a1 + 1160) - (v13 - *(_DWORD *)(v3 + 136));
    *(_QWORD *)(a1 + 1160) = v12;
    v21 = *(unsigned int *)(v3 + 160);
    v4 -= (v14 - v21);
    if (v15)
      break;
    if (v4 <= 0)
      goto LABEL_18;
  }
  if (v15 != 1)
  {
    if (v15 == -3)
    {
      bzero(*(void **)(v3 + 152), v21);
      TIFFErrorExtR(a1, "ZIPDecode", "Decoding error at scanline %lu, %s", v22, v23, v24, v25, v26, *(_DWORD *)(a1 + 876));
    }
    else
    {
      bzero(*(void **)(v3 + 152), v21);
      v32 = *(const char **)(v3 + 176);
      if (!v32)
        v32 = "";
      TIFFErrorExtR(a1, "ZIPDecode", "ZLib error: %s", v27, v28, v29, v30, v31, (char)v32);
    }
    goto LABEL_23;
  }
LABEL_18:
  if (v4)
  {
    TIFFErrorExtR(a1, "ZIPDecode", "Not enough data at scanline %lu (short %llu bytes)", v16, v17, v18, v19, v20, *(_DWORD *)(a1 + 876));
    bzero(*(void **)(v3 + 152), *(unsigned int *)(v3 + 160));
LABEL_23:
    result = 0;
    *(_DWORD *)(v3 + 240) = 1;
    return result;
  }
  *(_QWORD *)(a1 + 1152) = *(_QWORD *)(v3 + 128);
  return 1;
}

uint64_t ZIPSetupEncode(uint64_t a1)
{
  uint64_t v1;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;

  v1 = *(_QWORD *)(a1 + 1096);
  if (!v1)
    ZIPSetupEncode_cold_1();
  if ((*(_BYTE *)(v1 + 248) & 1) != 0)
  {
    inflateEnd((z_streamp)(v1 + 128));
    *(_DWORD *)(v1 + 248) = 0;
  }
  if (*(int *)(v1 + 244) >= 9)
    v3 = 9;
  else
    v3 = *(_DWORD *)(v1 + 244);
  if (deflateInit_((z_streamp)(v1 + 128), v3, "1.2.12", 112))
  {
    v9 = *(const char **)(v1 + 176);
    if (!v9)
      v9 = "";
    TIFFErrorExtR(a1, "ZIPSetupEncode", "%s", v4, v5, v6, v7, v8, (char)v9);
    return 0;
  }
  else
  {
    *(_DWORD *)(v1 + 248) |= 2u;
    return 1;
  }
}

BOOL ZIPPreEncode(uint64_t a1)
{
  uint64_t v1;
  unint64_t v3;

  v1 = *(_QWORD *)(a1 + 1096);
  if (!v1)
    ZIPPreEncode_cold_1();
  if (*(_DWORD *)(v1 + 248) != 2)
    (*(void (**)(uint64_t))(a1 + 976))(a1);
  *(_QWORD *)(v1 + 152) = *(_QWORD *)(a1 + 1120);
  v3 = *(_QWORD *)(a1 + 1128);
  if (HIDWORD(v3))
    LODWORD(v3) = -1;
  *(_DWORD *)(v1 + 160) = v3;
  return deflateReset((z_streamp)(v1 + 128)) == 0;
}

uint64_t ZIPPostEncode(_QWORD *a1)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t result;
  unint64_t v14;
  const char *v15;

  v2 = a1[137];
  *(_DWORD *)(v2 + 136) = 0;
  while (1)
  {
    v3 = deflate((z_streamp)(v2 + 128), 4);
    if (v3 > 1)
      break;
    v11 = v3;
    v12 = a1[141] - *(unsigned int *)(v2 + 160);
    if (v12)
    {
      a1[145] = v12;
      result = TIFFFlushData1((uint64_t)a1, v4, v5, v6, v7, v8, v9, v10);
      if (!(_DWORD)result)
        return result;
      *(_QWORD *)(v2 + 152) = a1[140];
      v14 = a1[141];
      if (HIDWORD(v14))
        LODWORD(v14) = -1;
      *(_DWORD *)(v2 + 160) = v14;
    }
    if (v11 == 1)
      return 1;
  }
  v15 = *(const char **)(v2 + 176);
  if (!v15)
    v15 = "";
  TIFFErrorExtR((uint64_t)a1, "ZIPPostEncode", "ZLib error: %s", v6, v7, v8, v9, v10, (char)v15);
  return 0;
}

uint64_t ZIPEncode(_QWORD *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  const char *v18;

  v3 = a1[137];
  if (!v3)
    ZIPEncode_cold_1();
  if (*(_DWORD *)(v3 + 248) != 2)
    ZIPEncode_cold_2();
  *(_QWORD *)(v3 + 128) = a2;
  while (1)
  {
    v6 = HIDWORD(a3) ? -1 : a3;
    *(_DWORD *)(v3 + 136) = v6;
    if (deflate((z_streamp)(v3 + 128), 0))
      break;
    if (!*(_DWORD *)(v3 + 160))
    {
      a1[145] = a1[141];
      result = TIFFFlushData1((uint64_t)a1, v7, v8, v9, v10, v11, v12, v13);
      if (!(_DWORD)result)
        return result;
      *(_QWORD *)(v3 + 152) = a1[140];
      v15 = a1[141];
      if (HIDWORD(v15))
        LODWORD(v15) = -1;
      *(_DWORD *)(v3 + 160) = v15;
    }
    v16 = (v6 - *(_DWORD *)(v3 + 136));
    v17 = (uint64_t)a3 <= v16;
    a3 -= v16;
    if (v17)
      return 1;
  }
  v18 = *(const char **)(v3 + 176);
  if (!v18)
    v18 = "";
  TIFFErrorExtR((uint64_t)a1, "ZIPEncode", "Encoder error: %s", v9, v10, v11, v12, v13, (char)v18);
  return 0;
}

uint64_t ZIPCleanup(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  int v4;

  v1 = a1[137];
  if (!v1)
    ZIPCleanup_cold_1();
  TIFFPredictorCleanup(a1);
  v3 = *(_QWORD *)(v1 + 264);
  a1[161] = *(_QWORD *)(v1 + 256);
  a1[160] = v3;
  v4 = *(_DWORD *)(v1 + 248);
  if ((v4 & 2) != 0)
  {
    deflateEnd((z_streamp)(v1 + 128));
    goto LABEL_6;
  }
  if ((v4 & 1) != 0)
  {
    inflateEnd((z_streamp)(v1 + 128));
LABEL_6:
    *(_DWORD *)(v1 + 248) = 0;
  }
  _TIFFfreeExt((uint64_t)a1, (char *)v1);
  a1[137] = 0;
  return _TIFFSetDefaultCompressionState((uint64_t)a1);
}

void ImageIOSetLoggingProc(void (*a1)(int a1, const char *a2, const char *a3, int a4, const char *a5, va_list a6))
{
  void (*v2)(int, const char *, const char *, int, const char *, va_list);

  IIOInitDebugFlags();
  v2 = ImageIOLogger;
  if (a1)
    v2 = a1;
  gImageIOLogProc = (uint64_t (*)(int, const char *, const char *, int, const char *, char *))v2;
}

const char *LogModuleWithArguments(const char *result, const char *a2, char *a3)
{
  if (gImageIOLogProc)
    return (const char *)gImageIOLogProc(0, result, 0, 0, a2, a3);
  return result;
}

const char *LogFault(const char *result, int a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  if (gImageIOLogProc)
    return (const char *)gImageIOLogProc(17, 0, result, a2, a3, va);
  return result;
}

void IIOLogAndCreateError(__CFError **a1, const __CFString *a2, CFIndex a3, const char *a4, int a5, const char *a6, ...)
{
  const __CFAllocator *v10;
  CFStringRef v11;
  uint64_t v12;
  CFDictionaryRef userInfo;
  CFStringRef v14;
  char *v15;
  va_list va;

  va_start(va, a6);
  va_copy(v15, va);
  if (gImageIOLogProc)
    gImageIOLogProc(16, "*** ERROR: ", a4, a5, a6, v15);
  if (a1)
  {
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    IIOString::IIOString((IIOString *)&v12, a6);
    v11 = CFStringCreateWithFormatAndArguments(v10, 0, v14, v15);
    IIOString::~IIOString((IIOString *)&v12);
    v12 = 0;
    userInfo = 0;
    v14 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v12);
    IIODictionary::setObjectForKey((IIODictionary *)&v12, v11, (const __CFString *)*MEMORY[0x1E0C9AFB0]);
    *a1 = CFErrorCreate(v10, a2, a3, userInfo);
    IIODictionary::~IIODictionary((IIODictionary *)&v12);
  }
}

void sub_188020484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOString::~IIOString((IIOString *)&a9);
  _Unwind_Resume(a1);
}

const char *ImageIOLog(const char *result, ...)
{
  va_list va;

  va_start(va, result);
  if (gImageIOLogProc)
    return (const char *)gImageIOLogProc(0, 0, 0, 0, result, va);
  return result;
}

uint64_t ImageIOLogInternal(const char *a1, ...)
{
  uint64_t result;
  va_list va;

  va_start(va, a1);
  result = IIO_OSAppleInternalBuild();
  if ((_DWORD)result)
  {
    if (gImageIOLogProc)
      return gImageIOLogProc(0, 0, 0, 0, a1, va);
  }
  return result;
}

void IIOWriteStream::IIOWriteStream(IIOWriteStream *this, unsigned __int8 *a2, uint64_t a3, char a4)
{
  *(_QWORD *)this = &off_1E1BAE448;
  *((_QWORD *)this + 1) = a2;
  *((_BYTE *)this + 32) = a4;
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
}

void IIOWriteStream::~IIOWriteStream(IIOWriteStream *this)
{
  JUMPOUT(0x18D761C30);
}

uint64_t IIOWriteStream::write16(uint64_t this, __int16 a2)
{
  __int16 v2;
  __int16 v3;

  v2 = __rev16(a2);
  if (*(_BYTE *)(this + 32))
    v3 = a2;
  else
    v3 = v2;
  *(_WORD *)(*(_QWORD *)(this + 8) + *(_QWORD *)(this + 24)) = v3;
  *(_QWORD *)(this + 24) += 2;
  return this;
}

uint64_t IIOWriteStream::write32(uint64_t this, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;

  v2 = bswap32(a2);
  if (*(_BYTE *)(this + 32))
    v3 = a2;
  else
    v3 = v2;
  *(_DWORD *)(*(_QWORD *)(this + 8) + *(_QWORD *)(this + 24)) = v3;
  *(_QWORD *)(this + 24) += 4;
  return this;
}

uint64_t IIOWriteStream::write64(uint64_t this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = bswap64(a2);
  if (*(_BYTE *)(this + 32))
    v3 = a2;
  else
    v3 = v2;
  *(_QWORD *)(*(_QWORD *)(this + 8) + *(_QWORD *)(this + 24)) = v3;
  *(_QWORD *)(this + 24) += 8;
  return this;
}

void *IIOWriteStream::writeBytes(IIOWriteStream *this, unsigned __int8 *a2, size_t a3)
{
  void *result;

  result = memcpy((void *)(*((_QWORD *)this + 1) + *((_QWORD *)this + 3)), a2, a3);
  *((_QWORD *)this + 3) += a3;
  return result;
}

uint64_t CGImageMetadataPropertyGetTypeID()
{
  if (CGImageMetadataPropertyGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataPropertyGetTypeID::once, &__block_literal_global_28);
  return CGImageMetadataPropertyGetTypeID::id;
}

double _CGImageMetadataPropertyFinalize(CFTypeRef cf)
{
  unsigned int v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  double result;

  v2 = (gIIODebugFlags >> 12) & 3;
  if (v2)
    ImageIODebugOptions(v2, "A", "_CGImageMetadataPropertyFinalize", cf, 0, -1, 0);
  v3 = (const void *)*((_QWORD *)cf + 2);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)cf + 2) = 0;
  v4 = (const void *)*((_QWORD *)cf + 3);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)cf + 3) = 0;
  v5 = (const void *)*((_QWORD *)cf + 4);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)cf + 4) = 0;
  v6 = (const void *)*((_QWORD *)cf + 5);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)cf + 6) = 0;
  result = 0.0;
  *((_OWORD *)cf + 1) = 0u;
  *((_OWORD *)cf + 2) = 0u;
  return result;
}

CFStringRef _CGImageMetadataPropertyCopyDebugDesc(CFTypeRef cf)
{
  const __CFAllocator *v2;
  const __CFAllocator *v4;

  if (*((_QWORD *)cf + 3) && *((_QWORD *)cf + 4) && *((_QWORD *)cf + 5))
  {
    v2 = CFGetAllocator(cf);
    return CFStringCreateWithFormat(v2, 0, CFSTR("<CGImageMetadataProperty %p> (schema = \"%@\", name = \"%@\", value = %@)"), cf, *((_QWORD *)cf + 3), *((_QWORD *)cf + 4), *((_QWORD *)cf + 5));
  }
  else
  {
    v4 = CFGetAllocator(cf);
    return CFStringCreateCopy(v4, CFSTR("<CGImageMetadataProperty> (invalid)"));
  }
}

uint64_t CGImageMetadataPropertyCreate(const __CFString *a1, const void *a2, const void *a3)
{
  uint64_t Instance;
  void *v7;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageMetadataPropertyCreate", 0, 0, -1, 0);
  Instance = 0;
  if (a1 && a3)
  {
    if (CGImageMetadataPropertyGetTypeID::once != -1)
      dispatch_once(&CGImageMetadataPropertyGetTypeID::once, &__block_literal_global_28);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      *(_QWORD *)(Instance + 16) = CFRetain(a1);
      if (a2)
        v7 = (void *)CFRetain(a2);
      else
        v7 = CGImageMetadataDefaultPrefixForSchema(a1);
      *(_QWORD *)(Instance + 24) = v7;
      *(_QWORD *)(Instance + 32) = CFRetain(a3);
      *(_QWORD *)(Instance + 40) = 0;
      *(_DWORD *)(Instance + 48) = 0;
    }
  }
  return Instance;
}

uint64_t CGImageMetadataPropertyGetSchema(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t CGImageMetadataPropertyGetSuggestedPrefix(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t CGImageMetadataPropertyGetPropertyName(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageMetadataPropertyGetPropertyName", 0, 0, -1, 0);
  if (a1)
    return *(_QWORD *)(a1 + 32);
  else
    return 0;
}

void CGImageMetadataPropertySetValue(uint64_t a1, const void *a2)
{
  const void *v4;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageMetadataPropertySetValue", 0, 0, -1, 0);
  if (a1)
  {
    v4 = *(const void **)(a1 + 40);
    if (v4 != a2)
    {
      if (v4)
        CFRelease(v4);
      *(_QWORD *)(a1 + 40) = a2;
      if (a2)
        CFRetain(a2);
    }
  }
}

uint64_t CGImageMetadataPropertyGetValue(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageMetadataPropertyGetValue", 0, 0, -1, 0);
  if (a1)
    return *(_QWORD *)(a1 + 40);
  else
    return 0;
}

void BMPWritePlugin::BMPWritePlugin(BMPWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  _QWORD *v3;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 5u);
  *v3 = &off_1E1BAE040;
}

void BMPWritePlugin::~BMPWritePlugin(BMPWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t BMPWritePlugin::writePrefix(BMPWritePlugin *this, CGImageRef image, IIODictionary *a3, int a4)
{
  size_t BytesPerRow;
  size_t Width;
  int Height;
  size_t BitsPerPixel;
  size_t BitsPerComponent;
  CGColorSpace *ColorSpace;
  int Type;
  CGColorSpaceModel Model;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  _BOOL4 v18;
  int v19;
  size_t v20;
  uint64_t result;
  size_t v22;
  size_t v23;
  CGColorSpace *BaseColorSpace;
  CGColorSpace *v25;
  size_t ColorTableCount;
  _BYTE *v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  unint64_t v31;
  unsigned int v32;
  unsigned int v33;
  float FloatForKey;
  _BOOL4 v35;
  _DWORD v37[3];
  __int16 v38;
  __int16 v39;
  int v40;
  int v41;
  uint32x2_t v42;
  int v43;
  int v44;
  __int128 v45;
  _OWORD v46[4];
  int v47;
  uint64_t __ptr;
  __int16 v49;
  int v50;
  _BYTE v51[1024];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  BytesPerRow = CGImageGetBytesPerRow(image);
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  BitsPerPixel = CGImageGetBitsPerPixel(image);
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  ColorSpace = CGImageGetColorSpace(image);
  Type = CGColorSpaceGetType();
  Model = CGColorSpaceGetModel(ColorSpace);
  bzero(v51, 0x400uLL);
  v49 = 0;
  __ptr = 19778;
  v47 = 0;
  memset(v46, 0, sizeof(v46));
  v45 = 0u;
  v15 = 32;
  if (BitsPerComponent == 8)
    v16 = BitsPerPixel;
  else
    v16 = 32;
  if (!a4)
    v15 = 24;
  if (v16 == 32)
    v17 = v15;
  else
    v17 = v16;
  if (v17 == 24)
  {
    v19 = 0;
    v18 = 0;
LABEL_20:
    v20 = 40;
    goto LABEL_21;
  }
  if (v17 != 32)
  {
    v19 = 0;
    v18 = 0;
    if (Model != kCGColorSpaceModelIndexed)
      v17 = v15;
    goto LABEL_20;
  }
  v18 = *((_BYTE *)this + 48) == 0;
  if (*((_BYTE *)this + 48))
    v19 = 0;
  else
    v19 = 3;
  if (*((_BYTE *)this + 48))
    v20 = 40;
  else
    v20 = 124;
LABEL_21:
  result = 0;
  if (BytesPerRow && ColorSpace)
  {
    v35 = v18;
    if (Type == 7)
    {
      BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
      CGColorSpaceGetType();
      CGColorSpaceGetModel(BaseColorSpace);
      v25 = CGColorSpaceGetBaseColorSpace(BaseColorSpace);
      if (CGColorSpaceGetNumberOfComponents(v25) != 3)
        return 0;
      ColorTableCount = CGColorSpaceGetColorTableCount(BaseColorSpace);
      if (ColorTableCount > 0x100)
        return 0;
      v22 = ColorTableCount;
      result = (uint64_t)malloc_type_malloc(3 * ColorTableCount, 0x989A6EB9uLL);
      if (!result)
        return result;
      v27 = (_BYTE *)result;
      CGColorSpaceGetColorTable(BaseColorSpace, (uint8_t *)result);
      if (v22)
      {
        v28 = 0;
        v29 = 2;
        v30 = 1;
        do
        {
          v51[v30 + 1] = v27[v29 - 2];
          v51[v30] = v27[v29 - 1];
          v51[v30 - 1] = v27[v29];
          ++v28;
          v29 += 3;
          v30 += 4;
        }
        while (v28 < v22);
      }
      free(v27);
      v23 = (4 * v22);
    }
    else
    {
      LODWORD(v22) = 0;
      v23 = 0;
    }
    v31 = ((v17 * Width + 31) >> 3) & 0x1FFFFFFFFFFFFFFCLL;
    *((_QWORD *)this + 5) = v31;
    *(_DWORD *)((char *)&__ptr + 2) = v20 + v23 + 14 + v31 * Height;
    v50 = v20 + v23 + 14;
    if (IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &__ptr, 0xEuLL) == 14)
    {
      v37[0] = v20;
      v37[1] = Width;
      v37[2] = -Height;
      v38 = 1;
      v39 = v17;
      v40 = v19;
      v41 = Height * Width * (v17 >> 3);
      v42 = 0;
      v43 = v22;
      v44 = v22;
      v32 = IIODictionary::containsKey(a3, CFSTR("DPIWidth"));
      v33 = IIODictionary::containsKey(a3, CFSTR("DPIHeight"));
      if (v32 && v33)
      {
        FloatForKey = IIODictionary::getFloatForKey(a3, CFSTR("DPIWidth"));
        v42 = vcvt_u32_f32(vadd_f32(vdiv_f32((float32x2_t)__PAIR64__(COERCE_UNSIGNED_INT(IIODictionary::getFloatForKey(a3, CFSTR("DPIHeight"))), LODWORD(FloatForKey)), (float32x2_t)vdup_n_s32(0x3CD013A9u)), (float32x2_t)0x3F0000003F000000));
      }
      if (v35)
      {
        v45 = xmmword_18822B7B0;
        LODWORD(v46[0]) = 1934772034;
        memset((char *)v46 + 4, 0, 48);
      }
      if (IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v37, v20) == v20
        && (Type != 7
         || !(_DWORD)v22
         || IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v51, v23) == v23))
      {
        return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t BMPWritePlugin::writeOneImage(BMPWritePlugin *this, CGImageRef image, IIODictionary *a3, IIODictionary *a4)
{
  unsigned int Height;
  CGBitmapInfo v8;
  int v9;
  uint32_t v10;
  uint64_t v11;
  void *v12;
  _QWORD v14[6];
  vImage_CGImageFormat v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v20[14];
  uint64_t v21;
  vImage_CGImageFormat v22;
  _BYTE v23[24];
  _QWORD v24[3];

  Height = CGImageGetHeight(image);
  if (_ImageHasRealAlphaChannel(image)
    && (!IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationAllowAlpha"))
     || IIODictionary::getBoolForKey(a3, CFSTR("kCGImageDestinationAllowAlpha"))))
  {
    v8 = 3;
    v9 = 1;
  }
  else
  {
    v9 = 0;
    v8 = 0;
  }
  BMPWritePlugin::writePrefix(this, image, a3, v9);
  memset(v24, 0, sizeof(v24));
  IIODictionary::IIODictionary((IIODictionary *)v24);
  IIONumber::IIONumber((IIONumber *)v23, *((_QWORD *)this + 5));
  IIODictionary::setObjectForKey((uint64_t)v24, (uint64_t)v23, CFSTR("DestinationRowBytes"));
  IIONumber::~IIONumber((IIONumber *)v23);
  memset(&v22.bitmapInfo, 0, 24);
  if (v9)
    v10 = 32;
  else
    v10 = 24;
  v22.bitsPerComponent = 8;
  v22.bitsPerPixel = v10;
  v22.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  CGColorSpaceRelease(v22.colorSpace);
  v22.bitmapInfo = v8;
  *(_OWORD *)&v22.version = 0uLL;
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v20, image, &v22, (IIODictionary *)v24);
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 0x40000000;
  v14[2] = ___ZN14BMPWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke;
  v14[3] = &unk_1E1BBD2A8;
  v15 = v22;
  v14[4] = &v16;
  v14[5] = this;
  v11 = IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v20, 0, Height, 16, (uint64_t)v14);
  v12 = (void *)v17[3];
  if (v12)
  {
    free(v12);
    v17[3] = 0;
  }
  _Block_object_dispose(&v16, 8);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v20);
  IIODictionary::~IIODictionary((IIODictionary *)v24);
  return v11;
}

void sub_1880210C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  uint64_t v15;
  va_list va;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  va_list va1;

  va_start(va1, a13);
  va_start(va, a13);
  v15 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v13 - 88));
  _Unwind_Resume(a1);
}

size_t ___ZN14BMPWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke(uint64_t a1, int a2, vImage_Buffer *src)
{
  uint64_t v4;
  int v5;
  IIOImageWriteSession *v7;
  void *data;
  size_t rowBytes;
  vImagePixelCount height;
  vImage_Buffer dest;
  uint8_t permuteMap[2];
  char v14;

  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_DWORD *)(a1 + 52);
  if (v5 == 32)
  {
    LODWORD(dest.data) = 50331906;
    vImagePermuteChannels_ARGB8888(src, src, (const uint8_t *)&dest, 0);
    v7 = *(IIOImageWriteSession **)(v4 + 16);
    rowBytes = src->rowBytes;
    data = src->data;
    height = src->height;
    return IIOImageWriteSession::putBytes(v7, data, height * rowBytes);
  }
  if (v5 == 24)
  {
    v14 = 0;
    *(_WORD *)permuteMap = 258;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = reallocf(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)+ 24), src->height * src->rowBytes);
    dest.data = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    *(_OWORD *)&dest.height = *(_OWORD *)&src->height;
    dest.rowBytes = src->rowBytes;
    vImagePermuteChannels_RGB888(src, &dest, permuteMap, 0);
    v7 = *(IIOImageWriteSession **)(v4 + 16);
    data = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    rowBytes = dest.rowBytes;
    height = dest.height;
    return IIOImageWriteSession::putBytes(v7, data, height * rowBytes);
  }
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v4 + 16), src->data, src->height * src->rowBytes);
}

uint64_t BMPWritePlugin::writeOne(BMPWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t BMPWritePlugin::WriteImageWithSession(BMPWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, CGImage *a4, IIODictionary *a5, IIODictionary *a6)
{
  IIODictionary *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  _OWORD v13[3];
  uint64_t v14;

  v14 = 0;
  memset(v13, 0, sizeof(v13));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v13, this, a2, 5u);
  *(_QWORD *)&v13[0] = &off_1E1BAE040;
  LOBYTE(v14) = 1;
  v9 = BMPWritePlugin::writeOneImage((BMPWritePlugin *)v13, a3, a4, v8);
  _cg_jpeg_mem_term(v13, v10, v11);
  return v9;
}

void sub_1880212C0(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _cg_jpeg_mem_term(&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1880212ACLL);
}

const char *ASTCTwiddler::ASTCTwiddlerImpl::copyFromLinearDataImp(ASTCTwiddler::ASTCTwiddlerImpl *this, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  _QWORD v16[6];

  if (*((_QWORD *)this + 1) >> a6 <= 1uLL)
    v11 = 1;
  else
    v11 = *((_QWORD *)this + 1) >> a6;
  if (*((_QWORD *)this + 2) >> a6 <= 1uLL)
    v12 = 1;
  else
    v12 = *((_QWORD *)this + 2) >> a6;
  *gCrashMessage = 0;
  snprintf(gCrashMessage, 0x200uLL, "ASTC-copyFromLinear: %p    offset: %ld    fileSize: %ld    levelRB: %d    dst: %p   (%dx%d)\n[", a2, a3, a4, a5, *((const void **)this + 5), v11, v12);
  qword_1ECDD8318 = gCrashMessage;
  objc_msgSend(*((id *)this + 7), "initializeTextureMemory:", *((_QWORD *)this + 5));
  v13 = (void *)*((_QWORD *)this + 7);
  v14 = *((_QWORD *)this + 5);
  memset(v16, 0, 24);
  v16[3] = v11;
  v16[4] = v12;
  v16[5] = 1;
  objc_msgSend(v13, "copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:", a2, a3, a5, 0, v14, 0, a6, v16);
  qword_1ECDD8318 = 0;
  return ASTCTwiddler::ASTCTwiddlerImpl::finalizeTwiddlingImp((const char *)this);
}

const char *ASTCTwiddler::ASTCTwiddlerImpl::copyFromTextureDataImp(ASTCTwiddler::ASTCTwiddlerImpl *this, const void *a2, void *a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  void *v7;
  int8x16_t v8;
  int8x16_t v9;
  _QWORD v11[3];
  int64x2_t v12;
  uint64_t v13;

  v7 = (void *)*((_QWORD *)this + 7);
  v8 = (int8x16_t)vshlq_u64(*(uint64x2_t *)((char *)this + 8), (uint64x2_t)vnegq_s64(vdupq_n_s64(a6)));
  v9 = (int8x16_t)vcgtq_u64((uint64x2_t)v8, (uint64x2_t)vdupq_n_s64(1uLL));
  v12 = vsubq_s64((int64x2_t)vandq_s8(v8, v9), (int64x2_t)vmvnq_s8(v9));
  v13 = 1;
  memset(v11, 0, sizeof(v11));
  objc_msgSend(v7, "copyFromTextureMemory:textureSlice:textureLevel:textureRegion:toLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:", a2, 0, (int)a6, v11, a3, a4, a5, 0);
  return ASTCTwiddler::ASTCTwiddlerImpl::finalizeTwiddlingImp((const char *)this);
}

ASTCTwiddler::ASTCTwiddlerImpl *ASTCTwiddler::copyFromLinearData(ASTCTwiddler *this, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  ASTCTwiddler::ASTCTwiddlerImpl *result;

  result = (ASTCTwiddler::ASTCTwiddlerImpl *)*((_QWORD *)this + 1);
  if (result)
    return (ASTCTwiddler::ASTCTwiddlerImpl *)ASTCTwiddler::ASTCTwiddlerImpl::copyFromLinearDataImp(result, a2, a3, a4, a5, a6);
  return result;
}

ASTCTwiddler::ASTCTwiddlerImpl *ASTCTwiddler::copyFromTextureData(ASTCTwiddler *this, const void *a2, void *a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  ASTCTwiddler::ASTCTwiddlerImpl *result;

  result = (ASTCTwiddler::ASTCTwiddlerImpl *)*((_QWORD *)this + 1);
  if (result)
    return (ASTCTwiddler::ASTCTwiddlerImpl *)ASTCTwiddler::ASTCTwiddlerImpl::copyFromTextureDataImp(result, a2, a3, a4, a5, a6);
  return result;
}

int8x8_t TIFFSwabLong8(int8x8_t *a1)
{
  int8x8_t result;

  result = vrev64_s8(*a1);
  *a1 = result;
  return result;
}

uint64_t TIFFSwabArrayOfTriples(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  char *v3;
  char v4;

  if (a2 >= 1)
  {
    v2 = a2 + 1;
    v3 = (char *)(result + 2);
    do
    {
      v4 = *v3;
      *v3 = *(v3 - 2);
      *(v3 - 2) = v4;
      --v2;
      v3 += 3;
    }
    while (v2 > 1);
  }
  return result;
}

__int32 *TIFFSwabArrayOfLong(__int32 *result, uint64_t a2, uint8x8_t a3)
{
  unint64_t v3;
  int16x8_t v4;

  if (a2 >= 1)
  {
    v3 = a2 + 1;
    do
    {
      a3.i32[0] = *result;
      v4 = (int16x8_t)vmovl_u8(a3);
      *(int16x4_t *)v4.i8 = vrev64_s16(*(int16x4_t *)v4.i8);
      a3 = (uint8x8_t)vmovn_s16(v4);
      *result++ = a3.i32[0];
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

int8x8_t *TIFFSwabArrayOfLong8(int8x8_t *result, uint64_t a2)
{
  unint64_t v2;

  if (a2 >= 1)
  {
    v2 = a2 + 1;
    do
    {
      *result = vrev64_s8(*result);
      ++result;
      --v2;
    }
    while (v2 > 1);
  }
  return result;
}

void *TIFFGetBitRevTable(int a1)
{
  if (a1)
    return &TIFFBitRevTable;
  else
    return &TIFFNoBitRevTable;
}

unsigned __int8 *TIFFReverseBits(unsigned __int8 *result, uint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  if (a2 < 9)
  {
    if (a2 <= 0)
      return result;
  }
  else
  {
    v2 = a2;
    do
    {
      *result = TIFFBitRevTable[*result];
      result[1] = TIFFBitRevTable[result[1]];
      result[2] = TIFFBitRevTable[result[2]];
      result[3] = TIFFBitRevTable[result[3]];
      result[4] = TIFFBitRevTable[result[4]];
      result[5] = TIFFBitRevTable[result[5]];
      result[6] = TIFFBitRevTable[result[6]];
      result[7] = TIFFBitRevTable[result[7]];
      result += 8;
      a2 = v2 - 8;
      v3 = v2 > 0x10;
      v2 -= 8;
    }
    while (v3);
  }
  v4 = a2 + 1;
  do
  {
    *result = TIFFBitRevTable[*result];
    ++result;
    --v4;
  }
  while (v4 > 1);
  return result;
}

uint64_t IIO_Reader_JP2::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  JP2ReadPlugin::JP2ReadPlugin(v4, a2, v5);
  return v4;
}

void sub_1880216BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40180D29B7);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_JP2::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  JP2ReadPlugin::JP2ReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_188021758(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40180D29B7);
  _Unwind_Resume(a1);
}

CFDataRef IIO_Reader_JP2::createGlobalInfoData(IIO_Reader_JP2 *this, IIOImageReadSession *a2)
{
  IIOImageRead *v2;
  CFDataRef v3;
  void *v5;
  uint64_t v6;

  v2 = IIOImageReadSession::globalInfoForType(a2, 1246769696);
  if (!v2)
    return 0;
  v5 = 0;
  v6 = 0;
  GlobalJP2Info::GlobalJP2Info((GlobalJP2Info *)&v5, v2);
  HIDWORD(v5) = 0;
  v6 = 0;
  v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)&v5, 16);
  GlobalJP2Info::~GlobalJP2Info(&v5);
  return v3;
}

void sub_1880217F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  GlobalJP2Info::~GlobalJP2Info(&a9);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_JP2::updateGlobalInfo(IIO_Reader_JP2 *this, IIOImageRead **a2, unsigned __int8 *a3, uint64_t a4)
{
  _OWORD *v6;

  if (a3 && a4 == 16)
  {
    v6 = malloc_type_malloc(0x10uLL, 0x1010040449DF08BuLL);
    *v6 = *(_OWORD *)a3;
    IIOImageReadSession::setGlobalInfo(a2, 1246769696, v6, releaseGlobalInfoJP2);
  }
  return 0;
}

BOOL IIO_Reader_JP2::compareOptions(IIO_Reader_JP2 *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  unsigned int Uint32ForKey;
  unsigned int v5;
  int v6;
  int v7;
  _BOOL8 v8;
  _QWORD v10[3];
  _QWORD v11[3];

  memset(v11, 0, sizeof(v11));
  IIODictionary::IIODictionary((IIODictionary *)v11, a2);
  memset(v10, 0, sizeof(v10));
  IIODictionary::IIODictionary((IIODictionary *)v10, a3);
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v11, CFSTR("kCGImageSourceSubsampleFactor"));
  v5 = IIODictionary::getUint32ForKey((IIODictionary *)v10, CFSTR("kCGImageSourceSubsampleFactor"));
  if (Uint32ForKey <= 1)
    v6 = 1;
  else
    v6 = Uint32ForKey;
  if (v5 <= 1)
    v7 = 1;
  else
    v7 = v5;
  v8 = v6 == v7;
  IIODictionary::~IIODictionary((IIODictionary *)v10);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  return v8;
}

void sub_188021914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_JP2::initThumbnail(IIO_Reader *a1, uint64_t a2, int a3, unint64_t a4)
{
  unint64_t v7;
  int v8;
  IIOReadPlugin *v9;
  int v10;

  v7 = 320;
  if (a4 < 0x140)
    v7 = a4;
  if (v7 <= 0xA0)
    v8 = 160;
  else
    v8 = v7;
  v9 = (IIOReadPlugin *)operator new();
  v10 = IIO_Reader::osType(a1);
  JP2ReadPlugin::JP2ReadPlugin((uint64_t)v9, a2, a3, 0, v10);
  IIOReadPlugin::setDecodeMode((uint64_t)v9, 2);
  IIOReadPlugin::setDestMaxPixelSize((uint64_t)v9, v8);
  return IIOReadPlugin::callInitialize(v9);
}

void sub_1880219E4(void *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40180D29B7);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1880219D0);
}

uint64_t IIO_Reader_JP2::hasCustomCompareOptionsProc(IIO_Reader_JP2 *this)
{
  return 1;
}

uint64_t IIO_Reader_JP2::hasCustomThumbnailProc(IIO_Reader_JP2 *this)
{
  return 1;
}

void PVRWritePlugin::PVRWritePlugin(PVRWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, char a4)
{
  uint64_t v5;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 0x18u);
  *(_QWORD *)v5 = &off_1E1BAFC78;
  *(_BYTE *)(v5 + 38) = a4;
  *(_QWORD *)(v5 + 40) = 0;
}

void PVRWritePlugin::PVRWritePlugin(IIOWritePlugin *a1, IIOImageWriteSession *a2, IIOImageDestination *a3, uint64_t a4)
{
  uint64_t v5;

  IIOWritePlugin::IIOWritePlugin(a1, a2, a3, 0x18u);
  *(_QWORD *)v5 = &off_1E1BAFC78;
  *(_BYTE *)(v5 + 38) = 0;
  *(_QWORD *)(v5 + 40) = a4;
}

void PVRWritePlugin::~PVRWritePlugin(PVRWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t PVRWritePlugin::writePVRHeader(IIOImageWriteSession **this, int a2, int a3, int a4)
{
  __int128 v4;
  uint64_t __ptr;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  __int128 v12;
  int v13;

  __ptr = 55727696;
  v7 = 2 * (a4 == 4);
  v8 = 0;
  v9 = 0;
  v10 = a3;
  v11 = a2;
  *(_QWORD *)&v4 = 0x100000001;
  *((_QWORD *)&v4 + 1) = 0x100000001;
  v12 = v4;
  v13 = 0;
  if (IIOImageWriteSession::putBytes(this[2], &__ptr, 0x34uLL) == 52)
    return 0;
  else
    return 4294967246;
}

uint64_t PVRWritePlugin::writeOneImage(PVRWritePlugin *this, CGImageRef image, IIODictionary *a3, IIODictionary *a4)
{
  size_t Width;
  size_t Height;
  CGImageAlphaInfo AlphaInfo;
  const char *v10;
  int v11;
  CGImageAlphaInfo v12;
  int v13;
  unsigned int Uint32ForKey;
  int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  _QWORD v20[8];
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  CGImageAlphaInfo v26;
  _OWORD v27[14];
  uint64_t v28;
  vImage_CGImageFormat v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;

  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  AlphaInfo = CGImageGetAlphaInfo(image);
  v30 = 0;
  v31 = &v30;
  v32 = 0x2000000000;
  v33 = -50;
  if (Width == Height)
  {
    if (Width < 8)
    {
      v10 = "*** can't write PVR - %d x %d (too small)\n";
      v11 = 114;
LABEL_4:
      LogError("writeOneImage", v11, v10, Width, Width);
      goto LABEL_24;
    }
    v12 = AlphaInfo;
    if (!isPowerOf2(Width) || !isPowerOf2(Width))
    {
      v10 = "*** can't write non-power-of-2 PVR - %d x %d\n";
      v11 = 115;
      goto LABEL_4;
    }
    if (IIODictionary::containsKey(a3, CFSTR("kCGImagePropertyPVRBitsPerPixel")))
    {
      if (IIODictionary::getUint32ForKey(a3, CFSTR("kCGImagePropertyPVRBitsPerPixel")) <= 2)
        v13 = 2;
      else
        v13 = 4;
    }
    else
    {
      v13 = 4;
    }
    if (IIODictionary::containsKey(a3, CFSTR("kCGImagePropertyPVRChannelWeighting")))
    {
      Uint32ForKey = IIODictionary::getUint32ForKey(a3, CFSTR("kCGImagePropertyPVRChannelWeighting"));
      if (Uint32ForKey > 2)
        v15 = 1;
      else
        v15 = Uint32ForKey;
    }
    else
    {
      v15 = 1;
    }
    if (IIODictionary::containsKey(a3, CFSTR("kCGImagePropertyPVRPunchThrough")))
    {
      v16 = IIODictionary::getUint32ForKey(a3, CFSTR("kCGImagePropertyPVRPunchThrough"));
      if (v16 <= 2)
        v17 = v16;
      else
        v17 = 0;
    }
    else
    {
      v17 = 0;
    }
    memset(&v29.bitmapInfo, 0, 24);
    *(_QWORD *)&v29.bitsPerComponent = 0x2000000008;
    v29.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
    CGColorSpaceRelease(v29.colorSpace);
    v29.bitmapInfo = 3;
    *(_OWORD *)&v29.version = 0uLL;
    v28 = 0;
    memset(v27, 0, sizeof(v27));
    IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v27, image, &v29, 0);
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 0x40000000;
    v20[2] = ___ZN14PVRWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke;
    v20[3] = &unk_1E1BBD2D0;
    v20[6] = Width;
    v20[7] = Width;
    v21 = v13;
    v22 = 0;
    v23 = v15;
    v24 = 1;
    v20[4] = &v30;
    v20[5] = this;
    v25 = v17;
    v26 = v12;
    IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v27, 0, Width, Width, (uint64_t)v20);
    IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v27);
  }
  else
  {
    LogError("writeOneImage", 112, "*** can't write non-square PVR [%zu x %zu]\n");
  }
LABEL_24:
  v18 = *((unsigned int *)v31 + 6);
  _Block_object_dispose(&v30, 8);
  return v18;
}

void sub_188021DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Block_object_dispose((const void *)(v15 - 112), 8);
  _Unwind_Resume(a1);
}

void ___ZN14PVRWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke(uint64_t a1, uint64_t a2, int8x8_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int __ptr;
  void *v14[2];
  __int128 v15;

  *(_OWORD *)v14 = 0u;
  v15 = 0u;
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 48);
  v6 = *(_QWORD *)(a1 + 56);
  v7 = *(unsigned int *)(a1 + 64);
  if (encodePVRTC(v14, a3, v7, *(unsigned int *)(a1 + 68), *(_DWORD *)(a1 + 72), *(_DWORD *)(a1 + 76), *(_DWORD *)(a1 + 80)))
  {
    v8 = (unint64_t)(v6 * v5 * v7) >> 3;
    v9 = *(_QWORD *)(v4 + 40);
    if (v9)
    {
      if ((*(uint64_t (**)(void))(*(_QWORD *)(v9 + 8) + 24))() == v8)
        (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 64))();
    }
    else
    {
      if (*(_BYTE *)(v4 + 38))
      {
        v10 = *(_DWORD *)(a1 + 64);
        if (v10 == 2)
          v11 = 35843;
        else
          v11 = 0;
        if (v10 == 4)
          v12 = 35842;
        else
          v12 = v11;
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = KTXWritePlugin::writeKTXHeader(*(IIOImageWriteSession **)(v4 + 16), *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 56), 0, 1u, *(_BYTE *)(a1 + 84), 0, 1, 0, v12, 0, 0);
        if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
        {
          __ptr = v8;
          IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v4 + 16), &__ptr, 4uLL);
        }
      }
      else
      {
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = PVRWritePlugin::writePVRHeader((IIOImageWriteSession **)v4, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_DWORD *)(a1 + 64));
      }
      if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
        IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v4 + 16), v14[0], v8);
    }
  }
  if (v14[0])
    free(v14[0]);
}

uint64_t PVRWritePlugin::writeOne(PVRWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

BOOL PVRWritePlugin::WriteProc(PVRWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  _BOOL8 v5;
  uint64_t v6;
  const char *v7;
  _OWORD v9[2];
  __int128 v10;

  v10 = 0u;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 0x18u);
  *(_QWORD *)&v9[0] = &off_1E1BAFC78;
  BYTE6(v10) = 0;
  *((_QWORD *)&v10 + 1) = 0;
  v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9) != 0;
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_188022000(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _cg_jpeg_mem_term(&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x188021FECLL);
}

uint64_t PVRWritePlugin::GetVkFormat(PVRWritePlugin *this, IIODictionary *a2)
{
  uint64_t v3;

  if (!this)
    return 0;
  v3 = 1000054005;
  if (IIODictionary::containsKey(this, CFSTR("kCGImagePropertyPVRBitsPerPixel")))
  {
    if (IIODictionary::getUint32ForKey(this, CFSTR("kCGImagePropertyPVRBitsPerPixel")) >= 3)
      return 1000054005;
    else
      return 1000054004;
  }
  return v3;
}

void _TAGList::_TAGList(_TAGList *this, char a2)
{
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_BYTE *)this + 41) = a2;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E1BB2EE8;
}

void _TAGList::~_TAGList(_TAGList *this)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  *(_QWORD *)this = &off_1E1BB2EE8;
  v2 = (_QWORD *)*((_QWORD *)this + 2);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  if (v2 != v3)
  {
    do
    {
      if (*v2)
        (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 8))(*v2);
      ++v2;
    }
    while (v2 != v3);
    v2 = (_QWORD *)*((_QWORD *)this + 2);
  }
  *((_QWORD *)this + 3) = v2;
  v4 = (void *)*((_QWORD *)this + 1);
  if (v4)
  {
    free(v4);
    *((_QWORD *)this + 1) = 0;
    v2 = (_QWORD *)*((_QWORD *)this + 2);
  }
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
}

{
  _TAGList::~_TAGList(this);
  JUMPOUT(0x18D761C30);
}

__n128 _TAGList::insertTag(_TAGList *this, _TAG *a2)
{
  char *v3;
  char *v4;
  char *v5;
  int v6;
  char *v7;
  unint64_t v8;
  unsigned int v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  __n128 result;
  _TAG *v15;

  v15 = a2;
  v4 = (char *)*((_QWORD *)this + 2);
  v5 = (char *)*((_QWORD *)this + 3);
  v3 = (char *)this + 16;
  if (v4 == v5)
  {
    v4 = v5;
  }
  else
  {
    v6 = *((unsigned __int16 *)a2 + 20);
    v7 = v4;
    do
    {
      if (*(unsigned __int16 *)(*(_QWORD *)v7 + 40) == v6)
        return _cg_jpeg_mem_term("insertTag", 77, "*** ERROR: duplicate _TAG? '%p' (markerID: 0x%04X) already exists\n", a2, v6);
      v7 += 8;
    }
    while (v7 != v5);
    v8 = (v5 - v4) >> 3;
    v9 = *((unsigned __int16 *)a2 + 20);
    do
    {
      v10 = v8 >> 1;
      v11 = &v4[8 * (v8 >> 1)];
      v13 = *(_QWORD *)v11;
      v12 = v11 + 8;
      v8 += ~(v8 >> 1);
      if (*(unsigned __int16 *)(v13 + 40) <= v9)
        v4 = v12;
      else
        v8 = v10;
    }
    while (v8);
  }
  std::vector<_TAG *>::insert((uint64_t)v3, v4, (char *)&v15);
  return result;
}

char *std::vector<_TAG *>::insert(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = std::vector<_APPx *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_188022424(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t _TAGList::removeTag(uint64_t result, unsigned __int16 *a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  v3 = *(_QWORD *)(result + 16);
  v2 = *(_QWORD *)(result + 24);
  if (v3 != v2)
  {
    v4 = a2[20];
    while (*(unsigned __int16 *)(*(_QWORD *)v3 + 40) != v4)
    {
      v3 += 8;
      if (v3 == v2)
        goto LABEL_14;
    }
    if (v3 != v2)
    {
      v5 = v3 + 8;
      if (v3 + 8 != v2)
      {
        do
        {
          if (*(unsigned __int16 *)(*(_QWORD *)v5 + 40) != v4)
          {
            *(_QWORD *)v3 = *(_QWORD *)v5;
            v3 += 8;
          }
          v5 += 8;
        }
        while (v5 != v2);
        v2 = *(_QWORD *)(result + 24);
      }
      if (v3 != v2)
        *(_QWORD *)(result + 24) = v3;
    }
  }
LABEL_14:
  if (a2)
    return (*(uint64_t (**)(unsigned __int16 *))(*(_QWORD *)a2 + 8))(a2);
  return result;
}

uint64_t _TAGList::findTagByID(_TAGList *this, int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 2);
  v3 = *((_QWORD *)this + 3);
  if (v2 != v3)
  {
    while (*(unsigned __int16 *)(*(_QWORD *)v2 + 40) != a2)
    {
      v2 += 8;
      if (v2 == v3)
        return 0;
    }
  }
  if (v2 == v3)
    return 0;
  else
    return *(_QWORD *)v2;
}

void _TAGList::mergeWithTagList(_TAGList *this, _TAGList *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v6;
  unsigned __int16 **v7;
  unsigned __int16 **v8;
  char v9;
  _TAG *v10;
  __n128 inserted;
  uint64_t *v12;

  if (a2)
  {
    v3 = (uint64_t *)*((_QWORD *)a2 + 2);
    v4 = (uint64_t *)*((_QWORD *)a2 + 3);
    if (v3 != v4)
    {
      do
      {
        v6 = *v3;
        v7 = (unsigned __int16 **)*((_QWORD *)this + 2);
        v8 = (unsigned __int16 **)*((_QWORD *)this + 3);
        if (v7 != v8)
        {
          while ((*v7)[20] != *(unsigned __int16 *)(v6 + 40))
          {
            if (++v7 == v8)
              goto LABEL_10;
          }
        }
        if (v7 == v8 || !*v7)
        {
LABEL_10:
          v9 = 16;
        }
        else
        {
          _TAGList::removeTag((uint64_t)this, *v7);
          v9 = 32;
        }
        v10 = (_TAG *)operator new();
        _TAG::_TAG((uint64_t)v10, v6, *((_BYTE *)this + 41) | v9);
        inserted = _TAGList::insertTag(this, v10);
        ++v3;
      }
      while (v3 != v4);
      v12 = (uint64_t *)*((_QWORD *)a2 + 2);
      v3 = (uint64_t *)*((_QWORD *)a2 + 3);
      if (v12 != v3)
      {
        do
        {
          if (*v12)
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)*v12 + 8))(*v12, inserted);
          ++v12;
        }
        while (v12 != v3);
        v3 = (uint64_t *)*((_QWORD *)a2 + 2);
      }
    }
    *((_QWORD *)a2 + 3) = v3;
  }
}

uint64_t _TAGList::dump(_TAGList *this)
{
  return (unsigned __int16)((*((_DWORD *)this + 6) - *((_DWORD *)this + 4)) >> 3);
}

uint64_t _TAGList::writeToBuffer(uint64_t this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned int *a5, unsigned int *a6, uint64_t a7)
{
  uint64_t *v7;
  uint64_t *i;
  uint64_t v15;
  int v16;
  uint64_t v17;

  v17 = 0;
  *a5 = 0;
  *a6 = 0;
  v7 = *(uint64_t **)(this + 16);
  for (i = *(uint64_t **)(this + 24); v7 != i; *a6 += v16)
  {
    v15 = *v7++;
    this = (*(uint64_t (**)(uint64_t, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, char *, uint64_t *, uint64_t))(*(_QWORD *)v15 + 16))(v15, a2, a3, a4, (char *)&v17 + 4, &v17, a7);
    v16 = v17;
    a3 += HIDWORD(v17);
    a4 += v17;
    *a5 += HIDWORD(v17);
  }
  return this;
}

void _TAG::_TAG(_TAG *this, char a2, __int16 a3, __int16 a4, int a5, unsigned __int8 *a6, unsigned int a7, int a8, char a9, BOOL a10)
{
  void *v13;
  char v14;

  *(_QWORD *)this = &off_1E1BB2600;
  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 24) = a2;
  *((_DWORD *)this + 7) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_BYTE *)this + 80) = a9;
  *((_WORD *)this + 20) = a3;
  *((_WORD *)this + 28) = a4;
  *((_DWORD *)this + 15) = a5;
  *((_DWORD *)this + 16) = a8;
  if (a6 && a10)
  {
    v13 = (void *)operator new[]();
    *((_QWORD *)this + 9) = v13;
    memcpy(v13, a6, a7);
    v14 = 1;
  }
  else
  {
    v14 = 0;
    *((_QWORD *)this + 9) = a6;
  }
  *((_BYTE *)this + 81) = v14;
  *((_DWORD *)this + 17) = a7;
}

void _TAG::_TAG(_TAG *this, unsigned __int8 *a2, uint64_t a3, char a4, int a5, unsigned int a6, char a7)
{
  *(_QWORD *)this = &off_1E1BB2600;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *((_BYTE *)this + 24) = a4;
  *((_DWORD *)this + 7) = a5;
  *((_QWORD *)this + 6) = &a2[a6];
  *((_QWORD *)this + 4) = a6;
  *((_BYTE *)this + 80) = a7;
  *((_WORD *)this + 20) = _TAG::readShort(this);
  *((_WORD *)this + 28) = (*(uint64_t (**)(_TAG *))(*(_QWORD *)this + 32))(this);
  *((_DWORD *)this + 15) = (*(uint64_t (**)(_TAG *))(*(_QWORD *)this + 96))(this);
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 9) = 0;
  (*(void (**)(_TAG *))(*(_QWORD *)this + 104))(this);
  *((_BYTE *)this + 81) = 0;
}

double _TAG::_TAG(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3;
  double result;

  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = &off_1E1BB2600;
  *(_QWORD *)(a1 + 8) = v3;
  *(_BYTE *)(a1 + 24) = *(_BYTE *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80) | a3;
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
  result = *(double *)(a2 + 60);
  *(double *)(a1 + 60) = result;
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_BYTE *)(a1 + 81) = *(_BYTE *)(a2 + 81);
  return result;
}

void _TAG::~_TAG(_TAG *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1E1BB2600;
  if (*((_BYTE *)this + 81))
  {
    v1 = *((_QWORD *)this + 9);
    if (v1)
      MEMORY[0x18D761C18](v1, 0x1000C8077774924);
  }
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1E1BB2600;
  if (*((_BYTE *)this + 81))
  {
    v1 = *((_QWORD *)this + 9);
    if (v1)
      MEMORY[0x18D761C18](v1, 0x1000C8077774924);
  }
  JUMPOUT(0x18D761C30);
}

uint64_t _TAG::nativeDataOrOffset(_TAG *this)
{
  unsigned int v1;
  unsigned int v2;

  v1 = *((_DWORD *)this + 16);
  v2 = bswap32(v1);
  if (*((_BYTE *)this + 24))
    return v1;
  else
    return v2;
}

unint64_t _TAG::readShort(_TAG *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;
  unsigned int v6;

  v1 = *((_QWORD *)this + 4);
  v2 = v1 + 2;
  v3 = *((_QWORD *)this + 2);
  if (v1 + 2 <= v3)
  {
    v4 = *((_QWORD *)this + 1) + v1;
    v5 = *(unsigned __int8 *)v4;
    LODWORD(v4) = *(unsigned __int8 *)(v4 + 1);
    v6 = v5 | ((_DWORD)v4 << 8);
    LODWORD(v4) = v4 | (v5 << 8);
    if (*((_BYTE *)this + 24))
      v4 = v6;
    else
      v4 = v4;
    *((_QWORD *)this + 4) = v2;
  }
  else
  {
    LogError("readShort", 431, "*** ERROR: _TAG::readShort - out-of-bounds: pos: %ld  size: %ld\n", v1, v3);
    return 0;
  }
  return v4;
}

unint64_t _TAG::readLong(_TAG *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;

  v1 = *((_QWORD *)this + 4);
  v2 = v1 + 4;
  v3 = *((_QWORD *)this + 2);
  if (v1 + 4 <= v3)
  {
    v4 = *((_QWORD *)this + 1) + v1;
    v5 = *(unsigned __int8 *)v4;
    v6 = *(unsigned __int8 *)(v4 + 1);
    v7 = *(unsigned __int8 *)(v4 + 2);
    LODWORD(v4) = *(unsigned __int8 *)(v4 + 3);
    v8 = (v5 << 24) | (v6 << 16) | (v7 << 8) | v4;
    LODWORD(v4) = v5 | (v6 << 8) | (v7 << 16) | ((_DWORD)v4 << 24);
    if (*((_BYTE *)this + 24))
      v4 = v4;
    else
      v4 = v8;
    *((_QWORD *)this + 4) = v2;
  }
  else
  {
    LogError("readLong", 453, "*** _TAG::readLong - out-of-bounds: pos: %ld  size: %ld\n", v1, v3);
    return 0;
  }
  return v4;
}

_TAG *_TAG::readTag(_TAG *this)
{
  _TAG *v2;

  v2 = (_TAG *)operator new();
  _TAG::_TAG(v2, *((unsigned __int8 **)this + 1), *((_QWORD *)this + 2), *((_BYTE *)this + 24), *((_DWORD *)this + 7), *((_DWORD *)this + 8), *((_BYTE *)this + 80));
  *((_QWORD *)this + 4) += 12;
  return v2;
}

void sub_188022B50(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

const char *_TAG::readData(const char *this)
{
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;

  v1 = this;
  v2 = *((_QWORD *)this + 4);
  v3 = *((_QWORD *)this + 2);
  if (v2 + 4 <= v3)
  {
    *((_DWORD *)this + 16) = *(_DWORD *)(*((_QWORD *)this + 1) + v2);
    switch(*((_WORD *)this + 28))
    {
      case 1:
      case 2:
      case 6:
      case 7:
        v4 = *((_DWORD *)this + 15);
        goto LABEL_8;
      case 3:
      case 8:
        v4 = 2 * *((_DWORD *)this + 15);
        goto LABEL_8;
      case 4:
      case 9:
      case 0xB:
        v4 = 4 * *((_DWORD *)this + 15);
        goto LABEL_8;
      case 5:
      case 0xA:
      case 0xC:
        v4 = 8 * *((_DWORD *)this + 15);
LABEL_8:
        *((_DWORD *)this + 17) = v4;
        break;
      default:
        return this;
    }
  }
  else
  {
    this = LogError("readData", 487, "*** ERROR: readData - out-of-bounds: pos: %ld  size: %ld\n", v2, v3);
    *((_QWORD *)v1 + 8) = 0;
    *((_WORD *)v1 + 20) = 0;
  }
  return this;
}

uint64_t _TAG::positionToSubID(uint64_t this)
{
  unsigned int v1;
  unsigned int v2;

  v1 = bswap32(*(_DWORD *)(this + 64));
  if (*(_BYTE *)(this + 24))
    v2 = *(_DWORD *)(this + 64);
  else
    v2 = v1;
  *(_QWORD *)(this + 32) = v2 + *(_DWORD *)(this + 28);
  return this;
}

uint64_t _TAG::setDataOrOffset16(uint64_t this, __int16 a2)
{
  __int16 v2;
  __int16 v3;

  v2 = __rev16(a2);
  if (*(_BYTE *)(this + 24))
    v3 = a2;
  else
    v3 = v2;
  *(_WORD *)(this + 64) = v3;
  return this;
}

uint64_t _TAG::setDataOrOffset32(uint64_t this, int a2)
{
  *(_DWORD *)(this + 64) = a2;
  return this;
}

uint64_t _TAG::copyDateTime(_TAG *this, const char *__s)
{
  uint64_t result;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;

  result = strlen(__s);
  v5 = *((unsigned int *)this + 15);
  if (result == (_DWORD)v5 - 1)
  {
    v6 = *((_QWORD *)this + 1);
    if (v6)
    {
      LODWORD(v7) = *((_DWORD *)this + 16);
      if ((_DWORD)v7)
      {
        v8 = *((unsigned int *)this + 7);
        if ((_DWORD)v8)
        {
          v9 = bswap32(v7);
          if (*((_BYTE *)this + 24))
            v7 = v7;
          else
            v7 = v9;
          return strlcpy((char *)(v6 + v8 + v7), __s, v5);
        }
      }
    }
  }
  return result;
}

uint64_t _TAG::writeData(_TAG *this, unsigned __int8 *a2, int a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned __int8 v10;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v18;

  v3 = *((unsigned __int8 *)this + 24);
  if (v3 == a3)
  {
    v4 = *((_DWORD *)this + 16);
LABEL_28:
    *(_DWORD *)a2 = v4;
    return 4;
  }
  v18 = 0;
  v5 = *((unsigned __int16 *)this + 28);
  if (v5 <= 0xB)
  {
    v6 = (unsigned int *)((char *)this + 64);
    if (((1 << v5) & 0xC6) != 0)
    {
      if (*((_DWORD *)this + 17) >= 4u)
        v9 = 4;
      else
        v9 = (unsigned __int16)*((_DWORD *)this + 17);
      for (; v9; --v9)
      {
        v10 = *(_BYTE *)v6;
        v6 = (unsigned int *)((char *)v6 + 1);
        *a2++ = v10;
      }
    }
    else
    {
      if (((1 << v5) & 0xA10) != 0)
      {
        v4 = *v6;
        v7 = bswap32(v4);
        if (!v3)
          v4 = v7;
        v8 = bswap32(v4);
        if (!a3)
          v4 = v8;
        goto LABEL_28;
      }
      if (((1 << v5) & 0x108) != 0)
      {
        v11 = (unsigned __int16)*((_DWORD *)this + 17);
        if (*((_DWORD *)this + 17) >= 2u)
          v11 = 2;
        if (v11)
        {
          v12 = 0;
          v13 = 2 * v11;
          do
          {
            v14 = *(unsigned __int16 *)((char *)v6 + v12);
            v15 = bswap32(v14) >> 16;
            if (!v3)
              v14 = v15;
            v16 = bswap32(v14) >> 16;
            if (!a3)
              LOWORD(v14) = v16;
            *(_WORD *)((char *)&v18 + v12) = v14;
            v12 += 2;
          }
          while (v13 != (_DWORD)v12);
          v4 = v18;
        }
        else
        {
          v4 = 0;
        }
        goto LABEL_28;
      }
    }
  }
  return 4;
}

uint64_t _TAG::writeToBuffer(uint64_t this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *__dst, unsigned int *a5, unsigned int *a6, int a7)
{
  uint64_t v9;
  __int16 v10;
  unsigned __int8 v11;
  __int16 v12;
  unsigned __int8 v13;
  unsigned int v14;
  unsigned int v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;

  v9 = this;
  *(_QWORD *)(this + 48) = a3;
  v10 = *(_WORD *)(this + 40);
  if (a7)
    v11 = *(_WORD *)(this + 40);
  else
    v11 = HIBYTE(*(_WORD *)(this + 40));
  if (a7)
    LOBYTE(v10) = HIBYTE(*(_WORD *)(this + 40));
  *a3 = v11;
  a3[1] = v10;
  v12 = *(_WORD *)(this + 56);
  if (a7)
    v13 = *(_WORD *)(this + 56);
  else
    v13 = HIBYTE(*(_WORD *)(this + 56));
  if (a7)
    LOBYTE(v12) = HIBYTE(*(_WORD *)(this + 56));
  a3[2] = v13;
  a3[3] = v12;
  v14 = *(_DWORD *)(this + 60);
  v15 = HIWORD(v14);
  if (a7)
    v16 = *(_DWORD *)(this + 60);
  else
    v16 = HIBYTE(*(_DWORD *)(this + 60));
  if (a7)
    v17 = BYTE1(*(_DWORD *)(this + 60));
  else
    v17 = BYTE2(*(_DWORD *)(this + 60));
  if (a7)
    LOBYTE(v14) = HIBYTE(*(_DWORD *)(this + 60));
  else
    LOBYTE(v15) = BYTE1(*(_DWORD *)(this + 60));
  a3[4] = v16;
  a3[5] = v17;
  a3[6] = v15;
  a3[7] = v14;
  if (*(_DWORD *)(this + 68) > 4u)
  {
    v19 = (_DWORD)__dst - (_DWORD)a2;
    v20 = ((_DWORD)__dst - (_DWORD)a2) >> 16;
    if (a7)
    {
      v21 = v19 >> 8;
      LOBYTE(v22) = (_BYTE)__dst - (_BYTE)a2;
      v19 >>= 24;
    }
    else
    {
      v22 = HIBYTE(v19);
      v21 = HIWORD(v19);
      v20 = v19 >> 8;
    }
    a3[8] = v22;
    a3[9] = v21;
    a3[10] = v20;
    a3[11] = v19;
    v23 = *(unsigned int **)(this + 72);
    if (!v23)
    {
      v24 = *(_DWORD *)(this + 64);
      v25 = bswap32(v24);
      if (*(_BYTE *)(this + 24))
        v26 = v24;
      else
        v26 = v25;
      v23 = (unsigned int *)(*(_QWORD *)(this + 8) + *(unsigned int *)(this + 28) + v26);
    }
    switch(*(_WORD *)(this + 56))
    {
      case 1:
      case 2:
      case 6:
      case 7:
        this = (uint64_t)memcpy(__dst, v23, *(unsigned int *)(this + 68));
        break;
      case 3:
      case 8:
        v27 = *(_DWORD *)(this + 68);
        v38 = (unsigned __int16)(v27 >> 1);
        if (!(unsigned __int16)(v27 >> 1))
          goto LABEL_53;
        do
        {
          v40 = *(unsigned __int16 *)v23;
          v23 = (unsigned int *)((char *)v23 + 2);
          v39 = v40;
          v41 = bswap32(v40) >> 16;
          if (!*(_BYTE *)(this + 24))
            v39 = v41;
          v42 = bswap32(v39) >> 16;
          if (!a7)
            LOWORD(v39) = v42;
          *(_WORD *)__dst = v39;
          __dst += 2;
          --v38;
        }
        while (v38);
        break;
      case 4:
      case 9:
      case 0xB:
        v27 = *(_DWORD *)(this + 68);
        v28 = (unsigned __int16)(v27 >> 2);
        if (!(unsigned __int16)(v27 >> 2))
          goto LABEL_53;
        do
        {
          v30 = *v23++;
          v29 = v30;
          v31 = bswap32(v30);
          if (!*(_BYTE *)(this + 24))
            v29 = v31;
          v32 = bswap32(v29);
          if (!a7)
            v29 = v32;
          *(_DWORD *)__dst = v29;
          __dst += 4;
          --v28;
        }
        while (v28);
        break;
      case 5:
      case 0xA:
      case 0xC:
        v27 = *(_DWORD *)(this + 68);
        v33 = (unsigned __int16)(v27 >> 2);
        if (!(unsigned __int16)(v27 >> 2))
          goto LABEL_53;
        do
        {
          v35 = *v23++;
          v34 = v35;
          v36 = bswap32(v35);
          if (!*(_BYTE *)(this + 24))
            v34 = v36;
          v37 = bswap32(v34);
          if (!a7)
            v34 = v37;
          *(_DWORD *)__dst = v34;
          __dst += 4;
          --v33;
        }
        while (v33);
        break;
      default:
        v27 = 0;
        goto LABEL_53;
    }
    v27 = *(_DWORD *)(v9 + 68);
LABEL_53:
    v18 = (v27 + 1) & 0xFFFFFFFE;
  }
  else
  {
    this = _TAG::writeData((_TAG *)this, a3 + 8, a7);
    v18 = 0;
  }
  *a5 = 12;
  *a6 = v18;
  return this;
}

void _APPx::_APPx(_APPx *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  __int16 v7;
  __int16 v8;
  __int16 v9;

  *(_QWORD *)this = &off_1E1BB2860;
  *((_QWORD *)this + 5) = a2;
  *((_QWORD *)this + 6) = a3;
  *((_QWORD *)this + 2) = a4;
  *((_QWORD *)this + 3) = a4;
  *((_BYTE *)this + 32) = 0;
  *((_BYTE *)this + 73) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_WORD *)this + 28) = a5;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 15) = a6;
  if (a5 == 65497)
    v7 = -1;
  else
    v7 = a5;
  if (a5 == 65496)
    v8 = 0;
  else
    v8 = v7;
  if ((a5 & 0xFFF0) == 0xFFE0)
    v9 = 16 * a5;
  else
    v9 = v8;
  *((_WORD *)this + 29) = v9;
  *((_BYTE *)this + 8) = a7;
  *((_BYTE *)this + 74) = 0;
}

void _APPx::~_APPx(_APPx *this)
{
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  *(_QWORD *)this = &off_1E1BB2860;
  JUMPOUT(0x18D761C30);
}

uint64_t _APPx::markerLength(_APPx *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t _APPx::readByte(_APPx *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_QWORD *)this + 3);
  v2 = *((_QWORD *)this + 6);
  if (v1 >= v2)
  {
    LogError("readByte", 932, "*** ERROR: readByte - out-of-bounds: pos: %ld  size: %ld\n", v1, v2);
    return 0;
  }
  else
  {
    v3 = v1 + 1;
    v4 = *(unsigned __int8 *)(*((_QWORD *)this + 5) + v1);
    *((_QWORD *)this + 3) = v3;
  }
  return v4;
}

unint64_t _APPx::readShort(_APPx *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;
  unsigned int v6;

  v1 = *((_QWORD *)this + 3);
  v2 = v1 + 2;
  v3 = *((_QWORD *)this + 6);
  if (v1 + 2 <= v3)
  {
    v4 = *((_QWORD *)this + 5) + v1;
    v5 = *(unsigned __int8 *)v4;
    LODWORD(v4) = *(unsigned __int8 *)(v4 + 1);
    v6 = v5 | ((_DWORD)v4 << 8);
    LODWORD(v4) = v4 | (v5 << 8);
    if (*((_BYTE *)this + 32))
      v4 = v6;
    else
      v4 = v4;
    *((_QWORD *)this + 3) = v2;
  }
  else
  {
    LogError("readShort", 946, "*** ERROR: _APPx::readShort - out-of-bounds: pos: %ld  size: %ld\n", v1, v3);
    return 0;
  }
  return v4;
}

unint64_t _APPx::readLong(_APPx *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;

  v1 = *((_QWORD *)this + 3);
  v2 = v1 + 4;
  v3 = *((_QWORD *)this + 6);
  if (v1 + 4 <= v3)
  {
    v4 = *((_QWORD *)this + 5) + v1;
    v5 = *(unsigned __int8 *)v4;
    v6 = *(unsigned __int8 *)(v4 + 1);
    v7 = *(unsigned __int8 *)(v4 + 2);
    LODWORD(v4) = *(unsigned __int8 *)(v4 + 3);
    v8 = (v5 << 24) | (v6 << 16) | (v7 << 8) | v4;
    LODWORD(v4) = v5 | (v6 << 8) | (v7 << 16) | ((_DWORD)v4 << 24);
    if (*((_BYTE *)this + 32))
      v4 = v4;
    else
      v4 = v8;
    *((_QWORD *)this + 3) = v2;
  }
  else
  {
    LogError("readLong", 968, "*** ERROR: _APPx::readLong - out-of-bounds: pos: %ld  size: %ld\n", v1, v3);
    return 0;
  }
  return v4;
}

_TAG *_APPx::readTag(_APPx *this)
{
  _TAG *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;

  v2 = (_TAG *)operator new();
  _TAG::_TAG(v2, *((unsigned __int8 **)this + 5), *((_QWORD *)this + 6), *((_BYTE *)this + 32), *((_DWORD *)this + 16), *((_DWORD *)this + 6), *((_BYTE *)this + 8));
  *((_QWORD *)this + 3) += 12;
  v3 = (*(uint64_t (**)(_TAG *))(*(_QWORD *)v2 + 56))(v2);
  v4 = (*(uint64_t (**)(_TAG *))(*(_QWORD *)v2 + 48))(v2);
  v5 = v4;
  if ((v3 - 1) > 9 || v4 >= *((_DWORD *)this + 15))
    goto LABEL_12;
  if (*((_WORD *)v2 + 20) && v3 == 3)
  {
    if ((*(unsigned int (**)(_TAG *))(*(_QWORD *)v2 + 48))(v2) < *((_DWORD *)this + 15) >> 1)
      return v2;
    goto LABEL_12;
  }
  if (!*((_WORD *)v2 + 20))
  {
LABEL_12:
    v6 = *((_DWORD *)this + 19) + 1;
    *((_DWORD *)this + 19) = v6;
    if (v6 <= 3)
      LogError("readTag", 1018, ": tag-id '%04X' is bad (type = %d  count = %ld) - ignoring...\n", *((unsigned __int16 *)v2 + 20), v3, v5);
    (*(void (**)(_TAG *))(*(_QWORD *)v2 + 8))(v2);
    return 0;
  }
  switch(v3)
  {
    case 4:
    case 9:
      if ((*(unsigned int (**)(_TAG *))(*(_QWORD *)v2 + 48))(v2) >= *((_DWORD *)this + 15) >> 2)
        goto LABEL_12;
      if (v3 == 5)
        goto LABEL_11;
      break;
    case 5:
    case 10:
LABEL_11:
      if ((*(unsigned int (**)(_TAG *))(*(_QWORD *)v2 + 48))(v2) >= *((_DWORD *)this + 15) >> 3)
        goto LABEL_12;
      break;
    default:
      return v2;
  }
  return v2;
}

void sub_188023400(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

uint64_t _APPx::processData(_APPx *this)
{
  uint64_t result;

  *((_WORD *)this + 28) = (*(uint64_t (**)(_APPx *))(*(_QWORD *)this + 104))(this);
  result = (*(uint64_t (**)(_APPx *))(*(_QWORD *)this + 104))(this);
  *((_DWORD *)this + 15) = result + 2;
  return result;
}

CFIndex _APPx::writeToStream(CFIndex this, CFWriteStreamRef stream)
{
  if (*(unsigned __int16 *)(this + 56) - 65505 <= 0xD
    && ((1 << (*(_WORD *)(this + 56) + 31)) & 0x2203) != 0)
  {
    return CFWriteStreamWrite(stream, (const UInt8 *)(*(_QWORD *)(this + 40) + *(_QWORD *)(this + 16)), *(unsigned int *)(this + 60));
  }
  return this;
}

uint64_t _APPx::setShouldAlignDataSize(uint64_t this)
{
  *(_BYTE *)(this + 74) = 1;
  return this;
}

uint64_t _APP3::_APP3(uint64_t a1, CFTypeRef cf, int a3)
{
  CFTypeID v6;

  *(_WORD *)(a1 + 73) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 238092259;
  *(_QWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &off_1E1BB27D0;
  *(_QWORD *)(a1 + 88) = 0;
  if (cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFDataGetTypeID())
    {
      *(_QWORD *)(a1 + 88) = CFRetain(cf);
      *(_DWORD *)(a1 + 60) = CFDataGetLength((CFDataRef)cf);
    }
  }
  *(_DWORD *)(a1 + 80) = a3;
  *(_WORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 56) = -29;
  return a1;
}

void sub_188023568(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E1BB2860;
  _Unwind_Resume(a1);
}

void _APP3::~_APP3(_APP3 *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E1BB27D0;
  v2 = (const void *)*((_QWORD *)this + 11);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 11) = 0;
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  _APP3::~_APP3(this);
  JUMPOUT(0x18D761C30);
}

const UInt8 *_APP3::writeToStream(_APP3 *this, __CFWriteStream *a2)
{
  int v4;
  unsigned int v5;
  int v6;
  const char *v7;
  const UInt8 *result;
  const UInt8 *v9;
  uint64_t v10;
  uint64_t v11;
  CFIndex v12;
  UInt8 buffer[2];
  __int16 v14;
  uint64_t v15;
  int v16;
  __int16 v17;
  __int16 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = *((_DWORD *)this + 15);
  if (v4)
    v5 = (v4 - 1) / 0xFDE8u + 1;
  else
    v5 = 0;
  v16 = 0;
  v15 = 0;
  *(_WORD *)buffer = -7169;
  v6 = *((_DWORD *)this + 20);
  if (v6 == 2)
  {
    LOBYTE(v16) = 109;
    v7 = "iOSCustom";
  }
  else
  {
    if (v6 != 1)
      goto LABEL_9;
    LOBYTE(v16) = 103;
    v7 = "iOS_Debug";
  }
  v15 = *(_QWORD *)v7;
LABEL_9:
  v18 = bswap32(v5) >> 16;
  result = CFDataGetBytePtr(*((CFDataRef *)this + 11));
  if ((_WORD)v5)
  {
    v9 = result;
    v10 = 0;
    v11 = *((unsigned int *)this + 15);
    do
    {
      ++v10;
      if (v11 >= 65000)
        v12 = 65000;
      else
        v12 = v11;
      v11 -= v12;
      v14 = bswap32(v12 + 18) >> 16;
      v17 = bswap32(v10) >> 16;
      CFWriteStreamWrite(a2, buffer, 20);
      result = (const UInt8 *)CFWriteStreamWrite(a2, v9, v12);
      v9 += v12;
    }
    while ((unsigned __int16)v5 != v10);
  }
  return result;
}

void _APPData::_APPData(_APPData *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  _QWORD *v7;

  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *v7 = &off_1E1BB2DF8;
}

void _APPData::~_APPData(_APPData *this)
{
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  *(_QWORD *)this = &off_1E1BB2860;
  JUMPOUT(0x18D761C30);
}

CFIndex _APPData::writeToStream(_APPData *this, CFWriteStreamRef stream)
{
  unsigned int v4;
  uint64_t v5;
  const UInt8 *v6;
  CFIndex v7;

  if (*((_BYTE *)this + 74) && *((__int16 *)this + 28) == -37 && *((_QWORD *)this + 2) == 2)
  {
    v4 = *((_DWORD *)this + 15);
    if (v4 < 0xFFF)
    {
      v5 = 2;
    }
    else
    {
      CFWriteStreamWrite(stream, (const UInt8 *)(*((_QWORD *)this + 5) + 2), 4094);
      v4 -= 4094;
      v5 = 4096;
    }
    v6 = (const UInt8 *)(*((_QWORD *)this + 5) + v5);
    v7 = v4;
  }
  else
  {
    v6 = (const UInt8 *)(*((_QWORD *)this + 5) + *((_QWORD *)this + 2));
    v7 = *((unsigned int *)this + 15);
  }
  return CFWriteStreamWrite(stream, v6, v7);
}

uint64_t _APPData::getImageDimension(_APPData *this, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;
  __int16 v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;

  result = (*(uint64_t (**)(_APPData *))(*(_QWORD *)this + 104))(this);
  v9 = result;
  if (result >> 8 >= 0xFF && (unsigned __int16)((unsigned __int16)(result + 48) >> 4) <= 0xFFEu)
  {
    do
    {
      result = (*(uint64_t (**)(_APPData *))(*(_QWORD *)this + 104))(this);
      v10 = *((_QWORD *)this + 3) + result;
      *((_QWORD *)this + 3) = v10 - 2;
      if (v10 > *((unsigned int *)this + 15))
        break;
      result = (*(uint64_t (**)(_APPData *))(*(_QWORD *)this + 104))(this);
      v9 = result;
      if (result >> 8 < 0xFF)
        break;
    }
    while ((unsigned __int16)((unsigned __int16)(result + 48) >> 4) < 0xFFFu);
  }
  if ((v9 & 0xFFF0) == 0xFFC0)
  {
    (*(void (**)(_APPData *))(*(_QWORD *)this + 104))(this);
    ++*((_QWORD *)this + 3);
    v11 = (*(uint64_t (**)(_APPData *))(*(_QWORD *)this + 104))(this);
    if (a3)
      *a3 = v11;
    v12 = (*(uint64_t (**)(_APPData *))(*(_QWORD *)this + 104))(this);
    if (a2)
      *a2 = v12;
    result = (*(uint64_t (**)(_APPData *))(*(_QWORD *)this + 96))(this);
    if (a4)
      *a4 = result;
  }
  return result;
}

void _APP0::_APP0(_APP0 *this, int a2, char a3, int a4)
{
  uint64_t v4;

  _APPx::_APPx(this, 0, 0, 0, a2, a4, a3);
  *(_QWORD *)v4 = &off_1E1BB2680;
  *(_BYTE *)(v4 + 80) = 0;
}

void _APP0::_APP0(_APP0 *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  uint64_t v7;

  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(_QWORD *)v7 = &off_1E1BB2680;
  *(_BYTE *)(v7 + 80) = 0;
}

void _APP0::~_APP0(_APP0 *this)
{
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  *(_QWORD *)this = &off_1E1BB2860;
  JUMPOUT(0x18D761C30);
}

uint64_t _APP0::markerLength(_APP0 *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t _APP0::writeToStream(uint64_t this, CFWriteStreamRef stream)
{
  CFIndex v2;
  UInt8 v3[24];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(this + 60);
  if ((_DWORD)v2 == 20 || *(_BYTE *)(this + 80))
  {
    *(_OWORD *)v3 = xmmword_18822BA70;
    *(_QWORD *)&v3[14] = 0x46504D4100002C01;
    return CFWriteStreamWrite(stream, v3, 22);
  }
  else if (*(_QWORD *)(this + 48))
  {
    return CFWriteStreamWrite(stream, (const UInt8 *)(*(_QWORD *)(this + 40) + *(_QWORD *)(this + 16)), v2);
  }
  return this;
}

void _APP1::_APP1(_APP1 *this, int a2, char a3)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  int v7;
  char *v8;

  _APPx::_APPx(this, 0, 0, 0, a2, 0, a3);
  *(_QWORD *)v4 = &off_1E1BB2718;
  *(_BYTE *)(v4 + 68) = 1;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_DWORD *)(v4 + 128) = 0;
  *(_WORD *)(v4 + 58) |= 1u;
  v5 = operator new();
  v6 = *((_BYTE *)this + 8);
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)(v5 + 32) = 0;
  *(_BYTE *)(v5 + 41) = v6;
  *(_QWORD *)(v5 + 8) = 0;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)v5 = &off_1E1BB2EE8;
  *((_QWORD *)this + 10) = v5;
  *(_BYTE *)(v5 + 40) = *((_BYTE *)this + 32);
  v7 = *((unsigned __int16 *)this + 28);
  v8 = 0;
  asprintf(&v8, "_mainIFD '%04X'", v7);
  *(_QWORD *)(*((_QWORD *)this + 10) + 8) = v8;
}

void sub_188023BA8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E1BB2860;
  _Unwind_Resume(a1);
}

void _APP1::_APP1(_APP1 *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  __int16 v7;
  uint64_t v8;

  v7 = a5;
  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(_QWORD *)v8 = &off_1E1BB2718;
  *(_WORD *)(v8 + 56) = v7;
  *(_BYTE *)(v8 + 68) = 1;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_DWORD *)(v8 + 128) = 0;
  *(_WORD *)(v8 + 58) |= 1u;
}

void _APP1::~_APP1(_APP1 *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = &off_1E1BB2718;
  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 10) = 0;
  }
  v3 = *((_QWORD *)this + 11);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    *((_QWORD *)this + 11) = 0;
  }
  v4 = *((_QWORD *)this + 12);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    *((_QWORD *)this + 12) = 0;
  }
  v5 = *((_QWORD *)this + 13);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    *((_QWORD *)this + 13) = 0;
  }
  v6 = *((_QWORD *)this + 14);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    *((_QWORD *)this + 14) = 0;
  }
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  _APP1::~_APP1(this);
  JUMPOUT(0x18D761C30);
}

void _APP1::mergeWithApp1(_APP1 *this, _APP1 *a2)
{
  _TAGList *v4;
  _TAGList *v5;
  _TAGList *v6;
  _TAGList *v7;
  _TAGList *v8;
  _TAGList *v9;
  uint64_t v10;
  char v11;
  _TAGList *v12;
  _TAGList *v13;
  uint64_t v14;
  char v15;
  _TAGList *v16;
  _TAGList *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t *v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t *v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t *v47;
  int v48;
  uint64_t v49;
  unsigned int v50;
  unsigned int v51;
  char *v52;

  v4 = (_TAGList *)*((_QWORD *)this + 10);
  if (v4)
  {
    v5 = (_TAGList *)*((_QWORD *)a2 + 10);
    if (v5)
      _TAGList::mergeWithTagList(v4, v5);
  }
  v6 = (_TAGList *)*((_QWORD *)this + 11);
  if (v6)
  {
    v7 = (_TAGList *)*((_QWORD *)a2 + 11);
    if (v7)
      _TAGList::mergeWithTagList(v6, v7);
  }
  v52 = 0;
  v8 = (_TAGList *)*((_QWORD *)a2 + 12);
  if (v8)
  {
    v9 = (_TAGList *)*((_QWORD *)this + 12);
    if (!v9)
    {
      v10 = operator new();
      v11 = *((_BYTE *)this + 8);
      *(_QWORD *)(v10 + 24) = 0;
      *(_QWORD *)(v10 + 32) = 0;
      *(_BYTE *)(v10 + 41) = v11;
      *(_QWORD *)(v10 + 8) = 0;
      *(_QWORD *)(v10 + 16) = 0;
      *(_QWORD *)v10 = &off_1E1BB2EE8;
      *((_QWORD *)this + 12) = v10;
      *(_BYTE *)(v10 + 40) = *((_BYTE *)this + 32);
      asprintf(&v52, "_exifIFD '%04X'", *((unsigned __int16 *)this + 28));
      v9 = (_TAGList *)*((_QWORD *)this + 12);
      *((_QWORD *)v9 + 1) = v52;
      v8 = (_TAGList *)*((_QWORD *)a2 + 12);
    }
    _TAGList::mergeWithTagList(v9, v8);
  }
  v12 = (_TAGList *)*((_QWORD *)a2 + 13);
  if (v12)
  {
    v13 = (_TAGList *)*((_QWORD *)this + 13);
    if (!v13)
    {
      v14 = operator new();
      v15 = *((_BYTE *)this + 8);
      *(_QWORD *)(v14 + 24) = 0;
      *(_QWORD *)(v14 + 32) = 0;
      *(_BYTE *)(v14 + 41) = v15;
      *(_QWORD *)(v14 + 8) = 0;
      *(_QWORD *)(v14 + 16) = 0;
      *(_QWORD *)v14 = &off_1E1BB2EE8;
      *((_QWORD *)this + 13) = v14;
      *(_BYTE *)(v14 + 40) = *((_BYTE *)this + 32);
      asprintf(&v52, "_gpsIFD '%04X'", *((unsigned __int16 *)this + 28));
      v13 = (_TAGList *)*((_QWORD *)this + 13);
      *((_QWORD *)v13 + 1) = v52;
      v12 = (_TAGList *)*((_QWORD *)a2 + 13);
    }
    _TAGList::mergeWithTagList(v13, v12);
  }
  v16 = (_TAGList *)*((_QWORD *)this + 14);
  if (v16)
  {
    v17 = (_TAGList *)*((_QWORD *)a2 + 14);
    if (v17)
      _TAGList::mergeWithTagList(v16, v17);
  }
  *((_DWORD *)this + 15) = 0;
  v18 = *((_QWORD *)this + 10);
  if (v18)
  {
    v19 = *(uint64_t **)(v18 + 16);
    v20 = *(uint64_t **)(v18 + 24);
    if (v19 == v20)
    {
      LODWORD(v18) = 0;
    }
    else
    {
      LODWORD(v18) = 0;
      do
      {
        v21 = *v19++;
        v22 = *(_DWORD *)(v21 + 68);
        if (v22 <= 4)
          v23 = 0;
        else
          v23 = (v22 + 1) & 0xFFFFFFFE;
        LODWORD(v18) = v23 + v18;
      }
      while (v19 != v20);
    }
    *((_DWORD *)this + 15) = v18;
  }
  v24 = *((_QWORD *)this + 12);
  if (v24)
  {
    v25 = *(uint64_t **)(v24 + 16);
    v26 = *(uint64_t **)(v24 + 24);
    if (v25 == v26)
    {
      v27 = 0;
    }
    else
    {
      v27 = 0;
      do
      {
        v28 = *v25++;
        v29 = *(_DWORD *)(v28 + 68);
        if (v29 <= 4)
          v30 = 0;
        else
          v30 = (v29 + 1) & 0xFFFFFFFE;
        v27 += v30;
      }
      while (v25 != v26);
    }
    LODWORD(v18) = v18 + v27;
    *((_DWORD *)this + 15) = v18;
  }
  v31 = *((_QWORD *)this + 11);
  if (v31)
  {
    v32 = *(uint64_t **)(v31 + 16);
    v33 = *(uint64_t **)(v31 + 24);
    if (v32 == v33)
    {
      v34 = 0;
    }
    else
    {
      v34 = 0;
      do
      {
        v35 = *v32++;
        v36 = *(_DWORD *)(v35 + 68);
        if (v36 <= 4)
          v37 = 0;
        else
          v37 = (v36 + 1) & 0xFFFFFFFE;
        v34 += v37;
      }
      while (v32 != v33);
    }
    LODWORD(v18) = v18 + v34;
    *((_DWORD *)this + 15) = v18;
  }
  v38 = *((_QWORD *)this + 13);
  if (v38)
  {
    v39 = *(uint64_t **)(v38 + 16);
    v40 = *(uint64_t **)(v38 + 24);
    if (v39 == v40)
    {
      v41 = 0;
    }
    else
    {
      v41 = 0;
      do
      {
        v42 = *v39++;
        v43 = *(_DWORD *)(v42 + 68);
        if (v43 <= 4)
          v44 = 0;
        else
          v44 = (v43 + 1) & 0xFFFFFFFE;
        v41 += v44;
      }
      while (v39 != v40);
    }
    LODWORD(v18) = v18 + v41;
    *((_DWORD *)this + 15) = v18;
  }
  v45 = *((_QWORD *)this + 14);
  if (v45)
  {
    v46 = *(uint64_t **)(v45 + 16);
    v47 = *(uint64_t **)(v45 + 24);
    if (v46 == v47)
    {
      v48 = 0;
    }
    else
    {
      v48 = 0;
      do
      {
        v49 = *v46++;
        v50 = *(_DWORD *)(v49 + 68);
        if (v50 <= 4)
          v51 = 0;
        else
          v51 = (v50 + 1) & 0xFFFFFFFE;
        v48 += v51;
      }
      while (v46 != v47);
    }
    *((_DWORD *)this + 15) = v18 + v48;
  }
}

double _APP1::updateThumbnailInfo(_APP1 *this, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  double result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  char v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  char v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  char v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  char v41;
  char v42;
  char *v43;

  v43 = 0;
  v6 = *((_QWORD *)this + 11);
  if (!v6)
  {
    v7 = operator new();
    v8 = *((_BYTE *)this + 8);
    *(_QWORD *)(v7 + 24) = 0;
    *(_QWORD *)(v7 + 32) = 0;
    *(_BYTE *)(v7 + 41) = v8;
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(v7 + 16) = 0;
    *(_QWORD *)v7 = &off_1E1BB2EE8;
    *((_QWORD *)this + 11) = v7;
    asprintf(&v43, "_thumbIFD '%04X'", *((unsigned __int16 *)this + 28));
    v6 = *((_QWORD *)this + 11);
    *(_QWORD *)(v6 + 8) = v43;
    *(_BYTE *)(v6 + 40) = *((_BYTE *)this + 32);
  }
  *((_QWORD *)this + 15) = a2;
  *((_DWORD *)this + 32) = a3;
  v10 = *(_QWORD *)(v6 + 16);
  v11 = *(_QWORD *)(v6 + 24);
  v12 = v10;
  if (v10 != v11)
  {
    v12 = v10;
    while (*(_WORD *)(*(_QWORD *)v12 + 40) != 513)
    {
      v12 += 8;
      if (v12 == v11)
        goto LABEL_10;
    }
  }
  if (v12 == v11 || !*(_QWORD *)v12)
  {
LABEL_10:
    v13 = operator new();
    v14 = *((_BYTE *)this + 32);
    v15 = *((_BYTE *)this + 8) | 0x40;
    *(_QWORD *)v13 = &off_1E1BB2600;
    *(_QWORD *)(v13 + 8) = 0;
    *(_BYTE *)(v13 + 24) = v14;
    *(_DWORD *)(v13 + 28) = 0;
    *(_QWORD *)(v13 + 48) = 0;
    *(_QWORD *)(v13 + 32) = 0;
    *(_BYTE *)(v13 + 80) = v15;
    *(_WORD *)(v13 + 40) = 513;
    *(_WORD *)(v13 + 56) = 4;
    *(_QWORD *)(v13 + 60) = 1;
    *(_QWORD *)(v13 + 72) = a2;
    *(_BYTE *)(v13 + 81) = 0;
    *(_DWORD *)(v13 + 68) = 4;
    *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 11), (_TAG *)v13).n128_u64[0];
    v16 = *((_QWORD *)this + 11);
    v10 = *(_QWORD *)(v16 + 16);
    v11 = *(_QWORD *)(v16 + 24);
  }
  if (v10 == v11)
    goto LABEL_15;
  v17 = v10;
  while (*(_WORD *)(*(_QWORD *)v17 + 40) != 514)
  {
    v17 += 8;
    if (v17 == v11)
      goto LABEL_15;
  }
  if (v17 == v11 || !*(_QWORD *)v17)
  {
LABEL_15:
    if (*a2 == 255 && a2[1] != 216)
      a3 += 2;
    v18 = bswap32(a3);
    if (!*((_BYTE *)this + 32))
      a3 = v18;
    v19 = operator new();
    v20 = *((_BYTE *)this + 32);
    v21 = *((_BYTE *)this + 8) | 0x40;
    *(_QWORD *)v19 = &off_1E1BB2600;
    *(_QWORD *)(v19 + 8) = 0;
    *(_BYTE *)(v19 + 24) = v20;
    *(_DWORD *)(v19 + 28) = 0;
    *(_QWORD *)(v19 + 48) = 0;
    *(_QWORD *)(v19 + 32) = 0;
    *(_BYTE *)(v19 + 80) = v21;
    *(_WORD *)(v19 + 40) = 514;
    *(_WORD *)(v19 + 56) = 4;
    *(_DWORD *)(v19 + 60) = 1;
    *(_DWORD *)(v19 + 64) = a3;
    *(_QWORD *)(v19 + 72) = 0;
    *(_BYTE *)(v19 + 81) = 0;
    *(_DWORD *)(v19 + 68) = 4;
    *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 11), (_TAG *)v19).n128_u64[0];
    v22 = *((_QWORD *)this + 11);
    v10 = *(_QWORD *)(v22 + 16);
    v11 = *(_QWORD *)(v22 + 24);
  }
  if (v10 == v11)
    goto LABEL_25;
  v23 = v10;
  while (*(_WORD *)(*(_QWORD *)v23 + 40) != 259)
  {
    v23 += 8;
    if (v23 == v11)
      goto LABEL_25;
  }
  if (v23 == v11 || !*(_QWORD *)v23)
  {
LABEL_25:
    if (*((_BYTE *)this + 32))
      v24 = 393216;
    else
      v24 = 1536;
    v25 = operator new();
    v26 = *((_BYTE *)this + 32);
    v27 = *((_BYTE *)this + 8) | 0x40;
    *(_QWORD *)v25 = &off_1E1BB2600;
    *(_QWORD *)(v25 + 8) = 0;
    *(_BYTE *)(v25 + 24) = v26;
    *(_DWORD *)(v25 + 28) = 0;
    *(_QWORD *)(v25 + 48) = 0;
    *(_QWORD *)(v25 + 32) = 0;
    *(_BYTE *)(v25 + 80) = v27;
    *(_WORD *)(v25 + 40) = 259;
    *(_WORD *)(v25 + 56) = 3;
    *(_DWORD *)(v25 + 60) = 1;
    *(_DWORD *)(v25 + 64) = v24;
    *(_QWORD *)(v25 + 72) = 0;
    *(_BYTE *)(v25 + 81) = 0;
    *(_DWORD *)(v25 + 68) = 2;
    *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 11), (_TAG *)v25).n128_u64[0];
    v28 = *((_QWORD *)this + 11);
    v10 = *(_QWORD *)(v28 + 16);
    v11 = *(_QWORD *)(v28 + 24);
  }
  if (v10 == v11)
    goto LABEL_33;
  v29 = v10;
  while (*(_WORD *)(*(_QWORD *)v29 + 40) != 282)
  {
    v29 += 8;
    if (v29 == v11)
      goto LABEL_33;
  }
  if (v29 == v11 || !*(_QWORD *)v29)
  {
LABEL_33:
    *(int8x8_t *)((char *)this + 132) = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(*((_BYTE *)this + 32) == 0), 0x1FuLL)), (int8x8_t)0x100000048000000, (int8x8_t)0x100000048);
    v30 = operator new();
    v31 = *((_BYTE *)this + 32);
    v32 = *((_BYTE *)this + 8) | 0x40;
    *(_QWORD *)v30 = &off_1E1BB2600;
    *(_QWORD *)(v30 + 8) = 0;
    *(_BYTE *)(v30 + 24) = v31;
    *(_DWORD *)(v30 + 28) = 0;
    *(_QWORD *)(v30 + 48) = 0;
    *(_QWORD *)(v30 + 32) = 0;
    *(_BYTE *)(v30 + 80) = v32;
    *(_WORD *)(v30 + 40) = 282;
    *(_WORD *)(v30 + 56) = 5;
    *(_QWORD *)(v30 + 60) = 1;
    *(_QWORD *)(v30 + 72) = (char *)this + 132;
    *(_BYTE *)(v30 + 81) = 0;
    *(_DWORD *)(v30 + 68) = 8;
    *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 11), (_TAG *)v30).n128_u64[0];
    v33 = *((_QWORD *)this + 11);
    v10 = *(_QWORD *)(v33 + 16);
    v11 = *(_QWORD *)(v33 + 24);
  }
  if (v10 == v11)
    goto LABEL_38;
  v34 = v10;
  while (*(_WORD *)(*(_QWORD *)v34 + 40) != 283)
  {
    v34 += 8;
    if (v34 == v11)
      goto LABEL_38;
  }
  if (v34 == v11 || !*(_QWORD *)v34)
  {
LABEL_38:
    *(int8x8_t *)((char *)this + 140) = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(*((_BYTE *)this + 32) == 0), 0x1FuLL)), (int8x8_t)0x100000048000000, (int8x8_t)0x100000048);
    v35 = operator new();
    v36 = *((_BYTE *)this + 32);
    v37 = *((_BYTE *)this + 8) | 0x40;
    *(_QWORD *)v35 = &off_1E1BB2600;
    *(_QWORD *)(v35 + 8) = 0;
    *(_BYTE *)(v35 + 24) = v36;
    *(_DWORD *)(v35 + 28) = 0;
    *(_QWORD *)(v35 + 48) = 0;
    *(_QWORD *)(v35 + 32) = 0;
    *(_BYTE *)(v35 + 80) = v37;
    *(_WORD *)(v35 + 40) = 283;
    *(_WORD *)(v35 + 56) = 5;
    *(_QWORD *)(v35 + 60) = 1;
    *(_QWORD *)(v35 + 72) = (char *)this + 140;
    *(_BYTE *)(v35 + 81) = 0;
    *(_DWORD *)(v35 + 68) = 8;
    *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 11), (_TAG *)v35).n128_u64[0];
    v38 = *((_QWORD *)this + 11);
    v10 = *(_QWORD *)(v38 + 16);
    v11 = *(_QWORD *)(v38 + 24);
  }
  while (v10 != v11)
  {
    if (*(_WORD *)(*(_QWORD *)v10 + 40) == 296)
    {
      if (v10 != v11 && *(_QWORD *)v10)
        return result;
      break;
    }
    v10 += 8;
  }
  if (*((_BYTE *)this + 32))
    v39 = 0x20000;
  else
    v39 = 512;
  v40 = operator new();
  v41 = *((_BYTE *)this + 32);
  v42 = *((_BYTE *)this + 8) | 0x40;
  *(_QWORD *)v40 = &off_1E1BB2600;
  *(_QWORD *)(v40 + 8) = 0;
  *(_BYTE *)(v40 + 24) = v41;
  *(_DWORD *)(v40 + 28) = 0;
  *(_QWORD *)(v40 + 48) = 0;
  *(_QWORD *)(v40 + 32) = 0;
  *(_BYTE *)(v40 + 80) = v42;
  *(_WORD *)(v40 + 40) = 296;
  *(_WORD *)(v40 + 56) = 3;
  *(_DWORD *)(v40 + 60) = 1;
  *(_DWORD *)(v40 + 64) = v39;
  *(_QWORD *)(v40 + 72) = 0;
  *(_BYTE *)(v40 + 81) = 0;
  *(_DWORD *)(v40 + 68) = 2;
  *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 11), (_TAG *)v40).n128_u64[0];
  return result;
}

void _APP1::getSubIFD(_APP1 *this, _TAG *a2, _TAGList *a3)
{
  unsigned int v6;
  unsigned int v7;
  int v8;
  char v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  int v22;
  uint64_t v23;
  char v24;
  char *v25;

  (*(void (**)(_TAG *))(*(_QWORD *)a2 + 40))(a2);
  v6 = (*(uint64_t (**)(_TAG *))(*(_QWORD *)a2 + 32))(a2);
  v7 = v6;
  if (*((_DWORD *)this + 15) / 0xAu < v6)
  {
    LogError("getSubIFD", 1596, "- bad IFD count [%d entries]\n", v6);
    return;
  }
  if (v6)
  {
    v8 = 0;
    v25 = 0;
    v9 = 1;
    while (1)
    {
      v10 = (*(uint64_t (**)(_TAG *))(*(_QWORD *)a2 + 24))(a2);
      if (v10)
        break;
LABEL_23:
      v9 = 0;
LABEL_24:
      if (++v8 >= v7)
        return;
    }
    v11 = (unsigned __int16 *)v10;
    v12 = *(_DWORD *)(v10 + 68);
    if (v12 <= 4)
      v13 = 0;
    else
      v13 = (v12 + 1) & 0xFFFFFFFE;
    if (v13 >= 5)
    {
      v14 = bswap32(*(_DWORD *)(v10 + 64));
      if (*(_BYTE *)(v10 + 24))
        v15 = *(_DWORD *)(v10 + 64);
      else
        v15 = v14;
      v16 = *((unsigned int *)this + 15);
      v17 = v15 + *((_DWORD *)this + 16);
      v18 = *((_QWORD *)this + 2);
      if (v18 > v17)
      {
        LODWORD(v16) = v18 + v16;
LABEL_16:
        LogError("getSubIFD", 1616, ": Skipping tag '%04X', dataOffset (%08X) with length = %d is outside the bounds of the APP1 marker (%08X - %08X)\n", *(unsigned __int16 *)(v10 + 40), v17, v13, *((_QWORD *)this + 2), v16);
LABEL_22:
        (*(void (**)(unsigned __int16 *))(*(_QWORD *)v11 + 8))(v11);
        goto LABEL_23;
      }
      v16 += v18;
      if (v16 < v17 + v13)
        goto LABEL_16;
    }
    if ((v9 & 1) != 0)
    {
      v19 = *((_QWORD *)a3 + 2);
      v20 = *((_QWORD *)a3 + 3);
      if (v19 != v20)
      {
        while (*(unsigned __int16 *)(*(_QWORD *)v19 + 40) != *(unsigned __int16 *)(v10 + 40))
        {
          v19 += 8;
          if (v19 == v20)
            goto LABEL_29;
        }
      }
      if (v19 == v20 || !*(_QWORD *)v19)
      {
LABEL_29:
        *(_QWORD *)&v21 = _TAGList::insertTag(a3, (_TAG *)v10).n128_u64[0];
        v22 = v11[20];
        switch(v22)
        {
          case 40965:
            if (!*((_QWORD *)this + 14))
            {
              v23 = operator new();
              v24 = *((_BYTE *)this + 8);
              *(_QWORD *)(v23 + 24) = 0;
              *(_QWORD *)(v23 + 32) = 0;
              *(_BYTE *)(v23 + 41) = v24;
              *(_QWORD *)(v23 + 8) = 0;
              *(_QWORD *)(v23 + 16) = 0;
              *(_QWORD *)v23 = &off_1E1BB2EE8;
              *((_QWORD *)this + 14) = v23;
              *(_BYTE *)(v23 + 40) = *((_BYTE *)this + 32);
              asprintf(&v25, "_interOpIFD '%04X'", *((unsigned __int16 *)this + 28));
              *(_QWORD *)(*((_QWORD *)this + 14) + 8) = v25;
              (*(void (**)(_APP1 *, unsigned __int16 *))(*(_QWORD *)this + 160))(this, v11);
            }
            break;
          case 34853:
            LogError("getSubIFD", 1645, "*** ERROR: second GPS Info Pointer???\n", v21);
            break;
          case 34665:
            LogError("getSubIFD", 1641, "*** ERROR: second Exif IFD Pointer???\n", v21);
            break;
        }
      }
      else
      {
        _cg_jpeg_mem_term("getSubIFD", 1632, "*** skipping tag -- already added\n");
      }
      v9 = 1;
      goto LABEL_24;
    }
    goto LABEL_22;
  }
}

void _APP1::processAPP1(_APP1 *this, uint64_t a2, char a3)
{
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char v13;
  int v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  __n128 inserted;
  int v18;
  uint64_t v19;
  char v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  char v31;
  unsigned int v32;
  uint64_t v33;
  _TAG *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t *v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  unsigned __int8 *v41;
  uint64_t v42;
  char *v43;

  *((_WORD *)this + 28) = (*(uint64_t (**)(_APP1 *))(*(_QWORD *)this + 104))(this);
  v6 = (*(uint64_t (**)(_APP1 *))(*(_QWORD *)this + 104))(this);
  v7 = *((_QWORD *)this + 2) + a2;
  *((_QWORD *)this + 3) = v7;
  *((_DWORD *)this + 15) = v6 + 2;
  *((_DWORD *)this + 16) = v7;
  if ((*(unsigned int (**)(_APP1 *))(*(_QWORD *)this + 104))(this) == 18761)
    *((_BYTE *)this + 32) = 1;
  *((_QWORD *)this + 3) += 2;
  v8 = (*(uint64_t (**)(_APP1 *))(*(_QWORD *)this + 112))(this);
  v9 = *((_DWORD *)this + 16);
  v10 = (v9 + v8);
  if (__CFADD__(v9, v8) || *((_QWORD *)this + 2) + (unint64_t)*((unsigned int *)this + 15) < v10)
  {
    LogError("processAPP1", 1692, "*** ERROR: bogus ifdOffset = %p + %p, marker range = %p - %p\n");
    return;
  }
  *((_QWORD *)this + 3) = v10;
  v11 = (*(uint64_t (**)(_APP1 *))(*(_QWORD *)this + 104))(this);
  v43 = 0;
  v12 = operator new();
  v13 = *((_BYTE *)this + 8);
  *(_QWORD *)(v12 + 24) = 0;
  *(_QWORD *)(v12 + 32) = 0;
  *(_BYTE *)(v12 + 41) = v13;
  *(_QWORD *)(v12 + 8) = 0;
  *(_QWORD *)(v12 + 16) = 0;
  *(_QWORD *)v12 = &off_1E1BB2EE8;
  *((_QWORD *)this + 10) = v12;
  *(_BYTE *)(v12 + 40) = *((_BYTE *)this + 32);
  asprintf(&v43, "_mainIFD '%04X'", *((unsigned __int16 *)this + 28));
  *(_QWORD *)(*((_QWORD *)this + 10) + 8) = v43;
  if (v11)
  {
    v14 = 0;
    while (1)
    {
      if (*((_QWORD *)this + 3) + 12 > *((_QWORD *)this + 2) + (unint64_t)*((unsigned int *)this + 15))
      {
        LogError("processAPP1", 1714, "*** ERROR: Bad IFD0 directory. Not enough data to read tag #%d.\n");
        return;
      }
      v15 = (unsigned __int16 *)(*(uint64_t (**)(_APP1 *))(*(_QWORD *)this + 120))(this);
      if (!v15)
      {
        LogError("processAPP1", 1729, "*** ERROR: Failed to read tag #%d in mainIFD.\n");
        return;
      }
      v16 = v15;
      if (!v15[20])
      {
        LogError("processAPP1", 1721, "*** ERROR: TAG #%d in mainIFD has invalid ID (%04X). This is likely due to an incorrect tag count.\n", v14 + 1, 0);
        (*(void (**)(unsigned __int16 *))(*(_QWORD *)v16 + 8))(v16);
        return;
      }
      inserted = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), (_TAG *)v15);
      if ((a3 & 1) != 0)
        goto LABEL_20;
      v18 = v16[20];
      switch(v18)
      {
        case 40965:
          LogError("processAPP1", 1757, "*** ERROR: Interoperability IFD at top Level???\n", inserted.n128_f64[0]);
          break;
        case 34853:
          v23 = operator new();
          v24 = *((_BYTE *)this + 8);
          *(_QWORD *)(v23 + 24) = 0;
          *(_QWORD *)(v23 + 32) = 0;
          *(_BYTE *)(v23 + 41) = v24;
          *(_QWORD *)(v23 + 8) = 0;
          *(_QWORD *)(v23 + 16) = 0;
          *(_QWORD *)v23 = &off_1E1BB2EE8;
          *((_QWORD *)this + 13) = v23;
          *(_BYTE *)(v23 + 40) = *((_BYTE *)this + 32);
          asprintf(&v43, "_gpsIFD '%04X'", *((unsigned __int16 *)this + 28));
          v21 = v43;
          v22 = *((_QWORD *)this + 13);
          goto LABEL_19;
        case 34665:
          v19 = operator new();
          v20 = *((_BYTE *)this + 8);
          *(_QWORD *)(v19 + 24) = 0;
          *(_QWORD *)(v19 + 32) = 0;
          *(_BYTE *)(v19 + 41) = v20;
          *(_QWORD *)(v19 + 8) = 0;
          *(_QWORD *)(v19 + 16) = 0;
          *(_QWORD *)v19 = &off_1E1BB2EE8;
          *((_QWORD *)this + 12) = v19;
          *(_BYTE *)(v19 + 40) = *((_BYTE *)this + 32);
          asprintf(&v43, "_exifIFD '%04X'", *((unsigned __int16 *)this + 28));
          v21 = v43;
          v22 = *((_QWORD *)this + 12);
LABEL_19:
          *(_QWORD *)(v22 + 8) = v21;
          (*(void (**)(_APP1 *, unsigned __int16 *))(*(_QWORD *)this + 160))(this, v16);
          break;
      }
LABEL_20:
      if (++v14 >= v11)
      {
        v25 = (*(uint64_t (**)(_APP1 *, __n128))(*(_QWORD *)this + 112))(this, inserted);
        if (v25 && (a3 & 1) == 0)
        {
          v26 = *((_DWORD *)this + 16);
          v27 = (v26 + v25);
          if (__CFADD__(v26, v25)
            || *((_QWORD *)this + 2) + (unint64_t)*((unsigned int *)this + 15) < v27)
          {
            LogError("processAPP1", 1770, "*** ERROR:  bogus ifdOffset = %p + %p, marker range = %p - %p\n");
          }
          else
          {
            *((_QWORD *)this + 3) = v27;
            if (*((_QWORD *)this + 6) >= v27)
            {
              v28 = (*(uint64_t (**)(_APP1 *))(*(_QWORD *)this + 104))(this);
              if (v28)
              {
                v29 = v28;
                v30 = operator new();
                v31 = *((_BYTE *)this + 8);
                *(_QWORD *)(v30 + 24) = 0;
                *(_QWORD *)(v30 + 32) = 0;
                *(_BYTE *)(v30 + 41) = v31;
                *(_QWORD *)(v30 + 8) = 0;
                *(_QWORD *)(v30 + 16) = 0;
                *(_QWORD *)v30 = &off_1E1BB2EE8;
                *((_QWORD *)this + 11) = v30;
                asprintf(&v43, "_thumbIFD '%04X'", *((unsigned __int16 *)this + 28));
                v32 = 0;
                v33 = *((_QWORD *)this + 11);
                *(_QWORD *)(v33 + 8) = v43;
                *(_BYTE *)(v33 + 40) = *((_BYTE *)this + 32);
                do
                {
                  v34 = (_TAG *)(*(uint64_t (**)(_APP1 *))(*(_QWORD *)this + 120))(this);
                  if (!v34)
                    break;
                  _TAGList::insertTag(*((_TAGList **)this + 11), v34);
                  ++v32;
                }
                while (v32 < v29);
                v35 = *((_QWORD *)this + 11);
                v36 = *(uint64_t **)(v35 + 16);
                v37 = *(uint64_t **)(v35 + 24);
                if (v36 != v37)
                {
                  while (*(_WORD *)(*v36 + 40) != 513)
                  {
                    if (++v36 == v37)
                      goto LABEL_47;
                  }
                }
                if (v36 == v37
                  || (v38 = *v36) == 0
                  || ((v39 = *(unsigned __int8 *)(v38 + 24),
                       LODWORD(v38) = *(_DWORD *)(v38 + 64),
                       v40 = bswap32(v38),
                       v39)
                    ? (v38 = v38)
                    : (v38 = v40),
                      *((_QWORD *)this + 6) < v38
                   || (v41 = (unsigned __int8 *)(*((_QWORD *)this + 5) + (*((_DWORD *)this + 16) + v38)),
                       *v41 != 255)
                   || v41[1] != 216))
                {
LABEL_47:
                  LogError("processAPP1", 1830, "*** ERROR: - corrupt thumbnail data\n");
                  v42 = *((_QWORD *)this + 11);
                  if (v42)
                    (*(void (**)(uint64_t))(*(_QWORD *)v42 + 8))(v42);
                  *((_QWORD *)this + 11) = 0;
                }
              }
            }
            else
            {
              LogError("processAPP1", 1777, "*** ERROR: ifdOffset (%d) is beyond the bounds of the file (size = %zu).\n");
            }
          }
        }
        return;
      }
    }
  }
}

void _APP1::processData(_APP1 *this)
{
  _APP1::processAPP1(this, 10, 0);
}

uint64_t _APP1::markerLength(_APP1 *this)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t *v3;
  int v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;

  v1 = *((_QWORD *)this + 10);
  if (v1)
  {
    v3 = *(uint64_t **)(v1 + 16);
    v2 = *(uint64_t **)(v1 + 24);
    v4 = 12 * (unsigned __int16)(((_DWORD)v2 - (_DWORD)v3) >> 3) + 6;
    if (v2 == v3)
    {
      v5 = 0;
    }
    else
    {
      v5 = 0;
      do
      {
        v6 = *v3++;
        v7 = *(_DWORD *)(v6 + 68);
        if (v7 <= 4)
          v8 = 0;
        else
          v8 = (v7 + 1) & 0xFFFFFFFE;
        v5 += v8;
      }
      while (v3 != v2);
    }
    v9 = v4 + v5;
  }
  else
  {
    v9 = 0;
  }
  v10 = *((_QWORD *)this + 12);
  if (v10)
  {
    v13 = v10 + 16;
    v12 = *(uint64_t **)(v10 + 16);
    v11 = *(uint64_t **)(v13 + 8);
    v14 = 12 * (unsigned __int16)(((_DWORD)v11 - (_DWORD)v12) >> 3);
    if (v11 == v12)
    {
      v15 = 0;
    }
    else
    {
      v15 = 0;
      do
      {
        v16 = *v12++;
        v17 = *(_DWORD *)(v16 + 68);
        if (v17 <= 4)
          v18 = 0;
        else
          v18 = (v17 + 1) & 0xFFFFFFFE;
        v15 += v18;
      }
      while (v12 != v11);
    }
    v9 += v14 + v15 + 6;
  }
  v19 = *((_QWORD *)this + 11);
  if (v19)
  {
    v22 = v19 + 16;
    v21 = *(uint64_t **)(v19 + 16);
    v20 = *(uint64_t **)(v22 + 8);
    v23 = 12 * (unsigned __int16)(((_DWORD)v20 - (_DWORD)v21) >> 3);
    if (v20 == v21)
    {
      v24 = 0;
    }
    else
    {
      v24 = 0;
      do
      {
        v25 = *v21++;
        v26 = *(_DWORD *)(v25 + 68);
        if (v26 <= 4)
          v27 = 0;
        else
          v27 = (v26 + 1) & 0xFFFFFFFE;
        v24 += v27;
      }
      while (v21 != v20);
    }
    v9 += v23 + v24 + 6;
  }
  v28 = *((_QWORD *)this + 13);
  if (v28)
  {
    v31 = v28 + 16;
    v30 = *(uint64_t **)(v28 + 16);
    v29 = *(uint64_t **)(v31 + 8);
    v32 = 12 * (unsigned __int16)(((_DWORD)v29 - (_DWORD)v30) >> 3);
    if (v29 == v30)
    {
      v33 = 0;
    }
    else
    {
      v33 = 0;
      do
      {
        v34 = *v30++;
        v35 = *(_DWORD *)(v34 + 68);
        if (v35 <= 4)
          v36 = 0;
        else
          v36 = (v35 + 1) & 0xFFFFFFFE;
        v33 += v36;
      }
      while (v30 != v29);
    }
    v9 += v32 + v33 + 6;
  }
  v37 = *((_QWORD *)this + 14);
  if (v37)
  {
    v40 = v37 + 16;
    v39 = *(uint64_t **)(v37 + 16);
    v38 = *(uint64_t **)(v40 + 8);
    v41 = 12 * (unsigned __int16)(((_DWORD)v38 - (_DWORD)v39) >> 3);
    if (v38 == v39)
    {
      v42 = 0;
    }
    else
    {
      v42 = 0;
      do
      {
        v43 = *v39++;
        v44 = *(_DWORD *)(v43 + 68);
        if (v44 <= 4)
          v45 = 0;
        else
          v45 = (v44 + 1) & 0xFFFFFFFE;
        v42 += v45;
      }
      while (v39 != v38);
    }
    v9 += v41 + v42 + 6;
  }
  if (v9)
    return (v9 + 18);
  else
    return 0;
}

uint64_t _TAG::priority(_TAG *this)
{
  int v1;
  uint64_t result;

  v1 = *((unsigned __int16 *)this + 20);
  result = 2;
  if (v1 <= 37384)
  {
    if (v1 == 33434)
      return 1;
    if (v1 != 36864 && v1 != 37121)
      return 0;
  }
  else if ((v1 - 40960) >= 4)
  {
    return (v1 - 41986) <= 4 && ((1 << (v1 - 2)) & 0x13) != 0 || v1 == 37385;
  }
  return result;
}

uint64_t _APP1::pruneContent(_APP1 *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _TAG **v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;

  v3 = *((_QWORD *)this + 12);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 16);
    v5 = *(_TAG ***)(v3 + 24);
    v6 = 126 - 2 * __clz(((uint64_t)v5 - v4) >> 3);
    if (v5 == (_TAG **)v4)
      v7 = 0;
    else
      v7 = v6;
    std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,false>(v4, v5, v7, 1);
    if (a2 >= 0xFFF8)
    {
      do
      {
        v8 = *(_QWORD *)(v3 + 16);
        v9 = *(_QWORD *)(v3 + 24) - v8;
        if ((v9 & 0x7FFF8) == 0)
          break;
        v10 = *(_QWORD *)(v8 + 8 * (unsigned __int16)((v9 >> 3) - 1));
        v11 = *(_DWORD *)(v10 + 68);
        v12 = v11 <= 4 ? 0 : (v11 + 1) & 0xFFFFFFFE;
        a2 = a2 - v12;
        _TAGList::removeTag(v3, (unsigned __int16 *)v10);
      }
      while (a2 > 0xFFF7);
    }
    v13 = *(_QWORD *)(v3 + 16);
    v14 = *(uint64_t **)(v3 + 24);
    v15 = 126 - 2 * __clz(((uint64_t)v14 - v13) >> 3);
    if (v14 == (uint64_t *)v13)
      v16 = 0;
    else
      v16 = v15;
    std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **,false>(v13, v14, v16, 1);
  }
  return a2;
}

void _APP1::writeToStream(_APP1 *this, __CFWriteStream *a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t *v14;
  uint64_t *v15;
  int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t *v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  unsigned int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  _BYTE *v54;
  unsigned int v55;
  __int16 v56;
  unsigned int v57;
  int v58;
  char v59;
  char v60;
  BOOL v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  char v66;
  _BYTE *v67;
  _BYTE *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t *v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  uint64_t v80;
  _BYTE *v81;
  char v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t *v86;
  uint64_t v87;
  unsigned int v88;
  uint64_t v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  uint64_t v94;
  _BYTE *v95;
  char v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t *v100;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  unsigned int v104;
  unsigned int v105;
  unsigned int v106;
  unsigned int v107;
  uint64_t v108;
  _BYTE *v109;
  char v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  unsigned int v114;
  uint64_t v115;
  _BYTE *v116;
  char v117;
  _WORD *v118;
  uint64_t v119;
  uint64_t *v120;
  uint64_t *v121;
  uint64_t *v122;
  uint64_t v123;
  unsigned int v124;
  uint64_t v125;
  unsigned int v126;
  int v127;
  int v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  uint64_t v132;
  unsigned int v133;
  uint64_t v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  uint64_t v139;
  char *v140;
  char v141;
  char v142;
  int v143;
  int v144;
  int v145;
  int v146;
  int v147;
  uint64_t v149;

  v3 = *((_QWORD *)this + 10);
  if (!v3)
  {
    v7 = 0;
    goto LABEL_10;
  }
  v6 = v3 + 16;
  v5 = *(uint64_t **)(v3 + 16);
  v4 = *(uint64_t **)(v6 + 8);
  v7 = 12 * (unsigned __int16)(((_DWORD)v4 - (_DWORD)v5) >> 3) + 6;
  if (v4 == v5)
  {
LABEL_10:
    v8 = 0;
    goto LABEL_11;
  }
  v8 = 0;
  do
  {
    v9 = *v5++;
    v10 = *(_DWORD *)(v9 + 68);
    if (v10 <= 4)
      v11 = 0;
    else
      v11 = (v10 + 1) & 0xFFFFFFFE;
    v8 += v11;
  }
  while (v5 != v4);
LABEL_11:
  v12 = *((_QWORD *)this + 11);
  if (!v12)
  {
    v21 = 0;
LABEL_22:
    v22 = 0;
LABEL_23:
    v23 = 0;
    goto LABEL_31;
  }
  v13 = (unsigned __int8 *)*((_QWORD *)this + 15);
  if (!v13)
  {
    v21 = 0;
    LODWORD(v12) = 0;
    goto LABEL_22;
  }
  v15 = *(uint64_t **)(v12 + 16);
  v14 = *(uint64_t **)(v12 + 24);
  v16 = (unsigned __int16)(((_DWORD)v14 - (_DWORD)v15) >> 3);
  if (v14 == v15)
  {
    v17 = 0;
  }
  else
  {
    v17 = 0;
    do
    {
      v18 = *v15++;
      v19 = *(_DWORD *)(v18 + 68);
      if (v19 <= 4)
        v20 = 0;
      else
        v20 = (v19 + 1) & 0xFFFFFFFE;
      v17 += v20;
    }
    while (v15 != v14);
  }
  v21 = 12 * v16 + 6;
  v24 = *((_DWORD *)this + 32);
  LODWORD(v12) = v24 + v17;
  if (__PAIR64__(v13[1], *v13) == 0xD8000000FFLL)
  {
    v22 = 0;
  }
  else
  {
    LODWORD(v12) = v12 + 2;
    v22 = 1;
  }
  if (v13[v24 - 2] == 255 && v13[v24 - 1] == 217)
    goto LABEL_23;
  LODWORD(v12) = v12 + 2;
  v23 = 1;
LABEL_31:
  v25 = *((_QWORD *)this + 12);
  if (v25)
  {
    v27 = *(uint64_t **)(v25 + 16);
    v26 = *(uint64_t **)(v25 + 24);
    v28 = 12 * (unsigned __int16)(((_DWORD)v26 - (_DWORD)v27) >> 3) + 6;
    if (v26 == v27)
    {
      LODWORD(v25) = 0;
    }
    else
    {
      LODWORD(v25) = 0;
      do
      {
        v29 = *v27++;
        v30 = *(_DWORD *)(v29 + 68);
        if (v30 <= 4)
          v31 = 0;
        else
          v31 = (v30 + 1) & 0xFFFFFFFE;
        LODWORD(v25) = v31 + v25;
      }
      while (v27 != v26);
    }
  }
  else
  {
    v28 = 0;
  }
  v32 = *((_QWORD *)this + 13);
  if (!v32)
  {
    v36 = 0;
    goto LABEL_50;
  }
  v35 = v32 + 16;
  v34 = *(uint64_t **)(v32 + 16);
  v33 = *(uint64_t **)(v35 + 8);
  v36 = 12 * (unsigned __int16)(((_DWORD)v33 - (_DWORD)v34) >> 3) + 6;
  if (v33 == v34)
  {
LABEL_50:
    v37 = 0;
    goto LABEL_51;
  }
  v37 = 0;
  do
  {
    v38 = *v34++;
    v39 = *(_DWORD *)(v38 + 68);
    if (v39 <= 4)
      v40 = 0;
    else
      v40 = (v39 + 1) & 0xFFFFFFFE;
    v37 += v40;
  }
  while (v34 != v33);
LABEL_51:
  v41 = *((_QWORD *)this + 14);
  if (v41)
  {
    v44 = v41 + 16;
    v43 = *(uint64_t **)(v41 + 16);
    v42 = *(uint64_t **)(v44 + 8);
    v45 = 12 * (unsigned __int16)(((_DWORD)v42 - (_DWORD)v43) >> 3) + 6;
    if (v42 != v43)
    {
      v46 = 0;
      do
      {
        v47 = *v43++;
        v48 = *(_DWORD *)(v47 + 68);
        if (v48 <= 4)
          v49 = 0;
        else
          v49 = (v48 + 1) & 0xFFFFFFFE;
        v46 += v49;
      }
      while (v43 != v42);
      if (v8)
        goto LABEL_66;
      goto LABEL_62;
    }
  }
  else
  {
    v45 = 0;
  }
  v46 = 0;
  if (v8)
    goto LABEL_66;
LABEL_62:
  if (!(_DWORD)v12 && !(_DWORD)v25 && !v37 && !v46)
    return;
LABEL_66:
  v143 = v23;
  v144 = v22;
  v145 = v21;
  v146 = v36;
  v147 = v45;
  v50 = v7 + v8 + v21 + v12 + v28 + v25 + v36 + v37 + v45 + v46;
  v51 = v50 + 16;
  v52 = ((v50 + 4111) & 0xFFFFF000) - 4;
  if (*((_BYTE *)this + 74))
    v53 = v52;
  else
    v53 = v51;
  v54 = malloc_type_calloc((v53 + 8), 1uLL, 0x379CFB8CuLL);
  if ((v53 + 8) >= 0x10000)
  {
    v55 = _APP1::pruneContent(this, v53);
    if (v55 >= 0xFFF8)
    {
      LogError("writeToStream", 2076, "*** ERROR: EXIF Data exceeds 64K limit, too big after truncation. Dropping 'APP1' marker.\n");
      free(v54);
      return;
    }
    LODWORD(v53) = v55;
    v28 = 12
        * (unsigned __int16)((*(_DWORD *)(*((_QWORD *)this + 12) + 24)
                                          - *(_DWORD *)(*((_QWORD *)this + 12) + 16)) >> 3)
        + 6;
  }
  v56 = *((_WORD *)this + 28);
  *v54 = HIBYTE(v56);
  v54[1] = v56;
  strcpy(v54 + 4, "Exif");
  v149 = 0;
  if (*((_BYTE *)this + 32))
    v57 = 18761;
  else
    v57 = 19789;
  *((_WORD *)v54 + 5) = __rev16(v57);
  v58 = (_DWORD)v54 + 10;
  if (*((_BYTE *)this + 32))
    v59 = 42;
  else
    v59 = 0;
  if (*((_BYTE *)this + 32))
    v60 = 0;
  else
    v60 = 42;
  v54[12] = v59;
  v54[13] = v60;
  v61 = *((_BYTE *)this + 32) == 0;
  v54[14] = 8 * *((_BYTE *)this + 32);
  *(_WORD *)(v54 + 15) = 0;
  v54[17] = 8 * v61;
  v62 = *((_QWORD *)this + 10);
  v63 = (uint64_t)&v54[v7 + 18];
  if (v62 && (v64 = *(_QWORD *)(v62 + 24) - *(_QWORD *)(v62 + 16), (unsigned __int16)(v64 >> 3)))
  {
    v65 = v64 >> 3;
    if (*((_BYTE *)this + 32))
      v66 = v65;
    else
      v66 = BYTE1(v65);
    if (*((_BYTE *)this + 32))
      LOBYTE(v65) = BYTE1(v65);
    v54[18] = v66;
    v54[19] = v65;
    (*(void (**)(_QWORD, _BYTE *, _BYTE *, uint64_t, char *, uint64_t *, _QWORD))(**((_QWORD **)this + 10)
                                                                                         + 16))(*((_QWORD *)this + 10), v54 + 10, v54 + 20, v63, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
    v67 = &v54[HIDWORD(v149) + 20];
  }
  else
  {
    v67 = 0;
  }
  v68 = (_BYTE *)(v63 + v8);
  v69 = *((_QWORD *)this + 12);
  if (v69)
  {
    v70 = *((_QWORD *)this + 10);
    if (v70)
    {
      v71 = *(uint64_t **)(v70 + 16);
      v72 = *(uint64_t **)(v70 + 24);
      if (v71 != v72)
      {
        while (*(unsigned __int16 *)(*v71 + 40) != 34665)
        {
          if (++v71 == v72)
            goto LABEL_105;
        }
      }
      if (v71 == v72)
        goto LABEL_105;
      v73 = *v71;
      if (!*v71)
        goto LABEL_105;
      v74 = (_DWORD)v68 - v58;
      v75 = *(_QWORD *)(v73 + 48);
      v76 = *(_DWORD *)(v75 + 8);
      if (*((_BYTE *)this + 32))
      {
        if (v76 != v74)
        {
          v77 = HIWORD(v74);
          v78 = v74 >> 8;
          LOBYTE(v79) = (_BYTE)v68 - v58;
          v74 >>= 24;
LABEL_104:
          *(_BYTE *)(v75 + 8) = v79;
          *(_BYTE *)(v75 + 9) = v78;
          *(_BYTE *)(v75 + 10) = v77;
          *(_BYTE *)(v75 + 11) = v74;
          v69 = *((_QWORD *)this + 12);
        }
      }
      else if (bswap32(v76) != v74)
      {
        v78 = HIWORD(v74);
        v79 = HIBYTE(v74);
        v77 = v74 >> 8;
        goto LABEL_104;
      }
LABEL_105:
      v80 = (*(_QWORD *)(v69 + 24) - *(_QWORD *)(v69 + 16)) >> 3;
      v81 = &v68[v28];
      if (*((_BYTE *)this + 32))
        v82 = v80;
      else
        v82 = BYTE1(v80);
      if (*((_BYTE *)this + 32))
        LOBYTE(v80) = BYTE1(v80);
      *v68 = v82;
      v68[1] = v80;
      (*(void (**)(_QWORD, _BYTE *, _BYTE *, _BYTE *, char *, uint64_t *, _QWORD))(**((_QWORD **)this + 12)
                                                                                           + 16))(*((_QWORD *)this + 12), v54 + 10, v68 + 2, v81, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
      v68 = &v81[v149];
    }
  }
  v83 = *((_QWORD *)this + 13);
  if (!v83)
    goto LABEL_131;
  v84 = *((_QWORD *)this + 10);
  if (!v84)
    goto LABEL_131;
  v85 = *(uint64_t **)(v84 + 16);
  v86 = *(uint64_t **)(v84 + 24);
  if (v85 != v86)
  {
    while (*(unsigned __int16 *)(*v85 + 40) != 34853)
    {
      if (++v85 == v86)
        goto LABEL_125;
    }
  }
  if (v85 != v86)
  {
    v87 = *v85;
    if (*v85)
    {
      v88 = (_DWORD)v68 - v58;
      v89 = *(_QWORD *)(v87 + 48);
      v90 = *(_DWORD *)(v89 + 8);
      if (*((_BYTE *)this + 32))
      {
        if (v90 != v88)
        {
          v91 = HIWORD(v88);
          v92 = v88 >> 8;
          LOBYTE(v93) = (_BYTE)v68 - v58;
          v88 >>= 24;
LABEL_124:
          *(_BYTE *)(v89 + 8) = v93;
          *(_BYTE *)(v89 + 9) = v92;
          *(_BYTE *)(v89 + 10) = v91;
          *(_BYTE *)(v89 + 11) = v88;
          v83 = *((_QWORD *)this + 13);
        }
      }
      else if (bswap32(v90) != v88)
      {
        v92 = HIWORD(v88);
        v93 = HIBYTE(v88);
        v91 = v88 >> 8;
        goto LABEL_124;
      }
    }
  }
LABEL_125:
  v94 = (*(_QWORD *)(v83 + 24) - *(_QWORD *)(v83 + 16)) >> 3;
  v95 = &v68[v146];
  if (*((_BYTE *)this + 32))
    v96 = v94;
  else
    v96 = BYTE1(v94);
  if (*((_BYTE *)this + 32))
    LOBYTE(v94) = BYTE1(v94);
  *v68 = v96;
  v68[1] = v94;
  (*(void (**)(_QWORD, _BYTE *, _BYTE *, _BYTE *, char *, uint64_t *, _QWORD))(**((_QWORD **)this + 13) + 16))(*((_QWORD *)this + 13), v54 + 10, v68 + 2, v95, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
  v68 = &v95[v37];
LABEL_131:
  v97 = *((_QWORD *)this + 14);
  if (v97)
  {
    v98 = *((_QWORD *)this + 12);
    if (v98)
    {
      v99 = *(uint64_t **)(v98 + 16);
      v100 = *(uint64_t **)(v98 + 24);
      if (v99 != v100)
      {
        while (*(unsigned __int16 *)(*v99 + 40) != 40965)
        {
          if (++v99 == v100)
            goto LABEL_145;
        }
      }
      if (v99 == v100)
        goto LABEL_145;
      v101 = *v99;
      if (!*v99)
        goto LABEL_145;
      v102 = (_DWORD)v68 - v58;
      v103 = *(_QWORD *)(v101 + 48);
      v104 = *(_DWORD *)(v103 + 8);
      if (*((_BYTE *)this + 32))
      {
        if (v104 != v102)
        {
          v105 = HIWORD(v102);
          v106 = v102 >> 8;
          LOBYTE(v107) = (_BYTE)v68 - v58;
          v102 >>= 24;
LABEL_144:
          *(_BYTE *)(v103 + 8) = v107;
          *(_BYTE *)(v103 + 9) = v106;
          *(_BYTE *)(v103 + 10) = v105;
          *(_BYTE *)(v103 + 11) = v102;
          v97 = *((_QWORD *)this + 14);
        }
      }
      else if (bswap32(v104) != v102)
      {
        v106 = HIWORD(v102);
        v107 = HIBYTE(v102);
        v105 = v102 >> 8;
        goto LABEL_144;
      }
LABEL_145:
      v108 = (*(_QWORD *)(v97 + 24) - *(_QWORD *)(v97 + 16)) >> 3;
      v109 = &v68[v147];
      if (*((_BYTE *)this + 32))
        v110 = v108;
      else
        v110 = BYTE1(v108);
      if (*((_BYTE *)this + 32))
        LOBYTE(v108) = BYTE1(v108);
      *v68 = v110;
      v68[1] = v108;
      (*(void (**)(_QWORD, _BYTE *, _BYTE *, _BYTE *, char *, uint64_t *, _QWORD))(**((_QWORD **)this + 14)
                                                                                           + 16))(*((_QWORD *)this + 14), v54 + 10, v68 + 2, v109, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
      v68 = &v109[v46];
    }
  }
  if (*((_QWORD *)this + 11) && *((_QWORD *)this + 15) && v67)
  {
    v111 = (_DWORD)v68 - v58;
    v112 = ((_DWORD)v68 - v58) >> 16;
    if (*((_BYTE *)this + 32))
    {
      v113 = v111 >> 8;
      LOBYTE(v114) = (_BYTE)v68 - v58;
      v111 >>= 24;
    }
    else
    {
      v114 = HIBYTE(v111);
      v113 = HIWORD(v111);
      v112 = v111 >> 8;
    }
    *v67 = v114;
    v67[1] = v113;
    v67[2] = v112;
    v67[3] = v111;
    v115 = (*(_QWORD *)(*((_QWORD *)this + 11) + 24) - *(_QWORD *)(*((_QWORD *)this + 11) + 16)) >> 3;
    v116 = &v68[v145];
    if (*((_BYTE *)this + 32))
      v117 = (*(_QWORD *)(*((_QWORD *)this + 11) + 24) - *(_QWORD *)(*((_QWORD *)this + 11) + 16)) >> 3;
    else
      v117 = (*(_QWORD *)(*((_QWORD *)this + 11) + 24) - *(_QWORD *)(*((_QWORD *)this + 11) + 16)) >> 11;
    if (*((_BYTE *)this + 32))
      LOBYTE(v115) = (*(_QWORD *)(*((_QWORD *)this + 11) + 24) - *(_QWORD *)(*((_QWORD *)this + 11) + 16)) >> 11;
    *v68 = v117;
    v68[1] = v115;
    (*(void (**)(_QWORD, _BYTE *, _BYTE *, _BYTE *, char *, uint64_t *, _QWORD))(**((_QWORD **)this + 11)
                                                                                         + 16))(*((_QWORD *)this + 11), v54 + 10, v68 + 2, v116, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
    v118 = &v116[v149];
    v119 = *((_QWORD *)this + 11);
    v120 = *(uint64_t **)(v119 + 16);
    v121 = *(uint64_t **)(v119 + 24);
    v122 = v120;
    if (v120 != v121)
    {
      v122 = v120;
      while (*(_WORD *)(*v122 + 40) != 513)
      {
        if (++v122 == v121)
          goto LABEL_172;
      }
    }
    if (v122 == v121 || (v123 = *v122) == 0)
    {
LABEL_172:
      v128 = v143;
      v127 = v144;
      goto LABEL_173;
    }
    v124 = (_DWORD)v118 - v58;
    v125 = *(_QWORD *)(v123 + 48);
    v126 = *(_DWORD *)(v125 + 8);
    if (*((_BYTE *)this + 32))
    {
      v128 = v143;
      v127 = v144;
      if (v126 == v124)
        goto LABEL_173;
      v129 = HIWORD(v124);
      v130 = v124 >> 8;
      LOBYTE(v131) = (_BYTE)v118 - v58;
      v124 >>= 24;
    }
    else
    {
      v128 = v143;
      v127 = v144;
      if (bswap32(v126) == v124)
        goto LABEL_173;
      v130 = HIWORD(v124);
      v131 = HIBYTE(v124);
      v129 = v124 >> 8;
    }
    *(_BYTE *)(v125 + 8) = v131;
    *(_BYTE *)(v125 + 9) = v130;
    *(_BYTE *)(v125 + 10) = v129;
    *(_BYTE *)(v125 + 11) = v124;
    v139 = *((_QWORD *)this + 11);
    v120 = *(uint64_t **)(v139 + 16);
    v121 = *(uint64_t **)(v139 + 24);
LABEL_173:
    while (v120 != v121)
    {
      v132 = *v120;
      if (*(_WORD *)(*v120 + 40) == 514)
      {
        if (v120 != v121 && v132)
        {
          v133 = *((_DWORD *)this + 32);
          if (v127)
            v133 += 2;
          v134 = *(_QWORD *)(v132 + 48);
          v135 = *(_DWORD *)(v134 + 8);
          if (*((_BYTE *)this + 32))
          {
            if (v135 == v133)
              break;
            v136 = HIWORD(v133);
            v137 = v133 >> 8;
            LOBYTE(v138) = v133;
            v133 >>= 24;
          }
          else
          {
            if (bswap32(v135) == v133)
              break;
            v137 = HIWORD(v133);
            v138 = HIBYTE(v133);
            v136 = v133 >> 8;
          }
          *(_BYTE *)(v134 + 8) = v138;
          *(_BYTE *)(v134 + 9) = v137;
          *(_BYTE *)(v134 + 10) = v136;
          *(_BYTE *)(v134 + 11) = v133;
        }
        break;
      }
      ++v120;
    }
    if (v127)
      *v118++ = -9985;
    memcpy(v118, *((const void **)this + 15), *((unsigned int *)this + 32));
    v140 = (char *)v118 + *((unsigned int *)this + 32);
    if (v128)
    {
      if (*((_BYTE *)this + 32))
        v141 = -39;
      else
        v141 = -1;
      if (*((_BYTE *)this + 32))
        v142 = -1;
      else
        v142 = -39;
      *v140 = v141;
      v140[1] = v142;
      v140 += 2;
    }
    *(_WORD *)v140 = 0;
  }
  *((_WORD *)v54 + 1) = bswap32(v53 + 2) >> 16;
  CFWriteStreamWrite(a2, v54, (v53 + 4));
  free(v54);
}

double _APP1::addMissingIFDTags(_APP1 *this, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _TAG *v12;
  double result;
  uint64_t v14;
  uint64_t v15;
  _TAG *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  char v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  char v26;
  int v27;
  _QWORD *v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  int v57;
  char v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char v62;
  unsigned int v63;
  char v64;
  uint64_t v65;
  uint64_t v66;
  char v67;
  unsigned int v68;
  char v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char v74;
  char v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  char v81;
  int v82;
  char *v83;

  v8 = *((_QWORD *)this + 10);
  if (v8)
  {
    v9 = *(_QWORD *)(v8 + 16);
    v10 = *(_QWORD *)(v8 + 24);
    v11 = v9;
    if (v9 != v10)
    {
      v11 = v9;
      while (*(_WORD *)(*(_QWORD *)v11 + 40) != 282)
      {
        v11 += 8;
        if (v11 == v10)
          goto LABEL_9;
      }
    }
    if (v11 == v10 || !*(_QWORD *)v11)
    {
LABEL_9:
      v12 = (_TAG *)newRationalTag(282, *((unsigned __int8 *)this + 32));
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), v12).n128_u64[0];
      v14 = *((_QWORD *)this + 10);
      v9 = *(_QWORD *)(v14 + 16);
      v10 = *(_QWORD *)(v14 + 24);
    }
    if (v9 == v10)
      goto LABEL_17;
    v15 = v9;
    while (*(_WORD *)(*(_QWORD *)v15 + 40) != 283)
    {
      v15 += 8;
      if (v15 == v10)
        goto LABEL_17;
    }
    if (v15 == v10 || !*(_QWORD *)v15)
    {
LABEL_17:
      v16 = (_TAG *)newRationalTag(283, *((unsigned __int8 *)this + 32));
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), v16).n128_u64[0];
      v17 = *((_QWORD *)this + 10);
      v9 = *(_QWORD *)(v17 + 16);
      v10 = *(_QWORD *)(v17 + 24);
    }
    if (v9 != v10)
    {
      v18 = v9;
      while (*(_WORD *)(*(_QWORD *)v18 + 40) != 296)
      {
        v18 += 8;
        if (v18 == v10)
          goto LABEL_25;
      }
      if (v18 != v10 && *(_QWORD *)v18)
        goto LABEL_29;
    }
LABEL_25:
    v19 = operator new();
    v20 = *((_BYTE *)this + 32);
    v21 = *((_BYTE *)this + 8);
    if (v20)
      v22 = 2;
    else
      v22 = 512;
    *(_QWORD *)v19 = &off_1E1BB2600;
    *(_QWORD *)(v19 + 8) = 0;
    *(_BYTE *)(v19 + 24) = v20;
    *(_DWORD *)(v19 + 28) = 0;
    *(_QWORD *)(v19 + 48) = 0;
    *(_QWORD *)(v19 + 32) = 0;
    *(_BYTE *)(v19 + 80) = v21 | 0x40;
    *(_WORD *)(v19 + 40) = 296;
    *(_WORD *)(v19 + 56) = 3;
    *(_DWORD *)(v19 + 60) = 1;
    *(_DWORD *)(v19 + 64) = v22;
    *(_QWORD *)(v19 + 72) = 0;
    *(_BYTE *)(v19 + 81) = 0;
    *(_DWORD *)(v19 + 68) = 2;
    *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), (_TAG *)v19).n128_u64[0];
    v23 = *((_QWORD *)this + 10);
    v9 = *(_QWORD *)(v23 + 16);
    v10 = *(_QWORD *)(v23 + 24);
LABEL_29:
    while (v9 != v10)
    {
      if (*(_WORD *)(*(_QWORD *)v9 + 40) == 531)
      {
        if (v9 != v10 && *(_QWORD *)v9)
          goto LABEL_38;
        break;
      }
      v9 += 8;
    }
    v24 = operator new();
    v25 = *((_BYTE *)this + 32);
    v26 = *((_BYTE *)this + 8);
    if (v25)
      v27 = 1;
    else
      v27 = 256;
    *(_QWORD *)v24 = &off_1E1BB2600;
    *(_QWORD *)(v24 + 8) = 0;
    *(_BYTE *)(v24 + 24) = v25;
    *(_DWORD *)(v24 + 28) = 0;
    *(_QWORD *)(v24 + 48) = 0;
    *(_QWORD *)(v24 + 32) = 0;
    *(_BYTE *)(v24 + 80) = v26 | 0x40;
    *(_WORD *)(v24 + 40) = 531;
    *(_WORD *)(v24 + 56) = 3;
    *(_DWORD *)(v24 + 60) = 1;
    *(_DWORD *)(v24 + 64) = v27;
    *(_QWORD *)(v24 + 72) = 0;
    *(_BYTE *)(v24 + 81) = 0;
    *(_DWORD *)(v24 + 68) = 2;
    *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), (_TAG *)v24).n128_u64[0];
  }
LABEL_38:
  v28 = (_QWORD *)*((_QWORD *)this + 12);
  if (!v28)
  {
    v29 = operator new();
    v30 = *((_BYTE *)this + 8);
    *(_QWORD *)(v29 + 24) = 0;
    *(_QWORD *)(v29 + 32) = 0;
    *(_BYTE *)(v29 + 41) = v30;
    *(_QWORD *)(v29 + 8) = 0;
    *(_QWORD *)(v29 + 16) = 0;
    *(_QWORD *)v29 = &off_1E1BB2EE8;
    *((_QWORD *)this + 12) = v29;
    *(_BYTE *)(v29 + 40) = *((_BYTE *)this + 32);
    v82 = *((unsigned __int16 *)this + 28);
    v83 = 0;
    asprintf(&v83, "_exifIFD '%04X'", v82);
    v28 = (_QWORD *)*((_QWORD *)this + 12);
    v28[1] = v83;
  }
  v31 = *((_QWORD *)this + 10);
  if (v31)
  {
    v32 = *(_QWORD *)(v31 + 16);
    v33 = *(_QWORD *)(v31 + 24);
    if (v32 != v33)
    {
      while (*(unsigned __int16 *)(*(_QWORD *)v32 + 40) != 34665)
      {
        v32 += 8;
        if (v32 == v33)
          goto LABEL_47;
      }
    }
    if (v32 == v33 || !*(_QWORD *)v32)
    {
LABEL_47:
      v34 = operator new();
      v35 = *((_BYTE *)this + 32);
      v36 = *((_BYTE *)this + 8) | 0x40;
      *(_QWORD *)v34 = &off_1E1BB2600;
      *(_QWORD *)(v34 + 8) = 0;
      *(_BYTE *)(v34 + 24) = v35;
      *(_DWORD *)(v34 + 28) = 0;
      *(_QWORD *)(v34 + 48) = 0;
      *(_QWORD *)(v34 + 32) = 0;
      *(_BYTE *)(v34 + 80) = v36;
      *(_WORD *)(v34 + 40) = -30871;
      *(_WORD *)(v34 + 56) = 4;
      *(_QWORD *)(v34 + 60) = 1;
      *(_QWORD *)(v34 + 72) = 0;
      *(_BYTE *)(v34 + 81) = 0;
      *(_DWORD *)(v34 + 68) = 4;
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), (_TAG *)v34).n128_u64[0];
      v28 = (_QWORD *)*((_QWORD *)this + 12);
    }
    v37 = v28[2];
    v38 = v28[3];
    v39 = v37;
    if (v37 != v38)
    {
      v39 = v37;
      while (*(__int16 *)(*(_QWORD *)v39 + 40) != -28672)
      {
        v39 += 8;
        if (v39 == v38)
          goto LABEL_55;
      }
    }
    if (v39 == v38 || !*(_QWORD *)v39)
    {
LABEL_55:
      v40 = operator new();
      v41 = *((_BYTE *)this + 32);
      v42 = *((_BYTE *)this + 8) | 0x40;
      *(_QWORD *)v40 = &off_1E1BB2600;
      *(_QWORD *)(v40 + 8) = 0;
      *(_BYTE *)(v40 + 24) = v41;
      *(_DWORD *)(v40 + 28) = 0;
      *(_QWORD *)(v40 + 48) = 0;
      *(_QWORD *)(v40 + 32) = 0;
      *(_BYTE *)(v40 + 80) = v42;
      *(_WORD *)(v40 + 40) = -28672;
      *(_WORD *)(v40 + 56) = 7;
      *(_QWORD *)(v40 + 60) = 0x3133323000000004;
      *(_QWORD *)(v40 + 72) = 0;
      *(_BYTE *)(v40 + 81) = 0;
      *(_DWORD *)(v40 + 68) = 4;
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 12), (_TAG *)v40).n128_u64[0];
      v43 = *((_QWORD *)this + 12);
      v37 = *(_QWORD *)(v43 + 16);
      v38 = *(_QWORD *)(v43 + 24);
    }
    if (v37 == v38)
      goto LABEL_63;
    v44 = v37;
    while (*(unsigned __int16 *)(*(_QWORD *)v44 + 40) != 37121)
    {
      v44 += 8;
      if (v44 == v38)
        goto LABEL_63;
    }
    if (v44 == v38 || !*(_QWORD *)v44)
    {
LABEL_63:
      v45 = operator new();
      v46 = *((_BYTE *)this + 32);
      v47 = *((_BYTE *)this + 8) | 0x40;
      *(_QWORD *)v45 = &off_1E1BB2600;
      *(_QWORD *)(v45 + 8) = 0;
      *(_BYTE *)(v45 + 24) = v46;
      *(_DWORD *)(v45 + 28) = 0;
      *(_QWORD *)(v45 + 48) = 0;
      *(_QWORD *)(v45 + 32) = 0;
      *(_BYTE *)(v45 + 80) = v47;
      *(_WORD *)(v45 + 40) = -28415;
      *(_WORD *)(v45 + 56) = 7;
      *(_QWORD *)(v45 + 60) = 0x3020100000004;
      *(_QWORD *)(v45 + 72) = 0;
      *(_BYTE *)(v45 + 81) = 0;
      *(_DWORD *)(v45 + 68) = 4;
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 12), (_TAG *)v45).n128_u64[0];
      v48 = *((_QWORD *)this + 12);
      v37 = *(_QWORD *)(v48 + 16);
      v38 = *(_QWORD *)(v48 + 24);
    }
    if (v37 == v38)
      goto LABEL_71;
    v49 = v37;
    while (*(__int16 *)(*(_QWORD *)v49 + 40) != -24576)
    {
      v49 += 8;
      if (v49 == v38)
        goto LABEL_71;
    }
    if (v49 == v38 || !*(_QWORD *)v49)
    {
LABEL_71:
      v50 = operator new();
      v51 = *((_BYTE *)this + 32);
      v52 = *((_BYTE *)this + 8) | 0x40;
      *(_QWORD *)v50 = &off_1E1BB2600;
      *(_QWORD *)(v50 + 8) = 0;
      *(_BYTE *)(v50 + 24) = v51;
      *(_DWORD *)(v50 + 28) = 0;
      *(_QWORD *)(v50 + 48) = 0;
      *(_QWORD *)(v50 + 32) = 0;
      *(_BYTE *)(v50 + 80) = v52;
      *(_WORD *)(v50 + 40) = -24576;
      *(_WORD *)(v50 + 56) = 7;
      *(_QWORD *)(v50 + 60) = 0x3030313000000004;
      *(_QWORD *)(v50 + 72) = 0;
      *(_BYTE *)(v50 + 81) = 0;
      *(_DWORD *)(v50 + 68) = 4;
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 12), (_TAG *)v50).n128_u64[0];
      v53 = *((_QWORD *)this + 12);
      v37 = *(_QWORD *)(v53 + 16);
      v38 = *(_QWORD *)(v53 + 24);
    }
    if (v37 == v38)
      goto LABEL_79;
    v54 = v37;
    while (*(unsigned __int16 *)(*(_QWORD *)v54 + 40) != 40961)
    {
      v54 += 8;
      if (v54 == v38)
        goto LABEL_79;
    }
    if (v54 == v38 || !*(_QWORD *)v54)
    {
LABEL_79:
      v55 = operator new();
      v56 = *((_BYTE *)this + 32);
      if (v56)
        v57 = 1;
      else
        v57 = 256;
      if (a4 != 3)
        v57 = 0xFFFF;
      v58 = *((_BYTE *)this + 8);
      *(_QWORD *)v55 = &off_1E1BB2600;
      *(_QWORD *)(v55 + 8) = 0;
      *(_BYTE *)(v55 + 24) = v56;
      *(_DWORD *)(v55 + 28) = 0;
      *(_QWORD *)(v55 + 48) = 0;
      *(_QWORD *)(v55 + 32) = 0;
      *(_BYTE *)(v55 + 80) = v58 | 0x40;
      *(_WORD *)(v55 + 40) = -24575;
      *(_WORD *)(v55 + 56) = 3;
      *(_DWORD *)(v55 + 60) = 1;
      *(_DWORD *)(v55 + 64) = v57;
      *(_QWORD *)(v55 + 72) = 0;
      *(_BYTE *)(v55 + 81) = 0;
      *(_DWORD *)(v55 + 68) = 2;
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 12), (_TAG *)v55).n128_u64[0];
      v59 = *((_QWORD *)this + 12);
      v37 = *(_QWORD *)(v59 + 16);
      v38 = *(_QWORD *)(v59 + 24);
    }
    if (v37 == v38)
      goto LABEL_92;
    v60 = v37;
    while (*(unsigned __int16 *)(*(_QWORD *)v60 + 40) != 40962)
    {
      v60 += 8;
      if (v60 == v38)
        goto LABEL_92;
    }
    if (v60 == v38 || !*(_QWORD *)v60)
    {
LABEL_92:
      v61 = operator new();
      v62 = *((_BYTE *)this + 32);
      v63 = bswap32(a2);
      if (v62)
        v63 = a2;
      v64 = *((_BYTE *)this + 8) | 0x40;
      *(_QWORD *)v61 = &off_1E1BB2600;
      *(_QWORD *)(v61 + 8) = 0;
      *(_BYTE *)(v61 + 24) = v62;
      *(_DWORD *)(v61 + 28) = 0;
      *(_QWORD *)(v61 + 48) = 0;
      *(_QWORD *)(v61 + 32) = 0;
      *(_BYTE *)(v61 + 80) = v64;
      *(_WORD *)(v61 + 40) = -24574;
      *(_WORD *)(v61 + 56) = 4;
      *(_DWORD *)(v61 + 60) = 1;
      *(_DWORD *)(v61 + 64) = v63;
      *(_QWORD *)(v61 + 72) = 0;
      *(_BYTE *)(v61 + 81) = 0;
      *(_DWORD *)(v61 + 68) = 4;
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 12), (_TAG *)v61).n128_u64[0];
      v65 = *((_QWORD *)this + 12);
      v37 = *(_QWORD *)(v65 + 16);
      v38 = *(_QWORD *)(v65 + 24);
    }
    if (v37 == v38)
      goto LABEL_101;
    while (*(unsigned __int16 *)(*(_QWORD *)v37 + 40) != 40963)
    {
      v37 += 8;
      if (v37 == v38)
        goto LABEL_101;
    }
    if (v37 == v38 || !*(_QWORD *)v37)
    {
LABEL_101:
      v66 = operator new();
      v67 = *((_BYTE *)this + 32);
      v68 = bswap32(a3);
      if (v67)
        v68 = a3;
      v69 = *((_BYTE *)this + 8) | 0x40;
      *(_QWORD *)v66 = &off_1E1BB2600;
      *(_QWORD *)(v66 + 8) = 0;
      *(_BYTE *)(v66 + 24) = v67;
      *(_DWORD *)(v66 + 28) = 0;
      *(_QWORD *)(v66 + 48) = 0;
      *(_QWORD *)(v66 + 32) = 0;
      *(_BYTE *)(v66 + 80) = v69;
      *(_WORD *)(v66 + 40) = -24573;
      *(_WORD *)(v66 + 56) = 4;
      *(_DWORD *)(v66 + 60) = 1;
      *(_DWORD *)(v66 + 64) = v68;
      *(_QWORD *)(v66 + 72) = 0;
      *(_BYTE *)(v66 + 81) = 0;
      *(_DWORD *)(v66 + 68) = 4;
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 12), (_TAG *)v66).n128_u64[0];
    }
    v70 = *((_QWORD *)this + 10);
    if (v70 && *((_QWORD *)this + 13))
    {
      v71 = *(_QWORD *)(v70 + 16);
      v72 = *(_QWORD *)(v70 + 24);
      if (v71 != v72)
      {
        while (*(unsigned __int16 *)(*(_QWORD *)v71 + 40) != 34853)
        {
          v71 += 8;
          if (v71 == v72)
            goto LABEL_112;
        }
      }
      if (v71 == v72 || !*(_QWORD *)v71)
      {
LABEL_112:
        v73 = operator new();
        v74 = *((_BYTE *)this + 32);
        v75 = *((_BYTE *)this + 8) | 0x40;
        *(_QWORD *)v73 = &off_1E1BB2600;
        *(_QWORD *)(v73 + 8) = 0;
        *(_BYTE *)(v73 + 24) = v74;
        *(_DWORD *)(v73 + 28) = 0;
        *(_QWORD *)(v73 + 48) = 0;
        *(_QWORD *)(v73 + 32) = 0;
        *(_BYTE *)(v73 + 80) = v75;
        *(_WORD *)(v73 + 40) = -30683;
        *(_WORD *)(v73 + 56) = 4;
        *(_QWORD *)(v73 + 60) = 1;
        *(_QWORD *)(v73 + 72) = 0;
        *(_BYTE *)(v73 + 81) = 0;
        *(_DWORD *)(v73 + 68) = 4;
        *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), (_TAG *)v73).n128_u64[0];
      }
    }
  }
  if (*((_QWORD *)this + 14))
  {
    v76 = *((_QWORD *)this + 12);
    v77 = *(_QWORD *)(v76 + 16);
    v78 = *(_QWORD *)(v76 + 24);
    if (v77 != v78)
    {
      while (*(unsigned __int16 *)(*(_QWORD *)v77 + 40) != 40965)
      {
        v77 += 8;
        if (v77 == v78)
          goto LABEL_120;
      }
    }
    if (v77 == v78 || !*(_QWORD *)v77)
    {
LABEL_120:
      v79 = operator new();
      v80 = *((_BYTE *)this + 32);
      v81 = *((_BYTE *)this + 8) | 0x40;
      *(_QWORD *)v79 = &off_1E1BB2600;
      *(_QWORD *)(v79 + 8) = 0;
      *(_BYTE *)(v79 + 24) = v80;
      *(_DWORD *)(v79 + 28) = 0;
      *(_QWORD *)(v79 + 48) = 0;
      *(_QWORD *)(v79 + 32) = 0;
      *(_BYTE *)(v79 + 80) = v81;
      *(_WORD *)(v79 + 40) = -24571;
      *(_WORD *)(v79 + 56) = 4;
      *(_QWORD *)(v79 + 60) = 1;
      *(_QWORD *)(v79 + 72) = 0;
      *(_BYTE *)(v79 + 81) = 0;
      *(_DWORD *)(v79 + 68) = 4;
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 12), (_TAG *)v79).n128_u64[0];
    }
  }
  return result;
}

uint64_t newRationalTag(__int16 a1, int a2)
{
  uint64_t v4;
  _DWORD *v5;
  int v6;
  int v7;

  v4 = operator new();
  *(_QWORD *)v4 = &off_1E1BB2600;
  *(_QWORD *)(v4 + 8) = 0;
  *(_BYTE *)(v4 + 24) = a2;
  *(_DWORD *)(v4 + 28) = 0;
  *(_QWORD *)(v4 + 48) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_BYTE *)(v4 + 80) = 64;
  *(_WORD *)(v4 + 40) = a1;
  *(_WORD *)(v4 + 56) = 5;
  *(_QWORD *)(v4 + 60) = 1;
  v5 = (_DWORD *)operator new[]();
  if (a2)
    v6 = 1;
  else
    v6 = 0x1000000;
  *(_QWORD *)(v4 + 72) = v5;
  if (a2)
    v7 = 72;
  else
    v7 = 1207959552;
  *v5 = v7;
  v5[1] = v6;
  *(_BYTE *)(v4 + 81) = 1;
  *(_DWORD *)(v4 + 68) = 8;
  return v4;
}

void sub_188026524(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

BOOL _APP1::updateDateTime(_APP1 *this, char *__s)
{
  __n128 inserted;
  uint64_t v5;
  _BOOL8 v6;
  _QWORD *v7;
  _QWORD *v8;
  _TAG *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  __n128 v13;
  _TAG *v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  _TAG *v18;

  if (strlen(__s) != 19)
    return 0;
  v5 = *((_QWORD *)this + 10);
  v6 = v5 != 0;
  if (v5)
  {
    v7 = *(_QWORD **)(v5 + 16);
    v8 = *(_QWORD **)(v5 + 24);
    if (v7 != v8)
    {
      while (*(_WORD *)(*v7 + 40) != 306)
      {
        if (++v7 == v8)
          goto LABEL_11;
      }
    }
    if (v7 == v8 || !*v7)
    {
LABEL_11:
      v9 = (_TAG *)operator new();
      _TAG::_TAG(v9, *((_BYTE *)this + 32), 306, 2, 20, (unsigned __int8 *)__s, 0x14u, 0, *((_BYTE *)this + 8) | 0x40, 1);
      inserted = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), v9);
    }
    else
    {
      (*(void (**)(_QWORD, char *))(*(_QWORD *)*v7 + 88))(*v7, __s);
    }
  }
  v10 = *((_QWORD *)this + 12);
  if (v10)
  {
    v11 = *(_QWORD **)(v10 + 16);
    v12 = *(_QWORD **)(v10 + 24);
    if (v11 != v12)
    {
      while (*(unsigned __int16 *)(*v11 + 40) != 36867)
      {
        if (++v11 == v12)
          goto LABEL_20;
      }
    }
    if (v11 == v12 || !*v11)
    {
LABEL_20:
      v14 = (_TAG *)operator new();
      _TAG::_TAG(v14, *((_BYTE *)this + 32), 36867, 2, 20, (unsigned __int8 *)__s, 0x14u, 0, *((_BYTE *)this + 8) | 0x40, 1);
      v13 = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 12), v14);
    }
    else
    {
      (*(void (**)(_QWORD, char *, __n128))(*(_QWORD *)*v11 + 88))(*v11, __s, inserted);
    }
    v15 = *((_QWORD *)this + 12);
    v16 = *(_QWORD **)(v15 + 16);
    v17 = *(_QWORD **)(v15 + 24);
    if (v16 != v17)
    {
      while (*(unsigned __int16 *)(*v16 + 40) != 36868)
      {
        if (++v16 == v17)
          goto LABEL_28;
      }
    }
    if (v16 == v17 || !*v16)
    {
LABEL_28:
      v18 = (_TAG *)operator new();
      _TAG::_TAG(v18, *((_BYTE *)this + 32), 36868, 2, 20, (unsigned __int8 *)__s, 0x14u, 0, *((_BYTE *)this + 8) | 0x40, 1);
      _TAGList::insertTag(*((_TAGList **)this + 12), v18);
    }
    else
    {
      (*(void (**)(_QWORD, char *, __n128))(*(_QWORD *)*v16 + 88))(*v16, __s, v13);
    }
    return 1;
  }
  return v6;
}

void sub_1880267C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

double _APP1::updateSubSecTime(_APP1 *this, char *__s)
{
  char *v2;
  size_t v4;
  double result;
  unsigned int v6;
  uint64_t v7;
  unsigned __int16 **v8;
  unsigned __int16 **v9;
  uint64_t v10;
  char v11;
  int v12;
  char v13;
  uint64_t v14;
  unsigned __int16 **v15;
  unsigned __int16 **v16;
  uint64_t v17;
  char v18;
  int v19;
  char v20;
  uint64_t v21;
  unsigned __int16 **v22;
  unsigned __int16 **v23;
  uint64_t v24;
  char v25;
  int v26;
  char v27;
  int __dst;

  v2 = __s;
  v4 = strlen(__s);
  v6 = v4 + 1;
  __dst = 0;
  if ((v4 + 1) <= 4)
    memcpy(&__dst, v2, v4);
  v7 = *((_QWORD *)this + 12);
  if (v7)
  {
    v8 = *(unsigned __int16 ***)(v7 + 16);
    v9 = *(unsigned __int16 ***)(v7 + 24);
    if (v8 != v9)
    {
      while ((*v8)[20] != 37520)
      {
        if (++v8 == v9)
          goto LABEL_11;
      }
    }
    if (v8 != v9 && *v8)
      _TAGList::removeTag(v7, *v8);
LABEL_11:
    v10 = operator new();
    v11 = *((_BYTE *)this + 32);
    v12 = __dst;
    if (v6 <= 4)
      v2 = 0;
    else
      v12 = 0;
    v13 = *((_BYTE *)this + 8) | 0x40;
    *(_QWORD *)v10 = &off_1E1BB2600;
    *(_QWORD *)(v10 + 8) = 0;
    *(_BYTE *)(v10 + 24) = v11;
    *(_DWORD *)(v10 + 28) = 0;
    *(_QWORD *)(v10 + 48) = 0;
    *(_QWORD *)(v10 + 32) = 0;
    *(_BYTE *)(v10 + 80) = v13;
    *(_WORD *)(v10 + 40) = -28016;
    *(_WORD *)(v10 + 56) = 2;
    *(_DWORD *)(v10 + 60) = v6;
    *(_DWORD *)(v10 + 64) = v12;
    *(_QWORD *)(v10 + 72) = v2;
    *(_BYTE *)(v10 + 81) = 0;
    *(_DWORD *)(v10 + 68) = v6;
    _TAGList::insertTag(*((_TAGList **)this + 12), (_TAG *)v10);
    v14 = *((_QWORD *)this + 12);
    v15 = *(unsigned __int16 ***)(v14 + 16);
    v16 = *(unsigned __int16 ***)(v14 + 24);
    if (v15 != v16)
    {
      while ((*v15)[20] != 37521)
      {
        if (++v15 == v16)
          goto LABEL_21;
      }
    }
    if (v15 != v16 && *v15)
      _TAGList::removeTag(v14, *v15);
LABEL_21:
    v17 = operator new();
    v18 = *((_BYTE *)this + 32);
    v19 = __dst;
    if (v6 > 4)
      v19 = 0;
    v20 = *((_BYTE *)this + 8) | 0x40;
    *(_QWORD *)v17 = &off_1E1BB2600;
    *(_QWORD *)(v17 + 8) = 0;
    *(_BYTE *)(v17 + 24) = v18;
    *(_DWORD *)(v17 + 28) = 0;
    *(_QWORD *)(v17 + 48) = 0;
    *(_QWORD *)(v17 + 32) = 0;
    *(_BYTE *)(v17 + 80) = v20;
    *(_WORD *)(v17 + 40) = -28015;
    *(_WORD *)(v17 + 56) = 2;
    *(_DWORD *)(v17 + 60) = v6;
    *(_DWORD *)(v17 + 64) = v19;
    *(_QWORD *)(v17 + 72) = v2;
    *(_BYTE *)(v17 + 81) = 0;
    *(_DWORD *)(v17 + 68) = v6;
    _TAGList::insertTag(*((_TAGList **)this + 12), (_TAG *)v17);
    v21 = *((_QWORD *)this + 12);
    v22 = *(unsigned __int16 ***)(v21 + 16);
    v23 = *(unsigned __int16 ***)(v21 + 24);
    if (v22 != v23)
    {
      while ((*v22)[20] != 37522)
      {
        if (++v22 == v23)
          goto LABEL_30;
      }
    }
    if (v22 != v23 && *v22)
      _TAGList::removeTag(v21, *v22);
LABEL_30:
    v24 = operator new();
    v25 = *((_BYTE *)this + 32);
    v26 = __dst;
    if (v6 > 4)
      v26 = 0;
    v27 = *((_BYTE *)this + 8) | 0x40;
    *(_QWORD *)v24 = &off_1E1BB2600;
    *(_QWORD *)(v24 + 8) = 0;
    *(_BYTE *)(v24 + 24) = v25;
    *(_DWORD *)(v24 + 28) = 0;
    *(_QWORD *)(v24 + 48) = 0;
    *(_QWORD *)(v24 + 32) = 0;
    *(_BYTE *)(v24 + 80) = v27;
    *(_WORD *)(v24 + 40) = -28014;
    *(_WORD *)(v24 + 56) = 2;
    *(_DWORD *)(v24 + 60) = v6;
    *(_DWORD *)(v24 + 64) = v26;
    *(_QWORD *)(v24 + 72) = v2;
    *(_BYTE *)(v24 + 81) = 0;
    *(_DWORD *)(v24 + 68) = v6;
    *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 12), (_TAG *)v24).n128_u64[0];
  }
  return result;
}

double _APP1::updateOrientation(_APP1 *this, unsigned int a2)
{
  uint64_t v2;
  _QWORD *v4;
  _QWORD *v5;
  double result;
  unsigned int v7;
  uint64_t v8;
  char v9;
  unsigned int v10;
  char v11;

  v2 = *((_QWORD *)this + 10);
  if (v2)
  {
    v4 = *(_QWORD **)(v2 + 16);
    v5 = *(_QWORD **)(v2 + 24);
    if (v4 != v5)
    {
      while (*(_WORD *)(*v4 + 40) != 274)
      {
        if (++v4 == v5)
          goto LABEL_9;
      }
    }
    if (v4 == v5 || !*v4)
    {
LABEL_9:
      if ((unsigned __int16)(a2 - 9) < 0xFFF8u)
        v7 = 1;
      else
        v7 = a2;
      v8 = operator new();
      v9 = *((_BYTE *)this + 32);
      v10 = __rev16(v7);
      v11 = *((_BYTE *)this + 8);
      if (v9)
        v10 = v7;
      *(_QWORD *)v8 = &off_1E1BB2600;
      *(_QWORD *)(v8 + 8) = 0;
      *(_BYTE *)(v8 + 24) = v9;
      *(_DWORD *)(v8 + 28) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 32) = 0;
      *(_BYTE *)(v8 + 80) = v11 | 0x40;
      *(_WORD *)(v8 + 40) = 274;
      *(_WORD *)(v8 + 56) = 3;
      *(_DWORD *)(v8 + 60) = 1;
      *(_DWORD *)(v8 + 64) = v10;
      *(_QWORD *)(v8 + 72) = 0;
      *(_BYTE *)(v8 + 81) = 0;
      *(_DWORD *)(v8 + 68) = 2;
      *(_QWORD *)&result = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), (_TAG *)v8).n128_u64[0];
    }
    else
    {
      (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 72))(*v4);
    }
  }
  return result;
}

void _APP1::updateTagWithString(_APP1 *this, int a2, CFTypeRef cf)
{
  __int16 v4;
  uint64_t v6;
  unsigned __int16 **v7;
  unsigned __int16 **v8;
  unsigned __int16 *v9;
  CFTypeID v10;
  char *UTF8String;
  unsigned int v12;
  uint64_t v13;
  char v14;
  int v15;
  __n128 inserted;
  char __dst[24];

  v4 = a2;
  v6 = *((_QWORD *)this + 10);
  v7 = *(unsigned __int16 ***)(v6 + 16);
  v8 = *(unsigned __int16 ***)(v6 + 24);
  if (v7 != v8)
  {
    while ((*v7)[20] != a2)
    {
      if (++v7 == v8)
        return;
    }
  }
  if (v7 != v8)
  {
    if (cf)
    {
      v9 = *v7;
      if (*v7)
      {
        v10 = CFGetTypeID(cf);
        if (v10 == CFStringGetTypeID())
        {
          IIOString::IIOString((IIOString *)__dst, cf);
          UTF8String = (char *)IIOString::createUTF8String((IIOString *)__dst);
          IIOString::~IIOString((IIOString *)__dst);
          if (UTF8String)
          {
            _TAGList::removeTag(*((_QWORD *)this + 10), v9);
            v12 = strlen(UTF8String) + 1;
            if (v12 < 5)
            {
              *(_DWORD *)__dst = 0;
              strlcpy(__dst, UTF8String, 4uLL);
              v13 = operator new();
              v14 = *((_BYTE *)this + 32);
              v15 = *(_DWORD *)__dst;
              *(_QWORD *)v13 = &off_1E1BB2600;
              *(_QWORD *)(v13 + 8) = 0;
              *(_BYTE *)(v13 + 24) = v14;
              *(_DWORD *)(v13 + 28) = 0;
              *(_QWORD *)(v13 + 48) = 0;
              *(_QWORD *)(v13 + 32) = 0;
              *(_WORD *)(v13 + 80) = 32;
              *(_WORD *)(v13 + 40) = v4;
              *(_WORD *)(v13 + 56) = 2;
              *(_DWORD *)(v13 + 60) = v12;
              *(_DWORD *)(v13 + 64) = v15;
              *(_QWORD *)(v13 + 72) = 0;
              *(_DWORD *)(v13 + 68) = v12;
            }
            else
            {
              v13 = operator new();
              _TAG::_TAG((_TAG *)v13, *((_BYTE *)this + 32), v4, 2, v12, (unsigned __int8 *)UTF8String, v12, 0, 32, 1);
            }
            inserted = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), (_TAG *)v13);
            (*(void (**)(uint64_t, __n128))(*(_QWORD *)v13 + 8))(v13, inserted);
            free(UTF8String);
          }
        }
      }
    }
  }
}

void sub_188026D64(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

void _APP1::mergeWithIPTCProps(_APP1 *this, IIODictionary *a2)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v5;
  const __CFDictionary *v6;

  if (*((_QWORD *)this + 10))
  {
    ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("Caption/Abstract"));
    if (ObjectForKey)
      _APP1::updateTagWithString(this, 270, ObjectForKey);
    v5 = IIODictionary::getObjectForKey(a2, CFSTR("Byline"));
    if (v5)
      _APP1::updateTagWithString(this, 315, v5);
    v6 = IIODictionary::getObjectForKey(a2, CFSTR("CopyrightNotice"));
    if (v6)
      _APP1::updateTagWithString(this, 33432, v6);
  }
}

void _APP1Exif::_APP1Exif (_APP1Exif *this, unsigned __int8 *a2, size_t a3)
{
  void *v6;

  *(_WORD *)((char *)this + 73) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_BYTE *)this + 8) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 0;
  *(_QWORD *)this = &off_1E1BB2FF0;
  *((_BYTE *)this + 148) = 1;
  *((_QWORD *)this + 7) = 236060641;
  *((_QWORD *)this + 8) = 0x100000000;
  if (a3)
  {
    v6 = (void *)operator new[]();
    *((_QWORD *)this + 19) = v6;
    memcpy(v6, a2, a3);
    *((_QWORD *)this + 20) = a3;
    *((_DWORD *)this + 15) = a3 + 4;
  }
  else
  {
    *((_QWORD *)this + 19) = 0;
    *((_QWORD *)this + 20) = 0;
  }
}

void sub_188026EFC(_Unwind_Exception *a1)
{
  _APP1 *v1;

  _APP1::~_APP1(v1);
  _Unwind_Resume(a1);
}

uint64_t _APP1Exif::markerLength(_APP1Exif *this)
{
  return *((unsigned int *)this + 15);
}

CFIndex _APP1Exif::writeToStream(CFIndex this, CFWriteStreamRef stream)
{
  CFIndex v2;
  uint64_t v3;
  __int16 v5;
  UInt8 buffer[4];

  if (*(_BYTE *)(this + 148))
  {
    v2 = this;
    if (*(_QWORD *)(this + 152))
    {
      v3 = *(_QWORD *)(this + 160);
      if (v3)
      {
        *(_WORD *)buffer = -7681;
        v5 = v3 + 2;
        buffer[2] = HIBYTE(v5);
        buffer[3] = v5;
        CFWriteStreamWrite(stream, buffer, 4);
        return CFWriteStreamWrite(stream, *(const UInt8 **)(v2 + 152), *(_QWORD *)(v2 + 160));
      }
    }
  }
  return this;
}

void _APP1Exif::~_APP1Exif (_APP1Exif *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BB2FF0;
  v2 = *((_QWORD *)this + 19);
  if (v2)
  {
    MEMORY[0x18D761C30](v2, 0x1000C4077774924);
    *((_QWORD *)this + 19) = 0;
  }
  _APP1::~_APP1(this);
}

{
  _APP1Exif::~_APP1Exif (this);
  JUMPOUT(0x18D761C30);
}

void _APP13::_APP13(_APP13 *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6, char a7)
{
  uint64_t v8;

  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(_QWORD *)v8 = &off_1E1BB2910;
  *(_QWORD *)(v8 + 152) = 0;
  *(_QWORD *)(v8 + 80) = 0;
  *(_QWORD *)(v8 + 88) = 0;
  *(_BYTE *)(v8 + 96) = 0;
  *(_QWORD *)(v8 + 104) = 0;
  *(_QWORD *)(v8 + 112) = 0;
  *(_QWORD *)(v8 + 120) = a6;
  *(_WORD *)(v8 + 144) = 0;
}

void _APP13::_APP13(_APP13 *this, CFTypeRef cf)
{
  const __CFData *v3;
  int Length;

  *(_WORD *)((char *)this + 73) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 248578029;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = &off_1E1BB2910;
  v3 = (const __CFData *)CFRetain(cf);
  *((_QWORD *)this + 10) = v3;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 19) = 0;
  Length = CFDataGetLength(v3);
  *((_DWORD *)this + 15) = Length + (Length & 1) + 28;
  *((_BYTE *)this + 96) = 1;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = Length + (Length & 1u) + 28;
  *((_WORD *)this + 72) = 257;
}

void sub_1880270DC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E1BB2860;
  _Unwind_Resume(a1);
}

void _APP13::_APP13(_APP13 *this, unsigned __int8 *a2, unsigned int a3)
{
  *(_WORD *)((char *)this + 73) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *(_QWORD *)this = &off_1E1BB2910;
  *((_DWORD *)this + 19) = 0;
  *((_BYTE *)this + 8) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = a2;
  *((_DWORD *)this + 14) = 248578029;
  *((_DWORD *)this + 15) = a3;
  *((_BYTE *)this + 96) = 1;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = a3;
  *((_WORD *)this + 72) = 257;
}

void _APP13::~_APP13(_APP13 *this)
{
  const void *v2;
  void *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E1BB2910;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 10) = 0;
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
    free(v3);
  *((_QWORD *)this + 11) = 0;
  v4 = *((_QWORD *)this + 19);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  *((_QWORD *)this + 19) = 0;
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  _APP13::~_APP13(this);
  JUMPOUT(0x18D761C30);
}

void _APP13::processData(_APP13 *this)
{
  unsigned __int8 *v1;
  unint64_t v3;
  BOOL v5;
  _BOOL4 v6;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  unsigned int v13;
  IIODictionary *v14;

  v1 = (unsigned __int8 *)(*((_QWORD *)this + 5) + *((_QWORD *)this + 2));
  if (*v1 == 255)
  {
    v3 = *((unsigned int *)this + 15);
    if (v1[1] == 237 && v3 >= 0xF)
    {
      v5 = *(_QWORD *)(v1 + 4) == 0x6F68736F746F6850 && *((_WORD *)v1 + 6) == 8304;
      v6 = !v5;
      if (!v6 && v3 >= 0x1F)
      {
        v8 = 18;
        do
        {
          if (v1[v8] != 56)
            break;
          if (v1[v8 + 1] != 66)
            break;
          if (v1[v8 + 2] != 73)
            break;
          v9 = &v1[v8];
          if (v1[v8 + 3] != 77)
            break;
          v10 = ((v1[v8 + 6] + 2) & 0x1FE) + v8 + 6;
          if (v10 + 12 >= v3)
            break;
          v11 = *(_DWORD *)&v1[v10];
          v8 = v10 + 4;
          if (v11)
          {
            v12 = bswap32(v11);
            if (v3 - v8 < v12)
              return;
            v13 = __rev16(*((unsigned __int16 *)v9 + 2));
            if (v13 == 1061)
            {
              *((_QWORD *)this + 16) = v8;
              *((_QWORD *)this + 17) = v12;
            }
            else if (v13 == 1028)
            {
              v14 = (IIODictionary *)*((_QWORD *)this + 19);
              if (!v14)
              {
                v14 = (IIODictionary *)operator new();
                IIODictionary::IIODictionary(v14);
                *((_QWORD *)this + 19) = v14;
              }
              ReadIPTCProps(v14, &v1[v8], v12);
              *((_QWORD *)this + 13) = v8;
              *((_QWORD *)this + 14) = (v12 & 1) + v12;
              *((_BYTE *)this + 96) = 1;
            }
            v8 += ((_DWORD)v12 + 1) & 0xFFFFFFFE;
          }
        }
        while (v8 + 12 < v3);
      }
    }
  }
}

void sub_188027384(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

CFTypeRef _APP13::setIPTCData(CFTypeRef this, CFDataRef theData)
{
  CFTypeRef v2;
  int Length;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;

  v2 = this;
  *((_QWORD *)this + 10) = theData;
  *((_BYTE *)this + 145) = 1;
  if (theData)
  {
    Length = CFDataGetLength(theData);
    v4 = (Length & 1) + Length;
    v5 = *((_QWORD *)v2 + 14);
    v6 = v4 + 12;
    v7 = v4 - v5;
    if (!v5)
      v7 = v6;
    *((_DWORD *)v2 + 15) += v7;
    return CFRetain(*((CFTypeRef *)v2 + 10));
  }
  else
  {
    v8 = *((_QWORD *)this + 14);
    if (v8)
      *((_DWORD *)this + 15) = *((_DWORD *)this + 30) - v8;
  }
  return this;
}

const __CFData *_APP13::writeToStream(_APP13 *this, CFWriteStreamRef stream)
{
  const UInt8 *v4;
  const __CFData *result;
  const UInt8 *v6;
  CFIndex v7;
  int v8;
  _WORD *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  int64_t v13;
  size_t v14;
  uint64_t v15;
  size_t v16;
  const UInt8 *v17;
  int v18;
  int v19;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFIndex v22;
  CFIndex v23;
  __int16 v24;
  UInt8 *v25;
  int v26;
  size_t v27;
  int v28;
  UInt8 v29;
  UInt8 v30[4];
  UInt8 v31[16];
  _BYTE buffer[30];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = (const UInt8 *)(*((_QWORD *)this + 5) + *((_QWORD *)this + 2));
  *(_OWORD *)buffer = xmmword_18822BA86;
  *(_OWORD *)&buffer[14] = *(__int128 *)((char *)&xmmword_18822BA86 + 14);
  result = (const __CFData *)*((_QWORD *)this + 10);
  if (result)
  {
    if (!*((_QWORD *)this + 13))
    {
      v19 = *((unsigned __int8 *)this + 144);
      BytePtr = CFDataGetBytePtr(result);
      Length = CFDataGetLength(*((CFDataRef *)this + 10));
      v22 = Length;
      v23 = Length & 1;
      v24 = (Length & 1) + Length;
      if (!v19)
      {
        v28 = *((_DWORD *)this + 15) - 2;
        *(_WORD *)v30 = -4609;
        v30[2] = BYTE1(v28);
        v30[3] = v28;
        CFWriteStreamWrite(stream, v30, 4);
        CFWriteStreamWrite(stream, v4 + 4, *((_QWORD *)this + 15) - 4);
        *(_WORD *)&v31[8] = 0;
        *(_QWORD *)v31 = 0x4044D494238;
        v31[10] = HIBYTE(v24);
        v31[11] = v24;
        CFWriteStreamWrite(stream, v31, 12);
        result = (const __CFData *)CFWriteStreamWrite(stream, BytePtr, v22);
        if (!v23)
          return result;
        v29 = 0;
        v25 = &v29;
        return (const __CFData *)CFWriteStreamWrite(stream, v25, 1);
      }
      buffer[2] = (unsigned __int16)(v24 + 28) >> 8;
      buffer[3] = v24 + 28;
      buffer[28] = (unsigned __int16)((Length & 1) + Length) >> 8;
      buffer[29] = (Length & 1) + Length;
      CFWriteStreamWrite(stream, buffer, 30);
      result = (const __CFData *)CFWriteStreamWrite(stream, BytePtr, v22);
      if (!v23)
        return result;
LABEL_19:
      v31[0] = 0;
      v25 = v31;
      return (const __CFData *)CFWriteStreamWrite(stream, v25, 1);
    }
    if (*((_QWORD *)this + 14) >= 3uLL)
    {
      v6 = CFDataGetBytePtr(result);
      v7 = CFDataGetLength(*((CFDataRef *)this + 10));
      v8 = *((_DWORD *)this + 15);
      v9 = (_WORD *)operator new[]();
      v10 = *((_QWORD *)this + 13);
      memcpy(v9, v4, v10);
      v9[1] = bswap32(v8 - 2) >> 16;
      memcpy((char *)v9 + v10, v6, v7);
      *(_WORD *)((char *)v9 + v10 - 2) = bswap32(v7) >> 16;
      v11 = v7;
      v12 = *((_QWORD *)this + 14);
      v13 = *((_QWORD *)this + 15) - (v12 + v10);
      if (v13 >= 1)
        memcpy((char *)v9 + v10 + v11, &v4[v12 + v10], v13);
      if (*((_BYTE *)this + 145))
      {
        v14 = *((_QWORD *)this + 16);
        if (v14)
        {
          if (*((_QWORD *)this + 17) == 16)
          {
            v15 = v11 - v12;
            if (v14 <= v10)
              v15 = 0;
            v16 = v15 + v14;
            memset(v31, 0, sizeof(v31));
            CreateMD5FromIIMBlock((char *)v9 + v10, v11, v31);
            *(_OWORD *)((char *)v9 + v16) = *(_OWORD *)v31;
          }
        }
      }
      goto LABEL_23;
    }
LABEL_13:
    if (!*((_BYTE *)this + 144))
      return result;
    v17 = (const UInt8 *)*((_QWORD *)this + 11);
    if (!v17)
      return result;
    v18 = *((_DWORD *)this + 15);
    *(_WORD *)&buffer[2] = bswap32(v18 + (v18 & 1) + 2) >> 16;
    CFWriteStreamWrite(stream, buffer, 4);
    result = (const __CFData *)CFWriteStreamWrite(stream, v17, *((unsigned int *)this + 15));
    if ((v18 & 1) == 0)
      return result;
    goto LABEL_19;
  }
  if (*((_QWORD *)this + 11))
    goto LABEL_13;
  if (!*((_BYTE *)this + 145))
    return (const __CFData *)CFWriteStreamWrite(stream, v4, *((unsigned int *)this + 15));
  if (*((_QWORD *)this + 13) >= 5uLL)
  {
    v26 = *((_DWORD *)this + 15);
    v9 = (_WORD *)operator new[]();
    v27 = *((_QWORD *)this + 13);
    memcpy(v9, v4, v27);
    v9[1] = bswap32(v26 - 2) >> 16;
    *(_DWORD *)((char *)v9 + v27 - 4) = 0;
    memcpy((char *)v9 + v27, &v4[v27 + *((_QWORD *)this + 14)], *((_QWORD *)this + 15) - (v27 + *((_QWORD *)this + 14)));
LABEL_23:
    CFWriteStreamWrite(stream, (const UInt8 *)v9, *((unsigned int *)this + 15));
    return (const __CFData *)MEMORY[0x18D761C18](v9, 0x1000C8077774924);
  }
  return result;
}

void _APP1XMP::_APP1XMP(_APP1XMP *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  uint64_t v7;

  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(_QWORD *)v7 = &off_1E1BB2CD8;
  *(_WORD *)(v7 + 68) = 256;
  *(_BYTE *)(v7 + 70) = 0;
  *(_WORD *)(v7 + 58) |= 2u;
  *(_QWORD *)(v7 + 80) = 0;
  *(_QWORD *)(v7 + 88) = 0;
  *(_BYTE *)(v7 + 96) = 0;
}

void _APP1XMP::_APP1XMP(_APP1XMP *this, const __CFData *a2)
{
  *(_WORD *)((char *)this + 73) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = &off_1E1BB2CD8;
  *((_BYTE *)this + 96) = 1;
  *((_QWORD *)this + 7) = 236126177;
  *((_QWORD *)this + 8) = 0x10000000000;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  _APP1XMP::setXMPData(this, a2);
}

void sub_1880278A4(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E1BB2860;
  _Unwind_Resume(a1);
}

_QWORD *_APP1XMP::setXMPData(_QWORD *this, CFDataRef theData)
{
  _QWORD *v3;

  if (theData)
  {
    v3 = this;
    *((_DWORD *)this + 15) = CFDataGetLength(theData) + 33;
    v3[10] = theData;
    this = CFRetain(theData);
    *((_BYTE *)v3 + 96) = 1;
  }
  return this;
}

CFDataRef _APP1XMP::processData(CFDataRef this)
{
  unsigned int v1;
  CFDataRef v2;
  unsigned __int8 *v3;
  uint64_t v7;
  const UInt8 *v8;

  v1 = *((_DWORD *)this + 15);
  if (v1 >= 4)
  {
    v2 = this;
    v3 = (unsigned __int8 *)(*((_QWORD *)this + 5) + *((_QWORD *)this + 2));
    if (__PAIR64__(v3[1], *v3) == 0xE1000000FFLL
      && v1 >= 0x21
      && *(_QWORD *)(v3 + 4) == 0x6E2F2F3A70747468
      && *(_QWORD *)(v3 + 12) == 0x2E65626F64612E73
      && *(_QWORD *)(v3 + 20) == 0x2F7061782F6D6F63
      && *(_QWORD *)(v3 + 25) == 0x2F302E312F7061)
    {
      v7 = __rev16(*((unsigned __int16 *)v3 + 1)) - 31;
      v8 = v3 + 33;
      *((_QWORD *)this + 11) = CreateMetadataFromXMPBuffer((const char *)v3 + 33, v7);
      this = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8, v7);
      *((_QWORD *)v2 + 10) = this;
    }
  }
  return this;
}

void _APP1XMP::~_APP1XMP(_APP1XMP *this)
{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E1BB2CD8;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 10) = 0;
  v3 = (const void *)*((_QWORD *)this + 11);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 11) = 0;
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  _APP1XMP::~_APP1XMP(this);
  JUMPOUT(0x18D761C30);
}

CFIndex _APP1XMP::writeToStream(CFDataRef *this, __CFWriteStream *a2)
{
  const __CFData *v4;
  const UInt8 *BytePtr;
  CFIndex Length;
  __int128 v8;
  char v9[24];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 96) && (v4 = this[10]) != 0)
  {
    v8 = xmmword_18822BAA4;
    strcpy(v9, "obe.com/xap/1.0/");
    BytePtr = CFDataGetBytePtr(v4);
    Length = CFDataGetLength(this[10]);
    WORD1(v8) = bswap32(Length + 31) >> 16;
    CFWriteStreamWrite(a2, (const UInt8 *)&v8, 33);
  }
  else
  {
    BytePtr = (const UInt8 *)this[2] + (_QWORD)this[5];
    Length = *((unsigned int *)this + 15);
  }
  return CFWriteStreamWrite(a2, BytePtr, Length);
}

void _APP1ExtendedXMP::_APP1ExtendedXMP(_APP1ExtendedXMP *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  uint64_t v7;

  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(_QWORD *)v7 = &off_1E1BB0EB8;
  *(_WORD *)(v7 + 68) = 0;
  *(_BYTE *)(v7 + 70) = 1;
  *(_WORD *)(v7 + 58) |= 3u;
  *(_BYTE *)(v7 + 112) = 0;
  *(_QWORD *)(v7 + 80) = 0;
  *(_QWORD *)(v7 + 88) = 0;
}

void _APP1ExtendedXMP::_APP1ExtendedXMP(_APP1ExtendedXMP *this, CFDataRef theData, int a3, int a4, CFTypeRef cf)
{
  *(_WORD *)((char *)this + 73) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = &off_1E1BB0EB8;
  *((_BYTE *)this + 112) = 1;
  *((_QWORD *)this + 7) = 236191713;
  *((_QWORD *)this + 8) = 0x1000000000000;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = cf;
  if (cf)
    CFRetain(cf);
  *((_DWORD *)this + 26) = a3;
  *((_DWORD *)this + 27) = a4;
  _APP1ExtendedXMP::setXMPData(this, theData);
}

void sub_188027C2C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E1BB2860;
  _Unwind_Resume(a1);
}

_QWORD *_APP1ExtendedXMP::setXMPData(_QWORD *this, CFDataRef theData)
{
  _QWORD *v3;

  if (theData)
  {
    v3 = this;
    *((_DWORD *)this + 15) = CFDataGetLength(theData) + 79;
    v3[10] = theData;
    this = CFRetain(theData);
    *((_BYTE *)v3 + 112) = 1;
  }
  return this;
}

CFDataRef _APP1ExtendedXMP::processData(CFDataRef this)
{
  unsigned int v1;
  CFDataRef v2;
  unsigned __int8 *v3;
  const __CFAllocator *v4;
  unsigned int v5;

  v1 = *((_DWORD *)this + 15);
  if (v1 >= 4)
  {
    v2 = this;
    v3 = (unsigned __int8 *)(*((_QWORD *)this + 5) + *((_QWORD *)this + 2));
    if (*v3 == 255 && v1 >= 0x27 && v3[1] == 225)
    {
      this = (CFDataRef)strcmp((const char *)v3 + 4, "http://ns.adobe.com/xmp/extension/");
      if (v1 >= 0x47 && !(_DWORD)this)
      {
        v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        this = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v3 + 39, 32);
        *((_QWORD *)v2 + 12) = this;
        v5 = *((_DWORD *)v2 + 15);
        if (v5 >= 0x4F)
        {
          *((_DWORD *)v2 + 27) = bswap32(*(_DWORD *)(v3 + 71));
          *((_DWORD *)v2 + 26) = bswap32(*(_DWORD *)(v3 + 75));
          this = CFDataCreate(v4, v3 + 79, v5 - 79);
          *((_QWORD *)v2 + 10) = this;
        }
      }
    }
  }
  return this;
}

void _APP1ExtendedXMP::~_APP1ExtendedXMP(_APP1ExtendedXMP *this)
{
  const void *v2;
  const void *v3;
  const void *v4;

  *(_QWORD *)this = &off_1E1BB0EB8;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 10) = 0;
  v3 = (const void *)*((_QWORD *)this + 11);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 11) = 0;
  v4 = (const void *)*((_QWORD *)this + 12);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 12) = 0;
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  _APP1ExtendedXMP::~_APP1ExtendedXMP(this);
  JUMPOUT(0x18D761C30);
}

CFIndex _APP1ExtendedXMP::writeToStream(_APP1ExtendedXMP *this, __CFWriteStream *a2)
{
  const __CFData *v4;
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v7;
  __int128 v8;
  __int128 v10;
  _BYTE v11[55];
  int32x2_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 112) && (v4 = (const __CFData *)*((_QWORD *)this + 10)) != 0)
  {
    v10 = xmmword_18822BAE9;
    strcpy(v11, "obe.com/xmp/extension/");
    BytePtr = CFDataGetBytePtr(v4);
    Length = CFDataGetLength(*((CFDataRef *)this + 10));
    WORD1(v10) = bswap32(Length + 77) >> 16;
    v7 = CFDataGetBytePtr(*((CFDataRef *)this + 12));
    v8 = *((_OWORD *)v7 + 1);
    *(_OWORD *)&v11[23] = *(_OWORD *)v7;
    *(_OWORD *)&v11[39] = v8;
    v12 = vrev64_s32((int32x2_t)vrev32_s8(*(int8x8_t *)((char *)this + 104)));
    CFWriteStreamWrite(a2, (const UInt8 *)&v10, 79);
  }
  else
  {
    BytePtr = (const UInt8 *)(*((_QWORD *)this + 5) + *((_QWORD *)this + 2));
    Length = *((unsigned int *)this + 15);
  }
  return CFWriteStreamWrite(a2, BytePtr, Length);
}

uint64_t _APP1ExtendedXMP::getXmpOffset(_APP1ExtendedXMP *this)
{
  return *((unsigned int *)this + 26);
}

uint64_t _APP1ExtendedXMP::getTotalXMPLength(_APP1ExtendedXMP *this)
{
  return *((unsigned int *)this + 27);
}

uint64_t _APP1ExtendedXMP::getGUID(_APP1ExtendedXMP *this)
{
  return *((_QWORD *)this + 12);
}

void _APP2ICC::_APP2ICC(_APP2ICC *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  uint64_t v7;

  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(_QWORD *)v7 = &off_1E1BB2D68;
  *(_BYTE *)(v7 + 90) = 0;
  *(_QWORD *)(v7 + 80) = 0;
  *(_BYTE *)(v7 + 71) = 1;
  *(_WORD *)(v7 + 88) = 0;
}

void _APP2ICC::_APP2ICC(_APP2ICC *this, CFDataRef theData, char a3, char a4)
{
  int Length;

  *(_WORD *)((char *)this + 73) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 32) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 237043682;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 19) = 0;
  *((_BYTE *)this + 8) = 0;
  *(_QWORD *)this = &off_1E1BB2D68;
  Length = CFDataGetLength(theData);
  *((_QWORD *)this + 10) = CFRetain(theData);
  *((_BYTE *)this + 71) = 1;
  *((_BYTE *)this + 88) = a3;
  *((_BYTE *)this + 89) = a4;
  *((_DWORD *)this + 15) = Length + 18;
  *((_BYTE *)this + 90) = 1;
}

void sub_188027FDC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = &off_1E1BB2860;
  _Unwind_Resume(a1);
}

void _APP2ICC::~_APP2ICC(_APP2ICC *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E1BB2D68;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)this = &off_1E1BB2860;
}

{
  _APP2ICC::~_APP2ICC(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _APP2ICC::writeToStream(uint64_t this, CFWriteStreamRef stream)
{
  uint64_t v3;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v6;
  __int128 v7;
  __int16 v8;
  uint64_t v9;

  v3 = this;
  v9 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(this + 90) && *(_QWORD *)(this + 80))
  {
    v7 = xmmword_18822BB38;
    WORD1(v7) = bswap32(*(unsigned __int16 *)(this + 60) - 2) >> 16;
    v8 = *(_WORD *)(this + 88);
    CFWriteStreamWrite(stream, (const UInt8 *)&v7, 18);
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v3 + 80));
    Length = CFDataGetLength(*(CFDataRef *)(v3 + 80));
    return CFWriteStreamWrite(stream, BytePtr, Length);
  }
  else
  {
    v6 = *(_QWORD *)(this + 40);
    if (v6)
      return CFWriteStreamWrite(stream, (const UInt8 *)(v6 + *(_QWORD *)(this + 16)), *(unsigned int *)(this + 60));
  }
  return this;
}

uint64_t _TAG::count(_TAG *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t _TAG::tagType(_TAG *this)
{
  return *((unsigned __int16 *)this + 28);
}

uint64_t _TAG::dataOrOffset(_TAG *this)
{
  return *((unsigned int *)this + 16);
}

uint64_t _APPx::mainIFD(_APPx *this)
{
  return 0;
}

uint64_t _APPx::thumbIFD(_APPx *this)
{
  return 0;
}

uint64_t _APP0::setWriteExtendedAPP0(uint64_t this)
{
  *(_BYTE *)(this + 80) = 1;
  return this;
}

uint64_t _APP1::mainIFD(_APP1 *this)
{
  return *((_QWORD *)this + 10);
}

uint64_t _APP1::thumbIFD(_APP1 *this)
{
  return *((_QWORD *)this + 11);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,false>(uint64_t result, _TAG **a2, uint64_t a3, char a4)
{
  _TAG **v5;
  uint64_t v6;
  unint64_t v7;
  _TAG **v8;
  _TAG *v9;
  _TAG *v10;
  _TAG *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t j;
  _TAG *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  BOOL v25;
  _TAG **v26;
  unint64_t v27;
  _TAG **v28;
  _TAG *v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  _TAG *v35;
  _TAG *v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  char v43;
  _TAG *v44;
  _TAG *v45;
  _TAG **v46;
  _TAG **v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  _TAG *v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  BOOL v60;
  _TAG *v61;
  _TAG *v62;
  _TAG *v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  _TAG **i;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  _TAG *v73;
  _TAG *v74;
  unsigned int *v75;
  unsigned int v76;
  _TAG *v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  _TAG *v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  _TAG **v88;
  _TAG *v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  _TAG *v97;
  _TAG *v98;
  unsigned int v99;
  _TAG **v100;
  BOOL v102;
  uint64_t v103;
  _TAG **v104;
  _TAG **v105;
  _TAG *v106;
  _TAG *v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  BOOL v112;
  _TAG **v113;
  uint64_t v114;
  _TAG *v115;
  unsigned int v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  uint64_t v124;
  _TAG **v125;
  _TAG *v126;
  _TAG *v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  unsigned int v132;
  BOOL v133;
  _TAG *v134;
  _TAG *v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  BOOL v140;
  uint64_t v141;
  uint64_t v142;
  _TAG *v143;
  _TAG *v144;
  unsigned int v145;
  unsigned int v146;
  BOOL v147;
  unsigned int v148;
  unsigned int v149;
  unsigned int v150;
  BOOL v151;
  _TAG *v152;
  unsigned int v153;
  unsigned int v154;
  unsigned int v155;
  unsigned int v156;
  uint64_t v157;
  _TAG **v158;
  uint64_t v159;
  _TAG **v160;
  _TAG **v161;
  uint64_t v162;
  uint64_t v163;
  _TAG *v164;
  _TAG *v165;
  unsigned int v166;
  unsigned int v167;
  unsigned int v168;
  unsigned int v169;
  BOOL v170;
  uint64_t v171;
  unint64_t v172;
  unint64_t v173;
  _TAG **v174;
  _TAG *v175;
  _TAG *v176;
  unsigned int v177;
  unsigned int v178;
  unsigned int v179;
  unsigned int v180;
  BOOL v181;
  _TAG **v182;
  unint64_t v183;
  _TAG *v184;
  unsigned int v185;
  unsigned int v186;
  unsigned int v187;
  unsigned int v188;
  unsigned int v189;
  unsigned int v190;
  unsigned int v191;
  BOOL v192;
  _TAG **v193;
  _TAG *v194;
  _TAG *v195;
  unsigned int v196;
  unsigned int v197;
  unsigned int v198;
  unsigned int v199;
  BOOL v200;
  _TAG **v201;
  _TAG *v202;
  unsigned int v203;
  unsigned int v204;
  unsigned int v205;
  unsigned int v206;
  int64_t v209;
  _TAG **v210;
  _TAG **v211;
  _TAG *v212;
  _TAG **v214;

  v5 = (_TAG **)result;
LABEL_2:
  v210 = a2 - 1;
  while (2)
  {
    v6 = (char *)a2 - (char *)v5;
    v7 = a2 - v5;
    switch(v7)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v97 = *(a2 - 1);
        v98 = *v5;
        v99 = _TAG::priority(v97);
        result = _TAG::priority(v98);
        if (v99 > result
          || v99 >= result
          && ((v189 = *((_DWORD *)v97 + 17), v189 <= 4) ? (v190 = 0) : (v190 = (v189 + 1) & 0xFFFFFFFE),
              (v191 = *((_DWORD *)v98 + 17), v191 >= 5) ? (v192 = ((v191 + 1) & 0xFFFFFFFE) > v190) : (v192 = 0),
              v192))
        {
          *v5 = v97;
          *(a2 - 1) = v98;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v5, v5 + 1, v210);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v5, v5 + 1, v5 + 2, v210);
      case 5uLL:
        return std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,0>(v5, v5 + 1, v5 + 2, v5 + 3, v210);
      default:
        if (v6 <= 191)
        {
          v100 = v5 + 1;
          v102 = v5 == a2 || v100 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v102)
            {
              v103 = 0;
              v104 = v5;
              do
              {
                v105 = v104;
                v104 = v100;
                v107 = *v105;
                v106 = v105[1];
                v108 = _TAG::priority(v106);
                result = _TAG::priority(v107);
                if (v108 > result
                  || v108 >= result
                  && ((v109 = *((_DWORD *)v106 + 17), v109 <= 4) ? (v110 = 0) : (v110 = (v109 + 1) & 0xFFFFFFFE),
                      (v111 = *((_DWORD *)v107 + 17), v111 >= 5)
                    ? (v112 = ((v111 + 1) & 0xFFFFFFFE) > v110)
                    : (v112 = 0),
                      v112))
                {
                  v105[1] = v107;
                  v113 = v5;
                  if (v105 != v5)
                  {
                    v114 = v103;
                    do
                    {
                      v115 = *(_TAG **)((char *)v5 + v114 - 8);
                      v116 = _TAG::priority(v106);
                      result = _TAG::priority(v115);
                      if (v116 <= result)
                      {
                        if (v116 < result)
                        {
                          v113 = (_TAG **)((char *)v5 + v114);
                          goto LABEL_203;
                        }
                        v117 = *((_DWORD *)v106 + 17);
                        v118 = v117 <= 4 ? 0 : (v117 + 1) & 0xFFFFFFFE;
                        v119 = *((_DWORD *)v115 + 17);
                        if (v119 < 5 || ((v119 + 1) & 0xFFFFFFFE) <= v118)
                        {
                          v113 = v105;
                          goto LABEL_203;
                        }
                      }
                      --v105;
                      *(_TAG **)((char *)v5 + v114) = v115;
                      v114 -= 8;
                    }
                    while (v114);
                    v113 = v5;
                  }
LABEL_203:
                  *v113 = v106;
                }
                v100 = v104 + 1;
                v103 += 8;
              }
              while (v104 + 1 != a2);
            }
          }
          else if (!v102)
          {
            do
            {
              v193 = v5;
              v5 = v100;
              v195 = *v193;
              v194 = v193[1];
              v196 = _TAG::priority(v194);
              result = _TAG::priority(v195);
              if (v196 > result
                || v196 >= result
                && ((v197 = *((_DWORD *)v194 + 17), v197 <= 4) ? (v198 = 0) : (v198 = (v197 + 1) & 0xFFFFFFFE),
                    (v199 = *((_DWORD *)v195 + 17), v199 >= 5) ? (v200 = ((v199 + 1) & 0xFFFFFFFE) > v198) : (v200 = 0),
                    v200))
              {
                do
                {
                  do
                  {
                    v201 = v193;
                    v202 = *--v193;
                    v193[2] = v195;
                    v195 = v202;
                    v203 = _TAG::priority(v194);
                    result = _TAG::priority(v202);
                  }
                  while (v203 > result);
                  if (v203 < result)
                    break;
                  v204 = *((_DWORD *)v194 + 17);
                  v205 = v204 <= 4 ? 0 : (v204 + 1) & 0xFFFFFFFE;
                  v206 = *((_DWORD *)v195 + 17);
                }
                while (v206 >= 5 && ((v206 + 1) & 0xFFFFFFFE) > v205);
                *v201 = v194;
              }
              v100 = v5 + 1;
            }
            while (v5 + 1 != a2);
          }
          return result;
        }
        v214 = v5;
        if (!a3)
        {
          if (v5 != a2)
          {
            v121 = (v7 - 2) >> 1;
            v122 = v121;
            do
            {
              v123 = v122;
              if (v121 >= v122)
              {
                v124 = (2 * v122) | 1;
                v125 = &v214[v124];
                if (2 * v122 + 2 < (uint64_t)v7)
                {
                  v126 = *v125;
                  v127 = v125[1];
                  v128 = _TAG::priority(*v125);
                  v129 = _TAG::priority(v127);
                  if (v128 > v129
                    || v128 >= v129
                    && ((v130 = *((_DWORD *)v126 + 17), v130 <= 4) ? (v131 = 0) : (v131 = (v130 + 1) & 0xFFFFFFFE),
                        (v132 = *((_DWORD *)v127 + 17), v132 >= 5)
                      ? (v133 = ((v132 + 1) & 0xFFFFFFFE) > v131)
                      : (v133 = 0),
                        v133))
                  {
                    ++v125;
                    v124 = 2 * v123 + 2;
                  }
                }
                v134 = *v125;
                v135 = v214[v123];
                v136 = _TAG::priority(*v125);
                result = _TAG::priority(v135);
                v121 = (v7 - 2) >> 1;
                if (v136 <= result)
                {
                  if (v136 < result
                    || ((v137 = *((_DWORD *)v134 + 17), v137 <= 4) ? (v138 = 0) : (v138 = (v137 + 1) & 0xFFFFFFFE),
                        (v139 = *((_DWORD *)v135 + 17), v139 >= 5)
                      ? (v140 = ((v139 + 1) & 0xFFFFFFFE) > v138)
                      : (v140 = 0),
                        !v140))
                  {
                    v214[v123] = v134;
                    if ((uint64_t)((v7 - 2) >> 1) >= v124)
                    {
                      v209 = v123;
                      while (1)
                      {
                        v211 = v125;
                        v141 = 2 * v124;
                        v124 = (2 * v124) | 1;
                        v125 = &v214[v124];
                        v142 = v141 + 2;
                        if (v141 + 2 < (uint64_t)v7)
                        {
                          v143 = *v125;
                          v144 = v125[1];
                          v145 = _TAG::priority(*v125);
                          v146 = _TAG::priority(v144);
                          v147 = v145 >= v146;
                          v25 = v145 > v146;
                          v121 = (v7 - 2) >> 1;
                          if (v25
                            || v147
                            && ((v148 = *((_DWORD *)v143 + 17), v148 <= 4)
                              ? (v149 = 0)
                              : (v149 = (v148 + 1) & 0xFFFFFFFE),
                                (v150 = *((_DWORD *)v144 + 17), v150 >= 5)
                              ? (v151 = ((v150 + 1) & 0xFFFFFFFE) > v149)
                              : (v151 = 0),
                                v151))
                          {
                            ++v125;
                            v124 = v142;
                          }
                        }
                        v152 = *v125;
                        v153 = _TAG::priority(*v125);
                        result = _TAG::priority(v135);
                        v123 = v209;
                        if (v153 > result)
                          break;
                        if (v153 >= result)
                        {
                          v154 = *((_DWORD *)v152 + 17);
                          v155 = v154 <= 4 ? 0 : (v154 + 1) & 0xFFFFFFFE;
                          v156 = *((_DWORD *)v135 + 17);
                          if (v156 >= 5 && ((v156 + 1) & 0xFFFFFFFE) > v155)
                            break;
                        }
                        *v211 = v152;
                        if (v121 < v124)
                          goto LABEL_254;
                      }
                      v125 = v211;
                    }
LABEL_254:
                    *v125 = v135;
                  }
                }
              }
              v122 = v123 - 1;
            }
            while (v123);
            v157 = (unint64_t)v6 >> 3;
            v158 = v214;
            do
            {
              v159 = 0;
              v212 = *v158;
              v160 = v158;
              do
              {
                v161 = v160;
                v160 += v159 + 1;
                v162 = 2 * v159;
                v159 = (2 * v159) | 1;
                v163 = v162 + 2;
                if (v162 + 2 < v157)
                {
                  v164 = *v160;
                  v165 = v160[1];
                  v166 = _TAG::priority(*v160);
                  result = _TAG::priority(v165);
                  if (v166 > result
                    || v166 >= result
                    && ((v167 = *((_DWORD *)v164 + 17), v167 <= 4) ? (v168 = 0) : (v168 = (v167 + 1) & 0xFFFFFFFE),
                        (v169 = *((_DWORD *)v165 + 17), v169 >= 5)
                      ? (v170 = ((v169 + 1) & 0xFFFFFFFE) > v168)
                      : (v170 = 0),
                        v170))
                  {
                    ++v160;
                    v159 = v163;
                  }
                }
                *v161 = *v160;
              }
              while (v159 <= (uint64_t)((unint64_t)(v157 - 2) >> 1));
              if (v160 == --a2)
              {
                *v160 = v212;
                v158 = v214;
              }
              else
              {
                v158 = v214;
                *v160 = *a2;
                *a2 = v212;
                v171 = (char *)v160 - (char *)v214 + 8;
                if (v171 >= 9)
                {
                  v172 = ((unint64_t)v171 >> 3) - 2;
                  v173 = v172 >> 1;
                  v174 = &v214[v172 >> 1];
                  v175 = *v174;
                  v176 = *v160;
                  v177 = _TAG::priority(*v174);
                  result = _TAG::priority(v176);
                  if (v177 > result
                    || v177 >= result
                    && ((v178 = *((_DWORD *)v175 + 17), v178 <= 4) ? (v179 = 0) : (v179 = (v178 + 1) & 0xFFFFFFFE),
                        (v180 = *((_DWORD *)v176 + 17), v180 >= 5)
                      ? (v181 = ((v180 + 1) & 0xFFFFFFFE) > v179)
                      : (v181 = 0),
                        v181))
                  {
                    *v160 = v175;
                    if (v172 >= 2)
                    {
                      while (1)
                      {
                        v183 = v173 - 1;
                        v173 = (v173 - 1) >> 1;
                        v182 = &v214[v173];
                        v184 = *v182;
                        v185 = _TAG::priority(*v182);
                        result = _TAG::priority(v176);
                        if (v185 <= result)
                        {
                          if (v185 < result)
                            break;
                          v186 = *((_DWORD *)v184 + 17);
                          v187 = v186 <= 4 ? 0 : (v186 + 1) & 0xFFFFFFFE;
                          v188 = *((_DWORD *)v176 + 17);
                          if (v188 < 5 || ((v188 + 1) & 0xFFFFFFFE) <= v187)
                            break;
                        }
                        *v174 = v184;
                        v174 = &v214[v173];
                        if (v183 <= 1)
                          goto LABEL_293;
                      }
                    }
                    v182 = v174;
LABEL_293:
                    *v182 = v176;
                  }
                }
              }
              v25 = v157-- <= 2;
            }
            while (!v25);
          }
          return result;
        }
        v8 = &v5[v7 >> 1];
        if ((unint64_t)v6 < 0x401)
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(&v5[v7 >> 1], v5, v210);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v5, &v5[v7 >> 1], v210);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v5 + 1, v8 - 1, a2 - 2);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v5 + 2, &v5[(v7 >> 1) + 1], a2 - 3);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v8 - 1, &v5[v7 >> 1], &v5[(v7 >> 1) + 1]);
          v9 = *v5;
          *v5 = *v8;
          *v8 = v9;
        }
        --a3;
        v10 = *v5;
        if ((a4 & 1) == 0)
        {
          v11 = *(v5 - 1);
          v12 = _TAG::priority(v11);
          v13 = _TAG::priority(v10);
          if (v12 <= v13)
          {
            v14 = v13;
            if (v12 < v13
              || ((v15 = *((_DWORD *)v11 + 17), v15 <= 4) ? (v16 = 0) : (v16 = (v15 + 1) & 0xFFFFFFFE),
                  (v17 = *((_DWORD *)v10 + 17), v17 < 5) || ((v17 + 1) & 0xFFFFFFFE) <= v16))
            {
              v61 = *v210;
              result = _TAG::priority(*v210);
              if (v14 > result
                || v14 >= result
                && ((v94 = *((_DWORD *)v10 + 17), v94 <= 4) ? (v95 = 0) : (v95 = (v94 + 1) & 0xFFFFFFFE),
                    (v96 = *((_DWORD *)v61 + 17), v96 >= 5) && ((v96 + 1) & 0xFFFFFFFE) > v95))
              {
                while (1)
                {
                  v63 = v5[1];
                  ++v5;
                  v62 = v63;
                  result = _TAG::priority(v63);
                  if (v14 > result)
                    break;
                  if (v14 >= result)
                  {
                    v64 = *((_DWORD *)v10 + 17);
                    v65 = v64 <= 4 ? 0 : (v64 + 1) & 0xFFFFFFFE;
                    v66 = *((_DWORD *)v62 + 17);
                    if (v66 >= 5 && ((v66 + 1) & 0xFFFFFFFE) > v65)
                      break;
                  }
                }
              }
              else
              {
                for (++v5; v5 < a2; ++v5)
                {
                  v89 = *v5;
                  result = _TAG::priority(*v5);
                  if (v14 > result)
                    break;
                  if (v14 >= result)
                  {
                    v90 = *((_DWORD *)v10 + 17);
                    v91 = v90 <= 4 ? 0 : (v90 + 1) & 0xFFFFFFFE;
                    v92 = *((_DWORD *)v89 + 17);
                    if (v92 >= 5 && ((v92 + 1) & 0xFFFFFFFE) > v91)
                      break;
                  }
                }
              }
              i = a2;
              if (v5 < a2)
              {
                for (i = a2 - 1; ; --i)
                {
                  result = _TAG::priority(v61);
                  if (v14 <= result)
                  {
                    if (v14 < result)
                      break;
                    v69 = *((_DWORD *)v10 + 17);
                    v70 = v69 <= 4 ? 0 : (v69 + 1) & 0xFFFFFFFE;
                    v71 = *((_DWORD *)v61 + 17);
                    if (v71 < 5 || ((v71 + 1) & 0xFFFFFFFE) <= v70)
                      break;
                  }
                  v73 = *(i - 1);
                  v61 = v73;
                }
              }
              if (v5 < i)
              {
                v74 = *v5;
                v75 = (unsigned int *)*i;
                do
                {
                  *v5 = (_TAG *)v75;
                  *i = v74;
                  v76 = _TAG::priority(v10);
                  while (1)
                  {
                    v77 = v5[1];
                    ++v5;
                    v74 = v77;
                    v78 = _TAG::priority(v77);
                    if (v76 > v78)
                      break;
                    if (v76 >= v78)
                    {
                      v79 = *((_DWORD *)v10 + 17);
                      v80 = v79 <= 4 ? 0 : (v79 + 1) & 0xFFFFFFFE;
                      v81 = *((_DWORD *)v74 + 17);
                      if (v81 >= 5 && ((v81 + 1) & 0xFFFFFFFE) > v80)
                        break;
                    }
                  }
                  do
                  {
                    do
                    {
                      v83 = *--i;
                      v75 = (unsigned int *)v83;
                      result = _TAG::priority(v83);
                    }
                    while (v76 > result);
                    if (v76 < result)
                      break;
                    v84 = *((_DWORD *)v10 + 17);
                    v85 = v84 <= 4 ? 0 : (v84 + 1) & 0xFFFFFFFE;
                    v86 = v75[17];
                  }
                  while (v86 >= 5 && ((v86 + 1) & 0xFFFFFFFE) > v85);
                }
                while (v5 < i);
              }
              v88 = v5 - 1;
              if (v5 - 1 != v214)
                *v214 = *v88;
              a4 = 0;
              *v88 = v10;
              continue;
            }
          }
        }
        v18 = _TAG::priority(v10);
        for (j = 0; ; ++j)
        {
          v20 = v214[j + 1];
          v21 = _TAG::priority(v20);
          if (v21 <= v18)
          {
            if (v21 < v18)
              break;
            v22 = *((_DWORD *)v20 + 17);
            v23 = v22 <= 4 ? 0 : (v22 + 1) & 0xFFFFFFFE;
            v24 = *((_DWORD *)v10 + 17);
            v25 = v24 >= 5 && ((v24 + 1) & 0xFFFFFFFE) > v23;
            if (!v25)
              break;
          }
        }
        v26 = &v214[j];
        v27 = (unint64_t)&v214[j + 1];
        if (j * 8)
        {
          v28 = a2 - 1;
          v29 = *v210;
          v30 = _TAG::priority(*v210);
          if (v30 <= v18)
          {
            v28 = a2 - 1;
            do
            {
              if (v30 >= v18)
              {
                v31 = *((_DWORD *)v29 + 17);
                v32 = v31 <= 4 ? 0 : (v31 + 1) & 0xFFFFFFFE;
                v33 = *((_DWORD *)v10 + 17);
                if (v33 >= 5 && ((v33 + 1) & 0xFFFFFFFE) > v32)
                  break;
              }
              v35 = *--v28;
              v29 = v35;
              v30 = _TAG::priority(v35);
            }
            while (v30 <= v18);
          }
        }
        else
        {
          v28 = a2;
          if (v27 < (unint64_t)a2)
          {
            v28 = a2 - 1;
            v36 = *v210;
            v37 = _TAG::priority(*v210);
            if (v37 <= v18)
            {
              v28 = a2 - 1;
              do
              {
                if (v37 >= v18)
                {
                  v38 = *((_DWORD *)v36 + 17);
                  if (v38 <= 4)
                    v39 = 0;
                  else
                    v39 = (v38 + 1) & 0xFFFFFFFE;
                  v40 = *((_DWORD *)v10 + 17);
                  v147 = v40 >= 5;
                  v41 = (v40 + 1) & 0xFFFFFFFE;
                  v43 = !v147 || v41 <= v39;
                  if (v27 >= (unint64_t)v28 || (v43 & 1) == 0)
                    break;
                }
                else if (v27 >= (unint64_t)v28)
                {
                  break;
                }
                v44 = *--v28;
                v36 = v44;
                v37 = _TAG::priority(v44);
              }
              while (v37 <= v18);
            }
          }
        }
        if (v27 < (unint64_t)v28)
        {
          v45 = *v28;
          v46 = v28;
          v47 = &v214[j + 1];
          do
          {
            *v47++ = v45;
            *v46 = v20;
            v48 = _TAG::priority(v10);
            while (1)
            {
              v20 = *v47;
              v49 = _TAG::priority(*v47);
              if (v49 <= v48)
              {
                if (v49 < v48)
                  break;
                v50 = *((_DWORD *)v20 + 17);
                v51 = v50 <= 4 ? 0 : (v50 + 1) & 0xFFFFFFFE;
                v52 = *((_DWORD *)v10 + 17);
                if (v52 < 5 || ((v52 + 1) & 0xFFFFFFFE) <= v51)
                  break;
              }
              ++v47;
            }
            while (1)
            {
              v54 = *--v46;
              v45 = v54;
              v55 = _TAG::priority(v54);
              if (v55 > v48)
                break;
              if (v55 >= v48)
              {
                v56 = *((_DWORD *)v45 + 17);
                v57 = v56 <= 4 ? 0 : (v56 + 1) & 0xFFFFFFFE;
                v58 = *((_DWORD *)v10 + 17);
                if (v58 >= 5 && ((v58 + 1) & 0xFFFFFFFE) > v57)
                  break;
              }
            }
          }
          while (v47 < v46);
          v26 = v47 - 1;
        }
        if (v26 != v214)
          *v214 = *v26;
        *v26 = v10;
        if (v27 < (unint64_t)v28)
        {
LABEL_91:
          result = std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,false>(v214, v26, a3, a4 & 1);
          a4 = 0;
          v5 = v26 + 1;
          continue;
        }
        v60 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v214, v26);
        v5 = v26 + 1;
        result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v26 + 1, a2);
        if (!(_DWORD)result)
        {
          if (v60)
            continue;
          goto LABEL_91;
        }
        a2 = v26;
        v5 = v214;
        if (!v60)
          goto LABEL_2;
        return result;
    }
  }
}

uint64_t std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,0>(_TAG **a1, _TAG **a2, _TAG **a3, _TAG **a4, _TAG **a5)
{
  _TAG *v10;
  _TAG *v11;
  unsigned int v12;
  uint64_t result;
  _TAG *v14;
  _TAG *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  BOOL v20;
  _TAG *v21;
  _TAG *v22;
  unsigned int v23;
  _TAG *v24;
  _TAG *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  BOOL v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a2, a3, a4);
  v10 = *a5;
  v11 = *a4;
  v12 = _TAG::priority(*a5);
  result = _TAG::priority(v11);
  if (v12 > result
    || v12 >= result
    && ((v27 = *((_DWORD *)v10 + 17), v27 <= 4) ? (v28 = 0) : (v28 = (v27 + 1) & 0xFFFFFFFE),
        (v29 = *((_DWORD *)v11 + 17), v29 >= 5) ? (v30 = ((v29 + 1) & 0xFFFFFFFE) > v28) : (v30 = 0),
        v30))
  {
    *a4 = v10;
    *a5 = v11;
    v14 = *a4;
    v15 = *a3;
    v16 = _TAG::priority(*a4);
    result = _TAG::priority(v15);
    if (v16 > result
      || v16 >= result
      && ((v17 = *((_DWORD *)v14 + 17), v17 <= 4) ? (v18 = 0) : (v18 = (v17 + 1) & 0xFFFFFFFE),
          (v19 = *((_DWORD *)v15 + 17), v19 >= 5) ? (v20 = ((v19 + 1) & 0xFFFFFFFE) > v18) : (v20 = 0),
          v20))
    {
      *a3 = v14;
      *a4 = v15;
      v21 = *a3;
      v22 = *a2;
      v23 = _TAG::priority(*a3);
      result = _TAG::priority(v22);
      if (v23 > result
        || v23 >= result
        && ((v31 = *((_DWORD *)v21 + 17), v31 <= 4) ? (v32 = 0) : (v32 = (v31 + 1) & 0xFFFFFFFE),
            (v33 = *((_DWORD *)v22 + 17), v33 >= 5) && ((v33 + 1) & 0xFFFFFFFE) > v32))
      {
        *a2 = v21;
        *a3 = v22;
        v24 = *a2;
        v25 = *a1;
        v26 = _TAG::priority(*a2);
        result = _TAG::priority(v25);
        if (v26 > result
          || v26 >= result
          && ((v34 = *((_DWORD *)v24 + 17), v34 <= 4) ? (v35 = 0) : (v35 = (v34 + 1) & 0xFFFFFFFE),
              (v36 = *((_DWORD *)v25 + 17), v36 >= 5) && ((v36 + 1) & 0xFFFFFFFE) > v35))
        {
          *a1 = v24;
          *a2 = v25;
        }
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(_TAG **a1, _TAG **a2, _TAG **a3)
{
  _TAG *v6;
  _TAG *v7;
  unsigned int v8;
  unsigned int v9;
  _TAG *v10;
  uint64_t result;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  BOOL v15;
  _TAG *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  _TAG *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  BOOL v26;
  _TAG *v27;
  _TAG *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;

  v6 = *a2;
  v7 = *a1;
  v8 = _TAG::priority(*a2);
  v9 = _TAG::priority(v7);
  if (v8 > v9
    || v8 >= v9
    && ((v18 = *((_DWORD *)v6 + 17), v18 <= 4) ? (v19 = 0) : (v19 = (v18 + 1) & 0xFFFFFFFE),
        (v20 = *((_DWORD *)v7 + 17), v20 >= 5) ? (v21 = ((v20 + 1) & 0xFFFFFFFE) > v19) : (v21 = 0),
        v21))
  {
    v10 = *a3;
    result = _TAG::priority(*a3);
    if (result > v8
      || result >= v8
      && ((v12 = *((_DWORD *)v10 + 17), v12 <= 4) ? (v13 = 0) : (v13 = (v12 + 1) & 0xFFFFFFFE),
          (v14 = *((_DWORD *)v6 + 17), v14 >= 5) ? (v15 = ((v14 + 1) & 0xFFFFFFFE) > v13) : (v15 = 0),
          v15))
    {
      *a1 = v10;
    }
    else
    {
      *a1 = v6;
      *a2 = v7;
      v16 = *a3;
      v17 = _TAG::priority(*a3);
      result = _TAG::priority(v7);
      if (v17 <= result)
      {
        if (v17 < result)
          return result;
        v30 = *((_DWORD *)v16 + 17);
        v31 = v30 <= 4 ? 0 : (v30 + 1) & 0xFFFFFFFE;
        v32 = *((_DWORD *)v7 + 17);
        if (v32 < 5 || ((v32 + 1) & 0xFFFFFFFE) <= v31)
          return result;
      }
      *a2 = v16;
    }
    *a3 = v7;
    return result;
  }
  v22 = *a3;
  result = _TAG::priority(*a3);
  if (result > v8
    || result >= v8
    && ((v23 = *((_DWORD *)v22 + 17), v23 <= 4) ? (v24 = 0) : (v24 = (v23 + 1) & 0xFFFFFFFE),
        (v25 = *((_DWORD *)v6 + 17), v25 >= 5) ? (v26 = ((v25 + 1) & 0xFFFFFFFE) > v24) : (v26 = 0),
        v26))
  {
    *a2 = v22;
    *a3 = v6;
    v27 = *a2;
    v28 = *a1;
    v29 = _TAG::priority(*a2);
    result = _TAG::priority(v28);
    if (v29 > result
      || v29 >= result
      && ((v33 = *((_DWORD *)v27 + 17), v33 <= 4) ? (v34 = 0) : (v34 = (v33 + 1) & 0xFFFFFFFE),
          (v35 = *((_DWORD *)v28 + 17), v35 >= 5) && ((v35 + 1) & 0xFFFFFFFE) > v34))
    {
      *a1 = v27;
      *a2 = v28;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(_TAG **a1, _TAG **a2)
{
  _TAG **v2;
  uint64_t v4;
  _BOOL8 result;
  _TAG *v6;
  _TAG *v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  BOOL v13;
  _TAG **v14;
  _TAG **v15;
  uint64_t v16;
  int v17;
  _TAG *v18;
  _TAG *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  BOOL v25;
  _TAG **v26;
  uint64_t v27;
  _TAG *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  _TAG **v35;

  v2 = a2;
  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      v8 = _TAG::priority(v6);
      v9 = _TAG::priority(v7);
      if (v8 > v9
        || v8 >= v9
        && ((v10 = *((_DWORD *)v6 + 17), v10 <= 4) ? (v11 = 0) : (v11 = (v10 + 1) & 0xFFFFFFFE),
            (v12 = *((_DWORD *)v7 + 17), v12 >= 5) ? (v13 = ((v12 + 1) & 0xFFFFFFFE) > v11) : (v13 = 0),
            v13))
      {
        *a1 = v6;
        *(v2 - 1) = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v14 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2);
      v15 = a1 + 3;
      if (a1 + 3 == v2)
        return 1;
      v16 = 0;
      v17 = 0;
      v35 = v2;
      break;
  }
  while (1)
  {
    v18 = *v15;
    v19 = *v14;
    v20 = _TAG::priority(*v15);
    v21 = _TAG::priority(v19);
    if (v20 > v21
      || v20 >= v21
      && ((v22 = *((_DWORD *)v18 + 17), v22 <= 4) ? (v23 = 0) : (v23 = (v22 + 1) & 0xFFFFFFFE),
          (v24 = *((_DWORD *)v19 + 17), v24 >= 5) ? (v25 = ((v24 + 1) & 0xFFFFFFFE) > v23) : (v25 = 0),
          v25))
    {
      *v15 = v19;
      v26 = a1;
      if (v14 != a1)
      {
        v27 = v16;
        do
        {
          v28 = *(_TAG **)((char *)a1 + v27 + 8);
          v29 = _TAG::priority(v18);
          v30 = _TAG::priority(v28);
          if (v29 <= v30)
          {
            if (v29 < v30)
            {
              v26 = v14;
              goto LABEL_40;
            }
            v31 = *((_DWORD *)v18 + 17);
            v32 = v31 <= 4 ? 0 : (v31 + 1) & 0xFFFFFFFE;
            v33 = *((_DWORD *)v28 + 17);
            if (v33 < 5 || ((v33 + 1) & 0xFFFFFFFE) <= v32)
            {
              v26 = (_TAG **)((char *)a1 + v27 + 16);
              goto LABEL_40;
            }
          }
          --v14;
          *(_TAG **)((char *)a1 + v27 + 16) = v28;
          v27 -= 8;
        }
        while (v27 != -16);
        v26 = a1;
LABEL_40:
        v2 = v35;
      }
      *v26 = v18;
      if (++v17 == 8)
        return v15 + 1 == v2;
    }
    v14 = v15;
    v16 += 8;
    if (++v15 == v2)
      return 1;
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(_TAG **a1, _TAG **a2, _TAG **a3, _TAG **a4)
{
  _TAG *v8;
  _TAG *v9;
  unsigned int v10;
  uint64_t result;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  BOOL v15;
  _TAG *v16;
  _TAG *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  BOOL v22;
  _TAG *v23;
  _TAG *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a2, a3);
  v8 = *a4;
  v9 = *a3;
  v10 = _TAG::priority(*a4);
  result = _TAG::priority(v9);
  if (v10 > result
    || v10 >= result
    && ((v12 = *((_DWORD *)v8 + 17), v12 <= 4) ? (v13 = 0) : (v13 = (v12 + 1) & 0xFFFFFFFE),
        (v14 = *((_DWORD *)v9 + 17), v14 >= 5) ? (v15 = ((v14 + 1) & 0xFFFFFFFE) > v13) : (v15 = 0),
        v15))
  {
    *a3 = v8;
    *a4 = v9;
    v16 = *a3;
    v17 = *a2;
    v18 = _TAG::priority(*a3);
    result = _TAG::priority(v17);
    if (v18 > result
      || v18 >= result
      && ((v19 = *((_DWORD *)v16 + 17), v19 <= 4) ? (v20 = 0) : (v20 = (v19 + 1) & 0xFFFFFFFE),
          (v21 = *((_DWORD *)v17 + 17), v21 >= 5) ? (v22 = ((v21 + 1) & 0xFFFFFFFE) > v20) : (v22 = 0),
          v22))
    {
      *a2 = v16;
      *a3 = v17;
      v23 = *a2;
      v24 = *a1;
      v25 = _TAG::priority(*a2);
      result = _TAG::priority(v24);
      if (v25 > result
        || v25 >= result
        && ((v26 = *((_DWORD *)v23 + 17), v26 <= 4) ? (v27 = 0) : (v27 = (v26 + 1) & 0xFFFFFFFE),
            (v28 = *((_DWORD *)v24 + 17), v28 >= 5) && ((v28 + 1) & 0xFFFFFFFE) > v27))
      {
        *a1 = v23;
        *a2 = v24;
      }
    }
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  BOOL v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  BOOL v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t *v59;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  unsigned int v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t *v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t *v87;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;

  v7 = (uint64_t *)result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (char *)a2 - (char *)v8;
    v10 = a2 - v8;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v38 = *(a2 - 1);
        v39 = *v8;
        if (*(unsigned __int16 *)(v38 + 40) < *(unsigned __int16 *)(*v8 + 40))
        {
          *v8 = v38;
          *(a2 - 1) = v39;
        }
        return result;
      case 3uLL:
        return (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v8, v8 + 1, a2 - 1);
      case 4uLL:
        return (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v8, v8 + 1, v8 + 2, a2 - 1);
      case 5uLL:
        v40 = v8 + 1;
        v41 = v8 + 2;
        v42 = v8 + 3;
        result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v8, v8 + 1, v8 + 2, v8 + 3);
        v43 = *(a2 - 1);
        v44 = v8[3];
        if (*(unsigned __int16 *)(v43 + 40) < *(unsigned __int16 *)(v44 + 40))
        {
          *v42 = v43;
          *(a2 - 1) = v44;
          v45 = *v42;
          v46 = *v41;
          v47 = *(unsigned __int16 *)(*v42 + 40);
          if (v47 < *(unsigned __int16 *)(*v41 + 40))
          {
            *v41 = v45;
            *v42 = v46;
            v48 = *v40;
            if (v47 < *(unsigned __int16 *)(*v40 + 40))
            {
              v8[1] = v45;
              v8[2] = v48;
              v49 = *v8;
              if (v47 < *(unsigned __int16 *)(*v8 + 40))
              {
                *v8 = v45;
                v8[1] = v49;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 191)
        {
          v50 = v8 + 1;
          v52 = v8 == a2 || v50 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v52)
            {
              v53 = 0;
              v54 = v8;
              do
              {
                v56 = *v54;
                v55 = v54[1];
                v54 = v50;
                v57 = *(unsigned __int16 *)(v55 + 40);
                if (v57 < *(unsigned __int16 *)(v56 + 40))
                {
                  v58 = v53;
                  while (1)
                  {
                    *(uint64_t *)((char *)v8 + v58 + 8) = v56;
                    if (!v58)
                      break;
                    v56 = *(uint64_t *)((char *)v8 + v58 - 8);
                    v58 -= 8;
                    if (v57 >= *(unsigned __int16 *)(v56 + 40))
                    {
                      v59 = (uint64_t *)((char *)v8 + v58 + 8);
                      goto LABEL_80;
                    }
                  }
                  v59 = v8;
LABEL_80:
                  *v59 = v55;
                }
                v50 = v54 + 1;
                v53 += 8;
              }
              while (v54 + 1 != a2);
            }
          }
          else if (!v52)
          {
            do
            {
              v90 = *v7;
              v89 = v7[1];
              v7 = v50;
              v91 = *(unsigned __int16 *)(v89 + 40);
              if (v91 < *(unsigned __int16 *)(v90 + 40))
              {
                do
                {
                  *v50 = v90;
                  v90 = *(v50 - 2);
                  --v50;
                }
                while (v91 < *(unsigned __int16 *)(v90 + 40));
                *v50 = v89;
              }
              v50 = v7 + 1;
            }
            while (v7 + 1 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v60 = (v10 - 2) >> 1;
            v61 = v60;
            do
            {
              v62 = v61;
              if (v60 >= v61)
              {
                v63 = (2 * v61) | 1;
                v64 = &v8[v63];
                v65 = *v64;
                if (2 * v62 + 2 < (uint64_t)v10)
                {
                  result = *(unsigned __int16 *)(v65 + 40);
                  if (result < *(unsigned __int16 *)(v64[1] + 40))
                  {
                    v65 = v64[1];
                    ++v64;
                    v63 = 2 * v62 + 2;
                  }
                }
                v66 = &v8[v62];
                v67 = *v66;
                v68 = *(unsigned __int16 *)(*v66 + 40);
                if (*(unsigned __int16 *)(v65 + 40) >= v68)
                {
                  do
                  {
                    v69 = v64;
                    *v66 = v65;
                    if (v60 < v63)
                      break;
                    result = (2 * v63) | 1;
                    v64 = &v8[result];
                    v70 = 2 * v63 + 2;
                    v65 = *v64;
                    if (v70 < (uint64_t)v10
                      && *(unsigned __int16 *)(v65 + 40) < *(unsigned __int16 *)(v64[1] + 40))
                    {
                      v65 = v64[1];
                      ++v64;
                      result = v70;
                    }
                    v66 = v69;
                    v63 = result;
                  }
                  while (*(unsigned __int16 *)(v65 + 40) >= v68);
                  *v69 = v67;
                }
              }
              v61 = v62 - 1;
            }
            while (v62);
            v71 = (unint64_t)v9 >> 3;
            do
            {
              v72 = 0;
              v73 = *v8;
              v74 = v8;
              do
              {
                v75 = &v74[v72];
                v78 = v75[1];
                v76 = v75 + 1;
                v77 = v78;
                v79 = (2 * v72) | 1;
                v80 = 2 * v72 + 2;
                if (v80 < v71)
                {
                  result = *(unsigned __int16 *)(v77 + 40);
                  if (result < *(unsigned __int16 *)(v76[1] + 40))
                  {
                    v77 = v76[1];
                    ++v76;
                    v79 = v80;
                  }
                }
                *v74 = v77;
                v74 = v76;
                v72 = v79;
              }
              while (v79 <= (uint64_t)((unint64_t)(v71 - 2) >> 1));
              if (v76 == --a2)
              {
                *v76 = v73;
              }
              else
              {
                *v76 = *a2;
                *a2 = v73;
                v81 = (char *)v76 - (char *)v8 + 8;
                if (v81 >= 9)
                {
                  v82 = (((unint64_t)v81 >> 3) - 2) >> 1;
                  v83 = &v8[v82];
                  v84 = *v83;
                  v85 = *v76;
                  v86 = *(unsigned __int16 *)(*v76 + 40);
                  if (*(unsigned __int16 *)(*v83 + 40) < v86)
                  {
                    do
                    {
                      v87 = v83;
                      *v76 = v84;
                      if (!v82)
                        break;
                      v82 = (v82 - 1) >> 1;
                      v83 = &v8[v82];
                      v84 = *v83;
                      v76 = v87;
                    }
                    while (*(unsigned __int16 *)(*v83 + 40) < v86);
                    *v87 = v85;
                  }
                }
              }
            }
            while (v71-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = &v8[v10 >> 1];
        if ((unint64_t)v9 < 0x401)
        {
          result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(&v7[v10 >> 1], v7, a2 - 1);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v7, &v7[v10 >> 1], a2 - 1);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v7 + 1, v12 - 1, a2 - 2);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v7 + 2, &v7[v11 + 1], a2 - 3);
          result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v12 - 1, v12, &v7[v11 + 1]);
          v13 = *v7;
          *v7 = *v12;
          *v12 = v13;
        }
        --a3;
        v14 = *v7;
        if ((a4 & 1) == 0)
        {
          v15 = *(unsigned __int16 *)(v14 + 40);
          if (*(unsigned __int16 *)(*(v7 - 1) + 40) < v15)
            goto LABEL_12;
          if (v15 >= *(unsigned __int16 *)(*(a2 - 1) + 40))
          {
            v30 = v7 + 1;
            do
            {
              v8 = v30;
              if (v30 >= a2)
                break;
              ++v30;
            }
            while (v15 >= *(unsigned __int16 *)(*v8 + 40));
          }
          else
          {
            v8 = v7;
            do
            {
              v29 = v8[1];
              ++v8;
            }
            while (v15 >= *(unsigned __int16 *)(v29 + 40));
          }
          v31 = a2;
          if (v8 < a2)
          {
            v31 = a2;
            do
              v32 = *--v31;
            while (v15 < *(unsigned __int16 *)(v32 + 40));
          }
          if (v8 < v31)
          {
            v33 = *v8;
            v34 = *v31;
            do
            {
              *v8 = v34;
              *v31 = v33;
              do
              {
                v35 = v8[1];
                ++v8;
                v33 = v35;
              }
              while (v15 >= *(unsigned __int16 *)(v35 + 40));
              do
              {
                v36 = *--v31;
                v34 = v36;
              }
              while (v15 < *(unsigned __int16 *)(v36 + 40));
            }
            while (v8 < v31);
          }
          v37 = v8 - 1;
          if (v8 - 1 != v7)
            *v7 = *v37;
          a4 = 0;
          *v37 = v14;
          continue;
        }
        v15 = *(unsigned __int16 *)(v14 + 40);
LABEL_12:
        v16 = 0;
        do
          v17 = v7[++v16];
        while (*(unsigned __int16 *)(v17 + 40) < v15);
        v18 = &v7[v16];
        v19 = a2;
        if (v16 == 1)
        {
          v19 = a2;
          do
          {
            if (v18 >= v19)
              break;
            v21 = *--v19;
          }
          while (*(unsigned __int16 *)(v21 + 40) >= v15);
        }
        else
        {
          do
            v20 = *--v19;
          while (*(unsigned __int16 *)(v20 + 40) >= v15);
        }
        if (v18 >= v19)
        {
          v27 = v18 - 1;
        }
        else
        {
          v22 = *v19;
          v23 = v19;
          v24 = &v7[v16];
          do
          {
            *v24 = v22;
            *v23 = v17;
            do
            {
              v25 = v24[1];
              ++v24;
              v17 = v25;
            }
            while (*(unsigned __int16 *)(v25 + 40) < v15);
            do
            {
              v26 = *--v23;
              v22 = v26;
            }
            while (*(unsigned __int16 *)(v26 + 40) >= v15);
          }
          while (v24 < v23);
          v27 = v24 - 1;
        }
        if (v27 != v7)
          *v7 = *v27;
        *v27 = v14;
        if (v18 < v19)
        {
LABEL_33:
          result = std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **,false>(v7, v27, a3, a4 & 1);
          a4 = 0;
          v8 = v27 + 1;
          continue;
        }
        v28 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v7, v27);
        v8 = v27 + 1;
        result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v27 + 1, a2);
        if (!(_DWORD)result)
        {
          if (v28)
            continue;
          goto LABEL_33;
        }
        a2 = v27;
        if (!v28)
          goto LABEL_2;
        return result;
    }
  }
}

uint64_t *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;

  v3 = *a2;
  v4 = *result;
  v5 = *(unsigned __int16 *)(*a2 + 40);
  v6 = *(unsigned __int16 *)(*result + 40);
  v7 = *a3;
  v8 = *(unsigned __int16 *)(*a3 + 40);
  if (v5 >= v6)
  {
    if (v8 < v5)
    {
      *a2 = v7;
      *a3 = v3;
      v9 = *result;
      if (*(unsigned __int16 *)(*a2 + 40) < *(unsigned __int16 *)(*result + 40))
      {
        *result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v5)
    {
      *result = v3;
      *a2 = v4;
      if (*(unsigned __int16 *)(*a3 + 40) >= v6)
        return result;
      *a2 = *a3;
    }
    else
    {
      *result = v7;
    }
    *a3 = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      if (*(unsigned __int16 *)(v6 + 40) < *(unsigned __int16 *)(*a1 + 40))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      v18 = a1 + 1;
      v19 = a1 + 2;
      v20 = a1 + 3;
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2, a1 + 3);
      v21 = *(a2 - 1);
      v22 = a1[3];
      if (*(unsigned __int16 *)(v21 + 40) < *(unsigned __int16 *)(v22 + 40))
      {
        *v20 = v21;
        *(a2 - 1) = v22;
        v23 = *v20;
        v24 = *v19;
        v25 = *(unsigned __int16 *)(*v20 + 40);
        if (v25 < *(unsigned __int16 *)(*v19 + 40))
        {
          *v19 = v23;
          *v20 = v24;
          v26 = *v18;
          if (v25 < *(unsigned __int16 *)(*v18 + 40))
          {
            a1[1] = v23;
            a1[2] = v26;
            v27 = *a1;
            if (v25 < *(unsigned __int16 *)(*a1 + 40))
            {
              *a1 = v23;
              a1[1] = v27;
            }
          }
        }
      }
      return 1;
    default:
      v8 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2);
      v9 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v10 = 0;
      v11 = 24;
      break;
  }
  while (1)
  {
    v12 = *v9;
    v13 = *v8;
    v14 = *(unsigned __int16 *)(*v9 + 40);
    if (v14 < *(unsigned __int16 *)(*v8 + 40))
    {
      v15 = v11;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15) = v13;
        v16 = v15 - 8;
        if (v15 == 8)
          break;
        v13 = *(uint64_t *)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 >= *(unsigned __int16 *)(v13 + 40))
        {
          v17 = (uint64_t *)((char *)a1 + v16);
          goto LABEL_13;
        }
      }
      v17 = a1;
LABEL_13:
      *v17 = v12;
      if (++v10 == 8)
        return v9 + 1 == a2;
    }
    v8 = v9;
    v11 += 8;
    if (++v9 == a2)
      return 1;
  }
}

uint64_t *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a2, a3);
  v9 = *a3;
  if (*(unsigned __int16 *)(*a4 + 40) < *(unsigned __int16 *)(*a3 + 40))
  {
    *a3 = *a4;
    *a4 = v9;
    v10 = *a2;
    if (*(unsigned __int16 *)(*a3 + 40) < *(unsigned __int16 *)(*a2 + 40))
    {
      *a2 = *a3;
      *a3 = v10;
      v11 = *a1;
      if (*(unsigned __int16 *)(*a2 + 40) < *(unsigned __int16 *)(*a1 + 40))
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

void IIOMemoryHash::~IIOMemoryHash(IIOMemoryHash *this)
{
  *(_QWORD *)this = &off_1E1BACDC8;
  std::__tree<unsigned long long>::destroy((uint64_t)this + 8, *((_QWORD **)this + 2));
}

{
  *(_QWORD *)this = &off_1E1BACDC8;
  std::__tree<unsigned long long>::destroy((uint64_t)this + 8, *((_QWORD **)this + 2));
  JUMPOUT(0x18D761C30);
}

uint64_t _ImageIO_AccreditMemory(uint64_t a1, uint64_t a2)
{
  unint64_t v5;
  unint64_t *v6;

  pthread_mutex_lock(&gImageIOMemoryHashLock);
  if (gMemoryHashCreateOnce != -1)
    dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_30);
  v5 = ~a1;
  v6 = &v5;
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v5, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6)[5] = a2;
  ImageIORecordMemory(a1, a2);
  return pthread_mutex_unlock(&gImageIOMemoryHashLock);
}

uint64_t IIO_ImageBlockSetRelease(const void *a1)
{
  if ((gIIODebugFlags & 0xC00) != 0)
  {
    ImageIOLog("    CGImageBlockSetRelease:   %14p [%ld]\n", a1, gBlockSetCount);
    if ((gIIODebugFlags & 0x800) != 0)
      IIODebug_ShowBacktrace(2);
  }
  return CGImageBlockSetRelease();
}

const char *IIO_ImageBlockSetReleased(const char *result)
{
  unsigned int v1;

  if ((gIIODebugFlags & 0xC00) != 0)
  {
    do
      v1 = __ldxr((unsigned int *)&gBlockSetCount);
    while (__stxr(v1 - 1, (unsigned int *)&gBlockSetCount));
    result = ImageIOLog("    CGImageBlockSetReleaseCB:                  info: %14p                        S-[%2ld]\n", result, gBlockSetCount);
    if ((gIIODebugFlags & 0x800) != 0)
      return IIODebug_ShowBacktrace(2);
  }
  return result;
}

const char *IIO_ImageBlockReleased(const char *result, const void *a2)
{
  unsigned int v2;

  if ((gIIODebugFlags & 0xC00) != 0)
  {
    do
      v2 = __ldxr((unsigned int *)&gBlockCount);
    while (__stxr(v2 - 1, (unsigned int *)&gBlockCount));
    result = ImageIOLog("    CGImageBlockReleaseCB:    %14p - info: %14p                        B-[%2ld]\n", a2, result, gBlockCount);
    if ((gIIODebugFlags & 0x800) != 0)
      return IIODebug_ShowBacktrace(2);
  }
  return result;
}

uint64_t ___ZN12IIOImageRead13CreateWithURLEPK7__CFURLPK10__CFStringPhbbb_block_invoke()
{
  uint64_t result;

  result = IOPreferencesGetBoolean("ImageIO_TrustSystemPathURLs", 0, 0);
  IIOImageRead::CreateWithURL(__CFURL const*,__CFString const*,unsigned char *,BOOL,BOOL,BOOL)::useSystemPath = result;
  return result;
}

void IIOImageRead::IIOImageRead(IIOImageRead *this, int a2, const char *a3, unint64_t a4, char a5, char a6)
{
  size_t f_iosize;
  statfs v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E1BAC230;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 30) = (char *)this + 248;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 36) = 0;
  IIOImageRead::setup((uint64_t)this, 7);
  *((_DWORD *)this + 6) = a2;
  *((_QWORD *)this + 10) = a4;
  *((_BYTE *)this + 64) = a6;
  *((_BYTE *)this + 65) = a6 ^ 1;
  *((_BYTE *)this + 66) = 1;
  bzero(&v13, 0x878uLL);
  if (statfs(a3, &v13))
  {
    if (a4 >= 0x1000)
      f_iosize = 4096;
    else
      f_iosize = a4;
  }
  else if (v13.f_iosize >= a4)
  {
    f_iosize = a4;
  }
  else
  {
    f_iosize = v13.f_iosize;
  }
  *((_QWORD *)this + 34) = f_iosize;
  if ((gIIODebugFlags & 0xC00000) != 0)
  {
    ImageIOLog("    %s: _fileBufferSize: %8ld  stat.f_iosize: %8ld  filesize: %8ld  file: '%s'", "IIOImageRead", f_iosize, v13.f_iosize, a4, a3);
    f_iosize = *((_QWORD *)this + 34);
  }
  *((_BYTE *)this + 71) = a5;
  *((_QWORD *)this + 35) = -1;
  *((_QWORD *)this + 33) = malloc_type_malloc(f_iosize, 0xAEF267FFuLL);
}

void sub_18802A538(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  void **v3;
  _QWORD **v4;
  void *v6;
  void *v7;

  v6 = (void *)v1[36];
  if (v6)
  {
    v1[37] = v6;
    operator delete(v6);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  v7 = *v3;
  if (*v3)
  {
    v1[20] = v7;
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

void IIOImageRead::IIOImageRead(IIOImageRead *this, CGDataProvider *a2, char a3)
{
  *(_QWORD *)this = &off_1E1BAC230;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 30) = (char *)this + 248;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 36) = 0;
  IIOImageRead::setup((uint64_t)this, 3);
  *((_QWORD *)this + 5) = CFRetain(a2);
  *((_BYTE *)this + 64) = a3;
  *((_BYTE *)this + 65) = a3 ^ 1;
  *((_QWORD *)this + 10) = CGDataProviderGetSizeOfData();
}

void sub_18802A61C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  _QWORD **v4;
  void **v5;
  void *v7;
  void *v8;

  v7 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  v8 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void IIOImageRead::IIOImageRead(IIOImageRead *this, IIOImageRead *a2)
{
  void *v4;
  const __CFData *DataFromXPCDict;

  *(_QWORD *)this = &off_1E1BAC230;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 30) = (char *)this + 248;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 36) = 0;
  IIOImageRead::setup((uint64_t)this, 9);
  if (MEMORY[0x18D763274](a2) == MEMORY[0x1E0C812F8])
  {
    DataFromXPCDict = (const __CFData *)IIOImageRead::CreateDataFromXPCDict(a2, v4);
    *((_QWORD *)this + 4) = DataFromXPCDict;
    if ((gIIODebugFlags & 0x80000000000) != 0)
    {
      ImageIOLog("D   %s:%d CreateDataFromXPCDict %p\n", "IIOImageRead", 628, DataFromXPCDict);
      DataFromXPCDict = (const __CFData *)*((_QWORD *)this + 4);
    }
    *((_WORD *)this + 32) = 1;
    if (DataFromXPCDict)
      DataFromXPCDict = (const __CFData *)CFDataGetLength(DataFromXPCDict);
    *((_QWORD *)this + 10) = DataFromXPCDict;
  }
}

void sub_18802A73C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  _QWORD **v4;
  void **v5;
  void *v7;
  void *v8;

  v7 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  v8 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

const UInt8 *IIOImageRead::CreateDataFromXPCDict(IIOImageRead *this, void *a2)
{
  xpc_object_t source_dict;
  void *v4;
  xpc_object_t value;
  uint64_t uint64;
  unint64_t v7;
  size_t v8;
  const UInt8 *result;
  void *region;

  if (MEMORY[0x18D763274](this, a2) != MEMORY[0x1E0C812F8])
    return 0;
  source_dict = iio_xpc_get_source_dict(this);
  v4 = source_dict;
  if (source_dict
    && (value = xpc_dictionary_get_value(source_dict, "iio_xpc_src_shmem"),
        uint64 = xpc_dictionary_get_uint64(v4, "iio_xpc_src_shmem_size"),
        value)
    && (v7 = uint64) != 0)
  {
    region = 0;
    v8 = xpc_shmem_map(value, &region);
    result = 0;
    if (v8 >= v7)
      result = (const UInt8 *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)region, v7);
  }
  else
  {
    region = 0;
    result = (const UInt8 *)xpc_dictionary_get_data(v4, "iio_xpc_src_data", (size_t *)&region);
    if (result)
      result = (const UInt8 *)CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], result, (CFIndex)region, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  }
  if (!result)
  {
    LogError("CreateDataFromXPCDict", 1980, "*** ERROR: Failed to create CFData from xpc_object_t: %p\n", this);
    return 0;
  }
  return result;
}

uint64_t IIOImageRead::getClientValueForKey@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  pthread_mutex_t *v6;
  uint64_t v7;

  v6 = (pthread_mutex_t *)(a1 + 176);
  *a3 = 0;
  a3[1] = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 176));
  v7 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(a1 + 240, a2);
  if (a1 + 248 != v7)
    std::shared_ptr<IIOBaseObject>::operator=[abi:ne180100](a3, (uint64_t *)(v7 + 56));
  return pthread_mutex_unlock(v6);
}

void sub_18802A904(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<IIOBaseObject>::operator=[abi:ne180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

uint64_t IIOImageRead::setClientValueForKey(uint64_t a1, __int128 *a2, uint64_t *a3)
{
  pthread_mutex_t *v6;
  uint64_t *v7;
  __int128 *v9;

  v6 = (pthread_mutex_t *)(a1 + 176);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 176));
  v9 = a2;
  v7 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)(a1 + 240), (const void **)a2, (uint64_t)&std::piecewise_construct, &v9);
  std::shared_ptr<IIOBaseObject>::operator=[abi:ne180100](v7 + 7, a3);
  return pthread_mutex_unlock(v6);
}

const __CFData *IIOImageRead::createDataWithMappedFile(IIOImageRead *this, BOOL *a2, int *a3)
{
  const __CFURL *v5;
  CFStringRef v7;
  CFStringRef v8;
  int v9;
  const __CFData *v10;
  const __CFData *v11;
  unint64_t Length;
  unsigned __int8 *BytePtr;
  char *v14;
  char *v15;
  stat v17;
  char v18[1024];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  memset(&v17, 0, sizeof(v17));
  *((_BYTE *)this + 70) = 1;
  v5 = (const __CFURL *)*((_QWORD *)this + 6);
  if (!v5)
  {
LABEL_16:
    v11 = 0;
    LODWORD(a2) = 0;
    if (!a3)
      return v11;
    goto LABEL_26;
  }
  v7 = IIO_CFURLCopyResolvedFileSystemPath(v5);
  if (!v7)
  {
    LogError("createDataWithMappedFile", 1637, "*** ERROR: cannot resolve URL\n");
    goto LABEL_16;
  }
  v8 = v7;
  bzero(v18, 0x400uLL);
  if (!_CFStringGetFileSystemRepresentation())
  {
    LogError("createDataWithMappedFile", 1640, "*** ERROR: cannot get URL path\n");
    LODWORD(a2) = 0;
    v11 = 0;
    goto LABEL_25;
  }
  v9 = open(v18, 0, 0);
  kdebug_trace();
  if ((gIIODebugFlags & 0x200000000000) != 0)
    ImageIOLog(">>> %s: opening file [%d] '%s'\n", "createDataWithMappedFile", v9, v18);
  if (v9 < 0)
  {
    LODWORD(a2) = *__error();
    v14 = strerror((int)a2);
    LogFault("createDataWithMappedFile", 1686, "*** ERROR: 'open' failed '%s'\terror = %d (%s)\n", v18, (_DWORD)a2, v14);
    kdebug_trace();
    v11 = 0;
    goto LABEL_25;
  }
  if (fstat(v9, &v17) < 0)
  {
    LODWORD(a2) = *__error();
    v15 = strerror((int)a2);
    LogFault("createDataWithMappedFile", 1654, "*** ERROR: 'failed - fstat err = %d (%s)\n", (_DWORD)a2, v15);
    v11 = 0;
  }
  else
  {
    v10 = _CFDataCreateWithMappedFile(v9, v18, &v17, *((unsigned __int8 *)this + 68));
    v11 = v10;
    if (!v10)
    {
      LogFault("createDataWithMappedFile", 1676, "*** ERROR: '_CFDataCreateWithMappedFile' failed '%s'\n", v18);
      goto LABEL_21;
    }
    *((_BYTE *)this + 70) = 0;
    if (a2)
    {
      *a2 = 1;
      Length = CFDataGetLength(v10);
      a2 = (BOOL *)(Length >= 4 ? 4 : Length);
      BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v11);
      if (a2)
      {
        ImageIO_FileIsNotReadable(BytePtr, (size_t)a2);
LABEL_21:
        LODWORD(a2) = 0;
      }
    }
  }
  if ((gIIODebugFlags & 0x200000000000) != 0)
    ImageIOLog("<<< %s: closing file [%d] '%s'\n", "createDataWithMappedFile", v9, v18);
  kdebug_trace();
  close(v9);
LABEL_25:
  CFRelease(v8);
  if (a3)
LABEL_26:
    *a3 = (int)a2;
  return v11;
}

void IIOBytesNoCopyDeallocate(void *a1, void *a2)
{
  if (a1)
    free(a1);
}

ssize_t IIOImageRead::getFileBytesAtOffset(IIOImageRead *this, void *__buf, unint64_t a3, size_t __nbyte)
{
  const void *v8;
  CFIndex Length;
  void *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  size_t v16;
  int v17;
  int *v18;
  char *v19;
  ssize_t v21;

  if ((gIIODebugFlags & 0x800000) != 0)
  {
    v8 = (const void *)*((unsigned int *)this + 6);
    Length = CFDataGetLength(*((CFDataRef *)this + 4));
    ImageIOLog("    %s:%d:  file: %p  [%8ld]  offset: 0x%08lX   size: %8ld\n", "getFileBytesAtOffset", 1415, v8, Length, a3, __nbyte);
  }
  v10 = (void *)*((_QWORD *)this + 33);
  if (!v10)
    return 0;
  v11 = *((_QWORD *)this + 34);
  if (!v11)
    return 0;
  v12 = *((_QWORD *)this + 35);
  v13 = a3 % v11;
  v14 = a3 % v11 + __nbyte;
  if (v12 == -1 || v12 > a3)
  {
    if (v14 < v11)
      goto LABEL_12;
  }
  else if (v14 < v11)
  {
    if (v12 + v11 > a3)
    {
      v15 = *((_QWORD *)this + 35);
LABEL_20:
      if ((gIIODebugFlags & 0xC00000) != 0)
        ImageIOLog("    %s:   file-buffer: [%10lld - %10lld] (%10lld bytes)   request: [%10ld - %10ld] (%10ld bytes)  memcpy from buffer\n", "getFileBytesAtOffset", v15, *((_QWORD *)this + 34) + v15, *((_QWORD *)this + 34), a3, __nbyte + a3, __nbyte);
      memmove(__buf, (const void *)(*((_QWORD *)this + 33) + v13), __nbyte);
      return __nbyte;
    }
LABEL_12:
    v15 = a3 - v13;
    if (v11 >= *((_QWORD *)this + 10) - (a3 - v13))
      v16 = *((_QWORD *)this + 10) - (a3 - v13);
    else
      v16 = *((_QWORD *)this + 34);
    if ((gIIODebugFlags & 0xC00000) != 0)
    {
      ImageIOLog("    %s:   file-buffer: [%10lld - %10lld] (%10lld bytes)   request: [%10ld - %10ld] (%10ld bytes)  fill buffer pread\n", "getFileBytesAtOffset", v12, v12 + v11, v11, a3, __nbyte + a3, __nbyte);
      v10 = (void *)*((_QWORD *)this + 33);
    }
    if (pread(*((_DWORD *)this + 6), v10, v16, a3 - v13) == -1)
    {
      v17 = *__error();
      v18 = __error();
      v19 = strerror(*v18);
      LogFault("getFileBytesAtOffset", 1466, "pread failed: err = %d (%s)\n", v17, v19);
    }
    *((_QWORD *)this + 35) = v15;
    goto LABEL_20;
  }
  *((_QWORD *)this + 35) = -1;
  if ((gIIODebugFlags & 0xC00000) != 0)
    ImageIOLog("    %s:   file-buffer: [%10lld - %10lld] (%10lld bytes)   request: [%10ld - %10ld] (%10ld bytes)  size/boundary pread\n", "getFileBytesAtOffset", -1, v11 - 1, v11, a3, __nbyte + a3, __nbyte);
  v21 = pread(*((_DWORD *)this + 6), __buf, __nbyte, a3);
  return v21 & ~(v21 >> 63);
}

uint64_t IIOImageRead::removeCacheKey(uint64_t this, uint64_t a2)
{
  uint64_t v3;
  pthread_mutex_t *v4;
  __int128 *v5;
  __int128 *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  char *DebugStringFromKey;
  char *v11;
  char *v12;
  int64_t v13;
  __int128 key;
  _BYTE v15[28];

  if (*(_QWORD *)(this + 296) != *(_QWORD *)(this + 288))
  {
    v3 = this;
    v4 = (pthread_mutex_t *)(this + 312);
    pthread_mutex_lock((pthread_mutex_t *)(this + 312));
    v6 = *(__int128 **)(v3 + 288);
    v5 = *(__int128 **)(v3 + 296);
    if (v6 != v5)
    {
      v7 = 0uLL;
      do
      {
        *(_OWORD *)&v15[12] = v7;
        key = v7;
        *(_OWORD *)v15 = v7;
        v8 = *v6;
        v9 = v6[1];
        *(_OWORD *)&v15[12] = *(__int128 *)((char *)v6 + 28);
        key = v8;
        *(_OWORD *)v15 = v9;
        if (WORD6(v9) == a2)
        {
          cache_remove((cache_t *)gImageBlockCache, &key);
          if ((gIIODebugFlags & 0x200) != 0)
          {
            DebugStringFromKey = createDebugStringFromKey((uint64_t)&key);
            if (DebugStringFromKey)
            {
              v11 = DebugStringFromKey;
              ImageIOLog("    cache_remove:            %p key: %s\n", (const void *)gImageBlockCache, DebugStringFromKey);
              free(v11);
            }
          }
          v12 = *(char **)(v3 + 296);
          v13 = v12 - ((char *)v6 + 44);
          if (v12 != (char *)v6 + 44)
            memmove(v6, (char *)v6 + 44, v12 - ((char *)v6 + 44));
          v5 = (__int128 *)((char *)v6 + v13);
          *(_QWORD *)(v3 + 296) = (char *)v6 + v13;
          v7 = 0uLL;
        }
        else
        {
          v6 = (__int128 *)((char *)v6 + 44);
        }
      }
      while (v6 != v5);
    }
    return pthread_mutex_unlock(v4);
  }
  return this;
}

uint64_t IIOImageRead::updateDataProvider(IIOImageRead *this, CGDataProvider *a2, int a3)
{
  pthread_mutex_t *v6;
  const void *v7;
  const void *v8;
  CFTypeRef v9;
  uint64_t SizeOfData;

  v6 = (pthread_mutex_t *)((char *)this + 376);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  v7 = (const void *)*((_QWORD *)this + 4);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 5);
  if (a2)
  {
    v9 = CFRetain(a2);
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 5) = v9;
    SizeOfData = CGDataProviderGetSizeOfData();
  }
  else
  {
    SizeOfData = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 5) = 0;
  }
  *((_QWORD *)this + 10) = SizeOfData;
  *((_BYTE *)this + 64) = a3;
  if (a3)
    *((_BYTE *)this + 65) = 0;
  if (v8)
    CFRelease(v8);
  return pthread_mutex_unlock(v6);
}

BOOL IIOImageRead::addDataToXPCDict(size_t *this, void *a2, void **a3)
{
  xpc_object_t v6;
  UInt8 *v7;
  CFIndex Size;
  size_t v9;
  xpc_object_t v10;
  void *v11;
  _BOOL8 v12;
  CFTypeRef v13;
  NSObject *v14;
  NSObject *v15;
  xpc_object_t v16;
  void *v17;
  _QWORD destructor[6];
  CFTypeRef cf;

  cf = 0;
  if (MEMORY[0x18D763274](a2) != MEMORY[0x1E0C812F8])
    goto LABEL_14;
  v6 = iio_xpc_add_source_dict(a2);
  v7 = (UInt8 *)IIOImageRead::retainBytePointer((IIOImageRead *)this, (const __CFData **)&cf, 1);
  Size = IIOImageRead::getSize((IIOImageRead *)this);
  v9 = Size;
  if (v7 && !Size)
    v9 = this[10];
  if (*((_BYTE *)this + 67))
  {
    v10 = xpc_shmem_create(v7, v9);
    if (v10)
    {
      v11 = v10;
      xpc_dictionary_set_value(v6, "iio_xpc_src_shmem", v10);
      xpc_dictionary_set_uint64(v6, "iio_xpc_src_shmem_size", v9);
      xpc_release(v11);
      v12 = 1;
      v13 = cf;
      goto LABEL_16;
    }
    v13 = cf;
    if (!cf)
    {
LABEL_15:
      v12 = 0;
      goto LABEL_16;
    }
    IIOImageRead::releaseBytePointer(0, cf);
LABEL_14:
    v13 = 0;
    goto LABEL_15;
  }
  destructor[0] = MEMORY[0x1E0C809B0];
  destructor[1] = 0x40000000;
  destructor[2] = ___ZN12IIOImageRead16addDataToXPCDictEPvPS0__block_invoke;
  destructor[3] = &__block_descriptor_tmp_63_0;
  destructor[4] = this;
  destructor[5] = cf;
  v14 = dispatch_data_create(v7, v9, 0, destructor);
  if (!v14)
    goto LABEL_14;
  v15 = v14;
  v16 = xpc_data_create_with_dispatch_data(v14);
  v12 = v16 != 0;
  if (v16)
  {
    v17 = v16;
    xpc_dictionary_set_value(v6, "iio_xpc_src_data", v16);
    xpc_release(v17);
  }
  dispatch_release(v15);
  v13 = 0;
LABEL_16:
  *a3 = (void *)v13;
  return v12;
}

void ___ZN12IIOImageRead16addDataToXPCDictEPvPS0__block_invoke(IIOImageRead *a1)
{
  const void *v1;

  v1 = (const void *)*((_QWORD *)a1 + 5);
  if (v1)
    IIOImageRead::releaseBytePointer(a1, v1);
}

uint64_t IIOImageRead::shouldExposeMultiFrameContents(IIOImageRead *this)
{
  IIOImageSource *Source;

  Source = (IIOImageSource *)CGImageSourceGetSource(~*((_QWORD *)this + 2));
  if (Source)
    return IIOImageSource::shouldExposeMultiFrameContents(Source);
  _cg_jpeg_mem_term("shouldExposeMultiFrameContents", 2094, "*** could not get 'shouldExposeMultiFrameContents' -- nil iSource\n");
  return 0;
}

uint64_t IIOImageRead::useImageSequence(IIOImageRead *this)
{
  IIOImageSource *Source;

  Source = (IIOImageSource *)CGImageSourceGetSource(~*((_QWORD *)this + 2));
  if (Source)
    return IIOImageSource::useImageSequence(Source);
  _cg_jpeg_mem_term("useImageSequence", 2109, "*** could not get 'useSequence' -- nil iSource\n");
  return 0;
}

CFStringRef _CGImageReadCopyDebugDesc(_QWORD *a1)
{
  uint64_t v1;
  const __CFAllocator *v2;

  if (a1)
    v1 = a1[3];
  else
    v1 = 0;
  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CGImageReadRef %p>%s"), v1, "");
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<IIOBaseObject>>,0>(uint64_t a1)
{
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](a1 + 24);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

BOOL std::less<std::string>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

uint64_t *std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v11 = 0;
  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__find_equal<std::string>((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    memset(v10, 0, sizeof(v10));
    std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, v10);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

void std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, __int128 **a2@<X2>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  std::string *v7;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = operator new(0x48uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  v7 = (std::string *)(v6 + 4);
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    v6[6] = *((_QWORD *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_18802B550(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<IIOBaseObject>>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<imageio_key>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x5D1745D1745D175)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(44 * a2);
}

void lexerror(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v10;
  char *__s1[2];

  __s1[0] = 0;
  __s1[1] = &a9;
  vasprintf(__s1, a2, &a9);
  v10 = __s1[0];
  if (__s1[0])
  {
    if (a1)
    {
      if (!*(_QWORD *)(a1 + 16))
        *(_QWORD *)(a1 + 16) = strdup(__s1[0]);
    }
    free(v10);
  }
}

uint64_t yy_create_buffer(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  void *v8;

  v6 = malloc_type_malloc(0x40uLL, 0xB53DB697uLL);
  if (!v6
    || (v7 = (uint64_t)v6, v6[3] = a2,
                          v8 = malloc_type_malloc(a2 + 2, 0xB53DB697uLL),
                          (*(_QWORD *)(v7 + 8) = v8) == 0))
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s\n", "out of dynamic memory in yy_create_buffer()");
    exit(2);
  }
  *(_DWORD *)(v7 + 36) = 1;
  yy_init_buffer(v7, a1, a3);
  return v7;
}

int *yyrestart(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t buffer;
  uint64_t v7;
  int *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;

  v4 = *(_QWORD *)(a2 + 40);
  if (v4 && (v5 = *(_QWORD *)(a2 + 24), *(_QWORD *)(v4 + 8 * v5))
    || (yyensure_buffer_stack((_QWORD *)a2),
        buffer = yy_create_buffer(*(_QWORD *)(a2 + 8), 0x4000, a2),
        v5 = *(_QWORD *)(a2 + 24),
        *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v5) = buffer,
        (v4 = *(_QWORD *)(a2 + 40)) != 0))
  {
    v7 = *(_QWORD *)(v4 + 8 * v5);
  }
  else
  {
    v7 = 0;
  }
  result = yy_init_buffer(v7, a1, a2);
  v9 = *(_QWORD *)(a2 + 40);
  v10 = *(_QWORD *)(a2 + 24);
  v11 = *(_QWORD *)(v9 + 8 * v10);
  *(_DWORD *)(a2 + 52) = *(_DWORD *)(v11 + 32);
  v12 = *(_BYTE **)(v11 + 16);
  *(_QWORD *)(a2 + 64) = v12;
  *(_QWORD *)(a2 + 128) = v12;
  *(_QWORD *)(a2 + 8) = **(_QWORD **)(v9 + 8 * v10);
  *(_BYTE *)(a2 + 48) = *v12;
  return result;
}

int *yy_init_buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  int *result;

  v6 = *__error();
  yy_flush_buffer(a1, a3);
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 56) = 1;
  v7 = *(_QWORD *)(a3 + 40);
  if (v7)
    v7 = *(_QWORD *)(v7 + 8 * *(_QWORD *)(a3 + 24));
  if (v7 != a1)
    *(_QWORD *)(a1 + 48) = 1;
  *(_DWORD *)(a1 + 40) = 0;
  result = __error();
  *result = v6;
  return result;
}

uint64_t yy_flush_buffer(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  if (result)
  {
    *(_DWORD *)(result + 32) = 0;
    **(_BYTE **)(result + 8) = 0;
    *(_BYTE *)(*(_QWORD *)(result + 8) + 1) = 0;
    *(_QWORD *)(result + 16) = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 44) = 1;
    *(_DWORD *)(result + 60) = 0;
    v2 = *(_QWORD *)(a2 + 40);
    if (v2)
      v3 = *(_QWORD *)(v2 + 8 * *(_QWORD *)(a2 + 24));
    else
      v3 = 0;
    if (v3 == result)
    {
      v4 = *(_QWORD *)(a2 + 24);
      v5 = *(_QWORD *)(v2 + 8 * v4);
      *(_DWORD *)(a2 + 52) = *(_DWORD *)(v5 + 32);
      v6 = *(_BYTE **)(v5 + 16);
      *(_QWORD *)(a2 + 64) = v6;
      *(_QWORD *)(a2 + 128) = v6;
      *(_QWORD *)(a2 + 8) = **(_QWORD **)(v2 + 8 * v4);
      *(_BYTE *)(a2 + 48) = *v6;
    }
  }
  return result;
}

void yypop_buffer_state(uint64_t a1)
{
  uint64_t v1;
  void **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    v3 = *(void ***)(v1 + 8 * *(_QWORD *)(a1 + 24));
    if (v3)
    {
      yy_delete_buffer(v3, a1);
      v4 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v4) = 0;
      if (v4)
        *(_QWORD *)(a1 + 24) = --v4;
      v5 = *(_QWORD *)(a1 + 40);
      if (v5)
      {
        v6 = *(_QWORD *)(v5 + 8 * v4);
        if (v6)
        {
          *(_DWORD *)(a1 + 52) = *(_DWORD *)(v6 + 32);
          v7 = *(_BYTE **)(v6 + 16);
          *(_QWORD *)(a1 + 64) = v7;
          *(_QWORD *)(a1 + 128) = v7;
          *(_QWORD *)(a1 + 8) = **(_QWORD **)(v5 + 8 * v4);
          *(_BYTE *)(a1 + 48) = *v7;
          *(_DWORD *)(a1 + 80) = 1;
        }
      }
    }
  }
}

void GIFWritePlugin::GIFWritePlugin(GIFWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v3;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 9u);
  *(_QWORD *)v3 = &off_1E1BAE0D0;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 83) = 0u;
  *(_QWORD *)(v3 + 112) = 0;
  *(_QWORD *)(v3 + 120) = 0;
  *(_QWORD *)(v3 + 104) = 0;
  *(_BYTE *)(v3 + 128) = 0;
}

void GIFWritePlugin::~GIFWritePlugin(GIFWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

IIOImageWriteSession *GIFWritePlugin::gifWriteFunc(uint64_t a1, const void *a2, int a3)
{
  IIOImageWriteSession *result;

  result = *(IIOImageWriteSession **)(a1 + 88);
  if (result)
    return (IIOImageWriteSession *)IIOImageWriteSession::putBytes(result, a2, a3);
  return result;
}

BOOL GIFWritePlugin::colorMapEntriesAreEqual(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int16 *v8;
  __int16 v9;
  uint64_t v10;
  __int16 v12;
  char v13;
  __int16 v14;
  char v15;

  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
  {
    v5 = *(_QWORD *)(v4 + 16);
    v6 = 2 * a2;
  }
  else
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16);
    if (!v7)
      return 0;
    v5 = *(_QWORD *)(v7 + 16);
    v6 = 2 * a2;
  }
  v8 = (__int16 *)(v5 + v6 + a2);
  v9 = *v8;
  v15 = *((_BYTE *)v8 + 2);
  v14 = v9;
  v10 = *(_QWORD *)(a3 + 16) + 3 * a4;
  LOBYTE(v9) = *(_BYTE *)(v10 + 2);
  v12 = *(_WORD *)v10;
  v13 = v9;
  return RGBColorType::isCloseTo((unsigned __int8 *)&v14, (unsigned __int8 *)&v12);
}

const char *GIFWritePlugin::reduceFrame(const char *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, unint64_t *a7, unint64_t *a8, unint64_t *a9, uint64_t *a10)
{
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v17;
  int v18;
  double v19;
  double v20;
  double v21;
  unint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int v35;
  unint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v52;
  CGRect v53;

  v10 = *a9;
  v11 = *a10;
  if (*a9 >= 2)
    v12 = 2;
  else
    v12 = *a9;
  if (v11 >= 2)
    v13 = 2;
  else
    v13 = *a10;
  if (!result[97])
    return result;
  v17 = result;
  v43 = v12;
  v44 = v13;
  v18 = *((unsigned __int8 *)result + 96);
  v19 = (double)*a7;
  v47 = *a10;
  v20 = (double)v11;
  v21 = (double)*a8;
  v53.origin.x = v19;
  v53.origin.y = v21;
  v53.size.width = (double)v10;
  v53.size.height = (double)v11;
  result = (const char *)CGRectEqualToRect(v53, *(CGRect *)*((_QWORD *)result + 14));
  v22 = a9;
  if ((result & 1) == 0 && !v17[97])
    goto LABEL_42;
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    result = ImageIOLog("                    newRect: (%.0f, %.0f, %.0f, %.0f)\n", v19, v21, (double)v10, v20);
    v22 = a9;
  }
  v23 = v18 ? a2 : *(__int16 *)(*((_QWORD *)v17 + 5) + 6);
  if (v17[97])
  {
    v24 = *((_QWORD *)v17 + 7);
    v25 = *((_QWORD *)v17 + 11) * v10;
    v26 = a3 + v25 * (v24 - 1);
    a3 += v25 * v24;
  }
  else
  {
    v26 = **((_QWORD **)v17 + 13);
  }
  v27 = *a10;
  if (!*a10)
    goto LABEL_42;
  v49 = (uint64_t)v17;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = v10 - 1;
  v33 = *v22;
  v34 = v47 - 1;
  v35 = a4;
  v48 = v10;
  do
  {
    if (!v33)
      goto LABEL_39;
    v36 = 0;
    do
    {
      v37 = *(unsigned __int8 *)(a3 + v36);
      if ((_DWORD)a6)
      {
        v38 = *(unsigned __int8 *)(v26 + v36);
        if (v35)
        {
          v52 = v34;
          v39 = a6;
          v40 = v23;
          v41 = v26;
          result = (const char *)GIFWritePlugin::colorMapEntriesAreEqual(v49, v38, a5, v37);
          v22 = a9;
          v34 = v52;
          v26 = v41;
          v23 = v40;
          a6 = v39;
          v35 = a4;
          if ((result & 1) != 0)
            goto LABEL_35;
        }
        else if (v37 == v38)
        {
          goto LABEL_35;
        }
      }
      else if ((_DWORD)v23 == v37)
      {
        goto LABEL_35;
      }
      ++v31;
      if (v36 < v32)
        v32 = v36;
      if (v36 > v29)
        v29 = v36;
      if (v28 < v34)
        v34 = v28;
      if (v28 > v30)
        v30 = v28;
LABEL_35:
      ++v36;
      v33 = *v22;
    }
    while (v36 < *v22);
    v10 = v48;
    v27 = *a10;
LABEL_39:
    ++v28;
    a3 += v10;
    v26 += v10;
  }
  while (v28 < v27);
  if (v31)
  {
    *a7 = v32;
    *a8 = v34;
    *v22 = v29 - v32 + 1;
    v42 = v30 - v34 + 1;
    goto LABEL_43;
  }
LABEL_42:
  *a7 = v10 >> 1;
  *a8 = v47 >> 1;
  v42 = v44;
  *v22 = v43;
LABEL_43:
  *a10 = v42;
  return result;
}

uint64_t GIFWritePlugin::getDelayTime(GIFWritePlugin *this, const __CFDictionary *a2)
{
  const __CFString *v2;
  unsigned int v3;
  double DoubleForKey;
  unsigned int v5;
  uint64_t v6;
  _QWORD v8[3];

  if (!a2)
    return 0;
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  v2 = CFSTR("UnclampedDelayTime");
  if ((IIODictionary::containsKey((IIODictionary *)v8, CFSTR("UnclampedDelayTime")) & 1) != 0
    || (v2 = CFSTR("DelayTime"),
        v3 = IIODictionary::containsKey((IIODictionary *)v8, CFSTR("DelayTime")),
        DoubleForKey = 0.0,
        v3))
  {
    DoubleForKey = IIODictionary::getDoubleForKey((IIODictionary *)v8, v2);
  }
  v5 = vcvtmd_u64_f64(DoubleForKey * 100.0 + 0.5);
  if (DoubleForKey <= 0.0)
    v6 = 0;
  else
    v6 = v5;
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return v6;
}

void sub_18802BDA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t GIFWritePlugin::writeOneImage(GIFWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

unint64_t GIFWritePlugin::writeSingleFrame(GIFWritePlugin *this)
{
  IIOImagePixelDataProvider *PixelDataProviderAtIndex;
  IIODictionary *PropertiesAtIndex;
  size_t v4;
  size_t v5;
  unint64_t v6;
  const char *v7;
  CGColorSpace *SourceGeomColorSpace;
  CGColorSpaceModel Model;
  CGColorSpaceModel v10;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v12;
  const __CFData *Value;
  const __CFData *v14;
  CFTypeID v15;
  int Length;
  int v17;
  int v18;
  int v20;
  UInt8 *v21;
  int v22;
  int v23;
  BOOL v24;
  unint64_t v25;
  unsigned int Error;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  CGColorSpace *v30;
  uint64_t v31;
  size_t v32;
  CGColorSpace *v33;
  void *v34;
  void *v35;
  CGContext *v36;
  CGContext *v37;
  IIOImageSource *v38;
  CGImage *Ref;
  const __CFDictionary *v40;
  unsigned __int8 v41;
  int v42;
  CGColorSpace *v43;
  int v44;
  unsigned __int8 v45;
  int v46;
  uint64_t v47;
  unsigned __int8 v48;
  int v49;
  uint64_t v50;
  int v51;
  unsigned __int8 v52;
  int v53;
  uint64_t v54;
  int v55;
  GIFWritePlugin *v56;
  __int16 DelayTime;
  _BOOL4 v58;
  unsigned int Uint32ForKeyGroup;
  unsigned int v60;
  uint64_t *v61;
  __int16 v62;
  int v63;
  int v64;
  char v65;
  BOOL v66;
  char v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  _BOOL4 v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  int *v75;
  int v76;
  int v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  int v82;
  void **v83;
  _QWORD *v84;
  double v85;
  double v86;
  uint64_t v87;
  IIODictionary *ContainerProperties;
  int v90;
  const __CFDictionary *v91;
  CGColorSpace *v92;
  CGColorSpace *space;
  int Type;
  _BYTE *v95;
  vImage_Buffer dest;
  uint64_t v97;
  _QWORD v98[2];
  UInt8 *buffer;
  unint64_t v100;
  size_t v101;
  unsigned int v102;
  unint64_t v103;
  unint64_t v104;
  _BYTE v105[768];
  uint64_t v106;
  CFRange v107;
  CGRect v108;
  CGRect v109;
  CGRect v110;

  v106 = *MEMORY[0x1E0C80C00];
  v90 = *((unsigned __int8 *)this + 98);
  v103 = 0;
  v104 = 0;
  v102 = 0;
  bzero(v105, 0x300uLL);
  v98[0] = 0;
  v98[1] = 0;
  buffer = v105;
  PixelDataProviderAtIndex = (IIOImagePixelDataProvider *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, *((_QWORD *)this + 7));
  PropertiesAtIndex = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex((IIOImageDestination **)this, *((_QWORD *)this + 7));
  ContainerProperties = (IIODictionary *)IIOWritePlugin::getContainerProperties((IIOImagePlus **)this);
  *((_BYTE *)this + 96) = IIOImagePixelDataProvider::getAlphaInfo(PixelDataProviderAtIndex) - 3 < 2;
  v4 = IIOImageSource::count(PixelDataProviderAtIndex);
  v101 = v4;
  v5 = IIO_Reader::testHeaderSize(PixelDataProviderAtIndex);
  v95 = 0;
  v100 = v5;
  v6 = 4294967246;
  *((_QWORD *)this + 8) = v4;
  *((_QWORD *)this + 9) = v5;
  v7 = "no";
  if (v5)
  {
    if (v4)
    {
      SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
      Type = CGColorSpaceGetType();
      Model = CGColorSpaceGetModel(SourceGeomColorSpace);
      v10 = Model;
      v95 = 0;
      if (Model <= kCGColorSpaceModelIndexed && ((1 << Model) & 0x23) != 0)
      {
        if (_cg_GifLastError((uint64_t)PixelDataProviderAtIndex) - 9 < 0xFFFFFFF8)
        {
          v95 = 0;
          goto LABEL_121;
        }
        ObjectForKey = IIODictionary::getObjectForKey(PropertiesAtIndex, CFSTR("{GIF}"));
        v12 = ObjectForKey;
        if (ObjectForKey)
        {
          Value = (const __CFData *)CFDictionaryGetValue(ObjectForKey, CFSTR("ImageColorMap"));
          v14 = Value;
          if (Value)
          {
            v15 = CFGetTypeID(Value);
            if (v15 == CFDataGetTypeID())
            {
              Length = CFDataGetLength(v14);
              if (Length <= 770)
                v17 = Length / 3;
              else
                v17 = 256;
              v18 = *((unsigned __int8 *)this + 96);
              if (v17 > 255 && v18 != 0)
                v17 = 255;
              LODWORD(v98[0]) = v17;
              if (v17 >= 1)
              {
                v107.length = 3 * v17;
                v107.location = 0;
                CFDataGetBytes(v14, v107, buffer);
                v18 = *((unsigned __int8 *)this + 96);
              }
              if (v18)
              {
                v20 = v98[0];
                v21 = &buffer[3 * SLODWORD(v98[0])];
                *(_WORD *)v21 = 0;
                v21[2] = 0;
                v22 = v20 + 1;
                LODWORD(v98[0]) = v20 + 1;
              }
              else
              {
                v22 = v98[0];
              }
              v23 = v22 - 1;
              if (v22 != 1)
              {
                v22 = 0;
                do
                {
                  ++v22;
                  v24 = v23 > 1;
                  v23 >>= 1;
                }
                while (v24);
              }
              HIDWORD(v98[0]) = v22;
            }
          }
        }
        v95 = malloc_type_malloc(v5 * v4, 0x8BDC4AEAuLL);
        if (!v95)
        {
          v95 = 0;
          goto LABEL_73;
        }
        v97 = 0;
        ColorQuantization::ColorQuantization((ColorQuantization *)&v97);
        v25 = IIOImagePlus::sourceImageProvider(PixelDataProviderAtIndex);
        Error = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
        v92 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
        space = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
        v91 = v12;
        v27 = IIOImagePixelDataProvider::getBitmapInfo(PixelDataProviderAtIndex) & 0x1F;
        if (v27 == 3)
        {
          v28 = 1;
        }
        else if (v27 == 4)
        {
          v28 = 2;
        }
        else if (v27)
        {
          v28 = v27;
        }
        else
        {
          v28 = 5;
        }
        v29 = 2 * v4;
        if (v10)
          v29 = v25;
        v30 = space;
        if (v10)
          v30 = 0;
        if (v25 <= 3 * v4)
          v31 = 4 * v4;
        else
          v31 = v25;
        if (v10 == kCGColorSpaceModelRGB)
          v32 = v31;
        else
          v32 = v29;
        if (v10 == kCGColorSpaceModelRGB)
          v33 = v92;
        else
          v33 = v30;
        v34 = malloc_type_calloc(v5, v32, 0x58370F57uLL);
        v35 = v34;
        if (!v34)
        {
          v51 = 4;
          v40 = v91;
          goto LABEL_72;
        }
        if (Type != 7)
        {
          v36 = CGBitmapContextCreate(v34, v4, v5, Error, v32, v33, v28);
          v37 = v36;
          if (v36)
          {
            v108.origin.x = 0.0;
            v108.origin.y = 0.0;
            v108.size.width = (double)v4;
            v108.size.height = (double)v5;
            CGContextClearRect(v36, v108);
            v38 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, *((_QWORD *)this + 7));
            Ref = (CGImage *)IIOImageSource::imageReadRef(v38);
            v109.origin.x = 0.0;
            v109.origin.y = 0.0;
            v109.size.width = (double)v4;
            v109.size.height = (double)v5;
            CGContextDrawImage(v37, v109, Ref);
            v110.origin.x = 0.0;
            v110.origin.y = 0.0;
            v110.size.width = (double)v4;
            v110.size.height = (double)v5;
            CGRectOffset(v110, 0.0, (double)v5);
            CGContextRelease(v37);
LABEL_53:
            dest.data = v35;
            dest.height = v5;
            dest.width = v4;
            dest.rowBytes = v32;
            v40 = v91;
            if (v10 == kCGColorSpaceModelRGB)
            {
              if ((_DWORD)v28 == 2)
              {
                vImageUnpremultiplyData_ARGB8888(&dest, &dest, 0x10u);
              }
              else if ((_DWORD)v28 == 1)
              {
                vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
              }
            }
            if (Type == 7)
            {
              if (!Ref)
                Ref = (CGImage *)IIOImageSource::imageReadRef(PixelDataProviderAtIndex);
              v41 = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
              v42 = *((unsigned __int8 *)this + 96);
              v43 = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
              v44 = ColorQuantization::generateFromIndexedImage((int)&v97, (uint64_t)&dest, Ref, v41, v28, v42 != 0, v43, (uint64_t)v98, v95, &v102);
            }
            else if (v10)
            {
              if (v10 != kCGColorSpaceModelRGB)
              {
                free(v35);
                v51 = 4;
                goto LABEL_72;
              }
              if (LODWORD(v98[0]))
              {
                v45 = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
                v46 = *((unsigned __int8 *)this + 96);
                v47 = IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
                v44 = ColorQuantization::generateFromRGBImage((uint64_t)&v97, (uint64_t)&dest, v45, v28, v46 != 0, v47, (uint64_t)v98, v95, (int *)&v102);
              }
              else
              {
                v52 = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
                v53 = *((unsigned __int8 *)this + 96);
                v54 = IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
                v44 = ColorQuantization::generateFromRGBImageWu((uint64_t)&v97, (uint64_t)&dest, v52, v28, v53 != 0, v54, (uint64_t)v98, (uint64_t)v95, &v102);
              }
            }
            else
            {
              v48 = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
              v49 = *((unsigned __int8 *)this + 96);
              v50 = IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
              v44 = ColorQuantization::generateFromGrayImage((uint64_t)&v97, (uint64_t)&dest, v48, v28, v49 != 0, v50, (uint64_t)v98, v95, &v102);
            }
            v55 = v44;
            free(v35);
            if (v55)
              v51 = 0;
            else
              v51 = 4;
LABEL_72:
            CGColorSpaceRelease(space);
            CGColorSpaceRelease(v92);
            ColorQuantization::~ColorQuantization((ColorQuantization *)&v97);
            if (v51)
            {
LABEL_73:
              v6 = 4294967246;
              v7 = "no";
              goto LABEL_121;
            }
            DelayTime = GIFWritePlugin::getDelayTime(v56, v40);
            v58 = v90 != 0;
            if (!*((_QWORD *)this + 7))
            {
              if (_cg_EGifPutScreenDesc(*((_QWORD *)this + 5), v101, v100, SHIDWORD(v98[0]), 0, (int *)v98) != 1)
              {
                _cg_jpeg_mem_term("writeSingleFrame", 840, "*** EGifPutScreenDesc failed\n");
                goto LABEL_73;
              }
              if (*((_QWORD *)this + 7)
                || !IIODictionary::containsKeyGroup(ContainerProperties, CFSTR("LoopCount"), CFSTR("{GIF}")))
              {
                goto LABEL_84;
              }
              Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(ContainerProperties, CFSTR("LoopCount"), CFSTR("{GIF}"));
              v58 = 0;
              v60 = Uint32ForKeyGroup << 16;
              if ((int)(Uint32ForKeyGroup << 16) >= -65535 && v60 != 0x10000)
              {
                v61 = (uint64_t *)((char *)this + 40);
                _cg_EGifPutExtensionLeader(*((_QWORD *)this + 5), 255);
                _cg_EGifPutExtensionBlock(*((_QWORD *)this + 5), 11, "NETSCAPE2.0");
                v62 = Uint32ForKeyGroup - 1;
                if (v60 <= 0x10000)
                  v62 = Uint32ForKeyGroup;
                LOBYTE(dest.data) = 1;
                BYTE1(dest.data) = v62;
                v63 = v62;
                BYTE2(dest.data) = (unsigned __int16)(v62 + (v62 >> 23)) >> 8;
                _cg_EGifPutExtensionBlock(*v61, 3, &dest);
                _cg_EGifPutExtensionTrailer(*v61);
                if ((gIIODebugFlags & 0x30000) != 0)
                  ImageIOLog("                 loop count: %d\n", v63);
LABEL_84:
                v58 = 0;
              }
            }
            v64 = *((unsigned __int8 *)this + 96);
            *(_WORD *)((char *)&dest.data + 1) = DelayTime;
            v65 = v102;
            v66 = v64 == 0;
            if (!v64)
              v65 = 0;
            BYTE3(dest.data) = v65;
            v67 = v64 | 8;
            if (v66)
              v67 = 4;
            LOBYTE(dest.data) = v67;
            v7 = "no";
            if (_cg_EGifPutExtension(*((_QWORD *)this + 5), 249, 4, &dest) != 1)
            {
LABEL_119:
              v6 = 4294967246;
              goto LABEL_121;
            }
            v68 = *((_QWORD *)this + 7);
            if (v58)
            {
              v69 = *((_QWORD *)this + 5);
              if (!v68)
              {
                v73 = v103;
                v72 = v104;
                v6 = v100;
                v74 = v101;
                v71 = 1;
                goto LABEL_104;
              }
              v70 = *(_QWORD **)(v69 + 16);
              if (v70)
              {
                v71 = !RGBColorMap::equalTo(v98, v70);
                if (!*((_QWORD *)this + 7))
                {
LABEL_96:
                  v69 = *((_QWORD *)this + 5);
                  v73 = v103;
                  v72 = v104;
                  v6 = v100;
                  v74 = v101;
                  if (!v71)
                  {
LABEL_105:
                    v75 = 0;
                    goto LABEL_106;
                  }
LABEL_104:
                  v75 = (int *)v98;
LABEL_106:
                  _cg_EGifPutImageDesc(v69, v72, v73, v74, v6, 0, v75);
                  v77 = v76;
                  if ((gIIODebugFlags & 0x30000) != 0)
                  {
                    ImageIOLog("      optimized image frame: (%d, %d, %d, %d)\n", v72, v73, v74, v6);
                    if ((gIIODebugFlags & 0x30000) != 0)
                    {
                      v78 = "yes";
                      if (!v71)
                        v78 = "no";
                      ImageIOLog("         writeImageColorMap: %s\n", v78);
                    }
                  }
                  if (v77 == 1)
                  {
                    if (v73 >= v6 + v73)
                    {
                      v6 = 0;
                      v7 = "yes";
                      goto LABEL_121;
                    }
                    v79 = *((_QWORD *)this + 8);
                    v80 = **((_QWORD **)this + 13);
                    v81 = v72 + v79 * v73;
                    while (_cg_EGifPutLine(*((_QWORD *)this + 5), &v95[v81], v74) == 1)
                    {
                      if (**((_QWORD **)this + 13))
                        bzero((void *)(v80 + v81), v74);
                      v81 += v79;
                      if (!--v6)
                      {
                        v7 = "yes";
                        goto LABEL_121;
                      }
                    }
                  }
                  goto LABEL_119;
                }
              }
              else
              {
                v71 = 1;
              }
            }
            else
            {
              v71 = 0;
              if (!v68)
                goto LABEL_96;
            }
            *((_BYTE *)this + 97) = 0;
            if (*((_BYTE *)this + 96))
              GIFWritePlugin::reduceFrame((const char *)this, v102, (uint64_t)v95, v71, (uint64_t)v98, 0, &v104, &v103, &v101, (uint64_t *)&v100);
            else
              GIFWritePlugin::reduceFrame((const char *)this, v102, (uint64_t)v95, v71, (uint64_t)v98, 1, &v104, &v103, &v101, (uint64_t *)&v100);
            v69 = *((_QWORD *)this + 5);
            v73 = v103;
            v72 = v104;
            v6 = v100;
            v74 = v101;
            if (!v71)
              goto LABEL_105;
            goto LABEL_104;
          }
          _cg_jpeg_mem_term("writeSingleFrame", 708, "*** ERROR: CGBitmapContextCreate returned NULL\n");
        }
        Ref = 0;
        goto LABEL_53;
      }
    }
  }
LABEL_121:
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("           gifWrite-success: %s\n", v7);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      v82 = _cg_GifLastError(*((_QWORD *)this + 5));
      ImageIOLog("               GifLastError: %d\n\n", v82);
    }
  }
  if (v95)
  {
    v83 = (void **)*((_QWORD *)this + 15);
    if (v83)
    {
      _cg_GifFreeMapObject(v83);
      *((_QWORD *)this + 15) = _cg_GifMakeMapObject(v98[0], (char *)buffer);
    }
    v84 = (_QWORD *)*((_QWORD *)this + 13);
    if (*v84)
    {
      free(v95);
    }
    else
    {
      *v84 = v95;
      v85 = (double)v101;
      v86 = (double)v100;
      v87 = *((_QWORD *)this + 14);
      *(_QWORD *)v87 = 0;
      *(_QWORD *)(v87 + 8) = 0;
      *(double *)(v87 + 16) = v85;
      *(double *)(v87 + 24) = v86;
    }
  }
  return v6;
}

void sub_18802C848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, CGColorSpaceRef a18, CGColorSpaceRef space, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  CGColorSpaceRelease(space);
  CGColorSpaceRelease(a18);
  ColorQuantization::~ColorQuantization((ColorQuantization *)&a26);
  _Unwind_Resume(a1);
}

uint64_t GIFWritePlugin::writeAllFramesWithGlobalColorMap(GIFWritePlugin *this)
{
  IIOImageSource *PixelDataProviderAtIndex;
  CGImage *Ref;
  size_t v4;
  CGImageAlphaInfo AlphaInfo;
  char v6;
  uint64_t v7;
  void *v8;
  int v9;
  CGContext *v10;
  CGContext *v11;
  double v12;
  unint64_t v13;
  unint64_t v14;
  CGFloat x;
  uint64_t v16;
  CGFloat y;
  double height;
  IIOImageSource *v19;
  CGImage *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  char *v24;
  char *v25;
  vImagePixelCount v26;
  char *v27;
  void *v28;
  unint64_t v29;
  IIODictionary *PropertiesAtIndex;
  GIFWritePlugin *ObjectForKey;
  __int16 DelayTime;
  unsigned int Uint32ForKeyGroup;
  unsigned int v34;
  __int16 v35;
  int v36;
  int v37;
  char v38;
  int v39;
  char v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  char *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  BOOL v54;
  unint64_t v55;
  char *v56;
  unsigned __int8 *v57;
  int v58;
  unsigned __int8 *v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  const char *v63;
  int Error;
  const char *v66;
  CGColorSpace *space;
  void *data;
  unint64_t v69;
  IIODictionary *ContainerProperties;
  char *v71;
  unsigned int v72;
  unsigned int v73;
  unint64_t width;
  uint64_t v75;
  unint64_t v76;
  vImage_Buffer dest;
  unint64_t v78;
  _QWORD v79[3];
  unsigned int v80;
  _BYTE v81[768];
  uint64_t v82;
  CGRect v83;
  CGRect v84;
  CGRect v85;
  CGRect v86;

  v82 = *MEMORY[0x1E0C80C00];
  v80 = 0;
  bzero(v81, 0x300uLL);
  v79[0] = 0;
  v79[1] = 0;
  v79[2] = v81;
  space = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  PixelDataProviderAtIndex = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
  ContainerProperties = (IIODictionary *)IIOWritePlugin::getContainerProperties((IIOImagePlus **)this);
  Ref = (CGImage *)IIOImageSource::imageReadRef(PixelDataProviderAtIndex);
  v69 = *((_QWORD *)this + 11);
  v4 = *((_QWORD *)this + 6) * v69;
  width = *((_QWORD *)this + 10);
  data = malloc_type_calloc(v4 * 4 * width, 1uLL, 0x850FADA5uLL);
  if (!data)
  {
    v28 = 0;
    v71 = 0;
    goto LABEL_114;
  }
  AlphaInfo = CGImageGetAlphaInfo(Ref);
  if (*((_QWORD *)this + 6) == 1)
  {
    v6 = 0;
    v7 = 5;
    v8 = data;
    v9 = 0;
    switch(AlphaInfo)
    {
      case kCGImageAlphaPremultipliedLast:
      case kCGImageAlphaLast:
        goto LABEL_8;
      case kCGImageAlphaPremultipliedFirst:
      case kCGImageAlphaFirst:
        v9 = 0;
        v7 = 2;
        v6 = 1;
        break;
      case kCGImageAlphaNoneSkipLast:
        break;
      case kCGImageAlphaNoneSkipFirst:
        v6 = 0;
        v9 = 0;
        v7 = 6;
        break;
      default:
        v9 = 0;
        break;
    }
  }
  else
  {
    v8 = data;
    if (AlphaInfo <= kCGImageAlphaNoneSkipFirst && (v6 = 1, ((1 << AlphaInfo) & 0x54) != 0))
    {
      v9 = 0;
      v7 = 2;
    }
    else
    {
LABEL_8:
      v6 = 1;
      v9 = 1;
      v7 = 1;
    }
  }
  *((_BYTE *)this + 96) = v6;
  v10 = CGBitmapContextCreate(v8, width, v4, 8uLL, 4 * width, space, v7);
  v11 = v10;
  if (v10)
  {
    v12 = (double)width;
    v83.size.height = (double)v4;
    v83.origin.x = 0.0;
    v83.origin.y = 0.0;
    v83.size.width = (double)width;
    CGContextClearRect(v10, v83);
    v72 = v7;
    v13 = *((_QWORD *)this + 6);
    if (v13)
    {
      v14 = 0;
      x = 0.0;
      v16 = -1;
      y = 0.0;
      height = (double)v69;
      do
      {
        v19 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v13 + v16);
        v20 = (CGImage *)IIOImageSource::imageReadRef(v19);
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("drawing image %d\n", v14);
        v84.origin.x = x;
        v84.origin.y = y;
        v84.size.width = v12;
        v84.size.height = height;
        CGContextDrawImage(v11, v84, v20);
        v85.origin.x = x;
        v85.origin.y = y;
        v85.size.width = v12;
        v85.size.height = height;
        v86 = CGRectOffset(v85, 0.0, (double)v69);
        x = v86.origin.x;
        y = v86.origin.y;
        v12 = v86.size.width;
        height = v86.size.height;
        ++v14;
        v13 = *((_QWORD *)this + 6);
        --v16;
      }
      while (v14 < v13);
    }
    CGContextRelease(v11);
    v7 = v72;
  }
  else
  {
    _cg_jpeg_mem_term("writeAllFramesWithGlobalColorMap", 1148, "*** ERROR: CGBitmapContextCreate returned NULL\n");
  }
  v78 = 0;
  ColorQuantization::ColorQuantization((ColorQuantization *)&v78);
  dest.data = data;
  dest.height = v4;
  dest.width = width;
  dest.rowBytes = 4 * width;
  if (*((_BYTE *)this + 96))
  {
    if (v9)
    {
      vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0);
      v21 = 3;
    }
    else
    {
      vImageUnpremultiplyData_ARGB8888(&dest, &dest, 0);
      v21 = 0;
    }
    if (dest.height)
    {
      v23 = 0;
      v24 = (char *)dest.data + v21;
      LOBYTE(v21) = 1;
      do
      {
        if (dest.width)
        {
          v25 = &v24[dest.rowBytes * v23];
          v26 = dest.width;
          while (*v25 == 255)
          {
            v25 += 4;
            if (!--v26)
              goto LABEL_32;
          }
          LOBYTE(v21) = 0;
        }
LABEL_32:
        ++v23;
      }
      while (v23 != dest.height);
    }
    else
    {
      LOBYTE(v21) = 1;
    }
    v22 = v21;
  }
  else
  {
    v22 = 1;
  }
  v73 = v22;
  *((_QWORD *)this + 8) = width;
  *((_QWORD *)this + 9) = v4;
  v27 = (char *)malloc_type_malloc(width + width * v4, 0xF8665CA5uLL);
  v71 = v27;
  if (!v27
    || (ColorQuantization::generateFromRGBImageWu((uint64_t)&v78, (uint64_t)&dest, 8, v7, *((unsigned __int8 *)this + 96), (uint64_t)space, (uint64_t)v79, (uint64_t)v27, &v80) & 1) == 0)
  {
    ColorQuantization::~ColorQuantization((ColorQuantization *)&v78);
    v28 = 0;
LABEL_114:
    v62 = 4294967246;
    v63 = "no";
    goto LABEL_99;
  }
  ColorQuantization::~ColorQuantization((ColorQuantization *)&v78);
  v28 = malloc_type_malloc(width, 0x1E637333uLL);
  *((_QWORD *)this + 9) = v69;
  *((_QWORD *)this + 7) = 0;
  if (!*((_QWORD *)this + 6))
  {
LABEL_98:
    v62 = 0;
    v63 = "yes";
LABEL_99:
    v66 = v63;
    goto LABEL_102;
  }
  v29 = 0;
  v66 = "no";
  while (1)
  {
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      ImageIOLog("####################################################################\n", v29);
      v29 = *((_QWORD *)this + 7);
    }
    PropertiesAtIndex = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex((IIOImageDestination **)this, v29);
    ObjectForKey = IIODictionary::getObjectForKey(PropertiesAtIndex, CFSTR("{GIF}"));
    DelayTime = GIFWritePlugin::getDelayTime(ObjectForKey, ObjectForKey);
    if (!*((_QWORD *)this + 7))
    {
      if (_cg_EGifPutScreenDesc(*((_QWORD *)this + 5), width, v69, SHIDWORD(v79[0]), 0, (int *)v79) != 1)
        goto LABEL_100;
      if (IIODictionary::containsKeyGroup(ContainerProperties, CFSTR("LoopCount"), CFSTR("{GIF}")))
      {
        Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(ContainerProperties, CFSTR("LoopCount"), CFSTR("{GIF}"));
        v34 = Uint32ForKeyGroup << 16;
        if ((int)(Uint32ForKeyGroup << 16) >= -65535 && v34 != 0x10000)
        {
          _cg_EGifPutExtensionLeader(*((_QWORD *)this + 5), 255);
          _cg_EGifPutExtensionBlock(*((_QWORD *)this + 5), 11, "NETSCAPE2.0");
          v35 = Uint32ForKeyGroup - 1;
          if (v34 <= 0x10000)
            v35 = Uint32ForKeyGroup;
          LOBYTE(dest.data) = 1;
          v36 = v35;
          BYTE1(dest.data) = v35;
          BYTE2(dest.data) = (unsigned __int16)(v35 + (v35 >> 23)) >> 8;
          _cg_EGifPutExtensionBlock(*((_QWORD *)this + 5), 3, &dest);
          _cg_EGifPutExtensionTrailer(*((_QWORD *)this + 5));
          if ((gIIODebugFlags & 0x30000) != 0)
            ImageIOLog("                 loop count: %d\n", v36);
        }
      }
    }
    v37 = *((unsigned __int8 *)this + 96);
    *(_WORD *)((char *)&dest.data + 1) = DelayTime;
    v38 = v80;
    if (!v37)
      v38 = 0;
    BYTE3(dest.data) = v38;
    if (v37)
      v39 = v73;
    else
      v39 = 1;
    if (v39)
      v40 = 4;
    else
      v40 = 8;
    LOBYTE(dest.data) = v40 | v37;
    if (_cg_EGifPutExtension(*((_QWORD *)this + 5), 249, 4, &dest) != 1)
    {
LABEL_100:
      v62 = 4294967246;
      goto LABEL_102;
    }
    v78 = 0;
    v76 = width;
    dest.data = 0;
    v75 = *((_QWORD *)this + 11);
    *((_BYTE *)this + 97) = 1;
    if (*((_QWORD *)this + 7))
    {
      if (*((_BYTE *)this + 96))
        v41 = v73;
      else
        v41 = 1;
      GIFWritePlugin::reduceFrame((const char *)this, v80, (uint64_t)v71, 0, (uint64_t)v79, v41, &v78, (unint64_t *)&dest, &v76, &v75);
    }
    v42 = v78;
    v43 = v76;
    v44 = (unint64_t)dest.data;
    v45 = v75;
    _cg_EGifPutImageDesc(*((_QWORD *)this + 5), v78, (__int16)dest.data, v76, v75, 0, 0);
    v47 = v46;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("      optimized image frame: (%d, %d, %d, %d)\n", v42, v44, v43, v45);
    if (v47 != 1)
      break;
    if (v43 + v42 > width)
    {
      v43 = width - v42;
      v76 = width - v42;
    }
    v48 = (char *)(v45 + v44);
    v49 = *((_QWORD *)this + 11);
    if (v45 + v44 > v49)
    {
      v43 = v49 - v44;
      v76 = v49 - v44;
    }
    if (v44 < (unint64_t)v48)
    {
      v50 = *((_QWORD *)this + 7);
      v51 = *((_QWORD *)this + 8);
      v52 = v42 + v51 * v44;
      v53 = (char *)(**((_QWORD **)this + 13) + v52);
      if (v50)
        v54 = *((_BYTE *)this + 97) == 0;
      else
        v54 = 1;
      v55 = v51 * v49;
      if (v54)
        v56 = 0;
      else
        v56 = &v71[(v50 - 1) * v55 + v52];
      v57 = (unsigned __int8 *)&v71[v50 * v55 + v52];
      do
      {
        if (v56)
          v58 = v39;
        else
          v58 = 0;
        v59 = v57;
        if (v58 == 1)
        {
          memcpy(v28, v57, v43);
          v59 = (unsigned __int8 *)v28;
          if (v43)
          {
            v60 = 0;
            do
            {
              if (v57[v60] == v56[v60])
                *((_BYTE *)v28 + v60) = v80;
              ++v60;
            }
            while (v43 > v60);
            v59 = (unsigned __int8 *)v28;
          }
        }
        if (_cg_EGifPutLine(*((_QWORD *)this + 5), v59, v43) != 1)
          goto LABEL_101;
        if (**((_QWORD **)this + 13))
          bzero(v53, v43);
        if (v56)
          v56 += v51;
        else
          v56 = 0;
        ++v44;
        v57 += v51;
        v53 += v51;
      }
      while ((char *)v44 != v48);
    }
    v61 = *((_QWORD *)this + 6);
    v29 = *((_QWORD *)this + 7) + 1;
    *((_QWORD *)this + 7) = v29;
    if (v29 >= v61)
      goto LABEL_98;
  }
LABEL_101:
  v62 = 4294967246;
  v66 = "no";
LABEL_102:
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("           gifWrite-success: %s\n", v66);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      Error = _cg_GifLastError(*((_QWORD *)this + 5));
      ImageIOLog("               GifLastError: %d\n\n", Error);
    }
  }
  if (data)
    free(data);
  if (v71)
    free(v71);
  if (v28)
    free(v28);
  CGColorSpaceRelease(space);
  return v62;
}

void sub_18802D164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, CGColorSpaceRef space, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  ColorQuantization::~ColorQuantization((ColorQuantization *)&a30);
  CGColorSpaceRelease(space);
  _Unwind_Resume(a1);
}

uint64_t GIFWritePlugin::writeAll(GIFWritePlugin *this)
{
  unsigned int ImageCount;
  unsigned int v3;
  _OWORD *v4;
  unint64_t v5;
  _BOOL4 v6;
  uint64_t PixelDataProviderAtIndex;
  uint64_t v8;
  BOOL v9;
  int v10;
  int v11;
  CFIndex v12;
  uint64_t v13;
  IIO_Reader *v14;
  IIO_Reader *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  IIO_Reader *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t Size;
  unint64_t v24;
  const char *v25;
  int Error;
  int v28;
  _OWORD v29[2];
  void *v30;

  v30 = 0;
  memset(v29, 0, sizeof(v29));
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    GIFWritePlugin::writeAll - [%p]\n", this);
  v28 = 0;
  ImageCount = IIOWritePlugin::getImageCount((IIOImageDestination **)this);
  if (!ImageCount)
  {
    v4 = 0;
    goto LABEL_56;
  }
  v3 = ImageCount;
  v4 = _cg_EGifOpen(*((_QWORD *)this + 2), (uint64_t)GIFWritePlugin::gifWriteFunc, &v28);
  if (!v4)
  {
LABEL_56:
    v22 = 4294967246;
    goto LABEL_45;
  }
  v5 = v3;
  v6 = v3 > 1;
  if (v3 < 2)
  {
    v10 = 0;
    goto LABEL_16;
  }
  PixelDataProviderAtIndex = IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
  v8 = IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v5 - 1);
  if (PixelDataProviderAtIndex)
    v9 = 1;
  else
    v9 = v8 == 0;
  v10 = !v9;
  if (v9)
  {
LABEL_16:
    v12 = 0;
    if (v5 <= 1)
      v13 = 1;
    else
      v13 = v5;
    do
    {
      v14 = (IIO_Reader *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v12);
      if (!v14)
      {
        _cg_jpeg_mem_term("writeAll", 1516, "*** Failed to get pixelDataProvider for index %d\n", v12);
        goto LABEL_56;
      }
      v15 = v14;
      v16 = *((_QWORD *)this + 11);
      if (v16 <= IIO_Reader::testHeaderSize(v14))
        v17 = IIO_Reader::testHeaderSize(v15);
      else
        v17 = *((_QWORD *)this + 11);
      *((_QWORD *)this + 11) = v17;
      v18 = *((_QWORD *)this + 10);
      if (v18 <= IIOImageSource::count(v15))
        v19 = IIOImageSource::count(v15);
      else
        v19 = *((_QWORD *)this + 10);
      *((_QWORD *)this + 10) = v19;
      ++v12;
    }
    while (v13 != v12);
    if (v19 && *((_QWORD *)this + 11))
    {
      v11 = 0;
      goto LABEL_30;
    }
    goto LABEL_56;
  }
  v10 = 1;
  v6 = 1;
  v11 = 1;
  if (*((_QWORD *)this + 10))
  {
LABEL_30:
    if (*((_QWORD *)this + 11))
      goto LABEL_32;
  }
  v20 = (IIO_Reader *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v5 - 1);
  *((_QWORD *)this + 11) = IIO_Reader::testHeaderSize(v20);
  *((_QWORD *)this + 10) = IIOImageSource::count(v20);
LABEL_32:
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("_CGImagePluginWriteGIF - imageCount: %ld\n", v5);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                           max size: %ld * %ld\n", *((_QWORD *)this + 10), *((_QWORD *)this + 11));
  }
  *((_QWORD *)this + 5) = v4;
  *((_QWORD *)this + 6) = v5;
  *((_QWORD *)this + 13) = &v30;
  *((_QWORD *)this + 14) = v29;
  *((_BYTE *)this + 98) = v10;
  if ((v6 & (v10 ^ 1)) == 1)
  {
    v21 = GIFWritePlugin::writeAllFramesWithGlobalColorMap(this);
    if ((_DWORD)v21)
    {
LABEL_37:
      v22 = v21;
      goto LABEL_45;
    }
  }
  else
  {
    if (v11)
    {
      Size = IIOImageWriteSession::getSize(*((IIOImageWriteSession **)this + 2));
      IIOImageWriteSession::seek(*((IIOImageWriteSession **)this + 2), Size - 1, 0);
      v5 = *((_QWORD *)this + 6);
      v24 = v5 - 1;
    }
    else
    {
      v24 = 0;
    }
    if (v24 < v5)
    {
      do
      {
        *((_QWORD *)this + 7) = v24;
        v21 = GIFWritePlugin::writeSingleFrame(this);
        if ((_DWORD)v21)
          goto LABEL_37;
      }
      while (++v24 < *((_QWORD *)this + 6));
    }
  }
  v22 = 0;
LABEL_45:
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    v25 = "no";
    if (!(_DWORD)v22)
      v25 = "yes";
    ImageIOLog("     _CGImagePluginWriteGIF-success: %s\n", v25);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      Error = _cg_GifLastError(*((_QWORD *)this + 5));
      ImageIOLog("                       GifLastError: %d\n\n\n", Error);
    }
  }
  if (v30)
    free(v30);
  if (v4)
    _cg_EGifCloseFile((uint64_t)v4, 0);
  *((_QWORD *)this + 14) = 0;
  return v22;
}

uint64_t GIFWritePlugin::writeOne(GIFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

double HEIFReadPlugin::HEIFReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  v3 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BAE158;
  result = 0.0;
  *(_OWORD *)(v3 + 440) = 0u;
  *(_OWORD *)(v3 + 456) = 0u;
  *(_OWORD *)(v3 + 472) = 0u;
  *(_OWORD *)(v3 + 488) = 0u;
  *(_OWORD *)(v3 + 504) = 0u;
  *(_DWORD *)(v3 + 476) = 1;
  *(_BYTE *)(v3 + 340) = 1;
  return result;
}

uint64_t HEIFReadPlugin::loadDataFromXPCObject(HEIFReadPlugin *this, void *a2)
{
  uint64_t result;
  _OWORD *data;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  const char *string;
  CFStringRef v10;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_heif", &length);
    if (length == 80)
    {
      *(_OWORD *)((char *)this + 440) = *data;
      v6 = data[1];
      v7 = data[2];
      v8 = data[4];
      *(_OWORD *)((char *)this + 488) = data[3];
      *(_OWORD *)((char *)this + 504) = v8;
      *(_OWORD *)((char *)this + 456) = v6;
      *(_OWORD *)((char *)this + 472) = v7;
      string = xpc_dictionary_get_string(a2, "iio_xpc_plugin_data_heif_req_cs");
      if (string && *string)
        v10 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], string, 0x8000100u);
      else
        v10 = 0;
      result = 0;
      *((_QWORD *)this + 64) = v10;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t HEIFReadPlugin::saveDataToXPCObject(const void **this, void *a2)
{
  uint64_t v4;
  const char *v5;
  _QWORD v7[3];

  v4 = IIOReadPlugin::saveDataToXPCObject((IIOReadPlugin *)this, a2);
  if (!(_DWORD)v4)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_heif", this + 55, 0x50uLL);
    memset(v7, 0, sizeof(v7));
    IIOString::IIOString((IIOString *)v7, this[64]);
    v5 = (const char *)IIOString::utf8String((IIOString *)v7);
    xpc_dictionary_set_string(a2, "iio_xpc_plugin_data_heif_req_cs", v5);
    IIOString::~IIOString((IIOString *)v7);
  }
  return v4;
}

void sub_18802D6E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::canCreateChromaSubsampledIOSurface(HEIFReadPlugin *this)
{
  return 1;
}

uint64_t HEIFReadPlugin::getExpectedWidthAndHeightForSubsampling(HEIFReadPlugin *this, const __CFData *a2, uint64_t a3, unint64_t a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t ImageGeometryForIndexWithOptions;
  unint64_t v13;
  unsigned int Uint32ForKey;
  unsigned int Uint32AtIndex;
  int PixelFormatForBitDepth;
  _BYTE v18[24];
  _BYTE v19[24];
  _BYTE v20[24];
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  CFTypeRef cf;
  const __CFDictionary *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  CFTypeRef v31;
  CFTypeRef v32;

  v31 = 0;
  v32 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v28);
  v27 = 0;
  cf = 0;
  if (!a2)
  {
    _cg_jpeg_mem_term("getExpectedWidthAndHeightForSubsampling", 165, "*** ERROR: getExpectedWidthAndHeightForSubsampling called with NULL-data\n");
LABEL_19:
    ImageGeometryForIndexWithOptions = 0;
    goto LABEL_20;
  }
  ImageGeometryForIndexWithOptions = IIOCreateCMPhotoDecompressionSession((uint64_t)&v32);
  if ((_DWORD)ImageGeometryForIndexWithOptions)
  {
    LogError("getExpectedWidthAndHeightForSubsampling", 170, "*** ERROR: CMPhotoDecompressionSessionCreate failed\n");
    goto LABEL_20;
  }
  ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionSessionCreateContainer(v32, 0, a2, 0, &v31);
  if ((_DWORD)ImageGeometryForIndexWithOptions)
  {
    LogError("getExpectedWidthAndHeightForSubsampling", 177, "*** ERROR: CMPhotoDecompressionSessionCreateContainer failed\n");
    goto LABEL_20;
  }
  v24 = 0;
  v25 = 0;
  ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v31, a3, 0, &v25, &v24, 0);
  if ((_DWORD)ImageGeometryForIndexWithOptions)
  {
    LogError("getExpectedWidthAndHeightForSubsampling", 188, "*** ERROR: CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions failed\n");
  }
  else
  {
    if (v25 / a4 <= v24 / a4)
      v13 = v24 / a4;
    else
      v13 = v25 / a4;
    if (IIODictionary::containsKey(*((IIODictionary **)this + 6), CFSTR("kCGImageDestinationImageMaxPixelSize")))
    {
      Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), CFSTR("kCGImageDestinationImageMaxPixelSize"));
      if (v13 > Uint32ForKey)
      {
        LODWORD(v13) = (Uint32ForKey & 0xFFFFFFF0) + 64;
        *((_BYTE *)this + 340) = 1;
      }
    }
    ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions(v31, a3, 0, &cf);
    if (!(_DWORD)ImageGeometryForIndexWithOptions)
    {
      if (cf)
      {
        v21 = 0;
        v22 = 0;
        v23 = 0;
        IIOArray::IIOArray((IIOArray *)&v21, (const __CFArray *)cf);
        Uint32AtIndex = IIOArray::getUint32AtIndex((IIOArray *)&v21, 0);
        PixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth(this, Uint32AtIndex, *((IIODictionary **)this + 6));
        IIONumber::IIONumber((IIONumber *)v20, PixelFormatForBitDepth);
        IIODictionary::setObjectForKey((uint64_t)&v28, (uint64_t)v20, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
        IIONumber::~IIONumber((IIONumber *)v20);
        CFRelease(cf);
        IIOArray::~IIOArray((IIOArray *)&v21);
      }
      IIONumber::IIONumber((IIONumber *)v19, v13);
      IIODictionary::setObjectForKey((uint64_t)&v28, (uint64_t)v19, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
      IIONumber::~IIONumber((IIONumber *)v19);
      IIONumber::IIONumber((IIONumber *)v18, *((_DWORD *)this + 119));
      IIODictionary::setObjectForKey((uint64_t)&v28, (uint64_t)v18, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
      IIONumber::~IIONumber((IIONumber *)v18);
      ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex(v31, a3, v29, &v27);
      if ((_DWORD)ImageGeometryForIndexWithOptions)
      {
        LogError("getExpectedWidthAndHeightForSubsampling", 230, "*** ERROR: CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex failed\n");
        goto LABEL_20;
      }
      v21 = 0;
      v22 = 0;
      v23 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v21, v27);
      *a5 = IIODictionary::getUint32ForKey((IIODictionary *)&v21, *(const __CFString **)gIIO_kCVPixelBufferWidthKey);
      *a6 = IIODictionary::getUint32ForKey((IIODictionary *)&v21, *(const __CFString **)gIIO_kCVPixelBufferHeightKey);
      IIODictionary::~IIODictionary((IIODictionary *)&v21);
      goto LABEL_19;
    }
    LogError("getExpectedWidthAndHeightForSubsampling", 206, "*** ERROR: CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions failed\n");
  }
LABEL_20:
  if (v31)
    CFRelease(v31);
  if (v32)
    CFRelease(v32);
  if (v27)
    CFRelease(v27);
  IIODictionary::~IIODictionary((IIODictionary *)&v28);
  return ImageGeometryForIndexWithOptions;
}

void sub_18802DA8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 104));
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::getPixelFormatForBitDepth(HEIFReadPlugin *this, unsigned int a2, IIODictionary *a3)
{
  int v4;
  _BOOL4 EnableRestrictedDecodingFlag;
  int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v4 = *((_DWORD *)this + 81);
  if (v4 == 1196573017)
  {
    if (a2 >= 9)
      return 1278226742;
    else
      return 1278226488;
  }
  else if (v4 == 1380401696)
  {
    EnableRestrictedDecodingFlag = HEIFReadPlugin::getEnableRestrictedDecodingFlag((IIODictionary **)this, a3);
    v7 = a2 < 9 || EnableRestrictedDecodingFlag;
    if (a2 == 10)
      v8 = 1815162994;
    else
      v8 = 1815491698;
    if (v7)
      return 1111970369;
    else
      return v8;
  }
  else
  {
    v10 = v4 >> 24;
    v11 = MEMORY[0x1E0C80978];
    if (v4 < 0)
    {
      v12 = __maskrune(v10, 0x40000uLL);
      v4 = *((_DWORD *)this + 81);
    }
    else
    {
      v12 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v10 + 60) & 0x40000;
    }
    if (v12)
      v13 = (v4 >> 24);
    else
      v13 = 46;
    v14 = v4 << 8 >> 24;
    if (v4 << 8 < 0)
    {
      v15 = __maskrune(v14, 0x40000uLL);
      v4 = *((_DWORD *)this + 81);
    }
    else
    {
      v15 = *(_DWORD *)(v11 + 4 * v14 + 60) & 0x40000;
    }
    if (v15)
      v16 = (v4 << 8 >> 24);
    else
      v16 = 46;
    v17 = (__int16)v4 >> 8;
    if (v4 << 16 < 0)
    {
      v18 = __maskrune(v17, 0x40000uLL);
      v4 = *((_DWORD *)this + 81);
    }
    else
    {
      v18 = *(_DWORD *)(v11 + 4 * v17 + 60) & 0x40000;
    }
    if (v18)
      v19 = ((__int16)v4 >> 8);
    else
      v19 = 46;
    if ((v4 << 24) <= 0x7F000000)
    {
      v20 = *(_DWORD *)(v11 + 4 * (char)v4 + 60) & 0x40000;
    }
    else
    {
      v20 = __maskrune((char)v4, 0x40000uLL);
      v4 = *((_DWORD *)this + 81);
    }
    v9 = 1111970369;
    if (v20)
      v21 = (char)v4;
    else
      v21 = 46;
    _cg_jpeg_mem_term("getPixelFormatForBitDepth", 1188, "*** getPixelFormatForBitDepth - unexpected colorModel: '%c%c%c%c' [0x%08x]- using icSigRgbData with 'BGRA'\n", v13, v16, v19, v21, v4);
    *((_DWORD *)this + 81) = 1380401696;
  }
  return v9;
}

uint64_t HEIFReadPlugin::handleDecodeRequest(HEIFReadPlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  const __CFDictionary *ObjectForKey;
  const __CFString *v7;
  const __CFDictionary *v8;
  const char *v9;
  unsigned int v10;
  float FloatForKey;
  unsigned int v12;
  float v13;
  BOOL BoolForKey;
  CGColorSpace *v15;
  int v16;
  _QWORD *Position;
  void *TagWithPath;
  const __CFNumber *v19;
  int v20;
  const void *v21;
  IIOImageRead *v22;
  HEIFMainImage *HEIFMainImageAtIndex;
  GlobalGIFInfo *HEIFAlternateImageAtIndex;
  const void *ImageDescOffset;
  int v26;
  int v27;
  const char *v28;
  int Uint32ForKey;
  int v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  CGColorSpace *v45;
  const __CFString *v46;
  CFStringRef v47;
  const char *v48;
  const char *v49;
  int v50;
  int *v51;
  int v52;
  int v53;
  int v54;
  _BYTE v56[24];
  _QWORD v57[2];
  void *value;
  CFTypeRef cf;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  uint64_t v65;

  if (IIODictionary::containsKey(a2, CFSTR("kCGImageSourceDecodeRequest")))
  {
    ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("kCGImageSourceDecodeRequest"));
    if (ObjectForKey)
    {
      v7 = (const __CFString *)ObjectForKey;
      v8 = IIODictionary::getObjectForKey(a2, CFSTR("kCGImageSourceDecodeRequestOptions"));
      v63 = 0;
      v64 = 0;
      v65 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v63, v8, 1);
      if (CFStringCompare(v7, CFSTR("kCGImageSourceDecodeToHDR"), 0))
      {
        if (CFStringCompare(v7, CFSTR("kCGImageSourceDecodeToSDR"), 0))
        {
          IIOString::IIOString((IIOString *)&v60, v7);
          v9 = (const char *)IIOString::utf8String((IIOString *)&v60);
          LogError("handleDecodeRequest", 326, "Unknown decode target: %s\n", v9);
          IIOString::~IIOString((IIOString *)&v60);
LABEL_104:
          IIODictionary::~IIODictionary((IIODictionary *)&v63);
          return 0;
        }
        v15 = (CGColorSpace *)*((_QWORD *)this + 20);
        if (!v15
          || !CGColorSpaceUsesITUR_2100TF(v15) && !CGColorSpaceUsesExtendedRange(*((CGColorSpaceRef *)this + 20)))
        {
          goto LABEL_104;
        }
        if ((gIIODebugFlags & 0x300000) != 0)
          ImageIOLog("☀️  decodeRequest: 'kCGImageSourceDecodeToSDR'\n");
        *((_WORD *)this + 242) = 256;
        *((_BYTE *)this + 488) = 0;
        v16 = 1;
LABEL_30:
        cf = 0;
        v60 = 0;
        v61 = 0;
        v62 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v60, a3);
        v21 = (const void *)*((_QWORD *)this + 20);
        if (v21)
          IIODictionary::setObjectForKey((IIODictionary *)&v60, v21, *(const __CFString **)gIIO_kCVImageBufferCGColorSpaceKey);
        v22 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
        HEIFMainImageAtIndex = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v22, *((_DWORD *)this + 124));
        HEIFAlternateImageAtIndex = (GlobalGIFInfo *)HEIFMainImage::getHEIFAlternateImageAtIndex(HEIFMainImageAtIndex, *((_DWORD *)this + 124));
        if (HEIFAlternateImageAtIndex)
        {
          ImageDescOffset = (const void *)GlobalGIFInfo::lastImageDescOffset(HEIFAlternateImageAtIndex);
          if (ImageDescOffset)
            IIODictionary::setObjectForKey((IIODictionary *)&v63, ImageDescOffset, CFSTR("kCGFlexRangeAlternateColorSpace"));
        }
        if ((gIIODebugFlags & 0x300000) != 0)
          ImageIOLog("☀️  'IIOCallCreatePixelBufferAttributesForHDRType'\n");
        if (*((_BYTE *)this + 492))
        {
          if ((gIIODebugFlags & 0x300000) != 0)
            ImageIOLog("☀️  image has alpha plane --> pixelformat 'l64r'\n");
          IIONumber::IIONumber((IIONumber *)v57, 1815491698);
          IIODictionary::setObjectForKey((IIODictionary *)&v63, value, CFSTR("kCGTargetPixelFormat"));
          IIONumber::~IIONumber((IIONumber *)v57);
        }
        v26 = IIOCallCreatePixelBufferAttributesForHDRType(v16, v61, v64, &cf);
        v27 = v26;
        if (v26)
        {
          v28 = IIOCMErrorString(v26);
          LogError("handleDecodeRequest", 358, "*** ERROR: Cannot decode to SDR: err = %s [%d]\n", v28, v27);
        }
        if (!cf)
          goto LABEL_103;
        v57[0] = 0;
        v57[1] = 0;
        value = 0;
        IIODictionary::IIODictionary((IIODictionary *)v57, (const __CFDictionary *)cf);
        Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v57, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey);
        v30 = Uint32ForKey;
        if ((gIIODebugFlags & 0x300000) != 0)
        {
          v31 = Uint32ForKey >> 24;
          v32 = MEMORY[0x1E0C80978];
          if (Uint32ForKey < 0)
            v33 = __maskrune(Uint32ForKey >> 24, 0x40000uLL);
          else
            v33 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v31 + 60) & 0x40000;
          if (v33)
            v34 = v31;
          else
            v34 = 46;
          v35 = v30 << 8 >> 24;
          if (v30 << 8 < 0)
            v36 = __maskrune(v30 << 8 >> 24, 0x40000uLL);
          else
            v36 = *(_DWORD *)(v32 + 4 * v35 + 60) & 0x40000;
          if (v36)
            v37 = v35;
          else
            v37 = 46;
          v38 = (__int16)v30 >> 8;
          if (v30 << 16 < 0)
            v39 = __maskrune((__int16)v30 >> 8, 0x40000uLL);
          else
            v39 = *(_DWORD *)(v32 + 4 * v38 + 60) & 0x40000;
          if ((v30 << 24) <= 0x7F000000)
            v40 = *(_DWORD *)(v32 + 4 * (char)v30 + 60) & 0x40000;
          else
            v40 = __maskrune((char)v30, 0x40000uLL);
          if (v39)
            v41 = v38;
          else
            v41 = 46;
          if (v40)
            v42 = (char)v30;
          else
            v42 = 46;
          ImageIOLog("☀️  requestedPixelFormat: '%c%c%c%c'   %s:%d\n", v34, v37, v41, v42, "handleDecodeRequest", 364);
        }
        v43 = IIODictionary::getUint32ForKey((IIODictionary *)v57, *(const __CFString **)gIIO_kCVPixelBufferWidthKey);
        v44 = IIODictionary::getUint32ForKey((IIODictionary *)v57, *(const __CFString **)gIIO_kCVPixelBufferHeightKey);
        v45 = IIODictionary::getObjectForKey((IIODictionary *)v57, *(const __CFString **)gIIO_kCVImageBufferCGColorSpaceKey);
        v46 = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v57, *(const __CFString **)gIIO_kCVImageBufferYCbCrMatrixKey);
        *((_DWORD *)this + 110) = v30;
        v47 = CGColorSpaceCopyName(v45);
        *((_QWORD *)this + 64) = v47;
        if ((gIIODebugFlags & 0x300000) != 0)
        {
          IIOString::IIOString((IIOString *)v56, v47);
          v48 = (const char *)IIOString::utf8String((IIOString *)v56);
          ImageIOLog("☀️  requestedColorSpace: '%s'\n", v48);
          IIOString::~IIOString((IIOString *)v56);
        }
        if (v45)
        {
          CGColorSpaceRelease(*((CGColorSpaceRef *)this + 20));
          *((_QWORD *)this + 20) = CFRetain(v45);
        }
        *((_BYTE *)this + 489) = IIODictionary::getBoolForKey((IIODictionary *)&v63, CFSTR("kCGDisableMetal"));
        if (v46)
        {
          if ((gIIODebugFlags & 0x300000) != 0)
          {
            IIOString::IIOString((IIOString *)v56, v46);
            v49 = (const char *)IIOString::utf8String((IIOString *)v56);
            ImageIOLog("☀️  requestedYCCMatrix: '%s'\n", v49);
            IIOString::~IIOString((IIOString *)v56);
          }
          if (CFStringCompare(v46, *(CFStringRef *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4, 0))
          {
            if (CFStringCompare(v46, *(CFStringRef *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_709_2, 0))
            {
              if (CFStringCompare(v46, *(CFStringRef *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020, 0))
                goto LABEL_84;
              v50 = 3;
            }
            else
            {
              v50 = 2;
            }
          }
          else
          {
            v50 = 1;
          }
          *((_DWORD *)this + 111) = v50;
        }
LABEL_84:
        *((_DWORD *)this + 65) = v43;
        *((_DWORD *)this + 66) = v44;
        if (v30 > 1815491697)
        {
          if (v30 == 2019963440)
          {
LABEL_92:
            *((_DWORD *)this + 68) = 2097162;
            v53 = 4;
            *((_WORD *)this + 138) = 4;
            *(_DWORD *)((char *)this + 278) = 197126;
LABEL_102:
            *((_DWORD *)this + 67) = (v43 * v53 + 15) & 0xFFFFFFF0;
            *((_BYTE *)this + 350) = 1;
            CFRelease(cf);
            IIODictionary::~IIODictionary((IIODictionary *)v57);
LABEL_103:
            IIODictionary::~IIODictionary((IIODictionary *)&v60);
            goto LABEL_104;
          }
          if (v30 != 1815491698)
          {
LABEL_95:
            *((_DWORD *)this + 68) = 2097160;
            *((_WORD *)this + 138) = 4;
            if (*((_BYTE *)this + 492))
              v54 = 3;
            else
              v54 = 5;
            *(_DWORD *)((char *)this + 278) = v54;
            v53 = 4;
            goto LABEL_102;
          }
          *((_DWORD *)this + 68) = 4194320;
          *((_WORD *)this + 138) = 4;
          v51 = (int *)((char *)this + 278);
          if (*((_BYTE *)this + 492))
            v52 = 259;
          else
            v52 = 261;
        }
        else
        {
          if (v30 != 1380411457)
          {
            if (v30 != 1815162994)
              goto LABEL_95;
            goto LABEL_92;
          }
          *((_DWORD *)this + 68) = 4194320;
          *((_WORD *)this + 138) = 4;
          v51 = (int *)((char *)this + 278);
          if (*((_BYTE *)this + 492))
            v52 = 16777475;
          else
            v52 = 16777477;
        }
        *v51 = v52;
        v53 = 8;
        goto LABEL_102;
      }
      if (!*((_BYTE *)this + 487) && !*((_BYTE *)this + 486))
        goto LABEL_104;
      if ((gIIODebugFlags & 0x300000) != 0)
        ImageIOLog("☀️  decodeRequest: 'kCGImageSourceDecodeToHDR'\n");
      *((_WORD *)this + 242) = 1;
      v10 = IIODictionary::containsKey((IIODictionary *)&v63, CFSTR("kCGTargetHeadroom"));
      FloatForKey = 0.0;
      if (v10)
        FloatForKey = IIODictionary::getFloatForKey((IIODictionary *)&v63, CFSTR("kCGTargetHeadroom"));
      *((float *)this + 112) = FloatForKey;
      v12 = IIODictionary::containsKey((IIODictionary *)&v63, CFSTR("kCGFallbackHDRGain"));
      v13 = 0.0;
      if (v12)
        v13 = IIODictionary::getFloatForKey((IIODictionary *)&v63, CFSTR("kCGFallbackHDRGain"));
      *((float *)this + 113) = v13;
      if (IIODictionary::containsKey((IIODictionary *)&v63, CFSTR("kCGGenerateFlexGTC")))
      {
        BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)&v63, CFSTR("kCGGenerateFlexGTC"));
      }
      else
      {
        if (!IIODictionary::containsKey((IIODictionary *)&v63, CFSTR("kCGImageSourceGenerateImageSpecificLumaScaling")))
        {
          *((_BYTE *)this + 488) = 1;
          goto LABEL_26;
        }
        BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)&v63, CFSTR("kCGImageSourceGenerateImageSpecificLumaScaling"));
      }
      *((_BYTE *)this + 488) = BoolForKey;
LABEL_26:
      if (IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceCreateThumbnailWithTransform")))
      {
        Position = (_QWORD *)IIOImageWriteSession::getPosition(this);
        TagWithPath = CGImageMetadataGetTagWithPath(Position, 0, CFSTR("tiff:Orientation"));
        v19 = (const __CFNumber *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
        IIONumber::IIONumber((IIONumber *)&v60, v19);
        v20 = IIONumber::uint32Num((IIONumber *)&v60);
        IIONumber::~IIONumber((IIONumber *)&v60);
        *((_DWORD *)this + 118) = v20;
      }
      else
      {
        *((_DWORD *)this + 118) = 1;
      }
      v16 = 2;
      goto LABEL_30;
    }
  }
  return 0;
}

void sub_18802E514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v10;
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v10 - 112));
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::getDecodePixelFormatForBitDepth(HEIFReadPlugin *this, int a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v6;
  unsigned int v7;

  v2 = *((_DWORD *)this + 81);
  if (v2 == 1196573017)
  {
    if (*((_BYTE *)this + 492))
      v6 = 843264056;
    else
      v6 = 1278226488;
    v7 = 1278226742;
    if (*((_BYTE *)this + 492))
      v7 = 843264310;
    if (a2 == 10)
      return v7;
    else
      return v6;
  }
  else if (v2 == 1380401696)
  {
    if (*((_BYTE *)this + 492))
      v3 = 1111970369;
    else
      v3 = 875704422;
    if (*((_BYTE *)this + 492))
      v4 = 1815491698;
    else
      v4 = 2019963440;
    if (a2 == 10)
      return v4;
    else
      return v3;
  }
  else
  {
    return 0;
  }
}

CFTypeRef HEIFReadPlugin::copyAuxiliaryDataInfo(HEIFReadPlugin *this, unsigned int a2, const __CFString *a3, IIODictionary *a4)
{
  IIOImageRead *v8;
  uint64_t HEIFMainImageAtIndex;
  HEIFGroupItem *v10;
  uint64_t Options;
  int v12;
  int v13;
  IIOImageRead *Size;
  IIOImageRead *v15;
  const UInt8 *v16;
  uint64_t v17;
  CFDataRef v18;
  __n128 v19;
  int v20;
  int v21;
  const char *v22;
  CFTypeRef v23;
  unsigned int NumberOfAuxImages;
  uint64_t v25;
  uint64_t v26;
  HEIFAuxImage *HEIFAuxImageAtIndex;
  const __CFString *v28;
  CFTypeRef v29;
  uint64_t v30;
  unsigned int v31;
  const void *v32;
  const char *v33;
  CFTypeRef v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  __CVBuffer *ObjectForKey;
  const __CFDictionary *v40;
  const __CFDictionary *v41;
  IIOImageRead **v42;
  CFTypeRef v44;
  void *v45;
  uint64_t (*v46)(CFTypeRef, uint64_t, _QWORD, _QWORD, uint64_t, CFDictionaryRef *);
  void (*v47)(CFTypeRef, uint64_t, _QWORD, _QWORD, CFTypeRef *);
  IIODictionary *v48;
  uint64_t v49;
  CFTypeRef v50;
  uint64_t v51;
  char v52;
  CFTypeRef cf;
  CFTypeRef v54;
  uint64_t v55;
  CFTypeRef v56;
  CFTypeRef v57;
  CFDictionaryRef theDict[2];
  void *value;
  CFTypeRef v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  CFTypeRef v64;
  uint64_t v65;
  int v66;
  CFTypeRef v67;
  CFTypeRef v68;
  void *v69;

  v68 = 0;
  v69 = 0;
  v67 = 0;
  IIO_LoadHEIFSymbols();
  v8 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
  HEIFMainImageAtIndex = GlobalHEIFInfo::getHEIFMainImageAtIndex(v8, *((_DWORD *)this + 124));
  if (!HEIFMainImageAtIndex
    || (v10 = (HEIFGroupItem *)HEIFMainImageAtIndex,
        v66 = 0,
        Options = IIOImagePlus::getOptions(*((IIOImagePlus **)this + 2)),
        v12 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v68),
        !v68))
  {
    v23 = 0;
    v18 = 0;
    goto LABEL_57;
  }
  v13 = v12;
  Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  v15 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v69, 1);
  if (!v15)
  {
    LogError("copyAuxiliaryDataInfo", 1415, "*** ERROR: retainBytePointer failed\n");
    v18 = 0;
    goto LABEL_42;
  }
  v16 = (const UInt8 *)v15;
  v17 = *((_QWORD *)this + 57);
  if (v17)
  {
    if (*((_QWORD *)this + 58))
      Size = (IIOImageRead *)*((_QWORD *)this + 58);
    else
      v17 = 0;
    v16 = (const UInt8 *)v15 + v17;
  }
  v18 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v16, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (v18)
    v13 = gFunc_CMPhotoDecompressionSessionCreateContainer(v68, 0, v18, &v66, &v67);
  if (a2 == 98)
  {
    if (!HEIFGroupItem::getStereoAggressorCount(v10))
      goto LABEL_42;
    v63 = 0;
    v64 = 0;
    v65 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v63);
    v60 = 0;
    v61 = 0;
    v62 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v60);
    IIONumber::IIONumber((IIONumber *)theDict, 6);
    IIODictionary::setObjectForKey((IIODictionary *)&v60, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputMode);
    IIONumber::~IIONumber((IIONumber *)theDict);
    IIODictionary::setObjectForKey((IIODictionary *)&v60, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer);
    IIODictionary::setObjectForKey((IIODictionary *)&v63, v61, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputOptions);
    v57 = 0;
    v20 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v67, *((unsigned int *)this + 124), v64, 5, &v57, v19);
    v21 = v20;
    if (v20)
    {
      v22 = IIOCMErrorString(v20);
      LogError("copyAuxiliaryDataInfo", 1447, "*** ERROR: CMPhotoDecompressionContainerCreateImageForIndex err: %s [%d]\n", v22, v21);
      v23 = 0;
    }
    else
    {
      theDict[0] = 0;
      theDict[1] = 0;
      value = 0;
      IIODictionary::IIODictionary((IIODictionary *)theDict, (const __CFDictionary *)v57);
      ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)theDict, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap);
      v40 = IIODictionary::getObjectForKey((IIODictionary *)theDict, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata);
      v56 = 0;
      CGImageCreateFlexRangeMetadata((uint64_t)v40, (uint64_t *)&v56);
      cf = 0;
      v54 = 0;
      v55 = 0;
      HEIFReadPlugin::auxiliaryDataInfoFromPixelBuffer(ObjectForKey, (const CGImageMetadata *)v56, a4, (IIODictionary *)&cf);
      v23 = CFRetain(v54);
      v41 = IIODictionary::getObjectForKey((IIODictionary *)theDict, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace);
      if (v41)
        IIODictionary::setObjectForKey((IIODictionary *)&cf, v41, CFSTR("kCGImageAuxiliaryDataInfoColorSpace"));
      if (IIODictionary::getBoolForKey(a4, CFSTR("kCGImageAuxiliaryDataIncludeMeteorPlusMetadata")))
      {
        v52 = 0;
        v51 = -1;
        gFunc_CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithOptions(v67, *((unsigned int *)this + 124), 0, 4, *(_QWORD *)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap, &v52, &v51);
        if (v52)
        {
          v50 = 0;
          gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions(v67, *((unsigned int *)this + 124), v51, 0, &v50);
          IIODictionary::setObjectForKey((IIODictionary *)&cf, v50, CFSTR("kCGImageAuxiliaryDataInfoMeteorPlusMetadata"));
          if (v50)
            CFRelease(v50);
        }
      }
      if (v56)
        CFRelease(v56);
      IIODictionary::~IIODictionary((IIODictionary *)&cf);
      IIODictionary::~IIODictionary((IIODictionary *)theDict);
    }
    if (v57)
      CFRelease(v57);
    IIODictionary::~IIODictionary((IIODictionary *)&v60);
    IIODictionary::~IIODictionary((IIODictionary *)&v63);
    goto LABEL_55;
  }
  NumberOfAuxImages = HEIFMainImage::getNumberOfAuxImages(v10);
  v60 = 0;
  if (!NumberOfAuxImages)
    goto LABEL_42;
  v48 = a4;
  v25 = 0;
  v26 = NumberOfAuxImages;
  v49 = Options;
  do
  {
    HEIFAuxImageAtIndex = (HEIFAuxImage *)HEIFMainImage::getHEIFAuxImageAtIndex(v10, v25);
    if (HEIFAuxImage::auxiliaryType(HEIFAuxImageAtIndex) != a2)
      goto LABEL_32;
    if (a2 < 4)
    {
      v13 = gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation(v67, *((unsigned int *)this + 124), v25, *(_QWORD *)(Options + 8), &v60);
    }
    else
    {
      v28 = (const __CFString *)IIOImageWriteSession::getSize(HEIFAuxImageAtIndex);
      if (a3 && v28)
      {
        if (CFStringCompare(a3, v28, 0))
          goto LABEL_32;
        if (a2 != 99)
        {
          theDict[0] = 0;
          v46 = (uint64_t (*)(CFTypeRef, uint64_t, _QWORD, _QWORD, uint64_t, CFDictionaryRef *))gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex;
          v34 = v67;
          v35 = *((unsigned int *)this + 124);
          v36 = HEIFAuxImage::payloadIndex(HEIFAuxImageAtIndex);
          v13 = v46(v34, v35, v36, *(_QWORD *)(v49 + 8), 2, theDict);
          if (theDict[0])
          {
            cf = 0;
            v44 = v67;
            v47 = (void (*)(CFTypeRef, uint64_t, _QWORD, _QWORD, CFTypeRef *))gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions;
            v37 = *((unsigned int *)this + 124);
            v38 = HEIFAuxImage::payloadIndex(HEIFAuxImageAtIndex);
            v47(v44, v37, v38, *(_QWORD *)(v49 + 8), &cf);
            v63 = 0;
            v64 = 0;
            v65 = 0;
            HEIFReadPlugin::auxiliaryDataInfoFromPixelBuffer(theDict[0], (const CGImageMetadata *)cf, v48, (IIODictionary *)&v63);
            v60 = CFRetain(v64);
            if (cf)
              CFRelease(cf);
            CFRelease(theDict[0]);
            IIODictionary::~IIODictionary((IIODictionary *)&v63);
          }
          Options = v49;
          if (!v13)
          {
LABEL_39:
            v23 = v60;
            goto LABEL_55;
          }
          goto LABEL_31;
        }
        theDict[0] = 0;
        v45 = gFunc_CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithOptions;
        v29 = v67;
        v30 = *((unsigned int *)this + 124);
        v31 = HEIFAuxImage::payloadIndex(HEIFAuxImageAtIndex);
        v13 = ((uint64_t (*)(CFTypeRef, uint64_t, _QWORD, _QWORD, CFDictionaryRef *))v45)(v29, v30, v31, 0, theDict);
        Options = v49;
        if (theDict[0])
        {
          v63 = 0;
          v64 = 0;
          v65 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v63);
          if (CFDictionaryContainsKey(theDict[0], CFSTR("Data")))
          {
            v32 = CFDictionaryGetValue(theDict[0], CFSTR("Data"));
            IIODictionary::setObjectForKey((IIODictionary *)&v63, v32, CFSTR("kCGImageAuxiliaryDataInfoData"));
          }
          v60 = CFRetain(v64);
          CFRelease(theDict[0]);
          IIODictionary::~IIODictionary((IIODictionary *)&v63);
          if (!v13)
            goto LABEL_39;
          goto LABEL_31;
        }
      }
    }
    if (!v13)
      goto LABEL_39;
LABEL_31:
    v33 = IIOCMErrorString(v13);
    _cg_jpeg_mem_term("copyAuxiliaryDataInfo", 1567, "*** CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation[%d]  err = %s [%d]\n", v25, v33, v13);
LABEL_32:
    ++v25;
  }
  while (v26 != v25);
  if (v60)
    CFRelease(v60);
LABEL_42:
  v23 = 0;
LABEL_55:
  if (v68)
    CFRelease(v68);
LABEL_57:
  if (v67)
    CFRelease(v67);
  if (v18)
    CFRelease(v18);
  if (v69)
  {
    v42 = (IIOImageRead **)*((_QWORD *)this + 3);
    if (v42)
      IIOImageReadSession::releaseBytePointer(v42, v69);
  }
  return v23;
}

void sub_18802ED38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;

  IIODictionary::~IIODictionary((IIODictionary *)&a20);
  IIODictionary::~IIODictionary((IIODictionary *)&a25);
  IIODictionary::~IIODictionary((IIODictionary *)&a28);
  IIODictionary::~IIODictionary((IIODictionary *)(v28 - 144));
  _Unwind_Resume(a1);
}

void HEIFReadPlugin::auxiliaryDataInfoFromPixelBuffer(__CVBuffer *a1@<X1>, const CGImageMetadata *a2@<X2>, IIODictionary *a3@<X3>, IIODictionary *a4@<X8>)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v10;
  __IOSurface *IOSurface;
  __IOSurface *v12;
  CGImage *v13;
  int PixelFormatType;
  uint64_t Height;
  unsigned int v16;
  uint64_t v17;
  int v18;
  const UInt8 *BaseAddress;
  CFDataRef v20;
  __n128 v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t Width;
  unint64_t BytesPerRow;
  _BYTE v33[16];
  void *v34;
  uint64_t v35;
  void *value;
  uint64_t v37;

  *(_QWORD *)a4 = 0;
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  IIODictionary::IIODictionary(a4);
  ObjectForKey = IIODictionary::getObjectForKey(a3, CFSTR("kCGImageAuxiliaryDataRepresentation"));
  v10 = ObjectForKey;
  if (!ObjectForKey)
    goto LABEL_8;
  if (CFEqual(ObjectForKey, CFSTR("kCGImageAuxiliaryDataRepresentationPixelBuffer")))
  {
    IIODictionary::setObjectForKey(a4, a1, CFSTR("kCGImageAuxiliaryDataInfoPixelBuffer"));
    goto LABEL_38;
  }
  if (CFEqual(v10, CFSTR("kCGImageAuxiliaryDataRepresentationIOSurface")))
  {
    IOSurface = (__IOSurface *)gFunc_CVPixelBufferGetIOSurface(a1);
    IOSurfaceIncrementUseCount(IOSurface);
    IIODictionary::setObjectForKey(a4, IOSurface, CFSTR("kCGImageAuxiliaryDataInfoIOSurface"));
    goto LABEL_38;
  }
  if (CFEqual(v10, CFSTR("kCGImageAuxiliaryDataRepresentationImage")))
  {
    v12 = (__IOSurface *)gFunc_CVPixelBufferGetIOSurface(a1);
    v13 = CGImageCreateFromIOSurface(v12, 0);
    IIODictionary::setObjectForKey(a4, v13, CFSTR("kCGImageAuxiliaryDataInfoImage"));
    CGImageRelease(v13);
  }
  else
  {
LABEL_8:
    PixelFormatType = gFunc_CVPixelBufferGetPixelFormatType(a1);
    Width = gFunc_CVPixelBufferGetWidth(a1);
    Height = gFunc_CVPixelBufferGetHeight(a1);
    BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(a1);
    if (gFunc_CVPixelBufferIsPlanar(a1))
    {
      v16 = PixelFormatType >> 24;
      v17 = MEMORY[0x1E0C80978];
      if (PixelFormatType < 0)
        v18 = __maskrune(PixelFormatType >> 24, 0x40000uLL);
      else
        v18 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v16 + 60) & 0x40000;
      if (v18)
        v22 = v16;
      else
        v22 = 46;
      v23 = PixelFormatType << 8 >> 24;
      if (PixelFormatType << 8 < 0)
        v24 = __maskrune(PixelFormatType << 8 >> 24, 0x40000uLL);
      else
        v24 = *(_DWORD *)(v17 + 4 * v23 + 60) & 0x40000;
      if (v24)
        v25 = v23;
      else
        v25 = 46;
      v26 = (__int16)PixelFormatType >> 8;
      if (PixelFormatType << 16 < 0)
        v27 = __maskrune((__int16)PixelFormatType >> 8, 0x40000uLL);
      else
        v27 = *(_DWORD *)(v17 + 4 * v26 + 60) & 0x40000;
      if ((PixelFormatType << 24) <= 0x7F000000)
        v28 = *(_DWORD *)(v17 + 4 * (char)PixelFormatType + 60) & 0x40000;
      else
        v28 = __maskrune((char)PixelFormatType, 0x40000uLL);
      if (v27)
        v29 = v26;
      else
        v29 = 46;
      if (v28)
        v30 = (char)PixelFormatType;
      else
        v30 = 46;
      LogError("auxiliaryDataInfoFromPixelBuffer", 1645, "*** ERROR: Unsupported AuxiliaryData format '%c%c%c%c'\n", v22, v25, v29, v30);
    }
    else
    {
      gFunc_CVPixelBufferLockBaseAddress(a1, 1);
      BaseAddress = (const UInt8 *)gFunc_CVPixelBufferGetBaseAddress(a1);
      v20 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], BaseAddress, BytesPerRow * Height);
      if (v20)
      {
        IIODictionary::setObjectForKey(a4, v20, CFSTR("kCGImageAuxiliaryDataInfoData"));
        CFRelease(v20);
      }
      gFunc_CVPixelBufferUnlockBaseAddress(a1, 1, v21);
    }
    v35 = 0;
    value = 0;
    v37 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v35);
    IIODictionary::setObjectForKey(a4, value, CFSTR("kCGImageAuxiliaryDataInfoDataDescription"));
    IIONumber::IIONumber((IIONumber *)v33, Width);
    IIODictionary::setObjectForKey((IIODictionary *)&v35, v34, CFSTR("Width"));
    IIONumber::~IIONumber((IIONumber *)v33);
    IIONumber::IIONumber((IIONumber *)v33, Height);
    IIODictionary::setObjectForKey((IIODictionary *)&v35, v34, CFSTR("Height"));
    IIONumber::~IIONumber((IIONumber *)v33);
    IIONumber::IIONumber((IIONumber *)v33, BytesPerRow);
    IIODictionary::setObjectForKey((IIODictionary *)&v35, v34, CFSTR("BytesPerRow"));
    IIONumber::~IIONumber((IIONumber *)v33);
    IIONumber::IIONumber((IIONumber *)v33, PixelFormatType);
    IIODictionary::setObjectForKey((IIODictionary *)&v35, v34, CFSTR("PixelFormat"));
    IIONumber::~IIONumber((IIONumber *)v33);
    IIODictionary::~IIODictionary((IIODictionary *)&v35);
  }
LABEL_38:
  if (a2)
    IIODictionary::setObjectForKey(a4, a2, CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
}

void sub_18802F20C(_Unwind_Exception *a1)
{
  IIODictionary *v1;

  IIODictionary::~IIODictionary(v1);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::copyISOGainMapDictionary(uint64_t a1, uint64_t a2)
{
  __n128 v4;
  int v5;
  int v6;
  const char *v7;
  uint64_t v8;
  _BYTE v10[16];
  void *value;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = 0;
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s\n", "copyISOGainMapDictionary");
  v15 = 0;
  v16 = 0;
  v17 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v15);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v12);
  IIONumber::IIONumber((IIONumber *)v10, 6);
  IIODictionary::setObjectForKey((IIODictionary *)&v12, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputMode);
  IIONumber::~IIONumber((IIONumber *)v10);
  IIODictionary::setObjectForKey((IIODictionary *)&v12, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer);
  IIODictionary::setObjectForKey((IIODictionary *)&v15, v13, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputOptions);
  v5 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(a2, *(unsigned int *)(a1 + 496), v16, 5, &v18, v4);
  v6 = v5;
  if (v5)
  {
    v7 = IIOCMErrorString(v5);
    LogError("copyISOGainMapDictionary", 1743, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v7, v6);
  }
  v8 = v18;
  IIODictionary::~IIODictionary((IIODictionary *)&v12);
  IIODictionary::~IIODictionary((IIODictionary *)&v15);
  return v8;
}

void sub_18802F3D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 48));
  _Unwind_Resume(a1);
}

__CFDictionary *HEIFReadPlugin::copyHDRGainMapDictionary(uint64_t a1, uint64_t a2, GlobalHEIFInfo *this, uint64_t a4)
{
  HEIFMainImage *HEIFMainImageAtIndex;
  int NumberOfAuxImages;
  const __CFString *v8;
  uint64_t v9;
  int AuxiliaryImageForIndex;
  IIOImageWriteSession *HEIFAuxImageAtIndex;
  const __CFString *Size;
  const char *v13;
  __CFDictionary *Mutable;
  __CFDictionary *v15;
  int v17;
  int v18;
  const char *v19;
  __int128 cf;

  HEIFMainImageAtIndex = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(this, *(_DWORD *)(a1 + 496));
  NumberOfAuxImages = HEIFMainImage::getNumberOfAuxImages(HEIFMainImageAtIndex);
  v8 = *(const __CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap;
  cf = 0uLL;
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s\n", "copyHDRGainMapDictionary");
  if (NumberOfAuxImages)
  {
    v9 = 0;
    AuxiliaryImageForIndex = 0;
    do
    {
      HEIFAuxImageAtIndex = (IIOImageWriteSession *)HEIFMainImage::getHEIFAuxImageAtIndex(HEIFMainImageAtIndex, v9);
      if (HEIFAuxImage::auxiliaryType(HEIFAuxImageAtIndex) == 4)
      {
        Size = (const __CFString *)IIOImageWriteSession::getSize(HEIFAuxImageAtIndex);
        if (v8 && Size)
        {
          if (CFStringCompare(v8, Size, 0))
            goto LABEL_12;
          AuxiliaryImageForIndex = gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex(a2, *(unsigned int *)(a1 + 496), v9, *(_QWORD *)(a4 + 8), 2, (char *)&cf + 8);
        }
        if (!AuxiliaryImageForIndex)
        {
          v17 = gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions(a2, *(unsigned int *)(a1 + 496), v9, 0, &cf);
          if (v17)
          {
            v18 = v17;
            v19 = IIOCMErrorString(v17);
            _cg_jpeg_mem_term("copyHDRGainMapDictionary", 1793, "*** CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions[%d]  err = %s [%d]\n", v9, v19, v18);
          }
          break;
        }
        v13 = IIOCMErrorString(AuxiliaryImageForIndex);
        _cg_jpeg_mem_term("copyHDRGainMapDictionary", 1785, "*** CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex[%d]  err = %s [%d]\n", v9, v13, AuxiliaryImageForIndex);
      }
LABEL_12:
      ++v9;
    }
    while (NumberOfAuxImages != v9);
  }
  if (cf == 0)
    return 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v15 = Mutable;
  if (*((_QWORD *)&cf + 1))
  {
    CFDictionarySetValue(Mutable, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap, *((const void **)&cf + 1));
    CFRelease(*((CFTypeRef *)&cf + 1));
  }
  if ((_QWORD)cf)
  {
    CFDictionarySetValue(v15, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata, (const void *)cf);
    CFRelease((CFTypeRef)cf);
  }
  return v15;
}

uint64_t HEIFReadPlugin::createFlexGTCInfo(HEIFReadPlugin *this, IIODictionary *a2, id *a3)
{
  char v6;
  uint64_t FlexGTCInfo;
  CFTypeID v8;
  CFTypeRef v9;
  IIODictionary *v10;
  const __CFDictionary *ObjectForKey;
  _BYTE v13[24];
  _BYTE v14[24];
  uint64_t v15;
  void *v16;
  uint64_t v17;
  CFTypeRef v18;
  CFTypeRef cf;
  void *value;
  const __CFDictionary *v21;
  __IOSurface *v22;

  IIO_LoadHEIFSymbols();
  v21 = 0;
  v22 = 0;
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s\n", "createFlexGTCInfo");
  v6 = *((_BYTE *)this + 484);
  *((_BYTE *)this + 484) = 0;
  FlexGTCInfo = (*(uint64_t (**)(HEIFReadPlugin *, _QWORD, _QWORD, __IOSurface **, const __CFDictionary **))(*(_QWORD *)this + 216))(this, 0, *((_QWORD *)a2 + 1), &v22, &v21);
  if (v22)
  {
    if ((gIIODebugFlags & 0x2000000) != 0)
      LogSurfaceFormat(v22, "inputSurface", "createFlexGTCInfo", 1837);
    if (v21)
    {
      value = 0;
      v18 = 0;
      cf = 0;
      CFDictionaryGetValueIfPresent(v21, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap, (const void **)&value);
      CFDictionaryGetValueIfPresent(v21, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata, &cf);
      if (cf)
      {
        v8 = CFGetTypeID(cf);
        if (v8 == CFDictionaryGetTypeID())
        {
          CGImageCreateFlexRangeMetadata((uint64_t)cf, (uint64_t *)&v18);
          v9 = v18;
        }
        else
        {
          v9 = CFRetain(cf);
          v18 = v9;
        }
        IIODictionary::setObjectForKey(a2, v9, CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
        CFRelease(v18);
      }
      v10 = (IIODictionary *)*((_QWORD *)this + 7);
      if (v10 && (ObjectForKey = IIODictionary::getObjectForKey(v10, CFSTR("{MakerApple}"))) != 0)
      {
        IIODictionary::setObjectForKey(a2, ObjectForKey, CFSTR("{MakerApple}"));
      }
      else
      {
        v15 = 0;
        v16 = 0;
        v17 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v15);
        IIONumber::IIONumber((IIONumber *)v14, *((float *)this + 125));
        IIODictionary::setObjectForKey((uint64_t)&v15, (uint64_t)v14, CFSTR("33"));
        IIONumber::~IIONumber((IIONumber *)v14);
        IIONumber::IIONumber((IIONumber *)v13, *((float *)this + 126));
        IIODictionary::setObjectForKey((uint64_t)&v15, (uint64_t)v13, CFSTR("48"));
        IIONumber::~IIONumber((IIONumber *)v13);
        IIODictionary::setObjectForKey(a2, v16, CFSTR("{MakerApple}"));
        IIODictionary::~IIODictionary((IIODictionary *)&v15);
      }
      if ((gIIODebugFlags & 0x300000) != 0)
        ImageIOLog("☀️  'IIOCallCreateFlexGTCInfo'\n");
      FlexGTCInfo = IIOCallCreateFlexGTCInfo((uint64_t)v22, (uint64_t)value, a3, *((void **)a2 + 1));
      CFRelease(v21);
    }
    else
    {
      _cg_jpeg_mem_term("createFlexGTCInfo", 1880, "*** ERROR: createFlexGTCInfo - failed to extract gainMap\n");
      FlexGTCInfo = 4294967246;
    }
    CFRelease(v22);
  }
  *((_BYTE *)this + 484) = v6;
  return FlexGTCInfo;
}

void sub_18802F8E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::copyImageBlockSetTiles(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary **a4, unsigned int a5, double a6, double a7, double a8, double a9, uint64_t a10, _DWORD *a11)
{
  double v16;
  uint64_t v17;
  double v20;
  double v21;
  double v22;
  double v23;
  unsigned int PixelSize;
  unsigned int v25;
  unsigned int v26;
  double v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint32x2_t v32;
  int v33;
  int v34;
  const char *v35;
  _BOOL4 v36;
  char *v37;
  CFDataRef v38;
  IIOImageRead *Size;
  IIOImageRead *v40;
  const UInt8 *v41;
  uint64_t v42;
  CFDataRef v43;
  int v44;
  int v45;
  const char *v46;
  char v47;
  unsigned int PixelFormatForBitDepth;
  unsigned int v49;
  unsigned int v50;
  double v51;
  double v52;
  double v53;
  unsigned int v54;
  double v55;
  double v56;
  double v57;
  unsigned int v58;
  double v59;
  double v60;
  double v61;
  double v62;
  CFDictionaryRef DictionaryRepresentation;
  __n128 v64;
  int v65;
  int v66;
  int IsPlanar;
  int PixelFormatType;
  int v69;
  unsigned int v70;
  int v71;
  char *BaseAddress;
  unint64_t BytesPerRow;
  unint64_t Height;
  __n128 v75;
  unint64_t v76;
  size_t v77;
  int v78;
  char *v79;
  vImagePixelCount v80;
  vImagePixelCount v81;
  int8x16_t v82;
  uint64_t v83;
  unsigned int v84;
  int v85;
  uint64_t v86;
  unsigned int v87;
  int v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  __n128 v92;
  double v93;
  double v94;
  double v95;
  char v96;
  const char *v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  int v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  double v105;
  IIOImageRead **v106;
  CFDataRef v107;
  uint64_t v108;
  const char **v109;
  _BOOL4 v111;
  _DWORD *v112;
  _DWORD *v113;
  _DWORD *v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  uint64_t v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  CFDataRef v122;
  unsigned int v123;
  unsigned int v125;
  unsigned int v126;
  const void *v127;
  uint64_t v128;
  _QWORD *v129;
  char v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int v133;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  _BYTE v136[24];
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  void *v141;
  int v142;
  CFTypeRef v143;
  CFTypeRef v144;
  size_t v145[2];
  CGRect v146;
  CGRect v147;

  v16 = a6;
  v17 = a3;
  v144 = 0;
  *a11 = 0;
  if (a3)
  {
    CGImageProviderGetSize();
    v21 = v20;
    v23 = v22;
    PixelSize = CGImageProviderGetPixelSize();
  }
  else
  {
    LODWORD(a6) = *(_DWORD *)(a1 + 292);
    v21 = (double)*(unint64_t *)&a6;
    LODWORD(a6) = *(_DWORD *)(a1 + 296);
    v23 = (double)*(unint64_t *)&a6;
    PixelSize = *(unsigned __int16 *)(a1 + 308);
  }
  v145[0] = 0;
  if ((a5 & 0x1FF) != 0)
    v25 = 512;
  else
    v25 = a5;
  if (!v25)
  {
    v108 = 0;
    v36 = 0;
    v37 = 0;
    goto LABEL_135;
  }
  v127 = a2;
  v128 = v17;
  v26 = (v16 / (double)v25);
  v27 = (double)(v25 - 1);
  v28 = ((v16 + a8 + v27) / (double)v25);
  v29 = (a7 / (double)v25);
  v30 = ((a7 + a9 + v27) / (double)v25);
  v31 = v30 - v29;
  v32 = vmin_u32((uint32x2_t)vdup_n_s32(v25), *(uint32x2_t *)(a1 + 228));
  *(uint32x2_t *)(a1 + 292) = v32;
  *(_DWORD *)(a1 + 236) = 16 * (unint64_t)((a8 * (double)PixelSize + 15.0) * 0.0625);
  *(_DWORD *)(a1 + 300) = v32.i32[0] * PixelSize;
  *(_DWORD *)(a1 + 104) = (v28 - v26) * (v30 - v29);
  v33 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v144);
  if (v33)
  {
    v34 = v33;
    v35 = IIOCMErrorString(v33);
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2720, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v35, v34);
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v17 = v128;
LABEL_132:
    v108 = IIOReadPlugin::imageBlockSetCreate(a1, v17, *(unsigned int *)(a1 + 104), *(double *)(a1 + 136), *(double *)(a1 + 144), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), v127);
    v107 = v38;
    goto LABEL_133;
  }
  v129 = (_QWORD *)(a1 + 292);
  v125 = (v16 / (double)v25);
  v126 = v30;
  v131 = (a7 / (double)v25);
  v132 = v25;
  v133 = v28;
  v143 = 0;
  v142 = 0;
  v141 = 0;
  Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
  v40 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v141, 1);
  if (!v40)
  {
    LogError("copyImageBlockSetTiles", 2733, "*** ERROR: retainBytePointer failed\n");
    v108 = 0;
    v36 = 0;
    v37 = 0;
    v17 = v128;
    goto LABEL_135;
  }
  v41 = (const UInt8 *)v40;
  v42 = *(_QWORD *)(a1 + 456);
  v17 = v128;
  if (v42)
  {
    if (*(_QWORD *)(a1 + 464))
      Size = *(IIOImageRead **)(a1 + 464);
    else
      v42 = 0;
    v41 = (const UInt8 *)v40 + v42;
  }
  v43 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v41, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v122 = v43;
  if (!v43)
    goto LABEL_19;
  v44 = gFunc_CMPhotoDecompressionSessionCreateContainer(v144, 0, v43, &v142, &v143);
  if (v44)
  {
    v45 = v44;
    v46 = IIOCMErrorString(v44);
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2749, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v46, v45);
LABEL_19:
    v37 = 0;
    v36 = 0;
    v47 = 1;
    goto LABEL_127;
  }
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  v111 = IIOImageReadSession::mapData(*(IIOImageRead ***)(a1 + 24));
  v138 = 0;
  v139 = 0;
  v140 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v138);
  v137 = 0;
  PixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
  HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)a1, (IIODictionary *)&v138, a4);
  IIONumber::IIONumber((IIONumber *)v136, PixelFormatForBitDepth);
  IIODictionary::setObjectForKey((uint64_t)&v138, (uint64_t)v136, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
  IIONumber::~IIONumber((IIONumber *)v136);
  HEIFReadPlugin::updateCreateImageOptions((HEIFReadPlugin *)a1, (IIODictionary *)&v138, *(IIODictionary **)(a1 + 48));
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    copyImageBlockSetTiles - decoding %d x %d tiles\n", v31, v28 - v26);
  if (v126 <= v29)
  {
    v37 = 0;
    v130 = 1;
  }
  else
  {
    v37 = 0;
    v49 = 0;
    v119 = HIBYTE(PixelFormatForBitDepth);
    v118 = MEMORY[0x1E0C80978] + 60 + 4 * HIBYTE(PixelFormatForBitDepth);
    v121 = (int)(PixelFormatForBitDepth << 8) >> 24;
    v120 = (__int16)PixelFormatForBitDepth >> 8;
    v113 = (_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * v120);
    v114 = (_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * v121);
    v116 = PixelFormatForBitDepth << 16;
    v117 = PixelFormatForBitDepth << 8;
    v123 = (char)PixelFormatForBitDepth;
    v115 = PixelFormatForBitDepth << 24;
    v112 = (_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * (char)PixelFormatForBitDepth);
    v130 = 1;
    do
    {
      v50 = *(_DWORD *)(a1 + 296);
      v51 = (double)(v50 * v131);
      v52 = (double)v50;
      if ((double)v50 + v51 <= v23)
        v53 = (double)v50;
      else
        v53 = v23 - (double)(v50 * v131);
      v54 = v125;
      if (v133 <= v125)
      {
LABEL_94:
        v96 = 1;
      }
      else
      {
        while (1)
        {
          v55 = (double)(v54 * v132);
          LODWORD(v52) = *(_DWORD *)(a1 + 292);
          v56 = (double)*(unint64_t *)&v52;
          if (v55 + v56 <= v21)
            v57 = v56;
          else
            v57 = v21 - (double)(v54 * v132);
          v37 = (char *)_ImageIO_Malloc(*(unsigned int *)(a1 + 300) * (unint64_t)*(unsigned int *)(a1 + 296), *(_QWORD *)(a1 + 384), v145, (uint64_t)kImageMalloc_HEIF_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
          if (!v37)
          {
            IIODictionary::~IIODictionary((IIODictionary *)&v138);
            v108 = 0;
            v17 = v128;
            v107 = v122;
            v36 = v111;
            goto LABEL_133;
          }
          v58 = *(unsigned __int16 *)(a1 + 316);
          v59 = v58 >= 2 ? v55 * (double)v58 : (double)(v54 * v132);
          v60 = v58 >= 2 ? v51 * (double)v58 : v51;
          v61 = v58 >= 2 ? v57 * (double)v58 : v57;
          v62 = v58 >= 2 ? v53 * (double)v58 : v53;
          DictionaryRepresentation = CGRectCreateDictionaryRepresentation(*(CGRect *)&v59);
          IIODictionary::setObjectForKey((IIODictionary *)&v138, DictionaryRepresentation, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_SourceCropRect);
          CFRelease(DictionaryRepresentation);
          v65 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v143, *(unsigned int *)(a1 + 496), v139, 2, &v137, v64);
          v66 = v65;
          if (v65)
            break;
          gFunc_CVPixelBufferLockBaseAddress(v137, 0);
          IsPlanar = gFunc_CVPixelBufferIsPlanar(v137);
          PixelFormatType = gFunc_CVPixelBufferGetPixelFormatType(v137);
          v69 = PixelFormatType;
          if (IsPlanar)
          {
            v70 = PixelFormatType >> 24;
            if (PixelFormatType < 0)
              v71 = __maskrune(PixelFormatType >> 24, 0x40000uLL);
            else
              v71 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v70 + 60) & 0x40000;
            if (v71)
              v83 = v70;
            else
              v83 = 46;
            v84 = v69 << 8 >> 24;
            if (v69 << 8 < 0)
              v85 = __maskrune(v69 << 8 >> 24, 0x40000uLL);
            else
              v85 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v84 + 60) & 0x40000;
            if (v85)
              v86 = v84;
            else
              v86 = 46;
            v87 = (__int16)v69 >> 8;
            if (v69 << 16 < 0)
              v88 = __maskrune((__int16)v69 >> 8, 0x40000uLL);
            else
              v88 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v87 + 60) & 0x40000;
            if ((v69 << 24) <= 0x7F000000)
              v89 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v69 + 60) & 0x40000;
            else
              v89 = __maskrune((char)v69, 0x40000uLL);
            if (v88)
              v90 = v87;
            else
              v90 = 46;
            if (v89)
              v91 = (char)v69;
            else
              v91 = 46;
            v75 = _cg_jpeg_mem_term("copyImageBlockSetTiles", 2844, "*** '%c%c%c%c' request returned planar data - not handled\n", v83, v86, v90, v91);
          }
          else
          {
            BaseAddress = (char *)gFunc_CVPixelBufferGetBaseAddress(v137);
            BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(v137);
            Height = gFunc_CVPixelBufferGetHeight(v137);
            v76 = *(unsigned int *)(a1 + 300);
            if (BytesPerRow >= v76)
              v77 = *(unsigned int *)(a1 + 300);
            else
              v77 = BytesPerRow;
            if (Height >= *(unsigned int *)(a1 + 296))
              v78 = *(_DWORD *)(a1 + 296);
            else
              v78 = Height;
            if (v78)
            {
              v79 = v37;
              do
              {
                memcpy(v79, BaseAddress, v77);
                v76 = *(unsigned int *)(a1 + 300);
                v79 += v76;
                BaseAddress += BytesPerRow;
                --v78;
              }
              while (v78);
            }
            if (v69 == 1111970369 && *(_BYTE *)(a1 + 404) == 1)
              goto LABEL_151;
            v80 = *(unsigned int *)v129;
            if (v76 >= 4 * (int)v80)
            {
              v81 = *(unsigned int *)(a1 + 296);
              dest.data = v37;
              dest.height = v81;
              dest.width = v80;
              dest.rowBytes = v76;
              *(_DWORD *)permuteMap = 50331906;
              vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0);
            }
            if (*(_BYTE *)(a1 + 404) == 1)
            {
LABEL_151:
              if (*(_BYTE *)(a1 + 492) && !*(_BYTE *)(a1 + 493))
              {
                dest.data = v37;
                v82.i64[0] = *v129;
                v82.i64[1] = HIDWORD(*v129);
                *(int8x16_t *)&dest.height = vextq_s8(v82, v82, 8uLL);
                dest.rowBytes = *(unsigned int *)(a1 + 300);
                vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
              }
            }
            v130 = 1;
          }
          v92.n128_f64[0] = gFunc_CVPixelBufferUnlockBaseAddress(v137, 0, v75);
          gFunc_CVPixelBufferRelease(v92);
          v146.origin.x = (double)(v54 * v132);
          v146.origin.y = v51;
          v146.size.width = v57;
          v146.size.height = v53;
          *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v49) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v37, v145[0], v146, *(unsigned int *)(a1 + 300), 0);
          if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
          {
            v93 = v51;
            v94 = v53;
          }
          else
          {
            v147.origin.x = (double)(v54 * v132);
            v147.origin.y = v51;
            v147.size.width = v57;
            v147.size.height = v53;
            *(CGRect *)&v52 = CGRectUnion(*(CGRect *)(a1 + 120), v147);
            v55 = v52;
            v57 = v95;
          }
          *(double *)(a1 + 120) = v55;
          *(double *)(a1 + 128) = v93;
          *(double *)(a1 + 136) = v57;
          *(double *)(a1 + 144) = v94;
          ++v49;
          if (++v54 == v133)
          {
            v37 = 0;
            goto LABEL_94;
          }
        }
        if (v65 == -15470)
        {
          if (v128)
            CGImageProviderSetProperty();
          v96 = 0;
        }
        else
        {
          v96 = 1;
        }
        v97 = IIOCMErrorString(v66);
        _cg_jpeg_mem_term("copyImageBlockSetTiles", 2830, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v97, v66);
        if ((*(_BYTE *)(v118 + 2) & 4) != 0)
          v98 = v119;
        else
          v98 = 46;
        if ((v117 & 0x80000000) != 0)
          v99 = __maskrune(v121, 0x40000uLL);
        else
          v99 = *v114 & 0x40000;
        if (v99)
          v100 = v121;
        else
          v100 = 46;
        if ((v116 & 0x80000000) != 0)
          v101 = __maskrune(v120, 0x40000uLL);
        else
          v101 = *v113 & 0x40000;
        if (v115 <= 0x7F000000)
          v102 = *v112 & 0x40000;
        else
          v102 = __maskrune(v123, 0x40000uLL);
        if (v101)
          v103 = v120;
        else
          v103 = 46;
        if (v102)
          v104 = v123;
        else
          v104 = 46;
        *(_QWORD *)&v105 = _cg_jpeg_mem_term("copyImageBlockSetTiles", 2831, "    outputPixelFormat: %c%c%c%c\n", v98, v100, v103, v104).n128_u64[0];
        _cg_jpeg_mem_term(v139, 4, "cmPhotoContainer", v105);
        v130 = 0;
      }
      ++v131;
    }
    while (v131 < v126 && (v96 & 1) != 0);
  }
  CFRelease(v143);
  v17 = v128;
  IIODictionary::~IIODictionary((IIODictionary *)&v138);
  v47 = v130 & 1;
  v36 = v111;
LABEL_127:
  gFunc_CMPhotoDecompressionSessionFlushCachedBuffers(v144, 0, 0);
  CFRelease(v144);
  if (v141)
  {
    v106 = *(IIOImageRead ***)(a1 + 24);
    if (v106)
      IIOImageReadSession::releaseBytePointer(v106, v141);
  }
  v107 = v122;
  if ((v47 & 1) != 0)
  {
    v38 = v122;
    goto LABEL_132;
  }
  v108 = 0;
LABEL_133:
  if (v107)
    CFRelease(v107);
LABEL_135:
  if (v17)
  {
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  }
  else if (*(_DWORD *)(a1 + 104))
  {
    *a11 = 1;
  }
  if (v36)
  {
    v109 = *(const char ***)(a1 + 24);
    if (v109)
      IIOImageReadSession::unmapData(v109);
  }
  if (v37)
    _ImageIO_Free((unint64_t)v37, v145[0]);
  return v108;
}

void sub_188030438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  uint64_t v38;

  IIONumber::~IIONumber((IIONumber *)&a38);
  IIODictionary::~IIODictionary((IIODictionary *)(v38 - 200));
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::copyImageBlockSetSingleTile(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary **a4, _DWORD *a5, double x, double y, double width, double a9)
{
  _DWORD *v9;
  unsigned int PixelSize;
  _BOOL4 v18;
  double v19;
  char *v20;
  int v21;
  int v22;
  const char *v23;
  uint64_t v24;
  IIOImageRead *Size;
  IIOImageRead *v26;
  const UInt8 *v27;
  uint64_t v28;
  CFDataRef v29;
  int v30;
  int v31;
  const char *v32;
  BOOL v33;
  unsigned int PixelFormatForBitDepth;
  unsigned int v35;
  double v36;
  double v37;
  double v38;
  double v39;
  int v40;
  unsigned int v41;
  CFDictionaryRef DictionaryRepresentation;
  __n128 v43;
  int v44;
  int v45;
  const char *v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  int v50;
  int IsPlanar;
  int PixelFormatType;
  __n128 v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  double v60;
  int v61;
  char *BaseAddress;
  unint64_t BytesPerRow;
  unint64_t Height;
  unint64_t v65;
  size_t v66;
  int v67;
  char *v68;
  _QWORD *v69;
  vImagePixelCount v70;
  vImagePixelCount v71;
  int8x16_t v72;
  __n128 v73;
  IIOImageRead **v74;
  const char **v75;
  uint64_t v77;
  int v78;
  uint64_t v79;
  _BOOL4 v80;
  CFDataRef cf;
  _DWORD *v82;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  _BYTE v86[24];
  _BYTE v87[24];
  _BYTE v88[24];
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  void *v93;
  int v94;
  CFTypeRef v95;
  CFTypeRef v96;
  size_t v97[2];
  CGRect v98;
  CGRect v99;
  CGRect v100;

  v9 = a5;
  v96 = 0;
  *a5 = 0;
  if (a3)
    PixelSize = CGImageProviderGetPixelSize();
  else
    PixelSize = *(unsigned __int16 *)(a1 + 308);
  v97[0] = 0;
  *(_DWORD *)(a1 + 104) = 1;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, 1uLL);
  v18 = IIOImageReadSession::mapData(*(IIOImageRead ***)(a1 + 24));
  *(_DWORD *)(a1 + 292) = width;
  *(_DWORD *)(a1 + 296) = a9;
  v19 = width * (double)PixelSize;
  *(_DWORD *)(a1 + 300) = (unint64_t)v19;
  v20 = (char *)_ImageIO_Malloc((unint64_t)v19 * (unint64_t)a9, *(_QWORD *)(a1 + 384), v97, (uint64_t)kImageMalloc_HEIF_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
  if (!v20)
  {
LABEL_7:
    if (a3)
    {
LABEL_8:
      v24 = 0;
      goto LABEL_9;
    }
    goto LABEL_86;
  }
  v21 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v96);
  if (v21)
  {
    v22 = v21;
    v23 = IIOCMErrorString(v21);
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2462, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v23, v22);
    goto LABEL_7;
  }
  v82 = v9;
  v95 = 0;
  v94 = 0;
  v93 = 0;
  Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
  v26 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v93, 1);
  v27 = (const UInt8 *)v26;
  v28 = *(_QWORD *)(a1 + 456);
  if (v28)
  {
    if (*(_QWORD *)(a1 + 464))
      Size = *(IIOImageRead **)(a1 + 464);
    else
      v28 = 0;
    v27 = (const UInt8 *)v26 + v28;
  }
  if (v27)
  {
    v29 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v27, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    if (v29)
    {
      cf = v29;
      v30 = gFunc_CMPhotoDecompressionSessionCreateContainer(v96, 0, v29, &v94, &v95);
      if (v30)
      {
        v31 = v30;
        v32 = IIOCMErrorString(v30);
        _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2491, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v32, v31);
        v33 = 0;
      }
      else
      {
        v90 = 0;
        v91 = 0;
        v92 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v90);
        v89 = 0;
        PixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
        if (CGImageProviderGetComponentType() == 6)
          v35 = 1815162994;
        else
          v35 = PixelFormatForBitDepth;
        HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)a1, (IIODictionary *)&v90, a4);
        IIONumber::IIONumber((IIONumber *)v88, v35);
        IIODictionary::setObjectForKey((uint64_t)&v90, (uint64_t)v88, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
        IIONumber::~IIONumber((IIONumber *)v88);
        HEIFReadPlugin::updateCreateImageOptions((HEIFReadPlugin *)a1, (IIODictionary *)&v90, *(IIODictionary **)(a1 + 48));
        v36 = a9;
        v37 = width;
        v38 = y;
        v39 = x;
        if (*(_WORD *)(a1 + 316))
        {
          IIONumber::IIONumber((IIONumber *)v87, *(_DWORD *)(a1 + 476));
          IIODictionary::setObjectForKey((uint64_t)&v90, (uint64_t)v87, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
          IIONumber::~IIONumber((IIONumber *)v87);
          v40 = *(_DWORD *)(a1 + 292) <= *(_DWORD *)(a1 + 296) ? *(_DWORD *)(a1 + 296) : *(_DWORD *)(a1 + 292);
          IIONumber::IIONumber((IIONumber *)v86, v40);
          IIODictionary::setObjectForKey((uint64_t)&v90, (uint64_t)v86, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
          IIONumber::~IIONumber((IIONumber *)v86);
          v36 = a9;
          v41 = *(unsigned __int16 *)(a1 + 316);
          v37 = width;
          v38 = y;
          v39 = x;
          if (v41 >= 2)
          {
            v39 = x * (double)v41;
            v38 = y * (double)v41;
            v37 = width * (double)v41;
            v36 = a9 * (double)v41;
          }
        }
        DictionaryRepresentation = CGRectCreateDictionaryRepresentation(*(CGRect *)&v39);
        IIODictionary::setObjectForKey((IIODictionary *)&v90, DictionaryRepresentation, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_SourceCropRect);
        CFRelease(DictionaryRepresentation);
        v44 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v95, *(unsigned int *)(a1 + 496), v91, 2, &v89, v43);
        v45 = v44;
        if (v44)
        {
          v46 = IIOCMErrorString(v44);
          _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2538, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v46, v45);
          LODWORD(v47) = HIBYTE(v35);
          if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * HIBYTE(v35) + 60) & 0x40000) != 0)
            v47 = v47;
          else
            v47 = 46;
          v79 = v47;
          v48 = (int)(v35 << 8) >> 24;
          v49 = MEMORY[0x1E0C80978];
          if (((v35 << 8) & 0x80000000) != 0)
            v50 = __maskrune((int)(v35 << 8) >> 24, 0x40000uLL);
          else
            v50 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v48 + 60) & 0x40000;
          if (v50)
            v54 = v48;
          else
            v54 = 46;
          v77 = v54;
          v55 = (__int16)v35 >> 8;
          if (((v35 << 16) & 0x80000000) != 0)
            v56 = __maskrune((__int16)v35 >> 8, 0x40000uLL);
          else
            v56 = *(_DWORD *)(v49 + 4 * v55 + 60) & 0x40000;
          if (v35 << 24 <= 0x7F000000)
            v57 = *(_DWORD *)(v49 + 4 * (char)v35 + 60) & 0x40000;
          else
            v57 = __maskrune((char)v35, 0x40000uLL);
          if (v56)
            v58 = v55;
          else
            v58 = 46;
          if (v57)
            v59 = (char)v35;
          else
            v59 = 46;
          *(_QWORD *)&v60 = _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2539, "    outputPixelFormat: %c%c%c%c\n", v79, v77, v58, v59).n128_u64[0];
          _cg_jpeg_mem_term(v91, 4, "cmPhotoContainer", v60);
          v33 = 0;
        }
        else
        {
          gFunc_CVPixelBufferLockBaseAddress(v89, 0);
          IsPlanar = gFunc_CVPixelBufferIsPlanar(v89);
          v33 = IsPlanar == 0;
          PixelFormatType = gFunc_CVPixelBufferGetPixelFormatType(v89);
          if (IsPlanar)
          {
            v53 = _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2550, "*** 'BGRA' request returned planar data - not handled\n");
          }
          else
          {
            v61 = PixelFormatType;
            BaseAddress = (char *)gFunc_CVPixelBufferGetBaseAddress(v89);
            BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(v89);
            v78 = v61;
            v80 = v18;
            Height = gFunc_CVPixelBufferGetHeight(v89);
            v65 = *(unsigned int *)(a1 + 300);
            if (BytesPerRow >= v65)
              v66 = *(unsigned int *)(a1 + 300);
            else
              v66 = BytesPerRow;
            if (Height >= *(unsigned int *)(a1 + 296))
              v67 = *(_DWORD *)(a1 + 296);
            else
              v67 = Height;
            if (v67)
            {
              v68 = v20;
              do
              {
                memcpy(v68, BaseAddress, v66);
                v65 = *(unsigned int *)(a1 + 300);
                v68 += v65;
                BaseAddress += BytesPerRow;
                --v67;
              }
              while (v67);
            }
            v69 = (_QWORD *)(a1 + 292);
            v18 = v80;
            if (v78 == 1111970369 && *(_BYTE *)(a1 + 404) != 1)
            {
              v70 = *(unsigned int *)v69;
              if (v65 >= 4 * (int)v70)
              {
                v71 = *(unsigned int *)(a1 + 296);
                dest.data = v20;
                dest.height = v71;
                dest.width = v70;
                dest.rowBytes = v65;
                *(_DWORD *)permuteMap = 50331906;
                vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
              }
            }
            if (*(_BYTE *)(a1 + 404) == 1 && *(_BYTE *)(a1 + 492) && !*(_BYTE *)(a1 + 493))
            {
              dest.data = v20;
              v72.i64[0] = *v69;
              v72.i64[1] = HIDWORD(*v69);
              *(int8x16_t *)&dest.height = vextq_s8(v72, v72, 8uLL);
              dest.rowBytes = *(unsigned int *)(a1 + 300);
              vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
            }
          }
          v73.n128_f64[0] = gFunc_CVPixelBufferUnlockBaseAddress(v89, 0, v53);
          gFunc_CVPixelBufferRelease(v73);
        }
        CFRelease(v95);
        IIODictionary::~IIODictionary((IIODictionary *)&v90);
      }
      CFRelease(v96);
      CFRelease(cf);
    }
    else
    {
      CFRelease(v96);
      v33 = 0;
    }
    if (v93)
    {
      v74 = *(IIOImageRead ***)(a1 + 24);
      if (v74)
        IIOImageReadSession::releaseBytePointer(v74, v93);
    }
    if (v33)
    {
      v98.origin.x = x;
      v98.origin.y = y;
      v98.size.width = width;
      v98.size.height = a9;
      **(_QWORD **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v20, v97[0], v98, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
      if (!CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
      {
        v100.origin.x = x;
        v100.origin.y = y;
        v100.size.width = width;
        v100.size.height = a9;
        v99 = CGRectUnion(*(CGRect *)(a1 + 120), v100);
        x = v99.origin.x;
        y = v99.origin.y;
        width = v99.size.width;
        a9 = v99.size.height;
      }
      *(double *)(a1 + 120) = x;
      *(double *)(a1 + 128) = y;
      *(double *)(a1 + 136) = width;
      *(double *)(a1 + 144) = a9;
      v9 = v82;
      if (a3)
      {
        v24 = IIOReadPlugin::imageBlockSetCreate(a1, a3, *(unsigned int *)(a1 + 104), width, a9, x, y, width, a9, *(_QWORD *)(a1 + 96), a2);
        v20 = 0;
LABEL_9:
        IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
        if (!v18)
          goto LABEL_92;
        goto LABEL_90;
      }
      v20 = 0;
      goto LABEL_86;
    }
  }
  else
  {
    LogError("copyImageBlockSetSingleTile", 2481, "*** ERROR: retainBytePointer failed\n");
  }
  v9 = v82;
  if (a3)
    goto LABEL_8;
LABEL_86:
  if (*(_DWORD *)(a1 + 104))
  {
    v24 = 0;
    *v9 = 1;
    if (!v18)
      goto LABEL_92;
  }
  else
  {
    v24 = 0;
    if (!v18)
      goto LABEL_92;
  }
LABEL_90:
  v75 = *(const char ***)(a1 + 24);
  if (v75)
    IIOImageReadSession::unmapData(v75);
LABEL_92:
  if (v20)
    _ImageIO_Free((unint64_t)v20, v97[0]);
  return v24;
}

void sub_188030CE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 184));
  _Unwind_Resume(a1);
}

__IOSurface *HEIFReadPlugin::createSurfaceWithGainMapApplied(uint64_t a1, uint64_t a2, uint64_t a3, GlobalHEIFInfo *a4, __IOSurface *a5)
{
  double Current;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  size_t Width;
  size_t Height;
  const __CFString *v14;
  int v15;
  __IOSurface *IOSurfaceWithFormat;
  __IOSurface *v17;
  CGImageAlphaInfo Alpha;
  CGColorSpaceRef v19;
  CGColorSpace *v20;
  CFPropertyListRef v21;
  float v22;
  float v23;
  CFTypeID v24;
  CFTypeRef v25;
  const __CFDictionary *ObjectForKey;
  int v27;
  CFAbsoluteTime v28;
  _BYTE v30[24];
  _BYTE v31[24];
  _BYTE v32[24];
  _BYTE v33[24];
  _BYTE v34[24];
  CGColorSpaceRef space;
  void *value;
  CFTypeRef v37;
  void *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;

  v39 = 0;
  v40 = 0;
  v41 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v39);
  v37 = 0;
  v38 = 0;
  space = 0;
  value = 0;
  Current = CFAbsoluteTimeGetCurrent();
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s\n", "createSurfaceWithGainMapApplied");
  if (*(_BYTE *)(a1 + 487))
    v10 = (const __CFDictionary *)HEIFReadPlugin::copyISOGainMapDictionary(a1, a2);
  else
    v10 = HEIFReadPlugin::copyHDRGainMapDictionary(a1, a2, a4, (uint64_t)&v39);
  v11 = v10;
  if (!v10)
  {
    v17 = 0;
    goto LABEL_38;
  }
  CFDictionaryGetValueIfPresent(v10, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap, (const void **)&value);
  CFDictionaryGetValueIfPresent(v11, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata, (const void **)&v38);
  CFDictionaryGetValueIfPresent(v11, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace, (const void **)&space);
  if (!value)
    goto LABEL_36;
  Width = IOSurfaceGetWidth(a5);
  Height = IOSurfaceGetHeight(a5);
  v14 = *(const __CFString **)(a1 + 512);
  v15 = *(_DWORD *)(a1 + 444);
  IOSurfaceWithFormat = IIO_CreateIOSurfaceWithFormat(Width, Height, 0, *(_DWORD *)(a1 + 440), 0, *(unsigned int *)(a1 + 432));
  v17 = IOSurfaceWithFormat;
  if ((gIIODebugFlags & 0x2000000) != 0)
    LogSurfaceFormat(IOSurfaceWithFormat, "outputSurface", "createSurfaceWithGainMapApplied", 3444);
  Alpha = IIO_IOSurfaceGetAlpha(a5);
  IIO_IOSurfaceSetAlpha(v17, Alpha);
  if (*(_BYTE *)(a1 + 488) && CGColorSpaceContainsFlexGTCInfo())
  {
    v19 = CGColorSpaceRetain(*(CGColorSpaceRef *)(a1 + 160));
  }
  else
  {
    v20 = CGColorSpaceCreateWithName(v14);
    if (v20)
      goto LABEL_18;
    v20 = CGColorSpaceRetain(space);
    if (v20)
      goto LABEL_18;
    v19 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9C8]);
  }
  v20 = v19;
LABEL_18:
  v21 = CGColorSpaceCopyPropertyList(v20);
  if (v21)
  {
    IOSurfaceSetValue(v17, (CFStringRef)*MEMORY[0x1E0CBBF90], v21);
    CFRelease(v21);
  }
  CGColorSpaceRelease(v20);
  if ((v15 - 1) <= 2)
    IOSurfaceSetYCbCrMatrix();
  v22 = *(float *)(a1 + 448);
  if (v22 > 0.0)
  {
    IIONumber::IIONumber((IIONumber *)v34, v22);
    IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v34, CFSTR("kCGTargetHeadroom"));
    IIONumber::~IIONumber((IIONumber *)v34);
  }
  v23 = *(float *)(a1 + 452);
  if (v23 > 0.0)
  {
    IIONumber::IIONumber((IIONumber *)v33, v23);
    IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v33, CFSTR("kCGFallbackHDRGain"));
    IIONumber::~IIONumber((IIONumber *)v33);
  }
  IIONumber::IIONumber((IIONumber *)v32, *(unsigned __int8 *)(a1 + 489));
  IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v32, CFSTR("kCGDisableMetal"));
  IIONumber::~IIONumber((IIONumber *)v32);
  IIONumber::IIONumber((IIONumber *)v31, *(unsigned __int8 *)(a1 + 488));
  IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v31, CFSTR("kCGGenerateFlexGTC"));
  IIONumber::~IIONumber((IIONumber *)v31);
  IIONumber::IIONumber((IIONumber *)v30, *(_DWORD *)(a1 + 472));
  IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v30, CFSTR("Orientation"));
  IIONumber::~IIONumber((IIONumber *)v30);
  if (v38)
  {
    v24 = CFGetTypeID(v38);
    if (v24 == CFDictionaryGetTypeID())
    {
      CGImageCreateFlexRangeMetadata((uint64_t)v38, (uint64_t *)&v37);
      v25 = v37;
    }
    else
    {
      v25 = CFRetain(v38);
      v37 = v25;
    }
    IIODictionary::setObjectForKey((IIODictionary *)&v39, v25, CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
    CFRelease(v37);
  }
  ObjectForKey = IIODictionary::getObjectForKey(*(IIODictionary **)(a1 + 56), CFSTR("{MakerApple}"));
  IIODictionary::setObjectForKey((IIODictionary *)&v39, ObjectForKey, CFSTR("{MakerApple}"));
  IIODictionary::setObjectForKey((IIODictionary *)&v39, space, CFSTR("kCGFlexRangeAlternateColorSpace"));
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  'IIOCallApplyHDRGainmap'\n");
  v27 = IIOCallApplyHDRGainmap(a5, (uint64_t)value, v17, v40);
  if (!v27)
    goto LABEL_37;
  _cg_jpeg_mem_term("createSurfaceWithGainMapApplied", 3513, "*** ERROR: IIOCallApplyHDRGainmap retuned %d\n", v27);
  if (!v17)
    goto LABEL_37;
  CFRelease(v17);
LABEL_36:
  v17 = 0;
LABEL_37:
  CFRelease(v11);
LABEL_38:
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    v28 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("☀️  %s [%g ms]\n", "createSurfaceWithGainMapApplied", (v28 - Current) * 1000.0);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v39);
  return v17;
}

void sub_1880311D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  va_list va;

  va_start(va, a12);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v12 - 120));
  _Unwind_Resume(a1);
}

__IOSurface *HEIFReadPlugin::createSurfaceWithToneMapApplied(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __IOSurface *a5, int a6, const __CFString *a7, int a8)
{
  double Current;
  const void **v13;
  size_t Width;
  size_t Height;
  __IOSurface *IOSurfaceWithFormat;
  __IOSurface *v17;
  CGColorSpace *v18;
  CFPropertyListRef v19;
  int v20;
  CFAbsoluteTime v21;
  uint64_t v23;
  void *v24;
  uint64_t v25;

  Current = CFAbsoluteTimeGetCurrent();
  v23 = 0;
  v24 = 0;
  v25 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v23);
  v13 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a8)
    v13 = (const void **)MEMORY[0x1E0C9AE40];
  IIODictionary::setObjectForKey((IIODictionary *)&v23, *v13, CFSTR("kCGDisableMetal"));
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  %s\n", "createSurfaceWithToneMapApplied");
  Width = IOSurfaceGetWidth(a5);
  Height = IOSurfaceGetHeight(a5);
  IOSurfaceWithFormat = IIO_CreateIOSurfaceWithFormat(Width, Height, 0, a6, 0, 0);
  v17 = IOSurfaceWithFormat;
  if ((gIIODebugFlags & 0x2000000) != 0)
    LogSurfaceFormat(IOSurfaceWithFormat, "outputSurface", "createSurfaceWithToneMapApplied", 3546);
  v18 = CGColorSpaceCreateWithName(a7);
  v19 = CGColorSpaceCopyPropertyList(v18);
  if (v19)
  {
    IOSurfaceSetValue(v17, (CFStringRef)*MEMORY[0x1E0CBBF90], v19);
    CFRelease(v19);
  }
  CGColorSpaceRelease(v18);
  if ((gIIODebugFlags & 0x300000) != 0)
    ImageIOLog("☀️  'IIOCallConvertHDRData'\n");
  v20 = IIOCallConvertHDRData(a5, v17, v24);
  if (v20)
  {
    _cg_jpeg_mem_term("createSurfaceWithToneMapApplied", 3560, "*** ERROR: IIOCallConvertHDRData retuned %d\n", v20);
    if (v17)
    {
      CFRelease(v17);
      v17 = 0;
    }
  }
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    v21 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("☀️  %s [%g ms]\n", "createSurfaceWithToneMapApplied", (v21 - Current) * 1000.0);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v23);
  return v17;
}

void sub_188031440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::decodeIntoIOSurface(HEIFReadPlugin *this, IIODecodeParameter *a2, __IOSurface *a3)
{
  const __CFDictionary *v6;
  uint64_t v7;
  IIOImageRead **v8;
  uint64_t v9;
  _BOOL4 v11;
  uint64_t v12;
  const char *v13;
  __n128 v14;
  const char **v15;
  IIOImageRead *Size;
  IIOImageRead *v17;
  const UInt8 *v18;
  uint64_t v19;
  uint64_t v20;
  CFDataRef v21;
  uint64_t v22;
  int v23;
  int v24;
  const char *v25;
  signed int PixelFormat;
  IIOImageRead *v27;
  int v28;
  const char *v29;
  __n128 v30;
  int v31;
  int v32;
  const char *v33;
  CFTypeRef *p_cf;
  uint64_t ThumbnailImageForIndex;
  const char *v36;
  unsigned int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  double v50;
  const char *v51;
  IIOImageRead **v52;
  _BYTE v53[24];
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  int v58;
  CFTypeRef cf;
  CFTypeRef v60;
  CFTypeRef v61;
  void *value;
  const __CFDictionary *v63[4];

  memset(v63, 0, 24);
  v6 = (const __CFDictionary *)IIOImageSource::reader(a2);
  IIODictionary::IIODictionary((IIODictionary *)v63, v6);
  v7 = *((_QWORD *)a2 + 2);
  value = 0;
  v8 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (!v8)
  {
LABEL_6:
    v9 = 4294967246;
    goto LABEL_7;
  }
  if (*((_BYTE *)this + 484) || *((_BYTE *)this + 485))
  {
    if ((gIIODebugFlags & 0x300000) != 0)
      ImageIOLog("☀️  ***ERROR: cannot applyGainMap / applyToneMap into a caller-provided IOSurface\n");
    goto LABEL_6;
  }
  v11 = IIOImageReadSession::mapData(v8);
  v61 = 0;
  if (!gFunc_CMPhotoDecompressionSessionCreate)
    _cg_jpeg_mem_term("decodeIntoIOSurface", 3023, "*** CMPhotoDecompressionSessionCreate symbol not found\n");
  v12 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v61);
  v9 = v12;
  if ((_DWORD)v12)
  {
    v13 = IIOCMErrorString(v12);
    v14 = _cg_jpeg_mem_term("decodeIntoIOSurface", 3030, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v13, v9);
    goto LABEL_12;
  }
  cf = 0;
  v60 = 0;
  v58 = 0;
  v57 = 0;
  Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  v17 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v57, 1);
  v18 = (const UInt8 *)v17;
  if (v17)
  {
    v19 = *((_QWORD *)this + 57);
    if (v19)
    {
      if (*((_QWORD *)this + 58))
        Size = (IIOImageRead *)*((_QWORD *)this + 58);
      else
        v19 = 0;
      v18 = (const UInt8 *)v17 + v19;
    }
    v20 = *MEMORY[0x1E0C9AE00];
    v21 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v18, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    if (v21)
    {
      v22 = gFunc_CMPhotoDecompressionSessionCreateContainer(v61, 0, v21, &v58, &v60);
      v9 = v22;
      if (!(_DWORD)v22 && v60)
      {
        v54 = 0;
        v55 = 0;
        v56 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v54);
        v23 = gFunc_CVPixelBufferCreateWithIOSurface(v20, a3, 0, &value);
        v24 = v23;
        if (v23)
        {
          v25 = IIOCMErrorString(v23);
          _cg_jpeg_mem_term("decodeIntoIOSurface", 3073, "*** CVPixelBufferCreateWithIOSurface  err = %s [%d]\n", v25, v24);
        }
        PixelFormat = IOSurfaceGetPixelFormat(a3);
        v27 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
        GlobalHEIFInfo::getHEIFMainImageAtIndex(v27, *((_DWORD *)this + 124));
        if (GlobalHEIFInfo::hasHEIFSequence(v27))
          v28 = IIOImageRead::trustedURL(v27);
        else
          v28 = 0;
        HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)this, (IIODictionary *)&v54, v63);
        IIONumber::IIONumber((IIONumber *)v53, PixelFormat);
        IIODictionary::setObjectForKey((uint64_t)&v54, (uint64_t)v53, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
        IIONumber::~IIONumber((IIONumber *)v53);
        IIODictionary::setObjectForKey((IIODictionary *)&v54, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_UseProvidedPixelBuffer);
        HEIFReadPlugin::updateCreateImageOptions(this, (IIODictionary *)&v54, *((IIODictionary **)this + 6));
        if (v28)
        {
          v31 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v60, 0, 0, &cf);
          v32 = v31;
          if (v31)
          {
            v33 = IIOCMErrorString(v31);
            v30 = _cg_jpeg_mem_term("decodeIntoIOSurface", 3092, "*** CMPhotoDecompressionSessionCreateContainer[sequence] err = %s [%d]\n", v33, v32);
          }
          if (*((unsigned __int8 *)this + 216) < 2u)
          {
            p_cf = &cf;
          }
          else
          {
            p_cf = &cf;
            if (!*((_BYTE *)this + 490))
              goto LABEL_41;
          }
        }
        else if (*((_BYTE *)this + 216) == 2)
        {
          p_cf = &v60;
          if (!*((_BYTE *)this + 490))
          {
LABEL_41:
            ThumbnailImageForIndex = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(*p_cf, *((unsigned int *)this + 124), 0, v55, 2, 0, v30);
LABEL_45:
            v9 = ThumbnailImageForIndex;
            if ((_DWORD)ThumbnailImageForIndex)
            {
              if ((_DWORD)ThumbnailImageForIndex == -15470 && v7)
                CGImageProviderSetProperty();
              v36 = IIOCMErrorString(v9);
              _cg_jpeg_mem_term("decodeIntoIOSurface", 3133, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v36, v9);
              v37 = PixelFormat >> 24;
              v38 = MEMORY[0x1E0C80978];
              if (PixelFormat < 0)
                v39 = __maskrune(PixelFormat >> 24, 0x40000uLL);
              else
                v39 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v37 + 60) & 0x40000;
              if (v39)
                v40 = v37;
              else
                v40 = 46;
              v41 = PixelFormat << 8 >> 24;
              if (PixelFormat << 8 < 0)
                v42 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
              else
                v42 = *(_DWORD *)(v38 + 4 * v41 + 60) & 0x40000;
              if (v42)
                v43 = v41;
              else
                v43 = 46;
              v44 = (__int16)PixelFormat >> 8;
              if (PixelFormat << 16 < 0)
              {
                v46 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
                v45 = v38;
              }
              else
              {
                v45 = v38;
                v46 = *(_DWORD *)(v38 + 4 * v44 + 60) & 0x40000;
              }
              if ((PixelFormat << 24) <= 0x7F000000)
                v47 = *(_DWORD *)(v45 + 4 * (char)PixelFormat + 60) & 0x40000;
              else
                v47 = __maskrune((char)PixelFormat, 0x40000uLL);
              if (v46)
                v48 = v44;
              else
                v48 = 46;
              if (v47)
                v49 = (char)PixelFormat;
              else
                v49 = 46;
              *(_QWORD *)&v50 = _cg_jpeg_mem_term("decodeIntoIOSurface", 3134, "    outputPixelFormat: %c%c%c%c\n", v40, v43, v48, v49).n128_u64[0];
              _cg_jpeg_mem_term(v55, 4, "cmPhotoContainer", v50);
            }
            else
            {
              if (gFunc_CMPhotoDecompressionSessionDetachSurface)
                v9 = gFunc_CMPhotoDecompressionSessionDetachSurface(v61, a3);
              else
                v9 = 0;
              if ((gIIODebugFlags & 0x2000000) != 0)
                LogSurfaceFormat(a3, "surface", "decodeIntoIOSurface", 3144);
              if ((_DWORD)v9)
              {
                v51 = IIOCMErrorString(v9);
                _cg_jpeg_mem_term("decodeIntoIOSurface", 3147, "*** CMPhotoDecompressionSessionDetachSurface  err = %s [%d]\n", v51, v9);
              }
            }
            if (cf)
              CFRelease(cf);
            CFRelease(v60);
            IIODictionary::~IIODictionary((IIODictionary *)&v54);
            goto LABEL_84;
          }
        }
        else
        {
          p_cf = &v60;
        }
        ThumbnailImageForIndex = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(*p_cf, *((unsigned int *)this + 124), v55, 2, 0, v30);
        goto LABEL_45;
      }
      v29 = IIOCMErrorString(v22);
      _cg_jpeg_mem_term("decodeIntoIOSurface", 3061, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v29, v9);
    }
    else
    {
      v9 = 0;
    }
LABEL_84:
    gFunc_CMPhotoDecompressionSessionFlushCachedBuffers(v61, 0, 0);
    CFRelease(v61);
    if (v21)
      CFRelease(v21);
    if (v57)
    {
      v52 = (IIOImageRead **)*((_QWORD *)this + 3);
      if (v52)
        IIOImageReadSession::releaseBytePointer(v52, v57);
    }
    goto LABEL_12;
  }
  LogError("decodeIntoIOSurface", 3045, "*** ERROR: retainBytePointer failed\n");
  v9 = 0;
LABEL_12:
  if (v11)
  {
    v15 = (const char **)*((_QWORD *)this + 3);
    if (v15)
      IIOImageReadSession::unmapData(v15);
  }
  if (value)
    gFunc_CVPixelBufferRelease(v14);
LABEL_7:
  IIODictionary::~IIODictionary((IIODictionary *)v63);
  return v9;
}

void sub_188031B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v5 - 112));
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::copyIOSurfaceImp(uint64_t a1, uint64_t a2, __CFDictionary *a3, __IOSurface **a4, uint64_t *a5)
{
  IIOImageRead **v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t updated;
  const char *v13;
  const char **v14;
  IIOImageRead *Size;
  IIOImageRead *v17;
  const UInt8 *v18;
  uint64_t v19;
  CFDataRef v20;
  int v21;
  IIOImageRead *v22;
  int v23;
  const char *v24;
  HEIFMainImage *HEIFMainImageAtIndex;
  int v26;
  int DecodePixelFormatForBitDepth;
  __n128 v28;
  uint64_t v29;
  __n128 v30;
  const char *v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t ThumbnailImageForIndex;
  uint64_t ImageForIndex;
  const char *v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  double v52;
  __IOSurface *SurfaceWithGainMapApplied;
  __IOSurface *v54;
  __IOSurface *SurfaceWithToneMapApplied;
  uint64_t v56;
  const char *v57;
  IIOImageRead **v58;
  GlobalHEIFInfo *v59;
  _BYTE v60[24];
  _BYTE v61[24];
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  int v66;
  CFTypeRef cf;
  CFTypeRef v68;
  CFTypeRef v69;
  _QWORD v70[3];
  __IOSurface *v71[2];

  v71[0] = 0;
  memset(v70, 0, sizeof(v70));
  IIODictionary::IIODictionary((IIODictionary *)v70, a3);
  IIO_LoadHEIFSymbols();
  v9 = *(IIOImageRead ***)(a1 + 24);
  if (!v9)
  {
    updated = 4294967246;
    goto LABEL_12;
  }
  v10 = IIOImageReadSession::mapData(v9);
  v69 = 0;
  if (!gFunc_CMPhotoDecompressionSessionCreate)
    _cg_jpeg_mem_term("copyIOSurfaceImp", 3200, "*** CMPhotoDecompressionSessionCreate symbol not found\n");
  v11 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v69);
  updated = v11;
  if ((_DWORD)v11)
  {
    v13 = IIOCMErrorString(v11);
    _cg_jpeg_mem_term("copyIOSurfaceImp", 3207, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v13, updated);
    goto LABEL_6;
  }
  cf = 0;
  v68 = 0;
  v66 = 0;
  v65 = 0;
  Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
  v17 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v65, 1);
  v18 = (const UInt8 *)v17;
  if (!v17)
  {
    LogError("copyIOSurfaceImp", 3222, "*** ERROR: retainBytePointer failed\n");
    updated = 4294967277;
    goto LABEL_6;
  }
  v19 = *(_QWORD *)(a1 + 456);
  if (v19)
  {
    if (*(_QWORD *)(a1 + 464))
      Size = *(IIOImageRead **)(a1 + 464);
    else
      v19 = 0;
    v18 = (const UInt8 *)v17 + v19;
  }
  v20 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v18, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (!v20)
  {
    updated = 0;
LABEL_104:
    CFRelease(v69);
    if (v20)
      CFRelease(v20);
    if (v65)
    {
      v58 = *(IIOImageRead ***)(a1 + 24);
      if (v58)
        IIOImageReadSession::releaseBytePointer(v58, v65);
    }
    goto LABEL_6;
  }
  v21 = gFunc_CMPhotoDecompressionSessionCreateContainer(v69, 0, v20, &v66, &v68);
  LODWORD(updated) = v21;
  if (v21 || !v68)
  {
    v24 = IIOCMErrorString(v21);
    _cg_jpeg_mem_term("copyIOSurfaceImp", 3237, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v24, updated);
    if ((_DWORD)updated)
      updated = updated;
    else
      updated = 4294967246;
    goto LABEL_104;
  }
  v62 = 0;
  v63 = 0;
  v64 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v62);
  v22 = IIOImageReadSession::globalInfoForType(*(IIOImageReadSession **)(a1 + 24), 1212500294);
  if (GlobalHEIFInfo::hasHEIFSequence(v22))
    v23 = IIOImageRead::trustedURL(v22);
  else
    v23 = 0;
  HEIFMainImageAtIndex = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v22, *(_DWORD *)(a1 + 496));
  if (HEIFMainImageAtIndex)
  {
    v26 = HEIFMainImage::bitDepth(HEIFMainImageAtIndex);
    DecodePixelFormatForBitDepth = HEIFReadPlugin::getDecodePixelFormatForBitDepth((HEIFReadPlugin *)a1, v26);
    HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)a1, (IIODictionary *)&v62, *(const __CFDictionary ***)(a1 + 48));
    IIONumber::IIONumber((IIONumber *)v61, DecodePixelFormatForBitDepth);
    IIODictionary::setObjectForKey((uint64_t)&v62, (uint64_t)v61, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
    IIONumber::~IIONumber((IIONumber *)v61);
    HEIFReadPlugin::updateCreateImageOptions((HEIFReadPlugin *)a1, (IIODictionary *)&v62, *(IIODictionary **)(a1 + 48));
    if (IIODictionary::containsKey((IIODictionary *)v70, CFSTR("kCGImageSurfaceFormatRequest"))
      && !*(_BYTE *)(a1 + 484)
      && !*(_BYTE *)(a1 + 485))
    {
      DecodePixelFormatForBitDepth = IIODictionary::getUint32ForKey((IIODictionary *)v70, CFSTR("kCGImageSurfaceFormatRequest"));
      IIONumber::IIONumber((IIONumber *)v60, DecodePixelFormatForBitDepth);
      IIODictionary::setObjectForKey((uint64_t)&v62, (uint64_t)v60, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
      IIONumber::~IIONumber((IIONumber *)v60);
    }
    if (v23)
    {
      v29 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v68, 0, 0, &cf);
      updated = v29;
      if ((_DWORD)v29)
      {
        v31 = IIOCMErrorString(v29);
        _cg_jpeg_mem_term("copyIOSurfaceImp", 3276, "*** CMPhotoDecompressionSessionCreateContainer[sequence] err = %s [%d]\n", v31, updated);
      }
      else
      {
        if (*(unsigned __int8 *)(a1 + 216) < 2u || *(_BYTE *)(a1 + 490))
          ImageForIndex = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(cf, *(unsigned int *)(a1 + 496), v63, 1, v71, v30);
        else
          ImageForIndex = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(cf, *(unsigned int *)(a1 + 496), 0, v63, 1, v71, v30);
        updated = ImageForIndex;
        v32 = (const char *)IIO_IOSurfaceLogAlphaInfo(v71[0], "HEIFSequence");
      }
    }
    else
    {
      if (*(_BYTE *)(a1 + 216) == 2 && !*(_BYTE *)(a1 + 490))
        ThumbnailImageForIndex = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(v68, *(unsigned int *)(a1 + 496), 0, v63, 1, v71, v28);
      else
        ThumbnailImageForIndex = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v68, *(unsigned int *)(a1 + 496), v63, 1, v71, v28);
      updated = ThumbnailImageForIndex;
      v32 = (const char *)IIO_IOSurfaceLogAlphaInfo(v71[0], "HEIF decode");
    }
    if ((_DWORD)updated)
    {
      if ((_DWORD)updated == -15470 && a2)
        CGImageProviderSetProperty();
      v38 = IIOCMErrorString(updated);
      _cg_jpeg_mem_term("copyIOSurfaceImp", 3321, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v38, updated);
      v39 = DecodePixelFormatForBitDepth >> 24;
      v40 = MEMORY[0x1E0C80978];
      if (DecodePixelFormatForBitDepth < 0)
        v41 = __maskrune(DecodePixelFormatForBitDepth >> 24, 0x40000uLL);
      else
        v41 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v39 + 60) & 0x40000;
      if (v41)
        v42 = v39;
      else
        v42 = 46;
      v59 = (GlobalHEIFInfo *)v42;
      v43 = DecodePixelFormatForBitDepth << 8 >> 24;
      if (DecodePixelFormatForBitDepth << 8 < 0)
        v44 = __maskrune(DecodePixelFormatForBitDepth << 8 >> 24, 0x40000uLL);
      else
        v44 = *(_DWORD *)(v40 + 4 * v43 + 60) & 0x40000;
      if (v44)
        v45 = v43;
      else
        v45 = 46;
      v46 = (__int16)DecodePixelFormatForBitDepth >> 8;
      if (DecodePixelFormatForBitDepth << 16 < 0)
      {
        v48 = __maskrune((__int16)DecodePixelFormatForBitDepth >> 8, 0x40000uLL);
        v47 = v40;
      }
      else
      {
        v47 = v40;
        v48 = *(_DWORD *)(v40 + 4 * v46 + 60) & 0x40000;
      }
      if ((DecodePixelFormatForBitDepth << 24) <= 0x7F000000)
        v49 = *(_DWORD *)(v47 + 4 * (char)DecodePixelFormatForBitDepth + 60) & 0x40000;
      else
        v49 = __maskrune((char)DecodePixelFormatForBitDepth, 0x40000uLL);
      if (v48)
        v50 = v46;
      else
        v50 = 46;
      if (v49)
        v51 = (char)DecodePixelFormatForBitDepth;
      else
        v51 = 46;
      *(_QWORD *)&v52 = _cg_jpeg_mem_term("copyIOSurfaceImp", 3322, "    outputPixelFormat: %c%c%c%c\n", v59, v45, v50, v51).n128_u64[0];
      _cg_jpeg_mem_term(v63, 4, "cmPhotoContainer", v52);
      goto LABEL_101;
    }
    if (gFunc_CMPhotoDecompressionSessionDetachSurface)
    {
      v32 = (const char *)gFunc_CMPhotoDecompressionSessionDetachSurface(v69, v71[0]);
      updated = (uint64_t)v32;
    }
    else
    {
      updated = 0;
    }
    if (*(_BYTE *)(a1 + 484))
    {
      if ((gIIODebugFlags & 0x300000) != 0)
        ImageIOLog("☀️  _requestedApplyGainMap --> createSurfaceWithGainMapApplied\n");
      SurfaceWithGainMapApplied = HEIFReadPlugin::createSurfaceWithGainMapApplied(a1, (uint64_t)v68, v34, v22, v71[0]);
      v54 = SurfaceWithGainMapApplied;
      if ((gIIODebugFlags & 0x2000000) != 0)
        LogSurfaceFormat(SurfaceWithGainMapApplied, "outputSurface", "copyIOSurfaceImp", 3336);
      if (v54)
      {
LABEL_90:
        CFRelease(v71[0]);
        v71[0] = v54;
      }
    }
    else if (*(_BYTE *)(a1 + 485))
    {
      if ((gIIODebugFlags & 0x300000) != 0)
        v32 = ImageIOLog("☀️  _requestedApplyToneMap --> createSurfaceWithToneMapApplied\n");
      SurfaceWithToneMapApplied = HEIFReadPlugin::createSurfaceWithToneMapApplied((uint64_t)v32, v33, v34, v35, v71[0], *(_DWORD *)(a1 + 440), *(const __CFString **)(a1 + 512), *(unsigned __int8 *)(a1 + 489));
      v54 = SurfaceWithToneMapApplied;
      if ((gIIODebugFlags & 0x2000000) != 0)
        LogSurfaceFormat(SurfaceWithToneMapApplied, "outputSurface", "copyIOSurfaceImp", 3347);
      if (v54)
        goto LABEL_90;
    }
    if (!a5)
      goto LABEL_98;
    if (*(_BYTE *)(a1 + 487))
    {
      v56 = HEIFReadPlugin::copyISOGainMapDictionary(a1, (uint64_t)v68);
    }
    else
    {
      if (!*(_BYTE *)(a1 + 486))
        goto LABEL_98;
      v56 = (uint64_t)HEIFReadPlugin::copyHDRGainMapDictionary(a1, (uint64_t)v68, v22, (uint64_t)v70);
    }
    *a5 = v56;
LABEL_98:
    if ((_DWORD)updated)
    {
      v57 = IIOCMErrorString(updated);
      _cg_jpeg_mem_term("copyIOSurfaceImp", 3374, "*** CMPhotoDecompressionSessionDetachSurface  err = %s [%d]\n", v57, updated);
    }
    else
    {
      updated = IIO_UpdateIOSurfaceOwnershipIdentity((uint64_t)v71[0], *(_DWORD *)(a1 + 432));
    }
LABEL_101:
    if (cf)
      CFRelease(cf);
    CFRelease(v68);
    IIODictionary::~IIODictionary((IIODictionary *)&v62);
    goto LABEL_104;
  }
  LogError("copyIOSurfaceImp", 3249, "*** ERROR: failed to get mainImage [#%d]\n", *(_DWORD *)(a1 + 496));
  IIODictionary::~IIODictionary((IIODictionary *)&v62);
  updated = 4294967246;
LABEL_6:
  if (v10)
  {
    v14 = *(const char ***)(a1 + 24);
    if (v14)
      IIOImageReadSession::unmapData(v14);
  }
  if (a4)
    *a4 = v71[0];
LABEL_12:
  IIODictionary::~IIODictionary((IIODictionary *)v70);
  return updated;
}

void sub_18803236C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v6 - 120));
  _Unwind_Resume(a1);
}

double AppleJPEGReadPlugin::AppleJPEGReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  JPEGReadPlugin::JPEGReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BB19F8;
  result = 0.0;
  *(_OWORD *)(v3 + 504) = 0u;
  *(_OWORD *)(v3 + 520) = 0u;
  *(_OWORD *)(v3 + 536) = 0u;
  *(_OWORD *)(v3 + 552) = 0u;
  *(_OWORD *)(v3 + 568) = 0u;
  *(_OWORD *)(v3 + 584) = 0u;
  *(_OWORD *)(v3 + 600) = 0u;
  *(_OWORD *)(v3 + 616) = 0u;
  *(_OWORD *)(v3 + 632) = 0u;
  *(_OWORD *)(v3 + 648) = 0u;
  *(_OWORD *)(v3 + 664) = 0u;
  *(_QWORD *)(v3 + 680) = 0;
  return result;
}

uint64_t AppleJPEGReadPlugin::loadDataFromXPCObject(AppleJPEGReadPlugin *this, void *a2)
{
  uint64_t DataFromXPCObject;
  _OWORD *data;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  size_t length;

  DataFromXPCObject = JPEGReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)DataFromXPCObject)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_applejpeg", &length);
    if (length == 184)
    {
      DataFromXPCObject = 0;
      v6 = *data;
      v7 = data[1];
      v8 = data[3];
      *(_OWORD *)((char *)this + 536) = data[2];
      *(_OWORD *)((char *)this + 552) = v8;
      *(_OWORD *)((char *)this + 504) = v6;
      *(_OWORD *)((char *)this + 520) = v7;
      v9 = data[4];
      v10 = data[5];
      v11 = data[7];
      *(_OWORD *)((char *)this + 600) = data[6];
      *(_OWORD *)((char *)this + 616) = v11;
      *(_OWORD *)((char *)this + 568) = v9;
      *(_OWORD *)((char *)this + 584) = v10;
      v12 = data[8];
      v13 = data[9];
      v14 = data[10];
      *((_QWORD *)this + 85) = *((_QWORD *)data + 22);
      *(_OWORD *)((char *)this + 648) = v13;
      *(_OWORD *)((char *)this + 664) = v14;
      *(_OWORD *)((char *)this + 632) = v12;
    }
    else
    {
      DataFromXPCObject = 4294967246;
    }
    *((_QWORD *)this + 82) = 0;
    *((_QWORD *)this + 81) = 0;
    *((_QWORD *)this + 83) = 0;
    *((_QWORD *)this + 79) = 0;
    *(_OWORD *)((char *)this + 504) = 0u;
    *(_OWORD *)((char *)this + 520) = 0u;
    *(_OWORD *)((char *)this + 536) = 0u;
    *(_OWORD *)((char *)this + 552) = 0u;
    *(_OWORD *)((char *)this + 568) = 0u;
    *(_OWORD *)((char *)this + 584) = 0u;
    *(_OWORD *)((char *)this + 600) = 0u;
    *(_OWORD *)((char *)this + 616) = 0u;
    IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), *((_QWORD *)this + 57), 0);
  }
  return DataFromXPCObject;
}

uint64_t AppleJPEGReadPlugin::saveDataToXPCObject(AppleJPEGReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = JPEGReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_applejpeg", (char *)this + 504, 0xB8uLL);
  return v4;
}

const char *AppleJPEGReadPlugin::appleJPEGErrorString(AppleJPEGReadPlugin *this, int a2)
{
  if ((a2 + 2) > 0xE)
    return "";
  else
    return off_1E1BC9B68[a2 + 2];
}

uint64_t AppleJPEGReadPlugin::canCreateChromaSubsampledIOSurface(AppleJPEGReadPlugin *this)
{
  return 1;
}

void AppleJPEGReadPlugin::readQualityPropertiesFromJPEG(uint64_t a1, uint64_t a2, IIODictionary *a3)
{
  CFMutableArrayRef Mutable;
  __CFArray *v4;
  CFIndex v5;
  const void *v6;
  signed int chroma_subsampling;
  int v8;
  _BYTE v11[24];
  _BYTE v12[28];
  int v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  _BYTE *v17;
  _BYTE *v18;
  _BYTE *v19;
  _BYTE v20[64];
  _BYTE v21[64];
  _BYTE v22[64];
  _BYTE v23[72];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v4 = Mutable;
      v5 = 0;
      v6 = (const void *)*MEMORY[0x1E0C9B0D0];
      do
        CFArraySetValueAtIndex(v4, v5++, v6);
      while (v5 != 4);
      memset(v23, 0, 64);
      memset(v22, 0, sizeof(v22));
      memset(v21, 0, sizeof(v21));
      memset(v20, 0, sizeof(v20));
      v16 = v20;
      v17 = v21;
      v18 = v22;
      v19 = v23;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      if (!applejpeg_decode_get_qtables())
        IIODictionary::setObjectForKeyGroup(a3, v4, CFSTR("Quantization"), CFSTR("{JPEG}"));
      CFRelease(v4);
    }
    chroma_subsampling = applejpeg_decode_get_chroma_subsampling();
    *(_BYTE *)(a1 + 676) = chroma_subsampling;
    if (chroma_subsampling <= 3)
    {
      v8 = dword_18822C360[chroma_subsampling];
      IIONumber::IIONumber((IIONumber *)v12, dword_18822C350[chroma_subsampling]);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v12, CFSTR("ChromaSubsamplingX"), CFSTR("{JPEG}"));
      IIONumber::~IIONumber((IIONumber *)v12);
      IIONumber::IIONumber((IIONumber *)v11, v8);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v11, CFSTR("ChromaSubsamplingY"), CFSTR("{JPEG}"));
      IIONumber::~IIONumber((IIONumber *)v11);
    }
  }
}

void sub_188032820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t AppleJPEGReadPlugin::containsGainMap(AppleJPEGReadPlugin *this)
{
  int v2;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (*((int *)this + 148) >= 1)
  {
    v2 = 0;
    do
    {
      applejpeg_decode_get_segment_info();
      ++v2;
    }
    while (v2 < *((_DWORD *)this + 148));
  }
  return 0;
}

uint64_t AppleJPEGReadPlugin::copyImageBlockSetSingleTile(uint64_t a1, const void *a2, const void *a3, double a4, double a5, double a6, double a7, double a8, double a9, uint64_t a10, _DWORD *a11)
{
  unsigned int PixelSize;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  AppleJPEGReadPlugin *output_dimensions;
  int v29;
  const char *v30;
  void *v31;
  uint64_t v32;
  int v33;
  int v34;
  BOOL v35;
  double v36;
  double v37;
  double v38;
  double v39;
  unint64_t v40;
  size_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  CGRect v48;
  CGRect v49;

  v47 = *MEMORY[0x1E0C80C00];
  v42 = 0;
  *a11 = 0;
  if (a3)
  {
    PixelSize = CGImageProviderGetPixelSize();
  }
  else
  {
    PixelSize = *(unsigned __int16 *)(a1 + 308);
    if (PixelSize == 3)
    {
      if (*(_BYTE *)(a1 + 310))
        PixelSize = 4;
      else
        PixelSize = 3;
    }
  }
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    %s:%d: Entering\n", "copyImageBlockSetSingleTile", 2258);
  *(_DWORD *)(a1 + 292) = a6;
  *(_DWORD *)(a1 + 296) = a7;
  *(_DWORD *)(a1 + 300) = (unint64_t)(a6 * (double)PixelSize);
  *(_DWORD *)(a1 + 104) = 1;
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a4, a5, a6, a7, a8, a9);
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  applejpeg_decode_clear_options();
  v22 = applejpeg_decode_set_option_outformat();
  if (v22)
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2301, "err = %d\n", v22);
  v23 = applejpeg_decode_set_option_outsize();
  if (v23)
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2314, "err = %d\n", v23);
  v43 = *(unsigned int *)(a1 + 300);
  v44 = v43;
  v45 = v43;
  v46 = v43;
  v24 = applejpeg_decode_set_option_stride();
  if (v24)
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2322, "err = %d\n", v24);
  if (*(_BYTE *)(a1 + 341))
    AppleJPEGReadPlugin::create_or_restoreIndexTable(a1);
  v25 = applejpeg_decode_set_option_mosquito_spray();
  if (v25)
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2354, "applejpeg_decode_set_option_mosquito_spray err = %d\n", v25);
  v26 = applejpeg_decode_set_option_multithread();
  if (v26)
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2361, "applejpeg_decode_set_option_multithread err = %d\n", v26);
  v27 = applejpeg_decode_set_option_crop();
  if (v27)
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2393, "err = %d\n", v27);
  applejpeg_decode_set_option_error_fill();
  output_dimensions = (AppleJPEGReadPlugin *)applejpeg_decode_get_output_dimensions();
  if ((_DWORD)output_dimensions)
  {
    v29 = (int)output_dimensions;
    v30 = AppleJPEGReadPlugin::appleJPEGErrorString(output_dimensions, (int)output_dimensions);
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2406, "*** ERROR: applejpeg_decode_get_output_dimensions - error %d (%s)\n", v29, v30);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    %s:%d: Options error %d\n", "copyImageBlockSetSingleTile", 2407, v29);
    v31 = 0;
  }
  else
  {
    applejpeg_decode_get_output_buffer_size();
    if (*(_DWORD *)(a1 + 300))
      _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2416, "*** ERROR: get_output_buffer_size rb=%d  blockGeo.rb=%d\n", 0, *(_DWORD *)(a1 + 300));
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    %s:%d: applejpeg_decode_get_output_buffer_size:%ld rowB:%ld size:%ldx%ld\n", "copyImageBlockSetSingleTile", 2418, 0, 0, 0, 0);
    v31 = (void *)_ImageIO_Malloc(0, *(_QWORD *)(a1 + 384), &v42, (uint64_t)kImageMalloc_APPLEJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
    if (v31)
    {
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    %s:%d: Got outbuf\n", "copyImageBlockSetSingleTile", 2428);
      v33 = applejpeg_decode_image_all();
      if (!v33)
        goto LABEL_60;
      v34 = v33;
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    %s:%d: Decode error %d\n", "copyImageBlockSetSingleTile", 2435, v33);
      if (v34 == 9 || v34 == -1)
      {
LABEL_60:
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("    %s:%d: Decoded image\n", "copyImageBlockSetSingleTile", 2442);
        v48.origin.x = a4;
        v48.origin.y = a5;
        v48.size.width = a6;
        v48.size.height = a7;
        **(_QWORD **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v31, v42, v48, *(unsigned int *)(a1 + 300), 0);
        v35 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]);
        v36 = a6;
        v37 = a7;
        if (!v35)
        {
          v49.origin.x = a4;
          v49.origin.y = a5;
          v49.size.width = a6;
          v49.size.height = a7;
          *(CGRect *)(&v36 - 2) = CGRectUnion(*(CGRect *)(a1 + 120), v49);
          a4 = v38;
          a5 = v39;
        }
        *(double *)(a1 + 120) = a4;
        *(double *)(a1 + 128) = a5;
        *(double *)(a1 + 136) = v36;
        *(double *)(a1 + 144) = v37;
        if (*(_BYTE *)(a1 + 341))
          AppleJPEGReadPlugin::save_index_table((AppleJPEGReadPlugin *)a1);
        v31 = 0;
        if (a3)
        {
          v40 = *(unsigned int *)(a1 + 104);
          if ((_DWORD)v40)
          {
            v32 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, v40, a6, a7, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), a2);
            v31 = 0;
LABEL_29:
            IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
            if (!v31)
              return v32;
            goto LABEL_54;
          }
        }
      }
    }
  }
  if (a3)
  {
    v32 = 0;
    goto LABEL_29;
  }
  if (!*(_DWORD *)(a1 + 104))
  {
    v32 = 0;
    if (!v31)
      return v32;
    goto LABEL_54;
  }
  v32 = 0;
  *a11 = 1;
  if (v31)
LABEL_54:
    _ImageIO_Free((unint64_t)v31, v42);
  return v32;
}

uint64_t AppleJPEGReadPlugin::copyImageBlockSetTiles(uint64_t a1, const void *a2, const void *a3, unint64_t a4, _DWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  const void *v11;
  double v17;
  double v20;
  double v21;
  double v22;
  double v23;
  unint64_t PixelSize;
  unint64_t v25;
  double v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64x2_t v30;
  int8x16_t v31;
  int64x2_t v32;
  size_t v33;
  int v34;
  unsigned int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unint64_t v40;
  unint64_t v41;
  double v42;
  uint64_t v43;
  unint64_t v44;
  CGRect *v45;
  uint64_t v46;
  unint64_t v47;
  double v48;
  double v49;
  double v50;
  unint64_t v51;
  uint64_t v52;
  double v53;
  double v54;
  double v55;
  int v56;
  void *v57;
  int v58;
  double v59;
  double v60;
  double v61;
  uint64_t v62;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  const void *v68;
  const void *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  size_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  CGRect v83;
  CGRect v84;

  v11 = a3;
  v17 = a6;
  v82 = *MEMORY[0x1E0C80C00];
  v77 = 0;
  *a5 = 0;
  if (a3)
  {
    CGImageProviderGetSize();
    v21 = v20;
    v23 = v22;
    PixelSize = CGImageProviderGetPixelSize();
  }
  else
  {
    LODWORD(a6) = *(_DWORD *)(a1 + 292);
    v21 = (double)*(unint64_t *)&a6;
    LODWORD(a6) = *(_DWORD *)(a1 + 296);
    v23 = (double)*(unint64_t *)&a6;
    PixelSize = *(unsigned __int16 *)(a1 + 308);
    if (PixelSize == 3)
    {
      if (*(_BYTE *)(a1 + 310))
        PixelSize = 4;
      else
        PixelSize = 3;
    }
  }
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    %s:%d: Entering\n", "copyImageBlockSetTiles", 2522);
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, v11, v17, a7, a8, a9, a10, a11);
  v25 = (unint64_t)(v17 / (double)a4);
  v26 = (double)(a4 - 1);
  v27 = (unint64_t)((v17 + a8 + v26) / (double)a4);
  v28 = (unint64_t)(a7 / (double)a4);
  v74 = (unint64_t)((a7 + a9 + v26) / (double)a4);
  *(_DWORD *)(a1 + 236) = 16 * (unint64_t)((a8 * (double)PixelSize + 15.0) * 0.0625);
  v29 = *(_QWORD *)(a1 + 228);
  v30.i64[0] = v29;
  v30.i64[1] = HIDWORD(v29);
  v31 = (int8x16_t)vdupq_n_s64(a4);
  v32 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v31, v30), (int8x16_t)v30, v31);
  *(int32x2_t *)(a1 + 292) = vmovn_s64(v32);
  *(_DWORD *)(a1 + 300) = v32.i32[0] * PixelSize;
  v71 = v27 - v25;
  v33 = ((v27 - v25) * (v74 - v28));
  *(_DWORD *)(a1 + 104) = v33;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, v33);
  applejpeg_decode_clear_options();
  v34 = applejpeg_decode_set_option_outformat();
  if (v34)
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2572, "err = %d\n", v34);
  if (*(unsigned __int16 *)(a1 + 316) <= 1u)
    v35 = 1;
  else
    v35 = *(unsigned __int16 *)(a1 + 316);
  v36 = applejpeg_decode_set_option_outsize();
  if (v36)
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2585, "err = %d\n", v36);
  v78 = *(unsigned int *)(a1 + 300);
  v79 = v78;
  v80 = v78;
  v81 = v78;
  v37 = applejpeg_decode_set_option_stride();
  if (v37)
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2593, "err = %d\n", v37);
  if (*(_BYTE *)(a1 + 341))
    AppleJPEGReadPlugin::create_or_restoreIndexTable(a1);
  if (*(char *)(a1 + 677) != -1)
    applejpeg_decode_set_option_force_app14();
  applejpeg_decode_set_option_error_fill();
  v38 = applejpeg_decode_set_option_mosquito_spray();
  if (v38)
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2641, "applejpeg_decode_set_option_mosquito_spray err = %d\n", v38);
  v39 = applejpeg_decode_set_option_multithread();
  if (v39)
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2648, "err = %d\n", v39);
  if (v74 > v28)
  {
    v40 = (unint64_t)(a7 / (double)a4);
    v75 = 0;
    v72 = 0;
    if (v25 <= v27)
      v41 = v27;
    else
      v41 = (unint64_t)(v17 / (double)a4);
    v42 = (double)v35;
    v43 = 8 * v41 - 8 * v25;
    v44 = v25 * a4;
    v45 = (CGRect *)MEMORY[0x1E0C9D628];
    v70 = v11;
    v67 = (unint64_t)(v17 / (double)a4);
    v68 = a2;
    v65 = v43;
    v66 = v27;
    v64 = v25 * a4;
    while (1)
    {
      v46 = *(unsigned int *)(a1 + 296);
      v73 = v40;
      v47 = v40 * v46;
      v48 = (double)v47;
      v49 = (double)v46 + (double)v47 <= v23 ? (double)v46 : v23 - (double)v47;
      if (v27 > v25)
        break;
LABEL_63:
      v40 = v73 + 1;
      v75 += v43;
      if (v73 + 1 == v74)
        goto LABEL_64;
    }
    v50 = v49 * v42;
    v51 = v71;
    v72 += v71;
    v52 = v75;
    while (1)
    {
      v53 = (double)v44;
      LODWORD(v50) = *(_DWORD *)(a1 + 292);
      v54 = (double)*(unint64_t *)&v50;
      if ((double)v44 + v54 <= v21)
        v55 = v54;
      else
        v55 = v21 - (double)v44;
      if (!*(_WORD *)(a1 + 316) && v39)
        _cg_jpeg_mem_term("copyImageBlockSetTiles", 2692, "err = %d\n", v39);
      v56 = applejpeg_decode_set_option_crop();
      if (v56)
        _cg_jpeg_mem_term("copyImageBlockSetTiles", 2696, "err = %d\n", v56);
      applejpeg_decode_get_output_buffer_size();
      if (*(_DWORD *)(a1 + 300))
        _cg_jpeg_mem_term("copyImageBlockSetTiles", 2703, "*** ERROR: get_output_buffer_size rb=%d  blockGeo.rb=%d\n", 0, *(_DWORD *)(a1 + 300));
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    %s:%d: applejpeg_decode_get_output_buffer_size:%ld rowB:%ld size:%ldx%ld\n", "copyImageBlockSetTiles", 2705, 0, 0, *(unsigned int *)(a1 + 292), *(unsigned int *)(a1 + 296));
      v57 = (void *)_ImageIO_Malloc(0, *(_QWORD *)(a1 + 384), &v77, (uint64_t)kImageMalloc_APPLEJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
      if (!v57)
        break;
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    %s:%d: Got outbuf\n", "copyImageBlockSetTiles", 2716);
      v58 = applejpeg_decode_image_all();
      v39 = v58;
      if (v58)
      {
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("    %s:%d: Decode error %d\n", "copyImageBlockSetTiles", 2723, v58);
        if (v39 != 9 && v39 != -1)
          break;
      }
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    %s:%d: Decoded image\n", "copyImageBlockSetTiles", 2730);
      v83.origin.x = (double)v44;
      v83.origin.y = v48;
      v83.size.width = v55;
      v83.size.height = v49;
      *(_QWORD *)(*(_QWORD *)(a1 + 96) + v52) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v57, v77, v83, *(unsigned int *)(a1 + 300), 0);
      if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *v45))
      {
        v59 = v48;
        v60 = v49;
      }
      else
      {
        v84.origin.x = (double)v44;
        v84.origin.y = v48;
        v84.size.width = v55;
        v84.size.height = v49;
        *(CGRect *)&v50 = CGRectUnion(*(CGRect *)(a1 + 120), v84);
        v53 = v50;
        v55 = v61;
      }
      *(double *)(a1 + 120) = v53;
      *(double *)(a1 + 128) = v59;
      v52 += 8;
      v44 += a4;
      *(double *)(a1 + 136) = v55;
      *(double *)(a1 + 144) = v60;
      if (!--v51)
      {
        v11 = v70;
        v25 = v67;
        a2 = v68;
        v43 = v65;
        v27 = v66;
        v44 = v64;
        goto LABEL_63;
      }
    }
    v62 = 0;
    if (!v70)
      goto LABEL_69;
LABEL_67:
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
    goto LABEL_71;
  }
LABEL_64:
  if (*(_BYTE *)(a1 + 341))
    AppleJPEGReadPlugin::save_index_table((AppleJPEGReadPlugin *)a1);
  v62 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)v11, *(unsigned int *)(a1 + 104), v21, v23, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), a2);
  v57 = 0;
  if (v11)
    goto LABEL_67;
LABEL_69:
  if (*(_DWORD *)(a1 + 104))
    *a5 = 1;
LABEL_71:
  if (v57)
    _ImageIO_Free((unint64_t)v57, v77);
  return v62;
}

uint64_t AppleJPEGReadPlugin::decodeIntoIOSurface(AppleJPEGReadPlugin *this, IIODecodeParameter *a2, __IOSurface *a3)
{
  const __CFDictionary *v3;
  _QWORD v5[3];

  memset(v5, 0, sizeof(v5));
  v3 = (const __CFDictionary *)IIOImageSource::reader(a2);
  IIODictionary::IIODictionary((IIODictionary *)v5, v3);
  IIODictionary::~IIODictionary((IIODictionary *)v5);
  return 4294967246;
}

CFDataRef AppleJPEGReadPlugin::CreateJPEGDataFromImage(AppleJPEGReadPlugin *this, IIOImagePixelDataProvider *a2, CGImageRef image, CGImage *a4)
{
  CGColorSpace *SourceGeomColorSpace;
  CGColorSpaceModel Model;
  unsigned int Width;
  size_t Height;
  uint64_t v9;
  int v10;
  CFIndex v11;
  CFDataRef v12;
  vImage_CGImageFormat format;
  vImage_Buffer buf;
  UInt8 *bytes;
  uint64_t v17;
  CFIndex v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = 0;
  v35 = 0u;
  v36 = xmmword_1E1BC9B00;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v28 = 0;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v21 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0;
  v18 = 0;
  bytes = 0;
  if (this)
    SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(this);
  else
    SourceGeomColorSpace = CGImageGetColorSpace(image);
  Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  memset(&buf, 0, sizeof(buf));
  memset(&format.colorSpace, 0, 32);
  *(_QWORD *)&format.bitsPerComponent = 0x1800000008;
  vImageBuffer_InitWithCGImage(&buf, &format, 0, image, 0);
  if (!applejpeg_encode_create())
    goto LABEL_24;
  applejpeg_encode_options_init();
  *(_QWORD *)&v29 = 1;
  LODWORD(v30) = 80;
  DWORD2(v32) = 3;
  *((_QWORD *)&v21 + 1) = __PAIR64__(Height, Width);
  if (Model <= kCGColorSpaceModelCMYK)
    LODWORD(v22) = dword_18822C340[Model];
  LODWORD(v21) = 1;
  bytes = (UInt8 *)malloc_type_malloc(0x2800uLL, 0xC23956C2uLL);
  v17 = 10240;
  if (applejpeg_encode_set_options_mem())
  {
LABEL_24:
    v12 = 0;
    goto LABEL_15;
  }
  HIDWORD(v21) = 1;
  if (Height)
  {
    v9 = 0;
    while (1)
    {
      *(_QWORD *)&v19 = (char *)buf.data + buf.rowBytes * v9;
      v10 = applejpeg_encode_image_row();
      if (v10)
        break;
      if (Height == ++v9)
      {
        v11 = v18;
        goto LABEL_14;
      }
    }
    _cg_jpeg_mem_term("CreateJPEGDataFromImage", 3473, "applejpeg_encode_image_row: %d\n", v10);
    goto LABEL_24;
  }
  v11 = 0;
LABEL_14:
  v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, v11);
LABEL_15:
  applejpeg_encode_destroy();
  if (buf.data)
    free(buf.data);
  if (bytes)
    free(bytes);
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v12)
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CreateJPEGDataFromImage", 3497, "could not create JPEG data");
  return v12;
}

uint64_t AppleJPEGReadPlugin::copyIOSurfaceSet(_BYTE *a1)
{
  uint64_t v2;
  void *v3;
  __CFArray *Mutable;
  uint64_t v5;

  v2 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)a1 + 224))(a1);
  if (v2)
  {
    v3 = (void *)v2;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B378]);
    CFArrayAppendValue(Mutable, v3);
    v5 = CGImageIOSurfaceSetCreate();
    IIO_IOSurfaceRelease((__IOSurface *)v3);
  }
  else
  {
    v5 = 0;
    a1[680] = 1;
    a1[496] = 0;
  }
  return v5;
}

uint64_t AppleJPEGReadPlugin::copyIOSurfaceImp(uint64_t a1, int a2, __CFDictionary *a3, _QWORD *a4)
{
  IIOImageRead **v6;
  _BOOL4 v7;
  const __CFAllocator *v8;
  uint64_t v9;
  uint64_t updated;
  const char *v11;
  const char **v12;
  IIOImageRead *Size;
  IIOImageRead *v15;
  const UInt8 *v16;
  uint64_t v17;
  CFDataRef v18;
  uint64_t v19;
  const char *v20;
  unsigned int Uint32ForKey;
  int v22;
  unsigned int v23;
  int v24;
  __n128 v25;
  uint64_t ThumbnailImageForIndex;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  const char *v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  double v42;
  IIOImageRead **v43;
  uint64_t v44;
  _BYTE v45[24];
  _BYTE v46[24];
  _BYTE v47[24];
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  int v52;
  CFTypeRef v53;
  CFTypeRef v54;
  _QWORD v55[3];
  uint64_t v56[2];

  v56[0] = 0;
  memset(v55, 0, sizeof(v55));
  IIODictionary::IIODictionary((IIODictionary *)v55, a3);
  v6 = *(IIOImageRead ***)(a1 + 24);
  if (v6)
  {
    v7 = IIOImageReadSession::mapData(v6);
    v54 = 0;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v9 = gFunc_CMPhotoDecompressionSessionCreate(*MEMORY[0x1E0C9AE00], 0, &v54);
    updated = v9;
    if ((_DWORD)v9)
    {
      v11 = IIOCMErrorString(v9);
      _cg_jpeg_mem_term("copyIOSurfaceImp", 3727, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v11, updated);
    }
    else
    {
      v53 = 0;
      v52 = 0;
      v51 = 0;
      Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
      v15 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v51, 1);
      v16 = (const UInt8 *)v15;
      if (v15)
      {
        v17 = *(_QWORD *)(a1 + 456);
        if (v17)
        {
          if (*(_QWORD *)(a1 + 464) != 0 && *(_QWORD *)(a1 + 464) + v17 < (unint64_t)Size)
            Size = *(IIOImageRead **)(a1 + 464);
          else
            v17 = 0;
          v16 = (const UInt8 *)v15 + v17;
        }
        v18 = CFDataCreateWithBytesNoCopy(v8, v16, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
        if (v18)
        {
          v19 = gFunc_CMPhotoDecompressionSessionCreateContainer(v54, 0, v18, &v52, &v53);
          updated = v19;
          if ((_DWORD)v19)
          {
            v20 = IIOCMErrorString(v19);
            _cg_jpeg_mem_term("copyIOSurfaceImp", 3766, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v20, updated);
          }
          else
          {
            v48 = 0;
            v49 = 0;
            v50 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v48);
            Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v55, CFSTR("kCGImageSurfaceFormatRequest"));
            v22 = *(_DWORD *)(a1 + 324);
            if (v22 == 1196573017)
            {
              v23 = 1278226488;
            }
            else if (v22 == 1380401696)
            {
              v23 = 875704422;
              if (!*(_BYTE *)(a1 + 676))
              {
                if (*(_BYTE *)(a1 + 405))
                  v23 = 1380401729;
                else
                  v23 = 1111970369;
              }
              if (Uint32ForKey == 875704422 || Uint32ForKey == 1380401729 || Uint32ForKey == 1111970369)
                v23 = Uint32ForKey;
            }
            else
            {
              v23 = 0;
            }
            IIONumber::IIONumber((IIONumber *)v47, v23);
            IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v47, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
            IIONumber::~IIONumber((IIONumber *)v47);
            IIODictionary::setObjectForKey((IIODictionary *)&v48, (const void *)*MEMORY[0x1E0C9AE40], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_ApplyTransform);
            if (*(_DWORD *)(a1 + 292) <= *(_DWORD *)(a1 + 296))
              v24 = *(_DWORD *)(a1 + 296);
            else
              v24 = *(_DWORD *)(a1 + 292);
            IIONumber::IIONumber((IIONumber *)v46, v24);
            IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v46, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
            IIONumber::~IIONumber((IIONumber *)v46);
            IIONumber::IIONumber((IIONumber *)v45, 1);
            IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v45, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
            IIONumber::~IIONumber((IIONumber *)v45);
            if (*(_BYTE *)(a1 + 216) == 2 && *(_DWORD *)(a1 + 452) != 1920231541)
              ThumbnailImageForIndex = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(v53, 0, 0, v49, 1, v56, v25);
            else
              ThumbnailImageForIndex = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v53, 0, v49, 1, v56, v25);
            updated = ThumbnailImageForIndex;
            if ((_DWORD)ThumbnailImageForIndex)
            {
              v27 = IIOCMErrorString(ThumbnailImageForIndex);
              _cg_jpeg_mem_term("copyIOSurfaceImp", 3824, "*** CoSurfaceMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v27, updated);
              LODWORD(v28) = HIBYTE(v23);
              v29 = MEMORY[0x1E0C80978];
              if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * HIBYTE(v23) + 60) & 0x40000) != 0)
                v28 = v28;
              else
                v28 = 46;
              v44 = v28;
              v30 = (int)(v23 << 8) >> 24;
              if (((v23 << 8) & 0x80000000) != 0)
                v31 = __maskrune((int)(v23 << 8) >> 24, 0x40000uLL);
              else
                v31 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v30 + 60) & 0x40000;
              if (v31)
                v35 = v30;
              else
                v35 = 46;
              v36 = (__int16)v23 >> 8;
              if (((v23 << 16) & 0x80000000) != 0)
              {
                v38 = __maskrune((__int16)v23 >> 8, 0x40000uLL);
                v37 = v29;
              }
              else
              {
                v37 = v29;
                v38 = *(_DWORD *)(v29 + 4 * v36 + 60) & 0x40000;
              }
              if (v23 << 24 <= 0x7F000000)
                v39 = *(_DWORD *)(v37 + 4 * (char)v23 + 60) & 0x40000;
              else
                v39 = __maskrune((char)v23, 0x40000uLL);
              if (v38)
                v40 = v36;
              else
                v40 = 46;
              if (v39)
                v41 = (char)v23;
              else
                v41 = 46;
              *(_QWORD *)&v42 = _cg_jpeg_mem_term("copyIOSurfaceImp", 3825, "    outputPixelFormat: %c%c%c%c\n", v44, v35, v40, v41).n128_u64[0];
              _cg_jpeg_mem_term(v49, 4, "cmPhotoContainer", v42);
            }
            else
            {
              if (gFunc_CMPhotoDecompressionSessionDetachSurface)
              {
                v32 = gFunc_CMPhotoDecompressionSessionDetachSurface(v54, v56[0]);
                v33 = v32;
                if (v32)
                {
                  v34 = IIOCMErrorString(v32);
                  _cg_jpeg_mem_term("copyIOSurfaceImp", 3837, "*** CMPhotoDecompressionSessionDetachSurface  err = %s [%d]\n", v34, v33);
                }
              }
              updated = IIO_UpdateIOSurfaceOwnershipIdentity(v56[0], *(_DWORD *)(a1 + 432));
            }
            CFRelease(v53);
            IIODictionary::~IIODictionary((IIODictionary *)&v48);
          }
        }
        else
        {
          updated = 0;
        }
        gFunc_CMPhotoDecompressionSessionFlushCachedBuffers(v54, 0, 0);
        CFRelease(v54);
        if (v18)
          CFRelease(v18);
        if (v51)
        {
          v43 = *(IIOImageRead ***)(a1 + 24);
          if (v43)
            IIOImageReadSession::releaseBytePointer(v43, v51);
        }
      }
      else
      {
        LogError("copyIOSurfaceImp", 3745, "retainBytePointer failed\n");
        updated = 0;
      }
    }
    if (v7)
    {
      v12 = *(const char ***)(a1 + 24);
      if (v12)
        IIOImageReadSession::unmapData(v12);
    }
    if (a4)
      *a4 = v56[0];
  }
  else
  {
    updated = 4294967246;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v55);
  return updated;
}

void sub_18803412C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v6 - 120));
  _Unwind_Resume(a1);
}

__n128 ___ZN19AppleJPEGReadPlugin29createImageBlockFromIOSurfaceEP11__IOSurfaceP7InfoRecP15CGImageProvider_block_invoke()
{
  vImage_Error v0;
  __n128 result;
  vImage_Error v2;
  const char *v3;
  vImage_YpCbCrToARGBMatrix matrix;
  vImage_YpCbCrPixelRange pixelRange;

  pixelRange = *(vImage_YpCbCrPixelRange *)ymmword_18822C2E0;
  *(_OWORD *)&matrix.Yp = xmmword_18822C300;
  matrix.Cb_B = 1.772;
  v0 = vImageConvert_YpCbCrToARGB_GenerateConversion(&matrix, &pixelRange, &AppleJPEGReadPlugin::createImageBlockFromIOSurface(__IOSurface *,InfoRec *,CGImageProvider *)::conversion, kvImage422YpCbYpCr8, kvImageARGB8888, 0);
  if (v0)
  {
    v2 = v0;
    v3 = IIO_vImageErrorString(v0);
    return _cg_jpeg_mem_term("createImageBlockFromIOSurface_block_invoke", 3970, "*** ERROR: vImageConvert_YpCbCrToARGB_GenerateConversion returned %ld (%s)\n", v2, v3);
  }
  return result;
}

void ICNSWritePlugin::~ICNSWritePlugin(ICNSWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t ICNSWritePlugin::writeOneImage(ICNSWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t ICNSWritePlugin::writeOneICNS(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, _DWORD *a6)
{
  int AlphaInfo;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  CFMutableDataRef Mutable;
  __CFData *v19;
  IIOImageWriteSession *v20;
  IIOImagePlus *v21;
  IIOImageDestination *v22;
  IIOImagePixelDataProvider *v23;
  IIODictionary *SourceGeomColorSpace;
  IIODictionary *v25;
  uint64_t v26;
  char *v27;
  size_t v28;
  unsigned int v29;
  _DWORD *v30;
  unsigned int appleflags;
  unsigned int Error;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  uint64_t v35;
  int v36;
  unint64_t v37;
  unsigned int v38;
  unsigned __int8 *v39;
  char *v40;
  int v41;
  int v42;
  uint64_t v43;
  unsigned __int8 v44;
  int v45;
  size_t v46;
  uint64_t v47;
  unsigned __int8 *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  unint64_t v57;
  uint64_t v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  _BYTE *v66;
  uint64_t v67;
  char v68;
  unsigned int v69;
  unint64_t Length;
  size_t v71;
  unsigned int v72;
  uint64_t v73;
  UInt8 *MutableBytePtr;
  uint64_t v76;
  uint64_t *v77;
  int v78;
  size_t size;
  uint64_t v81;
  uint64_t v82;
  char *v83;
  uint64_t v84;
  char *v85;
  _BYTE *v86;

  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(*(IIOImagePixelDataProvider **)a2);
  v11 = *(unsigned __int16 *)(a2 + 50);
  v12 = *(_DWORD *)(a2 + 56);
  v13 = *(unsigned __int8 *)(a2 + 75);
  v78 = AlphaInfo;
  v14 = 3;
  if (AlphaInfo)
    v14 = 4;
  size = *(unsigned __int16 *)(a2 + 48);
  v15 = v14 * size;
  v16 = IIOImagePlus::sourceImageProvider(*(IIOImagePlus **)a2);
  if (v16 < v15)
    return 4294967246;
  v17 = v16;
  IIOImagePixelDataProvider::rewind(*(IIOImagePixelDataProvider **)a2);
  if (v13 >= 2)
  {
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (!Mutable)
      return 0;
    v19 = Mutable;
    v20 = (IIOImageWriteSession *)operator new();
    IIOImageWriteSession::IIOImageWriteSession(v20, v19);
    v21 = *(IIOImagePlus **)(a1 + 24);
    v22 = *(IIOImageDestination **)a2;
    v23 = *(IIOImagePixelDataProvider **)(a2 + 16);
    SourceGeomColorSpace = (IIODictionary *)IIOImagePlus::getSourceGeomColorSpace(v21);
    if (PNGWritePlugin::WriteImageWithSession(v20, v21, v22, v23, SourceGeomColorSpace, v25))
    {
      LogError("writeOneICNS", 348, "could not create icns for size %d x %d\n", size, v11);
    }
    else
    {
      v69 = bswap32(v12);
      *(_DWORD *)(a3 + *a5) = v69;
      *a5 += 4;
      a6[2 * *a6 + 1] = v69;
      Length = CFDataGetLength(v19);
      v71 = Length;
      if (Length >= (4 * size * v11))
      {
        LogError("writeOneICNS", 359, "*** ERROR: encoded PNG larger than expected (%ld > %ld)\n", Length, (4 * size * v11));
        v26 = 4294967246;
        goto LABEL_67;
      }
      v72 = bswap32(Length + 8);
      *(_DWORD *)(a3 + *a5) = v72;
      *a5 += 4;
      v73 = *a6;
      a6[2 * v73 + 2] = v72;
      *a6 = v73 + 1;
      MutableBytePtr = CFDataGetMutableBytePtr(v19);
      memcpy((void *)(a3 + *a5), MutableBytePtr, v71);
      *a5 += v71;
    }
    CFRelease(v19);
    v26 = 0;
LABEL_67:
    (*(void (**)(IIOImageWriteSession *))(*(_QWORD *)v20 + 8))(v20);
    return v26;
  }
  v83 = (char *)malloc_type_calloc(v17, size, 0x7D71798EuLL);
  if (!v83)
    return 4294967246;
  if (v17 == v15)
  {
    if (IIOImagePixelDataProvider::getBytes(*(uint64_t (***)(IIOImagePixelDataProvider *, void *))a2, v83) != v15 * v11)
      goto LABEL_11;
  }
  else if ((_DWORD)v11)
  {
    v27 = v83;
    while (IIOImagePixelDataProvider::getBytes(*(uint64_t (***)(IIOImagePixelDataProvider *, void *))a2, v27) == v17)
    {
      v27 += v15;
      if (!--v11)
        goto LABEL_16;
    }
LABEL_11:
    v26 = 4294967246;
    goto LABEL_62;
  }
LABEL_16:
  v28 = v15 * size;
  v29 = bswap32(v12);
  v76 = a3;
  v77 = a5;
  *(_DWORD *)(a3 + *a5) = v29;
  *a5 += 4;
  v30 = a6;
  a6[2 * *a6 + 1] = v29;
  appleflags = _cg_png_get_appleflags(*(_QWORD *)a2);
  Error = _cg_GifLastError(*(_QWORD *)a2);
  v86 = malloc_type_calloc(v28 + (v28 >> 2), 1uLL, 0x588743D7uLL);
  if (!v86)
    goto LABEL_53;
  v33 = (unsigned __int8 *)malloc_type_calloc(0x8CuLL, 1uLL, 0x14355503uLL);
  if (!v33)
    goto LABEL_52;
  v34 = v33;
  v35 = 0;
  v36 = appleflags / Error;
  v37 = v28 / (int)(appleflags / Error);
  v38 = 4 * ((_DWORD)size == 128);
  v39 = v33 + 2;
  v81 = v37 - 1;
  v82 = v37 & 0xFFFFFFFE;
  v85 = (char *)(v33 + 2);
  do
  {
    v40 = &v83[v35];
    *v34 = v83[v35];
    if (!v82)
    {
      v44 = 1;
      goto LABEL_49;
    }
    v84 = v35;
    v41 = 0;
    v42 = 1;
    v43 = v81;
    v44 = 1;
    do
    {
      v45 = v40[v36 * v42];
      v46 = v44;
      v47 = v44 - 1;
      if (v44 <= 1u)
        goto LABEL_22;
      v49 = v44 - 2;
      if ((_DWORD)v46 == 2)
      {
        if (v45 == v34[1] && v45 == *v34)
          goto LABEL_32;
        v41 = 0;
        v44 = 3;
        goto LABEL_33;
      }
      if ((v46 & 0x80) == 0 && !v41)
      {
        if (v45 != v34[v47] || v45 != v34[v49])
        {
          v41 = 0;
LABEL_22:
          v44 = v46 + 1;
          v48 = &v34[v46];
          goto LABEL_44;
        }
        v86[v38] = v46 - 3;
        v50 = v38 + 1;
        memcpy(&v86[v50], v34, (v46 - 2));
        v39 = (unsigned __int8 *)v85;
        v38 = v50 + v49;
        *v34 = v34[v49];
        v34[1] = v34[v47];
LABEL_32:
        v44 = 3;
        v41 = 1;
LABEL_33:
        v48 = v39;
        goto LABEL_44;
      }
      if (v46 <= 0x81 && v41 == 1)
      {
        if (v45 == v34[v47] && v45 == v34[v49])
        {
          v44 = v46 + 1;
          v48 = &v34[v46];
          v41 = 1;
          goto LABEL_44;
        }
LABEL_42:
        v41 = 0;
        v86[v38] = v46 + 125;
        v86[v38 + 1] = *v34;
        v38 += 2;
        goto LABEL_43;
      }
      if (v41)
        goto LABEL_42;
      v86[v38] = v46 - 1;
      v51 = v38 + 1;
      memcpy(&v86[v51], v34, v46);
      v39 = (unsigned __int8 *)v85;
      v41 = 0;
      v38 = v51 + v46;
LABEL_43:
      v44 = 1;
      v48 = v34;
LABEL_44:
      *v48 = v45;
      ++v42;
      --v43;
    }
    while (v43);
    if (v41)
    {
      v86[v38] = v44 + 125;
      v86[v38 + 1] = *v34;
      v38 += 2;
      v35 = v84;
      goto LABEL_50;
    }
    v35 = v84;
LABEL_49:
    v86[v38] = v44 - 1;
    v52 = v38 + 1;
    memcpy(&v86[v52], v34, v44);
    v38 = v52 + v44;
    v39 = (unsigned __int8 *)v85;
LABEL_50:
    ++v35;
  }
  while (v35 != 3);
  v53 = bswap32(v38 + 8);
  v54 = *v77;
  *(_DWORD *)(v76 + v54) = v53;
  v54 += 4;
  *v77 = v54;
  v55 = *a6;
  a6[2 * v55 + 2] = v53;
  *a6 = v55 + 1;
  memcpy((void *)(v76 + v54), v86, v38);
  *v77 += v38;
  v30 = a6;
  free(v34);
LABEL_52:
  free(v86);
LABEL_53:
  HIDWORD(v57) = size;
  LODWORD(v57) = size - 16;
  v56 = v57 >> 4;
  if (v56 > 2)
  {
    v59 = 1949855083;
    LODWORD(v58) = 0x4000;
  }
  else
  {
    LODWORD(v58) = dword_18822C384[v56];
    v59 = *(_DWORD *)&aKm8skm8lkm8h[4 * v56];
  }
  v60 = bswap32(v59);
  *(_DWORD *)(v76 + *v77) = v60;
  v61 = *v77 + 4;
  *v77 = v61;
  v30[2 * *v30 + 1] = v60;
  v62 = bswap32(v58 | 8);
  *(_DWORD *)(v76 + v61) = v62;
  v63 = *v77 + 4;
  *v77 = v63;
  v64 = *v30;
  v30[2 * v64 + 2] = v62;
  *v30 = v64 + 1;
  if ((v78 - 1) > 3)
  {
    v67 = v58;
    memset((void *)(v76 + v63), 255, v58);
  }
  else
  {
    v65 = v83 + 3;
    v66 = (_BYTE *)(v76 + v63);
    v67 = v58;
    v58 = v58;
    do
    {
      v68 = *v65;
      v65 += 4;
      *v66++ = v68;
      --v58;
    }
    while (v58);
  }
  v26 = 0;
  *v77 += v67;
LABEL_62:
  free(v83);
  return v26;
}

void sub_18803490C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

uint64_t ICNSWritePlugin::writeAll(IIOImageDestination **this)
{
  unsigned int ImageCount;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int Uint32ForKey;
  IIOImageSource *PixelDataProviderAtIndex;
  IIODictionary *PropertiesAtIndex;
  IIOImageSource **v10;
  int v11;
  int v12;
  int v13;
  unsigned __int16 *ICNSInfoTable;
  int v15;
  unsigned __int16 *v16;
  int v17;
  _BYTE *v18;
  unsigned __int8 *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  _DWORD *v26;
  __int128 *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  size_t v32;
  uint64_t v33;
  uint64_t i;
  void *v35;
  unint64_t v37;
  uint64_t v38;
  _OWORD v39[6];
  size_t __nitems;
  _BYTE v41[75];
  _BYTE v42[1477];

  *(_QWORD *)&v42[1461] = *MEMORY[0x1E0C80C00];
  bzero(v41, 0x600uLL);
  ImageCount = IIOWritePlugin::getImageCount(this);
  if (ImageCount >= 0x10)
    v3 = 16;
  else
    v3 = ImageCount;
  v38 = v3;
  if (!(_DWORD)v3)
    goto LABEL_35;
  v37 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 72;
  Uint32ForKey = 72;
  do
  {
    PixelDataProviderAtIndex = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v5);
    PropertiesAtIndex = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex(this, v5);
    v10 = (IIOImageSource **)&v41[96 * v4];
    *v10 = PixelDataProviderAtIndex;
    v10[2] = PropertiesAtIndex;
    v11 = IIOImageSource::count(PixelDataProviderAtIndex);
    v12 = IIO_Reader::testHeaderSize(PixelDataProviderAtIndex);
    if (IIODictionary::containsKey(PropertiesAtIndex, CFSTR("DPIWidth")))
      Uint32ForKey = IIODictionary::getUint32ForKey(PropertiesAtIndex, CFSTR("DPIWidth"));
    if (IIODictionary::containsKey(PropertiesAtIndex, CFSTR("DPIHeight")))
      v6 = IIODictionary::getUint32ForKey(PropertiesAtIndex, CFSTR("DPIHeight"));
    if (Uint32ForKey != v6)
    {
      Uint32ForKey = 72;
      v6 = 72;
    }
    if (Uint32ForKey == 144)
      v13 = 2;
    else
      v13 = 1;
    ICNSInfoTable = (unsigned __int16 *)GetICNSInfoTable();
    v15 = *ICNSInfoTable;
    if (v15 == 0xFFFF)
    {
LABEL_23:
      LogError("writeAll", 580, "unsupported ICNS image size (%d x %d) - scaling factor: %d  dpi: %d x %d\n", v11, v12, v13, Uint32ForKey, v6);
    }
    else
    {
      v16 = ICNSInfoTable + 28;
      while ((v15 & 0x8000) != 0
           || *(v16 - 16) != v11
           || *(v16 - 15) != v12
           || v13 != *((unsigned __int8 *)v16 - 7)
           || *((_BYTE *)v16 - 4) != 1)
      {
        v17 = *v16;
        v16 += 28;
        LOWORD(v15) = v17;
        if (v17 == 0xFFFF)
          goto LABEL_23;
      }
      v18 = &v41[96 * v4];
      *(_OWORD *)(v18 + 24) = *(_OWORD *)(v16 - 28);
      *(_OWORD *)(v18 + 40) = *(_OWORD *)(v16 - 20);
      *(_OWORD *)(v18 + 56) = *(_OWORD *)(v16 - 12);
      *((_QWORD *)v18 + 9) = *((_QWORD *)v16 - 1);
      ++v4;
      v37 += (4 * v11 * v12);
    }
    ++v5;
  }
  while (v5 != v38);
  if (v4)
  {
    v19 = v42;
    v20 = v4;
    v21 = v4;
    do
    {
      v22 = *v19;
      v19 += 96;
      if (v22 < 2)
        ++v21;
      --v20;
    }
    while (v20);
    v23 = (8 * v21 + 8);
    v24 = malloc_type_calloc((v37 >> 2) + v37 + v23, 1uLL, 0xCBCC018FuLL);
    *v24 = 1936614249;
    v24[2] = 541282132;
    v24[3] = bswap32(v23);
    __nitems = v23 + 8;
    v26 = malloc_type_calloc((8 * v21) | 4, 1uLL, 0x6F5E6569uLL);
    v27 = (__int128 *)v41;
    do
    {
      v28 = v27[3];
      v39[2] = v27[2];
      v39[3] = v28;
      v29 = v27[5];
      v39[4] = v27[4];
      v39[5] = v29;
      v30 = *v27;
      v31 = v27[1];
      v27 += 6;
      v39[0] = v30;
      v39[1] = v31;
      ICNSWritePlugin::writeOneICNS((uint64_t)this, (uint64_t)v39, (uint64_t)v24, v25, (uint64_t *)&__nitems, v26);
      --v4;
    }
    while (v4);
    memcpy(v24 + 4, v26 + 1, (8 * *v26));
    free(v26);
    v32 = __nitems;
    v24[1] = bswap32(__nitems);
    IIOImageWriteSession::putBytes(this[2], v24, v32);
    v33 = 0;
  }
  else
  {
LABEL_35:
    v24 = 0;
    v33 = 4294967246;
  }
  for (i = 88; i != 1624; i += 96)
  {
    v35 = *(void **)&v41[i];
    if (v35)
      free(v35);
  }
  if (v24)
    free(v24);
  return v33;
}

uint64_t ICNSWritePlugin::WriteProc(ICNSWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 0xBu);
  *(_QWORD *)&v9[0] = &off_1E1BB0208;
  v5 = ICNSWritePlugin::writeAll((IIOImageDestination **)v9);
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_188034D20(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _cg_jpeg_mem_term(&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x188034D0CLL);
}

uint64_t ICNSWritePlugin::writeOne(ICNSWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

uint64_t TIFFInitThunderScan(_QWORD *a1)
{
  a1[120] = ThunderSetupDecode;
  a1[126] = ThunderDecodeRow;
  a1[128] = ThunderDecodeRow;
  return 1;
}

uint64_t ThunderSetupDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 116) == 4)
    return 1;
  TIFFErrorExtR(a1, "ThunderSetupDecode", "Wrong bitspersample value (%d), Thunder decoder only supports 4bits per sample.", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
  return 0;
}

uint64_t ThunderDecodeRow(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  char v22;

  if (a3 % *(_QWORD *)(a1 + 1104))
  {
    TIFFErrorExtR(a1, "ThunderDecodeRow", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v22);
    return 0;
  }
  if (a3 >= 1)
  {
    v10 = *(_QWORD *)(a1 + 1152);
    v11 = *(_QWORD *)(a1 + 1160);
    while (1)
    {
      v12 = *(unsigned int *)(a1 + 88);
      v13 = *(_DWORD *)(a1 + 88) != 0;
      if ((_DWORD)v12)
        v14 = v11 < 1;
      else
        v14 = 1;
      if (!v14)
        __asm { BR              X9 }
      *(_QWORD *)(a1 + 1152) = v10;
      *(_QWORD *)(a1 + 1160) = v11;
      if (v12)
        break;
      v15 = *(_QWORD *)(a1 + 1104);
      a2 += v15;
      v14 = a3 <= v15;
      a3 -= v15;
      if (v14)
        return 1;
    }
    bzero(a2, (unint64_t)(v12 + 1) >> 1);
    v21 = "Too much";
    if (v13)
      v21 = "Not enough";
    TIFFErrorExtR(a1, "ThunderDecode", "%s data at scanline %lu (%llu != %llu)", v16, v17, v18, v19, v20, (char)v21);
    return 0;
  }
  return 1;
}

const char *IIO_AlphaInfoString(char a1)
{
  if ((a1 & 0x1Fu) > 7)
    return "";
  else
    return off_1E1BC9BF8[a1 & 0x1F];
}

char *IIO_BitmapInfoString(unsigned int a1)
{
  char *v2;
  unsigned int v3;
  const std::string::value_type *v4;
  unsigned int v5;
  const std::string::value_type *v6;
  void *v7;
  std::string v9;

  if ((a1 & 0x1F) > 7)
    v2 = "";
  else
    v2 = off_1E1BC9BF8[a1 & 0x1F];
  memset(&v9, 0, sizeof(v9));
  std::string::basic_string[abi:ne180100]<0>(&v9, v2);
  v3 = (a1 >> 12) & 7;
  if (v3 >= 5)
    v4 = "| unknown-ByteOrder";
  else
    v4 = off_1E1BC9CB8[v3];
  std::string::append(&v9, v4);
  v5 = HIWORD(a1) & 0xF;
  if (v5 > 4)
    v6 = "| unknown-PixelFormat";
  else
    v6 = off_1E1BC9CE0[v5];
  std::string::append(&v9, v6);
  if ((a1 & 0xF00) == 0x100)
    std::string::append(&v9, "| FloatComponents");
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v7 = (void *)v9.__r_.__value_.__r.__words[0];
    strncpy(IIO_BitmapInfoString::str, v9.__r_.__value_.__l.__data_, 0x80uLL);
    operator delete(v7);
  }
  else
  {
    strncpy(IIO_BitmapInfoString::str, (const char *)&v9, 0x80uLL);
  }
  return IIO_BitmapInfoString::str;
}

void sub_188035284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *IIO_BitmapInfoStringSmall(unsigned int a1)
{
  const char *v2;
  unsigned int v3;
  const std::string::value_type *v4;
  unsigned int v5;
  const std::string::value_type *v6;
  void *v7;
  std::string v9;

  memset(&v9, 0, sizeof(v9));
  if ((a1 & 0x1F) > 7)
    v2 = "";
  else
    v2 = off_1E1BC9C38[a1 & 0x1F];
  MEMORY[0x18D761A14](&v9, v2);
  v3 = (a1 >> 12) & 7;
  if (v3 >= 5)
    v4 = "| unknown ";
  else
    v4 = off_1E1BC9D08[v3];
  std::string::append(&v9, v4);
  v5 = HIWORD(a1) & 0xF;
  if (v5 > 4)
    v6 = "| unknown  ";
  else
    v6 = off_1E1BC9D30[v5];
  std::string::append(&v9, v6);
  if ((a1 & 0xF00) == 0x100)
    std::string::append(&v9, "| Float");
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    v7 = (void *)v9.__r_.__value_.__r.__words[0];
    strncpy(IIO_BitmapInfoStringSmall::str, v9.__r_.__value_.__l.__data_, 0x80uLL);
    operator delete(v7);
  }
  else
  {
    strncpy(IIO_BitmapInfoStringSmall::str, (const char *)&v9, 0x80uLL);
  }
  return IIO_BitmapInfoStringSmall::str;
}

void sub_1880353B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

const char *IIO_ColorModelString(int a1)
{
  if (a1 > 6)
    return "";
  else
    return off_1E1BC9C78[a1 + 1];
}

uint64_t IIO_dumpCFSTR(char *a1, const __CFString *cf)
{
  CFTypeID v4;
  FILE *v5;
  char *v6;
  const __CFString *v7;
  const __CFString *v8;
  char buffer[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    *(_OWORD *)buffer = 0u;
    v11 = 0u;
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      CFStringGetCString(cf, buffer, 255, 0x8000100u);
    }
    else
    {
      v7 = CFCopyDescription(cf);
      if (v7)
      {
        v8 = v7;
        CFStringGetCString(v7, buffer, 255, 0x8000100u);
        CFRelease(v8);
      }
    }
    v5 = (FILE *)*MEMORY[0x1E0C80C10];
    v6 = buffer;
  }
  else
  {
    v5 = (FILE *)*MEMORY[0x1E0C80C10];
    v6 = "(null)";
  }
  return fprintf(v5, a1, v6);
}

void IIO_CFShow(const __CFDictionary *a1, uint64_t a2, const char *a3)
{
  const char *v3;
  uint64_t v4;
  const __CFDictionary *v5;
  CFTypeID v6;
  FILE **v7;
  uint64_t v8;
  CFIndex Count;
  FILE *v10;
  int64_t v11;
  const void **v12;
  CFStringRef *v13;
  CFStringRef v14;
  const void *Value;
  const char *v16;
  CFIndex v17;
  uint64_t v18;
  CFIndex i;
  size_t v20;
  const void *ValueAtIndex;
  uint64_t v22;
  uint64_t v23;
  const void **v24;
  const void **v25;
  uint64_t v26;
  size_t v27;
  CFIndex v28;
  uint64_t v29;
  const void **v30;
  const void **v31;
  uint64_t v32;
  const char *v33;
  FILE *v34;
  uint64_t v35;
  const __CFString *v36;
  uint64_t v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *Schema;
  const __CFString *SuggestedPrefix;
  uint64_t v42;
  const __CFString *PropertyName;
  const __CFString *v44;
  uint64_t v45;
  double valuePtr;
  char buffer;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  _BYTE v62[31];
  uint64_t v63;

  while (1)
  {
    v63 = *MEMORY[0x1E0C80C00];
    if (!a1)
    {
      v10 = (FILE *)*MEMORY[0x1E0C80C10];
      v16 = "(null)\n";
      goto LABEL_34;
    }
    v3 = a3;
    v4 = a2;
    v5 = a1;
    v6 = CFGetTypeID(a1);
    memset(v62, 0, sizeof(v62));
    v61 = 0u;
    v60 = 0u;
    v59 = 0u;
    v58 = 0u;
    v57 = 0u;
    v56 = 0u;
    v55 = 0u;
    v54 = 0u;
    v53 = 0u;
    v52 = 0u;
    v51 = 0u;
    v50 = 0u;
    v49 = 0u;
    v48 = 0u;
    buffer = 63;
    v7 = (FILE **)MEMORY[0x1E0C80C10];
    if (v4 >= 1)
    {
      v8 = v4;
      do
      {
        fwrite("    ", 4uLL, 1uLL, *v7);
        --v8;
      }
      while (v8);
    }
    if (v3)
      fprintf(*v7, "%s = ", v3);
    if (v6 == CFDictionaryGetTypeID())
    {
      Count = CFDictionaryGetCount(v5);
      v10 = *v7;
      if (Count)
      {
        v11 = Count;
        fwrite("dict(\n", 6uLL, 1uLL, v10);
        v12 = (const void **)malloc_type_malloc(8 * v11, 0x6004044C4A2DFuLL);
        CFDictionaryGetKeysAndValues(v5, v12, 0);
        qsort(v12, v11, 8uLL, (int (__cdecl *)(const void *, const void *))keySort);
        if (v11 >= 1)
        {
          v13 = (CFStringRef *)v12;
          do
          {
            CFStringGetCString(*v13, &buffer, 255, 0x8000100u);
            v14 = *v13++;
            Value = CFDictionaryGetValue(v5, v14);
            IIO_CFShow(Value, v4 + 1, &buffer);
            --v11;
          }
          while (v11);
        }
        free(v12);
        if (v4 >= 1)
        {
          do
          {
            fwrite("    ", 4uLL, 1uLL, *v7);
            --v4;
          }
          while (v4);
        }
LABEL_23:
        fwrite(")\n", 2uLL, 1uLL, *v7);
        return;
      }
      v16 = "dict()\n";
LABEL_34:
      v27 = 7;
      goto LABEL_35;
    }
    if (v6 == CFArrayGetTypeID())
    {
      v17 = CFArrayGetCount(v5);
      v10 = *v7;
      if (v17)
      {
        v18 = v17;
        fwrite("array(\n", 7uLL, 1uLL, v10);
        if (v18 >= 1)
        {
          for (i = 0; i != v18; ++i)
          {
            v20 = strlen(&buffer);
            snprintf(&buffer, 256 - v20, "#%2ld", i);
            ValueAtIndex = CFArrayGetValueAtIndex(v5, i);
            IIO_CFShow(ValueAtIndex, v4 + 1, &buffer);
          }
        }
        if (v4 >= 1)
        {
          do
          {
            fwrite("    ", 4uLL, 1uLL, *v7);
            --v4;
          }
          while (v4);
        }
        goto LABEL_23;
      }
      v16 = "array()\n";
      v27 = 8;
      goto LABEL_35;
    }
    if (v6 == CFBagGetTypeID())
    {
      v22 = MEMORY[0x18D76043C](v5);
      v10 = *v7;
      if (v22)
      {
        v23 = v22;
        fwrite("bag(\n", 5uLL, 1uLL, v10);
        v24 = (const void **)malloc_type_malloc(8 * v23, 0xC0040B8AA526DuLL);
        CFBagGetValues(v5, v24);
        if (v23 >= 1)
        {
          v25 = v24;
          do
          {
            v26 = (uint64_t)*v25++;
            IIO_CFShow(v26, v4 + 1, 0);
            --v23;
          }
          while (v23);
        }
        free(v24);
        if (v4 >= 1)
        {
          do
          {
            fwrite("    ", 4uLL, 1uLL, *v7);
            --v4;
          }
          while (v4);
        }
        goto LABEL_43;
      }
      v16 = "bag()\n";
LABEL_54:
      v27 = 6;
      goto LABEL_35;
    }
    if (v6 == CFSetGetTypeID())
    {
      v28 = CFSetGetCount(v5);
      v10 = *v7;
      if (!v28)
      {
        v16 = "set()\n";
        goto LABEL_54;
      }
      v29 = v28;
      fwrite("set(\n", 5uLL, 1uLL, v10);
      v30 = (const void **)malloc_type_malloc(8 * v29, 0xC0040B8AA526DuLL);
      CFSetGetValues(v5, v30);
      if (v29 >= 1)
      {
        v31 = v30;
        do
        {
          v32 = (uint64_t)*v31++;
          IIO_CFShow(v32, v4 + 1, 0);
          --v29;
        }
        while (v29);
      }
      free(v30);
      if (v4 >= 1)
      {
        do
        {
          fwrite("    ", 4uLL, 1uLL, *v7);
          --v4;
        }
        while (v4);
      }
LABEL_43:
      v10 = *v7;
      v16 = ")\n";
      v27 = 2;
LABEL_35:
      fwrite(v16, v27, 1uLL, v10);
      return;
    }
    if (v6 == CFStringGetTypeID())
    {
      IIO_dumpCFSTR("\"%s\"\n", (const __CFString *)v5);
      return;
    }
    if (v6 == CFBooleanGetTypeID())
    {
      if ((const __CFDictionary *)*MEMORY[0x1E0C9AE50] == v5)
        v33 = "true\n";
      else
        v33 = "false\n";
      fprintf(*v7, v33);
      return;
    }
    if (v6 == CFNumberGetTypeID())
    {
      valuePtr = 0.0;
      CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
      v34 = *v7;
      if (valuePtr == (double)(int)valuePtr)
        fprintf(v34, "%d\n", valuePtr);
      else
        fprintf(v34, "%f\n", valuePtr);
      return;
    }
    if (v6 != CGImageMetadataPropertyGetTypeID())
      break;
    if (v4 < 1)
    {
      Schema = (const __CFString *)CGImageMetadataPropertyGetSchema((uint64_t)v5);
      IIO_dumpCFSTR("   schema: %s\n", Schema);
    }
    else
    {
      v35 = v4;
      do
      {
        fwrite("    ", 4uLL, 1uLL, *v7);
        --v35;
      }
      while (v35);
      v36 = (const __CFString *)CGImageMetadataPropertyGetSchema((uint64_t)v5);
      IIO_dumpCFSTR("   schema: %s\n", v36);
      v37 = v4;
      do
      {
        fwrite("    ", 4uLL, 1uLL, *v7);
        --v37;
      }
      while (v37);
    }
    SuggestedPrefix = (const __CFString *)CGImageMetadataPropertyGetSuggestedPrefix((uint64_t)v5);
    IIO_dumpCFSTR("            prefix: %s\n", SuggestedPrefix);
    if (v4 < 1)
    {
      PropertyName = (const __CFString *)CGImageMetadataPropertyGetPropertyName((uint64_t)v5);
      IIO_dumpCFSTR("          property: %s\n", PropertyName);
    }
    else
    {
      v42 = v4;
      do
      {
        fwrite("    ", 4uLL, 1uLL, *v7);
        --v42;
      }
      while (v42);
      v44 = (const __CFString *)CGImageMetadataPropertyGetPropertyName((uint64_t)v5);
      IIO_dumpCFSTR("          property: %s\n", v44);
      v45 = v4;
      do
      {
        fwrite("    ", 4uLL, 1uLL, *v7);
        --v45;
      }
      while (v45);
    }
    fwrite("             value: \n", 0x15uLL, 1uLL, *v7);
    a1 = (const __CFDictionary *)CGImageMetadataPropertyGetValue((uint64_t)v5);
    a2 = v4 + 1;
LABEL_79:
    a3 = 0;
  }
  if (v6 == CGImageMetadataValueGetTypeID())
  {
    a1 = (const __CFDictionary *)CGImageMetadataValueGetValue((uint64_t)v5);
    a2 = v4 - 2;
    goto LABEL_79;
  }
  if (v6)
  {
    v38 = CFCopyDescription(v5);
    if (v38)
    {
      v39 = v38;
      IIO_dumpCFSTR("%s\n", v38);
      CFRelease(v39);
    }
  }
  else
  {
    ImageIOLog("*** valueType is 0\n");
    ImageIOLog("    value: %p\n", v5);
  }
}

CFComparisonResult keySort(CFTypeRef *a1, CFStringRef *a2)
{
  CFTypeID v4;
  CFTypeID v5;

  v4 = CFGetTypeID(*a1);
  if (v4 == CFStringGetTypeID() && (v5 = CFGetTypeID(*a2), v5 == CFStringGetTypeID()))
    return CFStringCompare((CFStringRef)*a1, *a2, 0);
  else
    return 0;
}

CGImageMetadataTagRef IIOMetadata_Tag::createDeepCopy(IIOMetadata_Tag *this, uint64_t a2, uint64_t a3, const __CFString *a4)
{
  const void *v5;
  const void *v6;
  CGImageMetadataTagRef v7;
  IIOMetadata_Tag *v8;
  const __CFString *v9;
  const void *v10;
  uint64_t v11;

  v5 = (const void *)IIOMetadata_Tag::copyTagValue(this, *((const __CFString **)this + 2), *((const __CFString **)this + 3), a4, *((CFTypeRef *)this + 6), 1);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = CGImageMetadataTagCreate(*((CFStringRef *)this + 2), *((CFStringRef *)this + 3), *((CFStringRef *)this + 4), (CGImageMetadataType)*((_DWORD *)this + 10), v5);
  CFRelease(v6);
  if (v7)
  {
    v10 = (const void *)*((_QWORD *)this + 7);
    if (v10)
    {
      v11 = *((_QWORD *)v7 + 3);
      *(_QWORD *)(v11 + 56) = IIOMetadata_Tag::copyTagValue(v8, *((const __CFString **)this + 2), *((const __CFString **)this + 3), v9, v10, 1);
    }
  }
  return v7;
}

void IIOMetadata_Tag::setName(IIOMetadata_Tag *this, const __CFString *a2)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
  if (v2)
    CFRelease(v2);
}

CFArrayRef IIOMetadata_Tag::copyValue(IIOMetadata_Tag *this)
{
  const __CFString *v2;
  CFTypeID v3;
  int v4;

  v2 = (const __CFString *)*((_QWORD *)this + 6);
  v3 = CFGetTypeID(v2);
  v4 = *((_DWORD *)this + 10);
  if (v4 == 1)
  {
    if (v3 == CFStringGetTypeID())
      return (CFArrayRef)CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v2);
    v4 = *((_DWORD *)this + 10);
  }
  if ((v4 - 2) <= 3)
  {
    if (v3 == CFArrayGetTypeID())
      return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFArrayRef)v2);
    v4 = *((_DWORD *)this + 10);
  }
  if (v4 == 6)
    return CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFDictionaryRef)v2);
  LogMetadata("copyValue", 197, "'tag' has an unrecognized value type\n");
  return 0;
}

CFStringRef IIOMetadata_Tag::createPathWithChildPath(IIOMetadata_Tag *this, const __CFString *a2)
{
  const __CFAllocator *v4;
  CFStringRef result;
  CFStringRef v6;
  int CharacterAtIndex;
  const __CFString *v8;
  CFStringRef v10;
  CFStringRef v11;

  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  result = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@:%@"), *((_QWORD *)this + 3), *((_QWORD *)this + 4));
  if (result)
  {
    v6 = result;
    CharacterAtIndex = CFStringGetCharacterAtIndex(a2, 0);
    v8 = CFSTR("%@.%@");
    if (CharacterAtIndex == 46 || CharacterAtIndex == 63)
      v8 = CFSTR("%@%@");
    if (*((_DWORD *)this + 10) == 6)
      v10 = CFStringCreateWithFormat(v4, 0, v8, v6, a2);
    else
      v10 = CFStringCreateWithFormat(v4, 0, CFSTR("%@%@"), v6, a2);
    v11 = v10;
    CFRelease(v6);
    return v11;
  }
  return result;
}

CGMutableImageMetadataRef CGImageMetadataCreateMutableCopy(CGImageMetadataRef metadata)
{
  CFTypeID v2;
  const __CFAllocator *v3;
  uint64_t Instance;
  uint64_t v5;
  const __CFDictionary *v6;
  __CFDictionary *v7;
  int64_t Count;
  const void **v9;
  const void **v10;
  const void **v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  const void **v15;
  const void **v16;
  IIOMetadata_Tag *v17;
  CGImageMetadataTagRef DeepCopy;
  CGImageMetadataTagRef v19;
  const __CFDictionary *v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  const __CFString *v23;
  const __CFString *v24;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataCreateMutableCopy", 0, 0, -1, 0);
  if (!metadata)
    return 0;
  v2 = CFGetTypeID(metadata);
  if (v2 != CGImageMetadataGetTypeID())
    return 0;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  CGImageMetadataGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  v5 = Instance;
  if (Instance)
  {
    *(_BYTE *)(Instance + 16) = 1;
    v6 = (const __CFDictionary *)*((_QWORD *)metadata + 3);
    v7 = CGImageMetadataTagsDictCreate();
    if (!v6)
    {
LABEL_20:
      *(_QWORD *)(v5 + 24) = v7;
      v20 = (const __CFDictionary *)*((_QWORD *)metadata + 5);
      if (v20)
        *(_QWORD *)(v5 + 40) = CFDictionaryCreateMutableCopy(v3, 0, v20);
      v21 = (const __CFDictionary *)*((_QWORD *)metadata + 4);
      if (v21)
        *(_QWORD *)(v5 + 32) = CFDictionaryCreateMutableCopy(v3, 0, v21);
      v22 = (const __CFDictionary *)*((_QWORD *)metadata + 6);
      if (v22)
        *(_QWORD *)(v5 + 48) = CFDictionaryCreateMutableCopy(v3, 0, v22);
      v23 = (const __CFString *)*((_QWORD *)metadata + 7);
      if (v23)
        *(_QWORD *)(v5 + 56) = CFStringCreateCopy(v3, v23);
      v24 = (const __CFString *)*((_QWORD *)metadata + 8);
      if (v24)
        *(_QWORD *)(v5 + 64) = CFStringCreateCopy(v3, v24);
      initRecursivePthread_mutex((pthread_mutex_t *)(v5 + 72));
      pthread_mutex_init((pthread_mutex_t *)(v5 + 136), 0);
      initRecursivePthread_mutex((pthread_mutex_t *)(v5 + 208));
      return (CGMutableImageMetadataRef)v5;
    }
    Count = CFDictionaryGetCount(v6);
    v9 = (const void **)malloc_type_calloc(8uLL, Count, 0x69C4DE67uLL);
    v10 = (const void **)malloc_type_calloc(8uLL, Count, 0xBEFA0FF0uLL);
    v11 = v10;
    if (v9 && v10)
    {
      CFDictionaryGetKeysAndValues(v6, v9, v10);
      if (Count < 1)
      {
LABEL_17:
        free(v9);
LABEL_18:
        if (v11)
          free(v11);
        goto LABEL_20;
      }
      v15 = v11;
      v16 = v9;
      do
      {
        if (*v15)
        {
          v17 = (IIOMetadata_Tag *)*((_QWORD *)*v15 + 3);
          if (v17)
          {
            DeepCopy = IIOMetadata_Tag::createDeepCopy(v17, v12, v13, v14);
            if (DeepCopy)
            {
              v19 = DeepCopy;
              CFDictionarySetValue(v7, *v16, DeepCopy);
              CFRelease(v19);
            }
          }
        }
        ++v16;
        ++v15;
        --Count;
      }
      while (Count);
    }
    if (!v9)
      goto LABEL_18;
    goto LABEL_17;
  }
  return (CGMutableImageMetadataRef)v5;
}

void CGImageMetadataTagSetName(uint64_t a1, const __CFString *a2)
{
  IIOMetadata_Tag *v2;

  if (a1)
  {
    v2 = *(IIOMetadata_Tag **)(a1 + 24);
    if (v2)
      IIOMetadata_Tag::setName(v2, a2);
  }
}

uint64_t CGImageMetadataTagSetValueType(uint64_t result, int a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = *(_QWORD *)(result + 24);
    if (v2)
      *(_DWORD *)(v2 + 40) = a2;
  }
  return result;
}

CFStringRef CGImageMetadataTagCopyNamespace(CGImageMetadataTagRef tag)
{
  uint64_t v2;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyNamespace", 0, 0, -1, 0);
  if (tag && (v2 = *((_QWORD *)tag + 3)) != 0)
    return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFStringRef *)(v2 + 16));
  else
    return 0;
}

CFStringRef CGImageMetadataTagCopyName(CGImageMetadataTagRef tag)
{
  uint64_t v2;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyName", 0, 0, -1, 0);
  if (tag && (v2 = *((_QWORD *)tag + 3)) != 0)
    return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFStringRef *)(v2 + 32));
  else
    return 0;
}

CFStringRef CGImageMetadataTagCopyPrefix(CGImageMetadataTagRef tag)
{
  uint64_t v2;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyPrefix", 0, 0, -1, 0);
  if (tag && (v2 = *((_QWORD *)tag + 3)) != 0)
    return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFStringRef *)(v2 + 24));
  else
    return 0;
}

CFTypeRef CGImageMetadataTagCopyValue(CGImageMetadataTagRef tag)
{
  IIOMetadata_Tag *v2;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyValue", 0, 0, -1, 0);
  if (tag && (v2 = (IIOMetadata_Tag *)*((_QWORD *)tag + 3)) != 0)
    return IIOMetadata_Tag::copyValue(v2);
  else
    return 0;
}

CFArrayRef CGImageMetadataTagCopyQualifiers(CGImageMetadataTagRef tag)
{
  uint64_t v2;
  const __CFArray *v3;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyQualifiers", 0, 0, -1, 0);
  if (tag && (v2 = *((_QWORD *)tag + 3)) != 0 && (v3 = *(const __CFArray **)(v2 + 56)) != 0)
    return CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v3);
  else
    return 0;
}

uint64_t CGImageMetadataTagCreateFromImageProperty(const void *a1, const void *a2, uint64_t a3)
{
  CFTypeID v6;
  CFTypeID TypeID;
  CFTypeID v8;
  CFTypeID v9;
  uint64_t v10;
  _QWORD v12[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  if (a1)
  {
    v6 = CFGetTypeID(a1);
    TypeID = CFStringGetTypeID();
    if (a2)
    {
      if (v6 == TypeID)
      {
        v8 = CFGetTypeID(a2);
        v9 = CFStringGetTypeID();
        if (a3)
        {
          if (v8 == v9)
          {
            v12[0] = MEMORY[0x1E0C809B0];
            v12[1] = 0x40000000;
            v12[2] = __CGImageMetadataTagCreateFromImageProperty_block_invoke;
            v12[3] = &unk_1E1BBD360;
            v12[4] = &v13;
            v12[5] = a1;
            v12[6] = a2;
            v12[7] = a3;
            XMPMappingIterateUsingBlock((uint64_t)v12);
          }
        }
      }
    }
  }
  v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_1880366FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CGImageMetadataTagRef CGImageMetadataTagCopy(uint64_t a1)
{
  uint64_t v1;
  int v2;
  const __CFAllocator *v3;
  const void *Copy;
  const void *v5;
  CGImageMetadataTagRef v6;
  const __CFArray *v7;
  uint64_t v8;

  if (!a1)
    return 0;
  v1 = *(_QWORD *)(a1 + 24);
  v2 = *(_DWORD *)(v1 + 40);
  if ((v2 - 2) >= 4)
  {
    if (v2 == 6)
    {
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFDictionaryRef *)(v1 + 48));
    }
    else
    {
      if (v2 != 1)
        return 0;
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFStringRef *)(v1 + 48));
    }
  }
  else
  {
    v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFArrayRef *)(v1 + 48));
  }
  v5 = Copy;
  if (!Copy)
    return 0;
  v6 = CGImageMetadataTagCreate(*(CFStringRef *)(v1 + 16), *(CFStringRef *)(v1 + 24), *(CFStringRef *)(v1 + 32), (CGImageMetadataType)*(_DWORD *)(v1 + 40), Copy);
  CFRelease(v5);
  if (v6)
  {
    v7 = *(const __CFArray **)(v1 + 56);
    if (v7)
    {
      v8 = *((_QWORD *)v6 + 3);
      *(_QWORD *)(v8 + 56) = CFArrayCreateMutableCopy(v3, 0, v7);
    }
  }
  return v6;
}

CFStringRef _CGImageMetadataTagCopyFormattingDescription(CFTypeRef cf, const __CFDictionary *a2)
{
  CFTypeID v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v11;
  const __CFAllocator *v12;

  if (!cf || (CFTypeRef)*MEMORY[0x1E0C9B0D0] == cf)
    return 0;
  v3 = CFGetTypeID(cf);
  if (CGImageMetadataTagGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_33);
  if (v3 != CGImageMetadataTagGetTypeID::id)
    return 0;
  v4 = (_QWORD *)*((_QWORD *)cf + 3);
  v5 = v4[3];
  v6 = v4[4];
  v7 = v4[6];
  v8 = !v5 || v6 == 0;
  if (v8 || v7 == 0)
    return 0;
  v11 = v4[7];
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (v11)
    return CFStringCreateWithFormat(v12, 0, CFSTR("%@:%@ = %@, Qualifiers = %@"), v5, v6, v7, v11);
  else
    return CFStringCreateWithFormat(v12, 0, CFSTR("%@:%@ = %@"), v5, v6, v7);
}

CFStringRef _CGImageMetadataTagCopyDescription(CFTypeRef cf)
{
  CFTypeID v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v10;
  const __CFAllocator *v11;

  if (!cf || (CFTypeRef)*MEMORY[0x1E0C9B0D0] == cf)
    return 0;
  v2 = CFGetTypeID(cf);
  if (CGImageMetadataTagGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_33);
  if (v2 != CGImageMetadataTagGetTypeID::id)
    return 0;
  v3 = (_QWORD *)*((_QWORD *)cf + 3);
  v4 = v3[3];
  v5 = v3[4];
  v6 = v3[6];
  v7 = !v4 || v5 == 0;
  if (v7 || v6 == 0)
    return 0;
  v10 = v3[7];
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (v10)
    return CFStringCreateWithFormat(v11, 0, CFSTR("<CGImageMetadataTag %p> %@:%@ = %@, Qualifiers = %@"), cf, v4, v5, v6, v10);
  else
    return CFStringCreateWithFormat(v11, 0, CFSTR("<CGImageMetadataTag %p> %@:%@ = %@"), cf, v4, v5, v6);
}

void CGInitializeImageIO()
{
  const char *v0;

  if ((IIO_XPCServer() & 1) == 0)
  {
    v0 = getprogname();
    if (strncmp(v0, "ImageIOXPCService", 0x11uLL))
    {
      gWakeupTime = CFAbsoluteTimeGetCurrent();
      if (CGInitializeImageIO::initOnceToken != -1)
        dispatch_once(&CGInitializeImageIO::initOnceToken, &__block_literal_global_34);
    }
  }
}

uint64_t IIOXPCClient::processSupportsOOPCheckOnce(IIOXPCClient *this)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN12IIOXPCClient27processSupportsOOPCheckOnceEv_block_invoke;
  block[3] = &__block_descriptor_tmp_153;
  block[4] = this;
  if (IIOXPCClient::processSupportsOOPCheckOnce(void)::xpcClientSupportsOOP != -1)
    dispatch_once(&IIOXPCClient::processSupportsOOPCheckOnce(void)::xpcClientSupportsOOP, block);
  return IIOXPCClient::processSupportsOOPCheckOnce(void)::supportsOOP;
}

void sub_188036D94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIOXPCClient::wakeup_xpc_service(IIOXPCClient *this)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN12IIOXPCClient18wakeup_xpc_serviceEv_block_invoke;
  block[3] = &__block_descriptor_tmp_215;
  block[4] = this;
  if (IIOXPCClient::wakeup_xpc_service(void)::onceToken != -1)
    dispatch_once(&IIOXPCClient::wakeup_xpc_service(void)::onceToken, block);
}

void IIOXPCClient::~IIOXPCClient(IIOXPCClient *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E1BAC250;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
}

{
  IIOXPCClient::~IIOXPCClient(this);
  JUMPOUT(0x18D761C30);
}

uint64_t IIOXPCClient::checkEnvOverwrite(IIOXPCClient *this)
{
  int v2;
  uint64_t result;
  BOOL v4;

  v2 = IIO_OSAppleInternalBuild();
  result = (uint64_t)getenv("IIOEnableOOP");
  if (v2)
  {
    if (!result)
    {
      result = IOPreferencesGetBoolean("IIOEnableOOP", 0, (BOOL *)this + 100);
      *((_BYTE *)this + 99) = result;
      return result;
    }
    *((_BYTE *)this + 100) = 1;
    result = atoi((const char *)result);
    v4 = (_DWORD)result != 0;
    goto LABEL_9;
  }
  if (result)
  {
    *(_WORD *)((char *)this + 99) = 257;
    return result;
  }
  result = IOPreferencesGetBoolean("IIOEnableOOP", 0, (BOOL *)this + 100);
  if (*((_BYTE *)this + 100))
  {
    v4 = 1;
LABEL_9:
    *((_BYTE *)this + 99) = v4;
  }
  return result;
}

uint64_t IIOXPCClient::checkFeatureFlags(IIOXPCClient *this)
{
  int v2;
  uint64_t result;

  *((_BYTE *)this + 97) = 0;
  v2 = IIOLockDownModeEnabled();
  *((_BYTE *)this + 96) = v2;
  if (!v2)
  {
    result = *((unsigned __int8 *)this + 97);
    if (!*((_BYTE *)this + 97))
      return result;
    goto LABEL_5;
  }
  result = _os_feature_enabled_impl();
  *((_BYTE *)this + 97) = result;
  if ((_DWORD)result)
  {
LABEL_5:
    result = _os_feature_enabled_impl();
    *((_BYTE *)this + 98) = result;
  }
  return result;
}

BOOL IIOXPCClient::isPermanentlyExcludedAppleApp(IIOXPCClient *this, CFStringRef theString1, const char *a3)
{
  return theString1
      && (CFStringCompare(theString1, CFSTR("com.apple.MessagesAirlockService"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.MessagesBlastDoorService"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.MediaAnalysisBlastDoorService"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.QuickLookThumbnailing.extension-secure"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.WebKit.WebContent.CaptivePortal"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.WebKit.WebContent.Crashy"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.WebKit.WebContent.Development"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.WebKit.WebContentExtension"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.WebKit.WebContent"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.WebKit.WebContentCaptivePortalExtension"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.quicklook.thumbnail.OfficeExtension"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.quicklook.thumbnail.AudiovisualExtension"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.quicklook.thumbnail.TextExtension"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.apple.quicklook.thumbnail.ImageExtension"), 0) == kCFCompareEqualTo);
}

BOOL IIOXPCClient::isTemporaryExcludedAppleApp(IIOXPCClient *this, CFStringRef theString1, const char *a3)
{
  _BOOL8 result;

  result = 0;
  if (!*((_BYTE *)this + 96))
  {
    if (theString1)
    {
      *((_WORD *)this + 48) = 0;
      if (!*((_BYTE *)this + 98)
        && (CFStringCompare(theString1, CFSTR("com.apple.AppStore"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.Music"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.Home"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.Maps"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.MobileSMS"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.assetsd"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.deferredmediad"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.cameracaptured"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.Notes"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.systempreferences"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.imdpersistenceagent"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.gamed"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.Preferences"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.proximitycontrold"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.mediaremoted"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.chronod"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.InputUI"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.Camera"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.continuitycaptured"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.photos"), 1uLL) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.camera"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.mobileslideshow"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.mobileslideshow.photo-picker"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.mobileslideshow.photospicker"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.TVPhotos"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.mobileslideshow.PhotosMessagesApp"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.CoreGraphics.CGPDFService"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.camera.lockscreen"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.CarPlayApp"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.carplay"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.Preview"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.weather"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.podcasts"), 0) == kCFCompareEqualTo
         || CFStringCompare(theString1, CFSTR("com.apple.test.NullPlusPlus"), 0) == kCFCompareEqualTo))
      {
        return 1;
      }
    }
  }
  return result;
}

BOOL IIOXPCClient::isPermanentlyExcluded3rdPartyApp(IIOXPCClient *this, CFStringRef theString1, const char *a3)
{
  return theString1
      && (CFStringCompare(theString1, CFSTR("com.google.Chrome.helper.renderer"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.microsoft.edgemac.helper.renderer"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("company.thebrowser.browser.helper.renderer"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.brave.Browser.helper.renderer"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("org.qt-project.Qt.QtWebEngineProcess"), 0) == kCFCompareEqualTo
       || CFStringCompare(theString1, CFSTR("com.operasoftware.Opera.helper"), 0) == kCFCompareEqualTo);
}

BOOL IIOXPCClient::is3rdPartyApp(IIOXPCClient *this, CFStringRef theString, const char *a3)
{
  __CFBundle *MainBundle;
  const __CFDictionary *InfoDictionary;
  const void *Value;
  BOOL v7;

  if (!theString)
    return 0;
  if (CFStringHasPrefix(theString, CFSTR("com.apple.")))
    return 0;
  MainBundle = CFBundleGetMainBundle();
  InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
  Value = CFDictionaryGetValue(InfoDictionary, CFSTR("NSImageIOEnableOutOfProcess"));
  if (Value)
    v7 = Value == (const void *)*MEMORY[0x1E0C9AE50];
  else
    v7 = 0;
  return !v7;
}

uint64_t IIOXPCClient::runningAtBNI(IIOXPCClient *this, const __CFString *a2, const char *a3)
{
  uint64_t result;

  result = IIO_OSAppleInternalBuild();
  if ((_DWORD)result)
  {
    if (getenv("RC_XBS"))
    {
      _cg_jpeg_mem_term("runningAtBNI", 536, "*** ImageIO stays in process due to 'RC_XBS' \n");
    }
    else
    {
      result = (uint64_t)getenv("XBS_IS_CHROOTED");
      if (!result)
        return result;
      _cg_jpeg_mem_term("runningAtBNI", 542, "*** ImageIO stays in process due to 'XBS_IS_CHROOTED' \n");
    }
    return 1;
  }
  return result;
}

uint64_t ___ZN12IIOXPCClient27processSupportsOOPCheckOnceEv_block_invoke(uint64_t a1)
{
  IIOXPCClient *v1;
  const __CFString *v2;
  char *v3;
  const __CFString *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  const char *v9;
  const char *v11;
  char v12;
  _BOOL8 isTemporaryExcludedAppleApp;
  const char *v14;
  _BOOL8 isPermanentlyExcluded3rdPartyApp;
  const char *v16;

  v1 = *(IIOXPCClient **)(a1 + 32);
  v2 = (const __CFString *)IIOGetBundleIdentifer();
  v3 = (char *)getprogname();
  if ((IIOXPCClient::runningAtBNI((IIOXPCClient *)v3, v4, v5) & 1) != 0)
  {
    v6 = "B&I environment";
LABEL_5:
    v3 = "";
LABEL_6:
    IIOXPCClient::processSupportsOOPCheckOnce(void)::supportsOOP = 0;
    goto LABEL_7;
  }
  v7 = IIO_XPCServer();
  if ((v7 & 1) != 0)
  {
    v6 = "not supported on this platform";
    goto LABEL_5;
  }
  if (IIOXPCClient::isPermanentlyExcludedAppleApp((IIOXPCClient *)v7, v2, v8))
  {
    v6 = "disabled for ";
    goto LABEL_6;
  }
  IIOXPCClient::checkEnvOverwrite(v1);
  IIOXPCClient::checkFeatureFlags(v1);
  if (*((_BYTE *)v1 + 100))
  {
    v12 = *((_BYTE *)v1 + 99);
    IIOXPCClient::processSupportsOOPCheckOnce(void)::supportsOOP = v12;
    v6 = "env";
  }
  else
  {
    if (!*((_BYTE *)v1 + 97))
    {
      v6 = "ff";
      goto LABEL_5;
    }
    isTemporaryExcludedAppleApp = IIOXPCClient::isTemporaryExcludedAppleApp(v1, v2, v11);
    if (isTemporaryExcludedAppleApp)
    {
      v6 = "temporary disabled for ";
      goto LABEL_6;
    }
    isPermanentlyExcluded3rdPartyApp = IIOXPCClient::isPermanentlyExcluded3rdPartyApp((IIOXPCClient *)isTemporaryExcludedAppleApp, v2, v14);
    if (isPermanentlyExcluded3rdPartyApp)
    {
      v6 = "permanently disabled for 3rd party app ";
      goto LABEL_6;
    }
    if (IIOXPCClient::is3rdPartyApp((IIOXPCClient *)isPermanentlyExcluded3rdPartyApp, v2, v16))
    {
      v6 = "disabled for 3rd party app ";
      goto LABEL_6;
    }
    v12 = IIOXPCClient::processSupportsOOPCheckOnce(void)::supportsOOP;
    v6 = "";
  }
  v3 = "";
  if (v12)
  {
    v9 = "enabled";
    return ImageIOLogInternal("*** ImageIO OOP %s (%s%s)\n", v9, v6, v3);
  }
LABEL_7:
  v9 = "disabled";
  return ImageIOLogInternal("*** ImageIO OOP %s (%s%s)\n", v9, v6, v3);
}

uint64_t IIOXPCClient::CanCheckTrustedURL(IIOXPCClient *this)
{
  if (IIOXPCClient::CanCheckTrustedURL(void)::onceToken != -1)
    dispatch_once(&IIOXPCClient::CanCheckTrustedURL(void)::onceToken, &__block_literal_global_157);
  return IIOXPCClient::CanCheckTrustedURL(void)::canCheckTrustedURL;
}

uint64_t ___ZN12IIOXPCClient18CanCheckTrustedURLEv_block_invoke(IIOXPCClient *a1)
{
  uint64_t result;

  result = IIOXPCClient::ProcessSupportsOOP(a1);
  IIOXPCClient::CanCheckTrustedURL(void)::canCheckTrustedURL = result;
  if ((_DWORD)result)
  {
    getpid();
    result = sandbox_check();
    IIOXPCClient::CanCheckTrustedURL(void)::canCheckTrustedURL = (_DWORD)result == 0;
  }
  return result;
}

void IIOXPCClient::connection_set_event_handler(IIOXPCClient *this, _xpc_connection_s *a2, dispatch_queue_s *a3)
{
  _QWORD handler[6];

  if (!a2)
    IIOXPCClient::connection_set_event_handler();
  IIOXPCLog("connection_set_event_handler %p\n", a2);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = ___ZN12IIOXPCClient28connection_set_event_handlerEP17_xpc_connection_sP16dispatch_queue_s_block_invoke;
  handler[3] = &__block_descriptor_tmp_174;
  handler[4] = this;
  handler[5] = a2;
  xpc_connection_set_event_handler(a2, handler);
  xpc_connection_resume(a2);
}

void ___ZN12IIOXPCClient28connection_set_event_handlerEP17_xpc_connection_sP16dispatch_queue_s_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v4;
  const char *name;
  const char *v6;
  const char *string;
  void *v8;
  const char *v9;
  const char *v10;
  const char *v11;

  v4 = *(_QWORD *)(a1 + 32);
  name = xpc_connection_get_name(*(xpc_connection_t *)(a1 + 40));
  IIOXPCLog("xpc connection  event handler called for %s\n", name);
  if (MEMORY[0x18D763274](a2) == MEMORY[0x1E0C81310])
  {
    v6 = (const char *)*MEMORY[0x1E0C81270];
    string = xpc_dictionary_get_string(a2, (const char *)*MEMORY[0x1E0C81270]);
    if (a2 == (void *)MEMORY[0x1E0C81258])
    {
      v10 = string;
      v11 = xpc_connection_get_name(*(xpc_connection_t *)(a1 + 40));
      ImageIOLog("❌ ImageIOXPC: connection interrupted: %s (%s)\n", v11, v10);
      kdebug_trace();
      *(_BYTE *)(v4 + 103) = 0;
    }
    else
    {
      v8 = (void *)MEMORY[0x1E0C81260];
      v9 = xpc_connection_get_name(*(xpc_connection_t *)(a1 + 40));
      if (a2 == v8)
      {
        ImageIOLog("❌ XPC_ERROR_CONNECTION_INVALID: %s\n", v9);
        kdebug_trace();
      }
      else
      {
        xpc_dictionary_get_string(a2, v6);
        IIOXPCLog("❌ ImageIOXPC: connection %s received unexpected error event: %s\n");
      }
    }
  }
  else
  {
    xpc_connection_get_name(*(xpc_connection_t *)(a1 + 40));
    IIOXPCLog("❌ ImageIOXPC: received unexpected event in connection handler for service %s\n");
  }
}

double iio_xpc_get_CGRect_from_xpcObj(void *a1)
{
  double v2;

  if (xpc_dictionary_get_count(a1) != 4)
    return 0.0;
  v2 = xpc_dictionary_get_double(a1, "origin_x");
  xpc_dictionary_get_double(a1, "origin_y");
  xpc_dictionary_get_double(a1, "size_width");
  xpc_dictionary_get_double(a1, "size_height");
  return v2;
}

void iio_xpc_get_CGSize_from_xpcObj(void *a1)
{
  if (xpc_dictionary_get_count(a1) == 2)
  {
    xpc_dictionary_get_double(a1, "size_width");
    xpc_dictionary_get_double(a1, "size_height");
  }
}

uint64_t ___ZN12IIOXPCClient18wakeup_xpc_serviceEv_block_invoke(uint64_t a1)
{
  IIOXPCClient *v1;
  xpc_object_t v2;
  void *v3;
  pid_t v4;
  dispatch_queue_t v5;
  NSObject *v6;
  _xpc_connection_s *v7;

  v1 = *(IIOXPCClient **)(a1 + 32);
  kdebug_trace();
  v2 = xpc_dictionary_create(0, 0, 0);
  if (v2)
  {
    v3 = v2;
    if (!*((_BYTE *)v1 + 101))
    {
      xpc_dictionary_set_uint64(v2, "iio_xpc_message_id", 8uLL);
      xpc_dictionary_set_uint64(v3, "iio_xpc_msg_debugflags", gIIODebugFlags);
      v4 = getpid();
      xpc_dictionary_set_uint64(v3, "iio_xpc_msg_pid", v4);
      v5 = dispatch_queue_create("com.apple.iio.queue", MEMORY[0x1E0C80D50]);
      if (!v5)
        ___ZN12IIOXPCClient18wakeup_xpc_serviceEv_block_invoke_cold_1();
      v6 = v5;
      v7 = (_xpc_connection_s *)IIOXPCClient::xpc_service_connection(v1);
      xpc_connection_send_message_with_reply(v7, v3, v6, &__block_literal_global_214);
      dispatch_release(v6);
    }
    xpc_release(v3);
  }
  return kdebug_trace();
}

xpc_object_t ___ZN12IIOXPCClient18wakeup_xpc_serviceEv_block_invoke_2(int a1, xpc_object_t xdict)
{
  return xpc_dictionary_get_dictionary(xdict, "iio_xpc_msg");
}

xpc_object_t iio_xpc_get_message_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_msg");
}

xpc_object_t IIOXPCClient::send_message_with_reply(IIOXPCClient *this, _xpc_connection_s *a2, dispatch_queue_s *a3, xpc_object_t xdict)
{
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  double v10;
  pid_t v11;
  xpc_object_t v12;
  xpc_object_t empty;
  IIOXPCClient *v14;
  xpc_object_t v15;
  int64_t v16;
  const char *string;
  uint64_t uint64;
  uint64_t v19;
  _BYTE v21[16];
  CFPropertyListRef value;

  do
    v7 = __ldaxr(&IIOXPCClient::send_message_with_reply(_xpc_connection_s *,dispatch_queue_s *,void *)::gTransactionID);
  while (__stlxr(v7 + 1, &IIOXPCClient::send_message_with_reply(_xpc_connection_s *,dispatch_queue_s *,void *)::gTransactionID));
  v8 = atomic_load(&IIOXPCClient::send_message_with_reply(_xpc_connection_s *,dispatch_queue_s *,void *)::gTransactionID);
  xpc_dictionary_set_uint64(xdict, "iio_xpc_transacion_id", v8);
  v9 = atomic_load(&IIOXPCClient::send_message_with_reply(_xpc_connection_s *,dispatch_queue_s *,void *)::gTransactionID);
  if (v9 == 1)
  {
    gFirstCallTime = CFAbsoluteTimeGetCurrent();
    ImageIOLogInternal("⏹️   ImageIO: first ImageIO call after %g seconds [previously: %g]...\n", *(double *)&gFirstCallTime - *(double *)&gWakeupTime, *(double *)&gSavedFirstCallTime);
    v10 = *(double *)&gFirstCallTime - *(double *)&gWakeupTime;
    if (*(double *)&gSavedFirstCallTime >= 0.0)
    {
      if (*(double *)&gSavedFirstCallTime - v10 <= 0.01)
      {
LABEL_10:
        kdebug_trace();
        v11 = getpid();
        xpc_dictionary_set_uint64(xdict, "iio_xpc_msg_pid", v11);
        goto LABEL_11;
      }
      *(double *)&gSavedFirstCallTime = *(double *)&gFirstCallTime - *(double *)&gWakeupTime;
      ImageIOLogInternal("⏹️   ImageIO: updating first IIO ImageIO to %g\n", v10);
      IIONumber::IIONumber((IIONumber *)v21, *(double *)&gSavedFirstCallTime);
      CFPreferencesSetAppValue(CFSTR("IIO_LaunchInfo"), value, (CFStringRef)*MEMORY[0x1E0C9B248]);
    }
    else
    {
      if (v10 > 8.0)
        v10 = 8.0;
      gSavedFirstCallTime = *(_QWORD *)&v10;
      ImageIOLogInternal("⏹️   ImageIO: updating first ImageIO call to %g\n", v10);
      IIONumber::IIONumber((IIONumber *)v21, *(double *)&gSavedFirstCallTime);
      CFPreferencesSetAppValue(CFSTR("IIO_LaunchInfo"), value, (CFStringRef)*MEMORY[0x1E0C9B248]);
    }
    IIONumber::~IIONumber((IIONumber *)v21);
    goto LABEL_10;
  }
LABEL_11:
  IIOSavePermissionsToXPCObject(xdict);
  IIOSaveAllowedTypesToXPCObject(xdict);
  *((_BYTE *)this + 101) = 1;
  v12 = xpc_connection_send_message_with_reply_sync(a2, xdict);
  empty = v12;
  if (v12)
  {
    v14 = (IIOXPCClient *)MEMORY[0x18D763274](v12);
    if (v14 == (IIOXPCClient *)MEMORY[0x1E0C81310])
    {
      kdebug_trace();
      string = xpc_dictionary_get_string(empty, (const char *)*MEMORY[0x1E0C81270]);
      LogFault("send_message_with_reply", 1112, "❌ Error: ImageIOXPCService send message error: %s\n", string);
      xpc_release(empty);
      empty = xpc_dictionary_create_empty();
      v15 = iio_xpc_add_message_dict(empty);
      if (!v15)
      {
LABEL_19:
        uint64 = xpc_dictionary_get_uint64(xdict, "iio_xpc_message_id");
        xpc_dictionary_set_uint64(empty, "iio_xpc_message_id", uint64);
        v19 = xpc_dictionary_get_uint64(xdict, "iio_xpc_transacion_id");
        xpc_dictionary_set_uint64(empty, "iio_xpc_transacion_id", v19);
        return empty;
      }
      v16 = 0x70000000FFFFFA88;
    }
    else
    {
      if (IIOXPCClient::replyIsValid(v14, empty))
        goto LABEL_19;
      xpc_release(empty);
      empty = xpc_dictionary_create_empty();
      v15 = iio_xpc_add_message_dict(empty);
      if (!v15)
        goto LABEL_19;
      v16 = 0x70000000FFFFFA87;
    }
    xpc_dictionary_set_int64(v15, "iio_xpc_msg_error", v16);
    goto LABEL_19;
  }
  return empty;
}

void sub_188037FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

xpc_object_t iio_xpc_add_message_dict(void *a1)
{
  xpc_object_t dictionary;

  dictionary = xpc_dictionary_get_dictionary(a1, "iio_xpc_msg");
  if (!dictionary)
  {
    dictionary = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_msg", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

void iio_xpc_dictionary_set_error_code(void *a1, unsigned int a2)
{
  if (a1)
    xpc_dictionary_set_int64(a1, "iio_xpc_msg_error", a2 | 0x7000000000000000);
}

BOOL IIOXPCClient::replyIsValid(IIOXPCClient *this, void *a2)
{
  _BOOL8 v3;
  _QWORD applier[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 1;
  if (MEMORY[0x18D763274](a2) == MEMORY[0x1E0C812F8])
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 0x40000000;
    applier[2] = ___ZN12IIOXPCClient12replyIsValidEPv_block_invoke;
    applier[3] = &unk_1E1BC9EE0;
    applier[4] = &v6;
    xpc_dictionary_apply(a2, applier);
    v3 = *((_BYTE *)v7 + 24) != 0;
  }
  else
  {
    v3 = 0;
    *((_BYTE *)v7 + 24) = 0;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_188038140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12IIOXPCClient12replyIsValidEPv_block_invoke(uint64_t a1, char *__s)
{
  size_t v4;
  size_t v5;
  BOOL v6;
  uint64_t result;

  v4 = strspn(__s, "abcdefghijklmnopqrstuvwxyz0123456789_");
  v5 = strlen(__s);
  v6 = v4 == v5 && v5 >= 9;
  if (v6
    && !strncmp("iio_xpc_", __s, 8uLL)
    && strncmp("iio_xpc_message_id", __s, 0x12uLL)
    && strncmp("iio_xpc_transacion_id", __s, 0x15uLL))
  {
    return 1;
  }
  result = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

dispatch_queue_t IIOXPCClient::xpc_service_queue(IIOXPCClient *this)
{
  dispatch_queue_t result;

  if (*((_BYTE *)this + 102))
    return (dispatch_queue_t)*((_QWORD *)this + 2);
  *((_BYTE *)this + 102) = 1;
  IIOXPCLog("create xpc service queue\n");
  result = dispatch_queue_create("com.apple.ImageIOXPCService.queue", 0);
  *((_QWORD *)this + 2) = result;
  return result;
}

uint64_t IIOXPCClient::xpc_service_connection(IIOXPCClient *this)
{
  pthread_mutex_t *v2;
  _xpc_connection_s *v3;
  dispatch_queue_s *v4;

  v2 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  if (!*((_BYTE *)this + 103))
  {
    *((_BYTE *)this + 103) = 1;
    IIOXPCLog("create xpc service connection (_connection: %p)\n", *((const void **)this + 3));
    v3 = xpc_connection_create("com.apple.ImageIOXPCService", 0);
    *((_QWORD *)this + 3) = v3;
    IIOXPCClient::connection_set_event_handler(this, v3, v4);
  }
  pthread_mutex_unlock(v2);
  return *((_QWORD *)this + 3);
}

BOOL iio_xpc_dictionary_add_databuffer(void *a1, const char *a2, void *buffer, size_t size)
{
  NSObject *v6;
  NSObject *v7;
  xpc_object_t v8;
  _BOOL8 v9;
  void *v10;

  v6 = dispatch_data_create(buffer, size, 0, 0);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = xpc_data_create_with_dispatch_data(v6);
  v9 = v8 != 0;
  if (v8)
  {
    v10 = v8;
    xpc_dictionary_set_value(a1, a2, v8);
    xpc_release(v10);
  }
  dispatch_release(v7);
  return v9;
}

BOOL iio_xpc_dictionary_add_CFData(void *a1, const char *a2, CFDataRef theData)
{
  UInt8 *BytePtr;
  size_t Length;

  BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  return iio_xpc_dictionary_add_databuffer(a1, a2, BytePtr, Length);
}

void *iio_xpc_add_xpcObj_from_CGRect(double a1, double a2, double a3, double a4)
{
  xpc_object_t empty;
  void *v9;

  empty = xpc_dictionary_create_empty();
  v9 = empty;
  if (empty)
  {
    xpc_dictionary_set_double(empty, "origin_x", a1);
    xpc_dictionary_set_double(v9, "origin_y", a2);
    xpc_dictionary_set_double(v9, "size_width", a3);
    xpc_dictionary_set_double(v9, "size_height", a4);
  }
  return v9;
}

void *iio_xpc_add_xpcObj_from_CGSize(double a1, double a2)
{
  xpc_object_t empty;
  void *v5;

  empty = xpc_dictionary_create_empty();
  v5 = empty;
  if (empty)
  {
    xpc_dictionary_set_double(empty, "size_width", a1);
    xpc_dictionary_set_double(v5, "size_height", a2);
  }
  return v5;
}

void iio_xpc_dictionary_addCGRect(void *a1, const char *a2, double a3, double a4, double a5, double a6)
{
  void *v8;
  void *v9;

  v8 = iio_xpc_add_xpcObj_from_CGRect(a3, a4, a5, a6);
  if (v8)
  {
    v9 = v8;
    xpc_dictionary_set_value(a1, a2, v8);
    xpc_release(v9);
  }
}

double iio_xpc_dictionary_get_CGRect(void *a1, const char *a2)
{
  xpc_object_t value;

  value = xpc_dictionary_get_value(a1, a2);
  return iio_xpc_get_CGRect_from_xpcObj(value);
}

void iio_xpc_dictionary_addCGSize(void *a1, const char *a2, double a3, double a4)
{
  void *v6;
  void *v7;

  v6 = iio_xpc_add_xpcObj_from_CGSize(a3, a4);
  if (v6)
  {
    v7 = v6;
    xpc_dictionary_set_value(a1, a2, v6);
    xpc_release(v7);
  }
}

void iio_xpc_dictionary_get_CGSize(void *a1, const char *a2)
{
  xpc_object_t value;

  value = xpc_dictionary_get_value(a1, a2);
  iio_xpc_get_CGSize_from_xpcObj(value);
}

void iio_xpc_dictionary_add_GlobalInfo(void *a1, const __CFData *a2, unsigned int a3)
{
  xpc_object_t empty;
  uint64_t Length;

  if (a2)
  {
    empty = xpc_dictionary_create_empty();
    iio_xpc_dictionary_add_CFData(empty, "iio_xpc_plugin_global_info_data", a2);
    Length = CFDataGetLength(a2);
    xpc_dictionary_set_uint64(empty, "iio_xpc_plugin_global_info_data_size", Length);
    xpc_dictionary_set_uint64(empty, "iio_xpc_plugin_global_info_ostype", a3);
    xpc_dictionary_set_value(a1, "iio_xpc_plugin_global_info", empty);
    xpc_release(empty);
  }
}

xpc_object_t iio_xpc_dictionary_get_GlobalInfo(void *a1, uint64_t *a2)
{
  xpc_object_t result;
  void *v4;
  void *data;
  uint64_t uint64;
  uint64_t v7;
  size_t length;

  length = 0;
  result = xpc_dictionary_get_dictionary(a1, "iio_xpc_plugin_global_info");
  if (!result)
  {
    v7 = 0;
    if (!a2)
      return result;
    goto LABEL_9;
  }
  v4 = result;
  data = (void *)xpc_dictionary_get_data(result, "iio_xpc_plugin_global_info_data", &length);
  uint64 = xpc_dictionary_get_uint64(v4, "iio_xpc_plugin_global_info_data_size");
  if (uint64 == length)
    v7 = uint64;
  else
    v7 = 0;
  if (uint64 == length)
    result = data;
  else
    result = 0;
  if (a2)
LABEL_9:
    *a2 = v7;
  return result;
}

xpc_object_t iio_xpc_dictionary_copy_CFDictionary(void *a1, const char *a2)
{
  xpc_object_t result;

  result = xpc_dictionary_get_dictionary(a1, a2);
  if (result)
    return (xpc_object_t)_CFXPCCreateCFObjectFromXPCObject();
  return result;
}

uint64_t iio_xpc_dictionary_add_CFDictionary(void *a1, const char *a2)
{
  void *v4;
  void *v5;

  v4 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (!v4)
    return 4294967246;
  v5 = v4;
  xpc_dictionary_set_value(a1, a2, v4);
  xpc_release(v5);
  return 0;
}

uint64_t iio_xpc_dictionary_get_error_code(void *a1)
{
  uint64_t v1;
  int64_t int64;

  v1 = 4294965895;
  if (a1)
  {
    int64 = xpc_dictionary_get_int64(a1, "iio_xpc_msg_error");
    if ((~int64 & 0x7000000000000000) != 0)
      return 4294965895;
    else
      return int64;
  }
  return v1;
}

xpc_object_t iio_xpc_get_source_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_src");
}

xpc_object_t iio_xpc_get_plugin_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_plugin");
}

xpc_object_t iio_xpc_get_callback_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_cb");
}

xpc_object_t iio_xpc_get_permission_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_permission");
}

xpc_object_t iio_xpc_add_source_dict(void *a1)
{
  xpc_object_t dictionary;

  dictionary = xpc_dictionary_get_dictionary(a1, "iio_xpc_src");
  if (!dictionary)
  {
    dictionary = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_src", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

xpc_object_t iio_xpc_add_plugin_dict(void *a1)
{
  xpc_object_t dictionary;

  dictionary = xpc_dictionary_get_dictionary(a1, "iio_xpc_plugin");
  if (!dictionary)
  {
    dictionary = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_plugin", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

xpc_object_t iio_xpc_add_callback_dict(void *a1)
{
  xpc_object_t dictionary;

  dictionary = xpc_dictionary_get_dictionary(a1, "iio_xpc_cb");
  if (!dictionary)
  {
    dictionary = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_cb", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

xpc_object_t iio_xpc_add_permission_dict(void *a1)
{
  xpc_object_t dictionary;

  dictionary = xpc_dictionary_get_dictionary(a1, "iio_xpc_permission");
  if (!dictionary)
  {
    dictionary = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_permission", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

unsigned int *png_do_gray_to_rgb(unsigned int *result, uint64_t a2)
{
  unsigned int v2;
  int v3;
  uint64_t v4;
  int v5;
  char *v6;
  char *v7;
  char v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  _BYTE *v14;
  char v15;
  unsigned __int8 v16;
  unint64_t v17;
  unint64_t v18;

  v2 = *((unsigned __int8 *)result + 17);
  if (v2 >= 8)
  {
    v3 = *((unsigned __int8 *)result + 16);
    if ((v3 & 2) == 0)
    {
      v4 = *result;
      v5 = *result;
      if (v3 == 4)
      {
        if (v2 == 8)
        {
          if (v5)
          {
            v9 = (_BYTE *)(a2 + 2 * v4 - 1);
            v10 = &v9[2 * v4];
            do
            {
              *v10 = *v9;
              *(v10 - 1) = *(v9 - 1);
              *(v10 - 2) = *(v9 - 1);
              *(v10 - 3) = *(v9 - 1);
              v10 -= 4;
              v9 -= 2;
              --v5;
            }
            while (v5);
          }
        }
        else if (v5)
        {
          v13 = (_BYTE *)(a2 + 4 * v4 - 1);
          v14 = &v13[4 * v4];
          do
          {
            *v14 = *v13;
            *(v14 - 1) = *(v13 - 1);
            *(v14 - 2) = *(v13 - 2);
            *(v14 - 3) = *(v13 - 3);
            *(v14 - 4) = *(v13 - 2);
            *(v14 - 5) = *(v13 - 3);
            *(v14 - 6) = *(v13 - 2);
            *(v14 - 7) = *(v13 - 3);
            v14 -= 8;
            v13 -= 4;
            --v5;
          }
          while (v5);
        }
      }
      else if (!*((_BYTE *)result + 16))
      {
        if (v2 == 8)
        {
          if (v5)
          {
            v6 = (char *)(v4 + a2 - 1);
            v7 = &v6[2 * v4];
            do
            {
              *v7 = *v6;
              *(v7 - 1) = *v6;
              v8 = *v6--;
              *(v7 - 2) = v8;
              v7 -= 3;
              --v5;
            }
            while (v5);
          }
        }
        else if (v5)
        {
          v11 = (_BYTE *)(a2 + 2 * v4 - 1);
          v12 = &v11[4 * v4];
          do
          {
            *v12 = *v11;
            *(v12 - 1) = *(v11 - 1);
            *(v12 - 2) = *v11;
            *(v12 - 3) = *(v11 - 1);
            *(v12 - 4) = *v11;
            *(v12 - 5) = *(v11 - 1);
            v12 -= 6;
            v11 -= 2;
            --v5;
          }
          while (v5);
        }
      }
      v15 = *((_BYTE *)result + 18) + 2;
      *((_BYTE *)result + 18) = v15;
      *((_BYTE *)result + 16) |= 2u;
      v16 = *((_BYTE *)result + 17) * v15;
      *((_BYTE *)result + 19) = v16;
      v17 = (v16 * (unint64_t)v4 + 7) >> 3;
      v18 = v4 * (unint64_t)(v16 >> 3);
      if (v16 < 8u)
        v18 = v17;
      *((_QWORD *)result + 1) = v18;
    }
  }
  return result;
}

void yyerror(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v10;
  uint64_t v11;
  char *__s1[2];

  __s1[0] = 0;
  __s1[1] = &a9;
  vasprintf(__s1, a2, &a9);
  v10 = __s1[0];
  if (__s1[0])
  {
    if (a1 && (v11 = *(_QWORD *)(a1 + 16)) != 0)
    {
      if (!*(_QWORD *)(v11 + 16))
        *(_QWORD *)(v11 + 16) = strdup(__s1[0]);
    }
    else
    {
      fputs(__s1[0], (FILE *)*MEMORY[0x1E0C80C10]);
      v10 = __s1[0];
    }
    free(v10);
  }
}

uint64_t IIO_Reader_OpenEXR::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  EXRReadPlugin::EXRReadPlugin(v4, a2, v5);
  return v4;
}

void sub_188038B94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F3C404799A226);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_OpenEXR::createReadPlugin(IIO_Reader *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  EXRReadPlugin::EXRReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_188038C30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F3C404799A226);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_OpenEXR::getImageCount(IIO_Reader_OpenEXR *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  IIOImageRead *v7;
  IIOImageRead *Size;
  void *v9;
  const char *name;
  unsigned int part_count;
  uint64_t v13;
  void *v14;

  if (!AppleEXREnabled())
  {
    part_count = 1;
    if (!a5)
      return 0;
    goto LABEL_10;
  }
  v14 = 0;
  v7 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v14, 1);
  Size = IIOImageReadSession::getSize(a2);
  v13 = 0;
  v9 = (void *)gFunc_axr_data_create(v7, Size, &v13, 0, 0);
  if (v13)
  {
    name = (const char *)gFunc_axr_error_get_name();
    LogError("getImageCount", 85, "*** axr_data_create failed: %s (%d)\n", name, v13);
  }
  if (v9)
  {
    part_count = gFunc_axr_data_get_part_count(v9);
    os_release(v9);
  }
  else
  {
    part_count = 0;
  }
  IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v14);
  if (a5)
LABEL_10:
    *a5 = part_count;
  return 0;
}

uint64_t IIO_Reader_OpenEXR::UpdateImageInfo(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t view_name;
  unint64_t image_count;
  uint64_t v7;
  BOOL v8;
  uint64_t image_name;
  uint64_t i;
  const std::string::value_type *v11;
  void *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t view_count;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22[2];
  void *v23[2];
  void *v24[2];
  __int128 v25;
  void *__p[2];
  _OWORD v27[5];

  view_count = gFunc_axr_logical_image_list_get_view_count();
  if (!view_count)
  {
    _cg_jpeg_mem_term("UpdateImageInfo", 134, "*** ERROR: axr_logical_image_list_get_view_count returned 0\n");
    return 4294967246;
  }
  v4 = 0;
  while (2)
  {
    memset(v27, 0, 72);
    v25 = 0u;
    *(_OWORD *)__p = 0u;
    *(_OWORD *)v23 = 0u;
    *(_OWORD *)v24 = 0u;
    memset(v22, 0, sizeof(v22));
    DWORD1(v22[0]) = v4;
    view_name = gFunc_axr_logical_image_list_get_view_name(a1, v4);
    MEMORY[0x18D761A14](v23, view_name);
    image_count = gFunc_axr_logical_image_list_get_image_count(a1, v4);
    if (!image_count)
    {
LABEL_26:
      v8 = 0;
      v15 = 0;
      goto LABEL_27;
    }
    v7 = 0;
    v8 = 1;
    while (1)
    {
      DWORD2(v22[0]) = v7;
      image_name = gFunc_axr_logical_image_list_get_image_name(a1, v4, v7);
      MEMORY[0x18D761A14](&v24[1], image_name);
      gFunc_axr_logical_image_list_get_image_info(&v18, a1, v4, v7, 1);
      *(_OWORD *)((char *)&v27[2] + 8) = v20;
      *(_OWORD *)((char *)&v27[3] + 8) = v21;
      *(_OWORD *)((char *)v27 + 8) = v18;
      *(_OWORD *)((char *)&v27[1] + 8) = v19;
      if (!(_DWORD)v19)
        goto LABEL_8;
      if ((_DWORD)v19 != 1)
        break;
      LOWORD(v22[0]) = 16;
LABEL_10:
      MEMORY[0x18D761A14](__p, "");
      for (i = 32; i != -1; --i)
      {
        if (((*((_QWORD *)&v27[0] + 1) >> i) & 1) != 0)
        {
          v11 = "";
          if (i <= 0x11)
            v11 = off_1E1BC9F00[i];
          std::string::append((std::string *)__p, v11);
        }
      }
      if (LODWORD(v27[3]) <= 3)
        memset((char *)&v27[3] + 4 * LODWORD(v27[3]) + 4, 255, 4 * (3 - LODWORD(v27[3])) + 4);
      v12 = (void *)BYTE7(v27[0]);
      if (SBYTE7(v27[0]) < 0)
        v12 = __p[1];
      if (v12)
        std::string::append((std::string *)__p, " ");
      v13 = a2[1];
      if (v13 >= a2[2])
      {
        v14 = std::vector<EXRPluginData>::__push_back_slow_path<EXRPluginData const&>(a2, v22);
      }
      else
      {
        std::allocator<EXRPluginData>::construct[abi:ne180100]<EXRPluginData,EXRPluginData const&>((uint64_t)(a2 + 2), a2[1], v22);
        v14 = v13 + 168;
        a2[1] = v13 + 168;
      }
      a2[1] = v14;
      v8 = ++v7 < image_count;
      if (v7 == image_count)
        goto LABEL_26;
    }
    if ((_DWORD)v19 == 2)
    {
LABEL_8:
      LOWORD(v22[0]) = 32;
      goto LABEL_10;
    }
    LogError("UpdateImageInfo", 156, "*** ERROR: unexpected imageInfo.type: %d\n", DWORD2(v27[1]));
    v15 = 4294967246;
LABEL_27:
    if (SBYTE7(v27[0]) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v25) < 0)
      operator delete(v24[1]);
    if (SHIBYTE(v24[0]) < 0)
      operator delete(v23[0]);
    if (!v8)
    {
      if (++v4 == view_count)
      {
        if (a2[1] == *a2)
          return 4294967246;
        else
          return v15;
      }
      continue;
    }
    return v15;
  }
}

void sub_18803907C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  EXRPluginData::~EXRPluginData((void **)va);
  _Unwind_Resume(a1);
}

void EXRPluginData::~EXRPluginData(void **this)
{
  if (*((char *)this + 103) < 0)
    operator delete(this[10]);
  if (*((char *)this + 79) < 0)
    operator delete(this[7]);
  if (*((char *)this + 55) < 0)
    operator delete(this[4]);
}

uint64_t IIO_Reader_OpenEXR::updatePartInfo(IIO_Reader_OpenEXR *this, IIODictionary *a2, axr_data *a3, EXRPluginData *a4)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  float v12;
  float v13;
  float v14;
  float v15;
  const char *v16;
  const char *v17;
  const char *name;
  unsigned int v20;
  int v21;
  _BYTE v22[24];
  _BYTE v23[24];
  _BYTE v24[24];
  _BYTE v25[24];
  CFMutableArrayRef v26;
  void *v27;
  void *v28;
  _BYTE v29[24];
  _BYTE v30[24];
  _BYTE v31[24];
  _BYTE v32[24];
  CFMutableArrayRef v33;
  void *v34;
  uint64_t v35;
  _BYTE v36[24];
  _BYTE v37[24];
  _BYTE v38[24];
  _BYTE v39[24];
  CFMutableArrayRef v40;
  const void *v41;
  uint64_t v42;
  int v43;
  int v44;
  unsigned int v45;
  float v46;
  float v47;
  float v48;
  float v49;
  const char *v50;
  const char *v51;

  gFunc_axr_data_get_part_info(&v40, a3, *((unsigned int *)a4 + 31), 1);
  v5 = (int)v40;
  v6 = HIDWORD(v40);
  v7 = (int)v41;
  v8 = HIDWORD(v41);
  v10 = v42;
  v9 = HIDWORD(v42);
  v11 = v43;
  v20 = v45;
  v21 = v44;
  v13 = v46;
  v12 = v47;
  v14 = v48;
  v15 = v49;
  v17 = v50;
  v16 = v51;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  IIOArray::IIOArray((IIOArray *)&v40);
  IIONumber::IIONumber((IIONumber *)v39, v5);
  IIOArray::addObject(&v40, (uint64_t)v39);
  IIONumber::~IIONumber((IIONumber *)v39);
  IIONumber::IIONumber((IIONumber *)v38, v7);
  IIOArray::addObject(&v40, (uint64_t)v38);
  IIONumber::~IIONumber((IIONumber *)v38);
  IIONumber::IIONumber((IIONumber *)v37, v6);
  IIOArray::addObject(&v40, (uint64_t)v37);
  IIONumber::~IIONumber((IIONumber *)v37);
  IIONumber::IIONumber((IIONumber *)v36, v8);
  IIOArray::addObject(&v40, (uint64_t)v36);
  IIONumber::~IIONumber((IIONumber *)v36);
  IIODictionary::setObjectForKey(a2, v41, "dataWindow");
  v33 = 0;
  v34 = 0;
  v35 = 0;
  IIOArray::IIOArray((IIOArray *)&v33);
  IIONumber::IIONumber((IIONumber *)v32, v10);
  IIOArray::addObject(&v33, (uint64_t)v32);
  IIONumber::~IIONumber((IIONumber *)v32);
  IIONumber::IIONumber((IIONumber *)v31, v11);
  IIOArray::addObject(&v33, (uint64_t)v31);
  IIONumber::~IIONumber((IIONumber *)v31);
  IIONumber::IIONumber((IIONumber *)v30, v9);
  IIOArray::addObject(&v33, (uint64_t)v30);
  IIONumber::~IIONumber((IIONumber *)v30);
  IIONumber::IIONumber((IIONumber *)v29, v21);
  IIOArray::addObject(&v33, (uint64_t)v29);
  IIONumber::~IIONumber((IIONumber *)v29);
  IIODictionary::setObjectForKey(a2, v34, "displayWindow");
  name = (const char *)gFunc_axr_compression_get_name(v20);
  IIOString::IIOString((IIOString *)&v26, name);
  IIODictionary::setObjectForKey(a2, v28, "compression");
  IIOString::~IIOString((IIOString *)&v26);
  if (v17 && *v17)
  {
    IIOString::IIOString((IIOString *)&v26, v17);
    IIODictionary::setObjectForKey(a2, v28, "name");
    IIOString::~IIOString((IIOString *)&v26);
  }
  if (v16 && *v16)
  {
    IIOString::IIOString((IIOString *)&v26, v16);
    IIODictionary::setObjectForKey(a2, v28, "view");
    IIOString::~IIOString((IIOString *)&v26);
  }
  IIONumber::IIONumber((IIONumber *)v25, v13);
  IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v25, "AspectRatio");
  IIONumber::~IIONumber((IIONumber *)v25);
  IIONumber::IIONumber((IIONumber *)v24, v15);
  IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v24, "screenWindowWidth");
  IIONumber::~IIONumber((IIONumber *)v24);
  v26 = 0;
  v27 = 0;
  v28 = 0;
  IIOArray::IIOArray((IIOArray *)&v26);
  IIONumber::IIONumber((IIONumber *)v23, v12);
  IIOArray::addObject(&v26, (uint64_t)v23);
  IIONumber::~IIONumber((IIONumber *)v23);
  IIONumber::IIONumber((IIONumber *)v22, v14);
  IIOArray::addObject(&v26, (uint64_t)v22);
  IIONumber::~IIONumber((IIONumber *)v22);
  IIODictionary::setObjectForKey(a2, v27, "screenWindowCenter");
  IIOArray::~IIOArray((IIOArray *)&v26);
  IIOArray::~IIOArray((IIOArray *)&v33);
  IIOArray::~IIOArray((IIOArray *)&v40);
  return 0;
}

void sub_188039454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  uint64_t v38;

  IIOString::~IIOString((IIOString *)&a23);
  IIOArray::~IIOArray((IIOArray *)&a38);
  IIOArray::~IIOArray((IIOArray *)(v38 - 256));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_OpenEXR::updatePropertyInfo(IIO_Reader_OpenEXR *this, IIODictionary *a2, axr_data *a3, EXRPluginData *a4)
{
  uint64_t v5;
  uint64_t property_count;
  uint64_t i;
  const char *v8;
  int v9;
  const char *v11[2];
  uint64_t v12;

  v5 = *((unsigned int *)a4 + 31);
  property_count = gFunc_axr_data_get_property_count(a3, v5);
  if (property_count)
  {
    for (i = 0; i != property_count; ++i)
    {
      gFunc_axr_data_get_property(v11, a3, v5, i, 1);
      v8 = v11[1];
      v9 = v12;
      _cg_jpeg_mem_term("updatePropertyInfo", 247, "\n[%2d,%2d]:  name: %s\n", v5, i, v11[0]);
      _cg_jpeg_mem_term("updatePropertyInfo", 248, "          type: %s\n", v8);
      _cg_jpeg_mem_term("updatePropertyInfo", 249, "          size: %d\n", v9);
    }
  }
  return 0;
}

uint64_t IIO_Reader_OpenEXR::updateChannelInfo(IIO_Reader_OpenEXR *this, IIODictionary *a2, axr_data *a3, EXRPluginData *a4)
{
  uint64_t v6;
  uint64_t channel_count;
  uint64_t i;
  uint64_t v9;
  int v10;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  const char *p_p;
  const char *v21;
  _BYTE v23[16];
  void *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  CFMutableArrayRef v28;
  void *v29;
  uint64_t v30;
  void *__p;
  _OWORD v32[17];
  _DWORD __dst[67];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v6 = *((unsigned int *)a4 + 31);
  v28 = 0;
  v29 = 0;
  v30 = 0;
  IIOArray::IIOArray((IIOArray *)&v28);
  channel_count = gFunc_axr_data_get_channel_count(a3, v6);
  if (channel_count)
  {
    for (i = 0; i != channel_count; ++i)
    {
      gFunc_axr_data_get_channel_info(&__p, a3, v6, i, 1);
      v9 = (int)__p;
      v10 = v32[0];
      memcpy(__dst, (char *)v32 + 4, sizeof(__dst));
      v11 = operator new(0x108uLL);
      __p = v11;
      v32[0] = xmmword_18822C9F0;
      v12 = *(_OWORD *)&__dst[55];
      v11[12] = *(_OWORD *)&__dst[51];
      v11[13] = v12;
      v13 = *(_OWORD *)&__dst[63];
      v11[14] = *(_OWORD *)&__dst[59];
      v11[15] = v13;
      v14 = *(_OWORD *)&__dst[39];
      v11[8] = *(_OWORD *)&__dst[35];
      v11[9] = v14;
      v15 = *(_OWORD *)&__dst[47];
      v11[10] = *(_OWORD *)&__dst[43];
      v11[11] = v15;
      v16 = *(_OWORD *)&__dst[23];
      v11[4] = *(_OWORD *)&__dst[19];
      v11[5] = v16;
      v17 = *(_OWORD *)&__dst[31];
      v11[6] = *(_OWORD *)&__dst[27];
      v11[7] = v17;
      v18 = *(_OWORD *)&__dst[7];
      *v11 = *(_OWORD *)&__dst[3];
      v11[1] = v18;
      v19 = *(_OWORD *)&__dst[15];
      v11[2] = *(_OWORD *)&__dst[11];
      v11[3] = v19;
      *((_BYTE *)v11 + 256) = 0;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v25);
      if (v32[0] >= 0)
        p_p = (const char *)&__p;
      else
        p_p = (const char *)__p;
      IIOString::IIOString((IIOString *)v23, p_p);
      IIODictionary::setObjectForKey((IIODictionary *)&v25, v24, "name");
      IIOString::~IIOString((IIOString *)v23);
      if (v9 < 3)
        IIODictionary::setObjectForKey((IIODictionary *)&v25, off_1E1BC9F90[v9], CFSTR("channels"));
      IIONumber::IIONumber((IIONumber *)v23, v10);
      IIODictionary::setObjectForKey((IIODictionary *)&v25, v24, "bits");
      IIONumber::~IIONumber((IIONumber *)v23);
      if (v32[0] >= 0)
        v21 = (const char *)&__p;
      else
        v21 = (const char *)__p;
      IIOString::IIOString((IIOString *)v23, v21);
      IIODictionary::setObjectForKey((IIODictionary *)&v25, v24, "name");
      IIOString::~IIOString((IIOString *)v23);
      IIOArray::addObject(&v28, v26);
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
      if (SHIBYTE(v32[0]) < 0)
        operator delete(__p);
    }
  }
  IIODictionary::setObjectForKey(a2, v29, "channels");
  IIOArray::~IIOArray((IIOArray *)&v28);
  return 0;
}

void sub_1880398D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  _Unwind_Resume(exception_object);
}

uint64_t IIO_Reader_OpenEXR::updateSourceProperties(IIO_Reader_OpenEXR *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  IIOImageRead *v9;
  IIOImageRead *Size;
  void *v11;
  const char *name;
  uint64_t logical_image_list;
  uint64_t updated;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  __int128 v19;
  const std::string::value_type **v20;
  __int128 v21;
  const std::string::value_type **v22;
  __int128 v23;
  const std::string::value_type **v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  IIODictionary *v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  _BYTE v36[32];
  void *v37[2];
  void *v38[4];
  void *__p[2];
  _OWORD v40[5];
  CFMutableArrayRef v41;
  const void *v42;
  uint64_t v43;
  _BYTE v44[24];
  uint64_t v45;
  const void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;

  if (!AppleEXREnabled())
    return 0;
  v52 = 0;
  v9 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v52, 1);
  Size = IIOImageReadSession::getSize(a2);
  v51 = 0;
  v11 = (void *)gFunc_axr_data_create(v9, Size, &v51, 0, 0);
  if (v51)
  {
    name = (const char *)gFunc_axr_error_get_name();
    LogError("updateSourceProperties", 313, "*** axr_data_create failed: %s (%d)\n", name, v51);
  }
  if (v11)
  {
    logical_image_list = gFunc_axr_data_create_logical_image_list(v11);
    if (logical_image_list)
    {
      v48 = 0;
      v49 = 0;
      v50 = 0;
      updated = IIO_Reader_OpenEXR::UpdateImageInfo(logical_image_list, &v48);
      if (!(_DWORD)updated)
      {
        v45 = 0;
        v46 = 0;
        v47 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v45);
        IIONumber::IIONumber((IIONumber *)v44, 1022611261 * ((unint64_t)(v49 - v48) >> 3));
        IIODictionary::setObjectForKey((uint64_t)&v45, (uint64_t)v44, "ImageCount");
        v32 = a3;
        IIONumber::~IIONumber((IIONumber *)v44);
        v41 = 0;
        v42 = 0;
        v43 = 0;
        IIOArray::IIOArray((IIOArray *)&v41);
        v15 = v48;
        if (v49 != v48)
        {
          v16 = 0;
          v17 = 1;
          do
          {
            *(_OWORD *)__p = 0u;
            memset(v40, 0, 72);
            memset(v38, 0, sizeof(v38));
            *(_OWORD *)&v36[16] = 0u;
            *(_OWORD *)v37 = 0u;
            *(_OWORD *)v36 = 0u;
            v18 = v15 + 168 * v16;
            v19 = *(_OWORD *)v18;
            *(_OWORD *)&v36[9] = *(_OWORD *)(v18 + 9);
            *(_OWORD *)v36 = v19;
            v20 = (const std::string::value_type **)(v18 + 32);
            if (*(char *)(v18 + 55) < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)v37, *v20, *(_QWORD *)(v15 + 168 * v16 + 40));
            }
            else
            {
              v21 = *(_OWORD *)v20;
              v38[0] = *(void **)(v18 + 48);
              *(_OWORD *)v37 = v21;
            }
            v22 = (const std::string::value_type **)(v15 + 168 * v16 + 56);
            if (*(char *)(v18 + 79) < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)&v38[1], *v22, *(_QWORD *)(v15 + 168 * v16 + 64));
            }
            else
            {
              v23 = *(_OWORD *)v22;
              v38[3] = *(void **)(v15 + 168 * v16 + 72);
              *(_OWORD *)&v38[1] = v23;
            }
            v24 = (const std::string::value_type **)(v15 + 168 * v16 + 80);
            if (*(char *)(v18 + 103) < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)__p, *v24, *(_QWORD *)(v15 + 168 * v16 + 88));
            }
            else
            {
              v25 = *(_OWORD *)v24;
              *(_QWORD *)&v40[0] = *(_QWORD *)(v15 + 168 * v16 + 96);
              *(_OWORD *)__p = v25;
            }
            v26 = v15 + 168 * v16;
            v27 = *(_OWORD *)(v26 + 104);
            v28 = *(_OWORD *)(v26 + 120);
            v29 = *(_OWORD *)(v26 + 152);
            *(_OWORD *)((char *)&v40[2] + 8) = *(_OWORD *)(v26 + 136);
            *(_OWORD *)((char *)&v40[3] + 8) = v29;
            *(_OWORD *)((char *)v40 + 8) = v27;
            *(_OWORD *)((char *)&v40[1] + 8) = v28;
            v33 = 0;
            v34 = 0;
            v35 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v33);
            (*(void (**)(IIO_Reader_OpenEXR *, uint64_t *, void *, _BYTE *))(*(_QWORD *)this + 272))(this, &v33, v11, v36);
            (*(void (**)(IIO_Reader_OpenEXR *, uint64_t *, void *, _BYTE *))(*(_QWORD *)this + 280))(this, &v33, v11, v36);
            (*(void (**)(IIO_Reader_OpenEXR *, uint64_t *, void *, _BYTE *))(*(_QWORD *)this + 288))(this, &v33, v11, v36);
            IIOArray::addObject(&v41, v34);
            IIODictionary::~IIODictionary((IIODictionary *)&v33);
            if (SBYTE7(v40[0]) < 0)
              operator delete(__p[0]);
            if (SHIBYTE(v38[3]) < 0)
              operator delete(v38[1]);
            if (SHIBYTE(v38[0]) < 0)
              operator delete(v37[0]);
            v16 = v17;
            v15 = v48;
          }
          while (0xCF3CF3CF3CF3CF3DLL * ((v49 - v48) >> 3) > v17++);
        }
        IIODictionary::setObjectForKey((IIODictionary *)&v45, v42, "Images");
        IIODictionary::setObjectForKey(v32, v46, "{FileContents}");
        IIOArray::~IIOArray((IIOArray *)&v41);
        IIODictionary::~IIODictionary((IIODictionary *)&v45);
        updated = 0;
      }
      *(_QWORD *)v36 = &v48;
      std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100]((void ***)v36);
    }
    else
    {
      updated = 0;
    }
    os_release(v11);
  }
  else
  {
    updated = 0;
  }
  IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v52);
  return updated;
}

void sub_188039D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  uint64_t v34;

  IIODictionary::~IIODictionary((IIODictionary *)(v34 - 160));
  a19 = v34 - 136;
  std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_OpenEXR::compareOptions(IIO_Reader_OpenEXR *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  _BOOL4 BoolForKey;
  uint64_t v5;
  _QWORD v7[3];
  _QWORD v8[3];

  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a3);
  BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v8, CFSTR("kCGImageSourceShouldAllowFloat"));
  v5 = BoolForKey ^ IIODictionary::getBoolForKey((IIODictionary *)v7, CFSTR("kCGImageSourceShouldAllowFloat")) ^ 1u;
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return v5;
}

void sub_188039E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_OpenEXR::hasCustomImageCountProc(IIO_Reader_OpenEXR *this)
{
  return 1;
}

uint64_t IIO_Reader_OpenEXR::hasCustomCompareOptionsProc(IIO_Reader_OpenEXR *this)
{
  return 1;
}

uint64_t IIO_Reader_OpenEXR::hasCustomSourcePropertiesProc(IIO_Reader_OpenEXR *this)
{
  return 1;
}

uint64_t std::vector<EXRPluginData>::__push_back_slow_path<EXRPluginData const&>(uint64_t *a1, __int128 *a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0xCF3CF3CF3CF3CF3DLL * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if (v3 + 1 > 0x186186186186186)
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  if (0x9E79E79E79E79E7ALL * ((a1[2] - *a1) >> 3) > v4)
    v4 = 0x9E79E79E79E79E7ALL * ((a1[2] - *a1) >> 3);
  if (0xCF3CF3CF3CF3CF3DLL * ((a1[2] - *a1) >> 3) >= 0xC30C30C30C30C3)
    v6 = 0x186186186186186;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<EXRPluginData>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[168 * v3];
  v13 = &v7[168 * v6];
  std::allocator<EXRPluginData>::construct[abi:ne180100]<EXRPluginData,EXRPluginData const&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 168;
  std::vector<EXRPluginData>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<EXRPluginData>::~__split_buffer(&v10);
  return v8;
}

void sub_188039FC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<EXRPluginData>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

__n128 std::allocator<EXRPluginData>::construct[abi:ne180100]<EXRPluginData,EXRPluginData const&>(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5;
  std::string *v6;
  __int128 v7;
  __int128 v8;
  std::string *v9;
  __int128 v10;
  __n128 result;
  __int128 v12;
  __int128 v13;

  v5 = *a3;
  *(_OWORD *)(a2 + 9) = *(__int128 *)((char *)a3 + 9);
  *(_OWORD *)a2 = v5;
  v6 = (std::string *)(a2 + 32);
  if (*((char *)a3 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *((const std::string::value_type **)a3 + 4), *((_QWORD *)a3 + 5));
  }
  else
  {
    v7 = a3[2];
    *(_QWORD *)(a2 + 48) = *((_QWORD *)a3 + 6);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  if (*((char *)a3 + 79) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a2 + 56), *((const std::string::value_type **)a3 + 7), *((_QWORD *)a3 + 8));
  }
  else
  {
    v8 = *(__int128 *)((char *)a3 + 56);
    *(_QWORD *)(a2 + 72) = *((_QWORD *)a3 + 9);
    *(_OWORD *)(a2 + 56) = v8;
  }
  v9 = (std::string *)(a2 + 80);
  if (*((char *)a3 + 103) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *((const std::string::value_type **)a3 + 10), *((_QWORD *)a3 + 11));
  }
  else
  {
    v10 = a3[5];
    *(_QWORD *)(a2 + 96) = *((_QWORD *)a3 + 12);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
  result = *(__n128 *)((char *)a3 + 104);
  v12 = *(__int128 *)((char *)a3 + 120);
  v13 = *(__int128 *)((char *)a3 + 136);
  *(_OWORD *)(a2 + 152) = *(__int128 *)((char *)a3 + 152);
  *(_OWORD *)(a2 + 136) = v13;
  *(_OWORD *)(a2 + 120) = v12;
  *(__n128 *)(a2 + 104) = result;
  return result;
}

void sub_18803A0BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;

  if (*(char *)(v1 + 79) < 0)
    operator delete(*v3);
  if (*(char *)(v1 + 55) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<EXRPluginData>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>,std::reverse_iterator<EXRPluginData*>,std::reverse_iterator<EXRPluginData*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<EXRPluginData>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x186186186186187)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(168 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>,std::reverse_iterator<EXRPluginData*>,std::reverse_iterator<EXRPluginData*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _QWORD v18[3];
  uint64_t v19;
  __int128 v20;
  __int128 v21;

  v7 = a7;
  *(_QWORD *)&v21 = a6;
  *((_QWORD *)&v21 + 1) = a7;
  v20 = v21;
  v18[0] = a1;
  v18[1] = &v20;
  v18[2] = &v21;
  v19 = 0;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 168);
      *(_OWORD *)(v9 - 159) = *(_OWORD *)(a3 - 159);
      *(_OWORD *)(v9 - 168) = v10;
      v11 = *(_OWORD *)(a3 - 136);
      *(_QWORD *)(v9 - 120) = *(_QWORD *)(a3 - 120);
      *(_OWORD *)(v9 - 136) = v11;
      *(_QWORD *)(a3 - 128) = 0;
      *(_QWORD *)(a3 - 120) = 0;
      *(_QWORD *)(a3 - 136) = 0;
      v12 = *(_OWORD *)(a3 - 112);
      *(_QWORD *)(v9 - 96) = *(_QWORD *)(a3 - 96);
      *(_OWORD *)(v9 - 112) = v12;
      *(_QWORD *)(a3 - 104) = 0;
      *(_QWORD *)(a3 - 96) = 0;
      *(_QWORD *)(a3 - 112) = 0;
      v13 = *(_OWORD *)(a3 - 88);
      *(_QWORD *)(v9 - 72) = *(_QWORD *)(a3 - 72);
      *(_OWORD *)(v9 - 88) = v13;
      *(_QWORD *)(a3 - 88) = 0;
      *(_QWORD *)(a3 - 80) = 0;
      *(_QWORD *)(a3 - 72) = 0;
      v14 = *(_OWORD *)(a3 - 64);
      v15 = *(_OWORD *)(a3 - 48);
      v16 = *(_OWORD *)(a3 - 16);
      *(_OWORD *)(v9 - 32) = *(_OWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 16) = v16;
      *(_OWORD *)(v9 - 64) = v14;
      *(_OWORD *)(v9 - 48) = v15;
      v9 -= 168;
      v7 -= 168;
      a3 -= 168;
    }
    while (a3 != a5);
    *((_QWORD *)&v21 + 1) = v9;
  }
  LOBYTE(v19) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v18);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<EXRPluginData>::destroy[abi:ne180100](v3, v1);
      v1 += 168;
    }
    while (v1 != v2);
  }
}

void std::allocator<EXRPluginData>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 103) < 0)
    operator delete(*(void **)(a2 + 80));
  if (*(char *)(a2 + 79) < 0)
    operator delete(*(void **)(a2 + 56));
  if (*(char *)(a2 + 55) < 0)
    operator delete(*(void **)(a2 + 32));
}

void **std::__split_buffer<EXRPluginData>::~__split_buffer(void **a1)
{
  std::__split_buffer<EXRPluginData>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<EXRPluginData>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 168;
    std::allocator<EXRPluginData>::destroy[abi:ne180100](v4, i - 168);
  }
}

void std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 168;
        std::allocator<EXRPluginData>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void IIO_Writer_PDF::~IIO_Writer_PDF(IIO_Writer_PDF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t IIO_Writer_PDF::write(IIO_Writer_PDF *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v3;
  _OWORD v5[4];

  memset(v5, 0, sizeof(v5));
  PDFWritePlugin::PDFWritePlugin((PDFWritePlugin *)v5, a2, a3);
  PDFWritePlugin::setup((PDFWritePlugin *)v5);
  v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v5);
  PDFWritePlugin::done((CGContextRef *)v5);
  PDFWritePlugin::~PDFWritePlugin((PDFWritePlugin *)v5);
  return v3;
}

void sub_18803A4F4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18803A4E0);
}

uint64_t png_do_invert(uint64_t result, _BYTE *a2)
{
  uint64_t k;
  int v3;
  unint64_t v4;
  unint64_t j;
  unint64_t v6;
  unint64_t i;
  _BYTE *v8;

  if (*(_BYTE *)(result + 16) == 4)
  {
    v3 = *(unsigned __int8 *)(result + 17);
    if (v3 == 16)
    {
      v6 = *(_QWORD *)(result + 8);
      if (v6)
      {
        for (i = 0; i < v6; i += 4)
        {
          v8 = &a2[i];
          *v8 = ~a2[i];
          v8[1] = ~a2[i + 1];
        }
      }
    }
    else if (v3 == 8)
    {
      v4 = *(_QWORD *)(result + 8);
      if (v4)
      {
        for (j = 0; j < v4; j += 2)
          a2[j] = ~a2[j];
      }
    }
  }
  else if (!*(_BYTE *)(result + 16))
  {
    for (k = *(_QWORD *)(result + 8); k; --k)
    {
      *a2 = ~*a2;
      ++a2;
    }
  }
  return result;
}

uint64_t png_do_packswap(uint64_t result, _BYTE *a2)
{
  unsigned int v2;
  uint64_t v3;
  _BYTE *v4;
  _BYTE *v5;

  v2 = *(unsigned __int8 *)(result + 17);
  if (v2 <= 7)
  {
    v3 = *(_QWORD *)(result + 8);
    switch(v2)
    {
      case 1u:
        v4 = &onebppswaptable;
        break;
      case 4u:
        v4 = &fourbppswaptable;
        break;
      case 2u:
        v4 = &twobppswaptable;
        break;
      default:
        return result;
    }
    if (v3 >= 1)
    {
      v5 = &a2[v3];
      do
      {
        *a2 = v4[*a2];
        ++a2;
      }
      while (a2 < v5);
    }
  }
  return result;
}

int *png_do_bgr(int *result, __int16 *a2)
{
  int v2;
  int v3;
  int v4;
  char v5;
  __int16 v7;
  char v8;
  __int16 v9;

  v2 = *((unsigned __int8 *)result + 16);
  if ((v2 & 2) != 0)
  {
    v3 = *result;
    v4 = *((unsigned __int8 *)result + 17);
    if (v4 == 16)
    {
      if (v2 == 2)
      {
        for (; v3; --v3)
        {
          v9 = *a2;
          *a2 = a2[2];
          a2[2] = v9;
          a2 += 3;
        }
      }
      else if (v2 == 6 && v3 != 0)
      {
        do
        {
          v7 = *a2;
          *a2 = a2[2];
          a2[2] = v7;
          a2 += 4;
          --v3;
        }
        while (v3);
      }
    }
    else if (v4 == 8)
    {
      if (v2 == 2)
      {
        for (; v3; --v3)
        {
          v8 = *(_BYTE *)a2;
          *(_BYTE *)a2 = *((_BYTE *)a2 + 2);
          *((_BYTE *)a2 + 2) = v8;
          a2 = (__int16 *)((char *)a2 + 3);
        }
      }
      else if (v2 == 6 && v3)
      {
        do
        {
          v5 = *(_BYTE *)a2;
          *(_BYTE *)a2 = *((_BYTE *)a2 + 2);
          *((_BYTE *)a2 + 2) = v5;
          a2 += 2;
          --v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t _cg_png_get_current_row_number(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 308);
  else
    return 0xFFFFFFFFLL;
}

uint64_t mj2_video_source::get_track_idx(mj2_video_source *this)
{
  return *(unsigned int *)(**((_QWORD **)this + 1) + 16);
}

uint64_t mj2_video_source::get_graphics_mode(mj2_video_source *this)
{
  return *(__int16 *)(*(_QWORD *)(**((_QWORD **)this + 1) + 40) + 8);
}

uint64_t mj2_video_source::access_dimensions(mj2_video_source *this)
{
  return jp2_header::access_dimensions((jp2_header *)(*((_QWORD *)this + 1) + 40));
}

uint64_t mj2_video_source::access_colour(mj2_video_source *this)
{
  return jp2_header::access_colour((jp2_header *)(*((_QWORD *)this + 1) + 40));
}

uint64_t mj2_video_source::access_palette(mj2_video_source *this)
{
  return jp2_header::access_palette((jp2_header *)(*((_QWORD *)this + 1) + 40));
}

uint64_t mj2_video_source::access_channels(mj2_video_source *this)
{
  return jp2_header::access_channels((jp2_header *)(*((_QWORD *)this + 1) + 40));
}

uint64_t mj2_video_source::get_stream_idx(mj2_video_source *this, int a2)
{
  _DWORD *v2;
  int v3;
  uint64_t result;
  unsigned int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  v2 = (_DWORD *)*((_QWORD *)this + 1);
  v3 = v2[170];
  if (v3 < 0)
  {
    v8 = *(_QWORD *)(*(_QWORD *)v2 + 8);
    if (!v8)
      return 0xFFFFFFFFLL;
    v9 = *(_QWORD *)(v8 + 104);
    if (!v9)
      return 0xFFFFFFFFLL;
    v10 = 0;
    do
    {
      v11 = *(_QWORD *)(v9 + 40);
      if (v11 && (*(_DWORD *)(v11 + 680) & 0x80000000) != 0)
      {
        *(_DWORD *)(v11 + 680) = v10;
        v10 += *(_DWORD *)(v11 + 676);
      }
      v9 = *(_QWORD *)(v9 + 24);
    }
    while (v9);
    v3 = v2[170];
    if (v3 < 0)
      return 0xFFFFFFFFLL;
  }
  result = 0xFFFFFFFFLL;
  if ((a2 & 0x80000000) == 0)
  {
    v5 = v2[22];
    if (v5 < v2[16])
    {
      v6 = v2[17];
      if (v6 > a2)
      {
        v7 = a2 + v6 * v5;
        if (v7 >= v2[169])
          mj2_video_source::get_stream_idx();
        return (v7 + v3);
      }
    }
  }
  return result;
}

uint64_t mj2_source::count_codestreams(mj2_source *this, int *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;

  *a2 = 0;
  if (*(_QWORD *)this)
  {
    v2 = *(_QWORD *)(*(_QWORD *)this + 104);
    if (v2)
    {
      v3 = 0;
      do
      {
        v4 = *(_QWORD *)(v2 + 40);
        if (v4 && (*(_DWORD *)(v4 + 680) & 0x80000000) != 0)
        {
          *(_DWORD *)(v4 + 680) = v3;
          v3 = *a2 + *(_DWORD *)(v4 + 676);
          *a2 = v3;
        }
        v2 = *(_QWORD *)(v2 + 24);
      }
      while (v2);
    }
  }
  return 1;
}

BOOL mj2_video_source::can_open_stream(mj2_video_source *this, int a2)
{
  _BOOL8 result;
  _DWORD *v4;

  result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    v4 = (_DWORD *)*((_QWORD *)this + 1);
    if (v4[22] < v4[16])
      return v4[17] > a2;
  }
  return result;
}

uint64_t mj2_source::get_track_type(mj2_source *this, int a2)
{
  uint64_t v2;

  if (!*(_QWORD *)this)
    mj2_source::get_track_type();
  v2 = *(_QWORD *)(*(_QWORD *)this + 104);
  if (!v2)
    return 0;
  while (*(_DWORD *)(v2 + 16) != a2)
  {
    v2 = *(_QWORD *)(v2 + 24);
    if (!v2)
      return 0;
  }
  if (*(_QWORD *)(v2 + 40))
    return 1;
  else
    return 1000;
}

uint64_t mj2_source::access_video_track(mj2_source *this, int a2)
{
  uint64_t v2;
  uint64_t v3;

  if (!*(_QWORD *)this)
    mj2_source::access_video_track();
  v2 = *(_QWORD *)(*(_QWORD *)this + 104);
  if (!v2)
    return 0;
  while (*(_DWORD *)(v2 + 16) != a2)
  {
    v2 = *(_QWORD *)(v2 + 24);
    if (!v2)
      return 0;
  }
  v3 = *(_QWORD *)(v2 + 40);
  if (v3)
    return *(_QWORD *)(v3 + 56);
  else
    return 0;
}

uint64_t mj2_source::find_stream(mj2_source *this, int a2, unsigned int *a3, int *a4, int *a5)
{
  uint64_t v10;
  _DWORD *v11;
  int v12;
  int v13;
  uint64_t result;
  int v15;
  BOOL v16;
  int v17;
  int v18;
  int v19;

  if (*(_QWORD *)this)
  {
    v19 = 0;
    mj2_source::count_codestreams(this, &v19);
    v10 = *(_QWORD *)(*(_QWORD *)this + 104);
    if (!v10)
    {
LABEL_8:
      *a3 = 0;
      *a5 = 0;
      result = 1;
      *a4 = 0;
      return result;
    }
    while (1)
    {
      v11 = *(_DWORD **)(v10 + 40);
      if (v11)
      {
        v12 = v11[170];
        if (v12 < 0)
          return 0;
        v13 = a2 - v12;
        if (v13 >= 0 && v13 < v11[169])
          break;
      }
      v10 = *(_QWORD *)(v10 + 24);
      if (!v10)
        goto LABEL_8;
    }
    *a3 = *(_DWORD *)(v10 + 16);
    v15 = v11[168];
    v16 = v15 == 0;
    v17 = v13 & 1;
    v18 = v13 >> (v15 != 0);
    if (v16)
      v17 = 0;
    *a4 = v18;
    *a5 = v17;
  }
  return 1;
}

uint64_t IIO_Reader_ATX::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  ATXReadPlugin::ATXReadPlugin(v4, a2, v5);
  return v4;
}

void sub_18803AA64(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4001FED7D0);
  _Unwind_Resume(a1);
}

CGMutableImageMetadataRef CGImageMetadataCreateFromXPCObj(void *a1)
{
  CGMutableImageMetadataRef Mutable;
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  BOOL v12;
  const __CFData *v13;
  const __CFData *v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  _QWORD v17[3];
  _QWORD v18[3];
  uint64_t v19;
  CFTypeRef cf;
  void (*v21)(uint64_t, const __CFDictionary *);
  void *v22;
  CGMutableImageMetadataRef v23;

  if (!a1)
    return 0;
  v3 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(a1, (const char *)IIO_METADATA_OBJ);
  if (v3)
  {
    v4 = v3;
    memset(v18, 0, sizeof(v18));
    IIODictionary::IIODictionary((IIODictionary *)v18, v3);
    Mutable = CGImageMetadataCreateMutable();
    memset(v17, 0, sizeof(v17));
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v18, CFSTR("tags"));
    IIOArray::IIOArray((IIOArray *)v17, ObjectForKey);
    v19 = MEMORY[0x1E0C809B0];
    cf = (CFTypeRef)0x40000000;
    v21 = ___ZL24IIOXPCDecodeMetadataTagsP8IIOArrayP15CGImageMetadata_block_invoke;
    v22 = &__block_descriptor_tmp_242;
    v23 = Mutable;
    IIOArray::enumerate((uint64_t)v17, (uint64_t)&v19);
    if (IIODictionary::containsKey((IIODictionary *)v18, CFSTR("makerNoteProps")))
    {
      v6 = IIODictionary::getObjectForKey((IIODictionary *)v18, CFSTR("makerNoteProps"));
      *((_QWORD *)Mutable + 6) = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v6);
    }
    if (IIODictionary::containsKey((IIODictionary *)v18, CFSTR("NStoPrefix")))
    {
      v7 = IIODictionary::getObjectForKey((IIODictionary *)v18, CFSTR("NStoPrefix"));
      *((_QWORD *)Mutable + 4) = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v7);
    }
    if (IIODictionary::containsKey((IIODictionary *)v18, CFSTR("prefixToNS")))
    {
      v8 = IIODictionary::getObjectForKey((IIODictionary *)v18, CFSTR("prefixToNS"));
      *((_QWORD *)Mutable + 5) = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v8);
    }
    if (IIODictionary::containsKey((IIODictionary *)v18, CFSTR("iptcComputedDigest")))
    {
      v9 = IIODictionary::getObjectForKey((IIODictionary *)v18, CFSTR("iptcComputedDigest"));
      *((_QWORD *)Mutable + 7) = CFRetain(v9);
    }
    if (IIODictionary::containsKey((IIODictionary *)v18, CFSTR("iptcPSIRDigest")))
    {
      v10 = IIODictionary::getObjectForKey((IIODictionary *)v18, CFSTR("iptcPSIRDigest"));
      *((_QWORD *)Mutable + 8) = CFRetain(v10);
    }
    *((_BYTE *)Mutable + 16) = IIODictionary::getBoolForKey((IIODictionary *)v18, CFSTR("mutable"));
    CFRelease(v4);
    IIOArray::~IIOArray((IIOArray *)v17);
    IIODictionary::~IIODictionary((IIODictionary *)v18);
  }
  else
  {
    _cg_jpeg_mem_term("CGImageMetadataCreateFromXPCObj", 279, "*** NOTE: failed to get metadata-dictionary from xpc_object_t - decoding XMPData...\n");
    v12 = xpc_dictionary_get_BOOL(a1, (const char *)IIO_METADATA_MUTABLE);
    if (!xpc_dictionary_get_value(a1, (const char *)IIO_METADATA_OBJ_ORIG))
      return 0;
    v13 = (const __CFData *)_CFXPCCreateCFObjectFromXPCObject();
    if (!v13)
      return 0;
    v14 = v13;
    Mutable = CGImageMetadataCreateFromXMPData(v13);
    if (Mutable)
    {
      v15 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(a1, (const char *)IIO_METADATA_MAKER_ORIG);
      if (v15)
      {
        v16 = v15;
        v19 = 0;
        cf = 0;
        v21 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v19, v15, 1);
        *((_QWORD *)Mutable + 6) = CFRetain(cf);
        CFRelease(v16);
        IIODictionary::~IIODictionary((IIODictionary *)&v19);
      }
      *((_BYTE *)Mutable + 16) = v12;
    }
    CFRelease(v14);
  }
  return Mutable;
}

void sub_18803AD4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

xpc_object_t CGImageMetadataCreateXPCObj(uint64_t a1)
{
  CFTypeID v2;
  xpc_object_t empty;
  const void **v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const __CFData *XMPData;
  uint64_t v12;
  void *value;
  uint64_t v14;
  _QWORD v15[3];
  _QWORD block[5];

  if (!a1)
    return 0;
  v2 = CFGetTypeID((CFTypeRef)a1);
  if (v2 != CGImageMetadataGetTypeID())
    return 0;
  empty = xpc_dictionary_create_empty();
  if (empty)
  {
    memset(v15, 0, sizeof(v15));
    IIODictionary::IIODictionary((IIODictionary *)v15);
    v4 = (const void **)MEMORY[0x1E0C9AE50];
    if (!*(_BYTE *)(a1 + 16))
      v4 = (const void **)MEMORY[0x1E0C9AE40];
    IIODictionary::setObjectForKey((IIODictionary *)v15, *v4, CFSTR("mutable"));
    v12 = 0;
    value = 0;
    v14 = 0;
    IIOArray::IIOArray((IIOArray *)&v12);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZL24IIOXPCEncodeMetadataTagsPK15CGImageMetadataP8IIOArray_block_invoke;
    block[3] = &__block_descriptor_tmp_264;
    block[4] = &v12;
    CGImageMetadataEnumerateTagsUsingBlock((CGImageMetadataRef)a1, 0, 0, block);
    IIODictionary::setObjectForKey((IIODictionary *)v15, value, CFSTR("tags"));
    v5 = *(const void **)(a1 + 32);
    if (v5)
      IIODictionary::setObjectForKey((IIODictionary *)v15, v5, CFSTR("NStoPrefix"));
    v6 = *(const void **)(a1 + 40);
    if (v6)
      IIODictionary::setObjectForKey((IIODictionary *)v15, v6, CFSTR("prefixToNS"));
    v7 = *(const void **)(a1 + 48);
    if (v7)
      IIODictionary::setObjectForKey((IIODictionary *)v15, v7, CFSTR("makerNoteProps"));
    v8 = *(const void **)(a1 + 56);
    if (v8)
      IIODictionary::setObjectForKey((IIODictionary *)v15, v8, CFSTR("iptcComputedDigest"));
    v9 = *(const void **)(a1 + 64);
    if (v9)
      IIODictionary::setObjectForKey((IIODictionary *)v15, v9, CFSTR("iptcPSIRDigest"));
    if (iio_xpc_dictionary_add_CFDictionary(empty, (const char *)IIO_METADATA_OBJ))
    {
      _cg_jpeg_mem_term("CGImageMetadataCreateXPCObj", 346, "*** NOTE: failed to add metadata-dictionary to xpc_object_t - sending XMPData...\n");
      xpc_dictionary_set_BOOL(empty, (const char *)IIO_METADATA_MUTABLE, *(_BYTE *)(a1 + 16));
      XMPData = CGImageMetadataCreateXMPData((CGImageMetadataRef)a1, 0);
      if (XMPData)
      {
        iio_xpc_dictionary_add_CFData(empty, (const char *)IIO_METADATA_OBJ_ORIG, XMPData);
        CFRelease(XMPData);
      }
      if (*(_QWORD *)(a1 + 48))
        iio_xpc_dictionary_add_CFDictionary(empty, (const char *)IIO_METADATA_MAKER_ORIG);
    }
    IIOArray::~IIOArray((IIOArray *)&v12);
    IIODictionary::~IIODictionary((IIODictionary *)v15);
  }
  return empty;
}

void sub_18803AF9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  IIOArray::~IIOArray((IIOArray *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

void CGImageMetadataRemoveTag(uint64_t a1, uint64_t a2)
{
  uint64_t Source;
  uint64_t v5;
  _QWORD key[3];

  Source = CGImageSourceGetSource(a2);
  if (a1)
  {
    if (a2)
    {
      key[2] = 0;
      v5 = *(_QWORD *)(Source + 32);
      key[0] = *(_QWORD *)(Source + 16);
      key[1] = v5;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), key);
    }
  }
}

__CFArray *CreateArrayFromCFValue(const __CFString *a1, int a2)
{
  CFTypeID v4;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFTypeID v10;
  CFStringRef SimpleStringFromCFValue;
  CFStringRef v12;
  CFTypeID v13;
  const __CFAllocator *v14;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v16;
  CFIndex v17;
  __CFArray *v18;

  if (!a1)
    return 0;
  v4 = CFGetTypeID(a1);
  if (v4 == CFArrayGetTypeID())
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      Count = CFArrayGetCount((CFArrayRef)a1);
      if (Count >= 1)
      {
        v7 = Count;
        for (i = 0; i != v7; ++i)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
          v10 = CFGetTypeID(ValueAtIndex);
          if (v10 == CFNumberGetTypeID()
            && (SimpleStringFromCFValue = CGImageMetadataCreateSimpleStringFromCFValue(ValueAtIndex, 4)) != 0)
          {
            v12 = SimpleStringFromCFValue;
            CFArrayAppendValue(Mutable, SimpleStringFromCFValue);
            CFRelease(v12);
          }
          else if (ValueAtIndex)
          {
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
        }
      }
    }
    return Mutable;
  }
  v13 = CFGetTypeID(a1);
  if (v13 != CFStringGetTypeID())
    return 0;
  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (a2 == 13)
  {
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, CFSTR("; "));
    if (ArrayBySeparatingStrings)
    {
      v16 = ArrayBySeparatingStrings;
      v17 = CFArrayGetCount(ArrayBySeparatingStrings);
      Mutable = CFArrayCreateMutableCopy(v14, v17, v16);
      CFRelease(v16);
      return Mutable;
    }
    LogMetadata("CreateArrayFromCFValue", 2900, "Could not create array from kLegacyTypeSemicolonString value\n");
    return 0;
  }
  v18 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  Mutable = v18;
  if (v18)
    CFArrayAppendValue(v18, a1);
  return Mutable;
}

__CFDictionary *CreateStructureFromCFValue(const void *a1)
{
  CFTypeID v2;
  CFIndex Count;
  CFIndex v4;
  __CFDictionary *Mutable;
  const void **v6;
  uint64_t i;
  const void *v8;
  const void *Value;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (v2 != CFDictionaryGetTypeID())
    return 0;
  Count = CFDictionaryGetCount((CFDictionaryRef)a1);
  if (Count < 1)
    return 0;
  v4 = Count;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v6 = (const void **)malloc_type_malloc(8 * v4, 0x6004044C4A2DFuLL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v6, 0);
    for (i = 0; i != v4; ++i)
    {
      v8 = v6[i];
      Value = CFDictionaryGetValue((CFDictionaryRef)a1, v8);
      CFDictionaryAddValue(Mutable, v8, Value);
    }
    free(v6);
  }
  return Mutable;
}

__CFString *CreateShortXMPDateFromIPTCDate(const __CFString *a1)
{
  CFTypeID v2;
  CFIndex Length;
  __CFString *v5;
  __CFString *Mutable;

  if (a1)
  {
    v2 = CFGetTypeID(a1);
    if (v2 == CFStringGetTypeID())
    {
      Length = CFStringGetLength(a1);
      if (Length == 8)
      {
        Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 10);
        v5 = Mutable;
        if (Mutable)
        {
          CFStringAppend(Mutable, a1);
          CFStringInsert(v5, 4, CFSTR("-"));
          CFStringInsert(v5, 7, CFSTR("-"));
        }
        return v5;
      }
      if (Length == 10)
        return (__CFString *)CFRetain(a1);
    }
  }
  return 0;
}

__CFString *CreateXMPDateFromIPTCDateAndTime(const __CFString *a1, const __CFString *a2)
{
  CFTypeID v4;
  CFIndex v5;
  __CFString *v6;
  _BOOL4 v7;
  CFTypeID v8;
  CFIndex v9;
  int v10;
  _BOOL4 v11;
  __CFString *Mutable;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;

  v24 = 0;
  v23 = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  if (a1 && (v4 = CFGetTypeID(a1), v4 == CFStringGetTypeID()))
  {
    v5 = CFStringGetLength(a1) + 1;
    v6 = (__CFString *)malloc_type_malloc(v5, 0xC7F6DA59uLL);
    if (!v6)
      return v6;
    if (!CFStringGetCString(a1, (char *)v6, v5, 0x600u))
    {
LABEL_32:
      free(v6);
      return 0;
    }
    v7 = sscanf((const char *)v6, "%04d%02d%02d", &v24, &v23, (char *)&v22 + 4) == 3;
    free(v6);
    if (!a2)
      goto LABEL_14;
  }
  else
  {
    v7 = 0;
    if (!a2)
    {
LABEL_14:
      v10 = 0;
      v11 = 0;
      goto LABEL_20;
    }
  }
  v8 = CFGetTypeID(a2);
  if (v8 != CFStringGetTypeID())
  {
    LODWORD(a2) = 0;
    goto LABEL_14;
  }
  v9 = CFStringGetLength(a2) + 1;
  v6 = (__CFString *)malloc_type_malloc(v9, 0x1D0F1D2EuLL);
  if (!v6)
    return v6;
  if (!CFStringGetCString(a2, (char *)v6, v9, 0x600u))
    goto LABEL_32;
  if (sscanf((const char *)v6, "%02d%02d%02d+%02d%02d", &v22, (char *)&v21 + 4, &v21, (char *)&v20 + 4, &v20) == 5)
  {
    LODWORD(a2) = 0;
  }
  else
  {
    if (sscanf((const char *)v6, "%02d%02d%02d-%02d%02d", &v22, (char *)&v21 + 4, &v21, (char *)&v20 + 4, &v20) != 5)
    {
      LODWORD(a2) = 0;
      v10 = 0;
      v11 = sscanf((const char *)v6, "%02d%02d%02d", &v22, (char *)&v21 + 4, &v21) == 3;
      goto LABEL_19;
    }
    LODWORD(a2) = 1;
  }
  v10 = 1;
  v11 = 1;
LABEL_19:
  free(v6);
LABEL_20:
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 19);
  v6 = Mutable;
  if (Mutable)
  {
    if (v7)
      CFStringAppendFormat(Mutable, 0, CFSTR("%04d-%02d-%02d"), v24, v23, HIDWORD(v22));
    else
      CFStringAppendFormat(Mutable, 0, CFSTR("0000-00-00"), v14, v16, v18);
    if (v11)
      CFStringAppendFormat(v6, 0, CFSTR("T%02d:%02d:%02d"), v22, HIDWORD(v21), v21);
    else
      CFStringAppendFormat(v6, 0, CFSTR("T00:00:00"), v15, v17, v19);
    if (v10)
    {
      if ((_DWORD)a2)
        CFStringAppendFormat(v6, 0, CFSTR("-%02d:%02d"), HIDWORD(v20), v20);
      else
        CFStringAppendFormat(v6, 0, CFSTR("+%02d:%02d"), HIDWORD(v20), v20);
    }
  }
  return v6;
}

CFStringRef CreateMergedXMPDateWithXMPTime(CFStringRef result, const __CFString *a2)
{
  const __CFString *v3;
  CFTypeID v4;
  CFTypeID TypeID;
  CFTypeID v6;
  int DateTimeStructFromXMPDateTimeString;
  int v8;
  uint64_t v9;
  BOOL v10[2];
  tm v11;
  tm v12;

  memset(&v12, 0, sizeof(v12));
  memset(&v11, 0, sizeof(v11));
  *(_WORD *)v10 = 0;
  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID(result);
    TypeID = CFStringGetTypeID();
    result = 0;
    if (a2)
    {
      if (v4 == TypeID)
      {
        v6 = CFGetTypeID(a2);
        if (v6 == CFStringGetTypeID())
        {
          DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(v3, &v12, 0, 0);
          v8 = GetDateTimeStructFromXMPDateTimeString(a2, &v11, &v10[1], v10);
          result = 0;
          if (DateTimeStructFromXMPDateTimeString && v8)
          {
            if (v10[1])
            {
              if (v10[0])
              {
                LODWORD(v9) = v11.tm_gmtoff % 3600 / 60;
                if ((int)v9 >= 0)
                  v9 = v9;
                else
                  v9 = (v11.tm_gmtoff % 3600 / -60);
                return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02dT%02d:%02d:%02d%+03d:%02d"), (v12.tm_year + 1900), (v12.tm_mon + 1), v12.tm_mday, v11.tm_hour, v11.tm_min, v11.tm_sec, v11.tm_gmtoff / 3600, v9);
              }
              else
              {
                return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02dT%02d:%02d:%02d"), (v12.tm_year + 1900), (v12.tm_mon + 1), v12.tm_mday, v11.tm_hour, v11.tm_min, v11.tm_sec);
              }
            }
            else
            {
              return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02d"), (v12.tm_year + 1900), (v12.tm_mon + 1), v12.tm_mday);
            }
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

const __CFString *CreateXMPDateTimeFromEXIFDateTime(const __CFString *cf)
{
  const __CFString *v1;
  CFTypeID v2;
  CFIndex v3;
  char *v4;
  char *v5;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;

  v1 = cf;
  v9 = 0;
  v10 = 0;
  v8 = 0;
  v7 = 0;
  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (v2 == CFStringGetTypeID()
      && (v3 = CFStringGetLength(v1) + 1, (v4 = (char *)malloc_type_malloc(v3, 0x120C3F65uLL)) != 0))
    {
      v5 = v4;
      if (CFStringGetCString(v1, v4, v3, 0x600u)
        && sscanf(v5, "%04d:%02d:%02d %02d:%02d:%02d", (char *)&v10 + 4, &v10, (char *)&v9 + 4, &v9, &v8, &v7) == 6)
      {
        v1 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02dT%02d:%02d:%02d"), HIDWORD(v10), v10, HIDWORD(v9), v9, v8, v7);
      }
      else
      {
        v1 = 0;
      }
      free(v5);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

CFStringRef CreateMetadataVersionStringFromArray(const void *a1)
{
  CFTypeID v2;
  CFIndex Count;
  unint64_t v4;
  const __CFAllocator *v5;
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  const __CFString *ValueAtIndex;
  const __CFString *v9;
  CFTypeID v10;
  const __CFString *SimpleStringFromCFValue;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  CFTypeID v15;
  CFStringRef v16;
  CFStringRef v17;
  const __CFString *v18;
  const __CFString *v19;
  CFTypeID v20;
  CFStringRef v21;
  CFStringRef v22;
  CFStringRef v23;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID())
    return 0;
  Count = CFArrayGetCount((CFArrayRef)a1);
  if (Count < 2)
    return 0;
  v4 = Count;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return 0;
  v7 = Mutable;
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a1, 0);
  if (!ValueAtIndex)
    goto LABEL_22;
  v9 = ValueAtIndex;
  v10 = CFGetTypeID(ValueAtIndex);
  if (v10 != CFNumberGetTypeID())
    goto LABEL_22;
  SimpleStringFromCFValue = CGImageMetadataCreateSimpleStringFromCFValue(v9, 0);
  if (!SimpleStringFromCFValue)
    goto LABEL_22;
  v12 = SimpleStringFromCFValue;
  if (CFStringGetLength(SimpleStringFromCFValue) == 1)
    CFArrayAppendValue(v7, CFSTR("0"));
  CFArrayAppendValue(v7, v12);
  CFRelease(v12);
  v13 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a1, 1);
  if (!v13)
    goto LABEL_22;
  v14 = v13;
  v15 = CFGetTypeID(v13);
  if (v15 != CFNumberGetTypeID())
    goto LABEL_22;
  v16 = CGImageMetadataCreateSimpleStringFromCFValue(v14, 0);
  if (!v16)
    goto LABEL_22;
  v17 = v16;
  CFArrayAppendValue(v7, v16);
  CFRelease(v17);
  if (v4 < 3)
  {
    CFArrayAppendValue(v7, CFSTR("0"));
    goto LABEL_19;
  }
  v18 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a1, 2);
  if (!v18
    || (v19 = v18, v20 = CFGetTypeID(v18), v20 != CFNumberGetTypeID())
    || (v21 = CGImageMetadataCreateSimpleStringFromCFValue(v19, 0)) == 0)
  {
LABEL_22:
    v23 = 0;
    goto LABEL_20;
  }
  v22 = v21;
  CFArrayAppendValue(v7, v21);
  CFRelease(v22);
LABEL_19:
  v23 = CFStringCreateByCombiningStrings(v5, v7, &stru_1E1BCE100);
LABEL_20:
  CFRelease(v7);
  return v23;
}

const __CFArray *CreateMetadataLensInfoFromCFValue(const __CFArray *cf, CFIndex *a2)
{
  const __CFArray *v2;
  CFTypeID v4;
  const __CFAllocator *v5;
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFString *v12;
  CFTypeID v13;
  const __CFString *SimpleStringFromCFValue;
  const __CFString *v15;
  const __CFString *v16;

  v2 = cf;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFArrayGetTypeID()
      && (v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00],
          (Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378])) != 0))
    {
      v7 = Mutable;
      Count = CFArrayGetCount(v2);
      if (Count >= 1)
      {
        v9 = Count;
        for (i = 0; i != v9; ++i)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v2, i);
          if (ValueAtIndex)
          {
            v12 = ValueAtIndex;
            v13 = CFGetTypeID(ValueAtIndex);
            if (v13 == CFNumberGetTypeID())
            {
              SimpleStringFromCFValue = CGImageMetadataCreateSimpleStringFromCFValue(v12, 3);
              if (SimpleStringFromCFValue)
              {
                v15 = SimpleStringFromCFValue;
                if (CFStringCompare(SimpleStringFromCFValue, CFSTR("0/1"), 0))
                  v16 = v15;
                else
                  v16 = CFSTR("0/0");
                CFArrayAppendValue(v7, v16);
                CFRelease(v15);
              }
            }
          }
        }
      }
      v2 = (const __CFArray *)CFStringCreateByCombiningStrings(v5, v7, CFSTR(" "));
      if (a2)
        *a2 = CFArrayGetCount(v7);
      CFRelease(v7);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

__CFDictionary *CreateXMPFlashStructFromCFValue(__CFDictionary *result)
{
  const __CFNumber *v1;
  CFTypeID v2;
  unsigned int valuePtr;

  valuePtr = 0;
  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID() && CFNumberGetValue(v1, kCFNumberIntType, &valuePtr))
      return CreateXMPFlashStructFromInt(valuePtr);
    else
      return 0;
  }
  return result;
}

CFStringRef CreateXMPGPSCoordinateFromCFValue(CFStringRef result, const __CFString *a2, int a3)
{
  const __CFNumber *v5;
  CFTypeID v6;
  BOOL v7;
  uint64_t v8;
  unsigned int v9;
  CFTypeID v10;
  unsigned int v11;
  double valuePtr;

  valuePtr = 0.0;
  if (result)
  {
    v5 = (const __CFNumber *)result;
    v6 = CFGetTypeID(result);
    if (v6 == CFNumberGetTypeID())
    {
      if (CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr))
      {
        if (a2)
        {
LABEL_5:
          if (a3)
          {
            v7 = CFStringCompare(a2, CFSTR("N"), 0) == kCFCompareEqualTo;
            LODWORD(v8) = 83;
            v9 = 78;
          }
          else
          {
            v7 = CFStringCompare(a2, CFSTR("E"), 0) == kCFCompareEqualTo;
            LODWORD(v8) = 87;
            v9 = 69;
          }
          if (v7)
            v8 = v9;
          else
            v8 = v8;
LABEL_23:
          valuePtr = fabs(valuePtr);
          return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d,%lg%c"), (int)valuePtr, (valuePtr - (double)(int)valuePtr) * 60.0, v8, *(_QWORD *)&valuePtr);
        }
LABEL_9:
        if (valuePtr < 0.0)
          LODWORD(v8) = 87;
        else
          LODWORD(v8) = 69;
        if (valuePtr < 0.0)
          v11 = 83;
        else
          v11 = 78;
        if (a3)
          v8 = v11;
        else
          v8 = v8;
        goto LABEL_23;
      }
    }
    else
    {
      v10 = CFGetTypeID(v5);
      if (v10 == CFStringGetTypeID())
      {
        valuePtr = CFStringGetDoubleValue((CFStringRef)v5);
        if (a2)
          goto LABEL_5;
        goto LABEL_9;
      }
    }
    return 0;
  }
  return result;
}

const __CFArray *CreateGPSVersionStringFromArray(const __CFArray *cf)
{
  const __CFArray *v1;
  CFTypeID v2;
  CFIndex Count;
  CFIndex v4;
  CFIndex v5;
  const __CFAllocator *v6;
  const __CFString *ValueAtIndex;
  CFTypeID v8;
  void *Copy;
  CFTypeID v10;
  const __CFArray *v11;
  const __CFArray *v12;
  uint64_t i;
  const void *v14;
  uint64_t valuePtr;
  void *values[2];
  __int128 v18;
  uint64_t v19;

  v1 = cf;
  v19 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)values = 0u;
  v18 = 0u;
  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (v2 != CFArrayGetTypeID())
      goto LABEL_16;
    Count = CFArrayGetCount(v1);
    if (Count < 2)
      goto LABEL_16;
    v4 = Count;
    v5 = 0;
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    do
    {
      if (v4 <= v5)
      {
        Copy = (void *)CFRetain(CFSTR("0"));
        if (!Copy)
          goto LABEL_16;
      }
      else
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v1, v5);
        v8 = CFGetTypeID(ValueAtIndex);
        if (v8 == CFNumberGetTypeID())
        {
          valuePtr = 0;
          CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberLongType, &valuePtr);
          Copy = (void *)CFStringCreateWithFormat(v6, 0, CFSTR("%ld"), valuePtr);
          if (!Copy)
            goto LABEL_16;
        }
        else
        {
          v10 = CFGetTypeID(ValueAtIndex);
          if (v10 != CFStringGetTypeID())
            goto LABEL_16;
          Copy = (void *)CFStringCreateCopy(v6, ValueAtIndex);
          if (!Copy)
            goto LABEL_16;
        }
      }
      values[v5++] = Copy;
    }
    while (v5 != 4);
    v11 = CFArrayCreate(v6, (const void **)values, 4, MEMORY[0x1E0C9B378]);
    if (v11)
    {
      v12 = v11;
      v1 = (const __CFArray *)CFStringCreateByCombiningStrings(v6, v11, CFSTR("."));
      CFRelease(v12);
    }
    else
    {
LABEL_16:
      v1 = 0;
    }
  }
  for (i = 0; i != 4; ++i)
  {
    v14 = values[i];
    if (v14)
      CFRelease(v14);
  }
  return v1;
}

void AddMWGRegionsFromExifAuxRegions(CGImageMetadata *a1, IIODictionary *this)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  const __CFArray *v7;
  unsigned int Count;
  CFIndex v9;
  const __CFArray *ObjectAtIndex;
  const __CFDictionary *v11;
  CFTypeID v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  const __CFString *v18;
  CGImageMetadataTagRef v19;
  CGImageMetadataTagRef v20;
  CGImageMetadataTagRef v21;
  CGImageMetadataTagRef v22;
  CGImageMetadataTagRef v23;
  CGImageMetadataTagRef v24;
  CFDictionaryRef v25;
  CGImageMetadataTagRef v26;
  CFDictionaryRef v27;
  CGImageMetadataTagRef v28;
  CGImageMetadataTag *v29;
  const __CFString *v30;
  const __CFString *v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  const __CFDictionary *v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  __CFDictionary *Mutable;
  CGImageMetadataTagRef v38;
  CGImageMetadataTagRef v39;
  CGImageMetadataTagRef v40;
  CGImageMetadataTagRef v41;
  CGImageMetadataTagRef v42;
  CGImageMetadataTag *v43;
  const __CFString *v44;
  CGImageMetadataTagRef cf;
  CGImageMetadata *metadata;
  const __CFAllocator *alloc;
  uint64_t v48;
  _QWORD v49[3];
  void *v50[3];
  void *v51;
  void *v52;
  void *values[5];
  void *keys[2];
  __int128 v55;
  const __CFString *v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (this)
  {
    ObjectForKey = IIODictionary::getObjectForKey(this, CFSTR("HeightAppliedTo"));
    v5 = IIODictionary::getObjectForKey(this, CFSTR("WidthAppliedTo"));
    v6 = IIODictionary::getObjectForKey(this, CFSTR("RegionList"));
    if (ObjectForKey)
    {
      if (v5)
      {
        v7 = v6;
        if (v6)
        {
          if (CFArrayGetCount(v6) >= 1)
          {
            memset(v50, 0, sizeof(v50));
            IIOArray::IIOArray((IIOArray *)v50, v7);
            CGImageMetadataRegisterNamespaceForPrefix(a1, CFSTR("http://www.metadataworkinggroup.com/schemas/regions/"), CFSTR("mwg-rs"), 0);
            CGImageMetadataRegisterNamespaceForPrefix(a1, CFSTR("http://ns.apple.com/faceinfo/1.0/"), CFSTR("apple-fi"), 0);
            CGImageMetadataRegisterNamespaceForPrefix(a1, CFSTR("http://ns.adobe.com/xap/1.0/sType/Dimensions#"), CFSTR("stDim"), 0);
            CGImageMetadataSetValueWithPath(a1, 0, CFSTR("mwg-rs:Regions.AppliedToDimensions.stDim:h"), ObjectForKey);
            CGImageMetadataSetValueWithPath(a1, 0, CFSTR("mwg-rs:Regions.AppliedToDimensions.stDim:w"), v5);
            CGImageMetadataSetValueWithPath(a1, 0, CFSTR("mwg-rs:Regions.AppliedToDimensions.stDim:unit"), CFSTR("pixel"));
            Count = IIOArray::getCount((IIOArray *)v50);
            if (Count)
            {
              v9 = 0;
              alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              v48 = Count;
              metadata = a1;
              while (1)
              {
                ObjectAtIndex = IIOArray::getObjectAtIndex((IIOArray *)v50, v9);
                v11 = ObjectAtIndex;
                if (!ObjectAtIndex)
                  goto LABEL_70;
                v12 = CFGetTypeID(ObjectAtIndex);
                if (v12 != CFDictionaryGetTypeID())
                  goto LABEL_70;
                memset(v49, 0, sizeof(v49));
                IIODictionary::IIODictionary((IIODictionary *)v49, v11);
                v13 = IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("X"));
                v14 = IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("Y"));
                v15 = IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("Width"));
                v16 = IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("Height"));
                if (v13)
                {
                  if (v14)
                  {
                    if (v15)
                    {
                      v17 = v16;
                      if (v16)
                      {
                        v18 = CFStringCreateWithFormat(alloc, 0, CFSTR("[%ld]"), v9);
                        if (v18)
                          break;
                      }
                    }
                  }
                }
LABEL_69:
                IIODictionary::~IIODictionary((IIODictionary *)v49);
LABEL_70:
                if (v48 == ++v9)
                  goto LABEL_71;
              }
              v19 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/xmp/sType/Area#"), CFSTR("stArea"), CFSTR("x"), kCGImageMetadataTypeString, v13);
              v20 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/xmp/sType/Area#"), CFSTR("stArea"), CFSTR("y"), kCGImageMetadataTypeString, v14);
              v21 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/xmp/sType/Area#"), CFSTR("stArea"), CFSTR("w"), kCGImageMetadataTypeString, v15);
              v22 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/xmp/sType/Area#"), CFSTR("stArea"), CFSTR("h"), kCGImageMetadataTypeString, v17);
              v23 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/xmp/sType/Area#"), CFSTR("stArea"), CFSTR("unit"), kCGImageMetadataTypeString, CFSTR("normalized"));
              v24 = v23;
              if (v19 && v20 && v21 && v22 && v23)
              {
                *(_OWORD *)keys = xmmword_1E1BCA240;
                v55 = *(_OWORD *)off_1E1BCA250;
                v56 = CFSTR("unit");
                values[0] = v19;
                values[1] = v20;
                values[2] = v21;
                values[3] = v22;
                values[4] = v23;
                v25 = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, 5, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                if (v25)
                {
                  v26 = CGImageMetadataTagCreate(CFSTR("http://www.metadataworkinggroup.com/schemas/regions/"), CFSTR("mwg-rs"), CFSTR("Area"), kCGImageMetadataTypeStructure, v25);
                  cf = v26;
                  if (v26)
                  {
                    v51 = v26;
                    v52 = CFSTR("Area");
                    v27 = CFDictionaryCreate(alloc, (const void **)&v52, (const void **)&v51, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                    if (v27)
                    {
                      v28 = CGImageMetadataTagCreate(CFSTR("http://www.metadataworkinggroup.com/schemas/regions/"), CFSTR("mwg-rs"), v18, kCGImageMetadataTypeStructure, v27);
                      CFRelease(v27);
                    }
                    else
                    {
                      v28 = 0;
                    }
                    CFRelease(cf);
                  }
                  else
                  {
                    v28 = 0;
                  }
                  CFRelease(v25);
                }
                else
                {
                  v28 = 0;
                }
              }
              else
              {
                v28 = 0;
                v29 = 0;
                if (!v19)
                  goto LABEL_32;
              }
              CFRelease(v19);
              v29 = v28;
LABEL_32:
              if (v20)
                CFRelease(v20);
              if (v21)
                CFRelease(v21);
              if (v22)
                CFRelease(v22);
              if (v24)
                CFRelease(v24);
              CFRelease(v18);
              if (v29)
              {
                v30 = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("Type"));
                v31 = v30;
                if (v30
                  && (CFStringCompare(v30, CFSTR("Face"), 0) == kCFCompareEqualTo
                   || CFStringCompare(v31, CFSTR("Pet"), 0) == kCFCompareEqualTo
                   || CFStringCompare(v31, CFSTR("Focus"), 0) == kCFCompareEqualTo
                   || CFStringCompare(v31, CFSTR("BarCode"), 0) == kCFCompareEqualTo
                   || CFStringCompare(v31, CFSTR("CleanAperture"), 0) == kCFCompareEqualTo))
                {
                  CGImageMetadataSetValueWithPath(metadata, v29, CFSTR("mwg-rs:Type"), v31);
                }
                v32 = IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("Timestamp"));
                v33 = IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("AngleInfoYaw"));
                v34 = IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("AngleInfoRoll"));
                v35 = IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("ConfidenceLevel"));
                v36 = IIODictionary::getObjectForKey((IIODictionary *)v49, CFSTR("FaceID"));
                Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                if (Mutable)
                {
                  if (v32)
                  {
                    v38 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/faceinfo/1.0/"), CFSTR("apple-fi"), CFSTR("Timestamp"), kCGImageMetadataTypeString, v32);
                    if (v38)
                    {
                      CFDictionarySetValue(Mutable, CFSTR("Timestamp"), v38);
                      CFRelease(v38);
                    }
                  }
                  if (v33)
                  {
                    v39 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/faceinfo/1.0/"), CFSTR("apple-fi"), CFSTR("AngleInfoYaw"), kCGImageMetadataTypeString, v33);
                    if (v39)
                    {
                      CFDictionarySetValue(Mutable, CFSTR("AngleInfoYaw"), v39);
                      CFRelease(v39);
                    }
                  }
                  if (v34)
                  {
                    v40 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/faceinfo/1.0/"), CFSTR("apple-fi"), CFSTR("AngleInfoRoll"), kCGImageMetadataTypeString, v34);
                    if (v40)
                    {
                      CFDictionarySetValue(Mutable, CFSTR("AngleInfoRoll"), v40);
                      CFRelease(v40);
                    }
                  }
                  if (v35)
                  {
                    v41 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/faceinfo/1.0/"), CFSTR("apple-fi"), CFSTR("ConfidenceLevel"), kCGImageMetadataTypeString, v35);
                    if (v41)
                    {
                      CFDictionarySetValue(Mutable, CFSTR("ConfidenceLevel"), v41);
                      CFRelease(v41);
                    }
                  }
                  if (v36)
                  {
                    v42 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/faceinfo/1.0/"), CFSTR("apple-fi"), CFSTR("FaceID"), kCGImageMetadataTypeString, v36);
                    if (v42)
                    {
                      CFDictionarySetValue(Mutable, CFSTR("FaceID"), v42);
                      CFRelease(v42);
                    }
                  }
                  v43 = CGImageMetadataTagCreate(CFSTR("http://www.metadataworkinggroup.com/schemas/regions/"), CFSTR("mwg-rs"), CFSTR("Extensions"), kCGImageMetadataTypeStructure, Mutable);
                  CFRelease(Mutable);
                  if (v43)
                  {
                    CGImageMetadataSetTagWithPath(metadata, v29, CFSTR("mwg-rs:Extensions"), v43);
                    CFRelease(v43);
                  }
                }
                v44 = CFStringCreateWithFormat(alloc, 0, CFSTR("mwg-rs:Regions.RegionList[%ld]"), v9);
                if (v44)
                {
                  CGImageMetadataSetTagWithPath(metadata, 0, v44, v29);
                  CFRelease(v44);
                }
                CFRelease(v29);
              }
              goto LABEL_69;
            }
LABEL_71:
            IIOArray::~IIOArray((IIOArray *)v50);
          }
        }
      }
    }
  }
}

void sub_18803C7DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

BOOL GetLongLongFromPropertyValue(const __CFString *a1, uint64_t *a2)
{
  _BOOL8 v2;
  const __CFString *v4;
  CFTypeID v5;
  CFTypeID v6;
  CFIndex Length;
  CFIndex v8;
  char *v9;
  int CString;

  v2 = 0;
  if (a1 && a2)
  {
    v4 = a1;
    *a2 = 0;
    v5 = CFGetTypeID(a1);
    if ((v5 != CGImageMetadataTagGetTypeID()
       || (v4 = *(const __CFString **)(CGImageSourceGetSource((uint64_t)v4) + 48)) != 0)
      && (v6 = CFGetTypeID(v4), v6 == CFStringGetTypeID()))
    {
      Length = CFStringGetLength(v4);
      v8 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
      v9 = (char *)malloc_type_malloc(v8, 0xD25FA49DuLL);
      CString = CFStringGetCString(v4, v9, v8, 0x8000100u);
      v2 = CString != 0;
      if (CString)
        *a2 = atoll(v9);
      free(v9);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t GetMajorVersionFromPropertyValue(const __CFString *cf, SInt32 *a2)
{
  uint64_t result;
  CFTypeID v5;
  const __CFString *v6;
  const __CFString *v7;
  CFRange v8;

  result = 0;
  if (cf && a2)
  {
    v5 = CFGetTypeID(cf);
    if (v5 == CFStringGetTypeID() && CFStringGetLength(cf) == 4)
    {
      v8.location = 0;
      v8.length = 2;
      v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cf, v8);
      if (v6)
      {
        v7 = v6;
        *a2 = CFStringGetIntValue(v6);
        CFRelease(v7);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t GetMinorVersionFromPropertyValue(const __CFString *a1, SInt32 *a2)
{
  uint64_t v2;
  CFTypeID v5;
  const __CFString *v6;
  const __CFString *v7;
  CFRange v9;

  v2 = 0;
  if (a1 && a2)
  {
    v5 = CFGetTypeID(a1);
    if (v5 == CFStringGetTypeID() && CFStringGetLength(a1) == 4)
    {
      v2 = 1;
      v9.location = 2;
      v9.length = 1;
      v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v9);
      if (v6)
      {
        v7 = v6;
        *a2 = CFStringGetIntValue(v6);
        CFRelease(v7);
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t GetRevisionVersionFromPropertyValue(const __CFString *a1, SInt32 *a2)
{
  uint64_t v2;
  CFTypeID v5;
  const __CFString *v6;
  const __CFString *v7;
  CFRange v9;

  v2 = 0;
  if (a1 && a2)
  {
    v5 = CFGetTypeID(a1);
    if (v5 == CFStringGetTypeID() && CFStringGetLength(a1) == 4)
    {
      v2 = 1;
      v9.location = 3;
      v9.length = 1;
      v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v9);
      if (v6)
      {
        v7 = v6;
        *a2 = CFStringGetIntValue(v6);
        CFRelease(v7);
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void addPropertiesFromMetadata(IIODictionary *a1, CFMutableArrayRef *a2, void *a3, int a4)
{
  CFTypeID v8;
  const __CFArray *v9;
  IIOArray *v10;
  CFTypeID v11;
  const __CFString *v12;
  const CFStringRef *v13;
  CFTypeID v14;
  CFTypeID v15;
  CFTypeID v16;
  IIOArray *v17;
  const __CFString *v18;
  CFStringRef v19;
  const __CFString *v20;
  uint64_t v21;
  const __CFString *v22;
  __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  CGImageMetadataType Type;
  CFTypeRef v27;
  CFTypeRef v28;
  const void *v29;
  CFTypeID v30;
  CFTypeID v31;
  CFTypeRef v32;
  CFTypeID v33;
  CFTypeID v34;
  CFTypeID v35;
  _QWORD v36[6];
  int v37;
  _QWORD v38[3];
  _QWORD v39[6];
  int v40;
  _QWORD v41[6];
  int v42;
  uint64_t v43;
  const void *v44;
  uint64_t v45;

  if (!a3)
    return;
  v8 = CFGetTypeID(a3);
  if (v8 == CGImageMetadataGetTypeID())
  {
    v9 = CGImageMetadataCopyTags((CGImageMetadataRef)a3);
    v43 = 0;
    v44 = 0;
    v45 = 0;
    v10 = IIOArray::IIOArray((IIOArray *)&v43, v9);
    v41[0] = MEMORY[0x1E0C809B0];
    v41[1] = 0x40000000;
    v41[2] = ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke;
    v41[3] = &__block_descriptor_tmp_270;
    v41[4] = a1;
    v41[5] = a2;
    v42 = a4;
    IIOArray::enumerate((uint64_t)v10, (uint64_t)v41);
    CFRelease(v9);
LABEL_4:
    IIOArray::~IIOArray((IIOArray *)&v43);
    return;
  }
  v11 = CFGetTypeID(a3);
  if (v11 == CGImageMetadataTagGetTypeID())
  {
    v12 = CGImageMetadataTagCopyNamespace((CGImageMetadataTagRef)a3);
    if (CFStringCompare(v12, CFSTR("http://ns.adobe.com/photoshop/1.0/"), 0)
      && CFStringCompare(v12, CFSTR("http://ns.adobe.com/exif/1.0/"), 0))
    {
      if (CFStringCompare(v12, CFSTR("http://ns.adobe.com/exif/1.0/aux/"), 0) == kCFCompareEqualTo
        || CFStringCompare(v12, CFSTR("http://ns.adobe.com/exif/1.0/"), 0) == kCFCompareEqualTo)
      {
        v13 = &kCGImagePropertyExifAuxDictionary;
        goto LABEL_23;
      }
      if (CFStringCompare(v12, CFSTR("http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/"), 0)
        && CFStringCompare(v12, CFSTR("http://iptc.org/std/Iptc4xmpExt/2008-02-29/"), 0)
        && CFStringCompare(v12, CFSTR("http://purl.org/dc/elements/1.1/"), 0)
        && CFStringCompare(v12, CFSTR("http://ns.adobe.com/tiff/1.0/"), 0) == kCFCompareEqualTo)
      {
        v13 = &kCGImagePropertyTIFFDictionary;
        goto LABEL_23;
      }
    }
    v13 = &kCGImagePropertyIPTCDictionary;
LABEL_23:
    v18 = *v13;
    v19 = CGImageMetadataTagCopyName((CGImageMetadataTagRef)a3);
    if (v19)
    {
      v20 = v19;
      v21 = 0;
      v22 = CFSTR("AuthorsPosition");
      while (CFStringCompare(v20, v22, 0))
      {
        v22 = gKeyMapping[v21 + 2];
        v21 += 2;
        if (v21 == 32)
        {
          v23 = (__CFString *)v20;
          goto LABEL_30;
        }
      }
      v23 = gKeyMapping[v21 + 1];
LABEL_30:
      v24 = (const __CFString *)CFRetain(v23);
      CFRelease(v20);
    }
    else
    {
      v24 = 0;
    }
    if (a4 <= 1)
      v25 = v18;
    else
      v25 = 0;
    Type = CGImageMetadataTagGetType((CGImageMetadataTagRef)a3);
    if ((Type - 2) >= 4)
    {
      if (Type == kCGImageMetadataTypeStructure)
      {
        v43 = 0;
        v44 = 0;
        v45 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v43);
        if (a1)
        {
          if (v25)
            IIODictionary::setObjectForKeyGroup(a1, v44, v24, v25);
          else
            IIODictionary::setObjectForKey(a1, v44, v24);
        }
        else
        {
          IIOArray::addObject(a2, v44);
        }
        v32 = CGImageMetadataTagCopyValue((CGImageMetadataTagRef)a3);
        if (v32)
        {
          addPropertiesFromMetadata((IIODictionary *)&v43, (IIOArray *)a2, v32, a4 + 1);
          CFRelease(v32);
        }
        IIODictionary::~IIODictionary((IIODictionary *)&v43);
      }
      else if (Type == kCGImageMetadataTypeString)
      {
        v28 = CGImageMetadataTagCopyValue((CGImageMetadataTagRef)a3);
        if (v28)
        {
          v29 = v28;
          if (a1)
          {
            if (v25)
              IIODictionary::setObjectForKeyGroup(a1, v28, v24, v25);
            else
              IIODictionary::setObjectForKey(a1, v28, v24);
          }
          else if (a2)
          {
            IIOArray::addObject(a2, v28);
          }
          CFRelease(v29);
        }
      }
    }
    else
    {
      v27 = CGImageMetadataTagCopyValue((CGImageMetadataTagRef)a3);
      v43 = 0;
      v44 = 0;
      v45 = 0;
      IIOArray::IIOArray((IIOArray *)&v43);
      if (a1)
      {
        if (v25)
          IIODictionary::setObjectForKeyGroup(a1, v44, v24, v25);
        else
          IIODictionary::setObjectForKey(a1, v44, v24);
      }
      else if (a2)
      {
        IIOArray::addObject(a2, v44);
      }
      addPropertiesFromMetadata(0, (IIOArray *)&v43, v27, a4 + 1);
      CFRelease(v27);
      IIOArray::~IIOArray((IIOArray *)&v43);
    }
    if (v12)
      CFRelease(v12);
    if (v24)
      CFRelease(v24);
    return;
  }
  v14 = CFGetTypeID(a3);
  if (v14 == CGImageMetadataValueGetTypeID())
  {
    _cg_jpeg_mem_term("addPropertiesFromMetadata", 1469, "===CGImageMetadataValue:%p===\n");
  }
  else
  {
    v15 = CFGetTypeID(a3);
    if (v15 == CGImageMetadataPropertyGetTypeID())
    {
      _cg_jpeg_mem_term("addPropertiesFromMetadata", 1473, "===CGImageMetadataProperty:%p===\n");
    }
    else
    {
      v16 = CFGetTypeID(a3);
      if (v16 == CFArrayGetTypeID())
      {
        v43 = 0;
        v44 = 0;
        v45 = 0;
        v17 = IIOArray::IIOArray((IIOArray *)&v43, (const __CFArray *)a3);
        v39[0] = MEMORY[0x1E0C809B0];
        v39[1] = 0x40000000;
        v39[2] = ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke_2;
        v39[3] = &__block_descriptor_tmp_273;
        v39[4] = a1;
        v39[5] = a2;
        v40 = a4;
        IIOArray::enumerate((uint64_t)v17, (uint64_t)v39);
        goto LABEL_4;
      }
      v30 = CFGetTypeID(a3);
      if (v30 == CFDictionaryGetTypeID())
      {
        v43 = 0;
        v44 = 0;
        v45 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v43);
        memset(v38, 0, sizeof(v38));
        IIODictionary::IIODictionary((IIODictionary *)v38, (const __CFDictionary *)a3);
        v36[0] = MEMORY[0x1E0C809B0];
        v36[1] = 0x40000000;
        v36[2] = ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke_3;
        v36[3] = &__block_descriptor_tmp_274;
        v36[4] = a1;
        v36[5] = a2;
        v37 = a4;
        IIODictionary::enumerate((uint64_t)v38, v36);
        IIODictionary::~IIODictionary((IIODictionary *)v38);
        IIODictionary::~IIODictionary((IIODictionary *)&v43);
      }
      else
      {
        v31 = CFGetTypeID(a3);
        if (v31 == CFBagGetTypeID())
        {
          _cg_jpeg_mem_term("addPropertiesFromMetadata", 1498, "===CFBag:%p===\n");
        }
        else
        {
          v33 = CFGetTypeID(a3);
          if (v33 == CFSetGetTypeID())
          {
            _cg_jpeg_mem_term("addPropertiesFromMetadata", 1502, "===CFSet:%p===\n");
          }
          else
          {
            v34 = CFGetTypeID(a3);
            if (v34 == CFStringGetTypeID())
            {
              _cg_jpeg_mem_term("addPropertiesFromMetadata", 1506, "===CFString:%p===\n");
            }
            else
            {
              v35 = CFGetTypeID(a3);
              if (v35 == CFNumberGetTypeID())
              {
                _cg_jpeg_mem_term("addPropertiesFromMetadata", 1510, "===CFNumber:%p===\n");
              }
              else
              {
                _cg_jpeg_mem_term("addPropertiesFromMetadata", 1514, "===unknown:%p===\n", a3);
                CFShow(a3);
              }
            }
          }
        }
      }
    }
  }
}

void sub_18803D184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v9 - 104));
  _Unwind_Resume(a1);
}

__CFDictionary *CreateRegionFromPropertyValue(const void *a1)
{
  CFTypeID v2;
  __CFDictionary *Mutable;
  const void *Value;
  uint64_t Source;
  uint64_t v6;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  CFNumberRef IntValueFromField;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeID v17;
  const __CFArray *v18;
  CFTypeID v19;
  CFMutableArrayRef v20;
  CFMutableArrayRef v21;
  CFIndex v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;
  CFMutableDictionaryRef v27;
  CFMutableDictionaryRef v28;
  const void *ValueAtIndex;
  uint64_t v30;
  uint64_t v31;
  CFTypeID v32;
  const __CFDictionary *v33;
  CFTypeID v34;
  __CFArray *v35;
  const __CFArray *v36;
  const __CFString *v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  const void *v41;
  uint64_t v42;
  uint64_t v43;
  CFTypeID v44;
  const void *v45;
  CFTypeID v46;
  CFNumberRef FloatValueFromField;
  CFNumberRef v48;
  CFNumberRef v49;
  CFNumberRef v50;
  CFNumberRef v51;
  CFNumberRef v52;
  CFNumberRef v53;
  CFNumberRef v54;
  const void *v55;
  const void *DefaultString;
  const void *v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  uint64_t v62;
  uint64_t v63;
  CFTypeID v64;
  const __CFDictionary *v65;
  CFTypeID v66;
  CFNumberRef v67;
  CFNumberRef v68;
  CFNumberRef v69;
  CFNumberRef v70;
  CFNumberRef v71;
  CFNumberRef v72;
  CFNumberRef v73;
  CFNumberRef v74;
  CFNumberRef v75;
  CFNumberRef v76;
  __CFDictionary *v78;
  CFIndex Count;
  const __CFAllocator *allocator;
  CFIndex v81;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (v2 != CFDictionaryGetTypeID())
    return 0;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("AppliedToDimensions"));
    Source = CGImageSourceGetSource((uint64_t)Value);
    if (Value)
    {
      v6 = Source;
      v7 = CFGetTypeID(Value);
      if (v7 == CGImageMetadataTagGetTypeID())
      {
        v8 = *(const void **)(v6 + 48);
        if (v8)
        {
          v9 = CFGetTypeID(v8);
          if (v9 == CFDictionaryGetTypeID())
          {
            IntValueFromField = CreateIntValueFromField((const __CFDictionary *)v8, CFSTR("w"));
            if (IntValueFromField)
            {
              v11 = IntValueFromField;
              CFDictionarySetValue(Mutable, CFSTR("WidthAppliedTo"), IntValueFromField);
              CFRelease(v11);
            }
            v12 = CreateIntValueFromField((const __CFDictionary *)v8, CFSTR("h"));
            if (v12)
            {
              v13 = v12;
              CFDictionarySetValue(Mutable, CFSTR("HeightAppliedTo"), v12);
              CFRelease(v13);
            }
            v14 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("RegionList"));
            v15 = CGImageSourceGetSource((uint64_t)v14);
            if (v14)
            {
              v16 = v15;
              v17 = CFGetTypeID(v14);
              if (v17 == CGImageMetadataTagGetTypeID())
              {
                v18 = *(const __CFArray **)(v16 + 48);
                if (v18)
                {
                  v19 = CFGetTypeID(*(CFTypeRef *)(v16 + 48));
                  if (v19 == CFArrayGetTypeID())
                  {
                    v20 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
                    if (v20)
                    {
                      v21 = v20;
                      CFDictionarySetValue(Mutable, CFSTR("RegionList"), v20);
                      CFRelease(v21);
                      Count = CFArrayGetCount(v18);
                      if (Count >= 1)
                      {
                        v78 = Mutable;
                        v22 = 0;
                        v23 = CFSTR("Name");
                        v24 = CFSTR("Type");
                        v25 = CFSTR("Description");
                        v26 = CFSTR("Timestamp");
                        do
                        {
                          v27 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                          if (!v27)
                            break;
                          v28 = v27;
                          CFArrayAppendValue(v21, v27);
                          CFRelease(v28);
                          ValueAtIndex = CFArrayGetValueAtIndex(v18, v22);
                          v30 = CGImageSourceGetSource((uint64_t)ValueAtIndex);
                          if (!ValueAtIndex)
                            break;
                          v31 = v30;
                          v32 = CFGetTypeID(ValueAtIndex);
                          if (v32 != CGImageMetadataTagGetTypeID())
                            break;
                          v33 = *(const __CFDictionary **)(v31 + 48);
                          if (!v33)
                            break;
                          v34 = CFGetTypeID(*(CFTypeRef *)(v31 + 48));
                          if (v34 != CFDictionaryGetTypeID())
                            break;
                          v81 = v22;
                          v35 = v21;
                          v36 = v18;
                          v37 = v26;
                          v38 = v25;
                          v39 = v24;
                          v40 = v23;
                          v41 = CFDictionaryGetValue(v33, CFSTR("Area"));
                          v42 = CGImageSourceGetSource((uint64_t)v41);
                          if (!v41)
                            break;
                          v43 = v42;
                          v44 = CFGetTypeID(v41);
                          if (v44 != CGImageMetadataTagGetTypeID())
                            break;
                          v45 = *(const void **)(v43 + 48);
                          if (!v45)
                            break;
                          v46 = CFGetTypeID(v45);
                          if (v46 != CFDictionaryGetTypeID())
                            break;
                          FloatValueFromField = CreateFloatValueFromField((const __CFDictionary *)v45, CFSTR("w"));
                          if (FloatValueFromField)
                          {
                            v48 = FloatValueFromField;
                            CFDictionarySetValue(v28, CFSTR("Width"), FloatValueFromField);
                            CFRelease(v48);
                          }
                          v49 = CreateFloatValueFromField((const __CFDictionary *)v45, CFSTR("h"));
                          if (v49)
                          {
                            v50 = v49;
                            CFDictionarySetValue(v28, CFSTR("Height"), v49);
                            CFRelease(v50);
                          }
                          v51 = CreateFloatValueFromField((const __CFDictionary *)v45, CFSTR("x"));
                          if (v51)
                          {
                            v52 = v51;
                            CFDictionarySetValue(v28, CFSTR("X"), v51);
                            CFRelease(v52);
                          }
                          v53 = CreateFloatValueFromField((const __CFDictionary *)v45, CFSTR("y"));
                          if (v53)
                          {
                            v54 = v53;
                            CFDictionarySetValue(v28, CFSTR("Y"), v53);
                            CFRelease(v54);
                          }
                          v23 = v40;
                          v55 = CFDictionaryGetValue(v33, v40);
                          DefaultString = CGImageMetadataGetDefaultString(v55);
                          if (DefaultString)
                            CFDictionarySetValue(v28, v40, DefaultString);
                          v24 = v39;
                          v57 = CFDictionaryGetValue(v33, v39);
                          v58 = CGImageMetadataGetDefaultString(v57);
                          if (v58)
                            CFDictionarySetValue(v28, v39, v58);
                          v25 = v38;
                          v59 = CFDictionaryGetValue(v33, v38);
                          v60 = CGImageMetadataGetDefaultString(v59);
                          if (v60)
                            CFDictionarySetValue(v28, v38, v60);
                          v61 = CFDictionaryGetValue(v33, CFSTR("Extensions"));
                          v62 = CGImageSourceGetSource((uint64_t)v61);
                          v26 = v37;
                          v18 = v36;
                          v21 = v35;
                          if (v61)
                          {
                            v63 = v62;
                            v64 = CFGetTypeID(v61);
                            if (v64 == CGImageMetadataTagGetTypeID())
                            {
                              v65 = *(const __CFDictionary **)(v63 + 48);
                              if (v65)
                              {
                                v66 = CFGetTypeID(*(CFTypeRef *)(v63 + 48));
                                if (v66 == CFDictionaryGetTypeID())
                                {
                                  v67 = CreateIntValueFromField(v65, v26);
                                  if (v67)
                                  {
                                    v68 = v67;
                                    CFDictionarySetValue(v28, v26, v67);
                                    CFRelease(v68);
                                  }
                                  v69 = CreateIntValueFromField(v65, CFSTR("AngleInfoYaw"));
                                  if (v69)
                                  {
                                    v70 = v69;
                                    CFDictionarySetValue(v28, CFSTR("AngleInfoYaw"), v69);
                                    CFRelease(v70);
                                  }
                                  v71 = CreateIntValueFromField(v65, CFSTR("AngleInfoRoll"));
                                  if (v71)
                                  {
                                    v72 = v71;
                                    CFDictionarySetValue(v28, CFSTR("AngleInfoRoll"), v71);
                                    CFRelease(v72);
                                  }
                                  v73 = CreateIntValueFromField(v65, CFSTR("ConfidenceLevel"));
                                  if (v73)
                                  {
                                    v74 = v73;
                                    CFDictionarySetValue(v28, CFSTR("ConfidenceLevel"), v73);
                                    CFRelease(v74);
                                  }
                                  v75 = CreateIntValueFromField(v65, CFSTR("FaceID"));
                                  if (v75)
                                  {
                                    v76 = v75;
                                    CFDictionarySetValue(v28, CFSTR("FaceID"), v75);
                                    CFRelease(v76);
                                  }
                                }
                              }
                            }
                          }
                          v22 = v81 + 1;
                        }
                        while (Count != v81 + 1);
                        return v78;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return Mutable;
}

uint64_t CreateIntFromXMPFlashStruct(const void *a1)
{
  CFTypeID v2;
  const void *Value;
  const __CFString *DefaultString;
  uint64_t v5;
  const void *v6;
  const __CFString *v7;
  const void *v8;
  const __CFString *v9;
  const void *v10;
  const __CFString *v11;
  const void *v12;
  const __CFString *v13;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (v2 != CFDictionaryGetTypeID())
    return 0;
  Value = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("Fired"));
  DefaultString = (const __CFString *)CGImageMetadataGetDefaultString(Value);
  if (DefaultString)
    v5 = CFStringCompare(DefaultString, CFSTR("True"), 1uLL) == kCFCompareEqualTo;
  else
    v5 = 0;
  v6 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("Return"));
  v7 = (const __CFString *)CGImageMetadataGetDefaultString(v6);
  if (v7)
    v5 = v5 & 0xFFFFFFF9 | (2 * (CFStringGetIntValue(v7) & 3u));
  v8 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("Mode"));
  v9 = (const __CFString *)CGImageMetadataGetDefaultString(v8);
  if (v9)
    v5 = v5 & 0xFFFFFFE7 | (8 * (CFStringGetIntValue(v9) & 3u));
  v10 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("Function"));
  v11 = (const __CFString *)CGImageMetadataGetDefaultString(v10);
  if (v11)
  {
    if (CFStringCompare(v11, CFSTR("True"), 1uLL))
      v5 = v5;
    else
      v5 = v5 | 0x20;
  }
  v12 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("RedEyeMode"));
  v13 = (const __CFString *)CGImageMetadataGetDefaultString(v12);
  if (v13)
  {
    if (CFStringCompare(v13, CFSTR("True"), 1uLL))
      return v5;
    else
      return v5 | 0x40;
  }
  return v5;
}

CFStringRef CreateGPSDateStringWithXMPDateTimeString(const __CFString *a1)
{
  int DateTimeStructFromXMPDateTimeString;
  CFStringRef result;
  tm v3;
  char __str[16];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  memset(__str, 0, 11);
  memset(&v3, 0, sizeof(v3));
  DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v3, 0, 0);
  result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    snprintf(__str, 0xBuLL, "%04d:%02d:%02d", v3.tm_year + 1900, v3.tm_mon + 1, v3.tm_mday);
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __str, 0x600u);
  }
  return result;
}

CFStringRef CreateGPSTimeStringWithXMPDateTimeString(const __CFString *a1)
{
  int DateTimeStructFromXMPDateTimeString;
  CFStringRef result;
  tm v3;
  char __str[8];
  char v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  *(_QWORD *)__str = 0;
  memset(&v3, 0, sizeof(v3));
  DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v3, 0, 0);
  result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    snprintf(__str, 9uLL, "%02d:%02d:%02d", v3.tm_hour, v3.tm_min, v3.tm_sec);
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __str, 0x600u);
  }
  return result;
}

uint64_t GetLegacyGPSFromXMPGPSCoordinate(void *a1, double *a2, _BYTE *a3)
{
  char *UTF8String;
  int v6;
  char v7;
  BOOL v8;
  uint64_t v9;
  int v10;
  int v11;
  __int16 v13;
  int v14;
  double v15;
  uint64_t v16;
  _QWORD v17[3];

  IIOString::IIOString((IIOString *)v17, a1);
  UTF8String = (char *)IIOString::createUTF8String((IIOString *)v17);
  IIOString::~IIOString((IIOString *)v17);
  v16 = 0;
  v17[0] = 0;
  v15 = 0.0;
  v14 = 0;
  v13 = 0;
  if (UTF8String)
  {
    v6 = sscanf(UTF8String, "%d,%2d,%2d%1[NSEW]", (char *)&v16 + 4, &v16, &v14, &v13);
    if (v6 <= 2)
    {
      v10 = sscanf(UTF8String, "%d,%lf%1[NSEW]", (char *)&v16 + 4, &v15, &v13);
      if (v10 < 2)
      {
        v11 = sscanf(UTF8String, "%lf", v17);
        v9 = 0;
        if (!a2 || v11 != 1)
          goto LABEL_16;
        v7 = 0;
        *a2 = *(double *)v17;
        goto LABEL_15;
      }
      if (a2)
      {
        *a2 = v15 / 60.0 + (double)SHIDWORD(v16);
        v7 = v13;
        v8 = v10 == 3;
LABEL_9:
        if (!v8)
          v7 = 0;
LABEL_15:
        *a3 = v7;
        v9 = 1;
        goto LABEL_16;
      }
    }
    else if (a2)
    {
      *a2 = (double)(int)v16 / 60.0 + (double)SHIDWORD(v16) + (double)v14 / 3600.0;
      v7 = v13;
      v8 = v6 == 4;
      goto LABEL_9;
    }
    v9 = 0;
LABEL_16:
    free(UTF8String);
    return v9;
  }
  return 0;
}

void sub_18803DBD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFArrayRef CreateGPSVersionArrayFromString(const __CFString *a1)
{
  CFTypeID v2;
  const __CFAllocator *v3;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const __CFString *ValueAtIndex;
  CFNumberRef v10;
  CFArrayRef v11;
  unsigned __int8 *UTF8String;
  CFIndex Length;
  CFIndex v14;
  CFIndex v15;
  CFNumberRef v16;
  uint64_t i;
  const void *v18;
  _DWORD valuePtr[6];
  void *values[2];
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)values = 0u;
  v22 = 0u;
  if (!a1
    || (v2 = CFGetTypeID(a1), v2 != CFStringGetTypeID())
    || (v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00],
        (ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, CFSTR("."))) == 0))
  {
LABEL_23:
    v11 = 0;
    goto LABEL_24;
  }
  v5 = ArrayBySeparatingStrings;
  Count = CFArrayGetCount(ArrayBySeparatingStrings);
  v7 = Count;
  if (Count >= 2)
  {
    v8 = 0;
    while (1)
    {
      valuePtr[0] = 0;
      if (v7 > v8)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, v8);
        valuePtr[0] = CFStringGetIntValue(ValueAtIndex);
      }
      v10 = CFNumberCreate(v3, kCFNumberIntType, valuePtr);
      values[v8] = v10;
      if (!v10)
        goto LABEL_23;
      if (++v8 == 4)
      {
        v11 = CFArrayCreate(v3, (const void **)values, 4, MEMORY[0x1E0C9B378]);
        goto LABEL_30;
      }
    }
  }
  if (Count == 1)
  {
    IIOString::IIOString((IIOString *)valuePtr, a1);
    UTF8String = (unsigned __int8 *)IIOString::createUTF8String((IIOString *)valuePtr);
    IIOString::~IIOString((IIOString *)valuePtr);
    Length = CFStringGetLength(a1);
    if (UTF8String)
    {
      v14 = Length;
      v15 = 0;
      while (1)
      {
        if (v14 <= v15)
        {
          valuePtr[0] = 0;
          v16 = CFNumberCreate(v3, kCFNumberIntType, valuePtr);
        }
        else
        {
          if (UTF8String[v15] - 48 >= 0xA)
          {
            v16 = (CFNumberRef)values[v15];
            goto LABEL_20;
          }
          valuePtr[0] = UTF8String[v15] - 48;
          v16 = CFNumberCreate(v3, kCFNumberIntType, valuePtr);
        }
        values[v15] = v16;
LABEL_20:
        if (!v16)
          goto LABEL_23;
        if (++v15 == 4)
        {
          v11 = CFArrayCreate(v3, (const void **)values, 4, MEMORY[0x1E0C9B378]);
          free(UTF8String);
          goto LABEL_30;
        }
      }
    }
  }
  v11 = 0;
LABEL_30:
  CFRelease(v5);
LABEL_24:
  for (i = 0; i != 4; ++i)
  {
    v18 = values[i];
    if (v18)
      CFRelease(v18);
  }
  return v11;
}

void sub_18803DE24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFDataRef CGImageMetadataCreateEXIFData(void *a1)
{
  CFTypeID v2;
  IIODictionary *v3;
  IIODictionary *v4;
  char *ExifBufferFromPropertiesJPEG;
  char *v6;
  CFDataRef v7;
  CFIndex length;

  length = 0;
  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (v2 != CGImageMetadataGetTypeID())
    return 0;
  v3 = (IIODictionary *)CGImagePropertiesCreateFromMetadata((const __CFDictionary **)a1);
  if (!v3)
    return 0;
  v4 = v3;
  ExifBufferFromPropertiesJPEG = CreateExifBufferFromPropertiesJPEG(v3, 0, 0, 0, 0, CFSTR("public.jpeg"), (unint64_t *)&length);
  v6 = ExifBufferFromPropertiesJPEG;
  if (!length)
  {
    v7 = 0;
    if (!ExifBufferFromPropertiesJPEG)
      goto LABEL_7;
    goto LABEL_6;
  }
  v7 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)ExifBufferFromPropertiesJPEG, length);
  if (v6)
LABEL_6:
    free(v6);
LABEL_7:
  (*(void (**)(IIODictionary *))(*(_QWORD *)v4 + 8))(v4);
  return v7;
}

const __CFData *CGImageMetadataCreateXMPWithEXIFFiltered(const CGImageMetadata *a1)
{
  CFDictionaryRef *v2;
  CFDictionaryRef *v3;
  const __CFData *XMPData;

  kdebug_trace();
  v2 = CGImageMetadataCreateWithEXIFFiltered(a1, 0);
  if (v2)
  {
    v3 = v2;
    XMPData = CGImageMetadataCreateXMPData((CGImageMetadataRef)v2, 0);
    CFRelease(v3);
    if (XMPData)
      CFDataGetLength(XMPData);
  }
  else
  {
    XMPData = 0;
  }
  kdebug_trace();
  return XMPData;
}

CFDictionaryRef *CGImageMetadataCreateWithEXIFFiltered(const CGImageMetadata *a1, int a2)
{
  CFTypeID v4;
  CGMutableImageMetadataRef MutableCopy;
  CFDictionaryRef *v6;
  CGImageMetadataTag *v7;
  CGImageMetadataTag *v8;
  CGImageMetadataTag *v9;
  CGImageMetadataTag *v10;
  CGImageMetadataTag *v11;
  CGImageMetadataTag *v12;
  CGImageMetadataTag *v13;
  uint64_t Source;
  const void *v15;
  CGImageMetadataTag *v16;
  CGImageMetadataTag *v17;
  CGImageMetadataTag *v18;
  CFTypeID v19;
  BOOL v20;
  const void *v22;
  CGImageMetadataTag *v23;
  CGImageMetadataTag *v24;
  CGImageMetadataTag *v25;
  CFTypeID v26;
  BOOL v27;
  CGImageMetadataTag *v28;
  CGImageMetadataTag *v29;
  uint64_t v30;
  _QWORD block[5];

  if (!a1)
    return 0;
  v4 = CFGetTypeID(a1);
  if (v4 != CGImageMetadataGetTypeID())
    return 0;
  MutableCopy = CGImageMetadataCreateMutableCopy(a1);
  v6 = (CFDictionaryRef *)MutableCopy;
  if (MutableCopy)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZL37CGImageMetadataCreateWithEXIFFilteredPK15CGImageMetadatab_block_invoke;
    block[3] = &__block_descriptor_tmp_344;
    block[4] = MutableCopy;
    CGImageMetadataEnumerateTagsUsingBlock(a1, 0, 0, block);
    v7 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, CFSTR("dc:description"));
    v8 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, CFSTR("dc:rights"));
    v9 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, CFSTR("dc:creator"));
    v10 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, CFSTR("xmp:CreatorTool"));
    v11 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, CFSTR("photoshop:DateCreated"));
    v12 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, CFSTR("xmp:CreateDate"));
    v13 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, CFSTR("xmp:ModifyDate"));
    Source = CGImageSourceGetSource((uint64_t)v7);
    v30 = CGImageSourceGetSource((uint64_t)v8);
    if (v7)
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("dc:description"));
    if (v8)
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("dc:rights"));
    if (v9)
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("dc:creator"));
    if (v10)
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("xmp:CreatorTool"));
    if (v11)
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("photoshop:DateCreated"));
    if (v12)
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("xmp:CreateDate"));
    if (v13)
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("xmp:ModifyDate"));
    if (v7 && (v15 = *(const void **)(Source + 48)) != 0)
    {
      v28 = v12;
      v16 = v11;
      v17 = v10;
      v18 = v9;
      v19 = CFGetTypeID(v15);
      v20 = v19 != CFArrayGetTypeID() || CFArrayGetCount(*(CFArrayRef *)(Source + 48)) < 2;
      v9 = v18;
      v10 = v17;
      v11 = v16;
      v12 = v28;
      if (v8)
      {
LABEL_28:
        v22 = *(const void **)(v30 + 48);
        if (v22)
        {
          v29 = v12;
          v23 = v11;
          v24 = v10;
          v25 = v9;
          v26 = CFGetTypeID(v22);
          if (v26 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)(v30 + 48)) >= 2)
            v20 = 0;
          v9 = v25;
          v10 = v24;
          v11 = v23;
          v12 = v29;
        }
      }
    }
    else
    {
      v20 = 1;
      if (v8)
        goto LABEL_28;
    }
    v27 = CFDictionaryGetCount(v6[3]) < 1 && v20;
    if (a2
      && (unint64_t)v7 | (unint64_t)v8 | (unint64_t)v9 | (unint64_t)v10 | (unint64_t)v11 | (unint64_t)v12 | (unint64_t)v13)
    {
      v27 = 0;
    }
    if (v27)
    {
      CFRelease(v6);
      v6 = 0;
    }
    else
    {
      if (v7)
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("dc:description"), v7);
      if (v8)
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("dc:rights"), v8);
      if (v9)
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("dc:creator"), v9);
      if (v10)
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("xmp:CreatorTool"), v10);
      if (v11)
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("photoshop:DateCreated"), v11);
      if (v12)
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("xmp:CreateDate"), v12);
      if (v13)
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, CFSTR("xmp:ModifyDate"), v13);
    }
    if (v7)
      CFRelease(v7);
    if (v8)
      CFRelease(v8);
    if (v9)
      CFRelease(v9);
    if (v10)
      CFRelease(v10);
    if (v11)
      CFRelease(v11);
    if (v12)
      CFRelease(v12);
    if (v13)
      CFRelease(v13);
  }
  return v6;
}

CFDictionaryRef *CGImageMetadataCreateExtendedXMPWithEXIFFiltered(const CGImageMetadata *a1, CFDataRef *a2, CFDataRef *a3, CFDataRef *a4, int a5)
{
  CFDictionaryRef *result;
  CFDictionaryRef *v9;
  _BOOL8 SerializedDataAndExtendedData;

  result = CGImageMetadataCreateWithEXIFFiltered(a1, a5);
  if (result)
  {
    v9 = result;
    SerializedDataAndExtendedData = CGImageMetadataCreateSerializedDataAndExtendedData(result, a2, a3, a4);
    CFRelease(v9);
    return (CFDictionaryRef *)SerializedDataAndExtendedData;
  }
  return result;
}

BOOL CGImageMetadataCreateSerializedDataAndExtendedData(CFDictionaryRef *a1, CFDataRef *a2, CFDataRef *a3, CFDataRef *a4)
{
  _BOOL8 v4;
  const __CFAllocator *v8;
  CFDataRef v9;
  CFIndex v11;
  CFIndex v12;
  CFIndex length;
  UInt8 *v14;
  UInt8 *v15;
  UInt8 *bytes;

  v15 = 0;
  bytes = 0;
  length = 0;
  v14 = 0;
  v11 = 0;
  v12 = 0;
  v4 = a1 != 0;
  if (a1)
  {
    SerializeMetadataForJPEGXMP(a1, (char **)&bytes, &length, (char **)&v15, &v12, (char **)&v14, &v11);
    if (!bytes)
    {
      v4 = 0;
      goto LABEL_13;
    }
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *a2 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, length);
    if (v15 && v12 > 1)
    {
      v9 = CFDataCreate(v8, v15, v12);
      *a3 = v9;
      if (!v9)
        goto LABEL_11;
    }
    else if (!*a3)
    {
      goto LABEL_11;
    }
    if (v14 && v11 >= 2)
      *a4 = CFDataCreate(v8, v14, v11);
  }
LABEL_11:
  if (bytes)
    free(bytes);
LABEL_13:
  if (v15)
    free(v15);
  if (v14)
    free(v14);
  return v4;
}

void CGImageMetadataRemoveGPS(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[32];

  v2 = 0;
  v3[31] = *MEMORY[0x1E0C80C00];
  v3[0] = CFSTR("GPSAltitude");
  v3[1] = CFSTR("GPSAltitudeRef");
  v3[2] = CFSTR("GPSAreaInformation");
  v3[3] = CFSTR("GPSDestBearing");
  v3[4] = CFSTR("GPSDestBearingRef");
  v3[5] = CFSTR("GPSDestDistance");
  v3[6] = CFSTR("GPSDestDistanceRef");
  v3[7] = CFSTR("GPSDestLatitude");
  v3[8] = CFSTR("GPSDestLatitudeRef");
  v3[9] = CFSTR("GPSDestLongitude");
  v3[10] = CFSTR("GPSDestLongitudeRef");
  v3[11] = CFSTR("GPSDifferential");
  v3[12] = CFSTR("GPSHPositioningError");
  v3[13] = CFSTR("GPSDOP");
  v3[14] = CFSTR("GPSImgDirection");
  v3[15] = CFSTR("GPSImgDirectionRef");
  v3[16] = CFSTR("GPSLatitude");
  v3[17] = CFSTR("GPSLatitudeRef");
  v3[18] = CFSTR("GPSLongitude");
  v3[19] = CFSTR("GPSLongitudeRef");
  v3[20] = CFSTR("GPSMapDatum");
  v3[21] = CFSTR("GPSMeasureMode");
  v3[22] = CFSTR("GPSProcessingMethod");
  v3[23] = CFSTR("GPSSatellites");
  v3[24] = CFSTR("GPSSpeed");
  v3[25] = CFSTR("GPSSpeedRef");
  v3[26] = CFSTR("GPSStatus");
  v3[27] = CFSTR("GPSTimeStamp");
  v3[28] = CFSTR("GPSTrack");
  v3[29] = CFSTR("GPSTrackRef");
  v3[30] = CFSTR("GPSVersionID");
  do
    CGImageMetadataRemoveTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), v3[v2++]);
  while (v2 != 31);
}

void CGImageMetadataRemoveTopLevelTag(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD key[3];

  if (a1 && a2)
  {
    if (a3)
    {
      key[1] = a3;
      key[2] = 0;
      key[0] = a2;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), key);
    }
  }
}

__CFDictionary *CreateXMPFlashStructFromInt(unsigned int a1)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  __CFString *v4;
  CGImageMetadataTagRef v5;
  CGImageMetadataTagRef v6;
  CFStringRef v7;
  const void *v8;
  CGImageMetadataTagRef v9;
  CGImageMetadataTagRef v10;
  CFStringRef v11;
  CGImageMetadataTagRef v12;
  CGImageMetadataTagRef v13;
  const __CFString *v14;
  CGImageMetadataTagRef v15;
  CGImageMetadataTagRef v16;
  __CFString *v17;
  CGImageMetadataTagRef v18;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v4 = (a1 & 1) != 0 ? CFSTR("True") : CFSTR("False");
    v5 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/exif/1.0/"), CFSTR("exif"), CFSTR("Fired"), kCGImageMetadataTypeString, v4);
    if (v5)
    {
      v6 = v5;
      CFDictionarySetValue(Mutable, CFSTR("Fired"), v5);
      CFRelease(v6);
      v7 = CFStringCreateWithFormat(v2, 0, CFSTR("%d"), (a1 >> 1) & 3);
      if (v7)
      {
        v8 = v7;
        v9 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/exif/1.0/"), CFSTR("exif"), CFSTR("Return"), kCGImageMetadataTypeString, v7);
        if (!v9)
          goto LABEL_19;
        v10 = v9;
        CFDictionarySetValue(Mutable, CFSTR("Return"), v9);
        CFRelease(v10);
        CFRelease(v8);
        v11 = CFStringCreateWithFormat(v2, 0, CFSTR("%d"), (a1 >> 3) & 3);
        if (!v11)
          return Mutable;
        v8 = v11;
        v12 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/exif/1.0/"), CFSTR("exif"), CFSTR("Mode"), kCGImageMetadataTypeString, v11);
        if (!v12)
        {
LABEL_19:
          CFRelease(v8);
          return Mutable;
        }
        v13 = v12;
        CFDictionarySetValue(Mutable, CFSTR("Mode"), v12);
        CFRelease(v13);
        CFRelease(v8);
        if ((a1 & 0x20) != 0)
          v14 = CFSTR("True");
        else
          v14 = CFSTR("False");
        v15 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/exif/1.0/"), CFSTR("exif"), CFSTR("Function"), kCGImageMetadataTypeString, v14);
        if (v15)
        {
          v16 = v15;
          CFDictionarySetValue(Mutable, CFSTR("Function"), v15);
          CFRelease(v16);
          v17 = (a1 & 0x40) != 0 ? CFSTR("True") : CFSTR("False");
          v18 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/exif/1.0/"), CFSTR("exif"), CFSTR("RedEyeMode"), kCGImageMetadataTypeString, v17);
          if (v18)
          {
            v8 = v18;
            CFDictionarySetValue(Mutable, CFSTR("RedEyeMode"), v18);
            goto LABEL_19;
          }
        }
      }
    }
  }
  return Mutable;
}

void CGImageMetadataCreateAndLogUTF8Error(const char *a1, int a2, int a3, char *a4, CFErrorRef *a5)
{
  const __CFAllocator *v8;
  __CFString *v9;
  __CFString *v10;
  void *v11;
  void *userInfoValues;
  void *userInfoKeys[2];

  userInfoKeys[1] = *(void **)MEMORY[0x1E0C80C00];
  LogError(a1, a2, a4);
  if (a5)
  {
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v9 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a4, 0x8000100u);
    if (v9)
    {
      v10 = v9;
      v11 = (void *)*MEMORY[0x1E0C9AFB0];
      userInfoValues = v9;
      userInfoKeys[0] = v11;
      *a5 = CFErrorCreateWithUserInfoKeysAndValues(v8, CFSTR("kCFErrorDomainCGImageMetadata"), a3, (const void *const *)userInfoKeys, (const void *const *)&userInfoValues, 1);
      CFRelease(v10);
    }
  }
}

void CGImageMetadataCreateAndLogError(const char *a1, int a2, void *a3, CFErrorRef *a4)
{
  char *UTF8String;
  void *userInfoKeys[3];
  void *userInfoValues[2];

  userInfoValues[1] = *(void **)MEMORY[0x1E0C80C00];
  IIOString::IIOString((IIOString *)userInfoKeys, a3);
  UTF8String = (char *)IIOString::createUTF8String((IIOString *)userInfoKeys);
  IIOString::~IIOString((IIOString *)userInfoKeys);
  if (UTF8String)
  {
    LogError(a1, 0, UTF8String);
    free(UTF8String);
  }
  if (a4)
  {
    userInfoKeys[0] = *(void **)MEMORY[0x1E0C9AFB0];
    userInfoValues[0] = a3;
    *a4 = CFErrorCreateWithUserInfoKeysAndValues((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("kCFErrorDomainCGImageMetadata"), a2, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, 1);
  }
}

void sub_18803EBF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFStringRef CreateXMPDateTimeWithXMPOrExifDateTimeString(const __CFString *a1)
{
  int DateTimeStructFromXMPDateTimeString;
  CFStringRef result;
  uint64_t v3;
  tm v4;
  BOOL v5[2];

  *(_WORD *)v5 = 0;
  memset(&v4, 0, sizeof(v4));
  DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v4, &v5[1], v5);
  result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    if (v5[1])
    {
      if (v5[0])
      {
        LODWORD(v3) = v4.tm_gmtoff % 3600 / 60;
        if ((int)v3 >= 0)
          v3 = v3;
        else
          v3 = (v4.tm_gmtoff % 3600 / -60);
        return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02dT%02d:%02d:%02d%+03d:%02d"), (v4.tm_year + 1900), (v4.tm_mon + 1), v4.tm_mday, v4.tm_hour, v4.tm_min, v4.tm_sec, v4.tm_gmtoff / 3600, v3);
      }
      else
      {
        return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02dT%02d:%02d:%02d"), (v4.tm_year + 1900), (v4.tm_mon + 1), v4.tm_mday, v4.tm_hour, v4.tm_min, v4.tm_sec);
      }
    }
    else
    {
      return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02d"), (v4.tm_year + 1900), (v4.tm_mon + 1), v4.tm_mday);
    }
  }
  return result;
}

CFStringRef CreateXMPDateFromEXIFGPSDateAndTime(const __CFString *a1, const __CFString *a2)
{
  CFTypeID v4;
  CFTypeID TypeID;
  CFStringRef v6;
  CFTypeID v7;
  CFIndex v8;
  char *v9;
  char *v10;
  CFIndex v11;
  char *v12;
  char *v13;
  size_t v14;
  char *__s;
  double v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;

  v19 = 0;
  v20 = 0;
  v18 = 0;
  v17 = 0.0;
  if (!a1)
    return 0;
  v4 = CFGetTypeID(a1);
  TypeID = CFStringGetTypeID();
  v6 = 0;
  if (a2 && v4 == TypeID)
  {
    v7 = CFGetTypeID(a2);
    if (v7 == CFStringGetTypeID())
    {
      v8 = CFStringGetLength(a1) + 1;
      v9 = (char *)malloc_type_malloc(v8, 0xCC34E93AuLL);
      if (v9)
      {
        v10 = v9;
        if (!CFStringGetCString(a1, v9, v8, 0x600u)
          || sscanf(v10, "%04d:%02d:%02d", (char *)&v20 + 4, &v20, (char *)&v19 + 4) != 3)
        {
          goto LABEL_18;
        }
        v11 = CFStringGetLength(a2) + 1;
        v12 = (char *)reallocf(v10, v11);
        if (v12)
        {
          v10 = v12;
          CFStringGetCString(a2, v12, v11, 0x600u);
          if (sscanf(v10, "%02d:%02d:%lf", &v19, &v18, &v17) == 3)
          {
            if (v17 - (double)(int)v17 <= 1.0e-10)
            {
              v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02dT%02d:%02d:%02d+0000"), HIDWORD(v20), v20, HIDWORD(v19), v19, v18, (int)v17);
              goto LABEL_19;
            }
            __s = 0;
            asprintf(&__s, "%012.9f", v17);
            v13 = __s;
            if (__s)
            {
              v14 = strlen(__s) - 1;
              if (v14 >= 4)
              {
                while (1)
                {
                  v13 = __s;
                  if (__s[v14] != 48)
                    break;
                  __s[v14--] = 0;
                  if (v14 <= 3)
                  {
                    v13 = __s;
                    break;
                  }
                }
              }
              v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02dT%02d:%02d:%s+0000"), HIDWORD(v20), v20, HIDWORD(v19), v19, v18, v13);
              free(__s);
              goto LABEL_19;
            }
          }
LABEL_18:
          v6 = 0;
LABEL_19:
          free(v10);
          return v6;
        }
      }
    }
    return 0;
  }
  return v6;
}

CFStringRef CreateIPTCDateFromExifDateTime(void *a1)
{
  IIOString *v1;
  const char *v2;
  CFStringRef v3;
  _QWORD v5[3];

  if (!a1)
    return 0;
  memset(v5, 0, sizeof(v5));
  v1 = IIOString::IIOString((IIOString *)v5, a1);
  v2 = (const char *)IIOString::utf8String(v1);
  if (strlen(v2) == 19)
    v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%c%c%c%c%c%c%c%c"), *v2, v2[1], v2[2], v2[3], v2[5], v2[6], v2[8], v2[9]);
  else
    v3 = 0;
  IIOString::~IIOString((IIOString *)v5);
  return v3;
}

void sub_18803F05C(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIOString::~IIOString((IIOString *)(v1 - 40));
  _Unwind_Resume(a1);
}

CFStringRef CreateIPTCTimeFromExifDateTime(void *a1)
{
  IIOString *v1;
  const __CFString *v2;
  CFStringRef v3;
  _QWORD v5[3];

  if (!a1)
    return 0;
  memset(v5, 0, sizeof(v5));
  v1 = IIOString::IIOString((IIOString *)v5, a1);
  v2 = IIOString::utf8String(v1);
  if (strlen((const char *)v2) == 19)
    v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%c%c%c%c%c%c"), SBYTE3(v2->info), SBYTE4(v2->info), SBYTE6(v2->info), SHIBYTE(v2->info), SBYTE1(v2->data), SBYTE2(v2->data));
  else
    v3 = 0;
  IIOString::~IIOString((IIOString *)v5);
  return v3;
}

void sub_18803F11C(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIOString::~IIOString((IIOString *)(v1 - 40));
  _Unwind_Resume(a1);
}

CFStringRef CreateXMPDateFromXMPDateTimeAndSubsecTime(const __CFString *cf, uint64_t a2)
{
  CFStringRef result;
  int DateTimeStructFromXMPDateTimeString;
  uint64_t v6;
  BOOL v7[2];
  tm v8;

  result = 0;
  *(_WORD *)v7 = 0;
  if (cf)
  {
    if (a2)
    {
      memset(&v8, 0, sizeof(v8));
      DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(cf, &v8, &v7[1], v7);
      result = 0;
      if (DateTimeStructFromXMPDateTimeString)
      {
        if (v7[1])
        {
          if (v7[0])
          {
            LODWORD(v6) = v8.tm_gmtoff % 3600 / 60;
            if ((int)v6 >= 0)
              v6 = v6;
            else
              v6 = (v8.tm_gmtoff % 3600 / -60);
            return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02dT%02d:%02d:%02d.%@%+03d:%02d"), (v8.tm_year + 1900), (v8.tm_mon + 1), v8.tm_mday, v8.tm_hour, v8.tm_min, v8.tm_sec, a2, v8.tm_gmtoff / 3600, v6);
          }
          else
          {
            return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%04d-%02d-%02dT%02d:%02d:%02d.%@"), (v8.tm_year + 1900), (v8.tm_mon + 1), v8.tm_mday, v8.tm_hour, v8.tm_min, v8.tm_sec, a2);
          }
        }
      }
    }
  }
  return result;
}

CFNumberRef CreateIntValueFromField(const __CFDictionary *a1, const void *a2)
{
  CFNumberRef result;
  const __CFString *v3;
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  SInt32 valuePtr;

  result = (CFNumberRef)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    v3 = (const __CFString *)result;
    v4 = CFGetTypeID(result);
    if (v4 == CGImageMetadataTagGetTypeID())
    {
      v3 = *(const __CFString **)(CGImageSourceGetSource((uint64_t)v3) + 48);
      if (!v3)
        return 0;
    }
    else
    {
      v5 = CFGetTypeID(v3);
      if (v5 != CFStringGetTypeID())
        return 0;
    }
    v6 = CFGetTypeID(v3);
    if (v6 == CFStringGetTypeID())
    {
      valuePtr = CFStringGetIntValue(v3);
      return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
    }
    return 0;
  }
  return result;
}

CFNumberRef CreateFloatValueFromField(const __CFDictionary *a1, const void *a2)
{
  CFNumberRef result;
  const __CFString *v3;
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  double valuePtr;

  result = (CFNumberRef)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    v3 = (const __CFString *)result;
    v4 = CFGetTypeID(result);
    if (v4 == CGImageMetadataTagGetTypeID())
    {
      v3 = *(const __CFString **)(CGImageSourceGetSource((uint64_t)v3) + 48);
      if (!v3)
        return 0;
    }
    else
    {
      v5 = CFGetTypeID(v3);
      if (v5 != CFStringGetTypeID())
        return 0;
    }
    v6 = CFGetTypeID(v3);
    if (v6 == CFStringGetTypeID())
    {
      valuePtr = CFStringGetDoubleValue(v3);
      return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &valuePtr);
    }
    return 0;
  }
  return result;
}

void ___ZL24IIOXPCDecodeMetadataTagsP8IIOArrayP15CGImageMetadata_block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  CGImageMetadataTagRef v3;
  _QWORD v4[3];

  memset(v4, 0, sizeof(v4));
  IIODictionary::IIODictionary((IIODictionary *)v4, a2);
  v3 = IIOXPCDecodeCGImageMetadataTag((IIODictionary *)v4);
  if (v3)
  {
    CGImageMetadataAddTag(*(_QWORD *)(a1 + 32), v3);
    CFRelease(v3);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v4);
}

void sub_18803F434(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImageMetadataTagRef IIOXPCDecodeCGImageMetadataTag(IIODictionary *a1)
{
  const __CFString *ObjectForKey;
  const __CFString *v3;
  const __CFString *v4;
  CGImageMetadataType Uint32ForKey;
  const __CFDictionary *v6;
  CGImageMetadataTagRef v7;
  CFTypeID TypeID;
  CFTypeID v9;
  int v10;
  const __CFDictionary *v11;
  const __CFArray *v12;
  uint64_t Source;
  _QWORD v15[5];
  _QWORD v16[5];
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  void *v23;
  void (*v24)(uint64_t);
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a1, CFSTR("nameSpace"));
  v3 = (const __CFString *)IIODictionary::getObjectForKey(a1, CFSTR("prefix"));
  v4 = (const __CFString *)IIODictionary::getObjectForKey(a1, CFSTR("name"));
  Uint32ForKey = IIODictionary::getUint32ForKey(a1, CFSTR("metadataType"));
  v6 = IIODictionary::getObjectForKey(a1, CFSTR("value"));
  if (Uint32ForKey <= kCGImageMetadataTypeString)
  {
    v7 = CGImageMetadataTagCreate(ObjectForKey, v3, v4, Uint32ForKey, v6);
    if (!v7)
      return v7;
    goto LABEL_9;
  }
  TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(v6))
  {
    v20 = 0;
    v21 = &v20;
    v22 = 0x4002000000;
    v23 = __Block_byref_object_copy__1;
    v24 = __Block_byref_object_dispose__1;
    v26 = 0;
    v27 = 0;
    v25 = 0;
    IIOArray::IIOArray((IIOArray *)&v25);
    v17 = 0;
    v18 = 0;
    v19 = 0;
    IIOArray::IIOArray((IIOArray *)&v17, v6);
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 0x40000000;
    v16[2] = ___ZL30IIOXPCDecodeCGImageMetadataTagP13IIODictionary_block_invoke;
    v16[3] = &unk_1E1BC9FF8;
    v16[4] = &v20;
    IIOArray::enumerate((uint64_t)&v17, (uint64_t)v16);
    v7 = CGImageMetadataTagCreate(ObjectForKey, v3, v4, Uint32ForKey, (CFTypeRef)v21[6]);
    IIOArray::~IIOArray((IIOArray *)&v17);
    _Block_object_dispose(&v20, 8);
    IIOArray::~IIOArray((IIOArray *)&v25);
    if (!v7)
      return v7;
LABEL_9:
    v10 = IIODictionary::getUint32ForKey(a1, CFSTR("sourceType"));
    CGImageMetadataTagSetSource((uint64_t)v7, v10);
    v11 = IIODictionary::getObjectForKey(a1, CFSTR("qualifiers"));
    if (v11)
    {
      v12 = v11;
      Source = CGImageSourceGetSource((uint64_t)v7);
      if (Source)
        *(_QWORD *)(Source + 56) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v12);
    }
    return v7;
  }
  v9 = CFDictionaryGetTypeID();
  if (v9 != CFGetTypeID(v6))
    return 0;
  v20 = 0;
  v21 = &v20;
  v22 = 0x4002000000;
  v23 = __Block_byref_object_copy__254;
  v24 = __Block_byref_object_dispose__255;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v25);
  v17 = 0;
  v18 = 0;
  v19 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v17, v6);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 0x40000000;
  v15[2] = ___ZL30IIOXPCDecodeCGImageMetadataTagP13IIODictionary_block_invoke_256;
  v15[3] = &unk_1E1BCA020;
  v15[4] = &v20;
  IIODictionary::enumerate((uint64_t)&v17, v15);
  v7 = CGImageMetadataTagCreate(ObjectForKey, v3, v4, Uint32ForKey, (CFTypeRef)v21[6]);
  IIODictionary::~IIODictionary((IIODictionary *)&v17);
  _Block_object_dispose(&v20, 8);
  IIODictionary::~IIODictionary((IIODictionary *)&v25);
  if (v7)
    goto LABEL_9;
  return v7;
}

void sub_18803F750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  IIODictionary *v15;
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  IIODictionary::~IIODictionary(v15);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)(result + 40) = &off_1E1BB2B40;
  v2 = *(_QWORD *)(a2 + 48);
  *(_BYTE *)(result + 56) = *(_BYTE *)(a2 + 56);
  *(_QWORD *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  IIOArray::~IIOArray((IIOArray *)(a1 + 40));
}

void ___ZL30IIOXPCDecodeCGImageMetadataTagP13IIODictionary_block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  const void *v3;
  _QWORD v4[3];

  memset(v4, 0, sizeof(v4));
  IIODictionary::IIODictionary((IIODictionary *)v4, a2);
  v3 = (const void *)IIOXPCDecodeCGImageMetadataTag((IIODictionary *)v4);
  IIOArray::addObject((CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v3);
  CFRelease(v3);
  IIODictionary::~IIODictionary((IIODictionary *)v4);
}

void sub_18803F83C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

IIODictionary *__Block_byref_object_copy__254(uint64_t a1, uint64_t a2)
{
  return IIODictionary::IIODictionary((IIODictionary *)(a1 + 40), (const IIODictionary *)(a2 + 40));
}

void __Block_byref_object_dispose__255(uint64_t a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(a1 + 40));
}

void ___ZL30IIOXPCDecodeCGImageMetadataTagP13IIODictionary_block_invoke_256(uint64_t a1, const __CFString *a2, __CFDictionary *a3)
{
  const void *v5;
  _QWORD v6[3];

  memset(v6, 0, sizeof(v6));
  IIODictionary::IIODictionary((IIODictionary *)v6, a3);
  v5 = (const void *)IIOXPCDecodeCGImageMetadataTag((IIODictionary *)v6);
  IIODictionary::setObjectForKey((IIODictionary *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v5, a2);
  CFRelease(v5);
  IIODictionary::~IIODictionary((IIODictionary *)v6);
}

void sub_18803F8DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZL24IIOXPCEncodeMetadataTagsPK15CGImageMetadataP8IIOArray_block_invoke(uint64_t a1, uint64_t a2, CGImageMetadataTag *a3)
{
  IIOXPCEncodeMetadataTag(a3, *(CFMutableArrayRef **)(a1 + 32));
  return 1;
}

void IIOXPCEncodeMetadataTag(CGImageMetadataTag *a1, CFMutableArrayRef *a2)
{
  uint64_t Source;
  IIODictionary *v4;
  int v5;
  const __CFArray *v6;
  CFTypeID TypeID;
  CFTypeID v8;
  CFTypeID v9;
  CFStringRef v10;
  const char *v11;
  _QWORD v12[5];
  _QWORD v13[5];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  void *value;
  void *v20;
  void (*v21)(uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const void *v26;
  uint64_t v27;

  Source = CGImageSourceGetSource((uint64_t)a1);
  v25 = 0;
  v26 = 0;
  v27 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v25);
  IIODictionary::setObjectForKey(v4, *(const void **)(Source + 16), CFSTR("nameSpace"));
  IIODictionary::setObjectForKey((IIODictionary *)&v25, *(const void **)(Source + 24), CFSTR("prefix"));
  IIODictionary::setObjectForKey((IIODictionary *)&v25, *(const void **)(Source + 32), CFSTR("name"));
  IIODictionary::setObjectForKey((IIODictionary *)&v25, *(const void **)(Source + 56), CFSTR("qualifiers"));
  v5 = *(_DWORD *)(Source + 40);
  IIONumber::IIONumber((IIONumber *)&v17, v5);
  IIODictionary::setObjectForKey((IIODictionary *)&v25, value, CFSTR("metadataType"));
  IIONumber::~IIONumber((IIONumber *)&v17);
  IIONumber::IIONumber((IIONumber *)&v17, *(_DWORD *)(Source + 68));
  IIODictionary::setObjectForKey((IIODictionary *)&v25, value, CFSTR("sourceType"));
  IIONumber::~IIONumber((IIONumber *)&v17);
  v6 = *(const __CFArray **)(Source + 48);
  if (v5 > 1)
  {
    TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(v6))
    {
      v17 = 0;
      v18 = &v17;
      value = (void *)0x4002000000;
      v20 = __Block_byref_object_copy__1;
      v21 = __Block_byref_object_dispose__1;
      v23 = 0;
      v24 = 0;
      v22 = 0;
      IIOArray::IIOArray((IIOArray *)&v22);
      v14 = 0;
      v15 = 0;
      v16 = 0;
      IIOArray::IIOArray((IIOArray *)&v14, v6);
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 0x40000000;
      v13[2] = ___ZL23IIOXPCEncodeMetadataTagP18CGImageMetadataTagP8IIOArray_block_invoke;
      v13[3] = &unk_1E1BCA068;
      v13[4] = &v17;
      IIOArray::enumerate((uint64_t)&v14, (uint64_t)v13);
      IIODictionary::setObjectForKey((IIODictionary *)&v25, (const void *)v18[6], CFSTR("value"));
      IIOArray::~IIOArray((IIOArray *)&v14);
      _Block_object_dispose(&v17, 8);
      IIOArray::~IIOArray((IIOArray *)&v22);
    }
    else
    {
      v8 = CFDictionaryGetTypeID();
      if (v8 == CFGetTypeID(v6))
      {
        v17 = 0;
        v18 = &v17;
        value = (void *)0x4002000000;
        v20 = __Block_byref_object_copy__254;
        v21 = __Block_byref_object_dispose__255;
        v23 = 0;
        v24 = 0;
        v22 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v22);
        v14 = 0;
        v15 = 0;
        v16 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v14, v6);
        v12[0] = MEMORY[0x1E0C809B0];
        v12[1] = 0x40000000;
        v12[2] = ___ZL23IIOXPCEncodeMetadataTagP18CGImageMetadataTagP8IIOArray_block_invoke_2;
        v12[3] = &unk_1E1BCA090;
        v12[4] = &v17;
        IIODictionary::enumerate((uint64_t)&v14, v12);
        IIODictionary::setObjectForKey((IIODictionary *)&v25, (const void *)v18[6], CFSTR("value"));
        IIODictionary::~IIODictionary((IIODictionary *)&v14);
        _Block_object_dispose(&v17, 8);
        IIODictionary::~IIODictionary((IIODictionary *)&v22);
      }
      else
      {
        CFShow(v6);
        v9 = CFGetTypeID(v6);
        v10 = CFCopyTypeIDDescription(v9);
        IIOString::IIOString((IIOString *)&v17, v10);
        v11 = (const char *)IIOString::utf8String((IIOString *)&v17);
        LogError("IIOXPCEncodeMetadataTag", 125, "*** failed to serialize metadata = %s\n", v11);
        IIOString::~IIOString((IIOString *)&v17);
      }
    }
  }
  else
  {
    IIODictionary::setObjectForKey((IIODictionary *)&v25, v6, CFSTR("value"));
  }
  IIOArray::addObject(a2, v26);
  IIODictionary::~IIODictionary((IIODictionary *)&v25);
}

void sub_18803FC3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  IIODictionary *v16;
  uint64_t v17;
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  IIODictionary::~IIODictionary(v16);
  IIODictionary::~IIODictionary((IIODictionary *)(v17 - 56));
  _Unwind_Resume(a1);
}

void ___ZL23IIOXPCEncodeMetadataTagP18CGImageMetadataTagP8IIOArray_block_invoke(uint64_t a1, CGImageMetadataTag *a2)
{
  CFTypeID TypeID;
  CFTypeID v5;
  CFStringRef v6;
  const char *v7;
  _BYTE v8[24];

  TypeID = CGImageMetadataTagGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    IIOXPCEncodeMetadataTag(a2, (IIOArray *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
  }
  else
  {
    v5 = CFGetTypeID(a2);
    v6 = CFCopyTypeIDDescription(v5);
    IIOString::IIOString((IIOString *)v8, v6);
    v7 = (const char *)IIOString::utf8String((IIOString *)v8);
    LogError("IIOXPCEncodeMetadataTag_block_invoke", 97, "*** unexpected type in array: %s\n", v7);
    IIOString::~IIOString((IIOString *)v8);
  }
}

void sub_18803FD98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZL23IIOXPCEncodeMetadataTagP18CGImageMetadataTagP8IIOArray_block_invoke_2(uint64_t a1, const __CFString *a2, CGImageMetadataTag *a3)
{
  CFTypeID TypeID;
  uint64_t v7;
  const __CFArray *ObjectAtIndex;
  CFTypeID v9;
  CFStringRef v10;
  const char *v11;
  _BYTE v12[24];
  _QWORD v13[3];

  memset(v13, 0, sizeof(v13));
  IIOArray::IIOArray((IIOArray *)v13);
  TypeID = CGImageMetadataTagGetTypeID();
  if (TypeID == CFGetTypeID(a3))
  {
    IIOXPCEncodeMetadataTag(a3, (IIOArray *)v13);
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    ObjectAtIndex = IIOArray::getObjectAtIndex((IIOArray *)v13, 0);
    IIODictionary::setObjectForKey((IIODictionary *)(v7 + 40), ObjectAtIndex, a2);
  }
  else
  {
    v9 = CFGetTypeID(a3);
    v10 = CFCopyTypeIDDescription(v9);
    IIOString::IIOString((IIOString *)v12, v10);
    v11 = (const char *)IIOString::utf8String((IIOString *)v12);
    LogError("IIOXPCEncodeMetadataTag_block_invoke_2", 116, "*** unexpected type in dictionary: %s\n", v11);
    IIOString::~IIOString((IIOString *)v12);
  }
  IIOArray::~IIOArray((IIOArray *)v13);
}

void sub_18803FE8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  IIOString::~IIOString((IIOString *)va);
  IIOArray::~IIOArray((IIOArray *)va1);
  _Unwind_Resume(a1);
}

uint64_t ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke(uint64_t a1, void *a2)
{
  return addPropertiesFromMetadata(*(IIODictionary **)(a1 + 32), *(IIOArray **)(a1 + 40), a2, *(_DWORD *)(a1 + 48) + 1);
}

uint64_t ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke_2(uint64_t a1, void *a2)
{
  return addPropertiesFromMetadata(*(IIODictionary **)(a1 + 32), *(IIOArray **)(a1 + 40), a2, *(_DWORD *)(a1 + 48) + 1);
}

uint64_t ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke_3(uint64_t a1, uint64_t a2, const void *a3)
{
  return addPropertiesFromMetadata(*(IIODictionary **)(a1 + 32), *(IIOArray **)(a1 + 40), a3, *(_DWORD *)(a1 + 48) + 1);
}

uint64_t ___ZL37CGImageMetadataCreateWithEXIFFilteredPK15CGImageMetadatab_block_invoke(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  uint64_t Source;

  Source = CGImageSourceGetSource(a3);
  if (CFStringCompare(*(CFStringRef *)(Source + 24), CFSTR("exif"), 0) == kCFCompareEqualTo
    || CFStringCompare(*(CFStringRef *)(Source + 24), CFSTR("tiff"), 0) == kCFCompareEqualTo
    || CFStringCompare(*(CFStringRef *)(Source + 24), CFSTR("exifEX"), 0) == kCFCompareEqualTo)
  {
    CGImageMetadataRemoveTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 32), 0, a2);
  }
  return 1;
}

size_t myTIFFWriteProc(_QWORD *a1, void *a2, size_t a3)
{
  IIOImageWriteSession *v3;

  if (a1 && (v3 = (IIOImageWriteSession *)a1[3]) != 0)
    return IIOImageWriteSession::putBytes(v3, a2, a3);
  else
    return 0;
}

uint64_t IIOErrorHandler(_BYTE *a1, const char *a2, char *a3, char *a4)
{
  uint64_t result;

  result = (uint64_t)LogModuleWithArguments(a2, a3, a4);
  if (a2)
  {
    result = strcmp(a2, "ZIPDecode");
    if ((_DWORD)result)
    {
      result = strcmp(a2, "PackBitsDecode");
      if (a1 && !(_DWORD)result)
        goto LABEL_5;
    }
    else if (a1)
    {
LABEL_5:
      a1[32] = 1;
    }
  }
  if (!a3)
    return result;
  result = (uint64_t)strstr(a3, "Bad code word");
  if (result || (result = (uint64_t)strstr(a3, "Premature EOL at line")) != 0)
  {
    if (!a1)
      return result;
    goto LABEL_10;
  }
  result = (uint64_t)strstr(a3, "Invalid tile byte count");
  if (a1 && result)
LABEL_10:
    a1[32] = 1;
  return result;
}

void GlobalTIFFInfo::GlobalTIFFInfo(GlobalTIFFInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  UInt8 **v4;
  UInt8 **v5;
  __CFReadStream *v6;
  __CFReadStream *v7;
  CFIndex v8;
  CFIndex v9;
  uint64_t v10;
  UInt8 v11[4];
  UInt8 buffer;

  *(_QWORD *)this = &off_1E1BAE138;
  *((_BYTE *)this + 8) = 0;
  *((_OWORD *)this + 1) = 0u;
  v4 = (UInt8 **)((char *)this + 16);
  v5 = (UInt8 **)((char *)this + 40);
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  buffer = 0;
  *(_DWORD *)v11 = 0;
  v10 = 0;
  v6 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v7 = v6;
  if (v6)
  {
    if (CFReadStreamOpen(v6))
    {
      if (CFReadStreamRead(v7, &buffer, 1) == 1)
      {
        *((_BYTE *)this + 8) = buffer;
        if (CFReadStreamRead(v7, v11, 4) == 4)
        {
          if (!*(_DWORD *)v11
            || (std::vector<unsigned long long>::resize((uint64_t)v4, *(unsigned int *)v11),
                v8 = CFReadStreamRead(v7, *v4, 8 * *(unsigned int *)v11),
                v8 == 8 * *(unsigned int *)v11))
          {
            if (CFReadStreamRead(v7, v11, 4) == 4)
            {
              if (!*(_DWORD *)v11
                || (std::vector<unsigned long long>::resize((uint64_t)v5, *(unsigned int *)v11),
                    v9 = CFReadStreamRead(v7, *v5, 8 * *(unsigned int *)v11),
                    v9 == 8 * *(unsigned int *)v11))
              {
                if (CFReadStreamRead(v7, (UInt8 *)&v10, 8) == 8)
                {
                  *((_QWORD *)this + 8) = v10;
                  if (CFReadStreamRead(v7, (UInt8 *)&v10, 8) == 8)
                  {
                    *((_QWORD *)this + 9) = v10;
                    if (CFReadStreamRead(v7, &buffer, 1) == 1)
                      *((_BYTE *)this + 80) = buffer;
                  }
                }
              }
            }
          }
        }
      }
    }
    CFRelease(v7);
  }
}

void sub_188040234(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 48) = v5;
    operator delete(v5);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 24) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<unsigned long long>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<unsigned long long>::__append((char **)a1, a2 - v2);
  }
}

CFTypeRef GlobalTIFFInfo::createDataRepresentation(GlobalTIFFInfo *this)
{
  __CFWriteStream *v2;
  __CFWriteStream *v3;
  CFIndex v4;
  CFIndex v5;
  CFTypeRef v6;
  uint64_t v8;
  UInt8 v9[4];
  UInt8 buffer;

  v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (!v2)
    return 0;
  v3 = v2;
  buffer = 0;
  *(_DWORD *)v9 = 0;
  v8 = 0;
  if (!CFWriteStreamOpen(v2))
    goto LABEL_16;
  buffer = *((_BYTE *)this + 8);
  if (CFWriteStreamWrite(v3, &buffer, 1) != 1)
    goto LABEL_16;
  *(_DWORD *)v9 = (*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3;
  if (CFWriteStreamWrite(v3, v9, 4) != 4)
    goto LABEL_16;
  if (*(_DWORD *)v9)
  {
    v4 = CFWriteStreamWrite(v3, *((const UInt8 **)this + 2), 8 * *(unsigned int *)v9);
    if (v4 != 8 * *(unsigned int *)v9)
      goto LABEL_16;
  }
  if ((*(_DWORD *)v9 = (*((_QWORD *)this + 6) - *((_QWORD *)this + 5)) >> 3, CFWriteStreamWrite(v3, v9, 4) == 4)
    && (!*(_DWORD *)v9
     || (v5 = CFWriteStreamWrite(v3, *((const UInt8 **)this + 5), 8 * *(unsigned int *)v9),
         v5 == 8 * *(unsigned int *)v9))
    && (v8 = *((_QWORD *)this + 8), CFWriteStreamWrite(v3, (const UInt8 *)&v8, 8) == 8)
    && (v8 = *((_QWORD *)this + 9), CFWriteStreamWrite(v3, (const UInt8 *)&v8, 8) == 8)
    && (buffer = *((_BYTE *)this + 80), CFWriteStreamWrite(v3, &buffer, 1) == 1))
  {
    v6 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
  }
  else
  {
LABEL_16:
    v6 = 0;
  }
  CFRelease(v3);
  return v6;
}

void std::vector<unsigned long long>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 3);
    if (v10 >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 3;
    v12 = v5 - v8;
    if (v12 >> 2 > v10)
      v10 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v11];
    v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      v18 = *((_QWORD *)v7 - 1);
      v7 -= 8;
      *((_QWORD *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

uint64_t IIO_Reader_AI::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  PDFReadPlugin::PDFReadPlugin(v4, a2, v5);
  return v4;
}

void sub_1880405A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F62C0459);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AI::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  PDFReadPlugin::PDFReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_188040640(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F62C0459);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AI::updateSourceProperties(IIO_Reader_AI *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v12;

  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  v12 = IIO_ReaderHandler::readerForType(ReaderHandler, 1346651680);
  return (*(uint64_t (**)(IIO_Reader *, IIOImageReadSession *, IIODictionary *, IIODictionary *, IIODictionary *, CGImageSourceStatus *))(*(_QWORD *)v12 + 56))(v12, a2, a3, a4, a5, a6);
}

uint64_t IIO_Reader_AI::compareOptions(IIO_Reader_AI *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v6;

  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  v6 = IIO_ReaderHandler::readerForType(ReaderHandler, 1346651680);
  return (*(uint64_t (**)(IIO_Reader *, const __CFDictionary *, const __CFDictionary *))(*(_QWORD *)v6 + 80))(v6, a2, a3);
}

uint64_t IIO_Reader_AI::getImageCount(IIO_Reader_AI *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v10;

  if (a5)
    *a5 = 0;
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  v10 = IIO_ReaderHandler::readerForType(ReaderHandler, 1346651680);
  return (*(__int16 (**)(IIO_Reader *, IIOImageReadSession *, IIODictionary *, CGImageSourceStatus *, unsigned int *))(*(_QWORD *)v10 + 32))(v10, a2, a3, a4, a5);
}

uint64_t IIO_Reader_AI::hasCustomImageCountProc(IIO_Reader_AI *this)
{
  return 1;
}

uint64_t IIO_Reader_AI::hasCustomCompareOptionsProc(IIO_Reader_AI *this)
{
  return 1;
}

uint64_t IIO_Reader_AI::hasCustomSourcePropertiesProc(IIO_Reader_AI *this)
{
  return 1;
}

uint64_t LogL16fromY(int a1, long double a2)
{
  double v3;
  double v5;

  if (a2 >= 1.8371976e19)
    return 0x7FFFLL;
  if (a2 <= -1.8371976e19)
    return 0xFFFFLL;
  if (a2 <= 5.4136769e-20)
  {
    if (a2 >= -5.4136769e-20)
    {
      return 0;
    }
    else
    {
      v5 = (log(-a2) * 1.44269504 + 64.0) * 256.0;
      if (a1)
        v5 = v5 + (double)rand() * 4.65661288e-10 + -0.5;
      return (int)v5 | 0xFFFF8000;
    }
  }
  else
  {
    v3 = (log(a2) * 1.44269504 + 64.0) * 256.0;
    if (a1)
      v3 = v3 + (double)rand() * 4.65661288e-10 + -0.5;
    return (int)v3;
  }
}

float *XYZtoRGB24(float *result, char *a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  char v8;
  double v9;
  char v10;
  char v11;

  v2 = *result;
  v3 = result[1];
  v4 = result[2];
  v5 = v3 * -1.276 + v2 * 2.69 + v4 * -0.414;
  v6 = v3 * 1.978 + v2 * -1.022 + v4 * 0.044;
  v7 = v3 * -0.224 + v2 * 0.061;
  if (v5 <= 0.0)
  {
    v8 = 0;
  }
  else
  {
    v8 = vcvtd_n_s64_f64(sqrt(v5), 8uLL);
    if (v5 >= 1.0)
      v8 = -1;
  }
  v9 = v7 + v4 * 1.163;
  *a2 = v8;
  if (v6 <= 0.0)
  {
    v10 = 0;
  }
  else
  {
    v10 = vcvtd_n_s64_f64(sqrt(v6), 8uLL);
    if (v6 >= 1.0)
      v10 = -1;
  }
  a2[1] = v10;
  if (v9 <= 0.0)
  {
    v11 = 0;
  }
  else
  {
    v11 = vcvtd_n_s64_f64(sqrt(v9), 8uLL);
    if (v9 >= 1.0)
      v11 = -1;
  }
  a2[2] = v11;
  return result;
}

uint64_t LogL10fromY(int a1, long double a2)
{
  double v3;

  if (a2 >= 15.742)
    return 1023;
  if (a2 <= 0.00024283)
    return 0;
  v3 = (log(a2) * 1.44269504 + 12.0) * 64.0;
  if (a1)
    v3 = v3 + (double)rand() * 4.65661288e-10 + -0.5;
  return (int)v3;
}

uint64_t uv_encode(int a1, double a2, double a3)
{
  double v6;
  int v7;
  double v8;
  uint64_t v9;
  double v10;
  float *v11;

  if (a3 < 0.0169399995)
    return oog_encode(a2, a3);
  v6 = (a3 + -0.0169399995) * 285.714277;
  if (a1)
    v6 = v6 + (double)rand() * 4.65661288e-10 + -0.5;
  v7 = (int)v6;
  if ((int)v6 >= 163)
    return oog_encode(a2, a3);
  v8 = uv_row[2 * v7];
  if (a2 < v8)
    return oog_encode(a2, a3);
  v9 = v7;
  v10 = (a2 - v8) * 285.714277;
  if (a1)
    v10 = v10 + (double)rand() * 4.65661288e-10 + -0.5;
  v11 = &uv_row[2 * v9];
  if ((int)v10 >= *((__int16 *)v11 + 2))
    return oog_encode(a2, a3);
  else
    return (*((__int16 *)v11 + 3) + (int)v10);
}

uint64_t oog_encode(double a1, double a2)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  int v6;
  BOOL v7;
  int v8;
  double v9;
  __int16 *v10;
  double v11;
  int v12;
  double v13;
  uint64_t *v14;
  unint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  uint64_t *v23;
  int v24;
  unsigned int v25;
  int v26;
  unint64_t v27;
  unint64_t *v28;
  int v29;
  int v30;
  double v32;
  double __b[100];
  uint64_t v35;

  v2 = a1;
  v35 = *MEMORY[0x1E0C80C00];
  if ((oog_encode_initialized & 1) == 0)
  {
    v32 = a2;
    memset_pattern16(__b, &unk_18822D4B0, 0x320uLL);
    v3 = 162;
    do
    {
      v4 = v3;
      v5 = (char *)&uv_row + 8 * v3;
      v6 = *((__int16 *)v5 + 2) - 1;
      if (v4)
        v7 = v4 == 162;
      else
        v7 = 1;
      if (v7)
        v8 = 1;
      else
        v8 = *((__int16 *)v5 + 2) - 1;
      v9 = *(float *)v5;
      v10 = (__int16 *)(v5 + 6);
      do
      {
        v11 = atan2(((double)(int)v4 + 0.5) * 0.00350000011 + 0.0169399995 + -0.473684211, v9 + ((double)v6 + 0.5) * 0.00350000011 + -0.210526316)* 15.9154943+ 50.0;
        v12 = (int)v11;
        v13 = vabdd_f64(v11, (double)(int)v11 + 0.5);
        if (v13 < __b[v12])
        {
          oog_encode_oog_table[v12] = v6 + *v10;
          __b[v12] = v13;
        }
        v6 -= v8;
      }
      while (v6 >= 0);
      v3 = v4 - 1;
    }
    while (v4);
    v14 = &v35;
    v15 = &STACK[0x640];
    v16 = 99;
    v17 = 198;
    v18 = 100;
    v2 = a1;
    do
    {
      v19 = v16;
      v20 = v18 - 1;
      if (__b[v16] > 1.5)
      {
        v21 = 1;
        v22 = v18;
        v23 = v14;
        do
        {
          if (*(double *)&v23[-100 * (v22 / 0x64)] < 1.5)
            break;
          ++v21;
          ++v23;
          ++v22;
        }
        while (v21 != 50);
        v24 = v18 + 99;
        v25 = 1;
        v26 = -1;
        v27 = v17;
        v28 = v15;
        while (*(double *)&v28[-100 * (v27 / 0x64)] >= 1.5)
        {
          ++v25;
          --v28;
          --v27;
          if (--v26 == -50)
          {
            v25 = 50;
            break;
          }
        }
        v29 = v24 + v26;
        if (v21 >= v25)
          v30 = v29;
        else
          v30 = v21 + v20;
        oog_encode_oog_table[v19] = oog_encode_oog_table[v30 % 100];
      }
      v16 = v19 - 1;
      --v14;
      --v15;
      --v17;
      v18 = v20;
    }
    while (v19);
    oog_encode_initialized = 1;
    a2 = v32;
  }
  return oog_encode_oog_table[(int)(atan2(a2 + -0.473684211, v2 + -0.210526316) * 15.9154943 + 50.0)];
}

uint64_t uv_decode(double *a1, double *a2, unsigned int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  double v10;

  if (a3 > 0x3FA0)
    return 0xFFFFFFFFLL;
  v4 = 0;
  v5 = 163;
  while (1)
  {
    v6 = v4 + v5;
    v7 = (v4 + v5) >> 1;
    v8 = a3 - *((__int16 *)&uv_row + 4 * v7 + 3);
    if (v8 < 1)
      break;
    v4 = v6 >> 1;
LABEL_8:
    if (v5 - v4 <= 1)
    {
      v9 = v4;
      v10 = (double)(int)(a3 - *((__int16 *)&uv_row + 4 * v4 + 3)) + 0.5;
      v7 = v4;
      goto LABEL_11;
    }
  }
  if (v8 < 0)
  {
    v5 = v6 >> 1;
    goto LABEL_8;
  }
  v9 = (uint64_t)v6 >> 1;
  v10 = 0.5;
LABEL_11:
  v3 = 0;
  *a1 = *((float *)&uv_row + 2 * v9) + v10 * 0.00350000011;
  *a2 = ((double)v7 + 0.5) * 0.00350000011 + 0.0169399995;
  return v3;
}

void LogLuv24toXYZ(unsigned int a1, uint64_t a2)
{
  int v3;
  __int16 v4;
  double v5;
  double v6;
  int v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  float v13;
  double v14;
  double v15;

  v3 = (a1 >> 14) & 0x3FF;
  if (v3 && (v4 = a1, v5 = exp(((double)v3 + 0.5) * 0.0108304247 + -8.31776617), v5 > 0.0))
  {
    v6 = v5;
    v14 = 0.0;
    v15 = 0.0;
    v7 = uv_decode(&v15, &v14, v4 & 0x3FFF);
    v9 = v14;
    v8 = v15;
    if (v7 < 0)
    {
      v9 = 0.473684211;
      v8 = 0.210526316;
    }
    v10 = 1.0 / (v9 * -16.0 + v8 * 6.0 + 12.0);
    v11 = v8 * 9.0 * v10;
    v12 = v9 * 4.0 * v10;
    *(float *)&v10 = v6 * (v11 / v12);
    v13 = v6;
    *(_DWORD *)a2 = LODWORD(v10);
    *(float *)(a2 + 4) = v13;
    *(float *)&v11 = v6 * ((1.0 - v11 - v12) / v12);
    *(_DWORD *)(a2 + 8) = LODWORD(v11);
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(_QWORD *)a2 = 0;
  }
}

uint64_t LogLuv24fromXYZ(float *a1, int a2)
{
  int v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  int v10;

  v4 = LogL10fromY(a2, a1[1]);
  v5 = 0.473684211;
  v6 = 0.210526316;
  if (v4)
  {
    v7 = *a1;
    v8 = a1[1];
    v9 = v7 + v8 * 15.0 + a1[2] * 3.0;
    if (v9 > 0.0)
    {
      v6 = v7 * 4.0 / v9;
      v5 = v8 * 9.0 / v9;
    }
  }
  v10 = uv_encode(a2, v6, v5);
  if (v10 < 0)
    v10 = uv_encode(0, 0.210526316, 0.473684211);
  return v10 | (v4 << 14);
}

void LogLuv32toXYZ(int a1, uint64_t a2)
{
  int v3;
  __int16 v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  float v11;
  float v12;

  v3 = a1 >> 16;
  if (((a1 >> 16) & 0x7FFF) == 0)
    goto LABEL_6;
  v4 = a1;
  v5 = exp(((double)((a1 >> 16) & 0x7FFF) + 0.5) * 0.00270760617 + -44.3614196);
  if ((v3 & 0x8000) != 0)
    v5 = -v5;
  if (v5 > 0.0)
  {
    v6 = ((double)HIBYTE(v4) + 0.5) * 0.00243902439;
    v7 = ((double)v4 + 0.5) * 0.00243902439;
    v8 = 1.0 / (v7 * -16.0 + v6 * 6.0 + 12.0);
    v9 = v6 * 9.0 * v8;
    v10 = v7 * 4.0 * v8;
    *(float *)&v8 = v5 * (v9 / v10);
    v11 = v5;
    *(_DWORD *)a2 = LODWORD(v8);
    *(float *)(a2 + 4) = v11;
    v12 = v5 * ((1.0 - v9 - v10) / v10);
    *(float *)(a2 + 8) = v12;
  }
  else
  {
LABEL_6:
    *(_DWORD *)(a2 + 8) = 0;
    *(_QWORD *)a2 = 0;
  }
}

uint64_t LogLuv32fromXYZ(float *a1, int a2)
{
  int v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  unsigned int v11;
  double v12;
  unsigned int v13;
  int v14;

  v4 = LogL16fromY(a2, a1[1]);
  v5 = 0.210526316;
  v6 = 0.473684211;
  if (v4
    && (v7 = *a1, v8 = a1[1], v9 = v7 + v8 * 15.0 + a1[2] * 3.0, v9 > 0.0)
    && (v5 = v7 * 4.0 / v9, v6 = v8 * 9.0 / v9, v5 <= 0.0))
  {
    v11 = 0;
  }
  else
  {
    v10 = v5 * 410.0;
    if (a2)
      v10 = v10 + (double)rand() * 4.65661288e-10 + -0.5;
    v11 = (int)v10;
  }
  if (v6 <= 0.0)
  {
    v13 = 0;
  }
  else
  {
    v12 = v6 * 410.0;
    if (a2)
      v12 = v12 + (double)rand() * 4.65661288e-10 + -0.5;
    v13 = (int)v12;
  }
  if (v11 >= 0xFF)
    v14 = 255;
  else
    v14 = v11;
  if (v13 >= 0xFF)
    v13 = 255;
  return v13 | (v14 << 8) | (v4 << 16);
}

uint64_t TIFFInitSGILog(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  int8x16_t v18;
  char *v20;
  uint64_t v21;

  if (a2 >> 1 != 17338)
    TIFFInitSGILog_cold_1();
  if (_TIFFMergeFields(a1, LogLuvFields, 2, a4, a5, a6, a7, a8))
  {
    v16 = _TIFFmallocExt((_QWORD *)a1, 56, v10, v11, v12, v13, v14, v15);
    *(_QWORD *)(a1 + 1096) = v16;
    if (v16)
    {
      v17 = v16;
      _TIFFmemset(v16, 0, 0x38uLL);
      *((_DWORD *)v17 + 1) = -1;
      *((_DWORD *)v17 + 2) = a2 == 34677;
      v17[4] = _logLuvNop;
      *(_QWORD *)(a1 + 952) = LogLuvFixupTags;
      *(_QWORD *)(a1 + 960) = LogLuvSetupDecode;
      *(_QWORD *)(a1 + 1024) = LogLuvDecodeStrip;
      *(_QWORD *)(a1 + 1040) = LogLuvDecodeTile;
      *(_QWORD *)(a1 + 976) = LogLuvSetupEncode;
      *(_QWORD *)(a1 + 1032) = LogLuvEncodeStrip;
      *(_QWORD *)(a1 + 1048) = LogLuvEncodeTile;
      *(_QWORD *)(a1 + 1056) = LogLuvClose;
      *(_QWORD *)(a1 + 1072) = LogLuvCleanup;
      v18 = *(int8x16_t *)(a1 + 1280);
      *(_QWORD *)(a1 + 1288) = LogLuvVGetField;
      *(int8x16_t *)(v17 + 5) = vextq_s8(v18, v18, 8uLL);
      *(_QWORD *)(a1 + 1280) = LogLuvVSetField;
      return 1;
    }
    v21 = *(_QWORD *)a1;
    v20 = "%s: No space for LogLuv state block";
  }
  else
  {
    v20 = "Merging SGILog codec-specific tags failed";
  }
  TIFFErrorExtR(a1, "TIFFInitSGILog", v20, v11, v12, v13, v14, v15, v21);
  return 0;
}

uint64_t LogLuvFixupTags()
{
  return 1;
}

uint64_t LogLuvSetupDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  int v12;
  void *v13;
  int v14;
  int v15;

  v9 = *(_QWORD *)(a1 + 1096);
  *(_QWORD *)(a1 + 1248) = _TIFFNoPostDecode;
  v10 = *(unsigned __int16 *)(a1 + 122);
  if (v10 == 32844)
  {
    result = LogL16InitState(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
    *(_QWORD *)(a1 + 1008) = LogL16Decode;
    v14 = *(_DWORD *)(v9 + 4);
    if (v14 == 3)
    {
      v13 = L16toGry;
      goto LABEL_23;
    }
    if (!v14)
    {
      v13 = L16toY;
      goto LABEL_23;
    }
  }
  else
  {
    if (v10 != 32845)
    {
      TIFFErrorExtR(a1, "LogLuvSetupDecode", "Inappropriate photometric interpretation %hu for SGILog compression; %s",
        a4,
        a5,
        a6,
        a7,
        a8,
        *(_WORD *)(a1 + 122));
      return 0;
    }
    result = LogLuvInitState(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
    if (*(unsigned __int16 *)(a1 + 120) == 34677)
    {
      *(_QWORD *)(a1 + 1008) = LogLuvDecode24;
      v12 = *(_DWORD *)(v9 + 4);
      switch(v12)
      {
        case 3:
          v13 = Luv24toRGB;
          goto LABEL_23;
        case 1:
          v13 = Luv24toLuv48;
          goto LABEL_23;
        case 0:
          v13 = Luv24toXYZ;
LABEL_23:
          *(_QWORD *)(v9 + 32) = v13;
          break;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 1008) = LogLuvDecode32;
      v15 = *(_DWORD *)(v9 + 4);
      switch(v15)
      {
        case 3:
          v13 = Luv32toRGB;
          goto LABEL_23;
        case 1:
          v13 = Luv32toLuv48;
          goto LABEL_23;
        case 0:
          v13 = Luv32toXYZ;
          goto LABEL_23;
      }
    }
  }
  return 1;
}

uint64_t LogLuvDecodeStrip(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v13;
  int v14;
  BOOL v15;

  v9 = a3;
  v10 = a2;
  result = _cg_TIFFScanlineSize(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v13 = result;
    if (v9 % result)
      LogLuvDecodeStrip_cold_1();
    if (v9)
    {
      do
      {
        v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1008))(a1, v10, v13, a4);
        v10 += v13;
        if (v14)
          v15 = v9 == v13;
        else
          v15 = 1;
        v9 -= v13;
      }
      while (!v15);
      return v14 != 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t LogLuvDecodeTile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v13;
  int v14;
  BOOL v15;

  v9 = a3;
  v10 = a2;
  result = _cg_TIFFTileRowSize(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v13 = result;
    if (v9 % result)
      LogLuvDecodeTile_cold_1();
    if (v9)
    {
      do
      {
        v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1008))(a1, v10, v13, a4);
        v10 += v13;
        if (v14)
          v15 = v9 == v13;
        else
          v15 = 1;
        v9 -= v13;
      }
      while (!v15);
      return v14 != 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t LogLuvSetupEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  void *v18;
  int v19;
  int v20;
  const char *v21;

  v9 = *(_QWORD *)(a1 + 1096);
  v10 = *(unsigned __int16 *)(a1 + 122);
  if (v10 == 32844)
  {
    result = LogL16InitState(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
    *(_QWORD *)(a1 + 1016) = LogL16Encode;
    v19 = *(_DWORD *)(v9 + 4);
    if (!v19)
    {
      v18 = L16fromY;
      goto LABEL_25;
    }
    if (v19 != 1)
    {
LABEL_18:
      v21 = "XYZ, Luv";
      if (*(unsigned __int16 *)(a1 + 122) == 32844)
        v21 = "Y, L";
      TIFFErrorExtR(a1, "LogLuvSetupEncode", "SGILog compression supported only for %s, or raw data", v12, v13, v14, v15, v16, (char)v21);
      return 0;
    }
  }
  else
  {
    if (v10 != 32845)
    {
      TIFFErrorExtR(a1, "LogLuvSetupEncode", "Inappropriate photometric interpretation %hu for SGILog compression; %s",
        a4,
        a5,
        a6,
        a7,
        a8,
        *(_WORD *)(a1 + 122));
      return 0;
    }
    result = LogLuvInitState(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
    if (*(unsigned __int16 *)(a1 + 120) == 34677)
    {
      *(_QWORD *)(a1 + 1016) = LogLuvEncode24;
      v17 = *(_DWORD *)(v9 + 4);
      if (!v17)
      {
        v18 = Luv24fromXYZ;
        goto LABEL_25;
      }
      if (v17 != 2)
      {
        if (v17 == 1)
        {
          v18 = Luv24fromLuv48;
LABEL_25:
          *(_QWORD *)(v9 + 32) = v18;
          goto LABEL_26;
        }
        goto LABEL_18;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 1016) = LogLuvEncode32;
      v20 = *(_DWORD *)(v9 + 4);
      if (!v20)
      {
        v18 = Luv32fromXYZ;
        goto LABEL_25;
      }
      if (v20 != 2)
      {
        if (v20 == 1)
        {
          v18 = Luv32fromLuv48;
          goto LABEL_25;
        }
        goto LABEL_18;
      }
    }
  }
LABEL_26:
  result = 1;
  *(_DWORD *)v9 = 1;
  return result;
}

uint64_t LogLuvEncodeStrip(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v13;
  int v14;
  BOOL v15;

  v9 = a3;
  v10 = a2;
  result = _cg_TIFFScanlineSize(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v13 = result;
    if (v9 % result)
      LogLuvEncodeStrip_cold_1();
    if (v9)
    {
      do
      {
        v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1016))(a1, v10, v13, a4);
        v10 += v13;
        v15 = v14 != 1 || v9 == v13;
        v9 -= v13;
      }
      while (!v15);
      return v14 == 1;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t LogLuvEncodeTile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v13;
  int v14;
  BOOL v15;

  v9 = a3;
  v10 = a2;
  result = _cg_TIFFTileRowSize(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v13 = result;
    if (v9 % result)
      LogLuvEncodeTile_cold_1();
    if (v9)
    {
      do
      {
        v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1016))(a1, v10, v13, a4);
        v10 += v13;
        v15 = v14 != 1 || v9 == v13;
        v9 -= v13;
      }
      while (!v15);
      return v14 == 1;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t LogLuvClose(uint64_t result)
{
  _DWORD *v1;
  __int16 v2;

  v1 = *(_DWORD **)(result + 1096);
  if (!v1)
    LogLuvClose_cold_1();
  if (*v1)
  {
    if (*(unsigned __int16 *)(result + 122) == 32844)
      v2 = 1;
    else
      v2 = 3;
    *(_WORD *)(result + 130) = v2;
    *(_DWORD *)(result + 116) = 131088;
  }
  return result;
}

uint64_t LogLuvCleanup(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  char *v4;

  v1 = a1[137];
  if (!v1)
    LogLuvCleanup_cold_1();
  v3 = *(_QWORD *)(v1 + 48);
  a1[161] = *(_QWORD *)(v1 + 40);
  a1[160] = v3;
  v4 = *(char **)(v1 + 16);
  if (v4)
    _TIFFfreeExt((uint64_t)a1, v4);
  _TIFFfreeExt((uint64_t)a1, (char *)v1);
  a1[137] = 0;
  return _TIFFSetDefaultCompressionState((uint64_t)a1);
}

uint64_t LogLuvVGetField(uint64_t a1, int a2, _DWORD **a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 1096);
  if (a2 != 65560)
    return (*(uint64_t (**)(void))(v3 + 40))();
  **a3 = *(_DWORD *)(v3 + 4);
  return 1;
}

uint64_t LogLuvVSetField(uint64_t a1, int a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v9 = *(_QWORD *)(a1 + 1096);
  if (a2 != 65561)
  {
    if (a2 != 65560)
      return (*(uint64_t (**)(uint64_t))(v9 + 48))(a1);
    v10 = *a3;
    *(_DWORD *)(v9 + 4) = *a3;
    v11 = 3;
    v12 = 32;
    switch(v10)
    {
      case 0u:
        break;
      case 1u:
        v11 = 2;
        v12 = 16;
        break;
      case 2u:
        v11 = 1;
        _cg_TIFFSetField(a1, 277, (uint64_t)a3, a4, a5, a6, a7, a8, 1);
        v12 = 32;
        break;
      case 3u:
        v11 = 1;
        v12 = 8;
        break;
      default:
        TIFFErrorExtR(a1, *(const char **)a1, "Unknown data format %d for LogLuv compression", a4, a5, a6, a7, a8, v10);
        return 0;
    }
    _cg_TIFFSetField(a1, 258, (uint64_t)a3, a4, a5, a6, a7, a8, v12);
    _cg_TIFFSetField(a1, 339, v15, v16, v17, v18, v19, v20, v11);
    if ((*(_BYTE *)(a1 + 17) & 4) != 0)
      v28 = _cg_TIFFTileSize(a1, v21, v22, v23, v24, v25, v26, v27);
    else
      v28 = -1;
    *(_QWORD *)(a1 + 936) = v28;
    *(_QWORD *)(a1 + 1104) = _cg_TIFFScanlineSize(a1, v21, v22, v23, v24, v25, v26, v27);
    return 1;
  }
  v13 = *a3;
  *(_DWORD *)(v9 + 8) = *a3;
  if (v13 < 2)
    return 1;
  TIFFErrorExtR(a1, "LogLuvVSetField", "Unknown encoding %d for LogLuv compression", a4, a5, a6, a7, a8, v13);
  return 0;
}

uint64_t LogLuvInitState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int v10;
  int v11;
  int v13;
  char *v14;
  int v15;
  uint64_t v16;
  int64_t v17;
  int64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  char v26;

  v8 = *(_QWORD *)(a1 + 1096);
  if (!v8)
    LogLuvInitState_cold_1();
  if (*(unsigned __int16 *)(a1 + 122) != 32845)
    LogLuvInitState_cold_2();
  if (*(_WORD *)(a1 + 170) != 1)
  {
    v14 = "SGILog compression cannot handle non-contiguous data";
    goto LABEL_37;
  }
  v10 = *(_DWORD *)(v8 + 4);
  if (v10 == -1)
  {
    v11 = *(unsigned __int16 *)(a1 + 118) | (8 * *(unsigned __int16 *)(a1 + 116));
    if (v11 > 256)
    {
      if ((v11 - 257) < 2)
        goto LABEL_15;
      if (v11 == 259)
      {
        v13 = 0;
LABEL_21:
        v10 = -1;
        goto LABEL_22;
      }
      if (v11 == 260)
      {
LABEL_15:
        v10 = 2;
        v13 = -1;
        goto LABEL_22;
      }
    }
    else
    {
      if ((v11 - 129) <= 3 && v11 != 131)
      {
        v10 = -1;
        v13 = 1;
LABEL_22:
        v15 = *(unsigned __int16 *)(a1 + 130);
        if (v15 != 3)
          v13 = -1;
        if (v15 != 1)
          v10 = v13;
        *(_DWORD *)(v8 + 4) = v10;
        goto LABEL_27;
      }
      if (v11 == 65 || v11 == 68)
      {
        v10 = -1;
        v13 = 3;
        goto LABEL_22;
      }
    }
    v13 = -1;
    goto LABEL_21;
  }
LABEL_27:
  if (v10 > 3)
  {
    v14 = "No support for converting user data format to LogLuv";
  }
  else
  {
    *(_DWORD *)(v8 + 12) = dword_18822D4C0[v10];
    if ((*(_BYTE *)(a1 + 17) & 4) != 0)
    {
      v17 = *(unsigned int *)(a1 + 100);
      v16 = *(unsigned int *)(a1 + 104);
    }
    else
    {
      v16 = *(unsigned int *)(a1 + 132);
      v17 = *(unsigned int *)(a1 + 88);
      if (v16 >= *(_DWORD *)(a1 + 92))
        v16 = *(unsigned int *)(a1 + 92);
    }
    v18 = _TIFFMultiplySSize(0, v17, v16, 0, a5, a6, a7, a8);
    *(_QWORD *)(v8 + 24) = v18;
    if (_TIFFMultiplySSize(0, v18, 4, 0, v19, v20, v21, v22))
    {
      v24 = _TIFFmallocExt((_QWORD *)a1, 4 * *(_QWORD *)(v8 + 24), v23, a4, a5, a6, a7, a8);
      *(_QWORD *)(v8 + 16) = v24;
      if (v24)
        return 1;
    }
    v14 = "No space for SGILog translation buffer";
  }
LABEL_37:
  TIFFErrorExtR(a1, "LogLuvInitState", v14, a4, a5, a6, a7, a8, v26);
  return 0;
}

uint64_t LogLuvDecode24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  char *v11;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  unint64_t v16;
  int v18;

  if ((_DWORD)a4)
    LogLuvDecode24_cold_2();
  v8 = *(_QWORD *)(a1 + 1096);
  if (!v8)
    LogLuvDecode24_cold_1();
  v10 = a3 / *(int *)(v8 + 12);
  if (*(_DWORD *)(v8 + 4) != 2)
  {
    if (*(_QWORD *)(v8 + 24) < v10)
    {
      v11 = "Translation buffer too short";
      goto LABEL_17;
    }
    a2 = *(_QWORD *)(v8 + 16);
  }
  v12 = *(unsigned __int8 **)(a1 + 1152);
  v13 = *(_QWORD *)(a1 + 1160);
  v14 = 0;
  v15 = v10 < 1 || v13 < 3;
  if (!v15)
  {
    v16 = *(_QWORD *)(a1 + 1160);
    do
    {
      *(_DWORD *)(a2 + 4 * v14) = (*v12 << 16) | (v12[1] << 8) | v12[2];
      v12 += 3;
      v13 = v16 - 3;
      if (++v14 >= v10)
        break;
      v15 = v16 > 5;
      v16 -= 3;
    }
    while (v15);
  }
  *(_QWORD *)(a1 + 1152) = v12;
  *(_QWORD *)(a1 + 1160) = v13;
  if (v10 == v14)
  {
    (*(void (**)(uint64_t))(v8 + 32))(v8);
    return 1;
  }
  v18 = *(_DWORD *)(a1 + 876);
  v11 = "Not enough data at row %u (short %lld pixels)";
LABEL_17:
  TIFFErrorExtR(a1, "LogLuvDecode24", v11, a4, a5, a6, a7, a8, v18);
  return 0;
}

void Luv24toXYZ(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v4;
  unint64_t v5;
  unsigned int v6;

  if (a3 >= 1)
  {
    v4 = *(unsigned int **)(a1 + 16);
    v5 = a3 + 1;
    do
    {
      v6 = *v4++;
      LogLuv24toXYZ(v6, a2);
      a2 += 12;
      --v5;
    }
    while (v5 > 1);
  }
}

uint64_t Luv24toLuv48(uint64_t result, _WORD *a2, uint64_t a3)
{
  double v3;
  double v4;
  unint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  __int16 v9;
  __int16 v10;
  __int16 v11;
  double v12;
  double v13[11];

  if (a3 >= 1)
  {
    v13[9] = v3;
    v13[10] = v4;
    v6 = a3 + 1;
    v7 = *(unsigned int **)(result + 16);
    do
    {
      v12 = 0.0;
      v13[0] = 0.0;
      v8 = *v7++;
      *a2 = ((v8 >> 12) & 0xFFD) + 13314;
      result = uv_decode(v13, &v12, v8 & 0x3FFF);
      v9 = vcvtd_n_s64_f64(v13[0], 0xFuLL);
      if ((int)result < 0)
        v9 = 6898;
      v10 = vcvtd_n_s64_f64(v12, 0xFuLL);
      a2[1] = v9;
      if ((int)result >= 0)
        v11 = v10;
      else
        v11 = 15521;
      a2[2] = v11;
      --v6;
      a2 += 3;
    }
    while (v6 > 1);
  }
  return result;
}

float *Luv24toRGB(float *result, char *a2, uint64_t a3)
{
  unsigned int *v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a3 >= 1)
  {
    v4 = (unsigned int *)*((_QWORD *)result + 2);
    v5 = a3 + 1;
    do
    {
      v8 = 0;
      v7 = 0;
      v6 = *v4++;
      LogLuv24toXYZ(v6, (uint64_t)&v7);
      result = XYZtoRGB24((float *)&v7, a2);
      a2 += 3;
      --v5;
    }
    while (v5 > 1);
  }
  return result;
}

uint64_t LogLuvDecode32(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  unsigned __int8 *v25;
  uint64_t v26;
  uint64_t v27;
  int v29;
  int v30;
  BOOL v31;
  char v32;

  if ((_DWORD)a4)
    LogLuvDecode32_cold_2();
  v9 = *(_QWORD *)(a1 + 1096);
  if (!v9)
    LogLuvDecode32_cold_1();
  v11 = __b;
  v12 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 2)
  {
    if (*(_QWORD *)(v9 + 24) < v12)
    {
      TIFFErrorExtR(a1, "LogLuvDecode32", "Translation buffer too short", a4, a5, a6, a7, a8, v32);
      return 0;
    }
    v11 = *(void **)(v9 + 16);
  }
  _TIFFmemset(v11, 0, 4 * v12);
  v19 = *(char **)(a1 + 1152);
  v20 = *(_QWORD *)(a1 + 1160);
  v21 = 24;
  while (1)
  {
    v22 = 0;
    v23 = v21;
    if (v12 >= 1 && v20 >= 1)
    {
      v22 = 0;
      do
      {
        v24 = *v19;
        if (*v19 < 0)
        {
          if ((unint64_t)v20 < 2)
            break;
          if (v24 != 126 && v22 < v12)
          {
            v29 = v19[1] << v23;
            v30 = v24 - 127;
            do
            {
              *((_DWORD *)v11 + v22++) |= v29;
              v31 = v30-- != 0;
            }
            while (v31 && v22 < v12);
          }
          v19 += 2;
          v20 -= 2;
        }
        else
        {
          v25 = (unsigned __int8 *)(v19 + 1);
          v26 = v20 - 1;
          if (v20 == 1)
          {
            v20 = 0;
            ++v19;
            break;
          }
          v27 = 0;
          while (v24 != (_DWORD)v27 && v22 + v27 < v12)
          {
            *((_DWORD *)v11 + v22 + v27) |= v25[v27] << v23;
            if (v26 == ++v27)
            {
              v20 = 0;
              v19 += v27 + 1;
              v22 += v27;
              goto LABEL_32;
            }
          }
          v20 = v26 - v27;
          v19 = (char *)&v25[v27];
          v22 += v27;
        }
      }
      while (v22 < v12 && v20 > 0);
    }
LABEL_32:
    if (v12 != v22)
      break;
    v21 = v23 - 8;
    if (!v23)
    {
      (*(void (**)(uint64_t, void *, uint64_t))(v9 + 32))(v9, __b, v12);
      *(_QWORD *)(a1 + 1152) = v19;
      *(_QWORD *)(a1 + 1160) = v20;
      return 1;
    }
  }
  TIFFErrorExtR(a1, "LogLuvDecode32", "Not enough data at row %u (short %lld pixels)", v14, v15, v16, v17, v18, *(_DWORD *)(a1 + 876));
  result = 0;
  *(_QWORD *)(a1 + 1152) = v19;
  *(_QWORD *)(a1 + 1160) = v20;
  return result;
}

void Luv32toXYZ(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int *v4;
  unint64_t v5;
  int v6;

  if (a3 >= 1)
  {
    v4 = *(int **)(a1 + 16);
    v5 = a3 + 1;
    do
    {
      v6 = *v4++;
      LogLuv32toXYZ(v6, a2);
      a2 += 12;
      --v5;
    }
    while (v5 > 1);
  }
}

uint64_t Luv32toLuv48(uint64_t result, _WORD *a2, uint64_t a3)
{
  unsigned __int32 *v3;
  unint64_t v4;
  float64x2_t v10;
  unsigned __int32 v11;
  int8x8_t v12;
  int8x8_t v13;
  uint64x2_t v14;
  int32x2_t v15;

  if (a3 >= 1)
  {
    v3 = *(unsigned __int32 **)(result + 16);
    v4 = a3 + 1;
    __asm { FMOV            V1.2D, #0.5 }
    v10 = (float64x2_t)vdupq_n_s64(0x3F63FB013FB013FBuLL);
    do
    {
      v11 = *v3++;
      v12.i32[0] = v11 >> 8;
      v12.i32[1] = v11;
      v13 = vand_s8(v12, (int8x8_t)0xFF000000FFLL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      v15 = vmovn_s64(vcvtq_n_s64_f64(vmulq_f64(vaddq_f64(vcvtq_f64_u64(v14), _Q1), v10), 0xFuLL));
      *a2 = HIWORD(v11);
      a2[2] = v15.i16[2];
      a2[1] = v15.i16[0];
      --v4;
      a2 += 3;
    }
    while (v4 > 1);
  }
  return result;
}

float *Luv32toRGB(float *result, char *a2, uint64_t a3)
{
  int *v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a3 >= 1)
  {
    v4 = (int *)*((_QWORD *)result + 2);
    v5 = a3 + 1;
    do
    {
      v8 = 0;
      v7 = 0;
      v6 = *v4++;
      LogLuv32toXYZ(v6, (uint64_t)&v7);
      result = XYZtoRGB24((float *)&v7, a2);
      a2 += 3;
      --v5;
    }
    while (v5 > 1);
  }
  return result;
}

uint64_t LogL16InitState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v10;
  int v11;
  int v12;
  char *v14;
  uint64_t v15;
  int64_t v16;
  int64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  char v25;

  v8 = *(_QWORD *)(a1 + 1096);
  if (!v8)
    LogL16InitState_cold_1();
  if (*(unsigned __int16 *)(a1 + 122) != 32844)
    LogL16InitState_cold_2();
  if (*(_WORD *)(a1 + 130) == 1)
  {
    v10 = *(_DWORD *)(v8 + 4);
    if (v10 != -1)
    {
      if (v10)
        goto LABEL_6;
      goto LABEL_25;
    }
    v12 = *(unsigned __int16 *)(a1 + 118) | (*(unsigned __int16 *)(a1 + 116) << 6) | 8;
    if (v12 <= 1032)
    {
      if (v12 == 521 || v12 == 524)
      {
        v10 = 3;
        goto LABEL_24;
      }
    }
    else
    {
      if ((v12 - 1033) <= 3 && v12 != 1035)
      {
        v10 = 1;
        goto LABEL_24;
      }
      if (v12 == 2059)
      {
        v10 = 0;
        goto LABEL_24;
      }
    }
    v10 = -1;
LABEL_24:
    *(_DWORD *)(v8 + 4) = v10;
    if (v10)
    {
LABEL_6:
      if (v10 == 3)
      {
        v11 = 1;
      }
      else
      {
        if (v10 != 1)
        {
          v14 = "No support for converting user data format to LogL";
LABEL_34:
          TIFFErrorExtR(a1, "LogL16InitState", v14, a4, a5, a6, a7, a8, v25);
          return 0;
        }
        v11 = 2;
      }
LABEL_26:
      *(_DWORD *)(v8 + 12) = v11;
      if ((*(_BYTE *)(a1 + 17) & 4) != 0)
      {
        v16 = *(unsigned int *)(a1 + 100);
        v15 = *(unsigned int *)(a1 + 104);
      }
      else
      {
        v15 = *(unsigned int *)(a1 + 132);
        v16 = *(unsigned int *)(a1 + 88);
        if (v15 >= *(_DWORD *)(a1 + 92))
          v15 = *(unsigned int *)(a1 + 92);
      }
      v17 = _TIFFMultiplySSize(0, v16, v15, 0, a5, a6, a7, a8);
      *(_QWORD *)(v8 + 24) = v17;
      if (_TIFFMultiplySSize(0, v17, 2, 0, v18, v19, v20, v21))
      {
        v23 = _TIFFmallocExt((_QWORD *)a1, 2 * *(_QWORD *)(v8 + 24), v22, a4, a5, a6, a7, a8);
        *(_QWORD *)(v8 + 16) = v23;
        if (v23)
          return 1;
      }
      v14 = "No space for SGILog translation buffer";
      goto LABEL_34;
    }
LABEL_25:
    v11 = 4;
    goto LABEL_26;
  }
  TIFFErrorExtR(a1, "LogL16InitState", "Sorry, can not handle LogL image with %s=%hu", a4, a5, a6, a7, a8, (char)"Samples/pixel");
  return 0;
}

uint64_t LogL16Decode(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  unsigned __int8 *v25;
  uint64_t v26;
  uint64_t v27;
  int v29;
  int v30;
  BOOL v31;
  char v32;

  if ((_DWORD)a4)
    LogL16Decode_cold_2();
  v9 = *(_QWORD *)(a1 + 1096);
  if (!v9)
    LogL16Decode_cold_1();
  v11 = __b;
  v12 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 1)
  {
    if (*(_QWORD *)(v9 + 24) < v12)
    {
      TIFFErrorExtR(a1, "LogL16Decode", "Translation buffer too short", a4, a5, a6, a7, a8, v32);
      return 0;
    }
    v11 = *(void **)(v9 + 16);
  }
  _TIFFmemset(v11, 0, 2 * v12);
  v19 = *(char **)(a1 + 1152);
  v20 = *(_QWORD *)(a1 + 1160);
  v21 = 8;
  while (1)
  {
    v22 = 0;
    v23 = v21;
    if (v12 >= 1 && v20 >= 1)
    {
      v22 = 0;
      do
      {
        v24 = *v19;
        if (*v19 < 0)
        {
          if ((unint64_t)v20 < 2)
            break;
          if (v24 != 126 && v22 < v12)
          {
            v29 = v19[1] << v23;
            v30 = v24 - 127;
            do
            {
              *((_WORD *)v11 + v22++) |= v29;
              v31 = v30-- != 0;
            }
            while (v31 && v22 < v12);
          }
          v19 += 2;
          v20 -= 2;
        }
        else
        {
          v25 = (unsigned __int8 *)(v19 + 1);
          v26 = v20 - 1;
          if (v20 == 1)
          {
            v20 = 0;
            ++v19;
            break;
          }
          v27 = 0;
          while (v24 != (_DWORD)v27 && v22 + v27 < v12)
          {
            *((_WORD *)v11 + v22 + v27) |= v25[v27] << v23;
            if (v26 == ++v27)
            {
              v20 = 0;
              v19 += v27 + 1;
              v22 += v27;
              goto LABEL_32;
            }
          }
          v20 = v26 - v27;
          v19 = (char *)&v25[v27];
          v22 += v27;
        }
      }
      while (v22 < v12 && v20 > 0);
    }
LABEL_32:
    if (v12 != v22)
      break;
    v21 = v23 - 8;
    if (!v23)
    {
      (*(void (**)(uint64_t, void *, uint64_t))(v9 + 32))(v9, __b, v12);
      *(_QWORD *)(a1 + 1152) = v19;
      *(_QWORD *)(a1 + 1160) = v20;
      return 1;
    }
  }
  TIFFErrorExtR(a1, "LogL16Decode", "Not enough data at row %u (short %lld pixels)", v14, v15, v16, v17, v18, *(_DWORD *)(a1 + 876));
  result = 0;
  *(_QWORD *)(a1 + 1152) = v19;
  *(_QWORD *)(a1 + 1160) = v20;
  return result;
}

void L16toY(uint64_t a1, float *a2, uint64_t a3)
{
  __int16 *v4;
  unint64_t v5;
  int v6;
  int v7;
  unsigned int v8;
  double v9;
  float v10;

  if (a3 >= 1)
  {
    v4 = *(__int16 **)(a1 + 16);
    v5 = a3 + 1;
    do
    {
      v7 = *v4++;
      v6 = v7;
      v8 = v7 & 0x7FFF;
      if ((v7 & 0x7FFF) != 0)
      {
        v9 = exp(((double)v8 + 0.5) * 0.00270760617 + -44.3614196);
        if (v6 < 0)
          v9 = -v9;
      }
      else
      {
        v9 = 0.0;
      }
      v10 = v9;
      *a2++ = v10;
      --v5;
    }
    while (v5 > 1);
  }
}

void L16toGry(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  __int16 *v4;
  unint64_t v5;
  int v6;
  int v7;
  unsigned int v8;
  double v9;

  if (a3 >= 1)
  {
    v4 = *(__int16 **)(a1 + 16);
    v5 = a3 + 1;
    do
    {
      v7 = *v4++;
      v6 = v7;
      v8 = v7 & 0x7FFF;
      if ((v7 & 0x7FFF) != 0)
      {
        v9 = exp(((double)v8 + 0.5) * 0.00270760617 + -44.3614196);
        if (v6 < 0)
          v9 = -v9;
        if (v9 <= 0.0)
        {
          LOBYTE(v8) = 0;
        }
        else
        {
          LOBYTE(v8) = vcvtd_n_s64_f64(sqrt(v9), 8uLL);
          if (v9 >= 1.0)
            LOBYTE(v8) = -1;
        }
      }
      *a2++ = v8;
      --v5;
    }
    while (v5 > 1);
  }
}

uint64_t LogLuvEncode24(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  char v18;

  if ((_DWORD)a4)
    LogLuvEncode24_cold_2();
  v9 = a1[137];
  if (!v9)
    LogLuvEncode24_cold_1();
  v10 = a2;
  v11 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 2)
  {
    if (*(_QWORD *)(v9 + 24) < v11)
    {
      TIFFErrorExtR((uint64_t)a1, "LogLuvEncode24", "Translation buffer too short", a4, a5, a6, a7, a8, v18);
      return 0;
    }
    v13 = *(_QWORD *)(v9 + 16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 32))(v9, a2, a3 / *(int *)(v9 + 12));
    v10 = v13;
  }
  v14 = (_BYTE *)a1[144];
  v15 = a1[141];
  v16 = v15 - a1[145];
  if (v11)
  {
    do
    {
      if (v16 <= 2)
      {
        a1[144] = v14;
        a1[145] = a1[141] - v16;
        result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!(_DWORD)result)
          return result;
        v14 = (_BYTE *)a1[144];
        v16 = a1[141] - a1[145];
      }
      *v14 = *(_WORD *)(v10 + 2);
      v14[1] = BYTE1(*(_DWORD *)v10);
      v17 = *(_DWORD *)v10;
      v10 += 4;
      v14[2] = v17;
      v14 += 3;
      v16 -= 3;
      --v11;
    }
    while (v11);
    v15 = a1[141];
  }
  a1[144] = v14;
  a1[145] = v15 - v16;
  return 1;
}

uint64_t Luv24fromXYZ(uint64_t result, float *a2, uint64_t a3)
{
  uint64_t v4;
  _DWORD *v5;
  unint64_t v6;

  if (a3 >= 1)
  {
    v4 = result;
    v5 = *(_DWORD **)(result + 16);
    v6 = a3 + 1;
    do
    {
      result = LogLuv24fromXYZ(a2, *(_DWORD *)(v4 + 8));
      *v5++ = result;
      a2 += 3;
      --v6;
    }
    while (v6 > 1);
  }
  return result;
}

uint64_t Luv24fromLuv48(uint64_t result, __int16 *a2, uint64_t a3)
{
  uint64_t v4;
  _DWORD *v5;
  unint64_t v6;
  int v7;
  int v8;

  if (a3 >= 1)
  {
    v4 = result;
    v5 = *(_DWORD **)(result + 16);
    v6 = a3 + 1;
    do
    {
      v7 = *a2;
      if (v7 < 1)
      {
        v8 = 0;
      }
      else if ((unsigned __int16)((unsigned __int16)v7 >> 1) <= 0xE78u)
      {
        if (*(_DWORD *)(v4 + 8))
          v8 = (int)(((double)v7 + -3314.0) * 0.25 + (double)rand() * 4.65661288e-10 + -0.5);
        else
          v8 = (v7 - 3314) >> 2;
      }
      else
      {
        v8 = 1023;
      }
      result = uv_encode(*(_DWORD *)(v4 + 8), ((double)a2[1] + 0.5) * 0.0000305175781, ((double)a2[2] + 0.5) * 0.0000305175781);
      if ((result & 0x80000000) != 0)
        result = uv_encode(0, 0.210526316, 0.473684211);
      *v5++ = result | (v8 << 14);
      --v6;
      a2 += 3;
    }
    while (v6 > 1);
  }
  return result;
}

uint64_t LogLuvEncode32(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t i;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  char v27;

  if ((_DWORD)a4)
    LogLuvEncode32_cold_2();
  v9 = a1[137];
  if (!v9)
    LogLuvEncode32_cold_1();
  v10 = a2;
  v11 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 2)
  {
    if (*(_QWORD *)(v9 + 24) < v11)
    {
      TIFFErrorExtR((uint64_t)a1, "LogLuvEncode32", "Translation buffer too short", a4, a5, a6, a7, a8, v27);
      return 0;
    }
    v13 = *(_QWORD *)(v9 + 16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 32))(v9, a2, a3 / *(int *)(v9 + 12));
    v10 = v13;
  }
  LODWORD(v14) = 0;
  v15 = (_BYTE *)a1[144];
  v16 = a1[141] - a1[145];
  v17 = 24;
  do
  {
    v18 = v17;
    if (v11 >= 1)
    {
      v19 = 0;
      v20 = 255 << v17;
      do
      {
        if (v16 <= 3)
        {
          a1[144] = v15;
          a1[145] = a1[141] - v16;
          result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!(_DWORD)result)
            return result;
          v15 = (_BYTE *)a1[144];
          v16 = a1[141] - a1[145];
        }
        for (i = v19; i < v11; i += v14)
        {
          v14 = 1;
          while (i + v14 < v11 && ((*(_DWORD *)(v10 + 4 * i + 4 * v14) ^ *(_DWORD *)(v10 + 4 * i)) & v20) == 0)
          {
            if (++v14 == 129)
              goto LABEL_22;
          }
          if (v14 >= 4)
            break;
        }
LABEL_22:
        if (((i - v19) & 0xFFFFFFFFFFFFFFFELL) == 2)
        {
          v22 = *(_DWORD *)(v10 + 4 * v19) & v20;
          v23 = v19 + 1;
          while ((*(_DWORD *)(v10 + 4 * v23) & v20) == v22)
          {
            if (i == ++v23)
            {
              *v15 = i + ~(_BYTE)v19 + 127;
              v15[1] = v22 >> v18;
              v15 += 2;
              v16 -= 2;
              v19 = i;
              goto LABEL_39;
            }
          }
        }
        while (v19 < i)
        {
          if (i - v19 >= 127)
            v24 = 127;
          else
            v24 = i - v19;
          if (v16 < v24 + 3)
          {
            a1[144] = v15;
            a1[145] = a1[141] - v16;
            result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!(_DWORD)result)
              return result;
            v15 = (_BYTE *)a1[144];
            v16 = a1[141] - a1[145];
          }
          *v15++ = v24;
          --v16;
          if (v24)
          {
            v25 = v24;
            do
            {
              v26 = *(_DWORD *)(v10 + 4 * v19++);
              *v15++ = v26 >> v18;
              --v25;
            }
            while (v25);
            v16 -= v24;
          }
        }
LABEL_39:
        if ((int)v14 < 4)
        {
          LODWORD(v14) = 0;
        }
        else
        {
          *v15 = v14 + 126;
          v15[1] = *(_DWORD *)(v10 + 4 * i) >> v18;
          v15 += 2;
          v16 -= 2;
        }
        v19 += v14;
      }
      while (v19 < v11);
    }
    v17 = v18 - 8;
  }
  while (v18);
  a1[144] = v15;
  a1[145] = a1[141] - v16;
  return 1;
}

uint64_t Luv32fromXYZ(uint64_t result, float *a2, uint64_t a3)
{
  uint64_t v4;
  _DWORD *v5;
  unint64_t v6;

  if (a3 >= 1)
  {
    v4 = result;
    v5 = *(_DWORD **)(result + 16);
    v6 = a3 + 1;
    do
    {
      result = LogLuv32fromXYZ(a2, *(_DWORD *)(v4 + 8));
      *v5++ = result;
      a2 += 3;
      --v6;
    }
    while (v6 > 1);
  }
  return result;
}

uint64_t Luv32fromLuv48(uint64_t result, unsigned __int16 *a2, uint64_t a3)
{
  int *v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  double v8;
  int v9;
  double v10;
  unint64_t v11;

  v4 = *(int **)(result + 16);
  if (*(_DWORD *)(result + 8))
  {
    if (a3 >= 1)
    {
      v5 = result;
      v6 = a3 + 1;
      do
      {
        v7 = *a2;
        v8 = (double)(__int16)a2[1] * 0.012512207;
        v9 = *(_DWORD *)(v5 + 8);
        if (v9)
        {
          result = rand();
          v8 = v8 + (double)(int)result * 4.65661288e-10 + -0.5;
          v9 = *(_DWORD *)(v5 + 8);
        }
        v10 = (double)(__int16)a2[2] * 0.012512207;
        if (v9)
        {
          result = rand();
          v10 = v10 + (double)(int)result * 4.65661288e-10 + -0.5;
        }
        *v4++ = (int)v10 | ((int)v8 << 8) | (v7 << 16);
        --v6;
        a2 += 3;
      }
      while (v6 > 1);
    }
  }
  else if (a3 >= 1)
  {
    v11 = a3 + 1;
    do
    {
      *v4++ = (*a2 << 16) | ((410 * (__int16)a2[1]) >> 7) & 0xFF00 | ((410 * (__int16)a2[2]) >> 15);
      --v11;
      a2 += 3;
    }
    while (v11 > 1);
  }
  return result;
}

uint64_t LogL16Encode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t i;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  char v27;

  if ((_DWORD)a4)
    LogL16Encode_cold_2();
  v9 = a1[137];
  if (!v9)
    LogL16Encode_cold_1();
  v10 = a2;
  v11 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 1)
  {
    if (*(_QWORD *)(v9 + 24) < v11)
    {
      TIFFErrorExtR((uint64_t)a1, "LogL16Encode", "Translation buffer too short", a4, a5, a6, a7, a8, v27);
      return 0;
    }
    v13 = *(_QWORD *)(v9 + 16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 32))(v9, a2, a3 / *(int *)(v9 + 12));
    v10 = v13;
  }
  LODWORD(v14) = 0;
  v15 = (_BYTE *)a1[144];
  v16 = a1[141] - a1[145];
  v17 = 8;
  do
  {
    v18 = v17;
    if (v11 >= 1)
    {
      v19 = 0;
      v20 = 255 << v17;
      do
      {
        if (v16 <= 3)
        {
          a1[144] = v15;
          a1[145] = a1[141] - v16;
          result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!(_DWORD)result)
            return result;
          v15 = (_BYTE *)a1[144];
          v16 = a1[141] - a1[145];
        }
        for (i = v19; i < v11; i += v14)
        {
          v14 = 1;
          while (i + v14 < v11
               && (v20 & *(__int16 *)(v10 + 2 * i + 2 * v14)) == (__int16)(*(_WORD *)(v10 + 2 * i) & v20))
          {
            if (++v14 == 129)
              goto LABEL_22;
          }
          if (v14 >= 4)
            break;
        }
LABEL_22:
        if (((i - v19) & 0xFFFFFFFFFFFFFFFELL) == 2)
        {
          v22 = (__int16)(*(_WORD *)(v10 + 2 * v19) & v20);
          v23 = v19 + 1;
          while ((v20 & *(__int16 *)(v10 + 2 * v23)) == v22)
          {
            if (i == ++v23)
            {
              *v15 = i + ~(_BYTE)v19 + 127;
              v15[1] = v22 >> v18;
              v15 += 2;
              v16 -= 2;
              v19 = i;
              goto LABEL_39;
            }
          }
        }
        while (v19 < i)
        {
          if (i - v19 >= 127)
            v24 = 127;
          else
            v24 = i - v19;
          if (v16 < v24 + 3)
          {
            a1[144] = v15;
            a1[145] = a1[141] - v16;
            result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!(_DWORD)result)
              return result;
            v15 = (_BYTE *)a1[144];
            v16 = a1[141] - a1[145];
          }
          *v15++ = v24;
          --v16;
          if (v24)
          {
            v25 = v24;
            do
            {
              v26 = *(__int16 *)(v10 + 2 * v19++);
              *v15++ = v26 >> v18;
              --v25;
            }
            while (v25);
            v16 -= v24;
          }
        }
LABEL_39:
        if ((int)v14 < 4)
        {
          LODWORD(v14) = 0;
        }
        else
        {
          *v15 = v14 + 126;
          v15[1] = *(__int16 *)(v10 + 2 * i) >> v18;
          v15 += 2;
          v16 -= 2;
        }
        v19 += v14;
      }
      while (v19 < v11);
    }
    v17 = v18 - 8;
  }
  while (v18);
  a1[144] = v15;
  a1[145] = a1[141] - v16;
  return 1;
}

uint64_t L16fromY(uint64_t result, float *a2, uint64_t a3)
{
  uint64_t v4;
  _WORD *v5;
  unint64_t v6;
  float v7;

  if (a3 >= 1)
  {
    v4 = result;
    v5 = *(_WORD **)(result + 16);
    v6 = a3 + 1;
    do
    {
      v7 = *a2++;
      result = LogL16fromY(*(_DWORD *)(v4 + 8), v7);
      *v5++ = result;
      --v6;
    }
    while (v6 > 1);
  }
  return result;
}

void TGAWritePlugin::TGAWritePlugin(TGAWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  _QWORD *v3;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 0x1Cu);
  *v3 = &off_1E1BAFCC0;
}

void TGAWritePlugin::~TGAWritePlugin(TGAWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t TGAWritePlugin::writeOneImage(IIOImageWriteSession **this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  _BOOL4 BoolForKey;
  CGBitmapInfo v10;
  unsigned int Uint32ForKey;
  _BOOL4 v12;
  CGColorSpaceRef v13;
  uint32_t v14;
  CGColorSpace *v15;
  int v16;
  CGColorSpace *BaseColorSpace;
  size_t NumberOfComponents;
  size_t ColorTableCount;
  uint8_t *v20;
  CGColorSpace *v21;
  unsigned int v22;
  char v23;
  char v24;
  uint64_t v25;
  size_t v26;
  _BYTE *v27;
  void *v28;
  uint64_t v29;
  unsigned int Height;
  size_t Width;
  _QWORD v33[8];
  uint32_t v34;
  BOOL v35;
  _OWORD v36[14];
  uint64_t v37;
  vImage_CGImageFormat v38;
  _QWORD v39[3];
  uint64_t __ptr;
  uint64_t v41;
  __int16 v42;
  _BYTE v43[768];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  __ptr = 0;
  v41 = 0;
  v42 = 0;
  bzero(v43, 0x300uLL);
  ColorSpace = CGImageGetColorSpace(a2);
  CGColorSpaceGetType();
  Model = CGColorSpaceGetModel(ColorSpace);
  Width = CGImageGetWidth(a2);
  Height = CGImageGetHeight(a2);
  if (!_ImageHasRealAlphaChannel(a2))
  {
    BoolForKey = 0;
    goto LABEL_6;
  }
  if (IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationAllowAlpha")))
  {
    BoolForKey = IIODictionary::getBoolForKey(a3, CFSTR("kCGImageDestinationAllowAlpha"));
    if (BoolForKey)
      goto LABEL_8;
LABEL_6:
    v10 = 0;
    goto LABEL_9;
  }
  BoolForKey = 1;
LABEL_8:
  v10 = 3;
LABEL_9:
  if (IIODictionary::containsKey(a3, CFSTR("Compression")))
  {
    Uint32ForKey = IIODictionary::getUint32ForKey(a3, CFSTR("Compression"));
LABEL_13:
    v12 = Uint32ForKey != 0;
    goto LABEL_15;
  }
  if (IIODictionary::containsKeyGroup(a3, CFSTR("Compression"), CFSTR("{TGA}")))
  {
    Uint32ForKey = IIODictionary::getUint32ForKeyGroup(a3, CFSTR("Compression"), CFSTR("{TGA}"));
    goto LABEL_13;
  }
  v12 = 1;
LABEL_15:
  if (Model == kCGColorSpaceModelRGB)
  {
    v15 = 0;
    if (BoolForKey)
      v14 = 32;
    else
      v14 = 24;
  }
  else
  {
    if (Model)
    {
      if (BoolForKey)
        v14 = 32;
      else
        v14 = 24;
      v13 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
      ColorSpace = v13;
    }
    else
    {
      v13 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
      ColorSpace = v13;
      v10 = 0;
      v14 = 8;
    }
    v15 = v13;
  }
  memset(v39, 0, sizeof(v39));
  IIODictionary::IIODictionary((IIODictionary *)v39);
  IIODictionary::setObjectForKey((IIODictionary *)v39, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("UseIndexedColorIfAvailable"));
  v38.bitsPerComponent = 8;
  v38.bitsPerPixel = v14;
  v38.colorSpace = ColorSpace;
  v38.bitmapInfo = v10;
  memset(&v38.version, 0, 20);
  v37 = 0;
  memset(v36, 0, sizeof(v36));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v36, a2, &v38, (IIODictionary *)v39);
  v16 = IIOPixelProvider::enableIndexColorPassThrough((IIOPixelProvider *)v36);
  if (v16)
  {
    BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
    NumberOfComponents = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
    ColorTableCount = CGColorSpaceGetColorTableCount(ColorSpace);
    v20 = (uint8_t *)malloc_type_malloc(ColorTableCount * NumberOfComponents, 0x100004077774924uLL);
    CGColorSpaceGetColorTable(ColorSpace, v20);
    v21 = CGColorSpaceGetBaseColorSpace(ColorSpace);
    CGColorSpaceGetType();
    CGColorSpaceGetModel(v21);
    *(_WORD *)((char *)&__ptr + 1) = 257;
    v14 = 8;
    v22 = 1;
    v23 = 9;
    if (!v12)
      goto LABEL_29;
    goto LABEL_28;
  }
  v22 = v14 >> 3;
  BYTE1(__ptr) = 0;
  if (Model)
  {
    ColorTableCount = 0;
    v20 = 0;
    BYTE2(__ptr) = 2;
    v23 = 10;
    if (v12)
      goto LABEL_28;
  }
  else
  {
    ColorTableCount = 0;
    v20 = 0;
    BYTE2(__ptr) = 3;
    v23 = 11;
    if (v12)
LABEL_28:
      BYTE2(__ptr) = v23;
  }
LABEL_29:
  if (v16)
  {
    *(_WORD *)((char *)&__ptr + 5) = ColorTableCount;
    HIBYTE(__ptr) = 24;
  }
  WORD2(v41) = Width;
  HIWORD(v41) = Height;
  LOBYTE(v42) = v14;
  if (v14 == 32)
    v24 = 40;
  else
    v24 = 32;
  HIBYTE(v42) = v24;
  if (IIOImageWriteSession::putBytes(this[2], &__ptr, 0x12uLL) == 18)
  {
    if (!ColorTableCount)
      goto LABEL_39;
    v25 = 0;
    v26 = ColorTableCount;
    do
    {
      v27 = &v43[v25];
      *v27 = v20[v25];
      v27[1] = v20[v25 + 1];
      v27[2] = v20[v25 + 2];
      v25 += 3;
      --v26;
    }
    while (v26);
    if (IIOImageWriteSession::putBytes(this[2], v43, 3 * ColorTableCount) != 3 * ColorTableCount)
    {
      v28 = 0;
      v29 = 4294967246;
    }
    else
    {
LABEL_39:
      if (v12)
        v28 = malloc_type_malloc(Width + Width * v22, 0xA04B6A47uLL);
      else
        v28 = 0;
      v33[0] = MEMORY[0x1E0C809B0];
      v33[1] = 0x40000000;
      v33[2] = ___ZN14TGAWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke;
      v33[3] = &__block_descriptor_tmp_45;
      v34 = v14;
      v35 = v12;
      v33[4] = this;
      v33[5] = v28;
      v33[6] = Width;
      v33[7] = v22;
      v29 = IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v36, 0, Height, 64, (uint64_t)v33);
      if (!v20)
      {
LABEL_46:
        if (!v28)
          goto LABEL_48;
        goto LABEL_47;
      }
    }
  }
  else
  {
    v28 = 0;
    v29 = 4294967246;
    if (!v20)
      goto LABEL_46;
  }
  free(v20);
  if (v28)
LABEL_47:
    free(v28);
LABEL_48:
  if (v15)
    CGColorSpaceRelease(v15);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v36);
  IIODictionary::~IIODictionary((IIODictionary *)v39);
  return v29;
}

void sub_188043830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)&a21);
  IIODictionary::~IIODictionary((IIODictionary *)&a56);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14TGAWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke(uint64_t result, int a2, vImage_Buffer *src, _BYTE *a4)
{
  vImage_Buffer *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  vImagePixelCount v9;
  char *v10;
  char *v11;
  int v12;
  size_t v13;
  unint64_t v14;
  uint64_t v15;
  unsigned __int8 v16;
  char *v17;
  int v18;
  char *v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  const void *v27;
  size_t v28;
  _BYTE *v29;
  uint64_t v30;
  vImage_Buffer *v31;
  vImagePixelCount v32;
  int __dst;
  uint8_t v34[4];
  uint8_t permuteMap[2];
  char v36;

  v5 = src;
  v6 = result;
  v7 = *(_QWORD *)(result + 32);
  v8 = *(_DWORD *)(result + 64);
  if (v8 == 32)
  {
    *(_DWORD *)v34 = 50331906;
    result = vImagePermuteChannels_ARGB8888(src, src, v34, 0);
  }
  else if (v8 == 24)
  {
    v36 = 0;
    *(_WORD *)permuteMap = 258;
    result = vImagePermuteChannels_RGB888(src, src, permuteMap, 0);
  }
  if (!*(_BYTE *)(v6 + 68))
    return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v7 + 16), v5->data, v5->height * v5->rowBytes);
  v29 = a4;
  if (!v5->height)
    return result;
  v9 = 0;
  v30 = v7;
  v31 = v5;
  do
  {
    v10 = (char *)v5->data + v5->rowBytes * v9;
    __dst = 0;
    v11 = *(char **)(v6 + 40);
    if (*(_QWORD *)(v6 + 48) < 2uLL)
    {
      v16 = 1;
      goto LABEL_30;
    }
    v32 = v9;
    LOBYTE(v12) = 0;
    v13 = *(_QWORD *)(v6 + 56);
    v14 = 1;
    v15 = 0x100000000;
    v16 = 1;
    v17 = v10;
    do
    {
      memcpy(&__dst, v17, v13);
      v17 = &v10[v13 * v14];
      v18 = memcmp(&__dst, v17, v13);
      if ((_BYTE)v12)
      {
        if (!v18 && v12 <= 0x7Eu)
        {
          LOBYTE(v12) = v12 + 1;
          goto LABEL_25;
        }
        *v11 = v12 ^ 0x80;
        v19 = v11 + 1;
        memcpy(v19, &__dst, *(_QWORD *)(v6 + 56));
        LOBYTE(v12) = 0;
        v13 = *(_QWORD *)(v6 + 56);
        v11 = &v19[v13];
      }
      else
      {
        if (v18 && (v16 & 0x80) == 0)
        {
          LOBYTE(v12) = 0;
          ++v16;
          goto LABEL_25;
        }
        v12 = v18 == 0;
        if (v12 == v16)
        {
          LOBYTE(v12) = v16;
        }
        else
        {
          LOBYTE(v20) = v16 - v12;
          v21 = v16 - v12 - 1;
          v22 = (v16 - v12);
          *v11 = v21;
          v23 = v11 + 1;
          if (v18)
            v20 = v20;
          else
            v20 = v20 + 1;
          memcpy(v23, &v10[*(_QWORD *)(v6 + 56) * ((v15 - (v20 << 32)) >> 32)], *(_QWORD *)(v6 + 56) * v22);
          v13 = *(_QWORD *)(v6 + 56);
          v11 = &v23[v13 * v22];
        }
      }
      v16 = 1;
LABEL_25:
      ++v14;
      v15 += 0x100000000;
    }
    while (*(_QWORD *)(v6 + 48) > v14);
    if ((_BYTE)v12)
    {
      *v11 = v12 ^ 0x80;
      v24 = v11 + 1;
      memcpy(v24, &__dst, *(_QWORD *)(v6 + 56));
      v25 = &v24[*(_QWORD *)(v6 + 56)];
      v7 = v30;
      v5 = v31;
      v9 = v32;
      goto LABEL_31;
    }
    v7 = v30;
    v5 = v31;
    v9 = v32;
LABEL_30:
    *v11 = v16 - 1;
    v26 = v11 + 1;
    memcpy(v26, &v10[(*(_QWORD *)(v6 + 48) - v16) * *(_QWORD *)(v6 + 56)], *(_QWORD *)(v6 + 56) * v16);
    v25 = &v26[*(_QWORD *)(v6 + 56) * v16];
LABEL_31:
    v27 = *(const void **)(v6 + 40);
    v28 = ((_DWORD)v25 - (_DWORD)v27);
    result = IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v7 + 16), v27, v28);
    if (result != v28)
    {
      *v29 = 1;
      return result;
    }
    ++v9;
  }
  while (v5->height > v9);
  return result;
}

void GIFBufferInfo::GIFBufferInfo(GIFBufferInfo *this, unsigned __int8 *a2, int a3, int a4, unsigned int a5, unsigned int a6)
{
  size_t v8;
  void *v9;
  char v10;

  *(_QWORD *)this = &off_1E1BACAA8;
  *((_DWORD *)this + 8) = a5;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 6) = a6;
  *((_DWORD *)this + 7) = a4;
  *((_DWORD *)this + 5) = -1;
  if (a2 && a3)
  {
    v8 = a6 * (unint64_t)a5;
    v9 = malloc_type_malloc(v8, 0xA5603103uLL);
    *((_QWORD *)this + 1) = v9;
    memcpy(v9, a2, v8);
    v10 = 1;
  }
  else
  {
    v10 = 0;
    *((_QWORD *)this + 1) = a2;
  }
  *((_BYTE *)this + 16) = v10;
}

uint64_t GIFBufferInfo::readFromStream(GIFBufferInfo *this, CFReadStreamRef stream)
{
  void *v4;
  UInt8 *v5;
  CFIndex v6;
  size_t size;
  UInt8 buffer[4];

  v4 = (void *)*((_QWORD *)this + 1);
  if (v4)
  {
    if (*((_BYTE *)this + 16))
    {
      free(v4);
      *((_QWORD *)this + 1) = 0;
    }
  }
  *(_DWORD *)buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) == 4)
  {
    if (*(_DWORD *)buffer != 1111902535)
      return 0;
    size = 0;
    if (CFReadStreamRead(stream, (UInt8 *)&size, 8) == 8)
    {
      if (size)
      {
        v5 = (UInt8 *)malloc_type_malloc(size, 0x4995811EuLL);
        *((_QWORD *)this + 1) = v5;
        v6 = CFReadStreamRead(stream, v5, size);
        if (size != v6)
          return 4294967246;
        *((_BYTE *)this + 16) = 1;
      }
      if (CFReadStreamRead(stream, (UInt8 *)this + 20, 20) == 20)
        return 0;
    }
  }
  return 4294967246;
}

void GIFBufferInfo::~GIFBufferInfo(GIFBufferInfo *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E1BACAA8;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    if (*((_BYTE *)this + 16))
      free(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_1E1BACAA8;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    if (*((_BYTE *)this + 16))
      free(v2);
  }
  JUMPOUT(0x18D761C30);
}

uint64_t GIFBufferInfo::writeToStream(GIFBufferInfo *this, CFWriteStreamRef stream)
{
  CFIndex v4;
  const UInt8 *v5;
  BOOL v6;
  CFIndex bufferLength;
  UInt8 buffer[4];

  *(_DWORD *)buffer = 1111902535;
  CFWriteStreamWrite(stream, buffer, 4);
  v4 = *((unsigned int *)this + 6) * (unint64_t)*((unsigned int *)this + 8);
  if (!*((_QWORD *)this + 1))
    v4 = 0;
  bufferLength = v4;
  CFWriteStreamWrite(stream, (const UInt8 *)&bufferLength, 8);
  v5 = (const UInt8 *)*((_QWORD *)this + 1);
  if (v5)
    v6 = bufferLength == 0;
  else
    v6 = 1;
  if (!v6)
    CFWriteStreamWrite(stream, v5, bufferLength);
  CFWriteStreamWrite(stream, (const UInt8 *)this + 20, 20);
  return 0;
}

void GlobalGIFInfo::GlobalGIFInfo(GlobalGIFInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  char *v6;
  char *v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  __CFReadStream *v11;
  __CFReadStream *v12;
  __int128 v13;

  *(_QWORD *)this = &off_1E1BACBE8;
  *(_OWORD *)((char *)this + 136) = 0u;
  v6 = (char *)this + 136;
  v7 = (char *)this + 160;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 72), 0);
  std::vector<GIFFrameInfo>::resize((uint64_t)v6, 0);
  v13 = 0uLL;
  std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>((uint64_t)v7, &v13);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
  if (*((_QWORD *)&v13 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v12 = v11;
  if (v11)
  {
    if (CFReadStreamOpen(v11))
    {
      GlobalGIFInfo::readFromStream(this, v12);
      CFReadStreamClose(v12);
    }
    CFRelease(v12);
  }
}

void sub_188043EEC(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v5;
  void *v6;

  v5 = *(_QWORD *)(v1 + 176);
  *(_QWORD *)(v1 + 176) = 0;
  if (v5)
    std::default_delete<IIOColorMap>::operator()[abi:ne180100](v1 + 176, v5);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v3);
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 144) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t GlobalGIFInfo::readFromStream(GlobalGIFInfo *this, CFReadStreamRef stream)
{
  CFIndex v4;
  uint64_t result;
  CFIndex v6;
  CFIndex v7;
  UInt8 *v8;
  UInt8 *v9;
  IIOColorMap *v10;
  uint64_t v11;
  CFIndex v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  IIOColorMap *v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  UInt8 buffer[4];
  UInt8 v21[8];
  int64_t v22;
  UInt8 v23[8];
  __CFReadStream *v24;

  v24 = stream;
  v22 = 0;
  *(_QWORD *)v23 = 0;
  *(_QWORD *)v21 = 0;
  *(_DWORD *)buffer = 0;
  CFReadStreamRead(stream, buffer, 4);
  if (*(_DWORD *)buffer != 1112493127)
    return 0;
  v4 = CFReadStreamRead(stream, v23, 8);
  result = 4294967260;
  if (v4 == 8 && *(uint64_t *)v23 >= 1)
  {
    v6 = CFReadStreamRead(stream, v21, 8);
    result = 4294967260;
    if (v6 == 8 && (*(_QWORD *)v21 & 0x8000000000000000) == 0)
    {
      v7 = CFReadStreamRead(stream, (UInt8 *)&v22, 8);
      result = 4294967260;
      if (v7 == 8
        && v22 >= 1
        && v22 == *(_QWORD *)v23
        && !__CFADD__(*(_QWORD *)v21, v22)
        && *(_QWORD *)v21 + v22 <= (unint64_t)v22)
      {
        std::vector<GIFFrameInfo>::resize((uint64_t)this + 136, v22);
        if (v22 >= 1)
        {
          v8 = (UInt8 *)(*((_QWORD *)this + 17) + 40 * *(_QWORD *)v21);
          v9 = &v8[40 * v22];
          while (CFReadStreamRead(stream, v8, 40) == 40)
          {
            v8 += 40;
            if (v8 >= v9)
              goto LABEL_15;
          }
          return 4294967260;
        }
LABEL_15:
        v18 = 0;
        v19 = 0;
        std::allocate_shared[abi:ne180100]<GIFBufferInfo,std::allocator<GIFBufferInfo>,__CFReadStream *&,void>(&v24, &v18);
        if (*(unsigned int *)(v18 + 24) * (unint64_t)*(unsigned int *)(v18 + 32))
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
          std::shared_ptr<IIOBaseObject>::operator=[abi:ne180100]((_QWORD *)this + 20, &v18);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 72));
        }
        v10 = (IIOColorMap *)operator new();
        IIOColorMap::IIOColorMap(v10, v24);
        v17 = v10;
        if (*(_DWORD *)v10)
        {
          v11 = *((_QWORD *)this + 22);
          v17 = 0;
          *((_QWORD *)this + 22) = v10;
          if (v11)
            std::default_delete<IIOColorMap>::operator()[abi:ne180100]((uint64_t)this + 176, v11);
        }
        v12 = CFReadStreamRead(v24, (UInt8 *)this + 184, 40);
        v13 = (uint64_t)v17;
        v17 = 0;
        if (v13)
          std::default_delete<IIOColorMap>::operator()[abi:ne180100]((uint64_t)&v17, v13);
        v14 = v19;
        if (v19)
        {
          p_shared_owners = (unint64_t *)&v19->__shared_owners_;
          do
            v16 = __ldaxr(p_shared_owners);
          while (__stlxr(v16 - 1, p_shared_owners));
          if (!v16)
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
        }
        if (v12 != 40)
          return 4294967260;
        return 0;
      }
    }
  }
  return result;
}

void sub_188044180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  uint64_t v11;

  v11 = a9;
  a9 = 0;
  if (v11)
    std::default_delete<IIOColorMap>::operator()[abi:ne180100]((uint64_t)&a9, v11);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t GlobalGIFInfo::getCachedFrameBuffer@<X0>(GlobalGIFInfo *this@<X0>, _QWORD *a2@<X8>)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v4 = (pthread_mutex_t *)((char *)this + 72);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
  v5 = *((_QWORD *)this + 21);
  *a2 = *((_QWORD *)this + 20);
  a2[1] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return pthread_mutex_unlock(v4);
}

void sub_188044238(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t GlobalGIFInfo::setCachedFrameBuffer(uint64_t a1, uint64_t *a2)
{
  pthread_mutex_t *v4;

  v4 = (pthread_mutex_t *)(a1 + 72);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  std::shared_ptr<IIOBaseObject>::operator=[abi:ne180100]((_QWORD *)(a1 + 160), a2);
  return pthread_mutex_unlock(v4);
}

uint64_t GlobalGIFInfo::setColorSyncProfileOffset(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 184) = a2;
  return this;
}

uint64_t GlobalGIFInfo::getSize(uint64_t this, unsigned int *a2, unsigned int *a3)
{
  *a2 = *(_DWORD *)(this + 208);
  *a3 = *(_DWORD *)(this + 212);
  return this;
}

uint64_t GlobalGIFInfo::getMinMaxFrames(uint64_t this, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  int v7;
  int v8;
  int v9;
  int v10;

  v5 = *(unsigned __int16 **)(this + 136);
  v6 = *(unsigned __int16 **)(this + 144);
  if (v5 == v6)
  {
    LOWORD(v8) = 0;
    LOWORD(v7) = 0;
    LOWORD(v10) = 16959;
    LOWORD(v9) = 16959;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    v9 = 999999;
    v10 = 999999;
    do
    {
      if (v10 >= v5[4])
        v10 = v5[4];
      if (v9 >= v5[5])
        v9 = v5[5];
      if (v8 <= v5[6])
        v8 = v5[6];
      if (v7 <= v5[7])
        v7 = v5[7];
      v5 += 20;
    }
    while (v5 != v6);
  }
  *a2 = v10;
  *a3 = v9;
  *a4 = v8;
  *a5 = v7;
  return this;
}

uint64_t GlobalGIFInfo::writeToStream(GlobalGIFInfo *this, CFWriteStreamRef stream, const CFRange *a3)
{
  CFIndex *p_length;
  CFIndex length;
  const UInt8 *v9;
  const UInt8 *v10;
  GIFBufferInfo *v11;
  __CFWriteStream *v12;
  IIOColorMap *v13;
  unint64_t v14;
  UInt8 buffer[4];
  UInt8 v16[4];

  p_length = &a3->length;
  if (a3->location + a3->length > 0xCCCCCCCCCCCCCCCDLL
                                 * ((uint64_t)(*((_QWORD *)this + 18) - *((_QWORD *)this + 17)) >> 3))
    return 4294967246;
  *(_DWORD *)buffer = 1112493127;
  CFWriteStreamWrite(stream, buffer, 4);
  v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)this + 18) - *((_QWORD *)this + 17)) >> 3);
  CFWriteStreamWrite(stream, (const UInt8 *)&v14, 8);
  CFWriteStreamWrite(stream, (const UInt8 *)a3, 8);
  CFWriteStreamWrite(stream, (const UInt8 *)p_length, 8);
  length = a3->length;
  if (length >= 1)
  {
    v9 = (const UInt8 *)(*((_QWORD *)this + 17) + 40 * a3->location);
    v10 = &v9[40 * length];
    do
    {
      CFWriteStreamWrite(stream, v9, 40);
      v9 += 40;
    }
    while (v9 < v10);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
  v11 = (GIFBufferInfo *)*((_QWORD *)this + 20);
  if (v11)
  {
    GIFBufferInfo::writeToStream(v11, stream);
  }
  else
  {
    *(_DWORD *)v16 = 1650878823;
    CFWriteStreamWrite(stream, v16, 4);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 72));
  v13 = (IIOColorMap *)*((_QWORD *)this + 22);
  if (v13)
    IIOColorMap::writeToStream(v13, stream);
  else
    IIOColorMap::writeEmptyPlaceholderToStream(stream, v12);
  CFWriteStreamWrite(stream, (const UInt8 *)this + 184, 40);
  return 0;
}

CFTypeRef GlobalGIFInfo::createDataRepresentation(GlobalGIFInfo *this, const CFRange *a2)
{
  __CFWriteStream *v4;
  __CFWriteStream *v5;
  CFTypeRef v6;

  v4 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (!v4)
    return 0;
  v5 = v4;
  if (CFWriteStreamOpen(v4))
  {
    GlobalGIFInfo::writeToStream(this, v5, a2);
    v6 = CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
    CFWriteStreamClose(v5);
  }
  else
  {
    v6 = 0;
  }
  CFRelease(v5);
  return v6;
}

void std::default_delete<IIOColorMap>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (a2)
  {
    v2 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 16) = 0;
    if (v2)
      MEMORY[0x18D761C18](v2, 0x1000C8033FC2DF1);
    JUMPOUT(0x18D761C30);
  }
}

void std::vector<GIFFrameInfo>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 40 * ((40 * a2 - 40) / 0x28) + 40;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - (_BYTE *)*a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (_BYTE *)*a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x333333333333333)
      v11 = 0x666666666666666;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[40 * v8];
    v15 = &v12[40 * v11];
    v16 = 40 * ((40 * a2 - 40) / 0x28) + 40;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 40);
        v21 = *(_OWORD *)(v18 - 24);
        *((_QWORD *)v14 - 1) = *((_QWORD *)v18 - 1);
        *(_OWORD *)(v14 - 24) = v21;
        *(_OWORD *)(v14 - 40) = v20;
        v14 -= 40;
        v18 -= 40;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

uint64_t std::allocate_shared[abi:ne180100]<GIFBufferInfo,std::allocator<GIFBufferInfo>,__CFReadStream *&,void>@<X0>(__CFReadStream **a1@<X1>, _QWORD *a2@<X8>)
{
  char *v4;
  uint64_t result;

  v4 = (char *)operator new(0x40uLL);
  result = std::__shared_ptr_emplace<GIFBufferInfo>::__shared_ptr_emplace[abi:ne180100]<__CFReadStream *&,std::allocator<GIFBufferInfo>,0>((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_188044774(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<GIFBufferInfo>::__shared_ptr_emplace[abi:ne180100]<__CFReadStream *&,std::allocator<GIFBufferInfo>,0>(uint64_t a1, __CFReadStream **a2)
{
  __CFReadStream *v3;

  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)a1 = &off_1E1BBC298;
  v3 = *a2;
  *(_QWORD *)(a1 + 24) = &off_1E1BACAA8;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_OWORD *)(a1 + 44) = 0u;
  GIFBufferInfo::readFromStream((GIFBufferInfo *)(a1 + 24), v3);
  return a1;
}

void sub_1880447E0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<GIFBufferInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E1BBC298;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<GIFBufferInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E1BBC298;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x18D761C30);
}

uint64_t std::__shared_ptr_emplace<GIFBufferInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

unint64_t XXH64(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v4 = a1;
  if (a2 < 0x20)
  {
    v13 = a3 + 0x27D4EB2F165667C5;
  }
  else
  {
    v5 = (unint64_t)a1 + a2 - 32;
    v6 = a3 + 0x60EA27EEADC0B5D6;
    v7 = a3 - 0x3D4D51C2D82B14B1;
    v8 = a3 + 0x61C8864E7A143579;
    do
    {
      v9 = __ROR8__(v6 - 0x3D4D51C2D82B14B1 * *v4, 33);
      v6 = 0x9E3779B185EBCA87 * v9;
      v10 = __ROR8__(v7 - 0x3D4D51C2D82B14B1 * v4[1], 33);
      v7 = 0x9E3779B185EBCA87 * v10;
      v11 = __ROR8__(a3 - 0x3D4D51C2D82B14B1 * v4[2], 33);
      a3 = 0x9E3779B185EBCA87 * v11;
      v12 = __ROR8__(v8 - 0x3D4D51C2D82B14B1 * v4[3], 33);
      v8 = 0x9E3779B185EBCA87 * v12;
      v4 += 4;
    }
    while ((unint64_t)v4 <= v5);
    v13 = 0x9E3779B185EBCA87
        * ((0x9E3779B185EBCA87
          * ((0x9E3779B185EBCA87
            * ((0x9E3779B185EBCA87
              * ((__ROR8__(v7, 57) + __ROR8__(v6, 63) + __ROR8__(a3, 52) + __ROR8__(v8, 46)) ^ (0x9E3779B185EBCA87
                                                                                              * __ROR8__(0xDEF35B010F796CA9* v9, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v10, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v11, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v12, 33)))- 0x7A1435883D4D519DLL;
  }
  return XXH64_finalize(v13 + a2, v4, a2);
}

void *XXH64_createState()
{
  return malloc_type_malloc(0x58uLL, 0x5F4BD4DCuLL);
}

uint64_t XXH64_freeState(void *a1)
{
  free(a1);
  return 0;
}

uint64_t XXH64_reset(uint64_t a1, unint64_t a2)
{
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a1 = 0;
  *(int64x2_t *)(a1 + 8) = vaddq_s64(vdupq_n_s64(a2), (int64x2_t)xmmword_18822D550);
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a2 + 0x61C8864E7A143579;
  *(_OWORD *)(a1 + 40) = v3;
  *(_OWORD *)(a1 + 56) = v4;
  *(_QWORD *)(a1 + 72) = 0;
  return 0;
}

uint64_t XXH64_update(uint64_t a1, char *__src, size_t __n)
{
  int v3;
  char *v4;
  uint64_t v6;
  size_t v7;
  uint64_t result;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  if (!__src)
    return 1;
  v3 = __n;
  v4 = __src;
  *(_QWORD *)a1 += __n;
  v6 = *(unsigned int *)(a1 + 72);
  if (v6 + __n <= 0x1F)
  {
    memcpy((void *)(a1 + v6 + 40), __src, __n);
    LODWORD(v7) = *(_DWORD *)(a1 + 72) + v3;
LABEL_13:
    result = 0;
    *(_DWORD *)(a1 + 72) = v7;
    return result;
  }
  v9 = &__src[__n];
  if ((_DWORD)v6)
  {
    memcpy((void *)(a1 + 40 + v6), __src, (32 - v6));
    v10 = __ROR8__(*(_QWORD *)(a1 + 16) - 0x3D4D51C2D82B14B1 * *(_QWORD *)(a1 + 48), 33);
    *(_QWORD *)(a1 + 8) = 0x9E3779B185EBCA87
                        * __ROR8__(*(_QWORD *)(a1 + 8) - 0x3D4D51C2D82B14B1 * *(_QWORD *)(a1 + 40), 33);
    *(_QWORD *)(a1 + 16) = 0x9E3779B185EBCA87 * v10;
    v11 = 0x9E3779B185EBCA87 * __ROR8__(*(_QWORD *)(a1 + 32) - 0x3D4D51C2D82B14B1 * *(_QWORD *)(a1 + 64), 33);
    *(_QWORD *)(a1 + 24) = 0x9E3779B185EBCA87
                         * __ROR8__(*(_QWORD *)(a1 + 24) - 0x3D4D51C2D82B14B1 * *(_QWORD *)(a1 + 56), 33);
    *(_QWORD *)(a1 + 32) = v11;
    v4 += (32 - *(_DWORD *)(a1 + 72));
    *(_DWORD *)(a1 + 72) = 0;
  }
  if (v4 + 32 <= v9)
  {
    v12 = *(_QWORD *)(a1 + 8);
    v13 = *(_QWORD *)(a1 + 16);
    v15 = *(_QWORD *)(a1 + 24);
    v14 = *(_QWORD *)(a1 + 32);
    do
    {
      v12 = 0x9E3779B185EBCA87 * __ROR8__(v12 - 0x3D4D51C2D82B14B1 * *(_QWORD *)v4, 33);
      v13 = 0x9E3779B185EBCA87 * __ROR8__(v13 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 1), 33);
      v15 = 0x9E3779B185EBCA87 * __ROR8__(v15 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 2), 33);
      v14 = 0x9E3779B185EBCA87 * __ROR8__(v14 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 3), 33);
      v4 += 32;
    }
    while (v4 <= v9 - 32);
    *(_QWORD *)(a1 + 8) = v12;
    *(_QWORD *)(a1 + 16) = v13;
    *(_QWORD *)(a1 + 24) = v15;
    *(_QWORD *)(a1 + 32) = v14;
  }
  if (v4 < v9)
  {
    v7 = v9 - v4;
    memcpy((void *)(a1 + 40), v4, v7);
    goto LABEL_13;
  }
  return 0;
}

unint64_t XXH64_digest(_QWORD *a1)
{
  uint64_t v1;

  if (*a1 < 0x20uLL)
    v1 = a1[3] + 0x27D4EB2F165667C5;
  else
    v1 = 0x9E3779B185EBCA87
       * ((0x9E3779B185EBCA87
         * ((0x9E3779B185EBCA87
           * ((0x9E3779B185EBCA87
             * ((__ROR8__(a1[2], 57) + __ROR8__(a1[1], 63) + __ROR8__(a1[3], 52) + __ROR8__(a1[4], 46)) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[1], 33)))
             - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[2], 33)))
           - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[3], 33)))
         - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[4], 33)))
       - 0x7A1435883D4D519DLL;
  return XXH64_finalize(v1 + *a1, a1 + 5, *a1);
}

unint64_t XXH64_finalize(unint64_t a1, uint64_t *a2, char a3)
{
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;

  v3 = a3 & 0x1F;
  if (v3 >= 8)
  {
    do
    {
      v4 = *a2++;
      a1 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579 * __ROR8__((0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * v4, 33)) ^ a1, 37);
      v3 -= 8;
    }
    while (v3 > 7);
  }
  if (v3 >= 4)
  {
    v5 = *(_DWORD *)a2;
    a2 = (uint64_t *)((char *)a2 + 4);
    a1 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * v5) ^ a1, 41);
    v3 -= 4;
  }
  for (; v3; --v3)
  {
    v6 = *(unsigned __int8 *)a2;
    a2 = (uint64_t *)((char *)a2 + 1);
    a1 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v6) ^ a1, 53);
  }
  v7 = 0x165667B19E3779F9
     * ((0xC2B2AE3D27D4EB4FLL * (a1 ^ (a1 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (a1 ^ (a1 >> 33))) >> 29));
  return v7 ^ HIDWORD(v7);
}

void _MPEntry::_MPEntry(_MPEntry *this, unsigned __int8 *a2, unsigned int a3, char a4)
{
  IIOScanner *v8;
  IIODictionary *v9;
  signed int Val32;
  int16x8_t v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  int v18;
  const __CFString *v19;

  *(_QWORD *)this = &off_1E1BB2E88;
  v8 = (IIOScanner *)operator new();
  IIOScanner::IIOScanner(v8, a2, a3, a4);
  *((_QWORD *)this + 6) = v8;
  v9 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v9);
  *((_QWORD *)this + 5) = v9;
  Val32 = IIOScanner::getVal32(*((IIOScanner **)this + 6));
  *((_BYTE *)this + 8) = Val32 < 0;
  v11 = (int16x8_t)vshlq_u32((uint32x4_t)vdupq_n_s32(Val32), (uint32x4_t)xmmword_18822D560);
  *(int8x8_t *)v11.i8 = vand_s8((int8x8_t)vmovn_s32((int32x4_t)v11), (int8x8_t)0x7000300010001);
  *(_DWORD *)((char *)this + 9) = vmovn_s16(v11).u32[0];
  *(_DWORD *)((char *)this + 13) = Val32 & 0xFFFFFF;
  v12 = (const void *)*MEMORY[0x1E0C9AE50];
  v13 = (const void *)*MEMORY[0x1E0C9AE40];
  if (Val32 >= 0)
    v14 = (const void *)*MEMORY[0x1E0C9AE40];
  else
    v14 = (const void *)*MEMORY[0x1E0C9AE50];
  IIODictionary::setObjectForKey(*((IIODictionary **)this + 5), v14, CFSTR("DependentParentImageFlag"));
  if (*((_BYTE *)this + 9))
    v15 = v12;
  else
    v15 = v13;
  IIODictionary::setObjectForKey(*((IIODictionary **)this + 5), v15, CFSTR("DependentChildImageFlag"));
  if (*((_BYTE *)this + 10))
    v16 = v12;
  else
    v16 = v13;
  IIODictionary::setObjectForKey(*((IIODictionary **)this + 5), v16, CFSTR("RepresentativeImageFlag"));
  if (*((_BYTE *)this + 12))
    v17 = v13;
  else
    v17 = v12;
  IIODictionary::setObjectForKey(*((IIODictionary **)this + 5), v17, CFSTR("ImageDataFormatIsJPEG"));
  v18 = *(_DWORD *)((char *)this + 13);
  if (v18 > 131073)
  {
    switch(v18)
    {
      case 131074:
        v19 = CFSTR("Multi-Frame Image Disparity");
        goto LABEL_26;
      case 131075:
        v19 = CFSTR("Multi-Frame Image Multi-Angle");
        goto LABEL_26;
      case 196608:
        v19 = CFSTR("Baseline MP Primary image");
        goto LABEL_26;
    }
  }
  else
  {
    switch(v18)
    {
      case 65537:
        v19 = CFSTR("Large Thumbnail: class 1");
        goto LABEL_26;
      case 65538:
        v19 = CFSTR("Large Thumbnail: class 2");
        goto LABEL_26;
      case 131073:
        v19 = CFSTR("Multi-Frame Image Panorama");
LABEL_26:
        IIODictionary::setObjectForKey(*((IIODictionary **)this + 5), v19, CFSTR("Type"));
        break;
    }
  }
  *(_DWORD *)((char *)this + 17) = IIOScanner::getVal32(*((IIOScanner **)this + 6));
  *(_QWORD *)((char *)this + 21) = IIOScanner::getVal32(*((IIOScanner **)this + 6));
  *(_WORD *)((char *)this + 29) = IIOScanner::getVal16(*((IIOScanner **)this + 6));
  *(_WORD *)((char *)this + 31) = IIOScanner::getVal16(*((IIOScanner **)this + 6));
}

void sub_188044FCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void _MPEntry::_MPEntry(_MPEntry *this, __CFReadStream *a2)
{
  int v2;
  int v3;
  _DWORD *exception;

  *(_QWORD *)this = &off_1E1BB2E88;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  v2 = _MPEntry::readFromStream(this, a2);
  if (v2)
  {
    v3 = v2;
    exception = __cxa_allocate_exception(4uLL);
    *exception = v3;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
}

uint64_t _MPEntry::readFromStream(_MPEntry *this, CFReadStreamRef stream)
{
  UInt8 *v4;
  UInt8 *v5;
  CFIndex v6;
  const __CFAllocator *v7;
  const __CFData *v8;
  const __CFData *v9;
  __CFDictionary *v10;
  __CFDictionary *v11;
  IIODictionary *v12;
  CFErrorRef v14;
  UInt8 buffer[8];

  v14 = 0;
  *(_QWORD *)buffer = 0;
  if (CFReadStreamRead(stream, &buffer[4], 4) == 4)
  {
    if (*(_DWORD *)&buffer[4] != 1850036301)
      return 0;
    if (CFReadStreamRead(stream, buffer, 4) == 4)
    {
      if (*(_DWORD *)buffer)
      {
        v4 = (UInt8 *)malloc_type_malloc(*(unsigned int *)buffer, 0x27A10984uLL);
        if (v4)
        {
          v5 = v4;
          v6 = CFReadStreamRead(stream, v4, *(unsigned int *)buffer);
          if (v6 != *(unsigned int *)buffer)
            return 4294967246;
          v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5, v6, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
          if (v8)
          {
            v9 = v8;
            v10 = (__CFDictionary *)CFPropertyListCreateWithData(v7, v8, 0, 0, &v14);
            if (v10)
            {
              v11 = v10;
              v12 = (IIODictionary *)operator new();
              IIODictionary::IIODictionary(v12, v11);
              *((_QWORD *)this + 5) = v12;
              CFRelease(v11);
            }
            CFRelease(v9);
          }
          free(v5);
        }
      }
      if (CFReadStreamRead(stream, (UInt8 *)this + 8, 25) == 25)
        return 0;
    }
  }
  return 4294967246;
}

void sub_1880451D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void _MPEntry::~_MPEntry(_MPEntry *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BB2E88;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 5) = 0;
  *(_DWORD *)((char *)this + 17) = 0;
  v3 = *((_QWORD *)this + 6);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
}

{
  _MPEntry::~_MPEntry(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _MPEntry::imageOffset(_MPEntry *this)
{
  return *(_QWORD *)((char *)this + 21);
}

uint64_t _MPEntry::imageSize(_MPEntry *this)
{
  return *(unsigned int *)((char *)this + 17);
}

void _MPEntry::updataMetadata(_MPEntry *this, unsigned __int8 *a2, unsigned int a3, _TAG *a4, uint64_t a5)
{
  int v10;
  const __CFString *v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int Val32;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[24];
  _OWORD v22[4];
  uint64_t v23;
  _BYTE v24[24];

  v10 = *((unsigned __int16 *)a4 + 20);
  switch(*((_WORD *)a4 + 20))
  {
    case 0xB201:
      v11 = CFSTR("PanOrientation");
      goto LABEL_19;
    case 0xB202:
      v11 = CFSTR("PanOverlap_H");
      goto LABEL_19;
    case 0xB203:
      v11 = CFSTR("PanOverlap_V");
      goto LABEL_19;
    case 0xB204:
      v11 = CFSTR("BaseViewpointNum");
      goto LABEL_19;
    case 0xB205:
      v11 = CFSTR("ConvergenceAngle");
      goto LABEL_19;
    case 0xB206:
      v11 = CFSTR("BaselineLength");
      goto LABEL_19;
    case 0xB207:
      v11 = CFSTR("VerticalDivergence");
      goto LABEL_19;
    case 0xB208:
      v11 = CFSTR("AxisDistance_X");
      goto LABEL_19;
    case 0xB209:
      v11 = CFSTR("AxisDistance_Y");
      goto LABEL_19;
    case 0xB20A:
      v11 = CFSTR("AxisDistance_Z");
      goto LABEL_19;
    case 0xB20B:
      v11 = CFSTR("YawAngle");
      goto LABEL_19;
    case 0xB20C:
      v11 = CFSTR("PitchAngle");
      goto LABEL_19;
    case 0xB20D:
      v11 = CFSTR("RollAngle");
      goto LABEL_19;
    default:
      if (v10 == 45056)
      {
        v11 = CFSTR("MPFVersion");
      }
      else
      {
        if (v10 != 45313)
          return;
        v11 = CFSTR("MPIndividualNum");
      }
LABEL_19:
      v12 = (*(uint64_t (**)(_TAG *))(*(_QWORD *)a4 + 48))(a4);
      v13 = (*(uint64_t (**)(_TAG *))(*(_QWORD *)a4 + 56))(a4);
      v14 = _TAG::nativeDataOrOffset(a4);
      if (v12 == 1)
      {
        v15 = v14;
        if (v13 == 10 || v13 == 5)
        {
          v23 = 0;
          memset(v22, 0, sizeof(v22));
          IIOScanner::IIOScanner((IIOScanner *)v22, a2, a3, *(_BYTE *)(*((_QWORD *)this + 6) + 68));
          IIOScanner::seek((IIOScanner *)v22, v15 + a5);
          Val32 = IIOScanner::getVal32((IIOScanner *)v22);
          v18 = IIOScanner::getVal32((IIOScanner *)v22);
          if (v18)
          {
            v19 = *((_QWORD *)this + 5);
            IIONumber::IIONumber((IIONumber *)v21, (double)Val32 / (double)v18);
            IIODictionary::setObjectForKey(v19, (uint64_t)v21, v11);
            IIONumber::~IIONumber((IIONumber *)v21);
          }
          IIOScanner::~IIOScanner((IIOScanner *)v22);
        }
        else if (v13 == 4)
        {
          v20 = *((_QWORD *)this + 5);
          IIONumber::IIONumber((IIONumber *)v24, v14);
          IIODictionary::setObjectForKey(v20, (uint64_t)v24, v11);
          IIONumber::~IIONumber((IIONumber *)v24);
        }
      }
      return;
  }
}

void sub_1880454C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIONumber::~IIONumber((IIONumber *)(v1 - 88));
  _Unwind_Resume(a1);
}

uint64_t _MPEntry::writeToStream(_MPEntry *this, CFWriteStreamRef stream)
{
  const __CFData *v4;
  const __CFData *v5;
  const UInt8 *BytePtr;
  int v8;
  UInt8 buffer[4];
  CFErrorRef error;

  error = 0;
  v8 = 1850036301;
  CFWriteStreamWrite(stream, (const UInt8 *)&v8, 4);
  v4 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFPropertyListRef *)(*((_QWORD *)this + 5) + 8), kCFPropertyListXMLFormat_v1_0, 0, &error);
  if (v4)
  {
    v5 = v4;
    *(_DWORD *)buffer = CFDataGetLength(v4);
    CFWriteStreamWrite(stream, buffer, 4);
    if (*(_DWORD *)buffer)
    {
      BytePtr = CFDataGetBytePtr(v5);
      CFWriteStreamWrite(stream, BytePtr, *(unsigned int *)buffer);
    }
    CFWriteStreamWrite(stream, (const UInt8 *)this + 8, 25);
    CFRelease(v5);
  }
  return 0;
}

void _MPExtension::_MPExtension(_MPExtension *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  uint64_t v8;

  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(_QWORD *)v8 = &off_1E1BAC410;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  std::vector<_APPx *>::resize(v8 + 88, 0);
  *((_BYTE *)this + 73) = 1;
}

void sub_18804562C(_Unwind_Exception *a1)
{
  _APPx *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *((_QWORD *)v1 + 12) = v4;
    operator delete(v4);
  }
  _APPx::~_APPx(v1);
  _Unwind_Resume(a1);
}

void _MPExtension::~_MPExtension(_MPExtension *this)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;

  *(_QWORD *)this = &off_1E1BAC410;
  v2 = *((_QWORD *)this + 10);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 10) = 0;
  v3 = (_QWORD *)*((_QWORD *)this + 11);
  v4 = (_QWORD *)*((_QWORD *)this + 12);
  if (v3 != v4)
  {
    do
    {
      if (*v3)
        (*(void (**)(_QWORD))(*(_QWORD *)*v3 + 8))(*v3);
      ++v3;
    }
    while (v3 != v4);
    v3 = (_QWORD *)*((_QWORD *)this + 11);
  }
  *((_QWORD *)this + 12) = v3;
  if (v3)
    operator delete(v3);
  _APPx::~_APPx(this);
}

{
  _MPExtension::~_MPExtension(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _MPExtension::getShortBE(_MPExtension *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *((_QWORD *)this + 3);
  v2 = v1 + 2;
  v3 = *((_QWORD *)this + 6);
  if (v1 + 2 >= v3)
  {
    _cg_jpeg_mem_term("getShortBE", 303, "out-of-bounds-read: _pos = %d   _jpegDataSize = %d\n", v1, v3);
    return 0;
  }
  else
  {
    v4 = bswap32(*(unsigned __int16 *)(*((_QWORD *)this + 5) + v1)) >> 16;
    *((_QWORD *)this + 3) = v2;
  }
  return v4;
}

void _MPExtension::processData(_MPExtension *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  _TAGList *v5;
  unsigned int v6;
  unsigned int v7;
  char **v8;
  _TAG *v9;
  unsigned __int16 *v10;
  __n128 inserted;
  int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  _MPEntry *v22;
  unint64_t v23;
  _MPEntry **v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  _MPEntry **v31;
  char *v32;
  char *v33;
  _MPEntry *v34;
  int v35;
  unint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int i;
  _TAG *v41;
  _TAG *v42;
  uint64_t j;
  uint64_t v44;
  unsigned int ShortBE;
  unsigned int v46;
  int v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int k;
  _TAG *v52;
  _TAG *v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;

  _APPx::processData(this);
  v2 = *((_QWORD *)this + 2) + 8;
  *((_QWORD *)this + 3) = v2;
  *((_DWORD *)this + 16) = v2;
  if ((*(unsigned int (**)(_MPExtension *))(*(_QWORD *)this + 104))(this) == 18761)
    *((_BYTE *)this + 32) = 1;
  *((_QWORD *)this + 3) += 2;
  *((_QWORD *)this + 3) = *((_DWORD *)this + 16)
                        + (*(unsigned int (**)(_MPExtension *))(*(_QWORD *)this + 112))(this);
  v3 = (*(uint64_t (**)(_MPExtension *))(*(_QWORD *)this + 104))(this);
  v4 = v3;
  if (!v3 || *((_QWORD *)this + 6) <= (uint64_t)v3)
  {
    _cg_jpeg_mem_term("processData", 526, "*** ERROR: bad idfCount: %d\n", v3);
    return;
  }
  v5 = (_TAGList *)operator new();
  _TAGList::_TAGList(v5, *((_BYTE *)this + 8));
  *((_QWORD *)this + 10) = v5;
  *((_BYTE *)v5 + 40) = *((_BYTE *)this + 32);
  v56 = 0;
  asprintf(&v56, "_MP extension '%04X'", *((unsigned __int16 *)this + 28));
  v6 = 0;
  v7 = 0;
  v8 = (char **)((char *)this + 88);
  *(_QWORD *)(*((_QWORD *)this + 10) + 8) = v56;
  do
  {
    v9 = (_TAG *)(*(uint64_t (**)(_MPExtension *))(*(_QWORD *)this + 120))(this);
    if (!v9)
      goto LABEL_39;
    v10 = (unsigned __int16 *)v9;
    inserted = _TAGList::insertTag((_TAGList *)*((_QWORD *)this + 10), v9);
    v12 = v10[20];
    if (v12 == 45060)
    {
      *((_WORD *)this + 56) = (*(uint64_t (**)(unsigned __int16 *, __n128))(*(_QWORD *)v10 + 64))(v10, inserted);
      goto LABEL_39;
    }
    if (v12 != 45058)
    {
      if (v12 == 45057)
        (*(void (**)(unsigned __int16 *, __n128))(*(_QWORD *)v10 + 64))(v10, inserted);
      goto LABEL_39;
    }
    v13 = (*(uint64_t (**)(unsigned __int16 *, __n128))(*(_QWORD *)v10 + 48))(v10, inserted);
    v6 = v13 >> 4;
    v14 = *((unsigned int *)this + 15);
    if (v13 >> 4 > v14)
    {
      LogError("processData", 385, ":   bad APP2 entry count: '%ld'   APP2 length: '%ld'\n");
LABEL_16:
      std::vector<_APPx *>::resize((uint64_t)this + 88, 0);
      goto LABEL_39;
    }
    if ((unint64_t)(*((_QWORD *)this + 2) + v14) > *((_QWORD *)this + 6))
    {
      LogError("processData", 390, ":   bad APP2 offset: '%ld'   APP2 length: '%ld'    fileSize: '%ld'\n");
      goto LABEL_16;
    }
    v15 = v13;
    v16 = *((_DWORD *)this + 16);
    v17 = _TAG::nativeDataOrOffset((_TAG *)v10);
    if (v15 >= 0x10)
    {
      v18 = 0;
      v19 = *((_DWORD *)this + 15) + *((_DWORD *)this + 4);
      v20 = (v17 + v16);
      while (1)
      {
        v21 = (v20 + 16);
        if (v21 > v19)
          break;
        v22 = (_MPEntry *)operator new();
        _MPEntry::_MPEntry(v22, (unsigned __int8 *)(*((_QWORD *)this + 5) + v20), *((_DWORD *)this + 15) - v20 + *((_DWORD *)this + 4), *((_BYTE *)this + 32));
        v24 = (_MPEntry **)*((_QWORD *)this + 12);
        v23 = *((_QWORD *)this + 13);
        if ((unint64_t)v24 >= v23)
        {
          v26 = ((char *)v24 - *v8) >> 3;
          if ((unint64_t)(v26 + 1) >> 61)
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          v27 = v23 - (_QWORD)*v8;
          v28 = v27 >> 2;
          if (v27 >> 2 <= (unint64_t)(v26 + 1))
            v28 = v26 + 1;
          if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8)
            v29 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v29 = v28;
          if (v29)
            v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 104, v29);
          else
            v30 = 0;
          v31 = (_MPEntry **)&v30[8 * v26];
          *v31 = v22;
          v25 = v31 + 1;
          v33 = (char *)*((_QWORD *)this + 11);
          v32 = (char *)*((_QWORD *)this + 12);
          if (v32 != v33)
          {
            do
            {
              v34 = (_MPEntry *)*((_QWORD *)v32 - 1);
              v32 -= 8;
              *--v31 = v34;
            }
            while (v32 != v33);
            v32 = *v8;
          }
          *((_QWORD *)this + 11) = v31;
          *((_QWORD *)this + 12) = v25;
          *((_QWORD *)this + 13) = &v30[8 * v29];
          if (v32)
            operator delete(v32);
        }
        else
        {
          *v24 = v22;
          v25 = v24 + 1;
        }
        *((_QWORD *)this + 12) = v25;
        ++v18;
        v20 = v21;
        if (v6 <= (unsigned __int16)v18)
          goto LABEL_39;
      }
      LogError("processData", 401, ":   bad APP2 MPEntry offset: '%ld'   fileSize: '%ld'\n", v20, *((_QWORD *)this + 6));
      std::vector<_APPx *>::resize((uint64_t)this + 88, 0);
      v6 = 0;
    }
LABEL_39:
    ++v7;
  }
  while (v7 < v4);
  v35 = (*(uint64_t (**)(_MPExtension *))(*(_QWORD *)this + 112))(this);
  if (v35)
  {
    v36 = (*((_DWORD *)this + 16) + v35);
    if (*((_QWORD *)this + 2) + (unint64_t)*((unsigned int *)this + 15) >= v36)
    {
      *((_QWORD *)this + 3) = v36;
      v37 = (*(uint64_t (**)(_MPExtension *))(*(_QWORD *)this + 104))(this);
      if ((_DWORD)v37)
      {
        v38 = v37;
        v39 = *((unsigned int *)this + 15);
        if (v39 >= v37)
        {
          if (*((_QWORD *)this + 12) != *((_QWORD *)this + 11))
          {
            for (i = 0; i < v38; ++i)
            {
              v41 = (_TAG *)(*(uint64_t (**)(_MPExtension *))(*(_QWORD *)this + 120))(this);
              if (v41)
              {
                v42 = v41;
                _MPEntry::updataMetadata(**((_MPEntry ***)this + 11), *((unsigned __int8 **)this + 5), *((_DWORD *)this + 12), v41, *((unsigned int *)this + 16));
                (*(void (**)(_TAG *))(*(_QWORD *)v42 + 8))(v42);
              }
            }
          }
        }
        else
        {
          LogError("processData", 446, ": ifdCount > _markerLength (%ld > %ld)\n", v37, v39);
        }
      }
    }
  }
  v54 = *((_QWORD *)this + 3);
  if (v6 >= 2)
  {
    v55 = v6;
    for (j = 1; j != v55; ++j)
    {
      *((_QWORD *)this + 3) = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 11) + 8 * j) + 21)
                            + *((unsigned int *)this + 16);
      if (_MPExtension::getShortBE(this) == 65496)
      {
        v44 = *((_QWORD *)this + 3);
        ShortBE = _MPExtension::getShortBE(this);
        if (ShortBE >> 8 >= 0xFF)
        {
          v46 = ShortBE;
          do
          {
            v47 = _MPExtension::getShortBE(this);
            v48 = v44;
            *((_QWORD *)this + 3) = v44;
            if (v46 == 65506 && !strncmp((const char *)(v44 + *((_QWORD *)this + 5) + 4), "MPF", 3uLL))
            {
              *((_QWORD *)this + 3) = v44 + 12;
              *((_QWORD *)this + 3) = (v44 + 8)
                                    + (unint64_t)(*(unsigned int (**)(_MPExtension *))(*(_QWORD *)this + 112))(this);
              v49 = (*(uint64_t (**)(_MPExtension *))(*(_QWORD *)this + 104))(this);
              if (v49)
              {
                v50 = v49;
                for (k = 0; k < v50; ++k)
                {
                  v52 = (_TAG *)(*(uint64_t (**)(_MPExtension *))(*(_QWORD *)this + 120))(this);
                  if (v52)
                  {
                    v53 = v52;
                    _MPEntry::updataMetadata(*(_MPEntry **)(*((_QWORD *)this + 11) + 8 * j), *((unsigned __int8 **)this + 5), *((_DWORD *)this + 12), v52, (v48 + 8));
                    (*(void (**)(_TAG *))(*(_QWORD *)v53 + 8))(v53);
                  }
                }
              }
            }
            v44 = (v48 + v47 + 2);
            *((_QWORD *)this + 3) = v44;
            v46 = _MPExtension::getShortBE(this);
          }
          while (v46 >> 8 > 0xFE);
        }
      }
    }
  }
  *((_QWORD *)this + 3) = v54;
}

void sub_188045D98(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C40D65CC8F0);
  _Unwind_Resume(a1);
}

_TAGList *_MPExtension::dumpTags(_MPExtension *this)
{
  _TAGList *result;
  uint64_t v3;
  uint64_t v4;
  int v5;

  result = (_TAGList *)*((_QWORD *)this + 10);
  if (result)
    result = (_TAGList *)_TAGList::dump(result);
  v3 = *((_QWORD *)this + 11);
  if (*((_QWORD *)this + 12) != v3)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      result = (_TAGList *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 8 * v4) + 16))(*(_QWORD *)(v3 + 8 * v4));
      v4 = (unsigned __int16)++v5;
      v3 = *((_QWORD *)this + 11);
    }
    while ((unsigned __int16)v5 < (unint64_t)((*((_QWORD *)this + 12) - v3) >> 3));
  }
  return result;
}

void _MPExtension::addMetadata(_MPExtension *this, CFMutableArrayRef theArray)
{
  uint64_t v3;
  uint64_t v5;
  int v6;

  if (theArray)
  {
    v3 = *((_QWORD *)this + 11);
    if (*((_QWORD *)this + 12) != v3)
    {
      v5 = 0;
      v6 = 0;
      do
      {
        CFArrayAppendValue(theArray, *(const void **)(*(_QWORD *)(*(_QWORD *)(v3 + 8 * v5) + 40) + 8));
        v5 = (unsigned __int16)++v6;
        v3 = *((_QWORD *)this + 11);
      }
      while ((unsigned __int16)v6 < (unint64_t)((*((_QWORD *)this + 12) - v3) >> 3));
    }
  }
}

void _MPOFile::~_MPOFile(_MPOFile *this)
{
  _JPEGFile::~_JPEGFile(this);
  JUMPOUT(0x18D761C30);
}

__CFArray *_MPOFile::CopyMetadata(_MPOFile *this)
{
  __CFArray *Mutable;
  _MPExtension *v3;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = (_MPExtension *)(*(uint64_t (**)(_MPOFile *))(*(_QWORD *)this + 32))(this);
  if (v3)
    _MPExtension::addMetadata(v3, Mutable);
  return Mutable;
}

uint64_t _MPOFile::processData(_MPOFile *this)
{
  uint64_t result;
  uint64_t v3;
  unsigned __int16 v4;
  unsigned int v5;
  _MPExtension *v6;

  *((_QWORD *)this + 5) = 0;
  result = _JPEGFile::getshort(this);
  if ((_DWORD)result == 65496)
  {
    v3 = *((_QWORD *)this + 5);
    result = _JPEGFile::getshort(this);
    if (result >> 8 >= 0xFF)
    {
      v4 = result;
      do
      {
        v5 = _JPEGFile::getshort(this);
        *((_QWORD *)this + 5) = v3;
        if (v4 == 65506 && !strncmp((const char *)(v3 + *((_QWORD *)this + 3) + 4), "MPF", 3uLL))
        {
          v6 = (_MPExtension *)operator new();
          _MPExtension::_MPExtension(v6, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), *((_QWORD *)this + 5), 65506, v5, *((_BYTE *)this + 96));
        }
        else
        {
          v6 = (_MPExtension *)operator new();
          _APPx::_APPx(v6, *((unsigned __int8 **)this + 3), *((_QWORD *)this + 4), *((_QWORD *)this + 5), v4, v5, *((_BYTE *)this + 96));
        }
        (*(void (**)(_MPExtension *))(*(_QWORD *)v6 + 16))(v6);
        _JPEGFile::insertAppMarker(this, v6);
        v3 += v5 + 2;
        *((_QWORD *)this + 5) = v3;
        result = _JPEGFile::getshort(this);
        v4 = result;
      }
      while (result >> 8 > 0xFE);
    }
  }
  return result;
}

void sub_188046080(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C40F187F6C8);
  _Unwind_Resume(a1);
}

uint64_t _MPOFile::findMPExtension(_MPOFile *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;

  v1 = *((_QWORD *)this + 9);
  v2 = *((_QWORD *)this + 10);
  while (v1 != v2)
  {
    result = *(_QWORD *)v1;
    if (*(__int16 *)(*(_QWORD *)v1 + 56) == -30 && *(_BYTE *)(result + 73))
      return result;
    v1 += 8;
  }
  return 0;
}

_TAGList *_MPOFile::dump(_MPOFile *this, const char *a2)
{
  _TAGList *result;

  _JPEGFile::dump((uint64_t)this, a2);
  result = (_TAGList *)(*(uint64_t (**)(_MPOFile *))(*(_QWORD *)this + 32))(this);
  if (result)
    return _MPExtension::dumpTags(result);
  return result;
}

uint64_t globalMPOInfoReleaseProc(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void GlobalMPOInfo::GlobalMPOInfo(GlobalMPOInfo *this)
{
  *(_QWORD *)this = &off_1E1BACC08;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *((_QWORD *)this + 5) = 0;
  std::vector<_APPx *>::resize((uint64_t)this + 24, 0);
  *((_QWORD *)this + 6) = 0;
}

void sub_1880461A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void GlobalMPOInfo::GlobalMPOInfo(GlobalMPOInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  __CFReadStream *v6;
  __CFReadStream *v7;

  *(_QWORD *)this = &off_1E1BACC08;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *((_QWORD *)this + 5) = 0;
  std::vector<_APPx *>::resize((uint64_t)this + 24, 0);
  *((_QWORD *)this + 6) = 0;
  v6 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v7 = v6;
  if (v6)
  {
    if (CFReadStreamOpen(v6))
    {
      GlobalMPOInfo::readFromStream(this, v7);
      CFReadStreamClose(v7);
    }
    CFRelease(v7);
  }
}

void sub_188046270(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GlobalMPOInfo::readFromStream(GlobalMPOInfo *this, CFReadStreamRef stream)
{
  char **v4;
  uint64_t v5;
  _MPEntry *v6;
  unint64_t v7;
  _MPEntry **v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  _MPEntry **v15;
  char *v16;
  char *v17;
  _MPEntry *v18;
  UInt8 buffer[4];
  UInt8 v21[8];

  *(_QWORD *)v21 = 0;
  *(_DWORD *)buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4)
    return 4294967246;
  if (*(_DWORD *)buffer != 1112493127)
    return 0;
  if (CFReadStreamRead(stream, v21, 8) != 8)
    return 4294967246;
  v4 = (char **)((char *)this + 24);
  std::vector<_MPEntry *>::reserve((void **)this + 3, *(unint64_t *)v21);
  if (*(uint64_t *)v21 >= 1)
  {
    LODWORD(v5) = 0;
    do
    {
      v6 = (_MPEntry *)operator new();
      _MPEntry::_MPEntry(v6, stream);
      v8 = (_MPEntry **)*((_QWORD *)this + 4);
      v7 = *((_QWORD *)this + 5);
      if ((unint64_t)v8 >= v7)
      {
        v10 = ((char *)v8 - *v4) >> 3;
        if ((unint64_t)(v10 + 1) >> 61)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v11 = v7 - (_QWORD)*v4;
        v12 = v11 >> 2;
        if (v11 >> 2 <= (unint64_t)(v10 + 1))
          v12 = v10 + 1;
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
          v13 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v13 = v12;
        if (v13)
          v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 40, v13);
        else
          v14 = 0;
        v15 = (_MPEntry **)&v14[8 * v10];
        *v15 = v6;
        v9 = v15 + 1;
        v17 = (char *)*((_QWORD *)this + 3);
        v16 = (char *)*((_QWORD *)this + 4);
        if (v16 != v17)
        {
          do
          {
            v18 = (_MPEntry *)*((_QWORD *)v16 - 1);
            v16 -= 8;
            *--v15 = v18;
          }
          while (v16 != v17);
          v16 = *v4;
        }
        *((_QWORD *)this + 3) = v15;
        *((_QWORD *)this + 4) = v9;
        *((_QWORD *)this + 5) = &v14[8 * v13];
        if (v16)
          operator delete(v16);
      }
      else
      {
        *v8 = v6;
        v9 = v8 + 1;
      }
      *((_QWORD *)this + 4) = v9;
      v5 = (v5 + 1);
    }
    while (*(uint64_t *)v21 > v5);
  }
  if (CFReadStreamRead(stream, (UInt8 *)this + 8, 16) == 16)
    return 0;
  else
    return 4294967246;
}

void GlobalMPOInfo::~GlobalMPOInfo(GlobalMPOInfo *this)
{
  const void *v2;
  _QWORD *v3;
  _QWORD *v4;

  *(_QWORD *)this = &off_1E1BACC08;
  v2 = (const void *)*((_QWORD *)this + 6);
  if (v2)
    CFRelease(v2);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  v4 = (_QWORD *)*((_QWORD *)this + 4);
  if (v3 != v4)
  {
    do
    {
      if (*v3)
        (*(void (**)(_QWORD))(*(_QWORD *)*v3 + 8))(*v3);
      ++v3;
    }
    while (v3 != v4);
    v3 = (_QWORD *)*((_QWORD *)this + 3);
  }
  *((_QWORD *)this + 4) = v3;
  if (v3)
    operator delete(v3);
}

{
  GlobalMPOInfo::~GlobalMPOInfo(this);
  JUMPOUT(0x18D761C30);
}

CFTypeRef GlobalMPOInfo::createDataRepresentation(GlobalMPOInfo *this)
{
  __CFWriteStream *v2;
  __CFWriteStream *v3;
  CFTypeRef v4;

  v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (!v2)
    return 0;
  v3 = v2;
  if (CFWriteStreamOpen(v2))
  {
    GlobalMPOInfo::writeToStream(this, v3);
    v4 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
    CFWriteStreamClose(v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

uint64_t GlobalMPOInfo::writeToStream(GlobalMPOInfo *this, CFWriteStreamRef stream)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v8;
  UInt8 buffer[4];

  *(_DWORD *)buffer = 1112493127;
  CFWriteStreamWrite(stream, buffer, 4);
  v8 = (uint64_t)(*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) >> 3;
  CFWriteStreamWrite(stream, (const UInt8 *)&v8, 8);
  if (v8 >= 1)
  {
    v4 = 0;
    v5 = 1;
    do
    {
      _MPEntry::writeToStream(*(_MPEntry **)(*((_QWORD *)this + 3) + 8 * v4), stream);
      v4 = v5;
    }
    while (v8 > v5++);
  }
  CFWriteStreamWrite(stream, (const UInt8 *)this + 8, 16);
  return 0;
}

void std::vector<_MPEntry *>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_QWORD *)v10 - 1);
        v10 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t GlobalMPOInfo::getEntryAtIndex(GlobalMPOInfo *this, unsigned int a2)
{
  return *(_QWORD *)(*((_QWORD *)this + 3) + 8 * a2);
}

void GlobalMPOInfo::addEntry(GlobalMPOInfo *this, _MPEntry *a2)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = *((_QWORD *)this + 5);
  v4 = (char *)this + 40;
  v5 = v6;
  v7 = (_QWORD *)*((_QWORD *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    v9 = (void **)(v4 - 16);
    v10 = *((_QWORD *)v4 - 2);
    v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v12 = v5 - v10;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v4, v14);
    else
      v15 = 0;
    v16 = &v15[8 * v11];
    v17 = &v15[8 * v14];
    *(_QWORD *)v16 = a2;
    v8 = v16 + 8;
    v19 = (char *)*((_QWORD *)this + 3);
    v18 = (char *)*((_QWORD *)this + 4);
    if (v18 != v19)
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *((_QWORD *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      v18 = (char *)*v9;
    }
    *((_QWORD *)this + 3) = v16;
    *((_QWORD *)this + 4) = v8;
    *((_QWORD *)this + 5) = v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v7 = a2;
    v8 = v7 + 1;
  }
  *((_QWORD *)this + 4) = v8;
}

uint64_t GlobalMPOInfo::getMetadata(GlobalMPOInfo *this)
{
  return *((_QWORD *)this + 6);
}

uint64_t GlobalMPOInfo::getEntryCount(GlobalMPOInfo *this)
{
  return *((unsigned __int16 *)this + 8);
}

uint64_t ExamineMPOFile(IIOImageReadSession *a1)
{
  IIOImageRead *Size;
  uint64_t v3;
  unsigned __int8 *v4;
  _JPEGFile *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD v15[4];
  uint64_t v16;

  Size = IIOImageReadSession::getSize(a1);
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  IIOScanner::IIOScanner((IIOScanner *)v15, a1);
  v3 = 0;
  if ((unint64_t)Size >= 0xC8)
  {
    v3 = (uint64_t)IIOImageReadSession::globalInfoForType(a1, 1297108768);
    if (!v3)
    {
      v3 = operator new();
      GlobalMPOInfo::GlobalMPOInfo((GlobalMPOInfo *)v3);
      IIOImageReadSession::setGlobalInfo((IIOImageRead **)a1, 1297108768, (void *)v3, (void (*)(void *))globalMPOInfoReleaseProc);
    }
    v4 = (unsigned __int8 *)*((_QWORD *)&v15[0] + 1);
    if (*((_QWORD *)&v15[0] + 1))
    {
      v5 = (_JPEGFile *)operator new();
      _JPEGFile::_JPEGFile(v5, v4, (uint64_t)Size, 0, 0);
      *(_QWORD *)v5 = &off_1E1BB2EB0;
      _MPOFile::processData(v5);
      *(_QWORD *)(v3 + 48) = _MPOFile::CopyMetadata(v5);
      v6 = (*(uint64_t (**)(_JPEGFile *))(*(_QWORD *)v5 + 32))(v5);
      v7 = v6;
      if (v6)
      {
        *(_QWORD *)(v3 + 8) = (*(unsigned int (**)(uint64_t))(*(_QWORD *)v6 + 128))(v6);
        v8 = *(_QWORD *)(v7 + 88);
        v9 = *(_QWORD *)(v7 + 96);
        v10 = (_QWORD *)(v7 + 88);
        v11 = v9 - v8;
        *(_WORD *)(v3 + 16) = v11 >> 3;
        if ((v11 & 0x7FFF8) != 0)
        {
          v12 = 0;
          v13 = (unsigned __int16)(v11 >> 3);
          do
            GlobalMPOInfo::addEntry((GlobalMPOInfo *)v3, *(_MPEntry **)(*v10 + 8 * v12++));
          while (v13 != v12);
        }
        std::vector<_APPx *>::resize((uint64_t)v10, 0);
      }
      (*(void (**)(_JPEGFile *))(*(_QWORD *)v5 + 8))(v5);
    }
  }
  IIOScanner::~IIOScanner((IIOScanner *)v15);
  return v3;
}

void sub_1880469A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  MEMORY[0x18D761C30](v9, 0x10A1C4078B77C84);
  IIOScanner::~IIOScanner((IIOScanner *)&a9);
  _Unwind_Resume(a1);
}

uint64_t _MPExtension::mpoBaseOffset(_MPExtension *this)
{
  return *((unsigned int *)this + 16);
}

uint64_t icnsCompare(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  BOOL v10;
  _BOOL4 v11;

  v2 = a1[48];
  v3 = a2[48];
  if (v2 > v3)
    return 1;
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  v5 = *((unsigned __int16 *)a1 + 12);
  v6 = *((unsigned __int16 *)a2 + 12);
  if (v5 > v6)
    return 0xFFFFFFFFLL;
  if (v5 < v6)
    return 1;
  v7 = a1[49];
  v8 = a2[49];
  v9 = v7 >= v8;
  v10 = v7 == v8;
  v11 = v7 < v8;
  if (!v10 && v9)
    return 0xFFFFFFFFLL;
  else
    return v11;
}

void *GetICNSInfoTable(void)
{
  if (GetICNSInfoTable(void)::gIIO_sortIconInfo != -1)
    dispatch_once(&GetICNSInfoTable(void)::gIIO_sortIconInfo, &__block_literal_global_36);
  return &globalIconInfo;
}

void ___Z16GetICNSInfoTablev_block_invoke()
{
  qsort(&globalIconInfo, 0x28uLL, 0x38uLL, (int (__cdecl *)(const void *, const void *))icnsCompare);
}

void GlobalICNSInfo::GlobalICNSInfo(GlobalICNSInfo *this)
{
  char *v1;

  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  v1 = (char *)this + 24;
  *(_OWORD *)this = 0u;
  std::vector<ICNS_INFO>::resize((uint64_t)this, 0);
  std::vector<ICNS_INFO>::resize((uint64_t)v1, 0);
}

void sub_188046B04(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  GlobalICNSInfo::GlobalICNSInfo((void **)v1);
  _Unwind_Resume(a1);
}

void std::vector<ICNS_INFO>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<ICNS_INFO>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 56 * a2;
  }
}

void GlobalICNSInfo::GlobalICNSInfo(GlobalICNSInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  char *v6;
  __CFReadStream *v7;
  __CFReadStream *v8;

  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  v6 = (char *)this + 24;
  *(_OWORD *)this = 0u;
  std::vector<ICNS_INFO>::resize((uint64_t)this, 0);
  std::vector<ICNS_INFO>::resize((uint64_t)v6, 0);
  v7 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v8 = v7;
  if (v7)
  {
    if (CFReadStreamOpen(v7))
    {
      if (GlobalICNSInfo::readFromStream(this, v8))
      {
        *((_QWORD *)this + 1) = *(_QWORD *)this;
        *((_QWORD *)this + 4) = *((_QWORD *)this + 3);
      }
      CFReadStreamClose(v8);
    }
    CFRelease(v8);
  }
}

void sub_188046C2C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  v5 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GlobalICNSInfo::readFromStream(GlobalICNSInfo *this, CFReadStreamRef stream)
{
  char **v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  char *v26;
  int v27;
  unint64_t v28;
  unint64_t v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  char *v42;
  char *v43;
  char *v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  UInt8 v54[4];
  UInt8 buffer[4];

  *(_DWORD *)buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4)
    return 4294967246;
  if (*(_DWORD *)buffer != 1397637961)
    return 0;
  *((_QWORD *)this + 1) = *(_QWORD *)this;
  v4 = (char **)((char *)this + 24);
  *((_QWORD *)this + 4) = *((_QWORD *)this + 3);
  *(_DWORD *)v54 = 0;
  if (CFReadStreamRead(stream, v54, 4) != 4)
    return 4294967246;
  if (*(_DWORD *)v54)
  {
    v5 = 0;
    do
    {
      v53 = 0;
      v51 = 0u;
      v52 = 0u;
      v50 = 0u;
      if (CFReadStreamRead(stream, (UInt8 *)&v50, 56) != 56)
        return 4294967246;
      v6 = *((_QWORD *)this + 1);
      v7 = *((_QWORD *)this + 2);
      if (v6 >= v7)
      {
        v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v6 - *(_QWORD *)this) >> 3);
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) > 0x492492492492492)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - *(_QWORD *)this) >> 3);
        if (2 * v13 > v12)
          v12 = 2 * v13;
        if (v13 >= 0x249249249249249)
          v14 = 0x492492492492492;
        else
          v14 = v12;
        if (v14)
          v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>((uint64_t)this + 16, v14);
        else
          v15 = 0;
        v16 = &v15[56 * v11];
        v17 = v50;
        v18 = v51;
        v19 = v52;
        *((_QWORD *)v16 + 6) = v53;
        *((_OWORD *)v16 + 1) = v18;
        *((_OWORD *)v16 + 2) = v19;
        *(_OWORD *)v16 = v17;
        v21 = *(char **)this;
        v20 = (char *)*((_QWORD *)this + 1);
        v22 = v16;
        if (v20 != *(char **)this)
        {
          do
          {
            v23 = *(_OWORD *)(v20 - 56);
            v24 = *(_OWORD *)(v20 - 40);
            v25 = *(_OWORD *)(v20 - 24);
            *((_QWORD *)v22 - 1) = *((_QWORD *)v20 - 1);
            *(_OWORD *)(v22 - 24) = v25;
            *(_OWORD *)(v22 - 40) = v24;
            *(_OWORD *)(v22 - 56) = v23;
            v22 -= 56;
            v20 -= 56;
          }
          while (v20 != v21);
          v20 = *(char **)this;
        }
        v26 = v16 + 56;
        *(_QWORD *)this = v22;
        *((_QWORD *)this + 1) = v16 + 56;
        *((_QWORD *)this + 2) = &v15[56 * v14];
        if (v20)
          operator delete(v20);
        *((_QWORD *)this + 1) = v26;
      }
      else
      {
        v8 = v50;
        v9 = v51;
        v10 = v52;
        *(_QWORD *)(v6 + 48) = v53;
        *(_OWORD *)(v6 + 16) = v9;
        *(_OWORD *)(v6 + 32) = v10;
        *(_OWORD *)v6 = v8;
        *((_QWORD *)this + 1) = v6 + 56;
      }
    }
    while (++v5 < *(_DWORD *)v54);
  }
  if (CFReadStreamRead(stream, v54, 4) != 4)
    return 4294967246;
  if (*(_DWORD *)v54)
  {
    v27 = 0;
    while (1)
    {
      v53 = 0;
      v51 = 0u;
      v52 = 0u;
      v50 = 0u;
      if (CFReadStreamRead(stream, (UInt8 *)&v50, 56) != 56)
        break;
      v28 = *((_QWORD *)this + 4);
      v29 = *((_QWORD *)this + 5);
      if (v28 >= v29)
      {
        v33 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v28 - (_QWORD)*v4) >> 3);
        v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) > 0x492492492492492)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v35 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v29 - (_QWORD)*v4) >> 3);
        if (2 * v35 > v34)
          v34 = 2 * v35;
        if (v35 >= 0x249249249249249)
          v36 = 0x492492492492492;
        else
          v36 = v34;
        if (v36)
          v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>((uint64_t)this + 40, v36);
        else
          v37 = 0;
        v38 = &v37[56 * v33];
        v39 = v50;
        v40 = v51;
        v41 = v52;
        *((_QWORD *)v38 + 6) = v53;
        *((_OWORD *)v38 + 1) = v40;
        *((_OWORD *)v38 + 2) = v41;
        *(_OWORD *)v38 = v39;
        v43 = (char *)*((_QWORD *)this + 3);
        v42 = (char *)*((_QWORD *)this + 4);
        v44 = v38;
        if (v42 != v43)
        {
          do
          {
            v45 = *(_OWORD *)(v42 - 56);
            v46 = *(_OWORD *)(v42 - 40);
            v47 = *(_OWORD *)(v42 - 24);
            *((_QWORD *)v44 - 1) = *((_QWORD *)v42 - 1);
            *(_OWORD *)(v44 - 24) = v47;
            *(_OWORD *)(v44 - 40) = v46;
            *(_OWORD *)(v44 - 56) = v45;
            v44 -= 56;
            v42 -= 56;
          }
          while (v42 != v43);
          v42 = *v4;
        }
        v48 = v38 + 56;
        *((_QWORD *)this + 3) = v44;
        *((_QWORD *)this + 4) = v38 + 56;
        *((_QWORD *)this + 5) = &v37[56 * v36];
        if (v42)
          operator delete(v42);
        *((_QWORD *)this + 4) = v48;
      }
      else
      {
        v30 = v50;
        v31 = v51;
        v32 = v52;
        *(_QWORD *)(v28 + 48) = v53;
        *(_OWORD *)(v28 + 16) = v31;
        *(_OWORD *)(v28 + 32) = v32;
        *(_OWORD *)v28 = v30;
        *((_QWORD *)this + 4) = v28 + 56;
      }
      if (++v27 >= *(_DWORD *)v54)
        return 0;
    }
    return 4294967246;
  }
  return 0;
}

void GlobalICNSInfo::~GlobalICNSInfo(GlobalICNSInfo *this)
{
  void *v2;
  void *v3;

  std::vector<ICNS_INFO>::resize((uint64_t)this, 0);
  std::vector<ICNS_INFO>::resize((uint64_t)this + 24, 0);
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v3;
    operator delete(v3);
  }
}

CFTypeRef GlobalICNSInfo::createDataRepresentation(GlobalICNSInfo *this)
{
  __CFWriteStream *v2;
  __CFWriteStream *v3;
  CFTypeRef v4;

  v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (!v2)
    return 0;
  v3 = v2;
  if (CFWriteStreamOpen(v2))
  {
    GlobalICNSInfo::writeToStream(this, v3);
    v4 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
    CFWriteStreamClose(v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

uint64_t GlobalICNSInfo::writeToStream(GlobalICNSInfo *this, CFWriteStreamRef stream)
{
  UInt8 buffer[4];
  UInt8 v6[4];

  *(_DWORD *)buffer = 1397637961;
  CFWriteStreamWrite(stream, buffer, 4);
  *(_DWORD *)v6 = -1227133513 * ((*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3);
  CFWriteStreamWrite(stream, v6, 4);
  CFWriteStreamWrite(stream, *(const UInt8 **)this, 56 * *(unsigned int *)v6);
  *(_DWORD *)v6 = -1227133513 * ((*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) >> 3);
  CFWriteStreamWrite(stream, v6, 4);
  CFWriteStreamWrite(stream, *((const UInt8 **)this + 3), 56 * *(unsigned int *)v6);
  return 0;
}

uint64_t GlobalICNSInfo::icnsImageCount(GlobalICNSInfo *this)
{
  return -1227133513 * ((*((_QWORD *)this + 1) - *(_QWORD *)this) >> 3);
}

BOOL GlobalICNSInfo::getICNSImageInfoAtIndex(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v3 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[1] - *a1) >> 3);
  if (v3 > a2)
  {
    v4 = *a1 + 56 * a2;
    v5 = *(_OWORD *)v4;
    v6 = *(_OWORD *)(v4 + 16);
    v7 = *(_OWORD *)(v4 + 32);
    *(_QWORD *)(a3 + 48) = *(_QWORD *)(v4 + 48);
    *(_OWORD *)(a3 + 16) = v6;
    *(_OWORD *)(a3 + 32) = v7;
    *(_OWORD *)a3 = v5;
  }
  return v3 > a2;
}

uint64_t GlobalICNSInfo::getICNSMaskInfoForType(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t i;
  __int128 v5;
  __int128 v6;
  int v7;

  if (!a2)
    return 0;
  for (i = *(_QWORD *)(a1 + 24); ; i += 56)
  {
    if (i == *(_QWORD *)(a1 + 32))
      return 0;
    v6 = *(_OWORD *)(i + 36);
    v7 = *(_DWORD *)(i + 52);
    if (*(_DWORD *)(i + 32) == a2)
      break;
  }
  v5 = *(_OWORD *)(i + 16);
  *(_OWORD *)a3 = *(_OWORD *)i;
  *(_OWORD *)(a3 + 16) = v5;
  *(_DWORD *)(a3 + 32) = a2;
  *(_OWORD *)(a3 + 36) = v6;
  *(_DWORD *)(a3 + 52) = v7;
  return 1;
}

void GlobalICNSInfo::addICNSInfo(void **a1, __int16 *a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  char *v11;
  uint64_t v12;
  _BYTE *v13;
  _BYTE *v14;
  unint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  char *v19;
  void **v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  char *v37;
  char *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  char *v42;
  char *v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  char *v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;

  if (*a2 == -2)
  {
    v6 = a1[5];
    v4 = (uint64_t)(a1 + 5);
    v5 = (uint64_t)v6;
    v7 = *(_QWORD *)(v4 - 8);
    if (v7 >= (unint64_t)v6)
    {
      v20 = (void **)(v4 - 16);
      v21 = *(_QWORD *)(v4 - 16);
      v22 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - v21) >> 3);
      v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) > 0x492492492492492)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v24 = 0x6DB6DB6DB6DB6DB7 * ((v5 - v21) >> 3);
      if (2 * v24 > v23)
        v23 = 2 * v24;
      if (v24 >= 0x249249249249249)
        v25 = 0x492492492492492;
      else
        v25 = v23;
      if (v25)
        v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>(v4, v25);
      else
        v26 = 0;
      v32 = &v26[56 * v22];
      v33 = &v26[56 * v25];
      v34 = *(_OWORD *)a2;
      v35 = *((_OWORD *)a2 + 1);
      v36 = *((_OWORD *)a2 + 2);
      *((_QWORD *)v32 + 6) = *((_QWORD *)a2 + 6);
      *((_OWORD *)v32 + 1) = v35;
      *((_OWORD *)v32 + 2) = v36;
      *(_OWORD *)v32 = v34;
      v11 = v32 + 56;
      v38 = (char *)a1[3];
      v37 = (char *)a1[4];
      if (v37 != v38)
      {
        do
        {
          v39 = *(_OWORD *)(v37 - 56);
          v40 = *(_OWORD *)(v37 - 40);
          v41 = *(_OWORD *)(v37 - 24);
          *((_QWORD *)v32 - 1) = *((_QWORD *)v37 - 1);
          *(_OWORD *)(v32 - 24) = v41;
          *(_OWORD *)(v32 - 40) = v40;
          *(_OWORD *)(v32 - 56) = v39;
          v32 -= 56;
          v37 -= 56;
        }
        while (v37 != v38);
        v37 = (char *)*v20;
      }
      a1[3] = v32;
      a1[4] = v11;
      a1[5] = v33;
      if (v37)
        operator delete(v37);
    }
    else
    {
      v8 = *(_OWORD *)a2;
      v9 = *((_OWORD *)a2 + 1);
      v10 = *((_OWORD *)a2 + 2);
      *(_QWORD *)(v7 + 48) = *((_QWORD *)a2 + 6);
      *(_OWORD *)(v7 + 16) = v9;
      *(_OWORD *)(v7 + 32) = v10;
      *(_OWORD *)v7 = v8;
      v11 = (char *)(v7 + 56);
    }
    a1[4] = v11;
  }
  else
  {
    v14 = a1[2];
    v12 = (uint64_t)(a1 + 2);
    v13 = v14;
    v15 = *(_QWORD *)(v12 - 8);
    if (v15 >= (unint64_t)v14)
    {
      v27 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v15 - (_QWORD)*a1) >> 3);
      v28 = v27 + 1;
      if ((unint64_t)(v27 + 1) > 0x492492492492492)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v29 = 0x6DB6DB6DB6DB6DB7 * ((v13 - (_BYTE *)*a1) >> 3);
      if (2 * v29 > v28)
        v28 = 2 * v29;
      if (v29 >= 0x249249249249249)
        v30 = 0x492492492492492;
      else
        v30 = v28;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>(v12, v30);
      else
        v31 = 0;
      v42 = &v31[56 * v27];
      v43 = &v31[56 * v30];
      v44 = *(_OWORD *)a2;
      v45 = *((_OWORD *)a2 + 1);
      v46 = *((_OWORD *)a2 + 2);
      *((_QWORD *)v42 + 6) = *((_QWORD *)a2 + 6);
      *((_OWORD *)v42 + 1) = v45;
      *((_OWORD *)v42 + 2) = v46;
      *(_OWORD *)v42 = v44;
      v19 = v42 + 56;
      v48 = (char *)*a1;
      v47 = (char *)a1[1];
      if (v47 != *a1)
      {
        do
        {
          v49 = *(_OWORD *)(v47 - 56);
          v50 = *(_OWORD *)(v47 - 40);
          v51 = *(_OWORD *)(v47 - 24);
          *((_QWORD *)v42 - 1) = *((_QWORD *)v47 - 1);
          *(_OWORD *)(v42 - 24) = v51;
          *(_OWORD *)(v42 - 40) = v50;
          *(_OWORD *)(v42 - 56) = v49;
          v42 -= 56;
          v47 -= 56;
        }
        while (v47 != v48);
        v47 = (char *)*a1;
      }
      *a1 = v42;
      a1[1] = v19;
      a1[2] = v43;
      if (v47)
        operator delete(v47);
    }
    else
    {
      v16 = *(_OWORD *)a2;
      v17 = *((_OWORD *)a2 + 1);
      v18 = *((_OWORD *)a2 + 2);
      *(_QWORD *)(v15 + 48) = *((_QWORD *)a2 + 6);
      *(_OWORD *)(v15 + 16) = v17;
      *(_OWORD *)(v15 + 32) = v18;
      *(_OWORD *)v15 = v16;
      v19 = (char *)(v15 + 56);
    }
    a1[1] = v19;
  }
}

void GlobalICNSInfo::sortInfo(void **this)
{
  qsort(*this, 0x6DB6DB6DB6DB6DB7 * (((_BYTE *)this[1] - (_BYTE *)*this) >> 3), 0x38uLL, (int (__cdecl *)(const void *, const void *))icnsCompare);
}

void std::vector<ICNS_INFO>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0x6DB6DB6DB6DB6DB7 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 56 * ((56 * a2 - 56) / 0x38) + 56;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x6DB6DB6DB6DB6DB7 * ((v7 - (_BYTE *)*a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x492492492492492)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v10 = 0x6DB6DB6DB6DB6DB7 * ((v5 - (_BYTE *)*a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x249249249249249)
      v11 = 0x492492492492492;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[56 * v8];
    v15 = &v12[56 * v11];
    v16 = 56 * ((56 * a2 - 56) / 0x38) + 56;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 56);
        v21 = *(_OWORD *)(v18 - 40);
        v22 = *(_OWORD *)(v18 - 24);
        *((_QWORD *)v14 - 1) = *((_QWORD *)v18 - 1);
        *(_OWORD *)(v14 - 24) = v22;
        *(_OWORD *)(v14 - 40) = v21;
        *(_OWORD *)(v14 - 56) = v20;
        v14 -= 56;
        v18 -= 56;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(56 * a2);
}

void OUTLINED_FUNCTION_0_2(void *__p@<X0>, uint64_t a2@<X8>)
{
  *(_QWORD *)(a2 + 8) = __p;
  operator delete(__p);
}

uint64_t PBMReadPlugin::PBMReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v6;

  v6 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)v6 = &off_1E1BAD578;
  *(_OWORD *)(v6 + 440) = 0u;
  *(_OWORD *)(v6 + 456) = 0u;
  *(_QWORD *)(v6 + 472) = 0;
  *(_QWORD *)(a1 + 480) = GetPBMLookupTable();
  return a1;
}

void sub_1880477E8(_Unwind_Exception *a1)
{
  IIOReadPlugin *v1;

  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

uint64_t PBMReadPlugin::PBMReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;

  v4 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v4 = &off_1E1BAD578;
  *(_OWORD *)(v4 + 440) = 0u;
  *(_OWORD *)(v4 + 456) = 0u;
  *(_QWORD *)(v4 + 472) = 0;
  *(_QWORD *)(a1 + 480) = GetPBMLookupTable();
  return a1;
}

void sub_188047848(_Unwind_Exception *a1)
{
  IIOReadPlugin *v1;

  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void PBMReadPlugin::~PBMReadPlugin(PBMReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t PBMReadPlugin::readChar(PBMReadPlugin *this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v7;

  v1 = *((_QWORD *)this + 61);
  if (v1)
  {
    v2 = *((_QWORD *)this + 59);
    v3 = v2 + 1;
    if (v2 != -1)
    {
      v4 = *((_QWORD *)this + 62);
      if (v4 >= v3)
      {
        v5 = *(unsigned __int8 *)(v1 + v2);
        *((_QWORD *)this + 59) = v3;
        v7 = *((_QWORD *)this + 60);
        if (*(unsigned __int8 *)(v7 + v5) != 254)
          return v5;
        while (v3 < v4)
        {
          v5 = *(unsigned __int8 *)(v1 + v3++);
          *((_QWORD *)this + 59) = v3;
          if (*(unsigned __int8 *)(v7 + v5) == 252)
            return v5;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t PBMReadPlugin::readInt(PBMReadPlugin *this)
{
  uint64_t v2;
  int v3;

  do
    v2 = *(unsigned __int8 *)(*((_QWORD *)this + 60) + PBMReadPlugin::readChar(this));
  while ((v2 & 0x80) != 0);
  v3 = *(unsigned __int8 *)(*((_QWORD *)this + 60) + PBMReadPlugin::readChar(this));
  if (v3 == 255)
    return 0xFFFFFFFFLL;
  while ((v3 & 0x80) == 0)
  {
    if ((int)v2 <= 214748364 && 10 * (int)v2 <= (v3 ^ 0x7FFFFFFF))
    {
      v2 = (10 * v2 + v3);
      v3 = *(unsigned __int8 *)(*((_QWORD *)this + 60) + PBMReadPlugin::readChar(this));
      if (v3 != 255)
        continue;
    }
    return 0xFFFFFFFFLL;
  }
  return v2;
}

uint64_t PBMReadPlugin::readFloat(PBMReadPlugin *this)
{
  unsigned __int8 Char;
  uint64_t v3;
  int v4;
  float v5;
  uint64_t i;
  uint64_t result;
  int v8;

  do
    Char = PBMReadPlugin::readChar(this);
  while ((*(_BYTE *)(*((_QWORD *)this + 60) + Char) & 0x80) != 0);
  v3 = 0;
  if (Char == 45)
    v4 = 0;
  else
    v4 = *(unsigned __int8 *)(*((_QWORD *)this + 60) + Char);
  v5 = 1.0;
  while (1)
  {
    for (i = v3; ; i = 1)
    {
      v3 = i;
      result = PBMReadPlugin::readChar(this);
      if (result != 46)
        break;
      if ((v3 & 1) != 0)
        return result;
    }
    if (*(char *)(*((_QWORD *)this + 60) + result) < 0)
      break;
    if (v4 > 214748364)
      break;
    v8 = *(unsigned __int8 *)(*((_QWORD *)this + 60) + result);
    if (10 * v4 > (v8 ^ 0x7FFFFFFF))
      break;
    v4 = 10 * v4 + v8;
    if ((v3 & 1) != 0)
      v5 = v5 * 10.0;
  }
  return result;
}

uint64_t PBMReadPlugin::readWidthAndHeight(PBMReadPlugin *this, unsigned int *a2, unsigned int *a3)
{
  int Int;
  int v7;

  Int = PBMReadPlugin::readInt(this);
  if (Int < 1 || *((_QWORD *)this + 23) <= (unint64_t)Int)
    return 0;
  if (a2)
    *a2 = Int;
  v7 = PBMReadPlugin::readInt(this);
  if (v7 < 1 || *((_QWORD *)this + 23) <= (unint64_t)v7)
    return 0;
  if (a3)
    *a3 = v7;
  return 1;
}

uint64_t PBMReadPlugin::readHeader(PBMReadPlugin *this)
{
  uint64_t result;
  unint64_t v3;
  unint64_t v4;
  size_t v5;
  int v6;
  int v7;
  int v9;
  float v10;
  size_t v11;
  unsigned __int16 *v13;
  int v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int v19;
  __int16 v20;
  unsigned int v21;
  char v22;
  int Int;
  int v24;
  int v25;
  int v26;
  size_t v27;
  char *v28;
  int v29;
  char *v30;
  int v31;
  char *v32;
  unsigned __int16 v33;
  char *v34;
  int v35;
  char *v36;
  const char *v37;
  int v38;
  size_t v39;
  uint64_t v40;
  size_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  unsigned int v46[2];

  *(_QWORD *)v46 = 0;
  result = *((_QWORD *)this + 61);
  if (!result)
    return result;
  v3 = *((_QWORD *)this + 59);
  if (v3 > 0xFFFFFFFFFFFFFFFDLL)
    return 0;
  v4 = v3 + 2;
  v5 = *((_QWORD *)this + 62);
  if (v5 < v3 + 2)
    return 0;
  v6 = *(unsigned __int8 *)(result + v3);
  v7 = *(unsigned __int8 *)(result + v3 + 1);
  *((_QWORD *)this + 59) = v4;
  if (v6 == 42 && v7 == 23)
  {
    v11 = v3 + 6;
    if (v4 > 0xFFFFFFFFFFFFFFFBLL || v5 < v11)
      return 0;
    v13 = (unsigned __int16 *)(result + v4);
    v14 = *(unsigned __int8 *)(result + v4 + 2);
    v15 = *((unsigned __int8 *)v13 + 3);
    LODWORD(v13) = *v13;
    *((_QWORD *)this + 59) = v11;
    v16 = __rev16(v13);
    v46[1] = v16;
    v17 = *((_QWORD *)this + 23);
    if (v17 <= v16)
      return 0;
    v18 = v15 | (v14 << 8);
    v46[0] = v18;
    if (v17 <= v18)
      return 0;
    result = 10;
LABEL_22:
    v9 = 1;
LABEL_23:
    v10 = 0.0;
LABEL_24:
    v19 = v46[0];
    *((_DWORD *)this + 57) = v46[1];
    *((_DWORD *)this + 58) = v19;
    *((_QWORD *)this + 56) = v9;
    *((float *)this + 114) = fabsf(v10);
    if (v9)
    {
      if (v9 <= 255)
      {
        *((_WORD *)this + 120) = 8;
LABEL_38:
        v21 = *((unsigned __int16 *)this + 122);
        if (v21 >= 3)
        {
          if (v21 == 3)
            v22 = 5;
          else
            v22 = 3;
          *((_BYTE *)this + 278) = v22;
          *(_DWORD *)((char *)this + 274) = 262176;
          *((_BYTE *)this + 279) = 0;
        }
        return result;
      }
      if (HIWORD(v9))
      {
        result = 0;
        if (*((_WORD *)this + 120) != 8)
          return result;
        goto LABEL_38;
      }
      v20 = 16;
    }
    else
    {
      if (v10 == 0.0)
        return result;
      *((_BYTE *)this + 344) = v10 < 0.0;
      v20 = 32;
    }
    *((_WORD *)this + 120) = v20;
    return result;
  }
  if (v6 != 80)
    return 0;
  switch(v7)
  {
    case '1':
      if ((PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46) & 1) == 0)
        return 0;
      v9 = 1;
      v10 = 0.0;
      result = 1;
      goto LABEL_24;
    case '2':
      result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if (!(_DWORD)result)
        return result;
      Int = PBMReadPlugin::readInt(this);
      if ((Int - 0x10000) < 0xFFFF0001)
        return 0;
      v9 = Int;
      result = 2;
      goto LABEL_23;
    case '3':
      result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if (!(_DWORD)result)
        return result;
      v24 = PBMReadPlugin::readInt(this);
      if ((v24 - 0x10000) < 0xFFFF0001)
        return 0;
      v9 = v24;
      result = 3;
      goto LABEL_23;
    case '4':
      if ((PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46) & 1) == 0)
        return 0;
      result = 4;
      goto LABEL_22;
    case '5':
      result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if (!(_DWORD)result)
        return result;
      v25 = PBMReadPlugin::readInt(this);
      if ((v25 - 0x10000) < 0xFFFF0001)
        return 0;
      v9 = v25;
      result = 5;
      goto LABEL_23;
    case '6':
      result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if (!(_DWORD)result)
        return result;
      v26 = PBMReadPlugin::readInt(this);
      if ((v26 - 0x10000) < 0xFFFF0001)
        return 0;
      v9 = v26;
      result = 6;
      goto LABEL_23;
    case '7':
      result = (uint64_t)strnstr((const char *)result, "ENDHDR", v5);
      if (!result)
        return result;
      v27 = result - *((_QWORD *)this + 61);
      v28 = strnstr(*((const char **)this + 61), "WIDTH", v27);
      if (v28)
        *((_QWORD *)this + 59) = &v28[-*((_QWORD *)this + 61)];
      v29 = PBMReadPlugin::readInt(this);
      if (v29 < 1)
        return 7;
      v46[1] = v29;
      if (*((_QWORD *)this + 23) <= (unint64_t)v29)
        return 7;
      v30 = strnstr(*((const char **)this + 61), "HEIGHT", v27);
      if (v30)
        *((_QWORD *)this + 59) = &v30[-*((_QWORD *)this + 61)];
      v31 = PBMReadPlugin::readInt(this);
      if (v31 < 1)
        return 7;
      v46[0] = v31;
      if (*((_QWORD *)this + 23) <= (unint64_t)v31)
        return 7;
      v32 = strnstr(*((const char **)this + 61), "DEPTH", v27);
      if (v32)
        *((_QWORD *)this + 59) = &v32[-*((_QWORD *)this + 61)];
      v33 = PBMReadPlugin::readInt(this);
      *((_WORD *)this + 122) = v33;
      if (v33 > 4u)
        return 7;
      v34 = strnstr(*((const char **)this + 61), "MAXVAL", v27);
      if (v34)
        *((_QWORD *)this + 59) = &v34[-*((_QWORD *)this + 61)];
      v35 = PBMReadPlugin::readInt(this);
      if ((v35 - 0x10000) < 0xFFFF0001)
        return 7;
      v9 = v35;
      v36 = strnstr(*((const char **)this + 61), "TUPLTYPE", v27);
      v37 = (const char *)*((_QWORD *)this + 61);
      if (v36)
        *((_QWORD *)this + 59) = v36 - v37;
      if (strnstr(v37, "RGB_ALPHA", v27))
      {
        if (*((_WORD *)this + 122) == 4)
        {
          *((_BYTE *)this + 246) = 3;
          *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
          *((_WORD *)this + 138) = *((_WORD *)this + 122);
LABEL_77:
          v38 = 1380401696;
LABEL_78:
          *((_DWORD *)this + 81) = v38;
LABEL_79:
          v39 = v27 + 6;
          *((_QWORD *)this + 59) = v27 + 6;
          v40 = *((_QWORD *)this + 61);
          if (v40)
          {
            if (v27 != -7)
            {
              v41 = v27 + 7;
              if (*((_QWORD *)this + 62) >= v27 + 7)
              {
                v42 = *(unsigned __int8 *)(v40 + v39);
                *((_QWORD *)this + 59) = v41;
                v43 = *((_QWORD *)this + 60);
                if ((*(_BYTE *)(v43 + v42) & 0xFE) == 0xFC)
                {
                  while (1)
                  {
                    v39 = v41 + 1;
                    if (v41 == -1 || *((_QWORD *)this + 62) < v39)
                      break;
                    v44 = *(unsigned __int8 *)(v40 + v41);
                    *((_QWORD *)this + 59) = v39;
                    v45 = *(_BYTE *)(v43 + v44) & 0xFE;
                    v41 = v39;
                    if (v45 != 252)
                      goto LABEL_95;
                  }
                }
                v39 = v41;
              }
            }
          }
LABEL_95:
          *((_QWORD *)this + 59) = v39 - 1;
          result = 7;
          goto LABEL_23;
        }
        _cg_jpeg_mem_term("readHeader", 398, "*** ERROR bad 'RGB_ALPHA':  expected %d channels got: %d channels\n");
        return 7;
      }
      if (strnstr(*((const char **)this + 61), "RGB", v27))
      {
        if (*((_WORD *)this + 122) == 3)
        {
          *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
          *((_BYTE *)this + 246) = 0;
          *((_WORD *)this + 122) = 3;
          if (*((_WORD *)this + 120) != 8)
            goto LABEL_79;
          *((_DWORD *)this + 69) = 327684;
          goto LABEL_77;
        }
        _cg_jpeg_mem_term("readHeader", 406, "*** ERROR bad 'RGB':  expected %d channels got: %d channels\n");
        return 7;
      }
      if (strnstr(*((const char **)this + 61), "GRAYSCALE_ALPHA", v27))
      {
        if (*((_WORD *)this + 122) != 2)
        {
          _cg_jpeg_mem_term("readHeader", 422, "*** ERROR bad 'GRAYSCALE_ALPHA':  expected %d channels got: %d channels\n");
          return 7;
        }
LABEL_98:
        *((_BYTE *)this + 246) = 3;
LABEL_102:
        *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
        v38 = 1196573017;
        goto LABEL_78;
      }
      if (strnstr(*((const char **)this + 61), "GRAYSCALE", v27))
      {
        if (*((_WORD *)this + 122) != 1)
        {
          _cg_jpeg_mem_term("readHeader", 429, "*** ERROR bad 'GRAYSCALE':  expected %d channels got: %d channels\n");
          return 7;
        }
      }
      else
      {
        if (!strnstr(*((const char **)this + 61), "BLACKANDWHITE", v27))
        {
          if (!strnstr(*((const char **)this + 61), "BLACKANDWHITE_ALPHA", v27))
            goto LABEL_79;
          if (v9 != 1 && *((_WORD *)this + 122) != 2)
          {
            _cg_jpeg_mem_term("readHeader", 443, "*** ERROR bad 'BLACKANDWHITE_ALPHA'\n");
            return 7;
          }
          goto LABEL_98;
        }
        if (v9 != 1 && *((_WORD *)this + 122) != 1)
        {
          _cg_jpeg_mem_term("readHeader", 436, "*** ERROR bad 'BLACKANDWHITE'\n");
          return 7;
        }
      }
      *((_BYTE *)this + 246) = 0;
      goto LABEL_102;
    default:
      if (v7 == 70)
      {
        result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
        if (!(_DWORD)result)
          return result;
        PBMReadPlugin::readFloat(this);
        v9 = 0;
        if (v10 != 0.0)
        {
          result = 9;
          goto LABEL_24;
        }
        return 0;
      }
      if (v7 != 102)
        return 0;
      result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if ((_DWORD)result)
      {
        PBMReadPlugin::readFloat(this);
        v9 = 0;
        if (v10 != 0.0)
        {
          result = 8;
          goto LABEL_24;
        }
        return 0;
      }
      break;
  }
  return result;
}

uint64_t PBMReadPlugin::initialize(PBMReadPlugin *this, IIODictionary *a2)
{
  const void **v3;
  unint64_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  int Val8;
  unsigned __int8 v9;
  unsigned int Header;
  unsigned int v11;
  int v12;
  int v13;
  char v14;
  int v15;
  int v16;
  char v17;
  char v18;
  uint64_t v19;
  unsigned int v20;
  char *v21;
  __int16 v23;
  int v24;
  int v25;
  BOOL v26;
  _DWORD *v27;
  _DWORD *v28;
  _DWORD *exception;
  _OWORD v30[2];
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = 0;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v34, *((IIOImageReadSession **)this + 3));
  if (!*((_BYTE *)this + 341))
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
  }
  v3 = (const void **)((char *)this + 488);
  v4 = v35;
  *((_QWORD *)this + 61) = *((_QWORD *)&v34 + 1);
  *((_QWORD *)this + 62) = v4;
  *((_QWORD *)this + 59) = 0;
  if (v4)
  {
    if (v4 >= 0x200)
      v5 = 512;
    else
      v5 = v4;
    v6 = malloc_type_malloc(v5, 0x8FDA7A06uLL);
    memcpy(v6, *v3, v5);
    v33 = 0;
    v31 = 0u;
    v32 = 0u;
    memset(v30, 0, sizeof(v30));
    IIOScanner::IIOScanner((IIOScanner *)v30, (unsigned __int8 *)v6, v5, 0);
    LODWORD(v7) = 0;
    do
    {
      if (*((_BYTE *)v6 + v7) == 35)
      {
        *((_BYTE *)v6 + v7) = 32;
        v7 = (v7 + 1);
        if (v7 < v5)
        {
          while (*((_BYTE *)v6 + v7) != 10)
          {
            *((_BYTE *)v6 + v7++) = 32;
            if (v5 == v7)
              goto LABEL_71;
          }
        }
        if ((_DWORD)v7 == (_DWORD)v5)
        {
LABEL_71:
          v27 = __cxa_allocate_exception(4uLL);
          *v27 = -1;
          __cxa_throw(v27, MEMORY[0x1E0DE4EF0], 0);
        }
      }
      LODWORD(v7) = v7 + 1;
    }
    while (v7 < v5);
    if (IIOScanner::getVal8((IIOScanner *)v30) != 80)
      goto LABEL_72;
    Val8 = IIOScanner::getVal8((IIOScanner *)v30);
    *((_QWORD *)&v31 + 1) = *((_QWORD *)this + 60);
    if (Val8 != 55)
    {
      v9 = IIOScanner::lookupVal8((IIOScanner *)v30);
      if ((v9 + 2) < 0xFEu)
        goto LABEL_72;
      while ((v9 & 0xFE) == 0xFC)
        v9 = IIOScanner::lookupVal8((IIOScanner *)v30);
      while (v9 <= 9u)
        v9 = IIOScanner::lookupVal8((IIOScanner *)v30);
      if ((v9 + 2) < 0xFEu)
        goto LABEL_72;
      while ((v9 & 0xFE) == 0xFC)
        v9 = IIOScanner::lookupVal8((IIOScanner *)v30);
      while (v9 <= 9u)
        v9 = IIOScanner::lookupVal8((IIOScanner *)v30);
      if (v9 == 0xFF)
      {
LABEL_72:
        v28 = __cxa_allocate_exception(4uLL);
        *v28 = -1;
        __cxa_throw(v28, MEMORY[0x1E0DE4EF0], 0);
      }
    }
    IIOScanner::~IIOScanner((IIOScanner *)v30);
  }
  else
  {
    v6 = 0;
  }
  Header = PBMReadPlugin::readHeader(this);
  v11 = Header;
  if (Header <= 0xA)
  {
    if (((1 << Header) & 0x536) != 0)
    {
      *((_BYTE *)this + 246) = 0;
      *((_WORD *)this + 121) = *((_WORD *)this + 120);
      *((_WORD *)this + 122) = 1;
      *((_DWORD *)this + 81) = 1196573017;
      if (Header == 8)
      {
        *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D948]);
        *((_BYTE *)this + 345) = 1;
        *((_WORD *)this + 121) = 32;
        *((_WORD *)this + 152) = 32;
        *((_BYTE *)this + 313) = 1;
LABEL_52:
        *((_DWORD *)this + 59) = (*((_DWORD *)this + 57) * (*((unsigned __int16 *)this + 121) >> 3) + 3) & 0xFFFFFFFC;
        goto LABEL_53;
      }
      *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
      v13 = *((unsigned __int16 *)this + 120);
      *((_WORD *)this + 136) = v13;
      if (v13 == 32)
      {
        v14 = 2;
      }
      else
      {
        if (v13 != 16)
          goto LABEL_52;
        v14 = 1;
      }
      *((_BYTE *)this + 279) = v14;
      goto LABEL_52;
    }
    if (((1 << Header) & 0x248) != 0)
    {
      *((_WORD *)this + 122) = 3;
      *((_BYTE *)this + 246) = 0;
      *((_WORD *)this + 121) = 3 * *((_WORD *)this + 120);
      *((_DWORD *)this + 81) = 1380401696;
      if (Header == 9)
      {
        *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D958]);
        *((_BYTE *)this + 345) = 1;
        *(_DWORD *)((char *)this + 242) = 196704;
        *((_BYTE *)this + 249) = 1;
        *((_WORD *)this + 139) = 512;
        LOWORD(v12) = *((_WORD *)this + 136);
      }
      else
      {
        *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
        v12 = *((unsigned __int16 *)this + 120);
        *((_WORD *)this + 136) = v12;
        switch(v12)
        {
          case 32:
            *((_DWORD *)this + 69) = 33554435;
            *((_BYTE *)this + 281) = 1;
            LOWORD(v12) = 32;
            break;
          case 16:
            *((_DWORD *)this + 69) = 16777219;
            LOWORD(v12) = 16;
            break;
          case 8:
            *((_DWORD *)this + 69) = 327684;
            LOWORD(v12) = 8;
            break;
        }
      }
      *((_DWORD *)this + 59) = *((_DWORD *)this + 57) * (*((unsigned __int16 *)this + 121) >> 3);
      *((_WORD *)this + 137) = v12 * *((_WORD *)this + 138);
      goto LABEL_53;
    }
    if (Header == 7)
    {
      v15 = *((unsigned __int16 *)this + 120);
      v16 = *((unsigned __int16 *)this + 122);
      *((_WORD *)this + 121) = v16 * v15;
      *((_DWORD *)this + 59) = (((unsigned __int16)(v16 * v15) + 7) >> 3) * *((_DWORD *)this + 57);
      *((_WORD *)this + 136) = v15;
      *((_WORD *)this + 137) = *((_WORD *)this + 138) * v15;
      if (v15 == 16)
      {
        v17 = 1;
      }
      else
      {
        if (v15 != 32)
          goto LABEL_62;
        *((_BYTE *)this + 249) = 1;
        v17 = 2;
      }
      *((_BYTE *)this + 247) = v17;
LABEL_62:
      if (v16 == 3)
      {
        *((_DWORD *)this + 81) = 1380401696;
        if (v15 == 8)
        {
          *(_DWORD *)((char *)this + 274) = 262176;
          *((_WORD *)this + 139) = 5;
        }
      }
      else if (v16 == 4)
      {
        *((_DWORD *)this + 81) = 1380401696;
        if (v15 == 8)
          v23 = 3;
        else
          v23 = 259;
        *((_WORD *)this + 123) = v23;
      }
      else
      {
        *((_DWORD *)this + 81) = 1196573017;
        v24 = *((unsigned __int8 *)this + 247);
        v25 = (v24 << 12) | (*((unsigned __int8 *)this + 248) << 16);
        v26 = *((_BYTE *)this + 249) != 0;
        *((_BYTE *)this + 278) = *((_BYTE *)this + 246) & 0x1F;
        *((_BYTE *)this + 279) = v24 & 7;
        *((_BYTE *)this + 280) = BYTE2(v25) & 0xF;
        *((_BYTE *)this + 281) = v26;
      }
LABEL_53:
      *((_QWORD *)this + 45) = 1;
      *((_QWORD *)this + 55) = v11;
      *((_QWORD *)this + 58) = *((_QWORD *)this + 59);
      *((_BYTE *)this + 350) = 1;
      v20 = (*((unsigned __int8 *)this + 247) << 12) | (*((unsigned __int8 *)this + 248) << 16) | ((*((_BYTE *)this + 249) != 0) << 8) | *((unsigned __int8 *)this + 246);
      v21 = IIO_BitmapInfoString(v20);
      _cg_jpeg_mem_term("initialize", 756, "*** bitmapInfo: %08X  %s\n", v20, v21);
      v19 = 0;
      v18 = 1;
      *((_WORD *)this + 188) = 1;
      if (!v6)
        goto LABEL_55;
      goto LABEL_54;
    }
  }
  _cg_jpeg_mem_term("initialize", 745, "*** ERROR: PBM type '%d' not handled\n", Header);
  v18 = 0;
  v19 = 4294967246;
  if (v6)
LABEL_54:
    free(v6);
LABEL_55:
  *v3 = 0;
  *((_QWORD *)this + 62) = 0;
  if ((v18 & 1) == 0)
    kdebug_trace();
  IIOScanner::~IIOScanner((IIOScanner *)&v34);
  return v19;
}

void sub_18804885C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

void sub_188048884(void *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  __cxa_begin_catch(a1);
  _cg_jpeg_mem_term("initialize", 599, "failed to read PBM header\n");
  __cxa_end_catch();
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x188048604);
}

void sub_1880488AC(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  __cxa_end_catch();
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x188048868);
}

void sub_1880488BC(void *a1)
{
  __cxa_begin_catch(a1);
  JUMPOUT(0x1880488C8);
}

uint64_t PBMReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t PBMReadPlugin::loadDataFromXPCObject(PBMReadPlugin *this, void *a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_pbm", &length);
    if (length == 40)
    {
      v6 = data;
      result = 0;
      v7 = *v6;
      v8 = v6[1];
      *((_QWORD *)this + 59) = *((_QWORD *)v6 + 4);
      *(_OWORD *)((char *)this + 440) = v7;
      *(_OWORD *)((char *)this + 456) = v8;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t PBMReadPlugin::saveDataToXPCObject(PBMReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_pbm", (char *)this + 440, 0x28uLL);
  return v4;
}

uint64_t PBMReadPlugin::decode_PBM_P1_TXT(PBMReadPlugin *this, unsigned __int8 *a2)
{
  unsigned int v2;
  int v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unsigned __int8 *v9;
  unsigned int Char;
  char v11;

  v2 = *((_DWORD *)this + 74);
  if (!v2)
    return 1;
  v5 = 0;
  v6 = 0;
  LODWORD(v7) = *((_DWORD *)this + 73);
  do
  {
    if (!(_DWORD)v7)
      goto LABEL_15;
    v8 = 0;
    v9 = &a2[v6 * *((unsigned int *)this + 75)];
    do
    {
      while (1)
      {
        Char = PBMReadPlugin::readChar(this);
        if ((Char & 0x80000000) != 0)
          break;
        if ((*(char *)(*((_QWORD *)this + 60) + Char) & 0x80000000) == 0)
        {
          if (*(_BYTE *)(*((_QWORD *)this + 60) + Char))
            v11 = 0;
          else
            v11 = -1;
          goto LABEL_13;
        }
      }
      if (++v5 <= 9)
        _cg_jpeg_mem_term("decode_PBM_P1_TXT", 860, "*** PBM - P1: invalid value at [%d,%d]: 0x%02X\n", v6, v8, -1);
      v11 = 0;
LABEL_13:
      *v9++ = v11;
      ++v8;
      v7 = *((unsigned int *)this + 73);
    }
    while (v8 < v7);
    v2 = *((_DWORD *)this + 74);
LABEL_15:
    ++v6;
  }
  while (v6 < v2);
  if (v5)
    LogError("decode_PBM_P1_TXT", 870, "*** ERROR: PBM - P1: %d invalid values in image [%d x %d]\n", v5, *((_DWORD *)this + 73), v2);
  return 1;
}

uint64_t PBMReadPlugin::decode_PBM_P2_TXT(PBMReadPlugin *this, unsigned __int8 *a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 *v10;
  uint64_t Int;
  int v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  int v19;
  unsigned int v20;

  v4 = *((_QWORD *)this + 56);
  v5 = *((_DWORD *)this + 74);
  if (*((_WORD *)this + 120) == 16)
  {
    if (!v5)
      return 1;
    v6 = 0;
    v7 = 0;
    LODWORD(v8) = *((_DWORD *)this + 73);
    do
    {
      if ((_DWORD)v8)
      {
        v9 = 0;
        v10 = &a2[v7 * *((unsigned int *)this + 75)];
        do
        {
          Int = PBMReadPlugin::readInt(this);
          if ((Int & 0x80000000) != 0)
          {
            if (++v6 <= 9)
              _cg_jpeg_mem_term("decode_PBM_P2_TXT", 902, "*** PGM - P2: invalid value at [%d,%d]: 0x%02\n", v7, v9, Int);
            LOWORD(v13) = 0;
          }
          else
          {
            v12 = (unsigned __int16)Int;
            if ((unsigned __int16)Int >= (unsigned __int16)v4)
              v12 = (unsigned __int16)v4;
            v13 = 0xFFFF * v12 / (unsigned __int16)v4;
          }
          *(_WORD *)&v10[2 * v9++] = v13;
          v8 = *((unsigned int *)this + 73);
        }
        while (v9 < v8);
        v5 = *((_DWORD *)this + 74);
      }
      ++v7;
    }
    while (v7 < v5);
  }
  else
  {
    if (!v5)
      return 1;
    v6 = 0;
    v14 = 0;
    LODWORD(v15) = *((_DWORD *)this + 73);
    do
    {
      if ((_DWORD)v15)
      {
        v16 = 0;
        v17 = &a2[v14 * *((unsigned int *)this + 75)];
        do
        {
          v18 = PBMReadPlugin::readInt(this);
          if ((v18 & 0x80000000) != 0)
          {
            if (++v6 <= 9)
              _cg_jpeg_mem_term("decode_PBM_P2_TXT", 925, "*** PGM - P2: invalid value at [%d,%d]: 0x%02\n", v14, v16, v18);
            LOBYTE(v20) = 0;
          }
          else
          {
            v19 = v18;
            if (v18 >= v4)
              v19 = v4;
            v20 = 255 * v19 / v4;
          }
          v17[v16++] = v20;
          v15 = *((unsigned int *)this + 73);
        }
        while (v16 < v15);
        v5 = *((_DWORD *)this + 74);
      }
      ++v14;
    }
    while (v14 < v5);
  }
  if (v6)
    LogError("decode_PBM_P2_TXT", 938, "*** ERROR: PGM - P2: %d invalid values in image [%d x %d]\n", v6, *((_DWORD *)this + 73), v5);
  return 1;
}

uint64_t PBMReadPlugin::decode_PPM_P3_TXT(PBMReadPlugin *this, unsigned __int8 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int16 v12;
  int v13;
  unsigned __int16 v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t result;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  unsigned __int8 *v25;
  int Int;
  unsigned __int8 v27;
  int v28;
  unsigned __int8 v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;

  v3 = *((_QWORD *)this + 56);
  if (*((_WORD *)this + 120) != 16)
  {
    v20 = *((unsigned int *)this + 58);
    if ((_DWORD)v20)
    {
      v5 = 0;
      v21 = 2 * (*((_BYTE *)this + 405) != 0);
      v22 = 2 * (*((_BYTE *)this + 405) == 0);
      v23 = *((_QWORD *)this + 56);
      LODWORD(v24) = *((_DWORD *)this + 57);
      v36 = a2;
      while (!(_DWORD)v24)
      {
LABEL_37:
        ++v5;
        result = 1;
        if (v5 >= v20)
          return result;
      }
      v9 = 0;
      v25 = &a2[v5 * *((unsigned int *)this + 75)];
      while (1)
      {
        Int = PBMReadPlugin::readInt(this);
        if (Int == -1)
          break;
        v27 = Int;
        v28 = PBMReadPlugin::readInt(this);
        if (v28 == -1)
          break;
        v29 = v28;
        v30 = PBMReadPlugin::readInt(this);
        if (v30 == -1)
          break;
        v31 = v27;
        if (v27 >= v3)
          v31 = v3;
        v25[v22] = 255 * v31 / v23;
        v32 = v29;
        if (v29 >= v3)
          v32 = v3;
        v25[1] = 255 * v32 / v23;
        v33 = v30;
        if (v30 >= v3)
          v33 = v3;
        v25[v21] = 255 * v33 / v23;
        v25[3] = -1;
        v25 += 4;
        ++v9;
        v24 = *((unsigned int *)this + 57);
        if (v9 >= v24)
        {
          v20 = *((unsigned int *)this + 58);
          a2 = v36;
          goto LABEL_37;
        }
      }
      v34 = 1010;
      goto LABEL_42;
    }
    return 1;
  }
  v4 = *((unsigned int *)this + 58);
  if (!(_DWORD)v4)
    return 1;
  v5 = 0;
  v6 = *((unsigned __int8 *)this + 310);
  v7 = (unsigned __int16)*((_QWORD *)this + 56);
  LODWORD(v8) = *((_DWORD *)this + 57);
  v35 = a2;
  while (!(_DWORD)v8)
  {
LABEL_20:
    ++v5;
    result = 1;
    if (v5 >= v4)
      return result;
  }
  v9 = 0;
  v10 = &a2[v5 * *((unsigned int *)this + 75)];
  while (1)
  {
    v11 = PBMReadPlugin::readInt(this);
    if (v11 == -1)
      break;
    v12 = v11;
    v13 = PBMReadPlugin::readInt(this);
    if (v13 == -1)
      break;
    v14 = v13;
    v15 = PBMReadPlugin::readInt(this);
    if (v15 == -1)
      break;
    v16 = v12;
    if (v12 >= (unsigned __int16)v3)
      v16 = (unsigned __int16)v3;
    *(_WORD *)v10 = 0xFFFF * v16 / v7;
    v17 = v14;
    if (v14 >= (unsigned __int16)v3)
      v17 = (unsigned __int16)v3;
    *((_WORD *)v10 + 1) = 0xFFFF * v17 / v7;
    v18 = (unsigned __int16)v15;
    if ((unsigned __int16)v15 >= (unsigned __int16)v3)
      v18 = (unsigned __int16)v3;
    *((_WORD *)v10 + 2) = 0xFFFF * v18 / v7;
    if (v6)
    {
      *((_WORD *)v10 + 3) = -1;
      v10 += 8;
    }
    else
    {
      v10 += 6;
    }
    ++v9;
    v8 = *((unsigned int *)this + 57);
    if (v9 >= v8)
    {
      v4 = *((unsigned int *)this + 58);
      a2 = v35;
      goto LABEL_20;
    }
  }
  v34 = 977;
LABEL_42:
  _cg_jpeg_mem_term("decode_PPM_P3_TXT", v34, "reached EOF at row:%d  col:%d\n", v5, v9);
  return 0;
}

uint64_t PBMReadPlugin::decode_PBM_P4_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
  size_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t v18;
  _QWORD v20[2];
  uint64_t v21;
  uint64_t v22;
  _QWORD v23[4];

  v4 = *((unsigned int *)this + 59);
  v5 = *((unsigned int *)this + 75);
  v6 = malloc_type_malloc(v4, 0x38A38D0uLL);
  v7 = operator new();
  IIOPixelConverterGray::IIOPixelConverterGray(v7, 6, 1, 1u, 0, 6, 8u, 0, (uint64_t)"PAM_P4_RAW");
  v8 = (v4 + 7) >> 3;
  v9 = 1;
  v23[0] = v6;
  v23[1] = 1;
  v10 = *((_DWORD *)this + 58);
  v23[2] = *((unsigned int *)this + 57);
  v23[3] = v8;
  v20[0] = a2;
  v20[1] = 1;
  v21 = *((unsigned int *)this + 73);
  v22 = v21;
  if (v10)
  {
    v11 = 0;
    do
    {
      if ((_DWORD)v4 && (v12 = *((_QWORD *)this + 61)) != 0)
      {
        v13 = *((_QWORD *)this + 59);
        v14 = v13 + v8;
        if (__CFADD__(v13, v8) || v14 < v13 || *((_QWORD *)this + 62) < v14)
        {
LABEL_19:
          _cg_jpeg_mem_term("decode_PBM_P4_RAW", 1057, "read error requested %ld bytes - got %d\n", v4, 0);
          v9 = 0;
          goto LABEL_20;
        }
        memcpy(v6, (const void *)(v12 + v13), (v4 + 7) >> 3);
        *((_QWORD *)this + 59) += v8;
      }
      else if ((_DWORD)v4)
      {
        goto LABEL_19;
      }
      (*(void (**)(uint64_t, _QWORD *, _QWORD *))(*(_QWORD *)v7 + 16))(v7, v23, v20);
      v20[0] += v5;
      ++v11;
      v15 = *((unsigned int *)this + 58);
    }
    while (v11 < v15);
    if (*((_DWORD *)this + 58))
    {
      v16 = 0;
      v17 = *((_DWORD *)this + 57);
      do
      {
        if (v17)
        {
          v18 = 0;
          do
          {
            a2[v18] = ~a2[v18];
            v17 = *((_DWORD *)this + 57);
            ++v18;
          }
          while (v18 < v17);
          v15 = *((unsigned int *)this + 58);
        }
        ++v16;
        a2 += v5;
      }
      while (v16 < v15);
    }
    v9 = 1;
  }
LABEL_20:
  if (v6)
    free(v6);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  return v9;
}

void sub_188049160(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C4050BC5624);
  _Unwind_Resume(a1);
}

uint64_t PBMReadPlugin::decode_PGM_P5_RAW(PBMReadPlugin *this, unsigned __int8 *__dst)
{
  unsigned int v2;
  unsigned int v5;
  unint64_t v6;
  size_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  size_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  int v15;
  unsigned __int8 *v16;
  int v17;

  v2 = *((_DWORD *)this + 58);
  if (!v2)
    return 1;
  v5 = 0;
  v6 = (unint64_t)*((unsigned __int16 *)this + 120) >> 3;
  v7 = v6 * (unint64_t)*((unsigned int *)this + 57);
  v8 = __dst;
  do
  {
    if (v7 && (v9 = *((_QWORD *)this + 61)) != 0)
    {
      v10 = *((_QWORD *)this + 59);
      v11 = v10 + v7;
      if (__CFADD__(v10, v7) || v11 < v10 || *((_QWORD *)this + 62) < v11)
      {
LABEL_19:
        _cg_jpeg_mem_term("decode_PGM_P5_RAW", 1102, "read error requested %ld bytes - got %d\n", v7, 0);
        return 0;
      }
      memcpy(v8, (const void *)(v9 + v10), v7);
      *((_QWORD *)this + 59) += v7;
      v2 = *((_DWORD *)this + 58);
    }
    else if (v7)
    {
      goto LABEL_19;
    }
    v12 = *((unsigned int *)this + 75);
    v8 += v12;
    ++v5;
  }
  while (v5 < v2);
  result = 1;
  if ((_DWORD)v6 == 2 && v2)
  {
    v14 = 0;
    v15 = *((_DWORD *)this + 57);
    do
    {
      if (v15)
      {
        v16 = &__dst[(v12 * v14)];
        v17 = v15;
        do
        {
          *(_WORD *)v16 = bswap32(*(unsigned __int16 *)v16) >> 16;
          v16 += 2;
          --v17;
        }
        while (v17);
      }
      ++v14;
    }
    while (v14 != v2);
    return 1;
  }
  return result;
}

uint64_t PBMReadPlugin::decode_PPM_P6_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
  size_t v4;
  size_t v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  size_t v14;
  size_t v15;
  unint64_t v16;
  unsigned int v17;
  unint64_t v18;
  unsigned int v19;
  unsigned int v20;
  vImagePixelCount v21;
  uint64_t v22;
  size_t v23;
  size_t v24;
  int v25;
  uint64_t v26;
  _WORD *v27;
  unsigned int v28;
  vImage_Buffer v30;
  vImage_Buffer dest;

  v4 = *((unsigned int *)this + 59);
  v5 = *((unsigned int *)this + 75);
  v6 = (unsigned __int8 *)malloc_type_malloc(v4, 0x99AC3158uLL);
  v7 = v6;
  v8 = *((_QWORD *)this + 56);
  v9 = *((unsigned __int16 *)this + 120);
  if (v9 == 16)
  {
    if (*((_DWORD *)this + 58))
    {
      v20 = 0;
      v21 = 3 * *((unsigned int *)this + 57);
      do
      {
        if ((_DWORD)v4 && (v22 = *((_QWORD *)this + 61)) != 0)
        {
          v23 = *((_QWORD *)this + 59);
          v24 = v23 + v4;
          if (__CFADD__(v23, v4) || v24 < v23 || *((_QWORD *)this + 62) < v24)
          {
LABEL_51:
            _cg_jpeg_mem_term("decode_PPM_P6_RAW", 1190, "read error requested %ld bytes - got %d\n");
            goto LABEL_53;
          }
          memcpy(v7, (const void *)(v22 + v23), v4);
          *((_QWORD *)this + 59) += v4;
        }
        else if ((_DWORD)v4)
        {
          goto LABEL_51;
        }
        if (*((_BYTE *)this + 344))
        {
          dest.data = v7;
          dest.height = 1;
          dest.width = v21;
          dest.rowBytes = v4;
          vImageByteSwap_Planar16U(&dest, &dest, 0x10u);
        }
        v25 = *((_DWORD *)this + 73);
        if (v25)
        {
          LODWORD(v26) = 3 * v25;
          if (v26 <= 1)
            v26 = 1;
          else
            v26 = v26;
          v27 = v7;
          do
          {
            v28 = (unsigned __int16)*v27;
            if (v28 >= (unsigned __int16)v8)
              v28 = (unsigned __int16)v8;
            *v27++ = 0xFFFF * v28 / (unsigned __int16)v8;
            --v26;
          }
          while (v26);
        }
        memcpy(a2, v7, v4);
        a2 += *((unsigned int *)this + 75);
        ++v20;
      }
      while (v20 < *((_DWORD *)this + 58));
    }
    goto LABEL_47;
  }
  if (v9 != 8)
  {
LABEL_47:
    v10 = 1;
LABEL_48:
    if (!v7)
      return v10;
    goto LABEL_49;
  }
  v10 = 1;
  dest.data = v6;
  dest.height = 1;
  v11 = *((_DWORD *)this + 58);
  dest.width = *((unsigned int *)this + 57);
  dest.rowBytes = v4;
  v30.data = a2;
  v30.height = 1;
  v30.width = *((unsigned int *)this + 73);
  v30.rowBytes = v5;
  if (!v11)
    goto LABEL_48;
  v12 = 0;
  while (1)
  {
    if ((_DWORD)v4)
    {
      v13 = *((_QWORD *)this + 61);
      if (v13)
      {
        v14 = *((_QWORD *)this + 59);
        v15 = v14 + v4;
        if (!__CFADD__(v14, v4) && v15 >= v14 && *((_QWORD *)this + 62) >= v15)
        {
          memcpy(v7, (const void *)(v13 + v14), v4);
          *((_QWORD *)this + 59) += v4;
          goto LABEL_11;
        }
      }
    }
    if ((_DWORD)v4)
      break;
LABEL_11:
    if (*((_DWORD *)this + 73))
    {
      v16 = 0;
      do
      {
        v17 = v7[v16];
        if (v17 >= v8)
          v17 = v8;
        v7[v16++] = 255 * v17 / v8;
      }
      while (v16 < (3 * *((_DWORD *)this + 73)));
    }
    if (*((_BYTE *)this + 405))
      vImageConvert_RGB888toRGBA8888(&dest, 0, 0xFFu, &v30, 0, 0);
    else
      vImageConvert_RGB888toBGRA8888(&dest, 0, 0xFFu, &v30, 0, 0);
    if (*((_DWORD *)this + 73))
    {
      v18 = 0;
      do
      {
        v19 = v7[v18];
        if (v19 >= v8)
          v19 = v8;
        v7[v18++] = 255 * v19 / v8;
      }
      while (v18 < (3 * *((_DWORD *)this + 73)));
    }
    v30.data = (char *)v30.data + *((unsigned int *)this + 75);
    if (++v12 >= *((_DWORD *)this + 58))
      goto LABEL_47;
  }
  _cg_jpeg_mem_term("decode_PPM_P6_RAW", 1150, "read error requested %ld bytes - got %d\n");
LABEL_53:
  v10 = 0;
  if (v7)
LABEL_49:
    free(v7);
  return v10;
}

uint64_t PBMReadPlugin::decode_PAM_P7_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
  size_t v4;
  uint64_t v5;
  void *v6;
  uint32_t v7;
  char v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char v12;
  int v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  size_t v20;
  size_t v21;
  _QWORD v23[4];
  _QWORD v24[4];

  v4 = *((unsigned int *)this + 59);
  v5 = *((unsigned int *)this + 75);
  v6 = malloc_type_malloc(v4, 0xB23577B9uLL);
  v7 = *((unsigned __int8 *)this + 240);
  v8 = v7 == 16;
  switch(*((_WORD *)this + 122))
  {
    case 1:
      v9 = operator new();
      IIOPixelConverterGray::IIOPixelConverterGray(v9, 6, *((_BYTE *)this + 244), v7, 0, 6, *((unsigned __int8 *)this + 304), v7 == 16, (uint64_t)"PAM_P7_gray");
      break;
    case 2:
      v9 = operator new();
      IIOPixelConverterGray::IIOPixelConverterGray(v9, 8, *((_BYTE *)this + 244), v7, 8, 8, *((unsigned __int8 *)this + 304), v7 == 16, (uint64_t)"PAM_P7_gray+alpha");
      break;
    case 3:
      if (v7 != 8)
        goto LABEL_11;
      v10 = *((unsigned __int8 *)this + 405);
      v11 = operator new();
      v9 = v11;
      if (v10)
        v12 = 4;
      else
        v12 = 5;
      IIOPixelConverterRGB::IIOPixelConverterRGB(v11, 0, *((_BYTE *)this + 244), 8u, 8, 8, 255, v12, *((_BYTE *)this + 304), v8, (uint64_t)"PAM_P7_rgb");
      break;
    case 4:
      if (v7 == 16)
      {
        v9 = operator new();
        IIOPixelConverterRGB::IIOPixelConverterRGB(v9, 2, *((_BYTE *)this + 244), 0x10u, 16, 16, 16, 2, *((_BYTE *)this + 304), 1, (uint64_t)"PAM_P7_rgb+alpha");
      }
      else
      {
        v13 = *((unsigned __int8 *)this + 405);
        v14 = operator new();
        v9 = v14;
        if (v13)
          v15 = 2;
        else
          v15 = 3;
        IIOPixelConverterRGB::IIOPixelConverterRGB(v14, 2, *((_BYTE *)this + 244), v7, v7, v7, 8, v15, *((_BYTE *)this + 304), v8, (uint64_t)"PAM_P7_rgb+alpha");
      }
      break;
    default:
      _cg_jpeg_mem_term("decode_PAM_P7_RAW", 1264, "*** ERROR: unexpected numberOfChannels: %d\n", *((unsigned __int16 *)this + 122));
LABEL_11:
      v9 = 0;
      break;
  }
  v16 = 1;
  v24[0] = v6;
  v24[1] = 1;
  v17 = *((_DWORD *)this + 58);
  v24[2] = *((unsigned int *)this + 57);
  v24[3] = v4;
  v23[0] = a2;
  v23[1] = 1;
  v23[2] = *((unsigned int *)this + 73);
  v23[3] = v5;
  if (v17)
  {
    v18 = 0;
    while (1)
    {
      if ((_DWORD)v4 && (v19 = *((_QWORD *)this + 61)) != 0)
      {
        v20 = *((_QWORD *)this + 59);
        v21 = v20 + v4;
        if (__CFADD__(v20, v4) || v21 < v20 || *((_QWORD *)this + 62) < v21)
        {
LABEL_30:
          _cg_jpeg_mem_term("decode_PAM_P7_RAW", 1276, "read error requested %ld bytes - got %d\n", v6, 0);
          v16 = 0;
          break;
        }
        memcpy(v6, (const void *)(v19 + v20), v4);
        *((_QWORD *)this + 59) += v4;
      }
      else if ((_DWORD)v4)
      {
        goto LABEL_30;
      }
      if (v9)
      {
        (*(void (**)(uint64_t, _QWORD *, _QWORD *))(*(_QWORD *)v9 + 16))(v9, v24, v23);
        a2 = (unsigned __int8 *)v23[0];
      }
      a2 += v5;
      v23[0] = a2;
      if (++v18 >= *((_DWORD *)this + 58))
      {
        v16 = 1;
        break;
      }
    }
  }
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  if (v6)
    free(v6);
  return v16;
}

void sub_188049960(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C401865CEE3);
  _Unwind_Resume(a1);
}

uint64_t PBMReadPlugin::decode_PFM_Pf_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
  unsigned int v2;
  unsigned int v5;
  float v6;
  size_t v7;
  float *v8;
  uint64_t v9;
  size_t v10;
  size_t v11;
  int v12;
  int v13;
  float v14;
  float v15;

  v2 = *((_DWORD *)this + 58);
  if (!v2)
    return 1;
  v5 = 0;
  v6 = *((float *)this + 114);
  v7 = *((unsigned int *)this + 57) * ((unint64_t)*((unsigned __int16 *)this + 121) >> 3);
  while (1)
  {
    v8 = (float *)&a2[*((_DWORD *)this + 75) * (v2 + ~v5)];
    if (v7)
    {
      v9 = *((_QWORD *)this + 61);
      if (v9)
      {
        v10 = *((_QWORD *)this + 59);
        v11 = v10 + v7;
        if (!__CFADD__(v10, v7) && v11 >= v10 && *((_QWORD *)this + 62) >= v11)
        {
          memcpy(v8, (const void *)(v9 + v10), v7);
          *((_QWORD *)this + 59) += v7;
          goto LABEL_9;
        }
      }
    }
    if (v7)
      break;
LABEL_9:
    v12 = *((_DWORD *)this + 57);
    if (v12)
    {
      v13 = *((unsigned __int8 *)this + 344);
      do
      {
        v14 = *v8;
        v15 = COERCE_FLOAT(bswap32(*(_DWORD *)v8));
        if (!v13)
          v14 = v15;
        *v8++ = v6 * v14;
        --v12;
      }
      while (v12);
    }
    ++v5;
    v2 = *((_DWORD *)this + 58);
    if (v5 >= v2)
      return 1;
  }
  _cg_jpeg_mem_term("decode_PFM_Pf_RAW", 1320, "read error requested %ld bytes - got %d\n", v7, 0);
  return 0;
}

uint64_t PBMReadPlugin::decode_PFM_PF_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
  size_t v4;
  unsigned int v5;
  char *v6;
  int v7;
  float v8;
  uint64_t v9;
  size_t v10;
  size_t v11;
  int v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  char *v16;
  uint64_t v17;
  float v18;
  float v19;
  uint64_t v20;

  v4 = *((unsigned int *)this + 59);
  v5 = *((_DWORD *)this + 75);
  v6 = (char *)malloc_type_malloc(v4, 0xCA8F4A50uLL);
  if (!*((_DWORD *)this + 58))
  {
LABEL_18:
    v20 = 1;
    if (v6)
      goto LABEL_19;
    return v20;
  }
  v7 = 0;
  v8 = *((float *)this + 114);
  while (1)
  {
    if ((_DWORD)v4)
    {
      v9 = *((_QWORD *)this + 61);
      if (v9)
        break;
    }
    if ((_DWORD)v4)
      goto LABEL_21;
LABEL_10:
    v12 = *((_DWORD *)this + 57);
    if (v12)
    {
      v13 = 0;
      v14 = &a2[v5 * (unint64_t)(*((_DWORD *)this + 74) + ~v7)];
      v15 = *((unsigned __int8 *)this + 344);
      v16 = v6;
      do
      {
        v17 = 0;
        do
        {
          v18 = *(float *)&v16[v17];
          v19 = COERCE_FLOAT(bswap32(LODWORD(v18)));
          if (!v15)
            v18 = v19;
          *(float *)&v14[v17] = v8 * v18;
          v17 += 4;
        }
        while ((_DWORD)v17 != 12);
        ++v13;
        v14 += v17;
        v16 += v17;
      }
      while (v13 != v12);
    }
    if (++v7 >= *((_DWORD *)this + 58))
      goto LABEL_18;
  }
  v10 = *((_QWORD *)this + 59);
  v11 = v10 + v4;
  if (!__CFADD__(v10, v4) && v11 >= v10 && *((_QWORD *)this + 62) >= v11)
  {
    memcpy(v6, (const void *)(v9 + v10), v4);
    *((_QWORD *)this + 59) += v4;
    goto LABEL_10;
  }
LABEL_21:
  _cg_jpeg_mem_term("decode_PFM_PF_RAW", 1362, "read error requested %ld bytes - got %d\n", v4, 0);
  v20 = 0;
  if (!v6)
    return v20;
LABEL_19:
  free(v6);
  return v20;
}

uint64_t PBMReadPlugin::decodeImageData(IIOImageReadSession **this, unsigned __int8 *a2)
{
  IIOImageReadSession *v4;
  int v5;
  uint64_t v6;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = 0;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v8, this[3]);
  v4 = (IIOImageReadSession *)v9;
  this[61] = (IIOImageReadSession *)*((_QWORD *)&v8 + 1);
  this[62] = v4;
  switch((unint64_t)this[55])
  {
    case 1uLL:
      PBMReadPlugin::decode_PBM_P1_TXT((PBMReadPlugin *)this, a2);
      goto LABEL_13;
    case 2uLL:
      PBMReadPlugin::decode_PBM_P2_TXT((PBMReadPlugin *)this, a2);
      goto LABEL_13;
    case 3uLL:
      v5 = PBMReadPlugin::decode_PPM_P3_TXT((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 4uLL:
      v5 = PBMReadPlugin::decode_PBM_P4_RAW((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 5uLL:
      v5 = PBMReadPlugin::decode_PGM_P5_RAW((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 6uLL:
      v5 = PBMReadPlugin::decode_PPM_P6_RAW((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 7uLL:
      v5 = PBMReadPlugin::decode_PAM_P7_RAW((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 8uLL:
      v5 = PBMReadPlugin::decode_PFM_Pf_RAW((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 9uLL:
      v5 = PBMReadPlugin::decode_PFM_PF_RAW((PBMReadPlugin *)this, a2);
LABEL_12:
      if (!v5)
        goto LABEL_14;
LABEL_13:
      v6 = 0;
      break;
    default:
      _cg_jpeg_mem_term("decodeImageData", 1442, "unknown PPM format [%d]", this[55]);
LABEL_14:
      v6 = 4294967246;
      break;
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v8);
  return v6;
}

void sub_188049D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t PBMReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL4 v20;
  void *BaseAddress;
  size_t Height;
  size_t v23;
  double v24;
  uint64_t BlockArray;
  double v26;
  unint64_t v27;
  unsigned int v28;
  vImagePixelCount v29;
  size_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  double v35;
  IIOImageRead **v36;
  const char **v37;
  vImage_Buffer dest;
  void *v40;
  unint64_t v41;
  CGRect v42;
  CGRect v43;

  v40 = 0;
  v41 = 0;
  if (!*((_QWORD *)this + 3))
    return 4294967292;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v8 = *((_DWORD *)this + 51);
    v9 = v8 >> 24;
    v10 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v11 = __maskrune(v9, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    }
    if (v11)
      v12 = (v8 >> 24);
    else
      v12 = 46;
    v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v14 = __maskrune(v13, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v8 << 8 >> 24);
    else
      v15 = 46;
    v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = ((__int16)v8 >> 8);
    else
      v18 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_23;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_23:
      v19 = *((char *)this + 204);
LABEL_26:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus PBMReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_27;
    }
    v19 = 46;
    goto LABEL_26;
  }
LABEL_27:
  IIOReadPlugin::debugDecodeImage(this, a2);
  IIOImageReadSession::rewind(*((_QWORD *)this + 3));
  v20 = IIOImageReadSession::mapData(*((IIOImageRead ***)this + 3));
  *((_QWORD *)this + 61) = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v40, 1);
  *((_QWORD *)this + 62) = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  *((_QWORD *)this + 59) = *((_QWORD *)this + 58);
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v27) = *((_DWORD *)this + 73);
    v26 = (double)v27;
    v28 = *((_DWORD *)this + 74);
    v24 = (double)v28;
    v23 = *((unsigned int *)this + 75) * (unint64_t)v28;
    BaseAddress = (void *)_ImageIO_Malloc(v23, *((_QWORD *)this + 48), &v41, (uint64_t)kImageMalloc_PBM_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      BlockArray = 4294967292;
      goto LABEL_46;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    v23 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v41 = v23;
    v24 = 0.0;
    BlockArray = 4294967292;
    v26 = 0.0;
  }
  if (BaseAddress)
  {
    bzero(BaseAddress, v23);
    BlockArray = (*(uint64_t (**)(IIOReadPlugin *, void *, size_t))(*(_QWORD *)this + 112))(this, BaseAddress, v23);
    if ((_DWORD)BlockArray)
    {
      *((_DWORD *)this + 26) = 0;
      if (a3 == 3)
        _ImageIO_Free((unint64_t)BaseAddress, v41);
    }
    else
    {
      if (*((_BYTE *)this + 406) == 1)
      {
        v29 = *((unsigned int *)this + 74);
        dest.data = BaseAddress;
        dest.height = v29;
        v30 = *((unsigned int *)this + 75);
        dest.width = *((unsigned int *)this + 73);
        dest.rowBytes = v30;
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0);
      }
      if (a3 == 3)
      {
        v31 = 0;
        v42.origin.x = 0.0;
        v42.origin.y = 0.0;
        v42.size.width = v26;
        v42.size.height = v24;
        **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v41, v42, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
        if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
        {
          v32 = 0;
        }
        else
        {
          v43.origin.x = 0.0;
          v43.origin.y = 0.0;
          v43.size.width = v26;
          v43.size.height = v24;
          *(CGRect *)(&v32 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v43);
          v31 = v33;
          v26 = v34;
          v24 = v35;
        }
        BlockArray = 0;
        *((_QWORD *)this + 15) = v31;
        *((_QWORD *)this + 16) = v32;
        *((double *)this + 17) = v26;
        *((double *)this + 18) = v24;
      }
      else
      {
        IOSurfaceUnlock(*a4, 0, 0);
        BlockArray = 0;
      }
    }
  }
LABEL_46:
  if (v40 && (v36 = (IIOImageRead **)*((_QWORD *)this + 3)) != 0)
  {
    IIOImageReadSession::releaseBytePointer(v36, v40);
    if (!v20)
      return BlockArray;
  }
  else if (!v20)
  {
    return BlockArray;
  }
  v37 = (const char **)*((_QWORD *)this + 3);
  if (v37)
    IIOImageReadSession::unmapData(v37);
  return BlockArray;
}

void sub_18804A19C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18804A030);
}

char *createNodePath(uint64_t a1)
{
  char *result;
  char *v3;
  char *v4;

  result = (char *)malloc_type_calloc(1uLL, 1uLL, 0x37070E98uLL);
  v4 = result;
  if (a1)
  {
    do
    {
      v3 = v4;
      if (*(_DWORD *)a1 > 1u)
      {
        switch(*(_DWORD *)a1)
        {
          case 2:
            asprintf(&v4, "%s[%d]");
            goto LABEL_4;
          case 3:
            asprintf(&v4, "%s[%s]");
            goto LABEL_4;
          case 4:
            asprintf(&v4, "%s.%s%s");
            goto LABEL_4;
          case 5:
            asprintf(&v4, "%s?%s%s");
            goto LABEL_4;
          default:
            break;
        }
      }
      else
      {
        asprintf(&v4, "%s%s%s");
LABEL_4:
        free(v3);
      }
      a1 = *(_QWORD *)(a1 + 40);
    }
    while (a1);
    return v4;
  }
  return result;
}

char *fixPrefixes(char *result)
{
  int *v1;
  const char *v2;
  const char *v3;
  int v4;

  v1 = (int *)*((_QWORD *)result + 5);
  if (v1)
  {
    v2 = (const char *)*((_QWORD *)result + 1);
    do
    {
      v3 = (const char *)*((_QWORD *)v1 + 1);
      if (!v3)
      {
        v4 = *v1;
        if (*v1 != 1 && v4 != 4)
        {
          if (v4 == 5 && v2 != 0)
          {
LABEL_15:
            result = strdup(v2);
            *((_QWORD *)v1 + 1) = result;
          }
          v3 = v2;
          goto LABEL_17;
        }
        if (v2)
          goto LABEL_15;
        v3 = 0;
      }
LABEL_17:
      v1 = (int *)*((_QWORD *)v1 + 5);
      v2 = v3;
    }
    while (v1);
  }
  return result;
}

CGPDFDocument *CreateSessionPDFRef(off_t *a1, BOOL *a2)
{
  CGDataProvider *v3;
  CGPDFDocument *v4;
  BOOL v5;
  CGDataProviderDirectCallbacks v7;

  *(_OWORD *)&v7.version = xmmword_1E1BCA2C8;
  *(_OWORD *)&v7.releaseBytePointer = *(_OWORD *)&off_1E1BCA2D8;
  v7.releaseInfo = (CGDataProviderReleaseInfoCallback)dpReleaseInfo;
  v3 = CGDataProviderCreateDirect(a1, a1[2], &v7);
  v4 = CGPDFDocumentCreateWithProvider(v3);
  CFRelease(v3);
  if (v4 && !CGPDFDocumentIsUnlocked(v4))
  {
    CGPDFDocumentRelease(v4);
    v4 = 0;
    v5 = 1;
    if (!a2)
      return v4;
    goto LABEL_4;
  }
  v5 = 0;
  if (a2)
LABEL_4:
    *a2 = v5;
  return v4;
}

uint64_t dpGetBytePointer(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 8);
  return result;
}

IIOScanner *dpGetBytesAtPosition(IIOScanner *this, void *__dst, uint64_t a3, size_t __n)
{
  if (this)
    return (IIOScanner *)IIOScanner::getBytesAtOffset(this, __dst, a3, __n);
  return this;
}

uint64_t IIO_CreateInputColorSpaceForOutputPoppyProfile()
{
  const ColorSyncProfile *InputPoppyProfile;
  const ColorSyncProfile *v1;
  CFDataRef v2;
  CFDataRef v3;
  uint64_t v4;
  CFErrorRef error;

  InputPoppyProfile = (const ColorSyncProfile *)ColorSyncCreateInputPoppyProfile();
  error = 0;
  if (!InputPoppyProfile)
    return 0;
  v1 = InputPoppyProfile;
  v2 = ColorSyncProfileCopyData(InputPoppyProfile, &error);
  if (v2)
  {
    v3 = v2;
    v4 = MEMORY[0x18D760CAC]();
    CFRelease(v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v1);
  return v4;
}

const ColorSyncProfile *IIO_CreateOutputPoppyProfileForImage(CGImageSource *a1, CGImageRef image, _QWORD *a3)
{
  CGImageSource *ThumbnailAtIndex;
  int Width;
  int Height;
  int v7;
  int v8;
  CGColorSpaceRef ColorSpace;
  CGImage *v10;
  size_t v11;
  size_t v12;
  const __CFString *v13;
  unint64_t v14;
  double v15;
  float v16;
  CGColorSpace *v17;
  const __CFString *Property;
  const __CFString *v19;
  size_t v20;
  size_t v21;
  CGContext *v22;
  CGContext *v23;
  CGImageRef v24;
  CGImage *v25;
  CGContext *v26;
  void *Data;
  const ColorSyncProfile *OutputPoppyProfileForRGBData;
  const ColorSyncProfile *v29;
  const __CFData *v30;
  const __CFData *v31;
  CFIndex Length;
  CGColorSpace *v33;
  _BOOL4 v34;
  int v35;
  FILE *v36;
  CGColorSpace *space;
  char *__filename[3];
  CFErrorRef error;
  CFDictionaryRef options;
  uint64_t v43;
  CGRect v44;
  CGRect v45;

  ThumbnailAtIndex = a1;
  *a3 = 0;
  if (a1)
  {
    error = 0;
    options = 0;
    v43 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&error);
    IIONumber::IIONumber((IIONumber *)__filename, 160);
    IIODictionary::setObjectForKey((IIODictionary *)&error, __filename[2], CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
    IIONumber::~IIONumber((IIONumber *)__filename);
    IIODictionary::setObjectForKey((IIODictionary *)&error, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent"));
    ThumbnailAtIndex = CGImageSourceCreateThumbnailAtIndex(ThumbnailAtIndex, 0, options);
    IIODictionary::~IIODictionary((IIODictionary *)&error);
  }
  if ((gIIODebugFlags & 0x8000000000) != 0)
  {
    Width = CGImageGetWidth(image);
    Height = CGImageGetHeight(image);
    ImageIOLog("COL image: %p [%d x %d]\n", image, Width, Height);
    if ((gIIODebugFlags & 0x8000300000) != 0)
    {
      v7 = CGImageGetWidth(ThumbnailAtIndex);
      v8 = CGImageGetHeight(ThumbnailAtIndex);
      ImageIOLog("COL thumb: %p [%d x %d]\n", ThumbnailAtIndex, v7, v8);
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL color: ");
    }
    ColorSpace = CGImageGetColorSpace(image);
    CFShow(ColorSpace);
  }
  if (ThumbnailAtIndex)
    v10 = ThumbnailAtIndex;
  else
    v10 = image;
  error = 0;
  v11 = CGImageGetWidth(v10);
  v12 = CGImageGetHeight(v10);
  v13 = (const __CFString *)*MEMORY[0x1E0C9D908];
  space = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D908]);
  if (v11 >= v12)
    v14 = v12;
  else
    v14 = v11;
  if (v14)
  {
    v15 = 24.0 / (double)v14;
    if (v15 > 1.0)
      v15 = 1.0;
    v16 = v15;
  }
  else
  {
    v16 = 1.0;
  }
  v17 = CGImageGetColorSpace(v10);
  if (!CGColorSpaceSupportsOutput(v17))
    v17 = space;
  Property = (const __CFString *)CGImageGetProperty();
  v19 = Property;
  v20 = vcvtms_u32_f32(v16 * (float)v11);
  v21 = vcvtms_u32_f32(v16 * (float)v12);
  if (!Property
    || CFStringCompare(Property, CFSTR("public.jpeg"), 0) && CFStringCompare(v19, CFSTR("public.heic"), 0))
  {
    goto LABEL_29;
  }
  v22 = CGBitmapContextCreate(0, 2 * v20, 2 * v21, 8uLL, 8 * v20, v17, 5u);
  v23 = v22;
  if (!v22)
  {
    _cg_jpeg_mem_term("IIO_CreateOutputPoppyProfileForImage", 218, "*** ERROR: CGBitmapContextCreate returned NULL\n");
LABEL_29:
    v25 = 0;
    goto LABEL_30;
  }
  v44.size.width = (double)(2 * v20);
  v44.size.height = (double)(2 * v21);
  v44.origin.x = 0.0;
  v44.origin.y = 0.0;
  CGContextDrawImage(v22, v44, v10);
  v24 = CGBitmapContextCreateImage(v23);
  v25 = v24;
  if (v24)
    v10 = v24;
  CGContextRelease(v23);
LABEL_30:
  v26 = CGBitmapContextCreate(0, v20, v21, 0x10uLL, 8 * v20, v17, 0x1105u);
  if (v26)
  {
    CGContextSetInterpolationQualityRange();
    v45.size.width = (double)v20;
    v45.size.height = (double)v21;
    v45.origin.x = 0.0;
    v45.origin.y = 0.0;
    CGContextDrawImage(v26, v45, v10);
    Data = CGBitmapContextGetData(v26);
    OutputPoppyProfileForRGBData = (const ColorSyncProfile *)ColorSyncCreateOutputPoppyProfileForRGBData();
    v29 = OutputPoppyProfileForRGBData;
    if (OutputPoppyProfileForRGBData)
    {
      v30 = ColorSyncProfileCopyData(OutputPoppyProfileForRGBData, &error);
      v31 = v30;
      if (v30)
      {
        if ((gIIODebugFlags & 0x8000300000) != 0)
        {
          Length = CFDataGetLength(v30);
          ImageIOLog("COL IIO_ColorSyncCreateOutputPoppyProfileForRGBData returned poppy profile [%p] data: %ld bytes\n", v29, Length);
        }
        *a3 = MEMORY[0x18D760CAC](v31);
        CFRelease(v31);
      }
    }
    else
    {
      v33 = CGImageGetColorSpace(v10);
      v34 = IIO_CGColorSpaceNameMatchesName(v33, v13);
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        if (v34)
          ImageIOLog("COL IIO_ColorSyncCreateOutputPoppyProfileForRGBData returned nil - original image is P3\n");
        else
          ImageIOLog("COL IIO_ColorSyncCreateOutputPoppyProfileForRGBData returned nil - original image is not P3\n");
      }
      if ((gIIODebugFlags & 0x8000000000) != 0)
      {
        __filename[0] = 0;
        v35 = IIO_CreateOutputPoppyProfileForImage::tCount++;
        asprintf(__filename, "/tmp/poppy-thumb_%d w=%ld, h=%ld, rb=%ld, bpc=16, cs=RGB, f=1, bo=16l, a=pl.br2", v35, v20, v21, 8 * v20);
        v36 = fopen(__filename[0], "w");
        if (v36)
        {
          fwrite(Data, v21, 8 * v20, v36);
          fclose(v36);
        }
        free(__filename[0]);
      }
    }
    CGContextRelease(v26);
  }
  else
  {
    _cg_jpeg_mem_term("IIO_CreateOutputPoppyProfileForImage", 234, "*** ERROR: CGBitmapContextCreate returned NULL\n");
    v29 = 0;
  }
  if (ThumbnailAtIndex)
    CGImageRelease(ThumbnailAtIndex);
  if (v25)
    CGImageRelease(v25);
  CGColorSpaceRelease(space);
  return v29;
}

void sub_18804A960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, CGColorSpaceRef space, char a15, uint64_t a16, uint64_t a17, char a18)
{
  CGColorSpaceRelease(space);
  _Unwind_Resume(a1);
}

uint64_t IIO_ColorSpaceCreateCopyWithFlexGTCInfo()
{
  uint64_t v0;
  const void *v1;
  const ColorSyncProfile *CopyWithFlexGTC;
  const ColorSyncProfile *v3;
  uint64_t v4;

  v0 = CGColorSpaceCopyColorSyncProfile();
  if (!v0)
    return 0;
  v1 = (const void *)v0;
  CopyWithFlexGTC = (const ColorSyncProfile *)ColorSyncProfileCreateCopyWithFlexGTC();
  if (CopyWithFlexGTC)
  {
    v3 = CopyWithFlexGTC;
    v4 = 0;
    if (ColorSyncProfileVerify(CopyWithFlexGTC, 0, 0))
      v4 = MEMORY[0x18D760CA0](v3, 0);
    CFRelease(v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v1);
  return v4;
}

uint64_t IIO_ColorSpaceAddToStream(CGColorSpace *a1, CFWriteStreamRef stream)
{
  CFPropertyListRef v4;
  const void *v5;
  const __CFData *Data;
  const __CFData *v7;
  const UInt8 *BytePtr;
  _BYTE buffer[12];

  buffer[5] = 0;
  *(_WORD *)&buffer[6] = 0;
  *(_DWORD *)&buffer[8] = 0;
  strcpy(buffer, "ICC ");
  CFWriteStreamWrite(stream, buffer, 4);
  if (a1)
  {
    v4 = CGColorSpaceCopyPropertyList(a1);
    if (v4)
    {
      v5 = v4;
      Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, kCFPropertyListXMLFormat_v1_0, 0, 0);
      if (Data)
      {
        v7 = Data;
        *(_QWORD *)&buffer[4] = CFDataGetLength(Data);
        if (*(_QWORD *)&buffer[4])
        {
          CFWriteStreamWrite(stream, &buffer[4], 8);
          BytePtr = CFDataGetBytePtr(v7);
          CFWriteStreamWrite(stream, BytePtr, *(CFIndex *)&buffer[4]);
        }
        CFRelease(v7);
      }
      CFRelease(v5);
    }
  }
  if (!*(_QWORD *)&buffer[4])
    CFWriteStreamWrite(stream, &buffer[4], 8);
  return 0;
}

CGColorSpaceRef IIO_ColorSpaceCreateFromStream(__CFReadStream *a1)
{
  CGColorSpaceRef v2;
  UInt8 *v4;
  UInt8 *v5;
  CFIndex v6;
  const __CFAllocator *v7;
  const __CFData *v8;
  const __CFData *v9;
  CFPropertyListRef v10;
  const void *v11;
  CFErrorRef error;
  UInt8 buffer[4];
  UInt8 v15[8];

  *(_QWORD *)v15 = 0;
  *(_DWORD *)buffer = 0;
  v2 = 0;
  if (CFReadStreamRead(a1, buffer, 4) == 4 && *(_DWORD *)buffer == 541279049)
  {
    v2 = 0;
    if (CFReadStreamRead(a1, v15, 8) == 8 && *(uint64_t *)v15 >= 1)
    {
      error = 0;
      v4 = (UInt8 *)malloc_type_malloc(*(size_t *)v15, 0x47689F12uLL);
      if (v4)
      {
        v5 = v4;
        v6 = CFReadStreamRead(a1, v4, *(CFIndex *)v15);
        if (*(_QWORD *)v15 == v6
          && (v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00],
              (v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5, v6, (CFAllocatorRef)*MEMORY[0x1E0C9AE20])) != 0))
        {
          v9 = v8;
          v10 = CFPropertyListCreateWithData(v7, v8, 0, 0, &error);
          if (v10)
          {
            v11 = v10;
            v2 = CGColorSpaceCreateWithPropertyList(v10);
            CFRelease(v11);
          }
          else
          {
            v2 = 0;
          }
          CFRelease(v9);
        }
        else
        {
          v2 = 0;
        }
        free(v5);
      }
      else
      {
        return 0;
      }
    }
  }
  return v2;
}

uint64_t IIO_ColorSpaceNameAddToStream(const __CFString *a1, CFWriteStreamRef stream)
{
  int Length;
  const char *CStringPtr;
  const UInt8 *v6;
  UInt8 buffer[4];

  *(_DWORD *)buffer = 0;
  if (!a1)
    goto LABEL_6;
  Length = CFStringGetLength(a1);
  *(_DWORD *)buffer = Length;
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr && Length)
  {
    v6 = (const UInt8 *)CStringPtr;
    CFWriteStreamWrite(stream, buffer, 4);
    CFWriteStreamWrite(stream, v6, *(unsigned int *)buffer);
    Length = *(_DWORD *)buffer;
  }
  if (!Length)
LABEL_6:
    CFWriteStreamWrite(stream, buffer, 4);
  return 0;
}

CFStringRef IIO_ColorSpaceNameCreateFromStream(__CFReadStream *a1)
{
  CFStringRef v3;
  UInt8 *v4;
  CFIndex v5;
  UInt8 buffer[4];

  *(_DWORD *)buffer = 0;
  if (CFReadStreamRead(a1, buffer, 4) != 4 || *(_DWORD *)buffer == 0)
    return 0;
  v4 = (UInt8 *)malloc_type_malloc(*(unsigned int *)buffer, 0x8DABDB9FuLL);
  v5 = CFReadStreamRead(a1, v4, *(unsigned int *)buffer);
  if (v5 == *(unsigned int *)buffer)
    v3 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, v5, 0x8000100u, 1u);
  else
    v3 = 0;
  free(v4);
  return v3;
}

void IIOColorConverter::createConverterWithColorSpaces(IIOColorConverter *this, vImage_CGImageFormat *a2, vImage_CGImageFormat *a3, CGColorSpaceRef src, CGColorSpaceRef dst)
{
  const CGColorConversionInfo *v8;
  const CGColorConversionInfo *v9;
  vImage_Error error;

  error = 0;
  v8 = CGColorConversionInfoCreate(src, dst);
  if (v8)
  {
    v9 = v8;
    *((_QWORD *)this + 1) = vImageConverter_CreateWithCGColorConversionInfo(v8, a2, a3, 0, 0, &error);
    CFRelease(v9);
  }
}

void IIOColorConverter::IIOColorConverter(IIOColorConverter *this, vImage_CGImageFormat *a2, vImage_CGImageFormat *a3, CGColorSpace *a4, CGColorSpace *a5)
{
  *(_QWORD *)this = &off_1E1BB1040;
  *((_QWORD *)this + 1) = 0;
  IIOColorConverter::createConverterWithColorSpaces(this, a2, a3, a4, a5);
}

void IIOColorConverter::IIOColorConverter(IIOColorConverter *this, CGColorSpaceRef src, CGColorSpaceRef dst)
{
  vImage_CGImageFormat v3;
  vImage_CGImageFormat v4;

  *(_QWORD *)this = &off_1E1BB1040;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)&v4.bitsPerComponent = 0x2000000008;
  v4.colorSpace = src;
  v4.bitmapInfo = 8198;
  memset(&v4.version, 0, 20);
  *(_QWORD *)&v3.bitsPerComponent = 0x2000000008;
  v3.colorSpace = dst;
  v3.bitmapInfo = 8198;
  memset(&v3.version, 0, 20);
  IIOColorConverter::createConverterWithColorSpaces(this, &v4, &v3, src, dst);
}

void IIOColorConverter::~IIOColorConverter(IIOColorConverter *this)
{
  vImageConverter *v1;

  *(_QWORD *)this = &off_1E1BB1040;
  v1 = (vImageConverter *)*((_QWORD *)this + 1);
  if (v1)
    vImageConverter_Release(v1);
}

{
  IIOColorConverter::~IIOColorConverter(this);
  JUMPOUT(0x18D761C30);
}

vImage_Error IIOColorConverter::colorConvert(IIOColorConverter *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  vImageConverter *v3;
  vImage_Error v4;
  vImage_Error v5;
  const char *v6;

  v3 = (vImageConverter *)*((_QWORD *)this + 1);
  if (!v3)
    return -50;
  v4 = iio_vImageConvert_AnyToAny(v3, a2, a3, 0, 0x10u);
  v5 = v4;
  if (v4)
  {
    v6 = IIO_vImageErrorString(v4);
    LogError("colorConvert", 521, "*** ERROR: vImageConvert_AnyToAny - %d - '%s'\n", v5, v6);
  }
  return v5;
}

CGImage *CGImageCreateFromIOSurface(__IOSurface *a1, const __CFDictionary *a2)
{
  signed int PixelFormat;
  CGImageAlphaInfo Alpha;
  size_t Width;
  size_t Height;
  CFTypeRef v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  CGImage *v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  const char *v22;
  const char *v23;
  double Current;
  unsigned __int16 v25;
  int v26;
  unsigned int *v27;
  CFAbsoluteTime v28;
  CGColorSpace *ColorSpace;
  uint64_t v31;
  CGImageAlphaInfo v32;
  _QWORD v33[3];
  _QWORD v34[3];
  char __str[16];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  IIOInitDebugFlags();
  memset(v34, 0, sizeof(v34));
  IIODictionary::IIODictionary((IIODictionary *)v34, a2);
  if (!a1)
  {
    v12 = 0;
    goto LABEL_54;
  }
  PixelFormat = IOSurfaceGetPixelFormat(a1);
  Alpha = IIO_IOSurfaceGetAlpha(a1);
  Width = IOSurfaceGetWidth(a1);
  Height = IOSurfaceGetHeight(a1);
  kdebug_trace();
  if ((gIIODebugFlags & 0x8000) != 0)
  {
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    *(_OWORD *)__str = 0u;
    v36 = 0u;
    v8 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E0CBC048]);
    v32 = Alpha;
    memset(v33, 0, sizeof(v33));
    IIOString::IIOString((IIOString *)v33, v8);
    v9 = PixelFormat >> 24;
    v10 = MEMORY[0x1E0C80978];
    if (PixelFormat < 0)
      v11 = __maskrune(PixelFormat >> 24, 0x40000uLL);
    else
      v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    if (v11)
      v13 = v9;
    else
      v13 = 46;
    v31 = v13;
    v14 = PixelFormat << 8 >> 24;
    if (PixelFormat << 8 < 0)
      v15 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
    else
      v15 = *(_DWORD *)(v10 + 4 * v14 + 60) & 0x40000;
    if (v15)
      v16 = v14;
    else
      v16 = 46;
    v17 = (__int16)PixelFormat >> 8;
    if (PixelFormat << 16 < 0)
      v18 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
    else
      v18 = *(_DWORD *)(v10 + 4 * v17 + 60) & 0x40000;
    if (v18)
      v19 = v17;
    else
      v19 = 46;
    if ((PixelFormat << 24) <= 0x7F000000)
      v20 = *(_DWORD *)(v10 + 4 * (char)PixelFormat + 60) & 0x40000;
    else
      v20 = __maskrune((char)PixelFormat, 0x40000uLL);
    if (v20)
      v21 = (char)PixelFormat;
    else
      v21 = 46;
    v22 = (const char *)IIOString::utf8String((IIOString *)v33);
    v23 = IIO_AlphaInfoString(v32);
    snprintf(__str, 0x60uLL, "<IOSurface: %p>  %dx%d '%c%c%c%c' '%s' %s", a1, Width, Height, v31, v16, v19, v21, v22, v23);
    if (v8)
      CFRelease(v8);
    IIOString::~IIOString((IIOString *)v33);
    if ((unsigned __int16)gIIODebugFlags >> 14)
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateFromIOSurface", 0, __str, -1, a2);
    Alpha = v32;
  }
  Current = CFAbsoluteTimeGetCurrent();
  if (PixelFormat > 2016686641)
  {
    if (PixelFormat <= 2019963439)
    {
      if (PixelFormat != 2016686642)
      {
        v25 = 13364;
LABEL_46:
        v26 = v25 | 0x78340000;
LABEL_47:
        if (PixelFormat != v26)
        {
          v27 = (unsigned int *)operator new();
          IIOIOSurfaceWrapper::IIOIOSurfaceWrapper((IIOIOSurfaceWrapper *)v27, a1, Width, Height, PixelFormat, Alpha, (IIODictionary *)v34);
          goto LABEL_49;
        }
      }
    }
    else if (PixelFormat != 2019963440 && PixelFormat != 2019963442)
    {
      v26 = 2019963956;
      goto LABEL_47;
    }
  }
  else
  {
    if (PixelFormat > 1647534391)
    {
      if (PixelFormat == 1647534392 || PixelFormat == 1999843442)
      {
        v27 = (unsigned int *)operator new();
        IIOIOSurfaceWrapper_CIF10::IIOIOSurfaceWrapper_CIF10((IIOIOSurfaceWrapper_CIF10 *)v27, a1, Width, Height, PixelFormat, Alpha, (IIODictionary *)v34);
        goto LABEL_49;
      }
      v25 = 12848;
      goto LABEL_46;
    }
    if (PixelFormat != 875704422)
    {
      v26 = 875704438;
      goto LABEL_47;
    }
  }
  v27 = (unsigned int *)operator new();
  IIOIOSurfaceWrapper_YCC::IIOIOSurfaceWrapper_YCC((IIOIOSurfaceWrapper_YCC *)v27, a1, Width, Height, PixelFormat, Alpha, (IIODictionary *)v34);
LABEL_49:
  v12 = (CGImage *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v27 + 16))(v27);
  IIOString::IIOString((IIOString *)__str, v27[22]);
  CGImageSetProperty();
  IIOString::~IIOString((IIOString *)__str);
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    v28 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    CGImageCreateFromIOSurface - %g ms\n", (v28 - Current) * 1000.0);
  }
  if (v12)
  {
    CGImageGetWidth(v12);
    CGImageGetHeight(v12);
    CGImageGetBitsPerPixel(v12);
    CGImageGetBitsPerComponent(v12);
    ColorSpace = CGImageGetColorSpace(v12);
    CGColorSpaceGetModel(ColorSpace);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(v12);
  }
  kdebug_trace();
LABEL_54:
  IIODictionary::~IIODictionary((IIODictionary *)v34);
  return v12;
}

void sub_18804B534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  uint64_t v16;
  va_list va;

  va_start(va, a16);
  MEMORY[0x18D761C30](v16, 0x10B1C403AEDC547);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageWasCreatedWithIOSurface(uint64_t a1)
{
  return IIO_CGImageWrapsIOSurface(a1, 0);
}

void IIOIOSurfaceWrapperBase::IIOIOSurfaceWrapperBase(IIOIOSurfaceWrapperBase *this, __IOSurface *a2, size_t WidthOfPlane, size_t HeightOfPlane, int a5, CGImageAlphaInfo a6, IIODictionary *a7)
{
  size_t PlaneCount;
  uint64_t v15;
  uint64_t Uint32ForKey;

  *(_QWORD *)this = &off_1E1B81520;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  *((_QWORD *)this + 9) = a2;
  *((_QWORD *)this + 19) = 0;
  *((_BYTE *)this + 200) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_WORD *)this + 110) = -1;
  *((_QWORD *)this + 24) = 0;
  IOSurfaceIncrementUseCount(a2);
  IIOFrameBufferRetain(*((CFTypeRef *)this + 9));
  *((_BYTE *)this + 208) = -1;
  *((_DWORD *)this + 53) = 0;
  *((_DWORD *)this + 54) = 0;
  *((_BYTE *)this + 142) = 0;
  *(_WORD *)((char *)this + 201) = -256;
  *((_DWORD *)this + 22) = a5;
  *((_QWORD *)this + 10) = IIO_IOSurfaceCopyColorSpace(*((__IOSurface **)this + 9));
  *((_BYTE *)this + 140) = IOSurfaceGetProtectionOptions() != 0;
  if (!WidthOfPlane)
    WidthOfPlane = IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 0);
  *((_QWORD *)this + 12) = WidthOfPlane;
  if (!HeightOfPlane)
    HeightOfPlane = IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 0);
  *((_QWORD *)this + 13) = HeightOfPlane;
  *((_QWORD *)this + 14) = IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 0);
  *((_QWORD *)this + 15) = IOSurfaceGetBytesPerElementOfPlane(*((IOSurfaceRef *)this + 9), 0);
  *((_DWORD *)this + 34) = a6;
  PlaneCount = IOSurfaceGetPlaneCount(*((IOSurfaceRef *)this + 9));
  *((_QWORD *)this + 16) = PlaneCount;
  *((_BYTE *)this + 141) = 0;
  if (PlaneCount)
  {
    v15 = 0;
    while (!IOSurfaceGetCompressionTypeOfPlane())
    {
      if ((unint64_t)++v15 >= *((_QWORD *)this + 16))
        goto LABEL_11;
    }
    *((_BYTE *)this + 141) = 1;
  }
LABEL_11:
  *((_DWORD *)this + 51) = 0;
  if (IIODictionary::containsKey(a7, CFSTR("CGImageAlphaInfo")))
  {
    *((_BYTE *)this + 202) = 1;
    Uint32ForKey = (uint64_t)IIODictionary::getUint32ForKey(a7, CFSTR("CGImageAlphaInfo"));
    *((_DWORD *)this + 51) = Uint32ForKey;
    if (Uint32ForKey > 5 || ((1 << Uint32ForKey) & 0x2A) == 0)
      *((_DWORD *)this + 51) = _AlphaTogglePosition(Uint32ForKey);
  }
  *((_QWORD *)this + 20) = 0;
}

void IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(IIOIOSurfaceWrapperBase *this)
{
  __IOSurface *v2;
  CFTypeRef v3;
  void *BaseAddress;

  *(_QWORD *)this = &off_1E1B81520;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  v2 = (__IOSurface *)*((_QWORD *)this + 9);
  if (v2)
  {
    if (*((_QWORD *)this + 10))
    {
      CGColorSpaceRelease(*((CGColorSpaceRef *)this + 10));
      v2 = (__IOSurface *)*((_QWORD *)this + 9);
    }
    v3 = IOSurfaceCopyValue(v2, CFSTR("com.apple.ImageIO.ImageIO_Malloced"));
    if (v3)
    {
      IOSurfaceRemoveValue(*((IOSurfaceRef *)this + 9), CFSTR("com.apple.ImageIO.ImageIO_Malloced"));
      BaseAddress = IOSurfaceGetBaseAddress(*((IOSurfaceRef *)this + 9));
      _ImageIO_Free((unint64_t)BaseAddress, 0);
      CFRelease(v3);
    }
    IOSurfaceDecrementUseCount(*((IOSurfaceRef *)this + 9));
    IIO_IOSurfaceRelease(*((__IOSurface **)this + 9));
  }
}

{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(this);
  JUMPOUT(0x18D761C30);
}

void IIOIOSurfaceWrapperBase::completeSetup(IIOIOSurfaceWrapperBase *this, IIODictionary *a2, CFStringRef name)
{
  CGColorSpace *v5;
  unsigned int v6;
  BOOL v7;
  int v8;

  *((_DWORD *)this + 40) = *((_DWORD *)this + 40) & 0xFFFFFFE0 | *((_DWORD *)this + 41);
  if (name && !*((_QWORD *)this + 10))
  {
    v5 = CGColorSpaceCreateWithName(name);
    *((_QWORD *)this + 10) = v5;
    IIO_IOSurfaceAddColorSpace(*((__IOSurface **)this + 9), v5);
  }
  if (a2 && IIODictionary::containsKey(a2, CFSTR("kCGImageComponentTypeRequest")))
  {
    *((_BYTE *)this + 208) = 1;
    *((_DWORD *)this + 53) = IIODictionary::getUint32ForKey(a2, CFSTR("kCGImageComponentTypeRequest"));
  }
  v6 = *((_DWORD *)this + 53);
  v7 = v6 > 6;
  v8 = (1 << v6) & 0x64;
  if (v7 || v8 == 0)
    *((_DWORD *)this + 53) = 1;
}

uint64_t IIOIOSurfaceWrapperBase::createImage(IIOIOSurfaceWrapperBase *this)
{
  return 0;
}

uint64_t IIOIOSurfaceWrapperBase::createBlockSetForCompressedSurface(uint64_t a1, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, _QWORD *a8)
{
  uint64_t PixelSize;
  void *v15;
  size_t v16;
  CGContextRef v17;
  CGContext *v18;
  unint64_t v19;
  double v20;
  uint64_t v21;

  PixelSize = CGImageProviderGetPixelSize();
  v15 = (void *)_ImageIO_Malloc(*(_QWORD *)(a1 + 96) * PixelSize * *(_QWORD *)(a1 + 104), 64, (size_t *)(a1 + 176), (uint64_t)kImageMalloc_IOSurface_Data, 0, 0, 0);
  *(_QWORD *)(a1 + 168) = v15;
  if (v15)
  {
    if (*(_DWORD *)(a1 + 216) == 1)
      v16 = 8;
    else
      v16 = 16;
    v17 = CGBitmapContextCreate(v15, *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), v16, *(_QWORD *)(a1 + 96) * PixelSize, *(CGColorSpaceRef *)(a1 + 80), *(_DWORD *)(a1 + 160));
    if (v17)
    {
      v18 = v17;
      CGContextErase();
      CGContextSetRGBStrokeColor(v18, 1.0, 0.0, 0.0, 1.0);
      v19 = *(_QWORD *)(a1 + 96);
      if (v19 >= *(_QWORD *)(a1 + 104))
        v19 = *(_QWORD *)(a1 + 104);
      v20 = (double)v19;
      CGContextSetLineWidth(v18, (double)v19 / 20.0);
      CGContextAddArc(v18, (double)(*(_QWORD *)(a1 + 96) >> 1), (double)(*(_QWORD *)(a1 + 104) >> 1), v20 / 6.0, 3437.74677, -3437.74677, 0);
      CGContextStrokePath(v18);
      CGContextFlush(v18);
      CFRelease(v18);
    }
    CGImageBlockCreate();
    v21 = CGImageBlockSetCreate();
  }
  else
  {
    v21 = 0;
  }
  *a8 = (*(uint64_t (**)(uint64_t, _QWORD, double, double, double, double))(*(_QWORD *)a1 + 64))(a1, 0, a2, a3, a4, a5);
  return v21;
}

const char *IIOIOSurfaceWrapperBase::ImageBlockReleaseNonCached(const char *result, const void *a2)
{
  unint64_t Data;

  if ((gIIODebugFlags & 0xC00) != 0)
    result = IIO_ImageBlockReleased(result, a2);
  if (a2)
  {
    Data = CGImageBlockGetData();
    return (const char *)_ImageIO_Free(Data, 0);
  }
  return result;
}

const char *IIOIOSurfaceWrapperBase::ImageBlockSetReleaseInfo(const char *this, void *a2)
{
  if ((gIIODebugFlags & 0xC00) != 0)
    return IIO_ImageBlockSetReleased(this);
  return this;
}

unint64_t IIOIOSurfaceWrapperBase::packDebugInfo(IIOIOSurfaceWrapperBase *this, CGRect a2, uint64_t a3)
{
  unint64_t v3;

  v3 = (*((_DWORD *)this + 54) << 28) | (unint64_t)(a3 << 32) | ((unint64_t)(*((_DWORD *)this + 51) & 0xF) << 24);
  if (*((_BYTE *)this + 142))
    v3 |= 0x400000uLL;
  if (*((_BYTE *)this + 202) == 1)
    v3 |= 0x100000uLL;
  if (*((_BYTE *)this + 208) == 1)
    v3 |= 0x40000uLL;
  if (*((_BYTE *)this + 140))
    v3 |= 0x10000uLL;
  if (*((_BYTE *)this + 141))
    v3 |= 0x4000uLL;
  if (a2.origin.y > 0.0 || a2.origin.x > 0.0)
    v3 |= 0x100uLL;
  if (a2.size.width < (double)*((unint64_t *)this + 12)
    || a2.size.height < (double)*((unint64_t *)this + 13))
  {
    v3 |= 0x40uLL;
  }
  if (*((_BYTE *)this + 201))
    return v3 | 0x10;
  else
    return v3;
}

uint64_t IIOIOSurfaceWrapperBase::preCopyBlockSet(IIOIOSurfaceWrapperBase *this, int a2, CGRect a3, CGSize a4, IIODictionary *a5)
{
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *ObjectForKey;

  *((_BYTE *)this + 200) = 0;
  if (a2 == 8)
  {
    v7 = (const __CFString *)*MEMORY[0x1E0C9DAB0];
    if (IIODictionary::containsKey(a5, (const __CFString *)*MEMORY[0x1E0C9DAB0]))
    {
      v8 = (const __CFString *)*MEMORY[0x1E0C9DAA8];
      ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a5, v7);
      if (CFStringCompare(v8, ObjectForKey, 0) == kCFCompareEqualTo)
        *((_BYTE *)this + 200) = 1;
    }
  }
  return 0;
}

uint64_t IIOIOSurfaceWrapperBase::postCopyBlockSet(uint64_t this)
{
  *(_QWORD *)(this + 144) = 0;
  *(_QWORD *)(this + 152) = 0;
  *(_QWORD *)(this + 168) = 0;
  *(_QWORD *)(this + 176) = 0;
  *(_DWORD *)(this + 184) = 0;
  return this;
}

uint64_t IIOIOSurfaceWrapperBase::CopyImageBlockSetWithOptionsNoOp(uint64_t a1)
{
  CGImageProviderSetProperty();
  if (*(_BYTE *)(a1 + 140))
    LogError("CopyImageBlockSetWithOptionsNoOp", 551, "*** ERROR: cannot copy data from protected IOSurface\n");
  return 0;
}

const char *IIOIOSurfaceWrapperBase::ImageBlockSetReleaseInfoNoCopy(const char *this, void *a2)
{
  if ((gIIODebugFlags & 0xC00) != 0)
    return IIO_ImageBlockSetReleased(this);
  return this;
}

const char *IIOIOSurfaceWrapperBase::ImageBlockReleaseNoCopy(const char *result, const void *a2)
{
  const char *v2;

  v2 = result;
  if ((gIIODebugFlags & 0xC00) != 0)
    result = IIO_ImageBlockReleased(result, a2);
  if (v2)
    return (const char *)IOSurfaceUnlock(*((IOSurfaceRef *)v2 + 9), 1u, 0);
  return result;
}

__IOSurface *IIOIOSurfaceWrapperBase::CopyIOSurface(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  __IOSurface *v5;
  _QWORD v7[3];

  IIOPackCopyCallbackInfo(a3);
  CGImageProviderGetBitmapInfo();
  kdebug_trace();
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a3);
  IIOFrameBufferRetain(*(CFTypeRef *)(a1 + 72));
  v5 = *(__IOSurface **)(a1 + 72);
  IOSurfaceGetWidth(v5);
  IOSurfaceGetHeight(v5);
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  return v5;
}

void sub_18804BEB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

unint64_t IIOPackCopyCallbackInfo(const __CFDictionary *a1)
{
  unint64_t v2;
  int v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  if (!a1)
    return 0xAAA0000000000000;
  if (CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E0C9DAB0]))
    v2 = 0x4000000000000000;
  else
    v2 = 0x8000000000000000;
  v3 = CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E0C9DAC0]);
  v4 = 0x1000000000000000;
  if (!v3)
    v4 = 0x2000000000000000;
  v5 = v4 | v2;
  if (CFDictionaryContainsKey(a1, CFSTR("kCGImageBlockIOSurfaceOptimizedRequest")))
    v6 = 0x400000000000000;
  else
    v6 = 0x800000000000000;
  v7 = CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E0C9DAA0]);
  v8 = 0x100000000000000;
  if (!v7)
    v8 = 0x200000000000000;
  v9 = v5 | v6 | v8;
  v10 = CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E0C9DA90]);
  v11 = 0x40000000000000;
  if (!v10)
    v11 = 0x80000000000000;
  v12 = v9 | v11;
  if (CFDictionaryContainsKey(a1, (const void *)*MEMORY[0x1E0C9DA98]))
    return v12 | 0x10000000000000;
  else
    return v12 | 0x20000000000000;
}

uint64_t IIOIOSurfaceWrapperBase::ReleaseInfo(uint64_t this, void *a2)
{
  if (this)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 8))(this);
  return this;
}

void IIOIOSurfaceWrapper::IIOIOSurfaceWrapper(IIOIOSurfaceWrapper *this, __IOSurface *a2, size_t a3, size_t a4, int a5, CGImageAlphaInfo a6, IIODictionary *a7)
{
  IIOIOSurfaceWrapper *v8;
  const __CFString *v9;

  IIOIOSurfaceWrapperBase::IIOIOSurfaceWrapperBase(this, a2, a3, a4, a5, a6, a7);
  *(_QWORD *)v8 = &off_1E1BB1B58;
  IIOIOSurfaceWrapper::completeSetup(v8, a7, v9);
}

void sub_18804C034(_Unwind_Exception *a1)
{
  IIOIOSurfaceWrapperBase *v1;

  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(v1);
  _Unwind_Resume(a1);
}

void IIOIOSurfaceWrapper::completeSetup(IIOIOSurfaceWrapper *this, IIODictionary *a2, const __CFString *a3)
{
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  BOOL v9;
  int v10;
  const __CFString **v11;
  int v12;
  BOOL v13;
  const __CFString **v14;
  const __CFString *v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;

  v5 = 136;
  if (*((_BYTE *)this + 202) == 1)
    v5 = 204;
  v6 = *(_DWORD *)((char *)this + v5);
  v7 = v6 & 0xFFFFFFFD;
  v8 = *((_DWORD *)this + 22);
  if (v8 <= 1278226487)
  {
    if (v8 <= 843264309)
    {
      if (v8 != 843264056)
      {
        if (v8 == 843264104)
        {
          v9 = v7 == 1 || v6 == 5;
          v10 = 5;
          v11 = (const __CFString **)MEMORY[0x1E0C9D930];
          goto LABEL_46;
        }
        goto LABEL_52;
      }
      v13 = v7 == 1 || v6 == 5;
      *((_DWORD *)this + 54) = 1;
      v14 = (const __CFString **)MEMORY[0x1E0C9D978];
LABEL_38:
      v15 = *v14;
      if (!v13)
        v6 = 1;
      *((_DWORD *)this + 41) = v6;
      goto LABEL_50;
    }
    if (v8 == 843264310)
    {
      v9 = v7 == 1 || v6 == 5;
      v10 = 2;
      v11 = (const __CFString **)MEMORY[0x1E0C9D978];
      goto LABEL_46;
    }
    v12 = 1111970369;
LABEL_23:
    if (v8 != v12)
      goto LABEL_52;
    v13 = v7 == 1 || v6 == 5;
    *((_DWORD *)this + 54) = 1;
    v14 = (const __CFString **)MEMORY[0x1E0C9DA10];
    goto LABEL_38;
  }
  if (v8 <= 1380411456)
  {
    if (v8 == 1278226488)
    {
      *((_DWORD *)this + 54) = 1;
      v15 = (const __CFString *)*MEMORY[0x1E0C9D978];
      *((_DWORD *)this + 41) = 0;
LABEL_50:
      *((_BYTE *)this + 142) = 1;
      goto LABEL_51;
    }
    v12 = 1380401729;
    goto LABEL_23;
  }
  if (v8 == 1815491698)
  {
    v9 = v7 == 1 || v6 == 5;
    v10 = 2;
    goto LABEL_32;
  }
  if (v8 != 1815162994)
  {
    if (v8 == 1380411457)
    {
      v9 = v7 == 1 || v6 == 5;
      v10 = 5;
LABEL_32:
      v11 = (const __CFString **)MEMORY[0x1E0C9DA10];
LABEL_46:
      *((_DWORD *)this + 54) = v10;
      v15 = *v11;
      if (v9)
        v16 = v6;
      else
        v16 = 1;
      *((_DWORD *)this + 41) = v16;
      goto LABEL_50;
    }
LABEL_52:
    v17 = v8 >> 24;
    v18 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v19 = __maskrune(v17, 0x40000uLL);
      v8 = *((_DWORD *)this + 22);
    }
    else
    {
      v19 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v17 + 60) & 0x40000;
    }
    if (v19)
      v20 = (v8 >> 24);
    else
      v20 = 46;
    v21 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v22 = __maskrune(v21, 0x40000uLL);
      v8 = *((_DWORD *)this + 22);
    }
    else
    {
      v22 = *(_DWORD *)(v18 + 4 * v21 + 60) & 0x40000;
    }
    if (v22)
      v23 = (v8 << 8 >> 24);
    else
      v23 = 46;
    v24 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v25 = __maskrune(v24, 0x40000uLL);
      v8 = *((_DWORD *)this + 22);
    }
    else
    {
      v25 = *(_DWORD *)(v18 + 4 * v24 + 60) & 0x40000;
    }
    if (v25)
      v26 = ((__int16)v8 >> 8);
    else
      v26 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v18 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_72;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_72:
      v27 = *((char *)this + 88);
LABEL_75:
      LogError("completeSetup", 731, "*** pixelformat '%c%c%c%c' not handled\n", v20, v23, v26, v27);
      v15 = 0;
      goto LABEL_51;
    }
    v27 = 46;
    goto LABEL_75;
  }
  *((_DWORD *)this + 54) = 6;
  v15 = (const __CFString *)*MEMORY[0x1E0C9D960];
  *((_DWORD *)this + 41) = 6;
LABEL_51:
  IIOIOSurfaceWrapperBase::completeSetup(this, a2, v15);
}

uint64_t IIOIOSurfaceWrapper::createImage(IIOIOSurfaceWrapper *this)
{
  int v2;
  BOOL v3;
  int v4;
  uint64_t ImageWithImageProvider;
  const __CFNumber *v7;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE v20[24];

  v2 = *((_DWORD *)this + 22);
  if (v2 <= 1278226487)
  {
    if (v2 > 843264309)
    {
      v3 = v2 == 843264310;
      v4 = 1111970369;
    }
    else
    {
      v3 = v2 == 843264056;
      v4 = 843264104;
    }
  }
  else if (v2 <= 1380411456)
  {
    v3 = v2 == 1278226488;
    v4 = 1380401729;
  }
  else
  {
    v3 = v2 == 1380411457 || v2 == 1815491698;
    v4 = 1815162994;
  }
  if (v3 || v2 == v4)
  {
    ImageWithImageProvider = IIOIOSurfaceWrapper::createImageWithImageProvider(this);
    goto LABEL_17;
  }
  v9 = v2 >> 24;
  v10 = MEMORY[0x1E0C80978];
  if (v2 < 0)
  {
    v11 = __maskrune(v9, 0x40000uLL);
    v2 = *((_DWORD *)this + 22);
  }
  else
  {
    v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
  }
  if (v11)
    v12 = (v2 >> 24);
  else
    v12 = 46;
  v13 = v2 << 8 >> 24;
  if (v2 << 8 < 0)
  {
    v14 = __maskrune(v13, 0x40000uLL);
    v2 = *((_DWORD *)this + 22);
  }
  else
  {
    v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14)
    v15 = (v2 << 8 >> 24);
  else
    v15 = 46;
  v16 = (__int16)v2 >> 8;
  if (v2 << 16 < 0)
  {
    v17 = __maskrune(v16, 0x40000uLL);
    v2 = *((_DWORD *)this + 22);
  }
  else
  {
    v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17)
    v18 = ((__int16)v2 >> 8);
  else
    v18 = 46;
  if ((v2 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v2 + 60) & 0x40000) != 0)
      goto LABEL_40;
LABEL_42:
    v19 = 46;
    goto LABEL_43;
  }
  if (!__maskrune((char)v2, 0x40000uLL))
    goto LABEL_42;
LABEL_40:
  v19 = *((char *)this + 88);
LABEL_43:
  _cg_jpeg_mem_term("createImage", 761, "    CGImageCreateFromIOSurface -- unsupported pixelformat: '%c%c%c%c'\n", v12, v15, v18, v19);
  ImageWithImageProvider = 0;
LABEL_17:
  v7 = (const __CFNumber *)IOSurfaceCopyValue(*((IOSurfaceRef *)this + 9), CFSTR("IOSurfaceContentHeadroom"));
  if (v7)
  {
    IIONumber::IIONumber((IIONumber *)v20, v7);
    IIONumber::floatNum((IIONumber *)v20);
    IIONumber::~IIONumber((IIONumber *)v20);
    CGImageSetHeadroom();
  }
  return ImageWithImageProvider;
}

void sub_18804C59C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper::createImageWithImageProvider(IIOIOSurfaceWrapper *this)
{
  void *v2;
  int v3;
  CGColorSpace *v4;
  CGColorSpaceRef v5;
  CGColorSpace *v6;
  uint64_t v7;
  _QWORD v9[2];
  void *value;
  _QWORD v11[7];

  v2 = IIOIOSurfaceWrapper::CopyImageBlockSetWithOptions;
  if (*((_BYTE *)this + 140))
    v2 = IIOIOSurfaceWrapperBase::CopyImageBlockSetWithOptionsNoOp;
  v11[4] = v2;
  v11[3] = 2;
  v11[5] = IIOIOSurfaceWrapperBase::CopyIOSurface;
  v11[6] = IIOIOSurfaceWrapperBase::ReleaseInfo;
  memset(v11, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v11);
  if (*((_DWORD *)this + 54) == 6)
  {
    IIONumber::IIONumber((IIONumber *)v9, 204806);
    IIODictionary::setObjectForKey((IIODictionary *)v11, value, (const __CFString *)*MEMORY[0x1E0C9DAF8]);
    IIONumber::~IIONumber((IIONumber *)v9);
  }
  else
  {
    v3 = *((_DWORD *)this + 41) - 1;
    if (v3 < 6)
      IIODictionary::setObjectForKey((IIODictionary *)v11, (const void *)*MEMORY[0x1E0C9AE50], **((const __CFString ***)&unk_1E1BCA420 + v3));
  }
  v4 = (CGColorSpace *)*((_QWORD *)this + 10);
  v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  v6 = v5;
  if (!v4)
    v4 = v5;
  if (CGImageProviderCreate())
  {
    CGImageProviderSetProperty();
    v9[0] = 0;
    v9[1] = 0;
    value = 0;
    IIONumber::IIONumber((IIONumber *)v9, *((_DWORD *)this + 22));
    CGImageProviderSetProperty();
    v7 = CGImageCreateWithImageProvider();
    CGImageProviderRelease();
    if (!*((_QWORD *)this + 10))
      IIO_IOSurfaceAddColorSpace(*((__IOSurface **)this + 9), v4);
    IIONumber::~IIONumber((IIONumber *)v9);
  }
  else
  {
    v7 = 0;
  }
  CGColorSpaceRelease(v6);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  return v7;
}

void sub_18804C794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper::CopyImageBlockSetWithOptions(uint64_t a1, uint64_t a2, __CFDictionary *a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, double a8, double a9)
{
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  _QWORD v37[4];

  memset(v37, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v37, a3);
  v18 = *(int *)(a1 + 216);
  IIOPackCopyCallbackInfo(a3);
  CGImageProviderGetBitmapInfo();
  kdebug_trace();
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    v20 = *(_DWORD *)(a1 + 88);
    v21 = v20 >> 24;
    v22 = MEMORY[0x1E0C80978];
    if (v20 < 0)
      v23 = __maskrune(v20 >> 24, 0x40000uLL);
    else
      v23 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v21 + 60) & 0x40000;
    if (v23)
      v24 = v21;
    else
      v24 = 46;
    v25 = v20 << 8 >> 24;
    if (v20 << 8 < 0)
      v26 = __maskrune(v20 << 8 >> 24, 0x40000uLL);
    else
      v26 = *(_DWORD *)(v22 + 4 * v25 + 60) & 0x40000;
    if (v26)
      v27 = v25;
    else
      v27 = 46;
    v28 = (__int16)v20 >> 8;
    if (v20 << 16 < 0)
      v29 = __maskrune((__int16)v20 >> 8, 0x40000uLL);
    else
      v29 = *(_DWORD *)(v22 + 4 * v28 + 60) & 0x40000;
    if ((v20 << 24) <= 0x7F000000)
      v30 = *(_DWORD *)(v22 + 4 * (char)v20 + 60) & 0x40000;
    else
      v30 = __maskrune((char)v20, 0x40000uLL);
    if (v29)
      v31 = v28;
    else
      v31 = 46;
    if (v30)
      v32 = (char)v20;
    else
      v32 = 46;
    ImageIOLog("S   CopyImageBlockSetWithOptions-SURF: {%g, %g, %g, %g} {%g, %g} '%c%c%c%c' %s\n", a4, a5, a6, a7, a8, a9, v24, v27, v31, v32, off_1E1BCA3A8[v18]);
  }
  v36 = 0;
  if (!*(_BYTE *)(a1 + 141))
  {
    switch((int)v18)
    {
      case 1:
        v33 = IIOIOSurfaceWrapper::copyImageBlockSetWithOptions8Bit(a1, a2, (IIODictionary *)v37, &v36, a4, a5, a6, a7, a8, a9);
        goto LABEL_29;
      case 2:
      case 5:
        v33 = IIOIOSurfaceWrapper::copyImageBlockSetWithOptions16Bit(a1, a2, (uint64_t)v37, &v36, a4, a5, a6, a7, a8, a9);
        goto LABEL_29;
      case 6:
        v33 = IIOIOSurfaceWrapper::copyImageBlockSetWithOptions10Bit(a1, a4, a5, a6, a7, a8, a9, a2, (uint64_t)v37, &v36);
        goto LABEL_29;
      default:
        LogError("CopyImageBlockSetWithOptions", 1684, "*** unsupported componentType '%s' (%d)\n", (&gComponentString)[v18], v18);
        goto LABEL_35;
    }
  }
  v33 = IIOIOSurfaceWrapperBase::createBlockSetForCompressedSurface(a1, a4, a5, a6, a7, a2, v19, &v36);
LABEL_29:
  v34 = v33;
  if (v33)
  {
    CGImageBlockSetGetRect();
  }
  else
  {
LABEL_35:
    _cg_jpeg_mem_term("CopyImageBlockSetWithOptions", 1694, "*** ERROR: CopyImageBlockSetWithOptions returned NULL\n");
    v34 = 0;
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v37);
  return v34;
}

void sub_18804CB4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSetNoCopy(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  kern_return_t v8;
  uint64_t result;
  CGRect v10;
  CGRect v11;

  v11.size.height = a5;
  v11.size.width = a4;
  v10.size.width = (double)*(unint64_t *)(a1 + 96);
  v10.size.height = (double)*(unint64_t *)(a1 + 104);
  v10.origin.x = 0.0;
  v10.origin.y = 0.0;
  v11.origin.x = a2;
  v11.origin.y = a3;
  CGRectIntersection(v10, v11);
  v8 = IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  result = 0;
  if (!v8)
  {
    IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
    CGImageBlockCreate();
    return CGImageBlockSetCreate();
  }
  return result;
}

vImage_Error IIOIOSurfaceWrapper::copy_BGRA_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  int *v7;
  vImage_Error v8;
  CFAbsoluteTime v9;
  int v11;
  int v12;

  Current = CFAbsoluteTimeGetCurrent();
  v12 = 50331906;
  v11 = 50462976;
  if (*((_BYTE *)this + 200))
    v7 = &v11;
  else
    v7 = &v12;
  v8 = vImagePermuteChannels_ARGB8888(a2, a3, (const uint8_t *)v7, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v9 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_BGRA_8bit", (v9 - Current) * 1000.0);
  }
  return v8;
}

vImage_Error IIOIOSurfaceWrapper::copy_RGBA_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  int *v7;
  vImage_Error v8;
  CFAbsoluteTime v9;
  int v11;
  int v12;

  Current = CFAbsoluteTimeGetCurrent();
  v12 = 50331906;
  v11 = 50462976;
  if (*((_BYTE *)this + 200))
    v7 = &v12;
  else
    v7 = &v11;
  v8 = vImagePermuteChannels_ARGB8888(a2, a3, (const uint8_t *)v7, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v9 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGBA_8bit", (v9 - Current) * 1000.0);
  }
  return v8;
}

uint64_t IIOIOSurfaceWrapper::copy_L008_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  size_t rowBytes;
  char *data;
  char *v8;
  unsigned int v9;
  CFAbsoluteTime v11;

  Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes)
    rowBytes = a3->rowBytes;
  else
    rowBytes = a2->rowBytes;
  if (a3->height)
  {
    data = (char *)a3->data;
    v8 = (char *)a2->data;
    v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_L008_8bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

uint64_t IIOIOSurfaceWrapper::copy_LA08_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  size_t rowBytes;
  char *data;
  char *v8;
  unsigned int v9;
  CFAbsoluteTime v11;

  Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes)
    rowBytes = a3->rowBytes;
  else
    rowBytes = a2->rowBytes;
  if (a3->height)
  {
    data = (char *)a3->data;
    v8 = (char *)a2->data;
    v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_LA08_8bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

vImage_Error IIOIOSurfaceWrapper::copy_l64r_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  vImage_Error v6;
  CFAbsoluteTime v7;
  uint8_t backgroundColor[4];
  uint8_t permuteMap[4];

  Current = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)backgroundColor = 0;
  *(_DWORD *)permuteMap = 50462976;
  v6 = vImageConvert_ARGB16UToARGB8888(a2, a3, permuteMap, 0, backgroundColor, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_l64r_8bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_RGhA_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  vImage_Error v6;
  CFAbsoluteTime v7;

  Current = CFAbsoluteTimeGetCurrent();
  v6 = vImageConvert_Planar16FtoPlanar8(a2, a3, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGhA_8bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_2C16_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  vImage_Error v6;
  CFAbsoluteTime v7;

  Current = CFAbsoluteTimeGetCurrent();
  v6 = vImageConvert_Planar16UtoPlanar8_dithered(a2, a3, 0, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_2C16_8bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_2C0h_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  vImage_Error v6;
  CFAbsoluteTime v7;

  Current = CFAbsoluteTimeGetCurrent();
  v6 = vImageConvert_Planar16FtoPlanar8(a2, a3, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_2C0h_8bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSet_8bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  IIOIOSurfaceWrapper *BaseAddress;
  size_t v11;
  size_t v12;
  int v13;
  int v14;
  const char *v15;
  int v16;
  uint64_t result;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  vImage_Buffer dest;
  vImage_Buffer v31;
  __int128 v32;
  __int128 v33;

  v33 = xmmword_1E1BCA388;
  v32 = xmmword_1E1BCA398;
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
    goto LABEL_32;
  BaseAddress = (IIOIOSurfaceWrapper *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  if (!BaseAddress)
  {
    if (*(_BYTE *)(a1 + 140))
      v15 = "YES";
    else
      v15 = "NO";
    _cg_jpeg_mem_term("copyImageBlockSet_8bit", 1034, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n", v15);
    goto LABEL_12;
  }
  v11 = *(_QWORD *)(a1 + 112);
  v31.data = (char *)BaseAddress
           + (unint64_t)(a2 * (double)*(unint64_t *)(a1 + 120))
           + (unint64_t)(a3 * (double)v11);
  v31.height = (unint64_t)a5;
  v31.width = (unint64_t)a4;
  v31.rowBytes = v11;
  dest.data = *(void **)(a1 + 168);
  dest.height = (unint64_t)a5;
  v12 = *(unsigned int *)(a1 + 184);
  dest.width = (unint64_t)a4;
  dest.rowBytes = v12;
  v13 = *(_DWORD *)(a1 + 88);
  if (v13 > 1278226487)
  {
    if (v13 <= 1380411456)
    {
      if (v13 != 1278226488)
      {
        if (v13 == 1380401729)
        {
          v14 = IIOIOSurfaceWrapper::copy_RGBA_8bit((IIOIOSurfaceWrapper *)a1, &v31, &dest);
          goto LABEL_30;
        }
        goto LABEL_34;
      }
      IIOIOSurfaceWrapper::copy_L008_8bit(BaseAddress, &v31, &dest);
      goto LABEL_27;
    }
    if (v13 == 1380411457)
    {
      v14 = IIOIOSurfaceWrapper::copy_RGhA_8bit(BaseAddress, &v31, &dest);
      goto LABEL_30;
    }
    if (v13 == 1815491698)
    {
      v14 = IIOIOSurfaceWrapper::copy_l64r_8bit(BaseAddress, &v31, &dest);
      goto LABEL_30;
    }
LABEL_34:
    v18 = v13 >> 24;
    v19 = MEMORY[0x1E0C80978];
    if (v13 < 0)
    {
      v20 = __maskrune(v18, 0x40000uLL);
      v13 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v20 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v18 + 60) & 0x40000;
    }
    if (v20)
      v21 = (v13 >> 24);
    else
      v21 = 46;
    v22 = v13 << 8 >> 24;
    if (v13 << 8 < 0)
    {
      v23 = __maskrune(v22, 0x40000uLL);
      v13 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v23 = *(_DWORD *)(v19 + 4 * v22 + 60) & 0x40000;
    }
    if (v23)
      v24 = (v13 << 8 >> 24);
    else
      v24 = 46;
    v25 = (__int16)v13 >> 8;
    if (v13 << 16 < 0)
    {
      v26 = __maskrune(v25, 0x40000uLL);
      v13 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v26 = *(_DWORD *)(v19 + 4 * v25 + 60) & 0x40000;
    }
    if (v26)
      v27 = ((__int16)v13 >> 8);
    else
      v27 = 46;
    if ((v13 << 24) <= 0x7F000000)
      v28 = *(_DWORD *)(v19 + 4 * (char)v13 + 60) & 0x40000;
    else
      v28 = __maskrune((char)v13, 0x40000uLL);
    if (v28)
      v29 = *(char *)(a1 + 88);
    else
      v29 = 46;
    LogError("copyImageBlockSet_8bit", 1081, "*** pixelFormat '%c%c%c%c' not supported\n", v21, v24, v27, v29);
LABEL_12:
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
LABEL_32:
    _ImageIO_Free(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176));
    result = 0;
    *(_QWORD *)(a1 + 168) = 0;
    return result;
  }
  if (v13 <= 843264309)
  {
    if (v13 != 843264056)
    {
      if (v13 == 843264104)
      {
        v14 = IIOIOSurfaceWrapper::copy_2C0h_8bit(BaseAddress, &v31, &dest);
LABEL_30:
        v16 = v14;
        goto LABEL_31;
      }
      goto LABEL_34;
    }
    IIOIOSurfaceWrapper::copy_LA08_8bit(BaseAddress, &v31, &dest);
LABEL_27:
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    goto LABEL_33;
  }
  if (v13 == 843264310)
  {
    v14 = IIOIOSurfaceWrapper::copy_2C16_8bit(BaseAddress, &v31, &dest);
    goto LABEL_30;
  }
  if (v13 != 1111970369)
    goto LABEL_34;
  v16 = IIOIOSurfaceWrapper::copy_BGRA_8bit((IIOIOSurfaceWrapper *)a1, &v31, &dest);
  if (*(_BYTE *)(a1 + 200) && *(_DWORD *)(a1 + 136) == 3)
    v16 = vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
LABEL_31:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  if (v16)
    goto LABEL_32;
LABEL_33:
  v31.data = (void *)CGImageBlockCreate();
  return CGImageBlockSetCreate();
}

uint64_t IIOIOSurfaceWrapper::copy_RGBA_10bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  size_t rowBytes;
  char *data;
  char *v8;
  unsigned int v9;
  CFAbsoluteTime v11;

  Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes)
    rowBytes = a3->rowBytes;
  else
    rowBytes = a2->rowBytes;
  if (a3->height)
  {
    data = (char *)a3->data;
    v8 = (char *)a2->data;
    v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGBA_10bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSet_10bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  IIOIOSurfaceWrapper *BaseAddress;
  size_t v11;
  size_t v12;
  int v13;
  uint64_t result;
  const char *v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  vImage_Buffer v38;
  vImage_Buffer v39;
  __int128 v40;
  __int128 v41;

  v41 = xmmword_1E1BCA388;
  v40 = xmmword_1E1BCA398;
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
    goto LABEL_34;
  BaseAddress = (IIOIOSurfaceWrapper *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  if (!BaseAddress)
  {
    if (*(_BYTE *)(a1 + 140))
      v15 = "YES";
    else
      v15 = "NO";
    _cg_jpeg_mem_term("copyImageBlockSet_10bit", 1149, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n", v15);
    goto LABEL_33;
  }
  v11 = *(_QWORD *)(a1 + 112);
  v39.data = (char *)BaseAddress
           + (unint64_t)(a2 * (double)*(unint64_t *)(a1 + 120))
           + (unint64_t)(a3 * (double)v11);
  v39.height = (unint64_t)a5;
  v39.width = (unint64_t)a4;
  v39.rowBytes = v11;
  v38.data = *(void **)(a1 + 168);
  v38.height = (unint64_t)a5;
  v12 = *(unsigned int *)(a1 + 184);
  v38.width = (unint64_t)a4;
  v38.rowBytes = v12;
  v13 = *(_DWORD *)(a1 + 88);
  if (v13 == 1815162994)
  {
    IIOIOSurfaceWrapper::copy_RGBA_10bit(BaseAddress, &v39, &v38);
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    v39.data = (void *)CGImageBlockCreate();
    return CGImageBlockSetCreate();
  }
  v16 = v13 >> 24;
  if (v13 < 0)
  {
    v17 = __maskrune(v16, 0x40000uLL);
    v13 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v17 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v16 + 60) & 0x40000;
  }
  if (v17)
    v18 = (v13 >> 24);
  else
    v18 = 46;
  v19 = v13 << 8 >> 24;
  if (v13 << 8 < 0)
  {
    v20 = __maskrune(v19, 0x40000uLL);
    v13 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v20 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v19 + 60) & 0x40000;
  }
  if (v20)
    v21 = (v13 << 8 >> 24);
  else
    v21 = 46;
  v22 = (__int16)v13 >> 8;
  if (v13 << 16 < 0)
  {
    v23 = __maskrune(v22, 0x40000uLL);
    v13 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v23 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v22 + 60) & 0x40000;
  }
  if (v23)
    v24 = ((__int16)v13 >> 8);
  else
    v24 = 46;
  if ((v13 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v13 + 60) & 0x40000) != 0)
      goto LABEL_29;
LABEL_31:
    v25 = 46;
    goto LABEL_32;
  }
  if (!__maskrune((char)v13, 0x40000uLL))
    goto LABEL_31;
LABEL_29:
  v25 = *(char *)(a1 + 88);
LABEL_32:
  LogError("copyImageBlockSet_10bit", 1164, "*** pixelFormat '%c%c%c%c' not supported\n", v18, v21, v24, v25);
LABEL_33:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
LABEL_34:
  kdebug_trace();
  v26 = *(_DWORD *)(a1 + 88);
  v27 = v26 >> 24;
  v28 = MEMORY[0x1E0C80978];
  if (v26 < 0)
  {
    v29 = __maskrune(v27, 0x40000uLL);
    v26 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v29 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v27 + 60) & 0x40000;
  }
  if (v29)
    v30 = (v26 >> 24);
  else
    v30 = 46;
  v31 = v26 << 8 >> 24;
  if (v26 << 8 < 0)
  {
    v32 = __maskrune(v31, 0x40000uLL);
    v26 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v32 = *(_DWORD *)(v28 + 4 * v31 + 60) & 0x40000;
  }
  if (v32)
    v33 = (v26 << 8 >> 24);
  else
    v33 = 46;
  v34 = (__int16)v26 >> 8;
  if (v26 << 16 < 0)
  {
    v35 = __maskrune(v34, 0x40000uLL);
    v26 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v35 = *(_DWORD *)(v28 + 4 * v34 + 60) & 0x40000;
  }
  if (v35)
    v36 = ((__int16)v26 >> 8);
  else
    v36 = 46;
  if ((v26 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v28 + 4 * (char)v26 + 60) & 0x40000) != 0)
      goto LABEL_54;
LABEL_56:
    v37 = 46;
    goto LABEL_57;
  }
  if (!__maskrune((char)v26, 0x40000uLL))
    goto LABEL_56;
LABEL_54:
  v37 = *(char *)(a1 + 88);
LABEL_57:
  LogError("copyImageBlockSet_10bit", 1183, "*** copyImageBlockSet_10bit '%c%c%c%c' failed: err=%d\n", v30, v33, v36, v37, -50);
  _ImageIO_Free(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176));
  result = 0;
  *(_QWORD *)(a1 + 168) = 0;
  return result;
}

vImage_Error IIOIOSurfaceWrapper::copy_RGBA_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  vImage_Error v6;
  CFAbsoluteTime v7;
  uint16_t backgroundColor[2];
  __int16 v10;
  uint8_t permuteMap[4];

  Current = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)permuteMap = 50462976;
  v10 = 0;
  *(_DWORD *)backgroundColor = 0;
  v6 = vImageConvert_ARGB8888ToARGB16U(a2, a3, permuteMap, 0, backgroundColor, 0x10u);
  if ((_DWORD)v6)
    _cg_jpeg_mem_term("copy_RGBA_16bit", 1206, "*** ERROR: iio_vImageConvert_ARGB8888ToARGB16U returned: %d\n", v6);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGBA_16bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_BGRA_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  vImage_Error v6;
  CFAbsoluteTime v7;
  uint16_t backgroundColor[2];
  __int16 v10;
  uint8_t permuteMap[4];

  Current = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)permuteMap = 50331906;
  v10 = 0;
  *(_DWORD *)backgroundColor = 0;
  v6 = vImageConvert_ARGB8888ToARGB16U(a2, a3, permuteMap, 0, backgroundColor, 0x10u);
  if ((_DWORD)v6)
    _cg_jpeg_mem_term("copy_BGRA_16bit", 1225, "*** ERROR: iio_vImageConvert_ARGB8888ToARGB16U returned: %d\n", v6);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_BGRA_16bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_L008_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  vImage_Error v6;
  CFAbsoluteTime v7;

  Current = CFAbsoluteTimeGetCurrent();
  v6 = vImageConvert_Planar8To16U(a2, a3, 0x10u);
  if ((_DWORD)v6)
    _cg_jpeg_mem_term("copy_L008_16bit", 1241, "*** ERROR: iio_vImageConvert_Planar8To16U returned: %d\n", v6);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_L008_16bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_LA08_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  vImage_Error v6;
  CFAbsoluteTime v7;

  Current = CFAbsoluteTimeGetCurrent();
  v6 = vImageConvert_Planar8To16U(a2, a3, 0x10u);
  if ((_DWORD)v6)
    _cg_jpeg_mem_term("copy_LA08_16bit", 1255, "*** ERROR: iio_vImageConvert_Planar8To16U returned: %d\n", v6);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_LA08_16bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

uint64_t IIOIOSurfaceWrapper::copy_l64r_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  size_t rowBytes;
  char *data;
  char *v8;
  unsigned int v9;
  CFAbsoluteTime v11;

  Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes)
    rowBytes = a3->rowBytes;
  else
    rowBytes = a2->rowBytes;
  if (a3->height)
  {
    data = (char *)a3->data;
    v8 = (char *)a2->data;
    v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_l64r_16bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

vImage_Error IIOIOSurfaceWrapper::copy_RGhA_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  size_t rowBytes;
  char *data;
  char *v9;
  unsigned int v10;
  vImage_Error v12;
  CFAbsoluteTime v13;

  Current = CFAbsoluteTimeGetCurrent();
  if (*((_DWORD *)this + 54) == 5)
  {
    if (a2->rowBytes >= a3->rowBytes)
      rowBytes = a3->rowBytes;
    else
      rowBytes = a2->rowBytes;
    if (a3->height)
    {
      data = (char *)a3->data;
      v9 = (char *)a2->data;
      v10 = 1;
      do
      {
        memcpy(data, v9, rowBytes);
        v9 += a2->rowBytes;
        data += a3->rowBytes;
      }
      while (a3->height > v10++);
    }
    v12 = 0;
  }
  else
  {
    v12 = vImageConvert_16Fto16U(a2, a3, 0x10u);
    if ((_DWORD)v12)
      _cg_jpeg_mem_term("copy_RGhA_16bit", 1307, "*** ERROR: iio_vImageConvert_16Fto16U returned: %d\n", v12);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v13 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGhA_16bit", (v13 - Current) * 1000.0);
  }
  return v12;
}

uint64_t IIOIOSurfaceWrapper::copy_2C16_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  size_t rowBytes;
  char *data;
  char *v8;
  unsigned int v9;
  CFAbsoluteTime v11;

  Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes)
    rowBytes = a3->rowBytes;
  else
    rowBytes = a2->rowBytes;
  if (a3->height)
  {
    data = (char *)a3->data;
    v8 = (char *)a2->data;
    v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_2C16_16bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

vImage_Error IIOIOSurfaceWrapper::copy_2C0h_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current;
  size_t rowBytes;
  char *data;
  char *v9;
  unsigned int v10;
  vImage_Error v12;
  CFAbsoluteTime v13;

  Current = CFAbsoluteTimeGetCurrent();
  if (*((_DWORD *)this + 54) == 5)
  {
    if (a2->rowBytes >= a3->rowBytes)
      rowBytes = a3->rowBytes;
    else
      rowBytes = a2->rowBytes;
    if (a3->height)
    {
      data = (char *)a3->data;
      v9 = (char *)a2->data;
      v10 = 1;
      do
      {
        memcpy(data, v9, rowBytes);
        v9 += a2->rowBytes;
        data += a3->rowBytes;
      }
      while (a3->height > v10++);
    }
    v12 = 0;
  }
  else
  {
    v12 = vImageConvert_16Fto16U(a2, a3, 0x10u);
    if ((_DWORD)v12)
      _cg_jpeg_mem_term("copy_2C0h_16bit", 1359, "*** ERROR: iio_vImageConvert_16Fto16U returned: %d\n", v12);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v13 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_2C0h_16bit", (v13 - Current) * 1000.0);
  }
  return v12;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSet_16bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  IIOIOSurfaceWrapper *BaseAddress;
  size_t v16;
  size_t v17;
  int v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  const char *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  vImage_Buffer v46;
  vImage_Buffer v47;
  __int128 v48;
  __int128 v49;

  v49 = xmmword_1E1BCA388;
  v48 = xmmword_1E1BCA398;
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
  {
LABEL_2:
    v10 = -50;
    goto LABEL_3;
  }
  BaseAddress = (IIOIOSurfaceWrapper *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  if (!BaseAddress)
  {
    if (*(_BYTE *)(a1 + 140))
      v29 = "YES";
    else
      v29 = "NO";
    _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1388, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n", v29);
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    goto LABEL_2;
  }
  v16 = *(_QWORD *)(a1 + 112);
  v47.data = (char *)BaseAddress
           + (unint64_t)(a2 * (double)*(unint64_t *)(a1 + 120))
           + (unint64_t)(a3 * (double)v16);
  v47.height = (unint64_t)a5;
  v47.width = (unint64_t)a4;
  v47.rowBytes = v16;
  v46.data = *(void **)(a1 + 168);
  v46.height = (unint64_t)a5;
  v17 = *(unsigned int *)(a1 + 184);
  v46.width = (unint64_t)a4;
  v46.rowBytes = v17;
  v18 = *(_DWORD *)(a1 + 88);
  if (v18 <= 1278226487)
  {
    if (v18 > 843264309)
    {
      if (v18 == 843264310)
      {
        IIOIOSurfaceWrapper::copy_2C16_16bit(BaseAddress, &v47, &v46);
        goto LABEL_57;
      }
      if (v18 == 1111970369)
      {
        v31 = IIOIOSurfaceWrapper::copy_BGRA_16bit(BaseAddress, &v47, &v46);
        if (v31)
        {
          v10 = v31;
          _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1407, "*** ERROR: copy_BGRA_16bit returned: %d\n");
          goto LABEL_83;
        }
        goto LABEL_57;
      }
    }
    else
    {
      if (v18 == 843264056)
      {
        v32 = IIOIOSurfaceWrapper::copy_LA08_16bit(BaseAddress, &v47, &v46);
        if (v32)
        {
          v10 = v32;
          _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1431, "*** ERROR: copy_LA08_16bit returned: %d\n");
          goto LABEL_83;
        }
        goto LABEL_57;
      }
      if (v18 == 843264104)
      {
        v19 = IIOIOSurfaceWrapper::copy_2C0h_16bit((IIOIOSurfaceWrapper *)a1, &v47, &v46);
        if (v19)
        {
          v10 = v19;
          _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1443, "*** ERROR: copy_2C0h_16bit returned: %d\n");
LABEL_83:
          IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
LABEL_3:
          kdebug_trace();
          v11 = *(_DWORD *)(a1 + 88);
          v12 = v11 >> 24;
          v13 = MEMORY[0x1E0C80978];
          if (v11 < 0)
          {
            v14 = __maskrune(v12, 0x40000uLL);
            v11 = *(_DWORD *)(a1 + 88);
          }
          else
          {
            v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
          }
          if (v14)
            v20 = (v11 >> 24);
          else
            v20 = 46;
          v21 = v11 << 8 >> 24;
          if (v11 << 8 < 0)
          {
            v22 = __maskrune(v21, 0x40000uLL);
            v11 = *(_DWORD *)(a1 + 88);
          }
          else
          {
            v22 = *(_DWORD *)(v13 + 4 * v21 + 60) & 0x40000;
          }
          if (v22)
            v23 = (v11 << 8 >> 24);
          else
            v23 = 46;
          v24 = (__int16)v11 >> 8;
          if (v11 << 16 < 0)
          {
            v25 = __maskrune(v24, 0x40000uLL);
            v11 = *(_DWORD *)(a1 + 88);
          }
          else
          {
            v25 = *(_DWORD *)(v13 + 4 * v24 + 60) & 0x40000;
          }
          if (v25)
            v26 = ((__int16)v11 >> 8);
          else
            v26 = 46;
          if ((v11 << 24) <= 0x7F000000)
          {
            if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0)
              goto LABEL_30;
          }
          else if (__maskrune((char)v11, 0x40000uLL))
          {
LABEL_30:
            v27 = *(char *)(a1 + 88);
LABEL_33:
            LogError("copyImageBlockSet_16bit", 1468, "*** copyImageBlockSet_16bit '%c%c%c%c' failed: err=%d\n", v20, v23, v26, v27, v10);
            _ImageIO_Free(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176));
            result = 0;
            *(_QWORD *)(a1 + 168) = 0;
            return result;
          }
          v27 = 46;
          goto LABEL_33;
        }
        goto LABEL_57;
      }
    }
    goto LABEL_58;
  }
  if (v18 > 1380411456)
  {
    if (v18 == 1380411457)
    {
      v34 = IIOIOSurfaceWrapper::copy_RGhA_16bit((IIOIOSurfaceWrapper *)a1, &v47, &v46);
      if (v34)
      {
        v10 = v34;
        _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1413, "*** ERROR: copy_RGhA_16bit returned: %d\n");
        goto LABEL_83;
      }
      goto LABEL_57;
    }
    if (v18 == 1815491698)
    {
      IIOIOSurfaceWrapper::copy_l64r_16bit(BaseAddress, &v47, &v46);
      goto LABEL_57;
    }
    goto LABEL_58;
  }
  if (v18 == 1278226488)
  {
    v33 = IIOIOSurfaceWrapper::copy_L008_16bit(BaseAddress, &v47, &v46);
    if (v33)
    {
      v10 = v33;
      _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1425, "*** ERROR: copy_L008_16bit returned: %d\n");
      goto LABEL_83;
    }
    goto LABEL_57;
  }
  if (v18 != 1380401729)
  {
LABEL_58:
    v35 = v18 >> 24;
    if (v18 < 0)
    {
      v36 = __maskrune(v35, 0x40000uLL);
      v18 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v36 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v35 + 60) & 0x40000;
    }
    if (v36)
      v37 = (v18 >> 24);
    else
      v37 = 46;
    v38 = v18 << 8 >> 24;
    if (v18 << 8 < 0)
    {
      v39 = __maskrune(v38, 0x40000uLL);
      v18 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v39 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v38 + 60) & 0x40000;
    }
    if (v39)
      v40 = (v18 << 8 >> 24);
    else
      v40 = 46;
    v41 = (__int16)v18 >> 8;
    if (v18 << 16 < 0)
    {
      v42 = __maskrune(v41, 0x40000uLL);
      v18 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v42 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v41 + 60) & 0x40000;
    }
    if (v42)
      v43 = ((__int16)v18 >> 8);
    else
      v43 = 46;
    if ((v18 << 24) <= 0x7F000000)
      v44 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v18 + 60) & 0x40000;
    else
      v44 = __maskrune((char)v18, 0x40000uLL);
    if (v44)
      v45 = *(char *)(a1 + 88);
    else
      v45 = 46;
    LogError("copyImageBlockSet_16bit", 1448, "*** pixelFormat '%c%c%c%c' not supported\n", v37, v40, v43, v45);
    v10 = -4;
    goto LABEL_83;
  }
  v30 = IIOIOSurfaceWrapper::copy_RGBA_16bit(BaseAddress, &v47, &v46);
  if (v30)
  {
    v10 = v30;
    _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1401, "*** ERROR: copy_RGBA_16bit returned: %d\n");
    goto LABEL_83;
  }
LABEL_57:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  v47.data = (void *)CGImageBlockCreate();
  return CGImageBlockSetCreate();
}

uint64_t IIOIOSurfaceWrapper::preCopyBlockSet(IIOIOSurfaceWrapper *this, int a2, CGRect a3, CGSize a4, IIODictionary *a5)
{
  double height;
  double width;
  int v9;
  char v11;
  unsigned int v12;

  height = a3.size.height;
  width = a3.size.width;
  IIOIOSurfaceWrapperBase::preCopyBlockSet(this, a2, a3, a4, a5);
  v9 = IIO_CGImageBlockSetBytesPerPixelForPixelFormat(*((_DWORD *)this + 22));
  v11 = a2 == 16 && *((_DWORD *)this + 22) == 1815162994;
  v12 = IIOAlignRowBytes((unint64_t)(width * (double)(v9 << v11)), 0);
  *((_DWORD *)this + 46) = v12;
  if (is_mul_ok((unint64_t)height, v12))
    *((_QWORD *)this + 21) = _ImageIO_Malloc((unint64_t)height * v12, 64, (size_t *)this + 22, (uint64_t)kImageMalloc_IOSurface_Data, 0, 0, 0);
  return 0;
}

uint64_t IIO_CGImageBlockSetBytesPerPixelForPixelFormat(int a1)
{
  uint64_t result;
  int v3;
  int v4;
  unsigned __int16 v5;

  result = 4;
  if (a1 <= 1650943795)
  {
    if (a1 <= 875836517)
    {
      if (a1 > 875704933)
      {
        if (a1 == 875704934)
          return result;
        v5 = 12918;
      }
      else
      {
        if (a1 == 875704422)
          return result;
        v5 = 12406;
      }
      v3 = v5 | 0x34320000;
    }
    else
    {
      if (a1 > 1278226735)
      {
        if (a1 == 1278226736 || a1 == 1278226742)
          return 2;
        v4 = 1279340600;
        goto LABEL_26;
      }
      if (a1 == 875836518)
        return result;
      v3 = 875836534;
    }
LABEL_30:
    if (a1 == v3)
      return result;
    return IIO_BytesPerPixelForPixelFormatPlane0(a1);
  }
  if (a1 > 2019963439)
  {
    if (a1 <= 2019963955)
    {
      if (a1 == 2019963440)
        return result;
      v3 = 2019963442;
    }
    else
    {
      if (a1 == 2019963956 || a1 == 2037741158)
        return result;
      v3 = 2037741171;
    }
    goto LABEL_30;
  }
  if (a1 <= 2016686639)
  {
    if (a1 == 1650943796)
      return 2;
    v4 = 1919379252;
LABEL_26:
    if (a1 != v4)
      return IIO_BytesPerPixelForPixelFormatPlane0(a1);
    return 2;
  }
  if (a1 != 2016686640 && a1 != 2016686642)
  {
    v3 = 2016687156;
    goto LABEL_30;
  }
  return result;
}

unint64_t IIOIOSurfaceWrapper::packDebugInfo(IIOIOSurfaceWrapper *this, CGRect a2, uint64_t a3)
{
  unint64_t result;

  result = IIOIOSurfaceWrapperBase::packDebugInfo(this, a2, a3);
  if (*((_BYTE *)this + 200))
    result |= 0x1000uLL;
  return result;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSetWithOptions8Bit(uint64_t a1, uint64_t a2, IIODictionary *a3, _QWORD *a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8, double a9, double a10)
{
  pthread_mutex_t *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *ObjectForKey;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v20 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (!*(_BYTE *)(a1 + 142))
    goto LABEL_13;
  *(_BYTE *)(a1 + 200) = 0;
  v21 = (const __CFString *)*MEMORY[0x1E0C9DAB0];
  if (IIODictionary::containsKey(a3, (const __CFString *)*MEMORY[0x1E0C9DAB0]))
  {
    v22 = (const __CFString *)*MEMORY[0x1E0C9DAA8];
    ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a3, v21);
    if (CFStringCompare(v22, ObjectForKey, 0) == kCFCompareEqualTo)
      *(_BYTE *)(a1 + 200) = 1;
  }
  v24 = *(_DWORD *)(a1 + 88);
  if (v24 == 1111970369)
  {
    if (!*(_BYTE *)(a1 + 200) || *(_DWORD *)(a1 + 136) != 1)
      goto LABEL_13;
  }
  else if (v24 == 1380401729 && *(_BYTE *)(a1 + 200))
  {
    goto LABEL_13;
  }
  v25 = IIOIOSurfaceWrapper::copyImageBlockSetNoCopy(a1, a5, a6, a7, a8);
  if (v25)
  {
    v26 = v25;
    v27 = 0;
    goto LABEL_16;
  }
LABEL_13:
  v27 = (*(uint64_t (**)(uint64_t, uint64_t, IIODictionary *, CGFloat, CGFloat, CGFloat, CGFloat, double, double))(*(_QWORD *)a1 + 40))(a1, 8, a3, a5, a6, a7, a8, a9, a10);
  v28 = *(_QWORD *)a1;
  if ((_DWORD)v27)
  {
    (*(void (**)(uint64_t))(v28 + 48))(a1);
    _cg_jpeg_mem_term("copyImageBlockSetWithOptions8Bit", 1571, "*** ERROR: copyImageBlockSetWithOptions8Bit err = %d\n", v27);
    v26 = 0;
  }
  else
  {
    v26 = (*(uint64_t (**)(uint64_t, uint64_t, IIODictionary *, CGFloat, CGFloat, CGFloat, CGFloat, double, double))(v28 + 24))(a1, a2, a3, a5, a6, a7, a8, a9, a10);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  }
LABEL_16:
  *a4 = (*(uint64_t (**)(uint64_t, uint64_t, CGFloat, CGFloat, CGFloat, CGFloat))(*(_QWORD *)a1 + 64))(a1, v27, a5, a6, a7, a8);
  pthread_mutex_unlock(v20);
  return v26;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSetWithOptions10Bit(uint64_t a1, double a2, double a3, double a4, double a5, double a6, double a7, uint64_t a8, uint64_t a9, _QWORD *a10)
{
  pthread_mutex_t *v19;
  uint64_t v20;
  uint64_t v21;

  v19 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(_QWORD *)a1 + 40))(a1, 10, a9, a2, a3, a4, a5, a6, a7);
  if ((_DWORD)v20)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    _cg_jpeg_mem_term("copyImageBlockSetWithOptions10Bit", 1594, "*** ERROR: copyImageBlockSetWithOptions10Bit err = %d\n", v20);
    v21 = 0;
  }
  else
  {
    v21 = IIOIOSurfaceWrapper::copyImageBlockSet_10bit(a1, a2, a3, a4, a5);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  }
  *a10 = (*(uint64_t (**)(uint64_t, uint64_t, double, double, double, double))(*(_QWORD *)a1 + 64))(a1, v20, a2, a3, a4, a5);
  pthread_mutex_unlock(v19);
  return v21;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSetWithOptions16Bit(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8, double a9, double a10)
{
  pthread_mutex_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v20 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (*(_BYTE *)(a1 + 142))
  {
    v21 = IIOIOSurfaceWrapper::copyImageBlockSetNoCopy(a1, a5, a6, a7, a8);
    v22 = 0;
  }
  else
  {
    v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, CGFloat, CGFloat, CGFloat, CGFloat, double, double))(*(_QWORD *)a1 + 40))(a1, 16, a3, a5, a6, a7, a8, a9, a10);
    v23 = *(_QWORD *)a1;
    if ((_DWORD)v22)
    {
      (*(void (**)(uint64_t))(v23 + 48))(a1);
      _cg_jpeg_mem_term("copyImageBlockSetWithOptions16Bit", 1625, "*** ERROR: copyImageBlockSetWithOptions16Bit err = %d\n", v22);
      v21 = 0;
    }
    else
    {
      v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, CGFloat, CGFloat, CGFloat, CGFloat, double, double))(v23 + 32))(a1, a2, a3, a5, a6, a7, a8, a9, a10);
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    }
  }
  *a4 = (*(uint64_t (**)(uint64_t, uint64_t, CGFloat, CGFloat, CGFloat, CGFloat))(*(_QWORD *)a1 + 64))(a1, v22, a5, a6, a7, a8);
  pthread_mutex_unlock(v20);
  return v21;
}

void IIOIOSurfaceWrapper_CIF10::IIOIOSurfaceWrapper_CIF10(IIOIOSurfaceWrapper_CIF10 *this, __IOSurface *a2, size_t a3, size_t a4, int a5, CGImageAlphaInfo a6, IIODictionary *a7)
{
  _QWORD *v9;
  void (**v10)(IIOIOSurfaceWrapper_CIF10 *__hidden);

  IIOIOSurfaceWrapperBase::IIOIOSurfaceWrapperBase(this, a2, a3, a4, a5, a6, a7);
  *v9 = &off_1E1B815D0;
  if (v9[16] < 2uLL)
  {
    *((_OWORD *)this + 14) = 0u;
    *((_OWORD *)this + 15) = 0u;
    v10 = &off_1E1B815D0;
  }
  else
  {
    *((_QWORD *)this + 28) = IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((_QWORD *)this + 29) = IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((_QWORD *)this + 30) = IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((_QWORD *)this + 31) = IOSurfaceGetBytesPerElementOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    v10 = *(void (***)(IIOIOSurfaceWrapper_CIF10 *__hidden))this;
  }
  ((void (*)(IIOIOSurfaceWrapper_CIF10 *, IIODictionary *, _QWORD))v10[7])(this, a7, 0);
}

void sub_18804F1E0(_Unwind_Exception *a1)
{
  IIOIOSurfaceWrapperBase *v1;

  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(v1);
  _Unwind_Resume(a1);
}

void IIOIOSurfaceWrapper_CIF10::~IIOIOSurfaceWrapper_CIF10(IIOIOSurfaceWrapper_CIF10 *this)
{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(this);
  JUMPOUT(0x18D761C30);
}

void IIOIOSurfaceWrapper_CIF10::completeSetup(IIOIOSurfaceWrapper_CIF10 *this, IIODictionary *a2, const __CFString *a3)
{
  int v5;
  const __CFString *v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  _BOOL4 BoolForKey;
  const char *v19;
  int v20;
  int v21;
  const char *v22;
  int v23;
  const char *v24;

  *((_QWORD *)this + 33) = 0;
  *((_DWORD *)this + 64) = CIF10MIN();
  *((_DWORD *)this + 65) = CIF10MAX();
  *((_BYTE *)this + 272) = 1;
  if (onceSkipCheck != -1)
    dispatch_once(&onceSkipCheck, &__block_literal_global_95);
  v5 = *((_DWORD *)this + 22);
  if (v5 == 1647534392)
  {
    *((_DWORD *)this + 54) = 1;
    *((_BYTE *)this + 264) = 1;
    v6 = (const __CFString *)*MEMORY[0x1E0C9D960];
    *((_DWORD *)this + 41) = 1;
    goto LABEL_31;
  }
  if (v5 == 1999843442)
  {
    *((_DWORD *)this + 54) = 1;
    *((_BYTE *)this + 264) = 1;
    v6 = (const __CFString *)*MEMORY[0x1E0C9D960];
    *((_DWORD *)this + 41) = 0;
    goto LABEL_31;
  }
  v7 = v5 >> 24;
  v8 = MEMORY[0x1E0C80978];
  if (v5 < 0)
  {
    v9 = __maskrune(v7, 0x40000uLL);
    v5 = *((_DWORD *)this + 22);
  }
  else
  {
    v9 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v7 + 60) & 0x40000;
  }
  if (v9)
    v10 = (v5 >> 24);
  else
    v10 = 46;
  v11 = v5 << 8 >> 24;
  if (v5 << 8 < 0)
  {
    v12 = __maskrune(v11, 0x40000uLL);
    v5 = *((_DWORD *)this + 22);
  }
  else
  {
    v12 = *(_DWORD *)(v8 + 4 * v11 + 60) & 0x40000;
  }
  if (v12)
    v13 = (v5 << 8 >> 24);
  else
    v13 = 46;
  v14 = (__int16)v5 >> 8;
  if (v5 << 16 < 0)
  {
    v15 = __maskrune(v14, 0x40000uLL);
    v5 = *((_DWORD *)this + 22);
  }
  else
  {
    v15 = *(_DWORD *)(v8 + 4 * v14 + 60) & 0x40000;
  }
  if (v15)
    v16 = ((__int16)v5 >> 8);
  else
    v16 = 46;
  if ((v5 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v8 + 4 * (char)v5 + 60) & 0x40000) != 0)
      goto LABEL_27;
LABEL_29:
    v17 = 46;
    goto LABEL_30;
  }
  if (!__maskrune((char)v5, 0x40000uLL))
    goto LABEL_29;
LABEL_27:
  v17 = *((char *)this + 88);
LABEL_30:
  LogError("completeSetup", 1768, "*** IIOIOSurfaceWrapper_CIF10 - pixelFormat '%c%c%c%c' not handled\n", v10, v13, v16, v17);
  v6 = 0;
LABEL_31:
  IIOIOSurfaceWrapperBase::completeSetup(this, a2, v6);
  if (a2)
  {
    if (!*((_BYTE *)this + 264))
    {
      *((_BYTE *)this + 265) = 1;
LABEL_53:
      IIOIOSurfaceWrapper_CIF10::updateColorMatchMode((uint64_t)this, a2);
      return;
    }
    if (IIODictionary::containsKey(a2, CFSTR("kCGImageSkipCIF10SRGBCheck")))
    {
      BoolForKey = IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSkipCIF10SRGBCheck"));
      *((_BYTE *)this + 265) = BoolForKey;
      v19 = "NO";
      if (BoolForKey)
        v19 = "YES";
      _cg_jpeg_mem_term("completeSetup", 1787, "    kCGImageSkipCIF10SRGBCheck was set to %s\n", v19);
    }
    else
    {
      v20 = *((_DWORD *)this + 54);
      if (v20 == 2 || v20 == 5 || (v21 = *((_DWORD *)this + 53), v21 == 5) || v21 == 2)
      {
        if (v20 == 2)
          v22 = "kCGImageComponent16BitInteger";
        else
          v22 = "kCGImageComponent16BitFloat";
        _cg_jpeg_mem_term("completeSetup", 1796, "    _componentType = %s  -- will skip CIF10SRGBCheck\n", v22);
        *((_BYTE *)this + 265) = 1;
        goto LABEL_49;
      }
    }
    if (!*((_BYTE *)this + 265))
      goto LABEL_53;
LABEL_49:
    v23 = gDeviceHasExtendedColorDisplay;
    *((_BYTE *)this + 272) = gDeviceHasExtendedColorDisplay ^ 1;
    if (v23)
      v24 = "NO (= assume P3)";
    else
      v24 = "YES";
    _cg_jpeg_mem_term("completeSetup", 1802, "    Skipping CIF10-to-SRGB-Check -- _isSRGB = %s\n", v24);
    goto LABEL_53;
  }
}

uint64_t IIOIOSurfaceWrapper_CIF10::updateColorMatchMode(uint64_t this, IIODictionary *a2)
{
  uint64_t v2;

  v2 = this;
  if (a2)
  {
    this = (uint64_t)IIODictionary::containsKey(a2, CFSTR("kCGImagePreferredColorConversionMode"));
    if ((_DWORD)this)
    {
      this = (uint64_t)IIODictionary::getUint32ForKey(a2, CFSTR("kCGImagePreferredColorConversionMode"));
      switch((int)this)
      {
        case 1:
          break;
        case 2:
          this = 2 * gCanUseMSRForColorConversion;
          break;
        case 3:
          this = 3;
          break;
        case 4:
          this = 0;
          *(_BYTE *)(v2 + 267) = 1;
          break;
        default:
          this = 0;
          break;
      }
      *(_DWORD *)(v2 + 268) = this;
      if ((gIIODebugFlags & 0x8000300000) != 0)
        this = (uint64_t)ImageIOLog("COL updateColorMatchMode: kCGImagePreferredColorConversionMode specified --> using: %d '%s'\n", this, (&gIIOColorMatchModeString)[this]);
      *(_BYTE *)(v2 + 266) = 1;
    }
  }
  else if (!*(_BYTE *)(this + 266))
  {
    *(_DWORD *)(this + 268) = 0;
    if ((gIIODebugFlags & 0x8000300000) != 0)
      return (uint64_t)ImageIOLog("COL updateColorMatchMode: no options specified --> using: kColorConversionModeDefault\n");
  }
  return this;
}

uint64_t IIOIOSurfaceWrapper_CIF10::createImage(IIOIOSurfaceWrapper_CIF10 *this)
{
  void *v2;
  int v3;
  const __CFString **v4;
  int v5;
  unsigned int *BaseAddressOfPlane;
  int v7;
  CFStringRef *v8;
  uint64_t v9;
  int v10;
  CGColorSpace *v11;
  const char *v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  _QWORD v27[3];
  _QWORD v28[7];

  v2 = IIOIOSurfaceWrapper_CIF10::CopyImageBlockSetWithOptions;
  if (*((_BYTE *)this + 140))
    v2 = IIOIOSurfaceWrapperBase::CopyImageBlockSetWithOptionsNoOp;
  v28[4] = v2;
  v28[3] = 2;
  v28[5] = IIOIOSurfaceWrapperBase::CopyIOSurface;
  v28[6] = IIOIOSurfaceWrapperBase::ReleaseInfo;
  memset(v28, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v28);
  v3 = *((_DWORD *)this + 22);
  if (v3 == 1647534392)
  {
    v4 = (const __CFString **)MEMORY[0x1E0C9DAF0];
    goto LABEL_7;
  }
  if (v3 == 1999843442)
  {
    v4 = (const __CFString **)MEMORY[0x1E0C9DAE8];
LABEL_7:
    IIODictionary::setObjectForKey((IIODictionary *)v28, (const void *)*MEMORY[0x1E0C9AE50], *v4);
  }
  if (!*((_BYTE *)this + 265) && !IOSurfaceLock(*((IOSurfaceRef *)this + 9), 1u, 0))
  {
    v5 = *((_DWORD *)this + 22);
    if (v5 == 1647534392)
    {
      BaseAddressOfPlane = (unsigned int *)IOSurfaceGetBaseAddressOfPlane(*((IOSurfaceRef *)this + 9), 0);
    }
    else
    {
      if (v5 != 1999843442)
        goto LABEL_46;
      BaseAddressOfPlane = (unsigned int *)IOSurfaceGetBaseAddress(*((IOSurfaceRef *)this + 9));
    }
    if (BaseAddressOfPlane)
    {
      *((_BYTE *)this + 272) = IIOIOSurfaceWrapper_CIF10::checkIfCIF10DataFitsIntoSRGB(this, BaseAddressOfPlane);
      IOSurfaceUnlock(*((IOSurfaceRef *)this + 9), 1u, 0);
      goto LABEL_16;
    }
    v5 = *((_DWORD *)this + 22);
LABEL_46:
    v14 = v5 >> 24;
    v15 = MEMORY[0x1E0C80978];
    if (v5 < 0)
    {
      v16 = __maskrune(v14, 0x40000uLL);
      v5 = *((_DWORD *)this + 22);
    }
    else
    {
      v16 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v14 + 60) & 0x40000;
    }
    if (v16)
      v17 = (v5 >> 24);
    else
      v17 = 46;
    v18 = v5 << 8 >> 24;
    if (v5 << 8 < 0)
    {
      v19 = __maskrune(v18, 0x40000uLL);
      v5 = *((_DWORD *)this + 22);
    }
    else
    {
      v19 = *(_DWORD *)(v15 + 4 * v18 + 60) & 0x40000;
    }
    if (v19)
      v20 = (v5 << 8 >> 24);
    else
      v20 = 46;
    v21 = (__int16)v5 >> 8;
    if (v5 << 16 < 0)
    {
      v22 = __maskrune(v21, 0x40000uLL);
      v5 = *((_DWORD *)this + 22);
    }
    else
    {
      v22 = *(_DWORD *)(v15 + 4 * v21 + 60) & 0x40000;
    }
    if (v22)
      v23 = ((__int16)v5 >> 8);
    else
      v23 = 46;
    if ((v5 << 24) <= 0x7F000000)
      v24 = *(_DWORD *)(v15 + 4 * (char)v5 + 60) & 0x40000;
    else
      v24 = __maskrune((char)v5, 0x40000uLL);
    if (v24)
      v25 = *((char *)this + 88);
    else
      v25 = 46;
    _cg_jpeg_mem_term("createImage", 1839, "*** ERROR: can't get CIF10 data '%c%c%c%c'\n", v17, v20, v23, v25);
LABEL_71:
    v13 = 0;
    goto LABEL_72;
  }
LABEL_16:
  if (*((_BYTE *)this + 208) != 1)
  {
    v9 = *((int *)this + 54);
    if (*((_BYTE *)this + 272))
    {
      if ((_DWORD)v9 != 1)
      {
        if ((gIIODebugFlags & 0x8000300000) != 0)
          ImageIOLog("*** _isSRGB + componentType: changing %s to %s\n", (&gComponentString)[v9], "8BitInt");
        v10 = 1;
LABEL_29:
        *((_DWORD *)this + 54) = v10;
      }
    }
    else if ((_DWORD)v9 != 2)
    {
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("*** NOT _isSRGB + componentType: changing %s to %s\n", (&gComponentString)[v9], "16BitFloat");
      v10 = 2;
      goto LABEL_29;
    }
    v8 = (CFStringRef *)MEMORY[0x1E0C9D908];
    goto LABEL_31;
  }
  v7 = *((_DWORD *)this + 53);
  *((_DWORD *)this + 54) = v7;
  if ((v7 - 1) >= 2)
    v8 = (CFStringRef *)MEMORY[0x1E0C9D960];
  else
    v8 = (CFStringRef *)MEMORY[0x1E0C9D908];
LABEL_31:
  if (*((_BYTE *)this + 272))
    v8 = (CFStringRef *)MEMORY[0x1E0C9DA10];
  if (!*v8)
    goto LABEL_71;
  v11 = CGColorSpaceCreateWithName(*v8);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    if (*((_BYTE *)this + 272))
    {
      v12 = "sRGB";
    }
    else if (*((_DWORD *)this + 54) == 1)
    {
      v12 = "P3";
    }
    else
    {
      v12 = "extended-sRGB";
    }
    ImageIOLog("COL CGImageProviderCreate - using '%s'\n", v12);
  }
  if (CGImageProviderCreate())
  {
    CGImageProviderSetProperty();
    memset(v27, 0, sizeof(v27));
    IIONumber::IIONumber((IIONumber *)v27, *((_DWORD *)this + 22));
    CGImageProviderSetProperty();
    v13 = CGImageCreateWithImageProvider();
    CGImageProviderRelease();
    CGImageSetProperty();
    IIONumber::~IIONumber((IIONumber *)v27);
  }
  else
  {
    v13 = 0;
  }
  CGColorSpaceRelease(v11);
LABEL_72:
  IIODictionary::~IIODictionary((IIODictionary *)v28);
  return v13;
}

void sub_18804FB34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16)
{
  CGColorSpace *v16;

  CGColorSpaceRelease(v16);
  IIODictionary::~IIODictionary((IIODictionary *)&a16);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper_CIF10::CopyImageBlockSetWithOptions(uint64_t a1, uint64_t a2, __CFDictionary *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  _QWORD v37[4];

  memset(v37, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v37, a3);
  v18 = *(int *)(a1 + 216);
  IIOPackCopyCallbackInfo(a3);
  CGImageProviderGetBitmapInfo();
  kdebug_trace();
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    v20 = *(_DWORD *)(a1 + 88);
    v21 = v20 >> 24;
    v22 = MEMORY[0x1E0C80978];
    if (v20 < 0)
      v23 = __maskrune(v20 >> 24, 0x40000uLL);
    else
      v23 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v21 + 60) & 0x40000;
    if (v23)
      v24 = v21;
    else
      v24 = 46;
    v25 = v20 << 8 >> 24;
    if (v20 << 8 < 0)
      v26 = __maskrune(v20 << 8 >> 24, 0x40000uLL);
    else
      v26 = *(_DWORD *)(v22 + 4 * v25 + 60) & 0x40000;
    if (v26)
      v27 = v25;
    else
      v27 = 46;
    v28 = (__int16)v20 >> 8;
    if (v20 << 16 < 0)
      v29 = __maskrune((__int16)v20 >> 8, 0x40000uLL);
    else
      v29 = *(_DWORD *)(v22 + 4 * v28 + 60) & 0x40000;
    if ((v20 << 24) <= 0x7F000000)
      v30 = *(_DWORD *)(v22 + 4 * (char)v20 + 60) & 0x40000;
    else
      v30 = __maskrune((char)v20, 0x40000uLL);
    if (v29)
      v31 = v28;
    else
      v31 = 46;
    if (v30)
      v32 = (char)v20;
    else
      v32 = 46;
    ImageIOLog("S   CopyImageBlockSetWithOptions-CIF10: {%g, %g, %g, %g} {%g, %g} '%c%c%c%c' %s\n", a4, a5, a6, a7, a8, a9, v24, v27, v31, v32, off_1E1BCA3A8[v18]);
  }
  v36 = 0;
  if (!*(_BYTE *)(a1 + 141))
  {
    switch((int)v18)
    {
      case 1:
        v33 = IIOIOSurfaceWrapper_CIF10::copyImageBlockSetWithOptions8Bit((uint64_t *)a1, a2, (uint64_t)v37, &v36, a4, a5, a6, a7, a8, a9);
        goto LABEL_29;
      case 2:
      case 5:
        v33 = IIOIOSurfaceWrapper_CIF10::copyImageBlockSetWithOptions16Bit((uint64_t *)a1, a2, (uint64_t)v37, &v36, a4, a5, a6, a7, a8, a9);
        goto LABEL_29;
      case 6:
        goto LABEL_35;
      default:
        LogError("CopyImageBlockSetWithOptions", 2793, "*** unsupported componentType '%s' (%d)\n", (&gComponentString)[v18], v18);
        goto LABEL_35;
    }
  }
  v33 = IIOIOSurfaceWrapperBase::createBlockSetForCompressedSurface(a1, a4, a5, a6, a7, a2, v19, &v36);
LABEL_29:
  v34 = v33;
  if (v33)
  {
    CGImageBlockSetGetRect();
  }
  else
  {
LABEL_35:
    _cg_jpeg_mem_term("CopyImageBlockSetWithOptions", 2803, "*** ERROR: CopyImageBlockSetWithOptions returned NULL\n");
    v34 = 0;
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v37);
  return v34;
}

void sub_18804FEAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

BOOL IIOIOSurfaceWrapper_CIF10::checkIfCIF10DataFitsIntoSRGB(IIOIOSurfaceWrapper_CIF10 *this, unsigned int *a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint32x4_t v10;
  uint32x4_t v11;
  int8x16_t v12;
  int8x16_t v13;
  unsigned int *v14;
  uint64_t v15;
  int8x16_t v16;
  unsigned __int128 v17;
  uint32x4_t v18;
  uint32x4_t v19;
  char v20;
  unint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  BOOL v31;

  v2 = *((_QWORD *)this + 13);
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    v5 = *((_DWORD *)this + 64);
    v6 = *((_DWORD *)this + 65);
    v7 = *((_QWORD *)this + 14);
    v8 = *((_QWORD *)this + 12);
    v9 = v8 >> 2;
    v10 = (uint32x4_t)vdupq_n_s32(v5);
    v11 = (uint32x4_t)vdupq_n_s32(v6);
    if (v8 >> 2 <= 1)
      v9 = 1;
    v12.i64[0] = 0x300000003;
    v12.i64[1] = 0x300000003;
    do
    {
      v13 = 0uLL;
      if (v8 >= 4)
      {
        v14 = a2;
        v15 = v9;
        do
        {
          v16 = *(int8x16_t *)v14;
          v14 += 4;
          v17 = *(_OWORD *)&vshrq_n_u32((uint32x4_t)v16, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL);
          v18 = (uint32x4_t)vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v16, 0xAuLL), v12);
          v19 = (uint32x4_t)vandq_s8(v16, v12);
          v13 = vorrq_s8(vorrq_s8(v13, (int8x16_t)vcgtq_u32(v18, v11)), vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vcgtq_u32(v19, v11), (int8x16_t)vcgtq_u32(v10, v19)), (int8x16_t)vcgtq_u32((uint32x4_t)v17, v11)), vorrq_s8((int8x16_t)vcgtq_u32(v10, (uint32x4_t)v17), (int8x16_t)vcgtq_u32(v10, v18))));
          --v15;
        }
        while (v15);
      }
      if ((v8 & 0xFFFFFFFFFFFFFFFCLL) >= v8)
      {
        v20 = 0;
      }
      else
      {
        v20 = 0;
        v21 = v8 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          v22 = a2[v21];
          v23 = (v22 >> 20) & 0x3FF;
          v24 = (v22 >> 10) & 0x3FF;
          v25 = v22 & 0x3FF;
          v31 = v23 < v5 || v23 > v6 || v24 < v5 || v24 > v6 || v25 < v5 || v25 > v6;
          v20 |= v31;
          ++v21;
        }
        while (v8 != v21);
      }
      if ((vmaxvq_u32((uint32x4_t)v13) & 0x80000000) != 0)
        break;
      if ((v20 & 1) != 0)
        break;
      ++v4;
      a2 = (unsigned int *)((char *)a2 + v7);
      v3 = v4 >= v2;
    }
    while (v4 != v2);
  }
  else
  {
    return 1;
  }
  return v3;
}

vImage_Error IIOIOSurfaceWrapper_CIF10::copy_CIF10_8bit_sRGB(IIOIOSurfaceWrapper_CIF10 *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Buffer *a4)
{
  double Current;
  int v8;
  int *v9;
  vImage_Error v10;
  CFAbsoluteTime v11;
  int v13;
  int v14;

  Current = CFAbsoluteTimeGetCurrent();
  v8 = *((_DWORD *)this + 22);
  if (v8 != 1647534392)
  {
    if (v8 == 1999843442)
    {
      v14 = 197121;
      v13 = 66051;
      if (*((_BYTE *)this + 200))
        v9 = &v13;
      else
        v9 = &v14;
      v10 = vImageConvert_XRGB2101010ToARGB8888(a2, 0xFFu, a4, *((_DWORD *)this + 64), *((_DWORD *)this + 65), (const uint8_t *)v9, 0x10u);
      if ((_DWORD)v10)
        _cg_jpeg_mem_term("copy_CIF10_8bit_sRGB", 2060, "*** ERROR vImageConvert_XRGB2101010ToARGB8888 - %d\n");
      goto LABEL_13;
    }
LABEL_12:
    v10 = 4294967246;
    goto LABEL_13;
  }
  if (IOSurfaceGetPlaneCount(*((IOSurfaceRef *)this + 9)) != 2)
    goto LABEL_12;
  v14 = 197121;
  v13 = 66051;
  v10 = vImageConvert_XRGB2101010_A8ToARGB8888();
  if ((_DWORD)v10)
    _cg_jpeg_mem_term("copy_CIF10_8bit_sRGB", 2085, "*** ERROR vImageConvert_XRGB2101010_A8ToARGB8888 - %d\n");
LABEL_13:
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_CIF10_8bit_sRGB", (v11 - Current) * 1000.0);
  }
  return v10;
}

vImage_Error IIOIOSurfaceWrapper_CIF10::copy_to_CIF10_FP16_xsRGB(IIOIOSurfaceWrapper_CIF10 *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Buffer *a4)
{
  double Current;
  int v8;
  vImage_Error v9;
  size_t BytesPerRowOfPlane;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  void *BaseAddressOfPlane;
  void *v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  CFAbsoluteTime v26;
  uint8_t permuteMap[8];
  size_t v29;
  size_t v30;
  size_t v31;
  int v32;

  Current = CFAbsoluteTimeGetCurrent();
  v8 = *((_DWORD *)this + 22);
  if (v8 != 1647534392)
  {
    if (v8 == 1999843442)
    {
      *(_DWORD *)permuteMap = 197121;
      v9 = vImageConvert_XRGB2101010ToARGB16F(a2, 1.0, a4, *((_DWORD *)this + 64), *((_DWORD *)this + 65), permuteMap, 0x810u);
      goto LABEL_33;
    }
    v15 = v8 >> 24;
    v16 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v17 = __maskrune(v15, 0x40000uLL);
      v8 = *((_DWORD *)this + 22);
    }
    else
    {
      v17 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v15 + 60) & 0x40000;
    }
    if (v17)
      v18 = (v8 >> 24);
    else
      v18 = 46;
    v19 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v20 = __maskrune(v19, 0x40000uLL);
      v8 = *((_DWORD *)this + 22);
    }
    else
    {
      v20 = *(_DWORD *)(v16 + 4 * v19 + 60) & 0x40000;
    }
    if (v20)
      v21 = (v8 << 8 >> 24);
    else
      v21 = 46;
    v22 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v23 = __maskrune(v22, 0x40000uLL);
      v8 = *((_DWORD *)this + 22);
    }
    else
    {
      v23 = *(_DWORD *)(v16 + 4 * v22 + 60) & 0x40000;
    }
    if (v23)
      v24 = ((__int16)v8 >> 8);
    else
      v24 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v16 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_28;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_28:
      v25 = *((char *)this + 88);
LABEL_31:
      _cg_jpeg_mem_term("copy_to_CIF10_FP16_xsRGB", 2159, "*** _surfacePixelFormat '%c%c%c%c' is not handled\n", v18, v21, v24, v25);
      goto LABEL_32;
    }
    v25 = 46;
    goto LABEL_31;
  }
  if (IOSurfaceGetPlaneCount(*((IOSurfaceRef *)this + 9)) != 2)
  {
LABEL_32:
    v9 = 4294967246;
    goto LABEL_33;
  }
  BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 0);
  WidthOfPlane = IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 0);
  HeightOfPlane = IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 0);
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(*((IOSurfaceRef *)this + 9), 0);
  IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
  IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
  IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
  v14 = IOSurfaceGetBaseAddressOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
  v32 = 50462976;
  v9 = 4294967246;
  if (BaseAddressOfPlane && v14)
  {
    *(_QWORD *)permuteMap = BaseAddressOfPlane;
    v29 = HeightOfPlane;
    v30 = WidthOfPlane;
    v31 = BytesPerRowOfPlane;
    v9 = vImageConvert_XRGB2101010_A8ToARGB16F();
    LogError("copy_to_CIF10_FP16_xsRGB", 2150, "⭕️ check 'b3a8' conversion\n");
  }
LABEL_33:
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v26 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_to_CIF10_FP16_xsRGB", (v26 - Current) * 1000.0);
  }
  return v9;
}

uint64_t IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_CA(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2, vImage_Buffer *a3, vImage_Buffer *a4, vImage_Buffer *a5)
{
  double height;
  double width;
  double Current;
  uint64_t *v10;
  uint64_t v11;
  CGImage *v12;
  int v13;
  double v14;
  unint64_t v15;
  int v16;
  __IOSurface *IOSurfaceWithFormatAndBuffer;
  CGColorSpace *v18;
  CGContext *IOSurfaceContext;
  unsigned int v20;
  uint64_t v21;
  void *BaseAddress;
  int *v23;
  uint64_t Property;
  CFAbsoluteTime v26;
  vImage_Buffer src;
  int v29;
  int v30;
  _QWORD v31[3];
  _QWORD v32[3];
  __int128 v33;
  __int128 v34;
  CGRect v35;

  height = a2.size.height;
  width = a2.size.width;
  Current = CFAbsoluteTimeGetCurrent();
  v33 = xmmword_1E1BCA340;
  v34 = *(_OWORD *)&off_1E1BCA350;
  memset(v32, 0, sizeof(v32));
  IIODictionary::IIODictionary((IIODictionary *)v32);
  if (height == (double)*((unint64_t *)this + 13) && width == (double)*((unint64_t *)this + 12))
  {
    v10 = (uint64_t *)MEMORY[0x1E0C9AE50];
    if (*((_DWORD *)this + 41))
      IIODictionary::setObjectForKey((IIODictionary *)v32, (const void *)*MEMORY[0x1E0C9AE50], (const __CFString *)*MEMORY[0x1E0C9DAF0]);
    if (CGImageProviderCreate())
    {
      v11 = *v10;
      CGImageProviderSetProperty();
      memset(v31, 0, sizeof(v31));
      IIONumber::IIONumber((IIONumber *)v31, *((_DWORD *)this + 22));
      CGImageProviderSetProperty();
      v12 = (CGImage *)CGImageCreateWithImageProvider();
      if (v12)
      {
        v13 = *((_DWORD *)this + 54);
        v14 = 4.0;
        if (v13 == 2)
          v14 = 8.0;
        v15 = IIOAlignRowBytes((unint64_t)(width * v14), 0);
        if (v13 == 2)
          v16 = 1815491698;
        else
          v16 = 1111970369;
        IOSurfaceWithFormatAndBuffer = IIO_CreateIOSurfaceWithFormatAndBuffer(a5->width, a5->height, v15, v16, (unsigned __int8 *)a5->data, a5->height * v15, 1, 0);
        if (IOSurfaceWithFormatAndBuffer)
        {
          v18 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D908]);
          IIO_IOSurfaceAddColorSpace(IOSurfaceWithFormatAndBuffer, v18);
          IOSurfaceContext = (CGContext *)IIO_CreateIOSurfaceContext(IOSurfaceWithFormatAndBuffer, v18);
          if (IOSurfaceContext)
          {
            CGContextClear();
            v35.origin.x = 0.0;
            v35.origin.y = 0.0;
            v35.size.width = width;
            v35.size.height = height;
            CGContextDrawImage(IOSurfaceContext, v35, v12);
            CGContextFlush(IOSurfaceContext);
            if (IOSurfaceLock(IOSurfaceWithFormatAndBuffer, 1u, 0))
            {
              v20 = -50;
            }
            else
            {
              BaseAddress = IOSurfaceGetBaseAddress(IOSurfaceWithFormatAndBuffer);
              if (BaseAddress)
              {
                if (*((_DWORD *)this + 54) == 1)
                {
                  v30 = 50331906;
                  v29 = 50462976;
                  src.data = BaseAddress;
                  *(_OWORD *)&src.height = *(_OWORD *)&a5->height;
                  src.rowBytes = v15;
                  if (*((_BYTE *)this + 200))
                    v23 = &v29;
                  else
                    v23 = &v30;
                  vImagePermuteChannels_ARGB8888(&src, a5, (const uint8_t *)v23, 0x10u);
                }
              }
              else
              {
                IOSurfaceRemoveValue(IOSurfaceWithFormatAndBuffer, CFSTR("com.apple.ImageIO.ImageIO_Malloced"));
              }
              IOSurfaceUnlock(IOSurfaceWithFormatAndBuffer, 1u, 0);
              v20 = 0;
            }
            CGContextRelease(IOSurfaceContext);
          }
          else
          {
            v20 = -50;
          }
          IIO_IOSurfaceRelease(IOSurfaceWithFormatAndBuffer);
          CGColorSpaceRelease(v18);
        }
        else
        {
          v20 = -50;
        }
        CGImageRelease(v12);
      }
      else
      {
        v20 = -50;
      }
      Property = CGImageProviderGetProperty();
      CGImageProviderRelease();
      if (Property != v11 || Property == 0)
        v21 = v20;
      else
        v21 = 4294967246;
      IIONumber::~IIONumber((IIONumber *)v31);
    }
    else
    {
      v21 = 4294967246;
    }
    if ((gIIODebugFlags & 0x8000300000) != 0)
    {
      v26 = CFAbsoluteTimeGetCurrent();
      ImageIOLog("COL %s - time: %gms\n", "copy_and_colormatch_CIF10_to_P3_CA", (v26 - Current) * 1000.0);
    }
  }
  else
  {
    v21 = 4294967246;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v32);
  return v21;
}

void sub_18805084C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char a20)
{
  CGColorSpace *v20;

  CGColorSpaceRelease(v20);
  IIONumber::~IIONumber((IIONumber *)&a17);
  IIODictionary::~IIODictionary((IIODictionary *)&a20);
  _Unwind_Resume(a1);
}

vImage_Error IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_MSR(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2, vImage_Buffer *a3, vImage_Buffer *a4, vImage_Buffer *a5)
{
  uint64_t v7;
  __IOSurface *IOSurfaceWithFormatAndBuffer;
  __IOSurface *v9;
  float64x2_t v10;
  float64x2_t v11;
  uint64_t v12;
  vImage_Error v13;
  void *BaseAddress;
  unsigned int BytesPerRow;
  uint8_t *v17;
  CGFloat y;
  CGFloat x;
  double height;
  double width;
  vImage_Buffer src;
  int v23;
  uint8_t permuteMap[4];
  CFDictionaryRef properties[2];
  uint64x2_t v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  int v37;
  CFTypeRef v38;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  v38 = 0;
  v37 = 0;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v30 = 0u;
  BYTE11(v33) = 12;
  v7 = IOSurfaceAcceleratorCreate();
  if ((_DWORD)v7)
  {
    v13 = v7;
    v9 = 0;
  }
  else
  {
    IOSurfaceWithFormatAndBuffer = IIO_CreateIOSurfaceWithFormatAndBuffer(a5->width, a5->height, a5->rowBytes, 1380401729, (unsigned __int8 *)a5->data, a5->rowBytes * a5->height, 1, 0);
    v9 = IOSurfaceWithFormatAndBuffer;
    if (IOSurfaceWithFormatAndBuffer)
      goto LABEL_4;
    properties[0] = 0;
    properties[1] = 0;
    v26.i64[0] = 0;
    IIODictionary::IIODictionary((IIODictionary *)properties);
    IIONumber::IIONumber((IIONumber *)&src, (uint64_t)width);
    IIODictionary::setObjectForKey((IIODictionary *)properties, (const void *)src.width, (const __CFString *)*MEMORY[0x1E0CBC1E0]);
    IIONumber::~IIONumber((IIONumber *)&src);
    IIONumber::IIONumber((IIONumber *)&src, (uint64_t)height);
    IIODictionary::setObjectForKey((IIODictionary *)properties, (const void *)src.width, (const __CFString *)*MEMORY[0x1E0CBC008]);
    IIONumber::~IIONumber((IIONumber *)&src);
    IIONumber::IIONumber((IIONumber *)&src, 4);
    IIODictionary::setObjectForKey((IIODictionary *)properties, (const void *)src.width, (const __CFString *)*MEMORY[0x1E0CBBF00]);
    IIONumber::~IIONumber((IIONumber *)&src);
    IIONumber::IIONumber((IIONumber *)&src, 1380401729);
    IIODictionary::setObjectForKey((IIODictionary *)properties, (const void *)src.width, (const __CFString *)*MEMORY[0x1E0CBC070]);
    IIONumber::~IIONumber((IIONumber *)&src);
    v9 = IOSurfaceCreate(properties[1]);
    _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_MSR", 2328, "*** falling back to standard 'IOSurfaceCreate'\n");
    IIODictionary::~IIODictionary((IIODictionary *)properties);
    if (v9)
    {
LABEL_4:
      IOSurfaceRemoveValue(v9, CFSTR("com.apple.ImageIO.ImageIO_Malloced"));
      IOSurfaceSetBulkAttachments2();
      v10.f64[0] = x;
      v10.f64[1] = y;
      v11.f64[0] = width;
      v11.f64[1] = height;
      *(uint64x2_t *)properties = vcvtq_n_u64_f64(v10, 0x10uLL);
      v26 = vcvtq_n_u64_f64(v11, 0x10uLL);
      v27 = 0;
      v28 = width;
      v29 = height;
      v12 = IOSurfaceAcceleratorTransformSurface();
      if ((_DWORD)v12)
      {
        v13 = v12;
        _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_MSR", 2350, "*** TransformSurface-band err 0x%x (%d)\n", v13, v13);
        goto LABEL_11;
      }
      *(_DWORD *)permuteMap = 50331906;
      v23 = 50462976;
      if (IOSurfaceWithFormatAndBuffer)
      {
        if (*((_BYTE *)this + 200))
        {
          v13 = vImagePermuteChannels_ARGB8888(a5, a5, permuteMap, 0x10u);
          goto LABEL_11;
        }
      }
      else if (!IOSurfaceLock(v9, 1u, 0))
      {
        BaseAddress = IOSurfaceGetBaseAddress(v9);
        BytesPerRow = IOSurfaceGetBytesPerRow(v9);
        src.data = BaseAddress;
        *(_OWORD *)&src.height = *(_OWORD *)&a5->height;
        src.rowBytes = BytesPerRow;
        if (*((_BYTE *)this + 200))
          v17 = permuteMap;
        else
          v17 = (uint8_t *)&v23;
        v13 = vImagePermuteChannels_ARGB8888(&src, a5, v17, 0x10u);
        IOSurfaceUnlock(v9, 1u, 0);
        goto LABEL_11;
      }
    }
    v13 = 0;
  }
LABEL_11:
  IIO_IOSurfaceRelease(v9);
  if (v38)
    CFRelease(v38);
  return v13;
}

void sub_188050BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_vImage(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2, vImage_Buffer *a3, vImage_Buffer *a4, vImage_Buffer *a5)
{
  double Current;
  int v8;
  CGColorSpace *v9;
  const __CFString *v10;
  CGColorSpace *v11;
  CGColorSpace *v12;
  CGColorSpace *v13;
  CGBitmapInfo v14;
  vImagePixelCount width;
  void *v16;
  void *v17;
  vImagePixelCount v18;
  __int128 v19;
  __int128 v20;
  vImagePixelCount height;
  vImagePixelCount v22;
  uint64_t v23;
  vImagePixelCount v24;
  vImagePixelCount v25;
  int v26;
  int v27;
  unsigned int v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  char *v39;
  vImage_Error v40;
  vImage_Error v41;
  CFAbsoluteTime v42;
  void *v44;
  void *v45;
  CGColorSpace *v46;
  CGColorSpace *v47;
  CGColorSpace *v48;
  CGColorSpace *space;
  vImagePixelCount v52;
  size_t rowBytes;
  vImage_Buffer dest;
  vImage_Buffer src;
  vImage_Buffer v56;
  vImage_Buffer v57;
  vImage_Buffer v58;
  vImage_Buffer v59;
  _QWORD v60[2];
  vImage_CGImageFormat v61;
  vImage_CGImageFormat v62;

  Current = CFAbsoluteTimeGetCurrent();
  v8 = *((_DWORD *)this + 41);
  v9 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D960]);
  v10 = (const __CFString *)*MEMORY[0x1E0C9D908];
  v46 = v9;
  v11 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D908]);
  v47 = v11;
  v12 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  v48 = v12;
  v13 = CGColorSpaceCreateWithName(v10);
  *(_QWORD *)&v62.renderingIntent = 0;
  *(_QWORD *)&v62.bitsPerComponent = 0x4000000010;
  v62.colorSpace = v9;
  if (v8)
    v14 = 4353;
  else
    v14 = 4357;
  v62.bitmapInfo = v14;
  *(_OWORD *)&v62.version = 0uLL;
  *(_QWORD *)&v61.bitsPerComponent = 0x4000000010;
  v61.colorSpace = v11;
  v61.bitmapInfo = v14;
  memset(&v61.version, 0, 20);
  v60[0] = 0;
  v60[1] = 0;
  space = v13;
  IIOColorConverter::IIOColorConverter((IIOColorConverter *)v60, &v62, &v61, v12, v13);
  width = a5->width;
  v16 = malloc_type_malloc(width << 9, 0xF46048A7uLL);
  v17 = malloc_type_malloc(width << 9, 0x3EE192ADuLL);
  if ((gIIODebugFlags & 0x8000300000) != 0)
    ImageIOLog("COL copy_and_colormatch_CIF10_to_P3_vImage: allocating FP16 buffers: 2 x %ld = %ld\n", width << 9, width << 10);
  v59.data = v16;
  v59.height = 64;
  v58.data = v17;
  v58.height = 64;
  v18 = a5->width;
  rowBytes = a5->rowBytes;
  v59.width = v18;
  v59.rowBytes = 8 * width;
  v58.width = v18;
  v58.rowBytes = 8 * width;
  v19 = *(_OWORD *)&a3->width;
  *(_OWORD *)&v57.data = *(_OWORD *)&a3->data;
  *(_OWORD *)&v57.width = v19;
  memset(&v56, 0, sizeof(v56));
  if (a4)
  {
    v20 = *(_OWORD *)&a4->width;
    *(_OWORD *)&v56.data = *(_OWORD *)&a4->data;
    *(_OWORD *)&v56.width = v20;
  }
  v44 = v17;
  v45 = v16;
  height = a5->height;
  if (height)
  {
    v22 = 0;
    v52 = 4 * v18;
    v23 = 4294967246;
    v24 = 64;
    v25 = 64;
    while (v22 + v25 <= height)
    {
      v57.height = v25;
      v56.height = v25;
      if (v24)
        goto LABEL_14;
      v22 += v25;
LABEL_54:
      if (v22 >= height)
        goto LABEL_57;
    }
    v25 = (height - v22);
    v59.height = v25;
    v58.height = v25;
    v57.height = v25;
    v56.height = v25;
    v24 = v25;
    if ((_DWORD)height == (_DWORD)v22)
      goto LABEL_57;
LABEL_14:
    v26 = *((_DWORD *)this + 22);
    if (v26 == 1647534392)
    {
      v57.data = (char *)a3->data + *((_QWORD *)this + 14) * v22;
      v56.data = (char *)a4->data + *((_QWORD *)this + 30) * v22;
      v27 = IIOIOSurfaceWrapper_CIF10::convert_b3a8_to_ARGB16F(this, &v57, &v56, &v59);
      goto LABEL_18;
    }
    if (v26 == 1999843442)
    {
      v57.data = (char *)a3->data + *((_QWORD *)this + 14) * v22;
      v27 = IIOIOSurfaceWrapper_CIF10::convert_w30r_to_ARGB16F(this, &v57, &v59);
LABEL_18:
      LODWORD(v23) = v27;
LABEL_44:
      if ((_DWORD)v23)
        _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2473, "*** ERROR: conversion from CIF10 to FP16 failed: %d\n", v23);
      v38 = IIOColorConverter::colorConvert((IIOColorConverter *)v60, &v59, &v58);
      if (v38)
        _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2480, "*** ERROR: color conversion fp16_xsRGB to fp16_P3 failed: %d\n", v38);
      v39 = (char *)a5->data + a5->rowBytes * v22;
      *(_OWORD *)&src.data = *(_OWORD *)&v58.data;
      src.rowBytes = v58.rowBytes;
      dest.data = v39;
      dest.height = v24;
      src.width = 4 * v58.width;
      dest.width = v52;
      dest.rowBytes = rowBytes;
      if (*((_DWORD *)this + 54) == 1)
      {
        v40 = vImageConvert_Planar16FtoPlanar8(&src, &dest, 0x10u);
        v23 = v40;
        if ((_DWORD)v40)
          _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2499, "*** ERROR: vImageConvert_Planar16FtoPlanar8 err: %d\n", v40);
      }
      else
      {
        v41 = vImageConvert_16Fto16U(&src, &dest, 0x10u);
        v23 = v41;
        if ((_DWORD)v41)
          _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2511, "*** ERROR: vImageConvert_16Fto16U err: %d\n", v41);
      }
      height = a5->height;
      v22 += v25;
      goto LABEL_54;
    }
    v28 = v26 >> 24;
    if (v26 < 0)
    {
      v29 = __maskrune(v28, 0x40000uLL);
      v26 = *((_DWORD *)this + 22);
    }
    else
    {
      v29 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v28 + 60) & 0x40000;
    }
    if (v29)
      v30 = (v26 >> 24);
    else
      v30 = 46;
    v31 = v26 << 8 >> 24;
    if (v26 << 8 < 0)
    {
      v32 = __maskrune(v31, 0x40000uLL);
      v26 = *((_DWORD *)this + 22);
    }
    else
    {
      v32 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v31 + 60) & 0x40000;
    }
    if (v32)
      v33 = (v26 << 8 >> 24);
    else
      v33 = 46;
    v34 = (__int16)v26 >> 8;
    if (v26 << 16 < 0)
    {
      v35 = __maskrune(v34, 0x40000uLL);
      v26 = *((_DWORD *)this + 22);
    }
    else
    {
      v35 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v34 + 60) & 0x40000;
    }
    if (v35)
      v36 = ((__int16)v26 >> 8);
    else
      v36 = 46;
    if ((v26 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v26 + 60) & 0x40000) != 0)
        goto LABEL_40;
    }
    else if (__maskrune((char)v26, 0x40000uLL))
    {
LABEL_40:
      v37 = *((_DWORD *)this + 22);
LABEL_43:
      _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2469, "*** ERROR - check the _surfacePixelFormat case '%c%c%c%c'\n", v30, v33, v36, (char)v37);
      goto LABEL_44;
    }
    LOBYTE(v37) = 46;
    goto LABEL_43;
  }
  v23 = 4294967246;
LABEL_57:
  if (v45)
    free(v45);
  if (v44)
    free(v44);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v42 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_and_colormatch_CIF10_to_P3_vImage", (v42 - Current) * 1000.0);
  }
  IIOColorConverter::~IIOColorConverter((IIOColorConverter *)v60);
  CGColorSpaceRelease(space);
  CGColorSpaceRelease(v48);
  CGColorSpaceRelease(v47);
  CGColorSpaceRelease(v46);
  return v23;
}

void sub_1880511A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, CGColorSpaceRef a15, CGColorSpaceRef a16, CGColorSpaceRef a17, CGColorSpaceRef space)
{
  CGColorSpaceRelease(space);
  CGColorSpaceRelease(a17);
  CGColorSpaceRelease(a16);
  CGColorSpaceRelease(a15);
  _Unwind_Resume(a1);
}

vImage_Error IIOIOSurfaceWrapper_CIF10::convert_w30r_to_ARGB16F(IIOIOSurfaceWrapper_CIF10 *this, vImage_Buffer *src, vImage_Buffer *dest)
{
  vImage_Error v3;
  uint8_t permuteMap[4];

  *(_DWORD *)permuteMap = 197121;
  v3 = vImageConvert_XRGB2101010ToARGB16F(src, 1.0, dest, *((_DWORD *)this + 64), *((_DWORD *)this + 65), permuteMap, 0x810u);
  if ((_DWORD)v3)
    kdebug_trace();
  return v3;
}

uint64_t IIOIOSurfaceWrapper_CIF10::convert_b3a8_to_ARGB16F(IIOIOSurfaceWrapper_CIF10 *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Buffer *a4)
{
  uint64_t v5;
  uint8_t permuteMap[4];

  if (*((_QWORD *)this + 16) != 2)
    return 4294967246;
  *(_DWORD *)permuteMap = 197121;
  v5 = vImageConvert_XRGB2101010_A8ToARGB16F();
  if ((_DWORD)v5 || (v5 = vImagePermuteChannels_ARGB16U(a4, a4, permuteMap, 0x10u), (_DWORD)v5))
    kdebug_trace();
  return v5;
}

uint64_t IIOIOSurfaceWrapper_CIF10::copyImageBlockSet_8bit(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  int ColorMatchMode;
  char *BaseAddress;
  void *BaseAddressOfPlane;
  vImage_Buffer *v13;
  vImage_Buffer *v14;
  uint64_t v15;
  size_t v18;
  double v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  vImage_Buffer *v24;
  int v25;
  uint64_t result;
  _QWORD v27[4];
  vImage_Buffer v28;
  vImage_Buffer v29;
  __int128 v30;
  __int128 v31;
  CGRect v32;
  CGRect v33;

  v30 = xmmword_1E1BCA398;
  v31 = xmmword_1E1BCA388;
  ColorMatchMode = IIOIOSurfaceWrapper_CIF10::getColorMatchMode((IIOIOSurfaceWrapper_CIF10 *)a1, *(CGRect *)&a2);
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
    goto LABEL_23;
  BaseAddress = (char *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 1uLL);
  if (!BaseAddress)
  {
    _cg_jpeg_mem_term("copyImageBlockSet_8bit", 2590, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n");
LABEL_22:
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    goto LABEL_23;
  }
  v18 = *(_QWORD *)(a1 + 112);
  v19 = a2 * (double)*(unint64_t *)(a1 + 120);
  v20 = &BaseAddress[(unint64_t)v19 + (unint64_t)(a3 * (double)v18)];
  v21 = *(_QWORD *)(a1 + 240);
  if (BaseAddressOfPlane)
  {
    v19 = a2 * (double)*(unint64_t *)(a1 + 248);
    v22 = (unint64_t)BaseAddressOfPlane + (unint64_t)v19 + (unint64_t)(a3 * (double)v21);
  }
  else
  {
    v22 = 0;
  }
  v29.data = v20;
  v29.height = (unint64_t)a5;
  v29.width = (unint64_t)a4;
  v29.rowBytes = v18;
  v28.data = *(void **)(a1 + 168);
  v28.height = (unint64_t)a5;
  v23 = *(unsigned int *)(a1 + 184);
  v28.width = (unint64_t)a4;
  v28.rowBytes = v23;
  v27[0] = v22;
  v27[1] = (unint64_t)a5;
  v27[2] = (unint64_t)a4;
  v27[3] = v21;
  if (v22)
    v24 = (vImage_Buffer *)v27;
  else
    v24 = 0;
  if (*(_BYTE *)(a1 + 272))
  {
    v25 = IIOIOSurfaceWrapper_CIF10::copy_CIF10_8bit_sRGB((IIOIOSurfaceWrapper_CIF10 *)a1, &v29, v24, &v28);
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    if (!v25)
      goto LABEL_25;
LABEL_23:
    _ImageIO_Free(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176));
    result = 0;
    *(_QWORD *)(a1 + 168) = 0;
    return result;
  }
  if (ColorMatchMode == 2)
  {
    v33.origin.x = a2;
    v33.origin.y = a3;
    v33.size.width = a4;
    v33.size.height = a5;
    if (!IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_MSR((IIOIOSurfaceWrapper_CIF10 *)a1, v33, v13, v14, &v28))goto LABEL_24;
    *(_QWORD *)&v19 = _cg_jpeg_mem_term("copyImageBlockSet_8bit", 2622, "*** ERROR: copy_and_colormatch_CIF10_to_P3_MSR returned: %d\n").n128_u64[0];
  }
  else if (ColorMatchMode == 1 && !*(_BYTE *)(a1 + 267))
  {
    v32.origin.x = a2;
    v32.origin.y = a3;
    v32.size.width = a4;
    v32.size.height = a5;
    if (!IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_CA((IIOIOSurfaceWrapper_CIF10 *)a1, v32, v13, v14, &v28))goto LABEL_24;
    *(_QWORD *)&v19 = _cg_jpeg_mem_term("copyImageBlockSet_8bit", 2614, "*** ERROR: copy_and_colormatch_CIF10_to_P3_CA returned: %d\n").n128_u64[0];
  }
  if (IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_vImage((IIOIOSurfaceWrapper_CIF10 *)a1, *(CGRect *)(&v15 - 1), &v29, v24, &v28))
  {
    _cg_jpeg_mem_term("copyImageBlockSet_8bit", 2628, "*** ERROR: copy_and_colormatch_CIF10_to_P3_vImage returned: %d\n");
    goto LABEL_22;
  }
LABEL_24:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
LABEL_25:
  v29.data = (void *)CGImageBlockCreate();
  return CGImageBlockSetCreate();
}

uint64_t IIOIOSurfaceWrapper_CIF10::getColorMatchMode(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2)
{
  uint64_t v3;
  double height;
  double width;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  BOOL v9;

  v3 = *((unsigned int *)this + 67);
  if (!(_DWORD)v3
    || (_DWORD)v3 == 1
    && (height = a2.size.height, width = a2.size.width, v3 = 3, (IIOIsAppSuspended() & 1) == 0)
    && ((v6 = *((_QWORD *)this + 12), v7 = *((_QWORD *)this + 13), (v7 * v6) >> 7 >= 0xE1) ? (v3 = 1) : (v3 = 3),
        width == (double)v6 ? (v8 = height == (double)v7) : (v8 = 0),
        !v8))
  {
    if (gCanUseMSRForColorConversion)
      v9 = *((_DWORD *)this + 54) == 1;
    else
      v9 = 0;
    if (v9)
      return 2;
    else
      return 3;
  }
  return v3;
}

uint64_t IIOIOSurfaceWrapper_CIF10::copyImageBlockSet_16bit(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  int ColorMatchMode;
  int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  char *BaseAddress;
  void *BaseAddressOfPlane;
  vImage_Buffer *v18;
  vImage_Buffer *v19;
  uint64_t v20;
  size_t v23;
  double v24;
  char *v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t result;
  const char *v37;
  size_t v38;
  vImage_Buffer *v39;
  int v40;
  int v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD v52[4];
  vImage_Buffer v53;
  vImage_Buffer v54;
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  CGRect v58;

  v56 = xmmword_1E1BCA398;
  v57 = xmmword_1E1BCA388;
  v55 = 0;
  ColorMatchMode = IIOIOSurfaceWrapper_CIF10::getColorMatchMode((IIOIOSurfaceWrapper_CIF10 *)a1, *(CGRect *)&a2);
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
  {
LABEL_2:
    v11 = -50;
    goto LABEL_3;
  }
  BaseAddress = (char *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 1uLL);
  if (!BaseAddress)
  {
    if (*(_BYTE *)(a1 + 140))
      v37 = "YES";
    else
      v37 = "NO";
    _cg_jpeg_mem_term("copyImageBlockSet_16bit", 2679, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n", v37);
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    goto LABEL_2;
  }
  v23 = *(_QWORD *)(a1 + 112);
  v24 = a2 * (double)*(unint64_t *)(a1 + 120);
  v25 = &BaseAddress[(unint64_t)v24 + (unint64_t)(a3 * (double)v23)];
  v26 = *(_QWORD *)(a1 + 240);
  if (BaseAddressOfPlane)
  {
    v24 = a2 * (double)*(unint64_t *)(a1 + 248);
    v27 = (unint64_t)BaseAddressOfPlane + (unint64_t)v24 + (unint64_t)(a3 * (double)v26);
  }
  else
  {
    v27 = 0;
  }
  v54.data = v25;
  v54.height = (unint64_t)a5;
  v54.width = (unint64_t)a4;
  v54.rowBytes = v23;
  v53.data = *(void **)(a1 + 168);
  v53.height = (unint64_t)a5;
  v38 = *(unsigned int *)(a1 + 184);
  v53.width = (unint64_t)a4;
  v53.rowBytes = v38;
  v52[0] = v27;
  v52[1] = (unint64_t)a5;
  v52[2] = (unint64_t)a4;
  v52[3] = v26;
  if (v27)
    v39 = (vImage_Buffer *)v52;
  else
    v39 = 0;
  v40 = *(_DWORD *)(a1 + 88);
  if (v40 != 1999843442 && v40 != 1647534392)
  {
    v42 = v40 >> 24;
    if (v40 < 0)
    {
      v43 = __maskrune(v42, 0x40000uLL);
      v40 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v43 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v42 + 60) & 0x40000;
    }
    if (v43)
      v44 = (v40 >> 24);
    else
      v44 = 46;
    v45 = v40 << 8 >> 24;
    if (v40 << 8 < 0)
    {
      v46 = __maskrune(v45, 0x40000uLL);
      v40 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v46 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v45 + 60) & 0x40000;
    }
    if (v46)
      v47 = (v40 << 8 >> 24);
    else
      v47 = 46;
    v48 = (__int16)v40 >> 8;
    if (v40 << 16 < 0)
    {
      v49 = __maskrune(v48, 0x40000uLL);
      v40 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      v49 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v48 + 60) & 0x40000;
    }
    if (v49)
      v50 = ((__int16)v40 >> 8);
    else
      v50 = 46;
    if ((v40 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v40 + 60) & 0x40000) != 0)
        goto LABEL_70;
    }
    else if (__maskrune((char)v40, 0x40000uLL))
    {
LABEL_70:
      v51 = *(char *)(a1 + 88);
LABEL_73:
      LogError("copyImageBlockSet_16bit", 2715, "*** pixelFormat '%c%c%c%c' not supported\n", v44, v47, v50, v51);
      v11 = -4;
      goto LABEL_74;
    }
    v51 = 46;
    goto LABEL_73;
  }
  if (*(_DWORD *)(a1 + 216) == 5)
  {
    v41 = IIOIOSurfaceWrapper_CIF10::copy_to_CIF10_FP16_xsRGB((IIOIOSurfaceWrapper_CIF10 *)a1, &v54, v19, &v53);
    if (v41)
    {
      v11 = v41;
      _cg_jpeg_mem_term("copyImageBlockSet_16bit", 2701, "*** ERROR: copy_to_CIF10_FP16_xsRGB returned: %d\n", v41);
LABEL_74:
      IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
LABEL_3:
      kdebug_trace();
      v12 = *(_DWORD *)(a1 + 88);
      v13 = v12 >> 24;
      v14 = MEMORY[0x1E0C80978];
      if (v12 < 0)
      {
        v15 = __maskrune(v13, 0x40000uLL);
        v12 = *(_DWORD *)(a1 + 88);
      }
      else
      {
        v15 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v13 + 60) & 0x40000;
      }
      if (v15)
        v28 = (v12 >> 24);
      else
        v28 = 46;
      v29 = v12 << 8 >> 24;
      if (v12 << 8 < 0)
      {
        v30 = __maskrune(v29, 0x40000uLL);
        v12 = *(_DWORD *)(a1 + 88);
      }
      else
      {
        v30 = *(_DWORD *)(v14 + 4 * v29 + 60) & 0x40000;
      }
      if (v30)
        v31 = (v12 << 8 >> 24);
      else
        v31 = 46;
      v32 = (__int16)v12 >> 8;
      if (v12 << 16 < 0)
      {
        v33 = __maskrune(v32, 0x40000uLL);
        v12 = *(_DWORD *)(a1 + 88);
      }
      else
      {
        v33 = *(_DWORD *)(v14 + 4 * v32 + 60) & 0x40000;
      }
      if (v33)
        v34 = ((__int16)v12 >> 8);
      else
        v34 = 46;
      if ((v12 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v14 + 4 * (char)v12 + 60) & 0x40000) != 0)
          goto LABEL_26;
      }
      else if (__maskrune((char)v12, 0x40000uLL))
      {
LABEL_26:
        v35 = *(char *)(a1 + 88);
LABEL_29:
        LogError("copyImageBlockSet_16bit", 2735, "*** copyImageBlockSet_16bit '%c%c%c%c' failed: err=%d\n", v28, v31, v34, v35, v11);
        _ImageIO_Free(*(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 176));
        result = 0;
        *(_QWORD *)(a1 + 168) = 0;
        return result;
      }
      v35 = 46;
      goto LABEL_29;
    }
    goto LABEL_50;
  }
  if (ColorMatchMode == 1 && !*(_BYTE *)(a1 + 267))
  {
    v58.origin.x = a2;
    v58.origin.y = a3;
    v58.size.width = a4;
    v58.size.height = a5;
    if (!IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_CA((IIOIOSurfaceWrapper_CIF10 *)a1, v58, v18, v19, &v53))
    {
LABEL_50:
      IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
      goto LABEL_51;
    }
  }
  v11 = IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_vImage((IIOIOSurfaceWrapper_CIF10 *)a1, *(CGRect *)(&v20 - 1), &v54, v39, &v53);
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  if (v11)
    goto LABEL_3;
LABEL_51:
  v55 = CGImageBlockCreate();
  return CGImageBlockSetCreate();
}

uint64_t IIOIOSurfaceWrapper_CIF10::copyImageBlockSetWithOptions8Bit(uint64_t *a1, uint64_t a2, uint64_t a3, _QWORD *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  pthread_mutex_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v20 = (pthread_mutex_t *)(a1 + 1);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, double, double, double, double, double, double))(*a1 + 40))(a1, 8, a3, a5, a6, a7, a8, a9, a10);
  v22 = *a1;
  if ((_DWORD)v21)
  {
    (*(void (**)(uint64_t *))(v22 + 48))(a1);
    _cg_jpeg_mem_term("copyImageBlockSetWithOptions8Bit", 2979, "*** ERROR: copyImageBlockSetWithOptions8Bit err = %d\n", v21);
    v23 = 0;
  }
  else
  {
    v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, double, double, double, double, double, double))(v22 + 24))(a1, a2, a3, a5, a6, a7, a8, a9, a10);
    (*(void (**)(uint64_t *))(*a1 + 48))(a1);
  }
  *a4 = (*(uint64_t (**)(uint64_t *, uint64_t, double, double, double, double))(*a1 + 64))(a1, v21, a5, a6, a7, a8);
  pthread_mutex_unlock(v20);
  return v23;
}

uint64_t IIOIOSurfaceWrapper_CIF10::copyImageBlockSetWithOptions16Bit(uint64_t *a1, uint64_t a2, uint64_t a3, _QWORD *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  pthread_mutex_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v20 = (pthread_mutex_t *)(a1 + 1);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  v21 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, double, double, double, double, double, double))(*a1 + 40))(a1, 16, a3, a5, a6, a7, a8, a9, a10);
  v22 = *a1;
  if ((_DWORD)v21)
  {
    (*(void (**)(uint64_t *))(v22 + 48))(a1);
    _cg_jpeg_mem_term("copyImageBlockSetWithOptions16Bit", 3014, "*** ERROR: copyImageBlockSetWithOptions16Bit err = %d\n", v21);
    v23 = 0;
  }
  else
  {
    v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, double, double, double, double, double, double))(v22 + 32))(a1, a2, a3, a5, a6, a7, a8, a9, a10);
    (*(void (**)(uint64_t *))(*a1 + 48))(a1);
  }
  *a4 = (*(uint64_t (**)(uint64_t *, uint64_t, double, double, double, double))(*a1 + 64))(a1, v21, a5, a6, a7, a8);
  pthread_mutex_unlock(v20);
  return v23;
}

uint64_t IIOIOSurfaceWrapper_CIF10::preCopyBlockSet(IIOIOSurfaceWrapper_CIF10 *this, unsigned int a2, CGRect a3, CGSize a4, IIODictionary *a5)
{
  double height;
  double width;
  int v9;
  unsigned int v10;
  unsigned int v11;

  height = a3.size.height;
  width = a3.size.width;
  IIOIOSurfaceWrapperBase::preCopyBlockSet(this, a2, a3, a4, a5);
  v9 = IIO_CGImageBlockSetBytesPerPixelForPixelFormat(*((_DWORD *)this + 22));
  v10 = (a2 + 7) >> 3;
  if (a2 <= 8)
    v10 = 1;
  v11 = IIOAlignRowBytes((unint64_t)(width * (double)(v9 * v10)), 0);
  *((_DWORD *)this + 46) = v11;
  if (is_mul_ok((unint64_t)height, v11))
    *((_QWORD *)this + 21) = _ImageIO_Malloc((unint64_t)height * v11, 64, (size_t *)this + 22, (uint64_t)kImageMalloc_IOSurface_Data, 0, 0, 0);
  return 0;
}

unint64_t IIOIOSurfaceWrapper_CIF10::packDebugInfo(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2, uint64_t a3)
{
  unint64_t result;

  result = IIOIOSurfaceWrapperBase::packDebugInfo(this, a2, a3);
  if (*((_BYTE *)this + 200))
    result |= 0x1000uLL;
  return result;
}

void IIOIOSurfaceWrapper_YCC::IIOIOSurfaceWrapper_YCC(IIOIOSurfaceWrapper_YCC *this, __IOSurface *a2, size_t a3, size_t a4, int a5, CGImageAlphaInfo a6, IIODictionary *a7)
{
  _QWORD *v9;
  void (**v10)(IIOIOSurfaceWrapper_YCC *__hidden);

  IIOIOSurfaceWrapperBase::IIOIOSurfaceWrapperBase(this, a2, a3, a4, a5, a6, a7);
  *v9 = &off_1E1B81578;
  if (v9[16] < 2uLL)
  {
    *((_OWORD *)this + 14) = 0u;
    *((_OWORD *)this + 15) = 0u;
    v10 = &off_1E1B81578;
  }
  else
  {
    *((_QWORD *)this + 28) = IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((_QWORD *)this + 29) = IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((_QWORD *)this + 30) = IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((_QWORD *)this + 31) = IOSurfaceGetBytesPerElementOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    v10 = *(void (***)(IIOIOSurfaceWrapper_YCC *__hidden))this;
  }
  ((void (*)(IIOIOSurfaceWrapper_YCC *, IIODictionary *, _QWORD))v10[7])(this, a7, 0);
}

void sub_188052098(_Unwind_Exception *a1)
{
  IIOIOSurfaceWrapperBase *v1;

  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(v1);
  _Unwind_Resume(a1);
}

void IIOIOSurfaceWrapper_YCC::~IIOIOSurfaceWrapper_YCC(IIOIOSurfaceWrapper_YCC *this)
{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(this);
  JUMPOUT(0x18D761C30);
}

void IIOIOSurfaceWrapper_YCC::completeSetup(IIOIOSurfaceWrapper_YCC *this, IIODictionary *a2, const __CFString *a3)
{
  int v5;
  const __CFString *v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  int v12;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;

  v5 = *((_DWORD *)this + 22);
  if (v5 > 2016687155)
  {
    if (v5 <= 2019963441)
    {
      if (v5 != 2016687156 && v5 != 2019963440)
        goto LABEL_12;
LABEL_21:
      *((_DWORD *)this + 54) = 6;
      v7 = (const __CFString *)*MEMORY[0x1E0C9D960];
      *((_DWORD *)this + 41) = 0;
      goto LABEL_22;
    }
    v11 = v5 == 2019963442;
    v12 = 2019963956;
LABEL_16:
    if (!v11 && v5 != v12)
    {
LABEL_12:
      v8 = v5 >> 24;
      v9 = MEMORY[0x1E0C80978];
      if (v5 < 0)
      {
        v10 = __maskrune(v8, 0x40000uLL);
        v5 = *((_DWORD *)this + 22);
      }
      else
      {
        v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x40000;
      }
      if (v10)
        v14 = (v5 >> 24);
      else
        v14 = 46;
      v15 = v5 << 8 >> 24;
      if (v5 << 8 < 0)
      {
        v16 = __maskrune(v15, 0x40000uLL);
        v5 = *((_DWORD *)this + 22);
      }
      else
      {
        v16 = *(_DWORD *)(v9 + 4 * v15 + 60) & 0x40000;
      }
      if (v16)
        v17 = (v5 << 8 >> 24);
      else
        v17 = 46;
      v18 = (__int16)v5 >> 8;
      if (v5 << 16 < 0)
      {
        v19 = __maskrune(v18, 0x40000uLL);
        v5 = *((_DWORD *)this + 22);
      }
      else
      {
        v19 = *(_DWORD *)(v9 + 4 * v18 + 60) & 0x40000;
      }
      if (v19)
        v20 = ((__int16)v5 >> 8);
      else
        v20 = 46;
      if ((v5 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v9 + 4 * (char)v5 + 60) & 0x40000) != 0)
          goto LABEL_41;
      }
      else if (__maskrune((char)v5, 0x40000uLL))
      {
LABEL_41:
        v21 = *((char *)this + 88);
LABEL_44:
        LogError("completeSetup", 3084, "*** pixelformat '%c%c%c%c' not handled\n", v14, v17, v20, v21);
        v7 = 0;
        goto LABEL_22;
      }
      v21 = 46;
      goto LABEL_44;
    }
    goto LABEL_21;
  }
  if (v5 > 2016686639)
  {
    v11 = v5 == 2016686640;
    v12 = 2016686642;
    goto LABEL_16;
  }
  if (v5 != 875704422 && v5 != 875704438)
    goto LABEL_12;
  *((_DWORD *)this + 54) = 1;
  v7 = (const __CFString *)*MEMORY[0x1E0C9DA10];
  *((_DWORD *)this + 41) = 5;
LABEL_22:
  IIOIOSurfaceWrapperBase::completeSetup(this, a2, v7);
}

uint64_t IIOIOSurfaceWrapper_YCC::createImage(IIOIOSurfaceWrapper_YCC *this)
{
  int v2;
  BOOL v3;
  int v4;
  unsigned __int16 v5;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *((_DWORD *)this + 22);
  if (v2 > 2016687155)
  {
    if (v2 > 2019963441)
    {
      v3 = v2 == 2019963956;
      v5 = 12850;
    }
    else
    {
      v3 = v2 == 2016687156;
      v5 = 12848;
    }
    v4 = v5 | 0x78660000;
  }
  else if (v2 > 2016686639)
  {
    v3 = v2 == 2016686640;
    v4 = 2016686642;
  }
  else
  {
    v3 = v2 == 875704422;
    v4 = 875704438;
  }
  if (v3 || v2 == v4)
    return IIOIOSurfaceWrapper_YCC::createImageWithImageProvider(this);
  v8 = v2 >> 24;
  v9 = MEMORY[0x1E0C80978];
  if (v2 < 0)
  {
    v10 = __maskrune(v8, 0x40000uLL);
    v2 = *((_DWORD *)this + 22);
  }
  else
  {
    v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x40000;
  }
  if (v10)
    v11 = (v2 >> 24);
  else
    v11 = 46;
  v12 = v2 << 8 >> 24;
  if (v2 << 8 < 0)
  {
    v13 = __maskrune(v12, 0x40000uLL);
    v2 = *((_DWORD *)this + 22);
  }
  else
  {
    v13 = *(_DWORD *)(v9 + 4 * v12 + 60) & 0x40000;
  }
  if (v13)
    v14 = (v2 << 8 >> 24);
  else
    v14 = 46;
  v15 = (__int16)v2 >> 8;
  if (v2 << 16 < 0)
  {
    v16 = __maskrune(v15, 0x40000uLL);
    v2 = *((_DWORD *)this + 22);
  }
  else
  {
    v16 = *(_DWORD *)(v9 + 4 * v15 + 60) & 0x40000;
  }
  if (v16)
    v17 = ((__int16)v2 >> 8);
  else
    v17 = 46;
  if ((v2 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v9 + 4 * (char)v2 + 60) & 0x40000) != 0)
      goto LABEL_35;
LABEL_37:
    v18 = 46;
    goto LABEL_38;
  }
  if (!__maskrune((char)v2, 0x40000uLL))
    goto LABEL_37;
LABEL_35:
  v18 = *((char *)this + 88);
LABEL_38:
  _cg_jpeg_mem_term("createImage", 3112, "    CGImageCreateFromIOSurface -- unsupported pixelformat: '%c%c%c%c'\n", v11, v14, v17, v18);
  return 0;
}

uint64_t IIOIOSurfaceWrapper_YCC::createImageWithImageProvider(IIOIOSurfaceWrapper_YCC *this)
{
  void *v2;
  unsigned int v3;
  const void **v4;
  const __CFString **v5;
  CGColorSpace *v6;
  CGColorSpaceRef v7;
  CGColorSpace *v8;
  uint64_t v9;
  _QWORD v11[3];
  _QWORD v12[7];

  v2 = IIOIOSurfaceWrapper_YCC::CopyImageBlockSetWithOptions;
  if (*((_BYTE *)this + 140))
    v2 = IIOIOSurfaceWrapperBase::CopyImageBlockSetWithOptionsNoOp;
  v12[4] = v2;
  v12[3] = 2;
  v12[5] = IIOIOSurfaceWrapperBase::CopyIOSurface;
  v12[6] = IIOIOSurfaceWrapperBase::ReleaseInfo;
  memset(v12, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v12);
  v3 = *((_DWORD *)this + 41);
  v4 = (const void **)MEMORY[0x1E0C9AE50];
  if (v3 <= 6)
  {
    if (((1 << v3) & 6) != 0)
    {
      IIODictionary::setObjectForKey((IIODictionary *)v12, (const void *)*MEMORY[0x1E0C9AE50], (const __CFString *)*MEMORY[0x1E0C9DAF0]);
    }
    else if (((1 << v3) & 0x18) == 0)
    {
      if (((1 << v3) & 0x60) == 0)
        goto LABEL_11;
      v5 = (const __CFString **)MEMORY[0x1E0C9DAE8];
      goto LABEL_10;
    }
    v5 = (const __CFString **)MEMORY[0x1E0C9DAE0];
LABEL_10:
    IIODictionary::setObjectForKey((IIODictionary *)v12, *v4, *v5);
  }
LABEL_11:
  v6 = (CGColorSpace *)*((_QWORD *)this + 10);
  v7 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  v8 = v7;
  if (!v6)
    v6 = v7;
  if (CGImageProviderCreate())
  {
    CGImageProviderSetProperty();
    memset(v11, 0, sizeof(v11));
    IIONumber::IIONumber((IIONumber *)v11, *((_DWORD *)this + 22));
    CGImageProviderSetProperty();
    v9 = CGImageCreateWithImageProvider();
    CGImageProviderRelease();
    if (!*((_QWORD *)this + 10))
      IIO_IOSurfaceAddColorSpace(*((__IOSurface **)this + 9), v6);
    IIONumber::~IIONumber((IIONumber *)v11);
  }
  else
  {
    v9 = 0;
  }
  CGColorSpaceRelease(v8);
  IIODictionary::~IIODictionary((IIODictionary *)v12);
  return v9;
}

void sub_1880526C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  CGColorSpace *v12;

  CGColorSpaceRelease(v12);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper_YCC::CopyImageBlockSetWithOptions(uint64_t a1, uint64_t a2, __CFDictionary *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  double v36;
  double v37;
  double v38;
  uint64_t v40;
  _QWORD v41[4];

  memset(v41, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v41, a3);
  v18 = *(int *)(a1 + 216);
  IIOPackCopyCallbackInfo(a3);
  CGImageProviderGetBitmapInfo();
  kdebug_trace();
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    v20 = *(_DWORD *)(a1 + 88);
    v21 = v20 >> 24;
    v22 = MEMORY[0x1E0C80978];
    if (v20 < 0)
      v23 = __maskrune(v20 >> 24, 0x40000uLL);
    else
      v23 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v21 + 60) & 0x40000;
    if (v23)
      v24 = v21;
    else
      v24 = 46;
    v25 = v20 << 8 >> 24;
    if (v20 << 8 < 0)
      v26 = __maskrune(v20 << 8 >> 24, 0x40000uLL);
    else
      v26 = *(_DWORD *)(v22 + 4 * v25 + 60) & 0x40000;
    if (v26)
      v27 = v25;
    else
      v27 = 46;
    v28 = (__int16)v20 >> 8;
    if (v20 << 16 < 0)
      v29 = __maskrune((__int16)v20 >> 8, 0x40000uLL);
    else
      v29 = *(_DWORD *)(v22 + 4 * v28 + 60) & 0x40000;
    if ((v20 << 24) <= 0x7F000000)
      v30 = *(_DWORD *)(v22 + 4 * (char)v20 + 60) & 0x40000;
    else
      v30 = __maskrune((char)v20, 0x40000uLL);
    if (v29)
      v31 = v28;
    else
      v31 = 46;
    if (v30)
      v32 = (char)v20;
    else
      v32 = 46;
    ImageIOLog("S   CopyImageBlockSetWithOptions_YCC: {%g, %g, %g, %g} {%g, %g} '%c%c%c%c' %s\n", a4, a5, a6, a7, a8, a9, v24, v27, v31, v32, off_1E1BCA3A8[v18]);
  }
  v40 = 0;
  if (*(_BYTE *)(a1 + 141))
  {
    v33 = IIOIOSurfaceWrapperBase::createBlockSetForCompressedSurface(a1, a4, a5, a6, a7, a2, v19, &v40);
  }
  else
  {
    v35 = (double)*(unint64_t *)(a1 + 96);
    v36 = (double)*(unint64_t *)(a1 + 104);
    v37 = *MEMORY[0x1E0C9D538];
    v38 = *(double *)(MEMORY[0x1E0C9D538] + 8);
    if ((_DWORD)v18 == 6)
    {
      v33 = IIOIOSurfaceWrapper_YCC::copyImageBlockSetWithOptions10Bit(a1, v37, v38, v35, v36, a2, v19, &v40);
    }
    else
    {
      if ((_DWORD)v18 != 1)
      {
        LogError("CopyImageBlockSetWithOptions", 3553, "*** unsupported componentType '%s' (%d)\n", (&gComponentString)[v18], v18);
        goto LABEL_36;
      }
      v33 = IIOIOSurfaceWrapper_YCC::copyImageBlockSetWithOptions8Bit(a1, v37, v38, v35, v36, a2, (IIODictionary *)v41, &v40);
    }
  }
  v34 = v33;
  if (!v33)
  {
LABEL_36:
    _cg_jpeg_mem_term("CopyImageBlockSetWithOptions", 3563, "*** ERROR: CopyImageBlockSetWithOptions returned NULL\n");
    v34 = 0;
    goto LABEL_37;
  }
  CGImageBlockSetGetRect();
LABEL_37:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v41);
  return v34;
}

void sub_188052A0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  unint64_t v7;
  unint64_t v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  void *BaseAddressOfPlane;
  void *v13;
  void *v14;
  OSType PixelFormat;
  const vImage_YpCbCrToARGB *v16;
  const vImage_YpCbCrToARGB *v17;
  int *v18;
  vImage_Error v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  vImage_Buffer dest;
  vImage_Buffer srcCbCr;
  vImage_Buffer srcYp;
  int v37;
  __int128 v38;
  __int128 v39;
  int v40;
  int v41;
  size_t v42;
  uint64_t v43;

  v43 = 0;
  v7 = (unint64_t)a5;
  v41 = 197121;
  v40 = 66051;
  v39 = xmmword_1E1BCA388;
  v38 = xmmword_1E1BCA398;
  v8 = IIOAlignRowBytes(vcvtd_n_u64_f64(a4, 2uLL), 0);
  if (!is_mul_ok(v7, v8))
    return 0;
  v9 = v8;
  v42 = 0;
  v10 = (void *)_ImageIO_Malloc(v7 * v8, 64, &v42, (uint64_t)kImageMalloc_IOSurface_Data, 0, 0, 0);
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
  {
    v11 = 0;
    if (!v10)
      return v11;
    goto LABEL_41;
  }
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 0);
  v13 = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 1uLL);
  v11 = 0;
  if (BaseAddressOfPlane)
  {
    v14 = v13;
    if (v13)
    {
      v37 = 0;
      IOSurfaceGetYCbCrMatrix();
      PixelFormat = IOSurfaceGetPixelFormat(*(IOSurfaceRef *)(a1 + 72));
      v16 = (const vImage_YpCbCrToARGB *)&IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv601v;
      if (PixelFormat != 875704438)
        v16 = (const vImage_YpCbCrToARGB *)&IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv601f;
      *(int8x16_t *)&srcYp.height = vextq_s8(*(int8x16_t *)(a1 + 96), *(int8x16_t *)(a1 + 96), 8uLL);
      srcYp.rowBytes = *(_QWORD *)(a1 + 112);
      dest.rowBytes = v9;
      srcCbCr.data = v14;
      *(int8x16_t *)&srcCbCr.height = vextq_s8(*(int8x16_t *)(a1 + 224), *(int8x16_t *)(a1 + 224), 8uLL);
      srcCbCr.rowBytes = *(_QWORD *)(a1 + 240);
      srcYp.data = BaseAddressOfPlane;
      dest.height = v7;
      dest.width = (unint64_t)a4;
      v17 = v16;
      dest.data = v10;
      ERROR_ImageIO_DataBufferIsNotReadable((unsigned __int8 *)BaseAddressOfPlane);
      ERROR_ImageIO_DataBufferIsNotReadable((unsigned __int8 *)v14);
      if (IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::YpCbCrToARGBCreate != -1)
        dispatch_once(&IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::YpCbCrToARGBCreate, &__block_literal_global_37);
      if (*(_BYTE *)(a1 + 200))
        v18 = &v40;
      else
        v18 = &v41;
      v19 = vImageConvert_420Yp8_CbCr8ToARGB8888(&srcYp, &srcCbCr, &dest, v17, (const uint8_t *)v18, 0xFFu, 0);
      if (!v19)
      {
        v43 = CGImageBlockCreate();
        v11 = CGImageBlockSetCreate();
        v10 = 0;
        goto LABEL_40;
      }
      v20 = v19;
      kdebug_trace();
      v21 = *(_DWORD *)(a1 + 88);
      v22 = v21 >> 24;
      v23 = MEMORY[0x1E0C80978];
      if (v21 < 0)
      {
        v24 = __maskrune(v22, 0x40000uLL);
        v21 = *(_DWORD *)(a1 + 88);
      }
      else
      {
        v24 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v22 + 60) & 0x40000;
      }
      if (v24)
        v25 = (v21 >> 24);
      else
        v25 = 46;
      v26 = v21 << 8 >> 24;
      if (v21 << 8 < 0)
      {
        v27 = __maskrune(v26, 0x40000uLL);
        v21 = *(_DWORD *)(a1 + 88);
      }
      else
      {
        v27 = *(_DWORD *)(v23 + 4 * v26 + 60) & 0x40000;
      }
      if (v27)
        v28 = (v21 << 8 >> 24);
      else
        v28 = 46;
      v29 = (__int16)v21 >> 8;
      if (v21 << 16 < 0)
      {
        v30 = __maskrune(v29, 0x40000uLL);
        v21 = *(_DWORD *)(a1 + 88);
      }
      else
      {
        v30 = *(_DWORD *)(v23 + 4 * v29 + 60) & 0x40000;
      }
      if (v30)
        v31 = ((__int16)v21 >> 8);
      else
        v31 = 46;
      if ((v21 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v23 + 4 * (char)v21 + 60) & 0x40000) != 0)
          goto LABEL_36;
      }
      else if (__maskrune((char)v21, 0x40000uLL))
      {
LABEL_36:
        v32 = *(char *)(a1 + 88);
LABEL_39:
        LogError("copyImageBlockSet_420f_8bit", 3325, "*** copyImageBlockSet_420f_8bit '%c%c%c%c' failed: err=%d\n", v25, v28, v31, v32, v20);
        v11 = 0;
        goto LABEL_40;
      }
      v32 = 46;
      goto LABEL_39;
    }
  }
LABEL_40:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  if (v10)
LABEL_41:
    _ImageIO_Free((unint64_t)v10, v42);
  return v11;
}

void ___ZN23IIOIOSurfaceWrapper_YCC27copyImageBlockSet_420f_8bitEP15CGImageProvider6CGRect6CGSizeP13IIODictionary_block_invoke()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  vImage_YpCbCrToARGB **v3;
  vImage_Error Conversion;
  vImage_Error v5;
  const char *v6;
  __int128 v7;
  int v8;
  _OWORD v9[2];
  _OWORD v10[2];
  _OWORD *v11;
  uint64_t v12;
  _QWORD v13[17];

  v0 = 0;
  v13[16] = *MEMORY[0x1E0C80C00];
  v10[0] = xmmword_18822D620;
  v10[1] = unk_18822D630;
  v9[0] = xmmword_18822D640;
  v9[1] = unk_18822D650;
  v1 = *MEMORY[0x1E0C8BDA8];
  v2 = *MEMORY[0x1E0C8BDB0];
  v8 = 1072746935;
  v7 = xmmword_18822D660;
  v11 = v9;
  v12 = v1;
  v3 = (vImage_YpCbCrToARGB **)v13;
  v13[0] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv601f;
  v13[1] = v10;
  v13[2] = v1;
  v13[3] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv601v;
  v13[4] = v9;
  v13[5] = v2;
  v13[6] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv709f;
  v13[7] = v10;
  v13[8] = v2;
  v13[9] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv709v;
  v13[10] = v9;
  v13[11] = &v7;
  v13[12] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv2020f;
  v13[13] = v10;
  v13[14] = &v7;
  v13[15] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv2020v;
  do
  {
    Conversion = vImageConvert_YpCbCrToARGB_GenerateConversion((const vImage_YpCbCrToARGBMatrix *)*(v3 - 1), (const vImage_YpCbCrPixelRange *)*(v3 - 2), *v3, kvImage420Yp8_CbCr8, kvImageARGB8888, 0);
    if (Conversion)
    {
      v5 = Conversion;
      v6 = IIO_vImageErrorString(Conversion);
      _cg_jpeg_mem_term("copyImageBlockSet_420f_8bit_block_invoke", 3302, "*** ERROR: vImageConvert_YpCbCrToARGB_GenerateConversion[%d] returned %ld (%s)\n", v0, v5, v6);
    }
    ++v0;
    v3 += 3;
  }
  while (v0 != 6);
}

uint64_t IIOIOSurfaceWrapper_YCC::copyImageBlockSet_xf20_10bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  uint64_t v11;
  unsigned __int16 *BaseAddressOfPlane;
  unsigned __int16 *v13;
  _BOOL4 v14;
  __int16 *XF20toRGB16fConversionInfo;
  uint64_t v16;
  int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t *v31[4];
  unsigned __int16 *v32;
  int8x16_t v33;
  uint64_t v34;
  unsigned __int16 *v35;
  int8x16_t v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  size_t v40;
  uint64_t v41;

  v41 = 0;
  v7 = (unint64_t)a5;
  v39 = xmmword_1E1BCA388;
  v38 = xmmword_1E1BCA398;
  v8 = IIOAlignRowBytes(4 * *(_QWORD *)(a1 + 96), 0);
  if (!is_mul_ok(v7, v8))
    return 0;
  v9 = (unint64_t *)v8;
  v40 = 0;
  v10 = (unint64_t *)_ImageIO_Malloc(v7 * v8, 64, &v40, (uint64_t)kImageMalloc_ATX_Data[0], 0, 0, 0);
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
  {
    v11 = 0;
    if (!v10)
      return v11;
    goto LABEL_32;
  }
  BaseAddressOfPlane = (unsigned __int16 *)IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 0);
  v13 = (unsigned __int16 *)IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 1uLL);
  v36 = vextq_s8(*(int8x16_t *)(a1 + 96), *(int8x16_t *)(a1 + 96), 8uLL);
  v37 = *(_QWORD *)(a1 + 112);
  v31[3] = v9;
  v32 = v13;
  v33 = vextq_s8(*(int8x16_t *)(a1 + 224), *(int8x16_t *)(a1 + 224), 8uLL);
  v34 = *(_QWORD *)(a1 + 240);
  v35 = BaseAddressOfPlane;
  v31[1] = (unint64_t *)v7;
  v31[2] = (unint64_t *)a4;
  v31[0] = v10;
  IOSurfaceGetYCbCrMatrix();
  v14 = IOSurfaceGetRangeOfComponentOfPlane(*(IOSurfaceRef *)(a1 + 72), 0, 0) == kIOSurfaceComponentRangeVideoRange;
  XF20toRGB16fConversionInfo = (__int16 *)GetXF20toRGB16fConversionInfo(0, v14);
  v16 = ConvertXF20toRGBA1010102(&v35, &v32, v31, XF20toRGB16fConversionInfo);
  if (!v16)
  {
    v41 = CGImageBlockCreate();
    v11 = CGImageBlockSetCreate();
    v10 = 0;
    goto LABEL_31;
  }
  v17 = v16;
  kdebug_trace();
  v18 = *(_DWORD *)(a1 + 88);
  v19 = v18 >> 24;
  v20 = MEMORY[0x1E0C80978];
  if (v18 < 0)
  {
    v21 = __maskrune(v19, 0x40000uLL);
    v18 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v21 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v19 + 60) & 0x40000;
  }
  if (v21)
    v22 = (v18 >> 24);
  else
    v22 = 46;
  v23 = v18 << 8 >> 24;
  if (v18 << 8 < 0)
  {
    v24 = __maskrune(v23, 0x40000uLL);
    v18 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v24 = *(_DWORD *)(v20 + 4 * v23 + 60) & 0x40000;
  }
  if (v24)
    v25 = (v18 << 8 >> 24);
  else
    v25 = 46;
  v26 = (__int16)v18 >> 8;
  if (v18 << 16 < 0)
  {
    v27 = __maskrune(v26, 0x40000uLL);
    v18 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    v27 = *(_DWORD *)(v20 + 4 * v26 + 60) & 0x40000;
  }
  if (v27)
    v28 = ((__int16)v18 >> 8);
  else
    v28 = 46;
  if ((v18 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v20 + 4 * (char)v18 + 60) & 0x40000) != 0)
      goto LABEL_27;
LABEL_29:
    v29 = 46;
    goto LABEL_30;
  }
  if (!__maskrune((char)v18, 0x40000uLL))
    goto LABEL_29;
LABEL_27:
  v29 = *(char *)(a1 + 88);
LABEL_30:
  LogError("copyImageBlockSet_xf20_10bit", 3407, "*** copyImageBlockSet_xf20_10bit '%c%c%c%c' failed: err=%d\n", v22, v25, v28, v29, v17);
  v11 = 0;
LABEL_31:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  if (v10)
LABEL_32:
    _ImageIO_Free((unint64_t)v10, v40);
  return v11;
}

uint64_t IIOIOSurfaceWrapper_YCC::copyImageBlockSetWithOptions8Bit(uint64_t a1, double a2, double d1_0, double d2_0, double a5, uint64_t a6, IIODictionary *a7, _QWORD *a8)
{
  pthread_mutex_t *v15;
  uint64_t v16;
  CGSize v18;
  CGRect v19;

  v15 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  IIOIOSurfaceWrapperBase::preCopyBlockSet((IIOIOSurfaceWrapperBase *)a1, 8, v19, v18, a7);
  v16 = IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(a1, a2, d1_0, d2_0, a5);
  *a8 = (*(uint64_t (**)(uint64_t, _QWORD, double, double, double, double))(*(_QWORD *)a1 + 64))(a1, 0, a2, d1_0, d2_0, a5);
  pthread_mutex_unlock(v15);
  return v16;
}

uint64_t IIOIOSurfaceWrapper_YCC::copyImageBlockSetWithOptions10Bit(uint64_t a1, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, _QWORD *a8)
{
  pthread_mutex_t *v14;
  uint64_t v15;

  v14 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  *(_BYTE *)(a1 + 200) = 0;
  v15 = IIOIOSurfaceWrapper_YCC::copyImageBlockSet_xf20_10bit(a1, a2, a3, a4, a5);
  *a8 = (*(uint64_t (**)(uint64_t, _QWORD, double, double, double, double))(*(_QWORD *)a1 + 64))(a1, 0, a2, a3, a4, a5);
  pthread_mutex_unlock(v14);
  return v15;
}

unint64_t IIOIOSurfaceWrapper_YCC::packDebugInfo(IIOIOSurfaceWrapper_YCC *this, CGRect a2, uint64_t a3)
{
  unint64_t result;

  result = IIOIOSurfaceWrapperBase::packDebugInfo(this, a2, a3);
  if (*((_BYTE *)this + 200))
    result |= 0x1000uLL;
  return result;
}

uint64_t IIOIOSurfaceWrapperBase::copyImageBlockSet_8bit()
{
  return 0;
}

uint64_t IIOIOSurfaceWrapperBase::copyImageBlockSet_16bit()
{
  return 0;
}

uint64_t ___ZL30CheckIfDeviceHasDisplayP3Panelv_block_invoke()
{
  mach_port_t v0;
  const __CFDictionary *v1;
  io_service_t MatchingService;
  io_object_t v3;
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  CFTypeID v6;
  const __CFNumber *Value;
  int valuePtr;

  gDeviceHasExtendedColorDisplay = MGCopyAnswer() == *MEMORY[0x1E0C9AE50];
  v0 = *MEMORY[0x1E0CBBAB8];
  v1 = IOServiceMatching("AppleM2ScalerCSCDriver");
  MatchingService = IOServiceGetMatchingService(v0, v1);
  v3 = MatchingService;
  if (MatchingService)
  {
    v4 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", CFSTR("IOSurfaceAcceleratorCapabilitiesDict"), 0, 0);
    if (v4)
    {
      v5 = v4;
      v6 = CFGetTypeID(v4);
      if (v6 == CFDictionaryGetTypeID())
      {
        if (CFDictionaryContainsKey(v5, CFSTR("kSurfaceAcceleratorCapabilitiesColorManager")))
        {
          Value = (const __CFNumber *)CFDictionaryGetValue(v5, CFSTR("kSurfaceAcceleratorCapabilitiesColorManager"));
          if (Value)
          {
            valuePtr = 0;
            if (CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr))
              gCanUseMSRForColorConversion = valuePtr != 0;
          }
        }
      }
      CFRelease(v5);
    }
  }
  return IOObjectRelease(v3);
}

uint64_t png_handle_IEND(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  int v5;
  uint64_t result;

  v4 = *(_DWORD *)(a1 + 76);
  if ((~v4 & 5) != 0)
    png_chunk_error((void (**)(void))a1, "out of place");
  v5 = a3;
  *(_DWORD *)(a1 + 76) = v4 | 0x18;
  result = png_crc_finish(a1, a3);
  if (v5)
    return png_chunk_benign_error(a1, "invalid");
  return result;
}

void png_handle_sPLT(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  int v8;
  Bytef *buffer;
  Bytef *v10;
  const char *v11;
  uint64_t v12;
  int v14;
  Bytef *v15;
  unsigned int v16;
  unsigned int v17;
  char *v18;
  _QWORD *v19;
  unint64_t v20;
  _WORD *v21;
  unsigned int v22;
  unsigned __int16 *v23;
  unsigned int v24;
  __int128 v25;
  void *v26[2];
  uint64_t v27;

  v6 = *(_DWORD *)(a1 + 884);
  if (v6)
  {
    v7 = v6 - 1;
    if (!v7)
    {
LABEL_5:
      png_crc_finish(a1, a3);
      return;
    }
    *(_DWORD *)(a1 + 884) = v7;
    if (v7 == 1)
    {
      png_warning(a1, "No space in chunk cache for sPLT");
      goto LABEL_5;
    }
  }
  v8 = *(_DWORD *)(a1 + 76);
  if ((v8 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v8 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    v11 = "out of place";
LABEL_13:
    png_chunk_benign_error(a1, v11);
    return;
  }
  buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 2);
  if (!buffer)
  {
    png_crc_finish(a1, a3);
    v11 = "out of memory";
    goto LABEL_13;
  }
  v10 = buffer;
  png_crc_read(a1, buffer, a3);
  if (png_crc_finish(a1, 0))
    return;
  v12 = 0;
  v10[a3] = 0;
  while (v10[v12++])
    ;
  if (a3 < 2 || &v10[v12] > &v10[(a3 - 2)])
  {
    v18 = "malformed sPLT chunk";
    goto LABEL_24;
  }
  v27 = 0;
  v25 = 0u;
  *(_OWORD *)v26 = 0u;
  v15 = &v10[v12 + 1];
  LOBYTE(v26[0]) = v10[v12];
  v14 = LOBYTE(v26[0]);
  if (LOBYTE(v26[0]) == 8)
    v16 = 6;
  else
    v16 = 10;
  v17 = a3 - 1 - v12;
  if (v17 % v16)
  {
    v18 = "sPLT chunk has bad length";
LABEL_24:
    png_warning(a1, v18);
    return;
  }
  v19 = png_malloc_warn((_QWORD *)a1, 10 * (v17 / v16));
  v26[1] = v19;
  LODWORD(v27) = v17 / v16;
  if (!v19)
  {
    v18 = "sPLT chunk requires too much memory";
    goto LABEL_24;
  }
  if (v16 <= v17)
  {
    v20 = 0;
    v21 = (_WORD *)v19 + 2;
    do
    {
      if (v14 == 8)
      {
        *(v21 - 2) = *v15;
        *(v21 - 1) = v15[1];
        *v21 = v15[2];
        LOWORD(v22) = v15[3];
        v23 = (unsigned __int16 *)(v15 + 4);
      }
      else
      {
        *(v21 - 2) = bswap32(*(unsigned __int16 *)v15) >> 16;
        *(v21 - 1) = bswap32(*((unsigned __int16 *)v15 + 1)) >> 16;
        *v21 = bswap32(*((unsigned __int16 *)v15 + 2)) >> 16;
        v22 = bswap32(*((unsigned __int16 *)v15 + 3)) >> 16;
        v23 = (unsigned __int16 *)(v15 + 8);
      }
      v21[1] = v22;
      v24 = *v23;
      v15 = (Bytef *)(v23 + 1);
      v21[2] = bswap32(v24) >> 16;
      ++v20;
      v21 += 5;
    }
    while (v20 < v17 / v16);
  }
  *(_QWORD *)&v25 = v10;
  *((_QWORD *)&v25 + 1) = v12;
  png_set_sPLT((void (**)(void))a1, a2, (uint64_t)&v25, 1);
  png_free(a1, v26[1]);
}

uint64_t png_handle_hIST(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5;
  uint64_t v6;
  _WORD *v7;
  uint64_t result;
  const char *v9;
  unsigned __int16 v10;
  _OWORD v11[32];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if ((*(_DWORD *)(a1 + 76) & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((*(_DWORD *)(a1 + 76) & 6) != 2)
  {
    png_crc_finish(a1, a3);
    v9 = "out of place";
    return png_chunk_benign_error(a1, v9);
  }
  if (a2 && (*(_BYTE *)(a2 + 8) & 0x40) != 0)
  {
    png_crc_finish(a1, a3);
    v9 = "duplicate";
    return png_chunk_benign_error(a1, v9);
  }
  if ((a3 & 1) != 0
    || a3 > 0x201
    || (v5 = a3 >> 1, a3 >> 1 != *(unsigned __int16 *)(a1 + 376)))
  {
    png_crc_finish(a1, a3);
    v9 = "invalid";
    return png_chunk_benign_error(a1, v9);
  }
  memset(v11, 0, sizeof(v11));
  if (a3 >= 2)
  {
    if (v5 <= 1)
      v6 = 1;
    else
      v6 = v5;
    v7 = v11;
    do
    {
      v10 = 0;
      png_crc_read(a1, (Bytef *)&v10, 2u);
      *v7++ = bswap32(v10) >> 16;
      --v6;
    }
    while (v6);
  }
  result = png_crc_finish(a1, 0);
  if (!(_DWORD)result)
    return (uint64_t)png_set_hIST((_QWORD *)a1, a2, v11);
  return result;
}

uint64_t png_handle_oFFs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  uint64_t result;
  int v7;
  const char *v8;
  int v9;
  uint64_t v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    v8 = "out of place";
    return png_chunk_benign_error(a1, v8);
  }
  if (a2 && (*(_BYTE *)(a2 + 9) & 1) != 0)
  {
    png_crc_finish(a1, a3);
    v8 = "duplicate";
    return png_chunk_benign_error(a1, v8);
  }
  if ((_DWORD)a3 != 9)
  {
    png_crc_finish(a1, a3);
    v8 = "invalid";
    return png_chunk_benign_error(a1, v8);
  }
  v11 = 0;
  v10 = 0;
  png_crc_read(a1, (Bytef *)&v10, 9u);
  result = png_crc_finish(a1, 0);
  if (!(_DWORD)result)
  {
    if ((char)v10 < 0)
      v7 = -((2147418112 * BYTE1(v10) - ((v10 << 24) | (BYTE2(v10) << 8) | BYTE3(v10))) & 0x7FFFFFFF);
    else
      v7 = _byteswap_ulong(v10);
    if (SBYTE4(v10) < 0)
      v9 = -((2147418112 * BYTE5(v10) - ((BYTE4(v10) << 24) | (BYTE6(v10) << 8) | HIBYTE(v10))) & 0x7FFFFFFF);
    else
      v9 = _byteswap_ulong(HIDWORD(v10));
    return png_set_oFFs(a1, a2, v7, v9, v11);
  }
  return result;
}

void png_handle_pCAL(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  Bytef *buffer;
  char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  char *v19;
  unsigned int v20;
  uint64_t v21;
  char *v22;
  const char **v24;
  const char **v25;
  uint64_t v26;
  const char *v27;
  char *v28;
  const char *v29;
  int v30;

  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    v9 = "out of place";
    goto LABEL_29;
  }
  if (a2 && (*(_BYTE *)(a2 + 9) & 4) != 0)
  {
    png_crc_finish(a1, a3);
    v9 = "duplicate";
    goto LABEL_29;
  }
  buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 2);
  if (!buffer)
  {
    png_crc_finish(a1, a3);
    goto LABEL_11;
  }
  v8 = (char *)buffer;
  png_crc_read(a1, buffer, a3);
  if (!png_crc_finish(a1, 0))
  {
    v10 = 0;
    v11 = a3;
    v12 = &v8[a3];
    *v12 = 0;
    while (v8[v10++])
      ;
    if (a3 - v10 + 1 <= 12)
    {
      v9 = "invalid";
      goto LABEL_29;
    }
    v14 = &v8[v10];
    if (v8[v10] < 0)
      v15 = -((2147418112 * v8[v10 + 1]
             - ((v8[v10] << 24) | (v8[v10 + 2] << 8) | v8[v10 + 3])) & 0x7FFFFFFF);
    else
      v15 = _byteswap_ulong(*(_DWORD *)&v8[v10]);
    v16 = (unsigned __int8 *)&v8[v10];
    v17 = v8[v10 + 4];
    if (v8[v10 + 4] < 0)
      v18 = -((2147418112 * v16[5] - ((v17 << 24) | (v16[6] << 8) | v16[7])) & 0x7FFFFFFF);
    else
      v18 = (v17 << 24) | (v16[5] << 16) | (v16[6] << 8) | v16[7];
    v19 = &v8[v10];
    v20 = v19[8];
    v21 = v19[9];
    if (!v19[8] && (_DWORD)v21 != 2 || v20 - 1 <= 1 && (_DWORD)v21 != 3 || v20 == 3 && (_DWORD)v21 != 4)
    {
      v9 = "invalid parameter count";
      goto LABEL_29;
    }
    v30 = v15;
    v22 = v14 + 9;
    v29 = v19 + 10;
    if (v20 >= 4)
      png_chunk_benign_error(a1, "unrecognized equation type");
    while (*++v22)
      ;
    v24 = (const char **)png_malloc_warn((_QWORD *)a1, 8 * v21);
    if (v24)
    {
      v25 = v24;
      if (!(_DWORD)v21)
      {
LABEL_44:
        png_set_pCAL_sized((_QWORD *)a1, a2, v8, v30, v18, v20, v21, v29, v24);
        png_free(a1, v25);
        return;
      }
      v26 = 0;
      while (1)
      {
        v27 = v22 + 1;
        if (v22 + 1 < v12)
        {
          v24[v26] = v27;
          v28 = (char *)(&v8[v11 - 1] - v22);
          while (*v27)
          {
            ++v27;
            if (!--v28)
            {
              v22 = &v8[v11];
              goto LABEL_42;
            }
          }
        }
        v22 = (char *)v27;
LABEL_42:
        if (v22 >= v12)
          break;
        if (++v26 == v21)
          goto LABEL_44;
      }
      png_free(a1, v24);
      v9 = "invalid data";
LABEL_29:
      png_chunk_benign_error(a1, v9);
      return;
    }
LABEL_11:
    v9 = "out of memory";
    goto LABEL_29;
  }
}

uint64_t png_handle_sCAL(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  const char *v7;
  Bytef *buffer;
  char *v9;
  uint64_t result;
  unint64_t v11;
  uint64_t v12;
  const char *v13;
  unsigned int v14;
  unint64_t v15;

  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    v7 = "out of place";
    return png_chunk_benign_error(a1, v7);
  }
  if (a2 && (*(_BYTE *)(a2 + 9) & 0x40) != 0)
  {
    png_crc_finish(a1, a3);
    v7 = "duplicate";
    return png_chunk_benign_error(a1, v7);
  }
  if (a3 <= 3)
  {
    png_crc_finish(a1, a3);
    v7 = "invalid";
    return png_chunk_benign_error(a1, v7);
  }
  buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 2);
  if (!buffer)
  {
    png_chunk_benign_error(a1, "out of memory");
    return png_crc_finish(a1, a3);
  }
  v9 = (char *)buffer;
  png_crc_read(a1, buffer, a3);
  v9[a3] = 0;
  result = png_crc_finish(a1, 0);
  if (!(_DWORD)result)
  {
    if (*v9 - 1 >= 2)
    {
      v7 = "invalid unit";
      return png_chunk_benign_error(a1, v7);
    }
    v15 = 1;
    v14 = 0;
    if (png_check_fp_number((uint64_t)v9, a3, &v14, &v15)
      && (v11 = v15, v15 < a3)
      && (v12 = v15 + 1, ++v15, !v9[v11]))
    {
      if ((v14 & 0x188) == 0x108)
      {
        v14 = 0;
        if (png_check_fp_number((uint64_t)v9, a3, &v14, &v15) && v15 == a3)
        {
          if ((v14 & 0x188) == 0x108)
            return (uint64_t)png_set_sCAL_sized((void (**)(void))a1, a2, *v9, v9 + 1, &v9[v12]);
          v13 = "non-positive height";
        }
        else
        {
          v13 = "bad height format";
        }
      }
      else
      {
        v13 = "non-positive width";
      }
    }
    else
    {
      v13 = "bad width format";
    }
    return png_chunk_benign_error(a1, v13);
  }
  return result;
}

uint64_t png_handle_acTL(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v4;
  int v7;
  int v8;
  uint64_t result;
  char *v10;
  const char *v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
  {
    v11 = "Missing IHDR before acTL";
    goto LABEL_16;
  }
  if ((v4 & 4) != 0)
  {
    v10 = "Invalid acTL after IDAT skipped";
LABEL_13:
    png_warning(a1, v10);
    return png_crc_finish(a1, a3);
  }
  if ((v4 & 0x10000) != 0)
  {
    v10 = "Duplicate acTL skipped";
    goto LABEL_13;
  }
  if ((_DWORD)a3 != 8)
  {
    v10 = "acTL with invalid length skipped";
    goto LABEL_13;
  }
  v12[0] = 0;
  png_crc_read(a1, (Bytef *)v12, 8u);
  png_crc_finish(a1, 0);
  v7 = bswap32(v12[0]);
  if (v7 < 0 || (v8 = bswap32(HIDWORD(v12[0])), v8 < 0))
  {
    v11 = "PNG unsigned integer out of range";
LABEL_16:
    _cg_png_error((void (**)(void))a1, v11);
  }
  result = _cg_png_set_acTL(a1, a2, v7, v8);
  if ((_DWORD)result)
    *(_DWORD *)(a1 + 76) |= 0x10000u;
  return result;
}

void png_handle_fcTL(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  char *v11;
  char *v12;
  const char *v13;
  _QWORD v14[4];

  v14[3] = *MEMORY[0x1E0C80C00];
  png_ensure_sequence_number(a1, a3);
  v6 = *(_DWORD *)(a1 + 76);
  if ((v6 & 1) == 0)
  {
    v13 = "Missing IHDR before fcTL";
    goto LABEL_26;
  }
  if ((v6 & 4) != 0)
  {
    v11 = "Invalid fcTL after IDAT skipped";
LABEL_15:
    png_warning(a1, v11);
    png_crc_finish(a1, a3 - 4);
    return;
  }
  if ((v6 & 0x20000) != 0)
  {
    v11 = "Duplicate fcTL within one frame skipped";
    goto LABEL_15;
  }
  if (a3 != 26)
  {
    v11 = "fcTL with invalid length skipped";
    goto LABEL_15;
  }
  memset(v14, 0, 22);
  png_crc_read(a1, (Bytef *)v14, 0x16u);
  png_crc_finish(a1, 0);
  v7 = bswap32(v14[0]);
  if (v7 < 0
    || (v8 = bswap32(HIDWORD(v14[0])), v8 < 0)
    || (v9 = bswap32(v14[1]), v9 < 0)
    || (v10 = bswap32(HIDWORD(v14[1])), v10 < 0))
  {
    v13 = "PNG unsigned integer out of range";
LABEL_26:
    _cg_png_error((void (**)(void))a1, v13);
  }
  if (*(_DWORD *)(a1 + 784))
  {
    if (a2)
    {
LABEL_11:
      png_set_next_frame_fcTL(a1, (uint64_t)a2, v7, v8, v9, v10, bswap32(LOWORD(v14[2])) >> 16, bswap32(WORD1(v14[2])) >> 16, BYTE4(v14[2]), BYTE5(v14[2]));
      png_read_reinit(a1, (uint64_t)a2);
      *(_DWORD *)(a1 + 76) |= 0x20000u;
    }
  }
  else
  {
    if (v10 | v9)
    {
      v12 = "fcTL for the first frame must have zero offset";
    }
    else
    {
      if (!a2)
        return;
      if (v7 == *a2 && v8 == a2[1])
        goto LABEL_11;
      v12 = "size in first frame's fcTL must match the size in IHDR";
    }
    png_warning(a1, v12);
  }
}

uint64_t png_ensure_sequence_number(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  unsigned int v4;
  const char *v5;
  unsigned int v6;

  if (a2 <= 3)
  {
    v5 = "invalid fcTL or fdAT chunk found";
    goto LABEL_8;
  }
  v6 = 0;
  result = png_crc_read(a1, (Bytef *)&v6, 4u);
  v4 = bswap32(v6);
  if ((v4 & 0x80000000) != 0)
  {
    v5 = "PNG unsigned integer out of range";
    goto LABEL_8;
  }
  if (v4 != *(_DWORD *)(a1 + 772))
  {
    v5 = "fcTL or fdAT chunk with out-of-order sequence number found";
LABEL_8:
    _cg_png_error((void (**)(void))a1, v5);
  }
  *(_DWORD *)(a1 + 772) = v4 + 1;
  return result;
}

void png_read_reinit(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  void *v8;

  v2 = *(_QWORD *)(a2 + 368);
  *(_QWORD *)(a1 + 280) = v2;
  v3 = *(unsigned __int8 *)(a1 + 394);
  v4 = v3 >= 8;
  v5 = (v3 >> 3) * (unint64_t)v2;
  if (!v4)
    v5 = (*(unsigned __int8 *)(a1 + 394) * (unint64_t)v2 + 7) >> 3;
  *(_QWORD *)(a1 + 296) = v5;
  v6 = *(unsigned __int8 *)(a2 + 42);
  v7 = (v6 >> 3) * (unint64_t)v2;
  if (v6 < 8)
    v7 = (*(unsigned __int8 *)(a2 + 42) * (unint64_t)v2 + 7) >> 3;
  *(_QWORD *)(a1 + 352) = v7;
  v8 = *(void **)(a1 + 320);
  if (v8)
    bzero(v8, v5 + 1);
}

BOOL png_handle_fdAT(uint64_t a1, uint64_t a2, unsigned int a3)
{
  png_ensure_sequence_number(a1, a3);
  png_warning(a1, "ignoring fdAT chunk");
  return png_crc_finish(a1, a3 - 4);
}

uint64_t png_read_filter_row_sub(uint64_t result, _BYTE *a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = *(_QWORD *)(result + 8);
  v3 = ((unint64_t)*(unsigned __int8 *)(result + 19) + 7) >> 3;
  if (v3 < v2)
  {
    do
    {
      a2[v3] += *a2;
      ++a2;
      --v2;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t png_read_filter_row_up(uint64_t result, _BYTE *a2, char *a3)
{
  uint64_t i;
  char v4;

  for (i = *(_QWORD *)(result + 8); i; --i)
  {
    v4 = *a3++;
    *a2++ += v4;
  }
  return result;
}

uint64_t png_read_reset(uint64_t result)
{
  *(_DWORD *)(result + 76) &= 0xFFFFFFF3;
  *(_DWORD *)(result + 308) = 0;
  *(_BYTE *)(result + 389) = 0;
  return result;
}

void *png_malloc_array(void (**a1)(void), int a2, unint64_t a3)
{
  if (a2 < 1 || !a3)
    _cg_png_error(a1, "internal error: array alloc");
  if (is_mul_ok(a3, a2))
    return png_malloc_base((uint64_t)a1, a2 * a3);
  else
    return 0;
}

const char *IIO_vImageErrorString(uint64_t a1)
{
  const char *result;

  switch(a1)
  {
    case -21784:
      result = "kvImageCoreVideoIsAbsent";
      break;
    case -21783:
      result = "kvImageUnsupportedConversion";
      break;
    case -21782:
      result = "kvImageInvalidCVImageFormat";
      break;
    case -21781:
      result = "kvImageInvalidImageObject";
      break;
    case -21780:
      result = "kvImageOutOfPlaceOperationRequired";
      break;
    case -21779:
      result = "kvImageColorSyncIsAbsent";
      break;
    case -21778:
      result = "kvImageInvalidImageFormat";
      break;
    case -21777:
      result = "kvImageInvalidRowBytes";
      break;
    case -21776:
      result = "kvImageInternalError";
      break;
    case -21775:
      result = "kvImageUnknownFlagsBit";
      break;
    case -21774:
      result = "kvImageBufferSizeMismatch";
      break;
    case -21773:
      result = "kvImageInvalidParameter";
      break;
    case -21772:
      result = "kvImageNullPointerArgument";
      break;
    case -21771:
      result = "kvImageMemoryAllocationError";
      break;
    case -21770:
      result = "kvImageInvalidOffset_Y";
      break;
    case -21769:
      result = "kvImageInvalidOffset_X";
      break;
    case -21768:
      result = "kvImageInvalidEdgeStyle";
      break;
    case -21767:
      result = "kvImageInvalidKernelSize";
      break;
    case -21766:
      result = "kvImageRoiLargerThanInputBuffer";
      break;
    default:
      if (a1)
        result = "unknown vImage error";
      else
        result = "kvImageNoError";
      break;
  }
  return result;
}

vImage_Error iio_convert_XRGB2101010ToRGB16U(const vImage_Buffer *a1, const vImage_Buffer *a2, vImage_Flags a3)
{
  __int128 v6;
  size_t v7;
  void *v8;
  __int128 v9;
  vImagePixelCount width;
  int v11;
  vImage_Error v12;
  vImage_Error v13;
  vImage_Error v14;
  uint8_t permuteMap[4];
  vImage_Buffer rgbDest;
  vImage_Buffer dest;
  vImage_Buffer src;

  v6 = *(_OWORD *)&a1->width;
  src.data = a1->data;
  *(_OWORD *)&src.width = v6;
  src.height = 1;
  v7 = (8 * LODWORD(a1->width));
  v8 = malloc_type_malloc(v7, 0x542F1257uLL);
  v9 = *(_OWORD *)&a2->data;
  *(_OWORD *)&rgbDest.width = *(_OWORD *)&a2->width;
  *(_OWORD *)&dest.data = v9;
  width = a2->width;
  dest.data = v8;
  dest.height = 1;
  dest.width = width;
  dest.rowBytes = v7;
  rgbDest.data = a2->data;
  rgbDest.height = 1;
  *(_DWORD *)permuteMap = 50462976;
  if (a1->height)
  {
    v11 = 0;
    while (1)
    {
      v12 = vImageConvert_XRGB2101010ToARGB16U(&src, 0xFFFFu, &dest, 0, 1023, permuteMap, a3);
      if (v12)
      {
        v14 = v12;
        _cg_jpeg_mem_term("iio_convert_XRGB2101010ToRGB16U", 1122, "*** ERROR: vImageConvert_XRGB2101010ToARGB16U failed err: %ld\n");
        goto LABEL_7;
      }
      v13 = vImageConvert_ARGB16UtoRGB16U(&dest, &rgbDest, a3);
      if (v13)
        break;
      src.data = (char *)src.data + src.rowBytes;
      rgbDest.data = (char *)rgbDest.data + rgbDest.rowBytes;
      if (a1->height <= (unsigned __int16)++v11)
        goto LABEL_6;
    }
    v14 = v13;
    _cg_jpeg_mem_term("iio_convert_XRGB2101010ToRGB16U", 1124, "*** ERROR: vImageConvert_ARGB16UtoRGB16U failed err: %ld\n");
  }
  else
  {
LABEL_6:
    v14 = 0;
  }
LABEL_7:
  free(v8);
  return v14;
}

void IIOSubsampler::~IIOSubsampler(IIOSubsampler *this)
{
  JUMPOUT(0x18D761C30);
}

vImage_Error IIOSubsampler::scale8bitChannels(IIOSubsampler *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Error a4)
{
  vImagePixelCount width;
  uint64_t v5;
  vImage_Error v7;
  char *v10;
  vImagePixelCount height;
  vImagePixelCount v12;
  void *v13;
  vImagePixelCount v14;
  vImagePixelCount v15;
  uint64_t v16;
  vImagePixelCount v17;
  vImagePixelCount v18;
  vImagePixelCount v19;
  uint64_t v20;
  char *v21;
  char *v22;
  vImagePixelCount v23;
  vImagePixelCount v24;
  vImagePixelCount v25;
  uint64_t v26;
  char *v27;
  size_t v28;
  vImage_Buffer v29;
  vImage_Buffer src;

  width = a2->width;
  v5 = a4;
  if (a2->rowBytes < width * a4 || a3->rowBytes < a3->width * a4)
    return 4294945522;
  v7 = a4;
  v10 = (char *)malloc_type_malloc(a2->height * width, 0xE9765EA7uLL);
  height = a2->height;
  v12 = a2->width;
  src.data = v10;
  src.height = height;
  src.width = v12;
  src.rowBytes = v12;
  v13 = malloc_type_malloc(a3->height * a3->width, 0x874A699CuLL);
  v14 = a3->height;
  v15 = a3->width;
  v29.data = v13;
  v29.height = v14;
  v29.width = v15;
  v29.rowBytes = v15;
  if ((_DWORD)v7)
  {
    v16 = 0;
    do
    {
      v17 = a2->height;
      if (v17)
      {
        LODWORD(v18) = 0;
        v19 = a2->width;
        do
        {
          if (v19)
          {
            v20 = 0;
            v21 = &v10[v19 * v18];
            v22 = (char *)a2->data + a2->rowBytes * v18;
            do
            {
              v21[v20++] = v22[v16];
              v19 = a2->width;
              v22 += v5;
            }
            while (v19 > v20);
            v17 = a2->height;
          }
          v18 = (v18 + 1);
        }
        while (v17 > v18);
      }
      v7 = vImageScale_Planar8(&src, &v29, 0, 0);
      v23 = a3->height;
      if (v23)
      {
        LODWORD(v24) = 0;
        v25 = a3->width;
        do
        {
          if (v25)
          {
            v26 = 0;
            v27 = (char *)a3->data + a3->rowBytes * v24;
            v28 = (size_t)v13 + v29.rowBytes * v24;
            do
            {
              v27[v16] = *(_BYTE *)(v28 + v26++);
              v25 = a3->width;
              v27 += v5;
            }
            while (v25 > v26);
            v23 = a3->height;
          }
          v24 = (v24 + 1);
        }
        while (v23 > v24);
      }
      ++v16;
    }
    while (v16 != v5);
  }
  if (v10)
    free(v10);
  if (v13)
    free(v13);
  return v7;
}

vImage_Error IIOSubsampler::scale16bitChannels(IIOSubsampler *this, vImage_Buffer *a2, vImage_Buffer *a3, unsigned int a4)
{
  vImagePixelCount width;
  uint64_t v6;
  vImage_Error v8;
  size_t v12;
  char *v13;
  size_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  vImagePixelCount height;
  unsigned int v19;
  uint64_t v20;
  size_t rowBytes;
  vImagePixelCount v22;
  char *v23;
  uint64_t v24;
  _WORD *v25;
  vImage_Error v26;
  vImagePixelCount v27;
  unsigned int v28;
  uint64_t v29;
  char *data;
  size_t v31;
  vImagePixelCount v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  IIOSubsampler *v36;
  vImage_Buffer dest;
  vImage_Buffer src;

  width = a2->width;
  v6 = 2 * a4;
  if (a2->rowBytes < v6 * width || a3->rowBytes < v6 * a3->width)
    return 4294945522;
  v12 = (2 * width);
  v13 = (char *)malloc_type_malloc(a2->height * v12, 0xC25A23FAuLL);
  src.data = v13;
  *(_OWORD *)&src.height = *(_OWORD *)&a2->height;
  src.rowBytes = v12;
  v14 = (2 * LODWORD(a3->width));
  v15 = (char *)malloc_type_malloc(a3->height * v14, 0xB42682E3uLL);
  dest.data = v15;
  *(_OWORD *)&dest.height = *(_OWORD *)&a3->height;
  dest.rowBytes = v14;
  if (a4)
  {
    v36 = this;
    v16 = 0;
    v17 = 0;
    v35 = a4;
    do
    {
      height = a2->height;
      if (height)
      {
        v19 = 0;
        v20 = 0;
        v22 = a2->width;
        rowBytes = a2->rowBytes;
        v23 = (char *)a2->data + v16;
        do
        {
          if (v22)
          {
            v24 = 0;
            v25 = v23;
            do
            {
              *(_WORD *)&v13[2 * v24++ + v19] = *v25;
              v25 = (_WORD *)((char *)v25 + v6);
            }
            while (v22 > v24);
          }
          ++v20;
          v19 += v12;
          v23 += rowBytes;
        }
        while (height > v20);
      }
      if (*((_BYTE *)v36 + 40))
        v26 = vImageScale_Planar16F(&src, &dest, 0, 0);
      else
        v26 = vImageScale_Planar16U(&src, &dest, 0, 0);
      v8 = v26;
      v27 = a3->height;
      if (v27)
      {
        v28 = 0;
        v29 = 0;
        data = (char *)a3->data;
        v32 = a3->width;
        v31 = a3->rowBytes;
        do
        {
          if (v32)
          {
            v33 = 0;
            v34 = data;
            do
            {
              *(_WORD *)&v34[v16] = *(_WORD *)&v15[2 * v33++ + v28];
              v34 += v6;
            }
            while (v32 > v33);
          }
          ++v29;
          data += v31;
          v28 += v14;
        }
        while (v27 > v29);
      }
      ++v17;
      v16 += 2;
    }
    while (v17 != v35);
    if (!v13)
      goto LABEL_25;
    goto LABEL_24;
  }
  v8 = 0;
  if (v13)
LABEL_24:
    free(v13);
LABEL_25:
  if (v15)
    free(v15);
  return v8;
}

vImage_Error IIOSubsampler::scale32bitChannels(IIOSubsampler *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Error a4)
{
  vImage_Error v4;
  vImagePixelCount width;
  uint64_t v6;
  size_t v10;
  char *v11;
  size_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  vImagePixelCount height;
  unsigned int v17;
  uint64_t v18;
  size_t rowBytes;
  vImagePixelCount v20;
  char *v21;
  uint64_t v22;
  _DWORD *v23;
  vImagePixelCount v24;
  unsigned int v25;
  uint64_t v26;
  char *data;
  size_t v28;
  vImagePixelCount v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  vImage_Buffer dest;
  vImage_Buffer src;

  v4 = a4;
  width = a2->width;
  v6 = 4 * a4;
  if (a2->rowBytes < v6 * width || a3->rowBytes < v6 * a3->width)
    return 4294945522;
  v10 = (4 * width);
  v11 = (char *)malloc_type_malloc(a2->height * v10, 0x25797BBBuLL);
  src.data = v11;
  *(_OWORD *)&src.height = *(_OWORD *)&a2->height;
  src.rowBytes = v10;
  v12 = (4 * LODWORD(a3->width));
  v13 = (char *)malloc_type_malloc(a3->height * v12, 0xE543619uLL);
  dest.data = v13;
  *(_OWORD *)&dest.height = *(_OWORD *)&a3->height;
  dest.rowBytes = v12;
  if ((_DWORD)v4)
  {
    v14 = 0;
    v15 = 0;
    v32 = v4;
    do
    {
      height = a2->height;
      if (height)
      {
        v17 = 0;
        v18 = 0;
        v20 = a2->width;
        rowBytes = a2->rowBytes;
        v21 = (char *)a2->data + v14;
        do
        {
          if (v20)
          {
            v22 = 0;
            v23 = v21;
            do
            {
              *(_DWORD *)&v11[4 * v22++ + v17] = *v23;
              v23 = (_DWORD *)((char *)v23 + v6);
            }
            while (v20 > v22);
          }
          ++v18;
          v17 += v10;
          v21 += rowBytes;
        }
        while (height > v18);
      }
      v4 = vImageScale_PlanarF(&src, &dest, 0, 0);
      v24 = a3->height;
      if (v24)
      {
        v25 = 0;
        v26 = 0;
        data = (char *)a3->data;
        v29 = a3->width;
        v28 = a3->rowBytes;
        do
        {
          if (v29)
          {
            v30 = 0;
            v31 = data;
            do
            {
              *(_DWORD *)&v31[v14] = *(_DWORD *)&v13[4 * v30++ + v25];
              v31 += v6;
            }
            while (v29 > v30);
          }
          ++v26;
          data += v28;
          v25 += v12;
        }
        while (v24 > v26);
      }
      ++v15;
      v14 += 4;
    }
    while (v15 != v32);
  }
  if (v11)
    free(v11);
  if (v13)
    free(v13);
  return v4;
}

vImage_Error IIOSubsampler::subsampleGray8(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  uint64_t v5;
  __int128 v6;
  vImagePixelCount v7;
  uint64_t v8;
  vImage_Error v9;
  vImage_Buffer dest;
  vImage_Buffer src;

  src.data = a2;
  src.height = a3;
  v5 = *((_QWORD *)this + 1);
  *(_QWORD *)&v6 = v5;
  *((_QWORD *)&v6 + 1) = HIDWORD(v5);
  *(_OWORD *)&src.width = v6;
  v7 = *a5;
  dest.data = a4;
  dest.height = v7;
  v8 = *((_QWORD *)this + 4);
  *(_QWORD *)&v6 = v8;
  *((_QWORD *)&v6 + 1) = HIDWORD(v8);
  *(_OWORD *)&dest.width = v6;
  v9 = vImageScale_Planar8(&src, &dest, 0, 0x20u);
  if (v9)
    LogError("subsampleGray8", 267, "*** ERROR: vImageScale_Planar8 err = %ld\n", v9);
  return v9;
}

vImage_Error IIOSubsampler::subsampleGray16(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  uint64_t v5;
  __int128 v6;
  vImagePixelCount v7;
  uint64_t v8;
  vImage_Error v9;
  vImage_Buffer dest;
  vImage_Buffer src;

  src.data = a2;
  src.height = a3;
  v5 = *((_QWORD *)this + 1);
  *(_QWORD *)&v6 = v5;
  *((_QWORD *)&v6 + 1) = HIDWORD(v5);
  *(_OWORD *)&src.width = v6;
  v7 = *a5;
  dest.data = a4;
  dest.height = v7;
  v8 = *((_QWORD *)this + 4);
  *(_QWORD *)&v6 = v8;
  *((_QWORD *)&v6 + 1) = HIDWORD(v8);
  *(_OWORD *)&dest.width = v6;
  v9 = vImageScale_Planar16U(&src, &dest, 0, 0x20u);
  if (v9)
    LogError("subsampleGray16", 283, "*** ERROR: vImageScale_Planar16U err = %ld\n", v9);
  return v9;
}

vImage_Error IIOSubsampler::subsampleRGB888(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  unsigned __int8 *v6;
  vImagePixelCount v8;
  uint64_t v9;
  __int128 v10;
  vImagePixelCount v11;
  uint64_t v12;
  size_t v13;
  size_t v14;
  void *v15;
  vImagePixelCount v16;
  vImage_Error v17;
  vImage_Error v18;
  __int16 v19;
  int v20;
  vImage_Error v21;
  vImage_Error v22;
  unsigned int v23;
  char *data;
  size_t v25;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;
  vImage_Buffer v30;
  vImage_Buffer v31;

  v6 = a4;
  v8 = a3;
  v31.data = a2;
  v31.height = a3;
  v9 = *((_QWORD *)this + 1);
  *(_QWORD *)&v10 = v9;
  *((_QWORD *)&v10 + 1) = HIDWORD(v9);
  *(_OWORD *)&v31.width = v10;
  v11 = *a5;
  v30.data = a4;
  v30.height = v11;
  v12 = *((_QWORD *)this + 4);
  *(_QWORD *)&v10 = v12;
  *((_QWORD *)&v10 + 1) = HIDWORD(v12);
  *(_OWORD *)&v30.width = v10;
  v13 = (4 * v9);
  v14 = (4 * (_DWORD)v12 + 15) & 0xFFFFFFF0;
  src.data = malloc_type_malloc(v13 * (unint64_t)a3, 0x9FC8435BuLL);
  src.height = v8;
  src.width = *((unsigned int *)this + 2);
  src.rowBytes = v13;
  v15 = malloc_type_malloc(*a5 * (unint64_t)v14, 0x8FBCB94DuLL);
  v16 = *a5;
  dest.data = v15;
  dest.height = v16;
  dest.width = *((unsigned int *)this + 8);
  dest.rowBytes = v14;
  v17 = vImageConvert_RGB888toARGB8888(&v31, 0, 0xFFu, &src, 0, 0);
  if (v17)
  {
    v22 = v17;
    IIO_vImageErrorString(v17);
    LogError("subsampleRGB888", 335, "*** ERROR: vImageConvert_RGB888toARGB8888 err = %ld (%s)\n");
  }
  else
  {
    v18 = vImageScale_ARGB8888(&src, &dest, 0, 0x20u);
    if (v18)
    {
      v22 = v18;
      IIO_vImageErrorString(v18);
      LogError("subsampleRGB888", 338, "*** ERROR: vImageScale_ARGB8888 err = %ld (%s)\n");
    }
    else
    {
      v19 = *((_WORD *)this + 15);
      if (v19)
      {
        if ((v19 & 2) != 0)
          v20 = 66051;
        else
          v20 = 197121;
        *(_DWORD *)permuteMap = v20;
        vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
        if (*a5)
        {
          v23 = 0;
          data = (char *)dest.data;
          v25 = *((unsigned int *)this + 9);
          do
          {
            memcpy(v6, data, v25);
            data += v14;
            v25 = *((unsigned int *)this + 9);
            v6 += v25;
            ++v23;
          }
          while (v23 < *a5);
        }
        v22 = 0;
      }
      else
      {
        v21 = vImageConvert_ARGB8888toRGB888(&dest, &v30, 0);
        v22 = v21;
        if (v21)
        {
          IIO_vImageErrorString(v21);
          LogError("subsampleRGB888", 364, "*** ERROR: vImageConvert_ARGB8888toRGB888 err = %ld (%s)\n");
        }
      }
    }
  }
  if (src.data)
    free(src.data);
  if (dest.data)
    free(dest.data);
  return v22;
}

vImage_Error IIOSubsampler::subsampleRGBA16(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  size_t v6;
  vImagePixelCount v7;
  uint64_t v8;
  __int128 v9;
  int v10;
  void *v11;
  vImage_Error v12;
  vImage_Error v13;
  vImage_Error v14;
  vImage_Error v15;
  int v16;
  vImage_Error v17;
  vImage_Error v18;
  vImage_Buffer dest;
  vImage_Buffer v21;
  vImage_Buffer src;

  src.data = a2;
  src.height = a3;
  v6 = *((unsigned int *)this + 3);
  src.width = *((unsigned int *)this + 2);
  src.rowBytes = v6;
  v7 = *a5;
  v21.data = a4;
  v21.height = v7;
  v8 = *((_QWORD *)this + 4);
  *(_QWORD *)&v9 = v8;
  *((_QWORD *)&v9 + 1) = HIDWORD(v8);
  *(_OWORD *)&v21.width = v9;
  dest = src;
  v10 = *((_DWORD *)this + 5);
  if ((v10 - 1) > 1)
  {
    v11 = 0;
  }
  else
  {
    v11 = malloc_type_malloc(v6 * a3, 0x88A12BFDuLL);
    dest.data = v11;
    v10 = *((_DWORD *)this + 5);
  }
  if (v10 == 1)
  {
    if (*((_BYTE *)this + 40))
      v12 = vImageUnpremultiplyData_RGBA16F(&src, &dest, 0);
    else
      v12 = vImageUnpremultiplyData_RGBA16U(&src, &dest, 0);
    v14 = v12;
    if (v12)
    {
      IIO_vImageErrorString(v12);
      LogError("subsampleRGBA16", 514, "*** ERROR: vImageUnpremultiplyData_RGBA16%c err = %ld (%s)\n");
      goto LABEL_35;
    }
  }
  else if (v10 == 2)
  {
    if (*((_BYTE *)this + 40))
    {
      dest = src;
    }
    else
    {
      v13 = vImageUnpremultiplyData_ARGB16U(&src, &dest, 0);
      if (v13)
      {
        v14 = v13;
        IIO_vImageErrorString(v13);
        LogError("subsampleRGBA16", 506, "*** ERROR: vImageUnpremultiplyData_ARGB16U err = %ld (%s)\n");
        goto LABEL_35;
      }
    }
  }
  if (*((_BYTE *)this + 40))
    v15 = vImageScale_ARGB16F(&dest, &v21, 0, 0x10u);
  else
    v15 = vImageScale_ARGB16U(&dest, &v21, 0, 0x20u);
  v14 = v15;
  if (v15)
  {
    IIO_vImageErrorString(v15);
    LogError("subsampleRGBA16", 522, "*** ERROR: vImageScale_ARGB16%c err = %ld (%s)\n");
    goto LABEL_35;
  }
  v16 = *((_DWORD *)this + 5);
  if (v16 == 1)
  {
    if (*((_BYTE *)this + 40))
      v17 = vImagePremultiplyData_RGBA16F(&v21, &v21, 0);
    else
      v17 = vImagePremultiplyData_RGBA16U(&v21, &v21, 0);
    v14 = v17;
    if (!v17)
      goto LABEL_29;
    IIO_vImageErrorString(v17);
    LogError("subsampleRGBA16", 538, "*** ERROR: vImagePremultiplyData_RGBA16%c err = %ld (%s)\n");
LABEL_35:
    if (!v11)
      return v14;
    goto LABEL_30;
  }
  if (v16 != 2 || *((_BYTE *)this + 40))
  {
    v14 = 0;
    if (!v11)
      return v14;
    goto LABEL_30;
  }
  v18 = vImagePremultiplyData_ARGB16U(&v21, &v21, 0);
  v14 = v18;
  if (v18)
  {
    IIO_vImageErrorString(v18);
    LogError("subsampleRGBA16", 530, "*** ERROR: vImagePremultiplyData_ARGB16U err = %ld (%s)\n");
    goto LABEL_35;
  }
LABEL_29:
  if (v11)
LABEL_30:
    free(v11);
  return v14;
}

vImage_Error IIOSubsampler::subsampleRGBA32(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  size_t v6;
  vImagePixelCount v7;
  uint64_t v8;
  __int128 v9;
  int v10;
  void *v11;
  vImage_Error v12;
  vImage_Error v13;
  vImage_Error v14;
  vImage_Error v15;
  int v16;
  vImage_Error v17;
  vImage_Error v18;
  vImage_Buffer dest;
  vImage_Buffer v21;
  vImage_Buffer src;

  src.data = a2;
  src.height = a3;
  v6 = *((unsigned int *)this + 3);
  src.width = *((unsigned int *)this + 2);
  src.rowBytes = v6;
  v7 = *a5;
  v21.data = a4;
  v21.height = v7;
  v8 = *((_QWORD *)this + 4);
  *(_QWORD *)&v9 = v8;
  *((_QWORD *)&v9 + 1) = HIDWORD(v8);
  *(_OWORD *)&v21.width = v9;
  dest = src;
  v10 = *((_DWORD *)this + 5);
  if ((v10 - 1) > 1)
  {
    v11 = 0;
  }
  else
  {
    v11 = malloc_type_malloc(v6 * a3, 0xF8DC76C0uLL);
    dest.data = v11;
    v10 = *((_DWORD *)this + 5);
  }
  if (v10 == 1)
  {
    if (*((_BYTE *)this + 40))
      v12 = vImageUnpremultiplyData_RGBA16F(&src, &dest, 0);
    else
      v12 = vImageUnpremultiplyData_RGBA16U(&src, &dest, 0);
    v14 = v12;
    if (v12)
    {
      IIO_vImageErrorString(v12);
      LogError("subsampleRGBA32", 588, "*** ERROR: vImageUnpremultiplyData_RGBA16%c err = %ld (%s)\n");
      goto LABEL_35;
    }
  }
  else if (v10 == 2)
  {
    if (*((_BYTE *)this + 40))
    {
      dest = src;
    }
    else
    {
      v13 = vImageUnpremultiplyData_ARGB16U(&src, &dest, 0);
      if (v13)
      {
        v14 = v13;
        IIO_vImageErrorString(v13);
        LogError("subsampleRGBA32", 580, "*** ERROR: vImageUnpremultiplyData_ARGB16U err = %ld (%s)\n");
        goto LABEL_35;
      }
    }
  }
  if (*((_BYTE *)this + 40))
    v15 = vImageScale_ARGB16F(&dest, &v21, 0, 0x10u);
  else
    v15 = vImageScale_ARGB16U(&dest, &v21, 0, 0x20u);
  v14 = v15;
  if (v15)
  {
    IIO_vImageErrorString(v15);
    LogError("subsampleRGBA32", 596, "*** ERROR: vImageScale_ARGB16%c err = %ld (%s)\n");
    goto LABEL_35;
  }
  v16 = *((_DWORD *)this + 5);
  if (v16 == 1)
  {
    if (*((_BYTE *)this + 40))
      v17 = vImagePremultiplyData_RGBA16F(&v21, &v21, 0);
    else
      v17 = vImagePremultiplyData_RGBA16U(&v21, &v21, 0);
    v14 = v17;
    if (!v17)
      goto LABEL_29;
    IIO_vImageErrorString(v17);
    LogError("subsampleRGBA32", 612, "*** ERROR: vImagePremultiplyData_RGBA16%c err = %ld (%s)\n");
LABEL_35:
    if (!v11)
      return v14;
    goto LABEL_30;
  }
  if (v16 != 2 || *((_BYTE *)this + 40))
  {
    v14 = 0;
    if (!v11)
      return v14;
    goto LABEL_30;
  }
  v18 = vImagePremultiplyData_ARGB16U(&v21, &v21, 0);
  v14 = v18;
  if (v18)
  {
    IIO_vImageErrorString(v18);
    LogError("subsampleRGBA32", 604, "*** ERROR: vImagePremultiplyData_ARGB16U err = %ld (%s)\n");
    goto LABEL_35;
  }
LABEL_29:
  if (v11)
LABEL_30:
    free(v11);
  return v14;
}

uint64_t IIOImageAnimator::IIOImageAnimator(uint64_t a1, uint64_t a2, const void *a3, IIODictionary *a4)
{
  uint64_t Uint64ForKey;
  unsigned int v9;
  double DoubleForKey;
  const __CFDictionary *ObjectForKey;
  const __CFNumber *v12;
  CFTypeID v13;

  *(_QWORD *)a1 = &off_1E1BB0DA8;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  IIO_LoadCoreMediaSymbols();
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 24) = _Block_copy(a3);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  if (IIODictionary::containsKey(a4, CFSTR("StartIndex")))
    Uint64ForKey = (uint64_t)IIODictionary::getUint64ForKey(a4, CFSTR("StartIndex"));
  else
    Uint64ForKey = -1;
  *(_QWORD *)(a1 + 128) = Uint64ForKey;
  v9 = IIODictionary::containsKey(a4, CFSTR("DelayTime"));
  DoubleForKey = -1.0;
  if (v9)
    DoubleForKey = IIODictionary::getDoubleForKey(a4, CFSTR("DelayTime"));
  *(_QWORD *)(a1 + 136) = -1;
  *(double *)(a1 + 144) = DoubleForKey;
  if (IIODictionary::containsKey(a4, CFSTR("LoopCount")))
  {
    ObjectForKey = IIODictionary::getObjectForKey(a4, CFSTR("LoopCount"));
    v12 = ObjectForKey;
    if (ObjectForKey != (const __CFDictionary *)*MEMORY[0x1E0C9B218])
    {
      v13 = CFGetTypeID(ObjectForKey);
      if (v13 == CFNumberGetTypeID())
        CFNumberGetValue(v12, kCFNumberCFIndexType, (void *)(a1 + 136));
    }
  }
  return a1;
}

void sub_188055A54(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void *v5;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v2);
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 64) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

void IIOImageAnimator::~IIOImageAnimator(IIOImageAnimator *this)
{
  IIOImageSource *v2;
  const void *v3;
  const void *v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  const void *v8;
  const void *v9;
  void *v10;
  __int128 v11;

  *(_QWORD *)this = &off_1E1BB0DA8;
  v2 = (IIOImageSource *)*((_QWORD *)this + 1);
  if (v2)
  {
    v3 = (const void *)IIOImageSource::cf(v2);
    CFRelease(v3);
  }
  v4 = (const void *)*((_QWORD *)this + 12);
  if (v4)
    CFRelease(v4);
  v11 = 0uLL;
  std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>((uint64_t)this + 112, &v11);
  v5 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
  if (*((_QWORD *)&v11 + 1))
  {
    v6 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v8 = (const void *)*((_QWORD *)this + 21);
  if (v8)
    CFRelease(v8);
  v9 = (const void *)*((_QWORD *)this + 22);
  if (v9)
    CFRelease(v9);
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 10));
  _Block_release(*((const void **)this + 3));
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)this + 112);
  v10 = (void *)*((_QWORD *)this + 7);
  if (v10)
  {
    *((_QWORD *)this + 8) = v10;
    operator delete(v10);
  }
}

{
  IIOImageAnimator::~IIOImageAnimator(this);
  JUMPOUT(0x18D761C30);
}

uint64_t IIOImageAnimator::setup(IIOImageSource **this)
{
  const __CFDictionary *v2;
  const __CFString *Type;
  const __CFString *v4;
  uint64_t v5;
  const CFStringRef *v6;
  unsigned int Uint32ForKeyGroup;
  const __CFDictionary *ObjectForKeyGroup;
  CFIndex Count;
  unint64_t v10;
  void **v11;
  const __CFDictionary *ValueAtIndex;
  double DoubleForKey;
  double v14;
  IIOImageSource *v15;
  double *v16;
  IIOImageSource *v17;
  double *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  IIOImageSource *v24;
  uint64_t v25;
  const __CFDictionary **v26;
  IIOImagePlus *Plugin;
  CGColorSpace *ColorSpace;
  unsigned int ColorSpaceModel;
  CFStringRef *v30;
  _QWORD v32[3];
  const __CFDictionary *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[3];
  _QWORD v37[3];

  memset(v37, 0, sizeof(v37));
  IIODictionary::IIODictionary((IIODictionary *)v37);
  v2 = IIOImageSource::copyProperties(this[1], (IIODictionary *)v37);
  if (!v2)
  {
    v5 = 4294945155;
    goto LABEL_45;
  }
  Type = (const __CFString *)IIOImageSource::getType((IIO_Reader **)this[1]);
  memset(v36, 0, sizeof(v36));
  IIODictionary::IIODictionary((IIODictionary *)v36, v2);
  if (CFStringCompare(Type, CFSTR("com.compuserve.gif"), 0) == kCFCompareEqualTo)
  {
    v6 = &kCGImagePropertyGIFDictionary;
LABEL_14:
    v4 = *v6;
    goto LABEL_15;
  }
  if (CFStringCompare(Type, CFSTR("public.png"), 0) == kCFCompareEqualTo)
  {
    v6 = &kCGImagePropertyPNGDictionary;
    goto LABEL_14;
  }
  if (CFStringCompare(Type, CFSTR("public.heics"), 0) == kCFCompareEqualTo)
  {
    v6 = &kCGImagePropertyHEICSDictionary;
    goto LABEL_14;
  }
  if (CFStringCompare(Type, CFSTR("public.avis"), 0) == kCFCompareEqualTo)
  {
    v6 = &kCGImagePropertyAVISDictionary;
    goto LABEL_14;
  }
  if (CFStringCompare(Type, CFSTR("org.webmproject.webp"), 0))
    v4 = 0;
  else
    v4 = CFSTR("{WebP}");
LABEL_15:
  this[5] = (IIOImageSource *)IIODictionary::getUint32ForKeyGroup((IIODictionary *)v36, CFSTR("CanvasPixelWidth"), v4);
  Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v36, CFSTR("CanvasPixelHeight"), v4);
  this[6] = (IIOImageSource *)Uint32ForKeyGroup;
  if (this[5] && Uint32ForKeyGroup)
  {
    ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v36, CFSTR("FrameInfo"), v4);
    Count = CFArrayGetCount(ObjectForKeyGroup);
    this[4] = (IIOImageSource *)Count;
    if (Count)
    {
      v10 = 0;
      v11 = (void **)(this + 7);
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(ObjectForKeyGroup, v10);
        v33 = 0;
        v34 = 0;
        v35 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v33, ValueAtIndex);
        DoubleForKey = IIODictionary::getDoubleForKey((IIODictionary *)&v33, CFSTR("DelayTime"));
        v14 = DoubleForKey;
        v16 = (double *)this[8];
        v15 = this[9];
        if (v16 >= (double *)v15)
        {
          v18 = (double *)*v11;
          v19 = ((char *)v16 - (_BYTE *)*v11) >> 3;
          v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 61)
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          v21 = v15 - (IIOImageSource *)v18;
          if (v21 >> 2 > v20)
            v20 = v21 >> 2;
          if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
            v22 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v22 = v20;
          if (v22)
          {
            v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(this + 9), v22);
            v18 = (double *)this[7];
            v16 = (double *)this[8];
          }
          else
          {
            v23 = 0;
          }
          v24 = (IIOImageSource *)&v23[8 * v19];
          *(double *)v24 = v14;
          v17 = (IIOImageSource *)((char *)v24 + 8);
          while (v16 != v18)
          {
            v25 = *((_QWORD *)v16-- - 1);
            *((_QWORD *)v24 - 1) = v25;
            v24 = (IIOImageSource *)((char *)v24 - 8);
          }
          this[7] = v24;
          this[8] = v17;
          this[9] = (IIOImageSource *)&v23[8 * v22];
          if (v18)
            operator delete(v18);
        }
        else
        {
          *v16 = DoubleForKey;
          v17 = (IIOImageSource *)(v16 + 1);
        }
        this[8] = v17;
        IIODictionary::~IIODictionary((IIODictionary *)&v33);
        ++v10;
      }
      while (v10 < (unint64_t)this[4]);
      v33 = 0;
      v34 = 0;
      v35 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v33);
      v26 = IIOImageSource::copyPropertiesAtIndex(this[1], 0, &v33);
      memset(v32, 0, sizeof(v32));
      IIODictionary::IIODictionary((IIODictionary *)v32, (const __CFDictionary *)v26);
      *((_BYTE *)this + 92) = IIODictionary::getBoolForKey((IIODictionary *)v32, "HasAlpha");
      Plugin = IIOImageSource::getAnimationReadPlugin(this[1]);
      this[2] = Plugin;
      ColorSpace = (CGColorSpace *)IIOReadPlugin::getColorSpace(Plugin);
      this[10] = CGColorSpaceRetain(ColorSpace);
      ColorSpaceModel = IIOReadPlugin::getColorSpaceModel(this[2]);
      *((_DWORD *)this + 22) = ColorSpaceModel;
      if (ColorSpaceModel >= 2)
      {
        _cg_jpeg_mem_term("setup", 274, "*** ERROR: unsupported colorspace");
        v5 = 4294945154;
      }
      else if (this[10])
      {
        v5 = 0;
      }
      else
      {
        v30 = (CFStringRef *)MEMORY[0x1E0C9D978];
        if (ColorSpaceModel)
          v30 = (CFStringRef *)MEMORY[0x1E0C9DA10];
        v5 = 0;
        this[10] = CGColorSpaceCreateWithName(*v30);
      }
      IIODictionary::~IIODictionary((IIODictionary *)v32);
      IIODictionary::~IIODictionary((IIODictionary *)&v33);
      IIODictionary::~IIODictionary((IIODictionary *)v36);
      goto LABEL_43;
    }
    _cg_jpeg_mem_term("setup", 256, "*** ERROR: bad image count (%ld)", 0);
  }
  else
  {
    _cg_jpeg_mem_term("setup", 253, "*** ERROR: bad image dimensions (%ldx%ld)", this[5], Uint32ForKeyGroup);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v36);
  v26 = 0;
  v5 = 4294945155;
LABEL_43:
  CFRelease(v2);
  if (v26)
    CFRelease(v26);
LABEL_45:
  IIODictionary::~IIODictionary((IIODictionary *)v37);
  return v5;
}

void sub_188055FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;
  uint64_t v13;
  uint64_t v14;
  va_list va2;

  va_start(va2, a6);
  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v11 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  _Unwind_Resume(a1);
}

uint64_t IIOImageAnimator::start(IIOImageAnimator *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  IIODictionary *v5;
  double v6;
  const void *v7;
  const __CFString *v8;
  IIODictionary *v9;
  int v10;
  __IOSurface *SurfaceWithFormat;
  CGImage *v12;
  IIOImageAnimator *v13;
  uint64_t v14;
  __IOSurface *v15;
  uint64_t v16;
  void *v17;
  uint64_t HostTimeClock;
  uint64_t v19;
  const void *Ref;
  _QWORD *v21;
  NSObject *v22;
  _QWORD handler[19];
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[4];
  _QWORD v29[4];
  uint64_t v30;
  CFTypeRef cf;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  _QWORD v49[3];
  _QWORD v50[4];

  v50[0] = 0;
  v50[1] = v50;
  v50[2] = 0x2000000000;
  v2 = *((_QWORD *)this + 16);
  if (v2 == -1)
    v2 = 0;
  v50[3] = v2;
  v3 = *((_QWORD *)this + 5);
  v4 = *((_QWORD *)this + 6);
  memset(v49, 0, sizeof(v49));
  IIODictionary::IIODictionary((IIODictionary *)v49);
  v47 = xmmword_1E1BCA450;
  v48 = *(_OWORD *)&off_1E1BCA460;
  IIODictionary::setObjectForKey(v5, (const void *)*MEMORY[0x1E0C9AE50], (const __CFString *)*MEMORY[0x1E0C9DAF0]);
  v6 = (double)v3;
  v43 = 0;
  v44 = &v43;
  v45 = 0x2000000000;
  v46 = 0;
  v46 = CGImageProviderCreate();
  v40 = 0;
  v41 = 0;
  v42 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v40);
  v7 = (const void *)*MEMORY[0x1E0C9DAA8];
  v8 = (const __CFString *)*MEMORY[0x1E0C9DAB0];
  IIODictionary::setObjectForKey(v9, (const void *)*MEMORY[0x1E0C9DAA8], (const __CFString *)*MEMORY[0x1E0C9DAB0]);
  (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 2) + 72))(*((_QWORD *)this + 2), v41);
  if (*((_DWORD *)this + 22))
    v10 = 1111970369;
  else
    v10 = 843264056;
  SurfaceWithFormat = IIO_CreateSurfaceWithFormat(v10, v3, v4, *((CGColorSpace **)this + 10));
  *((_QWORD *)this + 21) = SurfaceWithFormat;
  IOSurfaceIncrementUseCount(SurfaceWithFormat);
  if (*((_QWORD *)this + 4) == 1)
  {
    LOBYTE(v29[0]) = 0;
    v30 = 0;
    cf = 0;
    v32 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v30);
    IIODictionary::setObjectForKey((IIODictionary *)&v30, v7, v8);
    v39 = 0;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v34 = 0u;
    IIODecodeParameter::IIODecodeParameter((uint64_t)&v34, 0, v44[3], 0, cf, 0.0, 0.0, (double)v3, (double)v4, (double)v3, (double)v4);
    IIOReadPlugin::decodeImageIntoIOSurface(*((IIOReadPlugin **)this + 2), (IIODecodeParameter *)&v34, *((__IOSurface **)this + 21));
    v12 = CGImageCreateFromIOSurface(*((__IOSurface **)this + 21), 0);
    v13 = (IIOImageAnimator *)(*(uint64_t (**)(void))(*((_QWORD *)this + 3) + 16))();
    IIOImageAnimator::_releaseFrameImage(v13, v12);
    IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)&v34);
    IIODictionary::~IIODictionary((IIODictionary *)&v30);
    v14 = 0;
  }
  else
  {
    v15 = IIO_CreateSurfaceWithFormat(v10, v3, v4, *((CGColorSpace **)this + 10));
    *((_QWORD *)this + 22) = v15;
    IOSurfaceIncrementUseCount(v15);
    v16 = *((_QWORD *)this + 21);
    if (v16 && *((_QWORD *)this + 22))
    {
      *(_QWORD *)&v34 = 0;
      *((_QWORD *)&v34 + 1) = &v34;
      v35 = 0x2000000000uLL;
      v30 = 0;
      cf = &v30;
      v32 = 0x2000000000;
      v33 = v16;
      v29[0] = 0;
      v29[1] = v29;
      v29[2] = 0x2000000000;
      v29[3] = 0;
      v17 = malloc_type_calloc(8uLL, 2uLL, 0x913437F6uLL);
      v28[0] = 0;
      v28[1] = v28;
      v28[2] = 0x2000000000;
      v28[3] = 0;
      *((_QWORD *)this + 20) = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, MEMORY[0x1E0C80D38]);
      v27 = 0;
      HostTimeClock = gFunc_CMClockGetHostTimeClock();
      gFunc_CMTimebaseCreateWithSourceClock(*MEMORY[0x1E0C9AE00], HostTimeClock, &v27);
      if (v27)
      {
        gFunc_CMTimebaseAddTimerDispatchSource(v27, *((_QWORD *)this + 20));
        v19 = *((_QWORD *)this + 20);
        v26 = 0;
        v25 = *(_OWORD *)&kCMTimeZero.value;
        gFunc_CMTimebaseSetTimerDispatchSourceNextFireTime(v27, v19, &v25, 0);
        Ref = (const void *)IIOImageSource::imageReadRef(*((IIOImageSource **)this + 1));
        v21 = CGImageReadSessionCreate(Ref);
        *((_QWORD *)this + 12) = v21;
        *((_QWORD *)this + 13) = CGImageSourceGetSource((uint64_t)v21);
        *((_QWORD *)this + 19) = IIOImageSource::reader(*((IIOImageSource **)this + 1));
        v22 = *((_QWORD *)this + 20);
        handler[0] = MEMORY[0x1E0C809B0];
        handler[1] = 0x40000000;
        handler[2] = ___ZN16IIOImageAnimator5startEv_block_invoke;
        handler[3] = &unk_1E1BCA478;
        handler[4] = v50;
        handler[5] = &v43;
        handler[11] = 0;
        handler[12] = 0;
        *(double *)&handler[13] = v6;
        *(double *)&handler[14] = (double)v4;
        *(double *)&handler[15] = v6;
        *(double *)&handler[16] = (double)v4;
        handler[6] = &v30;
        handler[7] = v29;
        handler[8] = v28;
        handler[9] = &v34;
        handler[10] = this;
        handler[17] = v17;
        handler[18] = v27;
        dispatch_source_set_event_handler(v22, handler);
        gFunc_CMTimebaseSetRate(v27, 1.0);
        dispatch_resume(*((dispatch_object_t *)this + 20));
        v14 = 0;
      }
      else
      {
        v14 = 4294945152;
      }
      _Block_object_dispose(v28, 8);
      _Block_object_dispose(v29, 8);
      _Block_object_dispose(&v30, 8);
      _Block_object_dispose(&v34, 8);
    }
    else
    {
      v14 = 4294945152;
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v40);
  _Block_object_dispose(&v43, 8);
  IIODictionary::~IIODictionary((IIODictionary *)v49);
  _Block_object_dispose(v50, 8);
  return v14;
}

void sub_1880564DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  uint64_t v45;

  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose(&a45, 8);
  IIODictionary::~IIODictionary((IIODictionary *)(v45 - 248));
  _Block_object_dispose((const void *)(v45 - 224), 8);
  IIODictionary::~IIODictionary((IIODictionary *)(v45 - 152));
  _Block_object_dispose((const void *)(v45 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t _CopyImageBlockSetCallback()
{
  return 0;
}

uint64_t _CopyIOSurfaceCallback()
{
  return 0;
}

void IIOImageAnimator::_releaseFrameImage(IIOImageAnimator *this, CGImage *a2)
{
  if (CGImageGetImageProvider())
  {
    CGImageProviderSetProperty();
    CGImageProviderSetProperty();
  }
  CGImageRelease(a2);
}

void ___ZN16IIOImageAnimator5startEv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  IIODictionary *v3;
  IIOImageAnimator *v4;
  CGImage *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CGImage *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  void (*v16)(__int128 *__return_ptr, _QWORD *, _BYTE *);
  uint64_t v17;
  uint64_t v18;
  IIOImageAnimator *v19;
  IIOImageAnimator *v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  _BYTE v24[24];
  _QWORD v25[3];
  __int128 v26;
  uint64_t v27;
  _QWORD block[5];
  _QWORD v29[3];
  __int128 v30;
  __int128 v31;
  _OWORD v32[5];
  uint64_t v33;
  uint64_t v34;
  CFTypeRef v35;
  uint64_t v36;
  char v37;

  v2 = *(_QWORD *)(a1 + 80);
  v37 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v34);
  IIODictionary::setObjectForKey(v3, (const void *)*MEMORY[0x1E0C9DAA8], (const __CFString *)*MEMORY[0x1E0C9DAB0]);
  v33 = 0;
  memset(v32, 0, sizeof(v32));
  IIODecodeParameter::IIODecodeParameter((uint64_t)v32, 0, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), v35, *(double *)(a1 + 88), *(double *)(a1 + 96), *(double *)(a1 + 104), *(double *)(a1 + 112), *(double *)(a1 + 120), *(double *)(a1 + 128));
  IIOReadPlugin::decodeImageIntoIOSurface(*(IIOReadPlugin **)(v2 + 16), (IIODecodeParameter *)v32, *(__IOSurface **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8)
                                                                          + 24);
  v30 = 0u;
  v31 = 0u;
  memset(v29, 0, sizeof(v29));
  IIODictionary::IIODictionary((IIODictionary *)v29);
  IIODictionary::setObjectForKey((IIODictionary *)v29, (const void *)*MEMORY[0x1E0C9AE50], (const __CFString *)*MEMORY[0x1E0C9DAF0]);
  LODWORD(v30) = 2;
  *((_QWORD *)&v30 + 1) = _copyImageBlockSetCallback;
  *(_QWORD *)&v31 = _copyIOSurfaceCallback;
  *((_QWORD *)&v31 + 1) = _releaseFrameImageProviderInfo;
  v4 = (IIOImageAnimator *)CGImageProviderCreate();
  if (v4)
  {
    v4 = (IIOImageAnimator *)CGImageCreateWithImageProvider();
    v5 = v4;
    if (v4)
    {
      CGImageProviderRelease();
      v4 = (IIOImageAnimator *)(*(uint64_t (**)(void))(*(_QWORD *)(v2 + 24) + 16))();
    }
  }
  else
  {
    v5 = 0;
  }
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
  v7 = *(_QWORD *)(v6 + 24);
  if (v7 == 2)
  {
    v9 = *(_QWORD *)(a1 + 136);
    v10 = *(CGImage **)v9;
    *(_QWORD *)v9 = *(_QWORD *)(v9 + 8);
    IIOImageAnimator::_releaseFrameImage(v4, v10);
  }
  else
  {
    if (v7 == 1)
    {
      **(_QWORD **)(a1 + 136) = *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8);
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
      v8 = *(_QWORD *)(v6 + 24) + 1;
    }
    else
    {
      if (v7)
        goto LABEL_11;
      v8 = 1;
    }
    *(_QWORD *)(v6 + 24) = v8;
  }
LABEL_11:
  *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8) = v5;
  CGImageRetain(*(CGImageRef *)(*(_QWORD *)(a1 + 136) + 8));
  CGImageRelease(v5);
  CGImageProviderRelease();
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v12 = *(_QWORD *)(v2 + 168);
  if (*(_QWORD *)(v11 + 24) == v12)
    v12 = *(_QWORD *)(v2 + 176);
  *(_QWORD *)(v11 + 24) = v12;
  if (v37)
    goto LABEL_20;
  if (*(_QWORD *)(v2 + 32) < 2uLL
    || (++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24),
        v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8),
        *(_QWORD *)(v13 + 24) >= *(_QWORD *)(v2 + 32))
    && (*(_QWORD *)(v13 + 24) = 0,
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 0,
        *(_QWORD *)(v2 + 136) != -1)
    && (v14 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8),
        v15 = *(_QWORD *)(v14 + 24) + 1,
        *(_QWORD *)(v14 + 24) = v15,
        v15 >= *(_QWORD *)(v2 + 136)))
  {
    v37 = 1;
LABEL_20:
    _cg_jpeg_mem_term("start_block_invoke", 448, "*** animation was stopped...\n");
    CFRelease(*(CFTypeRef *)(a1 + 144));
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 160));
    dispatch_release(*(dispatch_object_t *)(v2 + 160));
    *(_QWORD *)(v2 + 160) = 0;
    IIOImageAnimator::_releaseFrameImage(v19, **(CGImage ***)(a1 + 136));
    IIOImageAnimator::_releaseFrameImage(v20, *(CGImage **)(*(_QWORD *)(a1 + 136) + 8));
    free(*(void **)(a1 + 136));
    CGImageProviderRelease();
    v21 = MEMORY[0x1E0C809B0];
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    block[0] = v21;
    block[1] = 0x40000000;
    block[2] = ___ZN16IIOImageAnimator5startEv_block_invoke_2;
    block[3] = &__block_descriptor_tmp_48;
    block[4] = v2;
    dispatch_async(MEMORY[0x1E0C80D38], block);
    goto LABEL_21;
  }
  v26 = 0uLL;
  v27 = 0;
  v16 = (void (*)(__int128 *__return_ptr, _QWORD *, _BYTE *))gFunc_CMTimeAdd;
  gFunc_CMTimebaseGetTime(v25, *(_QWORD *)(a1 + 144));
  gFunc_CMTimeMakeWithSeconds(600);
  v16(&v26, v25, v24);
  v17 = *(_QWORD *)(a1 + 144);
  v18 = *(_QWORD *)(v2 + 160);
  v22 = v26;
  v23 = v27;
  gFunc_CMTimebaseSetTimerDispatchSourceNextFireTime(v17, v18, &v22, 0);
LABEL_21:
  IIODictionary::~IIODictionary((IIODictionary *)v29);
  IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)v32);
  IIODictionary::~IIODictionary((IIODictionary *)&v34);
}

void sub_188056A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v33;

  IIODictionary::~IIODictionary((IIODictionary *)&a26);
  IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)&a33);
  IIODictionary::~IIODictionary((IIODictionary *)(v33 - 96));
  _Unwind_Resume(a1);
}

void *_copyImageBlockSetCallback(__IOSurface *a1, uint64_t a2, const __CFDictionary *a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  void *result;
  unint64_t BytesPerRow;
  void *v11;
  void *v12;
  void *BaseAddress;
  const __CFString *Value;
  const __CFString *v15;
  CFTypeID v16;
  uint64_t v17;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;
  __int128 v21;
  uint64_t v22;

  v22 = 0;
  CGImageProviderGetSize();
  v6 = v5;
  v8 = v7;
  v21 = xmmword_1E1BCA498;
  if (!CGImageProviderGetProperty())
  {
    BytesPerRow = IOSurfaceGetBytesPerRow(a1);
    IOSurfaceLock(a1, 1u, 0);
    v11 = malloc_type_malloc((unint64_t)(v8 * (double)BytesPerRow), 0x766E6C11uLL);
    if (v11)
    {
      v12 = v11;
      BaseAddress = IOSurfaceGetBaseAddress(a1);
      memcpy(v12, BaseAddress, (unint64_t)(v8 * (double)BytesPerRow));
      if (!a3
        || (Value = (const __CFString *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E0C9DAB0])) == 0
        || (v15 = Value, v16 = CFGetTypeID(Value), v16 != CFStringGetTypeID())
        || CFStringCompare(v15, (CFStringRef)*MEMORY[0x1E0C9DAA8], 0))
      {
        src.data = v12;
        src.height = (unint64_t)v8;
        src.width = (unint64_t)v6;
        src.rowBytes = BytesPerRow;
        dest.data = v12;
        dest.height = (unint64_t)v8;
        dest.width = (unint64_t)v6;
        dest.rowBytes = BytesPerRow;
        *(_DWORD *)permuteMap = 50331906;
        vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0x10u);
      }
      v17 = CGImageBlockCreate();
      v22 = v17;
    }
    else
    {
      v17 = 0;
    }
    IOSurfaceUnlock(a1, 1u, 0);
    if (v17)
      goto LABEL_6;
    return 0;
  }
  if (*MEMORY[0x1E0C9AE40] == CGImageProviderGetProperty())
    _cg_jpeg_mem_term("_copyImageBlockSetCallback", 68, "*** Should not be here\n");
  result = malloc_type_calloc((vcvtd_n_u64_f64(v6, 2uLL) + 15) & 0xFFFFFFFFFFFFFFF0, (unint64_t)v8, 0xF15B57AuLL);
  if (result)
  {
    v22 = CGImageBlockCreate();
    if (v22)
    {
LABEL_6:
      CGImageProviderGetColorSpace();
      return (void *)CGImageBlockSetCreateWithType();
    }
    return 0;
  }
  return result;
}

CFTypeRef _copyIOSurfaceCallback(const void *a1)
{
  uint64_t Property;

  Property = CGImageProviderGetProperty();
  if (!a1 || Property)
    return 0;
  else
    return IIOFrameBufferRetain(a1);
}

uint64_t ___ZN16IIOImageAnimator5startEv_block_invoke_2(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t _cg_JP2InitCompressionSettings(uint64_t result, float a2)
{
  *(_WORD *)result = a2 < 1.0;
  *(_WORD *)(result + 2) = 0;
  *(_WORD *)(result + 4) = vcvts_n_s32_f32(a2, 0xAuLL);
  *(_WORD *)(result + 6) = 4;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

uint64_t _cg_JP2CompressorSetup(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t *a5, _QWORD *a6)
{
  _OWORD *v12;
  _OWORD *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  kdu_compressed_target *v29;
  jp2_target *v30;
  uint64_t v31;

  v12 = malloc_type_calloc(0x120uLL, 1uLL, 0xFFF05A2DuLL);
  *a6 = v12;
  if (!v12)
    return 4294967188;
  v13 = v12;
  v14 = *a4;
  v15 = a4[1];
  v16 = a4[3];
  v12[2] = a4[2];
  v12[3] = v16;
  *v12 = v14;
  v12[1] = v15;
  v17 = a4[4];
  v18 = a4[5];
  v19 = a4[7];
  v12[6] = a4[6];
  v12[7] = v19;
  v12[4] = v17;
  v12[5] = v18;
  v20 = a4[8];
  v21 = a4[9];
  v22 = a4[11];
  v12[10] = a4[10];
  v12[11] = v22;
  v12[8] = v20;
  v12[9] = v21;
  v23 = (const void *)*((_QWORD *)v12 + 12);
  if (v23)
    CFRetain(v23);
  *((_QWORD *)v13 + 26) = a1;
  *((_QWORD *)v13 + 27) = a2;
  v24 = *a5;
  *((_DWORD *)v13 + 50) = *((_DWORD *)a5 + 2);
  *((_QWORD *)v13 + 24) = v24;
  v25 = operator new();
  *(_QWORD *)v25 = a1;
  *(_QWORD *)(v25 + 8) = a2;
  v27 = *((_QWORD *)a4 + 16);
  v26 = *((_QWORD *)a4 + 17);
  *(_DWORD *)(v25 + 16) = *((_QWORD *)a4 + 8);
  *(_DWORD *)(v25 + 20) = v26;
  *(_DWORD *)(v25 + 24) = v27;
  *(_QWORD *)(v25 + 32) = 0;
  *((_QWORD *)v13 + 31) = v25;
  kdu_image_in::AllocateSrcLineBuffer((kdu_image_in *)v25);
  kdu_image_in::SetChannelOffsets(*((_QWORD *)v13 + 31), *((_DWORD *)a4 + 27));
  v28 = operator new();
  *(_QWORD *)v28 = &off_1E1BB0018;
  *(_QWORD *)(v28 + 8) = 0;
  *(_QWORD *)(v28 + 16) = 0;
  *(_QWORD *)(v28 + 24) = 0;
  *(_BYTE *)(v28 + 32) = 0;
  *((_QWORD *)v13 + 29) = v28;
  v29 = (kdu_compressed_target *)operator new();
  *(_QWORD *)v29 = &off_1E1BB2258;
  *((_QWORD *)v29 + 1) = a3;
  *((_QWORD *)v29 + 2) = 0;
  *((_QWORD *)v13 + 28) = v29;
  jp2_family_tgt::open(*((_QWORD *)v13 + 29), v29);
  v30 = (jp2_target *)operator new();
  jp2_target::jp2_target(v30);
  v31 = *((_QWORD *)v13 + 30);
  *((_QWORD *)v13 + 30) = v30;
  if (v31)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
    v30 = (jp2_target *)*((_QWORD *)v13 + 30);
  }
  (*(void (**)(jp2_target *, _QWORD))(*(_QWORD *)v30 + 96))(v30, *((_QWORD *)v13 + 29));
  return 0;
}

void sub_188056F98(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C405E65678DLL);
  _Unwind_Resume(a1);
}

uint64_t kdu_image_in::AllocateSrcLineBuffer(kdu_image_in *this)
{
  uint64_t result;

  if (*((int *)this + 5) <= 0)
    kdu_image_in::AllocateSrcLineBuffer();
  result = operator new[]();
  *((_QWORD *)this + 4) = result;
  return result;
}

uint64_t kdu_image_in::SetChannelOffsets(uint64_t result, int a2)
{
  *(_OWORD *)(result + 40) = xmmword_18822D850;
  switch(a2)
  {
    case 2:
      goto LABEL_4;
    case 6:
LABEL_5:
      *(_QWORD *)(result + 40) = 0x200000001;
      *(_DWORD *)(result + 48) = 3;
      return result;
    case 4:
LABEL_4:
      *(_DWORD *)(result + 52) = 0;
      goto LABEL_5;
  }
  if ((a2 & 0xFFFFFFFD) == 1)
    *(_DWORD *)(result + 52) = 3;
  return result;
}

uint64_t _cg_JP2CompressorTearDown(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 232);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *(const void **)(a1 + 96);
  if (v3)
    CFRelease(v3);
  kdu_image_in::DeallocateSrcLineBuffer(*(kdu_image_in **)(a1 + 248));
  v4 = *(_QWORD *)(a1 + 248);
  if (v4)
    MEMORY[0x18D761C30](v4, 0x1090C40459A9DE1);
  v5 = *(_QWORD *)(a1 + 224);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  free((void *)a1);
  return 0;
}

uint64_t kdu_image_in::DeallocateSrcLineBuffer(kdu_image_in *this)
{
  uint64_t v2;
  uint64_t result;

  v2 = *((_QWORD *)this + 4);
  if (!v2)
    kdu_image_in::DeallocateSrcLineBuffer();
  result = MEMORY[0x18D761C18](v2, 0x1000C8077774924);
  *((_QWORD *)this + 4) = 0;
  return result;
}

uint64_t kdu_image_in::get(uint64_t a1, int a2, uint64_t a3, double a4, float a5)
{
  int v5;
  int v6;
  _BYTE *v7;
  _WORD *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;

  v5 = *(_DWORD *)(a1 + 24) / 8;
  v6 = *(_DWORD *)a3;
  v7 = (_BYTE *)(*(_QWORD *)(a1 + 32) + *(int *)(a1 + 4 * a2 + 40));
  v8 = *(_WORD **)(a3 + 8);
  if ((*(_BYTE *)(a3 + 6) & 2) != 0 || !v8)
  {
    if ((*(_BYTE *)(a3 + 6) & 1) != 0)
    {
      if (v6 >= 1)
      {
        v11 = v6 + 1;
        do
        {
          *v8++ = *v7 - 128;
          v7 += v5;
          --v11;
        }
        while (v11 > 1);
      }
    }
    else if (v6 >= 1)
    {
      v10 = v6 + 1;
      do
      {
        *v8++ = 32 * *v7 - 4096;
        v7 += v5;
        --v10;
      }
      while (v10 > 1);
    }
  }
  else if ((*(_BYTE *)(a3 + 6) & 1) != 0)
  {
    if (v6 >= 1)
    {
      v12 = v6 + 1;
      do
      {
        *(_DWORD *)v8 = *v7 - 128;
        v8 += 2;
        v7 += v5;
        --v12;
      }
      while (v12 > 1);
    }
  }
  else if (v6 >= 1)
  {
    v9 = v6 + 1;
    do
    {
      LOBYTE(a5) = *v7;
      a5 = (float)((float)LODWORD(a5) * 0.0039062) + -0.5;
      *(float *)v8 = a5;
      v8 += 2;
      v7 += v5;
      --v9;
    }
    while (v9 > 1);
  }
  return 1;
}

uint64_t _cg_JP2CompressorProcessImage(uint64_t a1)
{
  int *v2;
  int *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  const __CFData *v7;
  unsigned __int8 *BytePtr;
  unsigned int Length;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int num_colours;
  unsigned int i;
  unsigned int v16;
  unsigned int v17;
  int v18;
  kd_codestream *v19;
  kdu_params *v20;
  kdu_params *v21;
  char is_opponent_space;
  char v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  kdu_params *v27;
  unint64_t v28;
  int v29;
  unint64_t v30;
  kdu_params *v31;
  uint64_t v32;
  kdu_params *v33;
  kdu_params *v34;
  kdu_params *v35;
  kdu_params *v36;
  kdu_params *v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  kdc_flow_control *v47;
  uint64_t v48;
  jp2_family_tgt *v49;
  int v51;
  int v52;
  int v53;
  char v54;
  kdu_params *v55;
  BOOL v59;
  uint64_t v60;
  __int16 *v61;
  uint64_t *v62;
  int32x4_t v63;
  kd_codestream *v64;
  uint64_t v65;
  _OWORD v66[9];
  uint64_t v67;
  kd_codestream *v68;
  BOOL v69;
  int v70;
  BOOL v71[4];
  BOOL v72[4];

  v2 = (int *)*(unsigned int *)(a1 + 64);
  v3 = (int *)*(unsigned int *)(a1 + 72);
  v4 = *(_QWORD *)(a1 + 232);
  if (*(_QWORD *)(v4 + 8) || *(_QWORD *)(v4 + 16))
  {
    v67 = 0;
    memset(v66, 0, sizeof(v66));
    siz_params::siz_params((siz_params *)v66);
    kdu_params::set((kdu_params *)v66, "Scomponents", 0, 0, (int *)*(unsigned int *)(a1 + 120));
    kdu_params::set((kdu_params *)v66, "Sdims", 0, 0, (int *)*(unsigned int *)(a1 + 72));
    kdu_params::set((kdu_params *)v66, "Sdims", 0, 1, (int *)*(unsigned int *)(a1 + 64));
    kdu_params::set((kdu_params *)v66, "Sprecision", 0, 0, (int *)8);
    kdu_params::set((uint64_t)v66, "Ssigned", 0, 0, 0);
    kdu_params::set((kdu_params *)v66, "Stiles", 0, 0, v3);
    kdu_params::set((kdu_params *)v66, "Stiles", 0, 1, v2);
    kdu_params::set((kdu_params *)v66, "Stile_origin", 0, 0, 0);
    kdu_params::set((kdu_params *)v66, "Stile_origin", 0, 1, 0);
    (*(void (**)(_OWORD *, _QWORD))(*(_QWORD *)&v66[0] + 72))(v66, 0);
    v65 = 0;
    v65 = jp2_target::access_dimensions(*(jp2_target **)(a1 + 240));
    jp2_target::access_resolution(*(jp2_target **)(a1 + 240));
    v5 = jp2_target::access_channels(*(jp2_target **)(a1 + 240));
    v64 = 0;
    v64 = (kd_codestream *)jp2_target::access_colour(*(jp2_target **)(a1 + 240));
    if (*(_QWORD *)(a1 + 120))
    {
      v6 = 0;
      do
      {
        kdu_params::set((kdu_params *)v66, "Sdims", v6, 0, (int *)*(unsigned int *)(a1 + 72));
        kdu_params::set((kdu_params *)v66, "Sdims", v6, 1, (int *)*(unsigned int *)(a1 + 64));
        kdu_params::set((kdu_params *)v66, "Sprecision", v6, 0, (int *)8);
        kdu_params::set((uint64_t)v66, "Ssigned", v6++, 0, 0);
      }
      while (*(_QWORD *)(a1 + 120) > v6);
    }
    (*(void (**)(_OWORD *, _QWORD))(*(_QWORD *)&v66[0] + 72))(v66, 0);
    jp2_dimensions::init((jp2_dimensions *)&v65, (siz_params *)v66, 1u);
    v7 = *(const __CFData **)(a1 + 96);
    if (v7)
    {
      BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v7);
      Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
      jp2_colour::init((jp2_colour *)&v64, BytePtr, Length);
    }
    else
    {
      v10 = *(_QWORD *)(a1 + 88);
      if (v10 == 1)
      {
        v11 = 17;
      }
      else
      {
        if (v10 != 3)
        {
          fwrite("Error: Unsupported color model for JPEG2000 compression.\n", 0x39uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
          v12 = 0xFFFFFFFFLL;
LABEL_80:
          kdu_params::~kdu_params((kdu_params *)v66);
          return v12;
        }
        v11 = 16;
      }
      jp2_colour::init((uint64_t *)&v64, v11);
    }
    v13 = *(_DWORD *)(a1 + 108);
    v63.i64[0] = v5;
    v68 = v64;
    num_colours = jp2_colour::get_num_colours((jp2_colour *)&v68);
    if (v13 <= 6 && ((1 << v13) & 0x61) != 0)
    {
      jp2_channels::init((jp2_channels *)&v63, num_colours);
      if (num_colours >= 1)
      {
        for (i = 0; i != num_colours; ++i)
          jp2_channels::set_colour_mapping(v63.i64, i, i, -1, 0);
      }
    }
    else
    {
      jp2_channels::init((jp2_channels *)&v63, num_colours);
      if (num_colours >= 1)
      {
        v16 = 0;
        v17 = v13 - 1;
        do
        {
          jp2_channels::set_colour_mapping(v63.i64, v16, v16, -1, 0);
          jp2_channels::set_opacity_mapping(v63.i64, v16, num_colours, -1, 0);
          if (v17 <= 1)
            jp2_channels::set_premult_mapping(v63.i64, v16, num_colours, -1, 0);
          ++v16;
        }
        while (num_colours != v16);
      }
    }
    v68 = 0;
    kdu_codestream::create(&v68, (siz_params *)v66, *(kdu_compressed_target **)(a1 + 240), 0, 0, 0);
    v18 = *(unsigned __int16 *)(a1 + 192);
    v19 = v64;
    v20 = (kdu_params *)kdu_codestream::access_siz((kdu_codestream *)&v68);
    v63.i64[0] = (uint64_t)v19;
    v21 = (kdu_params *)kdu_params::access_cluster(v20, "COD");
    if (!v21)
      __assert_rtn("set_jp2_coding_defaults", "JP2LibCompress.cpp", 352, "cod != NULL");
    *(_DWORD *)v72 = 0;
    kdu_params::get(v20, "Mcomponents", 0, 0, (int *)v72, 1, 1, 1);
    v71[0] = 0;
    if ((int)jp2_colour::get_num_colours((jp2_colour *)&v63) >= 3)
    {
      is_opponent_space = jp2_colour::is_opponent_space((jp2_colour *)&v63);
      if (*(_DWORD *)v72)
        v23 = 0;
      else
        v23 = is_opponent_space;
      if ((v23 & 1) == 0)
        goto LABEL_35;
    }
    else if (*(_DWORD *)v72)
    {
      goto LABEL_35;
    }
    if ((kdu_params::get(v21, "Cycc", 0, 0, v71, 1, 1, 1) & 1) == 0)
    {
      v71[0] = 0;
      kdu_params::set((uint64_t)v21, "Cycc", 0, 0, 0);
    }
LABEL_35:
    kdu_params::set((uint64_t)v21, "Creversible", 0, 0, v18 == 0);
    v25 = *(_QWORD *)(a1 + 64);
    v24 = *(_QWORD *)(a1 + 72);
    v26 = *(unsigned __int16 *)(a1 + 196);
    v27 = (kdu_params *)kdu_codestream::access_siz((kdu_codestream *)&v68);
    v28 = v25 * v24;
    if ((uint64_t)v28 > 1024)
    {
      if (v28 > 0x1000)
      {
        if (v26 <= 64)
          v29 = 64;
        else
          v29 = v26;
        if (v28 <= 0x4000)
          v26 = v29;
      }
      else if (v26 <= 256)
      {
        v26 = 256;
      }
      v62 = (uint64_t *)operator new[]();
      if (v26 <= 0x3FF)
      {
        v30 = vcvtmd_s64_f64(((double)v26 * 0.0078125 + 0.01) * (double)(v28 >> 3));
LABEL_48:
        *v62 = v30;
        v31 = (kdu_params *)kdu_params::access_cluster(v27, "COD");
        if (!v31)
          __assert_rtn("assign_layer_bytes", "JP2LibCompress.cpp", 440, "cod != NULL");
        kdu_params::set(v31, "Clayers", 0, 0, (int *)1);
        v32 = *(unsigned int *)(a1 + 200);
        if ((_DWORD)v32)
          *v62 = v32;
        v61 = (__int16 *)operator new[]();
        *v61 = 0;
        if (*v62 >= 1)
          kdu_codestream::set_max_bytes((kdu_codestream *)&v68, *v62, 0, 1);
        if (*(_QWORD *)(a1 + 120) >= 3uLL)
        {
          v33 = (kdu_params *)kdu_codestream::access_siz((kdu_codestream *)&v68);
          v34 = (kdu_params *)kdu_params::access_cluster(v33, "COD");
          v35 = v34;
          if (!v34)
            __assert_rtn("set_default_colour_weights", "JP2LibCompress.cpp", 463, "cod != NULL");
          v63.i32[0] = 0;
          if ((kdu_params::get(v34, "Clev_weights", 0, 0, (float *)v63.i32, 1, 1, 1) & 1) == 0
            && (kdu_params::get(v35, "Cband_weights", 0, 0, (float *)v63.i32, 1, 1, 1) & 1) == 0)
          {
            v51 = 0;
            v60 = 0;
            v52 = 1;
            v53 = 1;
            v54 = 1;
            while (1)
            {
              *(_DWORD *)v72 = 0;
              kdu_params::get(v33, "Sprecision", v51, 0, (int *)v72, 1, 1, 1);
              *(_DWORD *)v71 = 1;
              kdu_params::get(v33, "Ssampling", v51, 0, (int *)v71, 1, 1, 1);
              v70 = 1;
              kdu_params::get(v33, "Ssampling", v51, 1, &v70, 1, 1, 1);
              v55 = (kdu_params *)kdu_params::access_relation(v35, -1, v51, 0, 1);
              if ((kdu_params::get(v55, "Clev_weights", 0, 0, (float *)v63.i32, 1, 1, 1) & 1) != 0
                || (kdu_params::get(v55, "Cband_weights", 0, 0, (float *)v63.i32, 1, 1, 1) & 1) != 0)
              {
                break;
              }
              v69 = 0;
              kdu_params::get(v55, "Creversible", 0, 0, &v69, 1, 1, 1);
              if (v51)
              {
                v59 = v69 == (BYTE4(v60) & 1) && *(_DWORD *)v72 == (_DWORD)v60 && v70 == v53 && *(_DWORD *)v71 == v52;
                v54 &= v59;
              }
              else
              {
                v52 = *(_DWORD *)v71;
                LODWORD(v60) = *(_DWORD *)v72;
                BYTE4(v60) = v69;
                v53 = v70;
              }
              if (++v51 == 3)
              {
                if ((v54 & 1) != 0)
                {
                  v72[0] = 0;
                  if ((kdu_params::get(v35, "Cycc", 0, 0, v72, 1, 1, 1) & 1) == 0)
                  {
                    v72[0] = 1;
                    kdu_params::set((uint64_t)v35, "Cycc", 0, 0, 1);
                  }
                  if (v72[0])
                  {
                    kdu_params::parse_string(v35, "Cband_weights:C0={0.0901},{0.2758},{0.2758},{0.7018},{0.8378},{0.8378},{1}");
                    kdu_params::parse_string(v35, "Cband_weights:C1={0.0263},{0.0863},{0.0863},{0.1362},{0.2564},{0.2564},{0.3346},{0.4691},{0.4691},{0.5444},{0.6523},{0.6523},{0.7078},{0.7797},{0.7797},{1}");
                    kdu_params::parse_string(v35, "Cband_weights:C2={0.0773},{0.1835},{0.1835},{0.2598},{0.4130},{0.4130},{0.5040},{0.6464},{0.6464},{0.7220},{0.8254},{0.8254},{0.8769},{0.9424},{0.9424},{1}");
                  }
                }
                break;
              }
            }
          }
        }
        v36 = (kdu_params *)kdu_codestream::access_siz((kdu_codestream *)&v68);
        kdu_params::finalize_all(v36, 0);
        v37 = (kdu_params *)kdu_codestream::access_siz((kdu_codestream *)&v68);
        jp2_dimensions::finalize_compatibility((uint64_t)&v65, v37);
        kdu_codestream::change_appearance((uint64_t *)&v68, 0, 0, 0);
        jp2_target::write_header(*(jp2_target **)(a1 + 240));
        jp2_target::open_codestream(*(jp2_target **)(a1 + 240), 1);
        v63 = 0uLL;
        kdu_codestream::get_valid_tiles((kdu_codestream *)&v68, &v63);
        v38 = operator new[]();
        v39 = v63.i32[3];
        if (v63.i64[1] > 0)
        {
          v40 = 0;
          do
          {
            v41 = operator new();
            kdc_flow_control::kdc_flow_control(v41, *(_QWORD *)(a1 + 248), v68, v40, 1, 0);
            *(_QWORD *)(v38 + 8 * v40++) = v41;
            v39 = v63.i32[3];
          }
          while (v40 < v63.i32[3]);
        }
        v42 = 0;
        v43 = 1;
        while (1)
        {
          do
          {
            while (1)
            {
              v44 = v43;
              if ((int)v42 >= v39)
                break;
              v47 = *(kdc_flow_control **)(v38 + 8 * v42);
              if (kdc_flow_control::advance_components(v47))
              {
                kdc_flow_control::process_components((uint64_t)v47);
                v44 = 0;
              }
              ++v42;
              v39 = v63.i32[3];
              v43 = v44;
            }
            v42 = 0;
            v43 = 1;
          }
          while ((v44 & 1) == 0);
          if (v39 < 1)
            break;
          v45 = 0;
          v46 = 1;
          do
          {
            v46 &= kdc_flow_control::advance_tile(*(kdc_flow_control **)(v38 + 8 * v45++)) ^ 1;
            v39 = v63.i32[3];
          }
          while (v45 < v63.i32[3]);
          v42 = 0;
          v43 = 1;
          if (v46)
          {
            if (v63.i32[3] >= 1)
            {
              v48 = 0;
              do
              {
                kdc_flow_control::~kdc_flow_control(*(kdc_flow_control **)(v38 + 8 * v48));
                MEMORY[0x18D761C30]();
                ++v48;
              }
              while (v48 < v63.i32[3]);
            }
            break;
          }
        }
        MEMORY[0x18D761C18](v38, 0x20C8093837F09);
        if (kdu_codestream::ready_for_flush((uint64_t *)&v68, 0))
          kdu_codestream::flush((uint64_t *)&v68, v62, 1u, v61, 1, 0, 0, 0.0);
        MEMORY[0x18D761C18](v62, 0x1000C8000313F17);
        MEMORY[0x18D761C18](v61, 0x1000C80BDFB0063);
        kdu_codestream::destroy(&v68);
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 240) + 16))(*(_QWORD *)(a1 + 240));
        v49 = *(jp2_family_tgt **)(a1 + 232);
        if (*((_QWORD *)v49 + 1) || *((_QWORD *)v49 + 2))
          jp2_family_tgt::close(v49);
        v12 = 0;
        goto LABEL_80;
      }
    }
    else
    {
      v62 = (uint64_t *)operator new[]();
    }
    v30 = 0;
    goto LABEL_48;
  }
  return 0xFFFFFFFFLL;
}

void sub_188057DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  kdu_params::~kdu_params((kdu_params *)va);
  _Unwind_Resume(a1);
}

float **_cg_JP2CompressorSetDisplayResolution(uint64_t a1, float a2, float a3)
{
  float *v6;

  v6 = (float *)jp2_target::access_resolution(*(jp2_target **)(a1 + 240));
  jp2_resolution::init((jp2_resolution *)&v6, a2 / a3);
  return jp2_resolution::set_resolution(&v6, a2, 1);
}

void jp2_family_tgt::~jp2_family_tgt(jp2_family_tgt *this)
{
  *(_QWORD *)this = &off_1E1BB0018;
  jp2_family_tgt::close(this);
}

{
  *(_QWORD *)this = &off_1E1BB0018;
  jp2_family_tgt::close(this);
  JUMPOUT(0x18D761C30);
}

void MyJP2CompressedTarget::~MyJP2CompressedTarget(MyJP2CompressedTarget *this)
{
  *(_QWORD *)this = off_1E1BB2398;
}

{
  *(_QWORD *)this = off_1E1BB2398;
  JUMPOUT(0x18D761C30);
}

BOOL MyJP2CompressedTarget::write(MyJP2CompressedTarget *this, const unsigned __int8 *a2, int a3)
{
  uint64_t v5;

  v5 = (*(uint64_t (**)(_QWORD, const unsigned __int8 *, _QWORD))(*((_QWORD *)this + 1) + 40))(*(_QWORD *)(*((_QWORD *)this + 1) + 8), a2, a3);
  *((_QWORD *)this + 2) += v5;
  return v5 == a3;
}

void IIO_Writer_BMP::~IIO_Writer_BMP(IIO_Writer_BMP *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t IIO_Writer_BMP::write(IIO_Writer_BMP *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v3;
  _OWORD v5[3];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  BMPWritePlugin::BMPWritePlugin((BMPWritePlugin *)v5, a2, a3);
  v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v5);
  BMPWritePlugin::~BMPWritePlugin((BMPWritePlugin *)v5);
  return v3;
}

void sub_1880580E0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BMPWritePlugin::~BMPWritePlugin((BMPWritePlugin *)&a9);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1880580CCLL);
}

uint64_t IIOImageSource::IIOImageSource(uint64_t a1, const __CFData *a2, int a3)
{
  IIODictionary *v5;

  *(_QWORD *)a1 = &off_1E1BAE3E0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  IIOImageSource::setup(a1, a3);
  if (IIOImageSource::setupWithProxyData((IIOImageSource *)a1, a2, v5))
    *(_DWORD *)(a1 + 328) = -7;
  return a1;
}

void sub_18805817C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 184) = v5;
    operator delete(v5);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 128) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IIOImageSource::setupWithProxyData(IIOImageSource *this, const __CFData *a2, IIODictionary *a3)
{
  const __CFDictionary *v4;
  IIODictionary *v5;

  v4 = (const __CFDictionary *)CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0, 0, 0);
  v5 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v5, v4);
  *((_QWORD *)this + 13) = v5;
  if (v4)
  {
    CFRelease(v4);
    v5 = (IIODictionary *)*((_QWORD *)this + 13);
  }
  if ((IIODictionary::containsKey(v5, CFSTR("{iio-proxy-base}")) & 1) != 0)
  {
    if ((IIODictionary::containsKey(*((IIODictionary **)this + 13), CFSTR("{iio-proxy-containerProperties}")) & 1) != 0)
    {
      if (IIODictionary::getUint32ForKeyGroup(*((IIODictionary **)this + 13), CFSTR("iio-proxy-count"), CFSTR("{iio-proxy-base}")) < 2|| (IIODictionary::containsKey(*((IIODictionary **)this + 13), CFSTR("{iio-proxy-imageProperties}")) & 1) != 0)
      {
        return 0;
      }
      _cg_jpeg_mem_term("setupWithProxyData", 64, "*** ERROR: proxy image properties are missing\n");
    }
    else
    {
      _cg_jpeg_mem_term("setupWithProxyData", 61, "*** ERROR: container properties are missing\n");
    }
  }
  else
  {
    _cg_jpeg_mem_term("setupWithProxyData", 60, "*** ERROR: proxy base is missing\n");
  }
  return 4294967246;
}

void sub_1880582D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

BOOL IIOImageSource::isProxy(IIOImageSource *this)
{
  return *((_BYTE *)this + 54) == 7;
}

void IIOImageSource::addImageSourceProxyInfo(IIOImageSource *this, IIODictionary *a2, IIODictionary *a3)
{
  IIODictionary *Properties;
  IIODictionary *v5;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFDictionary *v8;
  _QWORD v9[5];
  _QWORD v10[3];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, uint64_t);
  void (*v15)(uint64_t);
  _QWORD v16[3];

  Properties = (IIODictionary *)IIOImageSource::getProperties(this, a3);
  if (Properties)
  {
    v5 = Properties;
    ObjectForKey = IIODictionary::getObjectForKey(Properties, CFSTR("{Groups}"));
    if (ObjectForKey)
      IIODictionary::setObjectForKey(a2, ObjectForKey, CFSTR("{Groups}"));
    ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(v5, CFSTR("ImageCount"), CFSTR("{FileContents}"));
    if (ObjectForKeyGroup)
    {
      IIODictionary::setObjectForKeyGroup(a2, ObjectForKeyGroup, CFSTR("ImageCount"), CFSTR("{FileContents}"));
      v11 = 0;
      v12 = &v11;
      v13 = 0x4002000000;
      v14 = __Block_byref_object_copy__2;
      v15 = __Block_byref_object_dispose__2;
      memset(v16, 0, sizeof(v16));
      IIOArray::IIOArray((IIOArray *)v16);
      IIODictionary::setObjectForKeyGroup(a2, (const void *)v12[6], CFSTR("Images"), CFSTR("{FileContents}"));
      v8 = IIODictionary::getObjectForKeyGroup(v5, CFSTR("Images"), CFSTR("{FileContents}"));
      memset(v10, 0, sizeof(v10));
      IIOArray::IIOArray((IIOArray *)v10, v8);
      v9[0] = MEMORY[0x1E0C809B0];
      v9[1] = 0x40000000;
      v9[2] = ___ZN14IIOImageSource23addImageSourceProxyInfoEP13IIODictionaryS1__block_invoke;
      v9[3] = &unk_1E1BCA4B0;
      v9[4] = &v11;
      IIOArray::enumerate((uint64_t)v10, (uint64_t)v9);
      IIOArray::~IIOArray((IIOArray *)v10);
      _Block_object_dispose(&v11, 8);
      IIOArray::~IIOArray((IIOArray *)v16);
    }
  }
}

void sub_188058498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  IIOArray *v6;
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  IIOArray::~IIOArray((IIOArray *)va);
  _Block_object_dispose(va1, 8);
  IIOArray::~IIOArray(v6);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)(result + 40) = &off_1E1BB2B40;
  v2 = *(_QWORD *)(a2 + 48);
  *(_BYTE *)(result + 56) = *(_BYTE *)(a2 + 56);
  *(_QWORD *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  IIOArray::~IIOArray((IIOArray *)(a1 + 40));
}

void ___ZN14IIOImageSource23addImageSourceProxyInfoEP13IIODictionaryS1__block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v4;
  _QWORD v5[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  void (*v10)(uint64_t);
  _QWORD v11[3];
  _QWORD v12[3];
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  _QWORD v16[3];

  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, a2);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v13);
  IIOArray::addObject((CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v14);
  ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v16, CFSTR("AuxiliaryData"));
  if (ObjectForKey)
  {
    memset(v12, 0, sizeof(v12));
    IIOArray::IIOArray((IIOArray *)v12, ObjectForKey);
    v6 = 0;
    v7 = &v6;
    v8 = 0x4002000000;
    v9 = __Block_byref_object_copy__2;
    v10 = __Block_byref_object_dispose__2;
    memset(v11, 0, sizeof(v11));
    IIOArray::IIOArray((IIOArray *)v11);
    IIODictionary::setObjectForKey((IIODictionary *)&v13, (const void *)v7[6], CFSTR("AuxiliaryData"));
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 0x40000000;
    v5[2] = ___ZN14IIOImageSource23addImageSourceProxyInfoEP13IIODictionaryS1__block_invoke_2;
    v5[3] = &unk_1E1BBD498;
    v5[4] = &v6;
    IIOArray::enumerate((uint64_t)v12, (uint64_t)v5);
    _Block_object_dispose(&v6, 8);
    IIOArray::~IIOArray((IIOArray *)v11);
    IIOArray::~IIOArray((IIOArray *)v12);
  }
  v4 = IIODictionary::getObjectForKey((IIODictionary *)v16, CFSTR("NamedColorSpace"));
  IIODictionary::setObjectForKey((IIODictionary *)&v13, v4, CFSTR("NamedColorSpace"));
  IIODictionary::~IIODictionary((IIODictionary *)&v13);
  IIODictionary::~IIODictionary((IIODictionary *)v16);
}

void sub_188058668(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIOArray::~IIOArray((IIOArray *)(v1 - 88));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 64));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 40));
  _Unwind_Resume(a1);
}

void ___ZN14IIOImageSource23addImageSourceProxyInfoEP13IIODictionaryS1__block_invoke_2(uint64_t a1, const __CFDictionary *a2)
{
  const __CFDictionary *ObjectForKey;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  _QWORD v7[3];

  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a2);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v4);
  ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v7, CFSTR("AuxiliaryDataType"));
  IIODictionary::setObjectForKey((IIODictionary *)&v4, ObjectForKey, CFSTR("AuxiliaryDataType"));
  IIOArray::addObject((CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v5);
  IIODictionary::~IIODictionary((IIODictionary *)&v4);
  IIODictionary::~IIODictionary((IIODictionary *)v7);
}

void sub_188058750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIOImageSource::addImageSourceAtIndexProxyInfo(IIOImageSource *this, IIODictionary *a2, unsigned int a3, const __CFDictionary **a4)
{
  IIODictionary *PropertiesAtIndexInternal;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;

  PropertiesAtIndexInternal = IIOImageSource::getPropertiesAtIndexInternal(this, a3, a4);
  ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, CFSTR("23"), CFSTR("{MakerApple}"));
  if (ObjectForKeyGroup)
    IIODictionary::setObjectForKeyGroup(a2, ObjectForKeyGroup, CFSTR("23"), CFSTR("{MakerApple}"));
  v7 = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, CFSTR("25"), CFSTR("{MakerApple}"));
  if (v7)
    IIODictionary::setObjectForKeyGroup(a2, v7, CFSTR("25"), CFSTR("{MakerApple}"));
  v8 = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, CFSTR("87"), CFSTR("{MakerApple}"));
  if (v8)
    IIODictionary::setObjectForKeyGroup(a2, v8, CFSTR("87"), CFSTR("{MakerApple}"));
  v9 = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, CFSTR("CameraExtrinsics"), CFSTR("{HEIF}"));
  if (v9)
    IIODictionary::setObjectForKeyGroup(a2, v9, CFSTR("CameraExtrinsics"), CFSTR("{HEIF}"));
  v10 = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, CFSTR("CameraModel"), CFSTR("{HEIF}"));
  if (v10)
    IIODictionary::setObjectForKeyGroup(a2, v10, CFSTR("CameraModel"), CFSTR("{HEIF}"));
}

CFDataRef IIOImageSource::createProxyData(IIO_Reader **this, const __CFDictionary **a2)
{
  const void *Type;
  unint64_t v5;
  unsigned int PrimaryImageIndex;
  IIODictionary *PropertiesAtIndexInternal;
  unsigned int v8;
  CFDataRef v9;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  CFErrorRef error;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  void *value;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  _QWORD v23[3];
  uint64_t v24;
  CFPropertyListRef v25;
  uint64_t v26;

  Type = (const void *)IIOImageSource::getType(this);
  v5 = IIOImageSource::updatedCount((IIOImageSource *)this);
  PrimaryImageIndex = IIOImageSource::getPrimaryImageIndex(this);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  PropertiesAtIndexInternal = IIOImageSource::getPropertiesAtIndexInternal((IIOImageSource *)this, 0, a2);
  IIODictionary::IIODictionary((IIODictionary *)&v24, *((const __CFDictionary **)PropertiesAtIndexInternal + 1), 1);
  memset(v23, 0, sizeof(v23));
  IIODictionary::IIODictionary((IIODictionary *)v23);
  v20 = 0;
  v21 = 0;
  v22 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v20);
  IIONumber::IIONumber((IIONumber *)&v17, 1.0);
  IIODictionary::setObjectForKey((IIODictionary *)&v20, value, CFSTR("iio-proxy-version"));
  IIONumber::~IIONumber((IIONumber *)&v17);
  IIODictionary::setObjectForKey((IIODictionary *)&v20, Type, CFSTR("iio-proxy-isrType"));
  IIONumber::IIONumber((IIONumber *)&v17, v5);
  IIODictionary::setObjectForKey((IIODictionary *)&v20, value, CFSTR("iio-proxy-count"));
  IIONumber::~IIONumber((IIONumber *)&v17);
  IIONumber::IIONumber((IIONumber *)&v17, PrimaryImageIndex);
  IIODictionary::setObjectForKey((IIODictionary *)&v20, value, CFSTR("iio-primary_index"));
  IIONumber::~IIONumber((IIONumber *)&v17);
  IIODictionary::setObjectForKey((IIODictionary *)&v24, v21, CFSTR("{iio-proxy-base}"));
  v17 = 0;
  v18 = 0;
  value = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v17);
  IIOImageSource::addImageSourceProxyInfo((IIOImageSource *)this, (IIODictionary *)&v17, (IIODictionary *)a2);
  IIODictionary::setObjectForKey((IIODictionary *)&v24, v18, CFSTR("{iio-proxy-containerProperties}"));
  if (v5 >= 2)
  {
    error = 0;
    v15 = 0;
    v16 = 0;
    IIOArray::IIOArray((IIOArray *)&error);
    if ((_DWORD)v5)
    {
      v8 = 0;
      do
      {
        v11 = 0;
        v12 = 0;
        v13 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v11);
        if (v8)
          IIOImageSource::addImageSourceAtIndexProxyInfo((IIOImageSource *)this, (IIODictionary *)&v11, v8, a2);
        IIOArray::addObject(&error, v12);
        IIODictionary::~IIODictionary((IIODictionary *)&v11);
        ++v8;
      }
      while ((_DWORD)v5 != v8);
    }
    IIODictionary::setObjectForKey((IIODictionary *)&v24, v15, CFSTR("{iio-proxy-imageProperties}"));
    IIOArray::~IIOArray((IIOArray *)&error);
  }
  error = 0;
  v9 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v25, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  IIODictionary::~IIODictionary((IIODictionary *)&v17);
  IIODictionary::~IIODictionary((IIODictionary *)&v20);
  IIODictionary::~IIODictionary((IIODictionary *)v23);
  IIODictionary::~IIODictionary((IIODictionary *)&v24);
  return v9;
}

void sub_188058B08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va2;
  uint64_t v16;
  uint64_t v17;
  va_list va3;

  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v10 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v14 = va_arg(va3, _QWORD);
  v16 = va_arg(va3, _QWORD);
  v17 = va_arg(va3, _QWORD);
  IIOArray::~IIOArray((IIOArray *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  IIODictionary::~IIODictionary((IIODictionary *)va3);
  IIODictionary::~IIODictionary((IIODictionary *)(v4 - 72));
  _Unwind_Resume(a1);
}

const __CFDictionary *IIOImageSource::proxyGetType(IIODictionary **this)
{
  return IIODictionary::getObjectForKeyGroup(this[13], CFSTR("iio-proxy-isrType"), CFSTR("{iio-proxy-base}"));
}

uint64_t IIOImageSource::proxyGetCount(IIODictionary **this)
{
  return IIODictionary::getUint32ForKeyGroup(this[13], CFSTR("iio-proxy-count"), CFSTR("{iio-proxy-base}"));
}

CFTypeRef IIOImageSource::proxyCopyProperties(IIODictionary **this, IIODictionary *a2)
{
  const __CFDictionary *ObjectForKey;

  ObjectForKey = IIODictionary::getObjectForKey(this[13], CFSTR("{iio-proxy-containerProperties}"));
  return CFRetain(ObjectForKey);
}

CFTypeRef IIOImageSource::proxyCopyPropertiesAtIndex(IIODictionary **this, unint64_t a2, IIODictionary *a3)
{
  const __CFDictionary *ObjectForKey;
  const void *ValueAtIndex;
  CFTypeRef v7;
  uint64_t v8;
  CFTypeRef cf;
  uint64_t v10;

  if (a2)
  {
    ObjectForKey = IIODictionary::getObjectForKey(this[13], CFSTR("{iio-proxy-imageProperties}"));
    if (CFArrayGetCount(ObjectForKey) > a2)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(ObjectForKey, a2);
      return CFRetain(ValueAtIndex);
    }
    return 0;
  }
  else
  {
    cf = 0;
    v10 = 0;
    v8 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v8, *((const __CFDictionary **)this[13] + 1), 0);
    IIODictionary::removeObjectForKey((IIODictionary *)&v8, CFSTR("{iio-proxy-base}"));
    IIODictionary::removeObjectForKey((IIODictionary *)&v8, CFSTR("{iio-proxy-containerProperties}"));
    IIODictionary::removeObjectForKey((IIODictionary *)&v8, CFSTR("{iio-proxy-imageProperties}"));
    v7 = CFRetain(cf);
    IIODictionary::~IIODictionary((IIODictionary *)&v8);
  }
  return v7;
}

void sub_188058CD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIOImageSource::proxyGetPrimaryImageIndex(IIODictionary **this)
{
  return IIODictionary::getUint32ForKeyGroup(this[13], CFSTR("iio-primary_index"), CFSTR("{iio-proxy-base}"));
}

CFDataRef CGImageSourceCreateProxyData(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t Source;
  IIOImageSource *v5;
  CFDataRef ProxyData;
  const __CFDictionary *v8[3];

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCreateProxyData", 0, 0, -1, 0);
  if (!a1)
  {
    LogError("CGImageSourceCreateProxyData", 291, "*** ERROR: CGImageSourceCopyProxyPropertyList: source is NULL\n");
    return 0;
  }
  Source = CGImageSourceGetSource(a1);
  if (!Source)
    return 0;
  v5 = (IIOImageSource *)Source;
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  IIOImageSource::lock(v5);
  ProxyData = IIOImageSource::createProxyData((IIO_Reader **)v5, v8);
  IIOImageSource::unlock(v5);
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return ProxyData;
}

void sub_188058DD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageSourceCreateWithProxyData(const void *a1, const __CFDictionary *a2)
{
  CFTypeID v4;
  IIOImageSource *v5;
  uint64_t v6;
  _QWORD v8[3];

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCreateWithProxyData", 0, 0, -1, 0);
  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFDataGetTypeID())
    {
      memset(v8, 0, sizeof(v8));
      IIODictionary::IIODictionary((IIODictionary *)v8, a2);
      v5 = (IIOImageSource *)operator new();
      IIOImageSource::IIOImageSource((uint64_t)v5, (const __CFData *)a1, 7);
      if (IIOImageSource::errorStatus(v5))
      {
        (*(void (**)(IIOImageSource *))(*(_QWORD *)v5 + 8))(v5);
        IIODictionary::~IIODictionary((IIODictionary *)v8);
      }
      else
      {
        IIOImageSource::lock(v5);
        v6 = CGImageSourceRefCreateWith_ImageSource((uint64_t)v5);
        IIOImageSource::unlock(v5);
        IIODictionary::~IIODictionary((IIODictionary *)v8);
        if (v6)
          goto LABEL_9;
      }
    }
    else
    {
      LogError("CGImageSourceCreateWithProxyData", 319, "*** ERROR: CGImageSourceCreateWithProxyData: data is not a CFDataRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceCreateWithProxyData", 318, "*** ERROR: CGImageSourceCreateWithProxyData: proxyData is NULL\n");
  }
  kdebug_trace();
  v6 = 0;
LABEL_9:
  kdebug_trace();
  return v6;
}

void sub_188058FC0(void *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x18D761C30](v2, 0x10E1C40B803A584);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x188058EF4);
}

BOOL CGImageSourceIsProxy(uint64_t a1)
{
  IIOImageSource *Source;
  unsigned __int8 *v3;
  _BOOL8 v4;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceIsProxy", 0, 0, -1, 0);
  if (!a1)
  {
    LogError("CGImageSourceIsProxy", 361, "*** ERROR: CGImageSourceIsProxy: source is NULL\n");
    return 0;
  }
  Source = (IIOImageSource *)CGImageSourceGetSource(a1);
  if (!Source)
    return 0;
  v3 = (unsigned __int8 *)Source;
  if (IIOImageSource::imageDataDidNotMatchRequestedHint(Source))
  {
    LogError("CGImageSourceIsProxy", 366, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    return 0;
  }
  IIOImageSource::lock((IIOImageSource *)v3);
  v4 = v3[54] == 7;
  IIOImageSource::unlock((IIOImageSource *)v3);
  return v4;
}

uint64_t _ImageGetNonAlphaInfo(CGImage *a1)
{
  return CGImageGetBitmapInfo(a1) & 0xFFFFFFE0;
}

uint64_t _ImageHasRealAlphaChannel(CGImage *a1)
{
  CGImageAlphaInfo AlphaInfo;

  AlphaInfo = CGImageGetAlphaInfo(a1);
  return (AlphaInfo > kCGImageAlphaNoneSkipFirst) | (0x1Eu >> AlphaInfo) & 1;
}

uint64_t _AlphaPosition(int a1)
{
  if ((a1 - 1) > 5)
    return 0;
  else
    return dword_18822D900[a1 - 1];
}

uint64_t _ImageAlphaPosition(CGImage *a1)
{
  unsigned __int32 v1;

  v1 = CGImageGetAlphaInfo(a1) - 1;
  if (v1 > 5)
    return 0;
  else
    return dword_18822D900[v1];
}

uint64_t _AlphaTogglePosition(uint64_t result)
{
  if ((result - 1) <= 5)
    return dword_18822D918[(int)result - 1];
  return result;
}

BOOL IIOChromaticitiesMatchLinearSRGB(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  return fabs(a1 + -0.3127) < 0.0005
      && fabs(a2 + -0.329) < 0.0005
      && fabs(a3 + -0.64) < 0.0005
      && fabs(a4 + -0.33) < 0.0005
      && fabs(a5 + -0.3) < 0.0005
      && fabs(a6 + -0.6) < 0.0005
      && fabs(a7 + -0.15) < 0.0005
      && fabs(a8 + -0.06) < 0.0005
      && fabs(a9 + -1.0) < 0.0005;
}

void IIOAddDateComponents(CFMutableArrayRef *a1)
{
  tm *v2;
  int tm_mday;
  int tm_mon;
  _BYTE v5[24];
  _BYTE v6[24];
  _BYTE v7[24];
  _BYTE v8[24];
  _BYTE v9[24];
  _BYTE v10[24];
  time_t v11;

  v11 = time(0);
  v2 = localtime(&v11);
  tm_mday = v2->tm_mday;
  tm_mon = v2->tm_mon;
  IIONumber::IIONumber((IIONumber *)v10, v2->tm_year + 1900);
  IIOArray::addObject(a1, (uint64_t)v10);
  IIONumber::~IIONumber((IIONumber *)v10);
  IIONumber::IIONumber((IIONumber *)v9, tm_mon + 1);
  IIOArray::addObject(a1, (uint64_t)v9);
  IIONumber::~IIONumber((IIONumber *)v9);
  IIONumber::IIONumber((IIONumber *)v8, tm_mday);
  IIOArray::addObject(a1, (uint64_t)v8);
  IIONumber::~IIONumber((IIONumber *)v8);
  IIONumber::IIONumber((IIONumber *)v7, 0);
  IIOArray::addObject(a1, (uint64_t)v7);
  IIONumber::~IIONumber((IIONumber *)v7);
  IIONumber::IIONumber((IIONumber *)v6, 0);
  IIOArray::addObject(a1, (uint64_t)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  IIONumber::IIONumber((IIONumber *)v5, 0);
  IIOArray::addObject(a1, (uint64_t)v5);
  IIONumber::~IIONumber((IIONumber *)v5);
}

void sub_1880593B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIOAddXYZfrom_xy(CFMutableArrayRef *a1, float a2, float a3, float a4)
{
  float v7;
  float v8;
  _BYTE v9[24];
  _BYTE v10[24];
  _BYTE v11[24];

  if (a3 == 0.0)
  {
    v7 = 0.0;
    a4 = 0.0;
    v8 = 0.0;
  }
  else
  {
    v7 = (float)(a2 * a4) / a3;
    v8 = (float)((float)((float)(1.0 - a2) - a3) * a4) / a3;
  }
  IIONumber::IIONumber((IIONumber *)v11, v7);
  IIOArray::addObject(a1, (uint64_t)v11);
  IIONumber::~IIONumber((IIONumber *)v11);
  IIONumber::IIONumber((IIONumber *)v10, a4);
  IIOArray::addObject(a1, (uint64_t)v10);
  IIONumber::~IIONumber((IIONumber *)v10);
  IIONumber::IIONumber((IIONumber *)v9, v8);
  IIOArray::addObject(a1, (uint64_t)v9);
  IIONumber::~IIONumber((IIONumber *)v9);
}

void sub_1880594C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_ConvertCGColorToColorComponents(CGColor *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  CGColorSpaceRef v6;
  CGColorSpaceRef v7;

  v3 = MEMORY[0x18D760DF0](a2, 0);
  if (!v3)
    return 0;
  v4 = (const void *)v3;
  if (a1)
  {
    CGColorGetColorSpace(a1);
    CGColorGetComponents(a1);
    v5 = CGColorTransformConvertColorComponents();
  }
  else
  {
    v6 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
    if (v6)
    {
      v7 = v6;
      v5 = CGColorTransformConvertColorComponents();
      CFRelease(v7);
    }
    else
    {
      v5 = 0;
    }
  }
  CFRelease(v4);
  return v5;
}

const char *IIO_CheckHeadroom(const char *result, int a2, CGImage *a3, IIODictionary *a4)
{
  float v7;
  float v8;
  CGColorSpace *ColorSpace;
  float v10;
  float v11;
  const __CFString *ObjectForKey;
  CFComparisonResult v13;
  CFComparisonResult v14;
  _BOOL4 v15;
  _BOOL4 v16;
  size_t Width;
  size_t Height;
  unsigned int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  _BOOL4 v31;
  int v32;
  _BOOL4 IsHDR;
  const char *v34;

  if ((gIIODebugFlags & 0x300000) != 0)
  {
    v34 = result;
    CGImageGetContentHeadroom();
    v8 = v7;
    ColorSpace = CGImageGetColorSpace(a3);
    CGColorSpaceGetHeadroomInfo();
    v11 = v10;
    IsHDR = CGColorSpaceIsHDR(ColorSpace);
    v31 = CGColorSpaceUsesExtendedRange(ColorSpace);
    v32 = CGColorSpaceContainsFlexGTCInfo();
    if (a4 && IIODictionary::containsKey(a4, CFSTR("kCGImageSourceDecodeRequest")))
    {
      ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a4, CFSTR("kCGImageSourceDecodeRequest"));
      v13 = CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToSDR"), 0);
      v14 = CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToHDR"), 0);
      if (v14)
        v15 = 1;
      else
        v15 = v13 == kCFCompareEqualTo;
      if (v13)
        v16 = v14 == kCFCompareEqualTo;
      else
        v16 = 0;
    }
    else
    {
      v16 = 0;
      v15 = 1;
    }
    Width = CGImageGetWidth(a3);
    Height = CGImageGetHeight(a3);
    v19 = a2 >> 24;
    v20 = MEMORY[0x1E0C80978];
    if (a2 < 0)
      v21 = __maskrune(a2 >> 24, 0x40000uLL);
    else
      v21 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v19 + 60) & 0x40000;
    if (v21)
      v22 = v19;
    else
      v22 = 46;
    v23 = a2 << 8 >> 24;
    if (a2 << 8 < 0)
      v24 = __maskrune(a2 << 8 >> 24, 0x40000uLL);
    else
      v24 = *(_DWORD *)(v20 + 4 * v23 + 60) & 0x40000;
    if (v24)
      v25 = v23;
    else
      v25 = 46;
    v26 = (__int16)a2 >> 8;
    if (a2 << 16 < 0)
      v27 = __maskrune((__int16)a2 >> 8, 0x40000uLL);
    else
      v27 = *(_DWORD *)(v20 + 4 * v26 + 60) & 0x40000;
    if (v27)
      v28 = v26;
    else
      v28 = 46;
    if ((a2 << 24) <= 0x7F000000)
      v29 = *(_DWORD *)(v20 + 4 * (char)a2 + 60) & 0x40000;
    else
      v29 = __maskrune((char)a2, 0x40000uLL);
    if (v29)
      v30 = (char)a2;
    else
      v30 = 46;
    return ImageIOLog("✳️  %s '%c%c%c%c' [%ldx%ld]: imgHeadroom: %g   csHeadroom: %g   hasFlexGTC: %d   isHDR: %d   isEDR: %d   decodeToSDR: %d   decodeToHDR: %d\n", v34, v22, v25, v28, v30, Width, Height, v8, v11, v32, IsHDR, v31, v15, v16);
  }
  return result;
}

uint64_t IIO_Reader_PNG::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  PNGReadPlugin::PNGReadPlugin(v4, a2, v5);
  return v4;
}

void sub_1880598AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40251C7B2ALL);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_PNG::createGlobalInfoData(IIO_Reader_PNG *this, IIOImageReadSession *a2)
{
  IIOImageRead *result;
  CFIndex v3;
  CFRange v4;

  result = IIOImageReadSession::globalInfoForType(a2, 1095781959);
  if (result)
  {
    v3 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)result + 2) - *((_QWORD *)result + 1)) >> 1);
    v4.location = 0;
    v4.length = v3;
    return (IIOImageRead *)GlobalPNGInfo::createDataRepresentation(result, &v4);
  }
  return result;
}

uint64_t IIO_Reader_PNG::updateGlobalInfo(IIO_Reader_PNG *this, IIOImageRead **a2, unsigned __int8 *a3, unint64_t a4)
{
  GlobalPNGInfo *v7;

  v7 = (GlobalPNGInfo *)operator new();
  GlobalPNGInfo::GlobalPNGInfo(v7, a3, a4);
  IIOImageReadSession::setGlobalInfo(a2, 1095781959, v7, (void (*)(void *))globalPNGInfoReleaseProc);
  return 0;
}

void sub_188059994(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C402BA5416ELL);
  _Unwind_Resume(a1);
}

GlobalPNGInfo *IIO_Reader_PNG::deserializeGlobalInfo(IIO_Reader_PNG *this, unsigned __int8 *a2, unint64_t a3)
{
  GlobalPNGInfo *v5;

  v5 = (GlobalPNGInfo *)operator new();
  GlobalPNGInfo::GlobalPNGInfo(v5, a2, a3);
  return v5;
}

void sub_188059A0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C402BA5416ELL);
  _Unwind_Resume(a1);
}

_QWORD *GIFReadPlugin::GIFReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *result = &off_1E1BACAC8;
  *(_QWORD *)((char *)result + 436) = 0;
  return result;
}

void GIFReadPlugin::~GIFReadPlugin(GIFReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t GIFReadPlugin::loadDataFromXPCObject(GIFReadPlugin *this, void *a2)
{
  uint64_t DataFromXPCObject;
  _QWORD *data;
  size_t length;

  DataFromXPCObject = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)DataFromXPCObject)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_gif", &length);
    if (length == 8)
      *(_QWORD *)((char *)this + 436) = *data;
  }
  return DataFromXPCObject;
}

uint64_t GIFReadPlugin::saveDataToXPCObject(GIFReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_gif", (char *)this + 436, 8uLL);
  return v4;
}

uint64_t GIFReadPlugin::cacheImmediately(uint64_t this, const __CFDictionary *a2, CGImage *a3)
{
  *(_BYTE *)(this + 343) = 0;
  return this;
}

uint64_t GIFReadPlugin::decodeIndexedColorFrame(uint64_t a1, IIOScanner *a2, GlobalGIFInfo *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v9;
  unsigned int v10;
  char v11;
  unsigned int *v12;
  unsigned __int8 *v13;
  unint64_t v14;
  unint64_t v15;
  double v16;
  double v17;
  double x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v22;
  size_t v23;
  int64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  double v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  char *v34;
  char *v35;
  CGFloat MaxY;
  CGFloat v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t i;
  double v42;
  char *v43;
  double v44;
  char v45;
  char *v46;
  uint64_t v47;
  _BOOL8 v50;
  BOOL v51;
  uint64_t v53;
  size_t v54;
  int64_t v55;
  uint64_t v56;
  size_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v61;
  unint64_t v62;
  unsigned int v63;
  char *__src;
  double v65;
  double v66;
  double v67;
  uint64_t v68;
  double v69;
  double MinY;
  char *v71;
  size_t count;
  uint64_t v73;
  unsigned int v74[2];
  _BYTE __c[5];
  unsigned int v76[2];
  unsigned __int16 v77;
  unsigned __int16 v78;
  unsigned __int16 v79;
  unsigned __int16 v80;
  __int16 v81;
  __int16 v82;
  __int16 v83;
  uint64_t v84;
  CGRect v85;
  CGRect v86;
  CGRect v87;
  CGRect v88;
  CGRect v89;
  CGRect v90;
  CGRect v91;
  CGRect v92;
  CGRect v93;
  CGRect v94;
  CGRect v95;
  CGRect v96;
  CGRect v97;
  CGRect v98;
  CGRect v99;
  CGRect v100;

  v84 = *MEMORY[0x1E0C80C00];
  memset(__c, 0, sizeof(__c));
  *(_QWORD *)v74 = 0;
  *(_QWORD *)(a6 + 80) = 0;
  v73 = _cg_DGifOpen((uint64_t)a2, (int (*)(uint64_t, _DWORD *, uint64_t))gifReadWithScanner, (int *)&__c[1]);
  if (v73)
  {
    GlobalGIFInfo::getFrameInfoAtIndex(a3, *(_QWORD *)a6, (uint64_t)v76);
    v9 = *(_QWORD *)v76;
    v10 = v77;
    v68 = v78;
    count = v79;
    v63 = v80;
    v11 = v83;
    if ((v83 & 2) != 0)
    {
      __c[0] = v81;
    }
    else if (!v82)
    {
      v12 = (unsigned int *)*((_QWORD *)a3 + 22);
      if (v12)
      {
        bzero(v76, 0x400uLL);
        IIOColorMap::copyToRGBX(v12, v76, 0x400uLL, 0);
        if (**((_DWORD **)a3 + 22) > 0x100u)
          goto LABEL_98;
        if (!IIOColorMap::indexForColor((IIOColorMap *)0xFFFFFFFFLL, v76, (const unsigned int *)(unsigned __int16)**((_DWORD **)a3 + 22), __c, v13))__c[0] = 0;
      }
    }
    IIOScanner::seek(a2, v9, 0);
    if (_cg_DGifGetImageDesc(v73))
    {
      GlobalGIFInfo::getSize((uint64_t)a3, &v74[1], v74);
      LODWORD(v15) = v74[1];
      v85.size.width = (double)v15;
      LODWORD(v15) = v74[0];
      v85.size.height = (double)v15;
      v16 = (double)v10;
      v17 = (double)v68;
      v100.size.width = (double)count;
      v85.origin.x = 0.0;
      v85.origin.y = 0.0;
      v100.origin.x = (double)v10;
      v100.origin.y = (double)v68;
      v100.size.height = (double)v63;
      v86 = CGRectIntersection(v85, v100);
      x = v86.origin.x;
      y = v86.origin.y;
      width = v86.size.width;
      height = v86.size.height;
      if (CGRectIsEmpty(v86))
      {
        if (!*(_QWORD *)a6)
          bzero(*(void **)(a6 + 40), *(_QWORD *)(a6 + 56));
        v14 = 0;
        goto LABEL_91;
      }
      v87.origin.x = x;
      v87.origin.y = y;
      v87.size.width = width;
      v87.size.height = height;
      v66 = CGRectGetWidth(v87);
      v88.origin.x = (double)v10;
      v88.origin.y = (double)v68;
      v88.size.width = (double)count;
      v88.size.height = (double)v63;
      v65 = CGRectGetWidth(v88);
      v89.origin.x = (double)v10;
      v89.origin.y = (double)v68;
      v89.size.width = (double)count;
      v89.size.height = (double)v63;
      MinY = CGRectGetMinY(v89);
      v90.origin.x = x;
      v90.origin.y = y;
      v90.size.width = width;
      v90.size.height = height;
      v67 = CGRectGetMinY(v90);
      v91.origin.x = x;
      v91.origin.y = y;
      v91.size.width = width;
      v91.size.height = height;
      v22 = CGRectGetWidth(v91);
      v92.origin.x = x;
      v92.origin.y = y;
      v92.size.width = width;
      v92.size.height = height;
      v23 = v22;
      v24 = CGRectGetHeight(v92);
      if (*(_QWORD *)(a6 + 56) >= (uint64_t)(v24 * v23))
      {
        if (v66 >= v65 && MinY >= v67)
        {
          v25 = 0;
          v26 = 0;
          goto LABEL_23;
        }
        v26 = (char *)malloc_type_calloc(count, 1uLL, 0xDCFD785uLL);
        if (v26)
        {
          if (x <= v16)
            v25 = 0;
          else
            v25 = (unint64_t)(x - v16);
LABEL_23:
          v71 = v26;
          if ((v11 & 4) != 0)
          {
            v38 = 0;
            v39 = 0;
            __src = &v26[v25];
            v40 = -1;
            while (2)
            {
              for (i = gInterlacedOffset[v39]; i < v24; i += gInterlacedJumps[v39])
              {
                v97.origin.x = v16;
                v97.origin.y = (double)v68;
                v97.size.width = (double)count;
                v97.size.height = (double)v63;
                v42 = CGRectGetMinY(v97);
                v98.origin.x = x;
                v98.origin.y = y;
                v98.size.width = width;
                v98.size.height = height;
                v43 = (char *)(*(_QWORD *)(a6 + 40) + i * v23);
                v44 = (double)(v42 + (double)i);
                if (CGRectGetMinY(v98) > v44
                  || (v99.origin.x = x,
                      v99.origin.y = y,
                      v99.size.width = width,
                      v99.size.height = height,
                      CGRectGetMaxY(v99) <= v44))
                {
                  v45 = 1;
                  v46 = v71;
                }
                else
                {
                  v45 = 0;
                  if (v66 >= v65)
                    v46 = v43;
                  else
                    v46 = v71;
                }
                if (!_cg_DGifGetLine(v73, v46, count))
                {
                  if (v40 >= 0xFFFFFFFFLL)
                    v14 = 0xFFFFFFFFLL;
                  else
                    v14 = v40;
                  if (v14 != -1)
                  {
                    if (i < v24)
                    {
                      v53 = gInterlacedJumps[v39];
                      v54 = v23 * i;
                      do
                      {
                        memset((void *)(*(_QWORD *)(a6 + 40) + v54), __c[0], v23);
                        i += v53;
                        v54 += v53 * v23;
                      }
                      while (i < v24);
                    }
                    if (v39 <= 2)
                    {
                      do
                      {
                        v55 = gInterlacedOffset[++v39];
                        if (v55 < v24)
                        {
                          v56 = gInterlacedJumps[v39];
                          v57 = v23 * v55;
                          do
                          {
                            memset((void *)(*(_QWORD *)(a6 + 40) + v57), __c[0], v23);
                            v55 += v56;
                            v57 += v23 * v56;
                          }
                          while (v55 < v24);
                        }
                      }
                      while (v39 != 3);
                    }
                  }
                  goto LABEL_88;
                }
                if (!(v45 & 1 | (v66 >= v65)))
                  memcpy(v43, __src, v23);
                v47 = i + v68;
                if (v40 > i + v68)
                  v47 = v40;
                ++v38;
                v50 = v39 < 3 && v47 == (_DWORD)v24 - 1 && v24 > 1;
                v40 = v47 - v50;
              }
              if (++v39 != 4)
                continue;
              break;
            }
            if (v38)
              v51 = v63 == 1;
            else
              v51 = 0;
            if (v51 && v40 == 0)
              v14 = v38;
            else
              v14 = v40;
          }
          else
          {
            v27 = *(char **)(a6 + 40);
            v93.origin.x = x;
            v93.origin.y = y;
            v93.size.width = width;
            v93.size.height = height;
            v69 = CGRectGetMinY(v93);
            v94.origin.x = (double)v10;
            v94.origin.y = v17;
            v94.size.width = (double)count;
            v94.size.height = (double)v63;
            v28 = CGRectGetMinY(v94);
            v95.origin.x = x;
            v95.origin.y = y;
            v95.size.width = width;
            v95.size.height = height;
            if (CGRectGetMaxY(v95) > (double)(uint64_t)v28)
            {
              v29 = 0;
              v30 = (uint64_t)v69;
              v31 = (uint64_t)v28;
              v32 = &v71[v25];
              while (1)
              {
                v33 = v31 + v29;
                v34 = v66 >= v65 ? v27 : v71;
                v35 = v33 < v30 ? v71 : v34;
                if (!_cg_DGifGetLine(v73, v35, count))
                  break;
                if (v33 >= v30 && v66 < v65)
                  memcpy(v27, v32, v23);
                v96.origin.x = x;
                v96.origin.y = y;
                v96.size.width = width;
                v96.size.height = height;
                MaxY = CGRectGetMaxY(v96);
                v27 += v23;
                v37 = (double)(v31 + v29++ + 1);
                if (MaxY <= v37)
                {
                  v14 = v29 - 1;
                  goto LABEL_86;
                }
              }
              v61 = v31 - v30 + v29;
              v14 = v61 & ~(v61 >> 63);
              if (v14 < v24)
              {
                v62 = v61 & ~(v61 >> 63);
                v59 = v71;
                do
                {
                  memset(v27, __c[0], v23);
                  v27 += v23;
                  ++v62;
                }
                while (v62 < v24);
LABEL_89:
                if (v59)
                  free(v59);
                goto LABEL_91;
              }
LABEL_88:
              v59 = v71;
              goto LABEL_89;
            }
            v14 = -1;
          }
LABEL_86:
          if (*(_QWORD *)(v73 + 48))
          {
            v58 = operator new();
            GIFColorMap::GIFColorMap(v58, *(_QWORD *)(v73 + 48));
            *(_QWORD *)(a6 + 80) = v58;
          }
          goto LABEL_88;
        }
      }
    }
    else
    {
      _cg_jpeg_mem_term("decodeIndexedColorFrame", 602, "    GIF-ERROR: DGifGetImageDesc (%d)\n", 0);
    }
LABEL_98:
    v14 = -1;
LABEL_91:
    _cg_DGifCloseFile(v73, 0);
    return v14;
  }
  return -1;
}

void sub_18805A21C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1020C40D090CC53);
  _Unwind_Resume(a1);
}

size_t gifReadWithScanner(uint64_t a1, void *a2, int a3)
{
  return IIOScanner::getBytes(*(IIOScanner **)(a1 + 88), a2, a3);
}

void GIFReadPlugin::decodeIndexedColorFrames(uint64_t a1, IIOImageRead *this, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  const UInt8 *v12;
  uint64_t Size;
  size_t v14;
  _QWORD v15[11];
  void *v16;

  v16 = 0;
  v12 = IIOImageRead::retainBytePointer(this, (const __CFData **)&v16, 1);
  Size = IIOImageRead::getSize(this);
  v14 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(a6[1] - *a6) >> 3);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 0x40000000;
  v15[2] = ___ZN13GIFReadPlugin24decodeIndexedColorFramesEP12IIOImageReadP13GlobalGIFInfoRK14ReadPluginDataRK13GIFPluginDataRNSt3__16vectorI20IIODecodeFrameParamsNSA_9allocatorISC_EEEE_block_invoke;
  v15[3] = &__block_descriptor_tmp_50;
  v15[4] = a1;
  v15[5] = a6;
  v15[6] = v12;
  v15[7] = Size;
  v15[8] = a3;
  v15[9] = a4;
  v15[10] = a5;
  dispatch_apply(v14, 0, v15);
  if (this)
  {
    if (v16)
      IIOImageRead::releaseBytePointer(this, v16);
  }
}

void ___ZN13GIFReadPlugin24decodeIndexedColorFramesEP12IIOImageReadP13GlobalGIFInfoRK14ReadPluginDataRK13GIFPluginDataRNSt3__16vectorI20IIODecodeFrameParamsNSA_9allocatorISC_EEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _OWORD v9[4];
  uint64_t v10;

  v4 = *(unsigned __int8 **)(a1 + 48);
  v5 = **(_QWORD **)(a1 + 40);
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOScanner::IIOScanner((IIOScanner *)v9, v4, *(unsigned int *)(a1 + 56), 1);
  *(_QWORD *)(v5 + 88 * a2 + 64) = GIFReadPlugin::decodeIndexedColorFrame(v6, (IIOScanner *)v9, *(GlobalGIFInfo **)(a1 + 64), v7, v8, v5 + 88 * a2);
  IIOScanner::~IIOScanner((IIOScanner *)v9);
}

void sub_18805A3D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *GIFReadPlugin::createFrameBufferAtIndex(task_t *a1, CGRect *a2, uint64_t a3, IIO_Reader *a4, GlobalGIFInfo *a5, uint64_t a6, uint64_t a7)
{
  IIO_ReaderHandler *ReaderHandler;
  IIOImageRead *v15;
  unint64_t v16;
  CGFloat x;
  CGFloat y;
  double width;
  double height;
  unint64_t v21;
  memory_object_offset_t v22;
  unint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  char *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  _QWORD *v34;
  char *v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  unint64_t v40;
  char *v41;
  uint64_t *v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  unint64_t v47;
  uint64_t *v48;
  double v49;
  IIOColorMap *v50;
  char *SerializedData;
  CFDataRef v52;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  _OWORD v60[2];
  uint64_t v61;
  size_t v62;
  uint64_t *v63;
  char *v64;
  char *v65;
  unint64_t v66[5];
  CGRect v67;
  CGRect v68;

  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)a1);
  IIO_ReaderHandler::readerForType(ReaderHandler, 1195984416);
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v15 = (IIOImageRead *)IIO_Reader::testHeaderSize(a4);
  if (!v15)
    goto LABEL_16;
  v61 = 0;
  v62 = 0;
  memset(v60, 0, sizeof(v60));
  GlobalGIFInfo::getFrameInfoAtIndex(a5, a3, (uint64_t)v60);
  LOWORD(v16) = WORD4(v60[0]);
  v68.origin.x = (double)v16;
  LOWORD(v16) = WORD5(v60[0]);
  v68.origin.y = (double)v16;
  LOWORD(v16) = WORD6(v60[0]);
  v68.size.width = (double)v16;
  LOWORD(v16) = HIWORD(v60[0]);
  v68.size.height = (double)v16;
  v67 = CGRectIntersection(*a2, v68);
  x = v67.origin.x;
  y = v67.origin.y;
  width = v67.size.width;
  height = v67.size.height;
  v21 = (unint64_t)v67.size.width;
  if (!CGRectIsEmpty(v67))
  {
    if (is_mul_ok(v21, (unint64_t)height))
    {
      v22 = _ImageIO_Malloc(v21 * (unint64_t)height, *(_QWORD *)(a6 + 200), &v62, (uint64_t)kImageMalloc_GIF_Data[0], a1[108], 0, 0);
      if (v22)
        goto LABEL_6;
    }
LABEL_16:
    v34 = 0;
    goto LABEL_32;
  }
  v22 = 0;
LABEL_6:
  *(_QWORD *)&v54 = a3;
  *((CGFloat *)&v54 + 1) = x;
  *(CGFloat *)&v55 = y;
  *((double *)&v55 + 1) = width;
  *(double *)&v56 = height;
  *((_QWORD *)&v56 + 1) = v22;
  *(_QWORD *)&v57 = (unint64_t)width;
  *((_QWORD *)&v57 + 1) = v62;
  *(_QWORD *)&v58 = 0;
  DWORD2(v58) = 0;
  v59 = 0;
  v23 = (unint64_t)v64;
  if (v64 >= v65)
  {
    v29 = (unint64_t)v63;
    v30 = 0x2E8BA2E8BA2E8BA3 * ((v64 - (char *)v63) >> 3);
    v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) > 0x2E8BA2E8BA2E8BALL)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    if (0x5D1745D1745D1746 * ((v65 - (char *)v63) >> 3) > v31)
      v31 = 0x5D1745D1745D1746 * ((v65 - (char *)v63) >> 3);
    if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v65 - (char *)v63) >> 3)) >= 0x1745D1745D1745DLL)
      v32 = 0x2E8BA2E8BA2E8BALL;
    else
      v32 = v31;
    v66[4] = (unint64_t)&v65;
    if (v32)
    {
      v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>((uint64_t)&v65, v32);
      v29 = (unint64_t)v63;
      v23 = (unint64_t)v64;
    }
    else
    {
      v33 = 0;
    }
    v35 = &v33[88 * v30];
    v36 = v55;
    *(_OWORD *)v35 = v54;
    *((_OWORD *)v35 + 1) = v36;
    v37 = v56;
    v38 = v57;
    v39 = v58;
    *((_QWORD *)v35 + 10) = v59;
    *((_OWORD *)v35 + 3) = v38;
    *((_OWORD *)v35 + 4) = v39;
    *((_OWORD *)v35 + 2) = v37;
    if (v23 == v29)
    {
      v42 = (uint64_t *)&v33[88 * v30];
    }
    else
    {
      v40 = v23;
      v41 = &v33[88 * v30];
      do
      {
        v42 = (uint64_t *)(v41 - 88);
        v43 = *(_OWORD *)(v40 - 88);
        *(_OWORD *)(v41 - 72) = *(_OWORD *)(v40 - 72);
        *(_OWORD *)(v41 - 88) = v43;
        v44 = *(_OWORD *)(v40 - 56);
        v45 = *(_OWORD *)(v40 - 40);
        v46 = *(_OWORD *)(v40 - 24);
        *((_QWORD *)v41 - 1) = *(_QWORD *)(v40 - 8);
        *(_OWORD *)(v41 - 24) = v46;
        *(_OWORD *)(v41 - 40) = v45;
        *(_OWORD *)(v41 - 56) = v44;
        v40 -= 88;
        v41 -= 88;
      }
      while (v40 != v29);
    }
    v28 = v35 + 88;
    v63 = v42;
    v64 = v35 + 88;
    v47 = (unint64_t)v65;
    v65 = &v33[88 * v32];
    v66[2] = v23;
    v66[3] = v47;
    v66[0] = v29;
    v66[1] = v29;
    std::__split_buffer<IIODecodeFrameParams>::~__split_buffer((uint64_t)v66);
  }
  else
  {
    v24 = v55;
    *(_OWORD *)v64 = v54;
    *(_OWORD *)(v23 + 16) = v24;
    v25 = v56;
    v26 = v57;
    v27 = v58;
    *(_QWORD *)(v23 + 80) = v59;
    *(_OWORD *)(v23 + 48) = v26;
    *(_OWORD *)(v23 + 64) = v27;
    *(_OWORD *)(v23 + 32) = v25;
    v28 = (char *)(v23 + 88);
  }
  v64 = v28;
  IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)&v54);
  GIFReadPlugin::decodeIndexedColorFrames((uint64_t)a1, v15, (uint64_t)a5, a6, a7, &v63);
  v48 = v63;
  *(_QWORD *)&v56 = 0;
  v54 = 0u;
  v55 = 0u;
  GlobalGIFInfo::getFrameInfoAtIndex(a5, *v63, (uint64_t)&v54);
  if (WORD1(v55))
    v49 = (double)WORD1(v55) / 100.0;
  else
    v49 = 0.0333333333;
  v34 = (_QWORD *)IIOFrameBufferCreateForBuffer(v48[5], v48[7], HIWORD(v54) * (unint64_t)WORD6(v54), *v48, v49);
  IIOGIFFrameSetNumRowsDecoded((uint64_t)v34, v48[8]);
  v50 = (IIOColorMap *)v48[10];
  if (v50)
  {
    v66[0] = 0;
    SerializedData = IIOColorMap::createSerializedData(v50, v66);
    if (SerializedData)
    {
      v52 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)SerializedData, v66[0]);
      if (v52)
      {
        IIOFrameBufferSetColorTable(v34, v52);
        CFRelease(v52);
      }
      free(SerializedData);
    }
  }
LABEL_32:
  *(_QWORD *)&v54 = &v63;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)&v54);
  return v34;
}

void sub_18805A7C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  a9 = (void **)&a27;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t GIFReadPlugin::doDecodeImageData(task_t *a1, IIO_Reader *this, GlobalGIFInfo *a3, uint64_t a4, uint64_t a5, char *a6, size_t a7, uint64_t *a8, uint64_t *a9)
{
  uint64_t v9;
  const void *v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  const void *v22;
  GlobalGIFInfo *v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unint64_t v28;
  size_t v29;
  int v30;
  unsigned int v31;
  unint64_t v32;
  size_t v33;
  IIO_ReaderHandler *ClientValueForKey;
  IIOFrameBufferQueue *v35;
  IIO_ReaderHandler *ReaderHandler;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  unsigned int v45;
  std::__shared_weak_count *v46;
  unint64_t *p_shared_owners;
  unint64_t v48;
  uint64_t v49;
  std::__shared_weak_count *v50;
  unint64_t *v51;
  unint64_t v52;
  int v53;
  unint64_t v54;
  unsigned int v56;
  uint64_t v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  int v63;
  char v64;
  const void *v65;
  const __CFData *ColorTable;
  const __CFData *v67;
  const unsigned __int8 *BytePtr;
  CFIndex Length;
  uint64_t v70;
  unsigned int *v71;
  unsigned __int16 v72;
  double x;
  unint64_t height;
  uint64_t v75;
  unint64_t width;
  unint64_t y;
  char *v78;
  size_t v79;
  char *v80;
  unsigned __int8 *v82;
  unint64_t v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  int v90;
  char v91;
  void *v92;
  uint64_t v93;
  uint64_t v94;
  const __CFData *v95;
  const __CFData *v96;
  const unsigned __int8 *v97;
  CFIndex v98;
  uint64_t v99;
  unsigned int *v100;
  unsigned __int16 v101;
  unsigned int v102;
  double v103;
  uint64_t v104;
  unint64_t v105;
  char *v106;
  unsigned __int8 *v108;
  unint64_t v109;
  unsigned int v110;
  unsigned int v111;
  IIO_Reader *v113;
  IIOFrameBufferQueue *v116;
  uint64_t NumRowsDecoded;
  GlobalGIFInfo *v119;
  uint64_t Buffer;
  void *v121;
  uint64_t v122;
  char *v123;
  uint64_t v124;
  uint64_t v125;
  std::__shared_weak_count *v126;
  void *v127[2];
  char v128;
  _QWORD v129[6];
  CGRect v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *__p[2];
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  uint64_t v164;
  IIOFrameBufferQueue *v165;
  std::__shared_weak_count *v166;
  unsigned int v167[2];
  CGRect v168;
  unsigned int v169[256];
  uint64_t v170;
  CGRect v171;
  CGRect v172;
  CGRect v173;
  CGRect v174;

  v9 = (uint64_t)this;
  v170 = *MEMORY[0x1E0C80C00];
  if (!this)
  {
    v14 = 0;
LABEL_142:
    NumRowsDecoded = -1;
    goto LABEL_135;
  }
  v14 = (const void *)IIO_Reader::testHeaderSize(this);
  if (!v14)
  {
    v9 = 0;
    goto LABEL_142;
  }
  v15 = (uint64_t)v14;
  v113 = (IIO_Reader *)v9;
  bzero(v169, 0x400uLL);
  v16 = *(_DWORD *)a5;
  v17 = *(_DWORD *)(a4 + 112);
  v18 = *(_DWORD *)(a4 + 116);
  v124 = a4;
  *(_QWORD *)v167 = 0;
  v119 = a3;
  GlobalGIFInfo::getSize((uint64_t)a3, &v167[1], v167);
  LODWORD(v19) = v167[1];
  LODWORD(v20) = v167[0];
  v168.origin.y = 0.0;
  v168.origin.x = 0.0;
  v168.size.width = (double)v19;
  v168.size.height = (double)v20;
  v21 = *a8;
  if (!*a8)
  {
    v30 = 1;
    v23 = v119;
    goto LABEL_27;
  }
  v22 = *(const void **)(v21 + 8);
  v23 = a3;
  if (!v22)
    goto LABEL_26;
  v24 = *(_DWORD *)(a4 + 24);
  if (!v24)
    goto LABEL_26;
  v25 = *(unsigned int *)(v21 + 20);
  if ((_DWORD)v25 == v24 - 1)
  {
    GlobalGIFInfo::getFrameInfoAtIndex(a3, v25, (uint64_t)__p);
    if ((unsigned __int16)v150 >= 2u)
    {
      v23 = a3;
      if ((unsigned __int16)v150 == 2 && (BYTE4(v151) & 1) != 0)
        v16 = *(_DWORD *)(a4 + 24) - 1;
    }
    else
    {
      v26 = *a8;
      v23 = a3;
      if (*(unsigned __int8 *)(*a8 + 36) == *(unsigned __int8 *)(a4 + 220))
      {
        v27 = *(_DWORD *)(a4 + 116);
        if (v27 == *(_DWORD *)(v26 + 24))
        {
          v28 = *(unsigned int *)(v26 + 32) * (unint64_t)v27;
          if (v28 >= a7)
            v29 = a7;
          else
            v29 = v28;
          memcpy(a6, *(const void **)(v26 + 8), v29);
          v30 = 0;
          goto LABEL_27;
        }
      }
    }
LABEL_26:
    v30 = 1;
    goto LABEL_27;
  }
  v30 = 1;
  if (v25 >= v16
    && v25 < v24
    && *(unsigned __int8 *)(v21 + 36) == *(unsigned __int8 *)(a4 + 220))
  {
    v31 = *(_DWORD *)(a4 + 116);
    if (v31 == *(_DWORD *)(v21 + 24))
    {
      v32 = *(unsigned int *)(v21 + 32) * (unint64_t)v31;
      if (v32 >= a7)
        v33 = a7;
      else
        v33 = v32;
      memcpy(a6, v22, v33);
      v16 = *(_DWORD *)(*a8 + 20);
    }
  }
LABEL_27:
  if (*(_BYTE *)(a5 + 4))
  {
    v166 = 0;
    v165 = 0;
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)kFrameBufferQueueKey);
    ClientValueForKey = (IIO_ReaderHandler *)IIOImageRead::getClientValueForKey(v15, (const void **)__p, &v165);
    v23 = v119;
    if (SBYTE7(v150) < 0)
      operator delete(__p[0]);
    v35 = v165;
    if (!v165)
    {
      ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(ClientValueForKey);
      IIO_ReaderHandler::readerForType(ReaderHandler, 1195984416);
      v37 = *(_OWORD *)(a4 + 208);
      v161 = *(_OWORD *)(a4 + 192);
      v162 = v37;
      v163 = *(_OWORD *)(a4 + 224);
      v164 = *(_QWORD *)(a4 + 240);
      v38 = *(_OWORD *)(a4 + 144);
      v157 = *(_OWORD *)(a4 + 128);
      v158 = v38;
      v39 = *(_OWORD *)(a4 + 176);
      v159 = *(_OWORD *)(a4 + 160);
      v160 = v39;
      v40 = *(_OWORD *)(a4 + 80);
      v153 = *(_OWORD *)(a4 + 64);
      v154 = v40;
      v41 = *(_OWORD *)(a4 + 112);
      v155 = *(_OWORD *)(a4 + 96);
      v156 = v41;
      v42 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)__p = *(_OWORD *)a4;
      v150 = v42;
      v43 = *(_OWORD *)(a4 + 48);
      v151 = *(_OWORD *)(a4 + 32);
      v152 = v43;
      v44 = *(_QWORD *)a5;
      v35 = (IIOFrameBufferQueue *)operator new();
      v45 = GlobalGIFInfo::frameCount(v119);
      v129[1] = 0x40000000;
      v130 = v168;
      v144 = v162;
      v145 = v163;
      v140 = v158;
      v141 = v159;
      v142 = v160;
      v143 = v161;
      v136 = v154;
      v137 = v155;
      v138 = v156;
      v139 = v157;
      v131 = *(_OWORD *)__p;
      v132 = v150;
      v133 = v151;
      v129[0] = MEMORY[0x1E0C809B0];
      v129[2] = ___ZN13GIFReadPlugin17doDecodeImageDataEP19IIOImageReadSessionP13GlobalGIFInfoRK14ReadPluginDataRK13GIFPluginDataPhmNSt3__110shared_ptrI13GIFBufferInfoEEPl_block_invoke;
      v129[3] = &__block_descriptor_tmp_26;
      v129[4] = a1;
      v129[5] = v119;
      v134 = v152;
      v135 = v153;
      v146 = v164;
      v147 = v15;
      v148 = v44;
      IIOFrameBufferQueue::IIOFrameBufferQueue(v35, v45, 2, v129);
      std::string::basic_string[abi:ne180100]<0>(v127, (char *)kFrameBufferQueueKey);
      std::shared_ptr<IIOBaseObject>::shared_ptr[abi:ne180100]<IIOFrameBufferQueue,void>(&v125, (uint64_t)v35);
      IIOImageRead::setClientValueForKey(v15, (__int128 *)v127, &v125);
      v46 = v126;
      if (v126)
      {
        p_shared_owners = (unint64_t *)&v126->__shared_owners_;
        do
          v48 = __ldaxr(p_shared_owners);
        while (__stlxr(v48 - 1, p_shared_owners));
        if (!v48)
        {
          ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
          std::__shared_weak_count::__release_weak(v46);
        }
      }
      if (v128 < 0)
        operator delete(v127[0]);
      if ((v30 & (*(_BYTE *)(a5 + 5) == 0)) != 0)
        v49 = v16;
      else
        v49 = *(unsigned int *)(v124 + 24);
      IIOFrameBufferQueue::startEnqueueingBuffers(v35, v49);
    }
    v50 = v166;
    if (v166)
    {
      v51 = (unint64_t *)&v166->__shared_owners_;
      do
        v52 = __ldaxr(v51);
      while (__stlxr(v52 - 1, v51));
      if (!v52)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
  }
  else
  {
    v35 = 0;
  }
  v116 = v35;
  v123 = &a6[v18 * v17];
  if (*(_BYTE *)(a5 + 5))
    v53 = 0;
  else
    v53 = v30;
  LODWORD(v54) = *(_DWORD *)(v124 + 24);
  if (v53 == 1 && v16 < v54)
  {
    Buffer = 0;
    NumRowsDecoded = -1;
    v56 = 255;
    v57 = v16;
    while (1)
    {
      v122 = v57;
      GlobalGIFInfo::getFrameInfoAtIndex(v23, v57, (uint64_t)__p);
      v58 = LOWORD(__p[1]);
      v59 = WORD1(__p[1]);
      v60 = WORD2(__p[1]);
      v61 = HIWORD(__p[1]);
      v62 = (unsigned __int16)v150;
      v63 = SWORD2(v150);
      v64 = BYTE4(v151);
      if ((unsigned __int16)v150 == 2)
        break;
      if ((unsigned __int16)v150 != 3)
      {
        if (v116)
          v121 = (void *)IIOFrameBufferQueue::getAndRetainBufferAtIndex((os_unfair_lock_s *)v116, v122);
        else
          v121 = GIFReadPlugin::createFrameBufferAtIndex(a1, &v168, v122, v113, v119, v124, a5);
        if (!v121)
        {
          _cg_jpeg_mem_term("doDecodeImageData", 1136, "*** IIOFrameBufferQueue returned NULL for buffer at index: %ld\n", v122);
          goto LABEL_139;
        }
        Buffer = IIOFrameBufferGetBuffer((uint64_t)v121);
        ColorTable = (const __CFData *)IIOFrameBufferGetColorTable((uint64_t)v121);
        v67 = ColorTable;
        if (ColorTable)
        {
          __p[0] = 0;
          __p[1] = 0;
          *(_QWORD *)&v150 = 0;
          BytePtr = CFDataGetBytePtr(ColorTable);
          Length = CFDataGetLength(v67);
          IIOColorMap::IIOColorMap((IIOColorMap *)__p, BytePtr, Length);
          LOWORD(v67) = __p[0];
          IIOColorMap::copyToRGBX((unsigned int *)__p, v169, 0x400uLL, *(_BYTE *)(v124 + 221) == 0);
          v70 = v150;
          *(_QWORD *)&v150 = 0;
          if (v70)
            MEMORY[0x18D761C18](v70, 0x1000C8033FC2DF1);
        }
        else
        {
          v71 = (unsigned int *)*((_QWORD *)v119 + 22);
          if (!v71)
          {
            bzero(a6, (*(_DWORD *)(v124 + 116) * *(_DWORD *)(v124 + 112)));
LABEL_137:
            v14 = v121;
            goto LABEL_134;
          }
          LODWORD(v67) = *v71;
          IIOColorMap::copyToRGBX(v71, v169, 0x400uLL, *(_BYTE *)(v124 + 221) == 0);
        }
        NumRowsDecoded = IIOGIFFrameGetNumRowsDecoded((uint64_t)v121);
        if (NumRowsDecoded < 0)
          goto LABEL_137;
        if (v63 > (__int16)v67)
          v72 = v63 + 1;
        else
          v72 = (unsigned __int16)v67;
        if (v72 >= 0xFFu)
          v56 = 255;
        else
          v56 = v72;
        goto LABEL_79;
      }
      if (!v122)
        bzero(a6, (*(_DWORD *)(v124 + 116) * *(_DWORD *)(v124 + 112)));
      v65 = 0;
LABEL_99:
      IIOFrameBufferRelease(v65);
      v57 = v122 + 1;
      v54 = *(unsigned int *)(v124 + 24);
      v23 = v119;
      if (v122 + 1 >= v54)
        goto LABEL_100;
    }
    v121 = 0;
LABEL_79:
    v173.origin.x = (double)v58;
    v173.origin.y = (double)v59;
    v173.size.width = (double)v60;
    v173.size.height = (double)v61;
    x = v168.origin.x;
    v171 = CGRectIntersection(v168, v173);
    height = (unint64_t)v171.size.height;
    if ((unint64_t)v171.size.height)
    {
      v75 = 0;
      width = (unint64_t)v171.size.width;
      y = (unint64_t)v171.origin.y;
      v78 = &a6[4 * (unint64_t)((double)(unint64_t)v171.origin.x - x)];
      v79 = 4 * (unint64_t)v171.size.width;
      do
      {
        v80 = &v78[(v75 + y) * *(unsigned int *)(v124 + 116)];
        if (v80 > v123 || &v80[v79] > v123)
          break;
        if (v62 < 2)
        {
          if (width)
          {
            v82 = (unsigned __int8 *)(Buffer + v75 * width);
            v83 = width;
            do
            {
              v85 = *v82++;
              v84 = v85;
              if (v85 > v56)
                v84 = 0;
              if ((v64 & 2) == 0 || v84 != v63)
                *(_DWORD *)v80 = v169[v84];
              v80 += 4;
              --v83;
            }
            while (v83);
          }
        }
        else if (v62 == 2 && width)
        {
          bzero(v80, v79);
        }
        ++v75;
      }
      while (v75 != height);
    }
    v65 = v121;
    goto LABEL_99;
  }
  NumRowsDecoded = -1;
LABEL_100:
  GlobalGIFInfo::getFrameInfoAtIndex(v23, v54, (uint64_t)__p);
  v86 = LOWORD(__p[1]);
  v87 = WORD1(__p[1]);
  v88 = WORD2(__p[1]);
  v89 = HIWORD(__p[1]);
  v90 = SWORD2(v150);
  v91 = BYTE4(v151);
  if (v116)
    v92 = (void *)IIOFrameBufferQueue::getAndRetainBufferAtIndex((os_unfair_lock_s *)v116, *(unsigned int *)(v124 + 24));
  else
    v92 = GIFReadPlugin::createFrameBufferAtIndex(a1, &v168, *(unsigned int *)(v124 + 24), v113, v119, v124, a5);
  v93 = (uint64_t)v92;
  if (!v92)
  {
    _cg_jpeg_mem_term("doDecodeImageData", 1272, "*** IIOFrameBufferQueue returned NULL for buffer at index: %u\n", *(_DWORD *)(v124 + 24));
LABEL_139:
    v14 = 0;
    goto LABEL_134;
  }
  v94 = IIOFrameBufferGetBuffer((uint64_t)v92);
  v95 = (const __CFData *)IIOFrameBufferGetColorTable(v93);
  v96 = v95;
  if (v95)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(_QWORD *)&v150 = 0;
    v97 = CFDataGetBytePtr(v95);
    v98 = CFDataGetLength(v96);
    IIOColorMap::IIOColorMap((IIOColorMap *)__p, v97, v98);
    LOWORD(v96) = __p[0];
    IIOColorMap::copyToRGBX((unsigned int *)__p, v169, 0x400uLL, *(_BYTE *)(v124 + 221) == 0);
    v99 = v150;
    *(_QWORD *)&v150 = 0;
    if (v99)
      MEMORY[0x18D761C18](v99, 0x1000C8033FC2DF1);
    goto LABEL_109;
  }
  v100 = (unsigned int *)*((_QWORD *)v119 + 22);
  if (v100)
  {
    LODWORD(v96) = *v100;
    IIOColorMap::copyToRGBX(v100, v169, 0x400uLL, *(_BYTE *)(v124 + 221) == 0);
LABEL_109:
    NumRowsDecoded = IIOGIFFrameGetNumRowsDecoded(v93);
    if ((NumRowsDecoded & 0x8000000000000000) == 0)
    {
      v101 = v90 > (__int16)v96 ? v90 + 1 : (unsigned __int16)v96;
      v102 = v101 >= 0xFFu ? 255 : v101;
      v174.origin.x = (double)v86;
      v174.origin.y = (double)v87;
      v174.size.width = (double)v88;
      v174.size.height = (double)v89;
      v103 = v168.origin.x;
      v172 = CGRectIntersection(v168, v174);
      if ((unint64_t)v172.size.height)
      {
        v104 = 0;
        v105 = (unint64_t)v172.size.width;
        do
        {
          v106 = &a6[4 * (unint64_t)((double)(int)v172.origin.x - v103)
                   + (v104 + (unint64_t)v172.origin.y) * *(unsigned int *)(v124 + 116)];
          if (v106 > v123 || &v106[4 * (unint64_t)v172.size.width] > v123)
            break;
          if (v105)
          {
            v108 = (unsigned __int8 *)(v94 + v104 * v105);
            v109 = (unint64_t)v172.size.width;
            do
            {
              v111 = *v108++;
              v110 = v111;
              if (v102 < v111)
                v110 = 0;
              if ((v91 & 2) == 0 || v110 != v90)
                *(_DWORD *)v106 = v169[v110];
              v106 += 4;
              --v109;
            }
            while (v109);
          }
          ++v104;
        }
        while (v104 != (unint64_t)v172.size.height);
      }
    }
    goto LABEL_133;
  }
  bzero(a6, (*(_DWORD *)(v124 + 116) * *(_DWORD *)(v124 + 112)));
LABEL_133:
  v14 = (const void *)v93;
LABEL_134:
  v9 = 1;
LABEL_135:
  IIOFrameBufferRelease(v14);
  *a9 = NumRowsDecoded;
  return v9;
}

void sub_18805B258(_Unwind_Exception *a1)
{
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&STACK[0x2F0]);
  _Unwind_Resume(a1);
}

void sub_18805B794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15)
{
  uint64_t v15;

  a15 = (void **)(v15 - 184);
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

const void *GIFReadPlugin::copyImageBlockSetImp(IIOReadPlugin *this, const void *a2, const void *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  const void *v15;
  double v18;
  double v19;
  double v20;
  int CachedBlocks;
  IIOImageRead *v22;
  GlobalGIFInfo *v23;
  size_t v24;
  void *v25;
  const void *v26;
  unsigned int v27;
  size_t v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  int8x16_t v32;
  CGFloat v33;
  CGFloat v34;
  int v35;
  char v36;
  IIOImageRead **v37;
  IIO_Reader *v38;
  char *v39;
  size_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t *p_shared_owners;
  unint64_t v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  double v51;
  double v52;
  _BOOL4 v53;
  int v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  double v58;
  double v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t v63;
  const char **v64;
  unsigned int v66;
  char v67;
  uint8_t permuteMap[8];
  std::__shared_weak_count *v69;
  uint64_t v70[2];
  uint64_t v71;
  vImage_Buffer dest;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  size_t v76;
  void *__dst;
  CGRect v78;
  CGRect v79;
  CGRect v80;
  CGRect v81;

  v15 = a3;
  __dst = 0;
  if (a3)
    CGImageProviderGetSize();
  v76 = 0;
  if (*((_QWORD *)this + 3))
  {
    if (!*((_QWORD *)this + 49))
      *((_QWORD *)this + 49) = 16;
    *((_DWORD *)this + 75) = (4 * *((_DWORD *)this + 57) + 15) & 0xFFFFFFF0;
    IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    CachedBlocks = IIOReadPlugin::getCachedBlocks(this, v18, v19, v20);
    IIOReadPlugin::debugCopyBlockSet((const char *)this, v15, a4, a5, a6, a7, a8, a9);
    if (!CachedBlocks)
    {
      v35 = 1;
      goto LABEL_56;
    }
    v22 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1195984416);
    if (v22)
    {
      v23 = v22;
      if (GlobalGIFInfo::frameCount(v22) > *((_DWORD *)this + 52))
      {
        v74 = 0;
        v75 = 0;
        GlobalGIFInfo::getCachedFrameBuffer(v23, &v74);
        v24 = *((unsigned int *)this + 75) * (unint64_t)*((unsigned int *)this + 74);
        v25 = (void *)_ImageIO_Malloc(v24, *((_QWORD *)this + 48), &v76, (uint64_t)kImageMalloc_GIF_Data[0], *((_DWORD *)this + 108), 0, 0);
        __dst = v25;
        if (v25)
        {
          if (v74)
          {
            v26 = *(const void **)(v74 + 8);
            if (v26)
            {
              v27 = *(_DWORD *)(v74 + 24);
              v28 = v27 * (unint64_t)*(unsigned int *)(v74 + 32);
              if (v28)
              {
                v29 = *(_DWORD *)(v74 + 20);
                if (v29 == *((_DWORD *)this + 52)
                  && v27 == *((_DWORD *)this + 75)
                  && v28 == *((_DWORD *)this + 74) * v27)
                {
                  if ((gIIODebugFlags & 0x30000) != 0)
                  {
                    ImageIOLog("    frame#%d found in current-cache\n", v29);
                    v25 = __dst;
                    v26 = *(const void **)(v74 + 8);
                    v28 = *(unsigned int *)(v74 + 24) * (unint64_t)*(unsigned int *)(v74 + 32);
                  }
                  memcpy(v25, v26, v28);
                  if (*(unsigned __int8 *)(v74 + 36) != *((unsigned __int8 *)this + 404))
                  {
                    *(_DWORD *)permuteMap = 50331906;
                    dest.data = __dst;
                    v31 = *(_QWORD *)((char *)this + 292);
                    v32.i64[0] = v31;
                    v32.i64[1] = HIDWORD(v31);
                    *(int8x16_t *)&dest.height = vextq_s8(v32, v32, 8uLL);
                    dest.rowBytes = *((unsigned int *)this + 75);
                    vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
                  }
                  LODWORD(v30) = *((_DWORD *)this + 73);
                  v33 = (double)v30;
                  LODWORD(v30) = *((_DWORD *)this + 74);
                  v34 = (double)v30;
                  v78.origin.x = 0.0;
                  v78.origin.y = 0.0;
                  v78.size.width = v33;
                  v78.size.height = v34;
                  **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, __dst, v76, v78, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
                  v79.origin.x = 0.0;
                  v79.origin.y = 0.0;
                  v79.size.width = v33;
                  v79.size.height = v34;
                  AddSubRect((CGRect *)((char *)this + 120), v79);
                  CachedBlocks = 0;
                  v35 = 1;
                  *((_DWORD *)this + 26) = 1;
                  v36 = 1;
LABEL_51:
                  v60 = (std::__shared_weak_count *)v75;
                  if (!v75)
                    goto LABEL_55;
                  v61 = (unint64_t *)(v75 + 8);
                  do
                    v62 = __ldaxr(v61);
                  while (__stlxr(v62 - 1, v61));
                  if (!v62)
                  {
                    ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
                    std::__shared_weak_count::__release_weak(v60);
                    if ((v36 & 1) == 0)
                      goto LABEL_62;
                  }
                  else
                  {
LABEL_55:
                    if ((v36 & 1) == 0)
                      goto LABEL_62;
                  }
LABEL_56:
                  v63 = *((unsigned int *)this + 26);
                  if ((_DWORD)v63 && v15 && v35)
                  {
                    v15 = (const void *)IIOReadPlugin::imageBlockSetCreate((uint64_t)this, (uint64_t)v15, v63, *((double *)this + 17), *((double *)this + 18), *((double *)this + 15), *((double *)this + 16), *((double *)this + 17), *((double *)this + 18), *((_QWORD *)this + 12), a2);
                    IIOReadPlugin::freeBlockArray(this);
                    if ((CachedBlocks & 1) == 0)
                      return v15;
                    goto LABEL_67;
                  }
LABEL_62:
                  if (v15)
                    goto LABEL_63;
LABEL_66:
                  if (!CachedBlocks)
                    return v15;
                  goto LABEL_67;
                }
              }
            }
          }
          v73 = 0;
          memset(&dest, 0, sizeof(dest));
          GlobalGIFInfo::getFrameInfoAtIndex(v23, *((unsigned int *)this + 52), (uint64_t)&dest);
          v71 = 0;
          v37 = (IIOImageRead **)*((_QWORD *)this + 3);
          if (v37)
          {
            CachedBlocks = IIOImageReadSession::mapData(v37);
            v37 = (IIOImageRead **)*((_QWORD *)this + 3);
          }
          else
          {
            CachedBlocks = 0;
          }
          IIOImageReadSession::rewind((uint64_t)v37);
          v38 = (IIO_Reader *)*((_QWORD *)this + 3);
          v40 = v76;
          v39 = (char *)__dst;
          v41 = (std::__shared_weak_count *)v75;
          v70[0] = v74;
          v70[1] = v75;
          if (v75)
          {
            v42 = (unint64_t *)(v75 + 8);
            do
              v43 = __ldxr(v42);
            while (__stxr(v43 + 1, v42));
          }
          v35 = GIFReadPlugin::doDecodeImageData((task_t *)this, v38, v23, (uint64_t)this + 184, (uint64_t)this + 436, v39, v40, v70, &v71);
          if (v41)
          {
            p_shared_owners = (unint64_t *)&v41->__shared_owners_;
            do
              v46 = __ldaxr(p_shared_owners);
            while (__stlxr(v46 - 1, p_shared_owners));
            if (!v46)
            {
              ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
              std::__shared_weak_count::__release_weak(v41);
            }
          }
          if (LOWORD(dest.width) <= 1u)
          {
            *(_QWORD *)permuteMap = 0;
            v69 = 0;
            v67 = 1;
            v66 = *((_DWORD *)this + 75);
            std::allocate_shared[abi:ne180100]<GIFBufferInfo,std::allocator<GIFBufferInfo>,unsigned char *&,BOOL,unsigned int &,unsigned int &,unsigned int,void>((unsigned __int8 **)&__dst, (BOOL *)&v67, (unsigned int *)this + 73, (unsigned int *)this + 74, &v66, permuteMap);
            v47 = *(_QWORD *)permuteMap;
            *(_DWORD *)(*(_QWORD *)permuteMap + 20) = *((_DWORD *)this + 52);
            *(_BYTE *)(v47 + 36) = *((_BYTE *)this + 404);
            GlobalGIFInfo::setCachedFrameBuffer((uint64_t)v23, (uint64_t *)permuteMap);
            v48 = v69;
            if (v69)
            {
              v49 = (unint64_t *)&v69->__shared_owners_;
              do
                v50 = __ldaxr(v49);
              while (__stlxr(v50 - 1, v49));
              if (!v50)
              {
                ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
                std::__shared_weak_count::__release_weak(v48);
              }
            }
          }
          if ((v71 & 0x8000000000000000) == 0)
          {
            LODWORD(v44) = *((_DWORD *)this + 73);
            v51 = (double)v44;
            LODWORD(v44) = *((_DWORD *)this + 74);
            v52 = (double)v44;
            if (v71 >= HIWORD(dest.height) - 1)
            {
              v53 = *((_BYTE *)this + 343) != 0;
            }
            else
            {
              v53 = 0;
              *((_BYTE *)this + 343) = 0;
            }
            v80.origin.x = 0.0;
            v80.origin.y = 0.0;
            v80.size.width = v51;
            v80.size.height = v52;
            **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, __dst, v76, v80, *((unsigned int *)this + 75), v53);
            v55 = CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]);
            v56 = 0;
            if (v55)
            {
              v57 = 0;
            }
            else
            {
              v81.origin.x = 0.0;
              v81.origin.y = 0.0;
              v81.size.width = v51;
              v81.size.height = v52;
              *(CGRect *)&v56 = CGRectUnion(*(CGRect *)((char *)this + 120), v81);
              v51 = v58;
              v52 = v59;
            }
            *((_QWORD *)this + 15) = v56;
            *((_QWORD *)this + 16) = v57;
            v36 = 1;
            *((double *)this + 17) = v51;
            *((double *)this + 18) = v52;
            goto LABEL_51;
          }
          v54 = *((_DWORD *)this + 26);
          if (v54)
            *((_DWORD *)this + 26) = v54 - 1;
          _ImageIO_Free((unint64_t)__dst, v76);
        }
        else
        {
          _cg_jpeg_mem_term("copyImageBlockSetImp", 1448, "*** ImageIO_Malloc failed to alloc %ld bytes\n", v24);
          CachedBlocks = 0;
          v35 = 0;
        }
        v36 = 0;
        goto LABEL_51;
      }
    }
  }
  CachedBlocks = 0;
  if (!v15)
    goto LABEL_66;
LABEL_63:
  IIOReadPlugin::freeBlockArray(this);
  v15 = 0;
  if ((CachedBlocks & 1) == 0)
    return v15;
LABEL_67:
  v64 = (const char **)*((_QWORD *)this + 3);
  if (v64)
    IIOImageReadSession::unmapData(v64);
  return v15;
}

void sub_18805BDDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t GIFReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4, uint64_t a5, uint64_t *a6)
{
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *BaseAddress;
  size_t Height;
  size_t BytesPerRow;
  uint64_t v37;
  double v38;
  double v39;
  uint64_t v40;
  const void *Data;

  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v11 = *((_DWORD *)this + 51);
    v12 = v11 >> 24;
    v13 = MEMORY[0x1E0C80978];
    if (v11 < 0)
    {
      v14 = __maskrune(v12, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v11 >> 24);
    else
      v15 = 46;
    v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = (v11 << 8 >> 24);
    else
      v18 = 46;
    v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      v20 = __maskrune(v19, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20)
      v21 = ((__int16)v11 >> 8);
    else
      v21 = 46;
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      v22 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v15, v18, v21, v22, iioTypeStr[a3], "virtual OSStatus GIFReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    v22 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  *((_DWORD *)this + 52) = *((_QWORD *)a2 + 9);
  *((_DWORD *)this + 26) = 1;
  v23 = *((_QWORD *)a2 + 1);
  v24 = *((_QWORD *)a2 + 2);
  v25 = *((double *)a2 + 3);
  v26 = *((double *)a2 + 4);
  v27 = *((double *)a2 + 5);
  v28 = *((double *)a2 + 6);
  v29 = *((double *)a2 + 7);
  v30 = *((double *)a2 + 8);
  v31 = IIOImageSource::reader(a2);
  v32 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(_QWORD *)this + 200))(this, v23, v24, v31, v25, v26, v27, v28, v29, v30);
  v33 = v32;
  if (a3 == 1)
  {
    if (v32 && CGImageBlockSetGetCount() == 1 || *((_DWORD *)this + 26) == 1)
    {
      if (!a4 || !*a4)
      {
        v37 = 0;
        goto LABEL_50;
      }
      if (IOSurfaceLock(*a4, 0, 0))
      {
        v37 = 4294967246;
      }
      else
      {
        BaseAddress = IOSurfaceGetBaseAddress(*a4);
        IOSurfaceGetWidth(*a4);
        Height = IOSurfaceGetHeight(*a4);
        BytesPerRow = IOSurfaceGetBytesPerRow(*a4);
        if (v33)
          CGImageBlockSetGetImageBlock();
        CGImageBlockGetRect();
        v39 = v38;
        v40 = CGImageBlockGetBytesPerRow();
        Data = (const void *)CGImageBlockGetData();
        if (BytesPerRow == v40 && Height == (unint64_t)v39)
          memcpy(BaseAddress, Data, BytesPerRow * Height);
        else
          _cg_jpeg_mem_term("decodeImageImp", 1633, "*** ERROR: cannot copy into IOSurface\n");
        IOSurfaceUnlock(*a4, 1u, 0);
        v37 = 0;
      }
    }
    else
    {
      v37 = 4294967246;
      if (!a4)
        goto LABEL_50;
    }
    goto LABEL_48;
  }
  v37 = 4294967246;
  if (a3 == 3 && a6)
  {
    v37 = 0;
    *a6 = v32;
    v33 = 0;
  }
  if (a4)
  {
LABEL_48:
    if (*a4)
      IOSurfaceUnlock(*a4, 0, 0);
  }
LABEL_50:
  if (v33)
    CGImageBlockSetRelease();
  return v37;
}

_QWORD *std::allocate_shared[abi:ne180100]<GIFBufferInfo,std::allocator<GIFBufferInfo>,unsigned char *&,BOOL,unsigned int &,unsigned int &,unsigned int,void>@<X0>(unsigned __int8 **a1@<X1>, BOOL *a2@<X2>, unsigned int *a3@<X3>, unsigned int *a4@<X4>, unsigned int *a5@<X5>, _QWORD *a6@<X8>)
{
  _QWORD *v12;
  _QWORD *result;

  v12 = operator new(0x40uLL);
  result = std::__shared_ptr_emplace<GIFBufferInfo>::__shared_ptr_emplace[abi:ne180100]<unsigned char *&,BOOL,unsigned int &,unsigned int &,unsigned int,std::allocator<GIFBufferInfo>,0>(v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 3;
  a6[1] = v12;
  return result;
}

void sub_18805C200(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<GIFBufferInfo>::__shared_ptr_emplace[abi:ne180100]<unsigned char *&,BOOL,unsigned int &,unsigned int &,unsigned int,std::allocator<GIFBufferInfo>,0>(_QWORD *a1, unsigned __int8 **a2, BOOL *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_1E1BBC298;
  GIFBufferInfo::GIFBufferInfo((GIFBufferInfo *)(a1 + 3), *a2, *a3, *a4, *a5, *a6);
  return a1;
}

void sub_18805C25C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t png_write_filter_row_none_neon(int8x16_t *a1, uint64_t a2, unint64_t a3)
{
  int32x4_t v3;
  int32x4_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int32x4_t v12;
  uint64_t v13;
  uint32x4_t v14;
  __int32 v15;
  int16x4_t v16;

  v3 = 0uLL;
  if (a3 >= 0x40)
  {
    v4 = 0uLL;
    v5 = 0uLL;
    v6 = 0uLL;
    do
    {
      v7 = *a1;
      v8 = a1[1];
      v9 = a1[2];
      v10 = a1[3];
      a1 += 4;
      v3 = (int32x4_t)vpadalq_u16((uint32x4_t)v3, vpaddlq_u8((uint8x16_t)vabsq_s8(v7)));
      v4 = (int32x4_t)vpadalq_u16((uint32x4_t)v4, vpaddlq_u8((uint8x16_t)vabsq_s8(v8)));
      v5 = (int32x4_t)vpadalq_u16((uint32x4_t)v5, vpaddlq_u8((uint8x16_t)vabsq_s8(v9)));
      v6 = (int32x4_t)vpadalq_u16((uint32x4_t)v6, vpaddlq_u8((uint8x16_t)vabsq_s8(v10)));
      a3 -= 64;
    }
    while (a3 > 0x3F);
    v3 = vaddq_s32(vaddq_s32(v5, v6), vaddq_s32(v4, v3));
  }
  if (a3 >= 0x10)
  {
    do
    {
      v11 = *a1++;
      v3 = (int32x4_t)vpadalq_u16((uint32x4_t)v3, vpaddlq_u8((uint8x16_t)vabsq_s8(v11)));
      a3 -= 16;
    }
    while (a3 > 0xF);
  }
  v12.i64[0] = vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32((uint32x4_t)v3), 1), (uint32x4_t)v3).u64[0];
  v13 = v12.u32[0];
  if (a3 >= 4)
  {
    v14.i64[0] = 0x10000000100;
    v14.i64[1] = 0x10000000100;
    do
    {
      v15 = a1->i32[0];
      a1 = (int8x16_t *)((char *)a1 + 4);
      v12.i32[0] = v15;
      v16 = (int16x4_t)vmovl_u8(*(uint8x8_t *)v12.i8).u64[0];
      v12 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vcltz_s16(vshr_n_s16(vshl_n_s16(v16, 8uLL), 8uLL))), (int8x16_t)vsubw_u16(v14, (uint16x4_t)v16), (int8x16_t)vmovl_u16((uint16x4_t)v16));
      v13 = (vaddvq_s32(v12) + v13);
      a3 -= 4;
    }
    while (a3 > 3);
  }
  return v13;
}

uint64_t png_write_filter_row_sub_neon(int8x16_t *a1, _BYTE *a2, uint64_t a3, double a4, double a5, int32x4_t a6, int32x4_t a7)
{
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned __int8 *v11;
  int8x16_t *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  int32x4_t v19;
  int32x4_t v20;
  int32x4_t v21;
  unsigned __int8 *v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int v27;
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  uint64_t v32;
  int8x16_t v33;
  int32x4_t v34;
  unsigned __int32 v35;
  unsigned __int32 v36;
  int16x8_t v37;
  int16x4_t v38;
  int32x4_t v39;

  v7 = a1->u8[0];
  v8 = a1->u8[1];
  v9 = a1->u8[2];
  v10 = a1->u8[3];
  v11 = &a1->u8[4];
  *a2 = v7;
  a2[1] = v8;
  a2[2] = v9;
  a2[3] = v10;
  v12 = (int8x16_t *)(a2 + 4);
  if ((v7 & 0x80u) != 0)
    v7 = 256 - v7;
  v13 = 256 - v8;
  if ((v8 & 0x80u) == 0)
    v13 = v8;
  v14 = 256 - v9;
  if ((v9 & 0x80u) == 0)
    v14 = v9;
  v15 = 256 - v10;
  if ((v10 & 0x80u) == 0)
    v15 = v10;
  v16 = v13 + v7;
  v17 = v14 + v15;
  v18 = a3 - 4;
  v19 = 0uLL;
  if ((unint64_t)(a3 - 4) >= 0x40)
  {
    v20 = 0uLL;
    v21 = 0uLL;
    a7 = 0uLL;
    do
    {
      v22 = v11 + 64;
      v23 = vsubq_s8(*(int8x16_t *)v11, *(int8x16_t *)(v11 - 4));
      v24 = vsubq_s8(*((int8x16_t *)v11 + 1), *(int8x16_t *)(v11 + 12));
      v25 = vsubq_s8(*((int8x16_t *)v11 + 2), *(int8x16_t *)(v11 + 28));
      v26 = vsubq_s8(*((int8x16_t *)v11 + 3), *(int8x16_t *)(v11 + 44));
      *v12 = v23;
      v12[1] = v24;
      v12[2] = v25;
      v12[3] = v26;
      v12 += 4;
      v19 = (int32x4_t)vpadalq_u16((uint32x4_t)v19, vpaddlq_u8((uint8x16_t)vabsq_s8(v23)));
      v20 = (int32x4_t)vpadalq_u16((uint32x4_t)v20, vpaddlq_u8((uint8x16_t)vabsq_s8(v24)));
      v21 = (int32x4_t)vpadalq_u16((uint32x4_t)v21, vpaddlq_u8((uint8x16_t)vabsq_s8(v25)));
      a7 = (int32x4_t)vpadalq_u16((uint32x4_t)a7, vpaddlq_u8((uint8x16_t)vabsq_s8(v26)));
      v18 -= 64;
      v11 += 64;
    }
    while (v18 > 0x3F);
    a6 = vaddq_s32(v21, a7);
    v19 = vaddq_s32(a6, vaddq_s32(v20, v19));
    a1 = (int8x16_t *)(v22 - 4);
    v11 = v22;
  }
  v27 = v16 + v17;
  if (v18 >= 0x10)
  {
    do
    {
      v28 = *(int8x16_t *)v11;
      v11 += 16;
      v29 = v28;
      v30 = *a1++;
      a6.i32[1] = v30.i32[1];
      v31 = vsubq_s8(v29, v30);
      *v12++ = v31;
      v19 = (int32x4_t)vpadalq_u16((uint32x4_t)v19, vpaddlq_u8((uint8x16_t)vabsq_s8(v31)));
      v18 -= 16;
    }
    while (v18 > 0xF);
  }
  v32 = v27
      + vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32((uint32x4_t)v19), 1), (uint32x4_t)v19).u32[0];
  if (v18 >= 4)
  {
    v33.i64[0] = 0xFF000000FFLL;
    v33.i64[1] = 0xFF000000FFLL;
    v34.i64[0] = 0x10000000100;
    v34.i64[1] = 0x10000000100;
    do
    {
      v35 = *(_DWORD *)v11;
      v11 += 4;
      a6.i32[0] = v35;
      v36 = a1->i32[0];
      a1 = (int8x16_t *)((char *)a1 + 4);
      a7.i32[0] = v36;
      v37 = (int16x8_t)vsubl_u8(*(uint8x8_t *)a6.i8, *(uint8x8_t *)a7.i8);
      v12->i32[0] = vmovn_s16(v37).u32[0];
      v12 = (int8x16_t *)((char *)v12 + 4);
      v38 = vshr_n_s16(vshl_n_s16(*(int16x4_t *)v37.i8, 8uLL), 8uLL);
      v39 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v37.i8), v33);
      a7 = vmovl_s16(vcltz_s16(v38));
      a6 = (int32x4_t)vbslq_s8((int8x16_t)a7, (int8x16_t)vsubq_s32(v34, v39), (int8x16_t)v39);
      v32 = (vaddvq_s32(a6) + v32);
      v18 -= 4;
    }
    while (v18 > 3);
  }
  return v32;
}

uint64_t png_write_filter_row_up_neon(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, unint64_t a4, double a5, double a6, int32x4_t a7, int32x4_t a8)
{
  int32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  uint64_t v27;
  int8x16_t v28;
  int32x4_t v29;
  unsigned __int32 v30;
  unsigned __int32 v31;
  int16x8_t v32;
  int16x4_t v33;
  int32x4_t v34;

  v8 = 0uLL;
  if (a4 >= 0x40)
  {
    v9 = 0uLL;
    v10 = 0uLL;
    a8 = 0uLL;
    do
    {
      v11 = *a1;
      v12 = a1[1];
      v13 = a1[2];
      v14 = a1[3];
      a1 += 4;
      v15 = *a3;
      v16 = a3[1];
      v17 = a3[2];
      v18 = a3[3];
      a3 += 4;
      v19 = vsubq_s8(v11, v15);
      v20 = vsubq_s8(v12, v16);
      v21 = vsubq_s8(v13, v17);
      v22 = vsubq_s8(v14, v18);
      *a2 = v19;
      a2[1] = v20;
      a2[2] = v21;
      a2[3] = v22;
      a2 += 4;
      v8 = (int32x4_t)vpadalq_u16((uint32x4_t)v8, vpaddlq_u8((uint8x16_t)vabsq_s8(v19)));
      v9 = (int32x4_t)vpadalq_u16((uint32x4_t)v9, vpaddlq_u8((uint8x16_t)vabsq_s8(v20)));
      v10 = (int32x4_t)vpadalq_u16((uint32x4_t)v10, vpaddlq_u8((uint8x16_t)vabsq_s8(v21)));
      a8 = (int32x4_t)vpadalq_u16((uint32x4_t)a8, vpaddlq_u8((uint8x16_t)vabsq_s8(v22)));
      a4 -= 64;
    }
    while (a4 > 0x3F);
    a7 = vaddq_s32(v10, a8);
    v8 = vaddq_s32(a7, vaddq_s32(v9, v8));
  }
  if (a4 >= 0x10)
  {
    do
    {
      v23 = *a1++;
      v24 = v23;
      v25 = *a3++;
      a7.i32[1] = v25.i32[1];
      v26 = vsubq_s8(v24, v25);
      *a2++ = v26;
      v8 = (int32x4_t)vpadalq_u16((uint32x4_t)v8, vpaddlq_u8((uint8x16_t)vabsq_s8(v26)));
      a4 -= 16;
    }
    while (a4 > 0xF);
  }
  v27 = vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32((uint32x4_t)v8), 1), (uint32x4_t)v8).u32[0];
  if (a4 >= 4)
  {
    v28.i64[0] = 0xFF000000FFLL;
    v28.i64[1] = 0xFF000000FFLL;
    v29.i64[0] = 0x10000000100;
    v29.i64[1] = 0x10000000100;
    do
    {
      v30 = a1->i32[0];
      a1 = (int8x16_t *)((char *)a1 + 4);
      a7.i32[0] = v30;
      v31 = a3->i32[0];
      a3 = (int8x16_t *)((char *)a3 + 4);
      a8.i32[0] = v31;
      v32 = (int16x8_t)vsubl_u8(*(uint8x8_t *)a7.i8, *(uint8x8_t *)a8.i8);
      a2->i32[0] = vmovn_s16(v32).u32[0];
      a2 = (int8x16_t *)((char *)a2 + 4);
      v33 = vshr_n_s16(vshl_n_s16(*(int16x4_t *)v32.i8, 8uLL), 8uLL);
      v34 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v32.i8), v28);
      a8 = vmovl_s16(vcltz_s16(v33));
      a7 = (int32x4_t)vbslq_s8((int8x16_t)a8, (int8x16_t)vsubq_s32(v29, v34), (int8x16_t)v34);
      v27 = (vaddvq_s32(a7) + v27);
      a4 -= 4;
    }
    while (a4 > 3);
  }
  return v27;
}

uint64_t png_write_filter_row_avg_neon(unsigned __int32 *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint8x8_t a5, uint8x8_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  int8x16_t *v9;
  uint8x16_t *v10;
  __int32 v11;
  int16x8_t v12;
  int8x16_t *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int8x16_t *v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  uint32x4_t v30;
  int v31;
  int8x16_t v32;
  int8x16_t v33;
  uint8x16_t v34;
  uint8x16_t v35;
  uint8x16_t v36;
  int8x16_t v37;
  uint64_t v38;
  int8x16_t v39;
  int32x4_t v40;
  unsigned __int32 v41;
  unsigned __int32 v42;
  unsigned __int32 v43;
  int16x8_t v44;
  int16x4_t v45;
  int32x4_t v46;

  v9 = (int8x16_t *)(a1 + 1);
  a5.i32[0] = *a1;
  v11 = *a3;
  v10 = (uint8x16_t *)(a3 + 1);
  a6.i32[0] = v11;
  v12 = (int16x8_t)vmovl_u8(a5);
  *(int16x4_t *)v12.i8 = vsub_s16(*(int16x4_t *)v12.i8, (int16x4_t)vshr_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a6), 1uLL));
  *a2 = vmovn_s16(v12).u32[0];
  v13 = (int8x16_t *)(a2 + 1);
  v14 = 256 - v12.u8[0];
  if (v12.i8[0] >= 0)
    v14 = v12.u8[0];
  v15 = 256 - v12.u8[2];
  if (v12.i8[2] >= 0)
    v15 = v12.u8[2];
  v16 = 256 - v12.u8[4];
  if (v12.i8[4] >= 0)
    v16 = v12.u8[4];
  v17 = 256 - v12.u8[6];
  if (v12.i8[6] >= 0)
    v17 = v12.u8[6];
  v18 = v15 + v14;
  v19 = v16 + v17;
  v20 = a4 - 4;
  if ((unint64_t)(a4 - 4) < 0x40)
  {
    v30 = 0uLL;
  }
  else
  {
    v21 = 0;
    v22 = 0uLL;
    v23 = 0uLL;
    v24 = 0uLL;
    a8 = 0uLL;
    do
    {
      v25 = &v13[v21 / 0x10];
      v26 = vsubq_s8(*(int8x16_t *)&a1[v21 / 4 + 1], (int8x16_t)vhaddq_u8(*(uint8x16_t *)&a1[v21 / 4], v10[v21 / 0x10]));
      v27 = vsubq_s8(*(int8x16_t *)&a1[v21 / 4 + 5], (int8x16_t)vhaddq_u8(*(uint8x16_t *)&a1[v21 / 4 + 4], v10[v21 / 0x10 + 1]));
      v28 = vsubq_s8(*(int8x16_t *)&a1[v21 / 4 + 9], (int8x16_t)vhaddq_u8(*(uint8x16_t *)&a1[v21 / 4 + 8], v10[v21 / 0x10 + 2]));
      v29 = vsubq_s8(*(int8x16_t *)&a1[v21 / 4 + 13], (int8x16_t)vhaddq_u8(*(uint8x16_t *)&a1[v21 / 4 + 12], v10[v21 / 0x10 + 3]));
      *v25 = v26;
      v25[1] = v27;
      v25[2] = v28;
      v25[3] = v29;
      a9 = (int32x4_t)vpaddlq_u8((uint8x16_t)vabsq_s8(v26));
      v22 = (int32x4_t)vpadalq_u16((uint32x4_t)v22, (uint16x8_t)a9);
      v23 = (int32x4_t)vpadalq_u16((uint32x4_t)v23, vpaddlq_u8((uint8x16_t)vabsq_s8(v27)));
      v24 = (int32x4_t)vpadalq_u16((uint32x4_t)v24, vpaddlq_u8((uint8x16_t)vabsq_s8(v28)));
      a8 = (int32x4_t)vpadalq_u16((uint32x4_t)a8, vpaddlq_u8((uint8x16_t)vabsq_s8(v29)));
      v20 -= 64;
      v21 += 64;
    }
    while (v20 > 0x3F);
    a7 = vaddq_s32(v24, a8);
    v30 = (uint32x4_t)vaddq_s32(a7, vaddq_s32(v23, v22));
    a1 = (unsigned __int32 *)((char *)a1 + v21);
    v9 = (int8x16_t *)(a1 + 1);
    v10 = (uint8x16_t *)((char *)v10 + v21);
    v13 = (int8x16_t *)((char *)v13 + v21);
  }
  v31 = v18 + v19;
  if (v20 >= 0x10)
  {
    do
    {
      v32 = *v9++;
      v33 = v32;
      v34 = *(uint8x16_t *)a1;
      a1 += 4;
      v35 = v34;
      v36 = *v10++;
      a8.i32[1] = v36.i32[1];
      a7 = (int32x4_t)vhaddq_u8(v35, v36);
      v37 = vsubq_s8(v33, (int8x16_t)a7);
      *v13++ = v37;
      v30 = vpadalq_u16(v30, vpaddlq_u8((uint8x16_t)vabsq_s8(v37)));
      v20 -= 16;
    }
    while (v20 > 0xF);
  }
  v38 = v31 + vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v30), 1), v30).u32[0];
  if (v20 >= 4)
  {
    v39.i64[0] = 0xFF000000FFLL;
    v39.i64[1] = 0xFF000000FFLL;
    v40.i64[0] = 0x10000000100;
    v40.i64[1] = 0x10000000100;
    do
    {
      v41 = v9->i32[0];
      v9 = (int8x16_t *)((char *)v9 + 4);
      a7.i32[0] = v41;
      v42 = *a1++;
      a8.i32[0] = v42;
      v43 = v10->i32[0];
      v10 = (uint8x16_t *)((char *)v10 + 4);
      a9.i32[0] = v43;
      v44 = (int16x8_t)vmovl_u8(*(uint8x8_t *)a7.i8);
      *(int16x4_t *)v44.i8 = vsub_s16(*(int16x4_t *)v44.i8, (int16x4_t)vhadd_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)a9.i8), (uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)a8.i8)));
      v13->i32[0] = vmovn_s16(v44).u32[0];
      v13 = (int8x16_t *)((char *)v13 + 4);
      v45 = vshr_n_s16(vshl_n_s16(*(int16x4_t *)v44.i8, 8uLL), 8uLL);
      v46 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v44.i8), v39);
      a9 = vsubq_s32(v40, v46);
      a8 = vmovl_s16(vcltz_s16(v45));
      a7 = (int32x4_t)vbslq_s8((int8x16_t)a8, (int8x16_t)a9, (int8x16_t)v46);
      v38 = (vaddvq_s32(a7) + v38);
      v20 -= 4;
    }
    while (v20 > 3);
  }
  return v38;
}

uint64_t png_write_filter_row_paeth_neon(_BYTE *a1, unsigned __int8 *a2, _BYTE *a3, uint64_t a4, double a5, double a6, int8x16_t a7, uint16x8_t a8, int8x16_t a9, int8x16_t a10)
{
  unsigned __int8 v10;
  int v11;
  unsigned __int8 v12;
  int v13;
  unsigned __int8 v14;
  int v15;
  unsigned __int8 v16;
  int v17;
  int8x16_t *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  int32x4_t v31;
  int32x4_t v32;
  int8x16_t *v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t v39;
  uint16x8_t v40;
  uint16x8_t v41;
  uint8x8_t v42;
  uint16x8_t v43;
  uint8x8_t v44;
  int8x16_t v45;
  int8x16_t v46;
  uint16x8_t v47;
  int8x16_t v48;
  int8x16_t v49;
  uint32x4_t v50;
  int8x16_t *v51;
  int8x16_t *v52;
  int v53;
  int8x16_t v54;
  int8x16_t v55;
  int8x16_t v56;
  int8x16_t v57;
  uint8x16_t v58;
  uint16x8_t v59;
  uint8x8_t v60;
  uint16x8_t v61;
  int8x16_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int8x16_t v65;
  uint64_t v66;
  int8x16_t v67;
  int32x4_t v68;
  unsigned __int32 v69;
  unsigned __int32 v70;
  unsigned __int32 v71;
  unsigned __int32 v72;
  int8x8_t v73;
  int8x8_t v74;
  int8x8_t v75;
  uint32x4_t v76;
  uint32x4_t v77;
  uint32x4_t v78;
  uint32x4_t v79;
  int16x8_t v80;
  int16x4_t v81;
  int32x4_t v82;

  v10 = *a1 - *a3;
  v11 = (char)v10;
  v12 = a1[1] - a3[1];
  v13 = (char)v12;
  v14 = a1[2] - a3[2];
  v15 = (char)v14;
  v16 = a1[3] - a3[3];
  v17 = (char)v16;
  *a2 = v10;
  a2[1] = v12;
  a2[2] = v14;
  a2[3] = v16;
  v18 = (int8x16_t *)(a2 + 4);
  v19 = v10;
  v20 = 256 - v10;
  if (v11 >= 0)
    v20 = v19;
  v21 = v12;
  v22 = 256 - v12;
  if (v13 < 0)
    v21 = v22;
  v23 = v14;
  v24 = 256 - v14;
  if (v15 >= 0)
    v24 = v23;
  v25 = v16;
  v26 = 256 - v16;
  if (v17 >= 0)
    v26 = v25;
  v27 = v21 + v20;
  v28 = v24 + v26;
  v29 = a4 - 4;
  if ((unint64_t)(a4 - 4) < 0x20)
  {
    v51 = (int8x16_t *)(a1 + 4);
    v52 = (int8x16_t *)(a3 + 4);
    v50 = 0uLL;
  }
  else
  {
    v30 = 0;
    v31 = 0uLL;
    v32 = 0uLL;
    do
    {
      v33 = &v18[v30 / 0x10];
      v35 = *(int8x16_t *)&a1[v30];
      v34 = *(int8x16_t *)&a1[v30 + 16];
      v36 = *(int8x16_t *)&a3[v30 + 4];
      v37 = *(int8x16_t *)&a3[v30 + 20];
      v39 = *(int8x16_t *)&a3[v30];
      v38 = *(int8x16_t *)&a3[v30 + 16];
      v40 = vabdq_u16(vaddl_u8(*(uint8x8_t *)v36.i8, *(uint8x8_t *)v35.i8), vshll_n_u8(*(uint8x8_t *)v39.i8, 1uLL));
      v41 = vabdq_u16(vaddl_u8(*(uint8x8_t *)v37.i8, *(uint8x8_t *)v34.i8), vshll_n_u8(*(uint8x8_t *)v38.i8, 1uLL));
      v42 = (uint8x8_t)vextq_s8(v39, v39, 8uLL).u64[0];
      v43 = vabdq_u16(vaddl_high_u8((uint8x16_t)v36, (uint8x16_t)v35), vshll_high_n_u8((uint8x16_t)v39, 1uLL));
      v44 = (uint8x8_t)vextq_s8(v38, v38, 8uLL).u64[0];
      *(int8x8_t *)v45.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v40, vabdl_u8(*(uint8x8_t *)v36.i8, *(uint8x8_t *)v39.i8))), (int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v35.i8, *(uint8x8_t *)v39.i8), vabd_u8(*(uint8x8_t *)v36.i8, *(uint8x8_t *)v39.i8)));
      *(int8x8_t *)v46.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v41, vabdl_u8(*(uint8x8_t *)v37.i8, *(uint8x8_t *)v38.i8))), (int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v34.i8, *(uint8x8_t *)v38.i8), vabd_u8(*(uint8x8_t *)v37.i8, *(uint8x8_t *)v38.i8)));
      v47 = vabdq_u16(vaddl_high_u8((uint8x16_t)v37, (uint8x16_t)v34), vshll_high_n_u8((uint8x16_t)v38, 1uLL));
      v45.u64[1] = (unint64_t)vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v43, vabdl_high_u8((uint8x16_t)v36, (uint8x16_t)v39))), (int8x8_t)vcge_u8(vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL), v42), vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), v42)));
      v46.u64[1] = (unint64_t)vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v47, vabdl_high_u8((uint8x16_t)v37, (uint8x16_t)v38))), (int8x8_t)vcge_u8(vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), v44), vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), v44)));
      a10 = vbslq_s8(v45, v35, vbslq_s8(vuzp1q_s8((int8x16_t)vcgeq_u16(v40, vabdl_u8(*(uint8x8_t *)v35.i8, *(uint8x8_t *)v39.i8)), (int8x16_t)vcgeq_u16(v43, vabdl_high_u8((uint8x16_t)v35, (uint8x16_t)v39))), v36, v39));
      a9 = vbslq_s8(v46, v34, vbslq_s8(vuzp1q_s8((int8x16_t)vcgeq_u16(v41, vabdl_u8(*(uint8x8_t *)v34.i8, *(uint8x8_t *)v38.i8)), (int8x16_t)vcgeq_u16(v47, vabdl_high_u8((uint8x16_t)v34, (uint8x16_t)v38))), v37, v38));
      v48 = vsubq_s8(*(int8x16_t *)&a1[v30 + 4], a10);
      v49 = vsubq_s8(*(int8x16_t *)&a1[v30 + 20], a9);
      *v33 = v48;
      v33[1] = v49;
      a7 = (int8x16_t)vpaddlq_u8((uint8x16_t)vabsq_s8(v48));
      a8 = vpaddlq_u8((uint8x16_t)vabsq_s8(v49));
      v31 = (int32x4_t)vpadalq_u16((uint32x4_t)v31, (uint16x8_t)a7);
      v32 = (int32x4_t)vpadalq_u16((uint32x4_t)v32, a8);
      v29 -= 32;
      v30 += 32;
    }
    while (v29 > 0x1F);
    v50 = (uint32x4_t)vaddq_s32(v31, v32);
    a1 += v30;
    v51 = (int8x16_t *)(a1 + 4);
    a3 += v30;
    v52 = (int8x16_t *)(a3 + 4);
    v18 = (int8x16_t *)((char *)v18 + v30);
  }
  v53 = v27 + v28;
  if (v29 >= 0x10)
  {
    do
    {
      v54 = *(int8x16_t *)a1;
      a1 += 16;
      v55 = v54;
      v56 = *v52++;
      v57 = v56;
      v58 = *(uint8x16_t *)a3;
      a3 += 16;
      a8 = (uint16x8_t)v58;
      v59 = vabdq_u16(vaddl_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v55.i8), vshll_n_u8(*(uint8x8_t *)v58.i8, 1uLL));
      v60 = (uint8x8_t)vextq_s8((int8x16_t)a8, (int8x16_t)a8, 8uLL).u64[0];
      *(int8x8_t *)a9.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v59, vabdl_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v58.i8))), (int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v55.i8, *(uint8x8_t *)v58.i8), vabd_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v58.i8)));
      v61 = vabdq_u16(vaddl_high_u8((uint8x16_t)v57, (uint8x16_t)v55), vshll_high_n_u8(v58, 1uLL));
      a9.u64[1] = (unint64_t)vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v61, vabdl_high_u8((uint8x16_t)v57, v58))), (int8x8_t)vcge_u8(vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), v60), vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL), v60)));
      v62 = (int8x16_t)vcgeq_u16(v59, vabdl_u8(*(uint8x8_t *)v55.i8, *(uint8x8_t *)v58.i8));
      v63 = (int8x16_t)vcgeq_u16(v61, vabdl_high_u8((uint8x16_t)v55, v58));
      v64 = *v51++;
      a10 = vuzp1q_s8(v62, v63);
      a7 = vbslq_s8(a10, v57, (int8x16_t)a8);
      v65 = vsubq_s8(v64, vbslq_s8(a9, v55, a7));
      *v18++ = v65;
      v50 = vpadalq_u16(v50, vpaddlq_u8((uint8x16_t)vabsq_s8(v65)));
      v29 -= 16;
    }
    while (v29 > 0xF);
  }
  v66 = v53 + vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v50), 1), v50).u32[0];
  if (v29 >= 4)
  {
    v67.i64[0] = 0xFF000000FFLL;
    v67.i64[1] = 0xFF000000FFLL;
    v68.i64[0] = 0x10000000100;
    v68.i64[1] = 0x10000000100;
    do
    {
      v69 = v51->i32[0];
      v51 = (int8x16_t *)((char *)v51 + 4);
      a7.i32[0] = v69;
      v70 = *(_DWORD *)a1;
      a1 += 4;
      a8.i32[0] = v70;
      v71 = v52->i32[0];
      v52 = (int8x16_t *)((char *)v52 + 4);
      a9.i32[0] = v71;
      v72 = *(_DWORD *)a3;
      a3 += 4;
      a10.i32[0] = v72;
      v73 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a8.i8).u64[0];
      v74 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a9.i8).u64[0];
      v75 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a10.i8).u64[0];
      v76 = vmovl_u16((uint16x4_t)v75);
      v77 = vabdq_u32(vmovl_u16((uint16x4_t)v74), v76);
      v78 = vabdq_u32(vmovl_u16((uint16x4_t)v73), v76);
      v79 = (uint32x4_t)vabsq_s32(vaddq_s32((int32x4_t)vsubl_u16((uint16x4_t)v74, (uint16x4_t)v75), (int32x4_t)vsubl_u16((uint16x4_t)v73, (uint16x4_t)v75)));
      v80 = (int16x8_t)vmovl_u8(*(uint8x8_t *)a7.i8);
      *(int16x4_t *)v80.i8 = vsub_s16(*(int16x4_t *)v80.i8, (int16x4_t)vbsl_s8((int8x8_t)vmovn_s32((int32x4_t)vcgtq_u32(v77, vminq_u32(v78, v79))), vbsl_s8((int8x8_t)vmovn_s32((int32x4_t)vcgtq_u32(v78, v79)), v75, v74), v73));
      *(int8x8_t *)a8.i8 = vmovn_s16(v80);
      v81 = vshr_n_s16(vshl_n_s16(*(int16x4_t *)v80.i8, 8uLL), 8uLL);
      v82 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v80.i8), v67);
      a10 = (int8x16_t)vsubq_s32(v68, v82);
      a9 = (int8x16_t)vmovl_s16(vcltz_s16(v81));
      v18->i32[0] = a8.i32[0];
      v18 = (int8x16_t *)((char *)v18 + 4);
      a7 = vbslq_s8(a9, a10, (int8x16_t)v82);
      v66 = (vaddvq_s32((int32x4_t)a7) + v66);
      v29 -= 4;
    }
    while (v29 > 3);
  }
  return v66;
}

void IIO_LoadJPEGSymbols()
{
  if (gLoadCoreVideoSymbolsInitOnce != -1)
    dispatch_once(&gLoadCoreVideoSymbolsInitOnce, &__block_literal_global_38);
}

void IIO_LoadCoreMediaSymbols()
{
  if (gLoadCoreMediaSymbolsInitOnce != -1)
    dispatch_once(&gLoadCoreMediaSymbolsInitOnce, &__block_literal_global_13_0);
}

OSStatus CGAnimateImageAtURLWithBlock(CFURLRef url, CFDictionaryRef options, CGImageSourceAnimationBlock block)
{
  unsigned int v6;
  CFTypeID v7;
  CFTypeID v8;
  IIOImageSource *v9;
  OSStatus v10;
  const void *v11;
  _QWORD v13[3];

  kdebug_trace();
  IIOInitDebugFlags();
  v6 = (gIIODebugFlags >> 12) & 3;
  if (v6)
    ImageIODebugOptions(v6, "A", "CGAnimateImageAtURLWithBlock", url, 0, -1, 0);
  if (!url)
  {
    LogError("CGAnimateImageAtURLWithBlock", 123, "*** ERROR: CGAnimateImageAtURLWithBlock: url is nil\n");
LABEL_16:
    v10 = -50;
    goto LABEL_13;
  }
  v7 = CFGetTypeID(url);
  if (v7 != CFURLGetTypeID())
  {
    LogError("CGAnimateImageAtURLWithBlock", 124, "*** ERROR: CGAnimateImageAtURLWithBlock: url is not a CFURLRef\n");
    goto LABEL_16;
  }
  if (options)
  {
    v8 = CFGetTypeID(options);
    if (v8 != CFDictionaryGetTypeID())
    {
      LogError("CGAnimateImageAtURLWithBlock", 127, "*** ERROR: CGAnimateImageAtURLWithBlock: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  memset(v13, 0, sizeof(v13));
  IIODictionary::IIODictionary((IIODictionary *)v13, options);
  v9 = (IIOImageSource *)operator new();
  IIOImageSource::IIOImageSource(v9, url, (IIODictionary *)v13);
  if (IIOImageSource::errorStatus(v9))
  {
    (*(void (**)(IIOImageSource *))(*(_QWORD *)v9 + 8))(v9);
    v10 = -50;
  }
  else
  {
    IIOImageSource::lock(v9);
    v11 = (const void *)CGImageSourceRefCreateWith_ImageSource((uint64_t)v9);
    IIOImageSource::unlock(v9);
    v10 = IIOImageSource::animateWithBlock((uint64_t)v9, (uint64_t)v13, (uint64_t)block);
    if (v10 == -4)
      CFRelease(v11);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v13);
LABEL_13:
  kdebug_trace();
  return v10;
}

void sub_18805CEA8(void *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x18D761C30](v2, 0x10E1C40B803A584);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18805CE3CLL);
}

OSStatus CGAnimateImageDataWithBlock(CFDataRef data, CFDictionaryRef options, CGImageSourceAnimationBlock block)
{
  unsigned int v6;
  CFTypeID v7;
  CFTypeID v8;
  IIOImageSource *v9;
  const void *v10;
  OSStatus v11;
  _QWORD v13[3];

  kdebug_trace();
  IIOInitDebugFlags();
  v6 = (gIIODebugFlags >> 12) & 3;
  if (v6)
    ImageIODebugOptions(v6, "A", "CGAnimateImageDataWithBlock", data, 0, -1, 0);
  if (!data)
  {
    LogError("CGAnimateImageDataWithBlock", 177, "*** ERROR: CGImageSourceCreateWithData: data is nil\n");
LABEL_14:
    v11 = -50;
    goto LABEL_11;
  }
  v7 = CFGetTypeID(data);
  if (v7 != CFDataGetTypeID())
  {
    LogError("CGAnimateImageDataWithBlock", 178, "*** ERROR: CGImageSourceCreateWithData: data is not a CFDataRef\n");
    goto LABEL_14;
  }
  if (options)
  {
    v8 = CFGetTypeID(options);
    if (v8 != CFDictionaryGetTypeID())
    {
      LogError("CGAnimateImageDataWithBlock", 181, "*** ERROR: CGImageSourceCreateWithData: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  memset(v13, 0, sizeof(v13));
  IIODictionary::IIODictionary((IIODictionary *)v13, options);
  v9 = (IIOImageSource *)operator new();
  IIOImageSource::IIOImageSource(v9, data, (IIODictionary *)v13);
  IIOImageSource::lock(v9);
  v10 = (const void *)CGImageSourceRefCreateWith_ImageSource((uint64_t)v9);
  IIOImageSource::unlock(v9);
  v11 = IIOImageSource::animateWithBlock((uint64_t)v9, (uint64_t)v13, (uint64_t)block);
  if (v11 == -4)
    CFRelease(v10);
  IIODictionary::~IIODictionary((IIODictionary *)v13);
LABEL_11:
  kdebug_trace();
  return v11;
}

void sub_18805D0C8(void *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x18D761C30](v2, 0x10E1C40B803A584);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18805D05CLL);
}

uint64_t IIODecodeParameter::saveDataToXPCObject(IIODecodeParameter *this, void *a2)
{
  xpc_object_t v4;
  xpc_object_t v5;

  v4 = iio_xpc_add_source_dict(a2);
  v5 = iio_xpc_add_callback_dict(a2);
  iio_xpc_dictionary_addCGRect(v5, "iio_xpc_cb_blockset_cgrect", *((double *)this + 3), *((double *)this + 4), *((double *)this + 5), *((double *)this + 6));
  iio_xpc_dictionary_addCGSize(v5, "iio_xpc_cb_blockset_dest_cgsize", *((double *)this + 7), *((double *)this + 8));
  xpc_dictionary_set_uint64(v4, "iio_xpc_src_image_index", *((_QWORD *)this + 9));
  iio_xpc_dictionary_add_CFDictionary(v5, "iio_xpc_cb_blockset_options");
  return 0;
}

void IIO_Writer_TGA::~IIO_Writer_TGA(IIO_Writer_TGA *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t IIO_Writer_TGA::write(IIO_Writer_TGA *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v3;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  TGAWritePlugin::TGAWritePlugin((TGAWritePlugin *)v5, a2, a3);
  v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v5);
  TGAWritePlugin::~TGAWritePlugin((TGAWritePlugin *)v5);
  return v3;
}

void sub_18805D248(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TGAWritePlugin::~TGAWritePlugin((TGAWritePlugin *)&a9);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18805D234);
}

uint64_t _cg_TIFFComputeTile(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;

  v5 = *(_DWORD *)(a1 + 100);
  v6 = *(_DWORD *)(a1 + 104);
  v7 = *(_DWORD *)(a1 + 96);
  if (v7 == 1)
    v8 = 0;
  else
    v8 = a4;
  if (v5 == -1)
    v5 = *(_DWORD *)(a1 + 88);
  if (v6 == -1)
    v6 = *(_DWORD *)(a1 + 92);
  if (*(_DWORD *)(a1 + 108) == -1)
    v9 = *(_DWORD *)(a1 + 96);
  else
    v9 = *(_DWORD *)(a1 + 108);
  if (v5)
    v10 = v6 == 0;
  else
    v10 = 1;
  if (v10 || v9 == 0)
    return 1;
  v13 = 0;
  v14 = *(_DWORD *)(a1 + 88);
  if (v14 < -v5)
    v13 = (v5 + v14 - 1) / v5;
  v15 = 0;
  v16 = *(_DWORD *)(a1 + 92);
  if (v16 < -v6)
    v15 = (v6 + v16 - 1) / v6;
  v17 = 0;
  if (v7 < -v9)
    v17 = (v7 + v9 - 1) / v9;
  v18 = v8 / v9;
  v19 = a3 / v6;
  if (*(_WORD *)(a1 + 170) == 2)
    v18 += v17 * a5;
  return a2 / v5 + (v19 + v18 * v15) * v13;
}

uint64_t TIFFCheckTile(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 88) <= a2)
  {
    TIFFErrorExtR(a1, *(const char **)a1, "%lu: Col out of range, max %lu", a4, a5, a6, a7, a8, a2);
  }
  else if (*(_DWORD *)(a1 + 92) <= a3)
  {
    TIFFErrorExtR(a1, *(const char **)a1, "%lu: Row out of range, max %lu", a4, a5, a6, a7, a8, a3);
  }
  else if (*(_DWORD *)(a1 + 96) <= a4)
  {
    TIFFErrorExtR(a1, *(const char **)a1, "%lu: Depth out of range, max %lu", a4, a5, a6, a7, a8, a4);
  }
  else
  {
    if (*(_WORD *)(a1 + 170) != 2 || *(unsigned __int16 *)(a1 + 130) > a5)
      return 1;
    TIFFErrorExtR(a1, *(const char **)a1, "%lu: Sample out of range, max %lu", a4, a5, a6, a7, a8, a5);
  }
  return 0;
}

uint64_t _cg_TIFFNumberOfTiles(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;

  v10 = *(_DWORD *)(a1 + 100);
  v9 = *(_DWORD *)(a1 + 104);
  if (v10 == -1)
    v10 = *(_DWORD *)(a1 + 88);
  v11 = *(_DWORD *)(a1 + 108);
  if (v9 == -1)
    v9 = *(_DWORD *)(a1 + 92);
  if (v11 == -1)
    v11 = *(_DWORD *)(a1 + 96);
  v12 = 0;
  if (v10 && v9 && v11)
  {
    v13 = 0;
    v14 = *(_DWORD *)(a1 + 88);
    if (v14 < -v10)
      v13 = (v10 + v14 - 1) / v10;
    v15 = 0;
    v16 = *(_DWORD *)(a1 + 92);
    if (v16 < -v9)
      v15 = (v9 + v16 - 1) / v9;
    v17 = _TIFFMultiply32(a1, v13, v15, "TIFFNumberOfTiles", a5, a6, a7, a8);
    v22 = 0;
    v23 = *(_DWORD *)(a1 + 96);
    if (v23 < -v11)
      v22 = (v11 + v23 - 1) / v11;
    v12 = _TIFFMultiply32(a1, v17, v22, "TIFFNumberOfTiles", v18, v19, v20, v21);
  }
  if (*(_WORD *)(a1 + 170) == 2)
    return _TIFFMultiply32(a1, v12, *(unsigned __int16 *)(a1 + 130), "TIFFNumberOfTiles", a5, a6, a7, a8);
  else
    return v12;
}

uint64_t _cg_TIFFTileRowSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v9 = _cg_TIFFTileRowSize64(a1, a2, a3, a4, a5, a6, a7, a8);
  return _TIFFCastUInt64ToSSize(a1, v9, "TIFFTileRowSize", v10, v11, v12, v13, v14);
}

unint64_t _cg_TIFFTileSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return TIFFVTileSize64(a1, *(unsigned int *)(a1 + 104), a3, a4, a5, a6, a7, a8);
}

uint64_t _cg_TIFFTileSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v9 = TIFFVTileSize64(a1, *(unsigned int *)(a1 + 104), a3, a4, a5, a6, a7, a8);
  return _TIFFCastUInt64ToSSize(a1, v9, "TIFFTileSize", v10, v11, v12, v13, v14);
}

void _TIFFDefaultTileSize(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  v3 = *a2;
  if ((int)*a2 <= 0)
  {
    v3 = 256;
    *a2 = 256;
  }
  v4 = *a3;
  if ((int)*a3 <= 0)
  {
    v4 = 256;
    *a3 = 256;
    v3 = *a2;
  }
  if ((v3 & 0xF) != 0)
  {
    if (v3 >= 0xFFFFFFF0)
      v5 = 0;
    else
      v5 = (v3 + 15) & 0xFFFFFFF0;
    *a2 = v5;
    v4 = *a3;
  }
  if ((v4 & 0xF) != 0)
  {
    v6 = (v4 + 15) & 0xFFFFFFF0;
    if (v4 >= 0xFFFFFFF0)
      v6 = 0;
    *a3 = v6;
  }
}

void EXRWritePlugin::EXRWritePlugin(EXRWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  _QWORD *v4;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 8u);
  *v4 = &off_1E1BAE088;
  AppleEXREnabled();
  *((_QWORD *)this + 5) = 0;
}

void sub_18805D634(_Unwind_Exception *a1, uint64_t a2, const char *a3)
{
  uint64_t v3;

  _cg_jpeg_mem_term(v3, a2, a3);
  _Unwind_Resume(a1);
}

void EXRWritePlugin::~EXRWritePlugin(EXRWritePlugin *this, uint64_t a2, const char *a3)
{
  void *v4;

  *(_QWORD *)this = &off_1E1BAE088;
  v4 = (void *)*((_QWORD *)this + 5);
  if (v4)
    os_release(v4);
  _cg_jpeg_mem_term(this, a2, a3);
}

{
  EXRWritePlugin::~EXRWritePlugin(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t EXRWritePlugin::writeOneImage(EXRWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t EXRWritePlugin::writeOne(EXRWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t EXRWritePlugin::writeAll(IIOImageDestination **this)
{
  unsigned int ImageCount;
  uint64_t v3;
  unint64_t i;
  CGImage *SourceImageAtIndex;
  IIODictionary *PropertiesAtIndex;
  EXRWritePluginInput *v7;

  ImageCount = IIOWritePlugin::getImageCount(this);
  v3 = gFunc_axr_encoder_create(0);
  this[5] = (IIOImageDestination *)v3;
  if (ImageCount)
  {
    for (i = 0; i != ImageCount; ++i)
    {
      SourceImageAtIndex = (CGImage *)IIOWritePlugin::getSourceImageAtIndex(this, i);
      PropertiesAtIndex = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex(this, i);
      v7 = (EXRWritePluginInput *)operator new();
      EXRWritePluginInput::EXRWritePluginInput(v7, this[5], SourceImageAtIndex, PropertiesAtIndex);
    }
    v3 = (uint64_t)this[5];
  }
  return gFunc_axr_encoder_compress(v3, this, EXRWritePlugin::WriteCallback, 0, EXRWritePlugin::DestroyCallback, 0);
}

void sub_18805D79C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40C0714077);
  _Unwind_Resume(a1);
}

size_t EXRWritePlugin::WriteCallback(IIOImageWriteSession **this, void *a2, const unsigned __int8 *a3)
{
  return IIOImageWriteSession::putBytes(this[2], a2, (size_t)a3);
}

uint64_t EXRWritePlugin::WriteProc(EXRWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  _OWORD v11[3];

  if (!AppleEXREnabled())
    return 4294967246;
  memset(v11, 0, sizeof(v11));
  EXRWritePlugin::EXRWritePlugin((EXRWritePlugin *)v11, this, a2);
  v7 = EXRWritePlugin::writeAll((IIOImageDestination **)v11);
  EXRWritePlugin::~EXRWritePlugin((EXRWritePlugin *)v11, v8, v9);
  return v7;
}

void EXRWritePluginInput::EXRWritePluginInput(EXRWritePluginInput *this, axr_encoder *a2, CGImageRef image, IIODictionary *a4)
{
  CGColorSpace *ColorSpace;
  int HasRealAlphaChannel;
  unint64_t v9;
  size_t BitsPerComponent;
  int v11;
  int v12;
  CGColorSpaceModel Model;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  IIODictionary *v18;
  unsigned int v19;
  IIODictionary *v20;
  unsigned int Uint32ForKey;
  uint64_t v22;
  int Width;
  size_t Height;
  uint64_t appended;
  uint64_t v26;
  const __CFDictionary *ObjectForKeyGroup;
  uint64_t v28;
  CFIndex v29;
  CFIndex v30;
  const char *v31;
  _QWORD v32[3];
  _QWORD v33[2];
  _QWORD v34[2];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E1BB1B18;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = image;
  *((_QWORD *)this + 3) = a4;
  v37 = 0uLL;
  v35 = 0u;
  v36 = 0u;
  ColorSpace = CGImageGetColorSpace(image);
  HasRealAlphaChannel = _ImageHasRealAlphaChannel(image);
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 27) = 0;
  if ((CGImageGetBitmapInfo(image) & 0x100) != 0)
    v9 = 16;
  else
    v9 = 10;
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (BitsPerComponent <= v9)
    v11 = 1;
  else
    v11 = 2;
  *((_DWORD *)this + 26) = v11;
  if (BitsPerComponent <= v9)
    v12 = 16;
  else
    v12 = 32;
  *((_DWORD *)this + 28) = v12;
  while (1)
  {
    Model = CGColorSpaceGetModel(ColorSpace);
    if (Model != kCGColorSpaceModelIndexed)
      break;
    ColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
  }
  switch(Model)
  {
    case kCGColorSpaceModelMonochrome:
      v14 = 0;
      v15 = 1;
      if (HasRealAlphaChannel)
        v16 = 2;
      else
        v16 = 1;
      *((_DWORD *)this + 27) = v16;
      if (HasRealAlphaChannel)
        v17 = 4;
      else
        v17 = -1;
      LODWORD(v37) = 10;
      DWORD1(v37) = v17;
      *((_QWORD *)&v37 + 1) = -1;
      *(_QWORD *)&v35 = "Y";
      goto LABEL_24;
    case kCGColorSpaceModelRGB:
    case kCGColorSpaceModelCMYK:
      *((_DWORD *)this + 27) = 4;
      v37 = xmmword_18822B780;
      *(_QWORD *)&v35 = "R";
      *((_QWORD *)&v35 + 1) = "G";
      *(_QWORD *)&v36 = "B";
      v14 = 1;
      goto LABEL_23;
    case kCGColorSpaceModelXYZ:
      *((_DWORD *)this + 27) = 4;
      v37 = xmmword_18822DB20;
      *(_QWORD *)&v35 = "X";
      *((_QWORD *)&v35 + 1) = "Y";
      *(_QWORD *)&v36 = "Z";
      v14 = 7;
LABEL_23:
      v15 = 3;
LABEL_24:
      *((_QWORD *)&v35 + v15) = "A";
      v18 = (IIODictionary *)*((_QWORD *)this + 3);
      if (!v18)
        goto LABEL_32;
      v19 = IIODictionary::containsKey(v18, CFSTR("Compression"));
      v20 = (IIODictionary *)*((_QWORD *)this + 3);
      if (v19)
      {
        Uint32ForKey = IIODictionary::getUint32ForKey(v20, CFSTR("Compression"));
      }
      else
      {
        if (!IIODictionary::containsKeyGroup(v20, CFSTR("Compression"), CFSTR("{EXR}")))
        {
LABEL_32:
          v22 = 4;
          goto LABEL_33;
        }
        Uint32ForKey = IIODictionary::getUint32ForKeyGroup(*((IIODictionary **)this + 3), CFSTR("Compression"), CFSTR("{EXR}"));
      }
      if (Uint32ForKey <= 7)
        v22 = Uint32ForKey;
      else
        v22 = 4;
LABEL_33:
      Width = CGImageGetWidth(image);
      Height = CGImageGetHeight(image);
      appended = gFunc_axr_encoder_append_part(a2, "part name", 0, v22, (unint64_t)(Width - 1) << 32, (Height << 32) - 0x100000000, (unint64_t)(Width - 1) << 32, (Height << 32) - 0x100000000, 1.0, (float)(Width - 1) * 0.5, (float)(int)(((Height << 32) - 0x100000000) >> 32) * 0.5, (float)Width, 72.0, 0, 0);
      if (appended)
      {
        v26 = appended;
        ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(*((IIODictionary **)this + 3), CFSTR("Chromaticities"), CFSTR("{EXR}"));
        memset(v32, 0, sizeof(v32));
        IIOArray::IIOArray((IIOArray *)v32, ObjectForKeyGroup);
        if (IIOArray::getCount((IIOArray *)v32) == 8)
        {
          v28 = 0;
          v29 = 0;
          v34[0] = 0;
          v34[1] = 0;
          v33[0] = 0;
          v33[1] = 0;
          do
          {
            *(float *)((char *)v34 + v28) = IIOArray::getFloatAtIndex((IIOArray *)v32, v29);
            v30 = v29 + 1;
            *(float *)((char *)v33 + v28) = IIOArray::getFloatAtIndex((IIOArray *)v32, v30);
            v28 += 4;
            v29 = v30 + 1;
          }
          while (v28 != 16);
          gFunc_axr_part_set_chromaticities(v26, v14, v34, v33, 1.0);
        }
        else
        {
          gFunc_axr_part_set_chromaticities(v26, v14, 0, 0, 1.0);
        }
        IIOArray::~IIOArray((IIOArray *)v32);
        *((_QWORD *)this + 17) = gFunc_axr_part_create_colorspace(v26, 2, 0);
        gFunc_axr_part_append_channels(v26, 0, *((unsigned int *)this + 26), 1, 1, 0, &v37, &v35, *((unsigned int *)this + 27), EXRWritePluginInput::ReadCallback, EXRWritePluginInput::ReleaseCallback, this);
      }
      return;
    default:
      v31 = IIO_ColorModelString(Model);
      LogError("EXRWritePluginInput", 112, "*** colorspaceModel '%s' not handled\n", v31);
      return;
  }
}

void sub_18805DCB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

unint64_t EXRWritePluginInput::ReadCallback(const CGFloat *this, unint64_t a2, unint64_t a3, axr_size_t a4, EXRWritePluginInput *a5)
{
  axr_size_t v10;

  v10 = a4;
  return EXRWritePluginInput::readCB(a5, this, a2, a3, v10);
}

uint64_t EXRWritePluginInput::ReleaseCallback(uint64_t this)
{
  if (this)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 8))(this);
  return this;
}

void EXRWritePluginInput::~EXRWritePluginInput(EXRWritePluginInput *this)
{
  EXRWritePluginInput::~EXRWritePluginInput(this);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v2;
  CGColorSpace *v3;

  *(_QWORD *)this = &off_1E1BB1B18;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (CGColorSpace *)*((_QWORD *)this + 17);
  if (v3)
    CGColorSpaceRelease(v3);
}

unint64_t EXRWritePluginInput::readCB(EXRWritePluginInput *this, const CGFloat *a2, unint64_t a3, unint64_t a4, axr_size_t a5)
{
  IIOPixelProvider *v8;
  uint64_t v9;
  unint64_t v10;
  uint32_t v11;
  BOOL v12;
  CGBitmapInfo v13;
  int v14;
  IIOPixelProvider *v15;
  size_t Width;
  unint64_t v17;
  uint64_t v18;
  _QWORD v20[5];
  vImage_CGImageFormat v21;

  v8 = (IIOPixelProvider *)*((_QWORD *)this + 4);
  if (v8)
  {
    v10 = *((_QWORD *)this + 10);
    v9 = *((_QWORD *)this + 11);
  }
  else
  {
    v11 = *((_DWORD *)this + 27) * *((_DWORD *)this + 28);
    v21.bitsPerComponent = *((_DWORD *)this + 28);
    v21.bitsPerPixel = v11;
    v21.colorSpace = (CGColorSpaceRef)*((_QWORD *)this + 17);
    memset(&v21.bitmapInfo, 0, 24);
    if (CGColorSpaceGetModel(v21.colorSpace) || (CGImageHasAlpha() & 1) != 0)
    {
      v12 = *((_DWORD *)this + 28) == 32;
      v13 = 4355;
      v14 = 8451;
    }
    else
    {
      v12 = *((_DWORD *)this + 28) == 32;
      v13 = 4352;
      v14 = 8448;
    }
    if (v12)
      v13 = v14;
    v21.bitmapInfo = v13;
    *(_OWORD *)&v21.version = 0uLL;
    v15 = (IIOPixelProvider *)operator new();
    IIOPixelProvider::IIOPixelProvider(v15, *((CGImage **)this + 2), &v21, 0);
    *((_QWORD *)this + 4) = v15;
    *((_QWORD *)this + 9) = CGImageGetHeight(*((CGImageRef *)this + 2));
    Width = CGImageGetWidth(*((CGImageRef *)this + 2));
    v9 = 0;
    v10 = (Width * v21.bitsPerPixel) >> 3;
    *((_QWORD *)this + 10) = v10;
    *((_QWORD *)this + 11) = 0;
    v8 = (IIOPixelProvider *)*((_QWORD *)this + 4);
  }
  v17 = a3 / v10;
  *(_QWORD *)&v21.bitsPerComponent = 0;
  v21.colorSpace = (CGColorSpaceRef)&v21;
  *(_QWORD *)&v21.bitmapInfo = 0x2000000000;
  v21.decode = a2;
  if (v9 + a3 / v10 >= *((_QWORD *)this + 9))
    v18 = *((_QWORD *)this + 9);
  else
    LODWORD(v18) = v9 + v17;
  v20[0] = MEMORY[0x1E0C809B0];
  v20[1] = 0x40000000;
  v20[2] = ___ZN19EXRWritePluginInput6readCBEPvmm10axr_size_t_block_invoke;
  v20[3] = &unk_1E1BBD500;
  v20[4] = &v21;
  if (IIOPixelProvider::iterateOverImage(v8, v9, v18, v17, (uint64_t)v20))
    a3 = -12;
  else
    *((_QWORD *)this + 11) += v17;
  _Block_object_dispose(&v21, 8);
  return a3;
}

void sub_18805DEC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C405C07969BLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_BC::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  BCReadPlugin::BCReadPlugin(v4, a2, v5);
  return v4;
}

void sub_18805E000(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F4679EE4);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_BC::createReadPlugin(IIO_Reader *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  BCReadPlugin::BCReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_18805E09C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F4679EE4);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_BC::getImageCount(IIO_Reader_BC *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  if (a5)
    *a5 = 1;
  return 0;
}

uint64_t IIO_Reader_BC::updateSourceProperties(IIO_Reader_BC *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  return 0;
}

uint64_t _cg_png_set_zstream_owner(uint64_t result, int a2)
{
  *(_DWORD *)(result + 92) = a2;
  return result;
}

void _cg_png_reset_write(void **a1)
{
  png_free((uint64_t)a1, a1[40]);
  png_free((uint64_t)a1, a1[42]);
  png_free((uint64_t)a1, a1[43]);
  a1[40] = 0;
  a1[42] = 0;
  a1[43] = 0;
}

uint64_t png_read_filter_row_paeth4_apple(uint64_t result, uint64_t a2, uint64_t a3, uint16x4_t a4, double a5, uint8x8_t a6, double a7, uint32x4_t a8)
{
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  __int16 v11;
  uint64_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int32x4_t v15;
  int32x4_t v16;
  uint32x4_t v17;
  uint32x4_t v18;
  uint32x4_t v19;
  int16x8_t v20;
  int32x4_t v21;

  v8 = 0;
  v9 = *(_QWORD *)(result + 8);
  do
  {
    v10 = *(unsigned __int8 *)(a2 + v8);
    v11 = *(unsigned __int8 *)(a3 + v8) + v10;
    *(_BYTE *)(a2 + v8) = *(_BYTE *)(a3 + v8) + v10;
    ++v8;
  }
  while ((_DWORD)v8 != 4);
  if ((int)v9 >= 5)
  {
    v12 = 0;
    a4.i8[0] = *(_BYTE *)(a2 + v8 - 4);
    a4.i8[4] = *(_BYTE *)(a2 + v8 - 3);
    a4.i16[1] = a4.i16[2];
    a4.i8[4] = *(_BYTE *)(a2 + v8 - 2);
    a4.i16[3] = v11;
    v13 = (int8x16_t)vmovl_u16(a4);
    v14.i64[0] = 0xFF000000FFLL;
    v14.i64[1] = 0xFF000000FFLL;
    v15 = (int32x4_t)vandq_s8(v13, v14);
    a6.i32[0] = *(_DWORD *)(a3 + v8 - 4);
    v16 = (int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a6));
    do
    {
      a8.i32[0] = *(_DWORD *)(a3 + v12 + v8);
      a8 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)a8.i8));
      v17 = (uint32x4_t)vabdq_s32((int32x4_t)a8, v16);
      v18 = (uint32x4_t)vabdq_s32(v15, v16);
      v19 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_u32(vminq_u32(v18, v17), (uint32x4_t)vabsq_s32(vaddq_s32(vsubq_s32((int32x4_t)a8, v16), vsubq_s32(v15, v16)))), (int8x16_t)v16, vbslq_s8((int8x16_t)vcgtq_u32(v17, v18), (int8x16_t)a8, (int8x16_t)v15));
      v16.i32[0] = *(_DWORD *)(a2 + v12 + v8);
      v20 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v16.i8);
      v21 = (int32x4_t)vaddw_u16(v19, *(uint16x4_t *)v20.i8);
      *(int16x4_t *)v20.i8 = vmovn_s32(v21);
      *(_DWORD *)(a2 + v12 + v8) = vmovn_s16(v20).u32[0];
      v15 = (int32x4_t)vandq_s8((int8x16_t)v21, v14);
      v12 += 4;
      v16 = (int32x4_t)a8;
    }
    while ((int)v12 + 4 < (int)v9);
  }
  return result;
}

uint64_t CGImageCreateDataFromMetadata(const __CFDictionary *a1, uint64_t a2, CGImage *a3, CFDataRef *a4, CFDataRef *a5, CFDataRef *a6, const __CFDictionary *a7)
{
  const __CFDictionary *v13;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  CFTypeID TypeID;
  const CGImageMetadata *v18;
  const __CFDictionary *v19;
  const __CFData *JPEGDataFromImage;
  CGImage *Thumb;
  CGImage *v22;
  uint64_t Width;
  unsigned int Height;
  CGColorSpace *ColorSpace;
  char *v26;
  int v27;
  UInt8 *v28;
  UInt8 *v29;
  void *v30;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v32;
  CFTypeID v33;
  IIODictionary *v34;
  unsigned int v35;
  char *v36;
  int v37;
  UInt8 *v38;
  CFDataRef XMPData;
  _BOOL4 BoolForKey;
  CFDataRef *v42;
  CFDataRef *v43;
  size_t v45[3];
  size_t v46;
  uint64_t v47;
  uint64_t v48;
  size_t __n;

  if (a2)
  {
    v13 = *(const __CFDictionary **)(a2 + 24);
    if (v13)
      CFDictionaryGetCount(v13);
  }
  v43 = a5;
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageCreateDataFromMetadata", 0, 0, -1, 0);
  memset(v45, 0, sizeof(v45));
  IIODictionary::IIODictionary((IIODictionary *)v45, a1, 1);
  v42 = a6;
  if (IIODictionary::containsKeyGroup((IIODictionary *)v45, CFSTR("{ExifAux}"), CFSTR("{Exif}")))
  {
    ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v45, CFSTR("{ExifAux}"), CFSTR("{Exif}"));
    IIODictionary::setObjectForKey((IIODictionary *)v45, ObjectForKeyGroup, CFSTR("{ExifAux}"));
    IIODictionary::removeObjectForKeyGroup((IIODictionary *)v45, CFSTR("{ExifAux}"), CFSTR("{Exif}"));
  }
  v15 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v45, CFSTR("Caption/Abstract"), CFSTR("{IPTC}"));
  v16 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v45, CFSTR("ImageDescription"), CFSTR("{TIFF}"));
  if (v16)
  {
    if (!v15 || CFEqual(v15, v16))
      goto LABEL_15;
  }
  else if (!v15)
  {
    goto LABEL_15;
  }
  TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(v15))
    IIODictionary::setObjectForKeyGroup((IIODictionary *)v45, v15, CFSTR("ImageDescription"), CFSTR("{TIFF}"));
LABEL_15:
  v18 = (const CGImageMetadata *)CGImageMetadataCreateFromLegacyProps((IIODictionary *)v45);
  CGImageMetadataMerge((uint64_t)v18, a2, 0);
  if (!a4)
    goto LABEL_48;
  v48 = 0;
  __n = 0;
  v46 = 0;
  v47 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v46, a7);
  if (IIODictionary::containsKey((IIODictionary *)&v46, CFSTR("kCGDataFromMetadataAddExifApp1Marker")))
    BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)&v46, CFSTR("kCGDataFromMetadataAddExifApp1Marker"));
  else
    BoolForKey = 0;
  if (IIODictionary::containsKey((IIODictionary *)v45, "{ExifThumbnail}"))
  {
    v19 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v45, "JPEGThumbnailData", "{ExifThumbnail}");
    JPEGDataFromImage = v19;
    if (v19)
      CFRetain(v19);
    if (!a3)
      goto LABEL_31;
    goto LABEL_28;
  }
  if (IIODictionary::getBoolForKey((IIODictionary *)v45, CFSTR("kCGImageDestinationEmbedThumbnail")))
  {
    if (a3)
    {
      Thumb = CGImageCreateThumb(a3, 0xA0uLL);
      JPEGDataFromImage = AppleJPEGReadPlugin::CreateJPEGDataFromImage(0, (IIOImagePixelDataProvider *)v45, Thumb, v22);
LABEL_29:
      Width = CGImageGetWidth(a3);
      Height = CGImageGetHeight(a3);
      ColorSpace = CGImageGetColorSpace(a3);
      goto LABEL_32;
    }
    LogError("IIOCreateExifFromMetadata", 277, "*** ERROR: no image provided - cannot embed thumbnail\n");
    JPEGDataFromImage = 0;
  }
  else
  {
    JPEGDataFromImage = 0;
    if (a3)
    {
LABEL_28:
      Thumb = 0;
      goto LABEL_29;
    }
  }
LABEL_31:
  Width = (uint64_t)IIODictionary::getUint32ForKey((IIODictionary *)&v46, CFSTR("PixelXDimension"));
  Height = IIODictionary::getUint32ForKey((IIODictionary *)&v46, CFSTR("PixelYDimension"));
  Thumb = 0;
  ColorSpace = 0;
LABEL_32:
  if ((gIIODebugFlags & 0x2000000000000) != 0)
  {
    ImageIOLog("%s WriteExifData: writing Exif data\n", "-o- ");
    if ((gIIODebugFlags & 0x2000000000000) != 0)
      IIODebugOrientation("IIOCreateExifFromMetadata", 305, (IIODictionary *)v45);
  }
  v26 = CreateExifBufferFromPropertiesJPEG((IIODictionary *)v45, Width, Height, ColorSpace, JPEGDataFromImage, CFSTR("public.jpeg"), &__n);
  if (v26 && (v27 = __n, __n))
  {
    if (BoolForKey)
    {
      v28 = (UInt8 *)malloc_type_malloc((__n + 4), 0xF9030F24uLL);
      *(_WORD *)v28 = -7681;
      v28[2] = (unsigned __int16)(v27 + 2) >> 8;
      v28[3] = v27 + 2;
      memcpy(v28 + 4, v26, __n);
      *a4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v28, (v27 + 4));
      v29 = v28;
    }
    else
    {
      v30 = malloc_type_malloc(__n, 0xA945AF96uLL);
      memcpy(v30, v26, __n);
      *a4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v30, __n);
      v29 = (UInt8 *)v30;
    }
    free(v29);
  }
  else
  {
    _cg_jpeg_mem_term("IIOCreateExifFromMetadata", 309, "*** WARNING: CreateExifBufferFromPropertiesJPEG returned NULL\n");
  }
  if (JPEGDataFromImage)
    CFRelease(JPEGDataFromImage);
  if (Thumb)
    CGImageRelease(Thumb);
  if (v26)
    free(v26);
  IIODictionary::~IIODictionary((IIODictionary *)&v46);
LABEL_48:
  if (v43)
  {
    v46 = 0;
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v45, CFSTR("{IPTC}"));
    v32 = ObjectForKey;
    if (ObjectForKey && (v33 = CFGetTypeID(ObjectForKey), v33 == CFDictionaryGetTypeID()))
    {
      v34 = (IIODictionary *)operator new();
      IIODictionary::IIODictionary(v34, v32);
    }
    else
    {
      v34 = 0;
    }
    if (IIODictionary::getCount((IIODictionary *)v45))
    {
      v35 = IIODictionary::containsKeyGroup((IIODictionary *)v45, CFSTR("ColorSpace"), CFSTR("{Exif}"));
      if (v35)
        LOBYTE(v35) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v45, CFSTR("ColorSpace"), CFSTR("{Exif}")) == 1;
      v36 = CreateIPTCDataFromProperties(v35, v34, &v46);
      if (v36)
      {
        v37 = v46;
        if (v46)
        {
          v38 = (UInt8 *)malloc_type_malloc((v46 + 4), 0x7A3D08uLL);
          *(_WORD *)v38 = -4609;
          v38[2] = (unsigned __int16)(v37 + 2) >> 8;
          v38[3] = v37 + 2;
          memcpy(v38 + 4, v36, v46);
          *v43 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v38, (v37 + 4));
          free(v38);
          free(v36);
        }
      }
    }
    if (v34)
      (*(void (**)(IIODictionary *))(*(_QWORD *)v34 + 8))(v34);
  }
  if (v42)
  {
    v46 = 0;
    v47 = 0;
    v48 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v46, a7);
    if (IIODictionary::containsKey((IIODictionary *)&v46, CFSTR("kCGDataFromMetadataStripExifFromXMP"))
      && !IIODictionary::getBoolForKey((IIODictionary *)&v46, CFSTR("kCGDataFromMetadataStripExifFromXMP")))
    {
      XMPData = CGImageMetadataCreateXMPData(v18, 0);
    }
    else
    {
      XMPData = CGImageMetadataCreateXMPWithEXIFFiltered(v18);
    }
    *v42 = XMPData;
    IIODictionary::~IIODictionary((IIODictionary *)&v46);
  }
  if (v18)
    CFRelease(v18);
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v45);
  return 0;
}

void sub_18805E8F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  va_list va;

  va_start(va, a6);
  MEMORY[0x18D761C30](v6, 0x10A1C4047070A01);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateMetadataFromData(const __CFData *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4, CFDictionaryRef *a5, CGMutableImageMetadataRef *a6)
{
  CGMutableImageMetadataRef *v11;
  CGMutableImageMetadataRef Mutable;
  const char *BytePtr;
  unint64_t Length;
  unsigned int v15;
  int v16;
  const char *v17;
  unint64_t v18;
  uint64_t v19;
  CGMutableImageMetadataRef MetadataFromDatabuffer;
  CGImageMetadata *MetadataFromXMPBuffer;
  const char *v22;
  unint64_t v23;
  char v24;
  BOOL v25;
  uint64_t v26;
  CGMutableImageMetadataRef v27;
  uint64_t v28;
  CFDictionaryRef *v29;
  char v30;
  CGColorSpace *v31;
  const void *v32;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFDictionary *v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  const __CFDictionary *v37;
  const __CFDictionary *v38;
  float FloatAtIndex;
  float v40;
  const __CFDictionary *v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  const __CFString *v48;
  UInt8 *v49;
  unsigned int v50;
  int v51;
  const void **v52;
  const __CFDictionary *ObjectForKey;
  IIODictionary *v54;
  const char *v55;
  int Val32;
  unsigned int v57;
  unsigned int Uint32ForKeyGroup;
  unsigned int v59;
  int v60;
  unsigned int v61;
  int v62;
  IIONumber *v63;
  const UInt8 *v64;
  CFDataRef v65;
  float FloatForKeyGroup;
  unsigned int v68;
  char v69;
  CGMutableImageMetadataRef cf;
  _QWORD v72[5];
  uint64_t v73;
  uint64_t v74;
  void *value;
  void *v76[2];
  __int128 v77;
  void *__p[2];
  __int128 v79;
  uint64_t v80;
  _BYTE v81[24];
  _BYTE v82[24];
  _BYTE v83[24];
  _QWORD v84[2];
  const void *v85;

  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageCreateMetadataFromData", 0, 0, -1, 0);
  if (!a5)
  {
    v11 = a6;
    if (!a6)
    {
      LogError("CGImageCreateMetadataFromData", 456, "*** ERROR: imageProperties or imageMetadata have to be non-nil\n");
LABEL_39:
      v26 = 4294967246;
      goto LABEL_118;
    }
    goto LABEL_7;
  }
  *a5 = 0;
  v11 = a6;
  if (a6)
  {
LABEL_7:
    v69 = 0;
    *v11 = 0;
    goto LABEL_8;
  }
  v69 = 1;
LABEL_8:
  Mutable = CGImageMetadataCreateMutable();
  if (!a1)
    goto LABEL_13;
  BytePtr = (const char *)CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  if (Length < 0x11)
    goto LABEL_13;
  if (!strncmp(BytePtr, "Exif", 5uLL))
  {
    v15 = 6;
  }
  else
  {
    if (strncmp(BytePtr + 4, "Exif", 5uLL))
    {
      LogError("CGImageCreateMetadataFromData", 499, "*** ERROR: exifData not recognized (does not start with 'Exif");
LABEL_13:
      v15 = 0;
      goto LABEL_14;
    }
    v15 = 10;
  }
  MetadataFromDatabuffer = CreateMetadataFromDatabuffer(&BytePtr[v15], Length - v15, 4);
  if (MetadataFromDatabuffer)
  {
    CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromDatabuffer, 0);
    CFRelease(MetadataFromDatabuffer);
    v16 = 1;
    if (!a3)
      goto LABEL_31;
LABEL_15:
    v17 = (const char *)CFDataGetBytePtr(a3);
    v18 = CFDataGetLength(a3);
    if (v18 >= 0x29)
    {
      v19 = 29;
      if (strncmp(v17, kMainXMPSignatureString[0], 0x1DuLL))
      {
        if (strncmp(v17, kMainXMPPlainString[0], 0x21uLL))
        {
          if (!strncmp(v17, "http://ns.adobe.com/xmp/extension/", 0x23uLL))
            LogError("CGImageCreateMetadataFromData", 538, "*** ERROR: XMP exention blocks not handled yet!\n");
          goto LABEL_30;
        }
        v19 = 0;
      }
      MetadataFromXMPBuffer = CreateMetadataFromXMPBuffer(&v17[v19], v18 - v19);
      if (MetadataFromXMPBuffer)
      {
        CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromXMPBuffer, 0);
        CFRelease(MetadataFromXMPBuffer);
        LODWORD(a3) = 1;
        goto LABEL_31;
      }
      LogError("CGImageCreateMetadataFromData", 533, "*** ERROR: XMP not recognized (does not start with 'http://ns.adobe.com/xap/1.0/'\n");
    }
LABEL_30:
    LODWORD(a3) = 0;
    goto LABEL_31;
  }
LABEL_14:
  v16 = 0;
  if (a3)
    goto LABEL_15;
LABEL_31:
  cf = Mutable;
  v68 = v15;
  if (a2)
  {
    v22 = (const char *)CFDataGetBytePtr(a2);
    v23 = CFDataGetLength(a2);
    if (v23 >= 0x15)
    {
      if (!strncmp(v22, "Photoshop 3.0", 0xEuLL) || !strncmp(v22 + 4, "Photoshop 3.0", 0xEuLL))
      {
        v27 = CGImageMetadataCreateMutable();
        ReadPhotoshopImageResource((uint64_t)v27, (uint64_t)(v22 + 14), v23 - 14);
        CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)v27, 0);
        CFRelease(v27);
        v25 = a4 == 0;
        v24 = 1;
        goto LABEL_41;
      }
      LogError("CGImageCreateMetadataFromData", 570, "*** ERROR: IPTC not recognized (does not start with 'Photoshop 3.0'\n");
    }
  }
  v24 = 0;
  v25 = a4 == 0;
  if (((v16 | a3) & 1) == 0 && !a4)
  {
    CFRelease(cf);
    goto LABEL_39;
  }
LABEL_41:
  if (!a5)
    goto LABEL_115;
  v28 = CGImagePropertiesCreateFromMetadata((const __CFDictionary **)cf);
  v29 = (CFDictionaryRef *)v28;
  if (v28)
    v30 = 1;
  else
    v30 = v25;
  if ((v30 & 1) == 0)
  {
    v29 = (CFDictionaryRef *)operator new();
    IIODictionary::IIODictionary((IIODictionary *)v29);
    v31 = (CGColorSpace *)MEMORY[0x18D760CAC](a4);
    if (v31)
    {
      v32 = (const void *)CGColorSpaceCopyICCProfileDescription();
      if (v32)
      {
        IIODictionary::setObjectForKey((IIODictionary *)v29, v32, CFSTR("ProfileName"));
        CFRelease(v32);
      }
      CGColorSpaceRelease(v31);
    }
LABEL_52:
    IIONumber::IIONumber((IIONumber *)v84, 8);
    IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v84, CFSTR("Depth"));
    IIONumber::~IIONumber((IIONumber *)v84);
    ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, CFSTR("XResolution"), CFSTR("{TIFF}"));
    if (ObjectForKeyGroup)
    {
      IIODictionary::setObjectForKey((IIODictionary *)v29, ObjectForKeyGroup, CFSTR("DPIHeight"));
    }
    else
    {
      IIONumber::IIONumber((IIONumber *)v83, 72);
      IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v83, CFSTR("DPIHeight"));
      IIONumber::~IIONumber((IIONumber *)v83);
    }
    v34 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, CFSTR("YResolution"), CFSTR("{TIFF}"));
    if (v34)
    {
      IIODictionary::setObjectForKey((IIODictionary *)v29, v34, CFSTR("DPIWidth"));
    }
    else
    {
      IIONumber::IIONumber((IIONumber *)v82, 72);
      IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v82, CFSTR("DPIWidth"));
      IIONumber::~IIONumber((IIONumber *)v82);
    }
    v35 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, CFSTR("Orientation"), CFSTR("{TIFF}"));
    if (v35)
    {
      IIODictionary::setObjectForKey((IIODictionary *)v29, v35, CFSTR("Orientation"));
    }
    else
    {
      IIONumber::IIONumber((IIONumber *)v81, 1);
      IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v81, CFSTR("Orientation"));
      IIONumber::~IIONumber((IIONumber *)v81);
    }
    v36 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, CFSTR("PixelYDimension"), CFSTR("{Exif}"));
    if (v36)
      IIODictionary::setObjectForKey((IIODictionary *)v29, v36, CFSTR("PixelHeight"));
    v37 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, CFSTR("PixelXDimension"), CFSTR("{Exif}"));
    if (v37)
      IIODictionary::setObjectForKey((IIODictionary *)v29, v37, CFSTR("PixelWidth"));
    if (v25)
    {
      if (IIODictionary::containsKeyGroup((IIODictionary *)v29, CFSTR("PrimaryChromaticities"), CFSTR("{TIFF}"))
        && IIODictionary::containsKeyGroup((IIODictionary *)v29, CFSTR("WhitePoint"), CFSTR("{TIFF}"))
        && IIODictionary::containsKeyGroup((IIODictionary *)v29, CFSTR("Gamma"), CFSTR("{Exif}")))
      {
        IIODictionary::setObjectForKey((IIODictionary *)v29, CFSTR("RGB"), CFSTR("ColorModel"));
        FloatForKeyGroup = IIODictionary::getFloatForKeyGroup((IIODictionary *)v29, CFSTR("Gamma"), CFSTR("{Exif}"));
        v38 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, CFSTR("WhitePoint"), CFSTR("{TIFF}"));
        v76[0] = 0;
        v76[1] = 0;
        *(_QWORD *)&v77 = 0;
        IIOArray::IIOArray((IIOArray *)v76, v38);
        FloatAtIndex = IIOArray::getFloatAtIndex((IIOArray *)v76, 0);
        v40 = IIOArray::getFloatAtIndex((IIOArray *)v76, 1);
        v41 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, CFSTR("PrimaryChromaticities"), CFSTR("{TIFF}"));
        v73 = 0;
        v74 = 0;
        value = 0;
        IIOArray::IIOArray((IIOArray *)&v73, v41);
        v42 = IIOArray::getFloatAtIndex((IIOArray *)&v73, 0);
        v43 = IIOArray::getFloatAtIndex((IIOArray *)&v73, 1);
        v44 = IIOArray::getFloatAtIndex((IIOArray *)&v73, 2);
        v45 = IIOArray::getFloatAtIndex((IIOArray *)&v73, 3);
        v46 = IIOArray::getFloatAtIndex((IIOArray *)&v73, 4);
        v47 = IIOArray::getFloatAtIndex((IIOArray *)&v73, 5);
        if (IIOChromaticitiesMatchAdobeRGB(FloatAtIndex, v40, v42, v43, v44, v45, v46, v47, FloatForKeyGroup))
        {
          v48 = CFSTR("Adobe RGB (1998)");
        }
        else
        {
          if (!IIOChromaticitiesMatchSRGB(FloatAtIndex, v40, v42, v43, v44, v45, v46, v47, FloatForKeyGroup))
            goto LABEL_103;
          v48 = CFSTR("sRGB IEC61966-2.1");
        }
        IIODictionary::setObjectForKey((IIODictionary *)v29, v48, CFSTR("ProfileName"));
LABEL_103:
        IIOArray::~IIOArray((IIOArray *)&v73);
        IIOArray::~IIOArray((IIOArray *)v76);
        if ((v24 & 1) != 0)
          goto LABEL_104;
        goto LABEL_80;
      }
      if (IIODictionary::containsKeyGroup((IIODictionary *)v29, CFSTR("ColorSpace"), CFSTR("{Exif}"))
        && IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, CFSTR("ColorSpace"), CFSTR("{Exif}")) == 1)
      {
        IIODictionary::setObjectForKey((IIODictionary *)v29, CFSTR("sRGB IEC61966-2.1"), CFSTR("ProfileName"));
      }
LABEL_79:
      if ((v24 & 1) != 0)
      {
LABEL_104:
        if (IIODictionary::containsKeyGroup((IIODictionary *)v29, CFSTR("JPEGInterchangeFormatLength"), CFSTR("{Exif}")))
        {
          Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, CFSTR("JPEGInterchangeFormatLength"), CFSTR("{Exif}"));
          v59 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, CFSTR("JPEGInterchangeFormat"), CFSTR("{Exif}"));
          v60 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, CFSTR("JPEGInterchangeFormatWidth"), CFSTR("{Exif}"));
          v61 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, CFSTR("JPEGInterchangeFormatHeight"), CFSTR("{Exif}"));
          if (v60)
          {
            v62 = v61;
            if (v61)
            {
              if (v59 && Uint32ForKeyGroup)
              {
                v76[0] = 0;
                v76[1] = 0;
                *(_QWORD *)&v77 = 0;
                IIODictionary::IIODictionary((IIODictionary *)v76);
                IIODictionary::setObjectForKey((IIODictionary *)v29, v76[1], CFSTR("{ExifThumbnail}"));
                IIONumber::IIONumber((IIONumber *)v84, v60);
                IIODictionary::setObjectForKey((IIODictionary *)v76, v85, CFSTR("JPEGInterchangeFormatWidth"));
                IIONumber::~IIONumber((IIONumber *)v84);
                IIONumber::IIONumber(v63, v62);
                IIODictionary::setObjectForKey((IIODictionary *)v76, v85, CFSTR("JPEGInterchangeFormatHeight"));
                IIONumber::~IIONumber((IIONumber *)v84);
                v64 = CFDataGetBytePtr(a1);
                if (CFDataGetLength(a1) > Uint32ForKeyGroup - v68 + v59)
                {
                  v65 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &v64[v59 - v68], Uint32ForKeyGroup);
                  if (v65)
                  {
                    IIODictionary::setObjectForKey((IIODictionary *)v76, v65, CFSTR("JPEGThumbnailData"));
                    CFRelease(v65);
                  }
                }
                IIODictionary::~IIODictionary((IIODictionary *)v76);
              }
            }
          }
          IIODictionary::removeObjectForKeyGroup((IIODictionary *)v29, CFSTR("JPEGInterchangeFormatLength"), CFSTR("{Exif}"));
          IIODictionary::removeObjectForKeyGroup((IIODictionary *)v29, CFSTR("JPEGInterchangeFormat"), CFSTR("{Exif}"));
          IIODictionary::removeObjectForKeyGroup((IIODictionary *)v29, CFSTR("JPEGInterchangeFormatWidth"), CFSTR("{Exif}"));
          IIODictionary::removeObjectForKeyGroup((IIODictionary *)v29, CFSTR("JPEGInterchangeFormatHeight"), CFSTR("{Exif}"));
        }
        *a5 = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v29[1]);
        (*((void (**)(CFDictionaryRef *))*v29 + 1))(v29);
        goto LABEL_115;
      }
LABEL_80:
      if (IIODictionary::containsKey((IIODictionary *)v29, CFSTR("{IPTC}")))
      {
        _cg_jpeg_mem_term("CGImageCreateMetadataFromData", 615, "*** NOTE: metadata contains {IPTC} - but IPTCData was not requested...\n");
        ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v29, CFSTR("{IPTC}"));
        v84[0] = 0;
        v84[1] = 0;
        v85 = 0;
        v54 = IIODictionary::IIODictionary((IIODictionary *)v84, ObjectForKey);
        v76[0] = 0;
        v76[1] = v76;
        *(_QWORD *)&v77 = 0x4002000000;
        *((_QWORD *)&v77 + 1) = __Block_byref_object_copy__3;
        __p[0] = __Block_byref_object_dispose__3;
        __p[1] = 0;
        v79 = 0uLL;
        v72[0] = MEMORY[0x1E0C809B0];
        v72[1] = 0x40000000;
        v72[2] = __CGImageCreateMetadataFromData_block_invoke;
        v72[3] = &unk_1E1BBD528;
        v72[4] = v76;
        IIODictionary::enumerate((uint64_t)v54, v72);
        v55 = (char *)v76[1] + 40;
        if (*((char *)v76[1] + 63) < 0)
          v55 = *(const char **)v55;
        _cg_jpeg_mem_term("CGImageCreateMetadataFromData", 623, "    returning with Exif: '%s'\n", v55);
        kdebug_trace();
        _Block_object_dispose(v76, 8);
        if (SHIBYTE(v79) < 0)
          operator delete(__p[1]);
        IIODictionary::~IIODictionary((IIODictionary *)v84);
      }
      goto LABEL_104;
    }
    v49 = (UInt8 *)CFDataGetBytePtr(a4);
    v50 = CFDataGetLength(a4);
    if (v50 < 0xC9)
      goto LABEL_79;
    v51 = bswap32(*((_DWORD *)v49 + 4));
    if (v51 > 1281450527)
    {
      if (v51 == 1281450528)
      {
        v52 = (const void **)&kCGImagePropertyColorModelLab;
      }
      else
      {
        if (v51 != 1380401696)
          goto LABEL_92;
        v52 = (const void **)&kCGImagePropertyColorModelRGB;
      }
    }
    else if (v51 == 1129142603)
    {
      v52 = (const void **)&kCGImagePropertyColorModelCMYK;
    }
    else
    {
      if (v51 != 1196573017)
        goto LABEL_92;
      v52 = (const void **)&kCGImagePropertyColorModelGray;
    }
    IIODictionary::setObjectForKey((IIODictionary *)v29, *v52, CFSTR("ColorModel"));
LABEL_92:
    v80 = 0;
    *(_OWORD *)__p = 0u;
    v79 = 0u;
    *(_OWORD *)v76 = 0u;
    v77 = 0u;
    IIOScanner::IIOScanner((IIOScanner *)v76, v49, v50, 0);
    IIOScanner::seek((IIOScanner *)v76, 0x80uLL);
    Val32 = IIOScanner::getVal32((IIOScanner *)v76);
    if (Val32)
    {
      while (IIOScanner::getVal32((IIOScanner *)v76) != 1684370275)
      {
        IIOScanner::skip((uint64_t)v76, 8);
        if (!--Val32)
          goto LABEL_98;
      }
      v57 = IIOScanner::getVal32((IIOScanner *)v76);
      IIOScanner::getVal32((IIOScanner *)v76);
      IIOScanner::seek((IIOScanner *)v76, v57);
      if (IIOScanner::getVal32((IIOScanner *)v76) == 1684370275)
      {
        IIOScanner::skip((uint64_t)v76, 4);
        IIOScanner::getVal32((IIOScanner *)v76);
        v73 = 0;
        v74 = 0;
        value = 0;
        IIOString::IIOString((IIOString *)&v73, (const char *)&v49[*((_QWORD *)&v77 + 1)]);
        IIODictionary::setObjectForKey((IIODictionary *)v29, value, CFSTR("ProfileName"));
        IIOString::~IIOString((IIOString *)&v73);
      }
    }
LABEL_98:
    IIOScanner::~IIOScanner((IIOScanner *)v76);
    if ((v24 & 1) != 0)
      goto LABEL_104;
    goto LABEL_80;
  }
  if (v28)
    goto LABEL_52;
LABEL_115:
  if ((v69 & 1) != 0)
  {
    CFRelease(cf);
    v26 = 0;
  }
  else
  {
    v26 = 0;
    *a6 = cf;
  }
LABEL_118:
  kdebug_trace();
  return v26;
}

void sub_18805F6BC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,char a38)
{
  IIOString::~IIOString((IIOString *)&a20);
  IIOScanner::~IIOScanner((IIOScanner *)&a23);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18805F668);
}

__n128 __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
}

void sub_18805F8D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateMetadataFromDataArray(const __CFArray *a1, CFDictionaryRef *a2, CGMutableImageMetadataRef *a3)
{
  CFIndex v6;
  CFDataRef v7;
  const __CFData *v8;
  const void *ValueAtIndex;
  CFTypeID v10;
  const UInt8 *BytePtr;
  unsigned int Length;
  CFIndex v13;
  const __CFAllocator *v14;
  const UInt8 *v15;
  uint64_t MetadataFromData;
  CFAllocatorRef allocator;
  CFDictionaryRef *v19;
  const __CFData *v20;
  const __CFData *v21;

  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_DWORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageCreateMetadataFromDataArray", 0, 0, -1, 0);
  if (!a1)
  {
    LogError("CGImageCreateMetadataFromDataArray", 698, "*** ERROR: dataArray is nil\n");
    MetadataFromData = 4294967246;
    goto LABEL_38;
  }
  if (CFArrayGetCount(a1) <= 0)
  {
    MetadataFromData = CGImageCreateMetadataFromData(0, 0, 0, 0, a2, a3);
    goto LABEL_38;
  }
  v19 = a2;
  v6 = 0;
  v7 = 0;
  v20 = 0;
  v21 = 0;
  v8 = 0;
  allocator = (CFAllocatorRef)*MEMORY[0x1E0C9AE00];
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(a1, v6);
    v10 = CFGetTypeID(ValueAtIndex);
    if (v10 != CFDataGetTypeID())
    {
      LogError("CGImageCreateMetadataFromDataArray", 705, "*** ERROR: dataArray does not contain CFData\n");
      goto LABEL_15;
    }
    BytePtr = CFDataGetBytePtr((CFDataRef)ValueAtIndex);
    Length = CFDataGetLength((CFDataRef)ValueAtIndex);
    if (Length < 0x11)
      goto LABEL_15;
    if (!strncmp((const char *)BytePtr, "Exif", 5uLL))
    {
      v8 = (const __CFData *)ValueAtIndex;
      goto LABEL_15;
    }
    if (Length < 0x1F)
    {
      if (Length < 0x15)
        goto LABEL_15;
    }
    else
    {
      if (!strncmp((const char *)BytePtr, kMainXMPSignatureString[0], 0x1DuLL))
      {
        v20 = (const __CFData *)ValueAtIndex;
        goto LABEL_15;
      }
      if (Length >= 0x29 && !strncmp((const char *)BytePtr, "http://ns.adobe.com/xmp/extension/", 0x23uLL))
      {
        LogError("CGImageCreateMetadataFromDataArray", 722, "*** ERROR: XMP exention blocks not handled yet!\n");
        goto LABEL_15;
      }
    }
    if (!strncmp((const char *)BytePtr, "Photoshop 3.0", 0xEuLL))
    {
      v21 = (const __CFData *)ValueAtIndex;
      goto LABEL_15;
    }
    if (Length < 0x81)
      goto LABEL_15;
    if (!strncmp((const char *)BytePtr, "ICC_PROFILE", 0xCuLL))
    {
      if (v7)
        CFRelease(v7);
      v15 = BytePtr + 14;
      v13 = Length - 14;
      v14 = allocator;
      goto LABEL_34;
    }
    if (BytePtr[36] == 97 && BytePtr[37] == 99 && BytePtr[38] == 115 && BytePtr[39] == 112)
    {
      if (v7)
        CFRelease(v7);
      v13 = Length;
      v14 = allocator;
      v15 = BytePtr;
LABEL_34:
      v7 = CFDataCreate(v14, v15, v13);
    }
LABEL_15:
    ++v6;
  }
  while (v6 < CFArrayGetCount(a1));
  MetadataFromData = CGImageCreateMetadataFromData(v8, v21, v20, v7, v19, a3);
  if (v7)
    CFRelease(v7);
LABEL_38:
  kdebug_trace();
  return MetadataFromData;
}

uint64_t EXRReadPlugin::EXRReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v6;

  v6 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)v6 = &off_1E1BAC950;
  *(_OWORD *)(v6 + 440) = 0u;
  *(_OWORD *)(v6 + 456) = 0u;
  *(_OWORD *)(v6 + 472) = 0u;
  *(_OWORD *)(v6 + 488) = 0u;
  *(_OWORD *)(v6 + 504) = 0u;
  *(_OWORD *)(v6 + 520) = 0u;
  *(_OWORD *)(v6 + 536) = 0u;
  *(_OWORD *)(v6 + 552) = 0u;
  *(_OWORD *)(v6 + 568) = 0u;
  *(_OWORD *)(v6 + 584) = 0u;
  *(_QWORD *)(v6 + 600) = 0;
  AppleEXREnabled();
  return a1;
}

void sub_18805FC78(_Unwind_Exception *a1)
{
  IIOReadPlugin *v1;
  void **v2;

  EXRPluginData::~EXRPluginData(v2);
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

uint64_t EXRReadPlugin::EXRReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;

  v4 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v4 = &off_1E1BAC950;
  *(_OWORD *)(v4 + 440) = 0u;
  *(_OWORD *)(v4 + 456) = 0u;
  *(_OWORD *)(v4 + 472) = 0u;
  *(_OWORD *)(v4 + 488) = 0u;
  *(_OWORD *)(v4 + 504) = 0u;
  *(_OWORD *)(v4 + 520) = 0u;
  *(_OWORD *)(v4 + 536) = 0u;
  *(_OWORD *)(v4 + 552) = 0u;
  *(_OWORD *)(v4 + 568) = 0u;
  *(_OWORD *)(v4 + 584) = 0u;
  *(_QWORD *)(v4 + 600) = 0;
  AppleEXREnabled();
  return a1;
}

void sub_18805FCF4(_Unwind_Exception *a1)
{
  IIOReadPlugin *v1;
  void **v2;

  EXRPluginData::~EXRPluginData(v2);
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void EXRReadPlugin::~EXRReadPlugin(EXRReadPlugin *this)
{
  *(_QWORD *)this = &off_1E1BAC950;
  *((_QWORD *)this + 75) = 0;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  *(_QWORD *)this = &off_1E1BAC950;
  *((_QWORD *)this + 75) = 0;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t EXRReadPlugin::initialize(EXRReadPlugin *this, IIODictionary *a2)
{
  IIOImageRead *v3;
  IIOImageRead *Size;
  void *v5;
  void *logical_image_list;
  uint64_t updated;
  unint64_t v8;
  uint64_t v9;
  __int128 *v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t decoder;
  void *v17;
  int channel_count;
  char v19;
  double v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  int v29;
  BOOL v31;
  uint64_t colorspace;
  CFStringRef *v33;
  CGColorSpaceModel Model;
  int v35;
  uint64_t v36;
  __int16 v37;
  __int16 v38;
  unsigned __int16 v39;
  char v40;
  const char *name;
  CFMutableArrayRef v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  void *value;
  uint64_t v48;
  void **v49[2];
  void *v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;

  if (!AppleEXREnabled())
  {
    updated = 4294967246;
LABEL_39:
    kdebug_trace();
    return updated;
  }
  v63 = 0;
  v3 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v63, 1);
  Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  v62 = 0;
  v5 = (void *)gFunc_axr_data_create(v3, Size, &v62, 0, 0);
  logical_image_list = (void *)gFunc_axr_data_create_logical_image_list(v5);
  v59 = 0;
  v60 = 0;
  v61 = 0;
  updated = IIO_Reader_OpenEXR::UpdateImageInfo((uint64_t)logical_image_list, &v59);
  if ((_DWORD)updated)
  {
    _cg_jpeg_mem_term("initialize", 87, "*** ERROR: IIO_Reader_OpenEXR::UpdateImageInfo failed: %d\n", updated);
    goto LABEL_32;
  }
  v8 = *((unsigned int *)this + 52);
  v9 = v59;
  if (0xCF3CF3CF3CF3CF3DLL * ((v60 - v59) >> 3) <= v8)
  {
    LogError("initialize", 89, "*** IIO_Reader_OpenEXR::UpdateImageInfo read past end of imageInfo\n");
    goto LABEL_32;
  }
  v10 = (__int128 *)(v59 + 168 * v8);
  v11 = *v10;
  *(_OWORD *)((char *)this + 449) = *(__int128 *)((char *)v10 + 9);
  *(_OWORD *)((char *)this + 440) = v11;
  std::string::operator=((std::string *)((char *)this + 472), (const std::string *)(v10 + 2));
  std::string::operator=((std::string *)((char *)this + 496), (const std::string *)(v9 + 168 * v8 + 56));
  std::string::operator=((std::string *)((char *)this + 520), (const std::string *)(v9 + 168 * v8 + 80));
  v12 = v9 + 168 * v8;
  v13 = *(_OWORD *)(v12 + 104);
  v14 = *(_OWORD *)(v12 + 120);
  v15 = *(_OWORD *)(v12 + 152);
  *((_OWORD *)this + 36) = *(_OWORD *)(v12 + 136);
  *((_OWORD *)this + 37) = v15;
  *((_OWORD *)this + 34) = v13;
  *((_OWORD *)this + 35) = v14;
  if (v62)
  {
    name = (const char *)gFunc_axr_error_get_name();
    LogError("initialize", 91, "*** axr_data_create failed: %s (%d)\n", name, v62);
    goto LABEL_32;
  }
  decoder = gFunc_axr_logical_image_list_create_decoder(logical_image_list, v5, *((unsigned int *)this + 111), *((unsigned int *)this + 112), 0, 0, 0, 1.0);
  v17 = (void *)decoder;
  if (!decoder)
  {
    LogError("initialize", 95, "*** axr_logical_image_list_create_decoder returned NULL\n");
    goto LABEL_32;
  }
  channel_count = gFunc_axr_decoder_get_channel_count(decoder);
  v19 = channel_count;
  *((_DWORD *)this + 146) = channel_count;
  v20 = NAN;
  if ((channel_count & 1) == 0)
    v20 = 1.0;
  *((double *)this + 57) = v20;
  gFunc_axr_data_get_part_info(v49, v5, *((unsigned int *)this + 141), 1);
  v22 = v51;
  v21 = v52;
  v24 = v53;
  v23 = v54;
  v26 = v55;
  v25 = v56;
  v28 = v57;
  v27 = v58;
  v46 = 0;
  value = 0;
  v48 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v46);
  IIODictionary::setObjectForKey(*((IIODictionary **)this + 7), value, CFSTR("{EXR}"));
  v43 = 0;
  v44 = 0;
  v45 = 0;
  IIOArray::IIOArray((IIOArray *)&v43);
  IIODictionary::setObjectForKey((IIODictionary *)&v46, v44, CFSTR("Chromaticities"));
  IIONumber::IIONumber((IIONumber *)v49, v22);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v26);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v21);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v25);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v24);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v28);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v23);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v27);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  v29 = *((_DWORD *)this + 143);
  v31 = v29 != 1 && v29 != 7;
  *((_BYTE *)this + 464) = v31;
  colorspace = gFunc_axr_decoder_create_colorspace(v17, 0, 0);
  *((_QWORD *)this + 20) = colorspace;
  if (!colorspace)
  {
    if ((*((_DWORD *)this + 146) - 1) >= 2)
      v33 = (CFStringRef *)MEMORY[0x1E0C9D958];
    else
      v33 = (CFStringRef *)MEMORY[0x1E0C9D948];
    *((_QWORD *)this + 20) = CGColorSpaceCreateWithName(*v33);
  }
  if (*((_BYTE *)this + 464))
    gFunc_axr_decoder_get_read_pixels_info(v49, v17, 0, 1);
  else
    gFunc_axr_decoder_get_read_rgba_pixels_info(v49, v17, 0, 1, *((double *)this + 57));
  Model = CGColorSpaceGetModel(*((CGColorSpaceRef *)this + 20));
  if (Model == kCGColorSpaceModelMonochrome)
  {
    v35 = 1196573017;
    goto LABEL_27;
  }
  if (Model == kCGColorSpaceModelRGB)
  {
    v35 = 1380401696;
LABEL_27:
    *((_DWORD *)this + 81) = v35;
  }
  os_release(v17);
  IIOArray::~IIOArray((IIOArray *)&v43);
  IIODictionary::~IIODictionary((IIODictionary *)&v46);
  v36 = *((_QWORD *)this + 69);
  *(_QWORD *)((char *)this + 228) = v36;
  v37 = *((_WORD *)this + 292);
  *((_WORD *)this + 122) = v37;
  v38 = *((_WORD *)this + 220);
  *((_WORD *)this + 120) = v38;
  v39 = v38 * v37;
  *((_WORD *)this + 121) = v39;
  if ((v19 & 1) != 0)
    v40 = 5;
  else
    v40 = 3;
  *((_BYTE *)this + 246) = v40;
  *((_DWORD *)this + 59) = v36 * (v39 >> 3);
  *((_QWORD *)this + 24) = 0;
  *((_WORD *)this + 172) = 256;
  *((_BYTE *)this + 346) = 0;
  *((_WORD *)this + 188) = 1;
LABEL_32:
  if (v5)
    os_release(v5);
  if (logical_image_list)
    os_release(logical_image_list);
  if (v63)
    IIOImageReadSession::releaseBytePointer(*((IIOImageRead ***)this + 3), v63);
  v49[0] = (void **)&v59;
  std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100](v49);
  if ((_DWORD)updated)
    goto LABEL_39;
  return updated;
}

void sub_188060340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void **a17)
{
  uint64_t v17;

  IIOArray::~IIOArray((IIOArray *)&a11);
  IIODictionary::~IIODictionary((IIODictionary *)&a14);
  a17 = (void **)(v17 - 168);
  std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100](&a17);
  _Unwind_Resume(a1);
}

uint64_t EXRReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t EXRReadPlugin::loadDataFromXPCObject(EXRReadPlugin *this, void *a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_exr", &length);
    if (length == 168)
    {
      v6 = data;
      result = 0;
      v7 = *v6;
      v8 = v6[2];
      *(_OWORD *)((char *)this + 456) = v6[1];
      *(_OWORD *)((char *)this + 472) = v8;
      *(_OWORD *)((char *)this + 440) = v7;
      v9 = v6[3];
      v10 = v6[4];
      v11 = v6[6];
      *(_OWORD *)((char *)this + 520) = v6[5];
      *(_OWORD *)((char *)this + 536) = v11;
      *(_OWORD *)((char *)this + 488) = v9;
      *(_OWORD *)((char *)this + 504) = v10;
      v12 = v6[7];
      v13 = v6[8];
      v14 = v6[9];
      *((_QWORD *)this + 75) = *((_QWORD *)v6 + 20);
      *(_OWORD *)((char *)this + 568) = v13;
      *(_OWORD *)((char *)this + 584) = v14;
      *(_OWORD *)((char *)this + 552) = v12;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t EXRReadPlugin::saveDataToXPCObject(EXRReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_exr", (char *)this + 440, 0xA8uLL);
  return v4;
}

uint64_t EXRReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  IIOImageRead **v20;
  _BOOL4 v21;
  void *BaseAddress;
  size_t Height;
  uint64_t BlockArray;
  size_t v25;
  double v26;
  double v27;
  unint64_t v28;
  unsigned int v29;
  uint64_t v30;
  const char **v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  double v37;
  size_t v38;
  CGRect v39;
  CGRect v40;

  v38 = 0;
  if ((gIIODebugFlags & 0x20000) == 0)
    goto LABEL_26;
  v8 = *((_DWORD *)this + 51);
  v9 = v8 >> 24;
  v10 = MEMORY[0x1E0C80978];
  if (v8 < 0)
  {
    v11 = __maskrune(v9, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
  }
  if (v11)
    v12 = (v8 >> 24);
  else
    v12 = 46;
  v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    v14 = __maskrune(v13, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14)
    v15 = (v8 << 8 >> 24);
  else
    v15 = 46;
  v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    v17 = __maskrune(v16, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17)
    v18 = ((__int16)v8 >> 8);
  else
    v18 = 46;
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
      goto LABEL_22;
LABEL_24:
    v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL))
    goto LABEL_24;
LABEL_22:
  v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus EXRReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v20 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v20)
    v21 = IIOImageReadSession::mapData(v20);
  else
    v21 = 0;
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    v27 = (double)v28;
    v29 = *((_DWORD *)this + 74);
    v26 = (double)v29;
    v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((_QWORD *)this + 48), &v38, (uint64_t)kImageMalloc_EXR_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
      goto LABEL_42;
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v38 = v25;
    v26 = 0.0;
    v27 = 0.0;
  }
  if (!BaseAddress)
    goto LABEL_43;
  v30 = EXRReadPlugin::decodeBlockAppleEXR(this, BaseAddress);
  if ((_DWORD)v30)
  {
    BlockArray = v30;
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v38);
      if (!v21)
        return BlockArray;
      goto LABEL_44;
    }
LABEL_43:
    if (!v21)
      return BlockArray;
    goto LABEL_44;
  }
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_42:
    BlockArray = 0;
    goto LABEL_43;
  }
  v33 = 0;
  v39.origin.x = 0.0;
  v39.origin.y = 0.0;
  v39.size.width = v27;
  v39.size.height = v26;
  **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v39, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
  {
    v34 = 0;
  }
  else
  {
    v40.origin.x = 0.0;
    v40.origin.y = 0.0;
    v40.size.width = v27;
    v40.size.height = v26;
    *(CGRect *)(&v34 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v40);
    v33 = v35;
    v27 = v36;
    v26 = v37;
  }
  BlockArray = 0;
  *((_QWORD *)this + 15) = v33;
  *((_QWORD *)this + 16) = v34;
  *((double *)this + 17) = v27;
  *((double *)this + 18) = v26;
  if (v21)
  {
LABEL_44:
    v31 = (const char **)*((_QWORD *)this + 3);
    if (v31)
      IIOImageReadSession::unmapData(v31);
  }
  return BlockArray;
}

uint64_t EXRReadPlugin::decodeBlockAppleEXR(EXRReadPlugin *this, void *a2)
{
  int v4;
  IIOImageRead *v5;
  IIOImageRead *Size;
  void *v7;
  void *logical_image_list;
  uint64_t decoder;
  void *v10;
  uint64_t pixels;
  uint64_t v12;
  const char *name;
  _QWORD v15[4];
  uint64_t v16;
  void *v17;

  if (!AppleEXREnabled())
    return 4294967246;
  v4 = *((_DWORD *)this + 66);
  v17 = 0;
  v5 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v17, 1);
  Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  v16 = 0;
  v7 = (void *)gFunc_axr_data_create(v5, Size, &v16, 0, 0);
  if (!v16)
  {
    logical_image_list = (void *)gFunc_axr_data_create_logical_image_list(v7);
    decoder = gFunc_axr_logical_image_list_create_decoder(logical_image_list, v7, *((unsigned int *)this + 111), *((unsigned int *)this + 112), 0, 0, 0, *((double *)this + 57));
    v10 = (void *)decoder;
    if (decoder)
    {
      if (*((_BYTE *)this + 464))
      {
        gFunc_axr_decoder_get_read_pixels_info(v15, decoder, 0, 1);
        pixels = gFunc_axr_decoder_read_pixels(v10, a2, *((unsigned int *)this + 75), 2);
      }
      else
      {
        gFunc_axr_decoder_get_read_rgba_pixels_info(v15, decoder, 0, 1, *((double *)this + 57));
        pixels = gFunc_axr_decoder_read_rgba_pixels(v10, a2, *((unsigned int *)this + 75), 2, 1.0);
      }
      v16 = pixels;
      if (!pixels)
      {
        if (*((_DWORD *)this + 74) == v4)
          v12 = 0;
        else
          v12 = 4294967246;
        if (logical_image_list)
          goto LABEL_13;
        goto LABEL_14;
      }
      gFunc_axr_error_get_name();
      LogError("decodeBlockAppleEXR", 390, "*** axr_decoder_read_pixels failed: %s (%d)\n");
    }
    else
    {
      LogError("decodeBlockAppleEXR", 378, "*** axr_decoder_create failed\n");
    }
    v12 = 4294967246;
    if (logical_image_list)
LABEL_13:
      os_release(logical_image_list);
LABEL_14:
    if (v10)
      os_release(v10);
    if (!v7)
      goto LABEL_18;
    goto LABEL_17;
  }
  name = (const char *)gFunc_axr_error_get_name();
  LogError("decodeBlockAppleEXR", 370, "*** axr_data_create failed: %s (%d)\n", name, v16);
  v12 = 4294967246;
  if (v7)
LABEL_17:
    os_release(v7);
LABEL_18:
  if (v17)
    IIOImageReadSession::releaseBytePointer(*((IIOImageRead ***)this + 3), v17);
  return v12;
}

double TGAReadPlugin::TGAReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  double result;

  v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)v5 = &off_1E1BADC38;
  result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(_QWORD *)(v5 + 472) = 0;
  return result;
}

double TGAReadPlugin::TGAReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  v3 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BADC38;
  result = 0.0;
  *(_OWORD *)(v3 + 440) = 0u;
  *(_OWORD *)(v3 + 456) = 0u;
  *(_QWORD *)(v3 + 472) = 0;
  return result;
}

void TGAReadPlugin::~TGAReadPlugin(TGAReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t TGAReadPlugin::loadDataFromXPCObject(TGAReadPlugin *this, void *a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_tga", &length);
    if (length == 40)
    {
      v6 = data;
      result = 0;
      v7 = *v6;
      v8 = v6[1];
      *((_QWORD *)this + 59) = *((_QWORD *)v6 + 4);
      *(_OWORD *)((char *)this + 440) = v7;
      *(_OWORD *)((char *)this + 456) = v8;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t TGAReadPlugin::saveDataToXPCObject(TGAReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_tga", (char *)this + 440, 0x28uLL);
  return v4;
}

unint64_t TGAReadPlugin::readHeader(IIOImageReadSession **this)
{
  unint64_t result;
  _DWORD *exception;

  result = IIOImageReadSession::getBytesAtOffset(this[3], (_BYTE *)this + 440, 0, 0x12uLL);
  if (result != 18)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -36;
  }
  return result;
}

const char *TGAReadPlugin::debugHeader(TGAReadPlugin *this)
{
  unsigned __int16 *v2;
  int v3;
  const char *v4;

  v2 = (unsigned __int16 *)((char *)this + 443);
  ImageIOLog("    TGA:\n");
  ImageIOLog("                  sizeOfImageID:  %d\n", *((unsigned __int8 *)this + 440));
  ImageIOLog("                     hasPalette:  %d\n", *((unsigned __int8 *)this + 441));
  v3 = *((unsigned __int8 *)this + 442);
  v4 = "Compressed";
  if ((v3 & 8) == 0)
    v4 = "Uncompressed";
  ImageIOLog("                      imageType:  %d = %s+%s\n", v3, off_1E1BCA5F0[v3 & 3], v4);
  ImageIOLog("                       palStart:  %d\n", *v2);
  ImageIOLog("                        palSize:  %d\n", v2[1]);
  ImageIOLog("                palBitsPerPixel:  %d\n", *((unsigned __int8 *)this + 447));
  ImageIOLog("                        xOffset:  %d\n", *((unsigned __int16 *)this + 224));
  ImageIOLog("                        yOffset:  %d\n", *((unsigned __int16 *)this + 225));
  ImageIOLog("                          width:  %d\n", *((unsigned __int16 *)this + 226));
  ImageIOLog("                         height:  %d\n", *((unsigned __int16 *)this + 227));
  ImageIOLog("                   bitsPerPixel:  %d\n", *((unsigned __int8 *)this + 456));
  return ImageIOLog("                       attrBits:  0x%.2X = %d alphabits + %d origin\n", *((unsigned __int8 *)this + 457), *((_BYTE *)this + 457) & 0xF, (*((unsigned __int8 *)this + 457) >> 4) & 3);
}

uint64_t TGAReadPlugin::initialize(IIOImageReadSession **this, IIODictionary *a2)
{
  unsigned int v3;
  uint64_t result;
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  IIOImageRead *Size;
  _BYTE v9[16];
  void *value;
  uint64_t v11;
  void *v12;
  uint64_t v13;

  if (*((_BYTE *)this + 341))
  {
    TGAReadPlugin::readHeader(this);
    if (*((_BYTE *)this + 177))
      TGAReadPlugin::debugHeader((TGAReadPlugin *)this);
    if (*((unsigned __int8 *)this + 441) >= 2u)
    {
      _cg_jpeg_mem_term("initialize", 141, "*** ERROR: _tga._tgaHeader.hasPalette: %d\n");
    }
    else
    {
      v3 = *((unsigned __int8 *)this + 442);
      if (v3 <= 0xB && ((0xE0Fu >> v3) & 1) != 0)
      {
        if ((TGAReadPlugin::sanityCheck((TGAReadPlugin *)this, (0x202u >> v3) & 1, (0xE00u >> v3) & 1) & 1) != 0)
        {
          v11 = 0;
          v12 = 0;
          v13 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v11);
          IIONumber::IIONumber((IIONumber *)v9, *((unsigned __int8 *)this + 442) > 3u);
          IIODictionary::setObjectForKey((IIODictionary *)&v11, value, CFSTR("Compression"));
          IIONumber::~IIONumber((IIONumber *)v9);
          IIODictionary::setObjectForKey(this[7], v12, CFSTR("{TGA}"));
          IIODictionary::~IIODictionary((IIODictionary *)&v11);
          v5 = TGAReadPlugin::setupGeometry((TGAReadPlugin *)this);
          v6 = *((unsigned __int16 *)this + 121);
          *((_DWORD *)this + 59) = (*((unsigned __int16 *)this + 121)
                                  * (unint64_t)*((unsigned __int16 *)this + 226)
                                  + 7) >> 3;
          this[45] = (IIOImageReadSession *)1;
          *((_WORD *)this + 122) = v6 / *((unsigned __int16 *)this + 120);
          v7 = v5 + *((unsigned __int8 *)this + 440) + 18;
          this[24] = (IIOImageReadSession *)v7;
          if (v7 < (unint64_t)IIOImageReadSession::getSize(this[3]))
          {
            Size = IIOImageReadSession::getSize(this[3]);
            result = 0;
            this[58] = (IIOImageReadSession *)(Size - this[24]);
            *((_BYTE *)this + 472) = (*((_BYTE *)this + 442) & 8) != 0;
            *((_BYTE *)this + 473) = ~(*((unsigned __int8 *)this + 457) >> 5) & 1;
            *((_WORD *)this + 188) = 1;
            return result;
          }
          IIOImageReadSession::getSize(this[3]);
          _cg_jpeg_mem_term("initialize", 199, "*** ERROR: offset (%ld) out of range (%ld)\n");
        }
        else
        {
          _cg_jpeg_mem_term("initialize", 170, "*** ERROR: sanityCheck failed\n");
        }
      }
    }
  }
  kdebug_trace();
  return 4294967246;
}

void sub_188060FE0(void *a1)
{
  __cxa_begin_catch(a1);
  _cg_jpeg_mem_term("initialize", 186, "*** ERROR: setupGeometry failed\n");
  __cxa_end_catch();
  JUMPOUT(0x188060E30);
}

void sub_188061004(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t TGAReadPlugin::sanityCheck(TGAReadPlugin *this, char a2, char a3)
{
  _WORD *v6;
  int v7;
  unint64_t v8;
  int v9;
  int v10;
  unsigned int v11;
  IIOImageRead *Size;
  unint64_t v13;

  v6 = (_WORD *)((char *)this + 443);
  v7 = *((unsigned __int8 *)this + 442);
  if (!*((_BYTE *)this + 441))
  {
    if (*(unsigned __int16 *)((char *)this + 445) | (unsigned __int16)*v6)
    {
      _cg_jpeg_mem_term("sanityCheck", 487, "*** true-color (no palette) has paletteStart and paletteSize set (%d and %d)\n");
      return 0;
    }
    goto LABEL_8;
  }
  HIDWORD(v8) = *((unsigned __int8 *)this + 447);
  LODWORD(v8) = (HIDWORD(v8) << 24) - 0x8000000;
  if ((v8 >> 27) >= 4u)
  {
    _cg_jpeg_mem_term("sanityCheck", 480, "*** invalid paletteBitsPerPixel (%d)\n");
    return 0;
  }
  if ((v7 | 8) != 9)
  {
    _cg_jpeg_mem_term("sanityCheck", 481, "*** ERROR: unexpected image type (%d) with color palette\n");
    return 0;
  }
  if (*(unsigned __int16 *)((char *)this + 445) - 1 >= 0x1000)
  {
    _cg_jpeg_mem_term("sanityCheck", 482, "*** invalid paletteSize (%d)\n");
    return 0;
  }
  if (!*v6)
  {
LABEL_8:
    if (!*((_WORD *)this + 226))
    {
      _cg_jpeg_mem_term("sanityCheck", 490, "*** invalid width (%d)\n");
      return 0;
    }
    if (!*((_WORD *)this + 227))
    {
      _cg_jpeg_mem_term("sanityCheck", 491, "*** invalid height (%d)\n");
      return 0;
    }
    if (*((unsigned __int8 *)this + 457) >= 0x40u)
    {
      _cg_jpeg_mem_term("sanityCheck", 492, "*** invalid attrBits [%X]\n");
      return 0;
    }
    v9 = v7 & 3;
    if (v9 == 3)
    {
      v10 = *((unsigned __int8 *)this + 456);
      if (v10 != 8 && v10 != 16)
      {
        _cg_jpeg_mem_term("sanityCheck", 497, "*** Gray - invalid bitsPerPixel [%d]\n");
        return 0;
      }
    }
    else if (v9 == 2)
    {
      v11 = *((unsigned __int8 *)this + 456);
      if (v11 > 0x20 || ((1 << v11) & 0x101018000) == 0)
      {
        _cg_jpeg_mem_term("sanityCheck", 499, "*** RGB - invalid bitsPerPixel [%d]\n");
        return 0;
      }
    }
    else if (v9 == 1 && *((_BYTE *)this + 456) != 8)
    {
      _cg_jpeg_mem_term("sanityCheck", 495, "*** Indexed - invalid bitsPerPixel [%d]\n");
      return 0;
    }
    Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
    v13 = *((unsigned __int16 *)this + 227) * (unint64_t)*((unsigned __int16 *)this + 226);
    if ((a3 & 1) != 0)
    {
      if (100 * (uint64_t)Size < v13)
        return 0;
    }
    else
    {
      if ((a2 & 1) == 0)
        v13 = v13 * ((unint64_t)*((unsigned __int8 *)this + 456) >> 3);
      if ((unint64_t)Size < v13)
        return 0;
    }
    return 1;
  }
  _cg_jpeg_mem_term("sanityCheck", 483, "*** unhandled paletteStart (%d)\n");
  return 0;
}

unint64_t TGAReadPlugin::setupGeometry(TGAReadPlugin *this)
{
  int v2;
  char v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  int v13;
  BOOL v14;
  _DWORD *exception;

  v2 = *((_BYTE *)this + 442) & 3;
  v3 = *((_BYTE *)this + 457);
  v4 = *((unsigned __int16 *)this + 226);
  v5 = *((unsigned __int16 *)this + 227);
  *((_DWORD *)this + 57) = v4;
  *((_DWORD *)this + 58) = v5;
  v6 = *((unsigned __int8 *)this + 456);
  *((_WORD *)this + 121) = v6;
  *((_WORD *)this + 120) = 8;
  v7 = v3 & 0xF;
  v8 = v7 > 4;
  v9 = 0x103050505uLL >> (8 * v7);
  if (v8)
    LOBYTE(v9) = 3;
  if (v6 != 32)
    LOBYTE(v9) = 0;
  *((_BYTE *)this + 246) = v9;
  *((_QWORD *)this + 20) = 0;
  if (v2 == 3)
    v10 = 1196573017;
  else
    v10 = 1380401696;
  *((_DWORD *)this + 81) = v10;
  if (*((_BYTE *)this + 441))
    v11 = (*((unsigned __int8 *)this + 447) * (unint64_t)*(unsigned __int16 *)((char *)this + 445)) >> 3;
  else
    v11 = 0;
  switch(v2)
  {
    case 2:
      if (v6 - 15 >= 2)
      {
        if (v6 != 24)
        {
          if (v6 <= 8 && !v11)
            goto LABEL_29;
          *((_BYTE *)this + 278) = v9;
          if (v6 != 32)
            break;
LABEL_23:
          *((_WORD *)this + 138) = 4;
          *((_DWORD *)this + 68) = 2097160;
          *((_BYTE *)this + 279) = 0;
          break;
        }
      }
      else
      {
        *((_WORD *)this + 120) = 5;
      }
      *((_BYTE *)this + 278) = 5;
      goto LABEL_23;
    case 1:
      if (TGAReadPlugin::createIndexedColorSpace(this, v11) && *((unsigned __int16 *)this + 121) <= 8u)
      {
        v4 = *((_DWORD *)this + 57);
        break;
      }
LABEL_29:
      exception = __cxa_allocate_exception(4uLL);
      *exception = -50;
    case 3:
      *((_BYTE *)this + 278) = v9;
      if (v6 == 16)
      {
        *((_DWORD *)this + 68) = 1048584;
        *((_BYTE *)this + 278) = 3;
      }
      break;
  }
  v12 = *((unsigned __int8 *)this + 279);
  v13 = (v12 << 12) | (*((unsigned __int8 *)this + 280) << 16);
  v14 = *((_BYTE *)this + 281) != 0;
  *((_BYTE *)this + 310) = *((_BYTE *)this + 278) & 0x1F;
  *((_BYTE *)this + 311) = v12 & 7;
  *((_BYTE *)this + 312) = BYTE2(v13) & 0xF;
  *((_BYTE *)this + 313) = v14;
  *((_BYTE *)this + 350) = 1;
  *((_DWORD *)this + 67) = ((*((unsigned __int16 *)this + 137) + 7) >> 3) * v4;
  *((_BYTE *)this + 344) = 0;
  *((_BYTE *)this + 346) = 0;
  return v11;
}

uint64_t TGAReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

BOOL TGAReadPlugin::createIndexedColorSpace(TGAReadPlugin *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  size_t v6;
  int v7;
  char *v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  char *v14;
  size_t v15;
  char v16;
  _BYTE *v17;
  unsigned __int16 *v18;
  size_t v19;
  unsigned int v20;
  uint32x2_t v21;
  int8x8_t v22;
  int v23;
  char *v24;
  char v25;
  _BYTE *v26;
  char *v27;
  size_t v28;
  char v29;
  CGColorSpace *v30;
  _BYTE v32[2];
  _BYTE v33[16390];

  MEMORY[0x1E0C80A78](this, a2);
  *(_QWORD *)&v33[16382] = *MEMORY[0x1E0C80C00];
  if (!v3)
    return 0;
  v4 = v2;
  v5 = *(unsigned __int8 *)(v2 + 440);
  if (*(unsigned __int16 *)(v2 + 445) >= 0x100u)
    v6 = 256;
  else
    v6 = *(unsigned __int16 *)(v2 + 445);
  v7 = *(unsigned __int8 *)(v2 + 447);
  v8 = (char *)malloc_type_calloc(v6, 3uLL, 0x3F1B0C95uLL);
  if (v8)
  {
    v9 = v8;
    HIDWORD(v10) = *(unsigned __int8 *)(v4 + 447);
    LODWORD(v10) = (HIDWORD(v10) << 24) - 0x8000000;
    v11 = v5 + 18;
    v12 = (v6 * v7) >> 3;
    switch((v10 >> 27))
    {
      case 0u:
        bzero(v32, 0x1000uLL);
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v4 + 24), v32, v11, v12) != v12)
          goto LABEL_28;
        if ((_DWORD)v6)
        {
          v13 = v9 + 2;
          v14 = v32;
          v15 = v6;
          do
          {
            v16 = *v14++;
            *v13 = v16;
            *(v13 - 1) = v16;
            *(v13 - 2) = v16;
            v13 += 3;
            --v15;
          }
          while (v15);
        }
        goto LABEL_26;
      case 1u:
        bzero(v32, 0x2000uLL);
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v4 + 24), v32, v11, v12) != v12)
          goto LABEL_28;
        if ((_DWORD)v6)
        {
          v17 = v9 + 2;
          v18 = (unsigned __int16 *)v32;
          v19 = v6;
          do
          {
            v20 = *v18++;
            v21 = (uint32x2_t)vand_s8((int8x8_t)vdup_n_s32(v20), (int8x8_t)0x3E000007C00);
            v22 = vorr_s8((int8x8_t)vshl_u32(v21, (uint32x2_t)0xFFFFFFFEFFFFFFF9), (int8x8_t)vshl_u32(v21, (uint32x2_t)0xFFFFFFF9FFFFFFF4));
            *(v17 - 1) = v22.i8[4];
            *(v17 - 2) = v22.i8[0];
            *v17 = (8 * v20) | (v20 >> 2) & 7;
            v17 += 3;
            --v19;
          }
          while (v19);
        }
        goto LABEL_26;
      case 2u:
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v4 + 24), v8, v11, (v6 * v7) >> 3) != v12)goto LABEL_28;
        if ((_DWORD)v6)
        {
          v23 = v6;
          v24 = v9;
          do
          {
            v25 = *v24;
            *v24 = v24[2];
            v24[2] = v25;
            v24 += 3;
            --v23;
          }
          while (v23);
        }
        goto LABEL_26;
      case 3u:
        bzero(v32, 0x4000uLL);
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v4 + 24), v32, v11, v12) != v12)
        {
LABEL_28:
          free(v9);
          return 0;
        }
        if ((_DWORD)v6)
        {
          v26 = v9 + 2;
          v27 = v33;
          v28 = v6;
          do
          {
            *(v26 - 2) = *(v27 - 2);
            *(v26 - 1) = *(v27 - 1);
            v29 = *v27;
            v27 += 4;
            *v26 = v29;
            v26 += 3;
            --v28;
          }
          while (v28);
        }
LABEL_26:
        v30 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
        *(_QWORD *)(v4 + 160) = CGColorSpaceCreateIndexed(v30, (v6 - 1), (const unsigned __int8 *)v9);
        CGColorSpaceRelease(v30);
        free(v9);
        break;
      default:
        goto LABEL_26;
    }
  }
  return *(_QWORD *)(v4 + 160) != 0;
}

unsigned int *TGAReadPlugin::adjustAlphaIfNeeded(unsigned int *this, char *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  int v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  _BYTE *v16;

  v2 = this[74];
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = this[73];
    v5 = this[75];
    v6 = a2 + 3;
    while (!(_DWORD)v4)
    {
LABEL_7:
      ++v3;
      v6 += v5;
      if (v3 == v2)
      {
        v10 = 0;
        while (!(_DWORD)v4)
        {
LABEL_13:
          if (++v10 >= v2)
            return this;
        }
        v11 = &a2[v10 * v5];
        v12 = this[73];
        while (!*(_DWORD *)v11)
        {
          v11 += 4;
          if (!--v12)
            goto LABEL_13;
        }
        v13 = 0;
        v14 = a2 + 3;
        do
        {
          v15 = v4;
          v16 = v14;
          do
          {
            *v16 = -1;
            v16 += 4;
            --v15;
          }
          while (v15);
          ++v13;
          v14 += v5;
        }
        while (v13 != v2);
        return this;
      }
    }
    v7 = this[73];
    v8 = (unsigned __int8 *)v6;
    while (1)
    {
      v9 = *v8;
      v8 += 4;
      if (v9)
        break;
      if (!--v7)
        goto LABEL_7;
    }
  }
  return this;
}

uint64_t TGAReadPlugin::decodeRLE(TGAReadPlugin *this, char *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unint64_t BytesAtOffset;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  unsigned __int8 *v19;
  signed __int8 v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  int v24;
  unsigned int v25;
  int v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;

  v4 = *((unsigned int *)this + 74);
  v5 = *((unsigned int *)this + 73);
  v6 = *((unsigned int *)this + 75);
  v7 = *((_BYTE *)this + 442);
  v8 = *((unsigned __int8 *)this + 456);
  v9 = (unsigned __int8 *)malloc_type_malloc(*((_QWORD *)this + 58), 0x760A4549uLL);
  if (!v9)
    return 4294967243;
  v10 = v9;
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((_QWORD *)this + 24), *((_QWORD *)this + 58));
  if (BytesAtOffset == *((_QWORD *)this + 58))
  {
    v12 = 0;
    v13 = 0;
    v14 = (unint64_t)&v10[BytesAtOffset];
    v15 = (v7 & 3) == 2 && ((v8 + 1) & 0x1F0) == 16;
    v16 = 4;
    if (!v15)
      v16 = (unint64_t)(v8 + 1) >> 3;
    if (*((_BYTE *)this + 473))
      v17 = v4 - 1;
    else
      v17 = 0;
    v18 = &a2[v17 * v6];
    v19 = v10;
    do
    {
      if (v4 <= v13)
        break;
      v20 = *v19;
      v21 = (*v19 & 0x7F) + 1;
      if (v12 + v21 > v5 && v12 + v21 + 1 > (v4 - v13) * v5)
        goto LABEL_46;
      v22 = v20 < 0 ? 0 : (unint64_t)(v8 + 1) >> 3;
      v23 = (char *)(v19 + 2);
      do
      {
        switch((unint64_t)(v8 + 1) >> 3)
        {
          case 1uLL:
            if ((unint64_t)(v23 - 1) >= v14)
              goto LABEL_46;
            *v18 = *(v23 - 1);
            break;
          case 2uLL:
            if ((unint64_t)v23 >= v14)
              goto LABEL_46;
            if ((v7 & 3) == 2)
            {
              v24 = *v23;
              v25 = *(v23 - 1);
              v18[2] = (2 * *v23) & 0xF8 | (*v23 >> 4) & 7;
              v18[1] = ((v25 | (v24 << 8)) >> 2) & 0xF8 | ((v25 | (v24 << 8)) >> 7) & 7;
              v26 = (8 * v25) | (v25 >> 2) & 7;
              goto LABEL_27;
            }
            *v18 = *(v23 - 1);
            v18[1] = *v23;
            break;
          case 3uLL:
            if ((unint64_t)(v23 + 1) >= v14)
              goto LABEL_46;
            v18[2] = v23[1];
            v18[1] = *v23;
            LOBYTE(v26) = *(v23 - 1);
LABEL_27:
            *v18 = v26;
            if (v16 == 4)
              v18[3] = -1;
            break;
          case 4uLL:
            if ((unint64_t)(v23 + 2) >= v14)
              goto LABEL_46;
            v18[2] = v23[1];
            v18[1] = *v23;
            *v18 = *(v23 - 1);
            v18[3] = v23[2];
            break;
          default:
            break;
        }
        if (++v12 == v5)
        {
          v12 = 0;
          if (*((_BYTE *)this + 473))
            v27 = v4 - 2 - v13;
          else
            v27 = v13 + 1;
          ++v13;
          v18 = &a2[v27 * v6];
        }
        else
        {
          v18 += v16;
        }
        v23 += v22;
        LODWORD(v21) = v21 - 1;
      }
      while ((_DWORD)v21);
      v28 = v20 < 0 ? (unint64_t)(v8 + 1) >> 3 : 0;
      v19 = (unsigned __int8 *)&v23[v28 - 1];
    }
    while ((unint64_t)v19 < v14);
    if (*((_BYTE *)this + 456) == 32)
      TGAReadPlugin::adjustAlphaIfNeeded((unsigned int *)this, a2);
    v29 = 0;
  }
  else
  {
LABEL_46:
    v29 = 4294967243;
  }
  free(v10);
  return v29;
}

uint64_t TGAReadPlugin::decodeUncompressed(TGAReadPlugin *this, char *a2)
{
  uint64_t v4;
  vImagePixelCount v5;
  unint64_t v6;
  size_t v7;
  int v8;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  char *v23;
  vImagePixelCount v24;
  unsigned __int8 *v25;
  int v26;
  unsigned int v27;
  int v28;
  unsigned __int8 *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  char *v33;
  _BYTE *v34;
  vImagePixelCount v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  unsigned __int8 *v54;
  int v55;
  int v56;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _BYTE *v62;
  uint64_t v63;
  vImage_Buffer v64;
  vImage_Buffer v65;

  v4 = *((unsigned int *)this + 66);
  v5 = *((unsigned int *)this + 65);
  v6 = *((unsigned int *)this + 59);
  v7 = *((unsigned int *)this + 75);
  if (!*((_BYTE *)this + 441) || *((_BYTE *)this + 442) != 1)
  {
    v15 = *((unsigned __int8 *)this + 456);
    if (v15 <= 0xF)
    {
      if (v15 == 8)
      {
        if (*((_WORD *)this + 122) == 1 && (_DWORD)v4 != 0)
        {
          v44 = 0;
          v45 = 0;
          v46 = v4 - 1;
          while (1)
          {
            v47 = *((_BYTE *)this + 473) ? v46 : v45;
            if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &a2[v47 * v7], v44 + *((_QWORD *)this + 24), v6) != v6)return 4294967243;
            ++v45;
            --v46;
            v44 += v6;
            if (v46 == -1)
              goto LABEL_81;
          }
        }
        goto LABEL_81;
      }
      if (v15 != 15 || *((_WORD *)this + 122) != 3)
        goto LABEL_81;
      v9 = (unsigned __int8 *)malloc_type_malloc(2 * v5, 0x5122EA62uLL);
      if (!(_DWORD)v4)
        goto LABEL_80;
      v20 = 0;
      while (1)
      {
        v21 = *((unsigned __int8 *)this + 473);
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((_QWORD *)this + 24) + v20 * 2 * v5, 2 * v5) != 2 * v5)break;
        if ((_DWORD)v5)
        {
          v22 = ~v20 + v4;
          if (!v21)
            v22 = v20;
          v23 = &a2[v22 * v7 + 3];
          v24 = v5;
          v25 = v9;
          do
          {
            v26 = *v25;
            *(v23 - 2) = *v25 & 0xF8 | (*v25 >> 5);
            v27 = v25[1];
            *(v23 - 3) = ((v27 | (v26 << 8)) >> 3) & 0xF8 | v26 & 7;
            *(v23 - 1) = (4 * v27) & 0xF8 | (v27 >> 3) & 7;
            *v23 = -1;
            v23 += 4;
            v25 += 2;
            --v24;
          }
          while (v24);
        }
        if (++v20 == v4)
          goto LABEL_80;
      }
    }
    else
    {
      if (v15 != 16)
      {
        if (v15 != 24)
        {
          if (v15 == 32 && (_DWORD)v4)
          {
            v16 = 0;
            v17 = 0;
            v18 = v4 - 1;
            while (1)
            {
              v19 = *((_BYTE *)this + 473) ? v18 : v17;
              if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &a2[v19 * v7], v16 + *((_QWORD *)this + 24), v6) != v6)return 4294967243;
              ++v17;
              --v18;
              v16 += v6;
              if (v18 == -1)
                goto LABEL_81;
            }
          }
          goto LABEL_81;
        }
        v9 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 75), 0x2154F42EuLL);
        v65.data = v9;
        v65.height = 1;
        v65.width = v5;
        v65.rowBytes = v6;
        *(_OWORD *)&v64.data = xmmword_18820C490;
        v64.width = v5;
        v64.rowBytes = v7;
        if ((_DWORD)v4)
        {
          v38 = 0;
          v39 = 0;
          v40 = v4 - 1;
          while (1)
          {
            v41 = *((unsigned __int8 *)this + 473);
            if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, v38 + *((_QWORD *)this + 24), v6) != v6)goto LABEL_94;
            if (v41)
              v42 = v40;
            else
              v42 = v39;
            v64.data = &a2[v42 * v7];
            vImageConvert_RGB888toRGBA8888(&v65, 0, 0xFFu, &v64, 0, 0);
            ++v39;
            --v40;
            v38 += v6;
            if (v40 == -1)
              goto LABEL_80;
          }
        }
        goto LABEL_80;
      }
      v28 = *((unsigned __int16 *)this + 122);
      if (v28 != 3)
      {
        if (v28 == 2 && (_DWORD)v4)
        {
          v58 = 0;
          v59 = 0;
          v60 = v4 - 1;
          while (1)
          {
            v61 = *((_BYTE *)this + 473) ? v60 : v59;
            if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &a2[v61 * v7], v58 + *((_QWORD *)this + 24), v6) != v6)return 4294967243;
            ++v59;
            --v60;
            v58 += v6;
            if (v60 == -1)
              goto LABEL_81;
          }
        }
        goto LABEL_81;
      }
      v29 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 59), 0xC121423uLL);
      v9 = v29;
      if (!(_DWORD)v4)
        goto LABEL_80;
      v30 = 0;
      v62 = v29 + 1;
      while (1)
      {
        v31 = *((unsigned __int8 *)this + 473);
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((_QWORD *)this + 24) + v30 * v6, v6) != v6)break;
        if ((_DWORD)v5)
        {
          v32 = ~v30 + v4;
          if (!v31)
            v32 = v30;
          v33 = &a2[v32 * v7 + 3];
          v34 = v62;
          v35 = v5;
          do
          {
            v36 = *v34;
            v37 = *(v34 - 1);
            *(v33 - 1) = (2 * *v34) & 0xF8 | (*v34 >> 4) & 7;
            *(v33 - 2) = ((v37 | (v36 << 8)) >> 2) & 0xF8 | ((v37 | (v36 << 8)) >> 7) & 7;
            *(v33 - 3) = (8 * v37) | (v37 >> 2) & 7;
            *v33 = -1;
            v33 += 4;
            v34 += 2;
            --v35;
          }
          while (v35);
        }
        if (++v30 == v4)
          goto LABEL_80;
      }
    }
LABEL_93:
    if (!v9)
      return 4294967243;
LABEL_94:
    free(v9);
    return 4294967243;
  }
  v8 = *((unsigned __int8 *)this + 456);
  if (v8 == 16)
  {
    v9 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 59), 0xBB74A9B7uLL);
    if ((_DWORD)v4)
    {
      v48 = 0;
      LODWORD(v49) = ((2863311531u * (unint64_t)v5) >> 32) & 0xFFFFFFFE;
      if ((_DWORD)v49)
        v49 = v49;
      else
        v49 = 1;
      v63 = v49;
      do
      {
        v50 = *((unsigned __int8 *)this + 473);
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((_QWORD *)this + 24) + v48 * v6, v6) != v6)goto LABEL_93;
        if (v5 >= 3)
        {
          v51 = ~v48 + v4;
          if (!v50)
            v51 = v48;
          v52 = &a2[v51 * v7];
          v53 = v63;
          v54 = v9 + 1;
          do
          {
            v55 = *v54;
            v56 = *(v54 - 1);
            *v52 = (2 * v55) & 0xF8;
            v52[1] = ((v56 | (v55 << 8)) >> 2) & 0xF8;
            v52[2] = 8 * v56;
            v52 += 3;
            v54 += 2;
            --v53;
          }
          while (v53);
        }
      }
      while (++v48 != v4);
    }
LABEL_80:
    free(v9);
    goto LABEL_81;
  }
  if (v8 == 8)
  {
    v9 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 59), 0x6BE6C816uLL);
    if ((_DWORD)v4)
    {
      v10 = 0;
      v11 = 0;
      v12 = v4 - 1;
      while (1)
      {
        v13 = *((unsigned __int8 *)this + 473);
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, v10 + *((_QWORD *)this + 24), v6) != v6)goto LABEL_93;
        if (v13)
          v14 = v12;
        else
          v14 = v11;
        memcpy(&a2[v14 * v7], v9, v6);
        ++v11;
        --v12;
        v10 += v6;
        if (v12 == -1)
          goto LABEL_80;
      }
    }
    goto LABEL_80;
  }
LABEL_81:
  if (*((_BYTE *)this + 456) == 32)
    TGAReadPlugin::adjustAlphaIfNeeded((unsigned int *)this, a2);
  return 0;
}

uint64_t TGAReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  IIOImageRead **v20;
  _BOOL4 v21;
  uint64_t BlockArray;
  void *BaseAddress;
  size_t Height;
  size_t v25;
  double v26;
  double v27;
  unint64_t v28;
  unsigned int v29;
  uint64_t v30;
  vImagePixelCount v31;
  size_t v32;
  const char **v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  double v39;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  size_t v42;
  CGRect v43;
  CGRect v44;

  v42 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v8 = *((_DWORD *)this + 51);
    v9 = v8 >> 24;
    v10 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v11 = __maskrune(v9, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    }
    if (v11)
      v12 = (v8 >> 24);
    else
      v12 = 46;
    v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v14 = __maskrune(v13, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v8 << 8 >> 24);
    else
      v15 = 46;
    v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = ((__int16)v8 >> 8);
    else
      v18 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      v19 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, (char)v19, iioTypeStr[a3], "virtual OSStatus TGAReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    LOBYTE(v19) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  if (!*((_BYTE *)this + 414))
    return 4294967115;
  v20 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v20)
    v21 = IIOImageReadSession::mapData(v20);
  else
    v21 = 0;
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    v27 = (double)v28;
    v29 = *((_DWORD *)this + 74);
    v26 = (double)v29;
    v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((_QWORD *)this + 48), &v42, (uint64_t)kImageMalloc_TGA_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
      goto LABEL_54;
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v42 = v25;
    v26 = 0.0;
    v27 = 0.0;
  }
  if (!BaseAddress)
    goto LABEL_55;
  memset(BaseAddress, 255, v25);
  if (*((_BYTE *)this + 472))
    v30 = TGAReadPlugin::decodeRLE(this, (char *)BaseAddress);
  else
    v30 = TGAReadPlugin::decodeUncompressed(this, (char *)BaseAddress);
  BlockArray = v30;
  if ((_DWORD)v30)
  {
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v42);
      if (!v21)
        return BlockArray;
      goto LABEL_56;
    }
LABEL_55:
    if (!v21)
      return BlockArray;
    goto LABEL_56;
  }
  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8)
  {
    v31 = *((unsigned int *)this + 74);
    dest.data = BaseAddress;
    dest.height = v31;
    v32 = *((unsigned int *)this + 75);
    dest.width = *((unsigned int *)this + 73);
    dest.rowBytes = v32;
    if (*((_BYTE *)this + 405))
    {
      *(_DWORD *)permuteMap = 50331906;
      vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
    }
    if (!*((_BYTE *)this + 413) && !*((_BYTE *)this + 405))
      vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
  }
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_54:
    BlockArray = 0;
    goto LABEL_55;
  }
  v35 = 0;
  v43.origin.x = 0.0;
  v43.origin.y = 0.0;
  v43.size.width = v27;
  v43.size.height = v26;
  **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v43, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
  {
    v36 = 0;
  }
  else
  {
    v44.origin.x = 0.0;
    v44.origin.y = 0.0;
    v44.size.width = v27;
    v44.size.height = v26;
    *(CGRect *)(&v36 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v44);
    v35 = v37;
    v27 = v38;
    v26 = v39;
  }
  BlockArray = 0;
  *((_QWORD *)this + 15) = v35;
  *((_QWORD *)this + 16) = v36;
  *((double *)this + 17) = v27;
  *((double *)this + 18) = v26;
  if (v21)
  {
LABEL_56:
    v33 = (const char **)*((_QWORD *)this + 3);
    if (v33)
      IIOImageReadSession::unmapData(v33);
  }
  return BlockArray;
}

void HDRFlexGTC_curveFit(uint64_t a1, uint64_t a2, char a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v8;
  float v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  int *v20;
  unint64_t v21;
  int v22;
  float v23;
  float v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  float v34;
  int v35;
  float *v36;
  int v37;
  float v38;
  float v39;
  uint64_t v41;
  int v42;
  unsigned int v44;
  float v45;
  float v46;
  _OWORD v47[7];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  float v65[34];
  uint64_t v66;

  v8 = 0;
  v66 = *MEMORY[0x1E0C80C00];
  v46 = 0.0;
  memset(v65, 0, 128);
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v48 = 0u;
  v10 = -1.0;
  memset(v47, 0, sizeof(v47));
  v45 = 0.0;
  do
  {
    v65[v8] = (float)((float)(int)v8 + 0.5) * 0.03125;
    v11 = binY(a1, v8, *((float *)&a2 + 1));
    v12 = fmaxf(v11, v10);
    if ((a3 & 1) != 0)
      v10 = v12;
    else
      v10 = v11;
    *((float *)&v57 + v8++) = v10;
  }
  while ((_DWORD)v8 != 32);
  v13 = 0;
  do
  {
    v14 = v13;
    v15 = 31 - v13++;
    v16 = 2;
    do
    {
      v17 = 0;
      LODWORD(v18) = v14 - v16;
      if (v14 >= v16)
        v18 = v18;
      else
        v18 = 0;
      LODWORD(v19) = v16 + v13;
      if (v15 <= v16)
        v19 = 32;
      else
        v19 = v19;
      if (v19 > v18)
      {
        v17 = 0;
        v20 = (int *)(a1 + 140 * v18);
        v21 = v18;
        do
        {
          v22 = *v20;
          v20 += 35;
          v17 += v22;
          ++v21;
        }
        while (v21 < v19);
      }
      if (v16 > 0xE)
        break;
      ++v16;
    }
    while (v17 < 201);
    linearRegression(&v65[v18], (float *)&v57 + v18, v19 - v18, &v46, &v45);
    v23 = v45;
    v24 = v46 + (float)(v45 * v65[v14]);
    *((float *)&v49 + v14) = v24;
    *((float *)v47 + v14) = v23;
    if (v24 > 1.0)
    {
      *((_DWORD *)&v49 + v14) = 1065353216;
      *((_DWORD *)v47 + v14) = 0;
    }
  }
  while (v13 != 32);
  v25 = 0;
  v61 = v53;
  v62 = v54;
  v63 = v55;
  v64 = v56;
  v57 = v49;
  v58 = v50;
  v59 = v51;
  v60 = v52;
  *(_DWORD *)a4 = 0;
  v26 = v47[0];
  *(float *)(a4 + 4) = fminf(fmaxf(*(float *)&v49 + (float)(*(float *)v47 * -0.015625), 0.0), 1.0);
  *(_DWORD *)(a4 + 8) = v26;
  v27 = a4 + 28;
  v28 = 1;
  do
  {
    v44 = v28;
    v29 = v27;
    v30 = v25 + 2;
    LODWORD(v31) = v25 + 2;
    if (v25 <= 29)
    {
      v31 = v30;
      if (v30 <= 31)
        v32 = 31;
      else
        v32 = v30;
      v33 = 3;
      while (1)
      {
        *(float *)(a4 + 28) = (float)((float)(int)v31 + 0.5) * 0.03125;
        *(_DWORD *)(a4 + 32) = *((_DWORD *)&v49 + v31);
        *(_DWORD *)(a4 + 36) = *((_DWORD *)v47 + v31);
        computeCubic(a4);
        v34 = 0.0;
        if (v31 >= v25)
        {
          v34 = 0.0;
          v35 = v25;
          v36 = (float *)&v57 + v25;
          v37 = v33;
          do
          {
            v38 = *v36++;
            v39 = *(float *)(a4 + 24)
                + (*(float *)(a4 + 20)
                 + (*(float *)(a4 + 16) + *(float *)(a4 + 12) * (float)((float)((float)v35 + 0.5) * 0.03125))
                 * (float)((float)((float)v35 + 0.5) * 0.03125))
                * (float)((float)((float)v35 + 0.5) * 0.03125);
            v34 = v34 + (float)((float)(v38 - v39) * (float)(v38 - v39));
            ++v35;
            --v37;
          }
          while (v37);
        }
        if (sqrtf(v34 / (float)(v31 - v25 + 1)) > *(float *)&a2)
          break;
        ++v33;
        if (v31++ == v32)
        {
          LODWORD(v31) = 32;
          break;
        }
      }
    }
    if ((int)v31 >= 32)
      v25 = 32;
    else
      v25 = v31;
    v41 = v25 - 1;
    *(float *)(a4 + 28) = (float)((float)(int)v41 + 0.5) * 0.03125;
    *(_DWORD *)(a4 + 32) = *((_DWORD *)&v49 + v41);
    *(_DWORD *)(a4 + 36) = *((_DWORD *)v47 + v41);
    computeCubic(a4);
    if (v25 > 31)
      break;
    v28 = v44 + 1;
    v27 = v29 + 28;
    a4 = v29;
  }
  while (v44 < 0x1E);
  *(_DWORD *)(v29 + 28) = 1065353216;
  v42 = HIDWORD(v48);
  *(float *)(v29 + 32) = fminf(fmaxf(*((float *)&v56 + 3) + (float)(*((float *)&v48 + 3) * 0.015625), 0.0), 1.0);
  *(_DWORD *)(v29 + 36) = v42;
  computeCubic(v29);
  *a5 = v44 + 2;
}

float HDRFlexGTC_fillTable(float *a1, int a2, uint64_t a3, int a4, float result)
{
  float *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL4 v15;
  float *v17;
  float *v18;
  float v19;
  BOOL v20;
  float v21;

  v7 = a1;
  v8 = a2 - 1;
  if (a2 >= 2)
  {
    v9 = (a2 - 1);
    v10 = (uint64_t)a1;
    do
    {
      result = computeCubic(v10);
      v10 += 28;
      --v9;
    }
    while (v9);
  }
  if ((a4 & 0x80000000) == 0)
  {
    v11 = 0;
    v12 = (unint64_t)&v7[7 * v8];
    v13 = v7[7];
    result = (float)a4;
    do
    {
      v14 = (float)(int)v11 / result;
      v15 = v14 > v13;
      if (v14 > v13 && (unint64_t)(v7 + 7) < v12)
      {
        v17 = v7 + 14;
        v18 = v7 + 14;
        do
        {
          v19 = *v18;
          v18 += 7;
          v13 = v19;
          v15 = v14 > v19;
          v20 = v14 <= v19 || (unint64_t)v17 >= v12;
          v17 = v18;
        }
        while (!v20);
        v7 = v18 - 14;
      }
      if (v15)
        v14 = v13;
      v21 = v7[6] + (v7[5] + (v7[4] + v7[3] * v14) * v14) * v14;
      *(float *)(a3 + 4 * v11++) = v21;
    }
    while (v11 != a4 + 1);
  }
  return result;
}

float computeCubic(uint64_t a1)
{
  double v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  float result;

  v1 = *(float *)a1;
  v2 = *(float *)(a1 + 4);
  v3 = *(float *)(a1 + 8);
  v4 = *(float *)(a1 + 28);
  v5 = *(float *)(a1 + 36);
  v6 = (v3 + v5 - (*(float *)(a1 + 32) - v2 + *(float *)(a1 + 32) - v2) / (v4 - v1)) / ((v1 - v4) * (v1 - v4));
  v7 = (v5 - v3) / (v4 - v1 + v4 - v1) + (v1 + v4) * -1.5 * v6;
  v8 = v3 + v1 * -3.0 * v1 * v6 + v1 * -2.0 * v7;
  v9 = v2 + -(v1 * v1) * v1 * v6 + -(v1 * v1) * v7 - v1 * v8;
  *(float *)&v2 = v6;
  *(float *)&v7 = v7;
  *(_DWORD *)(a1 + 12) = LODWORD(v2);
  *(_DWORD *)(a1 + 16) = LODWORD(v7);
  *(float *)&v2 = v8;
  result = v9;
  *(_DWORD *)(a1 + 20) = LODWORD(v2);
  *(float *)(a1 + 24) = result;
  return result;
}

BOOL HDRFlexGTC_fillGaps(uint64_t a1, uint64_t a2, char a3)
{
  int v4;
  float v5;
  char *v6;
  int v7;
  int *v8;
  int v9;
  unint64_t v10;
  BOOL v11;
  int v12;
  int *i;
  int v14;
  int v15;
  int v16;
  int v17;
  float32x2_t v18;
  float32x2_t v19;
  uint64_t v20;
  int v21;
  int v22;
  float32x2_t v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  float v31;
  int v32;
  float v33;
  float v34;
  float v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  float v41;
  int v42;
  uint64_t v44;
  int v46;
  uint64_t v47;
  uint64_t v48;
  _OWORD v49[8];
  uint64_t v50;

  LOBYTE(v4) = 0;
  v50 = *MEMORY[0x1E0C80C00];
  v47 = 0;
  v48 = 0;
  v5 = *((float *)&a2 + 1);
  v46 = 0;
  v6 = (char *)v49;
  v7 = -1;
  v8 = (int *)a1;
  memset(v49, 0, sizeof(v49));
  do
  {
    v9 = *v8;
    if ((v4 & 1) != 0)
    {
      if (v9)
      {
        v4 = 0;
        *((_DWORD *)v6 + 1) = v7;
        v6 += 8;
        goto LABEL_10;
      }
    }
    else
    {
      if (v9)
      {
        v4 = 0;
        goto LABEL_10;
      }
      if (v6 - (char *)v49 >= 121)
      {
        puts("too many gaps");
        LODWORD(v10) = 16;
LABEL_16:
        v11 = 0;
        v12 = 0;
        v44 = a1 + 12;
        for (i = (int *)v49; ; i += 2)
        {
          v14 = *i;
          v15 = i[1];
          v16 = v15 + 1;
          v17 = *i - 1;
          if (*i < 1)
          {
            if (v15 > 30)
            {
              puts("no gain samples");
              return v11;
            }
            if (!slopeScan(a1, v16, 1, (_DWORD *)&v48 + 1, &v48))
              return v11;
            multiBinLinearRegression(a1, SHIDWORD(v48), v48, (_DWORD *)&v47 + 1, &v47, (float *)&v46, a3 & 1, v5);
            v25 = *i;
            v26 = i[1];
            if (*i <= v26)
            {
              v27 = v47;
              v28 = v46;
              v29 = v44 + 140 * v25;
              v30 = v26 + 1;
              do
              {
                v31 = *((float *)&v27 + 1) + (float)(*(float *)&v27 * (float)((float)((float)v25 + 0.5) * 0.03125));
                v32 = vcvtms_s32_f32(v31 * 32.0);
                *(_DWORD *)(v29 - 12) = 1;
                if (v32 >= 31)
                  v32 = 31;
                *(float *)(v29 - 8) = v31;
                *(_DWORD *)(v29 - 4) = v28;
                *(_DWORD *)(v29 + 4 * (v32 & ~(v32 >> 31))) = 1;
                ++v25;
                v29 += 140;
              }
              while (v30 != v25);
            }
          }
          else if (v15 > 30)
          {
            if (!slopeScan(a1, v14 - 1, -1, (_DWORD *)&v48 + 1, &v48))
              return v11;
            multiBinLinearRegression(a1, SHIDWORD(v48), v48, (_DWORD *)&v47 + 1, &v47, (float *)&v46, a3 & 1, v5);
            v33 = (float)((float)v17 + 0.5) * 0.03125;
            v34 = *((float *)&v47 + 1);
            v35 = *(float *)&v47;
            if ((float)(*((float *)&v47 + 1) + *(float *)&v47) <= 1.0)
            {
              if (*(float *)&v47 < 0.0)
              {
                v34 = *((float *)&v47 + 1) + (float)(*(float *)&v47 * v33);
                *((float *)&v47 + 1) = v34;
                LODWORD(v47) = 0;
                v35 = 0.0;
              }
            }
            else
            {
              v35 = fmaxf((float)(1.0 - (float)(*((float *)&v47 + 1) + (float)(*(float *)&v47 * v33))) / (float)(1.0 - v33), 0.0);
              v34 = 1.0 - v35;
              *(float *)&v47 = v35;
              *((float *)&v47 + 1) = 1.0 - v35;
            }
            v36 = *i;
            v37 = i[1];
            if (*i <= v37)
            {
              v38 = v46;
              v39 = v44 + 140 * v36;
              v40 = v37 + 1;
              do
              {
                v41 = v34 + (float)(v35 * (float)((float)((float)v36 + 0.5) * 0.03125));
                v42 = vcvtms_s32_f32(v41 * 32.0);
                *(_DWORD *)(v39 - 12) = 50;
                if (v42 >= 31)
                  v42 = 31;
                *(float *)(v39 - 8) = v41;
                *(_DWORD *)(v39 - 4) = v38;
                *(_DWORD *)(v39 + 4 * (v42 & ~(v42 >> 31))) = 1;
                ++v36;
                v39 += 140;
              }
              while (v40 != v36);
            }
          }
          else if (v15 >= v14)
          {
            v18 = *(float32x2_t *)(a1 + 140 * v17 + 4);
            v19 = vsub_f32(*(float32x2_t *)(a1 + 140 * v16 + 4), v18);
            v20 = v44 + 140 * v14;
            v21 = v15 - v14;
            v22 = -1;
            do
            {
              v23 = vmla_n_f32(v18, v19, (float)(v22 + 2) / (float)(v16 - v17));
              *(_DWORD *)(v20 - 12) = 1;
              v24 = vcvtms_s32_f32(32.0 * v23.f32[0]);
              if (v24 >= 31)
                v24 = 31;
              *(float32x2_t *)(v20 - 8) = v23;
              *(_DWORD *)(v20 + 4 * (v24 & ~(v24 >> 31))) = 1;
              v20 += 140;
              ++v22;
            }
            while (v21 != v22);
          }
          v11 = ++v12 >= (int)v10;
          if (v12 == (_DWORD)v10)
            return v11;
        }
      }
      *(_DWORD *)v6 = v7 + 1;
    }
    v4 = 1;
LABEL_10:
    v8 += 35;
    ++v7;
  }
  while (v7 != 31);
  if (v4)
  {
    *((_DWORD *)v6 + 1) = 31;
    v6 += 8;
  }
  v10 = (unint64_t)(v6 - (char *)v49) >> 3;
  if ((int)v10 >= 1)
    goto LABEL_16;
  return 1;
}

float binY(uint64_t a1, int a2, float a3)
{
  float v3;
  uint64_t v4;
  int v5;
  int v6;
  float v9;

  v3 = (float)(a3 / 100.0) * (float)*(unsigned int *)(a1 + 140 * a2);
  v4 = 0;
  if (v3 == 0.0)
  {
    while (!*(_DWORD *)(a1 + 140 * a2 + 12 + 4 * v4))
    {
      if (++v4 == 32)
        return 0.0;
    }
    v9 = (float)(int)v4;
    return v9 * 0.03125;
  }
  else
  {
    v5 = 0;
    do
    {
      v6 = *(_DWORD *)(a1 + 140 * a2 + 12 + 4 * v4);
      if (v3 >= (float)v5 && v3 <= (float)(v6 + v5))
      {
        v9 = (float)((float)(v3 - (float)v5) / (float)v6) + (float)(int)v4;
        return v9 * 0.03125;
      }
      ++v4;
      v5 += v6;
    }
    while (v4 != 32);
    return 0.0;
  }
}

float linearRegression(float *a1, float *a2, int a3, float *a4, float *a5)
{
  uint64_t v5;
  float v6;
  uint64_t v7;
  float *v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  BOOL v21;
  float v22;
  float result;

  if (a3 <= 0)
  {
    v15 = 0.0;
    v16 = 0.0 / (float)a3;
    v13 = v16;
    v14 = 0.0;
  }
  else
  {
    v5 = a3;
    v6 = 0.0;
    v7 = a3;
    v8 = a2;
    v9 = a1;
    v10 = 0.0;
    do
    {
      v11 = *v8++;
      v10 = v10 + v11;
      v12 = *v9++;
      v6 = v6 + v12;
      --v7;
    }
    while (v7);
    v13 = v10 / (float)a3;
    v14 = 0.0;
    v15 = 0.0;
    v16 = v6 / (float)a3;
    do
    {
      v17 = *a1++;
      v18 = v17 - v16;
      v14 = v14 + (float)(v18 * v18);
      v19 = *a2++;
      v15 = v15 + (float)((float)(v19 - v13) * v18);
      --v5;
    }
    while (v5);
  }
  v20 = v15 / v14;
  v21 = v14 == 0.0;
  v22 = 0.0;
  if (!v21)
    v22 = v20;
  result = v13 - (float)(v22 * v16);
  *a4 = result;
  *a5 = v22;
  return result;
}

uint64_t slopeScan(uint64_t a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  int v12;
  BOOL v14;
  uint64_t v15;
  int v16;
  int v17;

  if (a3 == 1)
    v5 = 32;
  else
    v5 = -1;
  v6 = *(_DWORD *)(a1 + 140 * a2);
  v7 = a3 + a2;
  v8 = a3 + (uint64_t)a2;
  v9 = v5 - v8;
  v10 = (int *)(a1 + 140 * v8);
  v11 = 1;
  do
  {
    v12 = v7;
    if (!v9)
      break;
    if (*v10 > 0)
      ++v11;
    v6 += *v10;
    v7 += a3;
    v9 -= a3;
    v10 += 35 * a3;
  }
  while (v6 < 200 || v11 < 5);
  v14 = v6 <= 199 || v11 <= 4;
  v15 = !v14;
  if (v14)
  {
    puts("too few samples");
  }
  else
  {
    if (a3 <= 0)
      v16 = v12;
    else
      v16 = a2;
    *a4 = v16;
    if (a3 <= 0)
      v17 = a2;
    else
      v17 = v12;
    *a5 = v17;
  }
  return v15;
}

void multiBinLinearRegression(uint64_t a1, int a2, int a3, _DWORD *a4, _DWORD *a5, float *a6, int a7, float a8)
{
  int v11;
  int v13;
  int v15;
  uint64_t v16;
  float v17;
  float *v18;
  float *v19;
  float v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  float *v25;
  float *v26;
  float v27;
  float v28;
  float v29;
  uint64_t v31;
  _OWORD v32[8];
  float v33[34];
  uint64_t v34;

  v11 = 0;
  v34 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  memset(v33, 0, 128);
  memset(v32, 0, sizeof(v32));
  if (a2 <= a3)
  {
    v13 = a2;
    v11 = 0;
    v15 = a3 + 1;
    v16 = 140 * a2;
    v17 = -1.0;
    v18 = v33;
    v19 = (float *)v32;
    do
    {
      if (*(_DWORD *)(a1 + v16))
      {
        *v18++ = (float)((float)v13 + 0.5) * 0.03125;
        v20 = binY(a1, v13, a8);
        v21 = fmaxf(v20, v17);
        if (a7)
          v17 = v21;
        else
          v17 = v20;
        *v19++ = v17;
        ++v11;
      }
      ++v13;
      v16 += 140;
    }
    while (v15 != v13);
  }
  linearRegression(v33, (float *)v32, v11, (float *)&v31 + 1, (float *)&v31);
  v22 = v31;
  *a4 = HIDWORD(v31);
  *a5 = v22;
  if (v11 < 1)
  {
    v24 = 0.0;
  }
  else
  {
    v23 = v11;
    v24 = 0.0;
    v25 = (float *)v32;
    v26 = v33;
    do
    {
      v27 = *v26++;
      v28 = *((float *)&v22 + 1) + (float)(*(float *)&v22 * v27);
      v29 = *v25++;
      v24 = v24 + (float)((float)(v29 - v28) * (float)(v29 - v28));
      --v23;
    }
    while (v23);
  }
  *a6 = sqrtf(v24 / (float)v11);
}

uint64_t _TIFFMultiply32(uint64_t a1, unsigned int a2, unsigned int a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3 || ((a3 * (unint64_t)a2) & 0xFFFFFFFF00000000) == 0)
    return a3 * a2;
  TIFFErrorExtR(a1, a4, "Integer overflow in %s", (uint64_t)a4, a5, a6, a7, a8, (char)a4);
  return 0;
}

uint64_t _TIFFMultiplySSize(uint64_t a1, int64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (a2 < 1 || a3 <= 0)
  {
    v8 = 0;
    if (a1 && a4)
    {
      TIFFErrorExtR(a1, a4, "Invalid argument to _TIFFMultiplySSize() in %s", (uint64_t)a4, a5, a6, a7, a8, (char)a4);
      return 0;
    }
  }
  else
  {
    if (0x7FFFFFFFFFFFFFFFuLL / a3 >= a2)
      return a3 * a2;
    v8 = 0;
    if (a1 && a4)
    {
      TIFFErrorExtR(a1, a4, "Integer overflow in %s", (uint64_t)a4, a5, a6, a7, a8, (char)a4);
      return 0;
    }
  }
  return v8;
}

uint64_t TIFFDefaultTransferFunction(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  unint64_t v30;
  float64x2_t v31;
  float64x2_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  char *v41;
  char *v42;
  float64x2_t v43;
  float64x2_t v44;
  uint64x2_t v45;
  long double v46;
  int32x2_t v47;

  *(_QWORD *)(a2 + 272) = 0;
  *(_QWORD *)(a2 + 280) = 0;
  *(_QWORD *)(a2 + 288) = 0;
  v8 = *(unsigned __int16 *)(a2 + 44);
  if (v8 > 0x3D)
    return 0;
  v12 = a2 + 272;
  v13 = 2 << v8;
  result = (uint64_t)_TIFFmallocExt(a1, 2 << v8, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)v12 = result;
  if (result)
  {
    v20 = result;
    *(_WORD *)result = 0;
    if (v8)
    {
      v21 = 0;
      v22 = 1 << v8;
      if ((unint64_t)(1 << v8) <= 2)
        v22 = 2;
      v45 = (uint64x2_t)vdupq_n_s64(v22 - 2);
      v23 = (double)(1 << v8) + -1.0;
      v24 = v22 & 0x7FFFFFFFFFFFFFFELL;
      __asm { FMOV            V0.2D, #0.5 }
      v43 = _Q0;
      v44 = (float64x2_t)vdupq_n_s64(0x40EFFFE000000000uLL);
      do
      {
        v47 = vmovn_s64((int64x2_t)vcgeq_u64(v45, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v21), (int8x16_t)xmmword_18820C490)));
        v30 = v21 + 2;
        v46 = pow((double)(uint64_t)(v21 + 2) / v23, 2.2);
        v31.f64[0] = pow((double)(uint64_t)(v21 + 1) / v23, 2.2);
        v31.f64[1] = v46;
        v32 = vrndmq_f64(vmlaq_f64(v43, v44, v31));
        if ((v47.i8[0] & 1) != 0)
          *(_WORD *)(v20 + 2 * v21 + 2) = (int)v32.f64[0];
        if ((v47.i8[4] & 1) != 0)
          *(_WORD *)(v20 + 2 * v21 + 4) = (int)v32.f64[1];
        v21 += 2;
      }
      while (v30 != v24);
    }
    if (*(unsigned __int16 *)(a2 + 58) - *(unsigned __int16 *)(a2 + 140) < 2)
      return 1;
    v33 = _TIFFmallocExt(a1, v13, v14, v15, v16, v17, v18, v19);
    *(_QWORD *)(a2 + 280) = v33;
    if (v33)
    {
      _TIFFmemcpy(v33, *(const void **)(a2 + 272), v13);
      v40 = _TIFFmallocExt(a1, v13, v34, v35, v36, v37, v38, v39);
      *(_QWORD *)(a2 + 288) = v40;
      if (v40)
      {
        _TIFFmemcpy(v40, *(const void **)v12, v13);
        return 1;
      }
    }
    if (*(_QWORD *)v12)
      _TIFFfreeExt((uint64_t)a1, *(char **)v12);
    v41 = *(char **)(a2 + 280);
    if (v41)
      _TIFFfreeExt((uint64_t)a1, v41);
    v42 = *(char **)(a2 + 288);
    if (v42)
      _TIFFfreeExt((uint64_t)a1, v42);
    result = 0;
    *(_QWORD *)v12 = 0;
    *(_QWORD *)(v12 + 8) = 0;
    *(_QWORD *)(v12 + 16) = 0;
  }
  return result;
}

uint64_t TIFFDefaultRefBlackWhite(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  float v10;

  result = (uint64_t)_TIFFmallocExt(a1, 24, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)(a2 + 296) = result;
  if (result)
  {
    if (*(_WORD *)(a2 + 50) == 6)
    {
      *(_QWORD *)(result + 16) = 0x437F000043000000;
      *(_OWORD *)result = xmmword_18822DCA0;
    }
    else
    {
      v10 = (float)~(-1 << *(_WORD *)(a2 + 44));
      *(_DWORD *)result = 0;
      *(float *)(result + 4) = v10;
      *(_DWORD *)(result + 8) = 0;
      *(float *)(result + 12) = v10;
      *(_DWORD *)(result + 16) = 0;
      *(float *)(result + 20) = v10;
    }
    return 1;
  }
  return result;
}

float _TIFFClampDoubleToFloat(double a1)
{
  if (a1 > 3.40282347e38)
    return 3.4028e38;
  if (a1 < -3.40282347e38)
    return -3.4028e38;
  return a1;
}

uint64_t ASTCReadPlugin::ASTCReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;

  result = CommonASTCReadPlugin::CommonASTCReadPlugin(a1, a2, a3);
  *(_QWORD *)result = &off_1E1BADE88;
  *(_QWORD *)(result + 502) = -1;
  *(_QWORD *)(result + 488) = -1;
  *(_QWORD *)(result + 496) = -1;
  *(_WORD *)(result + 504) = 0;
  return result;
}

void ASTCReadPlugin::~ASTCReadPlugin(ASTCReadPlugin *this)
{
  *(_QWORD *)this = &off_1E1BADE88;
  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);
}

{
  *(_QWORD *)this = &off_1E1BADE88;
  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t ASTCReadPlugin::loadDataFromXPCObject(ASTCReadPlugin *this, void *a2)
{
  uint64_t DataFromXPCObject;
  char *data;
  __int128 v6;
  uint64_t v7;
  size_t length;

  DataFromXPCObject = CommonASTCReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)DataFromXPCObject)
  {
    length = 0;
    data = (char *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_astc", &length);
    if (length == 22)
    {
      DataFromXPCObject = 0;
      v6 = *(_OWORD *)data;
      *(_QWORD *)((char *)this + 502) = *(_QWORD *)(data + 14);
      *(_OWORD *)((char *)this + 488) = v6;
    }
    else
    {
      DataFromXPCObject = 4294967246;
    }
    v7 = *((_QWORD *)this + 59);
    if (v7)
      (*(void (**)(uint64_t, void *))(*(_QWORD *)v7 + 16))(v7, a2);
  }
  return DataFromXPCObject;
}

uint64_t ASTCReadPlugin::saveDataToXPCObject(ASTCReadPlugin *this, void *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = CommonASTCReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_astc", (char *)this + 488, 0x16uLL);
    v5 = *((_QWORD *)this + 59);
    if (v5)
      (*(void (**)(uint64_t, void *))(*(_QWORD *)v5 + 24))(v5, a2);
  }
  return v4;
}

unint64_t ASTCReadPlugin::calculateKTXOffsetToRequestedImage(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int v5;
  unsigned int v6;
  int v7;
  int v8;
  unsigned int v10;

  v5 = *(unsigned __int16 *)(a1 + 318);
  v10 = 0;
  v6 = *(_DWORD *)(a2 + 48);
  if (v5)
  {
    if (v6)
      v7 = 1;
    else
      v7 = *(_DWORD *)(a2 + 52);
    do
    {
      IIOImageReadSession::seek(*(IIOImageReadSession **)(a1 + 24), a3, 0);
      IIOImageReadSession::getBytes(*(IIOImageReadSession **)(a1 + 24), &v10, 4uLL);
      a3 += v10 * v7 + 4;
      --v5;
    }
    while (v5);
  }
  IIOImageReadSession::seek(*(IIOImageReadSession **)(a1 + 24), a3, 0);
  IIOImageReadSession::getBytes(*(IIOImageReadSession **)(a1 + 24), &v10, 4uLL);
  v8 = v10;
  if (v6)
    v8 = v10 / v6;
  return a3 + (*(_DWORD *)(a1 + 208) * v8) + 4;
}

uint64_t ASTCReadPlugin::decodeImageData(ASTCReadPlugin *this, unsigned __int8 *a2)
{
  void *v4;
  vImagePixelCount v5;
  vImagePixelCount v6;
  size_t v7;
  IIOImageReadSession *v8;
  vImage_Buffer v10;

  v4 = (void *)*((_QWORD *)this + 59);
  if (v4)
  v5 = *((unsigned int *)this + 65);
  v6 = *((unsigned int *)this + 66);
  v7 = *((unsigned int *)this + 75);
  v10.data = a2;
  v10.height = v6;
  v10.width = v5;
  v10.rowBytes = v7;
  v8 = (IIOImageReadSession *)*((_QWORD *)this + 3);
  if (v8)
    return ASTCTextureImp::decodeASTCtoRGBX((ASTCTextureImp *)v4, v8, &v10, *((unsigned __int8 *)this + 310), *((_BYTE *)this + 405) == 0);
  else
    return 0;
}

uint64_t ASTCReadPlugin::decodeImageImp(uint64_t a1, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  const void *v8;
  ASTCTextureImp *v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  int v21;
  IIOImageRead **v22;
  _BOOL4 v23;
  int v24;
  unsigned int v25;
  int v26;
  void *BaseAddress;
  size_t Height;
  uint64_t BlockArray;
  size_t v30;
  double v31;
  double v32;
  unint64_t v33;
  unsigned int v34;
  size_t v35;
  void *v36;
  vImagePixelCount v37;
  vImagePixelCount v38;
  size_t v39;
  vImagePixelCount v40;
  vImagePixelCount v41;
  size_t v42;
  IIOImageReadSession *v43;
  const char **v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  double v49;
  double v50;
  vImage_Buffer v51;
  int v52;
  void *v53;
  size_t v54;
  size_t v55;
  vImage_Buffer v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;
  uint64_t v62;
  size_t v63[2];
  CGRect v64;
  CGRect v65;

  v63[0] = 0;
  v8 = *(const void **)(a1 + 472);
  if (v8)
  else
    v9 = 0;
  v62 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v10 = *(_DWORD *)(a1 + 204);
    v11 = v10 >> 24;
    v12 = MEMORY[0x1E0C80978];
    if (v10 < 0)
    {
      v13 = __maskrune(v11, 0x40000uLL);
      v10 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      v13 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v11 + 60) & 0x40000;
    }
    if (v13)
      v14 = (v10 >> 24);
    else
      v14 = 46;
    v15 = v10 << 8 >> 24;
    if (v10 << 8 < 0)
    {
      v16 = __maskrune(v15, 0x40000uLL);
      v10 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      v16 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
    }
    if (v16)
      v17 = (v10 << 8 >> 24);
    else
      v17 = 46;
    v18 = (__int16)v10 >> 8;
    if (v10 << 16 < 0)
    {
      v19 = __maskrune(v18, 0x40000uLL);
      v10 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      v19 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
    }
    if (v19)
      v20 = ((__int16)v10 >> 8);
    else
      v20 = 46;
    if ((v10 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000) != 0)
        goto LABEL_25;
    }
    else if (__maskrune((char)v10, 0x40000uLL))
    {
LABEL_25:
      v21 = *(_DWORD *)(a1 + 204);
LABEL_28:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v14, v17, v20, (char)v21, iioTypeStr[a3], "virtual OSStatus ASTCReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_29;
    }
    LOBYTE(v21) = 46;
    goto LABEL_28;
  }
LABEL_29:
  IIOReadPlugin::debugDecodeImage((IIOReadPlugin *)a1, a2);
  if (*(_BYTE *)(a1 + 410) == 1 && *(_QWORD *)(a1 + 392) != 16)
  {
    _cg_jpeg_mem_term("decodeImageImp", 896, "*** ERROR: ASTC cannot handle %d rowBytesAlignment\n", *(_QWORD *)(a1 + 392));
    BlockArray = 0;
    goto LABEL_66;
  }
  *(_QWORD *)(a1 + 392) = 16;
  v22 = *(IIOImageRead ***)(a1 + 24);
  if (v22)
    v23 = IIOImageReadSession::mapData(v22);
  else
    v23 = 0;
  v24 = ASTCTextureImp::needs_hdr(v9);
  v25 = *(_DWORD *)(a1 + 236);
  if (v24)
  {
    v26 = *(_DWORD *)(a1 + 228);
    if (v25 < 8 * v26)
    {
      v25 = 8 * v26;
      *(_DWORD *)(a1 + 236) = 8 * v26;
    }
  }
  *(_DWORD *)(a1 + 300) = ImageIOAlignRowBytes(v25, *(_QWORD *)(a1 + 392));
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
    LODWORD(v33) = *(_DWORD *)(a1 + 292);
    v32 = (double)v33;
    v34 = *(_DWORD *)(a1 + 296);
    v31 = (double)v34;
    v30 = *(unsigned int *)(a1 + 300) * (unint64_t)v34;
    BaseAddress = (void *)_ImageIO_Malloc(v30, *(_QWORD *)(a1 + 384), v63, (uint64_t)kImageMalloc_ASTC_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      BlockArray = 0;
      goto LABEL_63;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v30 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v63[0] = v30;
    v31 = 0.0;
    v32 = 0.0;
  }
  if (!BaseAddress)
  {
LABEL_63:
    if (!v23)
      goto LABEL_66;
    goto LABEL_64;
  }
  if (*(_BYTE *)(a1 + 505))
  {
    v35 = (16 * *(_DWORD *)(a1 + 452) * *(_DWORD *)(a1 + 456));
    v36 = malloc_type_calloc(v35, 1uLL, 0x94AE4889uLL);
    if (v36)
    {
      v61 = 0;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      memset(&v56, 0, sizeof(v56));
      if (!CreateKtxStream((uint64_t)&v56, *(IIOImageReadSession **)(a1 + 24)))
      {
        if (ktxTexture2_CreateFromStream(&v56, 0, &v62))
        {
          _cg_jpeg_mem_term("decodeImageImp", 965, "*** ERROR: ktxTexture2_CreateFromStream failed [%d]\n");
        }
        else
        {
          v52 = *(_DWORD *)(a1 + 208);
          v53 = v36;
          v54 = v35;
          v55 = 0;
          if (!(*(unsigned int (**)(void))(*(_QWORD *)(v62 + 8) + 40))())
          {
            v37 = *(unsigned int *)(a1 + 260);
            v38 = *(unsigned int *)(a1 + 264);
            v39 = *(unsigned int *)(a1 + 300);
            v51.data = BaseAddress;
            v51.height = v38;
            v51.width = v37;
            v51.rowBytes = v39;
            BlockArray = ASTCTextureImp::decodeASTCtoRGBX(v9, v36, v55, &v51, *(unsigned __int8 *)(a1 + 310), *(_BYTE *)(a1 + 405) == 0);
            if (!(_DWORD)BlockArray)
              goto LABEL_51;
            goto LABEL_58;
          }
          _cg_jpeg_mem_term("decodeImageImp", 969, "*** ERROR: ktxTexture_IterateLoadLevelFaces failed [%d]\n");
        }
      }
    }
LABEL_59:
    if (a3 == 3)
      _ImageIO_Free((unint64_t)BaseAddress, v63[0]);
    if (!v36)
      goto LABEL_53;
LABEL_62:
    free(v36);
    goto LABEL_63;
  }
  v40 = *(unsigned int *)(a1 + 292);
  v41 = *(unsigned int *)(a1 + 296);
  v42 = *(unsigned int *)(a1 + 300);
  v56.data = BaseAddress;
  v56.height = v41;
  v56.width = v40;
  v56.rowBytes = v42;
  v43 = *(IIOImageReadSession **)(a1 + 24);
  if (v43)
    BlockArray = ASTCTextureImp::decodeASTCtoRGBX(v9, v43, &v56, *(unsigned __int8 *)(a1 + 310), *(_BYTE *)(a1 + 405) == 0);
  v36 = 0;
  if ((_DWORD)BlockArray)
  {
LABEL_58:
    *(_DWORD *)(a1 + 104) = 0;
    goto LABEL_59;
  }
LABEL_51:
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
    BlockArray = 0;
    if (!v36)
      goto LABEL_53;
    goto LABEL_62;
  }
  v46 = 0;
  v64.origin.x = 0.0;
  v64.origin.y = 0.0;
  v64.size.width = v32;
  v64.size.height = v31;
  **(_QWORD **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, BaseAddress, v30, v64, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
  if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
  {
    v47 = 0;
  }
  else
  {
    v65.origin.x = 0.0;
    v65.origin.y = 0.0;
    v65.size.width = v32;
    v65.size.height = v31;
    *(CGRect *)(&v47 - 1) = CGRectUnion(*(CGRect *)(a1 + 120), v65);
    v46 = v48;
    v32 = v49;
    v31 = v50;
  }
  BlockArray = 0;
  *(_QWORD *)(a1 + 120) = v46;
  *(_QWORD *)(a1 + 128) = v47;
  *(double *)(a1 + 136) = v32;
  *(double *)(a1 + 144) = v31;
  if (v36)
    goto LABEL_62;
LABEL_53:
  if (!v23)
    goto LABEL_66;
LABEL_64:
  v44 = *(const char ***)(a1 + 24);
  if (v44)
    IIOImageReadSession::unmapData(v44);
LABEL_66:
  if (v62)
    (**(void (***)(void))(v62 + 8))();
  return BlockArray;
}

uint64_t TIFFInitLZW(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  if (a2 != 5)
    TIFFInitLZW_cold_1();
  v9 = _TIFFmallocExt((_QWORD *)a1, 296, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)(a1 + 1096) = v9;
  if (v9)
  {
    v9[29] = 0;
    v9[24] = 0;
    *((_DWORD *)v9 + 38) = *(_DWORD *)(a1 + 12);
    v9[36] = 0;
    *(_QWORD *)(a1 + 952) = LZWFixupTags;
    *(_QWORD *)(a1 + 960) = LZWSetupDecode;
    *(_QWORD *)(a1 + 968) = LZWPreDecode;
    *(_QWORD *)(a1 + 1008) = LZWDecode;
    *(_QWORD *)(a1 + 1024) = LZWDecode;
    *(_QWORD *)(a1 + 1040) = LZWDecode;
    *(_QWORD *)(a1 + 976) = LZWSetupEncode;
    *(_QWORD *)(a1 + 992) = LZWPreEncode;
    *(_QWORD *)(a1 + 1000) = LZWPostEncode;
    *(_QWORD *)(a1 + 1016) = LZWEncode;
    *(_QWORD *)(a1 + 1032) = LZWEncode;
    *(_QWORD *)(a1 + 1048) = LZWEncode;
    *(_QWORD *)(a1 + 1072) = LZWCleanup;
    TIFFPredictorInit(a1, v10, v11, v12, v13, v14, v15, v16);
    return 1;
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFInitLZW", "No space for LZW state block", v12, v13, v14, v15, v16, v18);
    return 0;
  }
}

uint64_t LZWFixupTags()
{
  return 1;
}

uint64_t LZWSetupDecode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _BYTE *v19;
  uint64_t i;
  char *v22;
  char v23;

  v9 = (_QWORD *)a1[137];
  if (!v9)
  {
    v10 = _TIFFmallocExt(a1, 296, a3, a4, a5, a6, a7, a8);
    a1[137] = v10;
    if (!v10)
    {
      v22 = "No space for LZW state block";
      goto LABEL_12;
    }
    v9 = v10;
    v10[29] = 0;
    v10[24] = 0;
    TIFFPredictorInit((uint64_t)a1, v11, v12, v13, v14, v15, v16, v17);
  }
  if (v9[29])
    return 1;
  v18 = _TIFFmallocExt(a1, 81904, a3, a4, a5, a6, a7, a8);
  v9[29] = v18;
  if (v18)
  {
    v19 = (char *)v18 + 4092;
    for (i = 255; i != -1; --i)
    {
      *(v19 - 2) = i;
      *(v19 - 1) = i;
      *v19 = 1;
      *((_WORD *)v19 - 2) = 1;
      *(_QWORD *)(v19 - 12) = 0;
      v19 -= 16;
    }
    *((_OWORD *)v18 + 257) = 0u;
    *((_OWORD *)v18 + 256) = 0u;
    return 1;
  }
  v22 = "No space for LZW code table";
LABEL_12:
  TIFFErrorExtR((uint64_t)a1, "LZWSetupDecode", v22, v13, v14, v15, v16, v17, v23);
  return 0;
}

uint64_t LZWPreDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  _BYTE *v11;
  char v13;

  v8 = *(_QWORD *)(a1 + 1096);
  if (!v8)
    LZWPreDecode_cold_1();
  v10 = *(_QWORD *)(v8 + 232);
  if (!v10)
  {
    (*(void (**)(uint64_t))(a1 + 960))(a1);
    v10 = *(_QWORD *)(v8 + 232);
    if (!v10)
      return 0;
  }
  if (*(uint64_t *)(a1 + 1160) >= 2 && (v11 = *(_BYTE **)(a1 + 1120), !*v11) && (v11[1] & 1) != 0)
  {
    if (!*(_QWORD *)(v8 + 192))
    {
      TIFFWarningExtR(a1, "LZWPreDecode", "Old-style LZW codes, convert file", a4, a5, a6, a7, a8, v13);
      *(_QWORD *)(a1 + 1008) = LZWDecodeCompat;
      *(_QWORD *)(a1 + 1024) = LZWDecodeCompat;
      *(_QWORD *)(a1 + 1040) = LZWDecodeCompat;
      (*(void (**)(uint64_t))(a1 + 960))(a1);
      *(_QWORD *)(v8 + 192) = LZWDecodeCompat;
      v10 = *(_QWORD *)(v8 + 232);
    }
    *(_WORD *)(v8 + 130) = 511;
  }
  else
  {
    *(_WORD *)(v8 + 130) = 510;
    *(_QWORD *)(v8 + 192) = LZWDecode;
  }
  *(_WORD *)(v8 + 128) = 9;
  *(_QWORD *)(v8 + 136) = 0;
  *(_QWORD *)(v8 + 144) = 0;
  *(_OWORD *)(v8 + 160) = xmmword_18822DCE0;
  *(_QWORD *)(v8 + 176) = 0;
  *(_QWORD *)(v8 + 184) = 0;
  *(_QWORD *)(v8 + 208) = v10;
  *(_QWORD *)(v8 + 216) = v10 - 16;
  *(_QWORD *)(v8 + 224) = v10 + 8160;
  *(_DWORD *)(v8 + 240) = 0;
  return 1;
}

uint64_t LZWDecode(_QWORD *a1, char *__b, int64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  char *v14;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int64_t v19;
  int64_t v20;
  int64_t v21;
  int64_t v22;
  BOOL v23;
  char *v24;
  uint64_t v25;
  unsigned __int8 *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  BOOL v46;
  char v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  BOOL v54;
  char v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  int64_t v59;
  int64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  uint64_t ***v70;
  uint64_t **v71;
  uint64_t *v72;
  char *v73;
  BOOL v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t *v87;
  int v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unsigned __int8 *v96;
  uint64_t v97;

  v3 = a1[137];
  if (!v3)
    LZWDecode_cold_1();
  v4 = *(_QWORD *)(v3 + 232);
  if (!v4)
    LZWDecode_cold_2();
  v5 = a3;
  v6 = __b;
  v7 = (uint64_t)a1;
  if (*(_DWORD *)(v3 + 240))
  {
    bzero(__b, a3);
    v13 = "LZWDecode";
    v88 = *(_DWORD *)(v7 + 876);
    v14 = "LZWDecode: Scanline %u cannot be read due to previous error";
LABEL_5:
    TIFFErrorExtR(v7, v13, v14, v8, v9, v10, v11, v12, v88);
    return 0;
  }
  v16 = *(_QWORD *)(v3 + 168);
  if (v16)
  {
    v17 = *(uint64_t **)(v3 + 200);
    v18 = *((unsigned __int16 *)v17 + 4);
    v19 = v18 - v16;
    v20 = a3 - (v18 - v16);
    if (a3 >= v18 - v16)
    {
      v24 = &__b[v19];
      v25 = ~v16 + v18;
      do
      {
        __b[v25] = *((_BYTE *)v17 + 11);
        v23 = v25-- != 0;
        if (!v23)
          break;
        v17 = (uint64_t *)*v17;
      }
      while (v17);
      *(_QWORD *)(v3 + 168) = 0;
    }
    else
    {
      *(_QWORD *)(v3 + 168) = v16 + a3;
      v21 = ~v16 + v18;
      do
      {
        v17 = (uint64_t *)*v17;
        if (v21 <= a3)
          break;
        --v21;
      }
      while (v17);
      if (v17)
      {
        v22 = a3 - 1;
        do
        {
          __b[v22] = *((_BYTE *)v17 + 11);
          v23 = v22-- != 0;
          if (!v23)
            break;
          v17 = (uint64_t *)*v17;
        }
        while (v17);
        v20 = v22 + 1;
        v24 = __b;
      }
      else
      {
        v24 = __b;
        v20 = a3;
      }
    }
    if (a3 < v19)
      return 1;
    v4 = *(_QWORD *)(v3 + 232);
    v6 = v24;
    v5 = v20;
  }
  v26 = (unsigned __int8 *)a1[144];
  v27 = *(_QWORD *)(v3 + 176) + 8 * (a1[145] - *(_QWORD *)(v3 + 184));
  *(_QWORD *)(v3 + 176) = v27;
  v28 = *(unsigned __int16 *)(v3 + 128);
  v30 = *(_QWORD *)(v3 + 136);
  v29 = *(_QWORD *)(v3 + 144);
  v31 = *(_QWORD *)(v3 + 160);
  v32 = *(_QWORD *)(v3 + 208);
  v33 = *(_QWORD *)(v3 + 216);
  v34 = *(_QWORD *)(v3 + 224);
  if (!v5)
    goto LABEL_114;
  v35 = v4 - 16;
  v36 = v4 + 4128;
  v37 = v4 + 8160;
  v38 = v4 + 81904;
  v97 = v7;
LABEL_28:
  while (2)
  {
    while (2)
    {
      while (2)
      {
        v29 -= v28;
        if (v29 >= 0)
          goto LABEL_29;
        if (v27 < 0x40)
        {
          if (v27 < 8)
            goto LABEL_117;
          v30 = *v26 | (v30 << 8);
          if ((unint64_t)v29 > 0xFFFFFFFFFFFFFFF7)
          {
            v29 += 8;
            ++v26;
            v27 -= 8;
          }
          else
          {
            if (v27 - 8 < 8)
            {
LABEL_117:
              bzero(v6, v5);
              *(_DWORD *)(v3 + 240) = 1;
              TIFFErrorExtR(v7, "LZWDecode", "LZWDecode: Strip %u not terminated with EOI code", v81, v82, v83, v84, v85, *(_DWORD *)(v7 + 884));
              return 0;
            }
            v67 = v26[1];
            v26 += 2;
            v30 = v67 | (v30 << 8);
            v29 += 16;
            v27 -= 16;
          }
LABEL_29:
          v39 = v30 >> v29;
          goto LABEL_30;
        }
        v51 = v30 << -(char)v29;
        v52 = *(_QWORD *)v26;
        v26 += 8;
        v30 = bswap64(v52);
        v53 = v30 >> v29;
        v29 += 64;
        v39 = v53 | v51;
        v27 -= 64;
LABEL_30:
        v40 = v39 & v31;
        v41 = v4 + 16 * (v39 & v31);
        if ((v39 & v31) <= 0x101)
        {
          if (v40 < 0x100)
          {
            if (v41 > v33)
              goto LABEL_118;
            *(_QWORD *)v33 = v32;
            *(_BYTE *)(v33 + 10) = *(_BYTE *)(v32 + 10);
            *(_WORD *)(v33 + 8) = *(_WORD *)(v32 + 8) + 1;
            *(_BYTE *)(v33 + 11) = v40;
            v44 = *(unsigned __int8 *)(v32 + 12);
            v45 = *(unsigned __int8 *)(v32 + 11);
            if (v44)
              v46 = v40 == v45;
            else
              v46 = 0;
            v47 = v46;
            *(_BYTE *)(v33 + 12) = v47;
            v48 = v33 + 16;
            if (v28 >= 11)
              v49 = 11;
            else
              v49 = v28;
            if (v48 >= v38)
              v50 = v35;
            else
              v50 = v33 + 16;
            if (v48 <= v34)
            {
              v33 += 16;
            }
            else
            {
              v28 = v49 + 1;
              v31 = ~(-2 << v49);
              v33 = v50;
            }
            if (v48 > v34)
              v34 = v35 + 16 * ~(-2 << v49);
            *v6++ = v40;
            v32 = v41;
            if (!--v5)
              goto LABEL_128;
            continue;
          }
          if (v40 == 257)
            goto LABEL_114;
          while (v29 <= 8)
          {
            if (v27 < 0x40)
            {
              if (v27 < 8)
                goto LABEL_117;
              v30 = *v26 | (v30 << 8);
              if (v29 <= 0)
              {
                if (v27 - 8 < 8)
                  goto LABEL_117;
                v64 = v26[1];
                v26 += 2;
                v30 = v64 | (v30 << 8);
                v29 += 7;
                v27 -= 16;
              }
              else
              {
                --v29;
                ++v26;
                v27 -= 8;
              }
              goto LABEL_88;
            }
            v61 = v30 << (9 - v29);
            v62 = *(_QWORD *)v26;
            v26 += 8;
            v30 = bswap64(v62);
            v29 += 55;
            v63 = (v30 >> v29) | v61;
            v27 -= 64;
LABEL_89:
            v65 = v63 & 0x1FF;
            if (v65 != 256)
            {
              if (v65 == 257)
              {
                v31 = 511;
                LOWORD(v28) = 9;
LABEL_113:
                v33 = v36;
                v34 = v37;
                goto LABEL_114;
              }
              if (v65 > 0x101)
              {
LABEL_118:
                bzero(v6, v5);
                *(_DWORD *)(v3 + 240) = 1;
                v13 = *(const char **)v7;
                v14 = "Using code not yet in table";
                goto LABEL_5;
              }
              *v6++ = v63;
              v32 = v4 + 16 * v65;
              v28 = 9;
              v31 = 511;
              v33 = v36;
              v34 = v37;
              if (!--v5)
              {
                LOWORD(v28) = 9;
                v31 = 511;
                goto LABEL_113;
              }
              goto LABEL_28;
            }
          }
          v29 -= 9;
LABEL_88:
          v63 = v30 >> v29;
          goto LABEL_89;
        }
        break;
      }
      if (v41 >= v33)
      {
        if (v41 != v33)
          goto LABEL_118;
        v43 = *(unsigned __int8 *)(v32 + 10);
        *(_BYTE *)(v33 + 11) = v43;
        v42 = v43;
      }
      else
      {
        v42 = *(unsigned __int8 *)(v4 + 16 * v40 + 10);
        *(_BYTE *)(v33 + 11) = v42;
        LOBYTE(v43) = *(_BYTE *)(v32 + 10);
      }
      if (*(_BYTE *)(v32 + 12))
        v54 = *(unsigned __int8 *)(v32 + 11) == v42;
      else
        v54 = 0;
      v55 = v54;
      *(_BYTE *)(v33 + 12) = v55;
      *(_QWORD *)v33 = v32;
      *(_BYTE *)(v33 + 10) = v43;
      *(_WORD *)(v33 + 8) = *(_WORD *)(v32 + 8) + 1;
      v56 = v33 + 16;
      if (v28 >= 11)
        v57 = 11;
      else
        v57 = v28;
      if (v56 >= v38)
        v58 = v35;
      else
        v58 = v33 + 16;
      if (v56 <= v34)
      {
        v33 += 16;
      }
      else
      {
        v28 = v57 + 1;
        v31 = ~(-2 << v57);
        v33 = v58;
      }
      if (v56 > v34)
        v34 = v35 + 16 * ~(-2 << v57);
      v59 = *(unsigned __int16 *)(v4 + 16 * v40 + 8);
      if (v59 <= 2)
      {
        v60 = v5 - 2;
        if (v5 <= 2)
        {
          if (v5 == 2)
          {
            v5 = 0;
            *(_WORD *)v6 = *(_WORD *)(v4 + 16 * v40 + 10);
            v6 += 2;
LABEL_123:
            v32 = v41;
            v7 = v97;
            goto LABEL_114;
          }
          goto LABEL_124;
        }
        *(_WORD *)v6 = *(_WORD *)(v4 + 16 * v40 + 10);
        v6 += 2;
        goto LABEL_97;
      }
      if ((_DWORD)v59 != 3)
      {
        if (v5 < v59)
          goto LABEL_124;
        v68 = v4 + 16 * v40;
        if (*(_BYTE *)(v68 + 12))
        {
          v91 = v35;
          v92 = v37;
          v89 = v41;
          v90 = v38;
          v95 = v31;
          v96 = v26;
          v93 = v36;
          v94 = v34;
          memset(v6, *(unsigned __int8 *)(v68 + 11), v59);
          v38 = v90;
          v35 = v91;
          v37 = v92;
          v36 = v93;
          v34 = v94;
          v31 = v95;
          v26 = v96;
          v6 += v59;
          v32 = v89;
          v5 -= v59;
          v7 = v97;
          if (!v5)
          {
            v32 = v89;
            goto LABEL_114;
          }
        }
        else
        {
          v69 = &v6[v59];
          *(v69 - 1) = *(_BYTE *)(v68 + 11);
          v70 = *(uint64_t ****)v41;
          *(v69 - 2) = *(_BYTE *)(*(_QWORD *)v41 + 11);
          v71 = *v70;
          *(v69 - 3) = *((_BYTE *)v71 + 11);
          v72 = *v71;
          v6[v59 - 4] = *((_BYTE *)v72 + 11);
          if (&v6[v59 - 4] > v6)
          {
            v73 = v69 - 5;
            do
            {
              v72 = (uint64_t *)*v72;
              v74 = v73 > v6;
              *v73-- = *((_BYTE *)v72 + 11);
            }
            while (v74);
          }
          v6 += v59;
          v32 = v41;
          v5 -= v59;
          v7 = v97;
          if (!v5)
          {
            v6 = v69;
            goto LABEL_128;
          }
        }
        continue;
      }
      break;
    }
    v60 = v5 - 3;
    if (v5 > 3)
    {
      v66 = v4 + 16 * v40;
      *v6 = *(_BYTE *)(v66 + 10);
      v6[1] = *(_BYTE *)(*(_QWORD *)v41 + 11);
      v6[2] = *(_BYTE *)(v66 + 11);
      v6 += 3;
LABEL_97:
      v5 = v60;
      v32 = v41;
      v7 = v97;
      continue;
    }
    break;
  }
  if (v5 == 3)
  {
    v5 = 0;
    v86 = v4 + 16 * v40;
    *v6 = *(_BYTE *)(v86 + 10);
    v6[1] = *(_BYTE *)(*(_QWORD *)v41 + 11);
    v6[2] = *(_BYTE *)(v86 + 11);
    v6 += 3;
    goto LABEL_123;
  }
LABEL_124:
  *(_QWORD *)(v3 + 200) = v41;
  v87 = (uint64_t *)v41;
  do
    v87 = (uint64_t *)*v87;
  while (v5 < *((unsigned __int16 *)v87 + 4));
  *(_QWORD *)(v3 + 168) = v5;
  v7 = v97;
  do
  {
    v6[v5 - 1] = *((_BYTE *)v87 + 11);
    v87 = (uint64_t *)*v87;
    --v5;
  }
  while (v5);
LABEL_128:
  v32 = v41;
LABEL_114:
  v75 = *(_QWORD *)(v7 + 1152) - (_QWORD)v26 + *(_QWORD *)(v7 + 1160);
  *(_QWORD *)(v7 + 1160) = v75;
  *(_QWORD *)(v7 + 1152) = v26;
  *(_QWORD *)(v3 + 176) = v27;
  *(_QWORD *)(v3 + 184) = v75;
  *(_WORD *)(v3 + 128) = v28;
  *(_QWORD *)(v3 + 136) = v30;
  *(_QWORD *)(v3 + 144) = v29;
  *(_QWORD *)(v3 + 160) = v31;
  *(_QWORD *)(v3 + 208) = v32;
  *(_QWORD *)(v3 + 216) = v33;
  *(_QWORD *)(v3 + 224) = v34;
  if (v5 >= 1)
  {
    bzero(v6, v5);
    TIFFErrorExtR(v7, "LZWDecode", "Not enough data at scanline %u (short %llu bytes)", v76, v77, v78, v79, v80, *(_DWORD *)(v7 + 876));
    return 0;
  }
  return 1;
}

uint64_t LZWSetupEncode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v17;

  v8 = a1[137];
  if (!v8)
    LZWSetupEncode_cold_1();
  v10 = _TIFFmallocExt(a1, 144016, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)(v8 + 288) = v10;
  if (v10)
    return 1;
  TIFFErrorExtR((uint64_t)a1, "LZWSetupEncode", "No space for LZW hash table", v11, v12, v13, v14, v15, v17);
  return 0;
}

uint64_t LZWPreEncode(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  v1 = *(_QWORD *)(a1 + 1096);
  if (!v1)
    LZWPreEncode_cold_1();
  v3 = *(_QWORD **)(v1 + 288);
  if (!v3)
  {
    (*(void (**)(uint64_t))(a1 + 976))(a1);
    v3 = *(_QWORD **)(v1 + 288);
  }
  *(_DWORD *)(v1 + 128) = 33488905;
  *(_WORD *)(v1 + 132) = 258;
  *(_QWORD *)(v1 + 136) = 0;
  *(_QWORD *)(v1 + 144) = 0;
  *(_QWORD *)(v1 + 248) = 10000;
  *(_QWORD *)(v1 + 256) = 0;
  *(_QWORD *)(v1 + 264) = 0;
  *(_QWORD *)(v1 + 272) = 0;
  *(_QWORD *)(v1 + 280) = *(_QWORD *)(a1 + 1120) + *(_QWORD *)(a1 + 1128) - 5;
  v4 = 9001;
  v5 = 17986;
  do
  {
    v6 = &v3[v5];
    *v6 = -1;
    v6[2] = -1;
    v6[4] = -1;
    v6[6] = -1;
    v6[8] = -1;
    v6[10] = -1;
    v6[12] = -1;
    v4 -= 8;
    v5 -= 16;
    v6[14] = -1;
  }
  while (v4 > 7);
  *v3 = -1;
  *(_DWORD *)(v1 + 244) = 0xFFFF;
  return 1;
}

uint64_t LZWPostEncode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  _BYTE *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  uint64_t v26;

  v9 = a1[137];
  v10 = (_BYTE *)a1[144];
  v11 = *(_QWORD *)(v9 + 136);
  v12 = *(_QWORD *)(v9 + 144);
  v13 = *(unsigned __int16 *)(v9 + 128);
  if ((unint64_t)v10 > *(_QWORD *)(v9 + 280))
  {
    a1[145] = &v10[-a1[140]];
    result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
    v10 = (_BYTE *)a1[140];
  }
  v15 = *(int *)(v9 + 244);
  if ((_DWORD)v15 != 0xFFFF)
  {
    v16 = *(unsigned __int16 *)(v9 + 132);
    v11 = (v11 << v13) | v15;
    v17 = v12 + v13;
    v12 = v12 + v13 - 8;
    *v10 = v11 >> v12;
    v18 = v17 < 16;
    v19 = v17 - 16;
    if (v18)
    {
      ++v10;
    }
    else
    {
      v10[1] = v11 >> v19;
      v10 += 2;
      v12 = v19;
    }
    *(_DWORD *)(v9 + 244) = 0xFFFF;
    if (v16 == 4093)
    {
      v11 = (v11 << v13) | 0x100;
      v20 = v12 + v13;
      v12 = v12 + v13 - 8;
      *v10 = v11 >> v12;
      v18 = v20 < 16;
      v21 = v20 - 16;
      if (v18)
      {
        LODWORD(v13) = 9;
        ++v10;
      }
      else
      {
        v10[1] = v11 >> v21;
        v10 += 2;
        LODWORD(v13) = 9;
        v12 = v21;
      }
    }
    else if (v16 >= *(unsigned __int16 *)(v9 + 130))
    {
      if (v13 >= 0xC)
        LZWPostEncode_cold_1();
      LODWORD(v13) = v13 + 1;
    }
  }
  v22 = (v11 << v13) | 0x101;
  v23 = v12 + v13;
  v24 = v23 - 8;
  *v10 = v22 >> (v23 - 8);
  v25 = v10 + 1;
  v18 = v23 < 16;
  v26 = v23 - 16;
  if (!v18)
  {
    v25 = v10 + 2;
    v10[1] = v22 >> v26;
    v24 = v26;
  }
  if (v24 >= 1)
    *v25++ = v22 << (8 - v24);
  a1[145] = &v25[-a1[140]];
  return 1;
}

uint64_t LZWEncode(_QWORD *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t result;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t j;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t i;
  _QWORD *v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;

  v3 = a1[137];
  if (!v3)
    return 0;
  if (!*(_QWORD *)(v3 + 288))
    LZWEncode_cold_1();
  v6 = a1;
  v8 = *(_QWORD *)(v3 + 264);
  v7 = *(_QWORD *)(v3 + 272);
  v9 = *(_QWORD *)(v3 + 248);
  v11 = *(_QWORD *)(v3 + 136);
  v10 = *(_QWORD *)(v3 + 144);
  v12 = *(unsigned __int16 *)(v3 + 132);
  v13 = *(unsigned __int16 *)(v3 + 130);
  v14 = *(unsigned __int16 *)(v3 + 128);
  v15 = (_BYTE *)v6[144];
  v16 = *(_QWORD *)(v3 + 280);
  v17 = *(unsigned __int16 *)(v3 + 244);
  if (a3 >= 1 && (_DWORD)v17 == 0xFFFF)
  {
    v18 = *(_QWORD *)(v3 + 264);
    v11 = (v11 << v14) | 0x100;
    v19 = v10 + *(unsigned __int16 *)(v3 + 128);
    v10 = v19 - 8;
    *v15 = v11 >> (v19 - 8);
    v20 = v19 < 16;
    v21 = v19 - 16;
    if (v20)
    {
      ++v15;
    }
    else
    {
      v15[1] = v11 >> v21;
      v15 += 2;
      v10 = v21;
    }
    v7 += v14;
    v23 = *a2++;
    v17 = v23;
    v8 = v18 + 1;
    --a3;
  }
  if (a3 >= 1)
  {
    v24 = v14;
    while (1)
    {
      v25 = 0;
      v26 = *(_QWORD *)(v3 + 288);
      v27 = (v8 << 8) + 256;
      v28 = 1;
      v29 = v17;
      while (1)
      {
        v17 = a2[v25];
        v30 = v29 + (v17 << 12);
        v31 = (unsigned __int16)v29 ^ (32 * v17);
        v32 = *(_QWORD *)(v26 + 16 * v31);
        if (v32 != v30)
          break;
        v29 = *(unsigned __int16 *)(v26 + 16 * v31 + 8);
        ++v25;
        v27 += 256;
        --v28;
        if ((unint64_t)(a3 + v28) <= 1)
        {
          v52 = v8 + v25;
          LODWORD(v17) = v29;
          goto LABEL_53;
        }
      }
      v63 = v8 + v25;
      v64 = v8 + v25 + 1;
      if ((v32 & 0x8000000000000000) == 0)
      {
        v33 = v31 - 9001;
        if (!(_DWORD)v31)
          v33 = -1;
        v34 = (unsigned __int16)v29 ^ (32 * v17);
        while (1)
        {
          v34 += v33 + (v34 + v33 < 0 ? 0x2329 : 0);
          v31 = v34;
          v35 = *(_QWORD *)(v26 + 16 * v34);
          if (v35 == v30)
            break;
          if (v35 < 0)
            goto LABEL_22;
        }
        v17 = *(unsigned __int16 *)(v26 + 16 * v34 + 8);
        v52 = v8 + v25 + 1;
        goto LABEL_47;
      }
LABEL_22:
      if ((unint64_t)v15 > v16)
      {
        v54 = v8;
        v55 = v24;
        v56 = v7;
        v57 = v13;
        v58 = v10;
        v59 = v16;
        v60 = v9;
        v61 = v11;
        v62 = v3;
        v6[145] = &v15[-v6[140]];
        v53 = v6;
        result = TIFFFlushData1((uint64_t)v6, v16, v10, 4294958295, v7, 9001, 10001, 0x7FFFFFLL);
        if (!(_DWORD)result)
          return result;
        v6 = v53;
        v8 = v54;
        v15 = (_BYTE *)v53[140];
        v11 = v61;
        v3 = v62;
        v16 = v59;
        v9 = v60;
        v10 = v58;
        v13 = v57;
        v7 = v56;
        v24 = v55;
      }
      v11 = (v11 << v24) | v29;
      v36 = v10 + (int)v24;
      v10 = v36 - 8;
      *v15 = v11 >> (v36 - 8);
      v37 = v8;
      v20 = v36 < 16;
      v38 = v36 - 16;
      if (v20)
      {
        ++v15;
      }
      else
      {
        v15[1] = v11 >> v38;
        v15 += 2;
        v10 = v38;
      }
      v39 = (int)v24;
      *(_WORD *)(v26 + 16 * v31 + 8) = v12;
      *(_QWORD *)(v26 + 16 * v31) = v30;
      v40 = v24;
      if (v12 == 4093)
        break;
      v7 += (int)v24;
      if (v12 >= v13)
      {
        v52 = v64;
        if ((int)v24 >= 12)
          LZWEncode_cold_2();
        v13 = ~(-1 << (v24 + 1));
        ++v12;
        v24 = (v24 + 1);
        goto LABEL_47;
      }
      v52 = v64;
      if (v64 >= v9)
      {
        if (v63 < 0x7FFFFF)
        {
          v47 = v27 / v7;
        }
        else if ((unint64_t)v7 >= 0x100)
        {
          v47 = v64 / (v7 >> 8);
        }
        else
        {
          v47 = 0x7FFFFFFFLL;
        }
        v9 = v37 + v25 + 10001;
        if (v47 <= *(_QWORD *)(v3 + 256))
        {
          v41 = *(_QWORD **)(v3 + 288);
          v49 = 17986;
          for (i = 9001; i > 7; i -= 8)
          {
            v51 = &v41[v49];
            *v51 = -1;
            v51[2] = -1;
            v51[4] = -1;
            v51[6] = -1;
            v51[8] = -1;
            v51[10] = -1;
            v51[12] = -1;
            v49 -= 16;
            v51[14] = -1;
          }
          goto LABEL_31;
        }
        *(_QWORD *)(v3 + 256) = v47;
        ++v12;
      }
      else
      {
        ++v12;
      }
LABEL_47:
      v48 = a3 - v25;
      a3 = a3 - v25 - 1;
      a2 += v25 + 1;
      v8 = v52;
      if (v48 <= 1)
        goto LABEL_53;
    }
    v41 = *(_QWORD **)(v3 + 288);
    v42 = 17986;
    for (j = 9001; j > 7; j -= 8)
    {
      v44 = &v41[v42];
      *v44 = -1;
      v44[2] = -1;
      v44[4] = -1;
      v44[6] = -1;
      v44[8] = -1;
      v44[10] = -1;
      v44[12] = -1;
      v42 -= 16;
      v44[14] = -1;
    }
LABEL_31:
    *v41 = -1;
    *(_QWORD *)(v3 + 256) = 0;
    v11 = (v11 << v40) | 0x100;
    v45 = v10 + v39;
    v10 = v10 + v39 - 8;
    *v15 = v11 >> v10;
    v52 = 0;
    v20 = v45 < 16;
    v46 = v45 - 16;
    if (v20)
    {
      v24 = 9;
      v13 = 511;
      v12 = 258;
      v7 = v39;
      ++v15;
    }
    else
    {
      v15[1] = v11 >> v46;
      v15 += 2;
      v24 = 9;
      v13 = 511;
      v12 = 258;
      v7 = v39;
      v10 = v46;
    }
    goto LABEL_47;
  }
  LOWORD(v24) = v14;
  v52 = v8;
LABEL_53:
  *(_QWORD *)(v3 + 264) = v52;
  *(_QWORD *)(v3 + 272) = v7;
  *(_QWORD *)(v3 + 248) = v9;
  *(_DWORD *)(v3 + 244) = v17;
  *(_QWORD *)(v3 + 136) = v11;
  *(_QWORD *)(v3 + 144) = v10;
  *(_WORD *)(v3 + 132) = v12;
  *(_WORD *)(v3 + 130) = v13;
  *(_WORD *)(v3 + 128) = v24;
  result = 1;
  v6[144] = v15;
  return result;
}

uint64_t LZWCleanup(_QWORD *a1)
{
  uint64_t v2;

  TIFFPredictorCleanup(a1);
  v2 = a1[137];
  if (!v2)
    LZWCleanup_cold_1();
  if (*(_QWORD *)(v2 + 232))
  {
    _TIFFfreeExt((uint64_t)a1, *(char **)(v2 + 232));
    v2 = a1[137];
  }
  if (*(_QWORD *)(v2 + 288))
  {
    _TIFFfreeExt((uint64_t)a1, *(char **)(v2 + 288));
    v2 = a1[137];
  }
  _TIFFfreeExt((uint64_t)a1, (char *)v2);
  a1[137] = 0;
  return _TIFFSetDefaultCompressionState((uint64_t)a1);
}

uint64_t LZWDecodeCompat(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int16 v29;
  int v30;
  unint64_t v31;
  uint64_t v32;
  char *v33;
  unint64_t v34;
  int v35;
  unint64_t v36;
  uint64_t v37;
  _BYTE *v38;
  _BYTE *v39;
  unint64_t v40;
  _BYTE *v41;
  BOOL v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v8 = *(_QWORD *)(a1 + 1096);
  if (!v8)
    LZWDecodeCompat_cold_1();
  v9 = a3;
  v10 = a2;
  v11 = *(_QWORD *)(v8 + 168);
  if (!v11)
    goto LABEL_13;
  v12 = *(uint64_t **)(v8 + 200);
  v13 = *((unsigned __int16 *)v12 + 4) - v11;
  v14 = a3 - v13;
  if (a3 >= v13)
  {
    v16 = *((unsigned __int16 *)v12 + 4) - v11;
    do
    {
      a2[v16 - 1] = *((_BYTE *)v12 + 11);
      v12 = (uint64_t *)*v12;
      --v16;
    }
    while (v16);
    *(_QWORD *)(v8 + 168) = 0;
    v10 = &a2[v13];
  }
  else
  {
    *(_QWORD *)(v8 + 168) = v11 + a3;
    v15 = v13;
    do
    {
      v12 = (uint64_t *)*v12;
      --v15;
    }
    while (v15 > a3);
    v14 = a3;
    do
    {
      a2[v14 - 1] = *((_BYTE *)v12 + 11);
      v12 = (uint64_t *)*v12;
      --v14;
    }
    while (v14);
  }
  v9 = v14;
  if (a3 >= v13)
  {
LABEL_13:
    v17 = *(unsigned __int8 **)(a1 + 1152);
    v18 = *(_QWORD *)(v8 + 176) + 8 * (*(_QWORD *)(a1 + 1160) - *(_QWORD *)(v8 + 184));
    *(_QWORD *)(v8 + 176) = v18;
    LODWORD(v19) = *(unsigned __int16 *)(v8 + 128);
    v21 = *(_QWORD *)(v8 + 136);
    v20 = *(_QWORD *)(v8 + 144);
    v22 = *(_QWORD *)(v8 + 160);
    v23 = *(_QWORD *)(v8 + 208);
    v24 = *(char **)(v8 + 216);
    v25 = *(_QWORD *)(v8 + 224);
    if (v9 >= 1)
    {
      v52 = a1;
      while (1)
      {
        if (v18 < v19)
        {
          v49 = v25;
          v51 = v22;
          TIFFWarningExtR(v52, "LZWDecodeCompat", "LZWDecode: Strip %u not terminated with EOI code", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 884));
          v22 = v51;
          a1 = v52;
          v25 = v49;
          goto LABEL_53;
        }
        v26 = ((unint64_t)*v17 << v20) | v21;
        v27 = v20 + 8;
        if (v20 + 8 >= v19)
        {
          ++v17;
        }
        else
        {
          v28 = v17[1];
          v17 += 2;
          v26 |= v28 << v27;
          v27 = v20 + 16;
        }
        v29 = v26 & v22;
        v21 = v26 >> v19;
        v20 = v27 - v19;
        v18 -= v19;
        v30 = v26 & (unsigned __int16)v22;
        if (v30 == 256)
          break;
        if (v30 == 257)
          goto LABEL_53;
        v31 = *(_QWORD *)(v8 + 232);
        if ((unint64_t)v24 < v31
          || (unint64_t)v24 >= v31 + 81904
          || (*(_QWORD *)v24 = v23, v23 < v31)
          || v23 >= v31 + 81904)
        {
          TIFFErrorExtR(a1, "LZWDecodeCompat", "Corrupted LZW table at scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
          return 0;
        }
        v32 = v29;
        v24[10] = *(_BYTE *)(v23 + 10);
        v33 = v24 + 10;
        v34 = v31 + 16 * v29;
        *((_WORD *)v24 + 4) = *(_WORD *)(v23 + 8) + 1;
        if (v34 < (unint64_t)v24)
          v33 = (char *)(v31 + 16 * v29 + 10);
        v24[11] = *v33;
        v24 += 16;
        if ((unint64_t)v24 > v25)
        {
          if ((int)v19 >= 11)
            v35 = 11;
          else
            v35 = v19;
          LODWORD(v19) = v35 + 1;
          v22 = ~(-1 << (v35 + 1));
          v25 = v31 + 16 * v22;
        }
        if ((v29 & 0xFF00) != 0)
        {
          v36 = *(unsigned __int16 *)(v31 + 16 * v29 + 8);
          if (!*(_WORD *)(v31 + 16 * v32 + 8))
          {
            TIFFErrorExtR(a1, "LZWDecodeCompat", "Wrong length of decoded string: data probably corrupted at scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
            return 0;
          }
          v37 = v9 - v36;
          if (v9 < v36)
          {
            *(_QWORD *)(v8 + 200) = v34;
            v50 = v34;
            do
              v50 = *(_QWORD *)v50;
            while (*(unsigned __int16 *)(v50 + 8) > (unsigned __int16)v9);
            *(_QWORD *)(v8 + 168) = v9;
            do
            {
              v10[v9 - 1] = *(_BYTE *)(v50 + 11);
              v50 = *(_QWORD *)v50;
              --v9;
            }
            while (v9);
            goto LABEL_55;
          }
          v38 = &v10[v36];
          v39 = v38 - 1;
          v40 = v34;
          v41 = v38 - 1;
          do
          {
            *v41-- = *(_BYTE *)(v40 + 11);
            v40 = *(_QWORD *)v40;
            if (v40)
              v42 = v39 > v10;
            else
              v42 = 0;
            v39 = v41;
          }
          while (v42);
          v9 = v37;
        }
        else
        {
          *v10 = v29;
          --v9;
          v38 = v10 + 1;
        }
LABEL_50:
        v23 = v34;
        v10 = v38;
        if (v9 <= 0)
          goto LABEL_55;
      }
      do
      {
        v24 = (char *)(*(_QWORD *)(v8 + 232) + 4128);
        _TIFFmemset(v24, 0, 0x12FD0uLL);
        if (v18 <= 8)
        {
          v19 = *(_QWORD *)(v8 + 232) + 8176;
          TIFFWarningExtR(v52, "LZWDecodeCompat", "LZWDecode: Strip %u not terminated with EOI code", a4, a5, a6, a7, a8, *(_DWORD *)(v52 + 884));
          v25 = v19;
          a1 = v52;
          LOWORD(v19) = 9;
          v22 = 511;
          goto LABEL_53;
        }
        v43 = ((unint64_t)*v17 << v20) | v21;
        v44 = v20 + 8;
        if (v20 <= 0)
        {
          v45 = v17[1];
          v17 += 2;
          v43 |= v45 << v44;
          v44 = v20 + 16;
        }
        else
        {
          ++v17;
        }
        v46 = v43 & 0x1FF;
        v21 = v43 >> 9;
        v20 = v44 - 9;
        v18 -= 9;
      }
      while (v46 == 256);
      if (v46 == 257)
      {
        v25 = *(_QWORD *)(v8 + 232) + 8176;
        LOWORD(v19) = 9;
        v22 = 511;
        v34 = v23;
        a1 = v52;
        goto LABEL_55;
      }
      a1 = v52;
      if (v46 < 0x101)
      {
        v25 = *(_QWORD *)(v8 + 232) + 8176;
        *v10 = v43;
        --v9;
        v34 = *(_QWORD *)(v8 + 232) + 16 * (v43 & 0x1FF);
        LODWORD(v19) = 9;
        v38 = v10 + 1;
        v22 = 511;
        goto LABEL_50;
      }
      TIFFErrorExtR(v52, *(const char **)v52, "LZWDecode: Corrupted LZW table at scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(v52 + 876));
      return 0;
    }
LABEL_53:
    v34 = v23;
LABEL_55:
    v47 = *(_QWORD *)(a1 + 1152) - (_QWORD)v17 + *(_QWORD *)(a1 + 1160);
    *(_QWORD *)(a1 + 1160) = v47;
    *(_QWORD *)(a1 + 1152) = v17;
    *(_QWORD *)(v8 + 176) = v18;
    *(_QWORD *)(v8 + 184) = v47;
    *(_WORD *)(v8 + 128) = v19;
    *(_QWORD *)(v8 + 136) = v21;
    *(_QWORD *)(v8 + 144) = v20;
    *(_QWORD *)(v8 + 160) = v22;
    *(_QWORD *)(v8 + 208) = v34;
    *(_QWORD *)(v8 + 216) = v24;
    *(_QWORD *)(v8 + 224) = v25;
    if (v9 >= 1)
    {
      TIFFErrorExtR(a1, "LZWDecodeCompat", "Not enough data at scanline %u (short %llu bytes)", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
      return 0;
    }
  }
  return 1;
}

void PSDWritePlugin::~PSDWritePlugin(PSDWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t PSDWritePlugin::writeLayerMaskBlock8bit(IIOImageWriteSession **this, uint64_t (**a2)(IIOImagePixelDataProvider *, void *), uint64_t a3, unint64_t a4, PSDWritePlugin *size, __int16 a6, unint64_t a7, int a8)
{
  char *v14;
  char *v15;
  char *v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  char *v20;
  int v21;
  PSDWritePlugin *Bytes;
  unint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  unint64_t v26;
  unsigned int v27;
  const unsigned __int8 *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unint64_t v42;
  unsigned int v43;
  unsigned __int8 *v44;
  size_t v45;
  uint64_t v46;
  PSDWritePlugin *v48;
  unsigned __int8 *v49;
  uint64_t v50;
  char *v51;
  unsigned __int8 *v54;
  uint64_t __nitems;
  unint64_t v56;
  char *v57;
  unint64_t v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  int8x16_t v66;
  int8x8_t __ptr;
  __int16 v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;
  uint64_t v72;
  __int16 v73;
  unsigned int v74;
  __int16 v75;
  unsigned int v76;
  __int16 v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v14 = (char *)malloc_type_malloc((size_t)size, 0xA6E3977CuLL);
  v66 = 0uLL;
  v78 = 0x4D49423800000000;
  v80 = 255;
  v82 = gExtraData8bit[0];
  __ptr = 0;
  v74 = 0;
  v76 = 0;
  v68 = -1;
  v69 = 0;
  v70 = bswap32(a4);
  v71 = bswap32(a3);
  v72 = 4294902784;
  v73 = 0;
  v77 = 512;
  v79 = 1836216174;
  v81 = 805306368;
  v75 = 256;
  v83 = unk_18822DD97;
  v84 = xmmword_18822DDA7;
  v61 = 256;
  v64 = 0u;
  v65 = 0u;
  __nitems = 2 * a4;
  v62 = 0u;
  v63 = 0u;
  v15 = (char *)malloc_type_malloc(2 * a4 * a7, 0x321DFE19uLL);
  if (v15 && (v59 = a6, (v16 = (char *)malloc_type_malloc(a3 + a4 * a3 * a7, 0x34A1057uLL)) != 0))
  {
    if (a8)
      v17 = -1;
    else
      v17 = 0;
    v66 = vbslq_s8((int8x16_t)vdupq_n_s32(v17), (int8x16_t)xmmword_18820BF90, (int8x16_t)xmmword_18822DD60);
    v54 = (unsigned __int8 *)v16;
    v56 = a4 * a3;
    if (a4)
    {
      v50 = a3;
      v51 = v15;
      v48 = (PSDWritePlugin *)this;
      v18 = 0;
      v19 = 0;
      v49 = (unsigned __int8 *)&v16[a3 + a4 * a3 * a7];
      v57 = v14;
      v58 = a7;
      v20 = v15;
      v21 = v59;
      do
      {
        Bytes = (PSDWritePlugin *)IIOImagePixelDataProvider::getBytes(a2, v14);
        if (Bytes != size)
          break;
        v23 = a4;
        v25 = v49;
        v24 = v50;
        if (a7)
        {
          v26 = 0;
          v27 = 1;
          v60 = v18;
          do
          {
            v28 = (const unsigned __int8 *)&v14[v66.i32[v26]];
            v29 = *((_QWORD *)&v62 + v26);
            v30 = v24;
            v31 = v25;
            v32 = v23;
            Bytes = (PSDWritePlugin *)PSDWritePlugin::PackBits(Bytes, v28, v21, v24, &v54[v26 * v56 + v29], v25, 0);
            v25 = v31;
            v24 = v30;
            v23 = v32;
            a7 = v58;
            *(_WORD *)&v20[2 * v60 + 2 * v26 * v32] = __rev16(Bytes);
            v33 = v29 + Bytes;
            v14 = v57;
            *((_QWORD *)&v62 + v26) = v33;
            v26 = v27++;
          }
          while (v26 < v58);
        }
        v18 = ++v19;
        a4 = v23;
      }
      while (v19 < v23);
      v34 = DWORD2(v62);
      v35 = v62;
      v36 = DWORD2(v63);
      v37 = v63;
      this = (IIOImageWriteSession **)v48;
      v15 = v51;
    }
    else
    {
      v36 = 0;
      v37 = 0;
      v34 = 0;
      v35 = 0;
    }
    v38 = __nitems + 2 + v35;
    v39 = __nitems + 2 + v34;
    v40 = __nitems + 2 + v37;
    v41 = __nitems + 2 + v36;
    HIDWORD(v72) = bswap32(v38);
    v74 = bswap32(v39);
    v76 = bswap32(v40);
    LODWORD(v78) = bswap32(v41);
    __ptr = vrev32_s8((int8x8_t)vadd_s32(vdup_n_s32(v39 + v38 + v40 + v41), (int32x2_t)0x6C00000070));
    IIOImageWriteSession::putBytes(this[2], &__ptr, 0x74uLL);
    if (!a7)
    {
      v46 = 0;
      v44 = v54;
      if (!v14)
        goto LABEL_25;
      goto LABEL_24;
    }
    v42 = 0;
    v43 = 1;
    v44 = v54;
    while (IIOImageWriteSession::putBytes(this[2], &v61, 2uLL) == 2)
    {
      if (IIOImageWriteSession::putBytes(this[2], &v15[2 * v42 * a4], __nitems) != __nitems)
        break;
      v45 = *((_QWORD *)&v62 + v42);
      if (IIOImageWriteSession::putBytes(this[2], &v54[v42 * v56], v45) != v45)
        break;
      v42 = v43++;
      if (v42 >= a7)
      {
        v46 = 0;
        if (v14)
          goto LABEL_24;
        goto LABEL_25;
      }
    }
  }
  else
  {
    v44 = 0;
  }
  v46 = 4294967246;
  if (v14)
LABEL_24:
    free(v14);
LABEL_25:
  if (v44)
    free(v44);
  if (v15)
    free(v15);
  return v46;
}

uint64_t PSDWritePlugin::PackBits(PSDWritePlugin *this, const unsigned __int8 *a2, int a3, uint64_t a4, unsigned __int8 *a5, unsigned __int8 *a6, int a7)
{
  unsigned __int8 *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  const unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  LOWORD(v7) = (_WORD)a5;
  if (a4 >= 1)
  {
    v8 = a7 << 31 >> 31;
    v9 = a3;
    v10 = 2 * a3;
    v7 = a5;
    do
    {
      v11 = 0;
      v12 = 1;
      v13 = 1;
      v14 = a2;
      while (1)
      {
        if (a4 + v11 >= 3)
        {
          v15 = *v14;
          if (v14[v9] == v15 && v14[v10] == v15)
            break;
        }
        v14 += v9;
        v13 = v12 < a4;
        --v11;
        ++v12;
        if (!(a4 + v11))
        {
          v16 = a4;
          goto LABEL_9;
        }
      }
      if (!v11)
        goto LABEL_19;
      v16 = -v11;
      do
      {
LABEL_9:
        if (v16 >= 127)
          v17 = 127;
        else
          v17 = v16;
        a4 -= v17;
        if (v7 >= a6)
          break;
        *v7++ = v17 - 1;
        if (v16 >= 1 && v7 < a6)
        {
          v18 = v17;
          do
          {
            *v7++ = *a2 ^ v8;
            a2 += v9;
            if (v18 <= 1)
              break;
            --v18;
          }
          while (v7 < a6);
        }
        v16 -= v17;
      }
      while (v16 >= 1);
LABEL_19:
      if (v13)
      {
        v19 = *a2;
        a2 += v9;
        if (a4 < 2)
        {
          v21 = 1;
        }
        else
        {
          if ((unint64_t)(a4 - 2) >= 0x7D)
            v20 = 125;
          else
            v20 = a4 - 2;
          v21 = v20 + 2;
          v22 = -1;
          while (*a2 == v19)
          {
            a2 += v9;
            if (v20 == ++v22)
              goto LABEL_32;
          }
          v21 = v22 + 2;
        }
LABEL_32:
        if (v7 >= a6)
          return (unsigned __int16)((_WORD)v7 - (_WORD)a5);
        *v7 = 1 - v21;
        if (v7 + 1 >= a6)
        {
          LOWORD(v7) = (_WORD)v7 + 1;
          return (unsigned __int16)((_WORD)v7 - (_WORD)a5);
        }
        v7[1] = v19 ^ v8;
        v7 += 2;
        a4 -= v21;
      }
    }
    while (a4 > 0);
  }
  return (unsigned __int16)((_WORD)v7 - (_WORD)a5);
}

uint64_t PSDWritePlugin::writeLayerMaskBlock16bit(IIOImageWriteSession **this, uint64_t (**a2)(IIOImagePixelDataProvider *, void *), unint64_t a3, unint64_t a4, size_t size, unint64_t a6, unint64_t a7, unsigned int a8)
{
  char *v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  unsigned int v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  __int16 v32;
  __int16 v33;
  __int16 v34;
  __int16 v35;
  unint64_t v36;
  unint64_t v37;
  unsigned int v38;
  unint64_t v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unint64_t v45;
  unsigned int v46;
  unsigned __int8 *v47;
  size_t v48;
  uint64_t v49;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  unint64_t v55;
  char *v58;
  int v59;
  __int16 v60;
  unint64_t v61;
  uint64_t __ptr;
  int v63;
  __int128 v64;
  int v65;
  unsigned int v66;
  __int16 v67;
  uint64_t v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  __int16 v72;
  unsigned int v73;
  __int16 v74;
  unsigned int v75;
  __int16 v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v13 = (char *)malloc_type_malloc(size, 0x491520AFuLL);
  v89 = 0u;
  v90 = 0u;
  v87 = 0u;
  v88 = 0u;
  v63 = 0;
  v65 = 909210188;
  v59 = 0;
  __ptr = 0;
  v73 = 0;
  v75 = 0;
  v64 = xmmword_18822DD70;
  v66 = 0;
  v67 = 256;
  v68 = 0;
  v69 = bswap32(a4);
  v70 = bswap32(a3);
  v71 = 4294902784;
  v72 = 0;
  v74 = 256;
  v76 = 512;
  v77 = 0x4D49423800000000;
  v78 = 1836216174;
  v79 = 524543;
  v80 = 1476395008;
  v86 = 0x310020007200;
  v83 = xmmword_18822DDD7;
  v84 = unk_18822DDE7;
  v85 = xmmword_18822DDF7;
  v14 = 2 * a4 * a3;
  v82 = unk_18822DDC7;
  v81 = gExtraData16bit;
  v60 = 768;
  v15 = (unsigned __int8 *)malloc_type_malloc(v14 * a7 + v14, 0x9EFD133FuLL);
  v16 = v15;
  if (v15)
  {
    v58 = v13;
    v61 = 0;
    if (a8)
      v17 = 0;
    else
      v17 = 3;
    v18 = 1;
    if (a8)
      v18 = 2;
    v19 = 2;
    if (a8)
      v19 = 3;
    v55 = a4;
    if (a4)
    {
      LODWORD(v20) = 0;
      v21 = a8;
      v22 = (char *)&v15[8 * a4 * a3];
      v23 = (char *)&v15[6 * a4 * a3];
      v24 = (char *)&v15[4 * a4 * a3];
      v25 = (char *)&v15[v14];
      v54 = &v58[2 * v17];
      v52 = &v58[2 * v18];
      v53 = &v58[2 * v21];
      v51 = &v58[2 * v19];
      do
      {
        if (IIOImagePixelDataProvider::getBytes(a2, v58) != size)
          break;
        if (a3)
        {
          v26 = 0;
          v27 = 1;
          v28 = v51;
          v29 = v52;
          v30 = v53;
          v31 = v54;
          do
          {
            v32 = *(_WORD *)v31;
            v31 += 8;
            *(_WORD *)&v25[v26] = v32;
            v33 = *(_WORD *)v30;
            v30 += 8;
            *(_WORD *)&v24[v26] = v33;
            v34 = *(_WORD *)v29;
            v29 += 8;
            *(_WORD *)&v23[v26] = v34;
            v35 = *(_WORD *)v28;
            v28 += 8;
            *(_WORD *)&v22[v26] = v35;
            v36 = v27;
            v26 += 2;
            ++v27;
          }
          while (v36 < a3);
          v22 += v26;
          v23 += v26;
          v24 += v26;
          v25 += v26;
        }
        v20 = (v20 + 1);
      }
      while (v20 < v55);
    }
    if (a7)
    {
      v37 = 0;
      v38 = 1;
      do
      {
        v39 = v38;
        v61 = v14;
        PSDWritePlugin::zipWithPrediction((PSDWritePlugin *)this, &v16[v14 * v38], v14, &v16[v37 * v14], &v61, a3, 16);
        *((_QWORD *)&v87 + v37) = v61;
        ++v38;
        v37 = v39;
      }
      while (v39 < a7);
      v40 = v87 + 2;
      v41 = DWORD2(v87) + 2;
      v42 = v88 + 2;
      v43 = DWORD2(v88) + 2;
    }
    else
    {
      v43 = 2;
      v42 = 2;
      v41 = 2;
      v40 = 2;
    }
    HIDWORD(v71) = bswap32(v40);
    v73 = bswap32(v41);
    v75 = bswap32(v42);
    LODWORD(v77) = bswap32(v43);
    v44 = v41 + v43 + v40 + v42;
    LODWORD(__ptr) = bswap32((v44 & 0xFFFFFFFC) + 184);
    v66 = bswap32((v44 & 0xFFFFFFFC) + 152);
    IIOImageWriteSession::putBytes(this[2], &__ptr, 0xB8uLL);
    if (a7)
    {
      v45 = 0;
      v46 = 1;
      while (IIOImageWriteSession::putBytes(this[2], &v60, 2uLL) == 2)
      {
        v47 = &v16[v45 * v14];
        v48 = *((_QWORD *)&v87 + v45);
        if (IIOImageWriteSession::putBytes(this[2], v47, v48) != v48)
          break;
        v45 = v46++;
        if (v45 >= a7)
          goto LABEL_27;
      }
      v49 = 4294967246;
    }
    else
    {
LABEL_27:
      v59 = 0;
      IIOImageWriteSession::putBytes(this[2], &v59, 4 - (v44 & 3));
      v49 = 0;
    }
    v13 = v58;
    if (v58)
      goto LABEL_29;
  }
  else
  {
    v49 = 4294967246;
    if (v13)
LABEL_29:
      free(v13);
  }
  if (v16)
    free(v16);
  return v49;
}

uint64_t PSDWritePlugin::zipWithPrediction(PSDWritePlugin *this, unsigned __int8 *a2, uint64_t a3, unsigned __int8 *a4, unint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  unsigned __int8 *v12;
  __int16 v13;
  unsigned __int8 v14;
  char v15;
  uint64_t v16;
  uint64_t i;

  v7 = 2 * a6 - 2;
  v8 = a2;
  v9 = a3;
  do
  {
    if (a7 == 16)
    {
      if (a6 != 1)
      {
        v10 = &v8[v7];
        v11 = a6 - 1;
        v12 = &v8[v7];
        do
        {
          v13 = *(v10 - 1);
          v14 = v10[1] - v13;
          v10[1] = v14;
          this = (PSDWritePlugin *)*v10;
          v15 = *(v12 - 2);
          v12 -= 2;
          *v10 = (_BYTE)this - ((unsigned __int16)(v13 + v14) >> 8) - v15;
          v10 = v12;
          --v11;
        }
        while (v11);
        v8 += v7;
      }
      v8 += 2;
      v16 = 2 * a6;
    }
    else
    {
      if (a6 != 1)
      {
        for (i = a6; i != 1; --i)
          v8[i - 1] -= v8[i - 2];
        v8 += a6 - 1;
      }
      ++v8;
      v16 = a6;
    }
    v9 -= v16;
  }
  while (v9 > 0);
  return PSDWritePlugin::zipWithoutPrediction(this, a2, a3, a4, a5);
}

uint64_t PSDWritePlugin::zipWithoutPrediction(PSDWritePlugin *this, unsigned __int8 *a2, uInt a3, unsigned __int8 *a4, unint64_t *a5)
{
  uint64_t v6;
  unsigned int v8;
  int v9;
  z_stream v10;

  memset(&v10.avail_in, 0, 104);
  v6 = *a5;
  v10.next_in = a2;
  v10.avail_in = a3;
  v10.next_out = a4;
  v10.avail_out = v6;
  *a5 = 0;
  if (deflateInit_(&v10, -1, "1.2.12", 112))
    return 0;
  do
  {
    v9 = deflate(&v10, 1);
    if (v9 == 1)
    {
      deflateEnd(&v10);
      goto LABEL_8;
    }
    v8 = v9;
  }
  while (!v9 && v10.avail_in);
  deflateEnd(&v10);
  if (v8 > 1)
    return 0;
LABEL_8:
  *a5 = v6 - v10.avail_out;
  return 1;
}

uint64_t PSDWritePlugin::writeOneImage(PSDWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

uint64_t PSDWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  int AlphaInfo;
  CGColorSpace *SourceGeomColorSpace;
  int Type;
  CGColorSpaceModel Model;
  size_t NumberOfComponents;
  CGImage *Ref;
  CGColorRenderingIntent RenderingIntent;
  __CFData *v13;
  const __CFData *v14;
  const __CFDictionary *ObjectForKey;
  CC_LONG v16;
  CC_LONG v17;
  unsigned __int8 *v18;
  uint64_t v19;
  unsigned int v20;
  CGColorSpace *v21;
  size_t v22;
  const __CFDictionary *v23;
  const CGImageMetadata *v24;
  CFTypeID v25;
  const __CFData *XMPData;
  const CGImageMetadata *v27;
  const CGImageMetadata *v28;
  const __CFData *v29;
  unsigned int Length;
  const __CFData *v31;
  CGColorSpace *BaseColorSpace;
  __int16 v33;
  int v34;
  char *v35;
  void *v36;
  unsigned __int8 *v37;
  unint64_t v38;
  BOOL v39;
  int v40;
  _BOOL4 v42;
  CGColorSpace *v43;
  size_t v44;
  size_t ColorTableCount;
  char *v46;
  int *v47;
  char v48;
  int v49;
  unsigned int v50;
  _BOOL4 v51;
  _BOOL4 v52;
  BOOL v53;
  int v54;
  _BOOL4 v55;
  _BOOL4 v56;
  BOOL v57;
  int v58;
  unsigned int v59;
  int v60;
  unsigned int v61;
  BOOL v62;
  int v63;
  int v64;
  float FloatForKey;
  float v66;
  unsigned int v67;
  unsigned int v68;
  __CFArray *IIMHashArrayForIIMBlock;
  CFIndex i;
  const __CFNumber *ValueAtIndex;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  size_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  BOOL v89;
  uint64_t v90;
  PSDWritePlugin *Bytes;
  unsigned __int8 *v92;
  unint64_t v93;
  char *v94;
  uint64_t v95;
  unsigned int v96;
  unsigned __int8 *v97;
  BOOL v98;
  unsigned __int8 *v99;
  uint64_t v100;
  unsigned int v101;
  const unsigned __int8 *v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  unint64_t v106;
  char *v107;
  uint64_t v108;
  unsigned int v109;
  unsigned __int8 *v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  _WORD *v114;
  unsigned int v115;
  unsigned __int8 *v116;
  unint64_t v117;
  unint64_t v118;
  unsigned int v119;
  uint64_t v120;
  unint64_t v121;
  char *v122;
  unsigned int v123;
  unsigned __int8 *v124;
  uint64_t v125;
  unsigned int v126;
  size_t v127;
  int v128;
  unsigned int v129;
  const __CFData *cf;
  unsigned int appleflags;
  const UInt8 *v132;
  BOOL v133;
  __CFData *v134;
  char *v135;
  unsigned __int8 *v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  uint8_t *table;
  const UInt8 *BytePtr;
  unsigned int v142;
  IIOImagePlus *v143;
  PSDWritePlugin *size;
  unsigned int __nitems;
  unsigned __int8 *__nitemsa;
  int v148;
  _BOOL4 hasAlpha;
  int v150;
  void *v151;
  CC_LONG v152;
  size_t v153;
  unsigned int Error;
  unsigned __int8 *v155;
  unint64_t v156;
  int v157;
  unint64_t v158;
  IIODictionary *v160;
  uint64_t __ptr;
  __int128 v162;
  __int16 v163;
  unsigned int v164;
  int v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  int v169;
  unint64_t v170;
  uint64_t v171;
  uint64_t valuePtr;
  uint64_t v173;
  uint64_t v174;
  int v175;
  _OWORD v176[4];
  uint64_t v177;

  v177 = *MEMORY[0x1E0C80C00];
  v171 = 0;
  memset(v176, 0, sizeof(v176));
  v167 = 0;
  v168 = 0;
  v166 = 0;
  __ptr = 0;
  v162 = 0uLL;
  v163 = 0;
  v164 = 0;
  v165 = 1296646712;
  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  size = (PSDWritePlugin *)IIOImagePlus::sourceImageProvider(a2);
  v158 = IIOImageSource::count(a2);
  v156 = IIO_Reader::testHeaderSize(a2);
  Error = _cg_GifLastError((uint64_t)a2);
  appleflags = _cg_png_get_appleflags((uint64_t)a2);
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  Type = CGColorSpaceGetType();
  Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  NumberOfComponents = CGColorSpaceGetNumberOfComponents(SourceGeomColorSpace);
  hasAlpha = IIOImagePixelDataProvider::hasAlpha(a2);
  Ref = (CGImage *)IIOImageSource::imageReadRef(a2);
  RenderingIntent = CGImageGetRenderingIntent(Ref);
  v13 = CGColorSpaceCopyData(SourceGeomColorSpace, RenderingIntent);
  v134 = v13;
  if (v13)
  {
    v14 = v13;
    BytePtr = CFDataGetBytePtr(v13);
    __nitems = CFDataGetLength(v14);
  }
  else
  {
    BytePtr = 0;
    __nitems = 0;
  }
  v170 = 0;
  v169 = 0;
  ObjectForKey = IIODictionary::getObjectForKey(a4, CFSTR("{IPTC}"));
  v157 = AlphaInfo;
  if (ObjectForKey)
  {
    valuePtr = 0;
    v173 = 0;
    v174 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&valuePtr, ObjectForKey);
    v16 = SizeOfIPTCData((IIODictionary *)&valuePtr);
    v17 = v16;
    if (v16)
    {
      v18 = (unsigned __int8 *)malloc_type_malloc(v16, 0xCCA8E47EuLL);
      if (!v18)
      {
        _cg_jpeg_mem_term("writeOne", 1413, "*** ERRROR: could not allocate iptcData - size=%d\n", v17);
        IIODictionary::~IIODictionary((IIODictionary *)&valuePtr);
        v35 = 0;
        v37 = 0;
        v36 = 0;
        table = 0;
        v138 = -50;
        goto LABEL_150;
      }
      WriteIPTCData((CFDictionaryRef *)&valuePtr, v18);
    }
    else
    {
      v18 = 0;
    }
    IIODictionary::~IIODictionary((IIODictionary *)&valuePtr);
  }
  else
  {
    v17 = 0;
    v18 = 0;
  }
  v152 = v17;
  v136 = v18;
  v143 = a2;
  if (a2)
  {
    v19 = IIOImageSource::count(a2);
    v20 = IIO_Reader::testHeaderSize(a2);
    v21 = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  }
  else
  {
    v19 = 0;
    v20 = 0;
    v21 = 0;
  }
  v135 = CreateExifBufferFromPropertiesJPEG(a3, v19, v20, v21, 0, CFSTR("com.adobe.photoshop-image"), &v170);
  if (v170 <= 6)
    v22 = 0;
  else
    v22 = (v170 - 6);
  if (IIODictionary::getBoolForKey(a4, CFSTR("kCGImageMetadataShouldExcludeXMP")))
    goto LABEL_25;
  v23 = IIODictionary::getObjectForKey(a4, CFSTR("{MetaData}"));
  v24 = v23;
  if (v23)
  {
    v25 = CFGetTypeID(v23);
    if (v25 == CGImageMetadataGetTypeID())
    {
      XMPData = CGImageMetadataCreateXMPData(v24, 0);
      goto LABEL_23;
    }
  }
  v27 = (const CGImageMetadata *)CGImageMetadataCreateFromLegacyProps(a4);
  v28 = v27;
  if (!v27)
  {
LABEL_25:
    v29 = 0;
    goto LABEL_26;
  }
  XMPData = CGImageMetadataCreateXMPData(v27, 0);
  CFRelease(v28);
LABEL_23:
  v29 = XMPData;
  if (!XMPData)
  {
LABEL_26:
    v132 = 0;
    Length = 0;
    goto LABEL_27;
  }
  v132 = CFDataGetBytePtr(XMPData);
  Length = CFDataGetLength(XMPData);
  v29 = XMPData;
LABEL_27:
  if (Type == 7
    && (v31 = v29,
        BaseColorSpace = CGColorSpaceGetBaseColorSpace(SourceGeomColorSpace),
        Model = CGColorSpaceGetModel(BaseColorSpace),
        v29 = v31,
        Model == kCGColorSpaceModelRGB))
  {
    v148 = 0;
    v33 = 2;
    v34 = v157;
  }
  else
  {
    if (Model)
      v33 = 3;
    else
      v33 = 1;
    v34 = v157;
    if (Model < kCGColorSpaceModelCMYK)
    {
      v148 = 0;
    }
    else if (Model == kCGColorSpaceModelCMYK)
    {
      v148 = 1;
      v33 = 4;
    }
    else
    {
      if (Model != kCGColorSpaceModelLab)
        goto LABEL_62;
      v148 = 0;
      v33 = 9;
    }
  }
  if (Error != 16 && Error != 8)
  {
LABEL_62:
    table = 0;
    v36 = 0;
    v37 = 0;
    v35 = 0;
    v138 = -50;
    if (!v29)
      goto LABEL_146;
    goto LABEL_145;
  }
  v35 = 0;
  v138 = -50;
  table = 0;
  v36 = 0;
  v37 = 0;
  if (size && SourceGeomColorSpace)
  {
    cf = v29;
    v38 = NumberOfComponents + hasAlpha;
    v39 = v38 != 4 || v34 == 0;
    v40 = v39;
    v150 = v40;
    v42 = v34 == 4 || v34 == 2;
    v139 = v42;
    LODWORD(__ptr) = 1397768760;
    WORD2(__ptr) = 256;
    WORD2(v162) = bswap32(v38) >> 16;
    *(_DWORD *)((char *)&v162 + 6) = bswap32(v156);
    *(_DWORD *)((char *)&v162 + 10) = bswap32(v158);
    v137 = Error;
    HIWORD(v162) = bswap32(Error) >> 16;
    v163 = v33 << 8;
    if (IIOImageWriteSession::putBytes(this[2], &__ptr, 0x1AuLL) != 26)
    {
      table = 0;
      goto LABEL_61;
    }
    if (Type == 7)
    {
      bzero(&valuePtr, 0x304uLL);
      BYTE2(valuePtr) = 3;
      v43 = CGColorSpaceGetBaseColorSpace(SourceGeomColorSpace);
      v44 = CGColorSpaceGetNumberOfComponents(v43);
      ColorTableCount = CGColorSpaceGetColorTableCount(SourceGeomColorSpace);
      table = (uint8_t *)malloc_type_malloc(ColorTableCount * v44, 0x100004077774924uLL);
      CGColorSpaceGetColorTable(SourceGeomColorSpace, table);
      if (ColorTableCount)
      {
        v46 = (char *)(table + 2);
        v47 = &v175;
        do
        {
          *((_BYTE *)v47 - 256) = *(v46 - 2);
          *(_BYTE *)v47 = *(v46 - 1);
          v48 = *v46;
          v46 += 3;
          *((_BYTE *)v47 + 256) = v48;
          v47 = (int *)((char *)v47 + 1);
          --ColorTableCount;
        }
        while (ColorTableCount);
      }
      if (IIOImageWriteSession::putBytes(this[2], &valuePtr, 0x304uLL) != 772)
        goto LABEL_61;
    }
    else
    {
      LODWORD(valuePtr) = 0;
      v35 = 0;
      table = 0;
      if (IIOImageWriteSession::putBytes(this[2], &valuePtr, 4uLL) != 4)
      {
        v138 = -50;
        v36 = 0;
        v37 = 0;
LABEL_130:
        v29 = cf;
        if (!cf)
          goto LABEL_146;
        goto LABEL_145;
      }
    }
    if (v150)
      v49 = 28;
    else
      v49 = 54;
    v50 = v164 + v49;
    v51 = BytePtr != 0;
    v52 = __nitems != 0;
    v53 = v51 && v52;
    v39 = !v51 || !v52;
    v54 = __nitems + (__nitems & 1) + 12;
    if (v39)
      v54 = 0;
    v55 = v136 != 0;
    v56 = v152 != 0;
    v57 = v56 && v55;
    v39 = !v56 || !v55;
    v58 = v152 + (v152 & 1) + 12;
    if (v39)
      v58 = 0;
    v59 = v50 + v54 + v58;
    v60 = v22 + (v22 & 1) + 12;
    if (v135 == 0 || (_DWORD)v22 == 0)
      v60 = 0;
    v61 = v59 + v60;
    if (v132)
      v62 = Length == 0;
    else
      v62 = 1;
    v63 = !v62;
    v128 = v63;
    if (!v62)
    {
      if (v57)
        v64 = 40;
      else
        v64 = 12;
      v61 += Length + (Length & 1) + v64;
    }
    v164 = bswap32(v61);
    if (IIOImageWriteSession::putBytes(this[2], &v164, 4uLL) == 4
      && ((v150 & 1) != 0 || IIOImageWriteSession::putBytes(this[2], &gAlphaNames, 0x1AuLL) == 26))
    {
      LOWORD(v166) = -4861;
      HIDWORD(v166) = 0x10000000;
      if (IIOImageWriteSession::putBytes(this[2], &v165, 0xCuLL) == 12)
      {
        if (IIODictionary::containsKey(a3, CFSTR("DPIWidth"))
          && IIODictionary::containsKey(a3, CFSTR("DPIHeight")))
        {
          FloatForKey = IIODictionary::getFloatForKey(a3, CFSTR("DPIWidth"));
          v66 = IIODictionary::getFloatForKey(a3, CFSTR("DPIHeight"));
          v67 = (int)(float)((float)(FloatForKey * 65536.0) + 0.5);
          v68 = (int)(float)((float)(v66 * 65536.0) + 0.5);
        }
        else
        {
          v67 = 4718592;
          v68 = 4718592;
        }
        v167 = bswap32(v67) | 0x100010000000000;
        v168 = bswap32(v68) | 0x100010000000000;
        if (IIOImageWriteSession::putBytes(this[2], &v167, 0x10uLL) == 16)
        {
          if (!v53
            || (LOWORD(v166) = 3844,
                HIDWORD(v166) = bswap32(__nitems),
                IIOImageWriteSession::putBytes(this[2], &v165, 0xCuLL) == 12)
            && IIOImageWriteSession::putBytes(this[2], BytePtr, __nitems) == __nitems
            && ((__nitems & 1) == 0 || IIOImageWriteSession::putBytes(this[2], &v171, 1uLL) == 1))
          {
            if (!v57
              || (LOWORD(v166) = 1028,
                  HIDWORD(v166) = bswap32(v152),
                  IIOImageWriteSession::putBytes(this[2], &v165, 0xCuLL) == 12)
              && IIOImageWriteSession::putBytes(this[2], v136, v152) == v152
              && ((v152 & 1) == 0 || IIOImageWriteSession::putBytes(this[2], &v171, 1uLL) == 1))
            {
              if (v135 == 0
                || (_DWORD)v22 == 0
                || (LOWORD(v166) = 8708,
                    HIDWORD(v166) = bswap32(v22),
                    IIOImageWriteSession::putBytes(this[2], &v165, 0xCuLL) == 12)
                && IIOImageWriteSession::putBytes(this[2], v135 + 6, v22) == v22
                && ((v22 & 1) == 0 || IIOImageWriteSession::putBytes(this[2], &v171, 1uLL) == 1))
              {
                if (v128)
                {
                  LOWORD(v166) = 9220;
                  HIDWORD(v166) = bswap32(Length);
                  if (IIOImageWriteSession::putBytes(this[2], &v165, 0xCuLL) != 12
                    || IIOImageWriteSession::putBytes(this[2], v132, Length) != Length
                    || (Length & 1) != 0 && IIOImageWriteSession::putBytes(this[2], &v171, 1uLL) != 1)
                  {
                    goto LABEL_61;
                  }
                  if (v57)
                  {
                    IIMHashArrayForIIMBlock = CreateIIMHashArrayForIIMBlock(v136, v152);
                    LOWORD(v166) = 9476;
                    HIDWORD(v166) = 0x10000000;
                    if (IIOImageWriteSession::putBytes(this[2], &v165, 0xCuLL) != 12)
                      goto LABEL_61;
                    for (i = 0; i != 16; ++i)
                    {
                      LOBYTE(valuePtr) = 0;
                      if (IIMHashArrayForIIMBlock)
                      {
                        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(IIMHashArrayForIIMBlock, i);
                        CFNumberGetValue(ValueAtIndex, kCFNumberCharType, &valuePtr);
                      }
                      if (IIOImageWriteSession::putBytes(this[2], &valuePtr, 1uLL) != 1)
                        goto LABEL_61;
                    }
                    if (IIMHashArrayForIIMBlock)
                      CFRelease(IIMHashArrayForIIMBlock);
                  }
                }
                v35 = (char *)malloc_type_malloc((size_t)size, 0xFD5E2F1FuLL);
                if (v35)
                {
                  v160 = (IIODictionary *)(appleflags / Error);
                  if (v150)
                  {
                    LODWORD(v173) = 0;
                    valuePtr = 0x8000000;
                    v138 = -50;
                    if (IIOImageWriteSession::putBytes(this[2], &valuePtr, 0xCuLL) != 12)
                    {
LABEL_142:
                      v36 = 0;
LABEL_143:
                      v37 = 0;
                      v29 = cf;
                      goto LABEL_144;
                    }
                    v73 = v158;
                    v74 = v156;
                    v75 = Error;
                  }
                  else
                  {
                    if (Error == 8)
                      v138 = PSDWritePlugin::writeLayerMaskBlock8bit(this, (uint64_t (**)(IIOImagePixelDataProvider *, void *))v143, v158, v156, size, (__int16)v160, 4uLL, v139);
                    else
                      v138 = PSDWritePlugin::writeLayerMaskBlock16bit(this, (uint64_t (**)(IIOImagePixelDataProvider *, void *))v143, v158, v156, (size_t)size, v72, 4uLL, v139);
                    v73 = v158;
                    v74 = v156;
                    v75 = Error;
                    if (v138)
                      goto LABEL_142;
                    v138 = 0;
                  }
                  v169 = 0;
                  v76 = v74 * v73;
                  if ((_DWORD)v75 != 8)
                  {
                    v129 = 0;
                    v36 = 0;
                    v77 = (v76 * v75) >> 3;
                    goto LABEL_162;
                  }
                  v78 = (2 * v38 * v74);
                  v169 = 256;
                  v79 = ((v73 + 127) * (unsigned __int128)0x204081020408103uLL) >> 64;
                  v80 = v73 + ((v79 + ((v73 + 127 - v79) >> 1)) >> 6);
                  v77 = v80 * v74;
                  if ((_DWORD)v78)
                  {
                    v81 = v80 * v74;
                    v129 = 2 * v38 * v74;
                    v36 = malloc_type_malloc(v78, 0x7CA154A9uLL);
                    v77 = v81;
                    if (!v36)
                    {
                      _cg_jpeg_mem_term("writeOne", 1737, "*** ERRROR: could not allocate rlebuf - size=%d\n", v129);
                      goto LABEL_142;
                    }
                  }
                  else
                  {
                    v129 = 0;
                    v36 = 0;
                  }
LABEL_162:
                  if (is_mul_ok(v38, v77))
                  {
                    v153 = v77;
                    v83 = v38 * v77;
                    v155 = (unsigned __int8 *)malloc_type_malloc(v38 * v77, 0xCDD4E68BuLL);
                    if (v155)
                    {
                      if (v137 == 16 && v38)
                      {
                        v84 = 0;
                        do
                          *((_QWORD *)v176 + v84++) = v153;
                        while (v38 > v84);
                      }
                      IIOImagePixelDataProvider::rewind(v143);
                      if (v156)
                      {
                        v85 = 0;
                        v142 = 0;
                        __nitemsa = &v155[v83];
                        v86 = v38 - 1;
                        v89 = v137 != 8 || v36 == 0 || v38 == 0;
                        v133 = v89;
                        v90 = 2 * v76;
                        v151 = v36;
                        while (1)
                        {
                          Bytes = (PSDWritePlugin *)IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v143, v35);
                          if (Bytes != size)
                            goto LABEL_223;
                          if (v137 == 16)
                          {
                            v92 = &v155[2 * v158 * v142];
                            switch(v157)
                            {
                              case 0:
                              case 5:
                                if (v158)
                                {
                                  LODWORD(v93) = 0;
                                  v94 = v35;
                                  do
                                  {
                                    if (v38)
                                    {
                                      v95 = 0;
                                      v96 = 1;
                                      v97 = v92;
                                      do
                                      {
                                        *(_WORD *)v97 = *(_WORD *)&v94[2 * v95] ^ ((__int16)((_WORD)v148 << 15) >> 15);
                                        v95 = v96;
                                        v97 += v90;
                                        v98 = v38 > v96++;
                                      }
                                      while (v98);
                                    }
                                    v93 = (v93 + 1);
                                    v94 += 2 * (_QWORD)v160;
                                    v92 += 2;
                                  }
                                  while (v158 > v93);
                                }
                                break;
                              case 1:
                              case 3:
                                if (v158)
                                {
                                  v106 = 0;
                                  v107 = v35;
                                  do
                                  {
                                    v108 = 0;
                                    if (v38 == 1)
                                    {
                                      v111 = v158;
                                      v112 = v156;
                                    }
                                    else
                                    {
                                      v109 = 1;
                                      v110 = v92;
                                      v111 = v158;
                                      v112 = v156;
                                      do
                                      {
                                        *(_WORD *)v110 = *(_WORD *)&v107[2 * v108] ^ ((__int16)((_WORD)v148 << 15) >> 15);
                                        v108 = v109;
                                        v110 += v90;
                                        v98 = v86 > v109++;
                                      }
                                      while (v98);
                                    }
                                    *(_WORD *)&v155[2 * v106 + 2 * (v85 + v108 * v112) * v111] = *(_WORD *)&v107[2 * v108];
                                    v106 = (v106 + 1);
                                    v107 += 2 * (_QWORD)v160;
                                    v92 += 2;
                                  }
                                  while (v111 > v106);
                                }
                                break;
                              case 2:
                              case 4:
                                if (v158)
                                {
                                  v113 = 0;
                                  v114 = v35;
                                  do
                                  {
                                    if (v38 == 1)
                                    {
                                      v120 = 0;
                                      v117 = v158;
                                      v118 = v156;
                                    }
                                    else
                                    {
                                      v115 = 1;
                                      v116 = v92;
                                      v117 = v158;
                                      v118 = v156;
                                      do
                                      {
                                        v119 = v115;
                                        *(_WORD *)v116 = v114[v115] ^ ((__int16)((_WORD)v148 << 15) >> 15);
                                        v116 += v90;
                                        ++v115;
                                      }
                                      while (v86 > v119);
                                      v120 = v119;
                                    }
                                    *(_WORD *)&v155[2 * v113 + 2 * (v85 + v120 * v118) * v117] = *v114;
                                    v113 = (v113 + 1);
                                    v114 += (uint64_t)v160;
                                    v92 += 2;
                                  }
                                  while (v117 > v113);
                                }
                                break;
                              case 6:
                                if (v158)
                                {
                                  LODWORD(v121) = 0;
                                  v122 = v35;
                                  do
                                  {
                                    if (v38)
                                    {
                                      v123 = 1;
                                      v124 = v92;
                                      do
                                      {
                                        *(_WORD *)v124 = *(_WORD *)&v122[2 * v123] ^ ((__int16)((_WORD)v148 << 15) >> 15);
                                        v124 += v90;
                                        v98 = v38 > v123++;
                                      }
                                      while (v98);
                                    }
                                    v121 = (v121 + 1);
                                    v122 += 2 * (_QWORD)v160;
                                    v92 += 2;
                                  }
                                  while (v158 > v121);
                                }
                                break;
                              default:
                                goto LABEL_222;
                            }
                            goto LABEL_222;
                          }
                          v99 = v155;
                          if (!v133)
                            break;
LABEL_222:
                          v85 = ++v142;
                          v36 = v151;
                          if (v156 <= v142)
                            goto LABEL_223;
                        }
                        v100 = 0;
                        v101 = 1;
                        while (1)
                        {
                          if (v157 == 2)
                            goto LABEL_194;
                          v102 = (const unsigned __int8 *)&v35[v100];
                          if (v157 == 6)
                          {
                            ++v102;
                            goto LABEL_196;
                          }
                          if (v157 == 4)
LABEL_194:
                            v102 = (const unsigned __int8 *)&v35[v101 % v160];
LABEL_196:
                          v103 = v35;
                          v104 = *((_QWORD *)v176 + v100);
                          Bytes = (PSDWritePlugin *)PSDWritePlugin::PackBits(Bytes, v102, (__int16)v160, v158, &v99[v100 * v153 + v104], __nitemsa, v148);
                          v105 = v104 + Bytes;
                          v35 = v103;
                          v99 = v155;
                          *((_WORD *)v151 + v85 + v100 * v156) = __rev16(Bytes);
                          *((_QWORD *)v176 + v100) = v105;
                          v100 = v101;
                          v98 = v38 > v101++;
                          if (!v98)
                            goto LABEL_222;
                        }
                      }
LABEL_223:
                      if (IIOImageWriteSession::putBytes(this[2], &v169, 2uLL) == 2
                        && (!v36 || IIOImageWriteSession::putBytes(this[2], v36, v129) == v129))
                      {
                        if (v38)
                        {
                          v125 = 0;
                          v126 = 1;
                          while (1)
                          {
                            v127 = *((_QWORD *)v176 + v125);
                            if (IIOImageWriteSession::putBytes(this[2], &v155[v125 * v153], v127) != v127)
                              break;
                            v125 = v126;
                            v98 = v38 > v126++;
                            if (!v98)
                              goto LABEL_230;
                          }
                        }
                        else
                        {
LABEL_230:
                          v138 = 0;
                        }
                      }
                      v29 = cf;
                      v37 = v155;
                      if (!cf)
                        goto LABEL_146;
LABEL_145:
                      CFRelease(v29);
                      goto LABEL_146;
                    }
                    _cg_jpeg_mem_term("writeOne", 1742, "*** ERRROR: could not allocate fullbuf - size=%d\n", 0);
                  }
                  goto LABEL_143;
                }
                _cg_jpeg_mem_term("writeOne", 1694, "*** ERRROR: could not allocate rowbuf - size=%d\n", (_DWORD)size);
              }
            }
          }
        }
      }
    }
LABEL_61:
    v36 = 0;
    v37 = 0;
    v35 = 0;
    v138 = -50;
    goto LABEL_130;
  }
LABEL_144:
  if (v29)
    goto LABEL_145;
LABEL_146:
  if (v135)
    free(v135);
  if (v136)
    free(v136);
LABEL_150:
  if (v134)
    CFRelease(v134);
  if (v37)
    free(v37);
  if (v35)
    free(v35);
  if (v36)
    free(v36);
  if (table)
    free(table);
  return v138;
}

void sub_188067114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a46);
  _Unwind_Resume(a1);
}

BOOL PSDWritePlugin::WriteProc(PSDWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  _BOOL8 v5;
  uint64_t v6;
  const char *v7;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 0x17u);
  *(_QWORD *)&v9[0] = &off_1E1BAFC30;
  v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9) != 0;
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_188067198(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _cg_jpeg_mem_term(&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x188067184);
}

uint64_t _cg_RadReadRGBSize(FILE *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result;
  int v6;
  BOOL v7;
  uint64_t v8;
  _QWORD v9[3];
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  *a3 = 0;
  if (!a1)
    return 4294967246;
  memset(v9, 0, sizeof(v9));
  v10 = 0;
  v8 = 0;
  if (RGBE_ReadHeader(a1, (uint64_t)&v8 + 4, (uint64_t)&v8, (uint64_t)v9))
    return 4294967246;
  v6 = v8;
  result = 4294967246;
  if ((HIDWORD(v8) - 1) >> 14)
    v7 = 1;
  else
    v7 = (int)v8 < 1;
  if (!v7 && v8 <= 0x4000)
  {
    result = 0;
    *a2 = HIDWORD(v8);
    *a3 = v6;
  }
  return result;
}

