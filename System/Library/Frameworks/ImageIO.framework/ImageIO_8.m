unint64_t ZSTD_compressBlock_btultra_dictMatchState(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v7;
  unsigned __int8 *v8;
  int v9;
  uint64_t v10;
  unsigned int *v11;
  __int128 *v12;
  __int128 v13;
  unsigned __int8 *v14;
  unint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  unsigned __int8 *v18;
  unsigned int v19;
  unsigned int v20;
  int32x2_t v21;
  int32x2_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unsigned int i;
  int inserted;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  char *v34;
  unsigned int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  unsigned int v53;
  unint64_t v54;
  unint64_t v55;
  _QWORD *v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  int v67;
  unsigned int v68;
  unint64_t v69;
  _DWORD *v71;
  uint64_t v72;
  char *v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unsigned int v79;
  uint64_t v80;
  int v81;
  char *v82;
  int v83;
  unsigned int v84;
  uint64_t v85;
  unsigned int v86;
  unsigned int v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  unsigned int v92;
  uint64_t v93;
  unsigned int v94;
  unsigned int v95;
  uint64_t v96;
  unsigned int v97;
  unsigned int v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  unint64_t v102;
  _QWORD *v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  uint64_t v111;
  _QWORD *v112;
  uint64_t v113;
  unint64_t v114;
  int v115;
  unsigned int v116;
  unint64_t v117;
  _DWORD *v119;
  uint64_t v120;
  char *v121;
  unint64_t v122;
  char *v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  int v127;
  unsigned int v128;
  unsigned int v129;
  uint64_t v130;
  int v131;
  uint64_t v132;
  unsigned int *v133;
  unsigned int *v134;
  unsigned int v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  uint64_t v144;
  int v145;
  _DWORD *v146;
  unsigned int v147;
  unsigned int v148;
  unsigned int v149;
  _BOOL4 v150;
  unsigned int v151;
  uint64_t v152;
  int v153;
  char *v154;
  int v155;
  unsigned int v156;
  uint64_t v157;
  unsigned int v158;
  unsigned int v160;
  int v161;
  uint64_t v162;
  uint64_t v163;
  unsigned int v164;
  uint64_t v165;
  unsigned int v166;
  unsigned int v167;
  uint64_t v168;
  unsigned int v169;
  unsigned int v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  unint64_t v174;
  _QWORD *v175;
  int v176;
  unint64_t v177;
  unint64_t v178;
  unsigned int v179;
  unsigned int v180;
  unsigned int v181;
  uint64_t v183;
  _QWORD *v184;
  uint64_t v185;
  uint64_t v186;
  int v187;
  unsigned int v188;
  unint64_t v189;
  _DWORD *v191;
  uint64_t v192;
  char *v193;
  unint64_t v194;
  char *v195;
  uint64_t v196;
  uint64_t v197;
  unint64_t v198;
  unsigned int v199;
  uint64_t v200;
  int v201;
  char *v202;
  int v203;
  unsigned int v204;
  uint64_t v205;
  unsigned int v206;
  unsigned int v208;
  int v209;
  uint64_t v210;
  uint64_t v211;
  unsigned int v212;
  uint64_t v213;
  unsigned int v214;
  unsigned int v215;
  uint64_t v216;
  unsigned int v217;
  unsigned int v218;
  uint64_t v219;
  unsigned int v220;
  uint64_t v221;
  unint64_t v222;
  _QWORD *v223;
  uint64_t v224;
  unint64_t v225;
  unint64_t v226;
  unsigned int v227;
  unsigned int v228;
  unsigned int v229;
  uint64_t v231;
  _QWORD *v232;
  uint64_t v233;
  uint64_t v234;
  int v235;
  unsigned int v236;
  unint64_t v237;
  _DWORD *v239;
  uint64_t v240;
  char *v241;
  unint64_t v242;
  char *v243;
  uint64_t v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  int v248;
  int v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  BOOL v253;
  unint64_t v254;
  unint64_t v255;
  int v256;
  uint64_t v257;
  unsigned int v258;
  unint64_t v259;
  unsigned int v260;
  uint64_t v261;
  uint64_t v262;
  unsigned __int8 *v263;
  _QWORD *v264;
  unint64_t v265;
  unint64_t v266;
  unsigned __int8 *v267;
  _DWORD *v268;
  unsigned int *v270;
  unint64_t v271;
  uint64_t v272;
  char *v273;
  char *v274;
  uint64_t v275;
  unint64_t v276;
  unint64_t v277;
  int v278;
  unsigned int v279;
  unsigned int v280;
  int v281;
  uint64_t v282;
  unsigned int *v283;
  unsigned int *v284;
  unsigned int v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t v288;
  uint64_t v289;
  uint64_t v290;
  unint64_t v291;
  unint64_t v292;
  unint64_t v293;
  uint64_t v294;
  int v295;
  _DWORD *v296;
  unsigned int v297;
  unsigned int v298;
  unsigned int v299;
  _BOOL4 v300;
  int v301;
  unsigned int v302;
  unsigned int v303;
  uint64_t v304;
  unsigned int v305;
  unint64_t v306;
  unint64_t v307;
  unint64_t v308;
  uint64_t v309;
  uint64_t v310;
  unint64_t v311;
  unint64_t v312;
  unint64_t v313;
  uint64_t v314;
  int v315;
  _DWORD *v316;
  unsigned int v317;
  unsigned int v318;
  unsigned int v319;
  _BOOL4 v320;
  int v321;
  unsigned int v322;
  unsigned int *v323;
  unsigned int *v324;
  unsigned int v325;
  unint64_t v326;
  uint64_t v327;
  unint64_t v328;
  uint64_t v329;
  uint64_t v330;
  unint64_t v331;
  unint64_t v332;
  unint64_t v333;
  uint64_t v334;
  unsigned int v335;
  _DWORD *v336;
  unsigned int v337;
  unsigned int v338;
  unsigned int v339;
  _BOOL4 v340;
  unint64_t v341;
  unint64_t v342;
  int v343;
  uint64_t v344;
  unsigned int v345;
  unint64_t v346;
  unsigned int v347;
  uint64_t v348;
  uint64_t v349;
  unsigned __int8 *v350;
  _QWORD *v351;
  unint64_t v352;
  unint64_t v353;
  unsigned __int8 *v354;
  _DWORD *v355;
  unsigned int *v357;
  unint64_t v358;
  uint64_t v359;
  char *v360;
  char *v361;
  uint64_t v362;
  unint64_t v363;
  unint64_t v364;
  unint64_t v365;
  unint64_t v366;
  int v367;
  uint64_t v368;
  unsigned int v369;
  unint64_t v370;
  unsigned int v371;
  uint64_t v372;
  uint64_t v373;
  unsigned __int8 *v374;
  _QWORD *v375;
  unint64_t v376;
  unint64_t v377;
  unsigned __int8 *v378;
  _DWORD *v379;
  unsigned int *v381;
  unint64_t v382;
  uint64_t v383;
  char *v384;
  char *v385;
  uint64_t v386;
  unint64_t v387;
  unint64_t v388;
  unint64_t v389;
  unint64_t v390;
  int v391;
  unsigned int v392;
  unint64_t v393;
  uint64_t v394;
  unsigned __int8 *v395;
  _DWORD *v396;
  unint64_t v397;
  unint64_t v398;
  unsigned __int8 *v399;
  unsigned int v400;
  _DWORD *v401;
  unsigned int *v403;
  unsigned int *v404;
  unsigned int *v405;
  unint64_t v406;
  uint64_t v407;
  char *v408;
  char *v409;
  uint64_t v410;
  unint64_t v411;
  unint64_t v412;
  _DWORD *v413;
  unint64_t v414;
  unint64_t v415;
  unsigned __int8 *v416;
  unsigned __int8 *v418;
  uint64_t v419;
  int v420;
  unsigned int v421;
  unsigned int v422;
  uint64_t v423;
  unsigned int v424;
  int v425;
  unsigned int v426;
  uint64_t v427;
  int v428;
  int v429;
  _DWORD *v430;
  unsigned int v431;
  unsigned int v432;
  unsigned int v433;
  unint64_t v434;
  unsigned int v435;
  unsigned int v436;
  _DWORD *v437;
  unint64_t v438;
  uint64_t v439;
  unsigned int *v440;
  uint64_t v441;
  unsigned int v442;
  unsigned int v443;
  unsigned int *v444;
  unsigned int v445;
  unsigned int v446;
  uint64_t v447;
  unsigned int v448;
  unsigned int v449;
  unsigned int *v450;
  uint64_t v451;
  uint64_t v452;
  int v453;
  unsigned int v454;
  unsigned int v455;
  unsigned int v456;
  uint64_t v457;
  int v458;
  unsigned int v459;
  unsigned int *v460;
  unsigned int v461;
  unint64_t v462;
  unsigned __int8 *v463;
  int v464;
  unsigned int v465;
  unsigned int v466;
  unsigned int *v467;
  unsigned int v468;
  uint64_t v469;
  unsigned __int8 *v470;
  unsigned int v471;
  int v472;
  unsigned int v473;
  unsigned int v474;
  unsigned int v475;
  unsigned int v476;
  unsigned int v477;
  int v478;
  unsigned int v479;
  int v480;
  unsigned int v481;
  unsigned int v482;
  uint64_t v483;
  int v484;
  int v485;
  uint64_t v486;
  unsigned int v487;
  uint64_t v488;
  int v489;
  signed int v490;
  unsigned int *v491;
  _DWORD *v492;
  int v493;
  signed int v494;
  unsigned int *v495;
  unsigned int v496;
  unsigned int *v497;
  unint64_t v498;
  unsigned int v499;
  unsigned int v500;
  unsigned int *v501;
  uint64_t v502;
  unsigned int *v503;
  unsigned int *v504;
  int v505;
  unsigned int v506;
  unint64_t v507;
  uint64_t v508;
  unsigned int v509;
  unint64_t v510;
  unsigned int *v511;
  unsigned int v512;
  unsigned int v513;
  int v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  int v518;
  uint64_t v519;
  unsigned int j;
  int v521;
  unsigned int *v522;
  unint64_t v523;
  unsigned int v524;
  uint64_t v525;
  uint64_t v526;
  _QWORD *v527;
  int v528;
  uint64_t v529;
  unsigned int v530;
  unsigned int v531;
  unsigned int v533;
  int v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  unsigned int v538;
  unsigned int v539;
  unsigned int v540;
  unsigned int v541;
  unsigned int v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  unint64_t v546;
  unsigned int v547;
  uint64_t v548;
  unint64_t v549;
  unsigned int v550;
  unsigned int v551;
  unsigned int v552;
  uint64_t v554;
  uint64_t v555;
  int v556;
  unsigned int v557;
  unint64_t v558;
  _QWORD *v560;
  _QWORD *v561;
  unint64_t v562;
  unint64_t v563;
  _DWORD *v564;
  unsigned int v565;
  uint64_t v566;
  unsigned int v567;
  _QWORD *v568;
  int v569;
  uint64_t v570;
  unsigned int v571;
  unsigned int v572;
  unsigned int v574;
  int v575;
  uint64_t v576;
  uint64_t v577;
  uint64_t v578;
  unsigned int v579;
  unsigned int v580;
  unsigned int v581;
  unsigned int v582;
  unsigned int v583;
  unsigned int v584;
  uint64_t v585;
  uint64_t v586;
  unint64_t v587;
  unsigned int v588;
  uint64_t v589;
  unint64_t v590;
  unint64_t v591;
  unsigned int v592;
  unsigned int v593;
  unsigned int v594;
  uint64_t v596;
  uint64_t v597;
  uint64_t v598;
  int v599;
  unsigned int v600;
  unint64_t v601;
  _QWORD *v603;
  _QWORD *v604;
  unint64_t v605;
  unint64_t v606;
  _DWORD *v607;
  int v608;
  unsigned int v609;
  uint64_t v610;
  unsigned int v611;
  unsigned int *v612;
  uint64_t v613;
  unsigned int *v614;
  unsigned int v615;
  unint64_t v616;
  unint64_t v617;
  unint64_t v618;
  uint64_t v619;
  uint64_t v620;
  unint64_t v621;
  unint64_t v622;
  uint64_t v623;
  unsigned int v624;
  _DWORD *v625;
  unsigned int v626;
  unsigned int v627;
  unsigned int v628;
  _BOOL4 v629;
  unsigned int v630;
  uint64_t v631;
  unsigned int v632;
  _QWORD *v633;
  unsigned int v634;
  int v635;
  uint64_t v636;
  unsigned int v637;
  unsigned int v638;
  unsigned int v640;
  int v641;
  uint64_t v642;
  uint64_t v643;
  uint64_t v644;
  unsigned int v645;
  unsigned int v646;
  unsigned int v647;
  unsigned int v648;
  unsigned int v649;
  unsigned int v650;
  uint64_t v651;
  uint64_t v652;
  unint64_t v653;
  unsigned int v654;
  uint64_t v655;
  unint64_t v656;
  unsigned int v657;
  unsigned int v658;
  unsigned int v659;
  uint64_t v661;
  _QWORD *v662;
  uint64_t v663;
  int v664;
  unsigned int v665;
  unint64_t v666;
  _QWORD *v668;
  _QWORD *v669;
  unint64_t v670;
  unint64_t v671;
  _DWORD *v672;
  unsigned int v673;
  uint64_t v674;
  unsigned int v675;
  _QWORD *v676;
  int v677;
  uint64_t v678;
  unsigned int v679;
  unsigned int v680;
  unsigned int v682;
  int v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  unsigned int v687;
  unsigned int v688;
  unsigned int v689;
  unsigned int v690;
  unsigned int v691;
  unsigned int v692;
  uint64_t v693;
  uint64_t v694;
  unint64_t v695;
  unsigned int v696;
  uint64_t v697;
  unint64_t v698;
  unsigned int v699;
  unsigned int v700;
  unsigned int v701;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  int v706;
  unsigned int v707;
  unint64_t v708;
  _QWORD *v710;
  _QWORD *v711;
  unint64_t v712;
  unint64_t v713;
  _DWORD *v714;
  uint64_t v715;
  int v716;
  int v717;
  uint64_t v718;
  uint64_t v719;
  int v720;
  BOOL v721;
  unint64_t v722;
  unint64_t v723;
  uint64_t v724;
  int v725;
  unint64_t v726;
  unsigned int v727;
  uint64_t v728;
  uint64_t v729;
  unsigned __int8 *v730;
  _QWORD *v731;
  unint64_t v732;
  unint64_t v733;
  char *v734;
  _DWORD *v735;
  unsigned int *v737;
  unsigned int *v738;
  unsigned int *v739;
  unint64_t v740;
  uint64_t v741;
  uint64_t v742;
  char *v743;
  char *v744;
  uint64_t v745;
  unint64_t v746;
  unint64_t v747;
  int v748;
  unsigned int v749;
  uint64_t v750;
  int *v751;
  unsigned int *v752;
  unsigned int v753;
  unint64_t v754;
  unint64_t v755;
  unint64_t v756;
  uint64_t v757;
  uint64_t v758;
  unint64_t v759;
  unint64_t v760;
  uint64_t v761;
  unsigned int v762;
  _DWORD *v763;
  unsigned int v764;
  unsigned int v765;
  unsigned int v766;
  _BOOL4 v767;
  int v768;
  unsigned int v769;
  uint64_t v770;
  unsigned int v771;
  unint64_t v772;
  unint64_t v773;
  unint64_t v774;
  uint64_t v775;
  uint64_t v776;
  unint64_t v777;
  unint64_t v778;
  uint64_t v779;
  unsigned int v780;
  _DWORD *v781;
  unsigned int v782;
  unsigned int v783;
  unsigned int v784;
  _BOOL4 v785;
  unsigned int *v786;
  int v787;
  unsigned int v788;
  int v789;
  uint64_t v790;
  unsigned int *v791;
  unsigned int v792;
  unint64_t v793;
  unint64_t v794;
  unint64_t v795;
  uint64_t v796;
  uint64_t v797;
  unint64_t v798;
  unint64_t v799;
  unint64_t v800;
  uint64_t v801;
  int v802;
  _DWORD *v803;
  unsigned int v804;
  unsigned int v805;
  unsigned int v806;
  _BOOL4 v807;
  unint64_t v808;
  unint64_t v809;
  uint64_t v810;
  unint64_t v811;
  uint64_t v812;
  unsigned __int8 *v813;
  _QWORD *v814;
  unint64_t v815;
  unint64_t v816;
  char *v817;
  unsigned int v818;
  _DWORD *v819;
  unsigned int *v821;
  unsigned int *v822;
  int *v823;
  unint64_t v824;
  uint64_t v825;
  uint64_t v826;
  char *v827;
  char *v828;
  uint64_t v829;
  unint64_t v830;
  unint64_t v831;
  unint64_t v832;
  unint64_t v833;
  uint64_t v834;
  int v835;
  unint64_t v836;
  unsigned int v837;
  uint64_t v838;
  uint64_t v839;
  unsigned __int8 *v840;
  _QWORD *v841;
  unint64_t v842;
  unint64_t v843;
  char *v844;
  _DWORD *v845;
  unsigned int *v847;
  unsigned int *v848;
  unsigned int *v849;
  unint64_t v850;
  uint64_t v851;
  uint64_t v852;
  char *v853;
  char *v854;
  uint64_t v855;
  unint64_t v856;
  unint64_t v857;
  unint64_t v858;
  unint64_t v859;
  unint64_t v860;
  uint64_t v861;
  uint64_t v862;
  unsigned __int8 *v863;
  _DWORD *v864;
  unint64_t v865;
  unint64_t v866;
  uint64_t v867;
  char *v868;
  unsigned int v869;
  unint64_t v870;
  _DWORD *v871;
  unsigned int *v873;
  uint64_t v874;
  uint64_t v875;
  uint64_t v876;
  char *v877;
  char *v878;
  uint64_t v879;
  unint64_t v880;
  unint64_t v881;
  _DWORD *v882;
  unint64_t v883;
  unint64_t v884;
  char *v885;
  uint64_t v887;
  uint64_t v888;
  uint64_t v889;
  int v890;
  signed int *v891;
  unsigned int v892;
  unsigned int v893;
  signed int v894;
  uint64_t v895;
  int v896;
  int v897;
  unsigned int v898;
  signed int *v899;
  unint64_t v900;
  unsigned int v901;
  signed int v902;
  uint64_t v903;
  unint64_t v904;
  unint64_t v905;
  _DWORD *v906;
  _DWORD *v907;
  int v908;
  uint64_t v909;
  uint64_t v910;
  int v911;
  int v912;
  unsigned int v913;
  unsigned int *v914;
  unsigned int v915;
  unsigned int v916;
  unint64_t v917;
  unsigned int v918;
  unsigned int v919;
  uint64_t v920;
  int v921;
  unsigned int v922;
  signed int v923;
  uint64_t v924;
  unint64_t v925;
  unint64_t v926;
  _DWORD *v927;
  _DWORD *v928;
  uint64_t v929;
  uint64_t v930;
  unint64_t v931;
  unsigned int *v932;
  unsigned int *v933;
  unsigned int *v934;
  unint64_t v935;
  unsigned int v936;
  unsigned int v937;
  unsigned int v938;
  unint64_t v939;
  uint64_t v940;
  unsigned int v941;
  unsigned int v942;
  unsigned int *v943;
  unsigned int v944;
  unsigned int *v945;
  unsigned int v946;
  unsigned int *v947;
  __int128 v948;
  BOOL v949;
  unsigned int v950;
  uint64_t v951;
  unsigned int v952;
  unsigned int v953;
  unsigned int v954;
  uint64_t v955;
  unsigned int v956;
  unsigned int v957;
  char *v958;
  unsigned __int8 *v959;
  uint64_t v960;
  int v961;
  unsigned int v962;
  unsigned int v963;
  unsigned int v964;
  unsigned int v965;
  unsigned int v966;
  unsigned __int8 *v967;
  char *v968;
  unsigned __int8 *v969;
  char *v970;
  uint64_t v971;
  _OWORD *v972;
  unint64_t v973;
  __int128 *v974;
  __int128 v975;
  unsigned __int8 *v976;
  char *v977;
  __int128 v978;
  unsigned __int8 *v979;
  unint64_t v980;
  unsigned __int8 *v981;
  uint64_t v982;
  unint64_t v983;
  __int128 *v984;
  char *v985;
  unint64_t v986;
  __int128 v987;
  unsigned __int8 *v988;
  char *v989;
  unint64_t v990;
  uint64_t v991;
  char v992;
  unint64_t v993;
  unint64_t v994;
  unsigned int v995;
  unsigned int v996;
  unsigned int *v997;
  uint64_t v998;
  unint64_t v999;
  _QWORD *v1000;
  _QWORD *v1001;
  uint64_t v1002;
  unint64_t v1003;
  uint64_t v1005;
  unsigned int *v1006;
  char *v1007;
  uint64_t v1008;
  unsigned int v1009;
  uint64_t v1010;
  uint64_t v1011;
  uint64_t v1012;
  int v1013;
  uint64_t v1014;
  int v1015;
  int v1016;
  uint64_t v1017;
  int v1018;
  uint64_t v1019;
  uint64_t v1020;
  unint64_t v1021;
  uint64_t v1022;
  uint64_t v1023;
  unint64_t v1024;
  int v1025;
  uint64_t v1026;
  int v1027;
  int v1028;
  uint64_t v1029;
  int v1030;
  uint64_t v1031;
  uint64_t v1032;
  uint64_t v1033;
  unsigned int *v1034;
  unsigned int v1035;
  uint64_t v1036;
  unsigned int v1037;
  uint64_t v1038;
  uint64_t v1039;
  unsigned int v1040;
  unsigned int v1041;
  unsigned int v1042;
  unsigned int v1043;
  uint64_t v1044;
  unsigned int *v1045;
  uint64_t v1046;
  unsigned int *v1047;
  int v1048;
  int v1049;
  int v1050;
  int v1051;
  uint64_t v1052;
  uint64_t v1053;
  uint64_t v1054;
  uint64_t v1055;
  uint64_t v1056;
  int v1057;
  int v1058;
  int v1059;
  _QWORD *v1060;
  unint64_t v1061;
  uint64_t v1062;
  uint64_t v1063;
  uint64_t v1064;
  uint64_t v1065;
  uint64_t v1066;
  uint64_t v1067;
  int v1068;
  unsigned int v1069;
  int v1070;
  int v1071;
  unsigned int v1072;
  uint64_t v1073;
  unsigned int v1074;
  uint64_t v1075;
  uint64_t v1076;
  unsigned int *v1077;
  unsigned int *v1078;
  unsigned int *v1079;
  uint64_t v1080;
  uint64_t v1081;
  uint64_t v1082;
  unsigned int v1083;
  uint64_t v1084;
  uint64_t v1085;
  uint64_t v1086;
  unsigned int v1087;
  unsigned int v1088;
  unsigned int v1089;
  unsigned int v1090;
  unsigned int *v1091;
  unint64_t v1092;
  unint64_t v1093;
  uint64_t v1094;
  int v1095;
  unsigned int v1096;
  uint64_t v1097;
  unsigned int v1098;
  uint64_t v1099;
  int v1100;
  int v1101;
  int v1102;
  unsigned int v1103;
  uint64_t v1104;
  unsigned int v1105;
  uint64_t v1106;
  unsigned int v1107;
  uint64_t v1108;
  uint64_t v1109;
  uint64_t v1110;
  unsigned int v1111;
  unsigned int v1112;
  unint64_t v1113;
  unsigned int v1114;
  int v1115;
  unsigned int v1116;
  unsigned int v1117;
  unsigned int v1118;
  unsigned int v1119;
  unsigned int v1120;
  unsigned int v1121;
  unsigned int v1122;
  int v1123;
  unsigned int v1124;
  uint64_t v1125;
  unsigned int v1126;
  unsigned int v1127;
  unsigned int v1128;
  unsigned int v1129;
  unsigned int v1130;
  unsigned int v1131;
  uint64_t v1132;
  int v1133;
  uint64_t v1134;
  uint64_t v1135;
  uint64_t v1136;
  unsigned int v1137;
  unint64_t v1138;
  unsigned int v1139;
  unint64_t v1140;
  unint64_t v1141;
  unsigned int v1142;
  unsigned int v1143;
  unsigned int v1144;
  uint64_t v1145;
  uint64_t v1146;
  int v1147;
  uint64_t v1148;
  uint64_t v1149;
  unsigned int v1150;
  unsigned int v1151;
  unsigned int v1152;
  unsigned int v1153;
  unsigned int v1154;
  unsigned int v1155;
  uint64_t v1156;
  unsigned int v1157;
  unsigned int v1158;
  uint64_t v1159;
  uint64_t v1160;
  unsigned int v1161;
  unsigned int v1162;
  unsigned int v1163;
  unsigned int v1164;
  unint64_t v1165;
  unsigned int v1166;
  unsigned int v1167;
  unsigned int v1168;
  unsigned int v1169;
  uint64_t v1170;
  uint64_t v1171;
  int v1172;
  uint64_t v1173;
  uint64_t v1174;
  uint64_t v1175;
  unsigned int v1176;
  unsigned int v1177;
  unsigned int v1178;
  unsigned int v1179;
  unsigned int v1180;
  unsigned int v1181;
  unsigned int v1182;
  unint64_t v1183;
  unsigned int v1184;
  unsigned int v1185;
  unsigned int v1186;
  unsigned int v1187;
  uint64_t v1188;
  _DWORD *v1189;
  unsigned int v1190;
  uint64_t v1191;
  uint64_t v1192;
  int v1193;
  unsigned int v1194;
  int v1195;
  int v1196;
  unsigned int v1197;
  int v1198;
  int v1199;
  int v1200;
  unsigned int v1201;
  int v1202;
  int v1203;
  unint64_t v1204;
  _QWORD *v1205;
  uint64_t v1206;
  unsigned int v1207;
  unsigned int v1208;
  unint64_t v1209;
  unsigned int v1210;
  unint64_t v1211;
  unint64_t v1212;
  uint64_t v1213;
  unsigned int v1214;
  unsigned int v1215;
  int v1216;
  uint64_t v1217;
  uint64_t v1218;
  int v1219;
  int v1220;
  int v1221;
  unsigned int v1222;
  unint64_t v1223;
  unsigned int v1224;
  unsigned int v1225;
  unsigned int v1226;
  unint64_t v1227;
  int v1228;
  unsigned __int8 *v1229;
  unsigned int v1230;
  int v1231;
  uint64_t v1232;
  int v1233;
  int v1234;
  uint64_t v1235;
  uint64_t v1236;
  char *v1237;
  char *v1238;
  unsigned int v1239;
  char *v1240;
  unint64_t v1241;
  uint64_t v1242;
  uint64_t v1243;
  uint64_t v1244;
  uint64_t v1245;
  _QWORD *v1246;
  _QWORD *v1247;
  char *v1248;
  _QWORD *v1249;
  int v1250;
  unsigned int v1251;
  unsigned int v1252;
  unsigned int v1253;
  unsigned int v1254;
  int v1255;
  unint64_t v1256;
  int v1257;
  int v1258;
  int v1259;
  int v1260;
  int v1261;
  int v1262;
  int v1263;
  int v1264;
  char **v1265;
  unsigned __int8 *v1266;
  uint64_t v1267;
  uint64_t v1268;
  unsigned int v1269;
  uint64_t v1270;
  uint64_t v1271;
  unsigned int v1272;
  unsigned int v1273;
  unsigned int v1274;
  unsigned int v1275;
  uint64_t v1276;
  unsigned int v1277;
  unsigned int v1278;
  unint64_t v1279;
  char *v1280;
  uint64_t v1281;
  char *v1282;
  unsigned int v1283;
  int v1284;
  int v1285;
  int v1286;
  int v1287;
  unsigned int v1288;
  int v1289;
  _QWORD *v1290;
  _QWORD *v1291;
  _QWORD *v1292;
  _QWORD *v1293;
  unsigned int v1294;
  unint64_t v1295;
  unint64_t v1296;
  _QWORD *v1297;
  unint64_t v1298;
  char *v1299;
  unint64_t v1300;
  unsigned int v1301;
  char *v1302;
  unint64_t v1303;
  uint64_t v1304;
  char *v1305;
  char *v1306;
  char *v1307;
  char *v1308;
  unsigned __int8 *v1309;
  unsigned int v1310;
  unint64_t v1311;
  int v1312;
  unint64_t v1313;
  unint64_t v1314;
  _QWORD *v1315;
  int v1316;
  _QWORD *v1317;
  _QWORD *v1318;
  uint64_t v1319;
  unsigned int v1320;
  unsigned int v1321;
  int v1322;
  unsigned int v1323;
  unsigned int v1324;
  unsigned int v1325;
  int v1326;
  int v1327;
  unsigned int v1328;
  int v1329;
  unint64_t v1330;
  unint64_t v1331;
  char *v1332;
  unsigned __int8 *v1334;
  unsigned __int8 *v1335;
  _DWORD *v1336;
  _DWORD *v1337;
  unsigned int v1338;
  __int128 v1339;
  __int128 v1340;
  _BYTE v1341[24];
  int v1342;
  uint64_t v1343;
  unsigned int v1344;
  uint64_t v1345;

  v7 = a1;
  v1345 = *MEMORY[0x1E0C80C00];
  v1265 = (char **)(a1 + 80);
  v1266 = a4;
  v1335 = &a4[a5];
  v1303 = (unint64_t)&a4[a5 - 8];
  v8 = (unsigned __int8 *)(*(_QWORD *)(a1 + 8) + *(unsigned int *)(a1 + 24));
  if (*(_DWORD *)(a1 + 212) >= 0xFFFu)
    v9 = 4095;
  else
    v9 = *(_DWORD *)(a1 + 212);
  v1190 = v9;
  if (*(_DWORD *)(a1 + 208) == 3)
    v10 = 3;
  else
    v10 = 4;
  v1009 = *(_DWORD *)(a1 + 36);
  v11 = *(unsigned int **)(a1 + 120);
  v1336 = *(_DWORD **)(a1 + 112);
  v1344 = 0;
  v1343 = 0;
  v1340 = 0u;
  memset(v1341, 0, sizeof(v1341));
  v1339 = 0u;
  v12 = *(__int128 **)(a1 + 224);
  if (v12)
  {
    v13 = v12[1];
    v1339 = *v12;
    v1340 = v13;
    *(_QWORD *)v1341 = *((_QWORD *)v12 + 4);
  }
  else
  {
    *(_QWORD *)v1341 = 0;
    v1339 = 0uLL;
    v1340 = 0uLL;
  }
  *(_QWORD *)&v1341[12] = 0;
  *(_DWORD *)&v1341[8] = 0;
  ZSTD_opt_getNextMatchAndUpdateSeqStore((uint64_t *)&v1339, 0, a5);
  ZSTD_rescaleFreqs(v1265, v1266, a5, 2);
  if (v8 == v1266)
    v14 = v1266 + 1;
  else
    v14 = v1266;
  v15 = (unint64_t)v1335;
  if ((unint64_t)v14 < v1303)
  {
    v1083 = 0;
    v1183 = (v10 - 1);
    v1330 = (unint64_t)(v1335 - 1);
    v1331 = (unint64_t)(v1335 - 3);
    v1061 = (v10 - 1) & 0xFFFFFFFFFFFFFFFELL;
    v1010 = v10 - 1;
    v16 = (v10 - 1) | 1;
    v1337 = v11 + 14;
    v1005 = v10 - v16;
    v1006 = &v11[7 * v16];
    v17 = v11 + 7;
    v18 = v1266;
    v1304 = v7;
    v1250 = v10;
    v1062 = a2;
    v1332 = (char *)(v1335 - 7);
    while (1)
    {
      v1229 = v18;
      v23 = (_DWORD)v14 - (_DWORD)v18;
      v1338 = 0;
      v24 = *(_QWORD *)(v7 + 8);
      v25 = *(unsigned int *)(v7 + 36);
      v1334 = v14;
      if (v24 + v25 > (unint64_t)v14)
      {
        LODWORD(v26) = 0;
        v27 = (uint64_t)v1336;
        goto LABEL_604;
      }
      v28 = *(_DWORD *)(v7 + 208);
      for (i = (_DWORD)v14 - v24; v25 < i; LODWORD(v25) = inserted + v25)
      {
        inserted = ZSTD_insertBt1(v7, (_QWORD *)(v24 + v25), v15, v28, 0);
        v15 = (unint64_t)v1335;
      }
      *(_DWORD *)(v7 + 36) = i;
      if ((v28 - 6) < 2)
        break;
      if (v28 == 5)
      {
        v26 = 0;
        if (*(_DWORD *)(v7 + 212) >= 0xFFFu)
          v151 = 4095;
        else
          v151 = *(_DWORD *)(v7 + 212);
        v152 = *(_QWORD *)(v7 + 8);
        v153 = (_DWORD)v1334 - v152;
        v154 = (char *)(v1334 + 12);
        v1101 = *(_DWORD *)(v7 + 204);
        v1109 = *(_QWORD *)(v7 + 48);
        v1093 = (0xCF1BBCDCBB000000 * *(_QWORD *)v1334) >> -(char)*(_DWORD *)(v7 + 200);
        v1117 = *(_DWORD *)(v1109 + 4 * v1093);
        v155 = -1 << (*(_DWORD *)(v7 + 196) - 1);
        v1050 = ~v155;
        v156 = (_DWORD)v1334 - v152 + v155 + 1;
        if ((int)v1334 - (int)v152 < ~v155)
          v156 = 0;
        v1127 = v156;
        v157 = *(unsigned int *)(v7 + 24);
        v158 = 1 << *(_DWORD *)(v7 + 192);
        v14 = v1334;
        if (v153 - *(_DWORD *)(v7 + 28) > v158 && *(_DWORD *)(v7 + 32) == 0)
          v160 = v153 - v158;
        else
          v160 = *(_DWORD *)(v7 + 28);
        if (v160 <= 1)
          v161 = 1;
        else
          v161 = v160;
        v1143 = v161;
        v162 = *(_QWORD *)(v7 + 184);
        v163 = *(_QWORD *)(v162 + 8);
        v1307 = *(char **)v162;
        v164 = *(_DWORD *)(v162 + 28);
        v165 = v160 - (*(_QWORD *)v162 - (_DWORD)v163);
        v1065 = v162;
        v1058 = *(_DWORD *)(v162 + 200);
        v166 = ~(-1 << (*(_DWORD *)(v162 + 196) - 1));
        v167 = *(_QWORD *)v162 - v163 - v164;
        v168 = *(_QWORD *)(v7 + 64);
        v1042 = (_DWORD)v1307 - v163;
        v1152 = v166;
        if (v167 <= v166)
          v169 = v164;
        else
          v169 = (_DWORD)v1307 - v163 - v166;
        v1163 = v169;
        v170 = v153 - v157;
        v1174 = v163;
        v171 = v163 - v165;
        v1186 = v164;
        v1135 = v160 - ((_DWORD)v1307 - (_DWORD)v163);
        v172 = v153 - v164 - v165;
        v173 = v23 == 0;
        v1085 = v152;
        v1292 = (_QWORD *)(v152 + v157);
        v1270 = v168;
        v1078 = (unsigned int *)(v168 + 8 * (v153 & ~v155));
        v1342 = 0;
        v1286 = v153 + 9;
        if (v23)
          v174 = 3;
        else
          v174 = 4;
        v175 = v1334 + 4;
        if (v23)
          v176 = 0;
        else
          v176 = -1;
        v177 = v1183;
        v178 = (unint64_t)(v1335 - 7);
        v1259 = (_DWORD)v1334 - v152;
        v1253 = v151;
        v1233 = v157;
        v1203 = v176;
        v1217 = v171;
        while (1)
        {
          if (v173 == 3)
          {
            v179 = *a3 - 1;
            v180 = v153 - v179;
            v181 = *a3 - 2;
            if (v181 >= v170)
              goto LABEL_211;
          }
          else
          {
            v179 = a3[v173];
            v180 = v153 - v179;
            v181 = v179 - 1;
            if (v179 - 1 >= v170)
            {
LABEL_211:
              if (v181 < v172 && v157 + ~v180 >= 3)
              {
                v183 = v171 + v180;
                if (*(_DWORD *)v14 == *(_DWORD *)v183)
                {
                  v184 = v175;
                  v1313 = v177;
                  v185 = v26;
                  v186 = v172;
                  v187 = ZSTD_count_2segments(v184, (char *)(v183 + 4), v15, v1307, v1292);
                  v172 = v186;
                  v171 = v1217;
                  LODWORD(v157) = v1233;
                  v154 = (char *)(v1334 + 12);
                  v151 = v1253;
                  v177 = v1313;
                  v153 = v1259;
                  v26 = v185;
                  v14 = v1334;
                  v15 = (unint64_t)v1335;
                  v178 = (unint64_t)(v1335 - 7);
                  v188 = v187 + 4;
                  v175 = v1334 + 4;
                  v176 = v1203;
                  v189 = v188;
                  if (v1313 < v188)
                    goto LABEL_225;
                }
              }
              goto LABEL_208;
            }
          }
          if (v180 < v160 || *(_DWORD *)v14 != *(_DWORD *)&v14[-v179])
            goto LABEL_208;
          v192 = -(uint64_t)v179;
          v193 = (char *)v175 - v179;
          if (v178 <= (unint64_t)v175)
            break;
          v194 = *v175 ^ *(_QWORD *)v193;
          if (v194)
          {
            v188 = (__clz(__rbit64(v194)) >> 3) + 4;
            v189 = v188;
            if (v177 < v188)
              goto LABEL_225;
            goto LABEL_208;
          }
          v196 = 0;
          do
          {
            v195 = &v154[v196];
            if ((unint64_t)&v154[v196] >= v178)
            {
              v193 = &v195[v192];
              if ((unint64_t)v195 >= v1331)
                goto LABEL_235;
              goto LABEL_233;
            }
            v197 = *(_QWORD *)&v154[v192 + v196];
            v196 += 8;
            v198 = *(_QWORD *)v195 ^ v197;
            v14 = v1334;
          }
          while (!v198);
          v188 = v196 + (__clz(__rbit64(v198)) >> 3) + 4;
          v189 = v188;
          if (v177 < v188)
          {
LABEL_225:
            v191 = &v1336[2 * v26];
            *v191 = v173 + v176;
            v191[1] = v188;
            v26 = (v26 + 1);
            if (v188 > v151)
              goto LABEL_603;
            v177 = v189;
            if (&v14[v189] == (unsigned __int8 *)v15)
              goto LABEL_603;
          }
LABEL_208:
          if (++v173 >= v174)
          {
            *(_DWORD *)(v1109 + 4 * v1093) = v153;
            v278 = ~(-1 << v1101);
            v279 = v1143;
            v280 = v1117;
            if (v1117 < v1143)
            {
              v130 = v1304;
              v281 = v1286;
              v282 = v1085;
              v284 = v1078 + 1;
              v283 = v1078;
LABEL_373:
              v1285 = v281;
              *v284 = 0;
              *v283 = 0;
              v1312 = v26;
              if (!v278)
                goto LABEL_601;
              v14 = v1334;
              v285 = *(_DWORD *)(*(_QWORD *)(v1065 + 48)
                               + 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)v1334) >> -(char)v1058));
              if (v285 <= v1186)
                goto LABEL_602;
              v286 = 0;
              v287 = 0;
              v1235 = *(_QWORD *)(v1065 + 64);
              v1244 = v282 + v1135;
              v1219 = v1259 + 2;
              v1261 = v278 - 1;
              while (1)
              {
                v1272 = v285;
                if (v287 >= v286)
                  v288 = v286;
                else
                  v288 = v287;
                v289 = v285;
                v290 = v1174 + v285;
                v291 = v177;
                v292 = ZSTD_count_2segments(&v14[v288], (char *)(v290 + v288), v15, v1307, v1292);
                v293 = v292 + v288;
                if (v292 + v288 + v289 >= v1042)
                  v294 = v1244 + v289;
                else
                  v294 = v290;
                if (v293 <= v291)
                {
                  v177 = v291;
                  v14 = v1334;
                  v15 = (unint64_t)v1335;
                  v130 = v1304;
                  v297 = v1272;
                  if (v1272 <= v1163)
                    goto LABEL_602;
                }
                else
                {
                  v295 = v1285;
                  if (v293 > v1285 - (v1272 + v1135))
                    v295 = v1272 + v1135 + v293;
                  v1285 = v295;
                  v296 = &v1336[2 * v1312];
                  *v296 = v1219 - (v1272 + v1135);
                  v296[1] = v293;
                  ++v1312;
                  if (v293 > 0x1000)
                    goto LABEL_599;
                  v297 = v1272;
                  v14 = v1334;
                  v15 = (unint64_t)v1335;
                  v177 = v292 + v288;
                  v130 = v1304;
                  if (&v1334[v293] == v1335 || v1272 <= v1163)
                    goto LABEL_602;
                }
                v298 = *(unsigned __int8 *)(v294 + v293);
                v299 = v14[v293];
                v63 = v298 >= v299;
                v300 = v298 < v299;
                if (v63)
                  v286 = v292 + v288;
                else
                  v287 = v292 + v288;
                if (v1261)
                {
                  --v1261;
                  v285 = *(_DWORD *)(v1235 + 8 * (v297 & v1152) + 4 * v300);
                  if (v285 > v1186)
                    continue;
                }
                goto LABEL_602;
              }
            }
            v341 = 0;
            v342 = 0;
            v343 = v153 + 2;
            v1317 = v1334 + 8;
            v282 = v1085;
            v344 = v1085 + 8;
            v130 = v1304;
            v281 = v1286;
            v284 = v1078 + 1;
            v283 = v1078;
            v345 = v1127;
            while (2)
            {
              if (v342 >= v341)
                v346 = v341;
              else
                v346 = v342;
              v347 = v280;
              v348 = v280;
              v349 = v1085 + v280;
              v350 = &v1334[v346];
              v351 = (_QWORD *)(v349 + v346);
              if (v1332 <= (char *)&v1334[v346])
              {
                v354 = &v1334[v346];
                if ((unint64_t)v350 >= v1331)
                  goto LABEL_459;
              }
              else
              {
                v352 = *(_QWORD *)v350 ^ *v351;
                if (v352)
                {
                  v353 = (__clz(__rbit64(v352)) >> 3) + v346;
                  if (v353 <= v177)
                    goto LABEL_475;
LABEL_468:
                  if (v353 > v281 - v347)
                    v281 = v347 + v353;
                  v355 = &v1336[2 * v26];
                  *v355 = v343 - v347;
                  v355[1] = v353;
                  LODWORD(v26) = v26 + 1;
                  if (v353 > 0x1000 || &v1334[v353] == (unsigned __int8 *)v15)
                  {
                    v1285 = v281;
                    v1312 = v26;
                    *v284 = 0;
                    *v283 = 0;
                    goto LABEL_601;
                  }
                  v177 = v353;
LABEL_475:
                  v357 = (unsigned int *)(v1270 + 8 * (v347 & v1050));
                  if (*(unsigned __int8 *)(v349 + v353) >= v1334[v353])
                  {
                    *v284 = v347;
                    if (v347 <= v345)
                    {
                      v284 = (unsigned int *)&v1342;
                      goto LABEL_373;
                    }
                    v341 = v353;
                    v284 = (unsigned int *)(v1270 + 8 * (v347 & v1050));
                    v63 = v278-- != 0;
                    if (!v63)
                      goto LABEL_373;
                  }
                  else
                  {
                    *v283 = v347;
                    if (v347 <= v345)
                    {
                      v283 = (unsigned int *)&v1342;
                      goto LABEL_373;
                    }
                    ++v357;
                    v342 = v353;
                    v283 = v357;
                    v63 = v278-- != 0;
                    if (!v63)
                      goto LABEL_373;
                  }
                  v280 = *v357;
                  if (*v357 < v279)
                    goto LABEL_373;
                  continue;
                }
                v358 = v177;
                v359 = 0;
                v360 = (char *)v1317 + v346;
                while (1)
                {
                  v361 = &v360[v359];
                  if (&v360[v359] >= v1332)
                    break;
                  v362 = *(_QWORD *)(v344 + v346 + v348 + v359);
                  v359 += 8;
                  v363 = *(_QWORD *)v361 ^ v362;
                  if (v363)
                  {
                    v364 = __clz(__rbit64(v363));
                    v177 = v358;
                    v345 = v1127;
                    v279 = v1143;
                    v353 = v359 + (v364 >> 3) + v346;
                    if (v353 <= v177)
                      goto LABEL_475;
                    goto LABEL_468;
                  }
                }
                v354 = (unsigned __int8 *)v1317 + v346 + v359;
                v351 = (_QWORD *)(v344 + v346 + v348 + v359);
                v177 = v358;
                v345 = v1127;
                v279 = v1143;
                if ((unint64_t)v354 >= v1331)
                {
LABEL_459:
                  if ((unint64_t)v354 >= v1330)
                  {
                    if ((unint64_t)v354 >= v15)
                      goto LABEL_467;
                  }
                  else
                  {
                    if (*(unsigned __int16 *)v351 == *(unsigned __int16 *)v354)
                    {
                      v354 += 2;
                      v351 = (_QWORD *)((char *)v351 + 2);
                    }
                    if ((unint64_t)v354 >= v15)
                    {
LABEL_467:
                      v353 = v354 - v1334;
                      if (v354 - v1334 <= v177)
                        goto LABEL_475;
                      goto LABEL_468;
                    }
                  }
                  if (*(unsigned __int8 *)v351 == *v354)
                    ++v354;
                  goto LABEL_467;
                }
              }
              break;
            }
            if (*(_DWORD *)v351 == *(_DWORD *)v354)
            {
              v354 += 4;
              v351 = (_QWORD *)((char *)v351 + 4);
            }
            goto LABEL_459;
          }
        }
        v195 = (char *)v175;
        if ((unint64_t)v175 >= v1331)
          goto LABEL_235;
LABEL_233:
        if (*(_DWORD *)v193 == *(_DWORD *)v195)
        {
          v195 += 4;
          v193 += 4;
        }
LABEL_235:
        if ((unint64_t)v195 >= v1330)
        {
          if ((unint64_t)v195 >= v15)
            goto LABEL_243;
        }
        else
        {
          if (*(unsigned __int16 *)v193 == *(unsigned __int16 *)v195)
          {
            v195 += 2;
            v193 += 2;
          }
          if ((unint64_t)v195 >= v15)
          {
LABEL_243:
            v188 = (_DWORD)v195 - (_DWORD)v175 + 4;
            v189 = v188;
            if (v177 < v188)
              goto LABEL_225;
            goto LABEL_208;
          }
        }
        if (*v193 == *v195)
          LODWORD(v195) = (_DWORD)v195 + 1;
        goto LABEL_243;
      }
      if (v28 != 3)
      {
        v26 = 0;
        if (*(_DWORD *)(v7 + 212) >= 0xFFFu)
          v199 = 4095;
        else
          v199 = *(_DWORD *)(v7 + 212);
        v200 = *(_QWORD *)(v7 + 8);
        v201 = (_DWORD)v1334 - v200;
        v202 = (char *)(v1334 + 12);
        v1102 = *(_DWORD *)(v7 + 204);
        v1110 = *(_QWORD *)(v7 + 48);
        v1094 = (-1640531535 * *(_DWORD *)v1334) >> -(char)*(_DWORD *)(v7 + 200);
        v1118 = *(_DWORD *)(v1110 + 4 * v1094);
        v203 = -1 << (*(_DWORD *)(v7 + 196) - 1);
        v1051 = ~v203;
        v204 = (_DWORD)v1334 - v200 + v203 + 1;
        if ((int)v1334 - (int)v200 < ~v203)
          v204 = 0;
        v1128 = v204;
        v205 = *(unsigned int *)(v7 + 24);
        v206 = 1 << *(_DWORD *)(v7 + 192);
        v14 = v1334;
        if (v201 - *(_DWORD *)(v7 + 28) > v206 && *(_DWORD *)(v7 + 32) == 0)
          v208 = v201 - v206;
        else
          v208 = *(_DWORD *)(v7 + 28);
        if (v208 <= 1)
          v209 = 1;
        else
          v209 = v208;
        v1144 = v209;
        v210 = *(_QWORD *)(v7 + 184);
        v211 = *(_QWORD *)(v210 + 8);
        v1308 = *(char **)v210;
        v212 = *(_DWORD *)(v210 + 28);
        v213 = v208 - (*(_QWORD *)v210 - (_DWORD)v211);
        v1066 = v210;
        v1059 = *(_DWORD *)(v210 + 200);
        v214 = ~(-1 << (*(_DWORD *)(v210 + 196) - 1));
        v215 = *(_QWORD *)v210 - v211 - v212;
        v216 = *(_QWORD *)(v7 + 64);
        v1043 = (_DWORD)v1308 - v211;
        v1153 = v214;
        if (v215 <= v214)
          v217 = v212;
        else
          v217 = (_DWORD)v1308 - v211 - v214;
        v1164 = v217;
        v218 = v201 - v205;
        v1175 = v211;
        v219 = v211 - v213;
        v1187 = v212;
        v1136 = v208 - ((_DWORD)v1308 - (_DWORD)v211);
        v220 = v201 - v212 - v213;
        v221 = v23 == 0;
        v1086 = v200;
        v1293 = (_QWORD *)(v200 + v205);
        v1271 = v216;
        v1079 = (unsigned int *)(v216 + 8 * (v201 & ~v203));
        v1342 = 0;
        v1287 = v201 + 9;
        if (v23)
          v222 = 3;
        else
          v222 = 4;
        v223 = v1334 + 4;
        if (v23)
          v224 = 0;
        else
          v224 = -1;
        v225 = v1183;
        v226 = (unint64_t)(v1335 - 7);
        v1260 = v201;
        v1254 = v199;
        v1234 = v205;
        v1204 = v222;
        v1218 = v211 - v213;
        while (1)
        {
          if (v221 == 3)
          {
            v227 = *a3 - 1;
            v228 = v201 - v227;
            v229 = *a3 - 2;
            if (v229 >= v218)
              goto LABEL_279;
          }
          else
          {
            v227 = a3[v221];
            v228 = v201 - v227;
            v229 = v227 - 1;
            if (v227 - 1 >= v218)
            {
LABEL_279:
              if (v229 < v220 && v205 + ~v228 >= 3)
              {
                v231 = v219 + v228;
                if (*(_DWORD *)v14 == *(_DWORD *)v231)
                {
                  v232 = v223;
                  v1314 = v225;
                  v233 = v26;
                  v234 = v224;
                  v235 = ZSTD_count_2segments(v232, (char *)(v231 + 4), v15, v1308, v1293);
                  v224 = v234;
                  v219 = v1218;
                  LODWORD(v205) = v1234;
                  v202 = (char *)(v1334 + 12);
                  v199 = v1254;
                  v225 = v1314;
                  v201 = v1260;
                  v26 = v233;
                  v14 = v1334;
                  v15 = (unint64_t)v1335;
                  v226 = (unint64_t)(v1335 - 7);
                  v236 = v235 + 4;
                  v223 = v1334 + 4;
                  v222 = v1204;
                  v237 = v236;
                  if (v1314 < v236)
                    goto LABEL_293;
                }
              }
              goto LABEL_276;
            }
          }
          if (v228 < v208 || *(_DWORD *)v14 != *(_DWORD *)&v14[-v227])
            goto LABEL_276;
          v240 = -(uint64_t)v227;
          v241 = (char *)v223 - v227;
          if (v226 <= (unint64_t)v223)
            break;
          v242 = *v223 ^ *(_QWORD *)v241;
          if (v242)
          {
            v236 = (__clz(__rbit64(v242)) >> 3) + 4;
            v237 = v236;
            if (v225 < v236)
              goto LABEL_293;
            goto LABEL_276;
          }
          v244 = 0;
          do
          {
            v243 = &v202[v244];
            if ((unint64_t)&v202[v244] >= v226)
            {
              v241 = &v243[v240];
              if ((unint64_t)v243 >= v1331)
                goto LABEL_303;
              goto LABEL_301;
            }
            v245 = *(_QWORD *)&v202[v240 + v244];
            v244 += 8;
            v246 = *(_QWORD *)v243 ^ v245;
            v14 = v1334;
          }
          while (!v246);
          v236 = v244 + (__clz(__rbit64(v246)) >> 3) + 4;
          v237 = v236;
          if (v225 < v236)
          {
LABEL_293:
            v239 = &v1336[2 * v26];
            *v239 = v221 + v224;
            v239[1] = v236;
            v26 = (v26 + 1);
            if (v236 > v199)
              goto LABEL_603;
            v225 = v237;
            if (&v14[v237] == (unsigned __int8 *)v15)
              goto LABEL_603;
          }
LABEL_276:
          if (++v221 >= v222)
          {
            *(_DWORD *)(v1110 + 4 * v1094) = v201;
            v301 = ~(-1 << v1102);
            v302 = v1144;
            v303 = v1118;
            if (v1118 < v1144)
            {
              v130 = v1304;
              v131 = v1287;
              v304 = v1086;
              v134 = v1079 + 1;
              v133 = v1079;
              goto LABEL_398;
            }
            v365 = 0;
            v366 = 0;
            v367 = v201 + 2;
            v1318 = v1334 + 8;
            v304 = v1086;
            v368 = v1086 + 8;
            v130 = v1304;
            v131 = v1287;
            v134 = v1079 + 1;
            v133 = v1079;
            v369 = v1128;
            while (1)
            {
              v370 = v366 >= v365 ? v365 : v366;
              v371 = v303;
              v372 = v303;
              v373 = v1086 + v303;
              v374 = &v1334[v370];
              v375 = (_QWORD *)(v373 + v370);
              if (v1332 <= (char *)&v1334[v370])
                break;
              v376 = *(_QWORD *)v374 ^ *v375;
              if (v376)
              {
                v377 = (__clz(__rbit64(v376)) >> 3) + v370;
                if (v377 <= v225)
                  goto LABEL_517;
LABEL_510:
                if (v377 > v131 - v371)
                  v131 = v371 + v377;
                v379 = &v1336[2 * v26];
                *v379 = v367 - v371;
                v379[1] = v377;
                LODWORD(v26) = v26 + 1;
                if (v377 <= 0x1000 && &v1334[v377] != (unsigned __int8 *)v15)
                {
                  v225 = v377;
                  goto LABEL_517;
                }
LABEL_574:
                v1285 = v131;
                v1312 = v26;
                *v134 = 0;
                *v133 = 0;
                goto LABEL_601;
              }
              v382 = v225;
              v383 = 0;
              v384 = (char *)v1318 + v370;
              do
              {
                v385 = &v384[v383];
                if (&v384[v383] >= v1332)
                {
                  v378 = (unsigned __int8 *)v1318 + v370 + v383;
                  v375 = (_QWORD *)(v368 + v370 + v372 + v383);
                  v225 = v382;
                  v369 = v1128;
                  v302 = v1144;
                  if ((unint64_t)v378 >= v1331)
                    goto LABEL_501;
                  goto LABEL_499;
                }
                v386 = *(_QWORD *)(v368 + v370 + v372 + v383);
                v383 += 8;
                v387 = *(_QWORD *)v385 ^ v386;
              }
              while (!v387);
              v388 = __clz(__rbit64(v387));
              v225 = v382;
              v369 = v1128;
              v302 = v1144;
              v377 = v383 + (v388 >> 3) + v370;
              if (v377 > v225)
                goto LABEL_510;
LABEL_517:
              v381 = (unsigned int *)(v1271 + 8 * (v371 & v1051));
              if (*(unsigned __int8 *)(v373 + v377) >= v1334[v377])
              {
                *v134 = v371;
                if (v371 <= v369)
                {
                  v134 = (unsigned int *)&v1342;
                  goto LABEL_398;
                }
                v365 = v377;
                v134 = (unsigned int *)(v1271 + 8 * (v371 & v1051));
                v63 = v301-- != 0;
                if (v63)
                  goto LABEL_490;
LABEL_398:
                v1285 = v131;
                *v134 = 0;
                *v133 = 0;
                v1312 = v26;
                if (v301)
                {
                  v14 = v1334;
                  v305 = *(_DWORD *)(*(_QWORD *)(v1066 + 48)
                                   + 4 * ((-1640531535 * *(_DWORD *)v1334) >> -(char)v1059));
                  if (v305 > v1187)
                  {
                    v306 = 0;
                    v307 = 0;
                    v1236 = *(_QWORD *)(v1066 + 64);
                    v1245 = v304 + v1136;
                    v1220 = v1260 + 2;
                    v1262 = v301 - 1;
                    while (1)
                    {
                      v1273 = v305;
                      if (v307 >= v306)
                        v308 = v306;
                      else
                        v308 = v307;
                      v309 = v305;
                      v310 = v1175 + v305;
                      v311 = v225;
                      v312 = ZSTD_count_2segments(&v14[v308], (char *)(v310 + v308), v15, v1308, v1293);
                      v313 = v312 + v308;
                      if (v312 + v308 + v309 >= v1043)
                        v314 = v1245 + v309;
                      else
                        v314 = v310;
                      if (v313 <= v311)
                      {
                        v225 = v311;
                        v14 = v1334;
                        v15 = (unint64_t)v1335;
                        v130 = v1304;
                        v317 = v1273;
                        if (v1273 <= v1164)
                          break;
                      }
                      else
                      {
                        v315 = v1285;
                        if (v313 > v1285 - (v1273 + v1136))
                          v315 = v1273 + v1136 + v313;
                        v1285 = v315;
                        v316 = &v1336[2 * v1312];
                        *v316 = v1220 - (v1273 + v1136);
                        v316[1] = v313;
                        ++v1312;
                        if (v313 > 0x1000)
                          goto LABEL_599;
                        v317 = v1273;
                        v14 = v1334;
                        v15 = (unint64_t)v1335;
                        v225 = v312 + v308;
                        v130 = v1304;
                        if (&v1334[v313] == v1335 || v1273 <= v1164)
                          break;
                      }
                      v318 = *(unsigned __int8 *)(v314 + v313);
                      v319 = v14[v313];
                      v63 = v318 >= v319;
                      v320 = v318 < v319;
                      if (v63)
                        v306 = v312 + v308;
                      else
                        v307 = v312 + v308;
                      if (v1262)
                      {
                        --v1262;
                        v305 = *(_DWORD *)(v1236 + 8 * (v317 & v1153) + 4 * v320);
                        if (v305 > v1187)
                          continue;
                      }
                      break;
                    }
                  }
LABEL_602:
                  *(_DWORD *)(v130 + 36) = v1285 - 8;
                  LODWORD(v26) = v1312;
LABEL_603:
                  v7 = v1304;
                  LODWORD(v10) = v1250;
                  v27 = (uint64_t)v1336;
                  v17 = v11 + 7;
                  goto LABEL_604;
                }
LABEL_601:
                v14 = v1334;
                goto LABEL_602;
              }
              *v133 = v371;
              if (v371 <= v369)
              {
                v133 = (unsigned int *)&v1342;
                goto LABEL_398;
              }
              ++v381;
              v366 = v377;
              v133 = v381;
              v63 = v301-- != 0;
              if (!v63)
                goto LABEL_398;
LABEL_490:
              v303 = *v381;
              if (*v381 < v302)
                goto LABEL_398;
            }
            v378 = &v1334[v370];
            if ((unint64_t)v374 >= v1331)
              goto LABEL_501;
LABEL_499:
            if (*(_DWORD *)v375 == *(_DWORD *)v378)
            {
              v378 += 4;
              v375 = (_QWORD *)((char *)v375 + 4);
            }
LABEL_501:
            if ((unint64_t)v378 >= v1330)
            {
              if ((unint64_t)v378 >= v15)
                goto LABEL_509;
            }
            else
            {
              if (*(unsigned __int16 *)v375 == *(unsigned __int16 *)v378)
              {
                v378 += 2;
                v375 = (_QWORD *)((char *)v375 + 2);
              }
              if ((unint64_t)v378 >= v15)
              {
LABEL_509:
                v377 = v378 - v1334;
                if (v378 - v1334 <= v225)
                  goto LABEL_517;
                goto LABEL_510;
              }
            }
            if (*(unsigned __int8 *)v375 == *v378)
              ++v378;
            goto LABEL_509;
          }
        }
        v243 = (char *)v223;
        if ((unint64_t)v223 >= v1331)
          goto LABEL_303;
LABEL_301:
        if (*(_DWORD *)v241 == *(_DWORD *)v243)
        {
          v243 += 4;
          v241 += 4;
        }
LABEL_303:
        if ((unint64_t)v243 >= v1330)
        {
          if ((unint64_t)v243 >= v15)
            goto LABEL_311;
        }
        else
        {
          if (*(unsigned __int16 *)v241 == *(unsigned __int16 *)v243)
          {
            v243 += 2;
            v241 += 2;
          }
          if ((unint64_t)v243 >= v15)
          {
LABEL_311:
            v236 = (_DWORD)v243 - (_DWORD)v223 + 4;
            v237 = v236;
            if (v225 < v236)
              goto LABEL_293;
            goto LABEL_276;
          }
        }
        if (*v241 == *v243)
          LODWORD(v243) = (_DWORD)v243 + 1;
        goto LABEL_311;
      }
      v26 = 0;
      if (*(_DWORD *)(v7 + 212) >= 0xFFFu)
        v31 = 4095;
      else
        v31 = *(_DWORD *)(v7 + 212);
      v32 = *(_QWORD *)(v7 + 8);
      v33 = (_DWORD)v1334 - v32;
      v34 = (char *)(v1334 + 11);
      v1071 = *(_DWORD *)(v7 + 204);
      v1076 = *(_QWORD *)(v7 + 48);
      v1063 = (-1640531535 * *(_DWORD *)v1334) >> -(char)*(_DWORD *)(v7 + 200);
      v35 = *(_DWORD *)(v1076 + 4 * v1063);
      v36 = -1 << (*(_DWORD *)(v7 + 196) - 1);
      v1115 = ~v36;
      v37 = (_DWORD)v1334 - v32 + v36 + 1;
      if ((int)v1334 - (int)v32 < ~v36)
        v37 = 0;
      v1107 = v37;
      v38 = *(unsigned int *)(v7 + 24);
      v39 = 1 << *(_DWORD *)(v7 + 192);
      v14 = v1334;
      if (v33 - *(_DWORD *)(v7 + 28) > v39 && *(_DWORD *)(v7 + 32) == 0)
        v41 = v33 - v39;
      else
        v41 = *(_DWORD *)(v7 + 28);
      if (v41 <= 1)
        v42 = 1;
      else
        v42 = v41;
      v1310 = v42;
      v43 = *(_QWORD *)(v7 + 184);
      v44 = *(_QWORD *)(v43 + 8);
      v1305 = *(char **)v43;
      v45 = *(_DWORD *)(v43 + 28);
      v46 = v41 - (*(_QWORD *)v43 - (_DWORD)v44);
      v1056 = v43;
      v1048 = *(_DWORD *)(v43 + 200);
      v47 = ~(-1 << (*(_DWORD *)(v43 + 196) - 1));
      v48 = *(_QWORD *)v43 - v44 - v45;
      v49 = *(_QWORD *)(v7 + 64);
      v1040 = (_DWORD)v1305 - v44;
      v1214 = v47;
      if (v48 <= v47)
        v50 = v45;
      else
        v50 = (_DWORD)v1305 - v44 - v47;
      v1230 = v50;
      v51 = v33 - v38;
      v1242 = v44;
      v52 = v44 - v46;
      v1251 = v45;
      v1125 = v41 - ((_DWORD)v1305 - (_DWORD)v44);
      v53 = v33 - v45 - v46;
      v54 = v23 == 0;
      v1290 = (_QWORD *)(v32 + v38);
      v1267 = v49;
      v1091 = (unsigned int *)(v49 + 8 * (v33 & ~v36));
      v1099 = v32;
      v1342 = 0;
      v1283 = v33 + 9;
      if (v23)
        v55 = 3;
      else
        v55 = 4;
      v56 = v1334 + 3;
      if (v23)
        v57 = 0;
      else
        v57 = -1;
      v58 = v1183;
      v59 = (unint64_t)(v1335 - 7);
      v1201 = v31;
      v1184 = v35;
      v1172 = v38;
      v1161 = v33 - v38;
      v1141 = v55;
      v1150 = v33;
      v1133 = v57;
      do
      {
        if (v54 == 3)
        {
          v60 = *a3 - 1;
          v61 = v33 - v60;
          v62 = *a3 - 2;
          if (v62 >= v51)
            goto LABEL_50;
        }
        else
        {
          v60 = a3[v54];
          v61 = v33 - v60;
          v62 = v60 - 1;
          if (v60 - 1 >= v51)
          {
LABEL_50:
            v63 = v62 < v53 && v38 + ~v61 >= 3;
            if (!v63)
              goto LABEL_47;
            v64 = v52 + v61;
            if (((*(_DWORD *)v64 ^ *(_DWORD *)v14) & 0xFFFFFF) != 0)
              goto LABEL_47;
            v1256 = v58;
            v65 = v26;
            v66 = v56;
            v67 = ZSTD_count_2segments(v56, (char *)(v64 + 3), v15, v1305, v1290);
            v57 = v1133;
            v55 = v1141;
            v56 = v66;
            LODWORD(v38) = v1172;
            v34 = (char *)(v1334 + 11);
            v35 = v1184;
            v58 = v1256;
            v26 = v65;
            v33 = v1150;
            v51 = v1161;
            v14 = v1334;
            v15 = (unint64_t)v1335;
            v59 = (unint64_t)(v1335 - 7);
            v68 = v67 + 3;
            v31 = v1201;
            v69 = v68;
            if (v1256 >= v68)
              goto LABEL_47;
            goto LABEL_64;
          }
        }
        if (v61 < v41 || ((*(_DWORD *)&v14[-v60] ^ *(_DWORD *)v14) & 0xFFFFFF) != 0)
          goto LABEL_47;
        v72 = -(uint64_t)v60;
        v73 = (char *)v56 - v60;
        if (v59 <= (unint64_t)v56)
        {
          v75 = (char *)v56;
          if ((unint64_t)v56 < v1331)
          {
LABEL_72:
            if (*(_DWORD *)v73 == *(_DWORD *)v75)
            {
              v75 += 4;
              v73 += 4;
            }
          }
LABEL_74:
          if ((unint64_t)v75 >= v1330)
          {
            if ((unint64_t)v75 >= v15)
              goto LABEL_82;
          }
          else
          {
            if (*(unsigned __int16 *)v73 == *(unsigned __int16 *)v75)
            {
              v75 += 2;
              v73 += 2;
            }
            if ((unint64_t)v75 >= v15)
            {
LABEL_82:
              v68 = (_DWORD)v75 - (_DWORD)v56 + 3;
              v69 = v68;
              if (v58 >= v68)
                goto LABEL_47;
LABEL_64:
              v71 = &v1336[2 * v26];
              *v71 = v54 + v57;
              v71[1] = v68;
              v26 = (v26 + 1);
              if (v68 <= v31)
              {
                v58 = v69;
                if (&v14[v69] != (unsigned __int8 *)v15)
                  goto LABEL_47;
              }
              goto LABEL_603;
            }
          }
          if (*v73 == *v75)
            LODWORD(v75) = (_DWORD)v75 + 1;
          goto LABEL_82;
        }
        v74 = *v56 ^ *(_QWORD *)v73;
        if (v74)
        {
          v68 = (__clz(__rbit64(v74)) >> 3) + 3;
          v69 = v68;
          if (v58 >= v68)
            goto LABEL_47;
          goto LABEL_64;
        }
        v76 = 0;
        do
        {
          v75 = &v34[v76];
          if ((unint64_t)&v34[v76] >= v59)
          {
            v73 = &v75[v72];
            if ((unint64_t)v75 < v1331)
              goto LABEL_72;
            goto LABEL_74;
          }
          v77 = *(_QWORD *)&v34[v72 + v76];
          v76 += 8;
          v78 = *(_QWORD *)v75 ^ v77;
          v14 = v1334;
        }
        while (!v78);
        v68 = v76 + (__clz(__rbit64(v78)) >> 3) + 3;
        v69 = v68;
        if (v58 < v68)
          goto LABEL_64;
LABEL_47:
        ++v54;
      }
      while (v54 < v55);
      if (v58 > 2)
      {
        v7 = v1304;
        LODWORD(v10) = v1250;
        v27 = (uint64_t)v1336;
        v250 = v1099;
        goto LABEL_422;
      }
      v7 = v1304;
      v247 = *(_QWORD *)(v1304 + 56);
      v248 = *(_DWORD *)v14;
      v249 = 32 - *(_DWORD *)(v1304 + 40);
      v27 = (uint64_t)v1336;
      v250 = v1099;
      if (v1009 < v33)
      {
        v251 = v1009;
        do
        {
          *(_DWORD *)(v247 + 4 * ((900185344 * *(_DWORD *)(v1099 + v251)) >> v249)) = v251;
          ++v251;
        }
        while (v33 != v251);
      }
      v252 = *(unsigned int *)(v247 + 4 * ((900185344 * v248) >> v249));
      v253 = v252 >= v1310 && (v33 - v252) >> 18 == 0;
      LODWORD(v10) = v1250;
      v17 = v11 + 7;
      if (!v253)
      {
        v1009 = v33;
        goto LABEL_422;
      }
      v413 = (_DWORD *)(v1099 + v252);
      v14 = v1334;
      if (v59 <= (unint64_t)v1334)
      {
        v416 = v1334;
        if ((unint64_t)v1334 < v1331)
        {
LABEL_582:
          if (*v413 == *(_DWORD *)v416)
          {
            v416 += 4;
            ++v413;
          }
        }
      }
      else
      {
        v414 = *(_QWORD *)v1334 ^ *(_QWORD *)v413;
        if (v414)
        {
          v415 = __clz(__rbit64(v414)) >> 3;
          v1009 = v33;
          if (v415 < 3)
            goto LABEL_422;
          goto LABEL_593;
        }
        v999 = 0;
        v1000 = v1334 + 8;
        while (1)
        {
          v1001 = &v1000[v999 / 8];
          if ((unint64_t)&v1000[v999 / 8] >= v59)
            break;
          v1002 = *(_QWORD *)(v1099 + v252 + 8 + v999);
          v999 += 8;
          v1003 = *v1001 ^ v1002;
          if (v1003)
          {
            v415 = v999 + (__clz(__rbit64(v1003)) >> 3);
            v14 = v1334;
            v1009 = v33;
            if (v415 >= 3)
              goto LABEL_593;
            goto LABEL_422;
          }
        }
        v416 = &v1334[v999 + 8];
        v413 = (_DWORD *)(v1099 + v252 + v999 + 8);
        if ((unint64_t)v416 < v1331)
          goto LABEL_582;
      }
      if ((unint64_t)v416 >= v1330)
      {
        if ((unint64_t)v416 >= v15)
          goto LABEL_592;
LABEL_590:
        if (*(unsigned __int8 *)v413 == *v416)
          ++v416;
        goto LABEL_592;
      }
      if (*(unsigned __int16 *)v413 == *(unsigned __int16 *)v416)
      {
        v416 += 2;
        v413 = (_DWORD *)((char *)v413 + 2);
      }
      if ((unint64_t)v416 < v15)
        goto LABEL_590;
LABEL_592:
      v14 = v1334;
      v415 = v416 - v1334;
      v1009 = v33;
      if (v415 < 3)
        goto LABEL_422;
LABEL_593:
      *v1336 = v33 - v252 + 2;
      v1336[1] = v415;
      if (v415 > v31 || &v14[v415] == (unsigned __int8 *)v15)
      {
        LODWORD(v26) = 1;
        v1009 = v33;
        *(_DWORD *)(v1304 + 36) = v33 + 1;
        goto LABEL_604;
      }
      LODWORD(v26) = 1;
      v1009 = v33;
      v58 = v415;
LABEL_422:
      *(_DWORD *)(v1076 + 4 * v1063) = v33;
      v321 = ~(-1 << v1071);
      if (v35 < v1310)
      {
        v322 = v1283;
        v324 = v1091 + 1;
        v323 = v1091;
        goto LABEL_424;
      }
      v389 = 0;
      v390 = 0;
      v1192 = v250 + 8;
      v1205 = v1334 + 8;
      v322 = v1283;
      v324 = v1091 + 1;
      v323 = v1091;
      v391 = v1115;
      v392 = v1107;
      while (2)
      {
        if (v390 >= v389)
          v393 = v389;
        else
          v393 = v390;
        v394 = v250 + v35;
        v395 = &v1334[v393];
        v396 = (_DWORD *)(v394 + v393);
        if (v59 <= (unint64_t)&v1334[v393])
        {
          v399 = &v1334[v393];
          v400 = v35;
          if ((unint64_t)v395 < v1331)
          {
LABEL_541:
            if (*v396 == *(_DWORD *)v399)
            {
              v399 += 4;
              ++v396;
            }
          }
        }
        else
        {
          v397 = *(_QWORD *)v395 ^ *(_QWORD *)v396;
          if (v397)
          {
            v398 = (__clz(__rbit64(v397)) >> 3) + v393;
            if (v398 <= v58)
              goto LABEL_559;
            goto LABEL_552;
          }
          v400 = v35;
          v404 = v324;
          v405 = v323;
          v406 = v58;
          v407 = 0;
          v408 = (char *)v1205 + v393;
          while (1)
          {
            v409 = &v408[v407];
            if ((unint64_t)&v408[v407] >= v59)
              break;
            v410 = *(_QWORD *)(v1192 + v393 + v35 + v407);
            v407 += 8;
            v411 = *(_QWORD *)v409 ^ v410;
            if (v411)
            {
              v412 = __clz(__rbit64(v411));
              v58 = v406;
              v323 = v405;
              v324 = v404;
              v391 = v1115;
              v392 = v1107;
              v398 = v407 + (v412 >> 3) + v393;
              if (v398 > v58)
                goto LABEL_552;
              goto LABEL_559;
            }
          }
          v399 = (unsigned __int8 *)v1205 + v393 + v407;
          v396 = (_DWORD *)(v1192 + v393 + v35 + v407);
          v58 = v406;
          v323 = v405;
          v324 = v404;
          v391 = v1115;
          v392 = v1107;
          if ((unint64_t)v399 < v1331)
            goto LABEL_541;
        }
        if ((unint64_t)v399 >= v1330)
        {
          if ((unint64_t)v399 >= v15)
            goto LABEL_551;
LABEL_549:
          if (*(unsigned __int8 *)v396 == *v399)
            ++v399;
          goto LABEL_551;
        }
        if (*(unsigned __int16 *)v396 == *(unsigned __int16 *)v399)
        {
          v399 += 2;
          v396 = (_DWORD *)((char *)v396 + 2);
        }
        if ((unint64_t)v399 < v15)
          goto LABEL_549;
LABEL_551:
        v35 = v400;
        v398 = v399 - v1334;
        if (v399 - v1334 <= v58)
          goto LABEL_559;
LABEL_552:
        if (v398 > v322 - v35)
          v322 = v35 + v398;
        v401 = (_DWORD *)(v27 + 8 * v26);
        *v401 = v33 + 2 - v35;
        v401[1] = v398;
        LODWORD(v26) = v26 + 1;
        if (v398 > 0x1000 || &v1334[v398] == (unsigned __int8 *)v15)
        {
          v1288 = v322;
          v1316 = v26;
          *v324 = 0;
          *v323 = 0;
          v14 = v1334;
          goto LABEL_1402;
        }
        v58 = v398;
LABEL_559:
        v403 = (unsigned int *)(v1267 + 8 * (v35 & v391));
        if (*(unsigned __int8 *)(v394 + v398) < v1334[v398])
        {
          *v323 = v35;
          if (v35 <= v392)
          {
            v323 = (unsigned int *)&v1342;
            goto LABEL_424;
          }
          ++v403;
          v390 = v398;
          v323 = v403;
          v63 = v321-- != 0;
          if (!v63)
            goto LABEL_424;
          goto LABEL_532;
        }
        *v324 = v35;
        if (v35 > v392)
        {
          v389 = v398;
          v324 = (unsigned int *)(v1267 + 8 * (v35 & v391));
          v63 = v321-- != 0;
          if (!v63)
            goto LABEL_424;
LABEL_532:
          v35 = *v403;
          if (*v403 < v1310)
            goto LABEL_424;
          continue;
        }
        break;
      }
      v324 = (unsigned int *)&v1342;
LABEL_424:
      v1288 = v322;
      *v324 = 0;
      *v323 = 0;
      v1316 = v26;
      if (!v321)
      {
        v14 = v1334;
        goto LABEL_1402;
      }
      v14 = v1334;
      v325 = *(_DWORD *)(*(_QWORD *)(v1056 + 48) + 4
                                                 * ((-1640531535 * *(_DWORD *)v1334) >> -(char)v1048));
      if (v325 <= v1251)
        goto LABEL_1402;
      v326 = 0;
      v327 = v250;
      v328 = 0;
      v1188 = *(_QWORD *)(v1056 + 64);
      v1191 = v327 + v1125;
      v1176 = v33 + 2;
      v1263 = v321 - 1;
      while (2)
      {
        v1274 = v325;
        if (v328 >= v326)
          v10 = v326;
        else
          v10 = v328;
        v329 = v325;
        v330 = v1242 + v325;
        v331 = v58;
        v332 = ZSTD_count_2segments(&v14[v10], (char *)(v330 + v10), v15, v1305, v1290);
        v333 = v332 + v10;
        if (v332 + v10 + v329 >= v1040)
          v334 = v1191 + v329;
        else
          v334 = v330;
        if (v333 <= v331)
        {
          v58 = v331;
          v14 = v1334;
          v15 = (unint64_t)v1335;
          v7 = v1304;
          LODWORD(v10) = v1250;
          v337 = v1274;
          if (v1274 <= v1230)
            goto LABEL_1402;
          goto LABEL_441;
        }
        v335 = v1288;
        if (v333 > v1288 - (v1274 + (_DWORD)v1125))
          v335 = v1274 + v1125 + v333;
        v1288 = v335;
        v336 = &v1336[2 * v1316];
        *v336 = v1176 - (v1274 + v1125);
        v336[1] = v333;
        ++v1316;
        if (v333 <= 0x1000)
        {
          v337 = v1274;
          v14 = v1334;
          v15 = (unint64_t)v1335;
          v58 = v332 + v10;
          v7 = v1304;
          LODWORD(v10) = v1250;
          if (&v1334[v333] == v1335 || v1274 <= v1230)
            goto LABEL_1402;
LABEL_441:
          v338 = *(unsigned __int8 *)(v334 + v333);
          v339 = v14[v333];
          v63 = v338 >= v339;
          v340 = v338 < v339;
          if (v63)
            v326 = v333;
          else
            v328 = v333;
          if (!v1263)
            goto LABEL_1402;
          --v1263;
          v325 = *(_DWORD *)(v1188 + 8 * (v337 & v1214) + 4 * v340);
          if (v325 <= v1251)
            goto LABEL_1402;
          continue;
        }
        break;
      }
      v14 = v1334;
      LODWORD(v15) = (_DWORD)v1335;
      v7 = v1304;
      LODWORD(v10) = v1250;
LABEL_1402:
      v27 = (uint64_t)v1336;
      v17 = v11 + 7;
      LODWORD(v26) = v1316;
      *(_DWORD *)(v7 + 36) = v1288 - 8;
LABEL_604:
      v1338 = v26;
      v418 = v14;
      ZSTD_optLdm_processMatchCandidate((uint64_t *)&v1339, v27, &v1338, (_DWORD)v14 - (_DWORD)v1266, v15 - (_DWORD)v14);
      LODWORD(v419) = v1338;
      if (v1338)
      {
        v11[4] = *a3;
        v11[5] = a3[1];
        v11[6] = a3[2];
        v11[2] = 0;
        v11[3] = v23;
        v420 = *(_DWORD *)(v7 + 160);
        if (v420 != 1)
        {
          v15 = (unint64_t)v1335;
          if (v23 < 0x40)
            v426 = ZSTD_LLcode_LL_Code[v23];
          else
            v426 = 50 - __clz(v23);
          v427 = 4 * v426;
          v428 = *(_DWORD *)(v7 + 148);
          v429 = v428 + (*(unsigned int *)((char *)LL_bits + v427) << 8);
          v430 = *(_DWORD **)(v7 + 88);
          LODWORD(v427) = *(_DWORD *)((char *)v430 + v427) + 1;
          v431 = __clz(v427);
          v422 = v429 - (((_DWORD)v427 << 8 >> (v431 ^ 0x1F)) + ((v431 ^ 0x1F) << 8));
          *v11 = v422;
          v423 = (v419 - 1);
          v424 = *(_DWORD *)(v27 + 8 * v423 + 4);
          if (v424 <= v1190)
          {
            v435 = *v430 + 1;
            v436 = __clz(v435) ^ 0x1F;
            v425 = v428 - ((v435 << 8 >> v436) + (v436 << 8));
            goto LABEL_616;
          }
LABEL_614:
          v432 = 0;
          v433 = *(_DWORD *)(v27 + 8 * v423);
          v434 = (unint64_t)(v1335 - 32);
          goto LABEL_1308;
        }
        v421 = __clz(v23 + 1);
        v422 = ((v23 + 1) << 8 >> (v421 ^ 0x1F)) + ((v421 ^ 0x1F) << 8);
        *v11 = v422;
        v423 = (v419 - 1);
        v424 = *(_DWORD *)(v27 + 8 * v423 + 4);
        v15 = (unint64_t)v1335;
        if (v424 > v1190)
          goto LABEL_614;
        v425 = 256;
LABEL_616:
        v437 = v11 + 14;
        v438 = v1061;
        do
        {
          *(v437 - 7) = 0x40000000;
          *v437 = 0x40000000;
          v437 += 14;
          v438 -= 2;
        }
        while (v438);
        if (v1010 != v1061)
        {
          v439 = v1005;
          v440 = v1006;
          do
          {
            *v440 = 0x40000000;
            v440 += 7;
            --v439;
          }
          while (v439);
        }
        v441 = 0;
        v442 = v425 + v422;
        if (v419 <= 1)
          v419 = 1;
        else
          v419 = v419;
        v443 = v10;
        do
        {
          v444 = (unsigned int *)(v27 + 8 * v441);
          v445 = v444[1];
          if (v443 <= v445)
          {
            v446 = *v444;
            v447 = __clz(v446 + 1) ^ 0x1F;
            if (v420 == 1)
            {
              v448 = (v443 << 8) - 512;
              do
              {
                v449 = __clz(v443 - 2);
                v450 = &v11[7 * v443];
                v450[2] = v443;
                v450[3] = v23;
                *v450 = (v448 >> (v449 ^ 0x1F)) + (((v449 ^ 0x1F) + (_DWORD)v447) << 8) + v442 + 4096;
                v450[1] = v446;
                ++v443;
                v448 += 256;
              }
              while (v443 <= v445);
            }
            else
            {
              v452 = *(_QWORD *)(v7 + 96);
              v451 = *(_QWORD *)(v7 + 104);
              v453 = *(_DWORD *)(v7 + 156) + *(_DWORD *)(v7 + 152) + 51;
              do
              {
                v461 = v443 - 3;
                if (v443 - 3 < 0x80)
                  v454 = ZSTD_MLcode_ML_Code[v461];
                else
                  v454 = 67 - __clz(v461);
                v455 = *(_DWORD *)(v451 + 4 * v447) + 1;
                v456 = __clz(v455);
                v457 = 4 * v454;
                v458 = *(unsigned int *)((char *)ML_bits + v457);
                LODWORD(v457) = *(_DWORD *)(v452 + v457) + 1;
                v459 = __clz(v457) ^ 0x1F;
                LODWORD(v457) = v442
                              + v453
                              - (v455 << 8 >> (v456 ^ 0x1F))
                              - ((_DWORD)v457 << 8 >> v459)
                              + (((_DWORD)v447 + v458 - (v456 ^ 0x1F) - v459) << 8);
                v460 = &v11[7 * v443];
                v460[2] = v443;
                v460[3] = v23;
                *v460 = v457;
                v460[1] = v446;
                ++v443;
              }
              while (v443 <= v445);
            }
          }
          ++v441;
        }
        while (v441 != v419);
        LODWORD(v462) = v443 - 1;
        if (v443 == 1)
        {
LABEL_1304:
          v932 = &v11[7 * v462];
          v433 = v932[1];
          v1083 = *v932;
          v424 = v932[2];
          v23 = v932[3];
          v1343 = *((_QWORD *)v932 + 2);
          v1344 = v932[6];
          if (v462 >= v23 + v424)
            v432 = v462 - (v23 + v424);
          else
            v432 = 0;
          v434 = (unint64_t)(v1335 - 32);
          if (!v424)
            goto LABEL_1388;
          goto LABEL_1308;
        }
        v463 = v1334;
        v1060 = v1334 + 8;
        v464 = (_DWORD)v1334 + 1;
        v465 = 1;
        while (2)
        {
          v466 = v465 - 1;
          v467 = &v11[7 * v465 - 7];
          if (v467[2])
            v468 = 1u;
          else
            v468 = v11[7 * v466 + 3] + 1;
          v469 = v465;
          v470 = &v463[v465];
          v471 = *v467;
          v472 = *(_DWORD *)(v7 + 160);
          if (*(_DWORD *)(v7 + 176) == 2)
          {
            v473 = v471 + 2048;
            if (v472 != 1)
            {
              if (v468 >= 0x40)
                goto LABEL_647;
LABEL_653:
              v474 = ZSTD_LLcode_LL_Code[v468];
              v475 = v468 - 1;
              if (v468 - 1 >= 0x40)
                goto LABEL_654;
LABEL_648:
              v476 = ZSTD_LLcode_LL_Code[v475];
              goto LABEL_655;
            }
LABEL_651:
            v477 = __clz(v468 + 1);
            v478 = ((v468 + 1) << 8 >> (v477 ^ 0x1F)) + ((v477 ^ 0x1F) << 8);
            v479 = __clz(v468) ^ 0x1F;
            v480 = -((v468 << 8 >> v479) + (v479 << 8));
          }
          else
          {
            if (v472 == 1)
            {
              v473 = v471 + 1536;
              goto LABEL_651;
            }
            v481 = *(_DWORD *)(*(_QWORD *)(v7 + 80) + 4 * *(v470 - 1)) + 1;
            v482 = __clz(v481);
            v473 = *(_DWORD *)(v7 + 144) - ((v481 << 8 >> (v482 ^ 0x1F)) + ((v482 ^ 0x1F) << 8)) + v471;
            if (v468 < 0x40)
              goto LABEL_653;
LABEL_647:
            v474 = 50 - __clz(v468);
            v475 = v468 - 1;
            if (v468 - 1 < 0x40)
              goto LABEL_648;
LABEL_654:
            v476 = 50 - __clz(v475);
LABEL_655:
            v483 = 4 * v474;
            v484 = *(unsigned int *)((char *)LL_bits + v483);
            v485 = *(_DWORD *)(v7 + 148);
            v486 = *(_QWORD *)(v7 + 88);
            LODWORD(v483) = *(_DWORD *)(v486 + v483) + 1;
            v487 = __clz(v483) ^ 0x1F;
            v478 = v485 - ((_DWORD)v483 << 8 >> v487) + ((v484 - v487) << 8);
            v488 = 4 * v476;
            v489 = *(unsigned int *)((char *)LL_bits + v488);
            LODWORD(v488) = *(_DWORD *)(v486 + v488) + 1;
            LODWORD(v486) = __clz(v488) ^ 0x1F;
            v480 = ((_DWORD)v488 << 8 >> v486) - v485 + (((_DWORD)v486 - v489) << 8);
          }
          v490 = v473 + v478 + v480;
          v491 = &v11[7 * v469];
          v494 = *v491;
          v492 = v491 + 2;
          v493 = v494;
          if (v490 <= v494)
          {
            v501 = &v11[7 * v469];
            v501[1] = 0;
            v501[2] = 0;
            v501[3] = v468;
            *v501 = v490;
            v493 = v490;
            v463 = v1334;
LABEL_661:
            v502 = 0;
            v503 = &v11[7 * v469];
            v504 = &v11[7 * v466];
            *((_QWORD *)v503 + 2) = *((_QWORD *)v504 + 2);
            v503[6] = v504[6];
            v505 = 1;
            if ((unint64_t)v470 <= v1303)
              goto LABEL_675;
LABEL_640:
            v465 = v469 + 1;
            ++v464;
            if ((int)v469 + 1 > v462)
              goto LABEL_1304;
            continue;
          }
          break;
        }
        v463 = v1334;
        if (!*v492)
          goto LABEL_661;
        v495 = &v11[7 * (v469 - *v492) + 4];
        v496 = v11[7 * v469 + 1];
        if (v496 < 3)
        {
          if (v11[7 * v469 + 3])
            v506 = v11[7 * v469 + 1];
          else
            v506 = v496 + 1;
          if (v506)
          {
            if (v506 == 3)
            {
              v498 = *v495;
              v500 = v498 - 1;
            }
            else
            {
              v500 = v495[v506];
              v498 = *v495;
            }
            v949 = v506 > 1;
            v508 = 2;
            if (v949)
              v508 = 1;
            v497 = &v495[v508];
            v463 = v1334;
          }
          else
          {
            v507 = *(_QWORD *)v495;
            v497 = &v11[7 * (v469 - *v492) + 6];
            v500 = v507;
            v498 = HIDWORD(v507);
          }
        }
        else
        {
          v499 = *v495;
          v497 = &v11[7 * (v469 - *v492) + 5];
          v498 = v499;
          v500 = v496 - 2;
        }
        v505 = 0;
        v509 = *v497;
        v510 = v500 | (v498 << 32);
        v511 = &v11[7 * v469];
        *((_QWORD *)v511 + 2) = v510;
        v511[6] = v509;
        v502 = 1;
        if ((unint64_t)v470 > v1303)
          goto LABEL_640;
LABEL_675:
        if ((_DWORD)v469 == (_DWORD)v462)
          goto LABEL_1304;
        v1289 = v464;
        if (v505)
        {
          v23 = v11[7 * v469 + 3];
          if (*(_DWORD *)(v7 + 160) != 1)
            goto LABEL_678;
LABEL_680:
          v514 = 256;
        }
        else
        {
          v23 = 0;
          if (*(_DWORD *)(v7 + 160) == 1)
            goto LABEL_680;
LABEL_678:
          v512 = **(_DWORD **)(v7 + 88) + 1;
          v513 = __clz(v512) ^ 0x1F;
          v514 = *(_DWORD *)(v7 + 148) - ((v512 << 8 >> v513) + (v513 << 8));
        }
        v1255 = v514;
        v1264 = v493;
        v1189 = v492;
        v1338 = 0;
        v515 = *(_QWORD *)(v7 + 8);
        v516 = *(unsigned int *)(v7 + 36);
        if (v515 + v516 > (unint64_t)v470)
        {
          LODWORD(v517) = 0;
          LODWORD(v10) = v1250;
          goto LABEL_1253;
        }
        v1309 = v470;
        v1319 = v502;
        v518 = *(_DWORD *)(v7 + 208);
        v519 = v7;
        for (j = (_DWORD)v470 - v515; v516 < j; LODWORD(v516) = v521 + v516)
        {
          v521 = ZSTD_insertBt1(v519, (_QWORD *)(v515 + v516), v15, v518, 0);
          v15 = (unint64_t)v1335;
        }
        v522 = &v11[7 * v469 + 4];
        *(_DWORD *)(v519 + 36) = j;
        v7 = v519;
        if ((v518 - 6) < 2)
        {
          v517 = 0;
          if (*(_DWORD *)(v519 + 212) >= 0xFFFu)
            v565 = 4095;
          else
            v565 = *(_DWORD *)(v519 + 212);
          v566 = *(_QWORD *)(v519 + 8);
          v470 = v1309;
          v567 = (_DWORD)v1309 - v566;
          v568 = v1309 + 4;
          v1028 = *(_DWORD *)(v519 + 204);
          v1032 = *(_QWORD *)(v519 + 48);
          v1024 = (0xCF1BBCDCBF9B0000 * *(_QWORD *)v1309) >> -(char)*(_DWORD *)(v519 + 200);
          v1035 = *(_DWORD *)(v1032 + 4 * v1024);
          v569 = -1 << (*(_DWORD *)(v519 + 196) - 1);
          v570 = *(unsigned int *)(v519 + 24);
          v1053 = v566;
          v1247 = (_QWORD *)(v566 + v570);
          v1068 = ~v569;
          v571 = (_DWORD)v1309 - v566 + v569 + 1;
          if (v567 < ~v569)
            v571 = 0;
          v1194 = v571;
          v572 = 1 << *(_DWORD *)(v519 + 192);
          if (v567 - *(_DWORD *)(v519 + 28) > v572 && *(_DWORD *)(v519 + 32) == 0)
            v574 = v567 - v572;
          else
            v574 = *(_DWORD *)(v519 + 28);
          if (v574 <= 1)
            v575 = 1;
          else
            v575 = v574;
          v1222 = v575;
          v1073 = *(_QWORD *)(v519 + 64);
          v1045 = (unsigned int *)(v1073 + 8 * (v567 & ~v569));
          v1207 = v567 + 9;
          v576 = *(_QWORD *)(v519 + 184);
          v577 = *(_QWORD *)(v576 + 8);
          v1238 = *(char **)v576;
          v578 = v574 - (*(_QWORD *)v576 - (_DWORD)v577);
          v1016 = *(_DWORD *)(v576 + 200);
          v1020 = v576;
          v579 = *(_DWORD *)(v576 + 28);
          v580 = ~(-1 << (*(_DWORD *)(v576 + 196) - 1));
          v581 = *(_QWORD *)v576 - v577 - v579;
          v1012 = *(_QWORD *)v576 - v577;
          v582 = *(_QWORD *)v576 - v577 + (-1 << (*(_DWORD *)(v576 + 196) - 1)) + 1;
          v1088 = v580;
          if (v581 <= v580)
            v583 = v579;
          else
            v583 = v582;
          v1096 = v583;
          v1342 = 0;
          v1112 = v579;
          v584 = v567 - v579 - v578;
          v585 = v1319;
          v586 = v1319 << 63 >> 63;
          if ((_DWORD)v1319)
            v587 = 4;
          else
            v587 = 3;
          v588 = v567 - v570;
          v1104 = v577;
          v1080 = v574 - ((_DWORD)v1238 - (_DWORD)v577);
          v589 = v577 - v578;
          v590 = v1183;
          v591 = (unint64_t)(v1335 - 7);
          v1178 = v567;
          v1166 = v565;
          v1155 = v574;
          v1138 = v587;
          v1120 = v567 - v570;
          v1129 = v584;
          while (2)
          {
            if (v585 == 3)
            {
              v592 = *v522 - 1;
              v593 = v567 - v592;
              v594 = *v522 - 2;
              if (v594 >= v588)
                goto LABEL_775;
LABEL_784:
              if (v593 < v574 || *(_DWORD *)v470 != *(_DWORD *)&v470[-v592])
                goto LABEL_772;
              v603 = (_QWORD *)((char *)v568 - v592);
              if (v591 > (unint64_t)v568)
              {
                v604 = v568;
                v605 = *v568 ^ *v603;
                if (v605)
                {
                  v600 = (__clz(__rbit64(v605)) >> 3) + 4;
                  v601 = v600;
                  if (v590 >= v600)
                    goto LABEL_772;
                  goto LABEL_805;
                }
                do
                {
                  ++v603;
                  if ((unint64_t)++v604 >= v591)
                    goto LABEL_797;
                  v606 = *v604 ^ *v603;
                }
                while (!v606);
                v604 = (_QWORD *)((char *)v604 + (__clz(__rbit64(v606)) >> 3));
LABEL_804:
                v600 = (_DWORD)v604 - (_DWORD)v568 + 4;
                v601 = v600;
                if (v590 >= v600)
                  goto LABEL_772;
                goto LABEL_805;
              }
              v604 = v568;
LABEL_797:
              if ((unint64_t)v604 >= v1331)
              {
                if ((unint64_t)v604 < v1330)
                  goto LABEL_809;
LABEL_801:
                if ((unint64_t)v604 >= v15)
                  goto LABEL_804;
              }
              else
              {
                if (*(_DWORD *)v603 == *(_DWORD *)v604)
                {
                  v604 = (_QWORD *)((char *)v604 + 4);
                  v603 = (_QWORD *)((char *)v603 + 4);
                }
                if ((unint64_t)v604 >= v1330)
                  goto LABEL_801;
LABEL_809:
                if (*(unsigned __int16 *)v603 == *(unsigned __int16 *)v604)
                {
                  v604 = (_QWORD *)((char *)v604 + 2);
                  v603 = (_QWORD *)((char *)v603 + 2);
                }
                if ((unint64_t)v604 >= v15)
                  goto LABEL_804;
              }
              if (*(unsigned __int8 *)v603 == *(unsigned __int8 *)v604)
                LODWORD(v604) = (_DWORD)v604 + 1;
              goto LABEL_804;
            }
            v592 = v522[v585];
            v593 = v567 - v592;
            v594 = v592 - 1;
            if (v592 - 1 < v588)
              goto LABEL_784;
LABEL_775:
            if (v594 < v584 && v570 + ~v593 >= 3)
            {
              v596 = v589 + v593;
              if (*(_DWORD *)v470 == *(_DWORD *)v596)
              {
                v1295 = v590;
                v1321 = v517;
                v597 = v570;
                v598 = v586;
                v599 = ZSTD_count_2segments(v568, (char *)(v596 + 4), v15, v1238, v1247);
                v587 = v1138;
                v568 = v1309 + 4;
                v586 = v598;
                v570 = v597;
                v565 = v1166;
                v567 = v1178;
                v522 = &v11[7 * v469 + 4];
                v517 = v1321;
                v574 = v1155;
                v590 = v1295;
                v470 = v1309;
                v591 = (unint64_t)(v1335 - 7);
                v15 = (unint64_t)v1335;
                v600 = v599 + 4;
                v588 = v1120;
                v584 = v1129;
                v601 = v600;
                if (v1295 < v600)
                {
LABEL_805:
                  v607 = &v1336[2 * v517];
                  *v607 = v585 + v586;
                  v607[1] = v600;
                  v517 = (v517 + 1);
                  if (v600 > v565)
                    goto LABEL_1251;
                  v590 = v601;
                  if (&v470[v601] == (unsigned __int8 *)v15)
                    goto LABEL_1251;
                }
              }
            }
LABEL_772:
            if (++v585 < v587)
              continue;
            break;
          }
          *(_DWORD *)(v1032 + 4 * v1024) = v567;
          v608 = ~(-1 << v1028);
          v609 = v1035;
          if (v1035 < v1222)
          {
            v610 = v1304;
            v611 = v1207;
            v612 = v1045;
            v613 = v1053;
            v614 = v1045 + 1;
            goto LABEL_815;
          }
          v722 = 0;
          v723 = 0;
          v1325 = v567 + 2;
          v613 = v1053;
          v1299 = (char *)v1060 + v469;
          v1276 = v1053 + 8;
          v610 = v1304;
          v611 = v1207;
          v614 = v1045 + 1;
          v612 = v1045;
          v724 = v1073;
          v725 = v1068;
          while (2)
          {
            if (v723 >= v722)
              v726 = v722;
            else
              v726 = v723;
            v727 = v609;
            v728 = v609;
            v729 = v1053 + v609;
            v730 = &v470[v726];
            v731 = (_QWORD *)(v729 + v726);
            if (v591 <= (unint64_t)&v470[v726])
            {
              v734 = (char *)&v470[v726];
              if ((unint64_t)v730 >= v1331)
                goto LABEL_983;
            }
            else
            {
              v732 = *(_QWORD *)v730 ^ *v731;
              if (v732)
              {
                v733 = (__clz(__rbit64(v732)) >> 3) + v726;
                if (v733 <= v590)
                  goto LABEL_999;
LABEL_992:
                if (v733 > v611 - v727)
                  v611 = v727 + v733;
                v735 = &v1336[2 * v517];
                *v735 = v1325 - v727;
                v735[1] = v733;
                v517 = (v517 + 1);
                if (v733 > 0x1000 || &v470[v733] == (unsigned __int8 *)v15)
                  goto LABEL_1216;
                v590 = v733;
LABEL_999:
                v737 = (unsigned int *)(v724 + 8 * (v727 & v725));
                if (*(unsigned __int8 *)(v729 + v733) >= v470[v733])
                {
                  *v614 = v727;
                  if (v727 <= v1194)
                  {
                    v614 = (unsigned int *)&v1342;
LABEL_815:
                    v1208 = v611;
                    *v614 = 0;
                    *v612 = 0;
                    v1322 = v517;
                    if (!v608)
                      goto LABEL_1250;
                    v615 = *(_DWORD *)(*(_QWORD *)(v1020 + 48)
                                     + 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)v470) >> -(char)v1016));
                    if (v615 <= v1112)
                      goto LABEL_1250;
                    v616 = 0;
                    v617 = 0;
                    v1146 = *(_QWORD *)(v1020 + 64);
                    v1156 = v613 + v1080;
                    v1179 = v1178 + 2;
                    v1195 = v608 - 1;
                    while (1)
                    {
                      v1275 = v615;
                      v1296 = v590;
                      v1223 = v616;
                      if (v617 >= v616)
                        v618 = v616;
                      else
                        v618 = v617;
                      v619 = v615;
                      v620 = v1104 + v615;
                      v621 = ZSTD_count_2segments(&v470[v618], (char *)(v620 + v618), v15, v1238, v1247);
                      v622 = v621 + v618;
                      v590 = v1296;
                      if (v621 + v618 + v619 >= v1012)
                        v623 = v1156 + v619;
                      else
                        v623 = v620;
                      if (v622 <= v1296)
                      {
                        v15 = (unint64_t)v1335;
                        v610 = v1304;
                        v470 = v1309;
                        v616 = v1223;
                        v626 = v1275;
                        if (v1275 <= v1096)
                          goto LABEL_1250;
                      }
                      else
                      {
                        v624 = v1208;
                        if (v622 > v1208 - (v1275 + (_DWORD)v1080))
                          v624 = v1275 + v1080 + v622;
                        v1208 = v624;
                        v625 = &v1336[2 * v1322];
                        *v625 = v1179 - (v1275 + v1080);
                        v625[1] = v622;
                        ++v1322;
                        if (v622 > 0x1000)
                        {
LABEL_1249:
                          LODWORD(v15) = (_DWORD)v1335;
                          v610 = v1304;
                          LODWORD(v470) = (_DWORD)v1309;
                          goto LABEL_1250;
                        }
                        v626 = v1275;
                        v610 = v1304;
                        v470 = v1309;
                        v590 = v621 + v618;
                        v15 = (unint64_t)v1335;
                        v616 = v1223;
                        if (&v1309[v622] == v1335 || v1275 <= v1096)
                        {
LABEL_1250:
                          *(_DWORD *)(v610 + 36) = v1208 - 8;
                          LODWORD(v517) = v1322;
LABEL_1251:
                          v7 = v1304;
                          goto LABEL_1252;
                        }
                      }
                      v627 = *(unsigned __int8 *)(v623 + v622);
                      v628 = v470[v622];
                      v63 = v627 >= v628;
                      v629 = v627 < v628;
                      if (v63)
                        v616 = v621 + v618;
                      else
                        v617 = v621 + v618;
                      if (v1195)
                      {
                        --v1195;
                        v615 = *(_DWORD *)(v1146 + 8 * (v626 & v1088) + 4 * v629);
                        if (v615 > v1112)
                          continue;
                      }
                      goto LABEL_1250;
                    }
                  }
                  v722 = v733;
                  v614 = (unsigned int *)(v724 + 8 * (v727 & v725));
                  v63 = v608-- != 0;
                  if (!v63)
                    goto LABEL_815;
                }
                else
                {
                  *v612 = v727;
                  if (v727 <= v1194)
                  {
                    v612 = (unsigned int *)&v1342;
                    goto LABEL_815;
                  }
                  ++v737;
                  v723 = v733;
                  v612 = v737;
                  v63 = v608-- != 0;
                  if (!v63)
                    goto LABEL_815;
                }
                v609 = *v737;
                if (v609 < v1222)
                  goto LABEL_815;
                continue;
              }
              v738 = v614;
              v739 = v612;
              v740 = v590;
              v741 = v517;
              v742 = 0;
              v743 = &v1299[v726];
              while (1)
              {
                v744 = &v743[v742];
                if ((unint64_t)&v743[v742] >= v591)
                  break;
                v745 = *(_QWORD *)(v1276 + v726 + v728 + v742);
                v742 += 8;
                v746 = *(_QWORD *)v744 ^ v745;
                if (v746)
                {
                  v747 = __clz(__rbit64(v746));
                  v517 = v741;
                  v590 = v740;
                  v612 = v739;
                  v614 = v738;
                  v724 = v1073;
                  v725 = v1068;
                  v733 = v742 + (v747 >> 3) + v726;
                  if (v733 <= v590)
                    goto LABEL_999;
                  goto LABEL_992;
                }
              }
              v734 = &v1299[v726 + v742];
              v731 = (_QWORD *)(v1276 + v726 + v728 + v742);
              v517 = v741;
              v590 = v740;
              v612 = v739;
              v614 = v738;
              v724 = v1073;
              v725 = v1068;
              if ((unint64_t)v734 >= v1331)
              {
LABEL_983:
                if ((unint64_t)v734 >= v1330)
                {
                  if ((unint64_t)v734 >= v15)
                    goto LABEL_991;
                }
                else
                {
                  if (*(unsigned __int16 *)v731 == *(unsigned __int16 *)v734)
                  {
                    v734 += 2;
                    v731 = (_QWORD *)((char *)v731 + 2);
                  }
                  if ((unint64_t)v734 >= v15)
                  {
LABEL_991:
                    v733 = v734 - (char *)v470;
                    if (v734 - (char *)v470 <= v590)
                      goto LABEL_999;
                    goto LABEL_992;
                  }
                }
                if (*(unsigned __int8 *)v731 == *v734)
                  ++v734;
                goto LABEL_991;
              }
            }
            break;
          }
          if (*(_DWORD *)v731 == *(_DWORD *)v734)
          {
            v734 += 4;
            v731 = (_QWORD *)((char *)v731 + 4);
          }
          goto LABEL_983;
        }
        v523 = (unint64_t)(v1335 - 7);
        v470 = v1309;
        if (v518 == 5)
        {
          v517 = 0;
          if (*(_DWORD *)(v519 + 212) >= 0xFFFu)
            v630 = 4095;
          else
            v630 = *(_DWORD *)(v519 + 212);
          v631 = *(_QWORD *)(v519 + 8);
          v632 = (_DWORD)v1309 - v631;
          v633 = v1309 + 4;
          v1025 = *(_DWORD *)(v519 + 204);
          v1029 = *(_QWORD *)(v519 + 48);
          v1021 = (0xCF1BBCDCBB000000 * *(_QWORD *)v1309) >> -(char)*(_DWORD *)(v519 + 200);
          v634 = *(_DWORD *)(v1029 + 4 * v1021);
          v635 = -1 << (*(_DWORD *)(v519 + 196) - 1);
          v636 = *(unsigned int *)(v519 + 24);
          v1054 = v631;
          v1297 = (_QWORD *)(v631 + v636);
          v1196 = ~v635;
          v637 = (_DWORD)v1309 - v631 + v635 + 1;
          if (v632 < ~v635)
            v637 = 0;
          v1180 = v637;
          v638 = 1 << *(_DWORD *)(v519 + 192);
          if (v632 - *(_DWORD *)(v519 + 28) > v638 && *(_DWORD *)(v519 + 32) == 0)
            v640 = v632 - v638;
          else
            v640 = *(_DWORD *)(v519 + 28);
          if (v640 <= 1)
            v641 = 1;
          else
            v641 = v640;
          v1239 = v641;
          v1036 = *(_QWORD *)(v519 + 64) + 8 * (v632 & ~v635);
          v1039 = *(_QWORD *)(v519 + 64);
          v1224 = v632 + 9;
          v642 = *(_QWORD *)(v519 + 184);
          v643 = *(_QWORD *)(v642 + 8);
          v1248 = *(char **)v642;
          v644 = v640 - (*(_QWORD *)v642 - (_DWORD)v643);
          v1013 = *(_DWORD *)(v642 + 200);
          v1017 = v642;
          v645 = *(_DWORD *)(v642 + 28);
          v646 = ~(-1 << (*(_DWORD *)(v642 + 196) - 1));
          v647 = *(_QWORD *)v642 - v643 - v645;
          v1008 = *(_QWORD *)v642 - v643;
          v648 = *(_QWORD *)v642 - v643 + (-1 << (*(_DWORD *)(v642 + 196) - 1)) + 1;
          v1069 = v646;
          if (v647 <= v646)
            v649 = v645;
          else
            v649 = v648;
          v1074 = v649;
          v1342 = 0;
          v1089 = v645;
          v650 = v632 - v645 - v644;
          v651 = v1319;
          v652 = v1319 << 63 >> 63;
          if ((_DWORD)v1319)
            v653 = 4;
          else
            v653 = 3;
          v654 = v632 - v636;
          v1081 = v643;
          v1046 = v640 - ((_DWORD)v1248 - (_DWORD)v643);
          v655 = v643 - v644;
          v656 = v1183;
          v1167 = v632;
          v1157 = v634;
          v1147 = v636;
          v1139 = v640;
          v1121 = v630;
          v1130 = v650;
          v1113 = v653;
          v1105 = v632 - v636;
          v1097 = v643 - v644;
          while (1)
          {
            if (v651 == 3)
            {
              v657 = *v522 - 1;
              v658 = v632 - v657;
              v659 = *v522 - 2;
              if (v659 < v654)
                goto LABEL_871;
            }
            else
            {
              v657 = v522[v651];
              v658 = v632 - v657;
              v659 = v657 - 1;
              if (v657 - 1 < v654)
              {
LABEL_871:
                if (v658 < v640 || *(_DWORD *)v470 != *(_DWORD *)&v470[-v657])
                  goto LABEL_859;
                v668 = (_QWORD *)((char *)v633 - v657);
                if (v523 > (unint64_t)v633)
                {
                  v669 = v633;
                  v670 = *v633 ^ *v668;
                  if (v670)
                  {
                    v665 = (__clz(__rbit64(v670)) >> 3) + 4;
                    v666 = v665;
                    if (v656 < v665)
                      goto LABEL_892;
                    goto LABEL_859;
                  }
                  do
                  {
                    ++v668;
                    if ((unint64_t)++v669 >= v523)
                      goto LABEL_884;
                    v671 = *v669 ^ *v668;
                  }
                  while (!v671);
                  v669 = (_QWORD *)((char *)v669 + (__clz(__rbit64(v671)) >> 3));
                  goto LABEL_891;
                }
                v669 = v633;
LABEL_884:
                if ((unint64_t)v669 >= v1331)
                {
                  if ((unint64_t)v669 >= v1330)
                    goto LABEL_888;
                }
                else
                {
                  if (*(_DWORD *)v668 == *(_DWORD *)v669)
                  {
                    v669 = (_QWORD *)((char *)v669 + 4);
                    v668 = (_QWORD *)((char *)v668 + 4);
                  }
                  if ((unint64_t)v669 >= v1330)
                  {
LABEL_888:
                    if ((unint64_t)v669 < v15)
                      goto LABEL_889;
                    goto LABEL_891;
                  }
                }
                if (*(unsigned __int16 *)v668 == *(unsigned __int16 *)v669)
                {
                  v669 = (_QWORD *)((char *)v669 + 2);
                  v668 = (_QWORD *)((char *)v668 + 2);
                }
                if ((unint64_t)v669 < v15)
                {
LABEL_889:
                  if (*(unsigned __int8 *)v668 == *(unsigned __int8 *)v669)
                    LODWORD(v669) = (_DWORD)v669 + 1;
                }
LABEL_891:
                v665 = (_DWORD)v669 - (_DWORD)v633 + 4;
                v666 = v665;
                if (v656 < v665)
                  goto LABEL_892;
                goto LABEL_859;
              }
            }
            if (v659 < v650 && v636 + ~v658 >= 3)
            {
              v661 = v655 + v658;
              if (*(_DWORD *)v470 == *(_DWORD *)v661)
              {
                v662 = v633;
                v1323 = v517;
                v1209 = v656;
                v663 = v652;
                v664 = ZSTD_count_2segments(v633, (char *)(v661 + 4), v15, v1248, v1297);
                v654 = v1105;
                v653 = v1113;
                v652 = v663;
                v630 = v1121;
                v650 = v1130;
                v640 = v1139;
                LODWORD(v636) = v1147;
                v634 = v1157;
                v656 = v1209;
                v522 = &v11[7 * v469 + 4];
                v517 = v1323;
                v632 = v1167;
                v470 = v1309;
                v523 = (unint64_t)(v1335 - 7);
                v15 = (unint64_t)v1335;
                v665 = v664 + 4;
                v633 = v662;
                v655 = v1097;
                v666 = v665;
                if (v1209 < v665)
                {
LABEL_892:
                  v672 = &v1336[2 * v517];
                  *v672 = v651 + v652;
                  v672[1] = v665;
                  v517 = (v517 + 1);
                  if (v665 > v630)
                    goto LABEL_1252;
                  v656 = v666;
                  if (&v470[v666] == (unsigned __int8 *)v15)
                    goto LABEL_1252;
                }
              }
            }
LABEL_859:
            if (++v651 >= v653)
            {
              *(_DWORD *)(v1029 + 4 * v1021) = v632;
              v748 = ~(-1 << v1025);
              if (v634 < v1239)
              {
                v749 = v1224;
                v750 = v1054;
                v752 = (unsigned int *)(v1036 + 4);
                v751 = (int *)v1036;
LABEL_1015:
                v1226 = v749;
                *v752 = 0;
                *v751 = 0;
                v1326 = v517;
                if (v748)
                {
                  v753 = *(_DWORD *)(*(_QWORD *)(v1017 + 48)
                                   + 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)v470) >> -(char)v1013));
                  if (v753 > v1089)
                  {
                    v754 = 0;
                    v755 = 0;
                    v1148 = *(_QWORD *)(v1017 + 64);
                    v1159 = v750 + v1046;
                    v1169 = v632 + 2;
                    v1198 = v748 - 1;
                    while (1)
                    {
                      v1277 = v753;
                      v1241 = v754;
                      v1211 = v755;
                      if (v755 >= v754)
                        v756 = v754;
                      else
                        v756 = v755;
                      v757 = v753;
                      v758 = v1081 + v753;
                      v759 = v656;
                      v760 = ZSTD_count_2segments(&v470[v756], (char *)(v758 + v756), v15, v1248, v1297) + v756;
                      if (v760 + v757 >= v1008)
                        v761 = v1159 + v757;
                      else
                        v761 = v758;
                      if (v760 <= v759)
                      {
                        v656 = v759;
                        v15 = (unint64_t)v1335;
                        v7 = v1304;
                        v470 = v1309;
                        v754 = v1241;
                        v755 = v1211;
                        v764 = v1277;
                        if (v1277 <= v1074)
                          break;
                      }
                      else
                      {
                        v762 = v1226;
                        if (v760 > v1226 - (v1277 + (_DWORD)v1046))
                          v762 = v1277 + v1046 + v760;
                        v1226 = v762;
                        v763 = &v1336[2 * v1326];
                        *v763 = v1169 - (v1277 + v1046);
                        v763[1] = v760;
                        ++v1326;
                        if (v760 > 0x1000)
                        {
                          LODWORD(v15) = (_DWORD)v1335;
                          v7 = v1304;
                          LODWORD(v470) = (_DWORD)v1309;
                          break;
                        }
                        v764 = v1277;
                        v7 = v1304;
                        v470 = v1309;
                        v656 = v760;
                        v15 = (unint64_t)v1335;
                        v754 = v1241;
                        v755 = v1211;
                        if (&v1309[v760] == v1335 || v1277 <= v1074)
                          break;
                      }
                      v765 = *(unsigned __int8 *)(v761 + v760);
                      v766 = v470[v760];
                      v63 = v765 >= v766;
                      v767 = v765 < v766;
                      if (v63)
                        v754 = v760;
                      else
                        v755 = v760;
                      if (v1198)
                      {
                        --v1198;
                        v753 = *(_DWORD *)(v1148 + 8 * (v764 & v1069) + 4 * v767);
                        if (v753 > v1089)
                          continue;
                      }
                      break;
                    }
                  }
                }
LABEL_1299:
                *(_DWORD *)(v7 + 36) = v1226 - 8;
                LODWORD(v517) = v1326;
LABEL_1252:
                LODWORD(v10) = v1250;
                v17 = v11 + 7;
                goto LABEL_1253;
              }
              v808 = 0;
              v809 = 0;
              v750 = v1054;
              v1280 = (char *)v1060 + v469;
              v1213 = v1054 + 8;
              v749 = v1224;
              v752 = (unsigned int *)(v1036 + 4);
              v751 = (int *)v1036;
              v810 = v1039;
              while (2)
              {
                if (v809 >= v808)
                  v811 = v808;
                else
                  v811 = v809;
                v812 = v750 + v634;
                v813 = &v470[v811];
                v814 = (_QWORD *)(v812 + v811);
                if (v523 <= (unint64_t)&v470[v811])
                {
                  v817 = (char *)&v470[v811];
                  v818 = v634;
                  if ((unint64_t)v813 >= v1331)
                    goto LABEL_1102;
                }
                else
                {
                  v815 = *(_QWORD *)v813 ^ *v814;
                  if (v815)
                  {
                    v816 = (__clz(__rbit64(v815)) >> 3) + v811;
                    if (v816 <= v656)
                      goto LABEL_1118;
LABEL_1111:
                    if (v816 > v749 - v634)
                      v749 = v634 + v816;
                    v819 = &v1336[2 * v517];
                    *v819 = v632 + 2 - v634;
                    v819[1] = v816;
                    v517 = (v517 + 1);
                    if (v816 > 0x1000 || &v470[v816] == (unsigned __int8 *)v15)
                    {
                      v1226 = v749;
                      v1326 = v517;
                      *v752 = 0;
                      *v751 = 0;
                      goto LABEL_1299;
                    }
                    v656 = v816;
LABEL_1118:
                    v821 = (unsigned int *)(v810 + 8 * (v634 & v1196));
                    if (*(unsigned __int8 *)(v812 + v816) >= v470[v816])
                    {
                      *v752 = v634;
                      if (v634 <= v1180)
                      {
                        v752 = (unsigned int *)&v1342;
                        goto LABEL_1015;
                      }
                      v808 = v816;
                      v752 = (unsigned int *)(v810 + 8 * (v634 & v1196));
                      v63 = v748-- != 0;
                      if (!v63)
                        goto LABEL_1015;
                    }
                    else
                    {
                      *v751 = v634;
                      if (v634 <= v1180)
                      {
                        v751 = &v1342;
                        goto LABEL_1015;
                      }
                      ++v821;
                      v809 = v816;
                      v751 = (int *)v821;
                      v63 = v748-- != 0;
                      if (!v63)
                        goto LABEL_1015;
                    }
                    v634 = *v821;
                    if (*v821 < v1239)
                      goto LABEL_1015;
                    continue;
                  }
                  v822 = v752;
                  v823 = v751;
                  v824 = v656;
                  v825 = v517;
                  v826 = 0;
                  v827 = &v1280[v811];
                  while (1)
                  {
                    v828 = &v827[v826];
                    if ((unint64_t)&v827[v826] >= v523)
                      break;
                    v829 = *(_QWORD *)(v1213 + v811 + v634 + v826);
                    v826 += 8;
                    v830 = *(_QWORD *)v828 ^ v829;
                    if (v830)
                    {
                      v831 = __clz(__rbit64(v830));
                      v517 = v825;
                      v656 = v824;
                      v751 = v823;
                      v752 = v822;
                      v810 = v1039;
                      v750 = v1054;
                      v816 = v826 + (v831 >> 3) + v811;
                      if (v816 <= v656)
                        goto LABEL_1118;
                      goto LABEL_1111;
                    }
                  }
                  v817 = &v1280[v811 + v826];
                  v814 = (_QWORD *)(v1213 + v811 + v634 + v826);
                  v517 = v825;
                  v656 = v824;
                  v751 = v823;
                  v752 = v822;
                  v810 = v1039;
                  v750 = v1054;
                  v818 = v634;
                  if ((unint64_t)v817 >= v1331)
                  {
LABEL_1102:
                    if ((unint64_t)v817 >= v1330)
                    {
                      if ((unint64_t)v817 >= v15)
                        goto LABEL_1110;
                    }
                    else
                    {
                      if (*(unsigned __int16 *)v814 == *(unsigned __int16 *)v817)
                      {
                        v817 += 2;
                        v814 = (_QWORD *)((char *)v814 + 2);
                      }
                      if ((unint64_t)v817 >= v15)
                      {
LABEL_1110:
                        v634 = v818;
                        v816 = v817 - (char *)v470;
                        if (v817 - (char *)v470 <= v656)
                          goto LABEL_1118;
                        goto LABEL_1111;
                      }
                    }
                    if (*(unsigned __int8 *)v814 == *v817)
                      ++v817;
                    goto LABEL_1110;
                  }
                }
                break;
              }
              if (*(_DWORD *)v814 == *(_DWORD *)v817)
              {
                v817 += 4;
                v814 = (_QWORD *)((char *)v814 + 4);
              }
              goto LABEL_1102;
            }
          }
        }
        v517 = 0;
        if (v518 != 3)
        {
          if (*(_DWORD *)(v519 + 212) >= 0xFFFu)
            v673 = 4095;
          else
            v673 = *(_DWORD *)(v519 + 212);
          v674 = *(_QWORD *)(v519 + 8);
          v675 = (_DWORD)v1309 - v674;
          v676 = v1309 + 4;
          v1030 = *(_DWORD *)(v519 + 204);
          v1033 = *(_QWORD *)(v519 + 48);
          v1026 = (-1640531535 * *(_DWORD *)v1309) >> -(char)*(_DWORD *)(v519 + 200);
          v1037 = *(_DWORD *)(v1033 + 4 * v1026);
          v677 = -1 << (*(_DWORD *)(v519 + 196) - 1);
          v678 = *(unsigned int *)(v519 + 24);
          v1055 = v674;
          v1249 = (_QWORD *)(v674 + v678);
          v1070 = ~v677;
          v679 = (_DWORD)v1309 - v674 + v677 + 1;
          if (v675 < ~v677)
            v679 = 0;
          v1197 = v679;
          v680 = 1 << *(_DWORD *)(v519 + 192);
          if (v675 - *(_DWORD *)(v519 + 28) > v680 && *(_DWORD *)(v519 + 32) == 0)
            v682 = v675 - v680;
          else
            v682 = *(_DWORD *)(v519 + 28);
          if (v682 <= 1)
            v683 = 1;
          else
            v683 = v682;
          v1225 = v683;
          v1075 = *(_QWORD *)(v519 + 64);
          v1047 = (unsigned int *)(v1075 + 8 * (v675 & ~v677));
          v1210 = v675 + 9;
          v684 = *(_QWORD *)(v519 + 184);
          v685 = *(_QWORD *)(v684 + 8);
          v1240 = *(char **)v684;
          v686 = v682 - (*(_QWORD *)v684 - (_DWORD)v685);
          v1018 = *(_DWORD *)(v684 + 200);
          v1022 = v684;
          v687 = *(_DWORD *)(v684 + 28);
          v688 = ~(-1 << (*(_DWORD *)(v684 + 196) - 1));
          v689 = *(_QWORD *)v684 - v685 - v687;
          v1014 = *(_QWORD *)v684 - v685;
          v690 = *(_QWORD *)v684 - v685 + (-1 << (*(_DWORD *)(v684 + 196) - 1)) + 1;
          v1090 = v688;
          if (v689 <= v688)
            v691 = v687;
          else
            v691 = v690;
          v1098 = v691;
          v1342 = 0;
          v1114 = v687;
          v692 = v675 - v687 - v686;
          v693 = v1319;
          v694 = v1319 << 63 >> 63;
          if ((_DWORD)v1319)
            v695 = 4;
          else
            v695 = 3;
          v696 = v675 - v678;
          v1106 = v685;
          v1082 = v682 - ((_DWORD)v1240 - (_DWORD)v685);
          v697 = v685 - v686;
          v698 = v1183;
          v1181 = v675;
          v1168 = v673;
          v1158 = v682;
          v1140 = v695;
          v1122 = v675 - v678;
          v1131 = v692;
          while (1)
          {
            if (v693 == 3)
            {
              v699 = *v522 - 1;
              v700 = v675 - v699;
              v701 = *v522 - 2;
              if (v701 < v696)
                goto LABEL_933;
            }
            else
            {
              v699 = v522[v693];
              v700 = v675 - v699;
              v701 = v699 - 1;
              if (v699 - 1 < v696)
              {
LABEL_933:
                if (v700 < v682 || *(_DWORD *)v470 != *(_DWORD *)&v470[-v699])
                  goto LABEL_921;
                v710 = (_QWORD *)((char *)v676 - v699);
                if (v523 > (unint64_t)v676)
                {
                  v711 = v676;
                  v712 = *v676 ^ *v710;
                  if (v712)
                  {
                    v707 = (__clz(__rbit64(v712)) >> 3) + 4;
                    v708 = v707;
                    if (v698 < v707)
                      goto LABEL_954;
                    goto LABEL_921;
                  }
                  do
                  {
                    ++v710;
                    if ((unint64_t)++v711 >= v523)
                      goto LABEL_946;
                    v713 = *v711 ^ *v710;
                  }
                  while (!v713);
                  v711 = (_QWORD *)((char *)v711 + (__clz(__rbit64(v713)) >> 3));
                  goto LABEL_953;
                }
                v711 = v676;
LABEL_946:
                if ((unint64_t)v711 >= v1331)
                {
                  if ((unint64_t)v711 >= v1330)
                    goto LABEL_950;
                }
                else
                {
                  if (*(_DWORD *)v710 == *(_DWORD *)v711)
                  {
                    v711 = (_QWORD *)((char *)v711 + 4);
                    v710 = (_QWORD *)((char *)v710 + 4);
                  }
                  if ((unint64_t)v711 >= v1330)
                  {
LABEL_950:
                    if ((unint64_t)v711 < v15)
                      goto LABEL_951;
                    goto LABEL_953;
                  }
                }
                if (*(unsigned __int16 *)v710 == *(unsigned __int16 *)v711)
                {
                  v711 = (_QWORD *)((char *)v711 + 2);
                  v710 = (_QWORD *)((char *)v710 + 2);
                }
                if ((unint64_t)v711 < v15)
                {
LABEL_951:
                  if (*(unsigned __int8 *)v710 == *(unsigned __int8 *)v711)
                    LODWORD(v711) = (_DWORD)v711 + 1;
                }
LABEL_953:
                v707 = (_DWORD)v711 - (_DWORD)v676 + 4;
                v708 = v707;
                if (v698 < v707)
                  goto LABEL_954;
                goto LABEL_921;
              }
            }
            if (v701 < v692 && v678 + ~v700 >= 3)
            {
              v703 = v697 + v700;
              if (*(_DWORD *)v470 == *(_DWORD *)v703)
              {
                v1298 = v698;
                v1324 = v517;
                v704 = v678;
                v705 = v694;
                v706 = ZSTD_count_2segments(v676, (char *)(v703 + 4), v15, v1240, v1249);
                v695 = v1140;
                v676 = v1309 + 4;
                v694 = v705;
                v678 = v704;
                v673 = v1168;
                v675 = v1181;
                v522 = &v11[7 * v469 + 4];
                v517 = v1324;
                v682 = v1158;
                v698 = v1298;
                v470 = v1309;
                v523 = (unint64_t)(v1335 - 7);
                v15 = (unint64_t)v1335;
                v707 = v706 + 4;
                v696 = v1122;
                v692 = v1131;
                v708 = v707;
                if (v1298 < v707)
                {
LABEL_954:
                  v714 = &v1336[2 * v517];
                  *v714 = v693 + v694;
                  v714[1] = v707;
                  v517 = (v517 + 1);
                  if (v707 > v673)
                    goto LABEL_1251;
                  v698 = v708;
                  if (&v470[v708] == (unsigned __int8 *)v15)
                    goto LABEL_1251;
                }
              }
            }
LABEL_921:
            if (++v693 >= v695)
            {
              *(_DWORD *)(v1033 + 4 * v1026) = v675;
              v768 = ~(-1 << v1030);
              v769 = v1037;
              if (v1037 < v1225)
              {
                v610 = v1304;
                v611 = v1210;
                v612 = v1047;
                v770 = v1055;
                v614 = v1047 + 1;
                goto LABEL_1040;
              }
              v832 = 0;
              v833 = 0;
              v1328 = v675 + 2;
              v770 = v1055;
              v1302 = (char *)v1060 + v469;
              v1281 = v1055 + 8;
              v610 = v1304;
              v611 = v1210;
              v614 = v1047 + 1;
              v612 = v1047;
              v834 = v1075;
              v835 = v1070;
              while (1)
              {
                v836 = v833 >= v832 ? v832 : v833;
                v837 = v769;
                v838 = v769;
                v839 = v1055 + v769;
                v840 = &v470[v836];
                v841 = (_QWORD *)(v839 + v836);
                if (v523 <= (unint64_t)&v470[v836])
                  break;
                v842 = *(_QWORD *)v840 ^ *v841;
                if (v842)
                {
                  v843 = (__clz(__rbit64(v842)) >> 3) + v836;
                  if (v843 <= v698)
                    goto LABEL_1160;
LABEL_1153:
                  if (v843 > v611 - v837)
                    v611 = v837 + v843;
                  v845 = &v1336[2 * v517];
                  *v845 = v1328 - v837;
                  v845[1] = v843;
                  v517 = (v517 + 1);
                  if (v843 <= 0x1000 && &v470[v843] != (unsigned __int8 *)v15)
                  {
                    v698 = v843;
                    goto LABEL_1160;
                  }
LABEL_1216:
                  v1208 = v611;
                  v1322 = v517;
                  *v614 = 0;
                  *v612 = 0;
                  goto LABEL_1250;
                }
                v848 = v614;
                v849 = v612;
                v850 = v698;
                v851 = v517;
                v852 = 0;
                v853 = &v1302[v836];
                do
                {
                  v854 = &v853[v852];
                  if ((unint64_t)&v853[v852] >= v523)
                  {
                    v844 = &v1302[v836 + v852];
                    v841 = (_QWORD *)(v1281 + v836 + v838 + v852);
                    v517 = v851;
                    v698 = v850;
                    v612 = v849;
                    v614 = v848;
                    v834 = v1075;
                    v835 = v1070;
                    if ((unint64_t)v844 >= v1331)
                      goto LABEL_1144;
                    goto LABEL_1142;
                  }
                  v855 = *(_QWORD *)(v1281 + v836 + v838 + v852);
                  v852 += 8;
                  v856 = *(_QWORD *)v854 ^ v855;
                }
                while (!v856);
                v857 = __clz(__rbit64(v856));
                v517 = v851;
                v698 = v850;
                v612 = v849;
                v614 = v848;
                v834 = v1075;
                v835 = v1070;
                v843 = v852 + (v857 >> 3) + v836;
                if (v843 > v698)
                  goto LABEL_1153;
LABEL_1160:
                v847 = (unsigned int *)(v834 + 8 * (v837 & v835));
                if (*(unsigned __int8 *)(v839 + v843) >= v470[v843])
                {
                  *v614 = v837;
                  if (v837 <= v1197)
                  {
                    v614 = (unsigned int *)&v1342;
                    goto LABEL_1040;
                  }
                  v832 = v843;
                  v614 = (unsigned int *)(v834 + 8 * (v837 & v835));
                  v63 = v768-- != 0;
                  if (v63)
                    goto LABEL_1133;
LABEL_1040:
                  v1208 = v611;
                  *v614 = 0;
                  *v612 = 0;
                  v1322 = v517;
                  if (v768)
                  {
                    v771 = *(_DWORD *)(*(_QWORD *)(v1022 + 48)
                                     + 4 * ((-1640531535 * *(_DWORD *)v470) >> -(char)v1018));
                    if (v771 > v1114)
                    {
                      v772 = 0;
                      v773 = 0;
                      v1149 = *(_QWORD *)(v1022 + 64);
                      v1160 = v770 + v1082;
                      v1182 = v1181 + 2;
                      v1199 = v768 - 1;
                      while (1)
                      {
                        v1278 = v771;
                        v1300 = v698;
                        v1227 = v772;
                        if (v773 >= v772)
                          v774 = v772;
                        else
                          v774 = v773;
                        v775 = v771;
                        v776 = v1106 + v771;
                        v777 = ZSTD_count_2segments(&v470[v774], (char *)(v776 + v774), v15, v1240, v1249);
                        v778 = v777 + v774;
                        v698 = v1300;
                        if (v777 + v774 + v775 >= v1014)
                          v779 = v1160 + v775;
                        else
                          v779 = v776;
                        if (v778 <= v1300)
                        {
                          v15 = (unint64_t)v1335;
                          v610 = v1304;
                          v470 = v1309;
                          v772 = v1227;
                          v782 = v1278;
                          if (v1278 <= v1098)
                            goto LABEL_1250;
                        }
                        else
                        {
                          v780 = v1208;
                          if (v778 > v1208 - (v1278 + (_DWORD)v1082))
                            v780 = v1278 + v1082 + v778;
                          v1208 = v780;
                          v781 = &v1336[2 * v1322];
                          *v781 = v1182 - (v1278 + v1082);
                          v781[1] = v778;
                          ++v1322;
                          if (v778 > 0x1000)
                            goto LABEL_1249;
                          v782 = v1278;
                          v610 = v1304;
                          v470 = v1309;
                          v698 = v777 + v774;
                          v15 = (unint64_t)v1335;
                          v772 = v1227;
                          if (&v1309[v778] == v1335 || v1278 <= v1098)
                            goto LABEL_1250;
                        }
                        v783 = *(unsigned __int8 *)(v779 + v778);
                        v784 = v470[v778];
                        v63 = v783 >= v784;
                        v785 = v783 < v784;
                        if (v63)
                          v772 = v777 + v774;
                        else
                          v773 = v777 + v774;
                        if (v1199)
                        {
                          --v1199;
                          v771 = *(_DWORD *)(v1149 + 8 * (v782 & v1090) + 4 * v785);
                          if (v771 > v1114)
                            continue;
                        }
                        goto LABEL_1250;
                      }
                    }
                  }
                  goto LABEL_1250;
                }
                *v612 = v837;
                if (v837 <= v1197)
                {
                  v612 = (unsigned int *)&v1342;
                  goto LABEL_1040;
                }
                ++v847;
                v833 = v843;
                v612 = v847;
                v63 = v768-- != 0;
                if (!v63)
                  goto LABEL_1040;
LABEL_1133:
                v769 = *v847;
                if (v769 < v1225)
                  goto LABEL_1040;
              }
              v844 = (char *)&v470[v836];
              if ((unint64_t)v840 >= v1331)
                goto LABEL_1144;
LABEL_1142:
              if (*(_DWORD *)v841 == *(_DWORD *)v844)
              {
                v844 += 4;
                v841 = (_QWORD *)((char *)v841 + 4);
              }
LABEL_1144:
              if ((unint64_t)v844 >= v1330)
              {
                if ((unint64_t)v844 >= v15)
                  goto LABEL_1152;
              }
              else
              {
                if (*(unsigned __int16 *)v841 == *(unsigned __int16 *)v844)
                {
                  v844 += 2;
                  v841 = (_QWORD *)((char *)v841 + 2);
                }
                if ((unint64_t)v844 >= v15)
                {
LABEL_1152:
                  v843 = v844 - (char *)v470;
                  if (v844 - (char *)v470 <= v698)
                    goto LABEL_1160;
                  goto LABEL_1153;
                }
              }
              if (*(unsigned __int8 *)v841 == *v844)
                ++v844;
              goto LABEL_1152;
            }
          }
        }
        v1007 = (char *)v1060 + v469;
        if (*(_DWORD *)(v519 + 212) >= 0xFFFu)
          v524 = 4095;
        else
          v524 = *(_DWORD *)(v519 + 212);
        v525 = *(_QWORD *)(v519 + 8);
        v526 = ((_DWORD)v1309 - v525);
        v527 = v1309 + 3;
        v1027 = *(_DWORD *)(v519 + 204);
        v1031 = *(_QWORD *)(v519 + 48);
        v1023 = (-1640531535 * *(_DWORD *)v1309) >> -(char)*(_DWORD *)(v519 + 200);
        v1119 = *(_DWORD *)(v1031 + 4 * v1023);
        v528 = -1 << (*(_DWORD *)(v519 + 196) - 1);
        v529 = *(unsigned int *)(v519 + 24);
        v1044 = v525;
        v1246 = (_QWORD *)(v525 + v529);
        v1193 = ~v528;
        v530 = v526 + v528 + 1;
        if (v526 < ~v528)
          v530 = 0;
        v1177 = v530;
        v531 = 1 << *(_DWORD *)(v519 + 192);
        if ((int)v526 - *(_DWORD *)(v519 + 28) > v531 && *(_DWORD *)(v519 + 32) == 0)
          v533 = v526 - v531;
        else
          v533 = *(_DWORD *)(v519 + 28);
        if (v533 <= 1)
          v534 = 1;
        else
          v534 = v533;
        v1294 = v534;
        v1206 = *(_QWORD *)(v519 + 64);
        v1034 = (unsigned int *)(v1206 + 8 * (v526 & ~v528));
        v535 = *(_QWORD *)(v519 + 184);
        v536 = *(_QWORD *)(v535 + 8);
        v1237 = *(char **)v535;
        v537 = v533 - (*(_QWORD *)v535 - (_DWORD)v536);
        v1015 = *(_DWORD *)(v535 + 200);
        v1019 = v535;
        v538 = *(_DWORD *)(v535 + 28);
        v539 = ~(-1 << (*(_DWORD *)(v535 + 196) - 1));
        v540 = *(_QWORD *)v535 - v536 - v538;
        v1011 = *(_QWORD *)v535 - v536;
        v541 = *(_QWORD *)v535 - v536 + (-1 << (*(_DWORD *)(v535 + 196) - 1)) + 1;
        v1111 = v539;
        if (v540 <= v539)
          v542 = v538;
        else
          v542 = v541;
        v1137 = v542;
        v1342 = 0;
        v1154 = v538;
        v543 = v526 - v538 - v537;
        v544 = v1319;
        v545 = v1319 << 63 >> 63;
        v1221 = v526 + 9;
        if ((_DWORD)v1319)
          v546 = 4;
        else
          v546 = 3;
        v547 = v526 - v529;
        v1145 = v536;
        v1038 = v533 - ((_DWORD)v1237 - (_DWORD)v536);
        v548 = v536 - v537;
        v549 = v1183;
        v1103 = v524;
        v1095 = v529;
        v1087 = v533;
        v1072 = v526;
        v1067 = v536 - v537;
        v1052 = v1319 << 63 >> 63;
        while (2)
        {
          if (v544 == 3)
          {
            v550 = *v522 - 1;
            v551 = v526 - v550;
            v552 = *v522 - 2;
            if (v552 >= v547)
              goto LABEL_712;
LABEL_721:
            if (v551 < v533 || ((*(_DWORD *)&v470[-v550] ^ *(_DWORD *)v470) & 0xFFFFFF) != 0)
              goto LABEL_709;
            v560 = (_QWORD *)((char *)v527 - v550);
            if (v523 > (unint64_t)v527)
            {
              v561 = v527;
              v562 = *v527 ^ *v560;
              if (v562)
              {
                v557 = (__clz(__rbit64(v562)) >> 3) + 3;
                v558 = v557;
                if (v549 >= v557)
                  goto LABEL_709;
              }
              else
              {
                do
                {
                  ++v560;
                  if ((unint64_t)++v561 >= v523)
                    goto LABEL_735;
                  v563 = *v561 ^ *v560;
                }
                while (!v563);
                v557 = (_DWORD)v561 + (__clz(__rbit64(v563)) >> 3) - (_DWORD)v527 + 3;
                v558 = v557;
                if (v549 >= v557)
                  goto LABEL_709;
              }
              goto LABEL_743;
            }
            v561 = v527;
LABEL_735:
            if ((unint64_t)v561 >= v1331)
            {
              if ((unint64_t)v561 >= v1330)
                goto LABEL_739;
            }
            else
            {
              if (*(_DWORD *)v560 == *(_DWORD *)v561)
              {
                v561 = (_QWORD *)((char *)v561 + 4);
                v560 = (_QWORD *)((char *)v560 + 4);
              }
              if ((unint64_t)v561 >= v1330)
              {
LABEL_739:
                if ((unint64_t)v561 < v15)
                  goto LABEL_740;
                goto LABEL_742;
              }
            }
            if (*(unsigned __int16 *)v560 == *(unsigned __int16 *)v561)
            {
              v561 = (_QWORD *)((char *)v561 + 2);
              v560 = (_QWORD *)((char *)v560 + 2);
            }
            if ((unint64_t)v561 < v15)
            {
LABEL_740:
              if (*(unsigned __int8 *)v560 == *(unsigned __int8 *)v561)
                LODWORD(v561) = (_DWORD)v561 + 1;
            }
LABEL_742:
            v557 = (_DWORD)v561 - (_DWORD)v527 + 3;
            v558 = v557;
            if (v549 >= v557)
              goto LABEL_709;
LABEL_743:
            v564 = &v1336[2 * v517];
            *v564 = v544 + v545;
            v564[1] = v557;
            v517 = (v517 + 1);
            if (v557 > v524)
              goto LABEL_1251;
            v549 = v558;
            if (&v470[v558] == (unsigned __int8 *)v15)
              goto LABEL_1251;
            goto LABEL_709;
          }
          v550 = v522[v544];
          v551 = v526 - v550;
          v552 = v550 - 1;
          if (v550 - 1 < v547)
            goto LABEL_721;
LABEL_712:
          if (v552 < v543 && v529 + ~v551 >= 3)
          {
            v554 = v548 + v551;
            if (((*(_DWORD *)v554 ^ *(_DWORD *)v470) & 0xFFFFFF) == 0)
            {
              v1165 = v549;
              v1320 = v517;
              v555 = v543;
              v556 = ZSTD_count_2segments(v527, (char *)(v554 + 3), v15, v1237, v1246);
              v548 = v1067;
              LODWORD(v545) = v1052;
              v543 = v555;
              LODWORD(v529) = v1095;
              v527 = v1309 + 3;
              v533 = v1087;
              v549 = v1165;
              v526 = v1072;
              v522 = &v11[7 * v469 + 4];
              v517 = v1320;
              v470 = v1309;
              v523 = (unint64_t)(v1335 - 7);
              v15 = (unint64_t)v1335;
              v557 = v556 + 3;
              v524 = v1103;
              v558 = v557;
              if (v1165 < v557)
                goto LABEL_743;
            }
          }
LABEL_709:
          if (++v544 < v546)
            continue;
          break;
        }
        if (v549 > 2)
        {
          v7 = v1304;
          v17 = v11 + 7;
          goto LABEL_1064;
        }
        v7 = v1304;
        v715 = *(_QWORD *)(v1304 + 56);
        v716 = *(_DWORD *)v470;
        v717 = 32 - *(_DWORD *)(v1304 + 40);
        if (v1009 < v526)
        {
          v718 = v1009;
          do
          {
            *(_DWORD *)(v715 + 4 * ((900185344 * *(_DWORD *)(v1044 + v718)) >> v717)) = v718;
            ++v718;
          }
          while (v1289 - (_DWORD)v1044 != v718);
        }
        v719 = *(unsigned int *)(v715 + 4 * ((900185344 * v716) >> v717));
        v720 = v526 - v719;
        v721 = v719 >= v1294 && (v526 - v719) >> 18 == 0;
        LODWORD(v10) = v1250;
        v17 = v11 + 7;
        if (!v721)
        {
          v1009 = v526;
LABEL_1064:
          v786 = v1034 + 1;
          goto LABEL_1065;
        }
        v882 = (_DWORD *)(v1044 + v719);
        if (v523 <= (unint64_t)v470)
        {
          v885 = (char *)v470;
          if ((unint64_t)v470 >= v1331)
            goto LABEL_1226;
LABEL_1224:
          if (*v882 == *(_DWORD *)v885)
          {
            v885 += 4;
            ++v882;
          }
LABEL_1226:
          if ((unint64_t)v885 >= v1330)
          {
            if ((unint64_t)v885 >= v15)
              goto LABEL_1234;
          }
          else
          {
            if (*(unsigned __int16 *)v882 == *(unsigned __int16 *)v885)
            {
              v885 += 2;
              v882 = (_DWORD *)((char *)v882 + 2);
            }
            if ((unint64_t)v885 >= v15)
            {
LABEL_1234:
              v786 = v1034 + 1;
              v884 = v885 - (char *)v470;
              v1009 = v526;
              if (v884 >= 3)
                goto LABEL_1235;
              goto LABEL_1065;
            }
          }
          if (*(unsigned __int8 *)v882 == *v885)
            ++v885;
          goto LABEL_1234;
        }
        v883 = *(_QWORD *)v470 ^ *(_QWORD *)v882;
        if (v883)
        {
          v884 = __clz(__rbit64(v883)) >> 3;
          v786 = v1034 + 1;
          v1009 = v526;
          if (v884 >= 3)
            goto LABEL_1235;
LABEL_1065:
          *(_DWORD *)(v1031 + 4 * v1023) = v526;
          v787 = ~(-1 << v1027);
          v788 = v1119;
          if (v1119 < v1294)
          {
            v789 = v1221;
            v790 = v1044;
            v791 = v1034;
LABEL_1067:
            v1228 = v789;
            *v786 = 0;
            *v791 = 0;
            v1327 = v517;
            if (v787)
            {
              v792 = *(_DWORD *)(*(_QWORD *)(v1019 + 48)
                               + 4 * ((-1640531535 * *(_DWORD *)v470) >> -(char)v1015));
              if (v792 > v1154)
              {
                v793 = 0;
                v794 = 0;
                v1132 = *(_QWORD *)(v1019 + 64);
                v1170 = v790 + v1038;
                v1123 = v526 + 2;
                v1200 = v787 - 1;
                while (1)
                {
                  v1301 = v792;
                  v1279 = v793;
                  v1212 = v794;
                  if (v794 >= v793)
                    v795 = v793;
                  else
                    v795 = v794;
                  v796 = v792;
                  v797 = v1145 + v792;
                  v798 = v549;
                  v799 = ZSTD_count_2segments(&v470[v795], (char *)(v797 + v795), v15, v1237, v1246);
                  v800 = v799 + v795;
                  if (v799 + v795 + v796 >= v1011)
                    v801 = v1170 + v796;
                  else
                    v801 = v797;
                  if (v800 <= v798)
                  {
                    v549 = v798;
                    v15 = (unint64_t)v1335;
                    v7 = v1304;
                    v470 = v1309;
                    v17 = v11 + 7;
                    v793 = v1279;
                    v804 = v1301;
                    v794 = v1212;
                    if (v1301 <= v1137)
                      break;
                  }
                  else
                  {
                    v802 = v1228;
                    if (v800 > v1228 - (v1301 + v1038))
                      v802 = v1301 + v1038 + v800;
                    v1228 = v802;
                    v803 = &v1336[2 * v1327];
                    *v803 = v1123 - (v1301 + v1038);
                    v803[1] = v800;
                    ++v1327;
                    if (v800 > 0x1000)
                    {
                      LODWORD(v15) = (_DWORD)v1335;
                      v7 = v1304;
                      LODWORD(v470) = (_DWORD)v1309;
                      v17 = v11 + 7;
                      break;
                    }
                    v804 = v1301;
                    v7 = v1304;
                    v470 = v1309;
                    v549 = v799 + v795;
                    v15 = (unint64_t)v1335;
                    v17 = v11 + 7;
                    v793 = v1279;
                    v794 = v1212;
                    if (&v1309[v800] == v1335 || v1301 <= v1137)
                      break;
                  }
                  v805 = *(unsigned __int8 *)(v801 + v800);
                  v806 = v470[v800];
                  v63 = v805 >= v806;
                  v807 = v805 < v806;
                  if (v63)
                    v793 = v800;
                  else
                    v794 = v800;
                  if (v1200)
                  {
                    --v1200;
                    v792 = *(_DWORD *)(v1132 + 8 * (v804 & v1111) + 4 * v807);
                    if (v792 > v1154)
                      continue;
                  }
                  break;
                }
              }
            }
LABEL_1301:
            LODWORD(v10) = v1250;
            LODWORD(v517) = v1327;
            *(_DWORD *)(v7 + 36) = v1228 - 8;
            goto LABEL_1253;
          }
          v858 = 0;
          v859 = 0;
          v1329 = v526 + 2;
          v1282 = (char *)v1060 + v469;
          v790 = v1044;
          v1171 = v1044 + 8;
          v789 = v1221;
          v791 = v1034;
          while (2)
          {
            if (v859 >= v858)
              v860 = v858;
            else
              v860 = v859;
            v861 = v788;
            v862 = v790 + v788;
            v863 = &v470[v860];
            v864 = (_DWORD *)(v862 + v860);
            if (v523 <= (unint64_t)&v470[v860])
            {
              v867 = v790;
              v868 = (char *)&v470[v860];
              v869 = v788;
              v870 = v549;
              if ((unint64_t)v863 < v1331)
              {
LABEL_1184:
                if (*v864 == *(_DWORD *)v868)
                {
                  v868 += 4;
                  ++v864;
                }
              }
            }
            else
            {
              v865 = *(_QWORD *)v863 ^ *(_QWORD *)v864;
              if (v865)
              {
                v866 = (__clz(__rbit64(v865)) >> 3) + v860;
                if (v866 <= v549)
                  goto LABEL_1202;
                goto LABEL_1195;
              }
              v1124 = v788;
              v874 = v526;
              v875 = v517;
              v876 = 0;
              v877 = &v1282[v860];
              while (1)
              {
                v878 = &v877[v876];
                if ((unint64_t)&v877[v876] >= v523)
                  break;
                v879 = *(_QWORD *)(v1171 + v860 + v861 + v876);
                v876 += 8;
                v880 = *(_QWORD *)v878 ^ v879;
                if (v880)
                {
                  v881 = __clz(__rbit64(v880));
                  v517 = v875;
                  v526 = v874;
                  v790 = v1044;
                  v788 = v1124;
                  v866 = v876 + (v881 >> 3) + v860;
                  if (v866 > v549)
                    goto LABEL_1195;
                  goto LABEL_1202;
                }
              }
              v868 = &v1282[v860 + v876];
              v864 = (_DWORD *)(v1171 + v860 + v861 + v876);
              v517 = v875;
              v526 = v874;
              v867 = v1044;
              v869 = v1124;
              v870 = v549;
              if ((unint64_t)v868 < v1331)
                goto LABEL_1184;
            }
            if ((unint64_t)v868 >= v1330)
            {
              if ((unint64_t)v868 >= v15)
                goto LABEL_1194;
            }
            else
            {
              if (*(unsigned __int16 *)v864 == *(unsigned __int16 *)v868)
              {
                v868 += 2;
                v864 = (_DWORD *)((char *)v864 + 2);
              }
              if ((unint64_t)v868 >= v15)
              {
LABEL_1194:
                v549 = v870;
                v788 = v869;
                v790 = v867;
                v866 = v868 - (char *)v470;
                if (v868 - (char *)v470 <= v549)
                {
LABEL_1202:
                  v873 = (unsigned int *)(v1206 + 8 * (v788 & v1193));
                  if (*(unsigned __int8 *)(v862 + v866) >= v470[v866])
                  {
                    *v786 = v788;
                    if (v788 <= v1177)
                    {
                      v786 = (unsigned int *)&v1342;
                      goto LABEL_1067;
                    }
                    v858 = v866;
                    v786 = (unsigned int *)(v1206 + 8 * (v788 & v1193));
                    v63 = v787-- != 0;
                    if (!v63)
                      goto LABEL_1067;
                  }
                  else
                  {
                    *v791 = v788;
                    if (v788 <= v1177)
                    {
                      v791 = (unsigned int *)&v1342;
                      goto LABEL_1067;
                    }
                    ++v873;
                    v859 = v866;
                    v791 = v873;
                    v63 = v787-- != 0;
                    if (!v63)
                      goto LABEL_1067;
                  }
                  v788 = *v873;
                  if (*v873 < v1294)
                    goto LABEL_1067;
                  continue;
                }
LABEL_1195:
                if (v866 > v789 - v788)
                  v789 = v788 + v866;
                v871 = &v1336[2 * v517];
                *v871 = v1329 - v788;
                v871[1] = v866;
                v517 = (v517 + 1);
                if (v866 > 0x1000 || &v470[v866] == (unsigned __int8 *)v15)
                {
                  v1228 = v789;
                  v1327 = v517;
                  *v786 = 0;
                  *v791 = 0;
                  goto LABEL_1301;
                }
                v549 = v866;
                goto LABEL_1202;
              }
            }
            break;
          }
          if (*(unsigned __int8 *)v864 == *v868)
            ++v868;
          goto LABEL_1194;
        }
        v929 = 0;
        while (2)
        {
          v885 = &v1007[v929];
          if ((unint64_t)&v1007[v929] >= v523)
          {
            v882 = (_DWORD *)(v1044 + v719 + v929 + 8);
            if ((unint64_t)v885 >= v1331)
              goto LABEL_1226;
            goto LABEL_1224;
          }
          v930 = *(_QWORD *)(v1044 + v719 + 8 + v929);
          v929 += 8;
          v931 = *(_QWORD *)v885 ^ v930;
          if (!v931)
            continue;
          break;
        }
        v884 = v929 + (__clz(__rbit64(v931)) >> 3);
        v786 = v1034 + 1;
        v1009 = v526;
        if (v884 < 3)
          goto LABEL_1065;
LABEL_1235:
        *v1336 = v720 + 2;
        v1336[1] = v884;
        if (v884 <= v524 && &v470[v884] != (unsigned __int8 *)v15)
        {
          v517 = 1;
          v1009 = v526;
          v549 = v884;
          goto LABEL_1065;
        }
        LODWORD(v517) = 1;
        v1009 = v526;
        *(_DWORD *)(v1304 + 36) = v526 + 1;
LABEL_1253:
        v1338 = v517;
        ZSTD_optLdm_processMatchCandidate((uint64_t *)&v1339, (uint64_t)v1336, &v1338, (_DWORD)v470 - (_DWORD)v1266, v15 - (_DWORD)v470);
        v887 = v1338;
        if (!v1338)
        {
          v15 = (unint64_t)v1335;
LABEL_639:
          v463 = v1334;
          v464 = v1289;
          goto LABEL_640;
        }
        v888 = v1338 - 1;
        v424 = v1336[2 * v888 + 1];
        v15 = (unint64_t)v1335;
        if (v424 <= v1190 && v424 + v469 <= 0xFFF)
        {
          v889 = 0;
          v890 = v1255 + v1264;
          while (1)
          {
            v891 = &v1336[2 * v889];
            v892 = v10;
            if (v889)
              v892 = *(v891 - 1) + 1;
            v893 = v891[1];
            if (v893 >= v892)
              break;
LABEL_1257:
            if (++v889 == v887)
              goto LABEL_639;
          }
          v894 = *v891;
          v895 = __clz(v894 + 1) ^ 0x1F;
          if (*(_DWORD *)(v7 + 160) == 1)
          {
            v896 = 0;
            v897 = v469 + v893;
            v898 = v469 + v893;
            while (1)
            {
              v900 = v893 + v469;
              v901 = __clz(v893 - 2);
              v902 = ((v893 - 2) << 8 >> (v901 ^ 0x1F)) + (((v901 ^ 0x1F) + (_DWORD)v895) << 8) + v890 + 4096;
              if (v900 <= v462)
              {
                if (v902 >= (int)v11[7 * v900])
                  goto LABEL_1264;
                goto LABEL_1263;
              }
              v903 = v462;
              v904 = (v897 - v896) - (unint64_t)v462;
              if (v904 >= 2)
              {
                v462 = (v904 & 0xFFFFFFFFFFFFFFFELL) + v462;
                v905 = (v898 - v903) & 0xFFFFFFFFFFFFFFFELL;
                v906 = &v1337[7 * v903];
                do
                {
                  *(v906 - 7) = 0x40000000;
                  *v906 = 0x40000000;
                  v906 += 14;
                  v905 -= 2;
                }
                while (v905);
                if (v904 == (v904 & 0xFFFFFFFFFFFFFFFELL))
                  goto LABEL_1263;
              }
              else
              {
                v462 = v462;
              }
              v907 = &v17[7 * v462];
              do
              {
                ++v462;
                *v907 = 0x40000000;
                v907 += 7;
              }
              while (v462 < v900);
LABEL_1263:
              v899 = (signed int *)&v11[7 * v900];
              v899[2] = v893;
              v899[3] = v23;
              *v899 = v902;
              v899[1] = v894;
LABEL_1264:
              --v893;
              ++v896;
              --v898;
              if (v893 < v892)
                goto LABEL_1257;
            }
          }
          v908 = 0;
          v910 = *(_QWORD *)(v7 + 96);
          v909 = *(_QWORD *)(v7 + 104);
          v911 = *(_DWORD *)(v7 + 156) + *(_DWORD *)(v7 + 152) + 51;
          v912 = v469 + v893;
          v913 = v469 + v893;
          while (2)
          {
            v915 = v893 - 3;
            if (v893 - 3 < 0x80)
              v916 = ZSTD_MLcode_ML_Code[v915];
            else
              v916 = 67 - __clz(v915);
            v917 = v893 + v469;
            v918 = *(_DWORD *)(v909 + 4 * v895) + 1;
            v919 = __clz(v918) ^ 0x1F;
            v920 = 4 * v916;
            v921 = *(unsigned int *)((char *)ML_bits + v920);
            LODWORD(v920) = *(_DWORD *)(v910 + v920) + 1;
            v922 = __clz(v920) ^ 0x1F;
            v923 = v890
                 + v911
                 - (v918 << 8 >> v919)
                 - ((_DWORD)v920 << 8 >> v922)
                 + (((_DWORD)v895 + v921 - v919 - v922) << 8);
            if (v917 <= v462)
            {
              if (v923 < (int)v11[7 * v917])
                goto LABEL_1277;
            }
            else
            {
              v924 = v462;
              v925 = (v912 - v908) - (unint64_t)v462;
              if (v925 < 2)
              {
                v462 = v462;
                goto LABEL_1290;
              }
              v462 = (v925 & 0xFFFFFFFFFFFFFFFELL) + v462;
              v926 = (v913 - v924) & 0xFFFFFFFFFFFFFFFELL;
              v927 = &v1337[7 * v924];
              do
              {
                *(v927 - 7) = 0x40000000;
                *v927 = 0x40000000;
                v927 += 14;
                v926 -= 2;
              }
              while (v926);
              v17 = v11 + 7;
              if (v925 != (v925 & 0xFFFFFFFFFFFFFFFELL))
              {
LABEL_1290:
                v928 = &v17[7 * v462];
                do
                {
                  ++v462;
                  *v928 = 0x40000000;
                  v928 += 7;
                }
                while (v462 < v917);
              }
LABEL_1277:
              v914 = &v11[7 * v917];
              v914[2] = v893;
              v914[3] = v23;
              *v914 = v923;
              v914[1] = v894;
            }
            --v893;
            ++v908;
            --v913;
            if (v893 < v892)
              goto LABEL_1257;
            continue;
          }
        }
        if (*v1189)
          v995 = 0;
        else
          v995 = v11[7 * v469 + 3];
        v434 = (unint64_t)(v1335 - 32);
        v433 = v1336[2 * v888];
        v996 = v469 - v995;
        if (v996 <= 0x1000)
          v432 = v996;
        else
          v432 = 0;
        if (!v424)
        {
LABEL_1388:
          v997 = &v11[7 * v432];
          v998 = *((_QWORD *)v997 + 2);
          a3[2] = v997[6];
          *(_QWORD *)a3 = v998;
          goto LABEL_1322;
        }
LABEL_1308:
        v933 = &v11[7 * v432 + 4];
        if (v433 < 3)
        {
          if (v23)
            v938 = v433;
          else
            v938 = v433 + 1;
          if (v938)
          {
            if (v938 == 3)
            {
              v935 = *v933;
              v937 = v935 - 1;
            }
            else
            {
              v937 = v933[v938];
              v935 = *v933;
            }
            v949 = v938 > 1;
            v940 = 2;
            if (v949)
              v940 = 1;
            v934 = &v933[v940];
          }
          else
          {
            v939 = *(_QWORD *)v933;
            v934 = &v11[7 * v432 + 6];
            v937 = v939;
            v935 = HIDWORD(v939);
          }
        }
        else
        {
          v936 = *v933;
          v934 = &v11[7 * v432 + 5];
          v935 = v936;
          v937 = v433 - 2;
        }
        v941 = *v934;
        *(_QWORD *)a3 = v937 | (v935 << 32);
        a3[2] = v941;
LABEL_1322:
        v942 = v432 + 1;
        v943 = &v11[7 * v432 + 7];
        *v943 = v1083;
        v943[1] = v433;
        v943[2] = v424;
        v943[3] = v23;
        *((_QWORD *)v943 + 2) = v1343;
        v943[6] = v1344;
        v944 = v432;
        if (!v432)
        {
          v950 = 1;
          v951 = v1062;
          v18 = v1229;
          goto LABEL_1332;
        }
        do
        {
          v945 = &v11[7 * v944];
          v946 = v945[3] + v945[2];
          v947 = &v11[7 * v432];
          v948 = *(_OWORD *)v945;
          *(_OWORD *)(v947 + 3) = *(_OWORD *)(v945 + 3);
          *(_OWORD *)v947 = v948;
          --v432;
          v63 = v944 >= v946;
          v944 -= v946;
          v949 = v944 != 0 && v63;
          if (!v63)
            v944 = 0;
        }
        while (v949);
        v950 = v432 + 1;
        v951 = v1062;
        v18 = v1229;
        if (v950 <= v942)
        {
          while (1)
          {
LABEL_1332:
            while (1)
            {
              v954 = v950;
              v956 = v11[7 * v950 + 2];
              v955 = v11[7 * v950 + 3];
              if (v956)
                break;
              v14 = &v18[v955];
              v950 = v954 + 1;
              if (v954 + 1 > v942)
                goto LABEL_1328;
            }
            v957 = v11[7 * v954 + 1];
            if (*(_DWORD *)(v7 + 176) != 2)
            {
              if ((_DWORD)v955)
              {
                v958 = *v1265;
                v959 = v18;
                v960 = v955;
                do
                {
                  v961 = *v959++;
                  *(_DWORD *)&v958[4 * v961] += 2;
                  --v960;
                }
                while (v960);
              }
              *(_DWORD *)(v7 + 128) += 2 * v955;
            }
            v962 = v955 < 0x40 ? ZSTD_LLcode_LL_Code[v955] : 50 - __clz(v955);
            ++*(_DWORD *)(*(_QWORD *)(v7 + 88) + 4 * v962);
            ++*(_DWORD *)(v7 + 132);
            v963 = v957 + 1;
            v964 = __clz(v957 + 1);
            ++*(_DWORD *)(*(_QWORD *)(v7 + 104) + 4 * (v964 ^ 0x1F));
            ++*(_DWORD *)(v7 + 140);
            v965 = v956 - 3;
            v966 = v956 - 3 < 0x80 ? ZSTD_MLcode_ML_Code[v965] : 67 - __clz(v965);
            ++*(_DWORD *)(*(_QWORD *)(v7 + 96) + 4 * v966);
            ++*(_DWORD *)(v7 + 136);
            v967 = &v18[v955];
            v968 = *(char **)(v951 + 24);
            if ((unint64_t)&v18[v955] > v434)
              break;
            *(_OWORD *)v968 = *(_OWORD *)v18;
            v971 = *(_QWORD *)(v951 + 24);
            if (v955 > 0x10)
            {
              v972 = (_OWORD *)(v971 + 16);
              v973 = v971 + v955;
              v974 = (__int128 *)(v18 + 16);
              do
              {
                v975 = *v974++;
                *v972++ = v975;
              }
              while ((unint64_t)v972 < v973);
LABEL_1377:
              *(_QWORD *)(v951 + 24) += v955;
              v982 = *(_QWORD *)(v951 + 8);
              if (v955 >= 0x10000)
              {
                v993 = (unint64_t)(v982 - *(_QWORD *)v951) >> 3;
                *(_DWORD *)(v951 + 72) = 1;
                *(_DWORD *)(v951 + 76) = v993;
              }
              goto LABEL_1379;
            }
            *(_QWORD *)(v951 + 24) = v971 + v955;
            v982 = *(_QWORD *)(v951 + 8);
LABEL_1379:
            *(_WORD *)(v982 + 4) = v955;
            *(_DWORD *)v982 = v963;
            if (v965 >= 0x10000)
            {
              v994 = (unint64_t)(v982 - *(_QWORD *)v951) >> 3;
              *(_DWORD *)(v951 + 72) = 2;
              *(_DWORD *)(v951 + 76) = v994;
            }
            *(_WORD *)(v982 + 6) = v965;
            *(_QWORD *)(v951 + 8) = v982 + 8;
            v18 += v956 + v955;
            v14 = v18;
            v950 = v954 + 1;
            if (v954 + 1 > v942)
              goto LABEL_1328;
          }
          if ((unint64_t)v18 <= v434)
          {
            v970 = &v968[v434 - (_QWORD)v18];
            v976 = v18;
            v977 = *(char **)(v951 + 24);
            do
            {
              v978 = *(_OWORD *)v976;
              v976 += 16;
              *(_OWORD *)v977 = v978;
              v977 += 16;
            }
            while (v977 < v970);
            v969 = (unsigned __int8 *)v434;
            if (v434 >= (unint64_t)v967)
              goto LABEL_1377;
          }
          else
          {
            v969 = v18;
            v970 = *(char **)(v951 + 24);
            if (v18 >= v967)
              goto LABEL_1377;
          }
          if ((unint64_t)v18 <= v434)
            v979 = (unsigned __int8 *)v434;
          else
            v979 = v18;
          v980 = &v18[v955] - v979;
          if (v980 < 8)
          {
            v981 = v969;
            goto LABEL_1376;
          }
          if ((unint64_t)(v968 - (char *)v18) < 0x20)
          {
            v981 = v969;
            goto LABEL_1376;
          }
          if (v980 >= 0x20)
          {
            v983 = v980 & 0xFFFFFFFFFFFFFFE0;
            v984 = (__int128 *)(v969 + 16);
            v985 = &v968[v979 - v18 + 16];
            v986 = v980 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              v987 = *v984;
              *((_OWORD *)v985 - 1) = *(v984 - 1);
              *(_OWORD *)v985 = v987;
              v984 += 2;
              v985 += 32;
              v986 -= 32;
            }
            while (v986);
            if (v980 == v983)
              goto LABEL_1377;
            if ((v980 & 0x18) == 0)
            {
              v981 = &v969[v983];
              v970 += v983;
              goto LABEL_1376;
            }
          }
          else
          {
            v983 = 0;
          }
          v970 += v980 & 0xFFFFFFFFFFFFFFF8;
          v981 = &v969[v980 & 0xFFFFFFFFFFFFFFF8];
          v988 = &v969[v983];
          v989 = &v968[&v979[v983] - v18];
          v990 = v983 - (v980 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            v991 = *(_QWORD *)v988;
            v988 += 8;
            *(_QWORD *)v989 = v991;
            v989 += 8;
            v990 += 8;
          }
          while (v990);
          if (v980 == (v980 & 0xFFFFFFFFFFFFFFF8))
            goto LABEL_1377;
          do
          {
LABEL_1376:
            v992 = *v981++;
            *v970++ = v992;
          }
          while (v981 < v967);
          goto LABEL_1377;
        }
        v14 = v1334;
LABEL_1328:
        if (*(_DWORD *)(v7 + 176) != 2)
        {
          v952 = *(_DWORD *)(v7 + 128) + 1;
          v953 = __clz(v952) ^ 0x1F;
          *(_DWORD *)(v7 + 144) = (v952 << 8 >> v953) + (v953 << 8);
        }
        v19 = *(_DWORD *)(v7 + 140) + 1;
        v20 = __clz(v19);
        v21 = vadd_s32(*(int32x2_t *)(v7 + 132), (int32x2_t)0x100000001);
        v22 = (int32x2_t)veor_s8((int8x8_t)vclz_s32(v21), (int8x8_t)0x1F0000001FLL);
        *(int32x2_t *)(v7 + 148) = vadd_s32(vshl_n_s32(v22, 8uLL), (int32x2_t)vshl_u32((uint32x2_t)vshl_n_s32(v21, 8uLL), (uint32x2_t)vneg_s32(v22)));
        *(_DWORD *)(v7 + 156) = (v19 << 8 >> (v20 ^ 0x1F)) + ((v20 ^ 0x1F) << 8);
        if ((unint64_t)v14 >= v1303)
        {
LABEL_1405:
          v1266 = v18;
          return v15 - (_QWORD)v1266;
        }
      }
      else
      {
        v14 = v418 + 1;
        v15 = (unint64_t)v1335;
        v18 = v1229;
        if ((unint64_t)(v418 + 1) >= v1303)
          goto LABEL_1405;
      }
    }
    v26 = 0;
    if (*(_DWORD *)(v7 + 212) >= 0xFFFu)
      v79 = 4095;
    else
      v79 = *(_DWORD *)(v7 + 212);
    v80 = *(_QWORD *)(v7 + 8);
    v81 = (_DWORD)v1334 - v80;
    v82 = (char *)(v1334 + 12);
    v1100 = *(_DWORD *)(v7 + 204);
    v1108 = *(_QWORD *)(v7 + 48);
    v1092 = (0xCF1BBCDCBF9B0000 * *(_QWORD *)v1334) >> -(char)*(_DWORD *)(v7 + 200);
    v83 = -1 << (*(_DWORD *)(v7 + 196) - 1);
    v1049 = ~v83;
    v84 = (_DWORD)v1334 - v80 + v83 + 1;
    if ((int)v1334 - (int)v80 < ~v83)
      v84 = 0;
    v1116 = *(_DWORD *)(v1108 + 4 * v1092);
    v1126 = v84;
    v85 = *(unsigned int *)(v7 + 24);
    v86 = 1 << *(_DWORD *)(v7 + 192);
    v14 = v1334;
    if (v81 - *(_DWORD *)(v7 + 28) > v86 && *(_DWORD *)(v7 + 32) == 0)
      v88 = v81 - v86;
    else
      v88 = *(_DWORD *)(v7 + 28);
    if (v88 <= 1)
      v89 = 1;
    else
      v89 = v88;
    v1142 = v89;
    v90 = *(_QWORD *)(v7 + 184);
    v91 = *(_QWORD *)(v90 + 8);
    v1306 = *(char **)v90;
    v92 = *(_DWORD *)(v90 + 28);
    v93 = v88 - (*(_QWORD *)v90 - (_DWORD)v91);
    v1064 = v90;
    v1057 = *(_DWORD *)(v90 + 200);
    v94 = ~(-1 << (*(_DWORD *)(v90 + 196) - 1));
    v95 = *(_QWORD *)v90 - v91 - v92;
    v96 = *(_QWORD *)(v7 + 64);
    v1041 = (_DWORD)v1306 - v91;
    v1151 = v94;
    if (v95 <= v94)
      v97 = v92;
    else
      v97 = (_DWORD)v1306 - v91 - v94;
    v1162 = v97;
    v98 = v81 - v85;
    v1173 = v91;
    v99 = v91 - v93;
    v1185 = v92;
    v1134 = v88 - ((_DWORD)v1306 - (_DWORD)v91);
    v100 = v81 - v92 - v93;
    v101 = v23 == 0;
    v1084 = v80;
    v1291 = (_QWORD *)(v80 + v85);
    v1268 = v96;
    v1077 = (unsigned int *)(v96 + 8 * (v81 & ~v83));
    v1342 = 0;
    v1284 = v81 + 9;
    if (v23)
      v102 = 3;
    else
      v102 = 4;
    v103 = v1334 + 4;
    if (v23)
      v104 = 0;
    else
      v104 = -1;
    v105 = v1183;
    v106 = (unint64_t)(v1335 - 7);
    v1257 = v81;
    v1252 = v79;
    v1231 = v85;
    v1215 = v81 - v85;
    v1202 = v104;
    while (1)
    {
      if (v101 == 3)
      {
        v107 = *a3 - 1;
        v108 = v81 - v107;
        v109 = *a3 - 2;
        if (v109 >= v98)
          goto LABEL_118;
      }
      else
      {
        v107 = a3[v101];
        v108 = v81 - v107;
        v109 = v107 - 1;
        if (v107 - 1 >= v98)
        {
LABEL_118:
          if (v109 < v100 && v85 + ~v108 >= 3)
          {
            v111 = v99 + v108;
            if (*(_DWORD *)v14 == *(_DWORD *)v111)
            {
              v112 = v103;
              v1311 = v105;
              v113 = v26;
              v114 = v102;
              v115 = ZSTD_count_2segments(v112, (char *)(v111 + 4), v15, v1306, v1291);
              v102 = v114;
              v98 = v1215;
              LODWORD(v85) = v1231;
              v82 = (char *)(v1334 + 12);
              v79 = v1252;
              v105 = v1311;
              v81 = v1257;
              v26 = v113;
              v14 = v1334;
              v15 = (unint64_t)v1335;
              v106 = (unint64_t)(v1335 - 7);
              v116 = v115 + 4;
              v103 = v1334 + 4;
              v104 = v1202;
              v117 = v116;
              if (v1311 < v116)
                goto LABEL_132;
            }
          }
          goto LABEL_115;
        }
      }
      if (v108 < v88 || *(_DWORD *)v14 != *(_DWORD *)&v14[-v107])
        goto LABEL_115;
      v120 = -(uint64_t)v107;
      v121 = (char *)v103 - v107;
      if (v106 <= (unint64_t)v103)
        break;
      v122 = *v103 ^ *(_QWORD *)v121;
      if (v122)
      {
        v116 = (__clz(__rbit64(v122)) >> 3) + 4;
        v117 = v116;
        if (v105 < v116)
          goto LABEL_132;
        goto LABEL_115;
      }
      v124 = 0;
      do
      {
        v123 = &v82[v124];
        if ((unint64_t)&v82[v124] >= v106)
        {
          v121 = &v123[v120];
          if ((unint64_t)v123 >= v1331)
            goto LABEL_142;
          goto LABEL_140;
        }
        v125 = *(_QWORD *)&v82[v120 + v124];
        v124 += 8;
        v126 = *(_QWORD *)v123 ^ v125;
        v14 = v1334;
      }
      while (!v126);
      v116 = v124 + (__clz(__rbit64(v126)) >> 3) + 4;
      v117 = v116;
      if (v105 < v116)
      {
LABEL_132:
        v119 = &v1336[2 * v26];
        *v119 = v101 + v104;
        v119[1] = v116;
        v26 = (v26 + 1);
        if (v116 > v79)
          goto LABEL_603;
        v105 = v117;
        if (&v14[v117] == (unsigned __int8 *)v15)
          goto LABEL_603;
      }
LABEL_115:
      if (++v101 >= v102)
      {
        *(_DWORD *)(v1108 + 4 * v1092) = v81;
        v127 = ~(-1 << v1100);
        v128 = v1142;
        v129 = v1116;
        if (v1116 < v1142)
        {
          v130 = v1304;
          v131 = v1284;
          v132 = v1084;
          v134 = v1077 + 1;
          v133 = v1077;
LABEL_161:
          v1285 = v131;
          *v134 = 0;
          *v133 = 0;
          v1312 = v26;
          if (!v127)
            goto LABEL_601;
          v14 = v1334;
          v135 = *(_DWORD *)(*(_QWORD *)(v1064 + 48) + 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)v1334) >> -(char)v1057));
          if (v135 <= v1185)
            goto LABEL_602;
          v136 = 0;
          v137 = 0;
          v1232 = *(_QWORD *)(v1064 + 64);
          v1243 = v132 + v1134;
          v1216 = v1257 + 2;
          v1258 = v127 - 1;
          while (1)
          {
            v1269 = v135;
            if (v137 >= v136)
              v138 = v136;
            else
              v138 = v137;
            v139 = v135;
            v140 = v1173 + v135;
            v141 = v105;
            v142 = ZSTD_count_2segments(&v14[v138], (char *)(v140 + v138), v15, v1306, v1291);
            v143 = v142 + v138;
            if (v142 + v138 + v139 >= v1041)
              v144 = v1243 + v139;
            else
              v144 = v140;
            if (v143 <= v141)
            {
              v105 = v141;
              v14 = v1334;
              v15 = (unint64_t)v1335;
              v130 = v1304;
              v147 = v1269;
              if (v1269 <= v1162)
                goto LABEL_602;
            }
            else
            {
              v145 = v1285;
              if (v143 > v1285 - (v1269 + v1134))
                v145 = v1269 + v1134 + v143;
              v1285 = v145;
              v146 = &v1336[2 * v1312];
              *v146 = v1216 - (v1269 + v1134);
              v146[1] = v143;
              ++v1312;
              if (v143 > 0x1000)
              {
LABEL_599:
                v14 = v1334;
                LODWORD(v15) = (_DWORD)v1335;
                v130 = v1304;
                goto LABEL_602;
              }
              v147 = v1269;
              v14 = v1334;
              v15 = (unint64_t)v1335;
              v105 = v142 + v138;
              v130 = v1304;
              if (&v1334[v143] == v1335 || v1269 <= v1162)
                goto LABEL_602;
            }
            v148 = *(unsigned __int8 *)(v144 + v143);
            v149 = v14[v143];
            v63 = v148 >= v149;
            v150 = v148 < v149;
            if (v63)
              v136 = v142 + v138;
            else
              v137 = v142 + v138;
            if (v1258)
            {
              --v1258;
              v135 = *(_DWORD *)(v1232 + 8 * (v147 & v1151) + 4 * v150);
              if (v135 > v1185)
                continue;
            }
            goto LABEL_602;
          }
        }
        v254 = 0;
        v255 = 0;
        v256 = v81 + 2;
        v1315 = v1334 + 8;
        v132 = v1084;
        v257 = v1084 + 8;
        v130 = v1304;
        v131 = v1284;
        v134 = v1077 + 1;
        v133 = v1077;
        v258 = v1126;
        while (2)
        {
          if (v255 >= v254)
            v259 = v254;
          else
            v259 = v255;
          v260 = v129;
          v261 = v129;
          v262 = v1084 + v129;
          v263 = &v1334[v259];
          v264 = (_QWORD *)(v262 + v259);
          if (v1332 <= (char *)&v1334[v259])
          {
            v267 = &v1334[v259];
            if ((unint64_t)v263 >= v1331)
              goto LABEL_341;
          }
          else
          {
            v265 = *(_QWORD *)v263 ^ *v264;
            if (v265)
            {
              v266 = (__clz(__rbit64(v265)) >> 3) + v259;
              if (v266 <= v105)
                goto LABEL_357;
LABEL_350:
              if (v266 > v131 - v260)
                v131 = v260 + v266;
              v268 = &v1336[2 * v26];
              *v268 = v256 - v260;
              v268[1] = v266;
              LODWORD(v26) = v26 + 1;
              if (v266 > 0x1000 || &v1334[v266] == (unsigned __int8 *)v15)
                goto LABEL_574;
              v105 = v266;
LABEL_357:
              v270 = (unsigned int *)(v1268 + 8 * (v260 & v1049));
              if (*(unsigned __int8 *)(v262 + v266) >= v1334[v266])
              {
                *v134 = v260;
                if (v260 <= v258)
                {
                  v134 = (unsigned int *)&v1342;
                  goto LABEL_161;
                }
                v254 = v266;
                v134 = (unsigned int *)(v1268 + 8 * (v260 & v1049));
                v63 = v127-- != 0;
                if (!v63)
                  goto LABEL_161;
              }
              else
              {
                *v133 = v260;
                if (v260 <= v258)
                {
                  v133 = (unsigned int *)&v1342;
                  goto LABEL_161;
                }
                ++v270;
                v255 = v266;
                v133 = v270;
                v63 = v127-- != 0;
                if (!v63)
                  goto LABEL_161;
              }
              v129 = *v270;
              if (*v270 < v128)
                goto LABEL_161;
              continue;
            }
            v271 = v105;
            v272 = 0;
            v273 = (char *)v1315 + v259;
            while (1)
            {
              v274 = &v273[v272];
              if (&v273[v272] >= v1332)
                break;
              v275 = *(_QWORD *)(v257 + v259 + v261 + v272);
              v272 += 8;
              v276 = *(_QWORD *)v274 ^ v275;
              if (v276)
              {
                v277 = __clz(__rbit64(v276));
                v105 = v271;
                v258 = v1126;
                v128 = v1142;
                v266 = v272 + (v277 >> 3) + v259;
                if (v266 <= v105)
                  goto LABEL_357;
                goto LABEL_350;
              }
            }
            v267 = (unsigned __int8 *)v1315 + v259 + v272;
            v264 = (_QWORD *)(v257 + v259 + v261 + v272);
            v105 = v271;
            v258 = v1126;
            v128 = v1142;
            if ((unint64_t)v267 >= v1331)
            {
LABEL_341:
              if ((unint64_t)v267 >= v1330)
              {
                if ((unint64_t)v267 >= v15)
                  goto LABEL_349;
              }
              else
              {
                if (*(unsigned __int16 *)v264 == *(unsigned __int16 *)v267)
                {
                  v267 += 2;
                  v264 = (_QWORD *)((char *)v264 + 2);
                }
                if ((unint64_t)v267 >= v15)
                {
LABEL_349:
                  v266 = v267 - v1334;
                  if (v267 - v1334 <= v105)
                    goto LABEL_357;
                  goto LABEL_350;
                }
              }
              if (*(unsigned __int8 *)v264 == *v267)
                ++v267;
              goto LABEL_349;
            }
          }
          break;
        }
        if (*(_DWORD *)v264 == *(_DWORD *)v267)
        {
          v267 += 4;
          v264 = (_QWORD *)((char *)v264 + 4);
        }
        goto LABEL_341;
      }
    }
    v123 = (char *)v103;
    if ((unint64_t)v103 >= v1331)
      goto LABEL_142;
LABEL_140:
    if (*(_DWORD *)v121 == *(_DWORD *)v123)
    {
      v123 += 4;
      v121 += 4;
    }
LABEL_142:
    if ((unint64_t)v123 >= v1330)
    {
      if ((unint64_t)v123 >= v15)
        goto LABEL_150;
    }
    else
    {
      if (*(unsigned __int16 *)v121 == *(unsigned __int16 *)v123)
      {
        v123 += 2;
        v121 += 2;
      }
      if ((unint64_t)v123 >= v15)
      {
LABEL_150:
        v116 = (_DWORD)v123 - (_DWORD)v103 + 4;
        v117 = v116;
        if (v105 < v116)
          goto LABEL_132;
        goto LABEL_115;
      }
    }
    if (*v121 == *v123)
      LODWORD(v123) = (_DWORD)v123 + 1;
    goto LABEL_150;
  }
  return v15 - (_QWORD)v1266;
}

unint64_t ZSTD_compressBlock_greedy_dedicatedDictSearch(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5)
{
  char *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  _QWORD *v15;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t BestMatch_dedicatedDictSearch_selectMLS;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  uint64_t v36;
  unsigned __int8 *v37;
  unint64_t v39;
  _OWORD *v40;
  char *v41;
  _BYTE *v42;
  char *v43;
  _OWORD *v44;
  __int128 v45;
  char *v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  _OWORD *v50;
  unint64_t v51;
  __int128 *v52;
  __int128 v53;
  uint64_t v54;
  __int16 v55;
  unint64_t v56;
  __int128 *v57;
  _OWORD *v58;
  unint64_t v59;
  __int128 v60;
  char *v61;
  _QWORD *v62;
  unint64_t v63;
  uint64_t v64;
  char v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _QWORD *v74;
  char *v75;
  _QWORD *v76;
  char *v77;
  unint64_t v78;
  unint64_t v79;
  char *v80;
  _DWORD *v81;
  char *v82;
  unint64_t v83;
  unint64_t v84;
  char *v85;
  char *v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  _DWORD *v90;
  __int16 v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  unint64_t v97;
  unsigned int *v99;
  unint64_t v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v105;
  char *v106;
  unint64_t v107;
  unsigned int v108;
  unint64_t v109;
  _QWORD *v110;
  uint64_t v111;

  v5 = (char *)a4;
  v6 = a4 + a5;
  v7 = a4 + a5 - 8;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *(unsigned int *)(a1 + 24);
  v11 = *a3;
  v10 = a3[1];
  v12 = *(_QWORD *)(a1 + 184);
  v14 = *(char **)v12;
  v13 = *(_QWORD *)(v12 + 8);
  v109 = v6;
  v110 = (_QWORD *)(v8 + v9);
  v100 = v13 + *(unsigned int *)(v12 + 24);
  if ((_DWORD)a4 - ((_DWORD)v8 + (_DWORD)v9) - (_DWORD)v100 + *(_QWORD *)v12)
    v15 = (_QWORD *)a4;
  else
    v15 = (_QWORD *)(a4 + 1);
  if ((unint64_t)v15 < v7)
  {
    v99 = a3;
    v17 = v6 - 32;
    v18 = v6 - 7;
    v102 = v6 - 1;
    v103 = v6 - 3;
    v108 = v9 + v13 - (_DWORD)v14;
    v106 = *(char **)v12;
    v107 = v7;
    v19 = v6;
    v105 = *(_QWORD *)(v12 + 8);
    v101 = v13 - v108;
    while (1)
    {
      v21 = v18;
      v22 = v17;
      v23 = (char *)v15 + 1;
      v24 = (_DWORD)v15 - v8 - v11;
      v25 = (v24 + 1);
      v26 = v13 + v25 - v108;
      if (v25 >= v9)
        v26 = v8 + v25;
      if ((v9 - v24 - 5) <= 0xFFFFFFFC && *(_DWORD *)v26 == *(_DWORD *)v23)
        break;
      v111 = 999999999;
      BestMatch_dedicatedDictSearch_selectMLS = ZSTD_HcFindBestMatch_dedicatedDictSearch_selectMLS(a1, v15, v19, &v111);
      v29 = v111;
      if (BestMatch_dedicatedDictSearch_selectMLS)
        v23 = (char *)v15;
      else
        v29 = 0;
      if (BestMatch_dedicatedDictSearch_selectMLS <= 3)
      {
        v15 = (_QWORD *)((char *)v15 + (((char *)v15 - v5) >> 8) + 1);
        v14 = v106;
        v20 = v107;
        v13 = v105;
        v17 = v22;
        v18 = v21;
        v19 = v109;
        goto LABEL_7;
      }
      v17 = v22;
      if (!v29)
      {
        v18 = v21;
        goto LABEL_33;
      }
      v31 = v8 + v9;
      if (v9 > (int)v23 - (int)v8 - (int)v29 + 2)
        v31 = v100;
      v32 = v101;
      if (v9 <= (int)v23 - (int)v8 - (int)v29 + 2)
        v32 = v8;
      if (v23 <= v5 || (v33 = ((_DWORD)v23 - v8 - v29 + 2), v32 + v33 <= v31))
      {
        v18 = v21;
        v36 = v9 + v8 + 8;
      }
      else
      {
        v34 = (unsigned __int8 *)(v32 + v33 - 1);
        v35 = (unsigned __int8 *)(v23 - 1);
        v18 = v21;
        v36 = v9 + v8 + 8;
        while (*v35 == *v34)
        {
          ++BestMatch_dedicatedDictSearch_selectMLS;
          v37 = v35 - 1;
          if (v35 > (unsigned __int8 *)v5)
          {
            --v35;
            if ((unint64_t)v34-- > v31)
              continue;
          }
          v23 = (char *)(v37 + 1);
          goto LABEL_49;
        }
        v23 = (char *)(v35 + 1);
      }
LABEL_49:
      v10 = v11;
      v11 = (v29 - 2);
      v39 = v23 - v5;
      v40 = *(_OWORD **)(a2 + 24);
      if ((unint64_t)v23 <= v17)
      {
LABEL_50:
        *v40 = *(_OWORD *)v5;
        v49 = *(_QWORD *)(a2 + 24);
        if (v39 <= 0x10)
        {
          *(_QWORD *)(a2 + 24) = v49 + v39;
          v54 = *(_QWORD *)(a2 + 8);
          v14 = v106;
          v20 = v107;
          v13 = v105;
          v19 = v109;
          v55 = BestMatch_dedicatedDictSearch_selectMLS - 3;
          *(_WORD *)(v54 + 4) = v39;
          *(_DWORD *)v54 = v29 + 1;
          if (BestMatch_dedicatedDictSearch_selectMLS - 3 >= 0x10000)
            goto LABEL_73;
          goto LABEL_70;
        }
        v50 = (_OWORD *)(v49 + 16);
        v51 = v49 + v39;
        v52 = (__int128 *)(v5 + 16);
        v14 = v106;
        v20 = v107;
        v13 = v105;
        v19 = v109;
        do
        {
          v53 = *v52++;
          *v50++ = v53;
        }
        while ((unint64_t)v50 < v51);
        goto LABEL_68;
      }
LABEL_34:
      if ((unint64_t)v5 <= v17)
      {
        v42 = (char *)v40 + v17 - (_QWORD)v5;
        v43 = v5;
        v44 = v40;
        do
        {
          v45 = *(_OWORD *)v43;
          v43 += 16;
          *v44++ = v45;
        }
        while (v44 < (_OWORD *)v42);
        v41 = (char *)v17;
        v14 = v106;
        v20 = v107;
        v13 = v105;
        v19 = v109;
        if (v17 >= (unint64_t)v23)
          goto LABEL_68;
      }
      else
      {
        v41 = v5;
        v42 = v40;
        v14 = v106;
        v20 = v107;
        v13 = v105;
        v19 = v109;
        if (v5 >= v23)
          goto LABEL_68;
      }
      if ((unint64_t)v5 <= v17)
        v46 = (char *)v17;
      else
        v46 = v5;
      v47 = v23 - v46;
      if ((unint64_t)(v23 - v46) < 8)
      {
        v48 = v41;
        goto LABEL_67;
      }
      if ((unint64_t)((char *)v40 - v5) < 0x20)
      {
        v48 = v41;
        goto LABEL_67;
      }
      if (v47 >= 0x20)
      {
        v56 = v47 & 0xFFFFFFFFFFFFFFE0;
        v57 = (__int128 *)(v41 + 16);
        v58 = (_OWORD *)((char *)v40 + v46 - v5 + 16);
        v59 = v47 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v60 = *v57;
          *(v58 - 1) = *(v57 - 1);
          *v58 = v60;
          v57 += 2;
          v58 += 2;
          v59 -= 32;
        }
        while (v59);
        if (v47 == v56)
          goto LABEL_68;
        if ((v47 & 0x18) == 0)
        {
          v48 = &v41[v56];
          v42 += v56;
          do
          {
LABEL_67:
            v65 = *v48++;
            *v42++ = v65;
          }
          while (v48 < v23);
          goto LABEL_68;
        }
      }
      else
      {
        v56 = 0;
      }
      v42 += v47 & 0xFFFFFFFFFFFFFFF8;
      v48 = &v41[v47 & 0xFFFFFFFFFFFFFFF8];
      v61 = &v41[v56];
      v62 = (_QWORD *)((char *)v40 + &v46[v56] - v5);
      v63 = v56 - (v47 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        v64 = *(_QWORD *)v61;
        v61 += 8;
        *v62++ = v64;
        v63 += 8;
      }
      while (v63);
      if (v47 != (v47 & 0xFFFFFFFFFFFFFFF8))
        goto LABEL_67;
LABEL_68:
      *(_QWORD *)(a2 + 24) += v39;
      v54 = *(_QWORD *)(a2 + 8);
      if (v39 >= 0x10000)
      {
        v67 = (unint64_t)(v54 - *(_QWORD *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v67;
        v55 = BestMatch_dedicatedDictSearch_selectMLS - 3;
        *(_WORD *)(v54 + 4) = v39;
        *(_DWORD *)v54 = v29 + 1;
        if (BestMatch_dedicatedDictSearch_selectMLS - 3 >= 0x10000)
        {
LABEL_73:
          v68 = (unint64_t)(v54 - *(_QWORD *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v68;
          *(_WORD *)(v54 + 6) = v55;
          v66 = v54 + 8;
          *(_QWORD *)(a2 + 8) = v54 + 8;
          v5 = &v23[BestMatch_dedicatedDictSearch_selectMLS];
          if ((unint64_t)&v23[BestMatch_dedicatedDictSearch_selectMLS] > v20)
          {
LABEL_71:
            v15 = v5;
            goto LABEL_7;
          }
          goto LABEL_74;
        }
      }
      else
      {
        v55 = BestMatch_dedicatedDictSearch_selectMLS - 3;
        *(_WORD *)(v54 + 4) = v39;
        *(_DWORD *)v54 = v29 + 1;
        if (BestMatch_dedicatedDictSearch_selectMLS - 3 >= 0x10000)
          goto LABEL_73;
      }
LABEL_70:
      *(_WORD *)(v54 + 6) = v55;
      v66 = v54 + 8;
      *(_QWORD *)(a2 + 8) = v54 + 8;
      v5 = &v23[BestMatch_dedicatedDictSearch_selectMLS];
      if ((unint64_t)&v23[BestMatch_dedicatedDictSearch_selectMLS] > v20)
        goto LABEL_71;
LABEL_74:
      v69 = v11;
      v70 = v10;
      while (1)
      {
        v11 = v70;
        v70 = v69;
        v71 = ((_DWORD)v5 - v8 - v11);
        v72 = v71 >= v9 ? v8 : v101;
        if ((v9 + ~(_DWORD)v71) < 3)
          break;
        v73 = v72 + v71;
        if (*(_DWORD *)(v72 + v71) != *(_DWORD *)v5)
          break;
        if (v71 >= v9)
          v74 = (_QWORD *)v19;
        else
          v74 = v14;
        v75 = v5 + 4;
        v76 = (_QWORD *)(v73 + 4);
        v77 = (char *)v74 + (_QWORD)v5 - v73;
        if ((unint64_t)v77 >= v19)
          v77 = (char *)v19;
        if (v77 - 7 <= v75)
        {
          v80 = v5 + 4;
          v81 = v76;
          if (v75 < v77 - 3)
          {
LABEL_91:
            if (*v81 == *(_DWORD *)v80)
            {
              v80 += 4;
              ++v81;
            }
          }
        }
        else
        {
          v78 = *(_QWORD *)v75 ^ *v76;
          if (v78)
          {
            v79 = __clz(__rbit64(v78)) >> 3;
            if ((_QWORD *)((char *)v76 + v79) != v74)
              goto LABEL_119;
            goto LABEL_98;
          }
          v85 = v5 + 12;
          while (1)
          {
            v86 = &v85[v78];
            if (&v85[v78] >= v77 - 7)
              break;
            v87 = *(_QWORD *)(v72 + v71 + 12 + v78);
            v78 += 8;
            v88 = *(_QWORD *)v86 ^ v87;
            if (v88)
            {
              v79 = v78 + (__clz(__rbit64(v88)) >> 3);
              v19 = v109;
              if ((_QWORD *)((char *)v76 + v79) != v74)
                goto LABEL_119;
              goto LABEL_98;
            }
          }
          v80 = &v5[v78 + 12];
          v81 = (_DWORD *)(v72 + v71 + v78 + 12);
          v19 = v109;
          if (v80 < v77 - 3)
            goto LABEL_91;
        }
        if (v80 >= v77 - 1)
        {
          if (v80 >= v77)
            goto LABEL_97;
LABEL_95:
          if (*(unsigned __int8 *)v81 == *v80)
            ++v80;
          goto LABEL_97;
        }
        if (*(unsigned __int16 *)v81 == *(unsigned __int16 *)v80)
        {
          v80 += 2;
          v81 = (_DWORD *)((char *)v81 + 2);
        }
        if (v80 < v77)
          goto LABEL_95;
LABEL_97:
        v79 = v80 - v75;
        if ((_QWORD *)((char *)v76 + v80 - v75) != v74)
          goto LABEL_119;
LABEL_98:
        v82 = &v75[v79];
        if (v18 <= (unint64_t)v82)
        {
          v89 = v82;
          v90 = (_DWORD *)(v8 + v9);
          if ((unint64_t)v82 >= v103)
            goto LABEL_113;
          goto LABEL_111;
        }
        v83 = *(_QWORD *)v82 ^ *v110;
        if (!v83)
        {
          v93 = 0;
          v94 = (uint64_t)&v5[v79 + 12];
          while (1)
          {
            v95 = (_QWORD *)(v94 + v93);
            if (v94 + v93 >= v18)
              break;
            v96 = *(_QWORD *)(v36 + v93);
            v93 += 8;
            v97 = *v95 ^ v96;
            if (v97)
            {
              v84 = v93 + (__clz(__rbit64(v97)) >> 3);
              goto LABEL_118;
            }
          }
          v89 = &v5[v79 + 12 + v93];
          v90 = (_DWORD *)(v36 + v93);
          if ((unint64_t)v89 >= v103)
          {
LABEL_113:
            if ((unint64_t)v89 < v102)
            {
              if (*(unsigned __int16 *)v90 == *(unsigned __int16 *)v89)
              {
                v89 += 2;
                v90 = (_DWORD *)((char *)v90 + 2);
              }
              if ((unint64_t)v89 < v19)
              {
LABEL_115:
                if (*(unsigned __int8 *)v90 == *v89)
                  ++v89;
              }
            }
            else if ((unint64_t)v89 < v19)
            {
              goto LABEL_115;
            }
            v84 = v89 - v82;
            goto LABEL_118;
          }
LABEL_111:
          if (*v90 == *(_DWORD *)v89)
          {
            v89 += 4;
            ++v90;
          }
          goto LABEL_113;
        }
        v84 = __clz(__rbit64(v83)) >> 3;
LABEL_118:
        v79 += v84;
LABEL_119:
        if ((unint64_t)v5 <= v17)
        {
          *(_OWORD *)*(_QWORD *)(a2 + 24) = *(_OWORD *)v5;
          v66 = *(_QWORD *)(a2 + 8);
          v91 = v79 + 1;
          *(_WORD *)(v66 + 4) = 0;
          *(_DWORD *)v66 = 1;
          if (v79 + 1 >= 0x10000)
          {
LABEL_123:
            v92 = (unint64_t)(v66 - *(_QWORD *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v92;
          }
        }
        else
        {
          v91 = v79 + 1;
          *(_WORD *)(v66 + 4) = 0;
          *(_DWORD *)v66 = 1;
          if (v79 + 1 >= 0x10000)
            goto LABEL_123;
        }
        *(_WORD *)(v66 + 6) = v91;
        v66 += 8;
        v5 += v79 + 4;
        *(_QWORD *)(a2 + 8) = v66;
        v69 = v11;
        v10 = v70;
        v15 = v5;
        if ((unint64_t)v5 > v20)
          goto LABEL_7;
      }
      v10 = v11;
      v11 = v69;
      v15 = v5;
LABEL_7:
      if ((unint64_t)v15 >= v20)
      {
        a3 = v99;
        goto LABEL_138;
      }
    }
    if (v25 >= v9)
      v27 = (char *)v19;
    else
      v27 = v14;
    v28 = ZSTD_count_2segments((_QWORD *)((char *)v15 + 5), (char *)(v26 + 4), v19, v27, v110);
    LODWORD(v29) = 0;
    BestMatch_dedicatedDictSearch_selectMLS = v28 + 4;
    v17 = v22;
    v18 = v21;
LABEL_33:
    v36 = v9 + v8 + 8;
    v39 = v23 - v5;
    v40 = *(_OWORD **)(a2 + 24);
    if ((unint64_t)v23 <= v17)
      goto LABEL_50;
    goto LABEL_34;
  }
LABEL_138:
  *a3 = v11;
  a3[1] = v10;
  return v109 - (_QWORD)v5;
}

unint64_t ZSTD_compressBlock_lazy_dedicatedDictSearch(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  unsigned __int8 *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  unint64_t v21;
  unint64_t BestMatch_dedicatedDictSearch_selectMLS;
  unint64_t v23;
  char v24;
  unsigned __int8 *v25;
  uint64_t v26;
  char *v27;
  unsigned __int8 *v28;
  uint64_t v29;
  _DWORD *v30;
  char *v31;
  char *v32;
  _QWORD *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unsigned __int8 *v39;
  _DWORD *v40;
  char *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  unsigned __int8 *v48;
  unint64_t v49;
  int v50;
  BOOL v51;
  unint64_t v52;
  uint64_t v53;
  char *v54;
  char *v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unsigned __int8 *v62;
  uint64_t v63;
  unsigned __int8 *v64;
  unsigned __int8 *v65;
  unsigned __int8 *v66;
  unint64_t v67;
  _OWORD *v68;
  uint64_t v69;
  uint64_t v70;
  _OWORD *v71;
  unint64_t v72;
  __int128 *v73;
  __int128 v74;
  uint64_t v75;
  __int16 v76;
  _OWORD *v77;
  _BYTE *v78;
  unsigned __int8 *v79;
  _OWORD *v80;
  __int128 v81;
  unsigned __int8 *v82;
  unint64_t v83;
  unsigned __int8 *v84;
  unint64_t v85;
  __int128 *v86;
  _OWORD *v87;
  unint64_t v88;
  __int128 v89;
  uint64_t *v90;
  _QWORD *v91;
  unint64_t v92;
  uint64_t v93;
  char v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  _QWORD *v103;
  char *v104;
  _QWORD *v105;
  char *v106;
  unint64_t v107;
  unint64_t v108;
  __int16 v109;
  char *v110;
  _DWORD *v111;
  char *v112;
  unint64_t v113;
  char *v114;
  char *v115;
  uint64_t v116;
  unint64_t v117;
  unsigned __int8 *v118;
  unsigned __int8 *v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  unint64_t v125;
  unsigned int *v127;
  unsigned __int8 *v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  uint64_t v133;
  char *v134;
  unsigned __int8 *v135;
  unsigned int v136;
  uint64_t v137;
  uint64_t v138;
  unsigned int v139;
  unsigned __int8 *v141;
  uint64_t v142;

  v5 = a4;
  v6 = (unint64_t)&a4[a5];
  v7 = (unint64_t)&a4[a5 - 8];
  v8 = *(_QWORD *)(a1 + 8);
  v9 = *(unsigned int *)(a1 + 24);
  v11 = *a3;
  LODWORD(v10) = a3[1];
  v12 = *(_QWORD *)(a1 + 184);
  v14 = *(char **)v12;
  v13 = *(_QWORD *)(v12 + 8);
  v135 = (unsigned __int8 *)(v8 + v9);
  v129 = (unsigned __int8 *)(v13 + *(unsigned int *)(v12 + 24));
  if ((_DWORD)a4 - ((_DWORD)v8 + (_DWORD)v9) - (_DWORD)v129 + *(_QWORD *)v12)
    v15 = a4;
  else
    v15 = a4 + 1;
  v141 = (unsigned __int8 *)v7;
  if ((unint64_t)v15 < v7)
  {
    v16 = a2;
    v127 = a3;
    v131 = v6 - 1;
    v132 = v6 - 3;
    v133 = v9 + v8 + 8;
    v139 = v9 + v13 - (_DWORD)v14;
    v130 = v13 - v139;
    v137 = *(_QWORD *)(a1 + 8);
    v138 = *(_QWORD *)(v12 + 8);
    v134 = *(char **)v12;
    while (1)
    {
      v17 = (_DWORD)v15 - v8 - v11;
      v18 = (v17 + 1);
      v19 = v13 + v18 - v139;
      if (v18 >= v9)
        v19 = v8 + v18;
      v136 = v10;
      if ((v9 - v17 - 5) <= 0xFFFFFFFC && *(_DWORD *)v19 == *(_DWORD *)(v15 + 1))
      {
        if (v18 >= v9)
          v20 = (char *)v6;
        else
          v20 = v14;
        v21 = ZSTD_count_2segments(v15 + 5, (char *)(v19 + 4), v6, v20, v135) + 4;
      }
      else
      {
        v21 = 0;
      }
      v142 = 999999999;
      BestMatch_dedicatedDictSearch_selectMLS = ZSTD_HcFindBestMatch_dedicatedDictSearch_selectMLS(a1, v15, v6, &v142);
      if (BestMatch_dedicatedDictSearch_selectMLS <= v21)
        v23 = v21;
      else
        v23 = BestMatch_dedicatedDictSearch_selectMLS;
      if (v23 < 4)
      {
        v15 += ((v15 - v5) >> 8) + 1;
        v13 = v138;
        v14 = v134;
        LODWORD(v10) = v136;
        goto LABEL_7;
      }
      v24 = BestMatch_dedicatedDictSearch_selectMLS > v21;
      if (BestMatch_dedicatedDictSearch_selectMLS <= v21)
        v25 = v15 + 1;
      else
        v25 = v15;
      if (v24)
        v26 = v142;
      else
        v26 = 0;
      v13 = v138;
      if (v15 >= v141)
      {
LABEL_94:
        v59 = v133;
        v58 = v6 - 7;
        v60 = v6 - 32;
        v10 = v136;
        if (!v26)
          goto LABEL_112;
LABEL_95:
        v61 = v137;
        v62 = v135;
        if (v9 > (int)v25 - ((int)v26 + (int)v137) + 2)
        {
          v62 = v129;
          v61 = v130;
        }
        if (v25 <= v5 || (v63 = ((_DWORD)v25 - (v26 + v137) + 2), v61 + v63 <= (unint64_t)v62))
        {
LABEL_104:
          v10 = v11;
          v11 = (v26 - 2);
          v67 = v25 - v5;
          v68 = *(_OWORD **)(v16 + 24);
          if ((unint64_t)v25 > v60)
            goto LABEL_113;
          goto LABEL_105;
        }
        v64 = (unsigned __int8 *)(v61 + v63 - 1);
        v65 = v25 - 1;
        while (*v65 == *v64)
        {
          ++v23;
          v66 = v65 - 1;
          if (v65 > v5)
          {
            --v65;
            v24 = v64-- > v62;
            if (v24)
              continue;
          }
          v25 = v66 + 1;
          goto LABEL_104;
        }
        v25 = v65 + 1;
        v10 = v11;
        v11 = (v26 - 2);
        v67 = v65 + 1 - v5;
        v68 = *(_OWORD **)(v16 + 24);
        if ((unint64_t)v25 <= v60)
          goto LABEL_105;
LABEL_113:
        if ((unint64_t)v5 <= v60)
        {
          v78 = (char *)v68 + v60 - (_QWORD)v5;
          v79 = v5;
          v80 = v68;
          do
          {
            v81 = *(_OWORD *)v79;
            v79 += 16;
            *v80++ = v81;
          }
          while (v80 < (_OWORD *)v78);
          v70 = v10;
          v77 = (_OWORD *)v60;
          if (v60 >= (unint64_t)v25)
            goto LABEL_140;
        }
        else
        {
          v70 = v10;
          v77 = v5;
          v78 = v68;
          if (v5 >= v25)
            goto LABEL_140;
        }
        if ((unint64_t)v5 <= v60)
          v82 = (unsigned __int8 *)v60;
        else
          v82 = v5;
        v83 = v25 - v82;
        if ((unint64_t)(v25 - v82) < 8)
        {
          v84 = (unsigned __int8 *)v77;
          goto LABEL_139;
        }
        if ((unint64_t)((char *)v68 - (char *)v5) < 0x20)
        {
          v84 = (unsigned __int8 *)v77;
          goto LABEL_139;
        }
        if (v83 < 0x20)
        {
          v85 = 0;
          goto LABEL_134;
        }
        v85 = v83 & 0xFFFFFFFFFFFFFFE0;
        v86 = v77 + 1;
        v87 = (_OWORD *)((char *)v68 + v82 - v5 + 16);
        v88 = v83 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v89 = *v86;
          *(v87 - 1) = *(v86 - 1);
          *v87 = v89;
          v86 += 2;
          v87 += 2;
          v88 -= 32;
        }
        while (v88);
        if (v83 == v85)
          goto LABEL_140;
        if ((v83 & 0x18) != 0)
        {
LABEL_134:
          v78 += v83 & 0xFFFFFFFFFFFFFFF8;
          v84 = (unsigned __int8 *)v77 + (v83 & 0xFFFFFFFFFFFFFFF8);
          v90 = (uint64_t *)((char *)v77 + v85);
          v91 = (_QWORD *)((char *)v68 + &v82[v85] - v5);
          v92 = v85 - (v83 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            v93 = *v90++;
            *v91++ = v93;
            v92 += 8;
          }
          while (v92);
          if (v83 == (v83 & 0xFFFFFFFFFFFFFFF8))
            goto LABEL_140;
        }
        else
        {
          v84 = (unsigned __int8 *)v77 + v85;
          v78 += v85;
        }
        do
        {
LABEL_139:
          v94 = *v84++;
          *v78++ = v94;
        }
        while (v84 < v25);
        goto LABEL_140;
      }
      v27 = (char *)(v15 + 13);
      do
      {
        v28 = v15 + 1;
        v29 = ((_DWORD)v15 + 1 - v137 - v11);
        if (v29 >= v9)
          v30 = (_DWORD *)(v137 + v29);
        else
          v30 = (_DWORD *)(v13 + v29 - v139);
        if ((v9 + ~(_DWORD)v29) < 3 || *v30 != *(_DWORD *)v28)
          goto LABEL_81;
        if (v29 >= v9)
          v31 = (char *)v6;
        else
          v31 = v134;
        v32 = (char *)(v15 + 5);
        v33 = v30 + 1;
        v34 = (unint64_t)&v15[v31 - (char *)(v30 + 1) + 5];
        if (v34 >= v6)
          v34 = v6;
        if (v34 - 7 <= (unint64_t)v32)
        {
          v39 = v15 + 5;
          v40 = v30 + 1;
          v37 = v133;
          v36 = v6 - 7;
          if ((unint64_t)v32 < v34 - 3)
          {
LABEL_44:
            if (*v40 == *(_DWORD *)v39)
            {
              v39 += 4;
              ++v40;
            }
          }
        }
        else
        {
          v35 = *(_QWORD *)v32 ^ *v33;
          v37 = v133;
          v36 = v6 - 7;
          if (v35)
          {
            v38 = __clz(__rbit64(v35)) >> 3;
            if ((char *)v33 + v38 != v31)
              goto LABEL_76;
            goto LABEL_55;
          }
          v44 = 0;
          while (1)
          {
            v39 = &v15[v44 * 4 + 13];
            if ((unint64_t)v39 >= v34 - 7)
              break;
            v45 = *(_QWORD *)&v30[v44 + 3];
            v44 += 2;
            v46 = *(_QWORD *)v39 ^ v45;
            if (v46)
            {
              v38 = v44 * 4 + (__clz(__rbit64(v46)) >> 3);
              if ((char *)v33 + v38 != v31)
                goto LABEL_76;
              goto LABEL_55;
            }
          }
          v40 = &v30[v44 + 3];
          if ((unint64_t)v39 < v34 - 3)
            goto LABEL_44;
        }
        if ((unint64_t)v39 >= v34 - 1)
        {
          if ((unint64_t)v39 >= v34)
            goto LABEL_54;
LABEL_52:
          if (*(unsigned __int8 *)v40 == *v39)
            ++v39;
          goto LABEL_54;
        }
        if (*(unsigned __int16 *)v40 == *(unsigned __int16 *)v39)
        {
          v39 += 2;
          v40 = (_DWORD *)((char *)v40 + 2);
        }
        if ((unint64_t)v39 < v34)
          goto LABEL_52;
LABEL_54:
        v38 = v39 - (unsigned __int8 *)v32;
        if ((char *)v33 + v39 - (unsigned __int8 *)v32 != v31)
          goto LABEL_76;
LABEL_55:
        v41 = &v32[v38];
        if (v36 <= (unint64_t)v41)
        {
          v47 = v41;
          v48 = v135;
          if ((unint64_t)v41 >= v132)
            goto LABEL_66;
          goto LABEL_64;
        }
        v42 = *(_QWORD *)v41 ^ *(_QWORD *)v135;
        if (!v42)
        {
          v53 = 0;
          v54 = &v27[v38];
          while (1)
          {
            v55 = &v54[v53];
            if ((unint64_t)&v54[v53] >= v36)
              break;
            v56 = *(_QWORD *)(v37 + v53);
            v53 += 8;
            v57 = *(_QWORD *)v55 ^ v56;
            if (v57)
            {
              v43 = v53 + (__clz(__rbit64(v57)) >> 3);
              goto LABEL_75;
            }
          }
          v47 = &v27[v38 + v53];
          v48 = (unsigned __int8 *)(v37 + v53);
          if ((unint64_t)v47 >= v132)
          {
LABEL_66:
            if ((unint64_t)v47 >= v131)
            {
              if ((unint64_t)v47 < v6)
                goto LABEL_72;
            }
            else
            {
              if (*(unsigned __int16 *)v48 == *(unsigned __int16 *)v47)
              {
                v47 += 2;
                v48 += 2;
              }
              if ((unint64_t)v47 >= v6)
                goto LABEL_74;
LABEL_72:
              if (*v48 == *v47)
                ++v47;
            }
LABEL_74:
            v43 = v47 - v41;
            goto LABEL_75;
          }
LABEL_64:
          if (*(_DWORD *)v48 == *(_DWORD *)v47)
          {
            v47 += 4;
            v48 += 4;
          }
          goto LABEL_66;
        }
        v43 = __clz(__rbit64(v42)) >> 3;
LABEL_75:
        v38 += v43;
LABEL_76:
        v49 = v38 + 4;
        v24 = (v38 != -5) & __CFADD__(v38, 5);
        v50 = 3 * v23 + (__clz(v26 + 1) ^ 0xFFFFFFE0) + 2;
        if (v24)
          v51 = 1;
        else
          v51 = 3 * (int)v49 <= v50;
        if (!v51)
        {
          v26 = 0;
          v23 = v49;
          v25 = v15 + 1;
        }
LABEL_81:
        v142 = 999999999;
        v52 = ZSTD_HcFindBestMatch_dedicatedDictSearch_selectMLS(a1, v15 + 1, v6, &v142);
        if (v52 < 4
          || (int)((__clz(v142 + 1) ^ 0xFFFFFFE0) + 4 * v52 + 1) <= (int)((__clz(v26 + 1) ^ 0xFFFFFFE0) + 4 * v23 + 5))
        {
          v16 = a2;
          v13 = v138;
          goto LABEL_94;
        }
        ++v27;
        ++v15;
        v25 = v28;
        v26 = v142;
        v23 = v52;
        v13 = v138;
      }
      while (v28 != v141);
      v23 = v52;
      LODWORD(v26) = v142;
      v25 = v141;
      v16 = a2;
      v59 = v133;
      v58 = v6 - 7;
      v60 = v6 - 32;
      v10 = v136;
      if (v142)
        goto LABEL_95;
LABEL_112:
      v67 = v25 - v5;
      v68 = *(_OWORD **)(v16 + 24);
      if ((unint64_t)v25 > v60)
        goto LABEL_113;
LABEL_105:
      *v68 = *(_OWORD *)v5;
      v69 = *(_QWORD *)(v16 + 24);
      if (v67 <= 0x10)
      {
        *(_QWORD *)(v16 + 24) = v69 + v67;
        v75 = *(_QWORD *)(v16 + 8);
        v76 = v23 - 3;
        *(_WORD *)(v75 + 4) = v67;
        *(_DWORD *)v75 = v26 + 1;
        if (v23 - 3 >= 0x10000)
          goto LABEL_143;
      }
      else
      {
        v70 = v10;
        v71 = (_OWORD *)(v69 + 16);
        v72 = v69 + v67;
        v73 = (__int128 *)(v5 + 16);
        do
        {
          v74 = *v73++;
          *v71++ = v74;
        }
        while ((unint64_t)v71 < v72);
LABEL_140:
        *(_QWORD *)(v16 + 24) += v67;
        v75 = *(_QWORD *)(v16 + 8);
        if (v67 >= 0x10000)
        {
          v95 = (unint64_t)(v75 - *(_QWORD *)v16) >> 3;
          *(_DWORD *)(v16 + 72) = 1;
          *(_DWORD *)(v16 + 76) = v95;
        }
        v10 = v70;
        v76 = v23 - 3;
        *(_WORD *)(v75 + 4) = v67;
        *(_DWORD *)v75 = v26 + 1;
        if (v23 - 3 >= 0x10000)
        {
LABEL_143:
          v96 = (unint64_t)(v75 - *(_QWORD *)v16) >> 3;
          *(_DWORD *)(v16 + 72) = 2;
          *(_DWORD *)(v16 + 76) = v96;
        }
      }
      *(_WORD *)(v75 + 6) = v76;
      v97 = v75 + 8;
      *(_QWORD *)(v16 + 8) = v75 + 8;
      v5 = &v25[v23];
      v8 = v137;
      if (&v25[v23] > v141)
      {
        v15 = &v25[v23];
        v14 = v134;
        goto LABEL_7;
      }
      v98 = v11;
      v99 = v10;
      v14 = v134;
      while (2)
      {
        v11 = v99;
        v99 = v98;
        v100 = ((_DWORD)v5 - v137 - v11);
        if (v100 >= v9)
          v101 = v137;
        else
          v101 = v130;
        if ((v9 + ~(_DWORD)v100) >= 3)
        {
          v102 = v101 + v100;
          if (*(_DWORD *)(v101 + v100) == *(_DWORD *)v5)
          {
            if (v100 >= v9)
              v103 = (_QWORD *)v6;
            else
              v103 = v134;
            v104 = (char *)(v5 + 4);
            v105 = (_QWORD *)(v102 + 4);
            v106 = (char *)v103 + (_QWORD)v5 - v102;
            if ((unint64_t)v106 >= v6)
              v106 = (char *)v6;
            if (v106 - 7 <= v104)
            {
              v110 = (char *)(v5 + 4);
              v111 = v105;
              if (v104 < v106 - 3)
              {
LABEL_165:
                if (*v111 == *(_DWORD *)v110)
                {
                  v110 += 4;
                  ++v111;
                }
              }
            }
            else
            {
              v107 = *(_QWORD *)v104 ^ *v105;
              if (v107)
              {
                v108 = __clz(__rbit64(v107)) >> 3;
                if ((_QWORD *)((char *)v105 + v108) != v103)
                  goto LABEL_161;
LABEL_176:
                v112 = &v104[v108];
                if (v58 <= (unint64_t)v112)
                {
                  v118 = (unsigned __int8 *)v112;
                  v119 = v135;
                  if ((unint64_t)v112 < v132)
                  {
LABEL_186:
                    if (*(_DWORD *)v119 == *(_DWORD *)v118)
                    {
                      v118 += 4;
                      v119 += 4;
                    }
                  }
                }
                else
                {
                  v113 = *(_QWORD *)v112 ^ *(_QWORD *)v135;
                  if (v113)
                  {
                    v108 += __clz(__rbit64(v113)) >> 3;
                    if ((unint64_t)v5 > v60)
                      goto LABEL_162;
LABEL_197:
                    *(_OWORD *)*(_QWORD *)(v16 + 24) = *(_OWORD *)v5;
                    v97 = *(_QWORD *)(v16 + 8);
                    v109 = v108 + 1;
                    *(_WORD *)(v97 + 4) = 0;
                    *(_DWORD *)v97 = 1;
                    if (v108 + 1 >= 0x10000)
                    {
LABEL_198:
                      v120 = (unint64_t)(v97 - *(_QWORD *)v16) >> 3;
                      *(_DWORD *)(v16 + 72) = 2;
                      *(_DWORD *)(v16 + 76) = v120;
                    }
LABEL_147:
                    *(_WORD *)(v97 + 6) = v109;
                    v97 += 8;
                    v5 += v108 + 4;
                    *(_QWORD *)(v16 + 8) = v97;
                    v98 = v11;
                    LODWORD(v10) = v99;
                    v15 = v5;
                    if (v5 > v141)
                      goto LABEL_7;
                    continue;
                  }
                  v121 = 0;
                  v122 = (uint64_t)&v5[v108 + 12];
                  while (1)
                  {
                    v123 = (_QWORD *)(v122 + v121);
                    if (v122 + v121 >= v58)
                      break;
                    v124 = *(_QWORD *)(v59 + v121);
                    v121 += 8;
                    v125 = *v123 ^ v124;
                    if (v125)
                    {
                      v108 += v121 + (__clz(__rbit64(v125)) >> 3);
                      if ((unint64_t)v5 <= v60)
                        goto LABEL_197;
                      goto LABEL_162;
                    }
                  }
                  v118 = &v5[v108 + 12 + v121];
                  v119 = (unsigned __int8 *)(v59 + v121);
                  if ((unint64_t)v118 < v132)
                    goto LABEL_186;
                }
                if ((unint64_t)v118 >= v131)
                {
                  if ((unint64_t)v118 >= v6)
                    goto LABEL_196;
                }
                else
                {
                  if (*(unsigned __int16 *)v119 == *(unsigned __int16 *)v118)
                  {
                    v118 += 2;
                    v119 += 2;
                  }
                  if ((unint64_t)v118 >= v6)
                  {
LABEL_196:
                    v108 += v118 - (unsigned __int8 *)v112;
                    if ((unint64_t)v5 > v60)
                      goto LABEL_162;
                    goto LABEL_197;
                  }
                }
                if (*v119 == *v118)
                  ++v118;
                goto LABEL_196;
              }
              v114 = (char *)(v5 + 12);
              while (1)
              {
                v115 = &v114[v107];
                if (&v114[v107] >= v106 - 7)
                  break;
                v116 = *(_QWORD *)(v101 + v100 + 12 + v107);
                v107 += 8;
                v117 = *(_QWORD *)v115 ^ v116;
                if (v117)
                {
                  v108 = v107 + (__clz(__rbit64(v117)) >> 3);
                  if ((_QWORD *)((char *)v105 + v108) != v103)
                    goto LABEL_161;
                  goto LABEL_176;
                }
              }
              v110 = (char *)&v5[v107 + 12];
              v111 = (_DWORD *)(v101 + v100 + v107 + 12);
              if (v110 < v106 - 3)
                goto LABEL_165;
            }
            if (v110 >= v106 - 1)
            {
              if (v110 >= v106)
                goto LABEL_175;
            }
            else
            {
              if (*(unsigned __int16 *)v111 == *(unsigned __int16 *)v110)
              {
                v110 += 2;
                v111 = (_DWORD *)((char *)v111 + 2);
              }
              if (v110 >= v106)
              {
LABEL_175:
                v108 = v110 - v104;
                if ((_QWORD *)((char *)v105 + v110 - v104) == v103)
                  goto LABEL_176;
LABEL_161:
                if ((unint64_t)v5 <= v60)
                  goto LABEL_197;
LABEL_162:
                v109 = v108 + 1;
                *(_WORD *)(v97 + 4) = 0;
                *(_DWORD *)v97 = 1;
                if (v108 + 1 >= 0x10000)
                  goto LABEL_198;
                goto LABEL_147;
              }
            }
            if (*(unsigned __int8 *)v111 == *v110)
              ++v110;
            goto LABEL_175;
          }
        }
        break;
      }
      LODWORD(v10) = v11;
      v11 = v98;
      v15 = v5;
LABEL_7:
      if (v15 >= v141)
      {
        a3 = v127;
        break;
      }
    }
  }
  *a3 = v11;
  a3[1] = v10;
  return v6 - (_QWORD)v5;
}

unint64_t ZSTD_compressBlock_lazy2_dedicatedDictSearch(uint64_t a1, uint64_t a2, unsigned int *a3, char *a4, uint64_t a5)
{
  char *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unint64_t v20;
  unint64_t BestMatch_dedicatedDictSearch_selectMLS;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned __int8 *v37;
  unint64_t v38;
  _OWORD *v39;
  uint64_t v40;
  _DWORD *v41;
  char *v42;
  char *v43;
  _QWORD *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  _DWORD *v51;
  char *v52;
  unint64_t v53;
  unint64_t v54;
  char *v55;
  char *v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  _DWORD *v60;
  unint64_t v61;
  int v62;
  char v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _OWORD *v75;
  unint64_t v76;
  __int128 *v77;
  __int128 v78;
  uint64_t v79;
  __int16 v80;
  _OWORD *v81;
  _BYTE *v82;
  __int128 *v83;
  _OWORD *v84;
  __int128 v85;
  char *v86;
  unint64_t v87;
  char *v88;
  unint64_t v89;
  __int128 *v90;
  _OWORD *v91;
  unint64_t v92;
  __int128 v93;
  uint64_t *v94;
  _QWORD *v95;
  unint64_t v96;
  uint64_t v97;
  char v98;
  unint64_t v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  _QWORD *v107;
  char *v108;
  _QWORD *v109;
  char *v110;
  unint64_t v111;
  unint64_t v112;
  __int16 v113;
  char *v114;
  _DWORD *v115;
  char *v116;
  unint64_t v117;
  char *v118;
  char *v119;
  uint64_t v120;
  unint64_t v121;
  char *v122;
  _DWORD *v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  _QWORD *v127;
  uint64_t v128;
  unint64_t v129;
  unsigned int *v131;
  unint64_t v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v136;
  unint64_t v137;
  unsigned int v138;
  unint64_t v139;
  _QWORD *v140;
  uint64_t v141;
  unsigned int v142;
  unint64_t v144;
  uint64_t v145;

  v5 = a4;
  v6 = (unint64_t)&a4[a5];
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(unsigned int *)(a1 + 24);
  v10 = *a3;
  LODWORD(v9) = a3[1];
  v11 = *(_QWORD *)(a1 + 184);
  v12 = *(char **)v11;
  v13 = *(_QWORD *)(v11 + 8);
  v140 = (_QWORD *)(v7 + v8);
  v132 = v13 + *(unsigned int *)(v11 + 24);
  if ((_DWORD)a4 - ((_DWORD)v7 + (_DWORD)v8) - (_DWORD)v132 + *(_QWORD *)v11)
    v14 = a4;
  else
    v14 = a4 + 1;
  v144 = (unint64_t)&a4[a5 - 8];
  if ((unint64_t)v14 >= v144)
    goto LABEL_222;
  v131 = a3;
  v136 = v6 - 1;
  v137 = v6 - 3;
  v133 = v6 - 32;
  v142 = v8 + v13 - (_DWORD)v12;
  v134 = v13 - v142;
  v139 = *(_QWORD *)v11;
  v141 = *(_QWORD *)(v11 + 8);
  while (2)
  {
    v15 = v14 + 1;
    v16 = (_DWORD)v14 - v7 - v10;
    v17 = (v16 + 1);
    v18 = v13 + v17 - v142;
    if (v17 >= v8)
      v18 = v7 + v17;
    v138 = v9;
    if ((v8 - v16 - 5) <= 0xFFFFFFFC && *(_DWORD *)v18 == *(_DWORD *)v15)
    {
      if (v17 >= v8)
        v19 = (char *)v6;
      else
        v19 = v12;
      v20 = ZSTD_count_2segments(v14 + 5, (char *)(v18 + 4), v6, v19, v140) + 4;
    }
    else
    {
      v20 = 0;
    }
    v145 = 999999999;
    BestMatch_dedicatedDictSearch_selectMLS = ZSTD_HcFindBestMatch_dedicatedDictSearch_selectMLS(a1, v14, v6, &v145);
    if (BestMatch_dedicatedDictSearch_selectMLS <= v20)
      v22 = v20;
    else
      v22 = BestMatch_dedicatedDictSearch_selectMLS;
    if (v22 < 4)
    {
      v14 += ((v14 - v5) >> 8) + 1;
      v12 = (char *)v139;
      LODWORD(v9) = v138;
      goto LABEL_7;
    }
    if (BestMatch_dedicatedDictSearch_selectMLS <= v20)
    {
      v23 = 0;
    }
    else
    {
      v15 = v14;
      v23 = v145;
    }
    v24 = v22;
    v25 = v23;
    v26 = v15;
    if ((unint64_t)v14 >= v144)
    {
LABEL_25:
      v27 = a2;
      if (!v25)
        goto LABEL_117;
      goto LABEL_26;
    }
    while (1)
    {
      v26 = v14 + 1;
      v40 = ((_DWORD)v14 + 1 - v7 - v10);
      if (v40 >= v8)
        v41 = (_DWORD *)(v7 + v40);
      else
        v41 = (_DWORD *)(v141 + v40 - v142);
      if ((v8 + ~(_DWORD)v40) < 3 || *v41 != *(_DWORD *)v26)
        goto LABEL_92;
      if (v40 >= v8)
        v42 = (char *)v6;
      else
        v42 = (char *)v139;
      v43 = v14 + 5;
      v44 = v41 + 1;
      v45 = (unint64_t)&v14[v42 - (char *)(v41 + 1) + 5];
      if (v45 >= v6)
        v45 = v6;
      if (v45 - 7 <= (unint64_t)v43)
      {
        v50 = v14 + 5;
        v51 = v41 + 1;
        v48 = v8 + v7 + 8;
        v47 = v6 - 7;
        if ((unint64_t)v43 < v45 - 3)
        {
LABEL_55:
          if (*v51 == *(_DWORD *)v50)
          {
            v50 += 4;
            ++v51;
          }
        }
      }
      else
      {
        v46 = *(_QWORD *)v43 ^ *v44;
        v48 = v8 + v7 + 8;
        v47 = v6 - 7;
        if (v46)
        {
          v49 = __clz(__rbit64(v46)) >> 3;
          if ((char *)v44 + v49 != v42)
            goto LABEL_87;
          goto LABEL_66;
        }
        v55 = v14 + 13;
        while (1)
        {
          v56 = &v55[v46];
          if ((unint64_t)&v55[v46] >= v45 - 7)
            break;
          v57 = *(_QWORD *)((char *)v41 + v46 + 12);
          v46 += 8;
          v58 = *(_QWORD *)v56 ^ v57;
          if (v58)
          {
            v49 = v46 + (__clz(__rbit64(v58)) >> 3);
            if ((char *)v44 + v49 != v42)
              goto LABEL_87;
            goto LABEL_66;
          }
        }
        v50 = &v14[v46 + 13];
        v51 = (_DWORD *)((char *)v41 + v46 + 12);
        if ((unint64_t)v50 < v45 - 3)
          goto LABEL_55;
      }
      if ((unint64_t)v50 >= v45 - 1)
      {
        if ((unint64_t)v50 >= v45)
          goto LABEL_65;
LABEL_63:
        if (*(unsigned __int8 *)v51 == *v50)
          ++v50;
        goto LABEL_65;
      }
      if (*(unsigned __int16 *)v51 == *(unsigned __int16 *)v50)
      {
        v50 += 2;
        v51 = (_DWORD *)((char *)v51 + 2);
      }
      if ((unint64_t)v50 < v45)
        goto LABEL_63;
LABEL_65:
      v49 = v50 - v43;
      if ((char *)v44 + v50 - v43 != v42)
        goto LABEL_87;
LABEL_66:
      v52 = &v43[v49];
      if (v47 <= (unint64_t)v52)
      {
        v59 = v52;
        v60 = (_DWORD *)(v7 + v8);
        if ((unint64_t)v52 >= v137)
          goto LABEL_77;
        goto LABEL_75;
      }
      v53 = *(_QWORD *)v52 ^ *v140;
      if (!v53)
      {
        v68 = 0;
        v69 = (uint64_t)&v14[v49 + 13];
        while (1)
        {
          v70 = (_QWORD *)(v69 + v68);
          if (v69 + v68 >= v47)
            break;
          v71 = *(_QWORD *)(v48 + v68);
          v68 += 8;
          v72 = *v70 ^ v71;
          if (v72)
          {
            v54 = v68 + (__clz(__rbit64(v72)) >> 3);
            goto LABEL_86;
          }
        }
        v59 = &v14[v49 + 13 + v68];
        v60 = (_DWORD *)(v48 + v68);
        if ((unint64_t)v59 >= v137)
        {
LABEL_77:
          if ((unint64_t)v59 >= v136)
          {
            if ((unint64_t)v59 >= v6)
            {
LABEL_85:
              v54 = v59 - v52;
              goto LABEL_86;
            }
          }
          else
          {
            if (*(unsigned __int16 *)v60 == *(unsigned __int16 *)v59)
            {
              v59 += 2;
              v60 = (_DWORD *)((char *)v60 + 2);
            }
            if ((unint64_t)v59 >= v6)
              goto LABEL_85;
          }
          if (*(unsigned __int8 *)v60 == *v59)
            ++v59;
          goto LABEL_85;
        }
LABEL_75:
        if (*v60 == *(_DWORD *)v59)
        {
          v59 += 4;
          ++v60;
        }
        goto LABEL_77;
      }
      v54 = __clz(__rbit64(v53)) >> 3;
LABEL_86:
      v49 += v54;
LABEL_87:
      v61 = v49 + 4;
      v63 = (v49 != -5) & __CFADD__(v49, 5);
      v62 = 3 * v22 + (__clz(v23 + 1) ^ 0xFFFFFFE0) + 2;
      if (v63)
        v63 = 1;
      else
        v63 = 3 * (int)v61 <= v62;
      if (!v63)
      {
        v23 = 0;
        v22 = v61;
        v15 = v14 + 1;
      }
LABEL_92:
      v145 = 999999999;
      v24 = ZSTD_HcFindBestMatch_dedicatedDictSearch_selectMLS(a1, v14 + 1, v6, &v145);
      if (v24 < 4
        || (v25 = v145,
            (int)((__clz(v145 + 1) ^ 0xFFFFFFE0) + 4 * v24 + 1) <= (int)((__clz(v23 + 1) ^ 0xFFFFFFE0) + 4 * v22 + 5)))
      {
        if ((unint64_t)v26 >= v144)
          break;
        v26 = v14 + 2;
        v64 = ((_DWORD)v14 + 2 - v7 - v10);
        v65 = v141 + v64 - v142;
        if (v64 >= v8)
          v65 = v7 + v64;
        if ((v8 + ~(_DWORD)v64) >= 3 && *(_DWORD *)v65 == *(_DWORD *)v26)
        {
          v66 = (char *)(v64 >= v8 ? v6 : v139);
          v67 = ZSTD_count_2segments(v14 + 6, (char *)(v65 + 4), v6, v66, v140);
          if (v67 <= 0xFFFFFFFFFFFFFFFBLL && (int)((__clz(v23 + 1) ^ 0xFFFFFFE0) + 4 * v22 + 2) < 4 * ((int)v67 + 4))
          {
            v23 = 0;
            v22 = v67 + 4;
            v15 = v14 + 2;
          }
        }
        v145 = 999999999;
        v24 = ZSTD_HcFindBestMatch_dedicatedDictSearch_selectMLS(a1, v14 + 2, v6, &v145);
        if (v24 < 4)
          break;
        v25 = v145;
        if ((int)((__clz(v145 + 1) ^ 0xFFFFFFE0) + 4 * v24 + 1) <= (int)((__clz(v23 + 1) ^ 0xFFFFFFE0) + 4 * v22 + 8))
          break;
      }
      v14 = v26;
      v15 = v26;
      v23 = v25;
      v22 = v24;
      if ((unint64_t)v26 >= v144)
        goto LABEL_25;
    }
    v24 = v22;
    LODWORD(v25) = v23;
    v26 = v15;
    v27 = a2;
    if (!v23)
    {
LABEL_117:
      v12 = (char *)v139;
      v35 = v8 + v7 + 8;
      v34 = v6 - 7;
      v36 = v6 - 32;
      v29 = v134;
      v9 = v138;
      v38 = v26 - v5;
      v39 = *(_OWORD **)(v27 + 24);
      if ((unint64_t)v26 <= v133)
        goto LABEL_118;
LABEL_127:
      v74 = v9;
      if ((unint64_t)v5 <= v36)
      {
        v82 = (char *)v39 + v36 - (_QWORD)v5;
        v83 = (__int128 *)v5;
        v84 = v39;
        do
        {
          v85 = *v83++;
          *v84++ = v85;
        }
        while (v84 < (_OWORD *)v82);
        v81 = (_OWORD *)v36;
        if (v36 < (unint64_t)v26)
          goto LABEL_133;
      }
      else
      {
        v81 = v5;
        v82 = v39;
        if (v5 >= v26)
          goto LABEL_152;
LABEL_133:
        if ((unint64_t)v5 <= v36)
          v86 = (char *)v36;
        else
          v86 = v5;
        v87 = v26 - v86;
        if ((unint64_t)(v26 - v86) < 8)
        {
          v88 = (char *)v81;
          goto LABEL_151;
        }
        if ((unint64_t)((char *)v39 - v5) < 0x20)
        {
          v88 = (char *)v81;
          goto LABEL_151;
        }
        if (v87 >= 0x20)
        {
          v89 = v87 & 0xFFFFFFFFFFFFFFE0;
          v90 = v81 + 1;
          v91 = (_OWORD *)((char *)v39 + v86 - v5 + 16);
          v92 = v87 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            v93 = *v90;
            *(v91 - 1) = *(v90 - 1);
            *v91 = v93;
            v90 += 2;
            v91 += 2;
            v92 -= 32;
          }
          while (v92);
          if (v87 != v89)
          {
            if ((v87 & 0x18) == 0)
            {
              v88 = (char *)v81 + v89;
              v82 += v89;
              goto LABEL_151;
            }
            goto LABEL_146;
          }
        }
        else
        {
          v89 = 0;
LABEL_146:
          v82 += v87 & 0xFFFFFFFFFFFFFFF8;
          v88 = (char *)v81 + (v87 & 0xFFFFFFFFFFFFFFF8);
          v94 = (uint64_t *)((char *)v81 + v89);
          v95 = (_QWORD *)((char *)v39 + &v86[v89] - v5);
          v96 = v89 - (v87 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            v97 = *v94++;
            *v95++ = v97;
            v96 += 8;
          }
          while (v96);
          if (v87 != (v87 & 0xFFFFFFFFFFFFFFF8))
          {
            do
            {
LABEL_151:
              v98 = *v88++;
              *v82++ = v98;
            }
            while (v88 < v26);
          }
        }
      }
LABEL_152:
      *(_QWORD *)(v27 + 24) += v38;
      v79 = *(_QWORD *)(v27 + 8);
      if (v38 >= 0x10000)
      {
        v99 = (unint64_t)(v79 - *(_QWORD *)v27) >> 3;
        *(_DWORD *)(v27 + 72) = 1;
        *(_DWORD *)(v27 + 76) = v99;
      }
      v9 = v74;
      v80 = v24 - 3;
      *(_WORD *)(v79 + 4) = v38;
      *(_DWORD *)v79 = v25 + 1;
      if (v24 - 3 >= 0x10000)
        goto LABEL_155;
      goto LABEL_156;
    }
LABEL_26:
    v28 = v7 + v8;
    if (v8 > (int)v26 - ((int)v25 + (int)v7) + 2)
      v28 = v132;
    v29 = v134;
    if (v8 <= (int)v26 - ((int)v25 + (int)v7) + 2)
      v30 = v7;
    else
      v30 = v134;
    if (v26 > v5)
    {
      v31 = ((_DWORD)v26 - (v25 + v7) + 2);
      if (v30 + v31 > v28)
      {
        v32 = (unsigned __int8 *)(v30 + v31 - 1);
        v33 = (unsigned __int8 *)(v26 - 1);
        v12 = (char *)v139;
        v35 = v8 + v7 + 8;
        v34 = v6 - 7;
        v36 = v6 - 32;
        while (*v33 == *v32)
        {
          ++v24;
          v37 = v33 - 1;
          if (v33 > (unsigned __int8 *)v5)
          {
            --v33;
            v63 = (unint64_t)v32-- > v28;
            if (v63)
              continue;
          }
          v26 = (char *)(v37 + 1);
          v9 = v10;
          v10 = (v25 - 2);
          v38 = v26 - v5;
          v39 = *(_OWORD **)(v27 + 24);
          if ((unint64_t)v26 <= v133)
            goto LABEL_118;
          goto LABEL_127;
        }
        v26 = (char *)(v33 + 1);
        v9 = v10;
        v10 = (v25 - 2);
        v38 = v33 + 1 - (unsigned __int8 *)v5;
        v39 = *(_OWORD **)(v27 + 24);
        if ((unint64_t)v26 <= v133)
          goto LABEL_118;
        goto LABEL_127;
      }
    }
    v12 = (char *)v139;
    v35 = v8 + v7 + 8;
    v34 = v6 - 7;
    v36 = v6 - 32;
    v9 = v10;
    v10 = (v25 - 2);
    v38 = v26 - v5;
    v39 = *(_OWORD **)(v27 + 24);
    if ((unint64_t)v26 > v133)
      goto LABEL_127;
LABEL_118:
    *v39 = *(_OWORD *)v5;
    v73 = *(_QWORD *)(v27 + 24);
    if (v38 > 0x10)
    {
      v74 = v9;
      v75 = (_OWORD *)(v73 + 16);
      v76 = v73 + v38;
      v77 = (__int128 *)(v5 + 16);
      do
      {
        v78 = *v77++;
        *v75++ = v78;
      }
      while ((unint64_t)v75 < v76);
      goto LABEL_152;
    }
    *(_QWORD *)(v27 + 24) = v73 + v38;
    v79 = *(_QWORD *)(v27 + 8);
    v80 = v24 - 3;
    *(_WORD *)(v79 + 4) = v38;
    *(_DWORD *)v79 = v25 + 1;
    if (v24 - 3 >= 0x10000)
    {
LABEL_155:
      v100 = (unint64_t)(v79 - *(_QWORD *)v27) >> 3;
      *(_DWORD *)(v27 + 72) = 2;
      *(_DWORD *)(v27 + 76) = v100;
    }
LABEL_156:
    *(_WORD *)(v79 + 6) = v80;
    v101 = v79 + 8;
    *(_QWORD *)(v27 + 8) = v79 + 8;
    v5 = &v26[v24];
    if ((unint64_t)&v26[v24] > v144)
    {
      v14 = &v26[v24];
      v13 = v141;
      goto LABEL_7;
    }
    v102 = v10;
    v103 = v9;
    v13 = v141;
    while (2)
    {
      v10 = v103;
      v103 = v102;
      v104 = ((_DWORD)v5 - v7 - v10);
      if (v104 >= v8)
        v105 = v7;
      else
        v105 = v29;
      if ((v8 + ~(_DWORD)v104) >= 3)
      {
        v106 = v105 + v104;
        if (*(_DWORD *)(v105 + v104) == *(_DWORD *)v5)
        {
          if (v104 >= v8)
            v107 = (_QWORD *)v6;
          else
            v107 = v12;
          v108 = v5 + 4;
          v109 = (_QWORD *)(v106 + 4);
          v110 = (char *)v107 + (_QWORD)v5 - v106;
          if ((unint64_t)v110 >= v6)
            v110 = (char *)v6;
          if (v110 - 7 <= v108)
          {
            v114 = v5 + 4;
            v115 = v109;
            if (v108 < v110 - 3)
            {
LABEL_177:
              if (*v115 == *(_DWORD *)v114)
              {
                v114 += 4;
                ++v115;
              }
            }
          }
          else
          {
            v111 = *(_QWORD *)v108 ^ *v109;
            if (v111)
            {
              v112 = __clz(__rbit64(v111)) >> 3;
              if ((_QWORD *)((char *)v109 + v112) != v107)
                goto LABEL_173;
LABEL_188:
              v116 = &v108[v112];
              if (v34 <= (unint64_t)v116)
              {
                v122 = v116;
                v123 = (_DWORD *)(v7 + v8);
                if ((unint64_t)v116 < v137)
                {
LABEL_198:
                  if (*v123 == *(_DWORD *)v122)
                  {
                    v122 += 4;
                    ++v123;
                  }
                }
              }
              else
              {
                v117 = *(_QWORD *)v116 ^ *v140;
                if (v117)
                {
                  v112 += __clz(__rbit64(v117)) >> 3;
                  if ((unint64_t)v5 > v36)
                    goto LABEL_174;
LABEL_209:
                  *(_OWORD *)*(_QWORD *)(v27 + 24) = *(_OWORD *)v5;
                  v101 = *(_QWORD *)(v27 + 8);
                  v113 = v112 + 1;
                  *(_WORD *)(v101 + 4) = 0;
                  *(_DWORD *)v101 = 1;
                  if (v112 + 1 >= 0x10000)
                  {
LABEL_210:
                    v124 = (unint64_t)(v101 - *(_QWORD *)v27) >> 3;
                    *(_DWORD *)(v27 + 72) = 2;
                    *(_DWORD *)(v27 + 76) = v124;
                  }
LABEL_159:
                  *(_WORD *)(v101 + 6) = v113;
                  v101 += 8;
                  v5 += v112 + 4;
                  *(_QWORD *)(v27 + 8) = v101;
                  v102 = v10;
                  LODWORD(v9) = v103;
                  v14 = v5;
                  if ((unint64_t)v5 > v144)
                    goto LABEL_7;
                  continue;
                }
                v125 = 0;
                v126 = (uint64_t)&v5[v112 + 12];
                while (1)
                {
                  v127 = (_QWORD *)(v126 + v125);
                  if (v126 + v125 >= v34)
                    break;
                  v128 = *(_QWORD *)(v35 + v125);
                  v125 += 8;
                  v129 = *v127 ^ v128;
                  if (v129)
                  {
                    v112 += v125 + (__clz(__rbit64(v129)) >> 3);
                    if ((unint64_t)v5 <= v36)
                      goto LABEL_209;
                    goto LABEL_174;
                  }
                }
                v122 = &v5[v112 + 12 + v125];
                v123 = (_DWORD *)(v35 + v125);
                if ((unint64_t)v122 < v137)
                  goto LABEL_198;
              }
              if ((unint64_t)v122 >= v136)
              {
                if ((unint64_t)v122 >= v6)
                  goto LABEL_208;
              }
              else
              {
                if (*(unsigned __int16 *)v123 == *(unsigned __int16 *)v122)
                {
                  v122 += 2;
                  v123 = (_DWORD *)((char *)v123 + 2);
                }
                if ((unint64_t)v122 >= v6)
                {
LABEL_208:
                  v112 += v122 - v116;
                  if ((unint64_t)v5 > v36)
                    goto LABEL_174;
                  goto LABEL_209;
                }
              }
              if (*(unsigned __int8 *)v123 == *v122)
                ++v122;
              goto LABEL_208;
            }
            v118 = v5 + 12;
            while (1)
            {
              v119 = &v118[v111];
              if (&v118[v111] >= v110 - 7)
                break;
              v120 = *(_QWORD *)(v105 + v104 + 12 + v111);
              v111 += 8;
              v121 = *(_QWORD *)v119 ^ v120;
              if (v121)
              {
                v112 = v111 + (__clz(__rbit64(v121)) >> 3);
                if ((_QWORD *)((char *)v109 + v112) != v107)
                  goto LABEL_173;
                goto LABEL_188;
              }
            }
            v114 = &v5[v111 + 12];
            v115 = (_DWORD *)(v105 + v104 + v111 + 12);
            if (v114 < v110 - 3)
              goto LABEL_177;
          }
          if (v114 >= v110 - 1)
          {
            if (v114 >= v110)
              goto LABEL_187;
          }
          else
          {
            if (*(unsigned __int16 *)v115 == *(unsigned __int16 *)v114)
            {
              v114 += 2;
              v115 = (_DWORD *)((char *)v115 + 2);
            }
            if (v114 >= v110)
            {
LABEL_187:
              v112 = v114 - v108;
              if ((_QWORD *)((char *)v109 + v114 - v108) == v107)
                goto LABEL_188;
LABEL_173:
              if ((unint64_t)v5 <= v36)
                goto LABEL_209;
LABEL_174:
              v113 = v112 + 1;
              *(_WORD *)(v101 + 4) = 0;
              *(_DWORD *)v101 = 1;
              if (v112 + 1 >= 0x10000)
                goto LABEL_210;
              goto LABEL_159;
            }
          }
          if (*(unsigned __int8 *)v115 == *v114)
            ++v114;
          goto LABEL_187;
        }
      }
      break;
    }
    LODWORD(v9) = v10;
    v10 = v102;
    v14 = v5;
LABEL_7:
    if ((unint64_t)v14 < v144)
      continue;
    break;
  }
  a3 = v131;
LABEL_222:
  *a3 = v10;
  a3[1] = v9;
  return v6 - (_QWORD)v5;
}

uint64_t ZSTD_resetSeqStore(uint64_t result)
{
  *(_QWORD *)(result + 24) = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 8) = *(_QWORD *)result;
  *(_DWORD *)(result + 72) = 0;
  return result;
}

uint64_t ZSTD_generateSequences(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v17[3];
  uint64_t v18[3];

  v10 = a5 + (a5 >> 8);
  v11 = (0x20000 - a5) >> 11;
  if (a5 >= 0x20000)
    v11 = 0;
  v12 = v10 + v11;
  v13 = malloc_type_malloc(v10 + v11, 0x26AA08A0uLL);
  if (!v13)
    return -64;
  v14 = v13;
  *(_QWORD *)(a1 + 592) = 1;
  *(_QWORD *)(a1 + 600) = a2;
  *(_QWORD *)(a1 + 608) = 0;
  *(_QWORD *)(a1 + 616) = a3;
  *(_DWORD *)(a1 + 3208) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  v18[0] = (uint64_t)v13;
  v18[1] = v12;
  v18[2] = 0;
  v17[0] = a4;
  v17[1] = a5;
  v17[2] = 0;
  v15 = *(_QWORD *)(a1 + 140);
  *(_QWORD *)(a1 + 140) = 0x100000001;
  ZSTD_compressStream2(a1, v18, v17, 2u);
  *(_QWORD *)(a1 + 140) = v15;
  free(v14);
  return *(_QWORD *)(a1 + 608);
}

void ZSTD_compress2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7[3];
  uint64_t v8[3];

  *(_DWORD *)(a1 + 3208) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  v8[0] = a2;
  v8[1] = a3;
  v8[2] = 0;
  v7[0] = a4;
  v7[1] = a5;
  v7[2] = 0;
  v6 = *(_QWORD *)(a1 + 140);
  *(_QWORD *)(a1 + 140) = 0x100000001;
  ZSTD_compressStream2(a1, v8, v7, 2u);
  *(_QWORD *)(a1 + 140) = v6;
}

uint64_t ZSTD_mergeBlockDelimiters(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;

  if (!a2)
    return 0;
  result = 0;
  v4 = a1;
  do
  {
    if (*(_DWORD *)v4 || *(_DWORD *)(v4 + 8))
    {
      *(_OWORD *)(a1 + 16 * result++) = *(_OWORD *)v4;
    }
    else if (a2 != 1)
    {
      *(_DWORD *)(v4 + 20) += *(_DWORD *)(v4 + 4);
    }
    v4 += 16;
    --a2;
  }
  while (a2);
  return result;
}

uint64_t ZSTD_writeSkippableFrame(_DWORD *a1, size_t a2, void *__src, size_t __n, unsigned int a5)
{
  size_t v5;

  v5 = __n + 8;
  if (__n + 8 > a2)
    return -70;
  if (HIDWORD(__n))
    return -72;
  if (a5 > 0xF)
    return -42;
  *a1 = a5 + 407710288;
  a1[1] = __n;
  memcpy(a1 + 2, __src, __n);
  return v5;
}

uint64_t ZSTD_writeLastEmptyBlock(uint64_t a1, unint64_t a2)
{
  if (a2 < 3)
    return -70;
  *(_WORD *)a1 = 1;
  *(_BYTE *)(a1 + 2) = 0;
  return 3;
}

uint64_t ZSTD_referenceExternalSequences(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (*(_DWORD *)a1 != 1)
    return -60;
  if (*(_DWORD *)(a1 + 280))
    return -40;
  result = 0;
  *(_QWORD *)(a1 + 2832) = a2;
  *(_QWORD *)(a1 + 2856) = a3;
  *(_QWORD *)(a1 + 2864) = a3;
  *(_QWORD *)(a1 + 2848) = 0;
  *(_QWORD *)(a1 + 2840) = 0;
  return result;
}

uint64_t ZSTD_compressContinue(int32x2_t *a1, _BYTE *a2, unint64_t a3, char *a4, size_t a5)
{
  return ZSTD_compressContinue_internal(a1, a2, a3, a4, a5, 1, 0);
}

uint64_t ZSTD_compressContinue_internal(int32x2_t *a1, _BYTE *a2, unint64_t a3, char *__src, size_t __n, int a6, int a7)
{
  unint64_t v10;
  _BYTE *v11;
  unint64_t v13;
  int v14;
  unint64_t v15;
  char *v16;
  int32x2_t v17;
  unsigned __int32 v18;
  unsigned __int32 v19;
  unint64_t v20;
  char *v22;
  uint64_t v23;
  char *v24;
  int32x2_t v25;
  char *v26;
  unsigned __int32 v27;
  uint64_t v28;
  unint64_t v29;
  __int32 v30;
  unint64_t v31;
  int32x2_t *v32;
  int v33;
  int v34;
  __int16 v35;
  int v36;
  _BOOL4 v37;
  unsigned __int32 v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unsigned int v42;
  char v43;
  char v44;
  unint64_t v45;
  int32x2_t v46;
  unint64_t v47;
  unint64_t v49;
  size_t v50;
  _BYTE *v51;
  int8x16_t *v52;
  int v53;
  uint32x4_t *v54;

  if (!a1->i32[0])
    return -60;
  v10 = a3;
  v11 = a2;
  v13 = 0;
  if (a6 && a1->i32[0] == 1)
  {
    v14 = a7;
    v15 = ZSTD_writeFrameHeader(a2, a3, &a1[23], *(_QWORD *)&a1[55] - 1, a1[44].u32[0]);
    v13 = v15;
    if (v15 > 0xFFFFFFFFFFFFFF88)
      return v13;
    v10 -= v15;
    v11 += v15;
    a1->i32[0] = 2;
    a7 = v14;
  }
  if (!__n)
    return v13;
  v54 = (uint32x4_t *)&a1[361];
  v16 = (char *)a1[361];
  v53 = a7;
  if (v16 == __src)
  {
    v17 = a1[363];
    v19 = a1[364].u32[1];
    v18 = a1[364].u32[0];
  }
  else
  {
    v17 = a1[362];
    v18 = (_DWORD)v16 - v17.i32[0];
    v19 = a1[364].u32[0];
    a1[364].i32[1] = v19;
    a1[364].i32[0] = (_DWORD)v16 - v17.i32[0];
    a1[363] = v17;
    a1[362] = (int32x2_t)(__src - &v16[-*(_QWORD *)&v17]);
    if ((_DWORD)v16 - v17.i32[0] - v19 <= 7)
    {
      a1[364].i32[1] = v18;
      v19 = (_DWORD)v16 - v17.i32[0];
    }
  }
  v22 = &__src[__n];
  v54->i64[0] = (uint64_t)&__src[__n];
  if ((unint64_t)&__src[__n] > *(_QWORD *)&v17 + (unint64_t)v19
    && *(_QWORD *)&v17 + (unint64_t)v18 > (unint64_t)__src)
  {
    v23 = (uint64_t)&v22[-*(_QWORD *)&v17];
    if (v23 > v18)
      LODWORD(v23) = v18;
    a1[364].i32[1] = v23;
  }
  if (v16 != __src)
    a1[365].i32[1] = v18;
  if (a1[35].i32[0])
  {
    v24 = (char *)a1[89];
    if (v24 == __src)
    {
      v25 = a1[91];
      v27 = a1[92].u32[1];
      LODWORD(v26) = a1[92].i32[0];
    }
    else
    {
      v25 = a1[90];
      v26 = &v24[-*(_QWORD *)&v25];
      v27 = a1[92].u32[0];
      a1[92].i32[1] = v27;
      a1[92].i32[0] = (int)v26;
      a1[91] = v25;
      a1[90] = (int32x2_t)(__src - v26);
      if (v26 - v27 <= 7)
      {
        a1[92].i32[1] = (int)v26;
        v27 = v26;
      }
    }
    a1[89] = (int32x2_t)v22;
    if ((unint64_t)v22 > *(_QWORD *)&v25 + (unint64_t)v27
      && *(_QWORD *)&v25 + (unint64_t)v26 > (unint64_t)__src)
    {
      v28 = (uint64_t)&v22[-*(_QWORD *)&v25];
      if (v28 > v26)
        LODWORD(v28) = (_DWORD)v26;
      a1[92].i32[1] = v28;
    }
  }
  if (!a6)
  {
    ZSTD_overflowCorrectIfNeeded(v54, &a1[46], &a1[23], (int)__src, (int)v22);
    v20 = ZSTD_compressBlock_internal((uint64_t)a1, v11, v10, __src, __n, 0);
    if (v20 <= 0xFFFFFFFFFFFFFF88)
      goto LABEL_79;
    return v20;
  }
  v51 = v11;
  v49 = v13;
  v29 = (unint64_t)a1[54];
  v30 = a1[23].i32[1];
  if (a1[27].i32[1])
    ZSTD_XXH64_update((unsigned int *)&a1[58], __src, __n);
  v52 = (int8x16_t *)&a1[359];
  v31 = (unint64_t)v11;
  v50 = __n;
  v32 = a1 + 23;
  do
  {
    v37 = v29 >= __n;
    if (v10 < 6)
      return -70;
    if (__n < v29)
      v29 = __n;
    ZSTD_overflowCorrectIfNeeded(v54, &a1[46], v32, (int)__src, (_DWORD)__src + v29);
    if (a1[365].i32[0] + (1 << v30) >= ((_DWORD)__src + v29 - a1[362].i32[0]))
    {
      v38 = a1[364].u32[1];
      if (a1[365].i32[1] >= v38)
        goto LABEL_43;
LABEL_53:
      a1[365].i32[1] = v38;
      v34 = v37 & v53;
      if (!*(_QWORD *)&a1[30])
        goto LABEL_54;
LABEL_44:
      v39 = ZSTD_buildSeqStore(a1, (unint64_t)__src, v29);
      v20 = v39;
      if (v39 > 0xFFFFFFFFFFFFFF88)
        return v20;
      if (!v39)
      {
        if (!a1[78].i32[0]
          && *(_QWORD *)&a1[80] - *(_QWORD *)&a1[79] <= 0x1FuLL
          && *(_QWORD *)&a1[82] - *(_QWORD *)&a1[81] <= 9uLL
          && ZSTD_isRLE(__src, v29))
        {
          v44 = *__src;
          *(_WORD *)v31 = v34 | (8 * v29) | 2;
          *(_BYTE *)(v31 + 2) = v29 >> 13;
          *(_BYTE *)(v31 + 3) = v44;
          v20 = 4;
LABEL_50:
          if (*(_DWORD *)(v52->i64[0] + 4568) == 2)
            *(_DWORD *)(v52->i64[0] + 4568) = 1;
          goto LABEL_37;
        }
        v40 = ZSTD_compressSuperBlock((uint64_t)a1, v31, v10, __src, v29, v34);
        if (v40 != -70)
        {
          v20 = v40;
          if (v40 > 0xFFFFFFFFFFFFFF88)
            return v20;
          v42 = a1[26].u32[1];
          v43 = v42 <= 7 ? 6 : v42 - 1;
          if (v40 && v40 < v29 - (v29 >> v43) + 1)
          {
            *v52 = vextq_s8(*v52, *v52, 8uLL);
            goto LABEL_50;
          }
        }
      }
      v20 = v29 + 3;
      if (v29 + 3 > v10)
        return -70;
      *(_WORD *)v31 = v34 | (8 * v29);
      *(_BYTE *)(v31 + 2) = v29 >> 13;
      memcpy((void *)(v31 + 3), __src, v29);
      if (v20 > 0xFFFFFFFFFFFFFF88)
        return v20;
      goto LABEL_50;
    }
    a1[365].i32[0] = 0;
    a1[384] = 0;
    v38 = a1[364].u32[1];
    if (a1[365].i32[1] < v38)
      goto LABEL_53;
LABEL_43:
    v34 = v37 & v53;
    if (a1[30])
      goto LABEL_44;
LABEL_54:
    v41 = ZSTD_compressBlock_internal((uint64_t)a1, (_BYTE *)(v31 + 3), v10 - 3, __src, v29, 1);
    v20 = v41;
    if (v41 > 0xFFFFFFFFFFFFFF88)
      return v20;
    if (v41 == 1)
    {
      v33 = 8 * v29;
      v35 = 2;
      goto LABEL_36;
    }
    if (v41)
    {
      v33 = v34;
      v34 = 8 * v41;
      v35 = 4;
LABEL_36:
      v36 = v34 | v33;
      *(_WORD *)v31 = v36 | v35;
      *(_BYTE *)(v31 + 2) = BYTE2(v36);
      v20 = v41 + 3;
      v32 = a1 + 23;
      goto LABEL_37;
    }
    v20 = v29 + 3;
    if (v29 + 3 > v10)
      return -70;
    *(_WORD *)v31 = v34 | (8 * v29);
    *(_BYTE *)(v31 + 2) = v29 >> 13;
    memcpy((void *)(v31 + 3), __src, v29);
    v32 = a1 + 23;
    if (v20 >= 0xFFFFFFFFFFFFFF89)
      return v20;
LABEL_37:
    v31 += v20;
    v10 -= v20;
    a1[78].i32[0] = 0;
    __src += v29;
    __n -= v29;
  }
  while (__n);
  if (v53 && v31 > (unint64_t)v51)
    a1->i32[0] = 3;
  v20 = v31 - (_QWORD)v51;
  v13 = v49;
  __n = v50;
  if (v20 <= 0xFFFFFFFFFFFFFF88)
  {
LABEL_79:
    v45 = (unint64_t)a1[55];
    v46 = (int32x2_t)(*(_QWORD *)&a1[56] + __n);
    v47 = *(_QWORD *)&a1[57] + v20 + v13;
    a1[56] = v46;
    a1[57] = (int32x2_t)v47;
    if (*(_QWORD *)&v46 + 1 <= v45 || v45 == 0)
      v20 += v13;
    else
      return -72;
  }
  return v20;
}

uint64_t ZSTD_getBlockSize(uint64_t a1)
{
  unsigned int v1;

  v1 = 1 << *(_DWORD *)(a1 + 188);
  if (v1 >= 0x20000)
    return 0x20000;
  else
    return v1;
}

uint64_t ZSTD_compressBlock(int32x2_t *a1, _BYTE *a2, unint64_t a3, char *a4, size_t a5)
{
  unint64_t v5;

  LODWORD(v5) = 1 << a1[23].i32[1];
  if (v5 >= 0x20000)
    v5 = 0x20000;
  else
    v5 = v5;
  if (v5 >= a5)
    return ZSTD_compressContinue_internal(a1, a2, a3, a4, a5, 0, 0);
  else
    return -72;
}

uint64_t ZSTD_loadCEntropy(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _DWORD *v15;
  unint64_t v16;
  unint64_t v17;
  unsigned int v18;
  int v19;
  _DWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unsigned int v23;
  int v24;
  unsigned int *v25;
  unint64_t v26;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  unsigned __int16 *v35;
  uint64_t v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  int16x8_t v41;
  int16x8_t v42;
  int16x8_t v43;
  int16x8_t v44;
  int16x8_t v45;
  int16x8_t v46;
  int16x4_t v47;
  __int16 v48;
  __int16 v49[32];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v8 = a3 + 8;
  *(_DWORD *)(a1 + 1024) = 1;
  v40 = 31;
  v41.i32[0] = 255;
  *(_DWORD *)v49 = 1;
  v9 = HUF_readCTable(a1, &v41, (char *)(a3 + 8), a4 - 8, v49);
  if (!*(_DWORD *)v49)
    *(_DWORD *)(a1 + 1024) = 2;
  if (v9 < 0xFFFFFFFFFFFFFF89 && v41.i32[0] > 0xFEu)
    v10 = v9;
  else
    v10 = 0;
  if (v9 >= 0xFFFFFFFFFFFFFF89 || v41.i32[0] <= 0xFEu)
    return -30;
  v11 = a3 + a4;
  v12 = v8 + v10;
  v41.i32[0] = 0;
  v13 = FSE_readNCount_bmi2(v49, &v40, &v41, (_DWORD *)(v8 + v10), v11 - (v8 + v10));
  if (v13 > 0xFFFFFFFFFFFFFF88)
    return -30;
  if (v41.i32[0] >= 9u)
    return -30;
  v14 = v13;
  if ((unint64_t)FSE_buildCTable_wksp((_WORD *)(a1 + 1028), v49, 31, v41.i32[0], a2, 0x1900uLL) > 0xFFFFFFFFFFFFFF88)
    return -30;
  v15 = (_DWORD *)(v12 + v14);
  v38 = 0;
  v39 = 52;
  v16 = FSE_readNCount_bmi2(&v41, &v39, &v38, v15, v11 - (_QWORD)v15);
  if (v16 > 0xFFFFFFFFFFFFFF88)
    return -30;
  if (v38 > 9)
    return -30;
  v17 = v16;
  v18 = v39;
  if ((unint64_t)FSE_buildCTable_wksp((_WORD *)(a1 + 1800), v41.i16, v39, v38, a2, 0x1900uLL) > 0xFFFFFFFFFFFFFF88)
    return -30;
  v19 = (v18 < 0x34) | vmaxv_u16((uint16x4_t)vceqz_s16(v47)) & 1 | (v48 == 0) | (vmaxvq_u8((uint8x16_t)vorrq_s8(vuzp1q_s8((int8x16_t)vceqzq_s16(v41), (int8x16_t)vceqzq_s16(v42)), vuzp1q_s8((int8x16_t)vceqzq_s16(v43), (int8x16_t)vceqzq_s16(v44)))) | vmaxvq_u8((uint8x16_t)vuzp1q_s8((int8x16_t)vceqzq_s16(v45), (int8x16_t)vceqzq_s16(v46)))) & 1
      ? 1
      : 2;
  *(_DWORD *)(a1 + 4572) = v19;
  v20 = (_DWORD *)((char *)v15 + v17);
  v38 = 0;
  v39 = 35;
  v21 = FSE_readNCount_bmi2(&v41, &v39, &v38, v20, v11 - (_QWORD)v20);
  if (v21 >= 0xFFFFFFFFFFFFFF89)
    return -30;
  if (v38 > 9)
    return -30;
  v22 = v21;
  v23 = v39;
  if ((unint64_t)FSE_buildCTable_wksp((_WORD *)(a1 + 3252), v41.i16, v39, v38, a2, 0x1900uLL) > 0xFFFFFFFFFFFFFF88)
    return -30;
  v24 = (vmaxvq_u8((uint8x16_t)vorrq_s8(vuzp1q_s8((int8x16_t)vceqzq_s16(v41), (int8x16_t)vceqzq_s16(v42)), vuzp1q_s8((int8x16_t)vceqzq_s16(v43), (int8x16_t)vceqzq_s16(v44)))) | vmaxv_u16((uint16x4_t)vceqz_s16(*(int16x4_t *)v45.i8))) & 1 | (v23 < 0x23)? 1: 2;
  *(_DWORD *)(a1 + 4576) = v24;
  v25 = (_DWORD *)((char *)v20 + v22);
  v26 = (unint64_t)v20 + v22 + 12;
  if (v26 > v11)
    return -30;
  v28 = *v25;
  *(_DWORD *)(a1 + 4580) = v28;
  v29 = v25[1];
  *(_DWORD *)(a1 + 4584) = v29;
  v30 = v25[2];
  *(_DWORD *)(a1 + 4588) = v30;
  v31 = v11 - v26;
  v32 = __clz(v11 - v26 + 0x20000) ^ 0x1F;
  if (v11 - v26 >= 0xFFFE0000)
    v32 = 31;
  if (v40 >= v32)
  {
    v34 = v32 + 1;
    v35 = (unsigned __int16 *)v49;
    while (*v35++)
    {
      if (!--v34)
      {
        v33 = 2;
        goto LABEL_32;
      }
    }
  }
  v33 = 1;
LABEL_32:
  *(_DWORD *)(a1 + 4568) = v33;
  v37 = v26 - a3;
  if (v31 < v30)
    v37 = -30;
  if (!(_DWORD)v30)
    v37 = -30;
  if (v31 < v29)
    v37 = -30;
  if (!(_DWORD)v29)
    v37 = -30;
  if (v31 < v28)
    v37 = -30;
  if ((_DWORD)v28)
    return v37;
  else
    return -30;
}

unint64_t ZSTD_compressBegin_advanced_internal(uint64_t a1, _DWORD *a2, unint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, unint64_t a8)
{
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)xmmword_18823D760, (uint32x4_t)vaddq_s32(*(int32x4_t *)(a7 + 4), (int32x4_t)xmmword_18823D750)))) & 1) != 0|| (*(_DWORD *)(a7 + 20) - 8) < 0xFFFFFFFB|| *(_DWORD *)(a7 + 24) > 0x20000u|| (*(_DWORD *)(a7 + 28) - 1) > 8)
  {
    return -42;
  }
  else
  {
    return ZSTD_compressBegin_internal(a1, a2, a3, a4, a5, a6, (uint64_t *)a7, a8, 0);
  }
}

unint64_t ZSTD_compressBegin_internal(uint64_t a1, _DWORD *a2, unint64_t a3, int a4, int a5, uint64_t a6, uint64_t *a7, unint64_t a8, int a9)
{
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t result;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  _DWORD *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;
  unsigned int v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _OWORD *v50;
  size_t v51;
  int v52;
  size_t v53;
  unint64_t v54;
  __int128 v55;
  _BYTE v56[168];
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  if (a6)
  {
    v15 = *(_QWORD *)(a6 + 8);
    if (v15)
    {
      if (a8 < 0x20000 || a8 == -1 || 6 * v15 > a8 || !*(_DWORD *)(a6 + 4948))
      {
        v16 = *((_DWORD *)a7 + 17);
        if (v16 != 3)
        {
          v17 = *(_DWORD *)(a6 + 168);
          v18 = *(unsigned int *)(a6 + 312);
          if (v17)
            goto LABEL_6;
          if (a8 == -1 || attachDictSizeCutoffs[v18] >= a8)
          {
            if (v16 == 2)
              goto LABEL_46;
          }
          else if (v16 != 1)
          {
            goto LABEL_46;
          }
          if (!*((_DWORD *)a7 + 12))
          {
LABEL_6:
            v20 = *a7;
            v19 = a7 + 4;
            v21 = v20;
            v22 = *(_DWORD *)(a6 + 288);
            v23 = *(_DWORD *)(a6 + 292);
            if ((v18 - 3) >= 3 || v17 == 0)
              v25 = *(_DWORD *)(a6 + 296);
            else
              v25 = *(_DWORD *)(a6 + 296) - 2;
            if (a8 >> 30)
            {
              if (a8 == -1)
              {
LABEL_39:
                *(_QWORD *)v56 = v21;
                *(_DWORD *)&v56[8] = v23;
                *(_DWORD *)&v56[12] = v25;
                *(_QWORD *)&v56[16] = *(_QWORD *)(a6 + 300);
                *(_DWORD *)&v56[24] = *(_DWORD *)(a6 + 308);
                *(_DWORD *)&v56[28] = v18;
                v39 = *((_OWORD *)v19 + 7);
                *(_OWORD *)&v56[128] = *((_OWORD *)v19 + 6);
                *(_OWORD *)&v56[144] = v39;
                *(_QWORD *)&v56[160] = v19[16];
                v40 = *((_OWORD *)v19 + 3);
                *(_OWORD *)&v56[64] = *((_OWORD *)v19 + 2);
                *(_OWORD *)&v56[80] = v40;
                v41 = *((_OWORD *)v19 + 5);
                *(_OWORD *)&v56[96] = *((_OWORD *)v19 + 4);
                *(_OWORD *)&v56[112] = v41;
                v42 = *((_OWORD *)v19 + 1);
                *(_OWORD *)&v56[32] = *(_OWORD *)v19;
                *(_OWORD *)&v56[48] = v42;
                result = ZSTD_resetCCtx_internal(a1, (__int128 *)v56, a8, 0, a9);
                if (result > 0xFFFFFFFFFFFFFF88)
                  return result;
                v43 = *(_QWORD *)(a6 + 96) - *(_QWORD *)(a6 + 104);
                if (*(_DWORD *)(a6 + 120) != (_DWORD)v43)
                {
                  *(_QWORD *)(a1 + 3072) = a6 + 96;
                  v44 = *(_DWORD *)(a1 + 2912);
                  if (v44 < v43)
                  {
                    *(_QWORD *)(a1 + 2888) = *(_QWORD *)(a1 + 2896) + v43;
                    *(_DWORD *)(a1 + 2916) = v43;
                    *(_DWORD *)(a1 + 2912) = v43;
                    v44 = v43;
                  }
                  *(_DWORD *)(a1 + 2920) = v44;
                }
LABEL_56:
                *(_DWORD *)(a1 + 352) = *(_DWORD *)(a6 + 4944);
                *(_QWORD *)(a1 + 360) = *(_QWORD *)(a6 + 8);
                memcpy(*(void **)(a1 + 2872), (const void *)(a6 + 328), 0x11F0uLL);
                return 0;
              }
            }
            else
            {
              v26 = __clz(a8 - 1) ^ 0x1F;
              if (a8 >= 0x40)
                v27 = v26 + 1;
              else
                v27 = 6;
              if (v22 >= v27)
                v22 = v27;
            }
            if (v25 >= v22 + 1)
              v25 = v22 + 1;
            if (v23 - (v18 > 5) > v22)
            {
              if (v18 <= 5)
                v23 = v22;
              else
                v23 = v22 + 1;
            }
            goto LABEL_39;
          }
LABEL_46:
          v45 = *(_OWORD *)(a7 + 15);
          v63 = *(_OWORD *)(a7 + 13);
          v64 = v45;
          v46 = *(_OWORD *)(a7 + 19);
          v65 = *(_OWORD *)(a7 + 17);
          v66 = v46;
          v47 = *(_OWORD *)(a7 + 7);
          v59 = *(_OWORD *)(a7 + 5);
          v60 = v47;
          v48 = *(_OWORD *)(a7 + 11);
          v61 = *(_OWORD *)(a7 + 9);
          v62 = v48;
          v49 = *(_OWORD *)(a7 + 3);
          v57 = *(_OWORD *)(a7 + 1);
          v58 = v49;
          v50 = (_OWORD *)(a6 + 96);
          *(_QWORD *)&v47 = *a7;
          *(_QWORD *)&v58 = *(_QWORD *)(a6 + 308);
          v57 = *(_OWORD *)(a6 + 292);
          *(_QWORD *)v56 = v47;
          *(_OWORD *)&v56[104] = v63;
          *(_OWORD *)&v56[120] = v45;
          *(_OWORD *)&v56[136] = v65;
          *(_OWORD *)&v56[152] = v66;
          *(_OWORD *)&v56[40] = v59;
          *(_OWORD *)&v56[56] = v60;
          *(_OWORD *)&v56[72] = v61;
          *(_OWORD *)&v56[88] = v62;
          *(_OWORD *)&v56[8] = v57;
          *(_OWORD *)&v56[24] = v58;
          result = ZSTD_resetCCtx_internal(a1, (__int128 *)v56, a8, 1, a9);
          if (result > 0xFFFFFFFFFFFFFF88)
            return result;
          *(_QWORD *)(a1 + 400) = *(_QWORD *)(a1 + 384);
          if (*(_DWORD *)(a6 + 312) == 1)
            v51 = 0;
          else
            v51 = 4 << *(_DWORD *)(a6 + 292);
          memcpy(*(void **)(a1 + 2936), *(const void **)(a6 + 144), 4 << *(_DWORD *)(a6 + 296));
          memcpy(*(void **)(a1 + 2952), *(const void **)(a6 + 160), v51);
          v52 = *(_DWORD *)(a1 + 2928);
          if (v52)
            v53 = 4 << v52;
          else
            v53 = 0;
          bzero(*(void **)(a1 + 2944), v53);
          v54 = *(_QWORD *)(a1 + 392);
          if (*(_QWORD *)(a1 + 400) < v54)
            *(_QWORD *)(a1 + 400) = v54;
          v55 = *(_OWORD *)(a6 + 112);
          *(_OWORD *)(a1 + 2888) = *v50;
          *(_OWORD *)(a1 + 2904) = v55;
          *(_QWORD *)(a1 + 2920) = *(_QWORD *)(a6 + 128);
          goto LABEL_56;
        }
      }
    }
  }
  v28 = *((_OWORD *)a7 + 9);
  *(_OWORD *)&v56[128] = *((_OWORD *)a7 + 8);
  *(_OWORD *)&v56[144] = v28;
  *(_QWORD *)&v56[160] = a7[20];
  v29 = *((_OWORD *)a7 + 5);
  *(_OWORD *)&v56[64] = *((_OWORD *)a7 + 4);
  *(_OWORD *)&v56[80] = v29;
  v30 = *((_OWORD *)a7 + 7);
  *(_OWORD *)&v56[96] = *((_OWORD *)a7 + 6);
  *(_OWORD *)&v56[112] = v30;
  v31 = *((_OWORD *)a7 + 1);
  *(_OWORD *)v56 = *(_OWORD *)a7;
  *(_OWORD *)&v56[16] = v31;
  v32 = *((_OWORD *)a7 + 3);
  *(_OWORD *)&v56[32] = *((_OWORD *)a7 + 2);
  *(_OWORD *)&v56[48] = v32;
  result = ZSTD_resetCCtx_internal(a1, (__int128 *)v56, a8, 0, a9);
  if (result > 0xFFFFFFFFFFFFFF88)
    return result;
  v34 = *(_QWORD *)(a1 + 2872);
  v35 = a1 + 2888;
  v36 = a1 + 712;
  v37 = (_QWORD *)(a1 + 368);
  v38 = (_DWORD *)(a1 + 184);
  if (a6)
  {
    result = ZSTD_compress_insertDictionary(v34, v35, v36, v37, v38, *(_DWORD **)a6, *(_QWORD *)(a6 + 8), *(_DWORD *)(a6 + 16), a5, *(_DWORD **)(a1 + 3120));
    if (result > 0xFFFFFFFFFFFFFF88)
      return result;
    *(_DWORD *)(a1 + 352) = result;
    a3 = *(_QWORD *)(a6 + 8);
  }
  else
  {
    result = ZSTD_compress_insertDictionary(v34, v35, v36, v37, v38, a2, a3, a4, a5, *(_DWORD **)(a1 + 3120));
    if (result > 0xFFFFFFFFFFFFFF88)
      return result;
    *(_DWORD *)(a1 + 352) = result;
  }
  result = 0;
  *(_QWORD *)(a1 + 360) = a3;
  return result;
}

unint64_t ZSTD_compressBegin_advanced(uint64_t a1, _DWORD *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  int32x4_t v6;
  unint64_t result;
  int v8;
  unsigned int v9;
  int v10;
  int v14;
  uint64_t v15;
  _DWORD *v16;
  int v17;
  int32x4_t v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  int v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[28];

  v6 = *(int32x4_t *)a4;
  result = -42;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)vaddq_s32(*(int32x4_t *)a4, (int32x4_t)xmmword_18823D770), (uint32x4_t)xmmword_18823D780))) & 1) == 0)
  {
    v8 = *(_DWORD *)(a4 + 16);
    if ((v8 - 3) <= 4)
    {
      v9 = *(_DWORD *)(a4 + 20);
      v10 = *(_DWORD *)(a4 + 24);
      if (v9 <= 0x20000 && (v10 - 1) <= 8)
      {
        v17 = 0;
        v18 = v6;
        v19 = v8;
        v20 = v9;
        v21 = v10;
        v22 = *(_QWORD *)(a4 + 28);
        v23 = *(_DWORD *)(a4 + 36);
        v24 = 0u;
        v25 = 0u;
        v26 = 0u;
        v27 = 0u;
        v28 = 0u;
        v29 = 0u;
        memset(v30, 0, sizeof(v30));
        result = ZSTD_resetCCtx_internal(a1, (__int128 *)&v17, a5, 0, 0);
        if (result <= 0xFFFFFFFFFFFFFF88)
        {
          v14 = 0;
          if (a2 && a3 >= 8)
          {
            v15 = *(_QWORD *)(a1 + 2872);
            v16 = *(_DWORD **)(a1 + 3120);
            *(_QWORD *)(v15 + 4580) = 0x400000001;
            *(_DWORD *)(v15 + 4588) = 8;
            *(_DWORD *)(v15 + 1024) = 0;
            *(_QWORD *)(v15 + 4568) = 0;
            *(_DWORD *)(v15 + 4576) = 0;
            if (*a2 == -332356553)
            {
              if (*(_DWORD *)(a1 + 224))
              {
                v14 = 0;
                result = ZSTD_loadCEntropy(v15, v16, (uint64_t)a2, a3);
                if (result > 0xFFFFFFFFFFFFFF88)
                  return result;
              }
              else
              {
                v14 = a2[1];
                result = ZSTD_loadCEntropy(v15, v16, (uint64_t)a2, a3);
                if (result > 0xFFFFFFFFFFFFFF88)
                  return result;
              }
              ZSTD_loadDictionaryContent(a1 + 2888, 0, (_QWORD *)(a1 + 368), (_DWORD *)(a1 + 184), (unint64_t)a2 + result, a3 - result, 0);
            }
            else
            {
              ZSTD_loadDictionaryContent(a1 + 2888, a1 + 712, (_QWORD *)(a1 + 368), (_DWORD *)(a1 + 184), (unint64_t)a2, a3, 0);
              v14 = 0;
            }
          }
          result = 0;
          *(_DWORD *)(a1 + 352) = v14;
          *(_QWORD *)(a1 + 360) = a3;
        }
      }
    }
  }
  return result;
}

unint64_t ZSTD_compressBegin_usingDict(uint64_t a1, _DWORD *a2, unint64_t a3, int a4)
{
  unint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  char *v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unint64_t result;
  int v19;
  uint64_t v20;
  _DWORD *v21;
  __int128 v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v7 = a3 + 499;
  if (!a3)
    v7 = -1;
  v8 = v7 < 0x40001;
  if (v7 <= 0x20000)
    ++v8;
  if (v7 > 0x4000)
    v9 = v8;
  else
    v9 = v8 + 1;
  if (a4 >= 0x16)
    v10 = 22;
  else
    v10 = a4;
  if (a4 < 0)
    v10 = 0;
  if (!a4)
    v10 = 3;
  v11 = (char *)&ZSTD_defaultCParameters + 644 * v9 + 28 * v10;
  v12 = *(_DWORD *)v11;
  v13 = *(_QWORD *)(v11 + 12);
  v14 = *((_DWORD *)v11 + 5);
  v15 = *((_DWORD *)v11 + 6);
  if (a4)
    v16 = a4;
  else
    v16 = 3;
  if (a4 <= 0xFFFE0000)
    v17 = -131072;
  else
    v17 = a4;
  if (a4 < 0)
    v14 = -v17;
  if (v12 <= 0xA)
    v12 = 10;
  LODWORD(v22) = 0;
  DWORD1(v22) = v12;
  *((_QWORD *)&v22 + 1) = *(_QWORD *)(v11 + 4);
  v23 = v13;
  v24 = v14;
  v25 = v15;
  v26 = 1;
  v27 = 0;
  v28 = v16;
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  v36 = 0;
  result = ZSTD_resetCCtx_internal(a1, &v22, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    v19 = 0;
    if (a2 && a3 >= 8)
    {
      v20 = *(_QWORD *)(a1 + 2872);
      v21 = *(_DWORD **)(a1 + 3120);
      *(_QWORD *)(v20 + 4580) = 0x400000001;
      *(_DWORD *)(v20 + 4588) = 8;
      *(_DWORD *)(v20 + 1024) = 0;
      *(_QWORD *)(v20 + 4568) = 0;
      *(_DWORD *)(v20 + 4576) = 0;
      if (*a2 == -332356553)
      {
        if (*(_DWORD *)(a1 + 224))
        {
          v19 = 0;
          result = ZSTD_loadCEntropy(v20, v21, (uint64_t)a2, a3);
          if (result > 0xFFFFFFFFFFFFFF88)
            return result;
        }
        else
        {
          v19 = a2[1];
          result = ZSTD_loadCEntropy(v20, v21, (uint64_t)a2, a3);
          if (result > 0xFFFFFFFFFFFFFF88)
            return result;
        }
        ZSTD_loadDictionaryContent(a1 + 2888, 0, (_QWORD *)(a1 + 368), (_DWORD *)(a1 + 184), (unint64_t)a2 + result, a3 - result, 0);
      }
      else
      {
        ZSTD_loadDictionaryContent(a1 + 2888, a1 + 712, (_QWORD *)(a1 + 368), (_DWORD *)(a1 + 184), (unint64_t)a2, a3, 0);
        v19 = 0;
      }
    }
    result = 0;
    *(_DWORD *)(a1 + 352) = v19;
    *(_QWORD *)(a1 + 360) = a3;
  }
  return result;
}

unint64_t ZSTD_compressBegin(uint64_t a1, int a2)
{
  unsigned int v3;
  char *v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unint64_t result;
  __int128 v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  if (a2 >= 0x16)
    v3 = 22;
  else
    v3 = a2;
  if (a2 < 0)
    v3 = 0;
  if (!a2)
    v3 = 3;
  v4 = (char *)&ZSTD_defaultCParameters + 28 * v3;
  v5 = *(_DWORD *)v4;
  v6 = *(_QWORD *)(v4 + 12);
  v7 = *((_DWORD *)v4 + 5);
  v8 = *((_DWORD *)v4 + 6);
  if (a2)
    v9 = a2;
  else
    v9 = 3;
  if (a2 <= 0xFFFE0000)
    v10 = -131072;
  else
    v10 = a2;
  if (a2 < 0)
    v7 = -v10;
  if (v5 <= 0xA)
    v5 = 10;
  LODWORD(v12) = 0;
  DWORD1(v12) = v5;
  *((_QWORD *)&v12 + 1) = *(_QWORD *)(v4 + 4);
  v13 = v6;
  v14 = v7;
  v15 = v8;
  v16 = 1;
  v17 = 0;
  v18 = v9;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0;
  result = ZSTD_resetCCtx_internal(a1, &v12, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    result = 0;
    *(_DWORD *)(a1 + 352) = 0;
    *(_QWORD *)(a1 + 360) = 0;
  }
  return result;
}

unint64_t ZSTD_compressEnd(int *a1, _BYTE *a2, unint64_t a3, char *a4, size_t a5)
{
  unint64_t result;
  int v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  int v13;
  char *v14;
  uint64_t v15;
  char v16;
  char v17;
  uint64_t v18;
  char v19;
  char *v20;
  int v21;

  result = ZSTD_compressContinue_internal((int32x2_t *)a1, a2, a3, a4, a5, 1, 1);
  if (result > 0xFFFFFFFFFFFFFF88)
    return result;
  v9 = *a1;
  if (!*a1)
    return -60;
  v10 = result;
  v11 = &a2[result];
  v12 = a3 - result;
  if (v9 == 3)
  {
    v14 = v11;
    if (a1[55])
      goto LABEL_24;
  }
  else if (v9 == 1)
  {
    v13 = a1[54];
    if (v12 < 0x12)
      return -70;
    v16 = 8 * *((_BYTE *)a1 + 188) - 80;
    v17 = (4 * (a1[55] > 0)) | (32 * (v13 != 0));
    if (a1[46])
    {
      v18 = 0;
    }
    else
    {
      *(_DWORD *)v11 = -47205080;
      v18 = 4;
    }
    v11[v18] = v17;
    if (v13)
      v19 = 0;
    else
      v19 = v16;
    v11[v18 | 1] = v19;
    v20 = &v11[v18 | 2];
    *a1 = 2;
    *(_DWORD *)v20 = 1;
    v14 = v20 + 3;
    v12 = v12 - (v18 | 2) - 3;
    if (a1[55])
      goto LABEL_24;
  }
  else
  {
    if (v12 < 4)
      return -70;
    *(_DWORD *)v11 = 1;
    v14 = v11 + 3;
    v12 -= 3;
    if (a1[55])
    {
LABEL_24:
      v21 = ZSTD_XXH64_digest((uint64_t *)a1 + 58);
      if (v12 >= 4)
      {
        *(_DWORD *)v14 = v21;
        *a1 = 0;
        result = v14 + 4 - v11;
        if (result > 0xFFFFFFFFFFFFFF88)
          return result;
        goto LABEL_10;
      }
      return -70;
    }
  }
  *a1 = 0;
  result = v14 - v11;
  if ((unint64_t)(v14 - v11) > 0xFFFFFFFFFFFFFF88)
    return result;
LABEL_10:
  v15 = *((_QWORD *)a1 + 55);
  if (v15 && v15 != *((_QWORD *)a1 + 56) + 1)
    return -72;
  result += v10;
  return result;
}

unint64_t ZSTD_compress_advanced(uint64_t a1, _BYTE *a2, unint64_t a3, char *a4, unint64_t a5, _DWORD *a6, unint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v8 = -42;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)xmmword_18823D760, (uint32x4_t)vaddq_s32(*(int32x4_t *)a8, (int32x4_t)xmmword_18823D750)))) & 1) != 0|| (*(_DWORD *)(a8 + 16) - 8) < 0xFFFFFFFB|| *(_DWORD *)(a8 + 20) > 0x20000u)
  {
    return v8;
  }
  if ((*(_DWORD *)(a8 + 24) - 1) <= 8)
  {
    memset(v10, 0, sizeof(v10));
    v19 = 0;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    *(_OWORD *)((char *)v10 + 4) = *(_OWORD *)a8;
    v10[1] = *(_OWORD *)(a8 + 12);
    DWORD2(v11) = *(_DWORD *)(a8 + 36);
    *(_QWORD *)&v11 = *(_QWORD *)(a8 + 28);
    return ZSTD_compress_advanced_internal(a1, a2, a3, a4, a5, a6, a7, (uint64_t)v10);
  }
  return -42;
}

unint64_t ZSTD_compress_advanced_internal(uint64_t a1, _BYTE *a2, unint64_t a3, char *a4, unint64_t a5, _DWORD *a6, unint64_t a7, uint64_t a8)
{
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  unint64_t result;
  int v21;
  uint64_t v22;
  _DWORD *v23;
  __int128 v24[10];
  uint64_t v25;

  v15 = *(_OWORD *)(a8 + 144);
  v24[8] = *(_OWORD *)(a8 + 128);
  v24[9] = v15;
  v25 = *(_QWORD *)(a8 + 160);
  v16 = *(_OWORD *)(a8 + 80);
  v24[4] = *(_OWORD *)(a8 + 64);
  v24[5] = v16;
  v17 = *(_OWORD *)(a8 + 112);
  v24[6] = *(_OWORD *)(a8 + 96);
  v24[7] = v17;
  v18 = *(_OWORD *)(a8 + 16);
  v24[0] = *(_OWORD *)a8;
  v24[1] = v18;
  v19 = *(_OWORD *)(a8 + 48);
  v24[2] = *(_OWORD *)(a8 + 32);
  v24[3] = v19;
  result = ZSTD_resetCCtx_internal(a1, v24, a5, 0, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    v21 = 0;
    if (!a6 || a7 < 8)
      goto LABEL_9;
    v22 = *(_QWORD *)(a1 + 2872);
    v23 = *(_DWORD **)(a1 + 3120);
    *(_QWORD *)(v22 + 4580) = 0x400000001;
    *(_DWORD *)(v22 + 4588) = 8;
    *(_DWORD *)(v22 + 1024) = 0;
    *(_QWORD *)(v22 + 4568) = 0;
    *(_DWORD *)(v22 + 4576) = 0;
    if (*a6 != -332356553)
    {
      ZSTD_loadDictionaryContent(a1 + 2888, a1 + 712, (_QWORD *)(a1 + 368), (_DWORD *)(a1 + 184), (unint64_t)a6, a7, 0);
      v21 = 0;
      goto LABEL_9;
    }
    if (*(_DWORD *)(a1 + 224))
    {
      v21 = 0;
      result = ZSTD_loadCEntropy(v22, v23, (uint64_t)a6, a7);
      if (result > 0xFFFFFFFFFFFFFF88)
        return result;
      goto LABEL_7;
    }
    v21 = a6[1];
    result = ZSTD_loadCEntropy(v22, v23, (uint64_t)a6, a7);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
LABEL_7:
      ZSTD_loadDictionaryContent(a1 + 2888, 0, (_QWORD *)(a1 + 368), (_DWORD *)(a1 + 184), (unint64_t)a6 + result, a7 - result, 0);
LABEL_9:
      *(_DWORD *)(a1 + 352) = v21;
      *(_QWORD *)(a1 + 360) = a7;
      return ZSTD_compressEnd((int *)a1, a2, a3, a4, a5);
    }
  }
  return result;
}

unint64_t ZSTD_compress_usingDict(uint64_t a1, _BYTE *a2, unint64_t a3, char *a4, unint64_t a5, _DWORD *a6, unint64_t a7, int a8)
{
  unint64_t v16;
  int v17;
  _BYTE v19[28];
  _BYTE v20[32];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  *(_OWORD *)v20 = 0uLL;
  if (a6)
    v16 = a7;
  else
    v16 = 0;
  *(_DWORD *)&v20[24] = 0;
  *(_QWORD *)&v20[16] = 0;
  ZSTD_getCParams_internal((uint64_t)v20, a8, a5, v16, 0);
  *(_OWORD *)&v19[12] = *(_OWORD *)&v20[12];
  *(_OWORD *)v19 = *(_OWORD *)v20;
  if (a8)
    v17 = a8;
  else
    v17 = 3;
  *(_DWORD *)v20 = 0;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0;
  *(_OWORD *)&v20[4] = *(_OWORD *)v19;
  *(_OWORD *)&v20[16] = *(_OWORD *)&v19[12];
  v21 = 0u;
  LODWORD(v21) = 1;
  HIDWORD(v21) = v17;
  return ZSTD_compress_advanced_internal(a1, a2, a3, a4, a5, a6, a7, (uint64_t)v20);
}

unint64_t ZSTD_compressCCtx(uint64_t a1, _BYTE *a2, unint64_t a3, char *a4, unint64_t a5, int a6)
{
  int v11;
  unsigned int v12;
  int v13;
  char *v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  unint64_t result;
  __int128 v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  int v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v11 = a5 < 0x40001;
  if (a5 <= 0x20000)
    ++v11;
  if (a5 <= 0x4000)
    ++v11;
  v12 = 3;
  if (a6 >= 0x16)
    v13 = 22;
  else
    v13 = a6;
  if (a6 < 0)
    v13 = 0;
  if (a6)
    v12 = v13;
  v14 = (char *)&ZSTD_defaultCParameters + 644 * v11 + 28 * v12;
  v16 = *(_DWORD *)v14;
  v15 = *((_DWORD *)v14 + 1);
  v17 = *((_DWORD *)v14 + 2);
  v18 = *(_QWORD *)(v14 + 12);
  v20 = *((_DWORD *)v14 + 5);
  v19 = *((_DWORD *)v14 + 6);
  if (a5 >> 30)
  {
    if (a5 == -1)
      goto LABEL_26;
  }
  else
  {
    v21 = __clz(a5 - 1) ^ 0x1F;
    if (a5 >= 0x40)
      v22 = v21 + 1;
    else
      v22 = 6;
    if (v16 >= v22)
      v16 = v22;
  }
  if (v17 >= v16 + 1)
    v17 = v16 + 1;
  if (v19 <= 5)
    v23 = v16;
  else
    v23 = v16 + 1;
  if (v15 - (v19 > 5) > v16)
    v15 = v23;
LABEL_26:
  v41 = 0;
  v40 = 0u;
  if (a6 <= 0xFFFE0000)
    v24 = -131072;
  else
    v24 = a6;
  if (v16 <= 0xA)
    v16 = 10;
  v39 = 0uLL;
  v38 = 0uLL;
  if (a6 < 0)
    v20 = -v24;
  if (a6)
    v25 = a6;
  else
    v25 = 3;
  v37 = 0uLL;
  v36 = 0uLL;
  v35 = 0uLL;
  v34 = 0uLL;
  LODWORD(v27) = 0;
  *(_QWORD *)((char *)&v27 + 4) = __PAIR64__(v15, v16);
  HIDWORD(v27) = v17;
  v28 = v18;
  v29 = v20;
  v30 = v19;
  v31 = 1;
  v32 = 0;
  v33 = v25;
  result = ZSTD_resetCCtx_internal(a1, &v27, a5, 0, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    *(_DWORD *)(a1 + 352) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    return ZSTD_compressEnd((int *)a1, a2, a3, a4, a5);
  }
  return result;
}

unint64_t ZSTD_compress(_BYTE *a1, unint64_t a2, char *a3, unint64_t a4, int a5)
{
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;
  _OWORD *v14;
  _BOOL4 v15;
  void (*v16)(uint64_t);
  void *v17;
  _DWORD v19[92];
  void *v20[2];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  void (*v24)(uint64_t);
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;

  bzero(v19, 0xD00uLL);
  v19[15] = 3;
  v19[12] = 1;
  v10 = ZSTD_compressCCtx((uint64_t)v19, a1, a2, a3, a4, a5);
  if (!(_QWORD)v26)
  {
LABEL_4:
    v11 = v28;
    if (!(_QWORD)v28)
      goto LABEL_18;
LABEL_5:
    v12 = *(_QWORD *)(v11 + 4936);
    v14 = (_OWORD *)(v11 + 32);
    v13 = *(void **)(v11 + 32);
    if ((unint64_t)v13 <= v11)
    {
      v15 = *(_QWORD *)(v11 + 40) >= v11;
      v16 = *(void (**)(uint64_t))(v11 + 4928);
      *(_OWORD *)(v11 + 64) = 0u;
      *(_OWORD *)(v11 + 80) = 0u;
      *v14 = 0u;
      *(_OWORD *)(v11 + 48) = 0u;
      if (!v13)
      {
LABEL_7:
        if (v15)
          goto LABEL_18;
        goto LABEL_12;
      }
    }
    else
    {
      v15 = 0;
      v16 = *(void (**)(uint64_t))(v11 + 4928);
      *(_OWORD *)(v11 + 64) = 0u;
      *(_OWORD *)(v11 + 80) = 0u;
      *v14 = 0u;
      *(_OWORD *)(v11 + 48) = 0u;
      if (!v13)
        goto LABEL_7;
    }
    if (!v16)
    {
      free(v13);
      if (v15)
        goto LABEL_18;
      goto LABEL_17;
    }
    v16(v12);
    if (v15)
      goto LABEL_18;
LABEL_12:
    if (v16)
    {
      ((void (*)(uint64_t, unint64_t))v16)(v12, v11);
      goto LABEL_18;
    }
LABEL_17:
    free((void *)v11);
    goto LABEL_18;
  }
  if (v24)
  {
    v24(v25);
    goto LABEL_4;
  }
  free((void *)v26);
  v11 = v28;
  if ((_QWORD)v28)
    goto LABEL_5;
LABEL_18:
  v30 = 0;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  ZSTDMT_freeCCtx(v31);
  v31 = 0;
  v17 = v20[0];
  v22 = 0u;
  v23 = 0u;
  *(_OWORD *)v20 = 0u;
  v21 = 0u;
  if (v17)
  {
    if (v24)
      v24(v25);
    else
      free(v17);
  }
  return v10;
}

uint64_t ZSTD_estimateCDictSize_advanced(uint64_t a1, _DWORD *a2, int a3)
{
  uint64_t v3;
  unint64_t v4;

  if (a2[6] == 1)
    v3 = 0;
  else
    v3 = 4 << a2[1];
  v4 = ((a1 + 7) & 0xFFFFFFFFFFFFFFF8) + 11352;
  if (a3 == 1)
    v4 = 11352;
  return v4 + v3 + (4 << a2[2]);
}

unint64_t ZSTD_estimateCDictSize(unint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = 0;
  v8 = 0;
  v7 = 0;
  ZSTD_getCParams_internal((uint64_t)&v5, a2, -1, a1, 2);
  v3 = 4 << SBYTE4(v5);
  if (v8 == 1)
    v3 = 0;
  return ((a1 + 7) & 0xFFFFFFFFFFFFFFF8) + (4 << v6) + v3 + 11352;
}

uint64_t ZSTD_sizeof_CDict(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = *(_QWORD *)(result + 32);
    v2 = 4952;
    if (v1 == result)
      v2 = 0;
    return *(_QWORD *)(result + 40) - v1 + v2;
  }
  return result;
}

char *ZSTD_createCDict_advanced(const void *a1, unint64_t a2, int a3, int a4, __int128 *a5, __int128 *a6)
{
  __int128 v7;
  uint64_t v8;
  __int128 v9[2];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  memset(v9, 0, sizeof(v9));
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  *(__int128 *)((char *)v9 + 4) = *a5;
  v9[1] = *(__int128 *)((char *)a5 + 12);
  v10 = 0u;
  LODWORD(v10) = 1;
  v17 = *a6;
  v18 = *((_QWORD *)a6 + 2);
  v7 = *a6;
  v8 = *((_QWORD *)a6 + 2);
  return ZSTD_createCDict_advanced2(a1, a2, a3, a4, v9, (uint64_t)&v7);
}

char *ZSTD_createCDict_advanced2(const void *a1, unint64_t a2, int a3, int a4, __int128 *a5, uint64_t a6)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __n128 v10;
  uint64_t (*v11)(_QWORD, unint64_t, __n128);
  uint64_t v12;
  _BOOL4 v13;
  char *result;
  int v20;
  unsigned int v21;
  int v22;
  char *v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unint64_t v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unint64_t v33;
  unint64_t v34;
  unsigned int v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  unint64_t v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  unint64_t inited;
  BOOL v56;
  uint64_t v57;
  char *v58;
  _OWORD *v59;
  _BOOL4 v60;
  void (*v61)(uint64_t);
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __n128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __n128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;

  v6 = a5[9];
  v81 = a5[8];
  v82 = v6;
  v83 = *((_QWORD *)a5 + 20);
  v7 = a5[5];
  v77 = a5[4];
  v78 = v7;
  v8 = a5[7];
  v79 = a5[6];
  v80 = v8;
  v9 = a5[1];
  v73 = *a5;
  v74 = v9;
  v10 = (__n128)a5[3];
  v11 = *(uint64_t (**)(_QWORD, unint64_t, __n128))a6;
  v12 = *(_QWORD *)(a6 + 8);
  v13 = *(_QWORD *)a6 == 0;
  v75 = a5[2];
  v76 = v10;
  if (((v13 ^ (v12 == 0)) & 1) != 0)
    return 0;
  if (DWORD2(v80))
  {
    v20 = a2 < 0x40001;
    if (a2 <= 0x20000)
      ++v20;
    if (a2 <= 0x4000)
      ++v20;
    v21 = 3;
    if (HIDWORD(v75) >= 0x16)
      v22 = 22;
    else
      v22 = HIDWORD(v75);
    if (v75 < 0)
      v22 = 0;
    if (HIDWORD(v75))
      v21 = v22;
    v23 = (char *)&ZSTD_defaultCParameters + 644 * v20 + 28 * v21;
    v24 = *(_DWORD *)v23;
    v25 = *((_DWORD *)v23 + 1);
    v26 = *((_DWORD *)v23 + 2);
    v27 = *(_QWORD *)(v23 + 12);
    v28 = *((_DWORD *)v23 + 5);
    v29 = *((_DWORD *)v23 + 6);
    if (a2 >> 30)
      goto LABEL_23;
    v30 = __clz(a2 - 1) ^ 0x1F;
    if (a2 >= 0x40)
      v31 = v30 + 1;
    else
      v31 = 6;
    if (v24 >= v31)
      v24 = v31;
    v32 = v24;
    if (a2)
    {
LABEL_23:
      v33 = (1 << v24) + a2;
      v34 = v33 >> 31;
      v35 = __clz(v33 - 1) ^ 0x1F;
      if (v34)
        v36 = 31;
      else
        v36 = v35 + 1;
      if (1 << v24 < a2)
        v32 = v36;
      else
        v32 = v24;
    }
    if (v29 <= 5)
      v37 = v32;
    else
      v37 = v32 + 1;
    if (v26 >= v32 + 1)
      v26 = v32 + 1;
    if (v25 - (v29 > 5) > v32)
      v25 = v37;
    if (HIDWORD(v75) <= 0xFFFE0000)
      v38 = -131072;
    else
      v38 = HIDWORD(v75);
    if (v75 < 0)
      v39 = -v38;
    else
      v39 = v28;
    if (v24 <= 0xA)
      v40 = 10;
    else
      v40 = v24;
    if (v29 - 3 >= 3)
      v41 = v26;
    else
      v41 = v26 + 2;
    v42 = HIDWORD(v27);
    v43 = DWORD1(v73);
    if (!DWORD1(v73))
      v43 = v40;
    v44 = HIDWORD(v73);
    if (!HIDWORD(v73))
      v44 = v41;
    if (DWORD2(v73))
      v45 = DWORD2(v73);
    else
      v45 = v25;
    if ((_DWORD)v74)
      LODWORD(v27) = v74;
    if (DWORD1(v74))
      v46 = DWORD1(v74);
    else
      v46 = v42;
    if (DWORD2(v74))
      v47 = DWORD2(v74);
    else
      v47 = v39;
    if (HIDWORD(v74))
      v29 = HIDWORD(v74);
    if (v29 - 6 <= 0xFFFFFFFC)
      goto LABEL_66;
  }
  else
  {
    v10.n128_u64[0] = (unint64_t)ZSTD_getCParamsFromCCtxParams((int8x8_t *)&v73, -1, a2, 2, (uint64_t)&v62);
    v43 = v62;
    v45 = DWORD1(v62);
    v44 = DWORD2(v62);
    LODWORD(v27) = HIDWORD(v62);
    v46 = v63;
    v47 = DWORD1(v63);
    v29 = DWORD2(v63);
    if ((DWORD2(v63) - 6) <= 0xFFFFFFFC)
    {
LABEL_66:
      DWORD2(v80) = 0;
      v10.n128_u64[0] = (unint64_t)ZSTD_getCParamsFromCCtxParams((int8x8_t *)&v73, -1, a2, 2, (uint64_t)&v62);
      v43 = v62;
      v45 = DWORD1(v62);
      v44 = DWORD2(v62);
      LODWORD(v27) = HIDWORD(v62);
      v46 = v63;
      v47 = DWORD1(v63);
      v29 = DWORD2(v63);
    }
  }
  *(_QWORD *)((char *)&v73 + 4) = __PAIR64__(v45, v43);
  HIDWORD(v73) = v44;
  *(_QWORD *)&v74 = v27 | (unint64_t)(v46 << 32);
  *((_QWORD *)&v74 + 1) = __PAIR64__(v29, v47);
  v48 = *(_QWORD *)(a6 + 16);
  v49 = 4 << v45;
  if (v29 == 1)
    v49 = 0;
  v50 = 4 << v44;
  v51 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8) + 11352;
  if (a3 == 1)
    v51 = 11352;
  v52 = v50 + v51;
  v53 = v52 + v49;
  if (v11)
  {
    v54 = (char *)v11(*(_QWORD *)(a6 + 16), v52 + v49, v10);
    if (!v54)
      goto LABEL_74;
    goto LABEL_73;
  }
  v54 = (char *)malloc_type_malloc(v52 + v49, 0x26AA08A0uLL);
  if (v54)
  {
LABEL_73:
    *((_QWORD *)v54 + 4) = v54;
    *((_QWORD *)v54 + 5) = &v54[v53];
    *((_QWORD *)v54 + 6) = v54 + 4952;
    *((_QWORD *)v54 + 7) = v54 + 4952;
    *((_QWORD *)v54 + 8) = v54 + 4952;
    *((_QWORD *)v54 + 9) = &v54[v53];
    *((_QWORD *)v54 + 10) = 0;
    *((_QWORD *)v54 + 11) = 0;
    *((_QWORD *)v54 + 615) = v11;
    *((_QWORD *)v54 + 616) = v12;
    *((_QWORD *)v54 + 617) = v48;
    *((_DWORD *)v54 + 1237) = 0;
  }
LABEL_74:
  v70 = v81;
  v71 = v82;
  v72 = v83;
  v66 = v77;
  v67 = v78;
  v68 = v79;
  v69 = v80;
  v62 = v73;
  v63 = v74;
  v64 = v75;
  v65 = v76;
  inited = ZSTD_initCDict_internal((uint64_t)v54, a1, a2, a3, a4, (uint64_t)&v62);
  v56 = __CFADD__(inited, 119);
  if (inited >= 0xFFFFFFFFFFFFFF89)
    result = 0;
  else
    result = v54;
  if (v56 && v54)
  {
    v57 = *((_QWORD *)v54 + 617);
    v59 = v54 + 32;
    v58 = (char *)*((_QWORD *)v54 + 4);
    if (v58 <= v54)
    {
      v60 = *((_QWORD *)v54 + 5) >= (unint64_t)v54;
      v61 = (void (*)(uint64_t))*((_QWORD *)v54 + 616);
      *((_OWORD *)v54 + 4) = 0u;
      *((_OWORD *)v54 + 5) = 0u;
      *v59 = 0u;
      *((_OWORD *)v54 + 3) = 0u;
      if (!v58)
        goto LABEL_90;
    }
    else
    {
      v60 = 0;
      v61 = (void (*)(uint64_t))*((_QWORD *)v54 + 616);
      *((_OWORD *)v54 + 4) = 0u;
      *((_OWORD *)v54 + 5) = 0u;
      *v59 = 0u;
      *((_OWORD *)v54 + 3) = 0u;
      if (!v58)
        goto LABEL_90;
    }
    if (!v61)
    {
      free(v58);
      if (v60)
        return 0;
      goto LABEL_94;
    }
    v61(v57);
LABEL_90:
    if (v60)
      return 0;
    if (v61)
    {
      ((void (*)(uint64_t, char *))v61)(v57, v54);
      return 0;
    }
LABEL_94:
    free(v54);
    return 0;
  }
  return result;
}

unint64_t ZSTD_initCDict_internal(uint64_t a1, const void *a2, size_t __n, int a4, int a5, uint64_t a6)
{
  unint64_t v10;
  __int128 v11;
  int v12;
  BOOL v13;
  void *v14;
  size_t v15;
  size_t v16;
  unint64_t result;
  __int128 *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;

  v10 = a1 + 96;
  v11 = *(_OWORD *)(a6 + 4);
  *(_OWORD *)(a1 + 300) = *(_OWORD *)(a6 + 16);
  *(_OWORD *)(a1 + 288) = v11;
  v12 = *(_DWORD *)(a6 + 120);
  if (v12)
    v13 = (__n & 0xFFFFFFFFE0000000) == 0;
  else
    v13 = 1;
  if (!v13)
    v12 = 0;
  *(_DWORD *)(a1 + 168) = v12;
  if (__n && a2 && a4 != 1)
  {
    if (*(_DWORD *)(a1 + 88)
      || (v15 = *(_QWORD *)(a1 + 40),
          v14 = *(void **)(a1 + 48),
          v16 = (size_t)v14 + ((__n + 7) & 0xFFFFFFFFFFFFFFF8),
          v16 > v15))
    {
      *(_BYTE *)(a1 + 80) = 1;
      return -64;
    }
    *(_QWORD *)(a1 + 48) = v16;
    *(_QWORD *)(a1 + 56) = v16;
    *(_QWORD *)(a1 + 64) = v16;
    if (!v14)
      return -64;
    *(_QWORD *)a1 = v14;
    memcpy(v14, a2, __n);
    v18 = (__int128 *)(a6 + 4);
    *(_QWORD *)(a1 + 8) = __n;
    *(_DWORD *)(a1 + 16) = a5;
    v19 = (_QWORD *)(a1 + 32);
    if (*(_DWORD *)(a1 + 88))
      goto LABEL_18;
  }
  else
  {
    *(_QWORD *)a1 = a2;
    *(_QWORD *)(a1 + 8) = __n;
    v18 = (__int128 *)(a6 + 4);
    *(_DWORD *)(a1 + 16) = a5;
    v19 = (_QWORD *)(a1 + 32);
    if (*(_DWORD *)(a1 + 88))
      goto LABEL_18;
  }
  v20 = *(_QWORD *)(a1 + 48);
  v21 = v20 + 6400;
  if ((unint64_t)(v20 + 6400) <= *(_QWORD *)(a1 + 40))
  {
    *(_QWORD *)(a1 + 48) = v21;
    *(_QWORD *)(a1 + 56) = v21;
    *(_QWORD *)(a1 + 64) = v21;
    goto LABEL_19;
  }
LABEL_18:
  v20 = 0;
  *(_BYTE *)(a1 + 80) = 1;
LABEL_19:
  *(_QWORD *)(a1 + 24) = v20;
  *(_QWORD *)(a1 + 4908) = 0x400000001;
  *(_DWORD *)(a1 + 4916) = 8;
  *(_DWORD *)(a1 + 1352) = 0;
  *(_QWORD *)(a1 + 4896) = 0;
  *(_DWORD *)(a1 + 4904) = 0;
  result = ZSTD_reset_matchState(v10, (uint64_t)v19, v18, 0, 1, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    *(_DWORD *)(a6 + 44) = 3;
    *(_DWORD *)(a6 + 32) = 1;
    result = ZSTD_compress_insertDictionary(a1 + 328, v10, 0, v19, (_DWORD *)a6, *(_DWORD **)a1, *(_QWORD *)(a1 + 8), a5, 1, *(_DWORD **)(a1 + 24));
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      *(_DWORD *)(a1 + 4944) = result;
      return 0;
    }
  }
  return result;
}

uint64_t ZSTD_freeCDict(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  _OWORD *v4;
  _BOOL4 v5;
  void (*v6)(uint64_t);

  if (!a1)
    return 0;
  v2 = a1[617];
  v4 = a1 + 4;
  v3 = (_QWORD *)a1[4];
  if (v3 <= a1)
  {
    v5 = a1[5] >= (unint64_t)a1;
    v6 = (void (*)(uint64_t))a1[616];
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *v4 = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    if (!v3)
    {
LABEL_4:
      if (!v5)
        goto LABEL_9;
      return 0;
    }
  }
  else
  {
    v5 = 0;
    v6 = (void (*)(uint64_t))a1[616];
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *v4 = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    if (!v3)
      goto LABEL_4;
  }
  if (!v6)
  {
    free(v3);
    if (v5)
      return 0;
    goto LABEL_12;
  }
  v6(v2);
  if (!v5)
  {
LABEL_9:
    if (v6)
    {
      ((void (*)(uint64_t, _QWORD *))v6)(v2, a1);
      return 0;
    }
LABEL_12:
    free(a1);
  }
  return 0;
}

char *ZSTD_createCDict(const void *a1, unint64_t a2, int a3)
{
  char *result;
  int v7;
  _OWORD v8[2];
  int v9;
  _BYTE v10[28];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  memset(v8, 0, 28);
  ZSTD_getCParams_internal((uint64_t)v8, a3, -1, a2, 2);
  v9 = 0;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  *(_OWORD *)v10 = v8[0];
  *(_OWORD *)&v10[12] = *(_OWORD *)((char *)v8 + 12);
  v11 = 0u;
  LODWORD(v11) = 1;
  v19 = 0;
  v20 = 0;
  v18 = 0;
  result = ZSTD_createCDict_advanced2(a1, a2, 0, 0, (__int128 *)&v9, (uint64_t)&ZSTD_defaultCMem);
  if (result)
  {
    if (a3)
      v7 = a3;
    else
      v7 = 3;
    *((_DWORD *)result + 1237) = v7;
  }
  return result;
}

char *ZSTD_createCDict_byReference(const void *a1, unint64_t a2, int a3)
{
  char *result;
  int v7;
  _OWORD v8[2];
  int v9;
  _BYTE v10[28];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  memset(v8, 0, 28);
  ZSTD_getCParams_internal((uint64_t)v8, a3, -1, a2, 2);
  v9 = 0;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  *(_OWORD *)v10 = v8[0];
  *(_OWORD *)&v10[12] = *(_OWORD *)((char *)v8 + 12);
  v11 = 0u;
  LODWORD(v11) = 1;
  v19 = 0;
  v20 = 0;
  v18 = 0;
  result = ZSTD_createCDict_advanced2(a1, a2, 1, 0, (__int128 *)&v9, (uint64_t)&ZSTD_defaultCMem);
  if (result)
  {
    if (a3)
      v7 = a3;
    else
      v7 = 3;
    *((_DWORD *)result + 1237) = v7;
  }
  return result;
}

uint64_t ZSTD_initStaticCDict(uint64_t a1, uint64_t a2, const void *a3, size_t __n, int a5, int a6, unsigned int *a7)
{
  uint64_t v8;
  size_t v9;
  uint64_t result;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  __int128 v14;
  uint64_t v15;
  int v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  int v25;
  __int128 v26;
  uint64_t v27;

  if (a7[6] == 1)
    v8 = 0;
  else
    v8 = 4 << a7[1];
  v9 = ((__n + 7) & 0xFFFFFFFFFFFFFFF8) + 11352;
  if (a5 == 1)
    v9 = 11352;
  if ((a1 & 7) != 0)
    return 0;
  result = 0;
  if (a1)
  {
    if (a2 >= 4952)
    {
      result = 0;
      v11 = 4 << a7[2];
      *(_QWORD *)(a1 + 32) = a1;
      *(_QWORD *)(a1 + 40) = a1 + a2;
      *(_QWORD *)(a1 + 48) = a1 + 4952;
      *(_QWORD *)(a1 + 56) = a1 + 4952;
      *(_QWORD *)(a1 + 64) = a1 + 4952;
      *(_QWORD *)(a1 + 72) = a1 + a2;
      *(_QWORD *)(a1 + 80) = 0;
      *(_QWORD *)(a1 + 88) = 0x100000000;
      if (v8 + v9 + v11 <= a2)
      {
        v12 = (unint64_t)*a7 << 32;
        v26 = *(_OWORD *)(a7 + 1);
        v27 = *(_QWORD *)(a7 + 5);
        v13 = v12;
        v14 = v26;
        v15 = v27;
        v16 = 1;
        v17 = 0u;
        v18 = 0u;
        v19 = 0u;
        v20 = 0u;
        v21 = 0u;
        v22 = 0u;
        v23 = 0u;
        v24 = 0u;
        v25 = 0;
        if (ZSTD_initCDict_internal(a1, a3, __n, a5, a6, (uint64_t)&v13) >= 0xFFFFFFFFFFFFFF89)
          return 0;
        else
          return a1;
      }
    }
  }
  return result;
}

__n128 ZSTD_getCParamsFromCDict@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;

  *(_OWORD *)a2 = *(_OWORD *)(a1 + 288);
  result = *(__n128 *)(a1 + 300);
  *(__n128 *)(a2 + 12) = result;
  return result;
}

uint64_t ZSTD_getDictID_fromCDict(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 4944);
  return result;
}

unint64_t ZSTD_compressBegin_usingCDict_advanced(uint64_t a1, uint64_t a2, uint64_t a3, int a4, unint64_t a5)
{
  int v10;
  unsigned int v11;
  BOOL v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v16;
  _OWORD v17[2];
  int v18;
  _BYTE v19[28];
  uint64_t v20;
  int v21;
  int v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  if (!a2)
    return -32;
  memset(v17, 0, 28);
  if (a5 < 0x20000 || a5 == -1 || (v16 = *(_QWORD *)(a2 + 8), 6 * v16 > a5) || (v10 = *(_DWORD *)(a2 + 4948)) == 0)
  {
    v17[0] = *(_OWORD *)(a2 + 288);
    *(_OWORD *)((char *)v17 + 12) = *(_OWORD *)(a2 + 300);
    v10 = *(_DWORD *)(a2 + 4948);
  }
  else
  {
    ZSTD_getCParams_internal((uint64_t)v17, *(_DWORD *)(a2 + 4948), a5, v16, 3);
  }
  v18 = 0;
  v30 = 0;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v23 = 0u;
  *(_OWORD *)v19 = v17[0];
  *(_OWORD *)&v19[12] = *(_OWORD *)((char *)v17 + 12);
  v20 = a3;
  v21 = a4;
  v22 = v10;
  if (a5 != -1)
  {
    v11 = 0x80000;
    if (a5 < 0x80000)
      v11 = a5;
    v12 = v11 > 1;
    v13 = __clz(v11 - 1) ^ 0x1F;
    if (v12)
      v14 = v13 + 1;
    else
      v14 = 1;
    if (*(_DWORD *)v19 > v14)
      v14 = *(_DWORD *)v19;
    *(_DWORD *)v19 = v14;
  }
  return ZSTD_compressBegin_internal(a1, 0, 0, 0, 0, a2, (uint64_t *)&v18, a5, 0);
}

uint64_t ZSTD_getCParams@<X0>(int a1@<W0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v5;

  if (a2)
    v5 = a2;
  else
    v5 = -1;
  return ZSTD_getCParams_internal(a4, a1, v5, a3, 3);
}

unint64_t ZSTD_compressBegin_usingCDict(uint64_t a1, uint64_t a2)
{
  int v2;
  _OWORD v4[2];
  uint64_t v5;
  int v6;
  int v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  if (!a2)
    return -32;
  v2 = *(_DWORD *)(a2 + 4948);
  memset(v4, 0, sizeof(v4));
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0;
  *(_OWORD *)((char *)v4 + 4) = *(_OWORD *)(a2 + 288);
  v4[1] = *(_OWORD *)(a2 + 300);
  v5 = 0;
  v6 = 0;
  v7 = v2;
  return ZSTD_compressBegin_internal(a1, 0, 0, 0, 0, a2, (uint64_t *)v4, 0xFFFFFFFFFFFFFFFFLL, 0);
}

unint64_t ZSTD_compress_usingCDict_advanced(int *a1, _BYTE *a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unint64_t result;

  result = ZSTD_compressBegin_usingCDict_advanced((uint64_t)a1, a6, a7, a8, a5);
  if (result <= 0xFFFFFFFFFFFFFF88)
    return ZSTD_compressEnd(a1, a2, a3, a4, a5);
  return result;
}

unint64_t ZSTD_compress_usingCDict(int *a1, _BYTE *a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6)
{
  unint64_t result;

  result = ZSTD_compressBegin_usingCDict_advanced((uint64_t)a1, a6, 1, 0, a5);
  if (result <= 0xFFFFFFFFFFFFFF88)
    return ZSTD_compressEnd(a1, a2, a3, a4, a5);
  return result;
}

uint64_t ZSTD_createCStream()
{
  void *v0;
  uint64_t v1;

  v0 = malloc_type_malloc(0xD00uLL, 0x26AA08A0uLL);
  v1 = (uint64_t)v0;
  if (v0)
  {
    bzero(v0, 0xD00uLL);
    ZSTD_clearAllDicts(v1);
    *(_QWORD *)(v1 + 176) = 0;
    *(_OWORD *)(v1 + 144) = 0u;
    *(_OWORD *)(v1 + 160) = 0u;
    *(_OWORD *)(v1 + 112) = 0u;
    *(_OWORD *)(v1 + 128) = 0u;
    *(_OWORD *)(v1 + 80) = 0u;
    *(_OWORD *)(v1 + 96) = 0u;
    *(_OWORD *)(v1 + 48) = 0u;
    *(_OWORD *)(v1 + 64) = 0u;
    *(_OWORD *)(v1 + 16) = 0u;
    *(_OWORD *)(v1 + 32) = 0u;
    *(_DWORD *)(v1 + 60) = 3;
    *(_DWORD *)(v1 + 48) = 1;
  }
  return v1;
}

void *ZSTD_createCStream_advanced(uint64_t a1)
{
  uint64_t (*v1)(_QWORD, uint64_t);
  uint64_t v2;
  void *v3;
  uint64_t v5;

  v1 = *(uint64_t (**)(_QWORD, uint64_t))a1;
  v2 = *(_QWORD *)(a1 + 8);
  if ((*(_QWORD *)a1 == 0) != (v2 == 0))
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (v1)
  {
    v3 = (void *)v1(*(_QWORD *)(a1 + 16), 3328);
    if (!v3)
      return v3;
  }
  else
  {
    v3 = malloc_type_malloc(0xD00uLL, 0x26AA08A0uLL);
    if (!v3)
      return v3;
  }
  bzero(v3, 0xD00uLL);
  *((_QWORD *)v3 + 69) = v1;
  *((_QWORD *)v3 + 70) = v2;
  *((_QWORD *)v3 + 71) = v5;
  ZSTD_clearAllDicts((uint64_t)v3);
  *((_QWORD *)v3 + 22) = 0;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_DWORD *)v3 + 15) = 3;
  *((_DWORD *)v3 + 12) = 1;
  return v3;
}

char *ZSTD_initStaticCStream(char *a1, uint64_t a2)
{
  char *result;
  unint64_t v5;
  char *v6;

  result = 0;
  if ((unint64_t)a2 >= 0xD01 && (a1 & 7) == 0)
  {
    result = 0;
    if (a1)
    {
      v5 = a2 - 3328;
      if (a2 >= 3328)
      {
        v6 = &a1[a2];
        bzero(a1, 0xD00uLL);
        result = 0;
        *((_QWORD *)a1 + 46) = a1;
        *((_QWORD *)a1 + 47) = v6;
        *((_QWORD *)a1 + 48) = a1 + 3328;
        *((_QWORD *)a1 + 49) = a1 + 3328;
        *((_QWORD *)a1 + 50) = a1 + 3328;
        *((_QWORD *)a1 + 51) = v6;
        *((_QWORD *)a1 + 52) = 0;
        *((_QWORD *)a1 + 53) = 0x100000000;
        *((_QWORD *)a1 + 73) = a2;
        if (v5 >> 3 >= 0x7B7)
        {
          *((_QWORD *)a1 + 359) = a1 + 3328;
          *((_QWORD *)a1 + 360) = a1 + 7920;
          *((_QWORD *)a1 + 48) = a1 + 19128;
          *((_QWORD *)a1 + 49) = a1 + 19128;
          *((_QWORD *)a1 + 50) = a1 + 19128;
          *((_QWORD *)a1 + 390) = a1 + 12512;
          return a1;
        }
      }
    }
  }
  return result;
}

uint64_t ZSTD_CStreamInSize()
{
  return 0x20000;
}

uint64_t ZSTD_CStreamOutSize()
{
  return 131591;
}

uint64_t ZSTD_resetCStream(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_DWORD *)(a1 + 3208) = 0;
  if (a2)
    v2 = a2 + 1;
  else
    v2 = 0;
  *(_QWORD *)(a1 + 440) = v2;
  return 0;
}

uint64_t ZSTD_initCStream_internal(uint64_t a1, const void *a2, size_t a3, uint64_t a4, __int128 *a5, uint64_t a6)
{
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  double v18;
  uint64_t result;
  uint64_t (*v20)(_QWORD, size_t, double);
  void *v21;

  *(_DWORD *)(a1 + 3208) = 0;
  *(_QWORD *)(a1 + 440) = a6 + 1;
  v10 = *a5;
  v11 = a5[2];
  *(_OWORD *)(a1 + 32) = a5[1];
  *(_OWORD *)(a1 + 48) = v11;
  *(_OWORD *)(a1 + 16) = v10;
  v12 = a5[3];
  v13 = a5[4];
  v14 = a5[6];
  *(_OWORD *)(a1 + 96) = a5[5];
  *(_OWORD *)(a1 + 112) = v14;
  *(_OWORD *)(a1 + 64) = v12;
  *(_OWORD *)(a1 + 80) = v13;
  v15 = a5[7];
  v16 = a5[8];
  v17 = a5[9];
  *(_QWORD *)(a1 + 176) = *((_QWORD *)a5 + 20);
  *(_OWORD *)(a1 + 144) = v16;
  *(_OWORD *)(a1 + 160) = v17;
  *(_OWORD *)(a1 + 128) = v15;
  v18 = ZSTD_clearAllDicts(a1);
  if (!a2)
  {
    result = 0;
    *(_QWORD *)(a1 + 3288) = a4;
    return result;
  }
  if (!a3)
    return 0;
  if (*(_QWORD *)(a1 + 584))
    return -64;
  v20 = *(uint64_t (**)(_QWORD, size_t, double))(a1 + 552);
  if (v20)
  {
    v21 = (void *)v20(*(_QWORD *)(a1 + 568), a3, v18);
    if (v21)
    {
LABEL_9:
      memcpy(v21, a2, a3);
      result = 0;
      *(_QWORD *)(a1 + 3248) = v21;
      *(_QWORD *)(a1 + 3256) = v21;
      *(_QWORD *)(a1 + 3264) = a3;
      *(_DWORD *)(a1 + 3272) = 0;
      return result;
    }
  }
  else
  {
    v21 = malloc_type_malloc(a3, 0x26AA08A0uLL);
    if (v21)
      goto LABEL_9;
  }
  return -64;
}

uint64_t ZSTD_initCStream_usingCDict_advanced(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  *(_DWORD *)(a1 + 3208) = 0;
  *(_QWORD *)(a1 + 440) = a5 + 1;
  *(_QWORD *)(a1 + 48) = a3;
  *(_DWORD *)(a1 + 56) = a4;
  ZSTD_clearAllDicts(a1);
  *(_QWORD *)(a1 + 3288) = a2;
  return 0;
}

uint64_t ZSTD_initCStream_usingCDict(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 3208) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  ZSTD_clearAllDicts(a1);
  *(_QWORD *)(a1 + 3288) = a2;
  return 0;
}

uint64_t ZSTD_initCStream_advanced(uint64_t a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t result;
  int32x4_t v10;
  unsigned int v11;
  double v12;
  uint64_t (*v13)(_QWORD, size_t, double);
  void *v14;

  if (a5 || *(_DWORD *)(a4 + 28))
    v8 = a5 + 1;
  else
    v8 = 0;
  *(_DWORD *)(a1 + 3208) = 0;
  *(_QWORD *)(a1 + 440) = v8;
  result = -42;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)xmmword_18823D760, (uint32x4_t)vaddq_s32(*(int32x4_t *)a4, (int32x4_t)xmmword_18823D750)))) & 1) == 0&& (*(_DWORD *)(a4 + 16) - 8) >= 0xFFFFFFFB&& *(_DWORD *)(a4 + 20) <= 0x20000u&& (*(_DWORD *)(a4 + 24) - 1) <= 8)
  {
    v10 = *(int32x4_t *)a4;
    *(_OWORD *)(a1 + 32) = *(_OWORD *)(a4 + 12);
    *(int32x4_t *)(a1 + 20) = v10;
    v11 = *(_DWORD *)(a4 + 36);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a4 + 28);
    *(_QWORD *)(a1 + 56) = v11;
    v12 = ZSTD_clearAllDicts(a1);
    result = 0;
    if (a2)
    {
      if (a3)
      {
        if (*(_QWORD *)(a1 + 584))
          return -64;
        v13 = *(uint64_t (**)(_QWORD, size_t, double))(a1 + 552);
        if (v13)
        {
          v14 = (void *)v13(*(_QWORD *)(a1 + 568), a3, v12);
          if (v14)
          {
LABEL_16:
            memcpy(v14, a2, a3);
            result = 0;
            *(_QWORD *)(a1 + 3248) = v14;
            *(_QWORD *)(a1 + 3256) = v14;
            *(_QWORD *)(a1 + 3264) = a3;
            *(_DWORD *)(a1 + 3272) = 0;
            return result;
          }
        }
        else
        {
          v14 = malloc_type_malloc(a3, 0x26AA08A0uLL);
          if (v14)
            goto LABEL_16;
        }
        return -64;
      }
    }
  }
  return result;
}

uint64_t ZSTD_initCStream_usingDict(uint64_t a1, const void *a2, size_t a3, int a4)
{
  int v7;
  BOOL v8;
  int v10;
  double v11;
  uint64_t result;
  uint64_t (*v13)(_QWORD, size_t, double);
  void *v14;

  if (a4 <= -131072)
    v7 = -131072;
  else
    v7 = a4;
  v8 = v7 <= 22;
  if (v7 >= 22)
    v7 = 22;
  *(_DWORD *)(a1 + 3208) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  if (!v8 || a4 < -131072)
    v10 = v7;
  else
    v10 = a4;
  if (!v10)
    v10 = 3;
  *(_DWORD *)(a1 + 60) = v10;
  v11 = ZSTD_clearAllDicts(a1);
  result = 0;
  if (a2 && a3)
  {
    if (*(_QWORD *)(a1 + 584))
      return -64;
    v13 = *(uint64_t (**)(_QWORD, size_t, double))(a1 + 552);
    if (v13)
    {
      v14 = (void *)v13(*(_QWORD *)(a1 + 568), a3, v11);
      if (v14)
      {
LABEL_21:
        memcpy(v14, a2, a3);
        result = 0;
        *(_QWORD *)(a1 + 3248) = v14;
        *(_QWORD *)(a1 + 3256) = v14;
        *(_QWORD *)(a1 + 3264) = a3;
        *(_DWORD *)(a1 + 3272) = 0;
        return result;
      }
    }
    else
    {
      v14 = malloc_type_malloc(a3, 0x26AA08A0uLL);
      if (v14)
        goto LABEL_21;
    }
    return -64;
  }
  return result;
}

uint64_t ZSTD_initCStream_srcSize(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  BOOL v9;
  int v11;

  *(_DWORD *)(a1 + 3208) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  ZSTD_clearAllDicts(a1);
  *(_QWORD *)(a1 + 3288) = 0;
  if (*(_DWORD *)(a1 + 3208))
  {
    *(_DWORD *)(a1 + 4) = 1;
    result = -60;
  }
  else
  {
    result = 0;
    if (a3)
      v7 = a3 + 1;
    else
      v7 = 0;
    *(_QWORD *)(a1 + 440) = v7;
  }
  if (a2 <= -131072)
    v8 = -131072;
  else
    v8 = a2;
  v9 = v8 <= 22;
  if (v8 >= 22)
    v8 = 22;
  if (!v9 || a2 < -131072)
    v11 = v8;
  else
    v11 = a2;
  if (!v11)
    v11 = 3;
  *(_DWORD *)(a1 + 60) = v11;
  return result;
}

uint64_t ZSTD_initCStream(uint64_t a1, int a2)
{
  int v4;
  BOOL v5;
  int v7;

  *(_DWORD *)(a1 + 3208) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  ZSTD_clearAllDicts(a1);
  *(_QWORD *)(a1 + 3288) = 0;
  if (*(_DWORD *)(a1 + 3208))
    *(_DWORD *)(a1 + 4) = 1;
  if (a2 <= -131072)
    v4 = -131072;
  else
    v4 = a2;
  v5 = v4 <= 22;
  if (v4 >= 22)
    v4 = 22;
  if (!v5 || a2 < -131072)
    v7 = v4;
  else
    v7 = a2;
  if (!v7)
    v7 = 3;
  *(_DWORD *)(a1 + 60) = v7;
  return 0;
}

void ZSTD_compressStream(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  ZSTD_compressStream2(a1, a2, a3, 0);
}

void ZSTD_compressStream2(uint64_t a1, uint64_t *a2, uint64_t *a3, unsigned int a4)
{
  unint64_t v5;
  uint64_t *v6;
  int v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  _BYTE v36[28];

  if (a2[2] > (unint64_t)a2[1])
    return;
  v6 = a3 + 1;
  v5 = a3[1];
  if (v6[1] > v5 || a4 > 2)
    return;
  if (*(_DWORD *)(a1 + 3208))
  {
    v10 = *(_DWORD *)(a1 + 308);
    goto LABEL_7;
  }
  ZSTD_CCtx_init_compressStream2(a1, a4, v5);
  if (v11 > 0xFFFFFFFFFFFFFF88)
    return;
  v10 = *(_DWORD *)(a1 + 308);
  if (v10 == 1)
  {
    v21 = *(_OWORD *)a3;
    *(_QWORD *)(a1 + 3232) = a3[2];
    *(_OWORD *)(a1 + 3216) = v21;
    if (*(_DWORD *)(a1 + 312) != 1)
      goto LABEL_7;
  }
  else if (*(_DWORD *)(a1 + 312) != 1)
  {
    goto LABEL_7;
  }
  *(_QWORD *)(a1 + 3240) = a2[1] - a2[2];
LABEL_7:
  if ((v10 != 1
     || *(_QWORD *)(a1 + 3216) == *a3 && *(_QWORD *)(a1 + 3232) == a3[2] && a4 == 2 && *(_QWORD *)(a1 + 3224) == a3[1])
    && (*(_DWORD *)(a1 + 312) != 1 || *(_QWORD *)(a1 + 3240) == a2[1] - a2[2]))
  {
    if (*(int *)(a1 + 260) < 1)
    {
      if (ZSTD_compressStream_generic((int32x2_t *)a1, a2, a3, a4) <= 0xFFFFFFFFFFFFFF88)
      {
        if (*(_DWORD *)(a1 + 308) == 1)
        {
          v20 = *(_OWORD *)a3;
          *(_QWORD *)(a1 + 3232) = a3[2];
          *(_OWORD *)(a1 + 3216) = v20;
        }
        if (*(_DWORD *)(a1 + 312) == 1)
          *(_QWORD *)(a1 + 3240) = a2[1] - a2[2];
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 4))
      {
        v12 = *(_QWORD *)(a1 + 3320);
        v13 = *(_DWORD *)(v12 + 44);
        *(_DWORD *)(v12 + 84) = *(_DWORD *)(a1 + 60);
        memset(&v36[4], 0, 24);
        ZSTD_getCParamsFromCCtxParams((int8x8_t *)(a1 + 16), -1, 0, 0, (uint64_t)v36);
        *(_DWORD *)v36 = v13;
        *(_OWORD *)(v12 + 56) = *(_OWORD *)&v36[12];
        *(_OWORD *)(v12 + 44) = *(_OWORD *)v36;
        *(_DWORD *)(a1 + 4) = 0;
      }
      if (a4)
      {
        if (a4 == 2)
        {
          v14 = a3[2];
          v15 = a2[2];
          while (1)
          {
            v16 = ZSTDMT_compressStream_generic(*(_QWORD *)(a1 + 3320), a2, a3, 2);
            v17 = a3[2];
            v18 = *(_QWORD *)(a1 + 456);
            *(_QWORD *)(a1 + 448) += v17 - v14;
            v19 = a2[2];
            *(_QWORD *)(a1 + 456) = v19 - v15 + v18;
            if (v16 > 0xFFFFFFFFFFFFFF88)
              break;
            if (!v16)
            {
              *(_DWORD *)(a1 + 3208) = 0;
              *(_QWORD *)(a1 + 440) = 0;
              goto LABEL_55;
            }
            v15 = v19;
            v14 = v17;
            if (v19 == a2[1])
              goto LABEL_55;
          }
        }
        else
        {
          v29 = a3[2];
          v30 = a2[2];
          while (1)
          {
            v31 = ZSTDMT_compressStream_generic(*(_QWORD *)(a1 + 3320), a2, a3, a4);
            v32 = a3[2];
            v33 = *(_QWORD *)(a1 + 456);
            *(_QWORD *)(a1 + 448) += v32 - v29;
            v34 = a2[2];
            *(_QWORD *)(a1 + 456) = v34 - v30 + v33;
            if (v31 > 0xFFFFFFFFFFFFFF88)
              break;
            if (v31)
            {
              v30 = v34;
              v29 = v32;
              if (v34 != a2[1])
                continue;
            }
            goto LABEL_55;
          }
        }
      }
      else
      {
        v22 = a3[2];
        v23 = a2[2];
        while (1)
        {
          v24 = ZSTDMT_compressStream_generic(*(_QWORD *)(a1 + 3320), a2, a3, 0);
          v25 = a3[2];
          v26 = *(_QWORD *)(a1 + 456);
          *(_QWORD *)(a1 + 448) += v25 - v22;
          v27 = a2[2];
          *(_QWORD *)(a1 + 456) = v27 - v23 + v26;
          if (v24 > 0xFFFFFFFFFFFFFF88)
            break;
          v28 = v25 == v22 && v27 == v23;
          if (!v28 || v22 == a3[1] || v23 == a2[1])
          {
LABEL_55:
            if (*(_DWORD *)(a1 + 308) == 1)
            {
              v35 = *(_OWORD *)a3;
              *(_QWORD *)(a1 + 3232) = a3[2];
              *(_OWORD *)(a1 + 3216) = v35;
            }
            if (*(_DWORD *)(a1 + 312) == 1)
              *(_QWORD *)(a1 + 3240) = a2[1] - a2[2];
            return;
          }
        }
      }
      *(_DWORD *)(a1 + 3208) = 0;
      *(_QWORD *)(a1 + 440) = 0;
    }
  }
}

__n128 ZSTD_CCtx_init_compressStream2(uint64_t a1, int a2, uint64_t a3)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _DWORD *v11;
  unint64_t v12;
  int v13;
  const void *v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  char *CDict_advanced2;
  __n128 result;
  int v25;
  int64x2_t *CCtx_advanced;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  _BYTE v38[32];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __n128 v45;
  __int128 v46;
  uint64_t v47;
  _BYTE v48[32];
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __n128 v55;
  __int128 v56;
  uint64_t v57;

  v6 = *(_OWORD *)(a1 + 160);
  v55 = *(__n128 *)(a1 + 144);
  v56 = v6;
  v57 = *(_QWORD *)(a1 + 176);
  v7 = *(_OWORD *)(a1 + 96);
  v51 = *(_OWORD *)(a1 + 80);
  v52 = v7;
  v8 = *(_OWORD *)(a1 + 128);
  v53 = *(_OWORD *)(a1 + 112);
  v54 = v8;
  v9 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)v48 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&v48[16] = v9;
  v10 = *(_OWORD *)(a1 + 64);
  v49 = *(_OWORD *)(a1 + 48);
  v50 = v10;
  v11 = *(_DWORD **)(a1 + 3296);
  v12 = *(_QWORD *)(a1 + 3304);
  v13 = *(_DWORD *)(a1 + 3312);
  v14 = *(const void **)(a1 + 3256);
  if (v14 && !*(_QWORD *)(a1 + 3280))
  {
    v21 = *(_QWORD *)(a1 + 3264);
    v22 = *(_DWORD *)(a1 + 3272);
    *(_OWORD *)v38 = *(_OWORD *)(a1 + 552);
    *(_QWORD *)&v38[16] = *(_QWORD *)(a1 + 568);
    CDict_advanced2 = ZSTD_createCDict_advanced2(v14, v21, 1, v22, (__int128 *)(a1 + 16), (uint64_t)v38);
    *(_QWORD *)(a1 + 3280) = CDict_advanced2;
    if (!CDict_advanced2)
      return result;
    *(_QWORD *)(a1 + 3288) = CDict_advanced2;
    *(_QWORD *)(a1 + 3296) = 0;
    *(_QWORD *)(a1 + 3304) = 0;
    *(_QWORD *)(a1 + 3312) = 0;
    v15 = (uint64_t)CDict_advanced2;
  }
  else
  {
    *(_QWORD *)(a1 + 3296) = 0;
    *(_QWORD *)(a1 + 3304) = 0;
    *(_QWORD *)(a1 + 3312) = 0;
    v15 = *(_QWORD *)(a1 + 3288);
    if (!v15)
      goto LABEL_5;
  }
  HIDWORD(v49) = *(_DWORD *)(v15 + 4948);
LABEL_5:
  if (a2 == 2)
    *(_QWORD *)(a1 + 440) = a3 + 1;
  if (v11)
  {
    v16 = (_QWORD *)(a1 + 440);
    v17 = *(_QWORD *)(a1 + 440) - 1;
    if (!v15)
    {
      v20 = v12;
      goto LABEL_24;
    }
    v18 = v50;
    v19 = DWORD1(v51);
    v20 = v12;
    if (!*(_DWORD *)(v15 + 168))
    {
LABEL_13:
      if (v17 == -1 || attachDictSizeCutoffs[*(unsigned int *)(v15 + 312)] >= v17)
      {
        if (v19 == 2)
          goto LABEL_24;
      }
      else if (v19 != 1)
      {
        goto LABEL_24;
      }
      if (!v18)
        goto LABEL_23;
LABEL_24:
      v25 = 0;
      goto LABEL_25;
    }
  }
  else
  {
    if (!v15)
    {
      v20 = 0;
      v16 = (_QWORD *)(a1 + 440);
      v17 = *(_QWORD *)(a1 + 440) - 1;
      goto LABEL_24;
    }
    v20 = *(_QWORD *)(v15 + 8);
    v16 = (_QWORD *)(a1 + 440);
    v17 = *(_QWORD *)(a1 + 440) - 1;
    v18 = v50;
    v19 = DWORD1(v51);
    if (!*(_DWORD *)(v15 + 168))
      goto LABEL_13;
  }
LABEL_23:
  v25 = 1;
LABEL_25:
  ZSTD_getCParamsFromCCtxParams((int8x8_t *)v48, v17, v20, v25, (uint64_t)v38);
  *(_OWORD *)&v48[16] = *(_OWORD *)&v38[12];
  *(_OWORD *)&v48[4] = *(_OWORD *)v38;
  if (*(_DWORD *)&v38[24] >= 7u && *(_DWORD *)&v48[4] >= 0x1Bu)
    LODWORD(v53) = 1;
  if (v17 <= 0x100000)
  {
    HIDWORD(v51) = 0;
    goto LABEL_37;
  }
  if (SHIDWORD(v51) < 1)
  {
LABEL_37:
    if (ZSTD_compressBegin_internal(a1, v11, v12, v13, 0, v15, (uint64_t *)v48, v17, 1) <= 0xFFFFFFFFFFFFFF88)
    {
      result = 0uLL;
      *(_OWORD *)(a1 + 3152) = 0u;
      if (*(_DWORD *)(a1 + 308))
      {
        v32 = 0;
      }
      else
      {
        v32 = *(_QWORD *)(a1 + 432);
        if (v32 == v17)
          ++v32;
      }
      *(_QWORD *)(a1 + 3168) = v32;
      *(_OWORD *)(a1 + 3192) = 0uLL;
      result.n128_u64[0] = 1;
      *(_QWORD *)(a1 + 3208) = 1;
    }
    return result;
  }
  CCtx_advanced = *(int64x2_t **)(a1 + 3320);
  if (!CCtx_advanced)
  {
    v27 = *(_QWORD *)(a1 + 576);
    *(_OWORD *)v38 = *(_OWORD *)(a1 + 552);
    *(_QWORD *)&v38[16] = *(_QWORD *)(a1 + 568);
    CCtx_advanced = ZSTDMT_createCCtx_advanced(HIDWORD(v51), (uint64_t)v38, v27);
    *(_QWORD *)(a1 + 3320) = CCtx_advanced;
    if (!CCtx_advanced)
      return result;
    v15 = *(_QWORD *)(a1 + 3288);
  }
  v28 = *v16 - 1;
  v45 = v55;
  v46 = v56;
  v47 = v57;
  v41 = v51;
  v42 = v52;
  v43 = v53;
  v44 = v54;
  *(_OWORD *)v38 = *(_OWORD *)v48;
  *(_OWORD *)&v38[16] = *(_OWORD *)&v48[16];
  v39 = v49;
  v40 = v50;
  result.n128_u64[0] = ZSTDMT_initCStream_internal((uint64_t)CCtx_advanced, v11, v12, v13, v15, (uint64_t)v38, v28).n128_u64[0];
  if (v29 <= 0xFFFFFFFFFFFFFF88)
  {
    v30 = *(_QWORD *)(a1 + 3288);
    if (v30)
    {
      v31 = *(_DWORD *)(v30 + 4944);
      v12 = *(_QWORD *)(v30 + 8);
    }
    else
    {
      v31 = 0;
    }
    v33 = v49;
    *(_OWORD *)(a1 + 232) = v50;
    v34 = v52;
    *(_OWORD *)(a1 + 248) = v51;
    v35 = *(_OWORD *)&v48[16];
    *(_OWORD *)(a1 + 184) = *(_OWORD *)v48;
    *(_OWORD *)(a1 + 200) = v35;
    *(_OWORD *)(a1 + 216) = v33;
    result = v55;
    v36 = v56;
    v37 = v53;
    *(_OWORD *)(a1 + 296) = v54;
    *(__n128 *)(a1 + 312) = result;
    *(_OWORD *)(a1 + 328) = v36;
    *(_DWORD *)(a1 + 352) = v31;
    *(_QWORD *)(a1 + 360) = v12;
    *(_DWORD *)(a1 + 3208) = 1;
    *(_QWORD *)(a1 + 344) = v57;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 456) = 0;
    *(_OWORD *)(a1 + 264) = v34;
    *(_OWORD *)(a1 + 280) = v37;
  }
  return result;
}

double ZSTDMT_updateCParams_whileCompressing(uint64_t a1, int8x8_t *a2)
{
  int v3;
  double result;
  _BYTE v5[28];

  v3 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 84) = a2[5].i32[1];
  memset(&v5[4], 0, 24);
  ZSTD_getCParamsFromCCtxParams(a2, -1, 0, 0, (uint64_t)v5);
  *(_DWORD *)v5 = v3;
  *(_OWORD *)(a1 + 56) = *(_OWORD *)&v5[12];
  result = *(double *)v5;
  *(_OWORD *)(a1 + 44) = *(_OWORD *)v5;
  return result;
}

uint64_t ZSTDMT_compressStream_generic(uint64_t a1, _QWORD *a2, uint64_t *a3, int a4)
{
  int v4;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  size_t v22;
  _QWORD *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  char *v27;
  char *v28;
  unint64_t v29;
  BOOL v30;
  BOOL v31;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  unint64_t v39;
  BOOL v40;
  uint64_t v41;
  size_t v42;
  size_t v43;
  BOOL v44;
  BOOL v45;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  BOOL v52;
  size_t v53;
  BOOL v54;
  BOOL v55;
  uint64_t v56;
  size_t v57;
  unint64_t v58;
  unsigned __int8 *v59;
  uint64_t v60;
  unint64_t v61;
  size_t v62;
  unsigned __int8 *v63;
  uint64_t v64;
  uint64_t v65;
  _BOOL4 v66;
  int v68;
  int v69;
  unint64_t v70;
  BOOL v71;
  unsigned int v72;
  int v73;
  _BOOL4 v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  pthread_mutex_t *v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t (**v81)(uint64_t);
  int v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t *v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _DWORD *v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int i;
  unsigned int v96;
  uint64_t j;
  uint64_t v98;
  uint64_t v99;
  size_t v100;
  unint64_t v101;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  _BOOL4 v121;
  _QWORD *v122;
  uint64_t v123;
  __int32 v124;
  int8x16_t *v125;
  unint64_t v126;
  uint64_t v127;
  _BYTE *Buffer;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  void (*v132)(_QWORD, void *);
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unsigned __int8 *v137;
  unsigned int v138;
  size_t v140;
  unsigned __int8 *v141;
  int v142;
  _BOOL8 v143;
  size_t v144;

  v4 = a4;
  if (!a4 && *(_DWORD *)(a1 + 2956))
    return -60;
  if (*(_DWORD *)(a1 + 224))
    goto LABEL_97;
  v9 = a3[1];
  v10 = a3[2];
  if (v9 <= v10)
    goto LABEL_97;
  v11 = *(_QWORD *)(a1 + 248);
  if (v11)
    goto LABEL_90;
  v12 = *(_DWORD *)(a1 + 2948);
  v13 = *(_DWORD *)(a1 + 2952);
  if (v12 >= v13)
  {
LABEL_11:
    v19 = 0;
    v20 = 0;
    v21 = *(_QWORD *)(a1 + 288);
    v22 = *(_QWORD *)(a1 + 208);
    if (*(_QWORD *)(a1 + 280) - v21 >= v22)
      goto LABEL_53;
  }
  else
  {
    v14 = *(_QWORD *)(a1 + 8);
    while (1)
    {
      v15 = *(_DWORD *)(a1 + 2944) & v12;
      pthread_mutex_lock((pthread_mutex_t *)(v14 + 424 * v15 + 16));
      v16 = *(_QWORD *)(a1 + 8) + 424 * v15;
      v17 = *(_QWORD *)v16;
      pthread_mutex_unlock((pthread_mutex_t *)(v16 + 16));
      v14 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(v14 + 424 * v15 + 200);
      if (v17 < v18)
        break;
      if (v13 == ++v12)
        goto LABEL_11;
    }
    v23 = (_QWORD *)(v14 + 424 * v15);
    v24 = v23 + 22;
    v25 = v23[23];
    v26 = v23 + 24;
    if (v25)
      v19 = v25;
    else
      v19 = v18;
    if (v25)
      v26 = v24;
    v20 = *v26;
    v21 = *(_QWORD *)(a1 + 288);
    v22 = *(_QWORD *)(a1 + 208);
    if (*(_QWORD *)(a1 + 280) - v21 >= v22)
      goto LABEL_53;
  }
  v27 = *(char **)(a1 + 272);
  v21 = *(_QWORD *)(a1 + 240);
  if (v20 && v27 && v19 && v21 && v20 + v19 > (unint64_t)v27 && (unint64_t)&v27[v21] > v20)
    goto LABEL_59;
  if (*(_DWORD *)(a1 + 136))
  {
    v144 = v22;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 2776));
    if (v27 && v21)
    {
      v28 = &v27[v21];
      while (1)
      {
        v33 = *(_QWORD *)(a1 + 2888);
        v34 = *(_QWORD *)(a1 + 2896);
        v35 = *(_QWORD *)(a1 + 2904);
        v36 = *(unsigned int *)(a1 + 2912);
        v37 = *(unsigned int *)(a1 + 2916);
        v38 = !v35 || (_DWORD)v36 == (_DWORD)v37;
        if (v38
          || ((v39 = v35 + v37, v39 + (v36 - v37) > (unint64_t)v27)
            ? (v40 = (unint64_t)v28 > v39)
            : (v40 = 0),
              !v40))
        {
          v29 = v34 + v36;
          v30 = !v34 || v33 == v29;
          v31 = !v30 && v33 > (unint64_t)v27;
          if (!v31 || (unint64_t)v28 <= v29)
            break;
        }
        pthread_cond_wait((pthread_cond_t *)(a1 + 2840), (pthread_mutex_t *)(a1 + 2776));
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2776));
    v22 = v144;
  }
  memmove(v27, *(const void **)(a1 + 232), v21);
  *(_QWORD *)(a1 + 232) = v27;
  *(_QWORD *)(a1 + 288) = v21;
LABEL_53:
  v41 = *(_QWORD *)(a1 + 272);
  v11 = v41 + v21;
  if (v20 && v41 && v19 && v22 && v20 + v19 > v11 && v11 + v22 > v20)
  {
LABEL_59:
    v11 = *(_QWORD *)(a1 + 248);
    goto LABEL_88;
  }
  if (*(_DWORD *)(a1 + 136))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 2776));
    if (v11 && v22)
    {
      v42 = v11 + v22;
      while (1)
      {
        v47 = *(_QWORD *)(a1 + 2888);
        v48 = *(_QWORD *)(a1 + 2896);
        v49 = *(_QWORD *)(a1 + 2904);
        v50 = *(unsigned int *)(a1 + 2912);
        v51 = *(unsigned int *)(a1 + 2916);
        v52 = !v49 || (_DWORD)v50 == (_DWORD)v51;
        if (v52 || ((v53 = v49 + v51, v53 + (v50 - v51) > v11) ? (v54 = v42 > v53) : (v54 = 0), !v54))
        {
          v43 = v48 + v50;
          v44 = !v48 || v47 == v43;
          v45 = !v44 && v47 > v11;
          if (!v45 || v42 <= v43)
            break;
        }
        pthread_cond_wait((pthread_cond_t *)(a1 + 2840), (pthread_mutex_t *)(a1 + 2776));
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 2776));
  }
  *(_QWORD *)(a1 + 248) = v11;
  *(_QWORD *)(a1 + 256) = v22;
  *(_QWORD *)(a1 + 264) = 0;
LABEL_88:
  if (!v11)
  {
LABEL_97:
    v66 = 1;
    goto LABEL_98;
  }
  v9 = a3[1];
  v10 = a3[2];
LABEL_90:
  v55 = 0;
  v56 = *a3;
  v57 = v9 - v10;
  v58 = *(_QWORD *)(a1 + 264);
  if (v57 >= *(_QWORD *)(a1 + 208) - v58)
    v57 = *(_QWORD *)(a1 + 208) - v58;
  if (!*(_DWORD *)(a1 + 132) || v57 + v58 < 0x20)
  {
LABEL_209:
    v62 = v57;
    goto LABEL_210;
  }
  v59 = (unsigned __int8 *)(v56 + v10);
  v60 = *(_QWORD *)(a1 + 2928);
  v61 = v58 - 32;
  if (v58 < 0x20)
  {
    v63 = (unsigned __int8 *)(v58 + v11 - 32);
    if (v58)
    {
      v133 = 0;
      v65 = 0;
      do
        v65 = *(unsigned __int8 *)(v11 + v133++) - 0x30E44323485A9B9DLL * v65 + 10;
      while (v58 != v133);
    }
    else
    {
      v65 = 0;
    }
    v62 = 32 - v58;
    v137 = v59;
    do
    {
      v138 = *v137++;
      v65 = v138 - 0x30E44323485A9B9DLL * v65 + 10;
    }
    while (!__CFADD__(v61++, 1));
LABEL_201:
    if (v62 <= v57)
      v140 = v57;
    else
      v140 = v62;
    while (1)
    {
      v55 = v140 != v62;
      if (v140 == v62)
        goto LABEL_209;
      v141 = &v63[v62];
      if (v62 >= 0x20)
        v141 = &v59[v62 - 32];
      v65 = v59[v62++] - 0x30E44323485A9B9DLL * (v65 - (*v141 + 10) * *(_QWORD *)(a1 + 2936)) + 10;
      if ((v60 & ~v65) == 0)
        goto LABEL_208;
    }
  }
  v62 = 0;
  v63 = (unsigned __int8 *)(v11 + v58 - 32);
  v64 = *(unsigned __int8 *)(v11 + v58 - 15)
      - 0x30E44323485A9B9DLL
      * (*(unsigned __int8 *)(v11 + v58 - 16)
       - 0x30E44323485A9B9DLL
       * (*(unsigned __int8 *)(v11 + v58 - 17)
        - 0x30E44323485A9B9DLL
        * (*(unsigned __int8 *)(v11 + v58 - 18)
         - 0x30E44323485A9B9DLL
         * (*(unsigned __int8 *)(v11 + v58 - 19)
          - 0x30E44323485A9B9DLL
          * (*(unsigned __int8 *)(v11 + v58 - 20)
           - 0x30E44323485A9B9DLL
           * (*(unsigned __int8 *)(v11 + v58 - 21)
            - 0x30E44323485A9B9DLL
            * (*(unsigned __int8 *)(v11 + v58 - 22)
             - 0x30E44323485A9B9DLL
             * (*(unsigned __int8 *)(v11 + v58 - 23)
              - 0x30E44323485A9B9DLL
              * (*(unsigned __int8 *)(v11 + v58 - 24)
               - 0x30E44323485A9B9DLL
               * (*(unsigned __int8 *)(v11 + v58 - 25)
                - 0x30E44323485A9B9DLL
                * (*(unsigned __int8 *)(v11 + v58 - 26)
                 - 0x30E44323485A9B9DLL
                 * (*(unsigned __int8 *)(v11 + v58 - 27)
                  - 0x30E44323485A9B9DLL
                  * (*(unsigned __int8 *)(v11 + v58 - 28)
                   - 0x30E44323485A9B9DLL
                   * (*(unsigned __int8 *)(v11 + v58 - 29)
                    - 0x30E44323485A9B9DLL
                    * (*(unsigned __int8 *)(v11 + v58 - 30)
                     - 0x30E44323485A9B9DLL
                     * (*(unsigned __int8 *)(v11 + v58 - 31) - 0x30E44323485A9B9DLL * *v63 + 0x1715609F2C75EBE8)
                     + 10)
                    + 10)
                   + 10)
                  + 10)
                 + 10)
                + 10)
               + 10)
              + 10)
             + 10)
            + 10)
           + 10)
          + 10)
         + 10)
        + 10)
       + 10)
      + 10;
  v65 = *(unsigned __int8 *)(v11 + v58 - 1)
      - 0x30E44323485A9B9DLL
      * (*(unsigned __int8 *)(v11 + v58 - 2)
       - 0x30E44323485A9B9DLL
       * (*(unsigned __int8 *)(v11 + v58 - 3)
        - 0x30E44323485A9B9DLL
        * (*(unsigned __int8 *)(v11 + v58 - 4)
         - 0x30E44323485A9B9DLL
         * (*(unsigned __int8 *)(v11 + v58 - 5)
          - 0x30E44323485A9B9DLL
          * (*(unsigned __int8 *)(v11 + v58 - 6)
           - 0x30E44323485A9B9DLL
           * (*(unsigned __int8 *)(v11 + v58 - 7)
            - 0x30E44323485A9B9DLL
            * (*(unsigned __int8 *)(v11 + v58 - 8)
             - 0x30E44323485A9B9DLL
             * (*(unsigned __int8 *)(v11 + v58 - 9)
              - 0x30E44323485A9B9DLL
              * (*(unsigned __int8 *)(v11 + v58 - 10)
               - 0x30E44323485A9B9DLL
               * (*(unsigned __int8 *)(v11 + v58 - 11)
                - 0x30E44323485A9B9DLL
                * (*(unsigned __int8 *)(v11 + v58 - 12)
                 - 0x30E44323485A9B9DLL
                 * (*(unsigned __int8 *)(v11 + v58 - 13)
                  - 0x30E44323485A9B9DLL * (*(unsigned __int8 *)(v11 + v58 - 14) - 0x30E44323485A9B9DLL * v64 + 10)
                  + 10)
                 + 10)
                + 10)
               + 10)
              + 10)
             + 10)
            + 10)
           + 10)
          + 10)
         + 10)
        + 10)
       + 10)
      + 10;
  if ((v60 & ~v65) != 0)
    goto LABEL_201;
LABEL_208:
  v55 = 1;
LABEL_210:
  if (v4 == 0 && v55)
    v4 = 1;
  memcpy((void *)(v11 + v58), (const void *)(v56 + a3[2]), v62);
  a3[2] += v62;
  *(_QWORD *)(a1 + 264) += v62;
  v66 = v62 == 0;
LABEL_98:
  if (a3[2] < (unint64_t)a3[1] && v4 == 2)
    v68 = 1;
  else
    v68 = v4;
  v69 = *(_DWORD *)(a1 + 224);
  v70 = *(_QWORD *)(a1 + 264);
  if (v69
    || v70 >= *(_QWORD *)(a1 + 208)
    || (v68 ? (v71 = v70 == 0) : (v71 = 1), !v71 || v68 == 2 && !*(_DWORD *)(a1 + 2956)))
  {
    v72 = *(_DWORD *)(a1 + 2952);
    v73 = *(_DWORD *)(a1 + 2944);
    v74 = v68 == 2;
    if (v72 <= *(_DWORD *)(a1 + 2948) + v73)
    {
      v75 = v73 & v72;
      if (v69)
      {
        v76 = *(_QWORD *)(a1 + 8);
        goto LABEL_116;
      }
      v109 = 0;
      v110 = *(_QWORD *)(a1 + 248);
      v111 = *(_QWORD *)(a1 + 8) + 424 * v75;
      *(_QWORD *)(v111 + 192) = v110;
      *(_QWORD *)(v111 + 200) = v70;
      *(_OWORD *)(v111 + 176) = *(_OWORD *)(a1 + 232);
      v112 = *(_QWORD *)(a1 + 8) + 424 * v75;
      *(_QWORD *)v112 = 0;
      *(_QWORD *)(v112 + 8) = 0;
      v113 = *(_OWORD *)(a1 + 40);
      v114 = *(_OWORD *)(a1 + 72);
      *(_OWORD *)(v112 + 240) = *(_OWORD *)(a1 + 56);
      *(_OWORD *)(v112 + 256) = v114;
      *(_OWORD *)(v112 + 224) = v113;
      v115 = *(_OWORD *)(a1 + 88);
      v116 = *(_OWORD *)(a1 + 104);
      v117 = *(_OWORD *)(a1 + 136);
      *(_OWORD *)(v112 + 304) = *(_OWORD *)(a1 + 120);
      *(_OWORD *)(v112 + 320) = v117;
      *(_OWORD *)(v112 + 272) = v115;
      *(_OWORD *)(v112 + 288) = v116;
      v118 = *(_OWORD *)(a1 + 152);
      v119 = *(_OWORD *)(a1 + 168);
      v120 = *(_OWORD *)(a1 + 184);
      *(_QWORD *)(v112 + 384) = *(_QWORD *)(a1 + 200);
      *(_OWORD *)(v112 + 352) = v119;
      *(_OWORD *)(v112 + 368) = v120;
      *(_OWORD *)(v112 + 336) = v118;
      if (!*(_DWORD *)(a1 + 2952))
        v109 = *(_QWORD *)(a1 + 3024);
      v121 = v68 == 2;
      v122 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 424 * v75);
      v123 = *(_QWORD *)(a1 + 2968);
      v122[20] = 0;
      v122[21] = 0;
      v124 = *(_DWORD *)(a1 + 2952);
      if (!*(_DWORD *)(a1 + 76))
        v121 = 0;
      if (!v124)
        v121 = 0;
      v122[49] = v109;
      v122[50] = v123;
      v76 = *(_QWORD *)(a1 + 8);
      v125 = (int8x16_t *)(v76 + 424 * v75);
      v125[8] = vextq_s8(*(int8x16_t *)(a1 + 16), *(int8x16_t *)(a1 + 16), 8uLL);
      v125[9].i64[0] = *(_QWORD *)(a1 + 32);
      v125[9].i64[1] = a1 + 296;
      v125[13].i32[0] = v124;
      v125[13].i32[1] = v124 == 0;
      v125[13].i32[2] = v74;
      v125[26].i32[0] = v121;
      v125[25].i64[1] = 0;
      *(_QWORD *)(a1 + 288) += v70;
      *(_QWORD *)(a1 + 256) = 0;
      *(_QWORD *)(a1 + 264) = 0;
      *(_QWORD *)(a1 + 248) = 0;
      if (v68 == 2)
      {
        *(_QWORD *)(a1 + 232) = 0;
        *(_QWORD *)(a1 + 240) = 0;
        *(_DWORD *)(a1 + 2956) = v74;
        if (v124)
        {
          if (!v70)
          {
LABEL_170:
            v127 = v76 + 424 * v75;
            Buffer = ZSTDMT_getBuffer(v125[8].i64[1]);
            *(_QWORD *)(v127 + 160) = Buffer;
            *(_QWORD *)(v127 + 168) = v129;
            if (Buffer)
            {
              v130 = v76 + 424 * v75;
              *(_QWORD *)(v130 + 192) = 0;
              *(_QWORD *)(v130 + 200) = 0;
              if (v129 >= 3)
              {
                *(_WORD *)Buffer = 1;
                Buffer[2] = 0;
                v131 = 3;
              }
              else
              {
                v131 = -70;
              }
            }
            else
            {
              v131 = -64;
            }
            *(_QWORD *)(v76 + 424 * v75 + 8) = v131;
            ++*(_DWORD *)(a1 + 2952);
            goto LABEL_126;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 76) = 0;
        }
      }
      else
      {
        v126 = *(_QWORD *)(a1 + 216);
        if (v126 >= v70)
          v126 = v70;
        *(_QWORD *)(a1 + 232) = v110 + v70 - v126;
        *(_QWORD *)(a1 + 240) = v126;
        if (!v70 && v124)
          goto LABEL_170;
      }
LABEL_116:
      v77 = *(_QWORD *)a1;
      v78 = (pthread_mutex_t *)(*(_QWORD *)a1 + 96);
      pthread_mutex_lock(v78);
      v79 = *(_QWORD *)(v77 + 72);
      if (v79 < 2)
      {
        if (*(_QWORD *)(v77 + 80) == *(_QWORD *)(v77 + 40) || !*(_DWORD *)(v77 + 88))
          goto LABEL_124;
      }
      else if (*(_QWORD *)(v77 + 56) == (*(_QWORD *)(v77 + 64) + 1) % v79)
      {
LABEL_124:
        pthread_mutex_unlock(v78);
        v82 = 1;
LABEL_125:
        *(_DWORD *)(a1 + 224) = v82;
        goto LABEL_126;
      }
      if (!*(_DWORD *)(v77 + 256))
      {
        *(_DWORD *)(v77 + 88) = 0;
        v80 = *(_QWORD *)(v77 + 64);
        v81 = (uint64_t (**)(uint64_t))(*(_QWORD *)(v77 + 48) + 16 * v80);
        *v81 = ZSTDMT_compressionJob;
        v81[1] = (uint64_t (*)(uint64_t))(v76 + 424 * v75);
        *(_QWORD *)(v77 + 64) = (v80 + 1) % v79;
        pthread_cond_signal((pthread_cond_t *)(v77 + 208));
      }
      pthread_mutex_unlock(v78);
      v82 = 0;
      ++*(_DWORD *)(a1 + 2952);
      goto LABEL_125;
    }
  }
LABEL_126:
  v83 = *(_DWORD *)(a1 + 2944) & *(_DWORD *)(a1 + 2948);
  pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 8) + 424 * v83 + 16));
  if (v66)
  {
    v84 = *(_QWORD *)(a1 + 8);
    if (*(_DWORD *)(a1 + 2948) < *(_DWORD *)(a1 + 2952)
      && *(_QWORD *)(v84 + 424 * v83 + 408) == *(_QWORD *)(v84 + 424 * v83 + 8))
    {
      do
      {
        if (*(_QWORD *)(v84 + 424 * v83) == *(_QWORD *)(v84 + 424 * v83 + 200))
          break;
        pthread_cond_wait((pthread_cond_t *)(v84 + 424 * v83 + 80), (pthread_mutex_t *)(v84 + 424 * v83 + 16));
        v84 = *(_QWORD *)(a1 + 8);
      }
      while (*(_QWORD *)(v84 + 424 * v83 + 408) == *(_QWORD *)(v84 + 424 * v83 + 8));
    }
  }
  else
  {
    v84 = *(_QWORD *)(a1 + 8);
  }
  v85 = (uint64_t *)(v84 + 424 * v83);
  v87 = *v85;
  v86 = v85[1];
  v88 = v85[25];
  pthread_mutex_unlock((pthread_mutex_t *)(v85 + 2));
  if (v86 >= 0xFFFFFFFFFFFFFF89)
  {
    for (i = *(_DWORD *)(a1 + 2948); i < *(_DWORD *)(a1 + 2952); *(_DWORD *)(a1 + 2948) = i)
    {
      v96 = *(_DWORD *)(a1 + 2944) & i;
      pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 8) + 424 * v96 + 16));
      for (j = *(_QWORD *)(a1 + 8);
            *(_QWORD *)(j + 424 * v96) < *(_QWORD *)(j + 424 * v96 + 200);
            j = *(_QWORD *)(a1 + 8))
      {
        pthread_cond_wait((pthread_cond_t *)(j + 424 * v96 + 80), (pthread_mutex_t *)(j + 424 * v96 + 16));
      }
      pthread_mutex_unlock((pthread_mutex_t *)(j + 424 * v96 + 16));
      i = *(_DWORD *)(a1 + 2948) + 1;
    }
    ZSTDMT_releaseAllJobResources(a1);
    goto LABEL_189;
  }
  v89 = *(_QWORD *)(a1 + 8);
  if (v87 == v88)
  {
    v90 = v89 + 424 * v83;
    if (*(_DWORD *)(v90 + 416))
    {
      v91 = (_DWORD *)(v90 + 416);
      v92 = ZSTD_XXH64_digest((uint64_t *)(a1 + 2680));
      v93 = v89 + 424 * v83;
      v94 = *(_QWORD *)(v93 + 8);
      *(_DWORD *)(*(_QWORD *)(v93 + 160) + v94) = v92;
      v86 += 4;
      *(_QWORD *)(v93 + 8) = v94 + 4;
      *v91 = 0;
      goto LABEL_143;
    }
  }
  if (v86)
  {
LABEL_143:
    v98 = *(_QWORD *)(v89 + 424 * v83 + 408);
    v99 = a2[2];
    if (v86 - v98 >= a2[1] - v99)
      v100 = a2[1] - v99;
    else
      v100 = v86 - v98;
    if (v100)
    {
      memcpy((void *)(*a2 + v99), (const void *)(*(_QWORD *)(v89 + 424 * v83 + 160) + v98), v100);
      v99 = a2[2];
      v89 = *(_QWORD *)(a1 + 8);
      v98 = *(_QWORD *)(v89 + 424 * v83 + 408);
    }
    a2[2] = v99 + v100;
    v101 = v98 + v100;
    *(_QWORD *)(v89 + 424 * v83 + 408) = v101;
    if (v87 == v88 && v101 == v86)
    {
      v103 = v89 + 424 * v83;
      v104 = *(void **)(v103 + 160);
      if (v104)
      {
        v105 = *(_QWORD *)(a1 + 16);
        v106 = *(_QWORD *)(v103 + 168);
        pthread_mutex_lock((pthread_mutex_t *)v105);
        v107 = *(unsigned int *)(v105 + 76);
        if (v107 >= *(_DWORD *)(v105 + 72))
        {
          pthread_mutex_unlock((pthread_mutex_t *)v105);
          v132 = *(void (**)(_QWORD, void *))(v105 + 88);
          if (v132)
            v132(*(_QWORD *)(v105 + 96), v104);
          else
            free(v104);
        }
        else
        {
          *(_DWORD *)(v105 + 76) = v107 + 1;
          v108 = v105 + 16 * v107;
          *(_QWORD *)(v108 + 104) = v104;
          *(_QWORD *)(v108 + 112) = v106;
          pthread_mutex_unlock((pthread_mutex_t *)v105);
        }
      }
      v134 = *(_QWORD *)(a1 + 8) + 424 * v83;
      *(_QWORD *)(v134 + 160) = 0;
      *(_QWORD *)(v134 + 168) = 0;
      v135 = *(_QWORD *)(a1 + 8) + 424 * v83;
      *(_QWORD *)(v135 + 8) = 0;
      *(_QWORD *)(a1 + 2976) += v87;
      *(_QWORD *)(a1 + 2984) += v86;
      ++*(_DWORD *)(a1 + 2948);
      v101 = *(_QWORD *)(v135 + 408);
    }
    v31 = v86 > v101;
    v86 -= v101;
    if (v31)
      goto LABEL_189;
  }
  if (v88 > v87 || *(_DWORD *)(a1 + 2948) < *(_DWORD *)(a1 + 2952) || *(_DWORD *)(a1 + 224) || *(_QWORD *)(a1 + 264))
  {
    v86 = 1;
  }
  else
  {
    v142 = *(_DWORD *)(a1 + 2956);
    *(_DWORD *)(a1 + 2960) = v142;
    v143 = v142 == 0;
    v86 = v68 == 2 && v143;
  }
LABEL_189:
  if (v86 <= 1)
    v136 = 1;
  else
    v136 = v86;
  if (a3[2] >= (unint64_t)a3[1])
    return v86;
  else
    return v136;
}

unint64_t ZSTD_compressStream_generic(int32x2_t *a1, uint64_t *a2, uint64_t *a3, int a4)
{
  int v4;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  int32x2_t *v11;
  __int32 v12;
  int32x2_t v13;
  int32x2_t v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int32x2_t v21;
  size_t v22;
  int32x2_t v23;
  int v24;
  size_t v25;
  unint64_t v26;
  _BYTE *v27;
  BOOL v28;
  _BOOL4 v29;
  char *v30;
  char *v31;
  unint64_t result;
  int32x2_t v33;
  int32x2_t v34;
  int32x2_t v35;
  int32x2_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v40;

  v4 = a4;
  v40 = (char *)(*a3 + a3[1]);
  v38 = *a3;
  v8 = (char *)(*a3 + a3[2]);
  v9 = *a2 + a2[1];
  v37 = *a2;
  v10 = (_BYTE *)(*a2 + a2[2]);
  v11 = a1 + 399;
  while (2)
  {
    v12 = a1[401].i32[0];
    while (1)
    {
      if (!v12)
        return -62;
      if (v12 == 1)
        break;
      if (v12 == 2)
      {
        v13 = a1[399];
        v14 = a1[400];
        v15 = *(_QWORD *)&v13 - *(_QWORD *)&v14;
        v16 = v9 - (_QWORD)v10;
        if ((unint64_t)(v9 - (_QWORD)v10) >= *(_QWORD *)&v13 - *(_QWORD *)&v14)
          v17 = *(_QWORD *)&v13 - *(_QWORD *)&v14;
        else
          v17 = v9 - (_QWORD)v10;
        if (v17)
          goto LABEL_10;
        goto LABEL_11;
      }
    }
    if (v4 == 2)
    {
      v18 = v9 - (_QWORD)v10;
      v19 = (unint64_t)(0x20000 - (v40 - v8)) >> 11;
      if ((unint64_t)(v40 - v8) >= 0x20000)
        v19 = 0;
      if ((v18 >= v40 - v8 + ((unint64_t)(v40 - v8) >> 8) + v19 || a1[39].i32[0] == 1) && !*(_QWORD *)&a1[395])
      {
        result = ZSTD_compressEnd((int *)a1, v10, v18, v8, v40 - v8);
        if (result > 0xFFFFFFFFFFFFFF88)
          return result;
        v10 += result;
        a1[401].i32[1] = 1;
        v8 = v40;
        goto LABEL_73;
      }
    }
    if (a1[38].i32[1])
    {
      v20 = v9 - (_QWORD)v10;
    }
    else
    {
      v21 = a1[395];
      if (*(_QWORD *)&a1[396] - *(_QWORD *)&v21 >= (unint64_t)(v40 - v8))
        v22 = v40 - v8;
      else
        v22 = *(_QWORD *)&a1[396] - *(_QWORD *)&v21;
      if (v22)
      {
        memcpy((void *)(*(_QWORD *)&a1[392] + *(_QWORD *)&v21), v8, v22);
        v21 = a1[395];
      }
      v23 = (int32x2_t)(*(_QWORD *)&v21 + v22);
      a1[395] = v23;
      v8 += v22;
      if (v4 == 1)
      {
        if (*(_QWORD *)&v23 == *(_QWORD *)&a1[394])
          goto LABEL_74;
      }
      else if (!v4 && *(_QWORD *)&v23 < *(_QWORD *)&a1[396])
      {
        goto LABEL_74;
      }
      v20 = v9 - (_QWORD)v10;
      if (!a1[38].i32[1])
      {
        v25 = *(_QWORD *)&v23 - *(_QWORD *)&a1[394];
        v24 = 1;
        goto LABEL_36;
      }
    }
    v24 = 0;
    if ((unint64_t)(v40 - v8) >= *(_QWORD *)&a1[54])
      v25 = (size_t)a1[54];
    else
      v25 = v40 - v8;
LABEL_36:
    v26 = (0x20000 - v25) >> 11;
    if (v25 >= 0x20000)
      v26 = 0;
    if (v20 >= v25 + (v25 >> 8) + v26)
    {
      v27 = v10;
      if (v24)
        goto LABEL_42;
LABEL_52:
      v31 = &v8[v25];
      v29 = &v8[v25] == v40;
      if (&v8[v25] == v40)
      {
        result = ZSTD_compressEnd((int *)a1, v27, v20, v8, v25);
        if (result > 0xFFFFFFFFFFFFFF88)
          return result;
      }
      else
      {
        result = ZSTD_compressContinue_internal(a1, v27, v20, v8, v25, 1, 0);
        if (result > 0xFFFFFFFFFFFFFF88)
          return result;
      }
      a1[401].i32[1] = v29;
      v8 = v31;
      v4 = a4;
      if (v27 != v10)
        goto LABEL_59;
      goto LABEL_66;
    }
    v27 = v10;
    if (a1[39].i32[0] != 1)
    {
      v27 = (_BYTE *)a1[397];
      v20 = (unint64_t)a1[398];
    }
    if (!v24)
      goto LABEL_52;
LABEL_42:
    v28 = v4 == 2 && v8 == v40;
    v29 = v28;
    v30 = (char *)(*(_QWORD *)&a1[392] + *(_QWORD *)&a1[394]);
    if (v28)
      result = ZSTD_compressEnd((int *)a1, v27, v20, v30, v25);
    else
      result = ZSTD_compressContinue_internal(a1, v27, v20, v30, v25, 1, 0);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      a1[401].i32[1] = v29;
      v33 = a1[395];
      v34 = a1[54];
      a1[396] = (int32x2_t)(*(_QWORD *)&v34 + *(_QWORD *)&v33);
      if (*(_QWORD *)&v34 + *(_QWORD *)&v33 > *(_QWORD *)&a1[393])
      {
        v33 = 0;
        a1[395] = 0;
        a1[396] = v34;
      }
      a1[394] = v33;
      if (v27 != v10)
      {
LABEL_59:
        v14 = 0;
        a1[399] = (int32x2_t)result;
        a1[400] = 0;
        a1[401].i32[0] = 2;
        v15 = result;
        v16 = v9 - (_QWORD)v10;
        if (v9 - (uint64_t)v10 >= result)
          v17 = result;
        else
          v17 = v9 - (_QWORD)v10;
        if (v17)
        {
LABEL_10:
          memcpy(v10, (const void *)(*(_QWORD *)&a1[397] + *(_QWORD *)&v14), v17);
          v14 = a1[400];
        }
LABEL_11:
        v10 += v17;
        a1[400] = (int32x2_t)(*(_QWORD *)&v14 + v17);
        if (v15 > v16)
        {
LABEL_74:
          a3[2] = (uint64_t)&v8[-v38];
          a2[2] = (uint64_t)&v10[-v37];
          if (a1[401].i32[1])
            return 0;
          v35 = a1[396];
          v36 = a1[395];
          result = *(_QWORD *)&v35 - *(_QWORD *)&v36;
          if (*(_QWORD *)&v35 == *(_QWORD *)&v36)
            return (unint64_t)a1[54];
          return result;
        }
        *v11 = 0;
        v11[1] = 0;
        if (!a1[401].i32[1])
        {
          a1[401].i32[0] = 1;
          v4 = a4;
          continue;
        }
LABEL_73:
        a1[401].i32[0] = 0;
        a1[55] = 0;
        goto LABEL_74;
      }
LABEL_66:
      v10 += result;
      if (!v29)
        continue;
      goto LABEL_73;
    }
    return result;
  }
}

void ZSTD_compressStream2_simpleArgs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t *a7, unsigned int a8)
{
  uint64_t v10[2];
  uint64_t v11;
  uint64_t v12[2];
  uint64_t v13;

  v12[0] = a2;
  v12[1] = a3;
  v13 = *a4;
  v10[0] = a5;
  v10[1] = a6;
  v11 = *a7;
  ZSTD_compressStream2(a1, v12, v10, a8);
  *a4 = v13;
  *a7 = v11;
}

uint64_t ZSTD_compressSequences(uint64_t a1, _BYTE *a2, unint64_t a3, uint64_t a4, unint64_t a5, char *a6, unint64_t a7)
{
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  int v17;
  uint64_t (*v18)(uint64_t, unsigned int *, uint64_t, unint64_t, char *, unint64_t);
  uint64_t (*v19)(uint64_t, unsigned int *, uint64_t, unint64_t, char *, uint64_t);
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  size_t v27;
  unint64_t v28;
  char v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;
  __int16 v33;
  unint64_t v34;
  int v35;
  uint64_t v37;
  _BYTE *v38;
  unint64_t v39;
  char *v40;
  unint64_t v41;
  uint64_t (*v42)(uint64_t, unsigned int *, uint64_t, unint64_t, char *, uint64_t);
  unint64_t v45;
  _QWORD v46[2];

  ZSTD_CCtx_init_compressStream2(a1, 2, a7);
  v13 = v12;
  if (v12 <= 0xFFFFFFFFFFFFFF88)
  {
    v14 = ZSTD_writeFrameHeader(a2, a3, (_DWORD *)(a1 + 184), a7, *(_DWORD *)(a1 + 352));
    v15 = &a2[v14];
    if (a7 && *(_DWORD *)(a1 + 220))
      ZSTD_XXH64_update((unsigned int *)(a1 + 464), a6, a7);
    v16 = a3 - v14;
    v46[0] = 0;
    v46[1] = 0;
    v17 = *(_DWORD *)(a1 + 316);
    v18 = ZSTD_copySequencesToSeqStoreNoBlockDelim;
    if (v17)
      v18 = 0;
    if (v17 == 1)
      v19 = ZSTD_copySequencesToSeqStoreExplicitBlockDelim;
    else
      v19 = (uint64_t (*)(uint64_t, unsigned int *, uint64_t, unint64_t, char *, uint64_t))v18;
    v42 = v19;
    if (a7)
    {
      v37 = v14;
      v38 = a2;
      v20 = 0;
      v41 = a7;
      v39 = a3 - v14;
      v40 = a6;
      v21 = a7;
      while (1)
      {
        v45 = v20;
        v22 = *(_QWORD *)(a1 + 432);
        v23 = v21 <= v22;
        if (v21 >= v22)
          v24 = *(_QWORD *)(a1 + 432);
        else
          LODWORD(v24) = v21;
        v25 = v24;
        *(_QWORD *)(a1 + 656) = *(_QWORD *)(a1 + 648);
        *(_QWORD *)(a1 + 640) = *(_QWORD *)(a1 + 632);
        *(_DWORD *)(a1 + 704) = 0;
        v26 = v42(a1, (unsigned int *)v46, a4, a5, a6, v24);
        v13 = v26;
        if (v26 > 0xFFFFFFFFFFFFFF88)
          return v13;
        v27 = v25 - v26;
        if (v25 - v26 <= 6)
        {
          v13 = v27 + 3;
          if (v27 + 3 > v16)
            return -70;
          *(_WORD *)v15 = v23 | (8 * v27);
          v15[2] = v27 >> 13;
          memcpy(v15 + 3, a6, v27);
          v20 = v13 + v45;
          goto LABEL_12;
        }
        v13 = ZSTD_entropyCompressSequences(a1 + 632, *(unsigned __int16 **)(a1 + 2872), *(char **)(a1 + 2880), (_DWORD *)(a1 + 184), (uint64_t)(v15 + 3), v16 - 3, v25 - v26, *(uint32x4_t **)(a1 + 3120));
        if (v13 > 0xFFFFFFFFFFFFFF88)
          return v13;
        if (!*(_DWORD *)(a1 + 624)
          && *(_QWORD *)(a1 + 640) - *(_QWORD *)(a1 + 632) <= 0x1FuLL
          && *(_QWORD *)(a1 + 656) - *(_QWORD *)(a1 + 648) <= 9uLL
          && ZSTD_isRLE(v40, v41)
          || v13 == 1)
        {
          if (v16 < 4)
            return -70;
          v29 = *a6;
          if (v21 > v22)
            v30 = 2;
          else
            v30 = 3;
          *(_WORD *)v15 = v30 | (8 * v27);
          v15[2] = v27 >> 13;
          v15[3] = v29;
          v13 = 4;
        }
        else
        {
          if (!v13)
          {
            v13 = v27 + 3;
            if (v27 + 3 > v16)
              return -70;
            *(_WORD *)v15 = v23 | (8 * v27);
            v15[2] = v27 >> 13;
            memcpy(v15 + 3, a6, v27);
            v28 = v45;
            if (v13 >= 0xFFFFFFFFFFFFFF89)
              return v13;
            goto LABEL_42;
          }
          v31 = *(_QWORD *)(a1 + 2872);
          v32 = *(_QWORD *)(a1 + 2880);
          *(_QWORD *)(a1 + 2872) = v32;
          *(_QWORD *)(a1 + 2880) = v31;
          if (*(_DWORD *)(v32 + 4568) == 2)
            *(_DWORD *)(v32 + 4568) = 1;
          if (v21 > v22)
            v33 = 4;
          else
            v33 = 5;
          *(_WORD *)v15 = v33 | (8 * v13);
          v15[2] = v13 >> 13;
          v13 += 3;
        }
        v28 = v45;
LABEL_42:
        v20 = v13 + v28;
        if (v21 <= v22)
        {
LABEL_46:
          v13 = v20;
          v14 = v37;
          a2 = v38;
          if (v20 > 0xFFFFFFFFFFFFFF88)
            return v13;
          goto LABEL_47;
        }
        *(_DWORD *)(a1 + 624) = 0;
LABEL_12:
        v15 += v13;
        a6 += v27;
        v16 -= v13;
        v21 -= v27;
        if (!v21)
          goto LABEL_46;
      }
    }
    if (v16 < 4)
      return -70;
    v39 = a3 - v14;
    *(_DWORD *)v15 = 1;
    v20 = 3;
LABEL_47:
    v13 = v20 + v14;
    if (*(_DWORD *)(a1 + 220))
    {
      v34 = v39 - v20;
      v35 = ZSTD_XXH64_digest((uint64_t *)(a1 + 464));
      if (v34 >= 4)
      {
        *(_DWORD *)&a2[v13] = v35;
        v13 += 4;
        return v13;
      }
      return -70;
    }
  }
  return v13;
}

uint64_t ZSTD_writeFrameHeader(_BYTE *a1, unint64_t a2, _DWORD *a3, unint64_t a4, unsigned int a5)
{
  int v5;
  int v6;
  int v7;
  int v8;
  BOOL v9;
  int v10;
  int v11;
  int v12;
  char v13;
  char v15;
  uint64_t v16;
  uint64_t v17;

  v5 = a5 > 0xFF;
  if (a5)
    ++v5;
  if ((a5 & 0xFFFF0000) != 0)
    ++v5;
  if (a3[10])
    v6 = 0;
  else
    v6 = v5;
  v7 = a3[1];
  v8 = a3[8];
  if (v8)
    v9 = 1 << v7 >= a4;
  else
    v9 = 0;
  v10 = v9;
  v11 = a4 >> 8 > 0x100;
  if (a4 > 0xFF)
    ++v11;
  if (a4 > 0xFFFFFFFE)
    ++v11;
  if (v8)
    v12 = v11;
  else
    v12 = 0;
  if (v10)
    v13 = 32;
  else
    v13 = 0;
  if (a2 < 0x12)
    return -70;
  v15 = v13 | (v6 + 4 * (a3[9] > 0)) | ((_BYTE)v12 << 6);
  if (*a3)
  {
    v16 = 0;
    v17 = 1;
    *a1 = v15;
    if ((v10 & 1) != 0)
      goto LABEL_29;
    goto LABEL_28;
  }
  *(_DWORD *)a1 = -47205080;
  v16 = 4;
  v17 = 5;
  a1[4] = v15;
  if ((v10 & 1) == 0)
  {
LABEL_28:
    a1[v17] = 8 * v7 - 80;
    v17 = v16 | 2;
  }
LABEL_29:
  if (v6 == 3)
  {
    *(_DWORD *)&a1[v17] = a5;
    v17 += 4;
    goto LABEL_37;
  }
  if (v6 == 2)
  {
    *(_WORD *)&a1[v17] = a5;
    v17 += 2;
    if (v12 != 1)
      goto LABEL_38;
LABEL_42:
    *(_WORD *)&a1[v17] = a4 - 256;
    return v17 + 2;
  }
  if (v6 != 1)
  {
LABEL_37:
    if (v12 != 1)
      goto LABEL_38;
    goto LABEL_42;
  }
  a1[v17++] = a5;
  if (v12 == 1)
    goto LABEL_42;
LABEL_38:
  if (v12 == 2)
  {
    *(_DWORD *)&a1[v17] = a4;
    return v17 + 4;
  }
  if (v12 == 3)
  {
    *(_QWORD *)&a1[v17] = a4;
    v17 += 8;
  }
  else if (v10)
  {
    a1[v17] = a4;
    return v17 + 1;
  }
  return v17;
}

unsigned int *ZSTD_XXH64_update(unsigned int *result, char *__src, size_t __n)
{
  int v3;
  char *v4;
  _QWORD *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  size_t v14;

  v3 = __n;
  v4 = __src;
  v5 = result;
  *(_QWORD *)result += __n;
  v6 = result[18];
  if (v6 + __n > 0x1F)
  {
    v7 = &__src[__n];
    if ((_DWORD)v6)
    {
      result = (unsigned int *)memcpy((char *)result + v6 + 40, __src, (32 - v6));
      v8 = __ROR8__(v5[2] - 0x3D4D51C2D82B14B1 * v5[6], 33);
      v5[1] = 0x9E3779B185EBCA87 * __ROR8__(v5[1] - 0x3D4D51C2D82B14B1 * v5[5], 33);
      v5[2] = 0x9E3779B185EBCA87 * v8;
      v9 = 0x9E3779B185EBCA87 * __ROR8__(v5[4] - 0x3D4D51C2D82B14B1 * v5[8], 33);
      v5[3] = 0x9E3779B185EBCA87 * __ROR8__(v5[3] - 0x3D4D51C2D82B14B1 * v5[7], 33);
      v5[4] = v9;
      v4 += (32 - *((_DWORD *)v5 + 18));
      *((_DWORD *)v5 + 18) = 0;
    }
    if (v4 + 32 <= v7)
    {
      v10 = v5[1];
      v11 = v5[2];
      v13 = v5[3];
      v12 = v5[4];
      do
      {
        v10 = 0x9E3779B185EBCA87 * __ROR8__(v10 - 0x3D4D51C2D82B14B1 * *(_QWORD *)v4, 33);
        v11 = 0x9E3779B185EBCA87 * __ROR8__(v11 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 1), 33);
        v13 = 0x9E3779B185EBCA87 * __ROR8__(v13 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 2), 33);
        v12 = 0x9E3779B185EBCA87 * __ROR8__(v12 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 3), 33);
        v4 += 32;
      }
      while (v4 <= v7 - 32);
      v5[1] = v10;
      v5[2] = v11;
      v5[3] = v13;
      v5[4] = v12;
      if (v4 >= v7)
        return result;
    }
    else if (v4 >= v7)
    {
      return result;
    }
    v14 = v7 - v4;
    result = (unsigned int *)memcpy(v5 + 5, v4, v14);
    *((_DWORD *)v5 + 18) = v14;
    return result;
  }
  if (__src)
  {
    result = (unsigned int *)memcpy((char *)result + v6 + 40, __src, __n);
    LODWORD(v6) = *((_DWORD *)v5 + 18);
  }
  *((_DWORD *)v5 + 18) = v6 + v3;
  return result;
}

unint64_t ZSTD_XXH64_digest(uint64_t *a1)
{
  _QWORD *v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unsigned int *v6;
  BOOL v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;

  v1 = a1 + 5;
  v2 = *((unsigned int *)a1 + 18);
  v3 = (unint64_t)a1 + v2 + 40;
  v4 = *a1;
  if ((unint64_t)*a1 < 0x20)
  {
    v5 = a1[3] + 0x27D4EB2F165667C5 + v4;
    if ((unint64_t)(a1 + 6) > v3)
    {
LABEL_5:
      v6 = (unsigned int *)(a1 + 5);
      goto LABEL_8;
    }
  }
  else
  {
    v5 = 0x85EBCA77C2B2AE63
       - 0x61C8864E7A143579
       * ((0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * ((0x85EBCA77C2B2AE63
           - 0x61C8864E7A143579
           * ((0x85EBCA77C2B2AE63
             - 0x61C8864E7A143579
             * ((__ROR8__(a1[2], 57) + __ROR8__(a1[1], 63) + __ROR8__(a1[3], 52) + __ROR8__(a1[4], 46)) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[1], 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[2], 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[3], 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[4], 33)))
       + v4;
    if ((unint64_t)(a1 + 6) > v3)
      goto LABEL_5;
  }
  do
  {
    v6 = (unsigned int *)(v1 + 1);
    v5 = 0x85EBCA77C2B2AE63
       - 0x61C8864E7A143579 * __ROR8__((0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * *v1, 33)) ^ v5, 37);
    v7 = (unint64_t)(v1 + 2) > v3;
    ++v1;
  }
  while (!v7);
LABEL_8:
  if ((unint64_t)(v6 + 1) <= v3)
    v5 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * *v6++) ^ v5, 41);
  if ((unint64_t)v6 < v3)
  {
    v8 = (char *)a1 + v2 - (char *)v6 + 40;
    do
    {
      v9 = *(unsigned __int8 *)v6;
      v6 = (unsigned int *)((char *)v6 + 1);
      v5 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v9) ^ v5, 53);
      --v8;
    }
    while (v8);
  }
  v10 = 0x165667B19E3779F9
      * ((0xC2B2AE3D27D4EB4FLL * (v5 ^ (v5 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (v5 ^ (v5 >> 33))) >> 29));
  return v10 ^ HIDWORD(v10);
}

void ZSTD_flushStream(uint64_t a1, uint64_t *a2)
{
  uint64_t v2[3];

  memset(v2, 0, sizeof(v2));
  ZSTD_compressStream2(a1, a2, v2, 1u);
}

void ZSTD_endStream(uint64_t a1, uint64_t *a2)
{
  uint64_t v2[3];

  memset(v2, 0, sizeof(v2));
  ZSTD_compressStream2(a1, a2, v2, 2u);
}

double ZSTD_getParams@<D0>(int a1@<W0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  double result;
  _BYTE v8[28];

  *(_OWORD *)v8 = 0uLL;
  if (a2)
    v6 = a2;
  else
    v6 = -1;
  *(_DWORD *)&v8[24] = 0;
  *(_QWORD *)&v8[16] = 0;
  ZSTD_getCParams_internal((uint64_t)v8, a1, v6, a3, 3);
  *(_QWORD *)(a4 + 32) = 0;
  *(_OWORD *)a4 = *(_OWORD *)v8;
  result = *(double *)&v8[12];
  *(_OWORD *)(a4 + 12) = *(_OWORD *)&v8[12];
  *(_DWORD *)(a4 + 28) = 1;
  return result;
}

unint64_t ZSTD_fillDoubleHashTable(unint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  char v11;
  char v12;
  char v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v3 = *(_QWORD *)(result + 8);
  v4 = *(unsigned int *)(result + 36);
  v5 = a2 - 8;
  if (v3 + v4 + 2 > (unint64_t)(a2 - 8))
    return result;
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_DWORD *)(result + 208);
  v8 = *(_QWORD *)(result + 64);
  v9 = *(_DWORD *)(result + 196);
  v10 = *(_DWORD *)(result + 200);
  result = 64;
  v11 = 64 - v9;
  v12 = 32 - v9;
  v13 = 64 - v10;
  if (a3)
  {
    v14 = 0;
    result = 0xCF1BBCDCBFA56300;
    v15 = v7 - 5;
    while (1)
    {
      switch(v15)
      {
        case 0:
          v17 = *(_QWORD *)(v3 + v4);
          v18 = 0xCF1BBCDCBB000000 * v17;
          goto LABEL_13;
        case 1:
          v17 = *(_QWORD *)(v3 + v4);
          v18 = 0xCF1BBCDCBF9B0000 * v17;
          goto LABEL_13;
        case 2:
          v17 = *(_QWORD *)(v3 + v4);
          v18 = 0xCF1BBCDCBFA56300 * v17;
          goto LABEL_13;
        case 3:
          v17 = *(_QWORD *)(v3 + v4);
          v18 = 0xCF1BBCDCB7A56463 * v17;
LABEL_13:
          v19 = v18 >> v11;
          break;
        default:
          v19 = (-1640531535 * *(_DWORD *)(v3 + v4)) >> v12;
          v17 = *(_QWORD *)(v3 + v4);
          break;
      }
      *(_DWORD *)(v8 + 4 * v19) = v4 + v14;
      *(_DWORD *)(v6 + 4 * ((0xCF1BBCDCB7A56463 * v17) >> v13)) = v4 + v14;
      v20 = v3 + v4;
      v21 = (0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4 + 1)) >> v13;
      if (*(_DWORD *)(v6 + 4 * v21))
      {
        v16 = (0xCF1BBCDCB7A56463 * *(_QWORD *)(v20 + 2)) >> v13;
        if (!*(_DWORD *)(v6 + 4 * v16))
          goto LABEL_16;
LABEL_6:
        v3 += 3;
        v14 += 3;
        if (v3 + v4 + 2 > v5)
          return result;
      }
      else
      {
        *(_DWORD *)(v6 + 4 * v21) = v4 + v14 + 1;
        v16 = (0xCF1BBCDCB7A56463 * *(_QWORD *)(v20 + 2)) >> v13;
        if (*(_DWORD *)(v6 + 4 * v16))
          goto LABEL_6;
LABEL_16:
        *(_DWORD *)(v6 + 4 * v16) = v4 + v14 + 2;
        v3 += 3;
        v14 += 3;
        if (v3 + v4 + 2 > v5)
          return result;
      }
    }
  }
  switch(v7)
  {
    case 5:
      do
      {
        v22 = *(_QWORD *)(v3 + v4);
        result = (0xCF1BBCDCBB000000 * v22) >> v11;
        *(_DWORD *)(v8 + 4 * result) = v4;
        *(_DWORD *)(v6 + 4 * ((0xCF1BBCDCB7A56463 * v22) >> v13)) = v4;
        v4 += 3;
      }
      while (v3 + v4 + 2 <= v5);
      break;
    case 6:
      do
      {
        v24 = *(_QWORD *)(v3 + v4);
        result = (0xCF1BBCDCBF9B0000 * v24) >> v11;
        *(_DWORD *)(v8 + 4 * result) = v4;
        *(_DWORD *)(v6 + 4 * ((0xCF1BBCDCB7A56463 * v24) >> v13)) = v4;
        v4 += 3;
      }
      while (v3 + v4 + 2 <= v5);
      break;
    case 7:
      do
      {
        v25 = *(_QWORD *)(v3 + v4);
        result = (0xCF1BBCDCBFA56300 * v25) >> v11;
        *(_DWORD *)(v8 + 4 * result) = v4;
        *(_DWORD *)(v6 + 4 * ((0xCF1BBCDCB7A56463 * v25) >> v13)) = v4;
        v4 += 3;
      }
      while (v3 + v4 + 2 <= v5);
      break;
    case 8:
      do
      {
        v23 = 0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4);
        *(_DWORD *)(v8 + 4 * (v23 >> v11)) = v4;
        *(_DWORD *)(v6 + 4 * (v23 >> v13)) = v4;
        v4 += 3;
      }
      while (v3 + v4 + 2 <= v5);
      break;
    default:
      do
      {
        result = (0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4)) >> v13;
        *(_DWORD *)(v8 + 4 * ((-1640531535 * *(_DWORD *)(v3 + v4)) >> v12)) = v4;
        *(_DWORD *)(v6 + 4 * result) = v4;
        v4 += 3;
      }
      while (v3 + v4 + 2 <= v5);
      break;
  }
  return result;
}

unint64_t ZSTD_compressBlock_doubleFast_extDict_generic(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5, int a6)
{
  unsigned __int8 *v6;
  uint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  char *v45;
  unint64_t v46;
  unsigned __int8 *v47;
  unint64_t v48;
  _OWORD *v49;
  unint64_t v50;
  unint64_t v51;
  _BYTE *v52;
  int v53;
  unint64_t v54;
  int v55;
  char *v56;
  unsigned __int8 *v57;
  unint64_t v58;
  BOOL v59;
  unint64_t v60;
  unint64_t v61;
  _OWORD *v62;
  unint64_t v63;
  _BYTE *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  char *v71;
  unsigned __int8 *v72;
  unint64_t v73;
  BOOL v74;
  unint64_t v75;
  _OWORD *v76;
  uint64_t v77;
  _OWORD *v78;
  unint64_t v79;
  __int128 *v80;
  __int128 v81;
  char *v82;
  unsigned __int8 *v83;
  int v84;
  unint64_t v85;
  unint64_t v87;
  _BYTE *v88;
  unsigned __int8 *v89;
  unsigned __int8 *v90;
  unsigned __int8 *v91;
  __int128 *v92;
  _OWORD *v93;
  __int128 v94;
  unint64_t v95;
  char *v96;
  char *v97;
  char v98;
  uint64_t v99;
  unint64_t v100;
  __int16 v101;
  unsigned __int8 *v102;
  unsigned __int8 *v103;
  unsigned __int8 *v104;
  uint64_t v105;
  _OWORD *v106;
  unint64_t v107;
  __int128 *v108;
  __int128 v109;
  __int128 *v110;
  _OWORD *v111;
  __int128 v112;
  unint64_t v113;
  unsigned __int8 *v114;
  __int128 *v115;
  _OWORD *v116;
  __int128 v117;
  unint64_t v118;
  unsigned __int8 *v119;
  uint64_t v120;
  _OWORD *v121;
  unint64_t v122;
  __int128 *v123;
  __int128 v124;
  unsigned __int8 *v125;
  unsigned __int8 *v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  __int128 *v130;
  _OWORD *v131;
  unint64_t v132;
  __int128 v133;
  uint64_t *v134;
  _QWORD *v135;
  unint64_t v136;
  uint64_t v137;
  __int128 *v138;
  _OWORD *v139;
  unint64_t v140;
  __int128 v141;
  uint64_t *v142;
  _QWORD *v143;
  unint64_t v144;
  uint64_t v145;
  __int128 *v146;
  _OWORD *v147;
  unint64_t v148;
  __int128 v149;
  uint64_t *v150;
  _QWORD *v151;
  unint64_t v152;
  uint64_t v153;
  char v154;
  unint64_t v155;
  char v156;
  unint64_t v157;
  unint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unsigned int v162;
  int v163;
  unint64_t v164;
  unint64_t v165;
  char v166;
  uint64_t v167;
  uint64_t v168;
  unsigned int v169;
  unint64_t v170;
  int v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  char *v175;
  unint64_t v176;
  unint64_t v177;
  _BOOL4 v178;
  uint64_t v179;
  unint64_t v180;
  unsigned __int8 *v181;
  _BOOL4 v182;
  int v183;
  unsigned int v184;
  unsigned __int8 *v185;
  unsigned int v186;
  unsigned __int8 *v187;
  char v188;
  char v189;
  unint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  uint64_t v194;
  unint64_t v195;
  unsigned __int8 *v196;
  unsigned __int8 *v197;
  uint64_t v198;
  unint64_t v199;
  unsigned int v200;
  unsigned int v201;
  unint64_t v202;
  uint64_t v203;
  uint64_t v204;
  int v205;
  uint64_t v206;
  uint64_t v207;
  char *v208;
  char *v209;
  unsigned __int8 *v210;
  unint64_t v211;
  unint64_t v212;
  unint64_t v213;
  _OWORD *v214;
  uint64_t v215;
  _OWORD *v216;
  unint64_t v217;
  __int128 *v218;
  __int128 v219;
  uint64_t v220;
  _QWORD *v221;
  _QWORD *v222;
  unint64_t v223;
  uint64_t v224;
  unsigned __int8 *v225;
  uint64_t v226;
  uint64_t v227;
  unint64_t v228;
  uint64_t v229;
  uint64_t v230;
  char *v231;
  _QWORD *v232;
  unint64_t v233;
  unsigned __int8 *v239;
  unsigned __int8 *v240;
  _BYTE *v241;
  uint64_t v242;
  unsigned __int8 *v243;
  _OWORD *v244;
  __int128 v245;
  unsigned __int8 *v246;
  unint64_t v247;
  unsigned __int8 *v248;
  char v249;
  unint64_t v250;
  __int16 v251;
  unint64_t v252;
  unint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  unsigned int v257;
  unsigned __int8 *v258;
  unsigned __int8 *v259;
  uint64_t v260;
  unint64_t v261;
  int v262;
  unint64_t v263;
  unint64_t v264;
  unint64_t v265;
  char *v266;
  unsigned __int8 *v267;
  unint64_t v268;
  unint64_t v269;
  unint64_t v270;
  uint64_t v271;
  unsigned __int8 *v272;
  unint64_t v273;
  unint64_t v274;
  unsigned __int8 *v275;
  unsigned __int8 *v276;
  uint64_t v277;
  unint64_t v278;
  _QWORD *v279;
  _QWORD *v280;
  unint64_t v281;
  unsigned __int8 *v282;
  unsigned __int8 *v283;
  unsigned __int8 *v284;
  unsigned __int8 *v285;
  unsigned __int8 *v286;
  unsigned __int8 *v287;
  unint64_t v288;
  unsigned __int8 *v289;
  unsigned __int8 *v290;
  uint64_t v291;
  unint64_t v292;
  unint64_t v293;
  __int128 *v294;
  _OWORD *v295;
  unint64_t v296;
  __int128 v297;
  unsigned __int8 *v298;
  _QWORD *v299;
  unint64_t v300;
  uint64_t v301;
  unsigned __int8 *v302;
  unsigned __int8 *v303;
  uint64_t v304;
  unint64_t v305;
  unint64_t v306;
  char *v307;
  unsigned __int8 *v308;
  char *v309;
  uint64_t v310;
  _OWORD *v311;
  unint64_t v312;
  __int128 *v313;
  __int128 v314;
  unsigned __int8 *v315;
  char *v316;
  __int128 v317;
  char *v318;
  unint64_t v319;
  unsigned __int8 *v320;
  unint64_t v321;
  unsigned __int8 *v322;
  unsigned __int8 *v323;
  unsigned __int8 *v324;
  __int128 *v325;
  char *v326;
  unint64_t v327;
  __int128 v328;
  unsigned __int8 *v329;
  char *v330;
  unint64_t v331;
  uint64_t v332;
  unsigned __int8 *v333;
  unsigned __int8 *v334;
  uint64_t v335;
  unint64_t v336;
  char v337;
  unint64_t v338;
  unsigned int v339;
  uint64_t v341;
  unsigned int v342;
  unsigned int *v343;
  unsigned int *v344;
  unsigned __int8 *v345;
  char v346;
  unint64_t v347;
  uint64_t v348;
  char v349;
  int v350;
  int v351;
  int v353;
  unint64_t v354;
  uint64_t v355;
  char *v356;
  unsigned int v357;
  unsigned __int8 *v358;
  uint64_t v359;
  int v360;
  uint64_t v361;
  uint64_t v362;
  unsigned int v363;
  char v364;
  char v365;
  unint64_t v366;
  uint64_t v367;
  uint64_t v368;

  v6 = a4;
  v8 = *(_QWORD *)(a1 + 48);
  v10 = *(_DWORD *)(a1 + 196);
  v9 = *(_DWORD *)(a1 + 200);
  v367 = *(_QWORD *)(a1 + 64);
  v11 = (unint64_t)&a4[a5];
  v12 = (unint64_t)&a4[a5 - 8];
  v13 = *(_QWORD *)(a1 + 8);
  v14 = (_DWORD)a4 + a5 - v13;
  v16 = *(_DWORD *)(a1 + 28);
  v15 = *(_DWORD *)(a1 + 32);
  v17 = 1 << *(_DWORD *)(a1 + 192);
  v18 = *(_DWORD *)(a1 + 24);
  v19 = v14 - v17;
  if (v14 - v16 > v17 && v15 == 0)
    v21 = v19;
  else
    v21 = v16;
  if (v18 <= v21)
    v22 = v21;
  else
    v22 = v18;
  v23 = *a3;
  v24 = a3[1];
  v347 = v11;
  v348 = *(_QWORD *)(a1 + 48);
  v366 = v12;
  v368 = *(_QWORD *)(a1 + 8);
  if (v21 >= v18)
  {
    v178 = v15 == 0;
    if (v178 && v14 - v18 > v17)
      v179 = v19;
    else
      v179 = v18;
    v363 = v179;
    v180 = v13 + v179;
    if ((_DWORD)v6 == (_DWORD)v180)
      v181 = v6 + 1;
    else
      v181 = v6;
    v182 = (_DWORD)v181 - (_DWORD)v13 - v18 > v17;
    v183 = (_DWORD)v181 - v13 - v17;
    if (!v178 || !v182)
      v183 = *(_DWORD *)(a1 + 24);
    v184 = (_DWORD)v181 - v13 - v183;
    if (v24 <= v184)
      v185 = (unsigned __int8 *)v24;
    else
      v185 = 0;
    if (v24 <= v184)
      v186 = 0;
    else
      v186 = a3[1];
    if (v23 <= v184)
    {
      v187 = (unsigned __int8 *)v23;
    }
    else
    {
      v186 = *a3;
      v187 = 0;
    }
    if ((unint64_t)v181 >= v12)
      goto LABEL_497;
    v357 = v186;
    v344 = a3;
    v188 = 64 - v9;
    v189 = 64 - v10;
    v365 = 32 - v10;
    v190 = v11 - 7;
    v191 = v11 - 3;
    v192 = v11 - 1;
    v193 = v11 - 32;
    v355 = v13 + 12;
    v359 = v13 + 16;
    v361 = v13 - 1;
    v194 = *(_QWORD *)(a1 + 64);
    while (1)
    {
      v196 = v185;
      v197 = v187;
      v198 = *(_QWORD *)v181;
      v199 = 0xCF1BBCDCB7A56463 * *(_QWORD *)v181;
      v200 = a6 - 5;
      switch(a6)
      {
        case 5:
          v201 = -1157627904;
          goto LABEL_258;
        case 6:
          v201 = -1080360960;
          goto LABEL_258;
        case 7:
          v201 = -1079680256;
LABEL_258:
          v202 = (v198 * (v201 | 0xCF1BBCDC00000000)) >> v189;
          break;
        case 8:
          v202 = v199 >> v189;
          break;
        default:
          v202 = (-1640531535 * v198) >> v365;
          break;
      }
      v203 = 4 * (v199 >> v188);
      v204 = *(unsigned int *)(v8 + v203);
      v205 = (_DWORD)v181 - v368;
      v206 = 4 * v202;
      v207 = *(unsigned int *)(v194 + 4 * v202);
      *(_DWORD *)(v194 + v206) = (_DWORD)v181 - v368;
      *(_DWORD *)(v8 + v203) = (_DWORD)v181 - v368;
      v208 = (char *)(v181 + 1);
      if (!(_DWORD)v197)
        break;
      v194 = v367;
      if (*(_DWORD *)&v208[-v197] != *(_DWORD *)(v181 + 1))
        break;
      v209 = (char *)(v181 + 5);
      v210 = &v181[-v197 + 5];
      if (v190 <= (unint64_t)(v181 + 5))
      {
        v239 = v181 + 5;
        if ((unint64_t)v209 >= v191)
          goto LABEL_287;
LABEL_285:
        if (*(_DWORD *)v210 == *(_DWORD *)v239)
        {
          v239 += 4;
          v210 += 4;
        }
LABEL_287:
        if ((unint64_t)v239 >= v192)
        {
          if ((unint64_t)v239 >= v11)
            goto LABEL_295;
        }
        else
        {
          if (*(unsigned __int16 *)v210 == *(unsigned __int16 *)v239)
          {
            v239 += 2;
            v210 += 2;
          }
          if ((unint64_t)v239 >= v11)
          {
LABEL_295:
            v212 = v239 - (unsigned __int8 *)v209;
            v213 = v208 - (char *)v6;
            v214 = *(_OWORD **)(a2 + 24);
            if ((unint64_t)v208 <= v193)
              goto LABEL_265;
LABEL_296:
            if ((unint64_t)v6 <= v193)
            {
              v241 = (char *)v214 + v193 - (_QWORD)v6;
              v243 = v6;
              v244 = v214;
              do
              {
                v245 = *(_OWORD *)v243;
                v243 += 16;
                *v244++ = v245;
              }
              while (v244 < (_OWORD *)v241);
              v240 = (unsigned __int8 *)v193;
              if (v193 < (unint64_t)v208)
                goto LABEL_303;
            }
            else
            {
              v240 = v6;
              v241 = v214;
              if (v6 >= (unsigned __int8 *)v208)
                goto LABEL_310;
LABEL_303:
              if ((unint64_t)v6 <= v193)
                v246 = (unsigned __int8 *)v193;
              else
                v246 = v6;
              v247 = v181 - v246 + 1;
              if (v247 < 8 || (unint64_t)((char *)v214 - (char *)v6) < 0x20)
              {
                v248 = v240;
                goto LABEL_309;
              }
              if (v247 >= 0x20)
              {
                v288 = v247 & 0xFFFFFFFFFFFFFFE0;
                v294 = (__int128 *)(v240 + 16);
                v295 = (_OWORD *)((char *)v214 + v246 - v6 + 16);
                v296 = v247 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  v297 = *v294;
                  *(v295 - 1) = *(v294 - 1);
                  *v295 = v297;
                  v294 += 2;
                  v295 += 2;
                  v296 -= 32;
                }
                while (v296);
                if (v247 != v288)
                {
                  if ((v247 & 0x18) == 0)
                  {
                    v248 = &v240[v288];
                    v241 += v288;
                    goto LABEL_309;
                  }
                  goto LABEL_419;
                }
              }
              else
              {
                v288 = 0;
LABEL_419:
                v241 += v247 & 0xFFFFFFFFFFFFFFF8;
                v248 = &v240[v247 & 0xFFFFFFFFFFFFFFF8];
                v298 = &v240[v288];
                v299 = (_QWORD *)((char *)v214 + &v246[v288] - v6);
                v300 = v288 - (v247 & 0xFFFFFFFFFFFFFFF8);
                do
                {
                  v301 = *(_QWORD *)v298;
                  v298 += 8;
                  *v299++ = v301;
                  v300 += 8;
                }
                while (v300);
                if (v247 != (v247 & 0xFFFFFFFFFFFFFFF8))
                {
                  do
                  {
LABEL_309:
                    v249 = *v248++;
                    *v241++ = v249;
                  }
                  while (v248 != &v240[v247]);
                }
              }
            }
LABEL_310:
            *(_QWORD *)(a2 + 24) += v213;
            v242 = *(_QWORD *)(a2 + 8);
            if (v213 >= 0x10000)
            {
              v250 = (unint64_t)(v242 - *(_QWORD *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v250;
            }
            v11 = v347;
            v194 = v367;
            goto LABEL_313;
          }
        }
        if (*v210 == *v239)
          ++v239;
        goto LABEL_295;
      }
      v211 = *(_QWORD *)v209 ^ *(_QWORD *)v210;
      if (v211)
      {
        v212 = __clz(__rbit64(v211)) >> 3;
        v213 = v208 - (char *)v6;
        v214 = *(_OWORD **)(a2 + 24);
        if ((unint64_t)v208 <= v193)
          goto LABEL_265;
        goto LABEL_296;
      }
      v258 = v181 + 13;
      do
      {
        v259 = &v258[v211];
        if ((unint64_t)&v258[v211] >= v190)
        {
          v239 = &v181[v211 + 13];
          v210 = &v239[-v197];
          v194 = v367;
          if ((unint64_t)v239 >= v191)
            goto LABEL_287;
          goto LABEL_285;
        }
        v260 = *(_QWORD *)&v181[v211 + 13 - v197];
        v211 += 8;
        v261 = *(_QWORD *)v259 ^ v260;
      }
      while (!v261);
      v212 = v211 + (__clz(__rbit64(v261)) >> 3);
      v194 = v367;
      v213 = v208 - (char *)v6;
      v214 = *(_OWORD **)(a2 + 24);
      if ((unint64_t)v208 > v193)
        goto LABEL_296;
LABEL_265:
      *v214 = *(_OWORD *)v6;
      v215 = *(_QWORD *)(a2 + 24);
      if (v213 > 0x10)
      {
        v216 = (_OWORD *)(v215 + 16);
        v217 = v215 + v213;
        v218 = (__int128 *)(v6 + 16);
        do
        {
          v219 = *v218++;
          *v216++ = v219;
        }
        while ((unint64_t)v216 < v217);
        goto LABEL_310;
      }
      *(_QWORD *)(a2 + 24) = v215 + v213;
      v242 = *(_QWORD *)(a2 + 8);
LABEL_313:
      v224 = v212 + 4;
      v251 = v212 + 1;
      *(_WORD *)(v242 + 4) = v213;
      *(_DWORD *)v242 = 1;
      v252 = (v212 + 1) >> 16;
      v225 = v197;
      if (v252)
      {
LABEL_314:
        v253 = (unint64_t)(v242 - *(_QWORD *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v253;
        v197 = v225;
      }
LABEL_315:
      *(_WORD *)(v242 + 6) = v251;
      v254 = v242 + 8;
      *(_QWORD *)(a2 + 8) = v242 + 8;
      v6 = (unsigned __int8 *)&v208[v224];
      if ((unint64_t)&v208[v224] > v366)
      {
        v185 = v196;
        v187 = v197;
        v181 = v6;
        v8 = v348;
LABEL_251:
        v195 = v366;
        goto LABEL_252;
      }
      v255 = (v205 + 2);
      v256 = *(_QWORD *)(v368 + v255);
      v8 = v348;
      *(_DWORD *)(v348 + 4 * ((0xCF1BBCDCB7A56463 * v256) >> v188)) = v255;
      *(_DWORD *)(v348 + 4 * ((0xCF1BBCDCB7A56463 * *(_QWORD *)(v6 - 2)) >> v188)) = (_DWORD)v6 - 2 - v368;
      switch(a6)
      {
        case 5:
          v257 = -1157627904;
          goto LABEL_326;
        case 6:
          v257 = -1080360960;
          goto LABEL_326;
        case 7:
          v257 = -1079680256;
LABEL_326:
          v264 = v257 | 0xCF1BBCDC00000000;
          *(_DWORD *)(v194 + 4 * ((v256 * v264) >> v189)) = v255;
          v262 = (_DWORD)v6 - 1;
          v265 = *(_QWORD *)(v6 - 1) * v264;
          goto LABEL_328;
        case 8:
          *(_DWORD *)(v194 + 4 * ((0xCF1BBCDCB7A56463 * v256) >> v189)) = v255;
          v262 = (_DWORD)v6 - 1;
          v265 = 0xCF1BBCDCB7A56463 * *(_QWORD *)(v6 - 1);
LABEL_328:
          v263 = v265 >> v189;
          break;
        default:
          *(_DWORD *)(v194 + 4 * ((-1640531535 * *(_DWORD *)(v368 + v255)) >> v365)) = v255;
          v262 = (_DWORD)v6 - 1;
          v263 = (-1640531535 * *(_DWORD *)(v6 - 1)) >> v365;
          break;
      }
      v195 = v366;
      *(_DWORD *)(v194 + 4 * v263) = v262 - v368;
      while (1)
      {
        v187 = v196;
        v196 = v197;
        if (!(_DWORD)v187 || *(_DWORD *)v6 != *(_DWORD *)&v6[-v187])
          break;
        v266 = (char *)(v6 + 4);
        v267 = &v6[-v187 + 4];
        if (v190 <= (unint64_t)(v6 + 4))
        {
          v272 = v6 + 4;
          if ((unint64_t)v266 >= v191)
            goto LABEL_340;
LABEL_338:
          if (*(_DWORD *)v267 == *(_DWORD *)v272)
          {
            v272 += 4;
            v267 += 4;
          }
LABEL_340:
          if ((unint64_t)v272 >= v192)
          {
            if ((unint64_t)v272 < v11)
              goto LABEL_346;
          }
          else
          {
            if (*(unsigned __int16 *)v267 == *(unsigned __int16 *)v272)
            {
              v272 += 2;
              v267 += 2;
            }
            if ((unint64_t)v272 >= v11)
              goto LABEL_348;
LABEL_346:
            if (*v267 == *v272)
              ++v272;
          }
LABEL_348:
          v269 = v272 - (unsigned __int8 *)v266;
          goto LABEL_349;
        }
        v268 = *(_QWORD *)v266 ^ *(_QWORD *)v267;
        if (v268)
        {
          v269 = __clz(__rbit64(v268)) >> 3;
          if (v200 > 3)
            goto LABEL_336;
          goto LABEL_349;
        }
        v275 = v6 + 12;
        do
        {
          v276 = &v275[v268];
          if ((unint64_t)&v275[v268] >= v190)
          {
            v272 = &v6[v268 + 12];
            v267 = &v272[-v187];
            v194 = v367;
            if ((unint64_t)v272 >= v191)
              goto LABEL_340;
            goto LABEL_338;
          }
          v277 = *(_QWORD *)&v6[v268 + 12 - v187];
          v268 += 8;
          v278 = *(_QWORD *)v276 ^ v277;
        }
        while (!v278);
        v269 = v268 + (__clz(__rbit64(v278)) >> 3);
        v194 = v367;
        if (v200 > 3)
        {
LABEL_336:
          v270 = (-1640531535 * *(_DWORD *)v6) >> v365;
          v271 = *(_QWORD *)v6;
          goto LABEL_355;
        }
LABEL_349:
        switch(a6)
        {
          case 5:
            v271 = *(_QWORD *)v6;
            v273 = 0xCF1BBCDCBB000000 * *(_QWORD *)v6;
            break;
          case 6:
            v271 = *(_QWORD *)v6;
            v273 = 0xCF1BBCDCBF9B0000 * *(_QWORD *)v6;
            break;
          case 7:
            v271 = *(_QWORD *)v6;
            v273 = 0xCF1BBCDCBFA56300 * *(_QWORD *)v6;
            break;
          case 8:
            v271 = *(_QWORD *)v6;
            v273 = 0xCF1BBCDCB7A56463 * *(_QWORD *)v6;
            break;
          default:
            goto LABEL_336;
        }
        v270 = v273 >> v189;
LABEL_355:
        *(_DWORD *)(v194 + 4 * v270) = (_DWORD)v6 - v368;
        *(_DWORD *)(v348 + 4 * ((0xCF1BBCDCB7A56463 * v271) >> v188)) = (_DWORD)v6 - v368;
        if ((unint64_t)v6 <= v193)
        {
          *(_OWORD *)*(_QWORD *)(a2 + 24) = *(_OWORD *)v6;
          v254 = *(_QWORD *)(a2 + 8);
        }
        *(_WORD *)(v254 + 4) = 0;
        *(_DWORD *)v254 = 1;
        if (v269 + 1 >= 0x10000)
        {
          v274 = (unint64_t)(v254 - *(_QWORD *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v274;
        }
        *(_WORD *)(v254 + 6) = v269 + 1;
        v254 += 8;
        v6 += v269 + 4;
        *(_QWORD *)(a2 + 8) = v254;
        v197 = v187;
        v185 = v196;
        v181 = v6;
        if ((unint64_t)v6 > v366)
          goto LABEL_252;
      }
      v185 = v187;
      v187 = v197;
      v181 = v6;
LABEL_252:
      if ((unint64_t)v181 >= v195)
      {
        a3 = v344;
        v186 = v357;
LABEL_497:
        if ((_DWORD)v187)
          v339 = v187;
        else
          v339 = v186;
        *a3 = v339;
        if ((_DWORD)v185)
          LODWORD(v24) = (_DWORD)v185;
        else
          LODWORD(v24) = v186;
        goto LABEL_503;
      }
    }
    if (v204 > v363)
    {
      v220 = v368 + v204;
      if (*(_QWORD *)(v368 + v204) == v198)
      {
        v221 = v181 + 8;
        v222 = (_QWORD *)(v220 + 8);
        if (v190 <= (unint64_t)(v181 + 8))
        {
          v282 = v181 + 8;
          if ((unint64_t)v221 >= v191)
            goto LABEL_374;
        }
        else
        {
          v223 = *v221 ^ *v222;
          if (v223)
          {
            v194 = v367;
            v224 = (__clz(__rbit64(v223)) >> 3) + 8;
            v225 = &v181[-v220];
            if (v181 <= v6)
              goto LABEL_427;
            goto LABEL_383;
          }
          v289 = v181 + 16;
          while (1)
          {
            v290 = &v289[v223];
            if ((unint64_t)&v289[v223] >= v190)
              break;
            v291 = *(_QWORD *)(v359 + v204 + v223);
            v223 += 8;
            v292 = *(_QWORD *)v290 ^ v291;
            if (v292)
            {
              v293 = __clz(__rbit64(v292));
              v194 = v367;
              v224 = v223 + (v293 >> 3) + 8;
              v225 = &v181[-v220];
              if (v181 <= v6)
              {
LABEL_427:
                v208 = (char *)v181;
                goto LABEL_428;
              }
LABEL_383:
              v283 = v181 - 1;
              v284 = (unsigned __int8 *)(v361 + v204);
              while (*v283 == *v284)
              {
                ++v224;
                v285 = v283 - 1;
                if ((unint64_t)v284 > v180)
                {
                  --v284;
                  v59 = v283-- > v6;
                  if (v59)
                    continue;
                }
                goto LABEL_406;
              }
LABEL_407:
              v208 = (char *)(v283 + 1);
              goto LABEL_428;
            }
          }
          v282 = &v181[v223 + 16];
          v222 = (_QWORD *)(v359 + v204 + v223);
          if ((unint64_t)v282 >= v191)
          {
LABEL_374:
            if ((unint64_t)v282 >= v192)
            {
              if ((unint64_t)v282 >= v11)
                goto LABEL_382;
            }
            else
            {
              if (*(unsigned __int16 *)v222 == *(unsigned __int16 *)v282)
              {
                v282 += 2;
                v222 = (_QWORD *)((char *)v222 + 2);
              }
              if ((unint64_t)v282 >= v11)
              {
LABEL_382:
                v194 = v367;
                v224 = v282 - v181;
                v225 = &v181[-v220];
                if (v181 <= v6)
                  goto LABEL_427;
                goto LABEL_383;
              }
            }
            if (*(unsigned __int8 *)v222 == *v282)
              ++v282;
            goto LABEL_382;
          }
        }
        if (*(_DWORD *)v222 == *(_DWORD *)v282)
        {
          v282 += 4;
          v222 = (_QWORD *)((char *)v222 + 4);
        }
        goto LABEL_374;
      }
    }
    if (v207 <= v363 || (v226 = v368 + v207, *(_DWORD *)(v368 + v207) != *(_DWORD *)v181))
    {
      _X8 = &v181[(v181 - v6) >> 8];
      v181 = _X8 + 1;
      _X8 += 257;
      __asm { PRFM            #0, [X8] }
      v185 = v196;
      v187 = v197;
      goto LABEL_251;
    }
    v227 = *(_QWORD *)v208;
    v228 = 4 * ((0xCF1BBCDCB7A56463 * *(_QWORD *)v208) >> v188);
    v229 = *(unsigned int *)(v8 + v228);
    *(_DWORD *)(v8 + v228) = v205 + 1;
    if (v229 > v363)
    {
      v230 = v368 + v229;
      if (*(_QWORD *)(v368 + v229) == v227)
      {
        v231 = (char *)(v181 + 9);
        v232 = (_QWORD *)(v230 + 8);
        if (v190 <= (unint64_t)(v181 + 9))
        {
          v322 = v181 + 9;
          if ((unint64_t)v231 >= v191)
            goto LABEL_454;
        }
        else
        {
          v233 = *(_QWORD *)v231 ^ *v232;
          if (v233)
          {
            v224 = (__clz(__rbit64(v233)) >> 3) + 8;
            v225 = (unsigned __int8 *)&v208[-v230];
            if (v208 <= (char *)v6)
              goto LABEL_428;
            goto LABEL_463;
          }
          v333 = v181 + 17;
          while (1)
          {
            v334 = &v333[v233];
            if ((unint64_t)&v333[v233] >= v190)
              break;
            v335 = *(_QWORD *)(v359 + v229 + v233);
            v233 += 8;
            v336 = *(_QWORD *)v334 ^ v335;
            v194 = v367;
            if (v336)
            {
              v224 = v233 + (__clz(__rbit64(v336)) >> 3) + 8;
              v225 = (unsigned __int8 *)&v208[-v230];
              if (v208 <= (char *)v6)
                goto LABEL_428;
              goto LABEL_463;
            }
          }
          v322 = &v181[v233 + 17];
          v232 = (_QWORD *)(v359 + v229 + v233);
          if ((unint64_t)v322 >= v191)
          {
LABEL_454:
            if ((unint64_t)v322 >= v192)
            {
              if ((unint64_t)v322 >= v11)
                goto LABEL_462;
            }
            else
            {
              if (*(unsigned __int16 *)v232 == *(unsigned __int16 *)v322)
              {
                v322 += 2;
                v232 = (_QWORD *)((char *)v232 + 2);
              }
              if ((unint64_t)v322 >= v11)
              {
LABEL_462:
                v224 = v322 - (unsigned __int8 *)v231 + 8;
                v225 = (unsigned __int8 *)&v208[-v230];
                if (v208 <= (char *)v6)
                  goto LABEL_428;
LABEL_463:
                v323 = (unsigned __int8 *)(v361 + v229);
                while (*v181 == *v323)
                {
                  ++v224;
                  v324 = v181 - 1;
                  if (v181 > v6)
                  {
                    --v181;
                    v59 = (unint64_t)v323-- > v180;
                    if (v59)
                      continue;
                  }
                  v208 = (char *)(v324 + 1);
                  goto LABEL_428;
                }
                v208 = (char *)(v181 + 1);
LABEL_428:
                v306 = v208 - (char *)v6;
                v307 = *(char **)(a2 + 24);
                if ((unint64_t)v208 <= v193)
                {
                  *(_OWORD *)v307 = *(_OWORD *)v6;
                  v310 = *(_QWORD *)(a2 + 24);
                  if (v306 <= 0x10)
                  {
                    *(_QWORD *)(a2 + 24) = v310 + v306;
                    v242 = *(_QWORD *)(a2 + 8);
                    goto LABEL_492;
                  }
                  v311 = (_OWORD *)(v310 + 16);
                  v312 = v310 + v306;
                  v313 = (__int128 *)(v6 + 16);
                  do
                  {
                    v314 = *v313++;
                    *v311++ = v314;
                  }
                  while ((unint64_t)v311 < v312);
LABEL_489:
                  *(_QWORD *)(a2 + 24) += v306;
                  v242 = *(_QWORD *)(a2 + 8);
                  if (v306 >= 0x10000)
                  {
                    v338 = (unint64_t)(v242 - *(_QWORD *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 1;
                    *(_DWORD *)(a2 + 76) = v338;
                  }
                  v11 = v347;
                  v194 = v367;
LABEL_492:
                  v251 = v224 - 3;
                  *(_WORD *)(v242 + 4) = v306;
                  *(_DWORD *)v242 = (_DWORD)v225 + 3;
                  v196 = v197;
                  v197 = v225;
                  if ((unint64_t)(v224 - 3) >= 0x10000)
                    goto LABEL_314;
                  goto LABEL_315;
                }
                if ((unint64_t)v6 <= v193)
                {
                  v309 = &v307[v193 - (_QWORD)v6];
                  v315 = v6;
                  v316 = *(char **)(a2 + 24);
                  do
                  {
                    v317 = *(_OWORD *)v315;
                    v315 += 16;
                    *(_OWORD *)v316 = v317;
                    v316 += 16;
                  }
                  while (v316 < v309);
                  v308 = (unsigned __int8 *)v193;
                  if (v193 >= (unint64_t)v208)
                    goto LABEL_489;
                }
                else
                {
                  v308 = v6;
                  v309 = *(char **)(a2 + 24);
                  if (v6 >= (unsigned __int8 *)v208)
                    goto LABEL_489;
                }
                if ((unint64_t)v6 <= v193)
                  v318 = (char *)v193;
                else
                  v318 = (char *)v6;
                v319 = v208 - v318;
                if ((unint64_t)(v208 - v318) < 8)
                {
                  v320 = v308;
                  goto LABEL_488;
                }
                if ((unint64_t)(v307 - (char *)v6) < 0x20)
                {
                  v320 = v308;
                  goto LABEL_488;
                }
                if (v319 >= 0x20)
                {
                  v321 = v319 & 0xFFFFFFFFFFFFFFE0;
                  v325 = (__int128 *)(v308 + 16);
                  v326 = &v307[v318 - (char *)v6 + 16];
                  v327 = v319 & 0xFFFFFFFFFFFFFFE0;
                  do
                  {
                    v328 = *v325;
                    *((_OWORD *)v326 - 1) = *(v325 - 1);
                    *(_OWORD *)v326 = v328;
                    v325 += 2;
                    v326 += 32;
                    v327 -= 32;
                  }
                  while (v327);
                  if (v319 == v321)
                    goto LABEL_489;
                  if ((v319 & 0x18) == 0)
                  {
                    v320 = &v308[v321];
                    v309 += v321;
                    do
                    {
LABEL_488:
                      v337 = *v320++;
                      *v309++ = v337;
                    }
                    while (v320 < (unsigned __int8 *)v208);
                    goto LABEL_489;
                  }
                }
                else
                {
                  v321 = 0;
                }
                v309 += v319 & 0xFFFFFFFFFFFFFFF8;
                v320 = &v308[v319 & 0xFFFFFFFFFFFFFFF8];
                v329 = &v308[v321];
                v330 = &v307[&v318[v321] - (char *)v6];
                v331 = v321 - (v319 & 0xFFFFFFFFFFFFFFF8);
                do
                {
                  v332 = *(_QWORD *)v329;
                  v329 += 8;
                  *(_QWORD *)v330 = v332;
                  v330 += 8;
                  v331 += 8;
                }
                while (v331);
                if (v319 == (v319 & 0xFFFFFFFFFFFFFFF8))
                  goto LABEL_489;
                goto LABEL_488;
              }
            }
            if (*(unsigned __int8 *)v232 == *v322)
              ++v322;
            goto LABEL_462;
          }
        }
        if (*(_DWORD *)v232 == *(_DWORD *)v322)
        {
          v322 += 4;
          v232 = (_QWORD *)((char *)v232 + 4);
        }
        goto LABEL_454;
      }
    }
    v279 = v181 + 4;
    v280 = (_QWORD *)(v226 + 4);
    if (v190 <= (unint64_t)(v181 + 4))
    {
      v286 = v181 + 4;
      if ((unint64_t)v279 >= v191)
        goto LABEL_393;
    }
    else
    {
      v281 = *v279 ^ *v280;
      if (v281)
      {
        v194 = v367;
        v224 = (__clz(__rbit64(v281)) >> 3) + 4;
        v225 = &v181[-v226];
        if (v181 <= v6)
          goto LABEL_427;
LABEL_402:
        v283 = v181 - 1;
        v287 = (unsigned __int8 *)(v361 + v207);
        while (*v283 == *v287)
        {
          ++v224;
          v285 = v283 - 1;
          if ((unint64_t)v287 > v180)
          {
            --v287;
            v59 = v283-- > v6;
            if (v59)
              continue;
          }
LABEL_406:
          v208 = (char *)(v285 + 1);
          goto LABEL_428;
        }
        goto LABEL_407;
      }
      v302 = v181 + 12;
      while (1)
      {
        v303 = &v302[v281];
        if ((unint64_t)&v302[v281] >= v190)
          break;
        v304 = *(_QWORD *)(v355 + v207 + v281);
        v281 += 8;
        v305 = *(_QWORD *)v303 ^ v304;
        if (v305)
        {
          v194 = v367;
          v224 = v281 + (__clz(__rbit64(v305)) >> 3) + 4;
          v225 = &v181[-v226];
          if (v181 <= v6)
            goto LABEL_427;
          goto LABEL_402;
        }
      }
      v286 = &v181[v281 + 12];
      v280 = (_QWORD *)(v355 + v207 + v281);
      if ((unint64_t)v286 >= v191)
      {
LABEL_393:
        if ((unint64_t)v286 >= v192)
        {
          if ((unint64_t)v286 >= v11)
            goto LABEL_401;
        }
        else
        {
          if (*(unsigned __int16 *)v280 == *(unsigned __int16 *)v286)
          {
            v286 += 2;
            v280 = (_QWORD *)((char *)v280 + 2);
          }
          if ((unint64_t)v286 >= v11)
          {
LABEL_401:
            v194 = v367;
            v224 = v286 - v181;
            v225 = &v181[-v226];
            if (v181 <= v6)
              goto LABEL_427;
            goto LABEL_402;
          }
        }
        if (*(unsigned __int8 *)v280 == *v286)
          ++v286;
        goto LABEL_401;
      }
    }
    if (*(_DWORD *)v280 == *(_DWORD *)v286)
    {
      v286 += 4;
      v280 = (_QWORD *)((char *)v280 + 4);
    }
    goto LABEL_393;
  }
  if (v12 <= (unint64_t)v6)
    goto LABEL_495;
  v358 = (unsigned __int8 *)(v13 + v22);
  v25 = *(_QWORD *)(a1 + 16);
  v343 = a3;
  v345 = (unsigned __int8 *)(v25 + v21);
  v362 = v25;
  v356 = (char *)(v25 + v22);
  v349 = 64 - v10;
  v346 = 32 - v10;
  v364 = 64 - v9;
  v360 = v22 - 1;
  v354 = v11 - 32;
  v26 = a6 - 5;
  v27 = (unint64_t)v6;
  v28 = *(_QWORD *)(a1 + 64);
  v351 = v22;
  v353 = v21;
  v350 = a6 - 5;
  do
  {
    v29 = v24;
    switch(v26)
    {
      case 0:
        v30 = *(_QWORD *)v6;
        v31 = -1157627904;
        goto LABEL_21;
      case 1:
        v30 = *(_QWORD *)v6;
        v31 = -1080360960;
        goto LABEL_21;
      case 2:
        v30 = *(_QWORD *)v6;
        v31 = -1079680256;
        goto LABEL_21;
      case 3:
        v30 = *(_QWORD *)v6;
        v31 = -1213897629;
LABEL_21:
        v32 = (v30 * (v31 | 0xCF1BBCDC00000000)) >> v349;
        break;
      default:
        v32 = (-1640531535 * *(_DWORD *)v6) >> v346;
        v30 = *(_QWORD *)v6;
        break;
    }
    v33 = 4 * v32;
    v34 = *(unsigned int *)(v28 + 4 * v32);
    if (v34 >= v22)
      v35 = v13;
    else
      v35 = v362;
    v36 = 4 * ((0xCF1BBCDCB7A56463 * v30) >> v364);
    v37 = *(unsigned int *)(v8 + v36);
    v38 = v13;
    if (v37 < v22)
      v13 = v362;
    v39 = (_DWORD)v6 - v38;
    v40 = (_DWORD)v6 - v38 + 1;
    v41 = (v40 - v23);
    if (v41 < v22)
      v38 = v362;
    *(_DWORD *)(v8 + v36) = v39;
    *(_DWORD *)(v28 + v33) = v39;
    if (v41 <= v21
      || (v360 - v41) < 3
      || (v42 = v38 + v41, *(_DWORD *)v42 != *(_DWORD *)(v6 + 1)))
    {
      if (v37 > v21)
      {
        v54 = v13 + v37;
        if (*(_QWORD *)(v13 + v37) == v30)
        {
          v55 = v39;
          v29 = v23;
          v11 = v347;
          if (v37 >= v22)
            v56 = (char *)v347;
          else
            v56 = v356;
          if (v37 >= v22)
            v57 = v358;
          else
            v57 = v345;
          v58 = ZSTD_count_2segments((_QWORD *)v6 + 1, (char *)(v54 + 8), v347, v56, v358) + 8;
          v59 = v54 > (unint64_t)v57 && (unint64_t)v6 > v27;
          if (v59)
          {
            v89 = v6 - 1;
            v90 = (unsigned __int8 *)(v13 + v37 - 1);
            v8 = v348;
            v28 = v367;
            v13 = v368;
            LODWORD(v22) = v351;
            LODWORD(v21) = v353;
            v60 = v354;
            v26 = v350;
            v53 = v55;
            while (*v89 == *v90)
            {
              ++v58;
              v91 = v89 - 1;
              if (v90 > v57)
              {
                --v90;
                v59 = (unint64_t)v89-- > v27;
                if (v59)
                  continue;
              }
              v6 = v91 + 1;
              v47 = v6;
              v61 = (unint64_t)&v91[-v27 + 1];
              v62 = *(_OWORD **)(a2 + 24);
              if ((unint64_t)v6 <= v354)
                goto LABEL_120;
              goto LABEL_52;
            }
            v6 = v89 + 1;
            v47 = v6;
            v61 = (unint64_t)&v89[-v27 + 1];
            v62 = *(_OWORD **)(a2 + 24);
            if ((unint64_t)v6 > v354)
              goto LABEL_52;
          }
          else
          {
            v47 = v6;
            v8 = v348;
            v28 = v367;
            v13 = v368;
            LODWORD(v22) = v351;
            LODWORD(v21) = v353;
            v60 = v354;
            v26 = v350;
            v53 = v55;
            v61 = (unint64_t)&v6[-v27];
            v62 = *(_OWORD **)(a2 + 24);
            if ((unint64_t)v6 > v354)
            {
LABEL_52:
              if (v27 <= v60)
              {
                v64 = (char *)v62 + v60 - v27;
                v110 = (__int128 *)v27;
                v111 = v62;
                do
                {
                  v112 = *v110++;
                  *v111++ = v112;
                }
                while (v111 < (_OWORD *)v64);
                v63 = v60;
                if (v60 >= (unint64_t)v6)
                  goto LABEL_190;
              }
              else
              {
                v63 = v27;
                v64 = v62;
                if (v27 >= (unint64_t)v6)
                {
LABEL_190:
                  *(_QWORD *)(a2 + 24) += v61;
                  v99 = *(_QWORD *)(a2 + 8);
                  if (v61 >= 0x10000)
                  {
                    v155 = (unint64_t)(v99 - *(_QWORD *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 1;
                    *(_DWORD *)(a2 + 76) = v155;
                  }
                  v44 = (v53 - v37);
                  goto LABEL_197;
                }
              }
              if (v27 > v60)
                v60 = v27;
              v113 = (unint64_t)&v6[-v60];
              if ((unint64_t)&v6[-v60] < 8)
              {
                v114 = (unsigned __int8 *)v63;
                goto LABEL_189;
              }
              if ((unint64_t)v62 - v27 < 0x20)
              {
                v114 = (unsigned __int8 *)v63;
                goto LABEL_189;
              }
              if (v113 >= 0x20)
              {
                v128 = v113 & 0xFFFFFFFFFFFFFFE0;
                v138 = (__int128 *)(v63 + 16);
                v139 = (_OWORD *)((char *)v62 + v60 - v27 + 16);
                v140 = v113 & 0xFFFFFFFFFFFFFFE0;
                do
                {
                  v141 = *v138;
                  *(v139 - 1) = *(v138 - 1);
                  *v139 = v141;
                  v138 += 2;
                  v139 += 2;
                  v140 -= 32;
                }
                while (v140);
                if (v113 == v128)
                  goto LABEL_190;
                if ((v113 & 0x18) == 0)
                {
                  v114 = (unsigned __int8 *)(v63 + v128);
                  v64 += v128;
                  do
                  {
LABEL_189:
                    v154 = *v114++;
                    *v64++ = v154;
                  }
                  while (v114 < v6);
                  goto LABEL_190;
                }
              }
              else
              {
                v128 = 0;
              }
              v64 += v113 & 0xFFFFFFFFFFFFFFF8;
              v114 = (unsigned __int8 *)(v63 + (v113 & 0xFFFFFFFFFFFFFFF8));
              v142 = (uint64_t *)(v63 + v128);
              v143 = (_QWORD *)((char *)v62 + v128 + v60 - v27);
              v144 = v128 - (v113 & 0xFFFFFFFFFFFFFFF8);
              do
              {
                v145 = *v142++;
                *v143++ = v145;
                v144 += 8;
              }
              while (v144);
              if (v113 == (v113 & 0xFFFFFFFFFFFFFFF8))
                goto LABEL_190;
              goto LABEL_189;
            }
          }
LABEL_120:
          *v62 = *(_OWORD *)v27;
          v105 = *(_QWORD *)(a2 + 24);
          if (v61 <= 0x10)
          {
            *(_QWORD *)(a2 + 24) = v105 + v61;
            v99 = *(_QWORD *)(a2 + 8);
            v44 = (v53 - v37);
            goto LABEL_197;
          }
          v106 = (_OWORD *)(v105 + 16);
          v107 = v105 + v61;
          v108 = (__int128 *)(v27 + 16);
          do
          {
            v109 = *v108++;
            *v106++ = v109;
          }
          while ((unint64_t)v106 < v107);
          goto LABEL_190;
        }
      }
      if (v34 <= v21 || (v65 = v35 + v34, *(_DWORD *)(v35 + v34) != *(_DWORD *)v6))
      {
        v6 += ((uint64_t)&v6[-v27] >> 8) + 1;
        v24 = v29;
        v11 = v347;
        v8 = v348;
        v13 = v368;
        continue;
      }
      v66 = *(_QWORD *)(v6 + 1);
      v67 = 4 * ((0xCF1BBCDCB7A56463 * v66) >> v364);
      v68 = *(unsigned int *)(v348 + v67);
      v69 = v368;
      if (v68 < v22)
        v69 = v362;
      *(_DWORD *)(v348 + v67) = v40;
      if (v68 > v21 && *(_QWORD *)(v69 + v68) == v66)
      {
        v341 = v69;
        v70 = v39;
        v342 = v23;
        if (v68 >= v22)
          v71 = (char *)v347;
        else
          v71 = v356;
        if (v68 >= v22)
          v72 = v358;
        else
          v72 = v345;
        v73 = v69 + v68;
        v58 = ZSTD_count_2segments(v6 + 9, (char *)(v69 + v68 + 8), v347, v71, v358) + 8;
        v44 = (v40 - v68);
        v74 = v73 > (unint64_t)v72 && (unint64_t)(v6 + 1) > v27;
        v75 = v354;
        if (v74)
        {
          v125 = (unsigned __int8 *)(v341 + v68 - 1);
          v11 = v347;
          v8 = v348;
          v28 = v367;
          LODWORD(v22) = v351;
          LODWORD(v21) = v353;
          v26 = v350;
          v29 = v342;
          v53 = v70;
          while (*v6 == *v125)
          {
            ++v58;
            v126 = v6 - 1;
            if (v125 > v72)
            {
              --v125;
              v59 = (unint64_t)v6-- > v27;
              if (v59)
                continue;
            }
            v47 = v126 + 1;
            v13 = v368;
            v61 = (unint64_t)&v126[-v27 + 1];
            v76 = *(_OWORD **)(a2 + 24);
            if ((unint64_t)(v126 + 1) <= v354)
              goto LABEL_140;
            goto LABEL_88;
          }
          v47 = v6 + 1;
          v13 = v368;
          v61 = (unint64_t)&v6[-v27 + 1];
          v76 = *(_OWORD **)(a2 + 24);
          if ((unint64_t)(v6 + 1) <= v354)
            goto LABEL_140;
LABEL_88:
          if (v27 <= v75)
          {
            v88 = (char *)v76 + v75 - v27;
            v115 = (__int128 *)v27;
            v116 = v76;
            do
            {
              v117 = *v115++;
              *v116++ = v117;
            }
            while (v116 < (_OWORD *)v88);
            v87 = v75;
            if (v75 >= (unint64_t)v47)
              goto LABEL_195;
          }
          else
          {
            v87 = v27;
            v88 = v76;
            if (v27 >= (unint64_t)v47)
              goto LABEL_195;
          }
          if (v27 > v75)
            v75 = v27;
          v118 = (unint64_t)&v47[-v75];
          if ((unint64_t)&v47[-v75] < 8)
          {
            v119 = (unsigned __int8 *)v87;
            goto LABEL_194;
          }
          if ((unint64_t)v76 - v27 < 0x20)
          {
            v119 = (unsigned __int8 *)v87;
            goto LABEL_194;
          }
          if (v118 >= 0x20)
          {
            v129 = v118 & 0xFFFFFFFFFFFFFFE0;
            v146 = (__int128 *)(v87 + 16);
            v147 = (_OWORD *)((char *)v76 + v75 - v27 + 16);
            v148 = v118 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              v149 = *v146;
              *(v147 - 1) = *(v146 - 1);
              *v147 = v149;
              v146 += 2;
              v147 += 2;
              v148 -= 32;
            }
            while (v148);
            if (v118 == v129)
              goto LABEL_195;
            if ((v118 & 0x18) == 0)
            {
              v119 = (unsigned __int8 *)(v87 + v129);
              v88 += v129;
              do
              {
LABEL_194:
                v156 = *v119++;
                *v88++ = v156;
              }
              while (v119 < v47);
              goto LABEL_195;
            }
          }
          else
          {
            v129 = 0;
          }
          v88 += v118 & 0xFFFFFFFFFFFFFFF8;
          v119 = (unsigned __int8 *)(v87 + (v118 & 0xFFFFFFFFFFFFFFF8));
          v150 = (uint64_t *)(v87 + v129);
          v151 = (_QWORD *)((char *)v76 + v129 + v75 - v27);
          v152 = v129 - (v118 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            v153 = *v150++;
            *v151++ = v153;
            v152 += 8;
          }
          while (v152);
          if (v118 != (v118 & 0xFFFFFFFFFFFFFFF8))
            goto LABEL_194;
LABEL_195:
          *(_QWORD *)(a2 + 24) += v61;
          v99 = *(_QWORD *)(a2 + 8);
          if (v61 >= 0x10000)
          {
            v157 = (unint64_t)(v99 - *(_QWORD *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v157;
          }
LABEL_197:
          v101 = v58 - 3;
          *(_WORD *)(v99 + 4) = v61;
          *(_DWORD *)v99 = v44 + 3;
          if (!((v58 - 3) >> 16))
            goto LABEL_199;
LABEL_198:
          v158 = (unint64_t)(v99 - *(_QWORD *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v158;
          goto LABEL_199;
        }
        v47 = v6 + 1;
        v11 = v347;
        v8 = v348;
        v28 = v367;
        v13 = v368;
        LODWORD(v22) = v351;
        LODWORD(v21) = v353;
        v26 = v350;
        v29 = v342;
        v53 = v70;
        v61 = (unint64_t)&v6[-v27 + 1];
        v76 = *(_OWORD **)(a2 + 24);
        if ((unint64_t)(v6 + 1) > v354)
          goto LABEL_88;
      }
      else
      {
        v29 = v23;
        v11 = v347;
        if (v34 >= v22)
          v82 = (char *)v347;
        else
          v82 = v356;
        if (v34 >= v22)
          v83 = v358;
        else
          v83 = v345;
        v84 = v39;
        v85 = ZSTD_count_2segments(v6 + 4, (char *)(v65 + 4), v347, v82, v358);
        v53 = v84;
        v58 = v85 + 4;
        v44 = (v84 - v34);
        if (v65 > (unint64_t)v83 && (unint64_t)v6 > v27)
        {
          v102 = v6 - 1;
          v103 = (unsigned __int8 *)(v35 + v34 - 1);
          v8 = v348;
          v28 = v367;
          LODWORD(v22) = v351;
          LODWORD(v21) = v353;
          v75 = v354;
          v26 = v350;
          while (*v102 == *v103)
          {
            ++v58;
            v104 = v102 - 1;
            if (v103 > v83)
            {
              --v103;
              v59 = (unint64_t)v102-- > v27;
              if (v59)
                continue;
            }
            v47 = v104 + 1;
            v13 = v368;
            v61 = (unint64_t)&v104[-v27 + 1];
            v76 = *(_OWORD **)(a2 + 24);
            if ((unint64_t)v47 <= v354)
              goto LABEL_140;
            goto LABEL_88;
          }
          v47 = v102 + 1;
          v13 = v368;
          v61 = (unint64_t)&v102[-v27 + 1];
          v76 = *(_OWORD **)(a2 + 24);
          if ((unint64_t)v47 > v354)
            goto LABEL_88;
        }
        else
        {
          v47 = v6;
          v8 = v348;
          v28 = v367;
          v13 = v368;
          LODWORD(v22) = v351;
          LODWORD(v21) = v353;
          v75 = v354;
          v26 = v350;
          v61 = (unint64_t)&v6[-v27];
          v76 = *(_OWORD **)(a2 + 24);
          if ((unint64_t)v6 > v354)
            goto LABEL_88;
        }
      }
LABEL_140:
      *v76 = *(_OWORD *)v27;
      v120 = *(_QWORD *)(a2 + 24);
      if (v61 <= 0x10)
      {
        *(_QWORD *)(a2 + 24) = v120 + v61;
        v99 = *(_QWORD *)(a2 + 8);
        goto LABEL_197;
      }
      v121 = (_OWORD *)(v120 + 16);
      v122 = v120 + v61;
      v123 = (__int128 *)(v27 + 16);
      do
      {
        v124 = *v123++;
        *v121++ = v124;
      }
      while ((unint64_t)v121 < v122);
      goto LABEL_195;
    }
    v43 = v39;
    v44 = v23;
    v11 = v347;
    if (v41 >= v22)
      v45 = (char *)v347;
    else
      v45 = v356;
    v46 = ZSTD_count_2segments(v6 + 5, (char *)(v42 + 4), v347, v45, v358);
    v47 = v6 + 1;
    v48 = (unint64_t)&v6[-v27 + 1];
    v49 = *(_OWORD **)(a2 + 24);
    v50 = v354;
    if ((unint64_t)(v6 + 1) <= v354)
    {
      *v49 = *(_OWORD *)v27;
      v77 = *(_QWORD *)(a2 + 24);
      if (v48 <= 0x10)
      {
        *(_QWORD *)(a2 + 24) = v77 + v48;
        v99 = *(_QWORD *)(a2 + 8);
        v28 = v367;
        v13 = v368;
        LODWORD(v22) = v351;
        LODWORD(v21) = v353;
        v26 = v350;
        v53 = v43;
        goto LABEL_111;
      }
      v78 = (_OWORD *)(v77 + 16);
      v79 = v77 + v48;
      v80 = (__int128 *)(v27 + 16);
      v28 = v367;
      v13 = v368;
      LODWORD(v22) = v351;
      LODWORD(v21) = v353;
      v26 = v350;
      v53 = v43;
      do
      {
        v81 = *v80++;
        *v78++ = v81;
      }
      while ((unint64_t)v78 < v79);
    }
    else
    {
      if (v27 <= v354)
      {
        v52 = (char *)v49 + v354 - v27;
        v92 = (__int128 *)v27;
        v93 = *(_OWORD **)(a2 + 24);
        do
        {
          v94 = *v92++;
          *v93++ = v94;
        }
        while (v93 < (_OWORD *)v52);
        v51 = v354;
        v28 = v367;
        v13 = v368;
        LODWORD(v22) = v351;
        LODWORD(v21) = v353;
        v26 = v350;
        v53 = v43;
        if (v354 >= (unint64_t)v47)
          goto LABEL_107;
      }
      else
      {
        v51 = v27;
        v52 = *(_BYTE **)(a2 + 24);
        v28 = v367;
        v13 = v368;
        LODWORD(v22) = v351;
        LODWORD(v21) = v353;
        v26 = v350;
        v53 = v43;
        if (v27 >= (unint64_t)v47)
          goto LABEL_107;
      }
      if (v27 > v354)
        v50 = v27;
      v95 = (unint64_t)&v6[-v50 + 1];
      if (v95 < 8 || (unint64_t)v49 - v27 < 0x20)
      {
        v96 = (char *)v51;
        goto LABEL_105;
      }
      if (v95 >= 0x20)
      {
        v127 = v95 & 0xFFFFFFFFFFFFFFE0;
        v130 = (__int128 *)(v51 + 16);
        v131 = (_OWORD *)((char *)v49 + v50 - v27 + 16);
        v132 = v95 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v133 = *v130;
          *(v131 - 1) = *(v130 - 1);
          *v131 = v133;
          v130 += 2;
          v131 += 2;
          v132 -= 32;
        }
        while (v132);
        if (v95 == v127)
          goto LABEL_107;
        if ((v95 & 0x18) == 0)
        {
          v96 = (char *)(v51 + v127);
          v52 += v127;
LABEL_105:
          v97 = (char *)(v95 + v51);
          do
          {
            v98 = *v96++;
            *v52++ = v98;
          }
          while (v96 != v97);
          goto LABEL_107;
        }
      }
      else
      {
        v127 = 0;
      }
      v52 += v95 & 0xFFFFFFFFFFFFFFF8;
      v96 = (char *)(v51 + (v95 & 0xFFFFFFFFFFFFFFF8));
      v134 = (uint64_t *)(v51 + v127);
      v135 = (_QWORD *)((char *)v49 + v127 + v50 - v27);
      v136 = v127 - (v95 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        v137 = *v134++;
        *v135++ = v137;
        v136 += 8;
      }
      while (v136);
      if (v95 != (v95 & 0xFFFFFFFFFFFFFFF8))
        goto LABEL_105;
    }
LABEL_107:
    *(_QWORD *)(a2 + 24) += v48;
    v99 = *(_QWORD *)(a2 + 8);
    if (v48 >= 0x10000)
    {
      v100 = (unint64_t)(v99 - *(_QWORD *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v100;
    }
LABEL_111:
    v58 = v46 + 4;
    v101 = v46 + 1;
    *(_WORD *)(v99 + 4) = v48;
    *(_DWORD *)v99 = 1;
    if ((v46 + 1) >> 16)
      goto LABEL_198;
LABEL_199:
    *(_WORD *)(v99 + 6) = v101;
    v159 = v99 + 8;
    *(_QWORD *)(a2 + 8) = v99 + 8;
    v27 = (unint64_t)&v47[v58];
    if ((unint64_t)&v47[v58] <= v366)
    {
      v160 = (v53 + 2);
      v161 = *(_QWORD *)(v13 + v160);
      *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCB7A56463 * v161) >> v364)) = v160;
      *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCB7A56463 * *(_QWORD *)(v27 - 2)) >> v364)) = v27 - 2 - v13;
      switch(v26)
      {
        case 0:
          v162 = -1157627904;
          goto LABEL_206;
        case 1:
          v162 = -1080360960;
          goto LABEL_206;
        case 2:
          v162 = -1079680256;
LABEL_206:
          v165 = v162 | 0xCF1BBCDC00000000;
          v166 = v349;
          *(_DWORD *)(v28 + 4 * ((v161 * v165) >> v349)) = v160;
          v163 = v27 - 1;
          v167 = *(_QWORD *)(v27 - 1);
          goto LABEL_208;
        case 3:
          v166 = v349;
          *(_DWORD *)(v28 + 4 * ((0xCF1BBCDCB7A56463 * v161) >> v349)) = v160;
          v163 = v27 - 1;
          v167 = *(_QWORD *)(v27 - 1);
          v165 = 0xCF1BBCDCB7A56463;
LABEL_208:
          v164 = (v167 * v165) >> v166;
          break;
        default:
          *(_DWORD *)(v28 + 4 * ((-1640531535 * *(_DWORD *)(v13 + v160)) >> v346)) = v160;
          v163 = v27 - 1;
          v164 = (-1640531535 * *(_DWORD *)(v27 - 1)) >> v346;
          break;
      }
      *(_DWORD *)(v28 + 4 * v164) = v163 - v13;
      while (1)
      {
        v24 = v44;
        v44 = v29;
        v171 = v27 - v13;
        v172 = (v27 - v13 - v29);
        v173 = v362;
        if (v172 >= v22)
          v173 = v13;
        if (v172 <= v21)
          break;
        if ((v360 - v172) < 3)
          break;
        v174 = v173 + v172;
        if (*(_DWORD *)v174 != *(_DWORD *)v27)
          break;
        if (v172 >= v22)
          v175 = (char *)v11;
        else
          v175 = v356;
        v176 = ZSTD_count_2segments((_QWORD *)(v27 + 4), (char *)(v174 + 4), v11, v175, v358);
        if (v27 <= v354)
        {
          *(_OWORD *)*(_QWORD *)(a2 + 24) = *(_OWORD *)v27;
          v159 = *(_QWORD *)(a2 + 8);
        }
        *(_WORD *)(v159 + 4) = 0;
        *(_DWORD *)v159 = 1;
        v26 = v350;
        if (v176 + 1 >= 0x10000)
        {
          v177 = (unint64_t)(v159 - *(_QWORD *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v177;
        }
        *(_WORD *)(v159 + 6) = v176 + 1;
        v159 += 8;
        *(_QWORD *)(a2 + 8) = v159;
        v28 = v367;
        LODWORD(v22) = v351;
        LODWORD(v21) = v353;
        switch(v350)
        {
          case 0:
            v168 = *(_QWORD *)v27;
            v169 = -1157627904;
            goto LABEL_211;
          case 1:
            v168 = *(_QWORD *)v27;
            v169 = -1080360960;
            goto LABEL_211;
          case 2:
            v168 = *(_QWORD *)v27;
            v169 = -1079680256;
            goto LABEL_211;
          case 3:
            v168 = *(_QWORD *)v27;
            v169 = -1213897629;
LABEL_211:
            v170 = (v168 * (v169 | 0xCF1BBCDC00000000)) >> v349;
            break;
          default:
            v170 = (-1640531535 * *(_DWORD *)v27) >> v346;
            v168 = *(_QWORD *)v27;
            break;
        }
        *(_DWORD *)(v367 + 4 * v170) = v171;
        *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCB7A56463 * v168) >> v364)) = v171;
        v27 += v176 + 4;
        v29 = v24;
        v23 = v44;
        v6 = (unsigned __int8 *)v27;
        if (v27 > v366)
          goto LABEL_14;
      }
      v23 = v24;
      v24 = v29;
      v6 = (unsigned __int8 *)v27;
    }
    else
    {
      v23 = v44;
      v24 = v29;
      v6 = &v47[v58];
    }
LABEL_14:
    ;
  }
  while ((unint64_t)v6 < v366);
  v6 = (unsigned __int8 *)v27;
  a3 = v343;
LABEL_495:
  *a3 = v23;
LABEL_503:
  a3[1] = v24;
  return v11 - (_QWORD)v6;
}

uint64_t ZSTD_fillHashTable(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  char v11;
  char v12;
  int v13;
  unint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;

  v3 = *(_QWORD *)(result + 8);
  v4 = *(unsigned int *)(result + 36);
  v5 = (_QWORD *)(v3 + v4);
  v6 = a2 - 6;
  v7 = v3 + v4 + 3;
  if (v7 < a2 - 6)
  {
    v8 = *(_QWORD *)(result + 48);
    v9 = *(_DWORD *)(result + 208);
    v10 = *(_DWORD *)(result + 200);
    v11 = 64 - v10;
    v12 = 32 - v10;
    if (a3)
    {
      result = 2654435761;
      v13 = v9 - 5;
      do
      {
        switch(v13)
        {
          case 0:
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v3 + v4)) >> v11)) = v4;
            v14 = (0xCF1BBCDCBB000000 * *(_QWORD *)(v3 + v4 + 1)) >> v11;
            if (!*(_DWORD *)(v8 + 4 * v14))
              *(_DWORD *)(v8 + 4 * v14) = v4 + 1;
            v15 = (_DWORD *)(v8 + 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v3 + v4 + 2)) >> v11));
            if (!*v15)
              goto LABEL_25;
            break;
          case 1:
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v3 + v4)) >> v11)) = v4;
            v17 = (0xCF1BBCDCBF9B0000 * *(_QWORD *)(v3 + v4 + 1)) >> v11;
            if (!*(_DWORD *)(v8 + 4 * v17))
              *(_DWORD *)(v8 + 4 * v17) = v4 + 1;
            v15 = (_DWORD *)(v8 + 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v3 + v4 + 2)) >> v11));
            if (!*v15)
              goto LABEL_25;
            break;
          case 2:
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBFA56300 * *(_QWORD *)(v3 + v4)) >> v11)) = v4;
            v18 = (0xCF1BBCDCBFA56300 * *(_QWORD *)(v3 + v4 + 1)) >> v11;
            if (!*(_DWORD *)(v8 + 4 * v18))
              *(_DWORD *)(v8 + 4 * v18) = v4 + 1;
            v15 = (_DWORD *)(v8 + 4 * ((0xCF1BBCDCBFA56300 * *(_QWORD *)(v3 + v4 + 2)) >> v11));
            if (!*v15)
              goto LABEL_25;
            break;
          case 3:
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4)) >> v11)) = v4;
            v19 = (0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4 + 1)) >> v11;
            if (!*(_DWORD *)(v8 + 4 * v19))
              *(_DWORD *)(v8 + 4 * v19) = v4 + 1;
            v15 = (_DWORD *)(v8 + 4 * ((0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4 + 2)) >> v11));
            if (!*v15)
              goto LABEL_25;
            break;
          default:
            *(_DWORD *)(v8 + 4 * ((-1640531535 * *(_DWORD *)(v3 + v4)) >> v12)) = v4;
            v16 = (-1640531535 * *(_DWORD *)(v3 + v4 + 1)) >> v12;
            if (!*(_DWORD *)(v8 + 4 * v16))
              *(_DWORD *)(v8 + 4 * v16) = v4 + 1;
            v15 = (_DWORD *)(v8 + 4 * ((-1640531535 * *(_DWORD *)(v3 + v4 + 2)) >> v12));
            if (!*v15)
LABEL_25:
              *v15 = v4 + 2;
            break;
        }
        v4 += 3;
      }
      while (v3 + v4 + 3 < v6);
    }
    else
    {
      switch(v9)
      {
        case 5:
          v20 = v3 + v4 + 6;
          if (v20 <= v6)
            v20 = v6;
          v21 = v20 - v3 - 6;
          if (v21 == v4)
            v22 = *(unsigned int *)(result + 36);
          else
            v22 = v4 + 1;
          v23 = (v21 - v22) / 3uLL;
          if (v21 != v4)
            ++v23;
          if (!v23)
            goto LABEL_82;
          v24 = v23 + 1;
          v25 = 3 * (v24 & 0x7FFFFFFFFFFFFFFELL);
          v7 += v25;
          v5 = (_QWORD *)((char *)v5 + v25);
          result = v24 & 0x7FFFFFFFFFFFFFFELL;
          do
          {
            v26 = (0xCF1BBCDCBB000000 * *(_QWORD *)(v3 + v4 + 3)) >> v11;
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v3 + v4)) >> v11)) = v4;
            *(_DWORD *)(v8 + 4 * v26) = v4 + 3;
            v4 += 6;
            result -= 2;
          }
          while (result);
          if (v24 != (v24 & 0x7FFFFFFFFFFFFFFELL))
          {
LABEL_82:
            do
            {
              *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBB000000 * *v5) >> v11)) = (_DWORD)v5 - v3;
              v5 = (_QWORD *)v7;
              v7 += 3;
            }
            while (v7 < v6);
          }
          break;
        case 6:
          v27 = v3 + v4 + 6;
          if (v27 <= v6)
            v27 = v6;
          v28 = v27 - v3 - 6;
          if (v28 == v4)
            v29 = *(unsigned int *)(result + 36);
          else
            v29 = v4 + 1;
          v30 = (v28 - v29) / 3uLL;
          if (v28 != v4)
            ++v30;
          if (!v30)
            goto LABEL_83;
          v31 = v30 + 1;
          v32 = 3 * (v31 & 0x7FFFFFFFFFFFFFFELL);
          v7 += v32;
          v5 = (_QWORD *)((char *)v5 + v32);
          result = v31 & 0x7FFFFFFFFFFFFFFELL;
          do
          {
            v33 = (0xCF1BBCDCBF9B0000 * *(_QWORD *)(v3 + v4 + 3)) >> v11;
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v3 + v4)) >> v11)) = v4;
            *(_DWORD *)(v8 + 4 * v33) = v4 + 3;
            v4 += 6;
            result -= 2;
          }
          while (result);
          if (v31 != (v31 & 0x7FFFFFFFFFFFFFFELL))
          {
LABEL_83:
            do
            {
              *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBF9B0000 * *v5) >> v11)) = (_DWORD)v5 - v3;
              v5 = (_QWORD *)v7;
              v7 += 3;
            }
            while (v7 < v6);
          }
          break;
        case 7:
          v34 = v3 + v4 + 6;
          if (v34 <= v6)
            v34 = v6;
          v35 = v34 - v3 - 6;
          if (v35 == v4)
            v36 = *(unsigned int *)(result + 36);
          else
            v36 = v4 + 1;
          v37 = (v35 - v36) / 3uLL;
          if (v35 != v4)
            ++v37;
          if (!v37)
            goto LABEL_84;
          v38 = v37 + 1;
          v39 = 3 * (v38 & 0x7FFFFFFFFFFFFFFELL);
          v7 += v39;
          v5 = (_QWORD *)((char *)v5 + v39);
          result = v38 & 0x7FFFFFFFFFFFFFFELL;
          do
          {
            v40 = (0xCF1BBCDCBFA56300 * *(_QWORD *)(v3 + v4 + 3)) >> v11;
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBFA56300 * *(_QWORD *)(v3 + v4)) >> v11)) = v4;
            *(_DWORD *)(v8 + 4 * v40) = v4 + 3;
            v4 += 6;
            result -= 2;
          }
          while (result);
          if (v38 != (v38 & 0x7FFFFFFFFFFFFFFELL))
          {
LABEL_84:
            do
            {
              *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBFA56300 * *v5) >> v11)) = (_DWORD)v5 - v3;
              v5 = (_QWORD *)v7;
              v7 += 3;
            }
            while (v7 < v6);
          }
          break;
        case 8:
          v41 = v3 + v4 + 6;
          if (v41 <= v6)
            v41 = v6;
          v42 = v41 - v3 - 6;
          if (v42 == v4)
            v43 = *(unsigned int *)(result + 36);
          else
            v43 = v4 + 1;
          v44 = (v42 - v43) / 3uLL;
          if (v42 != v4)
            ++v44;
          if (!v44)
            goto LABEL_85;
          v45 = v44 + 1;
          v46 = 3 * (v45 & 0x7FFFFFFFFFFFFFFELL);
          v7 += v46;
          v5 = (_QWORD *)((char *)v5 + v46);
          result = v45 & 0x7FFFFFFFFFFFFFFELL;
          do
          {
            v47 = (0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4 + 3)) >> v11;
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4)) >> v11)) = v4;
            *(_DWORD *)(v8 + 4 * v47) = v4 + 3;
            v4 += 6;
            result -= 2;
          }
          while (result);
          if (v45 != (v45 & 0x7FFFFFFFFFFFFFFELL))
          {
LABEL_85:
            do
            {
              *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCB7A56463 * *v5) >> v11)) = (_DWORD)v5 - v3;
              v5 = (_QWORD *)v7;
              v7 += 3;
            }
            while (v7 < v6);
          }
          break;
        default:
          do
          {
            *(_DWORD *)(v8 + 4 * ((-1640531535 * *(_DWORD *)(v3 + v4)) >> v12)) = v4;
            v4 += 3;
          }
          while (v3 + v4 + 3 < v6);
          break;
      }
    }
  }
  return result;
}

unint64_t ZSTD_compressBlock_fast_extDict_generic(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5, int a6)
{
  unsigned __int8 *v6;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  unsigned int v38;
  char *v39;
  unint64_t v40;
  unint64_t v41;
  _OWORD *v42;
  unint64_t v43;
  _BYTE *v44;
  unint64_t v45;
  char *v46;
  unsigned __int8 *v47;
  unint64_t v48;
  BOOL v49;
  unint64_t v50;
  _OWORD *v51;
  unint64_t v52;
  unint64_t v53;
  _BYTE *v54;
  uint64_t v55;
  _OWORD *v56;
  unint64_t v57;
  __int128 *v58;
  __int128 v59;
  unsigned __int8 *v60;
  unsigned __int8 *v61;
  unsigned __int8 *v62;
  __int128 *v63;
  _OWORD *v64;
  __int128 v65;
  unint64_t v66;
  unint64_t v67;
  char *v68;
  char *v69;
  char v70;
  uint64_t v71;
  unint64_t v72;
  __int16 v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _OWORD *v79;
  unint64_t v80;
  __int128 *v81;
  __int128 v82;
  __int128 *v83;
  _OWORD *v84;
  __int128 v85;
  unint64_t v86;
  unint64_t v87;
  unsigned __int8 *v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  __int128 *v92;
  _OWORD *v93;
  unint64_t v94;
  __int128 v95;
  uint64_t *v96;
  _QWORD *v97;
  unint64_t v98;
  uint64_t v99;
  __int128 *v100;
  _OWORD *v101;
  unint64_t v102;
  __int128 v103;
  uint64_t *v104;
  _QWORD *v105;
  unint64_t v106;
  uint64_t v107;
  char v108;
  unint64_t v109;
  unint64_t v110;
  unsigned int v111;
  uint64_t v112;
  unsigned int v113;
  int v114;
  unint64_t v115;
  unint64_t v116;
  uint64_t v117;
  unsigned int v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  char *v123;
  unint64_t v124;
  unint64_t v125;
  _BOOL4 v126;
  uint64_t v127;
  unint64_t v128;
  unsigned __int8 *v130;
  _BOOL4 v131;
  int v132;
  unsigned int v133;
  uint64_t v134;
  unsigned int v135;
  uint64_t v136;
  char v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  unsigned int v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  unint64_t v146;
  unsigned int v147;
  unint64_t v148;
  unsigned int v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  unsigned __int8 *v158;
  int v159;
  _BOOL8 v160;
  uint64_t v161;
  unsigned __int8 *v162;
  uint64_t v163;
  char *v164;
  unsigned __int8 *v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  _OWORD *v169;
  uint64_t v170;
  _OWORD *v171;
  unint64_t v172;
  __int128 *v173;
  __int128 v174;
  unsigned __int8 *v175;
  unsigned __int8 *v176;
  unsigned __int8 *v177;
  unsigned __int8 *v178;
  unsigned __int8 *v179;
  unsigned __int8 *v180;
  _BYTE *v181;
  unint64_t v182;
  uint64_t v183;
  unsigned __int8 *v184;
  _OWORD *v185;
  __int128 v186;
  unsigned __int8 *v187;
  unint64_t v188;
  unsigned __int8 *v189;
  uint64_t v190;
  uint64_t v191;
  _QWORD *v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  __int128 *v196;
  _OWORD *v197;
  unint64_t v198;
  __int128 v199;
  unsigned __int8 *v200;
  _QWORD *v201;
  unint64_t v202;
  uint64_t v203;
  char v204;
  unint64_t v205;
  unint64_t v206;
  unint64_t v207;
  uint64_t v208;
  unsigned int v209;
  uint64_t v210;
  unsigned int v211;
  unint64_t v212;
  uint64_t v213;
  uint64_t v214;
  char *v215;
  unsigned __int8 *v216;
  unint64_t v217;
  unint64_t v218;
  unsigned __int8 *v219;
  uint64_t v220;
  unsigned int v221;
  unint64_t v222;
  unsigned __int8 *v223;
  unsigned __int8 *v224;
  uint64_t v225;
  unint64_t v226;
  uint64_t v227;
  unsigned int v228;
  unsigned int *v230;
  unsigned int *v231;
  unsigned __int8 *v232;
  uint64_t v233;
  uint64_t v234;
  char v235;
  char v236;
  int v237;
  char *v238;
  unsigned __int8 *v239;
  int v240;
  unint64_t v241;
  unsigned int v242;
  int v243;
  int v244;
  uint64_t v245;
  uint64_t v246;
  unint64_t v247;
  uint64_t v248;
  uint64_t v249;
  unsigned int v250;
  char v251;
  unint64_t v252;

  v6 = a4;
  v8 = *(_QWORD *)(a1 + 48);
  v9 = *(_DWORD *)(a1 + 200);
  LODWORD(v10) = *(_DWORD *)(a1 + 212);
  if ((_DWORD)v10)
    v10 = v10;
  else
    v10 = 1;
  v234 = v10;
  v11 = *(_QWORD *)(a1 + 8);
  v12 = &a4[a5];
  v13 = (_DWORD)a4 + a5 - v11;
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v14 = *(_DWORD *)(a1 + 32);
  v16 = 1 << *(_DWORD *)(a1 + 192);
  v17 = *(_DWORD *)(a1 + 24);
  v18 = v13 - v16;
  if (v13 - (int)v15 > v16 && v14 == 0)
    v15 = v18;
  else
    v15 = v15;
  if (v17 <= v15)
    v20 = v15;
  else
    v20 = v17;
  v250 = v15;
  v252 = (unint64_t)&a4[a5];
  v21 = (unint64_t)(v12 - 8);
  v23 = *a3;
  v22 = a3[1];
  v245 = *(_QWORD *)(a1 + 48);
  v247 = (unint64_t)(v12 - 8);
  if (v15 >= v17)
  {
    v231 = a3;
    v126 = v14 == 0;
    if (v126 && v13 - v17 > v16)
      v127 = v18;
    else
      v127 = v17;
    v128 = v11 + v127;
    if ((unsigned __int8 *)(v11 + v127) == a4)
      _X22 = a4 + 1;
    else
      _X22 = a4;
    v130 = _X22 + 1;
    v131 = (_DWORD)_X22 - (_DWORD)v11 - v17 > v16;
    v132 = (_DWORD)_X22 - v11 - v16;
    if (!v126 || !v131)
      v132 = *(_DWORD *)(a1 + 24);
    v133 = (_DWORD)_X22 - v11 - v132;
    if (v22 <= v133)
      v134 = v22;
    else
      v134 = 0;
    if (v22 <= v133)
      v135 = 0;
    else
      v135 = a3[1];
    if (v23 <= v133)
      v136 = v23;
    else
      v136 = 0;
    if (v23 > v133)
      v135 = *a3;
    if ((unint64_t)v130 >= v21)
      goto LABEL_318;
    v242 = v135;
    v249 = v11 + 2;
    v137 = 64 - v9;
    v251 = 32 - v9;
    v138 = (unint64_t)(v12 - 7);
    v139 = (unint64_t)(v12 - 3);
    v140 = (unint64_t)(v12 - 1);
    v141 = (unint64_t)(v12 - 32);
    v244 = v127;
    while (1)
    {
      v142 = a6 - 5;
      switch(a6)
      {
        case 5:
          v143 = *(_QWORD *)_X22;
          v144 = (0xCF1BBCDCBB000000 * *(_QWORD *)_X22) >> v137;
          v145 = *(_QWORD *)v130;
          v146 = (0xCF1BBCDCBB000000 * *(_QWORD *)v130) >> v137;
          goto LABEL_189;
        case 6:
          v143 = *(_QWORD *)_X22;
          v147 = -1080360960;
          goto LABEL_188;
        case 7:
          v143 = *(_QWORD *)_X22;
          v147 = -1079680256;
          goto LABEL_188;
        case 8:
          v143 = *(_QWORD *)_X22;
          v147 = -1213897629;
LABEL_188:
          v148 = v147 | 0xCF1BBCDC00000000;
          v144 = (v143 * v148) >> v137;
          v145 = *(_QWORD *)v130;
          v146 = (*(_QWORD *)v130 * v148) >> v137;
          break;
        default:
          LODWORD(v143) = *(_DWORD *)_X22;
          v144 = (-1640531535 * *(_DWORD *)_X22) >> v251;
          LODWORD(v145) = *(_DWORD *)v130;
          v146 = (-1640531535 * *(_DWORD *)v130) >> v251;
          break;
      }
      v149 = (_DWORD)_X22 - v11;
      v150 = 4 * v144;
      v151 = *(unsigned int *)(v8 + 4 * v144);
      v152 = 4 * v146;
      v153 = *(unsigned int *)(v8 + 4 * v146);
      __asm { PRFM            #0, [X22,#0x100] }
      *(_DWORD *)(v8 + v150) = (_DWORD)_X22 - v11;
      *(_DWORD *)(v8 + v152) = (_DWORD)v130 - v11;
      if (!(_DWORD)v136)
        goto LABEL_327;
LABEL_189:
      v158 = &_X22[-v136 + 2];
      if (*(_DWORD *)v158 == *(_DWORD *)(_X22 + 2))
      {
        v159 = 0;
        v160 = _X22[1] == *(v158 - 1);
        v161 = _X22[1] == *(v158 - 1) ? 5 : 4;
        _X22 = &_X22[-v160 + 2];
        v162 = &v158[-v160];
        v163 = v136;
        v136 = v134;
      }
      else
      {
LABEL_327:
        if (v151 <= v127
          || (v162 = (unsigned __int8 *)(v11 + v151), *(_DWORD *)v162 != (_DWORD)v143))
        {
          if (v153 <= v127
            || (v162 = (unsigned __int8 *)(v11 + v153), *(_DWORD *)(v11 + v153) != (_DWORD)v145))
          {
            v182 = (v234 + 1) + ((unint64_t)(_X22 - v6) >> 7);
            _X22 += v182;
            v130 += v182;
            if ((unint64_t)v130 >= v21)
              goto LABEL_315;
            continue;
          }
          _X22 = v130;
        }
        v163 = ((_DWORD)_X22 - (_DWORD)v162);
        v159 = v163 + 2;
        if (_X22 <= v6 || (unint64_t)v162 <= v128)
        {
          v161 = 4;
        }
        else
        {
          v175 = v162 - 1;
          v176 = _X22 - 1;
          v161 = 4;
          while (*v176 == *v175)
          {
            ++v161;
            v177 = v175 - 1;
            v178 = v176 - 1;
            if (v176 > v6)
            {
              --v176;
              v49 = (unint64_t)v175-- > v128;
              if (v49)
                continue;
            }
            v162 = v177 + 1;
            _X22 = v178 + 1;
            goto LABEL_195;
          }
          v162 = v175 + 1;
          _X22 = v176 + 1;
        }
      }
LABEL_195:
      v164 = (char *)&_X22[v161];
      v165 = &v162[v161];
      if (v138 <= (unint64_t)&_X22[v161])
        break;
      v166 = *(_QWORD *)v164 ^ *(_QWORD *)v165;
      if (v166)
      {
        v167 = __clz(__rbit64(v166)) >> 3;
        v168 = _X22 - v6;
        v169 = *(_OWORD **)(a2 + 24);
        if ((unint64_t)_X22 <= v141)
          goto LABEL_198;
        goto LABEL_226;
      }
      v190 = 0;
      v191 = (uint64_t)&_X22[v161 + 8];
      do
      {
        v192 = (_QWORD *)(v191 + v190);
        if (v191 + v190 >= v138)
        {
          v179 = &_X22[v161 + 8 + v190];
          v165 = &v162[v161 + 8 + v190];
          if ((unint64_t)v179 >= v139)
            goto LABEL_217;
          goto LABEL_215;
        }
        v193 = *(_QWORD *)&v162[v161 + 8 + v190];
        v190 += 8;
        v194 = *v192 ^ v193;
      }
      while (!v194);
      v167 = v190 + (__clz(__rbit64(v194)) >> 3);
      v168 = _X22 - v6;
      v169 = *(_OWORD **)(a2 + 24);
      if ((unint64_t)_X22 > v141)
        goto LABEL_226;
LABEL_198:
      *v169 = *(_OWORD *)v6;
      v170 = *(_QWORD *)(a2 + 24);
      if (v168 > 0x10)
      {
        v171 = (_OWORD *)(v170 + 16);
        v172 = v170 + v168;
        v173 = (__int128 *)(v6 + 16);
        do
        {
          v174 = *v173++;
          *v171++ = v174;
        }
        while ((unint64_t)v171 < v172);
        goto LABEL_263;
      }
      *(_QWORD *)(a2 + 24) = v170 + v168;
      v183 = *(_QWORD *)(a2 + 8);
LABEL_266:
      v206 = v167 + v161;
      *(_WORD *)(v183 + 4) = v168;
      *(_DWORD *)v183 = v159 + 1;
      if (v206 - 3 >= 0x10000)
      {
        v207 = (unint64_t)(v183 - *(_QWORD *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v207;
      }
      *(_WORD *)(v183 + 6) = v206 - 3;
      v208 = v183 + 8;
      *(_QWORD *)(a2 + 8) = v183 + 8;
      v6 = &_X22[v206];
      v21 = v247;
      if ((unint64_t)&_X22[v206] > v247)
      {
        v134 = v136;
LABEL_181:
        v130 = v6 + 1;
        v136 = v163;
        _X22 = v6;
        if ((unint64_t)(v6 + 1) >= v247)
          goto LABEL_315;
      }
      else
      {
        v209 = v149 + 2;
        switch(v142)
        {
          case 0u:
            v210 = *(_QWORD *)(v249 + v149);
            v211 = -1157627904;
            goto LABEL_277;
          case 1u:
            v210 = *(_QWORD *)(v249 + v149);
            v211 = -1080360960;
            goto LABEL_277;
          case 2u:
            v210 = *(_QWORD *)(v249 + v149);
            v211 = -1079680256;
            goto LABEL_277;
          case 3u:
            v210 = *(_QWORD *)(v249 + v149);
            v211 = -1213897629;
LABEL_277:
            v212 = v211 | 0xCF1BBCDC00000000;
            *(_DWORD *)(v8 + 4 * ((v210 * v212) >> v137)) = v209;
            *(_DWORD *)(v8 + 4 * ((*(_QWORD *)(v6 - 2) * v212) >> v137)) = (_DWORD)v6 - 2 - v11;
            if ((_DWORD)v136)
              goto LABEL_278;
            goto LABEL_272;
          default:
            *(_DWORD *)(v8 + 4 * ((-1640531535 * *(_DWORD *)(v249 + v149)) >> v251)) = v209;
            *(_DWORD *)(v8 + 4 * ((-1640531535 * *(_DWORD *)(v6 - 2)) >> v251)) = (_DWORD)v6 - 2 - v11;
            if ((_DWORD)v136)
            {
LABEL_278:
              v213 = v163;
              while (1)
              {
                v134 = v213;
                v213 = v136;
                if (*(_DWORD *)v6 != *(_DWORD *)&v6[-v136])
                  break;
                v214 = -(uint64_t)v136;
                v215 = (char *)(v6 + 4);
                v216 = &v6[-v136 + 4];
                if (v138 <= (unint64_t)(v6 + 4))
                {
                  v219 = v6 + 4;
                  if ((unint64_t)v215 >= v139)
                    goto LABEL_289;
LABEL_287:
                  if (*(_DWORD *)v216 == *(_DWORD *)v219)
                  {
                    v219 += 4;
                    v216 += 4;
                  }
LABEL_289:
                  if ((unint64_t)v219 >= v140)
                  {
                    if ((unint64_t)v219 < v252)
                      goto LABEL_295;
                  }
                  else
                  {
                    if (*(unsigned __int16 *)v216 == *(unsigned __int16 *)v219)
                    {
                      v219 += 2;
                      v216 += 2;
                    }
                    if ((unint64_t)v219 >= v252)
                      goto LABEL_297;
LABEL_295:
                    if (*v216 == *v219)
                      ++v219;
                  }
LABEL_297:
                  v218 = v219 - (unsigned __int8 *)v215;
                  goto LABEL_298;
                }
                v217 = *(_QWORD *)v215 ^ *(_QWORD *)v216;
                if (v217)
                {
                  v218 = __clz(__rbit64(v217)) >> 3;
                  if (v142 > 3)
                    goto LABEL_284;
                  goto LABEL_298;
                }
                v223 = v6 + 12;
                do
                {
                  v224 = &v223[v217];
                  if ((unint64_t)&v223[v217] >= v138)
                  {
                    v219 = &v6[v217 + 12];
                    v216 = &v219[v214];
                    if ((unint64_t)v219 >= v139)
                      goto LABEL_289;
                    goto LABEL_287;
                  }
                  v225 = *(_QWORD *)&v6[v214 + 12 + v217];
                  v217 += 8;
                  v226 = *(_QWORD *)v224 ^ v225;
                }
                while (!v226);
                v218 = v217 + (__clz(__rbit64(v226)) >> 3);
                if (v142 > 3)
                {
LABEL_284:
                  *(_DWORD *)(v8 + 4 * ((-1640531535 * *(_DWORD *)v6) >> v251)) = (_DWORD)v6 - v11;
                  if ((unint64_t)v6 > v141)
                    goto LABEL_305;
LABEL_304:
                  *(_OWORD *)*(_QWORD *)(a2 + 24) = *(_OWORD *)v6;
                  v208 = *(_QWORD *)(a2 + 8);
                  goto LABEL_305;
                }
LABEL_298:
                switch(v142)
                {
                  case 0u:
                    v220 = *(_QWORD *)v6;
                    v221 = -1157627904;
                    break;
                  case 1u:
                    v220 = *(_QWORD *)v6;
                    v221 = -1080360960;
                    break;
                  case 2u:
                    v220 = *(_QWORD *)v6;
                    v221 = -1079680256;
                    break;
                  case 3u:
                    v220 = *(_QWORD *)v6;
                    v221 = -1213897629;
                    break;
                  default:
                    goto LABEL_284;
                }
                *(_DWORD *)(v8 + 4 * ((v220 * (v221 | 0xCF1BBCDC00000000)) >> v137)) = (_DWORD)v6 - v11;
                if ((unint64_t)v6 <= v141)
                  goto LABEL_304;
LABEL_305:
                *(_WORD *)(v208 + 4) = 0;
                *(_DWORD *)v208 = 1;
                if (v218 + 1 >= 0x10000)
                {
                  v222 = (unint64_t)(v208 - *(_QWORD *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v222;
                }
                v6 += v218 + 4;
                *(_WORD *)(v208 + 6) = v218 + 1;
                v208 += 8;
                *(_QWORD *)(a2 + 8) = v208;
                v136 = v134;
                v163 = v213;
                if ((unint64_t)v6 > v247)
                  goto LABEL_181;
              }
              v227 = v134;
              v134 = v136;
              v130 = v6 + 1;
              v136 = v227;
              _X22 = v6;
              if ((unint64_t)(v6 + 1) >= v247)
              {
LABEL_315:
                a3 = v231;
                v135 = v242;
LABEL_318:
                if ((_DWORD)v136)
                  v228 = v136;
                else
                  v228 = v135;
                *a3 = v228;
                if ((_DWORD)v134)
                  LODWORD(v22) = v134;
                else
                  LODWORD(v22) = v135;
                goto LABEL_324;
              }
            }
            else
            {
LABEL_272:
              v134 = 0;
              v130 = v6 + 1;
              v136 = v163;
              _X22 = v6;
              if ((unint64_t)(v6 + 1) >= v247)
                goto LABEL_315;
            }
            break;
        }
      }
    }
    v179 = &_X22[v161];
    if ((unint64_t)v164 >= v139)
      goto LABEL_217;
LABEL_215:
    if (*(_DWORD *)v165 == *(_DWORD *)v179)
    {
      v179 += 4;
      v165 += 4;
    }
LABEL_217:
    if ((unint64_t)v179 >= v140)
    {
      if ((unint64_t)v179 >= v252)
        goto LABEL_225;
    }
    else
    {
      if (*(unsigned __int16 *)v165 == *(unsigned __int16 *)v179)
      {
        v179 += 2;
        v165 += 2;
      }
      if ((unint64_t)v179 >= v252)
      {
LABEL_225:
        v167 = v179 - (unsigned __int8 *)v164;
        v168 = _X22 - v6;
        v169 = *(_OWORD **)(a2 + 24);
        if ((unint64_t)_X22 <= v141)
          goto LABEL_198;
LABEL_226:
        if ((unint64_t)v6 <= v141)
        {
          v181 = (char *)v169 + v141 - (_QWORD)v6;
          v184 = v6;
          v185 = v169;
          do
          {
            v186 = *(_OWORD *)v184;
            v184 += 16;
            *v185++ = v186;
          }
          while (v185 < (_OWORD *)v181);
          v180 = (unsigned __int8 *)v141;
          if (v141 >= (unint64_t)_X22)
            goto LABEL_263;
        }
        else
        {
          v180 = v6;
          v181 = v169;
          if (v6 >= _X22)
            goto LABEL_263;
        }
        if ((unint64_t)v6 <= v141)
          v187 = (unsigned __int8 *)v141;
        else
          v187 = v6;
        v188 = _X22 - v187;
        if ((unint64_t)(_X22 - v187) < 8)
        {
          v189 = v180;
          goto LABEL_262;
        }
        if ((unint64_t)((char *)v169 - (char *)v6) < 0x20)
        {
          v189 = v180;
          goto LABEL_262;
        }
        if (v188 >= 0x20)
        {
          v240 = a6;
          v195 = v188 & 0xFFFFFFFFFFFFFFE0;
          v196 = (__int128 *)(v180 + 16);
          v197 = (_OWORD *)((char *)v169 + v187 - v6 + 16);
          v198 = v188 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            v199 = *v196;
            *(v197 - 1) = *(v196 - 1);
            *v197 = v199;
            v196 += 2;
            v197 += 2;
            v198 -= 32;
          }
          while (v198);
          a6 = v240;
          LODWORD(v127) = v244;
          if (v188 == v195)
            goto LABEL_263;
          if ((v188 & 0x18) == 0)
          {
            v189 = &v180[v195];
            v181 += v195;
            do
            {
LABEL_262:
              v204 = *v189++;
              *v181++ = v204;
            }
            while (v189 < _X22);
LABEL_263:
            *(_QWORD *)(a2 + 24) += v168;
            v183 = *(_QWORD *)(a2 + 8);
            if (v168 >= 0x10000)
            {
              v205 = (unint64_t)(v183 - *(_QWORD *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v205;
            }
            v8 = v245;
            goto LABEL_266;
          }
        }
        else
        {
          v195 = 0;
        }
        v181 += v188 & 0xFFFFFFFFFFFFFFF8;
        v189 = &v180[v188 & 0xFFFFFFFFFFFFFFF8];
        v200 = &v180[v195];
        v201 = (_QWORD *)((char *)v169 + &v187[v195] - v6);
        v202 = v195 - (v188 & 0xFFFFFFFFFFFFFFF8);
        do
        {
          v203 = *(_QWORD *)v200;
          v200 += 8;
          *v201++ = v203;
          v202 += 8;
        }
        while (v202);
        LODWORD(v127) = v244;
        if (v188 == (v188 & 0xFFFFFFFFFFFFFFF8))
          goto LABEL_263;
        goto LABEL_262;
      }
    }
    if (*v165 == *v179)
      ++v179;
    goto LABEL_225;
  }
  v248 = *(_QWORD *)(a1 + 8);
  if (v21 <= (unint64_t)a4)
    goto LABEL_317;
  v230 = a3;
  v24 = *(_QWORD *)(a1 + 16);
  v232 = (unsigned __int8 *)(v24 + v15);
  v239 = (unsigned __int8 *)(v11 + v20);
  v246 = v24;
  v238 = (char *)(v24 + v20);
  v233 = v11 + 2;
  v25 = 64 - v9;
  v235 = 32 - v9;
  v243 = v20 - 1;
  v241 = (unint64_t)(v12 - 32);
  v26 = a6 - 5;
  v27 = (unint64_t)a4;
  v236 = 64 - v9;
  v237 = a6 - 5;
  do
  {
    switch(v26)
    {
      case 0:
        v28 = *(_QWORD *)v6;
        v29 = -1157627904;
        goto LABEL_24;
      case 1:
        v28 = *(_QWORD *)v6;
        v29 = -1080360960;
        goto LABEL_24;
      case 2:
        v28 = *(_QWORD *)v6;
        v29 = -1079680256;
        goto LABEL_24;
      case 3:
        v28 = *(_QWORD *)v6;
        v29 = -1213897629;
LABEL_24:
        v30 = (v28 * (v29 | 0xCF1BBCDC00000000)) >> v25;
        break;
      default:
        v30 = (-1640531535 * *(_DWORD *)v6) >> v235;
        break;
    }
    v31 = 4 * v30;
    v32 = *(unsigned int *)(v8 + 4 * v30);
    v33 = v246;
    if (v32 >= v20)
      v34 = v248;
    else
      v34 = v246;
    v35 = ((_DWORD)v6 - v248 - v23 + 1);
    if (v35 >= v20)
      v33 = v248;
    *(_DWORD *)(v8 + v31) = (_DWORD)v6 - v248;
    if (v35 > v250 && (v243 - v35) >= 3)
    {
      v36 = v33 + v35;
      v37 = v6 + 1;
      if (*(_DWORD *)v36 == *(_DWORD *)(v6 + 1))
      {
        v38 = (_DWORD)v6 - v248;
        if (v35 >= v20)
          v39 = (char *)v252;
        else
          v39 = v238;
        v40 = ZSTD_count_2segments(v6 + 5, (char *)(v36 + 4), v252, v39, v239);
        v41 = (unint64_t)&v37[-v27];
        v42 = *(_OWORD **)(a2 + 24);
        if ((unint64_t)v37 <= v241)
        {
          *v42 = *(_OWORD *)v27;
          v55 = *(_QWORD *)(a2 + 24);
          if (v41 <= 0x10)
          {
            *(_QWORD *)(a2 + 24) = v55 + v41;
            v71 = *(_QWORD *)(a2 + 8);
            v8 = v245;
            v21 = v247;
            v25 = v236;
            v26 = v237;
            v73 = v40 + 1;
            *(_WORD *)(v71 + 4) = v41;
            *(_DWORD *)v71 = 1;
            if (v40 + 1 < 0x10000)
            {
LABEL_82:
              *(_WORD *)(v71 + 6) = v73;
              v75 = v71 + 8;
              *(_QWORD *)(a2 + 8) = v71 + 8;
              v27 = (unint64_t)&v37[v40 + 4];
              v76 = v23;
              v77 = v22;
              if (v27 > v247)
                goto LABEL_83;
              goto LABEL_130;
            }
LABEL_81:
            v74 = (unint64_t)(v71 - *(_QWORD *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v74;
            goto LABEL_82;
          }
          v56 = (_OWORD *)(v55 + 16);
          v57 = v55 + v41;
          v58 = (__int128 *)(v27 + 16);
          v8 = v245;
          v21 = v247;
          v25 = v236;
          v26 = v237;
          do
          {
            v59 = *v58++;
            *v56++ = v59;
          }
          while ((unint64_t)v56 < v57);
        }
        else
        {
          if (v27 <= v241)
          {
            v44 = (char *)v42 + v241 - v27;
            v63 = (__int128 *)v27;
            v64 = *(_OWORD **)(a2 + 24);
            v8 = v245;
            v21 = v247;
            v26 = v237;
            do
            {
              v65 = *v63++;
              *v64++ = v65;
            }
            while (v64 < (_OWORD *)v44);
            v43 = v241;
            v25 = v236;
            if (v241 >= (unint64_t)v37)
              goto LABEL_77;
          }
          else
          {
            v43 = v27;
            v44 = *(_BYTE **)(a2 + 24);
            v8 = v245;
            v21 = v247;
            v25 = v236;
            v26 = v237;
            if (v27 >= (unint64_t)v37)
              goto LABEL_77;
          }
          if (v27 <= v241)
            v66 = v241;
          else
            v66 = v27;
          v67 = (unint64_t)&v6[-v66 + 1];
          if (v67 < 8 || (unint64_t)v42 - v27 < 0x20)
          {
            v68 = (char *)v43;
            goto LABEL_75;
          }
          if (v67 >= 0x20)
          {
            v90 = v67 & 0xFFFFFFFFFFFFFFE0;
            v92 = (__int128 *)(v43 + 16);
            v93 = (_OWORD *)((char *)v42 + v66 - v27 + 16);
            v94 = v67 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              v95 = *v92;
              *(v93 - 1) = *(v92 - 1);
              *v93 = v95;
              v92 += 2;
              v93 += 2;
              v94 -= 32;
            }
            while (v94);
            if (v67 == v90)
              goto LABEL_77;
            if ((v67 & 0x18) == 0)
            {
              v68 = (char *)(v43 + v90);
              v44 += v90;
LABEL_75:
              v69 = (char *)(v67 + v43);
              do
              {
                v70 = *v68++;
                *v44++ = v70;
              }
              while (v68 != v69);
              goto LABEL_77;
            }
          }
          else
          {
            v90 = 0;
          }
          v44 += v67 & 0xFFFFFFFFFFFFFFF8;
          v68 = (char *)(v43 + (v67 & 0xFFFFFFFFFFFFFFF8));
          v96 = (uint64_t *)(v43 + v90);
          v97 = (_QWORD *)((char *)v42 + v90 + v66 - v27);
          v98 = v90 - (v67 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            v99 = *v96++;
            *v97++ = v99;
            v98 += 8;
          }
          while (v98);
          if (v67 != (v67 & 0xFFFFFFFFFFFFFFF8))
            goto LABEL_75;
        }
LABEL_77:
        *(_QWORD *)(a2 + 24) += v41;
        v71 = *(_QWORD *)(a2 + 8);
        if (v41 < 0x10000)
        {
          v73 = v40 + 1;
          *(_WORD *)(v71 + 4) = v41;
          *(_DWORD *)v71 = 1;
          if (v40 + 1 < 0x10000)
            goto LABEL_82;
        }
        else
        {
          v72 = (unint64_t)(v71 - *(_QWORD *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 1;
          *(_DWORD *)(a2 + 76) = v72;
          v73 = v40 + 1;
          *(_WORD *)(v71 + 4) = v41;
          *(_DWORD *)v71 = 1;
          if (v40 + 1 < 0x10000)
            goto LABEL_82;
        }
        goto LABEL_81;
      }
    }
    if (v32 < v250 || (v45 = v34 + v32, *(_DWORD *)(v34 + v32) != *(_DWORD *)v6))
    {
      v6 += v234 + ((uint64_t)&v6[-v27] >> 8);
      v25 = v236;
      continue;
    }
    if (v32 >= v20)
      v46 = (char *)v252;
    else
      v46 = v238;
    if (v32 >= v20)
      v47 = v239;
    else
      v47 = v232;
    v48 = ZSTD_count_2segments(v6 + 4, (char *)(v45 + 4), v252, v46, v239) + 4;
    v49 = v45 > (unint64_t)v47 && (unint64_t)v6 > v27;
    if (v49)
    {
      v60 = v6 - 1;
      v61 = (unsigned __int8 *)(v34 + v32 - 1);
      v8 = v245;
      v21 = v247;
      v25 = v236;
      v26 = v237;
      v38 = (_DWORD)v6 - v248;
      while (*v60 == *v61)
      {
        ++v48;
        v62 = v60 - 1;
        if (v61 > v47)
        {
          --v61;
          v49 = (unint64_t)v60-- > v27;
          if (v49)
            continue;
        }
        v6 = v62 + 1;
        v50 = (unint64_t)&v62[-v27 + 1];
        v51 = *(_OWORD **)(a2 + 24);
        v52 = v241;
        if ((unint64_t)v6 > v241)
          goto LABEL_53;
        goto LABEL_87;
      }
      v6 = v60 + 1;
      v50 = (unint64_t)&v60[-v27 + 1];
      v51 = *(_OWORD **)(a2 + 24);
      v52 = v241;
      if ((unint64_t)v6 > v241)
        goto LABEL_53;
LABEL_87:
      *v51 = *(_OWORD *)v27;
      v78 = *(_QWORD *)(a2 + 24);
      if (v50 <= 0x10)
      {
        *(_QWORD *)(a2 + 24) = v78 + v50;
        v89 = *(_QWORD *)(a2 + 8);
        goto LABEL_127;
      }
      v79 = (_OWORD *)(v78 + 16);
      v80 = v78 + v50;
      v81 = (__int128 *)(v27 + 16);
      do
      {
        v82 = *v81++;
        *v79++ = v82;
      }
      while ((unint64_t)v79 < v80);
      goto LABEL_125;
    }
    v8 = v245;
    v21 = v247;
    v25 = v236;
    v26 = v237;
    v38 = (_DWORD)v6 - v248;
    v50 = (unint64_t)&v6[-v27];
    v51 = *(_OWORD **)(a2 + 24);
    v52 = v241;
    if ((unint64_t)v6 <= v241)
      goto LABEL_87;
LABEL_53:
    if (v27 <= v52)
    {
      v54 = (char *)v51 + v52 - v27;
      v83 = (__int128 *)v27;
      v84 = v51;
      do
      {
        v85 = *v83++;
        *v84++ = v85;
      }
      while (v84 < (_OWORD *)v54);
      v53 = v241;
      if (v241 >= (unint64_t)v6)
        goto LABEL_125;
    }
    else
    {
      v53 = v27;
      v54 = v51;
      if (v27 >= (unint64_t)v6)
        goto LABEL_125;
    }
    if (v27 <= v241)
      v86 = v241;
    else
      v86 = v27;
    v87 = (unint64_t)&v6[-v86];
    if ((unint64_t)&v6[-v86] < 8)
    {
      v88 = (unsigned __int8 *)v53;
      goto LABEL_124;
    }
    if ((unint64_t)v51 - v27 < 0x20)
    {
      v88 = (unsigned __int8 *)v53;
      goto LABEL_124;
    }
    if (v87 >= 0x20)
    {
      v91 = v87 & 0xFFFFFFFFFFFFFFE0;
      v100 = (__int128 *)(v53 + 16);
      v101 = (_OWORD *)((char *)v51 + v86 - v27 + 16);
      v102 = v87 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v103 = *v100;
        *(v101 - 1) = *(v100 - 1);
        *v101 = v103;
        v100 += 2;
        v101 += 2;
        v102 -= 32;
      }
      while (v102);
      if (v87 == v91)
        goto LABEL_125;
      if ((v87 & 0x18) == 0)
      {
        v88 = (unsigned __int8 *)(v53 + v91);
        v54 += v91;
        do
        {
LABEL_124:
          v108 = *v88++;
          *v54++ = v108;
        }
        while (v88 < v6);
        goto LABEL_125;
      }
    }
    else
    {
      v91 = 0;
    }
    v54 += v87 & 0xFFFFFFFFFFFFFFF8;
    v88 = (unsigned __int8 *)(v53 + (v87 & 0xFFFFFFFFFFFFFFF8));
    v104 = (uint64_t *)(v53 + v91);
    v105 = (_QWORD *)((char *)v51 + v91 + v86 - v27);
    v106 = v91 - (v87 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      v107 = *v104++;
      *v105++ = v107;
      v106 += 8;
    }
    while (v106);
    if (v87 != (v87 & 0xFFFFFFFFFFFFFFF8))
      goto LABEL_124;
LABEL_125:
    *(_QWORD *)(a2 + 24) += v50;
    v89 = *(_QWORD *)(a2 + 8);
    if (v50 >= 0x10000)
    {
      v109 = (unint64_t)(v89 - *(_QWORD *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v109;
    }
LABEL_127:
    v76 = v38 - v32;
    *(_WORD *)(v89 + 4) = v50;
    *(_DWORD *)v89 = v76 + 3;
    if (v48 - 3 >= 0x10000)
    {
      v110 = (unint64_t)(v89 - *(_QWORD *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v110;
    }
    *(_WORD *)(v89 + 6) = v48 - 3;
    v75 = v89 + 8;
    *(_QWORD *)(a2 + 8) = v89 + 8;
    v27 = (unint64_t)&v6[v48];
    v77 = v23;
    if (v27 > v247)
    {
LABEL_83:
      v23 = v76;
      v22 = v77;
      v6 = (unsigned __int8 *)v27;
      continue;
    }
LABEL_130:
    v111 = v38 + 2;
    switch(v26)
    {
      case 0:
        v112 = *(_QWORD *)(v233 + v38);
        v113 = -1157627904;
        goto LABEL_136;
      case 1:
        v112 = *(_QWORD *)(v233 + v38);
        v113 = -1080360960;
        goto LABEL_136;
      case 2:
        v112 = *(_QWORD *)(v233 + v38);
        v113 = -1079680256;
        goto LABEL_136;
      case 3:
        v112 = *(_QWORD *)(v233 + v38);
        v113 = -1213897629;
LABEL_136:
        v116 = v113 | 0xCF1BBCDC00000000;
        *(_DWORD *)(v8 + 4 * ((v112 * v116) >> v25)) = v111;
        v114 = v27 - 2;
        v115 = (*(_QWORD *)(v27 - 2) * v116) >> v25;
        break;
      default:
        *(_DWORD *)(v8 + 4 * ((-1640531535 * *(_DWORD *)(v233 + v38)) >> v235)) = v111;
        v114 = v27 - 2;
        v115 = (-1640531535 * *(_DWORD *)(v27 - 2)) >> v235;
        break;
    }
    *(_DWORD *)(v8 + 4 * v115) = v114 - v248;
    while (1)
    {
      v22 = v76;
      v76 = v77;
      v120 = v248;
      v121 = (v27 - v248 - v77);
      if (v121 < v20)
        v120 = v246;
      if (v121 <= v250)
        break;
      if ((v243 - v121) < 3)
        break;
      v122 = v120 + v121;
      if (*(_DWORD *)v122 != *(_DWORD *)v27)
        break;
      if (v121 >= v20)
        v123 = (char *)v252;
      else
        v123 = v238;
      v124 = ZSTD_count_2segments((_QWORD *)(v27 + 4), (char *)(v122 + 4), v252, v123, v239);
      if (v27 <= v241)
      {
        *(_OWORD *)*(_QWORD *)(a2 + 24) = *(_OWORD *)v27;
        v75 = *(_QWORD *)(a2 + 8);
      }
      *(_WORD *)(v75 + 4) = 0;
      *(_DWORD *)v75 = 1;
      v26 = v237;
      if (v124 + 1 >= 0x10000)
      {
        v125 = (unint64_t)(v75 - *(_QWORD *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v125;
      }
      *(_WORD *)(v75 + 6) = v124 + 1;
      v75 += 8;
      *(_QWORD *)(a2 + 8) = v75;
      v8 = v245;
      v21 = v247;
      switch(v237)
      {
        case 0:
          v117 = *(_QWORD *)v27;
          v118 = -1157627904;
          goto LABEL_139;
        case 1:
          v117 = *(_QWORD *)v27;
          v118 = -1080360960;
          goto LABEL_139;
        case 2:
          v117 = *(_QWORD *)v27;
          v118 = -1079680256;
          goto LABEL_139;
        case 3:
          v117 = *(_QWORD *)v27;
          v118 = -1213897629;
LABEL_139:
          v119 = (v117 * (v118 | 0xCF1BBCDC00000000)) >> v25;
          break;
        default:
          v119 = (-1640531535 * *(_DWORD *)v27) >> v235;
          break;
      }
      *(_DWORD *)(v245 + 4 * v119) = v27 - v248;
      v27 += v124 + 4;
      v77 = v22;
      v23 = v76;
      v6 = (unsigned __int8 *)v27;
      if (v27 > v247)
        goto LABEL_17;
    }
    v23 = v22;
    v22 = v76;
    v6 = (unsigned __int8 *)v27;
LABEL_17:
    ;
  }
  while ((unint64_t)v6 < v21);
  v6 = (unsigned __int8 *)v27;
  a3 = v230;
LABEL_317:
  *a3 = v23;
LABEL_324:
  a3[1] = v22;
  return v252 - (_QWORD)v6;
}

uint64_t ZSTD_insertAndFindFirstIndex(uint64_t a1, uint64_t *a2)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  char v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 208);
  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(_DWORD *)(a1 + 200);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(unsigned int *)(a1 + 36);
  if (v6 < (int)a2 - (int)v5)
  {
    v7 = *(_QWORD *)(a1 + 64);
    v8 = ~(-1 << *(_DWORD *)(a1 + 196));
    v9 = 64 - v4;
    switch(v2)
    {
      case 5:
        do
        {
          v10 = 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v5 + v6)) >> v9);
          *(_DWORD *)(v7 + 4 * (v6 & v8)) = *(_DWORD *)(v3 + v10);
          *(_DWORD *)(v3 + v10) = v6++;
        }
        while (v6 < ((_DWORD)a2 - v5));
        break;
      case 6:
        do
        {
          v12 = 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v5 + v6)) >> v9);
          *(_DWORD *)(v7 + 4 * (v6 & v8)) = *(_DWORD *)(v3 + v12);
          *(_DWORD *)(v3 + v12) = v6++;
        }
        while (v6 < ((_DWORD)a2 - v5));
        break;
      case 7:
        do
        {
          v13 = 4 * ((0xCF1BBCDCBFA56300 * *(_QWORD *)(v5 + v6)) >> v9);
          *(_DWORD *)(v7 + 4 * (v6 & v8)) = *(_DWORD *)(v3 + v13);
          *(_DWORD *)(v3 + v13) = v6++;
        }
        while (v6 < ((_DWORD)a2 - v5));
        break;
      case 8:
        do
        {
          v14 = 4 * ((0xCF1BBCDCB7A56463 * *(_QWORD *)(v5 + v6)) >> v9);
          *(_DWORD *)(v7 + 4 * (v6 & v8)) = *(_DWORD *)(v3 + v14);
          *(_DWORD *)(v3 + v14) = v6++;
        }
        while (v6 < ((_DWORD)a2 - v5));
        break;
      default:
        do
        {
          v11 = 4 * ((-1640531535 * *(_DWORD *)(v5 + v6)) >> (32 - v4));
          *(_DWORD *)(v7 + 4 * (v6 & v8)) = *(_DWORD *)(v3 + v11);
          *(_DWORD *)(v3 + v11) = v6++;
        }
        while (v6 < ((_DWORD)a2 - v5));
        break;
    }
  }
  *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v5;
  switch(v2)
  {
    case 5:
      v15 = *a2;
      v16 = -1157627904;
      goto LABEL_17;
    case 6:
      v15 = *a2;
      v16 = -1080360960;
      goto LABEL_17;
    case 7:
      v15 = *a2;
      v16 = -1079680256;
      goto LABEL_17;
    case 8:
      v15 = *a2;
      v16 = -1213897629;
LABEL_17:
      result = *(unsigned int *)(v3 + 4 * ((v15 * (v16 | 0xCF1BBCDC00000000)) >> -(char)v4));
      break;
    default:
      result = *(unsigned int *)(v3 + 4 * ((-1640531535 * *(_DWORD *)a2) >> -(char)v4));
      break;
  }
  return result;
}

uint64_t ZSTD_dedicatedDictSearch_lazy_loadDictionary(uint64_t result, int a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  unint64_t v8;
  BOOL v9;
  unsigned int v10;
  int v11;
  char v12;
  uint64_t v13;
  unsigned int v14;
  unint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int *v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  unint64_t v35;
  char v36;
  char v37;
  unint64_t v38;
  unint64_t v39;
  _QWORD *v40;

  v2 = *(_QWORD *)(result + 8);
  v3 = a2 - v2;
  v4 = *(_QWORD *)(result + 48);
  v5 = *(_QWORD *)(result + 64);
  v6 = *(_DWORD *)(result + 200);
  v7 = 1 << *(_DWORD *)(result + 196);
  v8 = *(unsigned int *)(result + 36);
  v9 = v3 >= v7;
  v10 = v3 - v7;
  if (v10 == 0 || !v9)
    v10 = *(_DWORD *)(result + 36);
  if (((1 << *(_DWORD *)(result + 204)) - 3) >= 0xFF)
    v11 = 255;
  else
    v11 = (1 << *(_DWORD *)(result + 204)) - 3;
  v12 = v6 - 2;
  v13 = v4 + 4 * (1 << (v6 - 2));
  v14 = 3 << (v6 - 2);
  v9 = v3 >= v14;
  LODWORD(v15) = v3 - v14;
  if ((_DWORD)v15 != 0 && v9)
    v15 = v15;
  else
    v15 = v8;
  if (v8 < v3)
  {
    v16 = 66 - v6;
    do
    {
      switch(*(_DWORD *)(result + 208))
      {
        case 5:
          v17 = ((0xCF1BBCDCBB000000 * *(_QWORD *)(v2 + v8)) >> v16);
          if (v8 >= v15)
            goto LABEL_11;
          break;
        case 6:
          v17 = ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v2 + v8)) >> v16);
          if (v8 >= v15)
            goto LABEL_11;
          break;
        case 7:
          v17 = ((0xCF1BBCDCBFA56300 * *(_QWORD *)(v2 + v8)) >> v16);
          if (v8 >= v15)
            goto LABEL_11;
          break;
        case 8:
          v17 = ((0xCF1BBCDCB7A56463 * *(_QWORD *)(v2 + v8)) >> v16);
          if (v8 >= v15)
            goto LABEL_11;
          break;
        default:
          v17 = (-1640531535 * *(_DWORD *)(v2 + v8)) >> (34 - v6);
          if (v8 >= v15)
LABEL_11:
            *(_DWORD *)(v13 + 4 * (v8 - v15)) = *(_DWORD *)(v4 + 4 * v17);
          break;
      }
      *(_DWORD *)(v4 + 4 * v17) = v8++;
    }
    while (v8 < v3);
  }
  v18 = 0;
  v19 = 0;
  v20 = (1 << v12);
  do
  {
    v22 = *(_DWORD *)(v4 + 4 * v18);
    v23 = v22 - v15;
    if (v22 < v15)
      goto LABEL_25;
    v24 = v22 < v10;
    v25 = *(_DWORD *)(v13 + 4 * v23);
    if (v25 < v15)
      goto LABEL_25;
    if (v25 < v10)
      ++v24;
    v26 = *(_DWORD *)(v13 + 4 * (v25 - v15));
    if (v26 < v15)
      goto LABEL_25;
    if (v26 < v10)
      ++v24;
    v27 = *(_DWORD *)(v13 + 4 * (v26 - v15));
    if (!v11)
    {
LABEL_25:
      v21 = 0;
      goto LABEL_26;
    }
    v28 = 0;
    while (v27 >= v10)
    {
LABEL_41:
      *(_DWORD *)(v5 + 4 * (v19 + v28++)) = v27;
      v9 = v27 >= v15;
      v29 = v27 - v15;
      if (!v9)
      {
        v21 = v28 + (v19 << 8);
        v19 += v28;
        goto LABEL_26;
      }
      v27 = *(_DWORD *)(v13 + 4 * v29);
      if (v11 == v28)
      {
        v19 += v28;
        v28 = v11;
        goto LABEL_46;
      }
    }
    if (v27 && v24 <= 3)
    {
      ++v24;
      goto LABEL_41;
    }
    v19 += v28;
    if (!v28)
      goto LABEL_25;
LABEL_46:
    v21 = v28 + ((v19 - v28) << 8);
LABEL_26:
    *(_DWORD *)(v4 + 4 * v18++) = v21;
  }
  while (v18 != v20);
  v30 = (4 << v12) - 4;
  v31 = (int *)(v4 + 4 * (v20 - 1));
  v32 = 4 * v20 - 1;
  do
  {
    v33 = v4 + 4 * v30;
    v34 = *v31--;
    *(_DWORD *)(v33 + 8) = 0;
    *(_QWORD *)v33 = 0;
    *(_DWORD *)(v4 + 4 * v32) = v34;
    v30 -= 4;
    v32 -= 4;
    LODWORD(v20) = v20 - 1;
  }
  while ((_DWORD)v20);
  v35 = *(unsigned int *)(result + 36);
  if (v35 < v3)
  {
    v36 = 66 - v6;
    v37 = 34 - v6;
    do
    {
      switch(*(_DWORD *)(result + 208))
      {
        case 5:
          v38 = 0xCF1BBCDCBB000000 * *(_QWORD *)(v2 + v35);
          goto LABEL_52;
        case 6:
          v38 = 0xCF1BBCDCBF9B0000 * *(_QWORD *)(v2 + v35);
          goto LABEL_52;
        case 7:
          v38 = 0xCF1BBCDCBFA56300 * *(_QWORD *)(v2 + v35);
          goto LABEL_52;
        case 8:
          v38 = 0xCF1BBCDCB7A56463 * *(_QWORD *)(v2 + v35);
LABEL_52:
          v39 = v38 >> v36;
          break;
        default:
          LODWORD(v39) = (-1640531535 * *(_DWORD *)(v2 + v35)) >> v37;
          break;
      }
      v40 = (_QWORD *)(v4 + 4 * (4 * v39));
      *(_QWORD *)((char *)v40 + 4) = *v40;
      *(_DWORD *)v40 = v35++;
    }
    while (v35 < v3);
  }
  *(_DWORD *)(result + 36) = v3;
  return result;
}

_DWORD *ZSTD_ldm_adjustParameters(_DWORD *result, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;

  v2 = *a2;
  result[5] = *a2;
  if (result[3])
  {
    v3 = result[1];
    if (v3)
      goto LABEL_3;
  }
  else
  {
    result[3] = 64;
    v3 = result[1];
    if (v3)
    {
LABEL_3:
      v4 = result[2];
      if (result[4])
        goto LABEL_4;
      goto LABEL_14;
    }
  }
  v3 = v2 - 7;
  if (v2 - 7 <= 6)
    v3 = 6;
  result[1] = v3;
  v4 = result[2];
  if (!result[4])
  {
LABEL_14:
    v6 = v2 >= v3;
    v7 = v2 - v3;
    if (!v6)
      v7 = 0;
    result[4] = v7;
  }
LABEL_4:
  if (v4)
    v5 = v4;
  else
    v5 = 3;
  if (v5 >= v3)
    v5 = v3;
  result[2] = v5;
  return result;
}

uint64_t ZSTD_ldm_getTableSize(_DWORD *a1)
{
  unsigned int v1;
  unsigned int v2;
  uint64_t v3;

  v2 = a1[1];
  v1 = a1[2];
  if (v1 >= v2)
    LOBYTE(v1) = a1[1];
  v3 = (1 << (v2 - v1)) + (8 << v2);
  if (*a1)
    return v3;
  else
    return 0;
}

unint64_t ZSTD_ldm_getMaxNbSeq(_DWORD *a1, unint64_t a2)
{
  if (*a1)
    return a2 / a1[3];
  else
    return 0;
}

unint64_t ZSTD_ldm_fillHashTable(unint64_t result, unint64_t a2, unint64_t a3, _DWORD *a4)
{
  int v4;
  int v5;
  int v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  char v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  char v22;
  uint64_t v23;
  unsigned __int8 v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30[2];

  v4 = a4[1];
  v5 = a4[2];
  v28 = *(_QWORD *)(result + 8);
  v7 = a4[3];
  v6 = a4[4];
  if (v7 >= 0x40)
    v8 = 64;
  else
    v8 = a4[3];
  v9 = v6 - 1;
  v10 = ~(-1 << v6);
  v11 = v8 - v6;
  if (v9 >= v8)
    v11 = 0;
  v30[0] = 0xFFFFFFFFLL;
  v30[1] = v10 << v11;
  if (a2 < a3)
  {
    v12 = a2;
    v13 = result;
    v25 = a3;
    v26 = result + 56;
    v15 = a2 + v7;
    v16 = ~(-1 << (v4 - v5));
    do
    {
      v29 = 0;
      result = ZSTD_ldm_gear_feed(v30, v12, a3 - v12, v26, &v29);
      v27 = result;
      v17 = v29;
      if (v29)
      {
        v18 = (uint64_t *)v26;
        do
        {
          v19 = *v18++;
          v20 = v12 + v19;
          if (v12 + v19 >= v15)
          {
            v21 = v20 - v7;
            result = ZSTD_XXH64((unsigned int *)(v20 - v7), v7);
            v22 = a4[2];
            v23 = *(_QWORD *)(v13 + 48);
            v24 = *(_BYTE *)(v23 + (result & v16));
            *(_QWORD *)(*(_QWORD *)(v13 + 32) + 8 * ((result & v16) << v22) + 8 * v24) = result & 0xFFFFFFFF00000000 | (v21 - v28);
            *(_BYTE *)(v23 + (result & v16)) = (v24 + 1) & ~(-1 << v22);
          }
          --v17;
        }
        while (v17);
      }
      v12 += v27;
      a3 = v25;
    }
    while (v12 < v25);
  }
  return result;
}

unint64_t ZSTD_ldm_gear_feed(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;

  v5 = *a1;
  v6 = a1[1];
  if (a3 < 4)
  {
    v12 = 0;
LABEL_18:
    if (v12 < a3)
    {
      v5 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(a2 + v12)] + 2 * v5;
      v17 = v12 + 1;
      if ((v5 & v6) == 0)
        goto LABEL_22;
      while (v17 < a3)
      {
        while (1)
        {
          ++v12;
          v5 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(a2 + v12)] + 2 * v5;
          v17 = v12 + 1;
          if ((v5 & v6) != 0)
            break;
LABEL_22:
          v18 = *a5;
          *(_QWORD *)(a4 + 8 * v18) = v17;
          LODWORD(v18) = v18 + 1;
          *a5 = v18;
          if ((_DWORD)v18 == 64 || v17 >= a3)
            goto LABEL_27;
        }
      }
LABEL_27:
      ++v12;
    }
    *a1 = v5;
    return v12;
  }
  else
  {
    v7 = 0;
    v8 = a2 + 1;
    while (1)
    {
      v9 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(a2 + v7)] + 2 * v5;
      if ((v9 & v6) == 0)
      {
        v13 = *a5;
        *(_QWORD *)(a4 + 8 * v13) = v7 + 1;
        *a5 = v13 + 1;
        if ((_DWORD)v13 == 63)
        {
          *a1 = v9;
          return v7 + 1;
        }
      }
      v10 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v8 + v7)] + 2 * v9;
      if ((v10 & v6) == 0)
      {
        v14 = *a5;
        *(_QWORD *)(a4 + 8 * v14) = v7 + 2;
        *a5 = v14 + 1;
        if ((_DWORD)v14 == 63)
        {
          *a1 = v10;
          return v7 + 2;
        }
      }
      v11 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v8 + v7 + 1)] + 2 * v10;
      if ((v11 & v6) == 0)
      {
        v15 = *a5;
        *(_QWORD *)(a4 + 8 * v15) = v7 + 3;
        *a5 = v15 + 1;
        if ((_DWORD)v15 == 63)
        {
          *a1 = v11;
          return v7 + 3;
        }
      }
      v5 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v8 + v7 + 2)] + 2 * v11;
      v12 = v7 + 4;
      if ((v5 & v6) == 0)
      {
        v16 = *a5;
        *(_QWORD *)(a4 + 8 * v16) = v12;
        LODWORD(v16) = v16 + 1;
        *a5 = v16;
        if ((_DWORD)v16 == 64)
          break;
      }
      v7 += 4;
      if (v12 + 3 >= a3)
        goto LABEL_18;
    }
    *a1 = v5;
    return v7 + 4;
  }
}

unint64_t ZSTD_XXH64(unsigned int *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unsigned int *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  BOOL v15;
  unint64_t v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  unint64_t v27;
  unsigned int v28;
  unint64_t v29;

  v2 = (unint64_t)a1 + a2;
  v3 = 0x27D4EB2F165667C5;
  v4 = a1;
  if ((a1 & 7) != 0)
  {
    if (a2 >= 0x20)
    {
      v18 = 0;
      v19 = 0x61C8864E7A143579;
      v20 = 0x60EA27EEADC0B5D6;
      v21 = 0xC2B2AE3D27D4EB4FLL;
      v4 = a1;
      do
      {
        v22 = __ROR8__(v20 - 0x3D4D51C2D82B14B1 * *(_QWORD *)v4, 33);
        v20 = 0x9E3779B185EBCA87 * v22;
        v23 = __ROR8__(v21 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 1), 33);
        v21 = 0x9E3779B185EBCA87 * v23;
        v24 = __ROR8__(v18 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 2), 33);
        v18 = 0x9E3779B185EBCA87 * v24;
        v25 = __ROR8__(v19 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 3), 33);
        v19 = 0x9E3779B185EBCA87 * v25;
        v4 += 8;
      }
      while ((unint64_t)v4 <= v2 - 32);
      v5 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * ((0x85EBCA77C2B2AE63
           - 0x61C8864E7A143579
           * ((0x85EBCA77C2B2AE63
             - 0x61C8864E7A143579
             * ((0x85EBCA77C2B2AE63
               - 0x61C8864E7A143579
               * ((__ROR8__(v21, 57) + __ROR8__(v20, 63) + __ROR8__(v18, 52) + __ROR8__(v19, 46)) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v22, 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v23, 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v24, 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v25, 33)))
         + a2;
      if ((unint64_t)(v4 + 2) > v2)
        goto LABEL_22;
    }
    else
    {
      v5 = a2 + 0x27D4EB2F165667C5;
      if ((unint64_t)(a1 + 2) > v2)
      {
LABEL_22:
        v26 = v4;
LABEL_25:
        if ((unint64_t)(v26 + 1) <= v2)
          v5 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * *v26++) ^ v5, 41);
        if ((unint64_t)v26 < v2)
        {
          v27 = (char *)a1 + a2 - (char *)v26;
          do
          {
            v28 = *(unsigned __int8 *)v26;
            v26 = (unsigned int *)((char *)v26 + 1);
            v5 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v28) ^ v5, 53);
            --v27;
          }
          while (v27);
        }
        goto LABEL_30;
      }
    }
    do
    {
      v26 = v4 + 2;
      v5 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * __ROR8__((0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * *(_QWORD *)v4, 33)) ^ v5, 37);
      v15 = (unint64_t)(v4 + 4) > v2;
      v4 += 2;
    }
    while (!v15);
    goto LABEL_25;
  }
  if (a2 >= 0x20)
  {
    v6 = 0;
    v7 = 0x61C8864E7A143579;
    v8 = 0x60EA27EEADC0B5D6;
    v9 = 0xC2B2AE3D27D4EB4FLL;
    v4 = a1;
    do
    {
      v10 = __ROR8__(v8 - 0x3D4D51C2D82B14B1 * *(_QWORD *)v4, 33);
      v8 = 0x9E3779B185EBCA87 * v10;
      v11 = __ROR8__(v9 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 1), 33);
      v9 = 0x9E3779B185EBCA87 * v11;
      v12 = __ROR8__(v6 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 2), 33);
      v6 = 0x9E3779B185EBCA87 * v12;
      v13 = __ROR8__(v7 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 3), 33);
      v7 = 0x9E3779B185EBCA87 * v13;
      v4 += 8;
    }
    while ((unint64_t)v4 <= v2 - 32);
    v3 = 0x85EBCA77C2B2AE63
       - 0x61C8864E7A143579
       * ((0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * ((0x85EBCA77C2B2AE63
           - 0x61C8864E7A143579
           * ((0x85EBCA77C2B2AE63
             - 0x61C8864E7A143579
             * ((__ROR8__(v9, 57) + __ROR8__(v8, 63) + __ROR8__(v6, 52) + __ROR8__(v7, 46)) ^ (0x9E3779B185EBCA87
                                                                                             * __ROR8__(0xDEF35B010F796CA9* v10, 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v11, 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v12, 33)))) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v13, 33)));
  }
  v5 = v3 + a2;
  if ((unint64_t)(v4 + 2) <= v2)
  {
    do
    {
      v14 = v4 + 2;
      v5 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * __ROR8__((0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * *(_QWORD *)v4, 33)) ^ v5, 37);
      v15 = (unint64_t)(v4 + 4) > v2;
      v4 += 2;
    }
    while (!v15);
  }
  else
  {
    v14 = v4;
  }
  if ((unint64_t)(v14 + 1) <= v2)
    v5 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * *v14++) ^ v5, 41);
  if ((unint64_t)v14 < v2)
  {
    v16 = (char *)a1 + a2 - (char *)v14;
    do
    {
      v17 = *(unsigned __int8 *)v14;
      v14 = (unsigned int *)((char *)v14 + 1);
      v5 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v17) ^ v5, 53);
      --v16;
    }
    while (v16);
  }
LABEL_30:
  v29 = 0x165667B19E3779F9
      * ((0xC2B2AE3D27D4EB4FLL * (v5 ^ (v5 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (v5 ^ (v5 >> 33))) >> 29));
  return v29 ^ HIDWORD(v29);
}

unint64_t ZSTD_ldm_generateSequences(int32x2_t *a1, _QWORD *a2, _DWORD *a3, uint64_t a4, unint64_t a5)
{
  uint64_t v5;
  unint64_t result;
  uint64_t v8;
  unsigned int v9;
  char *v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  char *v16;
  int32x2_t v17;
  unsigned int v18;
  unsigned __int32 v19;
  unsigned int v20;
  int v21;
  int v22;
  int32x2_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int32x2_t v28;
  int32x2_t v29;
  int32x2_t v30;
  int8x8_t v31;
  int32x2_t v32;
  uint64_t v33;
  uint64_t v34;
  uint32x4_t v35;
  uint64_t v36;
  float *v37;
  const float *v38;
  unsigned __int128 v39;
  uint32x4_t v40;
  uint64_t v41;
  _DWORD *v42;
  int v43;
  unsigned int v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  unint64_t v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unsigned int v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t *v69;
  uint64_t *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v80;
  uint64_t v81;
  int32x2_t *v82;
  int32x2_t v83;
  unsigned int v84;
  _QWORD *v85;
  unint64_t v86;
  char v87;
  int32x2_t v88;
  unsigned __int8 v89;
  int32x2_t *v90;
  char *v91;
  uint64_t v92;
  unsigned int v93;
  int32x2_t *v94;
  unsigned int v95;
  unsigned int *v96;
  unsigned int *v97;
  unsigned int *v98;
  unint64_t v99;
  int v100;
  unint64_t v101;
  _QWORD *v102;
  uint64_t v103;
  uint64_t v104;
  int32x2_t v105;
  char *v106;
  char *v107;
  char *v108;
  unint64_t v109;
  unint64_t v110;
  char *v111;
  _DWORD *v112;
  char *v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  char *v117;
  _DWORD *v118;
  int64_t v119;
  unsigned __int8 *v120;
  unsigned __int8 *v121;
  unsigned __int8 *v122;
  BOOL v123;
  uint64_t v124;
  unsigned __int8 *v125;
  unsigned __int8 *v126;
  char *v127;
  char *v128;
  uint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  _QWORD *v133;
  uint64_t v134;
  _DWORD *v135;
  unint64_t v136;
  unint64_t v137;
  _DWORD *v138;
  uint64_t v139;
  unsigned __int8 *v140;
  unsigned __int8 *v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  unsigned int *v146;
  unsigned int v147;
  unint64_t v148;
  char v149;
  int32x2_t v150;
  unint64_t v151;
  char v152;
  int32x2_t v153;
  unsigned __int8 v154;
  unint64_t v155;
  unint64_t v156;
  uint64_t v157;
  int v158;
  char *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  unint64_t v163;
  int v164;
  uint64_t v165;
  uint64_t *v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unsigned __int8 *v173;
  uint64_t v174;
  _QWORD *v176;
  uint64_t v177;
  unsigned int v178;
  unint64_t v179;
  int32x2_t *v180;
  uint64_t v181;
  uint64_t v182;
  int32x2_t *v183;
  int32x2_t v184;
  unint64_t v185;
  unint64_t v186;
  unsigned int v187;
  _DWORD *v188;
  char *v189;
  int32x2_t v190;
  unsigned int v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  unsigned int v195;
  uint64_t v196[3];

  if ((a5 & 0xFFFFF) != 0)
    v5 = (a5 >> 20) + 1;
  else
    v5 = a5 >> 20;
  if (!v5)
    return 0;
  result = 0;
  v8 = 0;
  v9 = 1 << a3[5];
  v10 = (char *)(a4 + a5);
  v11 = ~v9;
  v12 = (uint64_t)&a1[7];
  v180 = a1 + 71;
  v174 = a4;
  v13 = a2[3];
  v14 = a4 + 1;
  v166 = (uint64_t *)&a1[73];
LABEL_8:
  if (v13 < a2[4])
  {
    v169 = result;
    v15 = (unsigned __int8 *)(a4 + (v8 << 20));
    if ((unint64_t)(v10 - (char *)v15) >= 0x100000)
      v16 = (char *)(v15 + 0x100000);
    else
      v16 = v10;
    v17 = a1[1];
    v18 = (_DWORD)v16 - v17.i32[0];
    if (((_DWORD)v16 - v17.i32[0]) > 0xE0000000)
    {
      v25 = a3[1];
      v26 = 1 << v25;
      v27 = ((_DWORD)v15 - v17.i32[0] + v11);
      v28 = (int32x2_t)(*(_QWORD *)&a1[2] + v27);
      a1[1] = (int32x2_t)(*(_QWORD *)&v17 + v27);
      a1[2] = v28;
      v29 = a1[3];
      v30 = vdup_n_s32(v27);
      v31 = (int8x8_t)vcgt_u32((uint32x2_t)v29, (uint32x2_t)v30);
      a1[3] = vsub_s32((int32x2_t)vand_s8((int8x8_t)vsub_s32(v29, v30), v31), (int32x2_t)vmvn_s8(v31));
      v32 = a1[4];
      if (v25 >= 3)
      {
        v34 = (1 << v25) & 3;
        if ((v26 & 3) == 0)
          v34 = 4;
        v33 = v26 - v34;
        v35 = (uint32x4_t)vdupq_n_s32(v27);
        v36 = v33;
        v37 = (float *)a1[4];
        v38 = v37;
        do
        {
          v39 = (unsigned __int128)vld2q_f32(v38);
          v38 += 8;
          v40 = vqsubq_u32((uint32x4_t)v39, v35);
          *v37 = *(float *)v40.i32;
          v37[2] = *(float *)&v40.i32[1];
          v37[4] = *(float *)&v40.i32[2];
          v37[6] = *(float *)&v40.i32[3];
          v37 = (float *)v38;
          v36 -= 4;
        }
        while (v36);
      }
      else
      {
        v33 = 0;
      }
      v41 = v26 - v33;
      v42 = (_DWORD *)(*(_QWORD *)&v32 + 8 * v33);
      do
      {
        v43 = *v42 - v27;
        if (*v42 < v27)
          v43 = 0;
        *v42 = v43;
        v42 += 2;
        --v41;
      }
      while (v41);
      a1[5].i32[0] = 0;
      v184 = a1[1];
      v18 = (_DWORD)v16 - v184.i32[0];
      v19 = a1[3].u32[1];
      if (v9 >= (int)v16 - v184.i32[0])
      {
LABEL_14:
        v20 = a1[3].u32[0];
        v192 = a3[3];
        v22 = a3[1];
        v21 = a3[2];
        if (v19 >= v20)
        {
LABEL_15:
          v23 = 0;
          v24 = v20;
LABEL_33:
          v45 = v16 - (char *)v15;
          if (v19 >= v20)
            v46 = 0;
          else
            v46 = *(_QWORD *)&v23 + v24;
          v47 = (char *)(*(_QWORD *)&v23 + v20);
          if (v19 >= v20)
            v48 = 0;
          else
            v48 = *(_QWORD *)&v23 + v20;
          result = v16 - (char *)v15;
          if (v45 < v192)
            goto LABEL_209;
          v179 = v48;
          v194 = v46;
          v191 = v24;
          v190 = v23;
          v167 = v16 - (char *)v15;
          v178 = v19;
          v49 = a3[4];
          if (v192 >= 0x40)
            v50 = 64;
          else
            v50 = v192;
          v51 = v49 - 1;
          v52 = ~(-1 << v49);
          v53 = v50 - v49;
          if (v51 >= v50)
            v53 = 0;
          v54 = v52 << v53;
          v196[0] = 0xFFFFFFFFLL;
          v196[1] = v54;
          v189 = v47;
          if ((_DWORD)v192)
          {
            v55 = 0;
            v56 = 0xFFFFFFFFLL;
            v57 = v192;
            while (1)
            {
              v59 = v57 - v55;
              if (v59 < 4)
              {
                v60 = 0;
                v58 = 0;
LABEL_66:
                if (v58 >= v59)
                  goto LABEL_48;
                do
                {
                  while (1)
                  {
                    v61 = v58;
                    v56 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v174 + v55 + v58++)] + 2 * v56;
                    if ((v56 & v54) == 0)
                      break;
                    if (v58 >= v59)
                      goto LABEL_47;
                  }
                  *(_QWORD *)(v12 + 8 * v60++) = v58;
                }
                while (v60 != 64 && v58 < v59);
              }
              else
              {
                v60 = 0;
                v61 = 0;
                v62 = v14 + v55;
                while (1)
                {
                  v56 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v62 + v61 - 1)] + 2 * v56;
                  if ((v56 & v54) == 0)
                  {
                    *(_QWORD *)(v12 + 8 * v60++) = v61 + 1;
                    if (v60 == 64)
                      break;
                  }
                  v56 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v62 + v61)] + 2 * v56;
                  if ((v56 & v54) == 0)
                  {
                    *(_QWORD *)(v12 + 8 * v60++) = v61 + 2;
                    if (v60 == 64)
                    {
                      v58 = v61 + 2;
                      goto LABEL_48;
                    }
                  }
                  v56 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v62 + v61 + 1)] + 2 * v56;
                  if ((v56 & v54) == 0)
                  {
                    *(_QWORD *)(v12 + 8 * v60++) = v61 + 3;
                    if (v60 == 64)
                    {
                      v58 = v61 + 3;
                      goto LABEL_48;
                    }
                  }
                  v56 = ZSTD_ldm_gearTab[*(unsigned __int8 *)(v62 + v61 + 2)] + 2 * v56;
                  v58 = v61 + 4;
                  if ((v56 & v54) == 0)
                  {
                    *(_QWORD *)(v12 + 8 * v60++) = v58;
                    if (v60 == 64)
                    {
                      v58 = v61 + 4;
                      goto LABEL_48;
                    }
                  }
                  v61 += 4;
                  if (v58 + 3 >= v59)
                    goto LABEL_66;
                }
              }
LABEL_47:
              v58 = v61 + 1;
LABEL_48:
              v55 += v58;
              v57 = v192;
              if (v55 >= v192)
              {
                v196[0] = v56;
                break;
              }
            }
          }
          v63 = (unint64_t)v16;
          v64 = v16 - 8;
          if (&v15[v192] >= (unsigned __int8 *)v16 - 8)
            goto LABEL_208;
          v156 = v13;
          v157 = v14;
          v158 = v11;
          v159 = v10;
          v160 = v8;
          v161 = v5;
          v183 = a1;
          v162 = a4;
          v177 = 1 << v21;
          v186 = (unint64_t)(v16 - 3);
          v193 = (unint64_t)v16;
          v185 = (unint64_t)(v16 - 1);
          v182 = *(_QWORD *)&v184 + 8;
          v172 = *(_QWORD *)&v184 + 8 + v20;
          v173 = (unsigned __int8 *)(v48 - 1);
          v65 = v192;
          v66 = (uint64_t)&v15[v192];
          v188 = a3;
          v165 = v12;
          v187 = v20;
          v168 = (unint64_t)(v16 - 8);
          v176 = (_QWORD *)(*(_QWORD *)&v184 + v20);
          v164 = ~(-1 << (v22 - v21));
          v163 = (unint64_t)(v16 - 7);
LABEL_78:
          v195 = 0;
          v170 = ZSTD_ldm_gear_feed(v196, v66, (unint64_t)&v64[-v66], v12, &v195);
          v171 = v66;
          v67 = v195;
          if (!v195)
          {
            a3 = v188;
            goto LABEL_77;
          }
          v68 = v66 - v192;
          v69 = v166;
          v70 = (uint64_t *)v12;
          v181 = v195;
          do
          {
            v71 = *v70++;
            v72 = ZSTD_XXH64((unsigned int *)(v68 + v71), v65);
            a3 = v188;
            v73 = v72 & v164;
            *(v69 - 2) = v68 + v71;
            *((_DWORD *)v69 - 2) = v73;
            *((_DWORD *)v69 - 1) = HIDWORD(v72);
            _X8 = *(_QWORD *)&v183[4] + 8 * (v73 << v188[2]);
            *v69 = _X8;
            v69 += 3;
            __asm { PRFM            #0, [X8] }
            --v67;
          }
          while (v67);
          v80 = 0;
          v12 = v165;
          v82 = v180;
          v81 = v181;
          v83 = v184;
          v84 = v191;
          v85 = v176;
LABEL_83:
          while (1)
          {
            v90 = &v82[3 * v80];
            v91 = (char *)*v90;
            v94 = v90 + 1;
            v92 = v90[1].u32[0];
            v93 = v94->u32[1];
            v95 = (_DWORD)v91 - v83.i32[0];
            if (v91 >= (char *)v15)
              break;
            v86 = ((_DWORD)v91 - v83.i32[0]) | ((unint64_t)v93 << 32);
            v87 = a3[2];
            v88 = v183[6];
            v89 = *(_BYTE *)(*(_QWORD *)&v88 + v92);
            *(_QWORD *)(*(_QWORD *)&v183[4] + 8 * (v92 << v87) + 8 * v89) = v86;
            *(_BYTE *)(*(_QWORD *)&v88 + v92) = (v89 + 1) & ~(-1 << v87);
            if (++v80 == v81)
              goto LABEL_77;
          }
          v96 = (unsigned int *)v82[3 * v80 + 2];
          v97 = &v96[2 * v177];
          if (v178 < v187)
          {
            v98 = 0;
            v99 = 0;
            v100 = 0;
            v101 = 0;
            v102 = v91 + 8;
            while (1)
            {
              if (v96[1] != v93)
                goto LABEL_89;
              v104 = *v96;
              if (v104 <= v84)
                goto LABEL_89;
              if (v104 >= v187)
                v105 = v83;
              else
                v105 = v190;
              v106 = (char *)(*(_QWORD *)&v105 + v104);
              if (v104 >= v187)
                v107 = (char *)v193;
              else
                v107 = v189;
              v108 = &v91[v107 - v106];
              if ((unint64_t)v108 >= v193)
                v108 = (char *)v193;
              if (v108 - 7 <= v91)
              {
                v111 = v91;
                v112 = (_DWORD *)(*(_QWORD *)&v105 + v104);
                if (v91 < v108 - 3)
                {
LABEL_106:
                  if (*v112 == *(_DWORD *)v111)
                  {
                    v111 += 4;
                    ++v112;
                  }
                }
              }
              else
              {
                v109 = *(_QWORD *)v91 ^ *(_QWORD *)v106;
                if (v109)
                {
                  v110 = __clz(__rbit64(v109)) >> 3;
                  v83 = v184;
                  if (&v106[v110] != v107)
                    goto LABEL_103;
                  goto LABEL_117;
                }
                while (1)
                {
                  v111 = (char *)v102 + v109;
                  if ((char *)v102 + v109 >= v108 - 7)
                    break;
                  v115 = *(_QWORD *)(*(_QWORD *)&v105 + v104 + 8 + v109);
                  v109 += 8;
                  v116 = *(_QWORD *)v111 ^ v115;
                  if (v116)
                  {
                    v110 = v109 + (__clz(__rbit64(v116)) >> 3);
                    v83 = v184;
                    v65 = v192;
                    v84 = v191;
                    v85 = v176;
                    if (&v106[v110] != v107)
                      goto LABEL_103;
                    goto LABEL_117;
                  }
                }
                v112 = (_DWORD *)(*(_QWORD *)&v105 + v104 + v109 + 8);
                v83 = v184;
                v85 = v176;
                if (v111 < v108 - 3)
                  goto LABEL_106;
              }
              if (v111 >= v108 - 1)
                break;
              if (*(unsigned __int16 *)v112 == *(unsigned __int16 *)v111)
              {
                v111 += 2;
                v112 = (_DWORD *)((char *)v112 + 2);
              }
              if (v111 < v108)
                goto LABEL_114;
LABEL_116:
              v110 = v111 - v91;
              v65 = v192;
              v84 = v191;
              if (&v106[v110] != v107)
              {
LABEL_103:
                if (v110 >= v65)
                  goto LABEL_137;
                goto LABEL_89;
              }
LABEL_117:
              v113 = &v91[v110];
              if (v163 <= (unint64_t)&v91[v110])
              {
                v117 = &v91[v110];
                v118 = v85;
                if ((unint64_t)v113 < v186)
                {
LABEL_126:
                  if (*v118 == *(_DWORD *)v117)
                  {
                    v117 += 4;
                    ++v118;
                  }
                }
              }
              else
              {
                v114 = *(_QWORD *)v113 ^ *v85;
                if (v114)
                {
                  v110 += __clz(__rbit64(v114)) >> 3;
                  if (v110 >= v65)
                    goto LABEL_137;
                  goto LABEL_89;
                }
                v127 = (char *)v102 + v110;
                while (1)
                {
                  v128 = &v127[v114];
                  if ((unint64_t)&v127[v114] >= v163)
                    break;
                  v129 = *(_QWORD *)(v172 + v114);
                  v114 += 8;
                  v130 = *(_QWORD *)v128 ^ v129;
                  if (v130)
                  {
                    v131 = v114 + (__clz(__rbit64(v130)) >> 3);
                    v83 = v184;
                    v65 = v192;
                    v84 = v191;
                    v110 += v131;
                    if (v110 < v192)
                      goto LABEL_89;
                    goto LABEL_137;
                  }
                }
                v117 = (char *)v102 + v110 + v114;
                v118 = (_DWORD *)(v172 + v114);
                v83 = v184;
                if ((unint64_t)v117 < v186)
                  goto LABEL_126;
              }
              if ((unint64_t)v117 >= v185)
              {
                if ((unint64_t)v117 >= v193)
                  goto LABEL_136;
LABEL_134:
                v83 = v184;
                if (*(unsigned __int8 *)v118 == *v117)
                  ++v117;
                goto LABEL_136;
              }
              if (*(unsigned __int16 *)v118 == *(unsigned __int16 *)v117)
              {
                v117 += 2;
                v118 = (_DWORD *)((char *)v118 + 2);
              }
              if ((unint64_t)v117 < v193)
                goto LABEL_134;
LABEL_136:
              v119 = v117 - v113;
              v65 = v192;
              v84 = v191;
              v110 += v119;
              if (v110 >= v192)
              {
LABEL_137:
                v103 = 0;
                if (v104 >= v187)
                  v120 = (unsigned __int8 *)v85;
                else
                  v120 = (unsigned __int8 *)v194;
                if (v91 > (char *)v15 && v106 > (char *)v120)
                {
                  v103 = 0;
                  v121 = (unsigned __int8 *)(*(_QWORD *)&v105 + v104 - 1);
                  v122 = (unsigned __int8 *)(v91 - 1);
                  do
                  {
                    if (*v122 != *v121)
                      break;
                    ++v103;
                    if (v122 <= v15)
                      break;
                    --v122;
                    v123 = v121-- > v120;
                  }
                  while (v123);
                }
                if (v120 == (unsigned __int8 *)v194 || &v106[-v103] != (char *)v120)
                {
                  v65 = v192;
                  v84 = v191;
                }
                else
                {
                  v124 = 0;
                  v65 = v192;
                  v84 = v191;
                  if (v179 > v194 && &v91[-v103] > (char *)v15)
                  {
                    v124 = 0;
                    v125 = (unsigned __int8 *)&v91[-v103 - 1];
                    v126 = v173;
                    do
                    {
                      if (*v125 != *v126)
                        break;
                      ++v124;
                      if (v125 <= v15)
                        break;
                      --v125;
                      v123 = (unint64_t)v126-- > v194;
                    }
                    while (v123);
                  }
                  v103 += v124;
                }
                if (v103 + v110 > v99)
                {
                  v101 = v110;
                  v100 = v103;
                  v99 = v103 + v110;
                  v98 = v96;
                }
              }
LABEL_89:
              v96 += 2;
              if (v96 >= v97)
                goto LABEL_201;
            }
            if (v111 >= v108)
              goto LABEL_116;
LABEL_114:
            if (*(unsigned __int8 *)v112 == *v111)
              ++v111;
            goto LABEL_116;
          }
          v98 = 0;
          v132 = 0;
          v100 = 0;
          v101 = 0;
          v133 = v91 + 8;
          while (1)
          {
            if (v96[1] != v93)
              goto LABEL_168;
            v134 = *v96;
            if (v134 <= v84)
              goto LABEL_168;
            v135 = (_DWORD *)(*(_QWORD *)&v83 + v134);
            if (v163 <= (unint64_t)v91)
            {
              v138 = v91;
              if ((unint64_t)v91 < v186)
              {
LABEL_176:
                if (*v135 == *v138)
                {
                  ++v138;
                  ++v135;
                }
              }
            }
            else
            {
              v136 = *(_QWORD *)v91 ^ *(_QWORD *)v135;
              if (v136)
              {
                v137 = __clz(__rbit64(v136)) >> 3;
                if (v137 >= v65)
                  goto LABEL_187;
                goto LABEL_168;
              }
              v142 = 0;
              while (1)
              {
                v138 = &v133[v142];
                if ((unint64_t)&v133[v142] >= v163)
                  break;
                v143 = *(_QWORD *)(v182 + v134 + v142 * 8);
                ++v142;
                v144 = *(_QWORD *)v138 ^ v143;
                if (v144)
                {
                  v137 = v142 * 8 + (__clz(__rbit64(v144)) >> 3);
                  if (v137 < v65)
                    goto LABEL_168;
                  goto LABEL_187;
                }
              }
              v135 = (_DWORD *)(v182 + v134 + v142 * 8);
              if ((unint64_t)v138 < v186)
                goto LABEL_176;
            }
            if ((unint64_t)v138 >= v185)
              break;
            if (*(unsigned __int16 *)v135 == *(unsigned __int16 *)v138)
            {
              v138 = (_DWORD *)((char *)v138 + 2);
              v135 = (_DWORD *)((char *)v135 + 2);
            }
            if ((unint64_t)v138 < v193)
              goto LABEL_184;
LABEL_186:
            v137 = (char *)v138 - v91;
            if (v137 >= v65)
            {
LABEL_187:
              v139 = 0;
              if (v91 > (char *)v15 && v134 > v187)
              {
                v139 = 0;
                v140 = (unsigned __int8 *)(*(_QWORD *)&v184 - 1 + v134);
                v141 = (unsigned __int8 *)(v91 - 1);
                do
                {
                  if (*v141 != *v140)
                    break;
                  ++v139;
                  if (v141 <= v15)
                    break;
                  --v141;
                  v123 = v140-- > (unsigned __int8 *)v85;
                }
                while (v123);
              }
              if (v139 + v137 > v132)
              {
                v101 = v137;
                v100 = v139;
                v132 = v139 + v137;
                v98 = v96;
              }
            }
LABEL_168:
            v96 += 2;
            if (v96 >= v97)
            {
LABEL_201:
              if (v98)
              {
                v145 = a2[3];
                if (v145 == a2[4])
                  return -70;
                v146 = (unsigned int *)(*a2 + 12 * v145);
                v147 = v95 - *v98;
                v146[1] = (_DWORD)v91 - v100 - (_DWORD)v15;
                v146[2] = v100 + v101;
                *v146 = v147;
                a2[3] = v145 + 1;
                v148 = v95 | ((unint64_t)v93 << 32);
                a3 = v188;
                v149 = v188[2];
                v150 = v183[6];
                LOBYTE(v147) = *(_BYTE *)(*(_QWORD *)&v150 + v92);
                *(_QWORD *)(*(_QWORD *)&v183[4] + 8 * (v92 << v149) + 8 * v147) = v148;
                *(_BYTE *)(*(_QWORD *)&v150 + v92) = (v147 + 1) & ~(-1 << v149);
                v15 = (unsigned __int8 *)&v91[v101];
                v82 = v180;
                v81 = v181;
                if (++v80 == v181)
                  goto LABEL_77;
                goto LABEL_83;
              }
              v151 = v95 | ((unint64_t)v93 << 32);
              a3 = v188;
              v152 = v188[2];
              v153 = v183[6];
              v154 = *(_BYTE *)(*(_QWORD *)&v153 + v92);
              *(_QWORD *)(*(_QWORD *)&v183[4] + 8 * (v92 << v152) + 8 * v154) = v151;
              *(_BYTE *)(*(_QWORD *)&v153 + v92) = (v154 + 1) & ~(-1 << v152);
              v82 = v180;
              v81 = v181;
              if (++v80 != v181)
                goto LABEL_83;
LABEL_77:
              v66 = v171 + v170;
              v64 = (char *)v168;
              if (v171 + v170 < v168)
                goto LABEL_78;
              v5 = v161;
              a4 = v162;
              a1 = v183;
              v8 = v160;
              v10 = v159;
              v11 = v158;
              v13 = v156;
              v14 = v157;
              v63 = v193;
LABEL_208:
              result = v63 - (_QWORD)v15;
              v45 = v167;
LABEL_209:
              if (result > 0xFFFFFFFFFFFFFF88)
                return result;
              v155 = a2[3];
              if (v13 >= v155)
                result = v45 + v169;
              else
                *(_DWORD *)(*a2 + 12 * v13 + 4) += v169;
              ++v8;
              v14 += 0x100000;
              v174 += 0x100000;
              v13 = v155;
              if (v8 == v5)
                return 0;
              goto LABEL_8;
            }
          }
          if ((unint64_t)v138 >= v193)
            goto LABEL_186;
LABEL_184:
          if (*(unsigned __int8 *)v135 == *(unsigned __int8 *)v138)
            v138 = (_DWORD *)((char *)v138 + 1);
          goto LABEL_186;
        }
LABEL_32:
        v23 = a1[2];
        v24 = v19;
        goto LABEL_33;
      }
    }
    else
    {
      v184 = a1[1];
      v19 = a1[3].u32[1];
      if (a1[5].i32[0] + v9 >= v18)
        goto LABEL_14;
    }
    v44 = v18 - v9;
    if (v19 < v44)
    {
      a1[3].i32[1] = v44;
      v19 = v44;
    }
    v20 = a1[3].u32[0];
    if (v20 < v19)
    {
      a1[3].i32[0] = v19;
      v20 = v19;
    }
    a1[5].i32[0] = 0;
    v192 = a3[3];
    v22 = a3[1];
    v21 = a3[2];
    if (v19 >= v20)
      goto LABEL_15;
    goto LABEL_32;
  }
  return 0;
}

uint64_t *ZSTD_ldm_skipSequences(uint64_t *result, unint64_t a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  if (a2)
  {
    v3 = result[3];
    v4 = result[1];
    if (v4 <= v3)
      v5 = result[3];
    else
      v5 = result[1];
    v6 = 12 * v4;
    while (v5 != v4)
    {
      v7 = *result;
      v8 = *result + v6;
      v9 = *(unsigned int *)(v8 + 4);
      v10 = a2 - v9;
      if (a2 <= v9)
      {
        *(_DWORD *)(v8 + 4) = v9 - a2;
        return result;
      }
      *(_DWORD *)(v8 + 4) = 0;
      v11 = *(unsigned int *)(v8 + 8);
      a2 = v10 - v11;
      if (v10 < v11)
      {
        *(_DWORD *)(v7 + v6 + 8) = v11 - v10;
        if ((int)v11 - (int)v10 < a3)
        {
          v12 = v4 + 1;
          if (v12 < v3)
            *(_DWORD *)(v7 + v6 + 16) += v11 - v10;
          result[1] = v12;
        }
        return result;
      }
      *(_DWORD *)(v8 + 8) = 0;
      result[1] = ++v4;
      v6 += 12;
      if (v10 == v11)
        return result;
    }
  }
  return result;
}

uint64_t ZSTD_ldm_skipRawSeqStoreBytes(uint64_t result, int a2)
{
  unsigned int v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  unsigned int v9;

  v2 = *(_DWORD *)(result + 16) + a2;
  if (!v2)
    goto LABEL_12;
  v3 = *(_QWORD *)(result + 24);
  v4 = *(_QWORD *)(result + 8);
  v5 = v4 <= v3 ? *(_QWORD *)(result + 24) : *(_QWORD *)(result + 8);
  v6 = 12 * v4;
  while (v5 != v4)
  {
    v7 = *(_DWORD *)(*(_QWORD *)result + v6 + 8) + *(_DWORD *)(*(_QWORD *)result + v6 + 4);
    v8 = v2 >= v7;
    v9 = v2 - v7;
    if (!v8)
    {
      *(_QWORD *)(result + 16) = v2;
      break;
    }
    *(_QWORD *)(result + 8) = ++v4;
    v6 += 12;
    v2 = v9;
    if (!v9)
      goto LABEL_12;
  }
  if (v3 == v4)
LABEL_12:
    *(_QWORD *)(result + 16) = 0;
  return result;
}

uint64_t ZSTD_ldm_blockCompress(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, unint64_t a5, uint64_t a6)
{
  unint64_t v7;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t (*v15)(uint64_t, uint64_t, _QWORD *, unint64_t, uint64_t);
  uint64_t result;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  BOOL v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unsigned int *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unsigned int v46;
  int v47;
  unsigned int v48;
  unint64_t v49;
  unint64_t v50;
  __int128 *v51;
  __int128 *v52;
  __int128 *v53;
  __int128 v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  _OWORD *v59;
  unint64_t v60;
  __int128 *v61;
  __int128 v62;
  uint64_t v63;
  __int128 *v64;
  char *v65;
  __int128 *v66;
  _OWORD *v67;
  unint64_t v68;
  __int128 v69;
  uint64_t *v70;
  _QWORD *v71;
  unint64_t v72;
  uint64_t v73;
  char v74;
  unint64_t v75;
  unint64_t v76;
  unsigned int v77;
  uint64_t (*v78)(uint64_t, uint64_t, _QWORD *, unint64_t, unint64_t);

  v7 = a5;
  v12 = *(int *)(a2 + 216);
  if (*(_DWORD *)(a2 + 28) >= *(_DWORD *)(a2 + 24))
  {
    v13 = *(_QWORD *)(a2 + 184);
    if (v13)
    {
      v14 = *(_DWORD *)(v13 + 72) == 0;
      v13 = 2;
      if (!v14)
        v13 = 3;
    }
  }
  else
  {
    v13 = 1;
  }
  v15 = (uint64_t (*)(uint64_t, uint64_t, _QWORD *, unint64_t, uint64_t))*(&ZSTD_selectBlockCompressor_blockCompressor[10 * v13]
                                                                                       + v12);
  if (v12 <= 6)
  {
    v78 = (uint64_t (*)(uint64_t, uint64_t, _QWORD *, unint64_t, unint64_t))*(&ZSTD_selectBlockCompressor_blockCompressor[10 * v13]
                                                                                                  + v12);
    v25 = a5 + a6;
    v26 = *(_QWORD *)(a1 + 8);
    v27 = *(_QWORD *)(a1 + 24);
    if (v26 >= v27 || a6 < 1)
    {
LABEL_22:
      v29 = v7 - *(_DWORD *)(a2 + 8);
      v30 = *(_DWORD *)(a2 + 36);
      if (v30 + 1024 < v29)
      {
        v31 = v29 - v30 - 1024;
        if (v31 >= 0x200)
          v31 = 512;
        *(_DWORD *)(a2 + 36) = v29 - v31;
      }
      ZSTD_ldm_fillFastTables(a2, v7);
      return v78(a2, a3, a4, v7, v25 - v7);
    }
    v32 = v25 - 32;
    v77 = *(_DWORD *)(a2 + 208);
    while (1)
    {
      v33 = v25 - v7;
      v34 = *(_QWORD *)a1 + 12 * v26;
      v35 = *(_QWORD *)v34;
      v36 = HIDWORD(*(_QWORD *)v34);
      v37 = *(_DWORD *)(v34 + 8);
      if (v37 + v36 <= (int)v25 - (int)v7)
      {
        v45 = v26 + 1;
LABEL_45:
        *(_QWORD *)(a1 + 8) = v45;
      }
      else
      {
        if (v33 - v36 >= v77)
          v38 = *(_QWORD *)v34;
        else
          LODWORD(v38) = 0;
        if (v33 <= v36)
        {
          LODWORD(v35) = 0;
        }
        else
        {
          v37 = v33 - v36;
          LODWORD(v35) = v38;
        }
        if (v33)
        {
          v39 = (v25 - v7);
          if (v26 <= v27)
            v40 = v27;
          else
            v40 = v26;
          v41 = (unsigned int *)(*(_QWORD *)a1 + 12 * v26 + 8);
          while (v40 != v26)
          {
            v42 = *(v41 - 1);
            v43 = v39 - v42;
            if (v39 <= v42)
            {
              *(v41 - 1) = v42 - v39;
              break;
            }
            *(v41 - 1) = 0;
            v44 = *v41;
            v39 = v43 - v44;
            if (v43 < v44)
            {
              *v41 = v44 - v43;
              if ((int)v44 - (int)v43 >= v77)
                break;
              v45 = v26 + 1;
              if (v45 < v27)
                v41[2] += v44 - v43;
              goto LABEL_45;
            }
            *v41 = 0;
            v41 += 3;
            *(_QWORD *)(a1 + 8) = ++v26;
            if (v43 == v44)
              break;
          }
        }
      }
      if (!(_DWORD)v35)
        goto LABEL_22;
      v46 = v7 - *(_DWORD *)(a2 + 8);
      v47 = *(_DWORD *)(a2 + 36);
      if (v47 + 1024 < v46)
      {
        v48 = v46 - v47 - 1024;
        if (v48 >= 0x200)
          v48 = 512;
        *(_DWORD *)(a2 + 36) = v46 - v48;
      }
      ZSTD_ldm_fillFastTables(a2, v7);
      v49 = v78(a2, a3, a4, v7, v36);
      *(_QWORD *)((char *)a4 + 4) = *a4;
      v50 = v7 + v36;
      *(_DWORD *)a4 = v35;
      v51 = (__int128 *)(v7 + v36 - v49);
      v52 = *(__int128 **)(a3 + 24);
      if (v7 + v36 > v32)
        break;
      *v52 = *v51;
      v58 = *(_QWORD *)(a3 + 24);
      if (v49 > 0x10)
      {
        v59 = (_OWORD *)(v58 + 16);
        v60 = v58 + v49;
        v61 = (__int128 *)(v7 + v36 - v49 + 16);
        do
        {
          v62 = *v61++;
          *v59++ = v62;
        }
        while ((unint64_t)v59 < v60);
LABEL_83:
        *(_QWORD *)(a3 + 24) += v49;
        v63 = *(_QWORD *)(a3 + 8);
        if (v49 >= 0x10000)
        {
          v75 = (unint64_t)(v63 - *(_QWORD *)a3) >> 3;
          *(_DWORD *)(a3 + 72) = 1;
          *(_DWORD *)(a3 + 76) = v75;
        }
        goto LABEL_85;
      }
      *(_QWORD *)(a3 + 24) = v58 + v49;
      v63 = *(_QWORD *)(a3 + 8);
LABEL_85:
      *(_WORD *)(v63 + 4) = v49;
      *(_DWORD *)v63 = v35 + 3;
      if (((v37 - 3) & 0xFFFF0000) != 0)
      {
        v76 = (unint64_t)(v63 - *(_QWORD *)a3) >> 3;
        *(_DWORD *)(a3 + 72) = 2;
        *(_DWORD *)(a3 + 76) = v76;
      }
      *(_WORD *)(v63 + 6) = v37 - 3;
      *(_QWORD *)(a3 + 8) = v63 + 8;
      v7 = v50 + v37;
      v26 = *(_QWORD *)(a1 + 8);
      v27 = *(_QWORD *)(a1 + 24);
      if (v26 >= v27 || v7 >= v25)
        goto LABEL_22;
    }
    if ((unint64_t)v51 <= v32)
    {
      v53 = (__int128 *)((char *)v52 + v32 - (_QWORD)v51);
      do
      {
        v54 = *v51++;
        *v52++ = v54;
      }
      while (v52 < v53);
      v51 = (__int128 *)(v25 - 32);
      v52 = v53;
    }
    if ((unint64_t)v51 >= v50)
      goto LABEL_83;
    v55 = v36 + v7 - v49;
    if (v55 <= v32)
      v55 = v25 - 32;
    v56 = v36 + v7 - v55;
    if (v56 < 8 || (unint64_t)v52 - v55 < 0x20)
    {
      v64 = v52;
      v65 = (char *)v51;
      goto LABEL_82;
    }
    if (v56 >= 0x20)
    {
      v57 = v56 & 0xFFFFFFFFFFFFFFE0;
      v66 = v51 + 1;
      v67 = v52 + 1;
      v68 = v56 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v69 = *v66;
        *(v67 - 1) = *(v66 - 1);
        *v67 = v69;
        v66 += 2;
        v67 += 2;
        v68 -= 32;
      }
      while (v68);
      if (v56 == v57)
        goto LABEL_83;
      if ((v56 & 0x18) == 0)
      {
        v65 = (char *)v51 + v57;
        v64 = (__int128 *)((char *)v52 + v57);
        goto LABEL_82;
      }
    }
    else
    {
      v57 = 0;
    }
    v64 = (__int128 *)((char *)v52 + (v56 & 0xFFFFFFFFFFFFFFF8));
    v65 = (char *)v51 + (v56 & 0xFFFFFFFFFFFFFFF8);
    v70 = (uint64_t *)((char *)v51 + v57);
    v71 = (_QWORD *)((char *)v52 + v57);
    v72 = v57 - (v56 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      v73 = *v70++;
      *v71++ = v73;
      v72 += 8;
    }
    while (v72);
    if (v56 == (v56 & 0xFFFFFFFFFFFFFFF8))
      goto LABEL_83;
    do
    {
LABEL_82:
      v74 = *v65++;
      *(_BYTE *)v64 = v74;
      v64 = (__int128 *)((char *)v64 + 1);
    }
    while ((unint64_t)v65 < v50);
    goto LABEL_83;
  }
  *(_QWORD *)(a2 + 224) = a1;
  result = v15(a2, a3, a4, a5, a6);
  v17 = *(_DWORD *)(a1 + 16) + a6;
  if (v17)
  {
    v18 = *(_QWORD *)(a1 + 24);
    v19 = *(_QWORD *)(a1 + 8);
    if (v19 <= v18)
      v20 = *(_QWORD *)(a1 + 24);
    else
      v20 = *(_QWORD *)(a1 + 8);
    v21 = 12 * v19;
    while (1)
    {
      if (v20 == v19)
      {
        if (v20 == v18)
          goto LABEL_93;
        return result;
      }
      v22 = *(_DWORD *)(*(_QWORD *)a1 + v21 + 8) + *(_DWORD *)(*(_QWORD *)a1 + v21 + 4);
      v23 = v17 >= v22;
      v24 = v17 - v22;
      if (!v23)
        break;
      *(_QWORD *)(a1 + 8) = ++v19;
      v21 += 12;
      v17 = v24;
      if (!v24)
        goto LABEL_93;
    }
    *(_QWORD *)(a1 + 16) = v17;
    if (v19 != v18)
      return result;
  }
LABEL_93:
  *(_QWORD *)(a1 + 16) = 0;
  return result;
}

uint64_t ZSTD_ldm_fillFastTables(uint64_t result, uint64_t a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;

  v2 = *(_DWORD *)(result + 216);
  if (v2 == 2)
    return ZSTD_fillDoubleHashTable(result, a2, 0);
  if (v2 == 1)
  {
    v3 = *(_QWORD *)(result + 8);
    v4 = *(unsigned int *)(result + 36);
    v5 = (_QWORD *)(v3 + v4);
    v6 = a2 - 6;
    v7 = v3 + v4 + 3;
    if (v7 < a2 - 6)
    {
      v8 = *(_QWORD *)(result + 48);
      v9 = 64 - *(_DWORD *)(result + 200);
      switch(*(_DWORD *)(result + 208))
      {
        case 5:
          v10 = v3 + v4 + 6;
          if (v10 <= v6)
            v10 = a2 - 6;
          v11 = v10 - v3 - 6;
          if (v11 == v4)
            v12 = *(unsigned int *)(result + 36);
          else
            v12 = v4 + 1;
          v13 = (v11 - v12) / 3uLL;
          if (v11 != v4)
            ++v13;
          if (!v13)
            goto LABEL_62;
          v14 = v13 + 1;
          v15 = 3 * (v14 & 0x7FFFFFFFFFFFFFFELL);
          v7 += v15;
          v5 = (_QWORD *)((char *)v5 + v15);
          result = v14 & 0x7FFFFFFFFFFFFFFELL;
          do
          {
            v16 = (0xCF1BBCDCBB000000 * *(_QWORD *)(v3 + v4 + 3)) >> v9;
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v3 + v4)) >> v9)) = v4;
            *(_DWORD *)(v8 + 4 * v16) = v4 + 3;
            v4 += 6;
            result -= 2;
          }
          while (result);
          if (v14 != (v14 & 0x7FFFFFFFFFFFFFFELL))
          {
LABEL_62:
            do
            {
              *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBB000000 * *v5) >> v9)) = (_DWORD)v5 - v3;
              v5 = (_QWORD *)v7;
              v7 += 3;
            }
            while (v7 < v6);
          }
          break;
        case 6:
          v18 = v3 + v4 + 6;
          if (v18 <= v6)
            v18 = a2 - 6;
          v19 = v18 - v3 - 6;
          if (v19 == v4)
            v20 = *(unsigned int *)(result + 36);
          else
            v20 = v4 + 1;
          v21 = (v19 - v20) / 3uLL;
          if (v19 != v4)
            ++v21;
          if (!v21)
            goto LABEL_63;
          v22 = v21 + 1;
          v23 = 3 * (v22 & 0x7FFFFFFFFFFFFFFELL);
          v7 += v23;
          v5 = (_QWORD *)((char *)v5 + v23);
          result = v22 & 0x7FFFFFFFFFFFFFFELL;
          do
          {
            v24 = (0xCF1BBCDCBF9B0000 * *(_QWORD *)(v3 + v4 + 3)) >> v9;
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v3 + v4)) >> v9)) = v4;
            *(_DWORD *)(v8 + 4 * v24) = v4 + 3;
            v4 += 6;
            result -= 2;
          }
          while (result);
          if (v22 != (v22 & 0x7FFFFFFFFFFFFFFELL))
          {
LABEL_63:
            do
            {
              *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBF9B0000 * *v5) >> v9)) = (_DWORD)v5 - v3;
              v5 = (_QWORD *)v7;
              v7 += 3;
            }
            while (v7 < v6);
          }
          break;
        case 7:
          v25 = v3 + v4 + 6;
          if (v25 <= v6)
            v25 = a2 - 6;
          v26 = v25 - v3 - 6;
          if (v26 == v4)
            v27 = *(unsigned int *)(result + 36);
          else
            v27 = v4 + 1;
          v28 = (v26 - v27) / 3uLL;
          if (v26 != v4)
            ++v28;
          if (!v28)
            goto LABEL_64;
          v29 = v28 + 1;
          v30 = 3 * (v29 & 0x7FFFFFFFFFFFFFFELL);
          v7 += v30;
          v5 = (_QWORD *)((char *)v5 + v30);
          result = v29 & 0x7FFFFFFFFFFFFFFELL;
          do
          {
            v31 = (0xCF1BBCDCBFA56300 * *(_QWORD *)(v3 + v4 + 3)) >> v9;
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBFA56300 * *(_QWORD *)(v3 + v4)) >> v9)) = v4;
            *(_DWORD *)(v8 + 4 * v31) = v4 + 3;
            v4 += 6;
            result -= 2;
          }
          while (result);
          if (v29 != (v29 & 0x7FFFFFFFFFFFFFFELL))
          {
LABEL_64:
            do
            {
              *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCBFA56300 * *v5) >> v9)) = (_DWORD)v5 - v3;
              v5 = (_QWORD *)v7;
              v7 += 3;
            }
            while (v7 < v6);
          }
          break;
        case 8:
          v32 = v3 + v4 + 6;
          if (v32 <= v6)
            v32 = a2 - 6;
          v33 = v32 - v3 - 6;
          if (v33 == v4)
            v34 = *(unsigned int *)(result + 36);
          else
            v34 = v4 + 1;
          v35 = (v33 - v34) / 3uLL;
          if (v33 != v4)
            ++v35;
          if (!v35)
            goto LABEL_65;
          v36 = v35 + 1;
          v37 = 3 * (v36 & 0x7FFFFFFFFFFFFFFELL);
          v7 += v37;
          v5 = (_QWORD *)((char *)v5 + v37);
          result = v36 & 0x7FFFFFFFFFFFFFFELL;
          do
          {
            v38 = (0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4 + 3)) >> v9;
            *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCB7A56463 * *(_QWORD *)(v3 + v4)) >> v9)) = v4;
            *(_DWORD *)(v8 + 4 * v38) = v4 + 3;
            v4 += 6;
            result -= 2;
          }
          while (result);
          if (v36 != (v36 & 0x7FFFFFFFFFFFFFFELL))
          {
LABEL_65:
            do
            {
              *(_DWORD *)(v8 + 4 * ((0xCF1BBCDCB7A56463 * *v5) >> v9)) = (_DWORD)v5 - v3;
              v5 = (_QWORD *)v7;
              v7 += 3;
            }
            while (v7 < v6);
          }
          break;
        default:
          v17 = *(_BYTE *)(result + 200) - 32;
          do
          {
            *(_DWORD *)(v8 + 4 * ((-1640531535 * *(_DWORD *)(v3 + v4)) >> v17)) = v4;
            v4 += 3;
          }
          while (v3 + v4 + 3 < v6);
          break;
      }
    }
  }
  return result;
}

uint64_t ZSTD_updateTree(uint64_t result, int a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  int v8;

  v3 = result;
  v4 = *(_QWORD *)(result + 8);
  v5 = a2 - v4;
  v6 = *(_DWORD *)(result + 36);
  if (v6 < a2 - (int)v4)
  {
    v8 = *(_DWORD *)(result + 208);
    do
    {
      result = ZSTD_insertBt1(v3, (_QWORD *)(v4 + v6), a3, v8, 0);
      v6 += result;
    }
    while (v6 < v5);
  }
  *(_DWORD *)(v3 + 36) = v5;
  return result;
}

int64x2_t *ZSTDMT_createCCtx_advanced(unsigned int a1, uint64_t a2, uint64_t a3)
{
  void (*v3)(uint64_t, pthread_mutex_t *);
  uint64_t (*v4)(uint64_t, uint64_t);
  uint64_t v5;
  uint64_t v6;
  int64x2_t *v8;
  __int8 v9;
  int v10;
  int v11;
  size_t v12;
  pthread_mutex_t *v13;
  pthread_mutex_t *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  __int128 v20;
  uint64_t v21;
  unsigned int v22;

  v4 = *(uint64_t (**)(uint64_t, uint64_t))a2;
  v3 = *(void (**)(uint64_t, pthread_mutex_t *))(a2 + 8);
  v5 = *(_QWORD *)(a2 + 16);
  v22 = a1 + 2;
  if (!a1)
    return 0;
  v6 = a1 >= 0xC8 ? 200 : a1;
  if ((v4 != 0) != (v3 != 0))
    return 0;
  if (v4)
  {
    v8 = (int64x2_t *)v4(v5, 3040);
    bzero(v8, 0xBE0uLL);
  }
  else
  {
    v8 = (int64x2_t *)malloc_type_calloc(1uLL, 0xBE0uLL, 0xEC864E14uLL);
    if (!v8)
      return v8;
  }
  v8[7].i32[1] = v6;
  v8[187].i64[0] = (uint64_t)v4;
  v8[187].i64[1] = (uint64_t)v3;
  v8[188].i64[0] = v5;
  v8[185].i32[0] = 1;
  if (a3)
  {
    v8->i64[0] = a3;
    v9 = v8[189].i8[8] | 1;
  }
  else
  {
    *(_QWORD *)&v20 = v4;
    *((_QWORD *)&v20 + 1) = v3;
    v21 = v5;
    v8->i64[0] = (uint64_t)POOL_create_advanced(v6, 0, &v20);
    v9 = v8[189].i8[8] & 0xFE;
  }
  v8[189].i8[8] = v9;
  *(_QWORD *)&v20 = v4;
  *((_QWORD *)&v20 + 1) = v3;
  v21 = v5;
  v8->i64[1] = (uint64_t)ZSTDMT_createJobsTable(&v22, (uint64_t)&v20);
  v8[184].i32[0] = v22 - 1;
  v10 = 2 * v6 + 3;
  v11 = 32 * v6;
  v12 = (32 * v6 + 152);
  if (v4)
  {
    v13 = (pthread_mutex_t *)v4(v5, (v11 + 152));
    bzero(v13, v12);
    if (!v13)
      goto LABEL_22;
  }
  else
  {
    v13 = (pthread_mutex_t *)malloc_type_calloc(1uLL, (v11 + 152), 0xEC864E14uLL);
    if (!v13)
      goto LABEL_22;
  }
  if (pthread_mutex_init(v13, 0))
  {
    if (v3)
      v3(v5, v13);
    else
      free(v13);
    v13 = 0;
  }
  else
  {
    v13[1].__sig = 0x10000;
    *(_DWORD *)v13[1].__opaque = v10;
    *(_DWORD *)&v13[1].__opaque[4] = 0;
    *(_QWORD *)&v13[1].__opaque[8] = v4;
    *(_QWORD *)&v13[1].__opaque[16] = v3;
    *(_QWORD *)&v13[1].__opaque[24] = v5;
  }
LABEL_22:
  v8[1].i64[0] = (uint64_t)v13;
  *(_QWORD *)&v20 = v4;
  *((_QWORD *)&v20 + 1) = v3;
  v21 = v5;
  v8[1].i64[1] = (uint64_t)ZSTDMT_createCCtxPool(v6, &v20);
  if (v4)
  {
    v14 = (pthread_mutex_t *)v4(v5, v12);
    bzero(v14, v12);
    if (!v14)
      goto LABEL_32;
  }
  else
  {
    v14 = (pthread_mutex_t *)malloc_type_calloc(1uLL, v12, 0xEC864E14uLL);
    if (!v14)
      goto LABEL_32;
  }
  if (pthread_mutex_init(v14, 0))
  {
    if (v3)
      v3(v5, v14);
    else
      free(v14);
    v14 = 0;
  }
  else
  {
    v14[1].__sig = 0x10000;
    *(_DWORD *)v14[1].__opaque = v10;
    *(_DWORD *)&v14[1].__opaque[4] = 0;
    *(_QWORD *)&v14[1].__opaque[8] = v4;
    *(_QWORD *)&v14[1].__opaque[16] = v3;
    *(_QWORD *)&v14[1].__opaque[24] = v5;
    pthread_mutex_lock(v14);
    v14[1].__sig = 0;
    pthread_mutex_unlock(v14);
  }
LABEL_32:
  v8[2].i64[0] = (uint64_t)v14;
  bzero(&v8[18].u64[1], 0xA40uLL);
  v15 = pthread_mutex_init((pthread_mutex_t *)&v8[18].u64[1], 0);
  v16 = pthread_cond_init((pthread_cond_t *)&v8[22].u64[1], 0) | v15;
  v17 = pthread_mutex_init((pthread_mutex_t *)&v8[173].u64[1], 0);
  v18 = v16 | v17 | pthread_cond_init((pthread_cond_t *)&v8[177].u64[1], 0);
  v8[17].i64[1] = 0;
  v8[18].i64[0] = 0;
  v8[17].i64[0] = 0;
  if (v18 | vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqzq_s64(*v8), (int32x4_t)vceqzq_s64(v8[1])))) & 1 | (v8[2].i64[0] == 0))
  {
    ZSTDMT_freeCCtx((uint64_t)v8);
    return 0;
  }
  return v8;
}

uint64_t ZSTDMT_freeCCtx(uint64_t a1)
{
  char *v2;
  int v3;
  void (*v4)(uint64_t, char *);
  uint64_t v5;
  uint64_t v6;
  pthread_cond_t *v7;
  uint64_t v8;
  unint64_t v9;
  void **v10;
  void (*v11)(_QWORD);
  void (*v12)(_QWORD, uint64_t);
  uint64_t v13;
  uint64_t v14;
  void (*v15)(_QWORD, uint64_t);
  uint64_t v16;
  unint64_t v17;
  void **v18;
  void (*v19)(_QWORD);
  void (*v20)(_QWORD, uint64_t);
  void (*v21)(uint64_t);
  uint64_t v22;
  void *v23;
  unint64_t v24;
  uint64_t v25;
  void *v26;
  _OWORD *v27;
  _BOOL4 v28;
  void (*v29)(uint64_t);
  void (*v30)(_QWORD);
  void (*v31)(_QWORD, uint64_t);

  if (a1)
  {
    if ((*(_BYTE *)(a1 + 3032) & 1) == 0)
      POOL_free(*(_QWORD *)a1);
    ZSTDMT_releaseAllJobResources(a1);
    v2 = *(char **)(a1 + 8);
    if (v2)
    {
      v3 = *(_DWORD *)(a1 + 2944);
      v4 = *(void (**)(uint64_t, char *))(a1 + 3000);
      v5 = *(_QWORD *)(a1 + 3008);
      v6 = (v3 + 1);
      if (v3 != -1)
      {
        v7 = (pthread_cond_t *)(v2 + 80);
        do
        {
          pthread_mutex_destroy((pthread_mutex_t *)&v7[-2].__opaque[24]);
          pthread_cond_destroy(v7);
          v7 = (pthread_cond_t *)((char *)v7 + 424);
          --v6;
        }
        while (v6);
      }
      if (!v4)
      {
        free(v2);
        v8 = *(_QWORD *)(a1 + 16);
        if (!v8)
          goto LABEL_23;
        goto LABEL_11;
      }
      v4(v5, v2);
    }
    v8 = *(_QWORD *)(a1 + 16);
    if (!v8)
      goto LABEL_23;
LABEL_11:
    if (*(_DWORD *)(v8 + 72))
    {
      v9 = 0;
      v10 = (void **)(v8 + 104);
      do
      {
        if (*v10)
        {
          v11 = *(void (**)(_QWORD))(v8 + 88);
          if (v11)
            v11(*(_QWORD *)(v8 + 96));
          else
            free(*v10);
        }
        ++v9;
        v10 += 2;
      }
      while (v9 < *(unsigned int *)(v8 + 72));
    }
    pthread_mutex_destroy((pthread_mutex_t *)v8);
    v12 = *(void (**)(_QWORD, uint64_t))(v8 + 88);
    if (v12)
      v12(*(_QWORD *)(v8 + 96), v8);
    else
      free((void *)v8);
LABEL_23:
    v13 = *(_QWORD *)(a1 + 24);
    if (*(int *)(v13 + 64) >= 1)
    {
      v14 = 0;
      do
        ZSTD_freeCCtx(*(_QWORD *)(v13 + 96 + 8 * v14++));
      while (v14 < *(int *)(v13 + 64));
    }
    pthread_mutex_destroy((pthread_mutex_t *)v13);
    v15 = *(void (**)(_QWORD, uint64_t))(v13 + 80);
    if (v15)
    {
      v15(*(_QWORD *)(v13 + 88), v13);
      v16 = *(_QWORD *)(a1 + 32);
      if (!v16)
        goto LABEL_40;
    }
    else
    {
      free((void *)v13);
      v16 = *(_QWORD *)(a1 + 32);
      if (!v16)
        goto LABEL_40;
    }
    if (*(_DWORD *)(v16 + 72))
    {
      v17 = 0;
      v18 = (void **)(v16 + 104);
      do
      {
        if (*v18)
        {
          v19 = *(void (**)(_QWORD))(v16 + 88);
          if (v19)
            v19(*(_QWORD *)(v16 + 96));
          else
            free(*v18);
        }
        ++v17;
        v18 += 2;
      }
      while (v17 < *(unsigned int *)(v16 + 72));
    }
    pthread_mutex_destroy((pthread_mutex_t *)v16);
    v20 = *(void (**)(_QWORD, uint64_t))(v16 + 88);
    if (v20)
      v20(*(_QWORD *)(v16 + 96), v16);
    else
      free((void *)v16);
LABEL_40:
    v21 = *(void (**)(uint64_t))(a1 + 560);
    v22 = *(_QWORD *)(a1 + 568);
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 296));
    pthread_cond_destroy((pthread_cond_t *)(a1 + 360));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 2776));
    pthread_cond_destroy((pthread_cond_t *)(a1 + 2840));
    if (*(_QWORD *)(a1 + 608))
    {
      if (!v21)
      {
        free(*(void **)(a1 + 608));
        v23 = *(void **)(a1 + 624);
        if (!v23)
          goto LABEL_48;
        goto LABEL_47;
      }
      v21(v22);
    }
    v23 = *(void **)(a1 + 624);
    if (!v23)
      goto LABEL_48;
    if (v21)
    {
      v21(v22);
      goto LABEL_48;
    }
LABEL_47:
    free(v23);
LABEL_48:
    v24 = *(_QWORD *)(a1 + 3016);
    if (!v24)
      goto LABEL_60;
    v25 = *(_QWORD *)(v24 + 4936);
    v27 = (_OWORD *)(v24 + 32);
    v26 = *(void **)(v24 + 32);
    if ((unint64_t)v26 <= v24)
    {
      v28 = *(_QWORD *)(v24 + 40) >= v24;
      v29 = *(void (**)(uint64_t))(v24 + 4928);
      *(_OWORD *)(v24 + 64) = 0u;
      *(_OWORD *)(v24 + 80) = 0u;
      *v27 = 0u;
      *(_OWORD *)(v24 + 48) = 0u;
      if (!v26)
        goto LABEL_55;
    }
    else
    {
      v28 = 0;
      v29 = *(void (**)(uint64_t))(v24 + 4928);
      *(_OWORD *)(v24 + 64) = 0u;
      *(_OWORD *)(v24 + 80) = 0u;
      *v27 = 0u;
      *(_OWORD *)(v24 + 48) = 0u;
      if (!v26)
        goto LABEL_55;
    }
    if (!v29)
    {
      free(v26);
      if (v28)
        goto LABEL_60;
      goto LABEL_59;
    }
    v29(v25);
LABEL_55:
    if (v28)
      goto LABEL_60;
    if (v29)
    {
      ((void (*)(uint64_t, unint64_t))v29)(v25, v24);
      goto LABEL_60;
    }
LABEL_59:
    free((void *)v24);
LABEL_60:
    if (*(_QWORD *)(a1 + 272))
    {
      v30 = *(void (**)(_QWORD))(a1 + 3000);
      if (!v30)
      {
        free(*(void **)(a1 + 272));
        v31 = *(void (**)(_QWORD, uint64_t))(a1 + 3000);
        if (v31)
          goto LABEL_64;
        goto LABEL_66;
      }
      v30(*(_QWORD *)(a1 + 3008));
    }
    v31 = *(void (**)(_QWORD, uint64_t))(a1 + 3000);
    if (v31)
    {
LABEL_64:
      v31(*(_QWORD *)(a1 + 3008), a1);
      return 0;
    }
LABEL_66:
    free((void *)a1);
  }
  return 0;
}

void ZSTDMT_releaseAllJobResources(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  _OWORD *v5;
  _OWORD *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(_QWORD, void *);
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  v2 = 0;
  do
  {
    v7 = *(_QWORD *)(a1 + 8) + 424 * v2;
    v16 = *(_OWORD *)(v7 + 16);
    v17 = *(_OWORD *)(v7 + 32);
    v18 = *(_OWORD *)(v7 + 48);
    v19 = *(_OWORD *)(v7 + 64);
    v13 = *(_OWORD *)(v7 + 80);
    v14 = *(_OWORD *)(v7 + 96);
    v15 = *(_OWORD *)(v7 + 112);
    v8 = *(void **)(v7 + 160);
    if (v8)
    {
      v9 = *(_QWORD *)(a1 + 16);
      v10 = *(_QWORD *)(v7 + 168);
      pthread_mutex_lock((pthread_mutex_t *)v9);
      v11 = *(unsigned int *)(v9 + 76);
      if (v11 < *(_DWORD *)(v9 + 72))
      {
        *(_DWORD *)(v9 + 76) = v11 + 1;
        v3 = v9 + 16 * v11;
        *(_QWORD *)(v3 + 104) = v8;
        *(_QWORD *)(v3 + 112) = v10;
        pthread_mutex_unlock((pthread_mutex_t *)v9);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)v9);
        v12 = *(void (**)(_QWORD, void *))(v9 + 88);
        if (v12)
          v12(*(_QWORD *)(v9 + 96), v8);
        else
          free(v8);
      }
    }
    v4 = *(_QWORD *)(a1 + 8) + 424 * v2;
    *(_QWORD *)(v4 + 416) = 0;
    *(_OWORD *)(v4 + 384) = 0u;
    *(_OWORD *)(v4 + 400) = 0u;
    *(_OWORD *)(v4 + 352) = 0u;
    *(_OWORD *)(v4 + 368) = 0u;
    *(_OWORD *)(v4 + 320) = 0u;
    *(_OWORD *)(v4 + 336) = 0u;
    *(_OWORD *)(v4 + 288) = 0u;
    *(_OWORD *)(v4 + 304) = 0u;
    *(_OWORD *)(v4 + 256) = 0u;
    *(_OWORD *)(v4 + 272) = 0u;
    *(_OWORD *)(v4 + 224) = 0u;
    *(_OWORD *)(v4 + 240) = 0u;
    *(_OWORD *)(v4 + 192) = 0u;
    *(_OWORD *)(v4 + 208) = 0u;
    *(_OWORD *)(v4 + 160) = 0u;
    *(_OWORD *)(v4 + 176) = 0u;
    *(_OWORD *)(v4 + 128) = 0u;
    *(_OWORD *)(v4 + 144) = 0u;
    *(_OWORD *)(v4 + 96) = 0u;
    *(_OWORD *)(v4 + 112) = 0u;
    *(_OWORD *)(v4 + 64) = 0u;
    *(_OWORD *)(v4 + 80) = 0u;
    *(_OWORD *)(v4 + 32) = 0u;
    *(_OWORD *)(v4 + 48) = 0u;
    *(_OWORD *)v4 = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    v5 = (_OWORD *)(*(_QWORD *)(a1 + 8) + 424 * v2);
    v5[1] = v16;
    v5[2] = v17;
    v5[3] = v18;
    v5[4] = v19;
    v6 = (_OWORD *)(*(_QWORD *)(a1 + 8) + 424 * v2);
    v6[5] = v13;
    v6[6] = v14;
    v6[7] = v15;
    ++v2;
  }
  while (v2 <= *(_DWORD *)(a1 + 2944));
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_DWORD *)(a1 + 2960) = 1;
}

_QWORD *ZSTDMT_sizeof_CCtx(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const double *v9;
  int64x2_t v10;
  uint64_t v11;
  int64x2_t v12;
  const double *v13;
  unsigned __int128 v14;
  unsigned __int128 v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const double *v40;
  int64x2_t v41;
  uint64_t v42;
  int64x2_t v43;
  const double *v44;
  unsigned __int128 v45;
  unsigned __int128 v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  pthread_mutex_t *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;

  if (result)
  {
    v1 = result;
    if (*result)
      v2 = 16 * *(_QWORD *)(*result + 72) + 8 * *(_QWORD *)(*result + 32) + 3648;
    else
      v2 = 3384;
    v58 = v2;
    v3 = result[2];
    v4 = *(_DWORD *)(v3 + 72);
    pthread_mutex_lock((pthread_mutex_t *)v3);
    v5 = *(unsigned int *)(v3 + 72);
    if ((_DWORD)v5)
    {
      if (v5 >= 5)
      {
        v8 = v5 & 3;
        if ((v5 & 3) == 0)
          v8 = 4;
        v6 = v5 - v8;
        v9 = (const double *)(v3 + 144);
        v10 = 0uLL;
        v11 = v6;
        v12 = 0uLL;
        do
        {
          v13 = v9 - 4;
          v14 = (unsigned __int128)vld2q_f64(v13);
          v15 = (unsigned __int128)vld2q_f64(v9);
          v10 = vaddq_s64((int64x2_t)v14, v10);
          v12 = vaddq_s64((int64x2_t)v15, v12);
          v9 += 8;
          v11 -= 4;
        }
        while (v11);
        v7 = vaddvq_s64(vaddq_s64(v12, v10));
      }
      else
      {
        v6 = 0;
        v7 = 0;
      }
      v16 = v5 - v6;
      v17 = (uint64_t *)(v3 + 16 * v6 + 112);
      do
      {
        v18 = *v17;
        v17 += 2;
        v7 += v18;
        --v16;
      }
      while (v16);
    }
    else
    {
      v7 = 0;
    }
    v57 = (v4 - 1);
    pthread_mutex_unlock((pthread_mutex_t *)v3);
    v55 = *((_DWORD *)v1 + 736);
    v59 = v1;
    v19 = v1[3];
    pthread_mutex_lock((pthread_mutex_t *)v19);
    v20 = *(unsigned int *)(v19 + 64);
    v56 = (pthread_mutex_t *)v19;
    v54 = v20;
    v21 = 0;
    if ((_DWORD)v20)
    {
      v22 = (uint64_t *)(v19 + 96);
      do
      {
        v29 = *v22;
        if (*v22)
        {
          v30 = *(_QWORD *)(v29 + 368);
          if (v30 == v29)
            v31 = 0;
          else
            v31 = 3328;
          v32 = *(_QWORD *)(v29 + 3280);
          if (*(_QWORD *)(v29 + 3248))
            v33 = *(_QWORD *)(v29 + 3264);
          else
            v33 = 0;
          if (v32)
          {
            v23 = *(_QWORD *)(v32 + 32);
            v24 = *(_QWORD *)(v32 + 40);
            v25 = v23 == v32;
            v26 = 4952;
            if (v25)
              v26 = 0;
            v27 = v24 - v23 + v26;
          }
          else
          {
            v27 = 0;
          }
          v28 = *(_QWORD *)(v29 + 376);
          v29 = v28 - v30 + v31 + v33 + v27 + ZSTDMT_sizeof_CCtx(*(_QWORD *)(v29 + 3320));
        }
        v21 += v29;
        ++v22;
        --v20;
      }
      while (v20);
    }
    pthread_mutex_unlock(v56);
    v34 = v59[4];
    v35 = *(_DWORD *)(v34 + 72);
    pthread_mutex_lock((pthread_mutex_t *)v34);
    v36 = *(unsigned int *)(v34 + 72);
    if ((_DWORD)v36)
    {
      if (v36 >= 5)
      {
        v39 = v36 & 3;
        if ((v36 & 3) == 0)
          v39 = 4;
        v37 = v36 - v39;
        v40 = (const double *)(v34 + 144);
        v41 = 0uLL;
        v42 = v37;
        v43 = 0uLL;
        do
        {
          v44 = v40 - 4;
          v45 = (unsigned __int128)vld2q_f64(v44);
          v46 = (unsigned __int128)vld2q_f64(v40);
          v41 = vaddq_s64((int64x2_t)v45, v41);
          v43 = vaddq_s64((int64x2_t)v46, v43);
          v40 += 8;
          v42 -= 4;
        }
        while (v42);
        v38 = vaddvq_s64(vaddq_s64(v43, v41));
      }
      else
      {
        v37 = 0;
        v38 = 0;
      }
      v47 = v36 - v37;
      v48 = (uint64_t *)(v34 + 16 * v37 + 112);
      do
      {
        v49 = *v48;
        v48 += 2;
        v38 += v49;
        --v47;
      }
      while (v47);
    }
    else
    {
      v38 = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)v34);
    v50 = v59[377];
    if (v50)
    {
      v51 = *(_QWORD *)(v50 + 32);
      v52 = *(_QWORD *)(v50 + 40);
      v25 = v51 == v50;
      v53 = 4952;
      if (v25)
        v53 = 0;
      v50 = v52 - v51 + v53;
    }
    return (_QWORD *)(v58
                    + v7
                    + 424 * (v55 + 1)
                    + 8 * (v54 - 1)
                    + v21
                    + 16 * ((v35 - 1) + v57)
                    + v38
                    + v50
                    + v59[35]);
  }
  return result;
}

__n128 ZSTDMT_initCStream_internal(uint64_t a1, const void *a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v14;
  unint64_t v15;
  uint64_t v16;
  __n128 result;
  uint64_t v18;
  char *v19;
  void (*v20)(size_t, char *);
  pthread_cond_t *v21;
  char *JobsTable;
  pthread_mutex_t *v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  void (*v28)(_QWORD, uint64_t);
  char *v29;
  pthread_mutex_t *v30;
  int v31;
  BOOL v32;
  int v34;
  unsigned int i;
  unsigned int v36;
  uint64_t j;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  unint64_t v46;
  uint64_t v47;
  void *v48;
  _OWORD *v49;
  _BOOL4 v50;
  void (*v51)(uint64_t);
  uint64_t v52;
  void *v53;
  _OWORD *v54;
  _BOOL4 v55;
  void (*v56)(uint64_t);
  char *CDict_advanced2;
  int v58;
  unsigned int v59;
  int v60;
  int v61;
  int v62;
  unsigned int v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  int v70;
  unsigned int v71;
  pthread_mutex_t *v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  size_t v80;
  void (*v81)(_QWORD);
  uint64_t (*v82)(_QWORD, size_t);
  uint64_t v83;
  pthread_mutex_t *v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __n128 v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  uint64_t (*v94)(uint64_t, uint64_t);
  unsigned int v95;
  int v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  void *v100;
  void *v101;
  unsigned int v102;
  void *v103;
  void *v104;
  unint64_t v105;
  unint64_t *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unsigned int v110;
  uint64_t v111;
  int v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  int v118;
  void (*v119)(_QWORD);
  size_t size;
  uint64_t sizea;
  unint64_t v122;
  uint64_t v123;
  const void *v124;
  unint64_t v125;
  int v126;
  int v127;
  int v128;
  __int128 v129;
  uint64_t v130;
  __int128 v131[2];
  __int128 v132;
  __n128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  uint64_t v140;

  v14 = *(_DWORD *)(a6 + 76);
  if (v14 == *(_DWORD *)(a1 + 116))
  {
    v15 = *(_QWORD *)(a6 + 80);
    if (v15 - 1 < 0xFFFFF)
    {
LABEL_3:
      v16 = 0x100000;
      goto LABEL_38;
    }
LABEL_36:
    if (v15 < 0x40000001)
      goto LABEL_39;
    v16 = 0x40000000;
LABEL_38:
    *(_QWORD *)(a6 + 80) = v16;
LABEL_39:
    if (!*(_DWORD *)(a1 + 2960))
    {
      v34 = a4;
      for (i = *(_DWORD *)(a1 + 2948); i < *(_DWORD *)(a1 + 2952); *(_DWORD *)(a1 + 2948) = i)
      {
        v36 = *(_DWORD *)(a1 + 2944) & i;
        pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)(a1 + 8) + 424 * v36 + 16));
        for (j = *(_QWORD *)(a1 + 8);
              *(_QWORD *)(j + 424 * v36) < *(_QWORD *)(j + 424 * v36 + 200);
              j = *(_QWORD *)(a1 + 8))
        {
          pthread_cond_wait((pthread_cond_t *)(j + 424 * v36 + 80), (pthread_mutex_t *)(j + 424 * v36 + 16));
        }
        pthread_mutex_unlock((pthread_mutex_t *)(j + 424 * v36 + 16));
        i = *(_DWORD *)(a1 + 2948) + 1;
      }
      ZSTDMT_releaseAllJobResources(a1);
      *(_DWORD *)(a1 + 2960) = 1;
      a4 = v34;
    }
    v38 = *(_OWORD *)a6;
    v39 = *(_OWORD *)(a6 + 32);
    *(_OWORD *)(a1 + 56) = *(_OWORD *)(a6 + 16);
    *(_OWORD *)(a1 + 72) = v39;
    *(_OWORD *)(a1 + 40) = v38;
    v40 = *(_OWORD *)(a6 + 48);
    v41 = *(_OWORD *)(a6 + 64);
    v42 = *(_OWORD *)(a6 + 96);
    *(_OWORD *)(a1 + 120) = *(_OWORD *)(a6 + 80);
    *(_OWORD *)(a1 + 136) = v42;
    *(_OWORD *)(a1 + 88) = v40;
    *(_OWORD *)(a1 + 104) = v41;
    v43 = *(_OWORD *)(a6 + 112);
    v44 = *(_OWORD *)(a6 + 128);
    v45 = *(_OWORD *)(a6 + 144);
    *(_QWORD *)(a1 + 200) = *(_QWORD *)(a6 + 160);
    *(_OWORD *)(a1 + 168) = v44;
    *(_OWORD *)(a1 + 184) = v45;
    *(_OWORD *)(a1 + 152) = v43;
    *(_QWORD *)(a1 + 2968) = a7;
    v46 = *(_QWORD *)(a1 + 3016);
    if (a2)
    {
      if (!v46)
        goto LABEL_68;
      v47 = *(_QWORD *)(v46 + 4936);
      v49 = (_OWORD *)(v46 + 32);
      v48 = *(void **)(v46 + 32);
      if ((unint64_t)v48 <= v46)
      {
        v50 = *(_QWORD *)(v46 + 40) >= v46;
        v51 = *(void (**)(uint64_t))(v46 + 4928);
        *(_OWORD *)(v46 + 64) = 0u;
        *(_OWORD *)(v46 + 80) = 0u;
        *v49 = 0u;
        *(_OWORD *)(v46 + 48) = 0u;
        if (!v48)
          goto LABEL_57;
      }
      else
      {
        v50 = 0;
        v51 = *(void (**)(uint64_t))(v46 + 4928);
        *(_OWORD *)(v46 + 64) = 0u;
        *(_OWORD *)(v46 + 80) = 0u;
        *v49 = 0u;
        *(_OWORD *)(v46 + 48) = 0u;
        if (!v48)
          goto LABEL_57;
      }
      if (!v51)
      {
        free(v48);
        if (v50)
          goto LABEL_68;
        goto LABEL_67;
      }
      v51(v47);
LABEL_57:
      if (v50)
        goto LABEL_68;
      if (v51)
      {
        ((void (*)(uint64_t, unint64_t))v51)(v47, v46);
        goto LABEL_68;
      }
LABEL_67:
      free((void *)v46);
LABEL_68:
      v129 = *(_OWORD *)(a1 + 2992);
      v130 = *(_QWORD *)(a1 + 3008);
      memset(v131, 0, sizeof(v131));
      v137 = 0u;
      v138 = 0u;
      v135 = 0u;
      v136 = 0u;
      v133 = 0u;
      v134 = 0u;
      *(__int128 *)((char *)v131 + 4) = *(_OWORD *)(a6 + 4);
      v131[1] = *(_OWORD *)(a6 + 16);
      v132 = 0u;
      LODWORD(v132) = 1;
      v139 = *(_OWORD *)(a1 + 2992);
      v140 = *(_QWORD *)(a1 + 3008);
      CDict_advanced2 = ZSTD_createCDict_advanced2(a2, a3, 0, a4, v131, (uint64_t)&v129);
      *(_QWORD *)(a1 + 3016) = CDict_advanced2;
      *(_QWORD *)(a1 + 3024) = CDict_advanced2;
      if (!CDict_advanced2)
        return result;
      v58 = *(_DWORD *)(a6 + 88);
      v59 = *(_DWORD *)(a6 + 28);
      if (v58)
      {
LABEL_70:
        v60 = 9 - v58;
        if (v58 < 2)
        {
          v61 = 0;
          v62 = *(_DWORD *)(a6 + 96);
          if (!v62)
            goto LABEL_89;
          goto LABEL_79;
        }
LABEL_78:
        v61 = *(_DWORD *)(a6 + 4) - v60;
        v62 = *(_DWORD *)(a6 + 96);
        if (!v62)
          goto LABEL_89;
LABEL_79:
        v63 = *(_DWORD *)(a6 + 4);
        if (v59 > 5)
          v64 = 2;
        else
          v64 = 3;
        v65 = *(_DWORD *)(a6 + 8) + v64;
        if (v65 >= 0x1E)
          v65 = 30;
        if (v65 <= 0x15)
          v65 = 21;
        v66 = v65 - 2;
        if (v63 >= v66)
          v63 = v66;
        v61 = v63 - v60;
LABEL_89:
        v67 = 1 << v61;
        if (v61)
          v68 = 1 << v61;
        else
          v68 = 0;
        *(_QWORD *)(a1 + 216) = v68;
        v69 = *(_QWORD *)(a6 + 80);
        *(_QWORD *)(a1 + 208) = v69;
        if (v69)
        {
LABEL_106:
          if (*(_DWORD *)(a6 + 92))
          {
            *(_QWORD *)(a1 + 2920) = 0;
            *(_QWORD *)(a1 + 2928) = ~(-1 << ((__clz(v69 >> 20) ^ 0x1F) + 20));
            *(_QWORD *)(a1 + 2936) = 0xF5507FE35F91F8CBLL;
          }
          v128 = a4;
          if (v69 < v68)
          {
            *(_QWORD *)(a1 + 208) = v68;
            v69 = v67;
          }
          v72 = *(pthread_mutex_t **)(a1 + 16);
          v73 = (0x20000 - v69) >> 11;
          if (v69 >= 0x20000)
            v73 = 0;
          v74 = v69 + (v69 >> 8) + v73;
          pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 16));
          v72[1].__sig = v74;
          pthread_mutex_unlock(v72);
          if (*(_DWORD *)(a1 + 136))
            v75 = 1 << *(_DWORD *)(a1 + 44);
          else
            v75 = 0;
          v76 = *(_QWORD *)(a1 + 208);
          v77 = 2;
          if (*(_QWORD *)(a1 + 216))
            v77 = 3;
          LODWORD(v78) = *(_DWORD *)(a1 + 116);
          if ((int)v78 <= 1)
            v78 = 1;
          else
            v78 = v78;
          v79 = v76 * v78;
          if (v75 <= v79)
            v75 = v79;
          v80 = v75 + v77 * v76;
          if (*(_QWORD *)(a1 + 280) >= v80)
          {
LABEL_129:
            *(_QWORD *)(a1 + 288) = 0;
            *(_OWORD *)(a1 + 2948) = 0u;
            *(_OWORD *)(a1 + 2976) = 0u;
            *(_OWORD *)(a1 + 232) = 0u;
            *(_OWORD *)(a1 + 248) = 0u;
            *(_QWORD *)(a1 + 264) = 0;
            v84 = *(pthread_mutex_t **)(a1 + 32);
            v85 = *(_OWORD *)(a6 + 144);
            v138 = *(_OWORD *)(a6 + 128);
            v139 = v85;
            v140 = *(_QWORD *)(a6 + 160);
            v86 = *(_OWORD *)(a6 + 80);
            v134 = *(_OWORD *)(a6 + 64);
            v135 = v86;
            v87 = *(_OWORD *)(a6 + 112);
            v136 = *(_OWORD *)(a6 + 96);
            v137 = v87;
            v88 = *(_OWORD *)(a6 + 16);
            v131[0] = *(_OWORD *)a6;
            v131[1] = v88;
            v89 = *(__n128 *)(a6 + 48);
            v132 = *(_OWORD *)(a6 + 32);
            v133 = v89;
            v90 = v136;
            if (!(_DWORD)v136)
            {
              v91 = 0;
              v92 = 0;
              v93 = 0;
              v136 = 0uLL;
              *(_QWORD *)&v137 = 0;
              *(_DWORD *)(a1 + 2768) = 0;
              if (DWORD1(v132))
              {
LABEL_139:
                *(_QWORD *)(a1 + 2680) = 0;
                *(_OWORD *)(a1 + 2688) = xmmword_18822D550;
                *(_OWORD *)(a1 + 2704) = xmmword_18823D790;
                *(_OWORD *)(a1 + 2720) = 0u;
                *(_OWORD *)(a1 + 2736) = 0u;
                *(_OWORD *)(a1 + 2752) = 0u;
              }
LABEL_140:
              if (!v90)
              {
LABEL_192:
                *(_QWORD *)(a1 + 568) = v140;
                v114 = v139;
                *(_OWORD *)(a1 + 536) = v138;
                *(_OWORD *)(a1 + 552) = v114;
                v115 = v135;
                *(_OWORD *)(a1 + 472) = v134;
                *(_OWORD *)(a1 + 488) = v115;
                v116 = v137;
                *(_OWORD *)(a1 + 504) = v136;
                *(_OWORD *)(a1 + 520) = v116;
                v117 = v131[1];
                *(_OWORD *)(a1 + 408) = v131[0];
                *(_OWORD *)(a1 + 424) = v117;
                result = v133;
                *(_OWORD *)(a1 + 440) = v132;
                *(__n128 *)(a1 + 456) = result;
                *(_QWORD *)(a1 + 488) = v76;
                return result;
              }
              v125 = (unint64_t)a2;
              v94 = (uint64_t (*)(uint64_t, uint64_t))v139;
              v123 = v140;
              v95 = v93 - v92;
              v118 = *(_DWORD *)(a1 + 508);
              v96 = *(_DWORD *)(a1 + 512);
              v119 = (void (*)(_QWORD))*((_QWORD *)&v139 + 1);
              sizea = 1 << (v93 - v92);
              v97 = a3;
              v98 = 12 * (v76 / v91);
              pthread_mutex_lock(v84);
              v84[1].__sig = v98;
              v99 = v97;
              pthread_mutex_unlock(v84);
              *(_QWORD *)(a1 + 584) = "";
              *(_QWORD *)(a1 + 592) = "";
              result.n128_u64[0] = 0x100000001;
              *(_QWORD *)(a1 + 600) = 0x100000001;
              *(_QWORD *)(a1 + 576) = "Mnum_stages";
              v100 = *(void **)(a1 + 608);
              if (v100)
              {
                if (*(_DWORD *)(a1 + 508) >= v93)
                {
LABEL_162:
                  v104 = *(void **)(a1 + 624);
                  if (v104 && v118 - v96 >= v95)
                  {
                    v105 = v125;
                    if (!v100)
                      return result;
LABEL_174:
                    if (v104)
                    {
                      v106 = (unint64_t *)(a1 + 576);
                      bzero(v100, 8 << v93);
                      bzero(*(void **)(a1 + 624), sizea);
                      *(_DWORD *)(a1 + 616) = 0;
                      if (v99 && v128 == 1)
                      {
                        v107 = v105 + v99;
                        if (*v106 == v105)
                        {
                          v108 = *(_QWORD *)(a1 + 592);
                          v110 = *(_DWORD *)(a1 + 604);
                          LODWORD(v109) = *(_DWORD *)(a1 + 600);
                        }
                        else
                        {
                          v108 = *(_QWORD *)(a1 + 584);
                          v109 = *v106 - v108;
                          v110 = *(_DWORD *)(a1 + 600);
                          *(_DWORD *)(a1 + 604) = v110;
                          *(_DWORD *)(a1 + 600) = v109;
                          *(_QWORD *)(a1 + 592) = v108;
                          *(_QWORD *)(a1 + 584) = v105 - v109;
                          if (v109 - v110 <= 7)
                          {
                            *(_DWORD *)(a1 + 604) = v109;
                            v110 = v109;
                          }
                        }
                        *v106 = v107;
                        if (v107 > v108 + (unint64_t)v110 && v108 + (unint64_t)v109 > v105)
                        {
                          v111 = v107 - v108;
                          if (v111 > v109)
                            LODWORD(v111) = v109;
                          *(_DWORD *)(a1 + 604) = v111;
                        }
                        ZSTD_ldm_fillHashTable(a1 + 576, v105, v105 + v99, &v136);
                        if (v133.n128_u32[0])
                          v112 = 0;
                        else
                          v112 = v107 - *(_DWORD *)(a1 + 584);
                        *(_DWORD *)(a1 + 616) = v112;
                      }
                      v113 = *(_OWORD *)(a1 + 592);
                      *(_OWORD *)(a1 + 2888) = *(_OWORD *)v106;
                      *(_OWORD *)(a1 + 2904) = v113;
                      goto LABEL_192;
                    }
                    return result;
                  }
                  if (v104)
                  {
                    if (!v119)
                    {
                      free(*(void **)(a1 + 624));
                      if (v94)
                      {
LABEL_170:
                        v104 = (void *)v94(v123, sizea);
                        v105 = v125;
                        *(_QWORD *)(a1 + 624) = v104;
                        v100 = *(void **)(a1 + 608);
                        if (!v100)
                          return result;
                        goto LABEL_174;
                      }
LABEL_173:
                      v104 = malloc_type_malloc(sizea, 0x26AA08A0uLL);
                      v105 = v125;
                      *(_QWORD *)(a1 + 624) = v104;
                      v100 = *(void **)(a1 + 608);
                      if (!v100)
                        return result;
                      goto LABEL_174;
                    }
                    ((void (*)(uint64_t, _QWORD))v119)(v123, *(_QWORD *)(a1 + 624));
                  }
                  if (v94)
                    goto LABEL_170;
                  goto LABEL_173;
                }
                if (!v119)
                {
                  free(v100);
                  if (v94)
                    goto LABEL_146;
                  goto LABEL_160;
                }
                v119(v123);
              }
              if (v94)
              {
LABEL_146:
                v101 = (void *)v94(v123, 8 << v93);
LABEL_161:
                v100 = v101;
                *(_QWORD *)(a1 + 608) = v101;
                goto LABEL_162;
              }
LABEL_160:
              v101 = malloc_type_malloc(8 << v93, 0x26AA08A0uLL);
              goto LABEL_161;
            }
            v92 = DWORD2(v136);
            v91 = HIDWORD(v136);
            if (!HIDWORD(v136))
              v91 = 64;
            v93 = DWORD1(v136);
            DWORD1(v137) = DWORD1(v131[0]);
            HIDWORD(v136) = v91;
            if (DWORD1(v136))
            {
              if ((_DWORD)v137)
                goto LABEL_134;
            }
            else
            {
              if ((DWORD1(v131[0]) - 7) <= 6)
                v93 = 6;
              else
                v93 = DWORD1(v131[0]) - 7;
              DWORD1(v136) = v93;
              if ((_DWORD)v137)
                goto LABEL_134;
            }
            v102 = DWORD1(v131[0]) - v93;
            if (DWORD1(v131[0]) < v93)
              v102 = 0;
            LODWORD(v137) = v102;
LABEL_134:
            if (!DWORD2(v136))
              v92 = 3;
            if (v92 >= v93)
              v92 = v93;
            DWORD2(v136) = v92;
            *(_DWORD *)(a1 + 2768) = 0;
            if (DWORD1(v132))
              goto LABEL_139;
            goto LABEL_140;
          }
          if (*(_QWORD *)(a1 + 272))
          {
            v81 = *(void (**)(_QWORD))(a1 + 3000);
            if (!v81)
            {
              free(*(void **)(a1 + 272));
              v82 = *(uint64_t (**)(_QWORD, size_t))(a1 + 2992);
              if (v82)
              {
LABEL_127:
                v83 = v82(*(_QWORD *)(a1 + 3008), v80);
                *(_QWORD *)(a1 + 272) = v83;
                if (v83)
                {
LABEL_128:
                  *(_QWORD *)(a1 + 280) = v80;
                  v76 = *(_QWORD *)(a1 + 208);
                  goto LABEL_129;
                }
LABEL_158:
                *(_QWORD *)(a1 + 280) = 0;
                return result;
              }
LABEL_157:
              v103 = malloc_type_malloc(v80, 0x26AA08A0uLL);
              *(_QWORD *)(a1 + 272) = v103;
              if (v103)
                goto LABEL_128;
              goto LABEL_158;
            }
            v81(*(_QWORD *)(a1 + 3008));
          }
          v82 = *(uint64_t (**)(_QWORD, size_t))(a1 + 2992);
          if (v82)
            goto LABEL_127;
          goto LABEL_157;
        }
        if (v62)
        {
          if (v59 > 5)
            v70 = 2;
          else
            v70 = 3;
          v71 = v70 + *(_DWORD *)(a6 + 8);
          if (v71 < 0x15)
          {
            LOBYTE(v71) = 21;
LABEL_105:
            v69 = 1 << v71;
            *(_QWORD *)(a1 + 208) = 1 << v71;
            goto LABEL_106;
          }
        }
        else
        {
          v71 = *(_DWORD *)(a6 + 4) + 2;
          if (v71 < 0x14)
          {
            LOBYTE(v71) = 20;
            goto LABEL_105;
          }
        }
        if (v71 >= 0x1E)
          LOBYTE(v71) = 30;
        goto LABEL_105;
      }
LABEL_76:
      if (v59 - 5 >= 5)
      {
        v60 = 3;
        v61 = *(_DWORD *)(a6 + 4) - 3;
        v62 = *(_DWORD *)(a6 + 96);
        if (!v62)
          goto LABEL_89;
        goto LABEL_79;
      }
      v60 = dword_18823D688[v59 - 5];
      goto LABEL_78;
    }
    if (!v46)
    {
LABEL_75:
      *(_QWORD *)(a1 + 3016) = 0;
      *(_QWORD *)(a1 + 3024) = a5;
      v58 = *(_DWORD *)(a6 + 88);
      v59 = *(_DWORD *)(a6 + 28);
      if (v58)
        goto LABEL_70;
      goto LABEL_76;
    }
    v52 = *(_QWORD *)(v46 + 4936);
    v54 = (_OWORD *)(v46 + 32);
    v53 = *(void **)(v46 + 32);
    if ((unint64_t)v53 <= v46)
    {
      v55 = *(_QWORD *)(v46 + 40) >= v46;
      v56 = *(void (**)(uint64_t))(v46 + 4928);
      *(_OWORD *)(v46 + 64) = 0u;
      *(_OWORD *)(v46 + 80) = 0u;
      *v54 = 0u;
      *(_OWORD *)(v46 + 48) = 0u;
      if (!v53)
        goto LABEL_63;
    }
    else
    {
      v55 = 0;
      v56 = *(void (**)(uint64_t))(v46 + 4928);
      *(_OWORD *)(v46 + 64) = 0u;
      *(_OWORD *)(v46 + 80) = 0u;
      *v54 = 0u;
      *(_OWORD *)(v46 + 48) = 0u;
      if (!v53)
        goto LABEL_63;
    }
    if (!v56)
    {
      free(v53);
      if (v55)
        goto LABEL_75;
      goto LABEL_74;
    }
    v56(v52);
LABEL_63:
    if (v55)
      goto LABEL_75;
    if (v56)
    {
      ((void (*)(uint64_t, unint64_t))v56)(v52, v46);
      goto LABEL_75;
    }
LABEL_74:
    free((void *)v46);
    goto LABEL_75;
  }
  if (POOL_resize(*(_QWORD *)a1, *(unsigned int *)(a6 + 76)))
    return result;
  LODWORD(v129) = v14 + 2;
  v18 = (*(_DWORD *)(a1 + 2944) + 1);
  if (v14 + 2 > v18)
  {
    v122 = a3;
    v19 = *(char **)(a1 + 8);
    if (v19)
    {
      v126 = a4;
      v124 = a2;
      v20 = *(void (**)(size_t, char *))(a1 + 3000);
      size = *(_QWORD *)(a1 + 3008);
      if (*(_DWORD *)(a1 + 2944) != -1)
      {
        v21 = (pthread_cond_t *)(v19 + 80);
        do
        {
          pthread_mutex_destroy((pthread_mutex_t *)&v21[-2].__opaque[24]);
          pthread_cond_destroy(v21);
          v21 = (pthread_cond_t *)((char *)v21 + 424);
          --v18;
        }
        while (v18);
      }
      if (v20)
        v20(size, v19);
      else
        free(v19);
      a2 = v124;
      a4 = v126;
    }
    *(_DWORD *)(a1 + 2944) = 0;
    v131[0] = *(_OWORD *)(a1 + 2992);
    *(_QWORD *)&v131[1] = *(_QWORD *)(a1 + 3008);
    JobsTable = ZSTDMT_createJobsTable((unsigned int *)&v129, (uint64_t)v131);
    *(_QWORD *)(a1 + 8) = JobsTable;
    if (!JobsTable)
      return result;
    *(_DWORD *)(a1 + 2944) = v129 - 1;
    a3 = v122;
  }
  v23 = ZSTDMT_expandBufferPool(*(pthread_mutex_t **)(a1 + 16), v14);
  *(_QWORD *)(a1 + 16) = v23;
  if (v23)
  {
    v127 = a4;
    v24 = a3;
    v25 = *(_QWORD *)(a1 + 24);
    if (!v25)
    {
      *(_QWORD *)(a1 + 24) = 0;
      return result;
    }
    v26 = *(_DWORD *)(v25 + 64);
    if (v26 >= v14)
      goto LABEL_195;
    v131[0] = *(_OWORD *)(v25 + 72);
    *(_QWORD *)&v131[1] = *(_QWORD *)(v25 + 88);
    if (v26 >= 1)
    {
      v27 = 0;
      do
        ZSTD_freeCCtx(*(_QWORD *)(v25 + 96 + 8 * v27++));
      while (v27 < *(int *)(v25 + 64));
    }
    pthread_mutex_destroy((pthread_mutex_t *)v25);
    v28 = *(void (**)(_QWORD, uint64_t))(v25 + 80);
    if (v28)
      v28(*(_QWORD *)(v25 + 88), v25);
    else
      free((void *)v25);
    v129 = v131[0];
    v130 = *(_QWORD *)&v131[1];
    v29 = ZSTDMT_createCCtxPool(v14, &v129);
    *(_QWORD *)(a1 + 24) = v29;
    if (v29)
    {
LABEL_195:
      v30 = ZSTDMT_expandBufferPool(*(pthread_mutex_t **)(a1 + 32), v14);
      *(_QWORD *)(a1 + 32) = v30;
      if (v30)
      {
        v31 = v14 & ~(v14 >> 31);
        v32 = v31 > 0xC8;
        if (v31 >= 200)
          v31 = 200;
        if (!v32 && v14 >= 0)
          v31 = v14;
        *(_DWORD *)(a1 + 116) = v31;
        a3 = v24;
        a4 = v127;
        v15 = *(_QWORD *)(a6 + 80);
        if (v15 - 1 < 0xFFFFF)
          goto LABEL_3;
        goto LABEL_36;
      }
    }
  }
  return result;
}

uint64_t ZSTDMT_nextInputSizeHint(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 208);
  v2 = *(_QWORD *)(a1 + 264);
  if (v1 == v2)
    v2 = 0;
  return v1 - v2;
}

unint64_t HUF_readDTableX1_wksp_bmi2(int *a1, char *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t result;
  int8x16_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  char *v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  _BYTE *v48;
  char v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int64x2_t *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  int64x2_t v59;
  uint64_t v60;
  int64x2_t *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  unsigned __int8 *v69;
  uint64_t v70;
  int v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  unsigned __int8 *v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  int8x16_t v80;
  uint64_t v81;
  int8x16_t *v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  int8x16_t v86;
  int8x16_t v87;
  int8x16_t v88;
  int8x16_t v89;
  int8x16_t v90;
  int8x16_t v91;
  int8x16_t v92;
  int8x16_t v93;
  uint64_t v94;
  double *v95;
  uint64_t *v96;
  uint64_t v97;
  uint64_t v98;
  int8x16_t v99;
  int8x16_t v100;
  int8x16_t v101;
  double *v102;
  int8x16_t v103;
  double *v104;
  double *v105;
  __int128 *v106;
  char *v107;
  uint64_t v108;
  __int128 v109;
  char *v110;
  uint64_t v111;
  int8x8_t v112;
  uint64_t *v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  uint64_t v117;
  char *v118;
  __int128 *v119;
  uint64_t v120;
  __int128 v121;
  __int128 v122;
  int8x16_t v123;
  char *v124;
  uint64_t v125;
  int8x8_t v126;
  char *v127;
  uint64_t *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int8x8_t v133;
  _OWORD *v134;
  int8x16_t *v135;
  uint64_t v136;
  int8x16_t v137;
  int8x16_t v138;
  int8x16_t v139;
  int8x16_t v140;
  int8x16_t v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  double *v150;
  int8x16_t *v151;
  uint64_t v152;
  int8x16_t v153;
  int8x16_t v154;
  int8x16_t v155;
  int8x16_t v156;
  float64x2_t v157;
  float64x2_t v158;
  float64x2_t v159;
  float64x2_t v160;
  int8x16_t v161;
  double *v162;
  double *v163;
  double *v164;
  double *v165;
  double *v166;
  double *v167;
  double *v168;
  int *v169;
  uint64_t v170;
  int8x16x2_t v171;
  float64x2x2_t v172;
  float64x2x2_t v173;
  float64x2x2_t v174;
  float64x2x2_t v175;
  float64x2x2_t v176;
  float64x2x2_t v177;
  float64x2x2_t v178;
  float64x2x2_t v179;
  float64x2x2_t v180;
  float64x2x2_t v181;
  int8x16x4_t v182;

  v170 = 0;
  if (a5 < 0x3E4)
    return -44;
  result = HUF_readStats_wksp((unsigned __int8 *)(a4 + 740), 0x100uLL, a4, &v170, (_DWORD *)&v170 + 1, a2, a3, (unsigned __int16 *)(a4 + 128), 0x164uLL);
  if (result > 0xFFFFFFFFFFFFFF88)
    return result;
  v9 = *a1;
  v10 = HIDWORD(v170);
  if (HIDWORD(v170) > *a1 + 1)
    return -44;
  *(_WORD *)a1 = v9;
  *((_BYTE *)a1 + 2) = v10;
  *((_BYTE *)a1 + 3) = HIBYTE(v9);
  v11 = v170;
  if ((v10 & 0x80000000) == 0)
  {
    v12 = 0;
    v13 = v10 + 1;
    v14 = (_DWORD *)(a4 + 64);
    do
    {
      v15 = *(v14 - 16);
      *v14++ = v12;
      v12 += v15;
      --v13;
    }
    while (v13);
  }
  if ((int)v11 < 4)
  {
    LODWORD(v16) = 0;
    if ((int)v11 <= 0)
      goto LABEL_16;
    goto LABEL_14;
  }
  v16 = 0;
  do
  {
    v17 = 4 * *(unsigned __int8 *)(a4 + v16 + 740);
    v18 = a4 + 64;
    v19 = *(unsigned int *)(a4 + 64 + v17);
    *(_DWORD *)(v18 + v17) = v19 + 1;
    v20 = a4 + 484;
    *(_BYTE *)(v20 + v19) = v16;
    v21 = 4 * *(unsigned __int8 *)(a4 + v16 + 741);
    v22 = *(unsigned int *)(a4 + 64 + v21);
    *(_DWORD *)(v18 + v21) = v22 + 1;
    *(_BYTE *)(v20 + v22) = v16 + 1;
    v23 = 4 * *(unsigned __int8 *)(a4 + v16 + 742);
    v24 = *(unsigned int *)(a4 + 64 + v23);
    *(_DWORD *)(v18 + v23) = v24 + 1;
    *(_BYTE *)(v20 + v24) = v16 + 2;
    v25 = 4 * *(unsigned __int8 *)(a4 + v16 + 743);
    v26 = *(unsigned int *)(a4 + 64 + v25);
    *(_DWORD *)(v18 + v25) = v26 + 1;
    *(_BYTE *)(v20 + v26) = v16 + 3;
    v16 += 4;
  }
  while (v16 < (v11 - 3));
  if ((int)v16 < (int)v11)
  {
LABEL_14:
    v16 = v16;
    do
    {
      v27 = a4 + 4 * *(unsigned __int8 *)(a4 + 740 + v16);
      v28 = *(unsigned int *)(v27 + 64);
      *(_DWORD *)(v27 + 64) = v28 + 1;
      *(_BYTE *)(a4 + v28 + 484) = v16++;
    }
    while (v11 != v16);
  }
LABEL_16:
  v29 = (v10 + 1);
  if (v29 >= 2)
  {
    v30 = 0;
    v31 = *(_DWORD *)a4;
    v32 = a1 + 1;
    v33 = a4 + 484;
    v169 = a1 + 17;
    v34 = 1;
    while (1)
    {
      v35 = *(unsigned int *)(a4 + 4 * v34);
      v36 = 1 << v34 >> 1;
      v37 = v29 - v34;
      switch(v36)
      {
        case 1:
          if ((int)v35 < 1)
            goto LABEL_18;
          if (v35 < 8
            || (unint64_t)v32 + 2 * v30 < v33 + v31 + v35
            && v33 + v31 < (unint64_t)v32 + 2 * v30 + 2 * v35)
          {
            v38 = 0;
            v39 = v30;
            goto LABEL_25;
          }
          if (v35 >= 0x20)
          {
            v38 = v35 & 0x7FFFFFE0;
            v8 = vdupq_n_s8(v37);
            v106 = (__int128 *)(v33 + v31);
            v107 = (char *)a1 + 2 * v30 + 36;
            v108 = v35 & 0xFFFFFFE0;
            do
            {
              v109 = *v106;
              v171.val[0] = (int8x16_t)v106[1];
              v106 += 2;
              v110 = v107 - 32;
              vst2q_s8(v110, *(int8x16x2_t *)(&v8 - 1));
              v171.val[1] = v8;
              vst2q_s8(v107, v171);
              v107 += 64;
              v108 -= 32;
            }
            while (v108);
            if (v38 == v35)
              goto LABEL_18;
            if ((v35 & 0x18) == 0)
            {
              v39 = v38 + v30;
LABEL_25:
              v40 = (char *)a1 + 2 * v39 + 5;
              v41 = (char *)(v33 + v38 + v31);
              v42 = v35 - v38;
              do
              {
                v43 = *v41++;
                *(v40 - 1) = v43;
                *v40 = v37;
                v40 += 2;
                --v42;
              }
              while (v42);
              goto LABEL_18;
            }
          }
          else
          {
            v38 = 0;
          }
          v111 = v38;
          v38 = v35 & 0xFFFFFFF8;
          v112 = vdup_n_s8(v37);
          v39 = v38 + v30;
          v113 = (uint64_t *)(v33 + v111 + v31);
          v114 = v111 - v38;
          v115 = (char *)v32 + 2 * v111 + 2 * v30;
          do
          {
            v116 = *v113++;
            v117 = v116;
            vst2_s8(v115, *(int8x8x2_t *)(&v112 - 1));
            v115 += 16;
            v114 += 8;
          }
          while (v114);
          if (v38 != v35)
            goto LABEL_25;
LABEL_18:
          v31 += v35;
          v30 += v35 * v36;
          if (++v34 == v29)
            return result;
          break;
        case 2:
          if ((int)v35 < 1)
            goto LABEL_18;
          if (v35 < 8
            || (unint64_t)v32 + 2 * v30 < v33 + v31 + v35 && v33 + v31 < (unint64_t)&v32[v35] + 2 * v30)
          {
            v44 = 0;
            v45 = v30;
            goto LABEL_33;
          }
          if (v35 >= 0x20)
          {
            v44 = v35 & 0x7FFFFFE0;
            v8 = vdupq_n_s8(v37);
            v118 = (char *)v169 + 2 * v30;
            v119 = (__int128 *)(v33 + v31);
            v120 = v35 & 0xFFFFFFE0;
            do
            {
              v121 = *v119;
              v182.val[0] = (int8x16_t)v119[1];
              v119 += 2;
              v122 = v121;
              v123 = v8;
              v182.val[1] = v8;
              v182.val[2] = v182.val[0];
              v182.val[3] = v8;
              v124 = v118 - 64;
              vst4q_s8(v124, *(int8x16x4_t *)(&v8 - 1));
              vst4q_s8(v118, v182);
              v118 += 128;
              v120 -= 32;
            }
            while (v120);
            if (v44 == v35)
              goto LABEL_18;
            if ((v35 & 0x18) == 0)
            {
              v45 = v30 + 2 * v44;
LABEL_33:
              v46 = v35 - v44;
              v47 = (char *)(v33 + v44 + v31);
              v48 = (char *)a1 + 2 * v45 + 7;
              do
              {
                v49 = *v47++;
                *(v48 - 3) = v49;
                *(v48 - 2) = v37;
                *(v48 - 1) = v49;
                *v48 = v37;
                v48 += 4;
                --v46;
              }
              while (v46);
              goto LABEL_18;
            }
          }
          else
          {
            v44 = 0;
          }
          v125 = v44;
          v44 = v35 & 0xFFFFFFF8;
          v45 = v30 + 2 * v44;
          v126 = vdup_n_s8(v37);
          v127 = (char *)&v32[v125] + 2 * v30;
          v128 = (uint64_t *)(v33 + v125 + v31);
          v129 = v125 - v44;
          do
          {
            v130 = *v128++;
            v131 = v130;
            v132 = v130;
            v133 = v126;
            vst4_s8(v127, *(int8x8x4_t *)(&v126 - 1));
            v127 += 32;
            v129 += 8;
          }
          while (v129);
          if (v44 != v35)
            goto LABEL_33;
          goto LABEL_18;
        case 4:
          if ((int)v35 < 1)
            goto LABEL_18;
          v65 = (v29 - v34) << 8;
          if (v35 < 8
            || (unint64_t)v32 + 2 * v30 < v33 + v31 + v35
            && v33 + v31 < (unint64_t)&v32[2 * v35] + 2 * v30)
          {
            v66 = 0;
            v67 = v30;
            goto LABEL_56;
          }
          v80 = (int8x16_t)vdupq_n_s32(v65);
          if (v35 >= 0x10)
          {
            v66 = v35 & 0x7FFFFFF0;
            v134 = (_OWORD *)((char *)v32 + 2 * v30);
            v135 = (int8x16_t *)(v33 + v31);
            v136 = v35 & 0xFFFFFFF0;
            do
            {
              v137 = *v135++;
              v138 = vorrq_s8(v80, vqtbl1q_s8(v137, (int8x16_t)xmmword_18823D740));
              v139 = vorrq_s8(v80, vqtbl1q_s8(v137, (int8x16_t)xmmword_18823D710));
              v140 = vorrq_s8(v80, vqtbl1q_s8(v137, (int8x16_t)xmmword_18823D720));
              v141 = vorrq_s8(v80, vqtbl1q_s8(v137, (int8x16_t)xmmword_18823D730));
              *(_QWORD *)&v142 = v141.u32[2];
              *((_QWORD *)&v142 + 1) = v141.u32[3];
              v143 = v142;
              *(_QWORD *)&v142 = v140.u32[2];
              *((_QWORD *)&v142 + 1) = v140.u32[3];
              v144 = v142;
              *(_QWORD *)&v142 = v139.u32[2];
              *((_QWORD *)&v142 + 1) = v139.u32[3];
              v145 = v142;
              *(_QWORD *)&v142 = v138.u32[2];
              *((_QWORD *)&v142 + 1) = v138.u32[3];
              v146 = v142;
              *(_QWORD *)&v142 = v141.u32[0];
              *((_QWORD *)&v142 + 1) = v141.u32[1];
              v147 = v142;
              *(_QWORD *)&v142 = v140.u32[0];
              *((_QWORD *)&v142 + 1) = v140.u32[1];
              v148 = v142;
              *(_QWORD *)&v142 = v139.u32[0];
              *((_QWORD *)&v142 + 1) = v139.u32[1];
              v149 = v142;
              *((_QWORD *)&v142 + 1) = v138.u32[1];
              v8.i64[0] = 0x1000100010001 * v138.u32[0];
              v8.i64[1] = 0x1000100010001 * *((_QWORD *)&v142 + 1);
              *(_QWORD *)&v149 = 0x1000100010001 * v149;
              *((_QWORD *)&v149 + 1) *= 0x1000100010001;
              *(_QWORD *)&v148 = 0x1000100010001 * v148;
              *((_QWORD *)&v148 + 1) *= 0x1000100010001;
              *(_QWORD *)&v147 = 0x1000100010001 * v147;
              *((_QWORD *)&v147 + 1) *= 0x1000100010001;
              *(_QWORD *)&v146 = 0x1000100010001 * v146;
              *((_QWORD *)&v146 + 1) *= 0x1000100010001;
              *(_QWORD *)&v145 = 0x1000100010001 * v145;
              *((_QWORD *)&v145 + 1) *= 0x1000100010001;
              *(_QWORD *)&v144 = 0x1000100010001 * v144;
              *((_QWORD *)&v144 + 1) *= 0x1000100010001;
              *(_QWORD *)&v143 = 0x1000100010001 * v143;
              *((_QWORD *)&v143 + 1) *= 0x1000100010001;
              v134[4] = v147;
              v134[5] = v143;
              v134[2] = v148;
              v134[3] = v144;
              *v134 = v149;
              v134[1] = v145;
              v134[6] = v8;
              v134[7] = v146;
              v134 += 8;
              v136 -= 16;
            }
            while (v136);
            if (v66 == v35)
              goto LABEL_18;
            if ((v35 & 8) == 0)
            {
              v67 = v30 + 4 * v66;
LABEL_56:
              v68 = (_QWORD *)((char *)v32 + 2 * v67);
              v69 = (unsigned __int8 *)(v33 + v66 + v31);
              v70 = v35 - v66;
              do
              {
                v71 = *v69++;
                *v68++ = 0x1000100010001 * (v65 | v71);
                --v70;
              }
              while (v70);
              goto LABEL_18;
            }
          }
          else
          {
            v66 = 0;
          }
          v81 = v66;
          v66 = v35 & 0xFFFFFFF8;
          v67 = v30 + 4 * v66;
          v82 = (int8x16_t *)((char *)&v32[2 * v81] + 2 * v30);
          v83 = (uint64_t *)(v33 + v81 + v31);
          v84 = v81 - v66;
          do
          {
            v85 = *v83++;
            v8.i64[0] = v85;
            v86 = vqtbl1q_s8(v8, (int8x16_t)xmmword_18823D720);
            v87 = vorrq_s8(v80, vqtbl1q_s8(v8, (int8x16_t)xmmword_18823D710));
            v88 = vorrq_s8(v80, v86);
            v89.i64[0] = v88.u32[2];
            v89.i64[1] = v88.u32[3];
            v90 = v89;
            v89.i64[0] = v87.u32[2];
            v89.i64[1] = v87.u32[3];
            v91 = v89;
            v89.i64[0] = v88.u32[0];
            v89.i64[1] = v88.u32[1];
            v92 = v89;
            v89.i64[1] = v87.u32[1];
            v8.i64[0] = 0x1000100010001 * v87.u32[0];
            v8.i64[1] = 0x1000100010001 * v89.i64[1];
            v92.i64[0] *= 0x1000100010001;
            v92.i64[1] *= 0x1000100010001;
            v91.i64[0] *= 0x1000100010001;
            v91.i64[1] *= 0x1000100010001;
            v90.i64[0] *= 0x1000100010001;
            v90.i64[1] *= 0x1000100010001;
            v82[2] = v92;
            v82[3] = v90;
            *v82 = v8;
            v82[1] = v91;
            v82 += 4;
            v84 += 8;
          }
          while (v84);
          if (v66 != v35)
            goto LABEL_56;
          goto LABEL_18;
        case 8:
          if ((int)v35 < 1)
            goto LABEL_18;
          v72 = (v29 - v34) << 8;
          if (v35 < 8
            || (unint64_t)v32 + 2 * v30 < v33 + v31 + v35
            && v33 + v31 < (unint64_t)&v32[4 * v35] + 2 * v30)
          {
            v73 = 0;
            v74 = v30;
            goto LABEL_64;
          }
          v93 = (int8x16_t)vdupq_n_s32(v72);
          if (v35 >= 0x10)
          {
            v73 = v35 & 0x7FFFFFF0;
            v150 = (double *)((char *)v32 + 2 * v30);
            v151 = (int8x16_t *)(v33 + v31);
            v152 = v35 & 0xFFFFFFF0;
            do
            {
              v153 = *v151++;
              v154 = vorrq_s8(v93, vqtbl1q_s8(v153, (int8x16_t)xmmword_18823D740));
              v172.val[0] = (float64x2_t)vorrq_s8(v93, vqtbl1q_s8(v153, (int8x16_t)xmmword_18823D730));
              v155 = vorrq_s8(v93, vqtbl1q_s8(v153, (int8x16_t)xmmword_18823D720));
              v156 = vorrq_s8(v93, vqtbl1q_s8(v153, (int8x16_t)xmmword_18823D710));
              *(_QWORD *)&v157.f64[0] = v156.u32[0];
              *(_QWORD *)&v157.f64[1] = v156.u32[1];
              v158 = v157;
              *(_QWORD *)&v157.f64[0] = v156.u32[2];
              *(_QWORD *)&v157.f64[1] = v156.u32[3];
              v174.val[0] = v157;
              *(_QWORD *)&v157.f64[0] = v155.u32[0];
              *(_QWORD *)&v157.f64[1] = v155.u32[1];
              v159 = v157;
              *(_QWORD *)&v157.f64[0] = v155.u32[2];
              *(_QWORD *)&v157.f64[1] = v155.u32[3];
              v176.val[0] = v157;
              *(_QWORD *)&v157.f64[0] = LODWORD(v172.val[0].f64[0]);
              *(_QWORD *)&v157.f64[1] = HIDWORD(v172.val[0].f64[0]);
              v160 = v157;
              *(_QWORD *)&v157.f64[0] = LODWORD(v172.val[0].f64[1]);
              *(_QWORD *)&v157.f64[1] = HIDWORD(v172.val[0].f64[1]);
              v178.val[0] = v157;
              *(_QWORD *)&v157.f64[0] = v154.u32[0];
              *(_QWORD *)&v157.f64[1] = v154.u32[1];
              v8.i64[0] = 0x1000100010001 * v154.u32[2];
              v8.i64[1] = 0x1000100010001 * v154.u32[3];
              *(_QWORD *)&v172.val[0].f64[0] = 0x1000100010001 * *(_QWORD *)&v157.f64[0];
              *(_QWORD *)&v172.val[0].f64[1] = 0x1000100010001 * *(_QWORD *)&v157.f64[1];
              *(_QWORD *)&v178.val[0].f64[0] *= 0x1000100010001;
              *(_QWORD *)&v178.val[0].f64[1] *= 0x1000100010001;
              *(_QWORD *)&v179.val[0].f64[0] = 0x1000100010001 * *(_QWORD *)&v160.f64[0];
              *(_QWORD *)&v179.val[0].f64[1] = 0x1000100010001 * *(_QWORD *)&v160.f64[1];
              *(_QWORD *)&v176.val[0].f64[0] *= 0x1000100010001;
              *(_QWORD *)&v176.val[0].f64[1] *= 0x1000100010001;
              *(_QWORD *)&v180.val[0].f64[0] = 0x1000100010001 * *(_QWORD *)&v159.f64[0];
              *(_QWORD *)&v180.val[0].f64[1] = 0x1000100010001 * *(_QWORD *)&v159.f64[1];
              v161 = v8;
              *(_QWORD *)&v174.val[0].f64[0] *= 0x1000100010001;
              *(_QWORD *)&v174.val[0].f64[1] *= 0x1000100010001;
              *(_QWORD *)&v181.val[0].f64[0] = 0x1000100010001 * *(_QWORD *)&v158.f64[0];
              *(_QWORD *)&v181.val[0].f64[1] = 0x1000100010001 * *(_QWORD *)&v158.f64[1];
              v181.val[1] = v181.val[0];
              v162 = v150;
              vst2q_f64(v162, v181);
              v162 += 4;
              v172.val[1] = v172.val[0];
              v174.val[1] = v174.val[0];
              vst2q_f64(v162, v174);
              v180.val[1] = v180.val[0];
              v163 = v150 + 8;
              vst2q_f64(v163, v180);
              v176.val[1] = v176.val[0];
              v164 = v150 + 12;
              vst2q_f64(v164, v176);
              v179.val[1] = v179.val[0];
              v165 = v150 + 16;
              vst2q_f64(v165, v179);
              v178.val[1] = v178.val[0];
              v166 = v150 + 20;
              vst2q_f64(v166, v178);
              v167 = v150 + 24;
              vst2q_f64(v167, v172);
              v168 = v150 + 28;
              vst2q_f64(v168, *(float64x2x2_t *)v8.i8);
              v150 += 32;
              v152 -= 16;
            }
            while (v152);
            if (v73 == v35)
              goto LABEL_18;
            if ((v35 & 8) == 0)
            {
              v74 = v30 + 8 * v73;
LABEL_64:
              v75 = (uint64_t *)((char *)a1 + 2 * v74 + 12);
              v76 = (unsigned __int8 *)(v33 + v73 + v31);
              v77 = v35 - v73;
              do
              {
                v78 = *v76++;
                v79 = 0x1000100010001 * (v72 | v78);
                *(v75 - 1) = v79;
                *v75 = v79;
                v75 += 2;
                --v77;
              }
              while (v77);
              goto LABEL_18;
            }
          }
          else
          {
            v73 = 0;
          }
          v94 = v73;
          v73 = v35 & 0xFFFFFFF8;
          v74 = v30 + 8 * v73;
          v95 = (double *)((char *)&v32[4 * v94] + 2 * v30);
          v96 = (uint64_t *)(v33 + v94 + v31);
          v97 = v94 - v73;
          do
          {
            v98 = *v96++;
            v8.i64[0] = v98;
            v99 = vqtbl1q_s8(v8, (int8x16_t)xmmword_18823D710);
            v100 = vorrq_s8(v93, vqtbl1q_s8(v8, (int8x16_t)xmmword_18823D720));
            v101 = vorrq_s8(v93, v99);
            *(_QWORD *)&v173.val[0].f64[0] = 0x1000100010001 * v100.u32[2];
            *(_QWORD *)&v173.val[0].f64[1] = 0x1000100010001 * v100.u32[3];
            *(_QWORD *)&v175.val[0].f64[0] = 0x1000100010001 * v100.u32[0];
            *(_QWORD *)&v175.val[0].f64[1] = 0x1000100010001 * v100.u32[1];
            v173.val[1] = v173.val[0];
            v8.i64[0] = 0x1000100010001 * v101.u32[2];
            v8.i64[1] = 0x1000100010001 * v101.u32[3];
            *(_QWORD *)&v177.val[0].f64[0] = 0x1000100010001 * v101.u32[0];
            *(_QWORD *)&v177.val[0].f64[1] = 0x1000100010001 * v101.u32[1];
            v177.val[1] = v177.val[0];
            v102 = v95;
            vst2q_f64(v102, v177);
            v102 += 4;
            v175.val[1] = v175.val[0];
            v103 = v8;
            vst2q_f64(v102, *(float64x2x2_t *)v8.i8);
            v104 = v95 + 8;
            vst2q_f64(v104, v175);
            v105 = v95 + 12;
            vst2q_f64(v105, v173);
            v95 += 16;
            v97 += 8;
          }
          while (v97);
          if (v73 != v35)
            goto LABEL_64;
          goto LABEL_18;
        default:
          if ((int)v35 < 1)
            goto LABEL_18;
          v50 = 0;
          if (v36 <= 16)
            v51 = 16;
          else
            v51 = v36;
          v52 = ((v51 - 1) >> 4) + 1;
          v53 = 2 * v30;
          v54 = (int64x2_t *)((char *)v169 + v53);
          v55 = 2 * v36;
          v56 = (uint64_t)a1 + v53;
          while (2)
          {
            if (1 << v34 < 2)
              goto LABEL_41;
            v57 = 0x1000100010001
                * (((v29 - v34) << 8) | *(unsigned __int8 *)(a4 + v50 + v31 + 484));
            if (v51 < 0x31)
            {
              v58 = 0;
              goto LABEL_48;
            }
            v59 = vdupq_n_s64(v57);
            v60 = v52 & 0x1FFFFFFFFFFFFFFCLL;
            v61 = v54;
            do
            {
              v61[-4] = v59;
              v61[-3] = v59;
              v61[-2] = v59;
              v61[-1] = v59;
              *v61 = v59;
              v61[1] = v59;
              v61[2] = v59;
              v61[3] = v59;
              v61 += 8;
              v60 -= 4;
            }
            while (v60);
            v58 = 16 * (v52 & 0x1FFFFFFFFFFFFFFCLL);
            if (v52 != (v52 & 0x1FFFFFFFFFFFFFFCLL))
            {
LABEL_48:
              v62 = 2 * v58;
              v63 = v56;
              do
              {
                v64 = v63 + v62;
                *(_QWORD *)(v64 + 4) = v57;
                *(_QWORD *)(v64 + 12) = v57;
                *(_QWORD *)(v64 + 20) = v57;
                *(_QWORD *)(v64 + 28) = v57;
                v58 += 16;
                v63 += 32;
              }
              while (v58 < v36);
            }
LABEL_41:
            ++v50;
            v54 = (int64x2_t *)((char *)v54 + v55);
            v56 += v55;
            if (v50 == v35)
              goto LABEL_18;
            continue;
          }
      }
    }
  }
  return result;
}

uint64_t HUF_decompress1X1_usingDTable(_BYTE *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5)
{
  if (*(_BYTE *)(a5 + 1))
    return -1;
  else
    return HUF_decompress1X1_usingDTable_internal(a1, a2, a3, a4, a5);
}

uint64_t HUF_decompress1X1_usingDTable_internal(_BYTE *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;
  int v13;
  _BYTE *v14;
  uint64_t v15;
  unint64_t v16;
  _BOOL4 v17;
  unsigned int v18;
  _BYTE *v19;
  unsigned int v20;
  _BYTE *v21;
  unsigned int v22;
  _BYTE *v23;
  unsigned int v24;
  char *v25;
  char v26;
  _BYTE *v27;
  uint64_t v28;
  _BYTE *v29;

  if (!a4)
    return -72;
  v5 = a4 - 8;
  if (a4 < 8)
  {
    v6 = *a3;
    switch(a4)
    {
      case 2uLL:
        goto LABEL_14;
      case 3uLL:
        goto LABEL_13;
      case 4uLL:
        goto LABEL_12;
      case 5uLL:
        goto LABEL_11;
      case 6uLL:
        goto LABEL_10;
      case 7uLL:
        v6 |= (unint64_t)a3[6] << 48;
LABEL_10:
        v6 += (unint64_t)a3[5] << 40;
LABEL_11:
        v6 += (unint64_t)a3[4] << 32;
LABEL_12:
        v6 += (unint64_t)a3[3] << 24;
LABEL_13:
        v6 += (unint64_t)a3[2] << 16;
LABEL_14:
        v6 += (unint64_t)a3[1] << 8;
        break;
      default:
        break;
    }
    if (!a3[a4 - 1])
      return -20;
    v5 = 0;
    v7 = __clz(a3[a4 - 1]) - 8 * a4 + 41;
    goto LABEL_17;
  }
  if (!a3[a4 - 1])
    return -1;
  if (a4 > 0xFFFFFFFFFFFFFF88)
    return a4;
  v6 = *(_QWORD *)&a3[v5];
  v7 = __clz(a3[a4 - 1]) - 23;
LABEL_17:
  v9 = (unint64_t)&a1[a2];
  v10 = a5 + 4;
  v11 = &a3[v5];
  v12 = (unint64_t)&a1[a2 - 3];
  v13 = -*(unsigned __int16 *)(a5 + 2) & 0x3F;
  v14 = a1;
  while (1)
  {
    if (v5 >= 8)
    {
      v17 = 0;
      v18 = v7 >> 3;
      v7 &= 7u;
      v5 -= v18;
      v11 = &a3[v5];
      v6 = *(_QWORD *)&a3[v5];
      if ((unint64_t)v14 >= v12)
        goto LABEL_30;
      goto LABEL_25;
    }
    if (!v5)
      break;
    v15 = v7 >> 3;
    v16 = (unint64_t)&v11[-v15];
    v17 = v16 < (unint64_t)a3;
    if (v16 < (unint64_t)a3)
      LODWORD(v15) = v5;
    v7 -= 8 * v15;
    v5 -= v15;
    v11 = &a3[v5];
    v6 = *(_QWORD *)&a3[v5];
    if ((unint64_t)v14 >= v12)
    {
LABEL_30:
      v27 = v14;
LABEL_31:
      if ((unint64_t)v27 >= v9)
        goto LABEL_34;
      goto LABEL_32;
    }
LABEL_25:
    if (v17)
      goto LABEL_30;
    v19 = (_BYTE *)(v10 + 2 * ((unint64_t)(v6 << v7) >> v13));
    v20 = v7 + v19[1];
    *v14 = *v19;
    v21 = (_BYTE *)(v10 + 2 * ((unint64_t)(v6 << v20) >> v13));
    v22 = v20 + v21[1];
    v14[1] = *v21;
    v23 = (_BYTE *)(v10 + 2 * ((unint64_t)(v6 << v22) >> v13));
    v24 = v22 + v23[1];
    v14[2] = *v23;
    v25 = (char *)(v10 + 2 * ((unint64_t)(v6 << v24) >> v13));
    v26 = *v25;
    v7 = v24 + v25[1];
    v27 = v14 + 4;
    v14[3] = v26;
    v14 += 4;
    if (v7 >= 0x41)
      goto LABEL_31;
  }
  v27 = v14;
  if ((unint64_t)v14 >= v9)
    goto LABEL_34;
LABEL_32:
  v28 = &a1[a2] - v27;
  do
  {
    v29 = (_BYTE *)(v10 + 2 * ((unint64_t)(v6 << v7) >> v13));
    v7 += v29[1];
    *v27++ = *v29;
    --v28;
  }
  while (v28);
LABEL_34:
  if (v7 == 64 && v11 == a3)
    return a2;
  else
    return -20;
}

unint64_t HUF_decompress1X1_DCtx_wksp(int *a1, _BYTE *a2, uint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t result;

  result = HUF_readDTableX1_wksp_bmi2(a1, a4, a5, a6, a7);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
      return -72;
    else
      return HUF_decompress1X1_usingDTable_internal(a2, a3, (unsigned __int8 *)&a4[result], a5 - result, (uint64_t)a1);
  }
  return result;
}

unint64_t HUF_decompress4X1_usingDTable(_BYTE *a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5)
{
  if (*(_BYTE *)(a5 + 1))
    return -1;
  else
    return HUF_decompress4X1_usingDTable_internal(a1, a2, a3, a4, a5);
}

unint64_t HUF_decompress4X1_usingDTable_internal(_BYTE *a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned __int8 *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned __int8 *v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned __int8 *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  _BYTE *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  unsigned int v42;
  unint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  _BYTE *v46;
  _BYTE *v47;
  _BYTE *v48;
  _BYTE *v49;
  _BYTE *v50;
  _BYTE *v51;
  unsigned int v52;
  _BYTE *v53;
  unsigned int v54;
  char *v55;
  char v56;
  _BYTE *v57;
  unsigned int v58;
  _BYTE *v59;
  unsigned int v60;
  _BYTE *v61;
  unsigned int v62;
  _BYTE *v63;
  _BYTE *v64;
  unsigned int v65;
  _BYTE *v66;
  unsigned int v67;
  _BYTE *v68;
  unsigned int v69;
  _BYTE *v70;
  int v71;
  _BYTE *v72;
  unsigned int v73;
  _BYTE *v74;
  _BYTE *v75;
  int v76;
  _BYTE *v77;
  int v78;
  _BYTE *v79;
  int v80;
  int v81;
  uint64_t v82;
  int v83;
  int v84;
  int v85;
  _BYTE *v86;
  _BYTE *v87;
  _BYTE *v88;
  _BYTE *v89;
  _BYTE *v90;
  int v91;
  unsigned __int8 *v92;
  int v93;
  uint64_t v94;
  unsigned int v95;
  _BOOL4 v96;
  char *v97;
  char v98;
  _BYTE *v99;
  _BYTE *v100;
  char *v101;
  char v102;
  unint64_t v103;
  _BYTE *v104;
  char *v105;
  _BYTE *v106;
  int v107;
  unint64_t v108;
  _BOOL4 v109;
  unsigned int v110;
  char *v111;
  char v112;
  _BYTE *v113;
  _BYTE *v114;
  char *v115;
  char v116;
  _BYTE *v117;
  unsigned __int8 *v118;
  _BYTE *v119;
  int v120;
  unint64_t v121;
  _BOOL4 v122;
  unsigned int v123;
  char *v124;
  char v125;
  _BYTE *v126;
  _BYTE *v127;
  char *v128;
  char v129;
  _BYTE *v130;
  unsigned int v131;
  _BYTE *v132;
  uint64_t v133;
  char *v134;
  char v135;
  int v143;
  uint64_t v144;
  _BOOL4 v145;
  uint64_t *v146;
  uint64_t v147;
  unsigned __int8 *v148;
  int v149;
  _BYTE *v150;
  _BYTE *v151;
  _BYTE *v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  _BYTE *v156;
  char *v157;
  unsigned __int8 *v158;
  __int128 v159;
  __int128 v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;

  if (a4 < 0xA)
    return -20;
  v162 = v5;
  v163 = v6;
  v161 = 0;
  v159 = 0u;
  v160 = 0u;
  v9 = *a3;
  v10 = a3[1];
  v11 = a3[2];
  v13 = v9 + 6 + v10 + v11;
  v14 = a4 - v13;
  if (a4 < v13)
    return -20;
  if (!(_DWORD)v9)
    return -72;
  v16 = (unsigned __int8 *)(a3 + 3);
  if (v9 < 8)
  {
    v19 = *v16;
    switch((int)v9)
    {
      case 2:
        goto LABEL_16;
      case 3:
        goto LABEL_15;
      case 4:
        goto LABEL_14;
      case 5:
        goto LABEL_13;
      case 6:
        goto LABEL_12;
      case 7:
        v19 |= (unint64_t)*((unsigned __int8 *)a3 + 12) << 48;
LABEL_12:
        v19 += (unint64_t)*((unsigned __int8 *)a3 + 11) << 40;
LABEL_13:
        v19 += (unint64_t)*((unsigned __int8 *)a3 + 10) << 32;
LABEL_14:
        v19 += (unint64_t)*((unsigned __int8 *)a3 + 9) << 24;
LABEL_15:
        v19 += (unint64_t)*((unsigned __int8 *)a3 + 8) << 16;
LABEL_16:
        v19 += (unint64_t)*((unsigned __int8 *)a3 + 7) << 8;
        break;
      default:
        break;
    }
    v21 = v16[v9 - 1];
    if (!v21)
      return -20;
    v20 = __clz(v21) - 8 * v9 + 41;
    v18 = 6;
    if ((_DWORD)v10)
      goto LABEL_19;
    return -72;
  }
  v17 = v16[v9 - 1];
  if (!v17)
    return -1;
  v18 = v9 - 2;
  v19 = *(_QWORD *)((char *)a3 + v9 - 2);
  v20 = __clz(v17) - 23;
  if (!(_DWORD)v10)
    return -72;
LABEL_19:
  v12 = v9 + 6;
  v22 = (unsigned __int8 *)a3 + v9 + 6;
  if (v10 >= 8)
  {
    if (v22[v10 - 1])
    {
      v23 = v10 - 8;
      v24 = *(_QWORD *)&v22[v10 - 8];
      v25 = __clz(v22[v10 - 1]) - 23;
      goto LABEL_31;
    }
    return -1;
  }
  v24 = *v22;
  switch((int)v10)
  {
    case 2:
      goto LABEL_28;
    case 3:
      goto LABEL_27;
    case 4:
      goto LABEL_26;
    case 5:
      goto LABEL_25;
    case 6:
      goto LABEL_24;
    case 7:
      v24 |= (unint64_t)v22[6] << 48;
LABEL_24:
      v24 += (unint64_t)v22[5] << 40;
LABEL_25:
      v24 += (unint64_t)v22[4] << 32;
LABEL_26:
      v24 += (unint64_t)v22[3] << 24;
LABEL_27:
      v24 += (unint64_t)v22[2] << 16;
LABEL_28:
      v24 += (unint64_t)v22[1] << 8;
      break;
    default:
      break;
  }
  if (!v22[v10 - 1])
    return -20;
  v23 = 0;
  v25 = __clz(v22[v10 - 1]) - 8 * v10 + 41;
LABEL_31:
  if (!(_DWORD)v11)
    return -72;
  v26 = &v22[v10];
  if (v11 < 8)
  {
    v28 = *v26;
    switch((int)v11)
    {
      case 2:
        goto LABEL_44;
      case 3:
        goto LABEL_43;
      case 4:
        goto LABEL_42;
      case 5:
        goto LABEL_41;
      case 6:
        goto LABEL_40;
      case 7:
        v28 |= (unint64_t)v26[6] << 48;
LABEL_40:
        v28 += (unint64_t)v26[5] << 40;
LABEL_41:
        v28 += (unint64_t)v26[4] << 32;
LABEL_42:
        v28 += (unint64_t)v26[3] << 24;
LABEL_43:
        v28 += (unint64_t)v26[2] << 16;
LABEL_44:
        v28 += (unint64_t)v26[1] << 8;
        break;
      default:
        break;
    }
    if (v26[v11 - 1])
    {
      v156 = a1;
      v157 = (char *)a3 + v12;
      v154 = a2;
      v155 = v18;
      v153 = *(unsigned __int16 *)(a5 + 2);
      v27 = 0;
      v29 = __clz(v26[v11 - 1]) - 8 * v11 + 41;
      goto LABEL_47;
    }
    return -20;
  }
  if (!v26[v11 - 1])
    return -1;
  v156 = a1;
  v157 = (char *)a3 + v12;
  v154 = a2;
  v155 = v18;
  v153 = *(unsigned __int16 *)(a5 + 2);
  v27 = v11 - 8;
  v28 = *(_QWORD *)&v26[v11 - 8];
  v29 = __clz(v26[v11 - 1]) - 23;
LABEL_47:
  v158 = &v22[v10];
  result = BIT_initDStream((uint64_t)&v159, &v26[v11], v14);
  v31 = v155;
  v30 = v156;
  if (result > 0xFFFFFFFFFFFFFF88)
    return result;
  v32 = (unint64_t)&v156[v154];
  v33 = (unint64_t)&v156[v154 - 3];
  v34 = a5 + 4;
  v35 = (unint64_t)(v154 + 3) >> 2;
  v36 = (unint64_t)&v156[v35];
  v37 = (unint64_t)&v156[v35 + v35];
  v38 = v37 + v35;
  v39 = v159;
  if (v37 + v35 >= v33)
  {
    v86 = v156;
    v89 = &v156[v35];
    v88 = &v156[v35 + v35];
    v87 = (_BYTE *)(v37 + v35);
    goto LABEL_63;
  }
  v40 = v155;
  v41 = -v153 & 0x3F;
  v42 = DWORD2(v159);
  v43 = v161;
  v44 = (uint64_t *)v160;
  v45 = 2 * v35;
  v46 = v156;
  do
  {
    v47 = v46;
    v48 = &v46[3 * v35];
    v49 = &v47[v45];
    v50 = &v47[v35];
    v51 = (_BYTE *)(v34 + 2 * ((unint64_t)(v19 << v20) >> v41));
    v52 = v20 + v51[1];
    *v47 = *v51;
    v53 = (_BYTE *)(v34 + 2 * ((unint64_t)(v24 << v25) >> v41));
    v54 = v25 + v53[1];
    *v50 = *v53;
    v55 = (char *)(v34 + 2 * ((unint64_t)(v28 << v29) >> v41));
    v56 = *v55;
    LODWORD(v55) = v29 + v55[1];
    *v49 = v56;
    v57 = (_BYTE *)(v34 + 2 * ((unint64_t)(v39 << v42) >> v41));
    v58 = v42 + v57[1];
    *v48 = *v57;
    v59 = (_BYTE *)(v34 + 2 * ((unint64_t)(v19 << v52) >> v41));
    v60 = v52 + v59[1];
    v47[1] = *v59;
    v61 = (_BYTE *)(v34 + 2 * ((unint64_t)(v24 << v54) >> v41));
    v62 = v54 + v61[1];
    v50[1] = *v61;
    v63 = (_BYTE *)(v34 + 2 * ((unint64_t)(v28 << (char)v55) >> v41));
    LODWORD(v55) = (_DWORD)v55 + v63[1];
    v49[1] = *v63;
    v64 = (_BYTE *)(v34 + 2 * ((unint64_t)(v39 << v58) >> v41));
    v65 = v58 + v64[1];
    v48[1] = *v64;
    v66 = (_BYTE *)(v34 + 2 * ((unint64_t)(v19 << v60) >> v41));
    v67 = v60 + v66[1];
    v47[2] = *v66;
    v68 = (_BYTE *)(v34 + 2 * ((unint64_t)(v24 << v62) >> v41));
    v69 = v62 + v68[1];
    v50[2] = *v68;
    v70 = (_BYTE *)(v34 + 2 * ((unint64_t)(v28 << (char)v55) >> v41));
    v71 = (_DWORD)v55 + v70[1];
    v49[2] = *v70;
    v72 = (_BYTE *)(v34 + 2 * ((unint64_t)(v39 << v65) >> v41));
    v73 = v65 + v72[1];
    v48[2] = *v72;
    v74 = (_BYTE *)(v34 + 2 * ((unint64_t)(v19 << v67) >> v41));
    v20 = v67 + v74[1];
    v47[3] = *v74;
    v75 = (_BYTE *)(v34 + 2 * ((unint64_t)(v24 << v69) >> v41));
    v76 = v75[1];
    v50[3] = *v75;
    v77 = (_BYTE *)(v34 + 2 * ((unint64_t)(v28 << v71) >> v41));
    v78 = v77[1];
    v49[3] = *v77;
    v79 = (_BYTE *)(v34 + 2 * ((unint64_t)(v39 << v73) >> v41));
    v80 = v79[1];
    v48[3] = *v79;
    if (v40 < 14)
    {
      v81 = 3;
      v25 = v69 + v76;
      if (v23 >= 8)
      {
LABEL_52:
        v83 = 0;
        v23 -= v25 >> 3;
        v25 &= 7u;
        v24 = *(_QWORD *)&v157[v23];
        v29 = v71 + v78;
        if (v27 >= 8)
          goto LABEL_53;
        goto LABEL_59;
      }
    }
    else
    {
      v81 = 0;
      v82 = v40 - (v20 >> 3);
      v20 &= 7u;
      v40 = v82;
      v19 = *(_QWORD *)((char *)a3 + v82);
      v25 = v69 + v76;
      if (v23 >= 8)
        goto LABEL_52;
    }
    v83 = 3;
    v29 = v71 + v78;
    if (v27 >= 8)
    {
LABEL_53:
      v84 = 0;
      v27 -= v29 >> 3;
      v29 &= 7u;
      v28 = *(_QWORD *)&v158[v27];
      v42 = v73 + v80;
      if ((unint64_t)v44 >= v43)
        goto LABEL_54;
      goto LABEL_60;
    }
LABEL_59:
    v84 = 3;
    v42 = v73 + v80;
    if ((unint64_t)v44 >= v43)
    {
LABEL_54:
      v85 = 0;
      v44 = (uint64_t *)((char *)v44 - (v42 >> 3));
      v42 &= 7u;
      v39 = *v44;
      if ((unint64_t)(v48 + 4) >= v33)
        break;
      goto LABEL_55;
    }
LABEL_60:
    v85 = 3;
    if ((unint64_t)(v48 + 4) >= v33)
      break;
LABEL_55:
    v46 = v47 + 4;
  }
  while (!(v83 | v81 | v84 | v85));
  v86 = v47 + 4;
  DWORD2(v159) = v42;
  *(_QWORD *)&v160 = v44;
  v87 = &v47[3 * v35 + 4];
  v88 = &v47[v45 + 4];
  v89 = &v47[v35 + 4];
  v30 = v156;
  v31 = v40;
  v38 = v37 + v35;
  v32 = (unint64_t)&v156[v154];
  v36 = (unint64_t)&v156[v35];
LABEL_63:
  *(_QWORD *)&v159 = v39;
  result = -20;
  if ((unint64_t)v86 > v36 || (unint64_t)v89 > v37 || (unint64_t)v88 > v38)
    return result;
  if (v20 > 0x40)
  {
    v90 = v86;
    v91 = v153;
    v92 = v158;
    goto LABEL_81;
  }
  v91 = v153;
  v93 = -v153 & 0x3F;
  v92 = v158;
  while (2)
  {
    if (v31 >= 14)
    {
      v96 = 0;
      v95 = v20 >> 3;
      v20 &= 7u;
LABEL_75:
      v31 -= v95;
      v19 = *(_QWORD *)((char *)a3 + v31);
      if ((unint64_t)v86 >= v36 - 3 || v96)
      {
        v90 = v86;
        goto LABEL_81;
      }
      v97 = (char *)(v34 + 2 * ((unint64_t)(v19 << v20) >> v93));
      v98 = *v97;
      LODWORD(v97) = v20 + v97[1];
      *v86 = v98;
      v99 = (_BYTE *)(v34 + 2 * ((unint64_t)(v19 << (char)v97) >> v93));
      LODWORD(v97) = (_DWORD)v97 + v99[1];
      v86[1] = *v99;
      v100 = (_BYTE *)(v34 + 2 * ((unint64_t)(v19 << (char)v97) >> v93));
      LODWORD(v97) = (_DWORD)v97 + v100[1];
      v86[2] = *v100;
      v101 = (char *)(v34 + 2 * ((unint64_t)(v19 << (char)v97) >> v93));
      v102 = *v101;
      v20 = (_DWORD)v97 + v101[1];
      v90 = v86 + 4;
      v86[3] = v102;
      v86 += 4;
      if (v20 >= 0x41)
        goto LABEL_81;
      continue;
    }
    break;
  }
  if (v31 != 6)
  {
    v94 = v20 >> 3;
    v95 = v31 - 6;
    v96 = v31 - v94 < 6;
    if (v31 - v94 >= 6)
      v95 = v20 >> 3;
    v20 -= 8 * v95;
    goto LABEL_75;
  }
  v90 = v86;
LABEL_81:
  if ((unint64_t)v90 < v36)
  {
    v103 = &v30[v35] - v90;
    do
    {
      v104 = (_BYTE *)(v34 + 2 * ((unint64_t)(v19 << v20) >> (-(char)v91 & 0x3F)));
      v20 += v104[1];
      *v90++ = *v104;
      --v103;
    }
    while (v103);
  }
  v105 = &v157[v23];
  if (v25 <= 0x40)
  {
    v107 = -v91 & 0x3F;
    while (1)
    {
      if (v23 >= 8)
      {
        v109 = 0;
        v110 = v25 >> 3;
        v25 &= 7u;
      }
      else
      {
        if (!v23)
          goto LABEL_85;
        v108 = (unint64_t)&v105[-(v25 >> 3)];
        v109 = v108 < (unint64_t)v157;
        v110 = v108 >= (unint64_t)v157 ? v25 >> 3 : v23;
        v25 -= 8 * v110;
      }
      v23 -= v110;
      v105 = &v157[v23];
      v24 = *(_QWORD *)&v157[v23];
      if ((unint64_t)v89 >= v37 - 3 || v109)
        break;
      v111 = (char *)(v34 + 2 * ((unint64_t)(v24 << v25) >> v107));
      v112 = *v111;
      LODWORD(v111) = v25 + v111[1];
      *v89 = v112;
      v113 = (_BYTE *)(v34 + 2 * ((unint64_t)(v24 << (char)v111) >> v107));
      LODWORD(v111) = (_DWORD)v111 + v113[1];
      v89[1] = *v113;
      v114 = (_BYTE *)(v34 + 2 * ((unint64_t)(v24 << (char)v111) >> v107));
      LODWORD(v111) = (_DWORD)v111 + v114[1];
      v89[2] = *v114;
      v115 = (char *)(v34 + 2 * ((unint64_t)(v24 << (char)v111) >> v107));
      v116 = *v115;
      v25 = (_DWORD)v111 + v115[1];
      v106 = v89 + 4;
      v89[3] = v116;
      v89 += 4;
      if (v25 >= 0x41)
        goto LABEL_99;
    }
    v106 = v89;
  }
  else
  {
LABEL_85:
    v106 = v89;
  }
LABEL_99:
  while ((unint64_t)v106 < v37)
  {
    v117 = (_BYTE *)(v34 + 2 * ((unint64_t)(v24 << v25) >> (-(char)v91 & 0x3F)));
    v25 += v117[1];
    *v106++ = *v117;
  }
  v118 = &v92[v27];
  if (v29 <= 0x40)
  {
    v120 = -v91 & 0x3F;
    while (1)
    {
      if (v27 >= 8)
      {
        v122 = 0;
        v123 = v29 >> 3;
        v29 &= 7u;
      }
      else
      {
        if (!v27)
          goto LABEL_102;
        v121 = (unint64_t)&v118[-(v29 >> 3)];
        v122 = v121 < (unint64_t)v92;
        v123 = v121 >= (unint64_t)v92 ? v29 >> 3 : v27;
        v29 -= 8 * v123;
      }
      v27 -= v123;
      v118 = &v92[v27];
      v28 = *(_QWORD *)&v92[v27];
      if ((unint64_t)v88 >= v38 - 3 || v122)
        break;
      v124 = (char *)(v34 + 2 * ((unint64_t)(v28 << v29) >> v120));
      v125 = *v124;
      LODWORD(v124) = v29 + v124[1];
      *v88 = v125;
      v126 = (_BYTE *)(v34 + 2 * ((unint64_t)(v28 << (char)v124) >> v120));
      LODWORD(v124) = (_DWORD)v124 + v126[1];
      v88[1] = *v126;
      v127 = (_BYTE *)(v34 + 2 * ((unint64_t)(v28 << (char)v124) >> v120));
      LODWORD(v124) = (_DWORD)v124 + v127[1];
      v88[2] = *v127;
      v128 = (char *)(v34 + 2 * ((unint64_t)(v28 << (char)v124) >> v120));
      v129 = *v128;
      v29 = (_DWORD)v124 + v128[1];
      v119 = v88 + 4;
      v88[3] = v129;
      v88 += 4;
      if (v29 >= 0x41)
        goto LABEL_116;
    }
    v119 = v88;
  }
  else
  {
LABEL_102:
    v119 = v88;
  }
LABEL_116:
  while ((unint64_t)v119 < v38)
  {
    v130 = (_BYTE *)(v34 + 2 * ((unint64_t)(v28 << v29) >> (-(char)v91 & 0x3F)));
    v29 += v130[1];
    *v119++ = *v130;
  }
  v131 = DWORD2(v159);
  if (DWORD2(v159) <= 0x40)
  {
    v143 = -v91 & 0x3F;
    while (1)
    {
      if ((unint64_t)v160 >= v161)
      {
        v145 = 0;
        v146 = (uint64_t *)(v160 - (v131 >> 3));
        *(_QWORD *)&v160 = v146;
        v131 &= 7u;
      }
      else
      {
        if ((_QWORD)v160 == *((_QWORD *)&v160 + 1))
          break;
        v144 = v131 >> 3;
        v145 = (unint64_t)(v160 - v144) < *((_QWORD *)&v160 + 1);
        v144 = (unint64_t)(v160 - v144) >= *((_QWORD *)&v160 + 1)
             ? v144
             : (v160 - DWORD2(v160));
        v146 = (uint64_t *)(v160 - v144);
        *(_QWORD *)&v160 = v160 - v144;
        v131 -= 8 * v144;
      }
      DWORD2(v159) = v131;
      v147 = *v146;
      *(_QWORD *)&v159 = v147;
      if ((unint64_t)v87 >= v33 || v145)
        break;
      v148 = (unsigned __int8 *)(v34 + 2 * ((unint64_t)(v147 << v131) >> v143));
      v149 = *v148;
      LODWORD(v148) = v131 + v148[1];
      *v87 = v149;
      v150 = (_BYTE *)(v34 + 2 * ((unint64_t)(v147 << (char)v148) >> v143));
      LOBYTE(v149) = *v150;
      LODWORD(v148) = (_DWORD)v148 + v150[1];
      DWORD2(v159) = (_DWORD)v148;
      v87[1] = v149;
      v151 = (_BYTE *)(v34 + 2 * ((unint64_t)(v147 << SBYTE8(v159)) >> v143));
      LOBYTE(v149) = *v151;
      LODWORD(v148) = (_DWORD)v148 + v151[1];
      DWORD2(v159) = (_DWORD)v148;
      v87[2] = v149;
      v152 = (_BYTE *)(v34 + 2 * ((unint64_t)(v147 << SBYTE8(v159)) >> v143));
      LOBYTE(v149) = *v152;
      DWORD2(v159) = (_DWORD)v148 + v152[1];
      v132 = v87 + 4;
      v87[3] = v149;
      v131 = DWORD2(v159);
      v87 += 4;
      if (DWORD2(v159) >= 0x41)
        goto LABEL_120;
    }
  }
  v132 = v87;
LABEL_120:
  if ((unint64_t)v132 < v32)
  {
    v133 = &v30[v154] - v132;
    do
    {
      v134 = (char *)(v34 + 2 * ((_QWORD)v159 << SBYTE8(v159) >> (-(char)v91 & 0x3F)));
      v135 = *v134;
      DWORD2(v159) += v134[1];
      *v132++ = v135;
      --v133;
    }
    while (v133);
    v131 = DWORD2(v159);
  }
  if (v131 == 64
    && (_QWORD)v160 == *((_QWORD *)&v160 + 1)
    && v29 == 64
    && v118 == v92
    && v25 == 64
    && v105 == v157
    && v20 == 64
    && v31 == 6)
  {
    return v154;
  }
  else
  {
    return -20;
  }
}

unint64_t HUF_decompress4X1_DCtx_wksp(int *a1, _BYTE *a2, uint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t result;

  result = HUF_readDTableX1_wksp_bmi2(a1, a4, a5, a6, a7);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
      return -72;
    else
      return HUF_decompress4X1_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (uint64_t)a1);
  }
  return result;
}

unint64_t HUF_readDTableX2_wksp(int *a1, char *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  int v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t result;
  int v11;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  int v15;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  unsigned int v28;
  int v29;
  int v30;
  unsigned int v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  unsigned __int8 *v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  int32x4_t v53;
  int32x4_t *v54;
  unint64_t v55;
  uint64_t v56;
  unsigned int *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  __int128 v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  int32x4_t v66;
  int32x4_t *v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int *v70;
  uint64_t v71;
  int *v72;
  uint64_t v73;
  uint64_t v74;
  unsigned __int8 *v75;
  int v76;
  uint64_t v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v85;
  int32x4_t v86;
  unsigned int v87;
  int32x4_t *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int32x4_t v93;
  unint64_t v94;
  uint64_t v95;
  uint32x4_t v96;
  uint32x4_t v97;
  uint64_t v98;
  _DWORD *v99;
  uint64_t v100;
  unint64_t v101;
  int *v102;
  int v103;
  int *v105;
  int *v106;
  int v107;
  uint64_t v108;
  _OWORD v109[3];
  int v110;
  _OWORD v111[3];
  int v112;
  uint64_t v113;

  v113 = *MEMORY[0x1E0C80C00];
  if (a5 >= 0x5DC)
  {
    v7 = a1 + 1;
    v6 = *a1;
    v8 = a4 + 624;
    *(_OWORD *)(a4 + 716) = 0u;
    v9 = v6;
    *(_OWORD *)(a4 + 688) = 0u;
    *(_OWORD *)(a4 + 704) = 0u;
    *(_OWORD *)(a4 + 656) = 0u;
    *(_OWORD *)(a4 + 672) = 0u;
    *(_OWORD *)(a4 + 624) = 0u;
    *(_OWORD *)(a4 + 640) = 0u;
    if (v6 <= 0xCu)
    {
      v103 = v6;
      v108 = 0;
      result = HUF_readStats_wksp((unsigned __int8 *)(a4 + 1244), 0x100uLL, v8, &v108, (_DWORD *)&v108 + 1, a2, a3, (unsigned __int16 *)v109, 0x164uLL);
      if (result > 0xFFFFFFFFFFFFFF88)
        return result;
      v11 = v9 - HIDWORD(v108);
      if (v9 >= HIDWORD(v108))
      {
        v12 = 0;
        v13 = a4 + 732;
        v14 = (_DWORD *)(a4 + 680);
        v15 = HIDWORD(v108) + 1;
        while (!*(_DWORD *)(v8 + 4 * (HIDWORD(v108) + v12--)))
          ;
        v17 = 0;
        v18 = (HIDWORD(v108) + v12 + 2);
        v19 = HIDWORD(v108) + v12 + 2;
        if ((HIDWORD(v108) + v12) < 0xFFFFFFFE)
        {
          v20 = 0;
          v21 = (_DWORD *)(a4 + 628);
          v22 = v18 - 1;
          do
          {
            v17 = *v21 + v20;
            v21[14] = v20;
            ++v21;
            v20 = v17;
            --v22;
          }
          while (v22);
        }
        *v14 = v17;
        v23 = v108;
        if ((_DWORD)v108)
        {
          v24 = 0;
          do
          {
            v25 = *(unsigned __int8 *)(a4 + 1244 + v24);
            v26 = v14[v25];
            v14[v25] = v26 + 1;
            v27 = (_BYTE *)(v13 + 2 * v26);
            *v27 = v24;
            v27[1] = v25;
            ++v24;
          }
          while (v23 != v24);
        }
        *v14 = 0;
        v101 = result;
        if (v19 < 2)
        {
          v28 = -v12;
LABEL_25:
          v105 = v7;
          v40 = *(_OWORD *)(a4 + 16);
          v111[0] = *(_OWORD *)a4;
          v111[1] = v40;
          v111[2] = *(_OWORD *)(a4 + 32);
          v112 = *(_DWORD *)(a4 + 48);
          if (!v17)
          {
LABEL_66:
            *(_BYTE *)a1 = v103;
            *((_BYTE *)a1 + 1) = 1;
            *((_BYTE *)a1 + 2) = v103;
            *((_BYTE *)a1 + 3) = HIBYTE(v103);
            return v101;
          }
          v41 = 0;
          v107 = v15 - v9;
          v102 = a1 + 5;
          v106 = a1 + 1;
          while (1)
          {
            v43 = (unsigned __int8 *)(v13 + 2 * v41);
            v44 = *v43;
            v45 = v43[1];
            v46 = v15 - v45;
            v47 = *((unsigned int *)v111 + v45);
            v48 = v9 - (v15 - v45);
            v49 = 1 << (v9 - (v15 - v45));
            if (v48 < v28)
            {
              v42 = (v49 + v47);
              if (v47 < v42)
              {
                v50 = v44 & 0xFF00FFFF | ((v15 - v45) << 16) | 0x1000000;
                v51 = v42 - v47;
                v52 = *((unsigned int *)v111 + v45);
                if ((unint64_t)(v42 - v47) < 8)
                  goto LABEL_35;
                v52 = (v51 & 0xFFFFFFFFFFFFFFF8) + v47;
                v53 = vdupq_n_s32(v50);
                v54 = (int32x4_t *)&v102[v47];
                v55 = v51 & 0xFFFFFFFFFFFFFFF8;
                do
                {
                  v54[-1] = v53;
                  *v54 = v53;
                  v54 += 2;
                  v55 -= 8;
                }
                while (v55);
                if (v51 != (v51 & 0xFFFFFFFFFFFFFFF8))
                {
LABEL_35:
                  v56 = v42 - v52;
                  v57 = (unsigned int *)&v106[v52];
                  do
                  {
                    *v57++ = v50;
                    --v56;
                  }
                  while (v56);
                }
              }
              goto LABEL_28;
            }
            v58 = v9;
            LODWORD(v59) = v107 + v46;
            if ((int)(v107 + v46) <= 1)
              v59 = 1;
            else
              v59 = v59;
            v60 = *(unsigned int *)(a4 + 676 + 4 * v59);
            v61 = a4 + 52 * v46;
            v62 = *(_OWORD *)(v61 + 16);
            v109[0] = *(_OWORD *)v61;
            v109[1] = v62;
            v109[2] = *(_OWORD *)(v61 + 32);
            v110 = *(_DWORD *)(v61 + 48);
            if (v59 >= 2)
            {
              v63 = *((unsigned int *)v109 + v59);
              if ((_DWORD)v63)
              {
                v64 = v44 & 0xFF00FFFF | ((v15 - v45) << 16) | 0x1000000;
                if (v63 < 8)
                {
                  v65 = 0;
LABEL_48:
                  v69 = v63 - v65;
                  v70 = (unsigned int *)&v106[v65 + v47];
                  do
                  {
                    *v70++ = v64;
                    --v69;
                  }
                  while (v69);
                  goto LABEL_50;
                }
                v65 = v63 & 0xFFFFFFF8;
                v66 = vdupq_n_s32(v64);
                v67 = (int32x4_t *)&v102[v47];
                v68 = v65;
                do
                {
                  v67[-1] = v66;
                  *v67 = v66;
                  v67 += 2;
                  v68 -= 8;
                }
                while (v68);
                if (v65 != v63)
                  goto LABEL_48;
              }
            }
LABEL_50:
            if (v17 != (_DWORD)v60)
            {
              v71 = 0;
              v72 = &v105[v47];
              v73 = (v17 - v60);
              v74 = v13 + 2 * v60;
              do
              {
                v75 = (unsigned __int8 *)(v74 + 2 * v71);
                v76 = *v75;
                v77 = v75[1];
                v78 = *((_DWORD *)v109 + v77);
                v79 = (1 << (v48 - (v15 - v77))) + v78;
                v80 = (v76 << 8) & 0xFF00FFFF | ((v15 - v77 + v46) << 16) | v44 | 0x2000000;
                if (v79 <= v78 + 1)
                  v81 = v78 + 1;
                else
                  v81 = (1 << (v48 - (v15 - v77))) + v78;
                v82 = v81 - v78;
                v83 = v81 - 1;
                if (v82 >= 0x10 && v83 >= v78)
                {
                  v85 = v78 + (v82 & 0xFFFFFFF8);
                  v86 = vdupq_n_s32(v80);
                  v87 = v82 & 0xFFFFFFF8;
                  do
                  {
                    v88 = (int32x4_t *)&v72[v78];
                    *v88 = v86;
                    v88[1] = v86;
                    v78 += 8;
                    v87 -= 8;
                  }
                  while (v87);
                  if (v82 == (v82 & 0xFFFFFFF8))
                    goto LABEL_52;
                }
                else
                {
                  v85 = *((_DWORD *)v109 + v77);
                }
                do
                  v72[v85++] = v80;
                while (v85 < v79);
LABEL_52:
                *((_DWORD *)v109 + v77) = v79;
                ++v71;
              }
              while (v71 != v73);
            }
            LODWORD(v42) = v49 + v47;
            v9 = v58;
LABEL_28:
            *((_DWORD *)v111 + v45) = v42;
            if (++v41 == v17)
              goto LABEL_66;
          }
        }
        v29 = 0;
        v30 = v9 + v12 + 1;
        v31 = -v12;
        v32 = v18 - 1;
        v33 = v18 - 1;
        v34 = a4;
        do
        {
          *(_DWORD *)(v34 + 4) = v29;
          v34 += 4;
          v29 += *(_DWORD *)(v34 + 624) << v11++;
          --v33;
        }
        while (v33);
        v28 = -v12;
        if (-v12 >= (v9 + v12 + 1))
          goto LABEL_25;
        v35 = a4 + 4;
        if (v32 < 8)
        {
          v36 = v18 - 1;
          v37 = 13 * v31;
          do
          {
            v38 = (_DWORD *)(a4 + 4);
            v39 = v36;
            do
            {
              v38[v37] = *v38 >> v31;
              ++v38;
              --v39;
            }
            while (v39);
            ++v31;
            v37 += 13;
          }
          while (v30 != v31);
          goto LABEL_25;
        }
        v89 = 0;
        v90 = v35 + 52 * v31;
        v91 = 13 * v31;
        while (1)
        {
          if ((unint64_t)(v90 + 52 * v89 - v35) >= 0x20)
          {
            v93 = vdupq_n_s32(v31);
            v94 = (v18 - 1) & 0xFFFFFFFFFFFFFFF8;
            v95 = a4;
            do
            {
              v96 = (uint32x4_t)vnegq_s32(v93);
              v97 = vshlq_u32(*(uint32x4_t *)(v95 + 20), v96);
              v98 = v95 + v91 * 4;
              *(uint32x4_t *)(v98 + 4) = vshlq_u32(*(uint32x4_t *)(v95 + 4), v96);
              *(uint32x4_t *)(v98 + 20) = v97;
              v95 += 32;
              v94 -= 8;
            }
            while (v94);
            v92 = v32 & 0xFFFFFFFFFFFFFFF8 | 1;
            if (v32 == (v32 & 0xFFFFFFFFFFFFFFF8))
              goto LABEL_68;
          }
          else
          {
            v92 = 1;
          }
          v99 = (_DWORD *)(a4 + 4 * v92);
          v100 = v18 - v92;
          do
          {
            v99[v91] = *v99 >> v31;
            ++v99;
            --v100;
          }
          while (v100);
LABEL_68:
          ++v31;
          ++v89;
          v91 += 13;
          if (v30 == v31)
            goto LABEL_25;
        }
      }
    }
  }
  return -44;
}

uint64_t HUF_decompress1X2_usingDTable(char *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5)
{
  if (*(unsigned __int8 *)(a5 + 1) << 8 == 256)
    return HUF_decompress1X2_usingDTable_internal(a1, a2, a3, a4, a5);
  else
    return -1;
}

uint64_t HUF_decompress1X2_usingDTable_internal(char *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  char *v9;
  uint64_t v10;
  int i;
  unsigned __int8 *v12;
  _BOOL4 v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  char *v17;
  uint64_t v18;
  unsigned int v19;
  char *v20;
  uint64_t v21;
  unsigned int v22;
  char *v23;
  uint64_t v24;
  unint64_t j;
  unsigned __int8 *v26;
  _BOOL4 v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  unsigned int v34;
  int v35;

  if (!a4)
    return -72;
  v5 = a4 - 8;
  if (a4 >= 8)
  {
    if (!a3[a4 - 1])
      return -1;
    if (a4 <= 0xFFFFFFFFFFFFFF88)
    {
      v6 = *(_QWORD *)&a3[v5];
      v7 = __clz(a3[a4 - 1]) - 23;
      goto LABEL_17;
    }
    return a4;
  }
  v6 = *a3;
  switch(a4)
  {
    case 2uLL:
      goto LABEL_14;
    case 3uLL:
      goto LABEL_13;
    case 4uLL:
      goto LABEL_12;
    case 5uLL:
      goto LABEL_11;
    case 6uLL:
      goto LABEL_10;
    case 7uLL:
      v6 |= (unint64_t)a3[6] << 48;
LABEL_10:
      v6 += (unint64_t)a3[5] << 40;
LABEL_11:
      v6 += (unint64_t)a3[4] << 32;
LABEL_12:
      v6 += (unint64_t)a3[3] << 24;
LABEL_13:
      v6 += (unint64_t)a3[2] << 16;
LABEL_14:
      v6 += (unint64_t)a3[1] << 8;
      break;
    default:
      break;
  }
  if (!a3[a4 - 1])
    return -20;
  v5 = 0;
  v7 = __clz(a3[a4 - 1]) - 8 * a4 + 41;
LABEL_17:
  v9 = &a1[a2];
  v10 = a5 + 4;
  for (i = -*(unsigned __int16 *)(a5 + 2) & 0x3F; v7 <= 0x40; a1 = &v23[*(unsigned __int8 *)(v24 + 3)])
  {
    if (v5 >= 8)
    {
      v13 = 0;
      v14 = v7 >> 3;
      v7 &= 7u;
    }
    else
    {
      if (!v5)
        break;
      v12 = &a3[v5 - (v7 >> 3)];
      v13 = v12 < a3;
      if (v12 >= a3)
        v14 = v7 >> 3;
      else
        v14 = v5;
      v7 -= 8 * v14;
    }
    v5 -= v14;
    v6 = *(_QWORD *)&a3[v5];
    if (a1 >= v9 - 7)
      break;
    if (v13)
      break;
    v15 = v10 + 4 * ((unint64_t)(v6 << v7) >> i);
    *(_WORD *)a1 = *(_WORD *)v15;
    v16 = v7 + *(unsigned __int8 *)(v15 + 2);
    v17 = &a1[*(unsigned __int8 *)(v15 + 3)];
    v18 = v10 + 4 * ((unint64_t)(v6 << v16) >> i);
    *(_WORD *)v17 = *(_WORD *)v18;
    v19 = v16 + *(unsigned __int8 *)(v18 + 2);
    v20 = &v17[*(unsigned __int8 *)(v18 + 3)];
    v21 = v10 + 4 * ((unint64_t)(v6 << v19) >> i);
    *(_WORD *)v20 = *(_WORD *)v21;
    v22 = v19 + *(unsigned __int8 *)(v21 + 2);
    v23 = &v20[*(unsigned __int8 *)(v21 + 3)];
    v24 = v10 + 4 * ((unint64_t)(v6 << v22) >> i);
    *(_WORD *)v23 = *(_WORD *)v24;
    v7 = v22 + *(unsigned __int8 *)(v24 + 2);
  }
  for (j = (unint64_t)(v9 - 2); v7 <= 0x40; a1 += *(unsigned __int8 *)(v29 + 3))
  {
    if (v5 >= 8)
    {
      v27 = 0;
      v28 = v7 >> 3;
      v7 &= 7u;
    }
    else
    {
      if (!v5)
        break;
      v26 = &a3[v5 - (v7 >> 3)];
      v27 = v26 < a3;
      if (v26 >= a3)
        v28 = v7 >> 3;
      else
        v28 = v5;
      v7 -= 8 * v28;
    }
    v5 -= v28;
    v6 = *(_QWORD *)&a3[v5];
    if ((unint64_t)a1 > j)
      break;
    if (v27)
      break;
    v29 = v10 + 4 * ((unint64_t)(v6 << v7) >> i);
    *(_WORD *)a1 = *(_WORD *)v29;
    v7 += *(unsigned __int8 *)(v29 + 2);
  }
  while ((unint64_t)a1 <= j)
  {
    v30 = v10 + 4 * ((unint64_t)(v6 << v7) >> i);
    *(_WORD *)a1 = *(_WORD *)v30;
    v7 += *(unsigned __int8 *)(v30 + 2);
    a1 += *(unsigned __int8 *)(v30 + 3);
  }
  if (a1 >= v9)
    goto LABEL_49;
  v31 = (unint64_t)(v6 << v7) >> i;
  v32 = (char *)(v10 + 4 * v31);
  *a1 = *v32;
  if (v32[3] == 1)
  {
    v7 += v32[2];
LABEL_49:
    if (v7 == 64 && v5 == 0)
      return a2;
    else
      return -20;
  }
  if (v7 > 0x3F)
    goto LABEL_49;
  v34 = v7 + *(unsigned __int8 *)(v10 + 4 * v31 + 2);
  if (v34 >= 0x40)
    v35 = 64;
  else
    v35 = v34;
  if (v35 == 64 && v5 == 0)
    return a2;
  else
    return -20;
}

unint64_t HUF_decompress1X2_DCtx_wksp(int *a1, char *a2, uint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t result;

  result = HUF_readDTableX2_wksp(a1, a4, a5, a6, a7);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
      return -72;
    else
      return HUF_decompress1X2_usingDTable_internal(a2, a3, (unsigned __int8 *)&a4[result], a5 - result, (uint64_t)a1);
  }
  return result;
}

unint64_t HUF_decompress4X2_usingDTable(char *a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5)
{
  if (*(unsigned __int8 *)(a5 + 1) << 8 == 256)
    return HUF_decompress4X2_usingDTable_internal(a1, a2, a3, a4, a5);
  else
    return -1;
}

unint64_t HUF_decompress4X2_usingDTable_internal(char *a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned __int8 *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned __int8 *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned __int8 *v27;
  uint64_t v28;
  unsigned int v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  unint64_t v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  unint64_t v39;
  uint64_t *v40;
  char *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  char *v47;
  uint64_t v48;
  unsigned int v49;
  char *v50;
  uint64_t v51;
  unsigned int v52;
  char *v53;
  uint64_t v54;
  unsigned int v55;
  char *v56;
  uint64_t v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  char *v62;
  uint64_t v63;
  unsigned int v64;
  char *v65;
  uint64_t v66;
  unsigned int v67;
  char *v68;
  char *v69;
  uint64_t v70;
  unsigned int v71;
  char *v72;
  uint64_t v73;
  unsigned int v74;
  char *v75;
  uint64_t v76;
  unsigned int v77;
  char *v78;
  uint64_t v79;
  unsigned int v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  int v98;
  int v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  char *v103;
  unsigned __int8 *v104;
  unint64_t i;
  uint64_t v106;
  _BOOL4 v107;
  uint64_t v108;
  unsigned int v109;
  char *v110;
  uint64_t v111;
  unsigned int v112;
  char *v113;
  uint64_t v114;
  unsigned int v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  _BOOL4 v119;
  uint64_t v120;
  unsigned int j;
  uint64_t v122;
  unint64_t v123;
  char *v124;
  unsigned int v125;
  uint64_t v126;
  char *v127;
  BOOL v128;
  _BOOL4 v129;
  uint64_t v130;
  unsigned int v131;
  char *v132;
  uint64_t v133;
  unsigned int v134;
  char *v135;
  uint64_t v136;
  unsigned int v137;
  char *v138;
  uint64_t v139;
  unint64_t k;
  uint64_t v141;
  char *v142;
  _BOOL4 v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  char *v147;
  uint64_t v148;
  uint64_t v149;
  unsigned __int8 *v150;
  _BOOL4 v151;
  uint64_t v152;
  unsigned int v153;
  char *v154;
  uint64_t v155;
  unsigned int v156;
  char *v157;
  uint64_t v158;
  unsigned int v159;
  char *v160;
  uint64_t v161;
  unsigned int v162;
  unint64_t m;
  uint64_t v164;
  unsigned __int8 *v165;
  _BOOL4 v166;
  uint64_t v167;
  uint64_t v168;
  unint64_t v169;
  char *v170;
  unsigned int v171;
  unsigned int v172;
  uint64_t n;
  uint64_t v174;
  _BOOL4 v175;
  uint64_t *v176;
  uint64_t v177;
  uint64_t v178;
  unsigned int v179;
  char *v180;
  uint64_t v181;
  unsigned int v182;
  char *v183;
  uint64_t v184;
  unsigned int v185;
  char *v186;
  uint64_t v187;
  unint64_t ii;
  uint64_t v189;
  _BOOL4 v190;
  uint64_t *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  char *v196;
  unsigned int v197;
  char *v205;
  char *v206;
  char *v207;
  char *v208;
  int v209;
  uint64_t v210;
  uint64_t v211;
  char *v212;
  unsigned __int8 *v213;
  unint64_t v214;
  uint64_t v215;
  __int128 v216;
  __int128 v217;
  unint64_t v218;
  uint64_t v219;
  uint64_t v220;

  if (a4 < 0xA)
    return -20;
  v219 = v5;
  v220 = v6;
  v218 = 0;
  v216 = 0u;
  v217 = 0u;
  v9 = *a3;
  v10 = a3[1];
  v11 = a3[2];
  v13 = v9 + 6 + v10 + v11;
  v14 = a4 - v13;
  if (a4 < v13)
    return -20;
  if (!(_DWORD)v9)
    return -72;
  v17 = (unsigned __int8 *)(a3 + 3);
  if (v9 < 8)
  {
    v20 = *v17;
    switch((int)v9)
    {
      case 2:
        goto LABEL_16;
      case 3:
        goto LABEL_15;
      case 4:
        goto LABEL_14;
      case 5:
        goto LABEL_13;
      case 6:
        goto LABEL_12;
      case 7:
        v20 |= (unint64_t)*((unsigned __int8 *)a3 + 12) << 48;
LABEL_12:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 11) << 40;
LABEL_13:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 10) << 32;
LABEL_14:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 9) << 24;
LABEL_15:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 8) << 16;
LABEL_16:
        v20 += (unint64_t)*((unsigned __int8 *)a3 + 7) << 8;
        break;
      default:
        break;
    }
    v22 = v17[v9 - 1];
    if (!v22)
      return -20;
    v21 = __clz(v22) - 8 * v9 + 41;
    v19 = 6;
    if (!(_DWORD)v10)
      return -72;
  }
  else
  {
    v18 = v17[v9 - 1];
    if (!v18)
      return -1;
    v19 = v9 - 2;
    v20 = *(_QWORD *)((char *)a3 + v9 - 2);
    v21 = __clz(v18) - 23;
    if (!(_DWORD)v10)
      return -72;
  }
  v12 = v9 + 6;
  v23 = (unsigned __int8 *)a3 + v9 + 6;
  if (v10 >= 8)
  {
    if (v23[v10 - 1])
    {
      v24 = v10 - 8;
      v25 = *(_QWORD *)&v23[v10 - 8];
      v26 = __clz(v23[v10 - 1]) - 23;
      goto LABEL_31;
    }
    return -1;
  }
  v25 = *v23;
  switch((int)v10)
  {
    case 2:
      goto LABEL_28;
    case 3:
      goto LABEL_27;
    case 4:
      goto LABEL_26;
    case 5:
      goto LABEL_25;
    case 6:
      goto LABEL_24;
    case 7:
      v25 |= (unint64_t)v23[6] << 48;
LABEL_24:
      v25 += (unint64_t)v23[5] << 40;
LABEL_25:
      v25 += (unint64_t)v23[4] << 32;
LABEL_26:
      v25 += (unint64_t)v23[3] << 24;
LABEL_27:
      v25 += (unint64_t)v23[2] << 16;
LABEL_28:
      v25 += (unint64_t)v23[1] << 8;
      break;
    default:
      break;
  }
  if (!v23[v10 - 1])
    return -20;
  v24 = 0;
  v26 = __clz(v23[v10 - 1]) - 8 * v10 + 41;
LABEL_31:
  if (!(_DWORD)v11)
    return -72;
  v27 = &v23[v10];
  if (v11 < 8)
  {
    v28 = *v27;
    switch((int)v11)
    {
      case 2:
        goto LABEL_44;
      case 3:
        goto LABEL_43;
      case 4:
        goto LABEL_42;
      case 5:
        goto LABEL_41;
      case 6:
        goto LABEL_40;
      case 7:
        v28 |= (unint64_t)v27[6] << 48;
LABEL_40:
        v28 += (unint64_t)v27[5] << 40;
LABEL_41:
        v28 += (unint64_t)v27[4] << 32;
LABEL_42:
        v28 += (unint64_t)v27[3] << 24;
LABEL_43:
        v28 += (unint64_t)v27[2] << 16;
LABEL_44:
        v28 += (unint64_t)v27[1] << 8;
        break;
      default:
        break;
    }
    if (v27[v11 - 1])
    {
      v209 = *(unsigned __int16 *)(a5 + 2);
      v211 = a2;
      v212 = (char *)a3 + v12;
      v215 = v24;
      v210 = 0;
      v29 = __clz(v27[v11 - 1]) - 8 * v11 + 41;
      goto LABEL_47;
    }
    return -20;
  }
  if (!v27[v11 - 1])
    return -1;
  v209 = *(unsigned __int16 *)(a5 + 2);
  v211 = a2;
  v212 = (char *)a3 + v12;
  v215 = v24;
  v210 = v11 - 8;
  v28 = *(_QWORD *)&v27[v11 - 8];
  v29 = __clz(v27[v11 - 1]) - 23;
LABEL_47:
  v213 = &v23[v10];
  result = BIT_initDStream((uint64_t)&v216, &v27[v11], v14);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    v30 = &a1[v211];
    v31 = a5 + 4;
    v32 = (unint64_t)(v211 + 3) >> 2;
    v33 = &a1[v32];
    v34 = &a1[v32 + v32];
    v35 = (unint64_t)&v34[v32];
    v36 = v216;
    v214 = (unint64_t)&a1[v211 - 7];
    if ((unint64_t)&v34[v32] < v214)
    {
      v207 = &v34[v32];
      v208 = &a1[v211];
      v37 = -v209 & 0x3F;
      v38 = DWORD2(v216);
      v39 = v218;
      v40 = (uint64_t *)v217;
      v41 = &v34[v32];
      v205 = &a1[v32];
      v206 = &a1[v32 + v32];
      v42 = v206;
      v43 = &a1[v32];
      v44 = v210;
      while (1)
      {
        v45 = v31 + 4 * ((unint64_t)(v20 << v21) >> v37);
        *(_WORD *)a1 = *(_WORD *)v45;
        v46 = v21 + *(unsigned __int8 *)(v45 + 2);
        v47 = &a1[*(unsigned __int8 *)(v45 + 3)];
        v48 = v31 + 4 * ((unint64_t)(v25 << v26) >> v37);
        *(_WORD *)v43 = *(_WORD *)v48;
        v49 = v26 + *(unsigned __int8 *)(v48 + 2);
        v50 = &v43[*(unsigned __int8 *)(v48 + 3)];
        v51 = v31 + 4 * ((unint64_t)(v28 << v29) >> v37);
        *(_WORD *)v42 = *(_WORD *)v51;
        v52 = v29 + *(unsigned __int8 *)(v51 + 2);
        v53 = &v42[*(unsigned __int8 *)(v51 + 3)];
        v54 = v31 + 4 * ((unint64_t)(v36 << v38) >> v37);
        *(_WORD *)v41 = *(_WORD *)v54;
        v55 = v38 + *(unsigned __int8 *)(v54 + 2);
        v56 = &v41[*(unsigned __int8 *)(v54 + 3)];
        v57 = v31 + 4 * ((unint64_t)(v20 << v46) >> v37);
        *(_WORD *)v47 = *(_WORD *)v57;
        v58 = v46 + *(unsigned __int8 *)(v57 + 2);
        v59 = *(unsigned __int8 *)(v57 + 3);
        v60 = v31 + 4 * ((unint64_t)(v25 << v49) >> v37);
        *(_WORD *)v50 = *(_WORD *)v60;
        v61 = v49 + *(unsigned __int8 *)(v60 + 2);
        v62 = &v50[*(unsigned __int8 *)(v60 + 3)];
        v63 = v31 + 4 * ((unint64_t)(v28 << v52) >> v37);
        *(_WORD *)v53 = *(_WORD *)v63;
        v64 = v52 + *(unsigned __int8 *)(v63 + 2);
        v65 = &v53[*(unsigned __int8 *)(v63 + 3)];
        v66 = v31 + 4 * ((unint64_t)(v36 << v55) >> v37);
        *(_WORD *)v56 = *(_WORD *)v66;
        v67 = v55 + *(unsigned __int8 *)(v66 + 2);
        v68 = &v56[*(unsigned __int8 *)(v66 + 3)];
        v69 = &v47[v59];
        v70 = v31 + 4 * ((unint64_t)(v20 << v58) >> v37);
        *(_WORD *)v69 = *(_WORD *)v70;
        v71 = v58 + *(unsigned __int8 *)(v70 + 2);
        v72 = &v69[*(unsigned __int8 *)(v70 + 3)];
        v73 = v31 + 4 * ((unint64_t)(v25 << v61) >> v37);
        *(_WORD *)v62 = *(_WORD *)v73;
        v74 = v61 + *(unsigned __int8 *)(v73 + 2);
        v75 = &v62[*(unsigned __int8 *)(v73 + 3)];
        v76 = v31 + 4 * ((unint64_t)(v28 << v64) >> v37);
        *(_WORD *)v65 = *(_WORD *)v76;
        v77 = v64 + *(unsigned __int8 *)(v76 + 2);
        v78 = &v65[*(unsigned __int8 *)(v76 + 3)];
        v79 = v31 + 4 * ((unint64_t)(v36 << v67) >> v37);
        *(_WORD *)v68 = *(_WORD *)v79;
        v80 = v67 + *(unsigned __int8 *)(v79 + 2);
        v81 = &v68[*(unsigned __int8 *)(v79 + 3)];
        v82 = v31 + 4 * ((unint64_t)(v20 << v71) >> v37);
        *(_WORD *)v72 = *(_WORD *)v82;
        v21 = v71 + *(unsigned __int8 *)(v82 + 2);
        v83 = *(unsigned __int8 *)(v82 + 3);
        v84 = v31 + 4 * ((unint64_t)(v25 << v74) >> v37);
        *(_WORD *)v75 = *(_WORD *)v84;
        v85 = *(unsigned __int8 *)(v84 + 2);
        v86 = *(unsigned __int8 *)(v84 + 3);
        v87 = v31 + 4 * ((unint64_t)(v28 << v77) >> v37);
        *(_WORD *)v78 = *(_WORD *)v87;
        v88 = *(unsigned __int8 *)(v87 + 2);
        v89 = *(unsigned __int8 *)(v87 + 3);
        v90 = v31 + 4 * ((unint64_t)(v36 << v80) >> v37);
        *(_WORD *)v81 = *(_WORD *)v90;
        v91 = v44;
        if (v19 < 14)
        {
          v92 = 3;
          v26 = v74 + v85;
          v93 = *(unsigned __int8 *)(v90 + 2);
          v94 = *(unsigned __int8 *)(v90 + 3);
          v95 = v215;
          if (v215 >= 8)
          {
LABEL_52:
            v96 = 0;
            v97 = v95 - (v26 >> 3);
            v26 &= 7u;
            v215 = v97;
            v25 = *(_QWORD *)&v212[v97];
            v29 = v77 + v88;
            v44 = v91;
            if (v91 >= 8)
              goto LABEL_53;
            goto LABEL_60;
          }
        }
        else
        {
          v92 = 0;
          v19 -= v21 >> 3;
          v21 &= 7u;
          v20 = *(_QWORD *)((char *)a3 + v19);
          v26 = v74 + v85;
          v93 = *(unsigned __int8 *)(v90 + 2);
          v94 = *(unsigned __int8 *)(v90 + 3);
          v95 = v215;
          if (v215 >= 8)
            goto LABEL_52;
        }
        v96 = 3;
        v29 = v77 + v88;
        v44 = v91;
        if (v91 >= 8)
        {
LABEL_53:
          v98 = 0;
          v44 -= v29 >> 3;
          v29 &= 7u;
          v28 = *(_QWORD *)&v213[v44];
          v38 = v80 + v93;
          if ((unint64_t)v40 >= v39)
            goto LABEL_54;
          goto LABEL_61;
        }
LABEL_60:
        v98 = 3;
        v38 = v80 + v93;
        if ((unint64_t)v40 >= v39)
        {
LABEL_54:
          v99 = 0;
          v40 = (uint64_t *)((char *)v40 - (v38 >> 3));
          v38 &= 7u;
          v36 = *v40;
          goto LABEL_55;
        }
LABEL_61:
        v99 = 3;
LABEL_55:
        a1 = &v72[v83];
        v43 = &v75[v86];
        v42 = &v78[v89];
        v41 = &v81[v94];
        if (v96 | v92 | v98 | v99 || (unint64_t)v41 >= v214)
        {
          DWORD2(v216) = v38;
          *(_QWORD *)&v217 = v40;
          v35 = (unint64_t)v207;
          v30 = v208;
          v33 = v205;
          v34 = v206;
          goto LABEL_64;
        }
      }
    }
    v43 = &a1[v32];
    v42 = &a1[v32 + v32];
    v41 = &v34[v32];
    v44 = v210;
LABEL_64:
    *(_QWORD *)&v216 = v36;
    result = -20;
    if (a1 <= v33 && v43 <= v34 && (unint64_t)v42 <= v35)
    {
      v100 = v44;
      v101 = -v209 & 0x3F;
      if (v21 <= 0x40)
      {
        v102 = v215;
        v103 = v212;
        v104 = v213;
        do
        {
          if (v19 >= 14)
          {
            v107 = 0;
            LODWORD(v106) = v21 >> 3;
            v21 &= 7u;
          }
          else
          {
            if (v19 == 6)
              break;
            v106 = v21 >> 3;
            v107 = v19 - v106 < 6;
            if (v19 - v106 < 6)
              LODWORD(v106) = v19 - 6;
            v21 -= 8 * v106;
          }
          v19 -= v106;
          v20 = *(_QWORD *)((char *)a3 + v19);
          if (a1 >= v33 - 7)
            break;
          if (v107)
            break;
          v108 = v31 + 4 * ((unint64_t)(v20 << v21) >> v101);
          *(_WORD *)a1 = *(_WORD *)v108;
          v109 = v21 + *(unsigned __int8 *)(v108 + 2);
          v110 = &a1[*(unsigned __int8 *)(v108 + 3)];
          v111 = v31 + 4 * ((unint64_t)(v20 << v109) >> v101);
          *(_WORD *)v110 = *(_WORD *)v111;
          v112 = v109 + *(unsigned __int8 *)(v111 + 2);
          v113 = &v110[*(unsigned __int8 *)(v111 + 3)];
          v114 = v31 + 4 * ((unint64_t)(v20 << v112) >> v101);
          *(_WORD *)v113 = *(_WORD *)v114;
          v115 = v112 + *(unsigned __int8 *)(v114 + 2);
          v116 = &v113[*(unsigned __int8 *)(v114 + 3)];
          v117 = v31 + 4 * ((unint64_t)(v20 << v115) >> v101);
          *(_WORD *)v116 = *(_WORD *)v117;
          v21 = v115 + *(unsigned __int8 *)(v117 + 2);
          a1 = &v116[*(unsigned __int8 *)(v117 + 3)];
        }
        while (v21 <= 0x40);
        for (i = (unint64_t)(v33 - 2); v21 <= 0x40; a1 += *(unsigned __int8 *)(v120 + 3))
        {
          if (v19 >= 14)
          {
            v119 = 0;
            LODWORD(v118) = v21 >> 3;
            v21 &= 7u;
          }
          else
          {
            if (v19 == 6)
              break;
            v118 = v21 >> 3;
            v119 = v19 - v118 < 6;
            if (v19 - v118 < 6)
              LODWORD(v118) = v19 - 6;
            v21 -= 8 * v118;
          }
          v19 -= v118;
          v20 = *(_QWORD *)((char *)a3 + v19);
          if ((unint64_t)a1 > i)
            break;
          if (v119)
            break;
          v120 = v31 + 4 * ((unint64_t)(v20 << v21) >> v101);
          *(_WORD *)a1 = *(_WORD *)v120;
          v21 += *(unsigned __int8 *)(v120 + 2);
        }
      }
      else
      {
        v102 = v215;
        v103 = v212;
        v104 = v213;
        i = (unint64_t)(v33 - 2);
      }
      for (j = v21; (unint64_t)a1 <= i; a1 += *(unsigned __int8 *)(v122 + 3))
      {
        v122 = v31 + 4 * ((unint64_t)(v20 << j) >> v101);
        *(_WORD *)a1 = *(_WORD *)v122;
        j += *(unsigned __int8 *)(v122 + 2);
      }
      if (a1 < v33)
      {
        v123 = (unint64_t)(v20 << j) >> v101;
        v124 = (char *)(v31 + 4 * v123);
        *a1 = *v124;
        if (v124[3] == 1)
        {
          j += v124[2];
        }
        else if (j <= 0x3F)
        {
          v125 = j + *(unsigned __int8 *)(v31 + 4 * v123 + 2);
          if (v125 >= 0x40)
            j = 64;
          else
            j = v125;
        }
      }
      for (; v26 <= 0x40; v43 = &v138[*(unsigned __int8 *)(v139 + 3)])
      {
        if (v102 >= 8)
        {
          v129 = 0;
          LODWORD(v126) = v26 >> 3;
          v26 &= 7u;
        }
        else
        {
          if (!v102)
            break;
          v126 = v26 >> 3;
          v127 = &v103[v102 - v126];
          v128 = v127 >= v103;
          v129 = v127 < v103;
          if (!v128)
            LODWORD(v126) = v102;
          v26 -= 8 * v126;
        }
        v102 -= v126;
        v25 = *(_QWORD *)&v103[v102];
        if (v43 >= v34 - 7)
          break;
        if (v129)
          break;
        v130 = v31 + 4 * ((unint64_t)(v25 << v26) >> v101);
        *(_WORD *)v43 = *(_WORD *)v130;
        v131 = v26 + *(unsigned __int8 *)(v130 + 2);
        v132 = &v43[*(unsigned __int8 *)(v130 + 3)];
        v133 = v31 + 4 * ((unint64_t)(v25 << v131) >> v101);
        *(_WORD *)v132 = *(_WORD *)v133;
        v134 = v131 + *(unsigned __int8 *)(v133 + 2);
        v135 = &v132[*(unsigned __int8 *)(v133 + 3)];
        v136 = v31 + 4 * ((unint64_t)(v25 << v134) >> v101);
        *(_WORD *)v135 = *(_WORD *)v136;
        v137 = v134 + *(unsigned __int8 *)(v136 + 2);
        v138 = &v135[*(unsigned __int8 *)(v136 + 3)];
        v139 = v31 + 4 * ((unint64_t)(v25 << v137) >> v101);
        *(_WORD *)v138 = *(_WORD *)v139;
        v26 = v137 + *(unsigned __int8 *)(v139 + 2);
      }
      for (k = (unint64_t)(v34 - 2); v26 <= 0x40; v43 += *(unsigned __int8 *)(v144 + 3))
      {
        if (v102 >= 8)
        {
          v143 = 0;
          LODWORD(v141) = v26 >> 3;
          v26 &= 7u;
        }
        else
        {
          if (!v102)
            break;
          v141 = v26 >> 3;
          v142 = &v103[v102 - v141];
          v128 = v142 >= v103;
          v143 = v142 < v103;
          if (!v128)
            LODWORD(v141) = v102;
          v26 -= 8 * v141;
        }
        v102 -= v141;
        v25 = *(_QWORD *)&v103[v102];
        if ((unint64_t)v43 > k)
          break;
        if (v143)
          break;
        v144 = v31 + 4 * ((unint64_t)(v25 << v26) >> v101);
        *(_WORD *)v43 = *(_WORD *)v144;
        v26 += *(unsigned __int8 *)(v144 + 2);
      }
      while ((unint64_t)v43 <= k)
      {
        v145 = v31 + 4 * ((unint64_t)(v25 << v26) >> v101);
        *(_WORD *)v43 = *(_WORD *)v145;
        v26 += *(unsigned __int8 *)(v145 + 2);
        v43 += *(unsigned __int8 *)(v145 + 3);
      }
      if (v43 < v34)
      {
        v146 = (unint64_t)(v25 << v26) >> v101;
        v147 = (char *)(v31 + 4 * v146);
        *v43 = *v147;
        if (v147[3] != 1)
        {
          v148 = v211;
          if (v26 <= 0x3F)
          {
            v162 = v26 + *(unsigned __int8 *)(v31 + 4 * v146 + 2);
            if (v162 >= 0x40)
              v26 = 64;
            else
              v26 = v162;
          }
          goto LABEL_124;
        }
        v26 += v147[2];
      }
      v148 = v211;
LABEL_124:
      while (v29 <= 0x40)
      {
        if (v100 >= 8)
        {
          v151 = 0;
          LODWORD(v149) = v29 >> 3;
          v29 &= 7u;
        }
        else
        {
          if (!v100)
            break;
          v149 = v29 >> 3;
          v150 = &v104[v100 - v149];
          v128 = v150 >= v104;
          v151 = v150 < v104;
          if (!v128)
            LODWORD(v149) = v100;
          v29 -= 8 * v149;
        }
        v100 -= v149;
        v28 = *(_QWORD *)&v104[v100];
        if ((unint64_t)v42 >= v35 - 7)
          break;
        if (v151)
          break;
        v152 = v31 + 4 * ((unint64_t)(v28 << v29) >> v101);
        *(_WORD *)v42 = *(_WORD *)v152;
        v153 = v29 + *(unsigned __int8 *)(v152 + 2);
        v154 = &v42[*(unsigned __int8 *)(v152 + 3)];
        v155 = v31 + 4 * ((unint64_t)(v28 << v153) >> v101);
        *(_WORD *)v154 = *(_WORD *)v155;
        v156 = v153 + *(unsigned __int8 *)(v155 + 2);
        v157 = &v154[*(unsigned __int8 *)(v155 + 3)];
        v158 = v31 + 4 * ((unint64_t)(v28 << v156) >> v101);
        *(_WORD *)v157 = *(_WORD *)v158;
        v159 = v156 + *(unsigned __int8 *)(v158 + 2);
        v160 = &v157[*(unsigned __int8 *)(v158 + 3)];
        v161 = v31 + 4 * ((unint64_t)(v28 << v159) >> v101);
        *(_WORD *)v160 = *(_WORD *)v161;
        v29 = v159 + *(unsigned __int8 *)(v161 + 2);
        v42 = &v160[*(unsigned __int8 *)(v161 + 3)];
      }
      for (m = v35 - 2; v29 <= 0x40; v42 += *(unsigned __int8 *)(v167 + 3))
      {
        if (v100 >= 8)
        {
          v166 = 0;
          LODWORD(v164) = v29 >> 3;
          v29 &= 7u;
        }
        else
        {
          if (!v100)
            break;
          v164 = v29 >> 3;
          v165 = &v104[v100 - v164];
          v128 = v165 >= v104;
          v166 = v165 < v104;
          if (!v128)
            LODWORD(v164) = v100;
          v29 -= 8 * v164;
        }
        v100 -= v164;
        v28 = *(_QWORD *)&v104[v100];
        if ((unint64_t)v42 > m)
          break;
        if (v166)
          break;
        v167 = v31 + 4 * ((unint64_t)(v28 << v29) >> v101);
        *(_WORD *)v42 = *(_WORD *)v167;
        v29 += *(unsigned __int8 *)(v167 + 2);
      }
      while ((unint64_t)v42 <= m)
      {
        v168 = v31 + 4 * ((unint64_t)(v28 << v29) >> v101);
        *(_WORD *)v42 = *(_WORD *)v168;
        v29 += *(unsigned __int8 *)(v168 + 2);
        v42 += *(unsigned __int8 *)(v168 + 3);
      }
      if ((unint64_t)v42 < v35)
      {
        v169 = (unint64_t)(v28 << v29) >> v101;
        v170 = (char *)(v31 + 4 * v169);
        *v42 = *v170;
        if (v170[3] == 1)
        {
          v29 += v170[2];
        }
        else if (v29 <= 0x3F)
        {
          v171 = v29 + *(unsigned __int8 *)(v31 + 4 * v169 + 2);
          if (v171 >= 0x40)
            v29 = 64;
          else
            v29 = v171;
        }
      }
      v172 = DWORD2(v216);
      for (n = v100; v172 <= 0x40; v41 = &v186[*(unsigned __int8 *)(v187 + 3)])
      {
        if ((unint64_t)v217 >= v218)
        {
          v175 = 0;
          v176 = (uint64_t *)(v217 - (v172 >> 3));
          *(_QWORD *)&v217 = v176;
          v172 &= 7u;
        }
        else
        {
          if ((_QWORD)v217 == *((_QWORD *)&v217 + 1))
            break;
          v174 = v172 >> 3;
          v100 = n;
          v175 = (unint64_t)(v217 - v174) < *((_QWORD *)&v217 + 1);
          if ((unint64_t)(v217 - v174) >= *((_QWORD *)&v217 + 1))
            v174 = v174;
          else
            v174 = (v217 - DWORD2(v217));
          v176 = (uint64_t *)(v217 - v174);
          *(_QWORD *)&v217 = v217 - v174;
          v172 -= 8 * v174;
        }
        DWORD2(v216) = v172;
        v177 = *v176;
        *(_QWORD *)&v216 = v177;
        if ((unint64_t)v41 >= v214)
          break;
        if (v175)
          break;
        v178 = v31 + 4 * ((unint64_t)(v177 << v172) >> v101);
        *(_WORD *)v41 = *(_WORD *)v178;
        v179 = v172 + *(unsigned __int8 *)(v178 + 2);
        v180 = &v41[*(unsigned __int8 *)(v178 + 3)];
        v181 = v31 + 4 * ((unint64_t)(v177 << v179) >> v101);
        *(_WORD *)v180 = *(_WORD *)v181;
        v182 = v179 + *(unsigned __int8 *)(v181 + 2);
        v183 = &v180[*(unsigned __int8 *)(v181 + 3)];
        v184 = v31 + 4 * ((unint64_t)(v177 << v182) >> v101);
        *(_WORD *)v183 = *(_WORD *)v184;
        v185 = v182 + *(unsigned __int8 *)(v184 + 2);
        v186 = &v183[*(unsigned __int8 *)(v184 + 3)];
        v187 = v31 + 4 * ((unint64_t)(v177 << v185) >> v101);
        *(_WORD *)v186 = *(_WORD *)v187;
        v172 = v185 + *(unsigned __int8 *)(v187 + 2);
        DWORD2(v216) = v172;
      }
      for (ii = (unint64_t)(v30 - 2); v172 <= 0x40; v41 += *(unsigned __int8 *)(v193 + 3))
      {
        if ((unint64_t)v217 >= v218)
        {
          v190 = 0;
          v191 = (uint64_t *)(v217 - (v172 >> 3));
          *(_QWORD *)&v217 = v191;
          v172 &= 7u;
        }
        else
        {
          if ((_QWORD)v217 == *((_QWORD *)&v217 + 1))
            break;
          v189 = v172 >> 3;
          v100 = n;
          v190 = (unint64_t)(v217 - v189) < *((_QWORD *)&v217 + 1);
          if ((unint64_t)(v217 - v189) >= *((_QWORD *)&v217 + 1))
            v189 = v189;
          else
            v189 = (v217 - DWORD2(v217));
          v191 = (uint64_t *)(v217 - v189);
          *(_QWORD *)&v217 = v217 - v189;
          v172 -= 8 * v189;
        }
        DWORD2(v216) = v172;
        v192 = *v191;
        *(_QWORD *)&v216 = v192;
        if ((unint64_t)v41 > ii)
          break;
        if (v190)
          break;
        v193 = v31 + 4 * ((unint64_t)(v192 << v172) >> v101);
        *(_WORD *)v41 = *(_WORD *)v193;
        v172 += *(unsigned __int8 *)(v193 + 2);
        DWORD2(v216) = v172;
      }
      while ((unint64_t)v41 <= ii)
      {
        v194 = v31 + 4 * ((_QWORD)v216 << v172 >> v101);
        *(_WORD *)v41 = *(_WORD *)v194;
        v172 += *(unsigned __int8 *)(v194 + 2);
        DWORD2(v216) = v172;
        v41 += *(unsigned __int8 *)(v194 + 3);
      }
      if (v41 < v30)
      {
        v195 = (_QWORD)v216 << v172 >> v101;
        v196 = (char *)(v31 + 4 * v195);
        *v41 = *v196;
        if (v196[3] == 1)
        {
          v172 = DWORD2(v216) + v196[2];
        }
        else
        {
          v172 = DWORD2(v216);
          if (DWORD2(v216) <= 0x3F)
          {
            v197 = DWORD2(v216) + *(unsigned __int8 *)(v31 + 4 * v195 + 2);
            if (v197 >= 0x40)
              v172 = 64;
            else
              v172 = v197;
          }
        }
      }
      if (v172 == 64
        && (_QWORD)v217 == *((_QWORD *)&v217 + 1)
        && v29 == 64
        && v100 == 0
        && v26 == 64
        && v102 == 0
        && j == 64
        && v19 == 6)
      {
        return v148;
      }
      else
      {
        return -20;
      }
    }
  }
  return result;
}

unint64_t HUF_decompress4X2_DCtx_wksp(int *a1, char *a2, uint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t result;

  result = HUF_readDTableX2_wksp(a1, a4, a5, a6, a7);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
      return -72;
    else
      return HUF_decompress4X2_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (uint64_t)a1);
  }
  return result;
}

uint64_t HUF_decompress1X_usingDTable(char *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5)
{
  if (*(_BYTE *)(a5 + 1))
    return HUF_decompress1X2_usingDTable_internal(a1, a2, a3, a4, a5);
  else
    return HUF_decompress1X1_usingDTable_internal(a1, a2, a3, a4, a5);
}

unint64_t HUF_decompress4X_usingDTable(char *a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5)
{
  if (*(_BYTE *)(a5 + 1))
    return HUF_decompress4X2_usingDTable_internal(a1, a2, a3, a4, a5);
  else
    return HUF_decompress4X1_usingDTable_internal(a1, a2, a3, a4, a5);
}

BOOL HUF_selectDecoder(unint64_t a1, unint64_t a2)
{
  unsigned int v2;
  _DWORD *v3;
  unsigned int v4;

  if (a2 >= a1)
    v2 = 15;
  else
    v2 = 16 * a2 / a1;
  v3 = (_DWORD *)((char *)&algoTime + 24 * v2);
  v4 = *v3 + v3[1] * (a1 >> 8);
  LODWORD(v3) = v3[2] + v3[3] * (a1 >> 8);
  return v3 + (v3 >> 3) < v4;
}

unint64_t HUF_decompress4X_hufOnly_wksp(int *a1, char *a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unsigned int v12;
  unint64_t result;
  _DWORD *v14;
  unsigned int v15;

  if (!a3)
    return -70;
  if (!a5)
    return -20;
  if (a5 >= a3)
    v12 = 15;
  else
    v12 = 16 * a5 / a3;
  v14 = (_DWORD *)((char *)&algoTime + 24 * v12);
  v15 = *v14 + v14[1] * (a3 >> 8);
  LODWORD(v14) = v14[2] + v14[3] * (a3 >> 8);
  if (v14 + (v14 >> 3) >= v15)
  {
    result = HUF_readDTableX1_wksp_bmi2(a1, a4, a5, a6, a7);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (a5 > result)
        return HUF_decompress4X1_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (uint64_t)a1);
      return -72;
    }
  }
  else
  {
    result = HUF_readDTableX2_wksp(a1, a4, a5, a6, a7);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (a5 > result)
        return HUF_decompress4X2_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (uint64_t)a1);
      return -72;
    }
  }
  return result;
}

unint64_t HUF_decompress1X_DCtx_wksp(int *a1, _BYTE *__b, size_t __len, unsigned __int8 *__src, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t result;
  unsigned int v13;
  _DWORD *v14;
  unsigned int v15;

  if (!__len)
    return -70;
  if (a5 > __len)
    return -20;
  if (a5 == __len)
  {
    memcpy(__b, __src, __len);
    return __len;
  }
  if (a5 == 1)
  {
    memset(__b, *__src, __len);
    return __len;
  }
  if (a5 >= __len)
    v13 = 15;
  else
    v13 = 16 * a5 / __len;
  v14 = (_DWORD *)((char *)&algoTime + 24 * v13);
  v15 = *v14 + v14[1] * (__len >> 8);
  LODWORD(v14) = v14[2] + v14[3] * (__len >> 8);
  if (v14 + (v14 >> 3) >= v15)
  {
    result = HUF_readDTableX1_wksp_bmi2(a1, (char *)__src, a5, a6, a7);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (a5 > result)
        return HUF_decompress1X1_usingDTable_internal(__b, __len, &__src[result], a5 - result, (uint64_t)a1);
      return -72;
    }
  }
  else
  {
    result = HUF_readDTableX2_wksp(a1, (char *)__src, a5, a6, a7);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (a5 > result)
        return HUF_decompress1X2_usingDTable_internal(__b, __len, &__src[result], a5 - result, (uint64_t)a1);
      return -72;
    }
  }
  return result;
}

uint64_t HUF_decompress1X_usingDTable_bmi2(char *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, uint64_t a5)
{
  if (*(_BYTE *)(a5 + 1))
    return HUF_decompress1X2_usingDTable_internal(a1, a2, a3, a4, a5);
  else
    return HUF_decompress1X1_usingDTable_internal(a1, a2, a3, a4, a5);
}

unint64_t HUF_decompress1X1_DCtx_wksp_bmi2(int *a1, _BYTE *a2, uint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t result;

  result = HUF_readDTableX1_wksp_bmi2(a1, a4, a5, a6, a7);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
      return -72;
    else
      return HUF_decompress1X1_usingDTable_internal(a2, a3, (unsigned __int8 *)&a4[result], a5 - result, (uint64_t)a1);
  }
  return result;
}

unint64_t HUF_decompress4X_usingDTable_bmi2(char *a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5)
{
  if (*(_BYTE *)(a5 + 1))
    return HUF_decompress4X2_usingDTable_internal(a1, a2, a3, a4, a5);
  else
    return HUF_decompress4X1_usingDTable_internal(a1, a2, a3, a4, a5);
}

unint64_t HUF_decompress4X_hufOnly_wksp_bmi2(int *a1, char *a2, unint64_t a3, char *a4, unint64_t a5, uint64_t a6, unint64_t a7)
{
  unsigned int v12;
  unint64_t result;
  _DWORD *v14;
  unsigned int v15;

  if (!a3)
    return -70;
  if (!a5)
    return -20;
  if (a5 >= a3)
    v12 = 15;
  else
    v12 = 16 * a5 / a3;
  v14 = (_DWORD *)((char *)&algoTime + 24 * v12);
  v15 = *v14 + v14[1] * (a3 >> 8);
  LODWORD(v14) = v14[2] + v14[3] * (a3 >> 8);
  if (v14 + (v14 >> 3) >= v15)
  {
    result = HUF_readDTableX1_wksp_bmi2(a1, a4, a5, a6, a7);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (a5 > result)
        return HUF_decompress4X1_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (uint64_t)a1);
      return -72;
    }
  }
  else
  {
    result = HUF_readDTableX2_wksp(a1, a4, a5, a6, a7);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (a5 > result)
        return HUF_decompress4X2_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (uint64_t)a1);
      return -72;
    }
  }
  return result;
}

unint64_t HUF_readDTableX1(int *a1, char *a2, unint64_t a3)
{
  _BYTE v4[2048];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  return HUF_readDTableX1_wksp_bmi2(a1, a2, a3, (uint64_t)v4, 0x800uLL);
}

unint64_t HUF_decompress1X1_DCtx(int *a1, _BYTE *a2, uint64_t a3, char *a4, unint64_t a5)
{
  unint64_t result;
  _BYTE v11[2048];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = HUF_readDTableX1_wksp_bmi2(a1, a4, a5, (uint64_t)v11, 0x800uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
      return -72;
    else
      return HUF_decompress1X1_usingDTable_internal(a2, a3, (unsigned __int8 *)&a4[result], a5 - result, (uint64_t)a1);
  }
  return result;
}

unint64_t HUF_decompress1X1(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  unint64_t result;
  int v11;
  uint64_t v12;
  _QWORD v13[257];

  MEMORY[0x1E0C80A78](a1, a2);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v13[256] = *MEMORY[0x1E0C80C00];
  bzero(&v12, 0x2000uLL);
  v11 = 184549387;
  result = HUF_readDTableX1_wksp_bmi2(&v11, v5, v3, (uint64_t)v13, 0x800uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (v3 <= result)
      return -72;
    else
      return HUF_decompress1X1_usingDTable_internal(v9, v7, (unsigned __int8 *)&v5[result], v3 - result, (uint64_t)&v11);
  }
  return result;
}

unint64_t HUF_readDTableX2(int *a1, char *a2, unint64_t a3)
{
  _BYTE v4[2048];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  return HUF_readDTableX2_wksp(a1, a2, a3, (uint64_t)v4, 0x800uLL);
}

unint64_t HUF_decompress1X2_DCtx(int *a1, char *a2, uint64_t a3, char *a4, unint64_t a5)
{
  unint64_t result;
  _BYTE v11[2048];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = HUF_readDTableX2_wksp(a1, a4, a5, (uint64_t)v11, 0x800uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
      return -72;
    else
      return HUF_decompress1X2_usingDTable_internal(a2, a3, (unsigned __int8 *)&a4[result], a5 - result, (uint64_t)a1);
  }
  return result;
}

unint64_t HUF_decompress1X2(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  unint64_t result;
  int v11;
  uint64_t v12;
  _QWORD v13[257];

  MEMORY[0x1E0C80A78](a1, a2);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v13[256] = *MEMORY[0x1E0C80C00];
  bzero(&v12, 0x4000uLL);
  v11 = 201326604;
  result = HUF_readDTableX2_wksp(&v11, v5, v3, (uint64_t)v13, 0x800uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (v3 <= result)
      return -72;
    else
      return HUF_decompress1X2_usingDTable_internal(v9, v7, (unsigned __int8 *)&v5[result], v3 - result, (uint64_t)&v11);
  }
  return result;
}

unint64_t HUF_decompress4X1_DCtx(int *a1, _BYTE *a2, uint64_t a3, char *a4, unint64_t a5)
{
  unint64_t result;
  _BYTE v11[2048];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = HUF_readDTableX1_wksp_bmi2(a1, a4, a5, (uint64_t)v11, 0x800uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
      return -72;
    else
      return HUF_decompress4X1_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (uint64_t)a1);
  }
  return result;
}

unint64_t HUF_decompress4X1(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  unint64_t result;
  int v11;
  uint64_t v12;
  _QWORD v13[257];

  MEMORY[0x1E0C80A78](a1, a2);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v13[256] = *MEMORY[0x1E0C80C00];
  bzero(&v12, 0x2000uLL);
  v11 = 184549387;
  result = HUF_readDTableX1_wksp_bmi2(&v11, v5, v3, (uint64_t)v13, 0x800uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (v3 <= result)
      return -72;
    else
      return HUF_decompress4X1_usingDTable_internal(v9, v7, (unsigned __int16 *)&v5[result], v3 - result, (uint64_t)&v11);
  }
  return result;
}

unint64_t HUF_decompress4X2_DCtx(int *a1, char *a2, uint64_t a3, char *a4, unint64_t a5)
{
  unint64_t result;
  _BYTE v11[2048];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = HUF_readDTableX2_wksp(a1, a4, a5, (uint64_t)v11, 0x800uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (a5 <= result)
      return -72;
    else
      return HUF_decompress4X2_usingDTable_internal(a2, a3, (unsigned __int16 *)&a4[result], a5 - result, (uint64_t)a1);
  }
  return result;
}

unint64_t HUF_decompress4X2(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  unint64_t result;
  int v11;
  uint64_t v12;
  _QWORD v13[257];

  MEMORY[0x1E0C80A78](a1, a2);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v13[256] = *MEMORY[0x1E0C80C00];
  bzero(&v12, 0x4000uLL);
  v11 = 201326604;
  result = HUF_readDTableX2_wksp(&v11, v5, v3, (uint64_t)v13, 0x800uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (v3 <= result)
      return -72;
    else
      return HUF_decompress4X2_usingDTable_internal(v9, v7, (unsigned __int16 *)&v5[result], v3 - result, (uint64_t)&v11);
  }
  return result;
}

uint64_t HUF_decompress(void *a1, size_t __len, unsigned __int8 *__src, size_t a4)
{
  unsigned int v6;
  _DWORD *v7;
  unsigned int v8;

  if (!__len)
    return -70;
  if (a4 > __len)
    return -20;
  if (a4 == __len)
  {
    memcpy(a1, __src, __len);
    return __len;
  }
  else if (a4 == 1)
  {
    memset(a1, *__src, __len);
    return __len;
  }
  else
  {
    if (a4 >= __len)
      v6 = 15;
    else
      v6 = 16 * a4 / __len;
    v7 = (_DWORD *)((char *)&algoTime + 24 * v6);
    v8 = *v7 + v7[1] * (__len >> 8);
    LODWORD(v7) = v7[2] + v7[3] * (__len >> 8);
    return ((uint64_t (*)(void *, size_t, unsigned __int8 *))HUF_decompress_decompress[v7
                                                                                               + (v7 >> 3) < v8])(a1, __len, __src);
  }
}

uint64_t HUF_decompress4X_DCtx(int *a1, _BYTE *__b, size_t __len, unsigned __int8 *__src, unint64_t a5)
{
  uint64_t v6;
  unsigned int v10;
  _DWORD *v11;
  unsigned int v12;
  unint64_t DTableX1_wksp_bmi2;
  _BYTE v15[2048];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!__len)
    return -70;
  v6 = __len;
  if (a5 <= __len)
  {
    if (a5 == __len)
    {
      memcpy(__b, __src, __len);
      return v6;
    }
    if (a5 == 1)
    {
      memset(__b, *__src, __len);
      return v6;
    }
    if (a5 >= __len)
      v10 = 15;
    else
      v10 = 16 * a5 / __len;
    v11 = (_DWORD *)((char *)&algoTime + 24 * v10);
    v12 = *v11 + v11[1] * (__len >> 8);
    LODWORD(v11) = v11[2] + v11[3] * (__len >> 8);
    if (v11 + (v11 >> 3) >= v12)
    {
      DTableX1_wksp_bmi2 = HUF_readDTableX1_wksp_bmi2(a1, (char *)__src, a5, (uint64_t)v15, 0x800uLL);
      if (DTableX1_wksp_bmi2 > 0xFFFFFFFFFFFFFF88)
        return DTableX1_wksp_bmi2;
      if (a5 > DTableX1_wksp_bmi2)
        return HUF_decompress4X1_usingDTable_internal(__b, v6, (unsigned __int16 *)&__src[DTableX1_wksp_bmi2], a5 - DTableX1_wksp_bmi2, (uint64_t)a1);
    }
    else
    {
      DTableX1_wksp_bmi2 = HUF_readDTableX2_wksp(a1, (char *)__src, a5, (uint64_t)v15, 0x800uLL);
      if (DTableX1_wksp_bmi2 > 0xFFFFFFFFFFFFFF88)
        return DTableX1_wksp_bmi2;
      if (a5 > DTableX1_wksp_bmi2)
        return HUF_decompress4X2_usingDTable_internal(__b, v6, (unsigned __int16 *)&__src[DTableX1_wksp_bmi2], a5 - DTableX1_wksp_bmi2, (uint64_t)a1);
    }
    return -72;
  }
  return -20;
}

unint64_t HUF_decompress4X_hufOnly(int *a1, char *a2, unint64_t a3, char *a4, unint64_t a5)
{
  _BYTE v6[2048];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  return HUF_decompress4X_hufOnly_wksp(a1, a2, a3, a4, a5, (uint64_t)v6, 0x800uLL);
}

unint64_t HUF_decompress1X_DCtx(int *a1, _BYTE *a2, size_t a3, unsigned __int8 *a4, unint64_t a5)
{
  _BYTE v6[2048];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  return HUF_decompress1X_DCtx_wksp(a1, a2, a3, a4, a5, (uint64_t)v6, 0x800uLL);
}

uint64_t ZSTD_DDict_dictContent(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t ZSTD_DDict_dictSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

double ZSTD_copyDDictParameters(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double result;

  *(_DWORD *)(a1 + 29680) = *(_DWORD *)(a2 + 27316);
  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 29384) = v2;
  *(_QWORD *)(a1 + 29392) = v2;
  v4 = v2 + v3;
  *(_QWORD *)(a1 + 29400) = v4;
  *(_QWORD *)(a1 + 29376) = v4;
  if (*(_DWORD *)(a2 + 27320))
  {
    *(_QWORD *)a1 = a2 + 24;
    *(_QWORD *)(a1 + 8) = a2 + 6184;
    *(_QWORD *)&result = 0x100000001;
    *(_QWORD *)(a1 + 29480) = 0x100000001;
    *(_QWORD *)(a1 + 16) = a2 + 4128;
    *(_QWORD *)(a1 + 24) = a2 + 10288;
    *(_DWORD *)(a1 + 26684) = *(_DWORD *)(a2 + 26676);
    *(_DWORD *)(a1 + 26688) = *(_DWORD *)(a2 + 26680);
    *(_DWORD *)(a1 + 26692) = *(_DWORD *)(a2 + 26684);
  }
  else
  {
    result = 0.0;
    *(_QWORD *)(a1 + 29480) = 0;
  }
  return result;
}

char *ZSTD_createDDict_advanced(const void *a1, size_t a2, int a3, int a4, __int128 *a5)
{
  uint64_t (*v5)(_QWORD, uint64_t);
  char *v6;
  __int128 v13;
  uint64_t (*v14)(_QWORD, size_t);
  void *v15;
  _DWORD *v16;
  void (*v17)(uint64_t, char *);
  uint64_t v18;

  v5 = *(uint64_t (**)(_QWORD, uint64_t))a5;
  if ((*(_QWORD *)a5 == 0) != (*((_QWORD *)a5 + 1) == 0))
    return 0;
  if (v5)
  {
    v6 = (char *)v5(*((_QWORD *)a5 + 2), 27352);
    if (!v6)
      return v6;
  }
  else
  {
    v6 = (char *)malloc_type_malloc(0x6AD8uLL, 0x26AA08A0uLL);
    if (!v6)
      return v6;
  }
  v13 = *a5;
  *((_QWORD *)v6 + 3418) = *((_QWORD *)a5 + 2);
  *((_OWORD *)v6 + 1708) = v13;
  if (a1 && a2 && a3 != 1)
  {
    v14 = (uint64_t (*)(_QWORD, size_t))*((_QWORD *)v6 + 3416);
    if (v14)
    {
      v15 = (void *)v14(*((_QWORD *)v6 + 3418), a2);
      *(_QWORD *)v6 = v15;
      *((_QWORD *)v6 + 1) = v15;
      if (v15)
      {
LABEL_13:
        memcpy(v15, a1, a2);
        goto LABEL_16;
      }
    }
    else
    {
      v15 = malloc_type_malloc(a2, 0x26AA08A0uLL);
      *(_QWORD *)v6 = v15;
      *((_QWORD *)v6 + 1) = v15;
      if (v15)
        goto LABEL_13;
    }
    v17 = (void (*)(uint64_t, char *))*((_QWORD *)v6 + 3417);
    if (v17)
    {
      v18 = *((_QWORD *)v6 + 3418);
      goto LABEL_29;
    }
LABEL_31:
    free(v6);
    return 0;
  }
  *(_QWORD *)v6 = 0;
  *((_QWORD *)v6 + 1) = a1;
  if (!a1)
    a2 = 0;
LABEL_16:
  *((_QWORD *)v6 + 2) = a2;
  *((_DWORD *)v6 + 2572) = 201326604;
  *(_QWORD *)(v6 + 27316) = 0;
  if (a4 == 1)
    return v6;
  if (a2 <= 7 || (v16 = (_DWORD *)*((_QWORD *)v6 + 1), *v16 != -332356553))
  {
    if (a4 != 2)
      return v6;
LABEL_22:
    v17 = (void (*)(uint64_t, char *))*((_QWORD *)v6 + 3417);
    v18 = *((_QWORD *)v6 + 3418);
    if (*(_QWORD *)v6)
    {
      if (v17)
      {
        ((void (*)(_QWORD))v17)(*((_QWORD *)v6 + 3418));
LABEL_29:
        v17(v18, v6);
        return 0;
      }
      free(*(void **)v6);
    }
    else if (v17)
    {
      goto LABEL_29;
    }
    goto LABEL_31;
  }
  *((_DWORD *)v6 + 6829) = v16[1];
  if ((unint64_t)ZSTD_loadDEntropy((int *)v6 + 6, (uint64_t)v16, a2) > 0xFFFFFFFFFFFFFF88)
    goto LABEL_22;
  *((_DWORD *)v6 + 6830) = 1;
  return v6;
}

uint64_t ZSTD_freeDDict(void **a1)
{
  void (*v2)(void *);
  void *v3;

  if (a1)
  {
    v2 = (void (*)(void *))a1[3417];
    v3 = a1[3418];
    if (*a1)
    {
      if (v2)
      {
        v2(a1[3418]);
LABEL_6:
        ((void (*)(void *, void **))v2)(v3, a1);
        return 0;
      }
      free(*a1);
    }
    else if (v2)
    {
      goto LABEL_6;
    }
    free(a1);
  }
  return 0;
}

char *ZSTD_createDDict(const void *a1, size_t a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = 0uLL;
  v4 = 0;
  return ZSTD_createDDict_advanced(a1, a2, 0, 0, &v3);
}

char *ZSTD_createDDict_byReference(const void *a1, size_t a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = 0uLL;
  v4 = 0;
  return ZSTD_createDDict_advanced(a1, a2, 1, 0, &v3);
}

uint64_t ZSTD_initStaticDDict(uint64_t a1, unint64_t a2, _DWORD *__src, size_t __n, int a5, int a6)
{
  uint64_t v6;
  unint64_t v9;
  uint64_t v11;
  unint64_t v12;

  if ((a1 & 7) != 0)
    return 0;
  v9 = 27352;
  if (a5 != 1)
    v9 = __n + 27352;
  if (v9 > a2)
    return 0;
  v6 = a1;
  v11 = a1 + 27316;
  if (!a5)
  {
    memcpy((void *)(a1 + 27352), __src, __n);
    __src = (_DWORD *)(v11 + 36);
  }
  *(_QWORD *)v6 = 0;
  *(_QWORD *)(v6 + 8) = __src;
  if (__src)
    v12 = __n;
  else
    v12 = 0;
  *(_QWORD *)(v6 + 16) = v12;
  *(_DWORD *)(v6 + 10288) = 201326604;
  *(_QWORD *)v11 = 0;
  if (a6 == 1)
    return v6;
  if (v12 <= 7 || *__src != -332356553)
  {
    if (a6 != 2)
      return v6;
    return 0;
  }
  *(_DWORD *)v11 = __src[1];
  if ((unint64_t)ZSTD_loadDEntropy((int *)(v6 + 24), (uint64_t)__src, v12) > 0xFFFFFFFFFFFFFF88)
    return 0;
  *(_DWORD *)(v11 + 4) = 1;
  return v6;
}

uint64_t ZSTD_estimateDDictSize(uint64_t a1, int a2)
{
  if (a2 == 1)
    return 27352;
  else
    return a1 + 27352;
}

uint64_t ZSTD_sizeof_DDict(uint64_t result)
{
  if (result)
  {
    if (*(_QWORD *)result)
      return *(_QWORD *)(result + 16) + 27352;
    else
      return 27352;
  }
  return result;
}

uint64_t ZSTD_getDictID_fromDDict(uint64_t result)
{
  _DWORD *v1;

  if (result)
  {
    if (*(_QWORD *)(result + 16) >= 8uLL && (v1 = *(_DWORD **)(result + 8), *v1 == -332356553))
      return v1[1];
    else
      return 0;
  }
  return result;
}

uint64_t ZSTD_getDictID_fromDict(_DWORD *a1, unint64_t a2)
{
  if (a2 >= 8 && *a1 == -332356553)
    return a1[1];
  else
    return 0;
}

_QWORD *ZSTD_sizeof_DCtx(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = (_QWORD *)result[3708];
    if (v1)
    {
      v2 = 188328;
      if (*v1)
        v2 = v1[2] + 188328;
    }
    else
    {
      v2 = 160976;
    }
    return (_QWORD *)(result[3715] + v2 + result[3719]);
  }
  return result;
}

uint64_t ZSTD_estimateDCtxSize()
{
  return 160976;
}

uint64_t ZSTD_initStaticDCtx(uint64_t a1, unint64_t a2)
{
  uint64_t v2;

  v2 = 0;
  if (a2 >= 0x274D0 && (a1 & 7) == 0)
  {
    *(_QWORD *)(a1 + 29400) = 0;
    *(_QWORD *)(a1 + 29684) = 0;
    *(_QWORD *)(a1 + 29752) = 0;
    *(_QWORD *)(a1 + 29784) = 0;
    *(_DWORD *)(a1 + 29792) = 0;
    *(_QWORD *)(a1 + 160968) = 0;
    *(_DWORD *)(a1 + 29656) = 0;
    *(_QWORD *)(a1 + 29696) = 0;
    *(_OWORD *)(a1 + 29664) = 0u;
    *(_OWORD *)(a1 + 29708) = 0u;
    *(_DWORD *)(a1 + 29724) = 0;
    *(_QWORD *)(a1 + 29736) = 134217729;
    *(_QWORD *)(a1 + 29804) = 0;
    *(_QWORD *)(a1 + 29584) = 0;
    *(_DWORD *)(a1 + 29704) = 0;
    *(_QWORD *)(a1 + 29648) = a2;
    v2 = a1;
    *(_QWORD *)(a1 + 29712) = a1 + 160976;
  }
  return v2;
}

double ZSTD_createDCtx_advanced(uint64_t a1)
{
  uint64_t (*v1)(_QWORD, uint64_t);
  char *v3;
  double result;
  uint64_t v5;

  v1 = *(uint64_t (**)(_QWORD, uint64_t))a1;
  if ((*(_QWORD *)a1 == 0) == (*(_QWORD *)(a1 + 8) == 0))
  {
    if (v1)
    {
      v3 = (char *)v1(*(_QWORD *)(a1 + 16), 160976);
      if (!v3)
        return result;
    }
    else
    {
      v3 = (char *)malloc_type_malloc(0x274D0uLL, 0x26AA08A0uLL);
      if (!v3)
        return result;
    }
    v5 = *(_QWORD *)(a1 + 16);
    *(_OWORD *)(v3 + 29608) = *(_OWORD *)a1;
    *((_QWORD *)v3 + 3703) = v5;
    *((_QWORD *)v3 + 3706) = 0;
    *((_QWORD *)v3 + 3675) = 0;
    result = 0.0;
    *(_QWORD *)(v3 + 29684) = 0;
    *((_QWORD *)v3 + 3719) = 0;
    *((_QWORD *)v3 + 3723) = 0;
    *((_DWORD *)v3 + 7448) = 0;
    *((_QWORD *)v3 + 20121) = 0;
    *((_DWORD *)v3 + 7414) = 0;
    *((_QWORD *)v3 + 3712) = 0;
    *((_OWORD *)v3 + 1854) = 0u;
    *(_OWORD *)(v3 + 29708) = 0u;
    *((_DWORD *)v3 + 7431) = 0;
    *((_QWORD *)v3 + 3717) = 134217729;
    *(_QWORD *)(v3 + 29804) = 0;
    *((_QWORD *)v3 + 3698) = 0;
    *((_DWORD *)v3 + 7426) = 0;
  }
  return result;
}

double ZSTD_createDCtx()
{
  char *v0;
  double result;

  v0 = (char *)malloc_type_malloc(0x274D0uLL, 0x26AA08A0uLL);
  if (v0)
  {
    *((_QWORD *)v0 + 3706) = 0;
    *((_QWORD *)v0 + 3675) = 0;
    result = 0.0;
    *(_QWORD *)(v0 + 29684) = 0;
    *((_QWORD *)v0 + 3719) = 0;
    *((_QWORD *)v0 + 3723) = 0;
    *((_DWORD *)v0 + 7448) = 0;
    *((_QWORD *)v0 + 20121) = 0;
    *((_DWORD *)v0 + 7414) = 0;
    *((_QWORD *)v0 + 3712) = 0;
    *((_OWORD *)v0 + 1854) = 0u;
    *(_OWORD *)(v0 + 29708) = 0u;
    *((_DWORD *)v0 + 7431) = 0;
    *((_QWORD *)v0 + 3701) = 0;
    *((_QWORD *)v0 + 3703) = 0;
    *((_QWORD *)v0 + 3702) = 0;
    *((_QWORD *)v0 + 3717) = 134217729;
    *(_QWORD *)(v0 + 29804) = 0;
    *((_QWORD *)v0 + 3698) = 0;
    *((_DWORD *)v0 + 7426) = 0;
  }
  return result;
}

uint64_t ZSTD_freeDCtx(uint64_t result)
{
  uint64_t v1;
  void (*v2)(uint64_t);
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  uint64_t v7;
  void *v8;
  void **v9;

  if (!result)
    return result;
  v1 = result;
  if (*(_QWORD *)(result + 29648))
    return -64;
  v2 = *(void (**)(uint64_t))(result + 29616);
  v3 = *(_QWORD *)(result + 29624);
  v4 = (_QWORD *)(result + 29664);
  v5 = *(_QWORD *)(result + 29664);
  if (v5)
  {
    v6 = *(void (**)(uint64_t, uint64_t))(v5 + 27336);
    v7 = *(_QWORD *)(v5 + 27344);
    if (*(_QWORD *)v5)
    {
      if (v6)
      {
        ((void (*)(_QWORD))v6)(*(_QWORD *)(v5 + 27344));
LABEL_9:
        v6(v7, v5);
        goto LABEL_10;
      }
      free(*(void **)v5);
    }
    else if (v6)
    {
      goto LABEL_9;
    }
    free((void *)v5);
    *(_DWORD *)(v1 + 29688) = 0;
    *v4 = 0;
    *(_QWORD *)(v1 + 29672) = 0;
    v8 = *(void **)(v1 + 29712);
    if (!v8)
      goto LABEL_16;
    goto LABEL_11;
  }
LABEL_10:
  *(_DWORD *)(v1 + 29688) = 0;
  *v4 = 0;
  *(_QWORD *)(v1 + 29672) = 0;
  v8 = *(void **)(v1 + 29712);
  if (!v8)
    goto LABEL_16;
LABEL_11:
  if (v2)
    v2(v3);
  else
    free(v8);
LABEL_16:
  *(_QWORD *)(v1 + 29712) = 0;
  v9 = *(void ***)(v1 + 29696);
  if (v9)
  {
    if (*v9)
    {
      if (v2)
      {
        v2(v3);
LABEL_21:
        ((void (*)(uint64_t, void **))v2)(v3, v9);
LABEL_24:
        *(_QWORD *)(v1 + 29696) = 0;
        goto LABEL_25;
      }
      free(*v9);
    }
    else if (v2)
    {
      goto LABEL_21;
    }
    free(v9);
    goto LABEL_24;
  }
LABEL_25:
  if (v2)
    ((void (*)(uint64_t, uint64_t))v2)(v3, v1);
  else
    free((void *)v1);
  return 0;
}

void *ZSTD_copyDCtx(void *a1, const void *a2)
{
  return memcpy(a1, a2, 0x7410uLL);
}

BOOL ZSTD_isFrame(_DWORD *a1, unint64_t a2)
{
  if (a2 < 4)
    return 0;
  if (*a1 == -47205080)
    return 1;
  return *a1 >> 4 == 25481893;
}

uint64_t ZSTD_frameHeaderSize(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  _BOOL4 v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;

  if (a2 < 5)
    return -72;
  v3 = *(unsigned __int8 *)(a1 + 4);
  v4 = v3 & 3;
  v5 = v3 < 0x40;
  v6 = *(_QWORD *)((char *)&ZSTD_fcs_fieldSize + ((v3 >> 3) & 0x18));
  LODWORD(v3) = v3 & 0x20;
  v7 = (_DWORD)v3 == 0;
  v8 = v5 & (v3 >> 5);
  v9 = ZSTD_did_fieldSize[v4] + v6;
  if (v7)
    ++v9;
  return v9 + v8 + 5;
}

unint64_t ZSTD_getFrameHeader_advanced(uint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4)
{
  unint64_t result;
  uint64_t v6;
  unsigned __int8 *v7;
  unint64_t v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  unint64_t v24;

  if (a4)
    result = 1;
  else
    result = 5;
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (result <= a3)
  {
    if (!a2)
      return -1;
    if (a4 == 1)
    {
      if (!a3)
        return -72;
      v6 = 1;
      v7 = a2;
    }
    else
    {
      if (*(_DWORD *)a2 != -47205080)
      {
        if (*(_DWORD *)a2 >> 4 != 25481893)
          return -10;
        if (a3 < 8)
          return 8;
        result = 0;
        *(_QWORD *)a1 = *((unsigned int *)a2 + 1);
        *(_DWORD *)(a1 + 20) = 1;
        return result;
      }
      v7 = &a2[result - 1];
      v6 = result;
    }
    v8 = *v7;
    v9 = v8 < 0x40;
    v10 = ZSTD_did_fieldSize[v8 & 3];
    v11 = *(_QWORD *)((char *)&ZSTD_fcs_fieldSize + ((v8 >> 3) & 0x18));
    LODWORD(v8) = v8 & 0x20;
    v12 = (_DWORD)v8 == 0;
    v13 = v9 & (v8 >> 5);
    v14 = v10 + v6 + v11;
    if (v12)
      ++v14;
    v15 = v14 + v13;
    if (v15 > a3)
      return v15;
    *(_DWORD *)(a1 + 24) = v15;
    v16 = a2[result - 1];
    if ((v16 & 8) != 0)
      return -14;
    if ((v16 & 0x20) != 0)
    {
      v18 = 0;
    }
    else
    {
      v17 = a2[result];
      if (v17 > 0xAF)
        return -16;
      ++result;
      v18 = (1 << ((v17 >> 3) + 10))
          + ((unint64_t)(1 << ((v17 >> 3) + 10)) >> 3) * (v17 & 7);
    }
    v19 = v16 & 3;
    v20 = v16 >> 6;
    switch(v19)
    {
      case 3:
        v21 = *(_DWORD *)&a2[result];
        result += 4;
        break;
      case 2:
        v21 = *(unsigned __int16 *)&a2[result];
        result += 2;
        break;
      case 1:
        v21 = a2[result++];
        break;
      default:
        v21 = 0;
        break;
    }
    v22 = (v16 >> 2) & 1;
    switch(v20)
    {
      case 1u:
        v23 = *(unsigned __int16 *)&a2[result] + 256;
        break;
      case 2u:
        v23 = *(unsigned int *)&a2[result];
        break;
      case 3u:
        v23 = *(_QWORD *)&a2[result];
        break;
      default:
        if ((v16 & 0x20) != 0)
          v23 = a2[result];
        else
          v23 = -1;
        break;
    }
    result = 0;
    if ((v16 & 0x20) != 0)
      v24 = v23;
    else
      v24 = v18;
    *(_QWORD *)a1 = v23;
    *(_QWORD *)(a1 + 8) = v24;
    if (v24 >= 0x20000)
      LODWORD(v24) = 0x20000;
    *(_DWORD *)(a1 + 16) = v24;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 28) = v21;
    *(_DWORD *)(a1 + 32) = v22;
  }
  return result;
}

unint64_t ZSTD_getFrameHeader(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  return ZSTD_getFrameHeader_advanced(a1, a2, a3, 0);
}

uint64_t ZSTD_getFrameContentSize(unsigned __int8 *a1, unint64_t a2)
{
  unint64_t FrameHeader_advanced;
  uint64_t v3;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = 0;
  v5 = 0u;
  v6 = 0u;
  FrameHeader_advanced = ZSTD_getFrameHeader_advanced((uint64_t)&v5, a1, a2, 0);
  if (DWORD1(v6) == 1)
    v3 = 0;
  else
    v3 = v5;
  if (FrameHeader_advanced)
    return -2;
  else
    return v3;
}

unint64_t ZSTD_findDecompressedSize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t result;
  uint64_t v6;
  unint64_t FrameSizeInfo;
  unint64_t FrameHeader_advanced;
  unint64_t v10;
  BOOL v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v2 = a2;
  if (a2 >= 5)
  {
    v3 = 0;
    while (1)
    {
      if (*(_DWORD *)a1 >> 4 == 25481893)
      {
        if (v2 < 8)
          return -2;
        v6 = *(unsigned int *)(a1 + 4);
        FrameSizeInfo = v6 + 8;
        if (v6 > 0xFFFFFFF7 || FrameSizeInfo > v2)
          return -2;
      }
      else
      {
        v14 = 0;
        v12 = 0u;
        v13 = 0u;
        FrameHeader_advanced = ZSTD_getFrameHeader_advanced((uint64_t)&v12, (unsigned __int8 *)a1, v2, 0);
        if (DWORD1(v13) == 1)
          v10 = 0;
        else
          v10 = v12;
        if (FrameHeader_advanced)
          result = -2;
        else
          result = v10;
        if (result > 0xFFFFFFFFFFFFFFFDLL)
          return result;
        v11 = __CFADD__(result, v3);
        v3 += result;
        if (v11)
          return -2;
        FrameSizeInfo = ZSTD_findFrameSizeInfo(a1, v2);
        if (FrameSizeInfo > 0xFFFFFFFFFFFFFF88)
          return -2;
      }
      v2 -= FrameSizeInfo;
      a1 += FrameSizeInfo;
      if (v2 <= 4)
        goto LABEL_3;
    }
  }
  v3 = 0;
LABEL_3:
  if (v2)
    return -2;
  else
    return v3;
}

unint64_t ZSTD_getDecompressedSize(unsigned __int8 *a1, unint64_t a2)
{
  unint64_t FrameHeader_advanced;
  unint64_t v3;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = 0;
  v5 = 0u;
  v6 = 0u;
  FrameHeader_advanced = ZSTD_getFrameHeader_advanced((uint64_t)&v5, a1, a2, 0);
  if (DWORD1(v6) == 1)
    v3 = 0;
  else
    v3 = v5;
  if (FrameHeader_advanced)
    v3 = -2;
  if (v3 <= 0xFFFFFFFFFFFFFFFDLL)
    return v3;
  else
    return 0;
}

unint64_t ZSTD_findFrameSizeInfo(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t result;
  uint64_t v7;
  unsigned __int16 *v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  if (a2 >= 8 && *(_DWORD *)a1 >> 4 == 25481893)
  {
    v4 = *(unsigned int *)(a1 + 4);
    v5 = v4 + 8;
    if (v4 + 8 > a2)
      v5 = -72;
    if (v4 <= 0xFFFFFFF7)
      return v5;
    else
      return -14;
  }
  else
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    result = ZSTD_getFrameHeader_advanced((uint64_t)&v14, (unsigned __int8 *)a1, a2, 0);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (!result)
      {
        v7 = 0;
        v8 = (unsigned __int16 *)(a1 + DWORD2(v15));
        v9 = a2 - DWORD2(v15);
        while (v9 >= 3)
        {
          v10 = *v8;
          v11 = ((unint64_t)*v8 >> 1) & 3;
          if ((_DWORD)v11 != 1)
          {
            if ((_DWORD)v11 == 3)
              return -20;
            v11 = (v10 | (*((unsigned __int8 *)v8 + 2) << 16)) >> 3;
          }
          v12 = v11 + 3;
          v13 = v9 >= v12;
          v9 -= v12;
          if (!v13)
            return -72;
          v8 = (unsigned __int16 *)((char *)v8 + v12);
          ++v7;
          if ((v10 & 1) != 0)
          {
            if ((_DWORD)v16)
            {
              if (v9 < 4)
                return -72;
              v8 += 2;
            }
            return (unint64_t)v8 - a1;
          }
        }
      }
      return -72;
    }
  }
  return result;
}

uint64_t ZSTD_decompressBound(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t FrameSizeInfo;
  uint64_t result;

  v4 = 0;
  while (a2)
  {
    FrameSizeInfo = ZSTD_findFrameSizeInfo(a1, a2);
    result = -2;
    if (FrameSizeInfo <= 0xFFFFFFFFFFFFFF88)
    {
      a1 += FrameSizeInfo;
      a2 -= FrameSizeInfo;
      v4 += v5;
      if (v5 != -2)
        continue;
    }
    return result;
  }
  return v4;
}

uint64_t ZSTD_insertBlock(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a3)
  {
    v3 = a1[3672];
    if (v3 != a2)
    {
      a1[3675] = v3;
      a1[3674] = a2 + a1[3673] - v3;
      a1[3673] = a2;
    }
  }
  a1[3672] = a2 + a3;
  return a3;
}

_QWORD *ZSTD_checkContinuity(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a3)
  {
    v3 = result[3672];
    if (v3 != a2)
    {
      result[3675] = v3;
      result[3674] = a2 + result[3673] - v3;
      result[3673] = a2;
      result[3672] = a2;
    }
  }
  return result;
}

uint64_t ZSTD_decompress_usingDict(uint64_t a1, char *a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5, char *a6, unint64_t a7)
{
  return ZSTD_decompressMultiFrame(a1, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t ZSTD_decompressMultiFrame(uint64_t a1, char *a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5, char *a6, unint64_t a7, uint64_t a8)
{
  unint64_t v11;
  uint64_t v14;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  char v20;
  _DWORD *v21;
  BOOL v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t DEntropy;
  uint64_t v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t FrameHeader_advanced;
  int v39;
  int v40;
  char *v41;
  char *v42;
  char *v43;
  unint64_t v44;
  int v45;
  unsigned int v46;
  unint64_t v47;
  unint64_t v48;
  unsigned __int8 *v49;
  BOOL v50;
  uint64_t v51;
  int v52;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  char v57;
  char *v58;
  _OWORD *v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _OWORD *v68;
  int *v69;
  _QWORD *v70;
  char *v71;
  _QWORD *v72;
  char *v73;
  unsigned int *v74;
  _DWORD *v75;

  v11 = a5;
  v14 = (uint64_t)a2;
  v16 = a1 + 26684;
  if (a8)
  {
    a6 = *(char **)(a8 + 8);
    a7 = *(_QWORD *)(a8 + 16);
  }
  v17 = 5;
  if (*(_DWORD *)(a1 + 29584))
    v17 = 1;
  if (v17 <= a5)
  {
    v20 = 0;
    v21 = (_DWORD *)(a8 + 26676);
    v72 = (_QWORD *)(a1 + 29456);
    v68 = (_OWORD *)(a1 + 29376);
    v69 = (int *)(a1 + 32);
    v67 = a1 + 10296;
    v66 = a1 + 6192;
    v65 = a1 + 4136;
    v64 = a8 + 24;
    v63 = a8 + 6184;
    v62 = a8 + 4128;
    v61 = a8 + 10288;
    if (a6)
      v22 = a7 == 0;
    else
      v22 = 1;
    v23 = !v22;
    v60 = v23;
    v58 = &a6[a7];
    v70 = (_QWORD *)(a1 + 29416);
    v74 = (unsigned int *)(a1 + 29488);
    v59 = (_OWORD *)(a1 + 29528);
    v18 = a2;
    v75 = (_DWORD *)(a8 + 26676);
LABEL_17:
    while (*(_DWORD *)a4 >> 4 == 25481893)
    {
      if (v11 < 8)
        return -72;
      v24 = *((unsigned int *)a4 + 1);
      if (v24 > 0xFFFFFFF7)
        return -14;
      v25 = v24 + 8;
      if (v25 <= v11)
        v19 = v25;
      else
        v19 = -72;
      if (v19 > 0xFFFFFFFFFFFFFF88)
        return v19;
      a4 += v19;
      v11 -= v19;
      if (v11 < v17)
        goto LABEL_7;
    }
    v57 = v20;
    v73 = v18;
    if (a8)
    {
      *(_DWORD *)(v16 + 3000) = *(_QWORD *)(a1 + 29400) != *(_QWORD *)(a8 + 8) + *(_QWORD *)(a8 + 16);
      *(_QWORD *)(a1 + 29408) = v17;
      *v68 = 0u;
      v68[1] = 0u;
      *v72 = 0;
      v72[1] = 0;
      *(_DWORD *)(a1 + 10296) = 201326604;
      *(_OWORD *)(a1 + 29472) = xmmword_18823D7A0;
      *(_QWORD *)v16 = 0x400000001;
      *(_DWORD *)(v16 + 8) = 8;
      *(_QWORD *)a1 = v69;
      *(_QWORD *)(a1 + 8) = v66;
      *(_QWORD *)(a1 + 16) = v65;
      *(_QWORD *)(a1 + 24) = v67;
      *(_DWORD *)(v16 + 2996) = v21[160];
      v27 = *(char **)(a8 + 8);
      v26 = *(_QWORD *)(a8 + 16);
      *(_QWORD *)(a1 + 29384) = v27;
      *(_QWORD *)(a1 + 29392) = v27;
      v28 = &v27[v26];
      *(_QWORD *)(a1 + 29400) = &v27[v26];
      *(_QWORD *)(a1 + 29376) = &v27[v26];
      if (v21[161])
      {
        *(_QWORD *)(a1 + 29480) = 0x100000001;
        *(_QWORD *)a1 = v64;
        *(_QWORD *)(a1 + 8) = v63;
        *(_QWORD *)(a1 + 16) = v62;
        *(_QWORD *)(a1 + 24) = v61;
        *(_DWORD *)v16 = *v21;
        *(_DWORD *)(v16 + 4) = v21[1];
        *(_DWORD *)(v16 + 8) = v21[2];
      }
    }
    else
    {
      v27 = 0;
      v28 = 0;
      *(_QWORD *)(a1 + 29408) = v17;
      *v68 = 0u;
      v68[1] = 0u;
      *v72 = 0;
      v72[1] = 0;
      *(_DWORD *)(a1 + 10296) = 201326604;
      *(_DWORD *)(v16 + 2996) = 0;
      *(_OWORD *)(a1 + 29472) = xmmword_18823D7A0;
      *(_QWORD *)v16 = 0x400000001;
      *(_DWORD *)(v16 + 8) = 8;
      *(_QWORD *)a1 = v69;
      *(_QWORD *)(a1 + 8) = v66;
      *(_QWORD *)(a1 + 16) = v65;
      *(_QWORD *)(a1 + 24) = v67;
      if (v60)
      {
        v29 = a6;
        v27 = a6;
        if (a7 >= 8)
        {
          v29 = a6;
          v27 = a6;
          if (*(_DWORD *)a6 == -332356553)
          {
            *(_DWORD *)(v16 + 2996) = *((_DWORD *)a6 + 1);
            DEntropy = ZSTD_loadDEntropy(v69, (uint64_t)a6, a7);
            if (DEntropy > 0xFFFFFFFFFFFFFF88)
              return -30;
            v27 = &a6[DEntropy];
            *(_QWORD *)(a1 + 29480) = 0x100000001;
            v31 = *(_QWORD *)(a1 + 29376);
            *(_QWORD *)(a1 + 29400) = v31;
            v29 = &a6[DEntropy + *(_QWORD *)(a1 + 29384) - v31];
            v18 = v73;
          }
        }
        *(_QWORD *)(a1 + 29392) = v29;
        *(_QWORD *)(a1 + 29384) = v27;
        v28 = v58;
        *(_QWORD *)(a1 + 29376) = v58;
      }
    }
    if (a3 && v28 != v18)
    {
      *(_QWORD *)(a1 + 29400) = v28;
      *(_QWORD *)(a1 + 29392) = &v18[v27 - v28];
      *(_QWORD *)(a1 + 29384) = v18;
      *(_QWORD *)(a1 + 29376) = v18;
    }
    v32 = *(_DWORD *)(v16 + 2900);
    v33 = 9;
    if (v32)
      v33 = 5;
    if (v11 < v33)
      return -72;
    if (v32)
      v34 = 1;
    else
      v34 = 5;
    v35 = a4[v34 - 1];
    v36 = (v35 < 0x40) & ((v35 & 0x20) >> 5);
    v37 = ZSTD_did_fieldSize[v35 & 3] + v34 + *(_QWORD *)((char *)&ZSTD_fcs_fieldSize + ((v35 >> 3) & 0x18));
    if ((v35 & 0x20) == 0)
      ++v37;
    v19 = v37 + v36;
    if ((unint64_t)(v37 + v36) <= 0xFFFFFFFFFFFFFF88)
    {
      if (v11 < v19 + 3)
        return -72;
      FrameHeader_advanced = ZSTD_getFrameHeader_advanced((uint64_t)v70, a4, v19, v32);
      if (FrameHeader_advanced <= 0xFFFFFFFFFFFFFF88)
      {
        if (!FrameHeader_advanced)
        {
          if (*(_DWORD *)(v16 + 3020) == 1 && *(_QWORD *)(a1 + 29696))
            ZSTD_DCtx_selectFrameDDict(a1);
          v39 = *(_DWORD *)(v16 + 2760);
          if (v39 && *(_DWORD *)(v16 + 2996) != v39)
            return -32;
          v55 = a7;
          v56 = v14;
          if (*(_DWORD *)(v16 + 2764))
          {
            v40 = *(_DWORD *)(v16 + 2904);
            *(_DWORD *)(v16 + 2908) = v40 == 0;
            v41 = v73;
            if (!v40)
            {
              *(_OWORD *)(a1 + 29488) = xmmword_18823D7B0;
              *(_OWORD *)(a1 + 29504) = xmmword_18823D7C0;
              *(_QWORD *)(a1 + 29520) = 0x61C8864E7A143579;
              *v59 = 0u;
              v59[1] = 0u;
              v59[2] = 0u;
            }
          }
          else
          {
            *(_DWORD *)(v16 + 2908) = 0;
            v41 = v73;
          }
          v54 = a3;
          v71 = &v41[a3];
          *v72 += v19;
          a4 += v19;
          v11 -= v19;
          v42 = v41;
          while (1)
          {
            v44 = v11 - 3;
            if (v11 < 3)
              return -72;
            v45 = *(unsigned __int16 *)a4;
            v46 = v45 | (a4[2] << 16);
            v19 = v46 >> 3;
            v47 = ((unint64_t)*(unsigned __int16 *)a4 >> 1) & 3;
            v48 = v47;
            if ((_DWORD)v47 != 1)
            {
              if ((_DWORD)v47 == 3)
                return -20;
              v48 = v46 >> 3;
            }
            v11 = v44 - v48;
            if (v44 < v48)
              return -72;
            v49 = a4 + 3;
            if ((_DWORD)v47 == 2)
            {
              v19 = ZSTD_decompressBlock_internal(a1, v42, v71 - v42, (uint64_t)v49, v48, 1);
              if (v19 > 0xFFFFFFFFFFFFFF88)
                goto LABEL_105;
              if (!*(_DWORD *)(v16 + 2908))
                goto LABEL_61;
            }
            else if ((_DWORD)v47 == 1)
            {
              if (v71 - v42 < v19)
                return -70;
              if (v42)
              {
                memset(v42, *v49, v46 >> 3);
                if (!*(_DWORD *)(v16 + 2908))
                  goto LABEL_61;
              }
              else
              {
                if (v46 >= 8)
                  return -74;
                v19 = 0;
                if (!*(_DWORD *)(v16 + 2908))
                  goto LABEL_61;
              }
            }
            else
            {
              if (v48 > v71 - v42)
                return -70;
              if (v42)
              {
                memcpy(v42, v49, v48);
                v19 = v48;
                if (!*(_DWORD *)(v16 + 2908))
                  goto LABEL_61;
              }
              else
              {
                if (v48)
                  return -74;
                v19 = 0;
                if (!*(_DWORD *)(v16 + 2908))
                  goto LABEL_61;
              }
            }
            ZSTD_XXH64_update(v74, v42, v19);
LABEL_61:
            v42 += v19;
            a4 = &v49[v48];
            v21 = v75;
            v43 = v73;
            if ((v45 & 1) != 0)
            {
              v19 = v42 - v73;
              if (*v70 != -1 && v19 != *v70)
                return -20;
              if (*(_DWORD *)(v16 + 2764))
              {
                v50 = v11 >= 4;
                v11 -= 4;
                a7 = v55;
                v14 = v56;
                v51 = v54;
                if (!v50)
                  return -22;
                if (!*(_DWORD *)(v16 + 2904))
                {
                  v52 = ZSTD_XXH64_digest((uint64_t *)v74);
                  v43 = v73;
                  v21 = v75;
                  if (*(_DWORD *)a4 != v52)
                    return -22;
                }
                a4 += 4;
              }
              else
              {
                a7 = v55;
                v14 = v56;
                v51 = v54;
              }
              if (v19 >= 0xFFFFFFFFFFFFFF89)
                goto LABEL_105;
              v18 = &v43[v19];
              a3 = v51 - v19;
              v17 = 5;
              if (*(_DWORD *)(v16 + 2900))
                v17 = 1;
              v20 = 1;
              if (v11 >= v17)
                goto LABEL_17;
              goto LABEL_7;
            }
          }
        }
        return -72;
      }
      v19 = FrameHeader_advanced;
    }
LABEL_105:
    if ((((_DWORD)v19 == -10) & v57) == 0)
      return v19;
    return -72;
  }
  v18 = a2;
LABEL_7:
  if (v11)
    return -72;
  else
    return (uint64_t)&v18[-v14];
}

uint64_t ZSTD_decompressDCtx(uint64_t a1, char *a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  _DWORD *v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  void (*v15)(uint64_t, uint64_t);
  uint64_t v16;

  v10 = (_DWORD *)(a1 + 29688);
  v11 = *(_DWORD *)(a1 + 29688);
  if (v11 == -1)
    goto LABEL_4;
  if (v11 != 1)
  {
    v13 = (_QWORD *)(a1 + 29664);
    v14 = *(_QWORD *)(a1 + 29664);
    if (!v14)
    {
LABEL_13:
      v12 = 0;
      *v10 = 0;
      *v13 = 0;
      *(_QWORD *)(a1 + 29672) = 0;
      return ZSTD_decompressMultiFrame(a1, a2, a3, a4, a5, 0, 0, v12);
    }
    v15 = *(void (**)(uint64_t, uint64_t))(v14 + 27336);
    v16 = *(_QWORD *)(v14 + 27344);
    if (*(_QWORD *)v14)
    {
      if (v15)
      {
        ((void (*)(_QWORD))v15)(*(_QWORD *)(v14 + 27344));
LABEL_10:
        v15(v16, v14);
        goto LABEL_13;
      }
      free(*(void **)v14);
    }
    else if (v15)
    {
      goto LABEL_10;
    }
    free((void *)v14);
    goto LABEL_13;
  }
  *v10 = 0;
LABEL_4:
  v12 = *(_QWORD *)(a1 + 29672);
  return ZSTD_decompressMultiFrame(a1, a2, a3, a4, a5, 0, 0, v12);
}

uint64_t ZSTD_decompress_usingDDict(uint64_t a1, char *a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6)
{
  return ZSTD_decompressMultiFrame(a1, a2, a3, a4, a5, 0, 0, a6);
}

uint64_t ZSTD_getDDict(uint64_t a1)
{
  _DWORD *v1;
  int v2;
  uint64_t result;
  _QWORD *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  uint64_t v7;

  v1 = (_DWORD *)(a1 + 29688);
  v2 = *(_DWORD *)(a1 + 29688);
  if (v2 == -1)
    return *(_QWORD *)(a1 + 29672);
  if (v2 == 1)
  {
    *v1 = 0;
    return *(_QWORD *)(a1 + 29672);
  }
  v4 = (_QWORD *)(a1 + 29664);
  v5 = *(_QWORD *)(a1 + 29664);
  if (v5)
  {
    v6 = *(void (**)(uint64_t, uint64_t))(v5 + 27336);
    v7 = *(_QWORD *)(v5 + 27344);
    if (*(_QWORD *)v5)
    {
      if (v6)
      {
        ((void (*)(_QWORD))v6)(*(_QWORD *)(v5 + 27344));
LABEL_10:
        v6(v7, v5);
        goto LABEL_13;
      }
      free(*(void **)v5);
    }
    else if (v6)
    {
      goto LABEL_10;
    }
    free((void *)v5);
  }
LABEL_13:
  result = 0;
  *v1 = 0;
  *v4 = 0;
  v4[1] = 0;
  return result;
}

uint64_t ZSTD_decompress(char *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;

  v8 = (char *)malloc_type_malloc(0x274D0uLL, 0x26AA08A0uLL);
  if (!v8)
    return -64;
  v9 = (uint64_t)v8;
  *((_QWORD *)v8 + 3706) = 0;
  *((_QWORD *)v8 + 3675) = 0;
  *((_QWORD *)v8 + 3719) = 0;
  *((_QWORD *)v8 + 3723) = 0;
  *((_DWORD *)v8 + 7448) = 0;
  *((_QWORD *)v8 + 20121) = 0;
  *((_DWORD *)v8 + 7414) = 0;
  *((_QWORD *)v8 + 3712) = 0;
  *(_OWORD *)(v8 + 29708) = 0u;
  *((_DWORD *)v8 + 7431) = 0;
  *((_QWORD *)v8 + 3701) = 0;
  *((_OWORD *)v8 + 1851) = 0u;
  *((_QWORD *)v8 + 3717) = 134217729;
  *(_QWORD *)(v8 + 29804) = 0;
  *((_QWORD *)v8 + 3698) = 0;
  *((_DWORD *)v8 + 7426) = 0;
  *(_QWORD *)(v8 + 29684) = 0;
  *((_OWORD *)v8 + 1854) = 0u;
  v10 = ZSTD_decompressMultiFrame((uint64_t)v8, a1, a2, a3, a4, 0, 0, 0);
  ZSTD_freeDCtx(v9);
  return v10;
}

uint64_t ZSTD_nextSrcSizeToDecompress(uint64_t a1)
{
  return *(_QWORD *)(a1 + 29408);
}

uint64_t ZSTD_nextInputType(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 29476) - 2;
  if (v1 > 5)
    return 0;
  else
    return dword_18823D69C[v1];
}

size_t ZSTD_decompressContinue(uint64_t a1, char *__b, unint64_t a3, char *__src, size_t __n)
{
  size_t v5;
  unsigned int *v8;
  int v9;
  char *v10;
  int v11;
  size_t v12;
  unint64_t v13;
  size_t result;
  uint64_t v15;
  unint64_t v16;
  unint64_t FrameHeader_advanced;
  int v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;

  v5 = __n;
  v8 = (unsigned int *)(a1 + 29432);
  v9 = *(_DWORD *)(a1 + 29476);
  if ((v9 - 3) >= 2 || *(_DWORD *)(a1 + 29472))
  {
    if (*(_QWORD *)(a1 + 29408) == __n)
      goto LABEL_4;
    return -72;
  }
  if (__n <= 1)
    v12 = 1;
  else
    v12 = __n;
  if (v12 >= *(_QWORD *)(a1 + 29408))
    v12 = *(_QWORD *)(a1 + 29408);
  if (v12 != __n)
    return -72;
LABEL_4:
  if (a3)
  {
    v10 = *(char **)(a1 + 29376);
    if (v10 != __b)
    {
      *(_QWORD *)(a1 + 29400) = v10;
      *(_QWORD *)(a1 + 29392) = &__b[*(_QWORD *)(a1 + 29384) - (_QWORD)v10];
      *(_QWORD *)(a1 + 29384) = __b;
      *(_QWORD *)(a1 + 29376) = __b;
    }
  }
  *(_QWORD *)(a1 + 29456) += __n;
  switch(v9)
  {
    case 0:
      if (*(_DWORD *)(a1 + 29584))
      {
        v15 = 1;
        if (!__n)
        {
LABEL_23:
          *(_QWORD *)(a1 + 29576) = -72;
          return -72;
        }
      }
      else
      {
        if (*(_DWORD *)__src >> 4 == 25481893)
        {
          memcpy((void *)(a1 + 160944), __src, __n);
          *(_QWORD *)(a1 + 29408) = 8 - v5;
          v22 = 6;
          goto LABEL_34;
        }
        v15 = 5;
        if (__n < 5)
          goto LABEL_23;
      }
      v25 = __src[v15 - 1];
      v26 = (v25 < 0x40) & ((v25 & 0x20) >> 5);
      v27 = ZSTD_did_fieldSize[v25 & 3] + v15 + *(_QWORD *)((char *)&ZSTD_fcs_fieldSize + ((v25 >> 3) & 0x18));
      if ((v25 & 0x20) == 0)
        ++v27;
      v13 = v27 + v26;
      *(_QWORD *)(a1 + 29576) = v27 + v26;
      if ((unint64_t)(v27 + v26) > 0xFFFFFFFFFFFFFF88)
        return v13;
      memcpy((void *)(a1 + 160944), __src, __n);
      *(_QWORD *)(a1 + 29408) = v13 - v5;
      v8[11] = 1;
      return 0;
    case 1:
      memcpy((void *)(a1 + 160944 + *(_QWORD *)(a1 + 29576) - __n), __src, __n);
      v16 = *(_QWORD *)(a1 + 29576);
      FrameHeader_advanced = ZSTD_getFrameHeader_advanced(a1 + 29416, (unsigned __int8 *)(a1 + 160944), v16, v8[38]);
      v13 = FrameHeader_advanced;
      if (FrameHeader_advanced > 0xFFFFFFFFFFFFFF88)
        return v13;
      if (FrameHeader_advanced)
        return -72;
      if (v8[68] == 1 && *(_QWORD *)(a1 + 29696))
        ZSTD_DCtx_selectFrameDDict(a1);
      v23 = v8[3];
      if (!v23 || v8[62] == v23)
      {
        if (v8[4])
        {
          v24 = v8[39];
          v8[40] = v24 == 0;
          if (!v24)
          {
            *(_OWORD *)(a1 + 29488) = xmmword_18823D7B0;
            *(_OWORD *)(a1 + 29504) = xmmword_18823D7C0;
            *(_QWORD *)(a1 + 29520) = 0x61C8864E7A143579;
            *(_OWORD *)(a1 + 29528) = 0u;
            *(_OWORD *)(a1 + 29544) = 0u;
            *(_OWORD *)(a1 + 29560) = 0u;
          }
        }
        else
        {
          v8[40] = 0;
        }
        *(_QWORD *)(a1 + 29456) += v16;
        goto LABEL_91;
      }
      return -32;
    case 2:
      v18 = *(unsigned __int16 *)__src;
      v19 = (v18 | (__src[2] << 16)) >> 3;
      v20 = ((unint64_t)*(unsigned __int16 *)__src >> 1) & 3;
      if ((_DWORD)v20 == 1)
      {
        v21 = ((unint64_t)*(unsigned __int16 *)__src >> 1) & 3;
      }
      else
      {
        if ((_DWORD)v20 == 3)
          return -20;
        v21 = (v18 | (__src[2] << 16)) >> 3;
      }
      if (v21 > *v8)
        return -20;
      *(_QWORD *)(a1 + 29408) = v21;
      *(_DWORD *)(a1 + 29472) = v20;
      *(_QWORD *)(a1 + 29640) = v19;
      if (v21)
      {
        if ((v18 & 1) != 0)
          v22 = 4;
        else
          v22 = 3;
      }
      else if ((v18 & 1) != 0)
      {
        if (!*(_DWORD *)(a1 + 29448))
          goto LABEL_32;
        *(_QWORD *)(a1 + 29408) = 4;
        v22 = 5;
      }
      else
      {
LABEL_91:
        *(_QWORD *)(a1 + 29408) = 3;
        v22 = 2;
      }
      goto LABEL_34;
    case 3:
    case 4:
      v11 = *(_DWORD *)(a1 + 29472);
      if (v11)
      {
        if (v11 == 1)
        {
          v5 = *(_QWORD *)(a1 + 29640);
          if (v5 <= a3)
          {
            if (__b)
            {
              memset(__b, *__src, *(_QWORD *)(a1 + 29640));
            }
            else if (v5)
            {
              v5 = -74;
            }
            else
            {
              v5 = 0;
            }
          }
          else
          {
            v5 = -70;
          }
        }
        else
        {
          if (v11 != 2)
            return -20;
          v5 = ZSTD_decompressBlock_internal(a1, __b, a3, (uint64_t)__src, __n, 1);
        }
        v28 = 0;
        *(_QWORD *)(a1 + 29408) = 0;
        v13 = v5;
        if (v5 > 0xFFFFFFFFFFFFFF88)
          return v13;
      }
      else
      {
        if (__n > a3)
          return -70;
        if (__b)
        {
          memcpy(__b, __src, __n);
          if (v5 > 0xFFFFFFFFFFFFFF88)
            goto LABEL_93;
        }
        else if (__n)
        {
          return -74;
        }
        v28 = *(_QWORD *)(a1 + 29408) - v5;
        *(_QWORD *)(a1 + 29408) = v28;
      }
      if (v5 > *v8)
        return -20;
      *(_QWORD *)(a1 + 29464) += v5;
      if (v8[40])
      {
        ZSTD_XXH64_update((unsigned int *)(a1 + 29488), __b, v5);
        v28 = *(_QWORD *)(a1 + 29408);
      }
      *(_QWORD *)(a1 + 29376) = &__b[v5];
      if (!v28)
      {
        if (v8[11] == 4)
        {
          v29 = *(_QWORD *)(a1 + 29416);
          if (v29 != -1 && *(_QWORD *)(a1 + 29464) != v29)
            return -20;
          if (v8[4])
          {
            *(_QWORD *)(a1 + 29408) = 4;
            v8[11] = 5;
          }
          else
          {
            *(_QWORD *)(a1 + 29408) = 0;
            v8[11] = 0;
          }
        }
        else
        {
          v8[11] = 2;
          *(_QWORD *)(a1 + 29408) = 3;
        }
      }
LABEL_93:
      result = v5;
      break;
    case 5:
      if (!*(_DWORD *)(a1 + 29592) || *(_DWORD *)__src == ZSTD_XXH64_digest((uint64_t *)(a1 + 29488)))
        goto LABEL_32;
      return -22;
    case 6:
      memcpy((void *)(a1 - __n + 160952), __src, __n);
      *(_QWORD *)(a1 + 29408) = *(unsigned int *)(a1 + 160948);
      v22 = 7;
LABEL_34:
      v8[11] = v22;
      return 0;
    case 7:
LABEL_32:
      *(_QWORD *)(a1 + 29408) = 0;
      v8[11] = 0;
      return 0;
    default:
      return -1;
  }
  return result;
}

uint64_t ZSTD_getcBlockSize(unsigned __int16 *a1, unint64_t a2, _DWORD *a3)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  if (a2 < 3)
    return -72;
  v4 = *a1;
  v5 = (v4 & 0xFFF8 | (*((unsigned __int8 *)a1 + 2) << 16)) >> 3;
  result = (v4 >> 1) & 3;
  *a3 = result;
  a3[1] = v4 & 1;
  a3[2] = v5;
  if ((_DWORD)result != 1)
  {
    if ((_DWORD)result == 3)
      return -20;
    else
      return v5;
  }
  return result;
}

uint64_t ZSTD_decompressBlock_internal(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  unint64_t v6;
  unint64_t v13;
  int32x2_t *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  int v19;
  unsigned __int8 *v20;
  unint64_t v21;
  __int128 *v22;
  char *v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  int v28;
  char *v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  char *v36;
  size_t v37;
  char *v38;
  uint64_t v39;
  unint64_t v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int16 *v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unsigned __int16 *v75;
  uint64_t v76;
  int v77;
  int v78;
  unint64_t v79;
  unsigned __int16 *v80;
  uint64_t v81;
  unsigned int v82;
  int v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unsigned __int8 v87;
  unint64_t v88;
  unint64_t v89;
  char *v90;
  unint64_t v91;
  int v92;
  int v93;
  uint64_t v94;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  char *v106;
  _QWORD *v107;
  uint64_t v108;
  uint64_t v109;
  unsigned __int16 *v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unsigned __int16 *v115;
  uint64_t v116;
  int v117;
  int v118;
  unint64_t v119;
  unsigned __int16 *v120;
  uint64_t v121;
  unsigned int v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  unsigned int v130;
  unint64_t v131;
  char *v132;
  uint64_t *v133;
  uint64_t v134;
  char v135;
  uint64_t v136;
  int v137;
  unint64_t v138;
  unint64_t *v139;
  unint64_t v140;
  size_t v141;
  unint64_t v142;
  __int128 *v143;
  __int128 *v144;
  char *v145;
  char *v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  const void *v150;
  char *v151;
  __int128 v152;
  unint64_t v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  _QWORD *v163;
  char *v164;
  __int128 *v165;
  __int128 v166;
  uint64_t v167;
  char *v168;
  unint64_t v169;
  uint64_t v170;
  uint64_t v171;
  _OWORD *v172;
  __int128 *v173;
  char *v174;
  uint64_t v175;
  __int128 v176;
  uint64_t v177;
  int v178;
  unint64_t *v179;
  unint64_t v180;
  size_t v181;
  unint64_t v182;
  __int128 *v183;
  __int128 *v184;
  char *v186;
  char *v187;
  uint64_t v188;
  const void *v189;
  char *v190;
  char *v191;
  __int128 v192;
  unint64_t v193;
  uint64_t v194;
  char *v195;
  __int128 *v196;
  __int128 v197;
  uint64_t v198;
  char *v199;
  char *v200;
  __int128 *v201;
  char *v202;
  uint64_t v203;
  __int128 v204;
  int v205;
  size_t v206;
  char *v207;
  char *v208;
  int v209;
  char *v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  unint64_t v214;
  int32x2_t *v215;
  char *v216;
  unint64_t v217;
  unint64_t v218;
  int v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  uint64_t v225;
  _BYTE v226[24];
  char *v227;
  unint64_t v228;
  char *v229;
  __int128 *v230;
  unint64_t v231;
  size_t v232;
  unint64_t v233;
  unint64_t v234;
  _BYTE v235[16];
  _QWORD v236[17];

  v236[14] = *MEMORY[0x1E0C80C00];
  if (a5 >> 17)
    return -72;
  v13 = ZSTD_decodeLiteralsBlock(a1, a4, a5);
  v6 = v13;
  if (v13 <= 0xFFFFFFFFFFFFFF88)
  {
    v14 = (int32x2_t *)(a1 + 26684);
    v15 = (unsigned __int8 *)(a4 + v13);
    v16 = a5 - v13;
    v17 = *(_DWORD *)(a1 + 29684);
    v219 = 0;
    v18 = ZSTD_decodeSeqHeaders(a1, &v219, v15, v16);
    v6 = v18;
    if (v18 <= 0xFFFFFFFFFFFFFF88)
    {
      v19 = v219;
      if (!a2 && v219 > 0)
        return -70;
      v20 = &v15[v18];
      v21 = v16 - v18;
      if (v17)
      {
        *(_DWORD *)(a1 + 29684) = 0;
        goto LABEL_10;
      }
      if (a6)
      {
        if (*(_QWORD *)(a1 + 29424) >= 0x1000001uLL && v219 > 4)
          goto LABEL_19;
      }
      else if (v219 >= 5)
      {
LABEL_19:
        v30 = 0;
        v31 = *(_QWORD *)(a1 + 16);
        v32 = *(_DWORD *)(v31 + 4);
        v33 = v31 + 8;
        v34 = 1;
        do
        {
          if (*(unsigned __int8 *)(v33 + 8 * (v34 - 1) + 2) > 0x16u)
            ++v30;
        }
        while (!(v34++ >> v32));
        *(_DWORD *)(a1 + 29684) = 0;
        if ((v30 << (8 - v32)) >= 7)
        {
LABEL_10:
          v22 = *(__int128 **)(a1 + 29600);
          v230 = v22;
          v218 = (unint64_t)v22 + *(_QWORD *)(a1 + 29632);
          if (!v19)
          {
            v36 = a2;
            v37 = v218 - (_QWORD)v22;
            if (v218 - (unint64_t)v22 <= a3)
              goto LABEL_26;
            return -70;
          }
          v23 = *(char **)(a1 + 29384);
          v211 = *(_QWORD *)(a1 + 29392);
          v24 = *(_QWORD *)(a1 + 29400);
          v223 = 0u;
          v224 = 0u;
          v221 = 0u;
          v222 = 0u;
          v220 = 0u;
          *(_DWORD *)(a1 + 29484) = 1;
          v25 = v14->u32[0];
          v225 = 0;
          *(_QWORD *)v226 = v25;
          v26 = *(_QWORD *)(a1 + 26688);
          *(_QWORD *)&v27 = v26;
          *((_QWORD *)&v27 + 1) = HIDWORD(v26);
          *(_OWORD *)&v226[8] = v27;
          if (v19 >= 4)
            v28 = 4;
          else
            v28 = v19;
          v29 = (char *)(a2 - v23);
          v229 = (char *)(a2 - v23);
          v227 = v23;
          v228 = v24;
          v217 = v24;
          if (v16 == v6)
            return -20;
          *((_QWORD *)&v221 + 1) = v20;
          *(_QWORD *)&v222 = v20 + 8;
          v39 = v21 - 8;
          if (v21 < 8)
          {
            v40 = *v20;
            *(_QWORD *)&v221 = v20;
            *(_QWORD *)&v220 = v40;
            switch(v21)
            {
              case 2uLL:
                goto LABEL_41;
              case 3uLL:
                goto LABEL_40;
              case 4uLL:
                goto LABEL_39;
              case 5uLL:
                goto LABEL_38;
              case 6uLL:
                goto LABEL_37;
              case 7uLL:
                v40 |= (unint64_t)v20[6] << 48;
LABEL_37:
                v40 += (unint64_t)v20[5] << 40;
LABEL_38:
                v40 += (unint64_t)v20[4] << 32;
LABEL_39:
                v40 += (unint64_t)v20[3] << 24;
LABEL_40:
                v40 += (unint64_t)v20[2] << 16;
LABEL_41:
                v40 += (unint64_t)v20[1] << 8;
                *(_QWORD *)&v220 = v40;
                break;
              default:
                break;
            }
            if (!v20[v21 - 1])
              return -20;
            v39 = 0;
            v41 = __clz(v20[v21 - 1]) - 8 * v21 + 41;
            DWORD2(v220) = v41;
          }
          else
          {
            v40 = *(_QWORD *)&v20[v39];
            *(_QWORD *)&v221 = &v20[v39];
            *(_QWORD *)&v220 = v40;
            if (!HIBYTE(v40) || v21 > 0xFFFFFFFFFFFFFF88)
              return -20;
            v41 = __clz(HIBYTE(v40)) - 23;
          }
          v42 = *(_QWORD *)a1;
          v43 = *(unsigned int *)(*(_QWORD *)a1 + 4);
          v44 = v43 + v41;
          v45 = (v40 >> -(char)v44) & BIT_mask[v43];
          *((_QWORD *)&v222 + 1) = v45;
          if (v44 <= 0x40)
          {
            if (v39 >= 8)
            {
              v39 -= v44 >> 3;
              *(_QWORD *)&v221 = &v20[v39];
              v44 &= 7u;
            }
            else
            {
              if (!v39)
                goto LABEL_56;
              v46 = v44 >> 3;
              if (&v20[v39 - v46] >= v20)
                v47 = v46;
              else
                v47 = v39;
              v39 -= v47;
              *(_QWORD *)&v221 = &v20[v39];
              v44 -= 8 * v47;
            }
            v40 = *(_QWORD *)&v20[v39];
            *(_QWORD *)&v220 = v40;
          }
LABEL_56:
          v213 = v42 + 8;
          *(_QWORD *)&v223 = v42 + 8;
          v49 = *(_QWORD *)(a1 + 16);
          v50 = *(unsigned int *)(v49 + 4);
          v51 = v50 + v44;
          v52 = (v40 >> -(char)(v50 + v44)) & BIT_mask[v50];
          *((_QWORD *)&v223 + 1) = v52;
          v210 = &a2[a3];
          v205 = v28;
          if (v50 + v44 <= 0x40)
          {
            if (v39 >= 8)
            {
              v39 -= v51 >> 3;
              *(_QWORD *)&v221 = &v20[v39];
              v51 &= 7u;
LABEL_64:
              v40 = *(_QWORD *)&v20[v39];
              *(_QWORD *)&v220 = v40;
              goto LABEL_65;
            }
            if (v39)
            {
              v53 = v51 >> 3;
              if (&v20[v39 - v53] >= v20)
                v54 = v53;
              else
                v54 = v39;
              v39 -= v54;
              *(_QWORD *)&v221 = &v20[v39];
              v51 -= 8 * v54;
              goto LABEL_64;
            }
          }
LABEL_65:
          v55 = v49 + 8;
          *(_QWORD *)&v224 = v49 + 8;
          v56 = *(_QWORD *)(a1 + 8);
          v57 = *(unsigned int *)(v56 + 4);
          v58 = v57 + v51;
          v59 = (v40 >> -(char)(v57 + v51)) & BIT_mask[v57];
          DWORD2(v220) = v57 + v51;
          *((_QWORD *)&v224 + 1) = v59;
          v215 = (int32x2_t *)(a1 + 26684);
          v216 = v23;
          v209 = v19;
          v207 = a2;
          if (v57 + v51 >= 0x41)
          {
            LODWORD(v60) = 0;
            v225 = v56 + 8;
            goto LABEL_124;
          }
          if (v39 >= 8)
          {
            v39 -= v58 >> 3;
            v58 &= 7u;
            DWORD2(v220) = v58;
            v40 = *(_QWORD *)&v20[v39];
            *(_QWORD *)&v220 = v40;
            *(_QWORD *)&v221 = &v20[v39];
            v225 = v56 + 8;
          }
          else if (v39)
          {
            v61 = v58 >> 3;
            if (&v20[v39 - v61] >= v20)
              v62 = v61;
            else
              v62 = v39;
            v39 -= v62;
            v58 -= 8 * v62;
            DWORD2(v220) = v58;
            v40 = *(_QWORD *)&v20[v39];
            *(_QWORD *)&v220 = v40;
            *(_QWORD *)&v221 = &v20[v39];
            v225 = v56 + 8;
            if (v58 > 0x40)
            {
              LODWORD(v60) = 0;
              goto LABEL_124;
            }
          }
          else
          {
            v225 = v56 + 8;
          }
          v63 = 0;
          v60 = v28 & ~(v28 >> 31);
          v64 = v56 + 8;
          v65 = v26;
          v66 = v236;
          while (1)
          {
            if (v39 >= 8)
            {
              v39 -= v58 >> 3;
              *(_QWORD *)&v221 = &v20[v39];
              v58 &= 7u;
              DWORD2(v220) = v58;
              v40 = *(_QWORD *)&v20[v39];
            }
            else
            {
              if (!v39)
                goto LABEL_85;
              v67 = v58 >> 3;
              if (&v20[v39 - v67] >= v20)
                v68 = v67;
              else
                v68 = v39;
              v39 -= v68;
              *(_QWORD *)&v221 = &v20[v39];
              v58 -= 8 * v68;
              DWORD2(v220) = v58;
              v40 = *(_QWORD *)&v20[v39];
            }
            *(_QWORD *)&v220 = v40;
LABEL_85:
            if (v60 == v63)
            {
              v105 = (uint64_t)v210;
              v23 = v216;
              v106 = v210 - 32;
              v36 = a2;
              v208 = v210 - 32;
              if (v58 < 0x41)
                goto LABEL_126;
              goto LABEL_203;
            }
            v69 = v60;
            v70 = (unsigned __int16 *)(v213 + 8 * v45);
            v71 = *v70;
            v72 = *((unsigned __int8 *)v70 + 2);
            v73 = *((unsigned __int8 *)v70 + 3);
            v74 = *((unsigned int *)v70 + 1);
            v75 = (unsigned __int16 *)(v64 + 8 * v59);
            v76 = *v75;
            v77 = *((unsigned __int8 *)v75 + 2);
            v78 = *((unsigned __int8 *)v75 + 3);
            v79 = *((unsigned int *)v75 + 1);
            v80 = (unsigned __int16 *)(v55 + 8 * v52);
            v81 = *v80;
            v82 = *((unsigned __int8 *)v80 + 2);
            v83 = *((unsigned __int8 *)v80 + 3);
            v84 = *((unsigned int *)v80 + 1);
            if (v82 >= 2)
            {
              v85 = v40 << v58 >> -(char)v82;
              v14 = v215;
              v58 += v82;
              v86 = v85 + v84;
              goto LABEL_88;
            }
            if (v82)
            {
              if ((_DWORD)v74)
                v84 = v84;
              else
                v84 = (v84 + 1);
              v103 = v40 << v58++;
              v104 = v84 + (v103 >> 63);
              if (v104 == 3)
              {
                v86 = v25 - 1;
                if (v25 == 1)
                  v86 = 1;
                v14 = v215;
                v19 = v209;
                a2 = v207;
                goto LABEL_88;
              }
              v86 = *(_QWORD *)&v226[8 * v104];
              if (!v86)
                v86 = 1;
              v14 = v215;
              v19 = v209;
              a2 = v207;
              if (v104 != 1)
LABEL_88:
                *(_QWORD *)&v226[16] = v65;
LABEL_89:
              *(_QWORD *)v226 = v86;
              *(_QWORD *)&v226[8] = v25;
              v65 = v25;
              v25 = v86;
              goto LABEL_92;
            }
            v86 = v65;
            if (!(_DWORD)v74)
              goto LABEL_89;
LABEL_92:
            v87 = v77 + v72 + v82;
            v88 = (v40 << v58 >> -(char)v77) + v79;
            if (v77)
            {
              v58 += v77;
              v79 = v88;
            }
            if (v87 < 0x1Fu)
              goto LABEL_95;
            if (v58 <= 0x40)
            {
              if (v39 >= 8)
              {
                v39 -= v58 >> 3;
                v40 = *(_QWORD *)&v20[v39];
                v58 &= 7u;
                *(_QWORD *)&v221 = &v20[v39];
LABEL_116:
                *(_QWORD *)&v220 = v40;
                goto LABEL_117;
              }
              if (v39)
              {
                v102 = v58 >> 3;
                if (&v20[v39 - v102] >= v20)
                  v102 = v102;
                else
                  v102 = v39;
                v39 -= v102;
                v40 = *(_QWORD *)&v20[v39];
                v58 -= 8 * v102;
                *(_QWORD *)&v221 = &v20[v39];
                goto LABEL_116;
              }
            }
LABEL_117:
            v14 = v215;
            v19 = v209;
            a2 = v207;
LABEL_95:
            v89 = (v40 << v58 >> -(char)v72) + v74;
            if (v72)
            {
              v58 += v72;
              v74 = v89;
            }
            v90 = &v29[v74];
            v91 = v217;
            if (v25 <= (unint64_t)&v29[v74])
              v91 = (unint64_t)v216;
            v29 = &v90[v79];
            v229 = &v90[v79];
            v92 = v58 + v73;
            v45 = ((v40 >> -(char)v92) & BIT_mask[v73]) + v71;
            v93 = v92 + v78;
            v59 = ((v40 >> -(char)v93) & BIT_mask[v78]) + v76;
            *((_QWORD *)&v224 + 1) = v59;
            v58 = v93 + v83;
            v94 = BIT_mask[v83];
            DWORD2(v220) = v58;
            v52 = ((v40 >> -(char)v58) & v94) + v81;
            *((_QWORD *)&v222 + 1) = v45;
            *((_QWORD *)&v223 + 1) = v52;
            *(v66 - 2) = v74;
            *(v66 - 1) = v79;
            _X5 = (unint64_t)&v90[v91 - v25];
            *v66 = v25;
            v66[1] = _X5;
            v66 += 4;
            __asm { PRFM            #0, [X5] }
            _X5 = _X5 + v79;
            __asm { PRFUM           #0, [X5,#-1] }
            ++v63;
            v60 = v69;
            if (v58 > 0x40)
            {
              LODWORD(v60) = v63;
              v23 = v216;
LABEL_124:
              v105 = (uint64_t)v210;
              if ((int)v60 < v28)
                return -20;
              v106 = v210 - 32;
              v36 = a2;
              v208 = v210 - 32;
              if (v58 < 0x41)
              {
LABEL_126:
                while (2)
                {
                  v107 = (_QWORD *)v221;
                  if ((unint64_t)v221 >= (unint64_t)v222)
                  {
                    v107 = (_QWORD *)(v221 - (v58 >> 3));
                    *(_QWORD *)&v221 = v107;
                    v58 &= 7u;
                    goto LABEL_133;
                  }
                  if ((_QWORD)v221 != *((_QWORD *)&v221 + 1))
                  {
                    v108 = v58 >> 3;
                    if ((unint64_t)(v221 - v108) >= *((_QWORD *)&v221 + 1))
                      v109 = v108;
                    else
                      v109 = (v221 - DWORD2(v221));
                    v107 = (_QWORD *)(v221 - v109);
                    *(_QWORD *)&v221 = v221 - v109;
                    v58 -= 8 * v109;
LABEL_133:
                    DWORD2(v220) = v58;
                    *(_QWORD *)&v220 = *v107;
                  }
                  if ((int)v60 >= v19)
                    goto LABEL_204;
                  v110 = (unsigned __int16 *)(v223 + 8 * *((_QWORD *)&v222 + 1));
                  v111 = *v110;
                  v112 = *((unsigned __int8 *)v110 + 2);
                  v113 = *((unsigned __int8 *)v110 + 3);
                  v114 = *((unsigned int *)v110 + 1);
                  v115 = (unsigned __int16 *)(v225 + 8 * *((_QWORD *)&v224 + 1));
                  v116 = *v115;
                  v117 = *((unsigned __int8 *)v115 + 2);
                  v118 = *((unsigned __int8 *)v115 + 3);
                  v119 = *((unsigned int *)v115 + 1);
                  v120 = (unsigned __int16 *)(v224 + 8 * *((_QWORD *)&v223 + 1));
                  v121 = *v120;
                  v122 = *((unsigned __int8 *)v120 + 2);
                  v123 = *((unsigned __int8 *)v120 + 3);
                  v124 = *((unsigned int *)v120 + 1);
                  if (v122 >= 2)
                  {
                    v125 = (_QWORD)v220 << v58 >> -(char)v122;
                    v23 = v216;
                    v58 += v122;
                    v126 = v125 + v124;
                    *(_OWORD *)&v226[8] = *(_OWORD *)v226;
                    *(_QWORD *)v226 = v125 + v124;
                    goto LABEL_140;
                  }
                  if (!v122)
                  {
                    if ((_DWORD)v114)
                    {
                      v126 = *(_QWORD *)v226;
                    }
                    else
                    {
                      v126 = *(_QWORD *)&v226[8];
                      v171 = *(_QWORD *)v226;
                      *(_QWORD *)v226 = *(_QWORD *)&v226[8];
                      *(_QWORD *)&v226[8] = v171;
                    }
LABEL_140:
                    if (v117)
                    {
                      v127 = (_QWORD)v220 << v58 >> -(char)v117;
                      v58 += v117;
                      v119 += v127;
                    }
                    if ((v117 + v112 + v122) < 0x1Fu)
                    {
LABEL_143:
                      v128 = ((_QWORD)v220 << v58 >> -(char)v112) + v114;
                      _ZF = v112 == 0;
                      if (v112)
                        v130 = v58 + v112;
                      else
                        v130 = v58;
                      if (_ZF)
                        v131 = v114;
                      else
                        v131 = v128;
                      v132 = &v229[v131];
                      v133 = (uint64_t *)&v228;
                      v212 = v126;
                      if (v126 <= (unint64_t)&v229[v131])
                        v133 = (uint64_t *)&v227;
                      v134 = *v133;
                      v214 = v119;
                      v229 = &v132[v119];
                      v135 = v130 + v113;
                      v136 = (((unint64_t)v220 >> -(char)(v130 + v113)) & BIT_mask[v113]) + v111;
                      v137 = v130 + v113 + v118;
                      *((_QWORD *)&v224 + 1) = (((unint64_t)v220 >> -(char)(v135 + v118)) & BIT_mask[v118])
                                             + v116;
                      v138 = ((unint64_t)v220 >> -(char)(v137 + v123)) & BIT_mask[v123];
                      DWORD2(v220) = v137 + v123;
                      *((_QWORD *)&v222 + 1) = v136;
                      *((_QWORD *)&v223 + 1) = v138 + v121;
                      v139 = (unint64_t *)&v235[32 * (v60 & 3)];
                      v140 = *v139;
                      v141 = v139[1];
                      v142 = v139[2];
                      v143 = v230;
                      v144 = (__int128 *)((char *)v230 + *v139);
                      if ((unint64_t)v144 > v218 || (v6 = v141 + v140, &v36[v141 + v140] > v106))
                      {
                        v157 = v139[3];
                        v231 = *v139;
                        v232 = v141;
                        v233 = v142;
                        v234 = v157;
                        v158 = v134;
                        v159 = v131;
                        v160 = ZSTD_execSequenceEnd(v36, v105, (uint64_t *)&v231, &v230, v218, v216, v211, v217);
                        v134 = v158;
                        v14 = v215;
                        v23 = v216;
                        v105 = (uint64_t)v210;
                        v19 = v209;
                        v6 = v160;
                        v131 = v159;
                        a2 = v207;
                        v106 = v208;
                      }
                      else
                      {
                        v145 = &v36[v140];
                        *(_OWORD *)v36 = *v230;
                        if (v140 > 0x10)
                        {
                          v164 = v36 + 16;
                          v165 = v143 + 1;
                          do
                          {
                            v166 = *v165++;
                            *(_OWORD *)v164 = v166;
                            v164 += 16;
                          }
                          while (v164 < v145);
                        }
                        v146 = &v145[-v142];
                        v230 = v144;
                        if (v142 <= v145 - v23)
                        {
LABEL_158:
                          if (v142 < 0x10)
                          {
                            if (v142 > 7)
                            {
                              *(_QWORD *)v145 = *(_QWORD *)v146;
                            }
                            else
                            {
                              v167 = ZSTD_overlapCopy8_dec64table[v142];
                              *v145 = *v146;
                              v145[1] = v146[1];
                              v145[2] = v146[2];
                              v145[3] = v146[3];
                              v168 = &v146[ZSTD_overlapCopy8_dec32table[v142]];
                              *((_DWORD *)v145 + 1) = *(_DWORD *)v168;
                              v146 = &v168[-v167];
                            }
                            if (v141 >= 9)
                            {
                              v172 = v145 + 8;
                              v173 = (__int128 *)(v146 + 8);
                              v174 = &v145[v141];
                              if (v145 + 8 - (char *)v173 >= 16)
                              {
                                do
                                {
                                  v176 = *v173++;
                                  *v172++ = v176;
                                }
                                while (v172 < (_OWORD *)v174);
                              }
                              else
                              {
                                do
                                {
                                  v175 = *(_QWORD *)v173;
                                  v173 = (__int128 *)((char *)v173 + 8);
                                  *(_QWORD *)v172 = v175;
                                  v172 = (_OWORD *)((char *)v172 + 8);
                                }
                                while (v172 < (_OWORD *)v174);
                              }
                            }
                            v14 = v215;
                            v23 = v216;
                            v19 = v209;
                            v105 = (uint64_t)v210;
                            a2 = v207;
                            v106 = v208;
                          }
                          else
                          {
                            v151 = &v145[v141];
                            do
                            {
                              v152 = *(_OWORD *)v146;
                              v146 += 16;
                              *(_OWORD *)v145 = v152;
                              v145 += 16;
                            }
                            while (v145 < v151);
                            v14 = v215;
                          }
                        }
                        else
                        {
                          if (v142 > (unint64_t)&v145[-v211])
                            return -20;
                          v147 = v134;
                          v148 = v131;
                          v149 = v146 - v23;
                          v150 = (const void *)(v217 + v146 - v23);
                          if ((unint64_t)v150 + v141 > v217)
                          {
                            v206 = v141;
                            memmove(v145, v150, v23 - v146);
                            v145 -= v149;
                            v141 = v149 + v206;
                            v23 = v216;
                            v146 = v216;
                            v19 = v209;
                            v105 = (uint64_t)v210;
                            v131 = v148;
                            a2 = v207;
                            v106 = v208;
                            v134 = v147;
                            goto LABEL_158;
                          }
                          memmove(v145, v150, v141);
                          v23 = v216;
                          v19 = v209;
                          v105 = (uint64_t)v210;
                          v131 = v148;
                          a2 = v207;
                          v106 = v208;
                          v134 = v147;
                          v14 = v215;
                        }
                      }
                      if (v6 > 0xFFFFFFFFFFFFFF88)
                        return v6;
                      _X8 = (unint64_t)&v132[v134 - v212];
                      __asm { PRFM            #0, [X8] }
                      _X9 = _X8 + v214;
                      __asm { PRFUM           #0, [X9,#-1] }
                      *v139 = v131;
                      v139[1] = v214;
                      v139[2] = v212;
                      v139[3] = _X8;
                      v36 += v6;
                      LODWORD(v60) = v60 + 1;
                      v58 = DWORD2(v220);
                      if (DWORD2(v220) >= 0x41)
                        goto LABEL_203;
                      continue;
                    }
                    if (v58 <= 0x40)
                    {
                      if ((unint64_t)v107 >= (unint64_t)v222)
                      {
                        v163 = (_QWORD *)((char *)v107 - (v58 >> 3));
                        *(_QWORD *)&v221 = v163;
                        v58 &= 7u;
                        goto LABEL_195;
                      }
                      if (v107 != *((_QWORD **)&v221 + 1))
                      {
                        v161 = v58 >> 3;
                        if ((unint64_t)v107 - v161 >= *((_QWORD *)&v221 + 1))
                          v162 = v161;
                        else
                          v162 = ((_DWORD)v107 - DWORD2(v221));
                        v163 = (_QWORD *)((char *)v107 - v162);
                        *(_QWORD *)&v221 = v163;
                        v58 -= 8 * v162;
LABEL_195:
                        *(_QWORD *)&v220 = *v163;
                      }
                    }
                    v19 = v209;
                    v105 = (uint64_t)v210;
                    v23 = v216;
                    a2 = v207;
                    v106 = v208;
                    goto LABEL_143;
                  }
                  break;
                }
                if ((_DWORD)v114)
                  v124 = v124;
                else
                  v124 = (v124 + 1);
                v169 = (_QWORD)v220 << v58++;
                DWORD2(v220) = v58;
                v170 = v124 + (v169 >> 63);
                if (v170 == 3)
                {
                  if (*(_QWORD *)v226 == 1)
                    v126 = 1;
                  else
                    v126 = *(_QWORD *)v226 - 1;
                  goto LABEL_201;
                }
                if (*(_QWORD *)&v226[8 * v170])
                  v126 = *(_QWORD *)&v226[8 * v170];
                else
                  v126 = 1;
                if (v170 != 1)
LABEL_201:
                  *(_QWORD *)&v226[16] = *(_QWORD *)&v226[8];
                v177 = *(_QWORD *)v226;
                *(_QWORD *)v226 = v126;
                *(_QWORD *)&v226[8] = v177;
                v19 = v209;
                v105 = (uint64_t)v210;
                v23 = v216;
                a2 = v207;
                v106 = v208;
                goto LABEL_140;
              }
LABEL_203:
              if ((int)v60 >= v19)
              {
LABEL_204:
                v178 = v60 - v205;
                if ((int)v60 - v205 < v19)
                {
                  do
                  {
                    v179 = (unint64_t *)&v235[32 * (v178 & 3)];
                    v180 = *v179;
                    v181 = v179[1];
                    v182 = v179[2];
                    v6 = v181 + *v179;
                    v183 = v230;
                    v184 = (__int128 *)((char *)v230 + *v179);
                    if ((unint64_t)v184 > v218 || &v36[v6] > v106)
                    {
                      v193 = v179[3];
                      v231 = *v179;
                      v232 = v181;
                      v233 = v182;
                      v234 = v193;
                      v194 = ZSTD_execSequenceEnd(v36, v105, (uint64_t *)&v231, &v230, v218, v216, v211, v217);
                      v106 = v208;
                      v14 = v215;
                      v23 = v216;
                      v105 = (uint64_t)v210;
                      v19 = v209;
                      v6 = v194;
                    }
                    else
                    {
                      v186 = &v36[v180];
                      *(_OWORD *)v36 = *v230;
                      if (v180 > 0x10)
                      {
                        v195 = v36 + 16;
                        v196 = v183 + 1;
                        do
                        {
                          v197 = *v196++;
                          *(_OWORD *)v195 = v197;
                          v195 += 16;
                        }
                        while (v195 < v186);
                      }
                      v187 = &v186[-v182];
                      v230 = v184;
                      if (v182 <= v186 - v23)
                        goto LABEL_214;
                      if (v182 > (unint64_t)&v186[-v211])
                        return -20;
                      v188 = v187 - v23;
                      v189 = (const void *)(v217 + v187 - v23);
                      v190 = v23;
                      if ((unint64_t)v189 + v181 > v217)
                      {
                        memmove(v186, v189, v23 - v187);
                        v186 -= v188;
                        v181 += v188;
                        v187 = v190;
                        v19 = v209;
                        v105 = (uint64_t)v210;
                        v23 = v190;
                        v106 = v208;
LABEL_214:
                        if (v182 < 0x10)
                        {
                          if (v182 > 7)
                          {
                            *(_QWORD *)v186 = *(_QWORD *)v187;
                          }
                          else
                          {
                            v198 = ZSTD_overlapCopy8_dec64table[v182];
                            *v186 = *v187;
                            v186[1] = v187[1];
                            v186[2] = v187[2];
                            v186[3] = v187[3];
                            v199 = &v187[ZSTD_overlapCopy8_dec32table[v182]];
                            *((_DWORD *)v186 + 1) = *(_DWORD *)v199;
                            v187 = &v199[-v198];
                          }
                          if (v181 >= 9)
                          {
                            v200 = v186 + 8;
                            v201 = (__int128 *)(v187 + 8);
                            v202 = &v186[v181];
                            if (v186 + 8 - (char *)v201 >= 16)
                            {
                              do
                              {
                                v204 = *v201++;
                                *(_OWORD *)v200 = v204;
                                v200 += 16;
                              }
                              while (v200 < v202);
                            }
                            else
                            {
                              do
                              {
                                v203 = *(_QWORD *)v201;
                                v201 = (__int128 *)((char *)v201 + 8);
                                *(_QWORD *)v200 = v203;
                                v200 += 8;
                              }
                              while (v200 < v202);
                            }
                          }
                          v14 = v215;
                          v23 = v216;
                          v19 = v209;
                          v105 = (uint64_t)v210;
                          a2 = v207;
                          v106 = v208;
                        }
                        else
                        {
                          v191 = &v186[v181];
                          do
                          {
                            v192 = *(_OWORD *)v187;
                            v187 += 16;
                            *(_OWORD *)v186 = v192;
                            v186 += 16;
                          }
                          while (v186 < v191);
                          v14 = v215;
                        }
                        goto LABEL_219;
                      }
                      memmove(v186, v189, v181);
                      v14 = v215;
                      v19 = v209;
                      v105 = (uint64_t)v210;
                      v23 = v190;
                      v106 = v208;
                    }
LABEL_219:
                    if (v6 > 0xFFFFFFFFFFFFFF88)
                      return v6;
                    v36 += v6;
                    ++v178;
                  }
                  while (v178 != v19);
                }
                *v14 = vmovn_s64(*(int64x2_t *)v226);
                v14[1].i32[0] = *(_DWORD *)&v226[16];
                v22 = v230;
                v37 = v218 - (_QWORD)v230;
                if (v218 - (unint64_t)v230 <= v105 - (uint64_t)v36)
                {
LABEL_26:
                  if (v36)
                  {
                    memcpy(v36, v22, v37);
                    v38 = &v36[v37];
                  }
                  else
                  {
                    v38 = 0;
                  }
                  return v38 - a2;
                }
                return -70;
              }
              return -20;
            }
          }
        }
        return ZSTD_decompressSequences((uint64_t *)a1, a2, a3, v20, v21, v19);
      }
      *(_DWORD *)(a1 + 29684) = 0;
      return ZSTD_decompressSequences((uint64_t *)a1, a2, a3, v20, v21, v19);
    }
  }
  return v6;
}

uint64_t ZSTD_loadDEntropy(int *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  unint64_t DTableX2_wksp;
  unint64_t v8;
  _DWORD *v9;
  unint64_t v10;
  unint64_t v11;
  _DWORD *v12;
  unint64_t v13;
  unint64_t v14;
  _DWORD *v15;
  unint64_t v16;
  unint64_t v17;
  unsigned int *v18;
  unint64_t v19;
  uint64_t result;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  unsigned int v26;
  _BYTE v27[106];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a3 < 9)
    return -30;
  v6 = a2 + 8;
  DTableX2_wksp = HUF_readDTableX2_wksp(a1 + 2566, (char *)(a2 + 8), a3 - 8, (uint64_t)a1, 0x2818uLL);
  if (DTableX2_wksp > 0xFFFFFFFFFFFFFF88)
    return -30;
  v8 = a2 + a3;
  v9 = (_DWORD *)(v6 + DTableX2_wksp);
  v25 = 0;
  v26 = 31;
  v10 = FSE_readNCount_bmi2(v27, &v26, &v25, v9, a2 + a3 - (_QWORD)v9);
  if (v10 > 0xFFFFFFFFFFFFFF88)
    return -30;
  if (v26 > 0x1F)
    return -30;
  if (v25 >= 9)
    return -30;
  v11 = v10;
  ZSTD_buildFSETable(a1 + 1026, (uint64_t)v27, v26, (uint64_t)&OF_base, (uint64_t)&OF_bits, v25, (uint64_t)(a1 + 6666));
  v12 = (_DWORD *)((char *)v9 + v11);
  v25 = 0;
  v26 = 52;
  v13 = FSE_readNCount_bmi2(v27, &v26, &v25, v12, v8 - (_QWORD)v12);
  if (v13 > 0xFFFFFFFFFFFFFF88)
    return -30;
  if (v26 > 0x34)
    return -30;
  if (v25 >= 0xA)
    return -30;
  v14 = v13;
  ZSTD_buildFSETable(a1 + 1540, (uint64_t)v27, v26, (uint64_t)&ML_base, (uint64_t)ML_bits, v25, (uint64_t)(a1 + 6666));
  v15 = (_DWORD *)((char *)v12 + v14);
  v25 = 0;
  v26 = 35;
  v16 = FSE_readNCount_bmi2(v27, &v26, &v25, v15, v8 - (_QWORD)v15);
  if (v16 > 0xFFFFFFFFFFFFFF88)
    return -30;
  if (v26 > 0x23)
    return -30;
  if (v25 >= 0xA)
    return -30;
  v17 = v16;
  ZSTD_buildFSETable(a1, (uint64_t)v27, v26, (uint64_t)&LL_base, (uint64_t)LL_bits, v25, (uint64_t)(a1 + 6666));
  v18 = (_DWORD *)((char *)v15 + v17);
  v19 = (unint64_t)v15 + v17 + 12;
  if (v19 > v8)
    return -30;
  v21 = *v18;
  result = -30;
  if ((_DWORD)v21)
  {
    v22 = v8 - v19;
    if (v8 - v19 >= v21)
    {
      a1[6663] = v21;
      v23 = v18[1];
      if ((_DWORD)v23)
      {
        if (v22 >= v23)
        {
          a1[6664] = v23;
          v24 = v18[2];
          if ((_DWORD)v24)
          {
            if (v22 >= v24)
            {
              a1[6665] = v24;
              return v19 - a2;
            }
          }
        }
      }
    }
  }
  return result;
}

int *ZSTD_buildFSETable(int *result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  int v16;
  _DWORD *v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  int64x2_t v28;
  int64x2_t *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  int i;
  unint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  char v42;

  v7 = result + 2;
  v8 = (1 << a6);
  v9 = (v8 - 1);
  v10 = (a3 + 1);
  if (a3 != -1)
  {
    v12 = 0;
    v13 = a7 + 106;
    v14 = 1;
    v15 = v8 - 1;
    do
    {
      while (1)
      {
        v16 = *(__int16 *)(a2 + 2 * v12);
        if (v16 != -1)
          break;
        v17 = &v7[2 * v15--];
        v17[1] = v12;
        *(_WORD *)(a7 + 2 * v12++) = 1;
        if (v10 == v12)
          goto LABEL_9;
      }
      if (0x10000 << (a6 - 1) >> 16 <= v16)
        v14 = 0;
      *(_WORD *)(a7 + 2 * v12++) = v16;
    }
    while (v10 != v12);
LABEL_9:
    *result = v14;
    result[1] = a6;
    v18 = v8 >> 3;
    if (v15 != (_DWORD)v9)
    {
      v31 = 0;
      v32 = 0;
      v33 = v18 + (v8 >> 1) + 3;
      do
      {
        v34 = *(__int16 *)(a2 + 2 * v31);
        if (v34 >= 1)
        {
          for (i = 0; i != v34; ++i)
          {
            v7[2 * v32 + 1] = v31;
            do
              v32 = (v33 + v32) & v9;
            while (v32 > v15);
          }
        }
        ++v31;
      }
      while (v31 != v10);
      goto LABEL_34;
    }
    v19 = 0;
    v20 = 0;
    v21 = 0;
    while (1)
    {
      v22 = *(__int16 *)(a2 + 2 * v19);
      v23 = *(unsigned __int16 *)(a2 + 2 * v19);
      *(_QWORD *)(v13 + v21) = v20;
      if (v22 >= 9)
      {
        if (v23 <= 0x10)
          v24 = 16;
        else
          v24 = v23;
        v25 = v24 - 9;
        if (v25 >= 0x18)
        {
          v27 = (v25 >> 3) + 1;
          v26 = (32 * ((v27 & 0x3FFFFFFFFFFFFFFCuLL) >> 2)) | 8;
          v28 = vdupq_n_s64(v20);
          v29 = (int64x2_t *)(a7 + 130 + v21);
          v30 = v27 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v29[-1] = v28;
            *v29 = v28;
            v29 += 2;
            v30 -= 4;
          }
          while (v30);
          if (v27 == (v27 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_11;
        }
        else
        {
          v26 = 8;
        }
        do
        {
          *(_QWORD *)(v13 + v21 + v26) = v20;
          v26 += 8;
        }
        while (v26 < v23);
      }
LABEL_11:
      v21 += (__int16)v23;
      ++v19;
      v20 += 0x101010101010101;
      if (v19 == v10)
      {
        v11 = v18 + 3 + (v8 >> 1);
        goto LABEL_32;
      }
    }
  }
  *result = 1;
  result[1] = a6;
  v11 = (v8 >> 3) + (v8 >> 1) + 3;
LABEL_32:
  v36 = 0;
  v37 = 0;
  do
  {
    v7[2 * (v37 & v9) + 1] = *(unsigned __int8 *)(a7 + v36 + 106);
    v7[2 * (((_DWORD)v37 + v11) & v9) + 1] = *(unsigned __int8 *)(a7 + v36 + 107);
    v37 = ((_DWORD)v37 + 2 * v11) & v9;
    v36 += 2;
  }
  while (v36 < v8);
LABEL_34:
  v38 = result + 3;
  v39 = (1 << a6);
  do
  {
    v40 = *v38;
    v41 = *(unsigned __int16 *)(a7 + 2 * v40);
    *(_WORD *)(a7 + 2 * v40) = v41 + 1;
    v42 = a6 + 1 + (__clz(v41) ^ 0xE0);
    *((_BYTE *)v38 - 1) = v42;
    *((_WORD *)v38 - 2) = (v41 << v42) - v8;
    v40 *= 4;
    *((_BYTE *)v38 - 2) = *(_DWORD *)(a5 + v40);
    *v38 = *(_DWORD *)(a4 + v40);
    v38 += 2;
    --v39;
  }
  while (v39);
  return result;
}

uint64_t ZSTD_decompressBegin(uint64_t a1)
{
  uint64_t v1;

  v1 = 5;
  if (*(_DWORD *)(a1 + 29584))
    v1 = 1;
  *(_QWORD *)(a1 + 29408) = v1;
  *(_OWORD *)(a1 + 29376) = 0u;
  *(_OWORD *)(a1 + 29392) = 0u;
  *(_OWORD *)(a1 + 29456) = 0u;
  *(_DWORD *)(a1 + 10296) = 201326604;
  *(_DWORD *)(a1 + 29680) = 0;
  *(_OWORD *)(a1 + 29472) = xmmword_18823D7A0;
  *(_QWORD *)(a1 + 26684) = 0x400000001;
  *(_DWORD *)(a1 + 26692) = 8;
  *(_QWORD *)a1 = a1 + 32;
  *(_QWORD *)(a1 + 8) = a1 + 6192;
  *(_QWORD *)(a1 + 16) = a1 + 4136;
  *(_QWORD *)(a1 + 24) = a1 + 10296;
  return 0;
}

uint64_t ZSTD_decompressBegin_usingDict(uint64_t a1, _DWORD *a2, unint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  unint64_t DEntropy;
  uint64_t v9;

  result = 0;
  v5 = 5;
  if (*(_DWORD *)(a1 + 29584))
    v5 = 1;
  *(_QWORD *)(a1 + 29408) = v5;
  *(_QWORD *)(a1 + 26684) = 0x400000001;
  *(_DWORD *)(a1 + 26692) = 8;
  *(_OWORD *)(a1 + 29376) = 0u;
  *(_OWORD *)(a1 + 29392) = 0u;
  *(_OWORD *)(a1 + 29456) = 0u;
  *(_DWORD *)(a1 + 10296) = 201326604;
  *(_DWORD *)(a1 + 29680) = 0;
  *(_OWORD *)(a1 + 29472) = xmmword_18823D7A0;
  *(_QWORD *)a1 = a1 + 32;
  *(_QWORD *)(a1 + 8) = a1 + 6192;
  *(_QWORD *)(a1 + 16) = a1 + 4136;
  *(_QWORD *)(a1 + 24) = a1 + 10296;
  if (a2 && a3)
  {
    if (a3 > 7 && *a2 == -332356553)
    {
      *(_DWORD *)(a1 + 29680) = a2[1];
      DEntropy = ZSTD_loadDEntropy((int *)(a1 + 32), (uint64_t)a2, a3);
      if (DEntropy > 0xFFFFFFFFFFFFFF88)
        return -30;
      *(_QWORD *)(a1 + 29480) = 0x100000001;
      v9 = *(_QWORD *)(a1 + 29376);
      *(_QWORD *)(a1 + 29400) = v9;
      *(_QWORD *)(a1 + 29392) = (char *)a2 + DEntropy + *(_QWORD *)(a1 + 29384) - v9;
      *(_QWORD *)(a1 + 29384) = (char *)a2 + DEntropy;
    }
    else
    {
      *(_QWORD *)(a1 + 29392) = a2;
      *(_QWORD *)(a1 + 29384) = a2;
    }
    result = 0;
    *(_QWORD *)(a1 + 29376) = (char *)a2 + a3;
  }
  return result;
}

uint64_t ZSTD_decompressBegin_usingDDict(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (_QWORD *)(a1 + 26684);
  if (a2)
    *(_DWORD *)(a1 + 29684) = *(_QWORD *)(a1 + 29400) != *(_QWORD *)(a2 + 8) + *(_QWORD *)(a2 + 16);
  v3 = 5;
  if (*(_DWORD *)(a1 + 29584))
    v3 = 1;
  *(_QWORD *)(a1 + 29408) = v3;
  *(_OWORD *)(a1 + 29376) = 0u;
  *(_OWORD *)(a1 + 29392) = 0u;
  *(_OWORD *)(a1 + 29456) = 0u;
  *(_DWORD *)(a1 + 10296) = 201326604;
  *(_DWORD *)(a1 + 29680) = 0;
  *(_OWORD *)(a1 + 29472) = xmmword_18823D7A0;
  *v2 = 0x400000001;
  *(_DWORD *)(a1 + 26692) = 8;
  *(_QWORD *)a1 = a1 + 32;
  *(_QWORD *)(a1 + 8) = a1 + 6192;
  *(_QWORD *)(a1 + 16) = a1 + 4136;
  *(_QWORD *)(a1 + 24) = a1 + 10296;
  if (a2)
  {
    *(_DWORD *)(a1 + 29680) = *(_DWORD *)(a2 + 27316);
    v4 = *(_QWORD *)(a2 + 8);
    v5 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 29384) = v4;
    *(_QWORD *)(a1 + 29392) = v4;
    v6 = v4 + v5;
    *(_QWORD *)(a1 + 29400) = v6;
    *(_QWORD *)(a1 + 29376) = v6;
    if (*(_DWORD *)(a2 + 27320))
    {
      *(_QWORD *)a1 = a2 + 24;
      *(_QWORD *)(a1 + 8) = a2 + 6184;
      *(_QWORD *)(a1 + 29480) = 0x100000001;
      *(_QWORD *)(a1 + 16) = a2 + 4128;
      *(_QWORD *)(a1 + 24) = a2 + 10288;
      *(_DWORD *)v2 = *(_DWORD *)(a2 + 26676);
      *(_DWORD *)(a1 + 26688) = *(_DWORD *)(a2 + 26680);
      *(_DWORD *)(a1 + 26692) = *(_DWORD *)(a2 + 26684);
      return 0;
    }
    *(_DWORD *)(a1 + 29484) = 0;
  }
  return 0;
}

uint64_t ZSTD_getDictID_fromFrame(unsigned __int8 *a1, unint64_t a2)
{
  __int128 v3;
  __int128 v4;
  uint64_t v5;

  v5 = 0;
  v3 = 0u;
  v4 = 0u;
  if (ZSTD_getFrameHeader_advanced((uint64_t)&v3, a1, a2, 0) >= 0xFFFFFFFFFFFFFF89)
    return 0;
  else
    return HIDWORD(v4);
}

double ZSTD_createDStream()
{
  char *v0;
  double result;

  v0 = (char *)malloc_type_malloc(0x274D0uLL, 0x26AA08A0uLL);
  if (v0)
  {
    *((_QWORD *)v0 + 3706) = 0;
    *((_QWORD *)v0 + 3675) = 0;
    result = 0.0;
    *(_QWORD *)(v0 + 29684) = 0;
    *((_QWORD *)v0 + 3719) = 0;
    *((_QWORD *)v0 + 3723) = 0;
    *((_DWORD *)v0 + 7448) = 0;
    *((_QWORD *)v0 + 20121) = 0;
    *((_DWORD *)v0 + 7414) = 0;
    *((_QWORD *)v0 + 3712) = 0;
    *((_OWORD *)v0 + 1854) = 0u;
    *(_OWORD *)(v0 + 29708) = 0u;
    *((_DWORD *)v0 + 7431) = 0;
    *((_QWORD *)v0 + 3701) = 0;
    *((_QWORD *)v0 + 3703) = 0;
    *((_QWORD *)v0 + 3702) = 0;
    *((_QWORD *)v0 + 3717) = 134217729;
    *(_QWORD *)(v0 + 29804) = 0;
    *((_QWORD *)v0 + 3698) = 0;
    *((_DWORD *)v0 + 7426) = 0;
  }
  return result;
}

double ZSTD_createDStream_advanced(uint64_t a1)
{
  uint64_t (*v1)(_QWORD, uint64_t);
  uint64_t v2;
  uint64_t v3;
  char *v4;
  double result;

  v1 = *(uint64_t (**)(_QWORD, uint64_t))a1;
  v2 = *(_QWORD *)(a1 + 8);
  if ((*(_QWORD *)a1 == 0) == (v2 == 0))
  {
    v3 = *(_QWORD *)(a1 + 16);
    if (v1)
    {
      v4 = (char *)v1(*(_QWORD *)(a1 + 16), 160976);
      if (!v4)
        return result;
    }
    else
    {
      v4 = (char *)malloc_type_malloc(0x274D0uLL, 0x26AA08A0uLL);
      if (!v4)
        return result;
    }
    *((_QWORD *)v4 + 3701) = v1;
    *((_QWORD *)v4 + 3702) = v2;
    *((_QWORD *)v4 + 3703) = v3;
    *((_QWORD *)v4 + 3706) = 0;
    *((_QWORD *)v4 + 3675) = 0;
    result = 0.0;
    *(_QWORD *)(v4 + 29684) = 0;
    *((_QWORD *)v4 + 3719) = 0;
    *((_QWORD *)v4 + 3723) = 0;
    *((_DWORD *)v4 + 7448) = 0;
    *((_QWORD *)v4 + 20121) = 0;
    *((_DWORD *)v4 + 7414) = 0;
    *((_QWORD *)v4 + 3712) = 0;
    *((_OWORD *)v4 + 1854) = 0u;
    *(_OWORD *)(v4 + 29708) = 0u;
    *((_DWORD *)v4 + 7431) = 0;
    *((_QWORD *)v4 + 3717) = 134217729;
    *(_QWORD *)(v4 + 29804) = 0;
    *((_QWORD *)v4 + 3698) = 0;
    *((_DWORD *)v4 + 7426) = 0;
  }
  return result;
}

uint64_t ZSTD_initStaticDStream(uint64_t a1, unint64_t a2)
{
  uint64_t v2;

  v2 = 0;
  if (a2 >= 0x274D0 && (a1 & 7) == 0)
  {
    *(_QWORD *)(a1 + 29400) = 0;
    *(_QWORD *)(a1 + 29684) = 0;
    *(_QWORD *)(a1 + 29752) = 0;
    *(_QWORD *)(a1 + 29784) = 0;
    *(_DWORD *)(a1 + 29792) = 0;
    *(_QWORD *)(a1 + 160968) = 0;
    *(_DWORD *)(a1 + 29656) = 0;
    *(_QWORD *)(a1 + 29696) = 0;
    *(_OWORD *)(a1 + 29664) = 0u;
    *(_OWORD *)(a1 + 29708) = 0u;
    *(_DWORD *)(a1 + 29724) = 0;
    *(_QWORD *)(a1 + 29736) = 134217729;
    *(_QWORD *)(a1 + 29804) = 0;
    *(_QWORD *)(a1 + 29584) = 0;
    *(_DWORD *)(a1 + 29704) = 0;
    *(_QWORD *)(a1 + 29648) = a2;
    v2 = a1;
    *(_QWORD *)(a1 + 29712) = a1 + 160976;
  }
  return v2;
}

uint64_t ZSTD_DStreamInSize()
{
  return 131075;
}

uint64_t ZSTD_DStreamOutSize()
{
  return 0x20000;
}

uint64_t ZSTD_DCtx_loadDictionary_advanced(uint64_t a1, const void *a2, size_t a3, int a4, int a5)
{
  _DWORD *v5;
  uint64_t result;
  _QWORD *v12;
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t);
  uint64_t v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;

  v5 = (_DWORD *)(a1 + 29688);
  if (*(_DWORD *)(a1 + 29708))
    return -60;
  v12 = (_QWORD *)(a1 + 29664);
  v13 = *(_QWORD *)(a1 + 29664);
  if (!v13)
  {
LABEL_10:
    result = 0;
    *v5 = 0;
    *v12 = 0;
    v12[1] = 0;
    if (!a2)
      return result;
    goto LABEL_11;
  }
  v14 = *(void (**)(uint64_t, uint64_t))(v13 + 27336);
  v15 = *(_QWORD *)(v13 + 27344);
  if (*(_QWORD *)v13)
  {
    if (v14)
    {
      ((void (*)(_QWORD))v14)(*(_QWORD *)(v13 + 27344));
LABEL_9:
      v14(v15, v13);
      goto LABEL_10;
    }
    free(*(void **)v13);
  }
  else if (v14)
  {
    goto LABEL_9;
  }
  free((void *)v13);
  result = 0;
  *v5 = 0;
  *v12 = 0;
  v12[1] = 0;
  if (!a2)
    return result;
LABEL_11:
  if (a3)
  {
    v19 = *(_QWORD *)(a1 + 29624);
    v18 = *(_OWORD *)(a1 + 29608);
    v16 = ZSTD_createDDict_advanced(a2, a3, a4, a5, &v18);
    *(_QWORD *)(a1 + 29664) = v16;
    if (v16)
    {
      v17 = v16;
      result = 0;
      *(_QWORD *)(a1 + 29672) = v17;
      *v5 = -1;
    }
    else
    {
      return -64;
    }
  }
  return result;
}

uint64_t ZSTD_DCtx_loadDictionary_byReference(uint64_t a1, const void *a2, size_t a3)
{
  _DWORD *v3;
  uint64_t result;
  _QWORD *v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;

  v3 = (_DWORD *)(a1 + 29688);
  if (*(_DWORD *)(a1 + 29708))
    return -60;
  v8 = (_QWORD *)(a1 + 29664);
  v9 = *(_QWORD *)(a1 + 29664);
  if (!v9)
  {
LABEL_10:
    result = 0;
    *v3 = 0;
    *v8 = 0;
    v8[1] = 0;
    if (!a2)
      return result;
    goto LABEL_11;
  }
  v10 = *(void (**)(uint64_t, uint64_t))(v9 + 27336);
  v11 = *(_QWORD *)(v9 + 27344);
  if (*(_QWORD *)v9)
  {
    if (v10)
    {
      ((void (*)(_QWORD))v10)(*(_QWORD *)(v9 + 27344));
LABEL_9:
      v10(v11, v9);
      goto LABEL_10;
    }
    free(*(void **)v9);
  }
  else if (v10)
  {
    goto LABEL_9;
  }
  free((void *)v9);
  result = 0;
  *v3 = 0;
  *v8 = 0;
  v8[1] = 0;
  if (!a2)
    return result;
LABEL_11:
  if (a3)
  {
    v15 = *(_QWORD *)(a1 + 29624);
    v14 = *(_OWORD *)(a1 + 29608);
    v12 = ZSTD_createDDict_advanced(a2, a3, 1, 0, &v14);
    *(_QWORD *)(a1 + 29664) = v12;
    if (v12)
    {
      v13 = v12;
      result = 0;
      *(_QWORD *)(a1 + 29672) = v13;
      *v3 = -1;
    }
    else
    {
      return -64;
    }
  }
  return result;
}

uint64_t ZSTD_DCtx_loadDictionary(uint64_t a1, const void *a2, size_t a3)
{
  _DWORD *v3;
  uint64_t result;
  _QWORD *v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;

  v3 = (_DWORD *)(a1 + 29688);
  if (*(_DWORD *)(a1 + 29708))
    return -60;
  v8 = (_QWORD *)(a1 + 29664);
  v9 = *(_QWORD *)(a1 + 29664);
  if (!v9)
  {
LABEL_10:
    result = 0;
    *v3 = 0;
    *v8 = 0;
    v8[1] = 0;
    if (!a2)
      return result;
    goto LABEL_11;
  }
  v10 = *(void (**)(uint64_t, uint64_t))(v9 + 27336);
  v11 = *(_QWORD *)(v9 + 27344);
  if (*(_QWORD *)v9)
  {
    if (v10)
    {
      ((void (*)(_QWORD))v10)(*(_QWORD *)(v9 + 27344));
LABEL_9:
      v10(v11, v9);
      goto LABEL_10;
    }
    free(*(void **)v9);
  }
  else if (v10)
  {
    goto LABEL_9;
  }
  free((void *)v9);
  result = 0;
  *v3 = 0;
  *v8 = 0;
  v8[1] = 0;
  if (!a2)
    return result;
LABEL_11:
  if (a3)
  {
    v15 = *(_QWORD *)(a1 + 29624);
    v14 = *(_OWORD *)(a1 + 29608);
    v12 = ZSTD_createDDict_advanced(a2, a3, 0, 0, &v14);
    *(_QWORD *)(a1 + 29664) = v12;
    if (v12)
    {
      v13 = v12;
      result = 0;
      *(_QWORD *)(a1 + 29672) = v13;
      *v3 = -1;
    }
    else
    {
      return -64;
    }
  }
  return result;
}

uint64_t ZSTD_DCtx_refPrefix_advanced(uint64_t a1, const void *a2, size_t a3, int a4)
{
  _DWORD *v4;
  uint64_t result;
  _QWORD *v10;
  uint64_t v11;
  void (*v12)(uint64_t, uint64_t);
  uint64_t v13;
  char *v14;
  __int128 v15;
  uint64_t v16;

  v4 = (_DWORD *)(a1 + 29688);
  if (*(_DWORD *)(a1 + 29708))
    return -60;
  v10 = (_QWORD *)(a1 + 29664);
  v11 = *(_QWORD *)(a1 + 29664);
  if (v11)
  {
    v12 = *(void (**)(uint64_t, uint64_t))(v11 + 27336);
    v13 = *(_QWORD *)(v11 + 27344);
    if (*(_QWORD *)v11)
    {
      if (v12)
      {
        ((void (*)(_QWORD))v12)(*(_QWORD *)(v11 + 27344));
LABEL_8:
        v12(v13, v11);
        goto LABEL_9;
      }
      free(*(void **)v11);
    }
    else if (v12)
    {
      goto LABEL_8;
    }
    free((void *)v11);
    *v4 = 0;
    *v10 = 0;
    v10[1] = 0;
    if (!a2)
      goto LABEL_13;
    goto LABEL_10;
  }
LABEL_9:
  *v4 = 0;
  *v10 = 0;
  v10[1] = 0;
  if (!a2)
  {
LABEL_13:
    result = 0;
    *v4 = 1;
    return result;
  }
LABEL_10:
  if (!a3)
    goto LABEL_13;
  v16 = *(_QWORD *)(a1 + 29624);
  v15 = *(_OWORD *)(a1 + 29608);
  v14 = ZSTD_createDDict_advanced(a2, a3, 1, a4, &v15);
  *(_QWORD *)(a1 + 29664) = v14;
  if (v14)
  {
    *(_QWORD *)(a1 + 29672) = v14;
    goto LABEL_13;
  }
  return -64;
}

uint64_t ZSTD_DCtx_refPrefix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v3;
  uint64_t result;
  _QWORD *v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  uint64_t (*v12)(_QWORD, uint64_t);
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;

  v3 = (_DWORD *)(a1 + 29688);
  if (*(_DWORD *)(a1 + 29708))
    return -60;
  v8 = (_QWORD *)(a1 + 29664);
  v9 = *(_QWORD *)(a1 + 29664);
  if (v9)
  {
    v10 = *(void (**)(uint64_t, uint64_t))(v9 + 27336);
    v11 = *(_QWORD *)(v9 + 27344);
    if (*(_QWORD *)v9)
    {
      if (v10)
      {
        ((void (*)(_QWORD))v10)(*(_QWORD *)(v9 + 27344));
LABEL_8:
        v10(v11, v9);
        goto LABEL_9;
      }
      free(*(void **)v9);
    }
    else if (v10)
    {
      goto LABEL_8;
    }
    free((void *)v9);
    *v3 = 0;
    *v8 = 0;
    v8[1] = 0;
    if (!a2)
      goto LABEL_17;
    goto LABEL_10;
  }
LABEL_9:
  *v3 = 0;
  *v8 = 0;
  v8[1] = 0;
  if (!a2)
  {
LABEL_17:
    result = 0;
    *v3 = 1;
    return result;
  }
LABEL_10:
  if (!a3)
    goto LABEL_17;
  v12 = *(uint64_t (**)(_QWORD, uint64_t))(a1 + 29608);
  v13 = *(_QWORD *)(a1 + 29616);
  if ((v12 == 0) == (v13 == 0))
  {
    v14 = *(_QWORD *)(a1 + 29624);
    if (v12)
    {
      v15 = (_QWORD *)v12(*(_QWORD *)(a1 + 29624), 27352);
      if (v15)
      {
LABEL_14:
        v15[3416] = v12;
        v15[3417] = v13;
        v15[3418] = v14;
        *v15 = 0;
        v15[1] = a2;
        v15[2] = a3;
        *((_DWORD *)v15 + 2572) = 201326604;
        *(_QWORD *)((char *)v15 + 27316) = 0;
        *(_QWORD *)(a1 + 29664) = v15;
        *(_QWORD *)(a1 + 29672) = v15;
        goto LABEL_17;
      }
    }
    else
    {
      v15 = malloc_type_malloc(0x6AD8uLL, 0x26AA08A0uLL);
      if (v15)
        goto LABEL_14;
    }
  }
  *v8 = 0;
  return -64;
}

uint64_t ZSTD_initDStream_usingDict(uint64_t a1, const void *a2, size_t a3)
{
  _DWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  char *v11;
  __int128 v13;
  uint64_t v14;

  v6 = (_DWORD *)(a1 + 29584);
  *(_DWORD *)(a1 + 29708) = 0;
  *(_DWORD *)(a1 + 29804) = 0;
  v7 = (_QWORD *)(a1 + 29664);
  v8 = *(_QWORD *)(a1 + 29664);
  if (v8)
  {
    v9 = *(void (**)(uint64_t, uint64_t))(v8 + 27336);
    v10 = *(_QWORD *)(v8 + 27344);
    if (*(_QWORD *)v8)
    {
      if (v9)
      {
        ((void (*)(_QWORD))v9)(*(_QWORD *)(v8 + 27344));
LABEL_6:
        v9(v10, v8);
        goto LABEL_7;
      }
      free(*(void **)v8);
    }
    else if (v9)
    {
      goto LABEL_6;
    }
    free((void *)v8);
    v6[26] = 0;
    *v7 = 0;
    v7[1] = 0;
    if (!a2)
      goto LABEL_11;
    goto LABEL_8;
  }
LABEL_7:
  v6[26] = 0;
  *v7 = 0;
  v7[1] = 0;
  if (!a2)
    goto LABEL_11;
LABEL_8:
  if (a3)
  {
    v14 = *(_QWORD *)(a1 + 29624);
    v13 = *(_OWORD *)(a1 + 29608);
    v11 = ZSTD_createDDict_advanced(a2, a3, 0, 0, &v13);
    *(_QWORD *)(a1 + 29664) = v11;
    if (!v11)
      return -64;
    *(_QWORD *)(a1 + 29672) = v11;
    v6[26] = -1;
  }
LABEL_11:
  if (*v6)
    return 1;
  else
    return 5;
}

double ZSTD_DCtx_reset(uint64_t a1, int a2)
{
  _DWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  uint64_t v7;
  double result;

  v3 = (_DWORD *)(a1 + 29688);
  if ((a2 & 0xFFFFFFFD) == 1)
  {
    *(_DWORD *)(a1 + 29708) = 0;
    *(_DWORD *)(a1 + 29804) = 0;
  }
  if ((a2 & 0xFFFFFFFE) == 2 && !*(_DWORD *)(a1 + 29708))
  {
    v4 = (_QWORD *)(a1 + 29664);
    v5 = *(_QWORD *)(a1 + 29664);
    if (!v5)
    {
LABEL_15:
      *v3 = 0;
      *v4 = 0;
      *(_QWORD *)(a1 + 29672) = 0;
      *(_QWORD *)(a1 + 29736) = 134217729;
      v3[30] = 0;
      result = 0.0;
      *(_QWORD *)(a1 + 29584) = 0;
      v3[4] = 0;
      return result;
    }
    v6 = *(void (**)(uint64_t, uint64_t))(v5 + 27336);
    v7 = *(_QWORD *)(v5 + 27344);
    if (*(_QWORD *)v5)
    {
      if (v6)
      {
        ((void (*)(_QWORD))v6)(*(_QWORD *)(v5 + 27344));
LABEL_12:
        v6(v7, v5);
        goto LABEL_15;
      }
      free(*(void **)v5);
    }
    else if (v6)
    {
      goto LABEL_12;
    }
    free((void *)v5);
    goto LABEL_15;
  }
  return result;
}

uint64_t ZSTD_initDStream(uint64_t a1)
{
  _DWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  void (*v4)(uint64_t, uint64_t);
  uint64_t v5;

  v1 = (_DWORD *)(a1 + 29584);
  *(_DWORD *)(a1 + 29708) = 0;
  *(_DWORD *)(a1 + 29804) = 0;
  v2 = (_QWORD *)(a1 + 29664);
  v3 = *(_QWORD *)(a1 + 29664);
  if (!v3)
    goto LABEL_9;
  v4 = *(void (**)(uint64_t, uint64_t))(v3 + 27336);
  v5 = *(_QWORD *)(v3 + 27344);
  if (*(_QWORD *)v3)
  {
    if (v4)
    {
      ((void (*)(_QWORD))v4)(*(_QWORD *)(v3 + 27344));
LABEL_6:
      v4(v5, v3);
      goto LABEL_9;
    }
    free(*(void **)v3);
  }
  else if (v4)
  {
    goto LABEL_6;
  }
  free((void *)v3);
LABEL_9:
  v1[26] = 0;
  *v2 = 0;
  v2[1] = 0;
  if (*v1)
    return 1;
  else
    return 5;
}

unint64_t ZSTD_initDStream_usingDDict(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  unint64_t result;

  v2 = (_DWORD *)(a1 + 29584);
  *(_DWORD *)(a1 + 29708) = 0;
  *(_DWORD *)(a1 + 29804) = 0;
  result = ZSTD_DCtx_refDDict(a1, a2);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (*v2)
      return 1;
    else
      return 5;
  }
  return result;
}

uint64_t ZSTD_DCtx_refDDict(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  uint64_t result;
  _QWORD *v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t);
  uint64_t v9;
  _QWORD *v10;
  uint64_t (*v11)(uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  _OWORD *v14;
  void *v15;
  _QWORD *v16;
  unint64_t v17;
  _DWORD *v18;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, unint64_t);
  void (*v24)(uint64_t, _QWORD *);
  uint64_t v25;
  void *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  unsigned int v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _DWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  int v45;
  uint64_t v46;
  void (*v47)(uint64_t, _QWORD *);
  uint64_t v48;
  unsigned int v49;
  unsigned int v50;

  v2 = (_DWORD *)(a1 + 29688);
  if (*(_DWORD *)(a1 + 29708))
    return -60;
  v6 = (_QWORD *)(a1 + 29664);
  v7 = *(_QWORD *)(a1 + 29664);
  if (v7)
  {
    v8 = *(void (**)(uint64_t, uint64_t))(v7 + 27336);
    v9 = *(_QWORD *)(v7 + 27344);
    if (*(_QWORD *)v7)
    {
      if (v8)
      {
        ((void (*)(_QWORD))v8)(*(_QWORD *)(v7 + 27344));
LABEL_8:
        v8(v9, v7);
        goto LABEL_9;
      }
      free(*(void **)v7);
    }
    else if (v8)
    {
      goto LABEL_8;
    }
    free((void *)v7);
    *v2 = 0;
    *v6 = 0;
    v6[1] = 0;
    if (!a2)
      return 0;
    goto LABEL_10;
  }
LABEL_9:
  *v2 = 0;
  *v6 = 0;
  v6[1] = 0;
  if (!a2)
    return 0;
LABEL_10:
  *(_QWORD *)(a1 + 29672) = a2;
  *v2 = -1;
  if (v2[4] != 1)
    return 0;
  v10 = *(_QWORD **)(a1 + 29696);
  if (!v10)
  {
    v11 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 29608);
    if (v11)
    {
      v12 = *(_QWORD *)(a1 + 29624);
      v13 = v11(v12, 24);
      v14 = (_OWORD *)v11(v12, 512);
      *v14 = 0u;
      v14[1] = 0u;
      v14[2] = 0u;
      v14[3] = 0u;
      v14[4] = 0u;
      v14[5] = 0u;
      v14[6] = 0u;
      v14[7] = 0u;
      v14[8] = 0u;
      v14[9] = 0u;
      v14[10] = 0u;
      v14[11] = 0u;
      v14[12] = 0u;
      v14[13] = 0u;
      v14[14] = 0u;
      v14[15] = 0u;
      v14[16] = 0u;
      v14[17] = 0u;
      v14[18] = 0u;
      v14[19] = 0u;
      v14[20] = 0u;
      v14[21] = 0u;
      v14[22] = 0u;
      v14[23] = 0u;
      v14[24] = 0u;
      v14[25] = 0u;
      v14[26] = 0u;
      v14[27] = 0u;
      v14[28] = 0u;
      v14[29] = 0u;
      v14[30] = 0u;
      v14[31] = 0u;
      *(_QWORD *)v13 = v14;
      *(_OWORD *)(v13 + 8) = xmmword_18823D7D0;
      if (v14)
        v10 = (_QWORD *)v13;
      else
        v10 = 0;
      *(_QWORD *)(a1 + 29696) = v10;
    }
    else
    {
      v10 = malloc_type_malloc(0x18uLL, 0x26AA08A0uLL);
      v15 = malloc_type_calloc(1uLL, 0x200uLL, 0xEC864E14uLL);
      *v10 = v15;
      *(_OWORD *)(v10 + 1) = xmmword_18823D7D0;
      if (v15)
        v16 = v10;
      else
        v16 = 0;
      *(_QWORD *)(a1 + 29696) = v16;
      if (!v15)
        return -64;
    }
  }
  v17 = v10[1];
  if (v17 > 4 * v10[2])
    goto LABEL_25;
  v23 = *(uint64_t (**)(uint64_t, unint64_t))(a1 + 29608);
  v24 = *(void (**)(uint64_t, _QWORD *))(a1 + 29616);
  v25 = *(_QWORD *)(a1 + 29624);
  if (!v23)
  {
    v26 = malloc_type_calloc(1uLL, 16 * v17, 0xEC864E14uLL);
    if (v26)
      goto LABEL_33;
    return -64;
  }
  v26 = (void *)v23(v25, 16 * v17);
  bzero(v26, 16 * v17);
  if (!v26)
    return -64;
LABEL_33:
  v46 = v25;
  v47 = v24;
  v27 = (_QWORD *)*v10;
  v28 = v10[1];
  *v10 = v26;
  v10[1] = 2 * v17;
  v48 = 2 * v17;
  v10[2] = 0;
  if (!v28)
    goto LABEL_59;
  v29 = 0;
  v30 = 0;
  v31 = v48 - 1;
  while (2)
  {
    v32 = v27[v30];
    if (!v32)
      goto LABEL_36;
    if (*(_QWORD *)(v32 + 16) >= 8uLL && (v33 = *(_DWORD **)(v32 + 8), *v33 == -332356553))
      v34 = v33[1];
    else
      v34 = 0;
    v49 = v34;
    v35 = ZSTD_XXH64(&v49, 4uLL);
    if (v29 == v48)
      return -1;
    v36 = v35 & v31;
    v37 = *v10;
    v38 = *(_QWORD *)(*v10 + 8 * (v35 & v31));
    if (!v38)
    {
LABEL_35:
      *(_QWORD *)(v37 + 8 * v36) = v32;
      v10[2] = ++v29;
      goto LABEL_36;
    }
    while (1)
    {
      if (*(_QWORD *)(v38 + 16) >= 8uLL)
      {
        v39 = *(_DWORD **)(v38 + 8);
        if (*v39 == -332356553)
          break;
      }
      if (!v34)
        goto LABEL_50;
LABEL_46:
      v36 = (v36 & v31) + 1;
      v38 = *(_QWORD *)(v37 + 8 * v36);
      if (!v38)
        goto LABEL_35;
    }
    if (v39[1] != v34)
      goto LABEL_46;
LABEL_50:
    *(_QWORD *)(v37 + 8 * v36) = v32;
LABEL_36:
    if (++v30 != v28)
      continue;
    break;
  }
LABEL_59:
  if (v27)
  {
    if (v47)
      v47(v46, v27);
    else
      free(v27);
  }
LABEL_25:
  if (*(_QWORD *)(a2 + 16) >= 8uLL && (v18 = *(_DWORD **)(a2 + 8), *v18 == -332356553))
    v19 = v18[1];
  else
    v19 = 0;
  v50 = v19;
  v20 = ZSTD_XXH64(&v50, 4uLL);
  v22 = v10[1];
  v21 = v10[2];
  if (v21 == v22)
    return -1;
  v40 = v22 - 1;
  v41 = (v22 - 1) & v20;
  v42 = *v10;
  v43 = *(_QWORD *)(*v10 + 8 * v41);
  if (v43)
  {
    while (1)
    {
      if (*(_QWORD *)(v43 + 16) >= 8uLL && (v44 = *(_DWORD **)(v43 + 8), *v44 == -332356553))
        v45 = v44[1];
      else
        v45 = 0;
      if (v45 == v19)
        break;
      v41 = (v41 & v40) + 1;
      v43 = *(_QWORD *)(v42 + 8 * v41);
      if (!v43)
        goto LABEL_58;
    }
    result = 0;
    *(_QWORD *)(v42 + 8 * v41) = a2;
  }
  else
  {
LABEL_58:
    result = 0;
    *(_QWORD *)(v42 + 8 * v41) = a2;
    v10[2] = v21 + 1;
  }
  return result;
}

uint64_t ZSTD_resetDStream(_DWORD *a1)
{
  a1[7427] = 0;
  a1[7451] = 0;
  if (a1[7396])
    return 1;
  else
    return 5;
}

uint64_t ZSTD_DCtx_setMaxWindowSize(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 29708))
    return -60;
  if ((unint64_t)(a2 - 2147483649) < 0xFFFFFFFF800003FFLL)
    return -42;
  result = 0;
  *(_QWORD *)(a1 + 29736) = a2;
  return result;
}

uint64_t ZSTD_dParam_getBounds(int a1)
{
  uint64_t result;

  switch(a1)
  {
    case 1000:
    case 1001:
    case 1002:
    case 1003:
      result = 0;
      break;
    default:
      if (a1 == 100)
        result = 0;
      else
        result = -40;
      break;
  }
  return result;
}

uint64_t ZSTD_DCtx_setFormat(uint64_t a1, unsigned int a2)
{
  unsigned int *v2;
  uint64_t result;

  v2 = (unsigned int *)(a1 + 29584);
  if (*(_DWORD *)(a1 + 29708))
    return -60;
  if (a2 > 1)
    return -42;
  result = 0;
  *v2 = a2;
  return result;
}

uint64_t ZSTD_DCtx_setParameter(uint64_t a1, int a2, unsigned int a3)
{
  unsigned int *v3;
  uint64_t result;
  int v6;

  v3 = (unsigned int *)(a1 + 29584);
  if (*(_DWORD *)(a1 + 29708))
    return -60;
  switch(a2)
  {
    case 1000:
      if (a3 <= 1)
      {
        result = 0;
        *v3 = a3;
      }
      else
      {
        result = -42;
      }
      break;
    case 1001:
      if (a3 <= 1)
      {
        result = 0;
        v3[56] = a3;
      }
      else
      {
        result = -42;
      }
      break;
    case 1002:
      if (a3 <= 1)
      {
        result = 0;
        v3[1] = a3;
      }
      else
      {
        result = -42;
      }
      break;
    case 1003:
      if (a3 <= 1)
      {
        if (*(_QWORD *)(a1 + 29648))
          goto LABEL_23;
        result = 0;
        v3[30] = a3;
      }
      else
      {
        result = -42;
      }
      break;
    default:
      if (a2 == 100)
      {
        if (a3)
          v6 = a3;
        else
          v6 = 27;
        if ((v6 - 32) >= 0xFFFFFFEA)
        {
          result = 0;
          *(_QWORD *)(a1 + 29736) = 1 << v6;
        }
        else
        {
          result = -42;
        }
      }
      else
      {
LABEL_23:
        result = -40;
      }
      break;
  }
  return result;
}

uint64_t ZSTD_DCtx_getParameter(_DWORD *a1, int a2, unsigned int *a3)
{
  unsigned int *v3;
  uint64_t result;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v3 = a1 + 7396;
  switch(a2)
  {
    case 1000:
      result = 0;
      *a3 = *v3;
      break;
    case 1001:
      v6 = a1[7452];
      result = 0;
      *a3 = v6;
      break;
    case 1002:
      v7 = a1[7397];
      result = 0;
      *a3 = v7;
      break;
    case 1003:
      v8 = a1[7426];
      result = 0;
      *a3 = v8;
      break;
    default:
      if (a2 == 100)
      {
        v5 = __clz(a1[7434]) ^ 0x1F;
        result = 0;
        *a3 = v5;
      }
      else
      {
        result = -40;
      }
      break;
  }
  return result;
}

_QWORD *ZSTD_sizeof_DStream(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;

  if (result)
  {
    v1 = (_QWORD *)result[3708];
    if (v1)
    {
      v2 = 188328;
      if (*v1)
        v2 = v1[2] + 188328;
    }
    else
    {
      v2 = 160976;
    }
    return (_QWORD *)(result[3715] + v2 + result[3719]);
  }
  return result;
}

unint64_t ZSTD_decodingBufferSize_min(unint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  v2 = 0x20000;
  if (a1 < 0x20000)
    v2 = a1;
  v3 = a1 + v2 + 64;
  if (v3 >= a2)
    return a2;
  else
    return v3;
}

uint64_t ZSTD_estimateDStreamSize(unint64_t a1)
{
  uint64_t v1;

  v1 = 0x20000;
  if (a1 < 0x20000)
    v1 = a1;
  return a1 + 2 * v1 + 161040;
}

unint64_t ZSTD_estimateDStreamSize_fromFrame(unsigned __int8 *a1, unint64_t a2)
{
  unint64_t result;
  uint64_t v3;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = ZSTD_getFrameHeader_advanced((uint64_t)v5, a1, a2, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    if (result)
    {
      return -72;
    }
    else
    {
      v3 = 0x20000;
      if (*((_QWORD *)&v5[0] + 1) < 0x20000uLL)
        v3 = *((_QWORD *)&v5[0] + 1);
      v4 = *((_QWORD *)&v5[0] + 1) + 2 * v3 + 161040;
      if (*((_QWORD *)&v5[0] + 1) <= 0x80000000uLL)
        return v4;
      else
        return -16;
    }
  }
  return result;
}

uint64_t ZSTD_decompressStream(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t FrameHeader_advanced;
  unint64_t v6;
  unint64_t v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  size_t v23;
  __int128 v24;
  size_t v25;
  unint64_t v26;
  size_t v27;
  size_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  size_t v31;
  size_t v32;
  unint64_t FrameSizeInfo;
  int v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  void (*v38)(uint64_t, uint64_t);
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unsigned int v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  char *v61;
  void (*v62)(_QWORD);
  uint64_t (*v63)(_QWORD, unint64_t);
  unint64_t v64;
  int v65;
  size_t v66;
  char *v67;
  int v68;
  unint64_t v69;
  size_t v70;
  unint64_t v71;
  size_t v72;
  unint64_t v73;
  uint64_t v74;
  size_t v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  uint64_t v79;
  size_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  unsigned __int8 *v87;
  unint64_t v88;
  char *v89;
  __int128 v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  int v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t DDict;
  unint64_t v99;
  _OWORD *v100;
  unint64_t v101;
  uint64_t *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  _OWORD *v107;
  char *v108;
  _QWORD *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unsigned __int8 *v114;
  uint64_t v115;
  unint64_t *v117;
  uint64_t v118;
  unsigned __int8 *v119;
  unsigned __int8 *v120;

  v4 = a3[1];
  v3 = a3[2];
  if (v3 > v4)
    return -72;
  v7 = a2[1];
  v6 = a2[2];
  if (v6 > v7)
    return -70;
  v10 = a1 + 26684;
  v11 = *a3;
  v12 = *a2;
  if (*(_DWORD *)(a1 + 29808) == 1)
  {
    if (*(_DWORD *)(a1 + 29708))
    {
      FrameHeader_advanced = -104;
      if (*(_QWORD *)(a1 + 29816) != v12 || *(_QWORD *)(a1 + 29832) != v6 || *(_QWORD *)(a1 + 29824) != v7)
        return FrameHeader_advanced;
    }
  }
  v118 = a1 + 160944;
  v112 = a3[1];
  v113 = a3[2];
  v110 = a2[1];
  v111 = a2[2];
  v13 = (char *)(v12 + v6);
  v14 = v12 + v7;
  v115 = a1 + 29816;
  v15 = (uint64_t *)(a1 + 29760);
  v117 = (unint64_t *)(a1 + 29416);
  v119 = (unsigned __int8 *)(v11 + v4);
  v101 = v4 - v3;
  v102 = (uint64_t *)(a1 + 29664);
  v109 = (_QWORD *)(a1 + 29456);
  v107 = (_OWORD *)(a1 + 29376);
  v105 = a1 + 10296;
  v106 = a1 + 32;
  v104 = a1 + 6192;
  v103 = a1 + 4136;
  v100 = (_OWORD *)(a1 + 29528);
  v114 = (unsigned __int8 *)(v11 + v3);
  v120 = (unsigned __int8 *)(v11 + v3);
  v108 = (char *)(v12 + v6);
  while (2)
  {
    while (1)
    {
      v16 = *(_DWORD *)(v10 + 3024);
      if (v16 != 4)
        break;
      v17 = *(_QWORD *)(a1 + 29768);
      v18 = *(_QWORD *)(a1 + 29760);
      v19 = v17 - v18;
      v20 = v14 - (_QWORD)v13;
      if (v14 - (uint64_t)v13 >= (unint64_t)(v17 - v18))
        v21 = v17 - v18;
      else
        v21 = v14 - (_QWORD)v13;
      if (v21)
      {
        memcpy(v13, (const void *)(*(_QWORD *)(a1 + 29744) + v18), v21);
        v18 = *(_QWORD *)(a1 + 29760);
      }
      v13 += v21;
      v22 = v18 + v21;
      *v15 = v22;
      if (v19 > v20)
        goto LABEL_172;
      *(_DWORD *)(v10 + 3024) = 2;
      v23 = *(_QWORD *)(a1 + 29752);
      if (v23 < *(_QWORD *)(a1 + 29416) && v22 + (unint64_t)*(unsigned int *)(v10 + 2748) > v23)
      {
        *v15 = 0;
        *(_QWORD *)(a1 + 29768) = 0;
      }
    }
    switch(v16)
    {
      case 0:
        *(_DWORD *)(v10 + 3024) = 1;
        *(_QWORD *)(a1 + 29728) = 0;
        *(_QWORD *)(v10 + 3112) = 0;
        *(_QWORD *)(a1 + 29768) = 0;
        *(_QWORD *)(a1 + 29776) = 0;
        *v15 = 0;
        v24 = *(_OWORD *)a2;
        *(_QWORD *)(v115 + 16) = a2[2];
        *(_OWORD *)v115 = v24;
        FrameHeader_advanced = ZSTD_getFrameHeader_advanced((uint64_t)v117, (unsigned __int8 *)v118, 0, *(_DWORD *)(v10 + 2900));
        if (*(_DWORD *)(v10 + 3020))
          goto LABEL_25;
        goto LABEL_27;
      case 1:
        FrameHeader_advanced = ZSTD_getFrameHeader_advanced((uint64_t)v117, (unsigned __int8 *)v118, *(_QWORD *)(a1 + 29776), *(_DWORD *)(v10 + 2900));
        if (*(_DWORD *)(v10 + 3020))
        {
LABEL_25:
          if (*(_QWORD *)(a1 + 29696))
            ZSTD_DCtx_selectFrameDDict(a1);
        }
LABEL_27:
        if (FrameHeader_advanced > 0xFFFFFFFFFFFFFF88)
          return FrameHeader_advanced;
        if (FrameHeader_advanced)
        {
          v25 = *(_QWORD *)(a1 + 29776);
          v26 = FrameHeader_advanced - v25;
          v27 = v119 - v120;
          if (FrameHeader_advanced - v25 > v119 - v120)
          {
            if (v119 != v120)
            {
              memcpy((void *)(v118 + v25), v120, v27);
              v25 = *(_QWORD *)(a1 + 29776) + v27;
              *(_QWORD *)(a1 + 29776) = v25;
            }
            a3[2] = a3[1];
            v88 = 2;
            if (!*(_DWORD *)(v10 + 2900))
              v88 = 6;
            if (v88 <= FrameHeader_advanced)
              v88 = FrameHeader_advanced;
            return v88 - v25 + 3;
          }
          memcpy((void *)(v118 + v25), v120, FrameHeader_advanced - v25);
          *(_QWORD *)(a1 + 29776) = FrameHeader_advanced;
          v120 += v26;
          continue;
        }
        if (*v117 == -1
          || *(_DWORD *)(v10 + 2752) == 1
          || v14 - (uint64_t)v13 < *v117
          || (FrameSizeInfo = ZSTD_findFrameSizeInfo((uint64_t)v114, v101), FrameSizeInfo > v101))
        {
          if (*(_DWORD *)(v10 + 3124) == 1
            && *(_DWORD *)(v10 + 2752) != 1
            && *v117 != -1
            && v14 - (uint64_t)v13 < *v117)
          {
            return -70;
          }
          v34 = *(_DWORD *)(v10 + 3004);
          if (v34 == -1)
            goto LABEL_46;
          if (v34 != 1)
          {
            v37 = *v102;
            if (*v102)
            {
              v38 = *(void (**)(uint64_t, uint64_t))(v37 + 27336);
              v39 = *(_QWORD *)(v37 + 27344);
              if (*(_QWORD *)v37)
              {
                if (v38)
                {
                  ((void (*)(_QWORD))v38)(*(_QWORD *)(v37 + 27344));
                  goto LABEL_54;
                }
                free(*(void **)v37);
LABEL_56:
                free((void *)v37);
              }
              else
              {
                if (!v38)
                  goto LABEL_56;
LABEL_54:
                v38(v39, v37);
              }
            }
            v35 = 0;
            *(_DWORD *)(v10 + 3004) = 0;
            v36 = 1;
            *v102 = 0;
            v102[1] = 0;
            goto LABEL_58;
          }
          *(_DWORD *)(v10 + 3004) = 0;
LABEL_46:
          v35 = *(_QWORD *)(a1 + 29672);
          if (v35)
          {
            v36 = 0;
            *(_DWORD *)(v10 + 3000) = *(_QWORD *)(a1 + 29400) != *(_QWORD *)(v35 + 8) + *(_QWORD *)(v35 + 16);
          }
          else
          {
            v36 = 1;
          }
LABEL_58:
          v40 = *(_DWORD *)(v10 + 2900);
          v41 = 5;
          if (v40)
            v41 = 1;
          *(_QWORD *)(a1 + 29408) = v41;
          *v107 = 0u;
          v107[1] = 0u;
          *v109 = 0;
          v109[1] = 0;
          *(_DWORD *)(a1 + 10296) = 201326604;
          *(_DWORD *)(v10 + 2996) = 0;
          *(_OWORD *)(a1 + 29472) = xmmword_18823D7A0;
          *(_QWORD *)v10 = 0x400000001;
          *(_DWORD *)(v10 + 8) = 8;
          *(_QWORD *)a1 = v106;
          *(_QWORD *)(a1 + 8) = v104;
          *(_QWORD *)(a1 + 16) = v103;
          *(_QWORD *)(a1 + 24) = v105;
          if ((v36 & 1) == 0)
          {
            *(_DWORD *)(v10 + 2996) = *(_DWORD *)(v35 + 27316);
            v42 = *(_QWORD *)(v35 + 8);
            v43 = *(_QWORD *)(v35 + 16);
            *(_QWORD *)(a1 + 29384) = v42;
            *(_QWORD *)(a1 + 29392) = v42;
            v44 = v42 + v43;
            *(_QWORD *)(a1 + 29400) = v44;
            *(_QWORD *)(a1 + 29376) = v44;
            if (*(_DWORD *)(v35 + 27320))
            {
              *(_QWORD *)(a1 + 29480) = 0x100000001;
              *(_QWORD *)a1 = v35 + 24;
              *(_QWORD *)(a1 + 8) = v35 + 6184;
              *(_QWORD *)(a1 + 16) = v35 + 4128;
              *(_QWORD *)(a1 + 24) = v35 + 10288;
              *(_DWORD *)v10 = *(_DWORD *)(v35 + 26676);
              *(_DWORD *)(v10 + 4) = *(_DWORD *)(v35 + 26680);
              *(_DWORD *)(v10 + 8) = *(_DWORD *)(v35 + 26684);
            }
          }
          if (*(_DWORD *)v118 >> 4 == 25481893)
          {
            v45 = *(unsigned int *)(v118 + 4);
            v46 = 7;
          }
          else
          {
            v47 = *(_QWORD *)(a1 + 29776);
            v48 = ZSTD_getFrameHeader_advanced((uint64_t)v117, (unsigned __int8 *)v118, v47, v40);
            FrameHeader_advanced = v48;
            if (v48 > 0xFFFFFFFFFFFFFF88)
              return FrameHeader_advanced;
            if (v48)
              return -72;
            if (*(_DWORD *)(v10 + 3020) == 1 && *(_QWORD *)(a1 + 29696))
              ZSTD_DCtx_selectFrameDDict(a1);
            v49 = *(_DWORD *)(v10 + 2760);
            if (v49 && *(_DWORD *)(v10 + 2996) != v49)
              return -32;
            if (*(_DWORD *)(v10 + 2764))
            {
              v50 = *(_DWORD *)(v10 + 2904);
              *(_DWORD *)(v10 + 2908) = v50 == 0;
              if (!v50)
              {
                *(_OWORD *)(a1 + 29488) = xmmword_18823D7B0;
                *(_OWORD *)(a1 + 29504) = xmmword_18823D7C0;
                *(_QWORD *)(a1 + 29520) = 0x61C8864E7A143579;
                *v100 = 0u;
                v100[1] = 0u;
                v100[2] = 0u;
              }
            }
            else
            {
              *(_DWORD *)(v10 + 2908) = 0;
            }
            *v109 += v47;
            v46 = 2;
            v45 = 3;
          }
          *(_QWORD *)(a1 + 29408) = v45;
          *(_DWORD *)(v10 + 2792) = v46;
          v51 = *(_QWORD *)(a1 + 29424);
          if (v51 <= 0x400)
            v51 = 1024;
          *(_QWORD *)(a1 + 29424) = v51;
          if (v51 > *(_QWORD *)(a1 + 29736))
            return -16;
          v52 = *(_DWORD *)(v10 + 2748);
          if (v52 <= 4)
            v53 = 4;
          else
            v53 = v52;
          if (*(_DWORD *)(v10 + 3124))
          {
            v54 = 0;
          }
          else
          {
            v55 = 0x20000;
            if (v51 < 0x20000)
              v55 = v51;
            v56 = v51 + v55 + 64;
            if (v56 >= *v117)
              v54 = *v117;
            else
              v54 = v56;
          }
          v57 = *(_QWORD *)(a1 + 29720);
          v58 = *(_QWORD *)(a1 + 29752);
          if (v58 + v57 >= 3 * (v54 + v53))
          {
            v59 = *(_QWORD *)(v118 + 24) + 1;
            *(_QWORD *)(v118 + 24) = v59;
            if (v57 < v53)
              goto LABEL_96;
          }
          else
          {
            v59 = 0;
            *(_QWORD *)(v118 + 24) = 0;
            if (v57 < v53)
              goto LABEL_96;
          }
          if (v58 < v54 || v59 >= 0x80)
          {
LABEL_96:
            v60 = *(_QWORD *)(a1 + 29648);
            if (v60)
            {
              if (v54 + v53 > v60 - 160976)
                return -64;
              v61 = *(char **)(a1 + 29712);
            }
            else
            {
              if (*(_QWORD *)(a1 + 29712))
              {
                v62 = *(void (**)(_QWORD))(a1 + 29616);
                if (v62)
                  v62(*(_QWORD *)(a1 + 29624));
                else
                  free(*(void **)(a1 + 29712));
              }
              *(_QWORD *)(a1 + 29720) = 0;
              *(_QWORD *)(a1 + 29752) = 0;
              v63 = *(uint64_t (**)(_QWORD, unint64_t))(a1 + 29608);
              if (v63)
                v61 = (char *)v63(*(_QWORD *)(a1 + 29624), v54 + v53);
              else
                v61 = (char *)malloc_type_malloc(v54 + v53, 0x26AA08A0uLL);
              *(_QWORD *)(a1 + 29712) = v61;
              if (!v61)
                return -64;
            }
            *(_QWORD *)(a1 + 29720) = v53;
            *(_QWORD *)(a1 + 29744) = &v61[v53];
            *(_QWORD *)(a1 + 29752) = v54;
          }
          *(_DWORD *)(v10 + 3024) = 2;
LABEL_109:
          v29 = v120;
          v64 = v119 - v120;
          v65 = *(_DWORD *)(v10 + 2792);
          if ((v65 - 3) >= 2 || *(_DWORD *)(v10 + 2788))
          {
            v28 = *(_QWORD *)(a1 + 29408);
            v66 = v28;
            if (!v28)
              goto LABEL_161;
          }
          else
          {
            if (v64 <= 1)
              v77 = 1;
            else
              v77 = v119 - v120;
            v28 = *(_QWORD *)(a1 + 29408);
            if (v77 >= v28)
              v66 = *(_QWORD *)(a1 + 29408);
            else
              v66 = v77;
            if (!v66)
            {
LABEL_161:
              v83 = v112;
              v82 = v113;
              v85 = v110;
              v84 = v111;
              v86 = a2;
              v87 = v114;
              goto LABEL_162;
            }
          }
          if (v64 >= v66)
          {
            if (*(_DWORD *)(v10 + 3124))
            {
              if (v65 == 7)
                v71 = 0;
              else
                v71 = v14 - (_QWORD)v13;
              v72 = ZSTD_decompressContinue(a1, v13, v71, (char *)v120, v66);
              FrameHeader_advanced = v72;
              if (v72 > 0xFFFFFFFFFFFFFF88)
                return FrameHeader_advanced;
              v13 += v72;
LABEL_157:
              v81 = 2;
              goto LABEL_158;
            }
            if (v65 == 7)
            {
              v78 = 0;
              v79 = *v15;
            }
            else
            {
              v79 = *(_QWORD *)(a1 + 29760);
              v78 = *(_QWORD *)(a1 + 29752) - v79;
            }
            v80 = ZSTD_decompressContinue(a1, (char *)(*(_QWORD *)(a1 + 29744) + v79), v78, (char *)v120, v66);
            FrameHeader_advanced = v80;
            if (v80 > 0xFFFFFFFFFFFFFF88)
              return FrameHeader_advanced;
            if (v65 != 7 && !v80)
              goto LABEL_157;
            *(_QWORD *)(a1 + 29768) = *(_QWORD *)(a1 + 29760) + v80;
            v81 = 4;
LABEL_158:
            *(_DWORD *)(v10 + 3024) = v81;
            v120 += v66;
          }
          else
          {
            if (v120 == v119)
            {
              v120 = v119;
LABEL_172:
              v83 = v112;
              v82 = v113;
              v85 = v110;
              v84 = v111;
              v86 = a2;
              v87 = v114;
              goto LABEL_173;
            }
            *(_DWORD *)(v10 + 3024) = 3;
            v30 = *(_QWORD *)(a1 + 29728);
            v31 = v28 - v30;
            if (v65 == 7)
            {
LABEL_32:
              if (v31 >= v119 - v29)
                v32 = v119 - v29;
              else
                v32 = v31;
            }
            else
            {
LABEL_115:
              if (v31 > *(_QWORD *)(a1 + 29720) - v30)
                return -20;
              if (v31 >= v119 - v29)
                v32 = v119 - v29;
              else
                v32 = v31;
              if (v32)
              {
                memcpy((void *)(*(_QWORD *)(a1 + 29712) + v30), v29, v32);
                v29 = v120;
                v30 = *(_QWORD *)(a1 + 29728);
              }
            }
            *(_QWORD *)(a1 + 29728) = v30 + v32;
            v120 = &v29[v32];
            if (v32 < v31)
              goto LABEL_172;
            *(_QWORD *)(a1 + 29728) = 0;
            v67 = *(char **)(a1 + 29712);
            v68 = *(_DWORD *)(v10 + 2792);
            if (*(_DWORD *)(v10 + 3124))
            {
              if (v68 == 7)
                v69 = 0;
              else
                v69 = v14 - (_QWORD)v13;
              v70 = ZSTD_decompressContinue(a1, v13, v69, v67, v28);
              FrameHeader_advanced = v70;
              if (v70 > 0xFFFFFFFFFFFFFF88)
                return FrameHeader_advanced;
              v13 += v70;
LABEL_140:
              v76 = 2;
              goto LABEL_141;
            }
            if (v68 == 7)
            {
              v73 = 0;
              v74 = *v15;
            }
            else
            {
              v74 = *(_QWORD *)(a1 + 29760);
              v73 = *(_QWORD *)(a1 + 29752) - v74;
            }
            v75 = ZSTD_decompressContinue(a1, (char *)(*(_QWORD *)(a1 + 29744) + v74), v73, v67, v28);
            FrameHeader_advanced = v75;
            if (v75 > 0xFFFFFFFFFFFFFF88)
              return FrameHeader_advanced;
            if (v68 != 7 && !v75)
              goto LABEL_140;
            *(_QWORD *)(a1 + 29768) = *(_QWORD *)(a1 + 29760) + v75;
            v76 = 4;
LABEL_141:
            *(_DWORD *)(v10 + 3024) = v76;
          }
          continue;
        }
        v97 = FrameSizeInfo;
        DDict = ZSTD_getDDict(a1);
        v87 = v114;
        v99 = ZSTD_decompressMultiFrame(a1, v13, v14 - (_QWORD)v13, v114, v97, 0, 0, DDict);
        FrameHeader_advanced = v99;
        v83 = v112;
        v82 = v113;
        v85 = v110;
        v84 = v111;
        v86 = a2;
        if (v99 > 0xFFFFFFFFFFFFFF88)
          return FrameHeader_advanced;
        v120 = &v114[v97];
        v13 += v99;
        *(_QWORD *)(a1 + 29408) = 0;
LABEL_162:
        *(_DWORD *)(v10 + 3024) = 0;
LABEL_173:
        a3[2] = (uint64_t)&v120[-*a3];
        v89 = &v13[-*v86];
        v86[2] = v89;
        v90 = *(_OWORD *)v86;
        *(_QWORD *)(v115 + 16) = v89;
        *(_OWORD *)v115 = v90;
        if (v120 != v87 || v13 != v108)
        {
          *(_DWORD *)(v10 + 3120) = 0;
LABEL_180:
          v92 = *(_QWORD *)(a1 + 29408);
          if (v92)
          {
            v93 = 3;
            if (*(_DWORD *)(v10 + 2792) != 3)
              v93 = 0;
            return v92 - *(_QWORD *)(a1 + 29728) + v93;
          }
          else
          {
            v95 = *(_DWORD *)(v10 + 3116);
            if (*(_QWORD *)(a1 + 29768) == *(_QWORD *)(a1 + 29760))
            {
              if (v95)
              {
                v96 = a3[2];
                if (v96 >= a3[1])
                {
                  *(_DWORD *)(v10 + 3024) = 2;
                  return 1;
                }
                else
                {
                  FrameHeader_advanced = 0;
                  a3[2] = v96 + 1;
                }
              }
              else
              {
                return 0;
              }
            }
            else
            {
              FrameHeader_advanced = 1;
              if (!v95)
              {
                --a3[2];
                *(_DWORD *)(v10 + 3116) = 1;
              }
            }
          }
          return FrameHeader_advanced;
        }
        v91 = *(_DWORD *)(v10 + 3120);
        *(_DWORD *)(v10 + 3120) = v91 + 1;
        if (v91 < 15)
          goto LABEL_180;
        if (v84 == v85)
          return -70;
        if (v82 != v83)
          goto LABEL_180;
        return -72;
      case 2:
        goto LABEL_109;
      case 3:
        v28 = *(_QWORD *)(a1 + 29408);
        v29 = v120;
        v30 = *(_QWORD *)(a1 + 29728);
        v31 = v28 - v30;
        if (*(_DWORD *)(v10 + 2792) == 7)
          goto LABEL_32;
        goto LABEL_115;
      default:
        return -1;
    }
  }
}

void ZSTD_DCtx_selectFrameDDict(uint64_t a1)
{
  _DWORD *v2;
  _QWORD *v3;
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  int v10;
  uint64_t v12;
  void (*v13)(uint64_t, uint64_t);
  uint64_t v14;
  unsigned int v15;

  if (*(_QWORD *)(a1 + 29672))
  {
    v2 = (_DWORD *)(a1 + 29444);
    v3 = *(_QWORD **)(a1 + 29696);
    v4 = *(_DWORD *)(a1 + 29444);
    v15 = v4;
    v5 = ZSTD_XXH64(&v15, 4uLL);
    v6 = v3[1] - 1;
    v7 = v6 & v5;
    do
    {
      v8 = *(_QWORD *)(*v3 + 8 * v7);
      if (!v8)
        return;
      if (*(_QWORD *)(v8 + 16) < 8uLL)
        break;
      v9 = *(_DWORD **)(v8 + 8);
      if (*v9 != -332356553)
        break;
      v10 = v9[1];
      v7 = (v7 & v6) + 1;
    }
    while (v10 != v4 && v10 != 0);
    v12 = *(_QWORD *)(a1 + 29664);
    if (!v12)
    {
LABEL_19:
      *(_QWORD *)(a1 + 29664) = 0;
      v2[59] = *v2;
      *(_QWORD *)(a1 + 29672) = v8;
      v2[61] = -1;
      return;
    }
    v13 = *(void (**)(uint64_t, uint64_t))(v12 + 27336);
    v14 = *(_QWORD *)(v12 + 27344);
    if (*(_QWORD *)v12)
    {
      if (v13)
      {
        ((void (*)(_QWORD))v13)(*(_QWORD *)(v12 + 27344));
LABEL_16:
        v13(v14, v12);
        goto LABEL_19;
      }
      free(*(void **)v12);
    }
    else if (v13)
    {
      goto LABEL_16;
    }
    free((void *)v12);
    goto LABEL_19;
  }
}

uint64_t ZSTD_decompressStream_simpleArgs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t result;
  uint64_t v10[2];
  uint64_t v11;
  _QWORD v12[2];
  uint64_t v13;

  v12[0] = a2;
  v12[1] = a3;
  v13 = *a4;
  v10[0] = a5;
  v10[1] = a6;
  v11 = *a7;
  result = ZSTD_decompressStream(a1, v12, v10);
  *a4 = v13;
  *a7 = v11;
  return result;
}

uint64_t ZSTD_decodeLiteralsBlock(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 >= 3)
    __asm { BR              X10 }
  return -20;
}

uint64_t sub_1881B028C@<X0>(unsigned __int16 *a1@<X1>, unint64_t a2@<X2>, unint64_t a3@<X8>)
{
  _QWORD *v3;
  unsigned int v4;
  size_t v5;
  uint64_t v6;
  unint64_t v7;
  _OWORD *v8;

  v4 = (a3 >> 2) & 3;
  if (v4 == 1)
  {
    v5 = (unint64_t)*a1 >> 4;
    v6 = 2;
    v7 = v5 + 2;
    if (v5 + 34 <= a2)
      goto LABEL_10;
  }
  else
  {
    if (v4 == 3)
    {
      v5 = (*a1 | ((unint64_t)*((unsigned __int8 *)a1 + 2) << 16)) >> 4;
      v6 = 3;
      v7 = v5 + 3;
      if (v5 + 35 > a2)
        goto LABEL_4;
LABEL_10:
      v3[3700] = (char *)a1 + v6;
      v3[3704] = v5;
      return v7;
    }
    v5 = a3 >> 3;
    v6 = 1;
    v7 = v5 + 1;
    if (v5 + 33 <= a2)
      goto LABEL_10;
  }
LABEL_4:
  if (v7 > a2)
    return -20;
  memcpy(v3 + 3730, (char *)a1 + v6, v5);
  v3[3700] = v3 + 3730;
  v3[3704] = v5;
  v8 = (_OWORD *)((char *)v3 + v5 + 29840);
  *v8 = 0u;
  v8[1] = 0u;
  return v7;
}

uint64_t ZSTD_decodeSeqHeaders(uint64_t a1, int *a2, unsigned __int8 *a3, uint64_t a4)
{
  unsigned __int8 *v5;
  int v6;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int *v11;
  unsigned int v12;
  unint64_t v13;
  unsigned __int8 *v14;
  unint64_t v15;
  unsigned __int8 *v16;
  unint64_t v17;

  if (!a4)
    return -72;
  v5 = a3 + 1;
  v6 = *a3;
  if (*a3)
  {
    if ((v6 & 0x80) != 0)
    {
      if (v6 == 255)
      {
        if (a4 < 3)
          return -72;
        v5 = a3 + 3;
        v6 = *(unsigned __int16 *)(a3 + 1) + 32512;
      }
      else
      {
        if (a4 < 2)
          return -72;
        v5 = a3 + 2;
        v6 = (a3[1] | (v6 << 8)) - 0x8000;
      }
    }
    v8 = &a3[a4];
    *a2 = v6;
    v9 = v5 + 1;
    if (v5 + 1 > &a3[a4])
      return -72;
    v11 = (int *)(a1 + 29484);
    v12 = *v5;
    v13 = ZSTD_buildSeqTable(a1 + 32, (_QWORD *)a1, v12 >> 6, 0x23u, 9u, v9, v8 - v9, (uint64_t)&LL_base, (uint64_t)LL_bits, (uint64_t)&LL_defaultDTable, *(_DWORD *)(a1 + 29484), *(_DWORD *)(a1 + 29684), v6, a1 + 27324);
    if (v13 > 0xFFFFFFFFFFFFFF88)
      return -20;
    v14 = &v9[v13];
    v15 = ZSTD_buildSeqTable(a1 + 4136, (_QWORD *)(a1 + 16), (v12 >> 4) & 3, 0x1Fu, 8u, v14, v8 - v14, (uint64_t)&OF_base, (uint64_t)&OF_bits, (uint64_t)&OF_defaultDTable, *v11, *(_DWORD *)(a1 + 29684), v6, a1 + 27324);
    if (v15 > 0xFFFFFFFFFFFFFF88)
      return -20;
    v16 = &v14[v15];
    v17 = ZSTD_buildSeqTable(a1 + 6192, (_QWORD *)(a1 + 8), (v12 >> 2) & 3, 0x34u, 9u, v16, v8 - v16, (uint64_t)&ML_base, (uint64_t)ML_bits, (uint64_t)&ML_defaultDTable, *v11, *(_DWORD *)(a1 + 29684), v6, a1 + 27324);
    if (v17 > 0xFFFFFFFFFFFFFF88)
      return -20;
    else
      return &v16[v17] - a3;
  }
  else
  {
    *a2 = 0;
    if (a4 == 1)
      return 1;
    else
      return -72;
  }
}

uint64_t ZSTD_buildSeqTable(uint64_t a1, _QWORD *a2, int a3, unsigned int a4, unsigned int a5, _DWORD *a6, size_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, int a12, int a13, uint64_t a14)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v24;
  unsigned int v32;
  unsigned int v33;
  _BYTE v34[106];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v33 = a4;
  switch(a3)
  {
    case 0:
      v18 = 0;
      *a2 = a10;
      break;
    case 1:
      if (a7)
      {
        v19 = *(unsigned __int8 *)a6;
        if (v19 > a4)
          goto LABEL_18;
        v20 = 4 * v19;
        v21 = *(_DWORD *)(a8 + v20);
        LOBYTE(v20) = *(_DWORD *)(a9 + v20);
        *(_QWORD *)a1 = 0;
        *(_BYTE *)(a1 + 11) = 0;
        *(_WORD *)(a1 + 8) = 0;
        *(_BYTE *)(a1 + 10) = v20;
        *(_DWORD *)(a1 + 12) = v21;
        *a2 = a1;
        v18 = 1;
      }
      else
      {
        v18 = -72;
      }
      break;
    case 2:
      v32 = 0;
      v22 = FSE_readNCount_bmi2(v34, &v33, &v32, a6, a7);
      if (v22 > 0xFFFFFFFFFFFFFF88 || v32 > a5)
        goto LABEL_18;
      v18 = v22;
      ZSTD_buildFSETable((int *)a1, (uint64_t)v34, v33, a8, a9, v32, a14);
      *a2 = a1;
      break;
    case 3:
      if (a11)
      {
        if (a12)
          v23 = a13 < 25;
        else
          v23 = 1;
        if (!v23)
        {
          v24 = 0;
          do
          {
            _X11 = *a2 + v24;
            __asm { PRFM            #2, [X11] }
            v24 += 64;
          }
          while (v24 < 8 * (unint64_t)((1 << a5) + 1));
        }
        v18 = 0;
      }
      else
      {
LABEL_18:
        v18 = -20;
      }
      break;
    default:
      v18 = -1;
      break;
  }
  return v18;
}

unint64_t ZSTD_decompressSequences(uint64_t *a1, char *__dst, uint64_t a3, unsigned __int8 *a4, unint64_t a5, int a6)
{
  char *v6;
  char *v7;
  __int128 *v8;
  unint64_t v9;
  int v10;
  char *v11;
  uint64_t v12;
  int64x2_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;
  char *v18;
  size_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unint64_t v35;
  unsigned __int8 *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  unint64_t v39;
  unsigned __int16 *v40;
  uint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  unsigned __int16 *v45;
  uint64_t v46;
  int v47;
  int v48;
  size_t v49;
  unsigned __int16 *v50;
  uint64_t v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  BOOL v59;
  unsigned int v60;
  unint64_t v61;
  char v62;
  uint64_t v63;
  int v64;
  int v65;
  unint64_t v66;
  __int128 *v67;
  __int128 *v68;
  unint64_t v69;
  char *v70;
  char *v71;
  unsigned int *v72;
  unint64_t v73;
  uint64_t v74;
  const void *v75;
  char *v76;
  size_t v77;
  char *v78;
  __int128 v79;
  unsigned int v80;
  unint64_t v81;
  uint64_t v82;
  _QWORD *v83;
  int v84;
  char *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  _QWORD *v89;
  char *v90;
  __int128 *v91;
  __int128 v92;
  uint64_t v93;
  char *v94;
  unint64_t v95;
  uint64_t v96;
  char *v97;
  __int128 *v98;
  char *v99;
  uint64_t v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  int32x2_t *v105;
  char *v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  uint64_t v110;
  unint64_t v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  int64x2_t v117[3];
  uint64_t v118;
  __int128 *v119;
  uint64_t v120[5];

  v6 = __dst;
  v7 = &__dst[a3];
  v8 = (__int128 *)a1[3700];
  v119 = v8;
  v9 = (unint64_t)v8 + a1[3704];
  if (!a6)
  {
    v18 = v6;
    v19 = a1[3704];
    if (v19 <= v7 - v6)
      goto LABEL_133;
    return -70;
  }
  v10 = a6;
  v11 = (char *)a1[3673];
  v109 = a1[3675];
  v110 = a1[3674];
  v116 = 0u;
  memset(v117, 0, sizeof(v117));
  v114 = 0u;
  v115 = 0u;
  v112 = 0u;
  v113 = 0u;
  *((_DWORD *)a1 + 7371) = 1;
  v12 = *(uint64_t *)((char *)a1 + 26684);
  v13.i64[0] = v12;
  v13.i64[1] = HIDWORD(v12);
  *(int64x2_t *)((char *)v117 + 8) = v13;
  v14 = *((unsigned int *)a1 + 6673);
  v118 = 0;
  v117[1].i64[1] = v14;
  if (!a5)
    return -20;
  *((_QWORD *)&v113 + 1) = a4;
  *(_QWORD *)&v114 = a4 + 8;
  v15 = a5 - 8;
  if (a5 >= 8)
  {
    v16 = *(_QWORD *)&a4[v15];
    *(_QWORD *)&v113 = &a4[v15];
    *(_QWORD *)&v112 = v16;
    if (HIBYTE(v16) && a5 <= 0xFFFFFFFFFFFFFF88)
    {
      v105 = (int32x2_t *)((char *)a1 + 26684);
      v106 = v6;
      v107 = (uint64_t)v7;
      v17 = __clz(HIBYTE(v16)) - 23;
      goto LABEL_18;
    }
    return -20;
  }
  v16 = *a4;
  *(_QWORD *)&v113 = a4;
  *(_QWORD *)&v112 = v16;
  switch(a5)
  {
    case 2uLL:
      goto LABEL_15;
    case 3uLL:
      goto LABEL_14;
    case 4uLL:
      goto LABEL_13;
    case 5uLL:
      goto LABEL_12;
    case 6uLL:
      goto LABEL_11;
    case 7uLL:
      v16 |= (unint64_t)a4[6] << 48;
LABEL_11:
      v16 += (unint64_t)a4[5] << 40;
LABEL_12:
      v16 += (unint64_t)a4[4] << 32;
LABEL_13:
      v16 += (unint64_t)a4[3] << 24;
LABEL_14:
      v16 += (unint64_t)a4[2] << 16;
LABEL_15:
      v16 += (unint64_t)a4[1] << 8;
      *(_QWORD *)&v112 = v16;
      break;
    default:
      break;
  }
  if (!a4[a5 - 1])
    return -20;
  v105 = (int32x2_t *)((char *)a1 + 26684);
  v106 = v6;
  v107 = (uint64_t)v7;
  v15 = 0;
  v17 = __clz(a4[a5 - 1]) - 8 * a5 + 41;
  DWORD2(v112) = v17;
LABEL_18:
  v21 = *a1;
  v22 = *(unsigned int *)(*a1 + 4);
  v23 = v22 + v17;
  v24 = BIT_mask;
  *((_QWORD *)&v114 + 1) = (v16 >> -(char)v23) & BIT_mask[v22];
  if (v23 > 0x40)
    goto LABEL_27;
  if (v15 >= 8)
  {
    v15 -= v23 >> 3;
    *(_QWORD *)&v113 = &a4[v15];
    v23 &= 7u;
  }
  else
  {
    if (!v15)
      goto LABEL_27;
    v25 = v23 >> 3;
    if (&a4[v15 - v25] >= a4)
      v26 = v25;
    else
      v26 = v15;
    v15 -= v26;
    *(_QWORD *)&v113 = &a4[v15];
    v23 -= 8 * v26;
  }
  v16 = *(_QWORD *)&a4[v15];
  *(_QWORD *)&v112 = v16;
LABEL_27:
  *(_QWORD *)&v115 = v21 + 8;
  v27 = a1[2];
  v28 = *(unsigned int *)(v27 + 4);
  v29 = v28 + v23;
  *((_QWORD *)&v115 + 1) = (v16 >> -(char)v29) & BIT_mask[v28];
  if (v29 > 0x40)
    goto LABEL_36;
  if (v15 >= 8)
  {
    v15 -= v29 >> 3;
    *(_QWORD *)&v113 = &a4[v15];
    v29 &= 7u;
  }
  else
  {
    if (!v15)
      goto LABEL_36;
    v30 = v29 >> 3;
    if (&a4[v15 - v30] >= a4)
      v31 = v30;
    else
      v31 = v15;
    v15 -= v31;
    *(_QWORD *)&v113 = &a4[v15];
    v29 -= 8 * v31;
  }
  v16 = *(_QWORD *)&a4[v15];
  *(_QWORD *)&v112 = v16;
LABEL_36:
  *(_QWORD *)&v116 = v27 + 8;
  v32 = a1[1];
  v33 = *(unsigned int *)(v32 + 4);
  v34 = v33 + v29;
  v35 = (v16 >> -(char)v34) & BIT_mask[v33];
  DWORD2(v112) = v34;
  *((_QWORD *)&v116 + 1) = v35;
  if (v34 <= 0x40)
  {
    v36 = &a4[v15];
    if (v15 >= 8)
    {
      v38 = &v36[-(v34 >> 3)];
      *(_QWORD *)&v113 = v38;
      v34 &= 7u;
LABEL_44:
      DWORD2(v112) = v34;
      *(_QWORD *)&v112 = *(_QWORD *)v38;
      goto LABEL_45;
    }
    if (v15)
    {
      v37 = v34 >> 3;
      if (&v36[-v37] >= a4)
        v37 = v37;
      else
        v37 = v15;
      v38 = &v36[-v37];
      *(_QWORD *)&v113 = &v36[-v37];
      v34 -= 8 * v37;
      goto LABEL_44;
    }
  }
LABEL_45:
  v20 = 0;
  v117[0].i64[0] = v32 + 8;
  v18 = v106;
  v39 = v107 - 32;
  v108 = v9;
  do
  {
    v40 = (unsigned __int16 *)(v115 + 8 * *((_QWORD *)&v114 + 1));
    v41 = *v40;
    v42 = *((unsigned __int8 *)v40 + 2);
    v43 = *((unsigned __int8 *)v40 + 3);
    v44 = *((unsigned int *)v40 + 1);
    v45 = (unsigned __int16 *)(v117[0].i64[0] + 8 * *((_QWORD *)&v116 + 1));
    v46 = *v45;
    v47 = *((unsigned __int8 *)v45 + 2);
    v48 = *((unsigned __int8 *)v45 + 3);
    v49 = *((unsigned int *)v45 + 1);
    v50 = (unsigned __int16 *)(v116 + 8 * *((_QWORD *)&v115 + 1));
    v51 = *v50;
    v52 = *((unsigned __int8 *)v50 + 2);
    v53 = *((unsigned __int8 *)v50 + 3);
    v54 = *((unsigned int *)v50 + 1);
    if (v52 < 2)
    {
      if (!v52)
      {
        if ((_DWORD)v44)
        {
          v56 = v117[0].u64[1];
          if (!v47)
            goto LABEL_49;
          goto LABEL_48;
        }
        v56 = v117[1].u64[0];
LABEL_123:
        v102 = v117[0].i64[1];
        v117[0].i64[1] = v56;
        v117[1].i64[0] = v102;
        if (!v47)
          goto LABEL_49;
LABEL_48:
        v57 = (_QWORD)v112 << v34 >> -(char)v47;
        v34 += v47;
        v49 += v57;
        goto LABEL_49;
      }
      if ((_DWORD)v44)
        v54 = v54;
      else
        v54 = (v54 + 1);
      v95 = (_QWORD)v112 << v34++;
      DWORD2(v112) = v34;
      v96 = v54 + (v95 >> 63);
      if (v96 == 3)
      {
        if (v117[0].i64[1] == 1)
          v56 = 1;
        else
          v56 = v117[0].i64[1] - 1;
      }
      else
      {
        if (v117[0].i64[v96 + 1])
          v56 = v117[0].u64[v96 + 1];
        else
          v56 = 1;
        if (v96 == 1)
          goto LABEL_123;
      }
      v117[1].i64[1] = v117[1].i64[0];
      goto LABEL_123;
    }
    v55 = (_QWORD)v112 << v34 >> -(char)v52;
    v34 += v52;
    v56 = v55 + v54;
    v117[1] = *(int64x2_t *)((char *)v117 + 8);
    v117[0].i64[1] = v55 + v54;
    if (v47)
      goto LABEL_48;
LABEL_49:
    if ((v47 + v42 + v52) < 0x1Fu || v34 > 0x40)
      goto LABEL_50;
    if ((unint64_t)v113 >= (unint64_t)v114)
    {
      v89 = (_QWORD *)(v113 - (v34 >> 3));
      *(_QWORD *)&v113 = v89;
      v34 &= 7u;
    }
    else
    {
      if ((_QWORD)v113 == *((_QWORD *)&v113 + 1))
        goto LABEL_50;
      v87 = v34 >> 3;
      if ((unint64_t)(v113 - v87) >= *((_QWORD *)&v113 + 1))
        v88 = v87;
      else
        v88 = (v113 - DWORD2(v113));
      v89 = (_QWORD *)(v113 - v88);
      *(_QWORD *)&v113 = v113 - v88;
      v34 -= 8 * v88;
    }
    *(_QWORD *)&v112 = *v89;
LABEL_50:
    v58 = ((_QWORD)v112 << v34 >> -(char)v42) + v44;
    v59 = v42 == 0;
    if (v42)
      v60 = v34 + v42;
    else
      v60 = v34;
    if (v59)
      v61 = v44;
    else
      v61 = v58;
    v62 = v60 + v43;
    v63 = (((unint64_t)v112 >> -(char)(v60 + v43)) & v24[v43]) + v41;
    v64 = v60 + v43 + v48;
    *((_QWORD *)&v116 + 1) = (((unint64_t)v112 >> -(char)(v62 + v48)) & v24[v48]) + v46;
    v65 = v64 + v53;
    v66 = ((unint64_t)v112 >> -(char)(v64 + v53)) & v24[v53];
    DWORD2(v112) = v65;
    *((_QWORD *)&v114 + 1) = v63;
    *((_QWORD *)&v115 + 1) = v66 + v51;
    v67 = v119;
    v68 = (__int128 *)((char *)v119 + v61);
    if ((unint64_t)v119 + v61 > v9 || (v69 = v61 + v49, (unint64_t)&v18[v61 + v49] > v39))
    {
      v120[0] = v61;
      v120[1] = v49;
      v120[2] = v56;
      v120[3] = 0;
      v85 = v11;
      v86 = ZSTD_execSequenceEnd(v18, v107, v120, &v119, v9, v11, v110, v109);
      v11 = v85;
      v9 = v108;
      v69 = v86;
      goto LABEL_72;
    }
    v70 = &v18[v61];
    *(_OWORD *)v18 = *v119;
    if (v61 > 0x10)
    {
      v90 = v18 + 16;
      v91 = v67 + 1;
      do
      {
        v92 = *v91++;
        *(_OWORD *)v90 = v92;
        v90 += 16;
      }
      while (v90 < v70);
    }
    v71 = &v70[-v56];
    v119 = v68;
    if (v56 > v70 - v11)
    {
      if (v56 > (unint64_t)&v70[-v110])
      {
        v69 = -20;
        goto LABEL_72;
      }
      v111 = v20;
      v72 = v24;
      v73 = v39;
      v74 = v71 - v11;
      v75 = (const void *)(v109 + v71 - v11);
      v76 = v11;
      if ((unint64_t)v75 + v49 <= v109)
      {
        memmove(v70, v75, v49);
        v9 = v108;
        v39 = v73;
        v24 = v72;
        v11 = v76;
        v20 = v111;
        goto LABEL_72;
      }
      v77 = v49;
      memmove(v70, v75, v11 - v71);
      v70 -= v74;
      v49 = v74 + v77;
      v71 = v76;
      v9 = v108;
      v39 = v73;
      v24 = v72;
      v11 = v76;
      v20 = v111;
    }
    if (v56 < 0x10)
    {
      if (v56 > 7)
      {
        *(_QWORD *)v70 = *(_QWORD *)v71;
      }
      else
      {
        v93 = ZSTD_overlapCopy8_dec64table[v56];
        *v70 = *v71;
        v70[1] = v71[1];
        v70[2] = v71[2];
        v70[3] = v71[3];
        v94 = &v71[ZSTD_overlapCopy8_dec32table[v56]];
        *((_DWORD *)v70 + 1) = *(_DWORD *)v94;
        v71 = &v94[-v93];
      }
      if (v49 >= 9)
      {
        v97 = v70 + 8;
        v98 = (__int128 *)(v71 + 8);
        v99 = &v70[v49];
        if (v70 + 8 - (char *)v98 >= 16)
        {
          do
          {
            v101 = *v98++;
            *(_OWORD *)v97 = v101;
            v97 += 16;
          }
          while (v97 < v99);
        }
        else
        {
          do
          {
            v100 = *(_QWORD *)v98;
            v98 = (__int128 *)((char *)v98 + 8);
            *(_QWORD *)v97 = v100;
            v97 += 8;
          }
          while (v97 < v99);
        }
      }
    }
    else
    {
      v78 = &v70[v49];
      do
      {
        v79 = *(_OWORD *)v71;
        v71 += 16;
        *(_OWORD *)v70 = v79;
        v70 += 16;
      }
      while (v70 < v78);
    }
LABEL_72:
    v80 = DWORD2(v112);
    if (DWORD2(v112) > 0x40)
      goto LABEL_81;
    if ((unint64_t)v113 >= (unint64_t)v114)
    {
      v83 = (_QWORD *)(v113 - ((unint64_t)DWORD2(v112) >> 3));
      *(_QWORD *)&v113 = v83;
      v80 = BYTE8(v112) & 7;
    }
    else
    {
      if ((_QWORD)v113 == *((_QWORD *)&v113 + 1))
        goto LABEL_81;
      v81 = (unint64_t)DWORD2(v112) >> 3;
      if ((unint64_t)v113 - v81 >= *((_QWORD *)&v113 + 1))
        v82 = v81;
      else
        v82 = (v113 - DWORD2(v113));
      v83 = (_QWORD *)(v113 - v82);
      *(_QWORD *)&v113 = v113 - v82;
      v80 = DWORD2(v112) - 8 * v82;
    }
    DWORD2(v112) = v80;
    *(_QWORD *)&v112 = *v83;
LABEL_81:
    v18 += v69;
    v84 = v10 - 1;
    if (v69 >= 0xFFFFFFFFFFFFFF89)
      v20 = v69;
    else
      --v10;
    if (v69 > 0xFFFFFFFFFFFFFF88)
      break;
    v34 = v80;
  }
  while (v84);
  if (v20 <= 0xFFFFFFFFFFFFFF88)
  {
    if (v10)
      return -20;
    if (v80 > 0x40
      || (v20 = -20, v80 == 64)
      && (unint64_t)v113 < (unint64_t)v114
      && (_QWORD)v113 == *((_QWORD *)&v113 + 1))
    {
      v6 = v106;
      *v105 = vmovn_s64(*(int64x2_t *)((char *)v117 + 8));
      v105[1].i32[0] = v117[1].i32[2];
      v8 = v119;
      v19 = v9 - (_QWORD)v119;
      if (v9 - (unint64_t)v119 <= v107 - (uint64_t)v18)
      {
LABEL_133:
        if (v18)
        {
          memcpy(v18, v8, v19);
          v103 = &v18[v19];
        }
        else
        {
          v103 = 0;
        }
        return v103 - v6;
      }
      return -70;
    }
  }
  return v20;
}

uint64_t ZSTD_decompressBlock(_QWORD *a1, char *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  char *v7;
  uint64_t result;

  if (a3)
  {
    v7 = (char *)a1[3672];
    if (v7 != a2)
    {
      a1[3675] = v7;
      a1[3674] = &a2[a1[3673] - (_QWORD)v7];
      a1[3673] = a2;
      a1[3672] = a2;
    }
  }
  result = ZSTD_decompressBlock_internal((uint64_t)a1, a2, a3, a4, a5, 0);
  a1[3672] = &a2[result];
  return result;
}

uint64_t COVER_sum(int64x2_t *a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  int64x2_t *v5;
  int64x2_t v6;
  uint64_t v7;
  int64x2_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  if (!a2)
    return 0;
  if (a2 >= 4)
  {
    v2 = a2 & 0xFFFFFFFC;
    v5 = a1 + 1;
    v6 = 0uLL;
    v7 = v2;
    v8 = 0uLL;
    do
    {
      v6 = vaddq_s64(v5[-1], v6);
      v8 = vaddq_s64(*v5, v8);
      v5 += 2;
      v7 -= 4;
    }
    while (v7);
    v3 = vaddvq_s64(vaddq_s64(v8, v6));
    if (v2 == a2)
      return v3;
  }
  else
  {
    v2 = 0;
    v3 = 0;
  }
  v9 = &a1->i64[v2];
  v10 = a2 - v2;
  do
  {
    v11 = *v9++;
    v3 += v11;
    --v10;
  }
  while (v10);
  return v3;
}

unint64_t COVER_warnOnSmallCorpus(unint64_t result, unint64_t a2, int a3)
{
  FILE **v3;

  if (a3 >= 1 && (double)a2 / (double)result < 10.0)
  {
    v3 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/size(dictionary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend training on sources at least 10x, and preferably 100x the size of the dictionary! \n", result, a2, (double)a2 / (double)result);
    return fflush(*v3);
  }
  return result;
}

unint64_t COVER_computeEpochs(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  v4 = 10 * a3;
  if (a1 / a3 >= a4)
  {
    v5 = a1 / a3 / a4;
    v6 = a2 / v5;
    if (v6 >= v4)
      return v5 | (unint64_t)(v6 << 32);
  }
  else
  {
    v5 = 1;
    v6 = a2;
    if (a2 >= v4)
      return v5 | (unint64_t)(v6 << 32);
  }
  if (v4 >= a2)
    v6 = a2;
  else
    v6 = v4;
  v5 = a2 / v6;
  return v5 | (unint64_t)(v6 << 32);
}

uint64_t ZDICT_trainFromBuffer_cover(char *a1, size_t a2, uint64_t a3, int64x2_t *a4, uint64_t a5, unsigned int *a6)
{
  int v7;
  unsigned int v8;
  size_t v11;
  BOOL v12;
  FILE **v13;
  unint64_t v14;
  FILE **v15;
  FILE **v16;
  FILE **v20;
  unsigned int v21;
  size_t v22;
  void *v23;
  void *v24;
  FILE **v25;
  __int128 v26;
  size_t v27;
  uint64_t v28;
  FILE **v29;
  FILE **v30;
  _OWORD v32[3];
  void *v33;
  unsigned int v34;
  _BYTE v35[12];
  void *v36[2];
  __int128 v37;
  __int128 v38;
  void *v39[2];
  void *v40[2];
  uint64_t v41;

  *((_QWORD *)a6 + 2) = 0x3FF0000000000000;
  v7 = a6[9];
  g_displayLevel = v7;
  v8 = a6[1];
  if (!v8 || ((v11 = *a6, v8 <= v11) ? (v12 = v11 > a2) : (v12 = 1), v12))
  {
    if (v7 >= 1)
    {
      v13 = (FILE **)MEMORY[0x1E0C80C10];
      fwrite("Cover parameters incorrect\n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      fflush(*v13);
    }
    return -42;
  }
  else if ((_DWORD)a5)
  {
    if (a2 > 0xFF)
    {
      v41 = 0;
      *(_OWORD *)v39 = 0u;
      *(_OWORD *)v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      *(_OWORD *)v36 = 0u;
      v14 = COVER_ctx_init((uint64_t)v36, a3, a4, a5, v8, 1.0);
      if (v14 <= 0xFFFFFFFFFFFFFF88)
      {
        if (g_displayLevel >= 1 && (double)(unint64_t)v39[1] / (double)a2 < 10.0)
        {
          v20 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/size(dictionary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend training on sources at least 10x, and preferably 100x the size of the dictionary! \n", a2, LODWORD(v39[1]), (double)(unint64_t)v39[1] / (double)a2);
          fflush(*v20);
        }
        *(_QWORD *)&v35[4] = 0;
        v21 = __clz(*a6 - a6[1] + 1) ^ 0x1F;
        v34 = v21 + 2;
        *(_QWORD *)v35 = (4 << v21);
        *(_QWORD *)&v35[4] = ((4 << v21) - 1);
        v22 = 8 * (4 << v21);
        v23 = malloc_type_malloc(v22, 0x100004000313F17uLL);
        v33 = v23;
        if (v23)
        {
          v24 = v23;
          memset(v23, 255, v22);
          if (g_displayLevel >= 2)
          {
            v25 = (FILE **)MEMORY[0x1E0C80C10];
            fwrite("Building dictionary\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
            fflush(*v25);
          }
          v26 = *((_OWORD *)a6 + 1);
          v32[0] = *(_OWORD *)a6;
          v32[1] = v26;
          v32[2] = *((_OWORD *)a6 + 2);
          v27 = COVER_buildDictionary((uint64_t)v36, (uint64_t)v40[0], (uint64_t)&v33, (uint64_t)a1, a2, (int *)v32);
          v14 = ZDICT_finalizeDictionary(a1, a2, (unsigned int *)&a1[v27], a2 - v27, a3, (uint64_t)a4, a5, v28, *((_QWORD *)a6 + 4), HIDWORD(*((_QWORD *)a6 + 4)), a6[10]);
          if (v14 <= 0xFFFFFFFFFFFFFF88 && g_displayLevel >= 2)
          {
            v29 = (FILE **)MEMORY[0x1E0C80C10];
            fprintf((FILE *)*MEMORY[0x1E0C80C10], "Constructed dictionary of size %u\n", v14);
            fflush(*v29);
          }
          if (v39[0])
          {
            free(v39[0]);
            v39[0] = 0;
          }
          if (v40[0])
          {
            free(v40[0]);
            v40[0] = 0;
          }
          if (v40[1])
          {
            free(v40[1]);
            v40[1] = 0;
          }
          if (v36[1])
          {
            free(v36[1]);
            v36[1] = 0;
          }
          free(v24);
        }
        else
        {
          if (g_displayLevel >= 1)
          {
            v30 = (FILE **)MEMORY[0x1E0C80C10];
            fwrite("Failed to allocate dmer map: out of memory\n", 0x2BuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
            fflush(*v30);
          }
          if (v39[0])
          {
            free(v39[0]);
            v39[0] = 0;
          }
          if (v40[0])
          {
            free(v40[0]);
            v40[0] = 0;
          }
          if (v40[1])
          {
            free(v40[1]);
            v40[1] = 0;
          }
          if (v36[1])
            free(v36[1]);
          return -64;
        }
      }
    }
    else
    {
      if (v7 >= 1)
      {
        v15 = (FILE **)MEMORY[0x1E0C80C10];
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "dictBufferCapacity must be at least %u\n", 256);
        fflush(*v15);
      }
      return -70;
    }
  }
  else
  {
    if (v7 >= 1)
    {
      v16 = (FILE **)MEMORY[0x1E0C80C10];
      fwrite("Cover must have at least one input file\n", 0x28uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      fflush(*v16);
    }
    return -72;
  }
  return v14;
}

uint64_t COVER_ctx_init(uint64_t a1, uint64_t a2, int64x2_t *a3, unsigned int a4, unsigned int a5, double a6)
{
  uint64_t *v8;
  uint64_t v10;
  unint64_t v11;
  int64x2_t *v12;
  int64x2_t v13;
  uint64_t v14;
  int64x2_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int64x2_t *v26;
  int64x2_t v27;
  uint64_t v28;
  int64x2_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  int64x2_t *v34;
  int64x2_t v35;
  uint64_t v36;
  int64x2_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  unint64_t v41;
  FILE **v43;
  uint64_t result;
  FILE **v45;
  uint64_t v46;
  unsigned int v47;
  _QWORD *v48;
  int32x4_t *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  FILE **v55;
  size_t v56;
  BOOL v57;
  unint64_t v58;
  unsigned __int32 i;
  int (__cdecl *v60)(const void *, const void *);
  FILE **v61;
  unsigned int *v62;
  unint64_t v63;
  uint64_t (*v64)(uint64_t, unsigned int *, unsigned int *);
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int *v69;
  int v70;
  uint64_t v71;
  unint64_t v72;
  int v73;
  unint64_t *v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t *v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t *v82;
  unint64_t *v83;
  unint64_t v84;
  FILE **v85;
  void *v86;
  void *v87;
  void *v88;
  int32x4_t v89;
  int32x4_t *v90;
  int32x4_t v91;
  int32x4_t v92;
  unint64_t v93;
  uint64_t v94;

  v8 = (uint64_t *)a3;
  if (a4)
  {
    if (a4 >= 4)
    {
      v10 = a4 & 0xFFFFFFFC;
      v12 = a3 + 1;
      v13 = 0uLL;
      v14 = v10;
      v15 = 0uLL;
      do
      {
        v13 = vaddq_s64(v12[-1], v13);
        v15 = vaddq_s64(*v12, v15);
        v12 += 2;
        v14 -= 4;
      }
      while (v14);
      v11 = vaddvq_s64(vaddq_s64(v15, v13));
      if (v10 == a4)
        goto LABEL_10;
    }
    else
    {
      v10 = 0;
      v11 = 0;
    }
    v16 = a4 - v10;
    v17 = &a3->i64[v10];
    do
    {
      v18 = *v17++;
      v11 += v18;
      --v16;
    }
    while (v16);
  }
  else
  {
    v11 = 0;
  }
LABEL_10:
  v19 = ((double)a4 * a6);
  if (a6 >= 1.0)
    v20 = 0;
  else
    v20 = ((double)a4 * a6);
  v21 = a4 - v20;
  if (a6 >= 1.0)
    v22 = a4;
  else
    v22 = v19;
  v23 = v11;
  v24 = v11;
  if (a6 >= 1.0)
    goto LABEL_35;
  if (!(_DWORD)v19)
  {
    v19 = 0;
    v23 = 0;
    goto LABEL_26;
  }
  if (v19 < 4)
  {
    v25 = 0;
    v23 = 0;
LABEL_24:
    v30 = v19 - v25;
    v31 = &a3->i64[v25];
    do
    {
      v32 = *v31++;
      v23 += v32;
      --v30;
    }
    while (v30);
    goto LABEL_26;
  }
  v25 = v19 & 0xFFFFFFFC;
  v26 = a3 + 1;
  v27 = 0uLL;
  v28 = v25;
  v29 = 0uLL;
  do
  {
    v27 = vaddq_s64(v26[-1], v27);
    v29 = vaddq_s64(*v26, v29);
    v26 += 2;
    v28 -= 4;
  }
  while (v28);
  v23 = vaddvq_s64(vaddq_s64(v29, v27));
  if (v25 != v19)
    goto LABEL_24;
LABEL_26:
  if (a4 == v20)
  {
    v24 = 0;
  }
  else
  {
    if (v21 >= 4)
    {
      v33 = v21 & 0xFFFFFFFC;
      v34 = (int64x2_t *)((char *)a3 + 8 * v19 + 16);
      v35 = 0uLL;
      v36 = v33;
      v37 = 0uLL;
      do
      {
        v35 = vaddq_s64(v34[-1], v35);
        v37 = vaddq_s64(*v34, v37);
        v34 += 2;
        v36 -= 4;
      }
      while (v36);
      v24 = vaddvq_s64(vaddq_s64(v37, v35));
      if (v33 == v21)
        goto LABEL_35;
    }
    else
    {
      v33 = 0;
      v24 = 0;
    }
    v38 = v21 - v33;
    v39 = &a3->i64[v19 + v33];
    do
    {
      v40 = *v39++;
      v24 += v40;
      --v38;
    }
    while (v38);
  }
LABEL_35:
  if (a5 <= 8)
    v41 = 8;
  else
    v41 = a5;
  if (v11 < v41 || v11 >= 0xFFFFFFFF)
  {
    if (g_displayLevel >= 1)
    {
      v43 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "Total samples size is too large (%u MB), maximum size is %u MB\n");
LABEL_51:
      fflush(*v43);
    }
    return -72;
  }
  if (v22 <= 4)
  {
    if (g_displayLevel >= 1)
    {
      v43 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "Total number of training samples is %u and is invalid.");
      goto LABEL_51;
    }
    return -72;
  }
  if (a4 == v20)
  {
    if (g_displayLevel >= 1)
    {
      v43 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "Total number of testing samples is %u and is invalid.");
      goto LABEL_51;
    }
    return -72;
  }
  *(_QWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  if (g_displayLevel >= 2)
  {
    v45 = (FILE **)MEMORY[0x1E0C80C10];
    v94 = a2;
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "Training on %u samples of total size %u\n", v22, v23);
    fflush(*v45);
    a2 = v94;
    if (g_displayLevel >= 2)
    {
      fprintf(*v45, "Testing on %u samples of total size %u\n", v21, v24);
      fflush(*v45);
      a2 = v94;
    }
  }
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 24) = a4;
  *(_QWORD *)(a1 + 32) = v22;
  *(_QWORD *)(a1 + 40) = v21;
  v46 = v23 - v41 + 1;
  *(_QWORD *)(a1 + 56) = v46;
  *(_QWORD *)(a1 + 48) = malloc_type_malloc(4 * v46, 0x100004052888210uLL);
  *(_QWORD *)(a1 + 72) = malloc_type_malloc(4 * *(_QWORD *)(a1 + 56), 0x100004052888210uLL);
  v47 = a4 + 1;
  v48 = malloc_type_malloc(8 * (a4 + 1), 0x100004000313F17uLL);
  *(_QWORD *)(a1 + 8) = v48;
  v49 = *(int32x4_t **)(a1 + 48);
  if (!v49 || !*(_QWORD *)(a1 + 72) || !v48)
  {
    if (g_displayLevel >= 1)
    {
      v85 = (FILE **)MEMORY[0x1E0C80C10];
      fwrite("Failed to allocate scratch buffers\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      fflush(*v85);
      v49 = *(int32x4_t **)(a1 + 48);
    }
    if (v49)
    {
      free(v49);
      *(_QWORD *)(a1 + 48) = 0;
    }
    v86 = *(void **)(a1 + 64);
    if (v86)
    {
      free(v86);
      *(_QWORD *)(a1 + 64) = 0;
    }
    v87 = *(void **)(a1 + 72);
    if (v87)
    {
      free(v87);
      *(_QWORD *)(a1 + 72) = 0;
    }
    v88 = *(void **)(a1 + 8);
    if (v88)
    {
      free(v88);
      *(_QWORD *)(a1 + 8) = 0;
    }
    return -64;
  }
  *(_QWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 80) = a5;
  *v48 = 0;
  if (a4)
  {
    v50 = 0;
    if (v47 <= 2)
      v51 = 2;
    else
      v51 = v47;
    v52 = v48 + 1;
    v53 = v51 - 1;
    do
    {
      v54 = *v8++;
      v50 += v54;
      *v52++ = v50;
      --v53;
    }
    while (v53);
  }
  if (g_displayLevel >= 2)
  {
    v55 = (FILE **)MEMORY[0x1E0C80C10];
    fwrite("Constructing partial suffix array\n", 0x22uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    fflush(*v55);
    v49 = *(int32x4_t **)(a1 + 48);
  }
  v56 = *(_QWORD *)(a1 + 56);
  if (v56)
  {
    if (v56 < 0x10 || ((_DWORD)v56 ? (v57 = (v56 - 1) >> 32 == 0) : (v57 = 0), !v57))
    {
      v58 = 0;
      for (i = 0; i < v56; v58 = i)
LABEL_74:
        v49->i32[v58] = i++;
      goto LABEL_75;
    }
    v58 = v56 & 0xFFFFFFFFFFFFFFF8;
    i = v56 & 0xFFFFFFF8;
    v89 = (int32x4_t)xmmword_18820BF90;
    v90 = v49 + 1;
    v91.i64[0] = 0x400000004;
    v91.i64[1] = 0x400000004;
    v92.i64[0] = 0x800000008;
    v92.i64[1] = 0x800000008;
    v93 = v56 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      v90[-1] = v89;
      *v90 = vaddq_s32(v89, v91);
      v89 = vaddq_s32(v89, v92);
      v90 += 2;
      v93 -= 8;
    }
    while (v93);
    if (v56 != v58)
      goto LABEL_74;
  }
LABEL_75:
  g_coverCtx = a1;
  if (*(_DWORD *)(a1 + 80) >= 9u)
    v60 = (int (__cdecl *)(const void *, const void *))COVER_strict_cmp;
  else
    v60 = (int (__cdecl *)(const void *, const void *))COVER_strict_cmp8;
  qsort(v49, v56, 4uLL, v60);
  if (g_displayLevel >= 2)
  {
    v61 = (FILE **)MEMORY[0x1E0C80C10];
    fwrite("Computing frequencies\n", 0x16uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    fflush(*v61);
  }
  v62 = *(unsigned int **)(a1 + 48);
  v63 = *(_QWORD *)(a1 + 56);
  if (*(_DWORD *)(a1 + 80) >= 9u)
    v64 = COVER_cmp;
  else
    v64 = COVER_cmp8;
  if (v63)
  {
    v65 = 0;
    do
    {
      if (v63 <= v65 + 1)
        v66 = v65 + 1;
      else
        v66 = v63;
      v67 = 4;
      while (1)
      {
        v68 = v67;
        v69 = (unsigned int *)((char *)v62 + v67);
        if (v66 - 1 == v65)
          break;
        ++v65;
        v70 = v64(a1, v62, (unsigned int *)((char *)v62 + v67));
        v67 = v68 + 4;
        if (v70)
        {
          v71 = *(_QWORD *)(a1 + 48);
          v72 = (unint64_t)v62 - v71;
          v73 = 0;
          if (!v68)
            goto LABEL_85;
          goto LABEL_95;
        }
      }
      v65 = v66;
      v71 = *(_QWORD *)(a1 + 48);
      v72 = (unint64_t)v62 - v71;
      v73 = 0;
      if (!v68)
        goto LABEL_85;
LABEL_95:
      v74 = *(unint64_t **)(a1 + 8);
      v75 = &v74[*(_QWORD *)(a1 + 24)];
      v76 = *v74;
      v77 = *(_QWORD *)(a1 + 72);
      do
      {
        *(_DWORD *)(v77 + 4 * *v62) = v72 >> 2;
        v78 = *v62;
        if (v76 <= v78)
        {
          ++v73;
          if (v69 != v62 + 1)
          {
            v79 = v75;
            if (v75 != v74)
            {
              v80 = v75 - v74;
              v79 = v74;
              do
              {
                v81 = v80 >> 1;
                v82 = &v79[v80 >> 1];
                v84 = *v82;
                v83 = v82 + 1;
                v80 += ~(v80 >> 1);
                if (v84 >= v78)
                  v80 = v81;
                else
                  v79 = v83;
              }
              while (v80);
            }
            v76 = *v79;
            v74 = v79 + 1;
          }
        }
        ++v62;
      }
      while (v69 != v62);
LABEL_85:
      *(_DWORD *)(v71 + (v72 & 0x3FFFFFFFCLL)) = v73;
      v62 = v69;
    }
    while (v65 < v63);
  }
  else
  {
    v71 = *(_QWORD *)(a1 + 48);
  }
  result = 0;
  *(_QWORD *)(a1 + 64) = v71;
  *(_QWORD *)(a1 + 48) = 0;
  return result;
}

size_t COVER_buildDictionary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5, int *a6)
{
  size_t v6;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  FILE **v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  _DWORD *v27;
  int v28;
  unsigned int v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  _DWORD *v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  char v43;
  _DWORD *v44;
  unsigned int v45;
  uint64_t v46;
  int v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  unsigned int v53;
  BOOL v54;
  unsigned int v55;
  unsigned int v56;
  size_t v57;
  size_t v58;
  size_t v59;
  FILE **v60;
  FILE **v61;
  size_t v63;
  unint64_t v65;
  unint64_t v67;
  int v68;

  v6 = a5;
  v9 = *(_DWORD *)(a1 + 56);
  v10 = 10 * *a6;
  v11 = a5 / *a6;
  if (v11 < 4)
    v12 = 1;
  else
    v12 = v11 >> 2;
  v68 = v9 / v12;
  if (v9 / v12 < v10)
  {
    if (v10 >= v9)
      v13 = *(_DWORD *)(a1 + 56);
    else
      v13 = 10 * *a6;
    v68 = v13;
    v12 = v9 / v13;
  }
  v67 = v12;
  LODWORD(v14) = v12 >> 3;
  if (v14 >= 0x64)
    LODWORD(v14) = 100;
  if (v14 <= 0xA)
    v14 = 10;
  else
    v14 = v14;
  v65 = v14;
  if (g_displayLevel >= 2)
  {
    v15 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "Breaking content into %u epochs of size %u\n", v67, v68);
    fflush(*v15);
  }
  if (!v6)
    goto LABEL_76;
  v16 = 0;
  v17 = 0;
  v63 = v6;
LABEL_20:
  v18 = (v68 * v16);
  v19 = (v18 + v68);
  v20 = *a6;
  v21 = a6[1];
  memset(*(void **)a3, 255, 8 * *(unsigned int *)(a3 + 12));
  if (v18 < v19)
  {
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = *(_QWORD *)(a1 + 72);
    v27 = *(_DWORD **)a3;
    v28 = v20 - v21 + 2;
    v29 = v68 * v16;
    while (1)
    {
      v31 = *(unsigned int *)(v26 + 4 * v18);
      v32 = (-1640531535 * v31) >> -*(_BYTE *)(a3 + 8);
      v33 = v27[2 * v32 + 1];
      if (v33 == -1)
        goto LABEL_33;
      if (v27[2 * v32] != (_DWORD)v31)
        break;
LABEL_30:
      v34 = &v27[2 * v32 + 1];
      if (v33)
      {
        ++v18;
        *v34 = v33 + 1;
        if ((_DWORD)v18 - v29 != v28)
          goto LABEL_23;
        goto LABEL_35;
      }
LABEL_34:
      v25 += *(_DWORD *)(a2 + 4 * v31);
      ++v18;
      *v34 = 1;
      if ((_DWORD)v18 - v29 != v28)
        goto LABEL_23;
LABEL_35:
      v37 = *(unsigned int *)(v26 + 4 * v29);
      v38 = (-1640531535 * v37) >> -*(_BYTE *)(a3 + 8);
      v39 = v27[2 * v38 + 1];
      if (v39 != -1)
      {
        if (v27[2 * v38] == (_DWORD)v37)
        {
LABEL_39:
          ++v29;
          v40 = v39 - 1;
          v27[2 * v38 + 1] = v40;
          if (!v40)
          {
            v41 = *(_DWORD *)(a3 + 8);
            v42 = (-1640531535 * v37) >> -(char)v41;
            if (v27[2 * v42 + 1] != -1)
            {
              v43 = 32 - v41;
              while (v27[2 * v42] != (_DWORD)v37)
              {
                v42 = *(_DWORD *)(a3 + 16) & (v42 + 1);
                if (v27[2 * v42 + 1] == -1)
                  goto LABEL_51;
              }
              v44 = &v27[2 * v42];
              v45 = *(_DWORD *)(a3 + 16);
              v46 = v45 & ((_DWORD)v42 + 1);
              v47 = v27[2 * v46 + 1];
              if (v47 != -1)
              {
                v48 = 1;
                do
                {
                  while (1)
                  {
                    v49 = v27[2 * v46];
                    if ((((_DWORD)v46 - ((-1640531535 * v49) >> v43)) & v45) >= v48)
                      break;
                    ++v48;
                    v46 = ((_DWORD)v46 + 1) & v45;
                    v47 = v27[2 * v46 + 1];
                    if (v47 == -1)
                      goto LABEL_50;
                  }
                  *v44 = v49;
                  v44[1] = v47;
                  v48 = 1;
                  v44 = &v27[2 * v46];
                  v46 = ((_DWORD)v46 + 1) & v45;
                  v47 = v27[2 * v46 + 1];
                }
                while (v47 != -1);
              }
LABEL_50:
              v44[1] = -1;
            }
LABEL_51:
            v25 -= *(_DWORD *)(a2 + 4 * v37);
          }
          goto LABEL_23;
        }
        while (1)
        {
          v38 = *(_DWORD *)(a3 + 16) & (v38 + 1);
          v39 = v27[2 * v38 + 1];
          if (v39 == -1)
            break;
          if (v27[2 * v38] == (_DWORD)v37)
            goto LABEL_39;
        }
      }
      v30 = &v27[2 * v38];
      ++v29;
      *v30 = v37;
      v30[1] = -1;
LABEL_23:
      if (v25 > v24)
      {
        v24 = v25;
        v23 = v18;
        v22 = v29;
      }
      if (v18 == v19)
      {
        v50 = v22;
        v51 = v23;
        if (v22 == v23)
          goto LABEL_63;
        do
        {
          v52 = *(_DWORD *)(a2 + 4 * *(unsigned int *)(v26 + 4 * v22));
          if (v51 >= v22)
            v53 = v22;
          else
            v53 = v51;
          v54 = v52 == 0;
          if (v52)
            v50 = v22 + 1;
          v55 = v22 + 1;
          if (!v54)
            v51 = v53;
          ++v22;
        }
        while (v23 != v55);
        v56 = v51;
        if (v51 != v50)
        {
          do
            *(_DWORD *)(a2 + 4 * *(unsigned int *)(v26 + 4 * v56++)) = 0;
          while (v50 != v56);
          v23 = v50;
          if (v24)
            goto LABEL_64;
          goto LABEL_18;
        }
        v23 = v51;
LABEL_63:
        if (!v24)
          goto LABEL_18;
LABEL_64:
        v57 = a6[1];
        v58 = v23 + ~v51 + v57;
        if (v6 >= v58)
          v59 = v58;
        else
          v59 = v6;
        if (v59 < v57)
          goto LABEL_76;
        v6 -= v59;
        memcpy((void *)(a4 + v6), (const void *)(*(_QWORD *)a1 + v51), v59);
        if (g_displayLevel >= 2 && (clock() - g_time > 0x249F0 || g_displayLevel >= 4))
        {
          g_time = clock();
          v60 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%u%%       ", 100 * (v63 - v6) / v63);
          fflush(*v60);
          v17 = 0;
        }
        else
        {
          v17 = 0;
        }
LABEL_19:
        v16 = (v16 + 1) % v67;
        if (!v6)
          goto LABEL_76;
        goto LABEL_20;
      }
    }
    while (1)
    {
      v32 = *(_DWORD *)(a3 + 16) & (v32 + 1);
      v33 = v27[2 * v32 + 1];
      if (v33 == -1)
        break;
      if (v27[2 * v32] == (_DWORD)v31)
        goto LABEL_30;
    }
LABEL_33:
    v35 = 2 * v32;
    v36 = (char *)&v27[2 * v32];
    *((_DWORD *)v36 + 1) = 0;
    v34 = v36 + 4;
    v27[v35] = v31;
    goto LABEL_34;
  }
LABEL_18:
  if (++v17 < v65)
    goto LABEL_19;
LABEL_76:
  if (g_displayLevel >= 2)
  {
    v61 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%79s\r", "");
    fflush(*v61);
  }
  return v6;
}

uint64_t ZDICT_finalizeDictionary(char *a1, unint64_t a2, unsigned int *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, int a11)
{
  uint64_t v11;
  unint64_t v13;
  int v21;
  FILE **v22;
  unint64_t v23;
  size_t v24;
  size_t v25;
  _DWORD __src[2];
  _QWORD v27[33];

  v27[31] = *MEMORY[0x1E0C80C00];
  if (a9)
    v11 = a9;
  else
    v11 = 3;
  if (a2 < a4)
    return -70;
  if (a4 < 0x80)
    return -72;
  if (a2 < 0x100)
    return -70;
  __src[0] = -332356553;
  v21 = ZSTD_XXH64(a3, a4) % 0x7FFF8000 + 0x8000;
  if (a11)
    v21 = a11;
  __src[1] = v21;
  if (a10 >= 2)
  {
    v22 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%70s\r", "");
    fflush(*v22);
    fwrite("statistics ... \n", 0x10uLL, 1uLL, *v22);
    fflush(*v22);
  }
  v23 = ZDICT_analyzeEntropy((uint64_t)v27, 248, v11, a5, a6, a7, (uint64_t)a3, a4, a10);
  v13 = v23;
  if (v23 <= 0xFFFFFFFFFFFFFF88)
  {
    v24 = v23 + 8;
    if (v23 + 8 + a4 <= a2)
      v25 = a4;
    else
      v25 = a2 - (v23 + 8);
    v13 = v25 + v24;
    memmove(&a1[v24], a3, v25);
    memcpy(a1, __src, v24);
  }
  return v13;
}

unint64_t COVER_checkTotalCompressedSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, const void *a7, unint64_t a8)
{
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _BYTE *v28;
  void *v29;
  unint64_t v30;
  int v31;
  char *CDict_advanced2;
  char *v33;
  int v34;
  unint64_t v35;
  BOOL v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  size_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  char *v47;
  _OWORD *v48;
  _BOOL4 v49;
  void (*v50)(uint64_t);
  _OWORD v54[2];
  int v55;
  _BYTE v56[28];
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;

  if (*(double *)(a1 + 16) >= 1.0)
    v14 = 0;
  else
    v14 = a5;
  v15 = a6 - v14;
  if (a6 <= v14)
  {
    v18 = 0;
    v19 = 64;
    goto LABEL_24;
  }
  if (v15 >= 2)
  {
    v16 = 0;
    v20 = 0;
    v17 = v14 + (v15 & 0xFFFFFFFFFFFFFFFELL);
    v21 = (unint64_t *)(a2 + 8 * v14 + 8);
    v22 = v15 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      if (*(v21 - 1) > v16)
        v16 = *(v21 - 1);
      if (*v21 > v20)
        v20 = *v21;
      v21 += 2;
      v22 -= 2;
    }
    while (v22);
    if (v16 <= v20)
      v16 = v20;
    if (v15 == (v15 & 0xFFFFFFFFFFFFFFFELL))
      goto LABEL_21;
  }
  else
  {
    v16 = 0;
    v17 = v14;
  }
  v23 = a6 - v17;
  v24 = (unint64_t *)(a2 + 8 * v17);
  do
  {
    v26 = *v24++;
    v25 = v26;
    if (v26 > v16)
      v16 = v25;
    --v23;
  }
  while (v23);
LABEL_21:
  v18 = v16 + (v16 >> 8);
  if (v16 >> 17)
    v19 = 0;
  else
    v19 = (0x20000 - v16) >> 11;
LABEL_24:
  v27 = v18 + v19;
  v28 = malloc_type_malloc(v18 + v19, 0x2575891FuLL);
  v29 = malloc_type_malloc(0xD00uLL, 0x26AA08A0uLL);
  v30 = (unint64_t)v29;
  if (v29)
  {
    bzero(v29, 0xD00uLL);
    ZSTD_clearAllDicts(v30);
    *(_QWORD *)(v30 + 176) = 0;
    *(_OWORD *)(v30 + 144) = 0u;
    *(_OWORD *)(v30 + 160) = 0u;
    *(_OWORD *)(v30 + 112) = 0u;
    *(_OWORD *)(v30 + 128) = 0u;
    *(_OWORD *)(v30 + 80) = 0u;
    *(_OWORD *)(v30 + 96) = 0u;
    *(_OWORD *)(v30 + 48) = 0u;
    *(_OWORD *)(v30 + 64) = 0u;
    *(_OWORD *)(v30 + 16) = 0u;
    *(_OWORD *)(v30 + 32) = 0u;
    *(_DWORD *)(v30 + 60) = 3;
    *(_DWORD *)(v30 + 48) = 1;
  }
  v31 = *(_DWORD *)(a1 + 32);
  memset(v54, 0, 28);
  ZSTD_getCParams_internal((uint64_t)v54, v31, -1, a8, 2);
  v55 = 0;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  *(_OWORD *)v56 = v54[0];
  *(_OWORD *)&v56[12] = *(_OWORD *)((char *)v54 + 12);
  v57 = 0u;
  LODWORD(v57) = 1;
  v65 = 0;
  v66 = 0;
  v64 = 0;
  CDict_advanced2 = ZSTD_createCDict_advanced2(a7, a8, 0, 0, (__int128 *)&v55, (uint64_t)&ZSTD_defaultCMem);
  if (!CDict_advanced2)
  {
    ZSTD_freeCCtx(v30);
    a8 = -1;
    if (!v28)
      return a8;
    goto LABEL_56;
  }
  v33 = CDict_advanced2;
  if (v31)
    v34 = v31;
  else
    v34 = 3;
  *((_DWORD *)CDict_advanced2 + 1237) = v34;
  if (!v28 || !v30)
  {
    ZSTD_freeCCtx(v30);
    a8 = -1;
    v46 = *((_QWORD *)v33 + 617);
    v48 = v33 + 32;
    v47 = (char *)*((_QWORD *)v33 + 4);
    if (v47 > v33)
      goto LABEL_53;
LABEL_45:
    v49 = *((_QWORD *)v33 + 5) >= (unint64_t)v33;
    v50 = (void (*)(uint64_t))*((_QWORD *)v33 + 616);
    v48[2] = 0u;
    v48[3] = 0u;
    *v48 = 0u;
    v48[1] = 0u;
    if (!v47)
      goto LABEL_54;
LABEL_46:
    if (!v50)
    {
      free(v47);
      if (v49)
        goto LABEL_55;
LABEL_61:
      free(v33);
      if (!v28)
        return a8;
      goto LABEL_56;
    }
    v50(v46);
    if (v49)
      goto LABEL_55;
LABEL_58:
    if (v50)
    {
      ((void (*)(uint64_t, char *))v50)(v46, v33);
      if (!v28)
        return a8;
      goto LABEL_56;
    }
    goto LABEL_61;
  }
  if (*(double *)(a1 + 16) >= 1.0)
    v35 = 0;
  else
    v35 = a5;
  v36 = a6 > v35;
  v37 = a6 - v35;
  if (v36)
  {
    v38 = 8 * v35;
    v39 = (unint64_t *)(a2 + v38);
    v40 = (uint64_t *)(a4 + v38);
    while (1)
    {
      v42 = *v40++;
      v41 = v42;
      v44 = *v39++;
      v43 = v44;
      v45 = ZSTD_compressBegin_usingCDict_advanced(v30, (uint64_t)v33, 1, 0, v44);
      if (v45 > 0xFFFFFFFFFFFFFF88)
        break;
      v45 = ZSTD_compressEnd((int *)v30, v28, v27, (char *)(a3 + v41), v43);
      if (v45 > 0xFFFFFFFFFFFFFF88)
        break;
      a8 += v45;
      if (!--v37)
        goto LABEL_52;
    }
    a8 = v45;
  }
LABEL_52:
  ZSTD_freeCCtx(v30);
  v46 = *((_QWORD *)v33 + 617);
  v48 = v33 + 32;
  v47 = (char *)*((_QWORD *)v33 + 4);
  if (v47 <= v33)
    goto LABEL_45;
LABEL_53:
  v49 = 0;
  v50 = (void (*)(uint64_t))*((_QWORD *)v33 + 616);
  v48[2] = 0u;
  v48[3] = 0u;
  *v48 = 0u;
  v48[1] = 0u;
  if (v47)
    goto LABEL_46;
LABEL_54:
  if (!v49)
    goto LABEL_58;
LABEL_55:
  if (v28)
LABEL_56:
    free(v28);
  return a8;
}

double COVER_best_init(uint64_t a1)
{
  double result;

  if (a1)
  {
    pthread_mutex_init((pthread_mutex_t *)a1, 0);
    pthread_cond_init((pthread_cond_t *)(a1 + 64), 0);
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 184) = -1;
    result = 0.0;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 152) = 0u;
    *(_OWORD *)(a1 + 168) = 0u;
  }
  return result;
}

pthread_mutex_t *COVER_best_wait(pthread_mutex_t *result)
{
  pthread_mutex_t *v1;

  if (result)
  {
    v1 = result;
    pthread_mutex_lock(result);
    while (*(_QWORD *)&v1[1].__opaque[40])
      pthread_cond_wait((pthread_cond_t *)&v1[1], v1);
    return (pthread_mutex_t *)pthread_mutex_unlock(v1);
  }
  return result;
}

pthread_mutex_t *COVER_best_destroy(pthread_mutex_t *result)
{
  pthread_mutex_t *v1;
  void *v2;

  if (result)
  {
    v1 = result;
    pthread_mutex_lock(result);
    while (*(_QWORD *)&v1[1].__opaque[40])
      pthread_cond_wait((pthread_cond_t *)&v1[1], v1);
    pthread_mutex_unlock(v1);
    v2 = *(void **)&v1[1].__opaque[48];
    if (v2)
      free(v2);
    pthread_mutex_destroy(v1);
    return (pthread_mutex_t *)pthread_cond_destroy((pthread_cond_t *)&v1[1]);
  }
  return result;
}

pthread_mutex_t *COVER_best_start(pthread_mutex_t *result)
{
  pthread_mutex_t *v1;

  if (result)
  {
    v1 = result;
    pthread_mutex_lock(result);
    ++*(_QWORD *)&v1[1].__opaque[40];
    return (pthread_mutex_t *)pthread_mutex_unlock(v1);
  }
  return result;
}

pthread_mutex_t *COVER_best_finish(pthread_mutex_t *result, _OWORD *a2, uint64_t a3)
{
  pthread_mutex_t *v4;
  size_t v5;
  unint64_t v6;
  const void *v7;
  uint64_t v8;
  void *v9;
  __int128 v10;
  __int128 v11;

  if (!result)
    return result;
  v4 = result;
  v5 = *(_QWORD *)(a3 + 8);
  v6 = *(_QWORD *)(a3 + 16);
  v7 = *(const void **)a3;
  pthread_mutex_lock(result);
  v8 = *(_QWORD *)&v4[1].__opaque[40] - 1;
  *(_QWORD *)&v4[1].__opaque[40] = v8;
  if (v6 < *(_QWORD *)&v4[2].__opaque[48])
  {
    v9 = *(void **)&v4[1].__opaque[48];
    if (v9)
    {
      if (v4[2].__sig >= v5)
      {
LABEL_7:
        if (v7)
        {
          memcpy(v9, v7, v5);
          v4[2].__sig = v5;
          v11 = a2[1];
          v10 = a2[2];
          *(_OWORD *)v4[2].__opaque = *a2;
          *(_OWORD *)&v4[2].__opaque[16] = v11;
          *(_OWORD *)&v4[2].__opaque[32] = v10;
          *(_QWORD *)&v4[2].__opaque[48] = v6;
        }
        goto LABEL_9;
      }
      free(v9);
    }
    v9 = malloc_type_malloc(v5, 0xEF4369FAuLL);
    *(_QWORD *)&v4[1].__opaque[48] = v9;
    if (!v9)
    {
      *(_QWORD *)&v4[2].__opaque[48] = -1;
      v4[2].__sig = 0;
      pthread_cond_signal((pthread_cond_t *)&v4[1]);
      return (pthread_mutex_t *)pthread_mutex_unlock(v4);
    }
    goto LABEL_7;
  }
LABEL_9:
  if (!v8)
    pthread_cond_broadcast((pthread_cond_t *)&v4[1]);
  return (pthread_mutex_t *)pthread_mutex_unlock(v4);
}

uint64_t COVER_dictSelectionError@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = result;
  return result;
}

BOOL COVER_dictSelectionIsError(_QWORD *a1)
{
  return a1[2] > 0xFFFFFFFFFFFFFF88 || *a1 == 0;
}

void COVER_dictSelectionFree(void **a1)
{
  free(*a1);
}

void COVER_selectDict(size_t size@<X1>, char *a2@<X0>, size_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, unint64_t a7@<X6>, unint64_t a8@<X7>, _QWORD *a9@<X8>, __int128 *a10, uint64_t a11)
{
  unint64_t v11;
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  unint64_t v22;
  __int128 v23;
  unint64_t v24;
  unint64_t v25;
  double v26;
  unint64_t i;
  uint64_t v28;
  __int128 v29;
  unint64_t v30;
  unint64_t v31;
  void *v32;
  unint64_t v33;
  char *v34;
  unsigned int v35;
  __int128 v39;
  __int128 v40;
  __int128 v41;

  v18 = malloc_type_malloc(size, 0xE41D5588uLL);
  v19 = malloc_type_malloc(size, 0xF02885DFuLL);
  v20 = v19;
  if (!v18 || !v19)
  {
LABEL_13:
    free(v18);
    free(v20);
    *a9 = 0;
    a9[1] = 0;
    a9[2] = a3;
    return;
  }
  LODWORD(v11) = *((_DWORD *)a10 + 7);
  memcpy(v18, a2, a3);
  v35 = a6;
  v22 = ZDICT_finalizeDictionary((char *)v18, size, (unsigned int *)a2, a3, a4, a5, a6, v21, *((_QWORD *)a10 + 4), HIDWORD(*((_QWORD *)a10 + 4)), *((_DWORD *)a10 + 10));
  if (v22 >= 0xFFFFFFFFFFFFFF89)
  {
    free(v18);
    free(v20);
    *a9 = 0;
    a9[1] = 0;
    a9[2] = v22;
  }
  else
  {
    v23 = a10[1];
    v39 = *a10;
    v40 = v23;
    v41 = a10[2];
    v24 = COVER_checkTotalCompressedSize((uint64_t)&v39, a5, a4, a11, a7, a8, v18, v22);
    v25 = v24;
    if (v24 >= 0xFFFFFFFFFFFFFF89)
    {
      free(v18);
      free(v20);
      *a9 = 0;
      a9[1] = 0;
      a9[2] = v25;
    }
    else
    {
      if (*((_DWORD *)a10 + 6))
      {
        v33 = v24;
        if (v22 >= 0x101)
        {
          v34 = &a2[a3];
          v26 = ((double)v11 / 100.0 + 1.0) * (double)v24;
          for (i = 256; i < v22; i = 2 * a3)
          {
            memcpy(v20, v18, v22);
            v25 = v25 & 0xFFFFFFFF00000000 | *((unsigned int *)a10 + 10);
            a3 = ZDICT_finalizeDictionary((char *)v20, size, (unsigned int *)&v34[-i], i, a4, a5, v35, v28, *((_QWORD *)a10 + 4), HIDWORD(*((_QWORD *)a10 + 4)), v25);
            if (a3 >= 0xFFFFFFFFFFFFFF89)
              goto LABEL_13;
            v29 = a10[1];
            v39 = *a10;
            v40 = v29;
            v41 = a10[2];
            v30 = COVER_checkTotalCompressedSize((uint64_t)&v39, a5, a4, a11, a7, a8, v20, a3);
            v31 = v30;
            if (v30 >= 0xFFFFFFFFFFFFFF89)
            {
              free(v18);
              free(v20);
              *a9 = 0;
              a9[1] = 0;
              a9[2] = v31;
              return;
            }
            if (v26 >= (double)v30)
            {
              *a9 = v20;
              a9[1] = a3;
              a9[2] = v30;
              v32 = v18;
              goto LABEL_18;
            }
          }
        }
        *a9 = v18;
        a9[1] = v22;
        a9[2] = v33;
      }
      else
      {
        *a9 = v18;
        a9[1] = v22;
        a9[2] = v24;
      }
      v32 = v20;
LABEL_18:
      free(v32);
    }
  }
}

BOOL ZDICT_isError(unint64_t a1)
{
  return a1 > 0xFFFFFFFFFFFFFF88;
}

uint64_t ZDICT_optimizeTrainFromBuffer_cover(void *a1, unint64_t a2, uint64_t a3, int64x2_t *a4, unsigned int a5, uint64_t a6)
{
  double v6;
  int v7;
  unsigned int v8;
  char v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  FILE **v19;
  uint64_t v20;
  FILE **v21;
  FILE **v23;
  uint64_t v26;
  _QWORD *advanced;
  int v28;
  FILE **v29;
  FILE **v30;
  __int128 v31;
  char v32;
  __int128 v33;
  int v34;
  FILE **v35;
  unint64_t v36;
  FILE **v37;
  unsigned int v38;
  FILE **v39;
  char *v40;
  FILE **v41;
  __int128 v42;
  __int128 v43;
  int v44;
  int v45;
  FILE **v46;
  FILE **v47;
  FILE **v48;
  void *__dst;
  unsigned int v50;
  unsigned int v54;
  unsigned int v55;
  uint64_t v56;
  int v57;
  void *v58[2];
  __int128 v59;
  __int128 v60;
  void *v61[2];
  void *v62[2];
  uint64_t v63;
  pthread_mutex_t v64;
  pthread_cond_t v65;
  void *v66[2];
  _OWORD v67[4];
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  if (*(double *)(a6 + 16) <= 0.0)
    v6 = 1.0;
  else
    v6 = *(double *)(a6 + 16);
  v8 = *(_DWORD *)a6;
  v7 = *(_DWORD *)(a6 + 4);
  v9 = v7 == 0;
  if (v7)
    v10 = *(_DWORD *)(a6 + 4);
  else
    v10 = 6;
  if (v7)
    v11 = *(_DWORD *)(a6 + 4);
  else
    v11 = 8;
  if (*(_DWORD *)(a6 + 8))
    v12 = *(_DWORD *)(a6 + 8);
  else
    v12 = 40;
  if (v8)
    v13 = *(_DWORD *)a6;
  else
    v13 = 50;
  if (v8)
    v14 = *(_DWORD *)a6;
  else
    v14 = 2000;
  if (v8)
    v15 = 0;
  else
    v15 = 1950;
  if (v15 / v12 <= 1)
    v16 = 1;
  else
    v16 = v15 / v12;
  v17 = *(_DWORD *)(a6 + 36);
  if (v6 <= 0.0 || v6 > 1.0 || v13 < v11 || v14 < v13)
  {
    if (v17 >= 1)
    {
      v21 = (FILE **)MEMORY[0x1E0C80C10];
      fwrite("Incorrect parameters\n", 0x15uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      fflush(*v21);
    }
    return -42;
  }
  if (!a5)
  {
    if (g_displayLevel >= 1)
    {
      v23 = (FILE **)MEMORY[0x1E0C80C10];
      fwrite("Cover must have at least one input file\n", 0x28uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      fflush(*v23);
    }
    return -72;
  }
  if (a2 <= 0xFF)
  {
    if (g_displayLevel >= 1)
    {
      v19 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "dictBufferCapacity must be at least %u\n", 256);
      fflush(*v19);
    }
    return -70;
  }
  v55 = v11;
  v26 = *(unsigned int *)(a6 + 12);
  __dst = a1;
  v50 = v13;
  if (v26 < 2)
  {
    advanced = 0;
  }
  else
  {
    advanced = POOL_create_advanced(v26, 1, &ZSTD_defaultCMem);
    if (!advanced)
      return -64;
  }
  v56 = (uint64_t)advanced;
  memset(v67, 0, sizeof(v67));
  *(_OWORD *)v66 = 0u;
  memset(&v65, 0, sizeof(v65));
  v54 = (v15 / v16 + 1) << v9;
  memset(&v64, 0, sizeof(v64));
  pthread_mutex_init(&v64, 0);
  pthread_cond_init(&v65, 0);
  v66[0] = 0;
  v66[1] = 0;
  memset(v67, 0, 56);
  *((_QWORD *)&v67[3] + 1) = -1;
  v28 = v17 - 1;
  if (!v17)
    v28 = 0;
  g_displayLevel = v28;
  if (v17 >= 2)
  {
    v29 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "Trying %u different sets of parameters\n", v54);
    fflush(*v29);
  }
  if (v10 > v55)
    goto LABEL_50;
  v32 = 1;
  v33 = 0uLL;
  v34 = 1;
  while (2)
  {
    v57 = v34;
    v63 = 0;
    *(_OWORD *)v61 = v33;
    *(_OWORD *)v62 = v33;
    v59 = v33;
    v60 = v33;
    *(_OWORD *)v58 = v33;
    if (v17 >= 3)
    {
      v35 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "d=%u\n", v10);
      fflush(*v35);
    }
    v36 = COVER_ctx_init((uint64_t)v58, a3, a4, a5, v10, v6);
    if (v36 >= 0xFFFFFFFFFFFFFF89)
    {
      v20 = v36;
      if (v17 >= 1)
      {
        v48 = (FILE **)MEMORY[0x1E0C80C10];
        fwrite("Failed to initialize context\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
        fflush(*v48);
      }
      pthread_mutex_lock(&v64);
      while (v66[0])
        pthread_cond_wait(&v65, &v64);
      goto LABEL_113;
    }
    if ((v32 & 1) != 0 && v17 >= 1 && (double)(unint64_t)v61[1] / (double)a2 < 10.0)
    {
      v37 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/size(dictionary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend training on sources at least 10x, and preferably 100x the size of the dictionary! \n", a2, LODWORD(v61[1]), (double)(unint64_t)v61[1] / (double)a2);
      fflush(*v37);
    }
    v38 = v50;
    do
    {
      while (1)
      {
        v40 = (char *)malloc_type_malloc(0x48uLL, 0x1060040023D7745uLL);
        if (v17 >= 3)
        {
          v41 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "k=%u\n", v38);
          fflush(*v41);
        }
        if (!v40)
        {
          if (v17 >= 1)
          {
            v47 = (FILE **)MEMORY[0x1E0C80C10];
            fwrite("Failed to allocate parameters\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
            fflush(*v47);
          }
          pthread_mutex_lock(&v64);
          while (v66[0])
            pthread_cond_wait(&v65, &v64);
          pthread_mutex_unlock(&v64);
          if (v66[1])
            free(v66[1]);
          pthread_mutex_destroy(&v64);
          pthread_cond_destroy(&v65);
          if (v61[0])
          {
            free(v61[0]);
            v61[0] = 0;
          }
          if (v62[0])
          {
            free(v62[0]);
            v62[0] = 0;
          }
          if (v62[1])
          {
            free(v62[1]);
            v62[1] = 0;
          }
          if (v58[1])
          {
            free(v58[1]);
            v58[1] = 0;
          }
          v20 = -64;
          goto LABEL_116;
        }
        *(_QWORD *)v40 = v58;
        *((_QWORD *)v40 + 1) = &v64;
        *((_QWORD *)v40 + 2) = a2;
        v43 = *(_OWORD *)(a6 + 16);
        v42 = *(_OWORD *)(a6 + 32);
        *(_OWORD *)(v40 + 24) = *(_OWORD *)a6;
        *(_OWORD *)(v40 + 40) = v43;
        *(_OWORD *)(v40 + 56) = v42;
        *((_DWORD *)v40 + 6) = v38;
        *((_DWORD *)v40 + 7) = v10;
        *((double *)v40 + 5) = v6;
        *((_DWORD *)v40 + 8) = v12;
        *((_DWORD *)v40 + 12) = 0;
        v44 = g_displayLevel;
        *((_DWORD *)v40 + 15) = g_displayLevel;
        if (!v10 || v38 > a2 || v10 > v38)
          break;
        pthread_mutex_lock(&v64);
        ++v66[0];
        pthread_mutex_unlock(&v64);
        if (v56)
        {
          POOL_add(v56, (uint64_t)COVER_tryParameters, (uint64_t)v40);
          v45 = v57;
          if (v17 >= 2)
            goto LABEL_80;
        }
        else
        {
          COVER_tryParameters(v40);
          v45 = v57;
          if (v17 >= 2)
          {
LABEL_80:
            if (clock() - g_time > 0x249F0 || v17 >= 4)
            {
              g_time = clock();
              v39 = (FILE **)MEMORY[0x1E0C80C10];
              fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%u%%       ", 100 * v45 / v54);
              fflush(*v39);
            }
          }
        }
        v57 = v45 + 1;
        v38 += v16;
        if (v38 > v14)
          goto LABEL_83;
      }
      if (v44 >= 1)
      {
        v46 = (FILE **)MEMORY[0x1E0C80C10];
        fwrite("Cover parameters incorrect\n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
        fflush(*v46);
      }
      free(v40);
      v38 += v16;
    }
    while (v38 <= v14);
LABEL_83:
    pthread_mutex_lock(&v64);
    while (v66[0])
      pthread_cond_wait(&v65, &v64);
    pthread_mutex_unlock(&v64);
    v34 = v57;
    if (v61[0])
    {
      free(v61[0]);
      v61[0] = 0;
    }
    if (v62[0])
    {
      free(v62[0]);
      v62[0] = 0;
    }
    if (v62[1])
    {
      free(v62[1]);
      v62[1] = 0;
    }
    if (v58[1])
      free(v58[1]);
    v32 = 0;
    v10 += 2;
    v33 = 0uLL;
    if (v10 <= v55)
      continue;
    break;
  }
LABEL_50:
  if (v17 >= 2)
  {
    v30 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%79s\r", "");
    fflush(*v30);
  }
  v20 = *((_QWORD *)&v67[3] + 1);
  if (*((_QWORD *)&v67[3] + 1) < 0xFFFFFFFFFFFFFF89)
  {
    v31 = *(_OWORD *)((char *)&v67[1] + 8);
    *(_OWORD *)a6 = *(_OWORD *)((char *)v67 + 8);
    *(_OWORD *)(a6 + 16) = v31;
    *(_OWORD *)(a6 + 32) = *(_OWORD *)((char *)&v67[2] + 8);
    v20 = *(_QWORD *)&v67[0];
    memcpy(__dst, v66[1], *(size_t *)&v67[0]);
    COVER_best_destroy(&v64);
    goto LABEL_116;
  }
  pthread_mutex_lock(&v64);
  while (v66[0])
    pthread_cond_wait(&v65, &v64);
LABEL_113:
  pthread_mutex_unlock(&v64);
  if (v66[1])
    free(v66[1]);
  pthread_mutex_destroy(&v64);
  pthread_cond_destroy(&v65);
LABEL_116:
  POOL_free(v56);
  return v20;
}

void COVER_tryParameters(void *a1)
{
  uint64_t v2;
  int v3;
  int v4;
  __int128 v5;
  size_t v6;
  char *v7;
  void *v8;
  unsigned int v9;
  size_t v10;
  void *v11;
  void *v12;
  size_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  FILE *v23;
  const char *v24;
  size_t v25;
  pthread_mutex_t *v26;
  void *v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  int v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  _BYTE v37[12];
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v2 = *(_QWORD *)a1;
  v3 = *((_DWORD *)a1 + 6);
  v4 = *((_DWORD *)a1 + 7);
  v5 = *((_OWORD *)a1 + 3);
  v38 = *((_OWORD *)a1 + 2);
  v39 = v5;
  v40 = *((_QWORD *)a1 + 8);
  v6 = *((_QWORD *)a1 + 2);
  *(_QWORD *)&v37[4] = 0;
  v7 = (char *)malloc_type_malloc(v6, 0xB39D0365uLL);
  v8 = malloc_type_malloc(4 * *(_QWORD *)(v2 + 56), 0x100004052888210uLL);
  v9 = __clz(v3 - v4 + 1) ^ 0x1F;
  v36 = v9 + 2;
  *(_QWORD *)v37 = (4 << v9);
  *(_QWORD *)&v37[4] = (*(_DWORD *)v37 - 1);
  v10 = 8 * *(unsigned int *)v37;
  v11 = malloc_type_malloc(v10, 0x100004000313F17uLL);
  v12 = v11;
  v35 = v11;
  if (v11)
  {
    memset(v11, 255, v10);
    if (v7 && v8)
    {
      memcpy(v8, *(const void **)(v2 + 64), 4 * *(_QWORD *)(v2 + 56));
      v30 = v3;
      v31 = v4;
      v32 = v38;
      v33 = v39;
      v34 = v40;
      v13 = COVER_buildDictionary(v2, (uint64_t)v8, (uint64_t)&v35, (uint64_t)v7, v6, &v30);
      v32 = v38;
      v33 = v39;
      v15 = *(_QWORD *)(v2 + 24);
      v14 = *(_QWORD *)(v2 + 32);
      v17 = *(_QWORD *)(v2 + 8);
      v16 = *(_QWORD *)(v2 + 16);
      v18 = *(_QWORD *)v2;
      v30 = v3;
      v31 = v4;
      v34 = v40;
      COVER_selectDict(v6, &v7[v13], v6 - v13, v18, v16, v14, v14, v15, &v27, (__int128 *)&v30, v17);
      v19 = v27;
      v20 = v28;
      v21 = v29;
      if (v27)
        v22 = v29 > 0xFFFFFFFFFFFFFF88;
      else
        v22 = 1;
      if (!v22 || g_displayLevel < 1)
        goto LABEL_18;
      fwrite("Failed to select dictionary\n", 0x1CuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      goto LABEL_16;
    }
    if (g_displayLevel >= 1)
    {
      v23 = (FILE *)*MEMORY[0x1E0C80C10];
      v24 = "Failed to allocate buffers: out of memory\n";
      v25 = 42;
      goto LABEL_15;
    }
  }
  else if (g_displayLevel >= 1)
  {
    v23 = (FILE *)*MEMORY[0x1E0C80C10];
    v24 = "Failed to allocate dmer map: out of memory\n";
    v25 = 43;
LABEL_15:
    fwrite(v24, v25, 1uLL, v23);
    v20 = 0;
    v19 = 0;
    v21 = -1;
LABEL_16:
    fflush((FILE *)*MEMORY[0x1E0C80C10]);
    goto LABEL_18;
  }
  v20 = 0;
  v19 = 0;
  v21 = -1;
LABEL_18:
  free(v7);
  v26 = (pthread_mutex_t *)*((_QWORD *)a1 + 1);
  v30 = v3;
  v31 = v4;
  v32 = v38;
  v33 = v39;
  v34 = v40;
  v27 = v19;
  v28 = v20;
  v29 = v21;
  COVER_best_finish(v26, &v30, (uint64_t)&v27);
  free(a1);
  if (v12)
    free(v12);
  free(v19);
  free(v8);
}

uint64_t divsufsort(unsigned __int8 *a1, int *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v5;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  _BOOL4 v12;
  unsigned int v13;
  char *v14;
  int *v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int *v21;
  int *v22;
  int *v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  int *v29;
  int v30;
  int *v31;
  unsigned int *v32;
  int *v33;
  int v34;
  unsigned int v35;
  unsigned int v36;

  v3 = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      v5 = a3;
      if ((a3 & 0x80000000) == 0)
      {
        if (!(_DWORD)a3)
          return a3;
        v7 = a3 - 2;
        if ((_DWORD)a3 != 2)
        {
          v8 = a3 - 1;
          if ((_DWORD)a3 == 1)
          {
            v3 = 0;
            *a2 = 0;
            return v3;
          }
          v14 = (char *)malloc_type_malloc(0x400uLL, 0x100004052888210uLL);
          v15 = (int *)malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
          v16 = v15;
          v3 = 4294967294;
          if (v14 && v15)
          {
            if ((int)sort_typeBstar((uint64_t)a1, a2, v14, v15, v5) >= 1)
            {
              v17 = 254;
              while (1)
              {
                v18 = v17;
                v19 = v17 + 1;
                v20 = (_DWORD)v17 << 8;
                v21 = &a2[v16[v20 | v19]];
                v22 = &a2[*(int *)&v14[4 * v18 + 4] - 1];
                if (v21 <= v22)
                  break;
LABEL_17:
                v17 = v18 - 1;
                if (!v18)
                  goto LABEL_33;
              }
              v23 = 0;
              v24 = -1;
              while (1)
              {
                v25 = *v22;
                *v22 = ~*v22;
                if (v25 < 1)
                  goto LABEL_22;
                v26 = a1[v25 - 1];
                if (v25 == 1)
                {
                  v27 = 0;
                  if (v24 != v26)
                    goto LABEL_31;
                }
                else
                {
                  if (a1[v25 - 2] > v26)
                    v27 = -v25;
                  else
                    v27 = v25 - 1;
                  if (v24 != v26)
                  {
LABEL_31:
                    if ((v24 & 0x80000000) == 0)
                      v16[v24 | v20] = (unint64_t)((char *)v23 - (char *)a2) >> 2;
                    v23 = &a2[v16[v20 | v26]];
                    v24 = v26;
                  }
                }
                *v23-- = v27;
LABEL_22:
                if (v21 > --v22)
                  goto LABEL_17;
              }
            }
LABEL_33:
            v28 = a1[v8];
            v29 = &a2[*(int *)&v14[4 * v28]];
            if (a1[v7] < v28)
              v30 = -v5;
            else
              v30 = v8;
            *v29 = v30;
            if (v5)
            {
              v31 = &a2[v5];
              v32 = (unsigned int *)(v29 + 1);
              v33 = a2;
              do
              {
                while (1)
                {
                  v34 = *v33;
                  v35 = *v33 - 1;
                  if (*v33 >= 1)
                    break;
                  *v33++ = ~v34;
                  if (v33 >= v31)
                    goto LABEL_46;
                }
                v36 = a1[v35];
                if (v34 == 1 || a1[v34 - 2] < v36)
                  v35 = -v34;
                if ((_DWORD)v28 != v36)
                {
                  *(_DWORD *)&v14[4 * v28] = (unint64_t)((char *)v32 - (char *)a2) >> 2;
                  v32 = (unsigned int *)&a2[*(int *)&v14[4 * v36]];
                  LODWORD(v28) = v36;
                }
                *v32++ = v35;
                ++v33;
              }
              while (v33 < v31);
            }
LABEL_46:
            v3 = 0;
          }
          free(v16);
          free(v14);
          return v3;
        }
        v3 = 0;
        v9 = *a1;
        v10 = a1[1];
        v11 = v9 >= v10;
        v12 = v9 < v10;
        v13 = v11;
        a2[v13] = 0;
        a2[v12] = 1;
      }
    }
  }
  return v3;
}

uint64_t sort_typeBstar(uint64_t a1, int *a2, char *a3, _DWORD *a4, int a5)
{
  int v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  int v18;
  int v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  int v30;
  int *v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  unint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  char *v45;
  int *v46;
  int *v47;
  int v48;
  int v49;
  int *v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  int v54;
  char *v55;
  unsigned int v56;
  int *v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  int *v67;
  int v68;
  int *v69;
  int v70;
  int v71;
  int v72;
  int v73;
  BOOL v74;
  int v75;
  unint64_t v76;
  int v77;
  char *v78;
  int v79;
  unint64_t v80;
  int *v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  _BOOL4 v85;
  int v86;
  char *v87;
  int v88;
  char *v89;
  int v90;
  unsigned int v91;
  int *v92;
  int *v93;
  uint64_t v94;
  uint64_t v95;
  unsigned __int8 *v96;
  unint64_t v97;
  _BOOL4 v98;
  BOOL v99;
  unsigned __int8 *v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  int v105;
  unint64_t v106;
  _BOOL4 v107;
  unint64_t v108;
  unint64_t v109;
  char *v110;
  char *v111;
  int v112;
  char *v113;
  char *v114;
  int v115;
  int v116;
  int v117;
  char *v118;
  int v119;
  uint64_t v120;
  BOOL v121;
  uint64_t v122;
  uint64_t v123;
  char *v124;
  char *v125;
  __int128 *v126;
  __int128 *v127;
  uint64_t v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  unsigned int v132;
  int v133;
  int v134;
  int *v135;
  int v136;
  uint64_t v137;
  unsigned __int8 *v138;
  uint64_t v139;
  int *v140;
  uint64_t v141;
  unint64_t v142;
  unsigned __int8 *v143;
  unsigned __int8 *v144;
  unsigned __int8 *v145;
  unsigned __int8 *v146;
  unsigned int v147;
  unsigned int v148;
  int *v149;
  unsigned int v150;
  uint64_t v151;
  int v152;
  uint64_t v153;
  int *v154;
  uint64_t v155;
  int v156;
  int v157;
  unsigned int v158;
  unsigned int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  char *v166;
  int v167;
  _DWORD *v168;
  uint64_t v169;
  int v170;
  unint64_t v171;
  uint64_t v172;
  int *v173;
  int *v174;
  unint64_t v175;
  unint64_t v176;
  int v177;
  int v178;
  uint64_t v179;
  uint64_t v180;
  int *v181;
  unint64_t v182;
  char *v183;
  uint64_t v184;
  _OWORD *v185;
  uint64_t v186;
  char *v187;
  unint64_t v188;
  int *v189;
  unint64_t v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  int *v194;
  unsigned int *v195;
  unsigned int *v196;
  int v197;
  uint64_t v198;
  int v199;
  int v200;
  int *v201;
  unsigned int *v202;
  char *v203;
  int v204;
  int *v205;
  char *v206;
  int v207;
  char *v208;
  unint64_t v209;
  int v210;
  int *v211;
  uint64_t v212;
  int v213;
  int v214;
  int v215;
  int *v216;
  int v217;
  int v218;
  BOOL v219;
  int v220;
  int *v221;
  uint64_t v222;
  int v223;
  _OWORD *v224;
  unint64_t v225;
  uint64_t v226;
  unint64_t v227;
  int v228;
  char *v229;
  int v230;
  unint64_t v231;
  int *v232;
  int v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  int v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  int v242;
  uint64_t v243;
  uint64_t v244;
  int *v245;
  uint64_t v246;
  int v247;
  int v248;
  int v249;
  int *v250;
  int v251;
  int v252;
  int *v253;
  int v254;
  int v255;
  int v256;
  int *v257;
  int v258;
  int v259;
  int v260;
  int *v261;
  int *v262;
  int v263;
  int v264;
  int v265;
  int *v266;
  int v267;
  int v268;
  int v269;
  int v270;
  uint64_t v271;
  int v272;
  int v273;
  int v274;
  int *v275;
  int *v276;
  int v277;
  uint64_t v278;
  int v279;
  uint64_t v280;
  int v281;
  uint64_t v282;
  int v283;
  int v284;
  int v285;
  int v286;
  int v287;
  int v288;
  int v289;
  int v290;
  uint64_t v291;
  int v292;
  uint64_t v293;
  uint64_t v294;
  int v295;
  int v296;
  int v297;
  int v298;
  int v299;
  int v300;
  uint64_t v301;
  int *v302;
  int *v303;
  uint64_t v304;
  int v305;
  int v306;
  BOOL v307;
  int *v308;
  uint64_t v309;
  int v310;
  int v311;
  BOOL v312;
  int *v313;
  int v314;
  int v315;
  BOOL v316;
  int *v317;
  int *v318;
  int v319;
  int v320;
  BOOL v321;
  int v322;
  int *v323;
  int *v324;
  int v325;
  int *v326;
  int v327;
  char *v328;
  int v329;
  uint64_t v330;
  int v331;
  char *v332;
  int v333;
  uint64_t v334;
  int v335;
  int v336;
  uint64_t v337;
  int v338;
  uint64_t v339;
  int v340;
  unint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  int *v346;
  int *v347;
  unint64_t v348;
  int v349;
  unint64_t v350;
  unint64_t v351;
  int *v352;
  uint64_t v353;
  int v354;
  uint64_t v355;
  int v356;
  int *v357;
  uint64_t v358;
  uint64_t v359;
  int v360;
  unint64_t v361;
  int v362;
  int *v363;
  uint64_t v364;
  int v365;
  int v366;
  uint64_t v367;
  int v368;
  uint64_t v369;
  int v370;
  unint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  int *v375;
  int *v376;
  BOOL v377;
  uint64_t v378;
  __int128 *v379;
  int *v380;
  uint64_t v381;
  __int128 v382;
  __int128 v383;
  __int128 v384;
  unsigned int v385;
  int v386;
  uint64_t v387;
  uint64_t v388;
  int v389;
  uint64_t v390;
  uint64_t v391;
  int *v392;
  BOOL v393;
  int v394;
  uint64_t v395;
  int *v396;
  __int128 *v397;
  __int128 *v398;
  uint64_t v399;
  __int128 v400;
  __int128 v401;
  __int128 v402;
  unsigned int v403;
  int v404;
  int *v405;
  uint64_t v406;
  uint64_t v407;
  unint64_t v408;
  BOOL v409;
  uint64_t v410;
  __int128 *v411;
  int *v412;
  uint64_t v413;
  __int128 v414;
  __int128 v415;
  __int128 v416;
  unsigned int v417;
  int v418;
  uint64_t v419;
  int v420;
  uint64_t v421;
  uint64_t v422;
  int *v423;
  BOOL v424;
  int v425;
  uint64_t v426;
  int *v427;
  __int128 *v428;
  __int128 *v429;
  uint64_t v430;
  __int128 v431;
  __int128 v432;
  __int128 v433;
  unsigned int v434;
  int v435;
  int *v436;
  uint64_t v437;
  int *v438;
  uint64_t v439;
  _OWORD *v440;
  unint64_t v441;
  uint64_t v442;
  unint64_t v443;
  uint64_t v444;
  char **v445;
  unint64_t v446;
  _OWORD *v447;
  unint64_t v448;
  uint64_t v449;
  char **v450;
  unint64_t v451;
  _OWORD *v452;
  unint64_t v453;
  uint64_t v454;
  unint64_t v455;
  unint64_t v456;
  _OWORD *v457;
  uint64_t v458;
  _OWORD *v459;
  uint64_t v460;
  uint64_t v461;
  int v462;
  int v463;
  uint64_t v464;
  int v465;
  int v466;
  int v467;
  int v468;
  int v469;
  int v470;
  int v471;
  uint64_t v472;
  int *v473;
  unint64_t v474;
  uint64_t v475;
  uint64_t v476;
  int v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  unsigned int v481;
  int *v482;
  uint64_t v483;
  unint64_t v484;
  uint64_t v485;
  _OWORD *v486;
  _OWORD *v487;
  uint64_t v488;
  _OWORD *v489;
  uint64_t v490;
  _OWORD *v491;
  uint64_t v492;
  _OWORD *v493;
  _OWORD *v494;
  int *v495;
  uint64_t v496;
  int *v497;
  uint64_t v498;
  _OWORD *v499;
  _OWORD *v500;
  _OWORD *v501;
  _OWORD *v502;
  _OWORD *v503;
  _OWORD *v504;
  _OWORD *v505;
  _OWORD *v506;
  _OWORD *v507;
  int *v508;
  int v509;
  unsigned int v510;
  int v511;
  uint64_t v512;
  uint64_t v513;
  unsigned int v514;
  int v515;
  int v516;
  int v517;
  unsigned int v518;
  BOOL v519;
  int v520;
  int *v521;
  uint64_t v522;
  uint64_t v523;
  unint64_t v524;
  int v525;
  unint64_t v526;
  int v527;
  unint64_t v528;
  int v529;
  int v530;
  int64_t v531;
  unint64_t v532;
  unint64_t v533;
  unint64_t v534;
  uint64_t v535;
  uint64_t v536;
  BOOL v537;
  unint64_t v538;
  int *v540;
  int *v541;
  unint64_t v542;
  __int128 v543;
  int64_t v544;
  uint64_t v546;
  int v547;
  int v548;
  uint64_t v550;
  _DWORD *v551;
  unint64_t v552;
  uint64_t v553;
  uint64_t v554;
  int v555;
  int v556;
  uint64_t v557;
  int *v558;
  int *v559;
  int v560;
  int v561;
  int64_t v562;
  char *v563;
  _DWORD *v564;
  int v565;
  uint64_t v566;
  int v567;
  char *v568;
  int v569;
  int v570;
  int *v571;
  int *v572;
  unint64_t v573;
  int *v574;
  unint64_t v575;
  int *v576;
  int v577;
  uint64_t v578;
  int *v579;
  _OWORD v580[128];
  uint64_t v581;

  v581 = *MEMORY[0x1E0C80C00];
  bzero(a3, 0x400uLL);
  bzero(a4, 0x40000uLL);
  v9 = a5;
  v548 = a5;
  if (a5 >= 1)
  {
    v10 = *(unsigned __int8 *)(a1 + (a5 - 1));
    v9 = a5;
    v11 = a5 - 1;
LABEL_3:
    v12 = v11;
    v13 = v11 - 1;
    v14 = v10;
    while (1)
    {
      v15 = v14;
      v11 = v13;
      ++*(_DWORD *)&a3[4 * v14];
      if (!v12)
        break;
      v16 = v12 - 1;
      v14 = *(unsigned __int8 *)(a1 - 1 + v12);
      --v13;
      --v12;
      if (v15 > v14)
      {
        ++*(_DWORD *)((char *)a4 + ((v14 << 10) | (4 * v15)));
        a2[--v9] = v16;
        if (v16 + 1 < 2)
          break;
        while (1)
        {
          v10 = *(unsigned __int8 *)(a1 + --v11);
          if (v14 < v10)
            goto LABEL_3;
          ++*(_DWORD *)((char *)a4 + ((4 * v10) | (v14 << 10)));
          v14 = v10;
          if (v11 <= 0)
            goto LABEL_9;
        }
      }
    }
  }
LABEL_9:
  v546 = (a5 - 1);
  v547 = a5 - 1;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 256;
  do
  {
    v21 = v17;
    v22 = 4 * v17;
    v23 = *(_DWORD *)&a3[v22] + v19;
    *(_DWORD *)&a3[v22] = v18 + v19;
    v19 = v23 + a4[v21 | ((_DWORD)v21 << 8)];
    v17 = v21 + 1;
    if (v21 <= 0xFE)
    {
      v24 = v20;
      v25 = v21 + 1;
      do
      {
        v26 = v25 | ((_DWORD)v21 << 8);
        v18 += a4[v26];
        a4[v26] = v18;
        v19 += a4[v24 | v21];
        ++v25;
        v24 += 256;
      }
      while (v25 != 256);
    }
    v20 += 256;
  }
  while (v21 != 255);
  v557 = (a5 - v9);
  if ((int)v557 < 1)
    return v557;
  v27 = 4 * (a5 - v9);
  v28 = (uint64_t)&a2[a5 + v27 / 0xFFFFFFFFFFFFFFFCLL];
  v29 = &a2[(unint64_t)v27 / 4];
  v30 = v557 - 1;
  if ((_DWORD)v557 != 1)
  {
    v31 = (int *)((char *)a2 + 4 * v548 + 4 * (v557 - 2) - 4 * v557);
    v32 = ~v9 + v548;
    do
    {
      v33 = *v31--;
      v34 = (4 * *(unsigned __int8 *)(a1 + v33 + 1)) | ((unint64_t)*(unsigned __int8 *)(a1 + v33) << 10);
      v35 = *(int *)((char *)a4 + v34) - 1;
      *(_DWORD *)((char *)a4 + v34) = v35;
      a2[v35] = --v32;
    }
    while (v32 > 0);
  }
  v36 = (unsigned __int8 *)(a1 + *(int *)(v28 + 4 * v30));
  v37 = (4 * v36[1]) | ((unint64_t)*v36 << 10);
  v38 = v548 - 2 * v557;
  v39 = *(int *)((char *)a4 + v37) - 1;
  *(_DWORD *)((char *)a4 + v37) = v39;
  v551 = a4;
  v552 = a1 + 2 + v548 - 2;
  a2[v39] = v30;
  v550 = v38;
  v553 = a1 + 2;
  v554 = a1 + 3;
  v40 = 254;
  v41 = v557;
  v571 = a2;
  v572 = v29;
  while (2)
  {
    v42 = v40 << 8;
    v43 = 255;
    v555 = v40 << 8;
    v556 = v40;
    while (2)
    {
      v44 = v41;
      v41 = a4[v43 | v42];
      if (v44 - v41 < 2)
        goto LABEL_23;
      v45 = (char *)&a2[v44];
      v46 = &a2[v41];
      v49 = *v46;
      v47 = v46 + 1;
      v48 = v49;
      if (v49 == v30)
        v50 = v47;
      else
        v50 = &a2[v41];
      v569 = a4[v43 | v42];
      v567 = v43;
      v558 = &a2[v41];
      v559 = v47;
      v565 = v48;
      if (v38 < 1024)
      {
        v51 = v45 - (char *)v50;
        v52 = (v45 - (char *)v50) >> 2;
        if (v52 > v550)
        {
          v53 = v51 >> 2;
          if ((int)(v51 >> 2) >= 0x100000)
          {
            v54 = 1024;
            goto LABEL_64;
          }
          if (v53 >= 0x10000)
          {
            if (BYTE3(v53))
            {
              v70 = lg_table[BYTE3(v52)] + 24;
              if (v70 >= 16)
                goto LABEL_53;
            }
            else
            {
              v70 = lg_table[WORD1(v52)] + 16;
              if (v70 >= 16)
                goto LABEL_53;
            }
          }
          else if ((v53 & 0xFF00) != 0)
          {
            v70 = lg_table[v52 >> 8] + 8;
            if (v70 >= 16)
            {
LABEL_53:
              v71 = sqq_table[(int)v53 >> ((v70 & 0xFE) - 6)] << ((v70 >> 1) - 7);
              if (v70 >= 0x18)
                v71 = (v71 + (int)v53 / v71 + 1) >> 1;
              v72 = (v71 + (int)v53 / v71 + 1) >> 1;
              goto LABEL_60;
            }
          }
          else
          {
            v70 = *(_DWORD *)((char *)lg_table + (v51 & 0x3FC));
            if (v70 >= 16)
              goto LABEL_53;
          }
          if (v70 < 8)
          {
            v54 = sqq_table[(int)v53] >> 4;
LABEL_64:
            if (v54 >= 1024)
              v73 = 1024;
            else
              v73 = v54;
            v74 = v54 <= v38;
            if (v54 > v38)
              v75 = v73;
            else
              v75 = v38;
            v577 = v75;
            if (v74)
              v76 = (unint64_t)v29;
            else
              v76 = (unint64_t)&v45[-4 * v73];
            v573 = (unint64_t)v45;
            v575 = v76;
            if (v74)
              v55 = v45;
            else
              v55 = &v45[-4 * v73];
            if (v74)
              v77 = 0;
            else
              v77 = v73;
            v561 = v77;
            v563 = (char *)v50;
            if (v55 - (char *)v50 <= 4096)
              goto LABEL_80;
LABEL_33:
            v56 = 0;
            do
            {
              ss_mintrosort(a1, v28, v50, (unint64_t)(v50 + 1024));
              v58 = (v573 - (unint64_t)(v50 + 1024)) >> 2;
              v579 = v50 + 1024;
              if (v577 >= (int)v58)
                v59 = v575;
              else
                v59 = (unint64_t)(v50 + 1024);
              v60 = v28;
              v61 = a1;
              if (v577 <= (int)v58)
                v62 = (v573 - (unint64_t)(v50 + 1024)) >> 2;
              else
                v62 = v577;
              if ((v56 & 1) != 0)
              {
                v63 = 1024;
                v64 = v56;
                do
                {
                  v65 = v64;
                  v66 = 4 * v63;
                  v67 = &v50[v66 / 0xFFFFFFFFFFFFFFFCLL];
                  ss_swapmerge(v61, v60, &v50[v66 / 0xFFFFFFFFFFFFFFFCLL], v50, (char *)&v50[(unint64_t)v66 / 4], v59, v62);
                  v63 *= 2;
                  v64 = v65 >> 1;
                  v50 = v67;
                }
                while ((v65 & 2) != 0);
              }
              ++v56;
              v57 = v579;
              v50 = v579;
              a1 = v61;
              v28 = v60;
            }
            while (v55 - (char *)v579 > 4096);
            ss_mintrosort(a1, v60, v579, (unint64_t)v55);
            v68 = 1024;
            v38 = v548 - 2 * v557;
            a4 = v551;
            a2 = v571;
            do
            {
              if ((v56 & 1) != 0)
              {
                v69 = v57;
                v57 -= v68;
                ss_swapmerge(a1, v60, v57, v69, v55, v575, v577);
              }
              v68 *= 2;
              v74 = v56 > 1;
              v56 >>= 1;
            }
            while (v74);
            goto LABEL_81;
          }
          v72 = (sqq_table[(int)v53 >> ((v70 & 0xFE) - 6)] >> (7 - (v70 >> 1))) + 1;
LABEL_60:
          v54 = v72 - (v72 * v72 > (int)v53);
          goto LABEL_64;
        }
      }
      v561 = 0;
      v577 = v38;
      v573 = (unint64_t)&a2[v44];
      v575 = (unint64_t)v29;
      v55 = (char *)v573;
      v563 = (char *)v50;
      if (v45 - (char *)v50 > 4096)
        goto LABEL_33;
LABEL_80:
      ss_mintrosort(a1, v28, v50, (unint64_t)v55);
LABEL_81:
      v30 = v557 - 1;
      if (!v561)
        goto LABEL_145;
      ss_mintrosort(a1, v28, (int *)v55, v573);
      v78 = (char *)v573;
      do
      {
        v79 = *((_DWORD *)v78 - 1);
        v80 = (unint64_t)(v55 - v563) >> 2;
        if ((int)v80 >= 1)
        {
          v81 = (int *)(v28 + 4 * (v79 ^ (v79 >> 31)));
          v83 = *v81;
          v82 = v81[1];
          v84 = v553 + v82;
          v85 = v553 + v83 < (unint64_t)(v553 + v82);
          v86 = -1;
          v87 = v563;
          while (1)
          {
            v91 = v80 >> 1;
            v92 = (int *)&v87[4 * (v80 >> 1)];
            v93 = (int *)(v28 + 4 * (*v92 ^ (*v92 >> 31)));
            v94 = *v93;
            v95 = v93[1];
            v96 = (unsigned __int8 *)(v553 + v94);
            v97 = v553 + v95;
            v99 = v553 + v94 >= (unint64_t)(v553 + v95);
            v98 = v553 + v94 < (unint64_t)(v553 + v95);
            v99 = v99 || v553 + v83 >= v84;
            if (!v99)
              break;
            v100 = (unsigned __int8 *)(v553 + v83);
            v101 = v85;
            if (v98)
            {
LABEL_103:
              if (!v101)
              {
                v88 = 1;
                goto LABEL_87;
              }
              v104 = *v96;
              v105 = *v100;
              goto LABEL_105;
            }
LABEL_86:
            v88 = v101 << 31 >> 31;
LABEL_87:
            v89 = (char *)(v92 + 1);
            v90 = (v80 | 0xFFFFFFFE) + 1;
            if (v88 < 0)
              v87 = v89;
            LODWORD(v80) = (v90 & (v88 >> 31)) + v91;
            if (v88 >= 0)
              v86 = v88;
            if ((int)v80 <= 0)
            {
              if (v87 >= v55)
                goto LABEL_142;
              if (!v86)
                *(_DWORD *)v87 = ~*(_DWORD *)v87;
LABEL_111:
              v108 = (unint64_t)(v55 - v87) >> 2;
              if ((int)v108 >= 1)
              {
                v109 = (unint64_t)(v78 - v55) >> 2;
                if ((int)v109 >= 1)
                {
                  v110 = v78;
                  v111 = v87;
                  while ((_DWORD)v108 != (_DWORD)v109)
                  {
                    if (v108 >= v109)
                    {
                      do
                      {
                        v117 = *(_DWORD *)v111;
                        v111 += 4;
                        v116 = v117;
                        v118 = v55;
                        do
                        {
                          *((_DWORD *)v111 - 1) = *(_DWORD *)v118;
                          v119 = *(_DWORD *)v111;
                          v111 += 4;
                          *(_DWORD *)v118 = v119;
                          v118 += 4;
                        }
                        while (v110 > v118);
                        *((_DWORD *)v111 - 1) = v116;
                        LODWORD(v108) = v108 + ~(_DWORD)v109;
                      }
                      while ((int)v108 > (int)v109);
                    }
                    else
                    {
                      for (v110 -= 4; ; v110 -= 4)
                      {
                        v112 = *(_DWORD *)v110;
                        v113 = v55 - 4;
                        do
                        {
                          v114 = v110;
                          v115 = *((_DWORD *)v110 - 1);
                          v110 -= 4;
                          *(_DWORD *)v114 = *(_DWORD *)v113;
                          *(_DWORD *)v113 = v115;
                          v113 -= 4;
                        }
                        while (v113 >= v111);
                        *(_DWORD *)v110 = v112;
                        LODWORD(v109) = v109 + ~(_DWORD)v108;
                        if ((int)v109 <= (int)v108)
                          break;
                      }
                    }
                    if ((int)v108 < 1 || (int)v109 <= 0)
                      goto LABEL_140;
                  }
                  v120 = (v109 - 1);
                  if (v120 < 7
                    || (v111 < &v55[4 * v120 + 4] ? (v121 = v55 >= &v111[4 * v120 + 4]) : (v121 = 1), !v121))
                  {
                    v124 = v55;
                    v125 = v111;
                    goto LABEL_138;
                  }
                  v122 = v120 + 1;
                  v123 = (v120 + 1) & 0x1FFFFFFF8;
                  LODWORD(v109) = v109 - v123;
                  v124 = &v55[4 * v123];
                  v125 = &v111[4 * v123];
                  v126 = (__int128 *)(v111 + 16);
                  v127 = (__int128 *)(v55 + 16);
                  v128 = v123;
                  do
                  {
                    v129 = *(v126 - 1);
                    v130 = *v126;
                    v131 = *v127;
                    *(v126 - 1) = *(v127 - 1);
                    *v126 = v131;
                    *(v127 - 1) = v129;
                    *v127 = v130;
                    v126 += 2;
                    v127 += 2;
                    v128 -= 8;
                  }
                  while (v128);
                  if (v122 != v123)
                  {
LABEL_138:
                    v132 = v109 + 1;
                    do
                    {
                      v133 = *(_DWORD *)v125;
                      *(_DWORD *)v125 = *(_DWORD *)v124;
                      v125 += 4;
                      *(_DWORD *)v124 = v133;
                      v124 += 4;
                      --v132;
                    }
                    while (v132 > 1);
                  }
                }
              }
LABEL_140:
              if (v87 != v563)
              {
                v78 -= v55 - v87;
                v55 = v87;
                goto LABEL_142;
              }
              goto LABEL_145;
            }
          }
          v102 = a1;
          while (1)
          {
            v103 = v102 + v94;
            v104 = *(unsigned __int8 *)(v102 + v94 + 2);
            v105 = *(unsigned __int8 *)(v102 + v83 + 2);
            if (v104 != v105)
              break;
            v106 = v102 + v83 + 3;
            v101 = v106 < v84;
            ++v102;
            v107 = v103 + 3 < v97;
            if (v103 + 3 >= v97 || v106 >= v84)
            {
              v100 = (unsigned __int8 *)(v102 + v83 + 2);
              v96 = (unsigned __int8 *)(v102 + v94 + 2);
              if (!v107)
                goto LABEL_86;
              goto LABEL_103;
            }
          }
LABEL_105:
          v88 = v104 - v105;
          goto LABEL_87;
        }
        v87 = v563;
        if (v55 > v563)
          goto LABEL_111;
LABEL_142:
        v78 -= 4;
        if (v79 < 0)
        {
          do
          {
            v134 = *((_DWORD *)v78 - 1);
            v78 -= 4;
          }
          while (v134 < 0);
        }
      }
      while (v55 != v78);
LABEL_145:
      v29 = v572;
      v42 = v555;
      v40 = v556;
      v41 = v569;
      v43 = v567;
      if (v565 == (_DWORD)v557 - 1)
      {
        v135 = v559;
        v136 = *v558;
        if ((unint64_t)v559 < v573)
        {
          v137 = *(int *)(v28 + 4 * v136);
          if (v553 + v137 >= v552)
          {
            do
            {
              if ((*v135 & 0x80000000) == 0)
                break;
              *(v135 - 1) = *v135;
              ++v135;
            }
            while ((unint64_t)v135 < v573);
          }
          else
          {
            v138 = (unsigned __int8 *)(v554 + v137);
            do
            {
              v139 = *v135;
              if ((v139 & 0x80000000) == 0)
              {
                v140 = (int *)(v28 + 4 * v139);
                v141 = *v140;
                v142 = v553 + v140[1];
                if (v553 + v141 < v142)
                {
                  v143 = (unsigned __int8 *)(v554 + v141);
                  v144 = v138;
                  do
                  {
                    v145 = v143;
                    v146 = v144;
                    v147 = *(v144 - 1);
                    v148 = *(v143 - 1);
                    if (v147 != v148)
                      goto LABEL_152;
                    v143 = v145 + 1;
                    v144 = v146 + 1;
                  }
                  while ((unint64_t)v146 < v552 && (unint64_t)v145 < v142);
                  if ((unint64_t)v146 >= v552)
                    break;
                  if ((unint64_t)v145 < v142)
                  {
                    v147 = *v146;
                    v148 = *v145;
LABEL_152:
                    if (v147 <= v148)
                      break;
                  }
                }
              }
              *(v135++ - 1) = v139;
            }
            while ((unint64_t)v135 < v573);
          }
        }
        *(v135 - 1) = v136;
      }
LABEL_23:
      if (v40 < --v43)
        continue;
      break;
    }
    --v40;
    if (v41 > 0)
      continue;
    break;
  }
  v149 = a2 - 1;
  v150 = v30;
  do
  {
    v151 = a2[v150];
    if ((v151 & 0x80000000) == 0)
    {
      v152 = 0;
      v153 = v150;
      while (1)
      {
        v29[v151] = v150 + v152;
        if (!(v153 * 4))
          break;
        v151 = v149[v153--];
        --v152;
        if ((v151 & 0x80000000) != 0)
        {
          v150 += v152;
          v149[v153 + 2] = v152;
          if (v150 + 1 < 2)
            goto LABEL_174;
          goto LABEL_171;
        }
      }
      *a2 = ~v150;
      v159 = v557;
      if (v557 < 0x10000)
        goto LABEL_175;
      goto LABEL_179;
    }
LABEL_171:
    v154 = &a2[v150];
    LODWORD(v155) = *v154;
    v156 = v150 + 1;
    do
    {
      v157 = ~(_DWORD)v155;
      *v154 = v157;
      v29[v157] = v150;
      v158 = *--v154;
      v155 = v158;
      --v156;
    }
    while ((v158 & 0x80000000) != 0);
    v29[v155] = v150;
    v150 = v156 - 2;
  }
  while (v156 > 1);
LABEL_174:
  v159 = v557;
  if (v557 < 0x10000)
  {
LABEL_175:
    if ((v159 & 0xFF00) != 0)
    {
      v160 = lg_table[v159 >> 8] + 8;
      v161 = -v159;
      v162 = *a2;
      v560 = v161;
      if (*a2 <= v161)
        goto LABEL_767;
    }
    else
    {
      v160 = lg_table[v159];
      v165 = -v159;
      v162 = *a2;
      v560 = v165;
      if (*a2 <= v165)
        goto LABEL_767;
    }
    goto LABEL_185;
  }
LABEL_179:
  if (HIBYTE(v159))
  {
    v160 = lg_table[HIBYTE(v159)] + 24;
    v164 = -v159;
    v162 = *a2;
    v560 = v164;
    if (*a2 <= v164)
      goto LABEL_767;
  }
  else
  {
    v160 = lg_table[HIWORD(v159)] + 16;
    v163 = -v159;
    v162 = *a2;
    v560 = v163;
    if (*a2 <= v163)
      goto LABEL_767;
  }
LABEL_185:
  v166 = (char *)(v29 + 1);
  v167 = 2 * v160 / 3;
  v168 = a2 + 1;
  v169 = -(uint64_t)a2;
  v578 = 4 - (_QWORD)a2;
  v170 = v557;
  v564 = a2 + 1;
  v566 = a1;
  while (2)
  {
    LODWORD(v171) = 0;
    v570 = 0;
    v562 = v166 - (char *)v29;
    v172 = (int)((v166 - (char *)v29) >> 2);
    v173 = a2;
    v568 = v166;
LABEL_190:
    if (v162 < 0)
    {
      v174 = &v173[-v162];
      LODWORD(v171) = v171 + v162;
LABEL_188:
      if (v174 >= v29)
      {
        if ((_DWORD)v171)
          v174[(int)v171] = v171;
        if (!v570)
          goto LABEL_767;
LABEL_764:
        v166 += v562;
        v162 = *a2;
        if (*a2 <= v560)
          goto LABEL_767;
        continue;
      }
LABEL_189:
      v162 = *v174;
      v173 = v174;
      goto LABEL_190;
    }
    break;
  }
  if ((_DWORD)v171)
    v173[(int)v171] = v171;
  v174 = &v168[v29[v162]];
  v175 = (char *)v174 - (char *)v173;
  if ((char *)v174 - (char *)v173 < 5)
  {
    if (v175 == 4)
      LODWORD(v171) = -1;
    else
      LODWORD(v171) = 0;
    goto LABEL_188;
  }
  v176 = v175 >> 2;
  if ((v175 >> 2) >= 0x10000)
  {
    if (BYTE3(v176))
      v177 = lg_table[(v175 >> 26)] + 24;
    else
      v177 = lg_table[(unsigned __int16)(v175 >> 18)] + 16;
  }
  else if ((v176 & 0xFF00) != 0)
  {
    v177 = lg_table[(v175 >> 10) & 0xFFFFFF] + 8;
  }
  else
  {
    v177 = *(_DWORD *)((char *)lg_table + (v175 & 0x3FC));
  }
  v178 = 0;
  v179 = 0;
  v180 = 0xFFFFFFFFLL;
  v574 = v173;
  v576 = v174;
  v181 = v173;
  v182 = (unint64_t)v174;
  v183 = v166;
  while (1)
  {
LABEL_209:
    while (1)
    {
      v186 = v179;
      v187 = v183;
      v188 = v182;
      v189 = v181;
      if ((v177 & 0x80000000) == 0)
        break;
      if (v177 == -2)
      {
        v224 = &v580[2 * (int)v179 - 2];
        v226 = *((_QWORD *)v224 + 1);
        v225 = *((_QWORD *)v224 + 2);
        v29 = v572;
        if (*((_DWORD *)v224 + 6))
        {
          a2 = v571;
          if ((v180 & 0x80000000) == 0)
            DWORD2(v580[2 * v180 + 1]) = -1;
          v227 = (unint64_t)(v183 - (char *)v572) >> 2;
          v228 = ((v225 - (unint64_t)v571) >> 2) - 1;
          v229 = (char *)(v226 - 4);
          v230 = -1;
          if (v226 - 4 >= (unint64_t)v181)
          {
            v356 = -1;
            v357 = v181;
            do
            {
              v358 = *v357;
              v359 = (v358 - v227);
              if ((int)v358 - (int)v227 >= 0 && v572[v359] == v228)
              {
                *((_DWORD *)v229 + 1) = v359;
                v229 += 4;
                v360 = v572[v358];
                if (v356 != v360)
                  v230 = (unint64_t)(v229 - (char *)v571) >> 2;
                v572[v359] = v230;
                v356 = v360;
              }
              ++v357;
            }
            while (v357 <= (int *)v229);
          }
          if (v229 >= (char *)v181)
          {
            v361 = (unint64_t)&v229[v169];
            v362 = -1;
            v363 = (int *)v229;
            do
            {
              v364 = *v363;
              v365 = v572[v364];
              if (v362 != v365)
                v230 = v361 >> 2;
              if (v230 != v365)
                v572[v364] = v230;
              --v363;
              v361 -= 4;
              v362 = v365;
            }
            while (v363 >= v181);
          }
          v231 = (unint64_t)(v229 + 4);
          if ((unint64_t)(v229 + 4) < v225)
          {
            v232 = (int *)(v182 - 4);
            v233 = -1;
            do
            {
              v235 = *v232--;
              v234 = v235;
              v236 = (v235 - v227);
              if ((int)v235 - (int)v227 >= 0 && v572[v236] == v228)
              {
                *(_DWORD *)(v225 - 4) = v236;
                v225 -= 4;
                v237 = v572[v234];
                if (v233 != v237)
                  v230 = (v225 - (unint64_t)v571) >> 2;
                v572[v236] = v230;
                v233 = v237;
              }
            }
            while (v231 < v225);
          }
        }
        else
        {
          v348 = (unint64_t)(v183 - (char *)v572) >> 2;
          a2 = v571;
          v349 = ((v225 - (unint64_t)v571) >> 2) - 1;
          v350 = v226 - 4;
          if (v350 >= (unint64_t)v181)
          {
            do
            {
              v353 = (*v189 - v348);
              if (*v189 - (int)v348 >= 0 && v572[v353] == v349)
              {
                *(_DWORD *)(v350 + 4) = v353;
                v350 += 4;
                v572[v353] = (v350 - (unint64_t)v571) >> 2;
              }
              ++v189;
            }
            while ((unint64_t)v189 <= v350);
          }
          v351 = v350 + 4;
          if (v351 < v225)
          {
            v352 = (int *)(v182 - 4);
            do
            {
              v354 = *v352--;
              v355 = (v354 - v348);
              if (v354 - (int)v348 >= 0 && v572[v355] == v349)
              {
                *(_DWORD *)(v225 - 4) = v355;
                v225 -= 4;
                v572[v355] = (v225 - (unint64_t)v571) >> 2;
              }
            }
            while (v351 < v225);
          }
        }
        if ((_DWORD)v179 == 1)
          goto LABEL_753;
        v179 = (int)v179 - 2;
        goto LABEL_208;
      }
      v29 = v572;
      if (v177 == -1)
      {
        v203 = &v183[-4 * v172];
        v204 = ((v182 - (unint64_t)v571) >> 2) - 1;
        v205 = v181;
        do
        {
          v206 = (char *)v205;
          if ((unint64_t)v205 >= v182)
            goto LABEL_336;
          ++v205;
          v207 = *(_DWORD *)&v203[4 * *(int *)v206];
        }
        while (v207 == v204);
        if (v207 >= v204)
        {
LABEL_336:
          v205 = (int *)v206;
          goto LABEL_337;
        }
        for (; (unint64_t)v205 < v182; ++v205)
        {
          v222 = *v205;
          v223 = *(_DWORD *)&v203[4 * v222];
          if (v223 > v204)
            break;
          if (v223 == v204)
          {
            *v205 = *(_DWORD *)v206;
            *(_DWORD *)v206 = v222;
            v206 += 4;
          }
        }
LABEL_337:
        v275 = (int *)(v182 - 4);
        while (1)
        {
          v276 = v275;
          if (v205 >= v275)
            break;
          --v275;
          v277 = *(_DWORD *)&v203[4 * *v276];
          if (v277 != v204)
          {
            if (v277 <= v204)
            {
              v275 = v276;
            }
            else
            {
              for (; v205 < v275; --v275)
              {
                v278 = *v275;
                v279 = *(_DWORD *)&v203[4 * v278];
                if (v279 < v204)
                  break;
                if (v279 == v204)
                {
                  *v275 = *v276;
                  *v276-- = v278;
                }
              }
            }
            break;
          }
        }
        while (v205 < v275)
        {
          v366 = *v205;
          *v205++ = *v275;
          *v275 = v366;
          while (v205 < v275)
          {
            v367 = *v205;
            v368 = *(_DWORD *)&v203[4 * v367];
            if (v368 > v204)
              break;
            if (v368 == v204)
            {
              *v205 = *(_DWORD *)v206;
              *(_DWORD *)v206 = v367;
              v206 += 4;
            }
            ++v205;
          }
          while (v205 < --v275)
          {
            v369 = *v275;
            v370 = *(_DWORD *)&v203[4 * v369];
            if (v370 < v204)
              break;
            if (v370 == v204)
            {
              *v275 = *v276;
              *v276-- = v369;
            }
          }
        }
        v181 = (int *)v182;
        v182 = (unint64_t)v189;
        if (v206 <= (char *)v276)
        {
          v371 = (unint64_t)(v206 - (char *)v189) >> 2;
          v372 = ((char *)v205 - v206) >> 2;
          if ((int)v371 >= (int)v372)
            v373 = v372;
          else
            v373 = v371;
          v374 = (v373 - 1);
          if ((int)v373 >= 1)
          {
            v375 = &v205[-v373];
            if (v373 < 8)
            {
              v376 = v189;
              goto LABEL_552;
            }
            v409 = v189 >= &v205[v374 - v373 + 1] || v375 >= &v189[v374 + 1];
            v376 = v189;
            if (!v409)
              goto LABEL_552;
            v410 = v373 & 0xFFFFFFF8;
            v375 = (int *)((char *)v375 + v410 * 4);
            v376 = &v189[v410];
            v411 = (__int128 *)(v189 + 4);
            v412 = &v205[-v373 + 4];
            v413 = v373 & 0xFFFFFFF8;
            do
            {
              v414 = *(v411 - 1);
              v415 = *v411;
              v416 = *(_OWORD *)v412;
              *(v411 - 1) = *((_OWORD *)v412 - 1);
              *v411 = v416;
              *((_OWORD *)v412 - 1) = v414;
              *(_OWORD *)v412 = v415;
              v411 += 2;
              v412 += 8;
              v413 -= 8;
            }
            while (v413);
            v519 = (v373 & 0x7FFFFFF8) == v373;
            LODWORD(v373) = v373 - (v373 & 0xFFFFFFF8);
            if (!v519)
            {
LABEL_552:
              v417 = v373 + 1;
              do
              {
                v418 = *v376;
                *v376++ = *v375;
                *v375++ = v418;
                --v417;
              }
              while (v417 > 1);
            }
          }
          v419 = v276 - (v205 - 1);
          v420 = ((v188 - (unint64_t)v276) >> 2) - 1;
          if (v420 >= (int)v419)
            v421 = v419;
          else
            v421 = v420;
          v422 = (v421 - 1);
          if ((int)v421 >= 1)
          {
            v423 = (int *)(v188 - 4 * v421);
            if (v421 < 8
              || ((unint64_t)v205 < v188 + 4 * (v422 - v421) + 4
                ? (v424 = v423 >= &v205[v422 + 1])
                : (v424 = 1),
                  !v424))
            {
              v425 = v421;
              v427 = v205;
              goto LABEL_569;
            }
            v425 = v421 - (v421 & 0xFFFFFFF8);
            v426 = v421 & 0xFFFFFFF8;
            v423 = (int *)((char *)v423 + v426 * 4);
            v427 = &v205[v426];
            v428 = (__int128 *)(v205 + 4);
            v429 = (__int128 *)(v188 - 4 * v421 + 16);
            v430 = v421 & 0xFFFFFFF8;
            do
            {
              v431 = *(v428 - 1);
              v432 = *v428;
              v433 = *v429;
              *(v428 - 1) = *(v429 - 1);
              *v428 = v433;
              *(v429 - 1) = v431;
              *v429 = v432;
              v428 += 2;
              v429 += 2;
              v430 -= 8;
            }
            while (v430);
            if ((v421 & 0x7FFFFFF8) != v421)
            {
LABEL_569:
              v434 = v425 + 1;
              do
              {
                v435 = *v427;
                *v427++ = *v423;
                *v423++ = v435;
                --v434;
              }
              while (v434 > 1);
            }
          }
          v182 = (unint64_t)&v189[v372];
          v181 = (int *)(v188 - 4 * v419);
        }
        if (v182 < v188 && (unint64_t)v189 < v182)
        {
          v436 = v189;
          do
          {
            v437 = *v436++;
            v572[v437] = ((v182 - (unint64_t)v571) >> 2) - 1;
          }
          while ((unint64_t)v436 < v182);
        }
        if ((unint64_t)v181 < v188 && v182 < (unint64_t)v181)
        {
          v438 = (int *)v182;
          do
          {
            v439 = *v438++;
            v572[v439] = ((unint64_t)((char *)v181 - (char *)v571) >> 2) - 1;
          }
          while (v438 < v181);
        }
        if ((uint64_t)((uint64_t)v181 - v182) >= 5)
        {
          v440 = &v580[2 * (int)v179];
          *(_QWORD *)v440 = 0;
          *((_QWORD *)v440 + 1) = v182;
          *((_QWORD *)v440 + 2) = v181;
          *((_QWORD *)v440 + 3) = 0;
          *((_QWORD *)v440 + 4) = v203;
          *((_QWORD *)v440 + 5) = v189;
          *((_QWORD *)v440 + 6) = v188;
          v179 = (v179 + 2);
          *((_DWORD *)v440 + 14) = -2;
          *((_DWORD *)v440 + 15) = v180;
          v441 = v182 - (_QWORD)v189;
          v442 = (uint64_t)(v182 - (_QWORD)v189) >> 2;
          v443 = v188 - (_QWORD)v181;
          v444 = (uint64_t)(v188 - (_QWORD)v181) >> 2;
          if (v442 <= v444)
            goto LABEL_582;
LABEL_589:
          if ((uint64_t)v443 >= 5)
          {
            v450 = (char **)&v580[2 * (int)v179];
            *v450 = v187;
            v450[1] = (char *)v189;
            v450[2] = (char *)v182;
            v451 = v441 >> 2;
            if ((v441 >> 2) >= 0x10000)
            {
              if (BYTE3(v451))
              {
                v491 = &v580[2 * (int)v179];
                v179 = (v179 + 1);
                *((_DWORD *)v491 + 6) = lg_table[(v441 >> 26)] + 24;
                *((_DWORD *)v491 + 7) = v186;
                v453 = v443 >> 2;
                if ((v443 >> 2) >= 0x10000)
                  goto LABEL_613;
              }
              else
              {
                v459 = &v580[2 * (int)v179];
                v179 = (v179 + 1);
                *((_DWORD *)v459 + 6) = lg_table[(unsigned __int16)(v441 >> 18)] + 16;
                *((_DWORD *)v459 + 7) = v186;
                v453 = v443 >> 2;
                if ((v443 >> 2) >= 0x10000)
                  goto LABEL_613;
              }
            }
            else
            {
              if ((v451 & 0xFF00) != 0)
              {
                v452 = &v580[2 * (int)v179];
                v179 = (v179 + 1);
                *((_DWORD *)v452 + 6) = lg_table[(v441 >> 10) & 0xFFFFFF] + 8;
                *((_DWORD *)v452 + 7) = v186;
                v453 = v443 >> 2;
                if ((v443 >> 2) < 0x10000)
                  goto LABEL_593;
LABEL_613:
                if (!BYTE3(v453))
                {
                  v460 = (unsigned __int16)(v443 >> 18);
                  goto LABEL_682;
                }
                v492 = (v443 >> 26);
LABEL_734:
                v177 = lg_table[v492] + 24;
                v182 = v188;
                goto LABEL_738;
              }
              v494 = &v580[2 * (int)v179];
              v179 = (v179 + 1);
              *((_DWORD *)v494 + 6) = *(_DWORD *)((char *)lg_table + (v441 & 0x3FC));
              *((_DWORD *)v494 + 7) = v186;
              v453 = v443 >> 2;
              if ((v443 >> 2) >= 0x10000)
                goto LABEL_613;
            }
LABEL_593:
            if ((v453 & 0xFF00) != 0)
            {
              v454 = (v443 >> 10) & 0xFFFFFF;
LABEL_599:
              v177 = lg_table[v454] + 8;
              v182 = v188;
              goto LABEL_738;
            }
            goto LABEL_678;
          }
          if ((uint64_t)v441 < 5)
          {
LABEL_605:
            if (!(_DWORD)v179)
              goto LABEL_759;
            v184 = (int)v179;
            goto LABEL_207;
          }
          v456 = v441 >> 2;
          if ((v441 >> 2) < 0x10000)
          {
            if ((v456 & 0xFF00) != 0)
            {
              v449 = v442 >> 8;
LABEL_604:
              v177 = lg_table[v449] + 8;
LABEL_737:
              v181 = v189;
              goto LABEL_738;
            }
LABEL_679:
            v177 = *(_DWORD *)((char *)lg_table + (v441 & 0x3FC));
            goto LABEL_737;
          }
          if (!BYTE3(v456))
          {
            v458 = WORD1(v442);
            goto LABEL_685;
          }
          v490 = BYTE3(v442);
          goto LABEL_736;
        }
        v186 = v180;
        v441 = v182 - (_QWORD)v189;
        v442 = (uint64_t)(v182 - (_QWORD)v189) >> 2;
        v443 = v188 - (_QWORD)v181;
        v444 = (uint64_t)(v188 - (_QWORD)v181) >> 2;
        if (v442 > v444)
          goto LABEL_589;
LABEL_582:
        if ((uint64_t)v441 < 5)
        {
          if ((uint64_t)v443 < 5)
            goto LABEL_605;
          v455 = v443 >> 2;
          if ((v443 >> 2) >= 0x10000)
          {
            if (BYTE3(v455))
            {
              v492 = BYTE3(v444);
              goto LABEL_734;
            }
            v460 = WORD1(v444);
LABEL_682:
            v177 = lg_table[v460] + 16;
            v182 = v188;
LABEL_738:
            v183 = v187;
            v180 = v186;
            continue;
          }
          if ((v455 & 0xFF00) != 0)
          {
            v454 = v444 >> 8;
            goto LABEL_599;
          }
LABEL_678:
          v177 = *(_DWORD *)((char *)lg_table + (v443 & 0x3FC));
          v182 = v188;
          goto LABEL_738;
        }
        v445 = (char **)&v580[2 * (int)v179];
        *v445 = v187;
        v445[1] = (char *)v181;
        v445[2] = (char *)v188;
        v446 = v443 >> 2;
        if ((v443 >> 2) >= 0x10000)
        {
          if (BYTE3(v446))
          {
            v489 = &v580[2 * (int)v179];
            v179 = (v179 + 1);
            *((_DWORD *)v489 + 6) = lg_table[(v443 >> 26)] + 24;
            *((_DWORD *)v489 + 7) = v186;
            v448 = v441 >> 2;
            if ((v441 >> 2) >= 0x10000)
              goto LABEL_609;
          }
          else
          {
            v457 = &v580[2 * (int)v179];
            v179 = (v179 + 1);
            *((_DWORD *)v457 + 6) = lg_table[(unsigned __int16)(v443 >> 18)] + 16;
            *((_DWORD *)v457 + 7) = v186;
            v448 = v441 >> 2;
            if ((v441 >> 2) >= 0x10000)
              goto LABEL_609;
          }
        }
        else
        {
          if ((v446 & 0xFF00) != 0)
          {
            v447 = &v580[2 * (int)v179];
            v179 = (v179 + 1);
            *((_DWORD *)v447 + 6) = lg_table[(v443 >> 10) & 0xFFFFFF] + 8;
            *((_DWORD *)v447 + 7) = v186;
            v448 = v441 >> 2;
            if ((v441 >> 2) < 0x10000)
              goto LABEL_586;
LABEL_609:
            if (!BYTE3(v448))
            {
              v458 = (unsigned __int16)(v441 >> 18);
LABEL_685:
              v177 = lg_table[v458] + 16;
              goto LABEL_737;
            }
            v490 = (v441 >> 26);
LABEL_736:
            v177 = lg_table[v490] + 24;
            goto LABEL_737;
          }
          v493 = &v580[2 * (int)v179];
          v179 = (v179 + 1);
          *((_DWORD *)v493 + 6) = *(_DWORD *)((char *)lg_table + (v443 & 0x3FC));
          *((_DWORD *)v493 + 7) = v186;
          v448 = v441 >> 2;
          if ((v441 >> 2) >= 0x10000)
            goto LABEL_609;
        }
LABEL_586:
        if ((v448 & 0xFF00) != 0)
        {
          v449 = (v441 >> 10) & 0xFFFFFF;
          goto LABEL_604;
        }
        goto LABEL_679;
      }
LABEL_632:
      v472 = *v181;
      if ((v472 & 0x80000000) != 0)
      {
        if ((unint64_t)v181 >= v188)
          goto LABEL_205;
      }
      else
      {
        v473 = v181 + 1;
        v474 = (unint64_t)v181 + v169;
        do
        {
          v181 = v473;
          v29[v472] = v474 >> 2;
          if ((unint64_t)v473 >= v188)
            break;
          ++v473;
          v472 = *v181;
          v474 += 4;
        }
        while ((v472 & 0x80000000) == 0);
        if ((unint64_t)v181 >= v188)
        {
LABEL_205:
          if (!(_DWORD)v186)
          {
            a2 = v571;
LABEL_753:
            a4 = v551;
            a1 = v566;
            v30 = v557 - 1;
            v508 = v574;
            v174 = v576;
            if (v178)
              goto LABEL_754;
            goto LABEL_760;
          }
LABEL_206:
          v184 = (int)v186;
LABEL_207:
          v179 = v184 - 1;
LABEL_208:
          v185 = &v580[2 * v179];
          v183 = *(char **)v185;
          v181 = (int *)*((_QWORD *)v185 + 1);
          v182 = *((_QWORD *)v185 + 2);
          v177 = *((_DWORD *)v185 + 6);
          v180 = *((unsigned int *)v185 + 7);
          continue;
        }
      }
      v479 = 0;
      LODWORD(v480) = *v181;
      do
      {
        v181[v479] = ~(_DWORD)v480;
        v480 = v181[++v479];
      }
      while ((v480 & 0x80000000) != 0);
      if (v29[v480] == *(_DWORD *)&v187[4 * v480])
      {
        v177 = -1;
        v182 = (unint64_t)&v181[v479 + 1];
        if (v182 < v188)
          goto LABEL_660;
      }
      else
      {
        v481 = ((unint64_t)(v479 * 4) >> 2) + 1;
        if (v481 >= 0x10000)
        {
          if (HIBYTE(v481))
          {
            v177 = lg_table[HIBYTE(v481)] + 24;
            v182 = (unint64_t)&v181[v479 + 1];
            if (v182 < v188)
              goto LABEL_660;
          }
          else
          {
            v177 = lg_table[HIWORD(v481)] + 16;
            v182 = (unint64_t)&v181[v479 + 1];
            if (v182 < v188)
              goto LABEL_660;
          }
        }
        else if ((v481 & 0xFF00) != 0)
        {
          v177 = lg_table[v481 >> 8] + 8;
          v182 = (unint64_t)&v181[v479 + 1];
          if (v182 < v188)
            goto LABEL_660;
        }
        else
        {
          v177 = lg_table[(((unint64_t)(v479 * 4) >> 2) + 1)];
          v182 = (unint64_t)&v181[v479 + 1];
          if (v182 < v188)
          {
LABEL_660:
            if ((unint64_t)v181 < v182)
            {
              v482 = v181;
              do
              {
                v483 = *v482++;
                v29[v483] = (((unint64_t)v181 + v578 + v479 * 4) >> 2) - 1;
              }
              while ((unint64_t)v482 < v182);
            }
          }
        }
      }
      v484 = (unint64_t)(v479 * 4 + 4) >> 2;
      if (v170 >= (int)v484)
      {
LABEL_666:
        v170 -= v484;
        v485 = v188 - (_QWORD)v181 - v479 * 4 - 4;
        if (v479 * 4 + 4 <= v485)
        {
          v487 = &v580[2 * (int)v186];
          *(_QWORD *)v487 = v187;
          *((_QWORD *)v487 + 1) = v182;
          *((_QWORD *)v487 + 2) = v188;
          v179 = (v186 + 1);
          *((_DWORD *)v487 + 6) = -3;
          *((_DWORD *)v487 + 7) = v180;
          v183 = &v187[4 * v172];
        }
        else
        {
          v183 = &v187[4 * v172];
          v179 = v186;
          if (v485 >= 5)
          {
            v486 = &v580[2 * (int)v186];
            *(_QWORD *)v486 = v183;
            *((_QWORD *)v486 + 1) = v181;
            *((_QWORD *)v486 + 2) = v182;
            v179 = (v186 + 1);
            *((_DWORD *)v486 + 6) = v177;
            *((_DWORD *)v486 + 7) = v180;
            v177 = -3;
            v181 = (int *)v182;
            v182 = v188;
            v183 = v187;
          }
        }
      }
      else
      {
        if (v167)
        {
          v170 += v557;
          --v167;
          goto LABEL_666;
        }
        if ((v180 & 0x80000000) == 0)
          DWORD2(v580[2 * v180 + 1]) = -1;
        v167 = 0;
        v178 += v484;
        v488 = v188 - (_QWORD)v181 - v479 * 4 - 4;
        v177 = -3;
        v181 = (int *)v182;
        v182 = v188;
        v183 = v187;
        v179 = v186;
        if (v488 <= 4)
        {
          if ((_DWORD)v186)
            goto LABEL_674;
          v167 = 0;
LABEL_759:
          a2 = v571;
          v29 = v572;
          a4 = v551;
          a1 = v566;
          v30 = v557 - 1;
          v508 = v574;
          v174 = v576;
          if (v178)
            goto LABEL_754;
LABEL_760:
          v171 = (unint64_t)((char *)v508 - (char *)v174) >> 2;
          v166 = v568;
          v168 = v564;
          goto LABEL_188;
        }
      }
    }
    v190 = v182 - (_QWORD)v181;
    v191 = (uint64_t)(v182 - (_QWORD)v181) >> 2;
    LODWORD(v192) = v191 - 1;
    if ((int)v191 >= 1)
      v193 = v191 - 1;
    else
      v193 = (uint64_t)(v182 - (_QWORD)v181) >> 2;
    if ((uint64_t)v190 <= 35)
    {
      v194 = v181 + 1;
      v29 = v572;
      if ((unint64_t)(v181 + 1) < v182)
      {
        v195 = (unsigned int *)v181;
        do
        {
          v196 = (unsigned int *)v194;
          v197 = v195[1];
          v198 = (int)*v195;
          v199 = *(_DWORD *)&v187[4 * v197];
          v200 = *(_DWORD *)&v187[4 * v198];
          if (v199 >= v200)
          {
            v202 = v195;
          }
          else
          {
LABEL_218:
            v201 = (int *)(v195 - 1);
            while (1)
            {
              v202 = (unsigned int *)v201;
              v201[2] = v198;
              if (v201 < v181)
                break;
              --v201;
              v198 = *v202;
              if ((v198 & 0x80000000) == 0)
              {
                v199 = *(_DWORD *)&v187[4 * v197];
                v200 = *(_DWORD *)&v187[4 * v198];
                v195 = v202;
                if (v199 < v200)
                  goto LABEL_218;
                break;
              }
            }
          }
          if (v199 == v200)
            *v202 = ~*v202;
          v202[1] = v197;
          v194 = (int *)(v196 + 1);
          v195 = v196;
        }
        while ((unint64_t)(v196 + 1) < v182);
      }
      goto LABEL_632;
    }
    v208 = (char *)(v182 - 4);
    if (!v177)
    {
      if ((v191 & 1) != 0)
      {
        v192 = (uint64_t)(v188 - (_QWORD)v181) >> 2;
        if ((int)v191 < 2)
        {
LABEL_631:
          v29 = v572;
          while (v181 < (int *)v208)
          {
            v476 = *(int *)v208;
            v208 -= 4;
            v475 = v476;
            if (v181 <= (int *)v208)
            {
              v477 = *(_DWORD *)&v187[4 * v475];
              do
              {
                v478 = *(int *)v208;
                if (*(_DWORD *)&v187[4 * v478] != v477)
                  break;
                *(_DWORD *)v208 = ~(_DWORD)v478;
                v208 -= 4;
              }
              while (v181 <= (int *)v208);
            }
          }
          goto LABEL_632;
        }
      }
      else
      {
        v238 = (uint64_t)v193 >> 1;
        v239 = v181[v238];
        v240 = (int)v192;
        v241 = v181[(int)v192];
        if (*(_DWORD *)&v187[4 * v239] < *(_DWORD *)&v187[4 * v241])
        {
          v181[(int)v192] = v239;
          v181[v238] = v241;
        }
        if ((int)v191 <= 2)
        {
          v242 = *v181;
          v243 = v240;
          *v181 = v181[v243];
          v181[v243] = v242;
          goto LABEL_631;
        }
      }
      v280 = v192 >> 1;
      do
      {
        v282 = v181[(v280 - 1)];
        v283 = (2 * (v280 - 1)) | 1;
        if (v283 >= (int)v192)
        {
          v281 = v280 - 1;
        }
        else
        {
          v284 = *(_DWORD *)&v187[4 * v282];
          v285 = 2 * (v280 - 1);
          v286 = v280 - 1;
          while (1)
          {
            v281 = v285 + 2;
            v287 = *(_DWORD *)&v187[4 * v181[v283]];
            v288 = *(_DWORD *)&v187[4 * v181[v281]];
            v289 = v287 <= v288 ? *(_DWORD *)&v187[4 * v181[v281]] : *(_DWORD *)&v187[4 * v181[v283]];
            if (v289 <= v284)
              break;
            if (v287 >= v288)
              v281 = v283;
            v181[v286] = v181[v281];
            v285 = 2 * v281;
            v283 = (2 * v281) | 1;
            v286 = v281;
            if (v283 >= (int)v192)
              goto LABEL_351;
          }
          v281 = v286;
        }
LABEL_351:
        v181[v281] = v282;
        v74 = v280-- <= 1;
      }
      while (!v74);
      if ((v191 & 1) == 0)
      {
        v290 = 0;
        LODWORD(v291) = 0;
        v292 = *v181;
        v293 = (int)v192;
        *v181 = v181[v293];
        v181[v293] = v292;
        v294 = *v181;
        v295 = *(_DWORD *)&v187[4 * v294];
        v296 = 1;
        while (1)
        {
          v297 = v290 + 2;
          v298 = *(_DWORD *)&v187[4 * v181[v296]];
          v299 = *(_DWORD *)&v187[4 * v181[v297]];
          v300 = v298 <= v299 ? *(_DWORD *)&v187[4 * v181[v297]] : *(_DWORD *)&v187[4 * v181[v296]];
          if (v300 <= v295)
            break;
          if (v298 >= v299)
            v297 = v296;
          v181[(int)v291] = v181[v297];
          v290 = 2 * v297;
          v296 = (2 * v297) | 1;
          LODWORD(v291) = v297;
          if (v296 >= (int)v192)
          {
            v291 = v297;
            goto LABEL_616;
          }
        }
        v291 = (int)v291;
LABEL_616:
        v181[v291] = v294;
      }
      v461 = v192;
      do
      {
        v463 = *v181;
        v464 = v181[(v461 - 1)];
        *v181 = v464;
        if ((v461 - 1) < 2)
        {
          v462 = 0;
        }
        else
        {
          v465 = 0;
          v466 = 0;
          v467 = *(_DWORD *)&v187[4 * v464];
          v468 = 1;
          while (1)
          {
            v462 = v465 + 2;
            v469 = *(_DWORD *)&v187[4 * v181[v468]];
            v470 = *(_DWORD *)&v187[4 * v181[v462]];
            v471 = v469 <= v470 ? *(_DWORD *)&v187[4 * v181[v462]] : *(_DWORD *)&v187[4 * v181[v468]];
            if (v471 <= v467)
              break;
            if (v469 >= v470)
              v462 = v468;
            v181[v466] = v181[v462];
            v465 = 2 * v462;
            v468 = (2 * v462) | 1;
            v466 = v462;
            if (v468 >= (int)v461 - 1)
              goto LABEL_619;
          }
          v462 = v466;
        }
LABEL_619:
        v181[v462] = v464;
        v181[(v461 - 1)] = v463;
        v74 = v461-- <= 2;
      }
      while (!v74);
      goto LABEL_631;
    }
    v209 = v190 >> 2;
    v210 = ((v190 >> 2) & 0x80000000) == 0 ? v190 >> 2 : (int)v209 + 1;
    v211 = &v181[v210 >> 1];
    if ((int)v209 > 512)
    {
      v244 = v209 >> 3;
      v245 = &v181[v244];
      v246 = (2 * v244);
      v212 = *v189;
      v247 = *(_DWORD *)&v187[4 * v212];
      v248 = *(_DWORD *)&v187[4 * *v245];
      if (v247 <= v248)
        v249 = *v245;
      else
        v249 = *v189;
      if (v247 <= v248)
        v250 = &v189[v244];
      else
        v250 = v189;
      v251 = *(_DWORD *)&v187[4 * v189[v246]];
      if (*(_DWORD *)&v187[4 * v249] > v251)
      {
        if (v247 <= v248)
          v252 = *v189;
        else
          v252 = *v245;
        if (v247 <= v248)
          v245 = v189;
        if (*(_DWORD *)&v187[4 * v252] <= v251)
          v250 = &v189[v246];
        else
          v250 = v245;
      }
      v253 = &v211[v244];
      v254 = *(_DWORD *)&v187[4 * v211[-v244]];
      v255 = *(_DWORD *)&v187[4 * *v211];
      if (v254 <= v255)
        v256 = *v211;
      else
        v256 = v211[-v244];
      if (v254 <= v255)
        v257 = v211;
      else
        v257 = &v211[-v244];
      v258 = *(_DWORD *)&v187[4 * v256];
      v259 = *(_DWORD *)&v187[4 * *v253];
      if (v258 > v259)
      {
        if (v254 <= v255)
          v260 = v211[-v244];
        else
          v260 = *v211;
        if (v254 <= v255)
          v211 -= v244;
        if (*(_DWORD *)&v187[4 * v260] <= v259)
          v257 = v253;
        else
          v257 = v211;
      }
      v261 = (int *)&v208[-4 * v246];
      v262 = (int *)&v208[-4 * v244];
      v263 = *(_DWORD *)&v187[4 * *v261];
      v264 = *(_DWORD *)&v187[4 * *v262];
      if (v263 <= v264)
        v265 = *v262;
      else
        v265 = *v261;
      if (v263 <= v264)
        v266 = (int *)&v208[-4 * v244];
      else
        v266 = (int *)&v208[-4 * v246];
      v267 = *(_DWORD *)&v187[4 * v265];
      v268 = *(_DWORD *)&v187[4 * *(int *)v208];
      if (v267 > v268)
      {
        if (v263 <= v264)
          v269 = *v261;
        else
          v269 = *v262;
        v270 = *(_DWORD *)&v187[4 * v269];
        if (v263 > v264)
          v261 = (int *)&v208[-4 * v244];
        if (v270 <= v268)
          v266 = (int *)(v188 - 4);
        else
          v266 = v261;
        v267 = *(_DWORD *)&v187[4 * *v266];
      }
      v271 = *v250;
      v272 = *(_DWORD *)&v187[4 * v271];
      v273 = *(_DWORD *)&v187[4 * *v257];
      if (v272 <= v273)
        v274 = *v257;
      else
        v274 = *v250;
      if (v272 <= v273)
        v216 = v257;
      else
        v216 = v250;
      if (*(_DWORD *)&v187[4 * v274] > v267)
      {
        if (v272 > v273)
        {
          LODWORD(v271) = *v257;
          v250 = v257;
        }
        if (*(_DWORD *)&v187[4 * (int)v271] <= v267)
          v216 = v266;
        else
          v216 = v250;
      }
    }
    else if ((int)v209 > 32)
    {
      v301 = (v190 >> 4) & 0x3FFFFFFF;
      v302 = &v181[v301];
      v303 = (int *)&v208[-(v301 * 4)];
      v304 = *v302;
      v305 = *(_DWORD *)&v187[4 * v304];
      v306 = *(_DWORD *)&v187[4 * *v211];
      v307 = v305 <= v306;
      if (v305 <= v306)
      {
        v308 = v302;
      }
      else
      {
        LODWORD(v304) = *v211;
        v308 = v211;
      }
      if (v307)
        v302 = v211;
      v309 = *v303;
      v310 = *(_DWORD *)&v187[4 * v309];
      v311 = *(_DWORD *)&v187[4 * *(int *)v208];
      v312 = v310 <= v311;
      if (v310 <= v311)
      {
        v313 = v303;
      }
      else
      {
        LODWORD(v309) = *(_DWORD *)v208;
        v313 = (int *)(v188 - 4);
      }
      if (v312)
        v303 = (int *)(v188 - 4);
      v314 = *(_DWORD *)&v187[4 * (int)v304];
      v315 = *(_DWORD *)&v187[4 * (int)v309];
      v316 = v314 <= v315;
      if (v314 <= v315)
        v317 = v302;
      else
        v317 = v303;
      if (v316)
        v318 = v313;
      else
        v318 = v308;
      if (!v316)
        v303 = v302;
      v319 = *(_DWORD *)&v187[4 * *v181];
      v320 = *(_DWORD *)&v187[4 * *v317];
      v321 = v319 <= v320;
      if (v319 <= v320)
        v322 = *v181;
      else
        v322 = *v317;
      if (v321)
        v323 = v181;
      else
        v323 = v317;
      if (!v321)
        v317 = v181;
      if (*(_DWORD *)&v187[4 * v322] > *(_DWORD *)&v187[4 * *v318])
      {
        v324 = v323;
      }
      else
      {
        v303 = v317;
        v324 = v318;
      }
      v216 = *(_DWORD *)&v187[4 * *v303] <= *(_DWORD *)&v187[4 * *v324] ? v303 : v324;
      LODWORD(v212) = *v181;
    }
    else
    {
      v212 = *v181;
      v213 = *(_DWORD *)&v187[4 * v212];
      v214 = *(_DWORD *)&v187[4 * *v211];
      if (v213 <= v214)
        v215 = *v211;
      else
        v215 = *v181;
      if (v213 <= v214)
        v216 = v211;
      else
        v216 = v181;
      v217 = *(_DWORD *)&v187[4 * v215];
      v218 = *(_DWORD *)&v187[4 * *(int *)v208];
      if (v217 > v218)
      {
        v219 = v213 <= v214;
        if (v213 <= v214)
          v220 = *v181;
        else
          v220 = *v211;
        if (v219)
          v221 = v181;
        else
          v221 = v211;
        if (*(_DWORD *)&v187[4 * v220] <= v218)
          v216 = (int *)(v188 - 4);
        else
          v216 = v221;
      }
    }
    v325 = v177 - 1;
    *v189 = *v216;
    *v216 = v212;
    v326 = v189 + 1;
    v327 = *(_DWORD *)&v187[4 * *v189];
    do
    {
      v328 = (char *)v326;
      if ((unint64_t)v326 >= v188)
        goto LABEL_420;
      ++v326;
      v329 = *(_DWORD *)&v187[4 * *(int *)v328];
    }
    while (v329 == v327);
    if (v329 >= v327)
    {
      v326 = (int *)v328;
    }
    else
    {
      for (; (unint64_t)v326 < v188; ++v326)
      {
        v330 = *v326;
        v331 = *(_DWORD *)&v187[4 * v330];
        if (v331 > v327)
          break;
        if (v331 == v327)
        {
          *v326 = *(_DWORD *)v328;
          *(_DWORD *)v328 = v330;
          v328 += 4;
        }
      }
    }
LABEL_420:
    while (1)
    {
      v332 = v208;
      if (v326 >= (int *)v208)
        break;
      v208 -= 4;
      v333 = *(_DWORD *)&v187[4 * *(int *)v332];
      if (v333 != v327)
      {
        if (v333 <= v327)
        {
          v208 = v332;
        }
        else
        {
          for (; v326 < (int *)v208; v208 -= 4)
          {
            v334 = *(int *)v208;
            v335 = *(_DWORD *)&v187[4 * v334];
            if (v335 < v327)
              break;
            if (v335 == v327)
            {
              *(_DWORD *)v208 = *(_DWORD *)v332;
              *(_DWORD *)v332 = v334;
              v332 -= 4;
            }
          }
        }
        break;
      }
    }
    while (v326 < (int *)v208)
    {
      v336 = *v326;
      *v326++ = *(_DWORD *)v208;
      *(_DWORD *)v208 = v336;
      while (v326 < (int *)v208)
      {
        v337 = *v326;
        v338 = *(_DWORD *)&v187[4 * v337];
        if (v338 > v327)
          break;
        if (v338 == v327)
        {
          *v326 = *(_DWORD *)v328;
          *(_DWORD *)v328 = v337;
          v328 += 4;
        }
        ++v326;
      }
      while (1)
      {
        v208 -= 4;
        if (v326 >= (int *)v208)
          break;
        v339 = *(int *)v208;
        v340 = *(_DWORD *)&v187[4 * v339];
        if (v340 < v327)
          break;
        if (v340 == v327)
        {
          *(_DWORD *)v208 = *(_DWORD *)v332;
          *(_DWORD *)v332 = v339;
          v332 -= 4;
        }
      }
    }
    if (v328 > v332)
      break;
    v341 = (unint64_t)(v328 - (char *)v189) >> 2;
    v342 = (char *)v326 - v328;
    v343 = ((char *)v326 - v328) >> 2;
    if ((int)v341 >= (int)v343)
      v344 = v343;
    else
      v344 = v341;
    v345 = (v344 - 1);
    if ((int)v344 >= 1)
    {
      v346 = &v326[-v344];
      if (v344 < 8)
      {
        v347 = v189;
LABEL_502:
        v385 = v344 + 1;
        do
        {
          v386 = *v347;
          *v347++ = *v346;
          *v346++ = v386;
          --v385;
        }
        while (v385 > 1);
        goto LABEL_504;
      }
      v377 = v189 >= &v326[v345 - v344 + 1] || v346 >= &v189[v345 + 1];
      v347 = v189;
      if (!v377)
        goto LABEL_502;
      v378 = v344 & 0xFFFFFFF8;
      v346 = (int *)((char *)v346 + v378 * 4);
      v347 = &v189[v378];
      v379 = (__int128 *)(v189 + 4);
      v380 = &v326[-v344 + 4];
      v381 = v344 & 0xFFFFFFF8;
      do
      {
        v382 = *(v379 - 1);
        v383 = *v379;
        v384 = *(_OWORD *)v380;
        *(v379 - 1) = *((_OWORD *)v380 - 1);
        *v379 = v384;
        *((_OWORD *)v380 - 1) = v382;
        *(_OWORD *)v380 = v383;
        v379 += 2;
        v380 += 8;
        v381 -= 8;
      }
      while (v381);
      v519 = (v344 & 0x7FFFFFF8) == v344;
      LODWORD(v344) = v344 - (v344 & 0xFFFFFFF8);
      if (!v519)
        goto LABEL_502;
    }
LABEL_504:
    v387 = v332 - (char *)(v326 - 1);
    v388 = v387 >> 2;
    v389 = ((v188 - (unint64_t)v332) >> 2) - 1;
    if (v389 >= (int)(v387 >> 2))
      v390 = v388;
    else
      v390 = v389;
    v391 = (v390 - 1);
    if ((int)v390 >= 1)
    {
      v392 = (int *)(v188 - 4 * v390);
      if (v390 < 8
        || ((unint64_t)v326 < v188 + 4 * (v391 - v390) + 4
          ? (v393 = v392 >= &v326[v391 + 1])
          : (v393 = 1),
            !v393))
      {
        v394 = v390;
        v396 = v326;
LABEL_519:
        v403 = v394 + 1;
        do
        {
          v404 = *v396;
          *v396++ = *v392;
          *v392++ = v404;
          --v403;
        }
        while (v403 > 1);
        goto LABEL_521;
      }
      v394 = v390 - (v390 & 0xFFFFFFF8);
      v395 = v390 & 0xFFFFFFF8;
      v392 = (int *)((char *)v392 + v395 * 4);
      v396 = &v326[v395];
      v397 = (__int128 *)(v326 + 4);
      v398 = (__int128 *)(v188 - 4 * v390 + 16);
      v399 = v390 & 0xFFFFFFF8;
      do
      {
        v400 = *(v397 - 1);
        v401 = *v397;
        v402 = *v398;
        *(v397 - 1) = *(v398 - 1);
        *v397 = v402;
        *(v398 - 1) = v400;
        *v398 = v401;
        v397 += 2;
        v398 += 2;
        v399 -= 8;
      }
      while (v399);
      if ((v390 & 0x7FFFFFF8) != v390)
        goto LABEL_519;
    }
LABEL_521:
    v405 = &v189[v343];
    v182 = v188 - 4 * v388;
    v406 = v182 - (_QWORD)v405;
    v407 = (uint64_t)(v182 - (_QWORD)v405) >> 2;
    if (v191 == v407)
      break;
    v408 = (unint64_t)v406 >> 2;
    if (v572[*v405] == v327)
    {
      v177 = -1;
      if (v342 < 1)
        goto LABEL_701;
    }
    else if (v408 >= 0x10000)
    {
      if (BYTE3(v408))
      {
        v177 = lg_table[BYTE3(v407)] + 24;
        if (v342 < 1)
          goto LABEL_701;
      }
      else
      {
        v177 = lg_table[WORD1(v407)] + 16;
        if (v342 < 1)
          goto LABEL_701;
      }
    }
    else if ((v408 & 0xFF00) != 0)
    {
      v177 = lg_table[v407 >> 8] + 8;
      if (v342 < 1)
        goto LABEL_701;
    }
    else
    {
      v177 = *(_DWORD *)((char *)lg_table + (v406 & 0x3FC));
      if (v342 < 1)
        goto LABEL_701;
    }
    v495 = v189;
    do
    {
      v496 = *v495++;
      v572[v496] = ((unint64_t)((char *)v405 - (char *)v571) >> 2) - 1;
    }
    while (v495 < v405);
LABEL_701:
    if (v387 >= 1 && (unint64_t)v405 < v182)
    {
      v497 = &v189[v343];
      do
      {
        v498 = *v497++;
        v572[v498] = ((v182 - (unint64_t)v571) >> 2) - 1;
      }
      while ((unint64_t)v497 < v182);
    }
    if (v406 < 5)
      goto LABEL_723;
    if (v170 >= (int)v408)
    {
LABEL_709:
      v170 -= v408;
      if (v343 <= v388)
      {
        if (v388 <= v407)
        {
          v183 = &v187[4 * v172];
          if (v342 >= 5)
          {
            v501 = &v580[2 * (int)v186];
            *(_QWORD *)v501 = v183;
            *((_QWORD *)v501 + 1) = v405;
            *((_QWORD *)v501 + 2) = v182;
            *((_DWORD *)v501 + 6) = v177;
            *((_DWORD *)v501 + 7) = v180;
            *((_QWORD *)v501 + 4) = v187;
            *((_QWORD *)v501 + 5) = v182;
            *((_QWORD *)v501 + 6) = v188;
            v179 = (v186 + 2);
            *((_DWORD *)v501 + 14) = v325;
            *((_DWORD *)v501 + 15) = v180;
            goto LABEL_746;
          }
          v181 = &v189[v343];
          v179 = v186;
          if (v387 < 5)
            continue;
          v505 = &v580[2 * (int)v186];
          *(_QWORD *)v505 = v183;
          *((_QWORD *)v505 + 1) = v405;
          *((_QWORD *)v505 + 2) = v182;
          v179 = (v186 + 1);
LABEL_749:
          *((_DWORD *)v505 + 6) = v177;
          *((_DWORD *)v505 + 7) = v180;
LABEL_750:
          v181 = (int *)(v188 - 4 * v388);
          v182 = v188;
LABEL_751:
          v183 = v187;
          v177 = v325;
          continue;
        }
        if (v343 > v407)
        {
          v499 = &v580[2 * (int)v186];
          *(_QWORD *)v499 = v187;
          *((_QWORD *)v499 + 1) = v182;
          *((_QWORD *)v499 + 2) = v188;
          *((_DWORD *)v499 + 6) = v325;
          *((_DWORD *)v499 + 7) = v180;
          *((_QWORD *)v499 + 4) = v187;
          *((_QWORD *)v499 + 5) = v189;
          *((_QWORD *)v499 + 6) = v405;
          goto LABEL_716;
        }
        v506 = &v580[2 * (int)v186];
        *(_QWORD *)v506 = v187;
        *((_QWORD *)v506 + 1) = v182;
        *((_QWORD *)v506 + 2) = v188;
        *((_DWORD *)v506 + 6) = v325;
        *((_DWORD *)v506 + 7) = v180;
        v183 = &v187[4 * v172];
        v181 = &v189[v343];
        v179 = (int)v186 + 1;
        if (v342 >= 5)
        {
          v507 = &v580[2 * (int)v186 + 2];
          *(_QWORD *)v507 = v183;
          *((_QWORD *)v507 + 1) = v405;
          *((_QWORD *)v507 + 2) = v182;
          v179 = (v186 + 2);
          goto LABEL_745;
        }
      }
      else
      {
        if (v343 <= v407)
        {
          v183 = &v187[4 * v172];
          if (v387 >= 5)
          {
            v500 = &v580[2 * (int)v186];
            *(_QWORD *)v500 = v183;
            *((_QWORD *)v500 + 1) = v405;
            *((_QWORD *)v500 + 2) = v182;
            *((_DWORD *)v500 + 6) = v177;
            *((_DWORD *)v500 + 7) = v180;
            *((_QWORD *)v500 + 4) = v187;
            *((_QWORD *)v500 + 5) = v189;
            *((_QWORD *)v500 + 6) = v405;
            v179 = (v186 + 2);
            *((_DWORD *)v500 + 14) = v325;
            *((_DWORD *)v500 + 15) = v180;
            goto LABEL_750;
          }
          v181 = &v189[v343];
          v179 = v186;
          if (v342 < 5)
            continue;
          v507 = &v580[2 * (int)v186];
          *(_QWORD *)v507 = v183;
          *((_QWORD *)v507 + 1) = v405;
          *((_QWORD *)v507 + 2) = v182;
          v179 = (v186 + 1);
LABEL_745:
          *((_DWORD *)v507 + 6) = v177;
          *((_DWORD *)v507 + 7) = v180;
LABEL_746:
          v181 = v189;
          v182 = (unint64_t)v405;
          goto LABEL_751;
        }
        if (v388 > v407)
        {
          v499 = &v580[2 * (int)v186];
          *(_QWORD *)v499 = v187;
          *((_QWORD *)v499 + 1) = v189;
          *((_QWORD *)v499 + 2) = v405;
          *((_DWORD *)v499 + 6) = v325;
          *((_DWORD *)v499 + 7) = v180;
          *((_QWORD *)v499 + 4) = v187;
          *((_QWORD *)v499 + 5) = v182;
          *((_QWORD *)v499 + 6) = v188;
LABEL_716:
          v179 = (v186 + 2);
          *((_DWORD *)v499 + 14) = v325;
          *((_DWORD *)v499 + 15) = v180;
          v183 = &v187[4 * v172];
          v181 = &v189[v343];
          continue;
        }
        v504 = &v580[2 * (int)v186];
        *(_QWORD *)v504 = v187;
        *((_QWORD *)v504 + 1) = v189;
        *((_QWORD *)v504 + 2) = v405;
        *((_DWORD *)v504 + 6) = v325;
        *((_DWORD *)v504 + 7) = v180;
        v183 = &v187[4 * v172];
        v181 = &v189[v343];
        v179 = (int)v186 + 1;
        if (v387 >= 5)
        {
          v505 = &v580[2 * (int)v186 + 2];
          *(_QWORD *)v505 = v183;
          *((_QWORD *)v505 + 1) = v405;
          *((_QWORD *)v505 + 2) = v182;
          v179 = (v186 + 2);
          goto LABEL_749;
        }
      }
    }
    else
    {
      if (v167)
      {
        v170 += v557;
        --v167;
        goto LABEL_709;
      }
      v178 += v408;
      if ((v180 & 0x80000000) == 0)
        DWORD2(v580[2 * v180 + 1]) = -1;
LABEL_723:
      if (v342 <= v387)
      {
        if (v342 >= 5)
        {
          v503 = &v580[2 * (int)v186];
          *(_QWORD *)v503 = v187;
          *((_QWORD *)v503 + 1) = v182;
          *((_QWORD *)v503 + 2) = v188;
          v179 = (v186 + 1);
          *((_DWORD *)v503 + 6) = v325;
          *((_DWORD *)v503 + 7) = v180;
          goto LABEL_746;
        }
        v181 = (int *)(v188 - 4 * v388);
        v182 = v188;
        v183 = v187;
        v177 = v325;
        v179 = v186;
        if (v387 <= 4)
        {
LABEL_731:
          if (!(_DWORD)v186)
            goto LABEL_759;
          goto LABEL_206;
        }
      }
      else
      {
        if (v387 >= 5)
        {
          v502 = &v580[2 * (int)v186];
          *(_QWORD *)v502 = v187;
          *((_QWORD *)v502 + 1) = v189;
          *((_QWORD *)v502 + 2) = v405;
          v179 = (v186 + 1);
          *((_DWORD *)v502 + 6) = v325;
          *((_DWORD *)v502 + 7) = v180;
          goto LABEL_750;
        }
        v181 = v189;
        v182 = (unint64_t)&v189[v343];
        v183 = v187;
        v177 = v325;
        v179 = v186;
        if (v342 <= 4)
          goto LABEL_731;
      }
    }
  }
  if (v170 >= (int)v191)
  {
LABEL_525:
    if (v191 >= 0x10000)
    {
      if (BYTE3(v191))
        v177 = lg_table[BYTE3(v191)] + 24;
      else
        v177 = lg_table[WORD1(v191)] + 16;
    }
    else if ((v191 & 0xFF00) != 0)
    {
      v177 = lg_table[v191 >> 8] + 8;
    }
    else
    {
      v177 = *(_DWORD *)((char *)lg_table + (v190 & 0x3FC));
    }
    v170 -= v191;
    v181 = v189;
    v182 = v188;
    v179 = v186;
    v183 = &v187[4 * v172];
    goto LABEL_209;
  }
  a2 = v571;
  if (v167)
  {
    v170 += v557;
    --v167;
    goto LABEL_525;
  }
  if ((v180 & 0x80000000) == 0)
    DWORD2(v580[2 * v180 + 1]) = -1;
  v178 += v191;
  if ((_DWORD)v186)
  {
LABEL_674:
    v167 = 0;
    goto LABEL_206;
  }
  v167 = 0;
  v29 = v572;
  a4 = v551;
  a1 = v566;
  v30 = v557 - 1;
  v508 = v574;
  v174 = v576;
  if (!v178)
    goto LABEL_760;
LABEL_754:
  v570 += v178;
  v166 = v568;
  if (v174 < v29)
  {
    LODWORD(v171) = 0;
    v168 = v564;
    goto LABEL_189;
  }
  v168 = v564;
  if (v570)
    goto LABEL_764;
LABEL_767:
  v509 = v547;
  if (v548 >= 1)
  {
    v510 = *(unsigned __int8 *)(a1 + v546);
    v511 = v557;
LABEL_769:
    v512 = 0;
    v513 = a1 - 1;
    v514 = v510;
    v515 = v509;
    while (v509 != v512)
    {
      v516 = v512;
      v510 = *(unsigned __int8 *)(v513 + v509);
      ++v512;
      --v513;
      v74 = v514 > v510;
      v514 = v510;
      if (v74)
      {
        v517 = v509 - v512;
        if (v509 - (int)v512 + 1 <= 1)
        {
          v509 = v509 - 1 - v512;
        }
        else
        {
          v509 += ~v516;
          while (1)
          {
            v518 = v510;
            v510 = *(unsigned __int8 *)(a1 + --v509);
            if (v518 < v510)
              break;
            if (v509 <= 0)
            {
              v509 = -1;
              break;
            }
          }
        }
        v519 = v515 - v509 - (int)v512 > 1 || v515 == (_DWORD)v512;
        v520 = ~v515 + v512;
        if (v519)
          v520 = v517;
        a2[v29[--v511]] = v520;
        if ((v509 & 0x80000000) == 0)
          goto LABEL_769;
        break;
      }
    }
  }
  a4[0xFFFF] = v548;
  v521 = a2 - 3;
  v522 = 254;
  do
  {
    v524 = v522;
    v525 = v522 + 1;
    LODWORD(v526) = *(_DWORD *)&a3[4 * v524 + 4] - 1;
    v527 = (_DWORD)v524 << 8;
    LODWORD(v528) = 255;
    do
    {
      v529 = v526;
      v526 = 4 * (int)(v524 | ((_DWORD)v528 << 8));
      v530 = *(_DWORD *)((char *)a4 + v526);
      *(_DWORD *)((char *)a4 + v526) = v529;
      LODWORD(v526) = v529 - v530;
      v531 = (int)a4[(int)(v528 | v527)];
      if ((int)v531 <= v30)
      {
        v532 = v30;
        v526 = (int)v526;
        v533 = v30 - v531;
        v534 = v533 + 1;
        if (v533 + 1 < 0x20)
          goto LABEL_804;
        v535 = (int)v526;
        v536 = v30;
        v537 = &a2[v535 - v533] > &a2[v535] || &a2[v30 - v533] > &a2[v30];
        v538 = v533 >> 62;
        if (v537 || v538 != 0)
          goto LABEL_804;
        if ((unint64_t)(v536 * 4 - v535 * 4) < 0x20)
          goto LABEL_804;
        v526 = (int)v526 - (v534 & 0xFFFFFFFFFFFFFFF8);
        v532 = v30 - (v534 & 0xFFFFFFFFFFFFFFF8);
        v540 = &v521[v536];
        v541 = &v521[v535];
        v542 = v534 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v543 = *(_OWORD *)v540;
          *((_OWORD *)v541 - 1) = *((_OWORD *)v540 - 1);
          *(_OWORD *)v541 = v543;
          v540 -= 8;
          v541 -= 8;
          v542 -= 8;
        }
        while (v542);
        if (v534 != (v534 & 0xFFFFFFFFFFFFFFF8))
        {
LABEL_804:
          v544 = v532;
          do
          {
            a2[v526--] = a2[v544];
            LODWORD(v532) = v544 - 1;
            v74 = v544-- <= v531;
          }
          while (!v74);
        }
        v30 = v532;
      }
      v528 = (v528 - 1);
    }
    while (v524 < v528);
    v523 = (int)(v527 | v524);
    a4[v527 | v525] = v526 - a4[v523] + 1;
    a4[v523] = v526;
    v522 = v524 - 1;
  }
  while (v524);
  return v557;
}

uint64_t divbwt(_BYTE *a1, _BYTE *a2, int *a3, unsigned int a4, _BYTE *a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v10;
  int *v13;
  char *v14;
  int *v15;
  int *v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  int *v29;
  unint64_t v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int *v41;
  int *v42;
  int *v43;
  int v44;
  int v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  unsigned int v53;
  int v54;
  int v55;
  unsigned int *v56;
  int *v57;
  unsigned int *v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  BOOL v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  int *v66;
  unsigned int v67;
  int v68;
  int *v69;
  int *v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  int *v80;
  unint64_t v81;
  _BYTE *v82;
  int v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  int8x16_t *v91;
  int8x16x4_t *v92;
  unint64_t v93;
  uint64_t v94;
  int8x16x2_t *v95;
  _BYTE *v96;
  unint64_t v97;
  _QWORD *v98;
  unint64_t v99;
  int8x16_t *v100;
  int8x16x4_t *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  int8x16x2_t *v105;
  _QWORD *v106;
  _BYTE *v107;
  int *v108;
  int v109;
  int8x16x2_t v112;
  int8x16x2_t v113;
  int8x16x4_t v114;
  int8x16x4_t v115;

  v6 = 0xFFFFFFFFLL;
  if (a1 && a2 && (a4 & 0x80000000) == 0)
  {
    v10 = a4 - 1;
    if (a4 <= 1)
    {
      if (a4 != 1)
        return 0;
      *a2 = *a1;
      return 1;
    }
    v13 = a3;
    if (!a3)
      v13 = (int *)malloc_type_malloc(4 * (a4 + 1), 0x100004052888210uLL);
    v14 = (char *)malloc_type_malloc(0x400uLL, 0x100004052888210uLL);
    v15 = (int *)malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
    v16 = v15;
    v6 = 4294967294;
    if (v13 && v14 && v15)
    {
      v17 = sort_typeBstar((uint64_t)a1, v13, v14, v15, a4);
      if (a5 && a6)
      {
        v18 = (a4 >> 3) | (a4 >> 4) | (((a4 >> 3) | (a4 >> 4)) >> 2);
        v19 = v18 | (v18 >> 4) | ((v18 | (v18 >> 4)) >> 8);
        v20 = (v19 >> 17) | (v19 >> 1);
        v21 = v20 + 1;
        v22 = v10 / (v20 + 1);
        *a5 = v22;
        if (v17 >= 1)
        {
          v23 = 254;
          while (1)
          {
            v24 = v23;
            v25 = v23 + 1;
            v26 = (_DWORD)v23 << 8;
            v27 = (unint64_t)&v13[v16[v26 | v25]];
            v28 = *(int *)&v14[4 * v24 + 4];
            if (v27 <= (unint64_t)&v13[v28 - 1])
              break;
LABEL_17:
            v23 = v24 - 1;
            if (!v24)
              goto LABEL_57;
          }
          v29 = 0;
          v30 = 4 * v28 - 4;
          v31 = -1;
          while (1)
          {
            v32 = *(int *)((char *)v13 + v30);
            v33 = v32 - 1;
            if ((int)v32 < 1)
            {
              if (v32)
                *(int *)((char *)v13 + v30) = ~v32;
              goto LABEL_22;
            }
            if ((v32 & v20) != 0)
            {
              v34 = a1[v33];
              *(int *)((char *)v13 + v30) = ~v34;
              v35 = v32 - 2;
              if (v32 < 2)
                goto LABEL_34;
            }
            else
            {
              *(_DWORD *)(a6 + 4 * (int)(v32 / v21 - 1)) = v30 >> 2;
              v34 = a1[v33];
              *(int *)((char *)v13 + v30) = ~v34;
              v35 = v32 - 2;
              if (v32 < 2)
              {
LABEL_34:
                v36 = 0;
                if (v31 != v34)
                  goto LABEL_35;
                goto LABEL_21;
              }
            }
            if (a1[v35] > v34)
              v36 = -v32;
            else
              v36 = v32 - 1;
            if (v31 != v34)
            {
LABEL_35:
              if ((v31 & 0x80000000) == 0)
                v16[v31 | v26] = (unint64_t)((char *)v29 - (char *)v13) >> 2;
              v29 = &v13[v16[v26 | v34]];
              v31 = v34;
            }
LABEL_21:
            *v29-- = v36;
LABEL_22:
            v30 -= 4;
            if (v27 > (unint64_t)v13 + v30)
              goto LABEL_17;
          }
        }
LABEL_57:
        v49 = a1[v10];
        v50 = *(int *)&v14[4 * a1[v10]];
        v51 = &v13[v50];
        v52 = a4 - 2;
        v53 = a1[v52];
        v54 = a4 - 1;
        if (v53 < v49)
        {
          if ((v20 & v10) == 0)
          {
            *(_DWORD *)(a6 + 4 * (int)(v22 - 1)) = v50;
            v53 = a1[v52];
          }
          v54 = ~v53;
        }
        v55 = 0;
        *v51 = v54;
        v56 = (unsigned int *)(v51 + 1);
        v57 = v13;
        v58 = (unsigned int *)v13;
        while (1)
        {
          v60 = *v58;
          v59 = *v58 - 1;
          if ((int)*v58 < 1)
          {
            if (v60)
              *v58 = ~v60;
            else
              v57 = (int *)v58;
            goto LABEL_64;
          }
          if ((v60 & v20) != 0)
          {
            v61 = a1[v59];
            *v58 = v61;
            if (v49 == (_DWORD)v61)
              goto LABEL_68;
          }
          else
          {
            *(_DWORD *)(a6 + 4 * (int)(v60 / v21 - 1)) = v55;
            v61 = a1[v59];
            *v58 = v61;
            if (v49 == (_DWORD)v61)
            {
LABEL_68:
              v62 = v60 >= 2;
              v63 = v60 - 2;
              if (v62)
                goto LABEL_76;
              goto LABEL_63;
            }
          }
          *(_DWORD *)&v14[4 * v49] = (unint64_t)((char *)v56 - (char *)v13) >> 2;
          v56 = (unsigned int *)&v13[*(int *)&v14[4 * v61]];
          v49 = v61;
          v62 = v60 >= 2;
          v63 = v60 - 2;
          if (v62)
          {
LABEL_76:
            v64 = a1[v63];
            if (v64 < v61)
            {
              if ((v59 & v20) == 0)
              {
                *(_DWORD *)(a6 + 4 * (int)(v59 / v21 - 1)) = (unint64_t)((char *)v56 - (char *)v13) >> 2;
                v64 = a1[v63];
              }
              v59 = ~v64;
            }
          }
LABEL_63:
          *v56++ = v59;
LABEL_64:
          ++v58;
          ++v55;
          if (v58 >= (unsigned int *)&v13[a4])
            goto LABEL_99;
        }
      }
      if (v17 > 0)
      {
        v37 = 254;
        while (1)
        {
          v38 = v37;
          v39 = v37 + 1;
          v40 = (_DWORD)v37 << 8;
          v41 = &v13[v16[v40 | v39]];
          v42 = &v13[*(int *)&v14[4 * v38 + 4] - 1];
          if (v41 <= v42)
            break;
LABEL_39:
          v37 = v38 - 1;
          if (!v38)
            goto LABEL_80;
        }
        v43 = 0;
        v44 = -1;
        while (1)
        {
          v45 = *v42;
          v46 = *v42 - 1;
          if (*v42 < 1)
          {
            if (v45)
              *v42 = ~v45;
            goto LABEL_44;
          }
          v47 = a1[v46];
          *v42 = ~v47;
          if (v45 == 1)
          {
            v48 = 0;
            if (v44 != v47)
              goto LABEL_55;
          }
          else
          {
            if (a1[v45 - 2] > v47)
              v48 = -v45;
            else
              v48 = v46;
            if (v44 != v47)
            {
LABEL_55:
              if ((v44 & 0x80000000) == 0)
                v16[v44 | v40] = (unint64_t)((char *)v43 - (char *)v13) >> 2;
              v43 = &v13[v16[v40 | v47]];
              v44 = v47;
            }
          }
          *v43-- = v48;
LABEL_44:
          if (v41 > --v42)
            goto LABEL_39;
        }
      }
LABEL_80:
      v65 = a1[v10];
      v66 = &v13[*(int *)&v14[4 * v65]];
      v67 = a1[a4 - 2];
      if (v67 < v65)
        v68 = ~v67;
      else
        v68 = v10;
      *v66 = v68;
      v69 = v66 + 1;
      v57 = v13;
      v70 = v13;
      while (1)
      {
        v71 = *v70;
        v72 = *v70 - 1;
        if (*v70 < 1)
        {
          if (v71)
            *v70 = ~v71;
          else
            v57 = v70;
          goto LABEL_86;
        }
        v73 = a1[v72];
        *v70 = v73;
        if (v71 == 1)
        {
          v74 = 0;
          if ((_DWORD)v65 == v73)
            goto LABEL_85;
        }
        else
        {
          v75 = a1[v71 - 2];
          if (v75 < v73)
            v74 = ~v75;
          else
            v74 = v72;
          if ((_DWORD)v65 == v73)
            goto LABEL_85;
        }
        *(_DWORD *)&v14[4 * v65] = (unint64_t)((char *)v69 - (char *)v13) >> 2;
        v69 = &v13[*(int *)&v14[4 * v73]];
        LODWORD(v65) = v73;
LABEL_85:
        *v69++ = v74;
LABEL_86:
        if (++v70 >= &v13[a4])
        {
LABEL_99:
          v76 = (char *)v57 - (char *)v13;
          v77 = (unint64_t)((char *)v57 - (char *)v13) >> 2;
          *a2 = a1[v10];
          if ((int)v77 < 1)
          {
            v84 = 0;
          }
          else
          {
            v78 = (v76 >> 2);
            if (v78 < 8 || a2 + 1 < (_BYTE *)&v13[v78] && v13 < (int *)&a2[v78 + 1])
            {
              v79 = 0;
              goto LABEL_104;
            }
            if (v78 >= 0x20)
            {
              v90 = (v76 >> 2) & 0x1F;
              v79 = v78 - v90;
              v91 = (int8x16_t *)(a2 + 17);
              v92 = (int8x16x4_t *)(v13 + 16);
              v93 = v78 - v90;
              do
              {
                v114 = *v92;
                v91[-1] = vqtbl4q_s8(v92[-1], (int8x16_t)xmmword_18823D6F0);
                *v91 = vqtbl4q_s8(v114, (int8x16_t)xmmword_18823D6F0);
                v91 += 2;
                v92 += 2;
                v93 -= 32;
              }
              while (v93);
              v84 = v77;
              if (v90)
              {
                if (v90 < 8)
                  goto LABEL_104;
                goto LABEL_121;
              }
            }
            else
            {
              v79 = 0;
LABEL_121:
              v94 = (v76 >> 2) & 7;
              v95 = (int8x16x2_t *)&v13[v79];
              v96 = &a2[v79];
              v97 = v79 + v94;
              v79 = v78 - v94;
              v98 = v96 + 1;
              v99 = v97 - v78;
              do
              {
                v112 = *v95++;
                *v98++ = vqtbl2q_s8(v112, (int8x16_t)xmmword_18823D700).u64[0];
                v99 += 8;
              }
              while (v99);
              v84 = v77;
              if (v94)
              {
LABEL_104:
                v80 = &v13[v79];
                v81 = v79 - v78;
                v82 = &a2[v79 + 1];
                do
                {
                  v83 = *v80++;
                  *v82++ = v83;
                  v62 = __CFADD__(v81++, 1);
                }
                while (!v62);
                v84 = v77;
              }
            }
          }
          if ((int)(v84 + 1) >= (int)a4)
            goto LABEL_136;
          v85 = v84;
          v86 = v84 + 1;
          v87 = a4 - v84 - 2;
          if (v87 >= 7
            && (&a2[v86] >= (_BYTE *)&v13[v84 + 2 + v87] || &v13[v84 + 1] >= (int *)&a2[v84 + 2 + v87]))
          {
            v88 = v87 + 1;
            if (v87 >= 0x1F)
            {
              v89 = v88 & 0x1FFFFFFE0;
              v100 = (int8x16_t *)&a2[v84 + 17];
              v101 = (int8x16x4_t *)&v13[v85 + 17];
              v102 = v88 & 0x1FFFFFFE0;
              do
              {
                v115 = *v101;
                v100[-1] = vqtbl4q_s8(v101[-1], (int8x16_t)xmmword_18823D6F0);
                *v100 = vqtbl4q_s8(v115, (int8x16_t)xmmword_18823D6F0);
                v100 += 2;
                v101 += 2;
                v102 -= 32;
              }
              while (v102);
              if (v88 == v89)
                goto LABEL_136;
              if ((v88 & 0x18) != 0)
                goto LABEL_129;
              v86 += v89;
            }
            else
            {
              v89 = 0;
LABEL_129:
              v86 += v88 & 0x1FFFFFFF8;
              v103 = v89 - (v88 & 0x1FFFFFFF8);
              v104 = v89 + v85;
              v105 = (int8x16x2_t *)&v13[v104 + 1];
              v106 = &a2[v104 + 1];
              do
              {
                v113 = *v105++;
                *v106++ = vqtbl2q_s8(v113, (int8x16_t)xmmword_18823D700).u64[0];
                v103 += 8;
              }
              while (v103);
              if (v88 == (v88 & 0x1FFFFFFF8))
              {
LABEL_136:
                v6 = (v77 + 1);
                break;
              }
            }
          }
          v107 = &a2[v86];
          v108 = &v13[v86];
          do
          {
            v109 = *v108++;
            *v107++ = v109;
            LODWORD(v86) = v86 + 1;
          }
          while ((int)v86 < (int)a4);
          goto LABEL_136;
        }
      }
    }
    free(v16);
    free(v14);
    if (!a3)
      free(v13);
  }
  return v6;
}

uint64_t ZDICT_trainFromBuffer_fastCover(char *a1, size_t a2, uint64_t a3, int64x2_t *a4, unsigned int a5, uint64_t *a6)
{
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  size_t v11;
  BOOL v12;
  BOOL v14;
  BOOL v15;
  BOOL v16;
  BOOL v17;
  FILE **v18;
  unint64_t v19;
  FILE **v21;
  FILE **v22;
  int v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  int v30;
  FILE **v31;
  FILE **v32;
  void *v33;
  __int128 v34;
  size_t v35;
  uint64_t v36;
  FILE **v37;
  FILE **v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  void *v48[2];
  __int128 v49;
  __int128 v50;
  void *v51[2];
  __int128 v52;

  v7 = *((_DWORD *)a6 + 12);
  g_displayLevel = v7;
  a6[3] = 0x3FF0000000000000;
  if (*((_DWORD *)a6 + 2))
    v8 = *((_DWORD *)a6 + 2);
  else
    v8 = 20;
  *((_DWORD *)a6 + 2) = v8;
  if (*((_DWORD *)a6 + 8) <= 1u)
    v9 = 1;
  else
    v9 = *((_DWORD *)a6 + 8);
  *((_DWORD *)a6 + 8) = v9;
  v10 = HIDWORD(*a6);
  v11 = *a6;
  if (v10)
    v12 = (_DWORD)v11 == 0;
  else
    v12 = 1;
  if (v12
    || (v10 != 8 ? (v14 = v10 == 6) : (v14 = 1),
        v14 ? (v15 = v11 > a2) : (v15 = 1),
        v15
     || ((v8 - 32) >= 0xFFFFFFE1 ? (v16 = v10 > v11) : (v16 = 1),
         !v16 ? (v17 = v9 >= 0xB) : (v17 = 1),
         v17)))
  {
    if (v7 >= 1)
    {
      v18 = (FILE **)MEMORY[0x1E0C80C10];
      fwrite("FASTCOVER parameters incorrect\n", 0x1FuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      fflush(*v18);
    }
    return -42;
  }
  else if (a5)
  {
    if (a2 > 0xFF)
    {
      v40 = *a6;
      v39 = *(uint64_t *)((char *)a6 + 12);
      v26 = *((_DWORD *)a6 + 9);
      v27 = *(uint64_t *)((char *)a6 + 44);
      v28 = *((_DWORD *)a6 + 13);
      *(_OWORD *)v51 = 0u;
      v52 = 0u;
      v49 = 0u;
      v50 = 0u;
      *(_OWORD *)v48 = 0u;
      v29 = FASTCOVER_ctx_init((uint64_t *)v48, a3, a4, a5, v10, v8, FASTCOVER_defaultAccelParameters[v9], 1.0);
      if (v29 >= 0xFFFFFFFFFFFFFF89)
      {
        v19 = v29;
        if (g_displayLevel >= 1)
        {
          v38 = (FILE **)MEMORY[0x1E0C80C10];
          fwrite("Failed to initialize context\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
          fflush(*v38);
        }
      }
      else
      {
        v30 = g_displayLevel;
        if (g_displayLevel >= 1 && (double)(unint64_t)v51[0] / (double)a2 < 10.0)
        {
          v31 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/size(dictionary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend training on sources at least 10x, and preferably 100x the size of the dictionary! \n", a2, LODWORD(v51[0]), (double)(unint64_t)v51[0] / (double)a2);
          fflush(*v31);
          v30 = g_displayLevel;
        }
        if (v30 > 1)
        {
          v32 = (FILE **)MEMORY[0x1E0C80C10];
          fwrite("Building dictionary\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
          fflush(*v32);
        }
        v33 = malloc_type_calloc(1 << *((_DWORD *)a6 + 2), 2uLL, 0x1000040BDFB0063uLL);
        *(_QWORD *)&v34 = v40;
        *((_QWORD *)&v34 + 1) = v39;
        v41 = v34;
        v42 = 0x3FF0000000000000;
        v43 = v26;
        v44 = 0;
        v45 = v27;
        v46 = v28;
        v47 = 0;
        v35 = FASTCOVER_buildDictionary((uint64_t *)v48, (uint64_t)v51[1], (uint64_t)a1, a2, &v41, (uint64_t)v33);
        v19 = ZDICT_finalizeDictionary(a1, a2, (unsigned int *)&a1[v35], a2 - v35, a3, (uint64_t)a4, (unint64_t)v50 * DWORD2(v52) / 0x64, v36, v27, HIDWORD(v27), v28);
        if (v19 <= 0xFFFFFFFFFFFFFF88 && g_displayLevel >= 2)
        {
          v37 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "Constructed dictionary of size %u\n", v19);
          fflush(*v37);
        }
        free(v51[1]);
        v51[1] = 0;
        free(v48[1]);
        v48[1] = 0;
        free(v33);
      }
    }
    else
    {
      if (v7 >= 1)
      {
        v21 = (FILE **)MEMORY[0x1E0C80C10];
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "dictBufferCapacity must be at least %u\n", 256);
        fflush(*v21);
      }
      return -70;
    }
  }
  else
  {
    if (v7 >= 1)
    {
      v22 = (FILE **)MEMORY[0x1E0C80C10];
      fwrite("FASTCOVER must have at least one input file\n", 0x2CuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      fflush(*v22);
    }
    return -72;
  }
  return v19;
}

uint64_t FASTCOVER_ctx_init(uint64_t *a1, uint64_t a2, int64x2_t *a3, unsigned int a4, unsigned int a5, int a6, uint64_t a7, double a8)
{
  uint64_t *v10;
  uint64_t v12;
  unint64_t v13;
  int64x2_t *v14;
  int64x2_t v15;
  uint64_t v16;
  int64x2_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int64x2_t *v28;
  int64x2_t v29;
  uint64_t v30;
  int64x2_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  int64x2_t *v36;
  int64x2_t v37;
  uint64_t v38;
  int64x2_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  unint64_t v43;
  FILE **v45;
  uint64_t v46;
  FILE **v48;
  char v49;
  unsigned int v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  FILE **v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  uint64_t v62;
  unint64_t *v63;
  char v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  FILE **v71;
  FILE *v72;
  const char *v73;
  void *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;

  v10 = (uint64_t *)a3;
  if (a4)
  {
    if (a4 >= 4)
    {
      v12 = a4 & 0xFFFFFFFC;
      v14 = a3 + 1;
      v15 = 0uLL;
      v16 = v12;
      v17 = 0uLL;
      do
      {
        v15 = vaddq_s64(v14[-1], v15);
        v17 = vaddq_s64(*v14, v17);
        v14 += 2;
        v16 -= 4;
      }
      while (v16);
      v13 = vaddvq_s64(vaddq_s64(v17, v15));
      if (v12 == a4)
        goto LABEL_10;
    }
    else
    {
      v12 = 0;
      v13 = 0;
    }
    v18 = a4 - v12;
    v19 = &a3->i64[v12];
    do
    {
      v20 = *v19++;
      v13 += v20;
      --v18;
    }
    while (v18);
  }
  else
  {
    v13 = 0;
  }
LABEL_10:
  v21 = ((double)a4 * a8);
  if (a8 >= 1.0)
    v22 = 0;
  else
    v22 = ((double)a4 * a8);
  v23 = a4 - v22;
  if (a8 >= 1.0)
    v24 = a4;
  else
    v24 = v21;
  v25 = v13;
  v26 = v13;
  if (a8 >= 1.0)
    goto LABEL_35;
  if (!(_DWORD)v21)
  {
    v21 = 0;
    v25 = 0;
    goto LABEL_26;
  }
  if (v21 < 4)
  {
    v27 = 0;
    v25 = 0;
LABEL_24:
    v32 = v21 - v27;
    v33 = &a3->i64[v27];
    do
    {
      v34 = *v33++;
      v25 += v34;
      --v32;
    }
    while (v32);
    goto LABEL_26;
  }
  v27 = v21 & 0xFFFFFFFC;
  v28 = a3 + 1;
  v29 = 0uLL;
  v30 = v27;
  v31 = 0uLL;
  do
  {
    v29 = vaddq_s64(v28[-1], v29);
    v31 = vaddq_s64(*v28, v31);
    v28 += 2;
    v30 -= 4;
  }
  while (v30);
  v25 = vaddvq_s64(vaddq_s64(v31, v29));
  if (v27 != v21)
    goto LABEL_24;
LABEL_26:
  if (a4 == v22)
  {
    v26 = 0;
  }
  else
  {
    if (v23 >= 4)
    {
      v35 = v23 & 0xFFFFFFFC;
      v36 = (int64x2_t *)((char *)a3 + 8 * v21 + 16);
      v37 = 0uLL;
      v38 = v35;
      v39 = 0uLL;
      do
      {
        v37 = vaddq_s64(v36[-1], v37);
        v39 = vaddq_s64(*v36, v39);
        v36 += 2;
        v38 -= 4;
      }
      while (v38);
      v26 = vaddvq_s64(vaddq_s64(v39, v37));
      if (v35 == v23)
        goto LABEL_35;
    }
    else
    {
      v35 = 0;
      v26 = 0;
    }
    v40 = v23 - v35;
    v41 = &a3->i64[v21 + v35];
    do
    {
      v42 = *v41++;
      v26 += v42;
      --v40;
    }
    while (v40);
  }
LABEL_35:
  if (a5 <= 8)
    v43 = 8;
  else
    v43 = a5;
  if (v13 < v43 || v13 >= 0xFFFFFFFF)
  {
    if (g_displayLevel >= 1)
    {
      v45 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "Total samples size is too large (%u MB), maximum size is %u MB\n");
LABEL_51:
      fflush(*v45);
    }
    return -72;
  }
  if (v24 <= 4)
  {
    if (g_displayLevel >= 1)
    {
      v45 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "Total number of training samples is %u and is invalid\n");
      goto LABEL_51;
    }
    return -72;
  }
  if (a4 == v22)
  {
    if (g_displayLevel >= 1)
    {
      v45 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "Total number of testing samples is %u and is invalid.\n");
      goto LABEL_51;
    }
    return -72;
  }
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  if (g_displayLevel >= 2)
  {
    v48 = (FILE **)MEMORY[0x1E0C80C10];
    v76 = a2;
    v77 = a6;
    v75 = a7;
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "Training on %u samples of total size %u\n", v24, v25);
    fflush(*v48);
    a7 = v75;
    a2 = v76;
    a6 = v77;
    if (g_displayLevel >= 2)
    {
      fprintf(*v48, "Testing on %u samples of total size %u\n", v23, v26);
      fflush(*v48);
      a7 = v75;
      a2 = v76;
      a6 = v77;
    }
  }
  *a1 = a2;
  a1[2] = (uint64_t)v10;
  a1[3] = a4;
  a1[4] = v24;
  a1[5] = v23;
  a1[6] = v25 - v43 + 1;
  *((_DWORD *)a1 + 16) = a5;
  *((_DWORD *)a1 + 17) = a6;
  v49 = a6;
  v50 = a4 + 1;
  a1[9] = a7;
  v51 = malloc_type_calloc(a4 + 1, 8uLL, 0x100004000313F17uLL);
  a1[1] = (uint64_t)v51;
  if (!v51)
  {
    if (g_displayLevel < 1)
    {
LABEL_84:
      v74 = (void *)a1[7];
LABEL_85:
      free(v74);
      a1[7] = 0;
      free((void *)a1[1]);
      a1[1] = 0;
      return -64;
    }
    v71 = (FILE **)MEMORY[0x1E0C80C10];
    v72 = (FILE *)*MEMORY[0x1E0C80C10];
    v73 = "Failed to allocate scratch buffers \n";
LABEL_83:
    fwrite(v73, 0x24uLL, 1uLL, v72);
    fflush(*v71);
    goto LABEL_84;
  }
  *v51 = 0;
  if (a4)
  {
    v52 = 0;
    if (v50 <= 2)
      v53 = 2;
    else
      v53 = v50;
    v54 = v51 + 1;
    v55 = v53 - 1;
    do
    {
      v56 = *v10++;
      v52 += v56;
      *v54++ = v52;
      --v55;
    }
    while (v55);
  }
  v57 = (char *)malloc_type_calloc(1 << v49, 4uLL, 0x100004052888210uLL);
  a1[7] = (uint64_t)v57;
  if (!v57)
  {
    if (g_displayLevel < 1)
    {
      v74 = 0;
      goto LABEL_85;
    }
    v71 = (FILE **)MEMORY[0x1E0C80C10];
    v72 = (FILE *)*MEMORY[0x1E0C80C10];
    v73 = "Failed to allocate frequency table \n";
    goto LABEL_83;
  }
  if (g_displayLevel >= 2)
  {
    v58 = (FILE **)MEMORY[0x1E0C80C10];
    fwrite("Computing frequencies\n", 0x16uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    fflush(*v58);
    v57 = (char *)a1[7];
  }
  v59 = a1[4];
  if (!v59)
    return 0;
  v60 = 0;
  v61 = *((_DWORD *)a1 + 16);
  if (v61 <= 8)
    v62 = 8;
  else
    v62 = v61;
  v63 = (unint64_t *)a1[1];
  v64 = 64 - *((_DWORD *)a1 + 17);
  v65 = 0xCF1BBCDCBF9B0000;
  if (v61 != 6)
    v65 = 0xCF1BBCDCB7A56463;
  v66 = *((unsigned int *)a1 + 19) + 1;
  v67 = *v63;
  do
  {
    v68 = v63[++v60];
    if (v67 + v62 <= v68)
    {
      v69 = *a1;
      do
      {
        v70 = 4 * ((*(_QWORD *)(v69 + v67) * v65) >> v64);
        ++*(_DWORD *)&v57[v70];
        v67 += v66;
      }
      while (v62 + v67 <= v68);
    }
    v46 = 0;
    v67 = v68;
  }
  while (v60 != v59);
  return v46;
}

size_t FASTCOVER_buildDictionary(uint64_t *a1, uint64_t a2, uint64_t a3, size_t a4, _DWORD *a5, uint64_t a6)
{
  size_t v8;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  int *v16;
  FILE **v17;
  FILE *v18;
  unint64_t v19;
  unint64_t v20;
  FILE **v21;
  FILE *v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  char v32;
  unint64_t v33;
  int v34;
  uint64_t v35;
  BOOL v36;
  unint64_t v37;
  unint64_t v38;
  __int16 v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  char v46;
  unint64_t v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unint64_t v51;
  size_t v52;
  size_t v53;
  size_t v54;
  FILE **v55;
  size_t v57;

  v8 = a4;
  v11 = *((_DWORD *)a1 + 12);
  v12 = 10 * *a5;
  if (*a5 > a4)
    v13 = 1;
  else
    v13 = a4 / *a5;
  v14 = v11 / v13;
  if (v11 / v13 >= v12)
  {
    v15 = v13;
    v16 = (int *)&unk_1EDF03000;
    if (g_displayLevel < 2)
      goto LABEL_6;
LABEL_12:
    v17 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "Breaking content into %u epochs of size %u\n", v15, v14);
    v18 = *v17;
    v16 = (_DWORD *)&unk_1EDF03000;
    fflush(v18);
    if (!v8)
      goto LABEL_62;
    goto LABEL_13;
  }
  if (v12 >= v11)
    v14 = *((_DWORD *)a1 + 12);
  else
    v14 = 10 * *a5;
  v15 = v11 / v14;
  v16 = (int *)&unk_1EDF03000;
  if (g_displayLevel >= 2)
    goto LABEL_12;
LABEL_6:
  if (a4)
  {
LABEL_13:
    v19 = 0;
    v20 = 0;
    v57 = v8;
    while (1)
    {
      v23 = v14 * v19;
      v24 = v14 * (_DWORD)v19 + v14;
      v25 = a5[1];
      v26 = *((_DWORD *)a1 + 17);
      if (v14 * v19 < v24)
        break;
      v29 = 0;
      v28 = 0;
      v27 = 0;
LABEL_35:
      if (v23 < v24)
      {
        if (v25 == 6)
          v40 = 0xCF1BBCDCBF9B0000;
        else
          v40 = 0xCF1BBCDCB7A56463;
        v41 = v24 - v23;
        v42 = (uint64_t *)(*a1 + v23);
        do
        {
          v43 = *v42;
          v42 = (uint64_t *)((char *)v42 + 1);
          --*(_WORD *)(a6 + 2 * ((v43 * v40) >> (64 - v26)));
          --v41;
        }
        while (v41);
      }
      v44 = v28 - v27;
      if (v28 != v27)
      {
        v45 = *a1;
        v46 = 64 - v26;
        v47 = v25 == 6 ? 0xCF1BBCDCBF9B0000 : 0xCF1BBCDCB7A56463;
        v48 = v27;
        if (v44 < 2)
          goto LABEL_67;
        v48 = v27;
        if (v28 - 1 < v27)
          goto LABEL_67;
        v48 = v27 + (v44 & 0xFFFFFFFE);
        v49 = v27;
        v50 = v44 & 0xFFFFFFFE;
        do
        {
          v51 = (*(_QWORD *)(v45 + v49 + 1) * v47) >> v46;
          *(_DWORD *)(a2 + 4 * ((*(_QWORD *)(v45 + v49) * v47) >> v46)) = 0;
          *(_DWORD *)(a2 + 4 * v51) = 0;
          v49 += 2;
          v50 -= 2;
        }
        while (v50);
        if (v44 != (v44 & 0xFFFFFFFE))
        {
LABEL_67:
          do
            *(_DWORD *)(a2 + 4 * ((*(_QWORD *)(v45 + v48++) * v47) >> v46)) = 0;
          while (v28 != v48);
        }
      }
      if (v29)
      {
        v52 = a5[1];
        v53 = v28 + ~v27 + v52;
        if (v8 >= v53)
          v54 = v53;
        else
          v54 = v8;
        if (v54 < v52)
          goto LABEL_62;
        v8 -= v54;
        memcpy((void *)(a3 + v8), (const void *)(*a1 + v27), v54);
        if (v16[250] >= 2 && (clock() - g_time > 0x249F0 || v16[250] >= 4))
        {
          g_time = clock();
          v21 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%u%%       ", 100 * (v57 - v8) / v57);
          v22 = *v21;
          v16 = (int *)&unk_1EDF03000;
          fflush(v22);
        }
        v20 = 0;
        v19 = (v19 + 1) % v15;
        if (!v8)
          goto LABEL_62;
      }
      else
      {
        if (v20 > 8)
          goto LABEL_62;
        ++v20;
        v19 = (v19 + 1) % v15;
        if (!v8)
          goto LABEL_62;
      }
    }
    v27 = 0;
    v28 = 0;
    LODWORD(v29) = 0;
    v30 = 0;
    v31 = *a1;
    v32 = 64 - v26;
    if (v25 == 6)
      v33 = 0xCF1BBCDCBF9B0000;
    else
      v33 = 0xCF1BBCDCB7A56463;
    v34 = *a5 - v25 + 1;
    v35 = v14 * v19;
    while (1)
    {
      v37 = (*(_QWORD *)(v31 + v35) * v33) >> v32;
      if (*(_WORD *)(a6 + 2 * v37))
      {
        ++*(_WORD *)(a6 + 2 * v37);
        if (v34 + v23 == (_DWORD)v35)
          goto LABEL_32;
      }
      else
      {
        v30 += *(_DWORD *)(a2 + 4 * v37);
        *(_WORD *)(a6 + 2 * v37) = 1;
        if (v34 + v23 == (_DWORD)v35)
        {
LABEL_32:
          v38 = (*(_QWORD *)(v31 + v23) * v33) >> v32;
          v39 = *(_WORD *)(a6 + 2 * v38) - 1;
          *(_WORD *)(a6 + 2 * v38) = v39;
          if (!v39)
            v30 -= *(_DWORD *)(a2 + 4 * v38);
          ++v23;
        }
      }
      ++v35;
      v36 = v30 > v29;
      if (v30 <= v29)
        v29 = v29;
      else
        v29 = v30;
      if (v36)
      {
        v28 = v35;
        v27 = v23;
      }
      if (v24 == v35)
        goto LABEL_35;
    }
  }
LABEL_62:
  if (v16[250] >= 2)
  {
    v55 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%79s\r", "");
    fflush(*v55);
  }
  return v8;
}

uint64_t ZDICT_optimizeTrainFromBuffer_fastCover(void *a1, unint64_t a2, uint64_t a3, int64x2_t *a4, unsigned int a5, uint64_t a6)
{
  double v6;
  int v7;
  unsigned int v8;
  char v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  int v19;
  FILE **v20;
  FILE *v21;
  const char *v22;
  size_t v23;
  uint64_t v24;
  FILE **v26;
  FILE **v28;
  uint64_t v31;
  _QWORD *advanced;
  int v33;
  int v34;
  FILE **v35;
  FILE **v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  char v40;
  __int128 v41;
  FILE **v42;
  unint64_t v43;
  FILE **v44;
  unsigned int v45;
  _QWORD *v46;
  FILE **v47;
  uint64_t v48;
  int v49;
  FILE **v50;
  FILE **v51;
  FILE **v52;
  FILE **v53;
  unsigned int v54;
  void *__dst;
  uint64_t v56;
  unsigned int v57;
  int v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  uint64_t v65;
  int v66;
  void *v67[2];
  __int128 v68;
  __int128 v69;
  void *v70[2];
  __int128 v71;
  pthread_mutex_t v72;
  pthread_cond_t v73;
  void *v74[2];
  _OWORD v75[4];
  uint64_t v76;
  unsigned int v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  if (*(double *)(a6 + 24) <= 0.0)
    v6 = 0.75;
  else
    v6 = *(double *)(a6 + 24);
  v8 = *(_DWORD *)a6;
  v7 = *(_DWORD *)(a6 + 4);
  v9 = v7 == 0;
  if (v7)
    v10 = *(_DWORD *)(a6 + 4);
  else
    v10 = 6;
  if (v7)
    v11 = *(_DWORD *)(a6 + 4);
  else
    v11 = 8;
  if (*(_DWORD *)(a6 + 12))
    v12 = *(_DWORD *)(a6 + 12);
  else
    v12 = 40;
  if (v8)
    v13 = *(_DWORD *)a6;
  else
    v13 = 50;
  if (v8)
    v14 = *(_DWORD *)a6;
  else
    v14 = 2000;
  if (v8)
    v15 = 0;
  else
    v15 = 1950;
  if (v15 / v12 <= 1)
    v16 = 1;
  else
    v16 = v15 / v12;
  if (*(_DWORD *)(a6 + 8))
    v17 = *(_DWORD *)(a6 + 8);
  else
    v17 = 20;
  v18 = *(_DWORD *)(a6 + 32);
  if (v18 <= 1)
    v18 = 1;
  v19 = *(_DWORD *)(a6 + 48);
  if (v6 <= 0.0 || v6 > 1.0)
  {
    if (v19 >= 1)
    {
      v20 = (FILE **)MEMORY[0x1E0C80C10];
      v21 = (FILE *)*MEMORY[0x1E0C80C10];
      v22 = "Incorrect splitPoint\n";
      v23 = 21;
      goto LABEL_37;
    }
    return -42;
  }
  if (v18 >= 0xB)
  {
    if (v19 >= 1)
    {
      v20 = (FILE **)MEMORY[0x1E0C80C10];
      v21 = (FILE *)*MEMORY[0x1E0C80C10];
      v22 = "Incorrect accel\n";
      v23 = 16;
LABEL_37:
      fwrite(v22, v23, 1uLL, v21);
      fflush(*v20);
      return -42;
    }
    return -42;
  }
  if (v13 < v11 || v14 < v13)
  {
    if (v19 >= 1)
    {
      v20 = (FILE **)MEMORY[0x1E0C80C10];
      v21 = (FILE *)*MEMORY[0x1E0C80C10];
      v22 = "Incorrect k\n";
      v23 = 12;
      goto LABEL_37;
    }
    return -42;
  }
  if (a5)
  {
    if (a2 <= 0xFF)
    {
      if (v19 >= 1)
      {
        v26 = (FILE **)MEMORY[0x1E0C80C10];
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "dictBufferCapacity must be at least %u\n", 256);
        fflush(*v26);
      }
      return -70;
    }
    v62 = v18;
    v63 = v11;
    v61 = v17;
    v31 = *(unsigned int *)(a6 + 16);
    __dst = a1;
    v57 = v13;
    if (v31 < 2)
    {
      advanced = 0;
    }
    else
    {
      advanced = POOL_create_advanced(v31, 1, &ZSTD_defaultCMem);
      if (!advanced)
        return -64;
    }
    v65 = (uint64_t)advanced;
    memset(v75, 0, sizeof(v75));
    *(_OWORD *)v74 = 0u;
    memset(&v73, 0, sizeof(v73));
    v33 = (v15 / v16 + 1) << v9;
    memset(&v72, 0, sizeof(v72));
    pthread_mutex_init(&v72, 0);
    pthread_cond_init(&v73, 0);
    v74[0] = 0;
    v74[1] = 0;
    memset(v75, 0, 56);
    *((_QWORD *)&v75[3] + 1) = -1;
    v66 = *(_DWORD *)(a6 + 16);
    *(_OWORD *)v67 = *(_OWORD *)(a6 + 40);
    v76 = *(uint64_t *)((char *)v67 + 4);
    v56 = FASTCOVER_defaultAccelParameters[v62];
    v77 = HIDWORD(v67[1]);
    v34 = v19 - 1;
    if (!v19)
      v34 = 0;
    g_displayLevel = v34;
    if (v19 >= 2)
    {
      v35 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "Trying %u different sets of parameters\n", v33);
      fflush(*v35);
    }
    v54 = v33;
    if (v10 <= v63)
    {
      v40 = 1;
      v41 = 0uLL;
      v64 = 1;
      while (2)
      {
        *(_OWORD *)v70 = v41;
        v71 = v41;
        v68 = v41;
        v69 = v41;
        *(_OWORD *)v67 = v41;
        if (v19 >= 3)
        {
          v42 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "d=%u\n", v10);
          fflush(*v42);
        }
        v43 = FASTCOVER_ctx_init((uint64_t *)v67, a3, a4, a5, v10, v61, v56, v6);
        if (v43 >= 0xFFFFFFFFFFFFFF89)
        {
          v24 = v43;
          if (v19 >= 1)
          {
            v53 = (FILE **)MEMORY[0x1E0C80C10];
            fwrite("Failed to initialize context\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
            fflush(*v53);
          }
          pthread_mutex_lock(&v72);
          while (v74[0])
            pthread_cond_wait(&v73, &v72);
          pthread_mutex_unlock(&v72);
          if (v74[1])
            free(v74[1]);
          pthread_mutex_destroy(&v72);
          pthread_cond_destroy(&v73);
          goto LABEL_109;
        }
        if ((v40 & 1) != 0 && v19 >= 1 && (double)(unint64_t)v70[0] / (double)a2 < 10.0)
        {
          v44 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/size(dictionary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend training on sources at least 10x, and preferably 100x the size of the dictionary! \n", a2, LODWORD(v70[0]), (double)(unint64_t)v70[0] / (double)a2);
          fflush(*v44);
        }
        v45 = v57;
        do
        {
          while (1)
          {
            v46 = malloc_type_malloc(0x48uLL, 0x1060040023D7745uLL);
            if (v19 >= 3)
            {
              v47 = (FILE **)MEMORY[0x1E0C80C10];
              fprintf((FILE *)*MEMORY[0x1E0C80C10], "k=%u\n", v45);
              fflush(*v47);
            }
            if (!v46)
            {
              if (v19 >= 1)
              {
                v52 = (FILE **)MEMORY[0x1E0C80C10];
                fwrite("Failed to allocate parameters\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
                fflush(*v52);
              }
              pthread_mutex_lock(&v72);
              while (v74[0])
                pthread_cond_wait(&v73, &v72);
              pthread_mutex_unlock(&v72);
              if (v74[1])
                free(v74[1]);
              pthread_mutex_destroy(&v72);
              pthread_cond_destroy(&v73);
              free(v70[1]);
              v70[1] = 0;
              free(v67[1]);
              v67[1] = 0;
              v24 = -64;
              goto LABEL_109;
            }
            *v46 = v67;
            v46[1] = &v72;
            v46[2] = a2;
            v48 = v76;
            v46[8] = v77;
            *((_DWORD *)v46 + 6) = v45;
            *((_DWORD *)v46 + 7) = v10;
            *((double *)v46 + 5) = v6;
            *((_DWORD *)v46 + 8) = v12;
            *((_DWORD *)v46 + 9) = v66;
            v46[6] = 0;
            v46[7] = v48;
            v49 = g_displayLevel;
            *((_DWORD *)v46 + 15) = g_displayLevel;
            if (!v45 || !v10 || v10 != 8 && v10 != 6)
              break;
            if (v45 > a2 || (DWORD1(v71) - 32) < 0xFFFFFFE1 || v10 > v45)
              break;
            pthread_mutex_lock(&v72);
            ++v74[0];
            pthread_mutex_unlock(&v72);
            if (v65)
              POOL_add(v65, (uint64_t)FASTCOVER_tryParameters, (uint64_t)v46);
            else
              FASTCOVER_tryParameters((char *)v46);
            if (v19 >= 2 && (clock() - g_time > 0x249F0 || v19 >= 4))
            {
              g_time = clock();
              v51 = (FILE **)MEMORY[0x1E0C80C10];
              fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%u%%       ", 100 * v64 / v54);
              fflush(*v51);
            }
            ++v64;
            v45 += v16;
            if (v45 > v14)
              goto LABEL_97;
          }
          if (v49 >= 1)
          {
            v50 = (FILE **)MEMORY[0x1E0C80C10];
            fwrite("FASTCOVER parameters incorrect\n", 0x1FuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
            fflush(*v50);
          }
          free(v46);
          v45 += v16;
        }
        while (v45 <= v14);
LABEL_97:
        pthread_mutex_lock(&v72);
        while (v74[0])
          pthread_cond_wait(&v73, &v72);
        pthread_mutex_unlock(&v72);
        free(v70[1]);
        v70[1] = 0;
        free(v67[1]);
        v40 = 0;
        v10 += 2;
        v41 = 0uLL;
        if (v10 <= v63)
          continue;
        break;
      }
    }
    if (v19 >= 2)
    {
      v36 = (FILE **)MEMORY[0x1E0C80C10];
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%79s\r", "");
      fflush(*v36);
    }
    v24 = *((_QWORD *)&v75[3] + 1);
    if (*((_QWORD *)&v75[3] + 1) < 0xFFFFFFFFFFFFFF89)
    {
      *(_OWORD *)v67 = *(_OWORD *)((char *)&v75[2] + 4);
      v37 = *(_QWORD *)&v75[1];
      *(_QWORD *)a6 = *((_QWORD *)&v75[0] + 1);
      v38 = *((_QWORD *)&v75[1] + 1);
      v39 = v75[2];
      *(_QWORD *)(a6 + 12) = v37;
      *(_QWORD *)(a6 + 24) = v38;
      *(_DWORD *)(a6 + 8) = v61;
      *(void **)(a6 + 44) = *(void **)((char *)v67 + 4);
      *(_DWORD *)(a6 + 52) = HIDWORD(v67[1]);
      *(_DWORD *)(a6 + 32) = v62;
      *(_DWORD *)(a6 + 36) = v39;
      v24 = *(_QWORD *)&v75[0];
      memcpy(__dst, v74[1], *(size_t *)&v75[0]);
    }
    COVER_best_destroy(&v72);
LABEL_109:
    POOL_free(v65);
    return v24;
  }
  if (v19 >= 1)
  {
    v28 = (FILE **)MEMORY[0x1E0C80C10];
    fwrite("FASTCOVER must have at least one input file\n", 0x2CuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    fflush(*v28);
  }
  return -72;
}

void FASTCOVER_tryParameters(char *a1)
{
  uint64_t v2;
  __int128 v3;
  size_t v4;
  void *v5;
  char *v6;
  void *v7;
  void *v8;
  BOOL v9;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  size_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  pthread_mutex_t *v22;
  void *v23;
  uint64_t v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;

  v2 = *(_QWORD *)a1;
  v3 = *(_OWORD *)(a1 + 40);
  v29 = *(_OWORD *)(a1 + 24);
  v30 = v3;
  v31 = *(_OWORD *)(a1 + 56);
  v4 = *((_QWORD *)a1 + 2);
  v5 = malloc_type_calloc(1 << *(_DWORD *)(v2 + 68), 2uLL, 0x1000040BDFB0063uLL);
  v6 = (char *)malloc_type_malloc(v4, 0xF5C648D8uLL);
  v7 = malloc_type_malloc(4 << *(_DWORD *)(v2 + 68), 0x957A37F4uLL);
  v8 = v7;
  if (v5)
    v9 = v6 == 0;
  else
    v9 = 1;
  if (v9 || v7 == 0)
  {
    if (g_displayLevel < 1)
    {
      v11 = 0;
      v12 = 0;
      v13 = -1;
      goto LABEL_20;
    }
    fwrite("Failed to allocate buffers: out of memory\n", 0x2AuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    v11 = 0;
    v12 = 0;
    v13 = -1;
    goto LABEL_18;
  }
  memcpy(v7, *(const void **)(v2 + 56), 4 << *(_DWORD *)(v2 + 68));
  v26 = v29;
  v27 = v30;
  v28 = v31;
  v14 = FASTCOVER_buildDictionary((uint64_t *)v2, (uint64_t)v8, (uint64_t)v6, v4, &v26, (uint64_t)v5);
  v16 = *(_QWORD *)(v2 + 24);
  v15 = *(_QWORD *)(v2 + 32);
  v17 = v15 * *(unsigned int *)(v2 + 72) / 0x64;
  v19 = *(_QWORD *)(v2 + 8);
  v18 = *(_QWORD *)(v2 + 16);
  v20 = *(_QWORD *)v2;
  v26 = v29;
  v27 = v30;
  v28 = v31;
  COVER_selectDict(v4, &v6[v14], v4 - v14, v20, v18, v17, v15, v16, &v23, &v26, v19);
  v12 = v23;
  v11 = v24;
  v13 = v25;
  if (v23)
    v21 = v25 > 0xFFFFFFFFFFFFFF88;
  else
    v21 = 1;
  if (v21 && g_displayLevel >= 1)
  {
    fwrite("Failed to select dictionary\n", 0x1CuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
LABEL_18:
    fflush((FILE *)*MEMORY[0x1E0C80C10]);
  }
LABEL_20:
  free(v6);
  v22 = (pthread_mutex_t *)*((_QWORD *)a1 + 1);
  v26 = v29;
  v27 = v30;
  v28 = v31;
  v23 = v12;
  v24 = v11;
  v25 = v13;
  COVER_best_finish(v22, &v26, (uint64_t)&v23);
  free(a1);
  free(v5);
  free(v12);
  free(v8);
}

const char *ZDICT_getErrorName(unint64_t a1)
{
  if (a1 >= 0xFFFFFFFFFFFFFF89)
    return ERR_getErrorString(-(int)a1);
  else
    return ERR_getErrorString(0);
}

uint64_t ZDICT_getDictID(_DWORD *a1, unint64_t a2)
{
  if (a2 >= 8 && *a1 == -332356553)
    return a1[1];
  else
    return 0;
}

uint64_t ZDICT_getDictHeaderSize(_DWORD *a1, unint64_t a2)
{
  char *v4;
  _DWORD *v5;
  void *v6;
  uint64_t CEntropy;

  if (a2 < 9 || *a1 != -332356553)
    return -30;
  v4 = (char *)malloc_type_malloc(0x11F0uLL, 0x1000040F01E3A99uLL);
  v5 = malloc_type_malloc(0x1900uLL, 0xEC1534D4uLL);
  v6 = v5;
  CEntropy = -64;
  if (v4)
  {
    if (v5)
    {
      *(_QWORD *)(v4 + 4580) = 0x400000001;
      *((_DWORD *)v4 + 1147) = 8;
      *((_DWORD *)v4 + 256) = 0;
      *((_QWORD *)v4 + 571) = 0;
      *((_DWORD *)v4 + 1144) = 0;
      CEntropy = ZSTD_loadCEntropy((uint64_t)v4, v5, (uint64_t)a1, a2);
    }
  }
  free(v4);
  free(v6);
  return CEntropy;
}

uint64_t ZDICT_analyzeEntropy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v9;
  unint64_t v10;
  int64x2_t *v11;
  unsigned int v12;
  const void *v13;
  unint64_t v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int64x2_t *v23;
  int64x2_t v24;
  uint64_t v25;
  int64x2_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  void *v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  const void *v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  char *CDict_advanced2;
  void *v40;
  void *v41;
  int32x2_t *v42;
  int64x2_t *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  size_t v47;
  size_t v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  unsigned __int8 *v52;
  unint64_t v53;
  unint64_t v54;
  int v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _BYTE *v61;
  unsigned __int16 *v62;
  _BYTE *v63;
  _BYTE *v64;
  uint64_t v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  int v69;
  unint64_t v70;
  FILE **v71;
  FILE *v72;
  FILE **v73;
  unsigned __int8 *v74;
  uint64_t v75;
  int v76;
  unsigned __int8 *v77;
  uint64_t v78;
  int v79;
  unsigned __int8 *v80;
  int v81;
  _DWORD *v82;
  unsigned int v83;
  unsigned int v84;
  FILE **v85;
  unint64_t v86;
  FILE **v87;
  uint64_t v88;
  unsigned int v89;
  FILE **v90;
  FILE *v91;
  const char *v92;
  size_t v93;
  int32x4_t v94;
  int32x4_t v95;
  __int32 *v96;
  uint64_t v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  _WORD *v104;
  unint64_t v105;
  unint64_t v106;
  char *v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  FILE **v111;
  FILE **v112;
  FILE *v113;
  const char *v114;
  size_t v115;
  FILE **v116;
  FILE *v117;
  const char *v118;
  size_t v119;
  FILE **v120;
  uint64_t v121;
  char *v122;
  _OWORD *v123;
  _BOOL4 v124;
  void (*v125)(uint64_t);
  FILE **v127;
  char *v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t v131;
  _BYTE *v132;
  uint64_t v133;
  uint64_t v134;
  int64x2_t *v135;
  uint64_t v136;
  __int128 v137;
  _BYTE v138[4];
  int v139;
  int v140;
  int v141;
  __int16 v142[36];
  int32x4_t v143[9];
  int32x4_t v144[13];
  int v145;
  __int16 v146[31];
  int32x4_t v147;
  int32x4_t v148;
  int32x4_t v149;
  int32x4_t v150;
  int32x4_t v151;
  int32x4_t v152;
  int32x4_t v153;
  int32x4_t v154;
  int32x4_t v155[64];
  int v156[256];
  _QWORD v157[127];
  __int128 v158[2];
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  uint64_t v189;

  MEMORY[0x1E0C80A78](a1, a2);
  v15 = v14;
  v16 = v12;
  v133 = v17;
  v19 = v18;
  v189 = *MEMORY[0x1E0C80C00];
  v20 = __clz(v14 + 0x20000) ^ 0x1F;
  if (!v12)
  {
    v22 = 0;
    goto LABEL_10;
  }
  if (v12 < 4)
  {
    v21 = 0;
    v22 = 0;
LABEL_8:
    v27 = v12 - v21;
    v28 = &v11->i64[v21];
    do
    {
      v29 = *v28++;
      v22 += v29;
      --v27;
    }
    while (v27);
    goto LABEL_10;
  }
  v21 = v12 & 0xFFFFFFFC;
  v23 = v11 + 1;
  v24 = 0uLL;
  v25 = v21;
  v26 = 0uLL;
  do
  {
    v24 = vaddq_s64(v23[-1], v24);
    v26 = vaddq_s64(*v23, v26);
    v23 += 2;
    v25 -= 4;
  }
  while (v25);
  v22 = vaddvq_s64(vaddq_s64(v26, v24));
  if (v21 != v12)
    goto LABEL_8;
LABEL_10:
  if (v20 <= 0x1E)
  {
    v129 = v9;
    v130 = v10;
    v135 = v11;
    if (v12)
      v33 = v12;
    else
      v33 = 1;
    v34 = v13;
    memset_pattern16(v156, &unk_18820E900, 0x400uLL);
    v131 = v20;
    memset_pattern16(&v147, &unk_18820E900, (4 * v20 + 4));
    memset_pattern16(v144, &unk_18820E900, 0xD4uLL);
    memset_pattern16(v143, &unk_18820E900, 0x90uLL);
    bzero(v138, 0x1000uLL);
    v141 = 1;
    v140 = 1;
    v139 = 1;
    if (v19)
      v35 = v19;
    else
      v35 = 3;
    if (v22 < v33)
      v36 = -1;
    else
      v36 = v22 / v33;
    memset(v158, 0, 28);
    ZSTD_getCParams_internal((uint64_t)v158, v35, v36, v15, 3);
    v37 = v158[0];
    v137 = *(__int128 *)((char *)v158 + 4);
    v38 = *(_QWORD *)((char *)&v158[1] + 4);
    LODWORD(v158[0]) = 0;
    v165 = 0u;
    v164 = 0u;
    v163 = 0u;
    v162 = 0u;
    v161 = 0u;
    v159 = 0u;
    v160 = 0u;
    LODWORD(v159) = 1;
    DWORD1(v158[0]) = v37;
    *(__int128 *)((char *)v158 + 8) = v137;
    *((_QWORD *)&v158[1] + 1) = v38;
    *(_QWORD *)&v167 = 0;
    v166 = 0uLL;
    CDict_advanced2 = ZSTD_createCDict_advanced2(v34, v15, 1, 1, v158, (uint64_t)&ZSTD_defaultCMem);
    v40 = malloc_type_malloc(0xD00uLL, 0x26AA08A0uLL);
    v136 = (uint64_t)v40;
    if (v40)
    {
      bzero(v40, 0xD00uLL);
      ZSTD_clearAllDicts(v136);
      *(_QWORD *)(v136 + 176) = 0;
      *(_OWORD *)(v136 + 144) = 0u;
      *(_OWORD *)(v136 + 160) = 0u;
      *(_OWORD *)(v136 + 112) = 0u;
      *(_OWORD *)(v136 + 128) = 0u;
      *(_OWORD *)(v136 + 80) = 0u;
      *(_OWORD *)(v136 + 96) = 0u;
      *(_OWORD *)(v136 + 48) = 0u;
      *(_OWORD *)(v136 + 64) = 0u;
      *(_OWORD *)(v136 + 16) = 0u;
      *(_OWORD *)(v136 + 32) = 0u;
      *(_DWORD *)(v136 + 60) = 3;
      *(_DWORD *)(v136 + 48) = 1;
    }
    v41 = malloc_type_malloc(0x20000uLL, 0x7B020AB6uLL);
    v42 = (int32x2_t *)v136;
    v30 = v41;
    if (!CDict_advanced2 || !v136 || !v41)
    {
      if (a9)
      {
        v85 = (FILE **)MEMORY[0x1E0C80C10];
        fwrite("Not enough memory \n", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
        fflush(*v85);
      }
      v32 = -64;
      if (!CDict_advanced2)
        goto LABEL_138;
LABEL_127:
      v121 = *((_QWORD *)CDict_advanced2 + 617);
      v123 = CDict_advanced2 + 32;
      v122 = (char *)*((_QWORD *)CDict_advanced2 + 4);
      if (v122 <= CDict_advanced2)
      {
        v124 = *((_QWORD *)CDict_advanced2 + 5) >= (unint64_t)CDict_advanced2;
        v125 = (void (*)(uint64_t))*((_QWORD *)CDict_advanced2 + 616);
        *((_OWORD *)CDict_advanced2 + 4) = 0u;
        *((_OWORD *)CDict_advanced2 + 5) = 0u;
        *v123 = 0u;
        *((_OWORD *)CDict_advanced2 + 3) = 0u;
        if (!v122)
          goto LABEL_133;
      }
      else
      {
        v124 = 0;
        v125 = (void (*)(uint64_t))*((_QWORD *)CDict_advanced2 + 616);
        *((_OWORD *)CDict_advanced2 + 4) = 0u;
        *((_OWORD *)CDict_advanced2 + 5) = 0u;
        *v123 = 0u;
        *((_OWORD *)CDict_advanced2 + 3) = 0u;
        if (!v122)
          goto LABEL_133;
      }
      if (!v125)
      {
        free(v122);
        if (v124)
          goto LABEL_138;
        goto LABEL_137;
      }
      v125(v121);
LABEL_133:
      if (v124)
      {
LABEL_138:
        v31 = v136;
        goto LABEL_139;
      }
      if (v125)
      {
        ((void (*)(uint64_t, char *))v125)(v121, CDict_advanced2);
        goto LABEL_138;
      }
LABEL_137:
      free(CDict_advanced2);
      goto LABEL_138;
    }
    v132 = v41;
    v134 = (uint64_t)CDict_advanced2;
    v43 = v135;
    if (v16)
    {
      v44 = 0;
      v45 = 0;
      v46 = 1 << v37;
      if (1 << v37 >= 0x20000)
        v46 = 0x20000;
      v47 = v46;
      do
      {
        if (v47 >= v43->i64[v44])
          v48 = v43->u64[v44];
        else
          v48 = v47;
        v49 = *(_DWORD *)(v134 + 4948);
        v161 = 0u;
        v162 = 0u;
        v163 = 0u;
        v164 = 0u;
        v165 = 0u;
        v166 = 0u;
        *(_QWORD *)&v167 = 0;
        v160 = 0u;
        v159 = 0u;
        v158[1] = 0u;
        v158[0] = 0u;
        *(__int128 *)((char *)v158 + 4) = *(_OWORD *)(v134 + 288);
        v158[1] = *(_OWORD *)(v134 + 300);
        HIDWORD(v159) = v49;
        if (ZSTD_compressBegin_internal((uint64_t)v42, 0, 0, 0, 0, v134, (uint64_t *)v158, 0xFFFFFFFFFFFFFFFFLL, 0) >= 0xFFFFFFFFFFFFFF89)
        {
          if (!a9)
            goto LABEL_31;
          v71 = (FILE **)MEMORY[0x1E0C80C10];
          fwrite("warning : ZSTD_compressBegin_usingCDict failed \n", 0x30uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
          v72 = *v71;
          goto LABEL_30;
        }
        LODWORD(v50) = 1 << v42[23].i32[1];
        if (v50 >= 0x20000)
          v50 = 0x20000;
        else
          v50 = v50;
        if (v48 > v50
          || (v51 = ZSTD_compressContinue_internal(v42, v132, 0x20000uLL, (char *)(v133 + v45), v48, 0, 0),
              v42 = (int32x2_t *)v136,
              v51 >= 0xFFFFFFFFFFFFFF89))
        {
          if (a9 < 3)
            goto LABEL_31;
          v73 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "warning : could not compress sample size %u \n", v48);
          v72 = *v73;
LABEL_30:
          fflush(v72);
          v42 = (int32x2_t *)v136;
          goto LABEL_31;
        }
        if (!v51)
          goto LABEL_31;
        v52 = *(unsigned __int8 **)(v136 + 648);
        v53 = *(_QWORD *)(v136 + 656);
        if ((unint64_t)v52 < v53)
        {
          v54 = v53 - (_QWORD)v52;
          do
          {
            v55 = *v52++;
            ++v156[v55];
            --v54;
          }
          while (v54);
        }
        v56 = *(_QWORD *)(v136 + 632);
        v57 = *(_QWORD *)(v136 + 640) - v56;
        v58 = *(_QWORD *)(v136 + 664);
        v59 = *(_QWORD *)(v136 + 672);
        v60 = (v57 >> 3);
        if ((v57 & 0x7FFFFFFF8) != 0)
        {
          v61 = *(_BYTE **)(v136 + 680);
          v62 = (unsigned __int16 *)(v56 + 6);
          v63 = *(_BYTE **)(v136 + 664);
          v64 = *(_BYTE **)(v136 + 672);
          v65 = (v57 >> 3);
          do
          {
            while (1)
            {
              v66 = *(v62 - 1);
              if (v66 < 0x40)
                LOBYTE(v67) = ZSTD_LLcode_LL_Code[*(v62 - 1)];
              else
                v67 = 50 - __clz(v66);
              v68 = *v62;
              *v63 = v67;
              *v61 = __clz(*(_DWORD *)(v62 - 3)) ^ 0x1F;
              if (v68 >= 0x80)
                break;
              v62 += 4;
              *v64++ = ZSTD_MLcode_ML_Code[v68];
              ++v61;
              ++v63;
              if (!--v65)
                goto LABEL_53;
            }
            v62 += 4;
            *v64++ = 67 - __clz(v68);
            ++v61;
            ++v63;
            --v65;
          }
          while (v65);
        }
LABEL_53:
        v69 = *(_DWORD *)(v136 + 704);
        if (v69 == 1)
        {
          *(_BYTE *)(v58 + *(unsigned int *)(v136 + 708)) = 35;
          if (*(_DWORD *)(v136 + 704) != 2)
            goto LABEL_55;
        }
        else if (v69 != 2)
        {
LABEL_55:
          v70 = v57 >> 3;
          if ((_DWORD)v70)
            goto LABEL_63;
          goto LABEL_31;
        }
        *(_BYTE *)(v59 + *(unsigned int *)(v136 + 708)) = 52;
        v70 = v57 >> 3;
        if ((_DWORD)v70)
        {
LABEL_63:
          v74 = *(unsigned __int8 **)(v136 + 680);
          v75 = v60;
          do
          {
            v76 = *v74++;
            ++v147.i32[v76];
            --v75;
          }
          while (v75);
          v77 = *(unsigned __int8 **)(v136 + 672);
          v78 = v60;
          do
          {
            v79 = *v77++;
            ++v144[0].i32[v79];
            --v78;
          }
          while (v78);
          v80 = *(unsigned __int8 **)(v136 + 664);
          do
          {
            v81 = *v80++;
            ++v143[0].i32[v81];
            --v60;
          }
          while (v60);
          if (v70 >= 2)
          {
            v82 = *(_DWORD **)(v136 + 632);
            v83 = *v82 - 3;
            v84 = v82[2] - 3;
            if (v83 > 0x3FF)
              v83 = 0;
            if (v84 > 0x3FF)
              v84 = 0;
            *(_DWORD *)&v138[4 * v83] += 3;
            ++*(_DWORD *)&v138[4 * v84];
          }
        }
LABEL_31:
        v43 = v135;
        v45 += v135->i64[v44++];
      }
      while (v44 != v16);
    }
    v188 = 0u;
    v187 = 0u;
    v186 = 0u;
    v185 = 0u;
    v184 = 0u;
    v183 = 0u;
    v182 = 0u;
    v181 = 0u;
    v180 = 0u;
    v179 = 0u;
    v178 = 0u;
    v177 = 0u;
    v176 = 0u;
    v175 = 0u;
    v174 = 0u;
    v173 = 0u;
    v172 = 0u;
    v171 = 0u;
    v170 = 0u;
    v169 = 0u;
    v168 = 0u;
    v167 = 0u;
    v166 = 0u;
    v165 = 0u;
    v164 = 0u;
    v163 = 0u;
    v162 = 0u;
    v161 = 0u;
    v160 = 0u;
    v159 = 0u;
    memset(v158, 0, sizeof(v158));
    v86 = HUF_buildCTable_wksp((uint64_t)v155, v156, 255, 0xBu, (char *)v158, 0x1100uLL);
    v32 = v86;
    if (v86 >= 0xFFFFFFFFFFFFFF89)
    {
      CDict_advanced2 = (char *)v134;
      if (!a9)
      {
LABEL_126:
        v30 = v132;
        goto LABEL_127;
      }
      v90 = (FILE **)MEMORY[0x1E0C80C10];
      v91 = (FILE *)*MEMORY[0x1E0C80C10];
      v92 = " HUF_buildCTable error \n";
      v93 = 24;
LABEL_88:
      fwrite(v92, v93, 1uLL, v91);
      fflush(*v90);
      goto LABEL_126;
    }
    CDict_advanced2 = (char *)v134;
    if (v86 == 8)
    {
      if (a9 >= 2)
      {
        v87 = (FILE **)MEMORY[0x1E0C80C10];
        fwrite("warning : pathological dataset : literals are not compressible : samples are noisy or too regular \n", 0x63uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
        fflush(*v87);
      }
      memset_pattern16(v157, &unk_18823D800, 0x3FCuLL);
      v156[0] = 4;
      v157[126] = 0x100000001;
      v188 = 0u;
      v187 = 0u;
      v186 = 0u;
      v185 = 0u;
      v184 = 0u;
      v183 = 0u;
      v182 = 0u;
      v181 = 0u;
      v180 = 0u;
      v179 = 0u;
      v178 = 0u;
      v177 = 0u;
      v176 = 0u;
      v175 = 0u;
      v174 = 0u;
      v173 = 0u;
      v172 = 0u;
      v171 = 0u;
      v170 = 0u;
      v169 = 0u;
      v168 = 0u;
      v167 = 0u;
      v166 = 0u;
      v165 = 0u;
      v164 = 0u;
      v163 = 0u;
      v162 = 0u;
      v161 = 0u;
      v160 = 0u;
      v159 = 0u;
      memset(v158, 0, sizeof(v158));
      LODWORD(v32) = HUF_buildCTable_wksp((uint64_t)v155, v156, 255, 0xBu, (char *)v158, 0x1100uLL);
    }
    if (v131 >= 7)
    {
      v88 = ((_BYTE)v131 + 1) & 0x78;
      v94 = v147;
      v95 = v148;
      if (v88 != 8)
      {
        v94 = vaddq_s32(v149, v147);
        v95 = vaddq_s32(v150, v148);
        if (v88 != 16)
        {
          v94 = vaddq_s32(v151, v94);
          v95 = vaddq_s32(v152, v95);
          if (v88 != 24)
          {
            v94 = vaddq_s32(v153, v94);
            v95 = vaddq_s32(v154, v95);
            if (v88 != 32)
            {
              v94 = vaddq_s32(v155[0], v94);
              v95 = vaddq_s32(v155[1], v95);
              if (v88 != 40)
              {
                v94 = vaddq_s32(v155[2], v94);
                v95 = vaddq_s32(v155[3], v95);
                if (v88 != 48)
                {
                  v94 = vaddq_s32(v155[4], v94);
                  v95 = vaddq_s32(v155[5], v95);
                  if (v88 != 56)
                  {
                    v94 = vaddq_s32(v155[6], v94);
                    v95 = vaddq_s32(v155[7], v95);
                  }
                }
              }
            }
          }
        }
      }
      v89 = vaddvq_s32(vaddq_s32(v95, v94));
      if (v88 == (_DWORD)v131 + 1)
        goto LABEL_100;
    }
    else
    {
      v88 = 0;
      v89 = 0;
    }
    v96 = &v147.i32[v88];
    v97 = v131 - v88 + 1;
    do
    {
      v98 = *v96++;
      v89 += v98;
      --v97;
    }
    while (v97);
LABEL_100:
    v99 = FSE_normalizeCount(v146, 8u, (unsigned int *)&v147, v89, v131, 1);
    if (v99 >= 0xFFFFFFFFFFFFFF89)
    {
      if (a9)
      {
        v112 = (FILE **)MEMORY[0x1E0C80C10];
        v113 = (FILE *)*MEMORY[0x1E0C80C10];
        v114 = "FSE_normalizeCount error with offcodeCount \n";
        v115 = 44;
LABEL_113:
        fwrite(v114, v115, 1uLL, v113);
        fflush(*v112);
        v32 = v99;
        goto LABEL_126;
      }
LABEL_125:
      v32 = v99;
      goto LABEL_126;
    }
    v100 = FSE_normalizeCount((__int16 *)v158, 9u, (unsigned int *)v144, (vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v144[0], v144[4]), vaddq_s32(v144[2], v144[6])), vaddq_s32(vaddq_s32(v144[1], v144[5]), vaddq_s32(v144[3], v144[7]))), vaddq_s32(vaddq_s32(vaddq_s32(v144[8], v144[10]), vaddq_s32(v144[9], v144[11])), v144[12])))+ v145), 0x34u, 1);
    if (v100 >= 0xFFFFFFFFFFFFFF89)
    {
      if (!a9)
      {
LABEL_117:
        v32 = v100;
        goto LABEL_126;
      }
      v116 = (FILE **)MEMORY[0x1E0C80C10];
      v117 = (FILE *)*MEMORY[0x1E0C80C10];
      v118 = "FSE_normalizeCount error with matchLengthCount \n";
      v119 = 48;
LABEL_116:
      fwrite(v118, v119, 1uLL, v117);
      fflush(*v116);
      goto LABEL_117;
    }
    v101 = FSE_normalizeCount(v142, 9u, (unsigned int *)v143, vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v143[0], v143[4]), vaddq_s32(v143[2], v143[6])), vaddq_s32(vaddq_s32(v143[1], v143[5]), vaddq_s32(v143[3], v143[7]))), v143[8])), 0x23u, 1);
    if (v101 >= 0xFFFFFFFFFFFFFF89)
    {
      if (a9)
      {
        v120 = (FILE **)MEMORY[0x1E0C80C10];
        fwrite("FSE_normalizeCount error with litLengthCount \n", 0x2EuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
        fflush(*v120);
      }
      v32 = v101;
      goto LABEL_126;
    }
    v102 = HUF_writeCTable(v129, v130, (uint64_t)v155, 0xFFu, v32);
    v32 = v102;
    if (v102 < 0xFFFFFFFFFFFFFF89)
    {
      v103 = FSE_writeNCount((_WORD *)(v129 + v102), v130 - v102, (uint64_t)v146, 30, v99);
      v99 = v103;
      if (v103 < 0xFFFFFFFFFFFFFF89)
      {
        v104 = (_WORD *)(v129 + v32 + v103);
        v105 = v130 - v32 - v103;
        v106 = FSE_writeNCount(v104, v105, (uint64_t)v158, 52, v100);
        v100 = v106;
        if (v106 < 0xFFFFFFFFFFFFFF89)
        {
          v107 = (char *)v104 + v106;
          v108 = v105 - v106;
          v109 = FSE_writeNCount((_WORD *)((char *)v104 + v106), v108, (uint64_t)v142, 35, v101);
          v110 = v109;
          if (v109 >= 0xFFFFFFFFFFFFFF89)
          {
            if (a9)
            {
              v127 = (FILE **)MEMORY[0x1E0C80C10];
              fwrite("FSE_writeNCount error with litlengthNCount \n", 0x2CuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
              fflush(*v127);
              v32 = v110;
            }
            else
            {
              v32 = v109;
            }
          }
          else if (v108 - v109 > 0xB)
          {
            v128 = &v107[v109];
            *(_QWORD *)v128 = 0x400000001;
            *((_DWORD *)v128 + 2) = 8;
            v32 += v99 + v100 + v109 + 12;
          }
          else
          {
            if (a9)
            {
              v111 = (FILE **)MEMORY[0x1E0C80C10];
              fwrite("not enough space to write RepOffsets \n", 0x26uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
              fflush(*v111);
            }
            v32 = -70;
          }
          goto LABEL_126;
        }
        if (!a9)
          goto LABEL_117;
        v116 = (FILE **)MEMORY[0x1E0C80C10];
        v117 = (FILE *)*MEMORY[0x1E0C80C10];
        v118 = "FSE_writeNCount error with matchLengthNCount \n";
        v119 = 46;
        goto LABEL_116;
      }
      if (a9)
      {
        v112 = (FILE **)MEMORY[0x1E0C80C10];
        v113 = (FILE *)*MEMORY[0x1E0C80C10];
        v114 = "FSE_writeNCount error with offcodeNCount \n";
        v115 = 42;
        goto LABEL_113;
      }
      goto LABEL_125;
    }
    if (!a9)
      goto LABEL_126;
    v90 = (FILE **)MEMORY[0x1E0C80C10];
    v91 = (FILE *)*MEMORY[0x1E0C80C10];
    v92 = "HUF_writeCTable error \n";
    v93 = 23;
    goto LABEL_88;
  }
  v30 = 0;
  v31 = 0;
  v32 = -34;
LABEL_139:
  ZSTD_freeCCtx(v31);
  free(v30);
  return v32;
}

uint64_t ZDICT_trainFromBuffer_legacy(char *a1, unint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  int64x2_t *v17;
  int64x2_t v18;
  uint64_t v19;
  int64x2_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  unint64_t v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unint64_t v35;
  int64x2_t *v36;
  int64x2_t v37;
  uint64_t v38;
  int64x2_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  unsigned int *v43;
  FILE **v44;
  char *v45;
  char *v46;
  int v47;
  FILE **v48;
  unsigned int v49;
  unint64_t v50;
  int *v51;
  int v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t i;
  int v59;
  uint64_t v60;
  _DWORD *v61;
  int *v62;
  int v63;
  FILE **v64;
  uint64_t v65;
  unsigned int v66;
  char *v67;
  __int128 v68;
  unint64_t v69;
  uint64_t v70;
  char *v71;
  int v72;
  unsigned int v73;
  uint64_t v74;
  int v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t v78;
  int v79;
  unsigned int v80;
  unsigned int v81;
  unint64_t v82;
  int v83;
  uint64_t v84;
  char *v85;
  unint64_t v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  uint64_t v94;
  unint64_t v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  char *v100;
  uint64_t v101;
  FILE **v102;
  int v103;
  unsigned int v104;
  unsigned int v105;
  int v106;
  int v107;
  unsigned int v108;
  char v109;
  uint64_t v110;
  uint64_t v111;
  char *v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  _QWORD *v117;
  unint64_t v118;
  char *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  unsigned int v123;
  unsigned int v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  unsigned int v146;
  unsigned int v147;
  unsigned int v148;
  unsigned int v149;
  unsigned int v150;
  unsigned int v151;
  unsigned int v152;
  unsigned int v153;
  unsigned int v154;
  unsigned int v155;
  unsigned int v156;
  unsigned int v157;
  unsigned int v158;
  unsigned int v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  unsigned int v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  unsigned int v167;
  unsigned int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  unsigned int v173;
  unsigned int v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int v177;
  unint64_t v178;
  uint64_t v180;
  _QWORD *v181;
  unint64_t v182;
  char *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  int v187;
  unsigned int v188;
  unsigned int v189;
  uint64_t v190;
  int v191;
  int v192;
  int v193;
  uint64_t v194;
  char *v195;
  uint64_t v196;
  uint64_t v197;
  unsigned int v198;
  char *v199;
  unint64_t v200;
  char *v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  char *v205;
  unsigned int v206;
  unsigned int v207;
  unsigned int v208;
  uint64_t v209;
  unsigned int v210;
  uint64_t v211;
  uint64_t v212;
  unsigned int *v213;
  unsigned int *v214;
  uint64_t v215;
  unsigned int v216;
  uint64_t v217;
  unsigned int v218;
  unsigned int *v219;
  unsigned int *v220;
  uint64_t v221;
  unsigned int *v222;
  unsigned int v223;
  clock_t v224;
  uint64_t v225;
  uint64_t v226;
  const float *v227;
  int32x4_t v228;
  int32x4_t v229;
  const float *v230;
  unsigned __int128 v231;
  unsigned __int128 v232;
  uint64_t v233;
  unsigned int *v234;
  unsigned int v235;
  FILE **v236;
  uint64_t v237;
  unsigned int *v238;
  unsigned int v239;
  unint64_t v240;
  uint64_t v242;
  char *v243;
  int v244;
  int v245;
  int v246;
  uint64_t v247;
  unint64_t v248;
  unint64_t v249;
  uint64_t v250;
  char *v251;
  uint64_t v252;
  uint64_t v253;
  const float *v254;
  int32x4_t v255;
  int32x4_t v256;
  const float *v257;
  unsigned __int128 v258;
  unsigned __int128 v259;
  uint64_t v260;
  uint64_t v261;
  FILE **v263;
  unsigned int v264;
  FILE **v266;
  unsigned int v267;
  uint64_t v268;
  unsigned int v269;
  uint64_t v270;
  uint64_t v271;
  unint64_t v272;
  char *v273;
  unsigned int *v274;
  unint64_t v275;
  size_t v276;
  unsigned int v277;
  uint64_t v278;
  unsigned int v279;
  unsigned int v280;
  clock_t v281;
  char *v282;
  unsigned int v283;
  uint64_t v284;
  uint64_t v285;
  unint64_t v286;
  unsigned int v287;
  unsigned int v288;
  char *v289;
  unint64_t v290;
  unsigned int *v291;
  unsigned int v292;
  unsigned int v293;
  _DWORD *v294;
  char *v295;
  int *v296;
  uint64_t v297;
  unsigned int *v298;
  _BYTE v299[12];
  __int128 v300;
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  __int128 v305;
  __int128 v306;
  __int128 v307;
  __int128 v308;
  __int128 v309;
  __int128 v310;
  __int128 v311;
  __int128 v312;
  __int128 v313;
  __int128 v314;
  __int128 v315;
  __int128 v316;
  __int128 v317;
  __int128 v318;
  __int128 v319;
  __int128 v320;
  __int128 v321;
  __int128 v322;
  __int128 v323;
  __int128 v324;
  __int128 v325;
  __int128 v326;
  __int128 v327;
  __int128 v328;
  __int128 v329;
  __int128 v330;
  __int128 v331;
  uint64_t v332;

  v332 = *MEMORY[0x1E0C80C00];
  if (!(_DWORD)a5)
    return 0;
  v14 = a5;
  if (a5 < 4)
  {
    v15 = 0;
    v16 = 0;
LABEL_7:
    v21 = a5 - v15;
    v22 = (uint64_t *)(a4 + 8 * v15);
    do
    {
      v23 = *v22++;
      v16 += v23;
      --v21;
    }
    while (v21);
    goto LABEL_9;
  }
  v15 = a5 & 0xFFFFFFFC;
  v17 = (int64x2_t *)(a4 + 16);
  v18 = 0uLL;
  v19 = v15;
  v20 = 0uLL;
  do
  {
    v18 = vaddq_s64(v17[-1], v18);
    v20 = vaddq_s64(*v17, v20);
    v17 += 2;
    v19 -= 4;
  }
  while (v19);
  v16 = vaddvq_s64(vaddq_s64(v20, v18));
  if (v15 != a5)
    goto LABEL_7;
LABEL_9:
  if (v16 >= 0x200)
  {
    v25 = (char *)malloc_type_malloc(v16 + 32, 0xFEBA5CBFuLL);
    if (!v25)
      return -64;
    v26 = v25;
    memcpy(v25, a3, v16);
    v27 = &v26[v16];
    *(_OWORD *)v27 = xmmword_18823D7E0;
    *((_OWORD *)v27 + 1) = xmmword_18823D7F0;
    *(_DWORD *)v299 = HIDWORD(a6);
    *(_QWORD *)&v299[4] = a7;
    v28 = a2 >> 4;
    if (a5 > (a2 >> 4))
      LODWORD(v28) = a5;
    if (v28 <= 0x2710)
      v29 = 10000;
    else
      v29 = v28;
    v30 = (unsigned int *)malloc_type_malloc(12 * v29, 0x10000403E1C8BA9uLL);
    v31 = v30;
    if ((_DWORD)a6)
      v32 = a6;
    else
      v32 = 9;
    if (v32 <= 0x1E)
      v33 = a5 >> v32;
    else
      v33 = 4;
    if (a5 >= 4)
    {
      v34 = v14 & 0xFFFFFFFC;
      v36 = (int64x2_t *)(a4 + 16);
      v37 = 0uLL;
      v38 = v34;
      v39 = 0uLL;
      do
      {
        v37 = vaddq_s64(v36[-1], v37);
        v39 = vaddq_s64(*v36, v39);
        v36 += 2;
        v38 -= 4;
      }
      while (v38);
      v35 = vaddvq_s64(vaddq_s64(v39, v37));
      if (v34 == v14)
      {
LABEL_31:
        if (!v30)
        {
          v24 = -64;
LABEL_340:
          free(v26);
          return v24;
        }
        if (a2 < 0x100)
        {
          v24 = -70;
LABEL_339:
          free(v31);
          goto LABEL_340;
        }
        if (v35 < 0x200)
        {
LABEL_338:
          v24 = -34;
          goto LABEL_339;
        }
        v292 = v33;
        v288 = v32;
        v289 = a1;
        v290 = a2;
        *(_QWORD *)v30 = 1;
        v298 = v30;
        v30[2] = -1;
        v296 = (int *)malloc_type_malloc(4 * v35 + 8, 0x100004052888210uLL);
        v43 = (unsigned int *)malloc_type_malloc(4 * v35, 0x100004052888210uLL);
        v295 = (char *)malloc_type_malloc(v35 + 16, 0x100004077774924uLL);
        v294 = malloc_type_malloc(4 * v14, 0x100004052888210uLL);
        if (a7 >= 2)
        {
          v44 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%70s\r", "");
          fflush(*v44);
        }
        v293 = a7;
        v45 = v295;
        v46 = (char *)v296;
        if (!v296 || !v43 || !v295 || !v294)
        {
LABEL_54:
          v53 = v45;
          free(v46);
          free(v43);
          free(v53);
          free(v294);
          if (a7 >= 3)
          {
            v54 = *v298;
            v55 = v54 >= 0x19 ? 25 : v54;
            v297 = v55;
            if (v54 < 2)
            {
              v56 = 0;
            }
            else
            {
              if (v54 >= 0xA)
              {
                v225 = (v54 - 1) & 7;
                if (!v225)
                  v225 = 8;
                v226 = v54 - 1 - v225;
                v57 = v54 - v225;
                v227 = (const float *)(v298 + 16);
                v228 = 0uLL;
                v229 = 0uLL;
                do
                {
                  v230 = v227 - 12;
                  v231 = (unsigned __int128)vld3q_f32(v230);
                  v232 = (unsigned __int128)vld3q_f32(v227);
                  v228 = vaddq_s32((int32x4_t)v231, v228);
                  v229 = vaddq_s32((int32x4_t)v232, v229);
                  v227 += 24;
                  v226 -= 8;
                }
                while (v226);
                v56 = vaddvq_s32(vaddq_s32(v229, v228));
              }
              else
              {
                v56 = 0;
                v57 = 1;
              }
              v233 = v54 - v57;
              v234 = &v298[3 * v57 + 1];
              do
              {
                v235 = *v234;
                v234 += 3;
                v56 += v235;
                --v233;
              }
              while (v233);
            }
            v236 = (FILE **)MEMORY[0x1E0C80C10];
            fprintf((FILE *)*MEMORY[0x1E0C80C10], "\n %u segments found, of total size %u \n", v54 - 1, v56);
            fflush(*v236);
            fprintf(*v236, "list %u best segments \n", v297 - 1);
            fflush(*v236);
            if (v297 >= 2)
            {
              v237 = 1;
              while (1)
              {
                v31 = v298;
                v238 = &v298[3 * v237];
                v240 = *v238;
                v239 = v238[1];
                if (v35 < v240 || v35 < v239 + v240)
                  break;
                if (v239 >= 0x28)
                  v242 = 40;
                else
                  v242 = v239;
                fprintf(*v236, "%3u:%3u bytes at pos %8u, savings %7u bytes |", v237, v239, v240, v298[3 * v237 + 2]);
                fflush(*v236);
                if ((_DWORD)v242)
                {
                  v243 = &v26[v240];
                  do
                  {
                    v245 = *v243++;
                    v244 = v245;
                    if ((v245 - 127) >= 0xFFFFFFA1)
                      v246 = v244;
                    else
                      v246 = 46;
                    fputc(v246, *v236);
                    fflush(*v236);
                    --v242;
                  }
                  while (v242);
                }
                fwrite("| \n", 3uLL, 1uLL, *v236);
                fflush(*v236);
                if (++v237 == v297)
                  goto LABEL_327;
              }
              v24 = -1;
              goto LABEL_339;
            }
          }
LABEL_327:
          v31 = v298;
          v247 = *v298;
          if (v247 < 2)
            goto LABEL_338;
          v248 = v290;
          if (v247 >= 0xA)
          {
            v252 = (v247 - 1) & 7;
            if (!v252)
              v252 = 8;
            v253 = v247 - 1 - v252;
            v250 = v253 + 1;
            v254 = (const float *)(v298 + 16);
            v255 = 0uLL;
            v256 = 0uLL;
            v251 = v289;
            do
            {
              v257 = v254 - 12;
              v258 = (unsigned __int128)vld3q_f32(v257);
              v259 = (unsigned __int128)vld3q_f32(v254);
              v255 = vaddq_s32((int32x4_t)v258, v255);
              v256 = vaddq_s32((int32x4_t)v259, v256);
              v254 += 24;
              v253 -= 8;
            }
            while (v253);
            LODWORD(v249) = vaddvq_s32(vaddq_s32(v256, v255));
          }
          else
          {
            LODWORD(v249) = 0;
            v250 = 1;
            v251 = v289;
          }
          v260 = v247 - v250;
          v261 = 12 * v250 + 4;
          do
          {
            v249 = *(unsigned int *)((char *)v298 + v261) + v249;
            v261 += 12;
            --v260;
          }
          while (v260);
          if (v249 < 0x80)
            goto LABEL_338;
          if (v293 >= 2 && v290 >> 2 > v249)
          {
            v263 = (FILE **)MEMORY[0x1E0C80C10];
            fprintf((FILE *)*MEMORY[0x1E0C80C10], "!  warning : selected content significantly smaller than requested (%u < %u) \n", v249, v290);
            fflush(*v263);
            if (v35 < 10 * v290)
            {
              fprintf(*v263, "!  consider increasing the number of samples (total size : %u MB)\n", v35 >> 20);
              fflush(*v263);
            }
            v31 = v298;
            if (v292 >= 5)
            {
              fprintf(*v263, "!  consider increasing selectivity to produce larger dictionary (-s%u) \n", v288 + 1);
              fflush(*v263);
              fwrite("!  note : larger dictionaries are not necessarily better, test its efficiency on samples \n", 0x5AuLL, 1uLL, *v263);
              fflush(*v263);
              v31 = v298;
            }
          }
          v264 = v288;
          if (a5 >= 9 && 3 * v290 < v249 && v288 >= 2)
          {
            do
              --v264;
            while (a5 >> v264 < 5);
            if (v293 >= 2)
            {
              v266 = (FILE **)MEMORY[0x1E0C80C10];
              v267 = v264;
              fprintf((FILE *)*MEMORY[0x1E0C80C10], "!  note : calculated dictionary significantly larger than requested (%u > %u) \n", v249, v290);
              fflush(*v266);
              fprintf(*v266, "!  consider increasing dictionary size, or produce denser dictionary (-s%u) \n", v267);
              fflush(*v266);
              fwrite("!  always test dictionary efficiency on real samples \n", 0x36uLL, 1uLL, *v266);
              fflush(*v266);
              v31 = v298;
            }
          }
          v268 = *v31;
          if (v268 <= 1)
          {
            v269 = 0;
            *v31 = 1;
          }
          else
          {
            v269 = 0;
            v270 = 1;
            v271 = 4;
            while (1)
            {
              v272 = v31[v271] + v269;
              if (v272 > v290)
                break;
              ++v270;
              v271 += 3;
              v269 = v272;
              if (v268 == v270)
              {
                v269 = v272;
                LODWORD(v270) = *v31;
                break;
              }
            }
            *v31 = v270;
            if (v270 >= 2)
            {
              v273 = &v251[v290];
              v274 = v31 + 4;
              v275 = 1;
              while (1)
              {
                v276 = *v274;
                v273 -= v276;
                if (v273 < v251)
                  break;
                memcpy(v273, &v26[*(v274 - 1)], v276);
                ++v275;
                v274 += 3;
                if (v275 >= *v298)
                {
                  v248 = v290;
                  goto LABEL_368;
                }
              }
              v24 = -1;
              goto LABEL_369;
            }
          }
LABEL_368:
          v24 = ZDICT_addEntropyTablesFromBuffer_advanced(v251, v269, v248, (uint64_t)v26, a4, a5, *(unint64_t *)v299, *(int *)&v299[8]);
LABEL_369:
          v31 = v298;
          goto LABEL_339;
        }
        if (v292 <= 4)
          v47 = 4;
        else
          v47 = v292;
        v287 = v47;
        bzero(v295, v35 + 16);
        if (a7 < 3 || v35 < 0x7D000001)
        {
          v49 = a5;
          v50 = v35;
          if (v35 < 0x7D000001)
            goto LABEL_51;
        }
        else
        {
          v48 = (FILE **)MEMORY[0x1E0C80C10];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "sample set too large : reduced to %u MB ...\n", 2000);
          fflush(*v48);
        }
        v50 = v35;
        v49 = a5;
        do
          v50 -= *(_QWORD *)(a4 + 8 * --v49);
        while (v50 > 0x7D000000);
LABEL_51:
        v51 = v296 + 1;
        if (a7 >= 2)
        {
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "sorting %u files of total size %u MB ...\n", v49, v50 >> 20);
          fflush((FILE *)*MEMORY[0x1E0C80C10]);
        }
        v52 = divsufsort((unsigned __int8 *)v26, v51, v50);
        v45 = v295;
        v46 = (char *)v296;
        if (!v52)
        {
          v51[v50] = v50;
          *v296 = v50;
          if (v50)
          {
            for (i = 0; i != v50; ++i)
              v43[v51[i]] = i;
          }
          *v294 = 0;
          if (v49 >= 2)
          {
            v59 = 0;
            v60 = v49 - 1;
            v61 = v294 + 1;
            v62 = (int *)a4;
            do
            {
              v63 = *v62;
              v62 += 2;
              v59 += v63;
              *v61++ = v59;
              --v60;
            }
            while (v60);
          }
          if (a7 >= 2)
          {
            v64 = (FILE **)MEMORY[0x1E0C80C10];
            fwrite("finding patterns ... \n", 0x16uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
            fflush(*v64);
            v46 = (char *)v296;
            if (a7 >= 3)
            {
              fprintf(*v64, "minimum ratio : %u \n", v287);
              fflush(*v64);
              v46 = (char *)v296;
            }
          }
          v45 = v295;
          if (v50)
          {
            v65 = 0;
            v66 = 0;
            v279 = v29 - 1;
            v280 = v29;
            v67 = v26 + 8;
            v281 = 0;
            v282 = v46 + 4;
            v68 = 0uLL;
            v291 = v43;
            while (1)
            {
              if (v45[v65])
              {
                ++v66;
              }
              else
              {
                v69 = v43[v65];
                v314 = v68;
                v315 = v68;
                v312 = v68;
                v313 = v68;
                v310 = v68;
                v311 = v68;
                v308 = v68;
                v309 = v68;
                v306 = v68;
                v307 = v68;
                v304 = v68;
                v305 = v68;
                v302 = v68;
                v303 = v68;
                v300 = v68;
                v301 = v68;
                v70 = v51[v69];
                v45[v70] = 1;
                v71 = &v26[v70];
                v72 = *(unsigned __int16 *)&v26[v70 + 2];
                if (*(unsigned __int16 *)&v26[v70] == v72
                  || *(unsigned __int16 *)(v71 + 1) == *(unsigned __int16 *)(v71 + 3)
                  || v72 == *((unsigned __int16 *)v71 + 2))
                {
                  v73 = 6;
                  do
                  {
                    v74 = v73;
                    v75 = *(unsigned __int16 *)&v71[v73];
                    v73 += 2;
                  }
                  while (v75 == *((unsigned __int16 *)v71 + 2));
                  if (v73 != 2)
                  {
                    if (v26[v74 + v70] == v26[v74 - 1 + v70])
                      v76 = v73 + 1;
                    else
                      v76 = v73;
                    v77 = v66;
                    memset(&v45[v70 + 1], 1, v76 - 4 + 1);
                    v68 = 0uLL;
                    v67 = v26 + 8;
                    v66 = v77;
                    v45 = v295;
                    v46 = (char *)v296;
                  }
                }
                else
                {
                  v78 = *(_QWORD *)v71;
                  v79 = 1;
                  v80 = v69;
                  v81 = v287;
                  do
                  {
                    v83 = v79;
                    v84 = v51[++v80];
                    v85 = &v26[v70];
                    v86 = *(_QWORD *)&v26[v84] ^ v78;
                    if (!v86)
                    {
                      v87 = &v67[v84];
                      v85 = &v26[v70];
                      do
                      {
                        v89 = *((_QWORD *)v85 + 1);
                        v85 += 8;
                        v88 = v89;
                        v90 = *(_QWORD *)v87;
                        v87 += 8;
                        v86 = v88 ^ v90;
                      }
                      while (!v86);
                    }
                    v82 = &v85[__clz(__rbit64(v86)) >> 3] - v71;
                    v79 = v83 + 1;
                  }
                  while (v82 > 6);
                  do
                  {
                    LODWORD(v92) = v69;
                    v93 = v83;
                    v94 = *(int *)&v46[4 * v69];
                    v69 = (unint64_t)&v26[v70];
                    v95 = *(_QWORD *)&v26[v94] ^ v78;
                    if (!v95)
                    {
                      v96 = &v67[v94];
                      v69 = (unint64_t)&v26[v70];
                      do
                      {
                        v98 = *(_QWORD *)(v69 + 8);
                        v69 += 8;
                        v97 = v98;
                        v99 = *(_QWORD *)v96;
                        v96 += 8;
                        v95 = v97 ^ v99;
                      }
                      while (!v95);
                    }
                    v91 = v69 + (__clz(__rbit64(v95)) >> 3) - (_QWORD)v71;
                    LODWORD(v69) = v92 - 1;
                    v83 = v93 + 1;
                  }
                  while (v91 > 6);
                  if (v80 - v92 >= v287)
                  {
                    v283 = v66;
                    if (v293 >= 4)
                    {
                      fputc(10, (FILE *)*MEMORY[0x1E0C80C10]);
                      fflush((FILE *)*MEMORY[0x1E0C80C10]);
                      fprintf((FILE *)*MEMORY[0x1E0C80C10], "found %3u matches of length >= %i at pos %7u  ", v80 - v92, 7, v70);
                      v102 = (FILE **)MEMORY[0x1E0C80C10];
                      fflush((FILE *)*MEMORY[0x1E0C80C10]);
                      fputc(10, *v102);
                      fflush(*v102);
                      v68 = 0uLL;
                      v81 = v287;
                      v67 = v26 + 8;
                      v66 = v283;
                      v45 = v295;
                      v46 = (char *)v296;
                    }
                    v103 = 7;
                    if (v92 >= v80)
                    {
LABEL_106:
                      v104 = 0;
                      v105 = 0;
                      v106 = v92;
                      v107 = v92;
                      goto LABEL_107;
                    }
                    while (1)
                    {
                      v105 = 0;
                      v104 = 0;
                      v109 = 0;
                      v107 = v92;
                      v106 = v92;
                      v110 = v92;
                      do
                      {
                        if (v26[v51[v110] + v103] != v109)
                        {
                          if (v104 > v105)
                          {
                            v105 = v104;
                            v107 = v106;
                          }
                          v109 = v26[v51[v110] + v103];
                          v106 = v110;
                          v104 = 0;
                        }
                        ++v104;
                        ++v110;
                      }
                      while (v80 != v110);
LABEL_107:
                      v108 = v104 <= v105 ? v105 : v104;
                      if (v108 < v81)
                        break;
                      if (v104 <= v105)
                        LODWORD(v92) = v107;
                      else
                        LODWORD(v92) = v106;
                      v80 = v92 + v108;
                      ++v103;
                      if (v92 >= v92 + v108)
                        goto LABEL_106;
                    }
                    v111 = v51[v92];
                    v278 = v51[v92];
                    v330 = v68;
                    v331 = v68;
                    v328 = v68;
                    v329 = v68;
                    v326 = v68;
                    v327 = v68;
                    v324 = v68;
                    v325 = v68;
                    v322 = v68;
                    v323 = v68;
                    v320 = v68;
                    v321 = v68;
                    v318 = v68;
                    v319 = v68;
                    v316 = v68;
                    v317 = v68;
                    v285 = v111;
                    v112 = &v26[v111];
                    LODWORD(v113) = v92;
                    v114 = *(_QWORD *)&v26[v111];
                    do
                    {
                      v113 = (v113 + 1);
                      v116 = v51[v113];
                      v117 = v112;
                      v118 = *(_QWORD *)&v26[v116] ^ v114;
                      if (!v118)
                      {
                        v119 = &v67[v116];
                        v117 = v112;
                        do
                        {
                          v121 = v117[1];
                          ++v117;
                          v120 = v121;
                          v122 = *(_QWORD *)v119;
                          v119 += 8;
                          v118 = v120 ^ v122;
                        }
                        while (!v118);
                      }
                      v115 = (char *)v117 + (__clz(__rbit64(v118)) >> 3) - v112;
                      if (v115 >= 0x3F)
                        v115 = 63;
                      ++*((_DWORD *)&v316 + v115);
                    }
                    while (v115 > 6);
                    if ((_DWORD)v92)
                    {
                      do
                      {
                        v180 = v51[(v92 - 1)];
                        v181 = v112;
                        v182 = *(_QWORD *)&v26[v180] ^ v114;
                        if (!v182)
                        {
                          v183 = &v67[v180];
                          v181 = v112;
                          do
                          {
                            v185 = v181[1];
                            ++v181;
                            v184 = v185;
                            v186 = *(_QWORD *)v183;
                            v183 += 8;
                            v182 = v184 ^ v186;
                          }
                          while (!v182);
                        }
                        v178 = (char *)v181 + (__clz(__rbit64(v182)) >> 3) - v112;
                        if (v178 >= 0x3F)
                          v178 = 63;
                        ++*((_DWORD *)&v316 + v178);
                        if (v178 > 6)
                          LODWORD(v92) = v92 - 1;
                      }
                      while (v178 >= 7 && (_DWORD)v92 != 0);
                    }
                    v284 = v113;
                    if (HIDWORD(v331) >= v81)
                    {
                      v177 = 63;
                    }
                    else if (DWORD2(v331) + HIDWORD(v331) >= v81)
                    {
                      v177 = 62;
                    }
                    else
                    {
                      v123 = DWORD1(v331) + DWORD2(v331) + HIDWORD(v331);
                      if (v123 >= v81)
                      {
                        v177 = 61;
                      }
                      else
                      {
                        v124 = v331 + v123;
                        if (v124 >= v81)
                        {
                          v177 = 60;
                        }
                        else
                        {
                          v125 = HIDWORD(v330) + v124;
                          if (v125 >= v81)
                          {
                            v177 = 59;
                          }
                          else
                          {
                            v126 = DWORD2(v330) + v125;
                            if (v126 >= v81)
                            {
                              v177 = 58;
                            }
                            else
                            {
                              v127 = DWORD1(v330) + v126;
                              if (v127 >= v81)
                              {
                                v177 = 57;
                              }
                              else
                              {
                                v128 = v330 + v127;
                                if (v128 >= v287)
                                {
                                  v177 = 56;
                                }
                                else
                                {
                                  v129 = HIDWORD(v329) + v128;
                                  if (v129 >= v287)
                                  {
                                    v177 = 55;
                                  }
                                  else
                                  {
                                    v130 = DWORD2(v329) + v129;
                                    if (v130 >= v287)
                                    {
                                      v177 = 54;
                                    }
                                    else
                                    {
                                      v131 = DWORD1(v329) + v130;
                                      if (v131 >= v287)
                                      {
                                        v177 = 53;
                                      }
                                      else
                                      {
                                        v132 = v329 + v131;
                                        if (v132 >= v287)
                                        {
                                          v177 = 52;
                                        }
                                        else
                                        {
                                          v133 = HIDWORD(v328) + v132;
                                          if (v133 >= v287)
                                          {
                                            v177 = 51;
                                          }
                                          else
                                          {
                                            v134 = DWORD2(v328) + v133;
                                            if (v134 >= v287)
                                            {
                                              v177 = 50;
                                            }
                                            else
                                            {
                                              v135 = DWORD1(v328) + v134;
                                              if (v135 >= v287)
                                              {
                                                v177 = 49;
                                              }
                                              else
                                              {
                                                v136 = v328 + v135;
                                                if (v136 >= v287)
                                                {
                                                  v177 = 48;
                                                }
                                                else
                                                {
                                                  v137 = HIDWORD(v327) + v136;
                                                  if (v137 >= v287)
                                                  {
                                                    v177 = 47;
                                                  }
                                                  else
                                                  {
                                                    v138 = DWORD2(v327) + v137;
                                                    if (v138 >= v287)
                                                    {
                                                      v177 = 46;
                                                    }
                                                    else
                                                    {
                                                      v139 = DWORD1(v327) + v138;
                                                      if (v139 >= v287)
                                                      {
                                                        v177 = 45;
                                                      }
                                                      else
                                                      {
                                                        v140 = v327 + v139;
                                                        if (v140 >= v287)
                                                        {
                                                          v177 = 44;
                                                        }
                                                        else
                                                        {
                                                          v141 = HIDWORD(v326) + v140;
                                                          if (v141 >= v287)
                                                          {
                                                            v177 = 43;
                                                          }
                                                          else
                                                          {
                                                            v142 = DWORD2(v326) + v141;
                                                            if (v142 >= v287)
                                                            {
                                                              v177 = 42;
                                                            }
                                                            else
                                                            {
                                                              v143 = DWORD1(v326) + v142;
                                                              if (v143 >= v287)
                                                              {
                                                                v177 = 41;
                                                              }
                                                              else
                                                              {
                                                                v144 = v326 + v143;
                                                                if (v144 >= v287)
                                                                {
                                                                  v177 = 40;
                                                                }
                                                                else
                                                                {
                                                                  v145 = HIDWORD(v325) + v144;
                                                                  if (v145 >= v287)
                                                                  {
                                                                    v177 = 39;
                                                                  }
                                                                  else
                                                                  {
                                                                    v146 = DWORD2(v325) + v145;
                                                                    if (v146 >= v287)
                                                                    {
                                                                      v177 = 38;
                                                                    }
                                                                    else
                                                                    {
                                                                      v147 = DWORD1(v325) + v146;
                                                                      if (v147 >= v287)
                                                                      {
                                                                        v177 = 37;
                                                                      }
                                                                      else
                                                                      {
                                                                        v148 = v325 + v147;
                                                                        if (v148 >= v287)
                                                                        {
                                                                          v177 = 36;
                                                                        }
                                                                        else
                                                                        {
                                                                          v149 = HIDWORD(v324) + v148;
                                                                          if (v149 >= v287)
                                                                          {
                                                                            v177 = 35;
                                                                          }
                                                                          else
                                                                          {
                                                                            v150 = DWORD2(v324) + v149;
                                                                            if (v150 >= v287)
                                                                            {
                                                                              v177 = 34;
                                                                            }
                                                                            else
                                                                            {
                                                                              v151 = DWORD1(v324) + v150;
                                                                              if (v151 >= v287)
                                                                              {
                                                                                v177 = 33;
                                                                              }
                                                                              else
                                                                              {
                                                                                v152 = v324 + v151;
                                                                                if (v152 >= v287)
                                                                                {
                                                                                  v177 = 32;
                                                                                }
                                                                                else
                                                                                {
                                                                                  v153 = HIDWORD(v323) + v152;
                                                                                  if (v153 >= v287)
                                                                                  {
                                                                                    v177 = 31;
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    v154 = DWORD2(v323) + v153;
                                                                                    if (v154 >= v287)
                                                                                    {
                                                                                      v177 = 30;
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      v155 = DWORD1(v323) + v154;
                                                                                      if (v155 >= v287)
                                                                                      {
                                                                                        v177 = 29;
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        v156 = v323 + v155;
                                                                                        if (v156 >= v287)
                                                                                        {
                                                                                          v177 = 28;
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          v157 = HIDWORD(v322) + v156;
                                                                                          if (v157 >= v287)
                                                                                          {
                                                                                            v177 = 27;
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            v158 = DWORD2(v322) + v157;
                                                                                            if (v158 >= v287)
                                                                                            {
                                                                                              v177 = 26;
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              v159 = DWORD1(v322) + v158;
                                                                                              if (v159 >= v287)
                                                                                              {
                                                                                                v177 = 25;
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                v160 = v322 + v159;
                                                                                                if (v160 >= v287)
                                                                                                {
                                                                                                  v177 = 24;
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                  v161 = HIDWORD(v321) + v160;
                                                                                                  if (v161 >= v287)
                                                                                                  {
                                                                                                    v177 = 23;
                                                                                                  }
                                                                                                  else
                                                                                                  {
                                                                                                    v162 = DWORD2(v321) + v161;
                                                                                                    if (v162 >= v287)
                                                                                                    {
                                                                                                      v177 = 22;
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                      v163 = DWORD1(v321) + v162;
                                                                                                      if (v163 >= v287)
                                                                                                      {
                                                                                                        v177 = 21;
                                                                                                      }
                                                                                                      else
                                                                                                      {
                                                                                                        v164 = v321 + v163;
                                                                                                        if (v164 >= v287)
                                                                                                        {
                                                                                                          v177 = 20;
                                                                                                        }
                                                                                                        else
                                                                                                        {
                                                                                                          v165 = HIDWORD(v320) + v164;
                                                                                                          if (v165 >= v287)
                                                                                                          {
                                                                                                            v177 = 19;
                                                                                                          }
                                                                                                          else
                                                                                                          {
                                                                                                            v166 = DWORD2(v320) + v165;
                                                                                                            if (v166 >= v287)
                                                                                                            {
                                                                                                              v177 = 18;
                                                                                                            }
                                                                                                            else
                                                                                                            {
                                                                                                              v167 = DWORD1(v320) + v166;
                                                                                                              if (v167 >= v287)
                                                                                                              {
                                                                                                                v177 = 17;
                                                                                                              }
                                                                                                              else
                                                                                                              {
                                                                                                                v168 = v320 + v167;
                                                                                                                if (v168 >= v287)
                                                                                                                {
                                                                                                                  v177 = 16;
                                                                                                                }
                                                                                                                else
                                                                                                                {
                                                                                                                  v169 = HIDWORD(v319) + v168;
                                                                                                                  if (v169 >= v287)
                                                                                                                  {
                                                                                                                    v177 = 15;
                                                                                                                  }
                                                                                                                  else
                                                                                                                  {
                                                                                                                    v170 = DWORD2(v319) + v169;
                                                                                                                    if (v170 >= v287)
                                                                                                                    {
                                                                                                                      v177 = 14;
                                                                                                                    }
                                                                                                                    else
                                                                                                                    {
                                                                                                                      v171 = DWORD1(v319) + v170;
                                                                                                                      if (v171 >= v287)
                                                                                                                      {
                                                                                                                        v177 = 13;
                                                                                                                      }
                                                                                                                      else
                                                                                                                      {
                                                                                                                        v172 = v319 + v171;
                                                                                                                        if (v172 >= v287)
                                                                                                                        {
                                                                                                                          v177 = 12;
                                                                                                                        }
                                                                                                                        else
                                                                                                                        {
                                                                                                                          v173 = HIDWORD(v318) + v172;
                                                                                                                          if (v173 >= v287)
                                                                                                                          {
                                                                                                                            v177 = 11;
                                                                                                                          }
                                                                                                                          else
                                                                                                                          {
                                                                                                                            v174 = DWORD2(v318) + v173;
                                                                                                                            if (v174 >= v287)
                                                                                                                            {
                                                                                                                              v177 = 10;
                                                                                                                            }
                                                                                                                            else
                                                                                                                            {
                                                                                                                              v175 = DWORD1(v318) + v174;
                                                                                                                              if (v175 >= v287)
                                                                                                                              {
                                                                                                                                v177 = 9;
                                                                                                                              }
                                                                                                                              else
                                                                                                                              {
                                                                                                                                v176 = v318 + v175;
                                                                                                                                if (v176 >= v287)
                                                                                                                                {
                                                                                                                                  v177 = 8;
                                                                                                                                }
                                                                                                                                else if (HIDWORD(v317) + v176 < v287)
                                                                                                                                {
                                                                                                                                  v177 = 6;
                                                                                                                                }
                                                                                                                                else
                                                                                                                                {
                                                                                                                                  v177 = 7;
                                                                                                                                }
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              v45 = v295;
                              v46 = (char *)v296;
                              v67 = v26 + 8;
                              v68 = 0uLL;
                            }
                          }
                        }
                      }
                    }
                    v187 = v26[v285 - 1 + v177];
                    v188 = v177 + 1;
                    do
                    {
                      v189 = v188;
                      v190 = v177;
                      v191 = v26[v285 - 2 + v177--];
                      --v188;
                    }
                    while (v191 == v187);
                    v192 = v177 + 1;
                    if (v177 + 1 >= 7)
                    {
                      DWORD1(v301) = 0;
                      if (v192 >= 7)
                      {
                        v193 = 0;
                        v194 = 7;
                        do
                        {
                          v193 += (v194 - 3) * *((_DWORD *)&v316 + v194);
                          *((_DWORD *)&v300 + v194++) = v193;
                        }
                        while (v189 != v194);
                      }
                      v277 = *((_DWORD *)&v300 + v190);
                      if (v293 > 3)
                      {
                        v195 = v112;
                        fprintf((FILE *)*MEMORY[0x1E0C80C10], "Selected dict at position %u, of length %u : saves %u (ratio: %.2f)  \n", v285, v177 + 1, *((_DWORD *)&v300 + v190), (double)*((unsigned int *)&v300 + v190) / (double)v192);
                        fflush((FILE *)*MEMORY[0x1E0C80C10]);
                        v192 = v177 + 1;
                        v113 = v284;
                        v112 = v195;
                        v67 = v26 + 8;
                      }
                      v196 = v285;
                      if (v92 >= v113)
                      {
LABEL_279:
                        v286 = v278 | (v190 << 32);
                        v206 = ZDICT_tryMerge(v298, v286, v277, 0, (uint64_t)v26);
                        if (v206)
                        {
                          v207 = v206;
                          v208 = ZDICT_tryMerge(v298, *(_QWORD *)&v298[3 * v206], v298[3 * v206 + 2], v206, (uint64_t)v26);
                          if (v208)
                          {
                            v209 = v207;
                            do
                            {
                              v210 = v207;
                              v207 = v208;
                              v211 = *v298 - 1;
                              if (v211 > v210)
                              {
                                v212 = v211 - v209;
                                v213 = &v298[3 * v209];
                                v214 = v213;
                                do
                                {
                                  v215 = *(_QWORD *)(v214 + 3);
                                  v214 += 3;
                                  *(_QWORD *)v213 = v215;
                                  v213[2] = v213[5];
                                  v213 = v214;
                                  --v212;
                                }
                                while (v212);
                                LODWORD(v211) = *v298 - 1;
                              }
                              *v298 = v211;
                              v209 = v208;
                              v208 = ZDICT_tryMerge(v298, *(_QWORD *)&v298[3 * v208], v298[3 * v208 + 2], v208, (uint64_t)v26);
                            }
                            while (v208);
                          }
                        }
                        else
                        {
                          v216 = *v298;
                          if (*v298 >= v280)
                            v216 = v279;
                          v217 = v216 - 1;
                          if (v298[3 * v217 + 2] >= v277)
                          {
                            v218 = v216;
                          }
                          else
                          {
                            v218 = v216;
                            do
                            {
                              v219 = &v298[3 * v217];
                              v220 = &v298[3 * v218];
                              v221 = *(_QWORD *)v219;
                              v220[2] = v219[2];
                              *(_QWORD *)v220 = v221;
                              v217 = v218 - 2;
                              --v218;
                            }
                            while (v298[3 * v217 + 2] < v277);
                          }
                          v222 = &v298[3 * v218];
                          *(_QWORD *)v222 = v286;
                          v222[2] = v277;
                          *v298 = v216 + 1;
                        }
                        v66 = v283 + v177 + 1;
                        LODWORD(a7) = v293;
                        if (v293 < 2)
                        {
                          v45 = v295;
                          v46 = (char *)v296;
                          v43 = v291;
                        }
                        else
                        {
                          v223 = v283 + v177 + 1;
                          v224 = clock();
                          v66 = v223;
                          v45 = v295;
                          v46 = (char *)v296;
                          v43 = v291;
                          v67 = v26 + 8;
                          v68 = 0uLL;
                          if (v224 - v281 < 0x493E1)
                            goto LABEL_74;
                          v281 = clock();
                          fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%4.2f %% \r", (double)v223 / (double)v50 * 100.0);
                          fflush((FILE *)*MEMORY[0x1E0C80C10]);
                          if (v293 >= 4)
                            fflush((FILE *)*MEMORY[0x1E0C80C10]);
                          v45 = v295;
                          v46 = (char *)v296;
                          v66 = v223;
                        }
                        v67 = v26 + 8;
                        v68 = 0uLL;
                        goto LABEL_74;
                      }
                      v92 = v92;
                      while (2)
                      {
                        v197 = v51[v92];
                        v198 = v192;
                        if (v197 == v196)
                        {
                          if (v197 < v192 + (int)v197)
                            goto LABEL_278;
                        }
                        else
                        {
                          LODWORD(v199) = (_DWORD)v112;
                          v200 = *(_QWORD *)v112 ^ *(_QWORD *)&v26[v197];
                          if (!v200)
                          {
                            v201 = &v67[v197];
                            v199 = v112;
                            do
                            {
                              v203 = *((_QWORD *)v199 + 1);
                              v199 += 8;
                              v202 = v203;
                              v204 = *(_QWORD *)v201;
                              v201 += 8;
                              v200 = v202 ^ v204;
                            }
                            while (!v200);
                          }
                          v198 = (_DWORD)v199 + (__clz(__rbit64(v200)) >> 3) - (_DWORD)v112;
                          if (v192 < v198)
                            v198 = v192;
                          if (v197 < v198 + v197)
                          {
LABEL_278:
                            v205 = v112;
                            memset(&v295[v197], 1, v198 - 1 + 1);
                            v113 = v284;
                            v196 = v285;
                            v192 = v177 + 1;
                            v112 = v205;
                            v67 = v26 + 8;
                          }
                        }
                        if (++v92 == v113)
                          goto LABEL_279;
                        continue;
                      }
                    }
                  }
                  else if (v80 > v92)
                  {
                    v100 = &v282[4 * v92];
                    do
                    {
                      v101 = *(int *)v100;
                      v100 += 4;
                      v45[v101] = 1;
                      --v93;
                    }
                    while (v93);
                  }
                }
                ++v66;
                LODWORD(a7) = v293;
                v43 = v291;
              }
LABEL_74:
              v65 = v66;
              if (v50 <= v66)
                goto LABEL_54;
            }
          }
        }
        goto LABEL_54;
      }
    }
    else
    {
      v34 = 0;
      v35 = 0;
    }
    v40 = v14 - v34;
    v41 = (uint64_t *)(a4 + 8 * v34);
    do
    {
      v42 = *v41++;
      v35 += v42;
      --v40;
    }
    while (v40);
    goto LABEL_31;
  }
  return 0;
}

uint64_t ZDICT_trainFromBuffer(void *a1, unint64_t a2, uint64_t a3, int64x2_t *a4, unsigned int a5)
{
  _OWORD v6[2];
  __int128 v7;
  uint64_t v8;

  v7 = 0u;
  v8 = 0;
  memset(v6, 0, sizeof(v6));
  DWORD1(v6[0]) = 8;
  HIDWORD(v6[0]) = 4;
  HIDWORD(v7) = 3;
  return ZDICT_optimizeTrainFromBuffer_fastCover(a1, a2, a3, a4, a5, (uint64_t)v6);
}

unint64_t ZDICT_addEntropyTablesFromBuffer(_DWORD *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int *v9;
  unint64_t result;
  unint64_t v11;

  v9 = (_DWORD *)((char *)a1 + a3 - a2);
  result = ZDICT_analyzeEntropy((uint64_t)(a1 + 2), a3 - 8, 3, a4, a5, a6, (uint64_t)v9, a2, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    v11 = result + 8;
    *a1 = -332356553;
    a1[1] = ZSTD_XXH64(v9, a2) % 0x7FFF8000 + 0x8000;
    if (v11 + a2 >= a3)
    {
      return a3;
    }
    else
    {
      memmove((char *)a1 + v11, v9, a2);
      return v11 + a2;
    }
  }
  return result;
}

unint64_t ZDICT_addEntropyTablesFromBuffer_advanced(_DWORD *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, int a8)
{
  unint64_t v15;
  uint64_t v16;
  FILE **v17;
  unint64_t result;
  unint64_t v19;
  int v20;

  v15 = HIDWORD(a7);
  if ((_DWORD)a7)
    v16 = a7;
  else
    v16 = 3;
  if (HIDWORD(a7) >= 2)
  {
    v17 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "\r%70s\r", "");
    fflush(*v17);
    fwrite("statistics ... \n", 0x10uLL, 1uLL, *v17);
    fflush(*v17);
  }
  result = ZDICT_analyzeEntropy((uint64_t)(a1 + 2), a3 - 8, v16, a4, a5, a6, (uint64_t)a1 + a3 - a2, a2, v15);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    v19 = result + 8;
    *a1 = -332356553;
    v20 = ZSTD_XXH64((_DWORD *)((char *)a1 + a3 - a2), a2) % 0x7FFF8000 + 0x8000;
    if (a8)
      v20 = a8;
    a1[1] = v20;
    if (v19 + a2 >= a3)
    {
      return a3;
    }
    else
    {
      memmove((char *)a1 + v19, (char *)a1 + a3 - a2, a2);
      return v19 + a2;
    }
  }
  return result;
}

uint64_t BIT_initDStream(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v5;

  if (a3)
  {
    *(_QWORD *)(a1 + 24) = a2;
    *(_QWORD *)(a1 + 32) = a2 + 8;
    if (a3 < 8)
    {
      *(_QWORD *)(a1 + 16) = a2;
      v5 = *a2;
      *(_QWORD *)a1 = v5;
      switch(a3)
      {
        case 2uLL:
          goto LABEL_12;
        case 3uLL:
          goto LABEL_11;
        case 4uLL:
          goto LABEL_10;
        case 5uLL:
          goto LABEL_9;
        case 6uLL:
          goto LABEL_8;
        case 7uLL:
          v5 |= (unint64_t)a2[6] << 48;
          *(_QWORD *)a1 = v5;
LABEL_8:
          v5 += (unint64_t)a2[5] << 40;
          *(_QWORD *)a1 = v5;
LABEL_9:
          v5 += (unint64_t)a2[4] << 32;
          *(_QWORD *)a1 = v5;
LABEL_10:
          v5 += (unint64_t)a2[3] << 24;
          *(_QWORD *)a1 = v5;
LABEL_11:
          v5 += (unint64_t)a2[2] << 16;
          *(_QWORD *)a1 = v5;
LABEL_12:
          *(_QWORD *)a1 = v5 + ((unint64_t)a2[1] << 8);
          break;
        default:
          break;
      }
      if (a2[a3 - 1])
      {
        *(_DWORD *)(a1 + 8) = __clz(a2[a3 - 1]) - 8 * a3 + 41;
        return a3;
      }
      else
      {
        *(_DWORD *)(a1 + 8) = 0;
        return -20;
      }
    }
    else
    {
      v3 = *(_QWORD *)&a2[a3 - 8];
      *(_QWORD *)(a1 + 16) = &a2[a3 - 8];
      *(_QWORD *)a1 = v3;
      if (a2[a3 - 1])
      {
        *(_DWORD *)(a1 + 8) = __clz(a2[a3 - 1]) - 23;
        return a3;
      }
      else
      {
        *(_DWORD *)(a1 + 8) = 0;
        return -1;
      }
    }
  }
  else
  {
    *(_QWORD *)(a1 + 32) = 0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    return -72;
  }
}

unint64_t HUF_compressCTable_internal(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  unint64_t v9;
  unint64_t result;
  unint64_t v11;

  v9 = a3 - (_QWORD)a2;
  if (a6)
    result = HUF_compress4X_usingCTable_internal(a2, v9, a4, a5);
  else
    result = HUF_compress1X_usingCTable_internal((uint64_t)a2, v9, a4, a5);
  v11 = (unint64_t)a2 + result - a1;
  if (v11 >= a5 - 1)
    v11 = 0;
  if (!result)
    v11 = 0;
  if (result <= 0xFFFFFFFFFFFFFF88)
    return v11;
  return result;
}

uint64_t ZSTD_estimateSubBlockSize_symbolType(int a1, unsigned int *a2, unsigned int a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, uint64_t a7, char a8, double a9, double a10, double a11, double a12, double a13, double a14, int8x16_t a15, unsigned int a16, char *a17)
{
  unsigned int *v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int *v27;
  int v28;
  char v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  uint64_t v35;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned __int16 *v40;
  _DWORD *v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  char *v47;
  unsigned __int16 *v48;
  __int16 v49;
  int v50;
  int v51;
  unint64_t v52;
  uint64_t v53;
  unsigned __int16 *v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  char *v60;
  unint64_t v61;
  unsigned int *v62;
  unsigned int *v63;
  uint64_t v64;
  unsigned __int8 *v65;
  unint64_t v66;
  uint64_t v67;
  unsigned int v68;
  unsigned int v69;
  unint64_t v70;
  int64x2_t v71;
  int64x2_t v72;
  unint64_t *v73;
  unint64_t v74;
  int64x2_t v75;
  int64x2_t v76;
  unint64_t v77;
  uint32x4_t v78;
  int64x2_t v79;
  int64x2_t v80;
  unint64_t v81;
  int8x16_t *v82;
  int64x2_t v83;
  int64x2_t v84;
  int64x2_t v85;
  int64x2_t v86;
  int64x2_t v87;
  int8x16_t v88;
  uint32x4_t v89;
  uint32x4_t v90;
  uint32x4_t v91;
  uint32x4_t v92;
  unsigned int v93;
  unsigned int v94;

  v24 = (unsigned int *)a17;
  v25 = (unsigned int *)((char *)a2 + a4);
  v94 = a3;
  if ((unint64_t)a4 > 0x5DB)
  {
    if ((a17 & 3) != 0)
    {
      if (a1 == 1)
        goto LABEL_26;
    }
    else
    {
      HIST_count_parallel_wksp(a17, &v94, a2, a4, 0, a17);
      if (a1 == 1)
        goto LABEL_26;
    }
    goto LABEL_10;
  }
  v26 = a3;
  bzero(a17, 4 * (a3 + 1));
  if (!a4)
  {
    v94 = 0;
    if (a1 == 1)
      goto LABEL_26;
LABEL_10:
    if (a1)
    {
      if ((a1 & 0xFFFFFFFE) != 2)
        goto LABEL_26;
      v34 = *a5;
      if (*a5)
        v35 = 1 << (v34 - 1);
      else
        v35 = 1;
      if (v94 <= a5[1])
      {
        v52 = 0;
        v53 = v94 + 1;
        v54 = &a5[2 * v35 + 4];
        do
        {
          v56 = *(_DWORD *)v54;
          v54 += 4;
          v55 = v56;
          v58 = *v24++;
          v57 = v58;
          if (v58)
          {
            v59 = ((HIWORD(v55) + 1) << 8) - ((((HIWORD(v55) + 1) << 24) - ((v55 + (1 << v34)) << 8)) >> v34);
            if (v59 >= (v34 << 8) + 256)
              return 10 * a4;
            v52 += v57 * (unint64_t)v59;
          }
          --v53;
        }
        while (v53);
        v37 = v52 >> 8;
        if (a4 < 1)
          return v37 >> 3;
        goto LABEL_47;
      }
    }
    else if (v94 <= a16)
    {
      v30 = 8 - a8;
      if (v94 + 1 > 1)
        v31 = v94 + 1;
      else
        v31 = 1;
      if (v31 >= 2)
      {
        v38 = 0;
        v39 = 0;
        v32 = v31 & 0xFFFFFFFE;
        v40 = (unsigned __int16 *)(a7 + 2);
        v41 = a17 + 4;
        v42 = v32;
        do
        {
          v43 = *(v40 - 1);
          v45 = *v40;
          v40 += 2;
          v44 = v45;
          if (v43 == 0xFFFF)
            LOWORD(v43) = 1;
          if (v44 == 0xFFFF)
            LOWORD(v44) = 1;
          v38 += (kInverseProbabilityLog256[(__int16)v43 << v30] * *(v41 - 1));
          v39 += (kInverseProbabilityLog256[(__int16)v44 << v30] * *v41);
          v41 += 2;
          v42 -= 2;
        }
        while (v42);
        v33 = v39 + v38;
        if (v32 == v31)
        {
LABEL_39:
          v37 = v33 >> 8;
          if (a4 < 1)
            return v37 >> 3;
          goto LABEL_47;
        }
      }
      else
      {
        v32 = 0;
        v33 = 0;
      }
      v46 = v31 - v32;
      v47 = &a17[4 * v32];
      v48 = (unsigned __int16 *)(a7 + 2 * v32);
      do
      {
        v50 = *v48++;
        v49 = v50;
        if (v50 == 0xFFFF)
          v49 = 1;
        v51 = *(_DWORD *)v47;
        v47 += 4;
        v33 += (kInverseProbabilityLog256[v49 << v30] * v51);
        --v46;
      }
      while (v46);
      goto LABEL_39;
    }
    return 10 * a4;
  }
  v27 = a2;
  do
  {
    v28 = *(unsigned __int8 *)v27;
    v27 = (unsigned int *)((char *)v27 + 1);
    ++*(_DWORD *)&a17[4 * v28];
  }
  while (v27 < v25);
  while (!*(_DWORD *)&a17[4 * v26--])
    ;
  v94 = v26 + 1;
  if (a1 != 1)
    goto LABEL_10;
LABEL_26:
  v37 = 0;
  if (a4 < 1)
    return v37 >> 3;
LABEL_47:
  v60 = (char *)a2 + a4;
  if ((char *)a2 + a4 <= (char *)a2 + 1)
    v60 = (char *)a2 + 1;
  v61 = v60 - (char *)a2;
  if (!a6)
  {
    if (v61 < 8)
    {
      v63 = a2;
      goto LABEL_70;
    }
    if (v61 >= 0x10)
    {
      v70 = v61 & 0xFFFFFFFFFFFFFFF0;
      v79 = 0uLL;
      v80 = (int64x2_t)v37;
      v81 = v61 & 0xFFFFFFFFFFFFFFF0;
      v82 = (int8x16_t *)a2;
      v83 = 0uLL;
      a15 = 0uLL;
      v84 = 0uLL;
      v85 = 0uLL;
      v86 = 0uLL;
      v87 = 0uLL;
      do
      {
        v88 = *v82++;
        v89 = (uint32x4_t)vqtbl1q_s8(v88, (int8x16_t)xmmword_18823D720);
        v90 = (uint32x4_t)vqtbl1q_s8(v88, (int8x16_t)xmmword_18823D710);
        v91 = (uint32x4_t)vqtbl1q_s8(v88, (int8x16_t)xmmword_18823D730);
        v92 = (uint32x4_t)vqtbl1q_s8(v88, (int8x16_t)xmmword_18823D740);
        v79 = (int64x2_t)vaddw_high_u32((uint64x2_t)v79, v90);
        a15 = (int8x16_t)vaddw_high_u32((uint64x2_t)a15, v89);
        v83 = (int64x2_t)vaddw_u32((uint64x2_t)v83, *(uint32x2_t *)v89.i8);
        v80 = (int64x2_t)vaddw_u32((uint64x2_t)v80, *(uint32x2_t *)v90.i8);
        v84 = (int64x2_t)vaddw_u32((uint64x2_t)v84, *(uint32x2_t *)v91.i8);
        v85 = (int64x2_t)vaddw_high_u32((uint64x2_t)v85, v91);
        v86 = (int64x2_t)vaddw_u32((uint64x2_t)v86, *(uint32x2_t *)v92.i8);
        v87 = (int64x2_t)vaddw_high_u32((uint64x2_t)v87, v92);
        v81 -= 16;
      }
      while (v81);
      v37 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v80, v84), vaddq_s64(v83, v86)), vaddq_s64(vaddq_s64(v79, v85), vaddq_s64((int64x2_t)a15, v87))));
      if (v61 == v70)
        return v37 >> 3;
      if ((v61 & 8) == 0)
      {
        v63 = (unsigned int *)((char *)a2 + v70);
        do
        {
LABEL_70:
          v93 = *(unsigned __int8 *)v63;
          v63 = (unsigned int *)((char *)v63 + 1);
          v37 += v93;
        }
        while (v63 < v25);
        return v37 >> 3;
      }
    }
    else
    {
      v70 = 0;
    }
    v63 = (unsigned int *)((char *)a2 + (v61 & 0xFFFFFFFFFFFFFFF8));
    v71 = 0uLL;
    v72 = (int64x2_t)v37;
    v73 = (unint64_t *)((char *)a2 + v70);
    v74 = v70 - (v61 & 0xFFFFFFFFFFFFFFF8);
    v75 = 0uLL;
    v76 = 0uLL;
    do
    {
      v77 = *v73++;
      a15.i64[0] = v77;
      v78 = (uint32x4_t)vqtbl1q_s8(a15, (int8x16_t)xmmword_18823D720);
      a15 = vqtbl1q_s8(a15, (int8x16_t)xmmword_18823D710);
      v76 = (int64x2_t)vaddw_high_u32((uint64x2_t)v76, v78);
      v71 = (int64x2_t)vaddw_high_u32((uint64x2_t)v71, (uint32x4_t)a15);
      v75 = (int64x2_t)vaddw_u32((uint64x2_t)v75, *(uint32x2_t *)v78.i8);
      v72 = (int64x2_t)vaddw_u32((uint64x2_t)v72, *(uint32x2_t *)a15.i8);
      v74 += 8;
    }
    while (v74);
    v37 = vaddvq_s64(vaddq_s64(vaddq_s64(v72, v75), vaddq_s64(v71, v76)));
    if (v61 == (v61 & 0xFFFFFFFFFFFFFFF8))
      return v37 >> 3;
    goto LABEL_70;
  }
  if (v61 >= 2)
  {
    v64 = 0;
    v62 = (unsigned int *)((char *)a2 + (v61 & 0xFFFFFFFFFFFFFFFELL));
    v65 = (unsigned __int8 *)a2 + 1;
    v66 = v61 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v67 = *(v65 - 1);
      v68 = *v65;
      v65 += 2;
      v37 += *(unsigned int *)(a6 + 4 * v67);
      v64 += *(unsigned int *)(a6 + 4 * v68);
      v66 -= 2;
    }
    while (v66);
    v37 += v64;
    if (v61 == (v61 & 0xFFFFFFFFFFFFFFFELL))
      return v37 >> 3;
  }
  else
  {
    v62 = a2;
  }
  do
  {
    v69 = *(unsigned __int8 *)v62;
    v62 = (unsigned int *)((char *)v62 + 1);
    v37 += *(unsigned int *)(a6 + 4 * v69);
  }
  while (v62 < v25);
  return v37 >> 3;
}

uint64_t ZSTD_resetCCtx_internal(uint64_t a1, __int128 *a2, unint64_t a3, int a4, int a5)
{
  unsigned int v9;
  __int128 *v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t v25;
  _BOOL4 v26;
  unsigned int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  size_t matched;
  _BYTE *v40;
  char *v41;
  size_t v42;
  _BOOL4 v43;
  _OWORD *v44;
  int v45;
  char *v46;
  unsigned int v47;
  _BYTE *v48;
  _DWORD *v49;
  unsigned int v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  _BYTE *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  _DWORD *v65;
  unint64_t v66;
  void (*v67)(uint64_t);
  uint64_t v68;
  uint64_t (*v69)(_QWORD, size_t);
  char *v70;
  size_t v71;
  void *v72;
  unsigned int v73;
  uint64_t v74;
  _BYTE *v75;
  int v76;
  _DWORD *v77;
  _OWORD *v78;
  int v79;
  _BYTE *v80;
  unsigned int v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unsigned int v89;
  size_t v90;
  unsigned int v91;
  unint64_t v92;
  unint64_t v93;
  void *v94;
  unsigned int v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  char *v101;
  _OWORD *v102;
  int v103;
  __int128 *v104;
  uint64_t v105;

  *(_DWORD *)(a1 + 624) = 1;
  v10 = (__int128 *)((char *)a2 + 4);
  v9 = *((_DWORD *)a2 + 1);
  v11 = *((_DWORD *)a2 + 24);
  if (!v11)
    goto LABEL_10;
  *((_DWORD *)a2 + 29) = v9;
  if (*((_DWORD *)a2 + 27))
  {
    v12 = *((_DWORD *)a2 + 25);
    if (v12)
      goto LABEL_4;
LABEL_77:
    v12 = v9 - 7;
    if (v9 - 7 <= 6)
      v12 = 6;
    *((_DWORD *)a2 + 25) = v12;
    v13 = *((_DWORD *)a2 + 26);
    if (*((_DWORD *)a2 + 28))
      goto LABEL_5;
    goto LABEL_80;
  }
  *((_DWORD *)a2 + 27) = 64;
  v12 = *((_DWORD *)a2 + 25);
  if (!v12)
    goto LABEL_77;
LABEL_4:
  v13 = *((_DWORD *)a2 + 26);
  if (!*((_DWORD *)a2 + 28))
  {
LABEL_80:
    v50 = v9 - v12;
    if (v9 < v12)
      v50 = 0;
    *((_DWORD *)a2 + 28) = v50;
  }
LABEL_5:
  if (!v13)
    v13 = 3;
  if (v13 < v12)
    v12 = v13;
  *((_DWORD *)a2 + 26) = v12;
LABEL_10:
  if (1 << v9 >= a3)
    v14 = a3;
  else
    v14 = 1 << v9;
  if (a3)
    v15 = v14;
  else
    v15 = 1;
  if (v15 >= 0x20000)
    v16 = 0x20000;
  else
    v16 = v15;
  v17 = *((_DWORD *)a2 + 5);
  if (v17 == 3)
    v18 = 3;
  else
    v18 = 4;
  if (a5 == 1)
  {
    v19 = (0x20000 - v16) >> 11;
    if (v15 >= 0x20000)
      v19 = 0;
    v20 = v16 + (v16 >> 8) + v19;
    if (*((_DWORD *)a2 + 32))
      v21 = 0;
    else
      v21 = v20 + 1;
    v22 = v16 + v15;
    if (*((_DWORD *)a2 + 31))
      v23 = 0;
    else
      v23 = v22;
  }
  else
  {
    v21 = 0;
    v23 = 0;
  }
  v24 = *((_DWORD *)a2 + 27);
  if (v11)
    v25 = v16 / v24;
  else
    v25 = 0;
  v26 = *(_QWORD *)(a1 + 2888) - *(_QWORD *)(a1 + 2896) <= 0xDF000000uLL && *(_DWORD *)(a1 + 628) != 0;
  if (v14 >= 0x20000)
    v14 = 0x20000;
  if (!a3)
    v14 = 1;
  v27 = *((_DWORD *)a2 + 7);
  if (v27 != 1)
  {
    v28 = 4 << *((_DWORD *)a2 + 2);
    v29 = *((_DWORD *)a2 + 3);
    if (v17 != 3)
      goto LABEL_44;
LABEL_53:
    if (v27 <= 6)
      v30 = 0;
    else
      v30 = 149000;
    v31 = (4 << v29) + v28;
    if (v9 <= 0x11)
    {
      if (!v9)
        goto LABEL_48;
      v32 = 4 << v9;
      v33 = *(_QWORD *)(a1 + 584);
      if (v11)
        goto LABEL_49;
    }
    else
    {
      v32 = 0x80000;
      v33 = *(_QWORD *)(a1 + 584);
      if (v11)
        goto LABEL_49;
    }
LABEL_58:
    v36 = 0;
    v37 = 0;
    goto LABEL_59;
  }
  v28 = 0;
  v29 = *((_DWORD *)a2 + 3);
  if (v17 == 3)
    goto LABEL_53;
LABEL_44:
  if (v27 <= 6)
    v30 = 0;
  else
    v30 = 149000;
  v31 = (4 << v29) + v28;
LABEL_48:
  v32 = 0;
  v33 = *(_QWORD *)(a1 + 584);
  if (!v11)
    goto LABEL_58;
LABEL_49:
  v34 = *((_DWORD *)a2 + 25);
  v35 = *((_DWORD *)a2 + 26);
  if (v35 >= v34)
    LOBYTE(v35) = *((_DWORD *)a2 + 25);
  v36 = (1 << (v34 - v35)) + (8 << v34);
  v37 = 12 * (v14 / v24);
LABEL_59:
  v38 = 19128;
  if (!v33)
    v38 = 15800;
  matched = v14 + v21 + v23 + v38 + v31 + v30 + v32 + v36 + v37 + 11 * (v14 / v18) + 32;
  if (matched <= 0xFFFFFFFFFFFFFF88)
  {
    v105 = v25;
    if (!v33)
      ++*(_DWORD *)(a1 + 420);
    v40 = *(_BYTE **)(a1 + 368);
    v41 = *(char **)(a1 + 376);
    v42 = v41 - v40;
    if (*(_QWORD *)(a1 + 408) - *(_QWORD *)(a1 + 392) >= 3 * matched)
    {
      v43 = *(_DWORD *)(a1 + 420) > 128;
      v44 = (_OWORD *)(a1 + 368);
      if (v42 < matched)
        goto LABEL_74;
    }
    else
    {
      v43 = 0;
      v44 = (_OWORD *)(a1 + 368);
      if (v42 < matched)
        goto LABEL_74;
    }
    if (!v43)
    {
      v45 = !v26;
      v46 = *(char **)(a1 + 384);
      v47 = *(_DWORD *)(a1 + 424);
      *(_QWORD *)(a1 + 392) = v46;
      *(_QWORD *)(a1 + 408) = v41;
      v48 = (_BYTE *)(a1 + 416);
      *(_BYTE *)(a1 + 416) = 0;
      v49 = (_DWORD *)(a1 + 424);
      if (v47 >= 2)
        *(_DWORD *)(a1 + 424) = 1;
      goto LABEL_83;
    }
LABEL_74:
    if (v33)
      return -64;
    v67 = *(void (**)(uint64_t))(a1 + 560);
    v68 = *(_QWORD *)(a1 + 568);
    *v44 = 0u;
    v44[1] = 0u;
    v44[2] = 0u;
    v44[3] = 0u;
    v103 = a4;
    v102 = v44;
    if (v40)
    {
      if (!v67)
      {
        free(v40);
        v69 = *(uint64_t (**)(_QWORD, size_t))(a1 + 552);
        if (v69)
        {
LABEL_103:
          v70 = (char *)v69(*(_QWORD *)(a1 + 568), matched);
          if (!v70)
            return -64;
LABEL_165:
          v41 = &v70[matched];
          *(_QWORD *)(a1 + 368) = v70;
          *(_QWORD *)(a1 + 376) = &v70[matched];
          *(_QWORD *)(a1 + 424) = 0;
          *(_QWORD *)(a1 + 384) = v70;
          *(_QWORD *)(a1 + 392) = v70;
          *(_QWORD *)(a1 + 400) = v70;
          *(_QWORD *)(a1 + 408) = &v70[matched];
          *(_BYTE *)(a1 + 416) = 0;
          *(_DWORD *)(a1 + 420) = 0;
          if ((uint64_t)matched <= 4591)
          {
            *(_BYTE *)(a1 + 416) = 1;
            *(_QWORD *)(a1 + 2872) = 0;
            return -64;
          }
          *(_QWORD *)(a1 + 384) = v70 + 4592;
          *(_QWORD *)(a1 + 392) = v70 + 4592;
          *(_QWORD *)(a1 + 400) = v70 + 4592;
          *(_QWORD *)(a1 + 2872) = v70;
          if (matched >> 5 <= 0x11E)
          {
            *(_BYTE *)(a1 + 416) = 1;
            *(_QWORD *)(a1 + 2880) = 0;
            return -64;
          }
          v49 = (_DWORD *)(a1 + 424);
          v48 = (_BYTE *)(a1 + 416);
          v101 = v70 + 9184;
          *(_QWORD *)(a1 + 384) = v70 + 9184;
          *(_QWORD *)(a1 + 400) = v70 + 9184;
          *(_QWORD *)(a1 + 2880) = v70 + 4592;
          a4 = v103;
          v44 = v102;
          if (matched >> 3 >= 0x7B7)
          {
            v46 = v70 + 15800;
            *(_QWORD *)(a1 + 384) = v70 + 15800;
            *(_QWORD *)(a1 + 400) = v70 + 15800;
          }
          else
          {
            v46 = v70 + 9184;
            v101 = 0;
          }
          *(_QWORD *)(a1 + 3120) = v101;
          *(_QWORD *)(a1 + 392) = v46;
          *(_QWORD *)(a1 + 408) = v41;
          v45 = 1;
          *(_BYTE *)(a1 + 416) = 0;
LABEL_83:
          v51 = *a2;
          v52 = a2[1];
          *(_OWORD *)(a1 + 216) = a2[2];
          *(_OWORD *)(a1 + 200) = v52;
          *(_OWORD *)(a1 + 184) = v51;
          v53 = a2[3];
          v54 = a2[4];
          v55 = a2[6];
          *(_OWORD *)(a1 + 264) = a2[5];
          *(_OWORD *)(a1 + 280) = v55;
          *(_OWORD *)(a1 + 248) = v54;
          *(_OWORD *)(a1 + 232) = v53;
          v56 = a2[7];
          v57 = a2[8];
          v58 = a2[9];
          *(_QWORD *)(a1 + 344) = *((_QWORD *)a2 + 20);
          *(_OWORD *)(a1 + 312) = v57;
          *(_OWORD *)(a1 + 328) = v58;
          *(_OWORD *)(a1 + 296) = v56;
          v59 = *v10;
          *(_OWORD *)(a1 + 3092) = *(__int128 *)((char *)v10 + 12);
          *(_OWORD *)(a1 + 3080) = v59;
          *(_QWORD *)(a1 + 448) = 0;
          *(_QWORD *)(a1 + 456) = 0;
          *(_QWORD *)(a1 + 440) = a3 + 1;
          if (a3 == -1)
            *(_DWORD *)(a1 + 216) = 0;
          *(_QWORD *)(a1 + 432) = v16;
          *(_OWORD *)(a1 + 464) = xmmword_18823D7B0;
          *(_OWORD *)(a1 + 480) = xmmword_18823D7C0;
          *(_QWORD *)(a1 + 496) = 0x61C8864E7A143579;
          *(_OWORD *)(a1 + 536) = 0u;
          *(_OWORD *)(a1 + 520) = 0u;
          *(_OWORD *)(a1 + 504) = 0u;
          *(_DWORD *)a1 = 1;
          *(_DWORD *)(a1 + 352) = 0;
          *(_QWORD *)(a1 + 360) = 0;
          v60 = *(_QWORD *)(a1 + 2872);
          *(_QWORD *)(v60 + 4580) = 0x400000001;
          *(_DWORD *)(v60 + 4588) = 8;
          *(_DWORD *)(v60 + 1024) = 0;
          *(_QWORD *)(v60 + 4568) = 0;
          *(_DWORD *)(v60 + 4576) = 0;
          v61 = v48;
          if (*(_DWORD *)(a1 + 424))
          {
            v62 = (unint64_t)&v41[-v16 - 32];
            if (v62 < (unint64_t)v46)
              goto LABEL_87;
          }
          else
          {
            *(_QWORD *)(a1 + 400) = v46;
            *(_DWORD *)(a1 + 424) = 1;
            v62 = (unint64_t)&v41[-v16 - 32];
            if (v62 < (unint64_t)v46)
            {
LABEL_87:
              *v48 = 1;
              v62 = (unint64_t)v41;
              *(_QWORD *)(a1 + 648) = 0;
              *(_QWORD *)(a1 + 696) = v16;
              *(_DWORD *)(a1 + 3128) = a5;
              *(_QWORD *)(a1 + 3144) = v23;
              v63 = v16 / v18;
              if (v23)
                goto LABEL_88;
              goto LABEL_95;
            }
          }
          if (v62 < *(_QWORD *)(a1 + 400))
            *(_QWORD *)(a1 + 400) = v62;
          *(_QWORD *)(a1 + 408) = v62;
          *(_QWORD *)(a1 + 648) = v62;
          *(_QWORD *)(a1 + 696) = v16;
          *(_DWORD *)(a1 + 3128) = a5;
          *(_QWORD *)(a1 + 3144) = v23;
          v63 = v16 / v18;
          if (v23)
          {
LABEL_88:
            v64 = v62 - v23;
            if (v62 - v23 >= (unint64_t)v46)
            {
              v65 = v49;
              if (v64 < *(_QWORD *)(a1 + 400))
                *(_QWORD *)(a1 + 400) = v64;
              *(_QWORD *)(a1 + 408) = v64;
              *(_QWORD *)(a1 + 3136) = v64;
              *(_QWORD *)(a1 + 3184) = v21;
              if (!v21)
              {
LABEL_108:
                v66 = v64;
                *(_QWORD *)(a1 + 3176) = 0;
                if (!*((_DWORD *)a2 + 24))
                  goto LABEL_119;
                goto LABEL_113;
              }
            }
            else
            {
              *v61 = 1;
              v64 = v62;
              v65 = v49;
              *(_QWORD *)(a1 + 3136) = 0;
              *(_QWORD *)(a1 + 3184) = v21;
              if (!v21)
                goto LABEL_108;
            }
LABEL_96:
            v66 = v64 - v21;
            if (v64 - v21 >= (unint64_t)v46)
            {
              if (v66 < *(_QWORD *)(a1 + 400))
                *(_QWORD *)(a1 + 400) = v66;
              *(_QWORD *)(a1 + 408) = v66;
              *(_QWORD *)(a1 + 3176) = v66;
              if (!*((_DWORD *)a2 + 24))
              {
LABEL_119:
                if (!*(_DWORD *)(a1 + 280))
                {
                  *(_QWORD *)(a1 + 2864) = 0;
                  *(_OWORD *)(a1 + 2848) = 0u;
                  *(_OWORD *)(a1 + 2832) = 0u;
                  *(_QWORD *)(a1 + 688) = v63;
                  v81 = *(_DWORD *)(a1 + 424);
                  if (v81)
                  {
LABEL_121:
                    v82 = *(_QWORD *)(a1 + 392);
                    v83 = *(_QWORD *)(a1 + 408);
                    if (v18 > v16)
                      goto LABEL_122;
                    goto LABEL_130;
                  }
LABEL_129:
                  *(_QWORD *)(a1 + 400) = *(_QWORD *)(a1 + 384);
                  v81 = 1;
                  *(_DWORD *)(a1 + 424) = 1;
                  v82 = *(_QWORD *)(a1 + 392);
                  v83 = *(_QWORD *)(a1 + 408);
                  if (v18 > v16)
                  {
LABEL_122:
                    *(_QWORD *)(a1 + 672) = 0;
                    *(_QWORD *)(a1 + 664) = 0;
                    v84 = a1 + 2888;
                    *(_QWORD *)(a1 + 680) = 0;
                    if (v81 <= 1)
                      goto LABEL_123;
LABEL_147:
                    if (v18 <= v16)
                    {
LABEL_126:
                      v86 = v83 - 8 * v63;
                      if (v86 >= v82)
                      {
                        if (v86 < *(_QWORD *)(a1 + 400))
                          *(_QWORD *)(a1 + 400) = v86;
                        *(_QWORD *)(a1 + 408) = v86;
                      }
                      else
                      {
                        v86 = 0;
                        *v61 = 1;
                      }
LABEL_149:
                      *(_QWORD *)(a1 + 632) = v86;
                      matched = ZSTD_reset_matchState(v84, (uint64_t)v44, v10, a4, v45, 1);
                      if (matched > 0xFFFFFFFFFFFFFF88)
                        return matched;
                      if (!*((_DWORD *)a2 + 24))
                      {
LABEL_186:
                        matched = 0;
                        *(_DWORD *)(a1 + 628) = 1;
                        return matched;
                      }
                      v89 = *((_DWORD *)a2 + 25);
                      v90 = 8 << v89;
                      v91 = *(_DWORD *)(a1 + 424);
                      if (v91 >= 2)
                      {
                        v93 = *(_QWORD *)(a1 + 408);
                        if (v89 > 0x3C)
                          goto LABEL_177;
                      }
                      else
                      {
                        if (v91)
                        {
                          v92 = *(_QWORD *)(a1 + 400);
                        }
                        else
                        {
                          v92 = *(_QWORD *)(a1 + 384);
                          *(_QWORD *)(a1 + 400) = v92;
                        }
                        v93 = *(_QWORD *)(a1 + 408) & 0xFFFFFFFFFFFFFFFCLL;
                        *(_QWORD *)(a1 + 408) = v93;
                        if (v93 < v92)
                          *(_QWORD *)(a1 + 400) = v93;
                        *v65 = 2;
                        if (v89 > 0x3C)
                        {
LABEL_177:
                          *(_QWORD *)(a1 + 744) = 0;
                          bzero(0, v90);
                          v95 = *(_DWORD *)(a1 + 424);
                          if (v95 < 2)
                            goto LABEL_178;
                          goto LABEL_157;
                        }
                      }
                      v94 = (void *)(v93 - v90);
                      if (v93 - v90 >= *(_QWORD *)(a1 + 392))
                      {
                        if ((unint64_t)v94 < *(_QWORD *)(a1 + 400))
                          *(_QWORD *)(a1 + 400) = v94;
                        *(_QWORD *)(a1 + 408) = v94;
                        *(_QWORD *)(a1 + 744) = v94;
                        bzero(v94, v90);
                        v95 = *(_DWORD *)(a1 + 424);
                        if (v95 < 2)
                        {
LABEL_178:
                          v97 = v105;
                          if (v95)
                          {
                            v99 = *(_QWORD *)(a1 + 400);
                          }
                          else
                          {
                            v99 = *(_QWORD *)(a1 + 384);
                            *(_QWORD *)(a1 + 400) = v99;
                          }
                          v96 = *(_QWORD *)(a1 + 408) & 0xFFFFFFFFFFFFFFFCLL;
                          *(_QWORD *)(a1 + 408) = v96;
                          if (v96 < v99)
                            *(_QWORD *)(a1 + 400) = v96;
                          *v65 = 2;
                          if (!v105)
                            goto LABEL_184;
                          goto LABEL_158;
                        }
                      }
                      else
                      {
                        *v61 = 1;
                        *(_QWORD *)(a1 + 744) = 0;
                        bzero(0, v90);
                        v95 = *(_DWORD *)(a1 + 424);
                        if (v95 < 2)
                          goto LABEL_178;
                      }
LABEL_157:
                      v96 = *(_QWORD *)(a1 + 408);
                      v97 = v105;
                      if (!v105)
                      {
LABEL_184:
                        v98 = 0;
LABEL_185:
                        *(_QWORD *)(a1 + 2816) = v98;
                        *(_QWORD *)(a1 + 2824) = v97;
                        *(_QWORD *)(a1 + 720) = "";
                        *(_QWORD *)(a1 + 728) = "";
                        *(_QWORD *)(a1 + 712) = "Mnum_stages";
                        *(_QWORD *)(a1 + 736) = 0x100000001;
                        *(_DWORD *)(a1 + 752) = 0;
                        goto LABEL_186;
                      }
LABEL_158:
                      v98 = v96 - 12 * v97;
                      if (v98 >= *(_QWORD *)(a1 + 392))
                      {
                        if (v98 < *(_QWORD *)(a1 + 400))
                          *(_QWORD *)(a1 + 400) = v98;
                        *(_QWORD *)(a1 + 408) = v98;
                      }
                      else
                      {
                        v98 = 0;
                        *v61 = 1;
                      }
                      goto LABEL_185;
                    }
LABEL_148:
                    v86 = 0;
                    goto LABEL_149;
                  }
LABEL_130:
                  v87 = v83 - v63;
                  if (v83 - v63 >= v82)
                  {
                    if (v87 < *(_QWORD *)(a1 + 400))
                      *(_QWORD *)(a1 + 400) = v87;
                    *(_QWORD *)(a1 + 408) = v87;
                    *(_QWORD *)(a1 + 664) = v87;
                    v88 = v87 - v63;
                    if (v87 - v63 >= v82)
                    {
                      if (v88 < *(_QWORD *)(a1 + 400))
                        *(_QWORD *)(a1 + 400) = v88;
                      *(_QWORD *)(a1 + 408) = v88;
                      *(_QWORD *)(a1 + 672) = v88;
                      v83 = v88 - v63;
                      if (v88 - v63 < v82)
                      {
LABEL_146:
                        *v61 = 1;
                        v83 = v88;
                        v84 = a1 + 2888;
                        *(_QWORD *)(a1 + 680) = 0;
                        if (v81 > 1)
                          goto LABEL_147;
                        goto LABEL_123;
                      }
LABEL_135:
                      if (v83 < *(_QWORD *)(a1 + 400))
                        *(_QWORD *)(a1 + 400) = v83;
                      *(_QWORD *)(a1 + 408) = v83;
                      v84 = a1 + 2888;
                      *(_QWORD *)(a1 + 680) = v83;
                      if (v81 > 1)
                        goto LABEL_147;
LABEL_123:
                      v85 = *(_QWORD *)(a1 + 400);
                      v83 &= 0xFFFFFFFFFFFFFFFCLL;
                      *(_QWORD *)(a1 + 408) = v83;
                      if (v83 < v85)
                        *(_QWORD *)(a1 + 400) = v83;
                      *v65 = 2;
                      if (v18 <= v16)
                        goto LABEL_126;
                      goto LABEL_148;
                    }
                  }
                  else
                  {
                    *v61 = 1;
                    v87 = v83;
                    *(_QWORD *)(a1 + 664) = 0;
                  }
                  *v61 = 1;
                  v88 = v87;
                  *(_QWORD *)(a1 + 672) = 0;
                  v83 = v87 - v63;
                  if (v87 - v63 < v82)
                    goto LABEL_146;
                  goto LABEL_135;
                }
LABEL_120:
                *(_QWORD *)(a1 + 688) = v63;
                v81 = *(_DWORD *)(a1 + 424);
                if (v81)
                  goto LABEL_121;
                goto LABEL_129;
              }
            }
            else
            {
              *v61 = 1;
              v66 = v64;
              *(_QWORD *)(a1 + 3176) = 0;
              if (!*((_DWORD *)a2 + 24))
                goto LABEL_119;
            }
LABEL_113:
            v104 = v10;
            v71 = 1 << (*((_BYTE *)a2 + 100) - *((_BYTE *)a2 + 104));
            v72 = (void *)(v66 - v71);
            v73 = v18;
            if (v66 - v71 >= (unint64_t)v46)
            {
              v80 = v61;
              v77 = v65;
              if ((unint64_t)v72 < *(_QWORD *)(a1 + 400))
                *(_QWORD *)(a1 + 400) = v72;
              v74 = v63;
              v76 = v45;
              v78 = v44;
              v79 = a4;
              *(_QWORD *)(a1 + 408) = v72;
            }
            else
            {
              v74 = v63;
              v75 = v61;
              v76 = v45;
              v77 = v65;
              v78 = v44;
              v79 = a4;
              v72 = 0;
              v80 = v75;
              *v75 = 1;
            }
            *(_QWORD *)(a1 + 760) = v72;
            bzero(v72, v71);
            a4 = v79;
            v44 = v78;
            v65 = v77;
            v45 = v76;
            v61 = v80;
            v63 = v74;
            v18 = v73;
            v10 = v104;
            if (*(_DWORD *)a1 != 1)
              goto LABEL_120;
            goto LABEL_119;
          }
LABEL_95:
          v64 = v62;
          v65 = v49;
          *(_QWORD *)(a1 + 3136) = 0;
          *(_QWORD *)(a1 + 3184) = v21;
          if (!v21)
            goto LABEL_108;
          goto LABEL_96;
        }
LABEL_164:
        v70 = (char *)malloc_type_malloc(matched, 0x26AA08A0uLL);
        if (!v70)
          return -64;
        goto LABEL_165;
      }
      v67(v68);
    }
    v69 = *(uint64_t (**)(_QWORD, size_t))(a1 + 552);
    if (v69)
      goto LABEL_103;
    goto LABEL_164;
  }
  return matched;
}

uint64_t ZSTD_reset_matchState(uint64_t a1, uint64_t a2, __int128 *a3, int a4, int a5, int a6)
{
  uint64_t v10;
  int v11;
  int v12;
  const char *v13;
  const char *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t v27;
  void *v28;
  unsigned int v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  __int128 v38;

  if (*((_DWORD *)a3 + 6) == 1)
  {
    v10 = 0;
    v11 = *((_DWORD *)a3 + 2);
    if (a6 != 1)
      goto LABEL_10;
  }
  else
  {
    v11 = *((_DWORD *)a3 + 2);
    v10 = 4 << *((_DWORD *)a3 + 1);
    if (a6 != 1)
      goto LABEL_10;
  }
  if (*((_DWORD *)a3 + 4) == 3)
  {
    v12 = *(_DWORD *)a3;
    if (*(_DWORD *)a3 >= 0x11u)
      v12 = 17;
    if (a5 == 1)
      goto LABEL_11;
LABEL_9:
    v14 = *(const char **)a1;
    v13 = *(const char **)(a1 + 8);
    v15 = *(_QWORD *)(a2 + 16);
    goto LABEL_12;
  }
LABEL_10:
  v12 = 0;
  if (a5 != 1)
    goto LABEL_9;
LABEL_11:
  v13 = "";
  *(_QWORD *)(a1 + 8) = "";
  *(_QWORD *)(a1 + 16) = "";
  v14 = "Mnum_stages";
  *(_QWORD *)a1 = "Mnum_stages";
  v15 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 32) = v15;
LABEL_12:
  *(_DWORD *)(a1 + 40) = v12;
  *(int32x4_t *)(a1 + 24) = vzip1q_s32((int32x4_t)((_DWORD)v14 - (_DWORD)v13), vdupq_lane_s32((int32x2_t)((_DWORD)v14 - (_DWORD)v13), 0));
  *(_DWORD *)(a1 + 132) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a2 + 24) = v15;
  v16 = v15 + (4 << v11);
  v17 = *(_QWORD *)(a2 + 40);
  v18 = *(_DWORD *)(a2 + 56);
  v19 = v17;
  if (v18 > 1)
    goto LABEL_17;
  if (!v18)
  {
    v19 = v17 & 0xFFFFFFFFFFFFFFFCLL;
    *(_QWORD *)(a2 + 32) = v15;
    *(_QWORD *)(a2 + 40) = v17 & 0xFFFFFFFFFFFFFFFCLL;
    if ((v17 & 0xFFFFFFFFFFFFFFFCLL) >= v15)
      goto LABEL_16;
    goto LABEL_15;
  }
  v20 = *(_QWORD *)(a2 + 32);
  v19 = v17 & 0xFFFFFFFFFFFFFFFCLL;
  *(_QWORD *)(a2 + 40) = v17 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v17 & 0xFFFFFFFFFFFFFFFCLL) < v20)
LABEL_15:
    *(_QWORD *)(a2 + 32) = v19;
LABEL_16:
  *(_DWORD *)(a2 + 56) = 2;
LABEL_17:
  if (v16 <= v17)
  {
    *(_QWORD *)(a2 + 24) = v16;
    v21 = 4 << v12;
    *(_QWORD *)(a1 + 48) = v15;
    v22 = v16 + v10;
    if (v16 + v10 <= v19)
    {
LABEL_19:
      *(_QWORD *)(a2 + 24) = v22;
      *(_QWORD *)(a1 + 64) = v16;
      if (v12)
        v23 = v21;
      else
        v23 = 0;
      v24 = v22 + v23;
      if (v24 <= v19)
        goto LABEL_23;
LABEL_30:
      *(_BYTE *)(a2 + 48) = 1;
      *(_QWORD *)(a1 + 56) = 0;
      return -64;
    }
  }
  else
  {
    *(_BYTE *)(a2 + 48) = 1;
    v16 = v15;
    v21 = 4 << v12;
    *(_QWORD *)(a1 + 48) = 0;
    v22 = v15 + v10;
    if (v22 <= v19)
      goto LABEL_19;
  }
  *(_BYTE *)(a2 + 48) = 1;
  v22 = v16;
  *(_QWORD *)(a1 + 64) = 0;
  if (v12)
    v27 = v21;
  else
    v27 = 0;
  v24 = v16 + v27;
  if (v24 > v19)
    goto LABEL_30;
LABEL_23:
  *(_QWORD *)(a2 + 24) = v24;
  v25 = *(unsigned __int8 *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = v22;
  if (v25)
    return -64;
  if (a4 != 1)
  {
    v28 = *(void **)(a2 + 32);
    if ((unint64_t)v28 < v24)
    {
      bzero(v28, v24 - (_QWORD)v28);
      v24 = *(_QWORD *)(a2 + 24);
      v28 = *(void **)(a2 + 32);
    }
    if ((unint64_t)v28 < v24)
      *(_QWORD *)(a2 + 32) = v24;
  }
  if (a6 != 1 || *((_DWORD *)a3 + 6) < 7u)
    goto LABEL_73;
  v29 = *(_DWORD *)(a2 + 56);
  if (v29 >= 2)
  {
    v31 = *(_QWORD *)(a2 + 40);
    v32 = v31 - 1024;
    if (v31 - 1024 < v24)
      goto LABEL_66;
  }
  else
  {
    if (v29)
    {
      v30 = *(_QWORD *)(a2 + 32);
    }
    else
    {
      v30 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 32) = v30;
    }
    v31 = *(_QWORD *)(a2 + 40) & 0xFFFFFFFFFFFFFFFCLL;
    *(_QWORD *)(a2 + 40) = v31;
    if (v31 < v30)
      *(_QWORD *)(a2 + 32) = v31;
    *(_DWORD *)(a2 + 56) = 2;
    v32 = v31 - 1024;
    if (v31 - 1024 < v24)
    {
LABEL_66:
      *(_BYTE *)(a2 + 48) = 1;
      v32 = v31;
      *(_QWORD *)(a1 + 80) = 0;
      v33 = v31 - 144;
      if (v33 < v24)
        goto LABEL_67;
      goto LABEL_47;
    }
  }
  if (v32 < *(_QWORD *)(a2 + 32))
    *(_QWORD *)(a2 + 32) = v32;
  *(_QWORD *)(a2 + 40) = v32;
  *(_QWORD *)(a1 + 80) = v32;
  v33 = v32 - 144;
  if (v32 - 144 < v24)
  {
LABEL_67:
    *(_BYTE *)(a2 + 48) = 1;
    v33 = v32;
    *(_QWORD *)(a1 + 88) = 0;
    v34 = v32 - 212;
    if (v32 - 212 < v24)
      goto LABEL_68;
    goto LABEL_50;
  }
LABEL_47:
  if (v33 < *(_QWORD *)(a2 + 32))
    *(_QWORD *)(a2 + 32) = v33;
  *(_QWORD *)(a2 + 40) = v33;
  *(_QWORD *)(a1 + 88) = v33;
  v34 = v33 - 212;
  if (v33 - 212 < v24)
  {
LABEL_68:
    *(_BYTE *)(a2 + 48) = 1;
    v34 = v33;
    *(_QWORD *)(a1 + 96) = 0;
    v35 = v33 - 128;
    if (v33 - 128 < v24)
      goto LABEL_69;
    goto LABEL_53;
  }
LABEL_50:
  if (v34 < *(_QWORD *)(a2 + 32))
    *(_QWORD *)(a2 + 32) = v34;
  *(_QWORD *)(a2 + 40) = v34;
  *(_QWORD *)(a1 + 96) = v34;
  v35 = v34 - 128;
  if (v34 - 128 < v24)
  {
LABEL_69:
    *(_BYTE *)(a2 + 48) = 1;
    v35 = v34;
    *(_QWORD *)(a1 + 104) = 0;
    v36 = v34 - 32776;
    if (v34 - 32776 < v24)
      goto LABEL_70;
LABEL_56:
    if (v36 < *(_QWORD *)(a2 + 32))
      *(_QWORD *)(a2 + 32) = v36;
    *(_QWORD *)(a2 + 40) = v36;
    *(_QWORD *)(a1 + 112) = v36;
    v37 = v36 - 114716;
    if (v36 - 114716 < v24)
      goto LABEL_71;
LABEL_59:
    if (v37 < *(_QWORD *)(a2 + 32))
      *(_QWORD *)(a2 + 32) = v37;
    *(_QWORD *)(a2 + 40) = v37;
    goto LABEL_72;
  }
LABEL_53:
  if (v35 < *(_QWORD *)(a2 + 32))
    *(_QWORD *)(a2 + 32) = v35;
  *(_QWORD *)(a2 + 40) = v35;
  *(_QWORD *)(a1 + 104) = v35;
  v36 = v35 - 32776;
  if (v35 - 32776 >= v24)
    goto LABEL_56;
LABEL_70:
  *(_BYTE *)(a2 + 48) = 1;
  *(_QWORD *)(a1 + 112) = 0;
  v37 = v35 - 114716;
  if (v37 >= v24)
    goto LABEL_59;
LABEL_71:
  v37 = 0;
  *(_BYTE *)(a2 + 48) = 1;
LABEL_72:
  *(_QWORD *)(a1 + 120) = v37;
LABEL_73:
  v38 = *a3;
  *(_OWORD *)(a1 + 204) = *(__int128 *)((char *)a3 + 12);
  *(_OWORD *)(a1 + 192) = v38;
  if (*(_BYTE *)(a2 + 48))
    return -64;
  else
    return 0;
}

uint32x4_t *ZSTD_overflowCorrectIfNeeded(uint32x4_t *result, _QWORD *a2, _DWORD *a3, int a4, int a5)
{
  uint64_t v5;
  uint32x4_t *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int32x2_t v12;
  int32x2_t v13;
  int8x8_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int8x16_t v19;
  int32x4_t *v20;
  int32x4_t v21;
  uint32x4_t v22;
  uint32x4_t v23;
  __int32 v24;
  unint64_t v25;
  unsigned int v26;
  BOOL v27;
  __int32 v28;

  v5 = result->i64[1];
  if ((a5 - v5) >= 0xE0000001)
  {
    v8 = result;
    v9 = 1 << (a3[2] - (a3[7] > 5u));
    if (((v9 - 1) & (a4 - (_DWORD)v5)) != 0)
      v9 = (v9 - 1) & (a4 - v5);
    v10 = ((-1 << a3[1]) + a4 - v5 - v9);
    v11 = result[1].i64[0] + v10;
    result->i64[1] = v5 + v10;
    result[1].i64[0] = v11;
    v12 = vdup_n_s32(v10);
    v13 = (int32x2_t)result[1].u64[1];
    v14 = (int8x8_t)vcgt_u32((uint32x2_t)v13, (uint32x2_t)v12);
    result[1].u64[1] = (unint64_t)vsub_s32((int32x2_t)vand_s8((int8x8_t)vsub_s32(v13, v12), v14), (int32x2_t)vmvn_s8(v14));
    a2[4] = a2[2];
    result = ZSTD_reduceTable((uint32x4_t *)result[3].i64[0], 1 << a3[3], v10);
    v15 = a3[7];
    if (v15 != 1)
    {
      v16 = 1 << a3[2];
      result = (uint32x4_t *)v8[4].i64[0];
      if (v15 == 6)
      {
        v17 = v16 + 15;
        if (v16 >= 0)
          v17 = 1 << a3[2];
        if (v16 >= 16)
        {
          v18 = v17 >> 4;
          v19 = (int8x16_t)vdupq_n_s32(v10);
          v20 = (int32x4_t *)&result[2];
          v21.i64[0] = 0x100000001;
          v21.i64[1] = 0x100000001;
          do
          {
            v22 = vqsubq_u32((uint32x4_t)vaddq_s32((int32x4_t)vandq_s8(v19, (int8x16_t)vceqq_s32(v20[-1], v21)), v20[-1]), (uint32x4_t)v19);
            v20[-2] = (int32x4_t)vqsubq_u32((uint32x4_t)vaddq_s32((int32x4_t)vandq_s8(v19, (int8x16_t)vceqq_s32(v20[-2], v21)), v20[-2]), (uint32x4_t)v19);
            v20[-1] = (int32x4_t)v22;
            v23 = vqsubq_u32((uint32x4_t)vaddq_s32((int32x4_t)vandq_s8(v19, (int8x16_t)vceqq_s32(v20[1], v21)), v20[1]), (uint32x4_t)v19);
            *(uint32x4_t *)v20 = vqsubq_u32((uint32x4_t)vaddq_s32((int32x4_t)vandq_s8(v19, (int8x16_t)vceqq_s32(*v20, v21)), *v20), (uint32x4_t)v19);
            v20[1] = (int32x4_t)v23;
            v20 += 4;
            --v18;
          }
          while (v18);
        }
      }
      else
      {
        result = ZSTD_reduceTable(result, v16, v10);
      }
    }
    v24 = v8[2].i32[2];
    if (v24)
      result = ZSTD_reduceTable((uint32x4_t *)v8[3].i64[1], 1 << v24, v10);
    v25 = a2[3];
    if (a2[4] < v25)
      a2[4] = v25;
    v26 = v8[2].u32[1];
    v27 = v26 >= v10;
    v28 = v26 - v10;
    if (!v27)
      v28 = 0;
    v8[2].i32[0] = 0;
    v8[2].i32[1] = v28;
    v8[11].i64[1] = 0;
  }
  return result;
}

uint64_t ZSTD_compressBlock_internal(uint64_t a1, _BYTE *a2, unint64_t a3, _QWORD *a4, unint64_t a5, int a6)
{
  unint64_t v12;
  int v13;
  uint64_t v14;
  int8x16_t *v15;
  uint64_t v16;
  unint64_t v17;

  v12 = ZSTD_buildSeqStore((int32x2_t *)a1, (unint64_t)a4, a5);
  v13 = 4 * (v12 == 1);
  if (v12 >= 0xFFFFFFFFFFFFFF89)
    v13 = 1;
  if (v13 == 4)
  {
    v14 = 0;
  }
  else
  {
    v14 = v12;
    if (v13)
      return v14;
    v15 = (int8x16_t *)(a1 + 2872);
    if (*(_DWORD *)(a1 + 592))
    {
      ZSTD_copyBlockSequences(a1);
      v14 = 0;
      *v15 = vextq_s8(*v15, *v15, 8uLL);
      return v14;
    }
    v17 = ZSTD_entropyCompressSequences(a1 + 632, *(unsigned __int16 **)(a1 + 2872), *(char **)(a1 + 2880), (_DWORD *)(a1 + 184), (uint64_t)a2, a3, a5, *(uint32x4_t **)(a1 + 3120));
    if (*(_DWORD *)(a1 + 592))
    {
      ZSTD_copyBlockSequences(a1);
      return 0;
    }
    v14 = v17;
    if (a6 && !*(_DWORD *)(a1 + 624) && v17 <= 0x18 && ZSTD_isRLE(a4, a5))
    {
      *a2 = *(_BYTE *)a4;
      v14 = 1;
    }
    else if ((unint64_t)(v14 - 2) <= 0xFFFFFFFFFFFFFF86)
    {
      *v15 = vextq_s8(*v15, *v15, 8uLL);
    }
  }
  v16 = *(_QWORD *)(a1 + 2872);
  if (*(_DWORD *)(v16 + 4568) == 2)
    *(_DWORD *)(v16 + 4568) = 1;
  return v14;
}

uint32x4_t *ZSTD_reduceTable(uint32x4_t *result, int a2, unsigned int a3)
{
  int v3;
  int v4;
  uint32x4_t v5;
  uint32x4_t *v6;
  uint32x4_t v7;
  uint32x4_t v8;

  v3 = a2 + 15;
  if (a2 >= 0)
    v3 = a2;
  if (a2 >= 16)
  {
    v4 = v3 >> 4;
    v5 = (uint32x4_t)vdupq_n_s32(a3);
    v6 = result + 2;
    do
    {
      v7 = vqsubq_u32(v6[-1], v5);
      v6[-2] = vqsubq_u32(v6[-2], v5);
      v6[-1] = v7;
      v8 = vqsubq_u32(v6[1], v5);
      *v6 = vqsubq_u32(*v6, v5);
      v6[1] = v8;
      v6 += 4;
      --v4;
    }
    while (v4);
  }
  return result;
}

unint64_t ZSTD_buildSeqStore(int32x2_t *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unsigned int v5;
  int32x2_t v6;
  int32x2_t v7;
  int32x2_t v8;
  uint64_t v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  _DWORD *v14;
  unsigned int v15;
  __int32 v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  uint64_t v23;
  unint64_t result;
  int32x2_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  BOOL v30;
  _DWORD *v31;
  _QWORD *v32;
  int32x2_t *v33;
  size_t v34;
  uint64_t (*v35)(int32x2_t *, int32x2_t *, _QWORD *, unint64_t, unint64_t);
  size_t v36;
  int32x2_t v37;
  _QWORD v38[5];

  v3 = a3;
  if (a3 > 6)
  {
    a1[82] = a1[81];
    a1[80] = a1[79];
    a1[88].i32[0] = 0;
    v14 = (_DWORD *)a1[359];
    a1[382] = (int32x2_t)v14;
    a1[383].i32[0] = a1[32].i32[0];
    v15 = a2 - a1[362].i32[0];
    v16 = a1[365].i32[1];
    if (v16 + 384 < v15)
    {
      v17 = v15 - v16 - 384;
      if (v17 >= 0xC0)
        v17 = 192;
      a1[365].i32[1] = v15 - v17;
    }
    if (a1[364].i32[1] >= (unsigned __int32)a1[364].i32[0])
    {
      v18 = (uint64_t)a1[384];
      if (v18)
      {
        v30 = *(_DWORD *)(v18 + 72) == 0;
        v18 = 2;
        if (!v30)
          v18 = 3;
      }
    }
    else
    {
      v18 = 1;
    }
    v31 = (_DWORD *)a1[360];
    v32 = v31 + 1145;
    v31[1145] = v14[1145];
    v31[1146] = v14[1146];
    v31[1147] = v14[1147];
    if (*(_QWORD *)&a1[355] >= *(_QWORD *)&a1[357])
    {
      if (!a1[35].i32[0])
      {
        v35 = (uint64_t (*)(int32x2_t *, int32x2_t *, _QWORD *, unint64_t, unint64_t))*(&ZSTD_selectBlockCompressor_blockCompressor[10 * v18] + a1[26].i32[1]);
        a1[389] = 0;
        v34 = v35(a1 + 361, a1 + 79, v32, a2, a3);
        goto LABEL_40;
      }
      v38[0] = a1[352];
      memset(&v38[1], 0, 24);
      v38[4] = a1[353];
      result = ZSTD_ldm_generateSequences(a1 + 89, v38, &a1[35], a2, a3);
      if (result > 0xFFFFFFFFFFFFFF88)
        return result;
      v32 = (_QWORD *)(*(_QWORD *)&a1[360] + 4580);
      v33 = (int32x2_t *)v38;
    }
    else
    {
      v33 = a1 + 354;
    }
    v34 = ZSTD_ldm_blockCompress((uint64_t)v33, (uint64_t)&a1[361], (uint64_t)&a1[79], v32, a2, v3);
LABEL_40:
    v36 = v34;
    memcpy(*(void **)&a1[82], (const void *)(a2 + v3 - v34), v34);
    result = 0;
    *(_QWORD *)&a1[82] += v36;
    return result;
  }
  if (a1[26].i32[1] >= 7u)
  {
    v5 = a1[356].i32[0] + a3;
    if (v5)
    {
      v6 = a1[357];
      v7 = a1[355];
      if (*(_QWORD *)&v7 <= *(_QWORD *)&v6)
        v8 = a1[357];
      else
        v8 = a1[355];
      v9 = 12 * *(_QWORD *)&v7;
      while (1)
      {
        if (*(_QWORD *)&v8 == *(_QWORD *)&v7)
        {
          if (*(_QWORD *)&v8 != *(_QWORD *)&v6)
            return 1;
          goto LABEL_44;
        }
        v10 = *(_DWORD *)(*(_QWORD *)&a1[354] + v9 + 8) + *(_DWORD *)(*(_QWORD *)&a1[354] + v9 + 4);
        v11 = v5 >= v10;
        v12 = v5 - v10;
        if (!v11)
          break;
        ++*(_QWORD *)&v7;
        a1[355] = v7;
        v9 += 12;
        v5 = v12;
        if (!v12)
          goto LABEL_44;
      }
      a1[356] = (int32x2_t)v5;
      if (*(_QWORD *)&v7 != *(_QWORD *)&v6)
        return 1;
    }
LABEL_44:
    a1[356] = 0;
    return 1;
  }
  if (!a3)
    return 1;
  v19 = a1[25].u32[1];
  v20 = a1[357];
  v21 = a1[355];
  if (*(_QWORD *)&v21 <= *(_QWORD *)&v20)
    v22 = a1[357];
  else
    v22 = a1[355];
  v23 = 12 * *(_QWORD *)&v21;
  result = 1;
  while (*(_QWORD *)&v22 != *(_QWORD *)&v21)
  {
    v25 = a1[354];
    v26 = *(_QWORD *)&v25 + v23;
    v27 = *(unsigned int *)(*(_QWORD *)&v25 + v23 + 4);
    v28 = v3 - v27;
    if (v3 <= v27)
    {
      *(_DWORD *)(v26 + 4) = v27 - v3;
      return 1;
    }
    *(_DWORD *)(v26 + 4) = 0;
    v29 = *(unsigned int *)(v26 + 8);
    v3 = v28 - v29;
    if (v28 < v29)
    {
      *(_DWORD *)(*(_QWORD *)&v25 + v23 + 8) = v29 - v28;
      if ((int)v29 - (int)v28 < v19)
      {
        v37 = (int32x2_t)(*(_QWORD *)&v21 + 1);
        if (*(_QWORD *)&v37 < *(_QWORD *)&v20)
          *(_DWORD *)(*(_QWORD *)&v25 + v23 + 16) += v29 - v28;
        a1[355] = v37;
      }
      return 1;
    }
    *(_DWORD *)(v26 + 8) = 0;
    ++*(_QWORD *)&v21;
    a1[355] = v21;
    v23 += 12;
    if (v28 == v29)
      return result;
  }
  return result;
}

uint64_t ZSTD_isRLE(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  char *v3;
  char *v4;
  _DWORD *v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t v11;
  unint64_t v12;
  _QWORD *i;

  if (a2 == 1)
    return 1;
  v2 = a2 & 0x1F;
  if ((a2 & 0x1F) == 0)
  {
LABEL_21:
    if (a2 < 0x20)
      return 1;
    v11 = 0x101010101010101 * *(unsigned __int8 *)a1;
    v12 = a2 & 0xFFFFFFFFFFFFFFE0;
    for (i = (_QWORD *)((char *)a1 + v2 + 16); *(i - 2) == v11 && *(i - 1) == v11 && *i == v11 && i[1] == v11; i += 4)
    {
      v12 -= 32;
      if (!v12)
        return 1;
    }
    return 0;
  }
  v3 = (char *)a1 + v2;
  v4 = (char *)a1 + 1;
  v5 = a1;
  if (v2 < 9)
  {
LABEL_13:
    if (v4 >= v3 - 3)
    {
      if (v4 >= v3 - 1)
        goto LABEL_17;
    }
    else
    {
      if (*v5 == *(_DWORD *)v4)
      {
        v4 += 4;
        ++v5;
      }
      if (v4 >= v3 - 1)
      {
LABEL_17:
        if (v4 >= v3)
          goto LABEL_20;
        goto LABEL_18;
      }
    }
    if (*(unsigned __int16 *)v5 == *(unsigned __int16 *)v4)
    {
      v4 += 2;
      v5 = (_DWORD *)((char *)v5 + 2);
    }
    if (v4 >= v3)
    {
LABEL_20:
      if (v4 - ((char *)a1 + 1) != v2 - 1)
        return 0;
      goto LABEL_21;
    }
LABEL_18:
    if (*(unsigned __int8 *)v5 == *v4)
      ++v4;
    goto LABEL_20;
  }
  v6 = *(_QWORD *)((char *)a1 + 1) ^ *a1;
  if (!v6)
  {
    v7 = 0;
    do
    {
      v8 = &a1[v7];
      v4 = (char *)&a1[v7 + 1] + 1;
      if (v4 >= v3 - 7)
      {
        v5 = v8 + 1;
        goto LABEL_13;
      }
      ++v7;
      v9 = *(_QWORD *)v4 ^ v8[1];
    }
    while (!v9);
    if (v7 * 8 + (__clz(__rbit64(v9)) >> 3) == v2 - 1)
      goto LABEL_21;
    return 0;
  }
  if (__clz(__rbit64(v6)) >> 3 == v2 - 1)
    goto LABEL_21;
  return 0;
}

uint64_t ZSTD_copyBlockSequences(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int *v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  int v32;

  v1 = *(_QWORD *)(result + 632);
  v2 = *(_QWORD *)(result + 640);
  v3 = *(_QWORD *)(result + 656);
  v4 = *(_QWORD *)(result + 648);
  v5 = *(_QWORD *)(result + 608);
  v6 = *(_QWORD *)(result + 2872);
  v7 = *(_QWORD *)(result + 600) + 16 * v5;
  v31 = *(_QWORD *)(v6 + 4580);
  v32 = *(_DWORD *)(v6 + 4588);
  v9 = v2 - v1;
  v8 = v9 == 0;
  v10 = v9 >> 3;
  v11 = 0;
  if (!v8)
  {
    v12 = *(unsigned int *)(result + 708);
    if (v10 <= 1)
      v13 = 1;
    else
      v13 = v10;
    v14 = v7 + 8;
    v15 = (unsigned __int16 *)(v1 + 6);
    v16 = v13;
    while (1)
    {
      v22 = *(_DWORD *)(v15 - 3);
      v23 = *(v15 - 1);
      *(_DWORD *)(v14 - 4) = v23;
      v24 = *v15;
      *(_QWORD *)v14 = (v24 + 3);
      if (v12)
        goto LABEL_10;
      v27 = *(_DWORD *)(result + 704);
      if (v27 == 2)
        break;
      v25 = v23;
      if (v27 == 1)
      {
        v25 = v23 | 0x10000;
        *(_DWORD *)(v14 - 4) = v23 | 0x10000;
      }
LABEL_11:
      if (v22 >= 4)
      {
        *(_DWORD *)(v14 - 8) = v22 - 3;
        v17 = v22 - 1;
LABEL_7:
        v18 = v31;
        v19 = v17 - 2;
        v20 = (int *)&v31 + 1;
        goto LABEL_8;
      }
      *(_DWORD *)(v14 + 4) = v22;
      if (v25)
      {
        v26 = v22 - 1;
        *(_DWORD *)(v14 - 8) = *((_DWORD *)&v31 + v22 - 1);
        if (v22 - 1 >= 3)
          goto LABEL_35;
      }
      else
      {
        if (v22 == 3)
        {
          *(_DWORD *)(v14 - 8) = v31 - 1;
          if (v23)
            v26 = 2;
          else
            v26 = 3;
LABEL_17:
          if (v26 == 3)
          {
            v18 = v31;
            v19 = v31 - 1;
          }
          else
          {
            v19 = *((_DWORD *)&v31 + v26);
            v18 = v31;
          }
          if (v26 <= 1)
            v28 = 8;
          else
            v28 = 4;
          v20 = (int *)((char *)&v31 + v28);
          goto LABEL_8;
        }
        v26 = v22 - 1;
        *(_DWORD *)(v14 - 8) = *((_DWORD *)&v31 + v22);
        if (v22 - 1 >= 3)
        {
LABEL_35:
          v17 = -1;
          goto LABEL_7;
        }
      }
      if (!v23)
        ++v26;
      if (v26)
        goto LABEL_17;
      v19 = v31;
      v18 = HIDWORD(v31);
      v20 = &v32;
LABEL_8:
      v15 += 4;
      v21 = *v20;
      v31 = v19 | (unint64_t)(v18 << 32);
      v32 = v21;
      v11 += v25;
      --v12;
      v14 += 16;
      if (!--v16)
        goto LABEL_37;
    }
    *(_DWORD *)v14 = v24 + 65539;
LABEL_10:
    v25 = v23;
    goto LABEL_11;
  }
  v13 = 0;
LABEL_37:
  v29 = v3 - (v11 + v4);
  v30 = v7 + 16 * v13;
  *(_DWORD *)v30 = 0;
  *(_DWORD *)(v30 + 4) = v29;
  *(_QWORD *)(v30 + 8) = 0;
  *(_QWORD *)(result + 608) = v10 + v5 + 1;
  return result;
}

unint64_t ZSTD_entropyCompressSequences(uint64_t a1, unsigned __int16 *__src, char *__dst, _DWORD *a4, uint64_t a5, unint64_t a6, unint64_t a7, uint32x4_t *a8)
{
  unsigned int v13;
  char *v14;
  int v15;
  _BOOL4 v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t result;
  unint64_t v21;
  char *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unsigned __int16 *v31;
  _BYTE *v32;
  _BYTE *v33;
  _BYTE *v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  unsigned int *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  unint64_t v44;
  uint32x4_t *v45;
  uint64_t v46;
  uint32x4_t v47;
  uint32x4_t v48;
  uint64_t v49;
  unsigned int *v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  unint64_t v54;
  char *v56;
  uint64_t v57;
  char *v58;
  unsigned int *v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  char *v63;
  char *v64;
  uint64_t v65;
  unsigned int v66;
  unint64_t v67;
  unsigned __int16 *v68;
  unsigned int v69;
  uint32x4_t *v70;
  uint64_t v71;
  uint32x4_t v72;
  uint32x4_t v73;
  uint64_t v74;
  unsigned int *v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  char *v79;
  char *v80;
  unsigned int *v81;
  unint64_t v82;
  int v83;
  uint64_t v84;
  unsigned __int16 *v85;
  uint64_t v86;
  unsigned int v87;
  unint64_t v88;
  unsigned __int16 *v89;
  unsigned int v90;
  uint32x4_t *v91;
  uint64_t v92;
  uint32x4_t v93;
  uint32x4_t v94;
  uint64_t v95;
  unsigned int *v96;
  unsigned int v97;
  unsigned int v98;
  const void *v99;
  int v100;
  char *v101;
  unint64_t v102;
  unint64_t *v103;
  unsigned int v104;
  char v105;
  char *v106;
  uint64_t v107;
  char v108;
  uint64_t v109;
  unint64_t v110;
  unsigned __int16 *__dsta;
  unsigned __int16 *v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  char *v116;
  unsigned __int16 *v117;
  char *v118;
  _BOOL4 v119;
  unsigned int *v120;
  unsigned int *v121;
  uint64_t v123;
  unsigned int *v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127[3];

  v119 = a4[1] > 0x39u;
  v13 = a4[7];
  v14 = &a8[13].i8[4];
  v15 = a4[18];
  if (v15 == 1)
    goto LABEL_6;
  if (v15 == 2)
  {
    v16 = 1;
    goto LABEL_7;
  }
  if (v13 != 1)
LABEL_6:
    v16 = 0;
  else
    v16 = a4[6] != 0;
LABEL_7:
  v17 = *(_QWORD *)(a1 + 8);
  v123 = *(_QWORD *)a1;
  v124 = *(unsigned int **)(a1 + 32);
  v120 = *(unsigned int **)(a1 + 40);
  v121 = *(unsigned int **)(a1 + 48);
  v18 = a6;
  v19 = a5;
  result = ZSTD_compressLiterals(__src, __dst, v13, v16, a5, a6, *(unsigned int **)(a1 + 16), *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16), v14, 0x1904uLL);
  if (result > 0xFFFFFFFFFFFFFF88)
    goto LABEL_111;
  v116 = __dst;
  v117 = __src;
  v118 = v14;
  v21 = v19 + v18;
  v22 = (char *)(v19 + result);
  v23 = v18;
  if ((uint64_t)(v18 - result) < 4)
  {
    if (a7 <= v18)
      return 0;
    else
      return -70;
  }
  v24 = v17 - v123;
  v25 = (v17 - v123) >> 3;
  if ((unint64_t)(v17 - v123) > 0x3FF)
  {
    if (v24 >> 11 > 0x7E)
    {
      *v22 = -1;
      *(_WORD *)(v22 + 1) = (v24 >> 3) - 32512;
      v26 = v22 + 3;
      if (v17 == v123)
        goto LABEL_39;
    }
    else
    {
      *v22 = BYTE1(v25) ^ 0x80;
      v22[1] = v24 >> 3;
      v26 = v22 + 2;
      if (v17 == v123)
        goto LABEL_39;
    }
LABEL_14:
    v28 = *(_QWORD *)(a1 + 32);
    v27 = *(_QWORD *)(a1 + 40);
    v29 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
    if ((v29 & 0x7FFFFFFF8) != 0)
    {
      v30 = (v29 >> 3);
      v31 = (unsigned __int16 *)(*(_QWORD *)a1 + 6);
      v32 = *(_BYTE **)(a1 + 48);
      v33 = *(_BYTE **)(a1 + 32);
      v34 = *(_BYTE **)(a1 + 40);
      do
      {
        while (1)
        {
          v35 = *(v31 - 1);
          if (v35 < 0x40)
            LOBYTE(v36) = ZSTD_LLcode_LL_Code[*(v31 - 1)];
          else
            v36 = 50 - __clz(v35);
          v37 = *v31;
          *v33 = v36;
          *v32 = __clz(*(_DWORD *)(v31 - 3)) ^ 0x1F;
          if (v37 >= 0x80)
            break;
          v31 += 4;
          *v34++ = ZSTD_MLcode_ML_Code[v37];
          ++v32;
          ++v33;
          if (!--v30)
            goto LABEL_22;
        }
        v31 += 4;
        *v34++ = 67 - __clz(v37);
        ++v32;
        ++v33;
        --v30;
      }
      while (v30);
    }
LABEL_22:
    v112 = (unsigned __int16 *)(v116 + 1028);
    v38 = *(_DWORD *)(a1 + 72);
    if (v38 == 1)
    {
      *(_BYTE *)(v28 + *(unsigned int *)(a1 + 76)) = 35;
      v38 = *(_DWORD *)(a1 + 72);
    }
    __dsta = (unsigned __int16 *)(v116 + 3252);
    if (v38 == 2)
      *(_BYTE *)(v27 + *(unsigned int *)(a1 + 76)) = 52;
    v127[0] = 35;
    v110 = v24 >> 5;
    v114 = a7;
    v115 = v23;
    v107 = v19;
    v113 = v21;
    if (v24 >> 5 > 0x176)
    {
      if ((v118 & 3) != 0)
      {
        v44 = -1;
        LODWORD(v41) = 35;
      }
      else
      {
        v44 = HIST_count_parallel_wksp(a8, v127, v124, v25, 0, v118);
        LODWORD(v41) = v127[0];
      }
      goto LABEL_51;
    }
    a8[7] = 0u;
    a8[8] = 0u;
    v39 = v124;
    a8[5] = 0u;
    a8[6] = 0u;
    a8[3] = 0u;
    a8[4] = 0u;
    a8[1] = 0u;
    a8[2] = 0u;
    *a8 = 0u;
    do
    {
      v40 = *(unsigned __int8 *)v39;
      v39 = (unsigned int *)((char *)v39 + 1);
      ++a8->i32[v40];
    }
    while (v39 < (unsigned int *)((char *)v124 + v25));
    LODWORD(v41) = 36;
    do
      v41 = (v41 - 1);
    while (!a8->i32[v41]);
    if (v41 >= 7)
    {
      v42 = (v41 + 1) & 0x1FFFFFFF8;
      v45 = a8 + 1;
      v46 = v42;
      v47 = 0uLL;
      v48 = 0uLL;
      do
      {
        v47 = vmaxq_u32(v45[-1], v47);
        v48 = vmaxq_u32(*v45, v48);
        v45 += 2;
        v46 -= 8;
      }
      while (v46);
      v43 = vmaxvq_u32(vmaxq_u32(v47, v48));
      if (v41 + 1 == v42)
      {
LABEL_49:
        v44 = v43;
LABEL_51:
        *((_DWORD *)v116 + 1144) = *((_DWORD *)__src + 1144);
        v53 = ZSTD_selectEncodingType((_DWORD *)v116 + 1144, (unsigned int *)a8, v41, v44, v25, 9u, __src + 1626, (uint64_t)LL_defaultNorm, 6, 1, v13);
        result = ZSTD_buildCTable(v26 + 1, v113 - (_QWORD)(v26 + 1), __dsta, 9u, v53, (unsigned int *)a8, v41, v124, v25, LL_defaultNorm, 6, 35, __src + 1626, 0x524uLL, v118, 0x1904uLL);
        if (result >= 0xFFFFFFFFFFFFFF89)
          v54 = 0;
        else
          v54 = result;
        v108 = v53;
        if (result < 0xFFFFFFFFFFFFFF89 && v53 == 2)
          v56 = v26 + 1;
        else
          v56 = 0;
        v57 = (v17 - v123) >> 3;
        v18 = v115;
        if (result > 0xFFFFFFFFFFFFFF88)
          goto LABEL_111;
        v109 = (v17 - v123) >> 3;
        v58 = &v26[v54 + 1];
        v126 = 31;
        if (v110 > 0x176)
        {
          v64 = v56;
          if ((v118 & 3) != 0)
          {
            v67 = -1;
            LODWORD(v62) = 31;
            v63 = v116;
            v68 = v117;
            v69 = v13;
            v60 = v109;
            goto LABEL_80;
          }
          v60 = v109;
          v67 = HIST_count_parallel_wksp(a8, &v126, v121, v109, 0, v118);
          LODWORD(v62) = v126;
          v63 = v116;
          v68 = v117;
LABEL_79:
          v69 = v13;
LABEL_80:
          *((_DWORD *)v63 + 1142) = *((_DWORD *)v68 + 1142);
          v78 = ZSTD_selectEncodingType((_DWORD *)v63 + 1142, (unsigned int *)a8, v62, v67, v60, 8u, v117 + 514, (uint64_t)OF_defaultNorm, 5, v62 < 0x1D, v69);
          result = ZSTD_buildCTable(v58, v113 - (_QWORD)v58, v112, 8u, v78, (unsigned int *)a8, v62, v121, v60, OF_defaultNorm, 5, 28, v117 + 514, 0x304uLL, v118, 0x1904uLL);
          v18 = v115;
          if (result > 0xFFFFFFFFFFFFFF88)
            goto LABEL_111;
          v79 = &v58[result];
          if (v78 == 2)
            v80 = v58;
          else
            v80 = v64;
          v125 = 52;
          v106 = v80;
          if (v110 > 0x176)
          {
            if ((v118 & 3) != 0)
            {
              v88 = -1;
              LODWORD(v84) = 52;
              v89 = v117;
              v90 = v13;
              v82 = v109;
            }
            else
            {
              v82 = v109;
              v88 = HIST_count_parallel_wksp(a8, &v125, v120, v109, 0, v118);
              LODWORD(v84) = v125;
              v89 = v117;
              v90 = v13;
            }
            v85 = (unsigned __int16 *)(v63 + 1800);
            goto LABEL_103;
          }
          v81 = v120;
          v82 = v109;
          a8[13].i32[0] = 0;
          a8[11] = 0u;
          a8[12] = 0u;
          a8[9] = 0u;
          a8[10] = 0u;
          a8[7] = 0u;
          a8[8] = 0u;
          a8[5] = 0u;
          a8[6] = 0u;
          a8[3] = 0u;
          a8[4] = 0u;
          a8[1] = 0u;
          a8[2] = 0u;
          *a8 = 0u;
          do
          {
            v83 = *(unsigned __int8 *)v81;
            v81 = (unsigned int *)((char *)v81 + 1);
            ++a8->i32[v83];
          }
          while (v81 < (unsigned int *)((char *)v120 + v109));
          LODWORD(v84) = 53;
          v85 = (unsigned __int16 *)(v63 + 1800);
          do
            v84 = (v84 - 1);
          while (!a8->i32[v84]);
          if (v84 >= 7)
          {
            v86 = (v84 + 1) & 0x1FFFFFFF8;
            v91 = a8 + 1;
            v92 = v86;
            v93 = 0uLL;
            v94 = 0uLL;
            do
            {
              v93 = vmaxq_u32(v91[-1], v93);
              v94 = vmaxq_u32(*v91, v94);
              v91 += 2;
              v92 -= 8;
            }
            while (v92);
            v87 = vmaxvq_u32(vmaxq_u32(v93, v94));
            if (v84 + 1 == v86)
            {
LABEL_100:
              v88 = v87;
              v89 = v117;
              v90 = v13;
LABEL_103:
              *((_DWORD *)v63 + 1143) = *((_DWORD *)v89 + 1143);
              v99 = v89 + 900;
              v100 = ZSTD_selectEncodingType((_DWORD *)v63 + 1143, (unsigned int *)a8, v84, v88, v82, 9u, v89 + 900, (uint64_t)ML_defaultNorm, 6, 1, v90);
              result = ZSTD_buildCTable(v79, v113 - (_QWORD)v79, v85, 9u, v100, (unsigned int *)a8, v84, v120, v82, ML_defaultNorm, 6, 52, v99, 0x5ACuLL, v118, 0x1904uLL);
              if (v100 == 2)
                v101 = v79;
              else
                v101 = v106;
              v102 = v82;
              a7 = v114;
              v18 = v115;
              if (result > 0xFFFFFFFFFFFFFF88)
                goto LABEL_111;
              v103 = (unint64_t *)&v79[result];
              *v26 = (v108 << 6) + 16 * v78 + 4 * v100;
              result = ZSTD_encodeSequences(v103, v113 - (_QWORD)v103, v85, (uint64_t)v120, v112, (uint64_t)v121, __dsta, (uint64_t)v124, v123, v102, v119);
              if (result > 0xFFFFFFFFFFFFFF88)
                goto LABEL_111;
              v26 = (char *)v103 + result;
              if (v101)
              {
                v19 = v107;
                v23 = v115;
                if (v26 - v101 < 4)
                  return 0;
              }
              else
              {
                v19 = v107;
                v23 = v115;
              }
              goto LABEL_40;
            }
          }
          else
          {
            v86 = 0;
            v87 = 0;
          }
          v95 = v84 - v86 + 1;
          v96 = (unsigned int *)a8 + v86;
          do
          {
            v98 = *v96++;
            v97 = v98;
            if (v98 > v87)
              v87 = v97;
            --v95;
          }
          while (v95);
          goto LABEL_100;
        }
        v59 = v121;
        v60 = v57;
        a8[6] = 0u;
        a8[7] = 0u;
        a8[4] = 0u;
        a8[5] = 0u;
        a8[2] = 0u;
        a8[3] = 0u;
        *a8 = 0u;
        a8[1] = 0u;
        do
        {
          v61 = *(unsigned __int8 *)v59;
          v59 = (unsigned int *)((char *)v59 + 1);
          ++a8->i32[v61];
        }
        while (v59 < (unsigned int *)((char *)v121 + v57));
        LODWORD(v62) = 32;
        do
          v62 = (v62 - 1);
        while (!a8->i32[v62]);
        v63 = v116;
        v64 = v56;
        if (v62 >= 7)
        {
          v65 = (v62 + 1) & 0x1FFFFFFF8;
          v70 = a8 + 1;
          v71 = v65;
          v72 = 0uLL;
          v73 = 0uLL;
          do
          {
            v72 = vmaxq_u32(v70[-1], v72);
            v73 = vmaxq_u32(*v70, v73);
            v70 += 2;
            v71 -= 8;
          }
          while (v71);
          v66 = vmaxvq_u32(vmaxq_u32(v72, v73));
          if (v62 + 1 == v65)
          {
LABEL_77:
            v67 = v66;
            v68 = v117;
            goto LABEL_79;
          }
        }
        else
        {
          v65 = 0;
          v66 = 0;
        }
        v74 = v62 - v65 + 1;
        v75 = (unsigned int *)a8 + v65;
        do
        {
          v77 = *v75++;
          v76 = v77;
          if (v77 > v66)
            v66 = v76;
          --v74;
        }
        while (v74);
        goto LABEL_77;
      }
    }
    else
    {
      v42 = 0;
      v43 = 0;
    }
    v49 = v41 - v42 + 1;
    v50 = (unsigned int *)a8 + v42;
    do
    {
      v52 = *v50++;
      v51 = v52;
      if (v52 > v43)
        v43 = v51;
      --v49;
    }
    while (v49);
    goto LABEL_49;
  }
  *v22 = v24 >> 3;
  v26 = v22 + 1;
  if (v17 != v123)
    goto LABEL_14;
LABEL_39:
  memcpy(v116 + 1028, __src + 514, 0xDE0uLL);
LABEL_40:
  result = (unint64_t)&v26[-v19];
  if (v26 == (char *)v19)
    return result;
  v18 = v23;
LABEL_111:
  if (a7 <= v18 && result == -70)
    return 0;
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    v104 = a4[7];
    if (v104 <= 7)
      v105 = 6;
    else
      v105 = v104 - 1;
    if (result >= a7 - (a7 >> v105) - 2)
      return 0;
  }
  return result;
}

unint64_t ZSTD_compress_insertDictionary(uint64_t a1, unint64_t a2, unint64_t a3, _QWORD *a4, _DWORD *a5, _DWORD *a6, unint64_t a7, int a8, int a9, _DWORD *a10)
{
  unint64_t result;
  uint64_t v16;

  if (a6 && a7 > 7)
  {
    *(_QWORD *)(a1 + 4580) = 0x400000001;
    *(_DWORD *)(a1 + 4588) = 8;
    *(_DWORD *)(a1 + 1024) = 0;
    *(_QWORD *)(a1 + 4568) = 0;
    *(_DWORD *)(a1 + 4576) = 0;
    if (a8 == 1)
      goto LABEL_4;
    if (*a6 == -332356553)
      goto LABEL_20;
    if (a8 == 2)
      return -32;
    if (a8)
    {
LABEL_20:
      if (a5[10])
      {
        v16 = 0;
        result = ZSTD_loadCEntropy(a1, a10, (uint64_t)a6, a7);
        if (result <= 0xFFFFFFFFFFFFFF88)
          goto LABEL_16;
      }
      else
      {
        v16 = a6[1];
        result = ZSTD_loadCEntropy(a1, a10, (uint64_t)a6, a7);
        if (result <= 0xFFFFFFFFFFFFFF88)
        {
LABEL_16:
          ZSTD_loadDictionaryContent(a2, 0, a4, a5, (unint64_t)a6 + result, a7 - result, a9);
          return v16;
        }
      }
    }
    else
    {
LABEL_4:
      ZSTD_loadDictionaryContent(a2, a3, a4, a5, (unint64_t)a6, a7, a9);
      return 0;
    }
  }
  else if (a8 == 2)
  {
    return -32;
  }
  else
  {
    return 0;
  }
  return result;
}

unint64_t ZSTD_loadDictionaryContent(unint64_t result, unint64_t a2, _QWORD *a3, _DWORD *a4, unint64_t a5, uint64_t a6, int a7)
{
  unint64_t v7;
  _DWORD *v8;
  unint64_t v10;
  uint32x4_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unsigned __int32 v33;
  unsigned __int32 v34;
  int v35;
  uint64_t *v36;
  _DWORD *v39;

  v7 = a5;
  v8 = a4;
  v10 = a2;
  v11 = (uint32x4_t *)result;
  v12 = a5 + a6;
  if (a6)
  {
    if (*(_QWORD *)result == a5)
    {
      v13 = *(_QWORD *)(result + 16);
      LODWORD(v14) = *(_DWORD *)(result + 24);
      v15 = *(_DWORD *)(result + 28);
    }
    else
    {
      v13 = *(_QWORD *)(result + 8);
      v14 = *(_QWORD *)result - v13;
      v15 = *(_DWORD *)(result + 24);
      *(_DWORD *)(result + 24) = v14;
      *(_DWORD *)(result + 28) = v15;
      *(_QWORD *)(result + 8) = a5 - v14;
      *(_QWORD *)(result + 16) = v13;
      if (v14 - v15 <= 7)
      {
        *(_DWORD *)(result + 28) = v14;
        v15 = v14;
      }
    }
    *(_QWORD *)result = v12;
    if (v12 > v13 + (unint64_t)v15 && v13 + (unint64_t)v14 > a5)
    {
      v17 = v12 - v13;
      if (v17 > v14)
        LODWORD(v17) = v14;
      *(_DWORD *)(result + 28) = v17;
    }
  }
  v18 = a4[12];
  if (v18)
  {
    *(_DWORD *)(result + 32) = 0;
    v19 = a4[24];
    v39 = a4 + 24;
    if (!a2)
      goto LABEL_33;
  }
  else
  {
    *(_DWORD *)(result + 32) = v12 - *(_DWORD *)(result + 8);
    v19 = a4[24];
    v39 = a4 + 24;
    if (!a2)
      goto LABEL_33;
  }
  if (v19)
  {
    if (a6)
    {
      if (*(_QWORD *)a2 == a5)
      {
        v20 = *(_QWORD *)(a2 + 16);
        LODWORD(v21) = *(_DWORD *)(a2 + 24);
        v22 = *(_DWORD *)(a2 + 28);
      }
      else
      {
        v20 = *(_QWORD *)(a2 + 8);
        v21 = *(_QWORD *)a2 - v20;
        v22 = *(_DWORD *)(a2 + 24);
        *(_DWORD *)(a2 + 24) = v21;
        *(_DWORD *)(a2 + 28) = v22;
        *(_QWORD *)(a2 + 8) = a5 - v21;
        *(_QWORD *)(a2 + 16) = v20;
        if (v21 - v22 <= 7)
        {
          *(_DWORD *)(a2 + 28) = v21;
          v22 = v21;
        }
      }
      *(_QWORD *)a2 = v12;
      if (v12 > v20 + (unint64_t)v22 && v20 + (unint64_t)v21 > a5)
      {
        v23 = v12 - v20;
        if (v23 > v21)
          LODWORD(v23) = v21;
        *(_DWORD *)(a2 + 28) = v23;
      }
    }
    if (v18)
      v24 = 0;
    else
      v24 = v12 - *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a2 + 40) = v24;
  }
LABEL_33:
  if ((unint64_t)a6 >= 9)
  {
    if (a6 >= 9)
    {
      v25 = a5;
      do
      {
        v26 = v25;
        if ((unint64_t)a6 >= 0x1FFFFFFF)
          v27 = 0x1FFFFFFFLL;
        else
          v27 = a6;
        v25 += v27;
        result = (unint64_t)ZSTD_overflowCorrectIfNeeded(v11, a3, v8, v26, v25);
        if (v10 && v8[24])
          result = ZSTD_ldm_fillHashTable(v10, v7, v12, v39);
        switch(v8[7])
        {
          case 1:
            result = ZSTD_fillHashTable((uint64_t)v11, v25, a7);
            break;
          case 2:
            result = ZSTD_fillDoubleHashTable((unint64_t)v11, v25, a7);
            break;
          case 3:
          case 4:
          case 5:
            v36 = (uint64_t *)(v25 - 8);
            if (v11[4].i32[2])
              result = ZSTD_dedicatedDictSearch_lazy_loadDictionary((uint64_t)v11, (int)v36);
            else
              result = ZSTD_insertAndFindFirstIndex((uint64_t)v11, v36);
            break;
          case 6:
          case 7:
          case 8:
          case 9:
            v28 = v10;
            v29 = a3;
            v30 = v12;
            v31 = v7;
            v32 = v11->i64[1];
            v33 = v25 - v32 - 8;
            v34 = v11[2].u32[1];
            if (v34 < v33)
            {
              v35 = v11[13].i32[0];
              do
              {
                result = ZSTD_insertBt1((uint64_t)v11, (_QWORD *)(v32 + v34), v25, v35, 0);
                v34 += result;
              }
              while (v34 < v33);
            }
            v11[2].i32[1] = v33;
            v7 = v31;
            v12 = v30;
            a3 = v29;
            v10 = v28;
            v8 = a4;
            break;
          default:
            break;
        }
        a6 = v12 - v25;
      }
      while ((uint64_t)(v12 - v25) > 8);
    }
    v11[2].i32[1] = v12 - v11->i32[2];
  }
  return result;
}

uint64_t ZSTD_copySequencesToSeqStoreExplicitBlockDelim(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, char *__src, uint64_t a6)
{
  _OWORD *v6;
  unsigned int v9;
  char *v10;
  uint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  int v17;
  unint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  BOOL v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t result;
  char *v36;
  char *v37;
  _OWORD *v38;
  char *v39;
  uint64_t v40;
  _OWORD *v41;
  unint64_t v42;
  __int128 *v43;
  __int128 v44;
  __int128 *v45;
  char *v46;
  __int128 v47;
  char *v48;
  char *v49;
  unint64_t v50;
  char *v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  char *v55;
  __int128 *v56;
  char *v57;
  unint64_t v58;
  __int128 v59;
  uint64_t *v60;
  char *v61;
  unint64_t v62;
  uint64_t v63;
  char v64;
  uint64_t v65;
  uint64_t v66;
  size_t v67;
  unsigned int *v68;
  unsigned int v69;
  uint64_t v70;
  unint64_t v71;
  int v72;

  v6 = __src;
  v9 = *a2;
  v10 = &__src[a6];
  v11 = *(_QWORD *)(a1 + 3288);
  if (v11)
  {
    v12 = (unsigned int *)(v11 + 8);
LABEL_5:
    v13 = *v12;
    goto LABEL_6;
  }
  v13 = *(_QWORD *)(a1 + 3296);
  if (v13)
  {
    v12 = (unsigned int *)(a1 + 3304);
    goto LABEL_5;
  }
LABEL_6:
  v14 = *(_QWORD *)(a1 + 2872);
  v71 = *(_QWORD *)(v14 + 4580);
  v15 = (char *)&v71 + 4;
  v16 = v10 - 32;
  v17 = *(_DWORD *)(v14 + 4588);
  v72 = v17;
  while (1)
  {
    v18 = v9;
    v19 = (unsigned int *)(a3 + 16 * v9);
    v20 = v19[2];
    if (!v20)
      break;
    if (v18 >= a4)
      goto LABEL_82;
    v21 = *v19;
LABEL_15:
    v23 = a3 + 16 * v18;
    v24 = *(unsigned int *)(v23 + 4);
    v25 = *(_DWORD *)(v23 + 4) == 0;
    v26 = v71;
    if ((_DWORD)v24)
      v27 = (_DWORD)v71 == v21;
    else
      v27 = 0;
    if (v27)
    {
      v29 = 0;
      goto LABEL_25;
    }
    if (HIDWORD(v71) == v21)
    {
      v28 = 2;
LABEL_24:
      v29 = v28 + ~v25;
      goto LABEL_25;
    }
    if (v17 == v21)
    {
      v28 = 3;
      goto LABEL_24;
    }
    if ((_DWORD)v24 || (_DWORD)v71 - 1 != v21)
    {
      v29 = v21 + 2;
      if (v21 != 0 && v21 < 0xFFFFFFFE)
      {
        v31 = (int *)v15;
        goto LABEL_34;
      }
    }
    else
    {
      v29 = 2;
    }
LABEL_25:
    v30 = v29 + v25;
    if (v29 + v25)
    {
      if (v30 == 3)
      {
        v21 = v71 - 1;
      }
      else
      {
        v21 = *((_DWORD *)&v71 + v30);
        v26 = v71;
      }
      if (v30 <= 1)
        v32 = 8;
      else
        v32 = 4;
      v31 = (int *)((char *)&v71 + v32);
    }
    else
    {
      v21 = v71;
      v26 = HIDWORD(v71);
      v31 = &v72;
    }
LABEL_34:
    v17 = *v31;
    v71 = v21 | (unint64_t)(v26 << 32);
    v72 = v17;
    if (*(_DWORD *)(a1 + 320))
    {
      v33 = *((_QWORD *)a2 + 1) + v24 + v20;
      *((_QWORD *)a2 + 1) = v33;
      v34 = v33 <= 1 << *(_DWORD *)(a1 + 188) ? v33 + v13 : 1 << *(_DWORD *)(a1 + 188);
      result = -20;
      if (v20 < *(_DWORD *)(a1 + 204) || v34 + 2 < v29)
        return result;
    }
    if (*(_QWORD *)(a1 + 688) < (unint64_t)(v18 - *a2))
      return -64;
    v36 = (char *)v6 + v24;
    v37 = *(char **)(a1 + 656);
    if ((char *)v6 + v24 <= v16)
    {
      *(_OWORD *)v37 = *v6;
      v40 = *(_QWORD *)(a1 + 656);
      if (v24 <= 0x10)
      {
        *(_QWORD *)(a1 + 656) = v40 + v24;
        v52 = *(_QWORD *)(a1 + 640);
        goto LABEL_80;
      }
      v41 = (_OWORD *)(v40 + 16);
      v42 = v40 + v24;
      v43 = v6 + 1;
      do
      {
        v44 = *v43++;
        *v41++ = v44;
      }
      while ((unint64_t)v41 < v42);
    }
    else
    {
      if (v6 <= (_OWORD *)v16)
      {
        v39 = &v37[v16 - (char *)v6];
        v45 = v6;
        v46 = *(char **)(a1 + 656);
        do
        {
          v47 = *v45++;
          *(_OWORD *)v46 = v47;
          v46 += 16;
        }
        while (v46 < v39);
        v38 = v16;
        if (v16 >= v36)
          goto LABEL_78;
      }
      else
      {
        v38 = v6;
        v39 = *(char **)(a1 + 656);
        if (v6 >= (_OWORD *)v36)
          goto LABEL_78;
      }
      v48 = (char *)v6 + v24;
      if (v6 <= (_OWORD *)v16)
        v49 = v16;
      else
        v49 = (char *)v6;
      v50 = v48 - v49;
      if ((unint64_t)(v48 - v49) < 8)
      {
        v51 = (char *)v38;
        goto LABEL_77;
      }
      if ((unint64_t)(v37 - (char *)v6) < 0x20)
      {
        v51 = (char *)v38;
        goto LABEL_77;
      }
      if (v50 >= 0x20)
      {
        v54 = v10;
        v55 = v15;
        v53 = v50 & 0xFFFFFFFFFFFFFFE0;
        v56 = v38 + 1;
        v57 = &v37[v49 - (char *)v6 + 16];
        v58 = v50 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v59 = *v56;
          *((_OWORD *)v57 - 1) = *(v56 - 1);
          *(_OWORD *)v57 = v59;
          v56 += 2;
          v57 += 32;
          v58 -= 32;
        }
        while (v58);
        v15 = v55;
        v10 = v54;
        if (v50 == v53)
          goto LABEL_78;
        if ((v50 & 0x18) == 0)
        {
          v51 = (char *)v38 + v53;
          v39 += v53;
          do
          {
LABEL_77:
            v64 = *v51++;
            *v39++ = v64;
          }
          while (v51 < v36);
          goto LABEL_78;
        }
      }
      else
      {
        v53 = 0;
      }
      v39 += v50 & 0xFFFFFFFFFFFFFFF8;
      v51 = (char *)v38 + (v50 & 0xFFFFFFFFFFFFFFF8);
      v60 = (uint64_t *)((char *)v38 + v53);
      v61 = &v37[&v49[v53] - (char *)v6];
      v62 = v53 - (v50 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        v63 = *v60++;
        *(_QWORD *)v61 = v63;
        v61 += 8;
        v62 += 8;
      }
      while (v62);
      if (v50 != (v50 & 0xFFFFFFFFFFFFFFF8))
        goto LABEL_77;
    }
LABEL_78:
    *(_QWORD *)(a1 + 656) += v24;
    v52 = *(_QWORD *)(a1 + 640);
    if (v24 >= 0x10000)
    {
      *(_DWORD *)(a1 + 704) = 1;
      *(_DWORD *)(a1 + 708) = (unint64_t)(v52 - *(_QWORD *)(a1 + 632)) >> 3;
    }
LABEL_80:
    *(_WORD *)(v52 + 4) = v24;
    *(_DWORD *)v52 = v29 + 1;
    if (v20 - 3 >= 0x10000)
    {
      *(_DWORD *)(a1 + 704) = 2;
      *(_DWORD *)(a1 + 708) = (unint64_t)(v52 - *(_QWORD *)(a1 + 632)) >> 3;
    }
    *(_WORD *)(v52 + 6) = v20 - 3;
    *(_QWORD *)(a1 + 640) = v52 + 8;
    v6 = (_OWORD *)((char *)v6 + v24 + v20);
    v9 = v18 + 1;
  }
  v21 = *v19;
  if (v18 < a4 && v21 != 0)
    goto LABEL_15;
LABEL_82:
  v65 = *(_QWORD *)(a1 + 2880);
  *(_QWORD *)(v65 + 4580) = v71;
  *(_DWORD *)(v65 + 4588) = v72;
  v66 = a3 + 16 * v18;
  v69 = *(_DWORD *)(v66 + 4);
  v68 = (unsigned int *)(v66 + 4);
  v67 = v69;
  if (v69)
  {
    memcpy(*(void **)(a1 + 656), v6, v67);
    *(_QWORD *)(a1 + 656) += v67;
    v70 = *v68;
    v6 = (_OWORD *)((char *)v6 + v70);
    *((_QWORD *)a2 + 1) += v70;
  }
  if (v6 != (_OWORD *)v10)
    return -20;
  result = 0;
  *a2 = v18 + 1;
  return result;
}

uint64_t ZSTD_copySequencesToSeqStoreNoBlockDelim(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, char *a5, unint64_t a6)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  unint64_t v18;
  int v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  unint64_t v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  BOOL v32;
  unsigned int v33;
  BOOL v34;
  unsigned int v35;
  BOOL v36;
  int v37;
  unsigned int v38;
  int *v39;
  BOOL v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  _OWORD *v47;
  char *v48;
  uint64_t v49;
  _OWORD *v50;
  unint64_t v51;
  __int128 *v52;
  __int128 v53;
  char *v54;
  char *v55;
  __int128 v56;
  char *v57;
  char *v58;
  unint64_t v59;
  char *v60;
  uint64_t v61;
  __int16 v62;
  unint64_t v63;
  __int128 *v64;
  char *v65;
  unint64_t v66;
  __int128 v67;
  uint64_t *v68;
  char *v69;
  unint64_t v70;
  uint64_t v71;
  char v72;
  uint64_t v73;
  char *v74;
  size_t v75;
  char *v77;
  unint64_t v78;
  int v79;

  v8 = *a2;
  v9 = a2[1];
  v10 = v9 + a6;
  v11 = *(_QWORD *)(a1 + 3288);
  if (v11)
  {
    v12 = (uint64_t *)(v11 + 8);
LABEL_5:
    v13 = *v12;
    goto LABEL_6;
  }
  if (*(_QWORD *)(a1 + 3296))
  {
    v12 = (uint64_t *)(a1 + 3304);
    goto LABEL_5;
  }
  v13 = 0;
LABEL_6:
  v14 = &a5[a6];
  v15 = *(_QWORD *)(a1 + 2872);
  v78 = *(_QWORD *)(v15 + 4580);
  v79 = *(_DWORD *)(v15 + 4588);
  if (v10)
  {
    v16 = 0;
    v17 = 0;
    v18 = (unint64_t)(v14 - 32);
    v19 = v79;
    while (1)
    {
      if (v16 || v8 >= a4)
        goto LABEL_103;
      v20 = (unsigned int *)(a3 + 16 * v8);
      v22 = *v20;
      v21 = v20[1];
      v23 = v20[2];
      v24 = v23 + v21;
      v25 = v23 + v21 - v10;
      if (v23 + v21 <= v10)
      {
        v16 = 0;
        if (v21 >= v9)
          v26 = v21 - v9;
        else
          v26 = 0;
        v34 = v9 >= v21;
        v35 = v9 - v21;
        if (!v34)
          v35 = 0;
        v29 = v23 - v35;
        ++v8;
        v9 = 0;
        v30 = v26 == 0;
        v31 = v78;
        if (v26)
          v36 = (_DWORD)v78 == v22;
        else
          v36 = 0;
        if (v36)
          goto LABEL_28;
      }
      else
      {
        if (v10 <= v21)
          goto LABEL_103;
        if (v21 >= v9)
          v26 = v21 - v9;
        else
          v26 = 0;
        if (v23 <= a6 || (v27 = v10 - v9 - v26, v28 = *(_DWORD *)(a1 + 204), v27 < v28))
        {
          v17 = v10 - v21;
          v10 = v20[1];
          goto LABEL_103;
        }
        if (v28 > v25)
          v17 = v28 - v25;
        if (v28 >= v25)
          v24 = v28 - v25;
        else
          v24 = 0;
        v29 = v27 - v24;
        v16 = 1;
        v30 = v26 == 0;
        v31 = v78;
        if (v26)
          v32 = (_DWORD)v78 == v22;
        else
          v32 = 0;
        if (v32)
        {
LABEL_28:
          v33 = 0;
          goto LABEL_43;
        }
      }
      if (HIDWORD(v78) == v22)
        break;
      if (v19 == v22)
      {
        v37 = 3;
        goto LABEL_42;
      }
      if (v26 || (_DWORD)v31 - 1 != v22)
      {
        v33 = v22 + 2;
        if (v22 != 0 && v22 < 0xFFFFFFFE)
        {
          v39 = (int *)&v78 + 1;
          goto LABEL_51;
        }
      }
      else
      {
        v33 = 2;
      }
LABEL_43:
      v38 = v33 + v30;
      if (v33 + v30)
      {
        if (v38 == 3)
        {
          v22 = v31 - 1;
        }
        else
        {
          v22 = *((_DWORD *)&v78 + v38);
          v31 = v78;
        }
        v40 = v38 > 1;
        v41 = 8;
        if (v40)
          v41 = 4;
        v39 = (int *)((char *)&v78 + v41);
      }
      else
      {
        v22 = v78;
        v31 = HIDWORD(v78);
        v39 = &v79;
      }
LABEL_51:
      v19 = *v39;
      v78 = v22 | (unint64_t)(v31 << 32);
      v79 = v19;
      if (*(_DWORD *)(a1 + 320))
      {
        v42 = *((_QWORD *)a2 + 1) + v29 + v26;
        *((_QWORD *)a2 + 1) = v42;
        v43 = v42 <= 1 << *(_DWORD *)(a1 + 188) ? v42 + v13 : 1 << *(_DWORD *)(a1 + 188);
        v44 = -20;
        if (v29 < *(_DWORD *)(a1 + 204) || v43 + 2 < v33)
          return v44;
      }
      if (*(_QWORD *)(a1 + 688) < (unint64_t)(v8 - *a2))
        return -64;
      v45 = &a5[v26];
      v46 = *(char **)(a1 + 656);
      if ((unint64_t)v45 > v18)
      {
        if ((unint64_t)a5 <= v18)
        {
          v48 = &v46[v18 - (_QWORD)a5];
          v54 = a5;
          v55 = *(char **)(a1 + 656);
          do
          {
            v56 = *(_OWORD *)v54;
            v54 += 16;
            *(_OWORD *)v55 = v56;
            v55 += 16;
          }
          while (v55 < v48);
          v47 = (_OWORD *)v18;
          if (v18 < (unint64_t)v45)
            goto LABEL_69;
        }
        else
        {
          v47 = a5;
          v48 = *(char **)(a1 + 656);
          if (a5 >= v45)
            goto LABEL_96;
LABEL_69:
          v57 = &a5[v26];
          if ((unint64_t)a5 <= v18)
            v58 = (char *)v18;
          else
            v58 = a5;
          v59 = v57 - v58;
          if ((unint64_t)(v57 - v58) < 8)
          {
            v60 = (char *)v47;
            goto LABEL_95;
          }
          if ((unint64_t)(v46 - a5) < 0x20)
          {
            v60 = (char *)v47;
            goto LABEL_95;
          }
          v77 = v14;
          if (v59 >= 0x20)
          {
            v63 = v59 & 0xFFFFFFFFFFFFFFE0;
            v64 = v47 + 1;
            v65 = &v46[v58 - a5 + 16];
            v66 = v59 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              v67 = *v64;
              *((_OWORD *)v65 - 1) = *(v64 - 1);
              *(_OWORD *)v65 = v67;
              v64 += 2;
              v65 += 32;
              v66 -= 32;
            }
            while (v66);
            v14 = v77;
            if (v59 != v63)
            {
              if ((v59 & 0x18) == 0)
              {
                v60 = (char *)v47 + v63;
                v48 += v63;
                goto LABEL_95;
              }
              goto LABEL_90;
            }
          }
          else
          {
            v63 = 0;
LABEL_90:
            v48 += v59 & 0xFFFFFFFFFFFFFFF8;
            v60 = (char *)v47 + (v59 & 0xFFFFFFFFFFFFFFF8);
            v68 = (uint64_t *)((char *)v47 + v63);
            v69 = &v46[&v58[v63] - a5];
            v70 = v63 - (v59 & 0xFFFFFFFFFFFFFFF8);
            do
            {
              v71 = *v68++;
              *(_QWORD *)v69 = v71;
              v69 += 8;
              v70 += 8;
            }
            while (v70);
            v14 = v77;
            if (v59 != (v59 & 0xFFFFFFFFFFFFFFF8))
            {
              do
              {
LABEL_95:
                v72 = *v60++;
                *v48++ = v72;
              }
              while (v60 < v45);
            }
          }
        }
LABEL_96:
        *(_QWORD *)(a1 + 656) += v26;
        v61 = *(_QWORD *)(a1 + 640);
        if (v26 >= 0x10000)
        {
          *(_DWORD *)(a1 + 704) = 1;
          *(_DWORD *)(a1 + 708) = (unint64_t)(v61 - *(_QWORD *)(a1 + 632)) >> 3;
        }
        v62 = v29 - 3;
        *(_WORD *)(v61 + 4) = v26;
        *(_DWORD *)v61 = v33 + 1;
        if (v29 - 3 < 0x10000)
          goto LABEL_8;
LABEL_99:
        *(_DWORD *)(a1 + 704) = 2;
        *(_DWORD *)(a1 + 708) = (unint64_t)(v61 - *(_QWORD *)(a1 + 632)) >> 3;
        goto LABEL_8;
      }
      *(_OWORD *)v46 = *(_OWORD *)a5;
      v49 = *(_QWORD *)(a1 + 656);
      if (v26 > 0x10)
      {
        v50 = (_OWORD *)(v49 + 16);
        v51 = v49 + v26;
        v52 = (__int128 *)(a5 + 16);
        do
        {
          v53 = *v52++;
          *v50++ = v53;
        }
        while ((unint64_t)v50 < v51);
        goto LABEL_96;
      }
      *(_QWORD *)(a1 + 656) = v49 + v26;
      v61 = *(_QWORD *)(a1 + 640);
      v62 = v29 - 3;
      *(_WORD *)(v61 + 4) = v26;
      *(_DWORD *)v61 = v33 + 1;
      if (v29 - 3 >= 0x10000)
        goto LABEL_99;
LABEL_8:
      *(_WORD *)(v61 + 6) = v62;
      *(_QWORD *)(a1 + 640) = v61 + 8;
      a5 += v29 + v26;
      v10 -= v24;
      if (!v10)
        goto LABEL_103;
    }
    v37 = 2;
LABEL_42:
    v33 = v37 + ~v30;
    goto LABEL_43;
  }
  v17 = 0;
LABEL_103:
  *a2 = v8;
  a2[1] = v10;
  v73 = *(_QWORD *)(a1 + 2880);
  *(_QWORD *)(v73 + 4580) = v78;
  *(_DWORD *)(v73 + 4588) = v79;
  v44 = v17;
  v74 = &v14[-v17];
  if (a5 != v74)
  {
    v75 = ((_DWORD)v74 - (_DWORD)a5);
    memcpy(*(void **)(a1 + 656), a5, v75);
    *(_QWORD *)(a1 + 656) += v75;
    *((_QWORD *)a2 + 1) += v75;
  }
  return v44;
}

unint64_t ZSTD_count_2segments(_QWORD *a1, char *a2, unint64_t a3, char *a4, _QWORD *a5)
{
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v16;
  unint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;

  v5 = (char *)a1 + a4 - a2;
  if ((unint64_t)v5 >= a3)
    v5 = (char *)a3;
  v6 = (char *)a1;
  v7 = a2;
  if (v5 - 7 > (char *)a1)
  {
    v8 = *a1 ^ *(_QWORD *)a2;
    if (v8)
    {
      v9 = __clz(__rbit64(v8)) >> 3;
      goto LABEL_17;
    }
    v10 = 0;
    v11 = a1 + 1;
    while (1)
    {
      v12 = &v11[v10];
      if (&v11[v10] >= (_QWORD *)(v5 - 7))
        break;
      v13 = *(_QWORD *)&a2[v10 * 8 + 8];
      ++v10;
      v14 = *v12 ^ v13;
      if (v14)
      {
        v9 = v10 * 8 + (__clz(__rbit64(v14)) >> 3);
        goto LABEL_17;
      }
    }
    v6 = (char *)&a1[v10 + 1];
    v7 = &a2[v10 * 8 + 8];
  }
  if (v6 >= v5 - 3)
  {
    if (v6 >= v5 - 1)
      goto LABEL_13;
LABEL_25:
    if (*(unsigned __int16 *)v7 == *(unsigned __int16 *)v6)
    {
      v6 += 2;
      v7 += 2;
    }
    if (v6 >= v5)
      goto LABEL_16;
    goto LABEL_14;
  }
  if (*(_DWORD *)v7 == *(_DWORD *)v6)
  {
    v6 += 4;
    v7 += 4;
  }
  if (v6 < v5 - 1)
    goto LABEL_25;
LABEL_13:
  if (v6 < v5)
  {
LABEL_14:
    if (*v7 == *v6)
      ++v6;
  }
LABEL_16:
  v9 = v6 - (char *)a1;
LABEL_17:
  if (&a2[v9] != a4)
    return v9;
  v16 = (_QWORD *)((char *)a1 + v9);
  if (a3 - 7 <= (unint64_t)a1 + v9)
  {
    v18 = (_DWORD *)((char *)a1 + v9);
    if ((unint64_t)v16 >= a3 - 3)
      goto LABEL_32;
    goto LABEL_30;
  }
  v17 = *v16 ^ *a5;
  if (v17)
    return (__clz(__rbit64(v17)) >> 3) + v9;
  v19 = (uint64_t)a1 + v9 + 8;
  while (1)
  {
    v20 = (_QWORD *)(v19 + v17);
    if (v19 + v17 >= a3 - 7)
      break;
    v21 = *(_QWORD *)((char *)a5 + v17 + 8);
    v17 += 8;
    v22 = *v20 ^ v21;
    if (v22)
      return v17 + (__clz(__rbit64(v22)) >> 3) + v9;
  }
  v18 = (_DWORD *)((char *)a1 + v9 + v17 + 8);
  a5 = (_QWORD *)((char *)a5 + v17 + 8);
  if ((unint64_t)v18 < a3 - 3)
  {
LABEL_30:
    if (*(_DWORD *)a5 == *v18)
    {
      ++v18;
      a5 = (_QWORD *)((char *)a5 + 4);
    }
  }
LABEL_32:
  if ((unint64_t)v18 < a3 - 1)
  {
    if (*(unsigned __int16 *)a5 == *(unsigned __int16 *)v18)
    {
      v18 = (_DWORD *)((char *)v18 + 2);
      a5 = (_QWORD *)((char *)a5 + 2);
    }
    if ((unint64_t)v18 >= a3)
      return (char *)v18 - (char *)a1;
    goto LABEL_34;
  }
  if ((unint64_t)v18 < a3)
  {
LABEL_34:
    if (*(unsigned __int8 *)a5 == *(unsigned __int8 *)v18)
      v18 = (_DWORD *)((char *)v18 + 1);
  }
  return (char *)v18 - (char *)a1;
}

unint64_t ZSTD_BtFindBestMatch_selectMLS(uint64_t a1, uint64_t *a2, unint64_t a3, _QWORD *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  int v22;
  _DWORD *v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  _DWORD *v33;

  v4 = *(_DWORD *)(a1 + 208);
  if ((v4 - 6) >= 2)
  {
    if (v4 == 5)
    {
      v15 = *(_QWORD *)(a1 + 8);
      v16 = *(unsigned int *)(a1 + 36);
      if (v15 + v16 <= (unint64_t)a2)
      {
        if (v16 < (int)a2 - (int)v15)
        {
          v17 = *(_QWORD *)(a1 + 48);
          v18 = ~(-1 << (*(_DWORD *)(a1 + 196) - 1));
          v19 = *(_QWORD *)(a1 + 64);
          v20 = 64 - *(_DWORD *)(a1 + 200);
          do
          {
            v21 = 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v15 + v16)) >> v20);
            v22 = *(_DWORD *)(v17 + v21);
            v23 = (_DWORD *)(v19 + 8 * (v16 & v18));
            *(_DWORD *)(v17 + v21) = v16;
            *v23 = v22;
            v23[1] = 1;
            ++v16;
          }
          while ((_DWORD)a2 - (_DWORD)v15 != v16);
        }
        *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v15;
        v14 = 5;
        return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, v14, 0);
      }
    }
    else
    {
      v25 = *(_QWORD *)(a1 + 8);
      v26 = *(unsigned int *)(a1 + 36);
      if (v25 + v26 <= (unint64_t)a2)
      {
        if (v26 < (int)a2 - (int)v25)
        {
          v27 = *(_QWORD *)(a1 + 48);
          v28 = ~(-1 << (*(_DWORD *)(a1 + 196) - 1));
          v29 = *(_QWORD *)(a1 + 64);
          v30 = 32 - *(_DWORD *)(a1 + 200);
          do
          {
            v31 = 4 * ((-1640531535 * *(_DWORD *)(v25 + v26)) >> v30);
            v32 = *(_DWORD *)(v27 + v31);
            v33 = (_DWORD *)(v29 + 8 * (v26 & v28));
            *(_DWORD *)(v27 + v31) = v26;
            *v33 = v32;
            v33[1] = 1;
            ++v26;
          }
          while ((_DWORD)a2 - (_DWORD)v25 != v26);
        }
        *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v25;
        v14 = 4;
        return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, v14, 0);
      }
    }
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(unsigned int *)(a1 + 36);
    if (v5 + v6 <= (unint64_t)a2)
    {
      if (v6 < (int)a2 - (int)v5)
      {
        v7 = *(_QWORD *)(a1 + 48);
        v8 = ~(-1 << (*(_DWORD *)(a1 + 196) - 1));
        v9 = *(_QWORD *)(a1 + 64);
        v10 = 64 - *(_DWORD *)(a1 + 200);
        do
        {
          v11 = 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v5 + v6)) >> v10);
          v12 = *(_DWORD *)(v7 + v11);
          v13 = (_DWORD *)(v9 + 8 * (v6 & v8));
          *(_DWORD *)(v7 + v11) = v6;
          *v13 = v12;
          v13[1] = 1;
          ++v6;
        }
        while ((_DWORD)a2 - (_DWORD)v5 != v6);
      }
      *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v5;
      v14 = 6;
      return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, v14, 0);
    }
  }
  return 0;
}

unint64_t ZSTD_HcFindBestMatch_dictMatchState_selectMLS(uint64_t a1, _QWORD *a2, unint64_t a3, _QWORD *a4)
{
  int v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unint64_t v14;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int v24;
  unint64_t v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  int v34;
  _QWORD *v35;
  int v36;
  int v37;
  uint64_t v38;
  unint64_t v39;
  BOOL v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  uint64_t v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  unsigned int v48;
  unint64_t v49;
  unsigned int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  unint64_t v57;
  unint64_t v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  unsigned int v67;
  int v68;
  _QWORD *v69;
  int v70;
  int v71;
  uint64_t v72;
  unint64_t v73;
  unsigned int v74;
  unint64_t v75;
  unint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  _DWORD *v79;
  unint64_t v80;
  unint64_t v81;
  _DWORD *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  int v87;
  unsigned int v88;
  uint64_t v89;
  unsigned int v90;
  unsigned int v91;
  uint64_t v92;
  unsigned int v93;
  unint64_t v94;
  unsigned int v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  int v101;
  uint64_t v102;
  int v103;
  unsigned int v104;
  unsigned int v105;
  unsigned int v106;
  char *v107;
  uint64_t v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  unsigned int v112;
  uint64_t v113;
  unsigned int v114;
  int v115;
  uint64_t v116;
  unint64_t v117;
  unsigned int v119;
  unint64_t v120;
  unint64_t v121;
  _QWORD *v122;
  uint64_t v123;
  _DWORD *v124;
  unint64_t v125;
  unint64_t v126;
  _DWORD *v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  unsigned int v131;
  unint64_t v132;
  unint64_t v133;
  _QWORD *v134;
  uint64_t v135;
  _DWORD *v136;
  unint64_t v137;
  unint64_t v138;
  _DWORD *v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  int v143;
  int v144;
  int v145;
  _QWORD *v146;
  _QWORD *v147;
  _QWORD *v148;
  _QWORD *v149;
  char *v153;
  char *v154;
  _QWORD *v155;

  v5 = *(_DWORD *)(a1 + 208);
  if ((v5 - 6) < 2)
  {
    v6 = *(_QWORD *)(a1 + 64);
    v7 = *(_DWORD *)(a1 + 196);
    v8 = 1 << v7;
    v9 = *(_QWORD *)(a1 + 8);
    v10 = (_DWORD)a2 - v9;
    v11 = 1 << *(_DWORD *)(a1 + 192);
    v12 = *(unsigned int *)(a1 + 24);
    v13 = *(_DWORD *)(a1 + 28);
    v14 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)a2 - (_DWORD)v9 - v13 > v11 && *(_DWORD *)(a1 + 32) == 0)
      v13 = (_DWORD)a2 - v9 - v11;
    if (v10 >= v8)
      v16 = v10 - v8;
    else
      v16 = 0;
    v17 = 1 << *(_DWORD *)(a1 + 204);
    v18 = *(_QWORD *)(a1 + 184);
    v19 = *(_QWORD *)(a1 + 48);
    v20 = 64 - *(_DWORD *)(a1 + 200);
    if (v14 < v10)
    {
      v21 = ~(-1 << v7);
      do
      {
        v22 = 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v9 + v14)) >> v20);
        *(_DWORD *)(v6 + 4 * (v14 & v21)) = *(_DWORD *)(v19 + v22);
        *(_DWORD *)(v19 + v22) = v14++;
      }
      while (v14 < ((_DWORD)a2 - v9));
    }
    *(_DWORD *)(a1 + 36) = v10;
    v23 = 0xCF1BBCDCBF9B0000 * *a2;
    v24 = *(_DWORD *)(v19 + 4 * (v23 >> v20));
    if (v24 < v13)
    {
      v25 = 3;
LABEL_15:
      v26 = 1 << *(_DWORD *)(v18 + 196);
      v27 = *(_QWORD *)(v18 + 8);
      v153 = *(char **)v18;
      v28 = *(_QWORD *)v18 - v27;
      if (v28 >= v26)
        v29 = v28 - v26;
      else
        v29 = 0;
      if (v17)
      {
        v30 = *(_DWORD *)(v18 + 24);
        v31 = *(_DWORD *)(*(_QWORD *)(v18 + 48) + 4 * (v23 >> -*(_BYTE *)(v18 + 200)));
        if (v31 >= v30)
        {
          v148 = a2;
          v146 = (_QWORD *)(v9 + v12);
          v32 = *(_QWORD *)(v18 + 64);
          v33 = v26 - 1;
          v36 = *(_DWORD *)a2;
          v35 = (_QWORD *)((char *)a2 + 4);
          v34 = v36;
          v143 = v10 - v12 + v28 + 2;
          v37 = v17 - 1;
          do
          {
            v38 = v27 + v31;
            if (*(_DWORD *)v38 == v34)
            {
              v39 = ZSTD_count_2segments(v35, (char *)(v38 + 4), a3, v153, v146);
              if (v39 + 4 > v25)
              {
                *a4 = v143 - v31;
                v25 = v39 + 4;
                if ((_QWORD *)((char *)v148 + v39 + 4) == (_QWORD *)a3)
                  break;
              }
            }
            if (v31 <= v29)
              break;
            v40 = v37-- != 0;
            if (!v40)
              break;
            v31 = *(_DWORD *)(v32 + 4 * (v31 & v33));
          }
          while (v31 >= v30);
        }
      }
      return v25;
    }
    v74 = v8 - 1;
    v75 = a3 - 7;
    v76 = a3 - 3;
    v77 = a2 + 1;
    v78 = v9 + 8;
    v25 = 3;
    while (1)
    {
      v79 = (_DWORD *)(v9 + v24);
      if (*((unsigned __int8 *)v79 + v25) != *((unsigned __int8 *)a2 + v25))
        goto LABEL_72;
      if (v75 <= (unint64_t)a2)
      {
        v82 = a2;
        if ((unint64_t)a2 < v76)
        {
LABEL_64:
          if (*v79 == *v82)
          {
            ++v82;
            ++v79;
          }
        }
      }
      else
      {
        v80 = *a2 ^ *(_QWORD *)v79;
        if (v80)
        {
          v81 = __clz(__rbit64(v80)) >> 3;
          if (v81 <= v25)
            goto LABEL_72;
          goto LABEL_71;
        }
        v83 = 0;
        while (1)
        {
          v82 = &v77[v83];
          if ((unint64_t)&v77[v83] >= v75)
            break;
          v84 = *(_QWORD *)(v78 + v24 + v83 * 8);
          ++v83;
          v85 = *(_QWORD *)v82 ^ v84;
          if (v85)
          {
            v81 = v83 * 8 + (__clz(__rbit64(v85)) >> 3);
            if (v81 > v25)
              goto LABEL_71;
            goto LABEL_72;
          }
        }
        v79 = (_DWORD *)(v78 + v24 + v83 * 8);
        if ((unint64_t)v82 < v76)
          goto LABEL_64;
      }
      if ((unint64_t)v82 >= a3 - 1)
        break;
      if (*(unsigned __int16 *)v79 == *(unsigned __int16 *)v82)
      {
        v82 = (_DWORD *)((char *)v82 + 2);
        v79 = (_DWORD *)((char *)v79 + 2);
      }
      if ((unint64_t)v82 < a3)
        goto LABEL_68;
LABEL_70:
      v81 = (char *)v82 - (char *)a2;
      if (v81 <= v25)
        goto LABEL_72;
LABEL_71:
      *a4 = v10 + 2 - v24;
      v25 = v81;
      if ((_QWORD *)((char *)a2 + v81) == (_QWORD *)a3)
      {
        v25 = v81;
        goto LABEL_15;
      }
LABEL_72:
      if (v24 > v16)
      {
        if (--v17)
        {
          v24 = *(_DWORD *)(v6 + 4 * (v24 & v74));
          if (v24 >= v13)
            continue;
        }
      }
      goto LABEL_15;
    }
    if ((unint64_t)v82 >= a3)
      goto LABEL_70;
LABEL_68:
    if (*(unsigned __int8 *)v79 == *(unsigned __int8 *)v82)
      v82 = (_DWORD *)((char *)v82 + 1);
    goto LABEL_70;
  }
  if (v5 == 5)
  {
    v41 = *(_QWORD *)(a1 + 64);
    v42 = *(_DWORD *)(a1 + 196);
    v43 = 1 << v42;
    v44 = *(_QWORD *)(a1 + 8);
    v45 = (_DWORD)a2 - v44;
    v46 = 1 << *(_DWORD *)(a1 + 192);
    v47 = *(unsigned int *)(a1 + 24);
    v48 = *(_DWORD *)(a1 + 28);
    v49 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)a2 - (_DWORD)v44 - v48 > v46 && *(_DWORD *)(a1 + 32) == 0)
      v48 = (_DWORD)a2 - v44 - v46;
    if (v45 >= v43)
      v51 = v45 - v43;
    else
      v51 = 0;
    v52 = 1 << *(_DWORD *)(a1 + 204);
    v53 = *(_QWORD *)(a1 + 184);
    v54 = *(_QWORD *)(a1 + 48);
    v55 = 64 - *(_DWORD *)(a1 + 200);
    if (v49 < v45)
    {
      v56 = ~(-1 << v42);
      do
      {
        v57 = 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v44 + v49)) >> v55);
        *(_DWORD *)(v41 + 4 * (v49 & v56)) = *(_DWORD *)(v54 + v57);
        *(_DWORD *)(v54 + v57) = v49++;
      }
      while (v49 < ((_DWORD)a2 - v44));
    }
    *(_DWORD *)(a1 + 36) = v45;
    v58 = 0xCF1BBCDCBB000000 * *a2;
    v59 = *(_DWORD *)(v54 + 4 * (v58 >> v55));
    if (v59 < v48)
    {
      v25 = 3;
LABEL_43:
      v60 = 1 << *(_DWORD *)(v53 + 196);
      v61 = *(_QWORD *)(v53 + 8);
      v154 = *(char **)v53;
      v62 = *(_QWORD *)v53 - v61;
      if (v62 >= v60)
        v63 = v62 - v60;
      else
        v63 = 0;
      if (v52)
      {
        v64 = *(_DWORD *)(v53 + 24);
        v65 = *(_DWORD *)(*(_QWORD *)(v53 + 48) + 4 * (v58 >> -*(_BYTE *)(v53 + 200)));
        if (v65 >= v64)
        {
          v149 = a2;
          v147 = (_QWORD *)(v44 + v47);
          v66 = *(_QWORD *)(v53 + 64);
          v67 = v60 - 1;
          v70 = *(_DWORD *)a2;
          v69 = (_QWORD *)((char *)a2 + 4);
          v68 = v70;
          v144 = v45 - v47 + v62 + 2;
          v71 = v52 - 1;
          do
          {
            v72 = v61 + v65;
            if (*(_DWORD *)v72 == v68)
            {
              v73 = ZSTD_count_2segments(v69, (char *)(v72 + 4), a3, v154, v147);
              if (v73 + 4 > v25)
              {
                *a4 = v144 - v65;
                v25 = v73 + 4;
                if ((_QWORD *)((char *)v149 + v73 + 4) == (_QWORD *)a3)
                  break;
              }
            }
            if (v65 <= v63)
              break;
            v40 = v71-- != 0;
            if (!v40)
              break;
            v65 = *(_DWORD *)(v66 + 4 * (v65 & v67));
          }
          while (v65 >= v64);
        }
      }
      return v25;
    }
    v119 = v43 - 1;
    v120 = a3 - 7;
    v121 = a3 - 3;
    v122 = a2 + 1;
    v123 = v44 + 8;
    v25 = 3;
    while (1)
    {
      v124 = (_DWORD *)(v44 + v59);
      if (*((unsigned __int8 *)v124 + v25) != *((unsigned __int8 *)a2 + v25))
        goto LABEL_129;
      if (v120 <= (unint64_t)a2)
      {
        v127 = a2;
        if ((unint64_t)a2 < v121)
        {
LABEL_121:
          if (*v124 == *v127)
          {
            ++v127;
            ++v124;
          }
        }
      }
      else
      {
        v125 = *a2 ^ *(_QWORD *)v124;
        if (v125)
        {
          v126 = __clz(__rbit64(v125)) >> 3;
          if (v126 <= v25)
            goto LABEL_129;
          goto LABEL_128;
        }
        v128 = 0;
        while (1)
        {
          v127 = &v122[v128];
          if ((unint64_t)&v122[v128] >= v120)
            break;
          v129 = *(_QWORD *)(v123 + v59 + v128 * 8);
          ++v128;
          v130 = *(_QWORD *)v127 ^ v129;
          if (v130)
          {
            v126 = v128 * 8 + (__clz(__rbit64(v130)) >> 3);
            if (v126 > v25)
              goto LABEL_128;
            goto LABEL_129;
          }
        }
        v124 = (_DWORD *)(v123 + v59 + v128 * 8);
        if ((unint64_t)v127 < v121)
          goto LABEL_121;
      }
      if ((unint64_t)v127 >= a3 - 1)
        break;
      if (*(unsigned __int16 *)v124 == *(unsigned __int16 *)v127)
      {
        v127 = (_DWORD *)((char *)v127 + 2);
        v124 = (_DWORD *)((char *)v124 + 2);
      }
      if ((unint64_t)v127 < a3)
        goto LABEL_125;
LABEL_127:
      v126 = (char *)v127 - (char *)a2;
      if (v126 <= v25)
        goto LABEL_129;
LABEL_128:
      *a4 = v45 + 2 - v59;
      v25 = v126;
      if ((_QWORD *)((char *)a2 + v126) == (_QWORD *)a3)
      {
        v25 = v126;
        goto LABEL_43;
      }
LABEL_129:
      if (v59 > v51)
      {
        if (--v52)
        {
          v59 = *(_DWORD *)(v41 + 4 * (v59 & v119));
          if (v59 >= v48)
            continue;
        }
      }
      goto LABEL_43;
    }
    if ((unint64_t)v127 >= a3)
      goto LABEL_127;
LABEL_125:
    if (*(unsigned __int8 *)v124 == *(unsigned __int8 *)v127)
      v127 = (_DWORD *)((char *)v127 + 1);
    goto LABEL_127;
  }
  v86 = *(_QWORD *)(a1 + 64);
  v87 = *(_DWORD *)(a1 + 196);
  v88 = 1 << v87;
  v89 = *(_QWORD *)(a1 + 8);
  v90 = (_DWORD)a2 - v89;
  v91 = 1 << *(_DWORD *)(a1 + 192);
  v92 = *(unsigned int *)(a1 + 24);
  v93 = *(_DWORD *)(a1 + 28);
  v94 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)a2 - (_DWORD)v89 - v93 > v91 && *(_DWORD *)(a1 + 32) == 0)
    v93 = (_DWORD)a2 - v89 - v91;
  if (v90 >= v88)
    v96 = v90 - v88;
  else
    v96 = 0;
  v97 = 1 << *(_DWORD *)(a1 + 204);
  v98 = *(_QWORD *)(a1 + 184);
  v99 = *(_QWORD *)(a1 + 48);
  v100 = 32 - *(_DWORD *)(a1 + 200);
  if (v94 < v90)
  {
    v101 = ~(-1 << v87);
    do
    {
      v102 = 4 * ((-1640531535 * *(_DWORD *)(v89 + v94)) >> v100);
      *(_DWORD *)(v86 + 4 * (v94 & v101)) = *(_DWORD *)(v99 + v102);
      *(_DWORD *)(v99 + v102) = v94++;
    }
    while (v94 < ((_DWORD)a2 - v89));
  }
  *(_DWORD *)(a1 + 36) = v90;
  v103 = *(_DWORD *)a2;
  v104 = -1640531535 * *(_DWORD *)a2;
  v105 = *(_DWORD *)(v99 + 4 * (v104 >> v100));
  if (v105 >= v93)
  {
    v131 = v88 - 1;
    v132 = a3 - 7;
    v133 = a3 - 3;
    v134 = a2 + 1;
    v135 = v89 + 8;
    v25 = 3;
    while (1)
    {
      v136 = (_DWORD *)(v89 + v105);
      if (*((unsigned __int8 *)v136 + v25) != *((unsigned __int8 *)a2 + v25))
        goto LABEL_159;
      if (v132 <= (unint64_t)a2)
      {
        v139 = a2;
        if ((unint64_t)a2 < v133)
        {
LABEL_151:
          if (*v136 == *v139)
          {
            ++v139;
            ++v136;
          }
        }
      }
      else
      {
        v137 = *a2 ^ *(_QWORD *)v136;
        if (v137)
        {
          v138 = __clz(__rbit64(v137)) >> 3;
          if (v138 <= v25)
            goto LABEL_159;
          goto LABEL_158;
        }
        v140 = 0;
        while (1)
        {
          v139 = &v134[v140];
          if ((unint64_t)&v134[v140] >= v132)
            break;
          v141 = *(_QWORD *)(v135 + v105 + v140 * 8);
          ++v140;
          v142 = *(_QWORD *)v139 ^ v141;
          if (v142)
          {
            v138 = v140 * 8 + (__clz(__rbit64(v142)) >> 3);
            if (v138 > v25)
              goto LABEL_158;
            goto LABEL_159;
          }
        }
        v136 = (_DWORD *)(v135 + v105 + v140 * 8);
        if ((unint64_t)v139 < v133)
          goto LABEL_151;
      }
      if ((unint64_t)v139 >= a3 - 1)
        break;
      if (*(unsigned __int16 *)v136 == *(unsigned __int16 *)v139)
      {
        v139 = (_DWORD *)((char *)v139 + 2);
        v136 = (_DWORD *)((char *)v136 + 2);
      }
      if ((unint64_t)v139 < a3)
        goto LABEL_155;
LABEL_157:
      v138 = (char *)v139 - (char *)a2;
      if (v138 <= v25)
        goto LABEL_159;
LABEL_158:
      *a4 = v90 + 2 - v105;
      v25 = v138;
      if ((_QWORD *)((char *)a2 + v138) == (_QWORD *)a3)
      {
        v25 = v138;
        goto LABEL_100;
      }
LABEL_159:
      if (v105 > v96)
      {
        if (--v97)
        {
          v105 = *(_DWORD *)(v86 + 4 * (v105 & v131));
          if (v105 >= v93)
            continue;
        }
      }
      goto LABEL_100;
    }
    if ((unint64_t)v139 >= a3)
      goto LABEL_157;
LABEL_155:
    if (*(unsigned __int8 *)v136 == *(unsigned __int8 *)v139)
      v139 = (_DWORD *)((char *)v139 + 1);
    goto LABEL_157;
  }
  v25 = 3;
LABEL_100:
  v106 = 1 << *(_DWORD *)(v98 + 196);
  v107 = *(char **)v98;
  v108 = *(_QWORD *)(v98 + 8);
  v109 = *(_QWORD *)v98 - v108;
  if (v109 >= v106)
    v110 = v109 - v106;
  else
    v110 = 0;
  if (v97)
  {
    v111 = *(_DWORD *)(v98 + 24);
    v112 = *(_DWORD *)(*(_QWORD *)(v98 + 48) + 4 * (v104 >> -*(_BYTE *)(v98 + 200)));
    if (v112 >= v111)
    {
      v155 = (_QWORD *)(v89 + v92);
      v113 = *(_QWORD *)(v98 + 64);
      v114 = v106 - 1;
      v145 = v90 - v92 + v109 + 2;
      v115 = v97 - 1;
      do
      {
        v116 = v108 + v112;
        if (*(_DWORD *)v116 == v103)
        {
          v117 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v116 + 4), a3, v107, v155);
          if (v117 + 4 > v25)
          {
            *a4 = v145 - v112;
            v25 = v117 + 4;
            if ((_QWORD *)((char *)a2 + v117 + 4) == (_QWORD *)a3)
              break;
          }
        }
        if (v112 <= v110)
          break;
        v40 = v115-- != 0;
        if (!v40)
          break;
        v112 = *(_DWORD *)(v113 + 4 * (v112 & v114));
      }
      while (v112 >= v111);
    }
  }
  return v25;
}

unint64_t ZSTD_BtFindBestMatch_dictMatchState_selectMLS(uint64_t a1, uint64_t *a2, unint64_t a3, _QWORD *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  int v22;
  _DWORD *v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  _DWORD *v33;

  v4 = *(_DWORD *)(a1 + 208);
  if ((v4 - 6) >= 2)
  {
    if (v4 == 5)
    {
      v15 = *(_QWORD *)(a1 + 8);
      v16 = *(unsigned int *)(a1 + 36);
      if (v15 + v16 <= (unint64_t)a2)
      {
        if (v16 < (int)a2 - (int)v15)
        {
          v17 = *(_QWORD *)(a1 + 48);
          v18 = ~(-1 << (*(_DWORD *)(a1 + 196) - 1));
          v19 = *(_QWORD *)(a1 + 64);
          v20 = 64 - *(_DWORD *)(a1 + 200);
          do
          {
            v21 = 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v15 + v16)) >> v20);
            v22 = *(_DWORD *)(v17 + v21);
            v23 = (_DWORD *)(v19 + 8 * (v16 & v18));
            *(_DWORD *)(v17 + v21) = v16;
            *v23 = v22;
            v23[1] = 1;
            ++v16;
          }
          while ((_DWORD)a2 - (_DWORD)v15 != v16);
        }
        *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v15;
        v14 = 5;
        return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, v14, 2);
      }
    }
    else
    {
      v25 = *(_QWORD *)(a1 + 8);
      v26 = *(unsigned int *)(a1 + 36);
      if (v25 + v26 <= (unint64_t)a2)
      {
        if (v26 < (int)a2 - (int)v25)
        {
          v27 = *(_QWORD *)(a1 + 48);
          v28 = ~(-1 << (*(_DWORD *)(a1 + 196) - 1));
          v29 = *(_QWORD *)(a1 + 64);
          v30 = 32 - *(_DWORD *)(a1 + 200);
          do
          {
            v31 = 4 * ((-1640531535 * *(_DWORD *)(v25 + v26)) >> v30);
            v32 = *(_DWORD *)(v27 + v31);
            v33 = (_DWORD *)(v29 + 8 * (v26 & v28));
            *(_DWORD *)(v27 + v31) = v26;
            *v33 = v32;
            v33[1] = 1;
            ++v26;
          }
          while ((_DWORD)a2 - (_DWORD)v25 != v26);
        }
        *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v25;
        v14 = 4;
        return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, v14, 2);
      }
    }
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(unsigned int *)(a1 + 36);
    if (v5 + v6 <= (unint64_t)a2)
    {
      if (v6 < (int)a2 - (int)v5)
      {
        v7 = *(_QWORD *)(a1 + 48);
        v8 = ~(-1 << (*(_DWORD *)(a1 + 196) - 1));
        v9 = *(_QWORD *)(a1 + 64);
        v10 = 64 - *(_DWORD *)(a1 + 200);
        do
        {
          v11 = 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v5 + v6)) >> v10);
          v12 = *(_DWORD *)(v7 + v11);
          v13 = (_DWORD *)(v9 + 8 * (v6 & v8));
          *(_DWORD *)(v7 + v11) = v6;
          *v13 = v12;
          v13[1] = 1;
          ++v6;
        }
        while ((_DWORD)a2 - (_DWORD)v5 != v6);
      }
      *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v5;
      v14 = 6;
      return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, v14, 2);
    }
  }
  return 0;
}

unint64_t ZSTD_HcFindBestMatch_dedicatedDictSearch_selectMLS(uint64_t a1, _QWORD *a2, unint64_t a3, _QWORD *a4)
{
  int v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v29;
  int v30;
  int v31;
  unint64_t v32;
  unsigned int v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  int v42;
  int v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  int v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unsigned int *v61;
  uint64_t v62;
  unsigned int v63;
  int v66;
  int v67;
  unsigned int *v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  unsigned int v75;
  uint64_t v76;
  unsigned int v77;
  unsigned int v78;
  uint64_t v79;
  unsigned int v80;
  unsigned int v81;
  unint64_t v82;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  _QWORD *v97;
  unsigned int v98;
  uint64_t v99;
  uint64_t v100;
  int v105;
  int v108;
  unint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  char v121;
  unint64_t v122;
  uint64_t v123;
  unsigned int *v124;
  uint64_t v125;
  unsigned int v126;
  int v129;
  int v130;
  unsigned int *v131;
  unsigned int v132;
  unsigned int v133;
  uint64_t v134;
  unint64_t v135;
  unsigned int v136;
  unint64_t v137;
  unint64_t v138;
  _QWORD *v139;
  uint64_t v140;
  _DWORD *v141;
  unint64_t v142;
  unint64_t v143;
  _DWORD *v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  uint64_t v148;
  int v149;
  unsigned int v150;
  uint64_t v151;
  unsigned int v152;
  unsigned int v153;
  uint64_t v154;
  unint64_t v155;
  unsigned int v157;
  unsigned int v158;
  unsigned int v159;
  uint64_t v160;
  int v161;
  unsigned int v162;
  unsigned int v163;
  uint64_t v164;
  uint64_t v167;
  int v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  unsigned int v172;
  uint64_t v173;
  uint64_t v174;
  char *v175;
  int v180;
  int v183;
  unint64_t v184;
  unint64_t v185;
  uint64_t v186;
  uint64_t v189;
  unint64_t v190;
  uint64_t v191;
  unint64_t v192;
  uint64_t v193;
  int v194;
  uint64_t v195;
  unint64_t v196;
  uint64_t v197;
  unsigned int *v198;
  uint64_t v199;
  unsigned int v200;
  int v203;
  unsigned int *v204;
  unsigned int v205;
  unsigned int v206;
  uint64_t v207;
  unint64_t v208;
  unsigned int v210;
  unint64_t v211;
  unint64_t v212;
  _QWORD *v213;
  uint64_t v214;
  _QWORD *v215;
  unint64_t v216;
  unint64_t v217;
  _QWORD *v218;
  uint64_t v219;
  uint64_t v220;
  unint64_t v221;
  unsigned int v222;
  unint64_t v223;
  unint64_t v224;
  _QWORD *v225;
  uint64_t v226;
  _QWORD *v227;
  unint64_t v228;
  unint64_t v229;
  _QWORD *v230;
  uint64_t v231;
  uint64_t v232;
  unint64_t v233;
  int v234;
  int v235;
  int v236;
  int v237;
  unint64_t v238;
  unint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  int v244;
  char v245;
  int v246;
  unint64_t v247;
  unint64_t v248;
  uint64_t v249;
  uint64_t v250;
  char v251;
  char v252;
  char v253;
  int v254;
  int v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  int v259;
  char v260;
  char v261;
  int v262;
  int v263;
  int v264;
  uint64_t v265;
  _QWORD *v266;
  char *v267;
  _QWORD *v268;

  v5 = *(_DWORD *)(a1 + 208);
  if ((v5 - 6) >= 2)
  {
    if (v5 == 5)
    {
      v73 = *(_QWORD *)(a1 + 64);
      v74 = *(_DWORD *)(a1 + 196);
      v75 = 1 << v74;
      v76 = *(_QWORD *)(a1 + 8);
      v77 = (_DWORD)a2 - v76;
      v78 = 1 << *(_DWORD *)(a1 + 192);
      v79 = *(unsigned int *)(a1 + 24);
      v80 = (_DWORD)a2 - v76 - *(_DWORD *)(a1 + 28);
      v81 = (_DWORD)a2 - v76 - v78;
      v82 = *(unsigned int *)(a1 + 36);
      if (v80 > v78 && *(_DWORD *)(a1 + 32) == 0)
        v84 = v81;
      else
        v84 = *(_DWORD *)(a1 + 28);
      v85 = v77 - v75;
      if (v77 < v75)
        v85 = 0;
      v86 = 1 << *(_DWORD *)(a1 + 204);
      v87 = *(_QWORD *)(a1 + 184);
      v88 = 0xCF1BBCDCBB000000 * *a2;
      v89 = v88 >> (66 - *(_DWORD *)(v87 + 200));
      v90 = *(_QWORD *)(v87 + 48);
      _X1 = v90 + 16 * v89;
      __asm { PRFM            #0, [X1] }
      v93 = *(_QWORD *)(a1 + 48);
      v94 = 64 - *(_DWORD *)(a1 + 200);
      if (v82 < v77)
      {
        v95 = ~(-1 << v74);
        do
        {
          v96 = 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v76 + v82)) >> v94);
          *(_DWORD *)(v73 + 4 * (v82 & v95)) = *(_DWORD *)(v93 + v96);
          *(_DWORD *)(v93 + v96) = v82++;
        }
        while (v82 < v77);
      }
      v97 = (_QWORD *)(v76 + v79);
      *(_DWORD *)(a1 + 36) = v77;
      v98 = *(_DWORD *)(v93 + 4 * (v88 >> v94));
      if (v98 < v84)
      {
        v34 = 3;
        goto LABEL_59;
      }
      v210 = v75 - 1;
      v211 = a3 - 7;
      v212 = a3 - 3;
      v213 = a2 + 1;
      v214 = v76 + 8;
      v34 = 3;
LABEL_164:
      v215 = (_QWORD *)(v76 + v98);
      if (*((unsigned __int8 *)v215 + v34) != *((unsigned __int8 *)a2 + v34))
        goto LABEL_178;
      if (v211 <= (unint64_t)a2)
      {
        v218 = a2;
        if ((unint64_t)a2 >= v212)
          goto LABEL_172;
      }
      else
      {
        v216 = *a2 ^ *v215;
        if (v216)
        {
          v217 = __clz(__rbit64(v216)) >> 3;
          if (v217 > v34)
            goto LABEL_177;
          goto LABEL_178;
        }
        v219 = 0;
        while (1)
        {
          v218 = &v213[v219];
          if ((unint64_t)&v213[v219] >= v211)
            break;
          v220 = *(_QWORD *)(v214 + v98 + v219 * 8);
          ++v219;
          v221 = *v218 ^ v220;
          if (v221)
          {
            v217 = v219 * 8 + (__clz(__rbit64(v221)) >> 3);
            v97 = (_QWORD *)(v76 + v79);
            if (v217 <= v34)
              goto LABEL_178;
LABEL_177:
            *a4 = v77 + 2 - v98;
            v34 = v217;
            if ((_QWORD *)((char *)a2 + v217) == (_QWORD *)a3)
            {
              v34 = v217;
              goto LABEL_59;
            }
LABEL_178:
            if (v98 <= v85 || (--v86, !v86) || (v98 = *(_DWORD *)(v73 + 4 * (v98 & v210)), v98 < v84))
            {
LABEL_59:
              v99 = 16 * v89;
              v100 = *(_QWORD *)(v87 + 8);
              _X10 = v100 + *(unsigned int *)(v90 + 16 * v89);
              __asm { PRFM            #0, [X10] }
              v267 = *(char **)v87;
              _X10 = v100 + *(unsigned int *)(v90 + ((16 * v89) | 4));
              __asm { PRFM            #0, [X10] }
              v105 = *(_QWORD *)v87 - v100 - v79;
              _X8 = v100 + *(unsigned int *)(v90 + ((16 * v89) | 8));
              __asm { PRFM            #0, [X8] }
              if (v86 >= 3)
                v108 = 3;
              else
                v108 = v86;
              v109 = *(unsigned int *)(v90 + (v99 | 0xC));
              v110 = v109 >> 8;
              v111 = *(_QWORD *)(v87 + 64);
              _X8 = v111 + 4 * (v109 >> 8);
              __asm { PRFM            #0, [X8] }
              if (!v108)
                goto LABEL_80;
              v114 = *(unsigned int *)(v90 + 16 * v89);
              if ((_DWORD)v114)
              {
                v255 = v77 + v105 + 2;
                if (*(_DWORD *)(v100 + v114) != *(_DWORD *)a2)
                  goto LABEL_228;
                v262 = v105;
                v238 = v109 >> 8;
                v244 = *(_DWORD *)(v90 + (v99 | 0xC));
                v249 = *(_QWORD *)(v87 + 64);
                v115 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v100 + v114 + 4), a3, v267, v97);
                LOBYTE(v109) = v244;
                v111 = v249;
                v110 = v238;
                v105 = v262;
                if (v115 + 4 <= v34
                  || (*a4 = (v255 - v114),
                      v34 = v115 + 4,
                      (_QWORD *)((char *)a2 + v115 + 4) != (_QWORD *)a3))
                {
LABEL_228:
                  if (v108 == 1)
                    goto LABEL_80;
                  v116 = *(unsigned int *)(v90 + (v99 | 4));
                  if ((_DWORD)v116)
                  {
                    if (*(_DWORD *)(v100 + v116) != *(_DWORD *)a2)
                      goto LABEL_229;
                    v263 = v105;
                    v239 = v110;
                    v245 = v109;
                    v250 = v111;
                    v117 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v100 + v116 + 4), a3, v267, v97);
                    LOBYTE(v109) = v245;
                    v111 = v250;
                    v110 = v239;
                    v105 = v263;
                    if (v117 + 4 <= v34
                      || (*a4 = (v255 - v116),
                          v34 = v117 + 4,
                          (_QWORD *)((char *)a2 + v117 + 4) != (_QWORD *)a3))
                    {
LABEL_229:
                      if (v108 == 2)
                        goto LABEL_80;
                      v118 = *(unsigned int *)(v90 + (v99 | 8));
                      if ((_DWORD)v118)
                      {
                        if (*(_DWORD *)(v100 + v118) != *(_DWORD *)a2)
                          goto LABEL_80;
                        v264 = v105;
                        v119 = v110;
                        v120 = v111;
                        v121 = v109;
                        v122 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v100 + v118 + 4), a3, v267, v97);
                        LOBYTE(v109) = v121;
                        v111 = v120;
                        v110 = v119;
                        v105 = v264;
                        if (v122 + 4 <= v34
                          || (*a4 = (v255 - v118),
                              v34 = v122 + 4,
                              (_QWORD *)((char *)a2 + v122 + 4) != (_QWORD *)a3))
                        {
LABEL_80:
                          v123 = v86 - v108 >= v109 ? v109 : v86 - v108;
                          if ((_DWORD)v123)
                          {
                            v124 = (unsigned int *)(v111 + 4 * v110);
                            v125 = v123;
                            do
                            {
                              v126 = *v124++;
                              _X10 = v100 + v126;
                              __asm { PRFM            #0, [X10] }
                              --v125;
                            }
                            while (v125);
                            v129 = *(_DWORD *)a2;
                            v130 = v77 + v105 + 2;
                            v131 = (unsigned int *)(v111 + 4 * v110);
                            do
                            {
                              v133 = *v131++;
                              v132 = v133;
                              v134 = v100 + v133;
                              if (*(_DWORD *)v134 == v129)
                              {
                                v135 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v134 + 4), a3, v267, v97);
                                if (v135 + 4 > v34)
                                {
                                  *a4 = v130 - v132;
                                  v34 = v135 + 4;
                                  if ((_QWORD *)((char *)a2 + v135 + 4) == (_QWORD *)a3)
                                    break;
                                }
                              }
                              LODWORD(v123) = v123 - 1;
                            }
                            while ((_DWORD)v123);
                          }
                        }
                      }
                    }
                  }
                }
              }
              return v34;
            }
            goto LABEL_164;
          }
        }
        v215 = (_QWORD *)(v214 + v98 + v219 * 8);
        if ((unint64_t)v218 >= v212)
        {
LABEL_172:
          if ((unint64_t)v218 < a3 - 1)
          {
            if (*(unsigned __int16 *)v215 == *(unsigned __int16 *)v218)
            {
              v218 = (_QWORD *)((char *)v218 + 2);
              v215 = (_QWORD *)((char *)v215 + 2);
            }
            if ((unint64_t)v218 >= a3)
            {
LABEL_176:
              v97 = (_QWORD *)(v76 + v79);
              v217 = (char *)v218 - (char *)a2;
              if (v217 > v34)
                goto LABEL_177;
              goto LABEL_178;
            }
          }
          else if ((unint64_t)v218 >= a3)
          {
            goto LABEL_176;
          }
          if (*(unsigned __int8 *)v215 == *(unsigned __int8 *)v218)
            v218 = (_QWORD *)((char *)v218 + 1);
          goto LABEL_176;
        }
      }
      if (*(_DWORD *)v215 == *(_DWORD *)v218)
      {
        v218 = (_QWORD *)((char *)v218 + 4);
        v215 = (_QWORD *)((char *)v215 + 4);
      }
      goto LABEL_172;
    }
    v148 = *(_QWORD *)(a1 + 64);
    v149 = *(_DWORD *)(a1 + 196);
    v150 = 1 << v149;
    v151 = *(_QWORD *)(a1 + 8);
    v152 = (_DWORD)a2 - v151;
    v153 = 1 << *(_DWORD *)(a1 + 192);
    v154 = *(unsigned int *)(a1 + 24);
    v155 = *(unsigned int *)(a1 + 36);
    if ((int)a2 - (int)v151 - *(_DWORD *)(a1 + 28) > v153 && *(_DWORD *)(a1 + 32) == 0)
      v157 = (_DWORD)a2 - v151 - v153;
    else
      v157 = *(_DWORD *)(a1 + 28);
    v158 = v152 - v150;
    if (v152 < v150)
      v158 = 0;
    v159 = 1 << *(_DWORD *)(a1 + 204);
    v160 = *(_QWORD *)(a1 + 184);
    v161 = *(_DWORD *)a2;
    v162 = -1640531535 * *(_DWORD *)a2;
    v163 = v162 >> (34 - *(_DWORD *)(v160 + 200));
    v164 = *(_QWORD *)(v160 + 48);
    _X15 = v164 + 16 * v163;
    __asm { PRFM            #0, [X15] }
    v167 = *(_QWORD *)(a1 + 48);
    v168 = 32 - *(_DWORD *)(a1 + 200);
    if (v155 < v152)
    {
      v169 = ~(-1 << v149);
      do
      {
        v170 = 4 * ((-1640531535 * *(_DWORD *)(v151 + v155)) >> v168);
        *(_DWORD *)(v148 + 4 * (v155 & v169)) = *(_DWORD *)(v167 + v170);
        *(_DWORD *)(v167 + v170) = v155++;
      }
      while (v155 < v152);
      v161 = *(_DWORD *)a2;
      v162 = -1640531535 * *(_DWORD *)a2;
    }
    v268 = (_QWORD *)(v151 + v154);
    v171 = 4 * v163;
    *(_DWORD *)(a1 + 36) = v152;
    v172 = *(_DWORD *)(v167 + 4 * (v162 >> v168));
    if (v172 < v157)
    {
      v34 = 3;
      goto LABEL_133;
    }
    v222 = v150 - 1;
    v223 = a3 - 7;
    v224 = a3 - 3;
    v225 = a2 + 1;
    v226 = v151 + 8;
    v34 = 3;
LABEL_194:
    v227 = (_QWORD *)(v151 + v172);
    if (*((unsigned __int8 *)v227 + v34) != *((unsigned __int8 *)a2 + v34))
      goto LABEL_208;
    if (v223 <= (unint64_t)a2)
    {
      v230 = a2;
      if ((unint64_t)a2 >= v224)
        goto LABEL_202;
    }
    else
    {
      v228 = *a2 ^ *v227;
      if (v228)
      {
        v229 = __clz(__rbit64(v228)) >> 3;
        if (v229 > v34)
          goto LABEL_207;
        goto LABEL_208;
      }
      v231 = 0;
      while (1)
      {
        v230 = &v225[v231];
        if ((unint64_t)&v225[v231] >= v223)
          break;
        v232 = *(_QWORD *)(v226 + v172 + v231 * 8);
        ++v231;
        v233 = *v230 ^ v232;
        if (v233)
        {
          v229 = v231 * 8 + (__clz(__rbit64(v233)) >> 3);
          if (v229 <= v34)
            goto LABEL_208;
LABEL_207:
          *a4 = v152 + 2 - v172;
          v34 = v229;
          if ((_QWORD *)((char *)a2 + v229) == (_QWORD *)a3)
          {
            v34 = v229;
            goto LABEL_133;
          }
LABEL_208:
          if (v172 <= v158 || (--v159, !v159) || (v172 = *(_DWORD *)(v148 + 4 * (v172 & v222)), v172 < v157))
          {
LABEL_133:
            v173 = 4 * v171;
            v175 = *(char **)v160;
            v174 = *(_QWORD *)(v160 + 8);
            _X10 = v174 + *(unsigned int *)(v164 + 4 * v171);
            __asm { PRFM            #0, [X10] }
            _X10 = v174 + *(unsigned int *)(v164 + ((4 * v171) | 4));
            __asm { PRFM            #0, [X10] }
            v180 = *(_QWORD *)v160 - v174 - v154;
            _X8 = v174 + *(unsigned int *)(v164 + ((4 * v171) | 8));
            __asm { PRFM            #0, [X8] }
            if (v159 >= 3)
              v183 = 3;
            else
              v183 = v159;
            v184 = *(unsigned int *)(v164 + (v173 | 0xC));
            v185 = v184 >> 8;
            v186 = *(_QWORD *)(v160 + 64);
            _X8 = v186 + 4 * (v184 >> 8);
            __asm { PRFM            #0, [X8] }
            if (!v183)
              goto LABEL_154;
            v265 = v164;
            v189 = *(unsigned int *)(v164 + 4 * v171);
            if ((_DWORD)v189)
            {
              v246 = v152 + v180 + 2;
              if (*(_DWORD *)(v174 + v189) != v161)
                goto LABEL_230;
              v256 = v184 >> 8;
              v234 = v180;
              v240 = *(_QWORD *)(v160 + 64);
              v251 = v184;
              v190 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v174 + v189 + 4), a3, v175, v268);
              LOBYTE(v184) = v251;
              v185 = v256;
              v186 = v240;
              v180 = v234;
              if (v190 + 4 <= v34
                || (*a4 = (v246 - v189), v34 = v190 + 4, (_QWORD *)((char *)a2 + v190 + 4) != (_QWORD *)a3))
              {
LABEL_230:
                if (v183 == 1)
                  goto LABEL_154;
                v191 = *(unsigned int *)(v265 + (v173 | 4));
                if ((_DWORD)v191)
                {
                  if (*(_DWORD *)(v174 + v191) != v161)
                    goto LABEL_231;
                  v257 = v185;
                  v235 = v180;
                  v241 = v186;
                  v252 = v184;
                  v192 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v174 + v191 + 4), a3, v175, v268);
                  LOBYTE(v184) = v252;
                  v185 = v257;
                  v186 = v241;
                  v180 = v235;
                  if (v192 + 4 <= v34
                    || (*a4 = (v246 - v191),
                        v34 = v192 + 4,
                        (_QWORD *)((char *)a2 + v192 + 4) != (_QWORD *)a3))
                  {
LABEL_231:
                    if (v183 == 2)
                      goto LABEL_154;
                    v193 = *(unsigned int *)(v265 + (v173 | 8));
                    if ((_DWORD)v193)
                    {
                      if (*(_DWORD *)(v174 + v193) != v161)
                        goto LABEL_154;
                      v258 = v185;
                      v194 = v180;
                      v195 = v186;
                      v253 = v184;
                      v196 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v174 + v193 + 4), a3, v175, v268);
                      LOBYTE(v184) = v253;
                      v185 = v258;
                      v186 = v195;
                      v180 = v194;
                      if (v196 + 4 <= v34
                        || (*a4 = (v246 - v193),
                            v34 = v196 + 4,
                            (_QWORD *)((char *)a2 + v196 + 4) != (_QWORD *)a3))
                      {
LABEL_154:
                        v197 = v159 - v183 >= v184 ? v184 : v159 - v183;
                        if ((_DWORD)v197)
                        {
                          v198 = (unsigned int *)(v186 + 4 * v185);
                          v199 = v197;
                          do
                          {
                            v200 = *v198++;
                            _X10 = v174 + v200;
                            __asm { PRFM            #0, [X10] }
                            --v199;
                          }
                          while (v199);
                          v203 = v152 + v180 + 2;
                          v204 = (unsigned int *)(v186 + 4 * v185);
                          do
                          {
                            v206 = *v204++;
                            v205 = v206;
                            v207 = v174 + v206;
                            if (*(_DWORD *)v207 == v161)
                            {
                              v208 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v207 + 4), a3, v175, v268);
                              if (v208 + 4 > v34)
                              {
                                *a4 = v203 - v205;
                                v34 = v208 + 4;
                                if ((_QWORD *)((char *)a2 + v208 + 4) == (_QWORD *)a3)
                                  break;
                              }
                            }
                            LODWORD(v197) = v197 - 1;
                          }
                          while ((_DWORD)v197);
                        }
                      }
                    }
                  }
                }
              }
            }
            return v34;
          }
          goto LABEL_194;
        }
      }
      v227 = (_QWORD *)(v226 + v172 + v231 * 8);
      if ((unint64_t)v230 >= v224)
      {
LABEL_202:
        if ((unint64_t)v230 < a3 - 1)
        {
          if (*(unsigned __int16 *)v227 == *(unsigned __int16 *)v230)
          {
            v230 = (_QWORD *)((char *)v230 + 2);
            v227 = (_QWORD *)((char *)v227 + 2);
          }
          if ((unint64_t)v230 >= a3)
          {
LABEL_206:
            v229 = (char *)v230 - (char *)a2;
            if (v229 > v34)
              goto LABEL_207;
            goto LABEL_208;
          }
        }
        else if ((unint64_t)v230 >= a3)
        {
          goto LABEL_206;
        }
        if (*(unsigned __int8 *)v227 == *(unsigned __int8 *)v230)
          v230 = (_QWORD *)((char *)v230 + 1);
        goto LABEL_206;
      }
    }
    if (*(_DWORD *)v227 == *(_DWORD *)v230)
    {
      v230 = (_QWORD *)((char *)v230 + 4);
      v227 = (_QWORD *)((char *)v227 + 4);
    }
    goto LABEL_202;
  }
  v6 = *(_QWORD *)(a1 + 64);
  v7 = *(_DWORD *)(a1 + 196);
  v8 = 1 << v7;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = (_DWORD)a2 - v9;
  v11 = 1 << *(_DWORD *)(a1 + 192);
  v12 = *(unsigned int *)(a1 + 24);
  v13 = (_DWORD)a2 - v9 - *(_DWORD *)(a1 + 28);
  v14 = (_DWORD)a2 - v9 - v11;
  v15 = *(unsigned int *)(a1 + 36);
  if (v13 > v11 && *(_DWORD *)(a1 + 32) == 0)
    v17 = v14;
  else
    v17 = *(_DWORD *)(a1 + 28);
  v18 = v10 - v8;
  if (v10 < v8)
    v18 = 0;
  v19 = 1 << *(_DWORD *)(a1 + 204);
  v20 = *(_QWORD *)(a1 + 184);
  v21 = 0xCF1BBCDCBF9B0000 * *a2;
  v22 = v21 >> (66 - *(_DWORD *)(v20 + 200));
  v23 = *(_QWORD *)(v20 + 48);
  _X1 = v23 + 16 * v22;
  __asm { PRFM            #0, [X1] }
  v29 = *(_QWORD *)(a1 + 48);
  v30 = 64 - *(_DWORD *)(a1 + 200);
  if (v15 < v10)
  {
    v31 = ~(-1 << v7);
    do
    {
      v32 = 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v9 + v15)) >> v30);
      *(_DWORD *)(v6 + 4 * (v15 & v31)) = *(_DWORD *)(v29 + v32);
      *(_DWORD *)(v29 + v32) = v15++;
    }
    while (v15 < v10);
  }
  v266 = (_QWORD *)(v9 + v12);
  *(_DWORD *)(a1 + 36) = v10;
  v33 = *(_DWORD *)(v29 + 4 * (v21 >> v30));
  if (v33 < v17)
  {
    v34 = 3;
    goto LABEL_15;
  }
  v136 = v8 - 1;
  v137 = a3 - 7;
  v138 = a3 - 3;
  v139 = a2 + 1;
  v140 = v9 + 8;
  v34 = 3;
  while (1)
  {
    v141 = (_DWORD *)(v9 + v33);
    if (*((unsigned __int8 *)v141 + v34) != *((unsigned __int8 *)a2 + v34))
      goto LABEL_104;
    if (v137 <= (unint64_t)a2)
    {
      v144 = a2;
      if ((unint64_t)a2 < v138)
      {
LABEL_96:
        if (*v141 == *v144)
        {
          ++v144;
          ++v141;
        }
      }
      goto LABEL_98;
    }
    v142 = *a2 ^ *(_QWORD *)v141;
    if (!v142)
      break;
    v143 = __clz(__rbit64(v142)) >> 3;
    if (v143 > v34)
      goto LABEL_103;
LABEL_104:
    if (v33 > v18)
    {
      if (--v19)
      {
        v33 = *(_DWORD *)(v6 + 4 * (v33 & v136));
        if (v33 >= v17)
          continue;
      }
    }
    goto LABEL_15;
  }
  v145 = 0;
  while (1)
  {
    v144 = &v139[v145];
    if ((unint64_t)&v139[v145] >= v137)
      break;
    v146 = *(_QWORD *)(v140 + v33 + v145 * 8);
    ++v145;
    v147 = *(_QWORD *)v144 ^ v146;
    if (v147)
    {
      v143 = v145 * 8 + (__clz(__rbit64(v147)) >> 3);
      if (v143 > v34)
        goto LABEL_103;
      goto LABEL_104;
    }
  }
  v141 = (_DWORD *)(v140 + v33 + v145 * 8);
  if ((unint64_t)v144 < v138)
    goto LABEL_96;
LABEL_98:
  if ((unint64_t)v144 >= a3 - 1)
  {
    if ((unint64_t)v144 >= a3)
      goto LABEL_102;
    goto LABEL_100;
  }
  if (*(unsigned __int16 *)v141 == *(unsigned __int16 *)v144)
  {
    v144 = (_DWORD *)((char *)v144 + 2);
    v141 = (_DWORD *)((char *)v141 + 2);
  }
  if ((unint64_t)v144 < a3)
  {
LABEL_100:
    if (*(unsigned __int8 *)v141 == *(unsigned __int8 *)v144)
      v144 = (_DWORD *)((char *)v144 + 1);
  }
LABEL_102:
  v143 = (char *)v144 - (char *)a2;
  if (v143 <= v34)
    goto LABEL_104;
LABEL_103:
  *a4 = v10 + 2 - v33;
  v34 = v143;
  if ((_QWORD *)((char *)a2 + v143) != (_QWORD *)a3)
    goto LABEL_104;
  v34 = v143;
LABEL_15:
  v35 = 16 * v22;
  v37 = *(char **)v20;
  v36 = *(_QWORD *)(v20 + 8);
  _X10 = v36 + *(unsigned int *)(v23 + 16 * v22);
  __asm { PRFM            #0, [X10] }
  _X10 = v36 + *(unsigned int *)(v23 + ((16 * v22) | 4));
  __asm { PRFM            #0, [X10] }
  v42 = *(_QWORD *)v20 - v36 - v12;
  _X8 = v36 + *(unsigned int *)(v23 + ((16 * v22) | 8));
  __asm { PRFM            #0, [X8] }
  if (v19 >= 3)
    v45 = 3;
  else
    v45 = v19;
  v46 = *(unsigned int *)(v23 + (v35 | 0xC));
  v47 = v46 >> 8;
  v48 = *(_QWORD *)(v20 + 64);
  _X8 = v48 + 4 * (v46 >> 8);
  __asm { PRFM            #0, [X8] }
  if (!v45)
    goto LABEL_36;
  v51 = *(unsigned int *)(v23 + 16 * v22);
  if ((_DWORD)v51)
  {
    v254 = v10 + v42 + 2;
    if (*(_DWORD *)(v36 + v51) != *(_DWORD *)a2)
      goto LABEL_232;
    v259 = *(_DWORD *)(v23 + (v35 | 0xC));
    v236 = v42;
    v242 = *(_QWORD *)(v20 + 64);
    v247 = v46 >> 8;
    v52 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v36 + v51 + 4), a3, v37, v266);
    LOBYTE(v46) = v259;
    v48 = v242;
    v47 = v247;
    v42 = v236;
    if (v52 + 4 <= v34
      || (*a4 = (v254 - v51), v34 = v52 + 4, (_QWORD *)((char *)a2 + v52 + 4) != (_QWORD *)a3))
    {
LABEL_232:
      if (v45 == 1)
        goto LABEL_36;
      v53 = *(unsigned int *)(v23 + (v35 | 4));
      if ((_DWORD)v53)
      {
        if (*(_DWORD *)(v36 + v53) != *(_DWORD *)a2)
          goto LABEL_233;
        v260 = v46;
        v237 = v42;
        v243 = v48;
        v248 = v47;
        v54 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v36 + v53 + 4), a3, v37, v266);
        LOBYTE(v46) = v260;
        v48 = v243;
        v47 = v248;
        v42 = v237;
        if (v54 + 4 <= v34
          || (*a4 = (v254 - v53), v34 = v54 + 4, (_QWORD *)((char *)a2 + v54 + 4) != (_QWORD *)a3))
        {
LABEL_233:
          if (v45 == 2)
            goto LABEL_36;
          v55 = *(unsigned int *)(v23 + (v35 | 8));
          if ((_DWORD)v55)
          {
            if (*(_DWORD *)(v36 + v55) != *(_DWORD *)a2)
              goto LABEL_36;
            v261 = v46;
            v56 = v42;
            v57 = v47;
            v58 = v48;
            v59 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v36 + v55 + 4), a3, v37, v266);
            LOBYTE(v46) = v261;
            v48 = v58;
            v47 = v57;
            v42 = v56;
            if (v59 + 4 <= v34
              || (*a4 = (v254 - v55), v34 = v59 + 4, (_QWORD *)((char *)a2 + v59 + 4) != (_QWORD *)a3))
            {
LABEL_36:
              v60 = v19 - v45 >= v46 ? v46 : v19 - v45;
              if ((_DWORD)v60)
              {
                v61 = (unsigned int *)(v48 + 4 * v47);
                v62 = v60;
                do
                {
                  v63 = *v61++;
                  _X10 = v36 + v63;
                  __asm { PRFM            #0, [X10] }
                  --v62;
                }
                while (v62);
                v66 = *(_DWORD *)a2;
                v67 = v10 + v42 + 2;
                v68 = (unsigned int *)(v48 + 4 * v47);
                do
                {
                  v70 = *v68++;
                  v69 = v70;
                  v71 = v36 + v70;
                  if (*(_DWORD *)v71 == v66)
                  {
                    v72 = ZSTD_count_2segments((_QWORD *)((char *)a2 + 4), (char *)(v71 + 4), a3, v37, v266);
                    if (v72 + 4 > v34)
                    {
                      *a4 = v67 - v69;
                      v34 = v72 + 4;
                      if ((_QWORD *)((char *)a2 + v72 + 4) == (_QWORD *)a3)
                        break;
                    }
                  }
                  LODWORD(v60) = v60 - 1;
                }
                while ((_DWORD)v60);
              }
            }
          }
        }
      }
    }
  }
  return v34;
}

unint64_t ZSTD_DUBT_findBestMatch(uint64_t a1, uint64_t *a2, unint64_t a3, _QWORD *a4, int a5, int a6)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int *v28;
  unsigned int v29;
  BOOL v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  unsigned int *v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  char *v45;
  char *v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  uint64_t v57;
  unsigned int *v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  uint64_t v64;
  char *v65;
  char *v66;
  char *v67;
  unint64_t v68;
  char *v69;
  unsigned int *v70;
  unsigned int v71;
  uint64_t v72;
  char *v73;
  char *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unsigned int *v78;
  unsigned int *v79;
  int v80;
  unsigned int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t *v86;
  unsigned int v87;
  unint64_t v88;
  char *v89;
  uint64_t v90;
  char *v91;
  unsigned int *v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t v97;
  _DWORD *v98;
  unint64_t v99;
  _DWORD *v100;
  unsigned int *v101;
  uint64_t v102;
  char *v103;
  char *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  uint64_t v109;
  unsigned int v110;
  unint64_t v111;
  char *v112;
  uint64_t v113;
  uint64_t v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  unsigned int v118;
  unint64_t v119;
  int v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t v123;
  char *v124;
  unint64_t v125;
  unint64_t v126;
  uint64_t v127;
  unsigned int *v128;
  int v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  uint64_t v139;
  uint64_t v140;
  int v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  uint64_t v147;
  _QWORD *v148;
  _QWORD *v149;
  uint64_t v150;
  int v151;
  unsigned int v152;
  unint64_t v153;
  unint64_t v154;
  int v155;
  uint64_t v156;
  unsigned int v157;
  int v158;
  int v159;
  unsigned int v160;
  _QWORD *v161;
  unsigned int v162;
  char *v164;
  char *v165;
  uint64_t v166;
  uint64_t v167;
  unint64_t v168;
  uint64_t v169;
  unsigned int *v170;
  unint64_t v171;
  unsigned int v172;
  unsigned int *v173;
  _QWORD *v174;
  char *v175;
  int v176;
  unint64_t v177;
  char *v178;
  unint64_t v179;
  int v180;
  _DWORD v181[3];

  v6 = *(_QWORD *)(a1 + 48);
  v7 = *(_DWORD *)(a1 + 200);
  v8 = a5 - 5;
  switch(a5)
  {
    case 5:
      v9 = (int)a2;
      v10 = *a2;
      v11 = -1157627904;
      goto LABEL_7;
    case 6:
      v9 = (int)a2;
      v10 = *a2;
      v11 = -1080360960;
      goto LABEL_7;
    case 7:
      v9 = (int)a2;
      v10 = *a2;
      v11 = -1079680256;
      goto LABEL_7;
    case 8:
      v9 = (int)a2;
      v10 = *a2;
      v11 = -1213897629;
LABEL_7:
      v12 = (v10 * (v11 | 0xCF1BBCDC00000000)) >> -(char)v7;
      break;
    default:
      v9 = (int)a2;
      v12 = (-1640531535 * *(_DWORD *)a2) >> -(char)v7;
      break;
  }
  v13 = *(_QWORD *)(a1 + 8);
  v14 = v9 - v13;
  v15 = *(_DWORD *)(a1 + 196);
  v16 = 1 << *(_DWORD *)(a1 + 192);
  if (v14 - *(_DWORD *)(a1 + 28) > v16 && *(_DWORD *)(a1 + 32) == 0)
    v18 = v14 - v16;
  else
    v18 = *(_DWORD *)(a1 + 28);
  v19 = *(_QWORD *)(a1 + 64);
  v20 = ~(-1 << (v15 - 1));
  v21 = v14 + (-1 << (v15 - 1)) + 1;
  if (v14 < v20)
    v21 = 0;
  v135 = v18;
  v136 = v21;
  if (v21 <= v18)
    v22 = v18;
  else
    v22 = v21;
  v23 = 1 << *(_DWORD *)(a1 + 204);
  v24 = *(_DWORD *)(v6 + 4 * v12);
  v140 = a1;
  v144 = *(_QWORD *)(a1 + 64);
  v145 = *(_QWORD *)(a1 + 8);
  v155 = a6;
  v141 = ~(-1 << (v15 - 1));
  v134 = v14;
  v133 = v8;
  if (v24 <= v22)
    goto LABEL_92;
  v25 = 0;
  v26 = 1 << *(_DWORD *)(a1 + 204);
  do
  {
    v27 = v24;
    v28 = (unsigned int *)(v19 + 8 * (v24 & v20));
    v29 = v28[1];
    v30 = v29 == 1 && v26 >= 2;
    if (!v30)
      break;
    v28[1] = v25;
    --v26;
    v24 = *v28;
    v25 = v27;
  }
  while (v24 > v22);
  if (v29 == 1)
    *(_QWORD *)v28 = 0;
  v27 = v25;
  if (!v25)
  {
LABEL_92:
    v31 = *(_QWORD *)(a1 + 16);
    goto LABEL_94;
  }
  v130 = v23;
  v131 = v12;
  v132 = v6;
  v139 = v19 + 4;
  v31 = *(_QWORD *)(a1 + 16);
  v142 = v31;
  do
  {
    v33 = v27;
    v34 = *(_DWORD *)(v139 + 8 * (v27 & v20));
    v35 = *(_DWORD *)(a1 + 192);
    v36 = -1 << (*(_BYTE *)(a1 + 196) - 1);
    v37 = *(unsigned int *)(a1 + 24);
    v38 = *(_DWORD *)(a1 + 28);
    if (v37 <= v33)
      v39 = v13;
    else
      v39 = v31;
    v164 = (char *)(v31 + v37);
    if (v37 <= v33)
      v40 = a3;
    else
      v40 = v31 + v37;
    v32 = (unsigned int *)(v19 + 8 * (v33 & ~v36));
    v41 = v32 + 1;
    v42 = *v32;
    v181[0] = 0;
    v43 = 1 << v35;
    if (v33 - v38 <= v43)
      v44 = v38;
    else
      v44 = v33 - v43;
    v157 = v34;
    v160 = v26;
    if (v26 && v42 > v44)
    {
      v45 = 0;
      v46 = 0;
      v47 = ~v36;
      v48 = v33;
      v49 = v39 + v33;
      v148 = (_QWORD *)(v13 + v37);
      v50 = v40 - 7;
      v51 = v40 - 3;
      v52 = v40 - 1;
      v143 = v49 + 8;
      v172 = v44;
      v152 = v33;
      v153 = v37;
      v150 = v49;
      v146 = v40 - 3;
      while (1)
      {
        if (v46 >= v45)
          v53 = v45;
        else
          v53 = v46;
        v54 = v13;
        v175 = v46;
        v178 = v45;
        if (a6 != 1)
          goto LABEL_61;
        v55 = (unint64_t)&v53[v42];
        if (v37 > v48 || v55 >= v37)
          break;
        v167 = v31 + v42;
        v170 = v41;
        v56 = &v53[v49];
        v57 = v22;
        v58 = v32;
        v59 = v40;
        v60 = v50;
        v61 = v47;
        v62 = ZSTD_count_2segments(v56, &v53[v167], v40, v164, v148);
        v47 = v61;
        v50 = v60;
        v40 = v59;
        v48 = v152;
        v37 = v153;
        v32 = v58;
        v22 = v57;
        v49 = v150;
        v31 = v142;
        v13 = v145;
        v51 = v146;
        v19 = v144;
        a6 = v155;
        v63 = &v53[v62];
        v30 = (unint64_t)&v53[v62 + v42] >= v153;
        v64 = v167;
        v41 = v170;
        if (v30)
          v64 = v145 + v42;
        v65 = &v63[v150];
        if (&v63[v150] == (char *)v40)
          goto LABEL_33;
LABEL_77:
        v70 = (unsigned int *)(v19 + 8 * (v42 & v47));
        if (v63[v64] >= *v65)
        {
          *v41 = v42;
          if (v42 <= v22)
          {
            v41 = v181;
            goto LABEL_33;
          }
          v45 = v63;
          v41 = (unsigned int *)(v19 + 8 * (v42 & v47));
          v71 = v172;
          v46 = v175;
          if (!--v26)
            goto LABEL_33;
        }
        else
        {
          *v32 = v42;
          if (v42 <= v22)
          {
            v32 = v181;
            goto LABEL_33;
          }
          v32 = v70 + 1;
          v46 = v63;
          ++v70;
          v71 = v172;
          v45 = v178;
          if (!--v26)
            goto LABEL_33;
        }
        v42 = *v70;
        if (*v70 <= v71)
          goto LABEL_33;
      }
      if (v55 >= v37)
        v54 = v13;
      else
        v54 = v31;
LABEL_61:
      v64 = v54 + v42;
      v66 = &v53[v49];
      v67 = &v53[v64];
      if (v50 <= (unint64_t)&v53[v49])
      {
        v69 = &v53[v49];
        if ((unint64_t)v66 < v51)
        {
LABEL_66:
          if (*(_DWORD *)v67 == *(_DWORD *)v69)
          {
            v69 += 4;
            v67 += 4;
          }
        }
      }
      else
      {
        v68 = *(_QWORD *)v66 ^ *(_QWORD *)v67;
        if (v68)
        {
          v63 = &v53[__clz(__rbit64(v68)) >> 3];
          v65 = &v63[v49];
          if (&v63[v49] == (char *)v40)
            goto LABEL_33;
          goto LABEL_77;
        }
        v72 = 0;
        v73 = &v53[v143];
        while (1)
        {
          v74 = &v73[v72];
          if ((unint64_t)&v73[v72] >= v50)
            break;
          v75 = *(_QWORD *)&v53[v42 + 8 + v54 + v72];
          v72 += 8;
          v76 = *(_QWORD *)v74 ^ v75;
          if (v76)
          {
            v63 = &v53[v72 + (__clz(__rbit64(v76)) >> 3)];
            v65 = &v63[v49];
            if (&v63[v49] != (char *)v40)
              goto LABEL_77;
            goto LABEL_33;
          }
        }
        v69 = &v53[v143 + v72];
        v67 = &v53[v42 + 8 + v54 + v72];
        if ((unint64_t)v69 < v51)
          goto LABEL_66;
      }
      if ((unint64_t)v69 >= v52)
      {
        if ((unint64_t)v69 >= v40)
          goto LABEL_76;
      }
      else
      {
        if (*(unsigned __int16 *)v67 == *(unsigned __int16 *)v69)
        {
          v69 += 2;
          v67 += 2;
        }
        if ((unint64_t)v69 >= v40)
        {
LABEL_76:
          v63 = &v69[-v49];
          v65 = v69;
          if (v69 == (char *)v40)
            goto LABEL_33;
          goto LABEL_77;
        }
      }
      if (*v67 == *v69)
        ++v69;
      goto LABEL_76;
    }
LABEL_33:
    *v41 = 0;
    *v32 = 0;
    v27 = v157;
    v26 = v160 + 1;
    a1 = v140;
    v20 = v141;
  }
  while (v157);
  v14 = v134;
  v12 = v131;
  v6 = v132;
  v23 = v130;
LABEL_94:
  v77 = *(unsigned int *)(a1 + 24);
  v78 = (unsigned int *)(v19 + 8 * (v20 & v14));
  v79 = v78 + 1;
  v80 = v14 + 9;
  v180 = 0;
  v81 = *(_DWORD *)(v6 + 4 * v12);
  *(_DWORD *)(v6 + 4 * v12) = v14;
  v82 = v23 - 1;
  if (v81 <= v135)
  {
    v179 = 0;
    v86 = a2;
    goto LABEL_144;
  }
  v179 = 0;
  v83 = 0;
  v84 = 0;
  v165 = (char *)(v31 + v77);
  v161 = (_QWORD *)(v13 + v77);
  v85 = a3 - 7;
  v154 = a3 - 3;
  v158 = v14 + 1;
  v151 = v14 + 2;
  v86 = a2;
  v147 = v13 + 8;
  v149 = a2 + 1;
  v87 = v135;
  while (2)
  {
    if (v84 >= v83)
      v88 = v83;
    else
      v88 = v84;
    v89 = (char *)v86 + v88;
    v176 = v82;
    if (a6 != 1 || v88 + v81 >= v77)
    {
      v97 = v13 + v81;
      v98 = (_DWORD *)(v97 + v88);
      if (v85 <= (unint64_t)v89)
      {
        v100 = (_DWORD *)((char *)v86 + v88);
        if ((unint64_t)v89 < v154)
        {
LABEL_117:
          if (*v98 == *v100)
          {
            ++v100;
            ++v98;
          }
        }
      }
      else
      {
        v99 = *(_QWORD *)v89 ^ *(_QWORD *)v98;
        if (v99)
        {
          v86 = a2;
          v96 = (__clz(__rbit64(v99)) >> 3) + v88;
          if (v96 > v179)
            break;
          goto LABEL_128;
        }
        v102 = 0;
        v103 = (char *)v149 + v88;
        while (1)
        {
          v104 = &v103[v102];
          if ((unint64_t)&v103[v102] >= v85)
            break;
          v105 = *(_QWORD *)(v147 + v88 + v81 + v102);
          v102 += 8;
          v106 = *(_QWORD *)v104 ^ v105;
          if (v106)
          {
            v86 = a2;
            v96 = v102 + (__clz(__rbit64(v106)) >> 3) + v88;
            if (v96 <= v179)
              goto LABEL_128;
            goto LABEL_106;
          }
        }
        v100 = (_DWORD *)((char *)v149 + v88 + v102);
        v98 = (_DWORD *)(v147 + v88 + v81 + v102);
        if ((unint64_t)v100 < v154)
          goto LABEL_117;
      }
      if ((unint64_t)v100 >= a3 - 1)
      {
        if ((unint64_t)v100 >= a3)
          goto LABEL_127;
      }
      else
      {
        if (*(unsigned __int16 *)v98 == *(unsigned __int16 *)v100)
        {
          v100 = (_DWORD *)((char *)v100 + 2);
          v98 = (_DWORD *)((char *)v98 + 2);
        }
        if ((unint64_t)v100 >= a3)
        {
LABEL_127:
          v86 = a2;
          v96 = (char *)v100 - v89 + v88;
          if (v96 > v179)
            break;
          goto LABEL_128;
        }
      }
      if (*(unsigned __int8 *)v98 == *(unsigned __int8 *)v100)
        v100 = (_DWORD *)((char *)v100 + 1);
      goto LABEL_127;
    }
    v173 = v78;
    v90 = v31 + v81;
    v91 = (char *)(v90 + v88);
    v92 = v79;
    v93 = v31;
    v168 = v88;
    v94 = v85;
    v95 = ZSTD_count_2segments(v89, v91, a3, v165, v161);
    v85 = v94;
    v31 = v93;
    v79 = v92;
    v19 = v144;
    v13 = v145;
    v87 = v135;
    v96 = v95 + v168;
    if (v95 + v168 + v81 >= v77)
      v97 = v145 + v81;
    else
      v97 = v90;
    v78 = v173;
    v20 = v141;
    v86 = a2;
    if (v96 <= v179)
    {
LABEL_128:
      a6 = v155;
      v82 = v176;
LABEL_129:
      v101 = (unsigned int *)(v19 + 8 * (v81 & v20));
      if (*(unsigned __int8 *)(v97 + v96) >= *((unsigned __int8 *)v86 + v96))
      {
        *v79 = v81;
        if (v81 <= v136)
        {
          v79 = (unsigned int *)&v180;
          goto LABEL_144;
        }
        v83 = v96;
        v79 = (unsigned int *)(v19 + 8 * (v81 & v20));
        v30 = v82-- != 0;
        if (!v30)
          goto LABEL_144;
      }
      else
      {
        *v78 = v81;
        if (v81 <= v136)
        {
          v78 = (unsigned int *)&v180;
          goto LABEL_144;
        }
        ++v101;
        v84 = v96;
        v78 = v101;
        v30 = v82-- != 0;
        if (!v30)
          goto LABEL_144;
      }
      v81 = *v101;
      if (*v101 <= v87)
        goto LABEL_144;
      continue;
    }
    break;
  }
LABEL_106:
  if (v96 > v80 - v81)
    v80 = v81 + v96;
  if ((int)((__clz(v158 - v81) ^ 0x1F) + (__clz(*(_DWORD *)a4 + 1) ^ 0xFFFFFFE0) + 1) < 4 * ((int)v96 - (int)v179))
  {
    *a4 = v151 - v81;
    v179 = v96;
  }
  a6 = v155;
  v82 = v176;
  if ((uint64_t *)((char *)v86 + v96) != (uint64_t *)a3)
    goto LABEL_129;
  if (v155 == 2)
    v82 = 0;
LABEL_144:
  *v79 = 0;
  *v78 = 0;
  v159 = v80;
  if (a6 == 2 && v82)
  {
    v107 = *(_QWORD *)(v140 + 184);
    v108 = *(_DWORD *)(v107 + 200);
    switch(v133)
    {
      case 0:
        v109 = *v86;
        v110 = -1157627904;
        goto LABEL_156;
      case 1:
        v109 = *v86;
        v110 = -1080360960;
        goto LABEL_156;
      case 2:
        v109 = *v86;
        v110 = -1079680256;
        goto LABEL_156;
      case 3:
        v109 = *v86;
        v110 = -1213897629;
LABEL_156:
        v111 = (v109 * (v110 | 0xCF1BBCDC00000000)) >> -(char)v108;
        break;
      default:
        v111 = (-1640531535 * *(_DWORD *)v86) >> -(char)v108;
        break;
    }
    v112 = *(char **)v107;
    v113 = *(_QWORD *)(v107 + 8);
    v114 = *(_QWORD *)v107 - v113;
    v115 = *(_DWORD *)(v107 + 28);
    v116 = ~(-1 << (*(_DWORD *)(v107 + 196) - 1));
    v117 = v114 - v115 <= v116 ? *(_DWORD *)(v107 + 28) : v114 + (-1 << (*(_DWORD *)(v107 + 196) - 1)) + 1;
    v118 = *(_DWORD *)(*(_QWORD *)(v107 + 48) + 4 * v111);
    if (v118 > v115)
    {
      v162 = *(_DWORD *)(v107 + 28);
      v119 = 0;
      v177 = 0;
      v174 = (_QWORD *)(v13 + *(unsigned int *)(v140 + 24));
      v171 = (*(_DWORD *)v107 - v113);
      v166 = *(_QWORD *)(v107 + 64);
      v156 = (*(_DWORD *)(v140 + 28) - v114);
      v169 = v13 + v156;
      v120 = v82 - 1;
      do
      {
        if (v177 >= v119)
          v121 = v119;
        else
          v121 = v177;
        v122 = v113;
        v123 = v113 + v118;
        v124 = v112;
        v125 = ZSTD_count_2segments((uint64_t *)((char *)v86 + v121), (char *)(v123 + v121), a3, v112, v174);
        v126 = v125 + v121;
        if (v125 + v121 + v118 >= v171)
          v127 = v169 + v118;
        else
          v127 = v123;
        if (v126 <= v179)
        {
          v86 = a2;
          v113 = v122;
          v112 = v124;
        }
        else
        {
          if ((int)((__clz(v134 + 1 - (v118 + v156)) ^ 0x1F) + (__clz(*(_DWORD *)a4 + 1) ^ 0xFFFFFFE0) + 1) < 4 * ((int)v126 - (int)v179))
          {
            *a4 = v134 + 2 - (v118 + (_DWORD)v156);
            v179 = v125 + v121;
          }
          v86 = a2;
          v113 = v122;
          v112 = v124;
          if ((uint64_t *)((char *)a2 + v126) == (uint64_t *)a3)
            break;
        }
        v128 = (unsigned int *)(v166 + 8 * (v118 & v116));
        if (*(unsigned __int8 *)(v127 + v126) >= *((unsigned __int8 *)v86 + v126))
        {
          if (v118 <= v117)
            break;
        }
        else
        {
          if (v118 <= v117)
            break;
          ++v128;
          v177 = v125 + v121;
          v126 = v119;
        }
        v30 = v120-- != 0;
        if (!v30)
          break;
        v118 = *v128;
        v119 = v126;
      }
      while (*v128 > v162);
    }
  }
  *(_DWORD *)(v140 + 36) = v159 - 8;
  return v179;
}

unint64_t ZSTD_BtFindBestMatch_extDict_selectMLS(uint64_t a1, uint64_t *a2, unint64_t a3, _QWORD *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  int v22;
  _DWORD *v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  _DWORD *v33;

  v4 = *(_DWORD *)(a1 + 208);
  if ((v4 - 6) >= 2)
  {
    if (v4 == 5)
    {
      v15 = *(_QWORD *)(a1 + 8);
      v16 = *(unsigned int *)(a1 + 36);
      if (v15 + v16 <= (unint64_t)a2)
      {
        if (v16 < (int)a2 - (int)v15)
        {
          v17 = *(_QWORD *)(a1 + 48);
          v18 = ~(-1 << (*(_DWORD *)(a1 + 196) - 1));
          v19 = *(_QWORD *)(a1 + 64);
          v20 = 64 - *(_DWORD *)(a1 + 200);
          do
          {
            v21 = 4 * ((0xCF1BBCDCBB000000 * *(_QWORD *)(v15 + v16)) >> v20);
            v22 = *(_DWORD *)(v17 + v21);
            v23 = (_DWORD *)(v19 + 8 * (v16 & v18));
            *(_DWORD *)(v17 + v21) = v16;
            *v23 = v22;
            v23[1] = 1;
            ++v16;
          }
          while ((_DWORD)a2 - (_DWORD)v15 != v16);
        }
        *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v15;
        v14 = 5;
        return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, v14, 1);
      }
    }
    else
    {
      v25 = *(_QWORD *)(a1 + 8);
      v26 = *(unsigned int *)(a1 + 36);
      if (v25 + v26 <= (unint64_t)a2)
      {
        if (v26 < (int)a2 - (int)v25)
        {
          v27 = *(_QWORD *)(a1 + 48);
          v28 = ~(-1 << (*(_DWORD *)(a1 + 196) - 1));
          v29 = *(_QWORD *)(a1 + 64);
          v30 = 32 - *(_DWORD *)(a1 + 200);
          do
          {
            v31 = 4 * ((-1640531535 * *(_DWORD *)(v25 + v26)) >> v30);
            v32 = *(_DWORD *)(v27 + v31);
            v33 = (_DWORD *)(v29 + 8 * (v26 & v28));
            *(_DWORD *)(v27 + v31) = v26;
            *v33 = v32;
            v33[1] = 1;
            ++v26;
          }
          while ((_DWORD)a2 - (_DWORD)v25 != v26);
        }
        *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v25;
        v14 = 4;
        return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, v14, 1);
      }
    }
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(unsigned int *)(a1 + 36);
    if (v5 + v6 <= (unint64_t)a2)
    {
      if (v6 < (int)a2 - (int)v5)
      {
        v7 = *(_QWORD *)(a1 + 48);
        v8 = ~(-1 << (*(_DWORD *)(a1 + 196) - 1));
        v9 = *(_QWORD *)(a1 + 64);
        v10 = 64 - *(_DWORD *)(a1 + 200);
        do
        {
          v11 = 4 * ((0xCF1BBCDCBF9B0000 * *(_QWORD *)(v5 + v6)) >> v10);
          v12 = *(_DWORD *)(v7 + v11);
          v13 = (_DWORD *)(v9 + 8 * (v6 & v8));
          *(_DWORD *)(v7 + v11) = v6;
          *v13 = v12;
          v13[1] = 1;
          ++v6;
        }
        while ((_DWORD)a2 - (_DWORD)v5 != v6);
      }
      *(_DWORD *)(a1 + 36) = (_DWORD)a2 - v5;
      v14 = 6;
      return ZSTD_DUBT_findBestMatch(a1, a2, a3, a4, v14, 1);
    }
  }
  return 0;
}

uint64_t ZSTD_insertBt1(uint64_t a1, _QWORD *a2, unint64_t a3, int a4, int a5)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int *v20;
  unsigned int v21;
  unint64_t v22;
  int v23;
  int v24;
  unsigned int v25;
  unint64_t v26;
  unint64_t v27;
  unsigned int *v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  int *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  unint64_t v47;
  unint64_t v48;
  _DWORD *v49;
  int v50;
  unsigned int *v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  unsigned int v57;
  int v59;
  uint64_t v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  _QWORD *v65;
  char *v66;
  int v67;
  unint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  unint64_t v71;
  uint64_t v72;
  unsigned int v73;
  unsigned int v74;
  unint64_t v75;
  unint64_t v76;
  int v77;
  int v78;

  v6 = *(_QWORD *)(a1 + 48);
  v7 = *(_DWORD *)(a1 + 200);
  switch(a4)
  {
    case 5:
      v8 = *a2;
      v9 = -1157627904;
      goto LABEL_7;
    case 6:
      v8 = *a2;
      v9 = -1080360960;
      goto LABEL_7;
    case 7:
      v8 = *a2;
      v9 = -1079680256;
      goto LABEL_7;
    case 8:
      v8 = *a2;
      v9 = -1213897629;
LABEL_7:
      v10 = (v8 * (v9 | 0xCF1BBCDC00000000)) >> -(char)v7;
      break;
    default:
      v10 = (-1640531535 * *(_DWORD *)a2) >> -(char)v7;
      break;
  }
  v11 = *(_QWORD *)(a1 + 64);
  v12 = -1 << (*(_DWORD *)(a1 + 196) - 1);
  v13 = ~v12;
  v14 = 4 * v10;
  v15 = *(_DWORD *)(v6 + 4 * v10);
  v16 = *(_QWORD *)(a1 + 8);
  v17 = *(_QWORD *)(a1 + 16);
  v18 = (_DWORD)a2 - v16;
  if ((int)a2 - (int)v16 >= v13)
    v19 = ((_DWORD)a2 - v16 + v12 + 1);
  else
    v19 = 0;
  v20 = (int *)(v11 + 8 * (v18 & ~v12));
  v78 = 0;
  v22 = *(unsigned int *)(a1 + 24);
  v21 = *(_DWORD *)(a1 + 28);
  v23 = v18 + 9;
  v24 = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(v6 + v14) = v18;
  if (v15 < v21)
  {
    v25 = 0;
    *(_QWORD *)v20 = 0;
    goto LABEL_63;
  }
  v74 = v21;
  v59 = (_DWORD)a2 - v16;
  v26 = 0;
  v27 = 0;
  v66 = (char *)(v17 + v22);
  v65 = (_QWORD *)(v16 + v22);
  v28 = (unsigned int *)(v20 + 1);
  v29 = ~(-1 << v24);
  v30 = a3 - 7;
  v62 = a3 - 1;
  v63 = a3 - 3;
  v60 = v16 + 8;
  v61 = a2 + 1;
  v31 = 8;
  v69 = v16;
  v70 = a2;
  v68 = v22;
  v67 = a5;
  v64 = a3 - 7;
  while (1)
  {
    if (v27 >= v26)
      v32 = v26;
    else
      v32 = v27;
    v33 = v15;
    v34 = (char *)a2 + v32;
    v75 = v27;
    v76 = v26;
    v77 = v29;
    if (!a5 || v32 + v15 >= v22)
    {
      v45 = v16 + v15;
      v46 = (_QWORD *)(v45 + v32);
      if (v30 <= (unint64_t)v34)
      {
        v49 = (_DWORD *)((char *)a2 + v32);
        if ((unint64_t)v34 >= v63)
          goto LABEL_28;
      }
      else
      {
        v47 = *(_QWORD *)v34 ^ *v46;
        if (v47)
        {
          v48 = __clz(__rbit64(v47)) >> 3;
LABEL_37:
          v44 = v48 + v32;
          goto LABEL_38;
        }
        v52 = 0;
        v53 = (char *)v61 + v32;
        while (1)
        {
          v54 = &v53[v52];
          if ((unint64_t)&v53[v52] >= v30)
            break;
          v55 = *(_QWORD *)(v60 + v32 + v15 + v52);
          v52 += 8;
          v56 = *(_QWORD *)v54 ^ v55;
          if (v56)
          {
            v48 = v52 + (__clz(__rbit64(v56)) >> 3);
            goto LABEL_37;
          }
        }
        v49 = (_DWORD *)((char *)v61 + v32 + v52);
        v46 = (_QWORD *)(v60 + v32 + v15 + v52);
        if ((unint64_t)v49 >= v63)
        {
LABEL_28:
          if ((unint64_t)v49 >= v62)
          {
            if ((unint64_t)v49 >= a3)
            {
LABEL_36:
              v48 = (char *)v49 - v34;
              goto LABEL_37;
            }
          }
          else
          {
            if (*(unsigned __int16 *)v46 == *(unsigned __int16 *)v49)
            {
              v49 = (_DWORD *)((char *)v49 + 2);
              v46 = (_QWORD *)((char *)v46 + 2);
            }
            if ((unint64_t)v49 >= a3)
              goto LABEL_36;
          }
          if (*(unsigned __int8 *)v46 == *(unsigned __int8 *)v49)
            v49 = (_DWORD *)((char *)v49 + 1);
          goto LABEL_36;
        }
      }
      if (*(_DWORD *)v46 == *v49)
      {
        ++v49;
        v46 = (_QWORD *)((char *)v46 + 4);
      }
      goto LABEL_28;
    }
    v71 = v32;
    v72 = v17 + v15;
    v35 = (char *)(v72 + v32);
    v36 = v20;
    v37 = v13;
    v38 = v23;
    v39 = v17;
    v40 = v19;
    v73 = v15;
    v41 = v28;
    v42 = v31;
    v43 = ZSTD_count_2segments(v34, v35, a3, v66, v65);
    v31 = v42;
    v28 = v41;
    v15 = v73;
    v19 = v40;
    v17 = v39;
    v23 = v38;
    v13 = v37;
    v30 = v64;
    v20 = v36;
    v22 = v68;
    v16 = v69;
    a2 = v70;
    a5 = v67;
    v44 = v43 + v71;
    v45 = v72;
    if (v43 + v71 + v33 >= v68)
      v45 = v69 + v33;
LABEL_38:
    v50 = v15 + v44;
    if (v44 <= v23 - v15)
      v50 = v23;
    if (v44 > v31)
    {
      v23 = v50;
      v31 = v44;
    }
    if ((_QWORD *)((char *)a2 + v44) == (_QWORD *)a3)
      goto LABEL_58;
    v51 = (unsigned int *)(v11 + 8 * (v15 & v13));
    if (*(unsigned __int8 *)(v45 + v44) >= *((unsigned __int8 *)a2 + v44))
      break;
    *v20 = v15;
    if (v15 <= v19)
    {
      v20 = &v78;
      goto LABEL_58;
    }
    ++v51;
    v27 = v44;
    v20 = (int *)v51;
    v26 = v76;
    v29 = v77 - 1;
    if (!v77)
      goto LABEL_58;
LABEL_14:
    v15 = *v51;
    if (*v51 < v74)
      goto LABEL_58;
  }
  *v28 = v15;
  if (v15 > v19)
  {
    v26 = v44;
    v28 = (unsigned int *)(v11 + 8 * (v15 & v13));
    v27 = v75;
    v29 = v77 - 1;
    if (!v77)
      goto LABEL_58;
    goto LABEL_14;
  }
  v28 = (unsigned int *)&v78;
LABEL_58:
  *v28 = 0;
  *v20 = 0;
  v25 = v31 - 384;
  if ((v31 - 384) >= 0xC0)
    v25 = 192;
  if (v31 <= 0x180)
    v25 = 0;
  v18 = v59;
LABEL_63:
  v57 = v23 - v18 - 8;
  if (v25 <= v57)
    return v57;
  else
    return v25;
}

uint64_t *ZSTD_opt_getNextMatchAndUpdateSeqStore(uint64_t *result, int a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int *v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t v16;
  _DWORD *v17;
  unsigned int v18;
  BOOL v19;
  unsigned int v20;
  _DWORD *v21;
  unsigned int v22;
  unsigned int v23;
  _DWORD *v24;
  unsigned int v25;
  unsigned int v26;

  v3 = result[3];
  if (!v3 || (v4 = result[1], v4 >= v3))
  {
    result[5] = -1;
    return result;
  }
  v5 = *result;
  v6 = (int *)(*result + 12 * v4);
  v7 = v6[1];
  v8 = result[2];
  v9 = v7 - v8;
  if (v8 >= v7)
    v10 = 0;
  else
    v10 = v7 - v8;
  if (v10)
    v11 = 0;
  else
    v11 = v9;
  if (v10 >= a3)
  {
    result[5] = -1;
    v15 = v8 + a3;
    if (!((_DWORD)v8 + a3))
      goto LABEL_45;
    if (v4 <= v3)
      v16 = v3;
    else
      v16 = v4;
    v21 = (_DWORD *)(v5 + 12 * v4 + 8);
    while (v16 != v4)
    {
      v22 = *v21 + *(v21 - 1);
      v19 = v15 >= v22;
      v23 = v15 - v22;
      if (!v19)
      {
LABEL_44:
        result[2] = v15;
        if (v4 != v3)
          return result;
        goto LABEL_45;
      }
      result[1] = ++v4;
      v21 += 3;
      v15 = v23;
      if (!v23)
        goto LABEL_45;
    }
LABEL_42:
    if (v16 != v3)
      return result;
    goto LABEL_45;
  }
  v12 = v11 + v6[2];
  v13 = *v6;
  v14 = v12 + v10 + a2;
  *((_DWORD *)result + 10) = v10 + a2;
  *((_DWORD *)result + 11) = v14;
  *((_DWORD *)result + 12) = v13;
  if (v14 <= a3 + a2)
  {
    v15 = v10 + v8 + v12;
    if (!v15)
      goto LABEL_45;
    if (v4 <= v3)
      v16 = v3;
    else
      v16 = v4;
    v24 = (_DWORD *)(v5 + 12 * v4 + 8);
    while (v16 != v4)
    {
      v25 = *v24 + *(v24 - 1);
      v19 = v15 >= v25;
      v26 = v15 - v25;
      if (!v19)
        goto LABEL_44;
      result[1] = ++v4;
      v24 += 3;
      v15 = v26;
      if (!v26)
        goto LABEL_45;
    }
    goto LABEL_42;
  }
  *((_DWORD *)result + 11) = a3 + a2;
  v15 = v8 + a3;
  if ((_DWORD)v8 + a3)
  {
    if (v4 <= v3)
      v16 = v3;
    else
      v16 = v4;
    v17 = (_DWORD *)(v5 + 12 * v4 + 8);
    while (v16 != v4)
    {
      v18 = *v17 + *(v17 - 1);
      v19 = v15 >= v18;
      v20 = v15 - v18;
      if (!v19)
        goto LABEL_44;
      result[1] = ++v4;
      v17 += 3;
      v15 = v20;
      if (!v20)
        goto LABEL_45;
    }
    goto LABEL_42;
  }
LABEL_45:
  result[2] = 0;
  return result;
}

void ZSTD_rescaleFreqs(char **a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  int v6;
  uint64_t v7;
  char *v8;
  int32x4_t v9;
  int32x4_t v10;
  int32x4_t *v11;
  uint32x4_t v12;
  int32x4_t v13;
  uint32x4_t v14;
  int32x4_t v15;
  uint32x4_t v16;
  uint32x4_t v17;
  uint32x4_t *v18;
  uint32x4_t *v19;
  int32x4_t v20;
  uint32x4_t v21;
  int32x4_t v22;
  uint32x4_t v23;
  int32x4_t v24;
  uint32x4_t v25;
  int32x4_t v26;
  uint32x4_t v27;
  int32x4_t v28;
  uint32x4_t v29;
  int32x4_t v30;
  uint32x4_t v31;
  int32x4_t v32;
  uint32x4_t v33;
  int32x4_t v34;
  uint32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  uint32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  uint32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  uint32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  uint32x4_t *v58;
  int32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int v67;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  int *v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  int *v85;
  int v86;
  int v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  int *v92;
  int v93;
  int v94;
  int v95;
  unsigned int v96;
  unsigned int v97;
  int v98;
  unsigned int v99;
  unsigned int v100;
  int v101;
  int32x2_t v102;
  int32x2_t v103;
  int32x2_t v104;
  int8x8_t v105;
  int32x2_t v106;
  char *v107;
  unsigned __int8 *v108;
  int v109;
  uint64_t v110;
  char *v111;
  int32x4_t v112;
  int32x4_t v113;
  int32x4_t *v114;
  uint32x4_t v115;
  int32x4_t v116;
  uint32x4_t v117;
  int32x4_t v118;

  v6 = *((_DWORD *)a1 + 24);
  *((_DWORD *)a1 + 20) = 0;
  if (*((_DWORD *)a1 + 13))
  {
    if (v6 != 2)
    {
      v7 = 0;
      v8 = *a1;
      v9 = 0uLL;
      v10 = 0uLL;
      do
      {
        v11 = (int32x4_t *)&v8[v7];
        v12.i64[0] = 0x100000001;
        v12.i64[1] = 0x100000001;
        v13 = (int32x4_t)vsraq_n_u32(v12, *(uint32x4_t *)&v8[v7], 5uLL);
        v14.i64[0] = 0x100000001;
        v14.i64[1] = 0x100000001;
        v15 = (int32x4_t)vsraq_n_u32(v14, *(uint32x4_t *)&v8[v7 + 16], 5uLL);
        *v11 = v13;
        v11[1] = v15;
        v9 = vaddq_s32(v13, v9);
        v10 = vaddq_s32(v15, v10);
        v7 += 32;
      }
      while (v7 != 1024);
      *((_DWORD *)a1 + 12) = vaddvq_s32(vaddq_s32(v10, v9));
    }
    v16.i64[0] = 0x100000001;
    v16.i64[1] = 0x100000001;
    v17.i64[0] = 0x100000001;
    v17.i64[1] = 0x100000001;
    v19 = (uint32x4_t *)a1[1];
    v18 = (uint32x4_t *)a1[2];
    v20 = (int32x4_t)vsraq_n_u32(v17, *v19, 4uLL);
    v21.i64[0] = 0x100000001;
    v21.i64[1] = 0x100000001;
    v22 = (int32x4_t)vsraq_n_u32(v21, v19[1], 4uLL);
    *v19 = (uint32x4_t)v20;
    v19[1] = (uint32x4_t)v22;
    v23.i64[0] = 0x100000001;
    v23.i64[1] = 0x100000001;
    v24 = (int32x4_t)vsraq_n_u32(v23, v19[2], 4uLL);
    v25.i64[0] = 0x100000001;
    v25.i64[1] = 0x100000001;
    v26 = (int32x4_t)vsraq_n_u32(v25, v19[3], 4uLL);
    v19[2] = (uint32x4_t)v24;
    v19[3] = (uint32x4_t)v26;
    v27.i64[0] = 0x100000001;
    v27.i64[1] = 0x100000001;
    v28 = (int32x4_t)vsraq_n_u32(v27, v19[4], 4uLL);
    v29.i64[0] = 0x100000001;
    v29.i64[1] = 0x100000001;
    v30 = (int32x4_t)vsraq_n_u32(v29, v19[5], 4uLL);
    v19[4] = (uint32x4_t)v28;
    v19[5] = (uint32x4_t)v30;
    v31.i64[0] = 0x100000001;
    v31.i64[1] = 0x100000001;
    v32 = (int32x4_t)vsraq_n_u32(v31, v19[6], 4uLL);
    v33.i64[0] = 0x100000001;
    v33.i64[1] = 0x100000001;
    v34 = (int32x4_t)vsraq_n_u32(v33, v19[7], 4uLL);
    v19[6] = (uint32x4_t)v32;
    v19[7] = (uint32x4_t)v34;
    v35.i64[0] = 0x100000001;
    v35.i64[1] = 0x100000001;
    v36 = (int32x4_t)vsraq_n_u32(v35, v19[8], 4uLL);
    v19[8] = (uint32x4_t)v36;
    *((_DWORD *)a1 + 13) = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v36, v34), vaddq_s32(v32, v30)), vaddq_s32(vaddq_s32(v28, v26), vaddq_s32(v24, v22))), v20));
    v24.i64[0] = 0x100000001;
    v24.i64[1] = 0x100000001;
    v37 = (int32x4_t)vsraq_n_u32((uint32x4_t)v24, *v18, 4uLL);
    v20.i64[0] = 0x100000001;
    v20.i64[1] = 0x100000001;
    v38 = (int32x4_t)vsraq_n_u32((uint32x4_t)v20, v18[1], 4uLL);
    *v18 = (uint32x4_t)v37;
    v18[1] = (uint32x4_t)v38;
    v28.i64[0] = 0x100000001;
    v28.i64[1] = 0x100000001;
    v39 = (int32x4_t)vsraq_n_u32((uint32x4_t)v28, v18[2], 4uLL);
    v22.i64[0] = 0x100000001;
    v22.i64[1] = 0x100000001;
    v40 = (int32x4_t)vsraq_n_u32((uint32x4_t)v22, v18[3], 4uLL);
    v18[2] = (uint32x4_t)v39;
    v18[3] = (uint32x4_t)v40;
    v32.i64[0] = 0x100000001;
    v32.i64[1] = 0x100000001;
    v41 = (int32x4_t)vsraq_n_u32((uint32x4_t)v32, v18[4], 4uLL);
    v26.i64[0] = 0x100000001;
    v26.i64[1] = 0x100000001;
    v42 = (int32x4_t)vsraq_n_u32((uint32x4_t)v26, v18[5], 4uLL);
    v18[4] = (uint32x4_t)v41;
    v18[5] = (uint32x4_t)v42;
    v43.i64[0] = 0x100000001;
    v43.i64[1] = 0x100000001;
    v44 = (int32x4_t)vsraq_n_u32(v43, v18[6], 4uLL);
    v30.i64[0] = 0x100000001;
    v30.i64[1] = 0x100000001;
    v45 = (int32x4_t)vsraq_n_u32((uint32x4_t)v30, v18[7], 4uLL);
    v18[6] = (uint32x4_t)v44;
    v18[7] = (uint32x4_t)v45;
    v46.i64[0] = 0x100000001;
    v46.i64[1] = 0x100000001;
    v47 = (int32x4_t)vsraq_n_u32(v46, v18[8], 4uLL);
    v34.i64[0] = 0x100000001;
    v34.i64[1] = 0x100000001;
    v48 = (int32x4_t)vsraq_n_u32((uint32x4_t)v34, v18[9], 4uLL);
    v18[8] = (uint32x4_t)v47;
    v18[9] = (uint32x4_t)v48;
    v49.i64[0] = 0x100000001;
    v49.i64[1] = 0x100000001;
    v50 = (int32x4_t)vsraq_n_u32(v49, v18[10], 4uLL);
    v36.i64[0] = 0x100000001;
    v36.i64[1] = 0x100000001;
    v51 = (int32x4_t)vsraq_n_u32((uint32x4_t)v36, v18[11], 4uLL);
    v18[10] = (uint32x4_t)v50;
    v18[11] = (uint32x4_t)v51;
    v52 = ((unsigned __int32)v18[12].i32[0] >> 4) + 1;
    LODWORD(v19) = v52
                 + vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v51, v48), vaddq_s32(vaddq_s32(v45, v42), vaddq_s32(v40, v38))), vaddq_s32(vaddq_s32(v50, v47), vaddq_s32(vaddq_s32(v44, v41), vaddq_s32(v39, v37)))));
    v53 = ((unsigned __int32)v18[12].i32[1] >> 4) + 1;
    v18[12].i32[0] = v52;
    v18[12].i32[1] = v53;
    v54 = ((unsigned __int32)v18[12].i32[2] >> 4) + 1;
    v55 = ((unsigned __int32)v18[12].i32[3] >> 4) + 1;
    v18[12].i32[2] = v54;
    v18[12].i32[3] = v55;
    v56 = v55 + v54 + v53;
    v57 = ((unsigned __int32)v18[13].i32[0] >> 4) + 1;
    v18[13].i32[0] = v57;
    *((_DWORD *)a1 + 14) = v57 + v56 + (_DWORD)v19;
    v58 = (uint32x4_t *)a1[3];
    v44.i64[0] = 0x100000001;
    v44.i64[1] = 0x100000001;
    v59 = (int32x4_t)vsraq_n_u32((uint32x4_t)v44, v58[7], 4uLL);
    v48.i64[0] = 0x100000001;
    v48.i64[1] = 0x100000001;
    v60 = (int32x4_t)vsraq_n_u32((uint32x4_t)v48, v58[6], 4uLL);
    v41.i64[0] = 0x100000001;
    v41.i64[1] = 0x100000001;
    v61 = (int32x4_t)vsraq_n_u32((uint32x4_t)v41, v58[5], 4uLL);
    v45.i64[0] = 0x100000001;
    v45.i64[1] = 0x100000001;
    v62 = (int32x4_t)vsraq_n_u32((uint32x4_t)v45, v58[4], 4uLL);
    v39.i64[0] = 0x100000001;
    v39.i64[1] = 0x100000001;
    v63 = (int32x4_t)vsraq_n_u32((uint32x4_t)v39, v58[3], 4uLL);
    v42.i64[0] = 0x100000001;
    v42.i64[1] = 0x100000001;
    v64 = (int32x4_t)vsraq_n_u32((uint32x4_t)v42, v58[2], 4uLL);
    v37.i64[0] = 0x100000001;
    v37.i64[1] = 0x100000001;
    v65 = (int32x4_t)vsraq_n_u32((uint32x4_t)v37, v58[1], 4uLL);
    v66 = (int32x4_t)vsraq_n_u32(v16, *v58, 4uLL);
    *v58 = (uint32x4_t)v66;
    v58[1] = (uint32x4_t)v65;
    v58[2] = (uint32x4_t)v64;
    v58[3] = (uint32x4_t)v63;
    v58[4] = (uint32x4_t)v62;
    v58[5] = (uint32x4_t)v61;
    v58[6] = (uint32x4_t)v60;
    v58[7] = (uint32x4_t)v59;
    v67 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v66, v62), vaddq_s32(v64, v60)), vaddq_s32(vaddq_s32(v65, v61), vaddq_s32(v63, v59))));
    goto LABEL_53;
  }
  if ((unint64_t)a3 <= 0x400)
    *((_DWORD *)a1 + 20) = 1;
  v70 = a1[11];
  if (*((_DWORD *)v70 + 256) != 2)
  {
    if (v6 != 2)
    {
      v107 = *a1;
      bzero(*a1, 0x400uLL);
      if (a3 >= 1)
      {
        v108 = &a2[a3];
        do
        {
          v109 = *a2++;
          ++*(_DWORD *)&v107[4 * v109];
        }
        while (a2 < v108);
      }
      v110 = 0;
      v111 = *a1;
      v112 = 0uLL;
      v113 = 0uLL;
      do
      {
        v114 = (int32x4_t *)&v111[v110];
        v115.i64[0] = 0x100000001;
        v115.i64[1] = 0x100000001;
        v116 = (int32x4_t)vsraq_n_u32(v115, *(uint32x4_t *)&v111[v110], 5uLL);
        v117.i64[0] = 0x100000001;
        v117.i64[1] = 0x100000001;
        v118 = (int32x4_t)vsraq_n_u32(v117, *(uint32x4_t *)&v111[v110 + 16], 5uLL);
        *v114 = v116;
        v114[1] = v118;
        v112 = vaddq_s32(v116, v112);
        v113 = vaddq_s32(v118, v113);
        v110 += 32;
      }
      while (v110 != 1024);
      *((_DWORD *)a1 + 12) = vaddvq_s32(vaddq_s32(v113, v112));
    }
    memset_pattern16(a1[1], &unk_18820E900, 0x90uLL);
    *((_DWORD *)a1 + 13) = 36;
    memset_pattern16(a1[2], &unk_18820E900, 0xD4uLL);
    *((_DWORD *)a1 + 14) = 53;
    memset_pattern16(a1[3], &unk_18820E900, 0x80uLL);
    v67 = 32;
LABEL_53:
    *((_DWORD *)a1 + 15) = v67;
    if (*((_DWORD *)a1 + 24) == 2)
      goto LABEL_41;
    goto LABEL_38;
  }
  *((_DWORD *)a1 + 20) = 0;
  if (v6 != 2)
  {
    v71 = 0;
    *((_DWORD *)a1 + 12) = 0;
    v72 = *a1;
    v73 = v70 + 2;
    do
    {
      if (v73[v71])
        v74 = 1 << (11 - v73[v71]);
      else
        v74 = 1;
      *(_DWORD *)&v72[v71] = v74;
      *((_DWORD *)a1 + 12) += v74;
      v71 += 4;
    }
    while (v71 != 1024);
  }
  v75 = 0;
  v76 = 1 << (*((_WORD *)v70 + 1626) - 1);
  if (!*((_WORD *)v70 + 1626))
    v76 = 1;
  *((_DWORD *)a1 + 13) = 0;
  v77 = a1[1];
  v78 = (int *)&v70[4 * v76 + 3260];
  do
  {
    v79 = *v78;
    v78 += 2;
    v80 = 1 << (10 - ((v79 + 0xFFFF) >> 16));
    if ((v79 + 0xFFFF) < 0x10000)
      v81 = 1;
    else
      v81 = v80;
    *(_DWORD *)&v77[v75] = v81;
    *((_DWORD *)a1 + 13) += v81;
    v75 += 4;
  }
  while (v75 != 144);
  v82 = 0;
  v83 = 1 << (*((_WORD *)v70 + 900) - 1);
  if (!*((_WORD *)v70 + 900))
    v83 = 1;
  *((_DWORD *)a1 + 14) = 0;
  v84 = a1[2];
  v85 = (int *)&v70[4 * v83 + 1808];
  do
  {
    v86 = *v85;
    v85 += 2;
    v87 = 1 << (10 - ((v86 + 0xFFFF) >> 16));
    if ((v86 + 0xFFFF) < 0x10000)
      v88 = 1;
    else
      v88 = v87;
    *(_DWORD *)&v84[v82] = v88;
    *((_DWORD *)a1 + 14) += v88;
    v82 += 4;
  }
  while (v82 != 212);
  v89 = 0;
  v90 = 1 << (*((_WORD *)v70 + 514) - 1);
  if (!*((_WORD *)v70 + 514))
    v90 = 1;
  *((_DWORD *)a1 + 15) = 0;
  v91 = a1[3];
  v92 = (int *)&v70[4 * v90 + 1036];
  do
  {
    v93 = *v92;
    v92 += 2;
    v94 = 1 << (10 - ((v93 + 0xFFFF) >> 16));
    if ((v93 + 0xFFFF) < 0x10000)
      v95 = 1;
    else
      v95 = v94;
    *(_DWORD *)&v91[v89] = v95;
    v67 = v95 + *((_DWORD *)a1 + 15);
    *((_DWORD *)a1 + 15) = v67;
    v89 += 4;
  }
  while (v89 != 128);
  if (*((_DWORD *)a1 + 24) != 2)
  {
LABEL_38:
    v96 = *((_DWORD *)a1 + 12) + 1;
    v97 = __clz(v96);
    v98 = (v96 << 8 >> (v97 ^ 0x1F)) + ((v97 ^ 0x1F) << 8);
    if (!a4)
      v98 = (v97 << 8) ^ 0x1F00;
    *((_DWORD *)a1 + 16) = v98;
  }
LABEL_41:
  v99 = *((_DWORD *)a1 + 13) + 1;
  v100 = __clz(v99);
  if (a4)
  {
    v101 = (v99 << 8 >> (v100 ^ 0x1F)) + ((v100 ^ 0x1F) << 8);
    v102.i32[0] = *((_DWORD *)a1 + 14);
    v102.i32[1] = v67;
    v103 = vadd_s32(v102, (int32x2_t)0x100000001);
    v104 = (int32x2_t)veor_s8((int8x8_t)vclz_s32(v103), (int8x8_t)0x1F0000001FLL);
    v105 = (int8x8_t)vadd_s32(vshl_n_s32(v104, 8uLL), (int32x2_t)vshl_u32((uint32x2_t)vshl_n_s32(v103, 8uLL), (uint32x2_t)vneg_s32(v104)));
  }
  else
  {
    v101 = (v100 << 8) ^ 0x1F00;
    v106.i32[0] = *((_DWORD *)a1 + 14);
    v106.i32[1] = v67;
    v105 = veor_s8((int8x8_t)vshl_n_s32(vclz_s32(vadd_s32(v106, (int32x2_t)0x100000001)), 8uLL), (int8x8_t)0x1F0000001F00);
  }
  *((_DWORD *)a1 + 17) = v101;
  a1[9] = (char *)v105;
}

uint64_t *ZSTD_optLdm_processMatchCandidate(uint64_t *result, uint64_t a2, _DWORD *a3, unsigned int a4, unsigned int a5)
{
  unint64_t v5;
  uint64_t *v6;
  unint64_t v7;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v19;
  int v20;
  uint64_t v21;

  v5 = result[3];
  if (v5)
  {
    v6 = result;
    v7 = result[1];
    if (v7 < v5)
    {
      v11 = *((_DWORD *)result + 11);
      if (a4 >= v11)
      {
        if (a4 > v11)
        {
          v12 = a4 - v11 + *((_DWORD *)result + 4);
          if (!v12)
            goto LABEL_17;
          v13 = v7 <= v5 ? result[3] : result[1];
          v14 = 12 * v7;
          while (v13 != v7)
          {
            v15 = *(_DWORD *)(*result + v14 + 8) + *(_DWORD *)(*result + v14 + 4);
            v19 = v12 >= v15;
            v16 = v12 - v15;
            if (!v19)
            {
              result[2] = v12;
              goto LABEL_16;
            }
            result[1] = ++v7;
            v14 += 12;
            v12 = v16;
            if (!v16)
              goto LABEL_17;
          }
          v7 = v13;
LABEL_16:
          if (v7 == v5)
LABEL_17:
            result[2] = 0;
        }
        result = ZSTD_opt_getNextMatchAndUpdateSeqStore(result, a4, a5);
        v11 = *((_DWORD *)v6 + 11);
      }
      v17 = v11 - a4;
      v19 = *((_DWORD *)v6 + 10) <= a4 && v11 > a4 && v17 >= 3;
      if (v19)
      {
        v20 = *((_DWORD *)v6 + 12);
        v21 = *a3;
        if (!(_DWORD)v21 || v21 <= 0xFFF && v17 > *(_DWORD *)(a2 + 8 * (v21 - 1) + 4))
        {
          *(_DWORD *)(a2 + 8 * v21 + 4) = v17;
          *(_DWORD *)(a2 + 8 * (*a3)++) = v20 + 2;
        }
      }
    }
  }
  return result;
}

char *ZSTDMT_createJobsTable(unsigned int *a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void (*v14)(uint64_t, char *);
  pthread_cond_t *v15;

  v4 = __clz(*a1);
  v5 = v4 ^ 0x1F;
  v6 = (2 << (v4 ^ 0x1F));
  if (*(_QWORD *)a2)
  {
    v7 = (char *)(*(uint64_t (**)(_QWORD, uint64_t))a2)(*(_QWORD *)(a2 + 16), 424 * v6);
    bzero(v7, 424 * v6);
    if (!v7)
      return v7;
  }
  else
  {
    v7 = (char *)malloc_type_calloc(1uLL, 424 * v6, 0xEC864E14uLL);
    if (!v7)
      return v7;
  }
  *a1 = v6;
  if (v5 <= 0x1E)
  {
    v8 = 0;
    v9 = 0;
    if (v6 <= 1)
      v10 = 1;
    else
      v10 = v6;
    v11 = 424 * v10;
    do
    {
      v12 = pthread_mutex_init((pthread_mutex_t *)&v7[v8 + 16], 0);
      v9 |= v12 | pthread_cond_init((pthread_cond_t *)&v7[v8 + 80], 0);
      v8 += 424;
    }
    while (v11 != v8);
    if (v9)
    {
      v14 = *(void (**)(uint64_t, char *))(a2 + 8);
      v13 = *(_QWORD *)(a2 + 16);
      v15 = (pthread_cond_t *)(v7 + 80);
      do
      {
        pthread_mutex_destroy((pthread_mutex_t *)&v15[-2].__opaque[24]);
        pthread_cond_destroy(v15);
        v15 = (pthread_cond_t *)((char *)v15 + 424);
        --v6;
      }
      while (v6);
      if (v14)
        v14(v13, v7);
      else
        free(v7);
      return 0;
    }
  }
  return v7;
}

char *ZSTDMT_createCCtxPool(int a1, __int128 *a2)
{
  int v3;
  size_t v4;
  char *v5;
  void (*v7)(uint64_t, char *);
  uint64_t v8;
  __int128 v9;
  uint64_t (*v10)(_QWORD, size_t);
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;

  v3 = a1;
  v4 = 8 * (a1 - 1) + 104;
  if (*(_QWORD *)a2)
  {
    v5 = (char *)(*(uint64_t (**)(_QWORD, size_t))a2)(*((_QWORD *)a2 + 2), v4);
    bzero(v5, v4);
    if (!v5)
      return v5;
  }
  else
  {
    v5 = (char *)malloc_type_calloc(1uLL, v4, 0xEC864E14uLL);
    if (!v5)
      return v5;
  }
  if (!pthread_mutex_init((pthread_mutex_t *)v5, 0))
  {
    v9 = *a2;
    *((_QWORD *)v5 + 11) = *((_QWORD *)a2 + 2);
    *(_OWORD *)(v5 + 72) = v9;
    *((_DWORD *)v5 + 16) = v3;
    *((_DWORD *)v5 + 17) = 1;
    v10 = *(uint64_t (**)(_QWORD, size_t))a2;
    v11 = *((_QWORD *)a2 + 1);
    if ((*(_QWORD *)a2 == 0) == (v11 == 0))
    {
      v12 = *((_QWORD *)a2 + 2);
      if (v10)
      {
        v13 = (void *)v10(*((_QWORD *)a2 + 2), 3328);
        if (v13)
        {
LABEL_11:
          bzero(v13, 0xD00uLL);
          *((_QWORD *)v13 + 69) = v10;
          *((_QWORD *)v13 + 70) = v11;
          *((_QWORD *)v13 + 71) = v12;
          ZSTD_clearAllDicts((uint64_t)v13);
          *((_QWORD *)v13 + 22) = 0;
          *((_OWORD *)v13 + 9) = 0u;
          *((_OWORD *)v13 + 10) = 0u;
          *((_OWORD *)v13 + 7) = 0u;
          *((_OWORD *)v13 + 8) = 0u;
          *((_OWORD *)v13 + 5) = 0u;
          *((_OWORD *)v13 + 6) = 0u;
          *((_OWORD *)v13 + 3) = 0u;
          *((_OWORD *)v13 + 4) = 0u;
          *((_OWORD *)v13 + 1) = 0u;
          *((_OWORD *)v13 + 2) = 0u;
          *((_DWORD *)v13 + 15) = 3;
          *((_DWORD *)v13 + 12) = 1;
          *((_QWORD *)v5 + 12) = v13;
          return v5;
        }
      }
      else
      {
        v13 = malloc_type_malloc(0xD00uLL, 0x26AA08A0uLL);
        if (v13)
          goto LABEL_11;
      }
      v3 = *((_DWORD *)v5 + 16);
    }
    *((_QWORD *)v5 + 12) = 0;
    if (v3 >= 1)
    {
      v14 = 0;
      do
        ZSTD_freeCCtx(*(_QWORD *)&v5[8 * v14++ + 96]);
      while (v14 < *((int *)v5 + 16));
    }
    pthread_mutex_destroy((pthread_mutex_t *)v5);
    v7 = (void (*)(uint64_t, char *))*((_QWORD *)v5 + 10);
    if (v7)
    {
      v8 = *((_QWORD *)v5 + 11);
      goto LABEL_19;
    }
LABEL_20:
    free(v5);
    return 0;
  }
  v7 = (void (*)(uint64_t, char *))*((_QWORD *)a2 + 1);
  if (!v7)
    goto LABEL_20;
  v8 = *((_QWORD *)a2 + 2);
LABEL_19:
  v7(v8, v5);
  return 0;
}

pthread_mutex_t *ZSTDMT_expandBufferPool(pthread_mutex_t *a1, int a2)
{
  pthread_mutex_t *v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  void (*v6)(uint64_t, pthread_mutex_t *);
  uint64_t (*v7)(uint64_t, size_t);
  uint64_t v8;
  uint64_t sig;
  unint64_t v10;
  void **v11;
  void (*v12)(_QWORD);
  void (*v13)(_QWORD, pthread_mutex_t *);
  size_t v14;

  v2 = a1;
  if (!a1)
    return v2;
  v3 = 2 * a2;
  v4 = 2 * a2 + 3;
  v5 = *(_DWORD *)a1[1].__opaque;
  if (v5 >= v4)
    return v2;
  v7 = *(uint64_t (**)(uint64_t, size_t))&a1[1].__opaque[8];
  v6 = *(void (**)(uint64_t, pthread_mutex_t *))&a1[1].__opaque[16];
  v8 = *(_QWORD *)&a1[1].__opaque[24];
  sig = a1[1].__sig;
  if (v5)
  {
    v10 = 0;
    v11 = (void **)&a1[1].__opaque[32];
    do
    {
      if (*v11)
      {
        v12 = *(void (**)(_QWORD))&v2[1].__opaque[16];
        if (v12)
          v12(*(_QWORD *)&v2[1].__opaque[24]);
        else
          free(*v11);
      }
      ++v10;
      v11 += 2;
    }
    while (v10 < *(unsigned int *)v2[1].__opaque);
  }
  pthread_mutex_destroy(v2);
  v13 = *(void (**)(_QWORD, pthread_mutex_t *))&v2[1].__opaque[16];
  if (v13)
  {
    v13(*(_QWORD *)&v2[1].__opaque[24], v2);
    v14 = 16 * (v3 + 2) + 120;
    if (v7)
      goto LABEL_12;
LABEL_15:
    v2 = (pthread_mutex_t *)malloc_type_calloc(1uLL, v14, 0xEC864E14uLL);
    if (!v2)
      return v2;
    goto LABEL_16;
  }
  free(v2);
  v14 = 16 * (v3 + 2) + 120;
  if (!v7)
    goto LABEL_15;
LABEL_12:
  v2 = (pthread_mutex_t *)v7(v8, v14);
  bzero(v2, v14);
  if (!v2)
    return v2;
LABEL_16:
  if (pthread_mutex_init(v2, 0))
  {
    if (v6)
      v6(v8, v2);
    else
      free(v2);
    return 0;
  }
  else
  {
    v2[1].__sig = 0x10000;
    *(_DWORD *)v2[1].__opaque = v4;
    *(_DWORD *)&v2[1].__opaque[4] = 0;
    *(_QWORD *)&v2[1].__opaque[8] = v7;
    *(_QWORD *)&v2[1].__opaque[16] = v6;
    *(_QWORD *)&v2[1].__opaque[24] = v8;
    pthread_mutex_lock(v2);
    v2[1].__sig = sig;
    pthread_mutex_unlock(v2);
  }
  return v2;
}

uint64_t ZSTDMT_compressionJob(uint64_t a1)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  int v8;
  int v9;
  int32x2_t *v10;
  uint64_t (*v11)(_QWORD, uint64_t);
  int32x2_t v12;
  int32x2_t v13;
  uint64_t v14;
  void *Buffer;
  unint64_t v16;
  unint64_t v17;
  _BYTE *v18;
  unint64_t v19;
  _BYTE *v20;
  unint64_t v21;
  pthread_mutex_t *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unint64_t v29;
  unsigned int i;
  char **v31;
  uint64_t v32;
  char *v33;
  unsigned int v34;
  uint64_t v35;
  __int128 v36;
  int32x2_t v37;
  int32x2_t v38;
  unint64_t v39;
  unint64_t v40;
  _BYTE *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  BOOL v51;
  size_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unsigned int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void (*v62)(_QWORD, void *);
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v67;
  unint64_t v68;
  char *__src;
  char *__srca;
  int32x2_t v71;
  __int128 v72;
  int32x2_t v73;
  unint64_t v74;
  __int128 v75;
  int32x2_t v76;
  _BYTE v77[32];
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;

  v2 = *(_OWORD *)(a1 + 368);
  v84 = *(_OWORD *)(a1 + 352);
  v85 = v2;
  v86 = *(_QWORD *)(a1 + 384);
  v3 = *(_OWORD *)(a1 + 304);
  v80 = *(_OWORD *)(a1 + 288);
  v81 = v3;
  v4 = *(_OWORD *)(a1 + 336);
  v82 = *(_OWORD *)(a1 + 320);
  v83 = v4;
  v5 = *(_OWORD *)(a1 + 240);
  *(_OWORD *)v77 = *(_OWORD *)(a1 + 224);
  *(_OWORD *)&v77[16] = v5;
  v6 = *(_OWORD *)(a1 + 272);
  v78 = *(_OWORD *)(a1 + 256);
  v79 = v6;
  v7 = *(_QWORD *)(a1 + 128);
  pthread_mutex_lock((pthread_mutex_t *)v7);
  v8 = *(_DWORD *)(v7 + 68);
  if (v8)
  {
    v9 = v8 - 1;
    *(_DWORD *)(v7 + 68) = v9;
    v10 = *(int32x2_t **)(v7 + 8 * v9 + 96);
    pthread_mutex_unlock((pthread_mutex_t *)v7);
    goto LABEL_8;
  }
  pthread_mutex_unlock((pthread_mutex_t *)v7);
  v11 = *(uint64_t (**)(_QWORD, uint64_t))(v7 + 72);
  v12 = *(int32x2_t *)(v7 + 80);
  if ((v11 == 0) != (*(_QWORD *)&v12 == 0))
  {
    v10 = 0;
    goto LABEL_8;
  }
  v13 = *(int32x2_t *)(v7 + 88);
  if (v11)
  {
    v10 = (int32x2_t *)v11(*(_QWORD *)&v13, 3328);
    if (!v10)
      goto LABEL_8;
    goto LABEL_7;
  }
  v10 = (int32x2_t *)malloc_type_malloc(0xD00uLL, 0x26AA08A0uLL);
  if (v10)
  {
LABEL_7:
    bzero(v10, 0xD00uLL);
    v10[69] = (int32x2_t)v11;
    v10[70] = v12;
    v10[71] = v13;
    ZSTD_clearAllDicts((uint64_t)v10);
    v10[22] = 0;
    *(_OWORD *)v10[18].i8 = 0u;
    *(_OWORD *)v10[20].i8 = 0u;
    *(_OWORD *)v10[14].i8 = 0u;
    *(_OWORD *)v10[16].i8 = 0u;
    *(_OWORD *)v10[10].i8 = 0u;
    *(_OWORD *)v10[12].i8 = 0u;
    *(_OWORD *)v10[6].i8 = 0u;
    *(_OWORD *)v10[8].i8 = 0u;
    *(_OWORD *)v10[2].i8 = 0u;
    *(_OWORD *)v10[4].i8 = 0u;
    v10[7].i32[1] = 3;
    v10[6].i32[0] = 1;
  }
LABEL_8:
  v14 = *(_QWORD *)(a1 + 144);
  if (*(_QWORD *)(v14 + 64))
  {
    Buffer = ZSTDMT_getBuffer(v14);
    v76 = 0;
    v75 = 0uLL;
    v17 = v16 / 0xC;
    if (!v10)
      goto LABEL_18;
  }
  else
  {
    v17 = 0;
    Buffer = 0;
    v75 = 0uLL;
    v76 = 0;
    if (!v10)
      goto LABEL_18;
  }
  v18 = *(_BYTE **)(a1 + 160);
  if (!v18)
  {
    v20 = ZSTDMT_getBuffer(*(_QWORD *)(a1 + 136));
    if (!v20)
      goto LABEL_18;
    v18 = v20;
    v19 = v21;
    *(_QWORD *)(a1 + 160) = v20;
    *(_QWORD *)(a1 + 168) = v21;
    if (!(_DWORD)v82)
      goto LABEL_19;
    goto LABEL_17;
  }
  v19 = *(_QWORD *)(a1 + 168);
  if ((_DWORD)v82)
  {
LABEL_17:
    if (Buffer)
      goto LABEL_19;
LABEL_18:
    v22 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    *(_QWORD *)(a1 + 8) = -64;
LABEL_85:
    pthread_mutex_unlock(v22);
    goto LABEL_86;
  }
LABEL_19:
  if (*(_DWORD *)(a1 + 208))
    DWORD1(v78) = 0;
  LODWORD(v82) = 0;
  HIDWORD(v80) = 0;
  v23 = *(_QWORD *)(a1 + 392);
  if (v23)
  {
    v24 = -42;
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)xmmword_18823D760, (uint32x4_t)vaddq_s32(*(int32x4_t *)&v77[4], (int32x4_t)xmmword_18823D750)))) & 1) != 0)goto LABEL_84;
    if ((*(_DWORD *)&v77[20] - 8) < 0xFFFFFFFB)
      goto LABEL_84;
    if (*(_DWORD *)&v77[24] > 0x20000u)
      goto LABEL_84;
    if ((*(_DWORD *)&v77[28] - 1) > 8)
      goto LABEL_84;
    v24 = ZSTD_compressBegin_internal((uint64_t)v10, 0, 0, 0, 0, v23, (uint64_t *)v77, *(_QWORD *)(a1 + 400), 0);
    if (v24 >= 0xFFFFFFFFFFFFFF89)
      goto LABEL_84;
  }
  else
  {
    v25 = 400;
    if (!*(_DWORD *)(a1 + 212))
      v25 = 200;
    v26 = *(_QWORD *)(a1 + v25);
    LODWORD(v79) = *(_DWORD *)(a1 + 212) == 0;
    v24 = -42;
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vcgtq_u32((uint32x4_t)xmmword_18823D760, (uint32x4_t)vaddq_s32(*(int32x4_t *)&v77[4], (int32x4_t)xmmword_18823D750)))) & 1) != 0)goto LABEL_84;
    if ((*(_DWORD *)&v77[20] - 8) < 0xFFFFFFFB)
      goto LABEL_84;
    if (*(_DWORD *)&v77[24] > 0x20000u)
      goto LABEL_84;
    if ((*(_DWORD *)&v77[28] - 1) > 8)
      goto LABEL_84;
    v24 = ZSTD_compressBegin_internal((uint64_t)v10, *(_DWORD **)(a1 + 176), *(_QWORD *)(a1 + 184), 1, 0, 0, (uint64_t *)v77, v26, 0);
    if (v24 >= 0xFFFFFFFFFFFFFF89)
      goto LABEL_84;
  }
  v27 = *(_QWORD *)(a1 + 152);
  v28 = *(_DWORD *)(a1 + 208);
  v72 = v75;
  v73 = v76;
  v74 = v17;
  v29 = *(_QWORD *)(a1 + 200);
  __src = *(char **)(a1 + 192);
  v71 = (int32x2_t)Buffer;
  pthread_mutex_lock((pthread_mutex_t *)v27);
  for (i = *(_DWORD *)(v27 + 2472); i < v28; i = *(_DWORD *)(v27 + 2472))
    pthread_cond_wait((pthread_cond_t *)(v27 + 64), (pthread_mutex_t *)v27);
  if (i == v28)
  {
    if (*(_DWORD *)(v27 + 208))
    {
      v31 = (char **)(v27 + 280);
      if (v29)
      {
        if (*v31 == __src)
        {
          v32 = *(_QWORD *)(v27 + 296);
          v34 = *(_DWORD *)(v27 + 308);
          LODWORD(v33) = *(_DWORD *)(v27 + 304);
        }
        else
        {
          v32 = *(_QWORD *)(v27 + 288);
          v33 = &(*v31)[-v32];
          v34 = *(_DWORD *)(v27 + 304);
          *(_DWORD *)(v27 + 308) = v34;
          *(_DWORD *)(v27 + 304) = (_DWORD)v33;
          *(_QWORD *)(v27 + 288) = __src - v33;
          *(_QWORD *)(v27 + 296) = v32;
          if (v33 - v34 <= 7)
          {
            *(_DWORD *)(v27 + 308) = (_DWORD)v33;
            v34 = v33;
          }
        }
        *v31 = &__src[v29];
        if ((unint64_t)&__src[v29] > v32 + (unint64_t)v34
          && v32 + (unint64_t)v33 > (unint64_t)__src)
        {
          v35 = (uint64_t)&__src[v29 - v32];
          if (v35 > v33)
            LODWORD(v35) = (_DWORD)v33;
          *(_DWORD *)(v27 + 308) = v35;
        }
      }
      ZSTD_ldm_generateSequences((int32x2_t *)(v27 + 280), &v71, (_DWORD *)(v27 + 208), (uint64_t)__src, v29);
      pthread_mutex_lock((pthread_mutex_t *)(v27 + 2480));
      v36 = *(_OWORD *)(v27 + 296);
      *(_OWORD *)(v27 + 2592) = *(_OWORD *)v31;
      *(_OWORD *)(v27 + 2608) = v36;
      pthread_cond_signal((pthread_cond_t *)(v27 + 2544));
      pthread_mutex_unlock((pthread_mutex_t *)(v27 + 2480));
    }
    if (*(_DWORD *)(v27 + 148) && v29)
      ZSTD_XXH64_update((unsigned int *)(v27 + 2384), __src, v29);
  }
  ++*(_DWORD *)(v27 + 2472);
  pthread_cond_broadcast((pthread_cond_t *)(v27 + 64));
  pthread_mutex_unlock((pthread_mutex_t *)v27);
  v37 = v73;
  if (*(_QWORD *)&v73 && v10->i32[0] == 1 && !v10[35].i32[0])
  {
    v10[354] = v71;
    v10[357] = v37;
    v10[358] = v37;
    v10[356] = 0;
    v10[355] = 0;
  }
  if (!*(_DWORD *)(a1 + 212))
  {
    if (v10->i32[0])
    {
      if (v10->i32[0] != 1)
      {
LABEL_64:
        v38 = v10[359];
        *(_QWORD *)(*(_QWORD *)&v38 + 4580) = 0;
        *(_DWORD *)(*(_QWORD *)&v38 + 4588) = 0;
        goto LABEL_65;
      }
      v24 = ZSTD_writeFrameHeader(v18, v19, &v10[23], *(_QWORD *)&v10[55] - 1, v10[44].u32[0]);
      if (v24 <= 0xFFFFFFFFFFFFFF88)
      {
        v10->i32[0] = 2;
        goto LABEL_64;
      }
    }
    else
    {
      v24 = -60;
    }
LABEL_84:
    v22 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    *(_QWORD *)(a1 + 8) = v24;
    goto LABEL_85;
  }
LABEL_65:
  __srca = *(char **)(a1 + 192);
  v39 = *(_QWORD *)(a1 + 200) + 0x7FFFFLL;
  v40 = v39 >> 19;
  v41 = &v18[v19];
  if ((int)(v39 >> 19) >= 2)
  {
    v67 = v39 >> 19;
    v68 = v17;
    v22 = (pthread_mutex_t *)(a1 + 16);
    v42 = (v39 >> 19) - 1;
    v43 = 0x80000;
    while (1)
    {
      v44 = ZSTD_compressContinue_internal(v10, v18, v41 - v18, &__srca[v43 - 0x80000], 0x80000uLL, 1, 0);
      v45 = v44;
      if (v44 >= 0xFFFFFFFFFFFFFF89)
        break;
      v18 += v44;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
      v46 = *(_QWORD *)(a1 + 8) + v45;
      *(_QWORD *)a1 = v43;
      *(_QWORD *)(a1 + 8) = v46;
      pthread_cond_signal((pthread_cond_t *)(a1 + 80));
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
      v43 += 0x80000;
      if (!--v42)
      {
        __srca = &__srca[v43 - 0x80000];
        LODWORD(v40) = v67;
        v17 = v68;
        goto LABEL_70;
      }
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    *(_QWORD *)(a1 + 8) = v45;
    v17 = v68;
    goto LABEL_85;
  }
LABEL_70:
  v47 = *(_DWORD *)(a1 + 216);
  if (!(v47 | ((int)v40 > 0)))
  {
LABEL_86:
    v55 = 0;
    goto LABEL_87;
  }
  v48 = *(_QWORD *)(a1 + 200);
  v49 = v48 & 0x7FFFF;
  v51 = (v48 & 0x7FFFF) == 0;
  v50 = v48 & 0xFFFFFFFFFFF80000;
  v51 = !v51 || v50 == 0;
  if (v51)
    v52 = v49;
  else
    v52 = 0x80000;
  v53 = v41 - v18;
  if (v47)
    v54 = ZSTD_compressEnd((int *)v10, v18, v53, __srca, v52);
  else
    v54 = ZSTD_compressContinue_internal(v10, v18, v53, __srca, v52, 1, 0);
  v55 = v54;
  if (v54 >= 0xFFFFFFFFFFFFFF89)
  {
    v22 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    *(_QWORD *)(a1 + 8) = v55;
    goto LABEL_85;
  }
LABEL_87:
  v56 = *(_QWORD *)(a1 + 152);
  v57 = *(_DWORD *)(a1 + 208);
  pthread_mutex_lock((pthread_mutex_t *)v56);
  if (*(_DWORD *)(v56 + 2472) <= v57)
  {
    *(_DWORD *)(v56 + 2472) = v57 + 1;
    pthread_cond_broadcast((pthread_cond_t *)(v56 + 64));
    pthread_mutex_lock((pthread_mutex_t *)(v56 + 2480));
    v58 = *(_DWORD *)(v56 + 2592) - *(_DWORD *)(v56 + 2600);
    *(_DWORD *)(v56 + 2620) = v58;
    *(_DWORD *)(v56 + 2616) = v58;
    pthread_cond_signal((pthread_cond_t *)(v56 + 2544));
    pthread_mutex_unlock((pthread_mutex_t *)(v56 + 2480));
  }
  pthread_mutex_unlock((pthread_mutex_t *)v56);
  if (!Buffer)
  {
LABEL_95:
    if (!v10)
      goto LABEL_100;
    goto LABEL_96;
  }
  v59 = *(_QWORD *)(a1 + 144);
  pthread_mutex_lock((pthread_mutex_t *)v59);
  v60 = *(unsigned int *)(v59 + 76);
  if (v60 < *(_DWORD *)(v59 + 72))
  {
    *(_DWORD *)(v59 + 76) = v60 + 1;
    v61 = v59 + 16 * v60;
    *(_QWORD *)(v61 + 104) = Buffer;
    *(_QWORD *)(v61 + 112) = 12 * v17;
    pthread_mutex_unlock((pthread_mutex_t *)v59);
    if (!v10)
      goto LABEL_100;
    goto LABEL_96;
  }
  pthread_mutex_unlock((pthread_mutex_t *)v59);
  v62 = *(void (**)(_QWORD, void *))(v59 + 88);
  if (v62)
  {
    v62(*(_QWORD *)(v59 + 96), Buffer);
    goto LABEL_95;
  }
  free(Buffer);
  if (!v10)
    goto LABEL_100;
LABEL_96:
  v63 = *(_QWORD *)(a1 + 128);
  pthread_mutex_lock((pthread_mutex_t *)v63);
  v64 = *(int *)(v63 + 68);
  if ((int)v64 >= *(_DWORD *)(v63 + 64))
  {
    ZSTD_freeCCtx((unint64_t)v10);
  }
  else
  {
    *(_DWORD *)(v63 + 68) = v64 + 1;
    *(_QWORD *)(v63 + 8 * v64 + 96) = v10;
  }
  pthread_mutex_unlock((pthread_mutex_t *)v63);
LABEL_100:
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v65 = *(_QWORD *)(a1 + 8) + v55;
  *(_QWORD *)a1 = *(_QWORD *)(a1 + 200);
  *(_QWORD *)(a1 + 8) = v65;
  pthread_cond_signal((pthread_cond_t *)(a1 + 80));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
}

void *ZSTDMT_getBuffer(uint64_t a1)
{
  size_t v2;
  int v3;
  unsigned int v4;
  uint64_t v5;
  void *v6;
  size_t v7;
  void (*v9)(_QWORD, void *);
  uint64_t (*v10)(_QWORD, size_t);

  v2 = *(_QWORD *)(a1 + 64);
  pthread_mutex_lock((pthread_mutex_t *)a1);
  v3 = *(_DWORD *)(a1 + 76);
  if (v3)
  {
    v4 = v3 - 1;
    *(_DWORD *)(a1 + 76) = v4;
    v5 = a1 + 16 * v4;
    v6 = *(void **)(v5 + 104);
    v7 = *(_QWORD *)(v5 + 112);
    *(_QWORD *)(v5 + 104) = 0;
    *(_QWORD *)(v5 + 112) = 0;
    if (v7 >= v2 && v7 >> 3 <= v2)
    {
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      return v6;
    }
    if (v6)
    {
      v9 = *(void (**)(_QWORD, void *))(a1 + 88);
      if (!v9)
      {
        free(v6);
        pthread_mutex_unlock((pthread_mutex_t *)a1);
        v10 = *(uint64_t (**)(_QWORD, size_t))(a1 + 80);
        if (v10)
          return (void *)v10(*(_QWORD *)(a1 + 96), v2);
        return malloc_type_malloc(v2, 0x26AA08A0uLL);
      }
      v9(*(_QWORD *)(a1 + 96), v6);
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  v10 = *(uint64_t (**)(_QWORD, size_t))(a1 + 80);
  if (v10)
    return (void *)v10(*(_QWORD *)(a1 + 96), v2);
  return malloc_type_malloc(v2, 0x26AA08A0uLL);
}

uint64_t ZSTD_execSequenceEnd(_OWORD *a1, uint64_t a2, uint64_t *a3, __int128 **a4, uint64_t a5, char *a6, uint64_t a7, unint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v11;
  char *v12;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  _OWORD *v21;
  char *v22;
  __int128 v23;
  char *v24;
  _BYTE *v25;
  __int128 *v26;
  _OWORD *v27;
  __int128 v28;
  char *v29;
  char *v30;
  unint64_t v31;
  _BYTE *v32;
  _OWORD *v33;
  __int128 *v34;
  unint64_t v35;
  __int128 v36;
  _QWORD *v37;
  uint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  _OWORD *v42;
  __int128 *v43;
  unint64_t v44;
  __int128 v45;
  _QWORD *v46;
  uint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  char v50;
  char v51;
  char *v52;
  unint64_t v53;
  uint64_t v54;
  char *v55;
  char *v56;
  unint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  size_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  char *v65;
  char *v66;
  char *v67;
  uint64_t v68;
  __int128 v69;
  unint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  char *v73;
  char *v74;
  _OWORD *v75;
  __int128 *v76;
  unint64_t v77;
  __int128 v78;
  _QWORD *v79;
  char *v80;
  unint64_t v81;
  uint64_t v82;
  __int128 *v83;
  __int128 v84;
  char *v85;
  char *v86;
  unint64_t v87;
  char *v88;
  unint64_t v89;
  _OWORD *v90;
  char *v91;
  unint64_t v92;
  __int128 v93;
  char *v94;
  char *v95;
  unint64_t v96;
  uint64_t v97;
  char v98;
  char v99;

  v8 = *a3;
  v9 = a3[1] + *a3;
  if (v9 > a2 - (uint64_t)a1)
    return -70;
  v11 = *a4;
  if (v8 > (unint64_t)(a5 - (_QWORD)*a4))
    return -20;
  v12 = a6;
  v14 = (_QWORD *)((char *)a1 + v8);
  v15 = (char *)v11 + v8;
  v16 = a3[2];
  v17 = a2 - 32;
  if (v8 <= 7)
  {
    if (v8 < 1)
      goto LABEL_53;
    v18 = (char *)a1 + v8;
    if ((char *)a1 + v8 <= (char *)a1 + 1)
      v18 = (char *)a1 + 1;
    v19 = v18 - (char *)a1;
    if (v19 < 8 || (unint64_t)((char *)a1 - (char *)v11) < 0x20)
    {
      v24 = (char *)*a4;
      v25 = a1;
      goto LABEL_49;
    }
    if (v19 < 0x20)
    {
      v20 = 0;
      goto LABEL_32;
    }
    v20 = v19 & 0xFFFFFFFFFFFFFFE0;
    v33 = a1 + 1;
    v34 = v11 + 1;
    v35 = v19 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      v36 = *v34;
      *(v33 - 1) = *(v34 - 1);
      *v33 = v36;
      v33 += 2;
      v34 += 2;
      v35 -= 32;
    }
    while (v35);
    if (v19 != v20)
    {
      if ((v19 & 0x18) == 0)
      {
        v25 = (char *)a1 + v20;
        v24 = (char *)v11 + v20;
        goto LABEL_49;
      }
LABEL_32:
      v24 = (char *)v11 + (v19 & 0xFFFFFFFFFFFFFFF8);
      v25 = (char *)a1 + (v19 & 0xFFFFFFFFFFFFFFF8);
      v37 = (_QWORD *)((char *)a1 + v20);
      v38 = (uint64_t *)((char *)v11 + v20);
      v39 = v20 - (v19 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        v40 = *v38++;
        *v37++ = v40;
        v39 += 8;
      }
      while (v39);
      if (v19 == (v19 & 0xFFFFFFFFFFFFFFF8))
        goto LABEL_53;
      do
      {
LABEL_49:
        v50 = *v24++;
        *v25++ = v50;
      }
      while (v25 < (_BYTE *)v14);
      goto LABEL_53;
    }
    goto LABEL_53;
  }
  if ((unint64_t)v14 <= v17)
  {
    do
    {
      v23 = *v11++;
      *a1++ = v23;
    }
    while (a1 < (_OWORD *)v14);
    goto LABEL_53;
  }
  if (v17 >= (unint64_t)a1)
  {
    v26 = *a4;
    v27 = a1;
    do
    {
      v28 = *v26++;
      *v27++ = v28;
    }
    while ((unint64_t)v27 < v17);
    v22 = (char *)v11 + v17 - (_QWORD)a1;
    v21 = (_OWORD *)(a2 - 32);
  }
  else
  {
    v21 = a1;
    v22 = (char *)*a4;
  }
  if (v21 < (_OWORD *)v14)
  {
    v29 = (char *)a1 + v8;
    if ((unint64_t)a1 <= v17)
      v30 = (char *)(a2 - 32);
    else
      v30 = (char *)a1;
    v31 = v29 - v30;
    if (v31 < 8)
    {
      v32 = v21;
      goto LABEL_52;
    }
    if ((unint64_t)((char *)a1 - (char *)v11) < 0x20)
    {
      v32 = v21;
      goto LABEL_52;
    }
    if (v31 >= 0x20)
    {
      v41 = v31 & 0xFFFFFFFFFFFFFFE0;
      v42 = v21 + 1;
      v43 = (__int128 *)((char *)v11 + v30 - (char *)a1 + 16);
      v44 = v31 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v45 = *v43;
        *(v42 - 1) = *(v43 - 1);
        *v42 = v45;
        v42 += 2;
        v43 += 2;
        v44 -= 32;
      }
      while (v44);
      if (v31 == v41)
        goto LABEL_53;
      if ((v31 & 0x18) == 0)
      {
        v32 = (char *)v21 + v41;
        v22 += v41;
        goto LABEL_52;
      }
    }
    else
    {
      v41 = 0;
    }
    v22 += v31 & 0xFFFFFFFFFFFFFFF8;
    v32 = (char *)v21 + (v31 & 0xFFFFFFFFFFFFFFF8);
    v46 = (_QWORD *)((char *)v21 + v41);
    v47 = (uint64_t *)((char *)v11 + &v30[v41] - (char *)a1);
    v48 = v41 - (v31 & 0xFFFFFFFFFFFFFFF8);
    do
    {
      v49 = *v47++;
      *v46++ = v49;
      v48 += 8;
    }
    while (v48);
    if (v31 == (v31 & 0xFFFFFFFFFFFFFFF8))
      goto LABEL_53;
    do
    {
LABEL_52:
      v51 = *v22++;
      *v32++ = v51;
    }
    while (v32 < (_BYTE *)v14);
  }
LABEL_53:
  v52 = (char *)v14 - v16;
  *a4 = (__int128 *)v15;
  v53 = a3[2];
  if (v53 <= (char *)v14 - a6)
  {
    v54 = a3[1];
    v12 = v52;
    v55 = (char *)v14 + v54;
    if (v54 > 7)
      goto LABEL_66;
    goto LABEL_57;
  }
  if (v53 > (unint64_t)v14 - a7)
    return -20;
  v59 = (char *)(v52 - a6);
  v60 = (char *)(a8 + v52 - a6);
  v61 = a3[1];
  if ((unint64_t)&v60[v61] > a8)
  {
    memmove(v14, v60, a6 - v52);
    v14 = (_QWORD *)((char *)v14 - v59);
    v54 = (uint64_t)&v59[a3[1]];
    a3[1] = v54;
    v55 = (char *)v14 + v54;
    if (v54 > 7)
    {
LABEL_66:
      if ((unint64_t)((char *)v14 - v12) > 7)
      {
        *v14 = *(_QWORD *)v12;
        v65 = v12 + 8;
        v66 = (char *)(v14 + 1);
        if ((unint64_t)v55 <= v17)
        {
LABEL_68:
          v67 = &v66[v54];
          if (v66 - v65 >= 16)
          {
            do
            {
              v69 = *(_OWORD *)v65;
              v65 += 16;
              *(_OWORD *)v66 = v69;
              v66 += 16;
            }
            while (v66 < v67);
          }
          else
          {
            do
            {
              v68 = *(_QWORD *)v65;
              v65 += 8;
              *(_QWORD *)v66 = v68;
              v66 += 8;
            }
            while (v66 < v67);
          }
          return v9;
        }
      }
      else
      {
        v62 = 4 * ((char *)v14 - v12);
        v63 = *(int *)((char *)&ZSTD_overlapCopy8_dec64table + v62);
        *(_BYTE *)v14 = *v12;
        *((_BYTE *)v14 + 1) = v12[1];
        *((_BYTE *)v14 + 2) = v12[2];
        *((_BYTE *)v14 + 3) = v12[3];
        v64 = &v12[*(unsigned int *)((char *)&ZSTD_overlapCopy8_dec32table + v62)];
        *((_DWORD *)v14 + 1) = *(_DWORD *)v64;
        v12 = &v64[-v63];
        v65 = &v64[-v63 + 8];
        v66 = (char *)(v14 + 1);
        if ((unint64_t)v55 <= v17)
          goto LABEL_68;
      }
      if ((unint64_t)v66 <= v17)
      {
        v70 = v17 - (_QWORD)v66;
        if (v66 - v65 >= 16)
        {
          v83 = (__int128 *)v65;
          do
          {
            v84 = *v83++;
            *(_OWORD *)v66 = v84;
            v66 += 16;
          }
          while ((unint64_t)v66 < v17);
        }
        else
        {
          v71 = (uint64_t *)v65;
          do
          {
            v72 = *v71++;
            *(_QWORD *)v66 = v72;
            v66 += 8;
          }
          while ((unint64_t)v66 < v17);
        }
        v65 += v70;
        v66 = (char *)v17;
      }
      if (v66 >= v55)
        return v9;
      v85 = (char *)v14 + v54;
      v86 = (char *)(v14 + 1);
      if (v17 > (unint64_t)(v14 + 1))
        v86 = (char *)v17;
      v87 = v85 - v86;
      if (v87 < 8)
      {
        v88 = v66;
        goto LABEL_113;
      }
      if ((unint64_t)((char *)v14 - v12) < 0x20)
      {
        v88 = v66;
        goto LABEL_113;
      }
      if (v87 >= 0x20)
      {
        v89 = v87 & 0xFFFFFFFFFFFFFFE0;
        v90 = v66 + 16;
        v91 = &v12[v86 - (char *)v14 + 16];
        v92 = v87 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v93 = *(_OWORD *)v91;
          *(v90 - 1) = *((_OWORD *)v91 - 1);
          *v90 = v93;
          v90 += 2;
          v91 += 32;
          v92 -= 32;
        }
        while (v92);
        if (v87 == v89)
          return v9;
        if ((v87 & 0x18) == 0)
        {
          v88 = &v66[v89];
          v65 += v89;
          do
          {
LABEL_113:
            v99 = *v65++;
            *v88++ = v99;
          }
          while (v88 < v55);
          return v9;
        }
      }
      else
      {
        v89 = 0;
      }
      v65 += v87 & 0xFFFFFFFFFFFFFFF8;
      v88 = &v66[v87 & 0xFFFFFFFFFFFFFFF8];
      v94 = &v66[v89];
      v95 = &v12[&v86[v89] - (char *)v14];
      v96 = v89 - (v87 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        v97 = *(_QWORD *)v95;
        v95 += 8;
        *(_QWORD *)v94 = v97;
        v94 += 8;
        v96 += 8;
      }
      while (v96);
      if (v87 == (v87 & 0xFFFFFFFFFFFFFFF8))
        return v9;
      goto LABEL_113;
    }
LABEL_57:
    if (v54 < 1)
      return v9;
    v56 = (char *)v14 + v54;
    if ((char *)v14 + v54 <= (char *)v14 + 1)
      v56 = (char *)v14 + 1;
    v57 = v56 - (char *)v14;
    if (v57 < 8 || (unint64_t)((char *)v14 - v12) < 0x20)
    {
      v73 = v12;
      v74 = (char *)v14;
    }
    else
    {
      if (v57 < 0x20)
      {
        v58 = 0;
        goto LABEL_85;
      }
      v58 = v57 & 0xFFFFFFFFFFFFFFE0;
      v75 = v14 + 2;
      v76 = (__int128 *)(v12 + 16);
      v77 = v57 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        v78 = *v76;
        *(v75 - 1) = *(v76 - 1);
        *v75 = v78;
        v75 += 2;
        v76 += 2;
        v77 -= 32;
      }
      while (v77);
      if (v57 == v58)
        return v9;
      if ((v57 & 0x18) != 0)
      {
LABEL_85:
        v73 = &v12[v57 & 0xFFFFFFFFFFFFFFF8];
        v74 = (char *)v14 + (v57 & 0xFFFFFFFFFFFFFFF8);
        v79 = (_QWORD *)((char *)v14 + v58);
        v80 = &v12[v58];
        v81 = v58 - (v57 & 0xFFFFFFFFFFFFFFF8);
        do
        {
          v82 = *(_QWORD *)v80;
          v80 += 8;
          *v79++ = v82;
          v81 += 8;
        }
        while (v81);
        if (v57 == (v57 & 0xFFFFFFFFFFFFFFF8))
          return v9;
        goto LABEL_110;
      }
      v74 = (char *)v14 + v58;
      v73 = &v12[v58];
    }
    do
    {
LABEL_110:
      v98 = *v73++;
      *v74++ = v98;
    }
    while (v74 < v55);
    return v9;
  }
  memmove(v14, v60, v61);
  return v9;
}

uint64_t COVER_strict_cmp8(unsigned int *a1, unsigned int *a2)
{
  int v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unsigned int v7;
  unsigned int v8;

  v2 = *(_DWORD *)(g_coverCtx + 80);
  if (v2 == 8)
    v3 = -1;
  else
    v3 = ~(-1 << (8 * v2));
  v4 = v3 & *(_QWORD *)(*(_QWORD *)g_coverCtx + *a1);
  v5 = *(_QWORD *)(*(_QWORD *)g_coverCtx + *a2) & v3;
  v6 = v4 >= v5;
  v7 = v4 > v5;
  if (!v6)
    v7 = -1;
  if (a1 < a2)
    v8 = -1;
  else
    v8 = 1;
  if (v7)
    return v7;
  else
    return v8;
}

uint64_t COVER_strict_cmp(unsigned int *a1, unsigned int *a2)
{
  uint64_t result;
  unsigned int v5;

  LODWORD(result) = memcmp((const void *)(*(_QWORD *)g_coverCtx + *a1), (const void *)(*(_QWORD *)g_coverCtx + *a2), *(unsigned int *)(g_coverCtx + 80));
  if (a1 < a2)
    v5 = -1;
  else
    v5 = 1;
  if ((_DWORD)result)
    return result;
  else
    return v5;
}

uint64_t COVER_cmp8(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  int v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  _BOOL4 v8;

  v3 = *(_DWORD *)(a1 + 80);
  if (v3 == 8)
    v4 = -1;
  else
    v4 = ~(-1 << (8 * v3));
  v5 = v4 & *(_QWORD *)(*(_QWORD *)a1 + *a2);
  v6 = *(_QWORD *)(*(_QWORD *)a1 + *a3) & v4;
  v7 = v5 >= v6;
  v8 = v5 > v6;
  if (v7)
    return v8;
  else
    return 0xFFFFFFFFLL;
}

uint64_t COVER_cmp(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return memcmp((const void *)(*(_QWORD *)a1 + *a2), (const void *)(*(_QWORD *)a1 + *a3), *(unsigned int *)(a1 + 80));
}

uint64_t ss_mintrosort(uint64_t result, uint64_t a2, int *a3, unint64_t a4)
{
  unint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  int *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int *v15;
  int *v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  _BOOL4 v26;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  unsigned int v54;
  int v55;
  int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  int v72;
  int *v73;
  uint64_t v74;
  unsigned int v75;
  unsigned int v76;
  int v77;
  unsigned int v78;
  int *v79;
  unsigned int v80;
  BOOL v81;
  int v82;
  char *v83;
  uint64_t v84;
  uint64_t v85;
  int *v86;
  int *v87;
  uint64_t v88;
  char *v89;
  char *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int *v94;
  uint64_t v95;
  unsigned int v96;
  unsigned int v97;
  int v98;
  int *v99;
  unsigned int v100;
  unsigned int v101;
  int v102;
  int *v103;
  unsigned int v104;
  unsigned int v105;
  int v106;
  int *v107;
  unsigned int v108;
  unsigned int v109;
  int v110;
  int *v111;
  unsigned int v112;
  int *v113;
  unsigned int v114;
  int v115;
  unsigned int v116;
  int *v117;
  unsigned int v118;
  int v119;
  unsigned int v120;
  unsigned int v121;
  int v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  char **v126;
  int v127;
  char **v128;
  uint64_t v129;
  int *v130;
  uint64_t v131;
  unsigned int v132;
  int *v133;
  unsigned int v134;
  BOOL v135;
  int *v136;
  uint64_t v137;
  unsigned int v138;
  unsigned int v139;
  int *v140;
  unsigned int v141;
  unsigned int v142;
  BOOL v143;
  int *v144;
  int *v145;
  unsigned int v146;
  uint64_t v147;
  unsigned int v148;
  BOOL v149;
  unsigned int v150;
  int *v151;
  int *v152;
  uint64_t v153;
  unsigned int v154;
  int *v155;
  int *j;
  unsigned int v157;
  int *v158;
  int *i;
  unsigned int v160;
  uint64_t v161;
  unsigned int v162;
  uint64_t v163;
  unsigned int v164;
  int v165;
  uint64_t v166;
  unsigned int v167;
  uint64_t v168;
  unsigned int v169;
  int *v170;
  int *v171;
  uint64_t v172;
  uint64_t v173;
  unint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  int *v178;
  int *v179;
  unint64_t v180;
  BOOL v181;
  uint64_t v182;
  __int128 *v183;
  int *v184;
  uint64_t v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  BOOL v189;
  unsigned int v190;
  int v191;
  uint64_t v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  int *v196;
  BOOL v197;
  int v198;
  uint64_t v199;
  int *v200;
  __int128 *v201;
  __int128 *v202;
  uint64_t v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  unsigned int v207;
  int v208;
  int *v209;
  unint64_t v210;
  unsigned int v211;
  int *v212;
  int *v213;
  uint64_t v214;
  uint64_t v215;
  __int16 v216;
  uint64_t v217;
  int **v218;
  uint64_t v219;
  _QWORD *v220;
  unint64_t *v221;
  _QWORD *v222;
  _QWORD *v223;
  uint64_t v224;
  int **v225;
  _QWORD *v226;
  _QWORD *v227;
  int **v228;
  int v229;
  int v230;
  int v231;
  int v232;
  int v233;
  _QWORD *v234;
  _QWORD *v235;
  _QWORD v236[49];

  v236[48] = *MEMORY[0x1E0C80C00];
  v4 = a4 - (_QWORD)a3;
  if (((a4 - (_QWORD)a3) & 0x3FC00) != 0)
    v5 = lg_table[(v4 >> 10)] + 8;
  else
    v5 = *(_DWORD *)((char *)lg_table + (v4 & 0x3FC));
  LODWORD(v6) = 0;
  v7 = result + 2;
  v8 = 2;
LABEL_5:
  v9 = a4 - (_QWORD)a3;
  if ((uint64_t)(a4 - (_QWORD)a3) > 35)
    goto LABEL_35;
  v6 = (int)v6;
  while (1)
  {
    if ((uint64_t)v9 >= 5)
    {
      v10 = (int *)(a4 - 8);
      if (a4 - 8 >= (unint64_t)a3)
      {
        v12 = result + v8;
        do
        {
          v13 = *v10;
          v15 = v10 + 1;
          v14 = v10[1];
          v16 = (int *)(a2 + 4 * v13);
LABEL_15:
          v17 = (int *)(a2 + 4 * v14);
          v18 = *v16;
          v19 = *v17;
          v20 = v17[1];
          v21 = (unsigned __int8 *)(v12 + v18);
          v22 = (unsigned __int8 *)(v12 + v19);
          v23 = v7 + v16[1];
          v24 = v7 + v20;
          v25 = v12 + v19 < (unint64_t)(v7 + v20);
          v26 = v12 + v18 < v23;
          if (v12 + v18 >= v23 || (unint64_t)v22 >= v24)
          {
LABEL_20:
            if (!v26)
            {
              v30 = v25 << 31 >> 31;
              goto LABEL_33;
            }
            if (!v25)
              goto LABEL_24;
            v28 = *v21;
            v29 = *v22;
          }
          else
          {
            v32 = v12;
            while (1)
            {
              v28 = *(unsigned __int8 *)(v32 + v18);
              v29 = *(unsigned __int8 *)(v32 + v19);
              if (v28 != v29)
                break;
              v21 = (unsigned __int8 *)(++v32 + v18);
              v22 = (unsigned __int8 *)(v32 + v19);
              v25 = v32 + v19 < v24;
              v26 = v32 + v18 < v23;
              if (v32 + v18 >= v23 || (unint64_t)v22 >= v24)
                goto LABEL_20;
            }
          }
          v30 = v28 - v29;
          if (v30 >= 1)
          {
LABEL_24:
            ++v15;
            while (1)
            {
              *(v15 - 2) = v14;
              if ((unint64_t)v15 >= a4)
                goto LABEL_13;
              v31 = *v15++;
              v14 = v31;
              if ((v31 & 0x80000000) == 0)
              {
                --v15;
                goto LABEL_15;
              }
            }
          }
LABEL_33:
          if (!v30)
            *v15 = ~v14;
LABEL_13:
          *(v15 - 1) = v13;
          --v10;
        }
        while (v10 >= a3);
      }
    }
    if (!v6)
      return result;
    --v6;
    v11 = &v236[3 * v6];
    a3 = (int *)*v11;
    a4 = v11[1];
    v8 = *((_DWORD *)v11 + 4);
    v9 = a4 - (_QWORD)a3;
    if ((uint64_t)(a4 - (_QWORD)a3) >= 36)
    {
      v5 = HIDWORD(v236[3 * v6 + 2]);
LABEL_35:
      v33 = v9 >> 2;
      v34 = result + v8;
      if (!v5)
      {
        v35 = v9 >> 2;
        if ((v9 & 4) == 0)
        {
          LODWORD(v35) = v33 - 1;
          v36 = (int)v33 >= 1 ? v33 - 1 : v9 >> 2;
          v37 = a3[v36 >> 1];
          v38 = a3[(int)v35];
          if (*(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v37)) < *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v38)))
          {
            a3[(int)v35] = v37;
            a3[(uint64_t)v36 >> 1] = v38;
          }
        }
        if ((int)v35 >= 2)
        {
          v39 = v35 >> 1;
          do
          {
            v41 = a3[(v39 - 1)];
            v42 = (2 * (v39 - 1)) | 1;
            if (v42 >= (int)v35)
            {
              v40 = v39 - 1;
            }
            else
            {
              v43 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v41));
              v44 = 2 * (v39 - 1);
              v45 = v39 - 1;
              while (1)
              {
                v40 = v44 + 2;
                v46 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v42]));
                v47 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v40]));
                v48 = v46 <= v47
                    ? *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v40]))
                    : *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v42]));
                if (v48 <= v43)
                  break;
                if (v46 >= v47)
                  v40 = v42;
                a3[v45] = a3[v40];
                v44 = 2 * v40;
                v42 = (2 * v40) | 1;
                v45 = v40;
                if (v42 >= (int)v35)
                  goto LABEL_45;
              }
              v40 = v45;
            }
LABEL_45:
            a3[v40] = v41;
            v81 = v39-- <= 1;
          }
          while (!v81);
        }
        if ((v9 & 4) == 0)
        {
          v49 = (int)v35;
          v50 = *a3;
          *a3 = a3[v49];
          a3[v49] = v50;
          v51 = *a3;
          if ((int)v35 < 2)
          {
            v60 = 0;
          }
          else
          {
            v52 = 0;
            v53 = 0;
            v54 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v51));
            v55 = 1;
            while (1)
            {
              v56 = v52 + 2;
              v57 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v55]));
              v58 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v56]));
              v59 = v57 <= v58
                  ? *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v56]))
                  : *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v55]));
              if (v59 <= v54)
                break;
              if (v57 >= v58)
                v60 = v55;
              else
                v60 = v56;
              a3[v53] = a3[v60];
              v52 = 2 * v60;
              v55 = (2 * v60) | 1;
              v53 = v60;
              if (v55 >= (int)v35)
                goto LABEL_71;
            }
            v60 = v53;
          }
LABEL_71:
          a3[v60] = v51;
        }
        if ((int)v35 > 1)
        {
          v35 = v35;
          do
          {
            v62 = *a3;
            v63 = a3[(v35 - 1)];
            *a3 = v63;
            if ((v35 - 1) < 2)
            {
              v61 = 0;
            }
            else
            {
              v64 = 0;
              v65 = 0;
              v66 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v63));
              v67 = 1;
              while (1)
              {
                v68 = v64 + 2;
                v69 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v67]));
                v70 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v68]));
                v71 = v69 <= v70
                    ? *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v68]))
                    : *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v67]));
                if (v71 <= v66)
                  break;
                if (v69 >= v70)
                  v61 = v67;
                else
                  v61 = v68;
                a3[v65] = a3[v61];
                v64 = 2 * v61;
                v67 = (2 * v61) | 1;
                v65 = v61;
                if (v67 >= (int)v35 - 1)
                  goto LABEL_75;
              }
              v61 = v65;
            }
LABEL_75:
            a3[v61] = v63;
            a3[(v35 - 1)] = v62;
            v81 = v35-- <= 2;
          }
          while (!v81);
        }
      }
      if (v5 < 1)
      {
        v83 = (char *)(a3 + 1);
        v84 = *(int *)(a2 + 4 * *a3);
        v85 = *(unsigned __int8 *)(v34 + v84);
        if ((unint64_t)(a3 + 1) >= a4)
          goto LABEL_117;
        v86 = a3 + 1;
        while (1)
        {
          v88 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *(int *)v83));
          if ((_DWORD)v85 != (_DWORD)v88)
            break;
          v87 = a3;
          v88 = v85;
LABEL_112:
          v83 += 4;
          ++v86;
          v85 = v88;
          a3 = v87;
          if ((unint64_t)v83 >= a4)
            goto LABEL_116;
        }
        v87 = (int *)v83;
        if ((char *)v86 - (char *)a3 <= 4)
          goto LABEL_112;
        v87 = a3;
        LODWORD(v88) = v85;
LABEL_116:
        LODWORD(v84) = *(_DWORD *)(a2 + 4 * *v87);
        a3 = v87;
        LODWORD(v85) = v88;
LABEL_117:
        if ((int)v85 <= *(unsigned __int8 *)(v34 + (int)v84 - 1))
        {
          v90 = (char *)a3;
        }
        else
        {
          v89 = v83;
          v90 = (char *)a3;
          if (a3 >= (int *)v83)
            goto LABEL_121;
          do
          {
LABEL_119:
            v91 = *(int *)v90;
            if (*(_DWORD *)(a2 + 4 * v91) + v8 <= *(_DWORD *)(a2 + 4 * ((int)v91 + 1)))
              break;
            *(_DWORD *)v90 = ~(_DWORD)v91;
            v90 += 4;
          }
          while (v90 < v89);
LABEL_121:
          while (1)
          {
            v89 -= 4;
            if (v90 >= v89)
              break;
            v92 = *(int *)v89;
            if (*(_DWORD *)(a2 + 4 * v92) + v8 > *(_DWORD *)(a2 + 4 * ((int)v92 + 1)))
            {
              *(_DWORD *)v89 = *(_DWORD *)v90;
              *(_DWORD *)v90 = ~(_DWORD)v92;
              v90 += 4;
              if (v90 < v89)
                goto LABEL_119;
            }
          }
          if (v90 > (char *)a3)
            *a3 = ~*a3;
        }
        v124 = v83 - v90;
        v125 = (v83 - v90) >> 2;
        if (v125 <= (uint64_t)(a4 - (_QWORD)v83) >> 2)
        {
          v5 = -1;
          a3 = (int *)v83;
          if (v124 < 5)
            goto LABEL_5;
          v128 = (char **)&v236[3 * (int)v6];
          *v128 = v83;
          v128[1] = (char *)a4;
          LODWORD(v6) = v6 + 1;
          *((_DWORD *)v128 + 4) = v8;
          *((_DWORD *)v128 + 5) = -1;
LABEL_195:
          ++v8;
          if ((v124 & 0x3FC00) != 0)
            v5 = lg_table[BYTE1(v125)] + 8;
          else
            v5 = *(_DWORD *)((char *)lg_table + (v124 & 0x3FC));
          a3 = (int *)v90;
          a4 = (unint64_t)v83;
        }
        else
        {
          if ((uint64_t)(a4 - (_QWORD)v83) < 5)
            goto LABEL_195;
          v126 = (char **)&v236[3 * (int)v6];
          *v126 = v90;
          v126[1] = v83;
          *((_DWORD *)v126 + 4) = v8 + 1;
          if ((v124 & 0x3FC00) != 0)
            v127 = lg_table[BYTE1(v125)] + 8;
          else
            v127 = *(_DWORD *)((char *)lg_table + (v124 & 0x3FC));
          v233 = v6;
          LODWORD(v6) = v6 + 1;
          HIDWORD(v236[3 * v233 + 2]) = v127;
          v5 = -1;
          a3 = (int *)v83;
        }
      }
      else
      {
        if ((v33 & 0x80000000) == 0)
          v72 = v9 >> 2;
        else
          v72 = v33 + 1;
        v73 = &a3[v72 >> 1];
        if ((int)v33 > 512)
        {
          v93 = v33 >> 3;
          v94 = &a3[v93];
          v95 = (2 * v93);
          v74 = *a3;
          v96 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v74));
          v97 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v94));
          if (v96 <= v97)
            v98 = *v94;
          else
            v98 = *a3;
          if (v96 <= v97)
            v99 = &a3[v93];
          else
            v99 = a3;
          v100 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v98));
          v101 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * a3[v95]));
          if (v100 > v101)
          {
            if (v96 <= v97)
              v102 = *a3;
            else
              v102 = *v94;
            if (v96 <= v97)
              v94 = a3;
            if (*(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v102)) <= v101)
              v99 = &a3[v95];
            else
              v99 = v94;
          }
          v103 = &v73[v93];
          v104 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v73[-v93]));
          v105 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v73));
          if (v104 <= v105)
            v106 = *v73;
          else
            v106 = v73[-v93];
          if (v104 <= v105)
            v107 = v73;
          else
            v107 = &v73[-v93];
          v108 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v106));
          v109 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v103));
          if (v108 > v109)
          {
            if (v104 <= v105)
              v110 = v73[-v93];
            else
              v110 = *v73;
            if (v104 <= v105)
              v73 -= v93;
            if (*(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v110)) <= v109)
              v107 = v103;
            else
              v107 = v73;
          }
          v111 = (int *)(a4 - 4 - 4 * v95);
          v112 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v111));
          v113 = (int *)(a4 - 4 - 4 * v93);
          v114 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v113));
          if (v112 <= v114)
            v115 = *v113;
          else
            v115 = *v111;
          v116 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v115));
          if (v112 <= v114)
            v117 = v113;
          else
            v117 = v111;
          v118 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *(int *)(a4 - 4)));
          if (v116 > v118)
          {
            if (v112 <= v114)
              v119 = *v111;
            else
              v119 = *v113;
            if (v112 > v114)
              v111 = v113;
            if (*(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v119)) <= v118)
              v117 = (int *)(a4 - 4);
            else
              v117 = v111;
            v116 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v117));
          }
          v120 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v99));
          v121 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v107));
          if (v120 <= v121)
            v122 = *v107;
          else
            v122 = *v99;
          if (v120 <= v121)
            v79 = v107;
          else
            v79 = v99;
          if (*(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v122)) > v116)
          {
            if (v120 <= v121)
              v123 = *v99;
            else
              v123 = *v107;
            if (v120 > v121)
              v99 = v107;
            if (*(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v123)) <= v116)
              v79 = v117;
            else
              v79 = v99;
          }
        }
        else if ((int)v33 > 32)
        {
          v129 = (v9 >> 4) & 0x3FFFFFFF;
          v130 = &a3[v129];
          v131 = a3[v129];
          v132 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v131));
          v133 = (int *)(a4 - 4 - v129 * 4);
          v134 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v73));
          v135 = v132 > v134;
          if (v132 <= v134)
          {
            v136 = v130;
          }
          else
          {
            LODWORD(v131) = *v73;
            v136 = v73;
          }
          if (!v135)
            v130 = v73;
          v137 = *v133;
          v138 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v137));
          v139 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *(int *)(a4 - 4)));
          if (v138 <= v139)
          {
            v140 = v133;
          }
          else
          {
            LODWORD(v137) = *(_DWORD *)(a4 - 4);
            v140 = (int *)(a4 - 4);
          }
          if (v138 <= v139)
            v133 = (int *)(a4 - 4);
          v141 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * (int)v131));
          v142 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * (int)v137));
          v143 = v141 > v142;
          if (v141 <= v142)
            v144 = v130;
          else
            v144 = v133;
          if (v143)
            v145 = v136;
          else
            v145 = v140;
          v146 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *a3));
          if (v143)
            v133 = v130;
          v147 = *v144;
          v148 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v147));
          v149 = v146 > v148;
          if (v146 <= v148)
            LODWORD(v147) = *a3;
          v150 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * (int)v147));
          if (v146 <= v148)
            v151 = a3;
          else
            v151 = v144;
          if (v149)
            v144 = a3;
          if (v150 > *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v145)))
          {
            v152 = v151;
          }
          else
          {
            v133 = v144;
            v152 = v145;
          }
          if (*(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v133)) <= *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v152)))
            v79 = v133;
          else
            v79 = v152;
          LODWORD(v74) = *a3;
        }
        else
        {
          v74 = *a3;
          v75 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v74));
          v76 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v73));
          if (v75 <= v76)
            v77 = *v73;
          else
            v77 = *a3;
          v78 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v77));
          if (v75 <= v76)
            v79 = v73;
          else
            v79 = a3;
          v80 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *(int *)(a4 - 4)));
          if (v78 > v80)
          {
            v81 = v75 > v76;
            if (v75 <= v76)
              v82 = *a3;
            else
              v82 = *v73;
            if (!v81)
              v73 = a3;
            if (*(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v82)) <= v80)
              v79 = (int *)(a4 - 4);
            else
              v79 = v73;
          }
        }
        v153 = *v79;
        v154 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v153));
        *a3 = v153;
        v155 = a3 + 1;
        *v79 = v74;
        j = a3 + 1;
        if ((unint64_t)(a3 + 1) >= a4)
          goto LABEL_232;
        while (1)
        {
          v157 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v155));
          if (v157 != v154)
            break;
          j = ++v155;
          if ((unint64_t)v155 >= a4)
            goto LABEL_232;
        }
        if (v157 >= v154)
        {
          j = v155;
          v158 = (int *)(a4 - 4);
          i = (int *)(a4 - 4);
          if ((unint64_t)v155 < a4 - 4)
          {
LABEL_233:
            while (1)
            {
              v160 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * *v158));
              if (v160 != v154)
                break;
              i = --v158;
              if (j >= v158)
                goto LABEL_263;
            }
            if (v160 > v154)
            {
              for (i = v158 - 1; j < i; --i)
              {
                v163 = *i;
                v164 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v163));
                if (v164 < v154)
                  break;
                if (v164 == v154)
                {
                  *i = *v158;
                  *v158-- = v163;
                }
              }
            }
            else
            {
              i = v158;
            }
          }
        }
        else
        {
          for (j = v155 + 1; (unint64_t)j < a4; ++j)
          {
            v161 = *j;
            v162 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v161));
            if (v162 > v154)
              break;
            if (v162 == v154)
            {
              *j = *v155;
              *v155++ = v161;
            }
          }
LABEL_232:
          v158 = (int *)(a4 - 4);
          i = (int *)(a4 - 4);
          if ((unint64_t)j < a4 - 4)
            goto LABEL_233;
        }
LABEL_263:
        while (j < i)
        {
          v165 = *j;
          *j++ = *i;
          *i = v165;
          while (j < i)
          {
            v166 = *j;
            v167 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v166));
            if (v167 > v154)
              break;
            if (v167 == v154)
            {
              *j = *v155;
              *v155++ = v166;
            }
            ++j;
          }
          while (j < --i)
          {
            v168 = *i;
            v169 = *(unsigned __int8 *)(v34 + *(int *)(a2 + 4 * v168));
            if (v169 < v154)
              break;
            if (v169 == v154)
            {
              *i = *v158;
              *v158-- = v168;
            }
          }
        }
        if (v155 <= v158)
        {
          v174 = (unint64_t)((char *)v155 - (char *)a3) >> 2;
          v175 = j - v155;
          if ((int)v174 >= (int)v175)
            v176 = v175;
          else
            v176 = v174;
          v177 = (v176 - 1);
          if ((int)v176 >= 1)
          {
            v178 = &j[-v176];
            if (v176 < 8)
            {
              v179 = a3;
LABEL_292:
              v190 = v176 + 1;
              do
              {
                v191 = *v179;
                *v179++ = *v178;
                *v178++ = v191;
                --v190;
              }
              while (v190 > 1);
              goto LABEL_294;
            }
            v181 = a3 >= &j[v177 - v176 + 1] || v178 >= &a3[v177 + 1];
            v179 = a3;
            if (!v181)
              goto LABEL_292;
            v182 = v176 & 0xFFFFFFF8;
            v178 = (int *)((char *)v178 + v182 * 4);
            v179 = &a3[v182];
            v183 = (__int128 *)(a3 + 4);
            v184 = &j[-v176 + 4];
            v185 = v176 & 0xFFFFFFF8;
            do
            {
              v186 = *(v183 - 1);
              v187 = *v183;
              v188 = *(_OWORD *)v184;
              *(v183 - 1) = *((_OWORD *)v184 - 1);
              *v183 = v188;
              *((_OWORD *)v184 - 1) = v186;
              *(_OWORD *)v184 = v187;
              v183 += 2;
              v184 += 8;
              v185 -= 8;
            }
            while (v185);
            v189 = (v176 & 0x7FFFFFF8) == v176;
            LODWORD(v176) = v176 - (v176 & 0xFFFFFFF8);
            if (!v189)
              goto LABEL_292;
          }
LABEL_294:
          v192 = v158 - (j - 1);
          v193 = ((a4 - (unint64_t)v158) >> 2) - 1;
          if (v193 >= (int)v192)
            v194 = v192;
          else
            v194 = v193;
          v195 = (v194 - 1);
          if ((int)v194 < 1)
            goto LABEL_311;
          v196 = (int *)(a4 - 4 * v194);
          if (v194 >= 8
            && ((unint64_t)j < a4 + 4 * (v195 - v194) + 4
              ? (v197 = v196 >= &j[v195 + 1])
              : (v197 = 1),
                v197))
          {
            v198 = v194 - (v194 & 0xFFFFFFF8);
            v199 = v194 & 0xFFFFFFF8;
            v196 = (int *)((char *)v196 + v199 * 4);
            v200 = &j[v199];
            v201 = (__int128 *)(j + 4);
            v202 = (__int128 *)(a4 - 4 * v194 + 16);
            v203 = v194 & 0xFFFFFFF8;
            do
            {
              v204 = *(v201 - 1);
              v205 = *v201;
              v206 = *v202;
              *(v201 - 1) = *(v202 - 1);
              *v201 = v206;
              *(v202 - 1) = v204;
              *v202 = v205;
              v201 += 2;
              v202 += 2;
              v203 -= 8;
            }
            while (v203);
            if ((v194 & 0x7FFFFFF8) == v194)
              goto LABEL_311;
          }
          else
          {
            v198 = v194;
            v200 = j;
          }
          v207 = v198 + 1;
          do
          {
            v208 = *v200;
            *v200++ = *v196;
            *v196++ = v208;
            --v207;
          }
          while (v207 > 1);
LABEL_311:
          v209 = &a3[v175];
          v210 = a4 - 4 * v192;
          v211 = *(unsigned __int8 *)(*(int *)(a2 + 4 * *v209) + v34 - 1);
          v212 = v209;
          if (v154 > v211)
          {
            v213 = (int *)(a4 - 4 * v192);
            v212 = &a3[v175];
            if ((unint64_t)v209 >= v210)
              goto LABEL_315;
            do
            {
LABEL_313:
              v214 = *v212;
              if (*(_DWORD *)(a2 + 4 * v214) + v8 <= *(_DWORD *)(a2 + 4 * ((int)v214 + 1)))
                break;
              *v212++ = ~(_DWORD)v214;
            }
            while (v212 < v213);
LABEL_315:
            while (v212 < --v213)
            {
              v215 = *v213;
              if (*(_DWORD *)(a2 + 4 * v215) + v8 > *(_DWORD *)(a2 + 4 * ((int)v215 + 1)))
              {
                *v213 = *v212;
                *v212++ = ~(_DWORD)v215;
                if (v212 < v213)
                  goto LABEL_313;
              }
            }
            if (v212 > v209)
              *v209 = ~*v209;
          }
          --v5;
          v216 = v210 - (_WORD)v212;
          v217 = (uint64_t)(v210 - (_QWORD)v212) >> 2;
          if (v175 <= v192)
          {
            v223 = &v236[3 * (int)v6];
            if (v192 <= v217)
            {
              *v223 = v212;
              v223[1] = v210;
              *((_DWORD *)v223 + 4) = v8 + 1;
              if ((((_DWORD)v210 - (_DWORD)v212) & 0x3FC00) != 0)
                v230 = lg_table[BYTE1(v217)] + 8;
              else
                v230 = *(_DWORD *)((char *)lg_table + (v216 & 0x3FC));
              v235 = &v236[3 * (int)v6];
              *((_DWORD *)v235 + 5) = v230;
              v235[3] = v210;
              v235[4] = a4;
              LODWORD(v6) = v6 + 2;
              *((_DWORD *)v235 + 10) = v8;
              *((_DWORD *)v235 + 11) = v5;
              a4 = (unint64_t)&a3[v175];
            }
            else
            {
              *v223 = v210;
              v223[1] = a4;
              v224 = (int)v6 + 1;
              *((_DWORD *)v223 + 4) = v8;
              *((_DWORD *)v223 + 5) = v5;
              v225 = (int **)(v223 + 3);
              v226 = v223 + 4;
              if (v175 > v217)
              {
                *v225 = a3;
                *v226 = v209;
                v227 = &v236[3 * v224];
                LODWORD(v6) = v6 + 2;
                *((_DWORD *)v227 + 4) = v8;
                *((_DWORD *)v227 + 5) = v5;
                ++v8;
                if ((((_DWORD)v210 - (_DWORD)v212) & 0x3FC00) != 0)
                  goto LABEL_325;
                goto LABEL_329;
              }
              *v225 = v212;
              *v226 = v210;
              LODWORD(v236[3 * v224 + 2]) = v8 + 1;
              if ((((_DWORD)v210 - (_DWORD)v212) & 0x3FC00) != 0)
                v232 = lg_table[BYTE1(v217)] + 8;
              else
                v232 = *(_DWORD *)((char *)lg_table + (v216 & 0x3FC));
              LODWORD(v6) = v6 + 2;
              HIDWORD(v236[3 * v224 + 2]) = v232;
              a4 = (unint64_t)&a3[v175];
            }
          }
          else if (v175 <= v217)
          {
            v228 = (int **)&v236[3 * (int)v6];
            *v228 = v212;
            v228[1] = (int *)v210;
            *((_DWORD *)v228 + 4) = v8 + 1;
            if ((((_DWORD)v210 - (_DWORD)v212) & 0x3FC00) != 0)
              v229 = lg_table[BYTE1(v217)] + 8;
            else
              v229 = *(_DWORD *)((char *)lg_table + (v216 & 0x3FC));
            v234 = &v236[3 * (int)v6];
            *((_DWORD *)v234 + 5) = v229;
            v234[3] = a3;
            v234[4] = v209;
            LODWORD(v6) = v6 + 2;
            *((_DWORD *)v234 + 10) = v8;
            *((_DWORD *)v234 + 11) = v5;
            a3 = (int *)(a4 - 4 * v192);
          }
          else
          {
            v218 = (int **)&v236[3 * (int)v6];
            *v218 = a3;
            v218[1] = v209;
            v219 = (int)v6 + 1;
            *((_DWORD *)v218 + 4) = v8;
            *((_DWORD *)v218 + 5) = v5;
            v220 = v218 + 3;
            v221 = (unint64_t *)(v218 + 4);
            if (v192 > v217)
            {
              *v220 = v210;
              *v221 = a4;
              v222 = &v236[3 * v219];
              LODWORD(v6) = v6 + 2;
              *((_DWORD *)v222 + 4) = v8;
              *((_DWORD *)v222 + 5) = v5;
              ++v8;
              if ((((_DWORD)v210 - (_DWORD)v212) & 0x3FC00) != 0)
              {
LABEL_325:
                v5 = lg_table[BYTE1(v217)] + 8;
LABEL_330:
                a3 = v212;
                a4 = v210;
                goto LABEL_5;
              }
LABEL_329:
              v5 = *(_DWORD *)((char *)lg_table + (v216 & 0x3FC));
              goto LABEL_330;
            }
            *v220 = v212;
            *v221 = v210;
            LODWORD(v236[3 * v219 + 2]) = v8 + 1;
            if ((((_DWORD)v210 - (_DWORD)v212) & 0x3FC00) != 0)
              v231 = lg_table[BYTE1(v217)] + 8;
            else
              v231 = *(_DWORD *)((char *)lg_table + (v216 & 0x3FC));
            LODWORD(v6) = v6 + 2;
            HIDWORD(v236[3 * v219 + 2]) = v231;
            a3 = (int *)(a4 - 4 * v192);
          }
        }
        else
        {
          if (*(unsigned __int8 *)(*(int *)(a2 + 4 * *a3) + v34 - 1) >= v154)
          {
            v171 = a3;
          }
          else
          {
            v170 = (int *)a4;
            v171 = a3;
            if ((unint64_t)a3 >= a4)
              goto LABEL_269;
            do
            {
LABEL_267:
              v172 = *v171;
              if (*(_DWORD *)(a2 + 4 * v172) + v8 <= *(_DWORD *)(a2 + 4 * ((int)v172 + 1)))
                break;
              *v171++ = ~(_DWORD)v172;
            }
            while (v171 < v170);
LABEL_269:
            while (v171 < --v170)
            {
              v173 = *v170;
              if (*(_DWORD *)(a2 + 4 * v173) + v8 > *(_DWORD *)(a2 + 4 * ((int)v173 + 1)))
              {
                *v170 = *v171;
                *v171++ = ~(_DWORD)v173;
                if (v171 < v170)
                  goto LABEL_267;
              }
            }
            if (v171 > a3)
              *a3 = ~*a3;
            v180 = a4 - (_QWORD)v171;
            if (((a4 - (_QWORD)v171) & 0x3FC00) != 0)
              v5 = lg_table[(v180 >> 10)] + 8;
            else
              v5 = *(_DWORD *)((char *)lg_table + (v180 & 0x3FC));
          }
          ++v8;
          a3 = v171;
        }
      }
      goto LABEL_5;
    }
  }
}

uint64_t ss_swapmerge(uint64_t result, uint64_t a2, int *a3, int *a4, char *a5, unint64_t a6, int a7)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int *v13;
  int *v14;
  unint64_t v15;
  uint64_t v16;
  _OWORD *v17;
  _OWORD *v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  int *v22;
  int *v23;
  unsigned int v24;
  int v25;
  int *v26;
  unsigned int v27;
  int *v28;
  int *v29;
  int v30;
  unsigned int v31;
  int *v32;
  int v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  unint64_t v40;
  unint64_t v41;
  int v42;
  _BOOL4 v43;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  unint64_t v49;
  unint64_t v50;
  int v51;
  int v52;
  int *v53;
  int *v54;
  int v55;
  int v56;
  int v57;
  int *v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  int *v62;
  int *v63;
  int v64;
  int v65;
  int v66;
  int *v67;
  int v68;
  int *v69;
  int *v70;
  int v71;
  int v72;
  int v73;
  unsigned int v74;
  uint64_t v75;
  int v76;
  int *v77;
  int *v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int *v83;
  char v84;
  int *v85;
  uint64_t v86;
  int v87;
  char v88;
  _OWORD *v89;
  unint64_t v90;
  uint64_t v91;
  unsigned int v92;
  signed int v93;
  uint64_t v94;
  uint64_t v95;
  int *v96;
  int *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unsigned __int8 *v102;
  unsigned __int8 *v103;
  unint64_t v104;
  unint64_t v105;
  int v106;
  _BOOL4 v107;
  uint64_t v109;
  uint64_t v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  int *v117;
  int *v118;
  unsigned int v119;
  int v120;
  char *v121;
  uint64_t v122;
  int v123;
  int64_t v124;
  uint64_t v125;
  uint64_t v126;
  int *v127;
  int *v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  uint64_t v132;
  int v133;
  int64_t v134;
  uint64_t v135;
  int *v136;
  int *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unsigned __int8 *v141;
  unsigned __int8 *v142;
  unint64_t v143;
  unint64_t v144;
  _BOOL4 v145;
  _BOOL4 v146;
  uint64_t v148;
  uint64_t v149;
  int v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  uint64_t v155;
  int *v156;
  int *v157;
  unsigned int v158;
  int v159;
  int *v160;
  int v161;
  int *v162;
  int *v163;
  uint64_t v164;
  int *v165;
  uint64_t v166;
  int *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  unsigned __int8 *v171;
  unsigned __int8 *v172;
  unint64_t v173;
  unint64_t v174;
  int v175;
  _BOOL4 v176;
  uint64_t v178;
  uint64_t v179;
  int v180;
  int v181;
  unint64_t v182;
  unint64_t v183;
  int v184;
  int *v185;
  char *v186;
  int v187;
  int v188;
  int *v189;
  int v190;
  int *v191;
  int v192;
  uint64_t v193;
  int v194;
  int *v195;
  int *v196;
  uint64_t v197;
  int *v198;
  int *v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  unsigned __int8 *v203;
  unsigned __int8 *v204;
  unint64_t v205;
  unint64_t v206;
  _BOOL4 v207;
  _BOOL4 v208;
  uint64_t v210;
  uint64_t v211;
  int v212;
  unint64_t v213;
  unint64_t v214;
  uint64_t v215;
  int *v216;
  int *v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  unsigned __int8 *v221;
  unsigned __int8 *v222;
  unint64_t v223;
  unint64_t v224;
  _BOOL4 v225;
  _BOOL4 v226;
  uint64_t v228;
  uint64_t v229;
  int v230;
  unint64_t v231;
  unint64_t v232;
  int *v233;
  int v234;
  int *v235;
  int v236;
  uint64_t v237;
  unint64_t v238;
  uint64_t v239;
  __int128 *v240;
  __int128 *v241;
  __int128 v242;
  __int128 v243;
  __int128 v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  __int128 *v248;
  __int128 *v249;
  __int128 v250;
  __int128 v251;
  __int128 v252;
  int v253;
  uint64_t v254;
  int *v255;
  int *v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  unsigned __int8 *v260;
  unsigned __int8 *v261;
  unint64_t v262;
  unint64_t v263;
  _BOOL4 v264;
  _BOOL4 v265;
  uint64_t v267;
  uint64_t v268;
  int v269;
  unint64_t v270;
  unint64_t v271;
  uint64_t v272;
  int *v273;
  int *v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  unsigned __int8 *v278;
  unsigned __int8 *v279;
  unint64_t v280;
  unint64_t v281;
  _BOOL4 v282;
  _BOOL4 v283;
  uint64_t v285;
  uint64_t v286;
  int v287;
  unint64_t v288;
  unint64_t v289;
  int v290;
  uint64_t v291;
  int *v292;
  int *v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  unsigned __int8 *v297;
  unsigned __int8 *v298;
  unint64_t v299;
  unint64_t v300;
  _BOOL4 v301;
  _BOOL4 v302;
  uint64_t v304;
  uint64_t v305;
  int v306;
  unint64_t v307;
  unint64_t v308;
  int *v309;
  int *v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  unint64_t v314;
  unint64_t v315;
  _BOOL4 v316;
  uint64_t v318;
  unint64_t v319;
  unint64_t v320;
  _OWORD v321[64];
  uint64_t v322;

  LODWORD(v7) = 0;
  LOBYTE(v8) = 0;
  v322 = *MEMORY[0x1E0C80C00];
  v9 = a7;
  v10 = a6 - 4;
  v11 = result + 2;
  v12 = a6 + 4;
  v13 = (int *)(a5 + 4);
  v14 = a4;
  v15 = a5 - (char *)a4;
  v16 = (a5 - (char *)a4) >> 2;
  if (v16 > v9)
  {
    while (1)
    {
LABEL_65:
      v90 = (char *)v14 - (char *)a3;
      v91 = v14 - a3;
      if (v91 <= v9)
      {
        if (a3 >= v14)
          goto LABEL_271;
        v153 = v90 >> 2;
        if ((int)(v90 >> 2) >= 1)
        {
          v154 = (v90 >> 2);
          if (v154 < 8
            || (v155 = (v90 + 0x3FFFFFFFCLL) & 0x3FFFFFFFCLL, (unint64_t)a3 + v155 + 4 > a6)
            && (unint64_t)a3 < v12 + v155)
          {
            v156 = a3;
            v157 = (int *)a6;
            goto LABEL_133;
          }
          v245 = (v90 >> 2) & 7;
          v246 = v154 - v245;
          LODWORD(v153) = v153 - (v154 - v245);
          v247 = v154 - v245;
          v156 = &a3[v247];
          v157 = (int *)(a6 + v247 * 4);
          v248 = (__int128 *)(a3 + 4);
          v249 = (__int128 *)(a6 + 16);
          do
          {
            v250 = *(v249 - 1);
            v251 = *v249;
            v252 = *v248;
            *(v249 - 1) = *(v248 - 1);
            *v249 = v252;
            *(v248 - 1) = v250;
            *v248 = v251;
            v249 += 2;
            v248 += 2;
            v246 -= 8;
          }
          while (v246);
          if (v245)
          {
LABEL_133:
            v158 = v153 + 1;
            do
            {
              v159 = *v157;
              *v157++ = *v156;
              *v156++ = v159;
              --v158;
            }
            while (v158 > 1);
          }
        }
        v160 = (int *)(v10 + 4 * v91);
        v161 = *a3;
        v162 = a3;
        v163 = (int *)a6;
        while (1)
        {
          v164 = *v163;
          v165 = (int *)(a2 + 4 * v164);
          v166 = *v14;
          v167 = (int *)(a2 + 4 * v166);
          v168 = *v165;
          v170 = *v167;
          v169 = v167[1];
          v171 = (unsigned __int8 *)(v11 + v168);
          v172 = (unsigned __int8 *)(v11 + v170);
          v173 = v11 + v165[1];
          v174 = v11 + v169;
          v175 = v11 + v170 < (unint64_t)(v11 + v169);
          v176 = v11 + v168 < v173;
          if (v11 + v168 < v173 && (unint64_t)v172 < v174)
          {
            v178 = result;
            do
            {
              v179 = v178 + v170;
              v180 = *(unsigned __int8 *)(v178 + v168 + 2);
              v181 = *(unsigned __int8 *)(v178 + v170 + 2);
              if (v180 != v181)
                goto LABEL_148;
              v182 = v178 + v168 + 3;
              v183 = v179 + 3;
              v175 = v179 + 3 < v174;
              ++v178;
              v176 = v182 < v173;
            }
            while (v182 < v173 && v183 < v174);
            v172 = (unsigned __int8 *)(v178 + v170 + 2);
            v171 = (unsigned __int8 *)(v178 + v168 + 2);
          }
          if (v176)
          {
            if (!v175)
              goto LABEL_150;
            v180 = *v171;
            v181 = *v172;
LABEL_148:
            v184 = v180 - v181;
            if (v184 < 0)
              goto LABEL_155;
          }
          else
          {
            v184 = v175 << 31 >> 31;
            if (v184 < 0)
            {
              do
              {
LABEL_155:
                *v162 = v164;
                if (v160 <= v163)
                  goto LABEL_270;
                v188 = v162[1];
                ++v162;
                v189 = v163 + 1;
                LODWORD(v164) = v163[1];
                *v163++ = v188;
              }
              while ((v164 & 0x80000000) != 0);
              v163 = v189;
              continue;
            }
          }
          if (v184)
          {
LABEL_150:
            v185 = v162 + 1;
            v186 = (char *)(v14 + 1);
            do
            {
              *(v185 - 1) = v166;
              *((_DWORD *)v186 - 1) = *v185;
              if (v186 >= a5)
              {
                if (v163 >= v160)
                  goto LABEL_268;
                v235 = v185;
                do
                {
                  v236 = v235[1];
                  ++v235;
                  *v185 = *v163;
                  *v163++ = v236;
                  v185 = v235;
                }
                while (v163 < v160);
                goto LABEL_269;
              }
              v187 = *(_DWORD *)v186;
              v186 += 4;
              LODWORD(v166) = v187;
              ++v185;
            }
            while (v187 < 0);
            v162 = v185 - 1;
            v14 = (int *)(v186 - 4);
            continue;
          }
          *v14 = ~(_DWORD)v166;
          v190 = *v163;
          v191 = v163;
          do
          {
            *v162 = v190;
            if (v160 <= v191)
              goto LABEL_270;
            v192 = v162[1];
            ++v162;
            v163 = v191 + 1;
            v190 = v191[1];
            *v191++ = v192;
          }
          while (v190 < 0);
          v193 = 0;
          v194 = *v14;
          do
          {
            v162[v193] = v194;
            v14[v193] = v162[v193 + 1];
            v196 = &v14[v193 + 1];
            if (v196 >= (int *)a5)
            {
              v195 = &v162[v193];
              v185 = &v162[v193 + 1];
              if (v163 < v160)
              {
                v235 = v195 + 1;
                do
                {
                  v290 = v235[1];
                  ++v235;
                  *v185 = *v163;
                  *v163++ = v290;
                  v185 = v235;
                }
                while (v163 < v160);
                goto LABEL_269;
              }
LABEL_268:
              v235 = v185;
LABEL_269:
              *v235 = *v163;
              v160 = v163;
LABEL_270:
              *v160 = v161;
LABEL_271:
              if ((v8 & 1) != 0)
              {
                LODWORD(v291) = *a3;
                goto LABEL_287;
              }
              if ((v8 & 2) != 0)
              {
                v291 = *a3;
                v292 = (int *)(a2 + 4 * (*(a3 - 1) ^ (*(a3 - 1) >> 31)));
                v293 = (int *)(a2 + 4 * v291);
                v294 = *v292;
                v296 = *v293;
                v295 = v293[1];
                v297 = (unsigned __int8 *)(v11 + v294);
                v298 = (unsigned __int8 *)(v11 + v296);
                v299 = v11 + v292[1];
                v300 = v11 + v295;
                v301 = v11 + v296 < (unint64_t)(v11 + v295);
                v302 = v11 + v294 < v299;
                if (v11 + v294 >= v299 || (unint64_t)v298 >= v300)
                {
LABEL_282:
                  if (v302)
                  {
                    if (v301 && *v297 == *v298)
                      goto LABEL_287;
                  }
                  else if (!v301)
                  {
                    goto LABEL_287;
                  }
                }
                else
                {
                  v304 = result;
                  while (1)
                  {
                    v305 = v304 + v296;
                    v306 = *(unsigned __int8 *)(v304 + v294 + 2);
                    if (v306 != *(unsigned __int8 *)(v304 + v296 + 2))
                      break;
                    v307 = v304 + v294 + 3;
                    v308 = v305 + 3;
                    v301 = v308 < v300;
                    ++v304;
                    v302 = v307 < v299;
                    if (v307 >= v299 || v308 >= v300)
                    {
                      v298 = (unsigned __int8 *)(v304 + v296 + 2);
                      v297 = (unsigned __int8 *)(v304 + v294 + 2);
                      goto LABEL_282;
                    }
                  }
                  if (v306 == *(unsigned __int8 *)(v305 + 2))
LABEL_287:
                    *a3 = ~(_DWORD)v291;
                }
              }
              if ((v8 & 4) != 0)
              {
                v272 = *(int *)a5;
                v309 = (int *)(a2 + 4 * (*((_DWORD *)a5 - 1) ^ (*((int *)a5 - 1) >> 31)));
                v310 = (int *)(a2 + 4 * v272);
                v311 = *v309;
                v313 = *v310;
                v312 = v310[1];
                v278 = (unsigned __int8 *)(v11 + v311);
                v279 = (unsigned __int8 *)(v11 + v313);
                v314 = v11 + v309[1];
                v315 = v11 + v312;
                v282 = v11 + v313 < (unint64_t)(v11 + v312);
                v316 = v11 + v311 < v314;
                if (v11 + v311 < v314 && (unint64_t)v279 < v315)
                {
                  v318 = result;
                  do
                  {
                    v286 = v318 + v313;
                    v287 = *(unsigned __int8 *)(v318 + v311 + 2);
                    if (v287 != *(unsigned __int8 *)(v318 + v313 + 2))
                      goto LABEL_301;
                    v319 = v318 + v311 + 3;
                    v320 = v286 + 3;
                    v282 = v320 < v315;
                    ++v318;
                    v316 = v319 < v314;
                  }
                  while (v319 < v314 && v320 < v315);
                  v279 = (unsigned __int8 *)(v318 + v313 + 2);
                  v278 = (unsigned __int8 *)(v318 + v311 + 2);
                }
                if (v316)
                {
LABEL_257:
                  if (v282 && *v278 == *v279)
                    goto LABEL_302;
                }
                else
                {
LABEL_299:
                  if (!v282)
                    goto LABEL_302;
                }
              }
              goto LABEL_6;
            }
            v194 = *v196;
            ++v193;
          }
          while (*v196 < 0);
          v162 = (int *)((char *)v162 + v193 * 4);
          v14 = (int *)((char *)v14 + v193 * 4);
        }
      }
      if (v91 < v16)
        v16 = v14 - a3;
      if ((int)v16 < 1)
      {
LABEL_114:
        v135 = *v14;
        v136 = (int *)(a2 + 4 * (*(v14 - 1) ^ (*(v14 - 1) >> 31)));
        v137 = (int *)(a2 + 4 * v135);
        v138 = *v136;
        v140 = *v137;
        v139 = v137[1];
        v141 = (unsigned __int8 *)(v11 + v138);
        v142 = (unsigned __int8 *)(v11 + v140);
        v143 = v11 + v136[1];
        v144 = v11 + v139;
        v145 = v11 + v140 < (unint64_t)(v11 + v139);
        v146 = v11 + v138 < v143;
        if (v11 + v138 >= v143 || (unint64_t)v142 >= v144)
        {
LABEL_123:
          if (v146)
          {
            if (v145 && *v141 == *v142)
              goto LABEL_182;
          }
          else if (!v145)
          {
            goto LABEL_182;
          }
        }
        else
        {
          v148 = result;
          while (1)
          {
            v149 = v148 + v140;
            v150 = *(unsigned __int8 *)(v148 + v138 + 2);
            if (v150 != *(unsigned __int8 *)(v148 + v140 + 2))
              break;
            v151 = v148 + v138 + 3;
            v152 = v149 + 3;
            v145 = v152 < v144;
            ++v148;
            v146 = v151 < v143;
            if (v151 >= v143 || v152 >= v144)
            {
              v142 = (unsigned __int8 *)(v148 + v140 + 2);
              v141 = (unsigned __int8 *)(v148 + v138 + 2);
              goto LABEL_123;
            }
          }
          if (v150 == *(unsigned __int8 *)(v149 + 2))
          {
LABEL_182:
            *v14 = ~(_DWORD)v135;
            if ((v8 & 1) != 0)
            {
LABEL_183:
              LODWORD(v197) = *a3;
              goto LABEL_184;
            }
LABEL_167:
            if ((v8 & 2) != 0)
            {
              v197 = *a3;
              v198 = (int *)(a2 + 4 * (*(a3 - 1) ^ (*(a3 - 1) >> 31)));
              v199 = (int *)(a2 + 4 * v197);
              v200 = *v198;
              v202 = *v199;
              v201 = v199[1];
              v203 = (unsigned __int8 *)(v11 + v200);
              v204 = (unsigned __int8 *)(v11 + v202);
              v205 = v11 + v198[1];
              v206 = v11 + v201;
              v207 = v11 + v202 < (unint64_t)(v11 + v201);
              v208 = v11 + v200 < v205;
              if (v11 + v200 >= v205 || (unint64_t)v204 >= v206)
              {
LABEL_177:
                if (v208)
                {
                  if (v207 && *v203 == *v204)
                    goto LABEL_184;
                }
                else if (!v207)
                {
                  goto LABEL_184;
                }
              }
              else
              {
                v210 = result;
                while (1)
                {
                  v211 = v210 + v202;
                  v212 = *(unsigned __int8 *)(v210 + v200 + 2);
                  if (v212 != *(unsigned __int8 *)(v210 + v202 + 2))
                    break;
                  v213 = v210 + v200 + 3;
                  v214 = v211 + 3;
                  v207 = v214 < v206;
                  ++v210;
                  v208 = v213 < v205;
                  if (v213 >= v205 || v214 >= v206)
                  {
                    v204 = (unsigned __int8 *)(v210 + v202 + 2);
                    v203 = (unsigned __int8 *)(v210 + v200 + 2);
                    goto LABEL_177;
                  }
                }
                if (v212 == *(unsigned __int8 *)(v211 + 2))
LABEL_184:
                  *a3 = ~(_DWORD)v197;
              }
            }
            if ((v8 & 4) == 0)
              goto LABEL_6;
            v215 = *(int *)a5;
            v216 = (int *)(a2 + 4 * (*((_DWORD *)a5 - 1) ^ (*((int *)a5 - 1) >> 31)));
            v217 = (int *)(a2 + 4 * v215);
            v218 = *v216;
            v220 = *v217;
            v219 = v217[1];
            v221 = (unsigned __int8 *)(v11 + v218);
            v222 = (unsigned __int8 *)(v11 + v220);
            v223 = v11 + v216[1];
            v224 = v11 + v219;
            v225 = v11 + v220 < (unint64_t)(v11 + v219);
            v226 = v11 + v218 < v223;
            if (v11 + v218 >= v223 || (unint64_t)v222 >= v224)
            {
LABEL_195:
              if (v226)
              {
                if (!v225 || *v221 != *v222)
                  goto LABEL_6;
              }
              else if (v225)
              {
                goto LABEL_6;
              }
            }
            else
            {
              v228 = result;
              while (1)
              {
                v229 = v228 + v220;
                v230 = *(unsigned __int8 *)(v228 + v218 + 2);
                if (v230 != *(unsigned __int8 *)(v228 + v220 + 2))
                  break;
                v231 = v228 + v218 + 3;
                v232 = v229 + 3;
                v225 = v232 < v224;
                ++v228;
                v226 = v231 < v223;
                if (v231 >= v223 || v232 >= v224)
                {
                  v222 = (unsigned __int8 *)(v228 + v220 + 2);
                  v221 = (unsigned __int8 *)(v228 + v218 + 2);
                  goto LABEL_195;
                }
              }
              if (v230 != *(unsigned __int8 *)(v229 + 2))
                goto LABEL_6;
            }
            *(_DWORD *)a5 = ~(_DWORD)v215;
            goto LABEL_6;
          }
        }
        if ((v8 & 1) != 0)
          goto LABEL_183;
        goto LABEL_167;
      }
      v92 = 0;
      do
      {
        v93 = v16 >> 1;
        v94 = 4 * (int)v92;
        v95 = 4 * (v16 >> 1);
        v96 = (int *)(a2
                    + 4
                    * (v14[(unint64_t)v94 / 4 + (unint64_t)v95 / 4] ^ (v14[(unint64_t)v94 / 4 + (unint64_t)v95 / 4] >> 31)));
        v97 = (int *)(a2
                    + 4
                    * (v14[v94 / 0xFFFFFFFFFFFFFFFCLL - 1 + v95 / 0xFFFFFFFFFFFFFFFCLL] ^ (v14[v94 / 0xFFFFFFFFFFFFFFFCLL - 1 + v95 / 0xFFFFFFFFFFFFFFFCLL] >> 31)));
        v99 = *v96;
        v98 = v96[1];
        v101 = *v97;
        v100 = v97[1];
        v102 = (unsigned __int8 *)(v11 + v99);
        v103 = (unsigned __int8 *)(v11 + v101);
        v104 = v11 + v98;
        v105 = v11 + v100;
        v106 = v11 + v101 < (unint64_t)(v11 + v100);
        v107 = v11 + v99 < v104;
        if (v11 + v99 >= v104 || (unint64_t)v103 >= v105)
        {
LABEL_81:
          if (v107)
          {
            if (v106 && *v102 - *v103 < 0)
              goto LABEL_70;
          }
          else if (v106 << 31 >> 31 < 0)
          {
            goto LABEL_70;
          }
        }
        else
        {
          v109 = result;
          while (1)
          {
            v110 = v109 + v101;
            v111 = *(unsigned __int8 *)(v109 + v99 + 2);
            if (v111 != *(unsigned __int8 *)(v109 + v101 + 2))
              break;
            v112 = v109 + v99 + 3;
            v113 = v110 + 3;
            v106 = v113 < v105;
            ++v109;
            v107 = v112 < v104;
            if (v112 >= v104 || v113 >= v105)
            {
              v103 = (unsigned __int8 *)(v109 + v101 + 2);
              v102 = (unsigned __int8 *)(v109 + v99 + 2);
              goto LABEL_81;
            }
          }
          if (v111 - *(unsigned __int8 *)(v110 + 2) < 0)
          {
LABEL_70:
            v92 += v93 + 1;
            v93 += 1 + (v16 | 0xFFFFFFFE);
          }
        }
        LODWORD(v16) = v93;
      }
      while (v93 > 0);
      v114 = v92 - 1;
      if ((int)v92 < 1)
        goto LABEL_114;
      v115 = v92;
      v116 = (unint64_t)&v14[-v92];
      if (v92 < 8 || v116 < (unint64_t)&v14[v114 + 1] && v14 < &v14[v114 - v92 + 1])
      {
        v117 = v14;
        v118 = &v14[-v92];
        goto LABEL_94;
      }
      v92 -= v92 & 0xFFFFFFF8;
      v125 = v115 & 0xFFFFFFF8;
      v117 = &v14[v125];
      v118 = (int *)(v116 + v125 * 4);
      v126 = v115 & 0xFFFFFFF8;
      v127 = v14;
      do
      {
        v128 = &v127[-v115];
        v129 = *(_OWORD *)v128;
        v130 = *((_OWORD *)v128 + 1);
        v131 = *((_OWORD *)v127 + 1);
        *(_OWORD *)v128 = *(_OWORD *)v127;
        *((_OWORD *)v128 + 1) = v131;
        *(_OWORD *)v127 = v129;
        *((_OWORD *)v127 + 1) = v130;
        v127 += 8;
        v126 -= 8;
      }
      while (v126);
      if ((v115 & 0x7FFFFFF8) != v115)
      {
LABEL_94:
        v119 = v92 + 1;
        do
        {
          v120 = *v118;
          *v118++ = *v117;
          *v117++ = v120;
          --v119;
        }
        while (v119 > 1);
      }
      v121 = (char *)&v14[v115];
      if (v121 >= a5)
      {
LABEL_60:
        v84 = 0;
        v85 = v14;
        v86 = (uint64_t)v14;
        v87 = v8 & 3;
        if ((uint64_t)v90 <= (uint64_t)v15)
          goto LABEL_3;
        goto LABEL_61;
      }
      if ((*(_DWORD *)v121 & 0x80000000) != 0)
      {
        *(_DWORD *)v121 = ~*(_DWORD *)v121;
        if ((unint64_t)a3 >= v116)
        {
          v84 = 1;
          v85 = v14;
          v86 = (uint64_t)v14;
          v87 = v8 & 3;
          if ((uint64_t)v90 <= (uint64_t)v15)
            goto LABEL_3;
          goto LABEL_61;
        }
        v132 = 0;
        do
          v133 = v14[--v132];
        while (v133 < 0);
        v134 = v90 + v132 * 4;
        v85 = &v14[v132];
        v84 = 5;
        v86 = (uint64_t)v14;
        v87 = v8 & 3;
        if (v134 > (uint64_t)v15)
          goto LABEL_61;
LABEL_3:
        v17 = &v321[2 * (int)v7];
        *(_QWORD *)v17 = v86;
        *((_QWORD *)v17 + 1) = v121;
        *((_QWORD *)v17 + 2) = a5;
        LODWORD(v7) = v7 + 1;
        *((_DWORD *)v17 + 6) = v8 & 4 | v84 & 3;
        LOBYTE(v8) = v84 & 4 | v87;
        a5 = (char *)v85;
        v13 = v85 + 1;
        v14 = (int *)v116;
        v15 = (unint64_t)v85 - v116;
        v16 = (uint64_t)((uint64_t)v85 - v116) >> 2;
        if (v16 <= v9)
          break;
      }
      else
      {
        if ((unint64_t)a3 >= v116)
          goto LABEL_60;
        v122 = 0;
        do
          v123 = v14[v122++];
        while (v123 < 0);
        v124 = (char *)v13 - (char *)v14 - v122 * 4;
        v86 = (uint64_t)&v14[v122 - 1];
        v84 = 2;
        v85 = v14;
        v87 = v8 & 3;
        if ((uint64_t)v90 <= v124)
          goto LABEL_3;
LABEL_61:
        if (((v86 == (_QWORD)v14) & ((v84 & 2) >> 1)) != 0)
          v88 = v84 ^ 6;
        else
          v88 = v84;
        v89 = &v321[2 * (int)v7];
        *(_QWORD *)v89 = a3;
        *((_QWORD *)v89 + 1) = v116;
        *((_QWORD *)v89 + 2) = v85;
        LODWORD(v7) = v7 + 1;
        *((_DWORD *)v89 + 6) = v88 & 4 | v87;
        LOBYTE(v8) = v8 & 4 | v88 & 3;
        v14 = (int *)v121;
        a3 = (int *)v86;
        v15 = a5 - v121;
        v16 = (a5 - v121) >> 2;
        if (v16 <= v9)
          break;
      }
    }
  }
  while (2)
  {
    if (v14 >= (int *)a5 || a3 >= v14)
      goto LABEL_229;
    v19 = v15 >> 2;
    if ((int)(v15 >> 2) < 1)
      goto LABEL_17;
    v20 = (v15 >> 2);
    if (v20 >= 8
      && ((v21 = (v15 + 0x3FFFFFFFCLL) & 0x3FFFFFFFCLL, (unint64_t)v14 + v21 + 4 <= a6)
       || (unint64_t)v14 >= v12 + v21))
    {
      v237 = (v15 >> 2) & 7;
      v238 = v20 - v237;
      LODWORD(v19) = v19 - (v20 - v237);
      v239 = v20 - v237;
      v22 = &v14[v239];
      v23 = (int *)(a6 + v239 * 4);
      v240 = (__int128 *)(v14 + 4);
      v241 = (__int128 *)(a6 + 16);
      do
      {
        v242 = *(v241 - 1);
        v243 = *v241;
        v244 = *v240;
        *(v241 - 1) = *(v240 - 1);
        *v241 = v244;
        *(v240 - 1) = v242;
        *v240 = v243;
        v241 += 2;
        v240 += 2;
        v238 -= 8;
      }
      while (v238);
      if (!v237)
        goto LABEL_17;
    }
    else
    {
      v22 = v14;
      v23 = (int *)a6;
    }
    v24 = v19 + 1;
    do
    {
      v25 = *v23;
      *v23++ = *v22;
      *v22++ = v25;
      --v24;
    }
    while (v24 > 1);
LABEL_17:
    v26 = (int *)(v10 + 4 * v16);
    v27 = *v26 >> 31;
    v28 = (int *)(a2 + 4 * (*v26 ^ (*v26 >> 31)));
    v30 = *(v14 - 1);
    v29 = v14 - 1;
    v31 = v30 ^ (v30 >> 31);
    if (v30 < 0)
      v27 = (*v26 >> 31) | 2;
    v32 = (int *)(a2 + 4 * v31);
    v34 = (int *)(a5 - 4);
    v33 = *((_DWORD *)a5 - 1);
    while (1)
    {
      while (1)
      {
        v35 = *v28;
        v37 = *v32;
        v36 = v32[1];
        v38 = (unsigned __int8 *)(v11 + v35);
        v39 = (unsigned __int8 *)(v11 + v37);
        v40 = v11 + v28[1];
        v41 = v11 + v36;
        v42 = v11 + v37 < (unint64_t)(v11 + v36);
        v43 = v11 + v35 < v40;
        if (v11 + v35 < v40 && (unint64_t)v39 < v41)
        {
          v45 = result;
          while (1)
          {
            v46 = v45 + v37;
            v47 = *(unsigned __int8 *)(v45 + v35 + 2);
            v48 = *(unsigned __int8 *)(v45 + v37 + 2);
            if (v47 != v48)
              goto LABEL_32;
            v49 = v45 + v35 + 3;
            v50 = v46 + 3;
            v42 = v46 + 3 < v41;
            ++v45;
            v43 = v49 < v40;
            if (v49 >= v40 || v50 >= v41)
            {
              v39 = (unsigned __int8 *)(v45 + v37 + 2);
              v38 = (unsigned __int8 *)(v45 + v35 + 2);
              break;
            }
          }
        }
        if (!v43)
          break;
        if (!v42)
          goto LABEL_52;
        v47 = *v38;
        v48 = *v39;
LABEL_32:
        v51 = v47 - v48;
        if (v51 >= 1)
        {
LABEL_52:
          v76 = *v26;
          if ((v27 & 1) != 0)
          {
            do
            {
              v77 = v26;
              v78 = v34;
              v80 = *--v34;
              v79 = v80;
              *v78 = v76;
              v81 = *--v26;
              v76 = v81;
              *v77 = v79;
            }
            while (v81 < 0);
            v27 ^= 1u;
          }
          *v34-- = v76;
          if ((unint64_t)v26 <= a6)
          {
LABEL_221:
            v26 = (int *)a6;
            goto LABEL_228;
          }
          *v26 = *v34;
          v82 = *--v26;
          v28 = (int *)(a2 + 4 * v82);
          v83 = (int *)(a2 + 4 * ~v82);
          if (v82 < 0)
          {
            v28 = v83;
            v27 |= 1u;
          }
        }
        else
        {
          if (v51 < 0)
            goto LABEL_34;
LABEL_42:
          v61 = *v26;
          if ((v27 & 1) != 0)
          {
            do
            {
              v62 = v26;
              v63 = v34;
              v65 = *--v34;
              v64 = v65;
              *v63 = v61;
              v66 = *--v26;
              v61 = v66;
              *v62 = v64;
            }
            while (v66 < 0);
            v27 ^= 1u;
          }
          *v34 = ~v61;
          if ((unint64_t)v26 <= a6)
            goto LABEL_221;
          v67 = v34 - 1;
          *v26-- = *(v34 - 1);
          v68 = *v29;
          if ((v27 & 2) != 0)
          {
            do
            {
              v69 = v29;
              v70 = v67;
              v72 = *--v67;
              v71 = v72;
              *v70 = v68;
              v73 = *--v29;
              v68 = v73;
              *v69 = v71;
            }
            while (v73 < 0);
            v27 ^= 2u;
          }
          v34 = v67 - 1;
          v74 = *(v67 - 1);
          *v67 = v68;
          *v29-- = v74;
          if (v29 < a3)
          {
            if ((unint64_t)v26 > a6)
            {
              v233 = v67 - 1;
              do
              {
                v253 = *--v233;
                *v34 = *v26;
                *v26-- = v253;
                v34 = v233;
              }
              while ((unint64_t)v26 > a6);
              goto LABEL_227;
            }
LABEL_226:
            v233 = v34;
            goto LABEL_227;
          }
          v27 |= *v26 >> 31;
          v28 = (int *)(a2 + 4 * (*v26 ^ (*v26 >> 31)));
          v75 = *v29;
          if ((v75 & 0x80000000) != 0)
          {
            v32 = (int *)(a2 + 4 * ~(_DWORD)v75);
            v27 |= 2u;
          }
          else
          {
            v32 = (int *)(a2 + 4 * v75);
          }
        }
      }
      if (((v42 << 31 >> 31) & 0x80000000) == 0)
        goto LABEL_42;
LABEL_34:
      v52 = *v29;
      if ((v27 & 2) != 0)
      {
        do
        {
          v53 = v29;
          v54 = v34;
          v56 = *--v34;
          v55 = v56;
          *v54 = v52;
          v57 = *--v29;
          v52 = v57;
          *v53 = v55;
        }
        while (v57 < 0);
        v27 ^= 2u;
      }
      v58 = v34;
      v59 = *--v34;
      *v58 = v52;
      *v29-- = v59;
      if (v29 < a3)
        break;
      v60 = *v29;
      if (*v29 < 0)
      {
        v60 = ~v60;
        v27 |= 2u;
      }
      v32 = (int *)(a2 + 4 * v60);
    }
    if ((unint64_t)v26 <= a6)
      goto LABEL_226;
    v233 = v34;
    do
    {
      v234 = *--v233;
      *v34 = *v26;
      *v26-- = v234;
      v34 = v233;
    }
    while ((unint64_t)v26 > a6);
LABEL_227:
    *v233 = *v26;
LABEL_228:
    *v26 = v33;
LABEL_229:
    if ((v8 & 1) != 0)
    {
      LODWORD(v254) = *a3;
      goto LABEL_245;
    }
    if ((v8 & 2) != 0)
    {
      v254 = *a3;
      v255 = (int *)(a2 + 4 * (*(a3 - 1) ^ (*(a3 - 1) >> 31)));
      v256 = (int *)(a2 + 4 * v254);
      v257 = *v255;
      v259 = *v256;
      v258 = v256[1];
      v260 = (unsigned __int8 *)(v11 + v257);
      v261 = (unsigned __int8 *)(v11 + v259);
      v262 = v11 + v255[1];
      v263 = v11 + v258;
      v264 = v11 + v259 < (unint64_t)(v11 + v258);
      v265 = v11 + v257 < v262;
      if (v11 + v257 >= v262 || (unint64_t)v261 >= v263)
      {
LABEL_240:
        if (v265)
        {
          if (v264 && *v260 == *v261)
            goto LABEL_245;
        }
        else if (!v264)
        {
          goto LABEL_245;
        }
      }
      else
      {
        v267 = result;
        while (1)
        {
          v268 = v267 + v259;
          v269 = *(unsigned __int8 *)(v267 + v257 + 2);
          if (v269 != *(unsigned __int8 *)(v267 + v259 + 2))
            break;
          v270 = v267 + v257 + 3;
          v271 = v268 + 3;
          v264 = v271 < v263;
          ++v267;
          v265 = v270 < v262;
          if (v270 >= v262 || v271 >= v263)
          {
            v261 = (unsigned __int8 *)(v267 + v259 + 2);
            v260 = (unsigned __int8 *)(v267 + v257 + 2);
            goto LABEL_240;
          }
        }
        if (v269 == *(unsigned __int8 *)(v268 + 2))
LABEL_245:
          *a3 = ~(_DWORD)v254;
      }
    }
    if ((v8 & 4) == 0)
      goto LABEL_6;
    v272 = *(int *)a5;
    v273 = (int *)(a2 + 4 * (*((_DWORD *)a5 - 1) ^ (*((int *)a5 - 1) >> 31)));
    v274 = (int *)(a2 + 4 * v272);
    v275 = *v273;
    v277 = *v274;
    v276 = v274[1];
    v278 = (unsigned __int8 *)(v11 + v275);
    v279 = (unsigned __int8 *)(v11 + v277);
    v280 = v11 + v273[1];
    v281 = v11 + v276;
    v282 = v11 + v277 < (unint64_t)(v11 + v276);
    v283 = v11 + v275 < v280;
    if (v11 + v275 >= v280 || (unint64_t)v279 >= v281)
    {
LABEL_256:
      if (!v283)
        goto LABEL_299;
      goto LABEL_257;
    }
    v285 = result;
    while (1)
    {
      v286 = v285 + v277;
      v287 = *(unsigned __int8 *)(v285 + v275 + 2);
      if (v287 != *(unsigned __int8 *)(v285 + v277 + 2))
        break;
      v288 = v285 + v275 + 3;
      v289 = v286 + 3;
      v282 = v289 < v281;
      ++v285;
      v283 = v288 < v280;
      if (v288 >= v280 || v289 >= v281)
      {
        v279 = (unsigned __int8 *)(v285 + v277 + 2);
        v278 = (unsigned __int8 *)(v285 + v275 + 2);
        goto LABEL_256;
      }
    }
LABEL_301:
    if (v287 != *(unsigned __int8 *)(v286 + 2))
    {
LABEL_6:
      if (!(_DWORD)v7)
        return result;
LABEL_7:
      v7 = (int)v7 - 1;
      v18 = &v321[2 * v7];
      a3 = *(int **)v18;
      a5 = (char *)*((_QWORD *)v18 + 2);
      v8 = *((_DWORD *)v18 + 6);
      v13 = (int *)(a5 + 4);
      v14 = (int *)*((_QWORD *)v18 + 1);
      v15 = a5 - (char *)v14;
      v16 = (a5 - (char *)v14) >> 2;
      if (v16 > v9)
        goto LABEL_65;
      continue;
    }
    break;
  }
LABEL_302:
  *(_DWORD *)a5 = ~(_DWORD)v272;
  if ((_DWORD)v7)
    goto LABEL_7;
  return result;
}

uint64_t ZDICT_tryMerge(unsigned int *a1, unint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  int v14;
  unsigned int *v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  _QWORD *v24;
  unsigned int *v25;
  uint64_t v26;
  unsigned int *v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  unsigned int v31;
  _QWORD *v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int *v37;
  int v38;
  unsigned int *v39;
  unsigned int *v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int *v44;
  uint64_t v45;
  unsigned int *v47;

  v5 = *a1;
  if (v5 < 2)
    return 0;
  v6 = 0;
  v7 = 0;
  v8 = HIDWORD(a2);
  v9 = HIDWORD(a2) + a2;
  v10 = a4;
  v11 = 12 * a4 - 12;
  do
  {
    if (v11 != v6)
    {
      v12 = &a1[v6 / 4];
      v13 = a1[v6 / 4 + 3];
      v14 = v13 - a2;
      if (v13 > a2 && v13 <= v9)
      {
        v12[3] = a2;
        v16 = v12 + 3;
        v17 = v14 * a3 / HIDWORD(a2) + (HIDWORD(a2) >> 3) + v16[2];
        v16[1] += v14;
        v16[2] = v17;
        v18 = *(_QWORD *)v16;
        if ((v7 + 1) <= 1)
        {
          v22 = v7 + 1;
        }
        else
        {
          while (a1[3 * v7 + 2] < v17)
          {
            v19 = &a1[3 * v7];
            v20 = *(_QWORD *)v19;
            v16[2] = v19[2];
            *(_QWORD *)v16 = v20;
            v16 -= 3;
            v21 = v7 & 0xFFFFFFFE;
            LODWORD(v7) = v7 - 1;
            if (!v21)
            {
              v22 = 1;
              goto LABEL_33;
            }
          }
          v22 = (v7 + 1);
        }
LABEL_33:
        v37 = &a1[3 * v22];
        *(_QWORD *)v37 = v18;
        v37[2] = v17;
        return v22;
      }
    }
    ++v7;
    v6 += 12;
  }
  while (12 * v5 - 12 != v6);
  v23 = 0;
  v24 = (_QWORD *)(a5 + a2 + 1);
  v25 = a1 + 3;
  v26 = 1;
  while (1)
  {
    if (v26 == v10)
      goto LABEL_15;
    v27 = &a1[3 * v26];
    v28 = *v27;
    v30 = v27 + 1;
    v29 = v27[1];
    v31 = v27[1] + v28;
    if (v28 < a2 && v31 >= a2)
      break;
    v33 = (_QWORD *)(a5 + v28);
    if (*v33 == *v24)
    {
      v34 = 0;
      if ((_DWORD)v29)
      {
        while (*((unsigned __int8 *)v33 + v34) == *((unsigned __int8 *)v24 + v34))
        {
          if (v29 == ++v34)
            goto LABEL_25;
        }
      }
      if (v34 == v29)
      {
LABEL_25:
        v35 = HIDWORD(a2) - v29;
        if (HIDWORD(a2) - (int)v29 <= 1)
          v35 = 1;
        *v27 = a2;
        a1[3 * v26 + 2] += a3 * (unint64_t)v35 / v8;
        if ((v29 + 1) < HIDWORD(a2))
          LODWORD(v8) = v29 + 1;
        *v30 = v8;
        return v26;
      }
    }
LABEL_15:
    ++v26;
    ++v23;
    v25 += 3;
    if (v26 == v5)
      return 0;
  }
  v38 = v9 - v31;
  v39 = &a1[3 * v26];
  v41 = v39[2];
  v40 = v39 + 2;
  v42 = v41 + (HIDWORD(a2) >> 3);
  *v40 = v42;
  if (v38 >= 1)
  {
    *v30 = v38 + v29;
    v42 += v38 * a3 / HIDWORD(a2);
    *v40 = v42;
  }
  v43 = *(_QWORD *)v27;
  if (v26 >= 2)
  {
    while (a1[3 * v23 + 2] < v42)
    {
      v44 = &a1[3 * v23];
      v45 = *(_QWORD *)v44;
      v25[2] = v44[2];
      *(_QWORD *)v25 = v45;
      v25 -= 3;
      if (!(unint64_t)(v23-- & 0xFFFFFFFE))
      {
        v26 = 1;
        goto LABEL_41;
      }
    }
    v26 = (v23 + 1);
  }
LABEL_41:
  v47 = &a1[3 * v26];
  *(_QWORD *)v47 = v43;
  v47[2] = v42;
  return v26;
}

uint64_t ktxCheckHeader1_(int8x16_t *a1, uint64_t a2)
{
  uint64_t result;
  __int32 v6;
  unsigned int v7;
  __int32 v8;
  __int32 v9;
  unsigned __int32 v10;
  unsigned __int32 v11;
  int v12;
  __int16 v13;
  __int32 v14;
  char v15;

  if (a1->i64[0] != 0xBB31312058544BABLL || a1->i32[2] != 169478669)
    return 15;
  v6 = a1->i32[3];
  if (v6 != 67305985)
  {
    if (v6 != 16909060)
      return 1;
    _ktxSwapEndian32(a1 + 1, 0xCuLL);
    v7 = a1[1].u32[1];
    result = 1;
    if (v7 > 4 || ((1 << v7) & 0x16) == 0)
      return result;
  }
  *(_BYTE *)a2 = 0;
  v8 = a1[1].i32[0];
  v9 = a1[1].i32[2];
  if (v8 && v9)
  {
    if (v9 == a1[1].i32[3])
      return 1;
  }
  else
  {
    result = 1;
    if (v8 + v9)
      return result;
    *(_BYTE *)a2 = 1;
    if (v9 == a1[1].i32[3])
      return 1;
  }
  v10 = a1[2].u32[1];
  if (!v10)
    return 1;
  v12 = a1[2].i32[2];
  v11 = a1[2].u32[3];
  if (v11)
  {
    if (v12)
    {
      v12 = a1[3].i32[0];
      if (v12)
        return 16;
      v13 = 3;
      goto LABEL_26;
    }
    return 1;
  }
  if (v12)
  {
    *(_WORD *)(a2 + 2) = 2;
    v12 = 1;
    goto LABEL_27;
  }
  v13 = 1;
LABEL_26:
  *(_WORD *)(a2 + 2) = v13;
LABEL_27:
  v14 = a1[3].i32[1];
  if (v14 != 1 && (v14 != 6 || !v12))
    return 1;
  if (a1[3].i32[2])
  {
    v15 = 0;
  }
  else
  {
    v15 = 1;
    a1[3].i32[2] = 1;
  }
  *(_BYTE *)(a2 + 1) = v15;
  if (v10 <= a1[2].i32[2])
    v10 = a1[2].u32[2];
  if (v10 <= v11)
    v10 = v11;
  return v10 >> (a1[3].i8[8] - 1) == 0;
}

uint64_t ktxCheckHeader2_(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  int v8;
  unsigned int v9;

  if (*(_QWORD *)a1 != 0xBB30322058544BABLL || *(_DWORD *)(a1 + 8) != 169478669)
    return 15;
  v4 = *(_DWORD *)(a1 + 20);
  if (!v4)
    return 1;
  v6 = *(_DWORD *)(a1 + 24);
  v5 = *(_DWORD *)(a1 + 28);
  if (!v5)
  {
    if (v6)
    {
      *(_WORD *)(a2 + 2) = 2;
      v7 = 1;
      v8 = *(_DWORD *)(a1 + 36);
      if (v8 == 1)
        goto LABEL_19;
    }
    else
    {
      v7 = 0;
      *(_WORD *)(a2 + 2) = 1;
      v8 = *(_DWORD *)(a1 + 36);
      if (v8 == 1)
        goto LABEL_19;
    }
    goto LABEL_17;
  }
  if (!v6)
    return 1;
  v7 = *(_DWORD *)(a1 + 32);
  if (v7)
    return 16;
  *(_WORD *)(a2 + 2) = 3;
  v8 = *(_DWORD *)(a1 + 36);
  if (v8 != 1)
  {
LABEL_17:
    if (v8 != 6 || !v7)
      return 1;
  }
LABEL_19:
  v9 = *(_DWORD *)(a1 + 40);
  if (v9)
  {
    *(_BYTE *)(a2 + 1) = 0;
    if (v9 > 0x20)
      return 1;
  }
  else
  {
    LOBYTE(v9) = 1;
    *(_BYTE *)(a2 + 1) = 1;
    *(_DWORD *)(a1 + 40) = 1;
  }
  if (v4 <= v6)
    v4 = v6;
  if (v4 <= v5)
    v4 = v5;
  return v4 >> (v9 - 1) == 0;
}

_DWORD *createDFDUnpacked(int a1, int a2, int a3, unsigned int a4, int a5)
{
  int v9;
  int v10;
  _DWORD *v11;
  _DWORD *v12;
  uint64_t v13;
  _DWORD *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  _DWORD *v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  BOOL v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int *v56;
  int v57;
  int v58;

  v9 = a3 * a2;
  if (a5 == 8)
    v10 = 131329;
  else
    v10 = 65793;
  if (a1)
  {
    v11 = malloc_type_malloc(4 * (4 * v9 + 7), 0x100004052888210uLL);
    v12 = v11;
    *v11 = 4 * (4 * v9 + 7);
    v11[1] = 0;
    v11[2] = (v9 << 20) + 1572866;
    v11[3] = v10;
    v11[4] = 0;
    v11[5] = v9;
    v11[6] = 0;
    if (a2 >= 1)
    {
      v13 = (a3 - 1);
      if (a3 >= 1)
      {
        v14 = v11 + 7;
        if (a5 == 2 || a5 == 4)
        {
          v15 = 0;
          v16 = 0;
          v17 = a3;
          v18 = 8 * a3;
          v19 = 8 * a3 - 8;
          v20 = 4 * a3;
          v21 = a2;
          do
          {
            v22 = 0;
            v23 = (v16 & 0x7FFFFFFD) != 0 || a4 == 0;
            v24 = v16 ^ 2;
            if (v23)
              v24 = v16;
            if (v24 == 3)
              v25 = 15;
            else
              v25 = v24;
            v26 = v25 << 24;
            if (v25 == 15)
              v27 = 520552448;
            else
              v27 = (v25 << 24) | 0x70000;
            v28 = v15;
            v29 = v19;
            do
            {
              v31 = v22 == 0;
              v32 = &v14[v28];
              switch(a5)
              {
                case 1:
                  *(_QWORD *)v32 = v26 | v29 | 0x40070000u;
                  if (v13 == v22)
                    v33 = -128;
                  else
                    v33 = -256;
                  v30 = v33 | v31;
                  v31 = ~v33;
                  break;
                case 3:
                case 5:
                  *(_QWORD *)v32 = v26 | v29 | 0x40070000u;
                  v30 = -1;
                  break;
                case 6:
                  *(_QWORD *)v32 = v26 | v29 | 0xC0070000;
                  v31 = 1065353216;
                  v30 = -1082130432;
                  break;
                case 7:
                  v30 = 0;
                  *(_QWORD *)v32 = v26 | v29 | 0x80070000;
                  v31 = 1065353216;
                  break;
                case 8:
                  v30 = 0;
                  *(_QWORD *)v32 = v29 | v27;
                  v31 = 255;
                  break;
                default:
                  v30 = 0;
                  *(_QWORD *)v32 = v26 | v29 | 0x70000u;
                  break;
              }
              v32[2] = v30;
              v32[3] = v31;
              ++v22;
              v29 -= 8;
              v28 += 4;
            }
            while (v17 != v22);
            ++v16;
            v19 += v18;
            v15 += v20;
          }
          while (v16 != v21);
        }
        else
        {
          v39 = 0;
          v40 = 0;
          v41 = 8 * a3;
          v42 = 8 * a3 - 8;
          v43 = 4 * (a3 - 1);
          v44 = 4 * a3;
          v45 = 4 * a3;
          v46 = a2;
          do
          {
            v47 = 0;
            v48 = (v40 & 0x7FFFFFFD) != 0 || a4 == 0;
            v49 = v40 ^ 2;
            if (v48)
              v49 = v40;
            if (v49 == 3)
              v49 = 15;
            v50 = v49 << 24;
            v51 = (v49 << 24) | 0x70000;
            if (v49 == 15)
              v51 = 520552448;
            v52 = v42;
            do
            {
              v56 = &v14[v39 + (int)v47];
              switch(a5)
              {
                case 1:
                  *(_QWORD *)v56 = v50 | v52 | 0x40070000u;
                  if (v43 == v47)
                    v57 = -128;
                  else
                    v57 = -256;
                  v55 = ~v57;
                  v53 = v57 | (v47 == 0);
                  break;
                case 3:
                case 5:
                  v55 = v47 == 0;
                  *(_QWORD *)v56 = v50 | v52 | 0x40070000u;
                  v53 = -1;
                  break;
                case 6:
                  *(_QWORD *)v56 = v50 | v52 | 0xC0070000;
                  v55 = 1065353216;
                  v53 = -1082130432;
                  break;
                case 7:
                  v53 = 0;
                  *(_QWORD *)v56 = v50 | v52 | 0x80070000;
                  v55 = 1065353216;
                  break;
                case 8:
                  v53 = 0;
                  v54 = v52 | v51;
                  goto LABEL_57;
                default:
                  v53 = 0;
                  v54 = v50 | v52 | 0x70000;
LABEL_57:
                  *v56 = v54;
                  v56[1] = 0;
                  v55 = 255;
                  break;
              }
              v56[2] = v53;
              v56[3] = v55;
              v52 -= 8;
              v47 += 4;
            }
            while (v45 != v47);
            ++v40;
            v42 += v41;
            v39 += v44;
          }
          while (v40 != v46);
        }
      }
    }
  }
  else
  {
    v34 = 4 * (4 * a2 + 7);
    v12 = malloc_type_malloc(4 * (4 * a2 + 7), 0x100004052888210uLL);
    *v12 = v34;
    v12[1] = 0;
    v12[2] = (a2 << 20) + 1572866;
    v12[3] = v10;
    v12[4] = 0;
    v12[5] = v9;
    v12[6] = 0;
    if (a2 >= 1)
    {
      v35 = 8 * a3;
      if (a4)
      {
        v36 = 0;
        v37 = 0;
        do
        {
          if ((v37 & 0x7FFFFFFD) != 0)
            v38 = v37;
          else
            v38 = v37 ^ 2;
          writeSample((uint64_t)v12, v37++, v38, v35, v36, 1, 1, a5);
          v36 += v35;
        }
        while (a2 != v37);
      }
      else
      {
        v58 = 0;
        do
        {
          writeSample((uint64_t)v12, v58, v58, v35, a4, 1, 1, a5);
          ++v58;
          a4 += v35;
        }
        while (a2 != v58);
      }
    }
  }
  return v12;
}

uint64_t writeSample(uint64_t result, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8)
{
  _QWORD *v8;
  int v9;
  char v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;

  v8 = (_QWORD *)(result + 16 * a2 + 28);
  if (a3 == 3)
    v9 = 15;
  else
    v9 = a3;
  switch(a8)
  {
    case 1:
      v10 = a4 - 1;
      *v8 = (v9 << 24) | ((a4 - 1) << 16) | a5 | 0x40000000;
      if (!a6)
        v10 = a4;
      v11 = -1 << v10;
      if (a4 <= 32)
        v12 = ~v11;
      else
        v12 = 0x7FFFFFFF;
      v13 = -v12;
      if (!a7)
        v13 = ~v12;
      *(_DWORD *)(result + 16 * a2 + 36) = v13;
      *(_DWORD *)(result + 16 * a2 + 40) = v12;
      break;
    case 3:
    case 5:
      *v8 = ((a4 << 16) - 0x10000) | (v9 << 24) | a5 | 0x40000000;
      *(_DWORD *)(result + 16 * a2 + 36) = -1;
      *(_DWORD *)(result + 16 * a2 + 40) = a7 != 0;
      break;
    case 6:
      *(_DWORD *)v8 = ((a4 << 16) + 1073676288) | (v9 << 24) | a5 | 0xC0000000;
      *(_DWORD *)(result + 16 * a2 + 32) = 0;
      *(_DWORD *)(result + 16 * a2 + 36) = -1082130432;
      *(_DWORD *)(result + 16 * a2 + 40) = 1065353216;
      break;
    case 7:
      *(_DWORD *)v8 = ((a4 << 16) + 2147418112) | (v9 << 24) | a5 | 0x80000000;
      *(_DWORD *)(result + 16 * a2 + 32) = 0;
      *(_DWORD *)(result + 16 * a2 + 36) = 0;
      *(_DWORD *)(result + 16 * a2 + 40) = 1065353216;
      break;
    case 8:
      v14 = v9 << 24;
      if (v9 == 15)
        v14 = 520093696;
      *v8 = ((a4 << 16) - 0x10000) | a5 | v14;
      goto LABEL_20;
    default:
      *v8 = ((a4 << 16) - 0x10000) | (v9 << 24) | a5;
      if (a8 == 2 || a8 == 4)
      {
        *(_DWORD *)(result + 16 * a2 + 36) = 0;
        *(_DWORD *)(result + 16 * a2 + 40) = a7 != 0;
      }
      else
      {
LABEL_20:
        if (a4 <= 32)
          v15 = ~(-1 << a4);
        else
          v15 = -1;
        *(_DWORD *)(result + 16 * a2 + 36) = 0;
        *(_DWORD *)(result + 16 * a2 + 40) = v15;
      }
      break;
  }
  return result;
}

_OWORD *createDFDPacked(int a1, int a2, int32x4_t *a3, uint64_t a4, int a5)
{
  _OWORD *v5;
  int32x4_t *v9;
  int v10;
  int v11;
  int *v12;
  uint64_t v13;
  int32x4_t *v14;
  __int32 v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  _DWORD *v23;
  int v24;
  int v25;
  int v26;
  signed int i;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int32x4_t *v38;
  int32x4_t v39;
  uint64_t v40;
  int32x4_t v41;
  __int32 *v42;
  uint64_t v43;
  int v44;
  int v45;
  _DWORD *v46;
  int v47;
  uint64_t v48;
  unsigned int v49;
  int v50;
  _DWORD v52[36];
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (a2 == 6)
  {
    v5 = malloc_type_malloc(0x7CuLL, 0x100004052888210uLL);
    *v5 = xmmword_18823DA30;
    v5[1] = xmmword_18823DA40;
    v5[2] = xmmword_18823DA50;
    v5[3] = xmmword_18823DA60;
    v5[4] = xmmword_18823DA70;
    v5[5] = xmmword_18823DA80;
    v5[6] = xmmword_18823DA90;
    *((_QWORD *)v5 + 14) = 0xF00000000;
    *((_DWORD *)v5 + 30) = 31;
    return v5;
  }
  v9 = a3;
  v10 = a2;
  if (!a1)
  {
    if (a2 < 1)
    {
      v37 = 0;
      goto LABEL_36;
    }
    if (a2 >= 8)
    {
      v21 = a2 & 0xFFFFFFF8;
      v38 = a3 + 1;
      v39 = 0uLL;
      v40 = v21;
      v41 = 0uLL;
      do
      {
        v39 = vaddq_s32(v38[-1], v39);
        v41 = vaddq_s32(*v38, v41);
        v38 += 2;
        v40 -= 8;
      }
      while (v40);
      v22 = vaddvq_s32(vaddq_s32(v41, v39));
      if (v21 == a2)
        goto LABEL_35;
    }
    else
    {
      v21 = 0;
      v22 = 0;
    }
    v42 = &a3->i32[v21];
    v43 = a2 - v21;
    do
    {
      v44 = *v42++;
      v22 += v44;
      --v43;
    }
    while (v43);
LABEL_35:
    v37 = v22 >> 3;
LABEL_36:
    v45 = 4 * (4 * a2 + 7);
    v46 = malloc_type_malloc(4 * (4 * a2 + 7), 0x100004052888210uLL);
    v5 = v46;
    *v46 = v45;
    v46[1] = 0;
    if (a5 == 8)
      v47 = 131329;
    else
      v47 = 65793;
    v46[2] = (v10 << 20) + 1572866;
    v46[3] = v47;
    v46[4] = 0;
    v46[5] = v37;
    v46[6] = 0;
    if (v10 >= 1)
    {
      v48 = 0;
      v49 = 0;
      do
      {
        writeSample((uint64_t)v5, v48, *(_DWORD *)(a4 + 4 * v48), a3->i32[v48], v49, 1, 1, a5);
        v49 += a3->u32[v48++];
      }
      while (v10 != v48);
    }
    return v5;
  }
  v11 = 0;
  if (a2 < 1)
  {
    v50 = 24;
  }
  else
  {
    v12 = v52;
    v13 = a2;
    v14 = a3;
    do
    {
      *v12++ = v11;
      v15 = v14->i32[0];
      v14 = (int32x4_t *)((char *)v14 + 4);
      v11 += v15;
      --v13;
    }
    while (v13);
    v16 = 0;
    v17 = 0;
    v18 = ((_BYTE)v11 - 1) & 0x18;
    do
    {
      v52[(v17 ^ v18) + 4] = v16;
      v19 = a3->i32[v16] + v17;
      v20 = (v19 - 1) & 0xFFFFFFF8;
      if (v20 != (v17 & 0xFFFFFFF8))
      {
        v52[(v20 ^ v18) + 4] = v16;
        ++v10;
      }
      ++v16;
      v17 = v19;
    }
    while (a2 != v16);
    v50 = ((_BYTE)v11 - 1) & 0x18;
  }
  v23 = malloc_type_malloc(4 * (4 * v10 + 7), 0x100004052888210uLL);
  v5 = v23;
  if (a5 == 8)
    v24 = 131329;
  else
    v24 = 65793;
  *v23 = 4 * (4 * v10 + 7);
  v23[1] = 0;
  v23[2] = (v10 << 20) + 1572866;
  v23[3] = v24;
  v23[4] = 0;
  v23[5] = v11 >> 3;
  v23[6] = 0;
  v25 = v50;
  if (v11 >= 1)
  {
    v26 = 0;
    for (i = 0; i < v11; i += v33)
    {
      while (1)
      {
        while (1)
        {
          v28 = (int)v52[i + 4];
          if ((_DWORD)v28 != -1)
            break;
          i = (i & 0xFFFFFFF8) + 8;
          if (i >= v11)
            return v5;
        }
        v29 = v52[v28] ^ v25;
        if (v29 != i)
          break;
        v30 = v28;
        writeSample((uint64_t)v5, v26++, *(_DWORD *)(a4 + 4 * v28), v9->i32[v28], i, 1, 1, a5);
        i += v9->i32[v30];
        if (i >= v11)
          return v5;
      }
      v31 = 8 - (v52[v28] & 7);
      v32 = 4 * v28;
      v33 = v9->i32[v28] - v31;
      v34 = v26 + 1;
      writeSample((uint64_t)v5, v26, *(_DWORD *)(a4 + 4 * v28), v31, v29, 0, 1, a5);
      v52[v29 + 4] = -1;
      v26 += 2;
      v35 = *(_DWORD *)(a4 + v32);
      v25 = v50;
      v36 = v34;
      v9 = a3;
      writeSample((uint64_t)v5, v36, v35, v33, i, 1, 0, a5);
    }
  }
  return v5;
}

char *createDFDCompressed(unsigned int a1, int a2, int a3, int a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  char *result;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;

  v10 = a1;
  v11 = 4 * a1;
  v12 = *(_DWORD *)((char *)&compSampleCount + v11);
  result = (char *)malloc_type_malloc(4 * (4 * v12 + 7), 0x100004052888210uLL);
  *(_DWORD *)result = 4 * (4 * v12 + 7);
  *((_DWORD *)result + 1) = 0;
  *((_DWORD *)result + 2) = (v12 << 20) + 1572866;
  if (a5 == 8)
    v14 = 131328;
  else
    v14 = 65792;
  *((_DWORD *)result + 3) = *(_DWORD *)((char *)&compModelMapping + v11) | v14;
  *((_DWORD *)result + 4) = ((a3 << 8) - 256) | (a2 - 1) | ((a4 << 16) - 0x10000);
  *((_DWORD *)result + 5) = *(_DWORD *)((char *)&compBytes + v11);
  *((_DWORD *)result + 6) = 0;
  v15 = *(_DWORD *)((char *)&compFirstChannel + v11);
  switch(a5)
  {
    case 1:
      v16 = (compChannelBits[v10] << 16) - 0x10000;
      *((_DWORD *)result + 7) = v16 | (v15 << 24) | 0x40000000;
      *((_DWORD *)result + 8) = 0;
      v17 = 0x7FFFFFFF;
      v18 = 0x80000000;
      *((_DWORD *)result + 9) = 0x80000000;
      *((_DWORD *)result + 10) = 0x7FFFFFFF;
      if (((0x162CuLL >> v10) & 1) != 0)
        goto LABEL_22;
      break;
    case 3:
    case 5:
      v16 = (compChannelBits[v10] << 16) - 0x10000;
      *((_DWORD *)result + 7) = v16 | (v15 << 24) | 0x40000000;
      *((_DWORD *)result + 8) = 0;
      v17 = 1;
      v18 = -1;
      *((_DWORD *)result + 9) = -1;
      *((_DWORD *)result + 10) = 1;
      if (((0x162CuLL >> v10) & 1) != 0)
        goto LABEL_22;
      break;
    case 6:
      v16 = (compChannelBits[v10] << 16) - 0x10000;
      *((_DWORD *)result + 7) = v16 | (v15 << 24) | 0xC0000000;
      *((_DWORD *)result + 8) = 0;
      v17 = 1065353216;
      v18 = -1082130432;
      *((_DWORD *)result + 9) = -1082130432;
      *((_DWORD *)result + 10) = 1065353216;
      if (((0x162CuLL >> v10) & 1) != 0)
        goto LABEL_22;
      break;
    case 7:
      v18 = 0;
      v16 = (compChannelBits[v10] << 16) - 0x10000;
      *((_DWORD *)result + 7) = v16 | (v15 << 24) | 0x80000000;
      *((_DWORD *)result + 8) = 0;
      v17 = 1065353216;
      *((_DWORD *)result + 9) = 0;
      *((_DWORD *)result + 10) = 1065353216;
      if (((0x162CuLL >> v10) & 1) != 0)
        goto LABEL_22;
      break;
    case 8:
      v18 = 0;
      v19 = v15 << 24;
      if (((0x40CuLL >> v10) & 1) != 0)
        v19 = 520093696;
      v16 = (compChannelBits[v10] << 16) - 0x10000;
      *((_DWORD *)result + 7) = v16 | v19;
      *((_DWORD *)result + 8) = 0;
      v17 = -1;
      *((_DWORD *)result + 9) = 0;
      *((_DWORD *)result + 10) = -1;
      if (((0x162CuLL >> v10) & 1) != 0)
        goto LABEL_22;
      break;
    default:
      v16 = (compChannelBits[v10] << 16) - 0x10000;
      *(_QWORD *)(result + 28) = v16 | (v15 << 24);
      if (a5 == 4 || a5 == 2)
      {
        v18 = 0;
        v17 = 1;
        *((_DWORD *)result + 9) = 0;
        *((_DWORD *)result + 10) = 1;
        if (((0x162CuLL >> v10) & 1) == 0)
          return result;
      }
      else
      {
        v18 = 0;
        v17 = -1;
        *((_DWORD *)result + 9) = 0;
        *((_DWORD *)result + 10) = -1;
        if (((0x162CuLL >> v10) & 1) == 0)
          return result;
      }
LABEL_22:
      v20 = compSecondChannel[v10];
      switch(a5)
      {
        case 1:
        case 3:
        case 5:
          v20 |= 0x40u;
          break;
        case 6:
          v20 |= 0xC0u;
          break;
        case 7:
          v20 |= 0x80u;
          break;
        case 8:
          if (a1 == 9)
            v20 = 31;
          break;
        default:
          break;
      }
      *(_QWORD *)(result + 44) = compSecondChannelOffset[v10] | v16 | (v20 << 24);
      *((_DWORD *)result + 13) = v18;
      *((_DWORD *)result + 14) = v17;
      break;
  }
  return result;
}

char *createDFDDepthStencil(int a1, int a2, int a3)
{
  int v6;
  char *result;
  int v8;
  int *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2 <= 0)
    v6 = a1 > 0;
  else
    v6 = (a1 > 0) + 1;
  result = (char *)malloc_type_malloc((16 * v6 + 28), 0x100004052888210uLL);
  *(_DWORD *)result = 16 * v6 + 28;
  *((_DWORD *)result + 1) = 0;
  *((_DWORD *)result + 2) = (v6 << 20) + 1572866;
  *(_QWORD *)(result + 12) = 65793;
  *((_DWORD *)result + 5) = a3;
  *((_DWORD *)result + 6) = 0;
  if (a1 == 32)
  {
    *(_OWORD *)(result + 28) = xmmword_18823DAA0;
    if (a2 <= 0)
      return result;
    goto LABEL_12;
  }
  if (a1 <= 0)
  {
    if (a2 > 0)
    {
      v9 = (int *)(result + 28);
      v10 = (a2 << 16) - 0x10000;
      v11 = 10;
      v12 = 9;
      v13 = 8;
      goto LABEL_13;
    }
  }
  else
  {
    *((_DWORD *)result + 7) = ((a1 << 16) - 0x10000) | 0xE000000;
    *((_QWORD *)result + 4) = 0;
    if (a1 <= 0x20)
      v8 = ~(-1 << a1);
    else
      v8 = -1;
    *((_DWORD *)result + 10) = v8;
    if (a2 > 0)
    {
LABEL_12:
      v9 = (int *)(result + 44);
      v10 = ((a2 << 16) - 0x10000) | a1;
      v11 = 14;
      v12 = 13;
      v13 = 12;
LABEL_13:
      *v9 = v10 | 0xD000000;
      *(_DWORD *)&result[4 * v13] = 0;
      *(_DWORD *)&result[4 * v12] = 0;
      *(_DWORD *)&result[4 * v11] = 1;
    }
  }
  return result;
}

uint64_t interpretDFD(_DWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, unsigned int *a6)
{
  unsigned int v6;
  uint64_t result;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int *v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  unsigned int *v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int *v32;
  int v33;
  unsigned int v34;
  char v35;
  int v36;
  char v37;
  uint64_t v38;
  unsigned int *v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  _DWORD *v44;
  int v45;
  char *v46;
  char v47;
  int v48;

  if (*a1 < 0x2Cu)
    return 64;
  v6 = (a1[2] >> 18) - 6;
  if (v6 > 0x103 || *a1 != ((4 * v6) & 0x7FFFFFF0) + 28)
    return 64;
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  if (a1[5] > 0xFFu || a1[6])
    return 66;
  v8 = a1[3];
  if (v8 != 1)
    return 67;
  v9 = v6 >> 2;
  v10 = 4 * ((v8 & 0xFF0000) == 0x20000);
  if (v6 < 4)
    goto LABEL_9;
  if (v9 <= 1)
    v11 = 1;
  else
    v11 = v9;
  v12 = a1 + 8;
  v13 = v11;
  do
  {
    v14 = *v12;
    v12 += 4;
    if (v14)
      return 65;
    --v13;
  }
  while (v13);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = a1 + 7;
  v19 = v11;
  do
  {
    v20 = *v18;
    if (v15)
    {
      if (v20 < 0)
      {
        if ((v10 & 0x20) == 0)
          return 68;
      }
      else if ((v10 & 0x20) != 0)
      {
        return 68;
      }
      v15 = 1;
    }
    else
    {
      v15 = v20 >> 31;
      if (v20 >= 0)
        v10 = v10;
      else
        v10 = v10 | 0x20;
    }
    v21 = *v18 & 0x40000000;
    if (v16)
    {
      if (v21)
      {
        if ((v10 & 0x10) == 0)
          return 68;
      }
      else if ((v10 & 0x10) != 0)
      {
        return 68;
      }
      v16 = 1;
    }
    else
    {
      v16 = v21 >> 30;
      v10 = v10 | (v21 >> 26);
    }
    if (v17)
      goto LABEL_23;
    v17 = *((unsigned __int8 *)v18 + 2);
    if (*((_BYTE *)v18 + 2))
    {
      if ((v10 & 0x20) == 0)
      {
        if (v18[3] == 1)
          v10 = v10;
        else
          v10 = v10 | 8;
LABEL_23:
        v17 = 1;
        goto LABEL_24;
      }
      v17 = 1;
      if (*((float *)v18 + 3) == 1.0)
        v10 = v10;
      else
        v10 = v10 | 8;
    }
LABEL_24:
    v18 += 4;
    --v19;
  }
  while (v19);
  v46 = (char *)(a1 + 7);
  while (1)
  {
    v47 = *v46;
    v46 += 16;
    if ((v47 & 7) != 0)
      break;
    if (!--v11)
      goto LABEL_9;
  }
  v10 = v10 | 2;
LABEL_9:
  if ((v10 & 2) != 0)
  {
    *a6 = a1[5];
    if (v6 >= 4)
    {
      v35 = 0;
      v36 = 0;
      v37 = 0;
      if (v9 <= 1)
        v38 = 1;
      else
        v38 = v9;
      v39 = a1 + 7;
      v40 = -1;
      while (1)
      {
        v42 = *v39;
        v39 += 4;
        v41 = v42;
        v43 = HIBYTE(v42) & 0xF;
        result = 67;
        v44 = a2;
        switch(v43)
        {
          case 0:
            goto LABEL_81;
          case 1:
            v44 = a3;
            goto LABEL_81;
          case 2:
            v44 = a4;
            goto LABEL_81;
          case 15:
            v44 = a5;
LABEL_81:
            v45 = BYTE2(v41) + 1;
            if (v43 == v40)
            {
              if ((unsigned __int16)v41 >> 3 != v36 - 1
                || ((v41 | (v35 + v37)) & 7) != 0)
              {
                return 64;
              }
              v10 = v10 | 1;
              v44[1] += v45;
              v35 = BYTE2(v41) + 1;
              v36 = (unsigned __int16)v41 >> 3;
              v37 = v41;
              if (!--v38)
                goto LABEL_48;
            }
            else
            {
              if (v44[1])
                return 64;
              *v44 = (unsigned __int16)v41;
              v44[1] = v45;
              v40 = v43;
              v35 = BYTE2(v41) + 1;
              v36 = (unsigned __int16)v41 >> 3;
              v37 = v41;
              if (!--v38)
                goto LABEL_48;
            }
            break;
          default:
            return result;
        }
      }
    }
LABEL_48:
    if ((v10 & 1) != 0)
    {
      v48 = 8 * *a6 - 8;
      *(_DWORD *)a2 ^= v48;
      *(_DWORD *)a3 ^= v48;
      *(_DWORD *)a4 ^= v48;
      *(_DWORD *)a5 ^= v48;
      return v10;
    }
    else
    {
      return v10;
    }
  }
  else
  {
    if (v6 >= 4)
    {
      v22 = 0;
      v23 = 0;
      v24 = 0;
      if (v9 <= 1)
        v25 = 1;
      else
        v25 = v9;
      v26 = a1 + 7;
      v27 = -1;
      while (1)
      {
        v30 = *v26;
        v26 += 4;
        v29 = v30;
        v31 = HIBYTE(v30) & 0xF;
        result = 67;
        v32 = (int *)a2;
        switch(v31)
        {
          case 0:
            goto LABEL_61;
          case 1:
            v32 = (int *)a3;
            goto LABEL_61;
          case 2:
            v32 = (int *)a4;
            goto LABEL_61;
          case 15:
            v32 = (int *)a5;
LABEL_61:
            v33 = (unsigned __int16)v29 >> 3;
            v34 = (BYTE2(v29) + 1) >> 3;
            if (v31 == v27)
            {
              if (v33 == v23 - 1)
              {
                if (v24 && (v10 & 1) == 0)
                  return 64;
                v10 = v10 | 1;
                *v32 = v33;
              }
              else if (v33 != v22 + v23 || v24 && (v10 & 1) != 0)
              {
                return 64;
              }
              v28 = v32[1] + v34;
              v32[1] = v28;
              v24 = 1;
              *a6 = v28;
              v22 = v34;
              v23 = v33;
              result = v10;
              if (!--v25)
                return result;
            }
            else
            {
              if (v32[1])
                return 64;
              *v32 = v33;
              v32[1] = v34;
              v22 = v34;
              v27 = v31;
              *a6 = v34;
              v23 = v33;
              result = v10;
              if (!--v25)
                return result;
            }
            break;
          default:
            return result;
        }
      }
    }
    return v10;
  }
}

uint64_t getDFDComponentInfoUnpacked(uint64_t result, _DWORD *a2, unsigned int *a3)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int *v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;

  v3 = (*(_DWORD *)(result + 8) >> 18) - 6;
  *a2 = 0;
  if (v3 >= 4)
  {
    LODWORD(v4) = v3 >> 2;
    if (v4 <= 1)
      v4 = 1;
    else
      v4 = v4;
    v5 = (unsigned int *)(result + 28);
    v6 = -1;
    do
    {
      while (1)
      {
        v7 = *v5;
        v5 += 4;
        v8 = (BYTE2(v7) + 1) >> 3;
        v9 = HIBYTE(v7) & 0xF;
        if (v9 == v6)
          break;
        ++*a2;
        v6 = v9;
        *a3 = v8;
        if (!--v4)
          return result;
      }
      *a3 += v8;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t getDFDNumComponents(uint64_t a1)
{
  unsigned int v1;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  const float *v9;
  uint64_t v10;
  unsigned __int128 v11;
  int32x4_t v12;
  int32x4_t v13;
  const float *v14;
  unsigned __int128 v15;
  unsigned __int128 v16;
  unsigned __int128 v17;
  int32x4_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;

  v1 = (*(_DWORD *)(a1 + 8) >> 18) - 6;
  if (v1 < 4)
    return 0;
  v3 = v1 >> 2;
  if (v3 <= 1)
    v4 = 1;
  else
    v4 = v3;
  if (v4 >= 9)
  {
    if ((v4 & 7) != 0)
      v8 = v4 & 7;
    else
      v8 = 8;
    v5 = v4 - v8;
    v9 = (const float *)(a1 + 92);
    v10 = v8 - v4;
    *(_QWORD *)&v11 = -1;
    *((_QWORD *)&v11 + 1) = -1;
    v12 = 0uLL;
    v13 = 0uLL;
    do
    {
      v14 = v9 - 16;
      v15 = (unsigned __int128)vld4q_f32(v14);
      v16 = (unsigned __int128)vld4q_f32(v9);
      v17 = *(_OWORD *)&vshrq_n_u32((uint32x4_t)v15, 0x18uLL) & __PAIR128__(0xFFFFFF0FFFFFFF0FLL, 0xFFFFFF0FFFFFFF0FLL);
      v18 = (int32x4_t)vextq_s8((int8x16_t)v11, (int8x16_t)v17, 0xCuLL);
      v11 = *(_OWORD *)&vshrq_n_u32((uint32x4_t)v16, 0x18uLL) & __PAIR128__(0xFFFFFF0FFFFFFF0FLL, 0xFFFFFF0FFFFFFF0FLL);
      v12 = vsubq_s32(v12, (int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32((int32x4_t)v17, v18)));
      v13 = vsubq_s32(v13, (int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32((int32x4_t)v11, (int32x4_t)vextq_s8((int8x16_t)v17, (int8x16_t)v11, 0xCuLL))));
      v9 += 32;
      v10 += 8;
    }
    while (v10);
    LODWORD(v6) = vaddvq_s32(vaddq_s32(v13, v12));
    v7 = HIDWORD(v11);
  }
  else
  {
    v5 = 0;
    LODWORD(v6) = 0;
    v7 = -1;
  }
  v19 = a1 + 16 * v5 + 28;
  v20 = v5 - v4;
  do
  {
    v21 = *(_BYTE *)(v19 + 3) & 0xF;
    if (v21 == v7)
      v6 = v6;
    else
      v6 = (v6 + 1);
    v19 += 16;
    v7 = v21;
  }
  while (!__CFADD__(v20++, 1));
  return v6;
}

uint64_t recreateBytesPlane0FromSampleInfo(_DWORD *a1, unsigned int *a2)
{
  unsigned int v3;
  void *v5;
  unsigned int v6;
  uint64_t v8;
  _DWORD *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;

  if (*a1 < 0x2Cu)
    return 64;
  v3 = (a1[2] >> 18) - 6;
  if (v3 > 0x103 || *a1 != ((4 * v3) & 0x7FFFFFF0) + 28)
    return 64;
  v5 = malloc_type_malloc(v3 & 0xFFFFFFFC, 0x100004052888210uLL);
  memset(v5, 255, v3 & 0xFFFFFFFC);
  if (v3 >= 4)
  {
    v8 = 0;
    v6 = 0;
    v9 = a1 + 1;
    v10 = v3 >> 2;
    if (v3 >> 2 <= 1)
      v11 = 1;
    else
      v11 = v10;
    do
    {
      v12 = 0;
      v13 = (unsigned __int16)v9[4 * v8 + 6];
      while (v13 != *((_DWORD *)v5 + v12))
      {
        if (v11 == ++v12)
        {
          LODWORD(v12) = v11;
          break;
        }
      }
      if ((_DWORD)v12 == v10)
      {
        v6 += BYTE2(v9[4 * v8 + 6]) + 1;
        *((_DWORD *)v5 + v8) = v13;
      }
      ++v8;
    }
    while (v8 != v11);
  }
  else
  {
    v6 = 0;
  }
  free(v5);
  *a2 = v6 >> 3;
  return 1;
}

char *vk2dfd(int a1)
{
  char *result;
  __int128 *v3;
  __int128 *v4;
  int v5;
  unsigned int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  __int128 *v11;
  __int128 *v12;
  uint64_t v13;
  __int128 *v14;
  __int128 *v15;
  __int128 *v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *v19;
  int v20;
  __int128 *v21;
  __int128 *v22;
  __int128 *v23;
  __int128 *v24;
  __int128 *v25;
  __int128 *v26;
  int v27;
  int v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  result = 0;
  v31 = *MEMORY[0x1E0C80C00];
  if (a1 <= 1000287999)
  {
    switch(a1)
    {
      case 1:
        *(_QWORD *)&v30 = 1;
        *(_QWORD *)&v29 = 0x400000004;
        v3 = &v29;
        v4 = &v30;
        v5 = 2;
        goto LABEL_114;
      case 2:
        v11 = &xmmword_18823DCB8;
        goto LABEL_47;
      case 3:
        v11 = &xmmword_18822DD60;
        goto LABEL_47;
      case 4:
        DWORD2(v30) = 0;
        v13 = 0x100000002;
        goto LABEL_50;
      case 5:
        DWORD2(v30) = 2;
        v13 = 0x100000000;
LABEL_50:
        *(_QWORD *)&v30 = v13;
        DWORD2(v29) = 5;
        *(_QWORD *)&v29 = 0x600000005;
        v3 = &v29;
        v4 = &v30;
        v5 = 3;
        goto LABEL_114;
      case 6:
        v14 = &xmmword_18823DCB8;
        goto LABEL_53;
      case 7:
        v14 = &xmmword_18822DD60;
LABEL_53:
        v30 = *v14;
        v12 = &xmmword_18823DCD0;
        goto LABEL_113;
      case 8:
        v30 = xmmword_18822B2D0;
        v12 = &xmmword_18823DCE0;
        goto LABEL_113;
      case 9:
        return (char *)createDFDUnpacked(0, 1, 1, 0, 0);
      case 10:
        return (char *)createDFDUnpacked(0, 1, 1, 0, 1);
      case 11:
        return (char *)createDFDUnpacked(0, 1, 1, 0, 2);
      case 12:
        return (char *)createDFDUnpacked(0, 1, 1, 0, 3);
      case 13:
        return (char *)createDFDUnpacked(0, 1, 1, 0, 4);
      case 14:
        return (char *)createDFDUnpacked(0, 1, 1, 0, 5);
      case 15:
        return (char *)createDFDUnpacked(0, 1, 1, 0, 8);
      case 16:
        return (char *)createDFDUnpacked(0, 2, 1, 0, 0);
      case 17:
        return (char *)createDFDUnpacked(0, 2, 1, 0, 1);
      case 18:
        return (char *)createDFDUnpacked(0, 2, 1, 0, 2);
      case 19:
        return (char *)createDFDUnpacked(0, 2, 1, 0, 3);
      case 20:
        return (char *)createDFDUnpacked(0, 2, 1, 0, 4);
      case 21:
        return (char *)createDFDUnpacked(0, 2, 1, 0, 5);
      case 22:
        return (char *)createDFDUnpacked(0, 2, 1, 0, 8);
      case 23:
        return (char *)createDFDUnpacked(0, 3, 1, 0, 0);
      case 24:
        return (char *)createDFDUnpacked(0, 3, 1, 0, 1);
      case 25:
        return (char *)createDFDUnpacked(0, 3, 1, 0, 2);
      case 26:
        return (char *)createDFDUnpacked(0, 3, 1, 0, 3);
      case 27:
        return (char *)createDFDUnpacked(0, 3, 1, 0, 4);
      case 28:
        return (char *)createDFDUnpacked(0, 3, 1, 0, 5);
      case 29:
        return (char *)createDFDUnpacked(0, 3, 1, 0, 8);
      case 30:
        return (char *)createDFDUnpacked(0, 3, 1, 1u, 0);
      case 31:
        return (char *)createDFDUnpacked(0, 3, 1, 1u, 1);
      case 32:
        return (char *)createDFDUnpacked(0, 3, 1, 1u, 2);
      case 33:
        return (char *)createDFDUnpacked(0, 3, 1, 1u, 3);
      case 34:
        return (char *)createDFDUnpacked(0, 3, 1, 1u, 4);
      case 35:
        return (char *)createDFDUnpacked(0, 3, 1, 1u, 5);
      case 36:
        return (char *)createDFDUnpacked(0, 3, 1, 1u, 8);
      case 37:
        return (char *)createDFDUnpacked(0, 4, 1, 0, 0);
      case 38:
        return (char *)createDFDUnpacked(0, 4, 1, 0, 1);
      case 39:
        return (char *)createDFDUnpacked(0, 4, 1, 0, 2);
      case 40:
        return (char *)createDFDUnpacked(0, 4, 1, 0, 3);
      case 41:
        return (char *)createDFDUnpacked(0, 4, 1, 0, 4);
      case 42:
        return (char *)createDFDUnpacked(0, 4, 1, 0, 5);
      case 43:
        return (char *)createDFDUnpacked(0, 4, 1, 0, 8);
      case 44:
        return (char *)createDFDUnpacked(0, 4, 1, 1u, 0);
      case 45:
        return (char *)createDFDUnpacked(0, 4, 1, 1u, 1);
      case 46:
        return (char *)createDFDUnpacked(0, 4, 1, 1u, 2);
      case 47:
        return (char *)createDFDUnpacked(0, 4, 1, 1u, 3);
      case 48:
        return (char *)createDFDUnpacked(0, 4, 1, 1u, 4);
      case 49:
        return (char *)createDFDUnpacked(0, 4, 1, 1u, 5);
      case 50:
        return (char *)createDFDUnpacked(0, 4, 1, 1u, 8);
      case 51:
        v30 = xmmword_18820BF90;
        v12 = &xmmword_18823DCF0;
        goto LABEL_113;
      case 52:
        v30 = xmmword_18820BF90;
        v15 = &xmmword_18823DCF0;
        goto LABEL_119;
      case 53:
        v30 = xmmword_18820BF90;
        v16 = &xmmword_18823DCF0;
        goto LABEL_122;
      case 54:
        v30 = xmmword_18820BF90;
        v17 = &xmmword_18823DCF0;
        goto LABEL_125;
      case 55:
        v30 = xmmword_18820BF90;
        v18 = &xmmword_18823DCF0;
        goto LABEL_128;
      case 56:
        v30 = xmmword_18820BF90;
        v19 = &xmmword_18823DCF0;
        goto LABEL_131;
      case 57:
        v29 = xmmword_18823DCF0;
        v30 = xmmword_18820BF90;
        v3 = &v29;
        v4 = &v30;
        v5 = 4;
        v20 = 8;
        return (char *)createDFDPacked(0, v5, (int32x4_t *)v3, (uint64_t)v4, v20);
      case 58:
        v21 = &xmmword_18822B2D0;
        goto LABEL_112;
      case 59:
        v22 = &xmmword_18822B2D0;
        goto LABEL_118;
      case 60:
        v23 = &xmmword_18822B2D0;
        goto LABEL_121;
      case 61:
        v24 = &xmmword_18822B2D0;
        goto LABEL_124;
      case 62:
        v25 = &xmmword_18822B2D0;
        goto LABEL_127;
      case 63:
        v26 = &xmmword_18822B2D0;
        goto LABEL_130;
      case 64:
        v21 = &xmmword_18820BF90;
LABEL_112:
        v30 = *v21;
        v12 = &xmmword_18823DD00;
        goto LABEL_113;
      case 65:
        v22 = &xmmword_18820BF90;
LABEL_118:
        v30 = *v22;
        v15 = &xmmword_18823DD00;
LABEL_119:
        v29 = *v15;
        v3 = &v29;
        v4 = &v30;
        v5 = 4;
        v20 = 1;
        return (char *)createDFDPacked(0, v5, (int32x4_t *)v3, (uint64_t)v4, v20);
      case 66:
        v23 = &xmmword_18820BF90;
LABEL_121:
        v30 = *v23;
        v16 = &xmmword_18823DD00;
LABEL_122:
        v29 = *v16;
        v3 = &v29;
        v4 = &v30;
        v5 = 4;
        v20 = 2;
        return (char *)createDFDPacked(0, v5, (int32x4_t *)v3, (uint64_t)v4, v20);
      case 67:
        v24 = &xmmword_18820BF90;
LABEL_124:
        v30 = *v24;
        v17 = &xmmword_18823DD00;
LABEL_125:
        v29 = *v17;
        v3 = &v29;
        v4 = &v30;
        v5 = 4;
        v20 = 3;
        return (char *)createDFDPacked(0, v5, (int32x4_t *)v3, (uint64_t)v4, v20);
      case 68:
        v25 = &xmmword_18820BF90;
LABEL_127:
        v30 = *v25;
        v18 = &xmmword_18823DD00;
LABEL_128:
        v29 = *v18;
        v3 = &v29;
        v4 = &v30;
        v5 = 4;
        v20 = 4;
        return (char *)createDFDPacked(0, v5, (int32x4_t *)v3, (uint64_t)v4, v20);
      case 69:
        v26 = &xmmword_18820BF90;
LABEL_130:
        v30 = *v26;
        v19 = &xmmword_18823DD00;
LABEL_131:
        v29 = *v19;
        v3 = &v29;
        v4 = &v30;
        v5 = 4;
        v20 = 5;
        return (char *)createDFDPacked(0, v5, (int32x4_t *)v3, (uint64_t)v4, v20);
      case 70:
        return (char *)createDFDUnpacked(0, 1, 2, 0, 0);
      case 71:
        return (char *)createDFDUnpacked(0, 1, 2, 0, 1);
      case 72:
        return (char *)createDFDUnpacked(0, 1, 2, 0, 2);
      case 73:
        return (char *)createDFDUnpacked(0, 1, 2, 0, 3);
      case 74:
        return (char *)createDFDUnpacked(0, 1, 2, 0, 4);
      case 75:
        return (char *)createDFDUnpacked(0, 1, 2, 0, 5);
      case 76:
        return (char *)createDFDUnpacked(0, 1, 2, 0, 6);
      case 77:
        return (char *)createDFDUnpacked(0, 2, 2, 0, 0);
      case 78:
        return (char *)createDFDUnpacked(0, 2, 2, 0, 1);
      case 79:
        return (char *)createDFDUnpacked(0, 2, 2, 0, 2);
      case 80:
        return (char *)createDFDUnpacked(0, 2, 2, 0, 3);
      case 81:
        return (char *)createDFDUnpacked(0, 2, 2, 0, 4);
      case 82:
        return (char *)createDFDUnpacked(0, 2, 2, 0, 5);
      case 83:
        return (char *)createDFDUnpacked(0, 2, 2, 0, 6);
      case 84:
        return (char *)createDFDUnpacked(0, 3, 2, 0, 0);
      case 85:
        return (char *)createDFDUnpacked(0, 3, 2, 0, 1);
      case 86:
        return (char *)createDFDUnpacked(0, 3, 2, 0, 2);
      case 87:
        return (char *)createDFDUnpacked(0, 3, 2, 0, 3);
      case 88:
        return (char *)createDFDUnpacked(0, 3, 2, 0, 4);
      case 89:
        return (char *)createDFDUnpacked(0, 3, 2, 0, 5);
      case 90:
        return (char *)createDFDUnpacked(0, 3, 2, 0, 6);
      case 91:
        return (char *)createDFDUnpacked(0, 4, 2, 0, 0);
      case 92:
        return (char *)createDFDUnpacked(0, 4, 2, 0, 1);
      case 93:
        return (char *)createDFDUnpacked(0, 4, 2, 0, 2);
      case 94:
        return (char *)createDFDUnpacked(0, 4, 2, 0, 3);
      case 95:
        return (char *)createDFDUnpacked(0, 4, 2, 0, 4);
      case 96:
        return (char *)createDFDUnpacked(0, 4, 2, 0, 5);
      case 97:
        return (char *)createDFDUnpacked(0, 4, 2, 0, 6);
      case 98:
        return (char *)createDFDUnpacked(0, 1, 4, 0, 4);
      case 99:
        return (char *)createDFDUnpacked(0, 1, 4, 0, 5);
      case 100:
        return (char *)createDFDUnpacked(0, 1, 4, 0, 6);
      case 101:
        return (char *)createDFDUnpacked(0, 2, 4, 0, 4);
      case 102:
        return (char *)createDFDUnpacked(0, 2, 4, 0, 5);
      case 103:
        return (char *)createDFDUnpacked(0, 2, 4, 0, 6);
      case 104:
        return (char *)createDFDUnpacked(0, 3, 4, 0, 4);
      case 105:
        return (char *)createDFDUnpacked(0, 3, 4, 0, 5);
      case 106:
        return (char *)createDFDUnpacked(0, 3, 4, 0, 6);
      case 107:
        return (char *)createDFDUnpacked(0, 4, 4, 0, 4);
      case 108:
        return (char *)createDFDUnpacked(0, 4, 4, 0, 5);
      case 109:
        return (char *)createDFDUnpacked(0, 4, 4, 0, 6);
      case 110:
        return (char *)createDFDUnpacked(0, 1, 8, 0, 4);
      case 111:
        return (char *)createDFDUnpacked(0, 1, 8, 0, 5);
      case 112:
        return (char *)createDFDUnpacked(0, 1, 8, 0, 6);
      case 113:
        return (char *)createDFDUnpacked(0, 2, 8, 0, 4);
      case 114:
        return (char *)createDFDUnpacked(0, 2, 8, 0, 5);
      case 115:
        return (char *)createDFDUnpacked(0, 2, 8, 0, 6);
      case 116:
        return (char *)createDFDUnpacked(0, 3, 8, 0, 4);
      case 117:
        return (char *)createDFDUnpacked(0, 3, 8, 0, 5);
      case 118:
        return (char *)createDFDUnpacked(0, 3, 8, 0, 6);
      case 119:
        return (char *)createDFDUnpacked(0, 4, 8, 0, 4);
      case 120:
        return (char *)createDFDUnpacked(0, 4, 8, 0, 5);
      case 121:
        return (char *)createDFDUnpacked(0, 4, 8, 0, 6);
      case 122:
        DWORD2(v30) = 2;
        *(_QWORD *)&v30 = 0x100000000;
        DWORD2(v29) = 10;
        *(_QWORD *)&v29 = 0xB0000000BLL;
        v3 = &v29;
        v4 = &v30;
        v5 = 3;
        v20 = 7;
        return (char *)createDFDPacked(0, v5, (int32x4_t *)v3, (uint64_t)v4, v20);
      case 123:
        LODWORD(v30) = 0;
        LODWORD(v29) = 0;
        v3 = &v30;
        v4 = &v29;
        v5 = 6;
        v20 = 7;
        return (char *)createDFDPacked(0, v5, (int32x4_t *)v3, (uint64_t)v4, v20);
      case 124:
        v27 = 16;
        v28 = 2;
        return createDFDDepthStencil(v27, 0, v28);
      case 125:
        v27 = 24;
        goto LABEL_191;
      case 126:
        v27 = 32;
LABEL_191:
        v28 = 4;
        return createDFDDepthStencil(v27, 0, v28);
      case 127:
        return createDFDDepthStencil(0, 8, 1);
      case 128:
        return createDFDDepthStencil(16, 8, 3);
      case 129:
        return createDFDDepthStencil(24, 8, 4);
      case 130:
        return createDFDDepthStencil(32, 8, 5);
      case 131:
        v6 = 0;
        goto LABEL_268;
      case 132:
        v6 = 0;
        goto LABEL_274;
      case 133:
        v6 = 1;
        goto LABEL_268;
      case 134:
        v6 = 1;
        goto LABEL_274;
      case 135:
        v6 = 2;
        goto LABEL_268;
      case 136:
        v6 = 2;
        goto LABEL_274;
      case 137:
        v6 = 3;
        goto LABEL_268;
      case 138:
        v6 = 3;
        goto LABEL_274;
      case 139:
        v6 = 4;
        goto LABEL_268;
      case 140:
        v6 = 4;
        goto LABEL_222;
      case 141:
        v6 = 5;
        goto LABEL_268;
      case 142:
        v6 = 5;
        goto LABEL_222;
      case 143:
        return createDFDCompressed(6u, 4, 4, 1, 7);
      case 144:
        return createDFDCompressed(6u, 4, 4, 1, 6);
      case 145:
        v6 = 7;
        goto LABEL_268;
      case 146:
        v6 = 7;
        goto LABEL_274;
      case 147:
        v6 = 8;
        goto LABEL_268;
      case 148:
        v6 = 8;
        goto LABEL_274;
      case 149:
        v6 = 9;
        goto LABEL_268;
      case 150:
        v6 = 9;
        goto LABEL_274;
      case 151:
        v6 = 10;
        goto LABEL_268;
      case 152:
        v6 = 10;
        goto LABEL_274;
      case 153:
        v6 = 11;
        goto LABEL_268;
      case 154:
        v6 = 11;
        goto LABEL_222;
      case 155:
        v6 = 12;
        goto LABEL_268;
      case 156:
        v6 = 12;
LABEL_222:
        v7 = 4;
        v8 = 4;
        v9 = 1;
        v10 = 1;
        return createDFDCompressed(v6, v7, v8, v9, v10);
      case 157:
        v6 = 13;
LABEL_268:
        v7 = 4;
        v8 = 4;
        v9 = 1;
        v10 = 0;
        return createDFDCompressed(v6, v7, v8, v9, v10);
      case 158:
        v6 = 13;
LABEL_274:
        v7 = 4;
        v8 = 4;
        v9 = 1;
        v10 = 8;
        return createDFDCompressed(v6, v7, v8, v9, v10);
      case 159:
        return createDFDCompressed(0xDu, 5, 4, 1, 0);
      case 160:
        return createDFDCompressed(0xDu, 5, 4, 1, 8);
      case 161:
        return createDFDCompressed(0xDu, 5, 5, 1, 0);
      case 162:
        return createDFDCompressed(0xDu, 5, 5, 1, 8);
      case 163:
        return createDFDCompressed(0xDu, 6, 5, 1, 0);
      case 164:
        return createDFDCompressed(0xDu, 6, 5, 1, 8);
      case 165:
        return createDFDCompressed(0xDu, 6, 6, 1, 0);
      case 166:
        return createDFDCompressed(0xDu, 6, 6, 1, 8);
      case 167:
        return createDFDCompressed(0xDu, 8, 5, 1, 0);
      case 168:
        return createDFDCompressed(0xDu, 8, 5, 1, 8);
      case 169:
        return createDFDCompressed(0xDu, 8, 6, 1, 0);
      case 170:
        return createDFDCompressed(0xDu, 8, 6, 1, 8);
      case 171:
        return createDFDCompressed(0xDu, 8, 8, 1, 0);
      case 172:
        return createDFDCompressed(0xDu, 8, 8, 1, 8);
      case 173:
        return createDFDCompressed(0xDu, 10, 5, 1, 0);
      case 174:
        return createDFDCompressed(0xDu, 10, 5, 1, 8);
      case 175:
        return createDFDCompressed(0xDu, 10, 6, 1, 0);
      case 176:
        return createDFDCompressed(0xDu, 10, 6, 1, 8);
      case 177:
        return createDFDCompressed(0xDu, 10, 8, 1, 0);
      case 178:
        return createDFDCompressed(0xDu, 10, 8, 1, 8);
      case 179:
        return createDFDCompressed(0xDu, 10, 10, 1, 0);
      case 180:
        return createDFDCompressed(0xDu, 10, 10, 1, 8);
      case 181:
        return createDFDCompressed(0xDu, 12, 10, 1, 0);
      case 182:
        return createDFDCompressed(0xDu, 12, 10, 1, 8);
      case 183:
        return createDFDCompressed(0xDu, 12, 12, 1, 0);
      case 184:
        return createDFDCompressed(0xDu, 12, 12, 1, 8);
      default:
        switch(a1)
        {
          case 1000066000:
            result = createDFDCompressed(0xDu, 4, 4, 1, 6);
            break;
          case 1000066001:
            result = createDFDCompressed(0xDu, 5, 4, 1, 6);
            break;
          case 1000066002:
            result = createDFDCompressed(0xDu, 5, 5, 1, 6);
            break;
          case 1000066003:
            result = createDFDCompressed(0xDu, 6, 5, 1, 6);
            break;
          case 1000066004:
            result = createDFDCompressed(0xDu, 6, 6, 1, 6);
            break;
          case 1000066005:
            result = createDFDCompressed(0xDu, 8, 5, 1, 6);
            break;
          case 1000066006:
            result = createDFDCompressed(0xDu, 8, 6, 1, 6);
            break;
          case 1000066007:
            result = createDFDCompressed(0xDu, 8, 8, 1, 6);
            break;
          case 1000066008:
            result = createDFDCompressed(0xDu, 10, 5, 1, 6);
            break;
          case 1000066009:
            result = createDFDCompressed(0xDu, 10, 6, 1, 6);
            break;
          case 1000066010:
            result = createDFDCompressed(0xDu, 10, 8, 1, 6);
            break;
          case 1000066011:
            result = createDFDCompressed(0xDu, 10, 10, 1, 6);
            break;
          case 1000066012:
            result = createDFDCompressed(0xDu, 12, 10, 1, 6);
            break;
          case 1000066013:
            result = createDFDCompressed(0xDu, 12, 12, 1, 6);
            break;
          default:
            switch(a1)
            {
              case 1000054000:
                v6 = 15;
                goto LABEL_266;
              case 1000054001:
                v6 = 15;
                goto LABEL_268;
              case 1000054002:
                v6 = 16;
LABEL_266:
                v7 = 8;
                v8 = 4;
                v9 = 1;
                v10 = 0;
                return createDFDCompressed(v6, v7, v8, v9, v10);
              case 1000054003:
                v6 = 16;
                goto LABEL_268;
              case 1000054004:
                v6 = 15;
                goto LABEL_272;
              case 1000054005:
                v6 = 15;
                goto LABEL_274;
              case 1000054006:
                v6 = 16;
LABEL_272:
                v7 = 8;
                v8 = 4;
                v9 = 1;
                v10 = 8;
                return createDFDCompressed(v6, v7, v8, v9, v10);
              case 1000054007:
                v6 = 16;
                goto LABEL_274;
              default:
                return result;
            }
        }
        return result;
    }
  }
  switch(a1)
  {
    case 1000288000:
      v6 = 13;
      v7 = 3;
      v8 = 3;
      v9 = 3;
      v10 = 0;
      return createDFDCompressed(v6, v7, v8, v9, v10);
    case 1000288001:
      return createDFDCompressed(0xDu, 3, 3, 3, 8);
    case 1000288002:
      return createDFDCompressed(0xDu, 3, 3, 3, 6);
    case 1000288003:
      return createDFDCompressed(0xDu, 4, 3, 3, 0);
    case 1000288004:
      return createDFDCompressed(0xDu, 4, 3, 3, 8);
    case 1000288005:
      return createDFDCompressed(0xDu, 4, 3, 3, 6);
    case 1000288006:
      return createDFDCompressed(0xDu, 4, 4, 3, 0);
    case 1000288007:
      return createDFDCompressed(0xDu, 4, 4, 3, 8);
    case 1000288008:
      return createDFDCompressed(0xDu, 4, 4, 3, 6);
    case 1000288009:
      return createDFDCompressed(0xDu, 4, 4, 4, 0);
    case 1000288010:
      return createDFDCompressed(0xDu, 4, 4, 4, 8);
    case 1000288011:
      return createDFDCompressed(0xDu, 4, 4, 4, 6);
    case 1000288012:
      return createDFDCompressed(0xDu, 5, 4, 4, 0);
    case 1000288013:
      return createDFDCompressed(0xDu, 5, 4, 4, 8);
    case 1000288014:
      return createDFDCompressed(0xDu, 5, 4, 4, 6);
    case 1000288015:
      return createDFDCompressed(0xDu, 5, 5, 4, 0);
    case 1000288016:
      return createDFDCompressed(0xDu, 5, 5, 4, 8);
    case 1000288017:
      return createDFDCompressed(0xDu, 5, 5, 4, 6);
    case 1000288018:
      return createDFDCompressed(0xDu, 5, 5, 5, 0);
    case 1000288019:
      return createDFDCompressed(0xDu, 5, 5, 5, 8);
    case 1000288020:
      return createDFDCompressed(0xDu, 5, 5, 5, 6);
    case 1000288021:
      return createDFDCompressed(0xDu, 6, 5, 5, 0);
    case 1000288022:
      return createDFDCompressed(0xDu, 6, 5, 5, 8);
    case 1000288023:
      return createDFDCompressed(0xDu, 6, 5, 5, 6);
    case 1000288024:
      return createDFDCompressed(0xDu, 6, 6, 5, 0);
    case 1000288025:
      return createDFDCompressed(0xDu, 6, 6, 5, 8);
    case 1000288026:
      return createDFDCompressed(0xDu, 6, 6, 5, 6);
    case 1000288027:
      return createDFDCompressed(0xDu, 6, 6, 6, 0);
    case 1000288028:
      return createDFDCompressed(0xDu, 6, 6, 6, 8);
    case 1000288029:
      return createDFDCompressed(0xDu, 6, 6, 6, 6);
    default:
      if (a1 == 1000340000)
      {
        v11 = &xmmword_18822B2D0;
      }
      else
      {
        if (a1 != 1000340001)
          return result;
        v11 = &xmmword_18820BF90;
      }
LABEL_47:
      v30 = *v11;
      v12 = &xmmword_18823DD10;
LABEL_113:
      v29 = *v12;
      v3 = &v29;
      v4 = &v30;
      v5 = 4;
LABEL_114:
      v20 = 0;
      return (char *)createDFDPacked(0, v5, (int32x4_t *)v3, (uint64_t)v4, v20);
  }
}

uint64_t ktxFileStream_construct(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t result;

  result = 11;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *(_QWORD *)(a1 + 64) = a2;
      *(_DWORD *)(a1 + 56) = 1;
      *(_QWORD *)a1 = ktxFileStream_read;
      *(_QWORD *)(a1 + 8) = ktxFileStream_skip;
      *(_QWORD *)(a1 + 16) = ktxFileStream_write;
      *(_QWORD *)(a1 + 24) = ktxFileStream_getpos;
      *(_QWORD *)(a1 + 32) = ktxFileStream_setpos;
      *(_QWORD *)(a1 + 40) = ktxFileStream_getsize;
      *(_QWORD *)(a1 + 48) = ktxFileStream_destruct;
      *(_QWORD *)(a1 + 88) = 0;
      *(_BYTE *)(a1 + 96) = a3;
    }
  }
  return result;
}

uint64_t ktxFileStream_read(uint64_t a1, void *__ptr, size_t a3)
{
  uint64_t result;

  result = 11;
  if (a1 && __ptr)
  {
    if (fread(__ptr, 1uLL, a3, *(FILE **)(a1 + 64)) == a3)
    {
      result = 0;
      *(_QWORD *)(a1 + 88) += a3;
    }
    else if (feof(*(FILE **)(a1 + 64)))
    {
      return 7;
    }
    else
    {
      return 5;
    }
  }
  return result;
}

uint64_t ktxFileStream_skip(uint64_t a1, unint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t result;

  if (!a1)
    return 11;
  if (a2)
  {
    v4 = 1;
    while (getc(*(FILE **)(a1 + 64)) != -1)
    {
      v5 = v4++;
      if (v5 >= a2)
        goto LABEL_6;
    }
    if (feof(*(FILE **)(a1 + 64)))
      return 7;
    else
      return 5;
  }
  else
  {
LABEL_6:
    result = 0;
    *(_QWORD *)(a1 + 88) += a2;
  }
  return result;
}

uint64_t ktxFileStream_write(uint64_t a1, void *__ptr, size_t __size, size_t __nitems)
{
  uint64_t v4;

  v4 = 11;
  if (!a1 || !__ptr)
    return v4;
  if (fwrite(__ptr, __size, __nitems, *(FILE **)(a1 + 64)) == __nitems)
    return 0;
  v4 = 4;
  if (*__error() == 27)
    return v4;
  if (*__error() == 84)
    return 4;
  else
    return 8;
}

uint64_t ktxFileStream_getpos(uint64_t a1, off_t *a2)
{
  uint64_t result;
  FILE *v5;
  off_t v6;
  int v7;

  result = 11;
  if (a1 && a2)
  {
    v5 = *(FILE **)(a1 + 64);
    if (v5 == (FILE *)*MEMORY[0x1E0C80C18])
    {
      v6 = *(_QWORD *)(a1 + 88);
    }
    else
    {
      v6 = ftello(v5);
      if (v6 < 0)
      {
        v7 = *__error();
        if (v7 == 29)
          return 2;
        if (v7 == 84)
          return 4;
      }
    }
    result = 0;
    *a2 = v6;
  }
  return result;
}

uint64_t ktxFileStream_setpos(uint64_t a1, off_t a2)
{
  uint64_t result;
  uint64_t v5;
  off_t v6;
  off_t v7;

  if (!a1)
    return 11;
  if (*(_QWORD *)(a1 + 64) == *MEMORY[0x1E0C80C18])
  {
    v5 = *(_QWORD *)(a1 + 88);
    v6 = a2 - v5;
    if (a2 <= v5)
      return 2;
    else
      return (*(uint64_t (**)(uint64_t, off_t))(a1 + 8))(a1, v6);
  }
  else
  {
    v7 = 0;
    result = (*(uint64_t (**)(uint64_t, off_t *))(a1 + 40))(a1, &v7);
    if (!(_DWORD)result)
    {
      if (v7 >= a2)
        return (fseeko(*(FILE **)(a1 + 64), a2, 0) >> 31) & 6;
      else
        return 10;
    }
  }
  return result;
}

uint64_t ktxFileStream_getsize(uint64_t a1, off_t *a2)
{
  uint64_t result;
  int v5;
  int v6;
  stat v7;

  result = 11;
  if (a1 && a2)
  {
    memset(&v7, 0, sizeof(v7));
    fflush(*(FILE **)(a1 + 64));
    v5 = fileno(*(FILE **)(a1 + 64));
    if (fstat(v5, &v7) < 0)
    {
      if (*__error() == 84)
        return 4;
      else
        return 5;
    }
    else
    {
      v6 = v7.st_mode & 0xF000;
      result = 2;
      if (v6 != 4096 && v6 != 49152)
      {
        if ((v7.st_mode & 0x2000) != 0)
        {
          return 10;
        }
        else
        {
          result = 0;
          *a2 = v7.st_size;
        }
      }
    }
  }
  return result;
}

uint64_t ktxFileStream_destruct(uint64_t result)
{
  uint64_t v1;

  v1 = result;
  if (*(_BYTE *)(result + 96))
    result = fclose(*(FILE **)(result + 64));
  *(_QWORD *)(v1 + 64) = 0;
  return result;
}

_QWORD *ktxHashList_Construct(_QWORD *result)
{
  *result = 0;
  return result;
}

_QWORD *ktxHashList_ConstructCopy(_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  *result = 0;
  if (a2)
  {
    v2 = a2;
    v3 = (uint64_t)result;
    do
    {
      result = (_QWORD *)ktxHashList_AddKVPair(v3, *(char **)(v2 + 8), *(_DWORD *)(v2 + 16), *(const void **)(v2 + 24));
      v2 = *(_QWORD *)(v2 + 48);
    }
    while (v2);
  }
  return result;
}

uint64_t ktxHashList_AddKVPair(uint64_t a1, char *__s, unsigned int a3, const void *a4)
{
  uint64_t result;
  int v9;
  size_t v10;
  char *v11;
  char *v12;
  char *v13;
  unsigned int v14;
  _DWORD *v15;
  _OWORD *v16;
  uint64_t v17;
  _OWORD *v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  _DWORD *v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  _QWORD *v57;
  int v58;
  uint64_t i;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;

  result = 11;
  if (a1 && __s && (!a3 || a4))
  {
    v9 = strlen(__s);
    if (!v9)
      return 11;
    v10 = (v9 + 1);
    v11 = (char *)malloc_type_malloc(a3 + v10 + 88, 0xAFB9C282uLL);
    v12 = v11 + 88;
    *((_QWORD *)v11 + 1) = v11 + 88;
    *(_DWORD *)v11 = v10;
    memcpy(v11 + 88, __s, v10);
    *((_DWORD *)v11 + 4) = a3;
    if (a3)
    {
      *((_QWORD *)v11 + 3) = &v12[v10];
      memcpy(&v12[v10], a4, a3);
      v12 = (char *)*((_QWORD *)v11 + 1);
      LODWORD(v10) = *(_DWORD *)v11;
    }
    else
    {
      *((_QWORD *)v11 + 3) = 0;
    }
    v13 = v11 + 32;
    *((_QWORD *)v11 + 6) = 0;
    *((_QWORD *)v11 + 9) = v12;
    v14 = v10 - 1;
    *((_DWORD *)v11 + 20) = v10 - 1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 24) + 16) = v11;
      *((_QWORD *)v11 + 5) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 24)
                           - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 32);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 24) = v13;
      v15 = *(_DWORD **)(*(_QWORD *)a1 + 32);
    }
    else
    {
      *(_QWORD *)a1 = v11;
      *((_QWORD *)v11 + 5) = 0;
      *(_QWORD *)(*(_QWORD *)a1 + 32) = malloc_type_malloc(0x40uLL, 0x10200405F856B24uLL);
      v16 = *(_OWORD **)(*(_QWORD *)a1 + 32);
      if (!v16)
        goto LABEL_56;
      v16[2] = 0u;
      v16[3] = 0u;
      *v16 = 0u;
      v16[1] = 0u;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 24) = *(_QWORD *)a1 + 32;
      v17 = *(_QWORD *)(*(_QWORD *)a1 + 32);
      *(_QWORD *)(v17 + 8) = 0x500000020;
      *(_QWORD *)(v17 + 32) = 32;
      **(_QWORD **)(*(_QWORD *)a1 + 32) = malloc_type_malloc(0x200uLL, 0x1020040EDED9539uLL);
      v18 = **(_OWORD ***)(*(_QWORD *)a1 + 32);
      if (!v18)
        goto LABEL_56;
      v18[30] = 0u;
      v18[31] = 0u;
      v18[28] = 0u;
      v18[29] = 0u;
      v18[26] = 0u;
      v18[27] = 0u;
      v18[24] = 0u;
      v18[25] = 0u;
      v18[22] = 0u;
      v18[23] = 0u;
      v18[20] = 0u;
      v18[21] = 0u;
      v18[18] = 0u;
      v18[19] = 0u;
      v18[16] = 0u;
      v18[17] = 0u;
      v18[14] = 0u;
      v18[15] = 0u;
      v18[12] = 0u;
      v18[13] = 0u;
      v18[10] = 0u;
      v18[11] = 0u;
      v18[8] = 0u;
      v18[9] = 0u;
      v18[6] = 0u;
      v18[7] = 0u;
      v18[4] = 0u;
      v18[5] = 0u;
      v18[2] = 0u;
      v18[3] = 0u;
      *v18 = 0u;
      v18[1] = 0u;
      v15 = *(_DWORD **)(*(_QWORD *)a1 + 32);
      v15[14] = -1609490463;
      v14 = *(_DWORD *)v11 - 1;
      v12 = (char *)*((_QWORD *)v11 + 1);
    }
    v19 = -17973521;
    v20 = -1640531527;
    ++v15[4];
    *((_QWORD *)v11 + 4) = v15;
    *((_DWORD *)v11 + 21) = -17973521;
    if (v14 < 0xC)
    {
      v22 = -1640531527;
      v21 = v14;
    }
    else
    {
      v21 = v14;
      v22 = -1640531527;
      do
      {
        v23 = v20 + v12[4] + (v12[5] << 8) + (v12[6] << 16) + (v12[7] << 24);
        v24 = v12[8] + (v12[9] << 8) + (v12[10] << 16) + v19 + (v12[11] << 24);
        v25 = (v22 + *v12 + (v12[1] << 8) + (v12[2] << 16) + (v12[3] << 24) - (v23 + v24)) ^ (v24 >> 13);
        v26 = (v23 - v24 - v25) ^ (v25 << 8);
        v27 = (v24 - v25 - v26) ^ (v26 >> 13);
        v28 = (v25 - v26 - v27) ^ (v27 >> 12);
        v29 = (v26 - v27 - v28) ^ (v28 << 16);
        v30 = (v27 - v28 - v29) ^ (v29 >> 5);
        v22 = (v28 - v29 - v30) ^ (v30 >> 3);
        v20 = (v29 - v30 - v22) ^ (v22 << 10);
        v19 = (v30 - v22 - v20) ^ (v20 >> 15);
        *((_DWORD *)v11 + 21) = v19;
        v12 += 12;
        v21 -= 12;
      }
      while (v21 > 0xB);
    }
    v31 = v19 + v14;
    *((_DWORD *)v11 + 21) = v31;
    switch(v21)
    {
      case 1u:
        goto LABEL_32;
      case 2u:
        goto LABEL_31;
      case 3u:
        goto LABEL_30;
      case 4u:
        goto LABEL_29;
      case 5u:
        goto LABEL_28;
      case 6u:
        goto LABEL_27;
      case 7u:
        goto LABEL_26;
      case 8u:
        goto LABEL_25;
      case 9u:
        goto LABEL_24;
      case 0xAu:
        goto LABEL_23;
      case 0xBu:
        v31 += v12[10] << 24;
        *((_DWORD *)v11 + 21) = v31;
LABEL_23:
        v31 += v12[9] << 16;
        *((_DWORD *)v11 + 21) = v31;
LABEL_24:
        v31 += v12[8] << 8;
        *((_DWORD *)v11 + 21) = v31;
LABEL_25:
        v20 += v12[7] << 24;
LABEL_26:
        v20 += v12[6] << 16;
LABEL_27:
        v20 += v12[5] << 8;
LABEL_28:
        v20 += v12[4];
LABEL_29:
        v22 += v12[3] << 24;
LABEL_30:
        v22 += v12[2] << 16;
LABEL_31:
        v22 += v12[1] << 8;
LABEL_32:
        v22 += *v12;
        break;
      default:
        break;
    }
    v32 = (v22 - v20 - v31) ^ (v31 >> 13);
    v33 = (v20 - v31 - v32) ^ (v32 << 8);
    v34 = (v31 - v32 - v33) ^ (v33 >> 13);
    v35 = (v32 - v33 - v34) ^ (v34 >> 12);
    v36 = (v33 - v34 - v35) ^ (v35 << 16);
    v37 = (v34 - v35 - v36) ^ (v36 >> 5);
    v38 = (v35 - v36 - v37) ^ (v37 >> 3);
    v39 = (v37 - v38 - ((v36 - v37 - v38) ^ (v38 << 10))) ^ (((v36 - v37 - v38) ^ (v38 << 10)) >> 15);
    *((_DWORD *)v11 + 21) = v39;
    v40 = *(_QWORD *)(*(_QWORD *)a1 + 32);
    v41 = v39 & (*(_DWORD *)(v40 + 8) - 1);
    v42 = 16 * v41;
    v43 = *(_QWORD *)v40 + v42;
    ++*(_DWORD *)(v43 + 8);
    v44 = *(_QWORD *)v43;
    *((_QWORD *)v11 + 7) = 0;
    *((_QWORD *)v11 + 8) = v44;
    v45 = **(_QWORD **)(*(_QWORD *)a1 + 32);
    v46 = *(_QWORD *)(v45 + v42);
    if (v46)
    {
      *(_QWORD *)(v46 + 24) = v13;
      v45 = **(_QWORD **)(*(_QWORD *)a1 + 32);
    }
    v47 = 16 * v41;
    *(_QWORD *)(v45 + v47) = v13;
    v48 = **(_QWORD **)(*(_QWORD *)a1 + 32) + v47;
    if (*(_DWORD *)(v48 + 8) < (10 * *(_DWORD *)(v48 + 12) + 10) || v15[13] == 1)
      return 0;
    v49 = malloc_type_malloc(16 * (2 * v15[2]), 0x1020040EDED9539uLL);
    if (v49)
    {
      v50 = v49;
      bzero(v49, 16 * (2 * *(_DWORD *)(*(_QWORD *)v13 + 8)));
      v51 = *(_QWORD *)v13;
      v52 = *(_DWORD *)(*(_QWORD *)v13 + 16);
      v53 = *(unsigned int *)(*(_QWORD *)v13 + 8);
      v54 = *(_DWORD *)(*(_QWORD *)v13 + 12) + 1;
      v55 = 2 * v53 - 1;
      if ((v55 & v52) != 0)
        v56 = (v52 >> (*(_BYTE *)(*(_QWORD *)v13 + 12) + 1)) + 1;
      else
        v56 = v52 >> (*(_BYTE *)(*(_QWORD *)v13 + 12) + 1);
      *(_DWORD *)(v51 + 40) = v56;
      *(_DWORD *)(v51 + 44) = 0;
      v57 = *(_QWORD **)v51;
      if ((_DWORD)v53)
      {
        v58 = 0;
        for (i = 0; i != v53; ++i)
        {
          v60 = v57[2 * i];
          if (v60)
          {
            do
            {
              v61 = *(_QWORD *)(v60 + 32);
              v62 = *(_DWORD *)(v60 + 52) & v55;
              v63 = (char *)&v50[4 * v62];
              v64 = *((_DWORD *)v63 + 2) + 1;
              *((_DWORD *)v63 + 2) = v64;
              if (v64 > v56)
              {
                *(_DWORD *)(v51 + 44) = ++v58;
                v50[4 * v62 + 3] = v64 / v56;
              }
              v65 = *(_QWORD *)v63;
              *(_QWORD *)(v60 + 24) = 0;
              *(_QWORD *)(v60 + 32) = v65;
              if (v65)
                *(_QWORD *)(v65 + 24) = v60;
              *(_QWORD *)v63 = v60;
              v60 = v61;
            }
            while (v61);
          }
        }
      }
      *(_DWORD *)(v51 + 8) = 2 * v53;
      *(_DWORD *)(v51 + 12) = v54;
      free(v57);
      v66 = *(_QWORD *)v13;
      *(_QWORD *)v66 = v50;
      if (*(_DWORD *)(v66 + 44) <= *(_DWORD *)(v66 + 16) >> 1)
      {
        result = 0;
        *(_DWORD *)(v66 + 48) = 0;
        return result;
      }
      v67 = *(_DWORD *)(v66 + 48) + 1;
      *(_DWORD *)(v66 + 48) = v67;
      if (v67 >= 2)
      {
        result = 0;
        *(_DWORD *)(v66 + 52) = 1;
        return result;
      }
      return 0;
    }
LABEL_56:
    exit(-1);
  }
  return result;
}

uint64_t ktxHashList_Next(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 48);
  return result;
}

void ktxHashList_Destruct(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v1 = *a1;
  if (*a1)
  {
    v2 = *a1;
    while (1)
    {
      v3 = *(_QWORD *)(v2 + 40);
      v4 = *(_QWORD *)(v2 + 48);
      v5 = *(_QWORD *)(v1 + 32);
      if (*(_OWORD *)(v2 + 40) == 0)
      {
        free(*(void **)v5);
        free(*(void **)(v1 + 32));
        free((void *)v2);
        return;
      }
      v6 = *(_QWORD *)(v5 + 32);
      if (v2 != *(_QWORD *)(v5 + 24) - v6)
        break;
      *(_QWORD *)(v5 + 24) = v3 + v6;
      v7 = v4;
      if (v3)
        goto LABEL_7;
LABEL_8:
      v8 = *(_QWORD *)(v2 + 48);
      v9 = *(_QWORD *)(v7 + 32);
      if (v8)
        *(_QWORD *)(v8 + *(_QWORD *)(v9 + 32) + 8) = v3;
      v10 = *(_QWORD *)v9 + 16 * ((*(_DWORD *)(v9 + 8) - 1) & *(_DWORD *)(v2 + 84));
      --*(_DWORD *)(v10 + 8);
      if (*(_QWORD *)v10 == v2 + 32)
      {
        *(_QWORD *)v10 = *(_QWORD *)(v2 + 64);
        v11 = *(_QWORD *)(v2 + 56);
        if (!v11)
          goto LABEL_13;
LABEL_12:
        *(_QWORD *)(v11 + 32) = *(_QWORD *)(v2 + 64);
        goto LABEL_13;
      }
      v11 = *(_QWORD *)(v2 + 56);
      if (v11)
        goto LABEL_12;
LABEL_13:
      v12 = *(_QWORD *)(v2 + 64);
      if (v12)
        *(_QWORD *)(v12 + 24) = v11;
      --*(_DWORD *)(v9 + 16);
      free((void *)v2);
      v1 = v7;
      v2 = v4;
      if (!v4)
        return;
    }
    v7 = *(_QWORD *)(v2 + 48);
    if (!v3)
      goto LABEL_8;
LABEL_7:
    *(_QWORD *)(v3 + v6 + 16) = v4;
    v7 = v1;
    goto LABEL_8;
  }
}

uint64_t ktxHashList_Create(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t result;

  v2 = malloc_type_malloc(8uLL, 0x2004093837F09uLL);
  if (!v2)
    return 13;
  v3 = v2;
  result = 0;
  *v3 = 0;
  *a1 = v3;
  return result;
}

uint64_t ktxHashList_CreateCopy(uint64_t *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t result;

  v4 = malloc_type_malloc(8uLL, 0x2004093837F09uLL);
  if (!v4)
    return 13;
  v5 = (uint64_t)v4;
  for (*v4 = 0; a2; a2 = *(_QWORD *)(a2 + 48))
    ktxHashList_AddKVPair(v5, *(char **)(a2 + 8), *(_DWORD *)(a2 + 16), *(const void **)(a2 + 24));
  result = 0;
  *a1 = v5;
  return result;
}

void ktxHashList_Destroy(uint64_t *a1)
{
  ktxHashList_Destruct(a1);
  free(a1);
}

uint64_t ktxHashList_DeleteKVPair(uint64_t *a1, char *__s)
{
  uint64_t result;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  char *v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  result = 11;
  if (!a1 || !__s)
    return result;
  if (!*a1)
    return 0;
  v5 = -17973521;
  v6 = -1640531527;
  v7 = strlen(__s);
  v8 = v7;
  if (v7 < 0xC)
  {
    v11 = -1640531527;
    v10 = v7;
    v9 = __s;
  }
  else
  {
    v9 = __s;
    v10 = v7;
    v11 = -1640531527;
    do
    {
      v12 = v6 + v9[4] + (v9[5] << 8) + (v9[6] << 16) + (v9[7] << 24);
      v13 = v5 + v9[8] + (v9[9] << 8) + (v9[10] << 16) + (v9[11] << 24);
      v14 = (v11 + *v9 + (v9[1] << 8) + (v9[2] << 16) + (v9[3] << 24) - (v12 + v13)) ^ (v13 >> 13);
      v15 = (v12 - v13 - v14) ^ (v14 << 8);
      v16 = (v13 - v14 - v15) ^ (v15 >> 13);
      v17 = (v14 - v15 - v16) ^ (v16 >> 12);
      v18 = (v15 - v16 - v17) ^ (v17 << 16);
      v19 = (v16 - v17 - v18) ^ (v18 >> 5);
      v11 = (v17 - v18 - v19) ^ (v19 >> 3);
      v6 = (v18 - v19 - v11) ^ (v11 << 10);
      v5 = (v19 - v11 - v6) ^ (v6 >> 15);
      v9 += 12;
      v10 -= 12;
    }
    while (v10 > 0xB);
  }
  v20 = v5 + v7;
  switch(v10)
  {
    case 1u:
      goto LABEL_22;
    case 2u:
      goto LABEL_21;
    case 3u:
      goto LABEL_20;
    case 4u:
      goto LABEL_19;
    case 5u:
      goto LABEL_18;
    case 6u:
      goto LABEL_17;
    case 7u:
      goto LABEL_16;
    case 8u:
      goto LABEL_15;
    case 9u:
      goto LABEL_14;
    case 0xAu:
      goto LABEL_13;
    case 0xBu:
      v20 += v9[10] << 24;
LABEL_13:
      v20 += v9[9] << 16;
LABEL_14:
      v20 += v9[8] << 8;
LABEL_15:
      v6 += v9[7] << 24;
LABEL_16:
      v6 += v9[6] << 16;
LABEL_17:
      v6 += v9[5] << 8;
LABEL_18:
      v6 += v9[4];
LABEL_19:
      v11 += v9[3] << 24;
LABEL_20:
      v11 += v9[2] << 16;
LABEL_21:
      v11 += v9[1] << 8;
LABEL_22:
      v11 += *v9;
      break;
    default:
      break;
  }
  v21 = (v11 - v20 - v6) ^ (v20 >> 13);
  v22 = (v6 - v20 - v21) ^ (v21 << 8);
  v23 = (v20 - v21 - v22) ^ (v22 >> 13);
  v24 = (v21 - v22 - v23) ^ (v23 >> 12);
  v25 = (v22 - v23 - v24) ^ (v24 << 16);
  v26 = (v23 - v24 - v25) ^ (v25 >> 5);
  v27 = (v24 - v25 - v26) ^ (v26 >> 3);
  v28 = *(_QWORD *)(*a1 + 32);
  v29 = *(void **)v28;
  v30 = *(_QWORD *)(*(_QWORD *)v28
                  + 16
                  * (((v26 - v27 - ((v25 - v26 - v27) ^ (v27 << 10))) ^ (((v25 - v26 - v27) ^ (v27 << 10)) >> 15)) & (*(_DWORD *)(v28 + 8) - 1)));
  if (!v30)
    return 0;
  v31 = v30 - *(_QWORD *)(v28 + 32);
  if (*(_DWORD *)(v31 + 80) != v7)
    goto LABEL_28;
LABEL_27:
  if (memcmp(*(const void **)(v31 + 72), __s, v8))
  {
LABEL_28:
    while (1)
    {
      v32 = *(_QWORD *)(v31 + 64);
      if (!v32)
        return 0;
      v31 = v32 - *(_QWORD *)(v28 + 32);
      if (*(_DWORD *)(v31 + 80) == v8)
        goto LABEL_27;
    }
  }
  v33 = *(_QWORD *)(v31 + 40);
  if (!v33 && !*(_QWORD *)(v31 + 48))
  {
    free(v29);
    free(*(void **)(*a1 + 32));
    result = 0;
    *a1 = 0;
    return result;
  }
  v34 = *(_QWORD *)(v28 + 32);
  if (v31 == *(_QWORD *)(v28 + 24) - v34)
    *(_QWORD *)(v28 + 24) = v33 + v34;
  v35 = *(_QWORD *)(v31 + 48);
  if (!v33)
  {
    *a1 = v35;
    v36 = v31 + 32;
    v37 = *(_QWORD *)(v31 + 48);
    if (!v37)
      goto LABEL_37;
    goto LABEL_36;
  }
  *(_QWORD *)(v33 + *(_QWORD *)(*(_QWORD *)(*a1 + 32) + 32) + 16) = v35;
  v35 = *a1;
  v36 = v31 + 32;
  v37 = *(_QWORD *)(v31 + 48);
  if (v37)
  {
LABEL_36:
    *(_QWORD *)(v37 + *(_QWORD *)(*(_QWORD *)(v35 + 32) + 32) + 8) = *(_QWORD *)(v31 + 40);
    v35 = *a1;
  }
LABEL_37:
  v38 = **(_QWORD **)(v35 + 32)
      + 16 * ((*(_DWORD *)(*(_QWORD *)(v35 + 32) + 8) - 1) & *(_DWORD *)(v31 + 84));
  --*(_DWORD *)(v38 + 8);
  if (*(_QWORD *)v38 == v36)
    *(_QWORD *)v38 = *(_QWORD *)(v31 + 64);
  v39 = *(_QWORD *)(v31 + 56);
  if (v39)
    *(_QWORD *)(v39 + 32) = *(_QWORD *)(v31 + 64);
  v40 = *(_QWORD *)(v31 + 64);
  if (v40)
    *(_QWORD *)(v40 + 24) = v39;
  result = 0;
  --*(_DWORD *)(*(_QWORD *)(*a1 + 32) + 16);
  return result;
}

uint64_t ktxHashList_DeleteEntry(uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  result = 11;
  if (!a1 || !a2)
    return result;
  v4 = *(_QWORD *)(a2 + 40);
  if (!v4 && !*(_QWORD *)(a2 + 48))
  {
    free(**(void ***)(*a1 + 32));
    free(*(void **)(*a1 + 32));
    result = 0;
    *a1 = 0;
    return result;
  }
  v5 = *(_QWORD *)(*a1 + 32);
  v6 = *(_QWORD *)(v5 + 32);
  if (*(_QWORD *)(v5 + 24) - v6 != a2)
  {
    v7 = *(_QWORD *)(a2 + 48);
    if (v4)
      goto LABEL_7;
LABEL_18:
    *a1 = v7;
    v8 = a2 + 32;
    v9 = *(_QWORD *)(a2 + 48);
    if (!v9)
      goto LABEL_9;
    goto LABEL_8;
  }
  *(_QWORD *)(v5 + 24) = v4 + v6;
  v7 = *(_QWORD *)(a2 + 48);
  if (!v4)
    goto LABEL_18;
LABEL_7:
  *(_QWORD *)(v4 + *(_QWORD *)(*(_QWORD *)(*a1 + 32) + 32) + 16) = v7;
  v7 = *a1;
  v8 = a2 + 32;
  v9 = *(_QWORD *)(a2 + 48);
  if (v9)
  {
LABEL_8:
    *(_QWORD *)(v9 + *(_QWORD *)(*(_QWORD *)(v7 + 32) + 32) + 8) = *(_QWORD *)(a2 + 40);
    v7 = *a1;
  }
LABEL_9:
  v10 = **(_QWORD **)(v7 + 32)
      + 16 * ((*(_DWORD *)(*(_QWORD *)(v7 + 32) + 8) - 1) & *(_DWORD *)(a2 + 84));
  --*(_DWORD *)(v10 + 8);
  if (*(_QWORD *)v10 == v8)
    *(_QWORD *)v10 = *(_QWORD *)(a2 + 64);
  v11 = *(_QWORD *)(a2 + 56);
  if (v11)
    *(_QWORD *)(v11 + 32) = *(_QWORD *)(a2 + 64);
  v12 = *(_QWORD *)(a2 + 64);
  if (v12)
    *(_QWORD *)(v12 + 24) = v11;
  result = 0;
  --*(_DWORD *)(*(_QWORD *)(*a1 + 32) + 16);
  return result;
}

uint64_t ktxHashList_FindEntry(uint64_t *a1, char *__s, _QWORD *a3)
{
  uint64_t result;
  uint64_t v6;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  char *v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  result = 11;
  if (a1 && __s)
  {
    v6 = *a1;
    if (*a1)
    {
      v8 = -17973521;
      v9 = -1640531527;
      v10 = strlen(__s);
      v11 = v10;
      if (v10 < 0xC)
      {
        v14 = -1640531527;
        v13 = v10;
        v12 = __s;
      }
      else
      {
        v12 = __s;
        v13 = v10;
        v14 = -1640531527;
        do
        {
          v15 = v9 + v12[4] + (v12[5] << 8) + (v12[6] << 16) + (v12[7] << 24);
          v16 = v8 + v12[8] + (v12[9] << 8) + (v12[10] << 16) + (v12[11] << 24);
          v17 = (v14 + *v12 + (v12[1] << 8) + (v12[2] << 16) + (v12[3] << 24) - (v15 + v16)) ^ (v16 >> 13);
          v18 = (v15 - v16 - v17) ^ (v17 << 8);
          v19 = (v16 - v17 - v18) ^ (v18 >> 13);
          v20 = (v17 - v18 - v19) ^ (v19 >> 12);
          v21 = (v18 - v19 - v20) ^ (v20 << 16);
          v22 = (v19 - v20 - v21) ^ (v21 >> 5);
          v14 = (v20 - v21 - v22) ^ (v22 >> 3);
          v9 = (v21 - v22 - v14) ^ (v14 << 10);
          v8 = (v22 - v14 - v9) ^ (v9 >> 15);
          v12 += 12;
          v13 -= 12;
        }
        while (v13 > 0xB);
      }
      v23 = v8 + v10;
      switch(v13)
      {
        case 1u:
          goto LABEL_20;
        case 2u:
          goto LABEL_19;
        case 3u:
          goto LABEL_18;
        case 4u:
          goto LABEL_17;
        case 5u:
          goto LABEL_16;
        case 6u:
          goto LABEL_15;
        case 7u:
          goto LABEL_14;
        case 8u:
          goto LABEL_13;
        case 9u:
          goto LABEL_12;
        case 0xAu:
          goto LABEL_11;
        case 0xBu:
          v23 += v12[10] << 24;
LABEL_11:
          v23 += v12[9] << 16;
LABEL_12:
          v23 += v12[8] << 8;
LABEL_13:
          v9 += v12[7] << 24;
LABEL_14:
          v9 += v12[6] << 16;
LABEL_15:
          v9 += v12[5] << 8;
LABEL_16:
          v9 += v12[4];
LABEL_17:
          v14 += v12[3] << 24;
LABEL_18:
          v14 += v12[2] << 16;
LABEL_19:
          v14 += v12[1] << 8;
LABEL_20:
          v14 += *v12;
          break;
        default:
          break;
      }
      v24 = (v14 - v23 - v9) ^ (v23 >> 13);
      v25 = (v9 - v23 - v24) ^ (v24 << 8);
      v26 = (v23 - v24 - v25) ^ (v25 >> 13);
      v27 = (v24 - v25 - v26) ^ (v26 >> 12);
      v28 = (v25 - v26 - v27) ^ (v27 << 16);
      v29 = (v26 - v27 - v28) ^ (v28 >> 5);
      v30 = (v27 - v28 - v29) ^ (v29 >> 3);
      v31 = *(_QWORD *)(v6 + 32);
      v32 = *(_QWORD *)(*(_QWORD *)v31
                      + 16
                      * (((v29 - v30 - ((v28 - v29 - v30) ^ (v30 << 10))) ^ (((v28 - v29 - v30) ^ (v30 << 10)) >> 15)) & (*(_DWORD *)(v31 + 8) - 1)));
      if (v32)
      {
        v33 = v32 - *(_QWORD *)(v31 + 32);
        if (*(_DWORD *)(v33 + 80) != v10)
          goto LABEL_26;
LABEL_25:
        result = memcmp(*(const void **)(v33 + 72), __s, v11);
        if (!(_DWORD)result)
        {
          *a3 = v33;
          return result;
        }
LABEL_26:
        while (1)
        {
          v34 = *(_QWORD *)(v33 + 64);
          if (!v34)
            break;
          v33 = v34 - *(_QWORD *)(v31 + 32);
          if (*(_DWORD *)(v33 + 80) == v11)
            goto LABEL_25;
        }
      }
    }
    return 12;
  }
  return result;
}

uint64_t ktxHashList_FindValue(uint64_t *a1, char *a2, _DWORD *a3, _QWORD *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = 11;
  if (a3)
  {
    if (a4)
    {
      v10 = 0;
      result = ktxHashList_FindEntry(a1, a2, &v10);
      if (!(_DWORD)result)
      {
        v8 = v10;
        *a3 = *(_DWORD *)(v10 + 16);
        if (*(_DWORD *)(v8 + 16))
          v9 = *(_QWORD *)(v8 + 24);
        else
          v9 = 0;
        *a4 = v9;
      }
    }
  }
  return result;
}

uint64_t ktxHashListEntry_GetValue(uint64_t a1, _DWORD *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v5;

  result = 11;
  if (a2 && a3)
  {
    *a2 = *(_DWORD *)(a1 + 16);
    if (*(_DWORD *)(a1 + 16))
      v5 = *(_QWORD *)(a1 + 24);
    else
      v5 = 0;
    result = 0;
    *a3 = v5;
  }
  return result;
}

uint64_t ktxHashList_Serialize(unsigned int **a1, _DWORD *a2, unsigned int **a3)
{
  uint64_t result;
  unsigned int *v7;
  size_t v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int *i;
  uint64_t v12;
  char *v13;
  size_t v14;
  unsigned int v15;
  char *v16;
  uint64_t v17;
  char *v18;
  size_t v19;
  int __src;

  result = 11;
  if (a1 && a2 && a3)
  {
    __src = 0;
    v7 = *a1;
    if (!*a1)
      goto LABEL_15;
    LODWORD(v8) = 0;
    do
    {
      v8 = v8 + vcvts_n_u32_f32(ceilf((float)(*v7 + v7[4] + 4) * 0.25), 2uLL);
      v7 = (unsigned int *)*((_QWORD *)v7 + 6);
    }
    while (v7);
    if ((_DWORD)v8)
    {
      v9 = (unsigned int *)malloc_type_malloc(v8, 0x9EDD8534uLL);
      if (v9)
      {
        v10 = v9;
        *a2 = v8;
        *a3 = v9;
        for (i = *a1; i; i = (unsigned int *)*((_QWORD *)i + 6))
        {
          v15 = i[4] + *i;
          *v10 = v15;
          v16 = (char *)(v10 + 1);
          memcpy(v16, *((const void **)i + 1), *i);
          v17 = *i;
          v18 = &v16[v17];
          v19 = i[4];
          if ((_DWORD)v19)
          {
            memcpy(&v16[v17], *((const void **)i + 3), v19);
            v12 = i[4];
          }
          else
          {
            v12 = 0;
          }
          v13 = &v18[v12];
          v14 = (int)(float)-(float)((float)v15 - (float)(ceilf((float)v15 * 0.25) * 4.0));
          memcpy(v13, &__src, v14);
          v10 = (unsigned int *)&v13[v14];
        }
        return 0;
      }
      else
      {
        return 13;
      }
    }
    else
    {
LABEL_15:
      result = 0;
      *a2 = 0;
      *a3 = 0;
    }
  }
  return result;
}

uint64_t sort_by_key_codepoint(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8));
}

uint64_t ktxHashList_Sort(uint64_t a1)
{
  uint64_t v2;
  int i;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  BOOL v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;

  if (!a1)
    return 11;
  if (*(_QWORD *)a1)
  {
    v2 = *(_QWORD *)a1 + 32;
    for (i = 1; ; i *= 2)
    {
      v4 = 0;
      v5 = 0;
      v6 = v2;
      v2 = 0;
      do
      {
        v7 = 0;
        v8 = v6;
        if (i)
        {
          while (1)
          {
            ++v7;
            v9 = *(_QWORD *)(v8 + 16);
            if (!v9)
              break;
            v8 = v9 + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 32);
            if (i == v7)
            {
              v7 = i;
              goto LABEL_12;
            }
          }
          v8 = 0;
        }
LABEL_12:
        ++v5;
        v10 = i;
        while (1)
        {
          v12 = !v10 || v8 == 0;
          v13 = !v12;
          if (!v7)
            break;
          if (!v13)
          {
            v19 = *(_QWORD *)(v6 + 16);
            if (v19)
              v16 = v19 + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 32);
            else
              v16 = 0;
LABEL_40:
            --v7;
            v17 = v8;
            v18 = v6;
            if (v4)
              goto LABEL_13;
            goto LABEL_41;
          }
          v14 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 32);
          if (strcmp(*(const char **)(v6 - v14 + 8), *(const char **)(v8 - v14 + 8)) <= 0)
          {
            v15 = *(_QWORD *)(v6 + 16);
            v16 = v15 + v14;
            if (!v15)
              v16 = 0;
            goto LABEL_40;
          }
          v20 = *(_QWORD *)(v8 + 16);
          if (v20)
            v17 = v20 + v14;
          else
            v17 = 0;
          --v10;
          v16 = v6;
          v18 = v8;
          if (v4)
            goto LABEL_13;
LABEL_41:
          v11 = 0;
          v2 = v18;
LABEL_14:
          *(_QWORD *)(v18 + 8) = v11;
          v6 = v16;
          v8 = v17;
          v4 = v18;
        }
        if (v13)
        {
          v17 = *(_QWORD *)(v8 + 16);
          if (v17)
            v17 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 32);
          v7 = 0;
          --v10;
          v16 = v6;
          v18 = v8;
          if (v4)
          {
LABEL_13:
            *(_QWORD *)(v4 + 16) = v18 - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 32);
            v11 = v4 - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 32);
            goto LABEL_14;
          }
          goto LABEL_41;
        }
        v6 = v8;
      }
      while (v8);
      *(_QWORD *)(v4 + 16) = 0;
      if (v5 <= 1)
      {
        result = 0;
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 24) = v4;
        *(_QWORD *)a1 = v2 - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 32) + 32);
        return result;
      }
    }
  }
  return 0;
}

uint64_t ktxHashList_Deserialize(_QWORD *a1, int a2, char *a3)
{
  uint64_t result;
  int v6;
  unint64_t v7;
  char *v8;
  unsigned int v9;
  char *v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v15;

  result = 11;
  if (a1)
  {
    if (a2)
    {
      v6 = (int)a3;
      if (a3)
      {
        if (*a1)
        {
          return 10;
        }
        else
        {
          v7 = (unint64_t)&a3[a2];
          v8 = a3;
          while ((v6 - (_DWORD)v8 + a2) >= 4)
          {
            v9 = *(_DWORD *)v8;
            if (*(_DWORD *)v8 < 2u)
              break;
            v10 = v8 + 4;
            v11 = v6 - ((_DWORD)v8 + 4);
            v12 = v11 + a2;
            if (v9 > v11 + a2)
              break;
            v13 = strnlen(v10, (v11 + a2)) + 1;
            if (v13 >= v12 || v9 <= v13)
              break;
            result = ktxHashList_AddKVPair((uint64_t)a1, v10, v9 - v13, &v10[v13]);
            if ((_DWORD)result)
              return result;
            LODWORD(v15) = vcvts_n_u32_f32(ceilf((float)v9 * 0.25), 2uLL);
            v8 = &v10[v15];
            if ((unint64_t)v8 >= v7)
              return 0;
          }
          return 11;
        }
      }
    }
  }
  return result;
}

uint64_t ktxHashListEntry_GetKey(uint64_t a1, _DWORD *a2, _QWORD *a3)
{
  uint64_t result;

  result = 11;
  if (a2)
  {
    if (a3)
    {
      result = 0;
      *a2 = *(_DWORD *)a1;
      *a3 = *(_QWORD *)(a1 + 8);
    }
  }
  return result;
}

uint64_t ktxMemStream_getdata(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = 11;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
    }
  }
  return result;
}

uint64_t ktxMemStream_setup(uint64_t result)
{
  *(_DWORD *)(result + 56) = 2;
  *(_QWORD *)result = ktxMemStream_read;
  *(_QWORD *)(result + 8) = ktxMemStream_skip;
  *(_QWORD *)(result + 16) = ktxMemStream_write;
  *(_QWORD *)(result + 24) = ktxMemStream_getpos;
  *(_QWORD *)(result + 32) = ktxMemStream_setpos;
  *(_QWORD *)(result + 40) = ktxMemStream_getsize;
  *(_QWORD *)(result + 48) = ktxMemStream_destruct;
  return result;
}

uint64_t ktxMemStream_read(uint64_t a1, void *__dst, size_t a3)
{
  uint64_t *v3;
  int64_t v4;
  size_t v5;
  uint64_t result;
  uint64_t v7;

  if (!a1)
    return 11;
  v3 = *(uint64_t **)(a1 + 64);
  if (!v3)
    return 11;
  v4 = v3[4];
  v5 = v4 + a3;
  if ((uint64_t)(v4 + a3) < v4)
    return 7;
  if (v3[3] < (unint64_t)v5)
    return 7;
  v7 = *v3;
  if (!*v3)
    v7 = v3[1];
  memcpy(__dst, (const void *)(v7 + v4), a3);
  result = 0;
  v3[4] = v5;
  return result;
}

uint64_t ktxMemStream_skip(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  if (!a1)
    return 11;
  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
    return 11;
  v3 = *(_QWORD *)(v2 + 32);
  v4 = v3 + a2;
  if (v3 + a2 < v3)
    return 7;
  if (*(_QWORD *)(v2 + 24) < (unint64_t)v4)
    return 7;
  result = 0;
  *(_QWORD *)(v2 + 32) = v4;
  return result;
}

uint64_t ktxMemStream_write(uint64_t a1, void *__src, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t result;
  int64_t v6;
  size_t v7;
  unint64_t v8;
  unint64_t v10;
  int64_t v11;
  BOOL v12;
  unint64_t v13;
  void *v14;
  void *v15;
  int64_t v16;
  int64_t v17;

  if (!a1)
    return 11;
  v4 = *(_QWORD **)(a1 + 64);
  if (!v4)
    return 11;
  if (*v4)
    return 10;
  v6 = v4[4];
  v7 = a4 * a3;
  v8 = v6 + a4 * a3;
  if ((uint64_t)v8 < v6)
    return 4;
  v10 = v4[2];
  if (v10 < v8)
  {
    if (v10)
      v11 = v4[2];
    else
      v11 = 256;
    if (v11 < v8)
    {
      do
      {
        v12 = v11 < 0;
        v11 *= 2;
        if (v12)
          v13 = -1;
        else
          v13 = v11;
      }
      while (v13 < v8);
      v11 = v13;
    }
    if (v11 != v10)
    {
      v14 = (void *)v4[1];
      if (v14)
        v15 = malloc_type_realloc(v14, v11, 0xA652DA65uLL);
      else
        v15 = malloc_type_malloc(v11, 0x96CBAE37uLL);
      v4[1] = v15;
      if (!v15)
      {
        v4[2] = 0;
        v4[3] = 0;
        return 13;
      }
      v4[2] = v11;
      v6 = v4[4];
    }
  }
  memcpy((void *)(v4[1] + v6), __src, v7);
  v16 = v4[3];
  v17 = v4[4] + v7;
  v4[4] = v17;
  result = 0;
  if (v17 > v16)
    v4[3] = v17;
  return result;
}

uint64_t ktxMemStream_getpos(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = 11;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 32);
    }
  }
  return result;
}

uint64_t ktxMemStream_setpos(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  if (!a1)
    return 11;
  v2 = *(_QWORD *)(a1 + 64);
  if (*(_QWORD *)(v2 + 16) < a2)
    return 10;
  result = 0;
  *(_QWORD *)(v2 + 32) = a2;
  return result;
}

uint64_t ktxMemStream_getsize(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = 11;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 24);
    }
  }
  return result;
}

void ktxMemStream_destruct(uint64_t a1)
{
  void **v2;

  v2 = *(void ***)(a1 + 64);
  if (*(_BYTE *)(a1 + 96))
    free(v2[1]);
  free(v2);
  *(_QWORD *)(a1 + 64) = 0;
}

uint64_t ktxMemStream_construct(uint64_t a1, char a2)
{
  char *v4;
  char *v5;
  _QWORD *v6;
  void *v7;
  uint64_t result;

  if (!a1)
    return 11;
  v4 = (char *)malloc_type_malloc(0x28uLL, 0x105004059AC37B4uLL);
  if (!v4)
    return 13;
  v5 = v4;
  *((_OWORD *)v4 + 1) = 0u;
  v6 = v4 + 16;
  *((_QWORD *)v4 + 4) = 0;
  *(_OWORD *)v4 = 0u;
  v7 = malloc_type_malloc(0x100uLL, 0x96CBAE37uLL);
  *((_QWORD *)v5 + 1) = v7;
  if (v7)
  {
    result = 0;
    *((_QWORD *)v5 + 2) = 256;
    *(_QWORD *)(a1 + 64) = v5;
    *(_DWORD *)(a1 + 56) = 2;
    *(_QWORD *)a1 = ktxMemStream_read;
    *(_QWORD *)(a1 + 8) = ktxMemStream_skip;
    *(_QWORD *)(a1 + 16) = ktxMemStream_write;
    *(_QWORD *)(a1 + 24) = ktxMemStream_getpos;
    *(_QWORD *)(a1 + 32) = ktxMemStream_setpos;
    *(_QWORD *)(a1 + 40) = ktxMemStream_getsize;
    *(_QWORD *)(a1 + 48) = ktxMemStream_destruct;
    *(_BYTE *)(a1 + 96) = a2;
  }
  else
  {
    *v6 = 0;
    v6[1] = 0;
    return 13;
  }
  return result;
}

uint64_t ktxMemStream_construct_ro(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;

  result = 11;
  if (a1 && a2 && a3)
  {
    v7 = malloc_type_malloc(0x28uLL, 0x105004059AC37B4uLL);
    if (v7)
    {
      v8 = v7;
      result = 0;
      v8[3] = a3;
      v8[4] = 0;
      *v8 = a2;
      v8[1] = 0;
      v8[2] = a3;
      *(_QWORD *)(a1 + 64) = v8;
      *(_DWORD *)(a1 + 56) = 2;
      *(_QWORD *)a1 = ktxMemStream_read;
      *(_QWORD *)(a1 + 8) = ktxMemStream_skip;
      *(_QWORD *)(a1 + 16) = ktxMemStream_write;
      *(_QWORD *)(a1 + 24) = ktxMemStream_getpos;
      *(_QWORD *)(a1 + 32) = ktxMemStream_setpos;
      *(_QWORD *)(a1 + 40) = ktxMemStream_getsize;
      *(_QWORD *)(a1 + 48) = ktxMemStream_destruct;
      *(_BYTE *)(a1 + 96) = 0;
    }
    else
    {
      return 13;
    }
  }
  return result;
}

int8x16_t *_ktxSwapEndian16(int8x16_t *result, unint64_t a2)
{
  unint64_t v2;
  int8x16_t *v3;
  int8x16_t *v4;
  unint64_t v5;
  int8x16_t v6;
  unint64_t v7;

  if (a2)
  {
    if (a2 < 0x10)
    {
      v2 = 0;
      v3 = result;
LABEL_7:
      v7 = a2 - v2;
      do
      {
        v3->i16[0] = bswap32(v3->u16[0]) >> 16;
        v3 = (int8x16_t *)((char *)v3 + 2);
        --v7;
      }
      while (v7);
      return result;
    }
    v2 = a2 & 0xFFFFFFFFFFFFFFF0;
    v3 = (int8x16_t *)((char *)result + 2 * (a2 & 0xFFFFFFFFFFFFFFF0));
    v4 = result + 1;
    v5 = a2 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      v6 = vrev16q_s8(*v4);
      v4[-1] = vrev16q_s8(v4[-1]);
      *v4 = v6;
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
    if (v2 != a2)
      goto LABEL_7;
  }
  return result;
}

int8x16_t *_ktxSwapEndian32(int8x16_t *result, unint64_t a2)
{
  unint64_t v2;
  unsigned int *v3;
  int8x16_t *v4;
  unint64_t v5;
  int8x16_t v6;
  unint64_t v7;

  if (a2)
  {
    if (a2 < 8)
    {
      v2 = 0;
      v3 = (unsigned int *)result;
LABEL_7:
      v7 = a2 - v2;
      do
      {
        *v3 = bswap32(*v3);
        ++v3;
        --v7;
      }
      while (v7);
      return result;
    }
    v2 = a2 & 0xFFFFFFFFFFFFFFF8;
    v3 = (unsigned int *)result + (a2 & 0xFFFFFFFFFFFFFFF8);
    v4 = result + 1;
    v5 = a2 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      v6 = vrev32q_s8(*v4);
      v4[-1] = vrev32q_s8(v4[-1]);
      *v4 = v6;
      v4 += 2;
      v5 -= 8;
    }
    while (v5);
    if (v2 != a2)
      goto LABEL_7;
  }
  return result;
}

int8x16_t *_ktxSwapEndian64(int8x16_t *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t *v3;
  int8x16_t *v4;
  int8x16_t v5;
  unint64_t v6;
  int8x16_t v7;
  unint64_t v8;

  if (a2)
  {
    if (a2 < 4)
    {
      v2 = 0;
      v3 = (uint64_t *)result;
LABEL_7:
      v8 = a2 - v2;
      do
      {
        *v3 = bswap64(*v3 & 0xFF00FFFFFFFFFFFFLL);
        ++v3;
        --v8;
      }
      while (v8);
      return result;
    }
    v2 = a2 & 0xFFFFFFFFFFFFFFFCLL;
    v3 = &result->i64[a2 & 0xFFFFFFFFFFFFFFFCLL];
    v4 = result + 1;
    v5.i64[0] = 0xFF00FFFFFFFFFFFFLL;
    v5.i64[1] = 0xFF00FFFFFFFFFFFFLL;
    v6 = a2 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v7 = vrev64q_s8(vandq_s8(*v4, v5));
      v4[-1] = vrev64q_s8(vandq_s8(v4[-1], v5));
      *v4 = v7;
      v4 += 2;
      v6 -= 4;
    }
    while (v6);
    if (v2 != a2)
      goto LABEL_7;
  }
  return result;
}

uint64_t ktxTexture_construct(uint64_t a1, uint64_t a2, __int128 *a3)
{
  char *v6;
  __int128 v7;
  int v8;
  uint64_t result;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;

  *(_QWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  v6 = (char *)malloc_type_malloc(0xA8uLL, 0x10A2040785DE303uLL);
  *(_QWORD *)(a1 + 24) = v6;
  if (!v6)
    return 13;
  *((_QWORD *)v6 + 20) = 0;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 9) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *(_OWORD *)v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  v7 = *a3;
  *(_OWORD *)(v6 + 40) = a3[1];
  *(_OWORD *)(v6 + 24) = v7;
  *(_BYTE *)(a1 + 34) = (*(_BYTE *)a3 & 2) != 0;
  *(_QWORD *)(a1 + 64) = 0x6400000072;
  *(_DWORD *)(a1 + 72) = 111;
  v8 = *(_DWORD *)(a2 + 28);
  if ((v8 - 4) < 0xFFFFFFFD)
    return 11;
  v10 = *(_DWORD *)(a2 + 16);
  if (!v10)
    return 11;
  v11 = *(_DWORD *)(a2 + 20);
  if (!v11)
    return 11;
  v12 = *(_DWORD *)(a2 + 24);
  if (!v12)
    return 11;
  if (v8 == 3)
  {
    if (*(_BYTE *)(a2 + 44) || *(_DWORD *)(a2 + 40) != 1 || *(_DWORD *)(a2 + 36) != 1)
      return 10;
  }
  else if (v8 == 2)
  {
    if (v12 > 1)
      return 10;
  }
  else if (v8 == 1 && (v12 | v11) >= 2)
  {
    return 10;
  }
  *(_DWORD *)(a1 + 44) = v12;
  *(_DWORD *)(a1 + 48) = v8;
  *(_DWORD *)(a1 + 36) = v10;
  *(_DWORD *)(a1 + 40) = v11;
  v13 = *(_DWORD *)(a2 + 36);
  if (!v13)
    return 11;
  *(_DWORD *)(a1 + 56) = v13;
  v14 = *(_DWORD *)(a2 + 40);
  if (v14 == 1)
  {
LABEL_26:
    *(_DWORD *)(a1 + 60) = v14;
    v15 = *(_DWORD *)(a2 + 32);
    if (v15)
    {
      *(_DWORD *)(a1 + 52) = v15;
      *(_BYTE *)(a1 + 35) = *(_BYTE *)(a2 + 45);
      v16 = v15 - 1;
      if (!v16)
        goto LABEL_33;
      if (v10 <= v11)
        v10 = v11;
      if (v10 <= v12)
        v10 = v12;
      if (v10 >> v16)
      {
LABEL_33:
        *(_DWORD *)(a1 + 56) = v13;
        *(_BYTE *)(a1 + 32) = *(_BYTE *)(a2 + 44);
        ktxHashList_Construct((_QWORD *)(a1 + 80));
        return 0;
      }
      return 10;
    }
    return 11;
  }
  if (v14 != 6)
    return 11;
  result = 10;
  if (v8 == 2 && v10 == v11)
  {
    *(_BYTE *)(a1 + 33) = 1;
    goto LABEL_26;
  }
  return result;
}

uint64_t ktxTexture_constructFromStream(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v4 = malloc_type_malloc(0xA8uLL, 0x10A2040785DE303uLL);
  *(_QWORD *)(a1 + 24) = v4;
  v6 = *(_OWORD *)(a2 + 16);
  v5 = *(_OWORD *)(a2 + 32);
  v4[4] = *(_OWORD *)a2;
  v4[5] = v6;
  v4[6] = v5;
  v8 = *(_OWORD *)(a2 + 64);
  v7 = *(_OWORD *)(a2 + 80);
  v9 = *(_OWORD *)(a2 + 48);
  *((_QWORD *)v4 + 20) = *(_QWORD *)(a2 + 96);
  v4[8] = v8;
  v4[9] = v7;
  v4[7] = v9;
  *(_QWORD *)(a1 + 64) = 0x6400000072;
  *(_DWORD *)(a1 + 72) = 111;
  return 0;
}

void ktxTexture_destruct(uint64_t a1)
{
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  void *v6;
  void *v7;
  _OWORD v8[3];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v2 = *(_QWORD *)(a1 + 24);
  v3 = *(_OWORD *)(v2 + 144);
  v10 = *(_OWORD *)(v2 + 128);
  v11 = v3;
  v12 = *(_QWORD *)(v2 + 160);
  v4 = *(_OWORD *)(v2 + 80);
  v8[0] = *(_OWORD *)(v2 + 64);
  v8[1] = v4;
  v5 = *(_OWORD *)(v2 + 112);
  v8[2] = *(_OWORD *)(v2 + 96);
  v9 = v5;
  if ((_QWORD)v10)
    ((void (*)(_OWORD *))v9)(v8);
  if (*(_QWORD *)(a1 + 80))
    ktxHashList_Destruct((uint64_t *)(a1 + 80));
  v6 = *(void **)(a1 + 96);
  if (v6)
    free(v6);
  v7 = *(void **)(a1 + 112);
  if (v7)
    free(v7);
  free(*(void **)(a1 + 24));
}

uint64_t ktxTexture_CreateFromStream(uint64_t (**a1)(_QWORD, int8x16_t *, uint64_t), char a2, _QWORD *a3)
{
  uint64_t v6;
  _OWORD *v10;
  void *v11;
  _OWORD *v12;
  int8x16_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  memset(&v13, 0, 80);
  v6 = (*a1)(a1, &v13, 12);
  if (!(_DWORD)v6)
  {
    if (v13.i64[0] == 0xBB31312058544BABLL && v13.i32[2] == 169478669)
    {
      v6 = (*a1)(a1, (int8x16_t *)((unint64_t)&v13 | 0xC), 52);
      if ((_DWORD)v6)
        return v6;
      v10 = malloc_type_malloc(0x90uLL, 0x10300406A34F8ACuLL);
      if (v10)
      {
        v11 = v10;
        v10[7] = 0u;
        v10[8] = 0u;
        v10[5] = 0u;
        v10[6] = 0u;
        v10[3] = 0u;
        v10[4] = 0u;
        v10[1] = 0u;
        v10[2] = 0u;
        *v10 = 0u;
        v6 = ktxTexture1_constructFromStreamAndHeader((uint64_t)v10, (uint64_t)a1, &v13, a2);
        if (!(_DWORD)v6)
        {
LABEL_16:
          *a3 = v11;
          return v6;
        }
LABEL_15:
        free(v11);
        v11 = 0;
        goto LABEL_16;
      }
    }
    else
    {
      if (v13.i64[0] != 0xBB30322058544BABLL || v13.u32[2] != 169478669)
        return 15;
      v6 = (*a1)(a1, (int8x16_t *)((unint64_t)&v13 | 0xC), 68);
      if ((_DWORD)v6)
        return v6;
      v12 = malloc_type_malloc(0xA8uLL, 0x1030040B443E594uLL);
      if (v12)
      {
        v11 = v12;
        *((_QWORD *)v12 + 20) = 0;
        v12[8] = 0u;
        v12[9] = 0u;
        v12[6] = 0u;
        v12[7] = 0u;
        v12[4] = 0u;
        v12[5] = 0u;
        v12[2] = 0u;
        v12[3] = 0u;
        *v12 = 0u;
        v12[1] = 0u;
        v6 = ktxTexture2_constructFromStreamAndHeader((uint64_t)v12, (uint64_t)a1, (uint64_t)&v13, a2);
        if (!(_DWORD)v6)
          goto LABEL_16;
        goto LABEL_15;
      }
    }
    return 13;
  }
  return v6;
}

uint64_t ktxTexture_CreateFromStdioStream(uint64_t a1, char a2, _QWORD *a3)
{
  uint64_t result;
  _OWORD v7[6];
  uint64_t v8;

  result = 11;
  if (a1 && a3)
  {
    v8 = 0;
    memset(v7, 0, sizeof(v7));
    result = ktxFileStream_construct((uint64_t)v7, a1, 0);
    if (!(_DWORD)result)
      return ktxTexture_CreateFromStream((uint64_t (**)(_QWORD, int8x16_t *, uint64_t))v7, a2, a3);
  }
  return result;
}

uint64_t ktxTexture_CreateFromNamedFile(char *__filename, char a2, _QWORD *a3)
{
  uint64_t result;
  FILE *v7;
  _OWORD v8[6];
  uint64_t v9;

  result = 11;
  if (__filename && a3)
  {
    v7 = fopen(__filename, "rb");
    if (v7)
    {
      v9 = 0;
      memset(v8, 0, sizeof(v8));
      result = ktxFileStream_construct((uint64_t)v8, (uint64_t)v7, 1);
      if (!(_DWORD)result)
        return ktxTexture_CreateFromStream((uint64_t (**)(_QWORD, int8x16_t *, uint64_t))v8, a2, a3);
    }
    else
    {
      return 3;
    }
  }
  return result;
}

uint64_t ktxTexture_CreateFromMemory(uint64_t a1, uint64_t a2, char a3, _QWORD *a4)
{
  uint64_t result;
  _OWORD v9[6];
  uint64_t v10;

  result = 11;
  if (a2 && a1 && a4)
  {
    v10 = 0;
    memset(v9, 0, sizeof(v9));
    result = ktxMemStream_construct_ro((uint64_t)v9, a1, a2);
    if (!(_DWORD)result)
      return ktxTexture_CreateFromStream((uint64_t (**)(_QWORD, int8x16_t *, uint64_t))v9, a3, a4);
  }
  return result;
}

uint64_t ktxTexture_GetData(uint64_t a1)
{
  return *(_QWORD *)(a1 + 112);
}

uint64_t ktxTexture_GetDataSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 104);
}

uint64_t ktxTexture_GetElementSize(uint64_t a1)
{
  return *(_DWORD *)(*(_QWORD *)(a1 + 24) + 32) >> 3;
}

uint64_t ktxTexture_calcImageSize(uint64_t a1, char a2, int a3)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  v3 = *(_QWORD *)(a1 + 24);
  v4 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 36) >> a2) / (float)*(unsigned int *)(v3 + 36));
  v5 = *(_DWORD *)(v3 + 48);
  if (v5 > v4)
    v4 = *(_DWORD *)(v3 + 48);
  v6 = v4 * (*(_DWORD *)(v3 + 32) >> 3);
  if ((*(_BYTE *)(v3 + 24) & 2) == 0 && a3 == 1)
    v6 += (float)-(float)((float)v6 - (float)(ceilf((float)v6 * 0.25) * 4.0));
  v7 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 40) >> a2) / (float)*(unsigned int *)(v3 + 40));
  if (v5 > v7)
    v7 = *(_DWORD *)(v3 + 48);
  return v6 * v7;
}

uint64_t ktxTexture_IterateLevelFaces(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v20;

  v3 = 11;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 52))
    {
      v3 = 0;
      v6 = 0;
      while (1)
      {
        v7 = *(_DWORD *)(a1 + 40);
        v8 = *(_DWORD *)(a1 + 36) >> v6;
        v9 = v8 <= 1 ? 1 : v8;
        v10 = v7 >> v6 <= 1 ? 1 : v7 >> v6;
        v11 = *(_DWORD *)(a1 + 44) >> v6;
        v12 = v11 <= 1 ? 1 : v11;
        v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 24) + 8))(a1, v6);
        if (!*(_BYTE *)(a1 + 33) || *(_BYTE *)(a1 + 32))
          break;
        v14 = *(_DWORD *)(a1 + 60);
        if (v14)
          goto LABEL_19;
LABEL_6:
        v6 = (v6 + 1);
        if (v6 >= *(_DWORD *)(a1 + 52))
          return v3;
      }
      v14 = 1;
LABEL_19:
      v15 = 0;
      v16 = v13;
      do
      {
        v20 = 0;
        (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)(a1 + 8) + 8))(a1, v6, 0, v15, &v20);
        v17 = a2(v6, v15, v9, v10, v12, v16, *(_QWORD *)(a1 + 112) + v20, a3);
        if ((_DWORD)v17)
        {
          v3 = v17;
          goto LABEL_6;
        }
        v15 = (v15 + 1);
      }
      while (v14 != (_DWORD)v15);
      v3 = 0;
      goto LABEL_6;
    }
    return 0;
  }
  return v3;
}

unint64_t ktxTexture_layerSize(uint64_t a1, char a2, int a3)
{
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;

  v3 = *(_DWORD **)(a1 + 24);
  v4 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 36) >> a2) / (float)v3[9]);
  v5 = v3[12];
  if (v5 > v4)
    v4 = v3[12];
  v6 = v4 * (v3[8] >> 3);
  if (a3 == 1 && (v3[6] & 2) == 0)
    v6 += (float)-(float)((float)v6 - (float)(ceilf((float)v6 * 0.25) * 4.0));
  LODWORD(v7) = (*(_DWORD *)(a1 + 44) / v3[11]) >> a2;
  if (v7 <= 1)
    v7 = 1;
  else
    v7 = v7;
  v8 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 40) >> a2) / (float)v3[10]);
  if (v5 > v8)
    v8 = v3[12];
  return *(unsigned int *)(a1 + 60) * (unint64_t)(v6 * v8) * v7;
}

unint64_t ktxTexture_calcLevelSize(uint64_t a1, char a2, int a3)
{
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;

  v3 = *(_DWORD **)(a1 + 24);
  v4 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 36) >> a2) / (float)v3[9]);
  v5 = v3[12];
  if (v5 > v4)
    v4 = v3[12];
  v6 = v4 * (v3[8] >> 3);
  if (a3 == 1 && (v3[6] & 2) == 0)
    v6 += (float)-(float)((float)v6 - (float)(ceilf((float)v6 * 0.25) * 4.0));
  LODWORD(v7) = (*(_DWORD *)(a1 + 44) / v3[11]) >> a2;
  if (v7 <= 1)
    v7 = 1;
  else
    v7 = v7;
  v8 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 40) >> a2) / (float)v3[10]);
  if (v5 > v8)
    v8 = v3[12];
  return *(unsigned int *)(a1 + 60) * (unint64_t)(v6 * v8) * v7 * *(unsigned int *)(a1 + 56);
}

unint64_t ktxTexture_doCalcFaceLodSize(uint64_t a1, char a2, int a3)
{
  _DWORD *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  _DWORD *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;

  if (*(_BYTE *)(a1 + 33) && !*(_BYTE *)(a1 + 32))
  {
    v10 = *(_DWORD **)(a1 + 24);
    v11 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 36) >> a2) / (float)v10[9]);
    v12 = v10[12];
    if (v12 > v11)
      v11 = v10[12];
    v13 = v11 * (v10[8] >> 3);
    if (a3 == 1 && (v10[6] & 2) == 0)
      v13 += (float)-(float)((float)v13 - (float)(ceilf((float)v13 * 0.25) * 4.0));
    v14 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 40) >> a2) / (float)v10[10]);
    if (v12 > v14)
      v14 = v10[12];
    return v13 * v14;
  }
  else
  {
    v3 = *(_DWORD **)(a1 + 24);
    v4 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 36) >> a2) / (float)v3[9]);
    v5 = v3[12];
    if (v5 > v4)
      v4 = v3[12];
    v6 = v4 * (v3[8] >> 3);
    if (a3 == 1 && (v3[6] & 2) == 0)
      v6 += (float)-(float)((float)v6 - (float)(ceilf((float)v6 * 0.25) * 4.0));
    LODWORD(v7) = (*(_DWORD *)(a1 + 44) / v3[11]) >> a2;
    if (v7 <= 1)
      v7 = 1;
    else
      v7 = v7;
    v8 = vcvtps_u32_f32((float)(*(_DWORD *)(a1 + 40) >> a2) / (float)v3[10]);
    if (v5 > v8)
      v8 = v3[12];
    return *(unsigned int *)(a1 + 60) * (unint64_t)(v6 * v8) * v7 * *(unsigned int *)(a1 + 56);
  }
}

uint64_t ktxTexture_calcDataSizeTexture(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t, _QWORD))(a1 + 24))(a1, *(unsigned int *)(a1 + 52));
}

float ktxTexture_rowInfo(uint64_t a1, char a2, unsigned int *a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  float result;

  v5 = *(_DWORD **)(a1 + 24);
  v6 = (*(_DWORD *)(a1 + 36) / v5[9]) >> a2;
  if (v6 <= 1)
    v6 = 1;
  v7 = (*(_DWORD *)(a1 + 40) / v5[10]) >> a2;
  if (v7 <= 1)
    v7 = 1;
  *a3 = v7;
  v8 = (v5[8] * v6) >> 3;
  result = -(float)((float)v8 - (float)(ceilf((float)v8 * 0.25) * 4.0));
  *a4 = v8 + result;
  *a5 = result;
  return result;
}

uint64_t ktxTexture_GetRowPitch(uint64_t a1, char a2)
{
  unsigned int v2;

  v2 = (*(_DWORD *)(a1 + 36) / *(_DWORD *)(*(_QWORD *)(a1 + 24) + 36)) >> a2;
  if (v2 <= 1)
    v2 = 1;
  return ((v2 * *(_DWORD *)(*(_QWORD *)(a1 + 24) + 32)) >> 3)
       + (float)-(float)((float)((v2 * *(_DWORD *)(*(_QWORD *)(a1 + 24) + 32)) >> 3)
                                     - (float)(ceilf((float)((v2 * *(_DWORD *)(*(_QWORD *)(a1 + 24) + 32)) >> 3) * 0.25)
                                             * 4.0));
}

BOOL ktxTexture_isActiveStream(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 24) + 128) != 0;
}

uint64_t ktxTexture1_constructFromStreamAndHeader(uint64_t a1, uint64_t a2, int8x16_t *a3, char a4)
{
  uint64_t ImageData;
  uint64_t v8;
  __int128 v9;
  _BYTE *v10;
  _BYTE *v11;
  uint64_t v12;
  void *v13;
  int v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  BOOL v21;
  __int32 v22;
  size_t v23;
  char *v24;
  char *v25;
  int8x16_t *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  char *v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  int v36;

  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  ImageData = ktxTexture_constructFromStream(a1, a2);
  if ((_DWORD)ImageData)
    return ImageData;
  *(_DWORD *)a1 = 1;
  *(_QWORD *)(a1 + 8) = ktxTexture1_vtbl;
  v8 = *(_QWORD *)(a1 + 24);
  v9 = ktxTexture1_vtblInt;
  *(uint64_t (**)())(v8 + 16) = off_1EDF008F8[0];
  *(_OWORD *)v8 = v9;
  v10 = malloc_type_malloc(1uLL, 0x100004077774924uLL);
  *(_QWORD *)(a1 + 136) = v10;
  if (!v10)
  {
    ktxTexture_destruct(a1);
    return 13;
  }
  v36 = 0;
  v34 = 0;
  v35 = 0;
  v32 = 0u;
  v33 = 0u;
  *v10 = 0;
  v11 = *(_BYTE **)(a1 + 136);
  v12 = *(_QWORD *)(a1 + 24);
  ImageData = ktxCheckHeader1_(a3, (uint64_t)&v36);
  if ((_DWORD)ImageData)
    goto LABEL_4;
  *(_DWORD *)(a1 + 120) = a3[1].i32[2];
  v15 = a3[1].i32[3];
  *(_DWORD *)(a1 + 124) = v15;
  *(_DWORD *)(a1 + 132) = a3[1].i32[0];
  glGetFormatSize(v15, (uint64_t)&v32);
  if (!DWORD2(v32))
  {
    ImageData = 16;
    goto LABEL_4;
  }
  v16 = *(_QWORD *)(a1 + 24);
  v17 = v33;
  *(_OWORD *)(v16 + 24) = v32;
  *(_OWORD *)(v16 + 40) = v17;
  *(_DWORD *)(a1 + 128) = a3[2].i32[0];
  v18 = HIWORD(v36);
  *(_DWORD *)(a1 + 48) = HIWORD(v36);
  *(_DWORD *)(a1 + 36) = a3[2].i32[1];
  if (v18 == 3)
  {
    v19 = a3[2].i64[1];
LABEL_16:
    *(_QWORD *)(a1 + 40) = v19;
    goto LABEL_18;
  }
  if (v18 != 2)
  {
    if (v18 != 1)
      goto LABEL_18;
    v19 = 0x100000001;
    goto LABEL_16;
  }
  *(_DWORD *)(a1 + 40) = a3[2].i32[2];
  *(_DWORD *)(a1 + 44) = 1;
LABEL_18:
  v20 = a3[3].u32[0];
  v21 = v20 != 0;
  if (v20 <= 1)
    v20 = 1;
  *(_DWORD *)(a1 + 56) = v20;
  *(_BYTE *)(a1 + 32) = v21;
  v22 = a3[3].i32[1];
  *(_DWORD *)(a1 + 60) = v22;
  *(_BYTE *)(a1 + 33) = v22 == 6;
  *(_DWORD *)(a1 + 52) = a3[3].i32[2];
  *(_BYTE *)(a1 + 34) = (_BYTE)v36 != 0;
  *(_BYTE *)(a1 + 35) = BYTE1(v36) != 0;
  if (a3->i32[3] == 16909060)
    *v11 = 1;
  *(_DWORD *)(*(_QWORD *)(a1 + 24) + 56) = a3[1].i32[1];
  ktxHashList_Construct((_QWORD *)(a1 + 80));
  v23 = a3[3].u32[3];
  if (!(_DWORD)v23)
    goto LABEL_40;
  if ((a4 & 4) != 0)
  {
    (*(void (**)(uint64_t, size_t))(v12 + 72))(v12 + 64, v23);
    goto LABEL_40;
  }
  v24 = (char *)malloc_type_malloc(v23, 0x61F0112CuLL);
  if (!v24)
  {
    ImageData = 13;
    goto LABEL_4;
  }
  v25 = v24;
  ImageData = (*(uint64_t (**)(uint64_t, char *, size_t))(v12 + 64))(v12 + 64, v24, v23);
  if (!(_DWORD)ImageData)
  {
    if (*v11)
    {
      v26 = (int8x16_t *)v25;
      do
      {
        _ktxSwapEndian32(v26, 1uLL);
        LODWORD(v27) = vcvts_n_u32_f32(ceilf((float)v26->u32[0] * 0.25), 2uLL);
        v26 = (int8x16_t *)((char *)v26 + v27);
      }
      while (v26 < (int8x16_t *)&v25[v23]);
    }
    if ((a4 & 2) != 0)
    {
      *(_DWORD *)(a1 + 88) = v23;
      *(_QWORD *)(a1 + 96) = v25;
      ImageData = (*(uint64_t (**)(uint64_t, uint64_t *))(v12 + 104))(v12 + 64, &v34);
      if ((_DWORD)ImageData)
        goto LABEL_4;
      goto LABEL_41;
    }
    v31 = 0;
    v30 = 0;
    ImageData = ktxHashList_Deserialize((_QWORD *)(a1 + 80), v23, v25);
    free(v25);
    if ((_DWORD)ImageData)
      goto LABEL_4;
    if (!ktxHashList_FindValue((uint64_t *)(a1 + 80), "KTXorientation", &v30, &v31))
    {
      v29 = 0;
      sscanf(v31, "S=%c,T=%c,R=%c", &v29, (char *)&v29 + 1, (char *)&v29 + 2);
      v28 = *(_DWORD *)(a1 + 48);
      switch(v28)
      {
        case 1:
          goto LABEL_37;
        case 2:
LABEL_36:
          *(_DWORD *)(a1 + 68) = SBYTE1(v29);
LABEL_37:
          *(_DWORD *)(a1 + 64) = (char)v29;
          ImageData = (*(uint64_t (**)(uint64_t, uint64_t *))(v12 + 104))(v12 + 64, &v34);
          if ((_DWORD)ImageData)
            goto LABEL_4;
LABEL_41:
          ImageData = (*(uint64_t (**)(uint64_t, uint64_t *))(v12 + 88))(v12 + 64, &v35);
          if (!(_DWORD)ImageData)
          {
            *(_QWORD *)(a1 + 104) = v34 - (v35 + 4 * *(unsigned int *)(a1 + 52));
            if ((a4 & 1) == 0)
              return 0;
            ImageData = ktxTexture1_LoadImageData(a1, 0, 0);
            if (!(_DWORD)ImageData)
              return ImageData;
          }
          goto LABEL_4;
        case 3:
          *(_DWORD *)(a1 + 72) = SBYTE2(v29);
          goto LABEL_36;
      }
    }
LABEL_40:
    ImageData = (*(uint64_t (**)(uint64_t, uint64_t *))(v12 + 104))(v12 + 64, &v34);
    if ((_DWORD)ImageData)
      goto LABEL_4;
    goto LABEL_41;
  }
LABEL_4:
  v13 = *(void **)(a1 + 136);
  if (v13)
    free(v13);
  ktxTexture_destruct(a1);
  return ImageData;
}

double glGetFormatSize(int a1, uint64_t a2)
{
  double result;

  *(_QWORD *)(a2 + 24) = 0x100000001;
  if (a1 <= 36165)
  {
    if (a1 > 34797)
    {
      if (a1 <= 35727)
      {
        switch(a1)
        {
          case 34798:
LABEL_34:
            *(_OWORD *)a2 = xmmword_18823DE40;
            *(_QWORD *)&result = 0x100000004;
            *(_QWORD *)(a2 + 16) = 0x100000004;
            break;
          case 34799:
          case 34800:
          case 34801:
          case 34802:
          case 34803:
          case 34804:
          case 34805:
          case 34806:
          case 34807:
          case 34808:
          case 34809:
          case 34810:
          case 34811:
          case 34812:
          case 34813:
          case 34814:
          case 34815:
          case 34816:
          case 34817:
          case 34818:
          case 34819:
          case 34820:
          case 34821:
          case 34822:
          case 34823:
          case 34824:
          case 34825:
          case 34826:
          case 34827:
          case 34828:
          case 34829:
          case 34830:
          case 34831:
          case 34832:
          case 34833:
          case 34834:
          case 34835:
          case 34838:
          case 34839:
          case 34840:
          case 34841:
LABEL_80:
            *(_OWORD *)a2 = xmmword_18820E720;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 34836:
LABEL_29:
            *(_OWORD *)a2 = xmmword_18823DF40;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 34837:
LABEL_37:
            *(_OWORD *)a2 = xmmword_18823DF50;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 34842:
LABEL_30:
            *(_OWORD *)a2 = xmmword_18823DF60;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 34843:
LABEL_31:
            *(_OWORD *)a2 = xmmword_18823DF80;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          default:
            switch(a1)
            {
              case 35412:
              case 35414:
LABEL_22:
                *(_QWORD *)&result = 2;
                *(_OWORD *)a2 = xmmword_18823DEC0;
                *(_OWORD *)(a2 + 16) = xmmword_18823DED0;
                break;
              case 35413:
              case 35415:
LABEL_36:
                *(_QWORD *)&result = 2;
                *(_OWORD *)a2 = xmmword_18823DE50;
                *(_OWORD *)(a2 + 16) = xmmword_18823DED0;
                break;
              default:
                if (a1 != 35056)
                  goto LABEL_80;
                *(_OWORD *)a2 = xmmword_18823DD70;
                *(_QWORD *)&result = 0x100000001;
                *(_QWORD *)(a2 + 16) = 0x100000001;
                break;
            }
            break;
        }
      }
      else
      {
        switch(a1)
        {
          case 35728:
            *(_OWORD *)a2 = xmmword_18823DE30;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 35729:
            *(_OWORD *)a2 = xmmword_18823DE20;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 35730:
          case 35731:
          case 35732:
            *(_OWORD *)a2 = xmmword_18823DE10;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 35733:
            *(_OWORD *)a2 = xmmword_18823DE00;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 35734:
            *(_OWORD *)a2 = xmmword_18823DDF0;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 35735:
          case 35736:
          case 35737:
            *(_OWORD *)a2 = xmmword_18823DDE0;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 35840:
          case 35842:
            goto LABEL_36;
          case 35841:
          case 35843:
            goto LABEL_22;
          case 35898:
          case 35901:
LABEL_25:
            *(_OWORD *)a2 = xmmword_18823DEE0;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 35905:
LABEL_26:
            *(_OWORD *)a2 = xmmword_18823DFA0;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 35907:
LABEL_19:
            *(_OWORD *)a2 = xmmword_18823DF70;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 35916:
          case 35917:
          case 35952:
          case 35953:
          case 35986:
            goto LABEL_41;
          case 35918:
          case 35919:
          case 35954:
          case 35955:
          case 35987:
            goto LABEL_34;
          case 36012:
LABEL_35:
            *(_OWORD *)a2 = xmmword_18823DDC0;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          case 36013:
LABEL_42:
            *(_OWORD *)a2 = xmmword_18823DD60;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            break;
          default:
            goto LABEL_80;
        }
      }
    }
    else
    {
      if (a1 > 33188)
      {
        switch(a1)
        {
          case 33189:
            *(_OWORD *)a2 = xmmword_18823DDD0;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            return result;
          case 33190:
          case 33191:
            goto LABEL_35;
          case 33192:
          case 33193:
          case 33194:
          case 33195:
          case 33196:
          case 33197:
          case 33198:
          case 33199:
          case 33200:
          case 33201:
          case 33202:
          case 33203:
          case 33204:
          case 33205:
          case 33206:
          case 33207:
          case 33208:
          case 33209:
          case 33210:
          case 33211:
          case 33212:
          case 33213:
          case 33214:
          case 33215:
          case 33216:
          case 33217:
          case 33218:
          case 33219:
          case 33220:
          case 33221:
          case 33222:
          case 33223:
          case 33224:
          case 33225:
          case 33226:
          case 33227:
          case 33228:
          case 33229:
          case 33230:
          case 33231:
          case 33232:
          case 33233:
          case 33234:
          case 33235:
          case 33236:
          case 33237:
          case 33238:
          case 33239:
          case 33240:
          case 33241:
          case 33242:
          case 33243:
          case 33244:
          case 33245:
          case 33246:
          case 33247:
          case 33248:
          case 33249:
          case 33250:
          case 33251:
          case 33252:
          case 33253:
          case 33254:
          case 33255:
          case 33256:
          case 33257:
          case 33258:
          case 33259:
          case 33260:
          case 33261:
          case 33262:
          case 33263:
          case 33264:
          case 33265:
          case 33266:
          case 33267:
          case 33268:
          case 33269:
          case 33270:
          case 33271:
          case 33272:
          case 33273:
          case 33274:
          case 33275:
          case 33276:
          case 33277:
          case 33278:
          case 33279:
          case 33280:
          case 33281:
          case 33282:
          case 33283:
          case 33284:
          case 33285:
          case 33286:
          case 33287:
          case 33288:
          case 33289:
          case 33290:
          case 33291:
          case 33292:
          case 33293:
          case 33294:
          case 33295:
          case 33296:
          case 33297:
          case 33298:
          case 33299:
          case 33300:
          case 33301:
          case 33302:
          case 33303:
          case 33304:
          case 33305:
          case 33306:
          case 33307:
          case 33308:
          case 33309:
          case 33310:
          case 33311:
          case 33312:
          case 33313:
          case 33314:
          case 33315:
          case 33316:
          case 33317:
          case 33318:
          case 33319:
          case 33320:
            goto LABEL_80;
          case 33321:
          case 33329:
          case 33330:
LABEL_27:
            *(_OWORD *)a2 = xmmword_18823DFB0;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            return result;
          case 33322:
          case 33323:
          case 33325:
          case 33331:
          case 33332:
          case 33335:
          case 33336:
LABEL_16:
            *(_OWORD *)a2 = xmmword_18823DF90;
            *(_QWORD *)&result = 0x100000001;
            *(_QWORD *)(a2 + 16) = 0x100000001;
            return result;
          case 33324:
          case 33326:
          case 33327:
          case 33333:
          case 33334:
          case 33337:
          case 33338:
            goto LABEL_19;
          case 33328:
          case 33339:
          case 33340:
            goto LABEL_30;
          default:
            if ((a1 - 33776) < 2)
              goto LABEL_41;
            if ((a1 - 33778) < 2)
              goto LABEL_34;
            goto LABEL_80;
        }
      }
      switch(a1)
      {
        case 32847:
          *(_OWORD *)a2 = xmmword_18823DF30;
          *(_QWORD *)&result = 0x100000001;
          *(_QWORD *)(a2 + 16) = 0x100000001;
          return result;
        case 32848:
        case 32854:
LABEL_18:
          *(_OWORD *)a2 = xmmword_18823DF00;
          *(_QWORD *)&result = 0x100000001;
          *(_QWORD *)(a2 + 16) = 0x100000001;
          return result;
        case 32849:
          goto LABEL_26;
        case 32850:
        case 32855:
        case 32857:
          goto LABEL_25;
        case 32851:
          *(_OWORD *)a2 = xmmword_18823DF20;
          *(_QWORD *)&result = 0x100000001;
          *(_QWORD *)(a2 + 16) = 0x100000001;
          return result;
        case 32852:
          goto LABEL_31;
        case 32853:
          goto LABEL_70;
        case 32856:
          goto LABEL_19;
        case 32858:
          *(_OWORD *)a2 = xmmword_18823DEF0;
          *(_QWORD *)&result = 0x100000001;
          *(_QWORD *)(a2 + 16) = 0x100000001;
          return result;
        case 32859:
          goto LABEL_30;
        default:
          if (a1 != 10768)
            goto LABEL_80;
LABEL_70:
          *(_OWORD *)a2 = xmmword_18823DF10;
          *(_QWORD *)&result = 0x100000001;
          *(_QWORD *)(a2 + 16) = 0x100000001;
          break;
      }
    }
  }
  else if (a1 <= 37174)
  {
    if (a1 > 36491)
    {
      switch(a1)
      {
        case 36756:
        case 36797:
          goto LABEL_27;
        case 36757:
        case 36760:
        case 36798:
          goto LABEL_16;
        case 36758:
          goto LABEL_26;
        case 36759:
        case 36761:
          goto LABEL_19;
        case 36762:
          goto LABEL_31;
        case 36763:
          goto LABEL_30;
        case 36764:
        case 36765:
        case 36766:
        case 36767:
        case 36768:
        case 36769:
        case 36770:
        case 36771:
        case 36772:
        case 36773:
        case 36774:
        case 36775:
        case 36776:
        case 36777:
        case 36778:
        case 36779:
        case 36780:
        case 36781:
        case 36782:
        case 36783:
        case 36784:
        case 36785:
        case 36786:
        case 36787:
        case 36788:
        case 36789:
        case 36790:
        case 36791:
        case 36792:
        case 36793:
        case 36794:
        case 36795:
        case 36796:
          goto LABEL_80;
        default:
          if ((a1 - 36492) < 4)
            goto LABEL_34;
          if (a1 == 36975)
            goto LABEL_25;
          goto LABEL_80;
      }
    }
    switch(a1)
    {
      case 36166:
        *(_OWORD *)a2 = xmmword_18823DDB0;
        *(_QWORD *)&result = 0x100000001;
        *(_QWORD *)(a2 + 16) = 0x100000001;
        break;
      case 36167:
        *(_OWORD *)a2 = xmmword_18823DDA0;
        *(_QWORD *)&result = 0x100000001;
        *(_QWORD *)(a2 + 16) = 0x100000001;
        break;
      case 36168:
        *(_OWORD *)a2 = xmmword_18823DD90;
        *(_QWORD *)&result = 0x100000001;
        *(_QWORD *)(a2 + 16) = 0x100000001;
        break;
      case 36169:
        *(_OWORD *)a2 = xmmword_18823DD80;
        *(_QWORD *)&result = 0x100000001;
        *(_QWORD *)(a2 + 16) = 0x100000001;
        break;
      case 36194:
        goto LABEL_18;
      case 36196:
      case 36283:
      case 36284:
        goto LABEL_41;
      case 36208:
      case 36226:
        goto LABEL_29;
      case 36209:
      case 36227:
        goto LABEL_37;
      case 36214:
      case 36232:
        goto LABEL_30;
      case 36215:
      case 36233:
        goto LABEL_31;
      case 36220:
      case 36238:
        goto LABEL_19;
      case 36221:
      case 36239:
        goto LABEL_26;
      case 36267:
        goto LABEL_35;
      case 36268:
        goto LABEL_42;
      case 36285:
      case 36286:
        goto LABEL_34;
      default:
        goto LABEL_80;
    }
  }
  else
  {
    switch(a1)
    {
      case 37488:
      case 37489:
      case 37492:
      case 37493:
      case 37494:
      case 37495:
      case 37873:
        break;
      case 37490:
      case 37491:
      case 37496:
      case 37497:
      case 37808:
      case 37840:
        goto LABEL_34;
      case 37498:
      case 37499:
      case 37500:
      case 37501:
      case 37502:
      case 37503:
      case 37504:
      case 37505:
      case 37506:
      case 37507:
      case 37508:
      case 37509:
      case 37510:
      case 37511:
      case 37512:
      case 37513:
      case 37514:
      case 37515:
      case 37516:
      case 37517:
      case 37518:
      case 37519:
      case 37520:
      case 37521:
      case 37522:
      case 37523:
      case 37524:
      case 37525:
      case 37526:
      case 37527:
      case 37528:
      case 37529:
      case 37530:
      case 37531:
      case 37532:
      case 37533:
      case 37534:
      case 37535:
      case 37536:
      case 37537:
      case 37538:
      case 37539:
      case 37540:
      case 37541:
      case 37542:
      case 37543:
      case 37544:
      case 37545:
      case 37546:
      case 37547:
      case 37548:
      case 37549:
      case 37550:
      case 37551:
      case 37552:
      case 37553:
      case 37554:
      case 37555:
      case 37556:
      case 37557:
      case 37558:
      case 37559:
      case 37560:
      case 37561:
      case 37562:
      case 37563:
      case 37564:
      case 37565:
      case 37566:
      case 37567:
      case 37568:
      case 37569:
      case 37570:
      case 37571:
      case 37572:
      case 37573:
      case 37574:
      case 37575:
      case 37576:
      case 37577:
      case 37578:
      case 37579:
      case 37580:
      case 37581:
      case 37582:
      case 37583:
      case 37584:
      case 37585:
      case 37586:
      case 37587:
      case 37588:
      case 37589:
      case 37590:
      case 37591:
      case 37592:
      case 37593:
      case 37594:
      case 37595:
      case 37596:
      case 37597:
      case 37598:
      case 37599:
      case 37600:
      case 37601:
      case 37602:
      case 37603:
      case 37604:
      case 37605:
      case 37606:
      case 37607:
      case 37608:
      case 37609:
      case 37610:
      case 37611:
      case 37612:
      case 37613:
      case 37614:
      case 37615:
      case 37616:
      case 37617:
      case 37618:
      case 37619:
      case 37620:
      case 37621:
      case 37622:
      case 37623:
      case 37624:
      case 37625:
      case 37626:
      case 37627:
      case 37628:
      case 37629:
      case 37630:
      case 37631:
      case 37632:
      case 37633:
      case 37634:
      case 37635:
      case 37636:
      case 37637:
      case 37638:
      case 37639:
      case 37640:
      case 37641:
      case 37642:
      case 37643:
      case 37644:
      case 37645:
      case 37646:
      case 37647:
      case 37648:
      case 37649:
      case 37650:
      case 37651:
      case 37652:
      case 37653:
      case 37654:
      case 37655:
      case 37656:
      case 37657:
      case 37658:
      case 37659:
      case 37660:
      case 37661:
      case 37662:
      case 37663:
      case 37664:
      case 37665:
      case 37666:
      case 37667:
      case 37668:
      case 37669:
      case 37670:
      case 37671:
      case 37672:
      case 37673:
      case 37674:
      case 37675:
      case 37676:
      case 37677:
      case 37678:
      case 37679:
      case 37680:
      case 37681:
      case 37682:
      case 37683:
      case 37684:
      case 37685:
      case 37686:
      case 37687:
      case 37688:
      case 37689:
      case 37690:
      case 37691:
      case 37692:
      case 37693:
      case 37694:
      case 37695:
      case 37696:
      case 37697:
      case 37698:
      case 37699:
      case 37700:
      case 37701:
      case 37702:
      case 37703:
      case 37704:
      case 37705:
      case 37706:
      case 37707:
      case 37708:
      case 37709:
      case 37710:
      case 37711:
      case 37712:
      case 37713:
      case 37714:
      case 37715:
      case 37716:
      case 37717:
      case 37718:
      case 37719:
      case 37720:
      case 37721:
      case 37722:
      case 37723:
      case 37724:
      case 37725:
      case 37726:
      case 37727:
      case 37728:
      case 37729:
      case 37730:
      case 37731:
      case 37732:
      case 37733:
      case 37734:
      case 37735:
      case 37736:
      case 37737:
      case 37738:
      case 37739:
      case 37740:
      case 37741:
      case 37742:
      case 37743:
      case 37744:
      case 37745:
      case 37746:
      case 37747:
      case 37748:
      case 37749:
      case 37750:
      case 37751:
      case 37752:
      case 37753:
      case 37754:
      case 37755:
      case 37756:
      case 37757:
      case 37758:
      case 37759:
      case 37760:
      case 37761:
      case 37762:
      case 37763:
      case 37764:
      case 37765:
      case 37766:
      case 37767:
      case 37768:
      case 37769:
      case 37770:
      case 37771:
      case 37772:
      case 37773:
      case 37774:
      case 37775:
      case 37776:
      case 37777:
      case 37778:
      case 37779:
      case 37780:
      case 37781:
      case 37782:
      case 37783:
      case 37784:
      case 37785:
      case 37786:
      case 37787:
      case 37788:
      case 37789:
      case 37790:
      case 37791:
      case 37792:
      case 37793:
      case 37794:
      case 37795:
      case 37796:
      case 37797:
      case 37798:
      case 37799:
      case 37800:
      case 37801:
      case 37802:
      case 37803:
      case 37804:
      case 37805:
      case 37806:
      case 37807:
      case 37822:
      case 37823:
      case 37834:
      case 37835:
      case 37836:
      case 37837:
      case 37838:
      case 37839:
      case 37854:
      case 37855:
      case 37866:
      case 37867:
      case 37868:
      case 37869:
      case 37870:
      case 37871:
        goto LABEL_80;
      case 37809:
      case 37841:
        *(_OWORD *)a2 = xmmword_18823DE70;
        *(_QWORD *)&result = 0x100000004;
        *(_QWORD *)(a2 + 16) = 0x100000004;
        return result;
      case 37810:
      case 37842:
        *(_OWORD *)a2 = xmmword_18823DE70;
        *(_QWORD *)&result = 0x100000005;
        *(_QWORD *)(a2 + 16) = 0x100000005;
        return result;
      case 37811:
      case 37843:
        *(_OWORD *)a2 = xmmword_18823DE60;
        *(_QWORD *)&result = 0x100000005;
        *(_QWORD *)(a2 + 16) = 0x100000005;
        return result;
      case 37812:
      case 37844:
        *(_OWORD *)a2 = xmmword_18823DE60;
        *(_QWORD *)&result = 0x100000006;
        *(_QWORD *)(a2 + 16) = 0x100000006;
        return result;
      case 37813:
      case 37845:
        *(_OWORD *)a2 = xmmword_18823DEB0;
        *(_QWORD *)&result = 0x100000005;
        *(_QWORD *)(a2 + 16) = 0x100000005;
        return result;
      case 37814:
      case 37846:
        *(_OWORD *)a2 = xmmword_18823DEB0;
        *(_QWORD *)&result = 0x100000006;
        *(_QWORD *)(a2 + 16) = 0x100000006;
        return result;
      case 37815:
      case 37847:
        *(_OWORD *)a2 = xmmword_18823DEB0;
        *(_QWORD *)&result = 0x100000008;
        *(_QWORD *)(a2 + 16) = 0x100000008;
        return result;
      case 37816:
      case 37848:
        *(_OWORD *)a2 = xmmword_18823DEA0;
        *(_QWORD *)&result = 0x100000005;
        *(_QWORD *)(a2 + 16) = 0x100000005;
        return result;
      case 37817:
      case 37849:
        *(_OWORD *)a2 = xmmword_18823DEA0;
        *(_QWORD *)&result = 0x100000006;
        *(_QWORD *)(a2 + 16) = 0x100000006;
        return result;
      case 37818:
      case 37850:
        *(_OWORD *)a2 = xmmword_18823DEA0;
        *(_QWORD *)&result = 0x100000008;
        *(_QWORD *)(a2 + 16) = 0x100000008;
        return result;
      case 37819:
      case 37851:
        *(_OWORD *)a2 = xmmword_18823DEA0;
        *(_QWORD *)&result = 0x10000000ALL;
        *(_QWORD *)(a2 + 16) = 0x10000000ALL;
        return result;
      case 37820:
      case 37852:
        *(_OWORD *)a2 = xmmword_18823DE90;
        *(_QWORD *)&result = 0x10000000ALL;
        *(_QWORD *)(a2 + 16) = 0x10000000ALL;
        return result;
      case 37821:
      case 37853:
        *(_OWORD *)a2 = xmmword_18823DE90;
        *(_QWORD *)&result = 0x10000000CLL;
        *(_QWORD *)(a2 + 16) = 0x10000000CLL;
        return result;
      case 37824:
      case 37856:
        *(_OWORD *)a2 = xmmword_18823DE80;
        *(_QWORD *)&result = 0x300000003;
        *(_QWORD *)(a2 + 16) = 0x300000003;
        return result;
      case 37825:
      case 37857:
        *(_OWORD *)a2 = xmmword_18823DE40;
        *(_QWORD *)&result = 0x300000003;
        *(_QWORD *)(a2 + 16) = 0x300000003;
        return result;
      case 37826:
      case 37858:
        *(_OWORD *)a2 = xmmword_18823DE40;
        *(_QWORD *)&result = 0x300000004;
        *(_QWORD *)(a2 + 16) = 0x300000004;
        return result;
      case 37827:
      case 37859:
        *(_OWORD *)a2 = xmmword_18823DE40;
        *(_QWORD *)&result = 0x400000004;
        *(_QWORD *)(a2 + 16) = 0x400000004;
        return result;
      case 37828:
      case 37860:
        *(_OWORD *)a2 = xmmword_18823DE70;
        *(_QWORD *)&result = 0x400000004;
        *(_QWORD *)(a2 + 16) = 0x400000004;
        return result;
      case 37829:
      case 37861:
        *(_OWORD *)a2 = xmmword_18823DE70;
        *(_QWORD *)&result = 0x400000005;
        *(_QWORD *)(a2 + 16) = 0x400000005;
        return result;
      case 37830:
      case 37862:
        *(_OWORD *)a2 = xmmword_18823DE70;
        *(_QWORD *)&result = 0x500000005;
        *(_QWORD *)(a2 + 16) = 0x500000005;
        return result;
      case 37831:
      case 37863:
        *(_OWORD *)a2 = xmmword_18823DE60;
        *(_QWORD *)&result = 0x500000005;
        *(_QWORD *)(a2 + 16) = 0x500000005;
        return result;
      case 37832:
      case 37864:
        *(_OWORD *)a2 = xmmword_18823DE60;
        *(_QWORD *)&result = 0x500000006;
        *(_QWORD *)(a2 + 16) = 0x500000006;
        return result;
      case 37833:
      case 37865:
        *(_OWORD *)a2 = xmmword_18823DE60;
        *(_QWORD *)&result = 0x600000006;
        *(_QWORD *)(a2 + 16) = 0x600000006;
        return result;
      case 37872:
        goto LABEL_65;
      default:
        if (a1 == 37175)
        {
LABEL_65:
          *(_OWORD *)a2 = xmmword_18823DEC0;
          *(_QWORD *)&result = 0x100000004;
          *(_QWORD *)(a2 + 16) = 0x100000004;
          return result;
        }
        if (a1 != 37176)
          goto LABEL_80;
        break;
    }
LABEL_41:
    *(_OWORD *)a2 = xmmword_18823DE50;
    *(_QWORD *)&result = 0x100000004;
    *(_QWORD *)(a2 + 16) = 0x100000004;
  }
  return result;
}

uint64_t ktxTexture1_LoadImageData(uint64_t a1, int8x16_t *a2, size_t a3)
{
  uint64_t v3;
  int8x16_t *v4;
  _BYTE *v6;
  size_t v7;
  uint64_t v8;
  uint64_t (**v9)(uint64_t, int8x16_t *, uint64_t);
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int8x16_t v16;

  v3 = *(_QWORD *)(a1 + 24);
  if (!*(_QWORD *)(v3 + 128))
    return 10;
  v4 = a2;
  v6 = *(_BYTE **)(a1 + 136);
  v7 = *(_QWORD *)(a1 + 104);
  if (a2)
  {
    if (v7 > a3)
      return 11;
  }
  else
  {
    v4 = (int8x16_t *)malloc_type_malloc(v7, 0xEC4D5731uLL);
    *(_QWORD *)(a1 + 112) = v4;
    if (!v4)
      return 13;
  }
  v9 = (uint64_t (**)(uint64_t, int8x16_t *, uint64_t))(v3 + 64);
  if (*(_DWORD *)(a1 + 52))
  {
    v10 = 0;
    while (1)
    {
      v16.i32[0] = 0;
      v11 = (*v9)(v3 + 64, &v16, 4);
      if ((_DWORD)v11)
        break;
      if (*v6)
        _ktxSwapEndian32(&v16, 1uLL);
      v12 = v16.u32[0];
      if (!*(_BYTE *)(a1 + 33))
      {
        v13 = 1;
        goto LABEL_21;
      }
      if (*(_BYTE *)(a1 + 32))
      {
        v13 = 1;
        goto LABEL_21;
      }
      v13 = *(_DWORD *)(a1 + 60);
      if (v13)
      {
LABEL_21:
        do
        {
          v11 = (*v9)(v3 + 64, v4, v12);
          if ((_DWORD)v11)
            goto LABEL_26;
          if (*v6)
          {
            v14 = *(_DWORD *)(v3 + 56);
            if (v14 == 4)
            {
              _ktxSwapEndian32(v4, (unint64_t)v16.u32[0] >> 2);
            }
            else if (v14 == 2)
            {
              _ktxSwapEndian16(v4, (unint64_t)v16.u32[0] >> 1);
            }
          }
          v4 = (int8x16_t *)((char *)v4 + v12);
        }
        while (--v13);
      }
      if (++v10 >= *(_DWORD *)(a1 + 52))
        goto LABEL_27;
    }
LABEL_26:
    v8 = v11;
  }
  else
  {
LABEL_27:
    v8 = 0;
  }
  (*(void (**)(uint64_t))(v3 + 112))(v3 + 64);
  return v8;
}

void ktxTexture1_destruct(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 136);
  if (v2)
    free(v2);
  ktxTexture_destruct(a1);
}

uint64_t ktxTexture1_Create(int *a1, int a2, _QWORD *a3)
{
  _OWORD *v6;
  _QWORD *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v12;
  __int128 v13;
  _BYTE *v14;
  uint64_t v15;
  char v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  size_t v22;
  void *v23;
  __int128 v24[2];

  if (!a3)
    return 11;
  v6 = malloc_type_malloc(0x90uLL, 0x10300406A34F8ACuLL);
  if (!v6)
    return 13;
  v7 = v6;
  memset(v24, 0, sizeof(v24));
  *v6 = 0u;
  v6[1] = 0u;
  v6[2] = 0u;
  v6[3] = 0u;
  v6[4] = 0u;
  v6[5] = 0u;
  v6[7] = 0u;
  v6[8] = 0u;
  v6[6] = 0u;
  v8 = *a1;
  *((_DWORD *)v6 + 31) = *a1;
  glGetFormatSize(v8, (uint64_t)v24);
  if (DWORD2(v24[0]))
  {
    v9 = 6403;
    v10 = 11;
    if (v8 > 36165)
    {
      if (v8 > 37174)
      {
        switch(v8)
        {
          case 37488:
          case 37489:
            goto LABEL_39;
          case 37490:
          case 37491:
            goto LABEL_24;
          case 37492:
          case 37493:
            goto LABEL_38;
          case 37494:
          case 37495:
          case 37496:
          case 37497:
          case 37808:
          case 37809:
          case 37810:
          case 37811:
          case 37812:
          case 37813:
          case 37814:
          case 37815:
          case 37816:
          case 37817:
          case 37818:
          case 37819:
          case 37820:
          case 37821:
          case 37824:
          case 37825:
          case 37826:
          case 37827:
          case 37828:
          case 37829:
          case 37830:
          case 37831:
          case 37832:
          case 37833:
          case 37840:
          case 37841:
          case 37842:
          case 37843:
          case 37844:
          case 37845:
          case 37846:
          case 37847:
          case 37848:
          case 37849:
          case 37850:
          case 37851:
          case 37852:
          case 37853:
          case 37856:
          case 37857:
          case 37858:
          case 37859:
          case 37860:
          case 37861:
          case 37862:
          case 37863:
          case 37864:
          case 37865:
          case 37872:
          case 37873:
            goto LABEL_7;
          case 37498:
          case 37499:
          case 37500:
          case 37501:
          case 37502:
          case 37503:
          case 37504:
          case 37505:
          case 37506:
          case 37507:
          case 37508:
          case 37509:
          case 37510:
          case 37511:
          case 37512:
          case 37513:
          case 37514:
          case 37515:
          case 37516:
          case 37517:
          case 37518:
          case 37519:
          case 37520:
          case 37521:
          case 37522:
          case 37523:
          case 37524:
          case 37525:
          case 37526:
          case 37527:
          case 37528:
          case 37529:
          case 37530:
          case 37531:
          case 37532:
          case 37533:
          case 37534:
          case 37535:
          case 37536:
          case 37537:
          case 37538:
          case 37539:
          case 37540:
          case 37541:
          case 37542:
          case 37543:
          case 37544:
          case 37545:
          case 37546:
          case 37547:
          case 37548:
          case 37549:
          case 37550:
          case 37551:
          case 37552:
          case 37553:
          case 37554:
          case 37555:
          case 37556:
          case 37557:
          case 37558:
          case 37559:
          case 37560:
          case 37561:
          case 37562:
          case 37563:
          case 37564:
          case 37565:
          case 37566:
          case 37567:
          case 37568:
          case 37569:
          case 37570:
          case 37571:
          case 37572:
          case 37573:
          case 37574:
          case 37575:
          case 37576:
          case 37577:
          case 37578:
          case 37579:
          case 37580:
          case 37581:
          case 37582:
          case 37583:
          case 37584:
          case 37585:
          case 37586:
          case 37587:
          case 37588:
          case 37589:
          case 37590:
          case 37591:
          case 37592:
          case 37593:
          case 37594:
          case 37595:
          case 37596:
          case 37597:
          case 37598:
          case 37599:
          case 37600:
          case 37601:
          case 37602:
          case 37603:
          case 37604:
          case 37605:
          case 37606:
          case 37607:
          case 37608:
          case 37609:
          case 37610:
          case 37611:
          case 37612:
          case 37613:
          case 37614:
          case 37615:
          case 37616:
          case 37617:
          case 37618:
          case 37619:
          case 37620:
          case 37621:
          case 37622:
          case 37623:
          case 37624:
          case 37625:
          case 37626:
          case 37627:
          case 37628:
          case 37629:
          case 37630:
          case 37631:
          case 37632:
          case 37633:
          case 37634:
          case 37635:
          case 37636:
          case 37637:
          case 37638:
          case 37639:
          case 37640:
          case 37641:
          case 37642:
          case 37643:
          case 37644:
          case 37645:
          case 37646:
          case 37647:
          case 37648:
          case 37649:
          case 37650:
          case 37651:
          case 37652:
          case 37653:
          case 37654:
          case 37655:
          case 37656:
          case 37657:
          case 37658:
          case 37659:
          case 37660:
          case 37661:
          case 37662:
          case 37663:
          case 37664:
          case 37665:
          case 37666:
          case 37667:
          case 37668:
          case 37669:
          case 37670:
          case 37671:
          case 37672:
          case 37673:
          case 37674:
          case 37675:
          case 37676:
          case 37677:
          case 37678:
          case 37679:
          case 37680:
          case 37681:
          case 37682:
          case 37683:
          case 37684:
          case 37685:
          case 37686:
          case 37687:
          case 37688:
          case 37689:
          case 37690:
          case 37691:
          case 37692:
          case 37693:
          case 37694:
          case 37695:
          case 37696:
          case 37697:
          case 37698:
          case 37699:
          case 37700:
          case 37701:
          case 37702:
          case 37703:
          case 37704:
          case 37705:
          case 37706:
          case 37707:
          case 37708:
          case 37709:
          case 37710:
          case 37711:
          case 37712:
          case 37713:
          case 37714:
          case 37715:
          case 37716:
          case 37717:
          case 37718:
          case 37719:
          case 37720:
          case 37721:
          case 37722:
          case 37723:
          case 37724:
          case 37725:
          case 37726:
          case 37727:
          case 37728:
          case 37729:
          case 37730:
          case 37731:
          case 37732:
          case 37733:
          case 37734:
          case 37735:
          case 37736:
          case 37737:
          case 37738:
          case 37739:
          case 37740:
          case 37741:
          case 37742:
          case 37743:
          case 37744:
          case 37745:
          case 37746:
          case 37747:
          case 37748:
          case 37749:
          case 37750:
          case 37751:
          case 37752:
          case 37753:
          case 37754:
          case 37755:
          case 37756:
          case 37757:
          case 37758:
          case 37759:
          case 37760:
          case 37761:
          case 37762:
          case 37763:
          case 37764:
          case 37765:
          case 37766:
          case 37767:
          case 37768:
          case 37769:
          case 37770:
          case 37771:
          case 37772:
          case 37773:
          case 37774:
          case 37775:
          case 37776:
          case 37777:
          case 37778:
          case 37779:
          case 37780:
          case 37781:
          case 37782:
          case 37783:
          case 37784:
          case 37785:
          case 37786:
          case 37787:
          case 37788:
          case 37789:
          case 37790:
          case 37791:
          case 37792:
          case 37793:
          case 37794:
          case 37795:
          case 37796:
          case 37797:
          case 37798:
          case 37799:
          case 37800:
          case 37801:
          case 37802:
          case 37803:
          case 37804:
          case 37805:
          case 37806:
          case 37807:
          case 37822:
          case 37823:
          case 37834:
          case 37835:
          case 37836:
          case 37837:
          case 37838:
          case 37839:
          case 37854:
          case 37855:
          case 37866:
          case 37867:
          case 37868:
          case 37869:
          case 37870:
          case 37871:
            goto LABEL_40;
          default:
            if (v8 != 37175 && v8 != 37176)
              goto LABEL_40;
            goto LABEL_7;
        }
      }
      if (v8 <= 36491)
      {
        switch(v8)
        {
          case 36166:
          case 36167:
          case 36168:
          case 36169:
            v9 = 6401;
            v10 = ktxTexture_construct((uint64_t)v7, (uint64_t)a1, v24);
            if (!(_DWORD)v10)
              goto LABEL_44;
            goto LABEL_40;
          case 36194:
          case 36196:
          case 36209:
          case 36215:
          case 36221:
          case 36227:
          case 36233:
          case 36239:
            goto LABEL_38;
          case 36208:
          case 36214:
          case 36220:
          case 36226:
          case 36232:
          case 36238:
            goto LABEL_7;
          case 36267:
            goto LABEL_21;
          case 36268:
            goto LABEL_43;
          case 36283:
          case 36284:
            goto LABEL_39;
          case 36285:
          case 36286:
            goto LABEL_24;
          default:
            goto LABEL_40;
        }
      }
      switch(v8)
      {
        case 36756:
        case 36760:
        case 36797:
          goto LABEL_39;
        case 36757:
        case 36761:
        case 36798:
          goto LABEL_24;
        case 36758:
        case 36762:
          goto LABEL_38;
        case 36759:
        case 36763:
          goto LABEL_7;
        case 36764:
        case 36765:
        case 36766:
        case 36767:
        case 36768:
        case 36769:
        case 36770:
        case 36771:
        case 36772:
        case 36773:
        case 36774:
        case 36775:
        case 36776:
        case 36777:
        case 36778:
        case 36779:
        case 36780:
        case 36781:
        case 36782:
        case 36783:
        case 36784:
        case 36785:
        case 36786:
        case 36787:
        case 36788:
        case 36789:
        case 36790:
        case 36791:
        case 36792:
        case 36793:
        case 36794:
        case 36795:
        case 36796:
          goto LABEL_40;
        default:
          switch(v8)
          {
            case 36492:
            case 36493:
              goto LABEL_7;
            case 36494:
            case 36495:
              goto LABEL_38;
            default:
              if (v8 != 36975)
                goto LABEL_40;
              goto LABEL_7;
          }
      }
    }
    if (v8 <= 34797)
    {
      if (v8 > 33188)
      {
        switch(v8)
        {
          case 33189:
          case 33190:
          case 33191:
            goto LABEL_21;
          case 33192:
          case 33193:
          case 33194:
          case 33195:
          case 33196:
          case 33197:
          case 33198:
          case 33199:
          case 33200:
          case 33201:
          case 33202:
          case 33203:
          case 33204:
          case 33205:
          case 33206:
          case 33207:
          case 33208:
          case 33209:
          case 33210:
          case 33211:
          case 33212:
          case 33213:
          case 33214:
          case 33215:
          case 33216:
          case 33217:
          case 33218:
          case 33219:
          case 33220:
          case 33221:
          case 33222:
          case 33223:
          case 33224:
          case 33225:
          case 33226:
          case 33227:
          case 33228:
          case 33229:
          case 33230:
          case 33231:
          case 33232:
          case 33233:
          case 33234:
          case 33235:
          case 33236:
          case 33237:
          case 33238:
          case 33239:
          case 33240:
          case 33241:
          case 33242:
          case 33243:
          case 33244:
          case 33245:
          case 33246:
          case 33247:
          case 33248:
          case 33249:
          case 33250:
          case 33251:
          case 33252:
          case 33253:
          case 33254:
          case 33255:
          case 33256:
          case 33257:
          case 33258:
          case 33259:
          case 33260:
          case 33261:
          case 33262:
          case 33263:
          case 33264:
          case 33265:
          case 33266:
          case 33267:
          case 33268:
          case 33269:
          case 33270:
          case 33271:
          case 33272:
          case 33273:
          case 33274:
          case 33275:
          case 33276:
          case 33277:
          case 33278:
          case 33279:
          case 33280:
          case 33281:
          case 33282:
          case 33283:
          case 33284:
          case 33285:
          case 33286:
          case 33287:
          case 33288:
          case 33289:
          case 33290:
          case 33291:
          case 33292:
          case 33293:
          case 33294:
          case 33295:
          case 33296:
          case 33297:
          case 33298:
          case 33299:
          case 33300:
          case 33301:
          case 33302:
          case 33303:
          case 33304:
          case 33305:
          case 33306:
          case 33307:
          case 33308:
          case 33309:
          case 33310:
          case 33311:
          case 33312:
          case 33313:
          case 33314:
          case 33315:
          case 33316:
          case 33317:
          case 33318:
          case 33319:
          case 33320:
            goto LABEL_40;
          case 33321:
          case 33322:
          case 33325:
          case 33326:
          case 33329:
          case 33330:
          case 33331:
          case 33332:
          case 33333:
          case 33334:
            goto LABEL_39;
          case 33323:
          case 33324:
          case 33327:
          case 33328:
          case 33335:
          case 33336:
          case 33337:
          case 33338:
          case 33339:
          case 33340:
            goto LABEL_24;
          default:
            switch(v8)
            {
              case 33776:
                goto LABEL_38;
              case 33777:
              case 33778:
              case 33779:
                goto LABEL_7;
              default:
                goto LABEL_40;
            }
        }
      }
      switch(v8)
      {
        case 32847:
        case 32848:
        case 32849:
        case 32850:
        case 32851:
        case 32852:
          goto LABEL_38;
        case 32853:
        case 32854:
        case 32855:
        case 32856:
        case 32857:
        case 32858:
        case 32859:
          goto LABEL_7;
        default:
          if (v8 == 10768)
            goto LABEL_38;
          goto LABEL_40;
      }
    }
    if (v8 > 35727)
    {
      switch(v8)
      {
        case 35728:
        case 35730:
        case 35733:
        case 35735:
        case 35840:
        case 35841:
        case 35898:
        case 35901:
        case 35905:
        case 35916:
        case 35986:
          goto LABEL_38;
        case 35729:
        case 35731:
        case 35732:
        case 35734:
        case 35736:
        case 35737:
        case 35842:
        case 35843:
        case 35907:
        case 35917:
        case 35918:
        case 35919:
        case 35987:
          goto LABEL_7;
        case 35952:
        case 35953:
          goto LABEL_39;
        case 35954:
        case 35955:
LABEL_24:
          v9 = 33319;
          v10 = ktxTexture_construct((uint64_t)v7, (uint64_t)a1, v24);
          if (!(_DWORD)v10)
            goto LABEL_44;
          goto LABEL_40;
        case 36012:
LABEL_21:
          v9 = 6402;
          v10 = ktxTexture_construct((uint64_t)v7, (uint64_t)a1, v24);
          if (!(_DWORD)v10)
            goto LABEL_44;
          goto LABEL_40;
        case 36013:
          goto LABEL_43;
        default:
          goto LABEL_40;
      }
    }
    switch(v8)
    {
      case 34798:
      case 34836:
      case 34842:
LABEL_7:
        v9 = 6408;
        v10 = ktxTexture_construct((uint64_t)v7, (uint64_t)a1, v24);
        if (!(_DWORD)v10)
          goto LABEL_44;
        break;
      case 34799:
      case 34800:
      case 34801:
      case 34802:
      case 34803:
      case 34804:
      case 34805:
      case 34806:
      case 34807:
      case 34808:
      case 34809:
      case 34810:
      case 34811:
      case 34812:
      case 34813:
      case 34814:
      case 34815:
      case 34816:
      case 34817:
      case 34818:
      case 34819:
      case 34820:
      case 34821:
      case 34822:
      case 34823:
      case 34824:
      case 34825:
      case 34826:
      case 34827:
      case 34828:
      case 34829:
      case 34830:
      case 34831:
      case 34832:
      case 34833:
      case 34834:
      case 34835:
      case 34838:
      case 34839:
      case 34840:
      case 34841:
        break;
      case 34837:
      case 34843:
LABEL_38:
        v9 = 6407;
LABEL_39:
        v10 = ktxTexture_construct((uint64_t)v7, (uint64_t)a1, v24);
        if ((_DWORD)v10)
          break;
LABEL_44:
        *(_DWORD *)v7 = 1;
        v7[1] = ktxTexture1_vtbl;
        v12 = v7[3];
        v13 = ktxTexture1_vtblInt;
        *(uint64_t (**)())(v12 + 16) = off_1EDF008F8[0];
        *(_OWORD *)v12 = v13;
        v14 = malloc_type_malloc(1uLL, 0x100004077774924uLL);
        v7[17] = v14;
        if (!v14)
        {
          v10 = 13;
          break;
        }
        *v14 = 0;
        v15 = v7[3];
        v16 = v24[0];
        *((_BYTE *)v7 + 34) = (v24[0] & 2) != 0;
        if ((v16 & 2) != 0)
        {
          v21 = 0;
          *((_DWORD *)v7 + 30) = 0;
          *((_DWORD *)v7 + 32) = v9;
          v20 = 1;
        }
        else
        {
          *((_DWORD *)v7 + 30) = v9;
          *((_DWORD *)v7 + 32) = v9;
          v17 = *a1;
          v18 = 5125;
          v19 = 5123;
          v20 = 1;
          v21 = 5121;
          if (*a1 > 36165)
          {
            if (v17 > 36974)
            {
              switch(v17)
              {
                case 37488:
                case 37489:
                case 37490:
                case 37491:
                case 37492:
                case 37493:
                case 37494:
                case 37495:
                case 37496:
                case 37497:
                case 37808:
                case 37809:
                case 37810:
                case 37811:
                case 37812:
                case 37813:
                case 37814:
                case 37815:
                case 37816:
                case 37817:
                case 37818:
                case 37819:
                case 37820:
                case 37821:
                case 37824:
                case 37825:
                case 37826:
                case 37827:
                case 37828:
                case 37829:
                case 37830:
                case 37831:
                case 37832:
                case 37833:
                case 37840:
                case 37841:
                case 37842:
                case 37843:
                case 37844:
                case 37845:
                case 37846:
                case 37847:
                case 37848:
                case 37849:
                case 37850:
                case 37851:
                case 37852:
                case 37853:
                case 37856:
                case 37857:
                case 37858:
                case 37859:
                case 37860:
                case 37861:
                case 37862:
                case 37863:
                case 37864:
                case 37865:
                case 37872:
                case 37873:
                  goto LABEL_51;
                case 37498:
                case 37499:
                case 37500:
                case 37501:
                case 37502:
                case 37503:
                case 37504:
                case 37505:
                case 37506:
                case 37507:
                case 37508:
                case 37509:
                case 37510:
                case 37511:
                case 37512:
                case 37513:
                case 37514:
                case 37515:
                case 37516:
                case 37517:
                case 37518:
                case 37519:
                case 37520:
                case 37521:
                case 37522:
                case 37523:
                case 37524:
                case 37525:
                case 37526:
                case 37527:
                case 37528:
                case 37529:
                case 37530:
                case 37531:
                case 37532:
                case 37533:
                case 37534:
                case 37535:
                case 37536:
                case 37537:
                case 37538:
                case 37539:
                case 37540:
                case 37541:
                case 37542:
                case 37543:
                case 37544:
                case 37545:
                case 37546:
                case 37547:
                case 37548:
                case 37549:
                case 37550:
                case 37551:
                case 37552:
                case 37553:
                case 37554:
                case 37555:
                case 37556:
                case 37557:
                case 37558:
                case 37559:
                case 37560:
                case 37561:
                case 37562:
                case 37563:
                case 37564:
                case 37565:
                case 37566:
                case 37567:
                case 37568:
                case 37569:
                case 37570:
                case 37571:
                case 37572:
                case 37573:
                case 37574:
                case 37575:
                case 37576:
                case 37577:
                case 37578:
                case 37579:
                case 37580:
                case 37581:
                case 37582:
                case 37583:
                case 37584:
                case 37585:
                case 37586:
                case 37587:
                case 37588:
                case 37589:
                case 37590:
                case 37591:
                case 37592:
                case 37593:
                case 37594:
                case 37595:
                case 37596:
                case 37597:
                case 37598:
                case 37599:
                case 37600:
                case 37601:
                case 37602:
                case 37603:
                case 37604:
                case 37605:
                case 37606:
                case 37607:
                case 37608:
                case 37609:
                case 37610:
                case 37611:
                case 37612:
                case 37613:
                case 37614:
                case 37615:
                case 37616:
                case 37617:
                case 37618:
                case 37619:
                case 37620:
                case 37621:
                case 37622:
                case 37623:
                case 37624:
                case 37625:
                case 37626:
                case 37627:
                case 37628:
                case 37629:
                case 37630:
                case 37631:
                case 37632:
                case 37633:
                case 37634:
                case 37635:
                case 37636:
                case 37637:
                case 37638:
                case 37639:
                case 37640:
                case 37641:
                case 37642:
                case 37643:
                case 37644:
                case 37645:
                case 37646:
                case 37647:
                case 37648:
                case 37649:
                case 37650:
                case 37651:
                case 37652:
                case 37653:
                case 37654:
                case 37655:
                case 37656:
                case 37657:
                case 37658:
                case 37659:
                case 37660:
                case 37661:
                case 37662:
                case 37663:
                case 37664:
                case 37665:
                case 37666:
                case 37667:
                case 37668:
                case 37669:
                case 37670:
                case 37671:
                case 37672:
                case 37673:
                case 37674:
                case 37675:
                case 37676:
                case 37677:
                case 37678:
                case 37679:
                case 37680:
                case 37681:
                case 37682:
                case 37683:
                case 37684:
                case 37685:
                case 37686:
                case 37687:
                case 37688:
                case 37689:
                case 37690:
                case 37691:
                case 37692:
                case 37693:
                case 37694:
                case 37695:
                case 37696:
                case 37697:
                case 37698:
                case 37699:
                case 37700:
                case 37701:
                case 37702:
                case 37703:
                case 37704:
                case 37705:
                case 37706:
                case 37707:
                case 37708:
                case 37709:
                case 37710:
                case 37711:
                case 37712:
                case 37713:
                case 37714:
                case 37715:
                case 37716:
                case 37717:
                case 37718:
                case 37719:
                case 37720:
                case 37721:
                case 37722:
                case 37723:
                case 37724:
                case 37725:
                case 37726:
                case 37727:
                case 37728:
                case 37729:
                case 37730:
                case 37731:
                case 37732:
                case 37733:
                case 37734:
                case 37735:
                case 37736:
                case 37737:
                case 37738:
                case 37739:
                case 37740:
                case 37741:
                case 37742:
                case 37743:
                case 37744:
                case 37745:
                case 37746:
                case 37747:
                case 37748:
                case 37749:
                case 37750:
                case 37751:
                case 37752:
                case 37753:
                case 37754:
                case 37755:
                case 37756:
                case 37757:
                case 37758:
                case 37759:
                case 37760:
                case 37761:
                case 37762:
                case 37763:
                case 37764:
                case 37765:
                case 37766:
                case 37767:
                case 37768:
                case 37769:
                case 37770:
                case 37771:
                case 37772:
                case 37773:
                case 37774:
                case 37775:
                case 37776:
                case 37777:
                case 37778:
                case 37779:
                case 37780:
                case 37781:
                case 37782:
                case 37783:
                case 37784:
                case 37785:
                case 37786:
                case 37787:
                case 37788:
                case 37789:
                case 37790:
                case 37791:
                case 37792:
                case 37793:
                case 37794:
                case 37795:
                case 37796:
                case 37797:
                case 37798:
                case 37799:
                case 37800:
                case 37801:
                case 37802:
                case 37803:
                case 37804:
                case 37805:
                case 37806:
                case 37807:
                case 37822:
                case 37823:
                case 37834:
                case 37835:
                case 37836:
                case 37837:
                case 37838:
                case 37839:
                case 37854:
                case 37855:
                case 37866:
                case 37867:
                case 37868:
                case 37869:
                case 37870:
                case 37871:
                  goto LABEL_95;
                default:
                  if ((v17 - 37175) < 2)
                    goto LABEL_51;
                  if (v17 == 36975)
                    goto LABEL_82;
                  goto LABEL_95;
              }
            }
            if (v17 <= 36493)
            {
              switch(v17)
              {
                case 36166:
                case 36167:
                case 36168:
                case 36196:
                case 36220:
                case 36221:
                case 36283:
                case 36284:
                case 36285:
                case 36286:
                  goto LABEL_51;
                case 36169:
                case 36214:
                case 36215:
                  goto LABEL_79;
                case 36170:
                case 36171:
                case 36172:
                case 36173:
                case 36174:
                case 36175:
                case 36176:
                case 36177:
                case 36178:
                case 36179:
                case 36180:
                case 36181:
                case 36182:
                case 36183:
                case 36184:
                case 36185:
                case 36186:
                case 36187:
                case 36188:
                case 36189:
                case 36190:
                case 36191:
                case 36192:
                case 36193:
                case 36195:
                case 36197:
                case 36198:
                case 36199:
                case 36200:
                case 36201:
                case 36202:
                case 36203:
                case 36204:
                case 36205:
                case 36206:
                case 36207:
                case 36210:
                case 36211:
                case 36212:
                case 36213:
                case 36216:
                case 36217:
                case 36218:
                case 36219:
                case 36222:
                case 36223:
                case 36224:
                case 36225:
                case 36228:
                case 36229:
                case 36230:
                case 36231:
                case 36234:
                case 36235:
                case 36236:
                case 36237:
                case 36240:
                case 36241:
                case 36242:
                case 36243:
                case 36244:
                case 36245:
                case 36246:
                case 36247:
                case 36248:
                case 36249:
                case 36250:
                case 36251:
                case 36252:
                case 36253:
                case 36254:
                case 36255:
                case 36256:
                case 36257:
                case 36258:
                case 36259:
                case 36260:
                case 36261:
                case 36262:
                case 36263:
                case 36264:
                case 36265:
                case 36266:
                case 36269:
                case 36270:
                case 36271:
                case 36272:
                case 36273:
                case 36274:
                case 36275:
                case 36276:
                case 36277:
                case 36278:
                case 36279:
                case 36280:
                case 36281:
                case 36282:
                  goto LABEL_95;
                case 36194:
                  goto LABEL_64;
                case 36208:
                case 36209:
                  goto LABEL_86;
                case 36226:
                case 36227:
                  goto LABEL_61;
                case 36232:
                case 36233:
                  goto LABEL_73;
                case 36238:
                case 36239:
                  goto LABEL_66;
                case 36267:
                  goto LABEL_85;
                case 36268:
                  goto LABEL_89;
                default:
                  if ((v17 - 36492) >= 2)
                    goto LABEL_95;
                  goto LABEL_51;
              }
            }
            switch(v17)
            {
              case 36756:
              case 36757:
              case 36758:
              case 36759:
                goto LABEL_66;
              case 36760:
              case 36761:
              case 36762:
              case 36763:
                goto LABEL_73;
              case 36764:
              case 36765:
              case 36766:
              case 36767:
              case 36768:
              case 36769:
              case 36770:
              case 36771:
              case 36772:
              case 36773:
              case 36774:
              case 36775:
              case 36776:
              case 36777:
              case 36778:
              case 36779:
              case 36780:
              case 36781:
              case 36782:
              case 36783:
              case 36784:
              case 36785:
              case 36786:
              case 36787:
              case 36788:
              case 36789:
              case 36790:
              case 36791:
              case 36792:
              case 36793:
              case 36794:
              case 36795:
              case 36796:
                goto LABEL_95;
              case 36797:
              case 36798:
                goto LABEL_51;
              default:
                if (v17 == 36494 || v17 == 36495)
                  goto LABEL_85;
                goto LABEL_95;
            }
          }
          if (v17 > 34797)
          {
            if (v17 > 35727)
            {
              switch(v17)
              {
                case 35728:
                case 35729:
                case 35733:
                case 35734:
                case 35840:
                case 35841:
                case 35842:
                case 35843:
                case 35905:
                case 35907:
                case 35916:
                case 35917:
                case 35918:
                case 35919:
                case 35952:
                case 35953:
                case 35954:
                case 35955:
                case 35986:
                case 35987:
                  goto LABEL_51;
                case 35730:
                case 35735:
LABEL_64:
                  v19 = 33635;
                  goto LABEL_79;
                case 35731:
                case 35736:
LABEL_68:
                  v19 = 32819;
                  goto LABEL_79;
                case 35732:
                case 35737:
LABEL_78:
                  v19 = 32820;
                  goto LABEL_79;
                case 35898:
                  v18 = 35899;
                  goto LABEL_86;
                case 35901:
                  v18 = 35902;
                  goto LABEL_86;
                case 36012:
                  goto LABEL_85;
                case 36013:
LABEL_89:
                  v18 = 36269;
                  goto LABEL_86;
                default:
                  goto LABEL_95;
              }
            }
            switch(v17)
            {
              case 34798:
                break;
              case 34799:
              case 34800:
              case 34801:
              case 34802:
              case 34803:
              case 34804:
              case 34805:
              case 34806:
              case 34807:
              case 34808:
              case 34809:
              case 34810:
              case 34811:
              case 34812:
              case 34813:
              case 34814:
              case 34815:
              case 34816:
              case 34817:
              case 34818:
              case 34819:
              case 34820:
              case 34821:
              case 34822:
              case 34823:
              case 34824:
              case 34825:
              case 34826:
              case 34827:
              case 34828:
              case 34829:
              case 34830:
              case 34831:
              case 34832:
              case 34833:
              case 34834:
              case 34835:
              case 34838:
              case 34839:
              case 34840:
              case 34841:
                goto LABEL_95;
              case 34836:
              case 34837:
LABEL_85:
                v18 = 5126;
                goto LABEL_86;
              case 34842:
              case 34843:
LABEL_75:
                v19 = 5131;
LABEL_79:
                v20 = 2;
                v21 = v19;
                break;
              default:
                if ((v17 - 35412) < 4)
                  break;
                if (v17 != 35056)
                {
LABEL_95:
                  *((_DWORD *)v7 + 33) = 1281;
                  v10 = 11;
                  goto LABEL_58;
                }
LABEL_72:
                v18 = 34042;
LABEL_86:
                v20 = 4;
                v21 = v18;
                break;
            }
          }
          else
          {
            if (v17 > 33188)
            {
              switch(v17)
              {
                case 33189:
                case 33322:
                case 33324:
                case 33332:
                case 33338:
                  goto LABEL_79;
                case 33190:
                  goto LABEL_72;
                case 33191:
                case 33334:
                case 33340:
                  goto LABEL_86;
                case 33192:
                case 33193:
                case 33194:
                case 33195:
                case 33196:
                case 33197:
                case 33198:
                case 33199:
                case 33200:
                case 33201:
                case 33202:
                case 33203:
                case 33204:
                case 33205:
                case 33206:
                case 33207:
                case 33208:
                case 33209:
                case 33210:
                case 33211:
                case 33212:
                case 33213:
                case 33214:
                case 33215:
                case 33216:
                case 33217:
                case 33218:
                case 33219:
                case 33220:
                case 33221:
                case 33222:
                case 33223:
                case 33224:
                case 33225:
                case 33226:
                case 33227:
                case 33228:
                case 33229:
                case 33230:
                case 33231:
                case 33232:
                case 33233:
                case 33234:
                case 33235:
                case 33236:
                case 33237:
                case 33238:
                case 33239:
                case 33240:
                case 33241:
                case 33242:
                case 33243:
                case 33244:
                case 33245:
                case 33246:
                case 33247:
                case 33248:
                case 33249:
                case 33250:
                case 33251:
                case 33252:
                case 33253:
                case 33254:
                case 33255:
                case 33256:
                case 33257:
                case 33258:
                case 33259:
                case 33260:
                case 33261:
                case 33262:
                case 33263:
                case 33264:
                case 33265:
                case 33266:
                case 33267:
                case 33268:
                case 33269:
                case 33270:
                case 33271:
                case 33272:
                case 33273:
                case 33274:
                case 33275:
                case 33276:
                case 33277:
                case 33278:
                case 33279:
                case 33280:
                case 33281:
                case 33282:
                case 33283:
                case 33284:
                case 33285:
                case 33286:
                case 33287:
                case 33288:
                case 33289:
                case 33290:
                case 33291:
                case 33292:
                case 33293:
                case 33294:
                case 33295:
                case 33296:
                case 33297:
                case 33298:
                case 33299:
                case 33300:
                case 33301:
                case 33302:
                case 33303:
                case 33304:
                case 33305:
                case 33306:
                case 33307:
                case 33308:
                case 33309:
                case 33310:
                case 33311:
                case 33312:
                case 33313:
                case 33314:
                case 33315:
                case 33316:
                case 33317:
                case 33318:
                case 33319:
                case 33320:
                  goto LABEL_95;
                case 33321:
                case 33323:
                case 33330:
                case 33336:
                  goto LABEL_51;
                case 33325:
                case 33327:
                  goto LABEL_75;
                case 33326:
                case 33328:
                  goto LABEL_85;
                case 33329:
                case 33335:
LABEL_66:
                  v21 = 5120;
                  goto LABEL_51;
                case 33331:
                case 33337:
LABEL_73:
                  v19 = 5122;
                  goto LABEL_79;
                case 33333:
                case 33339:
LABEL_61:
                  v18 = 5124;
                  goto LABEL_86;
                default:
                  if ((v17 - 33776) >= 4)
                    goto LABEL_95;
                  goto LABEL_51;
              }
            }
            switch(v17)
            {
              case 32847:
              case 32854:
                goto LABEL_68;
              case 32848:
              case 32855:
                goto LABEL_78;
              case 32849:
              case 32853:
              case 32856:
                break;
              case 32850:
                v18 = 32822;
                goto LABEL_86;
              case 32851:
              case 32852:
              case 32858:
              case 32859:
                goto LABEL_79;
              case 32857:
LABEL_82:
                v18 = 33640;
                goto LABEL_86;
              default:
                if (v17 != 10768)
                  goto LABEL_95;
                v20 = 1;
                v21 = 33634;
                break;
            }
          }
        }
LABEL_51:
        *((_DWORD *)v7 + 33) = v21;
        *(_DWORD *)(v15 + 56) = v20;
        if (a2 != 1
          || (v22 = ktxTexture_calcDataSizeTexture((uint64_t)v7),
              v7[13] = v22,
              v23 = malloc_type_malloc(v22, 0xB70F38C9uLL),
              (v7[14] = v23) != 0))
        {
          v10 = 0;
          *a3 = v7;
          return v10;
        }
        v10 = 13;
LABEL_58:
        ktxTexture1_destruct((uint64_t)v7);
        ktxTexture_destruct((uint64_t)v7);
        break;
      default:
        switch(v8)
        {
          case 35412:
          case 35413:
            goto LABEL_38;
          case 35414:
          case 35415:
            goto LABEL_7;
          default:
            if (v8 != 35056)
              goto LABEL_40;
LABEL_43:
            v9 = 34041;
            v10 = ktxTexture_construct((uint64_t)v7, (uint64_t)a1, v24);
            if (!(_DWORD)v10)
              goto LABEL_44;
            goto LABEL_40;
        }
    }
  }
  else
  {
    v10 = 16;
  }
LABEL_40:
  free(v7);
  return v10;
}

uint64_t ktxTexture1_CreateFromStdioStream(uint64_t a1, char a2, _QWORD *a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD v11[6];
  uint64_t v12;
  int8x16_t v13[4];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 11;
  v6 = malloc_type_malloc(0x90uLL, 0x10300406A34F8ACuLL);
  if (v6)
  {
    v7 = v6;
    if (a1)
    {
      v12 = 0;
      memset(v11, 0, sizeof(v11));
      v8 = ktxFileStream_construct((uint64_t)v11, a1, 0);
      if (!(_DWORD)v8)
      {
        memset(v13, 0, sizeof(v13));
        v9 = (*(uint64_t (**)(_OWORD *, int8x16_t *, uint64_t))&v11[0])(v11, v13, 64);
        if ((_DWORD)v9)
        {
          v8 = v9;
        }
        else
        {
          v8 = ktxTexture1_constructFromStreamAndHeader((uint64_t)v7, (uint64_t)v11, v13, a2);
          if (!(_DWORD)v8)
            goto LABEL_11;
        }
      }
    }
    else
    {
      v8 = 11;
    }
    free(v7);
    v7 = 0;
LABEL_11:
    *a3 = v7;
    return v8;
  }
  return 13;
}

uint64_t ktxTexture1_CreateFromNamedFile(const char *a1, char a2, _QWORD *a3)
{
  void *v6;
  void *v7;
  FILE *v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD v12[6];
  uint64_t v13;
  int8x16_t v14[4];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 11;
  v6 = malloc_type_malloc(0x90uLL, 0x10300406A34F8ACuLL);
  if (v6)
  {
    v7 = v6;
    if (a1)
    {
      v8 = fopen(a1, "rb");
      if (v8)
      {
        v13 = 0;
        memset(v12, 0, sizeof(v12));
        v9 = ktxFileStream_construct((uint64_t)v12, (uint64_t)v8, 1);
        if (!(_DWORD)v9)
        {
          memset(v14, 0, sizeof(v14));
          v10 = (*(uint64_t (**)(_OWORD *, int8x16_t *, uint64_t))&v12[0])(v12, v14, 64);
          if ((_DWORD)v10)
          {
            v9 = v10;
          }
          else
          {
            v9 = ktxTexture1_constructFromStreamAndHeader((uint64_t)v7, (uint64_t)v12, v14, a2);
            if (!(_DWORD)v9)
              goto LABEL_13;
          }
        }
      }
      else
      {
        v9 = 3;
      }
    }
    else
    {
      v9 = 11;
    }
    free(v7);
    v7 = 0;
LABEL_13:
    *a3 = v7;
    return v9;
  }
  return 13;
}

uint64_t ktxTexture1_CreateFromMemory(uint64_t a1, uint64_t a2, char a3, _QWORD *a4)
{
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD v13[6];
  uint64_t v14;
  int8x16_t v15[4];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 11;
  v8 = malloc_type_malloc(0x90uLL, 0x10300406A34F8ACuLL);
  if (v8)
  {
    v9 = v8;
    v10 = 11;
    if (a1)
    {
      if (a2)
      {
        v14 = 0;
        memset(v13, 0, sizeof(v13));
        v10 = ktxMemStream_construct_ro((uint64_t)v13, a1, a2);
        if (!(_DWORD)v10)
        {
          memset(v15, 0, sizeof(v15));
          v11 = (*(uint64_t (**)(_OWORD *, int8x16_t *, uint64_t))&v13[0])(v13, v15, 64);
          if ((_DWORD)v11)
          {
            v10 = v11;
          }
          else
          {
            v10 = ktxTexture1_constructFromStreamAndHeader((uint64_t)v9, (uint64_t)v13, v15, a3);
            if (!(_DWORD)v10)
            {
LABEL_12:
              *a4 = v9;
              return v10;
            }
          }
        }
      }
    }
    free(v9);
    v9 = 0;
    goto LABEL_12;
  }
  return 13;
}

uint64_t ktxTexture1_CreateFromStream(uint64_t (**a1)(_QWORD, int8x16_t *, uint64_t), char a2, _QWORD *a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  int8x16_t v11[4];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 11;
  v6 = malloc_type_malloc(0x90uLL, 0x10300406A34F8ACuLL);
  if (v6)
  {
    v7 = v6;
    memset(v11, 0, sizeof(v11));
    v8 = (*a1)(a1, v11, 64);
    if ((_DWORD)v8)
    {
      v9 = v8;
    }
    else
    {
      v9 = ktxTexture1_constructFromStreamAndHeader((uint64_t)v7, (uint64_t)a1, v11, a2);
      if (!(_DWORD)v9)
      {
LABEL_9:
        *a3 = v7;
        return v9;
      }
    }
    free(v7);
    v7 = 0;
    goto LABEL_9;
  }
  return 13;
}

void ktxTexture1_Destroy(_QWORD *a1)
{
  void *v2;

  v2 = (void *)a1[17];
  if (v2)
    free(v2);
  ktxTexture_destruct((uint64_t)a1);
  free(a1);
}

uint64_t ktxTexture1_calcDataSizeLevels(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;

  if (!a2)
    return 0;
  v4 = 0;
  v5 = 0;
  do
    v5 += ktxTexture_calcLevelSize(a1, v4++, 1);
  while (a2 != v4);
  return v5;
}

unint64_t ktxTexture1_calcFaceLodSize(uint64_t a1, char a2)
{
  return ktxTexture_doCalcFaceLodSize(a1, a2, 1);
}

uint64_t ktxTexture1_calcLevelOffset(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;

  if (!a2)
    return 0;
  v4 = 0;
  v5 = 0;
  do
    v5 += ktxTexture_calcLevelSize(a1, v4++, 1);
  while (a2 != v4);
  return v5;
}

uint64_t ktxTexture1_GetImageOffset(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, _QWORD *a5)
{
  uint64_t v10;
  uint64_t result;
  unsigned int v12;

  if (!a1)
    return 11;
  if (*(_DWORD *)(a1 + 52) <= a2 || *(_DWORD *)(a1 + 56) <= a3)
    return 10;
  if (!*(_BYTE *)(a1 + 33))
  {
    v12 = *(_DWORD *)(a1 + 44) >> a2;
    if (v12 <= 1)
      v12 = 1;
    if (v12 > a4)
      goto LABEL_6;
    return 10;
  }
  if (*(_DWORD *)(a1 + 60) <= a4)
    return 10;
LABEL_6:
  *a5 = (**(uint64_t (***)(uint64_t, uint64_t))(a1 + 24))(a1, a2);
  if (a3)
    *a5 += ktxTexture_layerSize(a1, a2, 1) * a3;
  if (!a4)
    return 0;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, a2);
  result = 0;
  *a5 += v10 * a4;
  return result;
}

uint64_t ktxTexture1_GetDataSizeUncompressed(uint64_t a1)
{
  return *(_QWORD *)(a1 + 104);
}

uint64_t ktxTexture1_GetImageSize(uint64_t a1, char a2)
{
  return ktxTexture_calcImageSize(a1, a2, 1);
}

uint64_t ktxTexture1_glTypeSize(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 24) + 56);
}

uint64_t ktxTexture1_IterateLevels(uint64_t a1, uint64_t (*a2)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t), uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;

  result = 11;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 52))
    {
      v7 = 0;
      while (1)
      {
        v15 = 0;
        v8 = *(_DWORD *)(a1 + 40);
        v9 = *(_DWORD *)(a1 + 36) >> v7;
        v10 = v9 <= 1 ? 1 : v9;
        v11 = v8 >> v7 <= 1 ? 1 : v8 >> v7;
        v12 = *(_DWORD *)(a1 + 44) >> v7;
        v13 = v12 <= 1 ? 1 : v12;
        v14 = ktxTexture_calcLevelSize(a1, v7, 1);
        (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t *))(*(_QWORD *)(a1 + 8) + 8))(a1, v7, 0, 0, &v15);
        result = a2(v7, 0, v10, v11, v13, v14, *(_QWORD *)(a1 + 112) + v15, a3);
        if ((_DWORD)result)
          break;
        v7 = (v7 + 1);
        if (v7 >= *(_DWORD *)(a1 + 52))
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ktxTexture1_IterateLoadLevelFaces(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, int8x16_t *, uint64_t), uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t (**v5)(_QWORD, int8x16_t *, uint64_t);
  int8x16_t *v6;
  uint64_t v7;
  unsigned __int32 v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unsigned __int32 v24;
  uint64_t v25;
  _BYTE *v28;
  int8x16_t size;

  if (*(_DWORD *)a1 != 1)
    return 10;
  if (!a2)
    return 11;
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 24);
  if (!*(_QWORD *)(v4 + 128))
    return 10;
  v5 = (uint64_t (**)(_QWORD, int8x16_t *, uint64_t))(v4 + 64);
  v25 = *(_QWORD *)(a1 + 24);
  if (!*(_DWORD *)(a1 + 52))
  {
    v21 = 0;
    v6 = 0;
    goto LABEL_43;
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v28 = *(_BYTE **)(a1 + 136);
  while (1)
  {
LABEL_6:
    size.i32[0] = 0;
    v9 = *(_DWORD *)(v3 + 40);
    v10 = *(_DWORD *)(v3 + 36) >> v7;
    if (v10 <= 1)
      v11 = 1;
    else
      v11 = v10;
    if (v9 >> v7 <= 1)
      v12 = 1;
    else
      v12 = v9 >> v7;
    v13 = *(_DWORD *)(v3 + 44) >> v7;
    if (v13 <= 1)
      v14 = 1;
    else
      v14 = v13;
    v15 = (*v5)(v5, &size, 4);
    if ((_DWORD)v15)
      goto LABEL_41;
    if (*v28)
      _ktxSwapEndian32(&size, 1uLL);
    v16 = size.u32[0];
    if (!v6)
      break;
    if (v8 < size.i32[0])
    {
      v21 = 1;
      goto LABEL_43;
    }
    v24 = v8;
    if (!*(_BYTE *)(v3 + 33))
      goto LABEL_25;
LABEL_24:
    if (*(_BYTE *)(v3 + 32))
    {
LABEL_25:
      v17 = 1;
LABEL_26:
      v18 = 0;
      while (1)
      {
        v15 = (*v5)(v5, v6, v16);
        if ((_DWORD)v15)
          break;
        if (*v28)
        {
          v20 = *(_DWORD *)(v25 + 56);
          if (v20 == 4)
          {
            _ktxSwapEndian32(v6, (unint64_t)size.u32[0] >> 2);
          }
          else if (v20 == 2)
          {
            _ktxSwapEndian16(v6, (unint64_t)size.u32[0] >> 1);
          }
        }
        v19 = a2(v7, v18, v11, v12, v14, size.u32[0], v6, a3);
        v18 = (v18 + 1);
        if (v17 == (_DWORD)v18)
        {
          v21 = v19;
          v3 = a1;
          v7 = (v7 + 1);
          v8 = v24;
          if (v7 < *(_DWORD *)(a1 + 52))
            goto LABEL_6;
          goto LABEL_43;
        }
      }
LABEL_41:
      v21 = v15;
      goto LABEL_43;
    }
    v17 = *(_DWORD *)(v3 + 60);
    if (v17)
      goto LABEL_26;
    v21 = 0;
    v7 = (v7 + 1);
    v8 = v24;
    if (v7 >= *(_DWORD *)(v3 + 52))
      goto LABEL_43;
  }
  v6 = (int8x16_t *)malloc_type_malloc(size.u32[0], 0xBADBAB7FuLL);
  if (v6)
  {
    v24 = v16;
    if (!*(_BYTE *)(v3 + 33))
      goto LABEL_25;
    goto LABEL_24;
  }
  v21 = 13;
LABEL_43:
  free(v6);
  (*(void (**)(uint64_t (**)(_QWORD, int8x16_t *, uint64_t)))(v25 + 112))(v5);
  return v21;
}

uint64_t ktxTexture1_NeedsTranscoding()
{
  return 0;
}

uint64_t ktxFormatSize_initFromDfd(uint64_t a1, unsigned int *a2)
{
  uint64_t v2;
  uint64_t result;
  const void *v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  if (v2 < 0x2C || v2 - 4 != (unint64_t)a2[2] >> 16)
    return 0;
  if ((unsigned __int16)a2[2] != 2 || a2[1] != 0)
    return 0;
  v7 = a2 + 4;
  *(_DWORD *)(a1 + 12) = *((unsigned __int8 *)a2 + 16) + 1;
  *(_DWORD *)(a1 + 16) = *((unsigned __int8 *)a2 + 17) + 1;
  *(_DWORD *)(a1 + 20) = *((unsigned __int8 *)a2 + 18) + 1;
  v8 = 8 * a2[5];
  *(_DWORD *)(a1 + 8) = v8;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 24) = 0x100000001;
  if ((a2[3] & 0x80) != 0)
  {
    *(_DWORD *)a1 = 2;
    if (*((unsigned __int8 *)a2 + 12) == 164)
      *(_QWORD *)(a1 + 24) = 0x200000002;
    goto LABEL_28;
  }
  v9 = *((_BYTE *)a2 + 31) & 0xF;
  if (v9 == 13)
  {
    v11 = 16;
    goto LABEL_27;
  }
  if (v9 != 14)
  {
    v12 = a2[2];
    if ((v12 & 0xFFFF0000) == 0x780000
      && (((v12 >> 18) - 6) & 0xFFFFFFFC) == 0x18
      && !memcmp(&unk_1EDF033FC, v7, 0x6CuLL))
    {
      v11 = 1;
      goto LABEL_27;
    }
    v14 = 0;
    v13 = interpretDFD(a2, &v15, &v16, &v17, v18, &v14);
    if (v13 <= 0x3F)
    {
      if ((v13 & 2) != 0)
        *(_DWORD *)a1 |= 1u;
      v8 = *(_DWORD *)(a1 + 8);
      goto LABEL_28;
    }
    return 0;
  }
  v10 = ((a2[2] >> 18) - 6) >> 2;
  if (v10 == 2)
  {
    v11 = 25;
    goto LABEL_27;
  }
  if (v10 != 1)
    return 0;
  v11 = 8;
LABEL_27:
  *(_DWORD *)a1 = v11;
LABEL_28:
  if (v8)
    return 1;
  LODWORD(v15) = 0;
  result = recreateBytesPlane0FromSampleInfo(a2, (unsigned int *)&v15);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a1 + 8) = 8 * v15;
    return 1;
  }
  return result;
}

uint64_t ktxTexture2_constructFromStreamAndHeader(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t ImageData;
  int v8;
  uint64_t v9;
  __int128 v10;
  size_t v11;
  void *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t (**v15)(uint64_t, void *);
  int v16;
  uint64_t v17;
  unsigned int v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  size_t v30;
  void *v31;
  unsigned int *v32;
  double v33;
  uint64_t v34;
  char *v35;
  void *v36;
  void *v37;
  void **v38;
  int v40;
  char *v41;
  char *v42;
  int v43;
  uint64_t v44;
  char *v45;
  int v46;
  double v47;
  int v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  ImageData = ktxTexture_constructFromStream(a1, a2);
  if ((_DWORD)ImageData)
    return ImageData;
  v46 = 0;
  ImageData = ktxCheckHeader2_(a3, (uint64_t)&v46);
  if (!(_DWORD)ImageData)
  {
    v8 = *(_DWORD *)(a3 + 40);
    *(_DWORD *)a1 = 2;
    *(_QWORD *)(a1 + 8) = ktxTexture2_vtbl;
    v9 = *(_QWORD *)(a1 + 24);
    v10 = ktxTexture2_vtblInt;
    *(_QWORD *)(v9 + 16) = off_1EDF00980;
    *(_OWORD *)v9 = v10;
    v11 = 24 * (v8 - 1) + 56;
    v12 = malloc_type_malloc(v11, 0x9D79ECDCuLL);
    *(_QWORD *)(a1 + 160) = v12;
    if (!v12)
      goto LABEL_44;
    bzero(v12, v11);
    v13 = *(_QWORD **)(a1 + 160);
    v14 = *(_QWORD *)(a1 + 24);
    v15 = (uint64_t (**)(uint64_t, void *))(v14 + 64);
    *(_DWORD *)(a1 + 120) = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 44);
    *(_DWORD *)(v14 + 56) = *(_DWORD *)(a3 + 16);
    v16 = HIWORD(v46);
    *(_DWORD *)(a1 + 48) = HIWORD(v46);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a3 + 20);
    switch(v16)
    {
      case 3:
        v17 = *(_QWORD *)(a3 + 24);
        break;
      case 2:
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a3 + 24);
        *(_DWORD *)(a1 + 44) = 1;
LABEL_11:
        v18 = *(_DWORD *)(a3 + 32);
        v19 = v18 != 0;
        if (v18 <= 1)
          v18 = 1;
        *(_DWORD *)(a1 + 56) = v18;
        *(_BYTE *)(a1 + 32) = v19;
        v20 = *(_DWORD *)(a3 + 36);
        *(_DWORD *)(a1 + 60) = v20;
        *(_BYTE *)(a1 + 33) = v20 == 6;
        v21 = *(unsigned int *)(a3 + 40);
        *(_DWORD *)(a1 + 52) = v21;
        *(_BYTE *)(a1 + 35) = BYTE1(v46) != 0;
        ImageData = ((uint64_t (*)(uint64_t, _QWORD *, uint64_t))*v15)(v14 + 64, v13 + 4, 24 * v21);
        if ((_DWORD)ImageData)
          goto LABEL_45;
        v22 = *(unsigned int *)(a1 + 52);
        v23 = v13[3 * (v22 - 1) + 4];
        v13[3] = v23;
        if ((_DWORD)v22)
        {
          if ((_DWORD)v22 == 1)
          {
            v24 = 0;
LABEL_20:
            v28 = &v13[3 * v24 + 4];
            v29 = v22 - v24;
            do
            {
              *v28 -= v23;
              v28 += 3;
              --v29;
            }
            while (v29);
            goto LABEL_22;
          }
          v24 = v22 & 0xFFFFFFFE;
          v25 = v13 + 7;
          v26 = v24;
          do
          {
            v27 = *v25 - v23;
            *(v25 - 3) -= v23;
            *v25 = v27;
            v25 += 6;
            v26 -= 2;
          }
          while (v26);
          if (v24 != v22)
            goto LABEL_20;
        }
LABEL_22:
        v30 = *(unsigned int *)(a3 + 52);
        if (v30 < 4)
        {
LABEL_23:
          ImageData = 16;
          goto LABEL_45;
        }
        v31 = malloc_type_malloc(v30, 0x9CBB65DAuLL);
        *(_QWORD *)(a1 + 128) = v31;
        if (!v31)
          goto LABEL_44;
        ImageData = ((uint64_t (*)(uint64_t, void *, _QWORD))*v15)(v14 + 64, v31, *(unsigned int *)(a3 + 52));
        if ((_DWORD)ImageData)
          goto LABEL_45;
        v32 = *(unsigned int **)(a1 + 128);
        if (*v32 != *(_DWORD *)(a3 + 52) || !ktxFormatSize_initFromDfd(*(_QWORD *)(a1 + 24) + 24, v32))
          goto LABEL_23;
        *(_BYTE *)(a1 + 34) = (*(_BYTE *)(*(_QWORD *)(a1 + 24) + 24) & 2) != 0;
        *(_DWORD *)(*(_QWORD *)(a1 + 160) + 8) = ktxTexture2_calcRequiredLevelAlignment(a1);
        ktxHashList_Construct((_QWORD *)(a1 + 80));
        v34 = *(unsigned int *)(a3 + 60);
        if ((_DWORD)v34)
        {
          if ((a4 & 4) == 0)
          {
            v35 = (char *)malloc_type_malloc(*(unsigned int *)(a3 + 60), 0x45A6E3C4uLL);
            if (!v35)
              goto LABEL_44;
            v42 = v35;
            v43 = v34;
            ImageData = ((uint64_t (*)(uint64_t, char *, uint64_t))*v15)(v14 + 64, v35, v34);
            if ((_DWORD)ImageData)
              goto LABEL_45;
            if ((a4 & 2) != 0)
            {
              *(_DWORD *)(a1 + 88) = v43;
              *(_QWORD *)(a1 + 96) = v42;
              if (!*(_QWORD *)(a3 + 72))
                goto LABEL_42;
              goto LABEL_40;
            }
            v44 = 0;
            v45 = 0;
            ImageData = ktxHashList_Deserialize((_QWORD *)(a1 + 80), v43, v42);
            free(v42);
            if ((_DWORD)ImageData)
              goto LABEL_45;
            if (ktxHashList_FindValue((uint64_t *)(a1 + 80), "KTXorientation", (_DWORD *)&v44 + 1, &v45))
            {
LABEL_35:
              if (ktxHashList_FindValue((uint64_t *)(a1 + 80), "KTXanimData", &v44, &v47))
              {
                if (!*(_QWORD *)(a3 + 72))
                  goto LABEL_42;
                goto LABEL_40;
              }
              if ((_DWORD)v44 == 12)
              {
                ImageData = 1;
                if (!*(_BYTE *)(a1 + 32))
                  goto LABEL_45;
                *(_BYTE *)(a1 + 140) = 1;
                v33 = v47;
                *(double *)(a1 + 144) = v47;
                *(_DWORD *)(a1 + 152) = v48;
                if (!*(_QWORD *)(a3 + 72))
                  goto LABEL_42;
LABEL_40:
                (*(void (**)(uint64_t, _QWORD))(v14 + 96))(v14 + 64, *(_QWORD *)(a3 + 64));
                v36 = malloc_type_malloc(*(_QWORD *)(a3 + 72), 0x5B457448uLL);
                *v13 = v36;
                if (v36)
                {
                  v13[2] = *(_QWORD *)(a3 + 72);
                  ImageData = (*v15)(v14 + 64, v36);
                  if ((_DWORD)ImageData)
                    goto LABEL_45;
LABEL_42:
                  *(_QWORD *)(a1 + 104) = v13[5] + v13[4];
                  if ((a4 & 1) == 0)
                    return 0;
                  ImageData = ktxTexture2_LoadImageData(a1, 0, 0, v33);
                  if (!(_DWORD)ImageData)
                    return ImageData;
                  goto LABEL_45;
                }
LABEL_44:
                ImageData = 13;
                goto LABEL_45;
              }
LABEL_66:
              ImageData = 1;
              goto LABEL_45;
            }
            v40 = *(_DWORD *)(a1 + 48);
            if (HIDWORD(v44) != v40 + 1)
              goto LABEL_66;
            switch(v40)
            {
              case 3:
                v41 = v45;
                *(_DWORD *)(a1 + 72) = v45[2];
                break;
              case 2:
                v41 = v45;
                break;
              case 1:
                v41 = v45;
                goto LABEL_70;
              default:
                goto LABEL_35;
            }
            *(_DWORD *)(a1 + 68) = v41[1];
LABEL_70:
            *(_DWORD *)(a1 + 64) = *v41;
            goto LABEL_35;
          }
          (*(void (**)(uint64_t, _QWORD))(v14 + 72))(v14 + 64, *(unsigned int *)(a3 + 60));
        }
        if (!*(_QWORD *)(a3 + 72))
          goto LABEL_42;
        goto LABEL_40;
      case 1:
        v17 = 0x100000001;
        break;
      default:
        goto LABEL_11;
    }
    *(_QWORD *)(a1 + 40) = v17;
    goto LABEL_11;
  }
LABEL_45:
  v37 = *(void **)(a1 + 128);
  if (v37)
    free(v37);
  v38 = *(void ***)(a1 + 160);
  if (v38)
  {
    if (*v38)
    {
      free(*v38);
      v38 = *(void ***)(a1 + 160);
    }
    free(v38);
  }
  ktxTexture_destruct(a1);
  return ImageData;
}

uint64_t ktxTexture2_calcRequiredLevelAlignment(uint64_t a1)
{
  uint64_t result;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;

  if (*(_DWORD *)(a1 + 136))
    return 1;
  if (!*(_DWORD *)(a1 + 120))
    return 16;
  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 32);
  result = v2 >> 3;
  if ((v2 & 0x18) != 0)
  {
    v3 = 4;
    v4 = result;
    do
    {
      v5 = v4;
      v4 = v3 % v4;
      v3 = v5;
    }
    while (v4);
    return 4 * (int)result / v5;
  }
  return result;
}

uint64_t ktxTexture2_LoadImageData(uint64_t a1, uint64_t a2, size_t a3, double a4)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  size_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  float32x2_t v18;
  uint64_t *v19;
  int64x2_t v20;
  uint64_t v21;
  int64x2_t v22;
  uint64_t *v23;
  uint64x2_t v24;
  uint64_t v25;
  uint64x2_t v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v32;
  void *v33;
  void *v34;

  v6 = *(_QWORD *)(a1 + 24);
  v7 = *(_QWORD *)(a1 + 160);
  v8 = *(_DWORD *)(a1 + 136);
  if (v8 < 2)
  {
    v9 = *(_QWORD *)(a1 + 104);
    if (!*(_QWORD *)(a1 + 112))
      goto LABEL_25;
    return 10;
  }
  if (v8 != 2)
  {
    v9 = 0;
    if (*(_QWORD *)(a1 + 112))
      return 10;
    goto LABEL_25;
  }
  if (!*(_DWORD *)(a1 + 120))
  {
    v11 = 16;
    v15 = (*(_DWORD *)(a1 + 52) - 1);
    if (*(_DWORD *)(a1 + 52) - 1 > 0)
      goto LABEL_11;
LABEL_16:
    v9 = *(_QWORD *)(v7 + 48);
    if (*(_QWORD *)(a1 + 112))
      return 10;
    goto LABEL_25;
  }
  v10 = *(_DWORD *)(v6 + 32);
  v11 = v10 >> 3;
  if ((v10 & 0x18) != 0)
  {
    v12 = 4;
    v13 = v11;
    do
    {
      v14 = v13;
      v13 = v12 % v13;
      v12 = v14;
    }
    while (v13);
    v11 = 4 * v11 / v14;
  }
  v15 = (*(_DWORD *)(a1 + 52) - 1);
  if (*(_DWORD *)(a1 + 52) - 1 <= 0)
    goto LABEL_16;
LABEL_11:
  *(float *)&a4 = (float)v11;
  if (v15 < 4)
  {
    v16 = 0;
    v17 = v15;
LABEL_21:
    v27 = (unint64_t *)(v7 + 24 * v17 + 48);
    do
    {
      v28 = *v27;
      v27 -= 3;
      v16 += (float)(ceilf((float)v28 / *(float *)&a4) * *(float *)&a4);
      --v17;
    }
    while (v17 > 0);
    goto LABEL_23;
  }
  v18 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
  v17 = v15 & 3;
  v19 = (uint64_t *)(v7 + 24 * v15);
  v20 = 0uLL;
  v21 = v15 & 0xFFFFFFFC;
  v22 = 0uLL;
  do
  {
    v23 = v19 - 3;
    v24.i64[0] = v19[6];
    v24.i64[1] = v19[3];
    v25 = *v19;
    v19 -= 12;
    v26.i64[0] = v25;
    v26.i64[1] = *v23;
    v20 = (int64x2_t)vaddw_u32((uint64x2_t)v20, vcvt_u32_f32(vmul_n_f32(vrndp_f32(vdiv_f32(vcvt_f32_f64(vcvtq_f64_u64(v24)), v18)), *(float *)&a4)));
    v22 = (int64x2_t)vaddw_u32((uint64x2_t)v22, vcvt_u32_f32(vmul_n_f32(vrndp_f32(vdiv_f32(vcvt_f32_f64(vcvtq_f64_u64(v26)), v18)), *(float *)&a4)));
    v21 -= 4;
  }
  while (v21);
  v16 = vaddvq_s64(vaddq_s64(v22, v20));
  if ((v15 & 0xFFFFFFFC) != v15)
    goto LABEL_21;
LABEL_23:
  if (!a1)
    return 11;
  v9 = *(_QWORD *)(v7 + 48) + v16;
  if (*(_QWORD *)(a1 + 112))
    return 10;
LABEL_25:
  if (!*(_QWORD *)(v6 + 128))
    return 10;
  if (a2)
  {
    v29 = a2;
    if (v9 > a3)
      return 11;
  }
  else
  {
    v32 = malloc_type_malloc(v9, 0x7DF1A372uLL);
    *(_QWORD *)(a1 + 112) = v32;
    if (!v32)
      return 13;
    v29 = (uint64_t)v32;
    v8 = *(_DWORD *)(a1 + 136);
  }
  if (v8 == 2)
  {
    v33 = malloc_type_malloc(*(_QWORD *)(a1 + 104), 0x7332993EuLL);
    v34 = v33;
    if (!v33)
      return 13;
  }
  else
  {
    v33 = 0;
    v34 = (void *)v29;
  }
  v30 = (*(uint64_t (**)(uint64_t, _QWORD))(v6 + 96))(v6 + 64, *(_QWORD *)(v7 + 24));
  if (!(_DWORD)v30)
  {
    v30 = (*(uint64_t (**)(uint64_t, void *, _QWORD))(v6 + 64))(v6 + 64, v34, *(_QWORD *)(a1 + 104));
    if (!(_DWORD)v30)
    {
      if (*(_DWORD *)(a1 + 136) == 2
        && (v30 = ktxTexture2_inflateZstdInt(a1, (uint64_t)v33, v29, v9), free(v33), (_DWORD)v30))
      {
        if (!a2)
        {
          free(*(void **)(a1 + 112));
          *(_QWORD *)(a1 + 112) = 0;
        }
      }
      else
      {
        (*(void (**)(uint64_t))(v6 + 112))(v6 + 64);
        v30 = 0;
        *(_QWORD *)(v7 + 24) = 0;
      }
    }
  }
  return v30;
}

void ktxTexture2_destruct(uint64_t a1)
{
  void *v2;
  void **v3;

  v2 = *(void **)(a1 + 128);
  if (v2)
    free(v2);
  v3 = *(void ***)(a1 + 160);
  if (v3)
  {
    if (*v3)
    {
      free(*v3);
      v3 = *(void ***)(a1 + 160);
    }
    free(v3);
  }
  ktxTexture_destruct(a1);
}

uint64_t ktxTexture2_Create(uint64_t a1, int a2, unsigned int **a3)
{
  unsigned int *v6;
  unsigned int *v7;
  int v8;
  unsigned int *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void **v13;
  int v14;
  uint64_t v15;
  __int128 v16;
  size_t v17;
  void *v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  unsigned int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  int64x2_t *v30;
  size_t v31;
  void *v32;
  int v33;
  __int128 v34[2];

  if (!a3)
    return 11;
  v6 = (unsigned int *)malloc_type_malloc(0xA8uLL, 0x1030040B443E594uLL);
  if (v6)
  {
    v7 = v6;
    memset(v34, 0, sizeof(v34));
    *(_OWORD *)v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 8) = 0u;
    *((_OWORD *)v6 + 9) = 0u;
    *((_QWORD *)v6 + 20) = 0;
    v8 = *(_DWORD *)(a1 + 4);
    if (v8)
    {
      v9 = (unsigned int *)vk2dfd(v8);
      *((_QWORD *)v7 + 16) = v9;
      if (!v9)
      {
        v10 = 11;
        goto LABEL_24;
      }
      ktxFormatSize_initFromDfd((uint64_t)v34, v9);
    }
    else
    {
      v11 = malloc_type_malloc(**(unsigned int **)(a1 + 8), 0xB0BCEB7AuLL);
      *((_QWORD *)v7 + 16) = v11;
      if (!v11)
      {
        v10 = 13;
        goto LABEL_24;
      }
      memcpy(v11, *(const void **)(a1 + 8), **(unsigned int **)(a1 + 8));
      if ((ktxFormatSize_initFromDfd((uint64_t)v34, *((unsigned int **)v7 + 16)) & 1) != 0)
      {
        v10 = 16;
        v12 = (void *)*((_QWORD *)v7 + 16);
        if (!v12)
        {
LABEL_12:
          v13 = (void **)*((_QWORD *)v7 + 20);
          if (v13)
          {
            if (*v13)
            {
              free(*v13);
              v13 = (void **)*((_QWORD *)v7 + 20);
            }
            free(v13);
          }
          ktxTexture_destruct((uint64_t)v7);
          goto LABEL_24;
        }
LABEL_11:
        free(v12);
        goto LABEL_12;
      }
    }
    v10 = ktxTexture_construct((uint64_t)v7, a1, v34);
    if (!(_DWORD)v10)
    {
      v14 = *(_DWORD *)(a1 + 32);
      *v7 = 2;
      *((_QWORD *)v7 + 1) = ktxTexture2_vtbl;
      v15 = *((_QWORD *)v7 + 3);
      v16 = ktxTexture2_vtblInt;
      *(_QWORD *)(v15 + 16) = off_1EDF00980;
      *(_OWORD *)v15 = v16;
      v17 = 24 * (v14 - 1) + 56;
      v18 = malloc_type_malloc(v17, 0x9D79ECDCuLL);
      *((_QWORD *)v7 + 20) = v18;
      if (!v18)
        goto LABEL_45;
      bzero(v18, v17);
      v19 = *(_DWORD *)(a1 + 4);
      v7[30] = v19;
      if (*((_BYTE *)v7 + 34))
      {
        v20 = *((_QWORD *)v7 + 3);
        v21 = 1;
      }
      else
      {
        if ((v34[0] & 1) != 0)
        {
          *(_DWORD *)(*((_QWORD *)v7 + 3) + 56) = DWORD2(v34[0]) >> 3;
          goto LABEL_32;
        }
        if ((v34[0] & 0x18) == 0)
        {
          v33 = 0;
          getDFDComponentInfoUnpacked(*((_QWORD *)v7 + 16), &v33, (unsigned int *)(*((_QWORD *)v7 + 3) + 56));
          v19 = v7[30];
          goto LABEL_32;
        }
        v20 = *((_QWORD *)v7 + 3);
        if (v19 == 128)
        {
          *(_DWORD *)(v20 + 56) = 2;
          v7[34] = 0;
          goto LABEL_34;
        }
        v21 = 4;
      }
      *(_DWORD *)(v20 + 56) = v21;
LABEL_32:
      v7[34] = 0;
      if (!v19)
      {
        v24 = 16;
        goto LABEL_39;
      }
      v20 = *((_QWORD *)v7 + 3);
LABEL_34:
      v23 = *(_DWORD *)(v20 + 32);
      v24 = v23 >> 3;
      if ((v23 & 0x18) != 0)
      {
        v25 = 4;
        v26 = v24;
        do
        {
          v27 = v26;
          v26 = v25 % v26;
          v25 = v27;
        }
        while (v26);
        v24 = 4 * v24 / v27;
      }
LABEL_39:
      v28 = *((_QWORD *)v7 + 20);
      *(_DWORD *)(v28 + 8) = v24;
      *(_QWORD *)(v28 + 24) = 0;
      if (v7[13])
      {
        v29 = 0;
        v30 = (int64x2_t *)(v28 + 40);
        do
        {
          *v30 = vdupq_n_s64(ktxTexture_calcLevelSize((uint64_t)v7, v29, 2));
          v30[-1].i64[1] = (*(uint64_t (**)(unsigned int *, unint64_t))(*((_QWORD *)v7 + 3) + 16))(v7, v29++);
          v30 = (int64x2_t *)((char *)v30 + 24);
        }
        while (v29 < v7[13]);
      }
      if (a2 != 1
        || (v31 = ktxTexture_calcDataSizeTexture((uint64_t)v7),
            *((_QWORD *)v7 + 13) = v31,
            v32 = malloc_type_malloc(v31, 0xBF91D186uLL),
            (*((_QWORD *)v7 + 14) = v32) != 0))
      {
        v10 = 0;
        *a3 = v7;
        return v10;
      }
LABEL_45:
      v10 = 13;
      v12 = (void *)*((_QWORD *)v7 + 16);
      if (!v12)
        goto LABEL_12;
      goto LABEL_11;
    }
LABEL_24:
    free(v7);
    return v10;
  }
  return 13;
}

uint64_t ktxTexture2_CreateCopy(uint64_t a1, uint64_t **a2)
{
  uint64_t *v4;
  uint64_t *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  void *v14;
  double v15;
  uint64_t v16;
  __int128 *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  size_t v26;
  void *v27;
  size_t v28;
  void *v29;
  void *v30;
  uint64_t v31;
  uint64_t result;
  void *v33;
  void *v34;
  void *v35;
  void **v36;
  void *v37;

  if (!a2)
    return 11;
  v4 = (uint64_t *)malloc_type_malloc(0xA8uLL, 0x1030040B443E594uLL);
  if (!v4)
    return 13;
  v5 = v4;
  v6 = *(_OWORD *)a1;
  *((_OWORD *)v4 + 1) = *(_OWORD *)(a1 + 16);
  v8 = *(_OWORD *)(a1 + 96);
  v7 = *(_OWORD *)(a1 + 112);
  v9 = *(_OWORD *)(a1 + 144);
  *((_OWORD *)v4 + 8) = *(_OWORD *)(a1 + 128);
  *((_OWORD *)v4 + 6) = v8;
  v10 = *(_OWORD *)(a1 + 32);
  v11 = *(_OWORD *)(a1 + 48);
  v12 = *(_OWORD *)(a1 + 64);
  v13 = *(_OWORD *)(a1 + 80);
  *((_OWORD *)v4 + 7) = v7;
  *(_OWORD *)v4 = v6;
  *((_OWORD *)v4 + 4) = v12;
  *((_OWORD *)v4 + 5) = v13;
  *((_OWORD *)v4 + 2) = v10;
  *((_OWORD *)v4 + 3) = v11;
  *((_OWORD *)v4 + 9) = v9;
  v4[3] = 0;
  v4[20] = 0;
  v4[16] = 0;
  v4[12] = 0;
  v4[10] = 0;
  v4[14] = 0;
  v14 = malloc_type_malloc(0xA8uLL, 0x10A2040785DE303uLL);
  v5[3] = (uint64_t)v14;
  if (!v14)
    goto LABEL_31;
  if (!*(_QWORD *)(a1 + 112) && ktxTexture_isActiveStream(a1))
    ktxTexture2_LoadImageData(a1, 0, 0, v15);
  v16 = v5[3];
  v17 = *(__int128 **)(a1 + 24);
  v18 = v17[6];
  v20 = v17[3];
  v19 = v17[4];
  *(_OWORD *)(v16 + 80) = v17[5];
  *(_OWORD *)(v16 + 96) = v18;
  *(_OWORD *)(v16 + 48) = v20;
  *(_OWORD *)(v16 + 64) = v19;
  v22 = v17[8];
  v21 = v17[9];
  v23 = v17[7];
  *(_QWORD *)(v16 + 160) = *((_QWORD *)v17 + 20);
  *(_OWORD *)(v16 + 128) = v22;
  *(_OWORD *)(v16 + 144) = v21;
  *(_OWORD *)(v16 + 112) = v23;
  v24 = *v17;
  v25 = v17[2];
  *(_OWORD *)(v16 + 16) = v17[1];
  *(_OWORD *)(v16 + 32) = v25;
  *(_OWORD *)v16 = v24;
  v26 = 24 * (*(_DWORD *)(a1 + 52) - 1) + 56;
  v27 = malloc_type_malloc(v26, 0xACFD6261uLL);
  v5[20] = (uint64_t)v27;
  if (v27)
  {
    memcpy(v27, *(const void **)(a1 + 160), v26);
    v28 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 16);
    if (v28)
    {
      v29 = malloc_type_malloc(v28, 0xE6CFAFC2uLL);
      *(_QWORD *)v5[20] = v29;
      if (!v29)
        goto LABEL_21;
      memcpy(v29, **(const void ***)(a1 + 160), *(_QWORD *)(*(_QWORD *)(a1 + 160) + 16));
    }
    v30 = malloc_type_malloc(**(unsigned int **)(a1 + 128), 0xC856DEE6uLL);
    v5[16] = (uint64_t)v30;
    if (v30)
    {
      memcpy(v30, *(const void **)(a1 + 128), **(unsigned int **)(a1 + 128));
      v31 = *(_QWORD *)(a1 + 80);
      if (v31)
      {
        ktxHashList_ConstructCopy(v5 + 10, v31);
        goto LABEL_19;
      }
      if (!*(_QWORD *)(a1 + 96))
      {
LABEL_19:
        v34 = malloc_type_malloc(v5[13], 0x2F87B695uLL);
        v5[14] = (uint64_t)v34;
        if (v34)
        {
          memcpy(v34, *(const void **)(a1 + 112), *(_QWORD *)(a1 + 104));
          result = 0;
          *a2 = v5;
          return result;
        }
        goto LABEL_21;
      }
      v33 = malloc_type_malloc(*(unsigned int *)(a1 + 88), 0xBDCD7058uLL);
      v5[12] = (uint64_t)v33;
      if (v33)
      {
        memcpy(v33, *(const void **)(a1 + 96), *(unsigned int *)(a1 + 88));
        goto LABEL_19;
      }
    }
  }
LABEL_21:
  v35 = (void *)v5[3];
  if (v35)
    free(v35);
  v36 = (void **)v5[20];
  if (v36)
  {
    if (*v36)
    {
      free(*v36);
      v36 = (void **)v5[20];
    }
    free(v36);
  }
  v37 = (void *)v5[16];
  if (v37)
    free(v37);
  if (v5[10])
    ktxHashList_Destruct(v5 + 10);
LABEL_31:
  free(v5);
  return 13;
}

uint64_t ktxTexture2_CreateFromStdioStream(uint64_t a1, char a2, _QWORD *a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD v11[6];
  uint64_t v12;
  _OWORD v13[5];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 11;
  v6 = malloc_type_malloc(0xA8uLL, 0x1030040B443E594uLL);
  if (v6)
  {
    v7 = v6;
    if (a1)
    {
      v12 = 0;
      memset(v11, 0, sizeof(v11));
      v8 = ktxFileStream_construct((uint64_t)v11, a1, 0);
      if (!(_DWORD)v8)
      {
        memset(v13, 0, sizeof(v13));
        v9 = (*(uint64_t (**)(_OWORD *, _OWORD *, uint64_t))&v11[0])(v11, v13, 80);
        if ((_DWORD)v9)
        {
          v8 = v9;
        }
        else
        {
          v8 = ktxTexture2_constructFromStreamAndHeader((uint64_t)v7, (uint64_t)v11, (uint64_t)v13, a2);
          if (!(_DWORD)v8)
            goto LABEL_11;
        }
      }
    }
    else
    {
      v8 = 11;
    }
    free(v7);
    v7 = 0;
LABEL_11:
    *a3 = v7;
    return v8;
  }
  return 13;
}

uint64_t ktxTexture2_CreateFromNamedFile(const char *a1, char a2, _QWORD *a3)
{
  void *v6;
  void *v7;
  FILE *v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD v12[6];
  uint64_t v13;
  _OWORD v14[5];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 11;
  v6 = malloc_type_malloc(0xA8uLL, 0x1030040B443E594uLL);
  if (v6)
  {
    v7 = v6;
    if (a1)
    {
      v8 = fopen(a1, "rb");
      if (v8)
      {
        v13 = 0;
        memset(v12, 0, sizeof(v12));
        v9 = ktxFileStream_construct((uint64_t)v12, (uint64_t)v8, 1);
        if (!(_DWORD)v9)
        {
          memset(v14, 0, sizeof(v14));
          v10 = (*(uint64_t (**)(_OWORD *, _OWORD *, uint64_t))&v12[0])(v12, v14, 80);
          if ((_DWORD)v10)
          {
            v9 = v10;
          }
          else
          {
            v9 = ktxTexture2_constructFromStreamAndHeader((uint64_t)v7, (uint64_t)v12, (uint64_t)v14, a2);
            if (!(_DWORD)v9)
              goto LABEL_13;
          }
        }
      }
      else
      {
        v9 = 3;
      }
    }
    else
    {
      v9 = 11;
    }
    free(v7);
    v7 = 0;
LABEL_13:
    *a3 = v7;
    return v9;
  }
  return 13;
}

uint64_t ktxTexture2_CreateFromMemory(uint64_t a1, uint64_t a2, char a3, _QWORD *a4)
{
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD v13[6];
  uint64_t v14;
  _OWORD v15[5];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 11;
  v8 = malloc_type_malloc(0xA8uLL, 0x1030040B443E594uLL);
  if (v8)
  {
    v9 = v8;
    v10 = 11;
    if (a1)
    {
      if (a2)
      {
        v14 = 0;
        memset(v13, 0, sizeof(v13));
        v10 = ktxMemStream_construct_ro((uint64_t)v13, a1, a2);
        if (!(_DWORD)v10)
        {
          memset(v15, 0, sizeof(v15));
          v11 = (*(uint64_t (**)(_OWORD *, _OWORD *, uint64_t))&v13[0])(v13, v15, 80);
          if ((_DWORD)v11)
          {
            v10 = v11;
          }
          else
          {
            v10 = ktxTexture2_constructFromStreamAndHeader((uint64_t)v9, (uint64_t)v13, (uint64_t)v15, a3);
            if (!(_DWORD)v10)
            {
LABEL_12:
              *a4 = v9;
              return v10;
            }
          }
        }
      }
    }
    free(v9);
    v9 = 0;
    goto LABEL_12;
  }
  return 13;
}

uint64_t ktxTexture2_CreateFromStream(uint64_t (**a1)(_QWORD, _OWORD *, uint64_t), char a2, _QWORD *a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD v11[5];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 11;
  v6 = malloc_type_malloc(0xA8uLL, 0x1030040B443E594uLL);
  if (v6)
  {
    v7 = v6;
    memset(v11, 0, sizeof(v11));
    v8 = (*a1)(a1, v11, 80);
    if ((_DWORD)v8)
    {
      v9 = v8;
    }
    else
    {
      v9 = ktxTexture2_constructFromStreamAndHeader((uint64_t)v7, (uint64_t)a1, (uint64_t)v11, a2);
      if (!(_DWORD)v9)
      {
LABEL_9:
        *a3 = v7;
        return v9;
      }
    }
    free(v7);
    v7 = 0;
    goto LABEL_9;
  }
  return 13;
}

void ktxTexture2_Destroy(_QWORD *a1)
{
  void *v2;
  void **v3;

  v2 = (void *)a1[16];
  if (v2)
    free(v2);
  v3 = (void **)a1[20];
  if (v3)
  {
    if (*v3)
    {
      free(*v3);
      v3 = (void **)a1[20];
    }
    free(v3);
  }
  ktxTexture_destruct((uint64_t)a1);
  free(a1);
}

uint64_t ktxTexture2_calcDataSizeLevels(uint64_t a1, int a2)
{
  uint64_t v3;
  int v4;
  unint64_t v5;
  float v6;

  v3 = 0;
  v4 = a2 - 1;
  if (a2 != 1)
  {
    do
    {
      v5 = ktxTexture_calcLevelSize(a1, v4, 2);
      v6 = (float)*(unsigned int *)(*(_QWORD *)(a1 + 160) + 8);
      v3 += (float)(ceilf((float)v5 / v6) * v6);
      --v4;
    }
    while (v4);
  }
  return ktxTexture_calcLevelSize(a1, 0, 2) + v3;
}

uint64_t ktxTexture2_calcFaceLodSize(uint64_t a1, unsigned int a2)
{
  if (*(_BYTE *)(a1 + 33) && !*(_BYTE *)(a1 + 32))
    return ktxTexture_calcImageSize(a1, a2, 2);
  else
    return *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24 * a2 + 48);
}

uint64_t ktxTexture2_calcLevelOffset(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  uint64_t v5;
  unint64_t v6;
  float v7;

  v2 = *(_DWORD *)(a1 + 52) - 1;
  if (v2 <= a2)
    return 0;
  v5 = 0;
  do
  {
    v6 = ktxTexture_calcLevelSize(a1, v2, 2);
    v7 = (float)*(unsigned int *)(*(_QWORD *)(a1 + 160) + 8);
    v5 += (float)(ceilf((float)v6 / v7) * v7);
    --v2;
  }
  while (v2 > a2);
  return v5;
}

uint64_t ktxTexture2_levelFileOffset(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24) + *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24 * a2 + 32);
}

uint64_t lcm4(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;

  if ((result & 3) != 0)
  {
    v1 = 4;
    v2 = result;
    do
    {
      v3 = v2;
      v2 = v1 % v2;
      v1 = v3;
    }
    while (v2);
    return 4 * (int)result / v3;
  }
  return result;
}

uint64_t ktxTexture2_calcPostInflationLevelAlignment(uint64_t a1)
{
  unsigned int v1;
  uint64_t result;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;

  if (!*(_DWORD *)(a1 + 120))
    return 16;
  v1 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 32);
  result = v1 >> 3;
  if ((v1 & 0x18) != 0)
  {
    v3 = 4;
    v4 = result;
    do
    {
      v5 = v4;
      v4 = v3 % v4;
      v3 = v5;
    }
    while (v4);
    return 4 * (int)result / v5;
  }
  return result;
}

uint64_t ktxTexture2_GetComponentInfo(uint64_t a1, _DWORD *a2, unsigned int *a3)
{
  return getDFDComponentInfoUnpacked(*(_QWORD *)(a1 + 128), a2, a3);
}

uint64_t ktxTexture2_GetNumComponents(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  int v3;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 128);
  result = getDFDNumComponents(v1);
  if ((*(_DWORD *)(v1 + 12) & 0x80) != 0)
  {
    v3 = *(_DWORD *)(v1 + 12);
    if (v3 == 166)
    {
      v4 = *(_BYTE *)(v1 + 31) & 0xF;
      if (v4 > 5)
        return 1;
      else
        return dword_18823F074[v4];
    }
    else if (v3 == 163)
    {
      if ((_DWORD)result == 1)
      {
        if ((*(_BYTE *)(v1 + 31) & 0xF) != 0)
          return 1;
        else
          return 3;
      }
      else if (*(_BYTE *)(v1 + 31) & 0xF | ~*(_DWORD *)(v1 + 44) & 0xF000000)
      {
        return 2;
      }
      else
      {
        return 4;
      }
    }
  }
  return result;
}

uint64_t ktxTexture2_GetImageOffset(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, _QWORD *a5)
{
  char v5;
  uint64_t result;
  unsigned int v10;
  uint64_t v11;

  if (!a1)
    return 11;
  v5 = a2;
  if (*(_DWORD *)(a1 + 52) <= a2 || *(_DWORD *)(a1 + 56) <= a3 || *(_DWORD *)(a1 + 136))
    return 10;
  if (*(_BYTE *)(a1 + 33))
  {
    if (*(_DWORD *)(a1 + 60) <= a4)
      return 10;
  }
  else
  {
    v10 = *(_DWORD *)(a1 + 44) >> a2;
    if (v10 <= 1)
      v10 = 1;
    if (v10 <= a4)
      return 10;
  }
  *a5 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24 * a2 + 32);
  if (a3)
    *a5 += ktxTexture_layerSize(a1, a2, 2) * a3;
  if (!a4)
    return 0;
  v11 = ktxTexture_calcImageSize(a1, v5, 2);
  result = 0;
  *a5 += v11 * a4;
  return result;
}

uint64_t ktxTexture2_levelDataOffset(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24 * a2 + 32);
}

uint64_t ktxTexture2_GetImageSize(uint64_t a1, char a2)
{
  return ktxTexture_calcImageSize(a1, a2, 2);
}

uint64_t ktxTexture2_GetOETF(uint64_t a1)
{
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 128) + 14);
}

uint64_t ktxTexture2_GetPremultipliedAlpha(uint64_t a1)
{
  return *(_BYTE *)(*(_QWORD *)(a1 + 128) + 15) & 1;
}

BOOL ktxTexture2_NeedsTranscoding(uint64_t a1)
{
  return *(_DWORD *)(a1 + 136) == 1 || *(unsigned __int8 *)(*(_QWORD *)(a1 + 128) + 12) == 166;
}

uint64_t ktxTexture2_GetDataSizeUncompressed(uint64_t a1, double a2)
{
  unsigned int v2;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  float32x2_t v13;
  uint64_t *v14;
  int64x2_t v15;
  uint64_t v16;
  int64x2_t v17;
  uint64_t *v18;
  uint64x2_t v19;
  uint64_t v20;
  uint64x2_t v21;
  unint64_t *v22;
  unint64_t v23;

  v2 = *(_DWORD *)(a1 + 136);
  if (v2 < 2)
    return *(_QWORD *)(a1 + 104);
  if (v2 != 2)
    return 0;
  v4 = *(_QWORD *)(a1 + 160);
  if (!*(_DWORD *)(a1 + 120))
  {
    v6 = 16;
    v10 = (*(_DWORD *)(a1 + 52) - 1);
    if ((int)v10 >= 1)
      goto LABEL_11;
    return *(_QWORD *)(v4 + 48);
  }
  v5 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 32);
  v6 = v5 >> 3;
  if ((v5 & 0x18) != 0)
  {
    v7 = 4;
    v8 = v6;
    do
    {
      v9 = v8;
      v8 = v7 % v8;
      v7 = v9;
    }
    while (v8);
    v6 = 4 * v6 / v9;
  }
  v10 = (*(_DWORD *)(a1 + 52) - 1);
  if ((int)v10 < 1)
    return *(_QWORD *)(v4 + 48);
LABEL_11:
  *(float *)&a2 = (float)v6;
  if (v10 >= 4)
  {
    v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a2, 0);
    v12 = v10 & 3;
    v14 = (uint64_t *)(v4 + 24 * v10);
    v15 = 0uLL;
    v16 = v10 & 0xFFFFFFFC;
    v17 = 0uLL;
    do
    {
      v18 = v14 - 3;
      v19.i64[0] = v14[6];
      v19.i64[1] = v14[3];
      v20 = *v14;
      v14 -= 12;
      v21.i64[0] = v20;
      v21.i64[1] = *v18;
      v15 = (int64x2_t)vaddw_u32((uint64x2_t)v15, vcvt_u32_f32(vmul_n_f32(vrndp_f32(vdiv_f32(vcvt_f32_f64(vcvtq_f64_u64(v19)), v13)), *(float *)&a2)));
      v17 = (int64x2_t)vaddw_u32((uint64x2_t)v17, vcvt_u32_f32(vmul_n_f32(vrndp_f32(vdiv_f32(vcvt_f32_f64(vcvtq_f64_u64(v21)), v13)), *(float *)&a2)));
      v16 -= 4;
    }
    while (v16);
    v11 = vaddvq_s64(vaddq_s64(v17, v15));
    if ((v10 & 0x7FFFFFFC) == v10)
      return *(_QWORD *)(v4 + 48) + v11;
  }
  else
  {
    v11 = 0;
    v12 = v10;
  }
  v22 = (unint64_t *)(v4 + 24 * v12 + 48);
  do
  {
    v23 = *v22;
    v22 -= 3;
    v11 += (float)(ceilf((float)v23 / *(float *)&a2) * *(float *)&a2);
    --v12;
  }
  while (v12 > 0);
  return *(_QWORD *)(v4 + 48) + v11;
}

uint64_t ktxTexture2_IterateLevels(uint64_t a1, uint64_t (*a2)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t), uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;

  result = 11;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 136))
    {
      return 10;
    }
    else
    {
      v7 = *(_QWORD *)(a1 + 160) + 32;
      v8 = (*(_DWORD *)(a1 + 52) - 1);
      while ((v8 & 0x80000000) == 0)
      {
        v9 = *(_DWORD *)(a1 + 40);
        v10 = *(_DWORD *)(a1 + 36) >> v8;
        if (v10 <= 1)
          v11 = 1;
        else
          v11 = v10;
        if (v9 >> v8 <= 1)
          v12 = 1;
        else
          v12 = v9 >> v8;
        v13 = *(_DWORD *)(a1 + 44) >> v8;
        if (v13 <= 1)
          v14 = 1;
        else
          v14 = v13;
        result = a2(v8, 0, v11, v12, v14, *(_QWORD *)(v7 + 24 * v8 + 16), *(_QWORD *)(a1 + 112) + *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24 * v8 + 32), a3);
        v8 = (v8 - 1);
        if ((_DWORD)result)
          return result;
      }
      return 0;
    }
  }
  return result;
}

uint64_t ktxTexture2_IterateLoadLevelFaces(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t, char *, uint64_t), uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  void *v9;
  __n128 v10;
  void *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (**v17)(_QWORD, void *, unint64_t);
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  int ErrorCode;
  unsigned int v39;
  uint64_t (**v40)(_QWORD, void *, unint64_t);
  unint64_t v41;
  void *v42;
  uint64_t v43;
  char *v44;
  char *v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;

  if (*(_DWORD *)a1 != 2 || (*(_DWORD *)(a1 + 136) | 2) != 2)
    return 10;
  if (!a2)
    return 11;
  v5 = *(_QWORD *)(a1 + 24);
  if (!*(_QWORD *)(v5 + 128))
    return 10;
  v6 = *(_QWORD *)(a1 + 160);
  v7 = *(_QWORD *)(v6 + 40);
  if (!v7)
  {
    v11 = 0;
    v15 = 1;
LABEL_14:
    free(v11);
    return v15;
  }
  v9 = malloc_type_malloc(*(_QWORD *)(v6 + 40), 0x643E3636uLL);
  if (!v9)
    return 13;
  v11 = v9;
  if (*(_DWORD *)(a1 + 136) != 2)
  {
    v43 = 0;
    v44 = 0;
    v41 = v7;
    v45 = (char *)v9;
    goto LABEL_17;
  }
  v41 = *(_QWORD *)(v6 + 48);
  v12 = (char *)malloc_type_malloc(v41, 0x3215A52EuLL);
  if (!v12)
  {
    v15 = 13;
    goto LABEL_14;
  }
  v13 = v12;
  v10.n128_f64[0] = ZSTD_createDCtx();
  v43 = v14;
  v44 = v13;
  v45 = v13;
LABEL_17:
  v17 = (uint64_t (**)(_QWORD, void *, unint64_t))(v5 + 64);
  v18 = *(_DWORD *)(a1 + 52) - 1;
  if ((v18 & 0x80000000) == 0)
  {
    v42 = v11;
    v40 = (uint64_t (**)(_QWORD, void *, unint64_t))(v5 + 64);
    do
    {
      v19 = *(_DWORD *)(a1 + 40);
      v20 = *(_DWORD *)(a1 + 36) >> v18;
      if (v20 <= 1)
        v20 = 1;
      v48 = v20;
      if (v19 >> v18 <= 1)
        v21 = 1;
      else
        v21 = v19 >> v18;
      v22 = *(_DWORD *)(a1 + 44) >> v18;
      if (v22 <= 1)
        v22 = 1;
      v46 = v22;
      v47 = v21;
      v23 = *(_QWORD *)(v6 + 32 + 24 * v18 + 8);
      if (v23 - 1 >= v7)
      {
        v15 = 1;
        v37 = v43;
        v36 = v44;
        free(v11);
        if (v44)
          goto LABEL_47;
        goto LABEL_48;
      }
      v24 = v18;
      v25 = (*(uint64_t (**)(uint64_t (**)(_QWORD, void *, unint64_t), _QWORD, __n128))(v5 + 96))(v17, *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24) + *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24 * v18 + 32), v10);
      if ((_DWORD)v25 || (v25 = (*v17)(v17, v11, v23), (_DWORD)v25))
      {
        v15 = v25;
        v37 = v43;
        v36 = v44;
        free(v11);
        if (v44)
          goto LABEL_47;
        goto LABEL_48;
      }
      if (*(_DWORD *)(a1 + 136) == 2)
      {
        v23 = ZSTD_decompressDCtx(v43, v44, v41, (unsigned __int8 *)v11, v23);
        if (ZSTD_isError(v23))
        {
          ErrorCode = ZSTD_getErrorCode(v23);
          if (ErrorCode == 64)
            v39 = 13;
          else
            v39 = 1;
          if (ErrorCode == 70)
            return 11;
          else
            return v39;
        }
      }
      if (*(_BYTE *)(a1 + 33) && !*(_BYTE *)(a1 + 32))
      {
        v29 = vcvtps_u32_f32((float)(int)v48 / (float)*(unsigned int *)(v5 + 36));
        v10.n128_f32[0] = (float)(int)v47 / (float)*(unsigned int *)(v5 + 40);
        v30 = vcvtps_u32_f32(v10.n128_f32[0]);
        v31 = *(_DWORD *)(v5 + 48);
        if (v31 > v29)
          v29 = *(_DWORD *)(v5 + 48);
        if (v31 > v30)
          v30 = *(_DWORD *)(v5 + 48);
        v32 = (v29 * *(_DWORD *)(v5 + 32) * v30) >> 3;
        v33 = *(_DWORD *)(a1 + 60);
        if (v33 * (unint64_t)v32 > v41)
        {
          v15 = 7;
          v37 = v43;
          v36 = v44;
          free(v11);
          if (v44)
            goto LABEL_47;
          goto LABEL_48;
        }
        v26 = v7;
        v27 = v5;
        if (v33)
        {
          v34 = 0;
          v35 = v45;
          while (1)
          {
            v28 = a2(v24, v34, v48, v47, v46, v32, v35, a3);
            if ((_DWORD)v28)
              break;
            v35 += v32;
            v34 = (v34 + 1);
            if (v34 >= *(_DWORD *)(a1 + 60))
              goto LABEL_34;
          }
LABEL_50:
          v15 = v28;
          v37 = v43;
          v36 = v44;
          free(v42);
          if (v44)
            goto LABEL_47;
          goto LABEL_48;
        }
      }
      else
      {
        v26 = v7;
        v27 = v5;
        v28 = a2(v24, 0, v48, v47, v46, v23, v45, a3);
        if ((_DWORD)v28)
          goto LABEL_50;
      }
LABEL_34:
      v18 = v24 - 1;
      v11 = v42;
      v5 = v27;
      v7 = v26;
      v17 = v40;
    }
    while ((int)v24 > 0);
  }
  (*(void (**)(uint64_t (**)(_QWORD, void *, unint64_t)))(v5 + 112))(v17);
  v15 = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24) = 0;
  v37 = v43;
  v36 = v44;
  free(v11);
  if (v44)
LABEL_47:
    free(v36);
LABEL_48:
  if (v37)
    ZSTD_freeDCtx(v37);
  return v15;
}

uint64_t ktxTexture2_inflateZstdInt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  int64x2_t *v26;
  unint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  int ErrorCode;
  unsigned int v31;
  void *v32;
  size_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;

  result = 11;
  if (!a2 || !a3)
    return result;
  if (*(_DWORD *)(a1 + 136) != 2)
    return 10;
  v9 = *(_QWORD *)(a1 + 24);
  v10 = (24 * *(_DWORD *)(a1 + 52));
  v11 = *(_QWORD *)(a1 + 160);
  v12 = (char *)malloc_type_malloc(v10, 0x2DAE7CB1uLL);
  if (!v12)
    return 13;
  v13 = v12;
  v33 = v10;
  v34 = v9;
  v37 = v11;
  if (!*(_DWORD *)(a1 + 120))
  {
    v19 = 16;
LABEL_13:
    v36 = v19;
    goto LABEL_15;
  }
  v14 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 32);
  v15 = v14 >> 3;
  if ((v14 & 0x18) != 0)
  {
    v16 = 4;
    v17 = v15;
    do
    {
      v18 = v17;
      v17 = v16 % v17;
      v16 = v18;
    }
    while (v17);
    v19 = 4 * v15 / v18;
    goto LABEL_13;
  }
  v36 = v14 >> 3;
LABEL_15:
  ZSTD_createDCtx();
  v21 = v20;
  v22 = *(_DWORD *)(a1 + 52);
  v23 = v22 - 1;
  v35 = a1;
  v32 = v13;
  v24 = 0;
  if (v22 - 1 < 0)
  {
LABEL_19:
    ZSTD_freeDCtx(v21);
    *(_QWORD *)(v35 + 104) = v24;
    *(_DWORD *)(v35 + 136) = 0;
    memcpy((void *)(v37 + 32), v32, v33);
    free(v32);
    result = 0;
    *(_DWORD *)(*(_QWORD *)(v35 + 160) + 8) = v36;
    *(_DWORD *)(*(_QWORD *)(v35 + 128) + 20) = *(_DWORD *)(v34 + 32) >> 3;
  }
  else
  {
    v25 = 0;
    v26 = (int64x2_t *)&v13[24 * v23 + 8];
    v27 = (unint64_t *)(v37 + 24 * v23 + 40);
    while (1)
    {
      v28 = v25;
      v29 = ZSTD_decompressDCtx(v21, (char *)(a3 + v25), a4, (unsigned __int8 *)(a2 + *(v27 - 1)), *v27);
      if (ZSTD_isError(v29))
        break;
      v27 -= 3;
      *v26 = vdupq_n_s64(v29);
      v26[-1].i64[1] = v28;
      v24 += v29;
      v25 = v28 + (float)(ceilf((float)v29 / (float)v36) * (float)v36);
      a4 -= v29;
      --v22;
      v26 = (int64x2_t *)((char *)v26 - 24);
      if (v22 < 1)
        goto LABEL_19;
    }
    ErrorCode = ZSTD_getErrorCode(v29);
    if (ErrorCode == 64)
      v31 = 13;
    else
      v31 = 1;
    if (ErrorCode == 70)
      return 11;
    else
      return v31;
  }
  return result;
}

uint64_t ktxTexture1_setImageFromStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (**a5)(_QWORD, uint64_t, uint64_t), uint64_t a6)
{
  uint64_t result;
  uint64_t v11;
  __n128 v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  int __src;
  uint64_t v19;
  unsigned int v20;
  size_t __n;

  v20 = 0;
  result = 11;
  if (a1 && a5)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      __n = 0;
      v19 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(a1 + 8) + 8))(a1, a2, a3, a4, &v19);
      if (*(_BYTE *)(a1 + 34))
      {
        v11 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, a2);
        __n = 0;
        if (v11 == a6)
        {
LABEL_6:
          (*a5)(a5, *(_QWORD *)(a1 + 112) + v19, a6);
          return 0;
        }
      }
      else
      {
        v12.n128_f32[0] = ktxTexture_rowInfo(a1, a2, &v20, (_DWORD *)&__n + 1, &__n);
        if ((_DWORD)__n)
        {
          v13 = (HIDWORD(__n) - __n);
          if ((_DWORD)v13 * v20 == a6)
          {
            v14 = *(_QWORD *)(a1 + 112);
            __src = 0;
            if (v20)
            {
              v15 = 0;
              v16 = v14 + v19;
              do
              {
                v17 = v16 + HIDWORD(__n) * v15;
                ((void (*)(void (**)(_QWORD, uint64_t, uint64_t), uint64_t, uint64_t, __n128))*a5)(a5, v17, v13, v12);
                memcpy((void *)(v17 + v13), &__src, __n);
                ++v15;
              }
              while (v15 < v20);
            }
            return 0;
          }
        }
        else if (v20 * HIDWORD(__n) == a6)
        {
          goto LABEL_6;
        }
      }
    }
    return 10;
  }
  return result;
}

uint64_t ktxTexture1_SetImageFromStdioStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  _OWORD v13[6];
  uint64_t v14;

  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v11 = ktxFileStream_construct((uint64_t)v13, a5, 0);
  if (!(_DWORD)v11)
  {
    v11 = ktxTexture1_setImageFromStream(a1, a2, a3, a4, (void (**)(_QWORD, uint64_t, uint64_t))v13, a6);
    ktxFileStream_destruct((uint64_t)v13);
  }
  return v11;
}

uint64_t ktxTexture1_SetImageFromMemory(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  _OWORD v13[6];
  uint64_t v14;

  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v11 = ktxMemStream_construct_ro((uint64_t)v13, a5, a6);
  if (!(_DWORD)v11)
  {
    v11 = ktxTexture1_setImageFromStream(a1, a2, a3, a4, (void (**)(_QWORD, uint64_t, uint64_t))v13, a6);
    ktxMemStream_destruct((uint64_t)v13);
  }
  return v11;
}

uint64_t ktxTexture1_WriteToStream(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v20;
  void *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v22 = xmmword_18823F798;
  v23 = unk_18823F7A8;
  v24 = xmmword_18823F7B8;
  v25 = unk_18823F7C8;
  v21 = 0;
  if (!a2)
    return 11;
  if (!*(_QWORD *)(a1 + 112))
    return 10;
  v4 = (_QWORD *)(a1 + 80);
  if (*(_QWORD *)(a1 + 80))
  {
    if (*(_QWORD *)(a1 + 96))
      return 10;
  }
  *((_QWORD *)&v23 + 1) = *(_QWORD *)(a1 + 120);
  v6 = *(_DWORD *)(a1 + 132);
  LODWORD(v24) = *(_DWORD *)(a1 + 128);
  HIDWORD(v22) = 67305985;
  LODWORD(v23) = v6;
  v7 = ktxTexture1_glTypeSize(a1);
  v8 = *(_DWORD *)(a1 + 36);
  DWORD1(v23) = v7;
  DWORD1(v24) = v8;
  v9 = *(_DWORD *)(a1 + 48);
  if (v9 <= 1)
  {
    *((_QWORD *)&v24 + 1) = 0;
    v10 = *(unsigned __int8 *)(a1 + 32);
    if (!*(_BYTE *)(a1 + 32))
      goto LABEL_13;
    goto LABEL_12;
  }
  DWORD2(v24) = *(_DWORD *)(a1 + 40);
  if (v9 == 2)
  {
    HIDWORD(v24) = 0;
    v10 = *(unsigned __int8 *)(a1 + 32);
    if (!*(_BYTE *)(a1 + 32))
      goto LABEL_13;
LABEL_12:
    v10 = *(_DWORD *)(a1 + 56);
    goto LABEL_13;
  }
  HIDWORD(v24) = *(_DWORD *)(a1 + 44);
  v10 = *(unsigned __int8 *)(a1 + 32);
  if (*(_BYTE *)(a1 + 32))
    goto LABEL_12;
LABEL_13:
  *(_QWORD *)&v25 = __PAIR64__(*(_DWORD *)(a1 + 60), v10);
  if (!*(_BYTE *)(a1 + 35))
  {
    DWORD2(v25) = *(_DWORD *)(a1 + 52);
    if (*v4)
      goto LABEL_15;
LABEL_17:
    if (*(_QWORD *)(a1 + 96))
    {
      v21 = *(void **)(a1 + 96);
      HIDWORD(v25) = *(_DWORD *)(a1 + 88);
    }
    else
    {
      HIDWORD(v25) = 0;
    }
    goto LABEL_22;
  }
  DWORD2(v25) = 0;
  if (!*v4)
    goto LABEL_17;
LABEL_15:
  ktxHashList_Serialize((unsigned int **)(a1 + 80), (_DWORD *)&v25 + 3, (unsigned int **)&v21);
LABEL_22:
  v5 = (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(a2 + 16))(a2, &v22, 64, 1);
  if (!(_DWORD)v5)
  {
    if (!HIDWORD(v25))
      goto LABEL_49;
    v5 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(a2 + 16))(a2, v21, 1);
    if (*v4)
      free(v21);
    if (!(_DWORD)v5)
    {
LABEL_49:
      if (*(_DWORD *)(a1 + 52))
      {
        v12 = 0;
        v13 = 0;
        while (1)
        {
          v20 = 0;
          v20 = ktxTexture_doCalcFaceLodSize(a1, v13, 1);
          v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, v13);
          if (*(_DWORD *)(a1 + 44) >> v13 <= 1u)
            v15 = 1;
          else
            v15 = *(_DWORD *)(a1 + 44) >> v13;
          if (*(_BYTE *)(a1 + 33))
            v15 = *(_DWORD *)(a1 + 60);
          v16 = (*(uint64_t (**)(uint64_t, int *, uint64_t, uint64_t))(a2 + 16))(a2, &v20, 4, 1);
          if ((_DWORD)v16)
            break;
          if (*(_DWORD *)(a1 + 56) && v15)
          {
            v17 = 0;
            do
            {
              v18 = v15;
              do
              {
                v19 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(a2 + 16))(a2, *(_QWORD *)(a1 + 112) + v12, v14, 1);
                v12 += v14;
                --v18;
              }
              while (v18);
              ++v17;
            }
            while (v17 < *(_DWORD *)(a1 + 56));
            v5 = v19;
            v13 = (v13 + 1);
            if (v13 >= *(_DWORD *)(a1 + 52))
              return v5;
          }
          else
          {
            v5 = 0;
            v13 = (v13 + 1);
            if (v13 >= *(_DWORD *)(a1 + 52))
              return v5;
          }
        }
        return v16;
      }
      else
      {
        return 0;
      }
    }
  }
  return v5;
}

uint64_t ktxTexture1_WriteToStdioStream(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v4[6];
  uint64_t v5;

  if (!a1)
    return 11;
  v5 = 0;
  memset(v4, 0, sizeof(v4));
  result = ktxFileStream_construct((uint64_t)v4, a2, 0);
  if (!(_DWORD)result)
    return ktxTexture1_WriteToStream(a1, (uint64_t)v4);
  return result;
}

uint64_t ktxTexture1_WriteToNamedFile(uint64_t a1, char *__filename)
{
  FILE *v3;
  FILE *v4;
  uint64_t v5;
  _OWORD v7[6];
  uint64_t v8;

  if (!a1)
    return 11;
  v3 = fopen(__filename, "wb");
  if (!v3)
    return 3;
  v4 = v3;
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  v5 = ktxFileStream_construct((uint64_t)v7, (uint64_t)v3, 0);
  if (!(_DWORD)v5)
    v5 = ktxTexture1_WriteToStream(a1, (uint64_t)v7);
  fclose(v4);
  return v5;
}

uint64_t ktxTexture1_WriteToMemory(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v8;
  uint64_t v9;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v3 = 11;
  if (!a1)
    return v3;
  if (!a2)
    return v3;
  if (!a3)
    return v3;
  v15 = 0;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  memset(v10, 0, sizeof(v10));
  v9 = 0;
  *a2 = 0;
  v3 = ktxMemStream_construct((uint64_t)v10, 0);
  if ((_DWORD)v3)
    return v3;
  v8 = ktxTexture1_WriteToStream(a1, (uint64_t)v10);
  if (!(_DWORD)v8)
  {
    ktxMemStream_getdata((uint64_t)v10, a2);
    (*((void (**)(_OWORD *, uint64_t *))&v11 + 1))(v10, &v9);
    *a3 = (int)v9;
  }
  ktxMemStream_destruct((uint64_t)v10);
  return v8;
}

uint64_t ktxTexture1_WriteKTX2ToStream(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t appended;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  size_t v11;
  char *v12;
  char *v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v24;
  unsigned int v25;
  float v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  int64x2_t *v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  __n128 v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  unint64_t v40;
  int v41;
  int i;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  char *v48;
  char *v49;
  int v50;
  uint64_t v51;
  int v52;
  char *v53;
  int v54;
  uint64_t v55;
  void *v56;
  unsigned int v57;
  _OWORD v58[2];
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v61 = xmmword_18823F7F8;
  v62 = unk_18823F808;
  v63 = xmmword_18823F818;
  v59 = xmmword_18823F7D8;
  v60 = unk_18823F7E8;
  if (!a2)
    return 11;
  if (!*(_QWORD *)(a1 + 112))
    return 10;
  v4 = *(_DWORD *)(a1 + 124);
  appended = 16;
  if (v4 <= 36167)
  {
    if (v4 <= 33775)
    {
      v6 = 9;
      switch(v4)
      {
        case 33189:
          v6 = 124;
          goto LABEL_152;
        case 33190:
          v6 = 125;
          goto LABEL_152;
        case 33191:
        case 33192:
        case 33193:
        case 33194:
        case 33195:
        case 33196:
        case 33197:
        case 33198:
        case 33199:
        case 33200:
        case 33201:
        case 33202:
        case 33203:
        case 33204:
        case 33205:
        case 33206:
        case 33207:
        case 33208:
        case 33209:
        case 33210:
        case 33211:
        case 33212:
        case 33213:
        case 33214:
        case 33215:
        case 33216:
        case 33217:
        case 33218:
        case 33219:
        case 33220:
        case 33221:
        case 33222:
        case 33223:
        case 33224:
        case 33225:
        case 33226:
        case 33227:
        case 33228:
        case 33229:
        case 33230:
        case 33231:
        case 33232:
        case 33233:
        case 33234:
        case 33235:
        case 33236:
        case 33237:
        case 33238:
        case 33239:
        case 33240:
        case 33241:
        case 33242:
        case 33243:
        case 33244:
        case 33245:
        case 33246:
        case 33247:
        case 33248:
        case 33249:
        case 33250:
        case 33251:
        case 33252:
        case 33253:
        case 33254:
        case 33255:
        case 33256:
        case 33257:
        case 33258:
        case 33259:
        case 33260:
        case 33261:
        case 33262:
        case 33263:
        case 33264:
        case 33265:
        case 33266:
        case 33267:
        case 33268:
        case 33269:
        case 33270:
        case 33271:
        case 33272:
        case 33273:
        case 33274:
        case 33275:
        case 33276:
        case 33277:
        case 33278:
        case 33279:
        case 33280:
        case 33281:
        case 33282:
        case 33283:
        case 33284:
        case 33285:
        case 33286:
        case 33287:
        case 33288:
        case 33289:
        case 33290:
        case 33291:
        case 33292:
        case 33293:
        case 33294:
        case 33295:
        case 33296:
        case 33297:
        case 33298:
        case 33299:
        case 33300:
        case 33301:
        case 33302:
        case 33303:
        case 33304:
        case 33305:
        case 33306:
        case 33307:
        case 33308:
        case 33309:
        case 33310:
        case 33311:
        case 33312:
        case 33313:
        case 33314:
        case 33315:
        case 33316:
        case 33317:
        case 33318:
        case 33319:
        case 33320:
          return appended;
        case 33321:
          goto LABEL_152;
        case 33322:
          v6 = 70;
          goto LABEL_152;
        case 33323:
          v6 = 16;
          goto LABEL_152;
        case 33324:
          v6 = 77;
          goto LABEL_152;
        case 33325:
          v6 = 76;
          goto LABEL_152;
        case 33326:
          v6 = 100;
          goto LABEL_152;
        case 33327:
          v6 = 83;
          goto LABEL_152;
        case 33328:
          v6 = 103;
          goto LABEL_152;
        case 33329:
          v6 = 14;
          goto LABEL_152;
        case 33330:
          v6 = 13;
          goto LABEL_152;
        case 33331:
          v6 = 75;
          goto LABEL_152;
        case 33332:
          v6 = 74;
          goto LABEL_152;
        case 33333:
          v6 = 99;
          goto LABEL_152;
        case 33334:
          v6 = 98;
          goto LABEL_152;
        case 33335:
          v6 = 21;
          goto LABEL_152;
        case 33336:
          v6 = 20;
          goto LABEL_152;
        case 33337:
          v6 = 82;
          goto LABEL_152;
        case 33338:
          v6 = 81;
          goto LABEL_152;
        case 33339:
          v6 = 102;
          goto LABEL_152;
        case 33340:
          v6 = 101;
          goto LABEL_152;
        default:
          switch(v4)
          {
            case 32848:
              v6 = 6;
              goto LABEL_152;
            case 32849:
              v6 = 23;
              goto LABEL_152;
            case 32850:
            case 32857:
              v6 = 58;
              goto LABEL_152;
            case 32852:
              v6 = 84;
              goto LABEL_152;
            case 32854:
              v6 = 2;
              goto LABEL_152;
            case 32855:
              v6 = 8;
              goto LABEL_152;
            case 32856:
              v6 = 37;
              goto LABEL_152;
            case 32859:
              v6 = 91;
              goto LABEL_152;
            default:
              return appended;
          }
      }
      return appended;
    }
    if (v4 > 35411)
    {
      switch(v4)
      {
        case 35840:
        case 35842:
          v6 = 1000054001;
          goto LABEL_152;
        case 35841:
        case 35843:
          v6 = 1000054000;
          goto LABEL_152;
        case 35844:
        case 35845:
        case 35846:
        case 35847:
        case 35848:
        case 35849:
        case 35850:
        case 35851:
        case 35852:
        case 35853:
        case 35854:
        case 35855:
        case 35856:
        case 35857:
        case 35858:
        case 35859:
        case 35860:
        case 35861:
        case 35862:
        case 35863:
        case 35864:
        case 35865:
        case 35866:
        case 35867:
        case 35868:
        case 35869:
        case 35870:
        case 35871:
        case 35872:
        case 35873:
        case 35874:
        case 35875:
        case 35876:
        case 35877:
        case 35878:
        case 35879:
        case 35880:
        case 35881:
        case 35882:
        case 35883:
        case 35884:
        case 35885:
        case 35886:
        case 35887:
        case 35888:
        case 35889:
        case 35890:
        case 35891:
        case 35892:
        case 35893:
        case 35894:
        case 35895:
        case 35896:
        case 35897:
        case 35899:
        case 35900:
        case 35902:
        case 35903:
        case 35904:
        case 35906:
        case 35908:
        case 35909:
        case 35910:
        case 35911:
        case 35912:
        case 35913:
        case 35914:
        case 35915:
        case 35920:
        case 35921:
        case 35922:
        case 35923:
        case 35924:
        case 35925:
        case 35926:
        case 35927:
        case 35928:
        case 35929:
        case 35930:
        case 35931:
        case 35932:
        case 35933:
        case 35934:
        case 35935:
        case 35936:
        case 35937:
        case 35938:
        case 35939:
        case 35940:
        case 35941:
        case 35942:
        case 35943:
        case 35944:
        case 35945:
        case 35946:
        case 35947:
        case 35948:
        case 35949:
        case 35950:
        case 35951:
        case 35956:
        case 35957:
        case 35958:
        case 35959:
        case 35960:
        case 35961:
        case 35962:
        case 35963:
        case 35964:
        case 35965:
        case 35966:
        case 35967:
        case 35968:
        case 35969:
        case 35970:
        case 35971:
        case 35972:
        case 35973:
        case 35974:
        case 35975:
        case 35976:
        case 35977:
        case 35978:
        case 35979:
        case 35980:
        case 35981:
        case 35982:
        case 35983:
        case 35984:
        case 35985:
        case 35986:
        case 35987:
        case 35988:
        case 35989:
        case 35990:
        case 35991:
        case 35992:
        case 35993:
        case 35994:
        case 35995:
        case 35996:
        case 35997:
        case 35998:
        case 35999:
        case 36000:
        case 36001:
        case 36002:
        case 36003:
        case 36004:
        case 36005:
        case 36006:
        case 36007:
        case 36008:
        case 36009:
        case 36010:
        case 36011:
          return appended;
        case 35898:
          v6 = 122;
          goto LABEL_152;
        case 35901:
          v6 = 123;
          goto LABEL_152;
        case 35905:
          v6 = 29;
          goto LABEL_152;
        case 35907:
          v6 = 43;
          goto LABEL_152;
        case 35916:
          v6 = 132;
          goto LABEL_152;
        case 35917:
          v6 = 134;
          goto LABEL_152;
        case 35918:
          v6 = 136;
          goto LABEL_152;
        case 35919:
          v6 = 138;
          goto LABEL_152;
        case 35952:
LABEL_35:
          v6 = 139;
          goto LABEL_152;
        case 35953:
LABEL_36:
          v6 = 140;
          goto LABEL_152;
        case 35954:
LABEL_37:
          v6 = 141;
          goto LABEL_152;
        case 35955:
LABEL_38:
          v6 = 142;
          goto LABEL_152;
        case 36012:
LABEL_39:
          v6 = 126;
          goto LABEL_152;
        case 36013:
LABEL_40:
          v6 = 130;
          goto LABEL_152;
        default:
          switch(v4)
          {
            case 35412:
            case 35414:
              v6 = 1000054004;
              goto LABEL_152;
            case 35413:
            case 35415:
              v6 = 1000054005;
              goto LABEL_152;
            default:
              return appended;
          }
      }
      return appended;
    }
    switch(v4)
    {
      case 33776:
        v6 = 131;
        break;
      case 33777:
        v6 = 133;
        break;
      case 33778:
        v6 = 135;
        break;
      case 33779:
        v6 = 137;
        break;
      default:
        switch(v4)
        {
          case 34836:
            v6 = 109;
            goto LABEL_152;
          case 34837:
            v6 = 106;
            goto LABEL_152;
          case 34838:
          case 34839:
          case 34840:
          case 34841:
            return appended;
          case 34842:
            v6 = 97;
            goto LABEL_152;
          case 34843:
            v6 = 90;
            goto LABEL_152;
          default:
            if (v4 != 35056)
              return appended;
            v6 = 129;
            break;
        }
        break;
    }
  }
  else
  {
    if (v4 <= 37174)
    {
      if (v4 > 36491)
      {
        switch(v4)
        {
          case 36756:
            v6 = 10;
            goto LABEL_152;
          case 36757:
            v6 = 17;
            goto LABEL_152;
          case 36758:
            v6 = 24;
            goto LABEL_152;
          case 36759:
            v6 = 38;
            goto LABEL_152;
          case 36760:
            v6 = 71;
            goto LABEL_152;
          case 36761:
            v6 = 78;
            goto LABEL_152;
          case 36762:
            v6 = 85;
            goto LABEL_152;
          case 36763:
            v6 = 92;
            goto LABEL_152;
          case 36764:
          case 36765:
          case 36766:
          case 36767:
          case 36768:
          case 36769:
          case 36770:
          case 36771:
          case 36772:
          case 36773:
          case 36774:
          case 36775:
          case 36776:
          case 36777:
          case 36778:
          case 36779:
          case 36780:
          case 36781:
          case 36782:
          case 36783:
          case 36784:
          case 36785:
          case 36786:
          case 36787:
          case 36788:
          case 36789:
          case 36790:
          case 36791:
          case 36792:
          case 36793:
          case 36794:
          case 36795:
          case 36796:
            return appended;
          case 36797:
            v6 = 15;
            goto LABEL_152;
          case 36798:
            v6 = 22;
            goto LABEL_152;
          default:
            switch(v4)
            {
              case 36492:
                v6 = 145;
                goto LABEL_152;
              case 36493:
                v6 = 146;
                goto LABEL_152;
              case 36494:
                v6 = 144;
                goto LABEL_152;
              case 36495:
                v6 = 143;
                goto LABEL_152;
              default:
                if (v4 != 36975)
                  return appended;
                v6 = 62;
                break;
            }
            goto LABEL_152;
        }
      }
      else
      {
        switch(v4)
        {
          case 36168:
            v6 = 127;
            goto LABEL_152;
          case 36194:
            v6 = 4;
            goto LABEL_152;
          case 36196:
LABEL_34:
            v6 = 147;
            goto LABEL_152;
          case 36208:
            v6 = 107;
            goto LABEL_152;
          case 36209:
            v6 = 104;
            goto LABEL_152;
          case 36214:
            v6 = 95;
            goto LABEL_152;
          case 36215:
            v6 = 88;
            goto LABEL_152;
          case 36220:
            v6 = 41;
            goto LABEL_152;
          case 36221:
            v6 = 27;
            goto LABEL_152;
          case 36226:
            v6 = 108;
            goto LABEL_152;
          case 36227:
            v6 = 105;
            goto LABEL_152;
          case 36232:
            v6 = 96;
            goto LABEL_152;
          case 36233:
            v6 = 89;
            goto LABEL_152;
          case 36238:
            v6 = 42;
            goto LABEL_152;
          case 36239:
            v6 = 28;
            goto LABEL_152;
          case 36267:
            goto LABEL_39;
          case 36268:
            goto LABEL_40;
          case 36283:
            goto LABEL_35;
          case 36284:
            goto LABEL_36;
          case 36285:
            goto LABEL_37;
          case 36286:
            goto LABEL_38;
          default:
            return appended;
        }
      }
      return appended;
    }
    switch(v4)
    {
      case 37488:
        v6 = 153;
        break;
      case 37489:
        v6 = 154;
        break;
      case 37490:
        v6 = 155;
        break;
      case 37491:
        v6 = 156;
        break;
      case 37492:
        goto LABEL_34;
      case 37493:
        v6 = 148;
        break;
      case 37494:
        v6 = 149;
        break;
      case 37495:
        v6 = 150;
        break;
      case 37496:
        v6 = 151;
        break;
      case 37497:
        v6 = 152;
        break;
      case 37498:
      case 37499:
      case 37500:
      case 37501:
      case 37502:
      case 37503:
      case 37504:
      case 37505:
      case 37506:
      case 37507:
      case 37508:
      case 37509:
      case 37510:
      case 37511:
      case 37512:
      case 37513:
      case 37514:
      case 37515:
      case 37516:
      case 37517:
      case 37518:
      case 37519:
      case 37520:
      case 37521:
      case 37522:
      case 37523:
      case 37524:
      case 37525:
      case 37526:
      case 37527:
      case 37528:
      case 37529:
      case 37530:
      case 37531:
      case 37532:
      case 37533:
      case 37534:
      case 37535:
      case 37536:
      case 37537:
      case 37538:
      case 37539:
      case 37540:
      case 37541:
      case 37542:
      case 37543:
      case 37544:
      case 37545:
      case 37546:
      case 37547:
      case 37548:
      case 37549:
      case 37550:
      case 37551:
      case 37552:
      case 37553:
      case 37554:
      case 37555:
      case 37556:
      case 37557:
      case 37558:
      case 37559:
      case 37560:
      case 37561:
      case 37562:
      case 37563:
      case 37564:
      case 37565:
      case 37566:
      case 37567:
      case 37568:
      case 37569:
      case 37570:
      case 37571:
      case 37572:
      case 37573:
      case 37574:
      case 37575:
      case 37576:
      case 37577:
      case 37578:
      case 37579:
      case 37580:
      case 37581:
      case 37582:
      case 37583:
      case 37584:
      case 37585:
      case 37586:
      case 37587:
      case 37588:
      case 37589:
      case 37590:
      case 37591:
      case 37592:
      case 37593:
      case 37594:
      case 37595:
      case 37596:
      case 37597:
      case 37598:
      case 37599:
      case 37600:
      case 37601:
      case 37602:
      case 37603:
      case 37604:
      case 37605:
      case 37606:
      case 37607:
      case 37608:
      case 37609:
      case 37610:
      case 37611:
      case 37612:
      case 37613:
      case 37614:
      case 37615:
      case 37616:
      case 37617:
      case 37618:
      case 37619:
      case 37620:
      case 37621:
      case 37622:
      case 37623:
      case 37624:
      case 37625:
      case 37626:
      case 37627:
      case 37628:
      case 37629:
      case 37630:
      case 37631:
      case 37632:
      case 37633:
      case 37634:
      case 37635:
      case 37636:
      case 37637:
      case 37638:
      case 37639:
      case 37640:
      case 37641:
      case 37642:
      case 37643:
      case 37644:
      case 37645:
      case 37646:
      case 37647:
      case 37648:
      case 37649:
      case 37650:
      case 37651:
      case 37652:
      case 37653:
      case 37654:
      case 37655:
      case 37656:
      case 37657:
      case 37658:
      case 37659:
      case 37660:
      case 37661:
      case 37662:
      case 37663:
      case 37664:
      case 37665:
      case 37666:
      case 37667:
      case 37668:
      case 37669:
      case 37670:
      case 37671:
      case 37672:
      case 37673:
      case 37674:
      case 37675:
      case 37676:
      case 37677:
      case 37678:
      case 37679:
      case 37680:
      case 37681:
      case 37682:
      case 37683:
      case 37684:
      case 37685:
      case 37686:
      case 37687:
      case 37688:
      case 37689:
      case 37690:
      case 37691:
      case 37692:
      case 37693:
      case 37694:
      case 37695:
      case 37696:
      case 37697:
      case 37698:
      case 37699:
      case 37700:
      case 37701:
      case 37702:
      case 37703:
      case 37704:
      case 37705:
      case 37706:
      case 37707:
      case 37708:
      case 37709:
      case 37710:
      case 37711:
      case 37712:
      case 37713:
      case 37714:
      case 37715:
      case 37716:
      case 37717:
      case 37718:
      case 37719:
      case 37720:
      case 37721:
      case 37722:
      case 37723:
      case 37724:
      case 37725:
      case 37726:
      case 37727:
      case 37728:
      case 37729:
      case 37730:
      case 37731:
      case 37732:
      case 37733:
      case 37734:
      case 37735:
      case 37736:
      case 37737:
      case 37738:
      case 37739:
      case 37740:
      case 37741:
      case 37742:
      case 37743:
      case 37744:
      case 37745:
      case 37746:
      case 37747:
      case 37748:
      case 37749:
      case 37750:
      case 37751:
      case 37752:
      case 37753:
      case 37754:
      case 37755:
      case 37756:
      case 37757:
      case 37758:
      case 37759:
      case 37760:
      case 37761:
      case 37762:
      case 37763:
      case 37764:
      case 37765:
      case 37766:
      case 37767:
      case 37768:
      case 37769:
      case 37770:
      case 37771:
      case 37772:
      case 37773:
      case 37774:
      case 37775:
      case 37776:
      case 37777:
      case 37778:
      case 37779:
      case 37780:
      case 37781:
      case 37782:
      case 37783:
      case 37784:
      case 37785:
      case 37786:
      case 37787:
      case 37788:
      case 37789:
      case 37790:
      case 37791:
      case 37792:
      case 37793:
      case 37794:
      case 37795:
      case 37796:
      case 37797:
      case 37798:
      case 37799:
      case 37800:
      case 37801:
      case 37802:
      case 37803:
      case 37804:
      case 37805:
      case 37806:
      case 37807:
      case 37822:
      case 37823:
      case 37824:
      case 37825:
      case 37826:
      case 37827:
      case 37828:
      case 37829:
      case 37830:
      case 37831:
      case 37832:
      case 37833:
      case 37834:
      case 37835:
      case 37836:
      case 37837:
      case 37838:
      case 37839:
      case 37854:
      case 37855:
      case 37856:
      case 37857:
      case 37858:
      case 37859:
      case 37860:
      case 37861:
      case 37862:
      case 37863:
      case 37864:
      case 37865:
      case 37866:
      case 37867:
      case 37868:
      case 37869:
      case 37870:
      case 37871:
        return appended;
      case 37808:
        v6 = 157;
        break;
      case 37809:
        v6 = 159;
        break;
      case 37810:
        v6 = 161;
        break;
      case 37811:
        v6 = 163;
        break;
      case 37812:
        v6 = 165;
        break;
      case 37813:
        v6 = 167;
        break;
      case 37814:
        v6 = 169;
        break;
      case 37815:
        v6 = 171;
        break;
      case 37816:
        v6 = 173;
        break;
      case 37817:
        v6 = 175;
        break;
      case 37818:
        v6 = 177;
        break;
      case 37819:
        v6 = 179;
        break;
      case 37820:
        v6 = 181;
        break;
      case 37821:
        v6 = 183;
        break;
      case 37840:
        v6 = 158;
        break;
      case 37841:
        v6 = 160;
        break;
      case 37842:
        v6 = 162;
        break;
      case 37843:
        v6 = 164;
        break;
      case 37844:
        v6 = 166;
        break;
      case 37845:
        v6 = 168;
        break;
      case 37846:
        v6 = 170;
        break;
      case 37847:
        v6 = 172;
        break;
      case 37848:
        v6 = 174;
        break;
      case 37849:
        v6 = 176;
        break;
      case 37850:
        v6 = 178;
        break;
      case 37851:
        v6 = 180;
        break;
      case 37852:
        v6 = 182;
        break;
      case 37853:
        v6 = 184;
        break;
      case 37872:
        v6 = 1000054006;
        break;
      case 37873:
        v6 = 1000054007;
        break;
      default:
        if (v4 == 37175)
        {
          v6 = 1000054002;
        }
        else
        {
          if (v4 != 37176)
            return appended;
          v6 = 1000054003;
        }
        break;
    }
  }
LABEL_152:
  HIDWORD(v59) = v6;
  *(_QWORD *)&v60 = __PAIR64__(*(_DWORD *)(a1 + 36), ktxTexture1_glTypeSize(a1));
  v7 = *(_DWORD *)(a1 + 48);
  if (v7 <= 1)
  {
    *((_QWORD *)&v60 + 1) = 0;
    v8 = *(unsigned __int8 *)(a1 + 32);
    if (!*(_BYTE *)(a1 + 32))
      goto LABEL_158;
    goto LABEL_157;
  }
  DWORD2(v60) = *(_DWORD *)(a1 + 40);
  if (v7 == 2)
  {
    HIDWORD(v60) = 0;
    v8 = *(unsigned __int8 *)(a1 + 32);
    if (!*(_BYTE *)(a1 + 32))
      goto LABEL_158;
LABEL_157:
    v8 = *(_DWORD *)(a1 + 56);
    goto LABEL_158;
  }
  HIDWORD(v60) = *(_DWORD *)(a1 + 44);
  v8 = *(unsigned __int8 *)(a1 + 32);
  if (*(_BYTE *)(a1 + 32))
    goto LABEL_157;
LABEL_158:
  *(_QWORD *)&v61 = __PAIR64__(*(_DWORD *)(a1 + 60), v8);
  v9 = *(_DWORD *)(a1 + 52);
  if (*(_BYTE *)(a1 + 35))
    v10 = 0;
  else
    v10 = *(_DWORD *)(a1 + 52);
  DWORD2(v61) = v10;
  v11 = (24 * v9);
  v12 = (char *)malloc_type_malloc(v11, 0x3F73FD7FuLL);
  v13 = vk2dfd(v6);
  if (v13)
  {
    v48 = v13;
    v49 = v12;
    v57 = 0;
    v56 = 0;
    LODWORD(v62) = v11 + 80;
    v14 = *(_DWORD *)v13;
    DWORD1(v62) = *(_DWORD *)v13;
    v51 = a1;
    v17 = *(_QWORD *)(a1 + 80);
    v16 = (uint64_t *)(a1 + 80);
    v15 = v17;
    v55 = v17;
    if (v17)
    {
      while (1)
      {
        v54 = 0;
        v53 = 0;
        ktxHashListEntry_GetKey(v15, &v54, &v53);
        v18 = v53;
        if (!strncasecmp(v53, "KTX", 3uLL) && strcmp(v18, "KTXorientation") && strcmp(v18, "KTXwriter"))
          break;
        v15 = ktxHashList_Next(v55);
        v55 = v15;
        if (!v15)
          goto LABEL_169;
      }
      appended = 10;
      goto LABEL_178;
    }
LABEL_169:
    v19 = v51;
    if (!ktxHashList_FindEntry(v16, "KTXorientation", &v55))
    {
      v53 = 0;
      v54 = 0;
      v52 = 0;
      ktxHashListEntry_GetValue(v55, &v54, &v53);
      v20 = sscanf(v53, "S=%c,T=%c,R=%c", &v52, (char *)&v52 + 1, (char *)&v52 + 2);
      v21 = *(unsigned int *)(v51 + 48);
      if (v20 < v21)
      {
        appended = 1;
LABEL_178:
        free(v48);
        free(v49);
        return appended;
      }
      v22 = v20;
      if (v20 > v21)
      {
        *((_BYTE *)&v52 + v21) = 0;
        v22 = v21;
      }
      ktxHashList_DeleteEntry(v16, v55);
      ktxHashList_AddKVPair((uint64_t)v16, "KTXorientation", v22 + 1, &v52);
    }
    v55 = 0;
    ktxHashList_FindEntry(v16, "KTXwriter", &v55);
    appended = appendLibId(v16, v55);
    if ((_DWORD)appended)
      goto LABEL_178;
    ktxHashList_Sort((uint64_t)v16);
    ktxHashList_Serialize((unsigned int **)v16, &v57, (unsigned int **)&v56);
    if (v57)
      v24 = v14 + v11 + 80;
    else
      v24 = 0;
    *((_QWORD *)&v62 + 1) = __PAIR64__(v57, v24);
    v25 = v57 + v14 + v11 + 80;
    v63 = 0uLL;
    v26 = (float)lcm4(*(_DWORD *)(*(_QWORD *)(v51 + 24) + 32) >> 3);
    v27 = (float)-(float)((float)v25 - (float)(v26 * ceilf((float)v25 / v26)));
    v28 = *(_DWORD *)(v51 + 52) - 1;
    if (v28 >= 0)
    {
      v29 = v25 + v27;
      v30 = (int64x2_t *)&v49[24 * v28 + 8];
      do
      {
        v31 = ktxTexture_calcLevelSize(v51, v28, 2);
        *v30 = vdupq_n_s64(v31);
        v30[-1].i64[1] = v29;
        v29 += (float)(ceilf((float)v31 / v26) * v26);
        --v28;
        v30 = (int64x2_t *)((char *)v30 - 24);
      }
      while (v28 != -1);
    }
    appended = (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(a2 + 16))(a2, &v59, 80, 1);
    if (!(_DWORD)appended)
    {
      appended = (*(uint64_t (**)(uint64_t, char *, size_t, uint64_t))(a2 + 16))(a2, v49, v11, 1);
      if (!(_DWORD)appended)
      {
        v32 = (*(uint64_t (**)(uint64_t, char *, uint64_t, _QWORD))(a2 + 16))(a2, v48, 1, *(unsigned int *)v48);
        if (v57)
        {
          appended = (*(uint64_t (**)(uint64_t, void *, uint64_t))(a2 + 16))(a2, v56, 1);
          free(v56);
          if ((_DWORD)appended)
            return appended;
        }
        else
        {
          appended = v32;
        }
        memset(v58, 0, sizeof(v58));
        if (!(_DWORD)v27
          || (appended = (*(uint64_t (**)(uint64_t, _OWORD *, uint64_t, uint64_t))(a2 + 16))(a2, v58, 1, v27),
              !(_DWORD)appended))
        {
          v33 = *(_DWORD *)(v51 + 52);
          v34 = (v33 - 1);
          if (v33 - 1 >= 0 && !(_DWORD)appended)
          {
            do
            {
              v35 = ktxTexture_calcImageSize(v19, v34, 2);
              if (*(_DWORD *)(v19 + 44) >> v34 <= 1u)
                v37 = 1;
              else
                v37 = *(_DWORD *)(v19 + 44) >> v34;
              if (*(_BYTE *)(v19 + 33))
                v37 = *(_DWORD *)(v19 + 60);
              v52 = 0;
              LODWORD(v53) = 0;
              v54 = 0;
              if (!*(_BYTE *)(v19 + 34))
                v36.n128_f32[0] = ktxTexture_rowInfo(v19, v34, (unsigned int *)&v53, &v54, &v52);
              v38 = (*(uint64_t (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)(v19 + 24) + 16))(v19, v34, v36);
              v47 = v34;
              if (*(_DWORD *)(v19 + 56) && v37)
              {
                v39 = v38;
                v40 = 0;
                v41 = 0;
                appended = 0;
                do
                {
                  v50 = v41;
                  for (i = 0; i != v37; ++i)
                  {
                    if (v52)
                    {
                      if ((_DWORD)v53)
                      {
                        v43 = 0;
                        v44 = *(_QWORD *)(v19 + 112) + v39;
                        v45 = (v54 - v52);
                        do
                        {
                          v46 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 16))(a2, v44 + v54 * v43, v45, 1);
                          v40 += v45;
                          ++v43;
                        }
                        while (v43 < v53);
                        appended = v46;
                        v19 = v51;
                      }
                    }
                    else
                    {
                      appended = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(a2 + 16))(a2, *(_QWORD *)(v19 + 112) + v39, v35, 1);
                      v40 += v35;
                    }
                    v39 += v35;
                  }
                  v41 = v50 + 1;
                }
                while ((v50 + 1) < *(_DWORD *)(v19 + 56));
              }
              else
              {
                appended = 0;
                v40 = 0;
              }
              if (v47 && !(_DWORD)appended)
              {
                if ((float)-(float)((float)v40 - (float)(v26 * ceilf((float)v40 / v26))))
                  appended = (*(uint64_t (**)(uint64_t, _OWORD *, uint64_t))(a2 + 16))(a2, v58, 1);
                else
                  appended = 0;
              }
              if (v47 < 1)
                break;
              v34 = (v47 - 1);
            }
            while (!(_DWORD)appended);
          }
          goto LABEL_178;
        }
      }
    }
  }
  return appended;
}

uint64_t ktxTexture1_WriteKTX2ToStdioStream(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v4[6];
  uint64_t v5;

  if (!a1)
    return 11;
  v5 = 0;
  memset(v4, 0, sizeof(v4));
  result = ktxFileStream_construct((uint64_t)v4, a2, 0);
  if (!(_DWORD)result)
    return ktxTexture1_WriteKTX2ToStream(a1, (uint64_t)v4);
  return result;
}

uint64_t ktxTexture1_WriteKTX2ToNamedFile(uint64_t a1, char *__filename)
{
  FILE *v3;
  FILE *v4;
  uint64_t v5;
  _OWORD v7[6];
  uint64_t v8;

  if (!a1)
    return 11;
  v3 = fopen(__filename, "wb");
  if (!v3)
    return 3;
  v4 = v3;
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  v5 = ktxFileStream_construct((uint64_t)v7, (uint64_t)v3, 0);
  if (!(_DWORD)v5)
    v5 = ktxTexture1_WriteKTX2ToStream(a1, (uint64_t)v7);
  fclose(v4);
  return v5;
}

uint64_t ktxTexture1_WriteKTX2ToMemory(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v8;
  uint64_t v9;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v3 = 11;
  if (!a1)
    return v3;
  if (!a2)
    return v3;
  if (!a3)
    return v3;
  v15 = 0;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  memset(v10, 0, sizeof(v10));
  v9 = 0;
  *a2 = 0;
  v3 = ktxMemStream_construct((uint64_t)v10, 0);
  if ((_DWORD)v3)
    return v3;
  v8 = ktxTexture1_WriteKTX2ToStream(a1, (uint64_t)v10);
  if (!(_DWORD)v8)
  {
    ktxMemStream_getdata((uint64_t)v10, a2);
    (*((void (**)(_OWORD *, uint64_t *))&v11 + 1))(v10, &v9);
    *a3 = (int)v9;
  }
  ktxMemStream_destruct((uint64_t)v10);
  return v8;
}

uint64_t appendLibId(uint64_t *a1, uint64_t a2)
{
  char *v4;
  int v5;
  char *v6;
  uint64_t v7;
  const char *v8;
  int v9;
  unsigned int v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  _DWORD __n[3];

  memset(__n, 0, sizeof(__n));
  if (a2)
  {
    ktxHashListEntry_GetValue(a2, __n, &__n[1]);
    v4 = *(char **)&__n[1];
    v5 = __n[0];
  }
  else
  {
    v4 = "Unidentified app";
    *(_QWORD *)&__n[1] = "Unidentified app";
    v5 = 17;
    __n[0] = 17;
  }
  v6 = strstr(v4, "__default__");
  v7 = (v5 - 1);
  if (v4[v7])
    LODWORD(v7) = v5;
  else
    __n[0] = v5 - 1;
  if (v6)
    v8 = "v4.0.__default__";
  else
    v8 = "v4.0.0-76-g16d3b6b4-dirty";
  v9 = 27;
  if (!v6)
    v9 = 36;
  v10 = v9 + v7;
  v11 = (char *)malloc_type_malloc((v9 + v7), 0x213DE4D8uLL);
  v12 = strncpy(v11, *(const char **)&__n[1], __n[0]);
  v13 = &v12[__n[0]];
  strcpy(v13, " / libktx ");
  strcpy(v13 + 10, v8);
  ktxHashList_DeleteEntry(a1, a2);
  v14 = ktxHashList_AddKVPair((uint64_t)a1, "KTXwriter", v10, v11);
  free(v11);
  return v14;
}

uint64_t ktxTexture2_setImageFromStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (**a5)(_QWORD, uint64_t, uint64_t), uint64_t a6)
{
  uint64_t result;
  uint64_t v11;

  result = 11;
  if (a1 && a5)
  {
    if (*(_QWORD *)(a1 + 112))
    {
      v11 = 0;
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(a1 + 8) + 8))(a1, a2, a3, a4, &v11);
      if ((_DWORD)result)
        return result;
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, a2) == a6)
      {
        (*a5)(a5, *(_QWORD *)(a1 + 112) + v11, a6);
        return 0;
      }
    }
    return 10;
  }
  return result;
}

uint64_t ktxTexture2_SetImageFromStdioStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  _OWORD v13[6];
  uint64_t v14;
  uint64_t v15;

  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v11 = ktxFileStream_construct((uint64_t)v13, a5, 0);
  if (!(_DWORD)v11)
  {
    if (!a1)
    {
      v11 = 11;
      goto LABEL_9;
    }
    if (*(_QWORD *)(a1 + 112))
    {
      v15 = 0;
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(a1 + 8) + 8))(a1, a2, a3, a4, &v15);
      if ((_DWORD)v11)
      {
LABEL_9:
        ktxFileStream_destruct((uint64_t)v13);
        return v11;
      }
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, a2) == a6)
      {
        (*(void (**)(_OWORD *, uint64_t, uint64_t))&v13[0])(v13, *(_QWORD *)(a1 + 112) + v15, a6);
        v11 = 0;
        goto LABEL_9;
      }
    }
    v11 = 10;
    goto LABEL_9;
  }
  return v11;
}

uint64_t ktxTexture2_SetImageFromMemory(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  _OWORD v13[6];
  uint64_t v14;
  uint64_t v15;

  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v11 = ktxMemStream_construct_ro((uint64_t)v13, a5, a6);
  if (!(_DWORD)v11)
  {
    if (!a1)
    {
      v11 = 11;
      goto LABEL_9;
    }
    if (*(_QWORD *)(a1 + 112))
    {
      v15 = 0;
      v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(a1 + 8) + 8))(a1, a2, a3, a4, &v15);
      if ((_DWORD)v11)
      {
LABEL_9:
        ktxMemStream_destruct((uint64_t)v13);
        return v11;
      }
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 24))(a1, a2) == a6)
      {
        (*(void (**)(_OWORD *, uint64_t, uint64_t))&v13[0])(v13, *(_QWORD *)(a1 + 112) + v15, a6);
        v11 = 0;
        goto LABEL_9;
      }
    }
    v11 = 10;
    goto LABEL_9;
  }
  return v11;
}

uint64_t ktxTexture2_WriteToStream(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t appended;
  int v8;
  unsigned int v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t i;
  const char *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  _OWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  char *v35;
  unint64_t v36;
  unint64_t v37;
  BOOL v38;
  char v39;
  BOOL v41;
  int64x2_t v43;
  const double *v44;
  uint64_t v45;
  double *v46;
  const double *v47;
  double *v48;
  double *v49;
  uint64_t v50;
  signed int v51;
  unint64_t *v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  float v57;
  size_t size;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  unsigned int v63;
  char *v64[2];
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  float64x2x3_t v72;
  float64x2x3_t v73;

  v71 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD **)(a1 + 160);
  v68 = xmmword_18823F868;
  v69 = unk_18823F878;
  v70 = xmmword_18823F888;
  v66 = xmmword_18823F848;
  v67 = unk_18823F858;
  if (!a2)
    return 11;
  if (!*(_QWORD *)(a1 + 112))
    return 10;
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 56);
  HIDWORD(v66) = *(_DWORD *)(a1 + 120);
  LODWORD(v67) = v4;
  DWORD1(v67) = *(_DWORD *)(a1 + 36);
  v5 = *(_DWORD *)(a1 + 48);
  if (v5 <= 1)
  {
    *((_QWORD *)&v67 + 1) = 0;
    v6 = *(unsigned __int8 *)(a1 + 32);
    v59 = v2;
    v60 = a2;
    if (!*(_BYTE *)(a1 + 32))
      goto LABEL_10;
    goto LABEL_9;
  }
  DWORD2(v67) = *(_DWORD *)(a1 + 40);
  if (v5 == 2)
  {
    HIDWORD(v67) = 0;
    v6 = *(unsigned __int8 *)(a1 + 32);
    v59 = v2;
    v60 = a2;
    if (!*(_BYTE *)(a1 + 32))
      goto LABEL_10;
LABEL_9:
    v6 = *(_DWORD *)(a1 + 56);
    goto LABEL_10;
  }
  HIDWORD(v67) = *(_DWORD *)(a1 + 44);
  v6 = *(unsigned __int8 *)(a1 + 32);
  v59 = v2;
  v60 = a2;
  if (*(_BYTE *)(a1 + 32))
    goto LABEL_9;
LABEL_10:
  *(_QWORD *)&v68 = __PAIR64__(*(_DWORD *)(a1 + 60), v6);
  v8 = *(_DWORD *)(a1 + 52);
  if (*(_BYTE *)(a1 + 35))
    v9 = 0;
  else
    v9 = *(_DWORD *)(a1 + 52);
  v63 = 0;
  v62 = 0;
  *((_QWORD *)&v68 + 1) = __PAIR64__(*(_DWORD *)(a1 + 136), v9);
  size = (24 * v8);
  LODWORD(v69) = size + 80;
  v10 = *(_DWORD **)(a1 + 128);
  v11 = *v10;
  DWORD1(v69) = *v10;
  for (i = *(_QWORD *)(a1 + 80); i; i = ktxHashList_Next(i))
  {
    LODWORD(v61) = 0;
    v64[0] = 0;
    ktxHashListEntry_GetKey(i, &v61, v64);
    v13 = v64[0];
    if (!strncasecmp(v64[0], "KTX", 3uLL)
      && (!strncmp(v13, "ktx", 3uLL)
       || strcmp(v13, "KTXcubemapIncomplete")
       && strcmp(v13, "KTXorientation")
       && strcmp(v13, "KTXglFormat")
       && strcmp(v13, "KTXdxgiFormat__")
       && strcmp(v13, "KTXmetalPixelFormat")
       && strcmp(v13, "KTXswizzle")
       && strcmp(v13, "KTXwriter")
       && strcmp(v13, "KTXwriterScParams")
       && strcmp(v13, "KTXastcDecodeMode")
       && strcmp(v13, "KTXanimData")))
    {
      return 10;
    }
  }
  v61 = 0;
  ktxHashList_FindEntry((uint64_t *)(a1 + 80), "KTXwriter", &v61);
  appended = appendLibId((uint64_t *)(a1 + 80), v61);
  if (!(_DWORD)appended)
  {
    ktxHashList_Sort(a1 + 80);
    ktxHashList_Serialize((unsigned int **)(a1 + 80), &v63, (unsigned int **)&v62);
    v14 = v63 ? size + 80 + v11 : 0;
    *((_QWORD *)&v69 + 1) = __PAIR64__(v63, v14);
    v15 = size + 80 + v11 + v63;
    v16 = v59[2];
    if (v16)
    {
      v17 = (float)-(float)((float)(unint64_t)v15
                                        - (float)(ceilf((float)(unint64_t)v15 * 0.125) * 8.0));
      v18 = v15 + v17;
      v15 += v17;
    }
    else
    {
      v18 = 0;
      LODWORD(v17) = 0;
    }
    *(_QWORD *)&v70 = v18;
    *((_QWORD *)&v70 + 1) = v16;
    v19 = *(_DWORD *)(*(_QWORD *)(a1 + 160) + 8);
    appended = (*(uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t))(v60 + 16))(v60, &v66, 80, 1);
    if (!(_DWORD)appended)
    {
      v21 = (char *)malloc_type_malloc(size, 0x6498B1EFuLL);
      if (!v21)
        return 13;
      v22 = v21;
      v23 = v15 + v16;
      v24 = (float)-(float)((float)(unint64_t)(v15 + v16)
                                        - (float)((float)v19 * ceilf((float)(unint64_t)(v15 + v16) / (float)v19)));
      v25 = *(unsigned int *)(a1 + 52);
      if ((_DWORD)v25)
      {
        v26 = v23 + v24;
        if (v25 < 0xC)
        {
          v27 = 0;
LABEL_44:
          v28 = &v21[24 * v27 + 8];
          v29 = &v59[3 * v27 + 5];
          v30 = v25 - v27;
          do
          {
            *(_OWORD *)v28 = *v29;
            *((_QWORD *)v28 - 1) = v26 + *((_QWORD *)v29 - 1);
            v28 += 24;
            v29 = (_OWORD *)((char *)v29 + 24);
            --v30;
          }
          while (v30);
          goto LABEL_46;
        }
        v27 = 0;
        v33 = (unint64_t)&v21[24 * v25];
        v34 = v33 - 8;
        v35 = (char *)&v59[3 * v25];
        v36 = (unint64_t)(v35 + 24);
        v37 = (unint64_t)(v35 + 16);
        v38 = v21 + 16 >= v35 + 32 || (unint64_t)(v59 + 6) >= v33;
        v39 = !v38;
        v41 = (unint64_t)v21 < v37 && (unint64_t)(v59 + 4) < v33 - 16;
        if ((unint64_t)(v59 + 5) < v34 && (unint64_t)(v21 + 8) < v36)
          goto LABEL_44;
        if ((v39 & 1) != 0)
          goto LABEL_44;
        if (v41)
          goto LABEL_44;
        v27 = v25 & 0xFFFFFFFC;
        v43 = vdupq_n_s64(v26);
        v44 = (const double *)(v59 + 10);
        v45 = v27;
        v46 = (double *)v21;
        do
        {
          v47 = v44 - 6;
          v72 = vld3q_f64(v47);
          v73 = vld3q_f64(v44);
          v72.val[0] = (float64x2_t)vaddq_s64(v43, (int64x2_t)v72.val[0]);
          v73.val[0] = (float64x2_t)vaddq_s64(v43, (int64x2_t)v73.val[0]);
          v48 = v46 + 12;
          vst3q_f64(v46, v72);
          v49 = v46 + 6;
          vst3q_f64(v49, v73);
          v44 += 12;
          v46 = v48;
          v45 -= 4;
        }
        while (v45);
        if (v27 != v25)
          goto LABEL_44;
      }
LABEL_46:
      appended = (*(uint64_t (**)(uint64_t, char *, size_t, uint64_t, _QWORD *))(v60 + 16))(v60, v21, size, 1, v59);
      free(v22);
      if (!(_DWORD)appended)
      {
        v31 = v60;
        v32 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD))(v60 + 16))(v60, *(_QWORD *)(a1 + 128), 1, **(unsigned int **)(a1 + 128));
        if (v63)
        {
          appended = (*(uint64_t (**)(uint64_t, void *, uint64_t))(v60 + 16))(v60, v62, 1);
          free(v62);
          if ((_DWORD)appended)
            return appended;
          v31 = v60;
        }
        else
        {
          appended = v32;
        }
        *(_OWORD *)v64 = 0u;
        v65 = 0u;
        v50 = v59[2];
        if (v50)
        {
          if ((_DWORD)v17)
          {
            appended = (*(uint64_t (**)(uint64_t, char **, uint64_t, _QWORD))(v31 + 16))(v31, v64, 1, v17);
            if ((_DWORD)appended)
              return appended;
            v50 = v59[2];
          }
          appended = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v31 + 16))(v31, *v59, 1, v50);
          if ((_DWORD)appended)
            return appended;
        }
        if (!(_DWORD)v24
          || (appended = (*(uint64_t (**)(uint64_t, char **, uint64_t, uint64_t))(v31 + 16))(v31, v64, 1, v24),
              !(_DWORD)appended))
        {
          v51 = *(_DWORD *)(a1 + 52) - 1;
          if (v51 >= 0 && !(_DWORD)appended)
          {
            v52 = &v59[3 * v51 + 5];
            do
            {
              v53 = ktxTexture2_levelDataOffset(a1, v51);
              v55 = *v52;
              v52 -= 3;
              v54 = v55;
              v56 = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(v31 + 16))(v31, *(_QWORD *)(a1 + 112) + v53, v55, 1);
              appended = v56;
              if (v51 && !(_DWORD)v56)
              {
                v57 = (float)*(unsigned int *)(*(_QWORD *)(a1 + 160) + 8);
                if ((float)-(float)((float)v54 - (float)(v57 * ceilf((float)v54 / v57))))
                  appended = (*(uint64_t (**)(uint64_t, char **, uint64_t))(v31 + 16))(v31, v64, 1);
                else
                  appended = 0;
              }
              v38 = v51-- != 0;
            }
            while (v38 && !(_DWORD)appended);
          }
        }
      }
    }
  }
  return appended;
}

uint64_t ktxTexture2_WriteToStdioStream(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v4[6];
  uint64_t v5;

  if (!a1)
    return 11;
  v5 = 0;
  memset(v4, 0, sizeof(v4));
  result = ktxFileStream_construct((uint64_t)v4, a2, 0);
  if (!(_DWORD)result)
    return ktxTexture2_WriteToStream(a1, (uint64_t)v4);
  return result;
}

uint64_t ktxTexture2_WriteToNamedFile(uint64_t a1, char *__filename)
{
  FILE *v3;
  FILE *v4;
  uint64_t v5;
  _OWORD v7[6];
  uint64_t v8;

  if (!a1)
    return 11;
  v3 = fopen(__filename, "wb");
  if (!v3)
    return 3;
  v4 = v3;
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  v5 = ktxFileStream_construct((uint64_t)v7, (uint64_t)v3, 0);
  if (!(_DWORD)v5)
    v5 = ktxTexture2_WriteToStream(a1, (uint64_t)v7);
  fclose(v4);
  return v5;
}

uint64_t ktxTexture2_WriteToMemory(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v8;
  uint64_t v9;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v3 = 11;
  if (!a1)
    return v3;
  if (!a2)
    return v3;
  if (!a3)
    return v3;
  v15 = 0;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  memset(v10, 0, sizeof(v10));
  v9 = 0;
  *a2 = 0;
  v3 = ktxMemStream_construct((uint64_t)v10, 0);
  if ((_DWORD)v3)
    return v3;
  v8 = ktxTexture2_WriteToStream(a1, (uint64_t)v10);
  if (!(_DWORD)v8)
  {
    ktxMemStream_getdata((uint64_t)v10, a2);
    (*((void (**)(_OWORD *, uint64_t *))&v11 + 1))(v10, &v9);
    *a3 = (int)v9;
  }
  ktxMemStream_destruct((uint64_t)v10);
  return v8;
}

uint64_t ktxTexture2_DeflateZstd(uint64_t a1, int a2)
{
  size_t v3;
  char *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t CCtx;
  uint64_t result;
  unint64_t v9;
  int v10;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  int v19;
  size_t __n;
  char *__src;
  char *__dst;

  v3 = (24 * *(_DWORD *)(a1 + 52));
  v4 = (char *)malloc_type_malloc(*(_QWORD *)(a1 + 104) + v3, 0x5D2CA718uLL);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(_QWORD *)(a1 + 160);
  CCtx = ZSTD_createCCtx();
  if (!v4)
    return 13;
  if (*(_DWORD *)(a1 + 136))
    return 10;
  v9 = CCtx;
  __src = &v4[v3];
  __dst = (char *)(v6 + 32);
  v10 = *(_DWORD *)(a1 + 52);
  __n = v3;
  if (v10 - 1 < 0)
  {
    v12 = 0;
LABEL_10:
    ZSTD_freeCCtx(v9);
    v17 = malloc_type_malloc(v12, 0xAF782C40uLL);
    if (v17)
    {
      v18 = v17;
      memcpy(v17, __src, v12);
      memcpy(__dst, v4, __n);
      free(v4);
      free(*(void **)(a1 + 112));
      result = 0;
      *(_QWORD *)(a1 + 104) = v12;
      *(_QWORD *)(a1 + 112) = v18;
      *(_DWORD *)(a1 + 136) = 2;
      *(_DWORD *)(*(_QWORD *)(a1 + 160) + 8) = 1;
      *(_DWORD *)(*(_QWORD *)(a1 + 128) + 20) = 0;
    }
    else
    {
      free(v4);
      return 13;
    }
  }
  else
  {
    v11 = 0;
    v12 = 0;
    v13 = 24 * (v10 - 1);
    while (1)
    {
      v14 = ZSTD_compressCCtx(v9, &__src[v11], v5, (char *)(*(_QWORD *)(a1 + 112) + *(_QWORD *)&__dst[v13]), *(_QWORD *)&__dst[v13 + 8], a2);
      if (ZSTD_isError(v14))
        break;
      v15 = &v4[v13];
      v16 = *(_QWORD *)&__dst[v13 + 8];
      *((_QWORD *)v15 + 1) = v14;
      *((_QWORD *)v15 + 2) = v16;
      *(_QWORD *)v15 = v11;
      v12 += v14;
      v11 += v14;
      v5 -= v14;
      --v10;
      v13 -= 24;
      if (v10 <= 0)
        goto LABEL_10;
    }
    free(v4);
    v19 = ZSTD_getErrorCode(v14) - 42;
    result = 11;
    switch(v19)
    {
      case 0:
        return result;
      case 22:
      case 24:
      case 28:
        return 13;
      default:
        return 10;
    }
  }
  return result;
}

void OFDLoadExternalSymbols(void)
{
  if (gLoadCoreTextSymbolsInitOnce != -1)
    dispatch_once(&gLoadCoreTextSymbolsInitOnce, &__block_literal_global_47);
}

void OFDExtractOFDObjectsFromCFArray(const __CFDictionary *a1, void **a2)
{
  CFTypeID TypeID;
  OFDTextObject *v5;
  unint64_t v6;
  OFDTextObject **v7;
  _QWORD *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  OFDTextObject *v13;
  OFDTextObject *v14;
  unint64_t v15;
  OFDTextObject **v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  OFDTextObject **v23;
  char *v24;
  char *v25;
  OFDTextObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  OFDTextObject **v32;
  char *v33;
  char *v34;
  char *v35;
  OFDTextObject *v36;

  if (a1)
  {
    TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      v5 = OFDCreateObject(a1);
      v6 = (unint64_t)a2[2];
      v7 = (OFDTextObject **)a2[1];
      if ((unint64_t)v7 >= v6)
      {
        v27 = ((char *)v7 - (_BYTE *)*a2) >> 3;
        if ((unint64_t)(v27 + 1) >> 61)
LABEL_43:
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v28 = v6 - (_QWORD)*a2;
        v29 = v28 >> 2;
        if (v28 >> 2 <= (unint64_t)(v27 + 1))
          v29 = v27 + 1;
        if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
          v30 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v30 = v29;
        if (v30)
          v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(a2 + 2), v30);
        else
          v31 = 0;
        v32 = (OFDTextObject **)&v31[8 * v27];
        v33 = &v31[8 * v30];
        *v32 = v5;
        v8 = v32 + 1;
        v35 = (char *)*a2;
        v34 = (char *)a2[1];
        if (v34 != *a2)
        {
          do
          {
            v36 = (OFDTextObject *)*((_QWORD *)v34 - 1);
            v34 -= 8;
            *--v32 = v36;
          }
          while (v34 != v35);
          v34 = (char *)*a2;
        }
        *a2 = v32;
        a2[1] = v8;
        a2[2] = v33;
        if (v34)
          operator delete(v34);
      }
      else
      {
        *v7 = v5;
        v8 = v7 + 1;
      }
      a2[1] = v8;
    }
    else
    {
      Count = CFArrayGetCount(a1);
      if (Count)
      {
        v10 = Count;
        for (i = 0; i != v10; ++i)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, i);
          v13 = OFDCreateObject(ValueAtIndex);
          if (v13)
          {
            v14 = v13;
            v16 = (OFDTextObject **)a2[1];
            v15 = (unint64_t)a2[2];
            if ((unint64_t)v16 >= v15)
            {
              v18 = ((char *)v16 - (_BYTE *)*a2) >> 3;
              if ((unint64_t)(v18 + 1) >> 61)
                goto LABEL_43;
              v19 = v15 - (_QWORD)*a2;
              v20 = v19 >> 2;
              if (v19 >> 2 <= (unint64_t)(v18 + 1))
                v20 = v18 + 1;
              if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
                v21 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v21 = v20;
              if (v21)
                v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(a2 + 2), v21);
              else
                v22 = 0;
              v23 = (OFDTextObject **)&v22[8 * v18];
              *v23 = v14;
              v17 = v23 + 1;
              v25 = (char *)*a2;
              v24 = (char *)a2[1];
              if (v24 != *a2)
              {
                do
                {
                  v26 = (OFDTextObject *)*((_QWORD *)v24 - 1);
                  v24 -= 8;
                  *--v23 = v26;
                }
                while (v24 != v25);
                v24 = (char *)*a2;
              }
              *a2 = v23;
              a2[1] = v17;
              a2[2] = &v22[8 * v21];
              if (v24)
                operator delete(v24);
            }
            else
            {
              *v16 = v13;
              v17 = v16 + 1;
            }
            a2[1] = v17;
          }
        }
      }
    }
  }
}

OFDTextObject *OFDCreateObject(const __CFDictionary *a1)
{
  CFTypeID TypeID;
  OFDTextObject *v3;

  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a1))
    return 0;
  if (CFDictionaryContainsKey(a1, CFSTR("TextCode")))
  {
    v3 = (OFDTextObject *)operator new();
    OFDTextObject::OFDTextObject(v3, a1);
  }
  else if (CFDictionaryContainsKey(a1, CFSTR("ResourceID")))
  {
    v3 = (OFDTextObject *)operator new();
    OFDImageObject::OFDImageObject(v3, a1);
  }
  else if (CFDictionaryContainsKey(a1, CFSTR("PageRef")))
  {
    v3 = (OFDTextObject *)operator new();
    OFDSignatureObject::OFDSignatureObject(v3, a1);
  }
  else
  {
    v3 = (OFDTextObject *)operator new();
    OFDPathObject::OFDPathObject(v3, a1);
  }
  return v3;
}

void sub_1881D3AC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40473883AELL);
  _Unwind_Resume(a1);
}

uint64_t OFDCopyResourcePathFromDictionary(IIODictionary *a1, uint64_t a2, const __CFString *a3)
{
  __CFArray *ArrayObjectForPath;
  uint64_t v5;
  _QWORD v7[6];
  _QWORD v8[3];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  if (a1)
  {
    ArrayObjectForPath = IIODictionary::getArrayObjectForPath(a1, "Res.MultiMedias.MultiMedia");
    if (ArrayObjectForPath)
    {
      memset(v8, 0, sizeof(v8));
      IIOArray::IIOArray((IIOArray *)v8, ArrayObjectForPath);
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 0x40000000;
      v7[2] = ___Z33OFDCopyResourcePathFromDictionaryP13IIODictionaryyPK10__CFString_block_invoke;
      v7[3] = &unk_1E1BCCF60;
      v7[4] = &v9;
      v7[5] = a2;
      IIOArray::enumerate((uint64_t)v8, (uint64_t)v7);
      IIOArray::~IIOArray((IIOArray *)v8);
    }
  }
  v5 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v5;
}

void sub_1881D3BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  IIOArray::~IIOArray((IIOArray *)va);
  _Block_object_dispose((const void *)(v8 - 48), 8);
  _Unwind_Resume(a1);
}

void ___Z33OFDCopyResourcePathFromDictionaryP13IIODictionaryyPK10__CFString_block_invoke(uint64_t a1, CFTypeRef cf, uint64_t a3, _BYTE *a4)
{
  CFTypeID v7;
  const void *v8;
  _QWORD v9[3];

  v7 = CFGetTypeID(cf);
  if (v7 == CFDictionaryGetTypeID())
  {
    memset(v9, 0, sizeof(v9));
    IIODictionary::IIODictionary((IIODictionary *)v9, (const __CFDictionary *)cf);
    if (IIODictionary::getUint64ForKey((IIODictionary *)v9, "ID") == *(const __CFDictionary **)(a1 + 40))
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("MediaFile"));
      v8 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v8)
      {
        CFRetain(v8);
        *a4 = 1;
      }
    }
    IIODictionary::~IIODictionary((IIODictionary *)v9);
  }
}

void sub_1881D3CE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGAffineTransformFromString(const __CFString *a1@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v3;
  __int128 v4;
  IIOString *v5;
  const char *v6;
  _QWORD v7[3];

  v3 = MEMORY[0x1E0C9BAA8];
  v4 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *a2 = *MEMORY[0x1E0C9BAA8];
  a2[1] = v4;
  a2[2] = *(_OWORD *)(v3 + 32);
  if (a1)
  {
    memset(v7, 0, sizeof(v7));
    v5 = IIOString::IIOString((IIOString *)v7, a1);
    v6 = (const char *)IIOString::utf8String(v5);
    sscanf(v6, "%lf %lf %lf %lf %lf %lf", a2, (char *)a2 + 8, a2 + 1, (char *)a2 + 24, a2 + 2, (char *)a2 + 40);
    IIOString::~IIOString((IIOString *)v7);
  }
}

void sub_1881D3D80(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIOString::~IIOString((IIOString *)(v1 - 40));
  _Unwind_Resume(a1);
}

double CGRectFromString(const char *a1)
{
  __int128 v2;
  __int128 v3;

  v2 = 0u;
  v3 = 0u;
  sscanf(a1, "%lf %lf %lf %lf", &v2, (char *)&v2 + 8, &v3, (char *)&v3 + 8);
  return *(double *)&v2;
}

double CGRectFromCFString(const __CFString *a1)
{
  const char *v1;
  double v2;
  _QWORD v4[3];

  if (!a1)
    return *MEMORY[0x1E0C9D648];
  memset(v4, 0, sizeof(v4));
  IIOString::IIOString((IIOString *)v4, a1);
  if (IIOString::length((IIOString *)v4))
  {
    v1 = (const char *)IIOString::utf8String((IIOString *)v4);
    v2 = CGRectFromString(v1);
  }
  else
  {
    v2 = *MEMORY[0x1E0C9D628];
  }
  IIOString::~IIOString((IIOString *)v4);
  return v2;
}

void sub_1881D3E90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void OFDParseTextDelta(void *a1, uint64_t *a2)
{
  IIOString *v3;
  char *v4;
  _QWORD *v5;
  std::string *p_p;
  int v7;
  std::string *v8;
  __int128 v9;
  unint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  std::string __p;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  void *v20[2];
  __int128 v21;
  __int128 v22;
  _BYTE v23[144];
  uint64_t v24;
  _QWORD v25[3];

  memset(v25, 0, sizeof(v25));
  v3 = IIOString::IIOString((IIOString *)v25, a1);
  v24 = 0;
  v22 = 0u;
  memset(v23, 0, sizeof(v23));
  *(_OWORD *)v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  v4 = (char *)IIOString::utf8String(v3);
  std::string::basic_string[abi:ne180100]<0>(&__p, v4);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](&v15, &__p, 24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  memset(&__p, 0, sizeof(__p));
  while (1)
  {
    v5 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v15, (uint64_t)&__p, 0x20u);
    if ((*((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 32) & 5) != 0)
      break;
    if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      if (*__p.__r_.__value_.__l.__data_ == 103)
        goto LABEL_10;
      if (__p.__r_.__value_.__l.__size_)
      {
LABEL_24:
        v10 = a2[1];
        if (v10 >= a2[2])
        {
          v12 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (__int128 *)&__p);
        }
        else
        {
          if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
          {
            std::string::__init_copy_ctor_external((std::string *)a2[1], __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
          else
          {
            v11 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *(_QWORD *)(v10 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
            *(_OWORD *)v10 = v11;
          }
          v12 = v10 + 24;
          a2[1] = v10 + 24;
        }
        a2[1] = v12;
      }
    }
    else if (__p.__r_.__value_.__s.__data_[0] == 103)
    {
LABEL_10:
      std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v15, (uint64_t)&__p, 0x20u);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      v7 = atoi((const char *)p_p);
      std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v15, (uint64_t)&__p, 0x20u);
      if (v7 >= 1)
      {
        v8 = (std::string *)a2[1];
        do
        {
          if ((unint64_t)v8 >= a2[2])
          {
            v8 = (std::string *)std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (__int128 *)&__p);
          }
          else
          {
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              std::string::__init_copy_ctor_external(v8, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
            }
            else
            {
              v9 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
              v8->__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[2];
              *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
            }
            a2[1] = (uint64_t)++v8;
          }
          a2[1] = (uint64_t)v8;
          --v7;
        }
        while (v7);
      }
    }
    else if (*((_BYTE *)&__p.__r_.__value_.__s + 23))
    {
      goto LABEL_24;
    }
  }
  if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)&v15 = *MEMORY[0x1E0DE4F50];
  v13 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&v15 + *(_QWORD *)(v15 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&v16 = v13;
  *((_QWORD *)&v16 + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v21) < 0)
    operator delete(v20[1]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x18D761BE8](v23);
  IIOString::~IIOString((IIOString *)v25);
}

void sub_1881D4124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  uint64_t v16;

  if (a15 < 0)
    operator delete(__p);
  IIOString::~IIOString((IIOString *)(v16 - 72));
  _Unwind_Resume(a1);
}

_QWORD *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](_QWORD *a1, const std::string *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  std::ios_base *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v5 = MEMORY[0x1E0DE4FD0];
  v6 = MEMORY[0x1E0DE4FD0] + 104;
  a1[16] = MEMORY[0x1E0DE4FD0] + 104;
  a1[2] = v5 + 64;
  v7 = a1 + 2;
  v8 = (uint64_t)(a1 + 3);
  v9 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v10 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  *a1 = v10;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v10 - 24)) = v11;
  a1[1] = 0;
  v12 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v12, a1 + 3);
  v12[1].__vftable = 0;
  v12[1].__fmtflags_ = -1;
  v13 = v9[4];
  v14 = v9[5];
  a1[2] = v13;
  *(_QWORD *)((char *)v7 + *(_QWORD *)(v13 - 24)) = v14;
  v15 = v9[1];
  *a1 = v15;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v15 - 24)) = v9[6];
  *a1 = v5 + 24;
  a1[16] = v6;
  a1[2] = v5 + 64;
  std::stringbuf::basic_stringbuf[abi:ne180100](v8, a2, a3);
  return a1;
}

void sub_1881D4280(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x18D761BE8](v1);
  _Unwind_Resume(a1);
}

_QWORD *std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v6;
  _QWORD *v7;
  _BYTE *v8;
  int v9;
  char v11;

  v11 = 0;
  MEMORY[0x18D761A98](&v11, a1, 1);
  if (!v11)
    return a1;
  if (*(char *)(a2 + 23) < 0)
  {
    **(_BYTE **)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 23) = 0;
  }
  v6 = 0;
  while (1)
  {
    v7 = *(_QWORD **)((char *)a1 + *(_QWORD *)(*a1 - 24) + 40);
    v8 = (_BYTE *)v7[3];
    if (v8 != (_BYTE *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(_QWORD *))(*v7 + 80))(v7);
    if ((_DWORD)v7 == -1)
      break;
LABEL_9:
    if (v7 == a3)
    {
      v9 = 0;
      goto LABEL_17;
    }
    std::string::push_back((std::string *)a2, (std::string::value_type)v7);
    --v6;
    if (*(char *)(a2 + 23) < 0 && *(_QWORD *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6)
    v9 = 2;
  else
    v9 = 6;
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_1881D43D8(void *a1)
{
  _QWORD *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  v2 = *v1;
  *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24) + 32) |= 1u;
  if ((*((_BYTE *)v1 + *(_QWORD *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1881D43A4);
  }
  __cxa_rethrow();
}

void sub_1881D441C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = MEMORY[0x1E0DE4F50];
  v3 = *MEMORY[0x1E0DE4F50];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F50];
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_QWORD *)(a1 + 16) = v4;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x18D761BE8](a1 + 128);
  return a1;
}

void OFDParsePathOperations(void *a1, uint64_t *a2)
{
  IIOString *v3;
  char *v4;
  _QWORD *v5;
  std::string::size_type size;
  unint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  std::string __p;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  void *v17[2];
  __int128 v18;
  __int128 v19;
  _BYTE v20[144];
  uint64_t v21;
  _QWORD v22[3];

  memset(v22, 0, sizeof(v22));
  v3 = IIOString::IIOString((IIOString *)v22, a1);
  v21 = 0;
  v19 = 0u;
  memset(v20, 0, sizeof(v20));
  *(_OWORD *)v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  v4 = (char *)IIOString::utf8String(v3);
  std::string::basic_string[abi:ne180100]<0>(&__p, v4);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](&v12, &__p, 24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  memset(&__p, 0, sizeof(__p));
  while (1)
  {
    v5 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v12, (uint64_t)&__p, 0x20u);
    if ((*((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 32) & 5) != 0)
      break;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    if (size)
    {
      v7 = a2[1];
      if (v7 >= a2[2])
      {
        v9 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2, (__int128 *)&__p);
      }
      else
      {
        if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
        {
          std::string::__init_copy_ctor_external((std::string *)a2[1], __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }
        else
        {
          v8 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(_QWORD *)(v7 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)v7 = v8;
        }
        v9 = v7 + 24;
        a2[1] = v7 + 24;
      }
      a2[1] = v9;
    }
  }
  if ((*((_BYTE *)&__p.__r_.__value_.__s + 23) & 0x80) != 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)&v12 = *MEMORY[0x1E0DE4F50];
  v10 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&v12 + *(_QWORD *)(v12 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&v13 = v10;
  *((_QWORD *)&v13 + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v18) < 0)
    operator delete(v17[1]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x18D761BE8](v20);
  IIOString::~IIOString((IIOString *)v22);
}

void sub_1881D4668(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  uint64_t v16;

  if (a15 < 0)
    operator delete(__p);
  IIOString::~IIOString((IIOString *)(v16 - 56));
  _Unwind_Resume(a1);
}

void OFDParseColor(__CFDictionary *a1, _DWORD *a2)
{
  const __CFDictionary *ObjectForKey;
  const __CFString *v4;
  uint64_t i;
  int8x8_t v6;
  char *v7;
  unint64_t v8;
  unsigned int v9;
  const __CFDictionary *v11;
  const char *v12;
  _QWORD v13[3];
  char buffer[16];
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  memset(v13, 0, sizeof(v13));
  IIODictionary::IIODictionary((IIODictionary *)v13, a1);
  ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v13, CFSTR("ColorSpace"));
  if (ObjectForKey)
  {
    memset(buffer, 0, sizeof(buffer));
    *(_QWORD *)&v15 = 0;
    IIOString::IIOString((IIOString *)buffer, ObjectForKey);
    IIOString::utf8String((IIOString *)buffer);
    *a2 = 1;
    IIOString::~IIOString((IIOString *)buffer);
  }
  else
  {
    *a2 = 1;
  }
  v4 = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v13, CFSTR("Value"));
  if (!v4)
    goto LABEL_29;
  *(_OWORD *)buffer = 0u;
  v15 = 0u;
  CFStringGetCString(v4, buffer, 32, 0x8000100u);
  for (i = 0; i != 32; i += 8)
  {
    v6 = vceqz_s8(*(int8x8_t *)&buffer[i]);
    if ((v6.i8[0] & 1) != 0)
      buffer[i] = 32;
    if ((v6.i8[1] & 1) != 0)
      buffer[i + 1] = 32;
    if ((v6.i8[2] & 1) != 0)
      buffer[i + 2] = 32;
    if ((v6.i8[3] & 1) != 0)
      buffer[i + 3] = 32;
    if ((v6.i8[4] & 1) != 0)
      buffer[i + 4] = 32;
    if ((v6.i8[5] & 1) != 0)
      buffer[i + 5] = 32;
    if ((v6.i8[6] & 1) != 0)
      buffer[i + 6] = 32;
    if ((v6.i8[7] & 1) != 0)
      buffer[i + 7] = 32;
  }
  HIBYTE(v15) = 0;
  v7 = strtok(buffer, " ,");
  if (v7)
  {
    v8 = 0;
    do
    {
      v9 = v8 + 1;
      *(double *)&a2[2 * v8 + 2] = atof(v7) / 255.0;
      v7 = strtok(0, " ,");
      if (!v7)
        break;
    }
    while (v8++ < 3);
  }
  else
  {
LABEL_29:
    v9 = 0;
  }
  v11 = IIODictionary::getObjectForKey((IIODictionary *)v13, CFSTR("Alpha"));
  if (v11)
  {
    memset(buffer, 0, sizeof(buffer));
    *(_QWORD *)&v15 = 0;
    IIOString::IIOString((IIOString *)buffer, v11);
    if (v9 <= 3)
    {
      v12 = (const char *)IIOString::utf8String((IIOString *)buffer);
      *(double *)&a2[2 * v9 + 2] = atof(v12) / 255.0;
    }
    IIOString::~IIOString((IIOString *)buffer);
  }
  else if (v9 <= 3)
  {
    *(_QWORD *)&a2[2 * v9 + 2] = 0x3FF0000000000000;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v13);
}

void sub_1881D4934(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  IIOString::~IIOString((IIOString *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGColorRef OFDCreateCGColor(uint64_t a1)
{
  CGColorSpace *v2;
  CGColorRef v3;

  if (*(_DWORD *)a1 != 1)
    return 0;
  v2 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  v3 = CGColorCreate(v2, (const CGFloat *)(a1 + 8));
  if (v2)
    CGColorSpaceRelease(v2);
  return v3;
}

uint64_t std::stringbuf::basic_stringbuf[abi:ne180100](uint64_t a1, const std::string *a2, int a3)
{
  uint64_t v6;

  v6 = std::streambuf::basic_streambuf();
  *(_QWORD *)v6 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_DWORD *)(v6 + 96) = a3;
  std::string::operator=((std::string *)(v6 + 64), a2);
  std::stringbuf::__init_buf_ptrs[abi:ne180100](a1);
  return a1;
}

void sub_1881D4A40(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 87) < 0)
    operator delete(*v2);
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void std::stringbuf::__init_buf_ptrs[abi:ne180100](uint64_t a1)
{
  std::string *v2;
  char v3;
  std::string *v4;
  unint64_t v5;
  int v6;
  std::string::size_type v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  *(_QWORD *)(a1 + 88) = 0;
  v2 = (std::string *)(a1 + 64);
  v3 = *(_BYTE *)(a1 + 87);
  if (v3 < 0)
  {
    v4 = *(std::string **)(a1 + 64);
    v5 = *(_QWORD *)(a1 + 72);
  }
  else
  {
    v4 = v2;
    v5 = *(unsigned __int8 *)(a1 + 87);
  }
  v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
    *(_QWORD *)(a1 + 88) = (char *)v4 + v5;
    *(_QWORD *)(a1 + 16) = v4;
    *(_QWORD *)(a1 + 24) = v4;
    *(_QWORD *)(a1 + 32) = (char *)v4 + v5;
  }
  if ((v6 & 0x10) != 0)
  {
    *(_QWORD *)(a1 + 88) = (char *)v4 + v5;
    v7 = v3 < 0 ? (*(_QWORD *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize(v2, v7, 0);
    v8 = *(char *)(a1 + 87) < 0 ? *(_QWORD *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(_QWORD *)(a1 + 40) = v4;
    *(_QWORD *)(a1 + 48) = v4;
    *(_QWORD *)(a1 + 56) = (char *)v4 + v8;
    if ((*(_BYTE *)(a1 + 96) & 3) != 0)
    {
      if (v5 >> 31)
      {
        v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
        v5 = v5 - v10 - 0x7FFFFFFF;
        *(_QWORD *)(a1 + 48) = v4;
      }
      if (v5)
        *(_QWORD *)(a1 + 48) = (char *)v4 + v5;
    }
  }
}

void OFDContainer::OFDContainer(OFDContainer *this, const char *a2)
{
  IIODictionary *v4;
  FILE *v5;
  FILE *v6;

  *(_QWORD *)this = &off_1E1BAC2B0;
  *((_QWORD *)this + 3) = 0;
  v4 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v4);
  *((_QWORD *)this + 2) = v4;
  *((_QWORD *)this + 5) = 0;
  v5 = fopen(a2, "rb");
  if (v5)
  {
    v6 = v5;
    fseek(v5, 0, 2);
    *((_QWORD *)this + 5) = ftello(v6);
    fclose(v6);
  }
  *((_QWORD *)this + 4) = unzOpen((uint64_t)a2);
  *((_QWORD *)this + 1) = 0;
  OFDContainer::initializeFiles(this);
  OFDContainer::initializeAttributes(this);
  OFDContainer::initializeRootDocument(this);
}

void sub_1881D4C38(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void OFDContainer::OFDContainer(OFDContainer *this, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v5;
  IIODictionary *v6;

  *(_QWORD *)this = &off_1E1BAC2B0;
  *((_QWORD *)this + 3) = 0;
  v5 = a3;
  *((_QWORD *)this + 5) = a3;
  v6 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v6);
  *((_QWORD *)this + 2) = v6;
  *((_QWORD *)this + 4) = unzOpenBuffer((uint64_t)a2, v5);
  *((_QWORD *)this + 1) = 0;
  OFDContainer::initializeFiles(this);
  OFDContainer::initializeAttributes(this);
  OFDContainer::initializeRootDocument(this);
}

void sub_1881D4CF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void OFDContainer::~OFDContainer(OFDContainer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E1BAC2B0;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    unzCloseCurrentFile(v2);
  v3 = *((_QWORD *)this + 1);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 2);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

{
  OFDContainer::~OFDContainer(this);
  JUMPOUT(0x18D761C30);
}

BOOL OFDContainer::initializeFiles(OFDContainer *this)
{
  BOOL v2;
  const __CFAllocator *v4;
  unsigned int v5;
  CFStringRef v6;
  uint64_t v7;
  unint64_t v8;
  _BYTE v9[24];
  _OWORD v10[3];
  unsigned int v11[4];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  _OWORD cStr[15];
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v17 = 0uLL;
  if (unzGetGlobalInfo(*((_QWORD *)this + 4), &v17))
    v2 = 1;
  else
    v2 = (_QWORD)v17 == 0;
  if (!v2)
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v5 = 1;
    do
    {
      v19 = 0u;
      memset(cStr, 0, sizeof(cStr));
      v16 = 0;
      v15 = 0u;
      v13 = 0u;
      v14 = 0u;
      *(_OWORD *)v11 = 0u;
      v12 = 0u;
      memset(v10, 0, sizeof(v10));
      if (unzGetCurrentFileInfo64(*((_QWORD *)this + 4), (uint64_t)v10, (uint64_t)cStr, 0x100uLL, 0, 0, 0, 0)|| *(_QWORD *)&v11[2] > 0xFFFFFFFEuLL)
      {
        break;
      }
      HIBYTE(v19) = 0;
      v6 = CFStringCreateWithCString(v4, (const char *)cStr, 0x8000100u);
      if (v6)
      {
        v7 = *((_QWORD *)this + 2);
        IIONumber::IIONumber((IIONumber *)v9, v11[2]);
        IIODictionary::setObjectForKey(v7, (uint64_t)v9, v6);
        IIONumber::~IIONumber((IIONumber *)v9);
        CFRelease(v6);
      }
      if ((_QWORD)v17 == v5)
        break;
      if (unzGoToNextFile(*((_QWORD **)this + 4)))
        break;
      v8 = v5++;
    }
    while ((unint64_t)v17 > v8);
  }
  return IIODictionary::getCount(*((IIODictionary **)this + 2)) != 0;
}

void sub_1881D4F48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

BOOL OFDContainer::initializeAttributes(OFDContainer *this)
{
  const __CFData *v2;
  const __CFData *v3;

  v2 = OFDContainer::copyFileContent(this, "OFD.xml");
  v3 = v2;
  if (v2)
  {
    *((_QWORD *)this + 1) = XMLDictionaryCreateWithData(v2);
    CFRelease(v3);
  }
  return v3 != 0;
}

uint64_t OFDContainer::initializeRootDocument(OFDContainer *this)
{
  uint64_t result;
  __CFArray *ArrayObjectForPath;
  const void *v4;
  OFDDocument *v5;
  const char *v6;
  _BYTE v7[24];

  result = *((_QWORD *)this + 1);
  if (result)
  {
    ArrayObjectForPath = IIODictionary::getArrayObjectForPath((IIODictionary *)result, CFSTR("OFD.DocBody.DocRoot"));
    result = (uint64_t)CFArrayGetValueAtIndex(ArrayObjectForPath, 0);
    if (result)
    {
      v4 = (const void *)result;
      v5 = (OFDDocument *)operator new();
      IIOString::IIOString((IIOString *)v7, v4);
      v6 = (const char *)IIOString::utf8String((IIOString *)v7);
      OFDDocument::OFDDocument(v5, this, v6);
      *((_QWORD *)this + 3) = v5;
      IIOString::~IIOString((IIOString *)v7);
      OFDDocument::open(*((OFDDocument **)this + 3));
      return 1;
    }
  }
  return result;
}

void sub_1881D5058(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C400AA5E179);
  _Unwind_Resume(a1);
}

CFDataRef OFDContainer::copyFileContent(OFDContainer *this, const char *a2)
{
  int v4;
  char *v5;
  CFDataRef v6;
  CFIndex v7;
  UInt8 *v8;
  UInt8 *v9;
  _OWORD v11[3];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  _OWORD v18[16];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned __int8 *)a2;
  if (unzGoToFirstFile(*((_QWORD **)this + 4)))
    return 0;
  v5 = (char *)(v4 == 47 ? a2 + 1 : a2);
  if (unzLocateFile(*((_QWORD *)this + 4), v5, 0))
    return 0;
  memset(v18, 0, sizeof(v18));
  memset(v11, 0, sizeof(v11));
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0;
  if (unzGetCurrentFileInfo64(*((_QWORD *)this + 4), (uint64_t)v11, (uint64_t)v18, 0x100uLL, 0, 0, 0, 0))return 0;
  v7 = *((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1) > 0xFFFFFFFEuLL)
    return 0;
  v8 = (UInt8 *)malloc_type_calloc(*((_QWORD *)&v12 + 1) + 1, 1uLL, 0x19EA9DD4uLL);
  if (!v8)
    return 0;
  v9 = v8;
  if (unzOpenCurrentFile(*((_QWORD *)this + 4))
    || unzReadCurrentFile(*((_QWORD *)this + 4), (uint64_t)v9, v7) != (_DWORD)v7)
  {
    v6 = 0;
  }
  else
  {
    v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, v7);
  }
  free(v9);
  return v6;
}

void OFDTemplate::OFDTemplate(OFDTemplate *this, OFDDocument *a2, char *__s, int a4)
{
  char *v6;
  _OWORD *v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  *(_QWORD *)this = &off_1E1BABED0;
  *((_QWORD *)this + 3) = 0;
  v6 = (char *)this + 24;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 2) = a2;
  std::string::basic_string[abi:ne180100]<0>(&v9, __s);
  if (*((char *)this + 47) < 0)
    operator delete(*(void **)v6);
  *(_OWORD *)v6 = v9;
  *((_QWORD *)v6 + 2) = v10;
  *((_DWORD *)this + 2) = a4;
  *((_BYTE *)this + 56) = 0;
  v7 = (_OWORD *)MEMORY[0x1E0C9D648];
  *((_QWORD *)this + 6) = 0;
  v8 = v7[1];
  *(_OWORD *)((char *)this + 88) = *v7;
  *(_OWORD *)((char *)this + 104) = v8;
}

void sub_1881D52A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 72) = v5;
    operator delete(v5);
  }
  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void OFDTemplate::~OFDTemplate(OFDTemplate *this)
{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = &off_1E1BABED0;
  v2 = *((_QWORD *)this + 6);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 8);
  if (v3)
  {
    *((_QWORD *)this + 9) = v3;
    operator delete(v3);
  }
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
}

{
  OFDTemplate::~OFDTemplate(this);
  JUMPOUT(0x18D761C30);
}

uint64_t OFDTemplate::open(OFDTemplate *this)
{
  OFDContainer **v2;
  const char *v3;
  const __CFData *v4;
  const __CFData *v5;

  if (!*((_BYTE *)this + 56))
  {
    v2 = (OFDContainer **)*((_QWORD *)this + 2);
    v3 = (char *)this + 24;
    if (*((char *)this + 47) < 0)
      v3 = *(const char **)v3;
    v4 = OFDDocument::copyFileContent(v2, v3);
    if (v4)
    {
      v5 = v4;
      *((_BYTE *)this + 56) = OFDTemplate::parseXML(this, v4);
      CFRelease(v5);
    }
  }
  return *((unsigned __int8 *)this + 56);
}

BOOL OFDTemplate::parseXML(OFDTemplate *this, const __CFData *a2)
{
  IIODictionary *v3;
  IIODictionary *v4;
  __CFArray *ArrayObjectForPath;
  const __CFString *ValueAtIndex;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFArray *v10;
  __CFArray *v11;

  v3 = XMLDictionaryCreateWithData(a2);
  v4 = v3;
  *((_QWORD *)this + 6) = v3;
  if (v3)
  {
    ArrayObjectForPath = IIODictionary::getArrayObjectForPath(v3, CFSTR("Page.Area.PhysicalBox"));
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayObjectForPath, 0);
    *((double *)this + 11) = CGRectFromCFString(ValueAtIndex);
    *((_QWORD *)this + 12) = v7;
    *((_QWORD *)this + 13) = v8;
    *((_QWORD *)this + 14) = v9;
    v10 = IIODictionary::getArrayObjectForPath(*((IIODictionary **)this + 6), CFSTR("Page.Content.Layer.TextObject"));
    OFDExtractOFDObjectsFromCFArray(v10, (void **)this + 8);
    v11 = IIODictionary::getArrayObjectForPath(*((IIODictionary **)this + 6), CFSTR("Page.Content.Layer.PathObject"));
    OFDExtractOFDObjectsFromCFArray(v11, (void **)this + 8);
  }
  else
  {
    _cg_jpeg_mem_term("parseXML", 110, "*** ERROR: XMLDictionaryCreateWithData failed\n");
  }
  return v4 != 0;
}

void OFDTemplate::drawTemplateInContext(uint64_t a1, CGContext *a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  CGFloat **v7;
  CGFloat *v15;
  CGFloat *v16;

  v7 = *(CGFloat ***)(a1 + 64);
  while (v7 != *(CGFloat ***)(a1 + 72))
  {
    v16 = *v7++;
    v15 = v16;
    (*(void (**)(CGFloat *))(*(_QWORD *)v16 + 24))(v16);
    CGContextSaveGState(a2);
    CGContextTranslateCTM(a2, v15[9], v15[10]);
    (*(void (**)(CGFloat *, CGContext *, uint64_t, double, double, double, double))(*(_QWORD *)v15 + 16))(v15, a2, a3, a4, a5, a6, a7);
    CGContextRestoreGState(a2);
  }
}

void OFDSignatureObject::OFDSignatureObject(OFDSignatureObject *this, const __CFDictionary *a2)
{
  _QWORD v3[3];

  *(_QWORD *)OFDObject::OFDObject((uint64_t)this, a2, 4) = &off_1E1BB1850;
  memset(v3, 0, sizeof(v3));
  IIODictionary::IIODictionary((IIODictionary *)v3, a2);
  IIODictionary::~IIODictionary((IIODictionary *)v3);
}

void sub_1881D558C(_Unwind_Exception *a1, uint64_t a2, const char *a3)
{
  uint64_t v3;

  _cg_jpeg_mem_term(v3, a2, a3);
  _Unwind_Resume(a1);
}

void OFDSignatureObject::~OFDSignatureObject(OFDSignatureObject *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void OFDSignatureObject::drawInContext(OFDSignatureObject *this, CGContext *a2, CGRect a3, OFDContainer ***a4)
{
  const __CFArray *v7;
  OFDContainer **v8;
  const char *v9;
  const __CFData *v10;
  const __CFData *v11;
  unsigned __int8 *BytePtr;
  unsigned int Length;
  const __CFData *v14;
  const __CFData *v15;
  std::string *p_p;
  int data_low;
  int v18;
  __int128 v20;
  CGImageSource *v21;
  CGImageSource *v22;
  CGImage *ImageAtIndex;
  CGFloat v24;
  double v25;
  CGFloat v26;
  double v27;
  unsigned __int8 *v28;
  unsigned int v29;
  OFDDocument *v30;
  OFDPage *PageAtIndex;
  OFDPage *v32;
  CGFloat v33;
  CGFloat v34;
  CGFloat v35;
  CGFloat v36;
  uint64_t v37;
  const char *v38;
  CGAffineTransform v39;
  _OWORD v40[3];
  std::string __p;
  _QWORD v42[3];
  _QWORD v43[3];
  CGRect v44;
  CGRect v45;

  v7 = OFDPage::copySignatureFilePath((OFDPage *)a4);
  memset(v43, 0, sizeof(v43));
  IIOString::IIOString((IIOString *)v43, v7);
  if (v7)
    CFRelease(v7);
  v8 = a4[2];
  v9 = (const char *)IIOString::utf8String((IIOString *)v43);
  v10 = OFDDocument::copyFileContent(v8, v9);
  v11 = v10;
  if (v10)
  {
    BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v10);
    Length = CFDataGetLength(v11);
    memset(v42, 0, sizeof(v42));
    ASN1Parser::ASN1Parser((ASN1Parser *)v42);
    ASN1Parser::parseASN1((ASN1Parser *)v42, BytePtr, Length);
    memset(&__p, 0, sizeof(__p));
    v14 = ASN1Parser::copyImageData((uint64_t)v42, &__p);
    v15 = v14;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      if (__p.__r_.__value_.__l.__size_ != 3)
        goto LABEL_13;
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    else
    {
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 3)
        goto LABEL_13;
      p_p = &__p;
    }
    data_low = LOWORD(p_p->__r_.__value_.__l.__data_);
    v18 = p_p->__r_.__value_.__s.__data_[2];
    if (data_low == 26223 && v18 == 100)
    {
      v28 = (unsigned __int8 *)CFDataGetBytePtr(v14);
      v29 = CFDataGetLength(v15);
      memset(v40, 0, sizeof(v40));
      OFDContainer::OFDContainer((OFDContainer *)v40, v28, v29);
      v30 = (OFDDocument *)IIOImageSource::count((IIOImageSource *)v40);
      if (v30)
      {
        PageAtIndex = OFDDocument::getPageAtIndex(v30, 0);
        v32 = PageAtIndex;
        if (PageAtIndex)
        {
          OFDPage::open(PageAtIndex);
          v33 = *((double *)this + 11);
          v34 = *((double *)this + 12);
          v35 = *MEMORY[0x1E0C9D538];
          v36 = *(double *)(MEMORY[0x1E0C9D538] + 8);
          CGContextTranslateCTM(a2, *MEMORY[0x1E0C9D538], v36);
          v45.origin.x = v35;
          v45.origin.y = v36;
          v45.size.width = v33;
          v45.size.height = v34;
          OFDPage::drawInContext(v32, a2, v45);
          _cg_jpeg_mem_term(v32, v37, v38);
        }
      }
      OFDContainer::~OFDContainer((OFDContainer *)v40);
      goto LABEL_23;
    }
LABEL_13:
    if (v14)
    {
      CGContextSaveGState(a2);
      v20 = *(_OWORD *)((char *)this + 40);
      *(_OWORD *)&v39.a = *(_OWORD *)((char *)this + 24);
      *(_OWORD *)&v39.c = v20;
      *(_OWORD *)&v39.tx = *(_OWORD *)((char *)this + 56);
      CGContextConcatCTM(a2, &v39);
      v21 = CGImageSourceCreateWithData(v15, 0);
      v22 = v21;
      if (v21)
      {
        ImageAtIndex = CGImageSourceCreateImageAtIndex(v21, 0, 0);
        if (ImageAtIndex)
        {
          v24 = *((double *)this + 11);
          v25 = *((double *)this + 12);
          v26 = *MEMORY[0x1E0C9D538];
          v27 = *(double *)(MEMORY[0x1E0C9D538] + 8);
          CGContextTranslateCTM(a2, *MEMORY[0x1E0C9D538], v25 + v27);
          CGContextScaleCTM(a2, 1.0, -1.0);
          CGContextSetInterpolationQuality(a2, kCGInterpolationNone);
          v44.origin.x = v26;
          v44.origin.y = v27;
          v44.size.width = v24;
          v44.size.height = v25;
          CGContextDrawImage(a2, v44, ImageAtIndex);
          CGImageRelease(ImageAtIndex);
        }
        CFRelease(v22);
      }
      CFRelease(v15);
      CGContextRestoreGState(a2);
    }
LABEL_23:
    CFRelease(v11);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    ASN1Parser::~ASN1Parser((ASN1Parser *)v42);
  }
  IIOString::~IIOString((IIOString *)v43);
}

void sub_1881D58A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  uint64_t v28;

  OFDContainer::~OFDContainer((OFDContainer *)&a15);
  if (a27 < 0)
    operator delete(__p);
  ASN1Parser::~ASN1Parser((ASN1Parser *)&a28);
  IIOString::~IIOString((IIOString *)(v28 - 120));
  _Unwind_Resume(a1);
}

uint64_t OFDObject::OFDObject(uint64_t a1, const __CFDictionary *a2, char a3)
{
  IIODictionary *v4;
  const __CFString *ObjectForKey;
  __int128 v6;
  const __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  __CFDictionary *v12;
  __CFDictionary *v13;
  _OWORD v15[3];
  _QWORD v16[3];

  *(_QWORD *)a1 = &off_1E1BB2FA0;
  *(_BYTE *)(a1 + 8) = a3;
  memset(v16, 0, sizeof(v16));
  v4 = IIODictionary::IIODictionary((IIODictionary *)v16, a2);
  if (IIODictionary::getCount(v4))
  {
    ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v16, CFSTR("CTM"));
    CGAffineTransformFromString(ObjectForKey, v15);
    v6 = v15[1];
    *(_OWORD *)(a1 + 24) = v15[0];
    *(_OWORD *)(a1 + 40) = v6;
    *(_OWORD *)(a1 + 56) = v15[2];
    v7 = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v16, CFSTR("Boundary"));
    *(double *)(a1 + 72) = CGRectFromCFString(v7);
    *(_QWORD *)(a1 + 80) = v8;
    *(_QWORD *)(a1 + 88) = v9;
    *(_QWORD *)(a1 + 96) = v10;
    *(_QWORD *)(a1 + 16) = IIODictionary::getUint64ForKey((IIODictionary *)v16, CFSTR("ID"));
    *(_BYTE *)(a1 + 105) = IIODictionary::getBoolForKey((IIODictionary *)v16, "Fill");
    v11 = !IIODictionary::containsKey((IIODictionary *)v16, "Stroke")
       || IIODictionary::getBoolForKey((IIODictionary *)v16, "Stroke");
    *(_OWORD *)(a1 + 112) = 0u;
    *(_BYTE *)(a1 + 104) = v11;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    v12 = IIODictionary::getObjectForKey((IIODictionary *)v16, CFSTR("FillColor"));
    if (v12)
      OFDParseColor(v12, (_DWORD *)(a1 + 152));
    v13 = IIODictionary::getObjectForKey((IIODictionary *)v16, CFSTR("StrokeColor"));
    if (v13)
      OFDParseColor(v13, (_DWORD *)(a1 + 112));
  }
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  return a1;
}

void sub_1881D5A68(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 40));
  _Unwind_Resume(a1);
}

void OFDObject::~OFDObject(OFDObject *this)
{
  JUMPOUT(0x18D761C30);
}

void OFDPage::OFDPage(OFDPage *this, OFDDocument *a2, char *__s, int a4)
{
  char *v7;
  size_t v8;
  __int128 *v9;
  const void *v10;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  *(_QWORD *)this = &off_1E1BB29C0;
  *((_QWORD *)this + 3) = 0;
  v7 = (char *)this + 24;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 2) = a2;
  std::string::basic_string[abi:ne180100]<0>(&v13, __s);
  if (*((char *)this + 47) < 0)
    operator delete(*(void **)v7);
  *(_OWORD *)v7 = v13;
  *((_QWORD *)v7 + 2) = v14;
  if (!strstr(__s, ".xml"))
  {
    if (*((char *)this + 47) >= 0)
      v8 = *((unsigned __int8 *)this + 47);
    else
      v8 = *((_QWORD *)this + 4);
    v14 = 0;
    v13 = 0uLL;
    v9 = &v13;
    std::string::basic_string[abi:ne180100]((uint64_t)&v13, v8 + 12);
    if (v14 < 0)
      v9 = (__int128 *)v13;
    if (v8)
    {
      if (*((char *)this + 47) >= 0)
        v10 = v7;
      else
        v10 = (const void *)*((_QWORD *)this + 3);
      memmove(v9, v10, v8);
    }
    strcpy((char *)v9 + v8, "/Content.xml");
    if (*((char *)this + 47) < 0)
      operator delete(*(void **)v7);
    *(_OWORD *)v7 = v13;
    *((_QWORD *)v7 + 2) = v14;
  }
  *((_DWORD *)this + 2) = a4;
  *((_QWORD *)this + 8) = 0;
  v11 = (_OWORD *)MEMORY[0x1E0C9D648];
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  v12 = v11[1];
  *(_OWORD *)((char *)this + 104) = *v11;
  *(_OWORD *)((char *)this + 120) = v12;
  *((_BYTE *)this + 72) = 0;
  OFDPage::extractSignature(this);
}

void sub_1881D5C20(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 88) = v5;
    operator delete(v5);
  }
  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void OFDPage::extractSignature(OFDPage *this)
{
  uint64_t v2;
  std::string *v3;
  __int128 v4;
  void **v5;
  const __CFData *v6;
  const __CFData *v7;
  std::string __p;
  void *v9[2];
  int64_t v10;

  v2 = *((_QWORD *)this + 2);
  if (*(char *)(v2 + 63) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v2 + 40), *(_QWORD *)(v2 + 48));
  else
    __p = *(std::string *)(v2 + 40);
  v3 = std::string::append(&__p, "/Signs/Sign_0/Signature.xml");
  v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v10 = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)v9 = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v10 >= 0)
    v5 = v9;
  else
    v5 = (void **)v9[0];
  v6 = OFDDocument::copyFileContent(*((OFDContainer ***)this + 2), (const char *)v5);
  v7 = v6;
  if (v6)
  {
    *((_QWORD *)this + 8) = XMLDictionaryCreateWithData(v6);
    CFRelease(v7);
  }
  if (SHIBYTE(v10) < 0)
    operator delete(v9[0]);
}

void sub_1881D5D24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void OFDPage::~OFDPage(OFDPage *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = &off_1E1BB29C0;
  v2 = *((_QWORD *)this + 6);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 7);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 8);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = (void *)*((_QWORD *)this + 10);
  if (v5)
  {
    *((_QWORD *)this + 11) = v5;
    operator delete(v5);
  }
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
}

{
  OFDPage::~OFDPage(this);
  JUMPOUT(0x18D761C30);
}

CFDataRef OFDPage::open(OFDPage *this)
{
  CFDataRef result;
  OFDContainer **v3;
  const char *v4;
  const void *v5;

  if (*((_BYTE *)this + 72))
    return (CFDataRef)1;
  v3 = (OFDContainer **)*((_QWORD *)this + 2);
  v4 = (char *)this + 24;
  if (*((char *)this + 47) < 0)
    v4 = *(const char **)v4;
  result = OFDDocument::copyFileContent(v3, v4);
  *((_BYTE *)this + 72) = result != 0;
  if (result)
  {
    v5 = result;
    OFDPage::parseXML(this, result);
    CFRelease(v5);
    return (CFDataRef)(*((_BYTE *)this + 72) != 0);
  }
  return result;
}

BOOL OFDPage::parseXML(OFDPage *this, const __CFData *a2)
{
  IIODictionary *v3;
  IIODictionary *v4;
  __CFArray *ArrayObjectForPath;
  const __CFString *ValueAtIndex;
  double v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  IIODictionary *v12;
  __CFArray *v13;
  __CFArray *v14;
  __CFArray *v15;
  IIODictionary *v16;
  __CFArray *v17;

  v3 = XMLDictionaryCreateWithData(a2);
  v4 = v3;
  *((_QWORD *)this + 6) = v3;
  if (v3)
  {
    ArrayObjectForPath = IIODictionary::getArrayObjectForPath(v3, CFSTR("Page.Area.PhysicalBox"));
    if (ArrayObjectForPath)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayObjectForPath, 0);
      v7 = CGRectFromCFString(ValueAtIndex);
    }
    else
    {
      v11 = *((_QWORD *)this + 2);
      v7 = *(double *)(v11 + 152);
      v8 = *(_QWORD *)(v11 + 160);
      v9 = *(_QWORD *)(v11 + 168);
      v10 = *(_QWORD *)(v11 + 176);
    }
    *((double *)this + 13) = v7;
    *((_QWORD *)this + 14) = v8;
    *((_QWORD *)this + 15) = v9;
    *((_QWORD *)this + 16) = v10;
    v12 = (IIODictionary *)*((_QWORD *)this + 6);
    if (v12)
    {
      v13 = IIODictionary::getArrayObjectForPath(v12, CFSTR("Page.Content.Layer.TextObject"));
      OFDExtractOFDObjectsFromCFArray(v13, (void **)this + 10);
      v14 = IIODictionary::getArrayObjectForPath(*((IIODictionary **)this + 6), CFSTR("Page.Content.Layer.PathObject"));
      OFDExtractOFDObjectsFromCFArray(v14, (void **)this + 10);
      v15 = IIODictionary::getArrayObjectForPath(*((IIODictionary **)this + 6), CFSTR("Page.Content.Layer.ImageObject"));
      OFDExtractOFDObjectsFromCFArray(v15, (void **)this + 10);
    }
    v16 = (IIODictionary *)*((_QWORD *)this + 8);
    if (v16)
    {
      v17 = IIODictionary::getArrayObjectForPath(v16, CFSTR("Signature.SignedInfo.StampAnnot"));
      OFDExtractOFDObjectsFromCFArray(v17, (void **)this + 10);
    }
  }
  return v4 != 0;
}

double OFDPage::physicalBox(OFDPage *this)
{
  if (*((_QWORD *)this + 6))
    return *((double *)this + 13);
  else
    return 0.0;
}

CFStringRef OFDPage::copyResourcePath(OFDPage *this, unsigned int a2, const __CFString *a3)
{
  CFStringRef result;

  result = (CFStringRef)OFDCopyResourcePathFromDictionary(*((IIODictionary **)this + 7), a2, a3);
  if (!result)
    return OFDDocument::copyResourcePath(*((IIODictionary ***)this + 2), a2, a3);
  return result;
}

const __CFArray *OFDPage::copySignatureFilePath(OFDPage *this)
{
  IIODictionary *v1;
  __CFArray *ArrayObjectForPath;
  const __CFArray *v3;
  const __CFArray *ValueAtIndex;

  v1 = (IIODictionary *)*((_QWORD *)this + 8);
  if (!v1)
    return 0;
  ArrayObjectForPath = IIODictionary::getArrayObjectForPath(v1, CFSTR("Signature.SignedValue"));
  v3 = ArrayObjectForPath;
  if (!ArrayObjectForPath)
    return v3;
  if (!CFArrayGetCount(ArrayObjectForPath))
    return 0;
  ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v3, 0);
  v3 = ValueAtIndex;
  if (ValueAtIndex)
    CFRetain(ValueAtIndex);
  return v3;
}

void OFDPage::drawInContext(OFDPage *this, CGContextRef c, CGRect a3)
{
  double height;
  double width;
  double y;
  double x;
  __int128 v9;
  OFDTemplate *TemplateAtIndex;
  CGFloat **v11;
  CGFloat *v12;
  CGFloat *v13;
  CGAffineTransform v14;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  v9 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *(_OWORD *)&v14.a = *MEMORY[0x1E0C9BAA8];
  *(_OWORD *)&v14.c = v9;
  *(_OWORD *)&v14.tx = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
  CGContextSetTextMatrix(c, &v14);
  TemplateAtIndex = OFDDocument::getTemplateAtIndex(*((OFDDocument **)this + 2), *((_DWORD *)this + 2));
  if (TemplateAtIndex)
    OFDTemplate::drawTemplateInContext((uint64_t)TemplateAtIndex, c, (uint64_t)this, x, y, width, height);
  v11 = (CGFloat **)*((_QWORD *)this + 10);
  while (v11 != *((CGFloat ***)this + 11))
  {
    v13 = *v11++;
    v12 = v13;
    (*(void (**)(CGFloat *))(*(_QWORD *)v13 + 24))(v13);
    CGContextSaveGState(c);
    CGContextTranslateCTM(c, v12[9], v12[10]);
    (*(void (**)(CGFloat *, CGContextRef, OFDPage *, double, double, double, double))(*(_QWORD *)v12 + 16))(v12, c, this, x, y, width, height);
    CGContextRestoreGState(c);
  }
}

void OFDDocument::OFDDocument(OFDDocument *this, OFDContainer *a2, char *a3)
{
  std::string *v6;
  std::string *v7;
  IIODictionary *v8;
  uint64_t v9;
  std::string *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  std::string::size_type v14;
  size_t v15;
  std::string *v16;
  std::string *v17;
  __int128 v18;
  std::string v19;
  char v20;

  *((_OWORD *)this + 1) = 0u;
  v6 = (std::string *)((char *)this + 16);
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_QWORD *)this = &off_1E1BABEB0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  v7 = (std::string *)((char *)this + 40);
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  v8 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v8);
  *((_QWORD *)this + 12) = v8;
  *((_QWORD *)this + 1) = a2;
  std::string::basic_string[abi:ne180100]<0>(&v19, a3);
  if (*((char *)this + 39) < 0)
    operator delete(v6->__r_.__value_.__l.__data_);
  *v6 = v19;
  if (strchr(a3, 47))
  {
    if (*((char *)this + 39) < 0)
    {
      v10 = (std::string *)*((_QWORD *)this + 2);
      v9 = *((_QWORD *)this + 3);
      if (v9)
      {
LABEL_6:
        v11 = (char *)v10 + v9;
        v12 = v10;
        while (*v12 != 47)
        {
          ++v12;
          if (!--v9)
          {
            v12 = v11;
            break;
          }
        }
        v13 = (_BYTE *)(v12 - (_BYTE *)v10);
        if (v12 == v11)
          v14 = -1;
        else
          v14 = (std::string::size_type)v13;
        goto LABEL_28;
      }
    }
    else
    {
      v9 = *((unsigned __int8 *)this + 39);
      v10 = v6;
      if (*((_BYTE *)this + 39))
        goto LABEL_6;
    }
    v14 = -1;
LABEL_28:
    std::string::basic_string(&v19, v6, 0, v14, (std::allocator<char> *)&v20);
    if (*((char *)this + 63) < 0)
      operator delete(v7->__r_.__value_.__l.__data_);
    *v7 = v19;
    goto LABEL_31;
  }
  std::string::operator=(v7, v6);
  if (*((char *)this + 39) >= 0)
    v15 = *((unsigned __int8 *)this + 39);
  else
    v15 = *((_QWORD *)this + 3);
  memset(&v19, 0, sizeof(v19));
  v16 = &v19;
  std::string::basic_string[abi:ne180100]((uint64_t)&v19, v15 + 13);
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v16 = (std::string *)v19.__r_.__value_.__r.__words[0];
  if (v15)
  {
    if (*((char *)this + 39) >= 0)
      v17 = v6;
    else
      v17 = (std::string *)*((_QWORD *)this + 2);
    memmove(v16, v17, v15);
  }
  strcpy((char *)v16 + v15, "/Document.xml");
  if (*((char *)this + 39) < 0)
    operator delete(v6->__r_.__value_.__l.__data_);
  *v6 = v19;
LABEL_31:
  *((_DWORD *)this + 46) = 0;
  *((_BYTE *)this + 188) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  v18 = *(_OWORD *)(MEMORY[0x1E0C9D648] + 16);
  *(_OWORD *)((char *)this + 152) = *MEMORY[0x1E0C9D648];
  *(_OWORD *)((char *)this + 168) = v18;
  OFDDocument::extractResources(this);
  OFDDocument::extractSignatures(this);
}

void sub_1881D63A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;

  v6 = *(void **)(v1 + 128);
  if (v6)
  {
    *(_QWORD *)(v1 + 136) = v6;
    operator delete(v6);
  }
  v7 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 112) = v7;
    operator delete(v7);
  }
  if (*(char *)(v1 + 63) < 0)
    operator delete(*v3);
  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void OFDDocument::extractResources(OFDDocument *this)
{
  char *v2;
  size_t v3;
  void **v4;
  const void *v5;
  void **v6;
  const __CFData *v7;
  const __CFData *v8;
  size_t v9;
  void **v10;
  const void *v11;
  void **v12;
  const __CFData *v13;
  const __CFData *v14;
  void *__p[2];
  uint64_t v16;
  void *v17[2];
  uint64_t v18;

  v2 = (char *)this + 40;
  if (*((char *)this + 63) >= 0)
    v3 = *((unsigned __int8 *)this + 63);
  else
    v3 = *((_QWORD *)this + 6);
  v17[1] = 0;
  v18 = 0;
  v17[0] = 0;
  std::string::basic_string[abi:ne180100]((uint64_t)v17, v3 + 16);
  if (v18 >= 0)
    v4 = v17;
  else
    v4 = (void **)v17[0];
  if (v3)
  {
    if (*((char *)this + 63) >= 0)
      v5 = v2;
    else
      v5 = (const void *)*((_QWORD *)this + 5);
    memmove(v4, v5, v3);
  }
  strcpy((char *)v4 + v3, "/DocumentRes.xml");
  if (v18 >= 0)
    v6 = v17;
  else
    v6 = (void **)v17[0];
  v7 = OFDContainer::copyFileContent(*((OFDContainer **)this + 1), (const char *)v6);
  v8 = v7;
  if (v7)
  {
    *((_QWORD *)this + 9) = XMLDictionaryCreateWithData(v7);
    CFRelease(v8);
  }
  if (*((char *)this + 63) >= 0)
    v9 = *((unsigned __int8 *)this + 63);
  else
    v9 = *((_QWORD *)this + 6);
  __p[1] = 0;
  v16 = 0;
  __p[0] = 0;
  v10 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v9 + 14);
  if (v16 < 0)
    v10 = (void **)__p[0];
  if (v9)
  {
    if (*((char *)this + 63) >= 0)
      v11 = v2;
    else
      v11 = (const void *)*((_QWORD *)this + 5);
    memmove(v10, v11, v9);
  }
  strcpy((char *)v10 + v9, "/PublicRes.xml");
  if (v16 >= 0)
    v12 = __p;
  else
    v12 = (void **)__p[0];
  v13 = OFDContainer::copyFileContent(*((OFDContainer **)this + 1), (const char *)v12);
  v14 = v13;
  if (v13)
  {
    *((_QWORD *)this + 10) = XMLDictionaryCreateWithData(v13);
    CFRelease(v14);
  }
  OFDDocument::setupFonts(this);
  if (SHIBYTE(v16) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v18) < 0)
    operator delete(v17[0]);
}

void sub_1881D65E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void OFDDocument::extractSignatures(OFDDocument *this)
{
  size_t v2;
  void **v3;
  char *v4;
  void **v5;
  const __CFData *v6;
  const __CFData *v7;
  void *__p[2];
  uint64_t v9;

  if (*((char *)this + 63) >= 0)
    v2 = *((unsigned __int8 *)this + 63);
  else
    v2 = *((_QWORD *)this + 6);
  __p[1] = 0;
  v9 = 0;
  __p[0] = 0;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v2 + 21);
  if (v9 >= 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  if (v2)
  {
    if (*((char *)this + 63) >= 0)
      v4 = (char *)this + 40;
    else
      v4 = (char *)*((_QWORD *)this + 5);
    memmove(v3, v4, v2);
  }
  strcpy((char *)v3 + v2, "/Signs/Signatures.xml");
  if (v9 >= 0)
    v5 = __p;
  else
    v5 = (void **)__p[0];
  v6 = OFDContainer::copyFileContent(*((OFDContainer **)this + 1), (const char *)v5);
  v7 = v6;
  if (v6)
  {
    *((_QWORD *)this + 11) = XMLDictionaryCreateWithData(v6);
    CFRelease(v7);
  }
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
}

void sub_1881D6710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void OFDDocument::~OFDDocument(OFDDocument *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;

  *(_QWORD *)this = &off_1E1BABEB0;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 9);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 10);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 11);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 12);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  v7 = (void *)*((_QWORD *)this + 16);
  if (v7)
  {
    *((_QWORD *)this + 17) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 13);
  if (v8)
  {
    *((_QWORD *)this + 14) = v8;
    operator delete(v8);
  }
  if (*((char *)this + 63) < 0)
    operator delete(*((void **)this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(*((void **)this + 2));
}

{
  OFDDocument::~OFDDocument(this);
  JUMPOUT(0x18D761C30);
}

uint64_t OFDDocument::getPageCount(OFDDocument *this)
{
  return *((unsigned int *)this + 46);
}

OFDPage *OFDDocument::getPageAtIndex(OFDDocument *this, unsigned int a2)
{
  OFDPage *v4;
  __CFArray *ArrayObjectForPath;
  const __CFDictionary *ValueAtIndex;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  std::string::size_type v11;
  std::string::size_type v12;
  const __CFDictionary *ObjectForKey;
  char *v14;
  void **v15;
  std::string::size_type v16;
  OFDPage *v17;
  std::string *v18;
  _BYTE v20[24];
  void *__p[2];
  unsigned __int8 v22;
  std::string v23;
  _QWORD v24[3];

  if (*((_DWORD *)this + 46) <= a2)
    return 0;
  v4 = *(OFDPage **)(*((_QWORD *)this + 13) + 8 * a2);
  if (!v4)
  {
    ArrayObjectForPath = IIODictionary::getArrayObjectForPath(*((IIODictionary **)this + 8), CFSTR("Document.Pages.Page"));
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(ArrayObjectForPath, a2);
    memset(v24, 0, sizeof(v24));
    IIODictionary::IIODictionary((IIODictionary *)v24, ValueAtIndex);
    if (*((char *)this + 39) < 0)
    {
      v8 = (char *)*((_QWORD *)this + 2);
      v7 = *((_QWORD *)this + 3);
      if (v7)
      {
LABEL_5:
        v9 = &v8[v7];
        v10 = v8;
        while (*v10 != 47)
        {
          ++v10;
          if (!--v7)
          {
            v10 = v9;
            break;
          }
        }
        v11 = v10 - v8;
        if (v10 == v9)
          v12 = -1;
        else
          v12 = v11;
        goto LABEL_15;
      }
    }
    else
    {
      v7 = *((unsigned __int8 *)this + 39);
      v8 = (char *)this + 16;
      if (*((_BYTE *)this + 39))
        goto LABEL_5;
    }
    v12 = -1;
LABEL_15:
    memset(&v23, 0, sizeof(v23));
    std::string::basic_string(&v23, (const std::string *)((char *)this + 16), 0, v12, (std::allocator<char> *)__p);
    std::string::append(&v23, "/");
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v24, CFSTR("BaseLoc"));
    IIOString::IIOString((IIOString *)v20, ObjectForKey);
    v14 = (char *)IIOString::utf8String((IIOString *)v20);
    std::string::basic_string[abi:ne180100]<0>(__p, v14);
    if ((v22 & 0x80u) == 0)
      v15 = __p;
    else
      v15 = (void **)__p[0];
    if ((v22 & 0x80u) == 0)
      v16 = v22;
    else
      v16 = (std::string::size_type)__p[1];
    std::string::append(&v23, (const std::string::value_type *)v15, v16);
    if ((char)v22 < 0)
      operator delete(__p[0]);
    IIOString::~IIOString((IIOString *)v20);
    v17 = (OFDPage *)operator new();
    v4 = v17;
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v18 = &v23;
    else
      v18 = (std::string *)v23.__r_.__value_.__r.__words[0];
    OFDPage::OFDPage(v17, this, (const char *)v18, a2);
    if (OFDPage::open(v4))
    {
      *(_QWORD *)(*((_QWORD *)this + 13) + 8 * a2) = v4;
    }
    else
    {
      (*(void (**)(OFDPage *))(*(_QWORD *)v4 + 8))(v4);
      v4 = 0;
    }
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v23.__r_.__value_.__l.__data_);
    IIODictionary::~IIODictionary((IIODictionary *)v24);
  }
  return v4;
}

void sub_1881D6A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;

  if (a23 < 0)
    operator delete(__p);
  IIODictionary::~IIODictionary((IIODictionary *)(v23 - 56));
  _Unwind_Resume(a1);
}

OFDTemplate *OFDDocument::getTemplateAtIndex(OFDDocument *this, unsigned int a2)
{
  CFIndex v4;
  uint64_t v5;
  OFDTemplate *v6;
  __CFArray *ArrayObjectForPath;
  const __CFDictionary *ValueAtIndex;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  std::string::size_type v13;
  std::string::size_type v14;
  const __CFDictionary *ObjectForKey;
  char *v17;
  void **v18;
  std::string::size_type v19;
  OFDTemplate *v20;
  std::string *v21;
  _BYTE v22[24];
  void *__p[2];
  unsigned __int8 v24;
  std::string v25;
  _QWORD v26[3];

  if (*((_DWORD *)this + 46) <= a2)
    return 0;
  v4 = a2;
  v5 = *((_QWORD *)this + 16);
  if (a2 >= (unint64_t)((*((_QWORD *)this + 17) - v5) >> 3))
    return 0;
  v6 = *(OFDTemplate **)(v5 + 8 * a2);
  if (!v6)
  {
    ArrayObjectForPath = IIODictionary::getArrayObjectForPath(*((IIODictionary **)this + 8), CFSTR("Document.CommonData.TemplatePage"));
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(ArrayObjectForPath, v4);
    memset(v26, 0, sizeof(v26));
    IIODictionary::IIODictionary((IIODictionary *)v26, ValueAtIndex);
    if (*((char *)this + 39) < 0)
    {
      v10 = (char *)*((_QWORD *)this + 2);
      v9 = *((_QWORD *)this + 3);
      if (v9)
      {
LABEL_6:
        v11 = &v10[v9];
        v12 = v10;
        while (*v12 != 47)
        {
          ++v12;
          if (!--v9)
          {
            v12 = v11;
            break;
          }
        }
        v13 = v12 - v10;
        if (v12 == v11)
          v14 = -1;
        else
          v14 = v13;
        goto LABEL_17;
      }
    }
    else
    {
      v9 = *((unsigned __int8 *)this + 39);
      v10 = (char *)this + 16;
      if (*((_BYTE *)this + 39))
        goto LABEL_6;
    }
    v14 = -1;
LABEL_17:
    memset(&v25, 0, sizeof(v25));
    std::string::basic_string(&v25, (const std::string *)((char *)this + 16), 0, v14, (std::allocator<char> *)__p);
    std::string::append(&v25, "/");
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v26, CFSTR("BaseLoc"));
    IIOString::IIOString((IIOString *)v22, ObjectForKey);
    v17 = (char *)IIOString::utf8String((IIOString *)v22);
    std::string::basic_string[abi:ne180100]<0>(__p, v17);
    if ((v24 & 0x80u) == 0)
      v18 = __p;
    else
      v18 = (void **)__p[0];
    if ((v24 & 0x80u) == 0)
      v19 = v24;
    else
      v19 = (std::string::size_type)__p[1];
    std::string::append(&v25, (const std::string::value_type *)v18, v19);
    if ((char)v24 < 0)
      operator delete(__p[0]);
    IIOString::~IIOString((IIOString *)v22);
    v20 = (OFDTemplate *)operator new();
    v6 = v20;
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v21 = &v25;
    else
      v21 = (std::string *)v25.__r_.__value_.__r.__words[0];
    OFDTemplate::OFDTemplate(v20, this, (const char *)v21, a2);
    *(_QWORD *)(*((_QWORD *)this + 16) + 8 * v4) = v6;
    OFDTemplate::open(v6);
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v25.__r_.__value_.__l.__data_);
    IIODictionary::~IIODictionary((IIODictionary *)v26);
  }
  return v6;
}

void sub_1881D6C7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;
  uint64_t v24;

  MEMORY[0x18D761C30](v23, 0x10B3C40D6404C7DLL);
  if (a23 < 0)
    operator delete(__p);
  IIODictionary::~IIODictionary((IIODictionary *)(v24 - 56));
  _Unwind_Resume(a1);
}

uint64_t OFDDocument::open(OFDDocument *this)
{
  OFDContainer *v2;
  const char *v3;
  const __CFData *v4;
  const __CFData *v5;

  if (!*((_BYTE *)this + 188))
  {
    *((_BYTE *)this + 188) = 1;
    v2 = (OFDContainer *)*((_QWORD *)this + 1);
    v3 = (char *)this + 16;
    if (*((char *)this + 39) < 0)
      v3 = *(const char **)v3;
    v4 = OFDContainer::copyFileContent(v2, v3);
    if (v4)
    {
      v5 = v4;
      OFDDocument::parseXML(this, v4);
      CFRelease(v5);
    }
  }
  return 1;
}

BOOL OFDDocument::parseXML(OFDDocument *this, const __CFData *a2)
{
  IIODictionary *v3;
  IIODictionary *v4;
  __CFArray *ArrayObjectForPath;
  const __CFString *ValueAtIndex;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFArray *v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  __CFArray *v23;
  unsigned int Count;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v3 = XMLDictionaryCreateWithData(a2);
  v4 = v3;
  *((_QWORD *)this + 8) = v3;
  if (v3)
  {
    ArrayObjectForPath = IIODictionary::getArrayObjectForPath(v3, CFSTR("Document.CommonData.PageArea.PhysicalBox"));
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayObjectForPath, 0);
    *((double *)this + 19) = CGRectFromCFString(ValueAtIndex);
    *((_QWORD *)this + 20) = v7;
    *((_QWORD *)this + 21) = v8;
    *((_QWORD *)this + 22) = v9;
    v10 = IIODictionary::getArrayObjectForPath(*((IIODictionary **)this + 8), CFSTR("Document.Pages.Page"));
    if (v10)
      LODWORD(v10) = CFArrayGetCount(v10);
    v11 = *((_QWORD *)this + 13);
    *((_DWORD *)this + 46) = (_DWORD)v10;
    v12 = (_QWORD *)*((_QWORD *)this + 14);
    v13 = ((uint64_t)v12 - v11) >> 3;
    if (v13 < v10)
    {
      v14 = (_QWORD *)((char *)this + 120);
      do
      {
        if ((unint64_t)v12 >= *v14)
        {
          if ((v13 + 1) >> 61)
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          v15 = *v14 - v11;
          v16 = v15 >> 2;
          if (v15 >> 2 <= v13 + 1)
            v16 = v13 + 1;
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
            v17 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v17 = v16;
          if (v17)
            v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 120, v17);
          else
            v18 = 0;
          v19 = &v18[8 * v13];
          *(_QWORD *)v19 = 0;
          v12 = v19 + 8;
          v21 = (char *)*((_QWORD *)this + 13);
          v20 = (char *)*((_QWORD *)this + 14);
          if (v20 != v21)
          {
            do
            {
              v22 = *((_QWORD *)v20 - 1);
              v20 -= 8;
              *((_QWORD *)v19 - 1) = v22;
              v19 -= 8;
            }
            while (v20 != v21);
            v20 = (char *)*((_QWORD *)this + 13);
          }
          *((_QWORD *)this + 13) = v19;
          *((_QWORD *)this + 14) = v12;
          *((_QWORD *)this + 15) = &v18[8 * v17];
          if (v20)
            operator delete(v20);
        }
        else
        {
          *v12++ = 0;
        }
        *((_QWORD *)this + 14) = v12;
        v11 = *((_QWORD *)this + 13);
        v13 = ((uint64_t)v12 - v11) >> 3;
      }
      while (v13 < *((unsigned int *)this + 46));
    }
    v23 = IIODictionary::getArrayObjectForPath(*((IIODictionary **)this + 8), CFSTR("Document.CommonData.TemplatePage"));
    if (v23)
    {
      Count = CFArrayGetCount(v23);
      v25 = *((_QWORD *)this + 16);
      v26 = (_QWORD *)*((_QWORD *)this + 17);
      v27 = ((uint64_t)v26 - v25) >> 3;
      if (v27 < Count)
      {
        v28 = Count;
        v29 = (_QWORD *)((char *)this + 144);
        do
        {
          if ((unint64_t)v26 >= *v29)
          {
            if ((v27 + 1) >> 61)
              std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
            v30 = *v29 - v25;
            v31 = v30 >> 2;
            if (v30 >> 2 <= v27 + 1)
              v31 = v27 + 1;
            if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
              v32 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v32 = v31;
            if (v32)
              v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 144, v32);
            else
              v33 = 0;
            v34 = &v33[8 * v27];
            *(_QWORD *)v34 = 0;
            v26 = v34 + 8;
            v36 = (char *)*((_QWORD *)this + 16);
            v35 = (char *)*((_QWORD *)this + 17);
            if (v35 != v36)
            {
              do
              {
                v37 = *((_QWORD *)v35 - 1);
                v35 -= 8;
                *((_QWORD *)v34 - 1) = v37;
                v34 -= 8;
              }
              while (v35 != v36);
              v35 = (char *)*((_QWORD *)this + 16);
            }
            *((_QWORD *)this + 16) = v34;
            *((_QWORD *)this + 17) = v26;
            *((_QWORD *)this + 18) = &v33[8 * v32];
            if (v35)
              operator delete(v35);
          }
          else
          {
            *v26++ = 0;
          }
          *((_QWORD *)this + 17) = v26;
          v25 = *((_QWORD *)this + 16);
          v27 = ((uint64_t)v26 - v25) >> 3;
        }
        while (v27 < v28);
      }
    }
  }
  return v4 != 0;
}

void OFDDocument::setupFonts(OFDDocument *this)
{
  IIODictionary *v2;
  __CFArray *ArrayObjectForPath;
  const __CFArray *v4;
  CFIndex v5;
  const __CFDictionary *ValueAtIndex;
  IIODictionary *v7;
  const __CFString *Value;
  IIODictionary *v9;
  __CFArray *v10;
  const __CFArray *v11;
  CFIndex v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  CFTypeID TypeID;
  IIODictionary *v16;
  const __CFString *v17;

  v2 = (IIODictionary *)*((_QWORD *)this + 9);
  if (v2)
  {
    ArrayObjectForPath = IIODictionary::getArrayObjectForPath(v2, CFSTR("Res.Fonts.Font"));
    if (ArrayObjectForPath)
    {
      v4 = ArrayObjectForPath;
      if (CFArrayGetCount(ArrayObjectForPath) >= 1)
      {
        v5 = 0;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, v5);
          v7 = (IIODictionary *)*((_QWORD *)this + 12);
          Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, CFSTR("ID"));
          IIODictionary::setObjectForKey(v7, ValueAtIndex, Value);
          ++v5;
        }
        while (CFArrayGetCount(v4) > v5);
      }
    }
  }
  v9 = (IIODictionary *)*((_QWORD *)this + 10);
  if (v9)
  {
    v10 = IIODictionary::getArrayObjectForPath(v9, CFSTR("Res.Fonts.Font"));
    if (v10)
    {
      v11 = v10;
      if (CFArrayGetCount(v10) >= 1)
      {
        v12 = 0;
        do
        {
          v13 = (const __CFDictionary *)CFArrayGetValueAtIndex(v11, v12);
          if (v13)
          {
            v14 = v13;
            TypeID = CFDictionaryGetTypeID();
            if (TypeID == CFGetTypeID(v14))
            {
              if (CFDictionaryContainsKey(v14, CFSTR("FontName")))
              {
                v16 = (IIODictionary *)*((_QWORD *)this + 12);
                v17 = (const __CFString *)CFDictionaryGetValue(v14, CFSTR("ID"));
                IIODictionary::setObjectForKey(v16, v14, v17);
              }
            }
          }
          ++v12;
        }
        while (CFArrayGetCount(v11) > v12);
      }
    }
  }
  IIODictionary::enumerate(*((_QWORD *)this + 12), &__block_literal_global_27_0);
}

const void *OFDDocument::createFont(IIODictionary **this, uint64_t a2, double a3)
{
  const __CFString *v5;
  const __CFDictionary *ObjectForKey;
  const __CFString *Value;
  const __CFString *v8;
  uint64_t v9;
  const void *v10;
  const __CFString *v11;
  _QWORD v13[2];
  uint64_t v14;

  v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d"), a2);
  ObjectForKey = IIODictionary::getObjectForKey(this[12], v5);
  if (ObjectForKey)
  {
    Value = (const __CFString *)CFDictionaryGetValue(ObjectForKey, CFSTR("FontName"));
    if (Value)
    {
      v8 = Value;
      if (CFStringCompare(Value, CFSTR("SimSong-Regular"), 0) == kCFCompareEqualTo
        && OFDDocument::createFont(unsigned int,double)::onceToken != -1)
      {
        dispatch_once(&OFDDocument::createFont(unsigned int,double)::onceToken, &__block_literal_global_48);
      }
      v9 = gFunc_CTFontCreateWithName(v8, 0, a3);
      if (v9)
      {
        v10 = (const void *)v9;
        v11 = (const __CFString *)gFunc_CTFontCopyPostScriptName();
        if (CFStringCompare(v8, v11, 0) == kCFCompareEqualTo
          || CFStringCompare(CFSTR("CourierNewPSMT"), v11, 0) == kCFCompareEqualTo)
        {
          CFRelease(v11);
          return v10;
        }
        CFRelease(v10);
        CFRelease(v11);
      }
    }
  }
  v13[0] = 0;
  v13[1] = 0;
  v14 = 0;
  IIOString::IIOString((IIOString *)v13, "STSongti-TC-Regular");
  v10 = (const void *)gFunc_CTFontCreateWithName(v14, 0, a3);
  IIOString::~IIOString((IIOString *)v13);
  return v10;
}

void sub_1881D7290(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZN11OFDDocument10createFontEjd_block_invoke()
{
  IIODictionary *v0;
  const void *v1;
  NSObject *v2;
  _QWORD v3[5];
  CFMutableArrayRef v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v7 = 0;
  v8 = 0;
  v9 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v7);
  IIODictionary::setObjectForKey(v0, CFSTR("SimSong-Regular"), *(const __CFString **)gIIO_kCTFontNameAttribute);
  v1 = (const void *)gFunc_CTFontDescriptorCreateWithAttributes(v8);
  v2 = dispatch_semaphore_create(0);
  v4 = 0;
  v5 = 0;
  v6 = 0;
  IIOArray::IIOArray((IIOArray *)&v4);
  IIOArray::addObject(&v4, v1);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___ZN11OFDDocument10createFontEjd_block_invoke_2;
  v3[3] = &__block_descriptor_tmp_17_1;
  v3[4] = v2;
  if (gFunc_CTFontDescriptorMatchFontDescriptorsWithProgressHandler(v5, 0, v3))
    dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  IIOArray::~IIOArray((IIOArray *)&v4);
  IIODictionary::~IIODictionary((IIODictionary *)&v7);
}

void sub_1881D739C(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 40));
  _Unwind_Resume(a1);
}

uint64_t ___ZN11OFDDocument10createFontEjd_block_invoke_2(uint64_t a1, int a2)
{
  if (a2 == 1)
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  return 1;
}

void ___ZN11OFDDocument10setupFontsEv_block_invoke(int a1, int a2, __CFDictionary *a3)
{
  const __CFString *ObjectForKey;
  _QWORD v4[3];

  memset(v4, 0, sizeof(v4));
  IIODictionary::IIODictionary((IIODictionary *)v4, a3);
  ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v4, "FontName");
  if (CFStringCompare(ObjectForKey, CFSTR(""), 0) == kCFCompareEqualTo
    || CFStringCompare(ObjectForKey, CFSTR(""), 0) == kCFCompareEqualTo
    || CFStringCompare(ObjectForKey, CFSTR(""), 0) == kCFCompareEqualTo
    || CFStringHasPrefix(ObjectForKey, CFSTR("STSong"))
    || CFStringHasPrefix(ObjectForKey, CFSTR("KaiTi")))
  {
    IIODictionary::setObjectForKey((IIODictionary *)v4, CFSTR("SimSong-Regular"), CFSTR("FontName"));
  }
  IIODictionary::~IIODictionary((IIODictionary *)v4);
}

void sub_1881D74C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CFDataRef OFDDocument::copyFileContent(OFDContainer **this, const char *a2)
{
  return OFDContainer::copyFileContent(this[1], a2);
}

CFStringRef OFDDocument::copyResourcePath(IIODictionary **this, unsigned int a2, const __CFString *a3)
{
  uint64_t v5;
  uint64_t v6;
  CFAllocatorRef *v7;
  const void *v8;
  _QWORD *v9;
  CFStringRef v10;
  uint64_t v11;
  const void *v12;
  _QWORD *v13;
  CFStringRef v14;

  v5 = a2;
  v6 = OFDCopyResourcePathFromDictionary(this[9], a2, a3);
  v7 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v6)
  {
    v8 = (const void *)v6;
    v9 = this + 5;
    if (*((char *)this + 63) < 0)
      v9 = (_QWORD *)*v9;
    v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%s/Res/%@"), v9, v6);
    CFRelease(v8);
    if (v10)
      return v10;
  }
  v11 = OFDCopyResourcePathFromDictionary(this[10], v5, a3);
  if (!v11)
    return 0;
  v12 = (const void *)v11;
  v13 = this + 5;
  if (*((char *)this + 63) < 0)
    v13 = (_QWORD *)*v13;
  v14 = CFStringCreateWithFormat(*v7, 0, CFSTR("%s/Res/%@"), v13, v11);
  CFRelease(v12);
  return v14;
}

uint64_t unzStringFileNameCompare(const char *a1, const char *a2, int a3)
{
  int v4;
  int v5;
  int v6;
  int v7;

  if (a3 == 1)
    return strcmp(a1, a2);
  while (1)
  {
    v5 = *(unsigned __int8 *)a1++;
    v4 = v5;
    v7 = *(unsigned __int8 *)a2++;
    v6 = v7;
    if ((v4 - 97) < 0x1A)
      LOBYTE(v4) = v4 - 32;
    if ((v6 - 97) < 0x1A)
      LOBYTE(v6) = v6 - 32;
    if (!(_BYTE)v4)
      break;
    if (!(_BYTE)v6)
      return 1;
    if ((char)v4 < (char)v6)
      return 0xFFFFFFFFLL;
    if ((char)v4 > (char)v6)
      return 1;
  }
  if ((_BYTE)v6)
    return 0xFFFFFFFFLL;
  else
    return 0;
}

_QWORD *unzOpenInternal(uint64_t a1, uint64_t a2, int a3)
{
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _BYTE *v11;
  _BYTE *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  int Long;
  int Long64;
  int Short;
  int v23;
  int v24;
  int v25;
  int v26;
  BOOL v27;
  int v28;
  int v29;
  BOOL v30;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  _BYTE *v39;
  _BYTE *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  BOOL v52;
  int v53;
  BOOL v54;
  int v56;
  int v57;
  int v58;
  _QWORD *v59;
  _QWORD *v60;
  uint64_t v61;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _OWORD __src[21];
  unint64_t v68;
  uint64_t v69[2];

  memset(__src, 0, sizeof(__src));
  v63 = 0;
  if (a2)
  {
    v4 = *(_OWORD *)(a2 + 48);
    __src[2] = *(_OWORD *)(a2 + 32);
    __src[3] = v4;
    __src[4] = *(_OWORD *)(a2 + 64);
    *(_QWORD *)&__src[5] = *(_QWORD *)(a2 + 80);
    v5 = *(_OWORD *)(a2 + 16);
    __src[0] = *(_OWORD *)a2;
    __src[1] = v5;
  }
  else
  {
    fill_fopen64_filefunc((FILE *(**)(int, char *, char))__src);
  }
  DWORD2(__src[5]) = a3;
  v6 = call_zopen64((uint64_t)__src);
  *(_QWORD *)&__src[6] = v6;
  if (!v6)
    return 0;
  v7 = v6;
  v65 = 0;
  v66 = 0;
  v64 = 0;
  if (!call_zseek64(__src))
  {
    v8 = call_ztell64((uint64_t)__src);
    v9 = v8;
    v10 = v8 >= 0xFFFF ? 0xFFFFLL : v8;
    v11 = malloc_type_malloc(0x404uLL, 0xBA45F597uLL);
    if (v11)
    {
      v12 = v11;
      if (v10 >= 5)
      {
        v13 = 4;
        do
        {
          v14 = v13 + 1024;
          if (v13 + 1024 >= v10)
            v13 = v10;
          else
            v13 += 1024;
          v15 = v13 >= 0x404 ? 1028 : v13;
          if (call_zseek64(__src)
            || (*((uint64_t (**)(_QWORD, uint64_t, _BYTE *, unint64_t))&__src[0] + 1))(*((_QWORD *)&__src[3] + 1), v7, v12, v15) != v15)
          {
            break;
          }
          if (v15 >= 4)
          {
            v16 = (v15 - 4) + 1;
            while (v12[v16 - 1] != 80 || v12[v16] != 75 || v12[v16 + 1] != 6 || v12[v16 + 2] != 7)
            {
              v17 = v16-- <= 1;
              if (v17)
                goto LABEL_28;
            }
            if ((v16 - 1) + v9 - v13)
            {
              free(v12);
              if (call_zseek64(__src))
                goto LABEL_62;
              v69[0] = 0;
              if (unz64local_getLong((uint64_t)__src, v7, v69))
                goto LABEL_62;
              if (unz64local_getLong((uint64_t)__src, v7, v69))
                goto LABEL_62;
              if (v69[0])
                goto LABEL_62;
              v68 = 0;
              if (unz64local_getLong64((uint64_t)__src, v7, &v68))
                goto LABEL_62;
              if (unz64local_getLong((uint64_t)__src, v7, v69))
                goto LABEL_62;
              if (v69[0] != 1)
                goto LABEL_62;
              v18 = v68;
              if (call_zseek64(__src)
                || unz64local_getLong((uint64_t)__src, v7, v69)
                || v69[0] != 101075792
                || !v18)
              {
                goto LABEL_62;
              }
              HIDWORD(__src[20]) = 1;
              v19 = call_zseek64(__src);
              Long = unz64local_getLong((uint64_t)__src, *(uint64_t *)&__src[6], &v66);
              Long64 = unz64local_getLong64((uint64_t)__src, *(uint64_t *)&__src[6], &v68);
              Short = unz64local_getShort((uint64_t)__src, *(uint64_t *)&__src[6], v69);
              v23 = unz64local_getShort((uint64_t)__src, *(uint64_t *)&__src[6], v69);
              v24 = unz64local_getLong((uint64_t)__src, *(uint64_t *)&__src[6], &v65);
              v25 = unz64local_getLong((uint64_t)__src, *(uint64_t *)&__src[6], &v64);
              v26 = unz64local_getLong64((uint64_t)__src, *(uint64_t *)&__src[6], (unint64_t *)&__src[6] + 1);
              if (unz64local_getLong64((uint64_t)__src, *(uint64_t *)&__src[6], &v63) | v26 | v25 | v24 | v23 | Short | Long64 | Long)
                v27 = 0;
              else
                v27 = v19 == 0;
              v28 = !v27;
              v29 = v28 << 31 >> 31;
              if (v65)
                v30 = 0;
              else
                v30 = v64 == 0;
              if (v30 && v63 == *((_QWORD *)&__src[6] + 1))
                v32 = v29;
              else
                v32 = -103;
              v33 = unz64local_getLong64((uint64_t)__src, *(uint64_t *)&__src[6], (unint64_t *)&__src[10]);
              if (unz64local_getLong64((uint64_t)__src, *(uint64_t *)&__src[6], (unint64_t *)&__src[10] + 1) | v33)v34 = -1;
              else
                v34 = v32;
              *(_QWORD *)&__src[7] = 0;
              goto LABEL_109;
            }
          }
LABEL_28:
          ;
        }
        while (v10 > v14);
      }
      free(v12);
    }
  }
LABEL_62:
  v35 = *(_QWORD *)&__src[6];
  if (!call_zseek64(__src))
  {
    v36 = call_ztell64((uint64_t)__src);
    v37 = v36;
    v38 = v36 >= 0xFFFF ? 0xFFFFLL : v36;
    v39 = malloc_type_malloc(0x404uLL, 0x16ECF6D5uLL);
    if (v39)
    {
      v40 = v39;
      if (v38 >= 5)
      {
        v41 = 4;
        do
        {
          v42 = v41 + 1024;
          if (v41 + 1024 >= v38)
            v41 = v38;
          else
            v41 += 1024;
          v43 = v41 >= 0x404 ? 1028 : v41;
          if (call_zseek64(__src)
            || (*((uint64_t (**)(_QWORD, uint64_t, _BYTE *, unint64_t))&__src[0] + 1))(*((_QWORD *)&__src[3] + 1), v35, v40, v43) != v43)
          {
            break;
          }
          if (v43 >= 4)
          {
            v44 = (v43 - 4) + 1;
            while (v40[v44 - 1] != 80 || v40[v44] != 75 || v40[v44 + 1] != 5 || v40[v44 + 2] != 6)
            {
              v17 = v44-- <= 1;
              if (v17)
                goto LABEL_85;
            }
            v18 = (v44 - 1) + v37 - v41;
            if (v18)
            {
              free(v40);
              v45 = 0;
              goto LABEL_91;
            }
          }
LABEL_85:
          ;
        }
        while (v38 > v42);
      }
      free(v40);
    }
  }
  v18 = 0;
  v45 = -1;
LABEL_91:
  HIDWORD(__src[20]) = 0;
  v46 = call_zseek64(__src);
  v47 = unz64local_getLong((uint64_t)__src, *(uint64_t *)&__src[6], &v66);
  v48 = unz64local_getShort((uint64_t)__src, *(uint64_t *)&__src[6], &v65);
  v49 = unz64local_getShort((uint64_t)__src, *(uint64_t *)&__src[6], &v64);
  v50 = unz64local_getShort((uint64_t)__src, *(uint64_t *)&__src[6], &v66);
  *((_QWORD *)&__src[6] + 1) = v66;
  v51 = unz64local_getShort((uint64_t)__src, *(uint64_t *)&__src[6], &v66) | v50 | v49 | v48 | v47;
  if (v46)
    v52 = 0;
  else
    v52 = v51 == 0;
  if (v52)
    v53 = v45;
  else
    v53 = -1;
  if (v65)
    v54 = 0;
  else
    v54 = v64 == 0;
  if (v54 && v66 == *((_QWORD *)&__src[6] + 1))
    v56 = v53;
  else
    v56 = -103;
  v57 = unz64local_getLong((uint64_t)__src, *(uint64_t *)&__src[6], &v66);
  *(_QWORD *)&__src[10] = v66;
  v58 = unz64local_getLong((uint64_t)__src, *(uint64_t *)&__src[6], &v66);
  *((_QWORD *)&__src[10] + 1) = v66;
  if (unz64local_getShort((uint64_t)__src, *(uint64_t *)&__src[6], (uint64_t *)&__src[7]) | v58 | v57)
    v34 = -1;
  else
    v34 = v56;
LABEL_109:
  if (v18 < *(_QWORD *)&__src[10] + *((_QWORD *)&__src[10] + 1) || v34)
  {
    (*((void (**)(_QWORD, _QWORD))&__src[2] + 1))(*((_QWORD *)&__src[3] + 1), *(_QWORD *)&__src[6]);
    return 0;
  }
  *((_QWORD *)&__src[7] + 1) = v18 - (*(_QWORD *)&__src[10] + *((_QWORD *)&__src[10] + 1));
  *((_QWORD *)&__src[9] + 1) = v18;
  *(_QWORD *)&__src[20] = 0;
  DWORD2(__src[20]) = 0;
  v59 = malloc_type_malloc(0x150uLL, 0x10A004033D922FDuLL);
  v60 = v59;
  if (v59)
  {
    memcpy(v59, __src, 0x150uLL);
    v61 = v60[21];
    v60[16] = 0;
    v60[17] = v61;
    v60[18] = unz64local_GetCurrentFileInfoInternal((uint64_t)v60, (uint64_t)(v60 + 22), v60 + 39, 0, 0, 0, 0, 0, 0) == 0;
  }
  return v60;
}

_QWORD *unzOpen(uint64_t a1)
{
  return unzOpenInternal(a1, 0, 0);
}

_QWORD *unzOpenBuffer(uint64_t a1, uint64_t a2)
{
  _OWORD v3[5];
  uint64_t v4;
  char v5[16];
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)v5 = 0u;
  v6 = 0u;
  v4 = 0;
  memset(v3, 0, sizeof(v3));
  __sprintf_chk(v5, 0, 0x20uLL, "%lx+%lx", a1, a2);
  fill_memory_filefunc64_32(v3);
  return unzOpenInternal((uint64_t)v5, (uint64_t)v3, 0);
}

uint64_t unzCloseCurrentFile(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (!a1)
    return 4294967194;
  v2 = *(_QWORD *)(a1 + 320);
  if (!v2)
    return 4294967194;
  if (*(_QWORD *)(v2 + 192) || *(_DWORD *)(v2 + 312))
  {
    v3 = 0;
  }
  else if (*(_QWORD *)(v2 + 168) == *(_QWORD *)(v2 + 176))
  {
    v3 = 0;
  }
  else
  {
    v3 = 4294967191;
  }
  if (*(_QWORD *)v2)
    free(*(void **)v2);
  *(_QWORD *)v2 = 0;
  if (*(_QWORD *)(v2 + 128) == 8)
    inflateEnd((z_streamp)(v2 + 8));
  free((void *)v2);
  *(_QWORD *)(a1 + 320) = 0;
  return v3;
}

uint64_t unzGetGlobalInfo(uint64_t a1, _OWORD *a2)
{
  uint64_t result;

  if (!a1)
    return 4294967194;
  result = 0;
  *a2 = *(_OWORD *)(a1 + 104);
  return result;
}

uint64_t unzGetCurrentFileInfo64(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8)
{
  return unz64local_GetCurrentFileInfoInternal(a1, a2, 0, a3, a4, a5, a6, a7, a8);
}

uint64_t unz64local_GetCurrentFileInfoInternal(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8, unint64_t a9)
{
  int v10;
  uint32x4_t v11;
  int8x16_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t i;
  int v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int8x16_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  int v45;
  int Long;
  int v47;
  int v48;
  int v49;
  int Short;
  unsigned int v51;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  int8x16_t v68;
  uint64_t v69;

  v59 = 0;
  if (!a1)
    return 4294967194;
  if (call_zseek64((_QWORD *)a1) || unz64local_getLong(a1, *(_QWORD *)(a1 + 96), &v59))
  {
    v10 = -1;
  }
  else if (v59 == 33639248)
  {
    v10 = 0;
  }
  else
  {
    v10 = -103;
  }
  v51 = v10;
  v69 = 0;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v58 = 0;
  Short = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v61);
  v49 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v61 + 1);
  v48 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v62);
  v47 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v62 + 1);
  Long = unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v63);
  LODWORD(v69) = ((v63 >> 21) & 0xF) - 1;
  HIDWORD(v69) = (v63 >> 25) + 1980;
  v11.i32[0] = v63;
  v12 = (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v63), (uint32x4_t)xmmword_18823F910);
  v12.i32[0] = vshlq_u32(v11, (uint32x4_t)xmmword_18823F900).u32[0];
  v68 = vandq_s8(v12, (int8x16_t)xmmword_18823F920);
  v45 = unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v63 + 1);
  v13 = unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v58);
  *(_QWORD *)&v64 = v58;
  v14 = unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v58);
  *((_QWORD *)&v64 + 1) = v58;
  v15 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v65);
  v16 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v65 + 1);
  v17 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v66);
  v18 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v66 + 1);
  v19 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v67);
  v20 = unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v67 + 1);
  if (unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v58) | v20 | v19 | v18 | v17 | v16 | v15 | v14 | v13 | v45 | Long | v47 | v48 | v49 | Short)
    v21 = 0xFFFFFFFFLL;
  else
    v21 = v51;
  v60 = v58;
  v22 = v65;
  if (a4)
  {
    v24 = a7;
    v23 = a6;
    if (!(_DWORD)v21)
    {
      v25 = a5;
      if ((unint64_t)v65 < a5)
      {
        *(_BYTE *)(a4 + v65) = 0;
        v25 = v22;
      }
      v21 = 0;
      if (a5 && v22)
      {
        if ((*(uint64_t (**)(_QWORD, _QWORD))(a1 + 8))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 96)) == v25)
          v21 = 0;
        else
          v21 = 0xFFFFFFFFLL;
      }
      v22 -= v25;
    }
  }
  else
  {
    v24 = a7;
    v23 = a6;
  }
  v26 = *((_QWORD *)&v65 + 1);
  if (v23 && !(_DWORD)v21)
  {
    if (*((_QWORD *)&v65 + 1) >= v24)
      v27 = v24;
    else
      v27 = *((_QWORD *)&v65 + 1);
    if (v22)
    {
      v28 = call_zseek64((_QWORD *)a1);
      if (v28)
        v21 = 0xFFFFFFFFLL;
      else
        v21 = 0;
      if (!v28)
        v22 = 0;
      if (!v24)
      {
LABEL_40:
        v29 = v26 - v27 + v22;
        if ((_DWORD)v21)
          goto LABEL_76;
        goto LABEL_41;
      }
    }
    else
    {
      v21 = 0;
      if (!v24)
        goto LABEL_40;
    }
    if (v26)
    {
      if ((*(uint64_t (**)(_QWORD, _QWORD, uint64_t, unint64_t))(a1 + 8))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 96), v23, v27) == v27)v21 = v21;
      else
        v21 = 0xFFFFFFFFLL;
    }
    goto LABEL_40;
  }
  v29 = *((_QWORD *)&v65 + 1) + v22;
  if ((_DWORD)v21)
    goto LABEL_76;
LABEL_41:
  if (v26)
  {
    if (v29 == v26)
    {
      LODWORD(v21) = 0;
      v29 = 0;
    }
    else
    {
      v30 = call_zseek64((_QWORD *)a1);
      if (v30)
        LODWORD(v21) = -1;
      else
        LODWORD(v21) = 0;
      if (v30)
        v29 -= v26;
      else
        v29 = 0;
    }
    for (i = 0; i < v26; i += v33 + 4)
    {
      v56 = 0;
      v57 = 0;
      v32 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), &v57);
      if (unz64local_getShort(a1, *(_QWORD *)(a1 + 96), &v56) | v32)
        v21 = 0xFFFFFFFFLL;
      else
        v21 = v21;
      if (v57 == 1)
      {
        if (*((_QWORD *)&v64 + 1) == 0xFFFFFFFFLL)
        {
          if (unz64local_getLong64(a1, *(_QWORD *)(a1 + 96), (unint64_t *)&v64 + 1))
            v21 = 0xFFFFFFFFLL;
          else
            v21 = v21;
        }
        if ((_QWORD)v64 == 0xFFFFFFFFLL)
        {
          if (unz64local_getLong64(a1, *(_QWORD *)(a1 + 96), (unint64_t *)&v64))
            v21 = 0xFFFFFFFFLL;
          else
            v21 = v21;
        }
        if (v60 == 0xFFFFFFFF)
        {
          if (unz64local_getLong64(a1, *(_QWORD *)(a1 + 96), &v60))
            v21 = 0xFFFFFFFFLL;
          else
            v21 = v21;
        }
        if (*((_QWORD *)&v66 + 1) == 0xFFFFFFFFLL)
        {
          if (unz64local_getLong(a1, *(_QWORD *)(a1 + 96), &v55))
            v21 = 0xFFFFFFFFLL;
          else
            v21 = v21;
        }
        v33 = v56;
        v26 = *((_QWORD *)&v65 + 1);
      }
      else
      {
        v33 = v56;
        if (call_zseek64((_QWORD *)a1))
          v21 = 0xFFFFFFFFLL;
        else
          v21 = v21;
      }
    }
  }
LABEL_76:
  if (a8 && !(_DWORD)v21)
  {
    v34 = v66;
    v35 = a9;
    if ((unint64_t)v66 < a9)
    {
      *(_BYTE *)(a8 + v66) = 0;
      v35 = v34;
    }
    if (v29)
    {
      if (call_zseek64((_QWORD *)a1))
        v21 = 0xFFFFFFFFLL;
      else
        v21 = 0;
      if (!a9)
        goto LABEL_91;
LABEL_87:
      if (v34)
      {
        if ((*(uint64_t (**)(_QWORD, _QWORD, uint64_t, unint64_t))(a1 + 8))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 96), a8, v35) == v35)v21 = v21;
        else
          v21 = 0xFFFFFFFFLL;
      }
      goto LABEL_91;
    }
    v21 = 0;
    if (a9)
      goto LABEL_87;
  }
LABEL_91:
  if (a2 && !(_DWORD)v21)
  {
    v36 = v68;
    *(_OWORD *)(a2 + 96) = v67;
    *(int8x16_t *)(a2 + 112) = v36;
    *(_QWORD *)(a2 + 128) = v69;
    v37 = v64;
    *(_OWORD *)(a2 + 32) = v63;
    *(_OWORD *)(a2 + 48) = v37;
    v38 = v66;
    *(_OWORD *)(a2 + 64) = v65;
    *(_OWORD *)(a2 + 80) = v38;
    v39 = v62;
    *(_OWORD *)a2 = v61;
    *(_OWORD *)(a2 + 16) = v39;
  }
  if (a3 && !(_DWORD)v21)
    *a3 = v60;
  return v21;
}

uint64_t unzGoToFirstFile(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;

  if (!a1)
    return 4294967194;
  v2 = a1[21];
  a1[16] = 0;
  a1[17] = v2;
  result = unz64local_GetCurrentFileInfoInternal((uint64_t)a1, (uint64_t)(a1 + 22), a1 + 39, 0, 0, 0, 0, 0, 0);
  a1[18] = (_DWORD)result == 0;
  return result;
}

uint64_t unzGoToNextFile(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t result;

  if (!a1)
    return 4294967194;
  if (!a1[18])
    return 4294967196;
  v2 = a1[13];
  v3 = a1[16] + 1;
  if (v2 != 0xFFFF && v3 == v2)
    return 4294967196;
  v5 = a1[30] + a1[31] + a1[32] + a1[17] + 46;
  a1[16] = v3;
  a1[17] = v5;
  result = unz64local_GetCurrentFileInfoInternal((uint64_t)a1, (uint64_t)(a1 + 22), a1 + 39, 0, 0, 0, 0, 0, 0);
  a1[18] = (_DWORD)result == 0;
  return result;
}

uint64_t unzLocateFile(uint64_t a1, char *__s, int a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  _OWORD v20[16];
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1 || strlen(__s) > 0xFF)
    return 4294967194;
  if (!*(_QWORD *)(a1 + 144))
    return 4294967196;
  v7 = *(_QWORD *)(a1 + 128);
  v8 = *(_QWORD *)(a1 + 136);
  v17 = *(_OWORD *)(a1 + 272);
  v18 = *(_OWORD *)(a1 + 288);
  v9 = *(_QWORD *)(a1 + 312);
  v19 = *(_QWORD *)(a1 + 304);
  v13 = *(_OWORD *)(a1 + 208);
  v14 = *(_OWORD *)(a1 + 224);
  v15 = *(_OWORD *)(a1 + 240);
  v16 = *(_OWORD *)(a1 + 256);
  v11 = *(_OWORD *)(a1 + 176);
  v12 = *(_OWORD *)(a1 + 192);
  v10 = *(_QWORD *)(a1 + 168);
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = v10;
  result = unz64local_GetCurrentFileInfoInternal(a1, a1 + 176, (_QWORD *)(a1 + 312), 0, 0, 0, 0, 0, 0);
  for (*(_QWORD *)(a1 + 144) = (_DWORD)result == 0; !(_DWORD)result; result = unzGoToNextFile((_QWORD *)a1))
  {
    v21 = 0;
    memset(v20, 0, sizeof(v20));
    result = unz64local_GetCurrentFileInfoInternal(a1, 0, 0, (uint64_t)v20, 0x100uLL, 0, 0, 0, 0);
    if ((_DWORD)result)
      break;
    result = unzStringFileNameCompare((const char *)v20, __s, a3);
    if (!(_DWORD)result)
      return result;
  }
  *(_QWORD *)(a1 + 128) = v7;
  *(_QWORD *)(a1 + 136) = v8;
  *(_OWORD *)(a1 + 272) = v17;
  *(_OWORD *)(a1 + 288) = v18;
  *(_QWORD *)(a1 + 304) = v19;
  *(_OWORD *)(a1 + 208) = v13;
  *(_OWORD *)(a1 + 224) = v14;
  *(_OWORD *)(a1 + 240) = v15;
  *(_OWORD *)(a1 + 256) = v16;
  *(_OWORD *)(a1 + 176) = v11;
  *(_OWORD *)(a1 + 192) = v12;
  *(_QWORD *)(a1 + 312) = v9;
  return result;
}

uint64_t unzOpenCurrentFile3(uint64_t a1, _DWORD *a2, int *a3, int a4, uint64_t a5)
{
  uint64_t v5;
  int Long;
  uint64_t v11;
  int Short;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v21;
  int v22;
  char *v23;
  char *v24;
  void *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;

  v5 = 4294967194;
  if (!a1 || a5 || !*(_QWORD *)(a1 + 144))
    return v5;
  if (*(_QWORD *)(a1 + 320))
    unzCloseCurrentFile(a1);
  if (call_zseek64((_QWORD *)a1))
    return 4294967193;
  v38 = 0;
  v39 = 0;
  v37 = 0;
  Long = unz64local_getLong(a1, *(_QWORD *)(a1 + 96), &v39);
  v11 = v39;
  Short = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v38);
  v13 = unz64local_getShort(a1, *(_QWORD *)(a1 + 96), &v37);
  if (unz64local_getShort(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v38))
  {
    v14 = -1;
  }
  else
  {
    if (v11 == 67324752)
      v17 = 0;
    else
      v17 = -103;
    v18 = v13 | Short | Long;
    if (v18)
      v14 = -1;
    else
      v14 = v17;
    if (!v18 && v11 == 67324752)
    {
      if (v38 == *(_QWORD *)(a1 + 200) && v38 <= 0xC && ((1 << v38) & 0x1101) != 0)
        v14 = 0;
      else
        v14 = -103;
    }
  }
  v15 = unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v38);
  if (unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v38))
  {
    v16 = -1;
  }
  else
  {
    if (v15)
      v16 = -1;
    else
      v16 = v14;
    if (!v16)
    {
      if (v38 == *(_QWORD *)(a1 + 216))
      {
        v16 = 0;
      }
      else if ((v37 & 8) != 0)
      {
        v16 = 0;
      }
      else
      {
        v16 = -103;
      }
    }
  }
  if (unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v38))
  {
    v16 = -1;
  }
  else if (!v16 && v38 != 0xFFFFFFFF)
  {
    if (v38 == *(_QWORD *)(a1 + 224))
    {
      v16 = 0;
    }
    else if ((v37 & 8) != 0)
    {
      v16 = 0;
    }
    else
    {
      v16 = -103;
    }
  }
  if (unz64local_getLong(a1, *(_QWORD *)(a1 + 96), (uint64_t *)&v38))
  {
    v16 = -1;
  }
  else if (!v16 && v38 != 0xFFFFFFFF)
  {
    if (v38 == *(_QWORD *)(a1 + 232))
    {
      v16 = 0;
    }
    else if ((v37 & 8) != 0)
    {
      v16 = 0;
    }
    else
    {
      v16 = -103;
    }
  }
  v36 = 0;
  if (unz64local_getShort(a1, *(_QWORD *)(a1 + 96), &v36))
  {
    v16 = -1;
    v19 = v36;
  }
  else
  {
    v19 = v36;
    if (!v16)
    {
      if (v36 == *(_QWORD *)(a1 + 240))
        v16 = 0;
      else
        v16 = -103;
    }
  }
  v35 = 0;
  if (unz64local_getShort(a1, *(_QWORD *)(a1 + 96), &v35) || v16)
    return 4294967193;
  v21 = *(_QWORD *)(a1 + 312);
  v22 = v35;
  v23 = (char *)malloc_type_malloc(0x140uLL, 0x10B004067B04D0FuLL);
  if (!v23)
    return 4294967192;
  v24 = v23;
  v25 = malloc_type_malloc(0x4000uLL, 0xD13C373uLL);
  *(_QWORD *)v24 = v25;
  *((_QWORD *)v24 + 17) = v19 + v21 + 30;
  *((_DWORD *)v24 + 36) = v22;
  *((_QWORD *)v24 + 19) = 0;
  *((_DWORD *)v24 + 78) = a4;
  if (!v25)
  {
    free(v24);
    return 4294967192;
  }
  *((_QWORD *)v24 + 16) = 0;
  if (a2)
    *a2 = *(_QWORD *)(a1 + 200);
  if (!a3)
    goto LABEL_75;
  *a3 = 6;
  v26 = *(_QWORD *)(a1 + 192) & 6;
  switch(v26)
  {
    case 2:
      v27 = 9;
      break;
    case 6:
      v27 = 1;
      break;
    case 4:
      v27 = 2;
      break;
    default:
      goto LABEL_75;
  }
  *a3 = v27;
LABEL_75:
  v28 = *(_QWORD *)(a1 + 216);
  *((_QWORD *)v24 + 21) = 0;
  *((_QWORD *)v24 + 22) = v28;
  *((_QWORD *)v24 + 20) = 0;
  *((_QWORD *)v24 + 37) = *(_QWORD *)(a1 + 200);
  *((_QWORD *)v24 + 36) = *(_QWORD *)(a1 + 96);
  v29 = *(_OWORD *)(a1 + 32);
  v30 = *(_OWORD *)(a1 + 48);
  v31 = *(_OWORD *)(a1 + 64);
  *((_QWORD *)v24 + 35) = *(_QWORD *)(a1 + 80);
  *(_OWORD *)(v24 + 264) = v31;
  *(_OWORD *)(v24 + 248) = v30;
  *(_OWORD *)(v24 + 232) = v29;
  v32 = *(_OWORD *)a1;
  *(_OWORD *)(v24 + 216) = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(v24 + 200) = v32;
  *((_QWORD *)v24 + 38) = *(_QWORD *)(a1 + 120);
  *((_QWORD *)v24 + 6) = 0;
  v33 = *(_QWORD *)(a1 + 200);
  if (a4 || v33 != 12)
  {
    if (!a4 && v33 == 8)
    {
      *((_QWORD *)v24 + 1) = 0;
      *((_DWORD *)v24 + 4) = 0;
      *((_QWORD *)v24 + 10) = 0;
      *((_QWORD *)v24 + 11) = 0;
      *((_QWORD *)v24 + 9) = 0;
      v34 = inflateInit2_((z_streamp)(v24 + 8), -15, "1.2.12", 112);
      if ((_DWORD)v34)
      {
        v5 = v34;
        free(v24);
        return v5;
      }
      *((_QWORD *)v24 + 16) = 8;
    }
  }
  else
  {
    *((_DWORD *)v24 + 78) = 1;
  }
  v5 = 0;
  *(_OWORD *)(v24 + 184) = *(_OWORD *)(a1 + 224);
  *((_QWORD *)v24 + 15) = *(_QWORD *)(a1 + 312) + (v22 + v19) + 30;
  *((_DWORD *)v24 + 4) = 0;
  *(_QWORD *)(a1 + 320) = v24;
  *(_DWORD *)(a1 + 328) = 0;
  return v5;
}

uint64_t unzOpenCurrentFile(uint64_t a1)
{
  return unzOpenCurrentFile3(a1, 0, 0, 0, 0);
}

uint64_t unzReadCurrentFile(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t i;
  uint64_t v14;
  uLong v15;
  unint64_t v16;
  const Bytef *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uLong v22;
  uint64_t v23;

  if (!a1)
    return 4294967194;
  v3 = *(_QWORD *)(a1 + 320);
  if (!v3)
    return 4294967194;
  if (!*(_QWORD *)v3)
    return 4294967196;
  if (!a3)
    return 0;
  *(_QWORD *)(v3 + 32) = a2;
  *(_DWORD *)(v3 + 40) = a3;
  v4 = a3;
  v5 = *(_QWORD *)(v3 + 192);
  if (v5 < a3 && !*(_DWORD *)(v3 + 312))
  {
    *(_DWORD *)(v3 + 40) = v5;
    a3 = v5;
  }
  v6 = *(_QWORD *)(v3 + 184);
  v7 = *(unsigned int *)(v3 + 16);
  if (v6 + v7 < v4 && *(_DWORD *)(v3 + 312))
  {
    a3 = v7 + v6;
    *(_DWORD *)(v3 + 40) = v7 + v6;
  }
  if (!a3)
    return 0;
  v8 = 0;
  while (1)
  {
    LODWORD(v9) = *(_DWORD *)(v3 + 16);
    if (!(_DWORD)v9)
    {
      v10 = *(_QWORD *)(v3 + 184);
      if (v10)
      {
        if (v10 >= 0x4000)
          v9 = 0x4000;
        else
          v9 = *(_QWORD *)(v3 + 184);
        if (call_zseek64((_QWORD *)(v3 + 200))
          || (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(v3 + 208))(*(_QWORD *)(v3 + 256), *(_QWORD *)(v3 + 288), *(_QWORD *)v3, v9) != v9)
        {
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)(v3 + 120) += v9;
        *(_QWORD *)(v3 + 184) -= v9;
        *(_QWORD *)(v3 + 8) = *(_QWORD *)v3;
        *(_DWORD *)(v3 + 16) = v9;
      }
      else
      {
        LODWORD(v9) = 0;
      }
    }
    v11 = *(_QWORD *)(v3 + 296);
    if (v11)
    {
      if (!*(_DWORD *)(v3 + 312))
        break;
    }
    if (!(_DWORD)v9 && !*(_QWORD *)(v3 + 184))
      return v8;
    v12 = *(_DWORD *)(v3 + 40);
    if (v12 >= v9)
      v9 = v9;
    else
      v9 = v12;
    if ((_DWORD)v9)
    {
      for (i = 0; i != v9; ++i)
        *(_BYTE *)(*(_QWORD *)(v3 + 32) + i) = *(_BYTE *)(*(_QWORD *)(v3 + 8) + i);
      v14 = v9;
    }
    else
    {
      v14 = 0;
    }
    v15 = *(_QWORD *)(v3 + 168);
    *(_QWORD *)(v3 + 160) += v14;
    *(_QWORD *)(v3 + 168) = crc32(v15, *(const Bytef **)(v3 + 32), v9);
    *(_QWORD *)(v3 + 192) -= v14;
    *(_DWORD *)(v3 + 16) -= v9;
    *(_DWORD *)(v3 + 40) -= v9;
    *(_QWORD *)(v3 + 32) += v14;
    *(_QWORD *)(v3 + 8) += v14;
    v8 = (v9 + v8);
    *(_QWORD *)(v3 + 48) += v14;
LABEL_35:
    if (!*(_DWORD *)(v3 + 40))
      return v8;
  }
  if (v11 == 12)
    goto LABEL_35;
  v16 = *(_QWORD *)(v3 + 48);
  v17 = *(const Bytef **)(v3 + 32);
  v18 = inflate((z_streamp)(v3 + 8), 2);
  v19 = v18;
  if ((v18 & 0x80000000) == 0)
  {
    if (*(_QWORD *)(v3 + 56))
      v19 = 4294967293;
    else
      v19 = v18;
  }
  v20 = *(_QWORD *)(v3 + 48);
  if (v20 < v16)
    v20 += 0x100000000;
  v21 = v20 - v16;
  v22 = *(_QWORD *)(v3 + 168);
  *(_QWORD *)(v3 + 160) += v21;
  *(_QWORD *)(v3 + 168) = crc32(v22, v17, v21);
  *(_QWORD *)(v3 + 192) -= v21;
  v8 = (v8 + v21);
  if (!(_DWORD)v19)
    goto LABEL_35;
  v23 = v8;
  v8 = v19;
  if ((_DWORD)v19 != 1)
    return v8;
  return v23;
}

uint64_t unz64local_getLong(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  int v11;

  v11 = 0;
  if (unz64local_getByte(a1, a2, &v11)
    || (v6 = v11, unz64local_getByte(a1, a2, &v11))
    || (v7 = v11, unz64local_getByte(a1, a2, &v11)))
  {
    v8 = 0;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v10 = v6 | (v7 << 8) | ((uint64_t)v11 << 16);
    result = unz64local_getByte(a1, a2, &v11);
    v8 = v10 + ((uint64_t)v11 << 24);
    if ((_DWORD)result)
      v8 = 0;
  }
  *a3 = v8;
  return result;
}

uint64_t unz64local_getLong64(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  unint64_t v14;
  unsigned int v15;

  v15 = 0;
  if (unz64local_getByte(a1, a2, &v15)
    || (v6 = (int)v15, unz64local_getByte(a1, a2, &v15))
    || (v7 = (int)v15, unz64local_getByte(a1, a2, &v15))
    || (v8 = (int)v15, unz64local_getByte(a1, a2, &v15))
    || (v9 = (int)v15, unz64local_getByte(a1, a2, &v15))
    || (v10 = (int)v15, unz64local_getByte(a1, a2, &v15))
    || (v11 = v15, unz64local_getByte(a1, a2, &v15)))
  {
    v12 = 0;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v14 = v6 | (v7 << 8) | (v8 << 16) | (v9 << 24) | (v10 << 32) | (v11 << 40) | ((unint64_t)v15 << 48);
    result = unz64local_getByte(a1, a2, &v15);
    v12 = v14 | ((unint64_t)v15 << 56);
    if ((_DWORD)result)
      v12 = 0;
  }
  *a3 = v12;
  return result;
}

uint64_t unz64local_getShort(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  int v9;

  v9 = 0;
  if (unz64local_getByte(a1, a2, &v9))
  {
    v6 = 0;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v8 = v9;
    result = unz64local_getByte(a1, a2, &v9);
    v6 = v8 | ((uint64_t)v9 << 8);
    if ((_DWORD)result)
      v6 = 0;
  }
  *a3 = v6;
  return result;
}

uint64_t unz64local_getByte(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  unsigned __int8 v7;

  v7 = 0;
  if ((*(unsigned int (**)(_QWORD, uint64_t, unsigned __int8 *, uint64_t))(a1 + 8))(*(_QWORD *)(a1 + 56), a2, &v7, 1) == 1)
  {
    result = 0;
    *a3 = v7;
  }
  else if ((*(unsigned int (**)(_QWORD, uint64_t))(a1 + 48))(*(_QWORD *)(a1 + 56), a2))
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t call_zopen64(uint64_t a1)
{
  uint64_t (*v1)(_QWORD);

  v1 = *(uint64_t (**)(_QWORD))a1;
  if (!*(_QWORD *)a1)
    v1 = *(uint64_t (**)(_QWORD))(a1 + 64);
  return v1(*(_QWORD *)(a1 + 56));
}

uint64_t call_zseek64(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD);

  v1 = (uint64_t (*)(_QWORD))a1[4];
  if (!v1)
    v1 = (uint64_t (*)(_QWORD))a1[10];
  return v1(a1[7]);
}

uint64_t call_ztell64(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 56);
  if (v2)
    return (*(uint64_t (**)(uint64_t))(a1 + 24))(v3);
  result = (*(uint64_t (**)(uint64_t))(a1 + 72))(v3);
  if (result == 0xFFFFFFFFLL)
    return -1;
  return result;
}

size_t fread_file_func(int a1, FILE *__stream, void *__ptr, size_t __nitems)
{
  return fread(__ptr, 1uLL, __nitems, __stream);
}

size_t fwrite_file_func(int a1, FILE *__stream, void *__ptr, size_t __nitems)
{
  return fwrite(__ptr, 1uLL, __nitems, __stream);
}

uint64_t fclose_file_func(int a1, FILE *a2)
{
  return fclose(a2);
}

uint64_t ferror_file_func(int a1, FILE *a2)
{
  return ferror(a2);
}

FILE *(**fill_fopen64_filefunc(FILE *(**result)(int a1, char *__filename, char a3)))(int a1, char *__filename, char a3)
{
  *result = fopen64_file_func;
  result[1] = (FILE *(*)(int, char *, char))fread_file_func;
  result[2] = (FILE *(*)(int, char *, char))fwrite_file_func;
  result[3] = (FILE *(*)(int, char *, char))ftell64_file_func;
  result[4] = (FILE *(*)(int, char *, char))fseek64_file_func;
  result[5] = (FILE *(*)(int, char *, char))fclose_file_func;
  result[6] = (FILE *(*)(int, char *, char))ferror_file_func;
  result[7] = 0;
  return result;
}

FILE *fopen64_file_func(int a1, char *__filename, char a3)
{
  int v3;
  const char *v4;
  const char *v5;
  int v6;
  char v7;
  const char *v8;

  v3 = a3 & 3;
  v4 = "r+b";
  v5 = "wb";
  if ((a3 & 8) == 0)
    v5 = 0;
  if ((a3 & 4) != 0)
    LOBYTE(v6) = 1;
  else
    v6 = (a3 & 8) >> 3;
  if ((a3 & 4) == 0)
    v4 = v5;
  if (v3 == 1)
    v7 = 1;
  else
    v7 = v6;
  if (v3 == 1)
    v8 = "rb";
  else
    v8 = v4;
  if (__filename && (v7 & 1) != 0)
    return fopen(__filename, v8);
  else
    return 0;
}

off_t ftell64_file_func(int a1, FILE *__stream)
{
  return ftello(__stream);
}

uint64_t fseek64_file_func(int a1, FILE *__stream, off_t a3, unsigned int __whence)
{
  if (__whence > 2)
    return -1;
  if (fseeko(__stream, a3, __whence))
    return -1;
  return 0;
}

size_t fread_mem_func(int a1, _QWORD *a2, void *__dst, size_t a4)
{
  uint64_t v5;
  size_t v6;

  v5 = a2[3];
  if (a2[1] - v5 >= a4)
    v6 = a4;
  else
    v6 = a2[1] - v5;
  memcpy(__dst, (const void *)(*a2 + v5), v6);
  a2[3] += v6;
  return v6;
}

size_t fwrite_mem_func(int a1, _QWORD *a2, void *__src, size_t a4)
{
  uint64_t v5;
  size_t v6;
  size_t v7;
  size_t v8;

  v5 = a2[3];
  if (a2[1] - v5 >= a4)
    v6 = a4;
  else
    v6 = a2[1] - v5;
  memcpy((void *)(*a2 + v5), __src, v6);
  v7 = a2[2];
  v8 = a2[3] + v6;
  a2[3] = v8;
  if (v8 > v7)
    a2[2] = v8;
  return v6;
}

uint64_t ftell_mem_func(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 24);
}

uint64_t fseek_mem_func(uint64_t a1, _QWORD *a2, unint64_t a3, int a4)
{
  unint64_t v4;
  _QWORD *v6;
  uint64_t result;
  unint64_t v8;

  v4 = a3;
  if (a4)
  {
    if (a4 == 2)
    {
      v6 = a2 + 2;
    }
    else
    {
      if (a4 != 1)
        return -1;
      v6 = a2 + 3;
    }
    v4 = *v6 + a3;
  }
  if (v4 > a2[1])
    return 1;
  v8 = a2[2];
  if (v4 > v8)
    bzero((void *)(*a2 + v8), v4 - v8);
  result = 0;
  a2[3] = v4;
  return result;
}

uint64_t fclose_mem_func(int a1, void *a2)
{
  free(a2);
  return 0;
}

uint64_t ferror_mem_func()
{
  return 0;
}

_QWORD *fill_memory_filefunc64_32(_QWORD *result)
{
  *result = fopen64_mem_func;
  result[1] = fread_mem_func;
  result[2] = fwrite_mem_func;
  result[8] = fopen_mem_func;
  result[9] = ftell_mem_func;
  result[10] = fseek_mem_func;
  result[4] = 0;
  result[5] = fclose_mem_func;
  result[6] = ferror_mem_func;
  result[7] = 0;
  return result;
}

_QWORD *fopen64_mem_func(uint64_t a1, const char *a2, char a3)
{
  _QWORD *v5;
  uint64_t v6;
  _BYTE *v7;
  BOOL v8;
  uint64_t v10;
  _BYTE *v11;

  v5 = malloc_type_malloc(0x20uLL, 0x1010040FAA616C6uLL);
  if (v5)
  {
    v10 = 0;
    v11 = 0;
    if (sscanf(a2, "%lx+%lx", &v11, &v10) == 2
      && (v6 = v10, v7 = v11, *v5 = v11, v5[1] = v6, *v7 == 80)
      && (v7[1] == 75 ? (v8 = v6 == 0) : (v8 = 1), !v8))
    {
      if ((a3 & 8) != 0)
        v6 = 0;
      v5[2] = v6;
      v5[3] = 0;
    }
    else
    {
      free(v5);
      return 0;
    }
  }
  return v5;
}

void OFDTextObject::OFDTextObject(OFDTextObject *this, const __CFDictionary *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  const __CFDictionary *Value;
  const __CFDictionary *ObjectForKey;
  const __CFString *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  _BYTE v13[24];
  _QWORD v14[3];
  _QWORD v15[3];

  v4 = OFDObject::OFDObject((uint64_t)this, a2, 2);
  *(_QWORD *)v4 = &off_1E1BAD548;
  *(_OWORD *)(v4 + 232) = 0u;
  v5 = v4 + 232;
  *(_OWORD *)(v4 + 248) = 0u;
  v6 = (uint64_t *)(v4 + 256);
  v7 = (uint64_t *)(v4 + 280);
  *(_QWORD *)(v4 + 296) = 0;
  *(_OWORD *)(v4 + 264) = 0u;
  *(_OWORD *)(v4 + 280) = 0u;
  memset(v15, 0, sizeof(v15));
  IIODictionary::IIODictionary((IIODictionary *)v15, a2);
  Value = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("TextCode"));
  memset(v14, 0, sizeof(v14));
  IIODictionary::IIODictionary((IIODictionary *)v14, Value);
  *((_DWORD *)this + 48) = IIODictionary::getUint32ForKey((IIODictionary *)v15, CFSTR("Font"));
  *((double *)this + 25) = IIODictionary::getDoubleForKey((IIODictionary *)v15, CFSTR("Size"));
  *((double *)this + 27) = IIODictionary::getDoubleForKey((IIODictionary *)v14, CFSTR("X"));
  *((double *)this + 28) = IIODictionary::getDoubleForKey((IIODictionary *)v14, CFSTR("Y"));
  ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v14, CFSTR("_text"));
  if (ObjectForKey)
  {
    IIOString::IIOString((IIOString *)v13, ObjectForKey);
    v10 = IIOString::utf8String((IIOString *)v13);
  }
  else
  {
    v10 = (const __CFString *)"";
  }
  MEMORY[0x18D761A14](v5, v10);
  if (ObjectForKey)
    IIOString::~IIOString((IIOString *)v13);
  v11 = IIODictionary::getObjectForKey((IIODictionary *)v14, CFSTR("DeltaX"));
  if (v11)
    OFDParseTextDelta(v11, v6);
  v12 = IIODictionary::getObjectForKey((IIODictionary *)v14, CFSTR("DeltaY"));
  if (v12)
    OFDParseTextDelta(v12, v7);
  *((_QWORD *)this + 26) = 0;
  IIODictionary::~IIODictionary((IIODictionary *)v14);
  IIODictionary::~IIODictionary((IIODictionary *)v15);
}

void sub_1881D9748(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  void **v3;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  va_list va;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;
  uint64_t v13;
  uint64_t v14;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v11 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  IIOString::~IIOString((IIOString *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va2);
  if (*(char *)(v2 + 255) < 0)
    operator delete(*v3);
  _cg_jpeg_mem_term(v2, v5, v6);
  _Unwind_Resume(a1);
}

void OFDTextObject::~OFDTextObject(OFDTextObject *this)
{
  CGColor *v2;
  uint64_t v3;
  const char *v4;
  void **v5;

  *(_QWORD *)this = &off_1E1BAD548;
  v2 = (CGColor *)*((_QWORD *)this + 26);
  if (v2)
    CGColorRelease(v2);
  v5 = (void **)((char *)this + 280);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)((char *)this + 256);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
  if (*((char *)this + 255) < 0)
    operator delete(*((void **)this + 29));
  _cg_jpeg_mem_term(this, v3, v4);
}

{
  OFDTextObject::~OFDTextObject(this);
  JUMPOUT(0x18D761C30);
}

CFAttributedStringRef OFDTextObject::makeAttrStringRef(const void **this, const char *a2, const __CTFont *a3)
{
  CFAttributedStringRef v6;
  _BYTE v8[16];
  CFStringRef str;
  uint64_t v10;
  CFDictionaryRef attributes;
  uint64_t v12;

  v10 = 0;
  attributes = 0;
  v12 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v10);
  IIODictionary::setObjectForKey((IIODictionary *)&v10, a3, *(const __CFString **)gIIO_kCTFontAttributeName);
  IIODictionary::setObjectForKey((IIODictionary *)&v10, this[26], *(const __CFString **)gIIO_kCTForegroundColorAttributeName);
  IIOString::IIOString((IIOString *)v8, a2);
  v6 = CFAttributedStringCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], str, attributes);
  IIOString::~IIOString((IIOString *)v8);
  IIODictionary::~IIODictionary((IIODictionary *)&v10);
  return v6;
}

void sub_1881D9934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IIOString::~IIOString((IIOString *)&a9);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Unwind_Resume(a1);
}

void OFDTextObject::drawInContext(OFDTextObject *this, CGContext *a2, CGRect a3, OFDPage *a4)
{
  IIODictionary **v5;
  const __CTFont *Font;
  __int128 v8;
  const char *v9;
  double v10;
  double v11;
  const __CFAttributedString *AttrStringRef;
  uint64_t v13;
  unint64_t v14;
  const __CFAllocator *v15;
  CGFloat v16;
  CFAttributedStringRef v17;
  CFAttributedStringRef v18;
  uint64_t v19;
  const void *v20;
  uint64_t v21;
  const void *v22;
  double v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  CGColor *v30;
  uint64_t v31;
  const void *v32;
  CGContext *v33;
  _QWORD v34[2];
  CGAffineTransform transform;
  CFRange v36;

  v5 = (IIODictionary **)*((_QWORD *)a4 + 2);
  if (!v5)
    return;
  Font = (const __CTFont *)OFDDocument::createFont(v5, *((unsigned int *)this + 48), *((double *)this + 25));
  CGContextSaveGState(a2);
  *((_QWORD *)this + 23) = 0x3FF0000000000000;
  *((_QWORD *)this + 18) = 0x3FF0000000000000;
  *((_QWORD *)this + 26) = OFDCreateCGColor((uint64_t)this + 152);
  if (*((_DWORD *)this + 38) == 1)
    CGContextSetRGBFillColor(a2, *((CGFloat *)this + 20), *((CGFloat *)this + 21), *((CGFloat *)this + 22), 1.0);
  if (*((_DWORD *)this + 28) == 1)
    CGContextSetRGBFillColor(a2, *((CGFloat *)this + 15), *((CGFloat *)this + 16), *((CGFloat *)this + 17), 1.0);
  v8 = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)&transform.a = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)&transform.c = v8;
  *(_OWORD *)&transform.tx = *(_OWORD *)((char *)this + 56);
  CGContextConcatCTM(a2, &transform);
  CGContextScaleCTM(a2, 1.0, -1.0);
  v9 = (char *)this + 232;
  if (*((char *)this + 255) < 0)
    v9 = *(const char **)v9;
  v10 = *MEMORY[0x1E0C9D538] + *((double *)this + 27);
  v11 = *(double *)(MEMORY[0x1E0C9D538] + 8) - *((double *)this + 28);
  AttrStringRef = OFDTextObject::makeAttrStringRef((const void **)this, v9, Font);
  CFRelease(Font);
  if (*((_QWORD *)this + 33) == *((_QWORD *)this + 32) && *((_QWORD *)this + 36) == *((_QWORD *)this + 35))
  {
    CGContextSetTextPosition(a2, v10, v11);
    v31 = gFunc_CTLineCreateWithAttributedString(AttrStringRef);
    if (v31)
    {
      v32 = (const void *)v31;
      gFunc_CTLineDraw(v31, a2);
      CFRelease(v32);
    }
    CGContextFlush(a2);
    if (!AttrStringRef)
      goto LABEL_32;
  }
  else
  {
    if (CFAttributedStringGetLength(AttrStringRef) >= 1)
    {
      v13 = 0;
      v14 = 0;
      v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v16 = v10;
      v33 = a2;
      do
      {
        v36.location = v14;
        v36.length = 1;
        v17 = CFAttributedStringCreateWithSubstring(v15, AttrStringRef, v36);
        if (v17)
        {
          v18 = v17;
          v19 = gFunc_CTLineCreateWithAttributedString(v17);
          if (v19)
          {
            v20 = (const void *)v19;
            CGContextSetTextPosition(a2, v16, v11);
            gFunc_CTLineDraw(v20, a2);
            v21 = gFunc_CTFramesetterCreateWithAttributedString(v18);
            if (v21)
            {
              v22 = (const void *)v21;
              v34[0] = 0;
              v34[1] = 0;
              gFunc_CTFramesetterSuggestFrameSizeWithConstraints(v21, 0, 1, 0, v34, 1.79769313e308, 1.79769313e308);
              v24 = *((_QWORD *)this + 32);
              v25 = *((_QWORD *)this + 33);
              if (v25 != v24 && 0xAAAAAAAAAAAAAAABLL * ((v25 - v24) >> 3) > v14)
              {
                v26 = (const char *)(v24 + v13);
                if (*(char *)(v24 + v13 + 23) < 0)
                  v26 = *(const char **)v26;
                v23 = atof(v26);
              }
              v16 = v16 + v23;
              v27 = *((_QWORD *)this + 35);
              v28 = *((_QWORD *)this + 36) - v27;
              if (v28 && 0xAAAAAAAAAAAAAAABLL * (v28 >> 3) > v14)
              {
                v29 = (const char *)(v27 + v13);
                if (*(char *)(v27 + v13 + 23) < 0)
                  v29 = *(const char **)v29;
                v11 = v11 - atof(v29);
                if (v25 == v24)
                  v16 = v10;
              }
              a2 = v33;
              CFRelease(v22);
            }
            CFRelease(v20);
          }
          CFRelease(v18);
        }
        ++v14;
        v13 += 24;
      }
      while (CFAttributedStringGetLength(AttrStringRef) > (uint64_t)v14);
    }
    if (!AttrStringRef)
      goto LABEL_32;
  }
  CFRelease(AttrStringRef);
LABEL_32:
  v30 = (CGColor *)*((_QWORD *)this + 26);
  if (v30)
  {
    CGColorRelease(v30);
    *((_QWORD *)this + 26) = 0;
  }
  CGContextRestoreGState(a2);
}

void OFDImageObject::OFDImageObject(OFDImageObject *this, const __CFDictionary *a2)
{
  _QWORD v4[3];

  *(_QWORD *)OFDObject::OFDObject((uint64_t)this, a2, 3) = &off_1E1BAFB28;
  memset(v4, 0, sizeof(v4));
  IIODictionary::IIODictionary((IIODictionary *)v4, a2);
  *((_QWORD *)this + 24) = IIODictionary::getUint64ForKey((IIODictionary *)v4, CFSTR("ResourceID"));
  *((double *)this + 3) = *((double *)this + 3) * (1.0 / *((double *)this + 3));
  *((double *)this + 6) = *((double *)this + 6) * (1.0 / *((double *)this + 6));
  IIODictionary::~IIODictionary((IIODictionary *)v4);
}

void sub_1881D9D54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  const char *v5;
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _cg_jpeg_mem_term(v2, v4, v5);
  _Unwind_Resume(a1);
}

void OFDImageObject::~OFDImageObject(OFDImageObject *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void OFDImageObject::drawInContext(OFDImageObject *this, CGContextRef c, CGRect a3, OFDContainer ***a4)
{
  __int128 v7;
  CFStringRef v8;
  OFDContainer **v9;
  const char *v10;
  const __CFData *v11;
  const __CFData *v12;
  CGImageSource *v13;
  CGImageSource *v14;
  CGImage *ImageAtIndex;
  CGFloat v16;
  double v17;
  CGFloat v18;
  double v19;
  CGDataProvider *v20;
  uint64_t (*v21)(CGDataProvider *, uint64_t, CFIndex);
  CFIndex Length;
  void *v23;
  CGDataProvider *v24;
  CGColorSpace *v25;
  CGImage *v26;
  CGFloat v27;
  double v28;
  CGFloat v29;
  double v30;
  CGFloat v31;
  CGFloat v32;
  CGFloat v33;
  CGFloat v34;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  _QWORD v39[3];
  CGAffineTransform transform;
  CGRect v41;
  CGRect v42;
  CGRect v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;

  CGContextSaveGState(c);
  v7 = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)&transform.a = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)&transform.c = v7;
  *(_OWORD *)&transform.tx = *(_OWORD *)((char *)this + 56);
  CGContextConcatCTM(c, &transform);
  v8 = OFDPage::copyResourcePath((OFDPage *)a4, *((_DWORD *)this + 48), CFSTR("Image"));
  memset(v39, 0, sizeof(v39));
  IIOString::IIOString((IIOString *)v39, v8);
  if (v8)
    CFRelease(v8);
  v9 = a4[2];
  v10 = (const char *)IIOString::utf8String((IIOString *)v39);
  v11 = OFDDocument::copyFileContent(v9, v10);
  v12 = v11;
  if (v11)
  {
    v13 = CGImageSourceCreateWithData(v11, 0);
    v14 = v13;
    if (v13)
    {
      ImageAtIndex = CGImageSourceCreateImageAtIndex(v13, 0, 0);
      if (ImageAtIndex)
      {
        v16 = *((double *)this + 11);
        v17 = *((double *)this + 12);
        v18 = *MEMORY[0x1E0C9D538];
        v19 = *(double *)(MEMORY[0x1E0C9D538] + 8);
        CGContextTranslateCTM(c, *MEMORY[0x1E0C9D538], v17 + v19);
        CGContextScaleCTM(c, 1.0, -1.0);
        CGContextSetInterpolationQuality(c, kCGInterpolationNone);
        v41.origin.x = v18;
        v41.origin.y = v19;
        v41.size.width = v16;
        v41.size.height = v17;
        CGContextDrawImage(c, v41, ImageAtIndex);
        CGImageRelease(ImageAtIndex);
      }
      else
      {
        if (OFDImageObject::drawInContext(CGContext *,CGRect,OFDPage *)::onceToken != -1)
          dispatch_once(&OFDImageObject::drawInContext(CGContext *,CGRect,OFDPage *)::onceToken, &__block_literal_global_49);
        if (g_CGPDFSourceCreateForJBIG2)
        {
          v20 = CGDataProviderCreateWithCFData(v12);
          if (v20)
          {
            v21 = (uint64_t (*)(CGDataProvider *, uint64_t, CFIndex))g_CGPDFSourceCreateForJBIG2;
            Length = CFDataGetLength(v12);
            if (v21(v20, 13, Length - 13))
            {
              v23 = malloc_type_malloc(0x514uLL, 0xF023D34DuLL);
              if (CGPDFSourceRead() == 1300)
              {
                v24 = CGDataProviderCreateWithData(0, v23, 0x514uLL, (CGDataProviderReleaseDataCallback)DPReleaseDataCallback);
                if (v24)
                {
                  v25 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
                  v26 = CGImageCreate(0x64uLL, 0x64uLL, 1uLL, 1uLL, 0xDuLL, v25, 0, v24, 0, 0, kCGRenderingIntentDefault);
                  CGColorSpaceRelease(v25);
                  CGDataProviderRelease(v24);
                  if (v26)
                  {
                    v27 = *((double *)this + 11);
                    v28 = *((double *)this + 12);
                    v29 = *MEMORY[0x1E0C9D538];
                    v30 = *(double *)(MEMORY[0x1E0C9D538] + 8);
                    CGContextTranslateCTM(c, *MEMORY[0x1E0C9D538], v28 + v30);
                    CGContextScaleCTM(c, 1.0, -1.0);
                    CGContextSetInterpolationQuality(c, kCGInterpolationNone);
                    v42.origin.x = v29;
                    v42.origin.y = v30;
                    v42.size.width = v27;
                    v42.size.height = v28;
                    CGContextDrawImage(c, v42, v26);
                    CGImageRelease(v26);
                  }
                }
              }
              CGPDFSourceRelease();
            }
            CGDataProviderRelease(v20);
          }
        }
        else
        {
          v31 = *((double *)this + 11);
          v32 = *((double *)this + 12);
          v33 = *MEMORY[0x1E0C9D538];
          v34 = *(double *)(MEMORY[0x1E0C9D538] + 8);
          CGContextSetRGBFillColor(c, 0.8, 0.8, 0.8, 0.8);
          v43.origin.x = v33;
          v43.origin.y = v34;
          v43.size.width = v31;
          v43.size.height = v32;
          CGContextFillRect(c, v43);
          CGContextSetLineWidth(c, 0.2);
          v44.origin.x = v33;
          v44.origin.y = v34;
          v44.size.width = v31;
          v44.size.height = v32;
          v45 = CGRectInset(v44, 1.0, 1.0);
          x = v45.origin.x;
          y = v45.origin.y;
          width = v45.size.width;
          height = v45.size.height;
          CGContextSetRGBStrokeColor(c, 0.2, 0.2, 0.2, 0.8);
          v46.origin.x = x;
          v46.origin.y = y;
          v46.size.width = width;
          v46.size.height = height;
          CGContextStrokeRect(c, v46);
        }
      }
      CFRelease(v14);
    }
    CFRelease(v12);
  }
  CGContextRestoreGState(c);
  IIOString::~IIOString((IIOString *)v39);
}

void sub_1881DA178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void DPReleaseDataCallback(void *a1, void *a2)
{
  if (a2)
    free(a2);
}

void sub_1881DA3A0(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

IIODictionary *XMLDictionaryCreateWithData(const __CFData *a1)
{
  const __CFDictionary *v1;
  IIODictionary *v2;
  const __CFDictionary *v3;
  uint64_t v5;

  v5 = 0;
  v1 = +[IIO_CXMLParser dictionaryForXMLData:error:](IIO_CXMLParser, "dictionaryForXMLData:error:", a1, &v5);
  v2 = 0;
  if (!v5)
  {
    v3 = v1;
    v2 = (IIODictionary *)operator new();
    IIODictionary::IIODictionary(v2, v3);
  }
  return v2;
}

void sub_1881DA6A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t ASN1Item::readTag(uint64_t a1, _BYTE *a2, unsigned int a3, uint64_t a4)
{
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t result;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;

  if (!a3)
    return 0;
  *(_BYTE *)(a4 + 1) = *a2 & 0xC0;
  *(_BYTE *)a4 = (*a2 & 0x20) != 0;
  v4 = *a2 & 0x1F;
  if (v4 == 31)
  {
    *(_BYTE *)(a4 + 2) = 0;
    if (a3 >= 3)
      v5 = 3;
    else
      v5 = a3;
    if (v5 < 2)
      return 0;
    v6 = 0;
    v7 = 1;
    while (1)
    {
      v8 = a2[v7] & 0x7F | (v6 << 7);
      *(_BYTE *)(a4 + 2) = a2[v7] & 0x7F | ((_BYTE)v6 << 7);
      if (((char)a2[v7] & 0x80000000) == 0)
        break;
      ++v7;
      v6 = v8;
      if (v5 == v7)
        return 0;
    }
    v10 = v7 + 1;
  }
  else
  {
    *(_BYTE *)(a4 + 2) = v4;
    v10 = 1;
  }
  if (v10 >= a3)
    return 0;
  v11 = a2[v10];
  if (((char)a2[v10] & 0x80000000) == 0)
  {
    *(_DWORD *)(a4 + 4) = v11;
    goto LABEL_16;
  }
  result = 0;
  if (v11 != 128 && v11 != 255)
  {
    v14 = v11 & 0x7F;
    if (v14 > 4 || v14 + v10 >= a3)
      return 0;
    *(_DWORD *)(a4 + 4) = 0;
    v11 = 0;
    if (v14)
    {
      v12 = v10 + 1;
      do
      {
        v11 = a2[v12] | (v11 << 8);
        *(_DWORD *)(a4 + 4) = v11;
        ++v12;
        --v14;
      }
      while (v14);
      if (v11 > a3)
        return 0;
      goto LABEL_17;
    }
LABEL_16:
    LODWORD(v12) = v10 + 1;
LABEL_17:
    *(_QWORD *)(a4 + 8) = &a2[v12];
    v13 = v11 + v12;
    if (v13 <= a3)
    {
      *(_DWORD *)(a4 + 16) = v13;
      return 1;
    }
    return 0;
  }
  return result;
}

uint64_t ASN1Item::getInteger(uint64_t a1, uint64_t a2, int *a3)
{
  char *v3;
  int v4;
  unint64_t v5;
  int v6;

  if (*(_BYTE *)a2 || *(_BYTE *)(a2 + 1) || *(_BYTE *)(a2 + 2) != 2)
    return 0;
  if ((*(_DWORD *)(a2 + 4) - 5) >= 0xFFFFFFFC)
  {
    v3 = *(char **)(a2 + 8);
    v4 = *v3 >> 7;
    *a3 = v4;
    if (*(_DWORD *)(a2 + 4))
    {
      v5 = 0;
      do
      {
        *a3 = v4 << 8;
        v6 = v3[v5] | (v4 << 8);
        *a3 = v6;
        ++v5;
        v4 = v6;
      }
      while (v5 < *(unsigned int *)(a2 + 4));
    }
  }
  return 1;
}

uint64_t ASN1Item::getString(uint64_t a1, uint64_t a2, std::string *a3)
{
  unint64_t v5;

  MEMORY[0x18D761A14](a3, "");
  if (*(_DWORD *)(a2 + 4))
  {
    v5 = 0;
    do
      std::string::push_back(a3, *(_BYTE *)(*(_QWORD *)(a2 + 8) + v5++));
    while (v5 < *(unsigned int *)(a2 + 4));
  }
  return 1;
}

uint64_t ASN1Item::getObjectIdentifier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BYTE *v3;
  unsigned int v6;
  char *p_dst;
  unsigned int v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t i;
  int v13;
  uint64_t v14;
  char __str[8];
  int v17;
  char __dst;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[31];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  memset(v25, 0, sizeof(v25));
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v3 = *(_BYTE **)(a2 + 8);
  __dst = 0;
  if (*(_DWORD *)(a2 + 4))
  {
    v17 = 0;
    *(_QWORD *)__str = 0;
    v6 = snprintf(__str, 0xCuLL, "%d.%d", *v3 / 0x28u, *v3 % 0x28u);
    p_dst = &__dst;
    if (v6 > 0x7F)
    {
      v9 = 127;
    }
    else
    {
      v8 = v6;
      strcpy(&__dst, __str);
      p_dst = &__dst + v8;
      v9 = 127 - v8;
    }
    v10 = *(unsigned int *)(a2 + 4);
    if (v10 >= 2)
    {
      v11 = 0;
      for (i = 1; i < v10; ++i)
      {
        if ((v3[i] & 0x80) != 0)
        {
          v11 = v3[i] & 0x7F | (v11 << 7);
        }
        else
        {
          v13 = snprintf(__str, 0xCuLL, ".%d", v3[i] & 0x7F | (v11 << 7));
          if (v9 >= (unint64_t)v13)
          {
            v14 = v13;
            strcpy(p_dst, __str);
            p_dst += v14;
            v9 -= v14;
          }
          if (v9 < 1)
            break;
          v11 = 0;
          v10 = *(unsigned int *)(a2 + 4);
        }
      }
    }
    MEMORY[0x18D761A14](a3, &__dst);
  }
  return 1;
}

BOOL ASN1Item::getDate(int a1, uint64_t a2, std::string *this)
{
  unsigned int v3;

  v3 = *(_DWORD *)(a2 + 4);
  if (v3 >= 0xD)
  {
    std::string::push_back(this, **(_BYTE **)(a2 + 8));
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 1));
    std::string::push_back(this, 47);
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 2));
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 3));
    std::string::push_back(this, 47);
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 4));
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 5));
    std::string::push_back(this, 32);
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 6));
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 7));
    std::string::push_back(this, 58);
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 8));
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 9));
    std::string::push_back(this, 58);
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 10));
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 11));
    std::string::push_back(this, 32);
    std::string::push_back(this, *(_BYTE *)(*(_QWORD *)(a2 + 8) + 12));
  }
  return v3 > 0xC;
}

void _SES_Signature::~_SES_Signature(_SES_Signature *this)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;

  *(_QWORD *)this = &off_1E1BAFFC0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)this + 9);
  if (v4)
    free(v4);
  v5 = (void *)*((_QWORD *)this + 11);
  if (v5)
    free(v5);
  if (*((char *)this + 71) < 0)
    operator delete(*((void **)this + 6));
}

{
  _SES_Signature::~_SES_Signature(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SES_Signature::parse(_SES_Signature *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  BOOL v8;
  uint64_t v9;
  _OWORD *v10;
  unsigned __int8 *v11;
  int v12;
  int v13;
  int v14;
  size_t v15;
  void *v16;
  void *v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  uint64_t ObjectIdentifier;
  unsigned __int8 *v22;
  int v23;
  int v24;
  size_t v25;
  void *v26;
  void *v27;
  int v28;
  size_t v29;
  void *v30;
  size_t size;
  void *__src;
  uint64_t v33;

  size = 0;
  __src = 0;
  v33 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  gOffset = (uint64_t)a2;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)&size);
  result = 0;
  if (Tag && BYTE2(size) == 16)
  {
    if (ASN1Item::readTag(0, __src, HIDWORD(size), (uint64_t)&size))
      v8 = BYTE2(size) == 16;
    else
      v8 = 0;
    if (!v8)
      return 0;
    v9 = v33;
    v10 = (_OWORD *)operator new();
    *(_QWORD *)v10 = &off_1E1BB30D0;
    *(_OWORD *)((char *)v10 + 20) = 0u;
    *(_OWORD *)((char *)v10 + 36) = 0u;
    v10[3] = 0u;
    *(_OWORD *)((char *)v10 + 72) = 0u;
    *(_OWORD *)((char *)v10 + 88) = 0u;
    *((_QWORD *)this + 3) = v10;
    result = _TBS_Sign::parse((_TBS_Sign *)v10, (unsigned __int8 *)__src, HIDWORD(size));
    if ((_DWORD)result)
    {
      v11 = &a2[v9 + 4];
      v12 = a3 - v9;
      v13 = a3 - v9 - 4;
      v14 = ASN1Item::readTag(result, v11, v12 - 4, (uint64_t)&size);
      result = 0;
      if (v14)
      {
        if (BYTE2(size) == 4)
        {
          v15 = HIDWORD(size);
          v16 = malloc_type_malloc(HIDWORD(size), 0x4B106C32uLL);
          *((_QWORD *)this + 4) = v16;
          v17 = memcpy(v16, __src, v15);
          *((_DWORD *)this + 10) = v15;
          v18 = &v11[v33];
          v19 = v13 - v33;
          v20 = ASN1Item::readTag((uint64_t)v17, v18, v13 - (int)v33, (uint64_t)&size);
          result = 0;
          if (v20)
          {
            if (BYTE2(size) == 6)
            {
              ObjectIdentifier = ASN1Item::getObjectIdentifier(0, (uint64_t)&size, (uint64_t)this + 48);
              v22 = &v18[v33];
              v23 = v19 - v33;
              v24 = ASN1Item::readTag(ObjectIdentifier, v22, v19 - (int)v33, (uint64_t)&size);
              result = 0;
              if (v24)
              {
                if (BYTE2(size) == 3)
                {
                  v25 = HIDWORD(size);
                  v26 = malloc_type_malloc(HIDWORD(size), 0x46100A1BuLL);
                  *((_QWORD *)this + 9) = v26;
                  v27 = memcpy(v26, __src, v25);
                  *((_DWORD *)this + 20) = v25;
                  if (v23 == (_DWORD)v33)
                    return 1;
                  v28 = ASN1Item::readTag((uint64_t)v27, &v22[v33], v23 - (int)v33, (uint64_t)&size);
                  result = 0;
                  if (v28 && BYTE2(size) == 3)
                  {
                    v29 = HIDWORD(size);
                    v30 = malloc_type_malloc(HIDWORD(size), 0x46100A1BuLL);
                    *((_QWORD *)this + 11) = v30;
                    memcpy(v30, __src, v29);
                    *((_DWORD *)this + 24) = v29;
                    return 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void _TBS_Sign::~_TBS_Sign(_TBS_Sign *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E1BB30D0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 7);
  if (v3)
    free(v3);
  v4 = *((_QWORD *)this + 12);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  if (*((char *)this + 95) < 0)
    operator delete(*((void **)this + 9));
  if (*((char *)this + 55) < 0)
    operator delete(*((void **)this + 4));
}

{
  _TBS_Sign::~_TBS_Sign(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _TBS_Sign::parse(_TBS_Sign *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  uint64_t Integer;
  unsigned __int8 *v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned int v15;
  int v16;
  _BOOL8 Date;
  unsigned __int8 *v18;
  int v19;
  int v20;
  size_t v21;
  void *v22;
  void *v23;
  unsigned __int8 *v24;
  unsigned int v25;
  int v26;
  uint64_t String;
  size_t size;
  void *__src;
  uint64_t v30;

  size = 0;
  __src = 0;
  v30 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)&size);
  result = 0;
  if (Tag && BYTE2(size) == 2)
  {
    Integer = ASN1Item::getInteger(0, (uint64_t)&size, (int *)this + 5);
    if (a3 < v30)
    {
      return 0;
    }
    else
    {
      v9 = &a2[v30];
      v10 = a3 - v30;
      v11 = ASN1Item::readTag(Integer, v9, v10, (uint64_t)&size);
      result = 0;
      if (v11)
      {
        if (BYTE2(size) == 16)
        {
          v12 = v30;
          v13 = operator new();
          *(_QWORD *)v13 = &off_1E1BB2AD8;
          *(_QWORD *)(v13 + 24) = 0;
          *(_QWORD *)(v13 + 32) = 0;
          *(_DWORD *)(v13 + 40) = 0;
          *(_OWORD *)(v13 + 48) = 0u;
          *(_OWORD *)(v13 + 64) = 0u;
          *(_DWORD *)(v13 + 80) = 0;
          *((_QWORD *)this + 3) = v13;
          result = _SESeal::parse((_SESeal *)v13, (unsigned __int8 *)__src, HIDWORD(size));
          if ((_DWORD)result)
          {
            v14 = &v9[v12];
            v15 = v10 - v12;
            v16 = ASN1Item::readTag(result, v14, v15, (uint64_t)&size);
            result = 0;
            if (v16)
            {
              if (BYTE2(size) == 24)
              {
                Date = ASN1Item::getDate(0, (uint64_t)&size, (std::string *)((char *)this + 32));
                v18 = &v14[v30];
                v19 = v15 - v30;
                v20 = ASN1Item::readTag(Date, v18, v15 - v30, (uint64_t)&size);
                result = 0;
                if (v20)
                {
                  if (BYTE2(size) == 3)
                  {
                    v21 = HIDWORD(size);
                    v22 = malloc_type_malloc(HIDWORD(size), 0x46100A1BuLL);
                    *((_QWORD *)this + 7) = v22;
                    v23 = memcpy(v22, __src, v21);
                    *((_DWORD *)this + 16) = v21;
                    v24 = &v18[v30];
                    v25 = v19 - v30;
                    v26 = ASN1Item::readTag((uint64_t)v23, v24, v25, (uint64_t)&size);
                    result = 0;
                    if (v26)
                    {
                      if (BYTE2(size) == 22)
                      {
                        String = ASN1Item::getString(0, (uint64_t)&size, (std::string *)this + 3);
                        if (v25 == (_DWORD)v30)
                        {
                          return 1;
                        }
                        else
                        {
                          LODWORD(result) = ASN1Item::readTag(String, &v24[v30], v25 - v30, (uint64_t)&size);
                          if (BYTE2(size) == 16)
                            return result;
                          else
                            return 0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void _SESeal::~_SESeal(_SESeal *this)
{
  uint64_t v2;
  void *v3;
  void *v4;

  *(_QWORD *)this = &off_1E1BB2AD8;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)this + 9);
  if (v4)
    free(v4);
  if (*((char *)this + 71) < 0)
    operator delete(*((void **)this + 6));
}

{
  _SESeal::~_SESeal(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SESeal::parse(_SESeal *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned int v11;
  int v12;
  size_t v13;
  void *v14;
  void *v15;
  unsigned __int8 *v16;
  unsigned int v17;
  int v18;
  uint64_t ObjectIdentifier;
  int v20;
  size_t v21;
  void *v22;
  size_t size;
  void *__src;
  uint64_t v25;

  size = 0;
  __src = 0;
  v25 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)&size);
  result = 0;
  if (Tag)
  {
    if (BYTE2(size) == 16)
    {
      v8 = v25;
      v9 = operator new();
      *(_QWORD *)v9 = &off_1E1BADD58;
      *(_OWORD *)(v9 + 24) = 0u;
      *(_OWORD *)(v9 + 40) = 0u;
      *(_OWORD *)(v9 + 56) = 0u;
      *(_QWORD *)(v9 + 72) = 0;
      *((_QWORD *)this + 3) = v9;
      result = _SES_SealInfo::parse((_SES_SealInfo *)v9, (unsigned __int8 *)__src, HIDWORD(size));
      if ((_DWORD)result)
      {
        v10 = &a2[v8];
        v11 = a3 - v8;
        v12 = ASN1Item::readTag(result, v10, v11, (uint64_t)&size);
        result = 0;
        if (v12)
        {
          if (BYTE2(size) == 4)
          {
            v13 = HIDWORD(size);
            v14 = malloc_type_malloc(HIDWORD(size), 0x4B106C32uLL);
            *((_QWORD *)this + 4) = v14;
            v15 = memcpy(v14, __src, v13);
            *((_DWORD *)this + 10) = v13;
            v16 = &v10[v25];
            v17 = v11 - v25;
            v18 = ASN1Item::readTag((uint64_t)v15, v16, v17, (uint64_t)&size);
            result = 0;
            if (v18)
            {
              if (BYTE2(size) == 6)
              {
                ObjectIdentifier = ASN1Item::getObjectIdentifier(0, (uint64_t)&size, (uint64_t)this + 48);
                v20 = ASN1Item::readTag(ObjectIdentifier, &v16[v25], v17 - v25, (uint64_t)&size);
                result = 0;
                if (v20)
                {
                  if (BYTE2(size) == 3)
                  {
                    v21 = HIDWORD(size);
                    v22 = malloc_type_malloc(HIDWORD(size), 0x46100A1BuLL);
                    *((_QWORD *)this + 9) = v22;
                    memcpy(v22, __src, v21);
                    *((_DWORD *)this + 20) = v21;
                    return 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void _SES_SealInfo::~_SES_SealInfo(_SES_SealInfo *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_1E1BADD58;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 7);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 8);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 9);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  if (*((char *)this + 55) < 0)
    operator delete(*((void **)this + 4));
}

{
  _SES_SealInfo::~_SES_SealInfo(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SES_SealInfo::parse(_SES_SealInfo *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  unsigned __int8 *v8;
  unsigned int v9;
  _SES_Header *v10;
  uint64_t v11;
  int v12;
  uint64_t String;
  unsigned __int8 *v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24[2];
  unsigned __int8 *v25;
  uint64_t v26;

  *(_QWORD *)v24 = 0;
  v25 = 0;
  v26 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)v24);
  result = 0;
  if (Tag)
  {
    if (BYTE2(v24[0]) == 16)
    {
      v8 = &a2[v26];
      v9 = a3 - v26;
      v10 = (_SES_Header *)operator new();
      *(_QWORD *)v10 = &off_1E1BABFA0;
      *((_QWORD *)v10 + 4) = 0;
      *((_QWORD *)v10 + 5) = 0;
      *((_QWORD *)v10 + 3) = 0;
      *((_QWORD *)v10 + 8) = 0;
      *((_QWORD *)v10 + 9) = 0;
      *((_QWORD *)v10 + 7) = 0;
      *((_QWORD *)this + 3) = v10;
      v11 = _SES_Header::parse(v10, v25, v24[1]);
      v12 = ASN1Item::readTag(v11, v8, v9, (uint64_t)v24);
      result = 0;
      if (v12)
      {
        if (BYTE2(v24[0]) == 22)
        {
          String = ASN1Item::getString(0, (uint64_t)v24, (std::string *)((char *)this + 32));
          v14 = &v8[v26];
          v15 = v9 - v26;
          v16 = ASN1Item::readTag(String, v14, v15, (uint64_t)v24);
          result = 0;
          if (v16)
          {
            if (BYTE2(v24[0]) == 16)
            {
              v17 = v26;
              v18 = operator new();
              *(_QWORD *)v18 = &off_1E1BB1D10;
              *(_QWORD *)(v18 + 32) = 0;
              *(_QWORD *)(v18 + 40) = 0;
              *(_QWORD *)(v18 + 24) = 0;
              *(_OWORD *)(v18 + 56) = 0u;
              *(_OWORD *)(v18 + 72) = 0u;
              *(_OWORD *)(v18 + 88) = 0u;
              *(_OWORD *)(v18 + 104) = 0u;
              *(_OWORD *)(v18 + 120) = 0u;
              *((_QWORD *)this + 7) = v18;
              result = _SES_ESPropertyInfo::parse((_SES_ESPropertyInfo *)v18, v25, v24[1]);
              if ((_DWORD)result)
              {
                v19 = &v14[v17];
                v20 = v15 - v17;
                v21 = ASN1Item::readTag(result, v19, v20, (uint64_t)v24);
                result = 0;
                if (v21)
                {
                  if (BYTE2(v24[0]) == 16)
                  {
                    v22 = v26;
                    v23 = operator new();
                    *(_QWORD *)v23 = &off_1E1BB18A0;
                    *(_OWORD *)(v23 + 24) = 0u;
                    *(_OWORD *)(v23 + 40) = 0u;
                    *(_DWORD *)(v23 + 56) = 0;
                    *((_QWORD *)this + 8) = v23;
                    result = _SES_ESPictureInfo::parse((_SES_ESPictureInfo *)v23, v25, v24[1]);
                    if ((_DWORD)result)
                    {
                      if (v20 != (_DWORD)v22)
                        return ASN1Item::readTag(result, &v19[v22], v20 - v22, (uint64_t)v24)
                            && BYTE2(v24[0]) == 16;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void _SES_Header::~_SES_Header(void **this)
{
  *this = &off_1E1BABFA0;
  if (*((char *)this + 79) < 0)
    operator delete(this[7]);
  if (*((char *)this + 47) < 0)
    operator delete(this[3]);
}

{
  _SES_Header::~_SES_Header(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SES_Header::parse(_SES_Header *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  uint64_t String;
  unsigned __int8 *v9;
  unsigned int v10;
  uint64_t v11;
  BOOL v12;
  uint64_t Integer;
  int v14;
  _QWORD v15[2];
  uint64_t v16;

  v15[0] = 0;
  v15[1] = 0;
  v16 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)v15);
  result = 0;
  if (Tag && BYTE2(v15[0]) == 22)
  {
    String = ASN1Item::getString(0, (uint64_t)v15, (std::string *)this + 1);
    v9 = &a2[v16];
    v10 = a3 - v16;
    v11 = ASN1Item::readTag(String, v9, v10, (uint64_t)v15);
    if ((_DWORD)v11)
      v12 = BYTE2(v15[0]) == 2;
    else
      v12 = 0;
    if (v12)
    {
      Integer = ASN1Item::getInteger(v11, (uint64_t)v15, (int *)this + 12);
      v14 = ASN1Item::readTag(Integer, &v9[v16], v10 - v16, (uint64_t)v15);
      result = 0;
      if (v14)
      {
        if (BYTE2(v15[0]) == 22)
        {
          ASN1Item::getString(0, (uint64_t)v15, (std::string *)((char *)this + 56));
          return 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void _SES_ESPropertyInfo::~_SES_ESPropertyInfo(_SES_ESPropertyInfo *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BB1D10;
  v2 = *((_QWORD *)this + 7);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  if (*((char *)this + 135) < 0)
    operator delete(*((void **)this + 14));
  if (*((char *)this + 111) < 0)
    operator delete(*((void **)this + 11));
  if (*((char *)this + 87) < 0)
    operator delete(*((void **)this + 8));
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
}

{
  _SES_ESPropertyInfo::~_SES_ESPropertyInfo(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SES_ESPropertyInfo::parse(_SES_ESPropertyInfo *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  uint64_t Integer;
  unsigned __int8 *v9;
  int v10;
  uint64_t v11;
  BOOL v12;
  uint64_t String;
  unsigned __int8 *v14;
  int v15;
  int v16;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned int v19;
  int v20;
  unsigned __int8 *v21;
  unsigned int v22;
  int v23;
  _BOOL8 Date;
  unsigned __int8 *v25;
  unsigned int v26;
  int v27;
  _BOOL8 v28;
  int v29;
  _QWORD v30[2];
  uint64_t v31;

  v30[0] = 0;
  v30[1] = 0;
  v31 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)v30);
  result = 0;
  if (Tag && BYTE2(v30[0]) == 2)
  {
    Integer = ASN1Item::getInteger(0, (uint64_t)v30, (int *)this + 5);
    v9 = &a2[v31];
    v10 = a3 - v31;
    v11 = ASN1Item::readTag(Integer, v9, a3 - v31, (uint64_t)v30);
    if ((_DWORD)v11)
      v12 = BYTE2(v30[0]) == 12;
    else
      v12 = 0;
    if (v12)
    {
      String = ASN1Item::getString(v11, (uint64_t)v30, (std::string *)this + 1);
      v14 = &v9[v31];
      v15 = v10 - v31;
      v16 = ASN1Item::readTag(String, v14, v10 - (int)v31, (uint64_t)v30);
      result = 0;
      if (v16)
      {
        if (BYTE2(v30[0]) == 2)
        {
          v17 = ASN1Item::getInteger(0, (uint64_t)v30, (int *)this + 12);
          v18 = &v14[v31];
          v19 = v15 - v31;
          v20 = ASN1Item::readTag(v17, v18, v19, (uint64_t)v30);
          result = 0;
          if (v20)
          {
            if (BYTE2(v30[0]) == 16)
            {
              v21 = &v18[v31];
              v22 = v19 - v31;
              v23 = ASN1Item::readTag(0, v21, v22, (uint64_t)v30);
              result = 0;
              if (v23)
              {
                if (BYTE2(v30[0]) == 24)
                {
                  Date = ASN1Item::getDate(0, (uint64_t)v30, (std::string *)((char *)this + 64));
                  v25 = &v21[v31];
                  v26 = v22 - v31;
                  v27 = ASN1Item::readTag(Date, v25, v26, (uint64_t)v30);
                  result = 0;
                  if (v27)
                  {
                    if (BYTE2(v30[0]) == 24)
                    {
                      v28 = ASN1Item::getDate(0, (uint64_t)v30, (std::string *)((char *)this + 88));
                      v29 = ASN1Item::readTag(v28, &v25[v31], v26 - v31, (uint64_t)v30);
                      result = 0;
                      if (v29)
                      {
                        if (BYTE2(v30[0]) == 24)
                        {
                          ASN1Item::getDate(0, (uint64_t)v30, (std::string *)((char *)this + 112));
                          return 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void _SES_ESPictureInfo::~_SES_ESPictureInfo(_SES_ESPictureInfo *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E1BB18A0;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
    free(v2);
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
}

{
  _SES_ESPictureInfo::~_SES_ESPictureInfo(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SES_ESPictureInfo::parse(_SES_ESPictureInfo *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  uint64_t String;
  unsigned __int8 *v9;
  unsigned int v10;
  BOOL v11;
  size_t v12;
  void *v13;
  void *v14;
  unsigned __int8 *v15;
  unsigned int v16;
  int v17;
  uint64_t Integer;
  int v19;
  size_t size;
  void *__src;
  uint64_t v22;

  size = 0;
  __src = 0;
  v22 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)&size);
  result = 0;
  if (Tag && BYTE2(size) == 22)
  {
    String = ASN1Item::getString(0, (uint64_t)&size, (std::string *)this + 1);
    v9 = &a2[v22];
    v10 = a3 - v22;
    if (ASN1Item::readTag(String, v9, v10, (uint64_t)&size))
      v11 = BYTE2(size) == 4;
    else
      v11 = 0;
    if (v11)
    {
      v12 = HIDWORD(size);
      v13 = malloc_type_malloc(HIDWORD(size), 0x4B106C32uLL);
      *((_QWORD *)this + 6) = v13;
      v14 = memcpy(v13, __src, v12);
      *((_DWORD *)this + 14) = v12;
      v15 = &v9[v22];
      v16 = v10 - v22;
      v17 = ASN1Item::readTag((uint64_t)v14, v15, v16, (uint64_t)&size);
      result = 0;
      if (v17)
      {
        if (BYTE2(size) == 2)
        {
          Integer = ASN1Item::getInteger(0, (uint64_t)&size, (int *)this + 15);
          v19 = ASN1Item::readTag(Integer, &v15[v22], v16 - v22, (uint64_t)&size);
          result = 0;
          if (v19)
          {
            if (BYTE2(size) == 2)
            {
              ASN1Item::getInteger(0, (uint64_t)&size, (int *)this + 16);
              return 1;
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFDataRef _SES_ESPictureInfo::copyPictureData(uint64_t a1, std::string *a2)
{
  const UInt8 *v3;
  CFDataRef v5;

  v3 = *(const UInt8 **)(a1 + 48);
  if (!v3)
    return 0;
  v5 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v3, *(unsigned int *)(a1 + 56));
  std::string::operator=(a2, (const std::string *)(a1 + 24));
  return v5;
}

void _SES_Signature_v1::~_SES_Signature_v1(_SES_Signature_v1 *this)
{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = &off_1E1BB13B8;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
    free(v3);
}

{
  _SES_Signature_v1::~_SES_Signature_v1(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SES_Signature_v1::parse(_SES_Signature_v1 *this, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t Tag;
  uint64_t v6;
  unsigned int v8[2];
  unsigned __int8 *v9;
  uint64_t v10;

  *(_QWORD *)v8 = 0;
  v9 = 0;
  v10 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  v3 = a3 - 4;
  if (a3 < 4)
    return 0;
  gOffset = (uint64_t)a2;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)v8);
  if (!(_DWORD)Tag
    || BYTE2(v8[0]) != 16
    || !ASN1Item::readTag(Tag, v9, v8[1], (uint64_t)v8)
    || BYTE2(v8[0]) != 16
    || v3 < v10)
  {
    return 0;
  }
  v6 = operator new();
  *(_QWORD *)v6 = &off_1E1BAC4A8;
  *(_QWORD *)(v6 + 112) = 0;
  *(_QWORD *)(v6 + 120) = 0;
  *(_QWORD *)(v6 + 104) = 0;
  *(_QWORD *)(v6 + 48) = 0;
  *(_DWORD *)(v6 + 56) = 0;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 32) = 0;
  *(_DWORD *)(v6 + 40) = 0;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_DWORD *)(v6 + 96) = 0;
  *((_QWORD *)this + 3) = v6;
  return _TBS_Sign_v1::parse((_TBS_Sign_v1 *)v6, v9, v8[1]);
}

void _TBS_Sign_v1::~_TBS_Sign_v1(_TBS_Sign_v1 *this)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;

  *(_QWORD *)this = &off_1E1BAC4A8;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)this + 6);
  if (v4)
    free(v4);
  v5 = (void *)*((_QWORD *)this + 11);
  if (v5)
    free(v5);
  if (*((char *)this + 127) < 0)
    operator delete(*((void **)this + 13));
  if (*((char *)this + 87) < 0)
    operator delete(*((void **)this + 8));
}

{
  _TBS_Sign_v1::~_TBS_Sign_v1(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _TBS_Sign_v1::parse(_TBS_Sign_v1 *this, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t Tag;
  uint64_t Integer;
  _SESeal_v1 *v8;
  unsigned int v10[2];
  unsigned __int8 *v11;
  uint64_t v12;

  *(_QWORD *)v10 = 0;
  v11 = 0;
  v12 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)v10);
  if (!(_DWORD)Tag)
    return 0;
  if (BYTE2(v10[0]) != 2)
    return 0;
  Integer = ASN1Item::getInteger(Tag, (uint64_t)v10, (int *)this + 5);
  if (a3 < v12
    || !ASN1Item::readTag(Integer, &a2[v12], a3 - v12, (uint64_t)v10)
    || BYTE2(v10[0]) != 16)
  {
    return 0;
  }
  v8 = (_SESeal_v1 *)operator new();
  *(_QWORD *)v8 = &off_1E1BAB688;
  *((_QWORD *)v8 + 3) = 0;
  *((_QWORD *)v8 + 4) = 0;
  *((_QWORD *)this + 3) = v8;
  return _SESeal_v1::parse(v8, v11, v10[1]);
}

void _SESeal_v1::~_SESeal_v1(_SESeal_v1 *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BAB688;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BAB688;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  JUMPOUT(0x18D761C30);
}

uint64_t _SESeal_v1::parse(_SESeal_v1 *this, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v11[2];
  unsigned __int8 *v12;
  uint64_t v13;

  *(_QWORD *)v11 = 0;
  v12 = 0;
  v13 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  if (!ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)v11))
    return 0;
  if (BYTE2(v11[0]) != 16)
    return 0;
  v6 = v13;
  v7 = operator new();
  *(_QWORD *)v7 = &off_1E1BB0F48;
  *(_OWORD *)(v7 + 24) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_QWORD *)(v7 + 72) = 0;
  *((_QWORD *)this + 3) = v7;
  v8 = _SES_SealInfo_v1::parse((_SES_SealInfo_v1 *)v7, v12, v11[1]);
  if (!(_DWORD)v8
    || !ASN1Item::readTag(v8, &a2[v6], a3 - v6, (uint64_t)v11)
    || BYTE2(v11[0]) != 16)
  {
    return 0;
  }
  v9 = operator new();
  *(_QWORD *)v9 = &off_1E1BB0F70;
  *(_QWORD *)(v9 + 24) = 0;
  *(_DWORD *)(v9 + 32) = 0;
  *(_OWORD *)(v9 + 40) = 0u;
  *(_OWORD *)(v9 + 56) = 0u;
  *(_DWORD *)(v9 + 72) = 0;
  *((_QWORD *)this + 4) = v9;
  return _SES_SignInfo_v1::parse((_SES_SignInfo_v1 *)v9, v12, v11[1]);
}

void _SES_SealInfo_v1::~_SES_SealInfo_v1(_SES_SealInfo_v1 *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = &off_1E1BB0F48;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 7);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 8);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *((_QWORD *)this + 9);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  if (*((char *)this + 55) < 0)
    operator delete(*((void **)this + 4));
}

{
  _SES_SealInfo_v1::~_SES_SealInfo_v1(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SES_SealInfo_v1::parse(_SES_SealInfo_v1 *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  unsigned __int8 *v8;
  unsigned int v9;
  _SES_Header *v10;
  uint64_t v11;
  int v12;
  uint64_t String;
  unsigned __int8 *v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24[2];
  unsigned __int8 *v25;
  uint64_t v26;

  *(_QWORD *)v24 = 0;
  v25 = 0;
  v26 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)v24);
  result = 0;
  if (Tag)
  {
    if (BYTE2(v24[0]) == 16)
    {
      v8 = &a2[v26];
      v9 = a3 - v26;
      v10 = (_SES_Header *)operator new();
      *(_QWORD *)v10 = &off_1E1BABFA0;
      *((_QWORD *)v10 + 4) = 0;
      *((_QWORD *)v10 + 5) = 0;
      *((_QWORD *)v10 + 3) = 0;
      *((_QWORD *)v10 + 8) = 0;
      *((_QWORD *)v10 + 9) = 0;
      *((_QWORD *)v10 + 7) = 0;
      *((_QWORD *)this + 3) = v10;
      v11 = _SES_Header::parse(v10, v25, v24[1]);
      v12 = ASN1Item::readTag(v11, v8, v9, (uint64_t)v24);
      result = 0;
      if (v12)
      {
        if (BYTE2(v24[0]) == 22)
        {
          String = ASN1Item::getString(0, (uint64_t)v24, (std::string *)((char *)this + 32));
          v14 = &v8[v26];
          v15 = v9 - v26;
          v16 = ASN1Item::readTag(String, v14, v15, (uint64_t)v24);
          result = 0;
          if (v16)
          {
            if (BYTE2(v24[0]) == 16)
            {
              v17 = v26;
              v18 = operator new();
              *(_QWORD *)v18 = &off_1E1BB2438;
              *(_OWORD *)(v18 + 24) = 0u;
              *(_OWORD *)(v18 + 40) = 0u;
              *(_OWORD *)(v18 + 56) = 0u;
              *(_OWORD *)(v18 + 72) = 0u;
              *(_OWORD *)(v18 + 88) = 0u;
              *(_OWORD *)(v18 + 104) = 0u;
              *(_QWORD *)(v18 + 120) = 0;
              *((_QWORD *)this + 7) = v18;
              result = _SES_ESPropertyInfo_v1::parse((_SES_ESPropertyInfo_v1 *)v18, v25, v24[1]);
              if ((_DWORD)result)
              {
                v19 = &v14[v17];
                v20 = v15 - v17;
                v21 = ASN1Item::readTag(result, v19, v20, (uint64_t)v24);
                result = 0;
                if (v21)
                {
                  if (BYTE2(v24[0]) == 16)
                  {
                    v22 = v26;
                    v23 = operator new();
                    *(_QWORD *)v23 = &off_1E1BB18A0;
                    *(_OWORD *)(v23 + 24) = 0u;
                    *(_OWORD *)(v23 + 40) = 0u;
                    *(_DWORD *)(v23 + 56) = 0;
                    *((_QWORD *)this + 8) = v23;
                    result = _SES_ESPictureInfo::parse((_SES_ESPictureInfo *)v23, v25, v24[1]);
                    if (v20 != (_DWORD)v22)
                      return ASN1Item::readTag(result, &v19[v22], v20 - v22, (uint64_t)v24)
                          && BYTE2(v24[0]) == 16;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void _SES_ESPropertyInfo_v1::~_SES_ESPropertyInfo_v1(_SES_ESPropertyInfo_v1 *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BB2438;
  v2 = *((_QWORD *)this + 6);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  if (*((char *)this + 127) < 0)
    operator delete(*((void **)this + 13));
  if (*((char *)this + 103) < 0)
    operator delete(*((void **)this + 10));
  if (*((char *)this + 79) < 0)
    operator delete(*((void **)this + 7));
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
}

{
  _SES_ESPropertyInfo_v1::~_SES_ESPropertyInfo_v1(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SES_ESPropertyInfo_v1::parse(_SES_ESPropertyInfo_v1 *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  uint64_t Integer;
  unsigned __int8 *v9;
  unsigned int v10;
  uint64_t v11;
  BOOL v12;
  uint64_t String;
  unsigned __int8 *v14;
  int v15;
  int v16;
  unsigned __int8 *v17;
  int v18;
  int v19;
  _BOOL8 Date;
  unsigned __int8 *v21;
  unsigned int v22;
  int v23;
  _BOOL8 v24;
  int v25;
  _QWORD v26[2];
  uint64_t v27;

  v26[0] = 0;
  v26[1] = 0;
  v27 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)v26);
  result = 0;
  if (Tag && BYTE2(v26[0]) == 2)
  {
    Integer = ASN1Item::getInteger(0, (uint64_t)v26, (int *)this + 5);
    v9 = &a2[v27];
    v10 = a3 - v27;
    v11 = ASN1Item::readTag(Integer, v9, v10, (uint64_t)v26);
    if ((_DWORD)v11)
      v12 = BYTE2(v26[0]) == 12;
    else
      v12 = 0;
    if (v12)
    {
      String = ASN1Item::getString(v11, (uint64_t)v26, (std::string *)this + 1);
      v14 = &v9[v27];
      v15 = v10 - v27;
      v16 = ASN1Item::readTag(String, v14, v10 - v27, (uint64_t)v26);
      result = 0;
      if (v16)
      {
        if (BYTE2(v26[0]) == 16)
        {
          v17 = &v14[v27];
          v18 = v15 - v27;
          v19 = ASN1Item::readTag(0, v17, v15 - (int)v27, (uint64_t)v26);
          result = 0;
          if (v19)
          {
            if (BYTE2(v26[0]) == 23)
            {
              Date = ASN1Item::getDate(0, (uint64_t)v26, (std::string *)((char *)this + 56));
              v21 = &v17[v27];
              v22 = v18 - v27;
              v23 = ASN1Item::readTag(Date, v21, v22, (uint64_t)v26);
              result = 0;
              if (v23)
              {
                if (BYTE2(v26[0]) == 23)
                {
                  v24 = ASN1Item::getDate(0, (uint64_t)v26, (std::string *)((char *)this + 80));
                  v25 = ASN1Item::readTag(v24, &v21[v27], v22 - v27, (uint64_t)v26);
                  result = 0;
                  if (v25)
                  {
                    if (BYTE2(v26[0]) == 23)
                    {
                      ASN1Item::getDate(0, (uint64_t)v26, (std::string *)((char *)this + 104));
                      return 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void _SES_SignInfo_v1::~_SES_SignInfo_v1(_SES_SignInfo_v1 *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E1BB0F70;
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 8);
  if (v3)
    free(v3);
  if (*((char *)this + 63) < 0)
    operator delete(*((void **)this + 5));
}

{
  _SES_SignInfo_v1::~_SES_SignInfo_v1(this);
  JUMPOUT(0x18D761C30);
}

uint64_t _SES_SignInfo_v1::parse(_SES_SignInfo_v1 *this, unsigned __int8 *a2, unsigned int a3)
{
  int Tag;
  uint64_t result;
  size_t v8;
  void *v9;
  void *v10;
  unsigned __int8 *v11;
  unsigned int v12;
  uint64_t v13;
  BOOL v14;
  uint64_t ObjectIdentifier;
  int v16;
  size_t v17;
  void *v18;
  size_t size;
  void *__src;
  uint64_t v21;

  size = 0;
  __src = 0;
  v21 = 0;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 4) = a3;
  Tag = ASN1Item::readTag((uint64_t)this, a2, a3, (uint64_t)&size);
  result = 0;
  if (Tag && BYTE2(size) == 4)
  {
    v8 = HIDWORD(size);
    v9 = malloc_type_malloc(HIDWORD(size), 0x4B106C32uLL);
    *((_QWORD *)this + 3) = v9;
    v10 = memcpy(v9, __src, v8);
    *((_DWORD *)this + 8) = v8;
    v11 = &a2[v21];
    v12 = a3 - v21;
    v13 = ASN1Item::readTag((uint64_t)v10, v11, v12, (uint64_t)&size);
    if ((_DWORD)v13)
      v14 = BYTE2(size) == 6;
    else
      v14 = 0;
    if (v14)
    {
      ObjectIdentifier = ASN1Item::getObjectIdentifier(v13, (uint64_t)&size, (uint64_t)this + 40);
      v16 = ASN1Item::readTag(ObjectIdentifier, &v11[v21], v12 - v21, (uint64_t)&size);
      result = 0;
      if (v16)
      {
        if (BYTE2(size) == 3)
        {
          v17 = HIDWORD(size);
          v18 = malloc_type_malloc(HIDWORD(size), 0x46100A1BuLL);
          *((_QWORD *)this + 8) = v18;
          memcpy(v18, __src, v17);
          *((_DWORD *)this + 18) = v17;
          return 1;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void ASN1Parser::ASN1Parser(ASN1Parser *this)
{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E1BAB4B8;
}

void ASN1Parser::~ASN1Parser(ASN1Parser *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BAB4B8;
  v2 = *((_QWORD *)this + 2);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 1);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BAB4B8;
  v2 = *((_QWORD *)this + 2);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 1);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  JUMPOUT(0x18D761C30);
}

uint64_t ASN1Parser::parseASN1_V4Seal(ASN1Parser *this, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = operator new();
  *(_QWORD *)v6 = &off_1E1BAFFC0;
  *(_QWORD *)(v6 + 88) = 0;
  *(_DWORD *)(v6 + 96) = 0;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 32) = 0;
  *(_DWORD *)(v6 + 40) = 0;
  *(_OWORD *)(v6 + 48) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_DWORD *)(v6 + 80) = 0;
  *((_QWORD *)this + 1) = v6;
  v7 = _SES_Signature::parse((_SES_Signature *)v6, a2, a3);
  if ((v7 & 1) == 0)
  {
    v8 = *((_QWORD *)this + 1);
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    *((_QWORD *)this + 1) = 0;
  }
  return v7;
}

uint64_t ASN1Parser::parseASN1_V1Seal(ASN1Parser *this, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = operator new();
  *(_QWORD *)v6 = &off_1E1BB13B8;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 32) = 0;
  *(_DWORD *)(v6 + 40) = 0;
  *((_QWORD *)this + 2) = v6;
  v7 = _SES_Signature_v1::parse((_SES_Signature_v1 *)v6, a2, a3);
  if ((v7 & 1) == 0)
  {
    v8 = *((_QWORD *)this + 2);
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    *((_QWORD *)this + 2) = 0;
  }
  return v7;
}

uint64_t ASN1Parser::parseASN1(ASN1Parser *this, unsigned __int8 *a2, unsigned int a3)
{
  if ((ASN1Parser::parseASN1_V4Seal(this, a2, a3) & 1) != 0)
    return 1;
  else
    return ASN1Parser::parseASN1_V1Seal(this, a2, a3);
}

CFDataRef ASN1Parser::copyImageData(uint64_t a1, std::string *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  if ((v2 || (v2 = *(_QWORD *)(a1 + 16)) != 0)
    && (v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 24) + 24) + 24) + 64)) != 0)
  {
    return _SES_ESPictureInfo::copyPictureData(v3, a2);
  }
  else
  {
    return 0;
  }
}

void OFDPathObject::OFDPathObject(OFDPathObject *this, const __CFDictionary *a2)
{
  _QWORD *v4;
  uint64_t *v5;
  const __CFDictionary *ObjectForKey;
  _QWORD v7[3];

  v4 = (_QWORD *)OFDObject::OFDObject((uint64_t)this, a2, 1);
  v4[26] = 0;
  v5 = v4 + 26;
  *v4 = off_1E1BAD518;
  v4[27] = 0;
  v4[28] = 0;
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a2);
  if (IIODictionary::getCount((IIODictionary *)v7))
  {
    *((double *)this + 24) = IIODictionary::getDoubleForKey((IIODictionary *)v7, CFSTR("LineWidth"));
    *((double *)this + 25) = IIODictionary::getDoubleForKey((IIODictionary *)v7, CFSTR("MiterLimit"));
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v7, CFSTR("AbbreviatedData"));
    if (ObjectForKey)
      OFDParsePathOperations(ObjectForKey, v5);
    if (!*((_DWORD *)this + 28))
    {
      *((_DWORD *)this + 28) = 1;
      *((_QWORD *)this + 15) = 0;
      *((_QWORD *)this + 16) = 0;
      *((_QWORD *)this + 17) = 0;
      *((_QWORD *)this + 18) = 0x3FF0000000000000;
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)v7);
}

void sub_1881DCB64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  const char *v5;
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _cg_jpeg_mem_term(v2, v4, v5);
  _Unwind_Resume(a1);
}

void OFDPathObject::~OFDPathObject(OFDPathObject *this)
{
  uint64_t v2;
  const char *v3;
  void **v4;

  *(_QWORD *)this = off_1E1BAD518;
  v4 = (void **)((char *)this + 208);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v4);
  _cg_jpeg_mem_term(this, v2, v3);
}

{
  uint64_t v2;
  const char *v3;
  __n128 v4;
  void **v5;

  *(_QWORD *)this = off_1E1BAD518;
  v5 = (void **)((char *)this + 208);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
  v4 = _cg_jpeg_mem_term(this, v2, v3);
  MEMORY[0x18D761C30](v4);
}

void OFDPathObject::drawInContext(OFDPathObject *this, CGContextRef c, CGRect a3, OFDPage *a4)
{
  __int128 v6;
  double *v7;
  double v8;
  double v9;
  __int128 *v10;
  __int128 v11;
  std::string *v12;
  int v13;
  __int128 *v14;
  std::string *v15;
  double v16;
  double v17;
  std::string *v18;
  double v19;
  std::string *v20;
  double v21;
  double v22;
  std::string *v23;
  std::string *v24;
  double v25;
  double v26;
  std::string *v27;
  double v28;
  double v29;
  std::string *v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  std::string *v36;
  double v37;
  std::string *v38;
  double v39;
  double v40;
  std::string *v41;
  double v42;
  double v43;
  std::string *v44;
  double v45;
  double v46;
  std::string *v47;
  double v48;
  double v49;
  std::string *v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  std::string *v58;
  double v59;
  char v60;
  std::string v61;
  CGAffineTransform transform;

  CGContextSaveGState(c);
  v6 = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)&transform.a = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)&transform.c = v6;
  *(_OWORD *)&transform.tx = *(_OWORD *)((char *)this + 56);
  CGContextConcatCTM(c, &transform);
  CGContextSetLineWidth(c, *((CGFloat *)this + 24));
  if (*((_DWORD *)this + 28) == 1)
    CGContextSetRGBStrokeColor(c, *((CGFloat *)this + 15), *((CGFloat *)this + 16), *((CGFloat *)this + 17), 1.0);
  if (*((_DWORD *)this + 38) == 1)
    CGContextSetRGBFillColor(c, *((CGFloat *)this + 20), *((CGFloat *)this + 21), *((CGFloat *)this + 22), 1.0);
  v7 = (double *)MEMORY[0x1E0C9D538];
  v8 = *MEMORY[0x1E0C9D538];
  v9 = *(double *)(MEMORY[0x1E0C9D538] + 8);
  v10 = (__int128 *)*((_QWORD *)this + 26);
  while (v10 != *((__int128 **)this + 27))
  {
    memset(&v61, 0, sizeof(v61));
    if (*((char *)v10 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v61, *(const std::string::value_type **)v10, *((_QWORD *)v10 + 1));
    }
    else
    {
      v11 = *v10;
      v61.__r_.__value_.__r.__words[2] = *((_QWORD *)v10 + 2);
      *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v11;
    }
    if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v12 = &v61;
    else
      v12 = (std::string *)v61.__r_.__value_.__r.__words[0];
    v13 = v12->__r_.__value_.__s.__data_[0];
    if (v13 <= 75)
    {
      if (v13 == 66)
      {
        v8 = *v7;
        v9 = v7[1];
        v14 = (__int128 *)((char *)v10 + 24);
        if ((__int128 *)((char *)v10 + 24) == *((__int128 **)this + 27))
        {
          _cg_jpeg_mem_term("drawInContext", 129, "*** ERROR: malformed pathObject (%s)\n", "B.cp1x");
          goto LABEL_99;
        }
        std::string::operator=(&v61, (const std::string *)v10 + 1);
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v38 = &v61;
        else
          v38 = (std::string *)v61.__r_.__value_.__r.__words[0];
        v39 = atof((const char *)v38);
        v14 = v10 + 3;
        if (v10 + 3 == *((__int128 **)this + 27))
        {
          _cg_jpeg_mem_term("drawInContext", 132, "*** ERROR: malformed pathObject (%s)\n", "B.cp1y");
          goto LABEL_99;
        }
        v40 = v39;
        std::string::operator=(&v61, (const std::string *)v10 + 2);
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v41 = &v61;
        else
          v41 = (std::string *)v61.__r_.__value_.__r.__words[0];
        v42 = atof((const char *)v41);
        v14 = (__int128 *)((char *)v10 + 72);
        if ((__int128 *)((char *)v10 + 72) == *((__int128 **)this + 27))
        {
          _cg_jpeg_mem_term("drawInContext", 136, "*** ERROR: malformed pathObject (%s)\n", "B.cp2x");
          goto LABEL_99;
        }
        v43 = v42;
        std::string::operator=(&v61, (const std::string *)v10 + 3);
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v44 = &v61;
        else
          v44 = (std::string *)v61.__r_.__value_.__r.__words[0];
        v45 = atof((const char *)v44);
        v14 = v10 + 6;
        if (v10 + 6 == *((__int128 **)this + 27))
        {
          _cg_jpeg_mem_term("drawInContext", 139, "*** ERROR: malformed pathObject (%s)\n", "B.cp2y");
          goto LABEL_99;
        }
        v46 = v45;
        std::string::operator=(&v61, (const std::string *)v10 + 4);
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v47 = &v61;
        else
          v47 = (std::string *)v61.__r_.__value_.__r.__words[0];
        v48 = atof((const char *)v47);
        v14 = (__int128 *)((char *)v10 + 120);
        if ((__int128 *)((char *)v10 + 120) == *((__int128 **)this + 27))
        {
          _cg_jpeg_mem_term("drawInContext", 143, "*** ERROR: malformed pathObject (%s)\n", "B.x");
          goto LABEL_99;
        }
        v49 = v48;
        std::string::operator=(&v61, (const std::string *)v10 + 5);
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v50 = &v61;
        else
          v50 = (std::string *)v61.__r_.__value_.__r.__words[0];
        v51 = atof((const char *)v50);
        v10 += 9;
        if (v10 == *((__int128 **)this + 27))
        {
          _cg_jpeg_mem_term("drawInContext", 146, "*** ERROR: malformed pathObject (%s)\n", "B.y");
          goto LABEL_101;
        }
        v52 = v51;
        std::string::operator=(&v61, (const std::string *)v10);
        v53 = v8 + v40;
        v54 = v9 + v43;
        v55 = v8 + v46;
        v56 = v9 + v49;
        v57 = v8 + v52;
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v58 = &v61;
        else
          v58 = (std::string *)v61.__r_.__value_.__r.__words[0];
        v59 = atof((const char *)v58);
        CGContextAddCurveToPoint(c, v53, v54, v55, v56, v57, v9 + v59);
      }
      else if (v13 == 67)
      {
        CGContextClosePath(c);
      }
    }
    else
    {
      switch(v13)
      {
        case 'L':
          v8 = *v7;
          v9 = v7[1];
          v14 = (__int128 *)((char *)v10 + 24);
          if ((__int128 *)((char *)v10 + 24) == *((__int128 **)this + 27))
          {
            _cg_jpeg_mem_term("drawInContext", 108, "*** ERROR: malformed pathObject (%s)\n", "L.x");
            goto LABEL_99;
          }
          std::string::operator=(&v61, (const std::string *)v10 + 1);
          if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v20 = &v61;
          else
            v20 = (std::string *)v61.__r_.__value_.__r.__words[0];
          v21 = atof((const char *)v20);
          v10 += 3;
          if (v10 == *((__int128 **)this + 27))
          {
            _cg_jpeg_mem_term("drawInContext", 111, "*** ERROR: malformed pathObject (%s)\n", "L.y");
            goto LABEL_101;
          }
          v22 = v21;
          std::string::operator=(&v61, (const std::string *)v10);
          if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v23 = &v61;
          else
            v23 = (std::string *)v61.__r_.__value_.__r.__words[0];
          v8 = v8 + v22;
          v9 = v9 + atof((const char *)v23);
          CGContextAddLineToPoint(c, v8, v9);
          break;
        case 'Q':
          v14 = (__int128 *)((char *)v10 + 24);
          if ((__int128 *)((char *)v10 + 24) == *((__int128 **)this + 27))
          {
            _cg_jpeg_mem_term("drawInContext", 161, "*** ERROR: malformed pathObject (%s)\n", "Q.cp1x");
            goto LABEL_99;
          }
          std::string::operator=(&v61, (const std::string *)v10 + 1);
          if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v24 = &v61;
          else
            v24 = (std::string *)v61.__r_.__value_.__r.__words[0];
          v25 = atof((const char *)v24);
          v14 = v10 + 3;
          if (v10 + 3 == *((__int128 **)this + 27))
          {
            _cg_jpeg_mem_term("drawInContext", 164, "*** ERROR: malformed pathObject (%s)\n", "Q.cp1y");
            goto LABEL_99;
          }
          v26 = v25;
          std::string::operator=(&v61, (const std::string *)v10 + 2);
          if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v27 = &v61;
          else
            v27 = (std::string *)v61.__r_.__value_.__r.__words[0];
          v28 = atof((const char *)v27);
          v14 = (__int128 *)((char *)v10 + 72);
          if ((__int128 *)((char *)v10 + 72) == *((__int128 **)this + 27))
          {
            _cg_jpeg_mem_term("drawInContext", 168, "*** ERROR: malformed pathObject (%s)\n", "Q.cp2x");
            goto LABEL_99;
          }
          v29 = v28;
          std::string::operator=(&v61, (const std::string *)v10 + 3);
          if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v30 = &v61;
          else
            v30 = (std::string *)v61.__r_.__value_.__r.__words[0];
          v31 = atof((const char *)v30);
          v10 += 6;
          if (v10 == *((__int128 **)this + 27))
          {
            _cg_jpeg_mem_term("drawInContext", 171, "*** ERROR: malformed pathObject (%s)\n", "Q.cp2y");
            goto LABEL_101;
          }
          v32 = v31;
          std::string::operator=(&v61, (const std::string *)v10);
          v33 = v8 + v26;
          v34 = v9 + v29;
          v35 = v8 + v32;
          if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v36 = &v61;
          else
            v36 = (std::string *)v61.__r_.__value_.__r.__words[0];
          v37 = atof((const char *)v36);
          CGContextAddQuadCurveToPoint(c, v33, v34, v35, v9 + v37);
          break;
        case 'M':
          v8 = *v7;
          v9 = v7[1];
          v14 = (__int128 *)((char *)v10 + 24);
          if ((__int128 *)((char *)v10 + 24) == *((__int128 **)this + 27))
          {
            _cg_jpeg_mem_term("drawInContext", 86, "*** ERROR: malformed pathObject (%s)\n", "M.x");
LABEL_99:
            v60 = 0;
            v10 = v14;
            goto LABEL_81;
          }
          std::string::operator=(&v61, (const std::string *)v10 + 1);
          if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v15 = &v61;
          else
            v15 = (std::string *)v61.__r_.__value_.__r.__words[0];
          v16 = atof((const char *)v15);
          v10 += 3;
          if (v10 == *((__int128 **)this + 27))
          {
            _cg_jpeg_mem_term("drawInContext", 89, "*** ERROR: malformed pathObject (%s)\n", "M.y");
LABEL_101:
            v60 = 0;
            goto LABEL_81;
          }
          v17 = v16;
          std::string::operator=(&v61, (const std::string *)v10);
          if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v18 = &v61;
          else
            v18 = (std::string *)v61.__r_.__value_.__r.__words[0];
          v19 = atof((const char *)v18);
          CGContextStrokePath(c);
          v9 = v9 + v19;
          v8 = v8 + v17;
          CGContextMoveToPoint(c, v8, v9);
          break;
      }
    }
    v10 = (__int128 *)((char *)v10 + 24);
    v60 = 1;
LABEL_81:
    if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v61.__r_.__value_.__l.__data_);
      if ((v60 & 1) == 0)
        break;
    }
    else if ((v60 & 1) == 0)
    {
      break;
    }
  }
  if (*((_BYTE *)this + 105))
    CGContextFillPath(c);
  if (*((_BYTE *)this + 104))
    CGContextStrokePath(c);
  CGContextRestoreGState(c);
}

void sub_1881DD38C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

__CFData *_OFDCreatePDFDataFromURL(const __CFURL *a1)
{
  CFStringRef v1;
  const char *v2;
  OFDDocument *v3;
  OFDDocument *v4;
  int PageCount;
  __CFData *Mutable;
  CGDataConsumer *v7;
  CGContext *v8;
  unsigned int v9;
  const __CFString *v10;
  OFDPage *PageAtIndex;
  OFDPage *v12;
  CGFloat v13;
  double v14;
  CGFloat v15;
  double v16;
  CFDataRef v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  CGRect bytes;
  uint64_t v24;
  CFDictionaryRef pageInfo;
  uint64_t v26;
  _OWORD v27[3];
  _QWORD v28[3];

  v1 = CFURLCopyFileSystemPath(a1, kCFURLPOSIXPathStyle);
  memset(v28, 0, sizeof(v28));
  IIOString::IIOString((IIOString *)v28, v1);
  OFDLoadExternalSymbols();
  memset(v27, 0, sizeof(v27));
  v2 = (const char *)IIOString::utf8String((IIOString *)v28);
  OFDContainer::OFDContainer((OFDContainer *)v27, v2);
  v3 = (OFDDocument *)IIOImageSource::count((IIOImageSource *)v27);
  v4 = v3;
  if (v3)
  {
    PageCount = OFDDocument::getPageCount(v3);
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v7 = CGDataConsumerCreateWithCFData(Mutable);
    v8 = CGPDFContextCreate(v7, 0, 0);
    CGDataConsumerRelease(v7);
    if (PageCount)
    {
      v9 = 0;
      v10 = (const __CFString *)*MEMORY[0x1E0C9DB58];
      do
      {
        PageAtIndex = OFDDocument::getPageAtIndex(v4, v9);
        v12 = PageAtIndex;
        if (PageAtIndex)
        {
          OFDPage::open(PageAtIndex);
          v24 = 0;
          pageInfo = 0;
          v26 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v24);
          bytes.origin.x = OFDPage::physicalBox(v12);
          bytes.origin.y = v13;
          v15 = v14 * 2.54;
          bytes.size.width = v16 * 2.54;
          bytes.size.height = v14 * 2.54;
          v17 = CFDataCreate(0, (const UInt8 *)&bytes, 32);
          IIODictionary::setObjectForKey((IIODictionary *)&v24, v17, v10);
          CGPDFContextBeginPage(v8, pageInfo);
          CGContextTranslateCTM(v8, 0.0, v15);
          CGContextScaleCTM(v8, 2.54, -2.54);
          CGContextSetGrayFillColor(v8, 1.0, 1.0);
          CGContextFillRect(v8, bytes);
          OFDPage::drawInContext(v12, v8, bytes);
          CGPDFContextEndPage(v8);
          _cg_jpeg_mem_term(v12, v18, v19);
          IIODictionary::~IIODictionary((IIODictionary *)&v24);
        }
        ++v9;
      }
      while (PageCount != v9);
    }
    CGPDFContextClose(v8);
    _cg_jpeg_mem_term(v27, v20, v21);
    CFRelease(v8);
  }
  else
  {
    Mutable = 0;
  }
  OFDContainer::~OFDContainer((OFDContainer *)v27);
  IIOString::~IIOString((IIOString *)v28);
  return Mutable;
}

void sub_1881DD5C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  OFDContainer::~OFDContainer((OFDContainer *)va);
  IIOString::~IIOString((IIOString *)va1);
  _Unwind_Resume(a1);
}

void kd_roi_level_node::pull()
{
  __assert_rtn("pull", "roi.cpp", 70, "active && (width == cols) && (remaining_rows > 0)");
}

void kd_roi_level::advance()
{
  __assert_rtn("advance", "roi.cpp", 292, "source != NULL");
}

{
  __assert_rtn("advance", "roi.cpp", 330, "r >= first_buffer_idx");
}

{
  __assert_rtn("advance", "roi.cpp", 348, "node != NULL");
}

{
  __assert_rtn("advance", "roi.cpp", 360, "node != NULL");
}

{
  __assert_rtn("advance", "roi.cpp", 306, "(max_row+1-min_row) <= num_row_buffers");
}

{
  __assert_rtn("advance", "roi.cpp", 294, "next_row_loc < lim.y");
}

void kd_roi_level_node::advance()
{
  __assert_rtn("advance", "roi.cpp", 93, "remaining_rows > num_valid_row_buffers");
}

void kd_roi_level::notify_release()
{
  __assert_rtn("notify_release", "roi.cpp", 415, "(n < 4) && !node_released[n]");
}

void kdu_roi_level::create(kd_roi_level *a1)
{
  kd_roi_level::~kd_roi_level(a1);
  JUMPOUT(0x18D761C30);
}

void kdu_roi_level::acquire_node()
{
  __assert_rtn("acquire_node", "roi.cpp", 179, "(child_idx >= 0) && (child_idx < 4)");
}

{
  __assert_rtn("acquire", "roi_local.h", 69, "available");
}

void kd_precinct_pointer_server::initialize()
{
  __assert_rtn("initialize", "compressed_local.h", 1052, "this->buf_server == NULL");
}

void kd_buf_server::augment_structure_bytes()
{
  __assert_rtn("augment_structure_bytes", "compressed_local.h", 247, "structure_bytes >= 0");
}

void kd_tile::adjust_unloadability()
{
  __assert_rtn("adjust_unloadability", "compressed_local.h", 2551, "!is_unloadable");
}

void kd_precinct::desequence_packet()
{
  __assert_rtn("desequence_packet", "compressed_local.h", 3820, "!(desequenced || addressable)");
}

void kd_compressed_input::get_offset()
{
  __assert_rtn("get_offset", "compressed_local.h", 573, "!special_scope");
}

void kdu_output::put()
{
  __assert_rtn("put", "kdu_params.h", 127, "next_buf < end_buf");
}

void kdu_thread_entity::acquire_lock()
{
  __assert_rtn("acquire_lock", "kdu_threads.h", 896, "(lock_id>=0) && (lock_id<num_locks) && (lock->holder != this)");
}

void kdu_thread_entity::release_lock()
{
  __assert_rtn("release_lock", "kdu_threads.h", 935, "(lock_id>=0) && (lock_id<num_locks) && (lock->holder == this)");
}

void kd_precinct::release()
{
  __assert_rtn("release", "compressed_local.h", 3777, "resolution->codestream->in != NULL");
}

{
  __assert_rtn("release", "compressed_local.h", 4259, "(state != 0) && !(state & 1)");
}

void kd_precinct::load_required_packets()
{
  __assert_rtn("load_required_packets", "compressed_local.h", 3844, "desequenced && (next_layer_idx >= required_layers)");
}

void kd_precinct::initialize()
{
  __assert_rtn("set_modes", "compressed_local.h", 3520, "modes == (modes & 0xFF)");
}

void kd_compressed_input::set_suspend()
{
  __assert_rtn("set_suspend", "compressed_local.h", 618, "alt_first_unwritten > first_unwritten");
}

void kd_input::putback()
{
  __assert_rtn("putback", "compressed_local.h", 494, "first_unread > buffer");
}

{
  __assert_rtn("putback", "compressed_local.h", 493, "!throw_markers");
}

{
  __assert_rtn("putback", "compressed_local.h", 492, "!exhausted");
}

void kd_header_out::put_bit()
{
  __assert_rtn("put_bit", "compressed_local.h", 3307, "bit == (bit & 1)");
}

void kdu_thread_queue::find_unassigned_job()
{
  __assert_rtn("find_unassigned_job", "kdu_threads.cpp", 188, "first_runnable_child != NULL");
}

{
  __assert_rtn("find_unassigned_job", "kdu_threads.cpp", 170, "scan->subtree_unassigned_jobs == 0");
}

{
  __assert_rtn("find_unassigned_job", "kdu_threads.cpp", 165, "best_secondary->subtree_unassigned_jobs > 0");
}

void kdu_thread_queue::make_primary_jobs_runnable()
{
  __assert_rtn("make_primary_jobs_runnable", "kdu_threads.cpp", 257, "subtree_primary_jobs == 0");
}

void kdu_thread_queue::make_secondary_job_runnable()
{
  __assert_rtn("make_secondary_job_runnable", "kdu_threads.cpp", 270, "(subtree_unassigned_jobs > 0) && (subtree_secondary_pref != 0) && (subtree_runnable_jobs == 0) && (subtree_primary_jobs == 0)");
}

{
  __assert_rtn("make_secondary_job_runnable", "kdu_threads.cpp", 273, "secondary_pref != 0");
}

{
  __assert_rtn("make_secondary_job_runnable", "kdu_threads.cpp", 310, "best_child != NULL");
}

{
  __assert_rtn("make_secondary_job_runnable", "kdu_threads.cpp", 323, "result != NULL");
}

{
  __assert_rtn("make_secondary_job_runnable", "kdu_threads.cpp", 318, "this->num_unassigned_jobs > (this->num_runnable_jobs+this->num_primary_jobs)");
}

{
  __assert_rtn("make_secondary_job_runnable", "kdu_threads.cpp", 301, "(scan->subtree_runnable_jobs == 0) && (scan->subtree_primary_jobs == 0) && (scan->num_runnable_jobs == 0) && (scan->num_primary_jobs == 0)");
}

void kdu_thread_queue::make_subtree_jobs_runnable()
{
  __assert_rtn("make_subtree_jobs_runnable", "kdu_threads.cpp", 228, "(subtree_runnable_jobs == subtree_unassigned_jobs) && (num_runnable_jobs == num_unassigned_jobs) && (subtree_primary_jobs == 0)");
}

void kdu_thread_queue::install_synchronization_point()
{
  __assert_rtn("install_synchronization_point", "kdu_threads.cpp", 338, "num_sync_points < KDU_MAX_SYNC_NESTING");
}

void kdu_thread_entity::terminate()
{
  __assert_rtn("terminate", "kdu_threads.cpp", 964, "group->threads[n]->finished");
}

{
  __assert_rtn("terminate", "kdu_threads.cpp", 959, "group->num_deferred_jobs == 0");
}

{
  __assert_rtn("terminate", "kdu_threads.cpp", 949, "this->is_group_owner() && (group->num_finished_threads == 0)");
}

{
  __assert_rtn("terminate", "kdu_threads.cpp", 935, "root->parent->children == root");
}

{
  __assert_rtn("terminate", "kdu_threads.cpp", 932, "root->num_unassigned_jobs == 0");
}

{
  __assert_rtn("terminate", "kdu_threads.cpp", 910, "root->num_unassigned_jobs == root->subtree_unassigned_jobs");
}

void kdu_thread_entity::add_jobs()
{
  __assert_rtn("add_jobs", "kdu_threads.cpp", 669, "(delta_primary_jobs >= 0) && (num_jobs >= 0)");
}

{
  __assert_rtn("add_jobs", "kdu_threads.cpp", 688, "delta_secondary_jobs > 0");
}

{
  __assert_rtn("add_jobs", "kdu_threads.cpp", 766, "(best_thread_idx > 0) && (group->thread_activity[best_thread_idx]==NULL)");
}

{
  __assert_rtn("add_jobs", "kdu_threads.cpp", 714, "(queue->num_runnable_jobs + queue->num_primary_jobs) == queue->num_unassigned_jobs");
}

{
  __assert_rtn("add_jobs", "kdu_threads.cpp", 697, "secondary_seq != 0");
}

{
  __assert_rtn("add_jobs", "kdu_threads.cpp", 653, "num_jobs >= 0");
}

void kdu_thread_entity::synchronize()
{
  __assert_rtn("synchronize", "kdu_threads.cpp", 829, "(root->num_sync_points > 0) && (root->sync_points[0].synchronizing_thread_idx==thread_idx) && root->check_condition(true,thread_idx)");
}

{
  __assert_rtn("synchronize", "kdu_threads.cpp", 821, "(root->num_sync_points == 0) || (root->sync_points[0].synchronizing_thread_idx!=thread_idx)");
}

{
  __assert_rtn("synchronize", "kdu_threads.cpp", 808, "(root->children != NULL) || ((root->num_unassigned_jobs+root->first_unassigned_job_idx)==0)");
}

void kdu_thread_entity::process_jobs()
{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1185, "!is_group_owner()");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1186, "group->thread_activity[thread_idx] != NULL");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1210, "run_queue->prescheduled_job_idx >= 0");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1241, "group->num_threads > 1");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1276, "run_queue->prescheduled_job_idx >= 0");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1334, "last_queue->num_active_jobs > 0");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1415, "sp->synchronization_downcounter > 0");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1435, "last_queue->thread_awaiting_complete != this->thread_idx");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1444, "run_queue == NULL");
}

{
  __assert_rtn("check_condition", "threads_local.h", 93, "num_primary_jobs == 0");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1419, "sp->num_unsynchronized_children == 0");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1396, "last_queue->num_active_jobs == 0");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1360, "(last_queue->parent->num_sync_points > 0) && (last_queue->parent->sync_points[0].num_unsynchronized_children>0)");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1317, "run_queue->num_active_jobs == 0");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1284, "(run_queue->num_unassigned_jobs > 0) && (run_queue->num_runnable_jobs > 0)");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1215, "group->num_idle_threads > 0");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1200, "run_queue != KD_THREAD_ACTIVE");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1153, "(wait_queue->num_sync_points > 0) && (wait_queue->sync_points[0].synchronizing_thread_idx== this->thread_idx)");
}

{
  __assert_rtn("process_jobs", "kdu_threads.cpp", 1096, "(wait_queue != NULL) || !is_group_owner()");
}

void kdu_thread_queue::check_condition()
{
  __assert_rtn("check_condition", "threads_local.h", 88, "num_sync_points > 0");
}

void kdu_thread_entity::process_outstanding_sync_points()
{
  __assert_rtn("process_outstanding_sync_points", "kdu_threads.cpp", 1027, "sp->synchronized_worker == NULL");
}

{
  __assert_rtn("process_outstanding_sync_points", "kdu_threads.cpp", 1078, "(parent->num_sync_points > 0) && (parent->sync_points[0].num_unsynchronized_children > 0) && (parent->sync_points[0].synchronization_downcounter == 0)");
}

{
  __assert_rtn("process_outstanding_sync_points", "kdu_threads.cpp", 1049, "n < group->num_threads");
}

void kdu_channel_mapping::set_num_channels()
{
  __assert_rtn("set_num_channels", "kdu_region_decompressor.cpp", 1498, "num >= 0");
}

void kdu_channel_mapping::configure()
{
  __assert_rtn("configure", "kdu_region_decompressor.cpp", 1614, "num_entries <= 1024");
}

{
  __assert_rtn("configure", "kdu_region_decompressor.cpp", 1618, "palette[c] == NULL");
}

void kdu_channel_mapping::add_alpha_to_configuration()
{
  __assert_rtn("add_alpha_to_configuration", "kdu_region_decompressor.cpp", 1713, "num_entries <= 1024");
}

{
  __assert_rtn("add_alpha_to_configuration", "kdu_region_decompressor.cpp", 1717, "palette[c] == NULL");
}

void kdu_region_decompressor::add_component()
{
  __assert_rtn("add_component", "kdu_region_decompressor.cpp", 1822, "(off >= 0) && (off < num_components)");
}

void kdu_region_decompressor::open_tile()
{
  __assert_rtn("open_tile", "kdu_region_decompressor.cpp", 2217, "(full_render_dims & render_dims) == render_dims");
}

{
  __assert_rtn("open_tile", "kdu_region_decompressor.cpp", 2136, "!tile_open");
}

void kdu_line_buf::pre_create()
{
  __assert_rtn("pre_create", "kdu_sample_processing.h", 334, "(!pre_created) && (this->allocator == NULL)");
}

void kdu_sample_allocator::finalize()
{
  __assert_rtn("finalize", "kdu_sample_processing.h", 176, "pre_creation_phase");
}

{
  __assert_rtn("finalize", "kdu_sample_processing.h", 185, "(bytes_reserved == 0) || (buffer != NULL)");
}

void kdu_region_decompressor::close_tile()
{
  __assert_rtn("close_tile", "kdu_region_decompressor.cpp", 2303, "tile_open");
}

void transfer_fixed_point()
{
  __assert_rtn("transfer_fixed_point", "kdu_region_decompressor.cpp", 1135, "num_samples <= src->get_width()");
}

{
  __assert_rtn("transfer_fixed_point", "kdu_region_decompressor.cpp", 1209, "(sp != NULL) && !src->is_absolute()");
}

{
  __assert_rtn("transfer_fixed_point", "kdu_region_decompressor.cpp", 1139, "(sp != NULL) && !src->is_absolute()");
}

{
  __assert_rtn("transfer_fixed_point", "kdu_region_decompressor.cpp", 1289, "num_samples <= src->get_width()");
}

{
  __assert_rtn("transfer_fixed_point", "kdu_region_decompressor.cpp", 1381, "(sp != NULL) && !src->is_absolute()");
}

{
  __assert_rtn("transfer_fixed_point", "kdu_region_decompressor.cpp", 1293, "(sp != NULL) && !src->is_absolute()");
}

void kdu_sample_allocator::pre_alloc()
{
  __assert_rtn("pre_alloc", "kdu_sample_processing.h", 163, "pre_creation_phase");
}

void kdu_sample_allocator::alloc16()
{
  __assert_rtn("alloc16", "kdu_sample_processing.h", 206, "bytes_used <= bytes_reserved");
}

{
  __assert_rtn("alloc16", "kdu_sample_processing.h", 201, "!pre_creation_phase");
}

void kdu_sample_allocator::alloc32()
{
  __assert_rtn("alloc32", "kdu_sample_processing.h", 221, "bytes_used <= bytes_reserved");
}

{
  __assert_rtn("alloc32", "kdu_sample_processing.h", 216, "!pre_creation_phase");
}

void kdu_block::set_max_samples()
{
  __assert_rtn("set_max_samples", "blocks.cpp", 225, "!(alignment & 3)");
}

void kd_block::start_buffering()
{
  __assert_rtn("start_buffering", "compressed_local.h", 3526, "first_buf == NULL");
}

{
  __assert_rtn("start_buffering", "compressed_local.h", 3529, "first_buf == NULL");
}

void kd_block::put_byte()
{
  __assert_rtn("put_byte", "compressed_local.h", 3533, "current_buf != NULL");
}

{
  __assert_rtn("put_byte", "compressed_local.h", 3540, "current_buf != NULL");
}

void kd_block::retrieve_data()
{
  __assert_rtn("retrieve_data", "blocks.cpp", 556, "idx > 0");
}

{
  __assert_rtn("retrieve_data", "blocks.cpp", 535, "block->num_passes == (int) p_idx");
}

void kd_block::store_data()
{
  __assert_rtn("store_data", "blocks.cpp", 586, "block->missing_msbs < 255");
}

{
  __assert_rtn("store_data", "blocks.cpp", 587, "block->num_passes <= 255");
}

{
  __assert_rtn("store_data", "blocks.cpp", 604, "(val >= 0) && (val < (1<<16))");
}

{
  __assert_rtn("store_data", "blocks.cpp", 609, "total_bytes <= block->max_bytes");
}

{
  __assert_rtn("store_data", "blocks.cpp", 588, "first_buf == NULL");
}

{
  __assert_rtn("store_data", "blocks.cpp", 585, "block->modes == (int) modes");
}

{
  __assert_rtn("store_data", "blocks.cpp", 638, "block->missing_msbs < 255");
}

{
  __assert_rtn("store_data", "blocks.cpp", 639, "block->num_passes <= 255");
}

{
  __assert_rtn("store_data", "blocks.cpp", 656, "(val >= 0) && (val < (1<<16))");
}

{
  __assert_rtn("store_data", "blocks.cpp", 661, "total_bytes <= block->max_bytes");
}

{
  __assert_rtn("store_data", "blocks.cpp", 640, "first_buf == NULL");
}

void kd_block::get_byte()
{
  __assert_rtn("get_byte", "compressed_local.h", 3549, "current_buf != NULL");
}

void kd_block::start_packet()
{
  __assert_rtn("start_packet", "blocks.cpp", 810, "test_length < (1<<16)");
}

void kd_block::write_packet_header()
{
  __assert_rtn("write_packet_header", "blocks.cpp", 850, "(included && (layer_w < 0xFFFF)) || ((!included) && (layer_w == 0xFFFF))");
}

{
  __assert_rtn("write_packet_header", "blocks.cpp", 1044, "total_bytes == (int) temp_length");
}

{
  __assert_rtn("write_packet_header", "blocks.cpp", 1041, "segment_bytes < (1<<length_bits)");
}

{
  __assert_rtn("write_packet_header", "blocks.cpp", 1005, "total_bytes == (int) temp_length");
}

{
  __assert_rtn("write_packet_header", "blocks.cpp", 955, "val == 0");
}

void kd_block::write_body_bytes()
{
  __assert_rtn("write_body_bytes", "blocks.cpp", 1076, "scan != NULL");
}

{
  __assert_rtn("write_body_bytes", "blocks.cpp", 1085, "(xfer_bytes > 0) && (scan != NULL)");
}

void kd_block::build_tree()
{
  __assert_rtn("build_tree", "blocks.cpp", 1107, "total_nodes >= 0");
}

{
  __assert_rtn("build_tree", "blocks.cpp", 1153, "node == (blocks+total_nodes)");
}

{
  __assert_rtn("build_tree", "blocks.cpp", 1148, "(x==0) && (y==0)");
}

void kd_block::save_output_tree()
{
  __assert_rtn("save_output_tree", "blocks.cpp", 1216, "node->current_buf != NULL");
}

void mq_encoder::start()
{
  __assert_rtn("start", "mq_encoder.cpp", 108, "buffer != NULL");
}

{
  __assert_rtn("start", "mq_encoder.cpp", 107, "(prev == NULL) && (next == NULL)");
}

{
  __assert_rtn("start", "mq_encoder.cpp", 106, "buf_start == NULL");
}

{
  __assert_rtn("start", "mq_encoder.cpp", 105, "!active");
}

void mq_encoder::terminate()
{
  __assert_rtn("terminate", "mq_encoder.cpp", 136, "active");
}

{
  __assert_rtn("terminate", "mq_encoder.cpp", 215, "buf_next == buf_limit");
}

{
  __assert_rtn("terminate", "mq_encoder.cpp", 183, "t==0");
}

{
  __assert_rtn("terminate", "mq_encoder.cpp", 137, "!checked_out");
}

void mq_encoder::transfer_byte()
{
  __assert_rtn("transfer_byte", "mq_encoder.cpp", 328, "!checked_out");
}

void mq_encoder::find_truncation_point()
{
  __assert_rtn("find_truncation_point", "mq_encoder.cpp", 296, "F_min <= 5");
}

{
  __assert_rtn("find_truncation_point", "mq_encoder.cpp", 265, "buf_next < limit");
}

{
  __assert_rtn("find_truncation_point", "mq_encoder.cpp", 232, "!truncation_point_found");
}

{
  __assert_rtn("find_truncation_point", "mq_encoder.cpp", 231, "!active");
}

void mq_encoder::mq_encode()
{
  __assert_rtn("mq_encode", "mq_encoder.cpp", 366, "MQ_segment && active && (!checked_out) && ((symbol==0) || (symbol==KDU_INT32_MIN))");
}

void mq_encoder::mq_encode_run()
{
  __assert_rtn("mq_encode_run", "mq_encoder.cpp", 412, "MQ_segment && active && !checked_out");
}

void kd_create_dwt_description()
{
  __assert_rtn("kd_create_dwt_description", "codestream.cpp", 148, "c == num_coeffs");
}

{
  __assert_rtn("kd_create_dwt_description", "codestream.cpp", 144, "0");
}

{
  __assert_rtn("kd_create_dwt_description", "codestream.cpp", 128, "0");
}

{
  __assert_rtn("kd_create_dwt_description", "codestream.cpp", 179, "0");
}

void kd_input::process_unexpected_marker()
{
  __assert_rtn("process_unexpected_marker", "codestream.cpp", 298, "throw_markers");
}

{
  __assert_rtn("process_unexpected_marker", "codestream.cpp", 336, "!exhausted");
}

void kd_input::read()
{
  __assert_rtn("read", "codestream.cpp", 360, "xfer_bytes > 0");
}

void kd_input::ignore()
{
  __assert_rtn("ignore", "codestream.cpp", 405, "xfer_bytes > 0");
}

void kd_compressed_input::load_buf()
{
  __assert_rtn("load_buf", "codestream.cpp", 496, "(suspend_ptr>=first_unread) && (suspend_ptr<=first_unwritten)");
}

{
  __assert_rtn("load_buf", "codestream.cpp", 495, "alt_first_unwritten == NULL");
}

{
  __assert_rtn("load_buf", "codestream.cpp", 468, "first_unwritten == first_unread");
}

void kd_compressed_input::set_tileheader_scope()
{
  __assert_rtn("set_tileheader_scope", "codestream.cpp", 568, "xfer_bytes >= 0");
}

void kd_compressed_input::seek()
{
  __assert_rtn("seek", "codestream.cpp", 580, "!throw_markers");
}

void kd_buf_server::release()
{
  __assert_rtn("release", "codestream.cpp", 1805, "num_allocated_pages > 0");
}

void kd_buf_server::get()
{
  __assert_rtn("get", "codestream.cpp", 1757, "num_allocated_pages == total_pages");
}

void kd_pph_input::load_buf()
{
  __assert_rtn("load_buf", "codestream.cpp", 735, "buf_bytes >= 0");
}

{
  __assert_rtn("load_buf", "codestream.cpp", 730, "read_buf != NULL");
}

void kd_marker::read()
{
  __assert_rtn("read", "codestream.cpp", 778, "source != NULL");
}

{
  __assert_rtn("read", "codestream.cpp", 804, "valid_code");
}

void kd_pp_markers::add_marker()
{
  __assert_rtn("add_marker", "codestream.cpp", 973, "elt->get_code() == KDU_PPT");
}

{
  __assert_rtn("add_marker", "codestream.cpp", 968, "(list == NULL) || is_ppm");
}

{
  __assert_rtn("add_marker", "codestream.cpp", 974, "(list == NULL) || !is_ppm");
}

void kd_pp_markers::advance_list()
{
  __assert_rtn("advance_list", "codestream.cpp", 1102, "(list != NULL) && (list->bytes_read == list->get_length())");
}

void kd_tlm_generator::add_tpart_length()
{
  __assert_rtn("add_tpart_length", "codestream.cpp", 1164, "(tnum >= 0) && (tnum < num_tiles)");
}

{
  __assert_rtn("add_tpart_length", "codestream.cpp", 1163, "elt_ctr < num_elts");
}

void kd_tlm_generator::write_dummy_tlms()
{
  __assert_rtn("write_dummy_tlms", "codestream.cpp", 1192, "z_tlm <= 255");
}

{
  __assert_rtn("write_dummy_tlms", "codestream.cpp", 1205, "check_tlm_bytes == tlm_bytes");
}

void kd_tlm_generator::write_tlms()
{
  __assert_rtn("write_tlms", "codestream.cpp", 1233, "z_tlm <= 255");
}

void kd_tpart_pointer_server::add_tlm_marker()
{
  __assert_rtn("add_tlm_marker", "codestream.cpp", 1319, "copy_source.get_code() == KDU_TLM");
}

void kd_tpart_pointer_server::add_tpart()
{
  __assert_rtn("add_tpart", "codestream.cpp", 1376, "0");
}

void kd_tpart_pointer_server::translate_markers()
{
  __assert_rtn("translate_markers", "codestream.cpp", 1387, "groups == NULL");
}

void kd_precinct_pointer_server::record_byte()
{
  __assert_rtn("record_byte", "compressed_local.h", 1134, "tail != NULL");
}

void kd_thread_buf_server::augment_local_store()
{
  __assert_rtn("augment_local_store", "codestream.cpp", 1892, "env->codestream != NULL");
}

void kd_thread_env::flush()
{
  __assert_rtn("flush", "codestream.cpp", 1984, "num_outstanding_blocks == 0");
}

{
  __assert_rtn("flush", "codestream.cpp", 2071, "num_outstanding_blocks == 0");
}

{
  __assert_rtn("flush", "codestream.cpp", 2047, "precinct->num_outstanding_blocks == 1");
}

{
  __assert_rtn("flush", "codestream.cpp", 2027, "have_complete_precincts");
}

{
  __assert_rtn("flush", "codestream.cpp", 2010, "scan->target_precinct->num_outstanding_blocks > 0");
}

void kdu_thread_entity::try_lock()
{
  __assert_rtn("try_lock", "kdu_threads.h", 924, "(lock_id>=0) && (lock_id<num_locks) && (lock->holder != this)");
}

void kd_global_rescomp::add_ready_precinct()
{
  __assert_rtn("add_ready_precinct", "codestream.cpp", 2825, "(precinct->prev == NULL) && (precinct->next == NULL) && (precinct != first_ready)");
}

void kd_packet_sequencer::init()
{
  __assert_rtn("init", "codestream.cpp", 2180, "tile->initialized");
}

void kd_packet_sequencer::next_progression()
{
  __assert_rtn("next_progression", "codestream.cpp", 2293, "state.poc != NULL");
}

{
  __assert_rtn("next_progression", "codestream.cpp", 2295, "state.poc != NULL");
}

{
  __assert_rtn("next_progression", "codestream.cpp", 2305, "0");
}

void kd_packet_sequencer::restore_state()
{
  __assert_rtn("restore_state", "codestream.cpp", 2260, "state_saved");
}

void kd_packet_sequencer::next_in_sequence()
{
  __assert_rtn("next_in_sequence", "codestream.cpp", 2438, "0");
}

void kd_packet_sequencer::next_in_lrcp()
{
  __assert_rtn("next_in_lrcp", "codestream.cpp", 2489, "((precinct != NULL) && (precinct->next_layer_idx >= state.layer_idx)) || (state.layer_idx == 0)");
}

void kd_packet_sequencer::next_in_rlcp()
{
  __assert_rtn("next_in_rlcp", "codestream.cpp", 2529, "((precinct != NULL) && (precinct->next_layer_idx >= state.layer_idx)) || (state.layer_idx == 0)");
}

void kd_global_rescomp::notify_tile_status()
{
  __assert_rtn("notify_tile_status", "codestream.cpp", 2812, "(area_covered_by_tiles <= total_area) && (remaining_area >= 0)");
}

void kd_global_rescomp::close_ready_precinct()
{
  __assert_rtn("close_ready_precinct", "codestream.cpp", 2863, "precinct == last_ready");
}

{
  __assert_rtn("close_ready_precinct", "codestream.cpp", 2856, "precinct == first_ready");
}

void kd_codestream_comment::set_text()
{
  __assert_rtn("set_text", "codestream.cpp", 2902, "!readonly");
}

void kd_mct_stage::create_stages()
{
  __assert_rtn("create_stages", "codestream.cpp", 3135, "0");
}

{
  __assert_rtn("create_stages", "codestream.cpp", 3114, "0");
}

{
  __assert_rtn("create_stages", "codestream.cpp", 3099, "0");
}

void kd_mct_stage::apply_output_restrictions()
{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3396, "global_comp_info != NULL");
}

{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3598, "num_required_inputs == 0");
}

{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3582, "unset_inputs > 0");
}

{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3586, "unset_inputs == 0");
}

{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3564, "unset_inputs > 0");
}

{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3468, "(oci->apparent_idx >= 0) && (oci->block == block)");
}

{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3421, "oci->apparent_idx == comps_of_interest[n]");
}

{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3447, "num_apparent_outputs == next_stage->num_required_inputs");
}

{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3439, "next_stage->input_required_indices[n]==oci->apparent_idx");
}

{
  __assert_rtn("apply_output_restrictions", "codestream.cpp", 3428, "(global_comp_info == NULL) && (num_outputs == next_stage->num_inputs)");
}

void kd_mct_block::analyze_sensitivity()
{
  __assert_rtn("analyze_sensitivity", "codestream.cpp", 3657, "0");
}

void kd_mct_block::create_rxform_ss_model()
{
  __assert_rtn("create_rxform_ss_model", "codestream.cpp", 3744, "s == N");
}

{
  __assert_rtn("create_rxform_ss_model", "codestream.cpp", 3717, "N==num_outputs");
}

void kd_mct_block::create_dependency_ss_model()
{
  __assert_rtn("create_dependency_ss_model", "codestream.cpp", 3793, "m == (int) model->range_min");
}

{
  __assert_rtn("create_dependency_ss_model", "codestream.cpp", 3773, "N==num_outputs");
}

void kd_mct_block::create_dwt_ss_model()
{
  __assert_rtn("create_dwt_ss_model", "codestream.cpp", 3848, "(range_min >= synth_min) && (range_max <= synth_max)");
}

{
  __assert_rtn("create_dwt_ss_model", "codestream.cpp", 3988, "band_start_idx == num_inputs");
}

{
  __assert_rtn("create_dwt_ss_model", "codestream.cpp", 3852, "range_min == range_max");
}

{
  __assert_rtn("create_dwt_ss_model", "codestream.cpp", 3955, "step_coeffs == dwt_coefficients");
}

{
  __assert_rtn("create_dwt_ss_model", "codestream.cpp", 3871, "range_min == range_max");
}

{
  __assert_rtn("create_dwt_ss_model", "codestream.cpp", 3878, "!((range_min|range_max) & synth_gap)");
}

{
  __assert_rtn("create_dwt_ss_model", "codestream.cpp", 3824, "N==num_outputs");
}

void kd_codestream::construct_common()
{
  __assert_rtn("construct_common", "codestream.cpp", 4019, "0");
}

void kd_codestream::read_main_header()
{
  __assert_rtn("read_main_header", "codestream.cpp", 4666, "tile_span == tile_indices.size");
}

void kd_codestream::construct_output_comp_info()
{
  __assert_rtn("construct_output_comp_info", "codestream.cpp", 4275, "0");
}

{
  __assert_rtn("construct_output_comp_info", "codestream.cpp", 4240, "output_comp_info == NULL");
}

void kd_codestream::restrict_to_fragment()
{
  __assert_rtn("restrict_to_fragment", "codestream.cpp", 4367, "out != NULL");
}

{
  __assert_rtn("restrict_to_fragment", "codestream.cpp", 4398, "current_fragment_tiles > 0");
}

{
  __assert_rtn("restrict_to_fragment", "codestream.cpp", 4413, "(idx_min == tile_indices.pos) && (canvas == fragment_region) && initial_fragment && final_fragment");
}

void kd_codestream::restart()
{
  __assert_rtn("restart", "codestream.cpp", 4466, "tile_refs != NULL");
}

{
  __assert_rtn("restart", "codestream.cpp", 4490, "typ->tile_ref == NULL");
}

{
  __assert_rtn("restart", "codestream.cpp", 4475, "tref->tile != KD_EXPIRED_TILE");
}

void kd_codestream::create_tile()
{
  __assert_rtn("create_tile", "codestream.cpp", 4804, "tp == NULL");
}

{
  __assert_rtn("create_tile", "codestream.cpp", 4801, "(rel_idx.x >= 0) && (rel_idx.x < tile_indices.size.x) && (rel_idx.y >= 0) && (rel_idx.y < tile_indices.size.y)");
}

void kd_codestream::simulate_output()
{
  __assert_rtn("simulate_output", "codestream.cpp", 4919, "!finalize_layer");
}

{
  __assert_rtn("simulate_output", "codestream.cpp", 5015, "!finalize_layer");
}

{
  __assert_rtn("simulate_output", "codestream.cpp", 4991, "slope_threshold < 0xFFFF");
}

{
  __assert_rtn("simulate_output", "codestream.cpp", 4998, "packet_max_bytes >= packet_bytes");
}

{
  __assert_rtn("simulate_output", "codestream.cpp", 5003, "packet_bytes <= packet_max_bytes");
}

{
  __assert_rtn("simulate_output", "codestream.cpp", 4990, "finalize_layer && last_layer && (local_sloppy >= 0)");
}

{
  __assert_rtn("simulate_output", "codestream.cpp", 4946, "T <= (rc->remaining_area + rc->ready_area)");
}

{
  __assert_rtn("simulate_output", "codestream.cpp", 4937, "(rc->remaining_area > 0) && (rc->remaining_area >= rc->ready_area)");
}

void kd_codestream::calculate_min_header_cost()
{
  __assert_rtn("calculate_min_header_cost", "codestream.cpp", 5094, "total_area >= tile_area");
}

{
  __assert_rtn("calculate_min_header_cost", "codestream.cpp", 5078, "(abs_idx.x < tile_span.x) && (abs_idx.y < tile_span.y)");
}

{
  __assert_rtn("calculate_min_header_cost", "codestream.cpp", 5058, "min_fixed_header_size == 0");
}

void kd_codestream::pcrd_opt()
{
  __assert_rtn("pcrd_opt", "codestream.cpp", 5169, "adjusted_last_target > 0.0");
}

{
  __assert_rtn("pcrd_opt", "codestream.cpp", 5242, "threshold < (1<<16)");
}

{
  __assert_rtn("pcrd_opt", "codestream.cpp", 5284, "last_layer");
}

{
  __assert_rtn("pcrd_opt", "codestream.cpp", 5200, "last_layer");
}

{
  __assert_rtn("pcrd_opt", "codestream.cpp", 5161, "last_idx == -1");
}

{
  __assert_rtn("pcrd_opt", "codestream.cpp", 5150, "next_idx == (num_sized_layers-1)");
}

void kd_codestream::generate_codestream()
{
  __assert_rtn("generate_codestream", "codestream.cpp", 5298, "out != NULL");
}

{
  __assert_rtn("generate_codestream", "codestream.cpp", 5301, "(layer_sizes != NULL) && (layer_thresholds != NULL)");
}

{
  __assert_rtn("generate_codestream", "codestream.cpp", 5330, "org != NULL");
}

{
  __assert_rtn("generate_codestream", "codestream.cpp", 5371, "header_length == 0");
}

{
  __assert_rtn("generate_codestream", "codestream.cpp", 5368, "header_length == 0");
}

{
  __assert_rtn("generate_codestream", "codestream.cpp", 5329, "!tlm_generator");
}

void kd_codestream::unload_tiles_to_cache_threshold()
{
  __assert_rtn("unload_tiles_to_cache_threshold", "codestream.cpp", 5422, "unloadable_tile_scan->is_unloadable");
}

void kdu_codestream::create()
{
  __assert_rtn("create", "codestream.cpp", 5446, "(state == NULL) && (target != NULL)");
}

{
  __assert_rtn("create", "codestream.cpp", 5465, "state == NULL");
}

void kdu_codestream::destroy()
{
  __assert_rtn("destroy", "codestream.cpp", 5640, "state != NULL");
}

void kdu_codestream::set_max_bytes()
{
  __assert_rtn("set_max_bytes", "codestream.cpp", 5777, "!state->tiles_accessed");
}

void kdu_codestream::apply_input_restrictions()
{
  __assert_rtn("apply_input_restrictions", "codestream.cpp", 5958, "0");
}

{
  __assert_rtn("apply_input_restrictions", "codestream.cpp", 6021, "0");
}

void kdu_codestream::get_tile_dims()
{
  __assert_rtn("get_tile_dims", "codestream.cpp", 6061, "(tile_idx.x >= 0) && (tile_idx.x < state->tile_span.x) && (tile_idx.y >= 0) && (tile_idx.y < state->tile_span.y)");
}

void kdu_codestream::open_tile()
{
  __assert_rtn("open_tile", "codestream.cpp", 6502, "tp->tile_ref == tref");
}

{
  __assert_rtn("open_tile", "codestream.cpp", 6494, "state->allow_restart && (tref->tpart_head == NULL)");
}

{
  __assert_rtn("open_tile", "codestream.cpp", 6485, "(rel_idx.x >= 0) && (rel_idx.x < state->tile_indices.size.x) && (rel_idx.y >= 0) && (rel_idx.y < state->tile_indices.size.y)");
}

{
  __assert_rtn("open_tile", "codestream.cpp", 6481, "(tile_idx.x >= 0) && (tile_idx.x < state->tile_span.x) && (tile_idx.y >= 0) && (tile_idx.y < state->tile_span.y)");
}

void kdu_codestream::flush()
{
  __assert_rtn("flush", "codestream.cpp", 6561, "(state->out != NULL) && (num_layer_specs > 0)");
}

{
  __assert_rtn("flush", "codestream.cpp", 6569, "(state->layer_thresholds==NULL) && (state->layer_sizes==NULL)");
}

{
  __assert_rtn("flush", "codestream.cpp", 6583, "(state->layer_thresholds!=NULL) && (state->layer_sizes!=NULL)");
}

void kdu_codestream::ready_for_flush()
{
  __assert_rtn("ready_for_flush", "codestream.cpp", 6823, "precinct != NULL");
}

void kdu_kernels::expand_and_convolve()
{
  __assert_rtn("expand_and_convolve", "kernels.cpp", 183, "dst_L <= work_L");
}

{
  __assert_rtn("expand_and_convolve", "kernels.cpp", 182, "(dp == work1) || (dp == work2)");
}

{
  __assert_rtn("expand_and_convolve", "kernels.cpp", 181, "(sp == work1) || (sp == work2)");
}

void kdu_kernels::derive_taps_and_gains()
{
  __assert_rtn("derive_taps_and_gains", "kernels.cpp", 366, "(branch_min[index] >= -work_L) && (branch_max[index] <= work_L)");
}

void kdu_kernels::get_impulse_response()
{
  __assert_rtn("get_impulse_response", "kernels.cpp", 487, "0");
}

void kdu_kernels::get_energy_gain()
{
  __assert_rtn("get_energy_gain", "kernels.cpp", 500, "(num_extra_stages >= 0) && (num_extra_stages <= 3)");
}

{
  __assert_rtn("get_energy_gain", "kernels.cpp", 538, "half_len <= work_L");
}

void kdu_kernels::get_bibo_gain()
{
  __assert_rtn("get_bibo_gain", "kernels.cpp", 565, "(num_extra_stages >= 0) && (num_extra_stages <= 3)");
}

{
  __assert_rtn("get_bibo_gain", "kernels.cpp", 623, "rec->bibo_gain == high_gain");
}

{
  __assert_rtn("get_bibo_gain", "kernels.cpp", 603, "rec->bibo_gain == low_gain");
}

{
  __assert_rtn("get_bibo_gain", "kernels.cpp", 630, "(record_idx == 0) && (rec != NULL)");
}

void jp2_target::open(jp2_target *this, jp2_output_box *a2)
{
  __assert_rtn("open", "jp2.h", 3489, "0");
}

void jp2_target::open(jp2_target *this)
{
  __assert_rtn("open", "jp2.h", 3498, "0");
}

void jp2_family_src::open()
{
  __assert_rtn("open", "jp2.cpp", 432, "fp_name == NULL");
}

void jp2_input_box::read_box_header()
{
  __assert_rtn("read_box_header", "jp2.cpp", 578, "!have_placeholder");
}

void jp2_input_box::open()
{
  __assert_rtn("open", "jp2.cpp", 747, "target_pos >= 0");
}

void jp2_input_box::open_next()
{
  __assert_rtn("open_next", "jp2.cpp", 903, "locator.bin_id >= 0");
}

void jp2_input_box::is_complete()
{
  __assert_rtn("is_complete", "jp2.cpp", 1017, "(bin_id >= 0) && (bin_class >= 0)");
}

void jp2_input_box::read()
{
  __assert_rtn("read", "jp2.cpp", 1145, "src->seekable");
}

{
  __assert_rtn("read", "jp2.cpp", 1246, "partial_word_bytes < 4");
}

{
  __assert_rtn("read", "jp2.cpp", 1250, "partial_word_bytes == 4");
}

{
  __assert_rtn("read", "jp2.cpp", 1274, "partial_word_bytes == 2");
}

void jp2_output_box::open()
{
  __assert_rtn("open", "jp2.cpp", 1381, "!rubber_length");
}

{
  __assert_rtn("open", "jp2.cpp", 1389, "(buffer == NULL) && (buffer_size == 0)");
}

{
  __assert_rtn("open", "jp2.cpp", 1430, "super_box->rubber_length && super_box->write_immediately");
}

{
  __assert_rtn("open", "jp2.cpp", 1416, "(buffer == NULL) && (buffer_size == 0)");
}

void jp2_output_box::write_header()
{
  __assert_rtn("write_header", "jp2.cpp", 1461, "(box_type != 0) && ((tgt != NULL) || (super_box != NULL))");
}

{
  __assert_rtn("write_header", "jp2.cpp", 1462, "write_immediately");
}

{
  __assert_rtn("write_header", "jp2.cpp", 1463, "restore_size < 0");
}

{
  __assert_rtn("write_header", "jp2.cpp", 1473, "box_size >= 0");
}

{
  __assert_rtn("write_header", "jp2.cpp", 1467, "!write_header_on_close");
}

void jp2_output_box::set_rubber_length()
{
  __assert_rtn("set_rubber_length", "jp2.cpp", 1510, "box_type != 0");
}

{
  __assert_rtn("set_rubber_length", "jp2.cpp", 1547, "0");
}

void jp2_output_box::set_target_size()
{
  __assert_rtn("set_target_size", "jp2.cpp", 1575, "box_type != 0");
}

{
  __assert_rtn("set_target_size", "jp2.cpp", 1602, "0");
}

void jp2_output_box::write_header_last()
{
  __assert_rtn("write_header_last", "jp2.cpp", 1643, "write_immediately");
}

void jp2_output_box::close()
{
  __assert_rtn("close", "jp2.cpp", 1722, "0");
}

{
  __assert_rtn("close", "jp2.cpp", 1716, "0");
}

{
  __assert_rtn("close", "jp2.cpp", 1690, "0");
}

{
  __assert_rtn("close", "jp2.cpp", 1696, "buffer == NULL");
}

void jp2_output_box::end_rewrite()
{
  __assert_rtn("end_rewrite", "jp2.cpp", 1785, "advance >= 0");
}

{
  __assert_rtn("end_rewrite", "jp2.cpp", 1812, "0");
}

{
  __assert_rtn("end_rewrite", "jp2.cpp", 1809, "0");
}

{
  __assert_rtn("end_rewrite", "jp2.cpp", 1804, "0");
}

void jp2_output_box::write()
{
  __assert_rtn("write", "jp2.cpp", 1863, "restore_size < 0");
}

{
  __assert_rtn("write", "jp2.cpp", 1856, "0");
}

void jp2_dimensions::init()
{
  __assert_rtn("init", "jp2.cpp", 2133, "state != NULL");
}

{
  __assert_rtn("init", "jp2.cpp", 2137, "num_components > 0");
}

void j2_dimensions::init()
{
  __assert_rtn("init", "jp2.cpp", 1957, "ihdr->get_box_type() == jp2_image_header_4cc");
}

void jp2_dimensions::set_precision()
{
  __assert_rtn("set_precision", "jp2.cpp", 2274, "(state != NULL) && (component_idx >= 0) && (component_idx < state->num_components)");
}

void jp2_dimensions::get_size()
{
  __assert_rtn("get_size", "jp2.cpp", 2296, "state != NULL");
}

void jp2_dimensions::get_bit_depth()
{
  __assert_rtn("get_bit_depth", "jp2.cpp", 2330, "(state != NULL) && (component_idx >= 0) && (component_idx < state->num_components)");
}

void jp2_dimensions::get_signed()
{
  __assert_rtn("get_signed", "jp2.cpp", 2343, "(state != NULL) && (component_idx >= 0) && (component_idx < state->num_components)");
}

void j2_palette::init()
{
  __assert_rtn("init", "jp2.cpp", 2478, "(entry_bytes <= 5) && (entry_bytes > 0)");
}

{
  __assert_rtn("init", "jp2.cpp", 2433, "pclr->get_box_type() == jp2_palette_4cc");
}

void jp2_palette::get_num_entries()
{
  __assert_rtn("get_num_entries", "jp2.cpp", 2678, "state != NULL");
}

void jp2_palette::get_num_luts()
{
  __assert_rtn("get_num_luts", "jp2.cpp", 2689, "state != NULL");
}

void jp2_palette::get_bit_depth()
{
  __assert_rtn("get_bit_depth", "jp2.cpp", 2701, "(state != NULL) && (comp_idx >= 0) && (comp_idx < state->num_components)");
}

void jp2_palette::get_signed()
{
  __assert_rtn("get_signed", "jp2.cpp", 2714, "(state != NULL) && (comp_idx >= 0) && (comp_idx < state->num_components)");
}

void jp2_palette::get_lut()
{
  __assert_rtn("get_lut", "jp2.cpp", 2741, "(state != NULL) && (comp_idx >= 0) && (comp_idx < state->num_components)");
}

void j2_component_map::init()
{
  __assert_rtn("init", "jp2.cpp", 2800, "cmap->get_box_type() == jp2_component_mapping_4cc");
}

void j2_component_map::init_missing_cmap()
{
  __assert_rtn("init_missing_cmap", "jp2.cpp", 2848, "(cmap_channels == NULL) && (num_cmap_channels == 0)");
}

void j2_component_map::finalize()
{
  __assert_rtn("get_num_components", "jp2.cpp", 2307, "state != NULL");
}

{
  __assert_rtn("finalize", "jp2.cpp", 2913, "num_cmap_channels == 0");
}

void j2_component_map::add_cmap_channel()
{
  __assert_rtn("add_cmap_channel", "jp2.cpp", 2962, "dimensions.exists() && palette.exists()");
}

{
  __assert_rtn("add_cmap_channel", "jp2.cpp", 2986, "use_cmap_box");
}

void j2_channels::init()
{
  __assert_rtn("init", "jp2.cpp", 3178, "0");
}

void j2_channels::finalize()
{
  __assert_rtn("finalize", "jp2.cpp", 3266, "channels->cmap_channel[c] >= 0");
}

void j2_channels::find_cmap_channels()
{
  __assert_rtn("find_cmap_channels", "jp2.cpp", 3350, "c > 0");
}

{
  __assert_rtn("find_cmap_channels", "jp2.cpp", 3377, "cp->bit_depth > 0");
}

void j2_channels::add_cmap_channels()
{
  __assert_rtn("add_cmap_channels", "jp2.cpp", 3419, "cp->cmap_channel[c] < 0");
}

{
  __assert_rtn("add_cmap_channels", "jp2.cpp", 3430, "c == 0");
}

void j2_channels::save_box()
{
  __assert_rtn("save_box", "jp2.cpp", 3486, "!have_chroma_key");
}

{
  __assert_rtn("save_box", "jp2.cpp", 3480, "!have_chroma_key");
}

{
  __assert_rtn("save_box", "jp2.cpp", 3456, "chroma_key_buf == NULL");
}

void jp2_channels::init()
{
  __assert_rtn("init", "jp2.cpp", 3650, "state != NULL");
}

void jp2_channels::set_colour_mapping()
{
  __assert_rtn("set_colour_mapping", "jp2.cpp", 3670, "(state != NULL) && (colour_idx >= 0) && (colour_idx < state->num_colours)");
}

void jp2_channels::set_opacity_mapping()
{
  __assert_rtn("set_opacity_mapping", "jp2.cpp", 3687, "(state != NULL) && (colour_idx >= 0) && (colour_idx < state->num_colours)");
}

void jp2_channels::set_premult_mapping()
{
  __assert_rtn("set_premult_mapping", "jp2.cpp", 3704, "(state != NULL) && (colour_idx >= 0) && (colour_idx < state->num_colours)");
}

void jp2_channels::get_num_colours()
{
  __assert_rtn("get_num_colours", "jp2.cpp", 3730, "state != NULL");
}

void jp2_channels::get_opacity_mapping()
{
  __assert_rtn("get_opacity_mapping", "jp2.cpp", 3765, "(state != NULL) && (colour_idx >= 0) && (colour_idx < state->num_colours)");
}

void jp2_channels::get_premult_mapping()
{
  __assert_rtn("get_premult_mapping", "jp2.cpp", 3783, "(state != NULL) && (colour_idx >= 0) && (colour_idx < state->num_colours)");
}

void j2_resolution::init()
{
  __assert_rtn("init", "jp2.cpp", 3850, "res->is_complete()");
}

void j2_resolution::parse_sub_box()
{
  __assert_rtn("parse_sub_box", "jp2.cpp", 3926, "0");
}

void jp2_resolution::init()
{
  __assert_rtn("init", "jp2.cpp", 4042, "state != NULL");
}

void jp2_resolution::set_resolution()
{
  __assert_rtn("set_resolution", "jp2.cpp", 4064, "(state != NULL) && (state->display_ratio > 0.0F)");
}

void j2_colour::init()
{
  __assert_rtn("init", "jp2.cpp", 4689, "meth == 4");
}

{
  __assert_rtn("init", "jp2.cpp", 4613, "0");
}

{
  __assert_rtn("init", "jp2.cpp", 4611, "colr->get_box_type() == jp2_colour_4cc");
}

void j2_colour::finalize()
{
  __assert_rtn("finalize", "jp2.cpp", 4791, "(space == JP2_CIELab_SPACE) || (space == JP2_CIEJab_SPACE)");
}

void j2_colour::save_box()
{
  __assert_rtn("save_box", "jp2.cpp", 4831, "initialized");
}

void jp2_colour::init()
{
  __assert_rtn("init", "jp2.cpp", 4928, "state != NULL");
}

{
  __assert_rtn("init", "jp2.cpp", 5020, "state != NULL");
}

void jp2_colour::get_num_colours()
{
  __assert_rtn("get_num_colours", "jp2.cpp", 5412, "state != NULL");
}

void jp2_colour::get_space()
{
  __assert_rtn("get_space", "jp2.cpp", 5423, "state != NULL");
}

void jp2_colour::is_opponent_space()
{
  __assert_rtn("is_opponent_space", "jp2.cpp", 5434, "state != NULL");
}

void jp2_colour::get_precedence()
{
  __assert_rtn("get_precedence", "jp2.cpp", 5455, "state != NULL");
}

void j2_colour_converter::j2_colour_converter()
{
  __assert_rtn("j2_colour_converter", "jp2.cpp", 5632, "colour->num_colours > 0");
}

{
  __assert_rtn("j2_colour_converter", "jp2.cpp", 5772, "!skip_primary_matrix");
}

void j2_colour_converter::configure_d65_primary_transform()
{
  __assert_rtn("configure_d65_primary_transform", "jp2.cpp", 5957, "gamma < 1.0");
}

{
  __assert_rtn("configure_d65_primary_transform", "jp2.cpp", 5951, "(srgb_curve == NULL) && (tone_curves[0] == NULL) && (tone_curves[1] == NULL) && (tone_curves[2] == NULL)");
}

void j2_colour_converter::configure_lab_transform()
{
  __assert_rtn("configure_lab_transform", "jp2.cpp", 6234, "0");
}

{
  __assert_rtn("configure_lab_transform", "jp2.cpp", 6178, "srgb_curve == NULL");
}

{
  __assert_rtn("configure_lab_transform", "jp2.cpp", 6156, "tone_curves[0] == NULL");
}

void jp2_colour_converter::convert_lum()
{
  __assert_rtn("convert_lum", "jp2.cpp", 6328, "width <= line.get_width()");
}

{
  __assert_rtn("convert_lum", "jp2.cpp", 6331, "(sp != NULL) && !line.is_absolute()");
}

void jp2_colour_converter::convert_rgb()
{
  __assert_rtn("convert_rgb", "jp2.cpp", 6399, "lut1 != NULL");
}

{
  __assert_rtn("convert_rgb", "jp2.cpp", 6362, "(width <= red.get_width()) && (width <= green.get_width()) && (width <= blue.get_width())");
}

void jp2_colour_converter::convert_rgb4()
{
  __assert_rtn("convert_rgb4", "jp2.cpp", 6500, "(width <= red.get_width()) && (width <= green.get_width()) && (width <= blue.get_width())");
}

void jp2_target::write_header()
{
  __assert_rtn("write_header", "jp2.cpp", 7011, "header != NULL");
}

{
  __assert_rtn("write_header", "jp2.cpp", 7010, "!header_written");
}

void jp2_target::access_dimensions()
{
  __assert_rtn("access_dimensions", "jp2.cpp", 7052, "header != NULL");
}

void jp2_target::access_colour()
{
  __assert_rtn("access_colour", "jp2.cpp", 7063, "header != NULL");
}

void jp2_target::access_channels()
{
  __assert_rtn("access_channels", "jp2.cpp", 7085, "header != NULL");
}

void jp2_target::access_resolution()
{
  __assert_rtn("access_resolution", "jp2.cpp", 7096, "header != NULL");
}

void j2_component_map::verify_channel_query_idx()
{
  __assert_rtn("verify_channel_query_idx", "jp2_shared.h", 326, "dimensions.exists()");
}

void kd_attribute::describe()
{
  __assert_rtn("describe", "params.cpp", 678, "cp != NULL");
}

void kdu_params::link()
{
  __assert_rtn("link", "params.cpp", 900, "(tile_idx == -1) && (comp_idx == -1)");
}

{
  __assert_rtn("link", "params.cpp", 938, "refs != &dummy_ref");
}

{
  __assert_rtn("link", "params.cpp", 876, "(this->tile_idx == -1) && (this->comp_idx == -1) && (this->inst_idx == 0) && (this->refs == &this->dummy_ref) && (tile_idx < num_tiles) && (comp_idx < num_comps) && (tile_idx >= -1) && (comp_idx >= -1)");
}

void kdu_params::add_dependency()
{
  __assert_rtn("add_dependency", "params.cpp", 976, "0");
}

void kdu_params::copy_from()
{
  __assert_rtn("copy_from", "params.cpp", 1076, "dst != NULL");
}

{
  __assert_rtn("copy_from", "params.cpp", 1050, "target->tile_idx == target_tile");
}

void kdu_params::access_relation()
{
  __assert_rtn("access_relation", "params.cpp", 1398, "result->num_comps == 0");
}

{
  __assert_rtn("access_relation", "params.cpp", 1335, "tile_idx >= 0");
}

void kdu_params::get()
{
  __assert_rtn("get", "params.cpp", 1519, "(record_idx >= 0) && (field_idx >= 0)");
}

{
  __assert_rtn("get", "params.cpp", 1588, "(record_idx >= 0) && (field_idx >= 0)");
}

{
  __assert_rtn("get", "params.cpp", 1657, "(record_idx >= 0) && (field_idx >= 0)");
}

void kdu_params::set()
{
  __assert_rtn("set", "params.cpp", 1724, "(record_idx >= 0) && (field_idx >= 0)");
}

{
  __assert_rtn("set", "params.cpp", 1799, "(*cp == 'I') || (*cp == 'C')");
}

{
  __assert_rtn("set", "params.cpp", 1806, "(record_idx >= 0) && (record_idx < ap->num_records)");
}

{
  __assert_rtn("set", "params.cpp", 1832, "(record_idx >= 0) && (field_idx >= 0)");
}

{
  __assert_rtn("set", "params.cpp", 1868, "(record_idx >= 0) && (record_idx < ap->num_records)");
}

{
  __assert_rtn("set", "params.cpp", 1894, "(record_idx >= 0) && (field_idx >= 0)");
}

{
  __assert_rtn("set", "params.cpp", 1930, "(record_idx >= 0) && (record_idx < ap->num_records)");
}

void kdu_params::parse_string()
{
  __assert_rtn("parse_string", "params.cpp", 2328, "0");
}

{
  __assert_rtn("parse_string", "params.cpp", 2117, "next_inst != NULL");
}

void display_options()
{
  __assert_rtn("display_options", "params.cpp", 274, "0");
}

{
  __assert_rtn("display_options", "params.cpp", 252, "*pattern == ')'");
}

{
  __assert_rtn("display_options", "params.cpp", 268, "*pattern == ']'");
}

void kdu_params::textualize_attributes()
{
  __assert_rtn("textualize_attributes", "params.cpp", 2476, "0");
}

{
  __assert_rtn("textualize_attributes", "params.cpp", 2452, "val == att->ival");
}

{
  __assert_rtn("textualize_attributes", "params.cpp", 2473, "acc == att->ival");
}

void kdu_params::generate_marker_segments()
{
  __assert_rtn("generate_marker_segments", "params.cpp", 2814, "new_bytes >= 4");
}

{
  __assert_rtn("generate_marker_segments", "params.cpp", 2776, "(comp->comp_idx == -1) && (c >= 0)");
}

{
  __assert_rtn("generate_marker_segments", "params.cpp", 2778, "(comp==cluster->refs[ref_idx]) && (comp->comp_idx==c)");
}

void siz_params::copy_with_xforms()
{
  __assert_rtn("copy_with_xforms", "params.cpp", 3280, "(exponent.x >= 0) && (exponent.y >= 0)");
}

void siz_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 3419, "(xto >= 0) && (yto >= 0)");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 3512, "acc_length == cbd_length");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 3487, "acc_length == siz_length");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 3315, "last_marked == NULL");
}

void find_lcm()
{
  __assert_rtn("find_lcm", "params.cpp", 151, "(m > 0) && (n > 0)");
}

void kdu_read()
{
  __assert_rtn("kdu_read", "kdu_utils.h", 74, "nbytes <= 4");
}

void siz_params::finalize()
{
  __assert_rtn("finalize", "params.cpp", 3778, "have_dims && have_size");
}

void mct_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 4391, "length == acc_length");
}

void mcc_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 4885, "length == acc_length");
}

void mco_params::copy_with_xforms()
{
  __assert_rtn("copy_with_xforms", "params.cpp", 4964, "mcc != NULL");
}

void mco_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 5161, "length == acc_length");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 5137, "0");
}

void atk_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 5755, "length == acc_length");
}

void cod_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 6241, "siz != NULL");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 6401, "length == acc_length");
}

void cod_params::read_marker_segment()
{
  __assert_rtn("read_marker_segment", "params.cpp", 6500, "siz != NULL");
}

void cod_params::finalize()
{
  __assert_rtn("finalize", "params.cpp", 6827, "comp_idx < 0");
}

{
  __assert_rtn("finalize", "params.cpp", 6837, "siz != NULL");
}

{
  __assert_rtn("finalize", "params.cpp", 6846, "0");
}

{
  __assert_rtn("finalize", "params.cpp", 6817, "!get(Cblk,0,1,val)");
}

{
  __assert_rtn("finalize", "params.cpp", 6756, "0");
}

{
  __assert_rtn("finalize", "params.cpp", 6609, "!get(Calign_blk_last,0,1,val)");
}

void cod_params::derive_decomposition_structure()
{
  __assert_rtn("derive_decomposition_structure", "params.cpp", 6992, "dfs != NULL");
}

void cod_params::validate_dfs_data()
{
  __assert_rtn("validate_dfs_data", "params.cpp", 7119, "0");
}

void cod_params::validate_ads_data()
{
  __assert_rtn("validate_ads_data", "params.cpp", 7067, "0");
}

void cod_params::textualize_decomp()
{
  __assert_rtn("textualize_decomp", "params.cpp", 7177, "(bp-buf) <= 20");
}

void cod_params::expand_decomp_bands()
{
  __assert_rtn("expand_decomp_bands", "params.cpp", 7426, "num_bands <= 49");
}

void ads_params::finalize()
{
  __assert_rtn("finalize", "params.cpp", 7610, "(n == 0) || cod_params::is_valid_decomp_terminator(val)");
}

void ads_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 7697, "length == acc_length");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 7631, "(ref->tile_idx < 0) && (ref->inst_idx == this->inst_idx)");
}

void dfs_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 7963, "length == acc_length");
}

void qcd_params::copy_with_xforms()
{
  __assert_rtn("copy_with_xforms", "params.cpp", 8067, "0");
}

{
  __assert_rtn("copy_with_xforms", "params.cpp", 8110, "b_in < num_level_bands");
}

{
  __assert_rtn("copy_with_xforms", "params.cpp", 8090, "0");
}

void qcd_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 8149, "cod != NULL");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 8252, "siz != NULL");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 8312, "length == acc_length");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 8190, "ref_cod != NULL");
}

void qcd_params::read_marker_segment()
{
  __assert_rtn("read_marker_segment", "params.cpp", 8375, "siz != NULL");
}

void qcd_params::finalize()
{
  __assert_rtn("finalize", "params.cpp", 8458, "cod != NULL");
}

{
  __assert_rtn("finalize", "params.cpp", 8460, "cod != NULL");
}

{
  __assert_rtn("finalize", "params.cpp", 8477, "0");
}

{
  __assert_rtn("finalize", "params.cpp", 8603, "0");
}

{
  __assert_rtn("finalize", "params.cpp", 8617, "0");
}

{
  __assert_rtn("finalize", "params.cpp", 8473, "0");
}

{
  __assert_rtn("finalize", "params.cpp", 8466, "0");
}

void rgn_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 8749, "length == acc_length");
}

void poc_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 8964, "0");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 9040, "length == acc_length");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 8932, "(ref->tile_idx < 0) && (inst_idx == 0)");
}

void poc_params::read_marker_segment()
{
  __assert_rtn("read_marker_segment", "params.cpp", 9075, "0");
}

void crg_params::copy_with_xforms()
{
  __assert_rtn("copy_with_xforms", "params.cpp", 9156, "(source_siz != NULL) && (target_siz != NULL)");
}

{
  __assert_rtn("copy_with_xforms", "params.cpp", 9173, "(fact_x > 0) && (fact_y > 0)");
}

{
  __assert_rtn("copy_with_xforms", "params.cpp", 9166, "0");
}

void crg_params::write_marker_segment()
{
  __assert_rtn("write_marker_segment", "params.cpp", 9216, "0");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 9250, "length == acc_length");
}

{
  __assert_rtn("write_marker_segment", "params.cpp", 9211, "last_marked == NULL");
}

void crg_params::read_marker_segment()
{
  __assert_rtn("read_marker_segment", "params.cpp", 9284, "0");
}

void mq_decoder::start()
{
  __assert_rtn("start", "mq_decoder.cpp", 102, "(buffer != NULL) && (segment_length >= 0)");
}

{
  __assert_rtn("start", "mq_decoder.cpp", 101, "buf_start == NULL");
}

{
  __assert_rtn("start", "mq_decoder.cpp", 100, "!active");
}

void mq_decoder::finish()
{
  __assert_rtn("finish", "mq_decoder.cpp", 142, "active && !checked_out");
}

{
  __assert_rtn("finish", "mq_decoder.cpp", 149, "buf_next == (buf_start+segment_length+1)");
}

void mq_decoder::mq_decode()
{
  __assert_rtn("mq_decode", "mq_decoder.cpp", 219, "MQ_segment && active && !checked_out");
}

void mq_decoder::mq_decode_run()
{
  __assert_rtn("mq_decode_run", "mq_decoder.cpp", 272, "MQ_segment && active && !checked_out");
}

void kd_block_encoder::encode()
{
  __assert_rtn("encode", "block_encoder.cpp", 1203, "block->max_samples >= ((num_stripes<<2)*num_cols)");
}

{
  __assert_rtn("encode", "block_encoder.cpp", 1279, "available_bytes >= segment_bytes");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 858, "shift > 0");
}

{
  __assert_rtn("encode", "block_encoder.cpp", 1473, "first_unsized_z == block->num_passes");
}

{
  __assert_rtn("encode", "block_encoder.cpp", 1472, "segment_passes == 0");
}

{
  __assert_rtn("encode", "block_encoder.cpp", 1467, "first_unsized_z == (z+1)");
}

{
  __assert_rtn("encode", "block_encoder.cpp", 1457, "final");
}

{
  __assert_rtn("encode", "block_encoder.cpp", 1379, "first_unsized_z == t");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 1038, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 1017, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 1003, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 984, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 970, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 951, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 920, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 901, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_cleanup_pass", "block_encoder.cpp", 883, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_mag_ref_pass", "block_encoder.cpp", 825, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_mag_ref_pass", "block_encoder.cpp", 805, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_mag_ref_pass", "block_encoder.cpp", 785, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_mag_ref_pass", "block_encoder.cpp", 765, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_sig_prop_pass_raw", "block_encoder.cpp", 292, "shift > 0");
}

{
  __assert_rtn("encode_sig_prop_pass", "block_encoder.cpp", 427, "shift > 0");
}

{
  __assert_rtn("encode_sig_prop_pass", "block_encoder.cpp", 585, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_sig_prop_pass", "block_encoder.cpp", 565, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_sig_prop_pass", "block_encoder.cpp", 551, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_sig_prop_pass", "block_encoder.cpp", 533, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_sig_prop_pass", "block_encoder.cpp", 519, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_sig_prop_pass", "block_encoder.cpp", 501, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_sig_prop_pass", "block_encoder.cpp", 470, "A < MQE_A_MIN");
}

{
  __assert_rtn("encode_sig_prop_pass", "block_encoder.cpp", 452, "A < MQE_A_MIN");
}

void mq_encoder::augment_buffer()
{
  __assert_rtn("augment_buffer", "mq_encoder.h", 160, "(!checked_out) && (old_handle != NULL) && (new_handle != NULL)");
}

void mq_encoder::continues()
{
  __assert_rtn("continues", "mq_encoder.h", 170, "previous->active");
}

{
  __assert_rtn("continues", "mq_encoder.h", 171, "!previous->checked_out");
}

{
  __assert_rtn("continues", "mq_encoder.h", 169, "(!active) && (buf_start == NULL)");
}

void mq_encoder::get_bytes_used()
{
  __assert_rtn("get_bytes_used", "mq_encoder.h", 147, "(!checked_out) && (buf_start != NULL)");
}

void mq_encoder::finish()
{
  __assert_rtn("finish", "mq_encoder.h", 241, "!scan->active");
}

{
  __assert_rtn("finish", "mq_encoder.h", 237, "(!active) && (next == NULL)");
}

void mq_encoder::check_out()
{
  __assert_rtn("check_out", "mq_encoder.h", 252, "active && (!checked_out) && MQ_segment");
}

{
  __assert_rtn("check_out", "mq_encoder.h", 258, "active && (!checked_out) && !MQ_segment");
}

void mq_encoder::check_in()
{
  __assert_rtn("check_in", "mq_encoder.h", 264, "active && checked_out && MQ_segment");
}

{
  __assert_rtn("check_in", "mq_encoder.h", 270, "active && checked_out && !MQ_segment");
}

void kd_block_decoder::decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0("check_out", "mq_decoder.h", a3, "active && (!checked_out) && MQ_segment");
}

void kd_block_decoder::decode()
{
  __assert_rtn("check_out", "mq_decoder.h", 140, "active && (!checked_out) && !MQ_segment");
}

void kd_decoder::init()
{
  __assert_rtn("init", "decoder.cpp", 272, "num_per_row < block_indices.size.x");
}

{
  __assert_rtn("init", "decoder.cpp", 233, "(this->allocator == NULL) && (this->queue == NULL)");
}

void kd_decoder::pull()
{
  __assert_rtn("pull", "decoder.cpp", 381, "(queue == NULL) || (env != NULL)");
}

{
  __assert_rtn("pull", "decoder.cpp", 420, "buffered_line_lim <= buffer_height");
}

{
  __assert_rtn("pull", "decoder.cpp", 444, "buffer_height > nominal_block_height");
}

{
  __assert_rtn("pull", "decoder.cpp", 425, "line.get_width() == (subband_cols+pull_offset)");
}

{
  __assert_rtn("pull", "decoder.cpp", 411, "num_jobs_per_row == 1");
}

{
  __assert_rtn("pull", "decoder.cpp", 400, "buffer_height > nominal_block_height");
}

void kd_decoder::do_job()
{
  __assert_rtn("do_job", "decoder.cpp", 490, "blocks_remaining > 0");
}

{
  __assert_rtn("do_job", "decoder.cpp", 483, "idx.y < (block_indices.pos.y + block_indices.size.y)");
}

void kd_analysis::init()
{
  __assert_rtn("init", "analysis.cpp", 177, "child[LL_BAND].exists()");
}

{
  __assert_rtn("init", "analysis.cpp", 445, "ns == num_hor_steps");
}

{
  __assert_rtn("init", "analysis.cpp", 443, "ns == num_vert_steps");
}

{
  __assert_rtn("init", "analysis.cpp", 380, "extend < 256");
}

{
  __assert_rtn("init", "analysis.cpp", 365, "step->coeffs[n] == coefficients[n]");
}

void kd_vlift_queue::simulate_push_line()
{
  __assert_rtn("simulate_push_line", "transform_local.h", 218, "((idx ^ queue_idx) & 1) == 0");
}

void kd_vlift_queue::simulate_access_update()
{
  __assert_rtn("simulate_access_update", "transform_local.h", 232, "(((idx ^ queue_idx) & 1) == 0) && (idx >= update_pos)");
}

void kd_vlift_queue::simulate_access_source()
{
  __assert_rtn("simulate_access_source", "transform_local.h", 246, "(((idx ^ queue_idx) & 1) == 0) && (idx >= source_pos)");
}

void kd_analysis::push()
{
  __assert_rtn("push", "analysis.cpp", 673, "y_next <= y_max");
}

{
  __assert_rtn("push", "analysis.cpp", 695, "vline_in != NULL");
}

{
  __assert_rtn("push", "analysis.cpp", 863, "vline_out != NULL");
}

{
  __assert_rtn("push", "analysis.cpp", 826, "(num_vert_steps > 0) && !unit_height");
}

{
  __assert_rtn("push", "analysis.cpp", 802, "vert_xform_exists");
}

{
  __assert_rtn("push", "analysis.cpp", 708, "line.get_width() == (coset_width[0]+coset_width[1])");
}

{
  __assert_rtn("push", "analysis.cpp", 674, "reversible == line.is_absolute()");
}

void kd_vlift_queue::push_line()
{
  __assert_rtn("push_line", "transform_local.h", 140, "idx == (tail_idx+2)");
}

{
  __assert_rtn("push_line", "transform_local.h", 127, "((idx ^ queue_idx) & 1) == 0");
}

void kd_analysis::horizontal_analysis()
{
  __assert_rtn("horizontal_analysis", "analysis.cpp", 930, "hor_xform_exists");
}

{
  __assert_rtn("horizontal_analysis", "analysis.cpp", 926, "(coset_width[0] == line->cosets[0].get_width()) && (coset_width[1] == line->cosets[1].get_width())");
}

void kd_vlift_queue::access_update()
{
  __assert_rtn("access_update", "transform_local.h", 157, "(((idx ^ queue_idx) & 1) == 0) && (idx >= update_pos)");
}

{
  __assert_rtn("access_update", "transform_local.h", 163, "result != NULL");
}

void kd_vlift_queue::access_source()
{
  __assert_rtn("access_source", "transform_local.h", 186, "(((idx ^ queue_idx) & 1) == 0) && (idx >= source_pos)");
}

void kd_synthesis::init()
{
  __assert_rtn("init", "synthesis.cpp", 172, "child[LL_BAND].exists()");
}

{
  __assert_rtn("init", "synthesis.cpp", 551, "ns == num_hor_steps");
}

{
  __assert_rtn("init", "synthesis.cpp", 549, "ns == num_vert_steps");
}

{
  __assert_rtn("init", "synthesis.cpp", 463, "extend < 256");
}

{
  __assert_rtn("init", "synthesis.cpp", 448, "step->coeffs[n] == coefficients[n]");
}

{
  __assert_rtn("init", "synthesis.cpp", 325, "(lfill[0] >= 0) && (rfill[0] >= 0) && (lfill[0] < 256) && (rfill[0] < 256) && (lfill[1] >= 0) && (rfill[1] >= 0) && (lfill[1] < 256) && (rfill[1] < 256)");
}

{
  __assert_rtn("init", "synthesis.cpp", 298, "min_in[1] == max_in[1]");
}

{
  __assert_rtn("init", "synthesis.cpp", 291, "min_in[0] == max_in[0]");
}

{
  __assert_rtn("init", "synthesis.cpp", 243, "y_min_in[1] == y_max_in[1]");
}

void kd_synthesis::simulate_vertical_lifting()
{
  __assert_rtn("simulate_vertical_lifting", "synthesis.cpp", 769, "step->next_row_pos == y_next_in[vsub_parity]");
}

void kd_synthesis::pull()
{
  __assert_rtn("pull", "synthesis.cpp", 838, "y_next_out <= y_max_out");
}

{
  __assert_rtn("pull", "synthesis.cpp", 988, "src_off == 0");
}

{
  __assert_rtn("pull", "synthesis.cpp", 922, "step->next_row_pos == y_next_in[vsub_parity]");
}

void kd_encoder::init()
{
  __assert_rtn("init", "encoder.cpp", 266, "num_per_row < block_indices.size.x");
}

{
  __assert_rtn("init", "encoder.cpp", 229, "(this->allocator == NULL) && (this->queue == NULL)");
}

void kd_encoder::push()
{
  __assert_rtn("push", "encoder.cpp", 355, "(queue == NULL) || (env != NULL)");
}

{
  __assert_rtn("push", "encoder.cpp", 381, "subband_rows > 0");
}

{
  __assert_rtn("push", "encoder.cpp", 388, "queue != NULL");
}

{
  __assert_rtn("push", "encoder.cpp", 400, "free_line_lim <= buffer_height");
}

{
  __assert_rtn("push", "encoder.cpp", 456, "free_line_lim <= buffer_height");
}

{
  __assert_rtn("push", "encoder.cpp", 447, "num_jobs_per_row == 1");
}

{
  __assert_rtn("push", "encoder.cpp", 438, "free_line_lim <= nominal_block_height");
}

{
  __assert_rtn("push", "encoder.cpp", 404, "line.get_width() == subband_cols");
}

void kd_encoder::do_job()
{
  __assert_rtn("do_job", "encoder.cpp", 492, "blocks_remaining > 0");
}

{
  __assert_rtn("do_job", "encoder.cpp", 519, "num_samples > 0");
}

{
  __assert_rtn("do_job", "encoder.cpp", 531, "(xfer_size.x+offset) <= subband_cols");
}

{
  __assert_rtn("do_job", "encoder.cpp", 717, "downshift >= K_max");
}

{
  __assert_rtn("do_job", "encoder.cpp", 622, "upshift >= 0");
}

{
  __assert_rtn("do_job", "encoder.cpp", 528, "(xfer_size.x == block->region.size.x) && (xfer_size.y == block->region.size.y) && (0 == block->region.pos.x) && (0 == block->region.pos.y)");
}

{
  __assert_rtn("do_job", "encoder.cpp", 485, "idx.y < (block_indices.pos.y + block_indices.size.y)");
}

void kd_multi_line::reset()
{
  __assert_rtn("reset", "multi_transform.cpp", 110, "0");
}

{
  __assert_rtn("reset", "multi_transform.cpp", 90, "line.is_absolute() == reversible");
}

void kd_multi_line::copy()
{
  __assert_rtn("copy", "multi_transform.cpp", 193, "src->reversible");
}

{
  __assert_rtn("copy", "multi_transform.cpp", 186, "src->size.x == size.x");
}

void kd_multi_transform::construct()
{
  __assert_rtn("construct", "multi_transform.cpp", 518, "(n < block->num_dependencies) && (src_line != NULL)");
}

{
  __assert_rtn("construct", "multi_transform.cpp", 522, "tgt_line->reversible == src_line->reversible");
}

{
  __assert_rtn("construct", "multi_transform.cpp", 521, "src_line->bypass == NULL");
}

{
  __assert_rtn("construct", "multi_transform.cpp", 489, "line->is_constant && !line->reversible");
}

{
  __assert_rtn("construct", "multi_transform.cpp", 378, "collection->num_components == num_stage_inputs");
}

{
  __assert_rtn("construct", "multi_transform.cpp", 309, "0");
}

void kd_multi_transform::propagate_knowledge()
{
  __assert_rtn("propagate_knowledge", "multi_transform.cpp", 691, "have_xform_size");
}

{
  __assert_rtn("propagate_knowledge", "multi_transform.cpp", 676, "have_xform_size");
}

{
  __assert_rtn("propagate_knowledge", "multi_transform.cpp", 589, "block->num_dependencies <= block->num_components");
}

{
  __assert_rtn("propagate_knowledge", "multi_transform.cpp", 560, "codestream_collection->num_components >= 3");
}

void kd_multi_transform::create_resources()
{
  __assert_rtn("create_resources", "multi_transform.cpp", 819, "line->is_constant");
}

{
  __assert_rtn("create_resources", "multi_transform.cpp", 745, "codestream_collection->components[n] == &(comp->line)");
}

void kd_multi_synthesis::create()
{
  __assert_rtn("create", "multi_transform.cpp", 958, "comp->num_rows_in_progress <= comp->line.size.y");
}

void kd_multi_synthesis::terminate_queues()
{
  __assert_rtn("terminate_queues", "multi_transform.cpp", 906, "(env_queue != NULL) && (codestream_components[0].env_queue != NULL)");
}

void kd_multi_synthesis::get_size()
{
  __assert_rtn("get_size", "multi_transform.cpp", 973, "(comp_idx >= 0) && (comp_idx < output_collection->num_components)");
}

void kd_multi_synthesis::get_line()
{
  __assert_rtn("get_line", "multi_transform.cpp", 984, "(comp_idx >= 0) && (comp_idx < output_collection->num_components)");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1008, "line->outstanding_consumers > 0");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1075, "n >= 0");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1154, "(line->row_idx == tgt_row_idx) && (line->outstanding_consumers > 0)");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1114, "((comp->env_queue == NULL) && (env == NULL)) || ((comp->env_queue != NULL) && (env != NULL))");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1096, "(env != NULL) && (comp->num_rows_in_progress > 0)");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1083, "ycc_line->row_idx == (tgt_row_idx-1)");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1076, "codestream_collection->components[n] == line");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1066, "(scan->outstanding_consumers == 0) && (scan->row_idx == (tgt_row_idx-1))");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1057, "scan->row_idx == tgt_row_idx");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1026, "dep != NULL");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1025, "(n >= 0) && (n < block->num_dependencies)");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1016, "line->row_idx == (tgt_row_idx-1)");
}

{
  __assert_rtn("get_line", "multi_transform.cpp", 1003, "line->bypass == NULL");
}

void kd_multi_analysis::create()
{
  __assert_rtn("create", "multi_transform.cpp", 1287, "comp->num_available_rows <= comp->line.size.y");
}

void kd_multi_analysis::terminate_queues()
{
  __assert_rtn("terminate_queues", "multi_transform.cpp", 1236, "(env_queue != NULL) && (codestream_components[0].env_queue != NULL)");
}

void kd_multi_analysis::prepare_network_for_inversion()
{
  __assert_rtn("prepare_network_for_inversion", "multi_transform.cpp", 1327, "n < block->num_components");
}

void kd_multi_analysis::get_size()
{
  __assert_rtn("get_size", "multi_transform.cpp", 1306, "(comp_idx >= 0) && (comp_idx < output_collection->num_components)");
}

void kd_multi_analysis::exchange_line()
{
  __assert_rtn("exchange_line", "multi_transform.cpp", 1429, "line->row_idx == (row_idx-1)");
}

{
  __assert_rtn("exchange_line", "multi_transform.cpp", 1424, "(written == &(line->line)) && !line->waiting_for_inversion");
}

{
  __assert_rtn("exchange_line", "multi_transform.cpp", 1421, "line->num_consumers == 1");
}

{
  __assert_rtn("exchange_line", "multi_transform.cpp", 1416, "(comp_idx >= 0) && (comp_idx < output_collection->num_components)");
}

void kd_multi_analysis::advance_line()
{
  __assert_rtn("advance_line", "multi_transform.cpp", 1519, "n >= 0");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1538, "ycc_lines[n]->waiting_for_inversion");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1586, "!line->waiting_for_inversion");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1567, "((comp->env_queue == NULL) && (env == NULL)) || ((comp->env_queue != NULL) && (env != NULL))");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1549, "env != NULL");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1520, "codestream_collection->components[n] == line");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1511, "block->components[n].num_consumers == 1");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1496, "dep->num_consumers > 1");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1466, "(dep->num_consumers > 0) && !dep->is_constant");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1460, "dep->num_consumers > 1");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1456, "(n >= 0) && (n < block->num_dependencies)");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1445, "line->row_idx==(new_row_idx-1)");
}

{
  __assert_rtn("advance_line", "multi_transform.cpp", 1444, "line->num_consumers == 1");
}

void kd_multi_null_block::initialize()
{
  __assert_rtn("initialize", "multi_transform.cpp", 1645, "(num_stage_inputs == input_collection->num_components) && (num_stage_outputs == output_collection->num_components)");
}

void kd_multi_matrix_block::initialize()
{
  __assert_rtn("initialize", "multi_transform.cpp", 1709, "(num_stage_inputs == input_collection->num_components) && (num_stage_outputs == output_collection->num_components)");
}

void kd_multi_matrix_block::normalize_coefficients()
{
  __assert_rtn("normalize_coefficients", "multi_transform.cpp", 1768, "!line->is_constant");
}

void kd_multi_matrix_block::perform_transform()
{
  __assert_rtn("perform_transform", "multi_transform.cpp", 1860, "src_bit_depth > 0");
}

void kd_multi_matrix_block::prepare_for_inversion()
{
  __assert_rtn("prepare_for_inversion", "multi_transform.cpp", 1922, "work == NULL");
}

void kd_multi_matrix_block::perform_inverse()
{
  __assert_rtn("perform_inverse", "multi_transform.cpp", 2053, "inverse_coefficients != NULL");
}

void kd_multi_rxform_block::initialize()
{
  __assert_rtn("initialize", "multi_transform.cpp", 2219, "N >= num_block_outputs");
}

{
  __assert_rtn("initialize", "multi_transform.cpp", 2231, "(num_stage_inputs == input_collection->num_components) && (num_stage_outputs == output_collection->num_components)");
}

void kd_multi_rxform_block::perform_transform()
{
  __assert_rtn("perform_transform", "multi_transform.cpp", 2382, "n == N");
}

{
  __assert_rtn("perform_transform", "multi_transform.cpp", 2356, "n == N");
}

{
  __assert_rtn("perform_transform", "multi_transform.cpp", 2305, "num_dependencies == N");
}

void kd_multi_rxform_block::perform_inverse()
{
  __assert_rtn("perform_inverse", "multi_transform.cpp", 2480, "n == N");
}

{
  __assert_rtn("perform_inverse", "multi_transform.cpp", 2454, "n == N");
}

void kd_multi_dependency_block::initialize()
{
  __assert_rtn("initialize", "multi_transform.cpp", 2521, "N >= num_block_outputs");
}

{
  __assert_rtn("initialize", "multi_transform.cpp", 2577, "(f_cf-f_matrix) == (N*N)");
}

{
  __assert_rtn("initialize", "multi_transform.cpp", 2567, "!is_reversible");
}

{
  __assert_rtn("initialize", "multi_transform.cpp", 2545, "is_reversible");
}

{
  __assert_rtn("initialize", "multi_transform.cpp", 2556, "(i_cf-i_matrix) == (N*N)");
}

{
  __assert_rtn("initialize", "multi_transform.cpp", 2531, "(num_stage_inputs == input_collection->num_components) && (num_stage_outputs == output_collection->num_components)");
}

void kd_multi_dependency_block::normalize_coefficients()
{
  __assert_rtn("normalize_coefficients", "multi_transform.cpp", 2670, "N == num_dependencies");
}

void kd_multi_dependency_block::create_short_matrix()
{
  __assert_rtn("create_short_matrix", "multi_transform.cpp", 2723, "N == num_dependencies");
}

void kd_multi_dependency_block::perform_transform()
{
  __assert_rtn("perform_transform", "multi_transform.cpp", 2767, "num_dependencies == N");
}

void kd_multi_dependency_block::perform_inverse()
{
  __assert_rtn("perform_inverse", "multi_transform.cpp", 2941, "!(dep->reversible || line->reversible)");
}

{
  __assert_rtn("perform_inverse", "multi_transform.cpp", 2895, "num_dependencies == N");
}

void kd_multi_dwt_block::initialize()
{
  __assert_rtn("initialize", "multi_transform.cpp", 3043, "(step_info != NULL) && (num_levels > 0)");
}

{
  __assert_rtn("initialize", "multi_transform.cpp", 3097, "(loc >= canvas_min) && (loc < canvas_lim)");
}

{
  __assert_rtn("initialize", "multi_transform.cpp", 3033, "(num_stage_inputs == input_collection->num_components) && (num_stage_outputs == output_collection->num_components)");
}

void kd_multi_dwt_block::prepare_for_inversion()
{
  __assert_rtn("prepare_for_inversion", "multi_transform.cpp", 3342, "num_levels > 0");
}

void kd_multi_dwt_block::normalize_coefficients()
{
  __assert_rtn("normalize_coefficients", "multi_transform.cpp", 3410, "line->need_irreversible");
}

void kd_multi_dwt_block::perform_transform()
{
  __assert_rtn("perform_transform", "multi_transform.cpp", 3609, "lev->normalizing_shift == 0");
}

{
  __assert_rtn("perform_transform", "multi_transform.cpp", 3648, "0");
}

{
  __assert_rtn("perform_transform", "multi_transform.cpp", 3635, "(k >= 0) && (k < lev->region_size)");
}

void kd_multi_dwt_block::perform_inverse()
{
  __assert_rtn("perform_inverse", "multi_transform.cpp", 3810, "!dep->reversible");
}

{
  __assert_rtn("perform_inverse", "multi_transform.cpp", 3706, "lev->normalizing_shift == 0");
}

{
  __assert_rtn("perform_inverse", "multi_transform.cpp", 3784, "0");
}

{
  __assert_rtn("perform_inverse", "multi_transform.cpp", 3771, "(k >= 0) && (k < lev->region_size)");
}

void kdrc_overlay::set_buffer_surface()
{
  __assert_rtn("set_buffer_surface", "kdu_region_compositor.cpp", 545, "compositor != NULL");
}

{
  __assert_rtn("set_buffer_surface", "kdu_region_compositor.cpp", 629, "((head == NULL) && (tail == NULL)) || ((tail != NULL) && (tail->next == NULL))");
}

{
  __assert_rtn("set_buffer_surface", "kdu_region_compositor.cpp", 609, "next == NULL");
}

{
  __assert_rtn("set_buffer_surface", "kdu_region_compositor.cpp", 549, "(expansion_numerator.x > 0) && (expansion_numerator.y > 0) && (expansion_denominator.x > 0) && (expansion_denominator.y > 0)");
}

void kdrc_overlay::map_from_compositing_grid(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_1("long_floor_ratio", "kdu_utils.h", a3, "(num >= (kdu_long) KDU_INT32_MIN)");
}

{
  OUTLINED_FUNCTION_0_0("long_floor_ratio", "kdu_utils.h", a3, "(num <= (kdu_long) KDU_INT32_MAX)");
}

void kdrc_overlay::update_config()
{
  __assert_rtn("update_config", "kdu_region_compositor.cpp", 729, "scan == tail");
}

void kdrc_codestream::init()
{
  __assert_rtn("init", "kdu_region_compositor.cpp", 926, "!ifc");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 944, "!ifc");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 962, "!ifc");
}

void kdrc_codestream::restart()
{
  __assert_rtn("restart", "kdu_region_compositor.cpp", 982, "ifc.exists()");
}

void kdrc_codestream::attach()
{
  __assert_rtn("attach", "kdu_region_compositor.cpp", 1013, "!in_use");
}

{
  __assert_rtn("attach", "kdu_region_compositor.cpp", 1002, "head->prev_codestream_user == NULL");
}

{
  __assert_rtn("attach", "kdu_region_compositor.cpp", 997, "user->codestream == NULL");
}

void kdrc_codestream::detach()
{
  __assert_rtn("detach", "kdu_region_compositor.cpp", 1030, "user == head");
}

{
  __assert_rtn("detach", "kdu_region_compositor.cpp", 1037, "user != head");
}

{
  __assert_rtn("detach", "kdu_region_compositor.cpp", 1027, "user->codestream == this");
}

void kdrc_codestream::move_to_head()
{
  __assert_rtn("move_to_head", "kdu_region_compositor.cpp", 1092, "!in_use");
}

{
  __assert_rtn("move_to_head", "kdu_region_compositor.cpp", 1082, "head->prev_codestream_user == NULL");
}

{
  __assert_rtn("move_to_head", "kdu_region_compositor.cpp", 1062, "user == head");
}

{
  __assert_rtn("move_to_head", "kdu_region_compositor.cpp", 1069, "user != head");
}

{
  __assert_rtn("move_to_head", "kdu_region_compositor.cpp", 1057, "user->codestream == this");
}

void kdrc_codestream::move_to_tail()
{
  __assert_rtn("move_to_tail", "kdu_region_compositor.cpp", 1136, "!in_use");
}

{
  __assert_rtn("move_to_tail", "kdu_region_compositor.cpp", 1107, "user == head");
}

{
  __assert_rtn("move_to_tail", "kdu_region_compositor.cpp", 1114, "user != head");
}

{
  __assert_rtn("move_to_tail", "kdu_region_compositor.cpp", 1102, "user->codestream == this");
}

void kdrc_stream::init()
{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1230, "codestream == cs");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1217, "codestream == sibling->codestream");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1213, "codestream == NULL");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1206, "overlay == NULL");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1361, "mapping.num_channels == (mapping.num_colour_channels + ((have_alpha)?1:0))");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1279, "codestream == cs");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1266, "codestream == sibling->codestream");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1262, "codestream == NULL");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1254, "overlay == NULL");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1415, "codestream == cs");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1402, "codestream == sibling->codestream");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1398, "codestream == NULL");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 1382, "overlay == NULL");
}

void kdrc_stream::configure_subsampling()
{
  __assert_rtn("configure_subsampling", "kdu_region_compositor.cpp", 1561, "active_component >= 0");
}

void kdrc_stream::change_frame()
{
  __assert_rtn("change_frame", "kdu_region_compositor.cpp", 1480, "codestream == cs");
}

void kdrc_stream::set_error_level()
{
  __assert_rtn("set_error_level", "kdu_region_compositor.cpp", 1493, "(codestream != NULL) && (codestream->ifc.exists())");
}

void kdrc_stream::set_scale()
{
  __assert_rtn("set_scale", "kdu_region_compositor.cpp", 1805, "expansion_denominator.x > 0");
}

{
  __assert_rtn("set_scale", "kdu_region_compositor.cpp", 1820, "expansion_denominator.y > 0");
}

void kdrc_stream::set_buffer_surface()
{
  __assert_rtn("set_buffer_surface", "kdu_region_compositor.cpp", 2226, "have_valid_scale");
}

void kdrc_stream::process()
{
  __assert_rtn("process", "kdu_region_compositor.cpp", 2321, "buffer != NULL");
}

{
  __assert_rtn("process", "kdu_region_compositor.cpp", 2376, "!codestream->in_use");
}

void kdrc_stream::adjust_refresh()
{
  __assert_rtn("adjust_refresh", "kdu_region_compositor.cpp", 2522, "have_valid_scale");
}

{
  __assert_rtn("adjust_refresh", "kdu_region_compositor.cpp", 2537, "(left >= 0) && (right >= 0) && (top >= 0) && (bottom >= 0)");
}

void kdu_region_compositor::remove_stream()
{
  __assert_rtn("remove_stream", "kdu_region_compositor.cpp", 5943, "scan != NULL");
}

{
  __assert_rtn("remove_stream", "kdu_region_compositor.cpp", 5946, "(jpx_src != NULL) && single_component_box.exists()");
}

void kdrc_layer::init()
{
  __assert_rtn("init", "kdu_region_compositor.cpp", 2631, "(streams[0] == NULL) && (streams[1] == NULL)");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 2780, "stream_idx >= 0");
}

{
  __assert_rtn("init", "kdu_region_compositor.cpp", 2746, "(streams[0] == NULL) && (streams[1] == NULL)");
}

void kdu_region_compositor::add_active_stream()
{
  __assert_rtn("add_active_stream", "kdu_region_compositor.cpp", 5838, "raw_src == NULL");
}

{
  __assert_rtn("add_active_stream", "kdu_region_compositor.cpp", 5879, "0");
}

{
  __assert_rtn("add_active_stream", "kdu_region_compositor.cpp", 5873, "track != NULL");
}

void kdrc_layer::activate()
{
  __assert_rtn("activate", "kdu_region_compositor.cpp", 2899, "0");
}

{
  __assert_rtn("activate", "kdu_region_compositor.cpp", 2888, "overlay == NULL");
}

void kdrc_layer::set_buffer_surface()
{
  __assert_rtn("set_buffer_surface", "kdu_region_compositor.cpp", 3122, "!read_access_required");
}

{
  __assert_rtn("set_buffer_surface", "kdu_region_compositor.cpp", 3124, "(next == NULL) && (prev == NULL) && (whole_region == visible_region) && (overlay_buffer == NULL)");
}

void kdu_region_compositor::donate_compositing_buffer()
{
  __assert_rtn("donate_compositing_buffer", "kdu_region_compositor.cpp", 5744, "(active_layers != NULL) && active_layers->have_overlay_info");
}

{
  __assert_rtn("donate_compositing_buffer", "kdu_region_compositor.cpp", 5743, "this->buffer_region == buffer_region");
}

{
  __assert_rtn("donate_compositing_buffer", "kdu_region_compositor.cpp", 5742, "this->composition_buffer == NULL");
}

void kdrc_layer::update_overlay()
{
  __assert_rtn("update_overlay", "kdu_region_compositor.cpp", 3366, "(next == NULL) && (prev == NULL) && (overlay_buffer == NULL)");
}

void kdrc_layer::process_overlay()
{
  __assert_rtn("process_overlay", "kdu_region_compositor.cpp", 3431, "!have_alpha_channel");
}

void kdu_region_compositor::retract_compositing_buffer()
{
  __assert_rtn("retract_compositing_buffer", "kdu_region_compositor.cpp", 5756, "active_layers != NULL");
}

void kdrc_layer::update_composition()
{
  __assert_rtn("update_composition", "kdu_region_compositor.cpp", 3540, "have_valid_scale && (buffer != NULL)");
}

{
  __assert_rtn("update_composition", "kdu_region_compositor.cpp", 3579, "(bytesPerPixel == 4) && (compositingBytesPP == 4)");
}

void kdu_region_compositor::remove_compositing_layer()
{
  __assert_rtn("remove_compositing_layer", "kdu_region_compositor.cpp", 4363, "scan == last_active_layer");
}

{
  __assert_rtn("remove_compositing_layer", "kdu_region_compositor.cpp", 4368, "scan != last_active_layer");
}

{
  __assert_rtn("remove_compositing_layer", "kdu_region_compositor.cpp", 4356, "scan == active_layers");
}

void kdu_region_compositor::add_compositing_layer()
{
  __assert_rtn("add_compositing_layer", "kdu_region_compositor.cpp", 4101, "mj2_src != NULL");
}

{
  __assert_rtn("add_compositing_layer", "kdu_region_compositor.cpp", 4170, "active_layers == NULL");
}

{
  __assert_rtn("add_compositing_layer", "kdu_region_compositor.cpp", 4133, "scan == last_active_layer");
}

{
  __assert_rtn("add_compositing_layer", "kdu_region_compositor.cpp", 4138, "scan != last_active_layer");
}

{
  __assert_rtn("add_compositing_layer", "kdu_region_compositor.cpp", 4126, "scan == active_layers");
}

{
  __assert_rtn("add_compositing_layer", "kdu_region_compositor.cpp", 4068, "active_streams == NULL");
}

void kdu_region_compositor::set_single_component()
{
  __assert_rtn("set_single_component", "kdu_region_compositor.cpp", 4463, "mj2_src != NULL");
}

{
  __assert_rtn("set_single_component", "kdu_region_compositor.cpp", 4492, "active_streams->codestream_idx == stream_idx");
}

{
  __assert_rtn("set_single_component", "kdu_region_compositor.cpp", 4432, "last_active_layer == NULL");
}

void kdu_region_compositor::set_buffer_surface()
{
  __assert_rtn("set_buffer_surface", "kdu_region_compositor.cpp", 4568, "(active_streams != NULL) && (active_streams->next == NULL) && (composition_buffer != NULL)");
}

{
  __assert_rtn("set_buffer_surface", "kdu_region_compositor.cpp", 4596, "(needed_left >= 0) && (needed_right >= 0) && (needed_above >= 0) && (needed_below >= 0)");
}

void kdu_region_compositor::update_composition()
{
  __assert_rtn("update_composition", "kdu_region_compositor.cpp", 5451, "active_streams->next == NULL");
}

void kdu_region_compositor::process()
{
  __assert_rtn("process", "kdu_region_compositor.cpp", 5158, "invalid_scale_code != 0");
}

{
  __assert_rtn("process", "kdu_region_compositor.cpp", 5153, "!target->is_complete");
}

void jx_fragment_list::init()
{
  __assert_rtn("init", "jpx.cpp", 90, "flst->get_box_type() == jp2_fragment_list_4cc");
}

void jpx_input_box::seek()
{
  __assert_rtn("seek", "jpx.cpp", 407, "contents_start == 0");
}

void jx_compatibility::init_ftyp()
{
  __assert_rtn("init_ftyp", "jpx.cpp", 568, "ftyp->get_box_type() == jp2_file_type_4cc");
}

void jx_compatibility::init_rreq()
{
  __assert_rtn("init_rreq", "jpx.cpp", 601, "rreq->get_box_type() == jp2_reader_requirements_4cc");
}

void jx_composition::finish()
{
  __assert_rtn("finish", "jpx.cpp", 1520, "max_repeats >= 0");
}

{
  __assert_rtn("finish", "jpx.cpp", 1519, "remaining == 0");
}

{
  __assert_rtn("finish", "jpx.cpp", 1405, "comp_in.get_box_type() == jp2_composition_4cc");
}

void jx_source::parse_next_top_level_box()
{
  __assert_rtn("parse_next_top_level_box", "jpx.cpp", 5755, "!top_box");
}

{
  __assert_rtn("parse_next_top_level_box", "jpx.cpp", 5631, "!dtbl_box");
}

{
  __assert_rtn("parse_next_top_level_box", "jpx.cpp", 5675, "!top_box");
}

{
  __assert_rtn("parse_next_top_level_box", "jpx.cpp", 5706, "!top_box");
}

{
  __assert_rtn("parse_next_top_level_box", "jpx.cpp", 5726, "!top_box");
}

{
  __assert_rtn("parse_next_top_level_box", "jpx.cpp", 5740, "!top_box");
}

{
  __assert_rtn("parse_next_top_level_box", "jpx.cpp", 5587, "!top_box");
}

{
  __assert_rtn("parse_next_top_level_box", "jpx.cpp", 5582, "!already_open");
}

void jx_composition::remove_invisible_instructions()
{
  __assert_rtn("remove_invisible_instructions", "jpx.cpp", 1778, "tail == fp");
}

{
  __assert_rtn("remove_invisible_instructions", "jpx.cpp", 1768, "head == fp");
}

{
  __assert_rtn("remove_invisible_instructions", "jpx.cpp", 1765, "fp->num_instructions == 0");
}

{
  __assert_rtn("remove_invisible_instructions", "jpx.cpp", 1755, "fp->tail == ip");
}

{
  __assert_rtn("remove_invisible_instructions", "jpx.cpp", 1748, "fp->head == ip");
}

void jpx_layer_source::access_channels()
{
  __assert_rtn("access_channels", "jpx.cpp", 5420, "(state != NULL) && state->finished");
}

void jx_numlist::add_codestream()
{
  __assert_rtn("add_codestream", "jpx.cpp", 2520, "codestream_indices == NULL");
}

void jx_numlist::add_compositing_layer()
{
  __assert_rtn("add_compositing_layer", "jpx.cpp", 2551, "layer_indices == NULL");
}

void jx_regions::set_num_regions()
{
  __assert_rtn("set_num_regions", "jpx.cpp", 2603, "(regions == NULL) && (max_regions == 0)");
}

void jx_metagroup::unlink()
{
  __assert_rtn("unlink", "jpx.cpp", 3704, "(offset >= 0) && (offset < (JX_ROIGROUP_SIZE*JX_ROIGROUP_SIZE))");
}

{
  __assert_rtn("unlink", "jpx.cpp", 3702, "roig->level == 0");
}

{
  __assert_rtn("unlink", "jpx.cpp", 3691, "node == tail");
}

{
  __assert_rtn("unlink", "jpx.cpp", 3684, "node == head");
}

{
  __assert_rtn("unlink", "jpx.cpp", 3681, "node->metagroup == this");
}

void jx_meta_manager::link()
{
  __assert_rtn("link", "jpx.cpp", 3920, "(p_x < JX_ROIGROUP_SIZE) && (p_y < JX_ROIGROUP_SIZE)");
}

void jx_metanode::donate_input_box()
{
  __assert_rtn("donate_input_box", "jpx.cpp", 2786, "(read_state == NULL) && !(box_complete || descendants_known)");
}

void jx_metanode::finish_reading()
{
  __assert_rtn("finish_reading", "jpx.cpp", 2811, "box_complete && descendants_known");
}

{
  __assert_rtn("finish_reading", "jpx.cpp", 2819, "read_state->asoc.exists()");
}

{
  __assert_rtn("finish_reading", "jpx.cpp", 2966, "read_state->asoc.exists()");
}

{
  __assert_rtn("finish_reading", "jpx.cpp", 2967, "!read_state->box");
}

void jx_codestream_source::finish()
{
  __assert_rtn("finish", "jpx.cpp", 4879, "!sub_box.exists()");
}

{
  __assert_rtn("finish", "jpx.cpp", 4910, "!chdr");
}

void jx_layer_source::finish()
{
  __assert_rtn("finish", "jpx.cpp", 5348, "cs != NULL");
}

{
  __assert_rtn("finish", "jpx.cpp", 5224, "!sub_box.exists()");
}

{
  __assert_rtn("finish", "jpx.cpp", 5256, "!jplh");
}

void jpx_metanode::get_num_regions()
{
  __assert_rtn("get_num_regions", "jpx.cpp", 3260, "state->box_complete");
}

void jx_roigroup::delete_child()
{
  __assert_rtn("delete_child", "jpx.cpp", 3797, "this == manager->roi_scales[scale_idx]");
}

{
  __assert_rtn("delete_child", "jpx.cpp", 3773, "(loc.x >= 0) && (loc.x < JX_ROIGROUP_SIZE) && (loc.y >= 0) && (loc.y < JX_ROIGROUP_SIZE)");
}

{
  __assert_rtn("delete_child", "jpx.cpp", 3808, "this == parent->sub_groups[loc.x+loc.y*JX_ROIGROUP_SIZE]");
}

{
  __assert_rtn("delete_child", "jpx.cpp", 3807, "(loc.x >= 0) && (loc.x < JX_ROIGROUP_SIZE) && (loc.y >= 0) && (loc.y < JX_ROIGROUP_SIZE)");
}

{
  __assert_rtn("delete_child", "jpx.cpp", 3778, "metagroups[offset].head == NULL");
}

{
  __assert_rtn("delete_child", "jpx.cpp", 3785, "sub_groups[offset] != NULL");
}

void jpx_meta_manager::enumerate_matches()
{
  __assert_rtn("enumerate_matches", "jpx.cpp", 4407, "node->metagroup == &state->numlist_nodes");
}

{
  __assert_rtn("enumerate_matches", "jpx.cpp", 4451, "node->metagroup == &state->unassociated_nodes");
}

{
  __assert_rtn("enumerate_matches", "jpx.cpp", 4337, "(loc.x<JX_ROIGROUP_SIZE) && (loc.y<JX_ROIGROUP_SIZE)");
}

{
  __assert_rtn("enumerate_matches", "jpx.cpp", 4350, "(node->rep_id == JX_ROI_NODE) && (node->regions != NULL)");
}

{
  __assert_rtn("enumerate_matches", "jpx.cpp", 4316, "(loc.x >= 0) && (loc.x < JX_ROIGROUP_SIZE) && (loc.y >= 0) && (loc.y < JX_ROIGROUP_SIZE)");
}

{
  __assert_rtn("enumerate_matches", "jpx.cpp", 4263, "(offset>=0) && (offset<(JX_ROIGROUP_SIZE*JX_ROIGROUP_SIZE))");
}

void jx_codestream_source::donate_chdr_box()
{
  __assert_rtn("donate_chdr_box", "jpx.cpp", 4762, "(!header_loc) && (!chdr) && (!sub_box)");
}

void jx_codestream_source::donate_codestream_box()
{
  __assert_rtn("donate_codestream_box", "jpx.cpp", 4775, "!stream_loc");
}

void jx_codestream_source::parse_fragment_list()
{
  __assert_rtn("parse_fragment_list", "jpx.cpp", 4794, "stream_box.get_box_type() == jp2_fragment_table_4cc");
}

void jpx_codestream_source::get_codestream_id()
{
  __assert_rtn("get_codestream_id", "jpx.cpp", 4993, "(state != NULL) && state->metadata_finished");
}

void jpx_codestream_source::access_dimensions()
{
  __assert_rtn("access_dimensions", "jpx.cpp", 5028, "(state != NULL) && state->metadata_finished");
}

void jpx_codestream_source::open_stream()
{
  __assert_rtn("open_stream", "jpx.cpp", 5091, "state != NULL");
}

{
  __assert_rtn("open_stream", "jpx.cpp", 5098, "state->stream_box.exists()");
}

void jpx_codestream_source::access_palette()
{
  __assert_rtn("access_palette", "jpx.cpp", 5058, "(state != NULL) && state->metadata_finished");
}

void jx_layer_source::donate_jplh_box()
{
  __assert_rtn("donate_jplh_box", "jpx.cpp", 5134, "(!header_loc) && (!jplh) && (!sub_box)");
}

void jx_layer_source::check_stream_headers()
{
  __assert_rtn("check_stream_headers", "jpx.cpp", 5378, "cs != NULL");
}

void jpx_layer_source::get_layer_id()
{
  __assert_rtn("get_layer_id", "jpx.cpp", 5398, "(state != NULL) && state->finished");
}

void jpx_layer_source::access_colour()
{
  __assert_rtn("access_colour", "jpx.cpp", 5442, "(state != NULL) && state->finished");
}

void jpx_layer_source::have_stream_headers()
{
  __assert_rtn("have_stream_headers", "jpx.cpp", 5480, "state != NULL");
}

void jpx_layer_source::get_codestream_registration()
{
  __assert_rtn("get_codestream_registration", "jpx.cpp", 5505, "(state != NULL) && state->finished");
}

void jpx_source::open()
{
  __assert_rtn("open", "jpx.cpp", 6027, "!state->top_box");
}

{
  __assert_rtn("open", "jpx.cpp", 6002, "!state->have_reader_requirements");
}

{
  __assert_rtn("open", "jpx.cpp", 5989, "!state->top_box");
}

void jx_codestream_source::jx_codestream_source(j2_palette *a1, _QWORD *a2, jp2_input_box *a3)
{
  j2_palette::~j2_palette(a1);
  if (*a2)
    MEMORY[0x18D761C18](*a2, 0x1000C8052888210);
  jp2_input_box::~jp2_input_box(a3);
}

void _cg_TIFFReadDirectory_cold_1()
{
  __assert_rtn("_cg_TIFFReadDirectory", "tif_dirread.c", 4485, "fii != FAILED_FII");
}

void TIFFFetchDirectory_cold_1()
{
  __assert_rtn("TIFFFetchDirectory", "tif_dirread.c", 6007, "pdir");
}

void TIFFFetchNormalTag_cold_1()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6303, "fip != NULL");
}

void TIFFFetchNormalTag_cold_2()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7644, "0");
}

void TIFFFetchNormalTag_cold_3()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6305, "fip->set_field_type != TIFF_SETGET_OTHER");
}

void TIFFFetchNormalTag_cold_4()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6308, "fip->set_field_type != TIFF_SETGET_INT");
}

void TIFFFetchNormalTag_cold_5()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6373, "(uint32_t)dp->tdir_count + 1 == dp->tdir_count + 1");
}

void TIFFFetchNormalTag_cold_6()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6323, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_7()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6403, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_8()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6402, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_9()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6416, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_10()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6415, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_11()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6429, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_12()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6428, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_13()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6442, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_14()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6441, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_15()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6455, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_16()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6454, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_17()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6468, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_18()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6467, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_19()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6481, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_20()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6480, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_21()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6496, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_22()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6495, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_23()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6511, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_24()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6510, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_25()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6526, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_26()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6525, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_27()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6541, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_28()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6540, "fip->field_readcount == 1");
}

void TIFFFetchNormalTag_cold_29()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6569, "data");
}

void TIFFFetchNormalTag_cold_30()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6556, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_31()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6555, "fip->field_readcount == 2");
}

void TIFFFetchNormalTag_cold_32()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6580, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_33()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6581, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_34()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6615, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_35()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6616, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_36()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6650, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_37()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6651, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_38()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6685, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_39()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6686, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_40()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6720, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_41()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6721, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_42()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6755, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_43()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6756, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_44()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6790, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_45()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6791, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_46()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6825, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_47()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6826, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_48()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6860, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_49()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6861, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_50()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6897, "fip->field_readcount >= 1");
}

void TIFFFetchNormalTag_cold_51()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6898, "fip->field_passcount == 0");
}

void TIFFFetchNormalTag_cold_52()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6933, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_53()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6932, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_54()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6989, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_55()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 6988, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_56()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7018, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_57()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7017, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_58()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7047, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_59()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7046, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_60()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7076, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_61()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7075, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_62()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7105, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_63()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7104, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_64()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7134, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_65()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7133, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_66()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7163, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_67()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7162, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_68()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7192, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_69()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7191, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_70()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7221, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_71()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7220, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_72()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7250, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_73()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7249, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_74()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7279, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_75()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7278, "fip->field_readcount == TIFF_VARIABLE");
}

void TIFFFetchNormalTag_cold_76()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7308, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_77()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7307, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_78()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7360, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_79()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7359, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_80()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7407, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_81()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7406, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_82()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7431, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_83()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7430, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_84()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7455, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_85()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7454, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_86()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7479, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_87()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7478, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_88()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7503, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_89()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7502, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_90()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7527, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_91()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7526, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_92()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7551, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_93()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7550, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_94()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7575, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_95()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7574, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_96()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7599, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_97()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7598, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFFetchNormalTag_cold_98()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7623, "fip->field_passcount == 1");
}

void TIFFFetchNormalTag_cold_99()
{
  __assert_rtn("TIFFFetchNormalTag", "tif_dirread.c", 7622, "fip->field_readcount == TIFF_VARIABLE2");
}

void TIFFReadDirEntryOutputErr_cold_1()
{
  __assert_rtn("TIFFReadDirEntryOutputErr", "tif_dirread.c", 4020, "0");
}

void TIFFReadDirEntryOutputErr_cold_2()
{
  __assert_rtn("TIFFReadDirEntryOutputErr", "tif_dirread.c", 4066, "0");
}

void ChopUpSingleUncompressedStrip_cold_1()
{
  __assert_rtn("ChopUpSingleUncompressedStrip", "tif_dirread.c", 7901, "td->td_planarconfig == PLANARCONFIG_CONTIG");
}

void TryChopUpUncompressedBigTiff_cold_1()
{
  __assert_rtn("TryChopUpUncompressedBigTiff", "tif_dirread.c", 7971, "stripsize > 0x7FFFFFFFUL");
}

void TryChopUpUncompressedBigTiff_cold_2()
{
  __assert_rtn("TryChopUpUncompressedBigTiff", "tif_dirread.c", 8023, "stripbytes <= 0x7FFFFFFFUL");
}

void TryChopUpUncompressedBigTiff_cold_3()
{
  __assert_rtn("TryChopUpUncompressedBigTiff", "tif_dirread.c", 7970, "(tif->tif_flags & (TIFF_STRIPCHOP | TIFF_ISTILED)) == TIFF_STRIPCHOP");
}

void TryChopUpUncompressedBigTiff_cold_4()
{
  __assert_rtn("TryChopUpUncompressedBigTiff", "tif_dirread.c", 7968, "tif->tif_dir.td_compression == COMPRESSION_NONE");
}

void TryChopUpUncompressedBigTiff_cold_5()
{
  __assert_rtn("TryChopUpUncompressedBigTiff", "tif_dirread.c", 7967, "tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG");
}

void _TIFFGetStrileOffsetOrByteCountValue_cold_1()
{
  __assert_rtn("_TIFFPartialReadStripArray", "tif_dirread.c", 8079, "dirent->tdir_count > 4");
}

void _TIFFGetStrileOffsetOrByteCountValue_cold_2()
{
  __assert_rtn("_TIFFFetchStrileValue", "tif_dirread.c", 8261, "strile < nStripArrayAllocNew");
}

void TIFFReadDirEntryData_cold_1()
{
  __assert_rtn("TIFFReadDirEntryData", "tif_dirread.c", 3956, "size > 0");
}

void TIFFReadDirEntryArrayWithLimit_cold_1()
{
  __assert_rtn("TIFFReadDirEntryArrayWithLimit", "tif_dirread.c", 1355, "(tmsize_t)datasize > 0");
}

void TIFFReadDirEntryDataAndRealloc_cold_1()
{
  __assert_rtn("TIFFReadDirEntryDataAndRealloc", "tif_dirread.c", 1262, "!isMapped(tif)");
}

void TIFFHashSetSize_cold_1()
{
  __assert_rtn("TIFFHashSetSize", "tif_hash_set.c", 182, "set != NULL");
}

void TIFFHashSetInsert_cold_1()
{
  __assert_rtn("TIFFHashSetInsert", "tif_hash_set.c", 442, "set != NULL");
}

void TIFFHashSetLookup_cold_1()
{
  __assert_rtn("TIFFHashSetLookup", "tif_hash_set.c", 504, "set != NULL");
}

void TIFFHashSetRemove_cold_1()
{
  __assert_rtn("TIFFHashSetRemoveInternal", "tif_hash_set.c", 519, "set != NULL");
}

void TIFFInitOJPEG_cold_1()
{
  __assert_rtn("TIFFInitOJPEG", "tif_ojpeg.c", 464, "scheme == COMPRESSION_OJPEG");
}

void OJPEGPreDecode_cold_1()
{
  __assert_rtn("OJPEGReadSecondarySos", "tif_ojpeg.c", 1269, "s > 0");
}

void OJPEGPreDecode_cold_2()
{
  __assert_rtn("OJPEGReadSecondarySos", "tif_ojpeg.c", 1270, "s < 3");
}

void OJPEGPreDecode_cold_3()
{
  __assert_rtn("OJPEGReadSecondarySos", "tif_ojpeg.c", 1271, "sp->sos_end[0].log != 0");
}

void OJPEGPreDecode_cold_4()
{
  __assert_rtn("OJPEGWriteHeaderInfo", "tif_ojpeg.c", 1369, "sp->subsampling_convert_ycbcrimage == 0");
}

void OJPEGPreDecode_cold_5()
{
  __assert_rtn("OJPEGWriteHeaderInfo", "tif_ojpeg.c", 1368, "sp->subsampling_convert_ycbcrbuf == 0");
}

void OJPEGPreDecode_cold_6()
{
  __assert_rtn("OJPEGReadSecondarySos", "tif_ojpeg.c", 1272, "sp->sos_end[s].log == 0");
}

void OJPEGPreDecode_cold_7()
{
  __assert_rtn("OJPEGReadHeaderInfo", "tif_ojpeg.c", 1186, "sp->readheader_done == 0");
}

void OJPEGPostDecode_cold_1()
{
  __assert_rtn("OJPEGPostDecode", "tif_ojpeg.c", 997, "sp->libjpeg_session_active != 0");
}

void OJPEGDecode_cold_1()
{
  __assert_rtn("OJPEGDecodeRaw", "tif_ojpeg.c", 907, "cc > 0");
}

void OJPEGDecode_cold_2()
{
  __assert_rtn("OJPEGDecodeScanlines", "tif_ojpeg.c", 964, "cc > 0");
}

void OJPEGPrintDir_cold_1()
{
  __assert_rtn("OJPEGPrintDir", "tif_ojpeg.c", 658, "sp != NULL");
}

void OJPEGSubsamplingCorrect_cold_1()
{
  __assert_rtn("OJPEGSubsamplingCorrect", "tif_ojpeg.c", 1104, "sp->subsamplingcorrect_done == 0");
}

void OJPEGReadHeaderInfoSec_cold_1()
{
  __assert_rtn("OJPEGReadBytePeek", "tif_ojpeg.c", 2332, "sp->in_buffer_togo > 0");
}

void OJPEGReadHeaderInfoSec_cold_2()
{
  __assert_rtn("OJPEGReadHeaderInfoSec", "tif_ojpeg.c", 1600, "sp->plane_sample_offset == 0");
}

void OJPEGReadByte_cold_1()
{
  __assert_rtn("OJPEGReadByte", "tif_ojpeg.c", 2318, "sp->in_buffer_togo > 0");
}

void OJPEGReadHeaderInfoSecStreamSos_cold_1()
{
  __assert_rtn("OJPEGReadHeaderInfoSecStreamSos", "tif_ojpeg.c", 1980, "sp->subsamplingcorrect == 0");
}

void OJPEGReadBufferFill_cold_1()
{
  __assert_rtn("OJPEGReadBufferFill", "tif_ojpeg.c", 2241, "n > 0");
}

void OJPEGReadBufferFill_cold_2()
{
  __assert_rtn("OJPEGReadBufferFill", "tif_ojpeg.c", 2242, "n <= OJPEG_BUFFER");
}

void OJPEGReadBufferFill_cold_3()
{
  __assert_rtn("OJPEGReadBufferFill", "tif_ojpeg.c", 2244, "(uint64_t)n <= sp->in_buffer_file_togo");
}

void OJPEGReadBlock_cold_1()
{
  __assert_rtn("OJPEGReadBlock", "tif_ojpeg.c", 2362, "len > 0");
}

void OJPEGReadBlock_cold_2()
{
  __assert_rtn("OJPEGReadBlock", "tif_ojpeg.c", 2371, "sp->in_buffer_togo > 0");
}

void OJPEGLibjpegSessionAbort_cold_1()
{
  __assert_rtn("OJPEGLibjpegSessionAbort", "tif_ojpeg.c", 1492, "sp->libjpeg_session_active != 0");
}

void OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_1()
{
  __assert_rtn("OJPEGWriteStream", "tif_ojpeg.c", 2420, "sp->out_state <= ososEoi");
}

void OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_2()
{
  __assert_rtn("OJPEGWriteStreamSof", "tif_ojpeg.c", 2556, "255 >= 8 + sp->samples_per_pixel_per_plane * 3");
}

void OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_3()
{
  __assert_rtn("OJPEGWriteStreamSos", "tif_ojpeg.c", 2593, "255 >= 6 + sp->samples_per_pixel_per_plane * 2");
}

void OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_4()
{
  __assert_rtn("OJPEGWriteStreamCompressed", "tif_ojpeg.c", 2627, "sp->in_buffer_togo > 0");
}

void TIFFGrowStrips_cold_1()
{
  __assert_rtn("TIFFGrowStrips", "tif_write.c", 728, "td->td_planarconfig == PLANARCONFIG_CONTIG");
}

void TIFFAppendToStrip_cold_1()
{
  __assert_rtn("TIFFAppendToStrip", "tif_write.c", 772, "td->td_nstrips > 0");
}

void TIFFPredictorInit_cold_1()
{
  __assert_rtn("TIFFPredictorInit", "tif_predict.c", 1058, "sp != 0");
}

void TIFFPredictorCleanup_cold_1()
{
  __assert_rtn("TIFFPredictorCleanup", "tif_predict.c", 1098, "sp != 0");
}

void PredictorDecodeRow_cold_1()
{
  __assert_rtn("PredictorDecodeRow", "tif_predict.c", 611, "sp != NULL");
}

void PredictorDecodeRow_cold_2()
{
  __assert_rtn("PredictorDecodeRow", "tif_predict.c", 612, "sp->decoderow != NULL");
}

void PredictorDecodeRow_cold_3()
{
  __assert_rtn("PredictorDecodeRow", "tif_predict.c", 613, "sp->decodepfunc != NULL");
}

void PredictorDecodeTile_cold_1()
{
  __assert_rtn("PredictorDecodeTile", "tif_predict.c", 635, "sp != NULL");
}

void PredictorDecodeTile_cold_2()
{
  __assert_rtn("PredictorDecodeTile", "tif_predict.c", 636, "sp->decodetile != NULL");
}

void PredictorDecodeTile_cold_3()
{
  __assert_rtn("PredictorDecodeTile", "tif_predict.c", 641, "rowsize > 0");
}

void PredictorDecodeTile_cold_4()
{
  __assert_rtn("PredictorDecodeTile", "tif_predict.c", 648, "sp->decodepfunc != NULL");
}

void PredictorEncodeRow_cold_1()
{
  __assert_rtn("PredictorEncodeRow", "tif_predict.c", 911, "sp != NULL");
}

void PredictorEncodeRow_cold_2()
{
  __assert_rtn("PredictorEncodeRow", "tif_predict.c", 912, "sp->encodepfunc != NULL");
}

void PredictorEncodeRow_cold_3()
{
  __assert_rtn("PredictorEncodeRow", "tif_predict.c", 913, "sp->encoderow != NULL");
}

void PredictorEncodeTile_cold_1()
{
  __assert_rtn("PredictorEncodeTile", "tif_predict.c", 931, "sp != NULL");
}

void PredictorEncodeTile_cold_2()
{
  __assert_rtn("PredictorEncodeTile", "tif_predict.c", 932, "sp->encodepfunc != NULL");
}

void PredictorEncodeTile_cold_3()
{
  __assert_rtn("PredictorEncodeTile", "tif_predict.c", 933, "sp->encodetile != NULL");
}

void PredictorEncodeTile_cold_4()
{
  __assert_rtn("PredictorEncodeTile", "tif_predict.c", 951, "rowsize > 0");
}

void TIFFWriteDirectorySec_cold_1()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 1114, "0");
}

void TIFFWriteDirectorySec_cold_2()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 893, "o->field_passcount == 0");
}

void TIFFWriteDirectorySec_cold_3()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 892, "o->field_readcount == TIFF_VARIABLE");
}

void TIFFWriteDirectorySec_cold_4()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 891, "o->field_type == TIFF_ASCII");
}

void TIFFWriteDirectorySec_cold_5()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 907, "o->field_passcount == 0");
}

void TIFFWriteDirectorySec_cold_6()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 906, "o->field_readcount == 1");
}

void TIFFWriteDirectorySec_cold_7()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 905, "o->field_type == TIFF_SHORT");
}

void TIFFWriteDirectorySec_cold_8()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 920, "o->field_passcount == 0");
}

void TIFFWriteDirectorySec_cold_9()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 919, "o->field_readcount == 1");
}

void TIFFWriteDirectorySec_cold_10()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 918, "o->field_type == TIFF_LONG");
}

void TIFFWriteDirectorySec_cold_11()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 934, "o->field_passcount == 1");
}

void TIFFWriteDirectorySec_cold_12()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 933, "o->field_readcount == TIFF_VARIABLE2");
}

void TIFFWriteDirectorySec_cold_13()
{
  __assert_rtn("TIFFWriteDirectorySec", "tif_dirwrite.c", 932, "o->field_type == TIFF_UNDEFINED");
}

void TIFFWriteDirectorySec_cold_14()
{
  __assert_rtn("TIFFWriteDirectoryTagSubifd", "tif_dirwrite.c", 2165, "pa != 0");
}

void TIFFWriteDirectoryTagSshortArray_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedSshortArray", "tif_dirwrite.c", 2312, "count < 0x80000000");
}

void TIFFWriteDirectoryTagFloatArray_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedFloatArray", "tif_dirwrite.c", 2910, "count < 0x40000000");
}

void TIFFWriteDirectoryTagDoubleArray_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedDoubleArray", "tif_dirwrite.c", 2929, "count < 0x20000000");
}

void TIFFWriteDirectoryTagData_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagData", "tif_dirwrite.c", 2989, "dir[m].tdir_tag != tag");
}

void TIFFWriteDirectoryTagCheckedShortArray_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedShortArray", "tif_dirwrite.c", 2294, "count < 0x80000000");
}

void TIFFWriteDirectoryTagCheckedLong8Array_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedLong8Array", "tif_dirwrite.c", 2385, "count < 0x20000000");
}

void TIFFWriteDirectoryTagCheckedLongArray_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedLongArray", "tif_dirwrite.c", 2349, "count < 0x40000000");
}

void TIFFWriteDirectoryTagCheckedIfdArray_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedIfdArray", "tif_dirwrite.c", 2947, "count < 0x40000000");
}

void TIFFWriteDirectoryTagCheckedIfd8Array_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedIfd8Array", "tif_dirwrite.c", 2965, "count < 0x20000000");
}

void TIFFWriteDirectoryTagCheckedIfd8Array_cold_2()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedIfd8Array", "tif_dirwrite.c", 2967, "tif->tif_flags & TIFF_BIGTIFF");
}

void TIFFWriteDirectoryTagCheckedSlongArray_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedSlongArray", "tif_dirwrite.c", 2367, "count < 0x40000000");
}

void TIFFWriteDirectoryTagCheckedSlong8Array_cold_1()
{
  __assert_rtn("TIFFWriteDirectoryTagCheckedSlong8Array", "tif_dirwrite.c", 2409, "count < 0x20000000");
}

void _TIFFVSetField_cold_1()
{
  __assert_rtn("_TIFFVSetField", "tif_dir.c", 785, "fip->field_writecount == TIFF_VARIABLE2");
}

void _TIFFVSetField_cold_2()
{
  __assert_rtn("_TIFFVSetField", "tif_dir.c", 1114, "0");
}

void _TIFFVSetField_cold_3()
{
  __assert_rtn("_TIFFVSetField", "tif_dir.c", 914, "tv->count == 1");
}

void _TIFFVGetField_cold_1()
{
  __assert_rtn("_TIFFVGetField", "tif_dir.c", 1511, "tv->count == 1");
}

void decode_etc2()
{
  __assert_rtn("decode_etc2_planar", "DecompressorETC.cpp", 606, "data.mode == ETC_Data::Mode_Planar");
}

{
  __assert_rtn("get_partition", "DecompressorETC.cpp", 532, "data.mode == ETC_Data::Mode_ETC1");
}

{
  __assert_rtn("get_diff_subblock_palette", "DecompressorETC.cpp", 484, "table_idx < 8");
}

{
  __assert_rtn("get_diff_subblock_palette", "DecompressorETC.cpp", 498, "table_idx < 8");
}

void nv::decompress_eac()
{
  __assert_rtn("nvAbort", "DecompressorETC.cpp", 32, "0");
}

void get_abs_subblock_palette()
{
  __assert_rtn("get_abs_subblock_palette", "DecompressorETC.cpp", 514, "table_idx < 8");
}

void DumpModeEncode_cold_1()
{
  __assert_rtn("DumpModeEncode", "tif_dumpmode.c", 52, "n > 0");
}

void _TIFFFax3fillruns_cold_1()
{
  __assert_rtn("_TIFFFax3fillruns", "tif_fax3.c", 485, "x == lastx");
}

void Fax3VGetField_cold_1()
{
  __assert_rtn("Fax3VGetField", "tif_fax3.c", 1323, "sp != 0");
}

void Fax3VSetField_cold_1()
{
  __assert_rtn("Fax3VSetField", "tif_fax3.c", 1276, "sp != 0");
}

void Fax3VSetField_cold_2()
{
  __assert_rtn("Fax3VSetField", "tif_fax3.c", 1277, "sp->vsetparent != 0");
}

void Fax3PrintDir_cold_1()
{
  __assert_rtn("Fax3PrintDir", "tif_fax3.c", 1356, "sp != 0");
}

void Fax3PreDecode_cold_1()
{
  __assert_rtn("Fax3PreDecode", "tif_fax3.c", 169, "sp != NULL");
}

void Fax3PreEncode_cold_1()
{
  __assert_rtn("Fax3PreEncode", "tif_fax3.c", 790, "sp != NULL");
}

void Fax3Encode_cold_1()
{
  __assert_rtn("Fax3PutEOL", "tif_fax3.c", 774, "length < 9");
}

void Fax3Encode_cold_2()
{
  __assert_rtn("Fax3PutEOL", "tif_fax3.c", 764, "tparm < 9");
}

void Fax3Cleanup_cold_1()
{
  __assert_rtn("Fax3Cleanup", "tif_fax3.c", 1227, "sp != 0");
}

void putspan_cold_1()
{
  __assert_rtn("putspan", "tif_fax3.c", 728, "length < 9");
}

void putspan_cold_2()
{
  __assert_rtn("putspan", "tif_fax3.c", 720, "length < 9");
}

void putspan_cold_3()
{
  __assert_rtn("putspan", "tif_fax3.c", 714, "te->runlen == 64 * (span >> 6)");
}

void putspan_cold_4()
{
  __assert_rtn("putspan", "tif_fax3.c", 708, "length < 9");
}

void Fax3PutBits_cold_1()
{
  __assert_rtn("Fax3PutBits", "tif_fax3.c", 662, "length < 9");
}

void _cg_TIFFReadScanline_cold_1()
{
  __assert_rtn("TIFFFillStripPartial", "tif_read.c", 266, "(tif->tif_flags & TIFF_BUFFERMMAP) == 0");
}

void _cg_TIFFReadScanline_cold_2()
{
  __assert_rtn("TIFFFillStripPartial", "tif_read.c", 248, "(tif->tif_flags & TIFF_BUFFERMMAP) == 0");
}

void TIFFReadRawStrip1_cold_1()
{
  __assert_rtn("TIFFReadRawStrip1", "tif_read.c", 611, "(tif->tif_flags & TIFF_NOREADRAW) == 0");
}

void TIFFReadBufferSetup_cold_1()
{
  __assert_rtn("TIFFReadBufferSetup", "tif_read.c", 1374, "(tif->tif_flags & TIFF_NOREADRAW) == 0");
}

void TIFFReadRawStripOrTile2_cold_1()
{
  __assert_rtn("TIFFReadRawStripOrTile2", "tif_read.c", 674, "(tif->tif_flags & TIFF_NOREADRAW) == 0");
}

void TIFFReadRawStripOrTile2_cold_2()
{
  __assert_rtn("TIFFReadRawStripOrTile2", "tif_read.c", 673, "!isMapped(tif)");
}

void TIFFReadRawTile1_cold_1()
{
  __assert_rtn("TIFFReadRawTile1", "tif_read.c", 1117, "(tif->tif_flags & TIFF_NOREADRAW) == 0");
}

void _TIFFSwab16BitData_cold_1()
{
  __assert_rtn("_TIFFSwab16BitData", "tif_read.c", 1657, "(cc & 1) == 0");
}

void _TIFFSwab24BitData_cold_1()
{
  __assert_rtn("_TIFFSwab24BitData", "tif_read.c", 1664, "(cc % 3) == 0");
}

void _TIFFSwab32BitData_cold_1()
{
  __assert_rtn("_TIFFSwab32BitData", "tif_read.c", 1671, "(cc & 3) == 0");
}

void _TIFFSwab64BitData_cold_1()
{
  __assert_rtn("_TIFFSwab64BitData", "tif_read.c", 1678, "(cc & 7) == 0");
}

void TIFFReadAndRealloc_cold_1()
{
  __assert_rtn("TIFFReadAndRealloc", "tif_read.c", 100, "(tif->tif_flags & TIFF_MYBUFFER) != 0");
}

void TIFFWritePlugin::writeOne(unsigned __int16 a1, int a2)
{
  *gCrashMessage = 0;
  snprintf(gCrashMessage, 0x200uLL, "TIFF issue: bpc: %d compress: %d\n", a2, a1);
  qword_1ECDD8318 = gCrashMessage;
  abort();
}

void TIFFInitPixarLog_cold_1()
{
  __assert_rtn("TIFFInitPixarLog", "tif_pixarlog.c", 1611, "scheme == COMPRESSION_PIXARLOG");
}

void PixarLogSetupDecode_cold_1()
{
  __assert_rtn("PixarLogSetupDecode", "tif_pixarlog.c", 747, "sp != NULL");
}

void PixarLogSetupDecode_cold_2()
{
  __assert_rtn("add_ms", "tif_pixarlog.c", 723, "m1 >= 0 && m2 >= 0");
}

void PixarLogPreDecode_cold_1()
{
  __assert_rtn("PixarLogPreDecode", "tif_pixarlog.c", 819, "sp != NULL");
}

void PixarLogSetupEncode_cold_1()
{
  __assert_rtn("PixarLogSetupEncode", "tif_pixarlog.c", 1001, "sp != NULL");
}

void PixarLogPreEncode_cold_1()
{
  __assert_rtn("PixarLogPreEncode", "tif_pixarlog.c", 1051, "sp != NULL");
}

void PixarLogClose_cold_1()
{
  __assert_rtn("PixarLogClose", "tif_pixarlog.c", 1450, "sp != 0");
}

void PixarLogCleanup_cold_1()
{
  __assert_rtn("PixarLogCleanup", "tif_pixarlog.c", 1479, "sp != 0");
}

void TIFFInitZIP_cold_1()
{
  __assert_rtn("TIFFInitZIP", "tif_zip.c", 687, "(scheme == COMPRESSION_DEFLATE) || (scheme == COMPRESSION_ADOBE_DEFLATE)");
}

void ZIPSetupDecode_cold_1()
{
  __assert_rtn("ZIPSetupDecode", "tif_zip.c", 106, "sp != NULL");
}

void ZIPPreDecode_cold_1()
{
  __assert_rtn("ZIPPreDecode", "tif_zip.c", 139, "sp != NULL");
}

void ZIPDecode_cold_1()
{
  __assert_rtn("ZIPDecode", "tif_zip.c", 169, "sp != NULL");
}

void ZIPDecode_cold_2()
{
  __assert_rtn("ZIPDecode", "tif_zip.c", 170, "sp->state == ZSTATE_INIT_DECODE");
}

void ZIPSetupEncode_cold_1()
{
  __assert_rtn("ZIPSetupEncode", "tif_zip.c", 321, "sp != NULL");
}

void ZIPPreEncode_cold_1()
{
  __assert_rtn("ZIPPreEncode", "tif_zip.c", 352, "sp != NULL");
}

void ZIPEncode_cold_1()
{
  __assert_rtn("ZIPEncode", "tif_zip.c", 378, "sp != NULL");
}

void ZIPEncode_cold_2()
{
  __assert_rtn("ZIPEncode", "tif_zip.c", 379, "sp->state == ZSTATE_INIT_ENCODE");
}

void ZIPCleanup_cold_1()
{
  __assert_rtn("ZIPCleanup", "tif_zip.c", 556, "sp != 0");
}

void ImageIOLogger(uint64_t *a1, NSObject *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = 136446210;
  v4 = v2;
  _os_log_error_impl(&dword_187E34000, a2, OS_LOG_TYPE_ERROR, "%{public}s\n", (uint8_t *)&v3, 0xCu);
  OUTLINED_FUNCTION_0_1();
}

{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = 136446210;
  v4 = v2;
  _os_log_debug_impl(&dword_187E34000, a2, OS_LOG_TYPE_DEBUG, "%{public}s\n", (uint8_t *)&v3, 0xCu);
  OUTLINED_FUNCTION_0_1();
}

{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = 136446210;
  v4 = v2;
  _os_log_fault_impl(&dword_187E34000, a2, OS_LOG_TYPE_FAULT, "%{public}s\n", (uint8_t *)&v3, 0xCu);
  OUTLINED_FUNCTION_0_1();
}

void IIOXPCClient::connection_set_event_handler()
{
  __assert_rtn("connection_set_event_handler", "IIOXPCClient.cpp", 718, "connection");
}

void ___ZN12IIOXPCClient18wakeup_xpc_serviceEv_block_invoke_cold_1()
{
  __assert_rtn("wakeup_xpc_service_block_invoke", "IIOXPCClient.cpp", 980, "event_queue != NULL");
}

void mj2_video_source::get_stream_idx()
{
  __assert_rtn("get_stream_idx", "mj2.cpp", 2277, "stream_off < state->num_codestreams");
}

void mj2_source::get_track_type()
{
  __assert_rtn("get_track_type", "mj2.cpp", 3191, "state != NULL");
}

void mj2_source::access_video_track()
{
  __assert_rtn("access_video_track", "mj2.cpp", 3211, "state != NULL");
}

void TIFFInitSGILog_cold_1()
{
  __assert_rtn("TIFFInitSGILog", "tif_luv.c", 1785, "scheme == COMPRESSION_SGILOG24 || scheme == COMPRESSION_SGILOG");
}

void LogLuvDecodeStrip_cold_1()
{
  __assert_rtn("LogLuvDecodeStrip", "tif_luv.c", 398, "cc % rowlen == 0");
}

void LogLuvDecodeTile_cold_1()
{
  __assert_rtn("LogLuvDecodeTile", "tif_luv.c", 419, "cc % rowlen == 0");
}

void LogLuvEncodeStrip_cold_1()
{
  __assert_rtn("LogLuvEncodeStrip", "tif_luv.c", 721, "cc % rowlen == 0");
}

void LogLuvEncodeTile_cold_1()
{
  __assert_rtn("LogLuvEncodeTile", "tif_luv.c", 741, "cc % rowlen == 0");
}

void LogLuvClose_cold_1()
{
  __assert_rtn("LogLuvClose", "tif_luv.c", 1657, "sp != 0");
}

void LogLuvCleanup_cold_1()
{
  __assert_rtn("LogLuvCleanup", "tif_luv.c", 1681, "sp != 0");
}

void LogLuvInitState_cold_1()
{
  __assert_rtn("LogLuvInitState", "tif_luv.c", 1452, "sp != NULL");
}

void LogLuvInitState_cold_2()
{
  __assert_rtn("LogLuvInitState", "tif_luv.c", 1453, "td->td_photometric == PHOTOMETRIC_LOGLUV");
}

void LogLuvDecode24_cold_1()
{
  __assert_rtn("LogLuvDecode24", "tif_luv.c", 271, "sp != NULL");
}

void LogLuvDecode24_cold_2()
{
  __assert_rtn("LogLuvDecode24", "tif_luv.c", 270, "s == 0");
}

void LogLuvDecode32_cold_1()
{
  __assert_rtn("LogLuvDecode32", "tif_luv.c", 328, "sp != NULL");
}

void LogLuvDecode32_cold_2()
{
  __assert_rtn("LogLuvDecode32", "tif_luv.c", 326, "s == 0");
}

void LogL16InitState_cold_1()
{
  __assert_rtn("LogL16InitState", "tif_luv.c", 1347, "sp != NULL");
}

void LogL16InitState_cold_2()
{
  __assert_rtn("LogL16InitState", "tif_luv.c", 1348, "td->td_photometric == PHOTOMETRIC_LOGL");
}

void LogL16Decode_cold_1()
{
  __assert_rtn("LogL16Decode", "tif_luv.c", 198, "sp != NULL");
}

void LogL16Decode_cold_2()
{
  __assert_rtn("LogL16Decode", "tif_luv.c", 197, "s == 0");
}

void LogLuvEncode24_cold_1()
{
  __assert_rtn("LogLuvEncode24", "tif_luv.c", 556, "sp != NULL");
}

void LogLuvEncode24_cold_2()
{
  __assert_rtn("LogLuvEncode24", "tif_luv.c", 555, "s == 0");
}

void LogLuvEncode32_cold_1()
{
  __assert_rtn("LogLuvEncode32", "tif_luv.c", 616, "sp != NULL");
}

void LogLuvEncode32_cold_2()
{
  __assert_rtn("LogLuvEncode32", "tif_luv.c", 615, "s == 0");
}

void LogL16Encode_cold_1()
{
  __assert_rtn("LogL16Encode", "tif_luv.c", 448, "sp != NULL");
}

void LogL16Encode_cold_2()
{
  __assert_rtn("LogL16Encode", "tif_luv.c", 447, "s == 0");
}

void GlobalICNSInfo::GlobalICNSInfo(void **a1)
{
  void *v2;

  v2 = *a1;
  if (v2)
    OUTLINED_FUNCTION_0_2(v2, (uint64_t)a1);
}

void kdu_image_in::AllocateSrcLineBuffer()
{
  __assert_rtn("AllocateSrcLineBuffer", "kdu_image.h", 100, "mBytesPerRow > 0");
}

void kdu_image_in::DeallocateSrcLineBuffer()
{
  __assert_rtn("DeallocateSrcLineBuffer", "kdu_image.h", 106, "mSrcLineBuffer != NULL");
}

void TIFFInitLZW_cold_1()
{
  __assert_rtn("TIFFInitLZW", "tif_lzw.c", 1444, "scheme == COMPRESSION_LZW");
}

void LZWPreDecode_cold_1()
{
  __assert_rtn("LZWPreDecode", "tif_lzw.c", 285, "sp != NULL");
}

void LZWDecode_cold_1()
{
  __assert_rtn("LZWDecode", "tif_lzw.c", 461, "sp != NULL");
}

void LZWDecode_cold_2()
{
  __assert_rtn("LZWDecode", "tif_lzw.c", 462, "sp->dec_codetab != NULL");
}

void LZWSetupEncode_cold_1()
{
  __assert_rtn("LZWSetupEncode", "tif_lzw.c", 1075, "sp != NULL");
}

void LZWPreEncode_cold_1()
{
  __assert_rtn("LZWPreEncode", "tif_lzw.c", 1093, "sp != NULL");
}

void LZWPostEncode_cold_1()
{
  __assert_rtn("LZWPostEncode", "tif_lzw.c", 1384, "nbits <= BITS_MAX");
}

void LZWEncode_cold_1()
{
  __assert_rtn("LZWEncode", "tif_lzw.c", 1178, "sp->enc_hashtab != NULL");
}

void LZWEncode_cold_2()
{
  __assert_rtn("LZWEncode", "tif_lzw.c", 1292, "nbits <= BITS_MAX");
}

void LZWCleanup_cold_1()
{
  __assert_rtn("LZWCleanup", "tif_lzw.c", 1426, "tif->tif_data != 0");
}

void LZWDecodeCompat_cold_1()
{
  __assert_rtn("LZWDecodeCompat", "tif_lzw.c", 859, "sp != NULL");
}

void TIFFInitJPEG_cold_1()
{
  __assert_rtn("TIFFInitJPEG", "tif_jpeg.c", 2832, "scheme == COMPRESSION_JPEG");
}

void JPEGVGetField_cold_1()
{
  __assert_rtn("JPEGVGetField", "tif_jpeg.c", 2637, "sp != NULL");
}

void JPEGVSetField_cold_1()
{
  __assert_rtn("JPEGVSetField", "tif_jpeg.c", 2579, "sp != NULL");
}

void JPEGPrintDir_cold_1()
{
  __assert_rtn("JPEGPrintDir", "tif_jpeg.c", 2664, "sp != NULL");
}

void JPEGSetupDecode_cold_1()
{
  __assert_rtn("JPEGSetupDecode", "tif_jpeg.c", 1088, "sp != NULL");
}

void JPEGSetupDecode_cold_2()
{
  __assert_rtn("JPEGSetupDecode", "tif_jpeg.c", 1089, "sp->cinfo.comm.is_decompressor");
}

void JPEGPreDecode_cold_1()
{
  __assert_rtn("JPEGPreDecode", "tif_jpeg.c", 1171, "sp != NULL");
}

void JPEGPreDecode_cold_2()
{
  __assert_rtn("JPEGPreDecode", "tif_jpeg.c", 1178, "sp->cinfo.comm.is_decompressor");
}

void JPEGSetupEncode_cold_1()
{
  __assert_rtn("JPEGSetupEncode", "tif_jpeg.c", 1927, "sp != NULL");
}

void JPEGSetupEncode_cold_2()
{
  __assert_rtn("JPEGSetupEncode", "tif_jpeg.c", 1928, "!sp->cinfo.comm.is_decompressor");
}

void JPEGPreEncode_cold_1()
{
  __assert_rtn("JPEGPreEncode", "tif_jpeg.c", 2155, "sp != NULL");
}

void JPEGPreEncode_cold_2()
{
  __assert_rtn("JPEGPreEncode", "tif_jpeg.c", 2162, "!sp->cinfo.comm.is_decompressor");
}

void JPEGEncode_cold_1()
{
  __assert_rtn("JPEGEncode", "tif_jpeg.c", 2320, "sp != NULL");
}

void JPEGCleanup_cold_1()
{
  __assert_rtn("JPEGCleanup", "tif_jpeg.c", 2520, "sp != 0");
}

void JPEGFixupTagsSubsamplingReadByte_cold_1()
{
  __assert_rtn("JPEGFixupTagsSubsamplingReadByte", "tif_jpeg.c", 1013, "m < 0x80000000UL");
}

void BuildMapUaToAa_cold_1()
{
  __assert_rtn("BuildMapUaToAa", "tif_getimage.c", 3175, "img->UaToAa == NULL");
}

void BuildMapBitdepth16To8_cold_1()
{
  __assert_rtn("BuildMapBitdepth16To8", "tif_getimage.c", 3196, "img->Bitdepth16To8 == NULL");
}

void _TIFFreallocExt_cold_1()
{
  __assert_rtn("_TIFFreallocExt", "tif_open.c", 242, "oldSize <= tif->tif_cur_cumulated_mem_alloc");
}

void _TIFFfreeExt_cold_1()
{
  __assert_rtn("_TIFFfreeExt", "tif_open.c", 273, "oldSize <= tif->tif_cur_cumulated_mem_alloc");
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x1E0C80310](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x1E0C80318](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1E0C80320](c, data, *(_QWORD *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  return (CFAllocatorRef)MEMORY[0x1E0C97CA8](allocator, context);
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x1E0C97CE8](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x1E0C97D00](theArray, range.location, range.length, applier, context);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D10](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1E0C97D30](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D50](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
  MEMORY[0x1E0C97DA8](theArray, range.location, range.length, values);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x1E0C97DC0](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DD0](theArray, idx, value);
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  return (CFAttributedStringRef)MEMORY[0x1E0C97DF0](alloc, str, attributes);
}

CFAttributedStringRef CFAttributedStringCreateWithSubstring(CFAllocatorRef alloc, CFAttributedStringRef aStr, CFRange range)
{
  return (CFAttributedStringRef)MEMORY[0x1E0C97E10](alloc, aStr, range.location, range.length);
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  return MEMORY[0x1E0C97E48](aStr);
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x1E0C97E90](arg);
}

void CFBagAddValue(CFMutableBagRef theBag, const void *value)
{
  MEMORY[0x1E0C97E98](theBag, value);
}

CFMutableBagRef CFBagCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFBagCallBacks *callBacks)
{
  return (CFMutableBagRef)MEMORY[0x1E0C97EB8](allocator, capacity, callBacks);
}

CFIndex CFBagGetCount(CFBagRef theBag)
{
  return MEMORY[0x1E0C97EC8](theBag);
}

CFTypeID CFBagGetTypeID(void)
{
  return MEMORY[0x1E0C97ED8]();
}

void CFBagGetValues(CFBagRef theBag, const void **values)
{
  MEMORY[0x1E0C97EE8](theBag, values);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1E0C980E8](bundleID);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x1E0C98120](bundle);
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98130](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1E0C98150]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0C98180](bundle, key);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1E0C98350](cf);
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  return (CFStringRef)MEMORY[0x1E0C98380](type_id);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  MEMORY[0x1E0C98390](theData, bytes, length);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1E0C983B0](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983B8](allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983C0](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1E0C983C8](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x1E0C983F0](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1E0C98408](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1E0C98418]();
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
  MEMORY[0x1E0C98420](theData, extraLength);
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
  MEMORY[0x1E0C98428](theData, range.location, range.length, newBytes, newLength);
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  MEMORY[0x1E0C98430](theData, length);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x1E0C98460](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  return (CFStringRef)MEMORY[0x1E0C98490](allocator, formatter, date);
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
  MEMORY[0x1E0C984C0](formatter, formatString);
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1E0C984E8]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

Boolean CFDictionaryContainsValue(CFDictionaryRef theDict, const void *value)
{
  return MEMORY[0x1E0C98520](theDict, value);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98538](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x1E0C985D8](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFStringRef CFErrorCopyFailureReason(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1E0C98638](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1E0C98650](allocator, domain, code, userInfo);
}

CFErrorRef CFErrorCreateWithUserInfoKeysAndValues(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, const void *const *userInfoKeys, const void *const *userInfoValues, CFIndex numUserInfoValues)
{
  return (CFErrorRef)MEMORY[0x1E0C98658](allocator, domain, code, userInfoKeys, userInfoValues, numUserInfoValues);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1E0C98718](cf);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1E0C98720](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1E0C98758](cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1E0C98770]();
}

uint64_t CFLog()
{
  return MEMORY[0x1E0C98808]();
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1E0C98908]();
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1E0C989A8](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x1E0C989D0](number);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A60](key, applicationID, userName, hostName);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
  MEMORY[0x1E0C98A80](key, value, applicationID);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C98AA0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AB0](allocator, propertyList, mutabilityOption);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AD0](allocator, data, options, format, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  MEMORY[0x1E0C98B10](stream);
}

CFReadStreamRef CFReadStreamCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFReadStreamRef)MEMORY[0x1E0C98B38](alloc, bytes, length, bytesDeallocator);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B80](stream);
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1E0C98B88](stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98D70](theSet, value);
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98D78](theSet, applier, context);
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1E0C98D80](theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98D98](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1E0C98DA8](theSet);
}

CFTypeID CFSetGetTypeID(void)
{
  return MEMORY[0x1E0C98DB8]();
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
  MEMORY[0x1E0C98DD0](theSet, values);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98DE0](theSet, value);
}

void CFShow(CFTypeRef obj)
{
  MEMORY[0x1E0C98DF8](obj);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x1E0C98ED8](theString, appendedString);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  MEMORY[0x1E0C98EF0](theString, formatOptions, format);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1E0C98F58](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1E0C98F68](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1E0C98F78](alloc, theString);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98F88](alloc, data, *(_QWORD *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F90](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FC8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  return (CFStringRef)MEMORY[0x1E0C99008](alloc, buffer);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1E0C99020](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithPascalString(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C99028](alloc, pStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99050](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C99058](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99068](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1E0C990B0](theString, idx);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  double result;

  MEMORY[0x1E0C990D0](str);
  return result;
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C990E0](string, buffer, maxBufLen);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1E0C990F0](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99118](length, *(_QWORD *)&encoding);
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  return MEMORY[0x1E0C99128](string);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1E0C99168]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1E0C99190](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  MEMORY[0x1E0C991B8](str, idx, insertedStr);
}

Boolean CFStringIsEncodingAvailable(CFStringEncoding encoding)
{
  return MEMORY[0x1E0C991C0](*(_QWORD *)&encoding);
}

void CFStringReplaceAll(CFMutableStringRef theString, CFStringRef replacement)
{
  MEMORY[0x1E0C991F8](theString, replacement);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1E0C992C8](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C99320](url);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  return MEMORY[0x1E0C99338](url, key, propertyValueTypeRefPtr, error);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99348](anURL);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C99490](url, resolveAgainstBase, buffer, maxBufLen);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1E0C994B8]();
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1E0C99530](alloc, *(_QWORD *)&bytes.byte0, *(_QWORD *)&bytes.byte8);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  MEMORY[0x1E0C99600](stream);
}

CFErrorRef CFWriteStreamCopyError(CFWriteStreamRef stream)
{
  return (CFErrorRef)MEMORY[0x1E0C99608](stream);
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1E0C99610](stream, propertyName);
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  return (CFWriteStreamRef)MEMORY[0x1E0C99620](alloc, bufferAllocator);
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)MEMORY[0x1E0C99630](alloc, fileURL);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x1E0C99650](stream);
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1E0C99688](stream, buffer, bufferLength);
}

uint64_t CGAccessSessionCreate()
{
  return MEMORY[0x1E0C9BA60]();
}

uint64_t CGAccessSessionGetBytePointer()
{
  return MEMORY[0x1E0C9BA68]();
}

uint64_t CGAccessSessionGetBytes()
{
  return MEMORY[0x1E0C9BA70]();
}

uint64_t CGAccessSessionRelease()
{
  return MEMORY[0x1E0C9BA78]();
}

uint64_t CGAccessSessionRewind()
{
  return MEMORY[0x1E0C9BA80]();
}

uint64_t CGAccessSessionSkipForward()
{
  return MEMORY[0x1E0C9BA88]();
}

CGAffineTransform *__cdecl CGAffineTransformConcat(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t1, CGAffineTransform *t2)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BA90](retstr, t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAD8](retstr, sx, sy);
}

CGAffineTransform *__cdecl CGAffineTransformMakeTranslation(CGAffineTransform *__return_ptr retstr, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAE0](retstr, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x1E0C9BB10](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo);
}

CGImageRef CGBitmapContextCreateImage(CGContextRef context)
{
  return (CGImageRef)MEMORY[0x1E0C9BB20](context);
}

uint64_t CGBitmapContextCreateWithAlpha()
{
  return MEMORY[0x1E0C9BB28]();
}

uint64_t CGBitmapContextCreateWithDictionary()
{
  return MEMORY[0x1E0C9BB40]();
}

void *__cdecl CGBitmapContextGetData(CGContextRef context)
{
  return (void *)MEMORY[0x1E0C9BB70](context);
}

CGColorConversionInfoRef CGColorConversionInfoCreate(CGColorSpaceRef src, CGColorSpaceRef dst)
{
  return (CGColorConversionInfoRef)MEMORY[0x1E0C9BC48](src, dst);
}

CGColorConversionInfoRef CGColorConversionInfoCreateWithOptions(CGColorSpaceRef src, CGColorSpaceRef dst, CFDictionaryRef options)
{
  return (CGColorConversionInfoRef)MEMORY[0x1E0C9BC58](src, dst, options);
}

uint64_t CGColorConversionInfoIterateFunctionsWithCallbacks()
{
  return MEMORY[0x1E0C9BC70]();
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x1E0C9BC78](space, components);
}

CGFloat CGColorGetAlpha(CGColorRef color)
{
  CGFloat result;

  MEMORY[0x1E0C9BCF8](color);
  return result;
}

CGColorSpaceRef CGColorGetColorSpace(CGColorRef color)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BD00](color);
}

const CGFloat *__cdecl CGColorGetComponents(CGColorRef color)
{
  return (const CGFloat *)MEMORY[0x1E0C9BD08](color);
}

CFTypeID CGColorGetTypeID(void)
{
  return MEMORY[0x1E0C9BD38]();
}

uint64_t CGColorMatrixGetMatrix()
{
  return MEMORY[0x1E0C9BD40]();
}

uint64_t CGColorNxMTransformGetTransform()
{
  return MEMORY[0x1E0C9BD50]();
}

void CGColorRelease(CGColorRef color)
{
  MEMORY[0x1E0C9BD60](color);
}

CGColorRef CGColorRetain(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x1E0C9BD68](color);
}

uint64_t CGColorSpaceContainsFlexGTCInfo()
{
  return MEMORY[0x1E0C9BD70]();
}

uint64_t CGColorSpaceCopyBaseColorSpace()
{
  return MEMORY[0x1E0C9BD78]();
}

uint64_t CGColorSpaceCopyColorSyncProfile()
{
  return MEMORY[0x1E0C9BD80]();
}

uint64_t CGColorSpaceCopyColorTable()
{
  return MEMORY[0x1E0C9BD88]();
}

uint64_t CGColorSpaceCopyFlexGTCInfo()
{
  return MEMORY[0x1E0C9BD90]();
}

CFDataRef CGColorSpaceCopyICCData(CGColorSpaceRef space)
{
  return (CFDataRef)MEMORY[0x1E0C9BD98](space);
}

uint64_t CGColorSpaceCopyICCProfileDescription()
{
  return MEMORY[0x1E0C9BDB0]();
}

CFStringRef CGColorSpaceCopyName(CGColorSpaceRef space)
{
  return (CFStringRef)MEMORY[0x1E0C9BDB8](space);
}

CFPropertyListRef CGColorSpaceCopyPropertyList(CGColorSpaceRef space)
{
  return (CFPropertyListRef)MEMORY[0x1E0C9BDC0](space);
}

CGColorSpaceRef CGColorSpaceCreateDeviceCMYK(void)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BDE0]();
}

CGColorSpaceRef CGColorSpaceCreateDeviceGray(void)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BDE8]();
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BDF0]();
}

CGColorSpaceRef CGColorSpaceCreateExtendedLinearized(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE00](space);
}

uint64_t CGColorSpaceCreateFromCICP()
{
  return MEMORY[0x1E0C9BE08]();
}

CGColorSpaceRef CGColorSpaceCreateIndexed(CGColorSpaceRef baseSpace, size_t lastIndex, const unsigned __int8 *colorTable)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE18](baseSpace, lastIndex, colorTable);
}

CGColorSpaceRef CGColorSpaceCreateLab(const CGFloat *whitePoint, const CGFloat *blackPoint, const CGFloat *range)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE20](whitePoint, blackPoint, range);
}

CGColorSpaceRef CGColorSpaceCreateLinearized(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE28](space);
}

CGColorSpaceRef CGColorSpaceCreateWithColorSyncProfile(ColorSyncProfileRef a1, CFDictionaryRef options)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE38](a1, options);
}

CGColorSpaceRef CGColorSpaceCreateWithICCData(CFTypeRef data)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE40](data);
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE50](name);
}

CGColorSpaceRef CGColorSpaceCreateWithPropertyList(CFPropertyListRef plist)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE60](plist);
}

uint64_t CGColorSpaceEqualToColorSpace()
{
  return MEMORY[0x1E0C9BE68]();
}

CGColorSpaceRef CGColorSpaceGetBaseColorSpace(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE80](space);
}

uint64_t CGColorSpaceGetCICPInfo()
{
  return MEMORY[0x1E0C9BE88]();
}

void CGColorSpaceGetColorTable(CGColorSpaceRef space, uint8_t *table)
{
  MEMORY[0x1E0C9BEA0](space, table);
}

size_t CGColorSpaceGetColorTableCount(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BEA8](space);
}

uint64_t CGColorSpaceGetHeadroomInfo()
{
  return MEMORY[0x1E0C9BEB0]();
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BEC8](space);
}

CFStringRef CGColorSpaceGetName(CGColorSpaceRef space)
{
  return (CFStringRef)MEMORY[0x1E0C9BED0](space);
}

size_t CGColorSpaceGetNumberOfComponents(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BED8](space);
}

uint64_t CGColorSpaceGetRenderingIntent()
{
  return MEMORY[0x1E0C9BEE8]();
}

uint64_t CGColorSpaceGetType()
{
  return MEMORY[0x1E0C9BEF0]();
}

CFTypeID CGColorSpaceGetTypeID(void)
{
  return MEMORY[0x1E0C9BEF8]();
}

BOOL CGColorSpaceIsHDR(CGColorSpaceRef a1)
{
  return MEMORY[0x1E0C9BF00](a1);
}

BOOL CGColorSpaceIsHLGBased(CGColorSpaceRef s)
{
  return MEMORY[0x1E0C9BF08](s);
}

BOOL CGColorSpaceIsPQBased(CGColorSpaceRef s)
{
  return MEMORY[0x1E0C9BF18](s);
}

BOOL CGColorSpaceIsWideGamutRGB(CGColorSpaceRef a1)
{
  return MEMORY[0x1E0C9BF28](a1);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
  MEMORY[0x1E0C9BF30](space);
}

CGColorSpaceRef CGColorSpaceRetain(CGColorSpaceRef space)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BF38](space);
}

BOOL CGColorSpaceSupportsOutput(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BF40](space);
}

BOOL CGColorSpaceUsesExtendedRange(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BF48](space);
}

BOOL CGColorSpaceUsesITUR_2100TF(CGColorSpaceRef a1)
{
  return MEMORY[0x1E0C9BF50](a1);
}

uint64_t CGColorTRCGetFunction()
{
  return MEMORY[0x1E0C9BF58]();
}

uint64_t CGColorTRCGetGammaID()
{
  return MEMORY[0x1E0C9BF60]();
}

uint64_t CGColorTransformConvertColorComponents()
{
  return MEMORY[0x1E0C9BF80]();
}

uint64_t CGColorTransformCreate()
{
  return MEMORY[0x1E0C9BF90]();
}

void CGContextAddArc(CGContextRef c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise)
{
  MEMORY[0x1E0C9BFB0](c, *(_QWORD *)&clockwise, x, y, radius, startAngle, endAngle);
}

void CGContextAddCurveToPoint(CGContextRef c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9BFC0](c, cp1x, cp1y, cp2x, cp2y, x, y);
}

void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9BFD0](c, x, y);
}

void CGContextAddQuadCurveToPoint(CGContextRef c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9BFE0](c, cpx, cpy, x, y);
}

void CGContextBeginPage(CGContextRef c, const CGRect *mediaBox)
{
  MEMORY[0x1E0C9BFF8](c, mediaBox);
}

uint64_t CGContextClear()
{
  return MEMORY[0x1E0C9C018]();
}

void CGContextClearRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x1E0C9C020](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextClosePath(CGContextRef c)
{
  MEMORY[0x1E0C9C048](c);
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
  MEMORY[0x1E0C9C050](c, transform);
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  MEMORY[0x1E0C9C170](c, image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

uint64_t CGContextDrawImageWithOptions()
{
  return MEMORY[0x1E0C9C180]();
}

void CGContextDrawPDFPage(CGContextRef c, CGPDFPageRef page)
{
  MEMORY[0x1E0C9C1A0](c, page);
}

uint64_t CGContextDrawPDFPageWithAnnotations()
{
  return MEMORY[0x1E0C9C1A8]();
}

void CGContextEndPage(CGContextRef c)
{
  MEMORY[0x1E0C9C1F8](c);
}

uint64_t CGContextErase()
{
  return MEMORY[0x1E0C9C208]();
}

void CGContextFillPath(CGContextRef c)
{
  MEMORY[0x1E0C9C218](c);
}

void CGContextFillRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x1E0C9C220](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextFlush(CGContextRef c)
{
  MEMORY[0x1E0C9C230](c);
}

void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9C330](c, x, y);
}

void CGContextRelease(CGContextRef c)
{
  MEMORY[0x1E0C9C340](c);
}

void CGContextRestoreGState(CGContextRef c)
{
  MEMORY[0x1E0C9C370](c);
}

void CGContextSaveGState(CGContextRef c)
{
  MEMORY[0x1E0C9C388](c);
}

void CGContextScaleCTM(CGContextRef c, CGFloat sx, CGFloat sy)
{
  MEMORY[0x1E0C9C390](c, sx, sy);
}

void CGContextSetFillColorWithColor(CGContextRef c, CGColorRef color)
{
  MEMORY[0x1E0C9C408](c, color);
}

void CGContextSetGrayFillColor(CGContextRef c, CGFloat gray, CGFloat alpha)
{
  MEMORY[0x1E0C9C448](c, gray, alpha);
}

void CGContextSetInterpolationQuality(CGContextRef c, CGInterpolationQuality quality)
{
  MEMORY[0x1E0C9C458](c, *(_QWORD *)&quality);
}

uint64_t CGContextSetInterpolationQualityRange()
{
  return MEMORY[0x1E0C9C460]();
}

void CGContextSetLineWidth(CGContextRef c, CGFloat width)
{
  MEMORY[0x1E0C9C480](c, width);
}

void CGContextSetRGBFillColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x1E0C9C4A0](c, red, green, blue, alpha);
}

void CGContextSetRGBStrokeColor(CGContextRef c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)
{
  MEMORY[0x1E0C9C4A8](c, red, green, blue, alpha);
}

void CGContextSetShouldSmoothFonts(CGContextRef c, BOOL shouldSmoothFonts)
{
  MEMORY[0x1E0C9C4E0](c, shouldSmoothFonts);
}

uint64_t CGContextSetTextGreekingThreshold()
{
  return MEMORY[0x1E0C9C528]();
}

void CGContextSetTextMatrix(CGContextRef c, CGAffineTransform *t)
{
  MEMORY[0x1E0C9C530](c, t);
}

void CGContextSetTextPosition(CGContextRef c, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9C538](c, x, y);
}

void CGContextStrokePath(CGContextRef c)
{
  MEMORY[0x1E0C9C570](c);
}

void CGContextStrokeRect(CGContextRef c, CGRect rect)
{
  MEMORY[0x1E0C9C578](c, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextTranslateCTM(CGContextRef c, CGFloat tx, CGFloat ty)
{
  MEMORY[0x1E0C9C588](c, tx, ty);
}

CGDataConsumerRef CGDataConsumerCreate(void *info, const CGDataConsumerCallbacks *cbks)
{
  return (CGDataConsumerRef)MEMORY[0x1E0C9C5A8](info, cbks);
}

CGDataConsumerRef CGDataConsumerCreateWithCFData(CFMutableDataRef data)
{
  return (CGDataConsumerRef)MEMORY[0x1E0C9C5B0](data);
}

CGDataConsumerRef CGDataConsumerCreateWithURL(CFURLRef url)
{
  return (CGDataConsumerRef)MEMORY[0x1E0C9C5B8](url);
}

CFTypeID CGDataConsumerGetTypeID(void)
{
  return MEMORY[0x1E0C9C5C0]();
}

uint64_t CGDataConsumerPutBytes()
{
  return MEMORY[0x1E0C9C5C8]();
}

void CGDataConsumerRelease(CGDataConsumerRef consumer)
{
  MEMORY[0x1E0C9C5D0](consumer);
}

CFDataRef CGDataProviderCopyData(CGDataProviderRef provider)
{
  return (CFDataRef)MEMORY[0x1E0C9C5D8](provider);
}

CGDataProviderRef CGDataProviderCreateDirect(void *info, off_t size, const CGDataProviderDirectCallbacks *callbacks)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C5E0](info, size, callbacks);
}

CGDataProviderRef CGDataProviderCreateSequential(void *info, const CGDataProviderSequentialCallbacks *callbacks)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C5E8](info, callbacks);
}

CGDataProviderRef CGDataProviderCreateWithCFData(CFDataRef data)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C5F0](data);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C600](info, data, size, releaseData);
}

CGDataProviderRef CGDataProviderCreateWithURL(CFURLRef url)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C610](url);
}

uint64_t CGDataProviderGetBytes()
{
  return MEMORY[0x1E0C9C618]();
}

uint64_t CGDataProviderGetBytesAtPosition()
{
  return MEMORY[0x1E0C9C620]();
}

uint64_t CGDataProviderGetSizeOfData()
{
  return MEMORY[0x1E0C9C628]();
}

CFTypeID CGDataProviderGetTypeID(void)
{
  return MEMORY[0x1E0C9C630]();
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
  MEMORY[0x1E0C9C638](provider);
}

uint64_t CGDataProviderReleaseBytePtr()
{
  return MEMORY[0x1E0C9C640]();
}

CGDataProviderRef CGDataProviderRetain(CGDataProviderRef provider)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C648](provider);
}

uint64_t CGDataProviderRetainBytePtr()
{
  return MEMORY[0x1E0C9C650]();
}

uint64_t CGDataProviderRewind()
{
  return MEMORY[0x1E0C9C658]();
}

uint64_t CGGetMD5DigestOfBytes()
{
  return MEMORY[0x1E0C9CA38]();
}

uint64_t CGIOSurfaceContextCreate()
{
  return MEMORY[0x1E0C9CAD8]();
}

uint64_t CGImageBlockCreate()
{
  return MEMORY[0x1E0C9CB00]();
}

uint64_t CGImageBlockGetBytesPerRow()
{
  return MEMORY[0x1E0C9CB08]();
}

uint64_t CGImageBlockGetData()
{
  return MEMORY[0x1E0C9CB10]();
}

uint64_t CGImageBlockGetRect()
{
  return MEMORY[0x1E0C9CB18]();
}

uint64_t CGImageBlockRelease()
{
  return MEMORY[0x1E0C9CB20]();
}

uint64_t CGImageBlockSetCreate()
{
  return MEMORY[0x1E0C9CB28]();
}

uint64_t CGImageBlockSetCreateWithType()
{
  return MEMORY[0x1E0C9CB30]();
}

uint64_t CGImageBlockSetGetComponentType()
{
  return MEMORY[0x1E0C9CB38]();
}

uint64_t CGImageBlockSetGetCount()
{
  return MEMORY[0x1E0C9CB40]();
}

uint64_t CGImageBlockSetGetImageBlock()
{
  return MEMORY[0x1E0C9CB48]();
}

uint64_t CGImageBlockSetGetPixelSize()
{
  return MEMORY[0x1E0C9CB50]();
}

uint64_t CGImageBlockSetGetProperty()
{
  return MEMORY[0x1E0C9CB58]();
}

uint64_t CGImageBlockSetGetRect()
{
  return MEMORY[0x1E0C9CB60]();
}

uint64_t CGImageBlockSetRelease()
{
  return MEMORY[0x1E0C9CB68]();
}

uint64_t CGImageBlockSetSetProperty()
{
  return MEMORY[0x1E0C9CB78]();
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return (CGImageRef)MEMORY[0x1E0C9CB80](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, *(_QWORD *)&bitmapInfo, provider);
}

uint64_t CGImageCreateCopyWithClipPath()
{
  return MEMORY[0x1E0C9CB90]();
}

CGImageRef CGImageCreateCopyWithColorSpace(CGImageRef image, CGColorSpaceRef space)
{
  return (CGImageRef)MEMORY[0x1E0C9CB98](image, space);
}

uint64_t CGImageCreateWithImageProvider()
{
  return MEMORY[0x1E0C9CBB0]();
}

uint64_t CGImageDumpToFile()
{
  return MEMORY[0x1E0C9CBD8]();
}

CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image)
{
  return MEMORY[0x1E0C9CBE8](image);
}

CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image)
{
  return MEMORY[0x1E0C9CBF0](image);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return MEMORY[0x1E0C9CBF8](image);
}

size_t CGImageGetBitsPerPixel(CGImageRef image)
{
  return MEMORY[0x1E0C9CC00](image);
}

size_t CGImageGetBytesPerRow(CGImageRef image)
{
  return MEMORY[0x1E0C9CC08](image);
}

uint64_t CGImageGetClipPath()
{
  return MEMORY[0x1E0C9CC18]();
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9CC20](image);
}

uint64_t CGImageGetContentHeadroom()
{
  return MEMORY[0x1E0C9CC28]();
}

uint64_t CGImageGetData()
{
  return MEMORY[0x1E0C9CC30]();
}

CGDataProviderRef CGImageGetDataProvider(CGImageRef image)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9CC38](image);
}

const CGFloat *__cdecl CGImageGetDecode(CGImageRef image)
{
  return (const CGFloat *)MEMORY[0x1E0C9CC40](image);
}

uint64_t CGImageGetHeadroomInfo()
{
  return MEMORY[0x1E0C9CC58]();
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x1E0C9CC60](image);
}

uint64_t CGImageGetImageProvider()
{
  return MEMORY[0x1E0C9CC70]();
}

uint64_t CGImageGetMask()
{
  return MEMORY[0x1E0C9CC78]();
}

uint64_t CGImageGetMaskingColors()
{
  return MEMORY[0x1E0C9CC80]();
}

uint64_t CGImageGetProperty()
{
  return MEMORY[0x1E0C9CC98]();
}

CGColorRenderingIntent CGImageGetRenderingIntent(CGImageRef image)
{
  return MEMORY[0x1E0C9CCA0](image);
}

BOOL CGImageGetShouldInterpolate(CGImageRef image)
{
  return MEMORY[0x1E0C9CCA8](image);
}

uint64_t CGImageGetTransformForOrientationAndSize()
{
  return MEMORY[0x1E0C9CCB8]();
}

CFTypeID CGImageGetTypeID(void)
{
  return MEMORY[0x1E0C9CCC0]();
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x1E0C9CCD0](image);
}

uint64_t CGImageHasAlpha()
{
  return MEMORY[0x1E0C9CCD8]();
}

uint64_t CGImageIOSurfaceSetCreate()
{
  return MEMORY[0x1E0C9CCE0]();
}

BOOL CGImageIsMask(CGImageRef image)
{
  return MEMORY[0x1E0C9CCE8](image);
}

uint64_t CGImageIsOptimizedForSharing()
{
  return MEMORY[0x1E0C9CCF0]();
}

uint64_t CGImageProviderCopyIOSurface()
{
  return MEMORY[0x1E0C9CD10]();
}

uint64_t CGImageProviderCopyImageBlockSetWithOptions()
{
  return MEMORY[0x1E0C9CD20]();
}

uint64_t CGImageProviderCreate()
{
  return MEMORY[0x1E0C9CD30]();
}

uint64_t CGImageProviderGetAlphaInfo()
{
  return MEMORY[0x1E0C9CD38]();
}

uint64_t CGImageProviderGetBitmapInfo()
{
  return MEMORY[0x1E0C9CD40]();
}

uint64_t CGImageProviderGetCallbackVersion()
{
  return MEMORY[0x1E0C9CD48]();
}

uint64_t CGImageProviderGetColorSpace()
{
  return MEMORY[0x1E0C9CD50]();
}

uint64_t CGImageProviderGetComponentType()
{
  return MEMORY[0x1E0C9CD58]();
}

uint64_t CGImageProviderGetContentHeadroom()
{
  return MEMORY[0x1E0C9CD60]();
}

uint64_t CGImageProviderGetInfo()
{
  return MEMORY[0x1E0C9CD68]();
}

uint64_t CGImageProviderGetPixelSize()
{
  return MEMORY[0x1E0C9CD70]();
}

uint64_t CGImageProviderGetProperty()
{
  return MEMORY[0x1E0C9CD78]();
}

uint64_t CGImageProviderGetSize()
{
  return MEMORY[0x1E0C9CD80]();
}

uint64_t CGImageProviderRelease()
{
  return MEMORY[0x1E0C9CD88]();
}

uint64_t CGImageProviderSetProperty()
{
  return MEMORY[0x1E0C9CD98]();
}

void CGImageRelease(CGImageRef image)
{
  MEMORY[0x1E0C9CDA0](image);
}

CGImageRef CGImageRetain(CGImageRef image)
{
  return (CGImageRef)MEMORY[0x1E0C9CDA8](image);
}

uint64_t CGImageSetHeadroom()
{
  return MEMORY[0x1E0C9CDB8]();
}

uint64_t CGImageSetProperty()
{
  return MEMORY[0x1E0C9CDC0]();
}

uint64_t CGImageSurfaceSetGetIOSurface()
{
  return MEMORY[0x1E0C9CDC8]();
}

uint64_t CGImageTextureDataCreate()
{
  return MEMORY[0x1E0C9CDD0]();
}

uint64_t CGImageTextureDataGetNumberOfFaces()
{
  return MEMORY[0x1E0C9CDE0]();
}

uint64_t CGImageTextureDataGetNumberOfMipmaps()
{
  return MEMORY[0x1E0C9CDE8]();
}

uint64_t CGImageTextureDataGetPixelFormat()
{
  return MEMORY[0x1E0C9CDF8]();
}

uint64_t CGImageTextureDataGetSize()
{
  return MEMORY[0x1E0C9CE00]();
}

uint64_t CGImageTextureDataIsCompressed()
{
  return MEMORY[0x1E0C9CE08]();
}

uint64_t CGImageTextureDataSupportsTiledLayout()
{
  return MEMORY[0x1E0C9CE20]();
}

void CGPDFContextBeginPage(CGContextRef context, CFDictionaryRef pageInfo)
{
  MEMORY[0x1E0C9CEC0](context, pageInfo);
}

void CGPDFContextClose(CGContextRef context)
{
  MEMORY[0x1E0C9CEC8](context);
}

CGContextRef CGPDFContextCreate(CGDataConsumerRef consumer, const CGRect *mediaBox, CFDictionaryRef auxiliaryInfo)
{
  return (CGContextRef)MEMORY[0x1E0C9CED0](consumer, mediaBox, auxiliaryInfo);
}

void CGPDFContextEndPage(CGContextRef context)
{
  MEMORY[0x1E0C9CEE0](context);
}

uint64_t CGPDFDocumentCopyInfoDictionary()
{
  return MEMORY[0x1E0C9CF40]();
}

CGPDFDocumentRef CGPDFDocumentCreateWithProvider(CGDataProviderRef provider)
{
  return (CGPDFDocumentRef)MEMORY[0x1E0C9CF58](provider);
}

CGPDFAccessPermissions CGPDFDocumentGetAccessPermissions(CGPDFDocumentRef document)
{
  return MEMORY[0x1E0C9CF68](document);
}

size_t CGPDFDocumentGetNumberOfPages(CGPDFDocumentRef document)
{
  return MEMORY[0x1E0C9CF98](document);
}

CGPDFPageRef CGPDFDocumentGetPage(CGPDFDocumentRef document, size_t pageNumber)
{
  return (CGPDFPageRef)MEMORY[0x1E0C9CFA0](document, pageNumber);
}

BOOL CGPDFDocumentIsEncrypted(CGPDFDocumentRef document)
{
  return MEMORY[0x1E0C9CFB0](document);
}

BOOL CGPDFDocumentIsUnlocked(CGPDFDocumentRef document)
{
  return MEMORY[0x1E0C9CFC0](document);
}

void CGPDFDocumentRelease(CGPDFDocumentRef document)
{
  MEMORY[0x1E0C9CFC8](document);
}

uint64_t CGPDFPageContainsWideGamutContent()
{
  return MEMORY[0x1E0C9D078]();
}

CGRect CGPDFPageGetBoxRect(CGPDFPageRef page, CGPDFBox box)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D090](page, *(_QWORD *)&box);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

int CGPDFPageGetRotationAngle(CGPDFPageRef page)
{
  return MEMORY[0x1E0C9D0C8](page);
}

uint64_t CGPDFSourceRead()
{
  return MEMORY[0x1E0C9D250]();
}

uint64_t CGPDFSourceRelease()
{
  return MEMORY[0x1E0C9D258]();
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9D298](path, m, cp1x, cp1y, cp2x, cp2y, x, y);
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
  MEMORY[0x1E0C9D310](path);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x1E0C9D388]();
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x1E0C9D490](path, m, x, y);
}

void CGPathRelease(CGPathRef path)
{
  MEMORY[0x1E0C9D498](path);
}

CGPathRef CGPathRetain(CGPathRef path)
{
  return (CGPathRef)MEMORY[0x1E0C9D4A0](path);
}

BOOL CGRectContainsRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1E0C9D558]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9D560]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1E0C9D570]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D580]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D588]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5A0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5D0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x1E0C9D5E8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D5F8]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x1E0C9D608]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x1E0C9D630]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D640]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9D808]((__n128)size, *(__n128 *)&size.height);
}

uint64_t ColorSyncCreateInputPoppyProfile()
{
  return MEMORY[0x1E0C95430]();
}

uint64_t ColorSyncCreateOutputPoppyProfileForRGBData()
{
  return MEMORY[0x1E0C95438]();
}

uint64_t ColorSyncDataCanBeIgnoredOnSRGBDevice()
{
  return MEMORY[0x1E0C95440]();
}

uint64_t ColorSyncMakeProfile()
{
  return MEMORY[0x1E0C95450]();
}

CFDataRef ColorSyncProfileCopyData(ColorSyncProfileRef prof, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C95458](prof, error);
}

ColorSyncProfileRef ColorSyncProfileCreate(CFDataRef data, CFErrorRef *error)
{
  return (ColorSyncProfileRef)MEMORY[0x1E0C95470](data, error);
}

uint64_t ColorSyncProfileCreateCopyWithFlexGTC()
{
  return MEMORY[0x1E0C95478]();
}

uint64_t ColorSyncProfileCreateSanitizedCopy()
{
  return MEMORY[0x1E0C95490]();
}

BOOL ColorSyncProfileVerify(ColorSyncProfileRef prof, CFErrorRef *errors, CFErrorRef *warnings)
{
  return MEMORY[0x1E0C954C0](prof, errors, warnings);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x1E0CBB6F0](*(_QWORD *)&object);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB9A0](*(_QWORD *)&entry, plane, key, allocator, *(_QWORD *)&options);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x1E0CBB9E0](*(_QWORD *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBBA00](name);
}

uint64_t IOSurfaceAcceleratorCreate()
{
  return MEMORY[0x1E0D3A1D0]();
}

uint64_t IOSurfaceAcceleratorTransformSurface()
{
  return MEMORY[0x1E0D3A200]();
}

CFDictionaryRef IOSurfaceCopyAllValues(IOSurfaceRef buffer)
{
  return (CFDictionaryRef)MEMORY[0x1E0CBBAE0](buffer);
}

CFTypeRef IOSurfaceCopyValue(IOSurfaceRef buffer, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0CBBAE8](buffer, key);
}

IOSurfaceRef IOSurfaceCreate(CFDictionaryRef properties)
{
  return (IOSurfaceRef)MEMORY[0x1E0CBBAF0](properties);
}

xpc_object_t IOSurfaceCreateXPCObject(IOSurfaceRef aSurface)
{
  return (xpc_object_t)MEMORY[0x1E0CBBB10](aSurface);
}

void IOSurfaceDecrementUseCount(IOSurfaceRef buffer)
{
  MEMORY[0x1E0CBBB18](buffer);
}

size_t IOSurfaceGetAllocSize(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBB38](buffer);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x1E0CBBB40](buffer);
}

void *__cdecl IOSurfaceGetBaseAddressOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return (void *)MEMORY[0x1E0CBBB68](buffer, planeIndex);
}

uint64_t IOSurfaceGetBulkAttachments()
{
  return MEMORY[0x1E0CBBB70]();
}

size_t IOSurfaceGetBytesPerElementOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1E0CBBB88](buffer, planeIndex);
}

size_t IOSurfaceGetBytesPerRow(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBB90](buffer);
}

size_t IOSurfaceGetBytesPerRowOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1E0CBBBA0](buffer, planeIndex);
}

uint64_t IOSurfaceGetCompressionTypeOfPlane()
{
  return MEMORY[0x1E0CBBBD8]();
}

size_t IOSurfaceGetHeight(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBC28](buffer);
}

size_t IOSurfaceGetHeightOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1E0CBBC38](buffer, planeIndex);
}

OSType IOSurfaceGetPixelFormat(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBC68](buffer);
}

size_t IOSurfaceGetPlaneCount(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBC70](buffer);
}

uint64_t IOSurfaceGetProtectionOptions()
{
  return MEMORY[0x1E0CBBC90]();
}

IOSurfaceComponentRange IOSurfaceGetRangeOfComponentOfPlane(IOSurfaceRef buffer, size_t planeIndex, size_t componentIndex)
{
  return MEMORY[0x1E0CBBC98](buffer, planeIndex, componentIndex);
}

size_t IOSurfaceGetWidth(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBCE0](buffer);
}

size_t IOSurfaceGetWidthOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1E0CBBCF0](buffer, planeIndex);
}

uint64_t IOSurfaceGetYCbCrMatrix()
{
  return MEMORY[0x1E0CBBCF8]();
}

void IOSurfaceIncrementUseCount(IOSurfaceRef buffer)
{
  MEMORY[0x1E0CBBD00](buffer);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1E0CBBD28](buffer, *(_QWORD *)&options, seed);
}

IOSurfaceRef IOSurfaceLookupFromXPCObject(xpc_object_t xobj)
{
  return (IOSurfaceRef)MEMORY[0x1E0CBBD48](xobj);
}

void IOSurfaceRemoveValue(IOSurfaceRef buffer, CFStringRef key)
{
  MEMORY[0x1E0CBBDE8](buffer, key);
}

uint64_t IOSurfaceSetBulkAttachments2()
{
  return MEMORY[0x1E0CBBDF8]();
}

uint64_t IOSurfaceSetOwnershipIdentity()
{
  return MEMORY[0x1E0CBBE28]();
}

void IOSurfaceSetValue(IOSurfaceRef buffer, CFStringRef key, CFTypeRef value)
{
  MEMORY[0x1E0CBBE40](buffer, key, value);
}

uint64_t IOSurfaceSetYCbCrMatrix()
{
  return MEMORY[0x1E0CBBE50]();
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1E0CBBE88](buffer, *(_QWORD *)&options, seed);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1E0DE2B20]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1E0DE2B50]();
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x1E0CC6978]();
}

uint64_t MTLPixelFormatGetInfoForDevice()
{
  return MEMORY[0x1E0CC69C0]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1E0CB28A0](aClassName);
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x1E0CB2D88](format);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1E0CB3200](aClass);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1E0CD65F0](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1E0CD6610](allocator);
}

XML_Status XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)
{
  return MEMORY[0x1E0DE5818](parser, s, *(_QWORD *)&len, *(_QWORD *)&isFinal);
}

XML_Parser XML_ParserCreateNS(const XML_Char *encoding, XML_Char namespaceSeparator)
{
  return (XML_Parser)MEMORY[0x1E0DE5820](encoding, namespaceSeparator);
}

void XML_ParserFree(XML_Parser parser)
{
  MEMORY[0x1E0DE5828](parser);
}

void XML_SetCdataSectionHandler(XML_Parser parser, XML_StartCdataSectionHandler start, XML_EndCdataSectionHandler end)
{
  MEMORY[0x1E0DE5830](parser, start, end);
}

void XML_SetCharacterDataHandler(XML_Parser parser, XML_CharacterDataHandler handler)
{
  MEMORY[0x1E0DE5838](parser, handler);
}

void XML_SetCommentHandler(XML_Parser parser, XML_CommentHandler handler)
{
  MEMORY[0x1E0DE5840](parser, handler);
}

void XML_SetElementHandler(XML_Parser parser, XML_StartElementHandler start, XML_EndElementHandler end)
{
  MEMORY[0x1E0DE5848](parser, start, end);
}

void XML_SetNamespaceDeclHandler(XML_Parser parser, XML_StartNamespaceDeclHandler start, XML_EndNamespaceDeclHandler end)
{
  MEMORY[0x1E0DE5850](parser, start, end);
}

void XML_SetProcessingInstructionHandler(XML_Parser parser, XML_ProcessingInstructionHandler handler)
{
  MEMORY[0x1E0DE5858](parser, handler);
}

void XML_SetUserData(XML_Parser parser, void *userData)
{
  MEMORY[0x1E0DE5860](parser, userData);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1E0C9A498]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1E0C9A4B0]();
}

uint64_t _CFStringGetFileSystemRepresentation()
{
  return MEMORY[0x1E0C9A520]();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return MEMORY[0x1E0C9A800]();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return MEMORY[0x1E0C9A818]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1E0DE41C8](this, __c, __pos);
}

std::string::size_type std::string::rfind(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1E0DE41D0](this, __c, __pos);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1E0DE41F0]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4288](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1E0DE4388](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

std::string *__cdecl std::string::erase(std::string *this, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4408](this, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4420](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4428](this, __s, __n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4430](this, __str, __pos, __n);
}

std::string *__cdecl std::string::append(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  return (std::string *)MEMORY[0x1E0DE4438](this, __n, __c);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4440](this, __s);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4448](this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4450](this, __str, __pos, __n);
}

std::string *__cdecl std::string::assign(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  return (std::string *)MEMORY[0x1E0DE4458](this, __n, __c);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4468](this, __pos, __s);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  MEMORY[0x1E0DE4480](this, __n, __c);
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x1E0DE4490](this, __pos, __n1, __s, __n2);
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
  MEMORY[0x1E0DE44A8](this, __requested_capacity);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x1E0DE44B8](this, __c);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1E0DE44C8](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1E0DE44D8](this, __str);
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1E0DE4608]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1E0DE46B0]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1E0DE46B8]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1E0DE46C8]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1E0DE46D0]();
}

{
  return MEMORY[0x1E0DE46E8]();
}

{
  return MEMORY[0x1E0DE46F8]();
}

{
  return MEMORY[0x1E0DE4700]();
}

{
  return MEMORY[0x1E0DE4708]();
}

{
  return MEMORY[0x1E0DE4730]();
}

{
  return MEMORY[0x1E0DE4738]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1E0DE47A8]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
  MEMORY[0x1E0DE4890](this);
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
  MEMORY[0x1E0DE48A8](this, __lk);
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
  MEMORY[0x1E0DE48B0](this);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1E0DE48F8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
  MEMORY[0x1E0DE4920](*(_QWORD *)&__ev, __what_arg);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA0](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA8](this);
}

void std::mutex::~mutex(std::mutex *this)
{
  MEMORY[0x1E0DE4AB8](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x1E0DE4C50](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

std::bad_alloc *__cdecl std::bad_alloc::bad_alloc(std::bad_alloc *this)
{
  return (std::bad_alloc *)MEMORY[0x1E0DE4DB0](this);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x1E0DE4DD8](this);
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

uint64_t operator delete[]()
{
  return off_1E1B80198();
}

void operator delete(void *__p)
{
  off_1E1B801A0(__p);
}

uint64_t operator delete()
{
  return off_1E1B801A8();
}

uint64_t operator new[]()
{
  return off_1E1B801B0();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E1B801B8(__sz);
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  return (void *)off_1E1B801C0(__sz, a2);
}

uint64_t operator new()
{
  return off_1E1B801C8();
}

uint64_t __CFSetLastAllocationEventName()
{
  return MEMORY[0x1E0C9A9A0]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1E0C80A98](lpfunc, obj, lpdso_handle);
}

void __cxa_bad_cast(void)
{
  MEMORY[0x1E0DE5070]();
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

void __cxa_call_unexpected(void *a1)
{
  MEMORY[0x1E0DE5088](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE5098]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x1E0DE50A0](a1);
}

void *__cxa_get_exception_ptr(void *a1)
{
  return (void *)MEMORY[0x1E0DE50A8](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x1E0DE50B0](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x1E0DE50D0]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x1E0DE50E0](lpsrc, lpstype, lpdtype, s2d);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

simd_float3x3 __invert_f3(simd_float3x3 a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  simd_float3x3 result;

  MEMORY[0x1E0C80B30]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2]);
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1E0C80B68]();
}

__float2 __sincosf_stret(float a1)
{
  float v1;
  float v2;
  __float2 result;

  MEMORY[0x1E0C80BD0](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  return MEMORY[0x1E0C80BE8](a1, *(_QWORD *)&a2, a3, a4);
}

uint64_t __strncat_chk()
{
  return MEMORY[0x1E0C80C50]();
}

uint64_t _amkrtemp()
{
  return MEMORY[0x1E0C80CB8]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1E0C81010]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81020](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81040](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

simd_float4 _simd_exp2_f4(simd_float4 x)
{
  simd_float4 result;

  MEMORY[0x1E0C811C8]((__n128)x);
  return result;
}

simd_float4 _simd_exp_f4(simd_float4 x)
{
  simd_float4 result;

  MEMORY[0x1E0C811D0]((__n128)x);
  return result;
}

simd_float4 _simd_log2_f4(simd_float4 x)
{
  simd_float4 result;

  MEMORY[0x1E0C811E0]((__n128)x);
  return result;
}

simd_float4 _simd_log_f4(simd_float4 x)
{
  simd_float4 result;

  MEMORY[0x1E0C811E8]((__n128)x);
  return result;
}

simd_float4 _simd_pow_f4(simd_float4 x, simd_float4 y)
{
  simd_float4 result;

  MEMORY[0x1E0C811F8]((__n128)x, (__n128)y);
  return result;
}

uint64_t _xpc_runtime_is_app_sandboxed()
{
  return MEMORY[0x1E0C812A0]();
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1E0C813D0](a1, *(_QWORD *)&a2);
}

uLong adler32(uLong adler, const Bytef *buf, uInt len)
{
  return MEMORY[0x1E0DE9290](adler, buf, *(_QWORD *)&len);
}

uint64_t applejpeg_decode_clear_options()
{
  return MEMORY[0x1E0CFCF80]();
}

uint64_t applejpeg_decode_create()
{
  return MEMORY[0x1E0CFCF90]();
}

uint64_t applejpeg_decode_destroy()
{
  return MEMORY[0x1E0CFCF98]();
}

uint64_t applejpeg_decode_dump_ra_table()
{
  return MEMORY[0x1E0CFCFA0]();
}

uint64_t applejpeg_decode_get_chroma_subsampling()
{
  return MEMORY[0x1E0CFCFA8]();
}

uint64_t applejpeg_decode_get_image_info()
{
  return MEMORY[0x1E0CFCFB0]();
}

uint64_t applejpeg_decode_get_output_buffer_size()
{
  return MEMORY[0x1E0CFCFB8]();
}

uint64_t applejpeg_decode_get_output_dimensions()
{
  return MEMORY[0x1E0CFCFC0]();
}

uint64_t applejpeg_decode_get_precision()
{
  return MEMORY[0x1E0CFCFD0]();
}

uint64_t applejpeg_decode_get_qtables()
{
  return MEMORY[0x1E0CFCFD8]();
}

uint64_t applejpeg_decode_get_ra_table_sz()
{
  return MEMORY[0x1E0CFCFE0]();
}

uint64_t applejpeg_decode_get_segment_info()
{
  return MEMORY[0x1E0CFCFE8]();
}

uint64_t applejpeg_decode_image_all()
{
  return MEMORY[0x1E0CFCFF0]();
}

uint64_t applejpeg_decode_open_file()
{
  return MEMORY[0x1E0CFCFF8]();
}

uint64_t applejpeg_decode_set_option_buildindex()
{
  return MEMORY[0x1E0CFD020]();
}

uint64_t applejpeg_decode_set_option_crop()
{
  return MEMORY[0x1E0CFD028]();
}

uint64_t applejpeg_decode_set_option_error_fill()
{
  return MEMORY[0x1E0CFD030]();
}

uint64_t applejpeg_decode_set_option_force_app14()
{
  return MEMORY[0x1E0CFD038]();
}

uint64_t applejpeg_decode_set_option_mosquito_spray()
{
  return MEMORY[0x1E0CFD040]();
}

uint64_t applejpeg_decode_set_option_multithread()
{
  return MEMORY[0x1E0CFD048]();
}

uint64_t applejpeg_decode_set_option_outformat()
{
  return MEMORY[0x1E0CFD058]();
}

uint64_t applejpeg_decode_set_option_outsize()
{
  return MEMORY[0x1E0CFD060]();
}

uint64_t applejpeg_decode_set_option_stride()
{
  return MEMORY[0x1E0CFD068]();
}

uint64_t applejpeg_decode_set_ra_table()
{
  return MEMORY[0x1E0CFD080]();
}

uint64_t applejpeg_encode_create()
{
  return MEMORY[0x1E0CFD090]();
}

uint64_t applejpeg_encode_destroy()
{
  return MEMORY[0x1E0CFD098]();
}

uint64_t applejpeg_encode_image_row()
{
  return MEMORY[0x1E0CFD0B0]();
}

uint64_t applejpeg_encode_options_init()
{
  return MEMORY[0x1E0CFD0B8]();
}

uint64_t applejpeg_encode_set_options_file()
{
  return MEMORY[0x1E0CFD100]();
}

uint64_t applejpeg_encode_set_options_mem()
{
  return MEMORY[0x1E0CFD108]();
}

uint64_t applejpeg_recode_all_file()
{
  return MEMORY[0x1E0CFD110]();
}

uint64_t applejpeg_recode_clear_options()
{
  return MEMORY[0x1E0CFD118]();
}

uint64_t applejpeg_recode_close()
{
  return MEMORY[0x1E0CFD120]();
}

uint64_t applejpeg_recode_get_image_info()
{
  return MEMORY[0x1E0CFD128]();
}

uint64_t applejpeg_recode_open_file()
{
  return MEMORY[0x1E0CFD130]();
}

uint64_t applejpeg_recode_set_option_accelerated_resize()
{
  return MEMORY[0x1E0CFD138]();
}

uint64_t applejpeg_recode_set_option_aspect()
{
  return MEMORY[0x1E0CFD140]();
}

uint64_t applejpeg_recode_set_option_converter()
{
  return MEMORY[0x1E0CFD148]();
}

uint64_t applejpeg_recode_set_option_jpeg_quality()
{
  return MEMORY[0x1E0CFD168]();
}

uint64_t applejpeg_recode_set_option_jpeg_type()
{
  return MEMORY[0x1E0CFD170]();
}

uint64_t applejpeg_recode_set_option_orientation()
{
  return MEMORY[0x1E0CFD178]();
}

uint64_t applejpeg_recode_set_option_outsize()
{
  return MEMORY[0x1E0CFD180]();
}

uint64_t applejpeg_recode_set_option_skip_app0()
{
  return MEMORY[0x1E0CFD190]();
}

uint64_t applejpeg_resize_plugin_set_preferred_format()
{
  return MEMORY[0x1E0CFD198]();
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1E0C81608](a1, a2);
}

at_block_features_t at_block_get_features(at_block_format_t blockType, at_block_buffer_t *src, at_size_t validSize, size_t size, size_t *outSize, at_flags_t flags)
{
  return (at_block_features_t)MEMORY[0x1E0DE4078](blockType, src, *(_QWORD *)&validSize.x, *(_QWORD *)&validSize.z, size, outSize, flags);
}

float at_encoder_compress_texels(at_encoder_t encoder, const at_texel_region_t *src, const at_block_buffer_t *dest, float errorThreshold, at_flags_t flags)
{
  float result;

  MEMORY[0x1E0DE4080](encoder, src, dest, flags, errorThreshold);
  return result;
}

at_encoder_t at_encoder_create(at_texel_format_t texelType, at_alpha_t texelAlphaType, at_block_format_t blockType, at_alpha_t blockAlphaType, const float *backgroundColor)
{
  return (at_encoder_t)MEMORY[0x1E0DE4088](texelType, *(_QWORD *)&texelAlphaType, blockType, *(_QWORD *)&blockAlphaType, backgroundColor);
}

at_error_t at_encoder_decompress_texels(at_encoder_t encoder, const at_block_buffer_t *src, const at_texel_region_t *dest, at_flags_t flags)
{
  return MEMORY[0x1E0DE4090](encoder, src, dest, flags);
}

at_size_t at_encoder_get_block_counts(at_encoder_t encoder, at_size_t imageSize)
{
  uint64_t v2;
  uint32_t v3;
  at_size_t result;

  v2 = MEMORY[0x1E0DE4098](encoder, *(_QWORD *)&imageSize.x, *(_QWORD *)&imageSize.z);
  result.x = v2;
  result.y = HIDWORD(v2);
  result.z = v3;
  return result;
}

size_t at_encoder_get_block_size(at_encoder_t encoder)
{
  return MEMORY[0x1E0DE40A0](encoder);
}

BOOL at_encoder_is_compression_monolithic(at_encoder_t encoder, at_flags_t flags)
{
  return MEMORY[0x1E0DE40A8](encoder, flags);
}

long double atan2(long double __y, long double __x)
{
  long double result;

  MEMORY[0x1E0C81620](__y, __x);
  return result;
}

double atof(const char *a1)
{
  double result;

  MEMORY[0x1E0C81658](a1);
  return result;
}

int atoi(const char *a1)
{
  return MEMORY[0x1E0C81668](a1);
}

uint64_t atol(const char *a1)
{
  return MEMORY[0x1E0C81678](a1);
}

uint64_t atoll(const char *a1)
{
  return MEMORY[0x1E0C81688](a1);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1E0C816B8](a1, *(_QWORD *)&a2);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x1E0C81738](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

int cache_create(const char *name, const cache_attributes_t *attrs, cache_t **cache_out)
{
  return MEMORY[0x1E0C81770](name, attrs, cache_out);
}

int cache_get_and_retain(cache_t *cache, void *key, void **value_out)
{
  return MEMORY[0x1E0C81788](cache, key, value_out);
}

uintptr_t cache_hash_byte_string(const char *data, size_t bytes)
{
  return MEMORY[0x1E0C817C0](data, bytes);
}

uint64_t cache_print()
{
  return MEMORY[0x1E0C817D0]();
}

int cache_release_value(cache_t *cache, void *value)
{
  return MEMORY[0x1E0C817D8](cache, value);
}

int cache_remove(cache_t *cache, void *key)
{
  return MEMORY[0x1E0C817E0](cache, key);
}

int cache_set_and_retain(cache_t *cache, void *key, void *value, cache_cost_t cost)
{
  return MEMORY[0x1E0C817F8](cache, key, value, cost);
}

void cblas_sgemv(const CBLAS_ORDER __Order, const CBLAS_TRANSPOSE __TransA, const int __M, const int __N, const float __alpha, const float *__A, const int __lda, const float *__X, const int __incX, const float __beta, float *__Y, const int __incY)
{
  MEMORY[0x1E0C8BC20](*(_QWORD *)&__Order, *(_QWORD *)&__TransA, *(_QWORD *)&__M, *(_QWORD *)&__N, __A, *(_QWORD *)&__lda, __X, *(_QWORD *)&__incX, __alpha, __beta);
}

void cblas_ssyrk(const CBLAS_ORDER __Order, const CBLAS_UPLO __Uplo, const CBLAS_TRANSPOSE __Trans, const int __N, const int __K, const float __alpha, const float *__A, const int __lda, const float __beta, float *__C, const int __ldc)
{
  MEMORY[0x1E0C8BC70](*(_QWORD *)&__Order, *(_QWORD *)&__Uplo, *(_QWORD *)&__Trans, *(_QWORD *)&__N, *(_QWORD *)&__K, __A, *(_QWORD *)&__lda, __C, __alpha, __beta);
}

void clearerr(FILE *a1)
{
  MEMORY[0x1E0C82648](a1);
}

clock_t clock(void)
{
  return MEMORY[0x1E0C82650]();
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

size_t compression_encode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x1E0DE5280](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(_QWORD *)&algorithm);
}

compression_status compression_stream_destroy(compression_stream *stream)
{
  return MEMORY[0x1E0DE5290](stream);
}

compression_status compression_stream_init(compression_stream *stream, compression_stream_operation operation, compression_algorithm algorithm)
{
  return MEMORY[0x1E0DE52A0](stream, *(_QWORD *)&operation, *(_QWORD *)&algorithm);
}

compression_status compression_stream_process(compression_stream *stream, int flags)
{
  return MEMORY[0x1E0DE52B0](stream, *(_QWORD *)&flags);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return MEMORY[0x1E0C826D0](*(_QWORD *)&a1, a2, a3);
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return MEMORY[0x1E0DE92B0](crc, buf, *(_QWORD *)&len);
}

int deflate(z_streamp strm, int flush)
{
  return MEMORY[0x1E0DE92C0](strm, *(_QWORD *)&flush);
}

int deflateEnd(z_streamp strm)
{
  return MEMORY[0x1E0DE92D0](strm);
}

int deflateInit2_(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE92D8](strm, *(_QWORD *)&level, *(_QWORD *)&method, *(_QWORD *)&windowBits, *(_QWORD *)&memLevel, *(_QWORD *)&strategy, version, *(_QWORD *)&stream_size);
}

int deflateInit_(z_streamp strm, int level, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE92E0](strm, *(_QWORD *)&level, version, *(_QWORD *)&stream_size);
}

int deflateParams(z_streamp strm, int level, int strategy)
{
  return MEMORY[0x1E0DE92E8](strm, *(_QWORD *)&level, *(_QWORD *)&strategy);
}

int deflateReset(z_streamp strm)
{
  return MEMORY[0x1E0DE92F8](strm);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
  MEMORY[0x1E0C82BD8](iterations, queue, block);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x1E0C82CB0](buffer, size, queue, destructor);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D10](group, queue, block);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82D38](group, queue, block);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

dispatch_workloop_t dispatch_workloop_create(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x1E0C82FD8](label);
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1E0C83028](a1, a2);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1E0C83038]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

uint64_t dyld_process_is_restricted()
{
  return MEMORY[0x1E0C83128]();
}

void exit(int a1)
{
  MEMORY[0x1E0C83278](*(_QWORD *)&a1);
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x1E0C83280](__x);
  return result;
}

long double exp2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83288](__x);
  return result;
}

float exp2f(float a1)
{
  float result;

  MEMORY[0x1E0C83290](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1E0C83300](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int feof(FILE *a1)
{
  return MEMORY[0x1E0C83340](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x1E0C83348](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x1E0C833A0](a1, *(_QWORD *)&a2, a3);
}

int fileno(FILE *a1)
{
  return MEMORY[0x1E0C833B0](a1);
}

void flockfile(FILE *a1)
{
  MEMORY[0x1E0C83408](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1E0C83488](*(_QWORD *)&a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1E0C83490](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C834A0](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

float frexpf(float a1, int *a2)
{
  float result;

  MEMORY[0x1E0C834F0](a2, a1);
  return result;
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x1E0C83530](a1, a2, *(_QWORD *)&a3);
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  return MEMORY[0x1E0C83538](__stream, a2, *(_QWORD *)&__whence);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x1E0C83580](a1);
}

off_t ftello(FILE *__stream)
{
  return MEMORY[0x1E0C83588](__stream);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1E0C83590](*(_QWORD *)&a1, a2);
}

FILE *__cdecl funopen(const void *a1, int (__cdecl *a2)(void *, char *, int), int (__cdecl *a3)(void *, const char *, int), fpos_t (__cdecl *a4)(void *, fpos_t, int), int (__cdecl *a5)(void *))
{
  return (FILE *)MEMORY[0x1E0C835C8](a1, a2, a3, a4, a5);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1E0C83610](a1, a2, a3, a4, *(_QWORD *)&a5);
}

int getc(FILE *a1)
{
  return MEMORY[0x1E0C83638](a1);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x1E0C83778]();
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1E0C83860](a1, a2);
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x1E0DE93A0](strm, *(_QWORD *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x1E0DE93B8](strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE93C8](strm, *(_QWORD *)&windowBits, version, *(_QWORD *)&stream_size);
}

int inflateInit_(z_streamp strm, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE93D0](strm, version, *(_QWORD *)&stream_size);
}

int inflateReset(z_streamp strm)
{
  return MEMORY[0x1E0DE93D8](strm);
}

int inflateReset2(z_streamp strm, int windowBits)
{
  return MEMORY[0x1E0DE93E0](strm, *(_QWORD *)&windowBits);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1E0C83A20]();
}

long double ldexp(long double __x, int __e)
{
  long double result;

  MEMORY[0x1E0C83B40](*(_QWORD *)&__e, __x);
  return result;
}

float ldexpf(float a1, int a2)
{
  float result;

  MEMORY[0x1E0C83B48](*(_QWORD *)&a2, a1);
  return result;
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1E0C83BA8](a1);
}

long double log(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BB8](__x);
  return result;
}

long double log2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BE8](__x);
  return result;
}

float log2f(float a1)
{
  float result;

  MEMORY[0x1E0C83BF0](a1);
  return result;
}

float logf(float a1)
{
  float result;

  MEMORY[0x1E0C83C00](a1);
  return result;
}

void longjmp(jmp_buf a1, int a2)
{
  MEMORY[0x1E0C83C08](a1, *(_QWORD *)&a2);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1E0C83C38](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1E0C83C80](*(_QWORD *)&error_value);
}

kern_return_t mach_make_memory_entry_64(vm_map_t target_task, memory_object_size_t *size, memory_object_offset_t offset, vm_prot_t permission, mach_port_t *object_handle, mem_entry_name_port_t parent_entry)
{
  return MEMORY[0x1E0C83C98](*(_QWORD *)&target_task, size, offset, *(_QWORD *)&permission, object_handle, *(_QWORD *)&parent_entry);
}

kern_return_t mach_memory_entry_ownership(mem_entry_name_port_t mem_entry, task_t owner, int ledger_tag, int ledger_flags)
{
  return MEMORY[0x1E0C83CA0](*(_QWORD *)&mem_entry, *(_QWORD *)&owner, *(_QWORD *)&ledger_tag, *(_QWORD *)&ledger_flags);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1E0C83CF8](*(_QWORD *)&task, *(_QWORD *)&name);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

kern_return_t mach_vm_protect(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, BOOLean_t set_maximum, vm_prot_t new_protection)
{
  return MEMORY[0x1E0C83DE8](*(_QWORD *)&target_task, address, size, *(_QWORD *)&set_maximum, *(_QWORD *)&new_protection);
}

int madvise(void *a1, size_t a2, int a3)
{
  return MEMORY[0x1E0C83E60](a1, a2, *(_QWORD *)&a3);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x1E0C83F08](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1E0C84070](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
{
  return (void *)MEMORY[0x1E0C84090](__big, __big_len, __little, __little_len);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x1E0C840B8](__b, __pattern16, __len);
}

char *__cdecl mktemp(char *a1)
{
  return (char *)MEMORY[0x1E0C841C0](a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1E0C841D8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1E0C84220](a1, a2);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1E0DE7BF0](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1E0DE7BF8]();
}

void objc_end_catch(void)
{
  MEMORY[0x1E0DE7C80]();
}

void objc_exception_rethrow(void)
{
  MEMORY[0x1E0DE7C98]();
}

void objc_exception_throw(id exception)
{
  MEMORY[0x1E0DE7CA0](exception);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D20](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7E58](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E60](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1E0DE7E70](a1);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7FA0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C84480](a1, *(_QWORD *)&a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

void os_release(void *object)
{
  MEMORY[0x1E0C84910](object);
}

uint64_t os_simple_hash()
{
  return MEMORY[0x1E0C84938]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C84998](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x1E0C849F0]();
}

void perror(const char *a1)
{
  MEMORY[0x1E0C84AF0](a1);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C84BB8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C84BC0](a1, a2);
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1E0C84BC8](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1E0C84BD0](a1);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D18](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D20](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x1E0C84D28](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D30](a1);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x1E0C84D48](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1E0C84D50](a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x1E0C84DD8](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_trylock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E30](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E40](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E48](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1E0C84E60](a1, *(_QWORD *)&a2);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1E0C84E68](a1, a2);
}

int pthread_rwlock_destroy(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84E90](a1);
}

int pthread_rwlock_init(pthread_rwlock_t *a1, const pthread_rwlockattr_t *a2)
{
  return MEMORY[0x1E0C84E98](a1, a2);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EA0](a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EB8](a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return MEMORY[0x1E0C84EC0](a1);
}

int putchar(int a1)
{
  return MEMORY[0x1E0C84F50](*(_QWORD *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x1E0C84F60](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

void qsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
  MEMORY[0x1E0C84F90](__base, __nel, __width, __compar);
}

void qsort_r(void *__base, size_t __nel, size_t __width, void *a4, int (__cdecl *__compar)(void *, const void *, const void *))
{
  MEMORY[0x1E0C84F98](__base, __nel, __width, a4, __compar);
}

int rand(void)
{
  return MEMORY[0x1E0C84FB0]();
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1E0C85000](*(_QWORD *)&a1, a2, a3);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1E0C85030](__ptr, __size);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x1E0C85100](__from, __to, __ec);
}

int rmdir(const char *a1)
{
  return MEMORY[0x1E0C85138](a1);
}

uint64_t rootless_trusted_by_self_token()
{
  return MEMORY[0x1E0C85160]();
}

uint64_t rootless_verify_trusted_by_self_token()
{
  return MEMORY[0x1E0C85168]();
}

uint64_t sandbox_check()
{
  return MEMORY[0x1E0C85178]();
}

int setjmp(jmp_buf a1)
{
  return MEMORY[0x1E0C85348](a1);
}

char *__cdecl setlocale(int a1, const char *a2)
{
  return (char *)MEMORY[0x1E0C85358](*(_QWORD *)&a1, a2);
}

void siglongjmp(sigjmp_buf a1, int a2)
{
  MEMORY[0x1E0C853E8](a1, *(_QWORD *)&a2);
}

int sigsetjmp(sigjmp_buf a1, int a2)
{
  return MEMORY[0x1E0C85408](a1, *(_QWORD *)&a2);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int sprintf(char *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C85460](a1, a2);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C85498](a1, a2);
}

int ssyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_real *__a, __CLPK_integer *__lda, __CLPK_real *__w, __CLPK_real *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x1E0C8BF10](__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x1E0C854E0](a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1E0C85500](a1, a2);
}

char *__cdecl strcasestr(const char *__big, const char *__little)
{
  return (char *)MEMORY[0x1E0C85508](__big, __little);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85510](__s1, __s2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C85518](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x1E0C85530](__dst, __src);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1E0C85538](__s, __charset);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85570](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1E0C85590](a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B0](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1E0C855C0](__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return (char *)MEMORY[0x1E0C855C8](__big, __little, __len);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C855E8](__s, *(_QWORD *)&__c);
}

size_t strspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1E0C85608](__s, __charset);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

double strtod(const char *a1, char **a2)
{
  double result;

  MEMORY[0x1E0C85618](a1, a2);
  return result;
}

char *__cdecl strtok(char *__str, const char *__sep)
{
  return (char *)MEMORY[0x1E0C85648](__str, __sep);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85658](__str, __endptr, *(_QWORD *)&__base);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1E0C857A0](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
  MEMORY[0x1E0C857D0](*(_QWORD *)&a1, a2);
}

kern_return_t task_create_identity_token(task_t task, task_id_token_t *token)
{
  return MEMORY[0x1E0C85808](*(_QWORD *)&task, token);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1E0C85950](a1);
}

void tzset(void)
{
  MEMORY[0x1E0C85990]();
}

int unlink(const char *a1)
{
  return MEMORY[0x1E0C859B8](a1);
}

vImage_Error vImageAlphaBlend_ARGB8888(const vImage_Buffer *srcTop, const vImage_Buffer *srcBottom, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CB98](srcTop, srcBottom, dest, *(_QWORD *)&flags);
}

vImage_Error vImageBuffer_InitWithCGImage(vImage_Buffer *buf, vImage_CGImageFormat *format, const CGFloat *backgroundColor, CGImageRef image, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CC28](buf, format, backgroundColor, image, *(_QWORD *)&flags);
}

vImage_Error vImageByteSwap_Planar16U(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CC38](src, dest, *(_QWORD *)&flags);
}

Boolean vImageCGImageFormat_IsEqual(const vImage_CGImageFormat *f1, const vImage_CGImageFormat *f2)
{
  return MEMORY[0x1E0C8CC80](f1, f2);
}

vImage_Error vImageClipToAlpha_RGBA8888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CD00](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_16Fto16U(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CD28](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_16UToPlanar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CD40](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_16Uto16F(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CD48](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_420Yp8_CbCr8ToARGB8888(const vImage_Buffer *srcYp, const vImage_Buffer *srcCbCr, const vImage_Buffer *dest, const vImage_YpCbCrToARGB *info, const uint8_t permuteMap[4], const uint8_t alpha, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CD70](srcYp, srcCbCr, dest, info, permuteMap, alpha, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_ARGB16UToARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], uint8_t copyMask, const Pixel_8888 backgroundColor, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CE08](src, dest, permuteMap, copyMask, backgroundColor, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_ARGB16UtoARGB8888_dithered(const vImage_Buffer *src, const vImage_Buffer *dest, int dither, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8CE18](src, dest, *(_QWORD *)&dither, permuteMap, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_ARGB16UtoRGB16U(const vImage_Buffer *argbSrc, const vImage_Buffer *rgbDest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CE28](argbSrc, rgbDest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_ARGB2101010ToARGB16U(const vImage_Buffer *src, const vImage_Buffer *dest, int32_t RGB101010RangeMin, int32_t RGB101010RangeMax, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8CE30](src, dest, *(_QWORD *)&RGB101010RangeMin, *(_QWORD *)&RGB101010RangeMax, permuteMap, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_ARGB8888To420Yp8_CbCr8(const vImage_Buffer *src, const vImage_Buffer *destYp, const vImage_Buffer *destCbCr, const vImage_ARGBToYpCbCr *info, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8CE40](src, destYp, destCbCr, info, permuteMap, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_ARGB8888ToARGB16U(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], uint8_t copyMask, const Pixel_ARGB_16U backgroundColor, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CE88](src, dest, permuteMap, copyMask, backgroundColor, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_ARGB8888toRGB888(const vImage_Buffer *a1, const vImage_Buffer *a2, vImage_Flags a3)
{
  return MEMORY[0x1E0C8CEB8](a1, a2, *(_QWORD *)&a3);
}

vImage_Error vImageConvert_ARGBToYpCbCr_GenerateConversion(const vImage_ARGBToYpCbCrMatrix *matrix, const vImage_YpCbCrPixelRange *pixelRange, vImage_ARGBToYpCbCr *outInfo, vImageARGBType inARGBType, vImageYpCbCrType outYpCbCrType, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CEE8](matrix, pixelRange, outInfo, *(_QWORD *)&inARGBType, *(_QWORD *)&outYpCbCrType, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_AnyToAny(const vImageConverterRef converter, const vImage_Buffer *srcs, const vImage_Buffer *dests, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CEF0](converter, srcs, dests, tempBuffer, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_Planar16FtoPlanar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CF20](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_Planar16UtoPlanar8_dithered(const vImage_Buffer *src, const vImage_Buffer *dest, int dither, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CF40](src, dest, *(_QWORD *)&dither, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_Planar1toPlanar8(const vImage_Buffer *src, const vImage_Buffer *dest, const vImage_Flags flags)
{
  return MEMORY[0x1E0C8CF48](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_Planar2toPlanar8(const vImage_Buffer *src, const vImage_Buffer *dest, const vImage_Flags flags)
{
  return MEMORY[0x1E0C8CF50](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_Planar4toPlanar8(const vImage_Buffer *src, const vImage_Buffer *dest, const vImage_Flags flags)
{
  return MEMORY[0x1E0C8CF58](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_Planar8To16U(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CF60](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_RGB16UtoRGB888_dithered(const vImage_Buffer *src, const vImage_Buffer *dest, int dither, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CFE8](src, dest, *(_QWORD *)&dither, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_RGB565toBGRA8888(Pixel_8 alpha, const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D008](alpha, src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_RGB565toRGB888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D010](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_RGB565toRGBA8888(Pixel_8 alpha, const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D020](alpha, src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_RGB888toARGB8888(const vImage_Buffer *a1, const vImage_Buffer *a2, Pixel_8 a3, const vImage_Buffer *a4, BOOL a5, vImage_Flags a6)
{
  return MEMORY[0x1E0C8D028](a1, a2, a3, a4, a5, *(_QWORD *)&a6);
}

vImage_Error vImageConvert_RGB888toBGRA8888(const vImage_Buffer *a1, const vImage_Buffer *a2, Pixel_8 a3, const vImage_Buffer *a4, BOOL a5, vImage_Flags a6)
{
  return MEMORY[0x1E0C8D030](a1, a2, a3, a4, a5, *(_QWORD *)&a6);
}

vImage_Error vImageConvert_RGB888toRGBA8888(const vImage_Buffer *a1, const vImage_Buffer *a2, Pixel_8 a3, const vImage_Buffer *a4, BOOL a5, vImage_Flags a6)
{
  return MEMORY[0x1E0C8D048](a1, a2, a3, a4, a5, *(_QWORD *)&a6);
}

vImage_Error vImageConvert_RGBA5551toRGB565(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D060](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_XRGB2101010ToARGB16F(const vImage_Buffer *src, Pixel_F alpha, const vImage_Buffer *dest, int32_t RGB101010RangeMin, int32_t RGB101010RangeMax, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8D0A0](src, dest, *(_QWORD *)&RGB101010RangeMin, *(_QWORD *)&RGB101010RangeMax, permuteMap, *(_QWORD *)&flags, alpha);
}

vImage_Error vImageConvert_XRGB2101010ToARGB16U(const vImage_Buffer *src, uint16_t alpha, const vImage_Buffer *dest, int32_t RGB101010RangeMin, int32_t RGB101010RangeMax, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8D0A8](src, alpha, dest, *(_QWORD *)&RGB101010RangeMin, *(_QWORD *)&RGB101010RangeMax, permuteMap, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_XRGB2101010ToARGB8888(const vImage_Buffer *src, Pixel_8 alpha, const vImage_Buffer *dest, int32_t RGB101010RangeMin, int32_t RGB101010RangeMax, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8D0B0](src, alpha, dest, *(_QWORD *)&RGB101010RangeMin, *(_QWORD *)&RGB101010RangeMax, permuteMap, *(_QWORD *)&flags);
}

uint64_t vImageConvert_XRGB2101010_A8ToARGB16F()
{
  return MEMORY[0x1E0C8D0E0]();
}

uint64_t vImageConvert_XRGB2101010_A8ToARGB8888()
{
  return MEMORY[0x1E0C8D0F0]();
}

vImage_Error vImageConvert_YpCbCrToARGB_GenerateConversion(const vImage_YpCbCrToARGBMatrix *matrix, const vImage_YpCbCrPixelRange *pixelRange, vImage_YpCbCrToARGB *outInfo, vImageYpCbCrType inYpCbCrType, vImageARGBType outARGBType, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D0F8](matrix, pixelRange, outInfo, *(_QWORD *)&inYpCbCrType, *(_QWORD *)&outARGBType, *(_QWORD *)&flags);
}

vImageConverterRef vImageConverter_CreateWithCGColorConversionInfo(CGColorConversionInfoRef colorConversionInfoRef, const vImage_CGImageFormat *sFormat, const vImage_CGImageFormat *dFormat, const CGFloat *bg, vImage_Flags flags, vImage_Error *error)
{
  return (vImageConverterRef)MEMORY[0x1E0C8D118](colorConversionInfoRef, sFormat, dFormat, bg, *(_QWORD *)&flags, error);
}

vImageConverterRef vImageConverter_CreateWithCGImageFormat(const vImage_CGImageFormat *srcFormat, const vImage_CGImageFormat *destFormat, const CGFloat *backgroundColor, vImage_Flags flags, vImage_Error *error)
{
  return (vImageConverterRef)MEMORY[0x1E0C8D120](srcFormat, destFormat, backgroundColor, *(_QWORD *)&flags, error);
}

vImage_Error vImageConverter_MustOperateOutOfPlace(const vImageConverterRef converter, const vImage_Buffer *srcs, const vImage_Buffer *dests, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D150](converter, srcs, dests, *(_QWORD *)&flags);
}

uint64_t vImageConverter_Print()
{
  return MEMORY[0x1E0C8D158]();
}

void vImageConverter_Release(vImageConverterRef converter)
{
  MEMORY[0x1E0C8D160](converter);
}

CGImageRef vImageCreateCGImageFromBuffer(const vImage_Buffer *buf, const vImage_CGImageFormat *format, void (__cdecl *callback)(void *, void *), void *userData, vImage_Flags flags, vImage_Error *error)
{
  return (CGImageRef)MEMORY[0x1E0C8D1E8](buf, format, callback, userData, *(_QWORD *)&flags, error);
}

vImage_Error vImageExtractChannel_ARGB16U(const vImage_Buffer *src, const vImage_Buffer *dest, uint64_t channelIndex, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D280](src, dest, channelIndex, *(_QWORD *)&flags);
}

vImage_Error vImageExtractChannel_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, uint64_t channelIndex, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D288](src, dest, channelIndex, *(_QWORD *)&flags);
}

vImage_Error vImageHorizontalReflect_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D360](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageOverwriteChannelsWithScalar_ARGB8888(Pixel_8 scalar, const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t copyMask, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D4B0](scalar, src, dest, copyMask, *(_QWORD *)&flags);
}

vImage_Error vImageOverwriteChannelsWithScalar_Planar16U(Pixel_16U scalar, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D4C8](scalar, dest, *(_QWORD *)&flags);
}

vImage_Error vImageOverwriteChannelsWithScalar_PlanarF(Pixel_F scalar, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D4D8](dest, *(_QWORD *)&flags, scalar);
}

vImage_Error vImageOverwriteChannels_ARGB8888(const vImage_Buffer *newSrc, const vImage_Buffer *origSrc, const vImage_Buffer *dest, uint8_t copyMask, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D4E8](newSrc, origSrc, dest, copyMask, *(_QWORD *)&flags);
}

vImage_Error vImagePermuteChannels_ARGB16U(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8D510](src, dest, permuteMap, *(_QWORD *)&flags);
}

vImage_Error vImagePermuteChannels_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8D520](src, dest, permuteMap, *(_QWORD *)&flags);
}

vImage_Error vImagePermuteChannels_RGB888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[3], vImage_Flags flags)
{
  return MEMORY[0x1E0C8D538](src, dest, permuteMap, *(_QWORD *)&flags);
}

vImage_Error vImagePremultipliedAlphaBlend_BGRA8888(const vImage_Buffer *srcTop, const vImage_Buffer *srcBottom, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D5E0](srcTop, srcBottom, dest, *(_QWORD *)&flags);
}

vImage_Error vImagePremultiplyData_ARGB16U(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D5F8](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImagePremultiplyData_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D600](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImagePremultiplyData_RGBA16F(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D620](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImagePremultiplyData_RGBA16U(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D628](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImagePremultiplyData_RGBA8888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D630](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageRotate90_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_8 backColor, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D688](src, dest, rotationConstant, backColor, *(_QWORD *)&flags);
}

vImage_Error vImageScale_ARGB16F(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D6D8](src, dest, tempBuffer, *(_QWORD *)&flags);
}

vImage_Error vImageScale_ARGB16U(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D6E0](src, dest, tempBuffer, *(_QWORD *)&flags);
}

vImage_Error vImageScale_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D6E8](src, dest, tempBuffer, *(_QWORD *)&flags);
}

vImage_Error vImageScale_Planar16F(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D718](src, dest, tempBuffer, *(_QWORD *)&flags);
}

vImage_Error vImageScale_Planar16U(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D720](src, dest, tempBuffer, *(_QWORD *)&flags);
}

vImage_Error vImageScale_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D728](src, dest, tempBuffer, *(_QWORD *)&flags);
}

vImage_Error vImageScale_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D738](src, dest, tempBuffer, *(_QWORD *)&flags);
}

vImage_Error vImageUnpremultiplyData_ARGB16U(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D7A0](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageUnpremultiplyData_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D7A8](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageUnpremultiplyData_RGBA16F(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D7C8](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageUnpremultiplyData_RGBA16U(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D7D0](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageUnpremultiplyData_RGBA8888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D7D8](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageVerticalReflect_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D7F8](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageVerticalReflect_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D818](src, dest, *(_QWORD *)&flags);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x1E0C85A58](a1, a2, a3);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x1E0C85A68](a1, a2, a3);
}

kern_return_t vm_purgable_control(vm_map_t target_task, vm_address_t address, vm_purgable_t control, int *state)
{
  return MEMORY[0x1E0C85AE8](*(_QWORD *)&target_task, address, *(_QWORD *)&control, state);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1E0C85D40](*(_QWORD *)&__fd, __buf, __nbyte);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
  MEMORY[0x1E0C85DE0](xarray, value);
}

xpc_object_t xpc_array_create_empty(void)
{
  return (xpc_object_t)MEMORY[0x1E0C85E10]();
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1E0C85E30](xarray);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1E0C85E90](xarray, index);
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1E0C85F90](name, targetq);
}

const char *__cdecl xpc_connection_get_name(xpc_connection_t connection)
{
  return (const char *)MEMORY[0x1E0C86000](connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
  MEMORY[0x1E0C86018](connection);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
  MEMORY[0x1E0C86030](connection, message);
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
  MEMORY[0x1E0C86038](connection, message, replyq, handler);
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1E0C86048](connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x1E0C86080](connection, handler);
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x1E0C86178](bytes, length);
}

xpc_object_t xpc_data_create_with_dispatch_data(dispatch_data_t ddata)
{
  return (xpc_object_t)MEMORY[0x1E0C86188](ddata);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return MEMORY[0x1E0C861F0](xdict, applier);
}

uint64_t xpc_dictionary_copy_mach_send()
{
  return MEMORY[0x1E0C86200]();
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

xpc_object_t xpc_dictionary_create_empty(void)
{
  return (xpc_object_t)MEMORY[0x1E0C86218]();
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1E0C86228](original);
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C86248](xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C86260](xdict, key);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return MEMORY[0x1E0C86270](xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1E0C86278](xdict, key, length);
}

xpc_object_t xpc_dictionary_get_dictionary(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C86288](xdict, key);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  double result;

  MEMORY[0x1E0C86298](xdict, key);
  return result;
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862A0](xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1E0C862C8](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862D0](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C862E0](xdict, key);
}

uint64_t xpc_dictionary_handoff_reply()
{
  return MEMORY[0x1E0C862F0]();
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
  MEMORY[0x1E0C86310](xdict, key, value);
}

void xpc_dictionary_set_double(xpc_object_t xdict, const char *key, double value)
{
  MEMORY[0x1E0C86348](xdict, key, value);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
  MEMORY[0x1E0C86360](xdict, key, value);
}

uint64_t xpc_dictionary_set_mach_send()
{
  return MEMORY[0x1E0C86378]();
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
  MEMORY[0x1E0C86398](xdict, key, value);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
  MEMORY[0x1E0C863B8](xdict, key, value);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1E0C86520](object);
}

void xpc_release(xpc_object_t object)
{
  MEMORY[0x1E0C86658](object);
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1E0C86660](object);
}

xpc_object_t xpc_shmem_create(void *region, size_t length)
{
  return (xpc_object_t)MEMORY[0x1E0C866F0](region, length);
}

size_t xpc_shmem_map(xpc_object_t xshmem, void **region)
{
  return MEMORY[0x1E0C86700](xshmem, region);
}

