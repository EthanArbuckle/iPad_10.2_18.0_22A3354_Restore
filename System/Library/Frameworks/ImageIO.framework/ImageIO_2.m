void sub_187F1E654(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F1E660(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

BOOL jp2_input_box::read(jp2_input_box *this, unsigned int *a2)
{
  uint64_t v2;
  int v5;
  unsigned int v6;
  int v7;
  int v8;

  v2 = *((int *)this + 44);
  if ((int)v2 >= 4)
    jp2_input_box::read();
  v5 = *((_DWORD *)this + 44)
     + (*(uint64_t (**)(jp2_input_box *, char *, _QWORD))(*(_QWORD *)this + 32))(this, (char *)this + v2 + 152, (4 - v2));
  *((_DWORD *)this + 44) = v5;
  if (v5 >= 4)
  {
    if (v5 != 4)
      jp2_input_box::read();
    v6 = *((unsigned __int8 *)this + 152);
    *a2 = v6;
    v7 = *((unsigned __int8 *)this + 153) | (v6 << 8);
    *a2 = v7;
    v8 = *((unsigned __int8 *)this + 154) | (v7 << 8);
    *a2 = v8;
    *a2 = *((unsigned __int8 *)this + 155) | (v8 << 8);
    *((_DWORD *)this + 44) = 0;
  }
  return v5 > 3;
}

BOOL jp2_input_box::read(jp2_input_box *this, unsigned __int16 *a2)
{
  int v4;
  int v5;
  unsigned __int16 v6;
  _OWORD v8[2];
  uint64_t v9;

  v4 = *((_DWORD *)this + 44);
  if (v4 >= 2)
  {
    v9 = 0;
    memset(v8, 0, sizeof(v8));
    kdu_error::kdu_error((kdu_error *)v8, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v8[0] + 16))(v8, "Attempting to read a 2-byte word from a JP2 box, after first reading a partial 4-byte word!");
    kdu_error::~kdu_error((kdu_error *)v8);
  }
  v5 = *((_DWORD *)this + 44)
     + (*(uint64_t (**)(jp2_input_box *, char *, _QWORD))(*(_QWORD *)this + 32))(this, (char *)this + v4 + 152, (2 - v4));
  *((_DWORD *)this + 44) = v5;
  if (v5 >= 2)
  {
    if (v5 != 2)
      jp2_input_box::read();
    v6 = *((unsigned __int8 *)this + 152);
    *a2 = v6;
    *a2 = *((unsigned __int8 *)this + 153) | (unsigned __int16)(v6 << 8);
    *((_DWORD *)this + 44) = 0;
  }
  return v5 > 1;
}

void sub_187F1E81C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1E828()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_family_tgt::open(uint64_t this, kdu_compressed_target *a2)
{
  _OWORD v2[2];
  uint64_t v3;

  if (*(_QWORD *)(this + 8) || *(_QWORD *)(this + 16))
  {
    v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  *(_QWORD *)(this + 16) = a2;
  *(_QWORD *)(this + 24) = 0;
  *(_BYTE *)(this + 32) = 0;
  return this;
}

void sub_187F1E8B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1E8BC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

FILE *jp2_family_tgt::close(jp2_family_tgt *this)
{
  FILE *result;
  _QWORD *v3;

  v3 = (_QWORD *)((char *)this + 8);
  result = (FILE *)*((_QWORD *)this + 1);
  if (result)
    result = (FILE *)fclose(result);
  *((_BYTE *)this + 32) = 0;
  *v3 = 0;
  v3[1] = 0;
  return result;
}

void jp2_output_box::jp2_output_box(jp2_output_box *this)
{
  *(_QWORD *)this = &off_1E1BB0038;
  *((_DWORD *)this + 2) = 0;
  *((_BYTE *)this + 72) = 0;
  *((_BYTE *)this + 12) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 7) = -1;
  *((_QWORD *)this + 8) = 0;
}

void jp2_output_box::~jp2_output_box(jp2_output_box *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BB0038;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8077774924);
  *(_QWORD *)this = off_1E1BB2398;
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BB0038;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8077774924);
  *(_QWORD *)this = off_1E1BB2398;
  JUMPOUT(0x18D761C30);
}

uint64_t jp2_output_box::open(uint64_t this, jp2_family_tgt *a2, int a3, int a4)
{
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  if (*(_DWORD *)(this + 8))
  {
    v6 = 0;
    v4 = 0u;
    v5 = 0u;
    kdu_error::kdu_error((kdu_error *)&v4, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v4);
  }
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  if (a2)
  {
    if (*((_BYTE *)a2 + 32))
    {
      v6 = 0;
      v4 = 0u;
      v5 = 0u;
      kdu_error::kdu_error((kdu_error *)&v4, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)&v4);
    }
  }
  else if (a4)
  {
    jp2_output_box::open();
  }
  if (*(_QWORD *)(this + 64) || *(_DWORD *)(this + 32))
    jp2_output_box::open();
  *(_DWORD *)(this + 8) = a3;
  *(_BYTE *)(this + 12) = a4;
  *(_QWORD *)(this + 16) = a2;
  *(_QWORD *)(this + 40) = 0;
  *(_QWORD *)(this + 48) = -1;
  *(_QWORD *)(this + 56) = -1;
  *(_BYTE *)(this + 72) = 0;
  *(_BYTE *)(this + 73) = a4;
  *(_BYTE *)(this + 74) = 0;
  if (a4)
    return jp2_output_box::write_header((jp2_output_box *)this);
  return this;
}

void sub_187F1EAFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1EB08()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::write_header(jp2_output_box *this)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t result;
  unsigned int v8;

  if (!*((_DWORD *)this + 2) || !*((_QWORD *)this + 2) && !*((_QWORD *)this + 3))
    jp2_output_box::write_header();
  if (!*((_BYTE *)this + 73))
    jp2_output_box::write_header();
  if ((*((_QWORD *)this + 7) & 0x8000000000000000) == 0)
    jp2_output_box::write_header();
  v2 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = -16;
  if (*((_BYTE *)this + 12))
  {
    if (*((_BYTE *)this + 74))
      jp2_output_box::write_header();
    v8 = 0;
  }
  else
  {
    v3 = *((_QWORD *)this + 6);
    if ((v3 & 0x8000000000000000) != 0)
      jp2_output_box::write_header();
    v4 = 16;
    if (v3 < 0x1FFFFFFF8)
      v4 = 8;
    if (*((_BYTE *)this + 74))
      v5 = v4 + v3 + 8;
    else
      v5 = v4 + v3;
    if (v3 > 0x1FFFFFFF7 || *((_BYTE *)this + 74))
    {
      v8 = 0x1000000;
      (*(void (**)(jp2_output_box *, unsigned int *, uint64_t))(*(_QWORD *)this + 40))(this, &v8, 4);
      v8 = bswap32(*((_DWORD *)this + 2));
      (*(void (**)(jp2_output_box *, unsigned int *, uint64_t))(*(_QWORD *)this + 40))(this, &v8, 4);
      HIBYTE(v8) = BYTE4(v5);
      BYTE2(v8) = BYTE5(v5);
      BYTE1(v8) = BYTE6(v5);
      LOBYTE(v8) = HIBYTE(v5);
      (*(void (**)(jp2_output_box *, unsigned int *, uint64_t))(*(_QWORD *)this + 40))(this, &v8, 4);
      v6 = bswap32(v5);
      goto LABEL_19;
    }
    v8 = bswap32(v5);
  }
  (*(void (**)(jp2_output_box *, unsigned int *, uint64_t))(*(_QWORD *)this + 40))(this, &v8, 4);
  v6 = bswap32(*((_DWORD *)this + 2));
LABEL_19:
  v8 = v6;
  result = (*(uint64_t (**)(jp2_output_box *, unsigned int *, uint64_t))(*(_QWORD *)this + 40))(this, &v8, 4);
  *((_QWORD *)this + 5) = v2;
  return result;
}

uint64_t jp2_output_box::open(uint64_t this, jp2_output_box *a2, int a3, int a4)
{
  jp2_output_box *v5;
  _OWORD v6[2];
  uint64_t v7;

  v5 = (jp2_output_box *)this;
  if (*(_DWORD *)(this + 8))
  {
    v7 = 0;
    memset(v6, 0, sizeof(v6));
    kdu_error::kdu_error((kdu_error *)v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v6);
  }
  if (*(_QWORD *)(this + 64) || *(_DWORD *)(this + 32))
    jp2_output_box::open();
  *(_DWORD *)(this + 8) = a3;
  *(_BYTE *)(this + 12) = a4;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = a2;
  *(_QWORD *)(this + 40) = 0;
  *(_QWORD *)(this + 48) = -1;
  *(_QWORD *)(this + 56) = -1;
  *(_BYTE *)(this + 72) = 0;
  *(_BYTE *)(this + 73) = a4;
  *(_BYTE *)(this + 74) = 0;
  if (a4)
  {
    jp2_output_box::set_rubber_length((uint64_t)a2);
    if (!*((_BYTE *)a2 + 12) || !*((_BYTE *)a2 + 73))
      jp2_output_box::open();
    return jp2_output_box::write_header(v5);
  }
  return this;
}

void sub_187F1ED9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1EDA8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::set_rubber_length(uint64_t this)
{
  uint64_t v1;
  jp2_output_box *v2;
  uint64_t v3;
  uint64_t v4;
  FILE *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  if (!*(_DWORD *)(this + 8))
    jp2_output_box::set_rubber_length();
  v1 = this;
  if ((*(_QWORD *)(this + 16) || *(_QWORD *)(this + 24)) && !*(_BYTE *)(this + 12))
  {
    if (*(_BYTE *)(this + 73))
    {
      v11 = 0;
      v9 = 0u;
      v10 = 0u;
      kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Attempting to set a rubber length for a JP2 box whose total length has already been declared, or is to be written at the end.");
      kdu_error::~kdu_error((kdu_error *)&v9);
    }
    if ((*(_QWORD *)(this + 56) & 0x8000000000000000) == 0)
    {
      v11 = 0;
      v9 = 0u;
      v10 = 0u;
      kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Attempting to set a rubber length for a JP2 box which is currently inside a rewrite section.");
      kdu_error::~kdu_error((kdu_error *)&v9);
    }
    v2 = *(jp2_output_box **)(this + 24);
    if (v2)
      jp2_output_box::set_rubber_length(v2);
    *(_BYTE *)(v1 + 12) = 1;
    *(_BYTE *)(v1 + 73) = 1;
    this = jp2_output_box::write_header((jp2_output_box *)v1);
    if (*(_QWORD *)(v1 + 64))
    {
      v3 = *(_QWORD *)(v1 + 24);
      if (v3)
      {
        *(_BYTE *)(v1 + 72) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3) ^ 1;
      }
      else
      {
        v4 = *(_QWORD *)(v1 + 16);
        v5 = *(FILE **)(v4 + 8);
        if (v5)
        {
          v6 = fwrite(*(const void **)(v1 + 64), 1uLL, *(_QWORD *)(v1 + 40), v5);
          v7 = *(_QWORD *)(v1 + 40);
          *(_BYTE *)(v1 + 72) = v6 != v7;
        }
        else
        {
          v8 = *(_QWORD *)(v4 + 16);
          if (!v8)
            jp2_output_box::set_rubber_length();
          *(_BYTE *)(v1 + 72) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8) ^ 1;
          v7 = *(_QWORD *)(v1 + 40);
        }
        *(_QWORD *)(*(_QWORD *)(v1 + 16) + 24) += v7;
      }
      this = *(_QWORD *)(v1 + 64);
      if (this)
        this = MEMORY[0x18D761C18](this, 0x1000C8077774924);
      *(_DWORD *)(v1 + 32) = 0;
      *(_QWORD *)(v1 + 64) = 0;
    }
  }
  return this;
}

void sub_187F1EF5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1EF68()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::open_next(jp2_output_box *this)
{
  uint64_t (*v1)(void);
  _OWORD v3[2];
  uint64_t v4;

  if (*((_QWORD *)this + 3))
  {
    v1 = *(uint64_t (**)(void))(*(_QWORD *)this + 64);
  }
  else
  {
    if (!*((_QWORD *)this + 2))
    {
      v4 = 0;
      memset(v3, 0, sizeof(v3));
      kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)v3);
    }
    v1 = *(uint64_t (**)(void))(*(_QWORD *)this + 56);
  }
  return v1();
}

void sub_187F1F01C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1F028()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::set_target_size(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  FILE *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v2 = this;
  if (*(_BYTE *)(this + 12))
  {
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Attempting to set the target size of a JP2 box which has already been assigned a rubber length.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  if (*(_BYTE *)(this + 73))
  {
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Attempting to set the target size of a JP2 box whose content length is already known, or is to be written at the end.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  if ((*(_QWORD *)(this + 56) & 0x8000000000000000) == 0)
  {
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Attempting to set the target size of a JP2 box which is currently inside a rewrite section.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  if (!*(_DWORD *)(this + 8))
    jp2_output_box::set_target_size();
  if (*(_QWORD *)(this + 16) || *(_QWORD *)(this + 24))
  {
    *(_QWORD *)(this + 48) = a2;
    if (*(_QWORD *)(this + 40) > a2)
    {
      v11 = 0;
      v9 = 0u;
      v10 = 0u;
      kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Attempting to set the target size of a JP2 box to which a larger number of bytes has already been written.");
      kdu_error::~kdu_error((kdu_error *)&v9);
    }
    *(_BYTE *)(this + 73) = 1;
    this = jp2_output_box::write_header((jp2_output_box *)this);
    if (*(_QWORD *)(v2 + 64))
    {
      v3 = *(_QWORD *)(v2 + 24);
      if (v3)
      {
        *(_BYTE *)(v2 + 72) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3) ^ 1;
      }
      else
      {
        v4 = *(_QWORD *)(v2 + 16);
        v5 = *(FILE **)(v4 + 8);
        if (v5)
        {
          v6 = fwrite(*(const void **)(v2 + 64), 1uLL, *(_QWORD *)(v2 + 40), v5);
          v7 = *(_QWORD *)(v2 + 40);
          *(_BYTE *)(v2 + 72) = v6 != v7;
        }
        else
        {
          v8 = *(_QWORD *)(v4 + 16);
          if (!v8)
            jp2_output_box::set_target_size();
          *(_BYTE *)(v2 + 72) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8) ^ 1;
          v7 = *(_QWORD *)(v2 + 40);
        }
        *(_QWORD *)(*(_QWORD *)(v2 + 16) + 24) += v7;
      }
      this = *(_QWORD *)(v2 + 64);
      if (this)
        this = MEMORY[0x18D761C18](this, 0x1000C8077774924);
      *(_DWORD *)(v2 + 32) = 0;
      *(_QWORD *)(v2 + 64) = 0;
    }
  }
  return this;
}

void sub_187F1F258(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1F264()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::write_header_last(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v1 = this;
  if (!*(_DWORD *)(this + 8))
  {
    v7 = 0;
    v5 = 0u;
    v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  if (!*(_BYTE *)(this + 73) && !*(_BYTE *)(this + 74))
  {
    v2 = *(_QWORD *)(this + 16);
    if (v2)
    {
      if (*(_QWORD *)(v2 + 8)
        || (v3 = *(_QWORD *)(v2 + 16)) != 0
        && (v4 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 24))(v3, 0),
            (*(void (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v1 + 16) + 16) + 32))(*(_QWORD *)(*(_QWORD *)(v1 + 16) + 16)),
            (v4 & 1) != 0))
      {
        *(_BYTE *)(v1 + 74) = 1;
        this = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v1 + 48))(v1, 0x7FFFFFFFFFFFFFFFLL);
        if (!*(_BYTE *)(v1 + 73))
          jp2_output_box::write_header_last();
        return this;
      }
    }
    else if (!*(_QWORD *)(this + 24))
    {
      return this;
    }
    v7 = 0;
    v5 = 0u;
    v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  return this;
}

void sub_187F1F3CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1F3D8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL jp2_output_box::close(jp2_output_box *this)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  FILE *v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  FILE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _OWORD v19[2];
  uint64_t v20;

  if (!*((_DWORD *)this + 2))
    return 1;
  (*(void (**)(jp2_output_box *))(*(_QWORD *)this + 32))(this);
  v2 = *((_QWORD *)this + 6);
  if (v2 < 0 || *((_BYTE *)this + 74))
  {
    *((_QWORD *)this + 6) = *((_QWORD *)this + 5);
  }
  else if (v2 != *((_QWORD *)this + 5))
  {
    v20 = 0;
    memset(v19, 0, sizeof(v19));
    kdu_error::kdu_error((kdu_error *)v19, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v19[0] + 16))(v19, "Attempting to close an output JP2 box whose length was defined ahead of time, having written less bytes than indicated by that length value.");
    kdu_error::~kdu_error((kdu_error *)v19);
  }
  if (*((_QWORD *)this + 2) || *((_QWORD *)this + 3))
  {
    if (*((_BYTE *)this + 73))
    {
      if (*((_QWORD *)this + 8))
        jp2_output_box::close();
    }
    else
    {
      *((_BYTE *)this + 73) = 1;
      jp2_output_box::write_header(this);
      if (*((_QWORD *)this + 8))
      {
        v4 = *((_QWORD *)this + 3);
        if (v4)
        {
          *((_BYTE *)this + 72) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4) ^ 1;
        }
        else
        {
          v6 = *((_QWORD *)this + 2);
          v7 = *(FILE **)(v6 + 8);
          if (v7)
          {
            v8 = fwrite(*((const void **)this + 8), 1uLL, *((_QWORD *)this + 5), v7);
            v9 = *((_QWORD *)this + 5);
            *((_BYTE *)this + 72) = v8 != v9;
          }
          else
          {
            v10 = *(_QWORD *)(v6 + 16);
            if (!v10)
              jp2_output_box::close();
            *((_BYTE *)this + 72) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10) ^ 1;
            v9 = *((_QWORD *)this + 5);
          }
          *(_QWORD *)(*((_QWORD *)this + 2) + 24) += v9;
        }
        v11 = *((_QWORD *)this + 8);
        if (v11)
          MEMORY[0x18D761C18](v11, 0x1000C8077774924);
        *((_DWORD *)this + 8) = 0;
        *((_QWORD *)this + 8) = 0;
      }
    }
  }
  else
  {
    v5 = *((_QWORD *)this + 8);
    if (v5)
      MEMORY[0x18D761C18](v5, 0x1000C8077774924);
    *((_DWORD *)this + 8) = 0;
    *((_QWORD *)this + 8) = 0;
    *(_WORD *)((char *)this + 73) = 0;
  }
  if (*((_BYTE *)this + 74))
  {
    v12 = (_QWORD *)*((_QWORD *)this + 2);
    if (v12)
    {
      v13 = (FILE *)v12[1];
      if (v13)
      {
        fflush(v13);
        v14 = *((_QWORD *)this + 2);
        v15 = *(_QWORD *)(v14 + 24);
        v16 = v15 - *((_QWORD *)this + 6) - 16;
        *(_QWORD *)(v14 + 24) = v16;
        fseek(*(FILE **)(v14 + 8), v16, 0);
        jp2_output_box::write_header(this);
        fseek(*(FILE **)(*((_QWORD *)this + 2) + 8), v15, 0);
LABEL_34:
        *(_QWORD *)(*((_QWORD *)this + 2) + 24) = v15;
        goto LABEL_35;
      }
      v17 = v12[2];
      if (v17)
      {
        v15 = v12[3];
        v12[3] = v15 - (*((_QWORD *)this + 6) + 16);
        if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17) & 1) == 0)
          jp2_output_box::close();
        jp2_output_box::write_header(this);
        (*(void (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 2) + 16) + 32))(*(_QWORD *)(*((_QWORD *)this + 2) + 16));
        goto LABEL_34;
      }
    }
    jp2_output_box::close();
  }
LABEL_35:
  *((_DWORD *)this + 2) = 0;
  if (*((_BYTE *)this + 12))
  {
    v18 = *((_QWORD *)this + 2);
    if (v18)
      *(_BYTE *)(v18 + 32) = 1;
  }
  return *((_BYTE *)this + 72) == 0;
}

void sub_187F1F690(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1F69C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::start_rewrite(jp2_output_box *this, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  FILE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!*((_DWORD *)this + 2))
    return 0;
  result = 0;
  if ((a2 & 0x8000000000000000) == 0 && (*((_QWORD *)this + 7) & 0x8000000000000000) != 0)
  {
    v5 = *((_QWORD *)this + 5);
    if (v5 < a2)
      return 0;
    *((_QWORD *)this + 7) = v5;
    *((_QWORD *)this + 5) = v5 - a2;
    if (*((_BYTE *)this + 73))
    {
      v6 = *((_QWORD *)this + 2);
      if (v6)
      {
        v7 = *(FILE **)(v6 + 8);
        if (v7)
        {
          if (a2)
          {
            fflush(v7);
            v8 = *((_QWORD *)this + 2);
            v9 = *(_QWORD *)(v8 + 24) - a2;
            *(_QWORD *)(v8 + 24) = v9;
            fseek(*(FILE **)(v8 + 8), v9, 0);
          }
          return 1;
        }
        v11 = *(_QWORD *)(v6 + 16);
        if (v11 && (*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 24))(v11, a2))
        {
          *(_QWORD *)(*((_QWORD *)this + 2) + 24) -= a2;
          return 1;
        }
      }
      else
      {
        v10 = *((_QWORD *)this + 3);
        if (v10 && ((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 24))(v10, a2) & 1) != 0)
          return 1;
      }
      result = 0;
      *((_QWORD *)this + 7) = -1;
      *((_QWORD *)this + 5) += a2;
      return result;
    }
    return 1;
  }
  return result;
}

BOOL jp2_output_box::end_rewrite(jp2_output_box *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  FILE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v1 = *((_QWORD *)this + 7);
  if ((v1 & 0x8000000000000000) == 0)
  {
    v3 = *((_QWORD *)this + 5);
    v4 = v1 - v3;
    if (v1 - v3 < 0)
      jp2_output_box::end_rewrite();
    *((_QWORD *)this + 5) = v1;
    *((_QWORD *)this + 7) = -1;
    if (*((_BYTE *)this + 73))
    {
      v5 = *((_QWORD *)this + 2);
      if (v5)
      {
        v6 = *(FILE **)(v5 + 8);
        if (v6)
        {
          if (v1 != v3)
          {
            fflush(v6);
            v7 = *((_QWORD *)this + 2);
            v8 = *(_QWORD *)(v7 + 24) + v4;
            *(_QWORD *)(v7 + 24) = v8;
            fseek(*(FILE **)(v7 + 8), v8, 0);
          }
        }
        else
        {
          v10 = *(_QWORD *)(v5 + 16);
          if (!v10 || !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10))
            jp2_output_box::end_rewrite();
          *(_QWORD *)(*((_QWORD *)this + 2) + 24) += v4;
        }
      }
      else
      {
        v9 = *((_QWORD *)this + 3);
        if (!v9)
          jp2_output_box::end_rewrite();
        if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 32))(v9) & 1) == 0)
          jp2_output_box::end_rewrite();
      }
    }
  }
  return v1 >= 0;
}

BOOL jp2_output_box::write(jp2_output_box *this, const unsigned __int8 *__ptr, size_t __nitems)
{
  int v5;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  FILE *v23;
  uint64_t v25;
  _OWORD v26[2];
  uint64_t v27;

  if (!*((_DWORD *)this + 2) || *((_BYTE *)this + 72))
    return 0;
  v5 = __nitems;
  v7 = *((_QWORD *)this + 7);
  v8 = __nitems;
  if ((v7 & 0x8000000000000000) == 0)
  {
    v9 = *((_QWORD *)this + 5);
    v10 = v9 + (int)__nitems;
    v11 = v7 - v9;
    if (v10 > v7)
      v8 = v11;
    else
      v8 = __nitems;
  }
  if ((int)v8 <= 0)
    return (_DWORD)v8 == v5;
  v12 = *((_QWORD *)this + 6);
  v13 = *((_QWORD *)this + 5) + v8;
  *((_QWORD *)this + 5) = v13;
  if ((v12 & 0x8000000000000000) == 0 && v13 > v12)
  {
    v27 = 0;
    memset(v26, 0, sizeof(v26));
    kdu_error::kdu_error((kdu_error *)v26, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v26);
  }
  if (!*((_BYTE *)this + 73))
  {
    v17 = *((_QWORD *)this + 5);
    v18 = *((int *)this + 8);
    if (v17 <= v18)
    {
      v20 = (char *)*((_QWORD *)this + 8);
    }
    else
    {
      if ((*((_QWORD *)this + 7) & 0x8000000000000000) == 0)
        jp2_output_box::write();
      *((_DWORD *)this + 8) = v17 + v18 + 1024;
      v19 = (char *)operator new[]();
      v20 = v19;
      v21 = *((_QWORD *)this + 8);
      if (v21)
      {
        memcpy(v19, *((const void **)this + 8), *((_QWORD *)this + 5) - v8);
        MEMORY[0x18D761C18](v21, 0x1000C8077774924);
      }
      *((_QWORD *)this + 8) = v20;
      v17 = *((_QWORD *)this + 5);
    }
    memcpy(&v20[(int)v17 - (int)v8], __ptr, v8);
    return (_DWORD)v8 == v5;
  }
  v14 = *((_QWORD *)this + 3);
  if (v14)
  {
    v15 = (*(uint64_t (**)(uint64_t, const unsigned __int8 *, size_t))(*(_QWORD *)v14 + 40))(v14, __ptr, v8);
    v16 = v15 ^ 1;
    *((_BYTE *)this + 72) = v15 ^ 1;
  }
  else
  {
    v22 = *((_QWORD *)this + 2);
    v23 = *(FILE **)(v22 + 8);
    if (v23)
    {
      v16 = fwrite(__ptr, 1uLL, v8, v23) != v8;
    }
    else
    {
      v25 = *(_QWORD *)(v22 + 16);
      if (!v25)
        jp2_output_box::write();
      v16 = (*(uint64_t (**)(uint64_t, const unsigned __int8 *, size_t))(*(_QWORD *)v25 + 40))(v25, __ptr, v8) ^ 1;
    }
    *((_BYTE *)this + 72) = v16;
    *(_QWORD *)(*((_QWORD *)this + 2) + 24) += v8;
  }
  if ((_DWORD)v8 != v5)
    return 0;
  return v16 == 0;
}

void sub_187F1FAB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1FABC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void j2_dimensions::copy(j2_dimensions *this, j2_dimensions *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  j2_dimensions *v7;

  v7 = this;
  jp2_dimensions::init((uint64_t *)&v7, *(_QWORD *)a2, *((_DWORD *)a2 + 5), *((_BYTE *)a2 + 24), *((_DWORD *)a2 + 2));
  *((_BYTE *)this + 25) = *((_BYTE *)a2 + 25);
  *((_DWORD *)this + 3) = *((_DWORD *)a2 + 3);
  *((_BYTE *)this + 16) = *((_BYTE *)a2 + 16);
  if (*((int *)a2 + 5) >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)a2 + 4);
    v6 = *((_QWORD *)this + 4);
    do
    {
      *(_DWORD *)(v6 + 4 * v4) = *(_DWORD *)(v5 + 4 * v4);
      ++v4;
    }
    while (v4 < *((int *)a2 + 5));
  }
}

void jp2_dimensions::init(uint64_t *a1, uint64_t a2, int a3, unsigned __int8 a4, int a5)
{
  uint64_t v6;
  size_t v7;
  void *v8;
  _OWORD v9[2];
  uint64_t v10;

  if (!*a1)
    jp2_dimensions::init();
  if (*(_DWORD *)(*a1 + 20))
  {
    v10 = 0;
    memset(v9, 0, sizeof(v9));
    kdu_error::kdu_error((kdu_error *)v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v9[0] + 16))(v9, "JP2 dimensions may be initialized only once!");
    kdu_error::~kdu_error((kdu_error *)v9);
  }
  if (a3 <= 0)
    jp2_dimensions::init();
  *(_QWORD *)*a1 = a2;
  v6 = *a1;
  *(_DWORD *)(v6 + 20) = a3;
  *(_WORD *)(v6 + 24) = a4;
  *(_DWORD *)(v6 + 8) = a5;
  *(_DWORD *)(v6 + 12) = 2;
  *(_BYTE *)(v6 + 16) = 1;
  v7 = 4 * a3;
  v8 = (void *)operator new[]();
  *(_QWORD *)(*a1 + 32) = v8;
  bzero(v8, v7);
}

void sub_187F1FC48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1FC54()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_dimensions::init(j2_dimensions *this, jp2_input_box *a2)
{
  int v4;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64x2_t v10;
  unsigned int v11;
  int64x2_t v12;
  unsigned int *v13;
  int64x2_t v14;
  int32x2_t v15;
  __int16 v16;
  __int16 v17;
  unsigned __int16 v18;
  unsigned int v19[2];
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  if (*((_DWORD *)this + 5))
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  if (*((_DWORD *)a2 + 12) != 1768449138)
    j2_dimensions::init();
  *(_QWORD *)v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  if (!jp2_input_box::read(a2, &v19[1])
    || !jp2_input_box::read(a2, v19)
    || !jp2_input_box::read(a2, &v18)
    || (*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v17 + 1, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v17, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v16 + 1, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v16, 1) != 1)
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v20 + 16))(&v20, "Malformed image header box (ihdr) found in JP2-family data source.  Not all fields were present.");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  if (((*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2) & 1) == 0)
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v20 + 16))(&v20, "Malformed image header box (ihdr) found in JP2-family data source.  The box appears to be too long.");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  v4 = v18;
  if ((v18 - 1) >> 14
    || v17 > 9u
    || HIBYTE(v16) > 1u
    || v16 > 1u
    || HIBYTE(v17) != 255 && (HIBYTE(v17) & 0x7Eu) >= 0x26)
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v20 + 16))(&v20, "Malformed image header box (ihdr) found in JP2-family data source.  The box contains fields which do not conform to their legal range.");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  v5 = v19[0];
  if ((v19[1] & 0x80000000) != 0 || (v19[0] & 0x80000000) != 0)
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v20 + 16))(&v20, "Sorry: Cannot process JP2-family data sources whose image header box contains height or width values larger than 2^{31}-1.");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  *(_DWORD *)this = v19[1];
  *((_DWORD *)this + 1) = v5;
  *((_DWORD *)this + 5) = v4;
  *((_BYTE *)this + 24) = HIBYTE(v16) != 0;
  *((_BYTE *)this + 25) = (_BYTE)v16 != 0;
  *((_DWORD *)this + 2) = v17;
  result = operator new[]();
  *((_QWORD *)this + 4) = result;
  v7 = *((unsigned int *)this + 5);
  if ((int)v7 >= 1)
  {
    v8 = ~HIBYTE(v17) | 0xFFFFFF80;
    if (v17 >= 0)
      v8 = HIBYTE(v17) + 1;
    v9 = (v7 + 1) & 0x1FFFFFFFELL;
    v10 = (uint64x2_t)vdupq_n_s64(v7 - 1);
    if (HIBYTE(v17) == 255)
      v11 = 0;
    else
      v11 = v8;
    v12 = (int64x2_t)xmmword_18820C490;
    v13 = (unsigned int *)(result + 4);
    v14 = vdupq_n_s64(2uLL);
    do
    {
      v15 = vmovn_s64((int64x2_t)vcgeq_u64(v10, (uint64x2_t)v12));
      if ((v15.i8[0] & 1) != 0)
        *(v13 - 1) = v11;
      if ((v15.i8[4] & 1) != 0)
        *v13 = v11;
      v12 = vaddq_s64(v12, v14);
      v13 += 2;
      v9 -= 2;
    }
    while (v9);
  }
  *((_DWORD *)this + 3) = 2;
  *((_BYTE *)this + 16) = 1;
  return result;
}

void sub_187F1FFE4(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F1FFF0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t j2_dimensions::process_bpcc_box(j2_dimensions *this, jp2_input_box *a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  int v7;
  uint64_t result;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  unsigned __int8 v12;

  v12 = 0;
  if (*((int *)this + 5) >= 1)
  {
    v4 = 0;
    while ((*(unsigned int (**)(jp2_input_box *, unsigned __int8 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v12, 1) == 1)
    {
      v5 = v12 & 0x7F;
      if (v5 >= 0x26)
      {
        v11 = 0;
        v9 = 0u;
        v10 = 0u;
        kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Malformed bits per component (bpcc) box found in JP2-family data source.  The box contains an illegal bit-depth specifier.  Bit depths may not exceed 38 bits per sample.");
        goto LABEL_7;
      }
      v6 = ~v5;
      if ((v12 & 0x80u) == 0)
        v7 = v12 + 1;
      else
        v7 = v6;
      *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v4++) = v7;
      if (v4 >= *((int *)this + 5))
        goto LABEL_12;
    }
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Malformed bits per component (bpcc) box found in JP2-family data source.  The box contains insufficient bit-depth specifiers.");
LABEL_7:
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
LABEL_12:
  result = (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
  if ((result & 1) == 0)
  {
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Malformed bits per component (bpcc) box found in JP2-family data source.  The box appears to be too long.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  return result;
}

void sub_187F201B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F201BC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_dimensions::finalize(uint64_t this)
{
  int v1;
  int *v2;
  uint64_t v3;
  int v4;
  int v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v1 = *(_DWORD *)(this + 20);
  if (v1 < 1)
    goto LABEL_7;
  v2 = *(int **)(this + 32);
  v3 = *(unsigned int *)(this + 20);
  do
  {
    v5 = *v2++;
    v4 = v5;
    if (!v5 || (v4 - 39) < 0xFFFFFFB3)
      goto LABEL_7;
    --v3;
  }
  while (v3);
  if ((v1 - 16385) <= 0xFFFFBFFF)
  {
LABEL_7:
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (*(_DWORD *)(this + 8) >= 0xAu)
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  return this;
}

void sub_187F202D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F202DC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_dimensions::save_boxes(j2_dimensions *this, jp2_output_box *a2)
{
  uint64_t v4;
  unsigned __int8 v5;
  int *v6;
  int *v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned __int8 v15;
  uint64_t result;
  unsigned __int8 __ptr[8];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  void (**v23)(jp2_output_box *__hidden);
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  unsigned __int8 v29;

  j2_dimensions::finalize((uint64_t)this);
  v4 = *((unsigned int *)this + 5);
  if ((int)v4 < 2)
    goto LABEL_7;
  v5 = 0;
  v6 = (int *)*((_QWORD *)this + 4);
  v9 = *v6;
  v7 = v6 + 1;
  v8 = v9;
  v10 = v4 - 1;
  do
  {
    v11 = *v7++;
    if (v11 != v8)
      v5 = -1;
    --v10;
  }
  while (v10);
  if (!v5)
  {
LABEL_7:
    v12 = **((_DWORD **)this + 4);
    if (v12 <= 0)
      v5 = ~(_BYTE)v12 | 0x80;
    else
      v5 = v12 - 1;
  }
  v24 = 0u;
  v23 = &off_1E1BB0038;
  v28 = 0;
  v25 = 0uLL;
  v26 = 0uLL;
  v27 = 0xFFFFFFFFFFFFFFFFLL;
  jp2_output_box::open((uint64_t)&v23, a2, 1768449138, 0);
  *(_DWORD *)__ptr = bswap32(*(_DWORD *)this);
  ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v23[5])((jp2_output_box *)&v23, __ptr, 4uLL);
  *(_DWORD *)__ptr = bswap32(*((_DWORD *)this + 1));
  ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v23[5])((jp2_output_box *)&v23, __ptr, 4uLL);
  *(_WORD *)__ptr = bswap32(*((unsigned __int16 *)this + 10)) >> 16;
  ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v23[5])((jp2_output_box *)&v23, __ptr, 2uLL);
  __ptr[0] = v5;
  ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v23[5])((jp2_output_box *)&v23, __ptr, 1uLL);
  __ptr[0] = *((_DWORD *)this + 2);
  ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v23[5])((jp2_output_box *)&v23, __ptr, 1uLL);
  __ptr[0] = *((_BYTE *)this + 24);
  ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v23[5])((jp2_output_box *)&v23, __ptr, 1uLL);
  __ptr[0] = *((_BYTE *)this + 25);
  ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v23[5])((jp2_output_box *)&v23, __ptr, 1uLL);
  jp2_output_box::close((jp2_output_box *)&v23);
  if (v5 == 0xFF)
  {
    v18 = 0u;
    *(_QWORD *)__ptr = &off_1E1BB0038;
    v22 = 0;
    v19 = 0uLL;
    v20 = 0uLL;
    v21 = 0xFFFFFFFFFFFFFFFFLL;
    jp2_output_box::open((uint64_t)__ptr, a2, 1651532643, 0);
    if (*((int *)this + 5) >= 1)
    {
      v13 = 0;
      do
      {
        v14 = *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v13);
        if (v14 <= 0)
          v15 = ~(_BYTE)v14 | 0x80;
        else
          v15 = v14 - 1;
        v29 = v15;
        (*(void (**)(jp2_output_box *, const unsigned __int8 *, size_t))(*(_QWORD *)__ptr + 40))((jp2_output_box *)__ptr, &v29, 1uLL);
        ++v13;
      }
      while (v13 < *((int *)this + 5));
    }
    jp2_output_box::close((jp2_output_box *)__ptr);
    *(_QWORD *)__ptr = &off_1E1BB0038;
    if (*((_QWORD *)&v21 + 1))
      MEMORY[0x18D761C18](*((_QWORD *)&v21 + 1), 0x1000C8077774924);
  }
  v23 = &off_1E1BB0038;
  result = *((_QWORD *)&v27 + 1);
  if (*((_QWORD *)&v27 + 1))
    return MEMORY[0x18D761C18](*((_QWORD *)&v27 + 1), 0x1000C8077774924);
  return result;
}

void sub_187F205A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  if (a18)
    MEMORY[0x18D761C18](a18, 0x1000C8077774924);
  if (a28)
    MEMORY[0x18D761C18](a28, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t jp2_dimensions::init(jp2_dimensions *this, siz_params *a2, unsigned __int8 a3)
{
  int i;
  uint64_t v7;
  int v9;
  BOOL v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  int v14;
  int v15[2];
  int v16[2];

  *(_QWORD *)v15 = 0;
  *(_QWORD *)v16 = 0;
  v14 = 0;
  if (!kdu_params::get(a2, "Ssize", 0, 0, v16, 1, 1, 1)
    || !kdu_params::get(a2, "Ssize", 0, 1, &v16[1], 1, 1, 1)
    || !kdu_params::get(a2, "Sorigin", 0, 0, v15, 1, 1, 1)
    || !kdu_params::get(a2, "Sorigin", 0, 1, &v15[1], 1, 1, 1)
    || (kdu_params::get(a2, "Scomponents", 0, 0, &v14, 1, 1, 1) & 1) == 0)
  {
    v13 = 0;
    v11 = 0u;
    v12 = 0u;
    kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v11);
  }
  *(int32x2_t *)v16 = vsub_s32(*(int32x2_t *)v16, *(int32x2_t *)v15);
  jp2_dimensions::init((uint64_t *)this, *(uint64_t *)v16, v14, a3, 7);
  if (v14 >= 1)
  {
    for (i = 0; i < v14; ++i)
    {
      v10 = 0;
      v9 = 0;
      if (!kdu_params::get(a2, "Ssigned", i, 0, &v10, 1, 1, 1)
        || (kdu_params::get(a2, "Sprecision", i, 0, &v9, 1, 1, 1) & 1) == 0)
      {
        v13 = 0;
        v11 = 0u;
        v12 = 0u;
        kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v11);
      }
      jp2_dimensions::set_precision((uint64_t *)this, i, v9, v10);
    }
  }
  v7 = *(_QWORD *)this;
  *(_DWORD *)(v7 + 12) = 2;
  *(_BYTE *)(v7 + 16) = 1;
  return jp2_dimensions::finalize_compatibility((uint64_t)this, a2);
}

void sub_187F20890(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2089C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t *jp2_dimensions::set_precision(uint64_t *this, unsigned int a2, int a3, int a4)
{
  uint64_t v4;
  int v5;

  if ((a2 & 0x80000000) != 0 || (v4 = *this) == 0 || *(_DWORD *)(v4 + 20) <= (signed int)a2)
    jp2_dimensions::set_precision();
  if (a4)
    v5 = -a3;
  else
    v5 = a3;
  *(_DWORD *)(*(_QWORD *)(v4 + 32) + 4 * a2) = v5;
  return this;
}

uint64_t jp2_dimensions::finalize_compatibility(uint64_t this, kdu_params *a2)
{
  uint64_t v2;
  kdu_params *v4;
  __int16 v5;
  int v6;
  kdu_params *v7;
  kdu_params *v8;
  int v9;
  kdu_params *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;

  if (a2)
  {
    v2 = this;
    if (*(_DWORD *)(*(_QWORD *)this + 8) == 7)
    {
      this = kdu_params::access_cluster(a2, "SIZ");
      if (this)
      {
        v4 = (kdu_params *)this;
        this = kdu_params::get((kdu_params *)this, "Sprofile", 0, 0, (int *)(*(_QWORD *)v2 + 12), 1, 1, 1);
        if (*(_DWORD *)(*(_QWORD *)v2 + 12) == 3)
        {
          v16 = 0;
          this = kdu_params::get(v4, "Sextensions", 0, 0, &v16, 1, 1, 1);
          v5 = v16;
          if ((v16 & 0xFFFFFCFF) != 0)
            *(_BYTE *)(*(_QWORD *)v2 + 16) = 0;
          if ((v5 & 0x100) != 0)
          {
            if (*(_BYTE *)(*(_QWORD *)v2 + 16))
            {
              v14 = 1;
              v15 = 1;
              kdu_params::get(v4, "Stiles", 0, 0, &v14, 1, 1, 1);
              kdu_params::get(v4, "Stiles", 0, 1, &v15, 1, 1, 1);
              v6 = v15 * v14;
              v7 = (kdu_params *)kdu_params::access_cluster(a2, "MCO");
              this = kdu_params::access_cluster(a2, "MCC");
              if ((v6 & 0x80000000) == 0)
              {
                v8 = (kdu_params *)this;
                v9 = -1;
                while (1)
                {
                  v13 = 0;
                  if (v7)
                  {
                    this = kdu_params::access_relation(v7, v9, -1, 0, 0);
                    if (this)
                    {
                      this = kdu_params::get((kdu_params *)this, "Mnum_stages", 0, 0, &v13, 1, 1, 1);
                      if ((_DWORD)this)
                      {
                        if (v13 != 1)
                          break;
                      }
                    }
                  }
                  if (v8)
                  {
                    this = kdu_params::access_relation(v8, v9, -1, 0, 0);
                    if (this)
                    {
                      v10 = (kdu_params *)this;
                      do
                      {
                        v12 = 0;
                        this = kdu_params::get(v10, "Mstage_xforms", 0, 0, &v12, 1, 1, 1);
                        if ((this & 1) != 0)
                        {
                          if (v12 != 1)
                            goto LABEL_25;
                          this = kdu_params::get(v10, "Mstage_xforms", 1, 0, &v12, 1, 1, 1);
                          if ((_DWORD)this)
                            goto LABEL_25;
                          v11 = 1;
                          this = kdu_params::get(v10, "Mstage_xforms", 0, 3, &v11, 1, 1, 1);
                          if (v11)
                            goto LABEL_25;
                        }
                        v10 = (kdu_params *)*((_QWORD *)v10 + 11);
                      }
                      while (v10);
                    }
                  }
                  if (++v9 == v6)
                    return this;
                }
LABEL_25:
                *(_BYTE *)(*(_QWORD *)v2 + 16) = 0;
              }
            }
          }
        }
      }
    }
  }
  return this;
}

uint64_t jp2_dimensions::get_size(jp2_dimensions *this)
{
  if (!*(_QWORD *)this)
    jp2_dimensions::get_size();
  return **(_QWORD **)this;
}

uint64_t jp2_dimensions::get_bit_depth(jp2_dimensions *this, unsigned int a2)
{
  uint64_t v2;
  int v3;

  if ((a2 & 0x80000000) != 0 || (v2 = *(_QWORD *)this) == 0 || *(_DWORD *)(v2 + 20) <= (signed int)a2)
    jp2_dimensions::get_bit_depth();
  v3 = *(_DWORD *)(*(_QWORD *)(v2 + 32) + 4 * a2);
  if (v3 >= 0)
    return v3;
  else
    return -v3;
}

uint64_t jp2_dimensions::get_signed(jp2_dimensions *this, unsigned int a2)
{
  uint64_t v2;

  if ((a2 & 0x80000000) != 0 || (v2 = *(_QWORD *)this) == 0 || *(_DWORD *)(v2 + 20) <= (signed int)a2)
    jp2_dimensions::get_signed();
  return *(_DWORD *)(*(_QWORD *)(v2 + 32) + 4 * a2) >> 31;
}

uint64_t j2_palette::copy(j2_palette *this, j2_palette *a2)
{
  uint64_t result;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  if (*((_OWORD *)this + 1) != 0)
  {
    v7 = 0;
    memset(v6, 0, sizeof(v6));
    kdu_error::kdu_error((kdu_error *)v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v6);
  }
  *(_BYTE *)this = *(_BYTE *)a2;
  *(_QWORD *)((char *)this + 4) = *(_QWORD *)((char *)a2 + 4);
  *((_QWORD *)this + 2) = operator new[]();
  result = operator new[]();
  *((_QWORD *)this + 3) = result;
  if (*((int *)this + 1) >= 1)
  {
    v5 = 0;
    do
    {
      *(_DWORD *)(*((_QWORD *)this + 2) + 4 * v5) = *(_DWORD *)(*((_QWORD *)a2 + 2) + 4 * v5);
      *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v5) = operator new[]();
      result = (uint64_t)memcpy(*(void **)(*((_QWORD *)this + 3) + 8 * v5), *(const void **)(*((_QWORD *)a2 + 3) + 8 * v5), 4 * *((int *)this + 2));
      ++v5;
    }
    while (v5 < *((int *)this + 1));
  }
  return result;
}

void sub_187F20DA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F20DAC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_palette::init(j2_palette *this, jp2_input_box *a2)
{
  int v4;
  int v5;
  BOOL v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t i;
  uint64_t v15;
  int v16;
  unsigned int v17;
  char v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t result;
  int v27;
  unsigned __int8 v28;
  unsigned __int8 v29;
  unsigned __int16 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  if (*((_DWORD *)this + 1))
  {
    v33 = 0;
    v31 = 0u;
    v32 = 0u;
    kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v31);
  }
  *(_BYTE *)this = 1;
  if (*((_DWORD *)a2 + 12) != 1885564018)
    j2_palette::init();
  v30 = 0;
  v29 = 0;
  if (!jp2_input_box::read(a2, &v30)
    || ((v4 = (*(uint64_t (**)(jp2_input_box *, unsigned __int8 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v29, 1), v5 = v30, v4 == 1)? (v6 = v30 == 0): (v6 = 1), v6 || v30 > 0x400u || !v29))
  {
    v33 = 0;
    v31 = 0u;
    v32 = 0u;
    kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed palette (pclr) box found in JP2-family data source.  Insufficient or illegal fields encountered.");
    kdu_error::~kdu_error((kdu_error *)&v31);
  }
  *((_DWORD *)this + 1) = v29;
  *((_DWORD *)this + 2) = v5;
  *((_QWORD *)this + 2) = operator new[]();
  if (*((int *)this + 1) >= 1)
  {
    v7 = 0;
    while (1)
    {
      LOBYTE(v27) = 0;
      if ((*(unsigned int (**)(jp2_input_box *, int *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v27, 1) != 1)
        break;
      v8 = v27 & 0x7F;
      if (v8 >= 0x26)
      {
        v33 = 0;
        v31 = 0u;
        v32 = 0u;
        kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed palette (pclr) box found in JP2-family data. source.  The box contains an illegal bit-depth specifier.  Bit depths may not exceed 38 bits per sample.");
        goto LABEL_18;
      }
      v9 = ~v8;
      if ((v27 & 0x80u) == 0)
        v10 = v27 + 1;
      else
        v10 = v9;
      *(_DWORD *)(*((_QWORD *)this + 2) + 4 * v7++) = v10;
      if (v7 >= *((int *)this + 1))
        goto LABEL_23;
    }
    v33 = 0;
    v31 = 0u;
    v32 = 0u;
    kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed palette (pclr) box found in JP2-family data source.  The box contains insufficient bit-depth specifiers.");
LABEL_18:
    kdu_error::~kdu_error((kdu_error *)&v31);
  }
LABEL_23:
  *((_QWORD *)this + 3) = operator new[]();
  LODWORD(v11) = *((_DWORD *)this + 1);
  if ((int)v11 >= 1)
  {
    v12 = 0;
    do
    {
      *(_QWORD *)(*((_QWORD *)this + 3) + 8 * v12++) = operator new[]();
      v11 = *((int *)this + 1);
    }
    while (v12 < v11);
  }
  v13 = *((_DWORD *)this + 2);
  if (v13 >= 1)
  {
    for (i = 0; i < v13; ++i)
    {
      v28 = 0;
      v27 = 0;
      if ((int)v11 >= 1)
      {
        v15 = 0;
        do
        {
          v16 = *(_DWORD *)(*((_QWORD *)this + 2) + 4 * v15);
          if (v16 >= 0)
            v17 = *(_DWORD *)(*((_QWORD *)this + 2) + 4 * v15);
          else
            v17 = -v16;
          if (v17 - 41 <= 0xFFFFFFD7)
            j2_palette::init();
          if ((int)v17 <= 32)
            v18 = 32;
          else
            v18 = v17;
          if ((*(unsigned int (**)(jp2_input_box *, int *, _QWORD))(*(_QWORD *)a2 + 32))(a2, &v27, (v17 + 7) >> 3) != (v17 + 7) >> 3)
          {
            v33 = 0;
            v31 = 0u;
            v32 = 0u;
            kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
            (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed palette (pclr) box found in JP2-family data source.  The box contains insufficient palette entries.");
            kdu_error::~kdu_error((kdu_error *)&v31);
          }
          v19 = v27;
          if (v17 >= 9)
          {
            v19 = BYTE1(v27) | (v27 << 8);
            if (v17 >= 0x11)
            {
              v19 = BYTE2(v27) | (v19 << 8);
              if (v17 >= 0x19)
              {
                v19 = HIBYTE(v27) | (v19 << 8);
                if (v17 >= 0x21)
                  v19 = (v28 >> (v18 - 32)) + (v19 << (40 - v18));
              }
            }
          }
          v20 = ~v16 & 0x80000000;
          v21 = v19 << (v18 - v17);
          if (__OFADD__(v21, v20))
          {
            v33 = 0;
            v31 = 0u;
            v32 = 0u;
            kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
            (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed JEPG2000 - overflow.");
            kdu_error::~kdu_error((kdu_error *)&v31);
          }
          *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 3) + 8 * v15++) + 4 * i) = v21 + v20;
          v11 = *((int *)this + 1);
        }
        while (v15 < v11);
        v13 = *((_DWORD *)this + 2);
      }
    }
  }
  if ((int)v11 >= 1)
  {
    v22 = 0;
    v23 = *((_QWORD *)this + 2);
    while (1)
    {
      v24 = *(_DWORD *)(v23 + 4 * v22);
      if (v24 > 32)
        break;
      if (v24 <= -33)
      {
        v25 = -32;
        goto LABEL_56;
      }
LABEL_57:
      if (++v22 >= *((int *)this + 1))
        goto LABEL_58;
    }
    v25 = 32;
LABEL_56:
    *(_DWORD *)(v23 + 4 * v22) = v25;
    goto LABEL_57;
  }
LABEL_58:
  result = (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
  if ((result & 1) == 0)
  {
    v33 = 0;
    v31 = 0u;
    v32 = 0u;
    kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed palette (pclr) box encountered in JP2-family data source.  Box appears to be too long.");
    kdu_error::~kdu_error((kdu_error *)&v31);
  }
  return result;
}

void sub_187F2129C(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F212A8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t j2_palette::finalize(uint64_t this)
{
  int v1;
  int *v2;
  uint64_t v3;
  int v4;
  int v5;
  _OWORD v6[2];
  uint64_t v7;

  v1 = *(_DWORD *)(this + 4);
  if (v1)
  {
    if (v1 < 1)
      goto LABEL_9;
    v2 = *(int **)(this + 16);
    v3 = *(unsigned int *)(this + 4);
    do
    {
      v5 = *v2++;
      v4 = v5;
      if (!v5 || (v4 - 33) < 0xFFFFFFBF)
        goto LABEL_9;
      --v3;
    }
    while (v3);
    if ((v1 - 256) < 0xFFFFFF01 || (*(_DWORD *)(this + 8) - 1025) <= 0xFFFFFBFF)
    {
LABEL_9:
      v7 = 0;
      memset(v6, 0, sizeof(v6));
      kdu_error::kdu_error((kdu_error *)v6, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)v6);
    }
  }
  return this;
}

void sub_187F213C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F213CC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_palette::save_box(uint64_t this, jp2_output_box *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned __int8 v7;
  int v8;
  uint64_t i;
  uint64_t v10;
  int v11;
  unsigned int v12;
  size_t v13;
  unsigned int v14;
  unsigned __int8 __ptr[4];
  void (**v16)(jp2_output_box *__hidden);
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  if (*(_DWORD *)(this + 4))
  {
    v3 = this;
    j2_palette::finalize(this);
    v17 = 0u;
    v16 = &off_1E1BB0038;
    v21 = 0;
    v18 = 0uLL;
    v19 = 0uLL;
    v20 = 0xFFFFFFFFFFFFFFFFLL;
    jp2_output_box::open((uint64_t)&v16, a2, 1885564018, 0);
    *(_WORD *)__ptr = bswap32(*(unsigned __int16 *)(v3 + 8)) >> 16;
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v16[5])((jp2_output_box *)&v16, __ptr, 2uLL);
    __ptr[0] = *(_DWORD *)(v3 + 4);
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v16[5])((jp2_output_box *)&v16, __ptr, 1uLL);
    LODWORD(v4) = *(_DWORD *)(v3 + 4);
    if ((int)v4 >= 1)
    {
      v5 = 0;
      do
      {
        v6 = *(_DWORD *)(*(_QWORD *)(v3 + 16) + 4 * v5);
        if (v6 <= 0)
          v7 = ~(_BYTE)v6 | 0x80;
        else
          v7 = v6 - 1;
        __ptr[0] = v7;
        ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v16[5])((jp2_output_box *)&v16, __ptr, 1uLL);
        ++v5;
        v4 = *(int *)(v3 + 4);
      }
      while (v5 < v4);
    }
    v8 = *(_DWORD *)(v3 + 8);
    if (v8 >= 1)
    {
      for (i = 0; i < v8; ++i)
      {
        *(_DWORD *)__ptr = 0;
        if ((int)v4 >= 1)
        {
          v10 = 0;
          do
          {
            v11 = *(_DWORD *)(*(_QWORD *)(v3 + 16) + 4 * v10);
            if (v11 >= 0)
              v12 = *(_DWORD *)(*(_QWORD *)(v3 + 16) + 4 * v10);
            else
              v12 = -v11;
            if (v12 - 33 <= 0xFFFFFFDF)
              __assert_rtn("save_box", "jp2.cpp", 2587, "(entry_bytes > 0) && (entry_bytes <= 4)");
            v13 = (v12 + 7) >> 3;
            v14 = ((v11 | 0x7FFFFFFFu) + *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 24) + 8 * v10) + 4 * i) + 1) >> -(char)v12;
            __ptr[v13 - 1] = v14;
            if (v12 >= 9)
            {
              __ptr[(v13 - 2)] = BYTE1(v14);
              if (v12 >= 0x11)
              {
                __ptr[(v13 - 3)] = BYTE2(v14);
                if (v12 >= 0x19)
                  __ptr[(v13 - 4)] = HIBYTE(v14);
              }
            }
            jp2_output_box::write((jp2_output_box *)&v16, __ptr, v13);
            ++v10;
            v4 = *(int *)(v3 + 4);
          }
          while (v10 < v4);
          v8 = *(_DWORD *)(v3 + 8);
        }
      }
    }
    jp2_output_box::close((jp2_output_box *)&v16);
    v16 = &off_1E1BB0038;
    this = *((_QWORD *)&v20 + 1);
    if (*((_QWORD *)&v20 + 1))
      return MEMORY[0x18D761C18](*((_QWORD *)&v20 + 1), 0x1000C8077774924);
  }
  return this;
}

void sub_187F21630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19)
    MEMORY[0x18D761C18](a19, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t jp2_palette::get_num_entries(jp2_palette *this)
{
  if (!*(_QWORD *)this)
    jp2_palette::get_num_entries();
  return *(unsigned int *)(*(_QWORD *)this + 8);
}

uint64_t jp2_palette::get_num_luts(jp2_palette *this)
{
  if (!*(_QWORD *)this)
    jp2_palette::get_num_luts();
  return *(unsigned int *)(*(_QWORD *)this + 4);
}

uint64_t jp2_palette::get_bit_depth(jp2_palette *this, unsigned int a2)
{
  uint64_t v2;
  int v3;

  if ((a2 & 0x80000000) != 0 || (v2 = *(_QWORD *)this) == 0 || *(_DWORD *)(v2 + 4) <= (signed int)a2)
    jp2_palette::get_bit_depth();
  v3 = *(_DWORD *)(*(_QWORD *)(v2 + 16) + 4 * a2);
  if (v3 >= 0)
    return v3;
  else
    return -v3;
}

uint64_t jp2_palette::get_signed(jp2_palette *this, unsigned int a2)
{
  uint64_t v2;

  if ((a2 & 0x80000000) != 0 || (v2 = *(_QWORD *)this) == 0 || *(_DWORD *)(v2 + 4) <= (signed int)a2)
    jp2_palette::get_signed();
  return *(_DWORD *)(*(_QWORD *)(v2 + 16) + 4 * a2) >> 31;
}

uint64_t *jp2_palette::get_lut(uint64_t *result, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if ((a2 & 0x80000000) != 0 || (v3 = *result) == 0 || *(_DWORD *)(v3 + 4) <= (signed int)a2)
    jp2_palette::get_lut();
  if (*(int *)(v3 + 8) >= 1)
  {
    v4 = 0;
    v5 = *(_QWORD *)(*(_QWORD *)(v3 + 24) + 8 * a2);
    do
    {
      *(_WORD *)(a3 + 2 * v4) = (*(_DWORD *)(v5 + 4 * v4) + 0x40000) >> 19;
      ++v4;
    }
    while (v4 < *(int *)(*result + 8));
  }
  return result;
}

__n128 j2_component_map::copy(uint64_t a1, uint64_t a2)
{
  int v4;
  __n128 result;
  uint64_t v6;
  uint64_t v7;
  _OWORD v8[2];
  uint64_t v9;

  if (*(_QWORD *)(a1 + 8) || *(_QWORD *)(a1 + 16) || *(_QWORD *)(a1 + 32))
  {
    v9 = 0;
    memset(v8, 0, sizeof(v8));
    kdu_error::kdu_error((kdu_error *)v8, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v8);
  }
  *(_BYTE *)a1 = *(_BYTE *)a2;
  v4 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 24) = v4;
  *(_DWORD *)(a1 + 28) = v4;
  *(_QWORD *)(a1 + 32) = operator new[]();
  if (*(int *)(a1 + 28) >= 1)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      result = *(__n128 *)(*(_QWORD *)(a2 + 32) + v6);
      *(__n128 *)(*(_QWORD *)(a1 + 32) + v6) = result;
      ++v7;
      v6 += 16;
    }
    while (v7 < *(int *)(a1 + 28));
  }
  return result;
}

void sub_187F21870(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F2187C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_component_map::init(j2_component_map *this, jp2_input_box *a2)
{
  int v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  int v10;
  __int16 v12;
  unsigned __int16 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  if (*((_DWORD *)a2 + 12) != 1668112752)
    j2_component_map::init();
  *(_BYTE *)this = 1;
  if (*((_QWORD *)this + 4) || *((_DWORD *)this + 7))
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  if (*((_BYTE *)a2 + 125)
    || ((v4 = *((_DWORD *)a2 + 44) + *((_DWORD *)a2 + 22) - *((_DWORD *)a2 + 34)) != 0 ? (v5 = (v4 & 3) == 0) : (v5 = 0),
        !v5))
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Malformed component mapping (cmap) box encountered in JP2-family data source.  The body of any such box must contain exactly four bytes for each cmap-channel and there must be at least one cmap-channel.");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  *((_DWORD *)this + 7) = v4 >> 2;
  if (v4 <= 3)
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Malformed component mapping (cmap) box encountered in JP2-family data source.  The body of the box does not appear to contain any channel mappings.");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  *((_DWORD *)this + 6) = v4 >> 2;
  *((_QWORD *)this + 4) = operator new[]();
  if (*((int *)this + 7) >= 1)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v13 = 0;
      v12 = 0;
      if (!jp2_input_box::read(a2, &v13)
        || (*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v12 + 1, 1) != 1|| ((*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v12, 1) == 1? (v8 = HIBYTE(v12) >= 2u): (v8 = 1), v8))
      {
        v16 = 0;
        v14 = 0u;
        v15 = 0u;
        kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Malformed component mapping (cmap) box encountered in JP2-family data source.  Invalid or truncated mapping specs.");
        kdu_error::~kdu_error((kdu_error *)&v14);
      }
      v9 = *((_QWORD *)this + 4) + v6;
      if (HIBYTE(v12))
        v10 = v12;
      else
        v10 = -1;
      *(_DWORD *)v9 = v13;
      *(_DWORD *)(v9 + 4) = v10;
      *(_DWORD *)(v9 + 8) = -1;
      *(_BYTE *)(v9 + 12) = 0;
      ++v7;
      v6 += 16;
    }
    while (v7 < *((int *)this + 7));
  }
  return (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
}

void sub_187F21B24(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F21B30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t j2_component_map::init_missing_cmap(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_QWORD *)(a1 + 32) || *(_DWORD *)(a1 + 28))
    j2_component_map::init_missing_cmap();
  v3 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 24) = v3;
  *(_DWORD *)(a1 + 28) = v3;
  result = operator new[]();
  *(_QWORD *)(a1 + 32) = result;
  v5 = *(unsigned int *)(a1 + 28);
  if ((int)v5 >= 1)
  {
    v6 = 0;
    v7 = result + 8;
    do
    {
      *(_DWORD *)(v7 - 8) = 0;
      *(_DWORD *)(v7 - 4) = v6;
      *(_DWORD *)v7 = -1;
      *(_BYTE *)(v7 + 4) = 0;
      ++v6;
      v7 += 16;
    }
    while (v5 != v6);
  }
  return result;
}

_BYTE *j2_component_map::save_box(_BYTE *this, jp2_output_box *a2, int a3)
{
  BOOL v3;
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  void (**v7)(jp2_output_box *__hidden);
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  unsigned __int8 __ptr[2];

  if (*this)
    v3 = 0;
  else
    v3 = a3 == 0;
  if (!v3)
  {
    v4 = this;
    v8 = 0u;
    v7 = &off_1E1BB0038;
    v12 = 0;
    v9 = 0uLL;
    v10 = 0uLL;
    v11 = 0xFFFFFFFFFFFFFFFFLL;
    jp2_output_box::open((uint64_t)&v7, a2, 1668112752, 0);
    if (*((int *)v4 + 7) >= 1)
    {
      v5 = 0;
      v6 = 0;
      do
      {
        *(_WORD *)__ptr = bswap32(*(unsigned __int16 *)(*((_QWORD *)v4 + 4) + v5)) >> 16;
        ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v7[5])((jp2_output_box *)&v7, __ptr, 2uLL);
        if ((*(_DWORD *)(*((_QWORD *)v4 + 4) + v5 + 4) & 0x80000000) != 0)
        {
          *(_WORD *)__ptr = 0;
          ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v7[5])((jp2_output_box *)&v7, __ptr, 2uLL);
        }
        else
        {
          __ptr[0] = 1;
          ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v7[5])((jp2_output_box *)&v7, __ptr, 1uLL);
          __ptr[0] = *(_DWORD *)(*((_QWORD *)v4 + 4) + v5 + 4);
          ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v7[5])((jp2_output_box *)&v7, __ptr, 1uLL);
        }
        ++v6;
        v5 += 16;
      }
      while (v6 < *((int *)v4 + 7));
    }
    jp2_output_box::close((jp2_output_box *)&v7);
    v7 = &off_1E1BB0038;
    this = (_BYTE *)*((_QWORD *)&v11 + 1);
    if (*((_QWORD *)&v11 + 1))
      return (_BYTE *)MEMORY[0x18D761C18](*((_QWORD *)&v11 + 1), 0x1000C8077774924);
  }
  return this;
}

void sub_187F21D78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a18)
    MEMORY[0x18D761C18](a18, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t j2_component_map::finalize(uint64_t this, j2_dimensions *a2, j2_palette *a3)
{
  jp2_dimensions *v3;
  jp2_palette *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  signed int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  *(_QWORD *)(this + 8) = a2;
  v3 = (jp2_dimensions *)(this + 8);
  *(_QWORD *)(this + 16) = a3;
  v4 = (jp2_palette *)(this + 16);
  if (!a2)
    j2_component_map::finalize();
  if (!a3)
    jp2_palette::get_num_luts();
  v5 = this;
  v6 = *((_DWORD *)a2 + 5);
  v7 = *((_DWORD *)a3 + 1);
  if (v7 < 1)
  {
    if (*(_BYTE *)this)
    {
      v20 = 0;
      v18 = 0u;
      v19 = 0u;
      kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v18 + 16))(&v18, "JP2-family data source appears to contain a Component Mapping (cmap) box without any matching Palette (pclr) box.  Palette and Component Mapping boxes must be in one-to-one correspondence.");
      kdu_error::~kdu_error((kdu_error *)&v18);
    }
    if (*(_DWORD *)(this + 28))
      j2_component_map::finalize();
    *(_DWORD *)(this + 24) = v6;
    *(_DWORD *)(this + 28) = v6;
    v14 = *(_QWORD *)(this + 32);
    if (v14)
      MEMORY[0x18D761C18](v14, 0x1000C808B6DE1C6);
    this = operator new[]();
    *(_QWORD *)(v5 + 32) = this;
    if (*(int *)(v5 + 28) >= 1)
    {
      v15 = 0;
      v16 = 0;
      do
      {
        v17 = *(_QWORD *)(v5 + 32) + v15;
        *(_DWORD *)v17 = v16;
        *(_DWORD *)(v17 + 4) = -1;
        *(_DWORD *)(v17 + 8) = jp2_dimensions::get_bit_depth(v3, v16);
        this = jp2_dimensions::get_signed(v3, v16);
        *(_BYTE *)(v17 + 12) = this;
        ++v16;
        v15 += 16;
      }
      while (v16 < *(int *)(v5 + 28));
    }
  }
  else
  {
    *(_BYTE *)this = 1;
    if (*(int *)(this + 28) >= 1)
    {
      v8 = 0;
      v9 = 0;
      do
      {
        v10 = *(_QWORD *)(v5 + 32);
        v11 = *(_DWORD *)(v10 + v8);
        if (v11 < 0 || v11 >= v6 || (v12 = *(_DWORD *)(v10 + v8 + 4), v12 >= v7))
        {
          v20 = 0;
          v18 = 0u;
          v19 = 0u;
          kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v18 + 16))(&v18, "JP2-family data source appears to contain an illegal Component Mapping (cmap) box, one of whose channels refers to a non-existent image component or palette lookup table.");
          kdu_error::~kdu_error((kdu_error *)&v18);
        }
        v13 = v10 + v8;
        if (v12 < 0)
        {
          *(_DWORD *)(v13 + 8) = jp2_dimensions::get_bit_depth(v3, *(_DWORD *)(v10 + v8));
          this = jp2_dimensions::get_signed(v3, *(_DWORD *)(v10 + v8));
        }
        else
        {
          *(_DWORD *)(v13 + 8) = jp2_palette::get_bit_depth(v4, v12);
          this = jp2_palette::get_signed(v4, *(_DWORD *)(v13 + 4));
        }
        *(_BYTE *)(v10 + v8 + 12) = this;
        ++v9;
        v8 += 16;
      }
      while (v9 < *(int *)(v5 + 28));
    }
  }
  return this;
}

void sub_187F21FFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F22008()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_component_map::add_cmap_channel(j2_component_map *this, signed int a2, signed int a3)
{
  uint64_t v3;
  jp2_dimensions *v4;
  uint64_t v6;
  jp2_palette *v7;
  int v10;
  uint64_t v11;
  uint64_t result;
  _DWORD *v13;
  uint64_t v14;
  int v15;
  jp2_dimensions *v16;
  uint64_t v17;
  uint64_t v18;
  __int128 *v19;
  _OWORD *v20;
  __int128 v21;
  uint64_t v22;
  unsigned int *v23;
  _DWORD *v24;
  char v25;
  jp2_dimensions *v26;
  _OWORD v27[2];
  uint64_t v28;

  v4 = (j2_component_map *)((char *)this + 8);
  v3 = *((_QWORD *)this + 1);
  if (!v3 || (v7 = (j2_component_map *)((char *)this + 16), (v6 = *((_QWORD *)this + 2)) == 0))
    j2_component_map::add_cmap_channel();
  if (a3 < 0)
    v10 = -1;
  else
    v10 = a3;
  v11 = *((unsigned int *)this + 7);
  if ((int)v11 < 1)
  {
LABEL_11:
    if (a2 < 0 || *(_DWORD *)(v3 + 20) <= a2 || v10 >= *(_DWORD *)(v6 + 4))
    {
      v28 = 0;
      memset(v27, 0, sizeof(v27));
      kdu_error::kdu_error((kdu_error *)v27, "Error in Kakadu File Format Support:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v27[0] + 16))(v27, "Attempting to create a Component Mapping (cmap) box, one of whose channels refers to a non-existent image component or palette lookup table.");
      kdu_error::~kdu_error((kdu_error *)v27);
    }
    if (!*(_BYTE *)this)
      j2_component_map::add_cmap_channel();
    v15 = *((_DWORD *)this + 6);
    LODWORD(v14) = *((_DWORD *)this + 7);
    if ((int)v14 < v15)
    {
      v16 = v4;
      v17 = *((_QWORD *)this + 4);
LABEL_25:
      v22 = (int)v14;
      v23 = (unsigned int *)(v17 + 16 * (int)v14);
      *((_DWORD *)this + 7) = v14 + 1;
      *v23 = a2;
      v24 = v23 + 2;
      v23[1] = v10;
      if (a3 < 0)
      {
        v26 = v16;
        *v24 = jp2_dimensions::get_bit_depth(v16, a2);
        v25 = jp2_dimensions::get_signed(v26, *v23);
      }
      else
      {
        *v24 = jp2_palette::get_bit_depth(v7, a3);
        v25 = jp2_palette::get_signed(v7, v23[1]);
      }
      *(_BYTE *)(v17 + 16 * v22 + 12) = v25;
      return (*((_DWORD *)this + 7) - 1);
    }
    *((_DWORD *)this + 6) = v14 + v15 + 3;
    v17 = operator new[]();
    v14 = *((unsigned int *)this + 7);
    v18 = *((_QWORD *)this + 4);
    if ((int)v14 < 1)
    {
      if (!v18)
        goto LABEL_24;
    }
    else
    {
      v19 = (__int128 *)*((_QWORD *)this + 4);
      v20 = (_OWORD *)v17;
      do
      {
        v21 = *v19++;
        *v20++ = v21;
        --v14;
      }
      while (v14);
    }
    MEMORY[0x18D761C18](v18, 0x1000C808B6DE1C6);
    LODWORD(v14) = *((_DWORD *)this + 7);
LABEL_24:
    v16 = v4;
    *((_QWORD *)this + 4) = v17;
    goto LABEL_25;
  }
  result = 0;
  v13 = (_DWORD *)(*((_QWORD *)this + 4) + 4);
  while (*(v13 - 1) != a2 || *v13 != v10)
  {
    v13 += 4;
    if (v11 == ++result)
      goto LABEL_11;
  }
  return result;
}

void sub_187F22248(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F22254()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_channels::copy(j2_channels *this, j2_channels *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  unint64_t v11;
  __int128 *v12;
  _OWORD *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t result;
  uint64_t v18;
  _OWORD v19[2];
  uint64_t v20;

  if (*((_QWORD *)this + 1) || *((_QWORD *)this + 4))
  {
    v20 = 0;
    memset(v19, 0, sizeof(v19));
    kdu_error::kdu_error((kdu_error *)v19, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v19);
  }
  v4 = *((unsigned int *)a2 + 1);
  *(_DWORD *)this = v4;
  *((_DWORD *)this + 1) = v4;
  v5 = operator new[]();
  if ((_DWORD)v4)
  {
    v6 = v5;
    do
    {
      *(_QWORD *)(v6 + 8) = -1;
      *(_QWORD *)(v6 + 16) = -1;
      v7 = 36;
      v8 = 48;
      *(_QWORD *)v6 = -1;
      do
      {
        v9 = (_DWORD *)(v6 + v7);
        *v9 = -1;
        *(v9 - 3) = -1;
        *(_BYTE *)(v6 + v8++) = 0;
        v7 += 4;
      }
      while (v8 != 51);
      *(_QWORD *)(v6 + 52) = 0xFFFFFFFF00000000;
      *(_BYTE *)(v6 + 60) = 0;
      v6 += 64;
    }
    while (v6 != v5 + (v4 << 6));
  }
  *((_QWORD *)this + 1) = v5;
  if (*((_DWORD *)this + 1))
  {
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = (__int128 *)(*((_QWORD *)a2 + 1) + v10);
      v13 = (_OWORD *)(*((_QWORD *)this + 1) + v10);
      v14 = *v12;
      v15 = v12[1];
      v16 = v12[2];
      *(_OWORD *)((char *)v13 + 45) = *(__int128 *)((char *)v12 + 45);
      v13[1] = v15;
      v13[2] = v16;
      *v13 = v14;
      ++v11;
      v10 += 64;
    }
    while (v11 < *((unsigned int *)this + 1));
  }
  *((_WORD *)this + 8) = *((_WORD *)a2 + 8);
  *((_BYTE *)this + 18) = *((_BYTE *)a2 + 18);
  *((_DWORD *)this + 5) = 0;
  result = *((unsigned int *)a2 + 6);
  *((_DWORD *)this + 6) = result;
  if ((int)result >= 1)
  {
    result = operator new[]();
    *((_QWORD *)this + 4) = result;
    if (*((int *)this + 6) >= 1)
    {
      v18 = 0;
      do
      {
        *(_BYTE *)(*((_QWORD *)this + 4) + v18) = *(_BYTE *)(*((_QWORD *)a2 + 4) + v18);
        ++v18;
      }
      while (v18 < *((int *)this + 6));
    }
  }
  return result;
}

void sub_187F22414(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F22420()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_channels::init(j2_channels *this, jp2_input_box *a2)
{
  int v4;
  _BOOL4 v5;
  int v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  __int128 *v18;
  _OWORD *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  unsigned __int16 v36[2];
  unsigned __int16 v37;
  unsigned __int16 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  if (*((_QWORD *)this + 1)
    || *((_QWORD *)this + 4)
    || *((_BYTE *)this + 17)
    || *((_BYTE *)this + 18)
    || *((_BYTE *)this + 16))
  {
    v41 = 0;
    v39 = 0u;
    v40 = 0u;
    kdu_error::kdu_error((kdu_error *)&v39, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v39);
  }
  v4 = *((_DWORD *)a2 + 12);
  if (v4 != 1869636468)
  {
    if (v4 != 1667523942)
      j2_channels::init();
    v38 = 0;
    v5 = jp2_input_box::read(a2, &v38);
    v35 = v38;
    if (!v5 || !v38)
    {
      v41 = 0;
      v39 = 0u;
      v40 = 0u;
      kdu_error::kdu_error((kdu_error *)&v39, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v39 + 16))(&v39, "Malformed channel definition (cdef) box found in JP2-family data source.  Missing or invalid fields.");
      kdu_error::~kdu_error((kdu_error *)&v39);
    }
    v6 = 0;
    while (1)
    {
      v37 = 0;
      *(_DWORD *)v36 = 0;
      if (!jp2_input_box::read(a2, &v37)
        || !jp2_input_box::read(a2, &v36[1])
        || !jp2_input_box::read(a2, v36)
        || (v7 = v36[1], (unsigned __int16)(v36[1] + 1) >= 4u))
      {
        v41 = 0;
        v39 = 0u;
        v40 = 0u;
        kdu_error::kdu_error((kdu_error *)&v39, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v39 + 16))(&v39, "Malformed channel definition (cdef) box found in JP2-family data source.  Missing or invalid channel association information.");
        kdu_error::~kdu_error((kdu_error *)&v39);
      }
      v8 = v36[0];
      if (v36[0] == 0xFFFF || v36[1] > 2u)
        goto LABEL_41;
      v9 = v36[0] ? v36[0] - 1 : 0;
      if (v9 >= *(_DWORD *)this)
        break;
LABEL_35:
      if (v9 >= *((_DWORD *)this + 1))
        *((_DWORD *)this + 1) = v9 + 1;
      v23 = *((_QWORD *)this + 1);
      v24 = v23 + (v9 << 6);
      if ((*(_DWORD *)(v24 + 4 * v7) & 0x80000000) == 0)
      {
        v41 = 0;
        v39 = 0u;
        v40 = 0u;
        kdu_error::kdu_error((kdu_error *)&v39, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v39 + 16))(&v39, "Malformed channel definition (cdef) box found in JP2-family data source.  The box appears to provide multiple channels with the same Assoc/Typ values.");
        kdu_error::~kdu_error((kdu_error *)&v39);
      }
      *(_DWORD *)(v24 + 4 * v7) = v37;
      if (!v8)
        *(_BYTE *)(v23 + (v9 << 6) + v7 + 48) = 1;
LABEL_41:
      if (++v6 >= v35)
      {
        result = (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
        if ((result & 1) == 0)
        {
          v41 = 0;
          v39 = 0u;
          v40 = 0u;
          kdu_error::kdu_error((kdu_error *)&v39, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v39 + 16))(&v39, "Malformed channel definition (cdef) box found in JP2-family data source.  The box appears to be too long.");
          goto LABEL_68;
        }
        return result;
      }
    }
    v10 = (v9 + *(_DWORD *)this + 3);
    *(_DWORD *)this = v10;
    v11 = operator new[]();
    v12 = v11;
    if ((_DWORD)v10)
    {
      v13 = v11;
      do
      {
        *(_QWORD *)(v13 + 8) = -1;
        *(_QWORD *)(v13 + 16) = -1;
        v14 = 36;
        v15 = 48;
        *(_QWORD *)v13 = -1;
        do
        {
          v16 = (_DWORD *)(v13 + v14);
          *v16 = -1;
          *(v16 - 3) = -1;
          *(_BYTE *)(v13 + v15++) = 0;
          v14 += 4;
        }
        while (v15 != 51);
        *(_QWORD *)(v13 + 52) = 0xFFFFFFFF00000000;
        *(_BYTE *)(v13 + 60) = 0;
        v13 += 64;
      }
      while (v13 != v11 + (v10 << 6));
    }
    v17 = *((unsigned int *)this + 1);
    v18 = (__int128 *)*((_QWORD *)this + 1);
    v19 = (_OWORD *)v11;
    if ((_DWORD)v17)
    {
      do
      {
        v20 = *v18;
        v21 = v18[1];
        v22 = v18[2];
        *(_OWORD *)((char *)v19 + 45) = *(__int128 *)((char *)v18 + 45);
        v19[1] = v21;
        v19[2] = v22;
        *v19 = v20;
        v19 += 4;
        v18 += 4;
        --v17;
      }
      while (v17);
    }
    else if (!*((_QWORD *)this + 1))
    {
LABEL_34:
      *((_QWORD *)this + 1) = v12;
      goto LABEL_35;
    }
    MEMORY[0x18D761C18]();
    goto LABEL_34;
  }
  LOBYTE(v38) = 0;
  if ((*(unsigned int (**)(jp2_input_box *, unsigned __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v38, 1) != 1|| v38 >= 3u)
  {
    v41 = 0;
    v39 = 0u;
    v40 = 0u;
    kdu_error::kdu_error((kdu_error *)&v39, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v39 + 16))(&v39, "Malformed opacity (opct) box found in JPX data source.  Failed to read valid Otyp field.");
    kdu_error::~kdu_error((kdu_error *)&v39);
  }
  if (v38 == 1)
  {
    *((_BYTE *)this + 18) = 1;
  }
  else
  {
    if (!(_BYTE)v38)
    {
      *((_BYTE *)this + 17) = 1;
      goto LABEL_66;
    }
    LOBYTE(v37) = 0;
    if ((*(unsigned int (**)(jp2_input_box *, unsigned __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v37, 1) != 1)
    {
      v41 = 0;
      v39 = 0u;
      v40 = 0u;
      kdu_error::kdu_error((kdu_error *)&v39, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v39 + 16))(&v39, "Malformed opacity (opct) box found in JPX data source.  Failed to read valid Nch field.");
      kdu_error::~kdu_error((kdu_error *)&v39);
    }
    *((_BYTE *)this + 16) = 1;
    v27 = v37;
    *(_DWORD *)this = v37;
    *((_DWORD *)this + 1) = v27;
    v28 = operator new[]();
    if (v27)
    {
      v29 = v28;
      do
      {
        *(_QWORD *)(v29 + 8) = -1;
        *(_QWORD *)(v29 + 16) = -1;
        v30 = 36;
        v31 = 48;
        *(_QWORD *)v29 = -1;
        do
        {
          v32 = (_DWORD *)(v29 + v30);
          *v32 = -1;
          *(v32 - 3) = -1;
          *(_BYTE *)(v29 + v31++) = 0;
          v30 += 4;
        }
        while (v31 != 51);
        *(_QWORD *)(v29 + 52) = 0xFFFFFFFF00000000;
        *(_BYTE *)(v29 + 60) = 0;
        v29 += 64;
      }
      while (v29 != v28 + (v27 << 6));
    }
    *((_QWORD *)this + 1) = v28;
    if (*((_BYTE *)a2 + 125))
    {
      *((_DWORD *)this + 6) = -1;
      goto LABEL_63;
    }
    v33 = *((_DWORD *)a2 + 44) + *((_DWORD *)a2 + 22) - *((_DWORD *)a2 + 34);
    *((_DWORD *)this + 6) = v33;
    if (v33 <= 0)
    {
LABEL_63:
      v41 = 0;
      v39 = 0u;
      v40 = 0u;
      kdu_error::kdu_error((kdu_error *)&v39, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v39 + 16))(&v39, "Malformed opacity (opct) box found in JPX data source. Failed to read valid Nch field.");
      kdu_error::~kdu_error((kdu_error *)&v39);
    }
    v34 = operator new[]();
    *((_QWORD *)this + 4) = v34;
    (*(void (**)(jp2_input_box *, uint64_t, _QWORD))(*(_QWORD *)a2 + 32))(a2, v34, *((unsigned int *)this + 6));
  }
LABEL_66:
  result = (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
  if ((result & 1) == 0)
  {
    v41 = 0;
    v39 = 0u;
    v40 = 0u;
    kdu_error::kdu_error((kdu_error *)&v39, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v39 + 16))(&v39, "Malformed opacity (opct) box found in JPX data source.  The box appears to be too long.");
LABEL_68:
    kdu_error::~kdu_error((kdu_error *)&v39);
  }
  return result;
}

void sub_187F22A64(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F22A70(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

unsigned int *j2_channels::finalize(unsigned int *this, unsigned int a2, int a3)
{
  unsigned int *v4;
  unint64_t v5;
  unint64_t v6;
  _DWORD *v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  __int128 *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unint64_t v24;
  _DWORD *v25;
  unint64_t v26;
  _DWORD *v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  _DWORD *v31;
  uint64_t v32;
  unint64_t i;
  uint64_t v34;
  _DWORD *v35;
  _DWORD *v36;
  _DWORD *v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v4 = this;
  v5 = this[1];
  if (a2)
  {
    v6 = a2;
    if (v5 > a2)
    {
      v40 = 0;
      v38 = 0u;
      v39 = 0u;
      kdu_error::kdu_error((kdu_error *)&v38, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)&v38);
    }
  }
  else
  {
    v6 = this[1];
  }
  if (*((_QWORD *)this + 4))
  {
    if (v5 != v6)
    {
      v40 = 0;
      v38 = 0u;
      v39 = 0u;
      kdu_error::kdu_error((kdu_error *)&v38, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v38 + 16))(&v38, "Malformed opacity (opct) box encountered in a JPX file indicates a different number of colour channels to that associated with the specified colour space.");
      kdu_error::~kdu_error((kdu_error *)&v38);
    }
    v7 = 0;
    if ((a3 & 1) != 0)
      goto LABEL_49;
    goto LABEL_21;
  }
  if (v5 < v6)
  {
    if (v6 <= *this)
    {
LABEL_44:
      if (v5 || *((_BYTE *)v4 + 17) || *((_BYTE *)v4 + 18))
      {
        v7 = 0;
      }
      else
      {
        v7 = 0;
        if (!*((_BYTE *)v4 + 16) && (int)v6 >= 1)
        {
          v34 = 0;
          v35 = (_DWORD *)*((_QWORD *)v4 + 1);
          v36 = v35;
          do
          {
            v37 = v36;
            if (a3)
            {
              v36[3] = 0;
              v37 = &v35[16 * v34 + 6];
            }
            *v37 = v34++;
            v36 += 16;
          }
          while (v6 != v34);
          v7 = v36 - 16;
        }
      }
      v4[1] = v6;
      if ((a3 & 1) != 0)
        goto LABEL_49;
      goto LABEL_21;
    }
    *this = v6;
    this = (unsigned int *)operator new[]();
    v8 = this;
    v9 = (uint64_t)this;
    do
    {
      *(_QWORD *)(v9 + 8) = -1;
      *(_QWORD *)(v9 + 16) = -1;
      v10 = 36;
      v11 = 48;
      *(_QWORD *)v9 = -1;
      do
      {
        v12 = (_DWORD *)(v9 + v10);
        *v12 = -1;
        *(v12 - 3) = -1;
        *(_BYTE *)(v9 + v11++) = 0;
        v10 += 4;
      }
      while (v11 != 51);
      *(_QWORD *)(v9 + 52) = 0xFFFFFFFF00000000;
      *(_BYTE *)(v9 + 60) = 0;
      v9 += 64;
    }
    while ((unsigned int *)v9 != &this[16 * v6]);
    v13 = v4[1];
    v5 = *((_QWORD *)v4 + 1);
    if ((_DWORD)v13)
    {
      v14 = (__int128 *)*((_QWORD *)v4 + 1);
      do
      {
        v15 = *v14;
        v16 = v14[1];
        v17 = v14[2];
        *(_OWORD *)((char *)this + 45) = *(__int128 *)((char *)v14 + 45);
        *((_OWORD *)this + 1) = v16;
        *((_OWORD *)this + 2) = v17;
        *(_OWORD *)this = v15;
        this += 16;
        v14 += 4;
        --v13;
      }
      while (v13);
    }
    else if (!v5)
    {
LABEL_43:
      *((_QWORD *)v4 + 1) = v8;
      goto LABEL_44;
    }
    this = (unsigned int *)MEMORY[0x18D761C18](v5, 0x1000C80A987AF97);
    v5 = v4[1];
    goto LABEL_43;
  }
  v7 = 0;
  v6 = this[1];
  if ((a3 & 1) != 0)
  {
LABEL_49:
    if (v6)
    {
      v28 = 0;
      v29 = 4;
      do
      {
        if (*((_BYTE *)v4 + 16)
          && ((*(_DWORD *)(*((_QWORD *)v4 + 1) + v29) & 0x80000000) == 0 || (v7[2] & 0x80000000) == 0))
        {
          v40 = 0;
          v38 = 0u;
          v39 = 0u;
          kdu_error::kdu_error((kdu_error *)&v38, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v38);
        }
        ++v28;
        v29 += 64;
      }
      while (v28 < v6);
    }
    return this;
  }
LABEL_21:
  if (v6 >= 2)
  {
    v18 = *((_QWORD *)v4 + 1);
    v19 = 1;
    v20 = 64;
    do
    {
      v21 = 0;
      v22 = v18 + v20;
      do
      {
        if (*(_BYTE *)(v18 + v21 + 48))
        {
          if ((*(_DWORD *)(v22 + 4 * v21) & 0x80000000) == 0)
          {
            v40 = 0;
            v38 = 0u;
            v39 = 0u;
            kdu_error::kdu_error((kdu_error *)&v38, "Error in Kakadu File Format Support:\n");
            (*(void (**)(__int128 *, const char *))(v38 + 16))(&v38, "Malformed channel definition (cdef) box found in JP2-family data source.  The box appears to provide multiple channels with the same Assoc/Typ values.");
            kdu_error::~kdu_error((kdu_error *)&v38);
          }
          v23 = *(_DWORD *)(v18 + 4 * v21);
          if (v23 < 0)
            j2_channels::finalize();
          *(_DWORD *)(v22 + 4 * v21) = v23;
        }
        ++v21;
      }
      while (v21 != 3);
      ++v19;
      v6 = v4[1];
      v20 += 64;
    }
    while (v19 < v6);
  }
  if (*((_BYTE *)v4 + 17))
  {
    if (!v6)
      return this;
    v24 = 0;
    v25 = (_DWORD *)(*((_QWORD *)v4 + 1) + 4);
    do
    {
      *(v25 - 1) = v24;
      *v25 = v4[1];
      v25 += 16;
      ++v24;
      v6 = v4[1];
    }
    while (v24 < v6);
  }
  else if (*((_BYTE *)v4 + 18))
  {
    if (!v6)
      return this;
    v26 = 0;
    v27 = (_DWORD *)(*((_QWORD *)v4 + 1) + 8);
    do
    {
      *(v27 - 2) = v26;
      *v27 = v4[1];
      v27 += 16;
      ++v26;
      v6 = v4[1];
    }
    while (v26 < v6);
  }
  else if (*((_QWORD *)v4 + 4))
  {
    if (!v6)
      return this;
    v30 = 0;
    v31 = (_DWORD *)*((_QWORD *)v4 + 1);
    do
    {
      *v31 = v30;
      v31 += 16;
      ++v30;
      v6 = v4[1];
    }
    while (v30 < v6);
  }
  if (v6)
  {
    v32 = 0;
    for (i = 0; i < v6; ++i)
    {
      if ((*(_DWORD *)(*((_QWORD *)v4 + 1) + v32) & 0x80000000) != 0)
      {
        v40 = 0;
        v38 = 0u;
        v39 = 0u;
        kdu_error::kdu_error((kdu_error *)&v38, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v38);
      }
      v32 += 64;
    }
  }
  return this;
}

void sub_187F22F8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F22F98()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL j2_channels::all_cmap_channels_found(j2_channels *this)
{
  unint64_t v1;
  unint64_t v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;

  v1 = *((unsigned int *)this + 1);
  if ((_DWORD)v1)
  {
    v2 = 0;
    v3 = 0;
    v4 = *((_QWORD *)this + 1);
LABEL_3:
    v5 = 0;
    while ((*(_DWORD *)(v4 + v5) & 0x80000000) != 0 || (*(_DWORD *)(v4 + v5 + 12) & 0x80000000) == 0)
    {
      v5 += 4;
      if (v5 == 12)
      {
        ++v2;
        v4 += 64;
        v3 = v2 >= v1;
        if (v2 != v1)
          goto LABEL_3;
        return 1;
      }
    }
  }
  else
  {
    return 1;
  }
  return v3;
}

unsigned int *j2_channels::find_cmap_channels(unsigned int *this, j2_component_map *a2, int a3)
{
  unsigned int *v4;
  _DWORD *v5;
  signed int v6;
  unsigned int v7;
  unint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  unsigned __int8 *v19;
  unint64_t v20;
  signed int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int *v25;
  int v26;
  signed int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  unsigned __int8 v33;
  unsigned int *v34;
  _BYTE *v35;
  _DWORD *v36;
  _OWORD v38[2];
  uint64_t v39;

  v4 = this;
  if (this[1])
  {
    v5 = this + 5;
    v6 = this[5];
    this[5] = *((_DWORD *)a2 + 7) + v6;
  }
  else
  {
    this = j2_channels::finalize(this, *((_DWORD *)a2 + 7), 0);
    v5 = v4 + 5;
    v6 = v4[5];
    v7 = v4[1];
    v4[5] = *((_DWORD *)a2 + 7) + v6;
    if (!v7)
      return this;
  }
  v8 = 0;
  v9 = 1;
  v10 = 24;
  v34 = v4;
  do
  {
    v11 = *((_QWORD *)v4 + 1);
    v12 = v11 + (v8 << 6);
    v35 = (_BYTE *)(v12 + 60);
    v36 = (_DWORD *)(v12 + 56);
    v13 = v11 + v10;
    v14 = -12;
    do
    {
      v15 = *(_DWORD *)(v13 + v14 - 12);
      if (v15 < 0)
      {
        if (v14 == -12)
          j2_channels::find_cmap_channels();
      }
      else
      {
        v16 = v15 - v6;
        if (v15 < v6 || v15 >= *v5)
        {
          v9 &= *(_DWORD *)(v13 + v14) >= 0;
        }
        else
        {
          v17 = v13 + v14;
          *(_DWORD *)(v13 + v14) = a3;
          j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
          *(_DWORD *)(v17 + 12) = *(_DWORD *)(*((_QWORD *)a2 + 4) + 16 * v16);
          this = (unsigned int *)j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
          *(_DWORD *)(v17 + 24) = *(_DWORD *)(*((_QWORD *)a2 + 4) + 16 * v16 + 4);
          if (v14 == -12)
          {
            j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
            *v36 = *(_DWORD *)(*((_QWORD *)a2 + 4) + 16 * v16 + 8);
            this = (unsigned int *)j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
            *v35 = *(_BYTE *)(*((_QWORD *)a2 + 4) + 16 * v16 + 12);
          }
        }
      }
      v14 += 4;
    }
    while (v14);
    ++v8;
    v4 = v34;
    v18 = v34[1];
    v10 += 64;
  }
  while (v8 < v18);
  if ((v9 & 1) != 0)
  {
    v19 = (unsigned __int8 *)*((_QWORD *)v34 + 4);
    if (v19)
    {
      if ((_DWORD)v18)
      {
        v20 = 0;
        v21 = v34[6];
        do
        {
          v22 = *((_QWORD *)v34 + 1);
          v23 = v22 + (v20 << 6);
          v26 = *(_DWORD *)(v23 + 56);
          v25 = (int *)(v23 + 56);
          v24 = v26;
          if (v26 <= 0)
            j2_channels::find_cmap_channels();
          v27 = (v24 - 1) >> 3;
          if (v27 >= v21 || v20 == (_DWORD)v18 - 1 && v27 + 1 != v21)
          {
            v39 = 0;
            memset(v38, 0, sizeof(v38));
            kdu_error::kdu_error((kdu_error *)v38, "Error in Kakadu File Format Support:\n");
            (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v38[0] + 16))(v38, "Malformed opacity (opct) box in JPX data source.  The length of a chroma key specification is incompatible with the bit-depths of the colour channels.");
            kdu_error::~kdu_error((kdu_error *)v38);
          }
          v28 = 0;
          v29 = v22 + (v20 << 6);
          *(_DWORD *)(v29 + 52) = 0;
          v30 = v29 + 52;
          v31 = *(unsigned __int8 *)(v30 + 8);
          v32 = v27 + 2;
          do
          {
            *(_DWORD *)v30 = v28 << 8;
            v33 = *v19++;
            v28 = v33 | (v28 << 8);
            *(_DWORD *)v30 = v28;
            if (v31)
            {
              if (*v25 <= 31)
              {
                v28 = v28 << -(char)*v25 >> -(char)*v25;
                *(_DWORD *)v30 = v28;
              }
            }
            --v32;
          }
          while (v32 > 1);
          ++v20;
          v18 = v34[1];
        }
        while (v20 < v18);
      }
    }
  }
  return this;
}

void sub_187F232F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F23304()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

unsigned int *j2_channels::add_cmap_channels(unsigned int *this, j2_component_map *a2, int a3)
{
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  _DWORD *v18;
  _OWORD v19[2];
  uint64_t v20;

  v5 = this;
  if (this[1])
  {
    v6 = this[5];
    this[5] = *((_DWORD *)a2 + 7) + v6;
  }
  else
  {
    this = j2_channels::finalize(this, *((_DWORD *)a2 + 7), 1);
    v7 = v5[1];
    v6 = v5[5];
    v5[5] = *((_DWORD *)a2 + 7) + v6;
    if (!v7)
      return this;
  }
  v8 = 0;
  v9 = 24;
  do
  {
    v10 = *((_QWORD *)v5 + 1);
    v11 = v10 + (v8 << 6);
    v17 = v9;
    v18 = (_DWORD *)(v11 + 56);
    v12 = (_BYTE *)(v11 + 60);
    v13 = v10 + v9;
    v14 = -12;
    do
    {
      if (*(_DWORD *)(v13 + v14) == a3)
      {
        v15 = v13 + v14;
        if ((*(_DWORD *)(v13 + v14 - 12) & 0x80000000) == 0)
          j2_channels::add_cmap_channels();
        this = (unsigned int *)j2_component_map::add_cmap_channel(a2, *(_DWORD *)(v15 + 12), *(_DWORD *)(v15 + 24));
        *(_DWORD *)(v15 - 12) = (_DWORD)this + v6;
        if (v14 == -12)
        {
          v16 = (int)this;
          j2_component_map::verify_channel_query_idx((uint64_t)a2, (int)this);
          *v18 = *(_DWORD *)(*((_QWORD *)a2 + 4) + 16 * v16 + 8);
          this = (unsigned int *)j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
          *v12 = *(_BYTE *)(*((_QWORD *)a2 + 4) + 16 * v16 + 12);
          if (*((_BYTE *)v5 + 16))
          {
            if (v8 != v16)
            {
              v20 = 0;
              memset(v19, 0, sizeof(v19));
              kdu_error::kdu_error((kdu_error *)v19, "Error in Kakadu File Format Support:\n");
              (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v19[0] + 16))(v19, "Attempting to create a JPX file which uses chroma-keys in an incompatible manner across compositing layers which share a common codestream.  The JPX file format has insufficient flexibility in its channel mapping rules to allow arbitrary binding between image components and colour channels at the same time as chroma keying.");
              kdu_error::~kdu_error((kdu_error *)v19);
            }
          }
        }
        else if (*((_BYTE *)v5 + 16))
        {
          j2_channels::add_cmap_channels();
        }
      }
      v14 += 4;
    }
    while (v14);
    ++v8;
    v9 = v17 + 64;
  }
  while (v8 < v5[1]);
  return this;
}

void sub_187F234C0(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F234CC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_channels::save_box(uint64_t this, jp2_output_box *a2, char a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  BOOL *v8;
  int *v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  BOOL *v14;
  uint64_t v15;
  _BOOL4 v16;
  char v17;
  int *v18;
  int v19;
  int v20;
  int v21;
  char v22;
  char v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t i;
  uint64_t v32;
  unint64_t v33;
  uint64_t j;
  uint64_t v35;
  char v36;
  char v37;
  BOOL v38;
  uint64_t v39;
  const char *v40;
  int v41;
  signed int v42;
  BOOL v43;
  int v44;
  _OWORD v45[2];
  uint64_t v46;
  void (**v47)(jp2_output_box *__hidden);
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v3 = *(unsigned int *)(this + 4);
  if ((_DWORD)v3)
  {
    v4 = this;
    if (*(_QWORD *)(this + 32))
      j2_channels::save_box();
    v5 = 0;
    v6 = *(_QWORD *)(this + 8);
    v7 = (int *)(v6 + 64);
    v8 = (BOOL *)(v6 + 48);
    do
    {
      if (v3 < 2)
      {
        LODWORD(v10) = 1;
      }
      else
      {
        v9 = v7;
        v10 = 1;
        while (1)
        {
          v11 = *v9;
          v9 += 16;
          if (v11 != *(_DWORD *)(v6 + 4 * v5))
            break;
          if (v3 == ++v10)
          {
            LODWORD(v10) = v3;
            break;
          }
        }
      }
      v12 = (_DWORD)v10 == (_DWORD)v3;
      v13 = v3;
      v14 = v8;
      do
      {
        *v14 = v12;
        v14 += 64;
        --v13;
      }
      while (v13);
      ++v5;
      ++v7;
      ++v8;
    }
    while (v5 != 3);
    v15 = 0;
    v16 = *(_BYTE *)(this + 16) != 0;
    v17 = a3 ^ 1;
    if (*(_BYTE *)(this + 16))
      v17 = 1;
    v18 = (int *)v6;
    while (1)
    {
      v19 = *v18;
      v18 += 16;
      if (v15 != v19)
        break;
      if (v3 == ++v15)
        goto LABEL_21;
    }
    if (*(_BYTE *)(this + 16))
      j2_channels::save_box();
    v17 = 0;
    v16 = 1;
LABEL_21:
    if (!*(_BYTE *)(v6 + 49) || !*(_BYTE *)(v6 + 50))
    {
      if (*(_BYTE *)(this + 16))
        j2_channels::save_box();
      v17 = 0;
      v16 = 1;
    }
    v21 = *(_DWORD *)(v6 + 4);
    v20 = *(_DWORD *)(v6 + 8);
    if (v21 < 0)
    {
      if (v20 < 0)
      {
        v23 = v17 ^ 1;
        if (!*(_BYTE *)(this + 16))
          v23 = 1;
        if ((v23 & 1) != 0)
        {
          if (!v16)
            return this;
          goto LABEL_48;
        }
        goto LABEL_40;
      }
    }
    else if ((v20 & 0x80000000) == 0)
    {
LABEL_48:
      v48 = 0u;
      v47 = &off_1E1BB0038;
      v52 = 0;
      v49 = 0uLL;
      v50 = 0uLL;
      v51 = 0xFFFFFFFFFFFFFFFFLL;
      jp2_output_box::open((uint64_t)&v47, a2, 1667523942, 0);
      v27 = *(unsigned int *)(v4 + 4);
      if ((_DWORD)v27)
      {
        v28 = 0;
        v29 = 0;
        v30 = *(_QWORD *)(v4 + 8);
        do
        {
          for (i = 0; i != 3; ++i)
          {
            if ((*(_DWORD *)(v30 + 4 * i + 24) & 0x80000000) == 0 && (!v28 || !*(_BYTE *)(v30 + i + 48)))
              ++v29;
          }
          ++v28;
          v30 += 64;
        }
        while (v28 != v27);
      }
      else
      {
        v29 = 0;
      }
      LOWORD(v45[0]) = bswap32(v29) >> 16;
      ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v47[5])((jp2_output_box *)&v47, (const unsigned __int8 *)v45, 2uLL);
      if (*(_DWORD *)(v4 + 4))
      {
        v32 = 0;
        v33 = 0;
        do
        {
          for (j = 0; j != 3; ++j)
          {
            v35 = *(_QWORD *)(v4 + 8);
            if ((*(_DWORD *)(v35 + v32 + 4 * j + 24) & 0x80000000) == 0)
            {
              if (*(_BYTE *)(v35 + v32 + j + 48))
                v36 = 0;
              else
                v36 = v33 + 1;
              if (*(_BYTE *)(v35 + v32 + j + 48))
                v37 = 0;
              else
                v37 = (unsigned __int16)(v33 + 1) >> 8;
              if (*(_BYTE *)(v35 + v32 + j + 48))
                v38 = v33 == 0;
              else
                v38 = 1;
              if (v38)
              {
                LOWORD(v45[0]) = bswap32(*(_DWORD *)(v35 + v32 + 4 * j)) >> 16;
                ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v47[5])((jp2_output_box *)&v47, (const unsigned __int8 *)v45, 2uLL);
                LOWORD(v45[0]) = bswap32(j) >> 16;
                ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v47[5])((jp2_output_box *)&v47, (const unsigned __int8 *)v45, 2uLL);
                BYTE1(v45[0]) = v36;
                LOBYTE(v45[0]) = v37;
                ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v47[5])((jp2_output_box *)&v47, (const unsigned __int8 *)v45, 2uLL);
              }
            }
          }
          ++v33;
          v32 += 64;
        }
        while (v33 < *(unsigned int *)(v4 + 4));
      }
      goto LABEL_88;
    }
    if (v21 == (_DWORD)v3)
    {
      if ((v17 & 1) == 0)
        goto LABEL_48;
    }
    else
    {
      if (v20 == (_DWORD)v3)
        v22 = v17;
      else
        v22 = 0;
      if ((v22 & 1) == 0)
        goto LABEL_48;
    }
LABEL_40:
    v48 = 0u;
    v47 = &off_1E1BB0038;
    v52 = 0;
    v49 = 0uLL;
    v50 = 0uLL;
    v51 = 0xFFFFFFFFFFFFFFFFLL;
    jp2_output_box::open((uint64_t)&v47, a2, 1869636468, 0);
    v24 = *(_QWORD *)(v4 + 8);
    v26 = *(_DWORD *)(v24 + 4);
    v25 = *(_DWORD *)(v24 + 8);
    if (v26 < 0)
    {
      if (v25 < 0)
      {
        if (*(_BYTE *)(v4 + 16))
        {
          LOBYTE(v45[0]) = 2;
          ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v47[5])((jp2_output_box *)&v47, (const unsigned __int8 *)v45, 1uLL);
          if (*(_DWORD *)(v4 + 4) >= 0x100u)
          {
            v46 = 0;
            memset(v45, 0, sizeof(v45));
            kdu_error::kdu_error((kdu_error *)v45, "Error in Kakadu File Format Support:\n");
            (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v45[0] + 16))(v45, "Attempting to write a JPX opacity box with chroma key values for more than 255 channels.  This is not possible within the syntactic constraints of the opct box.");
            kdu_error::~kdu_error((kdu_error *)v45);
          }
          LOBYTE(v45[0]) = *(_DWORD *)(v4 + 4);
          ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v47[5])((jp2_output_box *)&v47, (const unsigned __int8 *)v45, 1uLL);
          if (!*(_DWORD *)(v4 + 4))
            goto LABEL_88;
          v39 = 0;
          v40 = "channels[n].bit_depth > 0";
          while (1)
          {
            v41 = *(_DWORD *)(*(_QWORD *)(v4 + 8) + (v39 << 6) + 56);
            if (v41 <= 0)
              break;
            v42 = (v41 - 1) & 0xFFFFFFF8;
            do
            {
              LOBYTE(v45[0]) = *(int *)(*(_QWORD *)(v4 + 8) + (v39 << 6) + 52) >> v42;
              ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v47[5])((jp2_output_box *)&v47, (const unsigned __int8 *)v45, 1uLL);
              v43 = v42 <= 7;
              v42 -= 8;
            }
            while (!v43);
            if (++v39 >= (unint64_t)*(unsigned int *)(v4 + 4))
              goto LABEL_88;
          }
          v44 = 3535;
        }
        else
        {
          v40 = "have_chroma_key";
          v44 = 3524;
        }
      }
      else
      {
        if (!*(_BYTE *)(v4 + 16))
        {
          LOBYTE(v45[0]) = 1;
          ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v47[5])((jp2_output_box *)&v47, (const unsigned __int8 *)v45, 1uLL);
LABEL_88:
          jp2_output_box::close((jp2_output_box *)&v47);
          v47 = &off_1E1BB0038;
          this = *((_QWORD *)&v51 + 1);
          if (*((_QWORD *)&v51 + 1))
            return MEMORY[0x18D761C18](*((_QWORD *)&v51 + 1), 0x1000C8077774924);
          return this;
        }
        v40 = "!have_chroma_key";
        v44 = 3519;
      }
    }
    else
    {
      if (v25 < 0 && !*(_BYTE *)(v4 + 16))
      {
        LOBYTE(v45[0]) = 0;
        ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v47[5])((jp2_output_box *)&v47, (const unsigned __int8 *)v45, 1uLL);
        goto LABEL_88;
      }
      v40 = "(channels->cmap_channel[2] < 0) && !have_chroma_key";
      v44 = 3514;
    }
    __assert_rtn("save_box", "jp2.cpp", v44, v40);
  }
  return this;
}

void sub_187F23A40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F23A4C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  _Unwind_Exception *v23;

  if (a23)
    MEMORY[0x18D761C18](a23, 0x1000C8077774924);
  _Unwind_Resume(v23);
}

uint64_t jp2_channels::init(jp2_channels *this, int a2)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  _OWORD v10[2];
  uint64_t v11;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    jp2_channels::init();
  if (*(_QWORD *)(v2 + 8) || *(_QWORD *)(v2 + 32))
  {
    v11 = 0;
    memset(v10, 0, sizeof(v10));
    kdu_error::kdu_error((kdu_error *)v10, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v10);
  }
  *(_DWORD *)v2 = a2;
  *(_DWORD *)(v2 + 4) = a2;
  result = operator new[]();
  if (a2)
  {
    v6 = result;
    do
    {
      *(_QWORD *)(v6 + 8) = -1;
      *(_QWORD *)(v6 + 16) = -1;
      v7 = 36;
      v8 = 48;
      *(_QWORD *)v6 = -1;
      do
      {
        v9 = (_DWORD *)(v6 + v7);
        *v9 = -1;
        *(v9 - 3) = -1;
        *(_BYTE *)(v6 + v8++) = 0;
        v7 += 4;
      }
      while (v8 != 51);
      *(_QWORD *)(v6 + 52) = 0xFFFFFFFF00000000;
      *(_BYTE *)(v6 + 60) = 0;
      v6 += 64;
    }
    while (v6 != result + ((uint64_t)a2 << 6));
  }
  *(_QWORD *)(*(_QWORD *)this + 8) = result;
  return result;
}

void sub_187F23BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F23BB8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t *jp2_channels::set_colour_mapping(uint64_t *this, unsigned int a2, int a3, int a4, int a5)
{
  uint64_t v5;
  _DWORD *v6;
  int v7;

  if ((a2 & 0x80000000) != 0 || (v5 = *this) == 0 || *(_DWORD *)(v5 + 4) <= a2)
    jp2_channels::set_colour_mapping();
  v6 = (_DWORD *)(*(_QWORD *)(v5 + 8) + ((unint64_t)a2 << 6));
  v6[3] = a5;
  if (a4 < 0)
    v7 = -1;
  else
    v7 = a4;
  v6[6] = a3;
  v6[9] = v7;
  return this;
}

uint64_t *jp2_channels::set_opacity_mapping(uint64_t *this, unsigned int a2, int a3, int a4, int a5)
{
  uint64_t v5;
  _DWORD *v6;
  int v7;

  if ((a2 & 0x80000000) != 0 || (v5 = *this) == 0 || *(_DWORD *)(v5 + 4) <= a2)
    jp2_channels::set_opacity_mapping();
  v6 = (_DWORD *)(*(_QWORD *)(v5 + 8) + ((unint64_t)a2 << 6));
  v6[4] = a5;
  if (a4 < 0)
    v7 = -1;
  else
    v7 = a4;
  v6[7] = a3;
  v6[10] = v7;
  return this;
}

uint64_t *jp2_channels::set_premult_mapping(uint64_t *this, unsigned int a2, int a3, int a4, int a5)
{
  uint64_t v5;
  _DWORD *v6;

  if ((a2 & 0x80000000) != 0 || (v5 = *this) == 0 || *(_DWORD *)(v5 + 4) <= a2)
    jp2_channels::set_premult_mapping();
  v6 = (_DWORD *)(*(_QWORD *)(v5 + 8) + ((unint64_t)a2 << 6));
  v6[5] = a5;
  v6[8] = a3;
  v6[11] = a4;
  return this;
}

uint64_t jp2_channels::get_num_colours(jp2_channels *this)
{
  if (!*(_QWORD *)this)
    jp2_channels::get_num_colours();
  return *(unsigned int *)(*(_QWORD *)this + 4);
}

BOOL jp2_channels::get_colour_mapping(jp2_channels *this, unsigned int a2, int *a3, int *a4, int *a5)
{
  uint64_t v5;
  _DWORD *v6;
  int v7;
  _DWORD *exception;

  if ((a2 & 0x80000000) != 0 || (v5 = *(_QWORD *)this) == 0 || *(_DWORD *)(v5 + 4) <= a2)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v6 = (_DWORD *)(*(_QWORD *)(v5 + 8) + ((unint64_t)a2 << 6));
  v7 = v6[3];
  if ((v7 & 0x80000000) == 0)
  {
    *a5 = v7;
    *a3 = v6[6];
    *a4 = v6[9];
  }
  return v7 >= 0;
}

BOOL jp2_channels::get_opacity_mapping(jp2_channels *this, unsigned int a2, int *a3, int *a4, int *a5)
{
  uint64_t v5;
  _DWORD *v6;
  int v7;

  if ((a2 & 0x80000000) != 0 || (v5 = *(_QWORD *)this) == 0 || *(_DWORD *)(v5 + 4) <= a2)
    jp2_channels::get_opacity_mapping();
  v6 = (_DWORD *)(*(_QWORD *)(v5 + 8) + ((unint64_t)a2 << 6));
  v7 = v6[4];
  if ((v7 & 0x80000000) == 0)
  {
    *a5 = v7;
    *a3 = v6[7];
    *a4 = v6[10];
  }
  return v7 >= 0;
}

BOOL jp2_channels::get_premult_mapping(jp2_channels *this, unsigned int a2, int *a3, int *a4, int *a5)
{
  uint64_t v5;
  _DWORD *v6;
  int v7;

  if ((a2 & 0x80000000) != 0 || (v5 = *(_QWORD *)this) == 0 || *(_DWORD *)(v5 + 4) <= a2)
    jp2_channels::get_premult_mapping();
  v6 = (_DWORD *)(*(_QWORD *)(v5 + 8) + ((unint64_t)a2 << 6));
  v7 = v6[5];
  if ((v7 & 0x80000000) == 0)
  {
    *a5 = v7;
    *a3 = v6[8];
    *a4 = v6[11];
  }
  return v7 >= 0;
}

BOOL jp2_channels::has_opacity(jp2_channels *this)
{
  unint64_t v1;
  uint64_t v2;
  int *v4;
  uint64_t v5;
  unint64_t v6;
  int v7;

  v1 = *(unsigned int *)(*(_QWORD *)this + 4);
  if (!(_DWORD)v1)
    return 0;
  v2 = *(_QWORD *)(*(_QWORD *)this + 8);
  if ((*(_DWORD *)(v2 + 16) & 0x80000000) == 0)
    return 1;
  v4 = (int *)(v2 + 80);
  v5 = 1;
  do
  {
    v6 = v5;
    if (v1 == v5)
      break;
    v7 = *v4;
    v4 += 16;
    ++v5;
  }
  while (v7 < 0);
  return v6 < v1;
}

BOOL jp2_channels::has_premultiplied_opacity(jp2_channels *this)
{
  unint64_t v1;
  uint64_t v2;
  int *v4;
  uint64_t v5;
  unint64_t v6;
  int v7;

  v1 = *(unsigned int *)(*(_QWORD *)this + 4);
  if (!(_DWORD)v1)
    return 0;
  v2 = *(_QWORD *)(*(_QWORD *)this + 8);
  if ((*(_DWORD *)(v2 + 20) & 0x80000000) == 0)
    return 1;
  v4 = (int *)(v2 + 84);
  v5 = 1;
  do
  {
    v6 = v5;
    if (v1 == v5)
      break;
    v7 = *v4;
    v4 += 16;
    ++v5;
  }
  while (v7 < 0);
  return v6 < v1;
}

uint64_t j2_resolution::init(uint64_t this, float a2)
{
  _OWORD v2[2];
  uint64_t v3;

  if (*(float *)this > 0.0)
  {
    v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v2[0] + 16))(v2, "JP2 resolution information may be initialized only once!");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  *(float *)this = a2;
  *(float *)(this + 4) = a2;
  *(_QWORD *)(this + 8) = 0;
  return this;
}

void sub_187F23F18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F23F24()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_resolution::init(j2_resolution *this, jp2_input_box *a2)
{
  int v4;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (*(float *)this > 0.0)
  {
    v10 = 0;
    memset(v9, 0, sizeof(v9));
    kdu_error::kdu_error((kdu_error *)v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v9[0] + 16))(v9, "JP2-family data source contains multiple instances of the resolution (res) box within the same JP2 header box or compositing layer header box!");
    kdu_error::~kdu_error((kdu_error *)v9);
  }
  if (!jp2_input_box::is_complete(a2))
    j2_resolution::init();
  *((_QWORD *)&v9[1] + 1) = 0;
  v18 = 0u;
  v22 = 0u;
  v21 = 0u;
  v19 = 0;
  *(_QWORD *)&v9[0] = &off_1E1BADD80;
  *(_OWORD *)((char *)v9 + 8) = xmmword_18820CDD0;
  v12 = 0uLL;
  v10 = 0;
  v11 = 0uLL;
  v13 = 0uLL;
  v14 = 0;
  v15 = -1;
  v16 = -1;
  v17 = -1;
  LODWORD(v18) = -1;
  DWORD2(v18) = 0;
  *(_DWORD *)((char *)&v18 + 5) = 0;
  v20 = -1;
  while (1)
  {
    v4 = jp2_input_box::open((jp2_input_box *)v9, a2);
    if (!v4)
      break;
    if (!jp2_input_box::is_complete((jp2_input_box *)v9))
    {
      jp2_input_box::close((jp2_input_box *)v9);
      (*(void (**)(jp2_input_box *, _QWORD))(*(_QWORD *)a2 + 40))(a2, 0);
      goto LABEL_16;
    }
    if ((DWORD2(v11) - 1919251299) >= 2)
      jp2_input_box::close((jp2_input_box *)v9);
    else
      j2_resolution::parse_sub_box(this, (jp2_input_box *)v9);
  }
  if (*((float *)this + 3) <= 0.0 && *((float *)this + 2) <= 0.0)
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "The JP2 resolution box must contain at least one of the capture or display resolution sub-boxes.");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (((*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2) & 1) == 0)
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "Malformed resolution box found in JP2-family data source.  Box appears to be too long.");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
LABEL_16:
  jp2_input_box::~jp2_input_box((jp2_input_box *)v9);
  return v4 ^ 1u;
}

void sub_187F24188(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F24194(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  _Unwind_Exception *v6;
  va_list va;

  va_start(va, a6);
  jp2_input_box::~jp2_input_box((jp2_input_box *)va);
  _Unwind_Resume(v6);
}

uint64_t j2_resolution::parse_sub_box(j2_resolution *this, jp2_input_box *a2)
{
  unint64_t v4;
  BOOL v5;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  double v9;
  double v10;
  int v11;
  int v12;
  double v13;
  int v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t result;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  __int16 v23;
  unsigned __int16 v24[2];
  unsigned __int16 v25[2];

  *(_DWORD *)v24 = 0;
  *(_DWORD *)v25 = 0;
  v23 = 0;
  if (!jp2_input_box::read(a2, &v25[1])
    || !jp2_input_box::read(a2, v25)
    || !jp2_input_box::read(a2, &v24[1])
    || !jp2_input_box::read(a2, v24)
    || (*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v23 + 1, 1) != 1|| ((*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v23, 1) == 1? (v5 = v25[0] == 0): (v5 = 1), !v5 ? (v6 = v24[0] == 0) : (v6 = 1), !v6 ? (v7 = v25[1] == 0) : (v7 = 1), !v7 ? (v8 = v24[1] == 0) : (v8 = 1), v8))
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v20 + 16))(&v20, "Malformed capture or display resolution sub-box found in JP2-family data source.  Insufficient or illegal data fields.");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  v9 = (double)v25[0];
  v10 = (double)v25[1] / v9;
  v11 = SHIBYTE(v23);
  if (SHIBYTE(v23) < 0)
  {
    v9 = 0.100000001;
    do
    {
      v10 = v10 * 0.100000001;
      LOWORD(v11) = v11 + 1;
    }
    while ((v11 & 0x100) == 0);
  }
  else
  {
    if (!HIBYTE(v23))
      goto LABEL_29;
    v9 = 10.0;
    do
    {
      v10 = v10 * 10.0;
      --v11;
    }
    while ((_BYTE)v11);
  }
  HIBYTE(v23) = 0;
LABEL_29:
  LOWORD(v9) = v24[1];
  LOWORD(v4) = v24[0];
  v12 = (char)v23;
  v13 = (double)*(unint64_t *)&v9 / (double)v4;
  if ((char)v23 < 0)
  {
    do
    {
      v13 = v13 * 0.100000001;
      LOWORD(v12) = v12 + 1;
    }
    while ((v12 & 0x100) == 0);
  }
  else
  {
    if (!(_BYTE)v23)
      goto LABEL_35;
    do
    {
      v13 = v13 * 10.0;
      --v12;
    }
    while ((_BYTE)v12);
  }
  LOBYTE(v23) = 0;
LABEL_35:
  v14 = *((_DWORD *)a2 + 12);
  if (v14 == 1919251300)
  {
    v17 = v13 / v10;
    *(float *)this = v17;
    if (*((float *)this + 3) <= 0.0)
      *((float *)this + 1) = v17;
    v18 = v10;
    *((float *)this + 2) = v18;
  }
  else
  {
    if (v14 != 1919251299)
      j2_resolution::parse_sub_box();
    v15 = v13 / v10;
    *((float *)this + 1) = v15;
    if (*((float *)this + 2) <= 0.0)
      *(float *)this = v15;
    v16 = v10;
    *((float *)this + 3) = v16;
  }
  result = (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
  if ((result & 1) == 0)
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v20 + 16))(&v20, "Malformed capture or display resolution sub-box found in JP2-family data source.  Box appears to be too long.");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  return result;
}

void sub_187F24468(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F24474()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

float *j2_resolution::finalize(float *this)
{
  if (*this <= 0.0)
    *this = 1.0;
  if (this[1] <= 0.0)
    this[1] = 1.0;
  return this;
}

float *j2_resolution::save_box(float *this, jp2_output_box *a2)
{
  float *v2;
  _BOOL4 v3;
  double v4;
  BOOL v5;
  float v6;
  int v7;
  j2_resolution *v8;
  float v9;
  BOOL v10;
  float v11;
  void (**v12)(jp2_output_box *__hidden);
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v2 = this;
  v3 = fabs(*this + -1.0) > 0.00999999978;
  v4 = fabs(this[1] + -1.0);
  v5 = v4 > 0.00999999978;
  v6 = this[3];
  v7 = this[2] > 0.0 || v3;
  if ((v7 & 1) != 0 || v4 > 0.00999999978 || v6 > 0.0)
  {
    v13 = 0u;
    v12 = &off_1E1BB0038;
    v17 = 0;
    v14 = 0uLL;
    v15 = 0uLL;
    v16 = 0xFFFFFFFFFFFFFFFFLL;
    v8 = (j2_resolution *)jp2_output_box::open((uint64_t)&v12, a2, 1919251232, 0);
    if (v7)
    {
      v9 = 1.0;
      if (v2[2] > 0.0)
        v9 = v2[2];
      v8 = (j2_resolution *)j2_resolution::save_sub_box(v8, (jp2_output_box *)&v12, 1919251300, v9, (float)(*v2 * v9));
      v10 = fabs((float)(v2[1] / *v2) + -1.0) >= 0.00999999978;
      v5 = v4 > 0.00999999978 && v10;
    }
    if (v5 || v6 > 0.0)
    {
      v11 = 1.0;
      if (v2[3] > 0.0)
        v11 = v2[3];
      j2_resolution::save_sub_box(v8, (jp2_output_box *)&v12, 1919251299, v11, (float)(v2[1] * v11));
    }
    jp2_output_box::close((jp2_output_box *)&v12);
    v12 = &off_1E1BB0038;
    this = (float *)*((_QWORD *)&v16 + 1);
    if (*((_QWORD *)&v16 + 1))
      return (float *)MEMORY[0x18D761C18](*((_QWORD *)&v16 + 1), 0x1000C8077774924);
  }
  return this;
}

void sub_187F2465C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17)
    MEMORY[0x18D761C18](a17, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t j2_resolution::save_sub_box(j2_resolution *this, jp2_output_box *a2, int a3, double a4, double a5)
{
  int v5;
  int v6;
  unsigned __int8 v7;
  double v8;
  int v9;
  int v10;
  signed int v11;
  unsigned __int8 v12;
  unsigned int v13;
  BOOL v14;
  uint64_t result;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  unsigned __int8 __ptr[2];

  if (a4 >= 1.0)
  {
    v6 = 0;
  }
  else
  {
    v5 = 0;
    do
    {
      v6 = v5 - 1;
      a4 = a4 * 10.0;
      if (a4 >= 1.0)
        break;
      v14 = v5-- <= -127;
    }
    while (!v14);
  }
  if (a4 <= 1.0 || v6 > 126)
  {
    v7 = v6;
  }
  else
  {
    do
    {
      v7 = v6 + 1;
      a4 = a4 * 0.1;
      if (a4 <= 1.0)
        break;
      v14 = v6++ < 126;
    }
    while (v14);
  }
  v8 = a4 * 32768.0 + 0.5;
  if (a5 >= 1.0)
  {
    v10 = 0;
  }
  else
  {
    v9 = 0;
    do
    {
      v10 = v9 - 1;
      a5 = a5 * 10.0;
      if (a5 >= 1.0)
        break;
      v14 = v9-- <= -127;
    }
    while (!v14);
  }
  v11 = (int)v8;
  if (a5 <= 1.0 || v10 > 126)
  {
    v12 = v10;
  }
  else
  {
    do
    {
      v12 = v10 + 1;
      a5 = a5 * 0.1;
      if (a5 <= 1.0)
        break;
      v14 = v10++ < 126;
    }
    while (v14);
  }
  v13 = (int)(a5 * 32768.0 + 0.5);
  v14 = v13 - 0x10000 < 0xFFFF0001 || v11 < 1;
  if (v14 || v11 >= 0x10000)
  {
    v18 = 0;
    v16 = 0u;
    v17 = 0u;
    kdu_error::kdu_error((kdu_error *)&v16, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v16 + 16))(&v16, "Unable to save resolution information having illegal or ridiculously small or large values!");
    kdu_error::~kdu_error((kdu_error *)&v16);
  }
  *((_QWORD *)&v16 + 1) = 0;
  v18 = 0;
  *(_QWORD *)&v16 = &off_1E1BB0038;
  v21 = 0;
  v17 = 0uLL;
  v19 = 0uLL;
  v20 = 0xFFFFFFFFFFFFFFFFLL;
  jp2_output_box::open((uint64_t)&v16, a2, a3, 0);
  *(_WORD *)__ptr = bswap32(v11) >> 16;
  (*(void (**)(jp2_output_box *, const unsigned __int8 *, size_t))(v16 + 40))((jp2_output_box *)&v16, __ptr, 2uLL);
  *(_WORD *)__ptr = 128;
  (*(void (**)(jp2_output_box *, const unsigned __int8 *, size_t))(v16 + 40))((jp2_output_box *)&v16, __ptr, 2uLL);
  *(_WORD *)__ptr = bswap32(v13) >> 16;
  (*(void (**)(jp2_output_box *, const unsigned __int8 *, size_t))(v16 + 40))((jp2_output_box *)&v16, __ptr, 2uLL);
  *(_WORD *)__ptr = 128;
  (*(void (**)(jp2_output_box *, const unsigned __int8 *, size_t))(v16 + 40))((jp2_output_box *)&v16, __ptr, 2uLL);
  __ptr[0] = v7;
  (*(void (**)(jp2_output_box *, const unsigned __int8 *, size_t))(v16 + 40))((jp2_output_box *)&v16, __ptr, 1uLL);
  __ptr[0] = v12;
  (*(void (**)(jp2_output_box *, const unsigned __int8 *, size_t))(v16 + 40))((jp2_output_box *)&v16, __ptr, 1uLL);
  jp2_output_box::close((jp2_output_box *)&v16);
  *(_QWORD *)&v16 = &off_1E1BB0038;
  result = *((_QWORD *)&v20 + 1);
  if (*((_QWORD *)&v20 + 1))
    return MEMORY[0x18D761C18](*((_QWORD *)&v20 + 1), 0x1000C8077774924);
  return result;
}

void sub_187F24974(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F24980(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

uint64_t jp2_resolution::init(jp2_resolution *this, float a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)this;
  if (!v2)
    jp2_resolution::init();
  return j2_resolution::init(v2, a2);
}

float **jp2_resolution::set_resolution(float **this, float a2, int a3)
{
  float *v3;
  uint64_t v4;

  v3 = *this;
  if (!*this || *v3 <= 0.0)
    jp2_resolution::set_resolution();
  v4 = 3;
  if (a3)
    v4 = 2;
  v3[v4] = a2;
  return this;
}

uint64_t j2_icc_profile::init(uint64_t this, unsigned __int8 *a2, unsigned int a3, char a4)
{
  uint64_t v5;
  int v6;
  int v7;
  void *v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t i;
  uint64_t j;
  unsigned int v17;
  unsigned int v18[2];
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v5 = this;
  *(_QWORD *)this = a2;
  if (a3 <= 3)
  {
    v21 = 0;
    v19 = 0u;
    v20 = 0u;
    kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Embedded ICC profile in JP2 colour description box has invalid data size.");
    kdu_error::~kdu_error((kdu_error *)&v19);
  }
  *(_DWORD *)(this + 8) = 4;
  v6 = bswap32(*(_DWORD *)a2);
  *(_DWORD *)(this + 8) = v6;
  if ((a4 & 1) == 0)
    *(_QWORD *)this = 0;
  v7 = v6;
  if (v6 > 100000000)
  {
    v21 = 0;
    v19 = 0u;
    v20 = 0u;
    kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Embedded ICC profile in JP2 colour description box has corrupt size field.");
    kdu_error::~kdu_error((kdu_error *)&v19);
  }
  if (v6 <= 131)
  {
    v21 = 0;
    v19 = 0u;
    v20 = 0u;
    kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Embedded ICC profile in JP2 colour description box does not have a complete header.");
    kdu_error::~kdu_error((kdu_error *)&v19);
  }
  if (v6 > (int)a3)
  {
    v21 = 0;
    v19 = 0u;
    v20 = 0u;
    kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Embedded ICC profile length does not match length specified in ICC header.\n");
    kdu_error::~kdu_error((kdu_error *)&v19);
  }
  if ((a4 & 1) == 0)
  {
    v8 = (void *)operator new[]();
    *(_QWORD *)v5 = v8;
    v7 = *(_DWORD *)(v5 + 8);
    this = (uint64_t)memcpy(v8, a2, v7);
  }
  if (v7 >= 16)
    v6 = bswap32(*(_DWORD *)(*(_QWORD *)v5 + 12));
  switch(v6)
  {
    case 1835955314:
      *(_BYTE *)(v5 + 22) = 1;
      break;
    case 1886549106:
      *(_BYTE *)(v5 + 23) = 1;
      break;
    case 1935896178:
      *(_BYTE *)(v5 + 21) = 1;
      break;
  }
  if (v7 >= 20)
    v6 = bswap32(*(_DWORD *)(*(_QWORD *)v5 + 16));
  if (v6 <= 1129142602)
  {
    if (v6 > 943934545)
    {
      if (v6 > 1111706705)
      {
        if (v6 == 1111706706)
        {
          v10 = 11;
        }
        else
        {
          if (v6 != 1128483922)
          {
            v9 = 1129142560;
            goto LABEL_60;
          }
          v10 = 12;
        }
      }
      else
      {
        switch(v6)
        {
          case 943934546:
            v10 = 8;
            break;
          case 960711762:
            v10 = 9;
            break;
          case 1094929490:
            v10 = 10;
            break;
          default:
            goto LABEL_127;
        }
      }
    }
    else
    {
      if (v6 <= 893602897)
      {
        if (v6 == 843271250)
        {
          v10 = 2;
          goto LABEL_62;
        }
        if (v6 == 860048466)
          goto LABEL_61;
        if (v6 != 876825682)
          goto LABEL_127;
        goto LABEL_116;
      }
      switch(v6)
      {
        case 893602898:
          v10 = 5;
          break;
        case 910380114:
          v10 = 6;
          break;
        case 927157330:
          v10 = 7;
          break;
        default:
          goto LABEL_127;
      }
    }
  }
  else
  {
    if (v6 > 1213421087)
    {
      if (v6 <= 1380401695)
      {
        if (v6 == 1213421088 || v6 == 1281450528)
          goto LABEL_61;
        v9 = 1282766368;
      }
      else
      {
        if (v6 <= 1497588337)
        {
          if (v6 != 1380401696)
          {
            v9 = 1482250784;
            goto LABEL_60;
          }
LABEL_61:
          v10 = 3;
          goto LABEL_62;
        }
        if (v6 == 1497588338)
          goto LABEL_61;
        v9 = 1501067552;
      }
LABEL_60:
      if (v6 == v9)
        goto LABEL_61;
LABEL_127:
      v21 = 0;
      v19 = 0u;
      v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Unknown colour space signature found in embedded ICC profile within a JP2-family data source's colour description (colr) box.");
      kdu_error::~kdu_error((kdu_error *)&v19);
    }
    if (v6 <= 1178815569)
    {
      if (v6 != 1129142603)
      {
        if (v6 != 1145261138)
        {
          if (v6 == 1162038354)
          {
            v10 = 14;
            goto LABEL_62;
          }
          goto LABEL_127;
        }
        v10 = 13;
        goto LABEL_62;
      }
LABEL_116:
      v10 = 4;
      goto LABEL_62;
    }
    if (v6 == 1178815570)
    {
      v10 = 15;
    }
    else
    {
      if (v6 != 1196573017)
      {
        v9 = 1212961568;
        goto LABEL_60;
      }
      v10 = 1;
    }
  }
LABEL_62:
  *(_DWORD *)(v5 + 12) = v10;
  if (v7 >= 24)
    v6 = bswap32(*(_DWORD *)(*(_QWORD *)v5 + 20));
  if (v6 == 1281450528)
  {
    *(_BYTE *)(v5 + 20) = 0;
  }
  else
  {
    if (v6 != 1482250784)
    {
      v21 = 0;
      v19 = 0u;
      v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Unknown PCS signature found in embedded ICC profile within a JP2-family data source's colour description (colr) box.");
      kdu_error::~kdu_error((kdu_error *)&v19);
    }
    *(_BYTE *)(v5 + 20) = 1;
  }
  if (v7 >= 132)
    v6 = bswap32(*(_DWORD *)(*(_QWORD *)v5 + 128));
  *(_DWORD *)(v5 + 16) = v6;
  *(_QWORD *)(v5 + 28) = 0;
  v11 = 40;
  *(_DWORD *)(v5 + 36) = 0;
  do
  {
    *(_DWORD *)(v5 + v11) = 0;
    v11 += 4;
  }
  while (v11 != 52);
  if (v6 >= 1)
  {
    v12 = 0;
    v13 = 140;
    do
    {
      *(_QWORD *)v18 = 0;
      v17 = 0;
      if (!j2_icc_profile::read((j2_icc_profile *)v5, &v18[1], v13 - 8)
        || !j2_icc_profile::read((j2_icc_profile *)v5, v18, v13 - 4)
        || (this = j2_icc_profile::read((j2_icc_profile *)v5, &v17, v13), !(_DWORD)this)
        || v18[0] >= 0x5F5E101)
      {
        v21 = 0;
        v19 = 0u;
        v20 = 0u;
        kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Embedded ICC profile in JP2 colour description box is corrupt!");
        kdu_error::~kdu_error((kdu_error *)&v19);
      }
      if ((int)v18[1] <= 1733843289)
      {
        switch(v18[1])
        {
          case 0x62545243u:
            this = j2_icc_profile::get_curve_data_offset((j2_icc_profile *)v5, v18[0], v17);
            *(_DWORD *)(v5 + 36) = this;
            break;
          case 0x6258595Au:
            this = j2_icc_profile::get_xyz_data_offset((j2_icc_profile *)v5, v18[0], v17);
            *(_DWORD *)(v5 + 48) = this;
            break;
          case 0x67545243u:
            this = j2_icc_profile::get_curve_data_offset((j2_icc_profile *)v5, v18[0], v17);
            *(_DWORD *)(v5 + 32) = this;
            break;
        }
        goto LABEL_96;
      }
      if ((int)v18[1] > 1918128706)
      {
        if (v18[1] != 1918128707)
        {
          if (v18[1] == 1918392666)
          {
            this = j2_icc_profile::get_xyz_data_offset((j2_icc_profile *)v5, v18[0], v17);
            *(_DWORD *)(v5 + 40) = this;
          }
          goto LABEL_96;
        }
      }
      else
      {
        if (v18[1] == 1733843290)
        {
          this = j2_icc_profile::get_xyz_data_offset((j2_icc_profile *)v5, v18[0], v17);
          *(_DWORD *)(v5 + 44) = this;
          goto LABEL_96;
        }
        if (v18[1] != 1800688195)
          goto LABEL_96;
      }
      this = j2_icc_profile::get_curve_data_offset((j2_icc_profile *)v5, v18[0], v17);
      *(_DWORD *)(v5 + 28) = this;
LABEL_96:
      ++v12;
      v13 += 12;
    }
    while (v12 < *(_DWORD *)(v5 + 16));
  }
  *(_BYTE *)(v5 + 24) = 0;
  v14 = *(_DWORD *)(v5 + 12);
  if (v14 >= 4)
  {
    v21 = 0;
    v19 = 0u;
    v20 = 0u;
    kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Embedded ICC profile has wrong number of TRCs.");
    kdu_error::~kdu_error((kdu_error *)&v19);
  }
  if (v14 >= 1)
  {
    for (i = 0; i < v14; ++i)
    {
      if (!*(_DWORD *)(v5 + 28 + 4 * i))
      {
        if (*(_BYTE *)(v5 + 21))
        {
          *(_BYTE *)(v5 + 24) = 1;
        }
        else if (*(_BYTE *)(v5 + 22))
        {
          v21 = 0;
          v19 = 0u;
          v20 = 0u;
          kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Embedded ICC profile in JP2 colour description box specifies a display profile, but does not contain a complete set of tone reproduction curves!  This condition is not compatible with any legal ICC profile.");
          kdu_error::~kdu_error((kdu_error *)&v19);
        }
      }
    }
    if (v14 == 3)
    {
      for (j = 0; j != 12; j += 4)
      {
        if (!*(_DWORD *)(v5 + 40 + j))
        {
          if (*(_BYTE *)(v5 + 21))
          {
            *(_BYTE *)(v5 + 24) = 1;
          }
          else if (*(_BYTE *)(v5 + 22))
          {
            v21 = 0;
            v19 = 0u;
            v20 = 0u;
            kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
            (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Embedded ICC profile in JP2 colour description box specifies a 3 colour display profile, but does not contain a complete set of primary colorant specifications.");
            kdu_error::~kdu_error((kdu_error *)&v19);
          }
        }
      }
    }
  }
  return this;
}

void sub_187F252F4()
{
  JUMPOUT(0x187F24E60);
}

void sub_187F252FC(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F25308(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

BOOL j2_icc_profile::read(j2_icc_profile *this, unsigned int *a2, int a3)
{
  int v3;
  unsigned __int8 *v4;
  unsigned int v5;
  int v6;
  int v7;

  v3 = *((_DWORD *)this + 2) - 3;
  if (v3 > a3)
  {
    v4 = (unsigned __int8 *)(*(_QWORD *)this + a3);
    v5 = *v4;
    *a2 = v5;
    v6 = v4[1] | (v5 << 8);
    *a2 = v6;
    v7 = v4[2] | (v6 << 8);
    *a2 = v7;
    *a2 = v4[3] | (v7 << 8);
  }
  return v3 > a3;
}

uint64_t j2_icc_profile::get_curve_data_offset(j2_icc_profile *this, int a2, int a3)
{
  uint64_t v6;
  unsigned int v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  if (a3 + a2 > *((_DWORD *)this + 2))
  {
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Illegal tag offset or length value supplied in the JP2 embedded icc profile.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  v8 = 0;
  j2_icc_profile::read(this, &v8, a2);
  if (a3 < 12 || v8 != 1668641398)
  {
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  j2_icc_profile::read(this, &v8, a2 + 4);
  v6 = (a2 + 8);
  j2_icc_profile::read(this, &v8, v6);
  if ((int)(2 * v8 + 12) > a3)
  {
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  return v6;
}

void sub_187F25558(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F25564(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t j2_icc_profile::get_xyz_data_offset(j2_icc_profile *this, int a2, int a3)
{
  unsigned int v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  if (a3 + a2 > *((_DWORD *)this + 2))
  {
    v9 = 0;
    v7 = 0u;
    v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v7 + 16))(&v7, "Illegal tag offset or length value supplied in JP2 embedded icc profile.");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  v6 = 0;
  j2_icc_profile::read(this, &v6, a2);
  if (a3 < 20 || v6 != 1482250784)
  {
    v9 = 0;
    v7 = 0u;
    v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  return (a2 + 8);
}

void sub_187F25680(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2568C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

void j2_colour::j2_colour(j2_colour *this)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_BYTE *)this + 100) = 0;
  *(_BYTE *)this = 0;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 22) = 0;
  *(_QWORD *)((char *)this + 12) = -1;
  *((_DWORD *)this + 5) = -1;
  *((_WORD *)this + 46) = 0;
  do
  {
    v2 = (char *)this + v1;
    *((_DWORD *)v2 + 16) = -1;
    *((_DWORD *)v2 + 19) = 0;
    v1 += 4;
  }
  while (v1 != 12);
}

void j2_colour::~j2_colour(j2_colour *this)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *((_QWORD *)this + 7);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8077774924);
  v3 = (_QWORD *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v3)
    std::default_delete<j2_icc_profile>::operator()[abi:ne180100]((uint64_t)this + 24, v3);
}

uint64_t j2_colour::copy(j2_colour *this, j2_colour *a2)
{
  uint64_t result;
  uint64_t v5;
  _QWORD *v6;
  uint64_t i;
  void *v8;
  uint64_t v9;
  char *v10;
  _DWORD *v11;

  result = *((_QWORD *)this + 7);
  if (result)
  {
    result = MEMORY[0x18D761C18](result, 0x1000C8077774924);
    *((_QWORD *)this + 7) = 0;
    *((_DWORD *)this + 12) = 0;
  }
  *((_DWORD *)this + 24) = *((_DWORD *)a2 + 24);
  *((_BYTE *)this + 100) = *((_BYTE *)a2 + 100);
  *(_BYTE *)this = *(_BYTE *)a2;
  *(_QWORD *)((char *)this + 4) = *(_QWORD *)((char *)a2 + 4);
  if (*((_QWORD *)a2 + 3))
  {
    v5 = operator new();
    *(_QWORD *)(v5 + 8) = 0;
    *(_QWORD *)(v5 + 16) = 0;
    *(_QWORD *)v5 = 0;
    *(_BYTE *)(v5 + 24) = 0;
    v6 = (_QWORD *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = v5;
    if (v6)
    {
      std::default_delete<j2_icc_profile>::operator()[abi:ne180100]((uint64_t)this + 24, v6);
      v5 = *((_QWORD *)this + 3);
    }
    result = j2_icc_profile::init(v5, **((unsigned __int8 ***)a2 + 3), *(_DWORD *)(*((_QWORD *)a2 + 3) + 8), 0);
  }
  if (*((_QWORD *)a2 + 7))
  {
    for (i = 0; i != 16; ++i)
      *((_BYTE *)this + i + 32) = *((_BYTE *)a2 + i + 32);
    *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
    v8 = (void *)operator new[]();
    *((_QWORD *)this + 7) = v8;
    result = (uint64_t)memcpy(v8, *((const void **)a2 + 7), *((int *)this + 12));
  }
  v9 = 0;
  v10 = (char *)a2 + 64;
  do
  {
    v11 = (_DWORD *)((char *)this + v9 + 64);
    *(v11 - 13) = *(_DWORD *)&v10[v9 - 52];
    *v11 = *(_DWORD *)&v10[v9];
    v11[3] = *(_DWORD *)&v10[v9 + 12];
    v9 += 4;
  }
  while (v9 != 12);
  *((_DWORD *)this + 22) = *((_DWORD *)a2 + 22);
  *((_WORD *)this + 46) = *((_WORD *)a2 + 46);
  return result;
}

uint64_t j2_colour::init(j2_colour *this, jp2_input_box *a2)
{
  uint64_t *v3;
  BOOL v5;
  BOOL v6;
  BOOL v7;
  unsigned int v8;
  uint64_t i;
  unsigned int v10;
  uint64_t result;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  unsigned int *v27;
  unsigned int v28;
  int v29;
  __int16 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  unsigned __int8 v34;
  __int16 v35;
  unsigned int v36[2];
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)a2 + 12) != 1668246642)
    j2_colour::init();
  if (*(_BYTE *)this || (v3 = (uint64_t *)((char *)this + 24), *((_QWORD *)this + 3)))
    j2_colour::init();
  v35 = 0;
  v34 = 0;
  if ((*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v35 + 1, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v35, 1) != 1|| ((*(unsigned int (**)(jp2_input_box *, unsigned __int8 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v34, 1) == 1? (v5 = v34 > 4u): (v5 = 1), !v5 ? (v6 = HIBYTE(v35) == 0) : (v6 = 1), !v6 ? (v7 = HIBYTE(v35) >= 5u) : (v7 = 1), v7))
  {
    v33 = 0;
    v31 = 0u;
    v32 = 0u;
    kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v31);
  }
  v8 = v35;
  if ((v35 & 0x80u) != 0)
    v8 = v35 | 0xFFFFFF00;
  *((_DWORD *)this + 24) = v8;
  *(_QWORD *)((char *)this + 12) = -1;
  *((_DWORD *)this + 5) = -1;
  *((_QWORD *)this + 8) = -1;
  *((_DWORD *)this + 18) = -1;
  for (i = 76; i != 88; i += 4)
    *(_DWORD *)((char *)this + i) = -1;
  *((_DWORD *)this + 22) = 0;
  *((_WORD *)this + 46) = 0;
  if (HIBYTE(v35) == 1)
  {
    v36[0] = 0;
    if (!jp2_input_box::read(a2, v36))
    {
      v33 = 0;
      v31 = 0u;
      v32 = 0u;
      kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed colour description (colr) box found in JP2-family data source.  Box appears to terminate prematurely.");
      kdu_error::~kdu_error((kdu_error *)&v31);
    }
    v10 = v36[0];
    if (v36[0] >= 0x19 || ((0x1FFFA1Bu >> SLOBYTE(v36[0])) & 1) == 0)
      return (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
    v12 = dword_18820D1A4[v36[0]];
    *((_DWORD *)this + 1) = v36[0];
    *((_DWORD *)this + 2) = v12;
  }
  else
  {
    if ((HIBYTE(v35) & 0xFE) != 2)
    {
      if (HIBYTE(v35) != 4)
        j2_colour::init();
      *(_QWORD *)((char *)this + 4) = 200;
      if ((*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)this + 32, 16) != 16)
      {
        v33 = 0;
        v31 = 0u;
        v32 = 0u;
        kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "JP2-family data source terminated unexpectedly inside the colour specification (colr) box.");
        kdu_error::~kdu_error((kdu_error *)&v31);
      }
      if (*((_BYTE *)a2 + 125))
      {
        *((_DWORD *)this + 12) = -1;
      }
      else
      {
        v21 = *((_DWORD *)a2 + 44) + *((_DWORD *)a2 + 22) - *((_DWORD *)a2 + 34);
        *((_DWORD *)this + 12) = v21;
        if (v21 >= 0)
        {
          v22 = *((_QWORD *)this + 7);
          if (v22)
            MEMORY[0x18D761C18](v22, 0x1000C8077774924);
          *((_QWORD *)this + 7) = operator new[]();
          (*(void (**)(jp2_input_box *))(*(_QWORD *)a2 + 32))(a2);
          v10 = *((_DWORD *)this + 1);
          goto LABEL_56;
        }
      }
      v33 = 0;
      v31 = 0u;
      v32 = 0u;
      kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed JP2 colour description (colr) box found in JP2-family data source.");
      kdu_error::~kdu_error((kdu_error *)&v31);
    }
    if (*((_BYTE *)a2 + 125)
      || (v13 = *((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 17),
          v14 = *((unsigned int *)a2 + 44),
          v15 = v13 + v14,
          (_DWORD)v13 + (_DWORD)v14 < 0))
    {
      v33 = 0;
      v31 = 0u;
      v32 = 0u;
      kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed JP2 colour description (colr) box found in JP2-family data source.");
      kdu_error::~kdu_error((kdu_error *)&v31);
    }
    v16 = (unsigned __int8 *)operator new[]();
    if ((*(unsigned int (**)(jp2_input_box *, unsigned __int8 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v16, v15) != (_DWORD)v15)
    {
      MEMORY[0x18D761C18](v16, 0x1000C8077774924);
      v33 = 0;
      v31 = 0u;
      v32 = 0u;
      kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "JP2-family data source terminated unexpectedly inside the colour specification (colr) box.");
      kdu_error::~kdu_error((kdu_error *)&v31);
    }
    v17 = operator new();
    *(_QWORD *)v17 = 0;
    *(_QWORD *)(v17 + 8) = 0;
    *(_BYTE *)(v17 + 24) = 0;
    *(_QWORD *)(v17 + 16) = 0;
    *(_QWORD *)&v31 = 0;
    v18 = (_QWORD *)*v3;
    *v3 = v17;
    if (v18)
    {
      std::default_delete<j2_icc_profile>::operator()[abi:ne180100]((uint64_t)this + 24, v18);
      v19 = (_QWORD *)v31;
      *(_QWORD *)&v31 = 0;
      if (v19)
        std::default_delete<j2_icc_profile>::operator()[abi:ne180100]((uint64_t)&v31, v19);
    }
    j2_icc_profile::init(*((_QWORD *)this + 3), v16, v15, 1);
    v20 = *(_DWORD *)(*((_QWORD *)this + 3) + 12);
    *((_DWORD *)this + 2) = v20;
    if (HIBYTE(v35) == 2)
    {
      if (v20 == 1)
        v10 = 100;
      else
        v10 = 101;
    }
    else if (v20 == 4)
    {
      v10 = 12;
    }
    else
    {
      v10 = 102;
    }
    *((_DWORD *)this + 1) = v10;
  }
LABEL_56:
  if (v10 == 19 || v10 == 14)
  {
    v23 = 0;
    *(_QWORD *)v36 = 0;
    v37 = 0;
    v39 = 0;
    v38 = 0;
    if (v10 == 14)
      v24 = 28;
    else
      v24 = 24;
    do
    {
      if (!jp2_input_box::read(a2, &v36[v23 / 4]))
      {
        if (v23)
        {
          v33 = 0;
          v31 = 0u;
          v32 = 0u;
          kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "JP2-family data source terminated unexpectedly; unable to read all EP parameter fields for CIELab or CIEJab "
            "enumerated colour space.");
          kdu_error::~kdu_error((kdu_error *)&v31);
        }
        goto LABEL_78;
      }
      v23 += 4;
    }
    while (v24 != v23);
    v25 = 0;
    v26 = &v36[1];
    do
    {
      v27 = (unsigned int *)((char *)this + v25 + 76);
      *(v27 - 3) = *(v26 - 1);
      v28 = *v26;
      v26 += 2;
      *v27 = v28;
      v25 += 4;
    }
    while (v25 != 12);
    if (*((_DWORD *)this + 1) == 14)
    {
      v29 = v39;
      *((_DWORD *)this + 22) = v39;
      if ((~v29 & 0x43540000) == 0)
      {
        *((_WORD *)this + 46) = v29;
        *((_DWORD *)this + 22) = 1129578496;
        goto LABEL_78;
      }
      switch(v29)
      {
        case 4470581:
          v30 = 7500;
          goto LABEL_76;
        case 4470325:
          v30 = 6500;
          goto LABEL_76;
        case 4470064:
          v30 = 5000;
LABEL_76:
          *((_WORD *)this + 46) = v30;
          goto LABEL_78;
      }
      *((_WORD *)this + 46) = 0;
    }
  }
LABEL_78:
  *(_BYTE *)this = 1;
  result = (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
  if ((result & 1) == 0)
  {
    v33 = 0;
    v31 = 0u;
    v32 = 0u;
    kdu_error::kdu_error((kdu_error *)&v31, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Malformed JP2 colour description (colr) box found in JP2-family data source.  The box appears to be too large.");
    kdu_error::~kdu_error((kdu_error *)&v31);
  }
  return result;
}

void sub_187F25FA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F25FB0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

int32x2_t j2_colour::finalize(j2_colour *this, j2_channels *a2)
{
  int v4;
  int *v5;
  int32x2_t result;
  int v7;
  uint64_t v10;
  char *v11;
  int bit_depth;
  int v13;
  int v14;
  int v16;
  _OWORD v17[2];
  uint64_t v18;

  if (*(_BYTE *)this)
  {
    v5 = (int *)((char *)this + 8);
    v4 = *((_DWORD *)this + 2);
    if (!v4)
    {
      if (!a2)
        jp2_channels::get_num_colours();
      v4 = *((_DWORD *)a2 + 1);
      *v5 = v4;
    }
  }
  else
  {
    *(_BYTE *)this = 1;
    v5 = (int *)((char *)this + 8);
    result = (int32x2_t)0x40000000CLL;
    *(_QWORD *)((char *)this + 4) = 0x40000000CLL;
    v4 = 4;
  }
  v7 = *((_DWORD *)this + 1);
  if ((v7 == 19 || v7 == 14) && v4 >= 1)
  {
    v10 = 0;
    v11 = (char *)this + 12;
    do
    {
      bit_depth = j2_channels::get_bit_depth(a2, v10);
      v13 = *(_DWORD *)&v11[4 * v10];
      if (v13 < 0)
      {
        *(_DWORD *)&v11[4 * v10] = bit_depth;
      }
      else if (v13 != bit_depth)
      {
        v14 = *((_DWORD *)this + 1);
        if (v14 != 14 && v14 != 19)
          j2_colour::finalize();
        v18 = 0;
        memset(v17, 0, sizeof(v17));
        kdu_error::kdu_error((kdu_error *)v17, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)v17);
      }
      ++v10;
    }
    while (v10 < *v5);
    v7 = *((_DWORD *)this + 1);
  }
  if (v7 == 19)
  {
    if (*((int *)this + 16) <= 0)
    {
      *((_OWORD *)this + 4) = xmmword_18820CDF0;
      result = vshr_n_s32((int32x2_t)vshl_u32((uint32x2_t)0x100000001, *(uint32x2_t *)((char *)this + 16)), 1uLL);
      *((int32x2_t *)this + 10) = result;
    }
  }
  else if (v7 == 14)
  {
    if (*((int *)this + 16) <= 0)
    {
      result = (int32x2_t)0xAA00000064;
      *((_OWORD *)this + 4) = xmmword_18820CE00;
      v16 = (1 << *((_DWORD *)this + 5) >> 2) + (1 << *((_DWORD *)this + 5) >> 3);
      *((_DWORD *)this + 20) = 1 << *((_DWORD *)this + 4) >> 1;
      *((_DWORD *)this + 21) = v16;
    }
    if (!*((_DWORD *)this + 22) && !*((_WORD *)this + 46))
      *((_DWORD *)this + 22) = 4470064;
  }
  return result;
}

void sub_187F26204(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F26210()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t j2_channels::get_bit_depth(j2_channels *this, unsigned int a2)
{
  _DWORD *exception;

  if (*((_DWORD *)this + 1) <= a2)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  return *(unsigned int *)(*((_QWORD *)this + 1) + ((uint64_t)(int)a2 << 6) + 56);
}

uint64_t j2_colour::save_box(j2_colour *this, jp2_output_box *a2)
{
  int v3;
  int v4;
  uint64_t v5;
  _DWORD *v6;
  int v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  void (**v13)(jp2_output_box *__hidden);
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  unsigned __int8 v19[4];
  unsigned __int8 __ptr[8];
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)this)
    j2_colour::save_box();
  v14 = 0u;
  v13 = &off_1E1BB0038;
  v18 = 0;
  v15 = 0uLL;
  v16 = 0uLL;
  v17 = 0xFFFFFFFFFFFFFFFFLL;
  jp2_output_box::open((uint64_t)&v13, a2, 1668246642, 0);
  v3 = *((_DWORD *)this + 1);
  if ((v3 - 100) < 2)
  {
    __ptr[0] = 2;
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    __ptr[0] = *((_DWORD *)this + 24);
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    __ptr[0] = *((_BYTE *)this + 100);
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    jp2_output_box::write((jp2_output_box *)&v13, **((const unsigned __int8 ***)this + 3), *(unsigned int *)(*((_QWORD *)this + 3) + 8));
  }
  else if (v3 == 102)
  {
    __ptr[0] = 3;
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    __ptr[0] = *((_DWORD *)this + 24);
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    __ptr[0] = *((_BYTE *)this + 100);
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    jp2_output_box::write((jp2_output_box *)&v13, **((const unsigned __int8 ***)this + 3), *(unsigned int *)(*((_QWORD *)this + 3) + 8));
  }
  else if (v3 == 200)
  {
    __ptr[0] = 4;
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    __ptr[0] = *((_DWORD *)this + 24);
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    __ptr[0] = *((_BYTE *)this + 100);
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    jp2_output_box::write((jp2_output_box *)&v13, (const unsigned __int8 *)this + 32, 0x10uLL);
    jp2_output_box::write((jp2_output_box *)&v13, *((const unsigned __int8 **)this + 7), *((unsigned int *)this + 12));
  }
  else
  {
    __ptr[0] = 1;
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    __ptr[0] = *((_DWORD *)this + 24);
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    __ptr[0] = *((_BYTE *)this + 100);
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 1uLL);
    *(_DWORD *)__ptr = bswap32(*((_DWORD *)this + 1));
    ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, __ptr, 4uLL);
    v4 = *((_DWORD *)this + 1);
    if (v4 == 19 || v4 == 14)
    {
      v5 = 0;
      *(_QWORD *)__ptr = 0;
      v21 = 0;
      v23 = 0;
      v6 = (_DWORD *)((char *)this + 64);
      v22 = 0;
      do
      {
        if ((*(v6 - 13) & 0x80000000) != 0 || (v7 = v6[3], v7 < 0) || (*v6 & 0x80000000) != 0)
          __assert_rtn("save_box", "jp2.cpp", 4873, "(precision[c]>=0) && (offset[c]>=0) && (range[c]>=0)");
        v8 = &__ptr[v5];
        *(_DWORD *)v8 = *v6;
        *((_DWORD *)v8 + 1) = v7;
        v5 += 8;
        ++v6;
      }
      while (v5 != 24);
      if (v4 == 14)
      {
        v23 = *((_DWORD *)this + 22);
        if (v23 == 1129578496)
          v23 = *((unsigned __int16 *)this + 46) | 0x43540000;
        v9 = 7;
      }
      else
      {
        v9 = 6;
      }
      v10 = 0;
      v11 = 4 * v9;
      do
      {
        *(_DWORD *)v19 = bswap32(*(_DWORD *)&__ptr[v10]);
        ((void (*)(jp2_output_box *, const unsigned __int8 *, size_t))v13[5])((jp2_output_box *)&v13, v19, 4uLL);
        v10 += 4;
      }
      while (v11 != v10);
    }
  }
  jp2_output_box::close((jp2_output_box *)&v13);
  v13 = &off_1E1BB0038;
  result = *((_QWORD *)&v17 + 1);
  if (*((_QWORD *)&v17 + 1))
    return MEMORY[0x18D761C18](*((_QWORD *)&v17 + 1), 0x1000C8077774924);
  return result;
}

void sub_187F2664C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17)
    MEMORY[0x18D761C18](a17, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

BOOL j2_colour::is_jp2_compatible(j2_colour *this)
{
  int v1;
  unsigned int v2;
  _BOOL4 v3;

  if (!*(_BYTE *)this)
    return 0;
  v1 = *((_DWORD *)this + 1);
  v2 = v1 - 16;
  v3 = (v1 - 100) < 2;
  return v2 < 3 || v3;
}

uint64_t *jp2_colour::init(uint64_t *result, int a2)
{
  uint64_t v2;
  uint64_t i;
  int v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v2 = *result;
  if (!*result)
    jp2_colour::init();
  if (*(_BYTE *)v2)
  {
    v7 = 0;
    v5 = 0u;
    v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  *(_QWORD *)(v2 + 64) = -1;
  *(_DWORD *)(v2 + 72) = -1;
  for (i = 76; i != 88; i += 4)
    *(_DWORD *)(v2 + i) = -1;
  *(_DWORD *)(v2 + 88) = 0;
  *(_WORD *)(v2 + 92) = 0;
  *(_DWORD *)(v2 + 4) = a2;
  switch(a2)
  {
    case 0:
    case 15:
    case 17:
      v4 = 1;
      break;
    case 1:
    case 3:
    case 4:
    case 9:
    case 11:
    case 14:
    case 16:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
      v4 = 3;
      break;
    case 12:
    case 13:
      v4 = 4;
      break;
    default:
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)&v5);
  }
  *(_DWORD *)(v2 + 8) = v4;
  *(_BYTE *)v2 = 1;
  return result;
}

void sub_187F267FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F26808()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

unsigned __int8 *jp2_colour::init(jp2_colour *this, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t *v6;
  j2_icc_profile *v7;
  _BOOL4 is_restricted;
  uint64_t v9;
  int v10;
  unsigned __int8 *result;
  unsigned __int8 *v12[2];
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  if (!*(_QWORD *)this)
    jp2_colour::init();
  if (**(_BYTE **)this)
  {
    *(_QWORD *)&v14 = 0;
    *(_OWORD *)v12 = 0u;
    v13 = 0u;
    kdu_error::kdu_error((kdu_error *)v12, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v12);
  }
  v15 = 0;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)v12 = 0u;
  j2_icc_profile::init((uint64_t)v12, a2, a3, 0);
  v4 = operator new();
  *(_QWORD *)v4 = 0;
  *(_QWORD *)(v4 + 8) = 0;
  *(_BYTE *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  v6 = (uint64_t *)(*(_QWORD *)this + 24);
  v5 = (_QWORD *)*v6;
  *v6 = v4;
  if (v5)
    std::default_delete<j2_icc_profile>::operator()[abi:ne180100]((uint64_t)v6, v5);
  j2_icc_profile::init(*(_QWORD *)(*(_QWORD *)this + 24), v12[0], v12[1], 0);
  v7 = *(j2_icc_profile **)(*(_QWORD *)this + 24);
  *(_DWORD *)(*(_QWORD *)this + 8) = *((_DWORD *)v7 + 3);
  is_restricted = j2_icc_profile::is_restricted(v7);
  v9 = *(_QWORD *)this;
  if (is_restricted)
  {
    if (*(_DWORD *)(v9 + 8) == 1)
      v10 = 100;
    else
      v10 = 101;
  }
  else
  {
    v10 = 102;
  }
  *(_DWORD *)(v9 + 4) = v10;
  *(_BYTE *)v9 = 1;
  result = v12[0];
  if (v12[0])
    return (unsigned __int8 *)MEMORY[0x18D761C18](v12[0], 0x1000C8077774924);
  return result;
}

void sub_187F2697C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F26988(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  _Unwind_Exception *v9;

  _Unwind_Resume(v9);
}

BOOL j2_icc_profile::is_restricted(j2_icc_profile *this)
{
  return *((_BYTE *)this + 20)
      && (*((_DWORD *)this + 3) | 2) == 3
      && (*((_BYTE *)this + 21) || *((_BYTE *)this + 22))
      && *((_BYTE *)this + 24) == 0;
}

double *find_monitor_matrix(double *result, double *a2, double *a3, const double *a4, double *a5)
{
  uint64_t v5;
  char v6;
  double v7;
  char v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double *v16;
  double v17;
  double v18;
  uint64_t v19;
  double v20;
  double v21[3];
  double v22[3];
  double v23[3];
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  uint64_t v30;

  v5 = 0;
  v30 = *MEMORY[0x1E0C80C00];
  v28 = 0.0;
  v29 = 0.0;
  v26 = 0.0;
  v27 = 0.0;
  v24 = 0.0;
  v25 = 0.0;
  v6 = 1;
  do
  {
    v7 = a3[v5];
    *(&v28 + v5) = result[v5] - v7;
    *(&v26 + v5) = a2[v5] - v7;
    v8 = v6;
    *(&v24 + v5) = a4[v5] - v7;
    v5 = 1;
    v6 = 0;
  }
  while ((v8 & 1) != 0);
  v9 = 0;
  v10 = v28 * v27 - v26 * v29;
  v11 = (v27 * v24 - v26 * v25) / v10;
  v12 = (v28 * v25 - v29 * v24) / v10;
  v13 = result[1];
  v23[0] = *result;
  v23[1] = v13;
  v23[2] = 1.0 - v23[0] - v13;
  v14 = a2[1];
  v22[0] = *a2;
  v22[1] = v14;
  v22[2] = 1.0 - v22[0] - v14;
  v15 = a3[1];
  v21[0] = *a3;
  v21[1] = v15;
  v21[2] = 1.0 - v21[0] - v15;
  v16 = a5 + 1;
  do
  {
    v17 = v12 * v22[v9];
    v18 = (1.0 - v11 - v12) * v21[v9];
    *(v16 - 1) = v11 * v23[v9];
    *v16 = v17;
    v16[1] = v18;
    v16 += 3;
    ++v9;
  }
  while (v9 != 3);
  v19 = 0;
  v20 = 1.0 / a4[1];
  do
  {
    a5[v19] = v20 * a5[v19];
    ++v19;
  }
  while (v19 != 9);
  return result;
}

uint64_t find_matrix_inverse(double *a1, const double *a2, double *a3, double *a4)
{
  uint64_t i;
  uint64_t v5;
  int j;
  int v7;
  double v8;
  unint64_t v9;
  double *v10;
  double *v11;
  uint64_t v12;
  double *v13;
  double *v14;
  double *v15;
  double v16;
  double *v17;
  unint64_t v18;
  int v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  double *v24;
  double v25;
  uint64_t v26;
  double *v27;
  double v28;
  double *v29;
  double *v30;
  uint64_t v31;
  uint64_t v32;
  double v33;
  uint64_t k;
  double *v35;
  double *v36;
  double *v37;
  double *v38;
  unint64_t v39;
  double *v40;
  double *v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t result;
  double v46;
  uint64_t m;

  for (i = 0; i != 9; ++i)
    a3[i] = a2[i];
  LODWORD(v5) = 0;
  for (j = 0; j != 3; ++j)
  {
    v7 = 0;
    v5 = (int)v5;
    do
    {
      if (j == v7)
        v8 = 1.0;
      else
        v8 = 0.0;
      a1[v5] = v8;
      ++v7;
      ++v5;
    }
    while (v7 != 3);
  }
  v9 = 0;
  v10 = a3 + 3;
  v11 = a1 + 3;
  v12 = 1;
  v13 = a1;
  v14 = a3;
  v15 = a3;
  do
  {
    v16 = a3[4 * v9];
    if (v16 < 0.0)
      v16 = -v16;
    v17 = v15;
    v18 = v9;
    v19 = v9;
    do
    {
      v20 = *v17;
      if (*v17 <= v16)
      {
        if (v20 < -v16)
        {
          v16 = -v20;
          v19 = v18;
        }
      }
      else
      {
        v19 = v18;
        v16 = *v17;
      }
      ++v18;
      v17 += 3;
    }
    while (v18 != 3);
    v21 = 0;
    v22 = 3 * v19;
    v23 = 1.0 / a3[v9 + v22];
    v24 = &a3[v22];
    do
    {
      v25 = v14[v21];
      v14[v21] = v23 * v24[v21];
      v24[v21++] = v23 * v25;
    }
    while (v21 != 3);
    v26 = 0;
    v27 = &a1[v22];
    do
    {
      v28 = v13[v26];
      v13[v26] = v23 * v27[v26];
      v27[v26++] = v23 * v28;
    }
    while (v26 != 3);
    if (v9 <= 1)
    {
      v29 = v11;
      v30 = v10;
      v31 = v12;
      do
      {
        v32 = 0;
        v33 = -a3[3 * v31 + v9];
        do
        {
          v30[v32] = v30[v32] + v33 * v14[v32];
          ++v32;
        }
        while (v32 != 3);
        for (k = 0; k != 3; ++k)
          v29[k] = v29[k] + v33 * v13[k];
        ++v31;
        v30 += 3;
        v29 += 3;
      }
      while (v31 != 3);
    }
    ++v9;
    ++v12;
    v15 += 4;
    v14 += 3;
    v13 += 3;
    v10 += 3;
    v11 += 3;
  }
  while (v9 != 3);
  v35 = a3 + 3;
  v36 = a3 + 6;
  v37 = a1 + 3;
  v38 = a1 + 6;
  v39 = 2;
  do
  {
    v40 = v37;
    v41 = v35;
    v42 = v39;
    do
    {
      v43 = 0;
      v44 = v42--;
      result = (3 * v42 + v39);
      v46 = -a3[result];
      do
      {
        v41[v43] = v41[v43] + v46 * v36[v43];
        ++v43;
      }
      while (v43 != 3);
      for (m = 0; m != 3; ++m)
        v40[m] = v40[m] + v46 * v38[m];
      v41 -= 3;
      v40 -= 3;
    }
    while (v44 >= 2);
    v35 -= 3;
    v36 -= 3;
    v37 -= 3;
    v38 -= 3;
  }
  while (v39-- > 1);
  return result;
}

uint64_t jp2_colour::get_num_colours(jp2_colour *this)
{
  if (!*(_QWORD *)this)
    jp2_colour::get_num_colours();
  return *(unsigned int *)(*(_QWORD *)this + 8);
}

uint64_t jp2_colour::get_space(jp2_colour *this)
{
  if (!*(_QWORD *)this)
    jp2_colour::get_space();
  return *(unsigned int *)(*(_QWORD *)this + 4);
}

uint64_t jp2_colour::is_opponent_space(jp2_colour *this)
{
  if (!*(_QWORD *)this)
    jp2_colour::is_opponent_space();
  return (*(_DWORD *)(*(_QWORD *)this + 4) < 0x19u) & (0x1CC621Au >> *(_DWORD *)(*(_QWORD *)this + 4));
}

uint64_t jp2_colour::get_precedence(jp2_colour *this)
{
  if (!*(_QWORD *)this)
    jp2_colour::get_precedence();
  return *(unsigned int *)(*(_QWORD *)this + 96);
}

uint64_t jp2_colour::get_icc_profile(jp2_colour *this, int *a2)
{
  _DWORD *v2;

  if (!*(_QWORD *)this)
    return 0;
  v2 = *(_DWORD **)(*(_QWORD *)this + 24);
  if (!v2)
    return 0;
  if (a2)
    *a2 = v2[2];
  return *(_QWORD *)v2;
}

void j2_colour_converter::j2_colour_converter(j2_colour_converter *this, j2_colour *a2, int a3, int a4)
{
  int v4;
  int v5;
  int v6;
  char *v10;
  uint64_t v11;
  double *v12;
  int v13;
  int i;
  int v15;
  float *v16;
  float v17;
  int v18;
  double *v19;
  double *v20;
  double *v21;
  char *v22;
  void *v23;
  const void *v24;
  char *v25;
  _OWORD *v26;
  double *v27;
  uint64_t j;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  double v32;
  double *v33;
  double v34;
  uint64_t v35;
  _OWORD *v36;
  uint64_t v37;
  _OWORD *v38;
  uint64_t v39;
  double v40;
  double *v41;
  double v42;
  uint64_t k;
  float v44;
  uint64_t v45;
  uint64_t m;
  uint64_t n;
  uint64_t ii;
  _OWORD v49[4];
  uint64_t v50;
  _OWORD v51[4];
  uint64_t v52;
  _OWORD v53[4];
  uint64_t v54;
  _OWORD v55[4];
  uint64_t v56;
  _OWORD v57[4];
  uint64_t v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)this = a3;
  if (a3)
    v4 = 14;
  else
    v4 = 13;
  *((_DWORD *)this + 1) = v4;
  v5 = *((_DWORD *)a2 + 2);
  if (v5 < 3)
    v6 = 1;
  else
    v6 = 3;
  *((_DWORD *)this + 2) = v6;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_BYTE *)this + 12) = 0;
  *((_BYTE *)this + 15) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 29) = 0;
  if (v5 <= 0)
    j2_colour_converter::j2_colour_converter();
  *(_WORD *)((char *)this + 13) = 1;
  *((_BYTE *)this + 112) = 1;
  *((_BYTE *)this + 144) = 1;
  v10 = (char *)this + 16;
  bzero((char *)this + 16, (4 * v6));
  v13 = 0;
  for (i = 0; i != v6; ++i)
  {
    v15 = 0;
    v16 = (float *)((char *)this + 4 * v13 + 148);
    v13 += v6;
    do
    {
      if (i == v15)
        v17 = 1.0;
      else
        v17 = 0.0;
      *v16 = v17;
      *(v16 - 27) = v17;
      ++v15;
      ++v16;
    }
    while (v6 != v15);
  }
  v18 = *((_DWORD *)a2 + 1);
  switch(v18)
  {
    case 0:
      *(_BYTE *)this = 0;
      *((_DWORD *)this + 1) = 13;
      v22 = (char *)operator new[]();
      *((_QWORD *)this + 29) = v22;
      memset_pattern16(v22, &unk_18820CF00, 0x2000uLL);
      v23 = v22 + 0x2000;
      v24 = &unk_18820CF10;
      goto LABEL_36;
    case 1:
      *((_QWORD *)this + 2) = 0x800000003C200000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18820CE70;
      *(_OWORD *)((char *)this + 56) = xmmword_18820CE80;
      *((_DWORD *)this + 18) = -1085214827;
      *((_BYTE *)this + 13) = 0;
      if (!a4)
        goto LABEL_28;
      goto LABEL_26;
    case 2:
    case 5:
    case 6:
    case 7:
    case 8:
    case 10:
    case 19:
      goto LABEL_34;
    case 3:
      *((_QWORD *)this + 2) = 0x8000000000000000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18820CE10;
      *(_OWORD *)((char *)this + 56) = xmmword_18820CE20;
      *((_DWORD *)this + 18) = -1086926429;
      *(_WORD *)((char *)this + 13) = 256;
      if (a4)
        goto LABEL_24;
      goto LABEL_58;
    case 4:
      *((_QWORD *)this + 2) = 0x800000003C200000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18820CE70;
      *(_OWORD *)((char *)this + 56) = xmmword_18820CE80;
      *((_DWORD *)this + 18) = -1085214827;
      *((_BYTE *)this + 13) = 0;
      if (a4)
      {
LABEL_26:
        *((_BYTE *)this + 12) = 1;
        *((_BYTE *)this + 14) = 1;
        goto LABEL_60;
      }
LABEL_58:
      v19 = (double *)&xy_601_red;
      v20 = (double *)&xy_601_green;
      v21 = (double *)&xy_601_blue;
      goto LABEL_59;
    case 9:
      *((_QWORD *)this + 2) = 0xBDE00D1B3E12CA58;
      *((_DWORD *)this + 6) = -1123013152;
      *(_OWORD *)((char *)this + 40) = xmmword_18820CE50;
      *(_OWORD *)((char *)this + 56) = xmmword_18820CE60;
      *((_DWORD *)this + 18) = -1082777844;
      *((_BYTE *)this + 13) = 0;
LABEL_28:
      v19 = xy_709_red;
      v20 = xy_709_green;
      v21 = xy_709_blue;
      goto LABEL_59;
    case 11:
      *((_DWORD *)this + 10) = -1082130432;
      *((_DWORD *)this + 14) = -1082130432;
      *((_DWORD *)this + 18) = -1082130432;
      goto LABEL_32;
    case 12:
      *((_BYTE *)this + 15) = 1;
      goto LABEL_60;
    case 13:
      *((_QWORD *)this + 2) = 0x8000000000000000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18820CE10;
      *(_OWORD *)((char *)this + 56) = xmmword_18820CE20;
      *((_DWORD *)this + 18) = -1086926429;
      *((_BYTE *)this + 14) = 1;
LABEL_32:
      *((_WORD *)this + 6) = 1;
      goto LABEL_60;
    case 14:
      if ((j2_colour_converter::configure_lab_transform(this, a2, v11, v12) & 1) == 0)
        goto LABEL_34;
      goto LABEL_60;
    case 15:
      *(_BYTE *)this = 0;
      *((_DWORD *)this + 1) = 13;
      v25 = (char *)operator new[]();
      *((_QWORD *)this + 29) = v25;
      memset_pattern16(v25, &unk_18820CF10, 0x2000uLL);
      v23 = v25 + 0x2000;
      v24 = &unk_18820CF00;
LABEL_36:
      memset_pattern16(v23, v24, 0x2000uLL);
      goto LABEL_60;
    case 16:
    case 17:
      goto LABEL_60;
    case 18:
      *((_QWORD *)this + 2) = 0x8000000000000000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18820CE10;
      *(_OWORD *)((char *)this + 56) = xmmword_18820CE20;
      *((_DWORD *)this + 18) = -1086926429;
      *(_WORD *)((char *)this + 13) = 256;
      goto LABEL_60;
    case 20:
      memset_pattern16(v10, &unk_18820CEF0, 0xCuLL);
      *((_DWORD *)this + 10) = 0x40000000;
      *((_DWORD *)this + 14) = 0x40000000;
      *((_DWORD *)this + 18) = 0x40000000;
      *((_BYTE *)this + 13) = 0;
      goto LABEL_60;
    case 21:
      j2_colour_converter::configure_d65_primary_transform(this, dbl_18820CEC0, dbl_18820CED0, dbl_18820CEE0, 1.8, 0.0);
      if (*((_BYTE *)this + 144))
        j2_colour_converter::j2_colour_converter();
      v58 = 0;
      memset(v57, 0, sizeof(v57));
      v56 = 0;
      memset(v55, 0, sizeof(v55));
      v54 = 0;
      memset(v53, 0, sizeof(v53));
      v52 = 0;
      memset(v51, 0, sizeof(v51));
      v50 = 0;
      memset(v49, 0, sizeof(v49));
      find_monitor_matrix(xy_709_red, xy_709_green, xy_709_blue, xy_D65_white, (double *)v57);
      find_monitor_matrix(dbl_18820CEC0, dbl_18820CED0, dbl_18820CEE0, xy_D50_white, (double *)v55);
      v26 = v53;
      find_matrix_inverse((double *)v53, (const double *)v57, (double *)v51, v27);
      for (j = 0; j != 3; ++j)
      {
        v29 = 0;
        v30 = &icc_xyzD50_to_xyzD65;
        do
        {
          v31 = 0;
          v32 = 0.0;
          v33 = (double *)v30;
          do
          {
            v34 = *v33;
            v33 += 3;
            v32 = v32 + *(double *)((char *)v26 + v31) * v34;
            v31 += 8;
          }
          while (v31 != 24);
          *((double *)v51 + 3 * j + v29++) = v32;
          ++v30;
        }
        while (v29 != 3);
        v26 = (_OWORD *)((char *)v26 + 24);
      }
      v35 = 0;
      v36 = v51;
      do
      {
        v37 = 0;
        v38 = v55;
        do
        {
          v39 = 0;
          v40 = 0.0;
          v41 = (double *)v38;
          do
          {
            v42 = *v41;
            v41 += 3;
            v40 = v40 + *(double *)((char *)v36 + v39) * v42;
            v39 += 8;
          }
          while (v39 != 24);
          *((double *)v49 + 3 * v35 + v37++) = v40;
          v38 = (_OWORD *)((char *)v38 + 8);
        }
        while (v37 != 3);
        ++v35;
        v36 = (_OWORD *)((char *)v36 + 24);
      }
      while (v35 != 3);
      for (k = 0; k != 9; ++k)
      {
        v44 = *((double *)v49 + k);
        *((float *)this + k + 37) = v44;
      }
      goto LABEL_60;
    case 22:
    case 23:
      *((_QWORD *)this + 2) = 0x800000003C200000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18820CE30;
      *(_OWORD *)((char *)this + 56) = xmmword_18820CE40;
      *((_DWORD *)this + 18) = -1089766529;
      *((_BYTE *)this + 13) = 0;
      if (a4)
      {
LABEL_24:
        *((_BYTE *)this + 12) = 1;
      }
      else
      {
        v19 = (double *)&xy_240m_red;
        v20 = (double *)&xy_240m_green;
        v21 = (double *)&xy_240m_blue;
LABEL_59:
        j2_colour_converter::configure_d65_primary_transform(this, v19, v20, v21, 2.22222222, 0.099);
      }
LABEL_60:
      if (*((_DWORD *)this + 2) == 3)
      {
        for (m = 0; m != 12; m += 4)
          *(_DWORD *)((char *)this + m + 28) = vcvtmd_s64_f64((float)(*(float *)((char *)this + m + 16) * 8192.0) + 0.5);
        for (n = 0; n != 36; n += 4)
          *(_DWORD *)((char *)this + n + 76) = vcvtmd_s64_f64((float)(*(float *)((char *)this + n + 40) * 4096.0) + 0.5);
        for (ii = 0; ii != 36; ii += 4)
          *(_DWORD *)((char *)this + ii + 184) = vcvtmd_s64_f64((float)(*(float *)((char *)this + ii + 148) * 4096.0) + 0.5);
      }
      return;
    case 24:
      v45 = 0;
      *((_QWORD *)this + 2) = 0x8000000000000000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18820CE10;
      *(_OWORD *)((char *)this + 56) = xmmword_18820CE20;
      *((_DWORD *)this + 18) = -1086926429;
      *((_BYTE *)this + 13) = 0;
      do
      {
        *(float32x2_t *)((char *)this + v45 + 44) = vadd_f32(*(float32x2_t *)((char *)this + v45 + 44), *(float32x2_t *)((char *)this + v45 + 44));
        v45 += 12;
      }
      while (v45 != 36);
      goto LABEL_60;
    default:
      if ((v18 - 100) < 3)
        goto LABEL_60;
LABEL_34:
      *((_DWORD *)this + 2) = 0;
      return;
  }
}

void j2_colour_converter::configure_d65_primary_transform(j2_colour_converter *this, double *a2, double *a3, double *a4, double a5, double a6)
{
  _OWORD *v11;
  double *v12;
  uint64_t i;
  uint64_t v14;
  _OWORD *v15;
  uint64_t v16;
  double v17;
  double *v18;
  double v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  char *v24;
  char *v25;
  double v26;
  float v27;
  double v28;
  double v29;
  int v30;
  uint64_t v31;
  double v32;
  double v33;
  uint64_t v34;
  int v35;
  double v36;
  double v37;
  double v38;
  double v39;
  int v40;
  char *v41;
  int v42;
  double v43;
  _OWORD v45[4];
  uint64_t v46;
  _OWORD v47[4];
  uint64_t v48;
  _OWORD v49[4];
  uint64_t v50;
  _OWORD v51[4];
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v52 = 0;
  memset(v51, 0, sizeof(v51));
  v50 = 0;
  memset(v49, 0, sizeof(v49));
  v48 = 0;
  memset(v47, 0, sizeof(v47));
  v46 = 0;
  memset(v45, 0, sizeof(v45));
  find_monitor_matrix(xy_709_red, xy_709_green, xy_709_blue, xy_D65_white, (double *)v51);
  find_monitor_matrix(a2, a3, a4, xy_D65_white, (double *)v49);
  v11 = v47;
  find_matrix_inverse((double *)v47, (const double *)v51, (double *)v45, v12);
  for (i = 0; i != 3; ++i)
  {
    v14 = 0;
    v15 = v49;
    do
    {
      v16 = 0;
      v17 = 0.0;
      v18 = (double *)v15;
      do
      {
        v19 = *v18;
        v18 += 3;
        v17 = v17 + *(double *)((char *)v11 + v16) * v19;
        v16 += 8;
      }
      while (v16 != 24);
      *((double *)v45 + 3 * i + v14++) = v17;
      v15 = (_OWORD *)((char *)v15 + 8);
    }
    while (v14 != 3);
    v11 = (_OWORD *)((char *)v11 + 24);
  }
  v20 = 0;
  v21 = 0;
  *((_BYTE *)this + 144) = 1;
  do
  {
    v22 = 0;
    v23 = v21;
    v24 = (char *)v45 + 8 * v21;
    v25 = (char *)this + 4 * v21 + 148;
    do
    {
      v26 = *(double *)&v24[8 * v22];
      v27 = v26;
      *(float *)&v25[4 * v22] = v27;
      if (v20 == (_DWORD)v22)
        v28 = 1.0;
      else
        v28 = 0.0;
      v29 = v28 - v26;
      if (v29 < -0.01 || v29 > 0.01)
        *((_BYTE *)this + 144) = 0;
      ++v22;
    }
    while ((_DWORD)v22 != 3);
    ++v20;
    v21 = v23 + 3;
  }
  while (v20 != 3);
  if (*((_QWORD *)this + 28) || *((_QWORD *)this + 15) || *((_QWORD *)this + 16) || *((_QWORD *)this + 17))
    j2_colour_converter::configure_d65_primary_transform();
  v30 = *((_DWORD *)this + 1);
  LODWORD(v31) = 1 << v30;
  *((_QWORD *)this + 15) = operator new[]();
  if (!*((_BYTE *)this + 144))
    *((_QWORD *)this + 28) = operator new[]();
  v32 = 1.0 / a5;
  if (1.0 / a5 >= 1.0)
    j2_colour_converter::configure_d65_primary_transform();
  v33 = v32 * a6 / (1.0 - v32);
  v43 = 0.0;
  if (v33 > 0.0)
    v43 = pow(v33 / (v32 * (a6 + 1.0)), 1.0 / v32) / v33;
  if (v30 != 31)
  {
    v34 = 0;
    v35 = *((unsigned __int8 *)this + 144);
    if ((int)v31 <= 1)
      v31 = 1;
    else
      v31 = v31;
    v36 = 1.0 / v32;
    do
    {
      v37 = (double)(int)v34 / 8191.0;
      if (v37 >= v33)
      {
        v38 = pow((v37 + a6) / (a6 + 1.0), v36);
        if (!v35)
        {
LABEL_36:
          v40 = vcvtmd_s64_f64(v38 * 8191.0 + 0.5);
          if (v40 <= -32768)
            v40 = -32768;
          if (v40 >= 0x7FFF)
            LOWORD(v40) = 0x7FFF;
          *(_WORD *)(*((_QWORD *)this + 15) + 2 * v34) = v40;
          if (v37 <= 0.00303993464)
            v39 = v37 * 12.9232102;
          else
            v39 = pow((double)(int)v34 / 8191.0, 0.416666667) * 1.055 + -0.055;
          v41 = (char *)this + 224;
          goto LABEL_46;
        }
      }
      else
      {
        v38 = v43 * v37;
        if (!v35)
          goto LABEL_36;
      }
      if (v38 <= 0.00303993464)
        v39 = v38 * 12.9232102;
      else
        v39 = pow(v38, 0.416666667) * 1.055 + -0.055;
      v41 = (char *)this + 120;
LABEL_46:
      v42 = vcvtmd_s64_f64((v39 + -0.5) * 8191.0 + 0.5);
      if (v42 <= -32768)
        v42 = -32768;
      if (v42 >= 0x7FFF)
        LOWORD(v42) = 0x7FFF;
      *(_WORD *)(*(_QWORD *)v41 + 2 * v34++) = v42;
    }
    while (v31 != v34);
  }
  *((_BYTE *)this + 112) = 0;
}

uint64_t j2_colour_converter::configure_lab_transform(j2_colour_converter *this, j2_colour *a2, uint64_t a3, double *a4)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  float v13;
  uint64_t i;
  float v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  double v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  double v29;
  int v30;
  double *v31;
  uint64_t v32;
  _OWORD *v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  double v37;
  double *v38;
  double v39;
  uint64_t k;
  double *v41;
  uint64_t j;
  uint64_t v44;
  double *v45;
  uint64_t m;
  float v47;
  _OWORD v48[4];
  _QWORD v49[2];
  _OWORD v50[4];
  uint64_t v51;
  _OWORD v52[4];
  uint64_t v53;
  _OWORD v54[4];
  uint64_t v55;
  _OWORD v56[4];
  uint64_t v57;
  double v58[3];
  float64x2_t v59;
  uint64_t v60;
  uint64_t v61;
  float64x2_t v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)a2 + 1) != 14)
    return 0;
  v5 = *((_DWORD *)a2 + 22);
  switch(v5)
  {
    case 4470064:
      v6 = 5000;
      break;
    case 1129578496:
      v6 = *((unsigned __int16 *)a2 + 46);
      if (v6 != 6500 && v6 != 5000)
        return 0;
      break;
    case 4470325:
      v6 = 6500;
      break;
    default:
      return 0;
  }
  v7 = *((_DWORD *)a2 + 16);
  if (v7 < 1)
    return 0;
  v8 = *((_DWORD *)a2 + 17);
  if (v8 < 1)
    return 0;
  v9 = *((_DWORD *)a2 + 18);
  if (v9 < 1 || *((int *)a2 + 3) < 1 || *((int *)a2 + 4) < 1 || *((int *)a2 + 5) < 1)
    return 0;
  v10 = 0;
  *((_BYTE *)this + 144) = 0;
  *((_BYTE *)this + 112) = 0;
  *((_BYTE *)this + 13) = 0;
  do
  {
    *(float *)((char *)this + v10 + 16) = 0.5
                                        - (float)((float)*(int *)((char *)a2 + v10 + 76)
                                                / (float)~(-1 << *(_DWORD *)((char *)a2 + v10 + 12)));
    v10 += 4;
  }
  while (v10 != 12);
  v11 = 0;
  v58[0] = 0.0;
  v58[1] = 100.0 / (double)v7;
  v59 = vdivq_f64((float64x2_t)xmmword_18820CE90, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v8), 0));
  v60 = 0;
  v61 = 0;
  v58[2] = 0.0;
  v62 = vdivq_f64((float64x2_t)xmmword_18820CEA0, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v9), 0));
  v12 = (float *)((char *)this + 16);
  do
  {
    v13 = v58[v11] + v58[v11 + 1] + v58[v11 + 2];
    *v12 = *v12 + (float)(v13 * -0.5);
    ++v12;
    v11 += 3;
  }
  while (v11 != 9);
  v57 = 0;
  memset(v56, 0, sizeof(v56));
  v55 = 0;
  memset(v54, 0, sizeof(v54));
  find_matrix_inverse((double *)v54, v58, (double *)v56, a4);
  for (i = 0; i != 9; ++i)
  {
    v15 = *((double *)v54 + i);
    *((float *)this + i + 10) = v15;
  }
  if (*((_QWORD *)this + 15))
    j2_colour_converter::configure_lab_transform();
  v16 = *((_DWORD *)this + 1);
  LODWORD(v17) = 1 << v16;
  v18 = operator new[]();
  *((_QWORD *)this + 15) = v18;
  if (v16 != 31)
  {
    v19 = v18;
    v20 = 0;
    if ((int)v17 <= 1)
      v21 = 1;
    else
      v21 = v17;
    do
    {
      v22 = (double)(int)v20 / 8191.0;
      if (v22 >= 0.08)
        v23 = pow((v22 + 0.16) / 1.16, 3.0);
      else
        v23 = v22 * 0.110705646;
      v24 = vcvtmd_s64_f64(v23 * 8191.0 + 0.5);
      if (v24 <= -32768)
        v24 = -32768;
      if (v24 >= 0x7FFF)
        LOWORD(v24) = 0x7FFF;
      *(_WORD *)(v19 + 2 * v20++) = v24;
    }
    while (v21 != v20);
  }
  if (*((_QWORD *)this + 28))
    j2_colour_converter::configure_lab_transform();
  v25 = operator new[]();
  *((_QWORD *)this + 28) = v25;
  if (v16 != 31)
  {
    v26 = v25;
    v27 = 0;
    if ((int)v17 <= 1)
      v17 = 1;
    else
      v17 = v17;
    do
    {
      v28 = (double)(int)v27 / 8191.0;
      if (v28 <= 0.00303993464)
        v29 = v28 * 12.9232102;
      else
        v29 = pow(v28, 0.416666667) * 1.055 + -0.055;
      v30 = vcvtmd_s64_f64((v29 + -0.5) * 8191.0 + 0.5);
      if (v30 <= -32768)
        v30 = -32768;
      if (v30 >= 0x7FFF)
        LOWORD(v30) = 0x7FFF;
      *(_WORD *)(v26 + 2 * v27++) = v30;
    }
    while (v17 != v27);
  }
  v53 = 0;
  memset(v52, 0, sizeof(v52));
  find_monitor_matrix(xy_709_red, xy_709_green, xy_709_blue, xy_D65_white, (double *)v52);
  v51 = 0;
  memset(v50, 0, sizeof(v50));
  find_matrix_inverse((double *)v50, (const double *)v52, (double *)v56, v31);
  v49[0] = 0;
  memset(v48, 0, sizeof(v48));
  if (v6 == 6500)
  {
    for (j = 2; j != 11; j += 3)
    {
      v44 = v49[j + 1];
      v45 = (double *)((char *)v48 + j * 8);
      *(v45 - 2) = *(double *)&v49[j] * 0.950455927;
      *((_QWORD *)v45 - 1) = v44;
      *v45 = *(double *)((char *)v50 + j * 8) * 1.08905775;
    }
  }
  else
  {
    v32 = 0;
    v33 = v50;
    do
    {
      v34 = 0;
      v35 = &icc_xyzD50_to_xyzD65;
      do
      {
        v36 = 0;
        v37 = 0.0;
        v38 = (double *)v35;
        do
        {
          v39 = *v38;
          v38 += 3;
          v37 = v37 + *(double *)((char *)v33 + v36) * v39;
          v36 += 8;
        }
        while (v36 != 24);
        *((double *)v48 + 3 * v32 + v34++) = v37;
        ++v35;
      }
      while (v34 != 3);
      ++v32;
      v33 = (_OWORD *)((char *)v33 + 24);
    }
    while (v32 != 3);
    for (k = 0; k != 72; k += 24)
    {
      v41 = (double *)((char *)v48 + k);
      *v41 = *(double *)((char *)v48 + k) * 0.964295676;
      v41[2] = *(double *)((char *)&v48[1] + k) * 0.825104603;
    }
  }
  for (m = 0; m != 9; ++m)
  {
    v47 = *((double *)v48 + m);
    *((float *)this + m + 37) = v47;
  }
  return 1;
}

void j2_colour_converter::~j2_colour_converter(j2_colour_converter *this)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  for (i = 120; i != 144; i += 8)
  {
    v3 = *(_QWORD *)((char *)this + i);
    if (v3)
    {
      MEMORY[0x18D761C18](v3, 0x1000C80BDFB0063);
      *(_QWORD *)((char *)this + i) = 0;
    }
  }
  v4 = *((_QWORD *)this + 28);
  if (v4)
  {
    MEMORY[0x18D761C18](v4, 0x1000C80BDFB0063);
    *((_QWORD *)this + 28) = 0;
  }
  v5 = *((_QWORD *)this + 29);
  if (v5)
  {
    MEMORY[0x18D761C18](v5, 0x1000C80BDFB0063);
    *((_QWORD *)this + 29) = 0;
  }
}

j2_colour_converter *jp2_colour_converter::clear(j2_colour_converter **this)
{
  j2_colour_converter *result;

  result = *this;
  if (result)
  {
    j2_colour_converter::~j2_colour_converter(result);
    result = (j2_colour_converter *)MEMORY[0x18D761C30]();
  }
  *this = 0;
  return result;
}

BOOL jp2_colour_converter::init(j2_colour_converter **a1, j2_colour *a2, int a3, int a4)
{
  j2_colour_converter *v8;
  int v9;

  if (*a1)
    jp2_colour_converter::clear(a1);
  v8 = (j2_colour_converter *)operator new();
  j2_colour_converter::j2_colour_converter(v8, a2, a3, a4);
  *a1 = v8;
  v9 = *((_DWORD *)v8 + 2);
  if (!v9)
  {
    j2_colour_converter::~j2_colour_converter(v8);
    MEMORY[0x18D761C30]();
    *a1 = 0;
  }
  return v9 != 0;
}

void sub_187F281DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1010C404873F55BLL);
  _Unwind_Resume(a1);
}

BOOL jp2_colour_converter::is_non_trivial(jp2_colour_converter *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    return 0;
  if (*(_BYTE *)(v1 + 13) && *(_BYTE *)(v1 + 112))
    return *(_QWORD *)(v1 + 232) != 0;
  return 1;
}

uint64_t jp2_colour_converter::convert_lum(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  __int16 *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  __int16 v11;
  int v12;

  v3 = *a1;
  if (!*a1 || *(_DWORD *)(v3 + 8) != 1)
    return 0;
  v4 = *(_QWORD *)(v3 + 232);
  if (v4)
  {
    if (a3 >= 0)
      v5 = a3;
    else
      v5 = *(_DWORD *)a2;
    if (v5 > *(_DWORD *)a2)
      jp2_colour_converter::convert_lum();
    if ((*(_BYTE *)(a2 + 6) & 2) == 0 || (*(_BYTE *)(a2 + 6) & 1) != 0 || (v6 = *(__int16 **)(a2 + 8)) == 0)
      jp2_colour_converter::convert_lum();
    if (v5 >= 1)
    {
      v7 = -65536 << *(_DWORD *)(v3 + 4) >> 16;
      v8 = v5 + 1;
      do
      {
        v9 = *v6;
        if (v9 > -4097)
        {
          v12 = v9 + 4096;
          if ((v12 & v7) != 0)
            v12 = ~v7;
          v11 = *(_WORD *)(v4 + 2 * v12);
        }
        else
        {
          v10 = -4096 - v9;
          if ((v10 & v7) != 0)
            v10 = ~v7;
          v11 = -8192 - *(_WORD *)(v4 + 2 * v10);
        }
        *v6++ = v11;
        --v8;
      }
      while (v8 > 1);
    }
  }
  return 1;
}

uint64_t jp2_colour_converter::convert_rgb(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  int v9;
  uint64_t result;
  int v14;
  int v15;
  int v16;
  __int16 *v17;
  __int16 *v18;
  __int16 *v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  __int16 *v29;
  __int16 *v30;
  __int16 *v31;
  int v32;
  int v33;
  int v34;
  __int16 v35;
  int v36;
  int v37;
  int v38;
  __int16 v39;
  int v40;
  int v41;
  int v42;
  __int16 v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  __int16 v62;
  int v63;
  int v64;
  int v65;
  __int16 v66;
  int v67;
  int v68;
  int v69;
  __int16 v70;

  v5 = *a1;
  if (!*a1 || *(_DWORD *)(v5 + 8) != 3)
    return 0;
  if (a5 >= 0)
    v9 = a5;
  else
    v9 = *(_DWORD *)a2;
  if (v9 > *(_DWORD *)a2 || v9 > *(_DWORD *)a3 || v9 > *(_DWORD *)a4)
    jp2_colour_converter::convert_rgb();
  if (*(_BYTE *)(v5 + 14))
  {
    kdu_convert_ycc_to_rgb(a2, a3, a4, v9);
  }
  else if (!*(_BYTE *)(v5 + 13) && v9 >= 1)
  {
    v14 = *(_DWORD *)(v5 + 28);
    v15 = *(_DWORD *)(v5 + 32);
    v16 = *(_DWORD *)(v5 + 36);
    if ((*(_BYTE *)(a4 + 6) & 2) != 0)
      v17 = *(__int16 **)(a4 + 8);
    else
      v17 = 0;
    if ((*(_BYTE *)(a3 + 6) & 2) != 0)
      v18 = *(__int16 **)(a3 + 8);
    else
      v18 = 0;
    if ((*(_BYTE *)(a2 + 6) & 2) != 0)
      v19 = *(__int16 **)(a2 + 8);
    else
      v19 = 0;
    v20 = v9 + 1;
    do
    {
      v21 = v14 + *v19;
      v22 = v15 + *v18;
      v23 = v16 + *v17;
      *v19++ = (*(_DWORD *)(v5 + 80) * v22 + *(_DWORD *)(v5 + 76) * v21 + *(_DWORD *)(v5 + 84) * v23 + 2048) >> 12;
      *v18++ = (*(_DWORD *)(v5 + 92) * v22 + *(_DWORD *)(v5 + 88) * v21 + *(_DWORD *)(v5 + 96) * v23 + 2048) >> 12;
      *v17++ = (*(_DWORD *)(v5 + 104) * v22
                            + *(_DWORD *)(v5 + 100) * v21
                            + *(_DWORD *)(v5 + 108) * v23
                            + 2048) >> 12;
      --v20;
    }
    while (v20 > 1);
  }
  v24 = *a1;
  if (*(_BYTE *)(*a1 + 112))
    return 1;
  v25 = *(_QWORD *)(v24 + 120);
  if (!v25)
    jp2_colour_converter::convert_rgb();
  v26 = -1 << *(_DWORD *)(v24 + 4);
  v27 = *(_QWORD *)(v24 + 128);
  v28 = *(_QWORD *)(v24 + 136);
  if (!v27)
    v27 = *(_QWORD *)(v24 + 120);
  if (!v28)
    v28 = *(_QWORD *)(v24 + 120);
  if ((*(_BYTE *)(a2 + 6) & 2) != 0)
    v29 = *(__int16 **)(a2 + 8);
  else
    v29 = 0;
  if ((*(_BYTE *)(a3 + 6) & 2) != 0)
    v30 = *(__int16 **)(a3 + 8);
  else
    v30 = 0;
  if ((*(_BYTE *)(a4 + 6) & 2) != 0)
    v31 = *(__int16 **)(a4 + 8);
  else
    v31 = 0;
  if (*(_BYTE *)(v24 + 144))
  {
    if (v9 >= 1)
    {
      v32 = v9 + 1;
      do
      {
        v33 = *v29;
        if (v33 > -4097)
        {
          v36 = v33 + 4096;
          if ((v36 & v26) != 0)
            v36 = ~v26;
          v35 = *(_WORD *)(v25 + 2 * v36);
        }
        else
        {
          v34 = -4096 - v33;
          if ((v34 & v26) != 0)
            v34 = ~v26;
          v35 = -8192 - *(_WORD *)(v25 + 2 * v34);
        }
        *v29 = v35;
        v37 = *v30;
        if (v37 > -4097)
        {
          v40 = v37 + 4096;
          if ((v40 & v26) != 0)
            v40 = ~v26;
          v39 = *(_WORD *)(v27 + 2 * v40);
        }
        else
        {
          v38 = -4096 - v37;
          if ((v38 & v26) != 0)
            v38 = ~v26;
          v39 = -8192 - *(_WORD *)(v27 + 2 * v38);
        }
        *v30 = v39;
        v41 = *v31;
        if (v41 > -4097)
        {
          v44 = v41 + 4096;
          if ((v44 & v26) != 0)
            v44 = ~v26;
          v43 = *(_WORD *)(v28 + 2 * v44);
        }
        else
        {
          v42 = -4096 - v41;
          if ((v42 & v26) != 0)
            v42 = ~v26;
          v43 = -8192 - *(_WORD *)(v28 + 2 * v42);
        }
        *v31++ = v43;
        ++v29;
        ++v30;
        --v32;
      }
      while (v32 > 1);
    }
    return 1;
  }
  if (v9 < 1)
    return 1;
  v45 = *(_QWORD *)(v24 + 224);
  v46 = v9 + 1;
  do
  {
    v47 = *v29;
    if (v47 > -4097)
    {
      v50 = v47 + 4096;
      if ((v50 & v26) != 0)
        v50 = ~v26;
      v49 = *(__int16 *)(v25 + 2 * v50);
    }
    else
    {
      v48 = -4096 - v47;
      if ((v48 & v26) != 0)
        v48 = ~v26;
      v49 = -*(__int16 *)(v25 + 2 * v48);
    }
    v51 = *v30;
    if (v51 > -4097)
    {
      v54 = v51 + 4096;
      if ((v54 & v26) != 0)
        v54 = ~v26;
      v53 = *(__int16 *)(v27 + 2 * v54);
    }
    else
    {
      v52 = -4096 - v51;
      if ((v52 & v26) != 0)
        v52 = ~v26;
      v53 = -*(__int16 *)(v27 + 2 * v52);
    }
    v55 = *v31;
    if (v55 > -4097)
    {
      v58 = v55 + 4096;
      if ((v58 & v26) != 0)
        v58 = ~v26;
      v57 = *(__int16 *)(v28 + 2 * v58);
    }
    else
    {
      v56 = -4096 - v55;
      if ((v56 & v26) != 0)
        v56 = ~v26;
      v57 = -*(__int16 *)(v28 + 2 * v56);
    }
    v59 = *(_DWORD *)(v24 + 184) * v49 + *(_DWORD *)(v24 + 188) * v53 + *(_DWORD *)(v24 + 192) * v57;
    v60 = (v59 + 2048) >> 12;
    if (v59 > -2049)
    {
      if ((v60 & v26) != 0)
        v60 = ~v26;
      v62 = *(_WORD *)(v45 + 2 * v60);
    }
    else
    {
      if ((v26 & -v60) != 0)
        v61 = ~v26;
      else
        v61 = -v60;
      v62 = -8192 - *(_WORD *)(v45 + 2 * v61);
    }
    *v29 = v62;
    v63 = *(_DWORD *)(v24 + 196) * v49 + *(_DWORD *)(v24 + 200) * v53 + *(_DWORD *)(v24 + 204) * v57;
    v64 = (v63 + 2048) >> 12;
    if (v63 > -2049)
    {
      if ((v64 & v26) != 0)
        v64 = ~v26;
      v66 = *(_WORD *)(v45 + 2 * v64);
    }
    else
    {
      if ((v26 & -v64) != 0)
        v65 = ~v26;
      else
        v65 = -v64;
      v66 = -8192 - *(_WORD *)(v45 + 2 * v65);
    }
    *v30 = v66;
    v67 = *(_DWORD *)(v24 + 208) * v49 + *(_DWORD *)(v24 + 212) * v53 + *(_DWORD *)(v24 + 216) * v57;
    v68 = (v67 + 2048) >> 12;
    if (v67 > -2049)
    {
      if ((v68 & v26) != 0)
        v68 = ~v26;
      v70 = *(_WORD *)(v45 + 2 * v68);
    }
    else
    {
      if ((v26 & -v68) != 0)
        v69 = ~v26;
      else
        v69 = -v68;
      v70 = -8192 - *(_WORD *)(v45 + 2 * v69);
    }
    *v31++ = v70;
    ++v29;
    ++v30;
    --v46;
    result = 1;
  }
  while (v46 > 1);
  return result;
}

uint64_t jp2_colour_converter::convert_rgb4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t result;
  uint64_t v13;
  __int16 *v16;
  __int16 *v17;
  __int16 *v18;
  __int16 *v19;
  int v20;
  int v21;

  result = jp2_colour_converter::convert_rgb(a1, a2, a3, a4, a6);
  if ((_DWORD)result && *(_BYTE *)(*a1 + 15))
  {
    LODWORD(v13) = *(_DWORD *)a5;
    if (a6 >= 0)
      v13 = a6;
    else
      v13 = v13;
    if ((int)v13 > *(_DWORD *)a2 || (int)v13 > *(_DWORD *)a3 || (int)v13 > *(_DWORD *)a4)
      jp2_colour_converter::convert_rgb4();
    if ((*(_BYTE *)(a2 + 6) & 2) != 0)
      v16 = *(__int16 **)(a2 + 8);
    else
      v16 = 0;
    if ((*(_BYTE *)(a3 + 6) & 2) != 0)
      v17 = *(__int16 **)(a3 + 8);
    else
      v17 = 0;
    if ((*(_BYTE *)(a4 + 6) & 2) != 0)
      v18 = *(__int16 **)(a4 + 8);
    else
      v18 = 0;
    if ((*(_BYTE *)(a5 + 6) & 2) != 0)
      v19 = *(__int16 **)(a5 + 8);
    else
      v19 = 0;
    if ((int)v13 >= 1)
    {
      do
      {
        v20 = *v19++;
        v21 = -16777216 - (v20 << 12);
        *v16 = (v21 + (4095 - v20) * *v16) >> 13;
        ++v16;
        *v17 = (v21 + (4095 - v20) * *v17) >> 13;
        ++v17;
        *v18 = (v21 + (4095 - v20) * *v18) >> 13;
        ++v18;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

void jp2_header::jp2_header(jp2_header *this)
{
  uint64_t v2;

  v2 = operator new();
  *(_QWORD *)v2 = &off_1E1BADD80;
  *(_OWORD *)(v2 + 8) = xmmword_18820CDD0;
  *(_DWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 48) = 0;
  *(_QWORD *)(v2 + 72) = 0;
  *(_QWORD *)(v2 + 80) = 0;
  *(_QWORD *)(v2 + 88) = 0;
  *(_QWORD *)(v2 + 96) = -1;
  *(_QWORD *)(v2 + 104) = -1;
  *(_QWORD *)(v2 + 112) = -1;
  *(_DWORD *)(v2 + 120) = -1;
  *(_DWORD *)(v2 + 125) = 0;
  *(_DWORD *)(v2 + 128) = 0;
  *(_OWORD *)(v2 + 136) = xmmword_18820CDD0;
  *(_DWORD *)(v2 + 176) = 0;
  *(_OWORD *)(v2 + 192) = xmmword_18820CEB0;
  *(_BYTE *)(v2 + 208) = 1;
  *(_DWORD *)(v2 + 212) = 0;
  *(_QWORD *)(v2 + 224) = 0;
  j2_colour::j2_colour((j2_colour *)(v2 + 232));
  *(_BYTE *)(v2 + 344) = 0;
  *(_QWORD *)(v2 + 348) = 0;
  *(_QWORD *)(v2 + 436) = 0;
  *(_QWORD *)(v2 + 360) = 0;
  *(_QWORD *)(v2 + 368) = 0;
  *(_BYTE *)(v2 + 376) = 0;
  *(_OWORD *)(v2 + 384) = 0u;
  *(_OWORD *)(v2 + 400) = 0u;
  *(_OWORD *)(v2 + 416) = 0u;
  *(_DWORD *)(v2 + 431) = 0;
  *(_QWORD *)(v2 + 456) = 0;
  *(_QWORD *)(v2 + 464) = 0;
  *(_QWORD *)(v2 + 448) = 0;
  *(_QWORD *)this = v2;
  *(_QWORD *)(v2 + 184) = 0;
}

void jp2_header::~jp2_header(jp2_header *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD **)this;
  if (*(_QWORD *)this)
  {
    j2_channels::~j2_channels((j2_channels *)(v1 + 52));
    v2 = v1[51];
    if (v2)
      MEMORY[0x18D761C18](v2, 0x1000C808B6DE1C6);
    j2_palette::~j2_palette((j2_palette *)(v1 + 43));
    j2_colour::~j2_colour((j2_colour *)(v1 + 29));
    v3 = v1[28];
    if (v3)
      MEMORY[0x18D761C18](v3, 0x1000C8052888210);
    jp2_input_box::~jp2_input_box((jp2_input_box *)v1);
    MEMORY[0x18D761C30]();
  }
}

float *jp2_header::write(float **this, jp2_output_box *a2)
{
  float *v4;
  float *v5;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  j2_dimensions::finalize((uint64_t)(*this + 48));
  j2_palette::finalize((uint64_t)(*this + 86));
  v4 = *this;
  if ((*this)[114] <= 0.0)
    v4[114] = 1.0;
  if (v4[115] <= 0.0)
    v4[115] = 1.0;
  j2_component_map::finalize((uint64_t)(v4 + 94), (j2_dimensions *)(v4 + 48), (j2_palette *)(v4 + 86));
  j2_channels::finalize((unsigned int *)*this + 104, *((_DWORD *)*this + 60), 1);
  j2_channels::add_cmap_channels((unsigned int *)*this + 104, (j2_component_map *)(*this + 94), 0);
  j2_colour::finalize((j2_colour *)(*this + 58), (j2_channels *)(*this + 104));
  v5 = *this;
  if (*((_BYTE *)*this + 432))
  {
    v9 = 0;
    v7 = 0u;
    v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  if (!j2_colour::is_jp2_compatible((j2_colour *)(v5 + 58)))
  {
    v9 = 0;
    v7 = 0u;
    v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  j2_dimensions::save_boxes((j2_dimensions *)(v5 + 48), a2);
  j2_colour::save_box((j2_colour *)(*this + 58), a2);
  j2_palette::save_box((uint64_t)(*this + 86), a2);
  j2_component_map::save_box((_BYTE *)*this + 376, a2, 0);
  j2_channels::save_box((uint64_t)(*this + 104), a2, 1);
  return j2_resolution::save_box(*this + 114, a2);
}

void sub_187F28BD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F28BE0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_header::access_dimensions(jp2_header *this)
{
  return *(_QWORD *)this + 192;
}

uint64_t jp2_header::access_colour(jp2_header *this)
{
  return *(_QWORD *)this + 232;
}

uint64_t jp2_header::access_palette(jp2_header *this)
{
  return *(_QWORD *)this + 344;
}

uint64_t jp2_header::access_channels(jp2_header *this)
{
  return *(_QWORD *)this + 416;
}

void jp2_target::jp2_target(jp2_target *this)
{
  *((_DWORD *)this + 2) = 0;
  *((_BYTE *)this + 72) = 0;
  *((_BYTE *)this + 12) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 7) = -1;
  *((_QWORD *)this + 8) = 0;
  *(_QWORD *)this = &off_1E1BAB890;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 10) = 0;
  std::unique_ptr<jp2_header>::reset[abi:ne180100]((jp2_header **)this + 10, 0);
  *((_BYTE *)this + 96) = 0;
}

void jp2_target::~jp2_target(jp2_header **this)
{
  jp2_header *v2;

  *this = (jp2_header *)&off_1E1BAB890;
  std::unique_ptr<jp2_header>::reset[abi:ne180100](this + 10, 0);
  *this = (jp2_header *)&off_1E1BB0038;
  v2 = this[8];
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8077774924);
  *this = (jp2_header *)off_1E1BB2398;
}

{
  jp2_target::~jp2_target(this);
  JUMPOUT(0x18D761C30);
}

jp2_header *jp2_target::open(jp2_target *this, jp2_family_tgt *a2)
{
  jp2_header *v3;
  jp2_header *result;
  _OWORD v5[2];
  uint64_t v6;

  *((_QWORD *)this + 11) = a2;
  if (*((_QWORD *)a2 + 3))
  {
    v6 = 0;
    memset(v5, 0, sizeof(v5));
    kdu_error::kdu_error((kdu_error *)v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v5);
  }
  v3 = (jp2_header *)operator new();
  jp2_header::jp2_header(v3);
  result = std::unique_ptr<jp2_header>::reset[abi:ne180100]((jp2_header **)this + 10, v3);
  *((_BYTE *)this + 96) = 0;
  return result;
}

void sub_187F28DB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F28DC4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_target::write_header(jp2_target *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v2 = *((_QWORD *)this + 11);
  if (!v2)
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (*(_QWORD *)(v2 + 24))
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  v3 = **((_QWORD **)this + 10);
  if (*(_DWORD *)(v3 + 200) != 7 || (v4 = *(_DWORD *)(v3 + 204), v4 < 0) || v4 >= 3)
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "Attempting to embed a codestream which does not conform to Part-1 of the JPEG2000 standard within a plain JP2 file.  For this, you must either write a raw codestream, or embed the codestream within the more advanced JPX file format.");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (*((_BYTE *)this + 96))
    jp2_target::write_header();
  if (!*((_QWORD *)this + 10))
    jp2_target::write_header();
  *((_BYTE *)this + 96) = 1;
  jp2_output_box::open((uint64_t)this, *((jp2_family_tgt **)this + 11), 1783636000, 0);
  LODWORD(v6) = 176622093;
  (*(void (**)(jp2_target *, __int128 *, uint64_t))(*(_QWORD *)this + 40))(this, &v6, 4);
  (*(void (**)(jp2_target *))(*(_QWORD *)this + 16))(this);
  (*(void (**)(jp2_target *, uint64_t, _QWORD))(*(_QWORD *)this + 80))(this, 1718909296, 0);
  LODWORD(v6) = 540176490;
  (*(void (**)(jp2_target *, __int128 *, uint64_t))(*(_QWORD *)this + 40))(this, &v6, 4);
  LODWORD(v6) = 0;
  (*(void (**)(jp2_target *, __int128 *, uint64_t))(*(_QWORD *)this + 40))(this, &v6, 4);
  LODWORD(v6) = 540176490;
  (*(void (**)(jp2_target *, __int128 *, uint64_t))(*(_QWORD *)this + 40))(this, &v6, 4);
  (*(void (**)(jp2_target *))(*(_QWORD *)this + 16))(this);
  (*(void (**)(jp2_target *, uint64_t, _QWORD))(*(_QWORD *)this + 80))(this, 1785737832, 0);
  jp2_header::write(*((float ***)this + 10), this);
  return (*(uint64_t (**)(jp2_target *))(*(_QWORD *)this + 16))(this);
}

void sub_187F29034(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F29040(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t jp2_target::open_codestream(jp2_target *this, uint64_t a2)
{
  _OWORD v3[2];
  uint64_t v4;

  if (!*((_QWORD *)this + 11) || !*((_BYTE *)this + 96))
  {
    v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  return (*(uint64_t (**)(jp2_target *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, 1785737827, a2);
}

void sub_187F290FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F29108()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_target::access_dimensions(jp2_target *this)
{
  _QWORD *v1;

  v1 = (_QWORD *)*((_QWORD *)this + 10);
  if (!v1)
    jp2_target::access_dimensions();
  return *v1 + 192;
}

uint64_t jp2_target::access_colour(jp2_target *this)
{
  _QWORD *v1;

  v1 = (_QWORD *)*((_QWORD *)this + 10);
  if (!v1)
    jp2_target::access_colour();
  return *v1 + 232;
}

uint64_t jp2_target::access_channels(jp2_target *this)
{
  _QWORD *v1;

  v1 = (_QWORD *)*((_QWORD *)this + 10);
  if (!v1)
    jp2_target::access_channels();
  return *v1 + 416;
}

uint64_t jp2_target::access_resolution(jp2_target *this)
{
  _QWORD *v1;

  v1 = (_QWORD *)*((_QWORD *)this + 10);
  if (!v1)
    jp2_target::access_resolution();
  return *v1 + 456;
}

void j2_data_references::init(j2_data_references *this, jp2_input_box *a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int64_t v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  unsigned int v14;
  unsigned __int16 v15;
  _OWORD v16[2];
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)a2 + 12) == 1685348972)
  {
    v15 = 0;
    if (!jp2_input_box::read(a2, &v15))
    {
      v17 = 0;
      memset(v16, 0, sizeof(v16));
      kdu_error::kdu_error((kdu_error *)v16, "Error in Kakadu File Format Support:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, "Malformed data reference box (dtbl) found in JPX data source.  Not all fields were present.");
      kdu_error::~kdu_error((kdu_error *)v16);
    }
    LODWORD(v4) = v15;
    *(_DWORD *)this = v15;
    if (*((_DWORD *)this + 1) >= (int)v4)
    {
      v5 = (char *)*((_QWORD *)this + 1);
    }
    else
    {
      *((_DWORD *)this + 1) = v4;
      v5 = (char *)operator new[]();
      v4 = *(unsigned int *)this;
      if (*((_QWORD *)this + 1))
      {
        if ((int)v4 < 1)
          goto LABEL_10;
        v6 = 0;
        do
        {
          *(_QWORD *)(*((_QWORD *)this + 1) + v6) = *(_QWORD *)&v5[v6];
          v6 += 8;
        }
        while (8 * v4 != v6);
        if (*((_QWORD *)this + 1))
        {
LABEL_10:
          MEMORY[0x18D761C18]();
          LODWORD(v4) = *(_DWORD *)this;
        }
      }
      *((_QWORD *)this + 1) = v5;
    }
    bzero(v5, 8 * (int)v4);
    *((_QWORD *)&v16[1] + 1) = 0;
    v25 = 0u;
    v29 = 0u;
    v28 = 0u;
    v26 = 0;
    *(_QWORD *)&v16[0] = &off_1E1BADD80;
    *(_OWORD *)((char *)v16 + 8) = xmmword_18820CDD0;
    v19 = 0uLL;
    v17 = 0;
    v18 = 0uLL;
    v20 = 0uLL;
    v21 = 0;
    v22 = -1;
    v23 = -1;
    v24 = -1;
    LODWORD(v25) = -1;
    DWORD2(v25) = 0;
    *(_DWORD *)((char *)&v25 + 5) = 0;
    v27 = -1;
    v14 = 0;
    if (*(int *)this >= 1)
    {
      v7 = 0;
      do
      {
        v8 = jp2_input_box::open((jp2_input_box *)v16, a2);
        if (DWORD2(v18) == 1970433056)
          v9 = v8;
        else
          v9 = 0;
        if (v9 != 1
          || !jp2_input_box::read((jp2_input_box *)v16, &v14)
          || BYTE5(v25)
          || (v10 = (DWORD2(v29) + v21 - v26), DWORD2(v29) + (int)v21 - (int)v26 < 0))
        {
          v13 = 0;
          v11 = 0u;
          v12 = 0u;
          kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v11 + 16))(&v11, "Malformed data reference box (dtbl).  Unable to read sufficient correctly formatted data entry URL boxes.");
          kdu_error::~kdu_error((kdu_error *)&v11);
        }
        if ((_DWORD)v10 == 0x7FFFFFFF)
        {
          v13 = 0;
          v11 = 0u;
          v12 = 0u;
          kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v11 + 16))(&v11, "Malformed data reference box (dtbl).  Unable to read sufficient correctly formatted data entry URL boxes.");
          kdu_error::~kdu_error((kdu_error *)&v11);
        }
        *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v7) = operator new[]();
        jp2_input_box::read((jp2_input_box *)v16, *(unsigned __int8 **)(*((_QWORD *)this + 1) + 8 * v7), v10);
        *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 1) + 8 * v7) + (int)v10) = 0;
        jp2_input_box::close((jp2_input_box *)v16);
        ++v7;
      }
      while (v7 < *(int *)this);
    }
    if (!*((_BYTE *)a2 + 125) && *((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 17) + *((int *)a2 + 44) >= 1)
    {
      v13 = 0;
      v11 = 0u;
      v12 = 0u;
      kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v11 + 16))(&v11, "Malformed data reference box (dtbl).  Box appears to contain additional content beyond the declared number of data entry URL boxes.");
      kdu_error::~kdu_error((kdu_error *)&v11);
    }
    (*(void (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
    jp2_input_box::~jp2_input_box((jp2_input_box *)v16);
  }
  else
  {
    (*(void (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
  }
}

void sub_187F295B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F295C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  _Unwind_Exception *v6;
  va_list va;

  va_start(va, a6);
  jp2_input_box::~jp2_input_box((jp2_input_box *)va);
  _Unwind_Resume(v6);
}

const char *jp2_data_references::get_url(jp2_data_references *this, int a2)
{
  const char *result;
  uint64_t v4;

  result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    v4 = *(_QWORD *)this;
    if (v4)
    {
      if (*(_DWORD *)v4 >= a2)
      {
        if (a2)
          return *(const char **)(*(_QWORD *)(v4 + 8) + 8 * (a2 - 1));
        else
          return "";
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t jp2_input_box::get_capabilities(jp2_input_box *this)
{
  return *((unsigned int *)this + 32);
}

uint64_t jp2_input_box::get_pos(jp2_input_box *this)
{
  return *((_QWORD *)this + 17) - (*((_QWORD *)this + 10) + *((int *)this + 44));
}

uint64_t jp2_output_box::open(jp2_output_box *this, uint64_t a2)
{
  return (*(uint64_t (**)(jp2_output_box *, _QWORD, uint64_t, _QWORD))(*(_QWORD *)this + 56))(this, 0, a2, 0);
}

uint64_t kdu_compressed_target::close(kdu_compressed_target *this)
{
  return 1;
}

uint64_t kdu_compressed_target::start_rewrite(kdu_compressed_target *this)
{
  return 0;
}

uint64_t kdu_compressed_target::end_rewrite(kdu_compressed_target *this)
{
  return 0;
}

uint64_t j2_component_map::verify_channel_query_idx(uint64_t this, int a2)
{
  _OWORD v2[2];
  uint64_t v3;

  if (a2 < 0 || *(_DWORD *)(this + 28) <= a2)
  {
    v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v2[0] + 16))(v2, "Attempting to associate a reproduction function (e.g., colour intensity, opacity, etc.) with a non-existent image channel in a JP2-family file.  The problem may be a missing or invalid Component Mapping (cmap) box, or a corrupt or illegal Channel Definitions (cdef) box.");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  if (!*(_QWORD *)(this + 8))
    j2_component_map::verify_channel_query_idx();
  return this;
}

void sub_187F29750(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F2975C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void j2_channels::~j2_channels(j2_channels *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 1);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C80A987AF97);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8077774924);
}

void j2_palette::~j2_palette(j2_palette *this)
{
  uint64_t v2;
  int v3;
  uint64_t i;
  uint64_t v5;

  v2 = *((_QWORD *)this + 2);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8052888210);
  if (*((_QWORD *)this + 3))
  {
    v3 = *((_DWORD *)this + 1);
    if (v3 < 1)
      goto LABEL_10;
    for (i = 0; i < v3; ++i)
    {
      v5 = *(_QWORD *)(*((_QWORD *)this + 3) + 8 * i);
      if (v5)
      {
        MEMORY[0x18D761C18](v5, 0x1000C8052888210);
        v3 = *((_DWORD *)this + 1);
      }
    }
    if (*((_QWORD *)this + 3))
LABEL_10:
      MEMORY[0x18D761C18]();
  }
}

void std::default_delete<j2_icc_profile>::operator()[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    if (*a2)
      MEMORY[0x18D761C18](*a2, 0x1000C8077774924);
    JUMPOUT(0x18D761C30);
  }
}

jp2_header *std::unique_ptr<jp2_header>::reset[abi:ne180100](jp2_header **a1, jp2_header *a2)
{
  jp2_header *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    jp2_header::~jp2_header(result);
    JUMPOUT(0x18D761C30);
  }
  return result;
}

void kd_attribute::kd_attribute(kd_attribute *this, const char *a2, const char *a3, int a4, const char *a5)
{
  const char *v5;
  uint64_t v7;
  int v8;
  const char *i;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  BOOL v15;
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  BOOL v23;
  _QWORD *exception;

  v5 = a5;
  v7 = 0;
  v8 = 0;
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  *((_DWORD *)this + 4) = a4;
  *((_QWORD *)this + 3) = a5;
  for (i = a5; ; ++i)
  {
    *((_DWORD *)this + 8) = v8;
    v10 = *(unsigned __int8 *)i;
    v11 = (v10 - 40);
    if (v11 > 0x33)
      break;
    if (((1 << (v10 - 40)) & 0x24C000000) != 0)
      goto LABEL_16;
    if (v10 == 40)
    {
      v12 = 41;
      goto LABEL_10;
    }
    if (v11 != 51)
      break;
    v12 = 93;
    do
    {
LABEL_10:
      v14 = *++i;
      v13 = v14;
      if (v14)
        v15 = v12 == v13;
      else
        v15 = 1;
    }
    while (!v15);
    if (!(_BYTE)v13)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = v5;
      __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
    }
LABEL_16:
    ++v8;
    v7 += 24;
  }
  if (*i)
  {
    v12 = 0;
    goto LABEL_10;
  }
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 16) = 1;
  v16 = operator new[]();
  if (v8)
  {
    v17 = (_BYTE *)(v16 + 16);
    do
    {
      *v17 = 0;
      *((_QWORD *)v17 - 1) = 0;
      v17 += 24;
      v7 -= 24;
    }
    while (v7);
  }
  *((_QWORD *)this + 5) = v16;
  *((_DWORD *)this + 8) = 0;
  if (*v5)
  {
    v18 = 0;
    while (1)
    {
      *(_QWORD *)(v16 + 24 * v18 + 8) = v5;
      v19 = *(unsigned __int8 *)v5 - 40;
      if (v19 > 0x33)
        goto LABEL_28;
      if (((1 << (*v5 - 40)) & 0x24C000000) == 0)
        break;
LABEL_34:
      *((_DWORD *)this + 8) = ++v18;
      if (!*(unsigned __int8 *)++v5)
        goto LABEL_35;
    }
    if (*v5 == 40)
    {
      v20 = 41;
    }
    else if (v19 == 51)
    {
      v20 = 93;
    }
    else
    {
LABEL_28:
      v20 = 0;
    }
    do
    {
      v22 = *++v5;
      v21 = v22;
      if (v22)
        v23 = v20 == v21;
      else
        v23 = 1;
    }
    while (!v23);
    goto LABEL_34;
  }
LABEL_35:
  *((_WORD *)this + 24) = 0;
  *((_QWORD *)this + 7) = 0;
}

uint64_t kd_attribute::augment_records(uint64_t this, int a2)
{
  uint64_t v3;
  int v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  __int128 *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int i;
  __int128 v17;
  char v18;
  int v19;
  int j;
  __int128 v21;
  _OWORD v22[2];
  uint64_t v23;

  if (*(_DWORD *)(this + 36) < a2)
  {
    v3 = this;
    v4 = *(_DWORD *)(this + 64);
    if (v4 < a2)
    {
      if ((*(_BYTE *)(this + 16) & 1) == 0)
      {
        v23 = 0;
        memset(v22, 0, sizeof(v22));
        kdu_error::kdu_error((kdu_error *)v22, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v22[0] + 16))(v22, "Attempting to write multiple records to a code-stream attribute");
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v22[0] + 16))(v22, ", \"");
        (*(void (**)(_OWORD *, _QWORD))(*(_QWORD *)&v22[0] + 16))(v22, *(_QWORD *)v3);
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v22[0] + 16))(v22, "\", which can accept only single attributes!");
        kdu_error::~kdu_error((kdu_error *)v22);
      }
      v5 = v4 + a2;
      v6 = *(int *)(this + 32) * (uint64_t)(v4 + a2);
      is_mul_ok(v6, 0x18uLL);
      v7 = operator new[]();
      v8 = v7;
      if ((_DWORD)v6)
      {
        v9 = (_BYTE *)(v7 + 16);
        v10 = 24 * v6;
        do
        {
          *v9 = 0;
          *((_QWORD *)v9 - 1) = 0;
          v9 += 24;
          v10 -= 24;
        }
        while (v10);
      }
      v11 = *(__int128 **)(v3 + 40);
      v12 = *(_DWORD *)(v3 + 64);
      if (v12 < 1)
      {
        v13 = 0;
        v15 = v7;
      }
      else
      {
        v13 = 0;
        v14 = *(_DWORD *)(v3 + 32);
        v15 = v7;
        do
        {
          if (v14 >= 1)
          {
            for (i = 0; i < v14; ++i)
            {
              v17 = *v11;
              v18 = *((_BYTE *)v11 + 16);
              v11 = (__int128 *)((char *)v11 + 24);
              *(_BYTE *)(v15 + 16) = v18;
              *(_OWORD *)v15 = v17;
              v15 += 24;
              v14 = *(_DWORD *)(v3 + 32);
            }
            v12 = *(_DWORD *)(v3 + 64);
          }
          ++v13;
        }
        while (v13 < v12);
      }
      if (v13 < v5)
      {
        v19 = *(_DWORD *)(v3 + 32);
        do
        {
          v11 = (__int128 *)((char *)v11 - 24 * v19);
          if (v19 >= 1)
          {
            for (j = 0; j < v19; ++j)
            {
              v21 = *v11;
              v11 = (__int128 *)((char *)v11 + 24);
              *(_OWORD *)v15 = v21;
              *(_BYTE *)(v15 + 16) = 0;
              v15 += 24;
              v19 = *(_DWORD *)(v3 + 32);
            }
          }
          ++v13;
        }
        while (v13 != v5);
      }
      this = *(_QWORD *)(v3 + 40);
      if (this)
        this = MEMORY[0x18D761C18](this, 0x1050C80E1FAFEFCLL);
      *(_QWORD *)(v3 + 40) = v8;
      *(_DWORD *)(v3 + 64) = v5;
    }
    *(_DWORD *)(v3 + 36) = a2;
  }
  return this;
}

void sub_187F29CC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F29CCC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_attribute::describe(kd_attribute *this, kdu_message *a2, int a3, int a4, int a5, char a6)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  int v12;
  int *v13;
  int *v14;
  const char *v15;
  uint64_t result;
  int v18;
  int v19;
  __int16 v20;
  char v21[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v8 = 0;
  v26 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  if (a3)
  {
    LOBYTE(v19) = 84;
    v8 = 1;
  }
  if (a4 && (*((_BYTE *)this + 16) & 4) == 0)
  {
    v9 = v8++;
    *(_BYTE *)((unint64_t)&v19 | v9) = 67;
  }
  if (a5)
  {
    *(_WORD *)((unint64_t)&v19 | v8) = 73;
LABEL_9:
    (*(void (**)(kdu_message *, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)this);
    (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "[:<");
    (*(void (**)(kdu_message *, int *))(*(_QWORD *)a2 + 16))(a2, &v19);
    (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, ">]={");
    goto LABEL_10;
  }
  *(_BYTE *)((unint64_t)&v19 | v8) = 0;
  if (v8)
    goto LABEL_9;
  (*(void (**)(kdu_message *, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)this);
  (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "={");
LABEL_10:
  if (*((int *)this + 8) >= 1)
  {
    v10 = 0;
    while (1)
    {
      if (v10)
        (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, ",");
      v11 = *(char **)(*((_QWORD *)this + 5) + 24 * v10 + 8);
      if (!v11)
        kd_attribute::describe();
      v12 = *v11;
      switch(*v11)
      {
        case 'B':
          (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "<yes/no>");
          goto LABEL_30;
        case 'C':
          (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "<custom int>");
          goto LABEL_30;
        case 'D':
        case 'E':
        case 'G':
        case 'H':
          goto LABEL_30;
        case 'F':
          (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "<float>");
          goto LABEL_30;
        case 'I':
          (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "<int>");
          goto LABEL_30;
        default:
          if (v12 == 40)
          {
            v24 = 0u;
            v25 = 0u;
            v22 = 0u;
            v23 = 0u;
            *(_OWORD *)v21 = 0u;
            v18 = 0;
            (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "ENUM<");
            do
            {
              v11 = parse_translator_entry(v11 + 1, 0x2Cu, v21, &v18, v14);
              (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v21);
              if (*v11 != 44)
                break;
              v20 = 44;
              (*(void (**)(kdu_message *, __int16 *))(*(_QWORD *)a2 + 16))(a2, &v20);
            }
            while (*v11 == 44);
            goto LABEL_29;
          }
          if (v12 == 91)
          {
            v24 = 0u;
            v25 = 0u;
            v22 = 0u;
            v23 = 0u;
            *(_OWORD *)v21 = 0u;
            v18 = 0;
            (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "FLAGS<");
            do
            {
              v11 = parse_translator_entry(v11 + 1, 0x7Cu, v21, &v18, v13);
              (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v21);
              if (*v11 != 124)
                break;
              v20 = 124;
              (*(void (**)(kdu_message *, __int16 *))(*(_QWORD *)a2 + 16))(a2, &v20);
            }
            while (*v11 == 124);
LABEL_29:
            (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, ">");
          }
LABEL_30:
          if (++v10 >= *((int *)this + 8))
            goto LABEL_31;
          break;
      }
    }
  }
LABEL_31:
  (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "}");
  if ((*((_DWORD *)this + 4) & 1) != 0)
    v15 = ",...\n";
  else
    v15 = "\n";
  result = (*(uint64_t (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, v15);
  if ((a6 & 1) != 0)
  {
    (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "\t");
    (*(void (**)(kdu_message *, _QWORD))(*(_QWORD *)a2 + 16))(a2, *((_QWORD *)this + 1));
    return (*(uint64_t (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "\n");
  }
  return result;
}

char *parse_translator_entry(const char *a1, unsigned __int8 a2, char *a3, _DWORD *a4, int *a5)
{
  uint64_t v7;
  int v8;
  char v9;
  unsigned int v10;
  const char *v11;
  int v12;
  int v13;
  char *__endptr[2];
  __int128 v16;
  uint64_t v17;
  char v18[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v7 = 0;
  v23 = *MEMORY[0x1E0C80C00];
  v8 = a2;
  while (1)
  {
    v9 = a1[v7];
    if (a2 == v9)
    {
LABEL_3:
      *(_QWORD *)&v20 = 0;
      *(_OWORD *)v18 = 0u;
      v19 = 0u;
      kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "String translators in code-stream attribute specifications must contain an '=' sign! Problem encountered at");
      (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, ": \"");
      (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, a1);
      (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "\".");
      kdu_error::~kdu_error((kdu_error *)v18);
    }
    v10 = a1[v7];
    if (v10 > 0x3C)
      break;
    if (!a1[v7] || v10 == 41)
      goto LABEL_3;
LABEL_4:
    a3[v7++] = v9;
    if (v7 == 80)
    {
      v17 = 0;
      *(_OWORD *)__endptr = 0u;
      v16 = 0u;
      kdu_error::kdu_error((kdu_error *)__endptr, "Kakadu Core Error:\n");
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, "String translators in code-stream attribute specifications may not exceed ");
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      *(_OWORD *)v18 = 0u;
      if (LOBYTE(__endptr[1]))
        sprintf(v18, "%x");
      else
        sprintf(v18, "%d");
      (*((void (**)(char **, char *))__endptr[0] + 2))(__endptr, v18);
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, " characters in length! Problem encountered at");
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, ": \"");
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, a1);
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, "\".");
      kdu_error::~kdu_error((kdu_error *)__endptr);
    }
  }
  if (v10 == 93)
    goto LABEL_3;
  if (v10 != 61)
    goto LABEL_4;
  a3[v7] = 0;
  v11 = &a1[(v7 + 1)];
  __endptr[0] = 0;
  v12 = strtol(v11, __endptr, 10);
  *a4 = v12;
  if (__endptr[0] == v11 || v8 != *__endptr[0] && (v13 = *__endptr[0], v13 != 41) && v13 != 93)
  {
    *(_QWORD *)&v20 = 0;
    *(_OWORD *)v18 = 0u;
    v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "String translators in code-stream attribute specifications must be identified with integers and correctly delimited! Problem encountered at");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, ": \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, v11);
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "\".");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  return __endptr[0];
}

void sub_187F2A418(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2A424(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

void kdu_params::~kdu_params(kdu_params *this)
{
  uint64_t i;
  uint64_t v3;
  kdu_params *v4;
  kdu_params *v5;
  _QWORD *v6;
  char *v7;
  _QWORD *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  kdu_params **v16;
  const char *v17;
  kdu_params *v18;
  int v19;
  _QWORD *v20;
  int v21;
  _QWORD *v22;
  kdu_params *v23;
  kdu_params *v24;
  kdu_params *v25;
  kdu_params *v26;
  kdu_params *v27;
  _QWORD *v28;
  int v29;

  *(_QWORD *)this = &unk_1E1BABA18;
  for (i = *((_QWORD *)this + 12); i; i = *((_QWORD *)this + 12))
  {
    *((_QWORD *)this + 12) = *(_QWORD *)(i + 56);
    v3 = *(_QWORD *)(i + 40);
    if (v3)
      MEMORY[0x18D761C18](v3, 0x1050C80E1FAFEFCLL);
    MEMORY[0x18D761C30](i, 0x1070C40C5D0BD27);
  }
  v4 = (kdu_params *)*((_QWORD *)this + 10);
  if (!v4)
    return;
  if (v4 != this)
  {
    do
    {
      v5 = v4;
      v4 = (kdu_params *)*((_QWORD *)v4 + 11);
    }
    while (v4 != this);
    v6 = (_QWORD *)((char *)v5 + 88);
    v7 = (char *)this + 88;
    goto LABEL_9;
  }
  v8 = (_QWORD *)*((_QWORD *)this + 11);
  if (v8)
  {
    do
    {
      *((_QWORD *)this + 11) = v8[11];
      v8[10] = 0;
      (*(void (**)(_QWORD *))(*v8 + 16))(v8);
      v8 = (_QWORD *)*((_QWORD *)this + 11);
    }
    while (v8);
    if (*((kdu_params **)this + 10) != this)
    {
      v17 = "this == first_inst";
      v29 = 797;
LABEL_53:
      __assert_rtn("~kdu_params", "params.cpp", v29, v17);
    }
  }
  v9 = *((_QWORD *)this + 8);
  if (!v9
    || (v10 = *((_DWORD *)this + 8),
        v11 = *((_DWORD *)this + 4),
        v12 = *((_DWORD *)this + 5),
        v13 = v10 + 1,
        v14 = v12 + v13 + v13 * v11 + 1,
        *(kdu_params **)(v9 + 8 * v14) != this))
  {
    v17 = "(refs != NULL) && (refs[ref_idx] == this)";
    v29 = 800;
    goto LABEL_53;
  }
  v15 = v14;
  *(_QWORD *)(v9 + 8 * v14) = 0;
  if (v12 < 0 && v10 >= 1)
  {
    v16 = (kdu_params **)(*((_QWORD *)this + 8) + 8 * v14 + 8);
    v17 = "(*sref)->tile_idx == this->tile_idx";
    while (1)
    {
      v18 = *v16;
      if (*v16 == this)
      {
        *v16 = 0;
      }
      else if (v18)
      {
        if (*((_DWORD *)v18 + 4) != *((_DWORD *)this + 4))
        {
          v29 = 813;
          goto LABEL_53;
        }
        (*(void (**)(kdu_params *))(*(_QWORD *)v18 + 16))(v18);
        if (*v16)
        {
          v29 = 816;
          v17 = "*sref == NULL";
          goto LABEL_53;
        }
      }
      --v13;
      ++v16;
      if (v13 <= 1)
      {
        v11 = *((_DWORD *)this + 4);
        break;
      }
    }
  }
  if ((v11 & 0x80000000) == 0)
    return;
  v19 = *((_DWORD *)this + 7);
  if (v19 < 1)
  {
LABEL_38:
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
      return;
    v25 = (kdu_params *)*((_QWORD *)this + 8);
    if (v25 != (kdu_params *)((char *)this + 72) && v25)
      MEMORY[0x18D761C18](v25, 0x20C8093837F09);
    v26 = (kdu_params *)*((_QWORD *)this + 6);
    if (!v26)
      return;
    if (v26 == this)
    {
      while (1)
      {
        v28 = (_QWORD *)*((_QWORD *)this + 7);
        if (!v28)
          break;
        *((_QWORD *)this + 7) = v28[7];
        v28[6] = 0;
        (*(void (**)(_QWORD *))(*v28 + 16))(v28);
      }
      return;
    }
    do
    {
      v27 = v26;
      v26 = (kdu_params *)*((_QWORD *)v26 + 7);
    }
    while (v26 != this);
    v6 = (_QWORD *)((char *)v27 + 56);
    v7 = (char *)this + 56;
LABEL_9:
    *v6 = *(_QWORD *)v7;
    return;
  }
  v20 = (_QWORD *)(*((_QWORD *)this + 8) + 8 * v15);
  v21 = v19 + 1;
  v17 = "(*sref)->comp_idx == this->comp_idx";
  do
  {
    v22 = &v20[*((int *)this + 8)];
    v24 = (kdu_params *)v22[1];
    v20 = v22 + 1;
    v23 = v24;
    if (v24 == this)
    {
      *v20 = 0;
    }
    else
    {
      if (!v23)
        goto LABEL_36;
      if (*((_DWORD *)v23 + 5) != *((_DWORD *)this + 5))
      {
        v29 = 831;
        goto LABEL_53;
      }
      (*(void (**)(kdu_params *))(*(_QWORD *)v23 + 16))(v23);
      if (*v20)
      {
        v29 = 834;
        v17 = "*sref == NULL";
        goto LABEL_53;
      }
    }
LABEL_36:
    --v21;
  }
  while (v21 > 1);
  if ((*((_DWORD *)this + 4) & 0x80000000) != 0)
    goto LABEL_38;
}

kdu_params *kdu_params::link(kdu_params *this, kdu_params *a2, int a3, int a4, int a5, int a6)
{
  kdu_params *v9;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  kdu_params *v15;
  int v16;
  uint64_t v17;
  uint64_t i;
  kdu_params *v19;
  int v20;
  kdu_params *v21;
  BOOL v22;
  kdu_params *v23;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  if (*((_DWORD *)this + 4) != -1
    || *((_DWORD *)this + 5) != -1
    || *((_DWORD *)this + 6)
    || a3 >= a5
    || (v9 = (kdu_params *)*((_QWORD *)this + 8), v9 != (kdu_params *)((char *)this + 72))
    || a4 < -1
    || a3 < -1
    || a4 >= a6)
  {
    kdu_params::link();
  }
  *((_DWORD *)this + 4) = a3;
  *((_DWORD *)this + 5) = a4;
  *((_DWORD *)this + 7) = a5;
  *((_DWORD *)this + 8) = a6;
  *((_QWORD *)this + 6) = 0;
  if (a5 >= 1 && !*((_BYTE *)this + 38) || a6 >= 1 && !*((_BYTE *)this + 39))
  {
    v27 = 0;
    v25 = 0u;
    v26 = 0u;
    kdu_error::kdu_error((kdu_error *)&v25, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v25);
  }
  v12 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 48);
  if (v12)
  {
    v13 = (const char *)*((_QWORD *)this + 1);
    while (1)
    {
      v14 = v12;
      if (!strcmp(*(const char **)(v12 + 8), v13))
        break;
      v12 = *(_QWORD *)(v14 + 56);
      if (!v12)
      {
        if ((a4 & a3) == 0xFFFFFFFF)
        {
          v15 = *(kdu_params **)(v14 + 48);
          *(_QWORD *)(v14 + 56) = this;
          goto LABEL_21;
        }
LABEL_44:
        kdu_params::link();
      }
    }
    if (*(_DWORD *)(v14 + 32) != a6 || *(_DWORD *)(v14 + 28) != a5)
    {
      v27 = 0;
      v25 = 0u;
      v26 = 0u;
      kdu_error::kdu_error((kdu_error *)&v25, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v25);
    }
    v19 = *(kdu_params **)(v14 + 64);
    *((_QWORD *)this + 8) = v19;
    if (v19 == v9)
      kdu_params::link();
    v20 = a4 + a3 + 1 + (a3 + 1) * a6 + 1;
    v21 = (kdu_params *)*((_QWORD *)v19 + v20);
    if (v21)
      v22 = v21 == this;
    else
      v22 = 1;
    if (!v22 && *((_DWORD *)v21 + 5) == a4 && *((_DWORD *)v21 + 4) == a3)
    {
      if (!*((_BYTE *)this + 40))
      {
        v27 = 0;
        v25 = 0u;
        v26 = 0u;
        kdu_error::kdu_error((kdu_error *)&v25, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v25);
      }
      do
      {
        v23 = v21;
        v21 = (kdu_params *)*((_QWORD *)v21 + 11);
      }
      while (v21);
      *((_QWORD *)this + 10) = *((_QWORD *)v23 + 10);
      *((_QWORD *)v23 + 11) = this;
      *((_DWORD *)this + 6) = *((_DWORD *)v23 + 6) + 1;
    }
    else
    {
      *((_QWORD *)v19 + v20) = this;
    }
  }
  else
  {
    v15 = this;
    if ((a4 & a3) != 0xFFFFFFFF)
      goto LABEL_44;
LABEL_21:
    *((_QWORD *)this + 6) = v15;
    *((_QWORD *)this + 7) = 0;
    v16 = a6 + 1;
    if (!is_mul_ok(a5 + 1, v16))
    {
      v27 = 0;
      v25 = 0u;
      v26 = 0u;
      kdu_error::kdu_error((kdu_error *)&v25, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v25);
    }
    v17 = (a5 + 1) * (uint64_t)v16;
    *((_QWORD *)this + 8) = operator new[]();
    if (v17)
    {
      for (i = 0; i != v17; ++i)
        *(_QWORD *)(*((_QWORD *)this + 8) + 8 * i) = this;
    }
  }
  return this;
}

void sub_187F2AA94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F2AAA0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_params::add_dependency(uint64_t this, const char *a2)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;

  v2 = 0;
  while (1)
  {
    v3 = *(const char **)(this + v2 + 112);
    if (v3 == a2)
      break;
    if (!v3)
    {
      v4 = this + v2;
      *(_QWORD *)(v4 + 112) = a2;
      *(_QWORD *)(v4 + 120) = 0;
      return this;
    }
    v2 += 8;
    if (v2 == 32)
      kdu_params::add_dependency();
  }
  return this;
}

uint64_t kdu_params::new_instance(kdu_params *this)
{
  kdu_params *v1;
  uint64_t result;
  kdu_params *v3;
  uint64_t i;

  if (!*((_BYTE *)this + 40))
    return 0;
  v1 = this;
  if ((*((_DWORD *)this + 5) & 0x80000000) != 0 && *((int *)this + 8) > 0)
    return 0;
  if ((*((_DWORD *)this + 4) & 0x80000000) != 0 && *((int *)this + 7) >= 1 && !*((_BYTE *)this + 42))
    return 0;
  result = (**(uint64_t (***)(kdu_params *))this)(this);
  *(_QWORD *)(result + 64) = *((_QWORD *)v1 + 8);
  *(_QWORD *)(result + 16) = *((_QWORD *)v1 + 2);
  *(_QWORD *)(result + 28) = *(_QWORD *)((char *)v1 + 28);
  *(_QWORD *)(result + 48) = 0;
  do
  {
    v3 = v1;
    v1 = (kdu_params *)*((_QWORD *)v1 + 11);
  }
  while (v1);
  *((_QWORD *)v3 + 11) = result;
  *(_QWORD *)(result + 80) = *((_QWORD *)v3 + 10);
  *(_DWORD *)(result + 24) = *((_DWORD *)v3 + 6) + 1;
  for (i = 112; i != 152; i += 8)
    *(_QWORD *)(result + i) = *(_QWORD *)((char *)v3 + i);
  return result;
}

uint64_t kdu_params::copy_from(uint64_t this, kdu_params *a2, int a3, int a4, int a5, uint64_t a6, unsigned int a7, _BOOL4 a8, BOOL a9, BOOL a10)
{
  int v12;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  _BOOL4 v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  kdu_params *v36;
  kdu_params *v37;
  BOOL v38;
  int v39;
  uint64_t v40;
  int v41;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v12 = a4;
  v14 = this;
  if (*((_QWORD *)a2 + 1) != *(_QWORD *)(this + 8))
  {
    v47 = 0;
    v45 = 0u;
    v46 = 0u;
    kdu_error::kdu_error((kdu_error *)&v45, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v45);
  }
  if ((*((_DWORD *)a2 + 4) & 0x80000000) == 0
    || (*((_DWORD *)a2 + 5) & 0x80000000) == 0
    || (*(_DWORD *)(this + 16) & 0x80000000) == 0
    || (*(_DWORD *)(this + 20) & 0x80000000) == 0)
  {
    v47 = 0;
    v45 = 0u;
    v46 = 0u;
    kdu_error::kdu_error((kdu_error *)&v45, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v45);
  }
  if (*((_DWORD *)a2 + 7) <= a3)
    v15 = 0;
  else
    v15 = *(_QWORD *)(*((_QWORD *)a2 + 8) + 8 * (a3 + 1 + (a3 + 1) * *((_DWORD *)a2 + 8)));
  if (*(_DWORD *)(this + 28) > a4)
  {
    v16 = a4 + 1;
    v17 = *(_QWORD *)(*(_QWORD *)(this + 64) + 8 * (v16 + v16 * *(_DWORD *)(this + 32)));
    if (v17)
    {
      if ((a4 & 0x80000000) == 0 && *(_DWORD *)(v17 + 16) == -1)
      {
        if (!v15 || (*(_DWORD *)(v15 + 16) & 0x80000000) != 0)
          goto LABEL_61;
        this = kdu_params::access_relation((kdu_params *)v17, a4, -1, 0, 0);
        v17 = this;
        if (*(_DWORD *)(this + 16) != v12)
          kdu_params::copy_from();
      }
      if (v15)
      {
        v18 = 0;
        v41 = v12;
        v19 = a6;
        v40 = v14;
        v39 = v16;
LABEL_20:
        v20 = a6;
        v21 = v17;
        v22 = v15;
        do
        {
          v23 = *(_DWORD *)(v22 + 24);
          if (a5 < 0 || v23 == a5)
          {
            if (*(_BYTE *)(v21 + 42))
            {
              this = kdu_params::access_relation((kdu_params *)v17, *(_DWORD *)(v21 + 16), *(_DWORD *)(v21 + 20), v23, 0);
              v21 = this;
              v25 = v20;
              if (!this)
                kdu_params::copy_from();
            }
            else
            {
              v25 = v20;
            }
            if (*(_BYTE *)(v21 + 37))
            {
              v47 = 0;
              v45 = 0u;
              v46 = 0u;
              kdu_error::kdu_error((kdu_error *)&v45, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)&v45);
            }
            if (*(_BYTE *)(v21 + 36))
              this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _BOOL4, BOOL, BOOL))(*(_QWORD *)v21 + 24))(v21, v22, v25, a7, a8, a9, a10);
            v24 = a5 >= 0;
          }
          else
          {
            v24 = 0;
          }
          if (!*(_BYTE *)(v21 + 40))
            break;
          v22 = *(_QWORD *)(v22 + 88);
          if (*(_BYTE *)(v21 + 42))
          {
            v26 = v21;
          }
          else
          {
            v26 = *(_QWORD *)(v21 + 88);
            if (!v26)
            {
              this = kdu_params::new_instance((kdu_params *)v21);
              v26 = *(_QWORD *)(v21 + 88);
            }
          }
          v27 = !v22 || v26 == 0;
          v28 = v27 || v24;
          v21 = v26;
        }
        while (v28 != 1);
        v29 = v19 + 1;
        v30 = v18 + 1;
        a6 = v20;
        v12 = v41;
        v14 = v40;
        while (1)
        {
          v19 = v29;
          v18 = v30;
          v31 = v29 - 1;
          v32 = *(_DWORD *)(v15 + 32);
          v15 = v31 >= v32 ? 0 : *(_QWORD *)(*(_QWORD *)(v15 + 64) + 8 * (v19 + a3 + 1 + (a3 + 1) * v32));
          v33 = *(_DWORD *)(v17 + 32);
          if (v18 - 1 >= v33)
            break;
          v17 = *(_QWORD *)(*(_QWORD *)(v17 + 64) + 8 * (v18 + v39 + v39 * v33));
          if (!v17)
            break;
          v34 = *(_DWORD *)(v17 + 20);
          if (v34 != -1 || v15 == 0)
          {
            if (v34 == -1)
            {
LABEL_58:
              this = kdu_params::access_relation((kdu_params *)v17, v41, v18 - 1, 0, 0);
              v17 = this;
            }
            if (v15 && v17)
              goto LABEL_20;
            break;
          }
          v29 = v19 + 1;
          v30 = v18 + 1;
          if (*(_DWORD *)(v15 + 20) != -1)
            goto LABEL_58;
        }
      }
    }
  }
LABEL_61:
  if (*((kdu_params **)a2 + 6) == a2 && *(_QWORD *)(v14 + 48) == v14)
  {
    v36 = (kdu_params *)*((_QWORD *)a2 + 7);
    if (v36)
    {
      v37 = *(kdu_params **)(v14 + 56);
      if (v37)
      {
        do
        {
          this = kdu_params::copy_from(v37, v36, a3, v12, a5, a6, a7, a8, a9, a10);
          v37 = (kdu_params *)*((_QWORD *)v37 + 7);
          v36 = (kdu_params *)*((_QWORD *)v36 + 7);
          if (v36)
            v38 = v37 == 0;
          else
            v38 = 1;
        }
        while (!v38);
      }
    }
  }
  return this;
}

void sub_187F2AFF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2B004(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Exception *v15;

  _Unwind_Resume(v15);
}

uint64_t kdu_params::access_relation(kdu_params *this, int a2, int a3, int a4, int a5)
{
  int v7;
  int v9;
  int v10;
  uint64_t v11;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  int v19;
  int i;
  _QWORD *v21;
  uint64_t v22;
  uint64_t j;
  uint64_t k;
  const char *v25;
  int v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;

  if (*((_DWORD *)this + 7) <= a2)
    return 0;
  v7 = *((_DWORD *)this + 8);
  if (v7 <= a3)
    return 0;
  v9 = a2 + 1 + (a2 + 1) * v7;
  v10 = a3 + v9 + 1;
  v11 = *(_QWORD *)(*((_QWORD *)this + 8) + 8 * v10);
  if (!v11)
    return v11;
  if ((a5 & 1) == 0 && (*(_DWORD *)(v11 + 16) != a2 || *(_DWORD *)(v11 + 20) != a3))
  {
    if (!a4 || *((_BYTE *)this + 42))
    {
      v11 = (**(uint64_t (***)(kdu_params *))this)(this);
      *(_QWORD *)(v11 + 64) = *((_QWORD *)this + 8);
      *(_DWORD *)(v11 + 16) = a2;
      *(_DWORD *)(v11 + 20) = a3;
      *(_QWORD *)(v11 + 28) = *(_QWORD *)((char *)this + 28);
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(*((_QWORD *)this + 8) + 8 * v10) = v11;
      if (a3 < 0)
      {
        if (a2 < 0)
          kdu_params::access_relation();
        v14 = *((_DWORD *)this + 8);
        if (v14 >= 1)
        {
          v15 = 0;
          v16 = 8 * v10 + 8;
          do
          {
            v17 = (_QWORD *)*((_QWORD *)this + 8);
            v18 = *(_QWORD *)((char *)&v17[v15] + v16);
            if (v18 == *v17)
            {
              *(_QWORD *)((char *)&v17[v15] + v16) = v11;
            }
            else if ((*(_DWORD *)(v18 + 16) & 0x80000000) != 0)
            {
              kdu_params::access_relation(this, a2, v15, 0, 0);
              v14 = *((_DWORD *)this + 8);
            }
            ++v15;
          }
          while ((int)v15 < v14);
        }
      }
      else if (a2 < 0)
      {
        v19 = *((_DWORD *)this + 7);
        if (v19 >= 1)
        {
          for (i = 0; i < v19; ++i)
          {
            v10 += *((_DWORD *)this + 8) + 1;
            v21 = (_QWORD *)*((_QWORD *)this + 8);
            v22 = v21[v10];
            if (v22 == *v21)
            {
              v21[v10] = v11;
            }
            else if ((*(_DWORD *)(v22 + 20) & 0x80000000) != 0)
            {
              kdu_params::access_relation(this, i, a3, 0, 0);
              v19 = *((_DWORD *)this + 7);
            }
          }
        }
      }
      else if (*(_QWORD *)(*((_QWORD *)this + 8) + 8 * v9) == **((_QWORD **)this + 8))
      {
        kdu_params::access_relation(this, a2, -1, 0, 0);
      }
      for (j = *(_QWORD *)(**((_QWORD **)this + 8) + 48); j; j = *(_QWORD *)(j + 56))
      {
        for (k = 112; k != 144; k += 8)
        {
          v25 = *(const char **)(j + k);
          if (!v25)
            break;
          if (!strcmp(v25, *((const char **)this + 1)))
          {
            kdu_params::access_relation((kdu_params *)j, a2, a3, 0, 0);
            if ((a2 & 0x80000000) == 0 && *(_BYTE *)(j + 39) && !*((_BYTE *)this + 39) && *(int *)(j + 32) >= 1)
            {
              v26 = 0;
              do
                kdu_params::access_relation((kdu_params *)j, a2, v26++, 0, 0);
              while (v26 < *(_DWORD *)(j + 32));
            }
            break;
          }
        }
      }
      if (v11)
        goto LABEL_43;
      return v11;
    }
    return 0;
  }
  do
  {
LABEL_43:
    if (*(_DWORD *)(v11 + 24) == a4)
      break;
    v28 = (uint64_t *)(v11 + 88);
    v27 = *(_QWORD *)(v11 + 88);
    if (!v27 || *(_DWORD *)(v27 + 24) > a4)
    {
      if (!*(_BYTE *)(v11 + 42))
        return 0;
      if (a5)
      {
        if ((*(_DWORD *)(v11 + 16) & 0x80000000) != 0)
          return 0;
        if (*(_DWORD *)(v11 + 32))
          kdu_params::access_relation();
        v28 = (uint64_t *)*((_QWORD *)this + 8);
      }
      else
      {
        v29 = (**(uint64_t (***)(kdu_params *))this)(this);
        *(_QWORD *)(v29 + 64) = *((_QWORD *)this + 8);
        *(_DWORD *)(v29 + 16) = a2;
        *(_DWORD *)(v29 + 20) = a3;
        *(_QWORD *)(v29 + 28) = *(_QWORD *)((char *)this + 28);
        *(_QWORD *)(v29 + 48) = 0;
        *(_OWORD *)(v29 + 80) = *(_OWORD *)(v11 + 80);
        *(_QWORD *)(v11 + 88) = v29;
        *(_DWORD *)(v29 + 24) = a4;
      }
    }
    v11 = *v28;
  }
  while (*v28);
  return v11;
}

uint64_t kdu_params::access_cluster(kdu_params *this, const char *__s2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(**((_QWORD **)this + 8) + 48);
  if (__s2 && v2)
  {
    do
    {
      if (!strcmp(*(const char **)(v2 + 8), __s2))
        break;
      v2 = *(_QWORD *)(v2 + 56);
    }
    while (v2);
  }
  return v2;
}

uint64_t kdu_params::access_cluster(kdu_params *this, int a2)
{
  uint64_t result;
  BOOL v3;
  BOOL v4;

  result = *(_QWORD *)(**((_QWORD **)this + 8) + 48);
  if (result)
    v3 = a2 < 1;
  else
    v3 = 1;
  if (!v3)
  {
    do
    {
      result = *(_QWORD *)(result + 56);
      if (result)
        v4 = a2 > 1;
      else
        v4 = 0;
      --a2;
    }
    while (v4);
  }
  return result;
}

uint64_t kdu_params::access_unique(kdu_params *this, int a2, int a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t result;

  if (*((_DWORD *)this + 7) <= a2)
    return 0;
  v4 = *((_DWORD *)this + 8);
  if (v4 <= a3)
    return 0;
  v5 = *(_QWORD *)(*((_QWORD *)this + 8) + 8 * (a3 + a2 + 1 + (a2 + 1) * v4 + 1));
  if (!v5 || *(_DWORD *)(v5 + 16) != a2 || *(_DWORD *)(v5 + 20) != a3)
    return 0;
  while (*(_DWORD *)(v5 + 24) != a4)
  {
    result = 0;
    v5 = *(_QWORD *)(v5 + 88);
    if (!v5)
      return result;
  }
  return v5;
}

uint64_t kdu_params::clear_marks(uint64_t this)
{
  uint64_t i;
  int v2;
  uint64_t *v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;

  for (i = *(_QWORD *)(**(_QWORD **)(this + 64) + 48); i; i = *(_QWORD *)(i + 56))
  {
    v2 = *(_DWORD *)(i + 28);
    if ((v2 & 0x80000000) == 0)
    {
      v3 = *(uint64_t **)(i + 64);
      v4 = *(_DWORD *)(i + 32);
      v5 = -1;
      do
      {
        if ((v4 & 0x80000000) == 0)
        {
          v6 = -1;
          do
          {
            v7 = *v3;
            if (*v3 && *(_DWORD *)(v7 + 16) == v5 && *(_DWORD *)(v7 + 20) == v6)
            {
              do
              {
                *(_BYTE *)(v7 + 37) = 0;
                *(_BYTE *)(v7 + 104) = 0;
                v7 = *(_QWORD *)(v7 + 88);
              }
              while (v7);
            }
            ++v6;
            ++v3;
          }
          while (v6 != v4);
        }
        ++v5;
      }
      while (v5 != v2);
    }
  }
  return this;
}

uint64_t kdu_params::any_changes(kdu_params *this)
{
  return *(unsigned __int8 *)(*(_QWORD *)(**((_QWORD **)this + 8) + 48) + 104);
}

uint64_t kdu_params::check_typical_tile(kdu_params *this, int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  _OWORD v8[2];
  uint64_t v9;

  v2 = *(_QWORD *)(**((_QWORD **)this + 8) + 48);
  if (!v2)
    return 1;
  while (1)
  {
    v3 = *(_DWORD *)(v2 + 28);
    if (v3 >= 1)
    {
      if (a2 < 0 || v3 <= a2)
      {
        v9 = 0;
        memset(v8, 0, sizeof(v8));
        kdu_error::kdu_error((kdu_error *)v8, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)v8);
      }
      v4 = *(_DWORD *)(v2 + 32);
      if ((v4 & 0x80000000) == 0)
        break;
    }
LABEL_11:
    v2 = *(_QWORD *)(v2 + 56);
    if (!v2)
      return 1;
  }
  v5 = v4 + 1;
  v6 = *(_QWORD *)(v2 + 64) + 8 * v5 * (a2 + 1);
  while (!*(_QWORD *)v6 || (*(_DWORD *)(*(_QWORD *)v6 + 16) & 0x80000000) != 0)
  {
    v6 += 8;
    if (!--v5)
      goto LABEL_11;
  }
  return 0;
}

void sub_187F2B5E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F2B5EC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_params::get(kdu_params *this, const char *a2, int a3, int a4, int *a5, int a6, _BOOL4 a7, _BOOL4 a8)
{
  int v12;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  int v19;
  int v20;
  kdu_params *v21;
  kdu_params *v22;
  uint64_t result;
  int v24;
  uint64_t v25;
  _OWORD v27[2];
  uint64_t v28;
  char v29[16];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if ((a4 | a3) < 0)
    kdu_params::get();
  v12 = a3;
  v15 = *((_QWORD *)this + 12);
  if (!v15)
  {
LABEL_10:
    *(_QWORD *)&v31 = 0;
    *(_OWORD *)v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)v29, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, "Attempt to access a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, ", \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, a2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, "\"!");
    kdu_error::~kdu_error((kdu_error *)v29);
  }
  v16 = *((_QWORD *)this + 12);
  while (*(const char **)v16 != a2)
  {
    v16 = *(_QWORD *)(v16 + 56);
    if (!v16)
    {
      while (strcmp(*(const char **)v15, a2))
      {
        v15 = *(_QWORD *)(v15 + 56);
        if (!v15)
          goto LABEL_10;
      }
      v16 = v15;
      break;
    }
  }
  if (*(_DWORD *)(v16 + 32) <= a4)
  {
    v28 = 0;
    memset(v27, 0, sizeof(v27));
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v27[0] + 16))(v27, "Attempt to access a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v27[0] + 16))(v27, " \"");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v27[0] + 16))(v27, a2);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v27[0] + 16))(v27, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v27[0] + 16))(v27, "The field index is ");
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    *(_OWORD *)v29 = 0u;
    if (BYTE8(v27[0]))
      sprintf(v29, "%x");
    else
      sprintf(v29, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v27[0] + 16))(v27, v29);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v27[0] + 16))(v27, ".");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  v17 = *(_QWORD *)(v16 + 40);
  if (v17)
  {
    v18 = *(_BYTE **)(v17 + 24 * a4 + 8);
    if (v18)
    {
      if (*v18 == 70)
      {
        *(_QWORD *)&v31 = 0;
        *(_OWORD *)v29 = 0u;
        v30 = 0u;
        kdu_error::kdu_error((kdu_error *)v29, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, "Attempting to access a floating point code-stream attribute field with the integer access method!\nThe attribute name is");
        (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, " \"");
        (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, a2);
        (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, "\".");
        kdu_error::~kdu_error((kdu_error *)v29);
      }
    }
  }
  if (*(_BYTE *)(v16 + 48))
    v19 = a8;
  else
    v19 = 1;
  if (*(int *)(v16 + 36) > 0)
    v20 = v19;
  else
    v20 = 0;
  if ((v20 & 1) == 0 && a6 && (!*((_DWORD *)this + 6) || *((_BYTE *)this + 42)))
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
    {
      v21 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), -1, 0, 1);
      if (v21)
      {
        if (*((_DWORD *)v21 + 4) == *((_DWORD *)this + 4)
          && (kdu_params::get(v21, a2, v12, a4, a5, 0, a7, a8) & 1) != 0)
        {
          return 1;
        }
      }
    }
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
    {
      v22 = (kdu_params *)kdu_params::access_relation(this, -1, *((_DWORD *)this + 5), *((_DWORD *)this + 6), 1);
      if (v22)
        return kdu_params::get(v22, a2, v12, a4, a5, 1, a7, a8);
    }
  }
  if (!v20)
    return 0;
  v24 = *(_DWORD *)(v16 + 36);
  if (v24 <= v12 && a7 && (*(_BYTE *)(v16 + 16) & 2) != 0)
    v12 = v24 - 1;
  result = 0;
  if ((v12 & 0x80000000) == 0 && v12 < v24)
  {
    v25 = v17 + 24 * a4;
    if (*(_BYTE *)(v25 + 24 * *(_DWORD *)(v16 + 32) * v12 + 16))
    {
      *a5 = *(_DWORD *)(v25 + 24 * *(_DWORD *)(v16 + 32) * v12);
      return 1;
    }
    return 0;
  }
  return result;
}

void sub_187F2BA54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2BA60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

uint64_t kdu_params::get(kdu_params *this, const char *a2, int a3, int a4, BOOL *a5, int a6, _BOOL4 a7, _BOOL4 a8)
{
  int v12;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  kdu_params *v20;
  kdu_params *v21;
  uint64_t result;
  int v23;
  _OWORD v25[2];
  uint64_t v26;
  char v27[16];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if ((a4 | a3) < 0)
    kdu_params::get();
  v12 = a3;
  v15 = *((_QWORD *)this + 12);
  if (!v15)
  {
LABEL_10:
    *(_QWORD *)&v29 = 0;
    *(_OWORD *)v27 = 0u;
    v28 = 0u;
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, "Attempt to access a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, ", \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, a2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, "\"!");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  v16 = *((_QWORD *)this + 12);
  while (*(const char **)v16 != a2)
  {
    v16 = *(_QWORD *)(v16 + 56);
    if (!v16)
    {
      while (strcmp(*(const char **)v15, a2))
      {
        v15 = *(_QWORD *)(v15 + 56);
        if (!v15)
          goto LABEL_10;
      }
      v16 = v15;
      break;
    }
  }
  if (*(_DWORD *)(v16 + 32) <= a4)
  {
    v26 = 0;
    memset(v25, 0, sizeof(v25));
    kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, "Attempt to access a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, " \"");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, a2);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, "The field index is ");
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    *(_OWORD *)v27 = 0u;
    if (BYTE8(v25[0]))
      sprintf(v27, "%x");
    else
      sprintf(v27, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v25[0] + 16))(v25, v27);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, ".");
    kdu_error::~kdu_error((kdu_error *)v25);
  }
  v17 = *(_QWORD *)(v16 + 40) + 24 * a4;
  if (**(_BYTE **)(v17 + 8) != 66)
  {
    *(_QWORD *)&v29 = 0;
    *(_OWORD *)v27 = 0u;
    v28 = 0u;
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, "Attempting to access a non-BOOLean code-stream attribute field with the BOOLean access method!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, " \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, a2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, "\".");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  if (*(_BYTE *)(v16 + 48))
    v18 = a8;
  else
    v18 = 1;
  if (*(int *)(v16 + 36) > 0)
    v19 = v18;
  else
    v19 = 0;
  if ((v19 & 1) == 0 && a6 && (!*((_DWORD *)this + 6) || *((_BYTE *)this + 42)))
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
    {
      v20 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), -1, 0, 1);
      if (v20)
      {
        if (*((_DWORD *)v20 + 4) == *((_DWORD *)this + 4)
          && (kdu_params::get(v20, a2, v12, a4, a5, 0, a7, a8) & 1) != 0)
        {
          return 1;
        }
      }
    }
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
    {
      v21 = (kdu_params *)kdu_params::access_relation(this, -1, *((_DWORD *)this + 5), *((_DWORD *)this + 6), 1);
      if (v21)
        return kdu_params::get(v21, a2, v12, a4, a5, 1, a7, a8);
    }
  }
  if (!v19)
    return 0;
  v23 = *(_DWORD *)(v16 + 36);
  if (v23 <= v12 && a7 && (*(_BYTE *)(v16 + 16) & 2) != 0)
    v12 = v23 - 1;
  result = 0;
  if ((v12 & 0x80000000) == 0 && v12 < v23)
  {
    if (*(_BYTE *)(v17 + 24 * *(_DWORD *)(v16 + 32) * v12 + 16))
    {
      *a5 = *(_DWORD *)(v17 + 24 * *(_DWORD *)(v16 + 32) * v12) != 0;
      return 1;
    }
    return 0;
  }
  return result;
}

void sub_187F2BEEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2BEF8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

uint64_t kdu_params::get(kdu_params *this, const char *a2, int a3, int a4, float *a5, int a6, _BOOL4 a7, _BOOL4 a8)
{
  int v12;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  kdu_params *v20;
  kdu_params *v21;
  uint64_t result;
  int v23;
  _OWORD v25[2];
  uint64_t v26;
  char v27[16];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if ((a4 | a3) < 0)
    kdu_params::get();
  v12 = a3;
  v15 = *((_QWORD *)this + 12);
  if (!v15)
  {
LABEL_10:
    *(_QWORD *)&v29 = 0;
    *(_OWORD *)v27 = 0u;
    v28 = 0u;
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, "Attempt to access a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, ", \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, a2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, "\"!");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  v16 = *((_QWORD *)this + 12);
  while (*(const char **)v16 != a2)
  {
    v16 = *(_QWORD *)(v16 + 56);
    if (!v16)
    {
      while (strcmp(*(const char **)v15, a2))
      {
        v15 = *(_QWORD *)(v15 + 56);
        if (!v15)
          goto LABEL_10;
      }
      v16 = v15;
      break;
    }
  }
  if (*(_DWORD *)(v16 + 32) <= a4)
  {
    v26 = 0;
    memset(v25, 0, sizeof(v25));
    kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, "Attempt to access a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, " \"");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, a2);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, "The field index is ");
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    *(_OWORD *)v27 = 0u;
    if (BYTE8(v25[0]))
      sprintf(v27, "%x");
    else
      sprintf(v27, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v25[0] + 16))(v25, v27);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, ".");
    kdu_error::~kdu_error((kdu_error *)v25);
  }
  v17 = *(_QWORD *)(v16 + 40) + 24 * a4;
  if (**(_BYTE **)(v17 + 8) != 70)
  {
    *(_QWORD *)&v29 = 0;
    *(_OWORD *)v27 = 0u;
    v28 = 0u;
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, "Attempting to access an integer code-stream parameter attribute field with the floating point access method!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, " \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, a2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v27 + 16))(v27, "\".");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  if (*(_BYTE *)(v16 + 48))
    v18 = a8;
  else
    v18 = 1;
  if (*(int *)(v16 + 36) > 0)
    v19 = v18;
  else
    v19 = 0;
  if ((v19 & 1) == 0 && a6 && (!*((_DWORD *)this + 6) || *((_BYTE *)this + 42)))
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
    {
      v20 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), -1, 0, 1);
      if (v20)
      {
        if (*((_DWORD *)v20 + 4) == *((_DWORD *)this + 4)
          && (kdu_params::get(v20, a2, v12, a4, a5, 0, a7, a8) & 1) != 0)
        {
          return 1;
        }
      }
    }
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
    {
      v21 = (kdu_params *)kdu_params::access_relation(this, -1, *((_DWORD *)this + 5), *((_DWORD *)this + 6), 1);
      if (v21)
        return kdu_params::get(v21, a2, v12, a4, a5, 1, a7, a8);
    }
  }
  if (!v19)
    return 0;
  v23 = *(_DWORD *)(v16 + 36);
  if (v23 <= v12 && a7 && (*(_BYTE *)(v16 + 16) & 2) != 0)
    v12 = v23 - 1;
  result = 0;
  if ((v12 & 0x80000000) == 0 && v12 < v23)
  {
    if (*(_BYTE *)(v17 + 24 * *(_DWORD *)(v16 + 32) * v12 + 16))
    {
      *a5 = *(float *)(v17 + 24 * *(_DWORD *)(v16 + 32) * v12);
      return 1;
    }
    return 0;
  }
  return result;
}

void sub_187F2C37C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2C388(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

const char *kdu_params::set(kdu_params *this, const char *__s2, int a3, int a4, int *a5)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v11;
  const char *result;
  int v13;
  int v14;
  int v15;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  char v25[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if ((a4 | a3) < 0)
    kdu_params::set();
  v7 = *((_QWORD *)this + 12);
  if (!v7)
  {
LABEL_50:
    *(_QWORD *)&v27 = 0;
    *(_OWORD *)v25 = 0u;
    v26 = 0u;
    kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, "Attempt to set a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, ", \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, __s2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, "\"!");
    kdu_error::~kdu_error((kdu_error *)v25);
  }
  v8 = a5;
  v11 = *((_QWORD *)this + 12);
  while (*(const char **)v11 != __s2)
  {
    v11 = *(_QWORD *)(v11 + 56);
    if (!v11)
    {
      while (strcmp(*(const char **)v7, __s2))
      {
        v7 = *(_QWORD *)(v7 + 56);
        if (!v7)
          goto LABEL_50;
      }
      v11 = v7;
      break;
    }
  }
  if ((*(_BYTE *)(v11 + 16) & 4) != 0 && *((_DWORD *)this + 5) != -1)
  {
    *(_QWORD *)&v27 = 0;
    *(_OWORD *)v25 = 0u;
    v26 = 0u;
    kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, "Attempt to set a non-tile-specific code-stream attribute in a specific component!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, " \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, __s2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, "\".");
    kdu_error::~kdu_error((kdu_error *)v25);
  }
  if (*(_DWORD *)(v11 + 32) <= a4)
  {
    v24 = 0;
    v22 = 0u;
    v23 = 0u;
    kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, "Attempt to set a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, " \"");
    (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, __s2);
    (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, "\".\n");
    (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, "The field index is ");
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    *(_OWORD *)v25 = 0u;
    if (BYTE8(v22))
      sprintf(v25, "%x");
    else
      sprintf(v25, "%d");
    (*(void (**)(__int128 *, char *))(v22 + 16))(&v22, v25);
    (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, ".");
    kdu_error::~kdu_error((kdu_error *)&v22);
  }
  result = *(const char **)(*(_QWORD *)(v11 + 40) + 24 * a4 + 8);
  v13 = *(unsigned __int8 *)result;
  switch(*result)
  {
    case 'B':
      if (v8 >= 2)
      {
        *(_QWORD *)&v27 = 0;
        *(_OWORD *)v25 = 0u;
        v26 = 0u;
        kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, "Attempting to set a BOOLean code-stream parameter attribute field with an integer not equal to 0 or 1!\nThe attribute name is");
        (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, " \"");
        (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, __s2);
        (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, "\".");
        kdu_error::~kdu_error((kdu_error *)v25);
      }
      goto LABEL_38;
    case 'C':
    case 'I':
      goto LABEL_38;
    case 'D':
    case 'E':
    case 'G':
    case 'H':
      goto LABEL_51;
    case 'F':
      *(_QWORD *)&v27 = 0;
      *(_OWORD *)v25 = 0u;
      v26 = 0u;
      kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, "Attempting to set a floating point code-stream parameter attribute field with the integer access method!\nThe attribute name is");
      (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, " \"");
      (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, __s2);
      (*(void (**)(char *, const char *))(*(_QWORD *)v25 + 16))(v25, "\".");
      kdu_error::~kdu_error((kdu_error *)v25);
    default:
      if (v13 == 40)
      {
        v28 = 0u;
        v29 = 0u;
        v26 = 0u;
        v27 = 0u;
        *(_OWORD *)v25 = 0u;
        v21 = 0;
        do
          result = parse_translator_entry(result + 1, 0x2Cu, v25, &v21, a5);
        while (*result == 44 && v21 != v8);
        if (v21 != v8)
        {
          v24 = 0;
          v22 = 0u;
          v23 = 0u;
          kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, "Attempting to set a code-stream attribute field using an integer value which does not match any of the defined translation values for the field!\nThe attribute name is");
          (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, " \"");
          (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, __s2);
          (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, "\".");
          kdu_error::~kdu_error((kdu_error *)&v22);
        }
      }
      else
      {
        if (v13 != 91)
LABEL_51:
          kdu_params::set();
        v14 = 0;
        v28 = 0u;
        v29 = 0u;
        v26 = 0u;
        v27 = 0u;
        *(_OWORD *)v25 = 0u;
        v21 = 0;
        do
        {
          result = parse_translator_entry(result + 1, 0x7Cu, v25, &v21, a5);
          v15 = v21;
          if ((v21 & ~v8) != 0)
            v15 = 0;
          v14 |= v15;
        }
        while (*result == 124);
        if (v14 != v8)
        {
          v24 = 0;
          v22 = 0u;
          v23 = 0u;
          kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, "Attempting to set a code-stream attribute field using an integer value which is incompatible with the flags defined for the field!\nThe attribute name is");
          (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, " \"");
          (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, __s2);
          (*(void (**)(__int128 *, const char *))(v22 + 16))(&v22, "\".");
          kdu_error::~kdu_error((kdu_error *)&v22);
        }
      }
LABEL_38:
      v17 = *(_DWORD *)(v11 + 36);
      if (v17 <= a3)
        result = (const char *)kd_attribute::augment_records(v11, a3 + 1);
      if (a3 < 0 || *(_DWORD *)(v11 + 36) <= a3)
        kdu_params::set();
      v18 = *(_QWORD *)(v11 + 40) + 24 * a4 + 24 * *(_DWORD *)(v11 + 32) * a3;
      if ((!*(_BYTE *)(v18 + 16) || v17 <= a3 || *(_DWORD *)v18 != v8) && !*((_BYTE *)this + 104))
      {
        *((_BYTE *)this + 104) = 1;
        v19 = *((_QWORD *)this + 10);
        *(_BYTE *)(v19 + 104) = 1;
        v20 = **(_QWORD **)(v19 + 64);
        *(_BYTE *)(v20 + 104) = 1;
        *(_BYTE *)(*(_QWORD *)(v20 + 48) + 104) = 1;
      }
      *(_BYTE *)(v18 + 16) = 1;
      *(_DWORD *)v18 = v8;
      *((_BYTE *)this + 36) = 0;
      return result;
  }
}

void sub_187F2CA50(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2CA5C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

uint64_t kdu_params::set(uint64_t this, const char *__s2, int a3, int a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD v16[2];
  uint64_t v17;
  char v18[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((a4 | a3) < 0)
    kdu_params::set();
  v6 = this;
  v7 = *(_QWORD *)(this + 96);
  if (!v7)
  {
LABEL_32:
    *(_QWORD *)&v20 = 0;
    *(_OWORD *)v18 = 0u;
    v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "Attempt to set a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, ", \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, __s2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "\"!");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  v11 = *(_QWORD *)(this + 96);
  while (*(const char **)v11 != __s2)
  {
    v11 = *(_QWORD *)(v11 + 56);
    if (!v11)
    {
      while (1)
      {
        this = strcmp(*(const char **)v7, __s2);
        if (!(_DWORD)this)
          break;
        v7 = *(_QWORD *)(v7 + 56);
        if (!v7)
          goto LABEL_32;
      }
      v11 = v7;
      break;
    }
  }
  if ((*(_BYTE *)(v11 + 16) & 4) != 0 && *(_DWORD *)(v6 + 20) != -1)
  {
    *(_QWORD *)&v20 = 0;
    *(_OWORD *)v18 = 0u;
    v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "Attempt to set a non-tile-specific code-stream attribute in a specific component!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, " \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, __s2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "\".");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  if (*(_DWORD *)(v11 + 32) <= a4)
  {
    v17 = 0;
    memset(v16, 0, sizeof(v16));
    kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, "Attempt to set a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, " \"");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, __s2);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, "The field index is ");
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    *(_OWORD *)v18 = 0u;
    if (BYTE8(v16[0]))
      sprintf(v18, "%x");
    else
      sprintf(v18, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v16[0] + 16))(v16, v18);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, ".");
    kdu_error::~kdu_error((kdu_error *)v16);
  }
  if (**(_BYTE **)(*(_QWORD *)(v11 + 40) + 24 * a4 + 8) != 66)
  {
    *(_QWORD *)&v20 = 0;
    *(_OWORD *)v18 = 0u;
    v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "Attempting to set a non-BOOLean code-stream parameter attribute field with the BOOLean access method!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, " \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, __s2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "\".");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  v12 = *(_DWORD *)(v11 + 36);
  if (v12 <= a3)
    this = kd_attribute::augment_records(v11, a3 + 1);
  if (a3 < 0 || *(_DWORD *)(v11 + 36) <= a3)
    kdu_params::set();
  v13 = *(_QWORD *)(v11 + 40) + 24 * a4 + 24 * *(_DWORD *)(v11 + 32) * a3;
  if ((!*(_BYTE *)(v13 + 16) || v12 <= a3 || *(_DWORD *)v13 != a5) && !*(_BYTE *)(v6 + 104))
  {
    *(_BYTE *)(v6 + 104) = 1;
    v14 = *(_QWORD *)(v6 + 80);
    *(_BYTE *)(v14 + 104) = 1;
    v15 = **(_QWORD **)(v14 + 64);
    *(_BYTE *)(v15 + 104) = 1;
    *(_BYTE *)(*(_QWORD *)(v15 + 48) + 104) = 1;
  }
  *(_BYTE *)(v13 + 16) = 1;
  *(_DWORD *)v13 = a5;
  *(_BYTE *)(v6 + 36) = 0;
  return this;
}

void sub_187F2CF08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2CF14(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

uint64_t kdu_params::set(uint64_t this, const char *__s2, int a3, int a4, double a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  _OWORD v18[2];
  uint64_t v19;
  char v20[16];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if ((a4 | a3) < 0)
    kdu_params::set();
  v6 = this;
  v7 = *(_QWORD *)(this + 96);
  if (!v7)
  {
LABEL_32:
    *(_QWORD *)&v22 = 0;
    *(_OWORD *)v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)v20, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, "Attempt to set a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, ", \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, __s2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, "\"!");
    kdu_error::~kdu_error((kdu_error *)v20);
  }
  v11 = *(_QWORD *)(this + 96);
  while (*(const char **)v11 != __s2)
  {
    v11 = *(_QWORD *)(v11 + 56);
    if (!v11)
    {
      while (1)
      {
        this = strcmp(*(const char **)v7, __s2);
        if (!(_DWORD)this)
          break;
        v7 = *(_QWORD *)(v7 + 56);
        if (!v7)
          goto LABEL_32;
      }
      v11 = v7;
      break;
    }
  }
  if ((*(_BYTE *)(v11 + 16) & 4) != 0 && *(_DWORD *)(v6 + 20) != -1)
  {
    *(_QWORD *)&v22 = 0;
    *(_OWORD *)v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)v20, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, "Attempt to set a non-tile-specific code-stream attribute in a specific component!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, " \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, __s2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, "\".");
    kdu_error::~kdu_error((kdu_error *)v20);
  }
  if (*(_DWORD *)(v11 + 32) <= a4)
  {
    v19 = 0;
    memset(v18, 0, sizeof(v18));
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, "Attempt to set a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, " \"");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, __s2);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, "The field index is ");
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    *(_OWORD *)v20 = 0u;
    if (BYTE8(v18[0]))
      sprintf(v20, "%x");
    else
      sprintf(v20, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v18[0] + 16))(v18, v20);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, ".");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  if (**(_BYTE **)(*(_QWORD *)(v11 + 40) + 24 * a4 + 8) != 70)
  {
    *(_QWORD *)&v22 = 0;
    *(_OWORD *)v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)v20, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, "Attempting to set an integer code-stream parameter attribute field with the floating point access method!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, " \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, __s2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v20 + 16))(v20, "\".");
    kdu_error::~kdu_error((kdu_error *)v20);
  }
  v12 = *(_DWORD *)(v11 + 36);
  if (v12 <= a3)
    this = kd_attribute::augment_records(v11, a3 + 1);
  if (a3 < 0 || *(_DWORD *)(v11 + 36) <= a3)
    kdu_params::set();
  v13 = *(_QWORD *)(v11 + 40) + 24 * a4 + 24 * *(_DWORD *)(v11 + 32) * a3;
  if (!*(_BYTE *)(v13 + 16) || v12 <= a3 || (v14 = a5, *(float *)v13 != v14))
  {
    if (!*(_BYTE *)(v6 + 104))
    {
      *(_BYTE *)(v6 + 104) = 1;
      v15 = *(_QWORD *)(v6 + 80);
      *(_BYTE *)(v15 + 104) = 1;
      v16 = **(_QWORD **)(v15 + 64);
      *(_BYTE *)(v16 + 104) = 1;
      *(_BYTE *)(*(_QWORD *)(v16 + 48) + 104) = 1;
    }
  }
  *(_BYTE *)(v13 + 16) = 1;
  v17 = a5;
  *(float *)v13 = v17;
  *(_BYTE *)(v6 + 36) = 0;
  return this;
}

void sub_187F2D398(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2D3A4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

uint64_t kdu_params::set_derived(uint64_t this, const char *__s2)
{
  uint64_t v3;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v3 = *(_QWORD *)(this + 96);
  if (!v3)
  {
LABEL_10:
    v6 = 0;
    memset(v5, 0, sizeof(v5));
    kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "Invalid attribute name");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, ", \"");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, __s2);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "\", ");
    kdu_error::~kdu_error((kdu_error *)v5);
  }
  v4 = *(_QWORD *)(this + 96);
  while (*(const char **)v4 != __s2)
  {
    v4 = *(_QWORD *)(v4 + 56);
    if (!v4)
    {
      while (1)
      {
        this = strcmp(*(const char **)v3, __s2);
        if (!(_DWORD)this)
          break;
        v3 = *(_QWORD *)(v3 + 56);
        if (!v3)
          goto LABEL_10;
      }
      v4 = v3;
      break;
    }
  }
  *(_BYTE *)(v4 + 48) = 1;
  return this;
}

void sub_187F2D4FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F2D508()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_params::parse_string(kdu_params *this, char *a2)
{
  char *v2;
  unsigned int v3;
  kdu_params *v4;
  const char **v5;
  size_t v6;
  const char *v7;
  _BOOL8 v8;
  char *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  kdu_params *v16;
  char *v18;
  int *v19;
  const char *v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char **v29;
  int v30;
  float v31;
  char *v32;
  char *v33;
  int v34;
  char *v35;
  int v36;
  int v37;
  BOOL v38;
  int v39;
  int v40;
  BOOL v41;
  char v42;
  char *v43;
  int v44;
  float v45;
  int v46;
  int v47;
  char *v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  int v56;
  float v57;
  char v59;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  int v64;
  char *__endptr;
  char v66[16];
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;

  v2 = a2;
  v71 = *MEMORY[0x1E0C80C00];
  while (1)
  {
    __endptr = v2;
    v3 = *v2;
    if (v3 <= 0x3D)
    {
      if (((1 << v3) & 0x100000600) != 0)
      {
        *(_QWORD *)&v68 = 0;
        *(_OWORD *)v66 = 0u;
        v67 = 0u;
        kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
        (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "White space characters are illegal!");
        kdu_error::~kdu_error((kdu_error *)v66);
      }
      if (((1 << v3) & 0x2400000000000001) != 0)
        break;
    }
    ++v2;
  }
  v4 = this;
  v5 = (const char **)*((_QWORD *)this + 12);
  if (!v5)
  {
LABEL_12:
    if (*((kdu_params **)this + 6) != this)
      return 0;
    do
    {
      v4 = (kdu_params *)*((_QWORD *)v4 + 7);
      v8 = v4 != 0;
    }
    while (v4 && (kdu_params::parse_string(v4, a2) & 1) == 0);
    return v8;
  }
  v6 = v2 - a2;
  while (1)
  {
    v7 = *v5;
    if (!strncmp(*v5, a2, v6) && strlen(v7) == v6)
      break;
    v5 = (const char **)v5[7];
    if (!v5)
      goto LABEL_12;
  }
  if (!v3)
  {
    *(_QWORD *)&v68 = 0;
    *(_OWORD *)v66 = 0u;
    v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Attribute");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " \"");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, *v5);
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\" ");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "is missing parameters:\n\n\t");
    kd_attribute::describe((kd_attribute *)v5, (kdu_message *)v66, *((unsigned __int8 *)this + 38), *((unsigned __int8 *)this + 39), *((unsigned __int8 *)this + 42), 1);
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\nParameter values must be separated from the attribute name and optional location specifiers by an '=' sign!\n");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (v3 == 58)
  {
    v9 = v2 + 1;
    v10 = -1;
    __endptr = v2 + 1;
    v11 = -2;
    v12 = -2;
    while (1)
    {
      v13 = *v9;
      if (!*v9 || v13 == 61)
        break;
      if (v13 == 84 && v11 <= -2)
      {
        v11 = strtol(v9 + 1, &__endptr, 10);
      }
      else if (v13 == 67 && v12 <= -2)
      {
        v12 = strtol(v9 + 1, &__endptr, 10);
      }
      else
      {
        if (v13 != 73 || (v10 & 0x80000000) == 0)
        {
          *(_QWORD *)&v68 = 0;
          *(_OWORD *)v66 = 0u;
          v67 = 0u;
          kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed location specifier encountered in attribute string");
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
          (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Tile specifiers following the the colon must have the form \"T<num>\", while component specifiers must have the form \"C<num>\" and index specifiers must have the form \"I<num>\". There may be at most one of each!");
          kdu_error::~kdu_error((kdu_error *)v66);
        }
        v10 = strtol(v9 + 1, &__endptr, 10);
      }
      v9 = __endptr;
    }
    v4 = this;
    if (v11 > -2)
      goto LABEL_41;
  }
  else
  {
    v12 = -2;
    v10 = -1;
  }
  v11 = *((_DWORD *)v4 + 4);
LABEL_41:
  if (v12 <= -2)
    v12 = *((_DWORD *)v4 + 5);
  if (v10 < 0)
  {
    if (v11 == *((_DWORD *)v4 + 4) && v12 == *((_DWORD *)v4 + 5))
    {
      v10 = *((_DWORD *)v4 + 6);
    }
    else
    {
      if (*((_BYTE *)v4 + 42))
      {
        *(_QWORD *)&v68 = 0;
        *(_OWORD *)v66 = 0u;
        v67 = 0u;
        kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed location specifier encountered in attribute string");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
        (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "You must supply an index specifier of the form \"I<num>\" for this type of parameter.");
        kdu_error::~kdu_error((kdu_error *)v66);
      }
      v10 = 0;
    }
  }
  else if (!*((_BYTE *)v4 + 42))
  {
    *(_QWORD *)&v68 = 0;
    *(_OWORD *)v66 = 0u;
    v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed location specifier encountered in attribute string");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
    (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "This type of parameter cannot be used with an index specifier (i.e., a specifier of the form \"I<num>\").");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (*((_DWORD *)v4 + 4) != v11 || *((_DWORD *)v4 + 5) != v12 || *((_DWORD *)v4 + 6) != v10)
  {
    v16 = (kdu_params *)kdu_params::access_relation(v4, v11, v12, v10, 0);
    if (!v16)
    {
      *(_QWORD *)&v68 = 0;
      *(_OWORD *)v66 = 0u;
      v67 = 0u;
      kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Attribute string");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
      (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\", ");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "refers to a non-existent tile-component!");
      kdu_error::~kdu_error((kdu_error *)v66);
    }
    return kdu_params::parse_string(v16, a2);
  }
  if (*((_BYTE *)v4 + 37))
  {
    *(_QWORD *)&v68 = 0;
    *(_OWORD *)v66 = 0u;
    v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (((_BYTE)v5[2] & 4) != 0 && *((_DWORD *)v4 + 5) != -1)
  {
    *(_QWORD *)&v68 = 0;
    *(_OWORD *)v66 = 0u;
    v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Attempt to set a non-tile-specific code-stream attribute in a specific component!\nProblem occurred while parsing the attribute string");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
    (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\".");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (*__endptr != 61)
  {
    *(_QWORD *)&v68 = 0;
    *(_OWORD *)v66 = 0u;
    v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
    (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Parameter values must be separated from the attribute name and optional location specifiers by an '=' sign!");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (*((int *)v5 + 9) >= 1 && *((_BYTE *)v5 + 49))
  {
    if (!*((_BYTE *)v4 + 40)
      || *((_BYTE *)v4 + 42)
      || !*((_QWORD *)v4 + 11) && (v54 = kdu_params::new_instance(v4), v4 = this, !v54))
    {
      *(_QWORD *)&v68 = 0;
      *(_OWORD *)v66 = 0u;
      v67 = 0u;
      kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "The supplied attribute string");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
      (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\", ");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "refers to code-stream parameters which have already been parsed out of some string.  Moreover, multiple instances of this attribute are not permitted here!");
      kdu_error::~kdu_error((kdu_error *)v66);
    }
    v16 = (kdu_params *)*((_QWORD *)v4 + 11);
    if (!v16)
      kdu_params::parse_string();
    return kdu_params::parse_string(v16, a2);
  }
  kdu_params::delete_unparsed_attribute((uint64_t)v4, *v5);
  *((_BYTE *)v5 + 49) = 1;
  v18 = __endptr;
  v55 = setlocale(4, 0);
  setlocale(4, "C");
  v20 = v18 + 1;
  v21 = v18[1];
  if (!v18[1])
    goto LABEL_173;
  v22 = 0;
  v59 = 0;
  do
  {
    if (v22)
    {
      if (v21 != 44)
      {
        *(_QWORD *)&v68 = 0;
        *(_OWORD *)v66 = 0u;
        v67 = 0u;
        kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
        (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Problem encountered at");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " \"");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, v20);
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\".\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Records must be separated by commas.");
        kdu_error::~kdu_error((kdu_error *)v66);
      }
      if (((_BYTE)v5[2] & 1) == 0)
      {
        *(_QWORD *)&v68 = 0;
        *(_OWORD *)v66 = 0u;
        v67 = 0u;
        kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
        (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Attribute does not support multiple parameter records!");
        kdu_error::~kdu_error((kdu_error *)v66);
      }
      v23 = *(unsigned __int8 *)++v20;
      v21 = v23;
    }
    if (v21 == 123)
    {
      ++v20;
    }
    else if (*((int *)v5 + 8) >= 2)
    {
      *(_QWORD *)&v68 = 0;
      *(_OWORD *)v66 = 0u;
      v67 = 0u;
      kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
      (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Problem encountered at");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " \"");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, v20);
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\".\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Records must be enclosed by curly braces, i.e., '{' and '}'.");
      kdu_error::~kdu_error((kdu_error *)v66);
    }
    v56 = v21;
    if (*((_DWORD *)v5 + 9) <= v22)
    {
      kd_attribute::augment_records((uint64_t)v5, v22 + 1);
      v59 = 1;
    }
    LODWORD(v24) = *((_DWORD *)v5 + 8);
    if ((int)v24 < 1)
    {
      v43 = (char *)v20;
      goto LABEL_165;
    }
    v25 = 0;
    do
    {
      if (v25)
      {
        if (*v20 != 44)
        {
          *(_QWORD *)&v68 = 0;
          *(_OWORD *)v66 = 0u;
          v67 = 0u;
          kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
          (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Problem encountered at");
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " \"");
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, v20);
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\".\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Fields must be separated by commas.");
          kdu_error::~kdu_error((kdu_error *)v66);
        }
        ++v20;
      }
      v26 = (uint64_t)&v5[5][24 * (int)v24 * v22];
      v27 = v26 + 24 * v25;
      v29 = (char **)(v27 + 8);
      v28 = *(char **)(v27 + 8);
      v30 = *v28;
      switch(*v28)
      {
        case 'B':
          v31 = *(float *)v27;
          if (!strncmp(v20, "yes", 3uLL))
          {
            *(_DWORD *)v27 = 1;
            v43 = (char *)(v20 + 3);
          }
          else
          {
            if (strncmp(v20, "no", 2uLL))
            {
              *(_QWORD *)&v68 = 0;
              *(_OWORD *)v66 = 0u;
              v67 = 0u;
              kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
              (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
              (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
              (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
              (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
              (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Problem encountered at");
              (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " \"");
              (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, v20);
              (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\".\n");
              (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Expected a BOOLean field identifier, i.e., one of \"yes\" or \"no\".");
              kdu_error::~kdu_error((kdu_error *)v66);
            }
            *(_DWORD *)v27 = 0;
            v43 = (char *)(v20 + 2);
          }
          if (!*(_BYTE *)(v26 + 24 * v25 + 16) || LODWORD(v31) != *(_DWORD *)v27)
            v59 = 1;
          goto LABEL_162;
        case 'C':
          LODWORD(v61) = 0;
          v44 = (*(uint64_t (**)(kdu_params *, const char *, const char *, uint64_t, __int128 *))(*(_QWORD *)this + 56))(this, v20, *v5, v25, &v61);
          if (!*(_BYTE *)(v26 + 24 * v25 + 16) || *(_DWORD *)v27 != (_DWORD)v61)
            v59 = 1;
          *(_DWORD *)v27 = v61;
          if (v44 <= 0)
          {
            *(_QWORD *)&v68 = 0;
            *(_OWORD *)v66 = 0u;
            v67 = 0u;
            kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
            (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Problem encountered at");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " \"");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, v20);
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\".\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Attempt to parse custom string representation failed.  Read usage information carefully.");
            kdu_error::~kdu_error((kdu_error *)v66);
          }
          v43 = (char *)&v20[v44];
          goto LABEL_162;
        case 'D':
        case 'E':
        case 'G':
        case 'H':
          goto LABEL_178;
        case 'F':
          v45 = strtod(v20, &__endptr);
          if (!*(_BYTE *)(v26 + 24 * v25 + 16) || *(float *)v27 != v45)
            v59 = 1;
          *(float *)v27 = v45;
          v43 = __endptr;
          if (__endptr == v20)
          {
            *(_QWORD *)&v68 = 0;
            *(_OWORD *)v66 = 0u;
            v67 = 0u;
            kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
            (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Problem encountered at");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " \"");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, v20);
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\".\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Expected a floating point field.");
            kdu_error::~kdu_error((kdu_error *)v66);
          }
          goto LABEL_162;
        case 'I':
          v46 = strtol(v20, &__endptr, 10);
          if (!*(_BYTE *)(v26 + 24 * v25 + 16) || *(_DWORD *)v27 != v46)
            v59 = 1;
          *(_DWORD *)v27 = v46;
          v43 = __endptr;
          if (__endptr == v20)
          {
            *(_QWORD *)&v68 = 0;
            *(_OWORD *)v66 = 0u;
            v67 = 0u;
            kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
            (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Problem encountered at");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " \"");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, v20);
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\".\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Expected an integer field.");
            kdu_error::~kdu_error((kdu_error *)v66);
          }
          goto LABEL_162;
        default:
          if (v30 != 40)
          {
            if (v30 != 91)
LABEL_178:
              kdu_params::parse_string();
            v57 = *(float *)v27;
            *(_DWORD *)v27 = 0;
            while (1)
            {
              v69 = 0u;
              v70 = 0u;
              v67 = 0u;
              v68 = 0u;
              *(_OWORD *)v66 = 0u;
              v64 = 0;
              v32 = *v29;
              if (*v20 == 124)
                v33 = (char *)(v20 + 1);
              else
                v33 = (char *)v20;
              do
              {
                v32 = parse_translator_entry(v32 + 1, 0x7Cu, v66, &v64, v19);
                v34 = v66[0];
                v20 = v33;
                if (v66[0])
                {
                  v35 = &v66[1];
                  v20 = v33;
                  while (v34 == *(unsigned __int8 *)v20)
                  {
                    ++v20;
                    v36 = *v35++;
                    v34 = v36;
                    if (!v36)
                      goto LABEL_107;
                  }
                }
                else
                {
LABEL_107:
                  v37 = *(unsigned __int8 *)v20;
                  v38 = (v37 - 124) < 2 || v37 == 0;
                  if (v38 || v37 == 44)
                    goto LABEL_119;
                }
              }
              while (*v32 == 124);
              if (*v33 != 48 || (v39 = v33[1], (v39 - 124) >= 2) && v39 != 44 && v33[1])
              {
                v63 = 0;
                v61 = 0u;
                v62 = 0u;
                kdu_error::kdu_error((kdu_error *)&v61, "Kakadu Core Error:\n");
                (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, "Malformed attribute string");
                (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, ", \"");
                (*(void (**)(__int128 *, char *))(v61 + 16))(&v61, a2);
                (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, "\"!\n");
                (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, "Problem encountered at");
                (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, " \"");
                (*(void (**)(__int128 *, char *))(v61 + 16))(&v61, v33);
                (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, "\".\n");
                display_options(*v29, (kdu_message *)&v61);
                kdu_error::~kdu_error((kdu_error *)&v61);
              }
              v64 = 0;
              v20 = v33 + 1;
LABEL_119:
              v40 = *(_DWORD *)v27 | v64;
              *(_DWORD *)v27 = v40;
              if (*v20 != 124)
              {
                if (*(_BYTE *)(v26 + 24 * v25 + 16))
                  v41 = LODWORD(v57) == v40;
                else
                  v41 = 0;
                v42 = !v41;
                v59 |= v42;
                v43 = (char *)v20;
                goto LABEL_162;
              }
            }
          }
          v69 = 0u;
          v70 = 0u;
          v67 = 0u;
          v68 = 0u;
          *(_OWORD *)v66 = 0u;
          v64 = 0;
          break;
      }
      while (1)
      {
        v28 = parse_translator_entry(v28 + 1, 0x2Cu, v66, &v64, v19);
        v47 = v66[0];
        v43 = (char *)v20;
        if (!v66[0])
          break;
        v48 = &v66[1];
        v43 = (char *)v20;
        while (v47 == *v43)
        {
          ++v43;
          v49 = *v48++;
          v47 = v49;
          if (!v49)
            goto LABEL_148;
        }
LABEL_151:
        if (*v28 != 44)
        {
          v63 = 0;
          v61 = 0u;
          v62 = 0u;
          kdu_error::kdu_error((kdu_error *)&v61, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, "Malformed attribute string");
          (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, ", \"");
          (*(void (**)(__int128 *, char *))(v61 + 16))(&v61, a2);
          (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, "\"!\n");
          (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, "Problem encountered at");
          (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, " \"");
          (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, v20);
          (*(void (**)(__int128 *, const char *))(v61 + 16))(&v61, "\".\n");
          display_options(*v29, (kdu_message *)&v61);
          kdu_error::~kdu_error((kdu_error *)&v61);
        }
      }
LABEL_148:
      v50 = *v43;
      if (*v43 && v50 != 44 && v50 != 125)
        goto LABEL_151;
      if (!*(_BYTE *)(v26 + 24 * v25 + 16) || *(_DWORD *)v27 != v64)
        v59 = 1;
      *(_DWORD *)v27 = v64;
LABEL_162:
      *(_BYTE *)(v26 + 24 * v25++ + 16) = 1;
      v24 = *((int *)v5 + 8);
      v20 = v43;
    }
    while (v25 < v24);
LABEL_165:
    v51 = *v43;
    if (v51 == 125)
    {
      v51 = *++v43;
    }
    else if (v56 == 123)
    {
      *(_QWORD *)&v68 = 0;
      *(_OWORD *)v66 = 0u;
      v67 = 0u;
      kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Malformed attribute string");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, ", \"");
      (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, a2);
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\"!\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Problem encountered at");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " \"");
      (*(void (**)(char *, char *))(*(_QWORD *)v66 + 16))(v66, v43);
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "\".\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Opening brace for record is not matched by a closing brace.");
      kdu_error::~kdu_error((kdu_error *)v66);
    }
    ++v22;
    v21 = v51;
    v20 = v43;
  }
  while (v51);
  if ((v59 & 1) != 0 && !*((_BYTE *)this + 104))
  {
    *((_BYTE *)this + 104) = 1;
    v52 = *((_QWORD *)this + 10);
    *(_BYTE *)(v52 + 104) = 1;
    v53 = **(_QWORD **)(v52 + 64);
    *(_BYTE *)(v53 + 104) = 1;
    *(_BYTE *)(*(_QWORD *)(v53 + 48) + 104) = 1;
  }
LABEL_173:
  *((_BYTE *)this + 36) = 0;
  setlocale(4, v55);
  return 1;
}

void sub_187F2ED50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2ED5C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  _Unwind_Exception *v23;

  _Unwind_Resume(v23);
}

uint64_t kdu_params::delete_unparsed_attribute(uint64_t this, const char *a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  kdu_params *i;
  int v11;
  int v12;
  int v13;
  uint64_t *v14;
  BOOL v15;
  int v16;
  int v17;
  uint64_t *v18;
  int v19;
  BOOL v20;
  _OWORD v21[2];
  uint64_t v22;

  v2 = *(_QWORD *)(this + 96);
  if (!v2)
  {
LABEL_40:
    v22 = 0;
    memset(v21, 0, sizeof(v21));
    kdu_error::kdu_error((kdu_error *)v21, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v21[0] + 16))(v21, "Attempting to delete a non-existent attribute with \"kdu_params::delete_unparsed_attribute\".");
    kdu_error::~kdu_error((kdu_error *)v21);
  }
  v4 = this;
  v5 = *(_QWORD *)(this + 96);
  while (*(const char **)v5 != a2)
  {
    v5 = *(_QWORD *)(v5 + 56);
    if (!v5)
    {
      while (1)
      {
        this = strcmp(*(const char **)v2, a2);
        if (!(_DWORD)this)
          break;
        v2 = *(_QWORD *)(v2 + 56);
        if (!v2)
          goto LABEL_40;
      }
      v5 = v2;
      break;
    }
  }
  if (!*(_BYTE *)(v5 + 49))
  {
    v6 = (*(_DWORD *)(v5 + 32) * *(_DWORD *)(v5 + 36));
    if ((_DWORD)v6)
    {
      if (!*(_BYTE *)(v4 + 104))
      {
        *(_BYTE *)(v4 + 104) = 1;
        v7 = *(_QWORD *)(v4 + 80);
        *(_BYTE *)(v7 + 104) = 1;
        v8 = **(_QWORD **)(v7 + 64);
        *(_BYTE *)(v8 + 104) = 1;
        *(_BYTE *)(*(_QWORD *)(v8 + 48) + 104) = 1;
      }
      if ((int)v6 >= 1)
      {
        v9 = (_BYTE *)(*(_QWORD *)(v5 + 40) + 16);
        do
        {
          *v9 = 0;
          v9 += 24;
          --v6;
        }
        while (v6);
      }
    }
    *(_DWORD *)(v5 + 36) = 0;
  }
  if (*(_QWORD *)(v4 + 80) == v4)
  {
    for (i = *(kdu_params **)(v4 + 88); i; i = (kdu_params *)*((_QWORD *)i + 11))
      this = kdu_params::delete_unparsed_attribute(i, a2);
    if ((*(_DWORD *)(v4 + 20) & 0x80000000) != 0)
    {
      v11 = *(_DWORD *)(v4 + 16);
      v12 = *(_DWORD *)(v4 + 32);
      if (v12 >= 1)
      {
        v13 = v12 + 1;
        v14 = (uint64_t *)(*(_QWORD *)(v4 + 64) + 8 * (v13 + v13 * v11) + 8);
        do
        {
          this = *v14;
          if (*v14)
            v15 = this == v4;
          else
            v15 = 1;
          if (!v15)
            this = kdu_params::delete_unparsed_attribute((kdu_params *)this, a2);
          ++v14;
          --v13;
        }
        while (v13 > 1);
        v11 = *(_DWORD *)(v4 + 16);
      }
      if (v11 < 0)
      {
        v16 = *(_DWORD *)(v4 + 28);
        if (v16 >= 1)
        {
          v17 = *(_DWORD *)(v4 + 32);
          v18 = (uint64_t *)(*(_QWORD *)(v4 + 64) + 8 * (v17 + 1));
          v19 = v16 + 1;
          do
          {
            this = *v18;
            if (*v18)
              v20 = this == v4;
            else
              v20 = 1;
            if (!v20)
            {
              this = kdu_params::delete_unparsed_attribute((kdu_params *)this, a2);
              v17 = *(_DWORD *)(v4 + 32);
            }
            v18 += v17 + 1;
            --v19;
          }
          while (v19 > 1);
        }
      }
    }
  }
  return this;
}

void sub_187F2F0A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F2F0AC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t display_options(char *a1, kdu_message *a2)
{
  char *v3;
  int v4;
  int *v5;
  char *v6;
  char v7;
  char *v8;
  char *v9;
  char *v10;
  int v11;
  const char *v12;
  int *v13;
  char *v14;
  char v15;
  char *v16;
  char *v17;
  int v18;
  int v20;
  _OWORD v21[5];
  char v22[16];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v3 = a1;
  v27 = *MEMORY[0x1E0C80C00];
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)v22 = 0u;
  memset(v21, 0, sizeof(v21));
  v20 = 0;
  v4 = *a1;
  if (v4 != 91)
  {
    if (v4 != 40)
      display_options();
    (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "Expected one of the identifiers, ");
    v6 = 0;
    v7 = 0;
    v8 = (char *)v21;
    v9 = v22;
    do
    {
      v10 = v9;
      v3 = parse_translator_entry(v3 + 1, 0x2Cu, v9, &v20, v5);
      if ((v7 & 1) != 0)
        (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, ", ");
      if (v6)
      {
        (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "\"");
        (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v6);
        (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "\"");
        v7 = 1;
      }
      v11 = *v3;
      v9 = v8;
      v8 = v10;
      v6 = v10;
    }
    while (v11 == 44);
    if (v11 != 41)
      display_options();
    v12 = "\".";
    if ((v7 & 1) == 0)
      goto LABEL_21;
LABEL_20:
    (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, " or ");
    goto LABEL_21;
  }
  (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "Expected one or more of the identifiers, ");
  v14 = 0;
  v15 = 0;
  v16 = (char *)v21;
  v17 = v22;
  do
  {
    v10 = v17;
    v3 = parse_translator_entry(v3 + 1, 0x7Cu, v17, &v20, v13);
    if ((v15 & 1) != 0)
      (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, ", ");
    if (v14)
    {
      (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "\"");
      (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v14);
      (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "\"");
      v15 = 1;
    }
    v18 = *v3;
    v17 = v16;
    v16 = v10;
    v14 = v10;
  }
  while (v18 == 124);
  if (v18 != 93)
    display_options();
  if ((v15 & 1) != 0)
    goto LABEL_20;
LABEL_21:
  (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "\"");
  (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v10);
  return (*(uint64_t (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, v12);
}

uint64_t kdu_params::textualize_attributes(uint64_t this, kdu_message *a2, char a3)
{
  _QWORD *i;
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  char *v12;
  int v13;
  const char *v14;
  int v15;
  int v16;
  float v18;
  char *v19;
  uint64_t v21;
  int v22;
  char v23[16];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  char v28[16];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v21 = this;
  for (i = *(_QWORD **)(this + 96); i; i = (_QWORD *)i[7])
  {
    if (*((_DWORD *)i + 9) && (!*((_BYTE *)i + 48) || (a3 & 1) == 0))
    {
      (*(void (**)(kdu_message *, _QWORD))(*(_QWORD *)a2 + 16))(a2, *i);
      if ((*(_DWORD *)(v21 + 20) & 0x80000000) == 0
        || (*(_DWORD *)(v21 + 16) & 0x80000000) == 0
        || *(_BYTE *)(v21 + 42))
      {
        strcpy(v28, ":");
        (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
        if ((*(_DWORD *)(v21 + 16) & 0x80000000) == 0)
        {
          (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "T");
          v31 = 0u;
          v32 = 0u;
          v29 = 0u;
          v30 = 0u;
          *(_OWORD *)v28 = 0u;
          if (*((_BYTE *)a2 + 8))
            sprintf(v28, "%x");
          else
            sprintf(v28, "%d");
          (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
        }
        if ((*(_DWORD *)(v21 + 20) & 0x80000000) == 0)
        {
          (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "C");
          v31 = 0u;
          v32 = 0u;
          v29 = 0u;
          v30 = 0u;
          *(_OWORD *)v28 = 0u;
          if (*((_BYTE *)a2 + 8))
            sprintf(v28, "%x");
          else
            sprintf(v28, "%d");
          (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
        }
        if (*(_BYTE *)(v21 + 42))
        {
          (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "I");
          v31 = 0u;
          v32 = 0u;
          v29 = 0u;
          v30 = 0u;
          *(_OWORD *)v28 = 0u;
          if (*((_BYTE *)a2 + 8))
            sprintf(v28, "%x");
          else
            sprintf(v28, "%d");
          (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
        }
      }
      strcpy(v28, "=");
      (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
      if (*((int *)i + 9) >= 1)
      {
        v6 = 0;
        do
        {
          if (v6)
          {
            strcpy(v28, ",");
            (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
          }
          LODWORD(v7) = *((_DWORD *)i + 8);
          if ((int)v7 > 1)
          {
            strcpy(v28, "{");
            (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
            LODWORD(v7) = *((_DWORD *)i + 8);
          }
          if ((int)v7 >= 1)
          {
            v8 = 0;
            while (2)
            {
              v9 = i[5];
              if (v8)
              {
                strcpy(v28, ",");
                (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
              }
              v10 = v9 + 24 * (int)v7 * v6;
              if (!*(_BYTE *)(v10 + 24 * v8 + 16))
              {
                *(_QWORD *)&v25 = 0;
                *(_OWORD *)v23 = 0u;
                v24 = 0u;
                kdu_error::kdu_error((kdu_error *)v23, "Kakadu Core Error:\n");
                (*(void (**)(char *, const char *))(*(_QWORD *)v23 + 16))(v23, "Attempting to textualize a code-stream parameter attribute, which has only partially been set!\nError occurred in attribute");
                (*(void (**)(char *, const char *))(*(_QWORD *)v23 + 16))(v23, " \"");
                (*(void (**)(char *, _QWORD))(*(_QWORD *)v23 + 16))(v23, *i);
                (*(void (**)(char *, const char *))(*(_QWORD *)v23 + 16))(v23, "\" ");
                (*(void (**)(char *, const char *))(*(_QWORD *)v23 + 16))(v23, "in field ");
                v31 = 0u;
                v32 = 0u;
                v29 = 0u;
                v30 = 0u;
                *(_OWORD *)v28 = 0u;
                if (v23[8])
                  sprintf(v28, "%x");
                else
                  sprintf(v28, "%d");
                (*(void (**)(char *, char *))(*(_QWORD *)v23 + 16))(v23, v28);
                (*(void (**)(char *, const char *))(*(_QWORD *)v23 + 16))(v23, " of record ");
                v31 = 0u;
                v32 = 0u;
                v29 = 0u;
                v30 = 0u;
                *(_OWORD *)v28 = 0u;
                if (v23[8])
                  sprintf(v28, "%x");
                else
                  sprintf(v28, "%d");
                (*(void (**)(char *, char *))(*(_QWORD *)v23 + 16))(v23, v28);
                (*(void (**)(char *, const char *))(*(_QWORD *)v23 + 16))(v23, ".");
                kdu_error::~kdu_error((kdu_error *)v23);
              }
              v11 = (unsigned int *)(v10 + 24 * v8);
              v12 = (char *)*((_QWORD *)v11 + 1);
              v13 = *v12;
              switch(*v12)
              {
                case 'B':
                  if (*v11)
                    v14 = "yes";
                  else
                    v14 = "no";
                  (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, v14);
                  goto LABEL_73;
                case 'C':
                  (*(void (**)(uint64_t, kdu_message *, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v21 + 64))(v21, a2, *i, v8, *v11);
                  goto LABEL_73;
                case 'D':
                case 'E':
                case 'G':
                case 'H':
                  goto LABEL_80;
                case 'F':
                  v18 = *(float *)v11;
                  v31 = 0u;
                  v32 = 0u;
                  v29 = 0u;
                  v30 = 0u;
                  *(_OWORD *)v28 = 0u;
                  sprintf(v28, "%f", v18);
                  (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
                  goto LABEL_73;
                case 'I':
                  v31 = 0u;
                  v32 = 0u;
                  v29 = 0u;
                  v30 = 0u;
                  *(_OWORD *)v28 = 0u;
                  if (*((_BYTE *)a2 + 8))
                    sprintf(v28, "%x");
                  else
                    sprintf(v28, "%d");
                  goto LABEL_72;
                default:
                  if (v13 == 40)
                  {
                    v31 = 0u;
                    v32 = 0u;
                    v29 = 0u;
                    v30 = 0u;
                    *(_OWORD *)v28 = 0u;
                    *(_DWORD *)v23 = 0;
                    while (1)
                    {
                      v19 = parse_translator_entry(v12 + 1, 0x2Cu, v28, v23, v5);
                      if (*(_DWORD *)v23 == *v11)
                        break;
                      v12 = v19;
                      if (*v19 != 44)
                        kdu_params::textualize_attributes();
                    }
LABEL_72:
                    (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
                  }
                  else
                  {
                    if (v13 != 91)
LABEL_80:
                      kdu_params::textualize_attributes();
                    v26 = 0u;
                    v27 = 0u;
                    v24 = 0u;
                    v25 = 0u;
                    *(_OWORD *)v23 = 0u;
                    v22 = 0;
                    if (!*v11)
                    {
                      v31 = 0uLL;
                      v32 = 0uLL;
                      v29 = 0uLL;
                      v30 = 0uLL;
                      *(_OWORD *)v28 = 0uLL;
                      if (*((_BYTE *)a2 + 8))
                        sprintf(v28, "%x");
                      else
                        sprintf(v28, "%d");
                      (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
                    }
                    v15 = 0;
                    do
                    {
                      v12 = parse_translator_entry(v12 + 1, 0x7Cu, v23, &v22, v5);
                      v16 = v22 | v15;
                      if ((v22 & ~*v11) == 0 && v16 > v15)
                      {
                        (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v23);
                        if (v16 == *v11)
                          goto LABEL_73;
                        strcpy(v28, ",");
                        (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
                        v15 = v16;
                      }
                    }
                    while (*v12 == 124);
                    if (v15 != *v11)
                      kdu_params::textualize_attributes();
                  }
LABEL_73:
                  ++v8;
                  v7 = *((int *)i + 8);
                  if (v8 < v7)
                    continue;
                  if ((int)v7 >= 2)
                  {
                    strcpy(v28, "}");
                    (*(void (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
                  }
                  break;
              }
              break;
            }
          }
          ++v6;
        }
        while (v6 < *((_DWORD *)i + 9));
      }
      strcpy(v28, "\n");
      this = (*(uint64_t (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v28);
    }
  }
  return this;
}

void sub_187F2FB00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F2FB0C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_params::textualize_attributes(uint64_t this, kdu_message *a2, int a3, int a4, char a5)
{
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  kdu_params *i;
  int v25;

  v7 = this;
  if (a3 < 0)
    v8 = -1;
  else
    v8 = a3;
  v9 = *(_DWORD *)(this + 28);
  if (v9 <= a4)
    v10 = v9 - 1;
  else
    v10 = a4;
  v11 = *(_DWORD *)(this + 16);
  if (v11 < 0)
  {
    v11 = v8;
  }
  else
  {
    v12 = v11 >= v8 && v11 <= v10;
    v10 = *(_DWORD *)(this + 16);
    if (!v12)
      return this;
  }
  if (*(_DWORD *)(this + 24))
    return kdu_params::textualize_attributes(this, a2, a5);
  v13 = *(_DWORD *)(this + 20);
  if (v13 < 0)
    v14 = 0xFFFFFFFFLL;
  else
    v14 = v13;
  if (v11 <= v10)
  {
    v15 = *(_DWORD *)(this + 32);
    if (v13 >= 0)
      v16 = *(_DWORD *)(this + 20);
    else
      v16 = v15 - 1;
    v17 = *(_QWORD *)(this + 64) + 8 * (v11 + 1 + (v11 + 1) * v15) + 8 * (v14 + 1);
    v25 = v10;
    do
    {
      if ((int)v14 <= v16)
      {
        v18 = (uint64_t *)v17;
        v19 = v14;
        do
        {
          v20 = *v18;
          if (*(_DWORD *)(*v18 + 20) == (_DWORD)v14 && *(_DWORD *)(v20 + 16) == v11)
          {
            do
            {
              this = kdu_params::textualize_attributes(v20, a2, a5);
              v20 = *(_QWORD *)(v20 + 88);
            }
            while (v20);
          }
          ++v18;
          v21 = (_DWORD)v14 == v16;
          LODWORD(v14) = v14 + 1;
        }
        while (!v21);
        v15 = *(_DWORD *)(v7 + 32);
        v10 = v25;
        v14 = v19;
      }
      v17 += 8 * (v15 + 1);
      v21 = v11++ == v10;
    }
    while (!v21);
  }
  if (*(_QWORD *)(v7 + 48) == v7)
  {
    for (i = *(kdu_params **)(v7 + 56); i; i = (kdu_params *)*((_QWORD *)i + 7))
      this = kdu_params::textualize_attributes(i, a2, a3, a4, a5);
  }
  return this;
}

uint64_t kdu_params::translate_marker_segment(kdu_params *this, uint64_t a2, uint64_t a3, unsigned __int8 *a4, int a5, uint64_t a6)
{
  kdu_params *v6;
  uint64_t result;
  int v13;
  int v14;
  _BYTE *v15;
  int v16;

  v16 = -1;
  v6 = *(kdu_params **)(**((_QWORD **)this + 8) + 48);
  if (!v6)
    return 0;
  while (*((_DWORD *)v6 + 7) <= a5
       || ((*(uint64_t (**)(kdu_params *, uint64_t, uint64_t, unsigned __int8 *, int *))(*(_QWORD *)v6 + 40))(v6, a2, a3, a4, &v16) & 1) == 0)
  {
    v6 = (kdu_params *)*((_QWORD *)v6 + 7);
    if (!v6)
      return 0;
  }
  v13 = v16;
  if (*((_BYTE *)v6 + 42))
  {
    v14 = -1;
    v16 = -1;
  }
  else
  {
    v14 = v16;
    v13 = 0;
  }
  result = kdu_params::access_relation(v6, a5, v14, v13, 0);
  if (result)
  {
    v15 = (_BYTE *)result;
    if (*(_BYTE *)(result + 40) && !*(_BYTE *)(result + 42))
    {
      result = 0;
      while (v15[37])
      {
        v15 = (_BYTE *)*((_QWORD *)v15 + 11);
        if (!v15)
          return result;
      }
    }
    result = (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, unsigned __int8 *, uint64_t))(*(_QWORD *)v15 + 48))(v15, a2, a3, a4, a6);
    if ((_DWORD)result)
    {
      v15[37] = 1;
      if (v15[40])
      {
        if (!v15[42])
          kdu_params::new_instance((kdu_params *)v15);
      }
      v15[36] = 0;
      return 1;
    }
  }
  return result;
}

uint64_t kdu_params::generate_marker_segments(kdu_params *this, kdu_output *a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v23;

  v4 = *(_QWORD *)(**((_QWORD **)this + 8) + 48);
  if (v4)
  {
    v8 = 0;
    v23 = a3 + 1;
    while (1)
    {
      if (*(_DWORD *)(v4 + 28) > a3)
      {
        v9 = *(_DWORD *)(v4 + 32);
        if ((v9 & 0x80000000) == 0)
          break;
      }
LABEL_43:
      v4 = *(_QWORD *)(v4 + 56);
      if (!v4)
        return v8;
    }
    v10 = v23 + v23 * v9;
    v11 = *(_QWORD *)(*(_QWORD *)(v4 + 64) + 8 * v10);
    v12 = -1;
    while (1)
    {
      v13 = *(_QWORD *)(v4 + 64);
      v14 = *(_QWORD *)(v13 + 8 * v10);
      if (*(_DWORD *)(v14 + 16) == a3 || *(_DWORD *)(v11 + 16) == a3 && *(_BYTE *)(v11 + 37))
      {
        v15 = *(_DWORD *)(v14 + 20);
        if (v15 == (_DWORD)v12)
        {
          if ((v12 & 0x8000000000000000) == 0)
            goto LABEL_17;
          goto LABEL_19;
        }
        if (*(_BYTE *)(v14 + 41))
        {
          if (v12 < 0 || v15 != -1)
            kdu_params::generate_marker_segments();
          v16 = kdu_params::access_relation((kdu_params *)v14, a3, v12, 0, 0);
          v13 = *(_QWORD *)(v4 + 64);
          if (v16 != *(_QWORD *)(v13 + 8 * v10) || (v14 = v16, *(_DWORD *)(v16 + 20) != (_DWORD)v12))
            kdu_params::generate_marker_segments();
LABEL_17:
          if (*(_DWORD *)(v11 + 16) != a3 || (v17 = v11, !*(_BYTE *)(v11 + 37)))
          {
LABEL_19:
            v17 = *(_QWORD *)(v13 + 8 * v12 + 8);
            if (!*(_BYTE *)(v17 + 37))
            {
              if (*(_BYTE *)(v4 + 37))
                v17 = v4;
              else
                v17 = 0;
            }
          }
          if (v17 == v14)
            v18 = 0;
          else
            v18 = v17;
          do
          {
            if (*(_BYTE *)(v14 + 42))
            {
              if ((*(_DWORD *)(v14 + 16) & 0x80000000) != 0)
                goto LABEL_34;
              v19 = *(_DWORD *)(v14 + 24);
              v18 = v4;
              while (1)
              {
                v20 = *(_DWORD *)(v18 + 24);
                if (v20 >= v19)
                  break;
                v18 = *(_QWORD *)(v18 + 88);
                if (!v18)
                  goto LABEL_34;
              }
              if (v20 != v19 || !*(_BYTE *)(v18 + 37))
LABEL_34:
                v18 = 0;
            }
            v21 = (*(uint64_t (**)(uint64_t, kdu_output *, uint64_t, uint64_t))(*(_QWORD *)v14 + 32))(v14, a2, v18, a4);
            if (v21 < 1)
            {
              if (*(_BYTE *)(v14 + 37))
                v18 = v14;
              else
                v18 = 0;
            }
            else
            {
              if (v21 <= 3)
                kdu_params::generate_marker_segments();
              v8 = (v21 + v8);
              *(_BYTE *)(v14 + 37) = 1;
              v18 = v14;
            }
            v14 = *(_QWORD *)(v14 + 88);
          }
          while (v14);
        }
      }
      ++v12;
      ++v10;
      if (v12 >= *(int *)(v4 + 32))
        goto LABEL_43;
    }
  }
  return 0;
}

kdu_params *kdu_params::finalize_all(kdu_params *this, _BOOL8 a2)
{
  kdu_params *v3;
  kdu_params *result;
  _QWORD *i;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  v3 = this;
  result = (kdu_params *)(*(uint64_t (**)(kdu_params *))(*(_QWORD *)this + 72))(this);
  if (*((kdu_params **)v3 + 10) == v3)
  {
    for (i = (_QWORD *)*((_QWORD *)v3 + 11); i; i = (_QWORD *)i[11])
      result = (kdu_params *)(*(uint64_t (**)(_QWORD *, _BOOL8))(*i + 72))(i, a2);
  }
  if ((*((_DWORD *)v3 + 5) & 0x80000000) != 0)
  {
    v6 = *((_DWORD *)v3 + 8);
    if (v6 >= 1)
    {
      v7 = 0;
      do
      {
        v8 = v7;
        v9 = *((_DWORD *)v3 + 4);
        result = *(kdu_params **)(*((_QWORD *)v3 + 8) + 8 * (++v7 + v6 + 1 + (v6 + 1) * v9));
        if (v8 == *((_DWORD *)result + 5) && *((_DWORD *)result + 4) == v9)
        {
          result = (kdu_params *)kdu_params::finalize_all(result, a2);
          v6 = *((_DWORD *)v3 + 8);
        }
      }
      while (v7 < v6);
    }
    if ((*((_DWORD *)v3 + 4) & 0x80000000) != 0)
    {
      v10 = *((_DWORD *)v3 + 7);
      if (v10 >= 1)
      {
        v11 = 0;
        do
        {
          v12 = v11 + 1;
          result = *(kdu_params **)(*((_QWORD *)v3 + 8) + 8 * (v12 + v12 * *((_DWORD *)v3 + 8)));
          if (v11 == *((_DWORD *)result + 4))
          {
            result = (kdu_params *)kdu_params::finalize_all(result, a2);
            v10 = *((_DWORD *)v3 + 7);
          }
          v11 = v12;
        }
        while (v12 < v10);
      }
    }
    if (*((kdu_params **)v3 + 6) == v3)
    {
      while (1)
      {
        v3 = (kdu_params *)*((_QWORD *)v3 + 7);
        if (!v3)
          break;
        result = (kdu_params *)kdu_params::finalize_all(v3, a2);
      }
    }
  }
  return result;
}

kdu_params *kdu_params::finalize_all(kdu_params *this, int a2, _BOOL8 a3)
{
  kdu_params *v5;
  int v6;
  _QWORD *i;
  int v8;
  int v9;
  int v10;
  int v11;

  v5 = this;
  v6 = *((_DWORD *)this + 4);
  if (v6 == a2)
  {
    this = (kdu_params *)(*(uint64_t (**)(kdu_params *, _BOOL8))(*(_QWORD *)this + 72))(this, a3);
    if (*((kdu_params **)v5 + 10) == v5)
    {
      for (i = (_QWORD *)*((_QWORD *)v5 + 11); i; i = (_QWORD *)i[11])
        this = (kdu_params *)(*(uint64_t (**)(_QWORD *, _BOOL8))(*i + 72))(i, a3);
    }
    if ((*((_DWORD *)v5 + 5) & 0x80000000) != 0)
    {
      v8 = *((_DWORD *)v5 + 8);
      if (v8 >= 1)
      {
        v9 = 0;
        do
        {
          v10 = v9;
          v11 = *((_DWORD *)v5 + 4);
          this = *(kdu_params **)(*((_QWORD *)v5 + 8) + 8 * (++v9 + v8 + 1 + (v8 + 1) * v11));
          if (v10 == *((_DWORD *)this + 5) && *((_DWORD *)this + 4) == v11)
          {
            this = kdu_params::finalize_all(this, a3);
            v8 = *((_DWORD *)v5 + 8);
          }
        }
        while (v9 < v8);
      }
    }
  }
  else if (v6 < 0 && (*((_DWORD *)this + 5) & 0x80000000) != 0 && *((_DWORD *)this + 7) > a2)
  {
    this = *(kdu_params **)(*((_QWORD *)this + 8) + 8 * (a2 + 1 + (a2 + 1) * *((_DWORD *)this + 8)));
    if (this)
    {
      if (*((_DWORD *)this + 4) == a2)
        this = kdu_params::finalize_all(this, a3);
    }
  }
  if (*((kdu_params **)v5 + 6) == v5)
  {
    while (1)
    {
      v5 = (kdu_params *)*((_QWORD *)v5 + 7);
      if (!v5)
        break;
      this = (kdu_params *)kdu_params::finalize_all(v5, a2, a3);
    }
  }
  return this;
}

void kdu_params::define_attribute(kdu_params *this, const char *a2, const char *a3, const char *a4, int a5)
{
  kd_attribute *v10;
  uint64_t v11;
  kd_attribute **v12;
  uint64_t v13;
  uint64_t v14;

  v10 = (kd_attribute *)operator new();
  kd_attribute::kd_attribute(v10, a2, a3, a5, a4);
  v13 = *((_QWORD *)this + 12);
  v12 = (kd_attribute **)((char *)this + 96);
  v11 = v13;
  if (v13)
  {
    do
    {
      v14 = v11;
      v11 = *(_QWORD *)(v11 + 56);
    }
    while (v11);
    v12 = (kd_attribute **)(v14 + 56);
  }
  *v12 = v10;
}

void sub_187F30354(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1070C40C5D0BD27);
  _Unwind_Resume(a1);
}

void siz_params::siz_params(siz_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *(_DWORD *)((char *)this + 38) = 0;
  *((_BYTE *)this + 42) = 0;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_WORD *)this + 18) = 1;
  *((_BYTE *)this + 104) = 0;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BABD40;
  *((_QWORD *)this + 1) = "SIZ";
    "dded later via an ammendment to Part 1.  They are in fact highly restrictive subsets of the Part 1 standard, taylore"
    "d for the needs of digital cinema projection equipment.  These profiles are not currently checked for conformance, a"
    "lthough that may well change in a future release.  If you don't know what you are doing, therefore, you should not l"
    "abel a codestream which you compress yourself as having either of these profiles.\n"
    "\t\t[Defaults to Profile-2.]",
    "(PROFILE0=0,PROFILE1=1,PROFILE2=2,PART2=3,CINEMA2K=4,CINEMA4K=5)",
    0);
  kdu_params::define_attribute(this, "Scap", "Flag indicating whether or not capabilities from additional parts (beyond parts 1 and 2) in the JPEG2000 family of standards are defined in a separate capabilities marker segment.\n\t\t[Defaults to false.]", "B", 0);
  kdu_params::define_attribute(this, "Sextensions", "Logical OR of any combination of a number of flags, indicating extended features from Part 2 of the JPEG2000 standard which may be found in this codestream.  Note that the Kakadu codestream generation machinery will set these flags automatically based on features which are detected in other parameter objects.  Explanation: DC means arbitrary DC offset; VARQ means variable quantization; TCQ means trellis-coded quantization; PRECQ means precinct-dependent quanti"
    "zation; VIS means visual masking; SSO means single-sample-overlap transform; DECOMP means arbitrary decomposition st"
    "yles; ANY_KNL means arbitrary transform kernels; SYM_KNL means arbitrary whole sample symmetric transform kernels; M"
    "CT means multi-component transform; CURVE means arbitrary point-transformation; and ROI means extended region-of-int"
    "erest signalling.\n"
    "\t\t[Defaults to 0.]",
    "[DC=1|VARQ=2|TCQ=4|PRECQ=2048|VIS=8|SSO=16|DECOMP=32|ANY_KNL=64|SYM_KNL=128|MCT=256|CURVE=512|ROI=1024]",
    0);
  kdu_params::define_attribute(this, "Ssize", "Canvas dimensions: vertical dimension first.\n\t\t[For compressors, this will normally be derived from the dimensions of the individual image components. Explicitly supplying the canvas dimensions may be desirable if the source image files do not indicate their dimensions, or if custom sub-sampling factors are desired.]", "II", 0);
  kdu_params::define_attribute(this, "Sorigin", "Image origin on canvas: vertical coordinate first.\n\t\t[Defaults to {0,0}, or the tile origin if one is given]", "II", 0);
  kdu_params::define_attribute(this, "Stiles", "Tile partition size: vertical dimension first.\n\t\t[Defaults to {0,0}]", "II", 0);
  kdu_params::define_attribute(this, "Stile_origin", "Tile origin on the canvas: vertical coordinate first.\n\t\t[Defaults to {0,0}]", "II", 0);
    "f the codestream image components produced after subjecting the original components to the forward multi-component t"
    "ransform.  Note that the last supplied identifier is repeated indefinitely for all remaining components.]",
    "B",
    3);
    "d after subjecting the original components to the forward multi-component transform.  Note that the last supplied va"
    "lue is repeated indefinitely for all remaining components.]",
    "I",
    3);
  kdu_params::define_attribute(this, "Ssampling", "Indicates the sub-sampling factors for each codestream image component. In each record, the vertical factor appears first, followed by the horizontal sub-sampling factor. The last supplied record is repeated indefinitely for all remaining components.\n\t\t[For compressors, a suitable set of sub-sampling factors will normally be deduced from the individual image component dimensions.]", "II", 3);
  kdu_params::define_attribute(this, "Sdims", "Indicates the dimensions (vertical, then horizontal) of each individual image component. The last supplied record is repeated indefinitely for all remaining components.\n\t\t[For compressors, the image component dimensions will normally be deduced from the image files supplied to the compressor, but may be explicitly set if raw input files are to be used.]", "II", 3);
}

void sub_187F30600(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t siz_params::copy_with_xforms(siz_params *this, kdu_params *a2, int a3, int a4, uint64_t a5, int a6, int a7)
{
  kdu_params *v12;
  uint64_t v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  kdu_params *v18;
  kdu_params *v19;
  int v20;
  signed int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  unint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t result;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  kdu_params *v54;
  kdu_params *v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int *v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  int v68;
  int v69;
  kdu_params *v70;
  siz_params *v71;
  int v72;
  kdu_params *v73;
  int v74;
  int v75[2];
  BOOL v76;
  int v77;
  int v78;
  int v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  int v83;
  int v84;
  int v85[2];
  int v86[2];
  int v87[2];
  int v88[2];
  BOOL v89;

  v12 = a2;
  v89 = 0;
  *(_QWORD *)v88 = 0;
  *(_QWORD *)v87 = 0;
  *(_QWORD *)v86 = 0;
  *(_QWORD *)v85 = 0;
  v83 = 0;
  v84 = 0;
  if (!kdu_params::get(a2, "Sprofile", 0, 0, &v88[1], 1, 1, 1)
    || !kdu_params::get(v12, "Scap", 0, 0, &v89, 1, 1, 1)
    || !kdu_params::get(v12, "Sextensions", 0, 0, v88, 1, 1, 1)
    || !kdu_params::get(v12, "Ssize", 0, a5, v87, 1, 1, 1)
    || !kdu_params::get(v12, "Ssize", 0, a5 ^ 1, &v87[1], 1, 1, 1)
    || !kdu_params::get(v12, "Sorigin", 0, a5, v86, 1, 1, 1)
    || !kdu_params::get(v12, "Sorigin", 0, a5 ^ 1, &v86[1], 1, 1, 1)
    || !kdu_params::get(v12, "Stiles", 0, a5, &v85[1], 1, 1, 1)
    || !kdu_params::get(v12, "Stiles", 0, a5 ^ 1, v85, 1, 1, 1)
    || !kdu_params::get(v12, "Stile_origin", 0, a5, &v84, 1, 1, 1)
    || (kdu_params::get(v12, "Stile_origin", 0, a5 ^ 1, &v83, 1, 1, 1) & 1) == 0)
  {
    v82 = 0;
    v80 = 0u;
    v81 = 0u;
    kdu_error::kdu_error((kdu_error *)&v80, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v80);
  }
  if ((a6 & 1) != 0 || (a7 & 1) != 0)
  {
    v14 = 3;
    v88[1] = 3;
  }
  else
  {
    v14 = v88[1];
  }
  kdu_params::set(this, "Sprofile", 0, 0, (int *)v14);
  kdu_params::set((uint64_t)this, "Scap", 0, 0, v89);
  kdu_params::set(this, "Sextensions", 0, 0, (int *)v88[0]);
  v79 = 0;
  if (kdu_params::get(v12, "Scomponents", 0, 0, &v79, 1, 1, 1))
  {
    if (v79 <= a3)
    {
      v82 = 0;
      v80 = 0u;
      v81 = 0u;
      kdu_error::kdu_error((kdu_error *)&v80, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v80 + 16))(&v80, "Attempting to discard all of the components from an existing code-stream!");
      kdu_error::~kdu_error((kdu_error *)&v80);
    }
    kdu_params::set(this, "Scomponents", 0, 0, (int *)(v79 - a3));
  }
  v78 = 0;
  if (kdu_params::get(v12, "Mcomponents", 0, 0, &v78, 1, 1, 1))
    kdu_params::set(this, "Mcomponents", 0, 0, (int *)v78);
  v77 = 0;
  v72 = a3;
  if (a4 <= 0)
  {
    v24 = 0;
    v17 = 0;
    v73 = 0;
    v26 = v87[0];
    v25 = v87[1];
    v28 = v86[0];
    v27 = v86[1];
    v29 = v85[0];
    v30 = v85[1];
    v31 = v83;
    v32 = v84;
    goto LABEL_60;
  }
  v67 = a7;
  if ((v88[0] & 0x20) != 0 && (v73 = (kdu_params *)kdu_params::access_cluster(v12, "COD")) != 0)
  {
    if (v79 > a3)
    {
      v66 = a5;
      v15 = a3;
      v16 = a4;
      LODWORD(v17) = a4;
      do
      {
        v18 = (kdu_params *)kdu_params::access_relation(v73, -1, v15, 0, 0);
        if (v18)
        {
          v19 = v18;
          if (kdu_params::get(v18, "Cdecomp", 0, 0, &v77, 1, 1, 1))
          {
            v68 = v17;
            v20 = 0;
            v21 = 0;
            v22 = 0;
            do
            {
              kdu_params::get(v19, "Cdecomp", v20, 0, &v77, 1, 1, 1);
              v22 += v77 & 1;
              v21 += (v77 >> 1) & 1;
              ++v20;
            }
            while (a4 != v20);
            LODWORD(v17) = v68;
            if (v22 < v68)
              LODWORD(v17) = v22;
            if (v21 < (int)v16)
              v16 = v21;
          }
        }
        ++v15;
      }
      while (v15 < v79);
      a5 = v66;
      goto LABEL_40;
    }
  }
  else
  {
    v73 = 0;
  }
  LODWORD(v17) = a4;
  v16 = a4;
LABEL_40:
  if ((_DWORD)a5)
    v23 = v16;
  else
    v23 = v17;
  if ((_DWORD)a5)
    v17 = v17;
  else
    v17 = v16;
  v24 = v23;
  v26 = v87[0];
  v25 = v87[1];
  v28 = v86[0];
  v27 = v86[1];
  v29 = v85[0];
  v30 = v85[1];
  v31 = v83;
  v32 = v84;
  if ((int)v24 < 1)
  {
    a3 = v72;
    a7 = v67;
  }
  else
  {
    v33 = 0;
    v34 = v86[1] | v87[1] | v85[0] | v83;
    a3 = v72;
    a7 = v67;
    while ((v34 & 1) == 0)
    {
      v33 = (v33 + 1);
      v34 >>= 1;
      if ((_DWORD)v24 == (_DWORD)v33)
        goto LABEL_54;
    }
    v24 = v33;
  }
LABEL_54:
  if ((int)v17 >= 1)
  {
    v35 = 0;
    v36 = v86[0] | v87[0] | v85[1] | v84;
    while ((v36 & 1) == 0)
    {
      v35 = (v35 + 1);
      v36 >>= 1;
      if ((_DWORD)v17 == (_DWORD)v35)
        goto LABEL_60;
    }
    v17 = v35;
  }
LABEL_60:
  v37 = v25 >> v24;
  v38 = (v26 >> v17);
  v87[0] = v26 >> v17;
  v87[1] = v25 >> v24;
  v39 = v27 >> v24;
  v40 = v28 >> v17;
  v86[0] = v28 >> v17;
  v86[1] = v39;
  v41 = v29 >> v24;
  v42 = v30 >> v17;
  v85[0] = v29 >> v24;
  v85[1] = v30 >> v17;
  v83 = v31 >> v24;
  v84 = v32 >> v17;
  if (a7)
  {
    v87[1] = 1 - v39;
    v86[1] = 1 - v37;
    v43 = v41 - (v31 >> v24) + 1;
    do
      v43 -= v41;
    while (v43 > 1 - v37);
    v83 = v43;
  }
  if (a6)
  {
    v44 = 1 - v38;
    v38 = (1 - v40);
    v87[0] = 1 - v40;
    v86[0] = v44;
    v45 = v42 - (v32 >> v17) + 1;
    do
      v45 -= v42;
    while (v45 > v44);
    v84 = v45;
  }
  kdu_params::set(this, "Ssize", 0, 0, (int *)v38);
  kdu_params::set(this, "Ssize", 0, 1, (int *)v87[1]);
  kdu_params::set(this, "Sorigin", 0, 0, (int *)v86[0]);
  kdu_params::set(this, "Sorigin", 0, 1, (int *)v86[1]);
  kdu_params::set(this, "Stiles", 0, 0, (int *)v85[1]);
  kdu_params::set(this, "Stiles", 0, 1, (int *)v85[0]);
  kdu_params::set(this, "Stile_origin", 0, 0, (int *)v84);
  result = (uint64_t)kdu_params::set(this, "Stile_origin", 0, 1, (int *)v83);
  v76 = 0;
  *(_QWORD *)v75 = 0;
  v74 = 0;
  if (v79 > a3)
  {
    v47 = a5 ^ 1;
    v48 = a3;
    v70 = v12;
    v71 = this;
    v69 = a5 ^ 1;
    do
    {
      if (kdu_params::get(v12, "Sprecision", v48, 0, &v75[1], 1, 1, 1))
        kdu_params::set(this, "Sprecision", v48 - a3, 0, (int *)v75[1]);
      if (kdu_params::get(v12, "Ssigned", v48, 0, &v76, 1, 1, 1))
        kdu_params::set((uint64_t)this, "Ssigned", v48 - a3, 0, v76);
      result = kdu_params::get(v12, "Ssampling", v48, a5, &v74, 1, 1, 1);
      if ((_DWORD)result)
      {
        result = kdu_params::get(v12, "Ssampling", v48, v47, v75, 1, 1, 1);
        if ((_DWORD)result)
        {
          v49 = v17;
          v50 = v24;
          v51 = a5;
          v52 = a4;
          v53 = a4;
          if (v73)
          {
            v54 = (kdu_params *)kdu_params::access_relation(v73, -1, v48, 0, 0);
            v52 = a4;
            v53 = a4;
            if (v54)
            {
              v55 = v54;
              v56 = kdu_params::get(v54, "Cdecomp", 0, 0, &v77, 1, 1, 1);
              v52 = v56 ? 0 : a4;
              v53 = v52;
              if (a4 >= 1)
              {
                if (v56)
                {
                  v57 = 0;
                  v53 = 0;
                  v52 = 0;
                  do
                  {
                    kdu_params::get(v55, "Cdecomp", v57, 0, &v77, 1, 1, 1);
                    v52 += v77 & 1;
                    v53 += (v77 >> 1) & 1;
                    ++v57;
                  }
                  while (a4 != v57);
                }
              }
            }
          }
          if ((_DWORD)v51)
            v58 = v53;
          else
            v58 = v52;
          if ((_DWORD)v51)
            v59 = v52;
          else
            v59 = v53;
          v60 = v58 - v50;
          if (v60 < 0 || (v24 = v50, v17 = v49, v61 = v59 - v49, v61 < 0))
            siz_params::copy_with_xforms();
          a5 = v51;
          v62 = (int *)(v74 << v61);
          v74 <<= v61;
          v75[0] <<= v60;
          v12 = v70;
          this = v71;
          a3 = v72;
          if (v75[0] > 255 || (int)v62 >= 256)
          {
            v82 = 0;
            v80 = 0u;
            v81 = 0u;
            kdu_error::kdu_error((kdu_error *)&v80, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v80 + 16))(&v80, "Cannot apply requested resolution reduction without creating a SIZ marker segment with illegal component sub-sampling factors.  For the current code-stream, sub-sampling factors would be required which exceed the legal range of 1 to 255.");
            kdu_error::~kdu_error((kdu_error *)&v80);
          }
          kdu_params::set(v71, "Ssampling", v48 - v72, 0, v62);
          result = (uint64_t)kdu_params::set(v71, "Ssampling", v48 - v72, 1, (int *)v75[0]);
          v47 = v69;
        }
      }
      ++v48;
    }
    while (v48 < v79);
  }
  if (v78 >= 1)
  {
    v63 = 0;
    while (1)
    {
      result = kdu_params::get(v12, "Mprecision", v63, 0, &v75[1], 0, 0, 1);
      if ((result & 1) == 0)
        break;
      result = (uint64_t)kdu_params::set(this, "Mprecision", v63++, 0, (int *)v75[1]);
      v64 = v78;
      if (v63 >= v78)
        goto LABEL_104;
    }
    v64 = v78;
LABEL_104:
    if (v64 >= 1)
    {
      v65 = 0;
      do
      {
        result = kdu_params::get(v12, "Msigned", v65, 0, &v76, 0, 0, 1);
        if (!(_DWORD)result)
          break;
        result = kdu_params::set((uint64_t)this, "Msigned", v65++, 0, v76);
      }
      while (v65 < v78);
    }
  }
  return result;
}

void sub_187F310F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F310FC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Unwind_Exception *v19;

  _Unwind_Resume(v19);
}

uint64_t siz_params::write_marker_segment(siz_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int lcm;
  unsigned int v15;
  int v16;
  kdu_params *v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  signed int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  kdu_params *v27;
  int v28;
  int v29;
  unsigned __int8 v30;
  unsigned __int8 v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  __int16 v40;
  __int16 v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  char v50;
  int v51;
  int v52;
  int v53;
  int v54;
  char v55;
  int v56;
  int v57;
  __int16 v58;
  int v59;
  int v60;
  uint64_t v61;
  int v63;
  int v65[4];
  __int128 v66;
  uint64_t v67;
  unsigned __int8 v68[8];
  BOOL v69;
  int v70;
  int v71;
  int v72;
  unsigned int v73[2];
  unsigned int v74[2];
  unsigned int v75[2];
  unsigned int v76[2];
  unsigned int v77[2];
  int v78;
  BOOL v79;
  char v80[16];
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (a3)
    siz_params::write_marker_segment();
  if (a4)
  {
    LODWORD(v61) = 0;
  }
  else
  {
    v79 = 0;
    v78 = 0;
    *(_QWORD *)v76 = 0;
    *(_QWORD *)v77 = 0;
    *(_QWORD *)v74 = 0;
    *(_QWORD *)v75 = 0;
    *(_QWORD *)v73 = 0;
    if (!kdu_params::get(this, "Sprofile", 0, 0, &v78, 1, 1, 1)
      || !kdu_params::get(this, "Scap", 0, 0, &v79, 1, 1, 1)
      || !kdu_params::get(this, "Sextensions", 0, 0, (int *)&v77[1], 1, 1, 1)
      || !kdu_params::get(this, "Ssize", 0, 0, (int *)&v76[1], 1, 1, 1)
      || !kdu_params::get(this, "Ssize", 0, 1, (int *)v77, 1, 1, 1)
      || !kdu_params::get(this, "Sorigin", 0, 0, (int *)&v75[1], 1, 1, 1)
      || !kdu_params::get(this, "Sorigin", 0, 1, (int *)v76, 1, 1, 1)
      || !kdu_params::get(this, "Stiles", 0, 0, (int *)&v74[1], 1, 1, 1)
      || !kdu_params::get(this, "Stiles", 0, 1, (int *)v75, 1, 1, 1)
      || !kdu_params::get(this, "Stile_origin", 0, 0, (int *)&v73[1], 1, 1, 1)
      || !kdu_params::get(this, "Stile_origin", 0, 1, (int *)v74, 1, 1, 1)
      || (kdu_params::get(this, "Scomponents", 0, 0, (int *)v73, 1, 1, 1) & 1) == 0)
    {
      *(_QWORD *)&v82 = 0;
      *(_OWORD *)v80 = 0u;
      v81 = 0u;
      kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v80 + 16))(v80, "Unable to write SIZ marker segment yet!");
      kdu_error::~kdu_error((kdu_error *)v80);
    }
    v5 = v73[0];
    if (v73[0] - 16385 <= 0xFFFFBFFF)
    {
      *(_QWORD *)&v82 = 0;
      *(_OWORD *)v80 = 0u;
      v81 = 0u;
      kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v80 + 16))(v80, "Illegal number of image components! Must be in the range 1 to 16384.");
      kdu_error::~kdu_error((kdu_error *)v80);
    }
    v72 = 0;
    v6 = kdu_params::get(this, "Mcomponents", 0, 0, &v72, 1, 1, 1);
    if (v72)
      v7 = v6;
    else
      v7 = 0;
    if (v7 == 1)
    {
      if ((v72 - 16385) <= 0xFFFFBFFF)
      {
        *(_QWORD *)&v82 = 0;
        *(_OWORD *)v80 = 0u;
        v81 = 0u;
        kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)v80);
      }
      v59 = v72 + 6;
    }
    else
    {
      v59 = 0;
    }
    v58 = 3 * v5;
    if (a2)
    {
      LODWORD(v61) = 3 * v5 + 40;
      v8 = v73[1];
      v9 = v74[0];
      if ((v74[0] & 0x80000000) != 0 || (v73[1] & 0x80000000) != 0)
      {
        v11 = v74[1];
        v12 = v75[0];
        v13 = v77[0];
        lcm = v75[0];
        if ((signed int)(v75[0] + v74[0]) >= (int)v77[0])
        {
          v9 = v76[0];
          v74[0] = v76[0];
          lcm = 1;
        }
        v15 = v76[1];
        v16 = v74[1];
        if ((signed int)(v74[1] + v73[1]) >= (int)v76[1])
        {
          v73[1] = v75[1];
          v16 = 1;
        }
        v17 = (kdu_params *)kdu_params::access_cluster(this, "COD");
        v18 = v13 - v76[0];
        if (v12 <= 1)
          v19 = 1;
        else
          v19 = v12;
        if (v18 <= 0)
          v20 = -(int)((v76[0] - v13) / v19);
        else
          v20 = (v18 - 1) / v19 + 1;
        v21 = v15 - v75[1];
        if (v11 <= 1)
          v22 = 1;
        else
          v22 = v11;
        v34 = v21 <= 0;
        v23 = (v21 - 1) / v22;
        if (v34)
          v24 = -(int)((v75[1] - v15) / v22);
        else
          v24 = v23 + 1;
        v60 = v24 * v20;
        if (((v24 * v20) & 0x80000000) == 0)
        {
          v63 = -1;
          v25 = v73[0];
          do
          {
            if (v25 >= 1)
            {
              v26 = 0;
              do
              {
                v65[0] = 1;
                v71 = 1;
                kdu_params::get(this, "Ssampling", v26, 0, &v71, 1, 1, 1);
                kdu_params::get(this, "Ssampling", v26, 1, v65, 1, 1, 1);
                v70 = 0;
                v69 = 0;
                if (!v17
                  || (v27 = (kdu_params *)kdu_params::access_relation(v17, v63, v26, 0, 1), (v17 = v27) == 0)
                  || !kdu_params::get(v27, "Clevels", 0, 0, &v70, 1, 1, 1)
                  || (kdu_params::get(v17, "Cuse_precincts", 0, 0, &v69, 1, 1, 1) & 1) == 0)
                {
                  *(_QWORD *)&v82 = 0;
                  *(_OWORD *)v80 = 0u;
                  v81 = 0u;
                  kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
                  (*(void (**)(char *, const char *))(*(_QWORD *)v80 + 16))(v80, "Attempting to write geometrically transformed SIZ marker information without attaching and finalizing all tile-component COD marker information.  This is essential to establish canvas coordinate equivalence relationships.");
                  kdu_error::~kdu_error((kdu_error *)v80);
                }
                v28 = v70;
                if ((v70 & 0x80000000) == 0)
                {
                  v29 = -v70;
                  do
                  {
                    v30 = 15;
                    *(_DWORD *)v68 = 15;
                    *(_DWORD *)&v68[4] = 15;
                    if (v69)
                    {
                      kdu_params::get(v17, "Cprecincts", v29 + v70, 0, (int *)v68, 1, 1, 1);
                      kdu_params::get(v17, "Cprecincts", v29 + v70, 1, (int *)&v68[4], 1, 1, 1);
                      v30 = v68[0];
                      v31 = v68[4];
                    }
                    else
                    {
                      v31 = 15;
                    }
                    v32 = (v65[0] << (v31 + v28));
                    v33 = (v71 << (v30 + v28));
                    v34 = (int)v32 < 1 || (int)v33 <= 0;
                    if (v34)
                    {
                      *(_QWORD *)&v82 = 0;
                      *(_OWORD *)v80 = 0u;
                      v81 = 0u;
                      kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
                      (*(void (**)(char *, const char *))(*(_QWORD *)v80 + 16))(v80, "Error attempting to convert geometrically transformed canvas coordinates to legal marker ranges.  Try using a smaller precinct size (you can use the transcoding utility to achieve this at the same time as geometric transformations.");
                      kdu_error::~kdu_error((kdu_error *)v80);
                    }
                    lcm = find_lcm(lcm, v32);
                    v35 = find_lcm(v16, v33);
                    v16 = v35;
                    ++v29;
                    v34 = v28-- <= 0;
                  }
                  while (!v34);
                }
                ++v26;
                v25 = v73[0];
              }
              while (v26 < (int)v73[0]);
            }
            ++v63;
          }
          while (v63 != v60);
          v9 = v74[0];
        }
        if (v9 < 0)
        {
          if (lcm <= 1)
            v37 = 1;
          else
            v37 = lcm;
          v36 = lcm + lcm * (~v9 / v37);
        }
        else
        {
          v36 = 0;
        }
        if ((v73[1] & 0x80000000) != 0)
        {
          if (v16 <= 1)
            v39 = 1;
          else
            v39 = v16;
          v38 = v16 + v16 * (~v73[1] / v39);
        }
        else
        {
          v38 = 0;
        }
        v77[0] += v36;
        v76[1] += v38;
        v75[1] += v38;
        v10 = v76[0] + v36;
        v76[0] += v36;
        v8 = v38 + v73[1];
        v9 += v36;
        v73[1] += v38;
        v74[0] = v9;
        if (v9 < 0 || v8 < 0)
          siz_params::write_marker_segment();
      }
      else
      {
        v10 = v76[0];
      }
      if (v10 < v9
        || (int)v75[1] < v8
        || v10 >= (signed int)(v75[0] + v9)
        || (int)v75[1] >= (signed int)(v74[1] + v8)
        || (int)v77[0] <= v10
        || (int)v76[1] <= (int)v75[1])
      {
        *(_QWORD *)&v82 = 0;
        *(_OWORD *)v80 = 0u;
        v81 = 0u;
        kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v80 + 16))(v80, "Cannot write SIZ marker with illegal canvas coordinates.  The first tile is required to have a non-empty intersection with the image region on the canvas.");
        kdu_error::~kdu_error((kdu_error *)v80);
      }
      kdu_output::put(a2, 255);
      kdu_output::put(a2, 81);
      kdu_output::put(a2, (unsigned __int16)(v58 + 38) >> 8);
      kdu_output::put(a2, v58 + 38);
      if (v78 == 3)
      {
        v40 = LOWORD(v77[1]) | 0x8000;
      }
      else
      {
        if (v78 > 5 || v77[1])
        {
          *(_QWORD *)&v82 = 0;
          *(_OWORD *)v80 = 0u;
          v81 = 0u;
          kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v80 + 16))(v80, "Illegal profile index.  \"Sprofile\" must be set in the range 0 to 5; 3 is required if Part 2 features are to be used.");
          kdu_error::~kdu_error((kdu_error *)v80);
        }
        if (v78 == 2)
        {
          v40 = 0;
        }
        else if (v78 < 4)
        {
          v40 = v78 + 1;
        }
        else
        {
          v40 = v78 - 1;
        }
      }
      if (v79)
        v41 = v40 | 0x4000;
      else
        v41 = v40;
      kdu_output::put(a2, SHIBYTE(v41));
      kdu_output::put(a2, v41);
      v42 = kdu_output::put(a2, v77[0]);
      v43 = kdu_output::put(a2, v76[1]);
      v44 = kdu_output::put(a2, v76[0]);
      v45 = kdu_output::put(a2, v75[1]);
      v46 = kdu_output::put(a2, v75[0]);
      v47 = kdu_output::put(a2, v74[1]);
      v48 = kdu_output::put(a2, v74[0]);
      v49 = kdu_output::put(a2, v73[1]);
      v50 = v73[0];
      kdu_output::put(a2, SBYTE1(v73[0]));
      kdu_output::put(a2, v50);
      v51 = v42 + v43 + v44 + v45 + v46 + v47 + v48 + v49 + 8;
      v70 = 0;
      v71 = 0;
      *(_QWORD *)v68 = 0;
      if ((int)v73[0] >= 1)
      {
        v52 = 0;
        do
        {
          if (!kdu_params::get(this, "Ssigned", v52, 0, &v71, 1, 1, 1)
            || !kdu_params::get(this, "Sprecision", v52, 0, &v70, 1, 1, 1)
            || !kdu_params::get(this, "Ssampling", v52, 0, (int *)v68, 1, 1, 1)
            || (kdu_params::get(this, "Ssampling", v52, 1, (int *)&v68[4], 1, 1, 1) & 1) == 0)
          {
            *(_QWORD *)&v82 = 0;
            *(_OWORD *)v80 = 0u;
            v81 = 0u;
            kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v80 + 16))(v80, "Unable to write SIZ marker segment! Precision or sub-sampling information missing for at least one component.");
            kdu_error::~kdu_error((kdu_error *)v80);
          }
          if ((v70 - 39) <= 0xFFFFFFD9)
          {
            v67 = 0;
            *(_OWORD *)v65 = 0u;
            v66 = 0u;
            kdu_error::kdu_error((kdu_error *)v65, "Kakadu Core Error:\n");
            (*(void (**)(int *, const char *))(*(_QWORD *)v65 + 16))(v65, "Illegal image sample bit-depth, ");
            v83 = 0u;
            v84 = 0u;
            v81 = 0u;
            v82 = 0u;
            *(_OWORD *)v80 = 0u;
            if (LOBYTE(v65[2]))
              sprintf(v80, "%x");
            else
              sprintf(v80, "%d");
            (*(void (**)(int *, char *))(*(_QWORD *)v65 + 16))(v65, v80);
            (*(void (**)(int *, const char *))(*(_QWORD *)v65 + 16))(v65, ". Legal range is from 1 to 38 bits per sample.");
            kdu_error::~kdu_error((kdu_error *)v65);
          }
          if ((*(_DWORD *)&v68[4] - 256) < 0xFFFFFF01 || *(int *)v68 < 1 || *(int *)v68 >= 256)
          {
            v67 = 0;
            *(_OWORD *)v65 = 0u;
            v66 = 0u;
            kdu_error::kdu_error((kdu_error *)v65, "Kakadu Core Error:\n");
            (*(void (**)(int *, const char *))(*(_QWORD *)v65 + 16))(v65, "Illegal component sub-sampling factors, {");
            v83 = 0u;
            v84 = 0u;
            v81 = 0u;
            v82 = 0u;
            *(_OWORD *)v80 = 0u;
            if (LOBYTE(v65[2]))
              sprintf(v80, "%x");
            else
              sprintf(v80, "%d");
            (*(void (**)(int *, char *))(*(_QWORD *)v65 + 16))(v65, v80);
            (*(void (**)(int *, const char *))(*(_QWORD *)v65 + 16))(v65, ",");
            v83 = 0u;
            v84 = 0u;
            v81 = 0u;
            v82 = 0u;
            *(_OWORD *)v80 = 0u;
            if (LOBYTE(v65[2]))
              sprintf(v80, "%x");
            else
              sprintf(v80, "%d");
            (*(void (**)(int *, char *))(*(_QWORD *)v65 + 16))(v65, v80);
            (*(void (**)(int *, const char *))(*(_QWORD *)v65 + 16))(v65, "}. Legal range is from 1 to 255.");
            kdu_error::~kdu_error((kdu_error *)v65);
          }
          v53 = kdu_output::put(a2, v70 + ((_BYTE)v71 << 7) - 1);
          v54 = kdu_output::put(a2, v68[4]);
          v51 += v53 + v54 + kdu_output::put(a2, v68[0]);
          ++v52;
        }
        while (v52 < (int)v73[0]);
      }
      if (v51 != (_DWORD)v61)
        siz_params::write_marker_segment();
      if (v59)
      {
        kdu_output::put(a2, 255);
        kdu_output::put(a2, 120);
        kdu_output::put(a2, (unsigned __int16)(v59 - 2) >> 8);
        kdu_output::put(a2, v59 - 2);
        v55 = v72;
        kdu_output::put(a2, SBYTE1(v72));
        kdu_output::put(a2, v55);
        if (v72 < 1)
        {
          v57 = 6;
        }
        else
        {
          v56 = 0;
          v57 = 6;
          do
          {
            if (!kdu_params::get(this, "Msigned", v56, 0, &v71, 1, 1, 1)
              || (kdu_params::get(this, "Mprecision", v56, 0, &v70, 1, 1, 1) & 1) == 0)
            {
              *(_QWORD *)&v82 = 0;
              *(_OWORD *)v80 = 0u;
              v81 = 0u;
              kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
              (*(void (**)(char *, const char *))(*(_QWORD *)v80 + 16))(v80, "Unable to write CBD marker segment! Precision or signed/unsigned information missing for at least one MCT output component.");
              kdu_error::~kdu_error((kdu_error *)v80);
            }
            if ((v70 - 39) <= 0xFFFFFFD9)
            {
              v67 = 0;
              *(_OWORD *)v65 = 0u;
              v66 = 0u;
              kdu_error::kdu_error((kdu_error *)v65, "Kakadu Core Error:\n");
              (*(void (**)(int *, const char *))(*(_QWORD *)v65 + 16))(v65, "Illegal precision for MCT output component, ");
              v83 = 0u;
              v84 = 0u;
              v81 = 0u;
              v82 = 0u;
              *(_OWORD *)v80 = 0u;
              if (LOBYTE(v65[2]))
                sprintf(v80, "%x");
              else
                sprintf(v80, "%d");
              (*(void (**)(int *, char *))(*(_QWORD *)v65 + 16))(v65, v80);
              (*(void (**)(int *, const char *))(*(_QWORD *)v65 + 16))(v65, ". Legal range is from 1 to 38 bits per sample.");
              kdu_error::~kdu_error((kdu_error *)v65);
            }
            v57 += kdu_output::put(a2, v70 + ((_BYTE)v71 << 7) - 1);
            ++v56;
          }
          while (v56 < v72);
        }
        if (v57 != v59)
          siz_params::write_marker_segment();
        LODWORD(v61) = v59 + v61;
      }
    }
    else
    {
      return v59 + 3 * v5 + 40;
    }
  }
  return v61;
}

void sub_187F3207C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  kdu_error::~kdu_error((kdu_error *)&a29);
}

void sub_187F32088(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Unwind_Exception *v29;

  _Unwind_Resume(v29);
}

uint64_t find_lcm(int a1, uint64_t a2)
{
  int v2;
  int v3;
  uint64_t v4;

  if (a1 < 1 || (int)a2 < 1)
    find_lcm();
  v2 = 1;
  if (a1 >= 2 && a2 >= 2)
  {
    v3 = 2;
    do
    {
      if (!(a1 % v3))
      {
        v4 = a2;
        while (1)
        {
          a2 = ((int)v4 / v3);
          if ((int)v4 % v3)
            break;
          v2 *= v3;
          a1 /= v3;
          v4 = ((int)v4 / v3);
          if (a1 % v3)
            goto LABEL_12;
        }
        a2 = v4;
      }
LABEL_12:
      if (v3 >= a1)
        break;
    }
    while (v3++ < (int)a2);
  }
  return (a2 * a1 * v2);
}

uint64_t siz_params::check_marker_segment(siz_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  int v7;

  *a5 = -1;
  if (a2 == 65361)
    return 1;
  if (a2 == 65400)
  {
    v7 = 0;
    if ((kdu_params::get(this, "Mcomponents", 0, 0, &v7, 1, 1, 1) & 1) == 0)
      *((_BYTE *)this + 37) = 0;
    return 1;
  }
  return 0;
}

uint64_t siz_params::read_marker_segment(siz_params *this, int a2, unsigned int a3, unsigned __int8 *a4, int a5)
{
  unsigned __int8 *v9;
  int v10;
  unsigned __int16 v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned __int8 *v15;
  unsigned int v16;
  int i;
  int *v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  int *v23;
  int *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  unsigned __int8 *v29;
  _QWORD *v30;
  unsigned __int8 *v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *exception;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  char v40[16];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (a5)
    return 0;
  v9 = &a4[a3];
  if (a2 == 65400)
  {
    if ((int)a3 <= 1)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = a4;
      __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
    }
    v13 = (char)*a4;
    v14 = a4[1] | ((v13 & 0x7F) << 8);
    kdu_params::set(this, "Mcomponents", 0, 0, (int *)v14);
    v15 = a4 + 2;
    if (v14)
    {
      v16 = 0;
      for (i = 0; i != v14; ++i)
      {
        if ((v13 & 0x80000000) == 0 || !v16)
        {
          if (v9 - v15 <= 0)
          {
            v32 = __cxa_allocate_exception(8uLL);
            *v32 = v15;
            __cxa_throw(v32, MEMORY[0x1E0DE4E60], 0);
          }
          v16 = *v15;
          kdu_params::set(this, "Msigned", i, 0, (int *)(v16 >> 7));
          kdu_params::set(this, "Mprecision", i, 0, (int *)((v16 & 0x7F) + 1));
          ++v15;
        }
      }
    }
    if (v15 != v9)
    {
      v39 = 0;
      v37 = 0u;
      v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v37 + 16))(&v37, "Malformed CBD marker segment encountered. The final ");
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      *(_OWORD *)v40 = 0u;
      if (BYTE8(v37))
        sprintf(v40, "%x");
      else
        sprintf(v40, "%d");
      (*(void (**)(__int128 *, char *))(v37 + 16))(&v37, v40);
      (*(void (**)(__int128 *, const char *))(v37 + 16))(&v37, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
    return 1;
  }
  if (a2 != 65361)
    return 0;
  if ((int)a3 <= 1)
  {
    v33 = __cxa_allocate_exception(8uLL);
    *v33 = a4;
    __cxa_throw(v33, MEMORY[0x1E0DE4E60], 0);
  }
  v10 = (char)*a4;
  v11 = _byteswap_ushort(*(_WORD *)a4);
  if (v10 < 0)
  {
    v18 = (int *)(v11 & 0x3FFF);
    v19 = 3;
  }
  else
  {
    v12 = a4[1] | (*a4 << 8) & 0xBFFF;
    if (v12 >= 5)
    {
      *(_QWORD *)&v42 = 0;
      *(_OWORD *)v40 = 0u;
      v41 = 0u;
      kdu_error::kdu_error((kdu_error *)v40, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v40 + 16))(v40, "Invalid SIZ marker segment encountered!");
      kdu_error::~kdu_error((kdu_error *)v40);
    }
    if (v12)
    {
      v18 = 0;
      if (v12 < 3)
        v19 = v12 - 1;
      else
        v19 = v12 + 1;
    }
    else
    {
      v18 = 0;
      v19 = 2;
    }
  }
  kdu_params::set(this, "Sprofile", 0, 0, (int *)v19);
  kdu_params::set(this, "Sextensions", 0, 0, v18);
  kdu_params::set((uint64_t)this, "Scap", 0, 0, (v10 >> 6) & 1);
  if (a3 <= 5)
  {
    v35 = a4 + 2;
LABEL_74:
    v30 = __cxa_allocate_exception(8uLL);
    *v30 = v35;
LABEL_61:
    __cxa_throw(v30, MEMORY[0x1E0DE4E60], 0);
  }
  v20 = (int *)bswap32(*(_DWORD *)(a4 + 2));
  kdu_params::set(this, "Ssize", 0, 1, v20);
  if (a3 <= 9)
  {
    v35 = a4 + 6;
    goto LABEL_74;
  }
  v21 = (int *)bswap32(*(_DWORD *)(a4 + 6));
  kdu_params::set(this, "Ssize", 0, 0, v21);
  if (a3 <= 0xD)
  {
    v35 = a4 + 10;
    goto LABEL_74;
  }
  kdu_params::set(this, "Sorigin", 0, 1, (int *)bswap32(*(_DWORD *)(a4 + 10)));
  if (a3 <= 0x11)
  {
    v35 = a4 + 14;
    goto LABEL_74;
  }
  kdu_params::set(this, "Sorigin", 0, 0, (int *)bswap32(*(_DWORD *)(a4 + 14)));
  if (a3 <= 0x15)
  {
    v35 = a4 + 18;
    goto LABEL_74;
  }
  v22 = (int *)bswap32(*(_DWORD *)(a4 + 18));
  kdu_params::set(this, "Stiles", 0, 1, v22);
  if (a3 <= 0x19)
  {
    v35 = a4 + 22;
    goto LABEL_74;
  }
  v23 = (int *)bswap32(*(_DWORD *)(a4 + 22));
  kdu_params::set(this, "Stiles", 0, 0, v23);
  if (a3 <= 0x1D)
  {
    v35 = a4 + 26;
    goto LABEL_74;
  }
  kdu_params::set(this, "Stile_origin", 0, 1, (int *)bswap32(*(_DWORD *)(a4 + 26)));
  if (a3 <= 0x21)
  {
    v35 = a4 + 30;
    goto LABEL_74;
  }
  kdu_params::set(this, "Stile_origin", 0, 0, (int *)bswap32(*(_DWORD *)(a4 + 30)));
  if ((v20 & 0x80000000) == 0 && (v22 & 0x80000000) != 0)
    kdu_params::set(this, "Stiles", 0, 1, v20);
  if ((v21 & 0x80000000) == 0 && (v23 & 0x80000000) != 0)
    kdu_params::set(this, "Stiles", 0, 0, v21);
  if (a3 <= 0x23)
  {
    v35 = a4 + 34;
    goto LABEL_74;
  }
  v24 = (int *)__rev16(*((unsigned __int16 *)a4 + 17));
  kdu_params::set(this, "Scomponents", 0, 0, v24);
  if (!(_DWORD)v24)
  {
    v29 = a4 + 36;
    goto LABEL_51;
  }
  v36 = v9;
  v25 = 0;
  v26 = 0;
  v27 = 36;
  do
  {
    if ((int)a3 + v25 - 36 <= 0)
    {
      v30 = __cxa_allocate_exception(8uLL);
      v31 = &a4[-v25 + 36];
      goto LABEL_60;
    }
    v28 = a4[v27];
    kdu_params::set(this, "Ssigned", v26, 0, (int *)(v28 >> 7));
    kdu_params::set(this, "Sprecision", v26, 0, (int *)((v28 & 0x7F) + 1));
    if ((int)a3 + v25 - 37 <= 0)
    {
      v30 = __cxa_allocate_exception(8uLL);
      v31 = &a4[-v25 + 37];
      goto LABEL_60;
    }
    kdu_params::set(this, "Ssampling", v26, 1, (int *)a4[v27 + 1]);
    if ((int)a3 + v25 - 38 <= 0)
    {
      v30 = __cxa_allocate_exception(8uLL);
      v31 = &a4[-v25 + 38];
LABEL_60:
      *v30 = v31;
      goto LABEL_61;
    }
    kdu_params::set(this, "Ssampling", v26++, 0, (int *)a4[v27 + 2]);
    v25 -= 3;
    v27 += 3;
  }
  while ((_DWORD)v24 != v26);
  v29 = &a4[-v25 + 36];
  v9 = v36;
LABEL_51:
  if (v29 != v9)
  {
    v39 = 0;
    v37 = 0u;
    v38 = 0u;
    kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v37 + 16))(&v37, "Malformed SIZ marker segment encountered. The final ");
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    *(_OWORD *)v40 = 0u;
    if (BYTE8(v37))
      sprintf(v40, "%x");
    else
      sprintf(v40, "%d");
    (*(void (**)(__int128 *, char *))(v37 + 16))(&v37, v40);
    (*(void (**)(__int128 *, const char *))(v37 + 16))(&v37, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)&v37);
  }
  return 1;
}

void sub_187F329C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F329D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, __int128 a12, uint64_t a13)
{
  _Unwind_Exception *v13;
  int v14;

  if (v14 == 1)
  {
    __cxa_begin_catch(v13);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(a11 + 16))(&a11, "Malformed SIZ marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(v13);
}

uint64_t kdu_read(unsigned __int8 **a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v3;
  uint64_t v4;
  _QWORD *exception;

  if (a3 >= 5)
    kdu_read();
  v3 = *a1;
  if (a2 - *a1 < a3)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = *a1;
    __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
  }
  *a1 = v3 + 1;
  v4 = *v3;
  if (a3 >= 2)
  {
    *a1 = v3 + 2;
    v4 = v3[1] | ((_DWORD)v4 << 8);
    if (a3 != 2)
    {
      *a1 = v3 + 3;
      v4 = v3[2] | ((_DWORD)v4 << 8);
      if (a3 >= 4)
      {
        *a1 = v3 + 4;
        return v3[3] | ((_DWORD)v4 << 8);
      }
    }
  }
  return v4;
}

uint64_t siz_params::finalize(siz_params *this, char a2)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int *v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int *v23;
  int v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  int v54;
  BOOL v55;
  unsigned int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  uint64_t i;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  uint64_t result;
  unsigned int v83;
  int v84;
  int v85;
  _BOOL4 v86;
  uint64_t v87;
  int v88;
  int *v89;
  kdu_params *v90;
  int v91;
  int v92;
  int v93;
  int v94;
  kdu_params *v95;
  int v96;
  int v98;
  kdu_params *v99;
  kdu_params *v100;
  int v101;
  int v103;
  BOOL v104;
  int v105;
  int v106;
  BOOL v107;
  int v108[2];
  int v109[2];
  int v110[4];
  __int128 v111;
  uint64_t v112;
  int v113;
  int v114;
  int v115[2];
  int v116[2];

  *(_QWORD *)v115 = 0;
  *(_QWORD *)v116 = 0;
  v114 = 0;
  v113 = 0;
  v3 = kdu_params::get(this, "Scomponents", 0, 0, &v116[1], 1, 1, 1);
  v4 = kdu_params::get(this, "Ssampling", 0, 0, v116, 1, 1, 1);
  v5 = kdu_params::get(this, "Sdims", 0, 0, v116, 1, 1, 1);
  v6 = 0;
  if (kdu_params::get(this, "Ssize", 0, 0, v115, 1, 1, 1))
    v6 = kdu_params::get(this, "Ssize", 0, 1, &v115[1], 1, 1, 1);
  if (!kdu_params::get(this, "Sorigin", 0, 0, &v113, 1, 1, 1)
    || (kdu_params::get(this, "Sorigin", 0, 1, &v114, 1, 1, 1) & 1) == 0)
  {
    v113 = 0;
    kdu_params::set(this, "Sorigin", 0, 0, 0);
    v114 = 0;
    kdu_params::set(this, "Sorigin", 0, 1, 0);
  }
  if (((v4 ^ 1 | v3) & 1) != 0)
  {
    if (((v5 ^ 1 | v3) & 1) != 0)
    {
      if ((v3 & 1) == 0)
      {
        v112 = 0;
        *(_OWORD *)v110 = 0u;
        v111 = 0u;
        kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information. Insufficient data supplied to determine the number of image components! Available information is as follows:\n\n");
        kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v110, 1);
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "\n");
        kdu_error::~kdu_error((kdu_error *)v110);
      }
    }
    else
    {
      v116[1] = 1;
      if (kdu_params::get(this, "Sdims", 1, 0, v116, 0, 0, 1))
      {
        do
          ++v116[1];
        while ((kdu_params::get(this, "Sdims", v116[1], 0, v116, 0, 0, 1) & 1) != 0);
      }
    }
  }
  else
  {
    v116[1] = 1;
    if (kdu_params::get(this, "Ssampling", 1, 0, v116, 0, 0, 1))
    {
      do
        ++v116[1];
      while ((kdu_params::get(this, "Ssampling", v116[1], 0, v116, 0, 0, 1) & 1) != 0);
    }
  }
  v7 = (int *)operator new[]();
  v8 = (int *)operator new[]();
  v9 = operator new[]();
  v10 = operator new[]();
  if (v5)
  {
    v11 = v116[1];
    if (v116[1] >= 1)
    {
      v12 = 0;
      v13 = 0;
      do
      {
        if (!kdu_params::get(this, "Sdims", v13, 0, &v8[v12], 1, 1, 1)
          || (kdu_params::get(this, "Sdims", v13, 1, &v7[v12], 1, 1, 1) & 1) == 0)
        {
          v112 = 0;
          *(_OWORD *)v110 = 0u;
          v111 = 0u;
          kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
          (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information. Component dimensions are only partially available!");
          MEMORY[0x18D761C18](v7, 0x1000C8052888210);
          MEMORY[0x18D761C18](v8, 0x1000C8052888210);
          MEMORY[0x18D761C18](v9, 0x1000C8052888210);
          MEMORY[0x18D761C18](v10, 0x1000C8052888210);
          kdu_error::~kdu_error((kdu_error *)v110);
        }
        ++v13;
        v11 = v116[1];
        ++v12;
      }
      while (v13 < v116[1]);
    }
    if ((v4 & 1) == 0)
    {
      if ((v6 | v4) == 1)
      {
        if ((v6 & 1) == 0)
LABEL_279:
          siz_params::finalize();
        goto LABEL_111;
      }
LABEL_105:
      v45 = v116[1];
      if (!synthesize_canvas_size(v116[1], v7, v114, &v115[1]) || !synthesize_canvas_size(v45, v8, v113, v115))
      {
        v112 = 0;
        *(_OWORD *)v110 = 0u;
        v111 = 0u;
        kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information Component dimensions are not consistent with a legal set of sub-sampling factors. Available information is as follows:\n\n");
        kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v110, 1);
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "\n");
        MEMORY[0x18D761C18](v7, 0x1000C8052888210);
        MEMORY[0x18D761C18](v8, 0x1000C8052888210);
        MEMORY[0x18D761C18](v9, 0x1000C8052888210);
        MEMORY[0x18D761C18](v10, 0x1000C8052888210);
        kdu_error::~kdu_error((kdu_error *)v110);
      }
      kdu_params::set(this, "Ssize", 0, 0, (int *)v115[0]);
      kdu_params::set(this, "Ssize", 0, 1, (int *)v115[1]);
      if (v4)
      {
LABEL_188:
        v24 = v116[1];
        goto LABEL_189;
      }
      goto LABEL_111;
    }
  }
  else
  {
    if (!v4)
      goto LABEL_39;
    v11 = v116[1];
  }
  if (v11 >= 1)
  {
    v101 = v4;
    v14 = 0;
    v15 = 0;
    do
    {
      if (!kdu_params::get(this, "Ssampling", v15, 0, (int *)(v10 + v14), 1, 1, 1)
        || (kdu_params::get(this, "Ssampling", v15, 1, (int *)(v9 + v14), 1, 1, 1) & 1) == 0)
      {
        v112 = 0;
        *(_OWORD *)v110 = 0u;
        v111 = 0u;
        kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information Component sub-sampling factors are only partially available!");
LABEL_36:
        MEMORY[0x18D761C18](v7, 0x1000C8052888210);
        MEMORY[0x18D761C18](v8, 0x1000C8052888210);
        MEMORY[0x18D761C18](v9, 0x1000C8052888210);
        MEMORY[0x18D761C18](v10, 0x1000C8052888210);
        kdu_error::~kdu_error((kdu_error *)v110);
      }
      if (*(int *)(v9 + v14) < 1 || *(int *)(v10 + v14) <= 0)
      {
        v112 = 0;
        *(_OWORD *)v110 = 0u;
        v111 = 0u;
        kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Image component sub-sampling factors must be strictly positive!");
        goto LABEL_36;
      }
      ++v15;
      v14 += 4;
    }
    while (v15 < v116[1]);
    v4 = v101;
    if (((v101 | v5) & 1) == 0)
    {
LABEL_39:
      v112 = 0;
      *(_OWORD *)v110 = 0u;
      v111 = 0u;
      kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information. Must have either the individual component dimensions or the component sub-sampling factors.");
      MEMORY[0x18D761C18](v7, 0x1000C8052888210);
      MEMORY[0x18D761C18](v8, 0x1000C8052888210);
      MEMORY[0x18D761C18](v9, 0x1000C8052888210);
      MEMORY[0x18D761C18](v10, 0x1000C8052888210);
      kdu_error::~kdu_error((kdu_error *)v110);
    }
  }
  if ((v5 & 1) == 0)
  {
    if ((v6 & 1) == 0)
    {
      v112 = 0;
      *(_OWORD *)v110 = 0u;
      v111 = 0u;
      kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information. Must have either the image component dimensions or the canvas size! Available information is as follows:\n\n");
      kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v110, 1);
      (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "\n");
      MEMORY[0x18D761C18](v7, 0x1000C8052888210);
      MEMORY[0x18D761C18](v8, 0x1000C8052888210);
      MEMORY[0x18D761C18](v9, 0x1000C8052888210);
      MEMORY[0x18D761C18](v10, 0x1000C8052888210);
      kdu_error::~kdu_error((kdu_error *)v110);
    }
    if (v116[1] >= 1)
    {
      v16 = 0;
      do
      {
        v17 = *(_DWORD *)(v9 + 4 * v16);
        if ((int)v17 <= 1)
          v17 = 1;
        if (v115[1] <= 0)
          v18 = -(int)(-v115[1] / v17);
        else
          v18 = (v115[1] - 1) / v17 + 1;
        if (v114 <= 0)
          v19 = -v114 / v17;
        else
          v19 = ~((v114 - 1) / v17);
        v7[v16] = v19 + v18;
        v20 = *(_DWORD *)(v10 + 4 * v16);
        if ((int)v20 <= 1)
          v20 = 1;
        if (v115[0] <= 0)
          v21 = -(int)(-v115[0] / v20);
        else
          v21 = (v115[0] - 1) / v20 + 1;
        if (v113 <= 0)
          v22 = -v113 / v20;
        else
          v22 = ~((v113 - 1) / v20);
        v23 = (int *)(v22 + v21);
        v8[v16] = (int)v23;
        kdu_params::set(this, "Sdims", v16, 0, v23);
        kdu_params::set(this, "Sdims", v16, 1, (int *)v7[v16]);
        ++v16;
      }
      while (v16 < v116[1]);
    }
  }
  if (((v6 | v4) & 1) == 0)
    goto LABEL_105;
  if ((v4 & 1) != 0)
  {
    v24 = v116[1];
    if ((v6 & 1) != 0)
      goto LABEL_189;
    if (v116[1] <= 0)
    {
      v27 = 0;
      v115[1] = 0;
    }
    else
    {
      v25 = 0;
      v26 = 0;
      LODWORD(v27) = 0;
      do
      {
        v28 = *(_DWORD *)(v9 + v25 * 4);
        if (v28 <= 1)
          v29 = 1;
        else
          v29 = *(_DWORD *)(v9 + v25 * 4);
        v30 = (v114 - 1) / v29;
        v31 = -(int)(-v114 / v29);
        if (v114 > 0)
          v31 = v30 + 1;
        v32 = (v7[v25] + v31) * v28;
        v33 = v32 - v28;
        if (v32 < v26 || v25 == 0)
          v26 = v32;
        if (v33 >= (int)v27 || v25 == 0)
          LODWORD(v27) = v33 + 1;
        ++v25;
      }
      while (v116[1] != v25);
      if ((int)v27 > v26)
      {
        v112 = 0;
        *(_OWORD *)v110 = 0u;
        v111 = 0u;
        kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information. Horizontal component dimensions and sub-sampling factors are incompatible. Available information is as follows:\n\n");
        kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v110, 1);
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "\n");
        MEMORY[0x18D761C18](v7, 0x1000C8052888210);
        MEMORY[0x18D761C18](v8, 0x1000C8052888210);
        MEMORY[0x18D761C18](v9, 0x1000C8052888210);
        MEMORY[0x18D761C18](v10, 0x1000C8052888210);
        kdu_error::~kdu_error((kdu_error *)v110);
      }
      v115[1] = v27;
      v36 = 0;
      do
      {
        v37 = *(_DWORD *)(v10 + v36 * 4);
        if (v37 <= 1)
          v38 = 1;
        else
          v38 = *(_DWORD *)(v10 + v36 * 4);
        v39 = (v113 - 1) / v38;
        v40 = -(int)(-v113 / v38);
        if (v113 > 0)
          v40 = v39 + 1;
        v41 = (v8[v36] + v40) * v37;
        v42 = v41 - v37;
        if (v41 < v26 || v36 == 0)
          v26 = v41;
        if (v42 >= (int)v27 || v36 == 0)
          v27 = (v42 + 1);
        else
          v27 = v27;
        ++v36;
      }
      while (v116[1] != v36);
      if ((int)v27 > v26)
      {
        v112 = 0;
        *(_OWORD *)v110 = 0u;
        v111 = 0u;
        kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information. Vertical component dimensions and sub-sampling factors are incompatible. Available information is as follows:\n\n");
        kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v110, 1);
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "\n");
        MEMORY[0x18D761C18](v7, 0x1000C8052888210);
        MEMORY[0x18D761C18](v8, 0x1000C8052888210);
        MEMORY[0x18D761C18](v9, 0x1000C8052888210);
        MEMORY[0x18D761C18](v10, 0x1000C8052888210);
        kdu_error::~kdu_error((kdu_error *)v110);
      }
    }
    v115[0] = v27;
    kdu_params::set(this, "Ssize", 0, 0, (int *)v27);
    kdu_params::set(this, "Ssize", 0, 1, (int *)v115[1]);
    goto LABEL_188;
  }
  if (!v6)
    goto LABEL_279;
LABEL_111:
  if (v116[1] < 1)
    goto LABEL_211;
  v46 = 0;
  do
  {
    v47 = v7[v46];
    v48 = (v115[1] - v114) / v47;
    if (v48 <= 1)
      v48 = 1;
    v49 = v115[1] - 1;
    if (v48 <= 1)
    {
      v50 = -v115[1];
      v51 = v114 - 1;
      v52 = -v114;
LABEL_128:
      v48 = 1;
    }
    else
    {
      v50 = -v115[1];
      v51 = v114 - 1;
      v52 = -v114;
      while (1)
      {
        v53 = v115[1] <= 0 ? -(int)(v50 / v48) : v49 / v48 + 1;
        v54 = v114 <= 0 ? v52 / v48 : ~(v51 / v48);
        if (v54 + v53 >= v47)
          break;
        v55 = v48-- <= 2;
        if (v55)
          goto LABEL_128;
      }
    }
    while (1)
    {
      v116[0] = v48;
      v56 = v48 <= 1 ? 1 : v48;
      v57 = v115[1] <= 0 ? -(int)(v50 / v56) : v49 / v56 + 1;
      v58 = v114 <= 0 ? v52 / v56 : ~(v51 / v56);
      if (v58 + v57 <= v47)
        break;
      ++v48;
    }
    if (v115[1] <= 0)
      v59 = -(int)(v50 / v56);
    else
      v59 = v49 / v56 + 1;
    if (v114 <= 0)
      v60 = v52 / v56;
    else
      v60 = ~(v51 / v56);
    if (v60 + v59 != v47)
    {
      v112 = 0;
      *(_OWORD *)v110 = 0u;
      v111 = 0u;
      kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information. Horizontal canvas and image component dimensions are not compatible.  Available information is as follows:\n\n");
      kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v110, 1);
      (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "\n");
      MEMORY[0x18D761C18](v7, 0x1000C8052888210);
      MEMORY[0x18D761C18](v8, 0x1000C8052888210);
      MEMORY[0x18D761C18](v9, 0x1000C8052888210);
      MEMORY[0x18D761C18](v10, 0x1000C8052888210);
      kdu_error::~kdu_error((kdu_error *)v110);
    }
    *(_DWORD *)(v9 + 4 * v46) = v48;
    v61 = v8[v46];
    v62 = (v115[0] - v113) / v61;
    if (v62 <= 1)
      v63 = 1;
    else
      v63 = v62;
    v64 = v115[0] - 1;
    if (v63 <= 1)
    {
      v65 = -v115[0];
      v66 = v113 - 1;
      v67 = -v113;
LABEL_164:
      v63 = 1;
    }
    else
    {
      v65 = -v115[0];
      v66 = v113 - 1;
      v67 = -v113;
      while (1)
      {
        v68 = v115[0] <= 0 ? -(int)(v65 / v63) : v64 / v63 + 1;
        v69 = v113 <= 0 ? v67 / v63 : ~(v66 / v63);
        if ((int)(v69 + v68) >= v61)
          break;
        v55 = (int)v63 <= 2;
        v63 = (v63 - 1);
        if (v55)
          goto LABEL_164;
      }
    }
    while (1)
    {
      v116[0] = v63;
      v70 = (int)v63 <= 1 ? 1 : v63;
      v71 = v115[0] <= 0 ? -(int)(v65 / v70) : v64 / v70 + 1;
      v72 = v113 <= 0 ? v67 / v70 : ~(v66 / v70);
      if (v72 + v71 <= v61)
        break;
      v63 = (v63 + 1);
    }
    if (v115[0] <= 0)
      v73 = -(int)(v65 / v70);
    else
      v73 = v64 / v70 + 1;
    if (v113 <= 0)
      v74 = v67 / v70;
    else
      v74 = ~(v66 / v70);
    if (v74 + v73 != v61)
    {
      v112 = 0;
      *(_OWORD *)v110 = 0u;
      v111 = 0u;
      kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information. Vertical canvas and image component dimensions are not compatible.  Available information is as follows:\n\n");
      kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v110, 1);
      (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "\n");
      MEMORY[0x18D761C18](v7, 0x1000C8052888210);
      MEMORY[0x18D761C18](v8, 0x1000C8052888210);
      MEMORY[0x18D761C18](v9, 0x1000C8052888210);
      MEMORY[0x18D761C18](v10, 0x1000C8052888210);
      kdu_error::~kdu_error((kdu_error *)v110);
    }
    *(_DWORD *)(v10 + 4 * v46) = v63;
    kdu_params::set(this, "Ssampling", v46, 0, (int *)v63);
    kdu_params::set(this, "Ssampling", v46, 1, (int *)*(unsigned int *)(v9 + 4 * v46));
    ++v46;
    v24 = v116[1];
  }
  while (v46 < v116[1]);
LABEL_189:
  if (v24 >= 1)
  {
    for (i = 0; i < v24; ++i)
    {
      v76 = *(_DWORD *)(v9 + 4 * i);
      if ((int)v76 <= 1)
        v76 = 1;
      if (v115[1] <= 0)
        v77 = -(int)(-v115[1] / v76);
      else
        v77 = (v115[1] - 1) / v76 + 1;
      if (v114 <= 0)
        v78 = -v114 / v76;
      else
        v78 = ~((v114 - 1) / v76);
      if (v78 + v77 != v7[i])
        goto LABEL_209;
      v79 = *(_DWORD *)(v10 + 4 * i);
      if ((int)v79 <= 1)
        v79 = 1;
      v80 = v115[0] <= 0 ? -(int)(-v115[0] / v79) : (v115[0] - 1) / v79 + 1;
      v81 = v113 <= 0 ? -v113 / v79 : ~((v113 - 1) / v79);
      if (v81 + v80 != v8[i])
      {
LABEL_209:
        v112 = 0;
        *(_OWORD *)v110 = 0u;
        v111 = 0u;
        kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problem trying to finalize SIZ information. Dimensions are inconsistent.  Available information is as follows:\n\n");
        kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v110, 1);
        (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "\n");
        MEMORY[0x18D761C18](v7, 0x1000C8052888210);
        MEMORY[0x18D761C18](v8, 0x1000C8052888210);
        MEMORY[0x18D761C18](v9, 0x1000C8052888210);
        MEMORY[0x18D761C18](v10, 0x1000C8052888210);
        kdu_error::~kdu_error((kdu_error *)v110);
      }
    }
  }
LABEL_211:
  MEMORY[0x18D761C18](v7, 0x1000C8052888210);
  MEMORY[0x18D761C18](v8, 0x1000C8052888210);
  MEMORY[0x18D761C18](v9, 0x1000C8052888210);
  MEMORY[0x18D761C18](v10, 0x1000C8052888210);
  *(_QWORD *)v108 = 0;
  *(_QWORD *)v109 = 0;
  if (!kdu_params::get(this, "Stile_origin", 0, 0, v108, 1, 1, 1)
    || (kdu_params::get(this, "Stile_origin", 0, 1, &v108[1], 1, 1, 1) & 1) == 0)
  {
    v108[0] = v113;
    kdu_params::set(this, "Stile_origin", 0, 0, (int *)v113);
    v108[1] = v114;
    kdu_params::set(this, "Stile_origin", 0, 1, (int *)v114);
  }
  if (!kdu_params::get(this, "Stiles", 0, 0, v109, 1, 1, 1)
    || (kdu_params::get(this, "Stiles", 0, 1, &v109[1], 1, 1, 1) & 1) == 0)
  {
    v109[1] = v115[1] - v108[1];
    v109[0] = v115[0] - v108[0];
    kdu_params::set(this, "Stiles", 0, 0, (int *)(v115[0] - v108[0]));
    kdu_params::set(this, "Stiles", 0, 1, (int *)v109[1]);
  }
  if (v108[1] > v114 || v109[1] + v108[1] <= v114 || v108[0] > v113 || v109[0] + v108[0] <= v113)
  {
    v112 = 0;
    *(_OWORD *)v110 = 0u;
    v111 = 0u;
    kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Problems trying to finalize SIZ information. Illegal tile origin coordinates.  The first tile must have a non-empty intersection with the image region on the canvas. Available information is as follows:\n\n");
    kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v110, 1);
    (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "\n");
    kdu_error::~kdu_error((kdu_error *)v110);
  }
  v107 = 0;
  if ((kdu_params::get(this, "Scap", 0, 0, &v107, 1, 1, 1) & 1) == 0)
  {
    v107 = 0;
    kdu_params::set((uint64_t)this, "Scap", 0, 0, 0);
  }
  v106 = 0;
  if ((kdu_params::get(this, "Sextensions", 0, 0, &v106, 1, 1, 1) & 1) == 0)
  {
    v106 = 0;
    kdu_params::set(this, "Sextensions", 0, 0, 0);
  }
  v105 = 0;
  result = kdu_params::get(this, "Sprofile", 0, 0, &v105, 1, 1, 1);
  if ((result & 1) == 0)
  {
    v105 = 2;
    result = (uint64_t)kdu_params::set(this, "Sprofile", 0, 0, (int *)2);
  }
  if (v105 >= 6)
  {
    v112 = 0;
    *(_OWORD *)v110 = 0u;
    v111 = 0u;
    kdu_error::kdu_error((kdu_error *)v110, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v110 + 16))(v110, "Illegal profile index.  \"Sprofile\" must be in the range 0 to 5: Profile-0 is the most restrictive original Part-1 profile; Profile-2 is the unrestricted Part-1 profile; 3 means that the codestream conforms to Part-2 of the sta"
      "ndard; 4 and 5 are for the restrictive Digital Cinema profiles, added by an ammendment to Part-1 of the standard.");
    kdu_error::~kdu_error((kdu_error *)v110);
  }
  if ((a2 & 1) == 0)
  {
    v83 = v105;
    v84 = v106;
    if (v106 && v105 != 3)
    {
      v105 = 3;
      kdu_params::set(this, "Sprofile", 0, 0, (int *)3);
    }
    v110[0] = 0;
    v85 = kdu_params::get(this, "Mcomponents", 0, 0, v110, 1, 1, 1);
    v86 = v110[0] > 0;
    if ((v85 & v86) != 0)
      v87 = 3;
    else
      v87 = v83;
    if ((v85 & v86) != 0)
      v88 = 256;
    else
      v88 = 0;
    v89 = (int *)(v88 | v84 & 0xFFFFFEFF);
    result = kdu_params::access_cluster(this, "COD");
    if (result)
    {
      v90 = (kdu_params *)result;
      v91 = *(_DWORD *)(result + 28);
      v92 = *(_DWORD *)(result + 32);
      v104 = 0;
      v103 = v91;
      if ((v91 & 0x80000000) == 0)
      {
        v93 = -1;
        while (v92 < 0)
        {
LABEL_273:
          if (++v93 == v103)
            goto LABEL_274;
        }
        v94 = -1;
        while (1)
        {
          result = kdu_params::access_unique(v90, v93, v94, 0);
          if (result)
            break;
LABEL_268:
          if (++v94 == v92)
            goto LABEL_273;
        }
        v95 = (kdu_params *)result;
        if ((!kdu_params::get((kdu_params *)result, "Cads", 0, 0, v116, 0, 1, 1) || !v116[0])
          && ((v93 & 0x80000000) == 0 || !kdu_params::get(v95, "Cdfs", 0, 0, v116, 0, 1, 1) || !v116[0]))
        {
          if (!kdu_params::get(v95, "Cdecomp", 0, 0, v116, 0, 0, 1))
          {
LABEL_254:
            if (kdu_params::get(v95, "Catk", 0, 0, v116, 0, 1, 1))
            {
              v98 = v116[0];
              if (v116[0])
              {
                v99 = (kdu_params *)kdu_params::access_cluster(this, "ATK");
                if (v99
                  && (v100 = (kdu_params *)kdu_params::access_relation(v99, v93, -1, v98, 1)) != 0
                  && kdu_params::get(v100, "Ksymmetric", 0, 0, &v104, 1, 1, 1)
                  && v104)
                {
                  v89 = (int *)(v89 | 0x80);
                }
                else
                {
                  v89 = (int *)(v89 | 0x40);
                }
                v87 = 3;
              }
            }
            result = kdu_params::get(v95, "Calign_blk_last", 0, 0, &v104, 1, 1, 1);
            if ((_DWORD)result && v104
              || (result = kdu_params::get(v95, "Calign_blk_last", 0, 1, &v104, 1, 1, 1), (_DWORD)result) && v104)
            {
              v87 = 3;
            }
            goto LABEL_268;
          }
          v96 = 1;
          while (v116[0] == 3)
          {
            if (!kdu_params::get(v95, "Cdecomp", v96++, 0, v116, 0, 0, 1))
              goto LABEL_254;
          }
        }
        v89 = (int *)(v89 | 0x20);
        v87 = 3;
        goto LABEL_254;
      }
    }
LABEL_274:
    if ((_DWORD)v87 != v105)
      result = (uint64_t)kdu_params::set(this, "Sprofile", 0, 0, (int *)v87);
    if ((_DWORD)v89 != v106)
      return (uint64_t)kdu_params::set(this, "Sextensions", 0, 0, v89);
  }
  return result;
}

void sub_187F34608(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F34614(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

BOOL synthesize_canvas_size(int a1, int *a2, int a3, int *a4)
{
  int v4;
  int *v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;

  v4 = *a2;
  if (a1 >= 2)
  {
    v5 = a2 + 1;
    v6 = a1 - 1;
    do
    {
      v8 = *v5++;
      v7 = v8;
      if (v8 > v4)
        v4 = v7;
      --v6;
    }
    while (v6);
  }
  v9 = a3 - 1;
  v10 = -a3;
  v11 = 1;
  v12 = 1;
  while (1)
  {
    v13 = -(int)(v10 / v12);
    if (a3 > 0)
      v13 = v9 / v12 + 1;
    v14 = (v13 + v4) * v12;
    v15 = v14 - v12 + 1;
    if (a1 < 1)
    {
      LODWORD(v16) = 0;
    }
    else
    {
      v16 = 0;
      while (1)
      {
        v17 = a2[v16];
        v18 = (v15 - a3) / v17;
        if (v18 <= 1)
          v18 = 1;
        if (v18 < 2)
        {
LABEL_19:
          v18 = 1;
        }
        else
        {
          while (1)
          {
            v19 = -(int)(v10 / v18);
            if (a3 > 0)
              v19 = v9 / v18 + 1;
            if ((v19 + v17) * v18 <= v15)
              break;
            if (v18-- <= 2)
              goto LABEL_19;
          }
        }
        v21 = v18 - 1;
        v22 = v18 + 1;
        v23 = ~v18;
        do
        {
          v24 = v22;
          v25 = v23;
          if (v18 <= 1)
            v26 = 1;
          else
            v26 = v18;
          v27 = -(int)(v10 / v26);
          v28 = v9 / v26;
          if (a3 > 0)
            v29 = v28 + 1;
          else
            v29 = v27;
          v30 = (v29 + v17) * v18++;
          ++v21;
          v22 = v24 + 1;
          --v23;
        }
        while (v30 < v15);
        v31 = v21 * (v17 + v29) - v18;
        v32 = v31 + 1;
        v33 = v31 + 2;
        if (v32 >= v15)
          v15 = v33;
        if (v15 > v14)
          break;
        if (v18 != 256)
        {
          do
          {
            if (v24 <= 1)
              v34 = 1;
            else
              v34 = v24;
            v35 = v9 / v34;
            v36 = -(int)(v10 / v34);
            if (a3 > 0)
              v36 = v35 + 1;
            v37 = (v36 + v17) * v24;
            if (v25 + v37 >= v14)
              break;
            ++v24;
            --v25;
            v30 = v37;
          }
          while (v24 != 256);
        }
        if (v30 < v14)
          v14 = v30;
        if (v15 > v14)
          break;
        if (++v16 == a1)
          goto LABEL_48;
      }
    }
    if ((_DWORD)v16 == a1)
      break;
    v11 = v12++ < 0xFF;
    if (v12 == 256)
      return 0;
  }
LABEL_48:
  *a4 = v15;
  return v11;
}

void mct_params::mct_params(mct_params *this)
{
  __int128 v2;

  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 1;
  *((_BYTE *)this + 42) = 1;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BABB60;
  *((_QWORD *)this + 1) = "MCT";
  *(_QWORD *)&v2 = 0xFFFFFFFF00000000;
  *((_QWORD *)&v2 + 1) = 0xFFFFFFFF00000000;
  *(_OWORD *)((char *)this + 152) = v2;
  *((_QWORD *)this + 21) = 0xFFFFFFFF00000000;
}

void sub_187F34A30(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t mct_params::copy_with_xforms(mct_params *this, kdu_params *a2)
{
  BOOL v4;
  int v5;
  int v6;
  uint64_t result;
  int v8;
  uint64_t v9;

  v9 = 0;
  if (kdu_params::get(a2, "Mmatrix_size", 0, 0, (int *)&v9, 0, 1, 1))
    v4 = (int)v9 < 1;
  else
    v4 = 1;
  if (!v4)
  {
    kdu_params::set(this, "Mmatrix_size", 0, 0, (int *)v9);
    if ((int)v9 >= 1)
    {
      v5 = 0;
      do
      {
        if (!kdu_params::get(a2, "Mmatrix_coeffs", v5, 0, (float *)&v9 + 1, 1, 1, 1))
          break;
        kdu_params::set((uint64_t)this, "Mmatrix_coeffs", v5++, 0, *((float *)&v9 + 1));
      }
      while (v5 < (int)v9);
    }
  }
  if (kdu_params::get(a2, "Mvector_size", 0, 0, (int *)&v9, 0, 1, 1))
  {
    if ((int)v9 >= 1)
    {
      kdu_params::set(this, "Mvector_size", 0, 0, (int *)v9);
      if ((int)v9 >= 1)
      {
        v6 = 0;
        do
        {
          if (!kdu_params::get(a2, "Mvector_coeffs", v6, 0, (float *)&v9 + 1, 1, 1, 1))
            break;
          kdu_params::set((uint64_t)this, "Mvector_coeffs", v6++, 0, *((float *)&v9 + 1));
        }
        while (v6 < (int)v9);
      }
    }
  }
  result = kdu_params::get(a2, "Mtriang_size", 0, 0, (int *)&v9, 0, 1, 1);
  if ((_DWORD)result)
  {
    if ((int)v9 >= 1)
    {
      result = (uint64_t)kdu_params::set(this, "Mtriang_size", 0, 0, (int *)v9);
      if ((int)v9 >= 1)
      {
        v8 = 0;
        do
        {
          result = kdu_params::get(a2, "Mtriang_coeffs", v8, 0, (float *)&v9 + 1, 1, 1, 1);
          if (!(_DWORD)result)
            break;
          result = kdu_params::set((uint64_t)this, "Mtriang_coeffs", v8++, 0, *((float *)&v9 + 1));
        }
        while (v8 < (int)v9);
      }
    }
  }
  return result;
}

uint64_t mct_params::finalize(uint64_t this, int a2)
{
  kdu_params *v2;
  int v3[2];
  int v4[2];
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v2 = (kdu_params *)this;
  if (a2)
  {
    if (*(_DWORD *)(this + 152) <= *(_DWORD *)(this + 156)
      || *(_DWORD *)(this + 160) <= *(_DWORD *)(this + 164)
      || *(_DWORD *)(this + 168) <= *(_DWORD *)(this + 172))
    {
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      goto LABEL_23;
    }
  }
  else
  {
    *(_QWORD *)v3 = 0;
    *(_QWORD *)v4 = 0;
    if (kdu_params::get((kdu_params *)this, "Mmatrix_size", 0, 0, &v4[1], 0, 1, 1) && v4[1] < 1
      || kdu_params::get(v2, "Mvector_size", 0, 0, v4, 0, 1, 1) && v4[0] < 1
      || (this = kdu_params::get(v2, "Mtriang_size", 0, 0, &v3[1], 0, 1, 1), (_DWORD)this) && v3[1] <= 0)
    {
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    if (!*((_DWORD *)v2 + 6) && v4[0] | v3[1] | v4[1])
    {
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    if (v4[1] >= 1 && (this = kdu_params::get(v2, "Mmatrix_coeffs", v4[1] - 1, 0, (float *)v3, 1, 1, 1), !(_DWORD)this)
      || v4[0] >= 1 && (this = kdu_params::get(v2, "Mvector_coeffs", v4[0] - 1, 0, (float *)v3, 1, 1, 1), !(_DWORD)this)
      || v3[1] >= 1
      && (this = kdu_params::get(v2, "Mtriang_coeffs", v3[1] - 1, 0, (float *)v3, 1, 1, 1), (this & 1) == 0))
    {
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
LABEL_23:
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
  }
  return this;
}

void sub_187F34F4C(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F34F58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

BOOL mct_params::check_marker_segment(mct_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  int v7;
  int v8;

  if (a2 != 65396 || a3 < 4)
    return 0;
  v7 = a4[2];
  v8 = a4[3];
  *a5 = v8;
  return (~v7 & 3) != 0 && v8 != 0;
}

uint64_t mct_params::read_marker_segment(mct_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t result;
  int v7;
  unint64_t v8;
  int v9;
  unsigned __int8 *v10;
  signed int v11;
  unsigned __int8 *v12;
  signed int v13;
  const char *v14;
  int v15;
  char *v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  _QWORD *exception;
  int v22[4];
  __int128 v23;
  uint64_t v24;
  char v25[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a5)
    return 0;
  result = 0;
  if (a2 == 65396 && a3 >= 4)
  {
    v7 = *((_DWORD *)this + 6);
    if (!v7)
      return 0;
    result = 0;
    if (v7 == a4[3])
    {
      v8 = a4[2];
      v9 = v8 & 3;
      if (v9 != 3)
      {
        v10 = &a4[a3];
        v11 = __rev16(*(unsigned __int16 *)a4);
        v12 = a4 + 4;
        if (v11)
        {
          v13 = 0;
          if ((v8 & 3) != 0)
            goto LABEL_11;
        }
        else
        {
          if (a3 <= 5)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = v12;
            __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
          }
          v12 = a4 + 6;
          v13 = __rev16(*((unsigned __int16 *)a4 + 2));
          if ((v8 & 3) != 0)
          {
LABEL_11:
            if (v9 == 1)
            {
              if (v11)
                v13 = *((_DWORD *)this + 39);
              else
                *((_DWORD *)this + 39) = v13;
              v16 = (char *)this + 152;
              v14 = "Mmatrix_size";
            }
            else
            {
              if (v9 != 2)
              {
                v14 = 0;
                v15 = 0;
                v13 = 0;
                goto LABEL_29;
              }
              if (v11)
                v13 = *((_DWORD *)this + 41);
              else
                *((_DWORD *)this + 41) = v13;
              v16 = (char *)this + 160;
              v14 = "Mvector_size";
            }
LABEL_28:
            v15 = (*(_DWORD *)v16)++;
LABEL_29:
            if (v11 > v13 || v11 < v15)
            {
              *(_QWORD *)&v27 = 0;
              *(_OWORD *)v25 = 0u;
              v26 = 0u;
              kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)v25);
            }
            if (v11 != v15)
            {
              *(_QWORD *)&v27 = 0;
              *(_OWORD *)v25 = 0u;
              v26 = 0u;
              kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)v25);
            }
            v17 = (v8 >> 2) & 3;
            v18 = dword_18820D310[v17];
            v22[0] = 0;
            if (v15 < 1)
            {
              v19 = 0;
            }
            else
            {
              kdu_params::get(this, v14, 0, 0, v22, 1, 1, 1);
              v19 = v22[0];
            }
            v20 = ((int)v10 - (int)v12) / v18;
            kdu_params::set(this, v14, 0, 0, (int *)(v19 + v20));
            if (v20 >= 1)
              __asm { BR              X8 }
            if (v12 != v10)
            {
              v24 = 0;
              *(_OWORD *)v22 = 0u;
              v23 = 0u;
              kdu_error::kdu_error((kdu_error *)v22, "Kakadu Core Error:\n");
              (*(void (**)(int *, const char *))(*(_QWORD *)v22 + 16))(v22, "Malformed MCT marker segment encountered. The final ");
              v28 = 0u;
              v29 = 0u;
              v26 = 0u;
              v27 = 0u;
              *(_OWORD *)v25 = 0u;
              if (LOBYTE(v22[2]))
                sprintf(v25, "%x");
              else
                sprintf(v25, "%d");
              (*(void (**)(int *, char *))(*(_QWORD *)v22 + 16))(v22, v25);
              (*(void (**)(int *, const char *))(*(_QWORD *)v22 + 16))(v22, " bytes were not consumed!");
              kdu_error::~kdu_error((kdu_error *)v22);
            }
            return 1;
          }
        }
        if (v11)
          v13 = *((_DWORD *)this + 43);
        else
          *((_DWORD *)this + 43) = v13;
        v16 = (char *)this + 168;
        v14 = "Mtriang_size";
        goto LABEL_28;
      }
    }
  }
  return result;
}

void sub_187F35448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int128 a17, __int128 a18, uint64_t a19)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    a19 = 0;
    a17 = 0u;
    a18 = 0u;
    kdu_error::kdu_error((kdu_error *)&a17, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(a17 + 16))(&a17, "Malformed MCT marker segment encountered.  Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mct_params::write_marker_segment(mct_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  int v4;
  uint64_t result;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  const char *v13;
  int v14;
  float v15;
  float v16;
  _BOOL4 v17;
  int v19;
  int v20;
  __int16 v21;
  int v22;
  int v23;
  __int16 v24;
  int v25;
  const char *v26;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  unsigned int v31;
  __int16 v32;
  uint64_t v33;
  int v34;
  unsigned int v35;
  int v36[2];
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = *((_DWORD *)this + 6);
  if (v4 < 1)
    return 0;
  result = 0;
  if (!a4 && v4 <= 0xFF)
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
      return 0;
    v37 = 0;
    *(_QWORD *)v36 = 0;
    kdu_params::get(this, "Mtriang_size", 0, 0, v36, 0, 1, 1);
    kdu_params::get(this, "Mmatrix_size", 0, 0, &v36[1], 0, 1, 1);
    kdu_params::get(this, "Mvector_size", 0, 0, &v37, 0, 1, 1);
    v8 = 0;
    result = 0;
    do
    {
      v9 = v36[v8];
      if (v9)
        result = (result + 4 * v9 + 8 * ((v9 - 1) / 4092) + 10);
      ++v8;
    }
    while (v8 != 3);
    if (a2 && (_DWORD)result)
    {
      v31 = result;
      v10 = 0;
      v11 = 0;
      do
      {
        v12 = v36[v10];
        if (v12)
        {
          *(float *)&v35 = 0.0;
          if (v12 < 1)
          {
            v17 = 0;
          }
          else
          {
            v13 = off_1E1BBE4B8[v10];
            v14 = 1;
            do
            {
              kdu_params::get(this, v13, v14 - 1, 0, (float *)&v35, 1, 1, 1);
              v15 = floor(*(float *)&v35 + 0.5);
              v16 = *(float *)&v35 - v15;
              *(float *)&v35 = v16;
              v17 = v16 > 0.0001 || v16 < 0.0001;
              v12 = v36[v10];
              if (v16 < 0.0001)
                break;
              if (v16 > 0.0001)
                break;
            }
            while (v14++ < v12);
          }
          if (v12 >= -4090)
          {
            v19 = 0;
            v20 = 0;
            v34 = (v12 - 1) / 4092;
            if (v17)
              v21 = 2048;
            else
              v21 = 1024;
            v32 = v21 | ((_WORD)v10 << 8);
            v33 = v10;
            do
            {
              v22 = v36[v10] - v19;
              if (v22 >= 4092)
                v23 = 4092;
              else
                v23 = v36[v10] - v19;
              kdu_output::put(a2, 255);
              kdu_output::put(a2, 116);
              v24 = ((2 * (v20 == 0)) | (4 * v23)) + 6;
              kdu_output::put(a2, SHIBYTE(v24));
              kdu_output::put(a2, v24 & 0xFE);
              kdu_output::put(a2, SBYTE1(v20));
              kdu_output::put(a2, v20);
              v25 = *((_DWORD *)this + 6);
              kdu_output::put(a2, (unsigned __int16)(v32 + v25) >> 8);
              kdu_output::put(a2, v25);
              if (v20)
              {
                v11 += 8;
              }
              else
              {
                kdu_output::put(a2, SBYTE1(v34));
                kdu_output::put(a2, v34);
                v11 += 10;
              }
              if (v22 >= 1)
              {
                v26 = off_1E1BBE4B8[v10];
                if (v23 <= 1)
                  v27 = 1;
                else
                  v27 = v23;
                v28 = v19;
                do
                {
                  kdu_params::get(this, v26, v28, 0, (float *)&v35, 1, 1, 1);
                  if (v17)
                  {
                    kdu_output::put(a2, v35);
                    v29 = 4;
                  }
                  else
                  {
                    v29 = kdu_output::put(a2, vcvtmd_s64_f64(*(float *)&v35 + 0.5));
                  }
                  v11 += v29;
                  ++v28;
                  --v27;
                }
                while (v27);
              }
              v19 += v23;
              v30 = v20++ == v34;
              v10 = v33;
            }
            while (!v30);
          }
        }
        ++v10;
      }
      while (v10 != 3);
      result = v31;
      if (v31 != v11)
        mct_params::write_marker_segment();
    }
  }
  return result;
}

void mcc_params::mcc_params(mcc_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 1;
  *((_BYTE *)this + 42) = 1;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BABAA0;
  *((_QWORD *)this + 1) = "MCC";
    "ansform block operates on the next N2 components in this list; and so forth.",
    "II",
    1);
    "t listed (these are the holes) are taken to be identically equal to 0.  The first transform block in the stage proce"
    "sses the first N1 components in the list to produces the first M1 components in the output list; the second transfor"
    "m block in the stage processes the next N1 components in the input list, producing the next M2 components in the out"
    "put list; and so forth.",
    "II",
    1);
    "offsets to be applied after inverse transformation of the input components to the block.  A value of 0 for this fiel"
    "d means that there is no offset; otherwise, the value must be in the range 1 to 255.\n"
    "\t\t   For DWT transforms, the 4'th field in the record identifies the number of DWT levels to be used, in the range"
    "mponent axis.  For dependency and decorrelation transforms, the 4'th field must hold 0 if the transform is irreversi"
    "ble, or 1 if it is reversible, while the 5'th field must hold 0.",
    "(DEP=0,MAT=1,DWT=3)IIII",
    1);
}

void sub_187F35A28(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t mcc_params::finalize(uint64_t this, char a2)
{
  kdu_params *v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  char v9;
  int v10;
  int v11;
  int v12[2];
  int v13;
  int v14;
  int v15[2];
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  int v19[2];

  if ((a2 & 1) == 0)
  {
    v2 = (kdu_params *)this;
    *(_QWORD *)v19 = 0;
    v3 = 0;
    if (kdu_params::get((kdu_params *)this, "Mstage_inputs", 0, 0, &v19[1], 0, 0, 1))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        if (!kdu_params::get(v2, "Mstage_inputs", v4, 1, v19, 0, 0, 1))
          break;
        if (v19[0] >= 0x4000 || v19[1] < 0 || v19[1] > v19[0])
        {
          v18 = 0;
          v16 = 0u;
          v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        v3 = v3 + v19[0] - v19[1] + 1;
        ++v4;
      }
      while ((kdu_params::get(v2, "Mstage_inputs", v4, 0, &v19[1], 0, 0, 1) & 1) != 0);
    }
    v5 = 0;
    if (kdu_params::get(v2, "Mstage_outputs", 0, 0, &v19[1], 0, 0, 1))
    {
      v5 = 0;
      v6 = 0;
      do
      {
        if (!kdu_params::get(v2, "Mstage_outputs", v6, 1, v19, 0, 0, 1))
          break;
        if (v19[0] >= 0x4000 || v19[1] < 0 || v19[1] > v19[0])
        {
          v18 = 0;
          v16 = 0u;
          v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        v5 = v5 + v19[0] - v19[1] + 1;
        ++v6;
      }
      while ((kdu_params::get(v2, "Mstage_outputs", v6, 0, &v19[1], 0, 0, 1) & 1) != 0);
    }
    *(_QWORD *)v15 = 0;
    v7 = 0;
    if (kdu_params::get(v2, "Mstage_collections", 0, 0, &v15[1], 0, 0, 1))
    {
      do
      {
        if (!kdu_params::get(v2, "Mstage_collections", v7, 1, v15, 0, 0, 1))
          break;
        if (v15[1] < 1 || v15[0] <= 0)
        {
          v18 = 0;
          v16 = 0u;
          v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        ++v7;
        v3 -= v15[1];
        v5 -= v15[0];
        v9 = kdu_params::get(v2, "Mstage_collections", v7, 0, &v15[1], 0, 0, 1);
      }
      while ((v9 & 1) != 0);
    }
    if (v3 | v5)
    {
      v18 = 0;
      v16 = 0u;
      v17 = 0u;
      kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v16);
    }
    v14 = 0;
    this = kdu_params::get(v2, "Mstage_xforms", 0, 0, &v14, 0, 0, 1);
    v10 = 0;
    if ((_DWORD)this)
    {
      v10 = 0;
      do
      {
        v13 = 0;
        *(_QWORD *)v12 = 0;
        v11 = 0;
        if (!kdu_params::get(v2, "Mstage_xforms", v10, 1, &v13, 0, 0, 1)
          || !kdu_params::get(v2, "Mstage_xforms", v10, 2, &v12[1], 0, 0, 1)
          || !kdu_params::get(v2, "Mstage_xforms", v10, 3, v12, 0, 0, 1)
          || !kdu_params::get(v2, "Mstage_xforms", v10, 4, &v11, 0, 0, 1)
          || v13 < 0
          || v13 > 255
          || v12[1] < 0
          || v12[1] >= 256)
        {
          v18 = 0;
          v16 = 0u;
          v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        if (v14 == 3 && v12[0] >= 0x21u)
        {
          v18 = 0;
          v16 = 0u;
          v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        if (v14 != 3 && (v12[0] > 1u || v11))
        {
          v18 = 0;
          v16 = 0u;
          v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        this = kdu_params::get(v2, "Mstage_xforms", ++v10, 0, &v14, 0, 0, 1);
      }
      while ((this & 1) != 0);
    }
    if (v7 != v10)
    {
      v18 = 0;
      v16 = 0u;
      v17 = 0u;
      kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v16);
    }
  }
  return this;
}

void sub_187F36030(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F3603C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Exception *v13;

  _Unwind_Resume(v13);
}

uint64_t mcc_params::copy_with_xforms(mcc_params *this, kdu_params *a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t result;
  int v8;
  int v9;
  int v10[2];
  int v11[2];
  int v12[2];
  int v13;
  int v14;

  v14 = 0;
  v13 = 0;
  if (kdu_params::get(a2, "Mstage_inputs", 0, 0, &v14, 0, 0, 1))
  {
    v4 = 0;
    do
    {
      if (!kdu_params::get(a2, "Mstage_inputs", v4, 1, &v13, 0, 0, 1))
        break;
      kdu_params::set(this, "Mstage_inputs", v4, 0, (int *)v14);
      kdu_params::set(this, "Mstage_inputs", v4++, 1, (int *)v13);
    }
    while ((kdu_params::get(a2, "Mstage_inputs", v4, 0, &v14, 0, 0, 1) & 1) != 0);
  }
  if (kdu_params::get(a2, "Mstage_outputs", 0, 0, &v14, 0, 0, 1))
  {
    v5 = 0;
    do
    {
      if (!kdu_params::get(a2, "Mstage_outputs", v5, 1, &v13, 0, 0, 1))
        break;
      kdu_params::set(this, "Mstage_outputs", v5, 0, (int *)v14);
      kdu_params::set(this, "Mstage_outputs", v5++, 1, (int *)v13);
    }
    while ((kdu_params::get(a2, "Mstage_outputs", v5, 0, &v14, 0, 0, 1) & 1) != 0);
  }
  *(_QWORD *)v12 = 0;
  if (kdu_params::get(a2, "Mstage_collections", 0, 0, &v12[1], 0, 0, 1))
  {
    v6 = 0;
    do
    {
      if (!kdu_params::get(a2, "Mstage_collections", v6, 1, v12, 0, 0, 1))
        break;
      kdu_params::set(this, "Mstage_collections", v6, 0, (int *)v12[1]);
      kdu_params::set(this, "Mstage_collections", v6++, 1, (int *)v12[0]);
    }
    while ((kdu_params::get(a2, "Mstage_collections", v6, 0, &v12[1], 0, 0, 1) & 1) != 0);
  }
  *(_QWORD *)v10 = 0;
  *(_QWORD *)v11 = 0;
  v9 = 0;
  result = kdu_params::get(a2, "Mstage_xforms", 0, 0, &v11[1], 0, 0, 1);
  if ((_DWORD)result)
  {
    v8 = 0;
    do
    {
      result = kdu_params::get(a2, "Mstage_xforms", v8, 1, v11, 0, 0, 1);
      if (!(_DWORD)result)
        break;
      result = kdu_params::get(a2, "Mstage_xforms", v8, 2, &v10[1], 0, 0, 1);
      if (!(_DWORD)result)
        break;
      result = kdu_params::get(a2, "Mstage_xforms", v8, 3, v10, 0, 0, 1);
      if (!(_DWORD)result)
        break;
      result = kdu_params::get(a2, "Mstage_xforms", v8, 4, &v9, 0, 0, 1);
      if (!(_DWORD)result)
        break;
      kdu_params::set(this, "Mstage_xforms", v8, 0, (int *)v11[1]);
      kdu_params::set(this, "Mstage_xforms", v8, 1, (int *)v11[0]);
      kdu_params::set(this, "Mstage_xforms", v8, 2, (int *)v10[1]);
      kdu_params::set(this, "Mstage_xforms", v8, 3, (int *)v10[0]);
      kdu_params::set(this, "Mstage_xforms", v8++, 4, (int *)v9);
      result = kdu_params::get(a2, "Mstage_xforms", v8, 0, &v11[1], 0, 0, 1);
    }
    while ((result & 1) != 0);
  }
  return result;
}

BOOL mcc_params::check_marker_segment(mcc_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  _BOOL8 result;

  result = a2 == 65397 && a3 > 2;
  if (result)
    *a5 = a4[2];
  return result;
}

uint64_t mcc_params::read_marker_segment(mcc_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t result;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  unsigned int v22;
  unint64_t v23;
  unsigned __int8 *v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  unsigned int v31;
  unsigned int v32;
  int *v33;
  int *v34;
  int *v35;
  int v36;
  int *v37;
  BOOL v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD *v45;
  _QWORD *v46;
  _QWORD *exception;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned __int8 *v53;
  _OWORD v54[2];
  uint64_t v55;
  char v56[16];
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (a5)
    return 0;
  result = 0;
  if (a2 == 65397 && a3 >= 3)
  {
    if (*((_DWORD *)this + 6) != a4[2])
      return 0;
    if (__rev16(*(unsigned __int16 *)a4))
      goto LABEL_10;
    if (a3 <= 4)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = a4 + 3;
      __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
    }
    v8 = a4 + 5;
    if (__rev16(*(unsigned __int16 *)(a4 + 3)))
    {
LABEL_10:
      *(_QWORD *)&v58 = 0;
      *(_OWORD *)v56 = 0u;
      v57 = 0u;
      kdu_error::kdu_error((kdu_error *)v56, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v56 + 16))(v56, "Encountered MCC (Multi-component transform Component Collection) information which has been split across multiple marker segments.  While this is not illegal, Kakadu does not currently support such massive multi-component transform descriptions.  It is a rare application indeed that would need multiple marker segments.");
      kdu_error::~kdu_error((kdu_error *)v56);
    }
    v53 = &a4[a3];
    if (v53 - v8 <= 1)
    {
      v46 = __cxa_allocate_exception(8uLL);
      *v46 = v8;
      __cxa_throw(v46, MEMORY[0x1E0DE4E60], 0);
    }
    v10 = *(unsigned __int16 *)v8;
    v9 = a4 + 7;
    v48 = __rev16(v10);
    if (v48)
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      while (1)
      {
        if (v53 - v9 < 1)
        {
          v42 = __cxa_allocate_exception(8uLL);
          *v42 = v9;
          __cxa_throw(v42, MEMORY[0x1E0DE4E60], 0);
        }
        v52 = *v9;
        if (v53 - (v9 + 1) <= 1)
        {
          v41 = __cxa_allocate_exception(8uLL);
          *v41 = v9 + 1;
          __cxa_throw(v41, MEMORY[0x1E0DE4E60], 0);
        }
        v14 = v9[1];
        v15 = v9 + 3;
        v49 = v11;
        v51 = v9[2] | ((v14 & 0x7F) << 8);
        if (v51)
        {
          v16 = v9[2] | ((v14 & 0x7F) << 8);
          v17 = (char)v14;
          v18 = (v14 >> 7) + 1;
          v19 = 0xFFFFFFFFLL;
          v20 = 0xFFFFFFFFLL;
          while (1)
          {
            if (v53 - v15 < v18)
            {
              v39 = __cxa_allocate_exception(8uLL);
              *v39 = v15;
              __cxa_throw(v39, MEMORY[0x1E0DE4E60], 0);
            }
            v21 = (int *)v19;
            v19 = *v15;
            if (v17 < 0)
            {
              v19 = v15[1] | ((_DWORD)v19 << 8);
              if ((_DWORD)v18 == 2)
              {
                v15 += 2;
                if ((v21 & 0x80000000) != 0)
                  goto LABEL_28;
              }
              else
              {
                v22 = v15[2];
                v15 += 3;
                v19 = v22 | ((_DWORD)v19 << 8);
                if ((v21 & 0x80000000) != 0)
                  goto LABEL_28;
              }
            }
            else
            {
              ++v15;
              if ((v21 & 0x80000000) != 0)
                goto LABEL_28;
            }
            if ((_DWORD)v19 != (_DWORD)v21 + 1)
            {
              kdu_params::set(this, "Mstage_inputs", v13, 0, (int *)v20);
              kdu_params::set(this, "Mstage_inputs", v13++, 1, v21);
LABEL_28:
              v20 = v19;
            }
            if (!--v16)
            {
              kdu_params::set(this, "Mstage_inputs", v13, 0, (int *)v20);
              kdu_params::set(this, "Mstage_inputs", v13++, 1, (int *)v19);
              v11 = v49;
              break;
            }
          }
        }
        if (v53 - v15 <= 1)
        {
          v43 = __cxa_allocate_exception(8uLL);
          *v43 = v15;
          __cxa_throw(v43, MEMORY[0x1E0DE4E60], 0);
        }
        v23 = *v15;
        v24 = v15 + 2;
        v25 = v15[1] | ((v23 & 0x7F) << 8);
        v50 = v25;
        if (v25)
          break;
LABEL_47:
        kdu_params::set(this, "Mstage_collections", v11, 0, (int *)v51);
        kdu_params::set(this, "Mstage_collections", v11, 1, (int *)v50);
        if (v53 - v24 <= 2)
        {
          v44 = __cxa_allocate_exception(8uLL);
          *v44 = v24;
          __cxa_throw(v44, MEMORY[0x1E0DE4E60], 0);
        }
        v32 = *v24;
        v33 = (int *)v24[1];
        v9 = v24 + 3;
        v34 = (int *)v24[2];
        if (v52 == 3)
        {
          if (v53 - v9 <= 3)
          {
            v45 = __cxa_allocate_exception(8uLL);
            *v45 = v9;
            __cxa_throw(v45, MEMORY[0x1E0DE4E60], 0);
          }
          v9 = v24 + 7;
          v35 = (int *)bswap32(*(_DWORD *)(v24 + 3));
          v36 = 63;
        }
        else
        {
          v35 = 0;
          v36 = 1;
        }
        v37 = (int *)(v36 & v32);
        if (!v51
          || !v50
          || (v52 != 3 ? (v38 = v52 > 1) : (v38 = 0), v38 || v37 > 0x20 || v51 != v50 && v52 != 1))
        {
          *(_QWORD *)&v58 = 0;
          *(_OWORD *)v56 = 0u;
          v57 = 0u;
          kdu_error::kdu_error((kdu_error *)v56, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v56 + 16))(v56, "Malformed MCC marker segment encountered.  Invalid component collection dimensions, transform type or number of DWT levels.");
          kdu_error::~kdu_error((kdu_error *)v56);
        }
        kdu_params::set(this, "Mstage_xforms", v11, 0, (int *)v52);
        kdu_params::set(this, "Mstage_xforms", v11, 1, v34);
        kdu_params::set(this, "Mstage_xforms", v11, 2, v33);
        kdu_params::set(this, "Mstage_xforms", v11, 3, v37);
        kdu_params::set(this, "Mstage_xforms", v11++, 4, v35);
        if (v11 == v48)
          goto LABEL_63;
      }
      v26 = (char)v23;
      v27 = (v23 >> 7) + 1;
      v28 = 0xFFFFFFFFLL;
      v29 = 0xFFFFFFFFLL;
      while (1)
      {
        if (v53 - v24 < v27)
        {
          v40 = __cxa_allocate_exception(8uLL);
          *v40 = v24;
          __cxa_throw(v40, MEMORY[0x1E0DE4E60], 0);
        }
        v30 = (int *)v28;
        v28 = *v24;
        if (v26 < 0)
        {
          v28 = v24[1] | ((_DWORD)v28 << 8);
          if ((_DWORD)v27 == 2)
          {
            v24 += 2;
            if ((v30 & 0x80000000) != 0)
              goto LABEL_44;
          }
          else
          {
            v31 = v24[2];
            v24 += 3;
            v28 = v31 | ((_DWORD)v28 << 8);
            if ((v30 & 0x80000000) != 0)
              goto LABEL_44;
          }
        }
        else
        {
          ++v24;
          if ((v30 & 0x80000000) != 0)
            goto LABEL_44;
        }
        if ((_DWORD)v28 != (_DWORD)v30 + 1)
        {
          kdu_params::set(this, "Mstage_outputs", v12, 0, (int *)v29);
          kdu_params::set(this, "Mstage_outputs", v12++, 1, v30);
LABEL_44:
          v29 = v28;
        }
        if (!--v25)
        {
          kdu_params::set(this, "Mstage_outputs", v12, 0, (int *)v29);
          v11 = v49;
          kdu_params::set(this, "Mstage_outputs", v12++, 1, (int *)v28);
          goto LABEL_47;
        }
      }
    }
LABEL_63:
    if (v9 != v53)
    {
      v55 = 0;
      memset(v54, 0, sizeof(v54));
      kdu_error::kdu_error((kdu_error *)v54, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v54[0] + 16))(v54, "Malformed MCC marker segment encountered. The final ");
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      *(_OWORD *)v56 = 0u;
      if (BYTE8(v54[0]))
        sprintf(v56, "%x");
      else
        sprintf(v56, "%d");
      (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v54[0] + 16))(v54, v56);
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v54[0] + 16))(v54, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v54);
    }
    return 1;
  }
  return result;
}

void sub_187F36BF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F36BFC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,__int128 a21,__int128 a22,uint64_t a23)
{
  _Unwind_Exception *v23;

  _Unwind_Resume(v23);
}

void sub_187F36C24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F36C44(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,__int128 a21,__int128 a22,uint64_t a23)
{
  sub_187F36C90(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21,
    a22,
    a23);
}

void sub_187F36C60(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,__int128 a21,__int128 a22,uint64_t a23)
{
  sub_187F36C90((int)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21,
    a22,
    a23);
}

void sub_187F36C74(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,__int128 a21,__int128 a22,uint64_t a23)
{
  sub_187F36C90(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21,
    a22,
    a23);
}

void sub_187F36C84(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,__int128 a21,__int128 a22,uint64_t a23)
{
  sub_187F36C90(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21,
    a22,
    a23);
}

void sub_187F36C90(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,__int128 a21,__int128 a22,uint64_t a23)
{
  void *v23;
  int v24;

  if (v24 == 1)
  {
    __cxa_begin_catch(v23);
    a23 = 0;
    a21 = 0u;
    a22 = 0u;
    kdu_error::kdu_error((kdu_error *)&a21, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(a21 + 16))(&a21, "Malformed MCC marker segment encountered.  Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a21);
  }
  JUMPOUT(0x187F36C18);
}

void sub_187F36CDC()
{
  __cxa_end_catch();
  JUMPOUT(0x187F36A14);
}

void sub_187F36CE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F36CF0()
{
  __cxa_end_catch();
  JUMPOUT(0x187F36C18);
}

void sub_187F36D00(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x187F36C18);
}

uint64_t mcc_params::write_marker_segment(mcc_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v4;
  int v8;
  int v9;
  int v10;
  int v12;
  int v13;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  char v23;
  int v24;
  int v25;
  int v26;
  char v27;
  int v28;
  char v29;
  int v30;
  int v31;
  int v32;
  char v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  __int16 v39;
  unsigned int v40;
  unsigned __int8 v41[8];
  unsigned __int8 v42[8];
  int v43;
  int v44;
  int v45;
  int v46;
  int v47[4];
  __int128 v48;
  uint64_t v49;
  int v50;
  int v51[2];

  v4 = 0;
  if (!a4 && *((int *)this + 6) <= 255)
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
      return 0;
    *(_QWORD *)v51 = 0;
    v8 = 1;
    if (kdu_params::get(this, "Mstage_inputs", 0, 0, &v51[1], 0, 0, 1))
    {
      v9 = 0;
      v10 = 0;
      do
      {
        if (!kdu_params::get(this, "Mstage_inputs", v9, 1, v51, 0, 0, 1))
          break;
        v10 = v10 + v51[0] - v51[1] + 1;
        if (v51[0] > 255 || v51[1] > 255)
          v8 = 2;
        ++v9;
      }
      while ((kdu_params::get(this, "Mstage_inputs", v9, 0, &v51[1], 0, 0, 1) & 1) != 0);
    }
    else
    {
      v10 = 0;
    }
    if (kdu_params::get(this, "Mstage_outputs", 0, 0, &v51[1], 0, 0, 1))
    {
      v12 = 0;
      v13 = 0;
      do
      {
        if (!kdu_params::get(this, "Mstage_outputs", v12, 1, v51, 0, 0, 1))
          break;
        v13 = v13 + v51[0] - v51[1] + 1;
        if (v51[0] > 255 || v51[1] > 255)
          v8 = 2;
        ++v12;
      }
      while ((kdu_params::get(this, "Mstage_outputs", v12, 0, &v51[1], 0, 0, 1) & 1) != 0);
    }
    else
    {
      v13 = 0;
    }
    v4 = (v8 * (v13 + v10) + 11);
    v50 = 0;
    v15 = 0;
    if (kdu_params::get(this, "Mstage_xforms", 0, 0, &v50, 0, 0, 1))
    {
      do
      {
        if (v50 == 3)
          v16 = 12;
        else
          v16 = 8;
        v4 = (v16 + v4);
        ++v15;
      }
      while ((kdu_params::get(this, "Mstage_xforms", v15, 0, &v50, 0, 0, 1) & 1) != 0);
    }
    if ((int)v4 >= 65538)
    {
      v49 = 0;
      *(_OWORD *)v47 = 0u;
      v48 = 0u;
      kdu_error::kdu_error((kdu_error *)v47, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(_QWORD *)v47 + 16))(v47, "Unable to write MCC (Multi-component transform Component Collection) marker segment, since the amount of information is too large to fit within a single marker segment.  The codestream syntax for this Part-2 marker segment allows the information to be split across multiple marker segments, but this feature is not yet implemented in Kakadu -- it is a rare application indeed that should need this.");
      kdu_error::~kdu_error((kdu_error *)v47);
    }
    if (v15)
    {
      if (a2)
      {
        kdu_output::put(a2, 255);
        kdu_output::put(a2, 117);
        v37 = v4;
        kdu_output::put(a2, (unsigned __int16)(v4 - 2) >> 8);
        kdu_output::put(a2, v4 - 2);
        kdu_output::put(a2, 0);
        kdu_output::put(a2, 0);
        v17 = kdu_output::put(a2, *((_BYTE *)this + 24));
        kdu_output::put(a2, 0);
        kdu_output::put(a2, 0);
        kdu_output::put(a2, SBYTE1(v15));
        kdu_output::put(a2, v15);
        v18 = 0;
        v19 = 0;
        v20 = 0;
        v46 = -1;
        v47[0] = 0;
        v21 = v17 + 10;
        v44 = -1;
        v45 = 0;
        v43 = 0;
        v39 = ((_WORD)v8 << 15) + 0x8000;
        v40 = 0;
        *(_QWORD *)v41 = 0;
        *(_QWORD *)v42 = 0;
        v38 = v15;
        do
        {
          kdu_params::get(this, "Mstage_collections", v20, 0, &v43, 1, 1, 1);
          kdu_params::get(this, "Mstage_collections", v20, 1, (int *)&v42[4], 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 0, &v50, 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 1, (int *)v42, 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 2, (int *)&v41[4], 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 3, (int *)v41, 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 4, (int *)&v40, 1, 1, 1);
          v22 = kdu_output::put(a2, v50);
          v23 = v43;
          kdu_output::put(a2, (unsigned __int16)(v43 + v39) >> 8);
          kdu_output::put(a2, v23);
          v24 = v21 + v22 + 2;
          if (v43 >= 1)
          {
            v25 = 0;
            v26 = v47[0];
            do
            {
              if (v26 > v46)
              {
                kdu_params::get(this, "Mstage_inputs", v19, 0, v47, 1, 1, 1);
                kdu_params::get(this, "Mstage_inputs", v19++, 1, &v46, 1, 1, 1);
              }
              v27 = v47[0];
              if (v8 == 1)
              {
                v28 = kdu_output::put(a2, v47[0]);
              }
              else
              {
                kdu_output::put(a2, SBYTE1(v47[0]));
                kdu_output::put(a2, v27);
                v28 = 2;
              }
              v24 += v28;
              v26 = ++v47[0];
              ++v25;
            }
            while (v25 < v43);
          }
          v29 = v42[4];
          kdu_output::put(a2, (unsigned __int16)(*(_WORD *)&v42[4] + v39) >> 8);
          kdu_output::put(a2, v29);
          v30 = v24 + 2;
          if (*(int *)&v42[4] >= 1)
          {
            v31 = 0;
            v32 = v45;
            do
            {
              if (v32 > v44)
              {
                kdu_params::get(this, "Mstage_outputs", v18, 0, &v45, 1, 1, 1);
                kdu_params::get(this, "Mstage_outputs", v18++, 1, &v44, 1, 1, 1);
              }
              v33 = v45;
              if (v8 == 1)
              {
                v34 = kdu_output::put(a2, v45);
              }
              else
              {
                kdu_output::put(a2, SBYTE1(v45));
                kdu_output::put(a2, v33);
                v34 = 2;
              }
              v30 += v34;
              v32 = ++v45;
              ++v31;
            }
            while (v31 < *(int *)&v42[4]);
          }
          v35 = kdu_output::put(a2, v41[0]) + v30;
          v36 = kdu_output::put(a2, v41[4]);
          v21 = v35 + v36 + kdu_output::put(a2, v42[0]);
          if (v50 == 3)
            v21 += kdu_output::put(a2, v40);
          ++v20;
        }
        while (v20 != v38);
        v4 = v37;
        if (v37 != v21)
          mcc_params::write_marker_segment();
      }
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

void sub_187F37418(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F37424()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void mco_params::mco_params(mco_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_BYTE *)this + 38) = 1;
  *(_DWORD *)((char *)this + 39) = 0;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_WORD *)this + 18) = 1;
  *((_BYTE *)this + 104) = 0;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BABB00;
  *((_QWORD *)this + 1) = "MCO";
}

void sub_187F374E4(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t mco_params::copy_with_xforms(mco_params *this, kdu_params *a2, int *a3)
{
  uint64_t result;
  kdu_params *v7;
  kdu_params *v8;
  int v9;
  uint64_t v10;
  kdu_params *v11;
  uint64_t i;
  kdu_params *v13;
  kdu_params *v14;
  int *v15;
  int *v16;
  int j;
  int v18[8];
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;

  v23 = 0;
  v22 = 0;
  result = kdu_params::get(a2, "Mnum_stages", 0, 0, &v23, 1, 1, 1);
  if ((_DWORD)result)
  {
    v20 = 1;
    v21 = 1;
    v7 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
    v8 = (kdu_params *)kdu_params::access_cluster(a2, "SIZ");
    if (v7)
      kdu_params::get(v7, "Scomponents", 0, 0, &v20, 1, 1, 1);
    if (v8)
      kdu_params::get(v8, "Scomponents", 0, 0, &v21, 1, 1, 1);
    if ((int)a3 <= 0 && v20 == v21)
    {
      v9 = 0;
    }
    else
    {
      v10 = kdu_params::access_relation(this, *((_DWORD *)this + 4), -1, 0, 0);
      if (!v10)
        mco_params::copy_with_xforms();
      v11 = (kdu_params *)v10;
      for (i = 1; ; i = (i + 1))
      {
        v18[0] = 0;
        v13 = v11;
        while (*((_DWORD *)v13 + 6) != (_DWORD)i)
        {
          v13 = (kdu_params *)*((_QWORD *)v13 + 11);
          if (!v13)
            goto LABEL_17;
        }
        if (!kdu_params::get(v13, "Mstage_inputs", 0, 0, v18, 1, 1, 1))
          break;
      }
LABEL_17:
      if (i >= 0x100)
      {
        v19 = 0;
        memset(v18, 0, sizeof(v18));
        kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v18 + 16))(v18, "Unable to modify the existing multi-component transform to work with a reduced number of codestream image components during transcoding.  Cannot create a taylored null transform to interface the components, since all allowed MCC marker segment instance indices have been used up already.");
        kdu_error::~kdu_error((kdu_error *)v18);
      }
      kdu_params::set(this, "Mstages", 0, 0, (int *)i);
      v14 = (kdu_params *)kdu_params::access_relation(v11, *((_DWORD *)this + 4), -1, i, 0);
      kdu_params::set(v14, "Mstage_inputs", 0, 0, 0);
      kdu_params::set(v14, "Mstage_inputs", 0, 1, (int *)(v20 - 1));
      kdu_params::set(v14, "Mstage_outputs", 0, 0, a3);
      kdu_params::set(v14, "Mstage_outputs", 0, 1, (int *)((_DWORD)a3 - 1 + v20));
      if ((int)a3 >= 1)
      {
        kdu_params::set(v14, "Mstage_outputs", 1, 0, 0);
        kdu_params::set(v14, "Mstage_outputs", 1, 1, (int *)((_DWORD)a3 - 1));
      }
      v15 = (int *)v20;
      v16 = (int *)(v20 + (_DWORD)a3);
      if ((int)v16 < v21)
      {
        kdu_params::set(v14, "Mstage_outputs", 2, 0, v16);
        kdu_params::set(v14, "Mstage_outputs", 2, 1, (int *)(v21 - 1));
        v15 = (int *)v20;
      }
      kdu_params::set(v14, "Mstage_collections", 0, 0, v15);
      v9 = 1;
      kdu_params::set(v14, "Mstage_collections", 0, 1, (int *)v21);
      kdu_params::set(v14, "Mstage_xforms", 0, 0, (int *)1);
      kdu_params::set(v14, "Mstage_xforms", 0, 1, 0);
      kdu_params::set(v14, "Mstage_xforms", 0, 2, 0);
      kdu_params::set(v14, "Mstage_xforms", 0, 3, 0);
      kdu_params::set(v14, "Mstage_xforms", 0, 4, 0);
    }
    result = (uint64_t)kdu_params::set(this, "Mnum_stages", 0, 0, (int *)(v23 + v9));
    if (v23 >= 1)
    {
      for (j = 0; j < v23; ++j)
      {
        result = kdu_params::get(a2, "Mstages", j, 0, &v22, 1, 1, 1);
        if (!(_DWORD)result)
          break;
        result = (uint64_t)kdu_params::set(this, "Mstages", v9 + j, 0, (int *)v22);
      }
    }
  }
  return result;
}

void sub_187F37950(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F3795C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL mco_params::check_marker_segment(mco_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  *a5 = -1;
  return a2 == 65399;
}

uint64_t mco_params::finalize(uint64_t this, char a2)
{
  kdu_params *v2;
  kdu_params *v3;
  int v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  int v8;
  int v9;

  if ((a2 & 1) == 0)
  {
    v2 = (kdu_params *)this;
    v9 = 0;
    v3 = (kdu_params *)kdu_params::access_cluster((kdu_params *)this, "SIZ");
    if (v3)
      kdu_params::get(v3, "Mcomponents", 0, 0, &v9, 1, 1, 1);
    v8 = 0;
    this = kdu_params::get(v2, "Mnum_stages", 0, 0, &v8, 1, 1, 1);
    if ((this & 1) != 0)
    {
      if (!v9)
      {
        v7 = 0;
        v5 = 0u;
        v6 = 0u;
        kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v5);
      }
    }
    else if (v9 >= 1)
    {
      v8 = 0;
      this = (uint64_t)kdu_params::set(v2, "Mnum_stages", 0, 0, 0);
    }
    v4 = 0;
    if (v8 >= 1)
    {
      this = kdu_params::get(v2, "Mstages", v8 - 1, 0, &v4, 1, 1, 1);
      if ((this & 1) == 0)
      {
        v7 = 0;
        v5 = 0u;
        v6 = 0u;
        kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v5);
      }
    }
  }
  return this;
}

void sub_187F37AF4(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F37B00(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

BOOL mco_params::read_marker_segment(mco_params *this, unsigned __int16 a2, int a3, unsigned __int8 *a4, int a5)
{
  int v9;
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v14;
  _QWORD *exception;
  _OWORD v16[2];
  uint64_t v17;
  char v18[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a5)
  {
    if (a3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = a4;
      __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
    }
    v9 = *a4;
    kdu_params::set(this, "Mnum_stages", 0, 0, (int *)*a4);
    v10 = a4 + 1;
    if (v9)
    {
      v11 = 0;
      v12 = a3 - 1;
      do
      {
        if (v12 <= 0)
        {
          v14 = __cxa_allocate_exception(8uLL);
          *v14 = &v10[v11];
          __cxa_throw(v14, MEMORY[0x1E0DE4E60], 0);
        }
        kdu_params::set(this, "Mstages", v11, 0, (int *)v10[v11]);
        ++v11;
        --v12;
      }
      while (v9 != (_DWORD)v11);
      v10 += v11;
    }
    if (v10 != &a4[a3])
    {
      v17 = 0;
      memset(v16, 0, sizeof(v16));
      kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, "Malformed MCO marker segment encountered. The final ");
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      *(_OWORD *)v18 = 0u;
      if (BYTE8(v16[0]))
        sprintf(v18, "%x");
      else
        sprintf(v18, "%d");
      (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v16[0] + 16))(v16, v18);
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v16);
    }
  }
  return a5 == 0;
}

void sub_187F37D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, __int128 a12, uint64_t a13)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(a11 + 16))(&a11, "Malformed MCO marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mco_params::write_marker_segment(mco_params *this, kdu_output *a2, kdu_params *a3)
{
  uint64_t v4;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16[8];
  uint64_t v17;
  unsigned __int8 v18[8];

  if (*((_DWORD *)this + 6) || (*((_DWORD *)this + 5) & 0x80000000) == 0)
    return 0;
  *(_QWORD *)v18 = 0;
  v4 = 0;
  if (!kdu_params::get(this, "Mnum_stages", 0, 0, (int *)v18, 0, 1, 1))
    return v4;
  v8 = *(_DWORD *)v18;
  if (*(int *)v18 >= 256)
  {
    v17 = 0;
    memset(v16, 0, sizeof(v16));
    kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v16);
  }
  if (a3)
  {
    v16[0] = 0;
    v9 = kdu_params::get(a3, "Mnum_stages", 0, 0, v16, 1, 1, 1);
    v10 = *(_DWORD *)v18;
    if (v9 && v16[0] == v8)
    {
      if (*(int *)v18 < 1)
      {
        v11 = 0;
      }
      else
      {
        v11 = 0;
        do
        {
          if ((kdu_params::get(this, "Mstages", v11, 0, (int *)&v18[4], 1, 1, 1) & 1) == 0)
            mco_params::write_marker_segment();
          v12 = *(_DWORD *)&v18[4];
          v16[0] = 0;
          v13 = kdu_params::get(a3, "Mstages", v11, 0, v16, 1, 1, 1);
          v10 = *(_DWORD *)v18;
          if (!v13)
            break;
          if (v16[0] != v12)
            break;
          ++v11;
        }
        while (v11 < *(int *)v18);
      }
      v8 = v10;
      if (v11 == v10)
        return 0;
    }
    else
    {
      v8 = *(_DWORD *)v18;
    }
  }
  v4 = (v8 + 5);
  if (a2)
  {
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 119);
    kdu_output::put(a2, (unsigned __int16)(v8 + 3) >> 8);
    kdu_output::put(a2, v8 + 3);
    v14 = kdu_output::put(a2, v18[0]) + 4;
    if (*(int *)v18 >= 1)
    {
      v15 = 0;
      do
      {
        kdu_params::get(this, "Mstages", v15, 0, (int *)&v18[4], 1, 1, 1);
        v14 += kdu_output::put(a2, v18[4]);
        ++v15;
      }
      while (v15 < *(int *)v18);
    }
    if ((_DWORD)v4 != v14)
      mco_params::write_marker_segment();
  }
  return v4;
}

void sub_187F3802C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F38038()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void atk_params::atk_params(atk_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 1;
  *((_BYTE *)this + 42) = 1;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BAB710;
  *((_QWORD *)this + 1) = "ATK";
  kdu_params::define_attribute(this, "Ksteps", "Array with one entry for each lifting step.  The first entry corrsponds to lifting step s=0, which updates odd indexed samples, based on even indexed samples; the second entry corresponds to lifting step s=1, which updates even inde"
    "xed samples, based on odd indexed samples; and so forth.  The first field in each record holds the length, Ls, of th"
    "e coefficient array Cs[n], for the relevant step s.  The second field is the location of the first entry, Ns, where "
    "Cs[n] is defined for n=Ns to Ns+Ls-1.  The value of Ns is typically negative, but need not be.  For symmetric kernel"
    "s, Ls must be even and Ns must satisfy Ns=-floor((Ls+p-1)/2), where p is the lifting step parity (0 if s is even, 1 "
    "ls, however, the third field holds the downshift value, Ds, while the fourth field holds the rounding offset, Rs, to"
    " be added immediately prior to downshifting.",
    "IIII",
    1);
}

void sub_187F38168(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t atk_params::copy_with_xforms(atk_params *this, kdu_params *a2, int a3, int a4, BOOL a5, int a6, int a7)
{
  uint64_t result;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19[2];
  int v20[2];
  _OWORD v21[2];
  uint64_t v22;
  int v23;
  BOOL v24[2];

  *(_WORD *)v24 = 0;
  result = kdu_params::get(a2, "Kreversible", 0, 0, &v24[1], 1, 1, 1);
  if ((_DWORD)result)
  {
    if ((kdu_params::get(a2, "Ksymmetric", 0, 0, v24, 1, 1, 1) & 1) != 0
      || ((*(void (**)(kdu_params *, _QWORD))(*(_QWORD *)a2 + 72))(a2, 0),
          result = kdu_params::get(a2, "Ksymmetric", 0, 0, v24, 1, 1, 1),
          (_DWORD)result))
    {
      kdu_params::set((uint64_t)this, "Kreversible", 0, 0, v24[1]);
      kdu_params::set((uint64_t)this, "Ksymmetric", 0, 0, v24[0]);
      v23 = 0;
      if (kdu_params::get(a2, "Kextension", 0, 0, &v23, 1, 1, 1))
        kdu_params::set(this, "Kextension", 0, 0, (int *)v23);
      if (v24[0])
        v12 = 0;
      else
        v12 = a6 | a7;
      if (a6 != a7 && v12)
      {
        v22 = 0;
        memset(v21, 0, sizeof(v21));
        kdu_error::kdu_error((kdu_error *)v21, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v21[0] + 16))(v21, "Cannot transpose ATK marker segment information to a new codestream which has flippped geometry unless the transform filters are whole-sample symmetric, or flipping is to be applied in both the vertical and horizontal directions.  The reason for this is that the same transform kernels must be used in both directions, only one of which requires reversal of the lifting coefficients.");
        kdu_error::~kdu_error((kdu_error *)v21);
      }
      LODWORD(v21[0]) = 0;
      *(_QWORD *)v19 = 0;
      *(_QWORD *)v20 = 0;
      result = kdu_params::get(a2, "Ksteps", 0, 0, &v20[1], 0, 0, 1);
      if ((_DWORD)result)
      {
        v13 = 0;
        v14 = 0;
        do
        {
          result = kdu_params::get(a2, "Ksteps", v14, 1, v20, 0, 0, 1);
          if (!(_DWORD)result)
            break;
          result = kdu_params::get(a2, "Ksteps", v14, 2, &v19[1], 0, 0, 1);
          if (!(_DWORD)result)
            break;
          result = kdu_params::get(a2, "Ksteps", v14, 3, v19, 0, 0, 1);
          if (!(_DWORD)result)
            break;
          if (v12)
            v20[0] = (~(2 * v14) & 2) - (v20[0] + v20[1]);
          kdu_params::set(this, "Ksteps", v14, 0, (int *)v20[1]);
          kdu_params::set(this, "Ksteps", v14, 1, (int *)v20[0]);
          kdu_params::set(this, "Ksteps", v14, 2, (int *)v19[1]);
          kdu_params::set(this, "Ksteps", v14, 3, (int *)v19[0]);
          v15 = v20[1];
          if (v20[1] >= 1)
          {
            v16 = 0;
            v17 = -1;
            do
            {
              kdu_params::get(a2, "Kcoeffs", v13 + v16, 0, (float *)v21, 1, 1, 1);
              if (v12)
                v18 = v13 + v17 + v20[1];
              else
                v18 = v13 + v16;
              kdu_params::set((uint64_t)this, "Kcoeffs", v18, 0, *(float *)v21);
              ++v16;
              v15 = v20[1];
              --v17;
            }
            while (v16 < v20[1]);
          }
          ++v14;
          v13 += v15;
          result = kdu_params::get(a2, "Ksteps", v14, 0, &v20[1], 0, 0, 1);
        }
        while ((result & 1) != 0);
      }
    }
  }
  return result;
}

void sub_187F38534(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F38540()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t atk_params::finalize(atk_params *this)
{
  uint64_t result;
  BOOL v3;
  int v4;
  int v5;
  double v6;
  double v7;
  double v8;
  int v9;
  int v10;
  double v11;
  int v12;
  float v13;
  int v14;
  double v15;
  int v16;
  char v17;
  BOOL v18;
  int v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  BOOL v23;
  float v24;
  int v25[2];
  int v26[2];

  *(_QWORD *)v25 = 0;
  *(_QWORD *)v26 = 0;
  v24 = 0.0;
  v23 = 0;
  if ((kdu_params::get(this, "Kreversible", 0, 0, &v23, 1, 1, 1) & 1) != 0)
  {
    v3 = 1;
    if (kdu_params::get(this, "Ksteps", 0, 0, &v26[1], 1, 1, 1))
    {
      v4 = 0;
      v5 = 0;
      v6 = 1.0;
      v7 = 1.0;
      do
      {
        v8 = v7;
        if (!kdu_params::get(this, "Ksteps", v5, 1, v26, 1, 1, 1)
          || !kdu_params::get(this, "Ksteps", v5, 2, &v25[1], 1, 1, 1)
          || (kdu_params::get(this, "Ksteps", v5, 3, v25, 1, 1, 1) & 1) == 0)
        {
          v22 = 0;
          v20 = 0u;
          v21 = 0u;
          kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v20);
        }
        if (v25[1] >= 0x19u)
        {
          v22 = 0;
          v20 = 0u;
          v21 = 0u;
          kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v20);
        }
        if (!v23 && (v25[1] > 0 || v25[0] >= 1))
        {
          v22 = 0;
          v20 = 0u;
          v21 = 0u;
          kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v20);
        }
        v9 = v26[1];
        if ((v26[1] & 1) != 0 || v26[0] + (((v5 & 1) + v26[1] - 1) >> 1))
          v3 = 0;
        if (v26[1] < 1)
        {
          v11 = 0.0;
        }
        else
        {
          v10 = 0;
          v11 = 0.0;
          v12 = -1;
          do
          {
            if ((kdu_params::get(this, "Kcoeffs", v4 + v10, 0, &v24, 1, 1, 1) & 1) == 0)
            {
              v22 = 0;
              v20 = 0u;
              v21 = 0u;
              kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)&v20);
            }
            v13 = v24;
            v9 = v26[1];
            if (v3)
            {
              if (v10 >= v26[1] >> 1)
              {
                v3 = 1;
              }
              else
              {
                LODWORD(v20) = 0;
                v3 = kdu_params::get(this, "Kcoeffs", v4 + v12 + v26[1], 0, (float *)&v20, 1, 1, 1)
                  && v24 == *(float *)&v20;
                v9 = v26[1];
              }
            }
            else
            {
              v3 = 0;
            }
            v11 = v11 + v13;
            ++v10;
            --v12;
          }
          while (v10 < v9);
        }
        v7 = v6 + v11 * v8;
        ++v5;
        v4 += v9;
        v6 = v8;
      }
      while ((kdu_params::get(this, "Ksteps", v5, 0, &v26[1], 1, 1, 1) & 1) != 0);
      v14 = v5 & 1;
    }
    else
    {
      v14 = 0;
      v4 = 0;
      v7 = 1.0;
      v8 = 1.0;
    }
    if (kdu_params::get(this, "Kcoeffs", v4, 0, &v24, 1, 1, 1))
    {
      v22 = 0;
      v20 = 0u;
      v21 = 0u;
      kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v20);
    }
    if (v23)
    {
      v15 = v14 ? v8 : v7;
      if (v15 > 1.001 || v15 < 0.999)
      {
        v22 = 0;
        v20 = 0u;
        v21 = 0u;
        kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v20);
      }
    }
    v19 = 0;
    if ((kdu_params::get(this, "Kextension", 0, 0, &v19, 1, 1, 1) & 1) == 0)
    {
      v19 = v3;
      kdu_params::set(this, "Kextension", 0, 0, (int *)v3);
    }
    v16 = v19 == 1 && v3;
    v18 = 0;
    result = kdu_params::get(this, "Ksymmetric", 0, 0, &v18, 0, 1, 1);
    if ((result & 1) != 0)
    {
      if (v18)
        v17 = v16;
      else
        v17 = 1;
      if ((v17 & 1) == 0)
      {
        v22 = 0;
        v20 = 0u;
        v21 = 0u;
        kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v20);
      }
    }
    else
    {
      return kdu_params::set((uint64_t)this, "Ksymmetric", 0, 0, v16);
    }
  }
  else if ((kdu_params::get(this, "Ksteps", 0, 0, &v26[1], 1, 1, 1) & 1) != 0
         || (result = kdu_params::get(this, "Kcoeffs", 0, 0, &v24, 1, 1, 1), (_DWORD)result))
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  return result;
}

void sub_187F38B60(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F38B6C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

BOOL atk_params::check_marker_segment(atk_params *this, int a2, int a3, unsigned __int8 *a4, unsigned int *a5)
{
  unsigned int v6;
  _BOOL8 result;

  if (a2 != 65401 || a3 < 2)
    return 0;
  v6 = a4[1];
  result = v6 > 1;
  *a5 = v6;
  return result;
}

uint64_t atk_params::read_marker_segment(atk_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t result;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  _BOOL4 v18;
  int v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  unsigned __int8 *v23;
  int *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned __int8 *v30;
  unint64_t v31;
  unsigned int v32;
  int v33;
  float v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t i;
  char v39;
  float v40;
  uint64_t j;
  char v42;
  int v43;
  int v44;
  double v45;
  int v46;
  int v47;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *exception;
  int v55;
  int v56;
  unsigned int v57;
  int v58;
  unsigned __int8 *v59;
  uint64_t v60;
  int v61;
  unsigned __int8 *v62;
  _OWORD v63[2];
  uint64_t v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (a5)
    return 0;
  result = 0;
  if (a2 == 65401 && a3 >= 2)
  {
    if (*((_DWORD *)this + 6) != a4[1])
      return 0;
    v9 = *a4;
    if ((v9 & 8) != 0 && ((v9 >> 6) & 1) == 0)
    {
      *(_QWORD *)&v67 = 0;
      v65 = 0u;
      v66 = 0u;
      kdu_error::kdu_error((kdu_error *)&v65, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v65 + 16))(&v65, "Malformed ATK marker segment encountered.  Transform kernels identified as whole-sample symmetric must also use the symmetric boundary extension method.");
      kdu_error::~kdu_error((kdu_error *)&v65);
    }
    v10 = v9 & 3;
    if ((v9 & 0x10) != 0 && v10 >= 2)
    {
      *(_QWORD *)&v67 = 0;
      v65 = 0u;
      v66 = 0u;
      kdu_error::kdu_error((kdu_error *)&v65, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v65 + 16))(&v65, "Cannot process ATK marker segment describing a reversible transform kernel with floating-point coefficient values.");
      kdu_error::~kdu_error((kdu_error *)&v65);
    }
    kdu_params::set((uint64_t)this, "Kreversible", 0, 0, (v9 >> 4) & 1);
    kdu_params::set((uint64_t)this, "Ksymmetric", 0, 0, (v9 & 8) != 0);
    kdu_params::set(this, "Kextension", 0, 0, (int *)((v9 >> 6) & 1));
    v11 = 1 << v10;
    if (((v9 >> 4) & 1) != 0)
      v12 = 0;
    else
      v12 = v11;
    v13 = &a4[v12 + 2];
    v62 = &a4[a3];
    if (a3 - (v12 + 2) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = v13;
      __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
    }
    v16 = *v13;
    v15 = v13 + 1;
    v14 = v16;
    v17 = v16 - 1;
    v18 = ((v9 >> 5) & 1) == 0;
    v19 = ((v16 - 1) & 1) != v18;
    if (((v16 - 1) & 1) == v18)
      v14 = v17;
    v56 = v19;
    if (v14 >= v19)
    {
      v55 = v9 & 3;
      v61 = 0;
      v60 = (v9 & 8) >> 3;
      v20 = v14;
      v21 = v15;
      do
      {
        if ((v9 & 8) == 0)
        {
          if (v62 - v21 <= 0)
          {
            v51 = __cxa_allocate_exception(8uLL);
            *v51 = v21;
            __cxa_throw(v51, MEMORY[0x1E0DE4E60], 0);
          }
          v22 = *v21++;
          HIDWORD(v60) = v22 - ((2 * v22) & 0x100);
        }
        if ((v9 & 0x10) != 0)
        {
          if (v62 - v21 <= 0)
          {
            v52 = __cxa_allocate_exception(8uLL);
            *v52 = v21;
            __cxa_throw(v52, MEMORY[0x1E0DE4E60], 0);
          }
          v23 = v21 + 1;
          v24 = (int *)*v21;
          if (v55 == 3)
            __assert_rtn("kdu_read", "kdu_utils.h", 74, "nbytes <= 4");
          if (v62 - v23 < v11)
          {
            v53 = __cxa_allocate_exception(8uLL);
            *v53 = v23;
            __cxa_throw(v53, MEMORY[0x1E0DE4E60], 0);
          }
          v25 = v21[1];
          if ((v9 & 3) != 0)
          {
            v26 = v21[2] | (v25 << 8);
            if (v55 == 1)
            {
              v21 += 3;
              v27 = v26 - ((v25 << 9) & 0x10000);
            }
            else
            {
              v28 = (v21[3] << 8) | (v26 << 16);
              v29 = v21[4];
              v21 += 5;
              v27 = v28 | v29;
            }
            v57 = v27;
          }
          else
          {
            v21 += 2;
            v57 = v25 - ((2 * v25) & 0x100);
          }
        }
        else
        {
          v24 = 0;
          v57 = 0;
        }
        if (v62 - v21 <= 0)
        {
          v50 = __cxa_allocate_exception(8uLL);
          *v50 = v21;
          __cxa_throw(v50, MEMORY[0x1E0DE4E60], 0);
        }
        v30 = v21 + 1;
        v31 = *v21;
        v59 = v30;
        if ((v9 & 8) != 0)
        {
          v31 = (2 * v31);
          HIDWORD(v60) = -((int)((v31 & 0xFFFFFFFE | v20 & 1) - 1) >> 1);
        }
        kdu_params::set(this, "Ksteps", v20, 0, (int *)v31);
        kdu_params::set(this, "Ksteps", v20, 1, (int *)HIDWORD(v60));
        kdu_params::set(this, "Ksteps", v20, 2, v24);
        kdu_params::set(this, "Ksteps", v20, 3, (int *)v57);
        v58 = v20;
        v32 = v31 >> v60;
        if (v32)
        {
          v33 = 0;
          v34 = (float)(1 << (char)v24);
          v35 = v32 + v61;
          v15 = v59;
          do
          {
            switch((int)v11)
            {
              case 1:
                if (v62 - v15 <= 0)
                  goto LABEL_78;
                v36 = *v15++;
                v37 = v36 - ((2 * v36) & 0x100);
                goto LABEL_56;
              case 2:
                if (v62 - v15 < 2)
                  goto LABEL_78;
                v43 = *v15;
                v44 = v15[1];
                v15 += 2;
                v37 = (v44 | (v43 << 8)) - ((v43 << 9) & 0x10000);
LABEL_56:
                v40 = (float)v37;
                if ((v9 & 0x10) != 0)
                  v40 = v40 / v34;
                break;
              case 4:
                if (v62 - v15 < 4)
                  goto LABEL_78;
                LODWORD(v65) = 0;
                for (i = 3; i != -1; --i)
                {
                  v39 = *v15++;
                  *((_BYTE *)&v65 + i) = v39;
                }
                if ((v9 & 0x10) != 0)
                  __assert_rtn("read_marker_segment", "params.cpp", 5552, "!reversible");
                v40 = *(float *)&v65;
                break;
              case 8:
                if (v62 - v15 < 8)
                {
LABEL_78:
                  v49 = __cxa_allocate_exception(8uLL);
                  *v49 = v15;
                  __cxa_throw(v49, MEMORY[0x1E0DE4E60], 0);
                }
                *(_QWORD *)&v65 = 0;
                for (j = 7; j != -1; --j)
                {
                  v42 = *v15++;
                  *((_BYTE *)&v65 + j) = v42;
                }
                if ((v9 & 0x10) != 0)
                  __assert_rtn("read_marker_segment", "params.cpp", 5556, "!reversible");
                v40 = *(double *)&v65;
                break;
              default:
                __assert_rtn("read_marker_segment", "params.cpp", 5558, "0");
            }
            v45 = v40;
            kdu_params::set((uint64_t)this, "Kcoeffs", v35 + ~v33, 0, v40);
            if ((v9 & 8) != 0)
              kdu_params::set((uint64_t)this, "Kcoeffs", v33 + v35, 0, v45);
            ++v33;
          }
          while (v33 != v32);
        }
        else
        {
          v15 = v59;
        }
        v61 += v32 << ((v9 & 8) >> 3);
        v14 = v58 - 1;
        v21 = v15;
        v20 = v58 - 1;
      }
      while (v58 > v56);
    }
    else
    {
      v61 = 0;
    }
    if (!v14)
    {
      kdu_params::set(this, "Ksteps", 0, 0, 0);
      kdu_params::set(this, "Ksteps", 0, 1, 0);
      kdu_params::set(this, "Ksteps", 0, 2, 0);
      kdu_params::set(this, "Ksteps", 0, 3, 0);
    }
    if (v15 != v62)
    {
      v64 = 0;
      memset(v63, 0, sizeof(v63));
      kdu_error::kdu_error((kdu_error *)v63, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v63[0] + 16))(v63, "Malformed ATK marker segment encountered. The final ");
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v65 = 0u;
      if (BYTE8(v63[0]))
        sprintf((char *)&v65, "%x");
      else
        sprintf((char *)&v65, "%d");
      (*(void (**)(_OWORD *, __int128 *))(*(_QWORD *)&v63[0] + 16))(v63, &v65);
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v63[0] + 16))(v63, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v63);
    }
    if (v61 >= 2)
    {
      v46 = v61 - 1;
      v47 = 1;
      do
      {
        LODWORD(v65) = 0;
        LODWORD(v63[0]) = 0;
        kdu_params::get(this, "Kcoeffs", v47 - 1, 0, (float *)&v65, 1, 1, 1);
        kdu_params::get(this, "Kcoeffs", v46, 0, (float *)v63, 1, 1, 1);
        kdu_params::set((uint64_t)this, "Kcoeffs", v47 - 1, 0, *(float *)v63);
        kdu_params::set((uint64_t)this, "Kcoeffs", v46--, 0, *(float *)&v65);
      }
      while (v47++ < v46);
    }
    return 1;
  }
  return result;
}

void sub_187F394DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F394E8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,__int128 a24,__int128 a25,uint64_t a26)
{
  _Unwind_Exception *v26;

  _Unwind_Resume(v26);
}

void sub_187F39530()
{
  JUMPOUT(0x187F3954CLL);
}

void sub_187F3959C()
{
  __cxa_end_catch();
  JUMPOUT(0x187F391F0);
}

void sub_187F395A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F395B4()
{
  __cxa_end_catch();
  JUMPOUT(0x187F39528);
}

void sub_187F395C4(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x187F39528);
}

uint64_t atk_params::write_marker_segment(atk_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  int v4;
  uint64_t v5;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  float v21;
  int v22;
  BOOL v23;
  int v24;
  int v25;
  int v26;
  int v27;
  char v28;
  int v29;
  int v30;
  int v31;
  __int16 v32;
  __int16 v33;
  __int16 v34;
  int v35;
  int v36;
  int v37;
  double v38;
  double v39;
  double v40;
  int v41;
  int v42;
  double v43;
  double v44;
  int v45;
  int v46;
  int v47;
  int v48;
  char v49;
  int v50;
  int v51;
  int v52;
  int v53;
  __int16 v54;
  int v55;
  unsigned int v57;
  unsigned int v58;
  unsigned __int8 v59[8];
  unsigned __int8 v60[8];
  _QWORD v61[5];
  int v62;
  BOOL v63[2];

  v4 = *((_DWORD *)this + 6);
  if (v4 < 2)
    return 0;
  v5 = 0;
  if (!a4 && v4 <= 0xFF)
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
      return 0;
    *(_WORD *)v63 = 0;
    v62 = 0;
    if (!kdu_params::get(this, "Kreversible", 0, 0, &v63[1], 1, 1, 1)
      || !kdu_params::get(this, "Ksymmetric", 0, 0, v63, 1, 1, 1)
      || (kdu_params::get(this, "Kextension", 0, 0, &v62, 1, 1, 1) & 1) == 0)
    {
      memset(v61, 0, sizeof(v61));
      kdu_error::kdu_error((kdu_error *)v61, "Kakadu Core Error:\n");
      (*(void (**)(_QWORD *, const char *))(v61[0] + 16))(v61, "Unable to write ATK marker segment yet! Some info missing.");
      kdu_error::~kdu_error((kdu_error *)v61);
    }
    *(_QWORD *)v59 = 0;
    *(_QWORD *)v60 = 0;
    *(float *)&v58 = 0.0;
    if (a3)
    {
      v10 = v63[1];
      LOBYTE(v61[0]) = 0;
      if (kdu_params::get(a3, "Kreversible", 0, 0, (BOOL *)v61, 1, 1, 1))
      {
        if (LOBYTE(v61[0]) == v10)
        {
          v11 = v63[0];
          LOBYTE(v61[0]) = 0;
          if (kdu_params::get(a3, "Ksymmetric", 0, 0, (BOOL *)v61, 1, 1, 1))
          {
            if (LOBYTE(v61[0]) == v11)
            {
              v12 = v62;
              LODWORD(v61[0]) = 0;
              if (kdu_params::get(a3, "Kextension", 0, 0, (int *)v61, 1, 1, 1))
              {
                if (LODWORD(v61[0]) == v12)
                {
                  v5 = 0;
                  if (!kdu_params::get(this, "Ksteps", 0, 0, (int *)&v60[4], 1, 1, 1))
                    return v5;
                  v13 = 0;
                  v14 = 0;
                  while (kdu_params::get(this, "Ksteps", v13, 1, (int *)v60, 1, 1, 1)
                       && kdu_params::get(this, "Ksteps", v13, 2, (int *)&v59[4], 1, 1, 1)
                       && kdu_params::get(this, "Ksteps", v13, 3, (int *)v59, 1, 1, 1))
                  {
                    v15 = *(_DWORD *)&v60[4];
                    LODWORD(v61[0]) = 0;
                    if (!kdu_params::get(a3, "Ksteps", v13, 0, (int *)v61, 1, 1, 1))
                      goto LABEL_44;
                    if (LODWORD(v61[0]) != v15)
                      goto LABEL_44;
                    v16 = *(_DWORD *)v60;
                    LODWORD(v61[0]) = 0;
                    if (!kdu_params::get(a3, "Ksteps", v13, 1, (int *)v61, 1, 1, 1))
                      goto LABEL_44;
                    if (LODWORD(v61[0]) != v16)
                      goto LABEL_44;
                    v17 = *(_DWORD *)&v59[4];
                    LODWORD(v61[0]) = 0;
                    if (!kdu_params::get(a3, "Ksteps", v13, 2, (int *)v61, 1, 1, 1))
                      goto LABEL_44;
                    if (LODWORD(v61[0]) != v17)
                      goto LABEL_44;
                    v18 = *(_DWORD *)v59;
                    LODWORD(v61[0]) = 0;
                    if (!kdu_params::get(a3, "Ksteps", v13, 3, (int *)v61, 1, 1, 1)
                      || LODWORD(v61[0]) != v18)
                    {
                      goto LABEL_44;
                    }
                    v19 = *(_DWORD *)&v60[4];
                    if (*(int *)&v60[4] < 1)
                    {
                      v20 = 0;
                    }
                    else
                    {
                      v20 = 0;
                      do
                      {
                        kdu_params::get(this, "Kcoeffs", v14 + v20, 0, (float *)&v58, 1, 1, 1);
                        v21 = *(float *)&v58;
                        LODWORD(v61[0]) = 0;
                        v22 = kdu_params::get(a3, "Kcoeffs", v14 + v20, 0, (float *)v61, 1, 1, 1);
                        v19 = *(_DWORD *)&v60[4];
                        if (v22)
                          v23 = *(float *)v61 == v21;
                        else
                          v23 = 0;
                        if (!v23)
                          break;
                        ++v20;
                      }
                      while (v20 < *(int *)&v60[4]);
                    }
                    if (v20 != v19)
                      goto LABEL_44;
                    ++v13;
                    v14 += v19;
                    v5 = 0;
                    if (!kdu_params::get(this, "Ksteps", v13, 0, (int *)&v60[4], 1, 1, 1))
                      return v5;
                  }
                  return 0;
                }
              }
            }
          }
        }
      }
    }
LABEL_44:
    v24 = 0;
    v25 = 0;
    if (kdu_params::get(this, "Ksteps", 0, 0, (int *)&v60[4], 1, 1, 1))
    {
      v25 = 0;
      v24 = 0;
      do
      {
        if (!kdu_params::get(this, "Ksteps", v24, 1, (int *)v60, 1, 1, 1))
          break;
        if (!kdu_params::get(this, "Ksteps", v24, 2, (int *)&v59[4], 1, 1, 1))
          break;
        if (!kdu_params::get(this, "Ksteps", v24, 3, (int *)v59, 1, 1, 1))
          break;
        ++v24;
        v25 += *(_DWORD *)&v60[4];
      }
      while ((kdu_params::get(this, "Ksteps", v24, 0, (int *)&v60[4], 1, 1, 1) & 1) != 0);
    }
    if (v63[1])
      v26 = 7;
    else
      v26 = 11;
    v27 = 2 * v24;
    if (v63[1])
      v28 = 1;
    else
      v28 = 2;
    if (v63[1])
      v27 = 5 * v24;
    v29 = (v25 >> v63[0] << v28) + v27;
    if (v63[0])
      v30 = v24;
    else
      v30 = 0;
    v5 = (v26 - v30 + v29);
    if (a2)
    {
      if (v63[0])
        v31 = *((_DWORD *)this + 6) + 2048;
      else
        v31 = *((_DWORD *)this + 6);
      if (v63[1])
      {
        LOWORD(v31) = v31 + 4096;
        v32 = 256;
      }
      else
      {
        v32 = 512;
      }
      if ((v24 & 1) != 0)
        LOWORD(v31) = v31 + 0x2000;
      if (v62 == 1)
        v33 = v31 + 0x4000;
      else
        v33 = v31;
      v34 = v33 + v32;
      kdu_output::put(a2, 255);
      kdu_output::put(a2, 121);
      kdu_output::put(a2, (unsigned __int16)(v5 - 2) >> 8);
      kdu_output::put(a2, v5 - 2);
      kdu_output::put(a2, SHIBYTE(v34));
      kdu_output::put(a2, v33);
      v57 = v5;
      if (v63[1])
      {
        v35 = 6;
      }
      else
      {
        if (kdu_params::get(this, "Ksteps", 0, 0, (int *)&v60[4], 1, 1, 1))
        {
          v36 = 0;
          v37 = 0;
          v38 = 1.0;
          v39 = 1.0;
          do
          {
            v40 = v39;
            v41 = *(_DWORD *)&v60[4];
            if (*(int *)&v60[4] < 1)
            {
              v43 = 0.0;
            }
            else
            {
              v42 = 0;
              v43 = 0.0;
              do
              {
                kdu_params::get(this, "Kcoeffs", v36 + v42, 0, (float *)&v58, 1, 1, 1);
                v43 = v43 + *(float *)&v58;
                ++v42;
                v41 = *(_DWORD *)&v60[4];
              }
              while (v42 < *(int *)&v60[4]);
            }
            v39 = v38 + v43 * v40;
            ++v37;
            v36 += v41;
            v38 = v40;
          }
          while ((kdu_params::get(this, "Ksteps", v37, 0, (int *)&v60[4], 1, 1, 1) & 1) != 0);
          if ((v37 & 1) != 0)
            v44 = v40;
          else
            v44 = v39;
          *(float *)&v45 = v44;
          v46 = v45;
        }
        else
        {
          v46 = 1065353216;
        }
        kdu_output::put(a2, v46);
        v35 = 10;
      }
      v47 = kdu_output::put(a2, v24) + v35;
      if (v24 >= 1)
      {
        do
        {
          kdu_params::get(this, "Ksteps", v24 - 1, 0, (int *)&v60[4], 1, 1, 1);
          kdu_params::get(this, "Ksteps", v24 - 1, 1, (int *)v60, 1, 1, 1);
          kdu_params::get(this, "Ksteps", v24 - 1, 2, (int *)&v59[4], 1, 1, 1);
          kdu_params::get(this, "Ksteps", v24 - 1, 3, (int *)v59, 1, 1, 1);
          if (!v63[0])
            v47 += kdu_output::put(a2, v60[0]);
          if (v63[1])
          {
            v48 = kdu_output::put(a2, v59[4]);
            v49 = v59[0];
            kdu_output::put(a2, v59[1]);
            kdu_output::put(a2, v49);
            v47 += v48 + 2;
          }
          v50 = *(_DWORD *)&v60[4];
          if (v63[0])
          {
            v50 = *(int *)&v60[4] >> 1;
            *(int *)&v60[4] >>= 1;
          }
          v51 = v25 - v50;
          v47 += kdu_output::put(a2, v50);
          v52 = *(_DWORD *)&v60[4];
          if (*(int *)&v60[4] >= 1)
          {
            v53 = 0;
            do
            {
              kdu_params::get(this, "Kcoeffs", v51 + v53, 0, (float *)&v58, 1, 1, 1);
              if (v63[1])
              {
                v54 = vcvtms_s32_f32((float)(*(float *)&v58 * (float)(1 << v59[4])) + 0.5);
                kdu_output::put(a2, SHIBYTE(v54));
                kdu_output::put(a2, v54);
                v55 = 2;
              }
              else
              {
                kdu_output::put(a2, v58);
                v55 = 4;
              }
              v47 += v55;
              ++v53;
              v52 = *(_DWORD *)&v60[4];
            }
            while (v53 < *(int *)&v60[4]);
          }
          if (!v63[0])
            v52 = 0;
          v25 = v51 - v52;
        }
        while (v24-- > 1);
      }
      v23 = v57 == v47;
      v5 = v57;
      if (!v23)
        atk_params::write_marker_segment();
    }
  }
  return v5;
}

void sub_187F39F60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F39F6C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_params::compare(kdu_params *this, const char *a2, int a3, int a4, int a5)
{
  uint64_t result;
  BOOL v7;

  v7 = 0;
  LODWORD(result) = kdu_params::get(this, a2, a3, a4, &v7, 1, 1, 1);
  if (v7 == a5)
    return result;
  else
    return 0;
}

void cod_params::cod_params(cod_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 0;
  *((_BYTE *)this + 42) = 0;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 16842753;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BAB770;
  *((_QWORD *)this + 1) = "COD";
  kdu_params::add_dependency((uint64_t)this, "QCD");
  kdu_params::define_attribute(this, "Clayers", "Number of quality layers. May not exceed 16384.\n\t\t[Default is 1]", "I", 4);
  kdu_params::define_attribute(this, "Cuse_sop", "Include SOP markers (i.e., resync markers)?\n\t\t[Default is no SOP markers]", "B", 4);
  kdu_params::define_attribute(this, "Cuse_eph", "Include EPH markers (marker end of each packet header)?\n\t\t[Default is no EPH markers]", "B", 4);
  kdu_params::define_attribute(this, "Corder", "Default progression order (may be overridden by Porder).  The four character identifiers have the following interpretation: L=layer; R=resolution; C=component; P=position. The first character in the identifier refers to the index wh"
    "ich progresses most slowly, while the last refers to the index which progresses most quickly.\n"
    "\t\t[Default is LRCP]",
    "(LRCP=0,RLCP=1,RPCL=2,PCRL=3,CPRL=4)",
    4);
  kdu_params::define_attribute(this, "Calign_blk_last", "If \"yes\", the code-block partition is aligned so that the last sample in each nominal block (ignoring the effect of boundaries) is aligned at a multiple of the block dimension (a power of 2).  Equivalently, the first sample in each nominal block lies at a location which is a multiple of the block dimension, plus 1. By default (i.e., \"no\"), the first sample of each block is aligned at a multiple of the block dimension. The alignment is specified separately for both dimensions, with the vertical dimension specified first.", "BB", 4);
  kdu_params::define_attribute(this, "Clevels", "Number of wavelet decomposition levels, or stages.  May not exceed 32.\n\t\t[Default is 5]", "I", 0);
    "imary detail subbands, denoted HL, LH and HH.  The second and third options produce only one primary detail subband "
    "(HX or XH), while the last option produces no detail subbands at all.  The primary splitting code is followed by par"
    "entheses, containing 0, 1 or 3 colon-separated sub-strings, each of which describes the additional splitting operati"
    "four additional characters may be provided to describe further splitting of the LL, HL, LH and HH subbands produced "
    "by the primary split.  Alternatively, the sub-string may consist only of the initial character, in which case no fur"
    "ther splitting is involved.  Thus, \"B\" and \"B----\" are equivalent sub-strings, as are \"H\" and \"H--\".\n"
    "\t   If insufficient parameters are supplied to accommodate the number of desired DWT levels, the final value is sim"
    "ply replicated.  Note, however, that the last value must conform to some specific rules, which derive from the way i"
    "n which JPEG2000 Part-2 defines extrapolation for information found in the ADS and DFS marker segments.  In particul"
    "ar, the terminal parameter must have identical splitting descriptors for all primary detail subbands (remember there"
    "ust be identical.  The only exception to this occurs where all primary detail subbands are split only once, in which"
    " case all primary detail subbands must have identical sub-strings holding one of the patterns, \"B----\", \"H--\", \""
    "V--\" or \"-\".  Thus, \"B(-:-:-)\", \"H(BBBBB)\", \"B(HHH:HHH:HHH)\", \"V(H--)\" and \"B(V--:V--:V--)\" are all leg"
    "al terminal values, while \"B(B:B:-)\" and \"V(VV-)\" are not legal.\n"
    "teger value, 3.  All Part-1 codestreams must use this Mallat decomposition style.]",
    "C",
    3);
  kdu_params::define_attribute(this, "Cprecincts", "Precinct dimensions (must be powers of 2). Multiple records may be supplied, in which case the first record refers to the highest resolution level and subsequent records to lower resolution levels. The last specified record is used for any remaining lower resolution levels.Inside each record, vertical coordinates appear first.", "II", 3);
  kdu_params::define_attribute(this, "Cblk", "Nominal code-block dimensions (must be powers of 2, no less than 4 and no greater than 1024). Actual dimensions are subject to precinct, tile and image dimensions. Vertical coordinates appear first.\n\t\t[Default block dimensions are {64,64}]", "II", 0);
  kdu_params::define_attribute(this, "Cmodes", "Block coder mode switches. Any combination is legal.\n\t\t[By default, all mode switches are turned off]", "[BYPASS=1|RESET=2|RESTART=4|CAUSAL=8|ERTERM=16|SEGMARK=32]", 0);
    "p' attribute is used to describe more general packet wavelet transforms, all subbands obtained by splitting an HL, L"
    "H or HH subband will be assigned the same weight.  No mechanism is provided for specifying their weights separately."
    "  Moreover, all three weights (HL, LH and HH) are present for each resolution level, even if that level only involve"
    "s horizontal or vertical splitting, and even in the degenerate case of no splitting at all.  For horizontal splittin"
    "g only, subbands derived from HX use the corresponding HL weight; HH and LH weights are then ignored.  Similarly for"
    " vertical splitting only, subbands derived from XH use the corresponding LH weight; HH and HL weights are then ignored.",
    "F",
    3);
}

void sub_187F3A310(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t cod_params::copy_with_xforms(cod_params *this, kdu_params *a2, int a3, int a4, int a5, int a6, int a7)
{
  _BOOL4 v14;
  _BOOL4 v15;
  int v16;
  int *v17;
  int v18;
  int v19;
  int v20;
  char v21;
  int v22;
  uint64_t result;
  int v24;
  float v25;
  int v26[2];
  cod_params *v27[2];
  __int128 v28;
  uint64_t v29;
  int v30;
  BOOL v31[8];
  BOOL v32;
  BOOL v33[4];
  BOOL v34[4];
  BOOL v35;
  BOOL v36[8];

  if ((*((_DWORD *)this + 5) & 0x80000000) != 0)
  {
    v36[0] = 0;
    LODWORD(v27[0]) = 0;
    v34[0] = 0;
    v33[0] = 0;
    *(_DWORD *)&v36[4] = 0;
    v31[4] = 0;
    v31[0] = 0;
    if (kdu_params::get(a2, "Cycc", 0, 0, v36, 0, 1, 1))
    {
      if (a3)
      {
        v14 = 0;
        v36[0] = 0;
      }
      else
      {
        v14 = v36[0];
      }
      kdu_params::set((uint64_t)this, "Cycc", 0, 0, v14);
    }
    if (kdu_params::get(a2, "Clayers", 0, 0, (int *)v27, 0, 1, 1))
      kdu_params::set(this, "Clayers", 0, 0, (int *)LODWORD(v27[0]));
    if (kdu_params::get(a2, "Cuse_sop", 0, 0, v34, 0, 1, 1))
      kdu_params::set((uint64_t)this, "Cuse_sop", 0, 0, v34[0]);
    if (kdu_params::get(a2, "Cuse_eph", 0, 0, v33, 0, 1, 1))
      kdu_params::set((uint64_t)this, "Cuse_eph", 0, 0, v33[0]);
    if (kdu_params::get(a2, "Corder", 0, 0, (int *)&v36[4], 0, 1, 1))
      kdu_params::set(this, "Corder", 0, 0, (int *)*(unsigned int *)&v36[4]);
    if (kdu_params::get(a2, "Calign_blk_last", 0, a5, v31, 0, 1, 1)
      && kdu_params::get(a2, "Calign_blk_last", 0, a5 ^ 1u, &v31[4], 0, 1, 1))
    {
      if (a7)
        v31[4] ^= 1u;
      v15 = v31[0];
      if (a6)
      {
        v15 = !v31[0];
        v31[0] ^= 1u;
      }
      kdu_params::set((uint64_t)this, "Calign_blk_last", 0, 0, v15);
      kdu_params::set((uint64_t)this, "Calign_blk_last", 0, 1, v31[4]);
    }
  }
  *(_QWORD *)v36 = 0;
  v35 = 0;
  *(_DWORD *)v33 = 0;
  *(_DWORD *)v34 = 0;
  v32 = 0;
  *(_QWORD *)v31 = 0;
  v30 = 0;
  if (kdu_params::get(a2, "Clevels", 0, 0, (int *)&v36[4], 0, 1, 1))
  {
    v16 = *(_DWORD *)&v36[4];
    v17 = (int *)(*(_DWORD *)&v36[4] - a4);
    *(_DWORD *)&v36[4] -= a4;
    if (v16 - a4 < 0)
    {
      v29 = 0;
      *(_OWORD *)v27 = 0u;
      v28 = 0u;
      kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
      (*((void (**)(cod_params **, const char *))v27[0] + 2))(v27, "Attempting to discard too many resolution levels!  Cannot discard more resolution levels than there are DWT levels.");
      kdu_error::~kdu_error((kdu_error *)v27);
    }
    kdu_params::set(this, "Clevels", 0, 0, v17);
  }
  if (kdu_params::get(a2, "Cdfs", 0, 0, (int *)v36, 0, 1, 1))
    kdu_params::set(this, "Cdfs", 0, 0, (int *)*(unsigned int *)v36);
  LODWORD(v27[0]) = 0;
  if (kdu_params::get(a2, "Cdecomp", 0, 0, (int *)v27, 0, 0, 1))
  {
    v18 = 0;
    do
    {
      v19 = v18;
      if (a5)
        LODWORD(v27[0]) = cod_params::transpose_decomp((cod_params *)LODWORD(v27[0]));
      if (v18 >= a4)
        kdu_params::set(this, "Cdecomp", v18 - a4, 0, (int *)LODWORD(v27[0]));
      ++v18;
    }
    while ((kdu_params::get(a2, "Cdecomp", v19 + 1, 0, (int *)v27, 0, 0, 1) & 1) != 0);
    if (v19 < a4)
      kdu_params::set(this, "Cdecomp", 0, 0, (int *)LODWORD(v27[0]));
  }
  if (kdu_params::get(a2, "Creversible", 0, 0, &v35, 0, 1, 1))
    kdu_params::set((uint64_t)this, "Creversible", 0, 0, v35);
  if (kdu_params::get(a2, "Ckernels", 0, 0, (int *)v34, 0, 1, 1))
    kdu_params::set(this, "Ckernels", 0, 0, (int *)*(unsigned int *)v34);
  if (kdu_params::get(a2, "Catk", 0, 0, (int *)v33, 0, 1, 1))
    kdu_params::set(this, "Catk", 0, 0, (int *)*(unsigned int *)v33);
  if (kdu_params::get(a2, "Cuse_precincts", 0, 0, &v32, 0, 1, 1))
    kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, v32);
  if (kdu_params::get(a2, "Cblk", 0, a5, (int *)v31, 0, 1, 1)
    && kdu_params::get(a2, "Cblk", 0, a5 ^ 1u, (int *)&v31[4], 0, 1, 1))
  {
    kdu_params::set(this, "Cblk", 0, 0, (int *)*(unsigned int *)v31);
    kdu_params::set(this, "Cblk", 0, 1, (int *)*(unsigned int *)&v31[4]);
  }
  if (kdu_params::get(a2, "Cmodes", 0, 0, &v30, 0, 1, 1))
    kdu_params::set(this, "Cmodes", 0, 0, (int *)v30);
  *(_QWORD *)v26 = 0;
  if (kdu_params::get(a2, "Cprecincts", a4, a5, v26, 0, 1, 1))
  {
    if (kdu_params::get(a2, "Cprecincts", a4, a5 ^ 1u, &v26[1], 0, 1, 1))
    {
      kdu_params::set(this, "Cprecincts", 0, 0, (int *)v26[0]);
      kdu_params::set(this, "Cprecincts", 0, 1, (int *)v26[1]);
      if (kdu_params::get(a2, "Cprecincts", a4 + 1, a5, v26, 0, 0, 1))
      {
        v20 = 0;
        do
        {
          if (!kdu_params::get(a2, "Cprecincts", v20 + 1 + a4, a5 ^ 1u, &v26[1], 0, 0, 1))
            break;
          kdu_params::set(this, "Cprecincts", v20 + 1, 0, (int *)v26[0]);
          kdu_params::set(this, "Cprecincts", v20 + 1, 1, (int *)v26[1]);
          v21 = kdu_params::get(a2, "Cprecincts", a4 + v20++ + 2, a5, v26, 0, 0, 1);
        }
        while ((v21 & 1) != 0);
      }
    }
  }
  v25 = 0.0;
  if (kdu_params::get(a2, "Cweight", 0, 0, &v25, 0, 1, 1))
    kdu_params::set((uint64_t)this, "Cweight", 0, 0, v25);
  if (kdu_params::get(a2, "Clev_weights", 0, 0, &v25, 0, 0, 1))
  {
    v22 = 0;
    do
      kdu_params::set((uint64_t)this, "Clev_weights", v22++, 0, v25);
    while ((kdu_params::get(a2, "Clev_weights", v22, 0, &v25, 0, 0, 1) & 1) != 0);
  }
  result = kdu_params::get(a2, "Cband_weights", 0, 0, &v25, 0, 0, 1);
  if ((_DWORD)result)
  {
    v24 = 0;
    do
    {
      kdu_params::set((uint64_t)this, "Cband_weights", v24++, 0, v25);
      result = kdu_params::get(a2, "Cband_weights", v24, 0, &v25, 0, 0, 1);
    }
    while ((result & 1) != 0);
  }
  return result;
}

void sub_187F3AC24(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F3AC30()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t cod_params::transpose_decomp(cod_params *this)
{
  unsigned int v1;

  v1 = this & 0xFFC00003 | (((this >> 2) & 0x3FF) << 12) | (this >> 10) & 0xFFC;
  if ((~(_DWORD)this & 3) != 0)
    v1 = this;
  if ((~v1 & 0xC) == 0)
    v1 = v1 & 0xFFFFFC3F | (v1 >> 6 << 8) | (v1 >> 2) & 0xC0;
  if ((~v1 & 0x3000) == 0)
    v1 = v1 & 0xFFF0FFFF | ((HIWORD(v1) & 3) << 18) | (v1 >> 2) & 0x30000;
  if ((~v1 & 0xC00000) == 0)
    v1 = v1 & 0xC3FFFFFF | (((v1 >> 26) & 3) << 28) | (v1 >> 2) & 0xC000000;
  return (2 * v1) & 0xAAAAAAAA | (v1 >> 1) & 0x55555555;
}

uint64_t cod_params::write_marker_segment(cod_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v4;
  _BOOL4 v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  _BOOL4 v14;
  int v15;
  int v16;
  _BOOL4 v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  BOOL v56;
  int v57;
  char v58;
  char v59;
  int v60;
  char v61;
  char v62;
  uint64_t v63;
  kdu_params *v64;
  int v65;
  kdu_params *v66;
  uint64_t v67;
  kdu_params *v68;
  _BOOL4 v69;
  int v70;
  int v71;
  int v72;
  char v73;
  char v74;
  char v75;
  int v76;
  int v77;
  BOOL v78;
  BOOL v79;
  BOOL v80;
  BOOL v81;
  int v82;
  int v83;
  char v84;
  int v85;
  int v86;
  unsigned int v87;
  int v88;
  int v89;
  unsigned int v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  char v94;
  unsigned int v95;
  BOOL v96;
  char v97;
  char v98;
  int v99;
  int v100;
  int v101;
  int v102;
  char v103;
  int v104;
  int v105;
  int v106;
  int v107;
  unsigned int v108;
  int v109;
  unsigned int v110;
  int v111;
  unsigned int v112;
  int v113;
  unsigned int v114;
  int v116;
  int v117;
  BOOL v118;
  int v119;
  unsigned __int8 v120[8];
  int v121[2];
  int v122[2];
  int v123[2];
  int v124;
  BOOL v125[2];
  unsigned __int8 v126[8];
  BOOL v127;
  BOOL v128[2];
  BOOL v129[2];
  int v130[4];
  __int128 v131;
  uint64_t v132;
  BOOL v133[16];
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  uint64_t v138;

  v138 = *MEMORY[0x1E0C80C00];
  if (a4)
    return 0;
  *(_WORD *)v129 = 0;
  *(_WORD *)v128 = 0;
  v127 = 0;
  *(_QWORD *)v126 = 0;
  *(_WORD *)v125 = 0;
  v124 = 0;
  *(_QWORD *)v122 = 0;
  *(_QWORD *)v123 = 0;
  *(_QWORD *)v120 = 0;
  *(_QWORD *)v121 = 0;
  v119 = 0;
  if (!kdu_params::get(this, "Cycc", 0, 0, &v129[1], 1, 1, 1)
    || !kdu_params::get(this, "Clayers", 0, 0, (int *)&v126[4], 1, 1, 1)
    || !kdu_params::get(this, "Cuse_sop", 0, 0, v129, 1, 1, 1)
    || !kdu_params::get(this, "Cuse_eph", 0, 0, &v128[1], 1, 1, 1)
    || !kdu_params::get(this, "Corder", 0, 0, (int *)v126, 1, 1, 1)
    || !kdu_params::get(this, "Calign_blk_last", 0, 0, &v127, 1, 1, 1)
    || !kdu_params::get(this, "Calign_blk_last", 0, 1, v128, 1, 1, 1)
    || !kdu_params::get(this, "Clevels", 0, 0, &v124, 1, 1, 1)
    || !kdu_params::get(this, "Cdfs", 0, 0, v123, 1, 1, 1)
    || !kdu_params::get(this, "Cads", 0, 0, &v123[1], 1, 1, 1)
    || !kdu_params::get(this, "Creversible", 0, 0, &v125[1], 1, 1, 1)
    || !kdu_params::get(this, "Ckernels", 0, 0, &v122[1], 1, 1, 1)
    || !kdu_params::get(this, "Catk", 0, 0, v122, 1, 1, 1)
    || !kdu_params::get(this, "Cblk", 0, 0, &v121[1], 1, 1, 1)
    || !kdu_params::get(this, "Cblk", 0, 1, v121, 1, 1, 1)
    || !kdu_params::get(this, "Cmodes", 0, 0, (int *)&v120[4], 1, 1, 1)
    || (kdu_params::get(this, "Cuse_precincts", 0, 0, v125, 1, 1, 1) & 1) == 0)
  {
    *(_QWORD *)&v135 = 0;
    v134 = 0u;
    *(_OWORD *)v133 = 0u;
    kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v133);
  }
  if (a3)
  {
    v8 = v129[1];
    v133[0] = 0;
    v9 = kdu_params::get(a3, "Cycc", 0, 0, v133, 1, 1, 1);
    v10 = v133[0] == v8 ? v9 : 0;
    if (v10 == 1)
    {
      v11 = *(_DWORD *)&v126[4];
      *(_DWORD *)v133 = 0;
      v12 = kdu_params::get(a3, "Clayers", 0, 0, (int *)v133, 1, 1, 1);
      v13 = *(_DWORD *)v133 == v11 ? v12 : 0;
      if (v13 == 1)
      {
        v14 = v129[0];
        v133[0] = 0;
        v15 = kdu_params::get(a3, "Cuse_sop", 0, 0, v133, 1, 1, 1);
        v16 = v133[0] == v14 ? v15 : 0;
        if (v16 == 1)
        {
          v17 = v128[1];
          v133[0] = 0;
          v18 = kdu_params::get(a3, "Cuse_eph", 0, 0, v133, 1, 1, 1);
          v19 = v133[0] == v17 ? v18 : 0;
          if (v19 == 1)
          {
            v20 = *(_DWORD *)v126;
            *(_DWORD *)v133 = 0;
            v21 = kdu_params::get(a3, "Corder", 0, 0, (int *)v133, 1, 1, 1);
            v22 = *(_DWORD *)v133 == v20 ? v21 : 0;
            if (v22 == 1
              && kdu_params::compare(a3, "Calign_blk_last", 0, 0, v127)
              && kdu_params::compare(a3, "Calign_blk_last", 0, 1, v128[0]))
            {
              v23 = v124;
              *(_DWORD *)v133 = 0;
              v24 = kdu_params::get(a3, "Clevels", 0, 0, (int *)v133, 1, 1, 1);
              v25 = *(_DWORD *)v133 == v23 ? v24 : 0;
              if (v25 == 1)
              {
                v26 = v123[1];
                *(_DWORD *)v133 = 0;
                v27 = kdu_params::get(a3, "Cads", 0, 0, (int *)v133, 1, 1, 1);
                v28 = *(_DWORD *)v133 == v26 ? v27 : 0;
                if (v28 == 1)
                {
                  v29 = v123[0];
                  *(_DWORD *)v133 = 0;
                  v30 = kdu_params::get(a3, "Cdfs", 0, 0, (int *)v133, 1, 1, 1);
                  v31 = *(_DWORD *)v133 == v29 ? v30 : 0;
                  if (v31 == 1
                    && (!v123[1] || (*((_DWORD *)a3 + 4) & 0x80000000) == 0)
                    && (!v123[0] || (*((_DWORD *)this + 4) & 0x80000000) == 0))
                  {
                    if (kdu_params::compare(a3, "Creversible", 0, 0, v125[1]))
                    {
                      v32 = v122[1];
                      *(_DWORD *)v133 = 0;
                      v33 = kdu_params::get(a3, "Ckernels", 0, 0, (int *)v133, 1, 1, 1);
                      v34 = *(_DWORD *)v133 == v32 ? v33 : 0;
                      if (v34 == 1)
                      {
                        v35 = v122[0];
                        *(_DWORD *)v133 = 0;
                        v36 = kdu_params::get(a3, "Catk", 0, 0, (int *)v133, 1, 1, 1);
                        v37 = *(_DWORD *)v133 == v35 ? v36 : 0;
                        if (v37 == 1)
                        {
                          v38 = v121[1];
                          *(_DWORD *)v133 = 0;
                          v39 = kdu_params::get(a3, "Cblk", 0, 0, (int *)v133, 1, 1, 1);
                          v40 = *(_DWORD *)v133 == v38 ? v39 : 0;
                          if (v40 == 1)
                          {
                            v41 = v121[0];
                            *(_DWORD *)v133 = 0;
                            v42 = kdu_params::get(a3, "Cblk", 0, 1, (int *)v133, 1, 1, 1);
                            v43 = *(_DWORD *)v133 == v41 ? v42 : 0;
                            if (v43 == 1)
                            {
                              v44 = *(_DWORD *)&v120[4];
                              *(_DWORD *)v133 = 0;
                              v45 = kdu_params::get(a3, "Cmodes", 0, 0, (int *)v133, 1, 1, 1);
                              v46 = *(_DWORD *)v133 == v44 ? v45 : 0;
                              if (v46 == 1 && kdu_params::compare(a3, "Cuse_precincts", 0, 0, v125[0]))
                              {
                                if (!v125[0])
                                  return 0;
                                v47 = v124;
                                if (v124 < 0)
                                {
                                  v55 = 0;
                                }
                                else
                                {
                                  v48 = 0;
                                  while (kdu_params::get(this, "Cprecincts", v48, 0, &v119, 1, 1, 1)
                                       && kdu_params::get(this, "Cprecincts", v48, 1, (int *)v120, 1, 1, 1))
                                  {
                                    v49 = v119;
                                    *(_DWORD *)v133 = 0;
                                    v50 = kdu_params::get(a3, "Cprecincts", v48, 0, (int *)v133, 1, 1, 1);
                                    v51 = *(_DWORD *)v133 == v49 ? v50 : 0;
                                    if (v51 != 1)
                                      break;
                                    v52 = *(_DWORD *)v120;
                                    *(_DWORD *)v133 = 0;
                                    v53 = kdu_params::get(a3, "Cprecincts", v48, 1, (int *)v133, 1, 1, 1);
                                    v54 = *(_DWORD *)v133 == v52 ? v53 : 0;
                                    if (v54 != 1)
                                      break;
                                    v55 = v48 + 1;
                                    v56 = v48++ < v124;
                                    if (!v56)
                                      goto LABEL_98;
                                  }
                                  v55 = v48;
LABEL_98:
                                  v47 = v124;
                                }
                                if (v55 > v47)
                                  return 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (v123[1] && (*((_DWORD *)this + 4) & 0x80000000) == 0)
  {
    if (!a3
      || ((v57 = v124,
           *(_DWORD *)v133 = 0,
           v58 = kdu_params::get(a3, "Clevels", 0, 0, (int *)v133, 1, 1, 1),
           *(_DWORD *)v133 == v57)
        ? (v59 = v58)
        : (v59 = 0),
          (v59 & 1) == 0))
    {
      *(_QWORD *)&v135 = 0;
      v134 = 0u;
      *(_OWORD *)v133 = 0u;
      kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v133);
    }
  }
  if (v123[0] && (*((_DWORD *)this + 4) & 0x80000000) != 0 && (*((_DWORD *)this + 5) & 0x80000000) == 0)
  {
    if (!a3
      || ((v60 = v124,
           *(_DWORD *)v133 = 0,
           v61 = kdu_params::get(a3, "Clevels", 0, 0, (int *)v133, 1, 1, 1),
           *(_DWORD *)v133 == v60)
        ? (v62 = v61)
        : (v62 = 0),
          (v62 & 1) == 0))
    {
      *(_QWORD *)&v135 = 0;
      v134 = 0u;
      *(_OWORD *)v133 = 0u;
      kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v133);
    }
  }
  v63 = kdu_params::access_cluster(this, "SIZ");
  if (!v63)
    cod_params::write_marker_segment();
  v64 = (kdu_params *)v63;
  if (*(_DWORD *)&v126[4] >= 0x10000u)
  {
    v132 = 0;
    *(_OWORD *)v130 = 0u;
    v131 = 0u;
    kdu_error::kdu_error((kdu_error *)v130, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v130 + 16))(v130, "Illegal number of quality layers, ");
    v136 = 0u;
    v137 = 0u;
    v134 = 0u;
    v135 = 0u;
    *(_OWORD *)v133 = 0u;
    if (LOBYTE(v130[2]))
      sprintf((char *)v133, "%x");
    else
      sprintf((char *)v133, "%d");
    (*(void (**)(int *, BOOL *))(*(_QWORD *)v130 + 16))(v130, v133);
    (*(void (**)(int *, const char *))(*(_QWORD *)v130 + 16))(v130, ".");
    kdu_error::~kdu_error((kdu_error *)v130);
  }
  if (v124 >= 0x21)
  {
    v132 = 0;
    *(_OWORD *)v130 = 0u;
    v131 = 0u;
    kdu_error::kdu_error((kdu_error *)v130, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v130 + 16))(v130, "Illegal number of DWT levels, ");
    v136 = 0u;
    v137 = 0u;
    v134 = 0u;
    v135 = 0u;
    *(_OWORD *)v133 = 0u;
    if (LOBYTE(v130[2]))
      sprintf((char *)v133, "%x");
    else
      sprintf((char *)v133, "%d");
    (*(void (**)(int *, BOOL *))(*(_QWORD *)v130 + 16))(v130, v133);
    (*(void (**)(int *, const char *))(*(_QWORD *)v130 + 16))(v130, ". Legal range is 0 to 32!");
    kdu_error::~kdu_error((kdu_error *)v130);
  }
  v116 = *((_DWORD *)this + 8);
  if ((*((_DWORD *)this + 5) & 0x80000000) != 0)
  {
    if (v129[1])
    {
      v66 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), 0, 0, 1);
      *(_QWORD *)v130 = v66;
      *(_QWORD *)&v130[2] = kdu_params::access_relation(this, *((_DWORD *)this + 4), 1, 0, 1);
      *(_QWORD *)&v131 = kdu_params::access_relation(this, *((_DWORD *)this + 4), 2, 0, 1);
      v118 = 0;
      kdu_params::get(v66, "Creversible", 0, 0, &v118, 1, 1, 1);
      v117 = 0;
      kdu_params::get(v64, "Sprecision", 0, 0, &v117, 1, 1, 1);
      v67 = 1;
      do
      {
        v68 = *(kdu_params **)&v130[2 * v67];
        if (!v68)
          break;
        v69 = v118;
        v133[0] = 0;
        v70 = kdu_params::get(v68, "Creversible", 0, 0, v133, 1, 1, 1);
        if (v133[0] == v69)
          v71 = v70;
        else
          v71 = 0;
        if (v71 == 1)
        {
          v72 = v117;
          *(_DWORD *)v133 = 0;
          v73 = kdu_params::get(v64, "Sprecision", v67, 0, (int *)v133, 1, 1, 1);
          v74 = *(_DWORD *)v133 == v72 ? v73 : 0;
          if ((v74 & 1) != 0)
            continue;
        }
        *(_QWORD *)&v135 = 0;
        v134 = 0u;
        *(_OWORD *)v133 = 0u;
        kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
        (*(void (**)(BOOL *, const char *))(*(_QWORD *)v133 + 16))(v133, "You cannot use a colour transform unless the first 3 image components have identical bit-depths and are either all reversible or all irreversible.");
        kdu_error::~kdu_error((kdu_error *)v133);
        ++v67;
      }
      while (v67 != 3);
    }
    v65 = 9;
  }
  else if (*((int *)this + 8) < 257)
  {
    v65 = 6;
  }
  else
  {
    v65 = 7;
  }
  v4 = v65 + v125[0] + v125[0] * v124 + 5;
  if (a2)
  {
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
    {
      v117 = 2;
      kdu_params::get(v64, "Sprofile", 0, 0, &v117, 1, 1, 1);
      if (!v117)
      {
        v132 = 0;
        *(_OWORD *)v130 = 0u;
        v131 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)v130, "Kakadu Core Warning:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v130 + 16))(v130, "Profile violation detected (code-stream is technically illegal).  COD/COC marker segments may only appear in the main header of a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.  Problem detected in tile ");
        v136 = 0u;
        v137 = 0u;
        v134 = 0u;
        v135 = 0u;
        *(_OWORD *)v133 = 0u;
        if (LOBYTE(v130[2]))
          sprintf((char *)v133, "%x");
        else
          sprintf((char *)v133, "%d");
        (*(void (**)(int *, BOOL *))(*(_QWORD *)v130 + 16))(v130, v133);
        (*(void (**)(int *, const char *))(*(_QWORD *)v130 + 16))(v130, ".");
        kdu_warning::~kdu_warning((kdu_warning *)v130);
      }
    }
    if (v122[0])
    {
      if ((v122[0] - 256) <= 0xFFFFFF01)
      {
        *(_QWORD *)&v135 = 0;
        v134 = 0u;
        *(_OWORD *)v133 = 0u;
        kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
        (*(void (**)(BOOL *, const char *))(*(_QWORD *)v133 + 16))(v133, "Illegal ATK instance index found when preparing to generate COD/COC marker segment.  Legal values are in the range 2 to 255.");
        kdu_error::~kdu_error((kdu_error *)v133);
      }
    }
    else if (v122[1] != v125[1])
    {
      *(_QWORD *)&v135 = 0;
      v134 = 0u;
      *(_OWORD *)v133 = 0u;
      kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v133);
    }
    v75 = v125[0];
    if ((*((_DWORD *)this + 5) & 0x80000000) != 0)
    {
      v78 = v129[0];
      v79 = v128[1];
      v80 = v128[0];
      v81 = v127;
      kdu_output::put(a2, 255);
      kdu_output::put(a2, 82);
      kdu_output::put(a2, (unsigned __int16)(v4 - 2) >> 8);
      kdu_output::put(a2, v4 - 2);
      v82 = kdu_output::put(a2, ((2 * v78) | (4 * v79) | (8 * v80) | (16 * v81)) | v75);
      v83 = kdu_output::put(a2, v126[0]);
      v84 = v126[4];
      kdu_output::put(a2, v126[5]);
      kdu_output::put(a2, v84);
      v85 = v82 + v83 + kdu_output::put(a2, v129[1]) + 6;
    }
    else
    {
      kdu_output::put(a2, 255);
      kdu_output::put(a2, 83);
      kdu_output::put(a2, (unsigned __int16)(v4 - 2) >> 8);
      kdu_output::put(a2, v4 - 2);
      v76 = *((_DWORD *)this + 5);
      if (v116 >= 257)
      {
        kdu_output::put(a2, SBYTE1(v76));
        kdu_output::put(a2, v76);
        v77 = 6;
      }
      else
      {
        v77 = kdu_output::put(a2, v76) + 4;
      }
      v85 = v77 + kdu_output::put(a2, v75);
    }
    v86 = -1;
    do
    {
      v87 = v86 + 1;
      v88 = 1 << (v86 + 1);
      if (v86 == 30)
        break;
      ++v86;
    }
    while (v88 < v121[0]);
    v89 = -1;
    do
    {
      v90 = v89 + 1;
      v91 = 1 << (v89 + 1);
      if (v89 == 30)
        break;
      ++v89;
    }
    while (v91 < v121[1]);
    if (v88 == v121[0])
      v92 = v87;
    else
      v92 = 0;
    if (v91 == v121[1])
      v93 = v90;
    else
      v93 = 0;
    v94 = v92 - 2;
    if (v92 < 2 || ((v95 = v93 + v92, v93 >= 2) ? (v96 = v95 >= 0xD) : (v96 = 1), v96))
    {
      *(_QWORD *)&v135 = 0;
      v134 = 0u;
      *(_OWORD *)v133 = 0u;
      kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
      (*(void (**)(BOOL *, const char *))(*(_QWORD *)v133 + 16))(v133, "Maximum code-block dimensions must be no less than 4 and the maximum code-block area must not exceed 4096 samples!");
      kdu_error::~kdu_error((kdu_error *)v133);
    }
    if ((*((_DWORD *)this + 4) & 0x80000000) != 0)
    {
      v97 = v123[0];
      if (!v123[0] || (*((_DWORD *)this + 5) & 0x80000000) != 0)
        goto LABEL_190;
    }
    else
    {
      v97 = v123[1];
      if (!v123[1])
      {
LABEL_190:
        v98 = v124;
        goto LABEL_191;
      }
    }
    v98 = v97 | 0x80;
LABEL_191:
    v99 = kdu_output::put(a2, v98);
    v100 = kdu_output::put(a2, v94);
    v101 = kdu_output::put(a2, v93 - 2);
    v102 = kdu_output::put(a2, v120[4]);
    v103 = v122[0];
    if (!v122[0])
      v103 = v122[1];
    v104 = v99 + v85 + v100 + v101 + v102 + kdu_output::put(a2, v103);
    if (v125[0])
    {
      v105 = v124;
      if ((v124 & 0x80000000) == 0)
      {
        v106 = 0;
        do
        {
          v130[0] = 0;
          v117 = 0;
          if (!kdu_params::get(this, "Cprecincts", v105 - v106, 0, &v117, 1, 1, 1)
            || (kdu_params::get(this, "Cprecincts", v124 - v106, 1, v130, 1, 1, 1) & 1) == 0)
          {
            *(_QWORD *)&v135 = 0;
            v134 = 0u;
            *(_OWORD *)v133 = 0u;
            kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
            (*(void (**)(BOOL *, const char *))(*(_QWORD *)v133 + 16))(v133, "No precinct dimensions supplied for COD/COC!");
            kdu_error::~kdu_error((kdu_error *)v133);
          }
          v107 = -1;
          do
          {
            v108 = v107 + 1;
            v109 = 1 << (v107 + 1);
            if (v107 == 30)
              break;
            ++v107;
          }
          while (v109 < v130[0]);
          if (v109 == v130[0])
            v110 = v108;
          else
            v110 = 0;
          v130[0] = v110;
          v111 = -1;
          do
          {
            v112 = v111 + 1;
            v113 = 1 << (v111 + 1);
            if (v111 == 30)
              break;
            ++v111;
          }
          while (v113 < v117);
          if (v113 == v117)
            v114 = v112;
          else
            v114 = 0;
          v117 = v114;
          if (v110 > 0xF || v114 >= 0x10)
          {
            *(_QWORD *)&v135 = 0;
            v134 = 0u;
            *(_OWORD *)v133 = 0u;
            kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
            (*(void (**)(BOOL *, const char *))(*(_QWORD *)v133 + 16))(v133, "Precinct dimensions may not exceed 2^15!");
            kdu_error::~kdu_error((kdu_error *)v133);
          }
          v104 += kdu_output::put(a2, v110 + 16 * v114);
          v105 = v124;
          v56 = v106++ < v124;
        }
        while (v56);
      }
    }
    if ((_DWORD)v4 != v104)
      cod_params::write_marker_segment();
  }
  return v4;
}

void sub_187F3C088(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F3C094(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  _Unwind_Exception *v25;

  _Unwind_Resume(v25);
}

uint64_t cod_params::check_marker_segment(cod_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  int v5;
  uint64_t result;
  int v8;

  if (a2 == 65362)
  {
    v5 = -1;
    goto LABEL_7;
  }
  result = 0;
  if (a2 == 65363 && a3 >= 2)
  {
    v8 = *a4;
    *a5 = v8;
    if (*((int *)this + 8) < 257)
      return 1;
    v5 = a4[1] | (v8 << 8);
LABEL_7:
    *a5 = v5;
    return 1;
  }
  return result;
}

uint64_t cod_params::read_marker_segment(cod_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  unsigned __int8 *v9;
  int v10;
  int v11;
  unsigned __int8 *v12;
  char v13;
  unsigned __int8 *v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  kdu_params *v18;
  int v19;
  unsigned __int8 *v20;
  unsigned __int8 v21;
  int *v22;
  unsigned int v23;
  uint64_t v24;
  unsigned __int8 *v25;
  int v26;
  int v27;
  int v28;
  unsigned __int8 *v29;
  int v30;
  unsigned int v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *exception;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  int v43;
  char v44[16];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (a5)
    return 0;
  v9 = &a4[a3];
  v10 = *((_DWORD *)this + 5);
  if (v10 < 0)
  {
    if (a2 != 65362)
      return 0;
    if (a3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = a4;
      __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
    }
    v17 = *a4;
    if (v17 >= 0x20)
    {
      *(_QWORD *)&v46 = 0;
      *(_OWORD *)v44 = 0u;
      v45 = 0u;
      kdu_error::kdu_error((kdu_error *)v44, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v44 + 16))(v44, "Malformed COD marker segment encountered. Invalid \"Scod\" value!");
      kdu_error::~kdu_error((kdu_error *)v44);
    }
    v16 = v17 & 1;
    kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, v16);
    kdu_params::set((uint64_t)this, "Cuse_sop", 0, 0, (v17 >> 1) & 1);
    kdu_params::set((uint64_t)this, "Cuse_eph", 0, 0, (v17 >> 2) & 1);
    kdu_params::set((uint64_t)this, "Calign_blk_last", 0, 1, (v17 >> 3) & 1);
    kdu_params::set((uint64_t)this, "Calign_blk_last", 0, 0, (v17 >> 4) & 1);
    if (a3 <= 1)
    {
      v36 = __cxa_allocate_exception(8uLL);
      *v36 = a4 + 1;
      __cxa_throw(v36, MEMORY[0x1E0DE4E60], 0);
    }
    kdu_params::set(this, "Corder", 0, 0, (int *)a4[1]);
    if (a3 <= 3)
    {
      v37 = __cxa_allocate_exception(8uLL);
      *v37 = a4 + 2;
      __cxa_throw(v37, MEMORY[0x1E0DE4E60], 0);
    }
    kdu_params::set(this, "Clayers", 0, 0, (int *)__rev16(*((unsigned __int16 *)a4 + 1)));
    if (a3 <= 4)
    {
      v38 = __cxa_allocate_exception(8uLL);
      *v38 = a4 + 4;
      __cxa_throw(v38, MEMORY[0x1E0DE4E60], 0);
    }
    v14 = a4 + 5;
    kdu_params::set(this, "Cycc", 0, 0, (int *)a4[4]);
  }
  else
  {
    if (a2 != 65363)
      return 0;
    v12 = a4 + 1;
    v11 = *a4;
    if (*((int *)this + 8) >= 257)
    {
      v12 = a4 + 2;
      v11 = a4[1] | (v11 << 8);
    }
    if (v11 != v10)
      return 0;
    if (v9 - v12 <= 0)
    {
      v39 = __cxa_allocate_exception(8uLL);
      *v39 = v12;
      __cxa_throw(v39, MEMORY[0x1E0DE4E60], 0);
    }
    v15 = *v12;
    v14 = v12 + 1;
    v13 = v15;
    if (v15 >= 2)
    {
      *(_QWORD *)&v46 = 0;
      *(_OWORD *)v44 = 0u;
      v45 = 0u;
      kdu_error::kdu_error((kdu_error *)v44, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v44 + 16))(v44, "Malformed COC marker segment. Invalid \"Scoc\" value!");
      kdu_error::~kdu_error((kdu_error *)v44);
    }
    v16 = v13 & 1;
    kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, v16);
  }
  if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
  {
    v18 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
    if (!v18)
      cod_params::read_marker_segment();
    v43 = 2;
    kdu_params::get(v18, "Sprofile", 0, 0, &v43, 1, 1, 1);
    if (!v43)
    {
      v42 = 0;
      v40 = 0u;
      v41 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v40, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v40 + 16))(&v40, "Profile violation detected (code-stream is technically illegal).  COD/COC marker segments may only appear in the main header of a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.  Problem detected in tile ");
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      *(_OWORD *)v44 = 0u;
      if (BYTE8(v40))
        sprintf(v44, "%x");
      else
        sprintf(v44, "%d");
      (*(void (**)(__int128 *, char *))(v40 + 16))(&v40, v44);
      (*(void (**)(__int128 *, const char *))(v40 + 16))(&v40, ".");
      kdu_warning::~kdu_warning((kdu_warning *)&v40);
    }
  }
  v43 = 0;
  if (v9 - v14 <= 0)
  {
    v33 = __cxa_allocate_exception(8uLL);
    *v33 = v14;
LABEL_61:
    __cxa_throw(v33, MEMORY[0x1E0DE4E60], 0);
  }
  v20 = v14 + 1;
  v19 = (char)*v14;
  v21 = *v14;
  v43 = *v14;
  if (v19 < 0)
  {
    v22 = (int *)(v21 & 0x7F);
    if ((*((_DWORD *)this + 4) & 0x80000000) != 0)
    {
      kdu_params::set(this, "Cdfs", 0, 0, v22);
      v22 = 0;
    }
    kdu_params::set(this, "Cads", 0, 0, v22);
    if ((kdu_params::get(this, "Clevels", 0, 0, &v43, 1, 1, 1) & 1) == 0)
    {
      *(_QWORD *)&v46 = 0;
      *(_OWORD *)v44 = 0u;
      v45 = 0u;
      kdu_error::kdu_error((kdu_error *)v44, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v44 + 16))(v44, "Corrupt JP2 file: no levels ");
      kdu_error::~kdu_error((kdu_error *)v44);
    }
  }
  else
  {
    kdu_params::set(this, "Cads", 0, 0, 0);
    if ((*((_DWORD *)this + 4) & 0x80000000) != 0)
      kdu_params::set(this, "Cdfs", 0, 0, 0);
    kdu_params::set(this, "Clevels", 0, 0, (int *)v43);
  }
  if (v9 - v20 <= 0
    || (kdu_params::set(this, "Cblk", 0, 1, (int *)(4 << v14[1])), v20 = v14 + 2, v9 - (v14 + 2) <= 0)
    || (kdu_params::set(this, "Cblk", 0, 0, (int *)(4 << v14[2])), v20 = v14 + 3, v9 - (v14 + 3) <= 0))
  {
    v33 = __cxa_allocate_exception(8uLL);
    *v33 = v20;
    goto LABEL_61;
  }
  kdu_params::set(this, "Cmodes", 0, 0, (int *)v14[3]);
  if (v9 - (v14 + 4) <= 0)
  {
    v34 = __cxa_allocate_exception(8uLL);
    *v34 = v14 + 4;
    __cxa_throw(v34, MEMORY[0x1E0DE4E60], 0);
  }
  v23 = v14[4];
  if (v23 < 2)
  {
    kdu_params::set(this, "Catk", 0, 0, 0);
    kdu_params::set((uint64_t)this, "Creversible", 0, 0, v23 == 1);
    v24 = v23 == 1;
  }
  else
  {
    kdu_params::set(this, "Catk", 0, 0, (int *)v14[4]);
    v24 = 0xFFFFFFFFLL;
  }
  kdu_params::set(this, "Ckernels", 0, 0, (int *)v24);
  v25 = v14 + 5;
  v26 = v43;
  if (v43 >= 0)
    v27 = v16;
  else
    v27 = 0;
  if (v27 == 1)
  {
    v28 = 0;
    v29 = (unsigned __int8 *)(&a4[a3] - v14 - 5);
    v30 = -1;
    do
    {
      if ((uint64_t)v29 <= 0)
      {
        v32 = __cxa_allocate_exception(8uLL);
        *v32 = v25;
        __cxa_throw(v32, MEMORY[0x1E0DE4E60], 0);
      }
      v31 = *v25++;
      kdu_params::set(this, "Cprecincts", v26 + v28, 0, (int *)(1 << (v31 >> 4)));
      kdu_params::set(this, "Cprecincts", v28 + v43, 1, (int *)(1 << (v31 & 0xF)));
      v26 = v43;
      ++v30;
      --v28;
      --v29;
    }
    while (v30 < v43);
  }
  if (v25 != v9)
  {
    v42 = 0;
    v40 = 0u;
    v41 = 0u;
    kdu_error::kdu_error((kdu_error *)&v40, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v40 + 16))(&v40, "Malformed COD/COC marker segment encountered. The final ");
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    *(_OWORD *)v44 = 0u;
    if (BYTE8(v40))
      sprintf(v44, "%x");
    else
      sprintf(v44, "%d");
    (*(void (**)(__int128 *, char *))(v40 + 16))(&v40, v44);
    (*(void (**)(__int128 *, const char *))(v40 + 16))(&v40, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)&v40);
  }
  return 1;
}

void sub_187F3CA20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F3CA30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, __int128 a12, uint64_t a13, uint64_t a14, __int128 a15, __int128 a16, uint64_t a17)
{
  int v17;
  _Unwind_Exception *v18;

  if (v17 == 1)
  {
    __cxa_begin_catch(v18);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(a11 + 16))(&a11, "Malformed COD/COC marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(v18);
}

uint64_t cod_params::finalize(cod_params *this, int a2)
{
  char v4;
  char v5;
  int v6;
  BOOL v7;
  BOOL v8;
  char v9;
  int *suitable_dfs_idx;
  int *suitable_ads_idx;
  int v12;
  int v13;
  kdu_params *v14;
  uint64_t v15;
  int v16;
  kdu_params *v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  char v24;
  int v25;
  char v26;
  char v27;
  char v28;
  char v29;
  char v30;
  int v31;
  char v32;
  int v33;
  int v34;
  int v35;
  int v36;
  char v37;
  char v38;
  kdu_params *v39;
  kdu_params *v40;
  char v41;
  char v42;
  uint64_t result;
  int v44;
  kdu_params *v45;
  int v46;
  int v47;
  int v48;
  _BOOL4 v49;
  int v50;
  kdu_params *v51;
  BOOL v52[8];
  BOOL v53;
  BOOL v54;
  int v55;
  int v56;
  BOOL v57;
  int v58[4];
  __int128 v59;
  uint64_t v60;
  BOOL v61;
  int v62[2];
  int v63[2];
  char v64[16];
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v62 = 0;
  *(_QWORD *)v63 = 0;
  v61 = 0;
  if ((a2 & 1) == 0)
  {
    if ((kdu_params::get(this, "Clayers", 0, 0, &v63[1], 1, 1, 1) & 1) != 0)
    {
      if (v63[1] > 0x4000)
      {
        v60 = 0;
        *(_OWORD *)v58 = 0u;
        v59 = 0u;
        kdu_error::kdu_error((kdu_error *)v58, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v58 + 16))(v58, "Illegal number of quality layers, ");
        v67 = 0u;
        v68 = 0u;
        v65 = 0u;
        v66 = 0u;
        *(_OWORD *)v64 = 0u;
        if (LOBYTE(v58[2]))
          sprintf(v64, "%x");
        else
          sprintf(v64, "%d");
        (*(void (**)(int *, char *))(*(_QWORD *)v58 + 16))(v58, v64);
        (*(void (**)(int *, const char *))(*(_QWORD *)v58 + 16))(v58, ", detected by coding parameter sub-system; legal code-streams may have no more than 16384 quality layers.");
        kdu_error::~kdu_error((kdu_error *)v58);
      }
    }
    else
    {
      kdu_params::set(this, "Clayers", 0, 0, (int *)1);
    }
    if ((kdu_params::get(this, "Cuse_sop", 0, 0, &v63[1], 1, 1, 1) & 1) == 0)
      kdu_params::set(this, "Cuse_sop", 0, 0, 0);
    if ((kdu_params::get(this, "Cuse_eph", 0, 0, &v63[1], 1, 1, 1) & 1) == 0)
      kdu_params::set(this, "Cuse_eph", 0, 0, 0);
    if ((kdu_params::get(this, "Corder", 0, 0, &v63[1], 1, 1, 1) & 1) == 0)
      kdu_params::set(this, "Corder", 0, 0, 0);
    if ((kdu_params::get(this, "Calign_blk_last", 0, 0, &v63[1], 1, 1, 1) & 1) == 0)
    {
      if (kdu_params::get(this, "Calign_blk_last", 0, 1, &v63[1], 1, 1, 1))
        cod_params::finalize();
      kdu_params::set(this, "Calign_blk_last", 0, 0, 0);
      kdu_params::set(this, "Calign_blk_last", 0, 1, 0);
    }
    if ((kdu_params::get(this, "Clevels", 0, 0, &v63[1], 1, 1, 1) & 1) != 0)
    {
      if (v63[1] >= 33)
      {
        v60 = 0;
        *(_OWORD *)v58 = 0u;
        v59 = 0u;
        kdu_error::kdu_error((kdu_error *)v58, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v58 + 16))(v58, "Illegal number of DWT levels, ");
        v67 = 0u;
        v68 = 0u;
        v65 = 0u;
        v66 = 0u;
        *(_OWORD *)v64 = 0u;
        if (LOBYTE(v58[2]))
          sprintf(v64, "%x");
        else
          sprintf(v64, "%d");
        (*(void (**)(int *, char *))(*(_QWORD *)v58 + 16))(v58, v64);
        (*(void (**)(int *, const char *))(*(_QWORD *)v58 + 16))(v58, ", detected by coding parameter sub-system; legal code-streams may have no more than 32 DWT levels in any given"
          " tile-component.");
        kdu_error::~kdu_error((kdu_error *)v58);
      }
    }
    else
    {
      kdu_params::set(this, "Clevels", 0, 0, (int *)5);
    }
    if (kdu_params::get(this, "Cdecomp", 0, 0, v62, 0, 0, 1))
    {
      v4 = 0;
      v5 = 0;
      v6 = 1;
      do
      {
        v7 = (~v62[0] & 3) != 0;
        v8 = v62[0] > 3u;
        v9 = kdu_params::get(this, "Cdecomp", v6, 0, v62, 0, 0, 1);
        v5 |= v7;
        v4 |= v8;
        ++v6;
      }
      while ((v9 & 1) != 0);
      if ((v5 & 1) != 0)
      {
        if ((kdu_params::get(this, "Cdfs", 0, 0, &v62[1], 0, 1, 1) & 1) == 0)
        {
          suitable_dfs_idx = (int *)cod_params::find_suitable_dfs_idx(this);
          v62[1] = (int)suitable_dfs_idx;
          kdu_params::set(this, "Cdfs", 0, 0, suitable_dfs_idx);
          if ((v4 & 1) == 0)
          {
LABEL_31:
            suitable_ads_idx = 0;
LABEL_36:
            v63[0] = (int)suitable_ads_idx;
            kdu_params::set(this, "Cads", 0, 0, suitable_ads_idx);
            goto LABEL_37;
          }
LABEL_34:
          if ((kdu_params::get(this, "Cads", 0, 0, v63, 0, 1, 1) & 1) != 0)
            goto LABEL_37;
          suitable_ads_idx = (int *)cod_params::find_suitable_ads_idx(this);
          goto LABEL_36;
        }
      }
      else
      {
        v62[1] = 0;
        kdu_params::set(this, "Cdfs", 0, 0, 0);
      }
      if ((v4 & 1) == 0)
        goto LABEL_31;
      goto LABEL_34;
    }
  }
LABEL_37:
  if ((kdu_params::get(this, "Cads", 0, 0, v63, 1, 1, 1) & 1) == 0)
    v63[0] = 0;
  if (kdu_params::get(this, "Cdfs", 0, 0, &v62[1], 1, 1, 1))
  {
    v12 = v62[1];
  }
  else
  {
    v12 = 0;
    v62[1] = 0;
  }
  v13 = v63[0];
  if (v63[0] | v12 && a2)
  {
    if (v63[0] < 1)
    {
      v15 = 0;
    }
    else
    {
      v14 = (kdu_params *)kdu_params::access_cluster(this, "ADS");
      if (!v14 || (v15 = kdu_params::access_relation(v14, *((_DWORD *)this + 4), -1, v13, 1)) == 0)
      {
        *(_QWORD *)&v66 = 0;
        *(_OWORD *)v64 = 0u;
        v65 = 0u;
        kdu_error::kdu_error((kdu_error *)v64, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v64 + 16))(v64, "ADS table index encountered while finalizing COD/COD marker segment information does not refer to accessible ADS (Arbitrary Decomposition Styles) information.");
        kdu_error::~kdu_error((kdu_error *)v64);
      }
    }
    v16 = v62[1];
    if (v62[1] < 1)
    {
      v18 = 0;
    }
    else
    {
      v17 = (kdu_params *)kdu_params::access_cluster(this, "DFS");
      if (!v17 || (v18 = kdu_params::access_relation(v17, -1, -1, v16, 1)) == 0)
      {
        *(_QWORD *)&v66 = 0;
        *(_OWORD *)v64 = 0u;
        v65 = 0u;
        kdu_error::kdu_error((kdu_error *)v64, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v64 + 16))(v64, "DFS table index encountered while finalizing COD/COD marker segment information does not refer to accessible DFS (Downsampling Factor Styles) information.");
        kdu_error::~kdu_error((kdu_error *)v64);
      }
    }
    if ((*((_DWORD *)this + 5) & 0x80000000) != 0)
    {
      if (v15)
      {
        v33 = *((_DWORD *)this + 4);
        if ((v33 & 0x80000000) == 0)
        {
          v34 = *((_DWORD *)this + 8);
          if (v34 < 1)
          {
            v35 = 0;
          }
          else
          {
            v35 = 0;
            while (kdu_params::access_unique(this, v33, v35, 0))
            {
              if (v34 == ++v35)
                goto LABEL_185;
            }
          }
          if (v35 == v34)
          {
LABEL_185:
            v15 = 0;
            v18 = 0;
            v62[1] = 0;
            v63[0] = 0;
          }
        }
      }
    }
    if (v15 | v18)
      cod_params::derive_decomposition_structure(this, (kdu_params *)v18, (kdu_params *)v15);
  }
  if ((kdu_params::get(this, "Cdecomp", 0, 0, v62, 1, 1, 1) & 1) == 0)
  {
    v62[0] = 3;
    kdu_params::set(this, "Cdecomp", 0, 0, (int *)3);
  }
  if ((a2 & 1) == 0)
  {
    if ((kdu_params::get(this, "Cads", 0, 0, v63, 1, 1, 1) & 1) == 0)
    {
      v63[0] = 0;
      kdu_params::set(this, "Cads", 0, 0, 0);
    }
    if ((kdu_params::get(this, "Cdfs", 0, 0, &v62[1], 1, 1, 1) & 1) == 0)
    {
      v62[1] = 0;
      kdu_params::set(this, "Cdfs", 0, 0, 0);
    }
  }
  if (v62[1] >= 1)
    cod_params::validate_dfs_data((uint64_t)this, v62[1]);
  if ((*((_DWORD *)this + 4) & 0x80000000) == 0 && v63[0] >= 1)
    cod_params::validate_ads_data((uint64_t)this, v63[0]);
  if ((a2 & 1) == 0)
  {
    v19 = *((_DWORD *)this + 4);
    if ((*((_DWORD *)this + 5) & 0x80000000) != 0 && v19 < 0 && v62[1] >= 1 && *((int *)this + 8) >= 1)
    {
      v36 = 0;
      do
        kdu_params::access_relation(this, -1, v36++, 0, 0);
      while (v36 < *((_DWORD *)this + 8));
      v19 = *((_DWORD *)this + 4);
    }
    if (v19 < 0 && v63[0] >= 1 && *((int *)this + 7) >= 1)
    {
      v20 = 0;
      do
        kdu_params::access_relation(this, v20++, *((_DWORD *)this + 5), 0, 0);
      while (v20 < *((_DWORD *)this + 7));
    }
  }
  v57 = 1;
  v55 = 0;
  v56 = 0;
  if ((kdu_params::get(this, "Catk", 0, 0, &v55, 1, 1, 1) & 1) == 0)
  {
    v55 = 0;
    kdu_params::set(this, "Catk", 0, 0, 0);
  }
  v21 = kdu_params::get(this, "Catk", 0, 0, &v55, 0, 1, 1);
  if (v55)
    v22 = v21;
  else
    v22 = 0;
  v23 = kdu_params::get(this, "Ckernels", 0, 0, &v56, 0, 1, 1);
  if (v22)
  {
    if (v56 == -1)
      v24 = v23;
    else
      v24 = 0;
    if ((v24 & 1) == 0)
    {
      v56 = -1;
      kdu_params::set(this, "Ckernels", 0, 0, (int *)0xFFFFFFFFLL);
    }
    goto LABEL_129;
  }
  if (v56 == -1)
    v25 = 0;
  else
    v25 = v23;
  if (v25 == 1)
  {
    v26 = kdu_params::get(this, "Catk", 0, 0, &v55, 0, 1, 1);
    if (v55)
      v27 = 0;
    else
      v27 = v26;
    if ((v27 & 1) == 0)
    {
      v55 = 0;
      kdu_params::set(this, "Catk", 0, 0, 0);
    }
    if (v56)
    {
      if (v56 != 1)
        cod_params::finalize();
      v28 = kdu_params::get(this, "Creversible", 0, 0, &v57, 0, 1, 1);
      if (v57)
        v29 = v28;
      else
        v29 = 0;
      if ((v29 & 1) == 0)
      {
        v57 = 1;
        kdu_params::set((uint64_t)this, "Creversible", 0, 0, 1);
      }
    }
    else
    {
      v37 = kdu_params::get(this, "Creversible", 0, 0, &v57, 0, 1, 1);
      if (v57)
        v38 = 0;
      else
        v38 = v37;
      if ((v38 & 1) == 0)
      {
        v57 = 0;
        kdu_params::set((uint64_t)this, "Creversible", 0, 0, 0);
      }
    }
    goto LABEL_129;
  }
  if (!kdu_params::get(this, "Creversible", 0, 0, &v57, 0, 1, 1))
    goto LABEL_129;
  v30 = kdu_params::get(this, "Catk", 0, 0, &v55, 1, 1, 1);
  v31 = v55;
  if (v55)
    v32 = v30;
  else
    v32 = 0;
  if ((v32 & 1) == 0)
  {
    if ((kdu_params::get(this, "Ckernels", 0, 0, &v56, 1, 1, 1) & 1) == 0 || v56 != v57)
    {
      v56 = v57;
      kdu_params::set(this, "Ckernels", 0, 0, (int *)v57);
    }
LABEL_129:
    v31 = v55;
    if (!v55)
      goto LABEL_142;
  }
  v52[4] = 0;
  v39 = (kdu_params *)kdu_params::access_cluster(this, "ATK");
  if (!v39
    || (v40 = (kdu_params *)kdu_params::access_relation(v39, *((_DWORD *)this + 4), -1, v31, 1)) == 0
    || (kdu_params::get(v40, "Kreversible", 0, 0, &v52[4], 1, 1, 1) & 1) == 0)
  {
    v60 = 0;
    *(_OWORD *)v58 = 0u;
    v59 = 0u;
    kdu_error::kdu_error((kdu_error *)v58, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v58 + 16))(v58, " ");
    v67 = 0u;
    v68 = 0u;
    v65 = 0u;
    v66 = 0u;
    *(_OWORD *)v64 = 0u;
    if (LOBYTE(v58[2]))
      sprintf(v64, "%x");
    else
      sprintf(v64, "%d");
    (*(void (**)(int *, char *))(*(_QWORD *)v58 + 16))(v58, v64);
    kdu_error::~kdu_error((kdu_error *)v58);
  }
  v41 = kdu_params::get(this, "Creversible", 0, 0, &v57, 0, 1, 1);
  if (v57 == v52[4])
    v42 = v41;
  else
    v42 = 0;
  if ((v42 & 1) == 0)
  {
    v57 = v52[4];
    kdu_params::set((uint64_t)this, "Creversible", 0, 0, v52[4]);
  }
LABEL_142:
  if (((kdu_params::get(this, "Creversible", 0, 0, &v57, 1, 1, 1) | a2) & 1) == 0)
  {
    v57 = 0;
    kdu_params::set((uint64_t)this, "Creversible", 0, 0, 0);
  }
  result = kdu_params::get(this, "Ckernels", 0, 0, &v56, 1, 1, 1);
  if (((result | a2) & 1) == 0)
  {
    v56 = 0;
    result = (uint64_t)kdu_params::set(this, "Ckernels", 0, 0, 0);
  }
  if (v55)
  {
    if ((v55 - 256) <= 0xFFFFFF01)
    {
      *(_QWORD *)&v66 = 0;
      *(_OWORD *)v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)v64, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v64 + 16))(v64, "Illegal ATK instance index found when finalizing a COD/COC marker segment.  Legal values are in the range 2 to 255.");
      kdu_error::~kdu_error((kdu_error *)v64);
    }
  }
  else if (v56 != v57)
  {
    *(_QWORD *)&v66 = 0;
    *(_OWORD *)v64 = 0u;
    v65 = 0u;
    kdu_error::kdu_error((kdu_error *)v64, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v64);
  }
  if ((a2 & 1) == 0)
  {
    if ((kdu_params::get(this, "Cblk", 0, 0, &v63[1], 1, 1, 1) & 1) == 0)
    {
      if (kdu_params::get(this, "Cblk", 0, 1, &v63[1], 1, 1, 1))
        cod_params::finalize();
      kdu_params::set(this, "Cblk", 0, 0, (int *)0x40);
      kdu_params::set(this, "Cblk", 0, 1, (int *)0x40);
    }
    if ((kdu_params::get(this, "Cmodes", 0, 0, &v63[1], 1, 1, 1) & 1) == 0)
      kdu_params::set(this, "Cmodes", 0, 0, 0);
    v54 = 0;
    if ((kdu_params::get(this, "Cycc", 0, 0, &v54, 1, 1, 1) & 1) == 0)
    {
      if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
        cod_params::finalize();
      v44 = *((_DWORD *)this + 8);
      v54 = 0;
      v45 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
      *(_DWORD *)v64 = 0;
      kdu_params::get(v45, "Mcomponents", 0, 0, (int *)v64, 1, 1, 1);
      if (v44 >= 3 && !*(_DWORD *)v64)
      {
        v58[0] = 0;
        v53 = 0;
        *(_QWORD *)v52 = 0;
        if (!v45)
          cod_params::finalize();
        v46 = 0;
        v47 = 0;
        v48 = 0;
        v49 = 0;
        v50 = 0;
        while (1)
        {
          v51 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), v46, 0, 1);
          if (!kdu_params::get(v51, "Creversible", 0, 0, &v53, 1, 1, 1)
            || !kdu_params::get(v45, "Sprecision", v46, 0, v58, 1, 1, 1)
            || !kdu_params::get(v45, "Ssampling", v46, 0, (int *)v52, 1, 1, 1)
            || (kdu_params::get(v45, "Ssampling", v46, 1, (int *)&v52[4], 1, 1, 1) & 1) == 0)
          {
            cod_params::finalize();
          }
          if (v46 && (v49 != v53 || v58[0] != v50 || *(_DWORD *)&v52[4] != v48 || *(_DWORD *)v52 != v47))
            break;
          ++v46;
          v47 = *(_DWORD *)v52;
          v48 = *(_DWORD *)&v52[4];
          v49 = v53;
          v50 = v58[0];
          if (v46 == 3)
          {
            v54 = 1;
            break;
          }
        }
      }
      kdu_params::set((uint64_t)this, "Cycc", 0, 0, v54);
    }
    if (v54 && *((int *)this + 8) <= 2)
      kdu_params::set((uint64_t)this, "Cycc", 0, 0, 0);
    if (kdu_params::get(this, "Cprecincts", 0, 0, &v63[1], 0, 0, 1))
      kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, 1);
    result = kdu_params::get(this, "Cuse_precincts", 0, 0, &v61, 1, 1, 1);
    if ((result & 1) == 0)
      return kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, 0);
  }
  return result;
}

void sub_187F3DE64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F3DE70(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Exception *v21;

  _Unwind_Resume(v21);
}

uint64_t cod_params::find_suitable_dfs_idx(cod_params *this)
{
  int v2;
  kdu_params *v3;
  uint64_t v4;
  int v5;
  int v6;
  kdu_params *v7;
  kdu_params *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  kdu_params *v13;
  int v15;
  int v16[4];
  __int128 v17;
  uint64_t v18;
  int v19;

  v19 = 0;
  v2 = *((_DWORD *)this + 5);
  if ((*((_DWORD *)this + 4) & 0x80000000) != 0)
  {
    v5 = 0;
    if (v2 < 0)
    {
LABEL_14:
      v4 = (v5 + 1);
      v19 = v5 + 1;
      v13 = (kdu_params *)kdu_params::access_cluster(this, "DFS");
      if (!v13)
        return v4;
      kdu_params::access_relation(v13, -1, -1, v5 + 1, 0);
    }
    else
    {
      v6 = -1;
      while (1)
      {
        v7 = (kdu_params *)kdu_params::access_unique(this, -1, v6, 0);
        if (v7)
        {
          v8 = v7;
          if (kdu_params::get(v7, "Cdfs", 0, 0, &v19, 1, 1, 1))
          {
            v9 = v19;
            if (v19)
            {
              v10 = 0;
              v15 = 3;
              v16[0] = 3;
              do
              {
                v11 = kdu_params::get(this, "Cdecomp", v10, 0, v16, 0, 0, 1);
                v12 = kdu_params::get(v8, "Cdecomp", v10, 0, &v15, 0, 0, 1);
                if (((v15 ^ LOBYTE(v16[0])) & 3) != 0)
                  break;
                ++v10;
              }
              while (((v11 | v12) & 1) != 0);
              v5 = v9;
              if (((v15 ^ LOBYTE(v16[0])) & 3) == 0)
                break;
            }
          }
        }
        if (++v6 >= *((_DWORD *)this + 5))
          goto LABEL_14;
      }
    }
    return v19;
  }
  v3 = (kdu_params *)kdu_params::access_relation(this, -1, v2, 0, 0);
  kdu_params::get(v3, "Cdfs", 0, 0, &v19, 1, 1, 1);
  v4 = v19;
  if (!v19)
  {
    v18 = 0;
    *(_OWORD *)v16 = 0u;
    v17 = 0u;
    kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v16);
  }
  return v4;
}

void sub_187F3E0E8(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F3E0F4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t cod_params::find_suitable_ads_idx(cod_params *this)
{
  kdu_params *v2;
  int v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  kdu_params *v13;
  int v15;
  int v16;
  int v17;

  v2 = (kdu_params *)kdu_params::access_cluster(this, "ADS");
  v17 = 0;
  v3 = *((_DWORD *)this + 4);
  v4 = kdu_params::access_unique(v2, v3, -1, 0);
  v5 = v4 != 0;
  LODWORD(v6) = 0;
  if (v4)
    v7 = v4;
  else
    v7 = (uint64_t)v2;
  if (v7)
  {
    while (1)
    {
      v8 = *(unsigned int *)(v7 + 24);
      if (((kdu_params::get((kdu_params *)v7, "Ddecomp", 0, 0, &v17, 1, 1, 1) & 1) != 0
         || (kdu_params::get((kdu_params *)v7, "DOads", 0, 0, &v17, 1, 1, 1) & 1) != 0
         || kdu_params::get((kdu_params *)v7, "DSads", 0, 0, &v17, 1, 1, 1))
        && (int)v8 > (int)v6)
      {
        v9 = 0;
        v6 = v8;
        v15 = 3;
        v16 = 3;
        do
        {
          v10 = kdu_params::get(this, "Cdecomp", v9, 0, &v16, 0, 0, 1);
          v11 = kdu_params::get((kdu_params *)v7, "Ddecomp", v9, 0, &v15, 0, 0, 1);
          if (v16 != v15)
            break;
          ++v9;
        }
        while (((v10 | v11) & 1) != 0);
        if (v16 == v15)
          break;
      }
      v12 = *(_QWORD *)(v7 + 88);
      if ((v5 & 1) != 0)
        v13 = v2;
      else
        v13 = 0;
      if (v12)
        v7 = *(_QWORD *)(v7 + 88);
      else
        v7 = (uint64_t)v13;
      v5 &= v12 != 0;
      if (!v7)
      {
        v3 = *((_DWORD *)this + 4);
        goto LABEL_21;
      }
    }
  }
  else
  {
LABEL_21:
    v6 = (v6 + 1);
    kdu_params::access_relation(v2, v3, -1, v6, 0);
  }
  return v6;
}

uint64_t cod_params::derive_decomposition_structure(cod_params *this, kdu_params *a2, kdu_params *a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  char v21;
  uint64_t result;
  int v23;
  kdu_params *v24;
  cod_params *v25;
  int v26;
  char v27;
  char v28;
  int v29;
  int v30;
  int v31;
  int v32;

  v32 = 0;
  if (a3)
  {
    LOBYTE(v6) = 1;
    v30 = 3;
    v31 = 1;
    v29 = 0;
    v7 = kdu_params::get(a3, "DOads", 0, 0, &v31, 1, 0, 1) ^ 1;
    v8 = kdu_params::get(a3, "DSads", 0, 0, &v29, 1, 0, 1) ^ 1;
    v24 = a2;
    if (a2)
      v6 = kdu_params::get(a2, "DSdfs", 0, 0, &v30, 1, 0, 1) ^ 1;
    v9 = 0;
    v10 = 1;
    v25 = this;
    while (1)
    {
      v11 = (int *)(v30 & 3);
      v27 = v7;
      v28 = v6;
      v26 = v9;
      if (((_DWORD)v11 - 1) < 2)
        break;
      if ((v30 & 3) != 0)
      {
        v12 = 2;
LABEL_9:
        v13 = 10 * v12 + 2;
        do
        {
          v14 = v31;
          if (v31 != 1)
          {
            v15 = v29;
            if ((v8 & 1) != 0)
            {
              LOBYTE(v8) = 1;
            }
            else
            {
              v8 = kdu_params::get(a3, "DSads", v10, 0, &v29, 1, 0, 1) ^ 1;
              v14 = v31;
              ++v10;
            }
            v11 = (int *)(v11 | (v15 << (10 * v12 + 2)));
            if (v15)
            {
              if (v14 != 2)
              {
                if (v15 == 3)
                  v16 = 4;
                else
                  v16 = 2;
                v17 = v16 | 1;
                v18 = v13 + 2 * v16;
                do
                {
                  v19 = v29;
                  if ((v8 & 1) != 0)
                    LOBYTE(v8) = 1;
                  else
                    v8 = kdu_params::get(a3, "DSads", v10++, 0, &v29, 1, 0, 1) ^ 1;
                  v11 = (int *)(v11 | (v19 << v18));
                  --v17;
                  v18 -= 2;
                }
                while (v17 > 1);
              }
            }
          }
          v13 -= 10;
        }
        while (v12-- > 0);
      }
      kdu_params::set(v25, "Cdecomp", v26, 0, v11);
      v9 = v26 + 1;
      if ((v28 & 1) != 0)
        v6 = 1;
      else
        v6 = kdu_params::get(v24, "DSdfs", v9, 0, &v30, 1, 0, 1) ^ 1;
      if ((v27 & 1) != 0)
        v7 = 1;
      else
        v7 = kdu_params::get(a3, "DOads", v9, 0, &v31, 1, 0, 1) ^ 1;
      if (v31 < 2)
        v21 = v7;
      else
        v21 = 0;
      LOBYTE(v8) = v21 | v8;
      if ((v6 & v7) == 1 && (v8 & 1) != 0)
      {
        result = cod_params::is_valid_decomp_terminator((cod_params *)v11);
        if ((_DWORD)result)
          return result;
      }
    }
    v12 = 0;
    goto LABEL_9;
  }
  if (!a2)
    cod_params::derive_decomposition_structure();
  result = kdu_params::get(a2, "DSdfs", 0, 0, &v32, 1, 0, 1);
  if ((_DWORD)result)
  {
    v23 = 0;
    do
    {
      kdu_params::set(this, "Cdecomp", v23++, 0, (int *)v32);
      result = kdu_params::get(a2, "DSdfs", v23, 0, &v32, 1, 0, 1);
    }
    while ((result & 1) != 0);
  }
  return result;
}

uint64_t cod_params::validate_dfs_data(uint64_t this, int a2)
{
  kdu_params *v3;
  kdu_params *v4;
  kdu_params *v5;
  kdu_params *v6;
  char v7;
  int v8;
  int v9;
  int v10;
  int v11[8];
  uint64_t v12;
  int v13;

  if (a2)
  {
    v3 = (kdu_params *)this;
    v4 = (kdu_params *)kdu_params::access_cluster((kdu_params *)this, "DFS");
    if (!v4 || (v5 = (kdu_params *)kdu_params::access_relation(v4, -1, -1, a2, 1)) == 0)
      cod_params::validate_dfs_data();
    v6 = v5;
    v13 = 0;
    v7 = kdu_params::get(v5, "DSdfs", 0, 0, &v13, 1, 1, 1);
    this = kdu_params::get(v3, "Cdecomp", 0, 0, &v13, 1, 0, 1);
    if ((_DWORD)this)
    {
      v8 = 1;
      do
      {
        v9 = v8 - 1;
        v10 = v13 & 3;
        if ((v7 & 1) != 0)
        {
          v11[0] = 0;
          if (!kdu_params::get(v6, "DSdfs", v9, 0, v11, 1, 1, 1) || v11[0] != v10)
          {
            v12 = 0;
            memset(v11, 0, sizeof(v11));
            kdu_error::kdu_error((kdu_error *)v11, "Kakadu Core Error:\n");
            kdu_error::~kdu_error((kdu_error *)v11);
          }
        }
        else
        {
          kdu_params::set(v6, "DSdfs", v9, 0, (int *)(v13 & 3));
        }
        this = kdu_params::get(v3, "Cdecomp", v8++, 0, &v13, 1, 0, 1);
      }
      while ((this & 1) != 0);
    }
  }
  return this;
}

void sub_187F3E820(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F3E82C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t cod_params::validate_ads_data(uint64_t this, int a2)
{
  int *v3;
  kdu_params *v4;
  kdu_params *v5;
  kdu_params *v6;
  char v7;
  int v8;
  int v9;
  int v10;
  int v11;
  char v12;
  char v13;
  char *v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  int v18[3];
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = (int *)this;
    v4 = (kdu_params *)kdu_params::access_cluster((kdu_params *)this, "ADS");
    if (!v4 || (v5 = (kdu_params *)kdu_params::access_relation(v4, v3[4], -1, a2, 1)) == 0)
      cod_params::validate_ads_data();
    v6 = v5;
    v18[0] = 0;
    v7 = kdu_params::get(v5, "Ddecomp", 0, 0, v18, 1, 1, 1);
    this = kdu_params::get((kdu_params *)v3, "Cdecomp", 0, 0, v18, 1, 0, 1);
    v8 = this;
    if ((_DWORD)this)
    {
      v9 = 1;
      do
      {
        v10 = v9 - 1;
        v11 = v18[0];
        if ((v7 & 1) != 0)
        {
          LODWORD(v15) = 0;
          v12 = kdu_params::get(v6, "Ddecomp", v10, 0, (int *)&v15, 1, 1, 1);
          if ((_DWORD)v15 == v11)
            v13 = v12;
          else
            v13 = 0;
          if ((v13 & 1) == 0)
          {
            v17 = 0;
            v15 = 0u;
            v16 = 0u;
            kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "Unacceptable interaction between ADS (Arbitrary Decomposition Style) and DFS (Downsampling Factor Styles) information in Part-2 codestream.  It makes no sense to use the same ADS table for two tile-components which have different downsampling factor styles, since downsampling styles have a strong effect on the interpretation of information recorded in the ADS marker segment.");
            kdu_error::~kdu_error((kdu_error *)&v15);
          }
        }
        else
        {
          kdu_params::set(v6, "Ddecomp", v10, 0, (int *)v18[0]);
        }
        this = kdu_params::get((kdu_params *)v3, "Cdecomp", v9++, 0, v18, 1, 0, 1);
      }
      while ((this & 1) != 0);
      if (v8)
      {
        v14 = (char *)v18[0];
        this = cod_params::is_valid_decomp_terminator((cod_params *)v18[0]);
        if ((this & 1) == 0)
        {
          *(_QWORD *)&v18[1] = 0;
          v19[0] = 0;
          *(_QWORD *)((char *)v19 + 5) = 0;
          cod_params::textualize_decomp((cod_params *)&v18[1], v14);
          v17 = 0;
          v15 = 0u;
          v16 = 0u;
          kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, ", \"");
          (*(void (**)(__int128 *, int *))(v15 + 16))(&v15, &v18[1]);
          (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "\".  ");
          kdu_error::~kdu_error((kdu_error *)&v15);
        }
      }
    }
  }
  return this;
}

void sub_187F3EADC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F3EAE8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL cod_params::is_valid_decomp_terminator(cod_params *this)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;

  if ((~(_DWORD)this & 3) != 0
    || (v1 = 0, v2 = (this >> 2) & 0x3FF, v2 == ((this >> 12) & 0x3FF))
    && v2 == this >> 22)
  {
    if (!(this >> 4))
      return 1;
    v3 = (this >> 2) & 3;
    if (v3 == 3)
    {
      if ((this >> 4) == 255)
        return 1;
    }
    else
    {
      if (v3 != 2)
        return v3 != 1 || (this & 0xF0) == 0x50;
      if ((this & 0xF0) == 0xC0)
        return 1;
    }
    return 0;
  }
  return v1;
}

void cod_params::textualize_decomp(cod_params *this, char *a2)
{
  __asm { BR              X11 }
}

_WORD *sub_187F3EBC8(_WORD *result)
{
  *result = 10285;
  result[1] = 41;
  return result;
}

uint64_t cod_params::custom_textualize_field(cod_params *this, kdu_message *a2, const char *__s1, int a4, char *a5)
{
  uint64_t result;
  uint64_t v9;
  _QWORD v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  result = strcmp(__s1, "Cdecomp");
  if (!(result | a4))
  {
    v9 = 0;
    v10[0] = 0;
    *(_QWORD *)((char *)v10 + 5) = 0;
    cod_params::textualize_decomp((cod_params *)&v9, a5);
    return (*(uint64_t (**)(kdu_message *, uint64_t *))(*(_QWORD *)a2 + 16))(a2, &v9);
  }
  return result;
}

uint64_t cod_params::custom_parse_field(cod_params *this, const char *a2, const char *__s1, int a4, int *a5)
{
  uint64_t result;
  int v8;
  int v9;
  int v10;
  const char *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  BOOL v22;
  uint64_t v23;

  if (strcmp(__s1, "Cdecomp") | a4)
    goto LABEL_2;
  v8 = *a2;
  if (v8 <= 71)
  {
    if (v8 == 45)
    {
      *a5 = 0;
      if (a2[1] == 40)
      {
        v11 = a2 + 2;
        goto LABEL_39;
      }
      goto LABEL_2;
    }
    if (v8 == 66)
    {
      v9 = 3;
      v10 = 3;
      goto LABEL_13;
    }
LABEL_2:
    result = 0;
    *a5 = 0;
    return result;
  }
  if (v8 == 72)
  {
    v9 = 1;
    v10 = 1;
  }
  else
  {
    if (v8 != 86)
      goto LABEL_2;
    v10 = 1;
    v9 = 2;
  }
LABEL_13:
  *a5 = v9;
  if (a2[1] != 40)
    goto LABEL_2;
  v12 = 0;
  v11 = a2 + 2;
  do
  {
    if (v12)
    {
      v13 = *(unsigned __int8 *)v11;
      if (v13 != 44 && v13 != 58)
        goto LABEL_2;
      ++v11;
    }
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 1;
    do
    {
      v18 = v11[v15];
      switch(v18)
      {
        case '-':
          v19 = 0;
          v20 = 0;
          if ((_DWORD)v15)
            goto LABEL_37;
LABEL_31:
          v21 = v11[v15 + 1];
          v22 = v21 > 0x3A;
          v23 = (1 << v21) & 0x400120000000000;
          if (v22 || v23 == 0)
            v17 += 2 * (v18 != 45) + v19;
          goto LABEL_37;
        case 'B':
          v20 = 3;
          v19 = 2;
          if ((_DWORD)v15)
            goto LABEL_37;
          goto LABEL_31;
        case 'H':
          v19 = 0;
          v20 = 1;
          if ((_DWORD)v15)
            goto LABEL_37;
          goto LABEL_31;
      }
      if (v18 != 86)
        goto LABEL_2;
      v19 = 0;
      v20 = 2;
      if (!(_DWORD)v15)
        goto LABEL_31;
LABEL_37:
      v16 += v20 << v14;
      ++v15;
      v14 += 2;
    }
    while ((int)v15 < v17);
    v9 |= v16 << (10 * v12 + 2);
    *a5 = v9;
    ++v12;
    v11 += v15;
  }
  while (v12 != v10);
LABEL_39:
  if (*v11 != 41)
    goto LABEL_2;
  return ((_DWORD)v11 - (_DWORD)a2 + 1);
}

uint64_t cod_params::expand_decomp_bands(uint64_t this, uint64_t a2, __int16 *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  __int16 v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  BOOL v22;
  __int16 v23;

  v3 = this;
  v4 = 0;
  LODWORD(this) = 0;
  v5 = v3 & 1;
  v6 = (v3 >> 1) & 1;
  v7 = (v3 >> 2);
  while (2)
  {
    v8 = 0;
    do
    {
      if (!(v8 | v4))
      {
        v23 = v3 & 1 | ((_WORD)v6 << 8);
        v9 = v7;
LABEL_22:
        *(_WORD *)(a2 + 2 * (int)this) = v23;
        this = (this + 1);
        goto LABEL_23;
      }
      v9 = ((int)v7 >> 10);
      if ((v7 & 3) == 0)
      {
        v23 = (((_WORD)v6 << 8) | ((_WORD)v4 << 10) | v5) + 4 * v8;
        goto LABEL_22;
      }
      v10 = 0;
      v11 = v7 & 1;
      v12 = (v7 >> 1) & 1;
      v13 = (v7 & 1) + v5;
      do
      {
        v14 = 0;
        v15 = (v10 << v6) | v4;
        v16 = v7;
        do
        {
          v17 = (v14 << v5) | v8;
          LODWORD(v7) = v16 >> 2;
          if ((v16 & 0xC) != 0)
          {
            v18 = 0;
            v19 = (v16 >> 3) & 1;
            do
            {
              v20 = 0;
              v21 = this;
              do
              {
                *(_WORD *)(a2 + 2 * (int)this + 2 * v20) = (((v7 & 1) + v13) | (((_WORD)v19
                                                                                 + (_WORD)v12
                                                                                 + ((v3 >> 1) & 1)) << 8))
                                                           + (((unsigned __int16)((_WORD)v18 << (v12 + ((v3 & 2) != 0))) | (unsigned __int16)v15) << 10)
                                                           + 4 * (((_WORD)v20 << v13) | v17);
                ++v20;
              }
              while ((v7 & 1) + 1 != (_DWORD)v20);
              LODWORD(this) = this + v20;
              v22 = v18++ == v19;
            }
            while (!v22);
            this = (v21 + v20);
          }
          else
          {
            *(_WORD *)(a2 + 2 * (int)this) = ((((_WORD)v12 + (_WORD)v6) << 8) | ((_WORD)v15 << 10) | v13) + 4 * v17;
            this = (this + 1);
          }
          v16 = v7;
          v22 = v14++ == v11;
        }
        while (!v22);
        v22 = v10++ == v12;
      }
      while (!v22);
LABEL_23:
      v7 = v9;
      v22 = v8++ == v5;
    }
    while (!v22);
    v22 = v4++ == v6;
    if (!v22)
      continue;
    break;
  }
  if ((int)this >= 50)
    cod_params::expand_decomp_bands();
  return this;
}

void ads_params::ads_params(ads_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 1;
  *((_BYTE *)this + 42) = 1;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BAB6B0;
  *((_QWORD *)this + 1) = "ADS";
  kdu_params::define_attribute(this, "DOads", "Number of sub-levels in each successive DWT level, starting from the highest level.  Accesses to non-existent values are supported by repeating the last available value.  All entries must lie in the range 1 to 3.  For the meaning of sub-levels in JPEG2000 Part-2, the reader is referred to Annex F of IS 15444-2.\n\t\t[You would not normally set values for this parameter attribute yourself.]", "I", 3);
    "zontally); or 0 (do not split).  The last value is repeated as necessary, if accesses are made beyond the end of the"
    " array.  For the meaning of these splitting instructions, the reader is referred to Annex F of IS 15444-2.\n"
    "\t\t[You would not normally set values for this parameter attribute yourself.]",
    "(X=0,H=1,V=2,B=3)",
    3);
}

void sub_187F3F198(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t ads_params::finalize(uint64_t this, char a2)
{
  kdu_params *v2;
  int v3;
  int v4;
  int v5;
  char v6;
  int v7;
  int i;
  int v9;
  char v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v16;
  int v17;
  int v18;
  int v20;
  _OWORD v21[2];
  uint64_t v22;
  int v23[5];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((a2 & 1) != 0)
    return this;
  v2 = (kdu_params *)this;
  v23[0] = 0;
  this = kdu_params::get((kdu_params *)this, "Ddecomp", 0, 0, v23, 0, 0, 0);
  v20 = this;
  if (!(_DWORD)this)
    return this;
  v3 = 0;
  v4 = 0;
  do
  {
    if ((*((_DWORD *)v2 + 6) - 128) <= 0xFFFFFF80)
    {
      *(_QWORD *)&v25 = 0;
      *(_OWORD *)&v23[1] = 0u;
      v24 = 0u;
      kdu_error::kdu_error((kdu_error *)&v23[1], "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v23[1]);
    }
    if ((v23[0] & 3u) - 1 >= 2)
    {
      if ((v23[0] & 3) != 3)
      {
        v7 = 0;
        v6 = v23[0] == 0;
        v5 = -1;
        goto LABEL_12;
      }
      v5 = 2;
      v6 = 1;
    }
    else
    {
      v5 = 0;
      v6 = v23[0] < 0x1000u;
    }
    v7 = 1;
LABEL_12:
    for (i = 8; i != 38; i += 10)
    {
      v9 = (v23[0] >> (i - 6)) & 3;
      v10 = (((v23[0] >> i) & 0xF) == 0) & v6;
      if (!v9)
        v6 &= (v23[0] >> (i - 4)) == 0;
      if ((v9 - 1) < 2)
        v6 = v10;
    }
    if ((v6 & 1) == 0)
    {
      v22 = 0;
      memset(v21, 0, sizeof(v21));
      kdu_error::kdu_error((kdu_error *)v21, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v21[0] + 16))(v21, ", 0x");
      BYTE8(v21[0]) = 1;
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      *(_OWORD *)&v23[1] = 0u;
      sprintf((char *)&v23[1], "%x", v23[0]);
      (*(void (**)(_OWORD *, int *))(*(_QWORD *)&v21[0] + 16))(v21, &v23[1]);
      BYTE8(v21[0]) = 0;
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v21[0] + 16))(v21, ".");
      kdu_error::~kdu_error((kdu_error *)v21);
    }
    if (!v4)
    {
      kdu_params::delete_unparsed_attribute((uint64_t)v2, "DOads");
      kdu_params::delete_unparsed_attribute((uint64_t)v2, "DSads");
    }
    v11 = ((unsigned __int16)(v23[0] >> 2) | (unsigned __int16)(v23[0] >> 12)) & 0x3FF | (v23[0] >> 22);
    if (v11)
    {
      if (v11 < 4)
        v12 = 2;
      else
        v12 = 3;
      kdu_params::set(v2, "DOads", v4, 0, (int *)v12);
      if (v7)
      {
        v13 = v3;
        do
        {
          v14 = v23[0] >> (10 * v5 + 2);
          kdu_params::set(v2, "DSads", v13, 0, (int *)(v14 & 3));
          v3 = v13 + 1;
          if ((v14 & 3) != 0 && v11 >= 4)
          {
            if ((v14 & 3) == 3)
              v16 = 4;
            else
              v16 = 2;
            v17 = v16 + v13 + 1;
            v18 = 2 * v16;
            do
            {
              kdu_params::set(v2, "DSads", v3++, 0, (int *)(((unsigned __int16)(v14 & 0x3FF) >> v18) & 3));
              v18 -= 2;
            }
            while (v18);
            v3 = v17;
          }
          v13 = v3;
        }
        while (v5-- > 0);
      }
    }
    else
    {
      kdu_params::set(v2, "DOads", v4, 0, (int *)1);
    }
    this = kdu_params::get(v2, "Ddecomp", ++v4, 0, v23, 0, 0, 0);
  }
  while ((this & 1) != 0);
  if (v20)
  {
    this = cod_params::is_valid_decomp_terminator((cod_params *)v23[0]);
    if ((this & 1) == 0)
      ads_params::finalize();
  }
  return this;
}

void sub_187F3F584(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F3F590(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t ads_params::write_marker_segment(ads_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  int v4;
  uint64_t v5;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned __int8 v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned __int8 v27;
  int v28;
  int v29;
  int v30;
  int v31;

  v4 = *((_DWORD *)this + 6);
  if (v4 < 1)
    return 0;
  v5 = 0;
  if (a4 || v4 > 0x7F)
    return v5;
  if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
    return 0;
  v30 = 0;
  if (a3)
  {
    if ((*((_DWORD *)a3 + 4) & 0x80000000) == 0 || *((_DWORD *)a3 + 6) != v4)
      ads_params::write_marker_segment();
    v10 = 0;
    while ((kdu_params::get(this, "DOads", v10, 0, &v30, 0, 0, 1) & 1) != 0)
    {
      v11 = v30;
      v31 = 0;
      if (kdu_params::get(a3, "DOads", v10, 0, &v31, 1, 1, 1))
      {
        ++v10;
        if (v31 == v11)
          continue;
      }
      goto LABEL_27;
    }
    while ((kdu_params::get(a3, "DOads", v10, 0, &v30, 0, 0, 1) & 1) != 0)
    {
      v12 = v30;
      v31 = 0;
      if (kdu_params::get(this, "DOads", v10, 0, &v31, 1, 1, 1))
      {
        ++v10;
        if (v31 == v12)
          continue;
      }
      goto LABEL_27;
    }
    v13 = 0;
    while ((kdu_params::get(this, "DSads", v13, 0, &v30, 0, 0, 1) & 1) != 0)
    {
      v14 = v30;
      v31 = 0;
      if (kdu_params::get(a3, "DSads", v13, 0, &v31, 1, 1, 1))
      {
        ++v13;
        if (v31 == v14)
          continue;
      }
      goto LABEL_27;
    }
    while (kdu_params::get(a3, "DSads", v13, 0, &v30, 0, 0, 1))
    {
      v15 = v30;
      v31 = 0;
      if (kdu_params::get(this, "DSads", v13, 0, &v31, 1, 1, 1))
      {
        ++v13;
        if (v31 == v15)
          continue;
      }
      goto LABEL_27;
    }
    return 0;
  }
LABEL_27:
  v16 = -1;
  do
    ++v16;
  while ((kdu_params::get(this, "DOads", v16, 0, &v30, 0, 0, 1) & 1) != 0);
  v17 = -1;
  do
    ++v17;
  while ((kdu_params::get(this, "DSads", v17, 0, &v30, 0, 0, 1) & 1) != 0);
  if (!(v17 | v16))
    return 0;
  v5 = ((v16 + 3) >> 2) + ((v17 + 3) >> 2) + 7;
  if (a2)
  {
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 115);
    kdu_output::put(a2, (unsigned __int16)(((v16 + 3) >> 2) + ((v17 + 3) >> 2) + 5) >> 8);
    kdu_output::put(a2, ((v16 + 3) >> 2) + ((v17 + 3) >> 2) + 5);
    v18 = kdu_output::put(a2, *((_BYTE *)this + 24));
    v19 = v18 + kdu_output::put(a2, v16) + 4;
    if (v16)
    {
      v20 = 0;
      v21 = 0;
      v22 = 8;
      do
      {
        kdu_params::get(this, "DOads", v21, 0, &v30, 1, 1, 1);
        v22 -= 2;
        v20 |= v30 << v22;
        if (!v22)
        {
          v23 = kdu_output::put(a2, v20);
          v20 = 0;
          v19 += v23;
          v22 = 8;
        }
        ++v21;
      }
      while (v16 != v21);
      if (v22 <= 7u)
        v19 += kdu_output::put(a2, v20);
    }
    v24 = kdu_output::put(a2, v17) + v19;
    if (v17)
    {
      v25 = 0;
      v26 = 0;
      v27 = 8;
      do
      {
        kdu_params::get(this, "DSads", v26, 0, &v30, 1, 1, 1);
        v28 = v30;
        if (v30 >= 1)
        {
          if (v30 == 3)
            v28 = 1;
          else
            v28 = v30 + 1;
          v30 = v28;
        }
        v27 -= 2;
        v25 |= v28 << v27;
        if (!v27)
        {
          v29 = kdu_output::put(a2, v25);
          v25 = 0;
          v24 += v29;
          v27 = 8;
        }
        ++v26;
      }
      while (v17 != v26);
      if (v27 <= 7u)
        v24 += kdu_output::put(a2, v25);
    }
    if ((_DWORD)v5 != v24)
      ads_params::write_marker_segment();
  }
  return v5;
}

BOOL ads_params::check_marker_segment(ads_params *this, int a2, int a3, char *a4, int *a5)
{
  int v6;

  if (a2 != 65395 || a3 < 1)
    return 0;
  v6 = *a4;
  *a5 = *a4;
  return v6 > 0;
}

uint64_t ads_params::read_marker_segment(ads_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t result;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int *v21;
  _QWORD *exception;
  _QWORD *v23;
  _QWORD *v24;
  _OWORD v25[2];
  uint64_t v26;
  char v27[16];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a5)
    return 0;
  result = 0;
  if (a2 == 65395 && a3 >= 2)
  {
    if (*((_DWORD *)this + 6) != *a4)
      return 0;
    v7 = &a4[a3];
    v8 = a4 + 2;
    v9 = a4[1];
    if (a4[1])
    {
      v10 = 0;
      v11 = 0;
      v12 = 0;
      do
      {
        if (!v10)
        {
          if (v7 - v8 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = v8;
            __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
          }
          v13 = *v8++;
          v11 = v13;
          v10 = 8;
        }
        v10 -= 2;
        kdu_params::set(this, "DOads", v12++, 0, (int *)((v11 >> v10) & 3));
      }
      while (v9 != v12);
    }
    else
    {
      v11 = 0;
    }
    if (v7 - v8 <= 0)
    {
      v24 = __cxa_allocate_exception(8uLL);
      *v24 = v8;
      __cxa_throw(v24, MEMORY[0x1E0DE4E60], 0);
    }
    v16 = *v8;
    v14 = v8 + 1;
    v15 = v16;
    if (v16)
    {
      v17 = 0;
      v18 = 0;
      do
      {
        if (!v17)
        {
          if (v7 - v14 <= 0)
          {
            v23 = __cxa_allocate_exception(8uLL);
            *v23 = v14;
            __cxa_throw(v23, MEMORY[0x1E0DE4E60], 0);
          }
          v19 = *v14++;
          v11 = v19;
          v17 = 8;
        }
        v17 -= 2;
        v20 = ((v11 >> v17) & 3) - 1;
        if (((v11 >> v17) & 3) == 1)
          v20 = 3;
        if (((v11 >> v17) & 3) != 0)
          v21 = (int *)v20;
        else
          v21 = 0;
        kdu_params::set(this, "DSads", v18++, 0, v21);
      }
      while (v15 != v18);
    }
    if (v14 != v7)
    {
      v26 = 0;
      memset(v25, 0, sizeof(v25));
      kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, "Malformed ADS marker segment encountered. The final ");
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      *(_OWORD *)v27 = 0u;
      if (BYTE8(v25[0]))
        sprintf(v27, "%x");
      else
        sprintf(v27, "%d");
      (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v25[0] + 16))(v25, v27);
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v25[0] + 16))(v25, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v25);
    }
    return 1;
  }
  return result;
}

void sub_187F3FD40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int128 a17, __int128 a18, uint64_t a19)
{
  _Unwind_Resume(exception_object);
}

uint64_t ads_params::custom_textualize_field(ads_params *this, kdu_message *a2, const char *__s1, int a4, char *a5)
{
  uint64_t result;
  uint64_t v9;
  _QWORD v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  result = strcmp(__s1, "Ddecomp");
  if (!(result | a4))
  {
    v9 = 0;
    v10[0] = 0;
    *(_QWORD *)((char *)v10 + 5) = 0;
    cod_params::textualize_decomp((cod_params *)&v9, a5);
    return (*(uint64_t (**)(kdu_message *, uint64_t *))(*(_QWORD *)a2 + 16))(a2, &v9);
  }
  return result;
}

void dfs_params::dfs_params(dfs_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 1;
  *((_BYTE *)this + 42) = 1;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 1;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BAB830;
  *((_QWORD *)this + 1) = "DFS";
}

void sub_187F3FF24(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t dfs_params::finalize(uint64_t this, char a2)
{
  kdu_params *v2;
  int v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  int v7;

  if ((a2 & 1) == 0)
  {
    v2 = (kdu_params *)this;
    v7 = 0;
    this = kdu_params::get((kdu_params *)this, "DSdfs", 0, 0, &v7, 0, 0, 0);
    if ((_DWORD)this)
    {
      v3 = 1;
      do
      {
        if ((*((_DWORD *)v2 + 6) - 128) <= 0xFFFFFF80)
        {
          v6 = 0;
          v4 = 0u;
          v5 = 0u;
          kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v4);
        }
        if (v7 >= 4)
        {
          v6 = 0;
          v4 = 0u;
          v5 = 0u;
          kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v4);
        }
        this = kdu_params::get(v2, "DSdfs", v3++, 0, &v7, 0, 0, 0);
      }
      while ((this & 1) != 0);
    }
  }
  return this;
}

void sub_187F40074(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F40080()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL dfs_params::check_marker_segment(dfs_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  int v6;

  if (a2 != 65394 || a3 < 2)
    return 0;
  v6 = (char)a4[1];
  *a5 = a4[1];
  return v6 > 0;
}

uint64_t dfs_params::read_marker_segment(dfs_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t result;
  unsigned __int8 *v7;
  int v8;
  unsigned __int8 *v9;
  int v10;
  unsigned int v11;
  int i;
  unsigned int v13;
  unsigned int v14;
  int *v15;
  _BYTE *v16;
  _QWORD *exception;
  _OWORD v18[2];
  uint64_t v19;
  unsigned __int8 *v20;

  if (a5 || (*((_DWORD *)this + 4) & 0x80000000) == 0 || (*((_DWORD *)this + 5) & 0x80000000) == 0)
    return 0;
  result = 0;
  if (a2 == 65394 && a3 >= 2)
  {
    v20 = a4 + 2;
    if (*((_DWORD *)this + 6) != a4[1])
      return 0;
    v7 = &a4[a3];
    v8 = kdu_read(&v20, v7, 1);
    v9 = v20;
    if (v8 >= 1)
    {
      v10 = 0;
      v11 = 0;
      for (i = 0; i != v8; ++i)
      {
        if (!v10)
        {
          if (v7 - v9 <= 0)
          {
            v20 = v9;
            exception = __cxa_allocate_exception(8uLL);
            *exception = v9;
            __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
          }
          v13 = *v9++;
          v11 = v13;
          v10 = 8;
        }
        v10 -= 2;
        v14 = ((v11 >> v10) & 3) - 1;
        if (((v11 >> v10) & 3) == 1)
          v14 = 3;
        if (((v11 >> v10) & 3) != 0)
          v15 = (int *)v14;
        else
          v15 = 0;
        kdu_params::set(this, "DSdfs", i, 0, v15);
      }
    }
    v20 = v9;
    if (v9 != v7)
    {
      v19 = 0;
      memset(v18, 0, sizeof(v18));
      kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, "Malformed DFS marker segment encountered. The final ");
      v16 = kdu_message::operator<<(v18);
      (*(void (**)(_BYTE *, const char *))(*(_QWORD *)v16 + 16))(v16, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v18);
    }
    return 1;
  }
  return result;
}

void sub_187F4027C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F40288()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_187F40290(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, __int128 a10, uint64_t a11, uint64_t a12)
{
  if (a2 != 1)
    sub_187F40288();
  __cxa_begin_catch(a1);
  a11 = 0;
  a9 = 0u;
  a10 = 0u;
  kdu_error::kdu_error((kdu_error *)&a9, "Kakadu Core Error:\n");
  (*(void (**)(__int128 *, const char *))(a9 + 16))(&a9, "Malformed DFS marker segment encountered. Marker segment is too small.");
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F402EC()
{
  __cxa_end_catch();
  JUMPOUT(0x187F401ECLL);
}

void sub_187F402F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F40304()
{
  __cxa_end_catch();
  sub_187F40288();
}

uint64_t dfs_params::write_marker_segment(dfs_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  int v4;
  uint64_t v5;
  int v9;
  unsigned int v10;
  __int16 v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned __int8 v16;
  int v17;
  int v18;
  int v19;

  v4 = *((_DWORD *)this + 6);
  if (v4 < 1)
    return 0;
  v5 = 0;
  if (!a4 && v4 <= 0x7F)
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0 || (*((_DWORD *)this + 4) & 0x80000000) == 0)
      return 0;
    v19 = 0;
    v9 = -1;
    do
      ++v9;
    while ((kdu_params::get(this, "DSdfs", v9, 0, &v19, 0, 0, 1) & 1) != 0);
    v10 = (v9 + 3) >> 2;
    v5 = v10 + 7;
    if (a2)
    {
      kdu_output::put(a2, 255);
      kdu_output::put(a2, 114);
      v11 = v10 + 5;
      kdu_output::put(a2, SHIBYTE(v11));
      kdu_output::put(a2, v11);
      v12 = *((_DWORD *)this + 6);
      kdu_output::put(a2, SBYTE1(v12));
      kdu_output::put(a2, v12);
      v13 = kdu_output::put(a2, v9) + 6;
      if (v9)
      {
        v14 = 0;
        v15 = 0;
        v16 = 8;
        do
        {
          kdu_params::get(this, "DSdfs", v15, 0, &v19, 1, 1, 1);
          v17 = v19;
          if (v19 >= 1)
          {
            if (v19 == 3)
              v17 = 1;
            else
              v17 = v19 + 1;
            v19 = v17;
          }
          v16 -= 2;
          v14 |= v17 << v16;
          if (!v16)
          {
            v18 = kdu_output::put(a2, v14);
            v14 = 0;
            v13 += v18;
            v16 = 8;
          }
          ++v15;
        }
        while (v9 != v15);
        if (v16 <= 7u)
          v13 += kdu_output::put(a2, v14);
      }
      if ((_DWORD)v5 != v13)
        dfs_params::write_marker_segment();
    }
  }
  return v5;
}

void qcd_params::qcd_params(qcd_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 0;
  *((_BYTE *)this + 42) = 0;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 16842753;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BABC80;
  *((_QWORD *)this + 1) = "QCD";
  kdu_params::add_dependency((uint64_t)this, "COD");
  kdu_params::add_dependency((uint64_t)this, "ADS");
  kdu_params::define_attribute(this, "Qguard", "Number of guard bits to prevent overflow in the magnitude bit-plane representation. Typical values are 1 or 2.\n\t\t[Default is 1]", "I", 0);
  kdu_params::define_attribute(this, "Qderived", "Quantization steps derived from LL band parameters? If \"yes\", all quantization step sizes will be related to the LL subband's step sizes through appropriate powers of 2 and only the LL band step size will be written in code-stream markers. Otherwise, a separate step size will be recorded for every subband. You cannot use this option with reversible compression.\n\t\t[Default is not derived]", "B", 0);
  kdu_params::define_attribute(this, "Qstep", "Base step size to be used in deriving irreversible quantization step sizes for every subband. The base step parameter should be in the range 0 to 2.\n\t\t[Default is 1/256]", "F", 0);
}

void sub_187F4063C(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t qcd_params::copy_with_xforms(qcd_params *this, kdu_params *a2, int a3, int a4, int a5)
{
  kdu_params *v7;
  kdu_params *v8;
  kdu_params *v9;
  uint64_t result;
  int v11;
  int v12;
  int v13;
  int v14;
  __int16 *v15;
  uint64_t v16;
  __int16 *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v23;
  float v25;
  BOOL v26;
  int v27;
  BOOL v28;
  int v29;
  _OWORD v30[6];
  __int16 v31;
  __int16 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v29 = 0;
  v28 = 0;
  if (kdu_params::get(a2, "Qguard", 0, 0, &v29, 0, 1, 1))
    kdu_params::set(this, "Qguard", 0, 0, (int *)v29);
  if (kdu_params::get(a2, "Qderived", 0, 0, &v28, 0, 1, 1))
    kdu_params::set((uint64_t)this, "Qderived", 0, 0, v28);
  v7 = (kdu_params *)kdu_params::access_cluster(a2, "COD");
  if (!v7
    || (v8 = (kdu_params *)kdu_params::access_relation(v7, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), 0, 1)) == 0)
  {
    qcd_params::copy_with_xforms();
  }
  v9 = v8;
  v27 = 0;
  v26 = 0;
  kdu_params::get(v8, "Clevels", 0, 0, &v27, 1, 1, 1);
  result = kdu_params::get(v9, "Creversible", 0, 0, &v26, 1, 1, 1);
  v38 = 0u;
  v37 = 0u;
  v36 = 0u;
  v35 = 0u;
  v34 = 0u;
  v33 = 0u;
  v31 = 0;
  memset(v30, 0, sizeof(v30));
  v32 = 0;
  v11 = v27;
  if (v27 >= a4)
  {
    v12 = 0;
    v13 = 0;
    v14 = 1;
    do
    {
      if (v13)
      {
        v25 = 0.0;
        if ((kdu_params::get(v9, "Cdecomp", v11 - v13, 0, (int *)&v25, 1, 1, 1) & 1) == 0)
          qcd_params::copy_with_xforms();
        result = cod_params::expand_decomp_bands(LODWORD(v25), (uint64_t)&v32, v15);
        v14 = result;
        if (a5)
        {
          v16 = cod_params::transpose_decomp((cod_params *)LODWORD(v25));
          result = cod_params::expand_decomp_bands(v16, (uint64_t)v30, v17);
        }
      }
      v23 = v13;
      if (v14 > (v13 != 0))
      {
        v18 = v13 != 0;
        do
        {
          LODWORD(v19) = v18;
          if (a5)
          {
            if (v14 < 1)
LABEL_27:
              qcd_params::copy_with_xforms();
            v19 = 0;
            v20 = bswap32(*((unsigned __int16 *)v30 + v18)) >> 16;
            while ((unsigned __int16)*(&v32 + v19) != v20)
            {
              if (v14 == ++v19)
                goto LABEL_27;
            }
          }
          v21 = v19 + v12;
          v25 = 0.0;
          if (v26)
          {
            kdu_params::get(a2, "Qabs_ranges", v21, 0, (int *)&v25, 1, 1, 1);
            result = (uint64_t)kdu_params::set(this, "Qabs_ranges", v12 + (int)v18, 0, (int *)LODWORD(v25));
          }
          else
          {
            kdu_params::get(a2, "Qabs_steps", v21, 0, &v25, 1, 1, 1);
            result = kdu_params::set((uint64_t)this, "Qabs_steps", v12 + (int)v18, 0, v25);
          }
          ++v18;
        }
        while (v18 != v14);
      }
      v12 = v12 + v14 - 1;
      ++v13;
      v11 = v27;
    }
    while (v23 < v27 - a4);
  }
  return result;
}

uint64_t qcd_params::write_marker_segment(qcd_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v4;
  kdu_params *v8;
  kdu_params *v9;
  kdu_params *v10;
  int v11;
  int v12;
  __int16 *v13;
  kdu_params *v14;
  kdu_params *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  char v21;
  char v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  _BOOL4 v30;
  kdu_params *v31;
  char v32;
  char v33;
  unsigned int v34;
  __int16 v35;
  int v36;
  int v37;
  int v38;
  int i;
  int v40;
  char v41;
  BOOL v43[4];
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  int v47;
  BOOL v48[2];
  int v49[2];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int16 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (a4)
    return 0;
  v8 = (kdu_params *)kdu_params::access_cluster(this, "COD");
  if (!v8)
    qcd_params::write_marker_segment();
  *(_QWORD *)v49 = 0;
  *(_WORD *)v48 = 0;
  v9 = (kdu_params *)kdu_params::access_relation(v8, *((_DWORD *)this + 4), *((_DWORD *)this + 5), 0, 1);
  v10 = v9;
  if (!v9
    || !kdu_params::get(v9, "Clevels", 0, 0, v49, 1, 1, 1)
    || (kdu_params::get(v10, "Creversible", 0, 0, &v48[1], 1, 1, 1) & 1) == 0)
  {
    *(_QWORD *)&v52 = 0;
    v50 = 0u;
    v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Cannot write QCD/QCC marker segment without first completing relevant COD/COC information!");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  if ((kdu_params::get(this, "Qguard", 0, 0, &v49[1], 1, 1, 1) & 1) == 0)
  {
    *(_QWORD *)&v52 = 0;
    v50 = 0u;
    v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Cannot write QCD/QCC marker segment yet! No info on guard bits.");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  if (v48[1])
  {
    v48[0] = 0;
    v56 = 0;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
  }
  else
  {
    if ((kdu_params::get(this, "Qderived", 0, 0, v48, 1, 1, 1) & 1) == 0)
    {
      *(_QWORD *)&v52 = 0;
      v50 = 0u;
      v51 = 0u;
      kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Cannot write QCD/QCC marker segment yet!  Not clear whether quant steps are derived from the LL band step size.");
      kdu_error::~kdu_error((kdu_error *)&v50);
    }
    v56 = 0;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    if (v48[0])
    {
LABEL_20:
      v12 = 1;
      if (!a3)
        goto LABEL_53;
      goto LABEL_21;
    }
  }
  LODWORD(v57) = 0;
  if (v49[0] < 1)
    goto LABEL_20;
  v11 = 0;
  v12 = 1;
  do
  {
    kdu_params::get(v10, "Cdecomp", v11, 0, (int *)&v57, 1, 1, 1);
    v12 = v12 + cod_params::expand_decomp_bands(v57, (uint64_t)&v50, v13) - 1;
    ++v11;
  }
  while (v11 < v49[0]);
  if (!a3)
    goto LABEL_53;
LABEL_21:
  LODWORD(v44) = 0;
  v43[0] = 0;
  v14 = (kdu_params *)kdu_params::access_relation(v10, *((_DWORD *)a3 + 4), *((_DWORD *)a3 + 5), 0, 1);
  v15 = v14;
  if (!v14)
    qcd_params::write_marker_segment();
  if (!kdu_params::get(v14, "Clevels", 0, 0, (int *)&v44, 1, 1, 1)
    || (kdu_params::get(v15, "Creversible", 0, 0, v43, 1, 1, 1) & 1) == 0)
  {
    *(_QWORD *)&v59 = 0;
    v57 = 0u;
    v58 = 0u;
    kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v57 + 16))(&v57, "Cannot write QCD/QCC marker segment without first completing all relevant COD/COC information!");
    kdu_error::~kdu_error((kdu_error *)&v57);
  }
  if (v43[0] == v48[1] && (_DWORD)v44 == v49[0])
  {
    v16 = v49[1];
    LODWORD(v57) = 0;
    v17 = kdu_params::get(a3, "Qguard", 0, 0, (int *)&v57, 1, 1, 1);
    v18 = (_DWORD)v57 == v16 ? v17 : 0;
    if (v18 == 1 && (v48[1] || kdu_params::compare(a3, "Qderived", 0, 0, v48[0])))
    {
      if (v12 >= 1)
      {
        v19 = 0;
        while (1)
        {
          if (v48[1])
          {
            v47 = 0.0;
            if ((kdu_params::get(this, "Qabs_ranges", v19, 0, (int *)&v47, 1, 1, 1) & 1) == 0)
            {
              *(_QWORD *)&v59 = 0;
              v57 = 0u;
              v58 = 0u;
              kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
              (*(void (**)(__int128 *, const char *))(v57 + 16))(&v57, "Cannot write QCD/QCC marker segment yet!  Absolute reversible ranging information not available.");
              kdu_error::~kdu_error((kdu_error *)&v57);
            }
            v20 = LODWORD(v47);
            LODWORD(v57) = 0;
            v21 = kdu_params::get(a3, "Qabs_ranges", v19, 0, (int *)&v57, 1, 1, 1);
            if ((_DWORD)v57 == v20)
              v22 = v21;
            else
              v22 = 0;
            if ((v22 & 1) == 0)
              goto LABEL_52;
          }
          else
          {
            v47 = 0.0;
            if ((kdu_params::get(this, "Qabs_steps", v19, 0, &v47, 1, 1, 1) & 1) == 0)
            {
              *(_QWORD *)&v59 = 0;
              v57 = 0u;
              v58 = 0u;
              kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
              (*(void (**)(__int128 *, const char *))(v57 + 16))(&v57, "Cannot write QCD/QCC marker segment yet!  Absolute step size information not available.");
              kdu_error::~kdu_error((kdu_error *)&v57);
            }
            *(float *)&v23 = v47;
            LODWORD(v57) = 0;
            v24 = kdu_params::get(a3, "Qabs_steps", v19, 0, (float *)&v57, 1, 1, 1);
            if (*(float *)&v57 == *(float *)&v23)
              v25 = v24;
            else
              v25 = 0;
            if (v25 != 1)
              goto LABEL_52;
          }
          if (v12 == ++v19)
            return 0;
        }
      }
      v19 = 0;
LABEL_52:
      if (v19 == v12)
        return 0;
    }
  }
LABEL_53:
  if (v49[1] >= 8u)
  {
    v46 = 0;
    v44 = 0u;
    v45 = 0u;
    kdu_error::kdu_error((kdu_error *)&v44, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v44 + 16))(&v44, "Illegal number of guard bits, ");
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v57 = 0u;
    if (BYTE8(v44))
      sprintf((char *)&v57, "%x");
    else
      sprintf((char *)&v57, "%d");
    (*(void (**)(__int128 *, __int128 *))(v44 + 16))(&v44, &v57);
    (*(void (**)(__int128 *, const char *))(v44 + 16))(&v44, ". Legal range is from 0 to 7.");
    kdu_error::~kdu_error((kdu_error *)&v44);
  }
  v26 = *((_DWORD *)this + 8);
  v27 = *((_DWORD *)this + 5);
  if (v26 < 257)
    v28 = 6;
  else
    v28 = 7;
  if (v27 >= 0)
    v29 = v28;
  else
    v29 = 5;
  v30 = v48[1];
  v4 = v29 + v12 * (2 - v48[1]);
  if (a2)
  {
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
    {
      v31 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
      if (!v31)
        qcd_params::write_marker_segment();
      LODWORD(v47) = 2;
      kdu_params::get(v31, "Sprofile", 0, 0, (int *)&v47, 1, 1, 1);
      if (!LODWORD(v47))
      {
        v46 = 0;
        v44 = 0u;
        v45 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v44, "Kakadu Core Warning:\n");
        (*(void (**)(__int128 *, const char *))(v44 + 16))(&v44, "Profile violation detected (code-stream is technically illegal).  QCD/QCC marker segments may only appear in the main header of a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.  Problem detected in tile ");
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v57 = 0u;
        if (BYTE8(v44))
          sprintf((char *)&v57, "%x");
        else
          sprintf((char *)&v57, "%d");
        (*(void (**)(__int128 *, __int128 *))(v44 + 16))(&v44, &v57);
        (*(void (**)(__int128 *, const char *))(v44 + 16))(&v44, ".");
        kdu_warning::~kdu_warning((kdu_warning *)&v44);
      }
      v30 = v48[1];
      v27 = *((_DWORD *)this + 5);
    }
    v32 = v49[1];
    if (v30)
      v33 = 0;
    else
      v33 = 2 - v48[0];
    kdu_output::put(a2, 255);
    v34 = v27 >> 31;
    v35 = v4 - 2;
    if (v34)
    {
      kdu_output::put(a2, 92);
      kdu_output::put(a2, SHIBYTE(v35));
      kdu_output::put(a2, v35);
      v37 = 4;
    }
    else
    {
      kdu_output::put(a2, 93);
      kdu_output::put(a2, SHIBYTE(v35));
      kdu_output::put(a2, v35);
      v36 = *((_DWORD *)this + 5);
      if (v26 >= 257)
      {
        kdu_output::put(a2, SBYTE1(v36));
        kdu_output::put(a2, v36);
        v37 = 6;
      }
      else
      {
        v37 = kdu_output::put(a2, v36) + 4;
      }
    }
    v38 = kdu_output::put(a2, v33 | (32 * v32)) + v37;
    if (v12 >= 1)
    {
      for (i = 0; i != v12; ++i)
      {
        if (v48[1])
        {
          LODWORD(v44) = 0;
          if ((kdu_params::get(this, "Qabs_ranges", i, 0, (int *)&v44, 1, 1, 1) & 1) == 0)
          {
            *(_QWORD *)&v59 = 0;
            v57 = 0u;
            v58 = 0u;
            kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v57 + 16))(&v57, "Insufficient absolute ranging parameters available for writing QCD/QCC marker segment");
            kdu_error::~kdu_error((kdu_error *)&v57);
          }
          if (v44 >= 0x20)
          {
            *(_QWORD *)&v59 = 0;
            v57 = 0u;
            v58 = 0u;
            kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v57 + 16))(&v57, "Absolute ranging parameters for reversibly compressed subbands must be non-negative, no larger than 31!");
            kdu_error::~kdu_error((kdu_error *)&v57);
          }
          v40 = kdu_output::put(a2, 8 * (v44 & 0x1Fu));
        }
        else
        {
          *(_DWORD *)v43 = 0;
          LODWORD(v44) = 0;
          v47 = 0.0;
          if ((kdu_params::get(this, "Qabs_steps", i, 0, (float *)&v44, 1, 1, 1) & 1) == 0)
          {
            *(_QWORD *)&v59 = 0;
            v57 = 0u;
            v58 = 0u;
            kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v57 + 16))(&v57, "Insufficient absolute quantization step size parameters available for writing QCD/QCC marker segment.");
            kdu_error::~kdu_error((kdu_error *)&v57);
          }
          step_to_eps_mu(*(float *)&v44, (int *)&v47, (int *)v43);
          v41 = v43[0];
          kdu_output::put(a2, (unsigned __int16)(*(_WORD *)v43 + (LOWORD(v47) << 11)) >> 8);
          kdu_output::put(a2, v41);
          v40 = 2;
        }
        v38 += v40;
      }
    }
    if ((_DWORD)v4 != v38)
      qcd_params::write_marker_segment();
  }
  return v4;
}

void sub_187F413F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  kdu_error::~kdu_error((kdu_error *)&a33);
}

void sub_187F41400(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Unwind_Exception *v33;

  _Unwind_Resume(v33);
}

int *step_to_eps_mu(float a1, int *result, int *a3)
{
  float v3;
  int v4;
  int v5;
  int v6;
  _OWORD v7[2];
  uint64_t v8;

  v3 = a1;
  if (a1 <= 0.0)
  {
    v8 = 0;
    memset(v7, 0, sizeof(v7));
    kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, "Absolute quantization step sizes must be strictly positive.");
    kdu_error::~kdu_error((kdu_error *)v7);
  }
  v4 = 0;
  while (v3 < 1.0)
  {
    v3 = v3 + v3;
    ++v4;
  }
  *result = v4;
  v5 = vcvtms_s32_f32((float)((float)(v3 + -1.0) * 2048.0) + 0.5);
  *a3 = v5;
  if (v5 < 2048)
  {
    v6 = *result;
  }
  else
  {
    *a3 = 0;
    v6 = *result - 1;
    *result = v6;
  }
  if (v6 >= 32)
  {
    *result = 31;
    *a3 = 0;
    v6 = *result;
  }
  if (v6 < 0)
  {
    *result = 0;
    *a3 = 2047;
  }
  return result;
}

void sub_187F415BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F415C8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t qcd_params::check_marker_segment(qcd_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  int v5;
  uint64_t result;
  int v8;

  if (a2 == 65372)
  {
    v5 = -1;
    goto LABEL_7;
  }
  result = 0;
  if (a2 == 65373 && a3 >= 2)
  {
    v8 = *a4;
    *a5 = v8;
    if (*((int *)this + 8) < 257)
      return 1;
    v5 = a4[1] | (v8 << 8);
LABEL_7:
    *a5 = v5;
    return 1;
  }
  return result;
}

uint64_t qcd_params::read_marker_segment(qcd_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  int v9;
  int v10;
  unint64_t v11;
  kdu_params *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned int v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  uint64_t v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *exception;
  _QWORD *v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  int v32;
  char v33[16];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a5)
    return 0;
  v9 = *((_DWORD *)this + 5);
  if (v9 < 0)
  {
    v11 = (unint64_t)a4;
    if (a2 != 65372)
      return 0;
  }
  else
  {
    if (a2 != 65373)
      return 0;
    v11 = (unint64_t)(a4 + 1);
    v10 = *a4;
    if (*((int *)this + 8) >= 257)
    {
      v11 = (unint64_t)(a4 + 2);
      v10 = a4[1] | (v10 << 8);
    }
    if (v10 != v9)
      return 0;
  }
  if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
  {
    v12 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
    if (!v12)
      qcd_params::read_marker_segment();
    v32 = 2;
    kdu_params::get(v12, "Sprofile", 0, 0, &v32, 1, 1, 1);
    if (!v32)
    {
      v31 = 0;
      v29 = 0u;
      v30 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v29, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "Profile violation detected (code-stream is technically illegal).  QCD/QCC marker segments may only appear in the main header of a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.  Problem detected in tile ");
      v36 = 0u;
      v37 = 0u;
      v34 = 0u;
      v35 = 0u;
      *(_OWORD *)v33 = 0u;
      if (BYTE8(v29))
        sprintf(v33, "%x");
      else
        sprintf(v33, "%d");
      (*(void (**)(__int128 *, char *))(v29 + 16))(&v29, v33);
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, ".");
      kdu_warning::~kdu_warning((kdu_warning *)&v29);
    }
  }
  v13 = &a4[a3];
  if ((uint64_t)&v13[-v11] <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = v11;
    __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
  }
  v14 = (unsigned __int8 *)(v11 + 1);
  v15 = *(unsigned __int8 *)v11;
  kdu_params::set(this, "Qguard", 0, 0, (int *)(v15 >> 5));
  v16 = a3;
  if ((v15 & 0x1F) == 2)
  {
    v22 = 0;
LABEL_29:
    kdu_params::set((uint64_t)this, "Qderived", 0, 0, v22);
    if (v14 < v13 - 1)
    {
      v23 = 0;
      v24 = (uint64_t)&a4[v16 + ~v11];
      do
      {
        if (v24 <= 1)
        {
          v25 = __cxa_allocate_exception(8uLL);
          *v25 = v14;
          __cxa_throw(v25, MEMORY[0x1E0DE4E60], 0);
        }
        kdu_params::set((uint64_t)this, "Qabs_steps", v23++, 0, (float)((float)((float)((float)(v14[1] | ((*v14 & 7) << 8)) * 0.00048828) + 1.0)/ (float)(1 << (*v14 >> 3))));
        v24 -= 2;
        v14 += 2;
        v18 = v14;
      }
      while (v14 < v13 - 1);
      goto LABEL_33;
    }
LABEL_43:
    v28 = __cxa_allocate_exception(8uLL);
    *v28 = v14;
    __cxa_throw(v28, MEMORY[0x1E0DE4E60], 0);
  }
  if ((v15 & 0x1F) == 1)
  {
    v22 = 1;
    goto LABEL_29;
  }
  if ((v15 & 0x1F) != 0)
  {
    *(_QWORD *)&v35 = 0;
    *(_OWORD *)v33 = 0u;
    v34 = 0u;
    kdu_error::kdu_error((kdu_error *)v33, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v33 + 16))(v33, "Undefined style byte found in QCD/QCC marker segment!");
    kdu_error::~kdu_error((kdu_error *)v33);
  }
  if (v14 >= v13)
    goto LABEL_43;
  v17 = 0;
  v18 = v13;
  v19 = &a4[v16 + ~v11];
  v20 = (uint64_t)v19;
  do
  {
    v21 = &v17[v11];
    if (v20 <= 0)
    {
      v26 = __cxa_allocate_exception(8uLL);
      *v26 = v21 + 1;
      __cxa_throw(v26, MEMORY[0x1E0DE4E60], 0);
    }
    kdu_params::set(this, "Qabs_ranges", (int)v17++, 0, (int *)(v21[1] >> 3));
    --v20;
  }
  while (v19 != v17);
LABEL_33:
  if (v18 != v13)
  {
    v31 = 0;
    v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "Malformed QCD/QCC marker segment encountered. The final ");
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    *(_OWORD *)v33 = 0u;
    if (BYTE8(v29))
      sprintf(v33, "%x");
    else
      sprintf(v33, "%d");
    (*(void (**)(__int128 *, char *))(v29 + 16))(&v29, v33);
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)&v29);
  }
  return 1;
}

void sub_187F41ADC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F41AEC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __int128 a17, __int128 a18, uint64_t a19)
{
  _Unwind_Exception *v19;
  int v20;

  if (v20 == 1)
  {
    __cxa_begin_catch(v19);
    a19 = 0;
    a17 = 0u;
    a18 = 0u;
    kdu_error::kdu_error((kdu_error *)&a17, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(a17 + 16))(&a17, "Malformed QCD/QCC marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a17);
  }
  _Unwind_Resume(v19);
}

kdu_params *qcd_params::finalize(kdu_params *this, char a2)
{
  kdu_params *v2;
  kdu_params *v3;
  kdu_params *v4;
  kdu_params *v5;
  kdu_params *v6;
  int v7;
  int v8;
  __int16 *v9;
  int v10;
  char v11;
  int v12;
  char v13;
  char v14;
  kdu_params *v15;
  int v16;
  int i;
  int v18;
  char v19;
  char v20;
  int v21;
  char v22;
  char v23;
  size_t v24;
  unsigned int v25;
  int v26;
  void *v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  int v31;
  const char *v32;
  int *v33;
  const char *v34;
  int v35;
  int *v36;
  float *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int *v44;
  __int16 *v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  double bibo_gain;
  double v50;
  int *v51;
  double v52;
  double v53;
  unint64_t j;
  char v55;
  char v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  float *v62;
  uint64_t k;
  int v64;
  int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  kdu_params *v69;
  int v70;
  int *v71;
  int v72;
  BOOL v73;
  int v74[2];
  int v75;
  float v76;
  int v77[2];
  unsigned int v78;
  unsigned int v79;
  int v80[4];
  __int128 v81;
  uint64_t v82;
  BOOL v83[2];
  BOOL v84;
  BOOL v85[2];
  BOOL v86;
  _BYTE v87[96];
  __int16 v88;
  float v89[24];
  __int16 v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  if ((a2 & 1) != 0)
    return this;
  v78 = 0;
  *(_QWORD *)v77 = 0;
  v76 = 0.0;
  v71 = (int *)this;
  if ((kdu_params::get(this, "Qguard", 0, 0, v77, 1, 1, 1) & 1) == 0)
  {
    v77[0] = 1;
    kdu_params::set((kdu_params *)v71, "Qguard", 0, 0, (int *)1);
  }
  v2 = (kdu_params *)kdu_params::access_cluster((kdu_params *)v71, "COD");
  if (!v2)
    qcd_params::finalize();
  v3 = (kdu_params *)kdu_params::access_relation(v2, v71[4], v71[5], 0, 1);
  v4 = v3;
  if (!v3)
    qcd_params::finalize();
  v75 = 0;
  *(_QWORD *)v74 = 0;
  if (!kdu_params::get(v3, "Creversible", 0, 0, &v75, 1, 1, 1)
    || !kdu_params::get(v4, "Clevels", 0, 0, &v74[1], 1, 1, 1)
    || (kdu_params::get(v4, "Ckernels", 0, 0, v74, 1, 1, 1) & 1) == 0)
  {
    qcd_params::finalize();
  }
  if (v74[0] == -1)
  {
    v80[0] = 0;
    if ((kdu_params::get(v4, "Catk", 0, 0, v80, 1, 1, 1) & 1) == 0)
      qcd_params::finalize();
    v6 = (kdu_params *)kdu_params::access_cluster((kdu_params *)v71, "ATK");
    if (!v6 || (v5 = (kdu_params *)kdu_params::access_relation(v6, v71[4], -1, v80[0], 1)) == 0)
      qcd_params::finalize();
  }
  else
  {
    v5 = 0;
  }
  v88 = 0;
  memset(v87, 0, sizeof(v87));
  if (v74[1] < 1)
  {
    v8 = 1;
  }
  else
  {
    v7 = 0;
    v8 = 1;
    do
    {
      kdu_params::get(v4, "Cdecomp", v7, 0, (int *)&v78, 1, 1, 1);
      v8 = v8 + cod_params::expand_decomp_bands(v78, (uint64_t)v87, v9) - 1;
      ++v7;
    }
    while (v7 < v74[1]);
  }
  v10 = 0;
  do
    v11 = kdu_params::get((kdu_params *)v71, "Qabs_steps", v10++, 0, &v76, 1, 1, 0);
  while ((v11 & 1) != 0);
  v12 = 0;
  do
    v13 = kdu_params::get((kdu_params *)v71, "Qabs_ranges", v12++, 0, &v77[1], 1, 1, 0);
  while ((v13 & 1) != 0);
  v73 = 0;
  if (v75)
  {
    this = (kdu_params *)kdu_params::get((kdu_params *)v71, "Qderived", 0, 0, &v73, 1, 1, 1);
    if (v73)
      v14 = 0;
    else
      v14 = (char)this;
    if ((v14 & 1) == 0)
    {
      v73 = 0;
      this = (kdu_params *)kdu_params::set((uint64_t)v71, "Qderived", 0, 0, 0);
    }
    if (v8 + 1 != v12)
    {
      v72 = 0;
      v15 = (kdu_params *)kdu_params::access_cluster((kdu_params *)v71, "SIZ");
      if ((kdu_params::get(v15, "Sprecision", v71[5] & ~(v71[5] >> 31), 0, &v72, 1, 1, 1) & 1) == 0)
      {
        v82 = 0;
        *(_OWORD *)v80 = 0u;
        v81 = 0u;
        kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v80 + 16))(v80, "Trying to finalize quantization parameter attributes without first providing any information about the image component bit-depths (i.e. \"Sprecision\").");
        kdu_error::~kdu_error((kdu_error *)v80);
      }
      v16 = v71[8];
      if (v71[5] < 0)
      {
        if (v16 < 1)
          goto LABEL_56;
        for (i = 0; i < v16; ++i)
        {
          v18 = v72;
          v80[0] = 0;
          v19 = kdu_params::get(v15, "Sprecision", i, 0, v80, 1, 1, 1);
          if (v80[0] == v18)
            v20 = v19;
          else
            v20 = 0;
          if ((v20 & 1) == 0)
            kdu_params::access_relation((kdu_params *)v71, v71[4], i, 0, 0);
          v16 = v71[8];
        }
      }
      if (v16 >= 3)
      {
        v21 = ++v72;
LABEL_57:
        if (v21 <= 4)
          v72 = ++v21;
        v70 = v74[1];
        v66 = v77[0];
        v90 = 0;
        memset(v89, 0, sizeof(v89));
        v86 = 0;
        *(_WORD *)v85 = 0;
        v84 = 0;
        *(_WORD *)v83 = 0;
        bzero(v80, 0x288uLL);
        kdu_kernels::clear((uint64_t)v80);
        v69 = v4;
        v65 = v21;
        if (v5)
        {
          v24 = 0;
          v25 = 0;
          v26 = 0;
          v79 = 0;
          while (kdu_params::get(v5, "Ksteps", v25, 0, (int *)&v79, 1, 1, 1))
          {
            v26 += v79;
            ++v25;
            v24 += 16;
          }
          v68 = v25;
          v27 = (void *)operator new[]();
          v28 = (uint64_t)v27;
          if (v25)
            bzero(v27, v24);
          v29 = (int *)operator new[]();
          v64 = v25;
          if (v25)
          {
            v30 = 0;
            v31 = 0;
            v32 = "Ksteps";
            v67 = v28;
            do
            {
              v33 = (int *)(v28 + 16 * v30);
              if (!kdu_params::get(v5, v32, v30, 0, v33, 1, 1, 1)
                || !kdu_params::get(v5, v32, v30, 1, (int *)(v28 + 16 * v30 + 4), 1, 1, 1)
                || !kdu_params::get(v5, v32, v30, 2, (int *)(v28 + 16 * v30 + 8), 1, 1, 1)
                || !kdu_params::get(v5, v32, v30, 3, (int *)(v28 + 16 * v30 + 12), 1, 1, 1))
              {
                __assert_rtn("derive_absolute_ranges", "params.cpp", 414, "0");
              }
              if (*v33 >= 1)
              {
                v34 = v32;
                v35 = 0;
                v36 = v29;
                v37 = (float *)&v29[v31];
                do
                  kdu_params::get(v5, "Kcoeffs", v31 + v35++, 0, v37++, 1, 1, 1);
                while (v35 < *v33);
                v31 += v35;
                v29 = v36;
                v32 = v34;
                v28 = v67;
              }
              ++v30;
            }
            while (v30 != v68);
          }
          kdu_kernels::init((uint64_t)v80, v64, v28, v29, 0, 0, 1);
          MEMORY[0x18D761C18](v28, 0x1000C80451B5BE8);
          MEMORY[0x18D761C18](v29, 0x1000C8052888210);
          v21 = v65;
        }
        else
        {
          v79 = 0;
          kdu_params::get(v4, "Ckernels", 0, 0, (int *)&v79, 1, 1, 1);
          kdu_kernels::init((kdu_kernels *)v80, v79, 1);
        }
        v38 = v8 - 1;
        if (v70 < 1)
        {
          v42 = 0;
          v41 = 0;
        }
        else
        {
          v39 = 0;
          v40 = 0;
          v41 = 0;
          v42 = 0;
          v43 = 0;
          v44 = (int *)(v21 - v66);
          do
          {
            v79 = 0;
            kdu_params::get(v69, "Cdecomp", v43, 0, (int *)&v79, 1, 1, 1);
            v46 = cod_params::expand_decomp_bands(v79, (uint64_t)v89, v45);
            if (v46 >= 1)
            {
              v47 = v46;
              while (1)
              {
                v48 = *((unsigned __int16 *)v89 + --v47);
                v40 = v48 & 3;
                v85[0] = (v48 & 4) != 0;
                v85[1] = (v48 & 8) != 0;
                v86 = (v48 & 0x10) != 0;
                v39 = (v48 >> 8) & 3;
                v83[0] = (v48 & 0x400) != 0;
                v83[1] = (v48 & 0x800) != 0;
                v84 = (v48 & 0x1000) != 0;
                if (!v47)
                  break;
                bibo_gain = kdu_kernels::get_bibo_gain((kdu_kernels *)v80, v42, v40, v85);
                v50 = bibo_gain * kdu_kernels::get_bibo_gain((kdu_kernels *)v80, v41, v39, v83);
                v51 = v44;
                if (v50 > 0.899999976)
                {
                  LODWORD(v51) = (_DWORD)v44;
                  do
                  {
                    v51 = (int *)((_DWORD)v51 + 1);
                    v50 = v50 * 0.5;
                  }
                  while (v50 > 0.899999976);
                }
                if (v38 <= 0)
                  __assert_rtn("derive_absolute_ranges", "params.cpp", 449, "band_idx > 0");
                kdu_params::set((kdu_params *)v71, "Qabs_ranges", v38--, 0, v51);
              }
            }
            v42 += v40;
            v41 += v39;
            ++v43;
          }
          while (v43 != v70);
        }
        if (v38)
          __assert_rtn("derive_absolute_ranges", "params.cpp", 456, "band_idx == 0");
        v52 = kdu_kernels::get_bibo_gain((kdu_kernels *)v80, v42, 0, 0);
        v53 = v52 * kdu_kernels::get_bibo_gain((kdu_kernels *)v80, v41, 0, 0);
        for (j = (v65 - v66); v53 > 0.899999976; v53 = v53 * 0.5)
          j = (j + 1);
        kdu_params::set((kdu_params *)v71, "Qabs_ranges", 0, 0, (int *)j);
        kdu_kernels::reset((kdu_kernels *)v80);
        return (kdu_params *)kdu_params::set_derived((uint64_t)v71, "Qabs_ranges");
      }
LABEL_56:
      v21 = v72;
      goto LABEL_57;
    }
  }
  else
  {
    v89[0] = 0.0;
    if (kdu_params::get((kdu_params *)v71, "Qstep", 0, 0, v89, 1, 1, 1))
    {
      if (kdu_params::get((kdu_params *)v71, "Qabs_steps", 0, 0, &v76, 0, 0, 0))
      {
        v82 = 0;
        *(_OWORD *)v80 = 0u;
        v81 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)v80, "Kakadu Core Warning:\n");
        kdu_warning::~kdu_warning((kdu_warning *)v80);
      }
      if ((kdu_params::get((kdu_params *)v71, "Qderived", 0, 0, &v73, 1, 1, 1) & 1) == 0)
      {
        v73 = 0;
        kdu_params::set((uint64_t)v71, "Qderived", 0, 0, 0);
      }
      derive_absolute_steps((qcd_params *)v71, v4, v5, v74[1], v8, v89[0], v73);
      kdu_params::set_derived((uint64_t)v71, "Qabs_steps");
    }
    else if (v10 - 1 >= v8)
    {
      v55 = kdu_params::get((kdu_params *)v71, "Qderived", 0, 0, &v73, 1, 1, 1);
      if (v73)
        v56 = 0;
      else
        v56 = v55;
      if ((v56 & 1) == 0)
      {
        v73 = 0;
        kdu_params::set((uint64_t)v71, "Qderived", 0, 0, 0);
      }
    }
    else
    {
      v22 = kdu_params::get((kdu_params *)v71, "Qderived", 0, 0, &v73, 1, 1, 1);
      if (v10 == 2)
      {
        if (v73)
          v23 = v22;
        else
          v23 = 0;
        if ((v23 & 1) == 0)
        {
          v73 = 1;
          kdu_params::set((uint64_t)v71, "Qderived", 0, 0, 1);
        }
      }
      else
      {
        if ((v22 & 1) == 0)
        {
          v73 = 0;
          kdu_params::set((uint64_t)v71, "Qderived", 0, 0, 0);
        }
        v89[0] = 0.0039062;
        kdu_params::set((uint64_t)v71, "Qstep", 0, 0, 0.00390625);
        derive_absolute_steps((qcd_params *)v71, v4, v5, v74[1], v8, v89[0], v73);
        kdu_params::set_derived((uint64_t)v71, "Qabs_steps");
      }
    }
    if (v73)
      v57 = 1;
    else
      v57 = v8;
    this = (kdu_params *)kdu_params::get((kdu_params *)v71, "Qabs_steps", 0, 0, &v76, 0, 0, 1);
    if ((_DWORD)this)
    {
      v79 = 0;
      v80[0] = 0;
      if ((int)v57 >= 1)
      {
        v58 = 0;
        do
        {
          if ((kdu_params::get((kdu_params *)v71, "Qabs_steps", v58, 0, &v76, 1, 1, 1) & 1) == 0)
            qcd_params::finalize();
          step_to_eps_mu(v76, v80, (int *)&v79);
          this = (kdu_params *)kdu_params::set((uint64_t)v71, "Qabs_steps", v58++, 0, (float)((float)((float)((float)(int)v79 * 0.00048828) + 1.0)/ (float)(1 << SLOBYTE(v80[0]))));
        }
        while ((_DWORD)v57 != v58);
      }
    }
    else
    {
      v79 = 0;
      v80[0] = 0;
      v59 = operator new[]();
      v60 = v59;
      if ((int)v57 >= 1)
      {
        v61 = 0;
        v62 = (float *)v59;
        do
        {
          if ((kdu_params::get((kdu_params *)v71, "Qabs_steps", v61, 0, v62, 1, 1, 0) & 1) == 0)
            qcd_params::finalize();
          ++v61;
          ++v62;
        }
        while (v57 != v61);
        for (k = 0; k != v57; ++k)
        {
          step_to_eps_mu(*(float *)(v60 + 4 * k), v80, (int *)&v79);
          kdu_params::set((uint64_t)v71, "Qabs_steps", k, 0, (float)((float)((float)((float)(int)v79 * 0.00048828) + 1.0) / (float)(1 << SLOBYTE(v80[0]))));
        }
      }
      kdu_params::set_derived((uint64_t)v71, "Qabs_steps");
      return (kdu_params *)MEMORY[0x18D761C18](v60, 0x1000C8052888210);
    }
  }
  return this;
}

void sub_187F42A68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

uint64_t derive_absolute_steps(qcd_params *a1, kdu_params *a2, kdu_params *a3, int a4, int a5, float a6, int a7)
{
  char v7;
  int v10;
  size_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  int v18;
  int *v19;
  int v20;
  float *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  __int16 *v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  double energy_gain;
  double v32;
  float v33;
  unint64_t v34;
  double v35;
  float v36;
  int *v38;
  void *v39;
  unsigned int v43;
  _BYTE v44[648];
  BOOL v45[2];
  BOOL v46;
  BOOL v47[2];
  BOOL v48;
  _WORD v49[52];
  uint64_t v50;

  v7 = a7;
  v50 = *MEMORY[0x1E0C80C00];
  memset(v49, 0, 98);
  v48 = 0;
  *(_WORD *)v47 = 0;
  v46 = 0;
  if (a7)
    v10 = 0;
  else
    v10 = a5 - 1;
  *(_WORD *)v45 = 0;
  bzero(v44, 0x288uLL);
  kdu_kernels::clear((uint64_t)v44);
  if (a3)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v43 = 0;
    while (kdu_params::get(a3, "Ksteps", v12, 0, (int *)&v43, 1, 1, 1))
    {
      v13 += v43;
      ++v12;
      v11 += 16;
    }
    v39 = (void *)operator new[]();
    if ((_DWORD)v12)
      bzero(v39, v11);
    v14 = operator new[]();
    v15 = (uint64_t)v39;
    v16 = (int *)v14;
    if ((_DWORD)v12)
    {
      v17 = 0;
      v18 = 0;
      v38 = (int *)v14;
      do
      {
        v19 = (int *)(v15 + 16 * v17);
        if (!kdu_params::get(a3, "Ksteps", v17, 0, v19, 1, 1, 1)
          || !kdu_params::get(a3, "Ksteps", v17, 1, (int *)(v15 + 16 * v17 + 4), 1, 1, 1)
          || !kdu_params::get(a3, "Ksteps", v17, 2, (int *)(v15 + 16 * v17 + 8), 1, 1, 1)
          || !kdu_params::get(a3, "Ksteps", v17, 3, (int *)(v15 + 16 * v17 + 12), 1, 1, 1))
        {
          __assert_rtn("derive_absolute_steps", "params.cpp", 512, "0");
        }
        if (*v19 >= 1)
        {
          v20 = 0;
          v21 = (float *)&v16[v18];
          do
            kdu_params::get(a3, "Kcoeffs", v18 + v20++, 0, v21++, 1, 1, 1);
          while (v20 < *v19);
          v18 += v20;
          v16 = v38;
          v15 = (uint64_t)v39;
        }
        ++v17;
      }
      while (v12 != v17);
    }
    kdu_kernels::init((uint64_t)v44, v12, v15, v16, 0, 0, 0);
    MEMORY[0x18D761C18](v15, 0x1000C80451B5BE8);
    MEMORY[0x18D761C18](v16, 0x1000C8052888210);
  }
  else
  {
    v43 = 0;
    kdu_params::get(a2, "Ckernels", 0, 0, (int *)&v43, 1, 1, 1);
    kdu_kernels::init((kdu_kernels *)v44, v43, 0);
  }
  if (a4 < 1)
  {
    v25 = 0;
    v24 = 0;
    if (!v10)
      goto LABEL_34;
LABEL_36:
    __assert_rtn("derive_absolute_steps", "params.cpp", 554, "band_idx == 0");
  }
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  do
  {
    v43 = 0;
    kdu_params::get(a2, "Cdecomp", v26, 0, (int *)&v43, 1, 1, 1);
    v28 = cod_params::expand_decomp_bands(v43, (uint64_t)v49, v27);
    if (v28 >= 1)
    {
      v29 = v28 - 1;
      do
      {
        v30 = (unsigned __int16)v49[v29];
        v23 = v30 & 3;
        v47[0] = (v30 & 4) != 0;
        v47[1] = (v30 & 8) != 0;
        v48 = (v30 & 0x10) != 0;
        v22 = (v30 >> 8) & 3;
        v45[0] = (v30 & 0x400) != 0;
        v45[1] = (v30 & 0x800) != 0;
        v46 = (v30 & 0x1000) != 0;
        if (v29 && (v7 & 1) == 0)
        {
          energy_gain = kdu_kernels::get_energy_gain((kdu_kernels *)v44, v25, v23, v47);
          v32 = kdu_kernels::get_energy_gain((kdu_kernels *)v44, v24, v22, v45);
          if (v10 <= 0)
            __assert_rtn("derive_absolute_steps", "params.cpp", 547, "band_idx > 0");
          v33 = sqrt(energy_gain * v32);
          kdu_params::set((uint64_t)a1, "Qabs_steps", v10--, 0, (float)(a6 / v33));
        }
        v34 = v29-- + 1;
      }
      while (v34 > 1);
    }
    v25 += v23;
    v24 += v22;
    ++v26;
  }
  while (v26 != a4);
  if (v10)
    goto LABEL_36;
LABEL_34:
  v35 = kdu_kernels::get_energy_gain((kdu_kernels *)v44, v25, 0, 0);
  v36 = sqrt(v35 * kdu_kernels::get_energy_gain((kdu_kernels *)v44, v24, 0, 0));
  kdu_params::set((uint64_t)a1, "Qabs_steps", 0, 0, (float)(a6 / v36));
  return kdu_kernels::reset((kdu_kernels *)v44);
}

void sub_187F4304C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  kdu_kernels::reset((kdu_kernels *)va);
  _Unwind_Resume(a1);
}

void rgn_params::rgn_params(rgn_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 256;
  *((_BYTE *)this + 42) = 0;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 16842753;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BABCE0;
  *((_QWORD *)this + 1) = "RGN";
  kdu_params::define_attribute(this, "Rshift", "Region of interest up-shift value.  All subband samples which are involved in the synthesis of any image sample which belongs to the foreground region of an ROI mask will be effectively shifted up (scaled by two the power of this shift value) prior to quantization.  The region geometry is specified independently and is not explicitly signalled through the code-stream; instead, this shift must be sufficiently large to enable the decoder to separate the foregrou"
    "nd and background on the basis of the shifted sample amplitudes alone.  You will receive an appropriate error messag"
    "e if the shift value is too small.\n"
    "\t\t[Default is 0]",
    "I",
    0);
  kdu_params::define_attribute(this, "Rlevels", "Number of initial (highest frequency) DWT levels through which to propagate geometric information concerning the foreground region for ROI processing.  Additional levels (i.e., lower frequency subbands) will be treated as belonging entirely to the foreground region.\n\t\t[Default is 4]", "I", 0);
}

void sub_187F43188(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

const char *rgn_params::copy_with_xforms(rgn_params *this, kdu_params *a2)
{
  const char *result;
  int v4;

  v4 = 0;
  result = (const char *)kdu_params::get(a2, "Rshift", 0, 0, &v4, 0, 1, 1);
  if ((_DWORD)result)
    return kdu_params::set(this, "Rshift", 0, 0, (int *)v4);
  return result;
}

uint64_t rgn_params::write_marker_segment(rgn_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v4;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  _BOOL4 v13;
  int v14;
  int v15;
  int v16;
  _OWORD v17[2];
  uint64_t v18;
  unsigned __int8 v19[4];
  char v20[16];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a4 || (*((_DWORD *)this + 5) & 0x80000000) != 0)
    return 0;
  *(_DWORD *)v19 = 0;
  if ((kdu_params::get(this, "Rshift", 0, 0, (int *)v19, 1, 1, 1) & 1) == 0)
    *(_DWORD *)v19 = 0;
  if (a3)
  {
    *(_DWORD *)v20 = 0;
    v9 = kdu_params::get(a3, "Rshift", 0, 0, (int *)v20, 1, 1, 1);
    v4 = 0;
    if (v9)
      v10 = *(_DWORD *)v20;
    else
      v10 = 0;
    v11 = *(_DWORD *)v19;
    if (*(_DWORD *)v19 == v10)
      return v4;
    goto LABEL_14;
  }
  v11 = *(_DWORD *)v19;
  if (!*(_DWORD *)v19)
    return 0;
LABEL_14:
  if (v11 >= 0x100)
  {
    v18 = 0;
    memset(v17, 0, sizeof(v17));
    kdu_error::kdu_error((kdu_error *)v17, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v17[0] + 16))(v17, "Illegal ROI up-shift, ");
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    *(_OWORD *)v20 = 0u;
    if (BYTE8(v17[0]))
      sprintf(v20, "%x");
    else
      sprintf(v20, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v17[0] + 16))(v17, v20);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v17[0] + 16))(v17, ". Legal range is from 0 to 255!");
    kdu_error::~kdu_error((kdu_error *)v17);
  }
  v12 = *((_DWORD *)this + 8);
  if (v12 < 257)
    v4 = 7;
  else
    v4 = 8;
  if (a2)
  {
    v13 = v12 < 257;
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 94);
    kdu_output::put(a2, 0);
    kdu_output::put(a2, v4 - 2);
    v14 = *((_DWORD *)this + 5);
    if (v13)
    {
      v15 = kdu_output::put(a2, v14) + 4;
    }
    else
    {
      kdu_output::put(a2, SBYTE1(v14));
      kdu_output::put(a2, v14);
      v15 = 6;
    }
    v16 = kdu_output::put(a2, 0);
    if ((_DWORD)v4 != v16 + v15 + kdu_output::put(a2, v19[0]))
      rgn_params::write_marker_segment();
  }
  return v4;
}

void sub_187F4347C(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F43488()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL rgn_params::check_marker_segment(rgn_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  _BOOL8 result;
  int v8;

  result = a2 == 65374 && a3 > 1;
  if (result)
  {
    v8 = *a4;
    *a5 = v8;
    if (*((int *)this + 8) >= 257)
      *a5 = a4[1] | (v8 << 8);
  }
  return result;
}

uint64_t rgn_params::read_marker_segment(rgn_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  int v6;
  int v8;
  int v9;
  int v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  _QWORD *exception;
  _QWORD *v16;
  _OWORD v17[2];
  uint64_t v18;
  char v19[16];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a2 != 65374 || a5 != 0)
    return 0;
  v6 = *((_DWORD *)this + 5);
  if (v6 < 0)
    return 0;
  v8 = *((_DWORD *)this + 8);
  if (v8 <= 256)
    v9 = 1;
  else
    v9 = 2;
  if (v9 > a3)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = a4;
    __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
  }
  v11 = a4 + 1;
  v10 = *a4;
  if (v8 >= 257)
  {
    v11 = a4 + 2;
    v10 = a4[1] | (v10 << 8);
  }
  if (v10 != v6)
    return 0;
  v12 = &a4[a3];
  if (v12 - v11 <= 0)
  {
    v16 = __cxa_allocate_exception(8uLL);
    *v16 = v11;
    goto LABEL_29;
  }
  v13 = v11 + 1;
  if (*v11)
  {
    *(_QWORD *)&v21 = 0;
    *(_OWORD *)v19 = 0u;
    v20 = 0u;
    kdu_error::kdu_error((kdu_error *)v19, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v19 + 16))(v19, "Encountered non-Part1 RGN marker segment!");
    kdu_error::~kdu_error((kdu_error *)v19);
  }
  if (v12 - v13 <= 0)
  {
    v16 = __cxa_allocate_exception(8uLL);
    *v16 = v13;
LABEL_29:
    __cxa_throw(v16, MEMORY[0x1E0DE4E60], 0);
  }
  kdu_params::set(this, "Rshift", 0, 0, (int *)v11[1]);
  if (v11 + 2 != v12)
  {
    v18 = 0;
    memset(v17, 0, sizeof(v17));
    kdu_error::kdu_error((kdu_error *)v17, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v17[0] + 16))(v17, "Malformed RGN marker segment encountered. The final ");
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    *(_OWORD *)v19 = 0u;
    if (BYTE8(v17[0]))
      sprintf(v19, "%x");
    else
      sprintf(v19, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v17[0] + 16))(v17, v19);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v17[0] + 16))(v17, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)v17);
  }
  return 1;
}

void sub_187F43724(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F43734(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, __int128 a12, uint64_t a13)
{
  _Unwind_Exception *v13;
  int v14;

  if (v14 == 1)
  {
    __cxa_begin_catch(v13);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(a11 + 16))(&a11, "Malformed RGN marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(v13);
}

void rgn_params::finalize(rgn_params *this, char a2)
{
  int v3;
  int v4;
  _OWORD v5[2];
  uint64_t v6;
  int v7;
  char v8[16];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if ((a2 & 1) == 0)
  {
    v7 = 0;
    if ((kdu_params::get(this, "Rlevels", 0, 0, &v7, 1, 1, 1) & 1) == 0)
      kdu_params::set(this, "Rlevels", 0, 0, (int *)4);
    v3 = kdu_params::get(this, "Rshift", 0, 0, &v7, 1, 1, 1);
    if (v7 > 37)
      v4 = v3;
    else
      v4 = 0;
    if (v4 == 1)
    {
      v6 = 0;
      memset(v5, 0, sizeof(v5));
      kdu_warning::kdu_warning((kdu_warning *)v5, "Kakadu Core Warning:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "Up-shift values in the RGN marker segment should not need to exceed 37 under any circumstances.  The use of a larger value, ");
      v11 = 0u;
      v12 = 0u;
      v9 = 0u;
      v10 = 0u;
      *(_OWORD *)v8 = 0u;
      if (BYTE8(v5[0]))
        sprintf(v8, "%x");
      else
        sprintf(v8, "%d");
      (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v5[0] + 16))(v5, v8);
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, " in this case, may cause problems.");
      kdu_warning::~kdu_warning((kdu_warning *)v5);
    }
  }
}

void sub_187F43960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

void poc_params::poc_params(poc_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 1;
  *((_BYTE *)this + 42) = 0;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BABC20;
  *((_QWORD *)this + 1) = "POC";
}

void sub_187F43A20(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t poc_params::copy_with_xforms(poc_params *this, kdu_params *a2, int a3)
{
  uint64_t result;
  int v7;
  BOOL v8;
  int v9[2];
  int v10[2];
  int v11[2];

  *(_QWORD *)v10 = 0;
  *(_QWORD *)v11 = 0;
  *(_QWORD *)v9 = 0;
  result = kdu_params::get(a2, "Porder", 0, 0, &v11[1], 0, 1, 1);
  if ((_DWORD)result)
  {
    result = kdu_params::get(a2, "Porder", 0, 0, &v11[1], 0, 0, 1);
    if ((_DWORD)result)
    {
      v7 = 0;
      do
      {
        result = kdu_params::get(a2, "Porder", v7, 1, v11, 0, 0, 1);
        if (!(_DWORD)result)
          break;
        result = kdu_params::get(a2, "Porder", v7, 2, &v10[1], 0, 0, 1);
        if (!(_DWORD)result)
          break;
        result = kdu_params::get(a2, "Porder", v7, 3, v10, 0, 0, 1);
        if (!(_DWORD)result)
          break;
        result = kdu_params::get(a2, "Porder", v7, 4, &v9[1], 0, 0, 1);
        if (!(_DWORD)result)
          break;
        result = kdu_params::get(a2, "Porder", v7, 5, v9, 0, 0, 1);
        if (!(_DWORD)result)
          break;
        v11[0] = (v11[0] - a3) & ~((v11[0] - a3) >> 31);
        v8 = v9[1] <= a3;
        v9[1] -= a3;
        if (v8)
        {
          v9[1] = 1;
          v10[1] = 0;
        }
        kdu_params::set(this, "Porder", v7, 0, (int *)v11[1]);
        kdu_params::set(this, "Porder", v7, 1, (int *)v11[0]);
        kdu_params::set(this, "Porder", v7, 2, (int *)v10[1]);
        kdu_params::set(this, "Porder", v7, 3, (int *)v10[0]);
        kdu_params::set(this, "Porder", v7, 4, (int *)v9[1]);
        kdu_params::set(this, "Porder", v7++, 5, (int *)v9[0]);
        result = kdu_params::get(a2, "Porder", v7, 0, &v11[1], 0, 0, 1);
      }
      while ((result & 1) != 0);
    }
  }
  return result;
}

uint64_t poc_params::write_marker_segment(poc_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  unsigned int v7;
  int v8;
  int v9;
  kdu_params *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  char v28;
  char v29;
  kdu_params *v30;
  int v31;
  int v32;
  int v33;
  __int16 v34;
  uint64_t result;
  __int16 v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  char v42;
  char v43;
  int v44;
  char v45;
  int v46;
  unsigned int v47;
  int v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  int v52;
  unsigned __int8 v53[8];
  unsigned __int8 v54[8];
  unsigned __int8 v55[8];
  char v56[16];
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 6) != a4)
    return 0;
  *(_QWORD *)v54 = 0;
  *(_QWORD *)v55 = 0;
  *(_QWORD *)v53 = 0;
  v7 = -1;
  do
    ++v7;
  while ((kdu_params::get(this, "Porder", v7, 0, (int *)&v55[4], 0, 1, 1) & 1) != 0);
  if (!v7)
    return 0;
  if (a3)
  {
    v8 = *((_DWORD *)a3 + 4);
    v9 = *((_DWORD *)this + 4);
    if (v8 != v9)
    {
      if ((v8 & 0x80000000) == 0 || *((_DWORD *)this + 6))
        poc_params::write_marker_segment();
      v10 = (kdu_params *)kdu_params::access_relation(this, v9, *((_DWORD *)this + 5), 1, 1);
      if (!v10 || (kdu_params::get(v10, "Porder", 0, 0, (int *)&v55[4], 1, 1, 1) & 1) == 0)
      {
        v11 = 0;
        do
        {
          if (!kdu_params::get(this, "Porder", v11, 0, (int *)&v55[4], 1, 1, 1)
            || !kdu_params::get(this, "Porder", v11, 1, (int *)v55, 1, 1, 1)
            || !kdu_params::get(this, "Porder", v11, 2, (int *)&v54[4], 1, 1, 1)
            || !kdu_params::get(this, "Porder", v11, 3, (int *)v54, 1, 1, 1)
            || !kdu_params::get(this, "Porder", v11, 4, (int *)&v53[4], 1, 1, 1)
            || (kdu_params::get(this, "Porder", v11, 5, (int *)v53, 1, 1, 1) & 1) == 0)
          {
            *(_QWORD *)&v58 = 0;
            *(_OWORD *)v56 = 0u;
            v57 = 0u;
            kdu_error::kdu_error((kdu_error *)v56, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v56 + 16))(v56, "Information required to write POC marker segment is not currently complete!");
            kdu_error::~kdu_error((kdu_error *)v56);
          }
          v12 = *(_DWORD *)&v55[4];
          *(_DWORD *)v56 = 0;
          v13 = kdu_params::get(a3, "Porder", v11, 0, (int *)v56, 1, 1, 1);
          v14 = *(_DWORD *)v56 == v12 ? v13 : 0;
          if (v14 != 1)
            return 0;
          v15 = *(_DWORD *)v55;
          *(_DWORD *)v56 = 0;
          v16 = kdu_params::get(a3, "Porder", v11, 1, (int *)v56, 1, 1, 1);
          v17 = *(_DWORD *)v56 == v15 ? v16 : 0;
          if (v17 != 1)
            return 0;
          v18 = *(_DWORD *)&v54[4];
          *(_DWORD *)v56 = 0;
          v19 = kdu_params::get(a3, "Porder", v11, 2, (int *)v56, 1, 1, 1);
          v20 = *(_DWORD *)v56 == v18 ? v19 : 0;
          if (v20 != 1)
            return 0;
          v21 = *(_DWORD *)v54;
          *(_DWORD *)v56 = 0;
          v22 = kdu_params::get(a3, "Porder", v11, 3, (int *)v56, 1, 1, 1);
          v23 = *(_DWORD *)v56 == v21 ? v22 : 0;
          if (v23 != 1)
            return 0;
          v24 = *(_DWORD *)&v53[4];
          *(_DWORD *)v56 = 0;
          v25 = kdu_params::get(a3, "Porder", v11, 4, (int *)v56, 1, 1, 1);
          v26 = *(_DWORD *)v56 == v24 ? v25 : 0;
          if (v26 != 1)
            return 0;
          v27 = *(_DWORD *)v53;
          *(_DWORD *)v56 = 0;
          v28 = kdu_params::get(a3, "Porder", v11, 5, (int *)v56, 1, 1, 1);
          v29 = *(_DWORD *)v56 == v27 ? v28 : 0;
          if ((v29 & 1) == 0)
            return 0;
        }
        while (v7 != ++v11);
      }
    }
  }
  v52 = 0;
  v30 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
  if (!v30 || (kdu_params::get(v30, "Scomponents", 0, 0, &v52, 1, 1, 1) & 1) == 0)
    poc_params::write_marker_segment();
  v31 = v52;
  if (v52 >= 257)
    v32 = 0x4000;
  else
    v32 = 256;
  if (v52 >= 257)
    v33 = 9;
  else
    v33 = 7;
  v34 = v33 * v7;
  result = v33 * v7 + 4;
  if (a2)
  {
    v47 = v33 * v7 + 4;
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 95);
    v36 = v34 + 2;
    kdu_output::put(a2, SHIBYTE(v36));
    kdu_output::put(a2, v36);
    v37 = 0;
    if (v7 <= 1)
      v38 = 1;
    else
      v38 = v7;
    v48 = v38;
    v39 = 4;
    while (1)
    {
      if (!kdu_params::get(this, "Porder", v37, 0, (int *)&v55[4], 1, 1, 1)
        || !kdu_params::get(this, "Porder", v37, 1, (int *)v55, 1, 1, 1)
        || !kdu_params::get(this, "Porder", v37, 2, (int *)&v54[4], 1, 1, 1)
        || !kdu_params::get(this, "Porder", v37, 3, (int *)v54, 1, 1, 1)
        || !kdu_params::get(this, "Porder", v37, 4, (int *)&v53[4], 1, 1, 1)
        || (kdu_params::get(this, "Porder", v37, 5, (int *)v53, 1, 1, 1) & 1) == 0)
      {
        *(_QWORD *)&v58 = 0;
        *(_OWORD *)v56 = 0u;
        v57 = 0u;
        kdu_error::kdu_error((kdu_error *)v56, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v56 + 16))(v56, "Information required to write POC marker segment is not currently complete!");
        kdu_error::~kdu_error((kdu_error *)v56);
      }
      if (*(_DWORD *)&v55[4] >= 0x21u)
      {
        v51 = 0;
        v49 = 0u;
        v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, "Illegal lower bound, ");
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        *(_OWORD *)v56 = 0u;
        if (BYTE8(v49))
          sprintf(v56, "%x");
        else
          sprintf(v56, "%d");
        (*(void (**)(__int128 *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, ", for resolution level indices in progression order change attribute.  Legal range is from 0 to 32.");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if (*(int *)v54 > 33 || *(int *)v54 <= *(int *)&v55[4])
      {
        v51 = 0;
        v49 = 0u;
        v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, "Illegal upper bound (exclusive), ");
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        *(_OWORD *)v56 = 0u;
        if (BYTE8(v49))
          sprintf(v56, "%x");
        else
          sprintf(v56, "%d");
        (*(void (**)(__int128 *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, ", for resolution level indices in progression order change attribute.  Legal range is from the lower bound + 1 to 33.");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if ((*(_DWORD *)v55 & 0x80000000) != 0 || *(int *)v55 >= v32)
      {
        v51 = 0;
        v49 = 0u;
        v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, "Illegal lower bound, ");
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        *(_OWORD *)v56 = 0u;
        if (BYTE8(v49))
          sprintf(v56, "%x");
        else
          sprintf(v56, "%d");
        (*(void (**)(__int128 *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, ", for component indices in progression order change attribute.  Legal range is from 0 to ");
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        *(_OWORD *)v56 = 0u;
        if (BYTE8(v49))
          sprintf(v56, "%x");
        else
          sprintf(v56, "%d");
        (*(void (**)(__int128 *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, ".");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if (*(int *)&v53[4] <= *(int *)v55 || *(int *)&v53[4] > v32)
      {
        v51 = 0;
        v49 = 0u;
        v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, "Illegal upper bound (exclusive), ");
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        *(_OWORD *)v56 = 0u;
        if (BYTE8(v49))
          sprintf(v56, "%x");
        else
          sprintf(v56, "%d");
        (*(void (**)(__int128 *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, ", for component indices in progression order change attribute.  Legal range is from the lower bound + 1 to ");
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        *(_OWORD *)v56 = 0u;
        if (BYTE8(v49))
          sprintf(v56, "%x");
        else
          sprintf(v56, "%d");
        (*(void (**)(__int128 *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, ".");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if (*(_DWORD *)&v54[4] >= 0x10000u)
      {
        v51 = 0;
        v49 = 0u;
        v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, "Illegal upper bound (exclusive), ");
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        *(_OWORD *)v56 = 0u;
        if (BYTE8(v49))
          sprintf(v56, "%x");
        else
          sprintf(v56, "%d");
        (*(void (**)(__int128 *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, ", for layer indices in progression order change attribute.  Legal range is from 0 to ");
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        *(_OWORD *)v56 = 0u;
        if (BYTE8(v49))
          sprintf(v56, "%x");
        else
          sprintf(v56, "%d");
        (*(void (**)(__int128 *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(__int128 *, const char *))(v49 + 16))(&v49, ".");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if (v31 > 256 || *(int *)&v53[4] < v32)
      {
        v40 = kdu_output::put(a2, v55[4]) + v39;
        if (v31 >= 257)
        {
          v42 = v55[0];
          kdu_output::put(a2, v55[1]);
          kdu_output::put(a2, v42);
          v41 = 2;
          goto LABEL_107;
        }
      }
      else
      {
        *(_DWORD *)&v53[4] = 0;
        v40 = kdu_output::put(a2, v55[4]) + v39;
      }
      v41 = kdu_output::put(a2, v55[0]);
LABEL_107:
      v43 = v54[4];
      kdu_output::put(a2, v54[5]);
      kdu_output::put(a2, v43);
      v44 = kdu_output::put(a2, v54[0]);
      v45 = v53[4];
      if (v31 >= 257)
      {
        kdu_output::put(a2, v53[5]);
        kdu_output::put(a2, v45);
        v46 = 2;
      }
      else
      {
        v46 = kdu_output::put(a2, v53[4]);
      }
      v39 = v40 + v41 + v44 + v46 + kdu_output::put(a2, v53[0]) + 2;
      if (v48 == ++v37)
      {
        result = v47;
        if (v47 != v39)
          poc_params::write_marker_segment();
        return result;
      }
    }
  }
  return result;
}

void sub_187F44884(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F44890(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  _Unwind_Exception *v23;

  _Unwind_Resume(v23);
}

BOOL poc_params::check_marker_segment(poc_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  *a5 = -1;
  return a2 == 65375;
}

BOOL poc_params::read_marker_segment(poc_params *this, int a2, int a3, unsigned __int8 *a4)
{
  kdu_params *v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  int *v15;
  unsigned __int8 *v16;
  unsigned int v17;
  BOOL v18;
  uint64_t v19;
  _QWORD *exception;
  _QWORD *v22;
  _OWORD v23[2];
  uint64_t v24;
  int v25;
  char v26[16];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a2 != 65375)
    return a2 == 65375;
  v25 = 0;
  v8 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
  if (!v8 || (kdu_params::get(v8, "Scomponents", 0, 0, &v25, 1, 1, 1) & 1) == 0)
    poc_params::read_marker_segment();
  v9 = v25;
  if (v25 < 257)
    v10 = 1;
  else
    v10 = 2;
  v11 = a3 / (2 * (int)v10 + 5);
  if (v11 < 1)
  {
LABEL_34:
    exception = __cxa_allocate_exception(8uLL);
    *exception = a4;
    goto LABEL_36;
  }
  v12 = 0;
  v13 = &a4[a3];
  do
  {
    if (v13 - a4 <= 0)
      goto LABEL_34;
    v14 = a4 + 1;
    kdu_params::set(this, "Porder", v12, 0, (int *)*a4);
    if (v13 - (a4 + 1) < v10
      || ((v15 = (int *)a4[1], v9 >= 257)
        ? (v14 = a4 + 3, v15 = (int *)(a4[2] | ((_DWORD)v15 << 8)))
        : (int *)(v14 = a4 + 2),
          kdu_params::set(this, "Porder", v12, 1, v15),
          v13 - v14 <= 1))
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = v14;
LABEL_36:
      __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
    }
    a4 = v14 + 2;
    kdu_params::set(this, "Porder", v12, 2, (int *)__rev16(*(unsigned __int16 *)v14));
    if (v13 - (v14 + 2) <= 0)
      goto LABEL_34;
    kdu_params::set(this, "Porder", v12, 3, (int *)v14[2]);
    v16 = v14 + 3;
    if (v13 - (v14 + 3) < v10
      || ((v17 = v14[3], v9 >= 257) ? (unsigned __int8 *)(v16 = v14 + 5, v17 = v14[4] | (v17 << 8)) : (v16 = v14 + 4),
          !v17 ? (v18 = v9 < 257) : (v18 = 0),
          !v18 ? (v19 = v17) : (v19 = 256),
          kdu_params::set(this, "Porder", v12, 4, (int *)v19),
          v13 - v16 <= 0))
    {
      v22 = __cxa_allocate_exception(8uLL);
      *v22 = v16;
      __cxa_throw(v22, MEMORY[0x1E0DE4E60], 0);
    }
    kdu_params::set(this, "Porder", v12, 5, (int *)*v16);
    a4 = v16 + 1;
    ++v12;
  }
  while (v11 != v12);
  if (a4 != v13)
  {
    v24 = 0;
    memset(v23, 0, sizeof(v23));
    kdu_error::kdu_error((kdu_error *)v23, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v23[0] + 16))(v23, "Malformed POC marker segment encountered. The final ");
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    *(_OWORD *)v26 = 0u;
    if (BYTE8(v23[0]))
      sprintf(v26, "%x");
    else
      sprintf(v26, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v23[0] + 16))(v23, v26);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v23[0] + 16))(v23, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)v23);
  }
  return a2 == 65375;
}

void sub_187F44C7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, __int128 a12, uint64_t a13)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(a11 + 16))(&a11, "Malformed POC marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(a1);
}

void sub_187F44D00()
{
  __cxa_end_catch();
  JUMPOUT(0x187F44BD8);
}

void sub_187F44D08(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F44D14()
{
  __cxa_end_catch();
  JUMPOUT(0x187F44C98);
}

void crg_params::crg_params(crg_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *(_DWORD *)((char *)this + 38) = 0;
  *((_BYTE *)this + 42) = 0;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_WORD *)this + 18) = 1;
  *((_BYTE *)this + 104) = 0;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BAB7D0;
  *((_QWORD *)this + 1) = "CRG";
}

void sub_187F44DC4(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t crg_params::copy_with_xforms(crg_params *this, kdu_params *a2, int a3, int a4, int a5, char a6, int a7)
{
  kdu_params *v11;
  uint64_t v12;
  kdu_params *v13;
  int32x2_t v14;
  int32x2_t v15;
  __int32 v16;
  __int32 v17;
  uint64_t result;
  int v19;
  int v20;
  int v22;
  float v23;
  float v24;
  uint64_t v25;
  int v26[2];
  int v27[2];
  int v28[2];
  int v29[2];

  if ((a6 & 1) != 0 || a7)
    return kdu_params::delete_unparsed_attribute((uint64_t)this, "CRGoffset");
  v11 = (kdu_params *)kdu_params::access_cluster(a2, "SIZ");
  v12 = kdu_params::access_cluster(this, "SIZ");
  if (!v11 || (v13 = (kdu_params *)v12) == 0)
    crg_params::copy_with_xforms();
  *(_QWORD *)v28 = 0;
  *(_QWORD *)v29 = 0;
  *(_QWORD *)v26 = 0;
  *(_QWORD *)v27 = 0;
  if (!kdu_params::get(v11, "Ssize", 0, 0, v29, 1, 1, 1)
    || !kdu_params::get(v11, "Ssize", 0, 1, &v29[1], 1, 1, 1)
    || !kdu_params::get(v11, "Sorigin", 0, 0, v28, 1, 1, 1)
    || !kdu_params::get(v11, "Sorigin", 0, 1, &v28[1], 1, 1, 1)
    || !kdu_params::get(v13, "Ssize", 0, 0, v27, 1, 1, 1)
    || !kdu_params::get(v13, "Ssize", 0, 1, &v27[1], 1, 1, 1)
    || !kdu_params::get(v13, "Sorigin", 0, 0, v26, 1, 1, 1)
    || (kdu_params::get(v13, "Sorigin", 0, 1, &v26[1], 1, 1, 1) & 1) == 0)
  {
    crg_params::copy_with_xforms();
  }
  v14 = vsub_s32(*(int32x2_t *)v29, *(int32x2_t *)v28);
  *(int32x2_t *)v29 = v14;
  v15 = vsub_s32(*(int32x2_t *)v27, *(int32x2_t *)v26);
  *(int32x2_t *)v27 = v15;
  v16 = v14.i32[0];
  if (a5)
  {
    v29[0] = v14.i32[1];
    v29[1] = v14.i32[0];
    v17 = v14.i32[1];
  }
  else
  {
    v17 = v14.i32[0];
    v16 = v14.i32[1];
  }
  v19 = v16 / v15.i32[1];
  v20 = v17 / v15.i32[0];
  if (v16 / v15.i32[1] < 1 || v20 <= 0)
    crg_params::copy_with_xforms();
  v25 = 0;
  result = kdu_params::get(a2, "CRGoffset", 0, a5, (float *)&v25 + 1, 0, 0, 1);
  if ((_DWORD)result)
  {
    v22 = 0;
    v23 = (float)v20;
    do
    {
      result = kdu_params::get(a2, "CRGoffset", v22, a5 ^ 1u, (float *)&v25, 0, 0, 1);
      if (!(_DWORD)result)
        break;
      v24 = *((float *)&v25 + 1) / v23;
      *(float *)&v25 = *(float *)&v25 / (float)v19;
      *((float *)&v25 + 1) = *((float *)&v25 + 1) / v23;
      if (v22 >= a3)
      {
        kdu_params::set((uint64_t)this, "CRGoffset", v22 - a3, 0, v24);
        kdu_params::set((uint64_t)this, "CRGoffset", v22 - a3, 1, *(float *)&v25);
      }
      result = kdu_params::get(a2, "CRGoffset", ++v22, a5, (float *)&v25 + 1, 0, 0, 1);
    }
    while ((result & 1) != 0);
    if (v22)
    {
      if (v22 <= a3)
      {
        kdu_params::set((uint64_t)this, "CRGoffset", 0, 0, *((float *)&v25 + 1));
        return kdu_params::set((uint64_t)this, "CRGoffset", 0, 1, *(float *)&v25);
      }
    }
  }
  return result;
}

uint64_t crg_params::write_marker_segment(crg_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  kdu_params *v7;
  __int16 v8;
  uint64_t v9;
  int v10;
  int v11;
  BOOL v12;
  BOOL v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  _OWORD v19[2];
  uint64_t v20;
  int v21;
  uint64_t v22;
  char v23[16];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a4)
    return 0;
  if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
    return 0;
  v22 = 0;
  if (!kdu_params::get(this, "CRGoffset", 0, 0, (float *)&v22, 1, 1, 1))
    return 0;
  if (a3)
    crg_params::write_marker_segment();
  v21 = 0;
  v7 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
  if (!v7 || (kdu_params::get(v7, "Scomponents", 0, 0, &v21, 1, 1, 1) & 1) == 0)
    crg_params::write_marker_segment();
  v8 = 4 * v21;
  v9 = (4 * v21 + 4);
  if (a2)
  {
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 99);
    kdu_output::put(a2, SHIBYTE(v8));
    kdu_output::put(a2, v8 | 2);
    if (v21 < 1)
    {
      v11 = 4;
    }
    else
    {
      v10 = 0;
      v11 = 4;
      do
      {
        if (!kdu_params::get(this, "CRGoffset", v10, 0, (float *)&v22, 1, 1, 1)
          || (kdu_params::get(this, "CRGoffset", v10, 1, (float *)&v22 + 1, 1, 1, 1) & 1) == 0)
        {
          *(_QWORD *)&v25 = 0;
          *(_OWORD *)v23 = 0u;
          v24 = 0u;
          kdu_error::kdu_error((kdu_error *)v23, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v23 + 16))(v23, "Component registration information incomplete!");
          kdu_error::~kdu_error((kdu_error *)v23);
        }
        v12 = *((float *)&v22 + 1) >= 0.0 && *((float *)&v22 + 1) < 1.0;
        if (!v12 || (*(float *)&v22 >= 0.0 ? (v13 = *(float *)&v22 < 1.0) : (v13 = 0), !v13))
        {
          v20 = 0;
          memset(v19, 0, sizeof(v19));
          kdu_error::kdu_error((kdu_error *)v19, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v19[0] + 16))(v19, "Illegal component registration offsets, {");
          v26 = 0u;
          v27 = 0u;
          v24 = 0u;
          v25 = 0u;
          *(_OWORD *)v23 = 0u;
          sprintf(v23, "%f", *(float *)&v22);
          (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v19[0] + 16))(v19, v23);
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v19[0] + 16))(v19, ",");
          v26 = 0u;
          v27 = 0u;
          v24 = 0u;
          v25 = 0u;
          *(_OWORD *)v23 = 0u;
          sprintf(v23, "%f", *((float *)&v22 + 1));
          (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v19[0] + 16))(v19, v23);
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v19[0] + 16))(v19, "}.  Legal range is from 0.0 to 1.0 (exclusive).");
          kdu_error::~kdu_error((kdu_error *)v19);
        }
        v14 = vcvtms_s32_f32((float)(*((float *)&v22 + 1) * 65536.0) + 0.5);
        if (v14 >= 0xFFFF)
          v15 = -1;
        else
          v15 = v14;
        v16 = vcvtms_s32_f32((float)(*(float *)&v22 * 65536.0) + 0.5);
        if (v16 >= 0xFFFF)
          v17 = -1;
        else
          v17 = v16;
        kdu_output::put(a2, SHIBYTE(v15));
        kdu_output::put(a2, v15);
        kdu_output::put(a2, SHIBYTE(v17));
        kdu_output::put(a2, v17);
        v11 += 4;
        ++v10;
      }
      while (v10 < v21);
    }
    if ((_DWORD)v9 != v11)
      crg_params::write_marker_segment();
  }
  return v9;
}

void sub_187F45554(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F45560(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

BOOL crg_params::check_marker_segment(crg_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  *a5 = -1;
  return a2 == 65379;
}

uint64_t crg_params::read_marker_segment(crg_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  BOOL v5;
  kdu_params *v10;
  unsigned __int8 *v11;
  int v12;
  uint64_t v13;
  _QWORD *exception;
  _OWORD v15[2];
  uint64_t v16;
  int v17;
  char v18[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v5 = a2 == 65379 && a5 == 0;
  if (!v5 || (*((_DWORD *)this + 5) & 0x80000000) == 0)
    return 0;
  v17 = 0;
  v10 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
  if (!v10 || !kdu_params::get(v10, "Scomponents", 0, 0, &v17, 1, 1, 1))
    crg_params::read_marker_segment();
  v11 = a4;
  if (v17 >= 1)
  {
    v12 = 0;
    v13 = a3;
    v11 = a4;
    while (v13 > 1)
    {
      kdu_params::set((uint64_t)this, "CRGoffset", v12, 1, (float)((float)(int)__rev16(*(unsigned __int16 *)v11) * 0.000015259));
      if (v13 - 2 <= 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        *exception = v11 + 2;
LABEL_24:
        __cxa_throw(exception, MEMORY[0x1E0DE4E60], 0);
      }
      kdu_params::set((uint64_t)this, "CRGoffset", v12, 0, (float)((float)(int)__rev16(*((unsigned __int16 *)v11 + 1)) * 0.000015259));
      v11 += 4;
      ++v12;
      v13 -= 4;
      if (v12 >= v17)
        goto LABEL_16;
    }
    exception = __cxa_allocate_exception(8uLL);
    *exception = v11;
    goto LABEL_24;
  }
LABEL_16:
  if (v11 != &a4[a3])
  {
    v16 = 0;
    memset(v15, 0, sizeof(v15));
    kdu_error::kdu_error((kdu_error *)v15, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v15[0] + 16))(v15, "Malformed CRG marker segment encountered. The final ");
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    *(_OWORD *)v18 = 0u;
    if (BYTE8(v15[0]))
      sprintf(v18, "%x");
    else
      sprintf(v18, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v15[0] + 16))(v15, v18);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v15[0] + 16))(v15, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)v15);
  }
  return 1;
}

void sub_187F45814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, __int128 a12, uint64_t a13)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(a11 + 16))(&a11, "Malformed CRG marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(a1);
}

void sub_187F45890()
{
  __cxa_end_catch();
  JUMPOUT(0x187F457CCLL);
}

void sub_187F45898(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F458A4()
{
  __cxa_end_catch();
  JUMPOUT(0x187F45830);
}

void org_params::org_params(org_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18820D300;
  *((_WORD *)this + 20) = 1;
  *((_BYTE *)this + 42) = 0;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 9) = this;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = this;
  *((_BYTE *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((_QWORD *)this + 14) = 0;
  *(_QWORD *)this = &off_1E1BABBC0;
  *((_QWORD *)this + 1) = "ORG";
  kdu_params::define_attribute(this, "ORGgen_plt", "Requests the insertion of packet length information in the header of all tile-parts associated with tiles for which this attribute is turned on (has a value of \"yes\").  The PLT marker segments written into the relevant tile-part headers will hold the lengths of those packets which belong to the same tile-part.  Note that the cost of any PLT marker segments generated as a result of this attribute being enabled will not be taken into account during rate allocation.  This means that the resulting code-streams will generally be a little larger than one might expect; however, "
    "this is probably a reasonable policy, since the PLT marker segments may be removed without losing any information.",
    "B",
    4);
  kdu_params::define_attribute(this, "ORGgen_tlm", "Requests the insertion of TLM (tile-part-length) marker segments in the main header, to facilitate random access to the code-stream.  This attribute takes a single integer-valued parameter, which identifies the maximum number of tile-parts which will be written to the code-stream for each tile.  The reason for including this parameter is that space for the TLM information must be reserved ahead of time; once the entire code-stream has been written the generati"
    "on machinery goes back and overwrites this reserved space with actual TLM data.  If the actual number of tile-parts "
    "which are generate is less than the value supplied here, empty tile-parts will be inserted into the code-stream so a"
    "s to use up all of the reserved TLM space.  For this reason, you should try to estimate the maximum number of tile-p"
    "arts you will need as accurately as possible, noting that the actual value may be hard to determine ahead of time if"
    " incremental flushing features are to be employed.  In any event, no JPEG2000 code-stream may have more than 255 til"
    "e-parts.  An error will be generated at run-time if the declared maximum number of tile-parts turns out to be insuff"
    "icient.  You should note that this attribute may be ignored if the target device does not support repositioning functionality.",
    "I",
    4);
}

void sub_187F459A0(_Unwind_Exception *a1)
{
  kdu_params *v1;

  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t org_params::copy_with_xforms(org_params *this, kdu_params *a2)
{
  uint64_t result;
  BOOL v5;
  int v6;

  v6 = 0;
  v5 = 0;
  if (kdu_params::get(a2, "ORGtparts", 0, 0, &v6, 0, 1, 1))
    kdu_params::set(this, "ORGtparts", 0, 0, (int *)v6);
  result = kdu_params::get(a2, "ORGgen_plt", 0, 0, &v5, 0, 1, 1);
  if ((_DWORD)result)
    return kdu_params::set((uint64_t)this, "ORGgen_plt", 0, 0, v5);
  return result;
}

uint64_t kdu_params::write_marker_segment(kdu_params *this, kdu_output *a2, kdu_params *a3)
{
  return 0;
}

uint64_t kdu_params::custom_parse_field(kdu_params *this, const char *a2, const char *a3, int a4, int *a5)
{
  return 0;
}

uint64_t siz_params::new_object(siz_params *this)
{
  return 0;
}

void siz_params::~siz_params(siz_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

mct_params *mct_params::new_object(mct_params *this)
{
  mct_params *v1;

  v1 = (mct_params *)operator new();
  mct_params::mct_params(v1);
  return v1;
}

void sub_187F45AFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40E369BBFALL);
  _Unwind_Resume(a1);
}

void mct_params::~mct_params(mct_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

mcc_params *mcc_params::new_object(mcc_params *this)
{
  mcc_params *v1;

  v1 = (mcc_params *)operator new();
  mcc_params::mcc_params(v1);
  return v1;
}

void sub_187F45B84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void mcc_params::~mcc_params(mcc_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

mco_params *mco_params::new_object(mco_params *this)
{
  mco_params *v1;

  v1 = (mco_params *)operator new();
  mco_params::mco_params(v1);
  return v1;
}

void sub_187F45C0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void mco_params::~mco_params(mco_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

atk_params *atk_params::new_object(atk_params *this)
{
  atk_params *v1;

  v1 = (atk_params *)operator new();
  atk_params::atk_params(v1);
  return v1;
}

void sub_187F45C94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void atk_params::~atk_params(atk_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

cod_params *cod_params::new_object(cod_params *this)
{
  cod_params *v1;

  v1 = (cod_params *)operator new();
  cod_params::cod_params(v1);
  return v1;
}

void sub_187F45D1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void cod_params::~cod_params(cod_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

ads_params *ads_params::new_object(ads_params *this)
{
  ads_params *v1;

  v1 = (ads_params *)operator new();
  ads_params::ads_params(v1);
  return v1;
}

void sub_187F45DA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void ads_params::~ads_params(ads_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

dfs_params *dfs_params::new_object(dfs_params *this)
{
  dfs_params *v1;

  v1 = (dfs_params *)operator new();
  dfs_params::dfs_params(v1);
  return v1;
}

void sub_187F45E30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void dfs_params::~dfs_params(dfs_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

qcd_params *qcd_params::new_object(qcd_params *this)
{
  qcd_params *v1;

  v1 = (qcd_params *)operator new();
  qcd_params::qcd_params(v1);
  return v1;
}

void sub_187F45EBC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void qcd_params::~qcd_params(qcd_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

rgn_params *rgn_params::new_object(rgn_params *this)
{
  rgn_params *v1;

  v1 = (rgn_params *)operator new();
  rgn_params::rgn_params(v1);
  return v1;
}

void sub_187F45F44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void rgn_params::~rgn_params(rgn_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

poc_params *poc_params::new_object(poc_params *this)
{
  poc_params *v1;

  v1 = (poc_params *)operator new();
  poc_params::poc_params(v1);
  return v1;
}

void sub_187F45FCC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void poc_params::~poc_params(poc_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

crg_params *crg_params::new_object(crg_params *this)
{
  crg_params *v1;

  v1 = (crg_params *)operator new();
  crg_params::crg_params(v1);
  return v1;
}

void sub_187F46054(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void crg_params::~crg_params(crg_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

org_params *org_params::new_object(org_params *this)
{
  org_params *v1;

  v1 = (org_params *)operator new();
  org_params::org_params(v1);
  return v1;
}

void sub_187F460DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void org_params::~org_params(org_params *this)
{
  kdu_params::~kdu_params(this);
  JUMPOUT(0x18D761C30);
}

uint64_t org_params::check_marker_segment(org_params *this, unsigned __int16 a2, int a3, unsigned __int8 *a4, int *a5)
{
  return 0;
}

uint64_t org_params::read_marker_segment(org_params *this, unsigned __int16 a2, int a3, unsigned __int8 *a4)
{
  return 0;
}

double _cg_jinit_huff_decoder(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _OWORD *v4;
  int v5;
  __int128 v6;
  double result;

  v2 = (**(uint64_t (***)(void))(a1 + 8))();
  v3 = v2;
  *(_QWORD *)(a1 + 624) = v2;
  *(_QWORD *)v2 = start_pass_huff_decoder;
  *(_QWORD *)(v2 + 16) = finish_pass_huff_0;
  if (*(_DWORD *)(a1 + 316))
  {
    v4 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, (uint64_t)*(int *)(a1 + 56) << 8);
    *(_QWORD *)(a1 + 192) = v4;
    if (*(int *)(a1 + 56) >= 1)
    {
      v5 = 0;
      *(_QWORD *)&v6 = -1;
      *((_QWORD *)&v6 + 1) = -1;
      do
      {
        v4[14] = v6;
        v4[15] = v6;
        v4[12] = v6;
        v4[13] = v6;
        v4[10] = v6;
        v4[11] = v6;
        v4[8] = v6;
        v4[9] = v6;
        v4[6] = v6;
        v4[7] = v6;
        v4[4] = v6;
        v4[5] = v6;
        v4[2] = v6;
        v4[3] = v6;
        *v4 = v6;
        v4[1] = v6;
        v4 += 16;
        ++v5;
      }
      while (v5 < *(_DWORD *)(a1 + 56));
    }
    result = 0.0;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
  }
  else
  {
    result = 0.0;
    *(_OWORD *)(v2 + 112) = 0u;
    *(_OWORD *)(v2 + 128) = 0u;
    *(_OWORD *)(v2 + 144) = 0u;
    *(_OWORD *)(v2 + 160) = 0u;
  }
  return result;
}

void start_pass_huff_decoder(_DWORD *a1)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int *v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  int v21;
  char *v22;
  int v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _DWORD *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void *v54;
  void *v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;

  v2 = *((_QWORD *)a1 + 78);
  v3 = a1[135];
  if (a1[79])
  {
    v4 = a1[136];
    if (v3)
    {
      if (v4 < v3 || v4 > a1[142] || a1[112] != 1)
        goto LABEL_79;
    }
    else if (v4)
    {
      goto LABEL_79;
    }
    v42 = a1[137];
    if (v42)
    {
      v43 = v42 - 1;
      if (v43 != a1[138])
        goto LABEL_79;
    }
    else
    {
      v43 = a1[138];
    }
    if (v43 < 14)
    {
LABEL_80:
      LODWORD(v45) = a1[112];
      if ((int)v45 >= 1)
      {
        v46 = 0;
        do
        {
          v47 = *(int *)(*(_QWORD *)&a1[2 * v46 + 114] + 4);
          v48 = (_DWORD *)(*((_QWORD *)a1 + 24) + (v47 << 8));
          v49 = a1[135];
          if (v49 && (*v48 & 0x80000000) != 0)
          {
            v50 = *(_QWORD *)a1;
            *(_DWORD *)(v50 + 40) = 118;
            *(_DWORD *)(v50 + 48) = v47;
            *(_DWORD *)(*(_QWORD *)a1 + 52) = 0;
            (*(void (**)(_DWORD *, uint64_t))(*(_QWORD *)a1 + 8))(a1, 0xFFFFFFFFLL);
            v49 = a1[135];
          }
          if (v49 <= a1[136])
          {
            v51 = v49;
            do
            {
              if (a1[137] != (v48[v51] & ~((int)v48[v51] >> 31)))
              {
                v52 = *(_QWORD *)a1;
                *(_DWORD *)(v52 + 40) = 118;
                *(_DWORD *)(v52 + 48) = v47;
                *(_DWORD *)(*(_QWORD *)a1 + 52) = v51;
                (*(void (**)(_DWORD *, uint64_t))(*(_QWORD *)a1 + 8))(a1, 0xFFFFFFFFLL);
              }
              v48[v51] = a1[138];
            }
            while (v51++ < (int)a1[136]);
          }
          ++v46;
          v45 = (int)a1[112];
        }
        while (v46 < v45);
      }
      v54 = decode_mcu_AC_first;
      if (a1[135])
      {
        v55 = decode_mcu_AC_refine;
      }
      else
      {
        v54 = decode_mcu_DC_first;
        v55 = decode_mcu_DC_refine;
      }
      if (a1[137])
        v56 = v55;
      else
        v56 = v54;
      *(_QWORD *)(v2 + 8) = v56;
      if ((int)v45 >= 1)
      {
        v57 = 0;
        do
        {
          v58 = *(_QWORD *)&a1[2 * v57 + 114];
          if (a1[135])
          {
            v59 = *(int *)(v58 + 24);
            v60 = v2 + 8 * v59;
            jpeg_make_d_derived_tbl((uint64_t)a1, 0, v59, (_QWORD *)(v60 + 72));
            *(_QWORD *)(v2 + 104) = *(_QWORD *)(v60 + 72);
          }
          else if (!a1[137])
          {
            jpeg_make_d_derived_tbl((uint64_t)a1, 1, *(_DWORD *)(v58 + 20), (_QWORD *)(v2 + 8 * *(int *)(v58 + 20) + 72));
          }
          *(_DWORD *)(v2 + 44 + 4 * v57++) = 0;
        }
        while (v57 < (int)a1[112]);
      }
      *(_DWORD *)(v2 + 40) = 0;
      goto LABEL_105;
    }
LABEL_79:
    v44 = *(_QWORD *)a1;
    *(_DWORD *)(v44 + 40) = 17;
    *(_DWORD *)(v44 + 48) = v3;
    *(_DWORD *)(*(_QWORD *)a1 + 52) = a1[136];
    *(_DWORD *)(*(_QWORD *)a1 + 56) = a1[137];
    *(_DWORD *)(*(_QWORD *)a1 + 60) = a1[138];
    (**(void (***)(_DWORD *))a1)(a1);
    goto LABEL_80;
  }
  if (v3 || a1[137] || a1[138] || ((v62 = a1[136], a1[78]) || v62 <= 63) && v62 != a1[142])
  {
    v5 = *(_QWORD *)a1;
    *(_DWORD *)(v5 + 40) = 125;
    (*(void (**)(_DWORD *, uint64_t))(v5 + 8))(a1, 0xFFFFFFFFLL);
  }
  v6 = decode_mcu_sub;
  if (a1[142] == 63)
    v6 = decode_mcu;
  *(_QWORD *)(v2 + 8) = v6;
  if ((int)a1[112] >= 1)
  {
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)&a1[2 * v7 + 114];
      jpeg_make_d_derived_tbl((uint64_t)a1, 1, *(_DWORD *)(v8 + 20), (_QWORD *)(v2 + 8 * *(int *)(v8 + 20) + 112));
      if (a1[142])
        jpeg_make_d_derived_tbl((uint64_t)a1, 0, *(_DWORD *)(v8 + 24), (_QWORD *)(v2 + 8 * *(int *)(v8 + 24) + 144));
      *(_DWORD *)(v2 + 44 + 4 * v7++) = 0;
    }
    while (v7 < (int)a1[112]);
  }
  if ((int)a1[124] >= 1)
  {
    v9 = 0;
    v10 = v2 + 336;
    do
    {
      v11 = *(int **)&a1[2 * a1[v9 + 125] + 114];
      v12 = v10 + 8 * v9;
      *(_QWORD *)(v12 - 160) = *(_QWORD *)(v2 + 8 * v11[5] + 112);
      v13 = a1[142];
      if (v13)
        v14 = *(_QWORD *)(v2 + 8 * v11[6] + 144);
      else
        v14 = 0;
      *(_QWORD *)(v12 - 80) = v14;
      if (v11[13])
      {
        v17 = v11 + 9;
        v15 = v11[9];
        v16 = v17[1];
        if (v13 > 14)
        {
          if (v13 > 34)
          {
            if (v13 == 35)
            {
              v36 = v16 - 7;
              v37 = v16 - 1;
              v38 = v15 - 7;
              v21 = v15 - 1;
              if (v36 < 0xFFFFFFFA)
                v37 = 5;
              if (v38 < 0xFFFFFFFA)
                v21 = 5;
              v22 = (char *)&jpeg_zigzag_order6 + 24 * v37;
            }
            else
            {
              if (v13 != 48)
                goto LABEL_65;
              v27 = v16 - 8;
              v28 = v16 - 1;
              v29 = v15 - 8;
              v21 = v15 - 1;
              if (v27 < 0xFFFFFFF9)
                v28 = 6;
              if (v29 < 0xFFFFFFF9)
                v21 = 6;
              v22 = (char *)&jpeg_zigzag_order7 + 28 * v28;
            }
          }
          else if (v13 == 15)
          {
            v30 = v16 - 5;
            v31 = v16 - 1;
            v32 = v15 - 5;
            v21 = v15 - 1;
            if (v30 < 0xFFFFFFFC)
              v31 = 3;
            if (v32 < 0xFFFFFFFC)
              v21 = 3;
            v22 = (char *)&jpeg_zigzag_order4 + 16 * v31;
          }
          else
          {
            if (v13 != 24)
              goto LABEL_65;
            v18 = v16 - 6;
            v19 = v16 - 1;
            v20 = v15 - 6;
            v21 = v15 - 1;
            if (v18 < 0xFFFFFFFB)
              v19 = 4;
            if (v20 < 0xFFFFFFFB)
              v21 = 4;
            v22 = (char *)&jpeg_zigzag_order5 + 20 * v19;
          }
          goto LABEL_70;
        }
        if (v13)
        {
          if (v13 == 3)
          {
            v33 = v16 - 3;
            v34 = v16 - 1;
            v35 = v15 - 3;
            v21 = v15 - 1;
            if (v33 < 0xFFFFFFFE)
              v34 = 1;
            if (v35 < 0xFFFFFFFE)
              v21 = 1;
            v22 = (char *)&jpeg_zigzag_order2 + 8 * v34;
            goto LABEL_70;
          }
          if (v13 == 8)
          {
            v24 = v16 - 4;
            v25 = v16 - 1;
            v26 = v15 - 4;
            v21 = v15 - 1;
            if (v24 < 0xFFFFFFFD)
              v25 = 2;
            if (v26 < 0xFFFFFFFD)
              v21 = 2;
            v22 = (char *)&jpeg_zigzag_order3 + 12 * v25;
            goto LABEL_70;
          }
LABEL_65:
          v39 = v16 - 9;
          v40 = v16 - 1;
          v41 = v15 - 9;
          v21 = v15 - 1;
          if (v39 < 0xFFFFFFF8)
            v40 = 7;
          if (v41 < 0xFFFFFFF8)
            v21 = 7;
          v22 = (char *)&jpeg_zigzag_order + 32 * v40;
LABEL_70:
          v23 = *(_DWORD *)&v22[4 * v21] + 1;
          goto LABEL_71;
        }
        v23 = 1;
      }
      else
      {
        v23 = 0;
      }
LABEL_71:
      *(_DWORD *)(v10 + 4 * v9++) = v23;
    }
    while (v9 < (int)a1[124]);
  }
LABEL_105:
  *(_DWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  v61 = a1[93];
  *(_DWORD *)(v2 + 60) = 0;
  *(_DWORD *)(v2 + 64) = v61;
}

uint64_t finish_pass_huff_0(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 624);
  *(_DWORD *)(*(_QWORD *)(result + 616) + 36) += *(_DWORD *)(v1 + 32) / 8;
  *(_DWORD *)(v1 + 32) = 0;
  return result;
}

uint64_t decode_mcu_DC_first(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t result;
  unsigned __int8 **v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _WORD *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  char *v25;
  int v26;
  __int128 v27;
  int v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v4 = *(_QWORD *)(a1 + 624);
  v5 = *(_DWORD *)(a1 + 552);
  if (!*(_DWORD *)(a1 + 372) || *(_DWORD *)(v4 + 64) || (result = process_restart(a1), (_DWORD)result))
  {
    if (!*(_DWORD *)(v4 + 60))
    {
      v33 = a1;
      v7 = *(unsigned __int8 ***)(a1 + 40);
      v8 = *v7;
      v9 = v7[1];
      v29 = *v7;
      v30 = v9;
      v10 = *(_QWORD *)(v4 + 24);
      v11 = *(_DWORD *)(v4 + 32);
      v27 = *(_OWORD *)(v4 + 40);
      v28 = *(_DWORD *)(v4 + 56);
      if (*(int *)(a1 + 496) >= 1)
      {
        v12 = 0;
        v31 = 0;
        v32 = 0;
        while (1)
        {
          v13 = *(_WORD **)(a2 + 8 * v12);
          v14 = *(int *)(a1 + 500 + 4 * v12);
          v15 = *(_QWORD *)(v4 + 8 * *(int *)(*(_QWORD *)(a1 + 8 * v14 + 456) + 20) + 72);
          if (v11 > 7)
            goto LABEL_11;
          result = jpeg_fill_bit_buffer(&v29, v10, v11, 0);
          if (!(_DWORD)result)
            return result;
          v10 = v31;
          v11 = v32;
          if ((int)v32 >= 8)
          {
LABEL_11:
            v17 = v10 >> (v11 - 8);
            v18 = *(_DWORD *)(v15 + 4 * v17 + 288);
            if (v18)
            {
              v11 -= v18;
              v19 = v15 + v17;
              v20 = *(unsigned __int8 *)(v19 + 1312);
              if (*(_BYTE *)(v19 + 1312))
                goto LABEL_17;
              goto LABEL_13;
            }
            v16 = 9;
          }
          else
          {
            v16 = 1;
          }
          v22 = jpeg_huff_decode((uint64_t)&v29, v10, v11, v15, v16);
          if (v22 < 0)
            return 0;
          v20 = v22;
          v10 = v31;
          v11 = v32;
          if (v22)
          {
LABEL_17:
            if (v11 < v20)
            {
              result = jpeg_fill_bit_buffer(&v29, v10, v11, v20);
              if (!(_DWORD)result)
                return result;
              v10 = v31;
              v11 = v32;
            }
            v11 -= v20;
            v23 = bmask[v20];
            v24 = v23 & (v10 >> v11);
            if (v24 > bmask[v20 - 1])
              v23 = 0;
            v21 = v24 - v23;
            goto LABEL_23;
          }
LABEL_13:
          v21 = 0;
LABEL_23:
          v25 = (char *)&v27 + 4 * v14;
          v26 = *((_DWORD *)v25 + 1) + v21;
          *((_DWORD *)v25 + 1) = v26;
          *v13 = v26 << v5;
          if (++v12 >= *(int *)(a1 + 496))
          {
            v7 = *(unsigned __int8 ***)(a1 + 40);
            v8 = v29;
            v9 = v30;
            break;
          }
        }
      }
      *v7 = v8;
      v7[1] = v9;
      *(_QWORD *)(v4 + 24) = v10;
      *(_DWORD *)(v4 + 32) = v11;
      *(_OWORD *)(v4 + 40) = v27;
      *(_DWORD *)(v4 + 56) = v28;
    }
    if (*(_DWORD *)(a1 + 372))
      --*(_DWORD *)(v4 + 64);
    return 1;
  }
  return result;
}

uint64_t decode_mcu_AC_first(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t result;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  _QWORD *v28;
  uint64_t v29;
  unsigned __int8 *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v4 = *(_QWORD *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    if (!*(_DWORD *)(v4 + 64))
    {
      result = process_restart(a1);
      if (!(_DWORD)result)
        return result;
    }
  }
  if (*(_DWORD *)(v4 + 60))
    goto LABEL_31;
  v6 = *(_DWORD *)(v4 + 40);
  if (v6)
  {
    v7 = v6 - 1;
    goto LABEL_30;
  }
  v34 = a1;
  v8 = *(_QWORD *)(a1 + 40);
  v10 = *(unsigned __int8 **)v8;
  v9 = *(_QWORD *)(v8 + 8);
  v30 = v10;
  v31 = v9;
  v11 = *(_QWORD *)(v4 + 24);
  v12 = *(_DWORD *)(v4 + 32);
  v13 = *(_DWORD *)(a1 + 544);
  v14 = *(_DWORD *)(a1 + 540);
  if (v14 > v13)
  {
LABEL_28:
    v7 = 0;
    goto LABEL_29;
  }
  v15 = *(_DWORD *)(a1 + 552);
  v16 = *(_QWORD *)(a1 + 560);
  v17 = *a2;
  v18 = *(_QWORD *)(v4 + 104);
  v32 = 0;
  v33 = 0;
  while (1)
  {
    if (v12 > 7)
      goto LABEL_13;
    result = jpeg_fill_bit_buffer(&v30, v11, v12, 0);
    if (!(_DWORD)result)
      return result;
    v11 = v32;
    v12 = v33;
    if ((int)v33 >= 8)
    {
LABEL_13:
      v20 = v11 >> (v12 - 8);
      v21 = *(_DWORD *)(v18 + 4 * v20 + 288);
      if (v21)
      {
        v12 -= v21;
        v22 = *(unsigned __int8 *)(v18 + v20 + 1312);
        goto LABEL_18;
      }
      v19 = 9;
    }
    else
    {
      v19 = 1;
    }
    v22 = jpeg_huff_decode((uint64_t)&v30, v11, v12, v18, v19);
    if ((v22 & 0x80000000) != 0)
      return 0;
    v11 = v32;
    v12 = v33;
LABEL_18:
    v23 = v22 >> 4;
    v24 = v22 & 0xF;
    if ((v22 & 0xF) != 0)
    {
      if (v12 < v24)
      {
        result = jpeg_fill_bit_buffer(&v30, v11, v12, v24);
        if (!(_DWORD)result)
          return result;
        v11 = v32;
        v12 = v33;
      }
      v25 = v23 + v14;
      v12 -= v24;
      v26 = bmask[v24];
      v27 = v26 & (v11 >> v12);
      if (v27 > bmask[v24 - 1])
        v26 = 0;
      *(_WORD *)(v17 + 2 * *(int *)(v16 + 4 * v25)) = (v27 - v26) << v15;
      goto LABEL_27;
    }
    if (v23 != 15)
      break;
    v25 = v14 + 15;
LABEL_27:
    v14 = v25 + 1;
    if (v25 >= v13)
      goto LABEL_28;
  }
  if (v22 < 0x10)
    goto LABEL_28;
  if (v12 >= v23)
    goto LABEL_40;
  result = jpeg_fill_bit_buffer(&v30, v11, v12, v23);
  if ((_DWORD)result)
  {
    v11 = v32;
    v12 = v33;
LABEL_40:
    v12 -= v23;
    v7 = (bmask[v23] & (v11 >> v12)) + ~(-1 << v23);
LABEL_29:
    v28 = *(_QWORD **)(a1 + 40);
    v29 = v31;
    *v28 = v30;
    v28[1] = v29;
    *(_QWORD *)(v4 + 24) = v11;
    *(_DWORD *)(v4 + 32) = v12;
LABEL_30:
    *(_DWORD *)(v4 + 40) = v7;
LABEL_31:
    if (*(_DWORD *)(a1 + 372))
      --*(_DWORD *)(v4 + 64);
    return 1;
  }
  return result;
}

uint64_t decode_mcu_DC_refine(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  unsigned __int8 **v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *(_QWORD *)(a1 + 624);
  if (!*(_DWORD *)(a1 + 372) || *(_DWORD *)(v4 + 64) || (result = process_restart(a1), (_DWORD)result))
  {
    v17 = a1;
    v6 = *(unsigned __int8 ***)(a1 + 40);
    v7 = *v6;
    v8 = v6[1];
    v13 = *v6;
    v14 = v8;
    v9 = *(_QWORD *)(v4 + 24);
    v10 = *(_DWORD *)(v4 + 32);
    if (*(int *)(a1 + 496) >= 1)
    {
      v11 = 0;
      v15 = 0;
      v16 = 0;
      v12 = 1 << *(_DWORD *)(a1 + 552);
      do
      {
        if (v10 <= 0)
        {
          result = jpeg_fill_bit_buffer(&v13, v9, v10, 1);
          if (!(_DWORD)result)
            return result;
          v9 = v15;
          v10 = v16;
        }
        if (((v9 >> --v10) & 1) != 0)
          **(_WORD **)(a2 + 8 * v11) |= v12;
        ++v11;
      }
      while (v11 < *(int *)(a1 + 496));
      v6 = *(unsigned __int8 ***)(a1 + 40);
      v7 = v13;
      v8 = v14;
    }
    *v6 = v7;
    v6[1] = v8;
    *(_QWORD *)(v4 + 24) = v9;
    *(_DWORD *)(v4 + 32) = v10;
    if (*(_DWORD *)(a1 + 372))
      --*(_DWORD *)(v4 + 64);
    return 1;
  }
  return result;
}

uint64_t decode_mcu_AC_refine(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t result;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  __int16 v22;
  int v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  __int16 v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v44;
  int v46;
  uint64_t v47;
  __int16 v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned __int8 *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _OWORD v62[16];
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    if (!*(_DWORD *)(v4 + 64))
    {
      result = process_restart(a1);
      if (!(_DWORD)result)
        return result;
    }
  }
  if (*(_DWORD *)(v4 + 60))
    goto LABEL_23;
  v59 = 0;
  v60 = 0;
  memset(v62, 0, sizeof(v62));
  v6 = *(_DWORD *)(a1 + 544);
  v7 = 0x10000 << *(_DWORD *)(a1 + 552);
  v8 = v7 >> 16;
  v53 = *(_QWORD *)(a1 + 560);
  v61 = a1;
  v9 = *(_QWORD *)(a1 + 40);
  v11 = *(unsigned __int8 **)v9;
  v10 = *(_QWORD *)(v9 + 8);
  v57 = v11;
  v58 = v10;
  v12 = *(_QWORD *)(v4 + 24);
  v13 = *(_DWORD *)(v4 + 32);
  v14 = *a2;
  v56 = HIWORD(v7);
  v15 = *(_DWORD *)(a1 + 540);
  if (*(_DWORD *)(v4 + 40))
  {
    v54 = *(_DWORD *)(v4 + 40);
    v52 = 0;
    goto LABEL_7;
  }
  v52 = 0;
  v26 = *(_QWORD *)(v4 + 104);
  v46 = -v7 >> 16;
  v55 = -HIWORD(v7);
  v48 = HIWORD(v7);
  v49 = v6;
  v47 = v26;
  while (1)
  {
    if (v13 > 7)
      goto LABEL_32;
    if (!jpeg_fill_bit_buffer(&v57, v12, v13, 0))
      goto LABEL_75;
    v12 = v59;
    v13 = v60;
    if ((int)v60 >= 8)
    {
LABEL_32:
      v28 = *(_DWORD *)(v26 + 4 * (v12 >> (v13 - 8)) + 288);
      if (v28)
      {
        v29 = v13 - v28;
        v30 = *(unsigned __int8 *)(v26 + (v12 >> (v13 - 8)) + 1312);
        goto LABEL_37;
      }
      v27 = 9;
    }
    else
    {
      v27 = 1;
    }
    v30 = jpeg_huff_decode((uint64_t)&v57, v12, v13, v26, v27);
    if ((v30 & 0x80000000) != 0)
      goto LABEL_75;
    v12 = v59;
    v29 = v60;
LABEL_37:
    v31 = v30 >> 4;
    if ((v30 & 0xF) != 0)
    {
      if ((v30 & 0xF) != 1)
      {
        v32 = *(_QWORD *)a1;
        *(_DWORD *)(v32 + 40) = 121;
        (*(void (**)(uint64_t, uint64_t))(v32 + 8))(a1, 0xFFFFFFFFLL);
      }
      if (v29 <= 0)
      {
        if (!jpeg_fill_bit_buffer(&v57, v12, v29, 1))
          goto LABEL_75;
        v12 = v59;
        v29 = v60;
      }
      --v29;
      v33 = v46;
      if ((((unint64_t)v12 >> v29) & 1) != 0)
        v33 = v8;
      v51 = v33;
      goto LABEL_48;
    }
    if (v31 != 15)
      break;
    v51 = 0;
LABEL_48:
    if (v15 <= v6)
      v34 = v6;
    else
      v34 = v15;
    v50 = v34 + 1;
    v35 = v34 - (uint64_t)v15 + 1;
    v36 = (int *)(v53 + 4 * v15);
    v13 = v29;
    do
    {
      v38 = *v36++;
      v37 = v38;
      if (*(_WORD *)(v14 + 2 * v38))
      {
        if (v13 <= 0)
        {
          if (!jpeg_fill_bit_buffer(&v57, v12, v13, 1))
            goto LABEL_75;
          v12 = v59;
          v13 = v60;
        }
        if ((((unint64_t)v12 >> --v13) & 1) != 0)
        {
          v39 = *(__int16 *)(v14 + 2 * v37);
          if ((v8 & v39) == 0)
          {
            v40 = v56;
            if (v39 < 0)
              v40 = v55;
            *(_WORD *)(v14 + 2 * v37) = v39 + v40;
          }
        }
      }
      else
      {
        v41 = __OFSUB__(v31--, 1);
        if (v31 < 0 != v41)
          goto LABEL_64;
      }
      ++v15;
      --v35;
    }
    while (v35);
    v15 = v50;
LABEL_64:
    HIWORD(v7) = v48;
    v6 = v49;
    v26 = v47;
    if (v51)
    {
      v42 = *(int *)(v53 + 4 * v15);
      *(_WORD *)(v14 + 2 * v42) = v51;
      *((_DWORD *)v62 + v52++) = v42;
    }
    if (v15++ >= v49)
      goto LABEL_67;
  }
  v54 = 1 << v31;
  if (v30 < 0x10)
  {
    v13 = v29;
    goto LABEL_7;
  }
  if (v29 >= v31)
  {
LABEL_73:
    v13 = v29 - v31;
    if (!((bmask[v31] & (v12 >> (v29 - v31))) + v54))
    {
LABEL_67:
      v23 = 0;
      goto LABEL_22;
    }
    v54 += bmask[v31] & (v12 >> (v29 - v31));
LABEL_7:
    if (v15 <= v6)
      v16 = v6;
    else
      v16 = v15;
    v17 = (int *)(v53 + 4 * v15);
    v18 = v16 - v15 + 1;
    do
    {
      v20 = *v17++;
      v19 = v20;
      if (*(_WORD *)(v14 + 2 * v20))
      {
        if (v13 <= 0)
        {
          if (!jpeg_fill_bit_buffer(&v57, v12, v13, 1))
            goto LABEL_75;
          v12 = v59;
          v13 = v60;
        }
        if ((((unint64_t)v12 >> --v13) & 1) != 0)
        {
          v21 = *(__int16 *)(v14 + 2 * v19);
          if ((v8 & v21) == 0)
          {
            v22 = v56;
            if (v21 < 0)
              v22 = -HIWORD(v7);
            *(_WORD *)(v14 + 2 * v19) = v21 + v22;
          }
        }
      }
      --v18;
    }
    while (v18);
    v23 = v54 - 1;
LABEL_22:
    v24 = *(_QWORD **)(a1 + 40);
    v25 = v58;
    *v24 = v57;
    v24[1] = v25;
    *(_QWORD *)(v4 + 24) = v12;
    *(_DWORD *)(v4 + 32) = v13;
    *(_DWORD *)(v4 + 40) = v23;
LABEL_23:
    if (*(_DWORD *)(a1 + 372))
      --*(_DWORD *)(v4 + 64);
    return 1;
  }
  if (jpeg_fill_bit_buffer(&v57, v12, v29, v31))
  {
    v12 = v59;
    v29 = v60;
    goto LABEL_73;
  }
LABEL_75:
  if (v52)
  {
    v44 = v52 - 1;
    do
      *(_WORD *)(v14 + 2 * *((int *)v62 + v44)) = 0;
    while ((_DWORD)v44--);
  }
  return 0;
}

void jpeg_make_d_derived_tbl(uint64_t a1, int a2, unsigned int a3, _QWORD *a4)
{
  void (**v8)(uint64_t);
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  uint64_t i;
  size_t v16;
  void (**v17)(uint64_t);
  int v18;
  unsigned int v19;
  int v20;
  char v21;
  _DWORD *v22;
  char *v23;
  int v24;
  void (**v25)(uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t j;
  unsigned int v34;
  uint64_t v35;
  int v36;
  uint64_t v38;
  unsigned __int8 *v39;
  unsigned int v40;
  void (**v41)(uint64_t);
  int v42;
  _DWORD v43[257];
  _BYTE v44[264];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  memset(v44, 0, 257);
  if (a3 >= 4)
  {
    v8 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v8 + 10) = 52;
    *((_DWORD *)v8 + 12) = a3;
    (**(void (***)(uint64_t))a1)(a1);
  }
  v9 = a1 + 8 * (int)a3;
  v10 = (uint64_t *)(v9 + 232);
  v11 = (uint64_t *)(v9 + 264);
  if (a2)
    v11 = v10;
  v12 = *v11;
  if (!*v11)
    v12 = _cg_jpeg_std_huff_table(a1, a2, a3);
  v42 = a2;
  v13 = (_QWORD *)*a4;
  if (!*a4)
  {
    v13 = (_QWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1568);
    *a4 = v13;
  }
  v14 = 0;
  v13[35] = v12;
  for (i = 1; i != 17; ++i)
  {
    v16 = *(unsigned __int8 *)(v12 + i);
    if (v14 + (int)v16 >= 257)
    {
      v17 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v17 + 10) = 9;
      (*v17)(a1);
    }
    if ((_DWORD)v16)
    {
      memset(&v44[v14], i, v16);
      v14 += v16;
    }
  }
  bzero(v43, 0x404uLL);
  v44[v14] = 0;
  v18 = v44[0];
  if (v44[0])
  {
    v19 = 0;
    v20 = 0;
    v21 = v44[0];
    do
    {
      if (v18 == v21)
      {
        v22 = &v43[v20];
        v23 = &v44[v20 + 1];
        do
        {
          *v22++ = v19++;
          v24 = *v23++;
          ++v20;
        }
        while (v18 == v24);
      }
      if (1 << v18 <= v19)
      {
        v25 = *(void (***)(uint64_t))a1;
        *((_DWORD *)v25 + 10) = 9;
        (*v25)(a1);
      }
      v19 *= 2;
      ++v18;
      v21 = v44[v20];
    }
    while (v21);
  }
  v26 = 0;
  LODWORD(v27) = 0;
  v28 = v12 + 1;
  v29 = v42;
  do
  {
    if (*(_BYTE *)(v28 + v26))
    {
      v13[v26 + 19] = (int)v27 - (unint64_t)v43[(int)v27];
      v27 = *(unsigned __int8 *)(v28 + v26) + (uint64_t)(int)v27;
      v30 = v43[v27 - 1];
    }
    else
    {
      v30 = -1;
    }
    v13[++v26] = v30;
  }
  while (v26 != 16);
  v13[17] = 0xFFFFFLL;
  bzero(v13 + 36, 0x400uLL);
  LODWORD(v31) = 0;
  v32 = v13 + 164;
  for (j = 1; j != 9; ++j)
  {
    if (*(_BYTE *)(v12 + j))
    {
      v34 = 1;
      v31 = (int)v31;
      do
      {
        v35 = (int)(v43[v31] << (8 - j));
        v36 = (1 << (8 - j)) + 1;
        do
        {
          *((_DWORD *)v32 + v35 - 256) = j;
          *((_BYTE *)v32 + v35++) = *(_BYTE *)(v12 + v31 + 17);
          --v36;
        }
        while (v36 > 1);
        ++v31;
      }
      while (v34++ < *(unsigned __int8 *)(v12 + j));
    }
  }
  if (v29 && v14 >= 1)
  {
    v38 = v14;
    v39 = (unsigned __int8 *)(v12 + 17);
    do
    {
      v40 = *v39++;
      if (v40 >= 0x10)
      {
        v41 = *(void (***)(uint64_t))a1;
        *((_DWORD *)v41 + 10) = 9;
        (*v41)(a1);
      }
      --v38;
    }
    while (v38);
  }
}

uint64_t decode_mcu_sub(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  int v6;
  unsigned __int8 **v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _WORD *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  int v46;
  unsigned __int8 *v47;
  unsigned __int8 *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v4 = *(_QWORD *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    if (!*(_DWORD *)(v4 + 64))
    {
      result = process_restart(a1);
      if (!(_DWORD)result)
        return result;
    }
  }
  if (!*(_DWORD *)(v4 + 60))
  {
    v44 = *(_QWORD *)(a1 + 560);
    v6 = *(_DWORD *)(a1 + 568);
    v51 = a1;
    v7 = *(unsigned __int8 ***)(a1 + 40);
    v8 = *v7;
    v9 = v7[1];
    v47 = *v7;
    v48 = v9;
    v10 = *(_QWORD *)(v4 + 24);
    v11 = *(_DWORD *)(v4 + 32);
    v45 = *(_OWORD *)(v4 + 40);
    v46 = *(_DWORD *)(v4 + 56);
    if (*(int *)(a1 + 496) < 1)
    {
LABEL_76:
      *v7 = v8;
      v7[1] = v9;
      *(_QWORD *)(v4 + 24) = v10;
      *(_DWORD *)(v4 + 32) = v11;
      *(_OWORD *)(v4 + 40) = v45;
      *(_DWORD *)(v4 + 56) = v46;
      goto LABEL_5;
    }
    v12 = 0;
    v49 = 0;
    v50 = 0;
    v43 = a2;
LABEL_11:
    v13 = *(_WORD **)(a2 + 8 * v12);
    v14 = *(_QWORD *)(v4 + 8 * v12 + 176);
    if (v11 > 7)
      goto LABEL_15;
    result = jpeg_fill_bit_buffer(&v47, v10, v11, 0);
    if (!(_DWORD)result)
      return result;
    v10 = v49;
    v11 = v50;
    if ((int)v50 >= 8)
    {
LABEL_15:
      v16 = v10 >> (v11 - 8);
      v17 = *(_DWORD *)(v14 + 4 * v16 + 288);
      if (v17)
      {
        v11 -= v17;
        v18 = *(unsigned __int8 *)(v14 + v16 + 1312);
        goto LABEL_20;
      }
      v15 = 9;
    }
    else
    {
      v15 = 1;
    }
    v19 = jpeg_huff_decode((uint64_t)&v47, v10, v11, v14, v15);
    if (v19 < 0)
      return 0;
    v18 = v19;
    v10 = v49;
    v11 = v50;
LABEL_20:
    v20 = *(_QWORD *)(v4 + 8 * v12 + 256);
    v21 = *(_DWORD *)(v4 + 4 * v12 + 336);
    if (v21)
    {
      if (v18)
      {
        if (v11 < v18)
        {
          result = jpeg_fill_bit_buffer(&v47, v10, v11, v18);
          if (!(_DWORD)result)
            return result;
          v10 = v49;
          v11 = v50;
        }
        v11 -= v18;
        v22 = bmask[v18];
        v23 = v22 & (v10 >> v11);
        if (v23 > bmask[v18 - 1])
          v22 = 0;
        v24 = v23 - v22;
      }
      else
      {
        v24 = 0;
      }
      v25 = (char *)&v45 + 4 * *(int *)(a1 + 4 * v12 + 500);
      v26 = *((_DWORD *)v25 + 1) + v24;
      *((_DWORD *)v25 + 1) = v26;
      *v13 = v26;
      if (v21 >= 2)
      {
        v27 = 1;
        while (1)
        {
          if (v11 > 7)
            goto LABEL_40;
          result = jpeg_fill_bit_buffer(&v47, v10, v11, 0);
          if (!(_DWORD)result)
            return result;
          v10 = v49;
          v11 = v50;
          if ((int)v50 >= 8)
          {
LABEL_40:
            v29 = v10 >> (v11 - 8);
            v30 = *(_DWORD *)(v20 + 4 * v29 + 288);
            if (v30)
            {
              v11 -= v30;
              v31 = *(unsigned __int8 *)(v20 + v29 + 1312);
              goto LABEL_45;
            }
            v28 = 9;
          }
          else
          {
            v28 = 1;
          }
          v31 = jpeg_huff_decode((uint64_t)&v47, v10, v11, v20, v28);
          if ((v31 & 0x80000000) != 0)
            return 0;
          v10 = v49;
          v11 = v50;
LABEL_45:
          v32 = v31 >> 4;
          v33 = v31 & 0xF;
          if ((v31 & 0xF) != 0)
          {
            if (v11 < v33)
            {
              result = jpeg_fill_bit_buffer(&v47, v10, v11, v33);
              if (!(_DWORD)result)
                return result;
              v10 = v49;
              v11 = v50;
            }
            v34 = v32 + v27;
            v11 -= v33;
            v35 = bmask[v33];
            v36 = v35 & (v10 >> v11);
            if (v36 > bmask[v33 - 1])
              LOWORD(v35) = 0;
            v13[*(int *)(v44 + 4 * v34)] = v36 - v35;
          }
          else
          {
            if (v32 != 15)
            {
LABEL_74:
              ++v12;
              a2 = v43;
              if (v12 >= *(int *)(a1 + 496))
              {
                v7 = *(unsigned __int8 ***)(a1 + 40);
                v8 = v47;
                v9 = v48;
                goto LABEL_76;
              }
              goto LABEL_11;
            }
            v34 = v27 + 15;
          }
          v27 = v34 + 1;
          if (v34 + 1 >= v21)
          {
            while (1)
            {
LABEL_57:
              if (v27 > v6)
                goto LABEL_74;
              if (v11 > 7)
                goto LABEL_62;
              result = jpeg_fill_bit_buffer(&v47, v10, v11, 0);
              if (!(_DWORD)result)
                return result;
              v10 = v49;
              v11 = v50;
              if ((int)v50 >= 8)
              {
LABEL_62:
                v38 = v10 >> (v11 - 8);
                v39 = *(_DWORD *)(v20 + 4 * v38 + 288);
                if (v39)
                {
                  v11 -= v39;
                  v40 = *(unsigned __int8 *)(v20 + v38 + 1312);
                  goto LABEL_67;
                }
                v37 = 9;
              }
              else
              {
                v37 = 1;
              }
              v40 = jpeg_huff_decode((uint64_t)&v47, v10, v11, v20, v37);
              if ((v40 & 0x80000000) != 0)
                return 0;
              v10 = v49;
              v11 = v50;
LABEL_67:
              v41 = v40 >> 4;
              v42 = v40 & 0xF;
              if ((v40 & 0xF) != 0)
              {
                if (v11 < v42)
                {
                  result = jpeg_fill_bit_buffer(&v47, v10, v11, v42);
                  if (!(_DWORD)result)
                    return result;
                  v10 = v49;
                  v11 = v50;
                }
                v11 -= v42;
              }
              else if (v41 != 15)
              {
                goto LABEL_74;
              }
              v27 += v41 + 1;
            }
          }
        }
      }
    }
    else if (v18)
    {
      if (v11 < v18)
      {
        result = jpeg_fill_bit_buffer(&v47, v10, v11, v18);
        if (!(_DWORD)result)
          return result;
        v10 = v49;
        v11 = v50;
      }
      v11 -= v18;
    }
    v27 = 1;
    goto LABEL_57;
  }
LABEL_5:
  if (*(_DWORD *)(a1 + 372))
    --*(_DWORD *)(v4 + 64);
  return 1;
}

uint64_t decode_mcu(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  unsigned __int8 **v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  _WORD *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  char *v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  __int128 v42;
  int v43;
  unsigned __int8 *v44;
  unsigned __int8 *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v4 = *(_QWORD *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    if (!*(_DWORD *)(v4 + 64))
    {
      result = process_restart(a1);
      if (!(_DWORD)result)
        return result;
    }
  }
  if (*(_DWORD *)(v4 + 60))
    goto LABEL_5;
  v48 = a1;
  v6 = *(unsigned __int8 ***)(a1 + 40);
  v7 = *v6;
  v8 = v6[1];
  v44 = *v6;
  v45 = v8;
  v9 = *(_QWORD *)(v4 + 24);
  v10 = *(_DWORD *)(v4 + 32);
  v42 = *(_OWORD *)(v4 + 40);
  v43 = *(_DWORD *)(v4 + 56);
  if (*(int *)(a1 + 496) < 1)
    goto LABEL_76;
  v11 = 0;
  v46 = 0;
  v47 = 0;
  do
  {
    v12 = *(_WORD **)(a2 + 8 * v11);
    v13 = *(_QWORD *)(v4 + 8 * v11 + 176);
    if (v10 > 7)
      goto LABEL_15;
    result = jpeg_fill_bit_buffer(&v44, v9, v10, 0);
    if (!(_DWORD)result)
      return result;
    v9 = v46;
    v10 = v47;
    if ((int)v47 >= 8)
    {
LABEL_15:
      v15 = v9 >> (v10 - 8);
      v16 = *(_DWORD *)(v13 + 4 * v15 + 288);
      if (v16)
      {
        v10 -= v16;
        v17 = *(unsigned __int8 *)(v13 + v15 + 1312);
        goto LABEL_20;
      }
      v14 = 9;
    }
    else
    {
      v14 = 1;
    }
    v18 = jpeg_huff_decode((uint64_t)&v44, v9, v10, v13, v14);
    if (v18 < 0)
      return 0;
    v17 = v18;
    v9 = v46;
    v10 = v47;
LABEL_20:
    v19 = *(_QWORD *)(v4 + 8 * v11 + 256);
    v20 = *(_DWORD *)(v4 + 4 * v11 + 336);
    if (!v20)
    {
      if (v17)
      {
        if (v10 < v17)
        {
          result = jpeg_fill_bit_buffer(&v44, v9, v10, v17);
          if (!(_DWORD)result)
            return result;
          v9 = v46;
          v10 = v47;
        }
        v10 -= v17;
      }
LABEL_57:
      v26 = 1;
      while (1)
      {
LABEL_58:
        if (v10 > 7)
          goto LABEL_62;
        result = jpeg_fill_bit_buffer(&v44, v9, v10, 0);
        if (!(_DWORD)result)
          return result;
        v9 = v46;
        v10 = v47;
        if ((int)v47 >= 8)
        {
LABEL_62:
          v37 = v9 >> (v10 - 8);
          v38 = *(_DWORD *)(v19 + 4 * v37 + 288);
          if (v38)
          {
            v10 -= v38;
            v39 = *(unsigned __int8 *)(v19 + v37 + 1312);
            goto LABEL_67;
          }
          v36 = 9;
        }
        else
        {
          v36 = 1;
        }
        v39 = jpeg_huff_decode((uint64_t)&v44, v9, v10, v19, v36);
        if ((v39 & 0x80000000) != 0)
          return 0;
        v9 = v46;
        v10 = v47;
LABEL_67:
        v40 = v39 >> 4;
        v41 = v39 & 0xF;
        if ((v39 & 0xF) != 0)
        {
          if (v10 < v41)
          {
            result = jpeg_fill_bit_buffer(&v44, v9, v10, v41);
            if (!(_DWORD)result)
              return result;
            v9 = v46;
            v10 = v47;
          }
          v10 -= v41;
        }
        else if (v40 != 15)
        {
          goto LABEL_74;
        }
        v26 += v40 + 1;
        if (v26 >= 64)
          goto LABEL_74;
      }
    }
    if (v17)
    {
      if (v10 < v17)
      {
        result = jpeg_fill_bit_buffer(&v44, v9, v10, v17);
        if (!(_DWORD)result)
          return result;
        v9 = v46;
        v10 = v47;
      }
      v10 -= v17;
      v21 = bmask[v17];
      v22 = v21 & (v9 >> v10);
      if (v22 > bmask[v17 - 1])
        v21 = 0;
      v23 = v22 - v21;
    }
    else
    {
      v23 = 0;
    }
    v24 = (char *)&v42 + 4 * *(int *)(a1 + 4 * v11 + 500);
    v25 = *((_DWORD *)v24 + 1) + v23;
    *((_DWORD *)v24 + 1) = v25;
    *v12 = v25;
    if (v20 < 2)
      goto LABEL_57;
    v26 = 1;
    do
    {
      if (v10 > 7)
        goto LABEL_40;
      result = jpeg_fill_bit_buffer(&v44, v9, v10, 0);
      if (!(_DWORD)result)
        return result;
      v9 = v46;
      v10 = v47;
      if ((int)v47 >= 8)
      {
LABEL_40:
        v28 = v9 >> (v10 - 8);
        v29 = *(_DWORD *)(v19 + 4 * v28 + 288);
        if (v29)
        {
          v10 -= v29;
          v30 = *(unsigned __int8 *)(v19 + v28 + 1312);
          goto LABEL_45;
        }
        v27 = 9;
      }
      else
      {
        v27 = 1;
      }
      v30 = jpeg_huff_decode((uint64_t)&v44, v9, v10, v19, v27);
      if ((v30 & 0x80000000) != 0)
        return 0;
      v9 = v46;
      v10 = v47;
LABEL_45:
      v31 = v30 >> 4;
      v32 = v30 & 0xF;
      if ((v30 & 0xF) != 0)
      {
        if (v10 < v32)
        {
          result = jpeg_fill_bit_buffer(&v44, v9, v10, v32);
          if (!(_DWORD)result)
            return result;
          v9 = v46;
          v10 = v47;
        }
        v33 = v31 + v26;
        v10 -= v32;
        v34 = bmask[v32];
        v35 = v34 & (v9 >> v10);
        if (v35 > bmask[v32 - 1])
          LOWORD(v34) = 0;
        v12[_cg_jpeg_natural_order[v33]] = v35 - v34;
      }
      else
      {
        if (v31 != 15)
          goto LABEL_74;
        v33 = v26 + 15;
      }
      v26 = v33 + 1;
    }
    while (v33 + 1 < v20);
    if (v33 <= 62)
      goto LABEL_58;
LABEL_74:
    ++v11;
  }
  while (v11 < *(int *)(a1 + 496));
  v6 = *(unsigned __int8 ***)(a1 + 40);
  v7 = v44;
  v8 = v45;
LABEL_76:
  *v6 = v7;
  v6[1] = v8;
  *(_QWORD *)(v4 + 24) = v9;
  *(_DWORD *)(v4 + 32) = v10;
  *(_OWORD *)(v4 + 40) = v42;
  *(_DWORD *)(v4 + 56) = v43;
LABEL_5:
  if (*(_DWORD *)(a1 + 372))
    --*(_DWORD *)(v4 + 64);
  return 1;
}

uint64_t process_restart(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;

  v2 = *(_DWORD **)(a1 + 624);
  v3 = *(_QWORD *)(a1 + 616);
  *(_DWORD *)(v3 + 36) += v2[8] / 8;
  v2[8] = 0;
  result = (*(uint64_t (**)(void))(v3 + 16))();
  if ((_DWORD)result)
  {
    if (*(int *)(a1 + 448) >= 1)
    {
      v5 = 0;
      do
        v2[v5++ + 11] = 0;
      while (v5 < *(int *)(a1 + 448));
    }
    v2[10] = 0;
    v2[16] = *(_DWORD *)(a1 + 372);
    if (!*(_DWORD *)(a1 + 572))
      v2[15] = 0;
    return 1;
  }
  return result;
}

uint64_t jpeg_fill_bit_buffer(unsigned __int8 **a1, uint64_t a2, int a3, int a4)
{
  int v5;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  unsigned __int8 **v14;
  uint64_t v15;
  unsigned int v16;
  unsigned __int8 **v17;
  int v18;
  int v19;
  BOOL v20;

  v5 = a3;
  v8 = *a1;
  v9 = a1[1];
  v10 = a1[4];
  if (*((_DWORD *)v10 + 143))
  {
LABEL_2:
    if (v5 < a4)
    {
      if (!*(_DWORD *)(*((_QWORD *)v10 + 78) + 60))
      {
        v11 = *(_QWORD *)v10;
        *(_DWORD *)(v11 + 40) = 120;
        (*(void (**)(unsigned __int8 *, uint64_t))(v11 + 8))(v10, 0xFFFFFFFFLL);
        *(_DWORD *)(*((_QWORD *)v10 + 78) + 60) = 1;
      }
      v12 = 25;
      a2 <<= 25 - v5;
      goto LABEL_20;
    }
  }
  else if (a3 <= 24)
  {
    while (1)
    {
      if (!v9)
      {
        result = (*(uint64_t (**)(unsigned __int8 *))(*((_QWORD *)v10 + 5) + 24))(v10);
        if (!(_DWORD)result)
          return result;
        v14 = (unsigned __int8 **)*((_QWORD *)v10 + 5);
        v8 = *v14;
        v9 = v14[1];
      }
      --v9;
      v16 = *v8++;
      v15 = v16;
      if (v16 == 255)
      {
        do
        {
          if (!v9)
          {
            result = (*(uint64_t (**)(unsigned __int8 *))(*((_QWORD *)v10 + 5) + 24))(v10);
            if (!(_DWORD)result)
              return result;
            v17 = (unsigned __int8 **)*((_QWORD *)v10 + 5);
            v8 = *v17;
            v9 = v17[1];
          }
          --v9;
          v19 = *v8++;
          v18 = v19;
        }
        while (v19 == 255);
        if (v18)
        {
          *((_DWORD *)v10 + 143) = v18;
          goto LABEL_2;
        }
        v15 = 255;
      }
      a2 = v15 | (a2 << 8);
      v12 = v5 + 8;
      v20 = v5 < 17;
      v5 += 8;
      if (!v20)
        goto LABEL_20;
    }
  }
  v12 = v5;
LABEL_20:
  *a1 = v8;
  a1[1] = v9;
  a1[2] = (unsigned __int8 *)a2;
  result = 1;
  *((_DWORD *)a1 + 6) = v12;
  return result;
}

uint64_t jpeg_huff_decode(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  int v5;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;

  v5 = a5;
  if (a3 < a5)
  {
    if (!jpeg_fill_bit_buffer((unsigned __int8 **)a1, a2, a3, a5))
      return 0xFFFFFFFFLL;
    a2 = *(_QWORD *)(a1 + 16);
    a3 = *(_DWORD *)(a1 + 24);
  }
  v8 = a3 - v5;
  v9 = (int)(bmask[v5] & (a2 >> v8));
  v10 = v5;
  if (*(_QWORD *)(a4 + 8 * v5) >= v9)
  {
    v11 = v5;
  }
  else
  {
    do
    {
      if (v8 <= 0)
      {
        if (!jpeg_fill_bit_buffer((unsigned __int8 **)a1, a2, v8, 1))
          return 0xFFFFFFFFLL;
        a2 = *(_QWORD *)(a1 + 16);
        v8 = *(_DWORD *)(a1 + 24);
      }
      v9 = ((unint64_t)a2 >> --v8) & 1 | (2 * v9);
      v11 = v10 + 1;
      v12 = *(_QWORD *)(a4 + 8 + 8 * v10++);
    }
    while (v9 > v12);
    v5 = v11;
  }
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = v8;
  if (v5 < 17)
    return *(unsigned __int8 *)(*(_QWORD *)(a4 + 280) + *(_DWORD *)(a4 + 8 * v11 + 144) + (int)v9 + 17);
  v13 = *(uint64_t **)(a1 + 32);
  v14 = *v13;
  *(_DWORD *)(v14 + 40) = 121;
  (*(void (**)(uint64_t *, uint64_t))(v14 + 8))(v13, 0xFFFFFFFFLL);
  return 0;
}

uint64_t (**_cg_jinit_c_coef_controller(uint64_t a1, int a2))(uint64_t *a1, int a2)
{
  uint64_t (**result)(uint64_t *, int);
  uint64_t (**v5)(uint64_t *, int);
  uint64_t v6;
  _QWORD *v7;
  unsigned int *v8;
  uint64_t (*v9)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD);
  uint64_t v10;
  uint64_t v11;
  int64x2_t v12;
  uint64_t v13;
  int64x2_t v14;
  int64x2_t v15;

  result = (uint64_t (**)(uint64_t *, int))(**(uint64_t (***)(void))(a1 + 8))();
  v5 = result;
  *(_QWORD *)(a1 + 520) = result;
  *result = start_pass_coef;
  if (a2)
  {
    if (*(int *)(a1 + 92) >= 1)
    {
      v6 = 0;
      v7 = result + 14;
      v8 = (unsigned int *)(*(_QWORD *)(a1 + 104) + 28);
      do
      {
        v9 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 8) + 40);
        v10 = _cg_jround_up(*v8, (int)*(v8 - 5));
        v11 = _cg_jround_up(v8[1], (int)*(v8 - 4));
        result = (uint64_t (**)(uint64_t *, int))v9(a1, 1, 0, v10, v11, *(v8 - 4));
        v7[v6++] = result;
        v8 += 24;
      }
      while (v6 < *(int *)(a1 + 92));
    }
  }
  else
  {
    result = (uint64_t (**)(uint64_t *, int))(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 8))(a1, 1, 1280);
    v12 = (int64x2_t)xmmword_18820C490;
    v13 = 4;
    v14 = vdupq_n_s64((unint64_t)result);
    v15 = vdupq_n_s64(2uLL);
    do
    {
      *(int64x2_t *)&v5[v13] = vaddq_s64(v14, vshlq_n_s64(v12, 7uLL));
      v12 = vaddq_s64(v12, v15);
      v13 += 2;
    }
    while (v13 != 14);
    v5[14] = 0;
  }
  return result;
}

uint64_t start_pass_coef(uint64_t *a1, int a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = a1[65];
  *(_DWORD *)(v4 + 16) = 0;
  result = start_iMCU_row_0((uint64_t)a1);
  switch(a2)
  {
    case 3:
      if (!*(_QWORD *)(v4 + 112))
      {
        v8 = *a1;
        *(_DWORD *)(v8 + 40) = 3;
        result = (*(uint64_t (**)(uint64_t *))v8)(a1);
      }
      v7 = compress_first_pass;
      goto LABEL_13;
    case 2:
      if (!*(_QWORD *)(v4 + 112))
      {
        v9 = *a1;
        *(_DWORD *)(v9 + 40) = 3;
        result = (*(uint64_t (**)(uint64_t *))v9)(a1);
      }
      v7 = compress_output;
      goto LABEL_13;
    case 0:
      if (*(_QWORD *)(v4 + 112))
      {
        v6 = *a1;
        *(_DWORD *)(v6 + 40) = 3;
        result = (*(uint64_t (**)(uint64_t *))v6)(a1);
      }
      v7 = compress_data;
LABEL_13:
      *(_QWORD *)(v4 + 8) = v7;
      return result;
  }
  v10 = *a1;
  *(_DWORD *)(v10 + 40) = 3;
  return (*(uint64_t (**)(uint64_t *))v10)(a1);
}

uint64_t start_iMCU_row_0(uint64_t result)
{
  _DWORD *v1;
  int v2;
  uint64_t v3;

  v1 = *(_DWORD **)(result + 520);
  if (*(int *)(result + 372) < 2)
  {
    v3 = *(_QWORD *)(result + 376);
    if (v1[4] >= (*(_DWORD *)(result + 368) - 1))
      v2 = *(_DWORD *)(v3 + 76);
    else
      v2 = *(_DWORD *)(v3 + 12);
  }
  else
  {
    v2 = 1;
  }
  v1[6] = 0;
  v1[7] = v2;
  v1[5] = 0;
  return result;
}

uint64_t compress_data(uint64_t a1, uint64_t a2)
{
  _DWORD *v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  int *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void (*v14)(uint64_t, int *, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v15;
  uint64_t v16;
  int v17;
  _WORD **v18;
  uint64_t v19;
  _WORD *v20;
  _WORD **v21;
  uint64_t v22;
  _WORD *v23;
  uint64_t result;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  _DWORD *v28;
  int v29;

  v3 = *(_DWORD **)(a1 + 520);
  v4 = v3[7];
  v29 = v3[6];
  if (v29 >= v4)
  {
LABEL_27:
    ++v3[4];
    start_iMCU_row_0(a1);
    return 1;
  }
  else
  {
    v26 = *(_DWORD *)(a1 + 408) - 1;
    v5 = *(_DWORD *)(a1 + 368) - 1;
    v28 = v3 + 8;
    v6 = v3[5];
    while (v6 > v26)
    {
LABEL_26:
      v6 = 0;
      v3[5] = 0;
      if (++v29 >= v4)
        goto LABEL_27;
    }
    while (1)
    {
      v7 = *(_DWORD *)(a1 + 372);
      if (v7 >= 1)
      {
        v8 = 0;
        v9 = 0;
        v25 = v6;
        do
        {
          v10 = *(int **)(a1 + 8 * v8 + 376);
          v11 = 18;
          if (v6 < v26)
            v11 = 14;
          if (v10[15] >= 1)
          {
            v12 = 0;
            v13 = v10[v11];
            v14 = *(void (**)(uint64_t, int *, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 552) + 8 * v10[1] + 8);
            v15 = v10[17] * v6;
            v16 = (v10[10] * v29);
            v27 = v8;
            do
            {
              if (v3[4] >= v5 && v12 + v29 >= v10[19])
              {
                bzero(*(void **)&v3[2 * v9 + 8], (uint64_t)v10[14] << 7);
                v17 = v10[14];
                if (v17 >= 1)
                {
                  v20 = *(_WORD **)&v3[2 * v9 + 6];
                  v21 = (_WORD **)&v28[2 * v9];
                  v22 = v10[14];
                  do
                  {
                    v23 = *v21++;
                    *v23 = *v20;
                    --v22;
                  }
                  while (v22);
                }
              }
              else
              {
                v14(a1, v10, *(_QWORD *)(a2 + 8 * v10[1]), *(_QWORD *)&v3[2 * v9 + 8], v16, v15, v13);
                v17 = v10[14];
                if (v17 > (int)v13)
                {
                  bzero(*(void **)&v3[2 * v9 + 8 + 2 * (int)v13], (uint64_t)(v17 - (int)v13) << 7);
                  v17 = v10[14];
                  if ((int)v13 < v17)
                  {
                    v18 = (_WORD **)&v28[2 * v13 + 2 * v9];
                    v19 = v17 - v13;
                    do
                    {
                      **v18 = **(v18 - 1);
                      ++v18;
                      --v19;
                    }
                    while (v19);
                  }
                }
              }
              v9 += v17;
              v16 = (v10[10] + v16);
              ++v12;
            }
            while (v12 < v10[15]);
            v7 = *(_DWORD *)(a1 + 372);
            v6 = v25;
            v8 = v27;
          }
          ++v8;
        }
        while (v8 < v7);
      }
      result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)(a1 + 560) + 8))(a1, v28);
      if (!(_DWORD)result)
        break;
      if (++v6 > v26)
      {
        v4 = v3[7];
        goto LABEL_26;
      }
    }
    v3[5] = v6;
    v3[6] = v29;
  }
  return result;
}

uint64_t compress_first_pass(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(uint64_t, _DWORD *, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t);
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  void **v21;
  char *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v28;
  unsigned int v29;
  unint64_t v30;
  int v31;
  unsigned int v32;
  uint64_t v35;

  v2 = a1;
  if (*(int *)(a1 + 92) >= 1)
  {
    v3 = 0;
    v28 = *(_QWORD *)(a1 + 520);
    v29 = *(_DWORD *)(a1 + 368) - 1;
    v4 = *(_DWORD **)(a1 + 104);
    do
    {
      v5 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(v2 + 8) + 64))(v2, *(_QWORD *)(v28 + 8 * v3 + 112), (v4[3] * *(_DWORD *)(v28 + 16)), v4[3], 1);
      v6 = *(_DWORD *)(v28 + 16);
      if (v6 >= v29)
      {
        v8 = v4[3];
        if (v4[8] % v8)
          v7 = v4[8] % v8;
        else
          v7 = v4[3];
      }
      else
      {
        v7 = v4[3];
      }
      v9 = v4[7];
      v10 = (int)v4[2];
      if ((int)(v9 % v10) <= 0)
        v11 = v9 % v10;
      else
        v11 = v10 - v9 % v10;
      v35 = v3;
      if (v7 >= 1)
      {
        v12 = 0;
        v13 = *(void (**)(uint64_t, _DWORD *, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(v2 + 552)
                                                                                                 + 8 * v3
                                                                                                 + 8);
        v31 = v7;
        v14 = v7;
        do
        {
          v15 = *(_QWORD *)(v5 + 8 * v12);
          v13(a1, v4, *(_QWORD *)(a2 + 8 * v3), v15, (v4[10] * v12), 0, v9);
          if ((int)v11 >= 1)
          {
            v16 = (_WORD *)(v15 + (v9 << 7));
            bzero(v16, (unint64_t)v11 << 7);
            v17 = *(v16 - 64);
            v18 = v11;
            do
            {
              *v16 = v17;
              v16 += 64;
              --v18;
            }
            while (v18);
          }
          ++v12;
        }
        while (v12 != v14);
        v6 = *(_DWORD *)(v28 + 16);
        v7 = v31;
      }
      if (v6 == v29 && v7 < v4[3])
      {
        v32 = v11 + v9;
        v30 = (unint64_t)(v11 + v9) << 7;
        v19 = v7;
        if (((int)v11 + (int)v9) / v10 <= 1)
          v20 = 1;
        else
          v20 = ((int)v11 + (int)v9) / v10;
        do
        {
          v21 = (void **)(v5 + 8 * v19);
          v23 = (uint64_t)*(v21 - 1);
          v22 = (char *)*v21;
          bzero(*v21, v30);
          if (v10 <= v32)
          {
            v24 = 0;
            do
            {
              if ((int)v10 >= 1)
              {
                v25 = 0;
                v26 = *(_WORD *)(v23 + ((v10 - 1) << 7));
                do
                {
                  *(_WORD *)&v22[v25] = v26;
                  v25 += 128;
                }
                while ((unint64_t)v10 << 7 != v25);
              }
              v23 += v10 << 7;
              ++v24;
              v22 += 128 * v10;
            }
            while (v24 != v20);
          }
          ++v19;
        }
        while (v19 < (int)v4[3]);
      }
      v2 = a1;
      v3 = v35 + 1;
      v4 += 24;
    }
    while (v35 + 1 < *(int *)(a1 + 92));
  }
  return compress_output(v2);
}

uint64_t compress_output(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  int v18;
  uint64_t result;
  _OWORD v20[2];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD **)(a1 + 520);
  memset(v20, 0, sizeof(v20));
  if (*(int *)(a1 + 372) >= 1)
  {
    v3 = 0;
    do
    {
      *((_QWORD *)v20 + v3) = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 8)
                                                                                                 + 64))(a1, *(_QWORD *)&v2[2 * *(int *)(*(_QWORD *)(a1 + 8 * v3 + 376) + 4) + 28], (*(_DWORD *)(*(_QWORD *)(a1 + 8 * v3 + 376) + 12) * v2[4]), *(unsigned int *)(*(_QWORD *)(a1 + 8 * v3 + 376) + 12), 0);
      ++v3;
    }
    while (v3 < *(int *)(a1 + 372));
  }
  v4 = v2[7];
  v5 = (int)v2[6];
  if ((int)v5 >= v4)
  {
LABEL_20:
    ++v2[4];
    start_iMCU_row_0(a1);
    return 1;
  }
  else
  {
    v6 = v2[5];
    v7 = *(_DWORD *)(a1 + 408);
    while (v6 >= v7)
    {
LABEL_19:
      v6 = 0;
      v2[5] = 0;
      if (++v5 >= v4)
        goto LABEL_20;
    }
    while (1)
    {
      v8 = *(unsigned int *)(a1 + 372);
      if ((int)v8 >= 1)
      {
        v9 = 0;
        v10 = 0;
        do
        {
          v11 = *(_QWORD *)(a1 + 8 * v9 + 376);
          v12 = *(unsigned int *)(v11 + 60);
          if ((int)v12 >= 1)
          {
            v13 = 0;
            v14 = *(_DWORD *)(v11 + 56);
            v15 = *((_QWORD *)v20 + v9);
            do
            {
              if (v14 >= 1)
              {
                v16 = *(_QWORD *)(v15 + 8 * (v13 + v5)) + ((unint64_t)(v14 * v6) << 7);
                v17 = (unint64_t *)&v2[2 * v10 + 8];
                v10 += v14;
                v18 = v14;
                do
                {
                  *v17++ = v16;
                  v16 += 128;
                  --v18;
                }
                while (v18);
              }
              ++v13;
            }
            while (v13 != v12);
          }
          ++v9;
        }
        while (v9 != v8);
      }
      result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)(a1 + 560) + 8))(a1, v2 + 8);
      if (!(_DWORD)result)
        break;
      ++v6;
      v7 = *(_DWORD *)(a1 + 408);
      if (v6 >= v7)
      {
        v4 = v2[7];
        goto LABEL_19;
      }
    }
    v2[5] = v6;
    v2[6] = v5;
  }
  return result;
}

uint64_t _cg_jinit_merged_upsampler(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  int v5;
  _QWORD *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v2 = (**(uint64_t (***)(void))(a1 + 8))();
  v3 = (_QWORD *)v2;
  *(_QWORD *)(a1 + 640) = v2;
  *(_QWORD *)v2 = start_pass_merged_upsample;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 76) = *(_DWORD *)(a1 + 144) * *(_DWORD *)(a1 + 136);
  if (*(_DWORD *)(a1 + 420) == 2)
  {
    *(_QWORD *)(v2 + 8) = merged_2v_upsample;
    *(_QWORD *)(v2 + 24) = h2v2_merged_upsample;
    v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 8))(a1, 1);
  }
  else
  {
    v4 = 0;
    v3[1] = merged_1v_upsample;
    v3[3] = h2v1_merged_upsample;
  }
  v3[8] = v4;
  v5 = *(_DWORD *)(a1 + 60);
  v6 = *(_QWORD **)(a1 + 640);
  v6[4] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
  v6[5] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
  v6[6] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
  result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
  v6[7] = result;
  v8 = v6[4];
  v9 = v6[5];
  v10 = v6[6];
  if (v5 == 7)
  {
    v11 = 0;
    v12 = -29696512;
    v13 = -23488896;
    v14 = 5806464;
    v15 = 11981184;
    do
    {
      *(_DWORD *)(v8 + 4 * v11) = v13 >> 16;
      *(_DWORD *)(v9 + 4 * v11) = v12 >> 16;
      *(_QWORD *)(v10 + 8 * v11) = v15;
      *(_QWORD *)(result + 8 * v11++) = v14;
      v14 -= 45107;
      v15 -= 93603;
      v12 += 232260;
      v13 += 183763;
    }
    while (v11 != 256);
  }
  else
  {
    v16 = 0;
    v17 = -14831872;
    v18 = -11728000;
    v19 = 2919552;
    v20 = 5990656;
    do
    {
      *(_DWORD *)(v8 + 4 * v16) = v18 >> 16;
      *(_DWORD *)(v9 + 4 * v16) = v17 >> 16;
      *(_QWORD *)(v10 + 8 * v16) = v20;
      *(_QWORD *)(result + 8 * v16++) = v19;
      v19 -= 22553;
      v20 -= 46802;
      v17 += 116130;
      v18 += 91881;
    }
    while (v16 != 256);
  }
  return result;
}

uint64_t start_pass_merged_upsample(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 640);
  *(_DWORD *)(v1 + 72) = 0;
  *(_DWORD *)(v1 + 80) = *(_DWORD *)(result + 140);
  return result;
}

char *merged_2v_upsample(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, _DWORD *a6, int a7)
{
  uint64_t v9;
  unsigned int v10;
  char *result;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 640);
  if (*(_DWORD *)(v9 + 72))
  {
    v10 = 1;
    result = _cg_jcopy_sample_rows((char *)(v9 + 64), 0, a5 + 8 * *a6, 0, 1, *(unsigned int *)(v9 + 76));
    *(_DWORD *)(v9 + 72) = 0;
  }
  else
  {
    v12 = *(_DWORD *)(v9 + 80);
    v13 = *a6;
    if (v12 >= a7 - (int)v13)
      v12 = a7 - v13;
    if (v12 >= 2)
      v10 = 2;
    else
      v10 = v12;
    v15 = *(_QWORD *)(a5 + 8 * v13);
    if (v10 < 2)
    {
      v14 = *(_QWORD *)(v9 + 64);
      *(_DWORD *)(v9 + 72) = 1;
    }
    else
    {
      v14 = *(_QWORD *)(a5 + 8 * (v13 + 1));
    }
    v16 = v14;
    result = (char *)(*(uint64_t (**)(void))(v9 + 24))();
  }
  *a6 += v10;
  *(_DWORD *)(v9 + 80) -= v10;
  if (!*(_DWORD *)(v9 + 72))
    ++*a3;
  return result;
}

uint64_t h2v2_merged_upsample(uint64_t result, _QWORD *a2, unsigned int a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  _BYTE *v14;
  _BYTE *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v4 = *(_QWORD **)(result + 640);
  v5 = *(_QWORD *)(result + 440);
  v7 = v4[4];
  v6 = v4[5];
  v8 = v4[6];
  v9 = v4[7];
  v10 = *(unsigned __int8 **)(*a2 + 16 * a3);
  v11 = *(unsigned __int8 **)(*a2 + 8 * ((2 * a3) | 1));
  v12 = *(unsigned __int8 **)(a2[1] + 8 * a3);
  v13 = *(unsigned __int8 **)(a2[2] + 8 * a3);
  v15 = *(_BYTE **)a4;
  v14 = *(_BYTE **)(a4 + 8);
  v16 = *(unsigned int *)(result + 136);
  if (v16 >= 2)
  {
    v17 = 0;
    v18 = v16 >> 1;
    do
    {
      v19 = v12[v17];
      v20 = v13[v17];
      v21 = *(int *)(v7 + 4 * v20);
      v22 = *v10;
      v23 = *(int *)(v6 + 4 * v19);
      v24 = (*(_QWORD *)(v8 + 8 * v20) + *(_QWORD *)(v9 + 8 * v19)) >> 16;
      *v15 = *(_BYTE *)(v5 + v21 + v22);
      v15[1] = *(_BYTE *)(v5 + v22 + (int)v24);
      v15[2] = *(_BYTE *)(v5 + v23 + v22);
      v25 = v10[1];
      v15[3] = *(_BYTE *)(v5 + v21 + v25);
      v15[4] = *(_BYTE *)(v5 + v25 + (int)v24);
      v15[5] = *(_BYTE *)(v5 + v23 + v25);
      v26 = *v11;
      *v14 = *(_BYTE *)(v5 + v21 + v26);
      v14[1] = *(_BYTE *)(v5 + v26 + (int)v24);
      v14[2] = *(_BYTE *)(v5 + v23 + v26);
      v27 = v11[1];
      v14[3] = *(_BYTE *)(v5 + v21 + v27);
      LOBYTE(v21) = *(_BYTE *)(v5 + v27 + (int)v24);
      v28 = v10 + 2;
      v29 = v11 + 2;
      v14[4] = v21;
      v15 += 6;
      v14[5] = *(_BYTE *)(v5 + v23 + v27);
      v14 += 6;
      ++v17;
      v11 += 2;
      v10 += 2;
    }
    while ((_DWORD)v18 != (_DWORD)v17);
    LODWORD(v16) = *(_DWORD *)(result + 136);
    v13 += v17;
    v12 += v17;
    v10 = v28;
    v11 = v29;
  }
  if ((v16 & 1) != 0)
  {
    v30 = *v13;
    v31 = *(int *)(v7 + 4 * v30);
    v32 = *v12;
    v33 = *(_QWORD *)(v8 + 8 * v30) + *(_QWORD *)(v9 + 8 * v32);
    v34 = *(int *)(v6 + 4 * v32);
    v35 = *v10;
    v33 >>= 16;
    *v15 = *(_BYTE *)(v5 + v31 + v35);
    v15[1] = *(_BYTE *)(v5 + v35 + (int)v33);
    v15[2] = *(_BYTE *)(v5 + v34 + v35);
    v36 = *v11;
    *v14 = *(_BYTE *)(v5 + v31 + v36);
    v14[1] = *(_BYTE *)(v5 + v36 + (int)v33);
    v14[2] = *(_BYTE *)(v5 + v34 + v36);
  }
  return result;
}

uint64_t merged_1v_upsample(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 640) + 24))();
  ++*a6;
  ++*a3;
  return result;
}

uint64_t h2v1_merged_upsample(uint64_t result, _QWORD *a2, unsigned int a3, _BYTE **a4)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  _BYTE *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int8 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v4 = *(_QWORD **)(result + 640);
  v5 = *(_QWORD *)(result + 440);
  v7 = v4[4];
  v6 = v4[5];
  v8 = v4[6];
  v9 = v4[7];
  v10 = *(unsigned __int8 **)(*a2 + 8 * a3);
  v11 = *(unsigned __int8 **)(a2[1] + 8 * a3);
  v12 = *(unsigned __int8 **)(a2[2] + 8 * a3);
  v13 = *a4;
  v14 = *(_DWORD *)(result + 136);
  if (v14 < 2)
  {
    if ((v14 & 1) == 0)
      return result;
LABEL_7:
    v25 = *v11;
    v26 = *v12;
    v27 = (*(_QWORD *)(v8 + 8 * v26) + *(_QWORD *)(v9 + 8 * v25)) >> 16;
    v28 = *(int *)(v6 + 4 * v25);
    v29 = *v10;
    *v13 = *(_BYTE *)(v5 + *(int *)(v7 + 4 * v26) + v29);
    v13[1] = *(_BYTE *)(v5 + v29 + (int)v27);
    v13[2] = *(_BYTE *)(v5 + v28 + v29);
    return result;
  }
  v15 = v14 >> 1;
  do
  {
    v17 = *v11++;
    v16 = v17;
    v18 = *v12++;
    v19 = *(int *)(v7 + 4 * v18);
    v20 = (*(_QWORD *)(v8 + 8 * v18) + *(_QWORD *)(v9 + 8 * v16)) >> 16;
    v21 = *(int *)(v6 + 4 * v16);
    v22 = *v10;
    *v13 = *(_BYTE *)(v5 + v19 + v22);
    v13[1] = *(_BYTE *)(v5 + v22 + (int)v20);
    v13[2] = *(_BYTE *)(v5 + v21 + v22);
    v23 = v10 + 2;
    v24 = v10[1];
    v13[3] = *(_BYTE *)(v5 + v19 + v24);
    v13[4] = *(_BYTE *)(v5 + v24 + (int)v20);
    v13[5] = *(_BYTE *)(v5 + v21 + v24);
    v13 += 6;
    v10 = v23;
    --v15;
  }
  while (v15);
  v10 = v23;
  if ((*(_DWORD *)(result + 136) & 1) != 0)
    goto LABEL_7;
  return result;
}

uint64_t mq_decoder::start(uint64_t this, unsigned __int8 *a2, int a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL4 v10;
  int v11;
  unsigned __int8 *v12;
  int32x2_t v13;
  uint64_t v14;

  if (*(_BYTE *)(this + 38))
    mq_decoder::start();
  v4 = this;
  if (*(_QWORD *)(this + 16))
    mq_decoder::start();
  if (!a2 || a3 < 0)
    mq_decoder::start();
  if (!*(_BYTE *)(this + 39))
  {
    v5 = 0;
    v6 = &dword_1EDF088B0;
    do
    {
      v7 = dword_18820D6B8[v5 >> 1];
      *(v6 - 4) = v5 & 1 | (mq_decoder::p_bar_table[v7] << 8);
      *((_QWORD *)v6 - 1) = (char *)&mq_decoder::transition_table + 32 * (v5 & 1 | (2 * v7));
      v8 = dword_18820D774[v5 >> 1];
      this = mq_decoder::p_bar_table[v5 >> 1];
      v10 = v5 >> 1 != 46 && (_DWORD)this == 22017;
      v11 = v5 & 1 ^ v10;
      *v6 = v11 | (mq_decoder::p_bar_table[v8] << 8);
      *((_QWORD *)v6 + 1) = (char *)&mq_decoder::transition_table + 32 * (v11 | (2 * v8));
      ++v5;
      v6 += 8;
    }
    while (v5 != 94);
    *(_BYTE *)(v4 + 39) = 1;
  }
  *(_BYTE *)(v4 + 38) = 1;
  *(_BYTE *)(v4 + 37) = a4;
  *(_QWORD *)(v4 + 16) = a2;
  *(_QWORD *)(v4 + 24) = a2;
  *(_DWORD *)(v4 + 40) = a3;
  v12 = &a2[a3];
  *(_BYTE *)(v4 + 44) = *v12;
  *(_BYTE *)(v4 + 45) = v12[1];
  *(_WORD *)v12 = -1;
  *(_BYTE *)(v4 + 36) = 0;
  if (a4)
  {
    *(_DWORD *)(v4 + 32) = 0;
    *(_QWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 4) = 0;
    mq_decoder::fill_lsbs(v4);
    *(_DWORD *)(v4 + 4) <<= *(_DWORD *)(v4 + 8);
    this = mq_decoder::fill_lsbs(v4);
    v13 = *(int32x2_t *)(v4 + 4);
    LODWORD(v14) = vshl_n_s32(v13, 7uLL).u32[0];
    HIDWORD(v14) = vadd_s32(v13, (int32x2_t)0x600000006).i32[1];
    *(_QWORD *)(v4 + 4) = v14;
    *(_DWORD *)v4 = 0x800000;
  }
  else
  {
    *(_QWORD *)(v4 + 8) = 0;
  }
  return this;
}

uint64_t mq_decoder::fill_lsbs(uint64_t this)
{
  int v1;
  unsigned __int8 *v2;
  unsigned int v3;
  int v4;

  v1 = *(_DWORD *)(this + 12);
  v2 = *(unsigned __int8 **)(this + 24);
  *(_QWORD *)(this + 24) = v2 + 1;
  v3 = *v2;
  if (v1 != 255)
  {
    v4 = 8;
LABEL_6:
    *(_DWORD *)(this + 8) = v4;
    *(_DWORD *)(this + 12) = v3;
    goto LABEL_7;
  }
  if (v3 < 0x90)
  {
    v3 *= 2;
    v4 = 7;
    goto LABEL_6;
  }
  *(_QWORD *)(this + 24) = v2;
  *(_QWORD *)(this + 8) = 0xFF00000008;
  ++*(_DWORD *)(this + 32);
  v3 = 255;
LABEL_7:
  *(_DWORD *)(this + 4) += v3;
  return this;
}

uint64_t mq_decoder::finish(mq_decoder *this, char a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned __int8 *v12;
  int v13;

  if (!*((_BYTE *)this + 38) || *((_BYTE *)this + 36))
    mq_decoder::finish();
  if ((a2 & 1) != 0)
  {
    v3 = *((_QWORD *)this + 2);
    v2 = (unsigned __int8 *)*((_QWORD *)this + 3);
    v4 = *((int *)this + 10);
    v5 = (unsigned __int8 *)(v3 + v4);
    if (*((_BYTE *)this + 37))
    {
      if ((unint64_t)v2 > v3 + v4)
      {
        if (v2 != v5 + 1)
          mq_decoder::finish();
        v6 = *((_DWORD *)this + 8);
        v7 = v6 + 1;
        *((_DWORD *)this + 8) = v6 + 1;
        v8 = *((_DWORD *)this + 2);
        if (!v8)
        {
          v7 = v6 + 2;
          *((_DWORD *)this + 8) = v6 + 2;
          LOBYTE(v8) = 8;
          *((_DWORD *)this + 2) = 8;
        }
        if ((v7 - 4) >= 0xFFFFFFFE && !(*((int *)this + 1) >> (24 - v8)))
          goto LABEL_13;
      }
LABEL_20:
      v9 = 0;
      goto LABEL_21;
    }
    if ((unint64_t)v2 < v3 + v4 && *((_DWORD *)this + 3) == 255 && !*((_DWORD *)this + 2))
    {
      v12 = v2 + 1;
      *((_QWORD *)this + 3) = v2 + 1;
      v13 = *v2;
      *((_DWORD *)this + 2) = 8;
      *((_DWORD *)this + 3) = v13;
      v10 = 42;
      v2 = v12;
    }
    else
    {
      v10 = 85;
    }
    if (v2 != v5 || (*((_DWORD *)this + 3) & ~(-1 << *((_DWORD *)this + 2))) != v10 >> (8 - *((_DWORD *)this + 2)))
      goto LABEL_20;
  }
  else
  {
    v3 = *((_QWORD *)this + 2);
    v4 = *((int *)this + 10);
  }
LABEL_13:
  v9 = 1;
LABEL_21:
  *(_BYTE *)(v3 + v4) = *((_BYTE *)this + 44);
  *(_BYTE *)(*((int *)this + 10) + *((_QWORD *)this + 2) + 1) = *((_BYTE *)this + 45);
  *((_BYTE *)this + 38) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  return v9;
}

void mq_decoder::mq_decode(mq_decode *this, int *a2, uint64_t a3)
{
  int v4;
  int v5;
  int v6;
  int v7;
  BOOL v8;
  int v9;
  _OWORD *v10;
  _OWORD *v11;
  int v12;
  int v13;
  BOOL v14;
  int v15;
  uint64_t v16;

  if (!*((_BYTE *)this + 37) || !*((_BYTE *)this + 38) || *((_BYTE *)this + 36))
    mq_decoder::mq_decode();
  v4 = *(_DWORD *)a3 & 1;
  *a2 = v4;
  v5 = *(_DWORD *)a3 - v4;
  v6 = *((_DWORD *)this + 1);
  v7 = *(_DWORD *)this - v5;
  *(_DWORD *)this = v7;
  v8 = __OFSUB__(v6, v5);
  v9 = v6 - v5;
  if (v9 < 0 != v8)
  {
    if (v7 >= v5)
    {
      *a2 = 1 - *a2;
      v10 = (_OWORD *)(*(_QWORD *)(a3 + 8) + 16);
    }
    else
    {
      v10 = *(_OWORD **)(a3 + 8);
    }
    *(_OWORD *)a3 = *v10;
    *(_DWORD *)this = v5;
    v12 = *((_DWORD *)this + 2);
    do
    {
      if (!v12)
      {
        mq_decoder::fill_lsbs((uint64_t)this);
        v5 = *(_DWORD *)this;
        v12 = *((_DWORD *)this + 2);
      }
      v13 = 2 * *((_DWORD *)this + 1);
      *(_DWORD *)this = 2 * v5;
      *((_DWORD *)this + 1) = v13;
      *((_DWORD *)this + 2) = --v12;
      v14 = v5 < 0x400000;
      v5 *= 2;
    }
    while (v14);
  }
  else
  {
    *((_DWORD *)this + 1) = v9;
    if (v7 < 0x800000)
    {
      if (v7 >= v5)
      {
        v11 = *(_OWORD **)(a3 + 8);
      }
      else
      {
        *a2 = 1 - *a2;
        v11 = (_OWORD *)(*(_QWORD *)(a3 + 8) + 16);
      }
      *(_OWORD *)a3 = *v11;
      v15 = *((_DWORD *)this + 2);
      do
      {
        if (!v15)
        {
          mq_decoder::fill_lsbs((uint64_t)this);
          v15 = *((_DWORD *)this + 2);
        }
        v16 = *(_QWORD *)this;
        *(int32x2_t *)this = vadd_s32(*(int32x2_t *)this, *(int32x2_t *)this);
        *((_DWORD *)this + 2) = --v15;
      }
      while ((int)v16 < 0x400000);
    }
  }
}

void mq_decoder::mq_decode_run(mq_decoder *this, int *a2)
{
  int v4;
  _QWORD v5[2];

  if (!*((_BYTE *)this + 37) || !*((_BYTE *)this + 38) || *((_BYTE *)this + 36))
    mq_decoder::mq_decode_run();
  v5[1] = &unk_1EDF09420;
  v4 = 0;
  v5[0] = (dword_1EDF0128C << 8);
  mq_decoder::mq_decode(this, &v4, (uint64_t)v5);
  *a2 = 2 * v4;
  mq_decoder::mq_decode(this, &v4, (uint64_t)v5);
  *a2 += v4;
}

uint64_t (**_cg_jinit_c_main_controller(int *a1, int a2))(uint64_t result, int a2)
{
  uint64_t (**result)(uint64_t, int);
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  int *v8;
  uint64_t v9;
  int v10;
  int v11;

  result = (uint64_t (**)(uint64_t, int))(**((uint64_t (***)(void))a1 + 1))();
  *((_QWORD *)a1 + 63) = result;
  *result = start_pass_main_0;
  if (!a1[72])
  {
    if (a2)
    {
      v5 = *(_QWORD *)a1;
      *(_DWORD *)(v5 + 40) = 3;
      return (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(int *))v5)(a1);
    }
    else if (a1[23] >= 1)
    {
      v6 = 0;
      v7 = result + 4;
      v8 = (int *)(*((_QWORD *)a1 + 13) + 40);
      do
      {
        v9 = (*(v8 - 1) * *(v8 - 3));
        v10 = *(v8 - 7);
        v11 = *v8;
        v8 += 24;
        result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(int *, uint64_t, uint64_t, _QWORD))(*((_QWORD *)a1 + 1) + 16))(a1, 1, v9, (v11 * v10));
        v7[v6++] = result;
      }
      while (v6 < a1[23]);
    }
  }
  return result;
}

uint64_t start_pass_main_0(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;

  if (!*(_DWORD *)(result + 288))
  {
    v2 = *(_QWORD *)(result + 504);
    *(_QWORD *)(v2 + 16) = 0;
    *(_DWORD *)(v2 + 24) = 0;
    *(_DWORD *)(v2 + 28) = a2;
    if (a2)
    {
      v3 = *(_QWORD *)result;
      *(_DWORD *)(v3 + 40) = 3;
      return (*(uint64_t (**)(uint64_t))v3)(result);
    }
    else
    {
      *(_QWORD *)(v2 + 8) = process_data_simple_main_0;
    }
  }
  return result;
}

uint64_t process_data_simple_main_0(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  _DWORD *v4;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;

  v4 = *(_DWORD **)(result + 504);
  if (v4[4] < *(_DWORD *)(result + 368))
  {
    v8 = result;
    v9 = v4[5];
    do
    {
      v10 = *(_DWORD *)(v8 + 364);
      if (v9 < v10)
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *, uint64_t, _DWORD *, _DWORD *))(*(_QWORD *)(v8 + 512) + 8))(v8, a2, a3, a4, v4 + 8, v4 + 5);
        v9 = v4[5];
        v10 = *(_DWORD *)(v8 + 364);
      }
      if (v9 != v10)
        break;
      result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)(v8 + 520) + 8))(v8, v4 + 8);
      v11 = v4[6];
      if (!(_DWORD)result)
      {
        if (!v11)
        {
          --*a3;
          v4[6] = 1;
        }
        return result;
      }
      if (v11)
      {
        ++*a3;
        v4[6] = 0;
      }
      v9 = 0;
      v12 = v4[4] + 1;
      *((_QWORD *)v4 + 2) = v12;
    }
    while (v12 < *(_DWORD *)(v8 + 368));
  }
  return result;
}

uint64_t _cg_jpeg_abort(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(result + 8);
  if (v1)
  {
    v2 = result;
    result = (*(uint64_t (**)(void))(v1 + 72))();
    if (*(_DWORD *)(v2 + 32))
    {
      *(_DWORD *)(v2 + 36) = 200;
      *(_QWORD *)(v2 + 408) = 0;
    }
    else
    {
      *(_DWORD *)(v2 + 36) = 100;
    }
  }
  return result;
}

uint64_t _cg_jpeg_destroy(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = result;
  v2 = *(_QWORD *)(result + 8);
  if (v2)
    result = (*(uint64_t (**)(uint64_t))(v2 + 80))(result);
  *(_QWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t _cg_jpeg_alloc_quant_table(uint64_t a1)
{
  uint64_t result;

  result = (**(uint64_t (***)(void))(a1 + 8))();
  *(_DWORD *)(result + 128) = 0;
  return result;
}

uint64_t _cg_jpeg_alloc_huff_table(uint64_t a1)
{
  uint64_t result;

  result = (**(uint64_t (***)(void))(a1 + 8))();
  *(_DWORD *)(result + 276) = 0;
  return result;
}

uint64_t _cg_jpeg_std_huff_table(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  char *v8;
  void *v9;
  void *v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  uint8x16_t v14;
  uint16x8_t v15;
  uint16x8_t v16;
  unsigned int v17;
  size_t v18;
  void (**v19)(uint64_t);
  void (**v20)(uint64_t);

  v4 = a1 + 192;
  if (a2)
    v4 = a1 + 160;
  v5 = a1 + 264;
  if (a2)
    v5 = a1 + 232;
  if (*(_DWORD *)(a1 + 32))
    v6 = v5;
  else
    v6 = v4;
  if (a3 == 1)
  {
    v7 = a2 == 0;
    if (a2)
      v8 = (char *)&_cg_jpeg_std_huff_table_bits_dc_chrominance;
    else
      v8 = (char *)&_cg_jpeg_std_huff_table_bits_ac_chrominance;
    v9 = &_cg_jpeg_std_huff_table_val_dc_chrominance;
    v10 = &_cg_jpeg_std_huff_table_val_ac_chrominance;
LABEL_18:
    if (v7)
      v11 = v10;
    else
      v11 = v9;
    v12 = *(_QWORD *)(v6 + 8 * a3);
    if (!v12)
    {
      v13 = a3;
      v12 = (**(uint64_t (***)(uint64_t, _QWORD, uint64_t))(a1 + 8))(a1, 0, 280);
      *(_DWORD *)(v12 + 276) = 0;
      *(_QWORD *)(v6 + 8 * v13) = v12;
    }
    *(_OWORD *)v12 = *(_OWORD *)v8;
    *(_BYTE *)(v12 + 16) = v8[16];
    v14 = *(uint8x16_t *)(v8 + 1);
    v15 = vmovl_high_u8(v14);
    v16 = vmovl_u8(*(uint8x8_t *)v14.i8);
    v17 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v16.i8, *(uint16x4_t *)v15.i8), (int32x4_t)vaddl_high_u16(v16, v15)));
    v18 = v17;
    if (v17 < 0x101)
    {
      if (!v17)
      {
LABEL_28:
        *(_DWORD *)(v12 + 276) = 0;
        return v12;
      }
    }
    else
    {
      v19 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v19 + 10) = 9;
      (*v19)(a1);
    }
    memcpy((void *)(v12 + 17), v11, v18);
    goto LABEL_28;
  }
  if (!a3)
  {
    v7 = a2 == 0;
    if (a2)
      v8 = (char *)&_cg_jpeg_std_huff_table_bits_dc_luminance;
    else
      v8 = (char *)&_cg_jpeg_std_huff_table_bits_ac_luminance;
    v9 = &_cg_jpeg_std_huff_table_val_dc_luminance;
    v10 = &_cg_jpeg_std_huff_table_val_ac_luminance;
    goto LABEL_18;
  }
  v20 = *(void (***)(uint64_t))a1;
  *((_DWORD *)v20 + 10) = 52;
  *((_DWORD *)v20 + 12) = a3;
  (**(void (***)(uint64_t))a1)(a1);
  return 0;
}

void KTX2WritePlugin::~KTX2WritePlugin(KTX2WritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t KTX2WritePlugin::writeOneImage(KTX2WritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t KTX2WritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  const __CFDictionary *ObjectForKey;
  int v8;
  IIODictionary *v9;
  _BOOL4 v10;
  int VkFormat;
  int v12;
  int v13;
  int Error;
  __int16 BitmapInfo;
  IIODictionary *v16;
  BOOL v17;
  int v18;
  IIOWritePlugin *v19;
  size_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  IIODictionary *v25;
  char v27;
  char v28[4];
  __int128 v29;
  int v30;
  int v31;
  _BYTE v32[24];
  size_t v33;
  const void *v34;
  unsigned int *v35;
  _QWORD v36[2];

  v36[1] = *MEMORY[0x1E0C80C00];
  v35 = 0;
  v33 = 0;
  v34 = 0;
  if (!IIODictionary::containsKey(a3, CFSTR("kCGImagePropertyEncoder")))
  {
    Error = _cg_GifLastError((uint64_t)a2);
    BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
    if (Error == 32)
    {
      v13 = 0;
      v10 = 0;
      v12 = 0;
      v17 = (BitmapInfo & 0x100) == 0;
      v18 = 108;
    }
    else
    {
      if (Error != 16)
      {
        if (Error != 8 || (BitmapInfo & 0x100) != 0)
          return 4294967242;
        v13 = 0;
        v10 = 0;
        v12 = 0;
        VkFormat = 43;
        goto LABEL_18;
      }
      v13 = 0;
      v10 = 0;
      v12 = 0;
      v17 = (BitmapInfo & 0x100) == 0;
      v18 = 96;
    }
    if (v17)
      VkFormat = v18;
    else
      VkFormat = v18 + 1;
    goto LABEL_18;
  }
  ObjectForKey = IIODictionary::getObjectForKey(a3, CFSTR("kCGImagePropertyEncoder"));
  v8 = CFEqual(ObjectForKey, CFSTR("kCGImagePropertyPVREncoder"));
  v10 = v8 != 0;
  if (v8)
  {
    VkFormat = PVRWritePlugin::GetVkFormat(a3, v9);
    v12 = 0;
    v13 = 0;
    if (!VkFormat)
      return 4294967242;
  }
  else if (CFEqual(ObjectForKey, CFSTR("kCGImagePropertyBCEncoder")))
  {
    VkFormat = BCWritePlugin::GetVkFormat((uint64_t)a3, v16);
    v12 = 0;
    v13 = 1;
    if (!VkFormat)
      return 4294967242;
  }
  else
  {
    if (!CFEqual(ObjectForKey, CFSTR("kCGImagePropertyASTCEncoder")))
      return 4294967242;
    VkFormat = ASTCWritePlugin::GetVkFormat(a3, v25);
    v13 = 0;
    v12 = 1;
    if (!VkFormat)
      return 4294967242;
  }
LABEL_18:
  *(_OWORD *)&v32[8] = 0u;
  v29 = 0u;
  DWORD1(v29) = VkFormat;
  v30 = IIOImageSource::count(a2);
  v31 = IIO_Reader::testHeaderSize(a2);
  *(_OWORD *)v32 = xmmword_18820D9D0;
  *(_DWORD *)&v32[16] = 1;
  *(_WORD *)&v32[20] = 0;
  if (ktxTexture2_Create((uint64_t)&v29, 1, &v35)
    || (v36[0] = 0x4F496567616D49, ktxHashList_AddKVPair((uint64_t)(v35 + 20), "KTXwriter", 8u, v36))
    || (strcpy(v28, "rd"), ktxHashList_AddKVPair((uint64_t)(v35 + 20), "KTXorientation", 3u, v28))
    || (v27 = IIOImagePixelDataProvider::getAlphaInfo(a2) + 48,
        ktxHashList_AddKVPair((uint64_t)(v35 + 20), "AlphaInfo_APPLE", 1u, &v27)))
  {
    v21 = 0;
    goto LABEL_48;
  }
  if (!v10)
  {
    if (v13)
    {
      v19 = (IIOWritePlugin *)operator new();
      BCWritePlugin::BCWritePlugin(v19, this[2], this[3], (uint64_t)v35);
      goto LABEL_28;
    }
    if (v12)
    {
      v19 = (IIOWritePlugin *)operator new();
      ASTCWritePlugin::ASTCWritePlugin(v19, this[2], this[3], (uint64_t)v35);
      goto LABEL_28;
    }
    v23 = IIOImagePlus::sourceImageProvider(a2);
    v24 = IIO_Reader::testHeaderSize(a2) * v23;
    v21 = malloc_type_malloc(v24, 0xB0A10883uLL);
    if (v21)
    {
      IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v21);
      if ((*(uint64_t (**)(void))(*((_QWORD *)v35 + 1) + 24))() == v24
        && !(*(unsigned int (**)(void))(*((_QWORD *)v35 + 1) + 64))())
      {
        free(v21);
        v19 = 0;
        goto LABEL_29;
      }
    }
LABEL_48:
    v19 = 0;
    goto LABEL_49;
  }
  v19 = (IIOWritePlugin *)operator new();
  PVRWritePlugin::PVRWritePlugin(v19, this[2], this[3], (uint64_t)v35);
LABEL_28:
  (*(void (**)(IIOWritePlugin *))(*(_QWORD *)v19 + 16))(v19);
LABEL_29:
  if (!(*(unsigned int (**)(void))(*((_QWORD *)v35 + 1) + 96))())
  {
    v20 = IIOImageWriteSession::putBytes(this[2], v34, v33);
    v21 = 0;
    if (v20 == v33)
      v22 = 0;
    else
      v22 = 4294967246;
    goto LABEL_33;
  }
  v21 = 0;
LABEL_49:
  v22 = 4294967246;
LABEL_33:
  if (v35)
    (**((void (***)(void))v35 + 1))();
  if (v21)
    free(v21);
  if (v19)
    (*(void (**)(IIOWritePlugin *))(*(_QWORD *)v19 + 8))(v19);
  return v22;
}

void sub_187F49E28(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40498E0FA1);
  _Unwind_Resume(a1);
}

uint64_t KTX2WritePlugin::WriteProc(KTX2WritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 0x10u);
  *(_QWORD *)&v9[0] = &off_1E1BB0A70;
  v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9);
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_187F49EE0(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _cg_jpeg_mem_term(&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187F49ECCLL);
}

uint64_t IIOWritePlugin::writeImageAtIndex(IIOWritePlugin *this, IIOImagePixelDataProvider *a2, CGImage *a3, IIODictionary *a4, IIODictionary *a5, unsigned int a6, uint64_t *a7)
{
  return 4294967292;
}

uint64_t IIOWritePlugin::completePerFrameSaving(IIOWritePlugin *this)
{
  return 0;
}

uint64_t _cg_jpeg_resync_to_restart(_DWORD *a1, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = a1[143];
  v5 = *(_QWORD *)a1;
  *(_DWORD *)(v5 + 40) = 124;
  *(_DWORD *)(v5 + 48) = v4;
  *(_DWORD *)(*(_QWORD *)a1 + 52) = a2;
  (*(void (**)(_DWORD *, uint64_t))(*(_QWORD *)a1 + 8))(a1, 0xFFFFFFFFLL);
  while (1)
  {
    if (v4 >= 192)
    {
      if ((v4 - 216) < 0xFFFFFFF8
        || v4 == (((_BYTE)a2 + 1) & 7 | 0xD0)
        || v4 == (((_BYTE)a2 + 2) & 7 | 0xD0))
      {
        v8 = *(_QWORD *)a1;
        *(_DWORD *)(v8 + 40) = 99;
        *(_DWORD *)(v8 + 48) = v4;
        *(_DWORD *)(*(_QWORD *)a1 + 52) = 3;
        (*(void (**)(_DWORD *, uint64_t))(*(_QWORD *)a1 + 8))(a1, 4);
        return 1;
      }
      if (v4 != (((_BYTE)a2 - 1) & 7 | 0xD0) && v4 != ((a2 + 6) & 7 | 0xD0))
        break;
    }
    v6 = *(_QWORD *)a1;
    *(_DWORD *)(v6 + 40) = 99;
    *(_DWORD *)(v6 + 48) = v4;
    *(_DWORD *)(*(_QWORD *)a1 + 52) = 2;
    (*(void (**)(_DWORD *, uint64_t))(*(_QWORD *)a1 + 8))(a1, 4);
    if (!next_marker(a1))
      return 0;
    v4 = a1[143];
  }
  v9 = *(_QWORD *)a1;
  *(_DWORD *)(v9 + 40) = 99;
  *(_DWORD *)(v9 + 48) = v4;
  v7 = 1;
  *(_DWORD *)(*(_QWORD *)a1 + 52) = 1;
  (*(void (**)(_DWORD *, uint64_t))(*(_QWORD *)a1 + 8))(a1, 4);
  a1[143] = 0;
  return v7;
}

uint64_t next_marker(_QWORD *a1)
{
  unsigned __int8 **v2;
  unsigned __int8 *v3;
  unsigned __int8 *i;
  uint64_t result;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  for (i = v2[1]; i; v2[1] = i)
  {
LABEL_4:
    v6 = *v3++;
    --i;
    if (v6 == 255)
    {
      do
      {
        if (!i)
        {
          result = ((uint64_t (*)(_QWORD *))v2[3])(a1);
          if (!(_DWORD)result)
            return result;
          v3 = *v2;
          i = v2[1];
        }
        --i;
        v10 = *v3++;
        v9 = v10;
      }
      while (v10 == 255);
      if (v9)
      {
        v11 = *(_DWORD *)(a1[77] + 36);
        if (v11)
        {
          v12 = *a1;
          *(_DWORD *)(v12 + 40) = 119;
          *(_DWORD *)(v12 + 48) = v11;
          *(_DWORD *)(*a1 + 52) = v9;
          (*(void (**)(_QWORD *, uint64_t))(*a1 + 8))(a1, 0xFFFFFFFFLL);
          *(_DWORD *)(a1[77] + 36) = 0;
        }
        *((_DWORD *)a1 + 143) = v9;
        result = 1;
        *v2 = v3;
        v2[1] = i;
        return result;
      }
      v7 = a1[77];
      v8 = *(_DWORD *)(v7 + 36) + 2;
    }
    else
    {
      v7 = a1[77];
      v8 = *(_DWORD *)(v7 + 36) + 1;
    }
    *(_DWORD *)(v7 + 36) = v8;
    *v2 = v3;
  }
  result = ((uint64_t (*)(_QWORD *))v2[3])(a1);
  if ((_DWORD)result)
  {
    v3 = *v2;
    i = v2[1];
    goto LABEL_4;
  }
  return result;
}

void _cg_jinit_marker_reader(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;
  _QWORD *v4;
  uint64_t v5;

  v2 = (**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 616) = v2;
  *(_QWORD *)v2 = reset_marker_reader;
  *(_QWORD *)(v2 + 8) = read_markers;
  *(_QWORD *)(v2 + 16) = read_restart_marker;
  *(_QWORD *)(v2 + 40) = skip_variable;
  *(_DWORD *)(v2 + 176) = 0;
  memset_pattern16((void *)(v2 + 48), off_1E1BBE4D0, 0x80uLL);
  for (i = 0; i != 64; i += 16)
  {
    v4 = (_QWORD *)(v2 + 180 + i);
    *v4 = 0;
    v4[1] = 0;
  }
  *(_QWORD *)(v2 + 48) = get_interesting_appn;
  *(_QWORD *)(v2 + 160) = get_interesting_appn;
  v5 = *(_QWORD *)(a1 + 616);
  *(_QWORD *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_QWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 36) = 0;
  *(_QWORD *)(v5 + 248) = 0;
}

uint64_t reset_marker_reader(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 616);
  *(_QWORD *)(result + 304) = 0;
  *(_DWORD *)(result + 172) = 0;
  *(_DWORD *)(result + 572) = 0;
  *(_QWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  *(_QWORD *)(v1 + 248) = 0;
  return result;
}

uint64_t read_markers(uint64_t a1)
{
  __int32 v2;
  uint64_t result;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  int v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  uint64_t v11;
  uint32x4_t *v12;
  int v13;
  uint32x4_t *v14;
  uint64_t *v15;
  int v16;
  int v17;
  int v18;
  unsigned __int8 **v19;
  unsigned __int8 *v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  unsigned int v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint32x4_t *v31;
  uint8x8_t v32;
  int64_t v33;
  uint64_t i;
  int v35;
  int64_t v36;
  uint32x4_t *v37;
  uint32x4_t v38;
  __n128 v39;
  uint32x4_t *v40;
  uint32x4_t v41;
  uint32x4_t *v42;
  _BYTE *v43;
  int64_t v44;
  char v45;
  uint32x4_t *v46;
  uint64_t v47;
  uint32x4_t *v48;
  uint32x4_t *v49;
  uint64_t v50;
  uint32x4_t *v51;
  unsigned __int8 **v52;
  unsigned __int8 *v53;
  uint64_t v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  unsigned __int8 *v57;
  unsigned int v58;
  unint64_t v59;
  unsigned __int8 *v60;
  unsigned __int8 *v61;
  uint64_t v62;
  unsigned int v63;
  unsigned __int8 *v64;
  unsigned int v65;
  uint32x4_t *v66;
  uint32x4_t *v67;
  unint64_t v68;
  uint64_t v69;
  uint32x4_t *v70;
  uint32x4_t *v71;
  uint64_t v72;
  uint32x4_t *v73;
  unsigned __int8 **v74;
  unsigned __int8 *v75;
  uint64_t v76;
  unsigned __int8 *v77;
  unsigned __int8 *v78;
  unsigned __int8 *v79;
  unsigned __int8 *v80;
  unsigned int v81;
  unint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  uint32x4_t *v86;
  uint32x4_t *v87;
  uint64_t v88;
  uint16x4_t **v89;
  uint16x4_t *v90;
  uint16x4_t *v91;
  unint64_t v92;
  int *v93;
  unint64_t v94;
  __int16 v95;
  __int16 v96;
  __int16 v97;
  uint64_t v98;
  uint16x4_t *v99;
  unint64_t v100;
  uint32x4_t *v101;
  uint16x4_t v102;
  unint64_t v103;
  unsigned __int8 **v104;
  unsigned __int8 *v105;
  unsigned __int8 *v106;
  uint64_t v107;
  unsigned __int8 *v108;
  unsigned __int8 *v109;
  unsigned int v110;
  uint32x4_t *v111;
  unsigned __int8 *v112;
  unsigned __int8 *v113;
  int v114;
  int v115;
  unsigned __int8 *v116;
  int v117;
  unsigned __int8 *v118;
  int v119;
  uint32x4_t *v120;
  unsigned __int8 **v121;
  unsigned __int8 *v122;
  unsigned __int8 *v123;
  uint32x4_t *v124;
  uint64_t v125;
  unsigned __int8 *v126;
  unsigned int v127;
  unsigned __int8 *v128;
  unsigned __int8 *v129;
  unsigned int v130;
  uint32x4_t *v131;
  unsigned __int8 *v132;
  unsigned __int8 *v133;
  int v134;
  uint32x4_t *v135;
  unsigned __int8 *v136;
  int v137;
  unsigned __int8 *v138;
  int v139;
  unsigned __int8 *v140;
  int v141;
  int v142;
  int v143;
  _DWORD *v144;
  int v145;
  int v146;
  int v147;
  int v148;
  unsigned __int8 *v149;
  int v150;
  unsigned __int8 *v151;
  int v152;
  int v153;
  unsigned __int8 *v154;
  int v155;
  unsigned __int8 *v156;
  int v157;
  int v159;
  unsigned __int8 *v160;
  int v161;
  unsigned __int8 *v162;
  int v163;
  int v164;
  unsigned __int8 *v165;
  int v166;
  unsigned __int8 *v167;
  int v168;
  int v170;
  unsigned __int8 *v171;
  int v172;
  unsigned __int8 *v173;
  int v174;
  int v175;
  unsigned __int8 *v176;
  int v177;
  unsigned __int8 *v178;
  int v179;
  uint32x4_t *v180;
  uint32x4_t *v181;
  uint32x4_t *v182;
  uint32x4_t *v183;
  unsigned __int8 **v184;
  unsigned __int8 *v185;
  unsigned __int8 *v186;
  uint32x4_t *v187;
  unsigned __int8 *v188;
  uint64_t v189;
  unsigned int v190;
  unsigned __int8 *v191;
  unsigned __int8 *v192;
  uint64_t v193;
  unsigned int v194;
  unsigned __int8 *v195;
  uint64_t v196;
  uint64_t v197;
  uint32x4_t *v198;
  uint32x4_t *v200;
  unsigned __int8 *v201;
  unsigned __int8 *v202;
  unint64_t v203;
  __int32 v204;
  unsigned __int8 *v205;
  int v206;
  uint64_t v207;
  int v208;
  uint64_t v209;
  __int32 *v210;
  int v211;
  uint64_t v212;
  uint32x4_t *v213;
  unsigned __int8 *v214;
  unsigned int v215;
  uint32x4_t *v216;
  char v217;
  unsigned __int8 *v218;
  int v219;
  unsigned __int8 *v220;
  unsigned __int8 *v221;
  int v222;
  unsigned __int8 *v223;
  unsigned __int8 *v224;
  unsigned __int8 *v225;
  unsigned int v226;
  uint32x4_t *v227;
  uint64_t v228;
  _QWORD *v229;
  _QWORD *v230;
  _QWORD *v231;
  _OWORD __src[16];
  _BYTE v233[17];
  uint64_t v234;

  v230 = (_QWORD *)(a1 + 340);
  v231 = (_QWORD *)(a1 + 324);
  v234 = *MEMORY[0x1E0C80C00];
  v229 = (_QWORD *)(a1 + 356);
  v2 = *(_DWORD *)(a1 + 572);
  if (v2)
    goto LABEL_15;
  while (2)
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 616) + 24))
    {
      result = next_marker((_QWORD *)a1);
      if (!(_DWORD)result)
        return result;
      v2 = *(_DWORD *)(a1 + 572);
    }
    else
    {
      v4 = *(unsigned __int8 ***)(a1 + 40);
      v5 = v4[1];
      if (!v5)
      {
        result = ((uint64_t (*)(uint64_t))v4[3])(a1);
        if (!(_DWORD)result)
          return result;
        v5 = v4[1];
      }
      v6 = *v4 + 1;
      v7 = **v4;
      v8 = v5 - 1;
      if (v5 == (unsigned __int8 *)1)
      {
        result = ((uint64_t (*)(uint64_t))v4[3])(a1);
        if (!(_DWORD)result)
          return result;
        v6 = *v4;
        v8 = v4[1];
      }
      v10 = *v6;
      v9 = v6 + 1;
      v2 = v10;
      if (v7 != 255 || v2 != 216)
      {
        v11 = *(_QWORD *)a1;
        *(_DWORD *)(v11 + 40) = 55;
        *(_DWORD *)(v11 + 48) = v7;
        *(_DWORD *)(*(_QWORD *)a1 + 52) = v2;
        (**(void (***)(uint64_t))a1)(a1);
      }
      *(_DWORD *)(a1 + 572) = v2;
      *v4 = v9;
      v4[1] = v8 - 1;
    }
LABEL_15:
    switch(v2)
    {
      case 192:
        v15 = (uint64_t *)a1;
        v16 = 1;
        goto LABEL_26;
      case 193:
        v15 = (uint64_t *)a1;
        v16 = 0;
LABEL_26:
        v17 = 0;
        goto LABEL_28;
      case 194:
        v15 = (uint64_t *)a1;
        v16 = 0;
        v17 = 1;
LABEL_28:
        v18 = 0;
        goto LABEL_74;
      case 195:
      case 197:
      case 198:
      case 199:
      case 200:
      case 203:
      case 205:
      case 206:
      case 207:
        v12 = *(uint32x4_t **)a1;
        v13 = 63;
        goto LABEL_20;
      case 196:
        memset(v233, 0, sizeof(v233));
        memset(__src, 0, sizeof(__src));
        v19 = *(unsigned __int8 ***)(a1 + 40);
        v20 = v19[1];
        if (v20)
          goto LABEL_32;
        if (!((unsigned int (*)(uint64_t))v19[3])(a1))
          return 0;
        v20 = v19[1];
LABEL_32:
        v22 = *v19 + 1;
        v21 = **v19;
        v23 = v20 - 1;
        if (v23)
          goto LABEL_35;
        if (!((unsigned int (*)(uint64_t))v19[3])(a1))
          return 0;
        v22 = *v19;
        v23 = v19[1];
LABEL_35:
        v24 = v23 - 1;
        v26 = *v22;
        v25 = v22 + 1;
        v27 = (v21 << 8) | v26;
        v28 = v27 - 2;
        if (v27 < 0x13)
          goto LABEL_68;
        while (2)
        {
          if (v24)
            goto LABEL_39;
          if (((unsigned int (*)(uint64_t))v19[3])(a1))
          {
            v25 = *v19;
            v24 = v19[1];
LABEL_39:
            v30 = *v25++;
            v29 = v30;
            v31 = *(uint32x4_t **)a1;
            v31[2].i32[2] = 82;
            v31[3].i32[0] = v30;
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, 1);
            LODWORD(v33) = 0;
            v233[0] = 0;
            --v24;
            for (i = 1; i != 17; ++i)
            {
              if (!v24)
              {
                if (!((unsigned int (*)(uint64_t))v19[3])(a1))
                  return 0;
                v25 = *v19;
                v24 = v19[1];
              }
              v35 = *v25++;
              v233[i] = v35;
              v33 = (v33 + v35);
              --v24;
            }
            v36 = v28 - 17;
            v37 = *(uint32x4_t **)a1;
            v32.i32[0] = *(_DWORD *)&v233[1];
            v38 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v32));
            v37[3] = v38;
            v38.i32[0] = *(_DWORD *)&v233[5];
            v37[4] = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v38.i8));
            v37[2].i32[2] = 88;
            v39 = ((__n128 (*)(uint64_t, uint64_t))v37->i64[1])(a1, 2);
            v40 = *(uint32x4_t **)a1;
            v39.n128_u32[0] = *(_DWORD *)&v233[9];
            v41 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v39.n128_u64[0]));
            v40[3] = v41;
            v41.i32[0] = *(_DWORD *)&v233[13];
            v40[4] = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v41.i8));
            v40[2].i32[2] = 88;
            ((void (*)(uint64_t, uint64_t))v40->i64[1])(a1, 2);
            if (v33 > 0x100 || v36 < v33)
            {
              v42 = *(uint32x4_t **)a1;
              v42[2].i32[2] = 9;
              ((void (*)(uint64_t))v42->i64[0])(a1);
              if (!(_DWORD)v33)
                goto LABEL_54;
            }
            else if (!(_DWORD)v33)
            {
              goto LABEL_54;
            }
            v43 = __src;
            v44 = v33;
            do
            {
              if (!v24)
              {
                if (!((unsigned int (*)(uint64_t))v19[3])(a1))
                  return 0;
                v25 = *v19;
                v24 = v19[1];
              }
              --v24;
              v45 = *v25++;
              *v43++ = v45;
              --v44;
            }
            while (v44);
LABEL_54:
            if ((v29 & 0x10) != 0)
            {
              if ((v29 - 20) <= 0xFFFFFFFB)
              {
                v48 = *(uint32x4_t **)a1;
                v48[2].i32[2] = 12;
                ((void (*)(uint64_t))v48->i64[0])(a1);
              }
              v29 -= 16;
              v47 = a1 + 8 * v29 + 264;
            }
            else
            {
              if (v29 >= 4)
              {
                v46 = *(uint32x4_t **)a1;
                v46[2].i32[2] = 12;
                ((void (*)(uint64_t))v46->i64[0])(a1);
              }
              v47 = a1 + 8 * v29 + 232;
            }
            if (v29 >= 4)
            {
              v49 = *(uint32x4_t **)a1;
              v49[2].i32[2] = 31;
              v49[3].i32[0] = v29;
              (**(void (***)(uint64_t))a1)(a1);
            }
            v50 = *(_QWORD *)v47;
            if (!*(_QWORD *)v47)
            {
              v50 = _cg_jpeg_alloc_huff_table(a1);
              *(_QWORD *)v47 = v50;
            }
            *(_OWORD *)v50 = *(_OWORD *)v233;
            *(_BYTE *)(v50 + 16) = v233[16];
            if ((_DWORD)v33)
              memcpy((void *)(*(_QWORD *)v47 + 17), __src, v33);
            v28 = v36 - v33;
            if (v36 - v33 <= 16)
            {
LABEL_68:
              if (v28)
              {
                v51 = *(uint32x4_t **)a1;
                v51[2].i32[2] = 12;
                ((void (*)(uint64_t))v51->i64[0])(a1);
              }
              *v19 = v25;
              v19[1] = v24;
              goto LABEL_278;
            }
            continue;
          }
          return 0;
        }
      case 201:
        v15 = (uint64_t *)a1;
        v16 = 0;
        v17 = 0;
        goto LABEL_73;
      case 202:
        v15 = (uint64_t *)a1;
        v16 = 0;
        v17 = 1;
LABEL_73:
        v18 = 1;
LABEL_74:
        result = get_sof(v15, v16, v17, v18);
        if (!(_DWORD)result)
          return result;
        goto LABEL_278;
      case 204:
        v52 = *(unsigned __int8 ***)(a1 + 40);
        v53 = v52[1];
        if (v53)
          goto LABEL_79;
        result = ((uint64_t (*)(uint64_t))v52[3])(a1);
        if (!(_DWORD)result)
          return result;
        v53 = v52[1];
LABEL_79:
        v55 = *v52 + 1;
        v54 = **v52;
        v56 = v53 - 1;
        if (v56)
          goto LABEL_82;
        result = ((uint64_t (*)(uint64_t))v52[3])(a1);
        if (!(_DWORD)result)
          return result;
        v55 = *v52;
        v56 = v52[1];
LABEL_82:
        v58 = *v55;
        v57 = v55 + 1;
        v59 = (v54 << 8) | v58;
        v60 = v56 - 1;
        if (v59 >= 3)
        {
          while (1)
          {
            if (!v60)
            {
              result = ((uint64_t (*)(uint64_t))v52[3])(a1);
              if (!(_DWORD)result)
                return result;
              v57 = *v52;
              v60 = v52[1];
            }
            v63 = *v57;
            v61 = v57 + 1;
            v62 = v63;
            v64 = v60 - 1;
            if (!v64)
            {
              result = ((uint64_t (*)(uint64_t))v52[3])(a1);
              if (!(_DWORD)result)
                return result;
              v61 = *v52;
              v64 = v52[1];
            }
            v65 = *v61;
            v66 = *(uint32x4_t **)a1;
            v66[2].i32[2] = 81;
            v66[3].i32[0] = v62;
            *(_DWORD *)(*(_QWORD *)a1 + 52) = v65;
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, 1);
            if (v62 < 0x20)
            {
              if (v62 < 0x10)
              {
                v69 = a1 + v62;
                *(_BYTE *)(v69 + 324) = v65 & 0xF;
                *(_BYTE *)(v69 + 340) = v65 >> 4;
                if ((v65 & 0xF) > v65 >> 4)
                {
                  v70 = *(uint32x4_t **)a1;
                  v70[2].i32[2] = 30;
                  v70[3].i32[0] = v65;
                  (**(void (***)(uint64_t))a1)(a1);
                }
                goto LABEL_93;
              }
            }
            else
            {
              v67 = *(uint32x4_t **)a1;
              v67[2].i32[2] = 29;
              v67[3].i32[0] = v62;
              (**(void (***)(uint64_t))a1)(a1);
            }
            *(_BYTE *)(a1 + (v62 - 16) + 356) = v65;
LABEL_93:
            v57 = v61 + 1;
            v60 = v64 - 1;
            v59 -= 2;
            v68 = v59 - 2;
            if (v59 <= 2)
              goto LABEL_273;
          }
        }
        v68 = v59 - 2;
LABEL_273:
        if (v68)
        {
          v181 = *(uint32x4_t **)a1;
          v181[2].i32[2] = 12;
          ((void (*)(uint64_t))v181->i64[0])(a1);
        }
        *v52 = v57;
        v52[1] = v60;
LABEL_278:
        *(_DWORD *)(a1 + 572) = 0;
        continue;
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
        goto LABEL_22;
      case 216:
        v71 = *(uint32x4_t **)a1;
        v71[2].i32[2] = 104;
        ((void (*)(uint64_t, uint64_t))v71->i64[1])(a1, 1);
        v72 = *(_QWORD *)(a1 + 616);
        if (*(_DWORD *)(v72 + 24))
        {
          v73 = *(uint32x4_t **)a1;
          v73[2].i32[2] = 64;
          ((void (*)(uint64_t))v73->i64[0])(a1);
          v72 = *(_QWORD *)(a1 + 616);
        }
        *v231 = 0;
        v231[1] = 0;
        *v230 = 0x101010101010101;
        v230[1] = 0x101010101010101;
        *v229 = 0x505050505050505;
        v229[1] = 0x505050505050505;
        *(_QWORD *)(a1 + 372) = 0;
        *(_DWORD *)(a1 + 60) = 0;
        *(_QWORD *)(a1 + 396) = 0;
        *(_WORD *)(a1 + 380) = 257;
        *(_BYTE *)(a1 + 382) = 0;
        *(_QWORD *)(a1 + 384) = 65537;
        *(_BYTE *)(a1 + 392) = 0;
        *(_DWORD *)(v72 + 24) = 1;
        goto LABEL_278;
      case 217:
        v183 = *(uint32x4_t **)a1;
        v183[2].i32[2] = 87;
        ((void (*)(uint64_t, uint64_t))v183->i64[1])(a1, 1);
        *(_DWORD *)(a1 + 572) = 0;
        return 2;
      case 218:
        v184 = *(unsigned __int8 ***)(a1 + 40);
        v185 = *v184;
        v186 = v184[1];
        if (!*(_DWORD *)(*(_QWORD *)(a1 + 616) + 28))
        {
          v187 = *(uint32x4_t **)a1;
          v187[2].i32[2] = 60;
          v187[5] = (uint32x4_t)xmmword_18820DA90;
          v187[6] = (uint32x4_t)unk_18820DAA0;
          v187[7] = (uint32x4_t)xmmword_18820DAB0;
          v187[3] = (uint32x4_t)xmmword_18820DA70;
          v187[4] = (uint32x4_t)unk_18820DA80;
          (**(void (***)(uint64_t))a1)(a1);
        }
        if (v186)
          goto LABEL_287;
        result = ((uint64_t (*)(uint64_t))v184[3])(a1);
        if (!(_DWORD)result)
          return result;
        v185 = *v184;
        v186 = v184[1];
LABEL_287:
        v190 = *v185;
        v188 = v185 + 1;
        v189 = v190;
        v191 = v186 - 1;
        if (v186 != (unsigned __int8 *)1)
          goto LABEL_290;
        result = ((uint64_t (*)(uint64_t))v184[3])(a1);
        if (!(_DWORD)result)
          return result;
        v188 = *v184;
        v191 = v184[1];
LABEL_290:
        v194 = *v188;
        v192 = v188 + 1;
        v193 = v194;
        v195 = v191 - 1;
        if (v191 != (unsigned __int8 *)1)
          goto LABEL_293;
        result = ((uint64_t (*)(uint64_t))v184[3])(a1);
        if (!(_DWORD)result)
          return result;
        v192 = *v184;
        v195 = v184[1];
LABEL_293:
        v196 = (v189 << 8) | v193;
        v197 = *v192;
        v198 = *(uint32x4_t **)a1;
        v198[2].i32[2] = 105;
        v198[3].i32[0] = v197;
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, 1);
        if (v196 != 2 * v197 + 6 || v197 > 4)
          goto LABEL_298;
        if ((_DWORD)v197)
        {
          *(_DWORD *)(a1 + 448) = v197;
          v201 = v192 + 1;
          v202 = v195 - 1;
          goto LABEL_302;
        }
        if (*(_DWORD *)(a1 + 316))
        {
          *(_DWORD *)(a1 + 448) = 0;
          v201 = v192 + 1;
          v202 = v195 - 1;
        }
        else
        {
LABEL_298:
          v200 = *(uint32x4_t **)a1;
          v200[2].i32[2] = 12;
          ((void (*)(uint64_t))v200->i64[0])(a1);
          *(_DWORD *)(a1 + 448) = v197;
          v201 = v192 + 1;
          v202 = v195 - 1;
          if ((_DWORD)v197)
          {
LABEL_302:
            v203 = 0;
            while (1)
            {
              if (!v202)
              {
                result = ((uint64_t (*)(uint64_t))v184[3])(a1);
                if (!(_DWORD)result)
                  return result;
                v201 = *v184;
                v202 = v184[1];
              }
              v206 = *v201;
              v205 = v201 + 1;
              v204 = v206;
              if (v203)
              {
                v207 = 0;
                while (**(_DWORD **)(a1 + 456 + 8 * v207) != v204)
                {
                  if (v203 == ++v207)
                    goto LABEL_317;
                }
                v208 = **(_DWORD **)(a1 + 456);
                if (v203 >= 2)
                {
                  v209 = 0;
                  do
                  {
                    if (**(_DWORD **)(a1 + 464 + 8 * v209) > v208)
                      v208 = **(_DWORD **)(a1 + 464 + 8 * v209);
                    ++v209;
                  }
                  while (v203 - 1 != v209);
                }
                v204 = v208 + 1;
              }
LABEL_317:
              v210 = *(__int32 **)(a1 + 304);
              v211 = *(_DWORD *)(a1 + 56);
              if (v211 >= 1)
              {
                v212 = (uint64_t)&v210[24 * (v211 - 1) + 24];
                do
                {
                  if (v204 == *v210)
                    goto LABEL_323;
                  v210 += 24;
                  --v211;
                }
                while (v211);
                v210 = (__int32 *)v212;
              }
              v213 = *(uint32x4_t **)a1;
              v213[2].i32[2] = 4;
              v213[3].i32[0] = v204;
              (**(void (***)(uint64_t))a1)(a1);
LABEL_323:
              *(_QWORD *)(a1 + 8 * v203 + 456) = v210;
              v214 = v202 - 1;
              if (!v214)
              {
                result = ((uint64_t (*)(uint64_t))v184[3])(a1);
                if (!(_DWORD)result)
                  return result;
                v205 = *v184;
                v214 = v184[1];
              }
              v215 = *v205;
              v201 = v205 + 1;
              v210[5] = v215 >> 4;
              v210[6] = v215 & 0xF;
              v216 = *(uint32x4_t **)a1;
              v216[3].i32[0] = *v210;
              v216[3].i32[1] = v210[5];
              v216[3].i32[2] = v210[6];
              v216[2].i32[2] = 106;
              ((void (*)(uint64_t, uint64_t))v216->i64[1])(a1, 1);
              ++v203;
              v202 = v214 - 1;
              if (v203 == v197)
              {
                v217 = 0;
                goto LABEL_331;
              }
            }
          }
        }
        v217 = 1;
LABEL_331:
        if (v202)
          goto LABEL_334;
        result = ((uint64_t (*)(uint64_t))v184[3])(a1);
        if (!(_DWORD)result)
          return result;
        v201 = *v184;
        v202 = v184[1];
LABEL_334:
        v219 = *v201;
        v218 = v201 + 1;
        *(_DWORD *)(a1 + 540) = v219;
        v220 = v202 - 1;
        if (v202 != (unsigned __int8 *)1)
          goto LABEL_337;
        result = ((uint64_t (*)(uint64_t))v184[3])(a1);
        if (!(_DWORD)result)
          return result;
        v218 = *v184;
        v220 = v184[1];
LABEL_337:
        v222 = *v218;
        v221 = v218 + 1;
        *(_DWORD *)(a1 + 544) = v222;
        v223 = v220 - 1;
        if (v223)
          goto LABEL_340;
        result = ((uint64_t (*)(uint64_t))v184[3])(a1);
        if ((_DWORD)result)
        {
          v221 = *v184;
          v223 = v184[1];
LABEL_340:
          v224 = v223 - 1;
          v226 = *v221;
          v225 = v221 + 1;
          *(_DWORD *)(a1 + 548) = v226 >> 4;
          *(_DWORD *)(a1 + 552) = v226 & 0xF;
          v227 = *(uint32x4_t **)a1;
          v227[3].i32[0] = *(_DWORD *)(a1 + 540);
          v227[3].i32[1] = *(_DWORD *)(a1 + 544);
          v227[3].i32[2] = *(_DWORD *)(a1 + 548);
          v227[3].i32[3] = *(_DWORD *)(a1 + 552);
          v227[2].i32[2] = 107;
          ((void (*)(uint64_t, uint64_t))v227->i64[1])(a1, 1);
          *(_DWORD *)(*(_QWORD *)(a1 + 616) + 32) = 0;
          if ((v217 & 1) == 0)
            ++*(_DWORD *)(a1 + 172);
          *v184 = v225;
          v184[1] = v224;
          result = 1;
          *(_DWORD *)(a1 + 572) = 0;
        }
        return result;
      case 219:
        v74 = *(unsigned __int8 ***)(a1 + 40);
        v75 = v74[1];
        if (v75)
          goto LABEL_103;
        result = ((uint64_t (*)(uint64_t))v74[3])(a1);
        if (!(_DWORD)result)
          return result;
        v75 = v74[1];
LABEL_103:
        v77 = *v74 + 1;
        v76 = **v74;
        v78 = v75 - 1;
        if (v78)
          goto LABEL_106;
        result = ((uint64_t (*)(uint64_t))v74[3])(a1);
        if (!(_DWORD)result)
          return result;
        v77 = *v74;
        v78 = v74[1];
LABEL_106:
        v79 = v78 - 1;
        v81 = *v77;
        v80 = v77 + 1;
        v82 = (v76 << 8) | v81;
        v83 = v82 - 2;
        if (v82 < 3)
          goto LABEL_269;
        break;
      case 220:
        result = skip_variable((_QWORD *)a1);
        if (!(_DWORD)result)
          return result;
        goto LABEL_278;
      case 221:
        v104 = *(unsigned __int8 ***)(a1 + 40);
        v105 = v104[1];
        if (v105)
          goto LABEL_162;
        result = ((uint64_t (*)(uint64_t))v104[3])(a1);
        if (!(_DWORD)result)
          return result;
        v105 = v104[1];
LABEL_162:
        v106 = *v104 + 1;
        v107 = **v104;
        v108 = v105 - 1;
        if (v105 != (unsigned __int8 *)1)
          goto LABEL_165;
        result = ((uint64_t (*)(uint64_t))v104[3])(a1);
        if (!(_DWORD)result)
          return result;
        v106 = *v104;
        v108 = v104[1];
LABEL_165:
        v110 = *v106;
        v109 = v106 + 1;
        if (((v107 << 8) | v110) != 4)
        {
          v111 = *(uint32x4_t **)a1;
          v111[2].i32[2] = 12;
          ((void (*)(uint64_t))v111->i64[0])(a1);
        }
        v112 = v108 - 1;
        if (v108 != (unsigned __int8 *)1)
          goto LABEL_170;
        result = ((uint64_t (*)(uint64_t))v104[3])(a1);
        if (!(_DWORD)result)
          return result;
        v109 = *v104;
        v112 = v104[1];
LABEL_170:
        v115 = *v109;
        v113 = v109 + 1;
        v114 = v115;
        v116 = v112 - 1;
        if (v116)
          goto LABEL_173;
        result = ((uint64_t (*)(uint64_t))v104[3])(a1);
        if (!(_DWORD)result)
          return result;
        v113 = *v104;
        v116 = v104[1];
LABEL_173:
        v117 = v114 << 8;
        v118 = v116 - 1;
        v119 = v117 | *v113;
        v120 = *(uint32x4_t **)a1;
        v120[2].i32[2] = 84;
        v120[3].i32[0] = v119;
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, 1);
        *(_DWORD *)(a1 + 372) = v119;
        *v104 = v113 + 1;
        v104[1] = v118;
        goto LABEL_278;
      case 222:
      case 223:
      case 240:
      case 241:
      case 242:
      case 243:
      case 244:
      case 245:
      case 246:
      case 247:
      case 249:
      case 250:
      case 251:
      case 252:
      case 253:
        goto LABEL_23;
      case 224:
      case 225:
      case 226:
      case 227:
      case 228:
      case 229:
      case 230:
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 616) + 8 * (v2 - 224) + 48))(a1);
        goto LABEL_17;
      case 248:
        v121 = *(unsigned __int8 ***)(a1 + 40);
        v122 = *v121;
        v123 = v121[1];
        if (!*(_DWORD *)(*(_QWORD *)(a1 + 616) + 28))
        {
          v124 = *(uint32x4_t **)a1;
          v124[2].i32[2] = 60;
          v124[5] = (uint32x4_t)xmmword_18820DAE1;
          v124[6] = (uint32x4_t)unk_18820DAF1;
          v124[7] = (uint32x4_t)xmmword_18820DB01;
          v124[3] = (uint32x4_t)xmmword_18820DAC1;
          v124[4] = (uint32x4_t)unk_18820DAD1;
          (**(void (***)(uint64_t))a1)(a1);
        }
        if (*(int *)(a1 + 56) < 3)
          goto LABEL_276;
        if (v123)
          goto LABEL_180;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_180:
        v127 = *v122;
        v126 = v122 + 1;
        v125 = v127;
        v128 = v123 - 1;
        if (v123 != (unsigned __int8 *)1)
          goto LABEL_183;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v126 = *v121;
        v128 = v121[1];
LABEL_183:
        v130 = *v126;
        v129 = v126 + 1;
        if (((v125 << 8) | v130) != 0x18)
        {
          v131 = *(uint32x4_t **)a1;
          v131[2].i32[2] = 12;
          ((void (*)(uint64_t))v131->i64[0])(a1);
        }
        v132 = v128 - 1;
        if (v132)
          goto LABEL_188;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v129 = *v121;
        v132 = v121[1];
LABEL_188:
        v134 = *v129;
        v133 = v129 + 1;
        if (v134 != 13)
        {
          v135 = *(uint32x4_t **)a1;
          v135[2].i32[2] = 70;
          v135[3].i32[0] = *(_DWORD *)(a1 + 572);
          (**(void (***)(uint64_t))a1)(a1);
        }
        v136 = v132 - 1;
        if (v132 != (unsigned __int8 *)1)
          goto LABEL_193;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v133 = *v121;
        v136 = v121[1];
LABEL_193:
        v139 = *v133;
        v138 = v133 + 1;
        v137 = v139;
        v140 = v136 - 1;
        if (v140)
          goto LABEL_196;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v138 = *v121;
        v140 = v121[1];
LABEL_196:
        v123 = v140 - 1;
        v141 = *v138;
        v122 = v138 + 1;
        if (((v137 << 8) | v141) != 0xFF)
          goto LABEL_276;
        if (v140 != (unsigned __int8 *)1)
          goto LABEL_200;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_200:
        --v123;
        v142 = *v122++;
        if (v142 != 3)
          goto LABEL_276;
        if (v123)
          goto LABEL_204;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_204:
        --v123;
        v143 = *v122++;
        v144 = *(_DWORD **)(a1 + 304);
        if (v144[24] != v143)
          goto LABEL_276;
        if (v123)
          goto LABEL_208;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
        v144 = *(_DWORD **)(a1 + 304);
LABEL_208:
        --v123;
        v145 = *v122++;
        if (*v144 != v145)
          goto LABEL_276;
        if (v123)
          goto LABEL_212;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
        v144 = *(_DWORD **)(a1 + 304);
LABEL_212:
        --v123;
        v146 = *v122++;
        if (v144[48] != v146)
          goto LABEL_276;
        if (v123)
          goto LABEL_216;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_216:
        --v123;
        v147 = *v122++;
        if (v147 != 128)
          goto LABEL_276;
        if (v123)
          goto LABEL_220;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_220:
        v150 = *v122;
        v149 = v122 + 1;
        v148 = v150;
        v151 = v123 - 1;
        if (v123 != (unsigned __int8 *)1)
          goto LABEL_223;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v149 = *v121;
        v151 = v121[1];
LABEL_223:
        v123 = v151 - 1;
        v152 = *v149;
        v122 = v149 + 1;
        if ((v148 << 8) | v152)
          goto LABEL_276;
        if (v151 != (unsigned __int8 *)1)
          goto LABEL_227;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_227:
        v155 = *v122;
        v154 = v122 + 1;
        v153 = v155;
        v156 = v123 - 1;
        if (v123 != (unsigned __int8 *)1)
          goto LABEL_230;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v154 = *v121;
        v156 = v121[1];
LABEL_230:
        v123 = v156 - 1;
        v157 = *v154;
        v122 = v154 + 1;
        if ((v153 << 8) | v157)
          goto LABEL_276;
        if (v156 != (unsigned __int8 *)1)
          goto LABEL_234;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_234:
        --v123;
        if (*v122++)
          goto LABEL_276;
        if (v123)
          goto LABEL_238;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_238:
        v161 = *v122;
        v160 = v122 + 1;
        v159 = v161;
        v162 = v123 - 1;
        if (v123 != (unsigned __int8 *)1)
          goto LABEL_241;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v160 = *v121;
        v162 = v121[1];
LABEL_241:
        v123 = v162 - 1;
        v163 = *v160;
        v122 = v160 + 1;
        if (((v159 << 8) | v163) != 1)
          goto LABEL_276;
        if (v162 != (unsigned __int8 *)1)
          goto LABEL_245;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_245:
        v166 = *v122;
        v165 = v122 + 1;
        v164 = v166;
        v167 = v123 - 1;
        if (v123 != (unsigned __int8 *)1)
          goto LABEL_248;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v165 = *v121;
        v167 = v121[1];
LABEL_248:
        v123 = v167 - 1;
        v168 = *v165;
        v122 = v165 + 1;
        if ((v164 << 8) | v168)
          goto LABEL_276;
        if (v167 != (unsigned __int8 *)1)
          goto LABEL_252;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_252:
        --v123;
        if (*v122++)
          goto LABEL_276;
        if (v123)
          goto LABEL_256;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_256:
        v172 = *v122;
        v171 = v122 + 1;
        v170 = v172;
        v173 = v123 - 1;
        if (v123 != (unsigned __int8 *)1)
          goto LABEL_259;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v171 = *v121;
        v173 = v121[1];
LABEL_259:
        v123 = v173 - 1;
        v174 = *v171;
        v122 = v171 + 1;
        if (((v170 << 8) | v174) != 1)
          goto LABEL_276;
        if (v173 != (unsigned __int8 *)1)
          goto LABEL_263;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v122 = *v121;
        v123 = v121[1];
LABEL_263:
        v177 = *v122;
        v176 = v122 + 1;
        v175 = v177;
        v178 = v123 - 1;
        if (v123 != (unsigned __int8 *)1)
          goto LABEL_266;
        result = ((uint64_t (*)(uint64_t))v121[3])(a1);
        if (!(_DWORD)result)
          return result;
        v176 = *v121;
        v178 = v121[1];
LABEL_266:
        v123 = v178 - 1;
        v179 = *v176;
        v122 = v176 + 1;
        if ((v175 << 8) | v179)
        {
LABEL_276:
          v182 = *(uint32x4_t **)a1;
          v182[2].i32[2] = 28;
          ((void (*)(uint64_t))v182->i64[0])(a1);
        }
        *(_DWORD *)(a1 + 396) = 1;
        *v121 = v122;
        v121[1] = v123;
        goto LABEL_278;
      case 254:
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 616) + 40))(a1);
LABEL_17:
        if (!(_DWORD)result)
          return result;
        goto LABEL_278;
      default:
        if (v2 == 1)
        {
LABEL_22:
          v14 = *(uint32x4_t **)a1;
          v14[2].i32[2] = 94;
          v14[3].i32[0] = v2;
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, 1);
        }
        else
        {
LABEL_23:
          v12 = *(uint32x4_t **)a1;
          v13 = 70;
LABEL_20:
          v12[2].i32[2] = v13;
          v12[3].i32[0] = v2;
          (**(void (***)(uint64_t))a1)(a1);
        }
        goto LABEL_278;
    }
    break;
  }
  while (1)
  {
    if (!v79)
    {
      result = ((uint64_t (*)(uint64_t))v74[3])(a1);
      if (!(_DWORD)result)
        return result;
      v80 = *v74;
      v79 = v74[1];
    }
    v84 = *v80;
    v85 = v84 & 0xF;
    v86 = *(uint32x4_t **)a1;
    v86[2].i32[2] = 83;
    v86[3].i32[0] = v84 & 0xF;
    *(_DWORD *)(*(_QWORD *)a1 + 52) = v84 >> 4;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, 1);
    if ((v84 & 0xF) >= 4)
    {
      v87 = *(uint32x4_t **)a1;
      v87[2].i32[2] = 32;
      v87[3].i32[0] = v85;
      (**(void (***)(uint64_t))a1)(a1);
    }
    v88 = a1 + 8 * v85;
    v91 = *(uint16x4_t **)(v88 + 200);
    v89 = (uint16x4_t **)(v88 + 200);
    v90 = v91;
    if (!v91)
    {
      v90 = (uint16x4_t *)_cg_jpeg_alloc_quant_table(a1);
      *v89 = v90;
    }
    v92 = v83 - 1;
    v228 = v83 - 1;
    if (v84 >= 0x10)
    {
      if ((unint64_t)v83 > 0x80)
      {
LABEL_124:
        v92 = 64;
LABEL_125:
        v93 = &_cg_jpeg_natural_order;
        goto LABEL_126;
      }
      memset_pattern16(v90, &unk_18820DB20, 0x80uLL);
      v92 >>= 1;
    }
    else
    {
      if ((unint64_t)v83 > 0x40)
        goto LABEL_124;
      memset_pattern16(v90, &unk_18820DB20, 0x80uLL);
    }
    if ((int)v92 > 24)
    {
      switch((_DWORD)v92)
      {
        case 0x19:
          v93 = &jpeg_natural_order5;
          goto LABEL_126;
        case 0x24:
          v93 = &jpeg_natural_order6;
          goto LABEL_126;
        case 0x31:
          v93 = &jpeg_natural_order7;
          goto LABEL_126;
      }
      goto LABEL_125;
    }
    if ((_DWORD)v92 == 4)
    {
      v93 = &jpeg_natural_order2;
      goto LABEL_126;
    }
    if ((_DWORD)v92 == 9)
    {
      v93 = &jpeg_natural_order3;
      goto LABEL_126;
    }
    if ((_DWORD)v92 != 16)
      goto LABEL_125;
    v93 = &jpeg_natural_order4;
LABEL_126:
    ++v80;
    --v79;
    if (v92)
    {
      v94 = v92;
      do
      {
        if (v84 >= 0x10)
        {
          if (!v79)
          {
            result = ((uint64_t (*)(uint64_t))v74[3])(a1);
            if (!(_DWORD)result)
              return result;
            v80 = *v74;
            v79 = v74[1];
          }
          v97 = *v80++;
          v96 = v97;
          if (!--v79)
          {
            result = ((uint64_t (*)(uint64_t))v74[3])(a1);
            if (!(_DWORD)result)
              return result;
            v80 = *v74;
            v79 = v74[1];
          }
          v95 = (v96 << 8) | *v80;
        }
        else
        {
          if (!v79)
          {
            result = ((uint64_t (*)(uint64_t))v74[3])(a1);
            if (!(_DWORD)result)
              return result;
            v80 = *v74;
            v79 = v74[1];
          }
          v95 = *v80;
        }
        v98 = *v93++;
        v90->i16[v98] = v95;
        ++v80;
        --v79;
        --v94;
      }
      while (v94);
    }
    if (*(int *)(*(_QWORD *)a1 + 128) >= 2)
    {
      v99 = v90 + 1;
      v100 = -8;
      do
      {
        v101 = *(uint32x4_t **)a1;
        v101[3] = vmovl_u16(v99[-1]);
        v102 = *v99;
        v99 += 2;
        v101[4] = vmovl_u16(v102);
        v101[2].i32[2] = 95;
        ((void (*)(uint64_t, uint64_t))v101->i64[1])(a1, 2);
        v100 += 8;
      }
      while (v100 < 0x38);
    }
    if (v84 >= 0x10)
      v103 = v92;
    else
      v103 = 0;
    v83 = v228 - v92 - v103;
    if (v83 <= 0)
    {
LABEL_269:
      if (v83)
      {
        v180 = *(uint32x4_t **)a1;
        v180[2].i32[2] = 12;
        ((void (*)(uint64_t))v180->i64[0])(a1);
      }
      *v74 = v80;
      v74[1] = v79;
      goto LABEL_278;
    }
  }
}

uint64_t read_restart_marker(uint64_t *a1)
{
  int v2;
  uint64_t result;
  int v4;
  uint64_t v5;

  v2 = *((_DWORD *)a1 + 143);
  if (!v2)
  {
    result = next_marker(a1);
    if (!(_DWORD)result)
      return result;
    v2 = *((_DWORD *)a1 + 143);
  }
  v4 = *(_DWORD *)(a1[77] + 32);
  if (v2 == v4 + 208)
  {
    v5 = *a1;
    *(_DWORD *)(v5 + 40) = 100;
    *(_DWORD *)(v5 + 48) = v4;
    (*(void (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 3);
    *((_DWORD *)a1 + 143) = 0;
  }
  else
  {
    result = (*(uint64_t (**)(uint64_t *))(a1[5] + 40))(a1);
    if (!(_DWORD)result)
      return result;
  }
  *(_DWORD *)(a1[77] + 32) = (*(_DWORD *)(a1[77] + 32) + 1) & 7;
  return 1;
}

uint64_t skip_variable(_QWORD *a1)
{
  unsigned __int8 **v2;
  unsigned __int8 *v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  if (!v3)
  {
    if (!((unsigned int (*)(_QWORD *))v2[3])(a1))
      return 0;
    v3 = v2[1];
  }
  v5 = *v2 + 1;
  v4 = **v2;
  v6 = v3 - 1;
  if (v6)
    goto LABEL_7;
  if (!((unsigned int (*)(_QWORD *))v2[3])(a1))
    return 0;
  v5 = *v2;
  v6 = v2[1];
LABEL_7:
  v7 = v6 - 1;
  v8 = (v4 << 8) | *v5;
  v9 = *a1;
  *(_DWORD *)(v9 + 40) = 93;
  *(_DWORD *)(v9 + 48) = *((_DWORD *)a1 + 143);
  *(_DWORD *)(*a1 + 52) = v8 - 2;
  v10 = 1;
  (*(void (**)(_QWORD *, uint64_t))(*a1 + 8))(a1, 1);
  *v2 = v5 + 1;
  v2[1] = v7;
  if (v8 >= 3)
    (*(void (**)(_QWORD *, unint64_t))(a1[5] + 32))(a1, v8 - 2);
  return v10;
}

uint64_t get_interesting_appn(uint64_t a1)
{
  unsigned __int8 **v2;
  unsigned __int8 *v3;
  uint64_t result;
  uint64_t v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned int v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  _BYTE *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  _QWORD v22[3];

  v22[2] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned __int8 ***)(a1 + 40);
  v3 = v2[1];
  if (!v3)
  {
    result = ((uint64_t (*)(uint64_t))v2[3])(a1);
    if (!(_DWORD)result)
      return result;
    v3 = v2[1];
  }
  v6 = *v2 + 1;
  v5 = **v2;
  v7 = v3 - 1;
  if (!v7)
  {
    result = ((uint64_t (*)(uint64_t))v2[3])(a1);
    if (!(_DWORD)result)
      return result;
    v6 = *v2;
    v7 = v2[1];
  }
  memset(v22, 0, 14);
  v9 = *v6;
  v8 = v6 + 1;
  v10 = (v5 << 8) | v9;
  v11 = v10 - 2;
  if (v10 <= 2)
    v12 = 0;
  else
    v12 = v10 - 2;
  if (v10 <= 0xF)
    v13 = v12;
  else
    v13 = 14;
  v14 = v7 - 1;
  if ((_DWORD)v13)
  {
    v15 = v22;
    v16 = v13;
    do
    {
      if (!v14)
      {
        result = ((uint64_t (*)(uint64_t))v2[3])(a1);
        if (!(_DWORD)result)
          return result;
        v8 = *v2;
        v14 = v2[1];
      }
      v17 = *v8++;
      *v15++ = v17;
      --v14;
      --v16;
    }
    while (v16);
    v18 = v13;
  }
  else
  {
    v18 = 0;
  }
  v19 = v11 - v18;
  v20 = *(_DWORD *)(a1 + 572);
  if (v20 == 238)
  {
    examine_app14((uint64_t *)a1, (uint64_t)v22, v13, v19);
  }
  else if (v20 == 224)
  {
    examine_app0((uint64_t *)a1, (uint64_t)v22, v13, v19);
  }
  else
  {
    v21 = *(_QWORD *)a1;
    *(_DWORD *)(v21 + 40) = 70;
    *(_DWORD *)(v21 + 48) = v20;
    (**(void (***)(uint64_t))a1)(a1);
  }
  *v2 = v8;
  v2[1] = v14;
  if (v19 >= 1)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 32))(a1, v19);
  return 1;
}

_QWORD *_cg_jpeg_save_markers(_QWORD *result, int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  BOOL v6;
  unsigned int v8;
  uint64_t (**v9)(_QWORD);

  v3 = result[77];
  v4 = *(_QWORD *)(result[1] + 96) - 32;
  if (v4 >= a3)
    LODWORD(v4) = a3;
  if ((_DWORD)v4)
  {
    if (a2 == 224 && v4 < 0xE)
    {
      v5 = save_marker;
      LODWORD(v4) = 14;
LABEL_22:
      v8 = a2 - 224;
      *(_QWORD *)(v3 + 8 * v8 + 48) = v5;
      *(_DWORD *)(v3 + 4 * v8 + 180) = v4;
      return result;
    }
    if (v4 < 0xC && a2 == 238)
      LODWORD(v4) = 12;
    v5 = save_marker;
  }
  else
  {
    v6 = a2 == 238 || a2 == 224;
    v5 = skip_variable;
    if (v6)
      v5 = get_interesting_appn;
  }
  if (a2 == 254)
  {
    *(_QWORD *)(v3 + 40) = v5;
    *(_DWORD *)(v3 + 176) = v4;
    return result;
  }
  if ((a2 & 0xFFFFFFF0) == 0xE0)
    goto LABEL_22;
  v9 = (uint64_t (**)(_QWORD))*result;
  *((_DWORD *)v9 + 10) = 70;
  *((_DWORD *)v9 + 12) = a2;
  return (_QWORD *)(*(uint64_t (**)(_QWORD *))*result)(result);
}

uint64_t save_marker(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int8 **v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned int v13;
  unsigned __int8 *v14;
  unsigned int v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned __int8 *v21;
  BOOL v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;

  v2 = *(_QWORD *)(a1 + 616);
  v3 = *(_QWORD *)(v2 + 248);
  v4 = *(unsigned __int8 ***)(a1 + 40);
  v5 = *v4;
  v6 = v4[1];
  if (v3)
  {
    v7 = *(unsigned int *)(v2 + 256);
    LODWORD(v8) = *(_DWORD *)(v3 + 16);
    v9 = *(_QWORD *)(v3 + 24) + v7;
    goto LABEL_29;
  }
  if (!v6)
  {
    result = ((uint64_t (*)(uint64_t))v4[3])(a1);
    if (!(_DWORD)result)
      return result;
    v5 = *v4;
    v6 = v4[1];
  }
  v13 = *v5;
  v12 = v5 + 1;
  v11 = v13;
  v14 = v6 - 1;
  if (v6 == (unsigned __int8 *)1)
  {
    result = ((uint64_t (*)(uint64_t))v4[3])(a1);
    if (!(_DWORD)result)
      return result;
    v12 = *v4;
    v14 = v4[1];
  }
  v6 = v14 - 1;
  v15 = *v12;
  v5 = v12 + 1;
  v16 = (v11 << 8) | v15;
  v17 = v16 - 2;
  if (v16 < 2)
  {
    LODWORD(v8) = 0;
    v25 = 0;
  }
  else
  {
    v18 = *(_DWORD *)(a1 + 572);
    if (v18 == 254)
      v19 = (unsigned int *)(v2 + 176);
    else
      v19 = (unsigned int *)(v2 + 4 * (v18 - 224) + 180);
    v20 = *v19;
    if (v20 >= v17)
      v8 = v17;
    else
      v8 = v20;
    v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 8))(a1, 1, v8 + 32);
    LODWORD(v7) = 0;
    *(_QWORD *)v3 = 0;
    *(_BYTE *)(v3 + 8) = *(_DWORD *)(a1 + 572);
    *(_DWORD *)(v3 + 12) = v17;
    *(_DWORD *)(v3 + 16) = v8;
    v9 = v3 + 32;
    *(_QWORD *)(v3 + 24) = v3 + 32;
    *(_QWORD *)(v2 + 248) = v3;
    *(_DWORD *)(v2 + 256) = 0;
LABEL_29:
    while (v7 < v8)
    {
      *v4 = v5;
      v4[1] = v6;
      *(_DWORD *)(v2 + 256) = v7;
      if (!v6)
      {
        result = ((uint64_t (*)(uint64_t))v4[3])(a1);
        if (!(_DWORD)result)
          return result;
        v5 = *v4;
        v6 = v4[1];
      }
      if (v7 < v8 && v6)
      {
        v21 = 0;
        do
        {
          v21[v9] = v21[(_QWORD)v5];
          v22 = (int)v7 + (int)v21 + 1 >= v8 || v6 - 1 == v21;
          ++v21;
        }
        while (!v22);
        v6 -= (uint64_t)v21;
        v5 = &v21[(_QWORD)v5];
        v9 += (uint64_t)v21;
        LODWORD(v7) = v7 + (_DWORD)v21;
      }
    }
    v23 = *(uint64_t **)(a1 + 408);
    if (v23)
    {
      do
      {
        v24 = v23;
        v23 = (uint64_t *)*v23;
      }
      while (v23);
    }
    else
    {
      v24 = (uint64_t *)(a1 + 408);
    }
    *v24 = v3;
    v25 = *(_QWORD *)(v3 + 24);
    v17 = (*(_DWORD *)(v3 + 12) - v8);
  }
  *(_QWORD *)(v2 + 248) = 0;
  v26 = *(_DWORD *)(a1 + 572);
  if (v26 == 238)
  {
    examine_app14((uint64_t *)a1, v25, v8, v17);
  }
  else if (v26 == 224)
  {
    examine_app0((uint64_t *)a1, v25, v8, v17);
  }
  else
  {
    v27 = *(_QWORD *)a1;
    *(_DWORD *)(v27 + 40) = 93;
    *(_DWORD *)(v27 + 48) = v26;
    *(_DWORD *)(*(_QWORD *)a1 + 52) = v8 + v17;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 8))(a1, 1);
  }
  *v4 = v5;
  v4[1] = v6;
  if (v17 >= 1)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 40) + 32))(a1, v17);
  return 1;
}

uint64_t get_sof(uint64_t *a1, int a2, int a3, int a4)
{
  unsigned __int8 **v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t result;
  unsigned __int8 *v9;
  uint64_t v10;
  unsigned int v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  int v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  int v25;
  unsigned __int8 *v26;
  unsigned __int8 *v27;
  int v28;
  int v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  int v32;
  unsigned __int8 *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned int v43;
  int v44;
  int v45;
  unsigned __int8 *v46;
  int v47;
  int *v48;
  unsigned int v49;
  int *v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  unsigned __int8 *v56;
  unsigned __int8 *v57;
  unsigned int v58;
  unsigned __int8 *v59;
  int v60;
  uint64_t v61;

  v5 = (unsigned __int8 **)a1[5];
  v7 = *v5;
  v6 = v5[1];
  *((_DWORD *)a1 + 78) = a2;
  *((_DWORD *)a1 + 79) = a3;
  *((_DWORD *)a1 + 80) = a4;
  if (!v6)
  {
    result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!(_DWORD)result)
      return result;
    v7 = *v5;
    v6 = v5[1];
  }
  v11 = *v7;
  v9 = v7 + 1;
  v10 = v11;
  v12 = v6 - 1;
  if (!v12)
  {
    result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!(_DWORD)result)
      return result;
    v9 = *v5;
    v12 = v5[1];
  }
  v15 = *v9;
  v13 = v9 + 1;
  v14 = v15;
  v16 = v12 - 1;
  if (!v16)
  {
    result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!(_DWORD)result)
      return result;
    v13 = *v5;
    v16 = v5[1];
  }
  v18 = *v13;
  v17 = v13 + 1;
  *((_DWORD *)a1 + 74) = v18;
  v19 = v16 - 1;
  if (!v19)
  {
    result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!(_DWORD)result)
      return result;
    v17 = *v5;
    v19 = v5[1];
  }
  v21 = *v17;
  v20 = v17 + 1;
  v22 = v21 << 8;
  *((_DWORD *)a1 + 13) = v21 << 8;
  v23 = v19 - 1;
  if (!v23)
  {
    result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!(_DWORD)result)
      return result;
    v20 = *v5;
    v23 = v5[1];
    v22 = *((_DWORD *)a1 + 13);
  }
  v25 = *v20;
  v24 = v20 + 1;
  *((_DWORD *)a1 + 13) = v22 + v25;
  v26 = v23 - 1;
  if (!v26)
  {
    result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!(_DWORD)result)
      return result;
    v24 = *v5;
    v26 = v5[1];
  }
  v28 = *v24;
  v27 = v24 + 1;
  v29 = v28 << 8;
  *((_DWORD *)a1 + 12) = v28 << 8;
  v30 = v26 - 1;
  if (!v30)
  {
    result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!(_DWORD)result)
      return result;
    v27 = *v5;
    v30 = v5[1];
    v29 = *((_DWORD *)a1 + 12);
  }
  v32 = *v27;
  v31 = v27 + 1;
  *((_DWORD *)a1 + 12) = v29 + v32;
  v33 = v30 - 1;
  if (v30 == (unsigned __int8 *)1)
  {
    result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!(_DWORD)result)
      return result;
    v31 = *v5;
    v33 = v5[1];
  }
  v34 = (v10 << 8) | v14;
  *((_DWORD *)a1 + 14) = *v31;
  v35 = *a1;
  *(_DWORD *)(v35 + 48) = *((_DWORD *)a1 + 143);
  *(_DWORD *)(v35 + 52) = *((_DWORD *)a1 + 12);
  *(_DWORD *)(v35 + 56) = *((_DWORD *)a1 + 13);
  *(_DWORD *)(v35 + 60) = *((_DWORD *)a1 + 14);
  *(_DWORD *)(v35 + 40) = 102;
  (*(void (**)(uint64_t *, uint64_t))(v35 + 8))(a1, 1);
  if (*(_DWORD *)(a1[77] + 28))
  {
    v36 = *a1;
    *(_DWORD *)(v36 + 40) = 61;
    (*(void (**)(uint64_t *))v36)(a1);
  }
  v37 = v34 - 8;
  if (!*((_DWORD *)a1 + 13) || !*((_DWORD *)a1 + 12) || (v38 = *((_DWORD *)a1 + 14), v38 <= 0))
  {
    v39 = *a1;
    *(_DWORD *)(v39 + 40) = 33;
    (*(void (**)(uint64_t *))v39)(a1);
    v38 = *((_DWORD *)a1 + 14);
  }
  if (v37 != 3 * v38)
  {
    v40 = *a1;
    *(_DWORD *)(v40 + 40) = 12;
    (*(void (**)(uint64_t *))v40)(a1);
    v38 = *((_DWORD *)a1 + 14);
  }
  if (!a1[38])
  {
    a1[38] = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 96 * v38);
    v38 = *((_DWORD *)a1 + 14);
  }
  v41 = v31 + 1;
  v42 = v33 - 1;
  if (v38 >= 1)
  {
    v43 = 0;
    v44 = -1;
    do
    {
      if (!v42)
      {
        result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
        if (!(_DWORD)result)
          return result;
        v41 = *v5;
        v42 = v5[1];
      }
      v47 = *v41;
      v46 = v41 + 1;
      v45 = v47;
      v48 = (int *)a1[38];
      if (v43)
      {
        v49 = v43;
        v50 = (int *)a1[38];
        while (*v50 != v45)
        {
          v50 += 24;
          if (!--v49)
          {
            v48 = v50;
            goto LABEL_51;
          }
        }
        v52 = *v48;
        v48 += 24;
        v51 = v52;
        if (v43 >= 2)
        {
          v53 = v44;
          do
          {
            v55 = *v48;
            v48 += 24;
            v54 = v55;
            if (v55 > v51)
              v51 = v54;
            --v53;
          }
          while (v53);
        }
        v45 = v51 + 1;
      }
LABEL_51:
      *v48 = v45;
      v48[1] = v43;
      v56 = v42 - 1;
      if (!v56)
      {
        result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
        if (!(_DWORD)result)
          return result;
        v46 = *v5;
        v56 = v5[1];
      }
      v58 = *v46;
      v57 = v46 + 1;
      v48[2] = v58 >> 4;
      v48[3] = v58 & 0xF;
      v59 = v56 - 1;
      if (v56 == (unsigned __int8 *)1)
      {
        result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
        if (!(_DWORD)result)
          return result;
        v57 = *v5;
        v59 = v5[1];
      }
      v60 = *v57;
      v41 = v57 + 1;
      v48[4] = v60;
      v61 = *a1;
      *(_DWORD *)(v61 + 48) = *v48;
      *(_DWORD *)(v61 + 52) = v48[2];
      *(_DWORD *)(v61 + 56) = v48[3];
      *(_DWORD *)(v61 + 60) = v48[4];
      *(_DWORD *)(v61 + 40) = 103;
      (*(void (**)(uint64_t *, uint64_t))(v61 + 8))(a1, 1);
      ++v43;
      v42 = v59 - 1;
      ++v44;
    }
    while ((signed int)v43 < *((_DWORD *)a1 + 14));
  }
  result = 1;
  *(_DWORD *)(a1[77] + 28) = 1;
  *v5 = v41;
  v5[1] = v42;
  return result;
}

uint64_t examine_app0(uint64_t *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;

  v6 = a4 + a3;
  if (a3 < 0xE)
  {
    if (a3 < 6 || *(_BYTE *)a2 != 74)
      goto LABEL_19;
    goto LABEL_15;
  }
  if (*(_BYTE *)a2 != 74)
    goto LABEL_19;
  if (*(_BYTE *)(a2 + 1) != 70 || *(_BYTE *)(a2 + 2) != 73 || *(_BYTE *)(a2 + 3) != 70 || *(_BYTE *)(a2 + 4))
  {
LABEL_15:
    if (*(_BYTE *)(a2 + 1) == 70 && *(_BYTE *)(a2 + 2) == 88 && *(_BYTE *)(a2 + 3) == 88 && !*(_BYTE *)(a2 + 4))
    {
      v20 = *(unsigned __int8 *)(a2 + 5);
      switch(v20)
      {
        case 19:
          v18 = *a1;
          v19 = 112;
          break;
        case 17:
          v18 = *a1;
          v19 = 111;
          break;
        case 16:
          v18 = *a1;
          v19 = 110;
          break;
        default:
          v22 = *a1;
          *(_DWORD *)(v22 + 40) = 91;
          *(_DWORD *)(v22 + 48) = *(unsigned __int8 *)(a2 + 5);
          *(_DWORD *)(*a1 + 52) = v6;
          return (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 1);
      }
      goto LABEL_20;
    }
LABEL_19:
    v18 = *a1;
    v19 = 79;
LABEL_20:
    *(_DWORD *)(v18 + 40) = v19;
    *(_DWORD *)(v18 + 48) = v6;
    return (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 1);
  }
  *((_DWORD *)a1 + 94) = 1;
  v7 = *(unsigned __int8 *)(a2 + 5);
  *((_BYTE *)a1 + 380) = v7;
  v8 = *(unsigned __int8 *)(a2 + 6);
  *((_BYTE *)a1 + 381) = v8;
  v9 = *(unsigned __int8 *)(a2 + 7);
  *((_BYTE *)a1 + 382) = v9;
  v10 = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
  *((_WORD *)a1 + 192) = v10;
  v11 = bswap32(*(unsigned __int16 *)(a2 + 10)) >> 16;
  *((_WORD *)a1 + 193) = v11;
  if ((v7 - 1) >= 2)
  {
    v12 = *a1;
    *(_DWORD *)(v12 + 40) = 122;
    *(_DWORD *)(v12 + 48) = v7;
    *(_DWORD *)(*a1 + 52) = *((unsigned __int8 *)a1 + 381);
    (*(void (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 0xFFFFFFFFLL);
    v7 = *((unsigned __int8 *)a1 + 380);
    v8 = *((unsigned __int8 *)a1 + 381);
    v10 = *((unsigned __int16 *)a1 + 192);
    v11 = *((unsigned __int16 *)a1 + 193);
    v9 = *((unsigned __int8 *)a1 + 382);
  }
  v13 = *a1;
  *(_DWORD *)(v13 + 48) = v7;
  *(_DWORD *)(v13 + 52) = v8;
  *(_DWORD *)(v13 + 56) = v10;
  *(_DWORD *)(v13 + 60) = v11;
  *(_DWORD *)(v13 + 64) = v9;
  *(_DWORD *)(v13 + 40) = 89;
  result = (*(uint64_t (**)(uint64_t *, uint64_t))(v13 + 8))(a1, 1);
  v15 = *(unsigned __int8 *)(a2 + 12);
  v16 = *(unsigned __int8 *)(a2 + 13);
  if (v16 | v15)
  {
    v17 = *a1;
    *(_DWORD *)(v17 + 40) = 92;
    *(_DWORD *)(v17 + 48) = *(unsigned __int8 *)(a2 + 12);
    *(_DWORD *)(*a1 + 52) = *(unsigned __int8 *)(a2 + 13);
    result = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 1);
    v15 = *(unsigned __int8 *)(a2 + 12);
    v16 = *(unsigned __int8 *)(a2 + 13);
  }
  if (v6 - 14 != 3 * v15 * (unint64_t)v16)
  {
    v21 = *a1;
    *(_DWORD *)(v21 + 40) = 90;
    *(_DWORD *)(v21 + 48) = v6 - 14;
    return (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 1);
  }
  return result;
}

uint64_t examine_app14(uint64_t *a1, uint64_t a2, unsigned int a3, int a4)
{
  unsigned int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;

  if (a3 >= 0xC
    && *(_BYTE *)a2 == 65
    && *(_BYTE *)(a2 + 1) == 100
    && *(_BYTE *)(a2 + 2) == 111
    && *(_BYTE *)(a2 + 3) == 98
    && *(_BYTE *)(a2 + 4) == 101)
  {
    v5 = __rev16(*(unsigned __int16 *)(a2 + 7));
    v6 = __rev16(*(unsigned __int16 *)(a2 + 9));
    v7 = *(unsigned __int8 *)(a2 + 11);
    v8 = *a1;
    *(_DWORD *)(v8 + 48) = __rev16(*(unsigned __int16 *)(a2 + 5));
    *(_DWORD *)(v8 + 52) = v5;
    *(_DWORD *)(v8 + 56) = v6;
    *(_DWORD *)(v8 + 60) = v7;
    *(_DWORD *)(v8 + 40) = 78;
    result = (*(uint64_t (**)(uint64_t *, uint64_t))(v8 + 8))(a1, 1);
    *((_DWORD *)a1 + 97) = 1;
    *((_BYTE *)a1 + 392) = v7;
  }
  else
  {
    v10 = *a1;
    *(_DWORD *)(v10 + 40) = 80;
    *(_DWORD *)(v10 + 48) = a4 + a3;
    return (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 1);
  }
  return result;
}

uint64_t _cg_jpeg_start_compress(uint64_t a1, int a2)
{
  int v4;
  void (**v5)(_QWORD);
  uint64_t result;
  int v7;

  v4 = *(_DWORD *)(a1 + 36);
  if (v4 != 100)
  {
    v5 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v4;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (a2)
    _cg_jpeg_suppress_tables(a1, 0);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 40) + 16))(a1);
  _cg_jinit_compress_master(a1);
  result = (**(uint64_t (***)(uint64_t))(a1 + 496))(a1);
  *(_DWORD *)(a1 + 344) = 0;
  if (*(_DWORD *)(a1 + 288))
    v7 = 102;
  else
    v7 = 101;
  *(_DWORD *)(a1 + 36) = v7;
  return result;
}

uint64_t _cg_jpeg_write_scanlines(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6;
  void (**v7)(uint64_t);
  void (**v8)(uint64_t);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t result;
  unsigned int v15;

  v6 = *(_DWORD *)(a1 + 36);
  if (v6 != 101)
  {
    v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 21;
    *((_DWORD *)v7 + 12) = v6;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (*(_DWORD *)(a1 + 344) >= *(_DWORD *)(a1 + 52))
  {
    v8 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v8 + 10) = 126;
    ((void (*)(uint64_t, uint64_t))v8[1])(a1, 0xFFFFFFFFLL);
  }
  v9 = *(_QWORD *)(a1 + 16);
  if (v9)
  {
    v10 = *(unsigned int *)(a1 + 52);
    *(_QWORD *)(v9 + 8) = *(unsigned int *)(a1 + 344);
    *(_QWORD *)(v9 + 16) = v10;
    (*(void (**)(uint64_t))v9)(a1);
  }
  v11 = *(_QWORD *)(a1 + 496);
  if (*(_DWORD *)(v11 + 24))
    (*(void (**)(uint64_t))(v11 + 8))(a1);
  v12 = *(_DWORD *)(a1 + 52) - *(_DWORD *)(a1 + 344);
  if (v12 >= a3)
    v13 = a3;
  else
    v13 = v12;
  v15 = 0;
  (*(void (**)(uint64_t, uint64_t, unsigned int *, uint64_t))(*(_QWORD *)(a1 + 504) + 8))(a1, a2, &v15, v13);
  result = v15;
  *(_DWORD *)(a1 + 344) += v15;
  return result;
}

uint64_t _cg_jpeg_write_raw_data(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6;
  void (**v7)(uint64_t);
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (**v13)(uint64_t);
  void (**v14)(uint64_t);

  v6 = *(_DWORD *)(a1 + 36);
  if (v6 != 102)
  {
    v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 21;
    *((_DWORD *)v7 + 12) = v6;
    (**(void (***)(uint64_t))a1)(a1);
  }
  v8 = *(unsigned int *)(a1 + 344);
  v9 = *(unsigned int *)(a1 + 52);
  if (v8 >= v9)
  {
    v14 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v14 + 10) = 126;
    ((void (*)(uint64_t, uint64_t))v14[1])(a1, 0xFFFFFFFFLL);
    return 0;
  }
  v10 = *(_QWORD *)(a1 + 16);
  if (v10)
  {
    *(_QWORD *)(v10 + 8) = v8;
    *(_QWORD *)(v10 + 16) = v9;
    (*(void (**)(uint64_t))v10)(a1);
  }
  v11 = *(_QWORD *)(a1 + 496);
  if (*(_DWORD *)(v11 + 24))
    (*(void (**)(uint64_t))(v11 + 8))(a1);
  v12 = (*(_DWORD *)(a1 + 364) * *(_DWORD *)(a1 + 356));
  if (v12 > a3)
  {
    v13 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v13 + 10) = 24;
    (*v13)(a1);
  }
  if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 520) + 8))(a1, a2))
    return 0;
  *(_DWORD *)(a1 + 344) += v12;
  return v12;
}

double HEIFReadPlugin::ColorConvert(HEIFReadPlugin *this, __CVBuffer *a2, unint64_t a3, IIOColorConverter *a4, void *a5, double result)
{
  vImagePixelCount Width;
  vImagePixelCount Height;
  size_t BytesPerRow;
  void *BaseAddress;
  __n128 v12;
  vImage_Error v13;
  const char *v14;
  vImage_Buffer v15;

  if (this)
  {
    IIO_LoadHEIFSymbols();
    if (gFunc_CVPixelBufferGetPixelFormatType(this) == 1111970369
      && !gFunc_CVPixelBufferLockBaseAddress(this, 0))
    {
      Width = gFunc_CVPixelBufferGetWidth(this);
      Height = gFunc_CVPixelBufferGetHeight(this);
      BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(this);
      BaseAddress = (void *)gFunc_CVPixelBufferGetBaseAddress(this);
      if (BaseAddress)
      {
        v15.data = BaseAddress;
        v15.height = Height;
        v15.width = Width;
        v15.rowBytes = BytesPerRow;
        v13 = IIOColorConverter::colorConvert(a4, &v15, &v15);
        if (v13)
        {
          v14 = IIO_vImageErrorString(v13);
          LogError("ColorConvert", 91, "*** vImageConvert_AnyToAny - %s\n", v14);
        }
      }
      return gFunc_CVPixelBufferUnlockBaseAddress(this, 0, v12);
    }
  }
  return result;
}

uint64_t HEIFReadPlugin::IIORecodeHEIF_to_JPEG(HEIFReadPlugin *this, IIOImageDestination *a2, IIOImageSource *a3)
{
  unsigned int v3;
  const __CFString *v6;
  CGImage *Plugin;
  CGImage *ImageAtIndex;
  CGImageSource *ColorSpace;
  const void *Ref;
  unint64_t v11;
  IIODictionary *ImagePropertiesAtIndex;
  const __CFData *Property;
  IIODictionary *v14;
  int Uint32ForKey;
  CGImageMetadata **v16;
  _BOOL4 BoolForKey;
  const void **RecodeProperties;
  int v19;
  _BOOL4 v20;
  _BOOL4 v21;
  IIODictionary *v22;
  const __CFAllocator *v23;
  int v24;
  int v25;
  const char *v26;
  CGColorSpace *v27;
  CGColorSpace *InputColorSpaceForOutputPoppyProfile;
  uint64_t v29;
  IIOImageRead *Size;
  IIOImageRead *v32;
  const void *v33;
  const void *v34;
  uint64_t v35;
  const char *v36;
  unint64_t v37;
  unsigned int v38;
  size_t Width;
  size_t Height;
  BOOL *v41;
  float FloatForKey;
  CGColorSpace *v43;
  CGColorSpaceModel Model;
  CGColorSpaceRef v45;
  const __CFDictionary *ObjectForKey;
  CGColorSpace *ResizeSourceColorSpace;
  CGColorSpace *v48;
  IIOColorConverter *v49;
  const UInt8 *BytePtr;
  size_t Length;
  const char *v52;
  CGImageSource *v53;
  CFDataRef v54;
  int CanBeIgnoredOnSRGBDevice;
  CGColorSpace *v56;
  void *value;
  IIOImageWriteSession *v58;
  unint64_t v59;
  CGColorSpace *space;
  CGColorSpace *v61;
  CFDataRef cf;
  IIOImageReadSession *Source;
  _QWORD *v64;
  _BYTE v65[24];
  _BYTE v66[24];
  _BYTE v67[24];
  _BYTE v68[16];
  void *v69;
  uint64_t v70;
  void *v71;
  uint64_t v72;
  _BYTE v73[24];
  _BYTE v74[24];
  _BYTE v75[24];
  _BYTE v76[31];
  char v77;
  CGColorSpaceRef v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  CFTypeRef v89;
  int v90;
  const __CFData *v91;
  CFTypeRef v92;
  CFTypeRef v93;
  UInt8 buffer[16];
  CFRange v95;

  v3 = a3;
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "IIORecodeHEIF_to_JPEG", 0, 0, -1, 0);
  v93 = 0;
  *(_QWORD *)buffer = 0;
  v91 = 0;
  v92 = 0;
  v90 = 0;
  v88 = 0;
  v89 = 0;
  v86 = 0;
  v87 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v86);
  v83 = 0;
  v84 = 0;
  v85 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v83);
  v80 = 0;
  v81 = 0;
  v82 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v80);
  v79 = 0;
  v58 = (IIOImageWriteSession *)IIOImageSource::count(this);
  v78 = 0;
  v6 = (const __CFString *)*MEMORY[0x1E0C9DA10];
  v61 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  v77 = 0;
  Plugin = (CGImage *)IIOImagePlus::readPlugin(this);
  ImageAtIndex = Plugin;
  if (Plugin)
  {
    CGImageRetain(Plugin);
  }
  else
  {
    ColorSpace = (CGImageSource *)IIOReadPlugin::getColorSpace(this);
    ImageAtIndex = CGImageSourceCreateImageAtIndex(ColorSpace, 0, 0);
    if (!ImageAtIndex)
    {
      _cg_jpeg_mem_term("IIORecodeHEIF_to_JPEG", 154, "*** ERROR: cannot get the source image...");
      ImageAtIndex = 0;
      goto LABEL_178;
    }
  }
  space = CGImageGetColorSpace(ImageAtIndex);
  CGColorSpaceGetModel(space);
  if (a2)
  {
    Ref = (const void *)IIOImageSource::imageReadRef(a2);
    *(_QWORD *)buffer = Ref;
    if (Ref)
      goto LABEL_8;
    goto LABEL_13;
  }
  Property = (const __CFData *)CGImageGetProperty();
  if (Property)
  {
    v95.location = 0;
    v95.length = 8;
    CFDataGetBytes(Property, v95, buffer);
  }
  Ref = *(const void **)buffer;
  if (!*(_QWORD *)buffer)
  {
LABEL_13:
    _cg_jpeg_mem_term("IIORecodeHEIF_to_JPEG", 175, "*** ERROR: cannot get the 'CGImageReadRef' of the source image...");
LABEL_178:
    cf = 0;
    Source = 0;
    v27 = 0;
    InputColorSpaceForOutputPoppyProfile = 0;
    RecodeProperties = 0;
    v64 = 0;
    goto LABEL_33;
  }
LABEL_8:
  v64 = CGImageReadSessionCreate(Ref);
  Source = (IIOImageReadSession *)CGImageSourceGetSource((uint64_t)v64);
  v11 = v3;
  if (a2)
  {
    ImagePropertiesAtIndex = (IIODictionary *)IIOImageSource::getImagePropertiesAtIndex(a2, v3);
    v11 = v3;
  }
  else
  {
    ImagePropertiesAtIndex = 0;
  }
  v59 = v11;
  v14 = (IIODictionary *)IIOImageDestination::getImagePropertiesAtIndex(this, v11);
  if (!v14)
    v14 = (IIODictionary *)IIOImageDestination::getImagePropertiesAtIndex(this, 0);
  if (IIODictionary::containsKey(v14, CFSTR("kCGImageSourceTiledDownsamplingMode")))
    Uint32ForKey = IIODictionary::getUint32ForKey(v14, CFSTR("kCGImageSourceTiledDownsamplingMode"));
  else
    Uint32ForKey = 1;
  IIOSkipMetadata(ImagePropertiesAtIndex);
  if (v14)
    BoolForKey = IIODictionary::getBoolForKey(v14, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
  else
    BoolForKey = 0;
  RecodeProperties = (const void **)IIOReadPlugin::CreateRecodeProperties(a2, ImagePropertiesAtIndex, this, (const __CFDictionary **)v14, (IIODictionary *)&v93, v16);
  v19 = IIOGetExifOrientation((IIODictionary *)RecodeProperties, 0);
  if (!v19)
    v19 = IIOGetExifOrientation(ImagePropertiesAtIndex, 0);
  v20 = (v19 - 2) < 7 && BoolForKey;
  if (v20)
  {
    IIODictionary::setObjectForKey((IIODictionary *)&v80, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_ApplyTransform);
    kdebug_trace();
  }
  v21 = IIODictionary::getBoolForKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageDestinationPreserveGainMap"));
  IIOReadPlugin::CleanupRecodeProperties((IIOReadPlugin *)RecodeProperties, v22);
  v23 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v24 = gFunc_CMPhotoDecompressionSessionCreate(*MEMORY[0x1E0C9AE00], v81, &v92);
  v25 = v24;
  if (v24)
  {
    v26 = IIOCMErrorString(v24);
    LogError("IIORecodeHEIF_to_JPEG", 237, "*** ERROR: could not create CMPhotoDecompressionSession err = %s [%d]\n", v26, v25);
LABEL_32:
    cf = 0;
    v27 = 0;
    InputColorSpaceForOutputPoppyProfile = 0;
LABEL_33:
    v29 = 4294967246;
    goto LABEL_34;
  }
  Size = IIOImageReadSession::getSize(Source);
  v32 = IIOImageReadSession::retainBytePointer(Source, (const __CFData **)&v79, 1);
  if (!v32)
  {
    LogError("IIORecodeHEIF_to_JPEG", 248, "*** ERROR: could not read input (HEIC) data\n");
    goto LABEL_32;
  }
  cf = CFDataCreateWithBytesNoCopy(v23, (const UInt8 *)v32, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (IIORestrictedDecodingEnabledFlag())
  {
    v33 = (const void *)*MEMORY[0x1E0C9AE50];
    IIODictionary::setObjectForKey((IIODictionary *)&v86, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoTranscodeOption_RestrictedTranscoding);
    IIODictionary::setObjectForKey((IIODictionary *)&v86, v33, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_RestrictedDecoding);
    if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
      ImageIOLog("••• ✅ Process-EnableRestrictedDecoding  | %s:%d\n");
  }
  else if (IIODictionary::containsKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageSourceEnableRestrictedDecoding")))
  {
    if (IIODictionary::getBoolForKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageSourceEnableRestrictedDecoding")))
    {
      v34 = (const void *)*MEMORY[0x1E0C9AE50];
      IIODictionary::setObjectForKey((IIODictionary *)&v86, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoTranscodeOption_RestrictedTranscoding);
      IIODictionary::setObjectForKey((IIODictionary *)&v86, v34, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_RestrictedDecoding);
      if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
        ImageIOLog("••• ✅ EnableRestrictedDecoding  | %s:%d\n");
    }
    else if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
    {
      ImageIOLog("••• ❌ EnableRestrictedDecoding  | %s:%d\n");
    }
  }
  else if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
  {
    ImageIOLog("••• ❓ EnableRestrictedDecoding  | %s:%d\n");
  }
  if ((IIOHardwareDecodingEnabledFlag() & 1) != 0)
  {
    if (IIODictionary::containsKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageSourceUseHardwareAcceleration")))
    {
      if (IIODictionary::getBoolForKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageSourceUseHardwareAcceleration")))
      {
        if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
          ImageIOLog("••• ✅ UseHardwareAcceleration  | %s:%d\n");
      }
      else
      {
        IIONumber::IIONumber((IIONumber *)v75, 1);
        IIODictionary::setObjectForKey((uint64_t)&v86, (uint64_t)v75, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
        IIONumber::~IIONumber((IIONumber *)v75);
        if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
          ImageIOLog("••• ❌ UseHardwareAcceleration  | %s:%d\n");
      }
    }
    else if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
    {
      ImageIOLog("••• ❓ UseHardwareAcceleration  | %s:%d\n");
    }
  }
  else
  {
    IIONumber::IIONumber((IIONumber *)v76, 1);
    IIODictionary::setObjectForKey((uint64_t)&v86, (uint64_t)v76, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
    IIONumber::~IIONumber((IIONumber *)v76);
    if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
      ImageIOLog("••• ❌ Process-UseHardwareAcceleration  | %s:%d\n");
  }
  v35 = gFunc_CMPhotoDecompressionSessionCreateContainer(v92, v87, cf, &v90, &v89);
  v29 = v35;
  if ((_DWORD)v35)
  {
    v36 = IIOCMErrorString(v35);
    LogError("IIORecodeHEIF_to_JPEG", 301, "*** ERROR: could not create CMPhotoDecompressionContainer err = %s [%d]\n", v36, v29);
    v27 = 0;
    InputColorSpaceForOutputPoppyProfile = 0;
    goto LABEL_34;
  }
  if (v20)
  {
    IIODictionary::setObjectForKey((IIODictionary *)&v83, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_ApplyTransform);
    kdebug_trace();
  }
  v37 = IIOImageDestination::resizeImageMaxPixelSize(this);
  if (v37)
  {
    IIONumber::IIONumber((IIONumber *)v74, v37);
    IIODictionary::setObjectForKey((uint64_t)&v83, (uint64_t)v74, *(const void **)gIIO_kCMPhotoCompressionOption_MaxPixelSize);
    IIONumber::~IIONumber((IIONumber *)v74);
    IIONumber::IIONumber((IIONumber *)v73, Uint32ForKey);
    IIODictionary::setObjectForKey((uint64_t)&v83, (uint64_t)v73, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
    IIONumber::~IIONumber((IIONumber *)v73);
  }
  v38 = IIODictionary::containsKey((IIODictionary *)RecodeProperties, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_Strips);
  value = (void *)*MEMORY[0x1E0C9AE50];
  if (v38)
    IIODictionary::setObjectForKey((IIODictionary *)&v83, value, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_Strips);
  IIODictionary::setObjectForKey((IIODictionary *)&v83, value, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_IncludeThumbnail);
  IIODictionary::setObjectForKey((IIODictionary *)&v83, value, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_IncludeMetadata);
  IIODictionary::setObjectForKey((IIODictionary *)&v83, RecodeProperties[1], *(const __CFString **)gIIO_kCMPhotoTranscodeOption_ReplacementImageProperties);
  IIODictionary::setObjectForKey((IIODictionary *)&v83, (const void *)*MEMORY[0x1E0C9AE40], *(const __CFString **)gIIO_kCMPhotoTranscodeOption_IncludeAuxiliaryImages);
  if (v21)
  {
    v70 = 0;
    v71 = 0;
    v72 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v70);
    if (!v37)
    {
      Width = CGImageGetWidth(ImageAtIndex);
      if (Width <= CGImageGetHeight(ImageAtIndex))
        Height = CGImageGetHeight(ImageAtIndex);
      else
        Height = CGImageGetWidth(ImageAtIndex);
      v37 = Height;
    }
    IIONumber::IIONumber((IIONumber *)v68, v37 >> 1);
    IIODictionary::setObjectForKey((IIODictionary *)&v70, v69, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
    IIONumber::~IIONumber((IIONumber *)v68);
    if (v20)
    {
      IIODictionary::setObjectForKey((IIODictionary *)&v70, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_ApplyTransform);
      kdebug_trace();
    }
    IIODictionary::setObjectForKey((IIODictionary *)&v83, v71, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_PreserveAndModifyGainMap);
    kdebug_trace();
    IIODictionary::~IIODictionary((IIODictionary *)&v70);
  }
  if (IIODictionary::containsKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageDestinationLossyCompressionQuality")))
  {
    FloatForKey = IIODictionary::getFloatForKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageDestinationLossyCompressionQuality"));
    if (FloatForKey != -1.0 && FloatForKey > 0.0 && FloatForKey <= 1.0)
    {
      IIONumber::IIONumber((IIONumber *)v67, 3);
      IIODictionary::setObjectForKey((uint64_t)&v83, (uint64_t)v67, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
      IIONumber::~IIONumber((IIONumber *)v67);
      v70 = 0;
      v71 = 0;
      v72 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v70);
      IIONumber::IIONumber((IIONumber *)v66, FloatForKey);
      IIODictionary::setObjectForKey((uint64_t)&v70, (uint64_t)v66, *(const void **)gIIO_kCMPhotoQualityControllerParameter_QualityValue);
      IIONumber::~IIONumber((IIONumber *)v66);
      IIODictionary::setObjectForKey((IIODictionary *)&v83, v71, *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
      IIODictionary::~IIODictionary((IIODictionary *)&v70);
    }
  }
  if (IIOImageDestination::GetOptimizeForSharing((IIOImageDestination *)RecodeProperties, (IIODictionary *)&v77, v41))
  {
    if (v77)
      v43 = v61;
    else
      v43 = space;
    v27 = CGColorSpaceRetain(v43);
    Model = CGColorSpaceGetModel(v27);
    if (IIO_CGColorSpaceNameMatchesName(v27, v6))
    {
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL AppleJPEG recoding image - original is sRGB -- falling back to sRGB\n");
LABEL_115:
      InputColorSpaceForOutputPoppyProfile = 0;
LABEL_116:
      ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)RecodeProperties, CFSTR("ColorSpace"));
      ResizeSourceColorSpace = ObjectForKey;
      if (v78)
        v48 = v78;
      else
        v48 = v61;
      if (!ObjectForKey)
        ResizeSourceColorSpace = IIOImageDestination::getResizeSourceColorSpace(this);
      if (ResizeSourceColorSpace)
      {
        if (v48)
        {
          v49 = (IIOColorConverter *)operator new();
          IIOColorConverter::IIOColorConverter(v49, ResizeSourceColorSpace, v48);
          if (*((_QWORD *)v49 + 1))
          {
            v70 = 0;
            v71 = 0;
            v72 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v70);
            IIONumber::IIONumber((IIONumber *)v68, 1);
            IIODictionary::setObjectForKey((IIODictionary *)&v70, v69, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_ColorConverterVersion);
            IIONumber::~IIONumber((IIONumber *)v68);
            IIODictionary::setObjectForKey((IIODictionary *)&v70, v27, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_ColorConverterCGColorSpace);
            IIONumber::IIONumber((IIONumber *)v68, (uint64_t)v49);
            IIODictionary::setObjectForKey((IIODictionary *)&v70, v69, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_ColorConverterUserPointer);
            IIONumber::~IIONumber((IIONumber *)v68);
            IIONumber::IIONumber((IIONumber *)v68, (uint64_t)HEIFReadPlugin::ColorConvert);
            IIODictionary::setObjectForKey((IIODictionary *)&v70, v69, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_ColorConverterCallback);
            IIONumber::~IIONumber((IIONumber *)v68);
            IIODictionary::setObjectForKey((IIODictionary *)&v83, v71, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_ColorConverter);
            IIONumber::IIONumber((IIONumber *)v65, 1111970369);
            IIODictionary::setObjectForKey((uint64_t)&v83, (uint64_t)v65, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
            IIONumber::~IIONumber((IIONumber *)v65);
            IIODictionary::~IIODictionary((IIODictionary *)&v70);
          }
        }
      }
      goto LABEL_125;
    }
    if (CGImageIsOptimizedForSharing())
    {
      CGColorSpaceRelease(v27);
      v45 = CGImageGetColorSpace(ImageAtIndex);
      v27 = (CGColorSpace *)CFRetain(v45);
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL original image is already poppy - not converting\n");
      goto LABEL_115;
    }
    if (v77)
    {
      v78 = CGColorSpaceRetain(v61);
      InputColorSpaceForOutputPoppyProfile = CGColorSpaceRetain(v61);
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL converting to sRGB\n");
      goto LABEL_116;
    }
    if (Model != kCGColorSpaceModelRGB)
    {
      if (!v78)
      {
        if (Model == kCGColorSpaceModelCMYK)
        {
          v78 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D968]);
          if ((gIIODebugFlags & 0x8000300000) != 0)
            ImageIOLog("COL AppleJPEG recoding image - GenericCMYK\n");
        }
        else if (Model == kCGColorSpaceModelMonochrome)
        {
          v78 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
          if ((gIIODebugFlags & 0x8000300000) != 0)
            ImageIOLog("COL AppleJPEG recoding image - GenericGrayGamma2.2\n");
        }
      }
      InputColorSpaceForOutputPoppyProfile = 0;
      goto LABEL_176;
    }
    if (a2)
      v53 = (CGImageSource *)IIOImageSource::cf(a2);
    else
      v53 = 0;
    IIO_CreateOutputPoppyProfileForImage(v53, ImageAtIndex, &v78);
    if (v78)
    {
      InputColorSpaceForOutputPoppyProfile = (CGColorSpace *)IIO_CreateInputColorSpaceForOutputPoppyProfile();
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL AppleJPEG recoding image - using poppy profile\n");
      if (v78)
        goto LABEL_176;
    }
    else
    {
      InputColorSpaceForOutputPoppyProfile = 0;
    }
    v54 = CGColorSpaceCopyICCData(space);
    if (v54
      && (CanBeIgnoredOnSRGBDevice = ColorSyncDataCanBeIgnoredOnSRGBDevice(), CFRelease(v54), CanBeIgnoredOnSRGBDevice))
    {
      v56 = CGImageGetColorSpace(ImageAtIndex);
      v78 = CGColorSpaceRetain(v56);
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL AppleJPEG recoding image - resizeSourceImage is Poppy -- using that\n");
    }
    else
    {
      v78 = CGColorSpaceRetain(v61);
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL AppleJPEG recoding image - poppyPCSToDeviceColorSpace is nil -- falling back to sRGB\n");
    }
LABEL_176:
    CGColorSpaceRelease(v27);
    v27 = CGColorSpaceRetain(v78);
    goto LABEL_116;
  }
  v27 = 0;
  InputColorSpaceForOutputPoppyProfile = 0;
LABEL_125:
  if (IIODictionary::containsKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageSourceEnableRestrictedDecoding")))
  {
    if (IIODictionary::getBoolForKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageSourceEnableRestrictedDecoding")))
    {
      IIODictionary::setObjectForKey((IIODictionary *)&v83, value, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_RestrictedTranscoding);
      IIODictionary::setObjectForKey((IIODictionary *)&v83, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_RestrictedDecoding);
      if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
        ImageIOLog("••• ✅ EnableRestrictedDecoding  | %s:%d\n");
    }
    else if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
    {
      ImageIOLog("••• ❌ EnableRestrictedDecoding  | %s:%d\n");
    }
  }
  else if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
  {
    ImageIOLog("••• ❓ EnableRestrictedDecoding  | %s:%d\n");
  }
  if (IIODictionary::containsKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageSourceUseHardwareAcceleration")))
  {
    if (IIODictionary::getBoolForKey((IIODictionary *)RecodeProperties, CFSTR("kCGImageSourceUseHardwareAcceleration")))
    {
      if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
        ImageIOLog("••• ✅ UseHardwareAcceleration  | %s:%d\n");
    }
    else
    {
      IIODictionary::setObjectForKey((IIODictionary *)&v83, value, *(const __CFString **)gIIO_kCMPhotoTranscodeOption_PreferSoftwareEncode);
      if ((gIIODebugFlags & 0x4000000000000) != 0 && (IIO_OSAppleInternalBuild() & 1) != 0)
        ImageIOLog("••• ❌ UseHardwareAcceleration  | %s:%d\n");
    }
  }
  else if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
  {
    ImageIOLog("••• ❓ UseHardwareAcceleration  | %s:%d\n");
  }
  v29 = gFunc_CMPhotoDecompressionContainerJFIFTranscode(v89, v84, v59, v59, &v91);
  if ((_DWORD)v29 || !v91)
  {
    v52 = IIOCMErrorString(v29);
    _cg_jpeg_mem_term("IIORecodeHEIF_to_JPEG", 548, "*** ERROR: CMPhotoDecompressionContainerJFIFTranscode failed err = %s [0x%08X]\n", v52, v29);
  }
  else
  {
    BytePtr = CFDataGetBytePtr(v91);
    Length = CFDataGetLength(v91);
    IIOImageWriteSession::putBytes(v58, BytePtr, Length);
    CFRelease(v91);
    _cg_jpeg_mem_term("IIORecodeHEIF_to_JPEG", 545, "    CMPhotoDecompressionContainerJFIFTranscode OK\n");
    v29 = 0;
  }
LABEL_34:
  CGImageRelease(ImageAtIndex);
  CGColorSpaceRelease(v27);
  CGColorSpaceRelease(v78);
  CGColorSpaceRelease(InputColorSpaceForOutputPoppyProfile);
  if (cf)
    CFRelease(cf);
  if (v89)
    CFRelease(v89);
  if (RecodeProperties)
    (*((void (**)(const void **))*RecodeProperties + 1))(RecodeProperties);
  if (v93)
    CFRelease(v93);
  if (v79 && Source)
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)Source, v79);
  if (v92)
    CFRelease(v92);
  if (v64)
    CFRelease(v64);
  CGColorSpaceRelease(v61);
  IIODictionary::~IIODictionary((IIODictionary *)&v80);
  IIODictionary::~IIODictionary((IIODictionary *)&v83);
  IIODictionary::~IIODictionary((IIODictionary *)&v86);
  return v29;
}

void sub_187F4D954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, CGColorSpaceRef space, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,char a43)
{
  uint64_t v43;

  CGColorSpaceRelease(space);
  IIODictionary::~IIODictionary((IIODictionary *)(v43 - 224));
  IIODictionary::~IIODictionary((IIODictionary *)(v43 - 200));
  IIODictionary::~IIODictionary((IIODictionary *)(v43 - 176));
  _Unwind_Resume(a1);
}

_QWORD *_cg_jinit_color_deconverter(uint64_t a1)
{
  _QWORD *result;
  _QWORD *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  int v11;
  uint64_t (*v12)(uint64_t, _QWORD *, unsigned int, _BYTE **, int);
  void *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t (*v18)(uint64_t, _QWORD *, unsigned int, _QWORD *, int);
  int v19;
  uint64_t v20;
  int v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;

  result = (_QWORD *)(**(uint64_t (***)(void))(a1 + 8))();
  v3 = result;
  *(_QWORD *)(a1 + 648) = result;
  *result = start_pass_dcolor;
  v4 = *(_DWORD *)(a1 + 60);
  if (v4 > 7)
    goto LABEL_34;
  if (((1 << v4) & 0xCC) == 0)
  {
    if (((1 << v4) & 0x30) != 0)
    {
      if (*(_DWORD *)(a1 + 56) == 4)
        goto LABEL_5;
      goto LABEL_4;
    }
    if (v4 == 1)
    {
      if (*(_DWORD *)(a1 + 56) == 1)
        goto LABEL_5;
      goto LABEL_4;
    }
LABEL_34:
    if (*(int *)(a1 + 56) > 0)
      goto LABEL_5;
    goto LABEL_4;
  }
  if (*(_DWORD *)(a1 + 56) != 3)
  {
LABEL_4:
    v5 = *(_QWORD *)a1;
    *(_DWORD *)(v5 + 40) = 11;
    result = (_QWORD *)(*(uint64_t (**)(uint64_t))v5)(a1);
  }
LABEL_5:
  if (*(_DWORD *)(a1 + 396) && (*(_DWORD *)(a1 + 60) | 4) != 6)
  {
    v6 = *(_QWORD *)a1;
    *(_DWORD *)(v6 + 40) = 28;
    result = (_QWORD *)(*(uint64_t (**)(uint64_t))v6)(a1);
  }
  v7 = *(_DWORD *)(a1 + 64);
  switch(v7)
  {
    case 1:
      *(_DWORD *)(a1 + 144) = 1;
      switch(*(_DWORD *)(a1 + 60))
      {
        case 1:
        case 3:
        case 7:
          v3[1] = grayscale_convert_0;
          v8 = *(unsigned int *)(a1 + 56);
          if ((int)v8 >= 2)
          {
            v9 = (_DWORD *)(*(_QWORD *)(a1 + 304) + 148);
            v10 = v8 - 1;
            do
            {
              *v9 = 0;
              v9 += 24;
              --v10;
            }
            while (v10);
          }
          goto LABEL_46;
        case 2:
          v17 = *(_DWORD *)(a1 + 396);
          if (v17 == 1)
          {
            v18 = rgb1_gray_convert;
            goto LABEL_54;
          }
          if (!v17)
          {
            v18 = rgb_gray_convert_0;
LABEL_54:
            v3[1] = v18;
            goto LABEL_56;
          }
          v31 = *(_QWORD *)a1;
          *(_DWORD *)(v31 + 40) = 28;
          (*(void (**)(uint64_t))v31)(a1);
LABEL_56:
          v32 = *(_QWORD *)(a1 + 648);
          result = (_QWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 6144);
          v33 = 0;
          v34 = 0;
          v35 = 0;
          *(_QWORD *)(v32 + 48) = result;
          v36 = 0x8000;
          do
          {
            v37 = &result[v35];
            *v37 = v33;
            ++v35;
            v37[256] = v34;
            v37[512] = v36;
            v36 += 7471;
            v34 += 38470;
            v33 += 19595;
          }
          while (v35 != 256);
LABEL_46:
          if (*(_DWORD *)(a1 + 108))
            v21 = 1;
          else
            v21 = *(_DWORD *)(a1 + 144);
          *(_DWORD *)(a1 + 148) = v21;
          return result;
        default:
          goto LABEL_43;
      }
    case 2:
      *(_DWORD *)(a1 + 144) = 3;
      switch(*(_DWORD *)(a1 + 60))
      {
        case 1:
          v13 = gray_rgb_convert;
          goto LABEL_45;
        case 2:
          v19 = *(_DWORD *)(a1 + 396);
          if (v19 == 1)
            goto LABEL_44;
          if (v19)
            goto LABEL_43;
          goto LABEL_30;
        case 3:
          v12 = ycc_rgb_convert;
          goto LABEL_40;
        case 7:
          v3[1] = ycc_rgb_convert;
          v22 = *(_QWORD **)(a1 + 648);
          v22[2] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
          v22[3] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
          v22[4] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
          result = (_QWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
          v23 = 0;
          v22[5] = result;
          v24 = v22[2];
          v25 = v22[3];
          v26 = -29696512;
          v27 = -23488896;
          v28 = 5806464;
          v29 = 11981184;
          v30 = v22[4];
          do
          {
            *(_DWORD *)(v24 + 4 * v23) = v27 >> 16;
            *(_DWORD *)(v25 + 4 * v23) = v26 >> 16;
            *(_QWORD *)(v30 + 8 * v23) = v29;
            result[v23++] = v28;
            v28 -= 45107;
            v29 -= 93603;
            v26 += 232260;
            v27 += 183763;
          }
          while (v23 != 256);
          goto LABEL_46;
        default:
          goto LABEL_43;
      }
    case 4:
      *(_DWORD *)(a1 + 144) = 4;
      v11 = *(_DWORD *)(a1 + 60);
      if (v11 == 4)
        goto LABEL_25;
      if (v11 != 5)
        goto LABEL_43;
      v12 = ycck_cmyk_convert;
LABEL_40:
      v3[1] = v12;
      result = (_QWORD *)build_ycc_rgb_table(a1);
      goto LABEL_46;
    case 6:
      *(_DWORD *)(a1 + 144) = 3;
      if (*(_DWORD *)(a1 + 60) != 6)
      {
        v15 = *(_QWORD *)a1;
        *(_DWORD *)(v15 + 40) = 28;
        result = (_QWORD *)(*(uint64_t (**)(uint64_t))v15)(a1);
      }
      v16 = *(_DWORD *)(a1 + 396);
      if (v16 == 1)
      {
LABEL_44:
        v13 = rgb1_rgb_convert;
      }
      else
      {
        if (v16)
        {
LABEL_43:
          v20 = *(_QWORD *)a1;
          *(_DWORD *)(v20 + 40) = 28;
          result = (_QWORD *)(*(uint64_t (**)(uint64_t))v20)(a1);
          goto LABEL_46;
        }
LABEL_30:
        v13 = rgb_convert_0;
      }
LABEL_45:
      v3[1] = v13;
      goto LABEL_46;
    default:
      if (v7 != *(_DWORD *)(a1 + 60))
      {
        v14 = *(_QWORD *)a1;
        *(_DWORD *)(v14 + 40) = 28;
        result = (_QWORD *)(*(uint64_t (**)(uint64_t))v14)(a1);
      }
      *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 56);
LABEL_25:
      v13 = null_convert_0;
      goto LABEL_45;
  }
}

char *grayscale_convert_0(uint64_t a1, char **a2, int a3, uint64_t a4, int a5)
{
  return _cg_jcopy_sample_rows(*a2, a3, a4, 0, a5, *(unsigned int *)(a1 + 136));
}

uint64_t rgb_gray_convert_0(uint64_t result, _QWORD *a2, unsigned int a3, _QWORD *a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;

  if (a5 >= 1)
  {
    v5 = *(_QWORD *)(*(_QWORD *)(result + 648) + 48);
    v6 = *(unsigned int *)(result + 136);
    do
    {
      v8 = (_BYTE *)*a4++;
      v7 = v8;
      if ((_DWORD)v6)
      {
        v9 = *(unsigned __int8 **)(*a2 + 8 * a3);
        v10 = *(unsigned __int8 **)(a2[1] + 8 * a3);
        v11 = *(unsigned __int8 **)(a2[2] + 8 * a3);
        v12 = v6;
        do
        {
          v14 = *v9++;
          v13 = v14;
          v16 = *v10++;
          v15 = v16;
          v17 = *v11++;
          *v7++ = (*(_DWORD *)(v5 + 8 * v15 + 2048)
                 + *(_QWORD *)(v5 + 8 * v13)
                 + *(_DWORD *)(v5 + 8 * v17 + 4096)) >> 16;
          --v12;
        }
        while (v12);
      }
      ++a3;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb1_gray_convert(uint64_t result, _QWORD *a2, unsigned int a3, _QWORD *a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  char *v9;
  unsigned __int8 *v10;
  _BYTE *v11;
  uint64_t v12;
  char v13;
  char v14;
  uint64_t v15;
  unsigned int v16;

  if (a5 >= 1)
  {
    v5 = *(_QWORD *)(*(_QWORD *)(result + 648) + 48);
    v6 = *(unsigned int *)(result + 136);
    do
    {
      v8 = (_BYTE *)*a4++;
      v7 = v8;
      if ((_DWORD)v6)
      {
        v9 = *(char **)(*a2 + 8 * a3);
        v10 = *(unsigned __int8 **)(a2[1] + 8 * a3);
        v11 = *(_BYTE **)(a2[2] + 8 * a3);
        v12 = v6;
        do
        {
          v14 = *v9++;
          v13 = v14;
          v16 = *v10++;
          v15 = v16;
          LOBYTE(v16) = *v11++;
          result = v15 ^ 0xFFFFFF80;
          *v7++ = (*(_DWORD *)(v5 + 8 * v15 + 2048)
                 + *(_QWORD *)(v5 + 8 * ((v15 ^ 0x80) + v13))
                 + *(_DWORD *)(v5 + 8 * ((v15 ^ 0x80) + v16) + 4096)) >> 16;
          --v12;
        }
        while (v12);
      }
      ++a3;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t gray_rgb_convert(uint64_t result, _QWORD *a2, unsigned int a3, _QWORD *a4, int a5)
{
  uint64_t v5;
  char *v6;
  _BYTE *v7;
  uint64_t v8;
  char v9;

  if (a5 >= 1)
  {
    v5 = *(unsigned int *)(result + 136);
    do
    {
      if ((_DWORD)v5)
      {
        v6 = *(char **)(*a2 + 8 * a3);
        v7 = (_BYTE *)(*a4 + 2);
        v8 = v5;
        do
        {
          v9 = *v6++;
          *v7 = v9;
          *(v7 - 1) = v9;
          *(v7 - 2) = v9;
          v7 += 3;
          --v8;
        }
        while (v8);
      }
      ++a3;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t ycc_rgb_convert(uint64_t result, _QWORD *a2, unsigned int a3, _BYTE **a4, int a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  _BYTE *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  BOOL v22;

  if (a5 >= 1)
  {
    v5 = *(_QWORD **)(result + 648);
    v6 = *(_QWORD *)(result + 440);
    v7 = v5[2];
    v8 = v5[3];
    v9 = v5[4];
    v10 = v5[5];
    v11 = *(unsigned int *)(result + 136);
    do
    {
      if ((_DWORD)v11)
      {
        v12 = *(unsigned __int8 **)(*a2 + 8 * a3);
        v13 = *(unsigned __int8 **)(a2[1] + 8 * a3);
        v14 = *(unsigned __int8 **)(a2[2] + 8 * a3);
        v15 = *a4;
        result = v11;
        do
        {
          v17 = *v12++;
          v16 = v17;
          v19 = *v13++;
          v18 = v19;
          v20 = *v14++;
          *v15 = *(_BYTE *)(v6 + *(int *)(v7 + 4 * v20) + v16);
          v15[1] = *(_BYTE *)(v6 + v16 + (int)((*(_QWORD *)(v9 + 8 * v20) + *(_QWORD *)(v10 + 8 * v18)) >> 16));
          v15[2] = *(_BYTE *)(v6 + *(int *)(v8 + 4 * v18) + v16);
          v15 += 3;
          --result;
        }
        while (result);
      }
      ++a3;
      ++a4;
      v22 = __OFSUB__(a5, 2);
      v21 = a5 - 2 < 0;
      --a5;
    }
    while (v21 == v22);
  }
  return result;
}

uint64_t build_ycc_rgb_table(uint64_t a1)
{
  _QWORD *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(_QWORD **)(a1 + 648);
  v2[2] = (**(uint64_t (***)(void))(a1 + 8))();
  v2[3] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
  v2[4] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
  result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
  v4 = 0;
  v2[5] = result;
  v5 = v2[2];
  v6 = v2[3];
  v7 = -11728000;
  v8 = -14831872;
  v9 = 5990656;
  v10 = 2919552;
  v11 = v2[4];
  do
  {
    *(_DWORD *)(v5 + 4 * v4) = v7 >> 16;
    *(_DWORD *)(v6 + 4 * v4) = v8 >> 16;
    *(_QWORD *)(v11 + 8 * v4) = v9;
    *(_QWORD *)(result + 8 * v4++) = v10;
    v7 += 91881;
    v8 += 116130;
    v9 -= 46802;
    v10 -= 22553;
  }
  while (v4 != 256);
  return result;
}

uint64_t rgb_convert_0(uint64_t result, _QWORD *a2, unsigned int a3, _BYTE **a4, int a5)
{
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  char v12;
  char v13;

  if (a5 >= 1)
  {
    v5 = *(unsigned int *)(result + 136);
    do
    {
      if ((_DWORD)v5)
      {
        v6 = *(char **)(*a2 + 8 * a3);
        v7 = *(char **)(a2[1] + 8 * a3);
        v8 = *(char **)(a2[2] + 8 * a3);
        v9 = *a4;
        v10 = v5;
        do
        {
          v11 = *v6++;
          *v9 = v11;
          v12 = *v7++;
          v9[1] = v12;
          v13 = *v8++;
          v9[2] = v13;
          v9 += 3;
          --v10;
        }
        while (v10);
      }
      ++a3;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb1_rgb_convert(uint64_t result, _QWORD *a2, unsigned int a3, _BYTE **a4, int a5)
{
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;

  if (a5 >= 1)
  {
    v5 = *(unsigned int *)(result + 136);
    do
    {
      if ((_DWORD)v5)
      {
        v6 = *(char **)(*a2 + 8 * a3);
        v7 = *(char **)(a2[1] + 8 * a3);
        v8 = *(char **)(a2[2] + 8 * a3);
        v9 = *a4;
        v10 = v5;
        do
        {
          v12 = *v6++;
          v11 = v12;
          v14 = *v7++;
          v13 = v14;
          v15 = *v8++;
          *v9 = (v13 + v11) ^ 0x80;
          v9[1] = v13;
          v9[2] = (v15 + v13) ^ 0x80;
          v9 += 3;
          --v10;
        }
        while (v10);
      }
      ++a3;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t ycck_cmyk_convert(uint64_t result, _QWORD *a2, unsigned int a3, _BYTE **a4, int a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  _BYTE *v15;
  _BYTE *v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  BOOL v22;
  BOOL v23;

  if (a5 >= 1)
  {
    v5 = *(_QWORD **)(result + 648);
    v6 = *(_QWORD *)(result + 440);
    v7 = v5[2];
    v8 = v5[3];
    v9 = v5[4];
    v10 = v5[5];
    v11 = *(unsigned int *)(result + 136);
    do
    {
      if ((_DWORD)v11)
      {
        v12 = *(unsigned __int8 **)(*a2 + 8 * a3);
        v13 = *(unsigned __int8 **)(a2[1] + 8 * a3);
        v14 = *(unsigned __int8 **)(a2[2] + 8 * a3);
        v15 = *(_BYTE **)(a2[3] + 8 * a3);
        result = v11;
        v16 = *a4;
        do
        {
          v18 = *v12++;
          v17 = v18;
          v20 = *v13++;
          v19 = v20;
          v21 = *v14++;
          v17 ^= 0xFFu;
          *v16 = *(_BYTE *)(v6 + v17 - *(_DWORD *)(v7 + 4 * v21));
          v16[1] = *(_BYTE *)(v6 + (int)(v17 - ((*(_QWORD *)(v9 + 8 * v21) + *(_QWORD *)(v10 + 8 * v19)) >> 16)));
          v16[2] = *(_BYTE *)(v6 + v17 - *(_DWORD *)(v8 + 4 * v19));
          LOBYTE(v21) = *v15++;
          v16[3] = v21;
          v16 += 4;
          --result;
        }
        while (result);
      }
      ++a3;
      ++a4;
      v23 = __OFSUB__(a5, 2);
      v22 = a5 - 2 < 0;
      --a5;
    }
    while (v22 == v23);
  }
  return result;
}

uint64_t null_convert_0(uint64_t result, uint64_t a2, unsigned int a3, uint64_t *a4, int a5)
{
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  int v11;
  char v12;

  if (a5 >= 1)
  {
    v5 = *(_DWORD *)(result + 136);
    v6 = *(unsigned int *)(result + 56);
    v7 = *(_DWORD *)(result + 56);
    do
    {
      if (v7 >= 1)
      {
        v8 = 0;
        do
        {
          if (v5)
          {
            v9 = *a4;
            v10 = *(char **)(*(_QWORD *)(a2 + 8 * v8) + 8 * a3);
            v11 = v5;
            do
            {
              v12 = *v10++;
              *(_BYTE *)(v9 + v8) = v12;
              v9 += (int)v6;
              --v11;
            }
            while (v11);
          }
          ++v8;
        }
        while (v8 != v6);
      }
      ++a3;
      ++a4;
    }
    while (a5-- > 1);
  }
  return result;
}

double _cg_jinit_memory_mgr(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  char *small;
  __n128 v6;
  void (**v7)(_QWORD, __n128);
  double result;

  a1[1] = 0;
  v2 = _cg_jpeg_mem_init();
  small = (char *)_cg_jpeg_get_small((int)a1, 0xA8uLL);
  if (!small)
  {
    v6 = _cg_jpeg_mem_term(a1, v3, v4);
    v7 = (void (**)(_QWORD, __n128))*a1;
    *((_DWORD *)v7 + 10) = 56;
    *((_DWORD *)v7 + 12) = 0;
    (*(void (**)(_QWORD *, __n128))*a1)(a1, v6);
  }
  *(_QWORD *)small = alloc_small;
  *((_QWORD *)small + 1) = alloc_large;
  *((_QWORD *)small + 2) = alloc_sarray;
  *((_QWORD *)small + 3) = alloc_barray;
  *((_QWORD *)small + 4) = request_virt_sarray;
  *((_QWORD *)small + 5) = request_virt_barray;
  *((_QWORD *)small + 6) = realize_virt_arrays;
  *((_QWORD *)small + 7) = access_virt_sarray;
  *((_QWORD *)small + 8) = access_virt_barray;
  *((_QWORD *)small + 9) = free_pool;
  *((_QWORD *)small + 11) = v2;
  *((_QWORD *)small + 12) = 1000000000;
  *((_QWORD *)small + 10) = self_destruct;
  result = 0.0;
  *(_OWORD *)(small + 104) = 0u;
  *(_OWORD *)(small + 120) = 0u;
  *(_OWORD *)(small + 136) = 0u;
  *((_QWORD *)small + 19) = 168;
  a1[1] = small;
  return result;
}

uint64_t alloc_small(_QWORD *a1, signed int a2, unint64_t a3)
{
  uint64_t v6;
  void (**v7)(_QWORD *);
  unint64_t v8;
  void (**v9)(_QWORD *);
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *i;
  void (**v21)(_QWORD *);
  _QWORD *v22;
  uint64_t v23;
  uint64_t result;
  unint64_t v25;

  v6 = a1[1];
  if (a3 > 0x3B9AC9E8)
  {
    v7 = (void (**)(_QWORD *))*a1;
    *((_DWORD *)v7 + 10) = 56;
    *((_DWORD *)v7 + 12) = 1;
    (*(void (**)(_QWORD *))*a1)(a1);
  }
  v8 = a3 + 7;
  if (a2 >= 2)
  {
    v9 = (void (**)(_QWORD *))*a1;
    *((_DWORD *)v9 + 10) = 15;
    *((_DWORD *)v9 + 12) = a2;
    (*(void (**)(_QWORD *))*a1)(a1);
  }
  v10 = v8 & 0xFFFFFFFFFFFFFFF8;
  v11 = v6 + 8 * a2;
  v14 = *(_QWORD **)(v11 + 104);
  v13 = (_QWORD *)(v11 + 104);
  v12 = v14;
  if (v14)
  {
    while (1)
    {
      v15 = v12;
      if (v12[2] >= v10)
        break;
      v12 = (_QWORD *)*v12;
      if (!*v15)
        goto LABEL_10;
    }
  }
  else
  {
    v15 = 0;
LABEL_10:
    v16 = v10 + 24;
    v17 = &extra_pool_slop;
    if (!v15)
      v17 = &first_pool_slop;
    if (v17[a2] >= 999999976 - v10)
      v18 = 999999976 - v10;
    else
      v18 = v17[a2];
    v19 = v16 + v18;
    for (i = _cg_jpeg_get_small((int)a1, v16 + v18); !i; i = _cg_jpeg_get_small((int)a1, v16 + v18))
    {
      if (v18 <= 0x63)
      {
        v21 = (void (**)(_QWORD *))*a1;
        *((_DWORD *)v21 + 10) = 56;
        *((_DWORD *)v21 + 12) = 2;
        (*(void (**)(_QWORD *))*a1)(a1);
      }
      v18 >>= 1;
      v19 = v16 + v18;
    }
    *(_QWORD *)(v6 + 152) += v19;
    *i = 0;
    i[1] = 0;
    i[2] = v18 + v10;
    if (v15)
      v22 = v15;
    else
      v22 = v13;
    *v22 = i;
    v15 = i;
  }
  v23 = v15[1];
  result = (uint64_t)v15 + v23 + 24;
  v25 = v15[2] - v10;
  v15[1] = v23 + v10;
  v15[2] = v25;
  return result;
}

_QWORD *alloc_large(_QWORD *a1, unsigned int a2, unint64_t a3)
{
  uint64_t v6;
  void (**v7)(_QWORD *);
  unint64_t v8;
  void (**v9)(_QWORD *);
  _QWORD *large;
  void (**v11)(_QWORD *);
  uint64_t v12;

  v6 = a1[1];
  if (a3 >= 0x3B9AC9E9)
  {
    v7 = (void (**)(_QWORD *))*a1;
    *((_DWORD *)v7 + 10) = 56;
    *((_DWORD *)v7 + 12) = 3;
    (*(void (**)(_QWORD *))*a1)(a1);
  }
  v8 = (a3 + 7) & 0xFFFFFFFFFFFFFFF8;
  if (a2 >= 2)
  {
    v9 = (void (**)(_QWORD *))*a1;
    *((_DWORD *)v9 + 10) = 15;
    *((_DWORD *)v9 + 12) = a2;
    (*(void (**)(_QWORD *))*a1)(a1);
  }
  large = _cg_jpeg_get_large((int)a1, v8 + 24);
  if (!large)
  {
    v11 = (void (**)(_QWORD *))*a1;
    *((_DWORD *)v11 + 10) = 56;
    *((_DWORD *)v11 + 12) = 4;
    (*(void (**)(_QWORD *))*a1)(a1);
  }
  *(_QWORD *)(v6 + 152) += v8 + 24;
  v12 = v6 + 8 * (int)a2;
  *large = *(_QWORD *)(v12 + 120);
  large[1] = v8;
  large[2] = 0;
  *(_QWORD *)(v12 + 120) = large;
  return large + 3;
}

uint64_t alloc_sarray(uint64_t *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unsigned int v14;
  uint64_t v15;

  v8 = a1[1];
  v9 = 0x3B9AC9E8 / a3;
  if (a3 > 0x3B9AC9E8)
  {
    v10 = *a1;
    *(_DWORD *)(v10 + 40) = 72;
    (*(void (**)(uint64_t *))v10)(a1);
  }
  if (v9 >= a4)
    v9 = a4;
  *(_DWORD *)(v8 + 160) = v9;
  v11 = alloc_small(a1, a2, 8 * a4);
  if (a4)
  {
    v12 = 0;
    do
    {
      if (v9 >= a4 - v12)
        v9 = a4 - v12;
      v13 = alloc_large(a1, a2, a3 * (unint64_t)v9);
      if (v9)
      {
        v14 = v9;
        do
        {
          v15 = (v12 + 1);
          *(_QWORD *)(v11 + 8 * v12) = v13;
          v13 = (_QWORD *)((char *)v13 + a3);
          LODWORD(v12) = v12 + 1;
          --v14;
        }
        while (v14);
      }
      else
      {
        v15 = v12;
      }
      v12 = v15;
    }
    while (v15 < a4);
  }
  return v11;
}

uint64_t alloc_barray(uint64_t *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;

  v8 = a1[1];
  v9 = (unint64_t)a3 << 7;
  v10 = 0x3B9AC9E8 / v9;
  if (a3 >= 0x773594)
  {
    v11 = *a1;
    *(_DWORD *)(v11 + 40) = 72;
    (*(void (**)(uint64_t *))v11)(a1);
  }
  if (v10 >= a4)
    LODWORD(v10) = a4;
  *(_DWORD *)(v8 + 160) = v10;
  v12 = alloc_small(a1, a2, 8 * a4);
  if (a4)
  {
    v13 = 0;
    v14 = (unint64_t)a3 << 7;
    do
    {
      if (v10 >= a4 - v13)
        v10 = a4 - v13;
      else
        v10 = v10;
      v15 = alloc_large(a1, a2, v9 * v10);
      if ((_DWORD)v10)
      {
        v16 = v10;
        do
        {
          v17 = (v13 + 1);
          *(_QWORD *)(v12 + 8 * v13) = v15;
          v15 = (_QWORD *)((char *)v15 + v14);
          LODWORD(v13) = v13 + 1;
          --v16;
        }
        while (v16);
      }
      else
      {
        v17 = v13;
      }
      v13 = v17;
    }
    while (v17 < a4);
  }
  return v12;
}

uint64_t request_virt_sarray(_QWORD *a1, signed int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v12;
  void (**v13)(_QWORD);
  uint64_t result;

  v12 = a1[1];
  if (a2 != 1)
  {
    v13 = (void (**)(_QWORD))*a1;
    *((_DWORD *)v13 + 10) = 15;
    *((_DWORD *)v13 + 12) = a2;
    (*(void (**)(_QWORD *))*a1)(a1);
  }
  result = alloc_small(a1, a2, 0x98uLL);
  *(_QWORD *)result = 0;
  *(_DWORD *)(result + 8) = a5;
  *(_DWORD *)(result + 12) = a4;
  *(_DWORD *)(result + 16) = a6;
  *(_DWORD *)(result + 36) = a3;
  *(_DWORD *)(result + 44) = 0;
  *(_QWORD *)(result + 48) = *(_QWORD *)(v12 + 136);
  *(_QWORD *)(v12 + 136) = result;
  return result;
}

uint64_t request_virt_barray(_QWORD *a1, signed int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v12;
  void (**v13)(_QWORD);
  uint64_t result;

  v12 = a1[1];
  if (a2 != 1)
  {
    v13 = (void (**)(_QWORD))*a1;
    *((_DWORD *)v13 + 10) = 15;
    *((_DWORD *)v13 + 12) = a2;
    (*(void (**)(_QWORD *))*a1)(a1);
  }
  result = alloc_small(a1, a2, 0x98uLL);
  *(_QWORD *)result = 0;
  *(_DWORD *)(result + 8) = a5;
  *(_DWORD *)(result + 12) = a4;
  *(_DWORD *)(result + 16) = a6;
  *(_DWORD *)(result + 36) = a3;
  *(_DWORD *)(result + 44) = 0;
  *(_QWORD *)(result + 48) = *(_QWORD *)(v12 + 144);
  *(_QWORD *)(v12 + 144) = result;
  return result;
}

uint64_t realize_virt_arrays(uint64_t result)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t i;
  unint64_t v8;
  uint64_t v9;
  uint64_t j;
  uint64_t v11;
  uint64_t v12;
  uint64_t k;
  uint64_t v14;
  uint64_t v15;

  v1 = (uint64_t *)result;
  v2 = *(_QWORD *)(result + 8);
  v3 = *(_QWORD *)(v2 + 136);
  if (v3)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      if (!*(_QWORD *)v3)
      {
        v6 = *(_DWORD *)(v3 + 12);
        v5 += *(unsigned int *)(v3 + 16) * (unint64_t)v6;
        v4 += *(unsigned int *)(v3 + 8) * (unint64_t)v6;
      }
      v3 = *(_QWORD *)(v3 + 48);
    }
    while (v3);
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
  for (i = *(_QWORD *)(v2 + 144); i; i = *(_QWORD *)(i + 48))
  {
    if (!*(_QWORD *)i)
    {
      v8 = (unint64_t)*(unsigned int *)(i + 12) << 7;
      v5 += v8 * *(unsigned int *)(i + 16);
      v4 += v8 * *(unsigned int *)(i + 8);
    }
  }
  if (v5 >= 1)
  {
    result = _cg_jpeg_mem_available(result, v5, v4, *(_QWORD *)(v2 + 152));
    if (result >= v4)
    {
      v9 = 1000000000;
    }
    else if (result / v5 <= 1)
    {
      v9 = 1;
    }
    else
    {
      v9 = result / v5;
    }
    for (j = *(_QWORD *)(v2 + 136); j; j = *(_QWORD *)(j + 48))
    {
      if (!*(_QWORD *)j)
      {
        v11 = *(unsigned int *)(j + 8);
        v12 = *(unsigned int *)(j + 16);
        if ((v11 - 1) / v12 >= v9)
        {
          *(_DWORD *)(j + 20) = v12 * v9;
          _cg_jpeg_open_backing_store(v1, (size_t (**)(uint64_t *, uint64_t, void *, uint64_t, size_t))(j + 56));
          *(_DWORD *)(j + 44) = 1;
          LODWORD(v11) = *(_DWORD *)(j + 20);
        }
        else
        {
          *(_DWORD *)(j + 20) = v11;
        }
        result = alloc_sarray(v1, 1u, *(_DWORD *)(j + 12), v11);
        *(_QWORD *)j = result;
        *(_QWORD *)(j + 24) = *(unsigned int *)(v2 + 160);
        *(_DWORD *)(j + 32) = 0;
        *(_DWORD *)(j + 40) = 0;
      }
    }
    for (k = *(_QWORD *)(v2 + 144); k; k = *(_QWORD *)(k + 48))
    {
      if (!*(_QWORD *)k)
      {
        v14 = *(unsigned int *)(k + 8);
        v15 = *(unsigned int *)(k + 16);
        if ((v14 - 1) / v15 >= v9)
        {
          *(_DWORD *)(k + 20) = v15 * v9;
          _cg_jpeg_open_backing_store(v1, (size_t (**)(uint64_t *, uint64_t, void *, uint64_t, size_t))(k + 56));
          *(_DWORD *)(k + 44) = 1;
          LODWORD(v14) = *(_DWORD *)(k + 20);
        }
        else
        {
          *(_DWORD *)(k + 20) = v14;
        }
        result = alloc_barray(v1, 1u, *(_DWORD *)(k + 12), v14);
        *(_QWORD *)k = result;
        *(_QWORD *)(k + 24) = *(unsigned int *)(v2 + 160);
        *(_DWORD *)(k + 32) = 0;
        *(_DWORD *)(k + 40) = 0;
      }
    }
  }
  return result;
}

uint64_t access_virt_sarray(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  size_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v22;

  v10 = a4 + a3;
  if (v10 > *(_DWORD *)(a2 + 8) || *(_DWORD *)(a2 + 16) < a4 || !*(_QWORD *)a2)
  {
    v11 = *a1;
    *(_DWORD *)(v11 + 40) = 23;
    (*(void (**)(uint64_t *))v11)(a1);
  }
  v12 = *(_DWORD *)(a2 + 28);
  if (v12 > a3 || v10 > *(_DWORD *)(a2 + 20) + v12)
  {
    if (!*(_DWORD *)(a2 + 44))
    {
      v13 = *a1;
      *(_DWORD *)(v13 + 40) = 71;
      (*(void (**)(uint64_t *))v13)(a1);
    }
    if (*(_DWORD *)(a2 + 40))
    {
      do_sarray_io((uint64_t)a1, a2, 1);
      *(_DWORD *)(a2 + 40) = 0;
    }
    v14 = a3;
    if (*(_DWORD *)(a2 + 28) >= a3)
      v14 = (v10 - *(_DWORD *)(a2 + 20)) & ~((v10 - *(unsigned int *)(a2 + 20)) >> 63);
    *(_DWORD *)(a2 + 28) = v14;
    do_sarray_io((uint64_t)a1, a2, 0);
  }
  v15 = *(_DWORD *)(a2 + 32);
  if (v15 < v10)
  {
    if (v15 >= a3)
    {
      if (a5)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v10;
        if (!*(_DWORD *)(a2 + 36))
          goto LABEL_26;
        goto LABEL_22;
      }
      if (*(_DWORD *)(a2 + 36))
      {
LABEL_22:
        v17 = *(_DWORD *)(a2 + 28);
        if (v15 - v17 < (int)v10 - v17)
        {
          v18 = *(unsigned int *)(a2 + 12);
          v19 = 8 * (v15 - v17);
          v20 = a4 + a3 - v15;
          do
          {
            bzero(*(void **)(*(_QWORD *)a2 + v19), v18);
            v19 += 8;
            --v20;
          }
          while (v20);
        }
        goto LABEL_25;
      }
    }
    else
    {
      if (a5)
      {
        v16 = *a1;
        *(_DWORD *)(v16 + 40) = 23;
        (*(void (**)(uint64_t *))v16)(a1);
        v15 = a3;
        goto LABEL_19;
      }
      v15 = a3;
      if (*(_DWORD *)(a2 + 36))
        goto LABEL_22;
    }
    v22 = *a1;
    *(_DWORD *)(v22 + 40) = 23;
    (*(void (**)(uint64_t *))v22)(a1);
    return *(_QWORD *)a2 + 8 * (a3 - *(_DWORD *)(a2 + 28));
  }
LABEL_25:
  if (a5)
LABEL_26:
    *(_DWORD *)(a2 + 40) = 1;
  return *(_QWORD *)a2 + 8 * (a3 - *(_DWORD *)(a2 + 28));
}

uint64_t access_virt_barray(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  size_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v22;

  v10 = a4 + a3;
  if (v10 > *(_DWORD *)(a2 + 8) || *(_DWORD *)(a2 + 16) < a4 || !*(_QWORD *)a2)
  {
    v11 = *a1;
    *(_DWORD *)(v11 + 40) = 23;
    (*(void (**)(uint64_t *))v11)(a1);
  }
  v12 = *(_DWORD *)(a2 + 28);
  if (v12 > a3 || v10 > *(_DWORD *)(a2 + 20) + v12)
  {
    if (!*(_DWORD *)(a2 + 44))
    {
      v13 = *a1;
      *(_DWORD *)(v13 + 40) = 71;
      (*(void (**)(uint64_t *))v13)(a1);
    }
    if (*(_DWORD *)(a2 + 40))
    {
      do_barray_io((uint64_t)a1, a2, 1);
      *(_DWORD *)(a2 + 40) = 0;
    }
    v14 = a3;
    if (*(_DWORD *)(a2 + 28) >= a3)
      v14 = (v10 - *(_DWORD *)(a2 + 20)) & ~((v10 - *(unsigned int *)(a2 + 20)) >> 63);
    *(_DWORD *)(a2 + 28) = v14;
    do_barray_io((uint64_t)a1, a2, 0);
  }
  v15 = *(_DWORD *)(a2 + 32);
  if (v15 < v10)
  {
    if (v15 >= a3)
    {
      if (a5)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v10;
        if (!*(_DWORD *)(a2 + 36))
          goto LABEL_26;
        goto LABEL_22;
      }
      if (*(_DWORD *)(a2 + 36))
      {
LABEL_22:
        v17 = *(_DWORD *)(a2 + 28);
        if (v15 - v17 < (int)v10 - v17)
        {
          v18 = (unint64_t)*(unsigned int *)(a2 + 12) << 7;
          v19 = 8 * (v15 - v17);
          v20 = a4 + a3 - v15;
          do
          {
            bzero(*(void **)(*(_QWORD *)a2 + v19), v18);
            v19 += 8;
            --v20;
          }
          while (v20);
        }
        goto LABEL_25;
      }
    }
    else
    {
      if (a5)
      {
        v16 = *a1;
        *(_DWORD *)(v16 + 40) = 23;
        (*(void (**)(uint64_t *))v16)(a1);
        v15 = a3;
        goto LABEL_19;
      }
      v15 = a3;
      if (*(_DWORD *)(a2 + 36))
        goto LABEL_22;
    }
    v22 = *a1;
    *(_DWORD *)(v22 + 40) = 23;
    (*(void (**)(uint64_t *))v22)(a1);
    return *(_QWORD *)a2 + 8 * (a3 - *(_DWORD *)(a2 + 28));
  }
LABEL_25:
  if (a5)
LABEL_26:
    *(_DWORD *)(a2 + 40) = 1;
  return *(_QWORD *)a2 + 8 * (a3 - *(_DWORD *)(a2 + 28));
}

void free_pool(_QWORD *a1, signed int a2)
{
  _QWORD *v4;
  void (**v5)(_QWORD);
  uint64_t i;
  uint64_t j;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;

  v4 = (_QWORD *)a1[1];
  if (a2 < 2)
  {
    if (a2 == 1)
    {
      for (i = v4[17]; i; i = *(_QWORD *)(i + 48))
      {
        if (*(_DWORD *)(i + 44))
        {
          *(_DWORD *)(i + 44) = 0;
          (*(void (**)(_QWORD *, uint64_t))(i + 72))(a1, i + 56);
        }
      }
      v4[17] = 0;
      for (j = v4[18]; j; j = *(_QWORD *)(j + 48))
      {
        if (*(_DWORD *)(j + 44))
        {
          *(_DWORD *)(j + 44) = 0;
          (*(void (**)(_QWORD *, uint64_t))(j + 72))(a1, j + 56);
        }
      }
      v4[18] = 0;
    }
  }
  else
  {
    v5 = (void (**)(_QWORD))*a1;
    *((_DWORD *)v5 + 10) = 15;
    *((_DWORD *)v5 + 12) = a2;
    (*(void (**)(_QWORD *))*a1)(a1);
  }
  v8 = a2;
  v9 = &v4[a2];
  v10 = (_QWORD *)v9[15];
  v9[15] = 0;
  if (v10)
  {
    do
    {
      v11 = (_QWORD *)*v10;
      v12 = v10[1] + v10[2] + 24;
      _cg_jpeg_free_small((int)a1, v10);
      v4[19] -= v12;
      v10 = v11;
    }
    while (v11);
  }
  v13 = &v4[v8];
  v14 = (_QWORD *)v13[13];
  v13[13] = 0;
  if (v14)
  {
    do
    {
      v15 = (_QWORD *)*v14;
      v16 = v14[1] + v14[2] + 24;
      _cg_jpeg_free_small((int)a1, v14);
      v4[19] -= v16;
      v14 = v15;
    }
    while (v15);
  }
}

__n128 self_destruct(uint64_t a1)
{
  signed int i;
  uint64_t v3;
  const char *v4;

  for (i = 1; i != -1; --i)
    free_pool((_QWORD *)a1, i);
  _cg_jpeg_free_small(a1, *(void **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  return _cg_jpeg_mem_term(a1, v3, v4);
}

uint64_t do_sarray_io(uint64_t result, uint64_t a2, int a3)
{
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = *(unsigned int *)(a2 + 20);
  if ((_DWORD)v3)
  {
    v5 = result;
    v6 = 0;
    v7 = *(unsigned int *)(a2 + 12);
    v8 = *(unsigned int *)(a2 + 24);
    v9 = *(unsigned int *)(a2 + 28) * (unint64_t)v7;
    v10 = a2 + 56;
    if (a3)
      v11 = 64;
    else
      v11 = 56;
    do
    {
      v12 = v3 - v6;
      if (v12 >= v8)
        v12 = v8;
      v13 = v6 + *(unsigned int *)(a2 + 28);
      if (v12 >= (uint64_t)(*(unsigned int *)(a2 + 32) - v13))
        v12 = *(unsigned int *)(a2 + 32) - v13;
      v14 = *(unsigned int *)(a2 + 8) - v13;
      if (v12 >= v14)
        v12 = v14;
      if (v12 < 1)
        break;
      v15 = v12 * v7;
      result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unint64_t, uint64_t))(a2 + v11))(v5, v10, *(_QWORD *)(*(_QWORD *)a2 + 8 * v6), v9, v12 * v7);
      v9 += v15;
      v3 = *(unsigned int *)(a2 + 20);
      v8 = *(unsigned int *)(a2 + 24);
      v6 += v8;
    }
    while (v6 < v3);
  }
  return result;
}

uint64_t do_barray_io(uint64_t result, uint64_t a2, int a3)
{
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;

  v3 = *(unsigned int *)(a2 + 20);
  if ((_DWORD)v3)
  {
    v5 = result;
    v6 = 0;
    v7 = (unint64_t)*(unsigned int *)(a2 + 12) << 7;
    v8 = *(unsigned int *)(a2 + 24);
    v9 = v7 * *(unsigned int *)(a2 + 28);
    v10 = a2 + 56;
    if (a3)
      v11 = 64;
    else
      v11 = 56;
    do
    {
      v12 = v3 - v6;
      if (v12 >= v8)
        v12 = v8;
      v13 = v6 + *(unsigned int *)(a2 + 28);
      if (v12 >= (uint64_t)(*(unsigned int *)(a2 + 32) - v13))
        v12 = *(unsigned int *)(a2 + 32) - v13;
      v14 = *(unsigned int *)(a2 + 8) - v13;
      if (v12 >= v14)
        v12 = v14;
      if (v12 < 1)
        break;
      v15 = v12 * v7;
      result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unint64_t, unint64_t))(a2 + v11))(v5, v10, *(_QWORD *)(*(_QWORD *)a2 + 8 * v6), v9, v12 * v7);
      v9 += v15;
      v3 = *(unsigned int *)(a2 + 20);
      v8 = *(unsigned int *)(a2 + 24);
      v6 += v8;
    }
    while (v6 < v3);
  }
  return result;
}

uint64_t (**_cg_jinit_forward_dct(uint64_t a1))(uint64_t result)
{
  uint64_t (**result)(uint64_t);
  int v3;
  uint64_t (***v4)(uint64_t);

  result = (uint64_t (**)(uint64_t))(**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 552) = result;
  *result = start_pass_fdctmgr;
  if (*(int *)(a1 + 92) >= 1)
  {
    v3 = 0;
    v4 = (uint64_t (***)(uint64_t))(*(_QWORD *)(a1 + 104) + 88);
    do
    {
      result = (uint64_t (**)(uint64_t))(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 256);
      *v4 = result;
      v4 += 12;
      ++v3;
    }
    while (v3 < *(_DWORD *)(a1 + 92));
  }
  return result;
}

uint64_t start_pass_fdctmgr(uint64_t result)
{
  int *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  int v14;
  int v15;
  uint64_t v16;
  void *v17;
  int v18;
  uint64_t v19;
  uint64_t (**v20)(int *);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  uint64_t v29;
  double v30;
  uint16x8_t v31;
  uint32x4_t v32;
  uint64x2_t v33;
  float64x2_t v34;
  uint64x2_t v35;
  uint32x4_t v36;
  float64x2_t v37;
  float32x4_t *v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  uint64_t (**v45)(int *);
  float64x2_t v46;
  uint64_t v47;

  if (*(int *)(result + 92) >= 1)
  {
    v1 = (int *)result;
    v2 = 0;
    v3 = 0;
    v47 = *(_QWORD *)(result + 552);
    v4 = *(_QWORD *)(result + 104);
    v6 = (float64x2_t)xmmword_18820DC20;
    v5 = (float64x2_t)unk_18820DC30;
    v8 = (float64x2_t)start_pass_fdctmgr_aanscalefactor;
    v7 = (float64x2_t)unk_18820DC10;
    __asm { FMOV            V18.2D, #1.0 }
    v46 = _Q18;
    while (1)
    {
      v14 = *(_DWORD *)(v4 + 36);
      v15 = *(_DWORD *)(v4 + 40) + (v14 << 8);
      if (v15 <= 1805)
      {
        if (v15 > 1027)
        {
          if (v15 > 1538)
          {
            if (v15 > 1547)
            {
              if (v15 == 1548)
              {
                v3 = 0;
                v16 = v47 + 8 * v2;
                v17 = jpeg_fdct_6x12;
                goto LABEL_85;
              }
              if (v15 == 1799)
              {
                v3 = 0;
                v16 = v47 + 8 * v2;
                v17 = jpeg_fdct_7x7;
                goto LABEL_85;
              }
            }
            else
            {
              if (v15 == 1539)
              {
                v3 = 0;
                v16 = v47 + 8 * v2;
                v17 = jpeg_fdct_6x3;
                goto LABEL_85;
              }
              if (v15 == 1542)
              {
                v3 = 0;
                v16 = v47 + 8 * v2;
                v17 = jpeg_fdct_6x6;
                goto LABEL_85;
              }
            }
          }
          else if (v15 > 1284)
          {
            if (v15 == 1285)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_5x5;
              goto LABEL_85;
            }
            if (v15 == 1290)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_5x10;
              goto LABEL_85;
            }
          }
          else
          {
            if (v15 == 1028)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_4x4;
              goto LABEL_85;
            }
            if (v15 == 1032)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_4x8;
              goto LABEL_85;
            }
          }
        }
        else if (v15 > 515)
        {
          if (v15 > 773)
          {
            if (v15 == 774)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_3x6;
              goto LABEL_85;
            }
            if (v15 == 1026)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_4x2;
              goto LABEL_85;
            }
          }
          else
          {
            if (v15 == 516)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_2x4;
              goto LABEL_85;
            }
            if (v15 == 771)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_3x3;
              goto LABEL_85;
            }
          }
        }
        else if (v15 > 512)
        {
          if (v15 == 513)
          {
            v3 = 0;
            v16 = v47 + 8 * v2;
            v17 = jpeg_fdct_2x1;
            goto LABEL_85;
          }
          if (v15 == 514)
          {
            v3 = 0;
            v16 = v47 + 8 * v2;
            v17 = jpeg_fdct_2x2;
            goto LABEL_85;
          }
        }
        else
        {
          if (v15 == 257)
          {
            v3 = 0;
            v16 = v47 + 8 * v2;
            v17 = jpeg_fdct_1x1;
            goto LABEL_85;
          }
          if (v15 == 258)
          {
            v3 = 0;
            v16 = v47 + 8 * v2;
            v17 = jpeg_fdct_1x2;
LABEL_85:
            *(_QWORD *)(v16 + 88) = v17;
            goto LABEL_86;
          }
        }
        goto LABEL_110;
      }
      if (v15 > 3077)
      {
        if (v15 > 3597)
        {
          if (v15 > 4103)
          {
            if (v15 == 4104)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_16x8;
              goto LABEL_85;
            }
            if (v15 == 4112)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_16x16;
              goto LABEL_85;
            }
          }
          else
          {
            if (v15 == 3598)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_14x14;
              goto LABEL_85;
            }
            if (v15 == 3855)
            {
              v3 = 0;
              v16 = v47 + 8 * v2;
              v17 = jpeg_fdct_15x15;
              goto LABEL_85;
            }
          }
        }
        else if (v15 > 3340)
        {
          if (v15 == 3341)
          {
            v3 = 0;
            v16 = v47 + 8 * v2;
            v17 = jpeg_fdct_13x13;
            goto LABEL_85;
          }
          if (v15 == 3591)
          {
            v3 = 0;
            v16 = v47 + 8 * v2;
            v17 = jpeg_fdct_14x7;
            goto LABEL_85;
          }
        }
        else
        {
          if (v15 == 3078)
          {
            v3 = 0;
            v16 = v47 + 8 * v2;
            v17 = jpeg_fdct_12x6;
            goto LABEL_85;
          }
          if (v15 == 3084)
          {
            v3 = 0;
            v16 = v47 + 8 * v2;
            v17 = jpeg_fdct_12x12;
            goto LABEL_85;
          }
        }
        goto LABEL_110;
      }
      if (v15 > 2312)
        break;
      if (v15 <= 2055)
      {
        if (v15 == 1806)
        {
          v3 = 0;
          v16 = v47 + 8 * v2;
          v17 = jpeg_fdct_7x14;
          goto LABEL_85;
        }
        if (v15 == 2052)
        {
          v3 = 0;
          v16 = v47 + 8 * v2;
          v17 = jpeg_fdct_8x4;
          goto LABEL_85;
        }
        goto LABEL_110;
      }
      if (v15 != 2056)
      {
        if (v15 == 2064)
        {
          v3 = 0;
          v16 = v47 + 8 * v2;
          v17 = jpeg_fdct_8x16;
          goto LABEL_85;
        }
LABEL_110:
        v44 = *(_QWORD *)v1;
        *(_DWORD *)(v44 + 40) = 7;
        *(_DWORD *)(v44 + 48) = v14;
        *(_DWORD *)(*(_QWORD *)v1 + 52) = *(_DWORD *)(v4 + 40);
        v45 = *(uint64_t (***)(int *))v1;
        goto LABEL_114;
      }
      v18 = v1[78];
      switch(v18)
      {
        case 2:
          *(_QWORD *)(v47 + 8 * v2 + 168) = _cg_jpeg_fdct_float;
          v3 = 2;
          goto LABEL_86;
        case 1:
          *(_QWORD *)(v47 + 8 * v2 + 88) = _cg_jpeg_fdct_ifast;
          v3 = 1;
          goto LABEL_86;
        case 0:
          v3 = 0;
          v16 = v47 + 8 * v2;
          v17 = _cg_jpeg_fdct_islow;
          goto LABEL_85;
      }
      v45 = *(uint64_t (***)(int *))v1;
      *(_DWORD *)(*(_QWORD *)v1 + 40) = 49;
LABEL_114:
      result = (*v45)(v1);
      _Q18 = v46;
      v8 = (float64x2_t)start_pass_fdctmgr_aanscalefactor;
      v7 = (float64x2_t)unk_18820DC10;
      v6 = (float64x2_t)xmmword_18820DC20;
      v5 = (float64x2_t)unk_18820DC30;
LABEL_86:
      v19 = *(unsigned int *)(v4 + 16);
      if (v19 > 3 || !*(_QWORD *)&v1[2 * v19 + 28])
      {
        v20 = *(uint64_t (***)(int *))v1;
        *((_DWORD *)v20 + 10) = 54;
        *((_DWORD *)v20 + 12) = v19;
        result = (**(uint64_t (***)(int *))v1)(v1);
        _Q18 = v46;
        v8 = (float64x2_t)start_pass_fdctmgr_aanscalefactor;
        v7 = (float64x2_t)unk_18820DC10;
        v6 = (float64x2_t)xmmword_18820DC20;
        v5 = (float64x2_t)unk_18820DC30;
      }
      v21 = *(_QWORD *)&v1[2 * (int)v19 + 28];
      if (v3 == 2)
      {
        v25 = 0;
        v26 = 0;
        v27 = *(_QWORD *)(v4 + 88);
        if (*(_DWORD *)(v4 + 52))
          v28 = 16.0;
        else
          v28 = 8.0;
        do
        {
          v29 = v26 << 32;
          v30 = *(double *)((char *)&start_pass_fdctmgr_aanscalefactor + v25);
          v31 = *(uint16x8_t *)(v21 + 2 * (int)v26);
          v32 = vmovl_high_u16(v31);
          v33.i64[0] = v32.u32[2];
          v33.i64[1] = v32.u32[3];
          v34 = vcvtq_f64_u64(v33);
          v33.i64[0] = v32.u32[0];
          v33.i64[1] = v32.u32[1];
          v35 = v33;
          v36 = vmovl_u16(*(uint16x4_t *)v31.i8);
          v33.i64[0] = v36.u32[2];
          v33.i64[1] = v36.u32[3];
          v37 = vcvtq_f64_u64(v33);
          v33.i64[0] = v36.u32[0];
          v33.i64[1] = v36.u32[1];
          v26 = (int)v26 + 8;
          v38 = (float32x4_t *)(v27 + (v29 >> 30));
          *v38 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(_Q18, vmulq_n_f64(vmulq_f64(vmulq_n_f64(vcvtq_f64_u64(v33), v30), v8), v28))), vdivq_f64(_Q18, vmulq_n_f64(vmulq_f64(vmulq_n_f64(v37, v30), v7), v28)));
          v38[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(_Q18, vmulq_n_f64(vmulq_f64(vmulq_n_f64(vcvtq_f64_u64(v35), v30), v6), v28))), vdivq_f64(_Q18, vmulq_n_f64(vmulq_f64(vmulq_n_f64(v34, v30), v5), v28)));
          v25 += 8;
        }
        while (v25 != 64);
        v39 = v47 + 8 * v2;
        v40 = forward_DCT_float;
      }
      else
      {
        if (v3 == 1)
        {
          v41 = 0;
          v42 = *(_QWORD *)(v4 + 88);
          do
          {
            if (*(_DWORD *)(v4 + 52))
              v43 = 10;
            else
              v43 = 11;
            *(_DWORD *)(v42 + 4 * v41) = (uint64_t)((1 << (v43 - 1))
                                                 + start_pass_fdctmgr_aanscales[v41]
                                                 * (unint64_t)*(unsigned __int16 *)(v21 + 2 * v41)) >> v43;
            ++v41;
          }
          while (v41 != 64);
        }
        else
        {
          v22 = 0;
          v23 = *(_QWORD *)(v4 + 88);
          do
          {
            if (*(_DWORD *)(v4 + 52))
              v24 = 4;
            else
              v24 = 3;
            *(_DWORD *)(v23 + 4 * v22) = *(unsigned __int16 *)(v21 + 2 * v22) << v24;
            ++v22;
          }
          while (v22 != 64);
        }
        v39 = v47 + 8 * v2;
        v40 = forward_DCT;
      }
      *(_QWORD *)(v39 + 8) = v40;
      ++v2;
      v4 += 96;
      if (v2 >= v1[23])
        return result;
    }
    if (v15 > 2569)
    {
      if (v15 == 2570)
      {
        v3 = 0;
        v16 = v47 + 8 * v2;
        v17 = jpeg_fdct_10x10;
        goto LABEL_85;
      }
      if (v15 == 2827)
      {
        v3 = 0;
        v16 = v47 + 8 * v2;
        v17 = jpeg_fdct_11x11;
        goto LABEL_85;
      }
    }
    else
    {
      if (v15 == 2313)
      {
        v3 = 0;
        v16 = v47 + 8 * v2;
        v17 = jpeg_fdct_9x9;
        goto LABEL_85;
      }
      if (v15 == 2565)
      {
        v3 = 0;
        v16 = v47 + 8 * v2;
        v17 = jpeg_fdct_10x5;
        goto LABEL_85;
      }
    }
    goto LABEL_110;
  }
  return result;
}

uint64_t forward_DCT(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int a7)
{
  uint64_t v10;
  uint64_t (*v11)(_OWORD *, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  _OWORD v23[16];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a7)
  {
    v10 = 0;
    v11 = *(uint64_t (**)(_OWORD *, uint64_t, uint64_t))(*(_QWORD *)(result + 552) + 8 * *(int *)(a2 + 4) + 88);
    v12 = *(_QWORD *)(a2 + 88);
    v13 = a3 + 8 * a5;
    v14 = a7;
    memset(v23, 0, sizeof(v23));
    do
    {
      result = v11(v23, v13, a6);
      for (i = 0; i != 64; ++i)
      {
        v16 = *(_DWORD *)(v12 + 4 * i);
        v17 = *((_DWORD *)v23 + i);
        v18 = v16 >> 1;
        if (v17 < 0)
        {
          v21 = v18 - v17;
          if (v21 >= v16)
            v22 = v21 / v16;
          else
            v22 = 0;
          v20 = -v22;
        }
        else
        {
          v19 = v17 + v18;
          if (v19 >= v16)
            v20 = v19 / v16;
          else
            LOWORD(v20) = 0;
        }
        *(_WORD *)(a4 + 2 * i) = v20;
      }
      ++v10;
      a6 = (*(_DWORD *)(a2 + 36) + a6);
      a4 += 128;
    }
    while (v10 != v14);
  }
  return result;
}

uint64_t forward_DCT_float(uint64_t result, uint64_t a2, uint64_t a3, int16x8_t *a4, unsigned int a5, uint64_t a6, unsigned int a7)
{
  uint64_t v10;
  uint64_t (*v11)(_OWORD *, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int16x8_t v15;
  uint64_t v16;
  int16x8_t *v17;
  float32x4_t v18;
  _OWORD v19[16];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a7)
  {
    v10 = 0;
    v11 = *(uint64_t (**)(_OWORD *, uint64_t, uint64_t))(*(_QWORD *)(result + 552) + 8 * *(int *)(a2 + 4) + 168);
    v12 = a3 + 8 * a5;
    memset(v19, 0, sizeof(v19));
    v13 = a7;
    v14 = *(_QWORD *)(a2 + 88);
    v18 = (float32x4_t)vdupq_n_s32(0x46800100u);
    do
    {
      result = v11(v19, v12, a6);
      v15.i64[0] = 0xC000C000C000C000;
      v15.i64[1] = 0xC000C000C000C000;
      v16 = 0;
      v17 = a4;
      do
      {
        *v17++ = vaddq_s16(vuzp1q_s16((int16x8_t)vcvtq_s32_f32(vaddq_f32(vmulq_f32((float32x4_t)v19[v16], *(float32x4_t *)(v14 + v16 * 16)), v18)), (int16x8_t)vcvtq_s32_f32(vaddq_f32(vmulq_f32((float32x4_t)v19[v16 + 1], *(float32x4_t *)(v14 + v16 * 16 + 16)), v18))), v15);
        v16 += 2;
      }
      while (v16 != 16);
      ++v10;
      a6 = (*(_DWORD *)(a2 + 36) + a6);
      a4 += 8;
    }
    while (v10 != v13);
  }
  return result;
}

uint64_t _cg_jinit_1pass_quantizer(uint64_t a1)
{
  void (**v2)(uint64_t);
  void (**v3)(_QWORD);
  int v4;
  void (**v5)(_QWORD);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  void (**v13)(_QWORD);
  uint64_t v14;
  uint64_t v15;
  uint64x2_t v16;
  int32x2_t v17;
  int64x2_t v18;
  unsigned int *v19;
  int8x8_t v20;
  int64x2_t v21;
  int8x8_t v22;
  int8x8_t v23;
  int8x8_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  char v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  char v33;
  _DWORD *v34;
  int v35;
  void (**v36)(_QWORD);
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t i;
  uint64_t result;

  v2 = (void (**)(uint64_t))(**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 656) = v2;
  *v2 = start_pass_1_quant;
  v2[2] = (void (*)(uint64_t))finish_pass_1_quant;
  v2[3] = (void (*)(uint64_t))new_color_map_1_quant;
  v2[14] = 0;
  v2[10] = 0;
  if (*(int *)(a1 + 144) >= 5)
  {
    v3 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v3 + 10) = 57;
    *((_DWORD *)v3 + 12) = 4;
    (**(void (***)(uint64_t))a1)(a1);
  }
  v4 = *(_DWORD *)(a1 + 120);
  if (v4 >= 257)
  {
    v5 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v5 + 10) = 59;
    *((_DWORD *)v5 + 12) = 256;
    (**(void (***)(uint64_t))a1)(a1);
    v4 = *(_DWORD *)(a1 + 120);
  }
  v6 = *(_QWORD *)(a1 + 656);
  v7 = *(unsigned int *)(a1 + 144);
  v8 = v4;
  v9 = 1;
  do
  {
    v10 = v9++;
    v11 = v9;
    if ((int)v7 >= 2)
    {
      v12 = v7 - 1;
      v11 = v9;
      do
      {
        v11 *= v9;
        --v12;
      }
      while (v12);
    }
  }
  while (v11 <= v4);
  if (v10 <= 1)
  {
    v13 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v13 + 10) = 58;
    *((_DWORD *)v13 + 12) = v11;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if ((int)v7 < 1)
  {
    v25 = 1;
  }
  else
  {
    v14 = v6 + 60;
    v15 = (v7 + 1) & 0x1FFFFFFFELL;
    v16 = (uint64x2_t)vdupq_n_s64(v7 - 1);
    v17 = vdup_n_s32(v10);
    v18 = (int64x2_t)xmmword_18820C490;
    v19 = (unsigned int *)(v6 + 64);
    v20 = (int8x8_t)0x100000001;
    v21 = vdupq_n_s64(2uLL);
    do
    {
      v22 = v20;
      v23 = (int8x8_t)vmovn_s64((int64x2_t)vcgeq_u64(v16, (uint64x2_t)v18));
      if ((v23.i8[0] & 1) != 0)
        *(v19 - 1) = v10;
      if ((v23.i8[4] & 1) != 0)
        *v19 = v10;
      v20 = (int8x8_t)vmul_s32((int32x2_t)v20, v17);
      v18 = vaddq_s64(v18, v21);
      v19 += 2;
      v15 -= 2;
    }
    while (v15);
    v24 = vbsl_s8(v23, v20, v22);
    v25 = (v24.i32[0] * v24.i32[1]);
    v26 = 0;
    v27 = *(_DWORD *)(a1 + 64);
    v28 = 1;
    while (1)
    {
      v29 = v26;
      if (v27 == 2)
        v29 = select_ncolors_RGB_order[v26];
      v30 = *(int *)(v14 + 4 * v29);
      v31 = v30 + 1;
      v32 = (int)v25 / (int)v30 * (v30 + 1);
      if (v32 <= v8)
      {
        v28 = 0;
        *(_DWORD *)(v14 + 4 * v29) = v31;
        ++v26;
        v25 = v32;
        if (v26 != v7)
          continue;
      }
      v26 = 0;
      v33 = v28;
      v28 = 1;
      if ((v33 & 1) != 0)
        break;
    }
  }
  v34 = *(_DWORD **)a1;
  if (*(_DWORD *)(a1 + 144) == 3)
  {
    v34[12] = v25;
    v34[13] = *(_DWORD *)(v6 + 60);
    v34[14] = *(_DWORD *)(v6 + 64);
    v34[15] = *(_DWORD *)(v6 + 68);
    v35 = 96;
    v36 = (void (**)(_QWORD))v34;
  }
  else
  {
    v34[12] = v25;
    v36 = *(void (***)(_QWORD))a1;
    v35 = 97;
  }
  v34[10] = v35;
  ((void (*)(uint64_t, uint64_t))v36[1])(a1, 1);
  v37 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v25, *(unsigned int *)(a1 + 144));
  v38 = *(_DWORD *)(a1 + 144);
  if (v38 >= 1)
  {
    v39 = 0;
    v40 = v25;
    do
    {
      v41 = *(unsigned int *)(v6 + 4 * v39 + 60);
      v42 = (v40 / (int)v41);
      if ((int)v41 >= 1)
      {
        v43 = 0;
        v44 = 0;
        do
        {
          if (v43 * (int)v42 < (int)v25)
          {
            v45 = v44;
            do
            {
              if ((int)v42 >= 1)
              {
                for (i = 0; i != v42; ++i)
                  *(_BYTE *)(*(_QWORD *)(v37 + 8 * v39) + v45 + i) = ((unint64_t)((v41 - 1) >> 1)
                                                                    - v43
                                                                    + (v43 << 8))
                                                                   / (v41 - 1);
              }
              v45 += v40;
            }
            while (v45 < (int)v25);
          }
          ++v43;
          v44 += (int)v42;
        }
        while (v43 != v41);
        v38 = *(_DWORD *)(a1 + 144);
      }
      ++v39;
      v40 /= (int)v41;
    }
    while (v39 < v38);
  }
  *(_QWORD *)(v6 + 32) = v37;
  *(_DWORD *)(v6 + 40) = v25;
  result = create_colorindex(a1);
  if (*(_DWORD *)(a1 + 112) == 2)
    return alloc_fs_workspace(a1);
  return result;
}

void start_pass_1_quant(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, int);
  uint64_t v5;
  size_t v6;
  uint64_t v7;
  void *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;

  v2 = *(_QWORD *)(a1 + 656);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(v2 + 32);
  *(_DWORD *)(a1 + 156) = *(_DWORD *)(v2 + 40);
  v3 = *(_DWORD *)(a1 + 112);
  if (v3 == 2)
  {
    *(_QWORD *)(v2 + 8) = quantize_fs_dither;
    *(_DWORD *)(v2 + 144) = 0;
    if (!*(_QWORD *)(v2 + 112))
      alloc_fs_workspace(a1);
    if (*(int *)(a1 + 144) >= 1)
    {
      v5 = 0;
      v6 = 2 * (*(_DWORD *)(a1 + 136) + 2);
      v7 = v2 + 112;
      do
        bzero(*(void **)(v7 + 8 * v5++), v6);
      while (v5 < *(int *)(a1 + 144));
    }
  }
  else if (v3 == 1)
  {
    v8 = quantize_ord_dither;
    if (*(_DWORD *)(a1 + 144) == 3)
      v8 = quantize3_ord_dither;
    *(_QWORD *)(v2 + 8) = v8;
    *(_DWORD *)(v2 + 76) = 0;
    if (!*(_DWORD *)(v2 + 56))
      create_colorindex(a1);
    if (!*(_QWORD *)(v2 + 80))
    {
      v9 = *(_DWORD *)(a1 + 144);
      if (v9 >= 1)
      {
        v10 = 0;
        v11 = *(_QWORD *)(a1 + 656);
        v12 = v11 + 60;
        do
        {
          v13 = *(_DWORD *)(v11 + 4 * v10 + 60);
          if (!v10)
            goto LABEL_25;
          v14 = 0;
          while (v13 != *(_DWORD *)(v12 + 4 * v14))
          {
            if (v10 == ++v14)
              goto LABEL_25;
          }
          v15 = *(_QWORD *)(v12 + 8 * v14 + 20);
          if (!v15)
          {
LABEL_25:
            v15 = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
            v16 = 0;
            v17 = (unsigned __int8 *)&base_dither_matrix;
            v18 = v15;
            do
            {
              for (i = 0; i != 16; ++i)
                *(_DWORD *)(v18 + 4 * i) = 255 * (255 - 2 * v17[i]) / ((uint64_t)(v13 - 1) << 9);
              ++v16;
              v18 += 64;
              v17 += 16;
            }
            while (v16 != 16);
            v9 = *(_DWORD *)(a1 + 144);
          }
          *(_QWORD *)(v11 + 8 * v10++ + 80) = v15;
        }
        while (v10 < v9);
      }
    }
  }
  else if (v3)
  {
    v20 = *(_QWORD *)a1;
    *(_DWORD *)(v20 + 40) = 49;
    (*(void (**)(uint64_t))v20)(a1);
  }
  else
  {
    if (*(_DWORD *)(a1 + 144) == 3)
      v4 = color_quantize3;
    else
      v4 = color_quantize;
    *(_QWORD *)(v2 + 8) = v4;
  }
}

uint64_t new_color_map_1_quant(uint64_t *a1)
{
  uint64_t v1;

  v1 = *a1;
  *(_DWORD *)(v1 + 40) = 47;
  return (*(uint64_t (**)(uint64_t *))v1)(a1);
}

uint64_t create_colorindex(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  char v18;
  _BYTE *v19;

  v2 = *(_QWORD *)(a1 + 656);
  v3 = *(_DWORD *)(a1 + 112);
  if (v3 == 1)
    v4 = 766;
  else
    v4 = 256;
  *(_DWORD *)(v2 + 56) = v3 == 1;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v4, *(unsigned int *)(a1 + 144));
  *(_QWORD *)(v2 + 48) = result;
  if (*(int *)(a1 + 144) >= 1)
  {
    v6 = 0;
    v7 = *(_DWORD *)(v2 + 40);
    do
    {
      v8 = *(int *)(v2 + 4 * v6 + 60);
      v9 = *(_QWORD *)(v2 + 48);
      if (v3 == 1)
      {
        *(_QWORD *)(v9 + 8 * v6) += 255;
        v9 = *(_QWORD *)(v2 + 48);
      }
      v10 = 0;
      v11 = 0;
      v12 = *(char **)(v9 + 8 * v6);
      v13 = v8 - 1;
      v14 = 2 * ((int)v8 - 1);
      v15 = (v8 + 254) / v14;
      v7 /= (int)v8;
      do
      {
        if (v10 > (int)v15)
        {
          v16 = 2 * v11 + 3;
          do
          {
            v15 = (v13 - v16 + ((uint64_t)v16 << 8)) / v14;
            ++v11;
            v16 += 2;
          }
          while (v10 > (int)v15);
        }
        v12[v10++] = v11 * v7;
      }
      while (v10 != 256);
      if (v3 == 1)
      {
        v17 = 0;
        v18 = *v12;
        v19 = v12 + 256;
        do
        {
          v12[v17 - 1] = v18;
          *v19++ = v12[255];
          --v17;
        }
        while (v17 != -255);
      }
      ++v6;
    }
    while (v6 < *(int *)(a1 + 144));
  }
  return result;
}

uint64_t alloc_fs_workspace(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (*(int *)(result + 144) >= 1)
  {
    v1 = result;
    v2 = 0;
    v3 = 2 * (*(_DWORD *)(result + 136) + 2);
    v4 = *(_QWORD *)(result + 656) + 112;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v1 + 8) + 8))(v1, 1, v3);
      *(_QWORD *)(v4 + 8 * v2++) = result;
    }
    while (v2 < *(int *)(v1 + 144));
  }
  return result;
}

uint64_t color_quantize3(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _BYTE *v10;
  unsigned __int8 *v11;
  int v12;

  if (a4 >= 1)
  {
    v4 = 0;
    v5 = *(uint64_t **)(*(_QWORD *)(result + 656) + 48);
    v6 = *v5;
    v7 = v5[1];
    v8 = v5[2];
    v9 = *(_DWORD *)(result + 136);
    do
    {
      if (v9)
      {
        v10 = *(_BYTE **)(a3 + 8 * v4);
        v11 = *(unsigned __int8 **)(a2 + 8 * v4);
        v12 = v9;
        do
        {
          result = *(unsigned __int8 *)(v7 + v11[1]);
          *v10++ = result + *(_BYTE *)(v6 + *v11) + *(_BYTE *)(v8 + v11[2]);
          v11 += 3;
          --v12;
        }
        while (v12);
      }
      ++v4;
    }
    while (v4 != a4);
  }
  return result;
}

uint64_t color_quantize(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  unsigned __int8 *v10;
  int v11;
  char v12;
  uint64_t *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;

  if (a4 >= 1)
  {
    v4 = 0;
    v5 = *(uint64_t **)(*(_QWORD *)(result + 656) + 48);
    v6 = *(_DWORD *)(result + 136);
    v7 = *(unsigned int *)(result + 144);
    v8 = a4;
    do
    {
      if (v6)
      {
        v9 = *(_BYTE **)(a3 + 8 * v4);
        v10 = *(unsigned __int8 **)(a2 + 8 * v4);
        v11 = v6;
        do
        {
          if ((int)v7 < 1)
          {
            v12 = 0;
          }
          else
          {
            v12 = 0;
            result = v7;
            v13 = v5;
            v14 = v10;
            do
            {
              v16 = *v13++;
              v15 = v16;
              LODWORD(v16) = *v14++;
              v12 += *(_BYTE *)(v15 + v16);
              --result;
            }
            while (result);
            v10 += (v7 - 1) + 1;
          }
          *v9++ = v12;
          --v11;
        }
        while (v11);
      }
      ++v4;
    }
    while (v4 != v8);
  }
  return result;
}

uint64_t quantize3_ord_dither(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  unsigned __int8 *v17;
  int v18;

  if (a4 >= 1)
  {
    v4 = 0;
    v5 = *(_QWORD *)(result + 656);
    v6 = *(uint64_t **)(v5 + 48);
    v7 = *v6;
    v8 = v6[1];
    v9 = v6[2];
    v10 = *(_DWORD *)(result + 136);
    v11 = a4;
    v12 = *(_DWORD *)(v5 + 76);
    do
    {
      if (v10)
      {
        v13 = 0;
        v14 = *(_QWORD *)(v5 + 80) + ((uint64_t)v12 << 6);
        result = *(_QWORD *)(v5 + 88) + ((uint64_t)v12 << 6);
        v15 = *(_QWORD *)(v5 + 96) + ((uint64_t)v12 << 6);
        v16 = *(_BYTE **)(a3 + 8 * v4);
        v17 = *(unsigned __int8 **)(a2 + 8 * v4);
        v18 = v10;
        do
        {
          *v16++ = *(_BYTE *)(v8 + *(int *)(result + 4 * v13) + (unint64_t)v17[1])
                 + *(_BYTE *)(v7 + *(int *)(v14 + 4 * v13) + (unint64_t)*v17)
                 + *(_BYTE *)(v9 + *(int *)(v15 + 4 * v13) + (unint64_t)v17[2]);
          v13 = ((_BYTE)v13 + 1) & 0xF;
          v17 += 3;
          --v18;
        }
        while (v18);
      }
      v12 = ((_BYTE)v12 + 1) & 0xF;
      *(_DWORD *)(v5 + 76) = v12;
      ++v4;
    }
    while (v4 != v11);
  }
  return result;
}

void quantize_ord_dither(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  int v19;

  if (a4 >= 1)
  {
    v6 = 0;
    v7 = *(_QWORD *)(a1 + 656);
    v8 = *(unsigned int *)(a1 + 136);
    v9 = *(unsigned int *)(a1 + 144);
    v10 = *(_DWORD *)(a1 + 144);
    v11 = a4;
    do
    {
      bzero(*(void **)(a3 + 8 * v6), v8);
      v12 = *(int *)(v7 + 76);
      if (v10 >= 1)
      {
        v13 = 0;
        do
        {
          if ((_DWORD)v8)
          {
            v14 = 0;
            v15 = *(_QWORD *)(*(_QWORD *)(v7 + 48) + 8 * v13);
            v16 = *(_QWORD *)(v7 + 8 * v13 + 80) + (v12 << 6);
            v17 = *(_BYTE **)(a3 + 8 * v6);
            v18 = *(_QWORD *)(a2 + 8 * v6);
            v19 = v8;
            do
            {
              *v17++ += *(_BYTE *)(v15 + *(int *)(v16 + 4 * v14) + (unint64_t)*(unsigned __int8 *)(v18 + v13));
              v14 = ((_BYTE)v14 + 1) & 0xF;
              v18 += (int)v9;
              --v19;
            }
            while (v19);
          }
          ++v13;
        }
        while (v13 != v9);
      }
      *(_DWORD *)(v7 + 76) = ((_BYTE)v12 + 1) & 0xF;
      ++v6;
    }
    while (v6 != v11);
  }
}

void quantize_fs_dither(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  unsigned __int8 *v17;
  _BYTE *v18;
  _WORD *v19;
  uint64_t v20;
  int v21;
  __int16 v22;
  __int16 v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;

  if (a4 >= 1)
  {
    v6 = 0;
    v7 = *(_QWORD *)(a1 + 656);
    v8 = *(unsigned int *)(a1 + 144);
    v9 = *(unsigned int *)(a1 + 136);
    v10 = *(_QWORD *)(a1 + 440);
    v11 = (v9 - 1);
    v12 = (v11 * v8);
    v13 = -(int)v8;
    v31 = a4;
    do
    {
      v14 = v13;
      v15 = v11;
      bzero(*(void **)(a3 + 8 * v6), v9);
      v11 = v15;
      v13 = v14;
      if ((int)v8 >= 1)
      {
        for (i = 0; i != v8; ++i)
        {
          v17 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v6) + i);
          v18 = *(_BYTE **)(a3 + 8 * v6);
          if (*(_DWORD *)(v7 + 144))
          {
            v17 += v12;
            v18 += v11;
            v19 = (_WORD *)(*(_QWORD *)(v7 + 8 * i + 112) + 2 * (v9 + 1));
            v20 = -1;
            v21 = v14;
          }
          else
          {
            v19 = *(_WORD **)(v7 + 8 * i + 112);
            v20 = 1;
            v21 = v8;
          }
          v22 = 0;
          if ((_DWORD)v9)
          {
            v23 = 0;
            v24 = 0;
            v25 = *(_QWORD *)(*(_QWORD *)(v7 + 48) + 8 * i);
            v26 = *(_QWORD *)(*(_QWORD *)(v7 + 32) + 8 * i);
            v27 = v9;
            do
            {
              v28 = *(unsigned __int8 *)(v10 + *v17 + (uint64_t)((v24 + (__int16)v19[v20] + 8) >> 4));
              v29 = *(unsigned __int8 *)(v25 + v28);
              *v18 += v29;
              LODWORD(v29) = v28 - *(unsigned __int8 *)(v26 + v29);
              v30 = 3 * v29 + v22;
              v22 = 5 * v29 + v23;
              v24 = 7 * v29;
              v17 += v21;
              *v19 = v30;
              v18 += v20;
              v19 += v20;
              v23 = v29;
              --v27;
            }
            while (v27);
          }
          *v19 = v22;
        }
      }
      *(_DWORD *)(v7 + 144) = *(_DWORD *)(v7 + 144) == 0;
      ++v6;
    }
    while (v6 != v31);
  }
}

double _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_(__int16 *a1, uint64_t a2, float32x2_t a3, int32x2_t a4)
{
  uint32x4_t v4;
  int32x2_t v5;
  int16x4_t v6;
  int32x2_t v7;
  int16x4_t v8;
  int v9;
  unsigned __int32 v10;
  double result;
  unsigned int v12;

  *(int32x2_t *)v4.i8 = vadd_s32(vcvt_s32_f32(a3), a4);
  v5 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)v4.i8, 0x10uLL), 0x10uLL);
  v6 = (int16x4_t)vshr_n_s32(v5, 0xFuLL);
  if ((vmaxv_u16((uint16x4_t)vuzp1_s16(v6, v6)) & 0x8000) == 0)
  {
    v7.i32[0] = a1[6];
    v7.i32[1] = a1[7];
    v8 = (int16x4_t)vcge_s32(v5, v7);
    v5 = (int32x2_t)vuzp1_s16(v8, v8);
    if ((vmaxv_u16((uint16x4_t)v5) & 0x8000) == 0)
      goto LABEL_6;
  }
  v9 = *(_DWORD *)(a2 + 4);
  if (v9)
  {
    if (v9 == 1)
    {
      v5.i16[0] = a1[6];
      v5.i16[2] = a1[7];
      v10 = vmax_s16((int16x4_t)vuzp1_s16(*(int16x4_t *)v4.i8, *(int16x4_t *)v4.i8).u32[0], 0).u32[0];
      v4 = vmovl_u16((uint16x4_t)vmin_s16((int16x4_t)v10, (int16x4_t)vuzp1_s16((int16x4_t)vadd_s32(v5, (int32x2_t)0xFFFF0000FFFFLL), (int16x4_t)v10).u32[0]));
    }
LABEL_6:
    HIWORD(v12) = v4.i16[2];
    LOWORD(v12) = v4.i16[0];
    (*(void (**)(__int16 *, _QWORD))(*(_QWORD *)a1 + 16))(a1, v12);
    return result;
  }
  return 0.0;
}

double xdr::Texture<unsigned short,float,int>::sampleRead(unsigned __int16 *a1, uint64_t a2, int a3, float a4)
{
  int v4;
  int v5;
  double result;

  v4 = (int)(float)((float)a3 + a4);
  if ((v4 & 0x80000000) == 0 && a1[6] > (unsigned __int16)v4)
  {
LABEL_7:
    (*(void (**)(unsigned __int16 *, _QWORD))(*(_QWORD *)a1 + 16))(a1, (unsigned __int16)v4);
    return result;
  }
  v5 = *(_DWORD *)(a2 + 4);
  if (v5)
  {
    if (v5 == 1)
    {
      v4 &= ~(v4 >> 31);
      if ((__int16)(a1[6] - 1) < v4)
        LOWORD(v4) = a1[6] - 1;
    }
    goto LABEL_7;
  }
  return 0.0;
}

double _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE6sampleERKNS_7SamplerES2_S3_(uint64_t a1, _DWORD *a2, float32x2_t a3, int32x2_t a4)
{
  int8x8_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  double result;
  float32x2_t v20;
  float32x2_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;

  if (!*a2)
  {
    v7.i32[0] = *(unsigned __int16 *)(a1 + 12);
    v7.i32[1] = *(unsigned __int16 *)(a1 + 14);
    a3 = vmul_f32(vadd_f32((float32x2_t)vorr_s8(v7, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), a3);
  }
  if (a2[2] != 1)
    return _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, a3, a4);
  v8 = vadd_f32(vrndm_f32(vadd_f32(a3, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000);
  v9 = vsub_f32(a3, v8);
  __asm { FMOV            V0.2S, #1.0 }
  v20 = vsub_f32(_D0, v9);
  v21 = v9;
  *(double *)v15.i64 = _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, v8, a4);
  v22 = vmlaq_n_f32((float32x4_t)0, v15, vmuls_lane_f32(v20.f32[0], v20, 1));
  *(double *)v16.i64 = _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, v8, vadd_s32(a4, (int32x2_t)0x100000000));
  v23 = vmlaq_n_f32(v22, v16, vmuls_lane_f32(v20.f32[0], v21, 1));
  *(double *)v17.i64 = _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, v8, vadd_s32(a4, (int32x2_t)1));
  v24 = vmlaq_n_f32(v23, v17, vmuls_lane_f32(v21.f32[0], v20, 1));
  *(double *)v18.i64 = _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, v8, vadd_s32(a4, (int32x2_t)0x100000001));
  *(_QWORD *)&result = vmlaq_n_f32(v24, v18, vmuls_lane_f32(v21.f32[0], v21, 1)).u64[0];
  return result;
}

double xdr::Texture<unsigned short,float,int>::sample(unsigned __int16 *a1, _DWORD *a2, int a3, float a4, float a5)
{
  float v8;
  float32x4_t v9;
  float32x4_t v10;
  double result;
  float v12;
  float32x4_t v13;
  float v14;

  if (!*a2)
  {
    LOWORD(a5) = a1[6];
    a4 = (float)LODWORD(a5) * a4;
  }
  if (a2[2] != 1)
    return xdr::Texture<unsigned short,float,int>::sampleRead(a1, (uint64_t)a2, a3, a4);
  v8 = a4 + -0.5;
  v12 = ceilf(a4 + -0.5) - (float)(a4 + -0.5);
  v14 = 1.0 - v12;
  *(double *)v9.i64 = xdr::Texture<unsigned short,float,int>::sampleRead(a1, (uint64_t)a2, a3, a4 + -0.5);
  v13 = vmlaq_n_f32((float32x4_t)0, v9, v12);
  *(double *)v10.i64 = xdr::Texture<unsigned short,float,int>::sampleRead(a1, (uint64_t)a2, a3 + 1, v8);
  *(_QWORD *)&result = vmlaq_n_f32(v13, v10, v14).u64[0];
  return result;
}

uint64_t IIOCallCreatePixelBufferAttributesForHDRType(int a1, void *a2, void *a3, _QWORD *a4)
{
  uint64_t v8;

  kdebug_trace();
  v8 = IIOCreatePixelBufferAttributesForHDRType(a1, a2, a3, a4);
  kdebug_trace();
  return v8;
}

uint64_t IIOCallConvertHDRGainMap(__IOSurface *a1, const void *a2, __IOSurface *a3, uint64_t a4, CGImageMetadata **a5, void *a6)
{
  uint64_t v12;
  const void *v13;
  const void *v14;
  const void *v15;
  uint64_t v16;
  const void *v18;

  kdebug_trace();
  v18 = 0;
  v12 = *MEMORY[0x1E0C9AE00];
  gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E0C9AE00], a1, MEMORY[0x1E0C9AA70], &v18);
  v13 = v18;
  if (v18)
  {
    if (a2)
    {
      v18 = 0;
      gFunc_CVPixelBufferCreateWithIOSurface(v12, a2, MEMORY[0x1E0C9AA70], &v18);
      a2 = v18;
    }
    v18 = 0;
    gFunc_CVPixelBufferCreateWithIOSurface(v12, a3, MEMORY[0x1E0C9AA70], &v18);
    v14 = v18;
    if (v18)
    {
      v18 = 0;
      gFunc_CVPixelBufferCreateWithIOSurface(v12, a4, MEMORY[0x1E0C9AA70], &v18);
      v15 = v18;
      if (v18)
      {
        v16 = IIOConvertHDRGainMap((uint64_t)v13, (uint64_t)a2, (uint64_t)v14, (uint64_t)v18, a5, a6);
        CFRelease(v15);
      }
      else
      {
        v16 = 4294967246;
      }
      CFRelease(v14);
    }
    else
    {
      v16 = 4294967246;
    }
    if (a2)
      CFRelease(a2);
    CFRelease(v13);
    if (!(_DWORD)v16)
    {
      v16 = IIOSurfaceCopyAlphaValuesFromSource(a1, a3);
      IIO_IOSurfaceLogAlphaInfo(a1, "IIOCallConvertHDRGainMap inputSurface:");
      IIO_IOSurfaceLogAlphaInfo(a3, "IIOCallConvertHDRGainMap outputSurface:");
    }
  }
  else
  {
    v16 = 4294967246;
  }
  kdebug_trace();
  return v16;
}

uint64_t IIOCallCreateFlexGTCInfo(uint64_t a1, uint64_t a2, id *a3, void *a4)
{
  const void *v8;
  uint64_t FlexGTCInfo;
  const void *v11;

  kdebug_trace();
  if (a3
    && (v11 = 0,
        gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E0C9AE00], a1, MEMORY[0x1E0C9AA70], &v11),
        (v8 = v11) != 0))
  {
    if (a2)
      FlexGTCInfo = CGImageCreateFlexGTCInfo((uint64_t)v11, a2, a3, a4);
    else
      FlexGTCInfo = 4294967246;
    CFRelease(v8);
  }
  else
  {
    FlexGTCInfo = 4294967246;
  }
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(*a3, "objectForKeyedSubscript:", CFSTR("com.apple.ColorSync.MonoGainMapParams")), "objectForKeyedSubscript:", CFSTR("com.apple.ColorSync.GainMapBaselineHeadroom")), "floatValue");
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a4, "objectForKeyedSubscript:", CFSTR("{MakerApple}")), "objectForKeyedSubscript:", CFSTR("33")), "floatValue");
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a4, "objectForKeyedSubscript:", CFSTR("{MakerApple}")), "objectForKeyedSubscript:", CFSTR("48")), "floatValue");
  kdebug_trace();
  return FlexGTCInfo;
}

uint64_t IIOCallConvertHDRData(__IOSurface *a1, __IOSurface *a2, void *a3)
{
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  const void *v11;

  kdebug_trace();
  v11 = 0;
  v6 = *MEMORY[0x1E0C9AE00];
  gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E0C9AE00], a1, MEMORY[0x1E0C9AA70], &v11);
  v7 = v11;
  if (!v11)
    goto LABEL_8;
  v11 = 0;
  gFunc_CVPixelBufferCreateWithIOSurface(v6, a2, MEMORY[0x1E0C9AA70], &v11);
  v8 = v11;
  if (!v11)
  {
    CFRelease(v7);
LABEL_8:
    v9 = 4294967246;
    goto LABEL_9;
  }
  if (*(_QWORD *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020)
    gFunc_CVBufferSetAttachment(v11, *(_QWORD *)gIIO_kCVImageBufferYCbCrMatrixKey, *(_QWORD *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020, 1);
  v9 = IIOConvertHDRData((uint64_t)v7, (uint64_t)v8, a3);
  CFRelease(v8);
  CFRelease(v7);
  if (!(_DWORD)v9)
  {
    v9 = IIOSurfaceCopyAlphaValuesFromSource(a1, a2);
    IIO_IOSurfaceLogAlphaInfo(a1, "IIOCallConvertHDRData inputSurface:");
    IIO_IOSurfaceLogAlphaInfo(a2, "IIOCallConvertHDRData outputSurface:");
  }
LABEL_9:
  kdebug_trace();
  return v9;
}

uint64_t IIOCallApplyHDRGainmap(__IOSurface *a1, uint64_t a2, __IOSurface *a3, void *a4)
{
  uint64_t v8;
  CFTypeRef v9;
  CFTypeRef v10;
  uint64_t v11;
  CFTypeRef cf;

  kdebug_trace();
  cf = 0;
  v8 = *MEMORY[0x1E0C9AE00];
  gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E0C9AE00], a1, MEMORY[0x1E0C9AA70], &cf);
  v9 = cf;
  if (!cf)
    goto LABEL_7;
  if (!a2 || (cf = 0, gFunc_CVPixelBufferCreateWithIOSurface(v8, a3, MEMORY[0x1E0C9AA70], &cf), (v10 = cf) == 0))
  {
    CFRelease(v9);
LABEL_7:
    v11 = 4294967246;
    goto LABEL_8;
  }
  v11 = IIOApplyHDRGainMap((uint64_t)v9, a2, (uint64_t)cf, a4);
  CFRelease(v10);
  CFRelease(v9);
  if (!(_DWORD)v11)
  {
    v11 = IIOSurfaceCopyAlphaValuesFromSource(a1, a3);
    IIO_IOSurfaceLogAlphaInfo(a1, "IIOCallApplyHDRGainmap inputSurface:");
    IIO_IOSurfaceLogAlphaInfo(a3, "IIOCallApplyHDRGainmap outputSurface:");
  }
LABEL_8:
  kdebug_trace();
  return v11;
}

uint64_t IIOCallCreateHDRGainmap(__IOSurface *a1, __IOSurface *a2, uint64_t a3, void *a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  const void *v11;
  uint64_t v12;
  const void *v14;

  kdebug_trace();
  v14 = 0;
  v8 = *MEMORY[0x1E0C9AE00];
  gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E0C9AE00], a1, MEMORY[0x1E0C9AA70], &v14);
  v9 = v14;
  if (!v14)
    goto LABEL_6;
  v14 = 0;
  gFunc_CVPixelBufferCreateWithIOSurface(v8, a2, MEMORY[0x1E0C9AA70], &v14);
  v10 = v14;
  if (!v14)
  {
    CFRelease(v9);
LABEL_6:
    v12 = 4294967246;
    goto LABEL_10;
  }
  v14 = 0;
  gFunc_CVPixelBufferCreateWithIOSurface(v8, a3, MEMORY[0x1E0C9AA70], &v14);
  v11 = v14;
  if (v14)
  {
    v12 = IIOCreateHDRGainMap((uint64_t)v9, (uint64_t)v10, (uint64_t)v14, a4);
    CFRelease(v11);
  }
  else
  {
    v12 = 4294967246;
  }
  CFRelease(v10);
  CFRelease(v9);
  if (!(_DWORD)v12)
  {
    v12 = IIOSurfaceCopyAlphaValuesFromSource(a1, a2);
    IIO_IOSurfaceLogAlphaInfo(a1, "IIOCallCreateHDRGainmap inputSurface:");
    IIO_IOSurfaceLogAlphaInfo(a2, "IIOCallCreateHDRGainmap outputSurface:");
  }
LABEL_10:
  kdebug_trace();
  return v12;
}

void kdu_block_encoder::kdu_block_encoder(kdu_block_encoder *this)
{
  _QWORD *v2;

  v2 = (_QWORD *)operator new();
  *v2 = &off_1E1BB0FC0;
  *(_QWORD *)this = v2;
}

clock_t kd_block_encoder::encode(kd_block_encoder *this, kdu_block *a2, double a3)
{
  kdu_block *v3;
  unsigned int v4;
  double v5;
  int v6;
  double v7;
  BOOL v8;
  uint64_t *v9;
  uint64_t v10;
  kdu_block *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  BOOL v20;
  int v21;
  int v22;
  char *v23;
  clock_t v24;
  int v25;
  size_t v26;
  int v27;
  int32x2_t v28;
  int v29;
  unsigned int v30;
  int *v31;
  clock_t v32;
  int32x2_t *v33;
  int v34;
  int v35;
  double v36;
  unsigned int v37;
  int64_t v38;
  unint64_t v39;
  int v40;
  int v41;
  int v42;
  _BOOL4 v43;
  int v44;
  int v45;
  unsigned __int8 *v46;
  clock_t v47;
  unint64_t v48;
  unsigned __int8 *v49;
  _BYTE *v50;
  int64_t v51;
  int v52;
  int v53;
  int v54;
  _BOOL4 v55;
  int v56;
  int v57;
  _BOOL4 v58;
  uint64_t v59;
  int v60;
  _QWORD *v61;
  uint64_t v62;
  _DWORD *v63;
  int v64;
  char v65;
  uint64_t v66;
  int v67;
  int *v68;
  unsigned int *v69;
  int v70;
  unsigned int v71;
  uint64_t v72;
  int *v73;
  unsigned int v74;
  int v75;
  signed int v76;
  signed int v77;
  int v78;
  unsigned int v79;
  BOOL v80;
  int v81;
  int v82;
  signed int v83;
  int v84;
  __int128 *v85;
  _OWORD *v86;
  int v87;
  int v88;
  unsigned __int8 *v89;
  unsigned __int8 *v90;
  unsigned int v91;
  int v92;
  BOOL v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  unsigned __int8 *v99;
  unsigned __int8 *v100;
  BOOL v101;
  int v102;
  int v103;
  int v104;
  int v105;
  unsigned __int8 *v106;
  unsigned __int8 *v107;
  int v108;
  int v109;
  unsigned int v110;
  int v111;
  unsigned int v112;
  int v113;
  unsigned int v114;
  int v115;
  int v116;
  unsigned __int8 *v117;
  unsigned __int8 *v118;
  int v119;
  unsigned int v120;
  int v121;
  uint64_t v122;
  int *v123;
  unsigned int v124;
  int v125;
  int v126;
  int v127;
  _OWORD *v128;
  int v129;
  int v130;
  unsigned __int8 *v131;
  unsigned __int8 *v132;
  int v133;
  uint64_t v134;
  int *v135;
  int v136;
  signed int v137;
  _OWORD *v138;
  int v139;
  int v140;
  unsigned __int8 *v141;
  unsigned __int8 *v142;
  int v143;
  unsigned int v144;
  int v145;
  uint64_t v146;
  int *v147;
  unsigned int v148;
  int v149;
  int v150;
  int v151;
  _OWORD *v152;
  int v153;
  int v154;
  unsigned __int8 *v155;
  unsigned __int8 *v156;
  uint64_t v157;
  int *v158;
  int v159;
  signed int v160;
  _OWORD *v161;
  int v162;
  int v163;
  unsigned __int8 *v164;
  unsigned __int8 *v165;
  int v166;
  unsigned int v167;
  int v168;
  uint64_t v169;
  int *v170;
  unsigned int v171;
  int v172;
  int v173;
  int v174;
  _OWORD *v175;
  int v176;
  int v177;
  unsigned __int8 *v178;
  unsigned __int8 *v179;
  uint64_t v180;
  int *v181;
  int v182;
  signed int v183;
  _OWORD *v184;
  int v185;
  int v186;
  unsigned __int8 *v187;
  unsigned __int8 *v188;
  int v189;
  int v190;
  unsigned int v191;
  int v192;
  uint64_t v193;
  int *v194;
  unsigned int v195;
  int v196;
  int v197;
  int v198;
  _OWORD *v199;
  int v200;
  int v201;
  unsigned __int8 *v202;
  unsigned __int8 *v203;
  int v204;
  int v205;
  BOOL v206;
  uint64_t v207;
  _DWORD *v208;
  char v209;
  uint64_t v210;
  int v211;
  _DWORD *v212;
  unsigned int *v213;
  int v214;
  unsigned int v215;
  BOOL v216;
  uint64_t v217;
  int *v218;
  unsigned int v219;
  int v220;
  signed int v221;
  signed int v222;
  int v223;
  unsigned int v224;
  _OWORD *v225;
  int v226;
  int v227;
  unsigned __int8 *v228;
  unsigned __int8 *v229;
  int v230;
  unsigned int v231;
  int v232;
  uint64_t v233;
  int *v234;
  unsigned int v235;
  int v236;
  int v237;
  int v238;
  _OWORD *v239;
  int v240;
  int v241;
  unsigned __int8 *v242;
  unsigned __int8 *v243;
  uint64_t v245;
  int *v246;
  unsigned int v247;
  int v248;
  signed int v249;
  signed int v250;
  int v251;
  _OWORD *v252;
  int v253;
  int v254;
  unsigned __int8 *v255;
  unsigned __int8 *v256;
  int v257;
  unsigned int v258;
  int v259;
  uint64_t v260;
  int *v261;
  unsigned int v262;
  int v263;
  int v264;
  int v265;
  _OWORD *v266;
  int v267;
  int v268;
  unsigned __int8 *v269;
  unsigned __int8 *v270;
  uint64_t v271;
  int *v272;
  unsigned int v273;
  int v274;
  signed int v275;
  signed int v276;
  int v277;
  _OWORD *v278;
  int v279;
  int v280;
  unsigned __int8 *v281;
  unsigned __int8 *v282;
  int v283;
  unsigned int v284;
  int v285;
  uint64_t v286;
  int *v287;
  unsigned int v288;
  int v289;
  int v290;
  int v291;
  _OWORD *v292;
  int v293;
  int v294;
  unsigned __int8 *v295;
  unsigned __int8 *v296;
  uint64_t v297;
  int *v298;
  unsigned int v299;
  int v300;
  signed int v301;
  signed int v302;
  int v303;
  _OWORD *v304;
  int v305;
  int v306;
  unsigned __int8 *v307;
  unsigned __int8 *v308;
  int v309;
  int v310;
  unsigned int v311;
  int v312;
  uint64_t v313;
  int *v314;
  unsigned int v315;
  int v316;
  int v317;
  int v318;
  _OWORD *v319;
  int v320;
  int v321;
  unsigned __int8 *v322;
  unsigned __int8 *v323;
  unsigned int v324;
  _DWORD *v325;
  char v326;
  int v327;
  _DWORD *v328;
  unsigned int *v329;
  int v330;
  uint64_t v331;
  _DWORD *v332;
  _DWORD *v333;
  _DWORD *v334;
  int v335;
  unsigned int v336;
  int v338;
  int v339;
  int v340;
  unsigned __int8 *v341;
  unsigned int v342;
  int v343;
  int v344;
  int v345;
  unsigned int v346;
  unsigned __int8 *v347;
  unsigned int *v348;
  int v350;
  int v351;
  int v352;
  unsigned __int8 *v353;
  unsigned int v354;
  int v355;
  unint64_t v356;
  int v357;
  int v358;
  unsigned int v359;
  unsigned __int8 *v360;
  unsigned int *v361;
  int v363;
  int v364;
  int v365;
  unsigned __int8 *v366;
  unsigned int v367;
  int v368;
  unint64_t v369;
  int v370;
  int v371;
  unsigned int v372;
  unsigned __int8 *v373;
  unsigned int *v374;
  int v375;
  int v376;
  int v377;
  unsigned __int8 *v378;
  unsigned int v379;
  int v380;
  unint64_t v381;
  int v382;
  int v383;
  unsigned int v384;
  unsigned __int8 *v385;
  unsigned int *v386;
  _DWORD *v387;
  size_t v388;
  char v389;
  int v390;
  int v391;
  int *v392;
  unsigned int *v393;
  int v394;
  unsigned int v395;
  int v396;
  int v397;
  uint64_t v398;
  __int128 *v399;
  int v400;
  uint64_t v401;
  __int128 *v402;
  unsigned int v403;
  int v404;
  int v405;
  int v406;
  unsigned int v407;
  uint64_t v408;
  uint64_t v409;
  __int128 *v410;
  uint64_t v411;
  uint64_t v412;
  int v413;
  int v414;
  int v415;
  unsigned __int8 *v416;
  unsigned __int8 *v417;
  int v418;
  int v419;
  uint64_t v420;
  __int128 *v421;
  int v422;
  uint64_t v423;
  __int128 *v424;
  unsigned int v425;
  int v426;
  int v427;
  int v428;
  uint64_t v429;
  uint64_t v430;
  __int128 *v431;
  uint64_t v432;
  uint64_t v433;
  int v434;
  int v435;
  int v436;
  unsigned __int8 *v437;
  unsigned __int8 *v438;
  int v439;
  int v440;
  uint64_t v441;
  __int128 *v442;
  int v443;
  uint64_t v444;
  __int128 *v445;
  unsigned int v446;
  int v447;
  int v448;
  int v449;
  uint64_t v450;
  uint64_t v451;
  __int128 *v452;
  uint64_t v453;
  uint64_t v454;
  int v455;
  int v456;
  int v457;
  unsigned __int8 *v458;
  unsigned __int8 *v459;
  int v460;
  BOOL v461;
  int v462;
  uint64_t v463;
  __int128 *v464;
  int v465;
  unsigned int v466;
  int v467;
  int v468;
  int v469;
  uint64_t v470;
  uint64_t v471;
  __int128 *v472;
  uint64_t v473;
  uint64_t v474;
  int v475;
  int v476;
  int v477;
  unsigned __int8 *v478;
  unsigned __int8 *v479;
  int64_t v480;
  int v481;
  mq_encoder *v482;
  int bytes_used;
  unsigned __int8 *v484;
  mq_encoder *v485;
  uint64_t v486;
  int v487;
  int v488;
  double v489;
  int v490;
  double v491;
  double v492;
  int v493;
  double v494;
  int v495;
  int v496;
  int v497;
  double v498;
  double v499;
  double v500;
  int v501;
  int64_t v502;
  _DWORD *v503;
  char v504;
  int v505;
  _DWORD *v506;
  unsigned int *v507;
  int v508;
  unsigned int v509;
  unsigned int v510;
  unsigned int v511;
  int v512;
  int v513;
  int v514;
  unsigned __int8 *v515;
  unsigned int v516;
  int v517;
  int v518;
  int v519;
  unsigned __int8 *v520;
  unsigned int v521;
  int v522;
  int v523;
  int v524;
  unsigned __int8 *v525;
  unsigned int v526;
  int v527;
  int v528;
  int v529;
  unsigned __int8 *v530;
  mq_encoder *v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  int v536;
  double v537;
  double v538;
  uint64_t v539;
  double v540;
  double v541;
  double v542;
  int v543;
  uint64_t v544;
  unsigned __int16 *v545;
  uint64_t v546;
  uint64_t v547;
  unsigned __int16 *v548;
  uint64_t v549;
  unsigned int v550;
  uint64_t v552;
  int v553;
  int *v554;
  char *v555;
  uint64_t v556;
  int v557;
  uint64_t v558;
  _DWORD *v559;
  uint64_t v560;
  unsigned int *v561;
  int v562;
  size_t v563;
  int v564;
  int v565;
  _BOOL4 v566;
  unsigned __int8 *v567;
  int v568;
  int v569;
  int v570;
  int v571;
  uint64_t v572;
  uint64_t v573;
  uint64_t v574;
  uint64_t v575;
  uint64_t v576;
  unsigned int v577;
  uint64_t v578;
  int v579;
  int64_t v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  int v584;
  int v585;
  kdu_block *v586;
  uint64_t v587;
  uint64_t v588;
  int v589;
  uint64_t v590;
  uint64_t v591;
  _BYTE *v592;
  unsigned __int8 *v593;
  int v594[2];
  int v595[2];
  _BYTE v596[40];
  uint64_t v597;
  _QWORD v598[18];
  __int128 v599;
  _BYTE v600[80];
  __int128 v601;
  __int128 v602;
  __int128 v603;
  _QWORD v604[94];

  v5 = MEMORY[0x1E0C80A78](this, a2);
  v564 = v6;
  v604[91] = *MEMORY[0x1E0C80C00];
  v7 = -1.0;
  v8 = v5 > 0.0 && v4 >= 2;
  v586 = v3;
  if (v8 && *((_DWORD *)v3 + 8))
    v7 = exp(((double)v4 + -65536.0) * 0.00270760617) * 4294967300.0;
  bzero(v604, 0x2D8uLL);
  v602 = 0u;
  v603 = 0u;
  v601 = 0u;
  memset(v600, 0, sizeof(v600));
  v599 = 0u;
  memset(v598, 0, sizeof(v598));
  bzero(v596, 0x16C0uLL);
  v9 = &v597;
  v10 = 91;
  do
  {
    *((_BYTE *)v9 - 5) = 0;
    *(v9 - 3) = 0;
    *(v9 - 2) = 0;
    *v9 = 0;
    v9[1] = 0;
    *((_BYTE *)v9 + 16) = 0;
    v9 += 8;
    --v10;
  }
  while (v10);
  v11 = v586;
  v12 = *((_DWORD *)v586 + 1);
  v565 = *(_DWORD *)v586;
  v13 = *(_DWORD *)v586 + 3;
  if (*((_DWORD *)v586 + 28) < (signed int)((v13 & 0xFFFFFFFC) * v12))
    kd_block_encoder::encode();
  v14 = v12;
  v15 = v12 + 3;
  v562 = v13 >> 2;
  v16 = ((v13 >> 2) + 2) * v15;
  v584 = *((_DWORD *)v586 + 1);
  v560 = v12;
  v558 = v15;
  if (*((_DWORD *)v586 + 29) <= v16)
  {
    if (v16 <= 1599)
      v16 = 1599;
    kdu_block::set_max_contexts((uint64_t)v586, v16 + 1);
    v15 = v558;
    v14 = v560;
    v12 = v584;
    v11 = v586;
  }
  v17 = *((_QWORD *)v11 + 13);
  v559 = (_DWORD *)*((_QWORD *)v11 + 12);
  v18 = *((_DWORD *)v11 + 12);
  v19 = 3 * (31 - *((_DWORD *)v11 + 11)) - 2;
  v20 = v18 <= v19;
  if (v18 >= v19)
    v21 = 3 * (31 - *((_DWORD *)v11 + 11)) - 2;
  else
    v21 = *((_DWORD *)v11 + 12);
  v22 = v21 & ~(v21 >> 31);
  if (!v20 || v21 < 0)
    *((_DWORD *)v11 + 12) = v22;
  v23 = (char *)(v17 + 4 * v15);
  if (*((_DWORD *)v11 + 22) < v22)
  {
    kdu_block::set_max_passes((uint64_t)v586, v22 + 10, 0);
    v15 = v558;
    v14 = v560;
    v12 = v584;
    v11 = v586;
  }
  v561 = (unsigned int *)(v23 + 4);
  if (*((_DWORD *)v11 + 34))
  {
    v24 = clock();
    v15 = v558;
    v14 = v560;
    v12 = v584;
    *((_QWORD *)v586 + 19) = v24;
    v25 = *((_DWORD *)v586 + 34);
  }
  else
  {
    v25 = 1;
  }
  v557 = v25;
  v26 = 4 * (int)v15 * v562 + 4;
  v27 = v565 & 3;
  v554 = (int *)&v561[(v562 - 1) * (int)v15];
  v582 = -3 - v12;
  v583 = -4 - v12;
  v581 = -2 - v12;
  v588 = v12 + 2;
  v587 = v12 + 4;
  v576 = v14;
  v556 = 4 * v14 + 4 * v15 + v17 + 12;
  v575 = -12 - 4 * v14;
  v574 = v588;
  v28 = vdup_n_s32(0x49200000u);
  v590 = 2 * v14;
  v591 = 3 * v14;
  v592 = v600;
  v553 = v18;
  v552 = (v18 - 1);
  v577 = v12 + 1;
  v578 = v15;
  v572 = 3 * v14;
  v573 = 2 * v14;
  v555 = v23;
  v563 = v26;
  do
  {
    bzero(v23, v26);
    if (v27)
    {
      if (v27 == 2)
        v29 = 1207959552;
      else
        v29 = 0x40000000;
      if (v27 == 1)
        v29 = 1224736768;
      if (v584 >= 1)
      {
        v30 = v577;
        v31 = v554;
        do
        {
          *v31++ = v29;
          --v30;
        }
        while (v30 > 1);
      }
    }
    v32 = (clock_t)v586;
    if (v565 >= 1)
    {
      v33 = (int32x2_t *)v556;
      v34 = v562 + 1;
      do
      {
        v33->i32[0] = 1226833920;
        v33[-1] = v28;
        --v34;
        v33 = (int32x2_t *)((char *)v33 + v578 * 4);
      }
      while (v34 > 1);
    }
    v35 = *((_DWORD *)v586 + 11);
    v36 = v5 * 0.0000152587891 * 0.0000152587891;
    if (v35 >= 1)
    {
      v37 = v35 + 1;
      v36 = v5 * 0.0000152587891 * 0.0000152587891;
      do
      {
        v36 = v36 * 0.25;
        --v37;
      }
      while (v37 > 1);
    }
    LODWORD(v38) = *((_DWORD *)v586 + 12);
    if ((int)v38 < 1)
    {
      v40 = 0;
      goto LABEL_920;
    }
    v39 = 0;
    v566 = 0;
    v40 = 0;
    v41 = 0;
    v579 = 0;
    v589 = *((_DWORD *)v586 + 7);
    v571 = *((_DWORD *)v586 + 23);
    v567 = (unsigned __int8 *)*((_QWORD *)v586 + 9);
    v568 = 30 - v35;
    v42 = 2;
    v585 = 1;
    do
    {
      v43 = v42 == 3;
      if (v42 == 3)
      {
        v36 = v36 * 0.25;
        v44 = 0;
      }
      else
      {
        v44 = v42;
      }
      v570 = v44;
      v45 = v571;
      v580 = v39;
      if (v571 - v41 <= 4095)
      {
        if (v571 < v41)
          kd_block_encoder::encode();
        v46 = *(unsigned __int8 **)(v32 + 72);
        v47 = v32;
        v48 = v39;
        kdu_block::set_max_bytes(v32, *(_DWORD *)(v32 + 92) + 0x2000, 1);
        v49 = *(unsigned __int8 **)(v47 + 72);
        if (v48)
        {
          v50 = v596;
          v51 = v580;
          do
          {
            mq_encoder::augment_buffer((uint64_t)v50, v46, v49);
            v50 += 64;
            --v51;
          }
          while (v51);
        }
        v45 = v571 + 0x2000;
        v567 = &v49[v567 - v46];
        v32 = (clock_t)v586;
        v39 = v580;
        v43 = v42 == 3;
      }
      v571 = v45;
      if (v579)
      {
        mq_encoder::continues((mq_encoder *)&v596[64 * v39], (mq_encoder *)(&v588 + 8 * v39));
      }
      else
      {
        v52 = *(_DWORD *)(v32 + 48);
        v53 = *(_DWORD *)(v32 + 28);
        if ((v53 & 1) != 0)
        {
          if (v570 == 2)
            v54 = 1;
          else
            v54 = 2;
          if (v39 <= 9)
            v54 = 10 - v39;
          v55 = v566;
          if (v39 > 9)
            v55 = v570 != 2;
        }
        else
        {
          v54 = *(_DWORD *)(v32 + 48);
          v55 = v566;
        }
        if ((v53 & 4) != 0)
          v56 = 1;
        else
          v56 = v54;
        if (v56 + (int)v39 <= v52)
          v57 = v56;
        else
          v57 = v52 - v39;
        v579 = v57;
        v566 = v55;
        mq_encoder::start((mq_encoder *)&v596[64 * v39], v567, !v55);
      }
      v569 = v568 - v43;
      if (v564)
        v58 = 31 - (v568 - v43) == *((_DWORD *)v586 + 10);
      else
        v58 = 0;
      if (!v580 || (*((_BYTE *)v586 + 28) & 2) != 0)
      {
        v59 = 0;
        v60 = mq_encoder::p_bar_table[0];
        do
        {
          v61 = &v598[v59];
          *(_DWORD *)v61 = v60;
          v61[1] = &mq_encoder::transition_table;
          v59 += 2;
        }
        while (v59 != 36);
        LODWORD(v598[0]) = unk_1EDF01128;
        v598[1] = &unk_1EDF099F8;
        LODWORD(v599) = dword_1EDF01124;
        *((_QWORD *)&v599 + 1) = &unk_1EDF099B8;
      }
      if (v42 == 3 && !v566)
      {
        v207 = *((int *)v586 + 8);
        *(_QWORD *)v594 = 0;
        *(_QWORD *)v595 = 0;
        v593 = 0;
        mq_encoder::check_out((uint64_t)&v596[64 * v580], &v595[1], v595, &v594[1], v594, &v593);
        if (v569 >= 31)
          kd_block_encoder::encode();
        v208 = &significance_distortion_lut;
        if (v58)
          v208 = &significance_distortion_lut_lossless;
        if (v565 < 1)
        {
          v64 = 0;
LABEL_656:
          mq_encoder::check_in((uint64_t)&v596[64 * v580], v595[1], v595[0], v594[1], v594[0], v593);
LABEL_834:
          v388 = v563;
          goto LABEL_835;
        }
        v64 = 0;
        v209 = 31 - v569;
        v210 = (uint64_t)*(&significance_luts + v207);
        v211 = v562;
        v212 = v559;
        v213 = v561;
        while (v584 < 1)
        {
LABEL_591:
          v213 += 3;
          v212 += v591;
          v206 = __OFSUB__(v211--, 1);
          if ((v211 < 0) ^ v206 | (v211 == 0))
            goto LABEL_656;
        }
        v214 = v584;
        while (1)
        {
          v215 = *v213;
          if (!*v213)
          {
            if (!v213[3])
            {
              do
              {
                v214 -= 3;
                v212 += 3;
                v224 = v213[6];
                v213 += 3;
              }
              while (!v224);
            }
            goto LABEL_589;
          }
          v216 = (v215 & 0x1EF) != 0 && (v215 & 0x200010) == 0;
          if (v216)
          {
            v217 = *(unsigned __int8 *)(v210 + (v215 & 0x1EF));
            v218 = (int *)&v598[2 * v217];
            v219 = *v212 << v209;
            v220 = *v218;
            v221 = v219 & 0x80000000 ^ *v218;
            v222 = v595[1] - v221;
            v595[1] = v222;
            if (v222 < 0x8000)
            {
              if (v221 < 0)
              {
                v222 &= ~0x80000000;
                v595[1] = v222;
                if (v222 >= (v220 & 0x7FFFFFFFu))
                {
                  v595[1] = v220 & 0x7FFFFFFF;
                  v222 = v220 & 0x7FFFFFFF;
                }
                else
                {
                  v595[0] += v220 & 0x7FFFFFFF;
                }
                v225 = (_OWORD *)(v598[2 * v217 + 1] + 16);
              }
              else
              {
                if (v222 >= v221)
                {
                  v595[0] += v221;
                }
                else
                {
                  v595[1] = v219 & 0x80000000 ^ v220;
                  v222 = v595[1];
                }
                v225 = (_OWORD *)v598[2 * v217 + 1];
              }
              *(_OWORD *)v218 = *v225;
              if (v222 >= 0x8000)
                kd_block_encoder::encode();
              v223 = v595[0];
              v226 = v594[1];
              do
              {
                v595[1] = 2 * v222;
                v595[0] = 2 * v223;
                v594[1] = --v226;
                if (v226)
                {
                  v223 *= 2;
                }
                else
                {
                  v227 = v594[0] + (v223 >> 26);
                  v594[0] = v227;
                  if (v227 < 255)
                  {
                    v229 = v593++;
                    *v229 = v227;
                    v594[0] = (v595[0] >> 19);
                    v223 = v595[0] & 0x7FFFF;
                    v595[0] &= 0x7FFFFu;
                    v226 = 8;
                  }
                  else
                  {
                    v228 = v593++;
                    *v228 = -1;
                    v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                    v223 = v595[0] & 0xFFFFF;
                    v595[0] &= 0xFFFFFu;
                    v226 = 7;
                  }
                  v594[1] = v226;
                }
                v222 = v595[1];
              }
              while (v595[1] < 0x8000);
            }
            else
            {
              v223 = v595[0] + v221;
              v595[0] += v221;
            }
            if ((v219 & 0x80000000) != 0)
            {
              v230 = v208[(v219 >> 26) & 0x1F];
              v231 = v213[1];
              v232 = sign_lut[(*(v213 - 1) >> 2) & 4 | (v215 >> 1) & 0x41 | v231 & 0x10 | (((*(v213 - 1) >> 2) & 0x80004 | (v215 >> 1) & 0x820041 | v231 & 0x200010) >> 16)];
              v233 = v232 >> 1;
              v234 = (int *)&v592[16 * v233];
              v235 = *v212 & 0x80000000;
              v236 = *v234;
              v237 = *v234 ^ (v232 << 31) ^ v235;
              v238 = v222 - v237;
              v595[1] = v238;
              if (v238 < 0x8000)
              {
                if (v237 < 0)
                {
                  v237 = v238 & 0x7FFFFFFF;
                  v595[1] = v238 & 0x7FFFFFFF;
                  if ((v238 & 0x7FFFFFFFu) >= (v236 & 0x7FFFFFFFu))
                  {
                    v595[1] = v236 & 0x7FFFFFFF;
                    v237 = v236 & 0x7FFFFFFF;
                  }
                  else
                  {
                    v223 += v236 & 0x7FFFFFFF;
                    v595[0] = v223;
                  }
                  v239 = (_OWORD *)(*(_QWORD *)&v592[16 * v233 + 8] + 16);
                }
                else
                {
                  if (v238 >= v237)
                  {
                    v223 += v237;
                    v595[0] = v223;
                    v237 = v238;
                  }
                  else
                  {
                    v595[1] = v237;
                  }
                  v239 = *(_OWORD **)&v592[16 * v233 + 8];
                }
                *(_OWORD *)v234 = *v239;
                if (v237 >= 0x8000)
                  kd_block_encoder::encode();
                v240 = v594[1];
                do
                {
                  v595[1] = 2 * v237;
                  v595[0] = 2 * v223;
                  v594[1] = --v240;
                  if (v240)
                  {
                    v223 *= 2;
                  }
                  else
                  {
                    v241 = v594[0] + (v223 >> 26);
                    v594[0] = v241;
                    if (v241 < 255)
                    {
                      v243 = v593++;
                      *v243 = v241;
                      v594[0] = (v595[0] >> 19);
                      v223 = v595[0] & 0x7FFFF;
                      v595[0] &= 0x7FFFFu;
                      v240 = 8;
                    }
                    else
                    {
                      v242 = v593++;
                      *v242 = -1;
                      v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                      v223 = v595[0] & 0xFFFFF;
                      v595[0] &= 0xFFFFFu;
                      v240 = 7;
                    }
                    v594[1] = v240;
                  }
                  v237 = v595[1];
                }
                while (v595[1] < 0x8000);
                v231 = v213[1];
              }
              else
              {
                v595[0] = v237 + v223;
              }
              v64 += v230;
              *(v213 - 1) |= 0x20u;
              v213[1] = v231 | 8;
              if (v235)
              {
                v215 |= 0x300010u;
                if ((v589 & 8) == 0)
                {
                  v213[v583] |= 0x20000u;
                  v213[v582] |= 0x80010000;
                  goto LABEL_443;
                }
              }
              else
              {
                v215 |= 0x100010u;
                if ((v589 & 8) == 0)
                {
                  v213[v583] |= 0x20000u;
                  v213[v582] |= 0x10000u;
LABEL_443:
                  v213[v581] |= 0x8000u;
                }
              }
            }
            else
            {
              v215 |= 0x100000u;
            }
          }
          if ((v215 & 0xF78) != 0 && (v215 & 0x1000080) == 0)
          {
            v245 = *(unsigned __int8 *)(v210 + ((v215 >> 3) & 0x1EFLL));
            v246 = (int *)&v598[2 * v245];
            v247 = v212[v560] << v209;
            v248 = *v246;
            v249 = v247 & 0x80000000 ^ *v246;
            v250 = v595[1] - v249;
            v595[1] = v250;
            if (v250 < 0x8000)
            {
              if (v249 < 0)
              {
                v250 &= ~0x80000000;
                v595[1] = v250;
                if (v250 >= (v248 & 0x7FFFFFFFu))
                {
                  v595[1] = v248 & 0x7FFFFFFF;
                  v250 = v248 & 0x7FFFFFFF;
                }
                else
                {
                  v595[0] += v248 & 0x7FFFFFFF;
                }
                v252 = (_OWORD *)(v598[2 * v245 + 1] + 16);
              }
              else
              {
                if (v250 >= v249)
                {
                  v595[0] += v249;
                }
                else
                {
                  v595[1] = v247 & 0x80000000 ^ v248;
                  v250 = v595[1];
                }
                v252 = (_OWORD *)v598[2 * v245 + 1];
              }
              *(_OWORD *)v246 = *v252;
              if (v250 >= 0x8000)
                kd_block_encoder::encode();
              v251 = v595[0];
              v253 = v594[1];
              do
              {
                v595[1] = 2 * v250;
                v595[0] = 2 * v251;
                v594[1] = --v253;
                if (v253)
                {
                  v251 *= 2;
                }
                else
                {
                  v254 = v594[0] + (v251 >> 26);
                  v594[0] = v254;
                  if (v254 < 255)
                  {
                    v256 = v593++;
                    *v256 = v254;
                    v594[0] = (v595[0] >> 19);
                    v251 = v595[0] & 0x7FFFF;
                    v595[0] &= 0x7FFFFu;
                    v253 = 8;
                  }
                  else
                  {
                    v255 = v593++;
                    *v255 = -1;
                    v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                    v251 = v595[0] & 0xFFFFF;
                    v595[0] &= 0xFFFFFu;
                    v253 = 7;
                  }
                  v594[1] = v253;
                }
                v250 = v595[1];
              }
              while (v595[1] < 0x8000);
            }
            else
            {
              v251 = v595[0] + v249;
              v595[0] += v249;
            }
            if ((v247 & 0x80000000) != 0)
            {
              v257 = v208[(v247 >> 26) & 0x1F];
              v258 = v213[1];
              v259 = sign_lut[(*(v213 - 1) >> 5) & 4 | (v215 >> 4) & 0x41 | (v258 >> 3) & 0x10 | (((*(v213 - 1) >> 5) & 0x80004 | (v215 >> 4) & 0x820041 | (v258 >> 3) & 0x200010) >> 16)];
              v260 = v259 >> 1;
              v261 = (int *)&v592[16 * v260];
              v262 = v212[v560] & 0x80000000;
              v263 = *v261;
              v264 = *v261 ^ (v259 << 31) ^ v262;
              v265 = v250 - v264;
              v595[1] = v265;
              if (v265 < 0x8000)
              {
                if (v264 < 0)
                {
                  v264 = v265 & 0x7FFFFFFF;
                  v595[1] = v265 & 0x7FFFFFFF;
                  if ((v265 & 0x7FFFFFFFu) >= (v263 & 0x7FFFFFFFu))
                  {
                    v595[1] = v263 & 0x7FFFFFFF;
                    v264 = v263 & 0x7FFFFFFF;
                  }
                  else
                  {
                    v251 += v263 & 0x7FFFFFFF;
                    v595[0] = v251;
                  }
                  v266 = (_OWORD *)(*(_QWORD *)&v592[16 * v260 + 8] + 16);
                }
                else
                {
                  if (v265 >= v264)
                  {
                    v251 += v264;
                    v595[0] = v251;
                    v264 = v265;
                  }
                  else
                  {
                    v595[1] = v264;
                  }
                  v266 = *(_OWORD **)&v592[16 * v260 + 8];
                }
                *(_OWORD *)v261 = *v266;
                if (v264 >= 0x8000)
                  kd_block_encoder::encode();
                v267 = v594[1];
                do
                {
                  v595[1] = 2 * v264;
                  v595[0] = 2 * v251;
                  v594[1] = --v267;
                  if (v267)
                  {
                    v251 *= 2;
                  }
                  else
                  {
                    v268 = v594[0] + (v251 >> 26);
                    v594[0] = v268;
                    if (v268 < 255)
                    {
                      v270 = v593++;
                      *v270 = v268;
                      v594[0] = (v595[0] >> 19);
                      v251 = v595[0] & 0x7FFFF;
                      v595[0] &= 0x7FFFFu;
                      v267 = 8;
                    }
                    else
                    {
                      v269 = v593++;
                      *v269 = -1;
                      v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                      v251 = v595[0] & 0xFFFFF;
                      v595[0] &= 0xFFFFFu;
                      v267 = 7;
                    }
                    v594[1] = v267;
                  }
                  v264 = v595[1];
                }
                while (v595[1] < 0x8000);
                v258 = v213[1];
              }
              else
              {
                v595[0] = v264 + v251;
              }
              v64 += v257;
              *(v213 - 1) |= 0x100u;
              v213[1] = v258 | 0x40;
              v215 |= (v262 >> 7) | 0x800080;
            }
            else
            {
              v215 |= 0x800000u;
            }
          }
          if ((v215 & 0x7BC0) != 0 && (v215 & 0x8000400) == 0)
          {
            v271 = *(unsigned __int8 *)(v210 + ((v215 >> 6) & 0x1EFLL));
            v272 = (int *)&v598[2 * v271];
            v273 = v212[v590] << v209;
            v274 = *v272;
            v275 = v273 & 0x80000000 ^ *v272;
            v276 = v595[1] - v275;
            v595[1] = v276;
            if (v276 < 0x8000)
            {
              if (v275 < 0)
              {
                v276 &= ~0x80000000;
                v595[1] = v276;
                if (v276 >= (v274 & 0x7FFFFFFFu))
                {
                  v595[1] = v274 & 0x7FFFFFFF;
                  v276 = v274 & 0x7FFFFFFF;
                }
                else
                {
                  v595[0] += v274 & 0x7FFFFFFF;
                }
                v278 = (_OWORD *)(v598[2 * v271 + 1] + 16);
              }
              else
              {
                if (v276 >= v275)
                {
                  v595[0] += v275;
                }
                else
                {
                  v595[1] = v273 & 0x80000000 ^ v274;
                  v276 = v595[1];
                }
                v278 = (_OWORD *)v598[2 * v271 + 1];
              }
              *(_OWORD *)v272 = *v278;
              if (v276 >= 0x8000)
                kd_block_encoder::encode();
              v277 = v595[0];
              v279 = v594[1];
              do
              {
                v595[1] = 2 * v276;
                v595[0] = 2 * v277;
                v594[1] = --v279;
                if (v279)
                {
                  v277 *= 2;
                }
                else
                {
                  v280 = v594[0] + (v277 >> 26);
                  v594[0] = v280;
                  if (v280 < 255)
                  {
                    v282 = v593++;
                    *v282 = v280;
                    v594[0] = (v595[0] >> 19);
                    v277 = v595[0] & 0x7FFFF;
                    v595[0] &= 0x7FFFFu;
                    v279 = 8;
                  }
                  else
                  {
                    v281 = v593++;
                    *v281 = -1;
                    v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                    v277 = v595[0] & 0xFFFFF;
                    v595[0] &= 0xFFFFFu;
                    v279 = 7;
                  }
                  v594[1] = v279;
                }
                v276 = v595[1];
              }
              while (v595[1] < 0x8000);
            }
            else
            {
              v277 = v595[0] + v275;
              v595[0] += v275;
            }
            if ((v273 & 0x80000000) != 0)
            {
              v283 = v208[(v273 >> 26) & 0x1F];
              v284 = v213[1];
              v285 = sign_lut[(*(v213 - 1) >> 8) & 4 | (v215 >> 7) & 0x41 | (v284 >> 6) & 0x10 | (((*(v213 - 1) >> 8) & 0x80004 | (v215 >> 7) & 0x820041 | (v284 >> 6) & 0x200010) >> 16)];
              v286 = v285 >> 1;
              v287 = (int *)&v592[16 * v286];
              v288 = v212[v590] & 0x80000000;
              v289 = *v287;
              v290 = *v287 ^ (v285 << 31) ^ v288;
              v291 = v276 - v290;
              v595[1] = v291;
              if (v291 < 0x8000)
              {
                if (v290 < 0)
                {
                  v290 = v291 & 0x7FFFFFFF;
                  v595[1] = v291 & 0x7FFFFFFF;
                  if ((v291 & 0x7FFFFFFFu) >= (v289 & 0x7FFFFFFFu))
                  {
                    v595[1] = v289 & 0x7FFFFFFF;
                    v290 = v289 & 0x7FFFFFFF;
                  }
                  else
                  {
                    v277 += v289 & 0x7FFFFFFF;
                    v595[0] = v277;
                  }
                  v292 = (_OWORD *)(*(_QWORD *)&v592[16 * v286 + 8] + 16);
                }
                else
                {
                  if (v291 >= v290)
                  {
                    v277 += v290;
                    v595[0] = v277;
                    v290 = v291;
                  }
                  else
                  {
                    v595[1] = v290;
                  }
                  v292 = *(_OWORD **)&v592[16 * v286 + 8];
                }
                *(_OWORD *)v287 = *v292;
                if (v290 >= 0x8000)
                  kd_block_encoder::encode();
                v293 = v594[1];
                do
                {
                  v595[1] = 2 * v290;
                  v595[0] = 2 * v277;
                  v594[1] = --v293;
                  if (v293)
                  {
                    v277 *= 2;
                  }
                  else
                  {
                    v294 = v594[0] + (v277 >> 26);
                    v594[0] = v294;
                    if (v294 < 255)
                    {
                      v296 = v593++;
                      *v296 = v294;
                      v594[0] = (v595[0] >> 19);
                      v277 = v595[0] & 0x7FFFF;
                      v595[0] &= 0x7FFFFu;
                      v293 = 8;
                    }
                    else
                    {
                      v295 = v593++;
                      *v295 = -1;
                      v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                      v277 = v595[0] & 0xFFFFF;
                      v595[0] &= 0xFFFFFu;
                      v293 = 7;
                    }
                    v594[1] = v293;
                  }
                  v290 = v595[1];
                }
                while (v595[1] < 0x8000);
                v284 = v213[1];
              }
              else
              {
                v595[0] = v290 + v277;
              }
              v64 += v283;
              *(v213 - 1) |= 0x800u;
              v213[1] = v284 | 0x200;
              v215 |= (v288 >> 4) | 0x4000400;
            }
            else
            {
              v215 |= 0x4000000u;
            }
          }
          if ((v215 & 0x3DE00) != 0 && (v215 & 0x40002000) == 0)
          {
            v297 = *(unsigned __int8 *)(v210 + ((v215 >> 9) & 0x1EF));
            v298 = (int *)&v598[2 * v297];
            v299 = v212[v591] << v209;
            v300 = *v298;
            v301 = v299 & 0x80000000 ^ *v298;
            v302 = v595[1] - v301;
            v595[1] = v302;
            if (v302 < 0x8000)
            {
              if (v301 < 0)
              {
                v302 &= ~0x80000000;
                v595[1] = v302;
                if (v302 >= (v300 & 0x7FFFFFFFu))
                {
                  v595[1] = v300 & 0x7FFFFFFF;
                  v302 = v300 & 0x7FFFFFFF;
                }
                else
                {
                  v595[0] += v300 & 0x7FFFFFFF;
                }
                v304 = (_OWORD *)(v598[2 * v297 + 1] + 16);
              }
              else
              {
                if (v302 >= v301)
                {
                  v595[0] += v301;
                }
                else
                {
                  v595[1] = v299 & 0x80000000 ^ v300;
                  v302 = v595[1];
                }
                v304 = (_OWORD *)v598[2 * v297 + 1];
              }
              *(_OWORD *)v298 = *v304;
              if (v302 >= 0x8000)
                kd_block_encoder::encode();
              v303 = v595[0];
              v305 = v594[1];
              do
              {
                v595[1] = 2 * v302;
                v595[0] = 2 * v303;
                v594[1] = --v305;
                if (v305)
                {
                  v303 *= 2;
                }
                else
                {
                  v306 = v594[0] + (v303 >> 26);
                  v594[0] = v306;
                  if (v306 < 255)
                  {
                    v308 = v593++;
                    *v308 = v306;
                    v594[0] = (v595[0] >> 19);
                    v303 = v595[0] & 0x7FFFF;
                    v595[0] &= 0x7FFFFu;
                    v305 = 8;
                  }
                  else
                  {
                    v307 = v593++;
                    *v307 = -1;
                    v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                    v303 = v595[0] & 0xFFFFF;
                    v595[0] &= 0xFFFFFu;
                    v305 = 7;
                  }
                  v594[1] = v305;
                }
                v302 = v595[1];
              }
              while (v595[1] < 0x8000);
            }
            else
            {
              v303 = v595[0] + v301;
              v595[0] += v301;
            }
            if ((v299 & 0x80000000) != 0)
            {
              v309 = v208[(v299 >> 26) & 0x1F];
              v310 = (v215 >> 10) & 0x20041;
              if ((v215 & 0x80000000) != 0)
                v310 |= 0x800000u;
              v311 = (*(v213 - 1) >> 11) & 0x80004 | v310 | (v213[1] >> 9) & 0x200010;
              v312 = sign_lut[v311 & 0x55 | HIWORD(v311)];
              v313 = v312 >> 1;
              v314 = (int *)&v592[16 * v313];
              v315 = v212[v591] & 0x80000000;
              v316 = *v314;
              v317 = *v314 ^ (v312 << 31) ^ v315;
              v318 = v302 - v317;
              v595[1] = v318;
              if (v318 < 0x8000)
              {
                if (v317 < 0)
                {
                  v317 = v318 & 0x7FFFFFFF;
                  v595[1] = v318 & 0x7FFFFFFF;
                  if ((v318 & 0x7FFFFFFFu) >= (v316 & 0x7FFFFFFFu))
                  {
                    v595[1] = v316 & 0x7FFFFFFF;
                    v317 = v316 & 0x7FFFFFFF;
                  }
                  else
                  {
                    v303 += v316 & 0x7FFFFFFF;
                    v595[0] = v303;
                  }
                  v319 = (_OWORD *)(*(_QWORD *)&v592[16 * v313 + 8] + 16);
                }
                else
                {
                  if (v318 >= v317)
                  {
                    v303 += v317;
                    v595[0] = v303;
                    v317 = v318;
                  }
                  else
                  {
                    v595[1] = v317;
                  }
                  v319 = *(_OWORD **)&v592[16 * v313 + 8];
                }
                *(_OWORD *)v314 = *v319;
                if (v317 >= 0x8000)
                  kd_block_encoder::encode();
                v320 = v594[1];
                do
                {
                  v595[1] = 2 * v317;
                  v595[0] = 2 * v303;
                  v594[1] = --v320;
                  if (v320)
                  {
                    v303 *= 2;
                  }
                  else
                  {
                    v321 = v594[0] + (v303 >> 26);
                    v594[0] = v321;
                    if (v321 < 255)
                    {
                      v323 = v593++;
                      *v323 = v321;
                      v594[0] = (v595[0] >> 19);
                      v303 = v595[0] & 0x7FFFF;
                      v595[0] &= 0x7FFFFu;
                      v320 = 8;
                    }
                    else
                    {
                      v322 = v593++;
                      *v322 = -1;
                      v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                      v303 = v595[0] & 0xFFFFF;
                      v595[0] &= 0xFFFFFu;
                      v320 = 7;
                    }
                    v594[1] = v320;
                  }
                  v317 = v595[1];
                }
                while (v595[1] < 0x8000);
              }
              else
              {
                v595[0] = v317 + v303;
              }
              v213[v588] |= 4u;
              v64 += v309;
              v213[v587] |= 1u;
              *(v213 - 1) |= 0x4000u;
              v213[1] |= 0x1000u;
              v324 = v213[v558];
              if (v315)
              {
                v213[v558] = v324 | 0x40002;
                v215 |= 0x60002000u;
              }
              else
              {
                v213[v558] = v324 | 2;
                v215 |= 0x20002000u;
              }
            }
            else
            {
              v215 |= 0x20000000u;
            }
          }
          *v213 = v215;
LABEL_589:
          ++v212;
          ++v213;
          v206 = __OFSUB__(v214--, 1);
          if ((v214 < 0) ^ v206 | (v214 == 0))
            goto LABEL_591;
        }
      }
      if (v42 == 3)
      {
        *(_QWORD *)v595 = 0;
        v593 = 0;
        mq_encoder::check_out((uint64_t)&v596[64 * v580], &v595[1], v595, &v593);
        if (v568 >= 32)
          kd_block_encoder::encode();
        v325 = &significance_distortion_lut;
        if (v58)
          v325 = &significance_distortion_lut_lossless;
        if (v565 < 1)
        {
          v64 = 0;
        }
        else
        {
          v64 = 0;
          v326 = 32 - v568;
          v327 = v562;
          v328 = v559;
          v329 = v561;
          v330 = v584;
          do
          {
            if (v330 >= 1)
            {
              v331 = 0;
              v332 = &v328[v576];
              v333 = &v328[v573];
              v334 = &v328[v572];
              v335 = v577;
              do
              {
                v336 = v329[v331];
                if (v336)
                {
                  if ((v336 & 0x1EF) != 0 && (v336 & 0x200010) == 0)
                  {
                    v338 = v328[v331];
                    v339 = v595[1];
                    v340 = v595[0];
                    if (!v595[1])
                    {
                      v341 = v593++;
                      *v341 = v595[0];
                      v340 = 0;
                      v339 = 8 - ((v595[0] + 1) >> 8);
                    }
                    v342 = v338 << v326;
                    v343 = __PAIR64__(v340, v342) >> 31;
                    v595[0] = v343;
                    v344 = v339 - 1;
                    v595[1] = v344;
                    if ((v342 & 0x80000000) != 0)
                    {
                      v345 = v325[(v342 >> 26) & 0x1F];
                      v346 = v328[v331];
                      if (!v344)
                      {
                        v347 = v593++;
                        *v347 = v343;
                        v343 = 0;
                        v344 = 8 - ((v595[0] + 1) >> 8);
                      }
                      v595[0] = (v346 >> 31) | (2 * v343);
                      v595[1] = v344 - 1;
                      if ((v589 & 8) == 0)
                      {
                        v329[v583 + v331] |= 0x20000u;
                        *(unsigned int *)((char *)v329 + v575 + v331 * 4) |= v346 & 0x80000000 | 0x10000;
                        v329[v581 + v331] |= 0x8000u;
                      }
                      v64 += v345;
                      v348 = &v329[v331];
                      *(v348 - 1) = v329[v331 - 1] | 0x20;
                      v348[1] = v329[v331 + 1] | 8;
                      v336 |= (v346 >> 31 << 21) | 0x100010;
                      v330 = v584;
                    }
                    else
                    {
                      v336 |= 0x100000u;
                    }
                  }
                  if ((v336 & 0xF78) != 0 && (v336 & 0x1000080) == 0)
                  {
                    v350 = v332[v331];
                    v351 = v595[1];
                    v352 = v595[0];
                    if (!v595[1])
                    {
                      v353 = v593++;
                      *v353 = v595[0];
                      v352 = 0;
                      v351 = 8 - ((v595[0] + 1) >> 8);
                    }
                    v354 = v350 << v326;
                    HIDWORD(v356) = v352;
                    LODWORD(v356) = v350 << v326;
                    v355 = v356 >> 31;
                    v595[0] = v355;
                    v357 = v351 - 1;
                    v595[1] = v351 - 1;
                    if ((v354 & 0x80000000) != 0)
                    {
                      v358 = v325[(v354 >> 26) & 0x1F];
                      v359 = v332[v331];
                      if (!v357)
                      {
                        v360 = v593++;
                        *v360 = v355;
                        v355 = 0;
                        v357 = 8 - ((v595[0] + 1) >> 8);
                      }
                      v64 += v358;
                      v595[0] = (v359 >> 31) | (2 * v355);
                      v595[1] = v357 - 1;
                      v361 = &v329[v331];
                      *(v361 - 1) = v329[v331 - 1] | 0x100;
                      v361[1] = v329[v331 + 1] | 0x40;
                      v336 |= (v359 >> 31 << 24) | 0x800080;
                    }
                    else
                    {
                      v336 |= 0x800000u;
                    }
                  }
                  if ((v336 & 0x7BC0) != 0 && (v336 & 0x8000400) == 0)
                  {
                    v363 = v333[v331];
                    v364 = v595[1];
                    v365 = v595[0];
                    if (!v595[1])
                    {
                      v366 = v593++;
                      *v366 = v595[0];
                      v365 = 0;
                      v364 = 8 - ((v595[0] + 1) >> 8);
                    }
                    v367 = v363 << v326;
                    HIDWORD(v369) = v365;
                    LODWORD(v369) = v363 << v326;
                    v368 = v369 >> 31;
                    v595[0] = v368;
                    v370 = v364 - 1;
                    v595[1] = v364 - 1;
                    if ((v367 & 0x80000000) != 0)
                    {
                      v371 = v325[(v367 >> 26) & 0x1F];
                      v372 = v333[v331];
                      if (!v370)
                      {
                        v373 = v593++;
                        *v373 = v368;
                        v368 = 0;
                        v370 = 8 - ((v595[0] + 1) >> 8);
                      }
                      v64 += v371;
                      v595[0] = (v372 >> 31) | (2 * v368);
                      v595[1] = v370 - 1;
                      v374 = &v329[v331];
                      *(v374 - 1) = v329[v331 - 1] | 0x800;
                      v374[1] = v329[v331 + 1] | 0x200;
                      v336 |= (v372 >> 31 << 27) | 0x4000400;
                    }
                    else
                    {
                      v336 |= 0x4000000u;
                    }
                  }
                  if ((v336 & 0x3DE00) != 0 && (v336 & 0x40002000) == 0)
                  {
                    v375 = v334[v331];
                    v376 = v595[1];
                    v377 = v595[0];
                    if (!v595[1])
                    {
                      v378 = v593++;
                      *v378 = v595[0];
                      v377 = 0;
                      v376 = 8 - ((v595[0] + 1) >> 8);
                    }
                    v379 = v375 << v326;
                    HIDWORD(v381) = v377;
                    LODWORD(v381) = v375 << v326;
                    v380 = v381 >> 31;
                    v595[0] = v380;
                    v382 = v376 - 1;
                    v595[1] = v376 - 1;
                    if ((v379 & 0x80000000) != 0)
                    {
                      v383 = v325[(v379 >> 26) & 0x1F];
                      v384 = v334[v331];
                      if (!v382)
                      {
                        v385 = v593++;
                        *v385 = v380;
                        v380 = 0;
                        v382 = 8 - ((v595[0] + 1) >> 8);
                      }
                      v595[0] = (v384 >> 31) | (2 * v380);
                      v595[1] = v382 - 1;
                      v64 += v383;
                      v329[v574 + v331] |= 4u;
                      v329[v578 + v331] |= (v384 >> 31 << 18) | 2;
                      v329[v587 + v331] |= 1u;
                      v386 = &v329[v331];
                      *(v386 - 1) = v329[v331 - 1] | 0x4000;
                      v386[1] = v329[v331 + 1] | 0x1000;
                      v336 |= (v384 >> 31 << 30) | 0x20002000;
                    }
                    else
                    {
                      v336 |= 0x20000000u;
                    }
                  }
                  v329[v331] = v336;
                }
                ++v331;
                --v335;
              }
              while (v335 > 1);
              v328 = (_DWORD *)((char *)v328 + v331 * 4);
              v329 = (unsigned int *)((char *)v329 + v331 * 4);
            }
            v329 += 3;
            v328 += v591;
            v206 = __OFSUB__(v327--, 1);
          }
          while (!((v327 < 0) ^ v206 | (v327 == 0)));
        }
        mq_encoder::check_in((uint64_t)&v596[64 * v580], v595[1], v595[0], v593);
        goto LABEL_834;
      }
      if (v42 != 1 || v566)
      {
        if (v42 != 1)
        {
          v62 = *((int *)v586 + 8);
          *(_QWORD *)v594 = 0;
          *(_QWORD *)v595 = 0;
          v593 = 0;
          mq_encoder::check_out((uint64_t)&v596[64 * v580], &v595[1], v595, &v594[1], v594, &v593);
          if (v568 >= 31)
            kd_block_encoder::encode();
          v63 = &significance_distortion_lut;
          if (v58)
            v63 = &significance_distortion_lut_lossless;
          if (v565 >= 1)
          {
            v64 = 0;
            v65 = 31 - v568;
            v66 = (uint64_t)*(&significance_luts + v62);
            v67 = v562;
            v68 = v559;
            v69 = v561;
            while (v584 < 1)
            {
LABEL_376:
              v69 += 3;
              v68 += v591;
              v206 = __OFSUB__(v67--, 1);
              if ((v67 < 0) ^ v206 | (v67 == 0))
                goto LABEL_656;
            }
            v70 = v584;
            while (1)
            {
              v71 = *v69;
              if (!*v69)
              {
                if (*v68 << v65 < 0)
                {
                  v80 = 0;
                  v81 = 0;
                }
                else if (v68[v560] << v65 < 0)
                {
                  v80 = 0;
                  v81 = 1;
                }
                else
                {
                  if (((v68[v590] << v65) & 0x80000000) == 0)
                  {
                    if (v68[v591] << v65 < 0)
                      v79 = 0x80000000;
                    else
                      v79 = 0;
                    v80 = v68[v591] << v65 >= 0;
                    if (v68[v591] << v65 < 0)
                      v81 = 3;
                    else
                      v81 = -1;
                    goto LABEL_111;
                  }
                  v80 = 0;
                  v81 = 2;
                }
                v79 = 0x80000000;
LABEL_111:
                v82 = v599 ^ v79;
                v83 = v595[1] - (v599 ^ v79);
                v595[1] = v83;
                if (v83 < 0x8000)
                {
                  if (v82 < 0)
                  {
                    v83 &= ~0x80000000;
                    v595[1] = v83;
                    if (v83 >= (v599 & 0x7FFFFFFF))
                    {
                      v595[1] = v599 & 0x7FFFFFFF;
                      v83 = v599 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v595[0] += v599 & 0x7FFFFFFF;
                    }
                    v85 = (__int128 *)(*((_QWORD *)&v599 + 1) + 16);
                  }
                  else
                  {
                    if (v83 >= v82)
                    {
                      v595[0] += v82;
                    }
                    else
                    {
                      v595[1] = v82;
                      v83 = v82;
                    }
                    v85 = (__int128 *)*((_QWORD *)&v599 + 1);
                  }
                  v599 = *v85;
                  if (v83 >= 0x8000)
                    kd_block_encoder::encode();
                  v84 = v595[0];
                  v87 = v594[1];
                  do
                  {
                    v595[1] = 2 * v83;
                    v595[0] = 2 * v84;
                    v594[1] = --v87;
                    if (v87)
                    {
                      v84 *= 2;
                    }
                    else
                    {
                      v88 = v594[0] + (v84 >> 26);
                      v594[0] = v88;
                      if (v88 < 255)
                      {
                        v90 = v593++;
                        *v90 = v88;
                        v594[0] = (v595[0] >> 19);
                        v84 = v595[0] & 0x7FFFF;
                        v595[0] &= 0x7FFFFu;
                        v87 = 8;
                      }
                      else
                      {
                        v89 = v593++;
                        *v89 = -1;
                        v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                        v84 = v595[0] & 0xFFFFF;
                        v595[0] &= 0xFFFFFu;
                        v87 = 7;
                      }
                      v594[1] = v87;
                    }
                    v83 = v595[1];
                  }
                  while (v595[1] < 0x8000);
                }
                else
                {
                  v84 = v595[0] + v82;
                  v595[0] = v84;
                }
                if (!v80)
                {
                  v91 = v83 - 22017;
                  if ((v81 & 2) != 0 || v83 < 0xD601)
                  {
                    v92 = v84 + 22017;
                    v93 = v83 >= 0xAC02;
                    if (v83 >= 0xAC02)
                      v94 = v84 + 22017;
                    else
                      v94 = v84;
                    if (v93)
                      v95 = v91;
                    else
                      v95 = 22017;
                    if (v93)
                      v92 = v84;
                    if (v93)
                      v96 = 22017;
                    else
                      v96 = v91;
                    if ((v81 & 2) != 0)
                    {
                      v91 = v96;
                    }
                    else
                    {
                      v92 = v94;
                      v91 = v95;
                    }
                    v97 = v594[1];
                    do
                    {
                      v595[1] = 2 * v91;
                      v595[0] = 2 * v92;
                      v594[1] = --v97;
                      if (v97)
                      {
                        v92 *= 2;
                      }
                      else
                      {
                        v98 = v594[0] + (v92 >> 26);
                        v594[0] = v98;
                        if (v98 < 255)
                        {
                          v100 = v593++;
                          *v100 = v98;
                          v594[0] = (v595[0] >> 19);
                          v92 = v595[0] & 0x7FFFF;
                          v595[0] &= 0x7FFFFu;
                          v97 = 8;
                        }
                        else
                        {
                          v99 = v593++;
                          *v99 = -1;
                          v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                          v92 = v595[0] & 0xFFFFF;
                          v595[0] &= 0xFFFFFu;
                          v97 = 7;
                        }
                        v594[1] = v97;
                      }
                      v91 = v595[1];
                    }
                    while (v595[1] < 0x8000);
                  }
                  else
                  {
                    v92 = v84 + 22017;
                  }
                  v77 = v91 - 22017;
                  v595[1] = v91 - 22017;
                  if ((v81 & 1) != 0 || v91 < 0xD601)
                  {
                    v101 = v91 >= 0xAC02;
                    if (v91 >= 0xAC02)
                      v102 = v92 + 22017;
                    else
                      v102 = v92;
                    if (v101)
                      v103 = v77;
                    else
                      v103 = 22017;
                    if (v101)
                      v77 = 22017;
                    else
                      v92 += 22017;
                    if ((v81 & 1) != 0)
                      v78 = v92;
                    else
                      v78 = v102;
                    if ((v81 & 1) == 0)
                      v77 = v103;
                    v104 = v594[1];
                    do
                    {
                      v595[1] = 2 * v77;
                      v595[0] = 2 * v78;
                      v594[1] = --v104;
                      if (v104)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        v105 = v594[0] + (v78 >> 26);
                        v594[0] = v105;
                        if (v105 < 255)
                        {
                          v107 = v593++;
                          *v107 = v105;
                          v594[0] = (v595[0] >> 19);
                          v78 = v595[0] & 0x7FFFF;
                          v595[0] &= 0x7FFFFu;
                          v104 = 8;
                        }
                        else
                        {
                          v106 = v593++;
                          *v106 = -1;
                          v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                          v78 = v595[0] & 0xFFFFF;
                          v595[0] &= 0xFFFFFu;
                          v104 = 7;
                        }
                        v594[1] = v104;
                      }
                      v77 = v595[1];
                    }
                    while (v595[1] < 0x8000);
                  }
                  else
                  {
                    v78 = v92 + 22017;
                    v595[0] = v92 + 22017;
                  }
                  v71 = *v69;
                  switch(v81)
                  {
                    case 0:
                      v108 = *v68;
                      v74 = *v68 << v65;
                      goto LABEL_205;
                    case 1:
                      v113 = v68[v560];
                      v114 = v113 << v65;
                      goto LABEL_254;
                    case 2:
                      v109 = v68[v590];
                      v110 = v109 << v65;
                      goto LABEL_299;
                    case 3:
                      v111 = v68[v591];
                      v112 = v111 << v65;
                      goto LABEL_344;
                    default:
                      goto LABEL_92;
                  }
                }
                goto LABEL_374;
              }
LABEL_92:
              if ((v71 & 0x300010) == 0)
              {
                v72 = *(unsigned __int8 *)(v66 + (v71 & 0x1EF));
                v73 = (int *)&v598[2 * v72];
                v74 = *v68 << v65;
                v75 = *v73;
                v76 = v74 & 0x80000000 ^ *v73;
                v77 = v595[1] - v76;
                v595[1] = v77;
                if (v77 < 0x8000)
                {
                  if (v76 < 0)
                  {
                    v77 &= ~0x80000000;
                    v595[1] = v77;
                    if (v77 >= (v75 & 0x7FFFFFFFu))
                    {
                      v595[1] = v75 & 0x7FFFFFFF;
                      v77 = v75 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v595[0] += v75 & 0x7FFFFFFF;
                    }
                    v86 = (_OWORD *)(v598[2 * v72 + 1] + 16);
                  }
                  else
                  {
                    if (v77 >= v76)
                    {
                      v595[0] += v76;
                    }
                    else
                    {
                      v595[1] = v74 & 0x80000000 ^ v75;
                      v77 = v595[1];
                    }
                    v86 = (_OWORD *)v598[2 * v72 + 1];
                  }
                  *(_OWORD *)v73 = *v86;
                  if (v77 >= 0x8000)
                    kd_block_encoder::encode();
                  v78 = v595[0];
                  v115 = v594[1];
                  do
                  {
                    v595[1] = 2 * v77;
                    v595[0] = 2 * v78;
                    v594[1] = --v115;
                    if (v115)
                    {
                      v78 *= 2;
                    }
                    else
                    {
                      v116 = v594[0] + (v78 >> 26);
                      v594[0] = v116;
                      if (v116 < 255)
                      {
                        v118 = v593++;
                        *v118 = v116;
                        v594[0] = (v595[0] >> 19);
                        v78 = v595[0] & 0x7FFFF;
                        v595[0] &= 0x7FFFFu;
                        v115 = 8;
                      }
                      else
                      {
                        v117 = v593++;
                        *v117 = -1;
                        v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                        v78 = v595[0] & 0xFFFFF;
                        v595[0] &= 0xFFFFFu;
                        v115 = 7;
                      }
                      v594[1] = v115;
                    }
                    v77 = v595[1];
                  }
                  while (v595[1] < 0x8000);
                }
                else
                {
                  v78 = v595[0] + v76;
                  v595[0] += v76;
                }
                if ((v74 & 0x80000000) != 0)
                {
                  v108 = *v68;
LABEL_205:
                  v119 = v63[(v74 >> 26) & 0x1F];
                  v120 = v69[1];
                  v121 = sign_lut[(*(v69 - 1) >> 2) & 4 | (v71 >> 1) & 0x41 | v120 & 0x10 | (((*(v69 - 1) >> 2) & 0x80004 | (v71 >> 1) & 0x820041 | v120 & 0x200010) >> 16)];
                  v122 = v121 >> 1;
                  v123 = (int *)&v592[16 * v122];
                  v124 = v108 & 0x80000000;
                  v125 = *v123;
                  v126 = v124 ^ (v121 << 31) ^ *v123;
                  v127 = v77 - v126;
                  v595[1] = v127;
                  if (v127 < 0x8000)
                  {
                    if (v126 < 0)
                    {
                      v126 = v127 & 0x7FFFFFFF;
                      v595[1] = v127 & 0x7FFFFFFF;
                      if ((v127 & 0x7FFFFFFFu) >= (v125 & 0x7FFFFFFFu))
                      {
                        v595[1] = v125 & 0x7FFFFFFF;
                        v126 = v125 & 0x7FFFFFFF;
                      }
                      else
                      {
                        v78 += v125 & 0x7FFFFFFF;
                        v595[0] = v78;
                      }
                      v128 = (_OWORD *)(*(_QWORD *)&v592[16 * v122 + 8] + 16);
                    }
                    else
                    {
                      if (v127 >= v126)
                      {
                        v78 += v126;
                        v595[0] = v78;
                        v126 = v127;
                      }
                      else
                      {
                        v595[1] = v126;
                      }
                      v128 = *(_OWORD **)&v592[16 * v122 + 8];
                    }
                    *(_OWORD *)v123 = *v128;
                    if (v126 >= 0x8000)
                      kd_block_encoder::encode();
                    v129 = v594[1];
                    do
                    {
                      v595[1] = 2 * v126;
                      v595[0] = 2 * v78;
                      v594[1] = --v129;
                      if (v129)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        v130 = v594[0] + (v78 >> 26);
                        v594[0] = v130;
                        if (v130 < 255)
                        {
                          v132 = v593++;
                          *v132 = v130;
                          v594[0] = (v595[0] >> 19);
                          v78 = v595[0] & 0x7FFFF;
                          v595[0] &= 0x7FFFFu;
                          v129 = 8;
                        }
                        else
                        {
                          v131 = v593++;
                          *v131 = -1;
                          v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                          v78 = v595[0] & 0xFFFFF;
                          v595[0] &= 0xFFFFFu;
                          v129 = 7;
                        }
                        v594[1] = v129;
                      }
                      v126 = v595[1];
                    }
                    while (v595[1] < 0x8000);
                    v120 = v69[1];
                  }
                  else
                  {
                    v595[0] = v126 + v78;
                  }
                  v64 += v119;
                  *(v69 - 1) |= 0x20u;
                  v69[1] = v120 | 8;
                  if (v124)
                  {
                    v71 |= 0x200010u;
                    v133 = -2147418112;
                    if ((v589 & 8) != 0)
                      goto LABEL_231;
                  }
                  else
                  {
                    v71 |= 0x10u;
                    if ((v589 & 8) != 0)
                      goto LABEL_231;
                    v133 = 0x10000;
                  }
                  v69[v583] |= 0x20000u;
                  v69[v582] |= v133;
                  v69[v581] |= 0x8000u;
                }
              }
LABEL_231:
              if ((v71 & 0x1800080) == 0)
              {
                v134 = *(unsigned __int8 *)(v66 + ((v71 >> 3) & 0x1EFLL));
                v135 = (int *)&v598[2 * v134];
                v114 = v68[v560] << v65;
                v136 = *v135;
                v137 = v114 & 0x80000000 ^ *v135;
                v77 = v595[1] - v137;
                v595[1] = v77;
                if (v77 < 0x8000)
                {
                  if (v137 < 0)
                  {
                    v77 &= ~0x80000000;
                    v595[1] = v77;
                    if (v77 >= (v136 & 0x7FFFFFFFu))
                    {
                      v595[1] = v136 & 0x7FFFFFFF;
                      v77 = v136 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v595[0] += v136 & 0x7FFFFFFF;
                    }
                    v138 = (_OWORD *)(v598[2 * v134 + 1] + 16);
                  }
                  else
                  {
                    if (v77 >= v137)
                    {
                      v595[0] += v137;
                    }
                    else
                    {
                      v595[1] = v114 & 0x80000000 ^ v136;
                      v77 = v595[1];
                    }
                    v138 = (_OWORD *)v598[2 * v134 + 1];
                  }
                  *(_OWORD *)v135 = *v138;
                  if (v77 >= 0x8000)
                    kd_block_encoder::encode();
                  v78 = v595[0];
                  v139 = v594[1];
                  do
                  {
                    v595[1] = 2 * v77;
                    v595[0] = 2 * v78;
                    v594[1] = --v139;
                    if (v139)
                    {
                      v78 *= 2;
                    }
                    else
                    {
                      v140 = v594[0] + (v78 >> 26);
                      v594[0] = v140;
                      if (v140 < 255)
                      {
                        v142 = v593++;
                        *v142 = v140;
                        v594[0] = (v595[0] >> 19);
                        v78 = v595[0] & 0x7FFFF;
                        v595[0] &= 0x7FFFFu;
                        v139 = 8;
                      }
                      else
                      {
                        v141 = v593++;
                        *v141 = -1;
                        v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                        v78 = v595[0] & 0xFFFFF;
                        v595[0] &= 0xFFFFFu;
                        v139 = 7;
                      }
                      v594[1] = v139;
                    }
                    v77 = v595[1];
                  }
                  while (v595[1] < 0x8000);
                }
                else
                {
                  v78 = v595[0] + v137;
                  v595[0] += v137;
                }
                if ((v114 & 0x80000000) != 0)
                {
                  v113 = v68[v560];
LABEL_254:
                  v143 = v63[(v114 >> 26) & 0x1F];
                  v144 = v69[1];
                  v145 = sign_lut[(*(v69 - 1) >> 5) & 4 | (v71 >> 4) & 0x41 | (v144 >> 3) & 0x10 | (((*(v69 - 1) >> 5) & 0x80004 | (v71 >> 4) & 0x820041 | (v144 >> 3) & 0x200010) >> 16)];
                  v146 = v145 >> 1;
                  v147 = (int *)&v592[16 * v146];
                  v148 = v113 & 0x80000000;
                  v149 = *v147;
                  v150 = v148 ^ (v145 << 31) ^ *v147;
                  v151 = v77 - v150;
                  v595[1] = v151;
                  if (v151 < 0x8000)
                  {
                    if (v150 < 0)
                    {
                      v150 = v151 & 0x7FFFFFFF;
                      v595[1] = v151 & 0x7FFFFFFF;
                      if ((v151 & 0x7FFFFFFFu) >= (v149 & 0x7FFFFFFFu))
                      {
                        v595[1] = v149 & 0x7FFFFFFF;
                        v150 = v149 & 0x7FFFFFFF;
                      }
                      else
                      {
                        v78 += v149 & 0x7FFFFFFF;
                        v595[0] = v78;
                      }
                      v152 = (_OWORD *)(*(_QWORD *)&v592[16 * v146 + 8] + 16);
                    }
                    else
                    {
                      if (v151 >= v150)
                      {
                        v78 += v150;
                        v595[0] = v78;
                        v150 = v151;
                      }
                      else
                      {
                        v595[1] = v150;
                      }
                      v152 = *(_OWORD **)&v592[16 * v146 + 8];
                    }
                    *(_OWORD *)v147 = *v152;
                    if (v150 >= 0x8000)
                      kd_block_encoder::encode();
                    v153 = v594[1];
                    do
                    {
                      v595[1] = 2 * v150;
                      v595[0] = 2 * v78;
                      v594[1] = --v153;
                      if (v153)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        v154 = v594[0] + (v78 >> 26);
                        v594[0] = v154;
                        if (v154 < 255)
                        {
                          v156 = v593++;
                          *v156 = v154;
                          v594[0] = (v595[0] >> 19);
                          v78 = v595[0] & 0x7FFFF;
                          v595[0] &= 0x7FFFFu;
                          v153 = 8;
                        }
                        else
                        {
                          v155 = v593++;
                          *v155 = -1;
                          v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                          v78 = v595[0] & 0xFFFFF;
                          v595[0] &= 0xFFFFFu;
                          v153 = 7;
                        }
                        v594[1] = v153;
                      }
                      v150 = v595[1];
                    }
                    while (v595[1] < 0x8000);
                    v144 = v69[1];
                  }
                  else
                  {
                    v595[0] = v150 + v78;
                  }
                  v64 += v143;
                  *(v69 - 1) |= 0x100u;
                  v69[1] = v144 | 0x40;
                  v71 |= (v148 >> 7) | 0x80;
                }
              }
              if ((v71 & 0xC000400) == 0)
              {
                v157 = *(unsigned __int8 *)(v66 + ((v71 >> 6) & 0x1EFLL));
                v158 = (int *)&v598[2 * v157];
                v110 = v68[v590] << v65;
                v159 = *v158;
                v160 = v110 & 0x80000000 ^ *v158;
                v77 = v595[1] - v160;
                v595[1] = v77;
                if (v77 < 0x8000)
                {
                  if (v160 < 0)
                  {
                    v77 &= ~0x80000000;
                    v595[1] = v77;
                    if (v77 >= (v159 & 0x7FFFFFFFu))
                    {
                      v595[1] = v159 & 0x7FFFFFFF;
                      v77 = v159 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v595[0] += v159 & 0x7FFFFFFF;
                    }
                    v161 = (_OWORD *)(v598[2 * v157 + 1] + 16);
                  }
                  else
                  {
                    if (v77 >= v160)
                    {
                      v595[0] += v160;
                    }
                    else
                    {
                      v595[1] = v110 & 0x80000000 ^ v159;
                      v77 = v595[1];
                    }
                    v161 = (_OWORD *)v598[2 * v157 + 1];
                  }
                  *(_OWORD *)v158 = *v161;
                  if (v77 >= 0x8000)
                    kd_block_encoder::encode();
                  v78 = v595[0];
                  v162 = v594[1];
                  do
                  {
                    v595[1] = 2 * v77;
                    v595[0] = 2 * v78;
                    v594[1] = --v162;
                    if (v162)
                    {
                      v78 *= 2;
                    }
                    else
                    {
                      v163 = v594[0] + (v78 >> 26);
                      v594[0] = v163;
                      if (v163 < 255)
                      {
                        v165 = v593++;
                        *v165 = v163;
                        v594[0] = (v595[0] >> 19);
                        v78 = v595[0] & 0x7FFFF;
                        v595[0] &= 0x7FFFFu;
                        v162 = 8;
                      }
                      else
                      {
                        v164 = v593++;
                        *v164 = -1;
                        v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                        v78 = v595[0] & 0xFFFFF;
                        v595[0] &= 0xFFFFFu;
                        v162 = 7;
                      }
                      v594[1] = v162;
                    }
                    v77 = v595[1];
                  }
                  while (v595[1] < 0x8000);
                }
                else
                {
                  v78 = v595[0] + v160;
                  v595[0] += v160;
                }
                if ((v110 & 0x80000000) != 0)
                {
                  v109 = v68[v590];
LABEL_299:
                  v166 = v63[(v110 >> 26) & 0x1F];
                  v167 = v69[1];
                  v168 = sign_lut[(*(v69 - 1) >> 8) & 4 | (v71 >> 7) & 0x41 | (v167 >> 6) & 0x10 | (((*(v69 - 1) >> 8) & 0x80004 | (v71 >> 7) & 0x820041 | (v167 >> 6) & 0x200010) >> 16)];
                  v169 = v168 >> 1;
                  v170 = (int *)&v592[16 * v169];
                  v171 = v109 & 0x80000000;
                  v172 = *v170;
                  v173 = v171 ^ (v168 << 31) ^ *v170;
                  v174 = v77 - v173;
                  v595[1] = v174;
                  if (v174 < 0x8000)
                  {
                    if (v173 < 0)
                    {
                      v173 = v174 & 0x7FFFFFFF;
                      v595[1] = v174 & 0x7FFFFFFF;
                      if ((v174 & 0x7FFFFFFFu) >= (v172 & 0x7FFFFFFFu))
                      {
                        v595[1] = v172 & 0x7FFFFFFF;
                        v173 = v172 & 0x7FFFFFFF;
                      }
                      else
                      {
                        v78 += v172 & 0x7FFFFFFF;
                        v595[0] = v78;
                      }
                      v175 = (_OWORD *)(*(_QWORD *)&v592[16 * v169 + 8] + 16);
                    }
                    else
                    {
                      if (v174 >= v173)
                      {
                        v78 += v173;
                        v595[0] = v78;
                        v173 = v174;
                      }
                      else
                      {
                        v595[1] = v173;
                      }
                      v175 = *(_OWORD **)&v592[16 * v169 + 8];
                    }
                    *(_OWORD *)v170 = *v175;
                    if (v173 >= 0x8000)
                      kd_block_encoder::encode();
                    v176 = v594[1];
                    do
                    {
                      v595[1] = 2 * v173;
                      v595[0] = 2 * v78;
                      v594[1] = --v176;
                      if (v176)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        v177 = v594[0] + (v78 >> 26);
                        v594[0] = v177;
                        if (v177 < 255)
                        {
                          v179 = v593++;
                          *v179 = v177;
                          v594[0] = (v595[0] >> 19);
                          v78 = v595[0] & 0x7FFFF;
                          v595[0] &= 0x7FFFFu;
                          v176 = 8;
                        }
                        else
                        {
                          v178 = v593++;
                          *v178 = -1;
                          v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                          v78 = v595[0] & 0xFFFFF;
                          v595[0] &= 0xFFFFFu;
                          v176 = 7;
                        }
                        v594[1] = v176;
                      }
                      v173 = v595[1];
                    }
                    while (v595[1] < 0x8000);
                    v167 = v69[1];
                  }
                  else
                  {
                    v595[0] = v173 + v78;
                  }
                  v64 += v166;
                  *(v69 - 1) |= 0x800u;
                  v69[1] = v167 | 0x200;
                  v71 |= (v171 >> 4) | 0x400;
                }
              }
              if ((v71 & 0x60002000) == 0)
              {
                v180 = *(unsigned __int8 *)(v66 + ((v71 >> 9) & 0x1EF));
                v181 = (int *)&v598[2 * v180];
                v112 = v68[v591] << v65;
                v182 = *v181;
                v183 = v112 & 0x80000000 ^ *v181;
                v77 = v595[1] - v183;
                v595[1] = v77;
                if (v77 < 0x8000)
                {
                  if (v183 < 0)
                  {
                    v77 &= ~0x80000000;
                    v595[1] = v77;
                    if (v77 >= (v182 & 0x7FFFFFFFu))
                    {
                      v595[1] = v182 & 0x7FFFFFFF;
                      v77 = v182 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v595[0] += v182 & 0x7FFFFFFF;
                    }
                    v184 = (_OWORD *)(v598[2 * v180 + 1] + 16);
                  }
                  else
                  {
                    if (v77 >= v183)
                    {
                      v595[0] += v183;
                    }
                    else
                    {
                      v595[1] = v112 & 0x80000000 ^ v182;
                      v77 = v595[1];
                    }
                    v184 = (_OWORD *)v598[2 * v180 + 1];
                  }
                  *(_OWORD *)v181 = *v184;
                  if (v77 >= 0x8000)
                    kd_block_encoder::encode();
                  v78 = v595[0];
                  v185 = v594[1];
                  do
                  {
                    v595[1] = 2 * v77;
                    v595[0] = 2 * v78;
                    v594[1] = --v185;
                    if (v185)
                    {
                      v78 *= 2;
                    }
                    else
                    {
                      v186 = v594[0] + (v78 >> 26);
                      v594[0] = v186;
                      if (v186 < 255)
                      {
                        v188 = v593++;
                        *v188 = v186;
                        v594[0] = (v595[0] >> 19);
                        v78 = v595[0] & 0x7FFFF;
                        v595[0] &= 0x7FFFFu;
                        v185 = 8;
                      }
                      else
                      {
                        v187 = v593++;
                        *v187 = -1;
                        v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                        v78 = v595[0] & 0xFFFFF;
                        v595[0] &= 0xFFFFFu;
                        v185 = 7;
                      }
                      v594[1] = v185;
                    }
                    v77 = v595[1];
                  }
                  while (v595[1] < 0x8000);
                }
                else
                {
                  v78 = v595[0] + v183;
                  v595[0] += v183;
                }
                if ((v112 & 0x80000000) != 0)
                {
                  v111 = v68[v591];
LABEL_344:
                  v189 = v63[(v112 >> 26) & 0x1F];
                  v190 = (v71 >> 10) & 0x20041;
                  if ((v71 & 0x80000000) != 0)
                    v190 |= 0x800000u;
                  v191 = (*(v69 - 1) >> 11) & 0x80004 | v190 | (v69[1] >> 9) & 0x200010;
                  v192 = sign_lut[v191 & 0x55 | HIWORD(v191)];
                  v193 = v192 >> 1;
                  v194 = (int *)&v592[16 * v193];
                  v195 = v111 & 0x80000000;
                  v196 = *v194;
                  v197 = v195 ^ (v192 << 31) ^ *v194;
                  v198 = v77 - v197;
                  v595[1] = v198;
                  if (v198 < 0x8000)
                  {
                    if (v197 < 0)
                    {
                      v197 = v198 & 0x7FFFFFFF;
                      v595[1] = v198 & 0x7FFFFFFF;
                      if ((v198 & 0x7FFFFFFFu) >= (v196 & 0x7FFFFFFFu))
                      {
                        v595[1] = v196 & 0x7FFFFFFF;
                        v197 = v196 & 0x7FFFFFFF;
                      }
                      else
                      {
                        v78 += v196 & 0x7FFFFFFF;
                        v595[0] = v78;
                      }
                      v199 = (_OWORD *)(*(_QWORD *)&v592[16 * v193 + 8] + 16);
                    }
                    else
                    {
                      if (v198 >= v197)
                      {
                        v78 += v197;
                        v595[0] = v78;
                        v197 = v198;
                      }
                      else
                      {
                        v595[1] = v197;
                      }
                      v199 = *(_OWORD **)&v592[16 * v193 + 8];
                    }
                    *(_OWORD *)v194 = *v199;
                    if (v197 >= 0x8000)
                      kd_block_encoder::encode();
                    v200 = v594[1];
                    do
                    {
                      v595[1] = 2 * v197;
                      v595[0] = 2 * v78;
                      v594[1] = --v200;
                      if (v200)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        v201 = v594[0] + (v78 >> 26);
                        v594[0] = v201;
                        if (v201 < 255)
                        {
                          v203 = v593++;
                          *v203 = v201;
                          v594[0] = (v595[0] >> 19);
                          v78 = v595[0] & 0x7FFFF;
                          v595[0] &= 0x7FFFFu;
                          v200 = 8;
                        }
                        else
                        {
                          v202 = v593++;
                          *v202 = -1;
                          v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                          v78 = v595[0] & 0xFFFFF;
                          v595[0] &= 0xFFFFFu;
                          v200 = 7;
                        }
                        v594[1] = v200;
                      }
                      v197 = v595[1];
                    }
                    while (v595[1] < 0x8000);
                  }
                  else
                  {
                    v595[0] = v197 + v78;
                  }
                  v64 += v189;
                  v69[v588] |= 4u;
                  v69[v587] |= 1u;
                  *(v69 - 1) |= 0x4000u;
                  v69[1] |= 0x1000u;
                  if (v195)
                    v204 = 262146;
                  else
                    v204 = 2;
                  if (v195)
                    v205 = 1073750016;
                  else
                    v205 = 0x2000;
                  v69[v558] |= v204;
                  v71 |= v205;
                }
              }
              *v69 = (v71 << 15) & 0x12480000 | v71 & 0xDB6FFFFF;
LABEL_374:
              ++v68;
              ++v69;
              v206 = __OFSUB__(v70--, 1);
              if ((v70 < 0) ^ v206 | (v70 == 0))
                goto LABEL_376;
            }
          }
          v64 = 0;
          goto LABEL_656;
        }
        *(_QWORD *)v595 = 0;
        v593 = 0;
        mq_encoder::check_out((uint64_t)&v596[64 * v580], &v595[1], v595, &v593);
        v503 = &refinement_distortion_lut;
        if (v58)
          v503 = &refinement_distortion_lut_lossless;
        v64 = 0;
        if (v565 >= 1)
        {
          v504 = 31 - v568;
          v505 = v562;
          v506 = v559;
          v507 = v561;
          v388 = v563;
          while (v584 < 1)
          {
LABEL_908:
            v507 += 3;
            v506 += v591;
            v206 = __OFSUB__(v505--, 1);
            if ((v505 < 0) ^ v206 | (v505 == 0))
              goto LABEL_916;
          }
          v508 = v584;
          while (2)
          {
            v509 = *v507;
            if ((*v507 & 0x12480000) == 0)
            {
              if (!v507[2])
              {
                do
                {
                  v508 -= 2;
                  v506 += 2;
                  v510 = v507[4];
                  v507 += 2;
                }
                while (!v510);
              }
              goto LABEL_906;
            }
            if ((v509 & 0x80000) != 0)
            {
              v511 = *v506 << v504;
              v512 = v503[v511 >> 26];
              v513 = v595[1];
              v514 = v595[0];
              if (!v595[1])
              {
                v515 = v593++;
                *v515 = v595[0];
                v514 = 0;
                v513 = 8 - ((v595[0] + 1) >> 8);
              }
              v64 += v512;
              v595[0] = __PAIR64__(v514, v511) >> 31;
              v595[1] = v513 - 1;
              if ((v509 & 0x400000) != 0)
                goto LABEL_897;
LABEL_888:
              if ((v509 & 0x2000000) == 0)
                goto LABEL_889;
LABEL_900:
              v521 = v506[v590] << v504;
              v522 = v503[v521 >> 26];
              v523 = v595[1];
              v524 = v595[0];
              if (!v595[1])
              {
                v525 = v593++;
                *v525 = v595[0];
                v524 = 0;
                v523 = 8 - ((v595[0] + 1) >> 8);
              }
              v64 += v522;
              v595[0] = __PAIR64__(v524, v521) >> 31;
              v595[1] = v523 - 1;
              if ((v509 & 0x10000000) == 0)
              {
LABEL_906:
                ++v506;
                ++v507;
                v206 = __OFSUB__(v508--, 1);
                if ((v508 < 0) ^ v206 | (v508 == 0))
                  goto LABEL_908;
                continue;
              }
            }
            else
            {
              if ((v509 & 0x400000) == 0)
                goto LABEL_888;
LABEL_897:
              v516 = v506[v560] << v504;
              v517 = v503[v516 >> 26];
              v518 = v595[1];
              v519 = v595[0];
              if (!v595[1])
              {
                v520 = v593++;
                *v520 = v595[0];
                v519 = 0;
                v518 = 8 - ((v595[0] + 1) >> 8);
              }
              v64 += v517;
              v595[0] = __PAIR64__(v519, v516) >> 31;
              v595[1] = v518 - 1;
              if ((v509 & 0x2000000) != 0)
                goto LABEL_900;
LABEL_889:
              if ((v509 & 0x10000000) == 0)
                goto LABEL_906;
            }
            break;
          }
          v526 = v506[v591] << v504;
          v527 = v503[v526 >> 26];
          v528 = v595[1];
          v529 = v595[0];
          if (!v595[1])
          {
            v530 = v593++;
            *v530 = v595[0];
            v529 = 0;
            v528 = 8 - ((v595[0] + 1) >> 8);
          }
          v64 += v527;
          v595[0] = __PAIR64__(v529, v526) >> 31;
          v595[1] = v528 - 1;
          goto LABEL_906;
        }
        v388 = v563;
LABEL_916:
        mq_encoder::check_in((uint64_t)&v596[64 * v580], v595[1], v595[0], v593);
      }
      else
      {
        *(_QWORD *)v594 = 0;
        *(_QWORD *)v595 = 0;
        v593 = 0;
        mq_encoder::check_out((uint64_t)&v596[64 * v580], &v595[1], v595, &v594[1], v594, &v593);
        v387 = &refinement_distortion_lut;
        if (v58)
          v387 = &refinement_distortion_lut_lossless;
        v388 = v563;
        v64 = 0;
        if (v565 >= 1)
        {
          v389 = 31 - v568;
          v390 = (-1 << (v568 + 2)) & 0x7FFFFFFF;
          v391 = v562;
          v392 = v559;
          v393 = v561;
          do
          {
            if (v584 >= 1)
            {
              v394 = v584;
              do
              {
                v395 = *v393;
                if ((*v393 & 0x12480000) != 0)
                {
                  if ((v395 & 0x80000) != 0)
                  {
                    v396 = *v392;
                    v397 = *v393 & 0x1EF;
                    if ((v395 & 0x1EF) != 0)
                      v398 = 256;
                    else
                      v398 = 240;
                    if ((v395 & 0x1EF) != 0)
                      v399 = &v602;
                    else
                      v399 = &v601;
                    v400 = v396 & v390;
                    if ((v396 & v390) != 0)
                      v401 = 272;
                    else
                      v401 = v398;
                    if ((v396 & v390) != 0)
                      v402 = &v603;
                    else
                      v402 = v399;
                    v403 = v396 << v389;
                    v64 += v387[v403 >> 26];
                    v404 = *(_DWORD *)((char *)v598 + v401);
                    v405 = v403 & 0x80000000 ^ v404;
                    v406 = v595[1] - v405;
                    v595[1] = v406;
                    if (v406 < 0x8000)
                    {
                      if (v405 < 0)
                      {
                        v405 = v406 & 0x7FFFFFFF;
                        v595[1] = v406 & 0x7FFFFFFF;
                        if ((v406 & 0x7FFFFFFFu) >= (v404 & 0x7FFFFFFFu))
                        {
                          v595[1] = v404 & 0x7FFFFFFF;
                          v405 = v404 & 0x7FFFFFFF;
                        }
                        else
                        {
                          v595[0] += v404 & 0x7FFFFFFF;
                        }
                        v216 = v397 == 0;
                        v411 = 264;
                        if (v216)
                          v411 = 248;
                        v216 = v400 == 0;
                        v412 = 280;
                        if (v216)
                          v412 = v411;
                        v410 = (__int128 *)(*(_QWORD *)((char *)v598 + v412) + 16);
                      }
                      else
                      {
                        if (v406 >= v405)
                        {
                          v595[0] += v405;
                          v405 = v406;
                        }
                        else
                        {
                          v595[1] = v405;
                        }
                        v216 = v397 == 0;
                        v408 = 264;
                        if (v216)
                          v408 = 248;
                        v216 = v400 == 0;
                        v409 = 280;
                        if (v216)
                          v409 = v408;
                        v410 = *(__int128 **)((char *)v598 + v409);
                      }
                      *v402 = *v410;
                      if (v405 >= 0x8000)
                        kd_block_encoder::encode();
                      v413 = v595[0];
                      v414 = v594[1];
                      do
                      {
                        v595[1] = 2 * v405;
                        v595[0] = 2 * v413;
                        v594[1] = --v414;
                        if (v414)
                        {
                          v413 *= 2;
                        }
                        else
                        {
                          v415 = v594[0] + (v413 >> 26);
                          v594[0] = v415;
                          if (v415 < 255)
                          {
                            v417 = v593++;
                            *v417 = v415;
                            v594[0] = (v595[0] >> 19);
                            v413 = v595[0] & 0x7FFFF;
                            v595[0] &= 0x7FFFFu;
                            v414 = 8;
                          }
                          else
                          {
                            v416 = v593++;
                            *v416 = -1;
                            v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                            v413 = v595[0] & 0xFFFFF;
                            v595[0] &= 0xFFFFFu;
                            v414 = 7;
                          }
                          v594[1] = v414;
                        }
                        v405 = v595[1];
                      }
                      while (v595[1] < 0x8000);
                    }
                    else
                    {
                      v595[0] += v405;
                    }
                  }
                  if ((v395 & 0x400000) != 0)
                  {
                    v418 = v392[v560];
                    v419 = v395 & 0xF78;
                    if ((v395 & 0xF78) != 0)
                      v420 = 256;
                    else
                      v420 = 240;
                    if ((v395 & 0xF78) != 0)
                      v421 = &v602;
                    else
                      v421 = &v601;
                    v422 = v418 & v390;
                    if ((v418 & v390) != 0)
                      v423 = 272;
                    else
                      v423 = v420;
                    if ((v418 & v390) != 0)
                      v424 = &v603;
                    else
                      v424 = v421;
                    v425 = v418 << v389;
                    v64 += v387[v425 >> 26];
                    v426 = *(_DWORD *)((char *)v598 + v423);
                    v427 = v425 & 0x80000000 ^ v426;
                    v428 = v595[1] - v427;
                    v595[1] = v428;
                    if (v428 < 0x8000)
                    {
                      if (v427 < 0)
                      {
                        v427 = v428 & 0x7FFFFFFF;
                        v595[1] = v428 & 0x7FFFFFFF;
                        if ((v428 & 0x7FFFFFFFu) >= (v426 & 0x7FFFFFFFu))
                        {
                          v595[1] = v426 & 0x7FFFFFFF;
                          v427 = v426 & 0x7FFFFFFF;
                        }
                        else
                        {
                          v595[0] += v426 & 0x7FFFFFFF;
                        }
                        v216 = v419 == 0;
                        v432 = 264;
                        if (v216)
                          v432 = 248;
                        v216 = v422 == 0;
                        v433 = 280;
                        if (v216)
                          v433 = v432;
                        v431 = (__int128 *)(*(_QWORD *)((char *)v598 + v433) + 16);
                      }
                      else
                      {
                        if (v428 >= v427)
                        {
                          v595[0] += v427;
                          v427 = v428;
                        }
                        else
                        {
                          v595[1] = v427;
                        }
                        v216 = v419 == 0;
                        v429 = 264;
                        if (v216)
                          v429 = 248;
                        v216 = v422 == 0;
                        v430 = 280;
                        if (v216)
                          v430 = v429;
                        v431 = *(__int128 **)((char *)v598 + v430);
                      }
                      *v424 = *v431;
                      if (v427 >= 0x8000)
                        kd_block_encoder::encode();
                      v434 = v595[0];
                      v435 = v594[1];
                      do
                      {
                        v595[1] = 2 * v427;
                        v595[0] = 2 * v434;
                        v594[1] = --v435;
                        if (v435)
                        {
                          v434 *= 2;
                        }
                        else
                        {
                          v436 = v594[0] + (v434 >> 26);
                          v594[0] = v436;
                          if (v436 < 255)
                          {
                            v438 = v593++;
                            *v438 = v436;
                            v594[0] = (v595[0] >> 19);
                            v434 = v595[0] & 0x7FFFF;
                            v595[0] &= 0x7FFFFu;
                            v435 = 8;
                          }
                          else
                          {
                            v437 = v593++;
                            *v437 = -1;
                            v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                            v434 = v595[0] & 0xFFFFF;
                            v595[0] &= 0xFFFFFu;
                            v435 = 7;
                          }
                          v594[1] = v435;
                        }
                        v427 = v595[1];
                      }
                      while (v595[1] < 0x8000);
                    }
                    else
                    {
                      v595[0] += v427;
                    }
                  }
                  if ((v395 & 0x2000000) != 0)
                  {
                    v439 = v392[v590];
                    v440 = v395 & 0x7BC0;
                    if ((v395 & 0x7BC0) != 0)
                      v441 = 256;
                    else
                      v441 = 240;
                    if ((v395 & 0x7BC0) != 0)
                      v442 = &v602;
                    else
                      v442 = &v601;
                    v443 = v439 & v390;
                    if ((v439 & v390) != 0)
                      v444 = 272;
                    else
                      v444 = v441;
                    if ((v439 & v390) != 0)
                      v445 = &v603;
                    else
                      v445 = v442;
                    v446 = v439 << v389;
                    v64 += v387[v446 >> 26];
                    v447 = *(_DWORD *)((char *)v598 + v444);
                    v448 = v446 & 0x80000000 ^ v447;
                    v449 = v595[1] - v448;
                    v595[1] = v449;
                    if (v449 < 0x8000)
                    {
                      if (v448 < 0)
                      {
                        v448 = v449 & 0x7FFFFFFF;
                        v595[1] = v449 & 0x7FFFFFFF;
                        if ((v449 & 0x7FFFFFFFu) >= (v447 & 0x7FFFFFFFu))
                        {
                          v595[1] = v447 & 0x7FFFFFFF;
                          v448 = v447 & 0x7FFFFFFF;
                        }
                        else
                        {
                          v595[0] += v447 & 0x7FFFFFFF;
                        }
                        v216 = v440 == 0;
                        v453 = 264;
                        if (v216)
                          v453 = 248;
                        v216 = v443 == 0;
                        v454 = 280;
                        if (v216)
                          v454 = v453;
                        v452 = (__int128 *)(*(_QWORD *)((char *)v598 + v454) + 16);
                      }
                      else
                      {
                        if (v449 >= v448)
                        {
                          v595[0] += v448;
                          v448 = v449;
                        }
                        else
                        {
                          v595[1] = v448;
                        }
                        v216 = v440 == 0;
                        v450 = 264;
                        if (v216)
                          v450 = 248;
                        v216 = v443 == 0;
                        v451 = 280;
                        if (v216)
                          v451 = v450;
                        v452 = *(__int128 **)((char *)v598 + v451);
                      }
                      *v445 = *v452;
                      if (v448 >= 0x8000)
                        kd_block_encoder::encode();
                      v455 = v595[0];
                      v456 = v594[1];
                      do
                      {
                        v595[1] = 2 * v448;
                        v595[0] = 2 * v455;
                        v594[1] = --v456;
                        if (v456)
                        {
                          v455 *= 2;
                        }
                        else
                        {
                          v457 = v594[0] + (v455 >> 26);
                          v594[0] = v457;
                          if (v457 < 255)
                          {
                            v459 = v593++;
                            *v459 = v457;
                            v594[0] = (v595[0] >> 19);
                            v455 = v595[0] & 0x7FFFF;
                            v595[0] &= 0x7FFFFu;
                            v456 = 8;
                          }
                          else
                          {
                            v458 = v593++;
                            *v458 = -1;
                            v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                            v455 = v595[0] & 0xFFFFF;
                            v595[0] &= 0xFFFFFu;
                            v456 = 7;
                          }
                          v594[1] = v456;
                        }
                        v448 = v595[1];
                      }
                      while (v595[1] < 0x8000);
                    }
                    else
                    {
                      v595[0] += v448;
                    }
                  }
                  if ((v395 & 0x10000000) != 0)
                  {
                    v460 = v392[v591];
                    v462 = v395 & 0x3DE00;
                    v461 = (v395 & 0x3DE00) == 0;
                    if ((v395 & 0x3DE00) != 0)
                      v463 = 32;
                    else
                      v463 = 30;
                    if (v461)
                      v464 = &v601;
                    else
                      v464 = &v602;
                    v465 = v460 & v390;
                    if ((v460 & v390) != 0)
                    {
                      v463 = 34;
                      v464 = &v603;
                    }
                    v466 = v460 << v389;
                    v64 += v387[v466 >> 26];
                    v467 = v598[v463];
                    v468 = v466 & 0x80000000 ^ v467;
                    v469 = v595[1] - v468;
                    v595[1] = v469;
                    if (v469 < 0x8000)
                    {
                      if (v468 < 0)
                      {
                        v468 = v469 & 0x7FFFFFFF;
                        v595[1] = v469 & 0x7FFFFFFF;
                        if ((v469 & 0x7FFFFFFFu) >= (v467 & 0x7FFFFFFFu))
                        {
                          v595[1] = v467 & 0x7FFFFFFF;
                          v468 = v467 & 0x7FFFFFFF;
                        }
                        else
                        {
                          v595[0] += v467 & 0x7FFFFFFF;
                        }
                        v216 = v462 == 0;
                        v473 = 264;
                        if (v216)
                          v473 = 248;
                        v216 = v465 == 0;
                        v474 = 280;
                        if (v216)
                          v474 = v473;
                        v472 = (__int128 *)(*(_QWORD *)((char *)v598 + v474) + 16);
                      }
                      else
                      {
                        if (v469 >= v468)
                        {
                          v595[0] += v468;
                          v468 = v469;
                        }
                        else
                        {
                          v595[1] = v468;
                        }
                        v216 = v462 == 0;
                        v470 = 264;
                        if (v216)
                          v470 = 248;
                        v216 = v465 == 0;
                        v471 = 280;
                        if (v216)
                          v471 = v470;
                        v472 = *(__int128 **)((char *)v598 + v471);
                      }
                      *v464 = *v472;
                      if (v468 >= 0x8000)
                        kd_block_encoder::encode();
                      v475 = v595[0];
                      v476 = v594[1];
                      do
                      {
                        v595[1] = 2 * v468;
                        v595[0] = 2 * v475;
                        v594[1] = --v476;
                        if (v476)
                        {
                          v475 *= 2;
                        }
                        else
                        {
                          v477 = v594[0] + (v475 >> 26);
                          v594[0] = v477;
                          if (v477 < 255)
                          {
                            v479 = v593++;
                            *v479 = v477;
                            v594[0] = (v595[0] >> 19);
                            v475 = v595[0] & 0x7FFFF;
                            v595[0] &= 0x7FFFFu;
                            v476 = 8;
                          }
                          else
                          {
                            v478 = v593++;
                            *v478 = -1;
                            v594[0] = ((v594[0] >> 1) | 0x7F) & (v595[0] >> 20);
                            v475 = v595[0] & 0xFFFFF;
                            v595[0] &= 0xFFFFFu;
                            v476 = 7;
                          }
                          v594[1] = v476;
                        }
                        v468 = v595[1];
                      }
                      while (v595[1] < 0x8000);
                    }
                    else
                    {
                      v595[0] += v468;
                    }
                  }
                }
                else if (!v393[2])
                {
                  do
                  {
                    v394 -= 2;
                    v392 += 2;
                    v407 = v393[4];
                    v393 += 2;
                  }
                  while (!v407);
                }
                ++v392;
                ++v393;
                v206 = __OFSUB__(v394--, 1);
              }
              while (!((v394 < 0) ^ v206 | (v394 == 0)));
            }
            v393 += 3;
            v392 += v591;
            v206 = __OFSUB__(v391--, 1);
          }
          while (!((v391 < 0) ^ v206 | (v391 == 0)));
        }
        mq_encoder::check_in((uint64_t)&v596[64 * v580], v595[1], v595[0], v594[1], v594[0], v593);
      }
LABEL_835:
      v480 = v580;
      *(double *)&v604[v580] = v36 * (double)v64;
      if ((*((_BYTE *)v586 + 28) & 0x20) != 0 && v570 == 2)
      {
        mq_encoder::mq_encode_run((mq_encoder *)&v596[64 * v580], 2);
        mq_encoder::mq_encode_run((mq_encoder *)&v596[64 * v580], 2);
        v480 = v580;
      }
      v481 = v579 - 1;
      v482 = (mq_encoder *)&v596[64 * v480];
      bytes_used = mq_encoder::get_bytes_used(v482);
      if (v579 == 1)
      {
        v484 = mq_encoder::terminate(v482, (v589 & 0x10) == 0);
        v41 = 0;
        v571 = v45 + (_DWORD)v567 - (_DWORD)v484;
        v567 = v484;
      }
      else
      {
        v41 = bytes_used;
      }
      LOBYTE(v593) = 0;
      if (v580 >= v40)
      {
        v485 = (mq_encoder *)&v596[64 * (uint64_t)v40];
        v486 = 4 * v40;
        v487 = v40;
        do
        {
          *(_DWORD *)(*((_QWORD *)v586 + 7) + v486) = mq_encoder::get_incremental_length(v485, (BOOL *)&v593);
          if ((_BYTE)v593)
          {
            if (v487 != v40)
              kd_block_encoder::encode();
            ++v40;
          }
          ++v487;
          v485 = (mq_encoder *)((char *)v485 + 64);
          v486 += 4;
        }
        while (v585 != v487);
      }
      v32 = (clock_t)v586;
      if (v7 > 0.0)
      {
        v488 = 0;
        v489 = 0.0;
        v490 = 3;
        v491 = 0.0;
        v492 = 0.0;
        v493 = v580;
        v494 = 0.0;
        while (1)
        {
          if (v493 <= 6)
            v495 = 6;
          else
            v495 = v493;
          v496 = v495 - 7;
          if (v493 > v496)
          {
            v497 = 0;
            v498 = 0.0;
            v499 = 0.0;
            do
            {
              v498 = v498 + (double)*(int *)(*((_QWORD *)v586 + 7) + 4 * (v493 + v497));
              v499 = v499 + *(double *)&v604[v493 + v497];
              if (!v497 || v491 * v498 > v489 * v499)
              {
                v491 = v499;
                v489 = v498;
              }
              --v497;
            }
            while (v493 + v497 > v496);
          }
          v500 = v7 * v489;
          if ((v580 - v493) >= 3)
          {
            v501 = v490;
            do
            {
              v500 = v500 * 3.0;
              v501 -= 3;
            }
            while (v501 > 5);
          }
          if (v491 > v500)
            break;
          if (v491 > 0.0 && v489 > 0.0 && (v488 < 1 || v492 * v491 > v494 * v489))
          {
            ++v488;
            v494 = v491;
            v492 = v489;
          }
          v206 = __OFSUB__(v493--, 1);
          if (v493 < 0 == v206)
          {
            ++v490;
            if (v488 < 3)
              continue;
          }
          if (v488 < 2)
            break;
          if ((int)v580 - v493 < 3)
            break;
          v502 = v580 + 1;
          *((_DWORD *)v586 + 12) = v580 + 1;
          if (v579 < 2)
            break;
          mq_encoder::terminate(v482, (v589 & 0x10) == 0);
          if (v580 >= v40)
          {
            v531 = (mq_encoder *)&v596[64 * (uint64_t)v40];
            v532 = 4 * v40;
            do
            {
              LOBYTE(v593) = 0;
              *(_DWORD *)(*((_QWORD *)v586 + 7) + v532) = mq_encoder::get_incremental_length(v531, (BOOL *)&v593);
              if (!(_BYTE)v593)
                kd_block_encoder::encode();
              v531 = (mq_encoder *)((char *)v531 + 64);
              v532 += 4;
              ++v40;
            }
            while (v585 != v40);
            v40 = v585;
          }
          goto LABEL_875;
        }
      }
      v502 = v580 + 1;
      --v579;
      if (!v481)
      {
LABEL_875:
        if (v502 != v40)
          kd_block_encoder::encode();
        mq_encoder::finish((uint64_t)v482);
        v32 = (clock_t)v586;
        v579 = 0;
      }
      v42 = v570 + 1;
      v38 = *(int *)(v32 + 48);
      ++v585;
      v39 = v502;
      v568 = v569;
    }
    while (v502 < v38);
    v26 = v388;
    if (v579)
      kd_block_encoder::encode();
LABEL_920:
    if (v40 != (_DWORD)v38)
      kd_block_encoder::encode();
    if (v5 > 0.0 && v40 >= 1)
    {
      v533 = 0;
      v535 = *(_QWORD *)(v32 + 56);
      v534 = *(_QWORD *)(v32 + 64);
      do
      {
        v536 = v533 - 9;
        if (v533 < 9)
          v536 = 0;
        v537 = -1.0;
        v538 = 0.0;
        v539 = v533;
        v540 = 0.0;
        do
        {
          v538 = v538 + *(double *)&v604[v539];
          if (v538 <= 0.0)
            goto LABEL_939;
          v540 = v540 + (double)*(int *)(v535 + 4 * v539);
          if (v540 > 0.0 && (v537 < 0.0 || v537 * v540 > v538))
            v537 = v538 / v540;
          v20 = v539-- <= v536;
        }
        while (!v20);
        if (v537 <= 0.0)
        {
LABEL_939:
          LOWORD(v543) = 0;
          goto LABEL_940;
        }
        v541 = v537 * 2.32830644e-10;
        if (v541 > 1.0)
          v541 = 1.0;
        v542 = log(v541) * 369.32993 + 65536.0;
        if (v542 <= 65535.0)
        {
          v32 = (clock_t)v586;
          if (v542 >= 2.0)
            v543 = (int)v542;
          else
            LOWORD(v543) = 2;
        }
        else
        {
          LOWORD(v543) = -1;
          v32 = (clock_t)v586;
        }
LABEL_940:
        *(_WORD *)(v534 + 2 * v533++) = v543;
      }
      while (v533 != v40);
      v544 = 0;
      v545 = (unsigned __int16 *)(v534 + 2);
      v546 = 1;
      do
      {
        v547 = v544 + 1;
        if (v544 + 1 < (unint64_t)v40)
        {
          v548 = v545;
          v549 = v40;
          while (1)
          {
            v550 = *v548++;
            if (v550 >= *(unsigned __int16 *)(v534 + 2 * v544))
              break;
            if (v546 == --v549)
              goto LABEL_951;
          }
          *(_WORD *)(v534 + 2 * v544) = 0;
        }
LABEL_951:
        ++v546;
        ++v545;
        ++v544;
      }
      while (v547 != v40);
      if (v40 == v553 && v564 && !*(_WORD *)(v534 + 2 * v552))
        *(_WORD *)(v534 + 2 * v552) = 1;
    }
    v20 = v557-- <= 1;
    v23 = v555;
    v27 = v565 & 3;
  }
  while (!v20);
  return kdu_block::finish_timing(v32);
}

uint64_t mq_encoder::augment_buffer(uint64_t this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3;
  int64_t v4;

  v3 = *(_QWORD *)(this + 16);
  if (v3)
  {
    if (!a3 || !a2 || *(_BYTE *)(this + 33))
      mq_encoder::augment_buffer();
    v4 = *(_QWORD *)(this + 24) + a3 - a2;
    *(_QWORD *)(this + 16) = v3 + a3 - a2;
    *(_QWORD *)(this + 24) = v4;
  }
  return this;
}

__n128 mq_encoder::continues(mq_encoder *this, mq_encoder *a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  if (*((_BYTE *)this + 35) || *((_QWORD *)this + 2))
    mq_encoder::continues();
  if (!*((_BYTE *)a2 + 35))
    mq_encoder::continues();
  if (*((_BYTE *)a2 + 33))
    mq_encoder::continues();
  result = *(__n128 *)a2;
  v3 = *((_OWORD *)a2 + 1);
  v4 = *((_OWORD *)a2 + 2);
  *(_OWORD *)((char *)this + 41) = *(_OWORD *)((char *)a2 + 41);
  *((_OWORD *)this + 1) = v3;
  *((_OWORD *)this + 2) = v4;
  *(__n128 *)this = result;
  *((_QWORD *)this + 5) = a2;
  *((_QWORD *)a2 + 6) = this;
  *((_BYTE *)a2 + 35) = 0;
  return result;
}

uint64_t mq_encoder::get_bytes_used(mq_encoder *this)
{
  uint64_t v1;

  if (*((_BYTE *)this + 33) || (v1 = *((_QWORD *)this + 2)) == 0)
    mq_encoder::get_bytes_used();
  return (*((_DWORD *)this + 6) - v1);
}

uint64_t mq_encoder::get_incremental_length(mq_encoder *this, BOOL *a2)
{
  char v4;
  mq_encoder *v5;
  mq_encoder *v6;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  _DWORD *v10;

  if (*((_BYTE *)this + 36))
  {
    v4 = 1;
  }
  else
  {
    v5 = this;
    do
    {
      v6 = v5;
      v5 = (mq_encoder *)*((_QWORD *)v5 + 6);
    }
    while (v5);
    v7 = (uint64_t)v6;
    do
    {
      if (*(_BYTE *)(v7 + 36))
        break;
      if (!*(_BYTE *)(v7 + 35))
      {
        v8 = (unsigned __int8 *)*((_QWORD *)v6 + 3);
        if ((uint64_t)&v8[-*(_QWORD *)(v7 + 24)] >= 5)
          mq_encoder::find_truncation_point(v7, v8);
      }
      v7 = *(_QWORD *)(v7 + 40);
    }
    while (v7);
    v4 = *((_BYTE *)this + 36);
  }
  *a2 = v4;
  v9 = *((_QWORD *)this + 5);
  if (v9)
    v10 = (_DWORD *)(v9 + 24);
  else
    v10 = (_DWORD *)((char *)this + 16);
  return (*((_DWORD *)this + 6) - *v10);
}

uint64_t mq_encoder::finish(uint64_t this)
{
  uint64_t v1;

  if (*(_BYTE *)(this + 35) || *(_QWORD *)(this + 48))
    mq_encoder::finish();
  do
  {
    if (*(_BYTE *)(this + 35))
      mq_encoder::finish();
    v1 = *(_QWORD *)(this + 40);
    *(_BYTE *)(this + 36) = 0;
    *(_QWORD *)(this + 16) = 0;
    *(_QWORD *)(this + 24) = 0;
    *(_QWORD *)(this + 40) = 0;
    *(_QWORD *)(this + 48) = 0;
    this = v1;
  }
  while (v1);
  return this;
}

clock_t kdu_block::finish_timing(clock_t this)
{
  int *v1;
  uint64_t v2;

  if (*(_DWORD *)(this + 136))
  {
    v1 = (int *)this;
    this = clock();
    v2 = *((_QWORD *)v1 + 18);
    *((_QWORD *)v1 + 20) += this - *((_QWORD *)v1 + 19);
    *((_QWORD *)v1 + 18) = v2 + *v1 * (uint64_t)v1[1];
  }
  return this;
}

void kd_block_encoder::~kd_block_encoder(kd_block_encoder *this)
{
  *(_QWORD *)this = off_1E1BB24D0;
}

{
  *(_QWORD *)this = off_1E1BB24D0;
  JUMPOUT(0x18D761C30);
}

uint64_t mq_encoder::check_out(uint64_t this, int *a2, int *a3, int *a4, int *a5, unsigned __int8 **a6)
{
  if (!*(_BYTE *)(this + 35) || *(_BYTE *)(this + 33) || !*(_BYTE *)(this + 34))
    mq_encoder::check_out();
  *(_BYTE *)(this + 33) = 1;
  *a2 = *(_DWORD *)this;
  *a3 = *(_DWORD *)(this + 4);
  *a4 = *(_DWORD *)(this + 8);
  *a5 = *(_DWORD *)(this + 12);
  *a6 = *(unsigned __int8 **)(this + 24);
  return this;
}

uint64_t mq_encoder::check_in(uint64_t this, int a2, int a3, int a4, int a5, unsigned __int8 *a6)
{
  if (!*(_BYTE *)(this + 35) || !*(_BYTE *)(this + 33) || !*(_BYTE *)(this + 34))
    mq_encoder::check_in();
  *(_BYTE *)(this + 33) = 0;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = a3;
  *(_DWORD *)(this + 8) = a4;
  *(_DWORD *)(this + 12) = a5;
  *(_QWORD *)(this + 24) = a6;
  return this;
}

uint64_t mq_encoder::check_out(uint64_t this, int *a2, int *a3, unsigned __int8 **a4)
{
  if (!*(_BYTE *)(this + 35) || *(_BYTE *)(this + 33) || *(_BYTE *)(this + 34))
    mq_encoder::check_out();
  *(_BYTE *)(this + 33) = 1;
  *a2 = *(_DWORD *)(this + 8);
  *a3 = *(_DWORD *)(this + 12);
  *a4 = *(unsigned __int8 **)(this + 24);
  return this;
}

uint64_t mq_encoder::check_in(uint64_t this, int a2, int a3, unsigned __int8 *a4)
{
  if (!*(_BYTE *)(this + 35) || !*(_BYTE *)(this + 33) || *(_BYTE *)(this + 34))
    mq_encoder::check_in();
  *(_BYTE *)(this + 33) = 0;
  *(_DWORD *)(this + 8) = a2;
  *(_DWORD *)(this + 12) = a3;
  *(_QWORD *)(this + 24) = a4;
  return this;
}

void kdu_block_decoder::kdu_block_decoder(kdu_block_decoder *this)
{
  _QWORD *v2;

  v2 = (_QWORD *)operator new();
  *v2 = &off_1E1BB0F98;
  *(_QWORD *)this = v2;
}

clock_t kd_block_decoder::decode(kd_block_decoder *this, kdu_block *a2)
{
  kdu_block *v2;
  unsigned int v3;
  signed int v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  kdu_block *v9;
  clock_t v10;
  int v11;
  uint64_t v12;
  int32x2_t v13;
  char *v14;
  kdu_block *v15;
  char *v16;
  kdu_block *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t i;
  uint64_t v22;
  int v23;
  int *v24;
  unsigned int v25;
  int32x2_t *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  BOOL v33;
  int v34;
  unint64_t v35;
  int v36;
  int v37;
  char v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  _BOOL4 v44;
  unint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  int v49;
  unint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  int v54;
  _OWORD *v55;
  uint64_t v56;
  signed int v57;
  signed int v58;
  int v59;
  int v60;
  unsigned int v61;
  unsigned __int8 *v62;
  int v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  int v67;
  int v68;
  unsigned int *v69;
  int v70;
  unsigned int v71;
  uint64_t v72;
  _DWORD *v73;
  int v74;
  int v75;
  unsigned int *v76;
  unsigned int *v77;
  uint64_t *v78;
  _OWORD *v79;
  unsigned int *v80;
  unsigned int *v81;
  uint64_t *v82;
  int v83;
  unsigned __int8 *v84;
  unsigned int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  BOOL v91;
  int v92;
  int v93;
  BOOL v94;
  int v95;
  int v96;
  _BOOL4 v97;
  int v98;
  _OWORD *v99;
  int v100;
  unsigned __int8 *v101;
  unsigned int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  BOOL v108;
  int v109;
  int v110;
  _BOOL4 v111;
  int v112;
  unsigned __int8 *v113;
  unsigned int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  BOOL v120;
  int v121;
  int v122;
  unsigned int v123;
  unsigned int v124;
  int v125;
  int v126;
  unsigned __int8 *v127;
  unsigned int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  BOOL v134;
  int v135;
  int v136;
  unint64_t v137;
  unint64_t v138;
  _DWORD *v139;
  int v140;
  _OWORD *v141;
  _OWORD *v142;
  int v143;
  unsigned __int8 *v144;
  unsigned int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  BOOL v151;
  int v152;
  int v153;
  int v154;
  int v155;
  uint64_t v156;
  _DWORD *v157;
  int v158;
  _OWORD *v159;
  _OWORD *v160;
  int v161;
  unsigned __int8 *v162;
  unsigned int v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int v168;
  BOOL v169;
  int v170;
  int v171;
  unsigned int v172;
  unsigned int v173;
  unint64_t v174;
  unint64_t v175;
  _DWORD *v176;
  int v177;
  _OWORD *v178;
  _OWORD *v179;
  int v180;
  unsigned __int8 *v181;
  unsigned int v182;
  int v183;
  int v184;
  int v185;
  int v186;
  int v187;
  BOOL v188;
  int v189;
  int v190;
  int v191;
  uint64_t v192;
  _DWORD *v193;
  int v194;
  _OWORD *v195;
  _OWORD *v196;
  int v197;
  unsigned __int8 *v198;
  unsigned int v199;
  int v200;
  int v201;
  int v202;
  int v203;
  int v204;
  BOOL v205;
  int v206;
  int v207;
  unsigned int v208;
  unsigned int v209;
  unint64_t v210;
  unint64_t v211;
  _DWORD *v212;
  int v213;
  _OWORD *v214;
  _OWORD *v215;
  int v216;
  unsigned __int8 *v217;
  unsigned int v218;
  int v219;
  int v220;
  int v221;
  int v222;
  int v223;
  BOOL v224;
  int v225;
  int v226;
  int v227;
  uint64_t v228;
  _DWORD *v229;
  int v230;
  _OWORD *v231;
  _OWORD *v232;
  int v233;
  unsigned __int8 *v234;
  unsigned int v235;
  int v236;
  int v237;
  int v238;
  int v239;
  int v240;
  BOOL v241;
  int v242;
  int v243;
  unint64_t v244;
  unint64_t v245;
  int *v246;
  int v247;
  int v248;
  _OWORD *v249;
  _OWORD *v250;
  int v251;
  unsigned __int8 *v252;
  unsigned int v253;
  int v254;
  int v255;
  int v256;
  int v257;
  int v258;
  BOOL v259;
  int v260;
  int v261;
  int v262;
  BOOL v263;
  uint64_t v264;
  int v265;
  int v266;
  int v267;
  unsigned int v268;
  unsigned __int8 *v269;
  int v270;
  uint64_t v271;
  int v272;
  int v273;
  _DWORD *v274;
  unsigned int *v275;
  unsigned int v276;
  uint64_t v278;
  _DWORD *v279;
  int v280;
  unint64_t v281;
  unint64_t v282;
  _DWORD *v283;
  int v284;
  unsigned int v285;
  _OWORD *v286;
  _OWORD *v287;
  int v288;
  unsigned int v289;
  unsigned __int8 *v290;
  unsigned int v291;
  int v292;
  int v293;
  int v294;
  int v295;
  BOOL v296;
  int v297;
  int v298;
  unsigned int v299;
  unsigned __int8 *v300;
  unsigned int v301;
  int v302;
  int v303;
  int v304;
  int v305;
  BOOL v306;
  int v307;
  int v308;
  uint64_t v310;
  _DWORD *v311;
  int v312;
  unsigned int v313;
  unsigned int v314;
  unint64_t v315;
  unint64_t v316;
  _DWORD *v317;
  int v318;
  _OWORD *v319;
  _OWORD *v320;
  int v321;
  unsigned int v322;
  unsigned __int8 *v323;
  unsigned int v324;
  int v325;
  int v326;
  int v327;
  int v328;
  BOOL v329;
  int v330;
  int v331;
  unsigned int v332;
  unsigned __int8 *v333;
  unsigned int v334;
  int v335;
  int v336;
  int v337;
  int v338;
  BOOL v339;
  int v340;
  int v341;
  uint64_t v342;
  _DWORD *v343;
  int v344;
  unsigned int v345;
  unsigned int v346;
  unint64_t v347;
  unint64_t v348;
  _DWORD *v349;
  int v350;
  _OWORD *v351;
  _OWORD *v352;
  int v353;
  unsigned int v354;
  unsigned __int8 *v355;
  unsigned int v356;
  int v357;
  int v358;
  int v359;
  int v360;
  BOOL v361;
  int v362;
  int v363;
  unsigned int v364;
  unsigned __int8 *v365;
  unsigned int v366;
  int v367;
  int v368;
  int v369;
  int v370;
  BOOL v371;
  int v372;
  int v373;
  uint64_t v374;
  _DWORD *v375;
  int v376;
  int v377;
  unsigned int v378;
  unint64_t v379;
  unint64_t v380;
  _DWORD *v381;
  int v382;
  _OWORD *v383;
  _OWORD *v384;
  int v385;
  unsigned int v386;
  unsigned __int8 *v387;
  unsigned int v388;
  int v389;
  int v390;
  int v391;
  int v392;
  BOOL v393;
  int v394;
  int v395;
  unsigned int v396;
  unsigned __int8 *v397;
  unsigned int v398;
  int v399;
  int v400;
  int v401;
  int v402;
  BOOL v403;
  int v404;
  int v405;
  int v406;
  uint64_t v407;
  unsigned __int8 *v408;
  int v409;
  int v410;
  char *v411;
  unsigned int *v412;
  uint64_t v413;
  unsigned int v414;
  unsigned __int8 *v415;
  unsigned int v416;
  uint64_t v418;
  unsigned int v419;
  unsigned int v420;
  int v421;
  unsigned __int8 *v422;
  BOOL v423;
  unsigned int *v424;
  uint64_t v426;
  unsigned int v427;
  unsigned int v428;
  int v429;
  unsigned __int8 *v430;
  BOOL v431;
  unsigned int *v432;
  uint64_t v434;
  unsigned int *v435;
  unsigned int v436;
  unsigned int *v437;
  int v438;
  int v439;
  int v440;
  unsigned int v441;
  unsigned __int8 *v442;
  int v443;
  int v444;
  int *v445;
  unsigned int *v446;
  int v447;
  int v448;
  unsigned int v449;
  uint64_t v450;
  __int128 *v451;
  int v452;
  int v453;
  uint64_t v454;
  uint64_t v455;
  __int128 *v456;
  uint64_t v457;
  uint64_t v458;
  int v459;
  unsigned int v460;
  unsigned __int8 *v461;
  unsigned int v462;
  int v463;
  int v464;
  int v465;
  int v466;
  BOOL v467;
  int v468;
  int v469;
  unsigned int v470;
  uint64_t v471;
  __int128 *v472;
  int v473;
  int v474;
  uint64_t v475;
  uint64_t v476;
  __int128 *v477;
  uint64_t v478;
  uint64_t v479;
  int v480;
  unsigned int v481;
  unsigned __int8 *v482;
  unsigned int v483;
  int v484;
  int v485;
  int v486;
  int v487;
  BOOL v488;
  int v489;
  int v490;
  unsigned int v491;
  uint64_t v492;
  __int128 *v493;
  int v494;
  int v495;
  uint64_t v496;
  uint64_t v497;
  __int128 *v498;
  uint64_t v499;
  uint64_t v500;
  int v501;
  unsigned int v502;
  unsigned __int8 *v503;
  unsigned int v504;
  int v505;
  int v506;
  int v507;
  int v508;
  BOOL v509;
  int v510;
  int v511;
  unsigned int v512;
  BOOL v513;
  int v514;
  uint64_t v515;
  __int128 *v516;
  int v517;
  uint64_t v518;
  uint64_t v519;
  __int128 *v520;
  uint64_t v521;
  uint64_t v522;
  int v523;
  unsigned int v524;
  unsigned __int8 *v525;
  unsigned int v526;
  int v527;
  int v528;
  int v529;
  int v530;
  BOOL v531;
  int v532;
  int v533;
  unsigned int v534;
  unsigned __int8 *v535;
  int v536;
  int v537;
  _DWORD *v538;
  unsigned int *v539;
  int v540;
  unsigned __int8 *v541;
  unsigned int v542;
  unsigned int v543;
  unsigned __int8 *v544;
  unsigned int v545;
  int v546;
  int v547;
  BOOL v548;
  unsigned __int8 *v549;
  unsigned int v550;
  int v551;
  int v552;
  BOOL v553;
  unsigned __int8 *v554;
  unsigned int v555;
  int v556;
  int v557;
  BOOL v558;
  unsigned int v559;
  unsigned __int8 *v560;
  int v561;
  int v562;
  BOOL v563;
  unint64_t v564;
  int v565;
  int v566;
  uint64_t v568;
  uint64_t v569;
  size_t v570;
  size_t v571;
  int v572;
  int v573;
  int v574;
  unsigned int v575;
  int v576;
  BOOL v577;
  int v578;
  int v579;
  char *v580;
  unsigned int *v581;
  BOOL v582;
  int v583;
  unsigned __int8 *v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  uint64_t v588;
  int v589;
  int v590;
  uint64_t v591;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  int v596;
  unsigned int v597;
  uint64_t v598;
  unint64_t v599;
  uint64_t v600;
  uint64_t v601;
  int v602;
  int v603[4];
  __int128 v604;
  uint64_t v605;
  __int128 v606;
  __int128 v607;
  __int128 v608;
  _OWORD v609[9];
  __int128 v610;
  _OWORD v611[5];
  __int128 v612;
  __int128 v613;
  __int128 v614;
  uint64_t v615;

  v2 = a2;
  v615 = *MEMORY[0x1E0C80C00];
  v3 = *((_DWORD *)a2 + 1);
  v583 = *(_DWORD *)a2;
  v4 = ((*(_DWORD *)a2 + 3) & 0xFFFFFFFC) * v3;
  v5 = v3 + 3;
  v579 = (*(_DWORD *)a2 + 3) >> 2;
  v6 = (v579 + 2) * (v3 + 3);
  v600 = v3;
  if (*((_DWORD *)a2 + 28) < v4)
  {
    if (v4 <= 4096)
      v7 = 4096;
    else
      v7 = ((*(_DWORD *)a2 + 3) & 0xFFFFFFFC) * v3;
    kdu_block::set_max_samples((uint64_t)v2, v7);
    v3 = v600;
    v2 = a2;
  }
  if (*((_DWORD *)v2 + 29) <= v6)
  {
    if (v6 <= 1599)
      v8 = 1599;
    else
      v8 = v6;
    kdu_block::set_max_contexts((uint64_t)v2, v8 + 1);
    v3 = v600;
    v2 = a2;
  }
  v601 = (int)v3;
  if (*((_DWORD *)v2 + 34))
  {
    v9 = v2;
    v10 = clock();
    v3 = v600;
    *((_QWORD *)v9 + 19) = v10;
    v11 = *((_DWORD *)v9 + 34);
  }
  else
  {
    v11 = 1;
  }
  v572 = v11;
  v607 = 0u;
  v608 = 0u;
  v606 = 0u;
  v613 = 0u;
  v614 = 0u;
  v595 = (int)v5;
  v612 = 0u;
  v570 = (int)(4 * v5 * v579 + 4);
  v571 = 4 * v4;
  v568 = (int)((v579 - 1) * v5);
  memset(v611, 0, sizeof(v611));
  v610 = 0u;
  v586 = (int)(-3 - v3);
  v587 = (int)(-4 - v3);
  v585 = (int)(-2 - v3);
  v594 = (int)(v3 + 2);
  v593 = (int)(v3 + 4);
  v12 = 4 * (int)v5;
  v569 = 4 * v601 + v12 + 12;
  memset(v609, 0, sizeof(v609));
  v13 = vdup_n_s32(0x49200000u);
  v573 = v583 & 3;
  v597 = v3 + 1;
  v14 = (char *)&mq_decoder::transition_table;
  v15 = a2;
  v598 = v12;
  while (2)
  {
    v16 = v14;
LABEL_16:
    v580 = (char *)*((_QWORD *)v15 + 12);
    v17 = v15;
    bzero(v580, v571);
    v18 = *((_QWORD *)v17 + 13);
    v19 = (char *)(v18 + 4 * v595);
    v581 = (unsigned int *)(v19 + 4);
    bzero(v19, v570);
    v22 = v600;
    if ((v583 & 3) != 0)
    {
      if (v573 == 2)
        v23 = 1207959552;
      else
        v23 = 0x40000000;
      if (v573 == 1)
        v23 = 1224736768;
      if ((int)v600 >= 1)
      {
        v24 = (int *)&v581[v568];
        v25 = v597;
        do
        {
          *v24++ = v23;
          --v25;
        }
        while (v25 > 1);
      }
    }
    v14 = v16;
    if (v583 >= 1)
    {
      v26 = (int32x2_t *)(v18 + v569);
      v27 = v579 + 1;
      do
      {
        v26->i32[0] = 1226833920;
        v26[-1] = v13;
        --v27;
        v26 = (int32x2_t *)((char *)v26 + v12);
      }
      while (v27 > 1);
    }
    v15 = a2;
    v28 = *((_DWORD *)a2 + 11);
    v29 = *((_DWORD *)a2 + 10) - v28;
    if (v29 < 1)
      return kdu_block::finish_timing((clock_t)v15);
    v30 = 30 - v28;
    LODWORD(v31) = 3 * (30 - v28) - 2;
    v32 = *((_DWORD *)a2 + 12);
    if ((int)v31 >= v32)
      v31 = v32;
    else
      v31 = v31;
    v588 = v31;
    v602 = *((_DWORD *)a2 + 7);
    if ((v602 & 0x10) != 0)
    {
      if (*((_BYTE *)a2 + 37))
        v33 = 1;
      else
        v33 = *((_BYTE *)a2 + 36) != 0;
      v577 = v33;
    }
    else
    {
      v577 = 0;
    }
    v34 = 1;
    if ((int)v588 >= 1)
    {
      v591 = 0;
      v35 = 0;
      v590 = 0;
      v582 = 0;
      v36 = 0;
      v578 = 0;
      v576 = 3 * v29 - 2;
      v584 = (unsigned __int8 *)*((_QWORD *)a2 + 9);
      v37 = 2;
      do
      {
        v38 = v30 - 1;
        if (v37 == 3)
          v39 = v30 - 1;
        else
          v39 = v30;
        if (v37 == 3)
          v40 = 0;
        else
          v40 = v37;
        v596 = v40;
        v599 = v35;
        if (v36)
        {
          if (v35)
            goto LABEL_74;
        }
        else
        {
          v41 = *((_DWORD *)v15 + 7);
          if ((v41 & 1) != 0)
          {
            if (v596 == 2)
              v43 = v34;
            else
              v43 = v34 + 1;
            if (v35 <= 9)
              v43 = 10 - v35;
            v44 = v590;
            if (v35 > 9)
              v44 = v596 != 2;
            v590 = v44;
            v42 = v576;
          }
          else
          {
            v42 = v576;
            v43 = v576;
          }
          if ((v41 & 4) != 0)
            LODWORD(v45) = 1;
          else
            LODWORD(v45) = v43;
          v46 = (int)v45 + (int)v35 > (int)v588;
          if ((int)v45 + (int)v35 <= (int)v588)
            v45 = v45;
          else
            v45 = (v588 - v35);
          v47 = v45;
          v48 = (int)v588 < v42 && v46;
          v582 = v48;
          v49 = v39;
          if ((int)v47 < 1)
          {
            v51 = 0;
          }
          else
          {
            v50 = 0;
            v51 = 0;
            do
              v51 += *(_DWORD *)(*((_QWORD *)v15 + 7) + v591 + 4 * v50++);
            while (v50 < v47);
          }
          v52 = v47;
          v20 = mq_decoder::start((uint64_t)&v606, v584, v51, v34 & ~v590);
          v584 += v51;
          v578 = v599;
          v15 = a2;
          v22 = v600;
          v34 = 1;
          v14 = v16;
          v36 = v52;
          v39 = v49;
          if (v599)
          {
LABEL_74:
            if ((*((_BYTE *)v15 + 28) & 2) == 0)
              goto LABEL_78;
          }
        }
        v53 = 0;
        v54 = mq_decoder::p_bar_table[0] << 8;
        do
        {
          v55 = &v609[v53];
          *(_DWORD *)v55 = v54;
          *((_QWORD *)v55 + 1) = v14;
          ++v53;
        }
        while (v53 != 18);
        LODWORD(v609[0]) = unk_1EDF011E4 << 8;
        *((_QWORD *)&v609[0] + 1) = v14 + 256;
        LODWORD(v610) = dword_1EDF011E0 << 8;
        *((_QWORD *)&v610 + 1) = v14 + 192;
LABEL_78:
        v589 = v36;
        if (!((v37 != 3) | v590 & 1))
        {
          if (!BYTE6(v608) || BYTE4(v608) || !BYTE5(v608))
            kd_block_decoder::decode(v20, i, v22);
          v264 = *((int *)v15 + 8);
          BYTE4(v608) = v34;
          if (SDWORD1(v606) >= (int)v606 - 0x800000)
            i = (v606 - 0x800000);
          else
            i = DWORD1(v606);
          v265 = v606 - i;
          v266 = DWORD1(v606) - i;
          v267 = DWORD2(v606);
          v268 = HIDWORD(v606);
          v269 = (unsigned __int8 *)*((_QWORD *)&v607 + 1);
          v270 = v608;
          if (v583 < 1)
            goto LABEL_1494;
          v271 = (uint64_t)*(&significance_luts + v264);
          v272 = (v34 << v39) + (v34 << v39 >> 1);
          v273 = v579;
          v274 = v580;
          v275 = v581;
          while ((int)v22 < 1)
          {
LABEL_1053:
            v275 += 3;
            v20 = 3 * v601;
            v274 += 3 * v601;
            v263 = __OFSUB__(v273--, 1);
            v22 = v600;
            if ((v273 < 0) ^ v263 | (v273 == 0))
              goto LABEL_1494;
          }
          v20 = v22;
          while (2)
          {
            v276 = *v275;
            if (!*v275)
            {
              if (!v275[3])
              {
                do
                {
                  LODWORD(v20) = v20 - 3;
                  v274 += 3;
                  v285 = v275[6];
                  v275 += 3;
                }
                while (!v285);
              }
              goto LABEL_1051;
            }
            if ((v276 & 0x1EF) == 0 || (v276 & 0x200010) != 0)
              goto LABEL_754;
            v278 = *(unsigned __int8 *)(v271 + (v276 & 0x1EF));
            v279 = &v609[v278];
            v280 = *v279 & 1;
            i = (i - *v279 + v280);
            if ((int)i < 0)
            {
              v265 += i;
              v266 += i;
              i = *v279 & 0xFFFFFFFE;
              if (v266 < 0)
              {
                if (v265 >= (int)i)
                {
                  v280 = !(*(_BYTE *)v279 & 1);
                  v286 = (_OWORD *)(*((_QWORD *)&v609[v278] + 1) + 16);
                }
                else
                {
                  v286 = (_OWORD *)*((_QWORD *)&v609[v278] + 1);
                }
                v266 += i;
                *(_OWORD *)v279 = *v286;
                if ((int)i >= 0x800000)
                {
LABEL_1492:
                  v265 = i;
LABEL_1493:
                  v22 = v600;
LABEL_1494:
                  BYTE4(v608) = 0;
                  LODWORD(v606) = v265 + i;
                  DWORD1(v606) = v266 + i;
                  *((_QWORD *)&v606 + 1) = __PAIR64__(v268, v267);
                  *((_QWORD *)&v607 + 1) = v269;
                  LODWORD(v608) = v270;
                  v14 = v16;
                  goto LABEL_1609;
                }
              }
              else
              {
                if (v265 >= 0x800000)
                  goto LABEL_1493;
                if (v265 >= (int)i)
                {
                  i = *((_QWORD *)&v609[v278] + 1);
                }
                else
                {
                  v280 = !(*(_BYTE *)v279 & 1);
                  i = *((_QWORD *)&v609[v278] + 1) + 16;
                }
                *(_OWORD *)v279 = *(_OWORD *)i;
                LODWORD(i) = v265;
              }
              v288 = v270;
              do
              {
                if (!v267)
                {
                  v290 = v269 + 1;
                  v289 = *v269;
                  v291 = v266 + v289;
                  if (v289 >= 0x90)
                    v292 = 255;
                  else
                    v292 = *v269;
                  if (v289 >= 0x90)
                  {
                    v293 = v288 + 1;
                  }
                  else
                  {
                    ++v269;
                    v293 = v270;
                  }
                  if (v289 < 0x90)
                    v294 = v288;
                  else
                    v294 = v288 + 1;
                  if (v289 < 0x90)
                  {
                    v295 = 7;
                  }
                  else
                  {
                    v291 = v266;
                    v295 = 8;
                  }
                  v296 = v268 == 255;
                  if (v268 == 255)
                    v268 = v292;
                  else
                    v268 = v289;
                  if (v296)
                    v270 = v293;
                  else
                    v269 = v290;
                  if (v296)
                    v288 = v294;
                  if (v296)
                    v266 = v291;
                  if (v296)
                    v267 = v295;
                  else
                    v267 = 8;
                  v266 += v268;
                }
                v297 = 2 * i;
                v266 *= 2;
                --v267;
                v94 = (int)i < 0x400000;
                LODWORD(i) = 2 * i;
              }
              while (v94);
              LODWORD(i) = v297 - 0x800000;
              if (v266 >= v297 - 0x800000)
                i = i;
              else
                i = v266;
              v265 = v297 - i;
              v266 -= i;
              if (v280)
                goto LABEL_656;
            }
            else if (v280)
            {
LABEL_656:
              v281 = sign_lut[(*(v275 - 1) >> 2) & 4 | (v276 >> 1) & 0x41 | v275[1] & 0x10 | (((*(v275 - 1) >> 2) & 0x80004 | (v276 >> 1) & 0x820041 | v275[1] & 0x200010) >> 16)];
              v282 = v281 >> 1;
              v283 = &v611[v281 >> 1];
              v284 = *v283 & 1;
              i = (i - *v283 + v284);
              if ((int)i < 0)
              {
                v265 += i;
                v266 += i;
                i = *v283 & 0xFFFFFFFE;
                if (v266 < 0)
                {
                  if (v265 >= (int)i)
                  {
                    v284 = !(*(_BYTE *)v283 & 1);
                    v287 = (_OWORD *)(*((_QWORD *)&v611[v282] + 1) + 16);
                  }
                  else
                  {
                    v287 = (_OWORD *)*((_QWORD *)&v611[v282] + 1);
                  }
                  v266 += i;
                  *(_OWORD *)v283 = *v287;
                  if ((int)i >= 0x800000)
                    goto LABEL_1492;
                }
                else
                {
                  if (v265 >= 0x800000)
                    goto LABEL_1493;
                  if (v265 >= (int)i)
                  {
                    i = *((_QWORD *)&v611[v282] + 1);
                  }
                  else
                  {
                    v284 = !(*(_BYTE *)v283 & 1);
                    i = *((_QWORD *)&v611[v282] + 1) + 16;
                  }
                  *(_OWORD *)v283 = *(_OWORD *)i;
                  LODWORD(i) = v265;
                }
                v298 = v270;
                do
                {
                  if (!v267)
                  {
                    v300 = v269 + 1;
                    v299 = *v269;
                    v301 = v266 + v299;
                    if (v299 >= 0x90)
                      v302 = 255;
                    else
                      v302 = *v269;
                    if (v299 >= 0x90)
                    {
                      v303 = v298 + 1;
                    }
                    else
                    {
                      ++v269;
                      v303 = v270;
                    }
                    if (v299 < 0x90)
                      v304 = v298;
                    else
                      v304 = v298 + 1;
                    if (v299 < 0x90)
                    {
                      v305 = 7;
                    }
                    else
                    {
                      v301 = v266;
                      v305 = 8;
                    }
                    v306 = v268 == 255;
                    if (v268 == 255)
                      v268 = v302;
                    else
                      v268 = v299;
                    if (v306)
                      v270 = v303;
                    else
                      v269 = v300;
                    if (v306)
                      v298 = v304;
                    if (v306)
                      v266 = v301;
                    if (v306)
                      v267 = v305;
                    else
                      v267 = 8;
                    v266 += v268;
                  }
                  v307 = 2 * i;
                  v266 *= 2;
                  --v267;
                  v94 = (int)i < 0x400000;
                  LODWORD(i) = 2 * i;
                }
                while (v94);
                LODWORD(i) = v307 - 0x800000;
                if (v266 >= v307 - 0x800000)
                  i = i;
                else
                  i = v266;
                v265 = v307 - i;
                v266 -= i;
              }
              v308 = v284 ^ v281 & 1;
              if ((v602 & 8) == 0)
              {
                v275[v587] |= 0x20000u;
                v275[v586] |= (v308 << 31) | 0x10000;
                v275[v585] |= 0x8000u;
              }
              *(v275 - 1) |= 0x20u;
              v275[1] |= 8u;
              v276 |= (v308 << 21) | 0x100010;
              *v274 = (v308 << 31) + v272;
LABEL_754:
              if ((v276 & 0xF78) == 0 || (v276 & 0x1000080) != 0)
              {
LABEL_854:
                if ((v276 & 0x7BC0) != 0 && (v276 & 0x8000400) == 0)
                {
                  v342 = *(unsigned __int8 *)(v271 + ((v276 >> 6) & 0x1EFLL));
                  v343 = &v609[v342];
                  v344 = *v343 & 1;
                  i = (i - *v343 + v344);
                  if ((int)i < 0)
                  {
                    v265 += i;
                    v266 += i;
                    i = *v343 & 0xFFFFFFFE;
                    if (v266 < 0)
                    {
                      if (v265 >= (int)i)
                      {
                        v344 = !(*(_BYTE *)v343 & 1);
                        v351 = (_OWORD *)(*((_QWORD *)&v609[v342] + 1) + 16);
                      }
                      else
                      {
                        v351 = (_OWORD *)*((_QWORD *)&v609[v342] + 1);
                      }
                      v266 += i;
                      *(_OWORD *)v343 = *v351;
                      if ((int)i >= 0x800000)
                        goto LABEL_1492;
                    }
                    else
                    {
                      if (v265 >= 0x800000)
                        goto LABEL_1493;
                      if (v265 >= (int)i)
                      {
                        i = *((_QWORD *)&v609[v342] + 1);
                      }
                      else
                      {
                        v344 = !(*(_BYTE *)v343 & 1);
                        i = *((_QWORD *)&v609[v342] + 1) + 16;
                      }
                      *(_OWORD *)v343 = *(_OWORD *)i;
                      LODWORD(i) = v265;
                    }
                    v353 = v270;
                    do
                    {
                      if (!v267)
                      {
                        v355 = v269 + 1;
                        v354 = *v269;
                        v356 = v266 + v354;
                        if (v354 >= 0x90)
                          v357 = 255;
                        else
                          v357 = *v269;
                        if (v354 >= 0x90)
                        {
                          v358 = v353 + 1;
                        }
                        else
                        {
                          ++v269;
                          v358 = v270;
                        }
                        if (v354 < 0x90)
                          v359 = v353;
                        else
                          v359 = v353 + 1;
                        if (v354 < 0x90)
                        {
                          v360 = 7;
                        }
                        else
                        {
                          v356 = v266;
                          v360 = 8;
                        }
                        v361 = v268 == 255;
                        if (v268 == 255)
                          v268 = v357;
                        else
                          v268 = v354;
                        if (v361)
                          v270 = v358;
                        else
                          v269 = v355;
                        if (v361)
                          v353 = v359;
                        if (v361)
                          v266 = v356;
                        if (v361)
                          v267 = v360;
                        else
                          v267 = 8;
                        v266 += v268;
                      }
                      v362 = 2 * i;
                      v266 *= 2;
                      --v267;
                      v94 = (int)i < 0x400000;
                      LODWORD(i) = 2 * i;
                    }
                    while (v94);
                    LODWORD(i) = v362 - 0x800000;
                    if (v266 >= v362 - 0x800000)
                      i = i;
                    else
                      i = v266;
                    v265 = v362 - i;
                    v266 -= i;
                    if (!v344)
                      goto LABEL_910;
LABEL_858:
                    v345 = *(v275 - 1);
                    v346 = v275[1];
                    v347 = sign_lut[(v345 >> 8) & 4 | (v276 >> 7) & 0x41 | (v346 >> 6) & 0x10 | (((v345 >> 8) & 0x80004 | (v276 >> 7) & 0x820041 | (v346 >> 6) & 0x200010) >> 16)];
                    v348 = v347 >> 1;
                    v349 = &v611[v347 >> 1];
                    v350 = *v349 & 1;
                    i = (i - *v349 + v350);
                    if ((int)i < 0)
                    {
                      v265 += i;
                      v266 += i;
                      i = *v349 & 0xFFFFFFFE;
                      if (v266 < 0)
                      {
                        if (v265 >= (int)i)
                        {
                          v350 = !(*(_BYTE *)v349 & 1);
                          v352 = (_OWORD *)(*((_QWORD *)&v611[v348] + 1) + 16);
                        }
                        else
                        {
                          v352 = (_OWORD *)*((_QWORD *)&v611[v348] + 1);
                        }
                        v266 += i;
                        *(_OWORD *)v349 = *v352;
                        if ((int)i >= 0x800000)
                          goto LABEL_1492;
                      }
                      else
                      {
                        if (v265 >= 0x800000)
                          goto LABEL_1493;
                        if (v265 >= (int)i)
                        {
                          i = *((_QWORD *)&v611[v348] + 1);
                        }
                        else
                        {
                          v350 = !(*(_BYTE *)v349 & 1);
                          i = *((_QWORD *)&v611[v348] + 1) + 16;
                        }
                        *(_OWORD *)v349 = *(_OWORD *)i;
                        LODWORD(i) = v265;
                      }
                      v363 = v270;
                      do
                      {
                        if (!v267)
                        {
                          v365 = v269 + 1;
                          v364 = *v269;
                          v366 = v266 + v364;
                          if (v364 >= 0x90)
                            v367 = 255;
                          else
                            v367 = *v269;
                          if (v364 >= 0x90)
                          {
                            v368 = v363 + 1;
                          }
                          else
                          {
                            ++v269;
                            v368 = v270;
                          }
                          if (v364 < 0x90)
                            v369 = v363;
                          else
                            v369 = v363 + 1;
                          if (v364 < 0x90)
                          {
                            v370 = 7;
                          }
                          else
                          {
                            v366 = v266;
                            v370 = 8;
                          }
                          v371 = v268 == 255;
                          if (v268 == 255)
                            v268 = v367;
                          else
                            v268 = v364;
                          if (v371)
                            v270 = v368;
                          else
                            v269 = v365;
                          if (v371)
                            v363 = v369;
                          if (v371)
                            v266 = v366;
                          if (v371)
                            v267 = v370;
                          else
                            v267 = 8;
                          v266 += v268;
                        }
                        v372 = 2 * i;
                        v266 *= 2;
                        --v267;
                        v94 = (int)i < 0x400000;
                        LODWORD(i) = 2 * i;
                      }
                      while (v94);
                      LODWORD(i) = v372 - 0x800000;
                      if (v266 >= v372 - 0x800000)
                        i = i;
                      else
                        i = v266;
                      v265 = v372 - i;
                      v266 -= i;
                      v346 = v275[1];
                      v345 = *(v275 - 1);
                    }
                    v373 = v350 ^ v347 & 1;
                    *(v275 - 1) = v345 | 0x800;
                    v275[1] = v346 | 0x200;
                    v276 |= (v373 << 27) | 0x4000400;
                    v274[2 * v601] = v272 + (v373 << 31);
                  }
                  else
                  {
                    if (v344)
                      goto LABEL_858;
LABEL_910:
                    v276 |= 0x4000000u;
                  }
                }
                if ((v276 & 0x3DE00) != 0 && (v276 & 0x40002000) == 0)
                {
                  v374 = *(unsigned __int8 *)(v271 + ((v276 >> 9) & 0x1EFLL));
                  v375 = &v609[v374];
                  v376 = *v375 & 1;
                  i = (i - *v375 + v376);
                  if ((int)i < 0)
                  {
                    v265 += i;
                    v266 += i;
                    i = *v375 & 0xFFFFFFFE;
                    if (v266 < 0)
                    {
                      if (v265 >= (int)i)
                      {
                        v376 = !(*(_BYTE *)v375 & 1);
                        v383 = (_OWORD *)(*((_QWORD *)&v609[v374] + 1) + 16);
                      }
                      else
                      {
                        v383 = (_OWORD *)*((_QWORD *)&v609[v374] + 1);
                      }
                      v266 += i;
                      *(_OWORD *)v375 = *v383;
                      if ((int)i >= 0x800000)
                        goto LABEL_1492;
                    }
                    else
                    {
                      if (v265 >= 0x800000)
                        goto LABEL_1493;
                      if (v265 >= (int)i)
                      {
                        i = *((_QWORD *)&v609[v374] + 1);
                      }
                      else
                      {
                        v376 = !(*(_BYTE *)v375 & 1);
                        i = *((_QWORD *)&v609[v374] + 1) + 16;
                      }
                      *(_OWORD *)v375 = *(_OWORD *)i;
                      LODWORD(i) = v265;
                    }
                    v385 = v270;
                    do
                    {
                      if (!v267)
                      {
                        v387 = v269 + 1;
                        v386 = *v269;
                        v388 = v266 + v386;
                        if (v386 >= 0x90)
                          v389 = 255;
                        else
                          v389 = *v269;
                        if (v386 >= 0x90)
                        {
                          v390 = v385 + 1;
                        }
                        else
                        {
                          ++v269;
                          v390 = v270;
                        }
                        if (v386 < 0x90)
                          v391 = v385;
                        else
                          v391 = v385 + 1;
                        if (v386 < 0x90)
                        {
                          v392 = 7;
                        }
                        else
                        {
                          v388 = v266;
                          v392 = 8;
                        }
                        v393 = v268 == 255;
                        if (v268 == 255)
                          v268 = v389;
                        else
                          v268 = v386;
                        if (v393)
                          v270 = v390;
                        else
                          v269 = v387;
                        if (v393)
                          v385 = v391;
                        if (v393)
                          v266 = v388;
                        if (v393)
                          v267 = v392;
                        else
                          v267 = 8;
                        v266 += v268;
                      }
                      v394 = 2 * i;
                      v266 *= 2;
                      --v267;
                      v94 = (int)i < 0x400000;
                      LODWORD(i) = 2 * i;
                    }
                    while (v94);
                    LODWORD(i) = v394 - 0x800000;
                    if (v266 >= v394 - 0x800000)
                      i = i;
                    else
                      i = v266;
                    v265 = v394 - i;
                    v266 -= i;
                    if (!v376)
                      goto LABEL_1009;
LABEL_955:
                    v377 = (v276 >> 10) & 0x20041;
                    if ((v276 & 0x80000000) != 0)
                      v377 |= 0x800000u;
                    v378 = (*(v275 - 1) >> 11) & 0x80004 | v377 | (v275[1] >> 9) & 0x200010;
                    v379 = sign_lut[v378 & 0x55 | HIWORD(v378)];
                    v380 = v379 >> 1;
                    v381 = &v611[v379 >> 1];
                    v382 = *v381 & 1;
                    i = (i - *v381 + v382);
                    if ((int)i < 0)
                    {
                      v265 += i;
                      v266 += i;
                      i = *v381 & 0xFFFFFFFE;
                      if (v266 < 0)
                      {
                        if (v265 >= (int)i)
                        {
                          v382 = !(*(_BYTE *)v381 & 1);
                          v384 = (_OWORD *)(*((_QWORD *)&v611[v380] + 1) + 16);
                        }
                        else
                        {
                          v384 = (_OWORD *)*((_QWORD *)&v611[v380] + 1);
                        }
                        v266 += i;
                        *(_OWORD *)v381 = *v384;
                        if ((int)i >= 0x800000)
                          goto LABEL_1492;
                      }
                      else
                      {
                        if (v265 >= 0x800000)
                          goto LABEL_1493;
                        if (v265 >= (int)i)
                        {
                          i = *((_QWORD *)&v611[v380] + 1);
                        }
                        else
                        {
                          v382 = !(*(_BYTE *)v381 & 1);
                          i = *((_QWORD *)&v611[v380] + 1) + 16;
                        }
                        *(_OWORD *)v381 = *(_OWORD *)i;
                        LODWORD(i) = v265;
                      }
                      v395 = v270;
                      do
                      {
                        if (!v267)
                        {
                          v397 = v269 + 1;
                          v396 = *v269;
                          v398 = v266 + v396;
                          if (v396 >= 0x90)
                            v399 = 255;
                          else
                            v399 = *v269;
                          if (v396 >= 0x90)
                          {
                            v400 = v395 + 1;
                          }
                          else
                          {
                            ++v269;
                            v400 = v270;
                          }
                          if (v396 < 0x90)
                            v401 = v395;
                          else
                            v401 = v395 + 1;
                          if (v396 < 0x90)
                          {
                            v402 = 7;
                          }
                          else
                          {
                            v398 = v266;
                            v402 = 8;
                          }
                          v403 = v268 == 255;
                          if (v268 == 255)
                            v268 = v399;
                          else
                            v268 = v396;
                          if (v403)
                            v270 = v400;
                          else
                            v269 = v397;
                          if (v403)
                            v395 = v401;
                          if (v403)
                            v266 = v398;
                          if (v403)
                            v267 = v402;
                          else
                            v267 = 8;
                          v266 += v268;
                        }
                        v404 = 2 * i;
                        v266 *= 2;
                        --v267;
                        v94 = (int)i < 0x400000;
                        LODWORD(i) = 2 * i;
                      }
                      while (v94);
                      LODWORD(i) = v404 - 0x800000;
                      if (v266 >= v404 - 0x800000)
                        i = i;
                      else
                        i = v266;
                      v265 = v404 - i;
                      v266 -= i;
                    }
                    v405 = v382 ^ v379 & 1;
                    v275[v594] |= 4u;
                    v275[v595] |= (v405 << 18) | 2;
                    v275[v593] |= 1u;
                    *(v275 - 1) |= 0x4000u;
                    v275[1] |= 0x1000u;
                    v276 |= (v405 << 30) | 0x20002000;
                    v274[3 * v601] = v272 + (v405 << 31);
                  }
                  else
                  {
                    if (v376)
                      goto LABEL_955;
LABEL_1009:
                    v276 |= 0x20000000u;
                  }
                }
                *v275 = v276;
LABEL_1051:
                ++v274;
                ++v275;
                v263 = __OFSUB__((_DWORD)v20, 1);
                v20 = (v20 - 1);
                if (((int)v20 < 0) ^ v263 | ((_DWORD)v20 == 0))
                  goto LABEL_1053;
                continue;
              }
              v310 = *(unsigned __int8 *)(v271 + ((v276 >> 3) & 0x1EFLL));
              v311 = &v609[v310];
              v312 = *v311 & 1;
              i = (i - *v311 + v312);
              if ((int)i < 0)
              {
                v265 += i;
                v266 += i;
                i = *v311 & 0xFFFFFFFE;
                if (v266 < 0)
                {
                  if (v265 >= (int)i)
                  {
                    v312 = !(*(_BYTE *)v311 & 1);
                    v319 = (_OWORD *)(*((_QWORD *)&v609[v310] + 1) + 16);
                  }
                  else
                  {
                    v319 = (_OWORD *)*((_QWORD *)&v609[v310] + 1);
                  }
                  v266 += i;
                  *(_OWORD *)v311 = *v319;
                  if ((int)i >= 0x800000)
                    goto LABEL_1492;
                }
                else
                {
                  if (v265 >= 0x800000)
                    goto LABEL_1493;
                  if (v265 >= (int)i)
                  {
                    i = *((_QWORD *)&v609[v310] + 1);
                  }
                  else
                  {
                    v312 = !(*(_BYTE *)v311 & 1);
                    i = *((_QWORD *)&v609[v310] + 1) + 16;
                  }
                  *(_OWORD *)v311 = *(_OWORD *)i;
                  LODWORD(i) = v265;
                }
                v321 = v270;
                do
                {
                  if (!v267)
                  {
                    v323 = v269 + 1;
                    v322 = *v269;
                    v324 = v266 + v322;
                    if (v322 >= 0x90)
                      v325 = 255;
                    else
                      v325 = *v269;
                    if (v322 >= 0x90)
                    {
                      v326 = v321 + 1;
                    }
                    else
                    {
                      ++v269;
                      v326 = v270;
                    }
                    if (v322 < 0x90)
                      v327 = v321;
                    else
                      v327 = v321 + 1;
                    if (v322 < 0x90)
                    {
                      v328 = 7;
                    }
                    else
                    {
                      v324 = v266;
                      v328 = 8;
                    }
                    v329 = v268 == 255;
                    if (v268 == 255)
                      v268 = v325;
                    else
                      v268 = v322;
                    if (v329)
                      v270 = v326;
                    else
                      v269 = v323;
                    if (v329)
                      v321 = v327;
                    if (v329)
                      v266 = v324;
                    if (v329)
                      v267 = v328;
                    else
                      v267 = 8;
                    v266 += v268;
                  }
                  v330 = 2 * i;
                  v266 *= 2;
                  --v267;
                  v94 = (int)i < 0x400000;
                  LODWORD(i) = 2 * i;
                }
                while (v94);
                LODWORD(i) = v330 - 0x800000;
                if (v266 >= v330 - 0x800000)
                  i = i;
                else
                  i = v266;
                v265 = v330 - i;
                v266 -= i;
                if (v312)
                  goto LABEL_761;
              }
              else if (v312)
              {
LABEL_761:
                v313 = *(v275 - 1);
                v314 = v275[1];
                v315 = sign_lut[(v313 >> 5) & 4 | (v276 >> 4) & 0x41 | (v314 >> 3) & 0x10 | (((v313 >> 5) & 0x80004 | (v276 >> 4) & 0x820041 | (v314 >> 3) & 0x200010) >> 16)];
                v316 = v315 >> 1;
                v317 = &v611[v315 >> 1];
                v318 = *v317 & 1;
                i = (i - *v317 + v318);
                if ((int)i < 0)
                {
                  v265 += i;
                  v266 += i;
                  i = *v317 & 0xFFFFFFFE;
                  if (v266 < 0)
                  {
                    if (v265 >= (int)i)
                    {
                      v318 = !(*(_BYTE *)v317 & 1);
                      v320 = (_OWORD *)(*((_QWORD *)&v611[v316] + 1) + 16);
                    }
                    else
                    {
                      v320 = (_OWORD *)*((_QWORD *)&v611[v316] + 1);
                    }
                    v266 += i;
                    *(_OWORD *)v317 = *v320;
                    if ((int)i >= 0x800000)
                      goto LABEL_1492;
                  }
                  else
                  {
                    if (v265 >= 0x800000)
                      goto LABEL_1493;
                    if (v265 >= (int)i)
                    {
                      i = *((_QWORD *)&v611[v316] + 1);
                    }
                    else
                    {
                      v318 = !(*(_BYTE *)v317 & 1);
                      i = *((_QWORD *)&v611[v316] + 1) + 16;
                    }
                    *(_OWORD *)v317 = *(_OWORD *)i;
                    LODWORD(i) = v265;
                  }
                  v331 = v270;
                  do
                  {
                    if (!v267)
                    {
                      v333 = v269 + 1;
                      v332 = *v269;
                      v334 = v266 + v332;
                      if (v332 >= 0x90)
                        v335 = 255;
                      else
                        v335 = *v269;
                      if (v332 >= 0x90)
                      {
                        v336 = v331 + 1;
                      }
                      else
                      {
                        ++v269;
                        v336 = v270;
                      }
                      if (v332 < 0x90)
                        v337 = v331;
                      else
                        v337 = v331 + 1;
                      if (v332 < 0x90)
                      {
                        v338 = 7;
                      }
                      else
                      {
                        v334 = v266;
                        v338 = 8;
                      }
                      v339 = v268 == 255;
                      if (v268 == 255)
                        v268 = v335;
                      else
                        v268 = v332;
                      if (v339)
                        v270 = v336;
                      else
                        v269 = v333;
                      if (v339)
                        v331 = v337;
                      if (v339)
                        v266 = v334;
                      if (v339)
                        v267 = v338;
                      else
                        v267 = 8;
                      v266 += v268;
                    }
                    v340 = 2 * i;
                    v266 *= 2;
                    --v267;
                    v94 = (int)i < 0x400000;
                    LODWORD(i) = 2 * i;
                  }
                  while (v94);
                  LODWORD(i) = v340 - 0x800000;
                  if (v266 >= v340 - 0x800000)
                    i = i;
                  else
                    i = v266;
                  v265 = v340 - i;
                  v266 -= i;
                  v314 = v275[1];
                  v313 = *(v275 - 1);
                }
                v341 = v318 ^ v315 & 1;
                *(v275 - 1) = v313 | 0x100;
                v275[1] = v314 | 0x40;
                v276 |= (v341 << 24) | 0x800080;
                v274[v601] = v272 + (v341 << 31);
                goto LABEL_854;
              }
              v276 |= 0x800000u;
              goto LABEL_854;
            }
            break;
          }
          v276 |= 0x100000u;
          goto LABEL_754;
        }
        if (v37 == 3)
        {
          if (!BYTE6(v608) || BYTE4(v608) | BYTE5(v608))
            kd_block_decoder::decode();
          BYTE4(v608) = v34;
          v406 = DWORD2(v606);
          v407 = HIDWORD(v606);
          v408 = (unsigned __int8 *)*((_QWORD *)&v607 + 1);
          if (v583 < 1)
            goto LABEL_1193;
          v409 = (v34 << v38) + (v34 << v38 >> 1);
          v410 = v579;
          v411 = v580;
          v412 = v581;
LABEL_1060:
          if ((int)v22 < 1)
            goto LABEL_1191;
          v413 = 0;
          v20 = (uint64_t)v412 - 12 - 4 * v601;
          i = (uint64_t)&v412[v587];
          v414 = v597;
          v415 = v408;
          while (1)
          {
            v416 = v412[v413];
            if (v416)
              break;
LABEL_1189:
            ++v413;
            if ((int)--v414 <= 1)
            {
              v411 += v413 * 4;
              v412 = (unsigned int *)((char *)v412 + v413 * 4);
              v22 = v600;
              v34 = 1;
LABEL_1191:
              v412 += 3;
              v411 += 12 * v601;
              v263 = __OFSUB__(v410--, 1);
              if (!((v410 < 0) ^ v263 | (v410 == 0)))
                goto LABEL_1060;
LABEL_1193:
              BYTE4(v608) = 0;
              *((_QWORD *)&v606 + 1) = __PAIR64__(v407, v406);
              *((_QWORD *)&v607 + 1) = v408;
              goto LABEL_1609;
            }
          }
          if ((v416 & 0x1EF) == 0 || (v416 & 0x200010) != 0)
          {
            v418 = v407;
            goto LABEL_1103;
          }
          if (v406)
          {
            v418 = v407;
            goto LABEL_1076;
          }
          v408 = v415 + 1;
          v418 = *v415;
          if ((_DWORD)v407 == 255)
          {
            if (v418 >= 0x90)
            {
              v406 = 8;
              v418 = 255;
              v408 = v415;
              goto LABEL_1076;
            }
            v406 = 7;
          }
          else
          {
            v406 = 8;
          }
          ++v415;
LABEL_1076:
          if (((v418 >> --v406) & 1) != 0)
          {
            if (!v406)
            {
              v419 = *v415;
              if (v419 >= 0x90)
                v420 = 255;
              else
                v420 = *v415;
              if (v419 >= 0x90)
                v421 = 8;
              else
                v421 = 7;
              if (v419 >= 0x90)
                v422 = v415;
              else
                v422 = v415 + 1;
              v423 = (_DWORD)v418 == 255;
              if ((_DWORD)v418 == 255)
                v418 = v420;
              else
                v418 = *v415;
              if (v423)
                v406 = v421;
              else
                v406 = 8;
              if (v423)
                v408 = v422;
              else
                v408 = v415 + 1;
              if (v423)
                v415 = v422;
              else
                ++v415;
            }
            --v406;
            if ((v602 & 8) == 0)
            {
              *(_DWORD *)(i + v413 * 4) |= 0x20000u;
              *(_DWORD *)(v20 + v413 * 4) |= (v418 >> v406 << 31) | 0x10000;
              v412[v585 + v413] |= 0x8000u;
            }
            v424 = &v412[v413];
            *(v424 - 1) = v412[v413 - 1] | 0x20;
            v424[1] = v412[v413 + 1] | 8;
            v416 |= (((v418 >> v406) & 1) << 21) | 0x100010;
            *(_DWORD *)&v411[v413 * 4] = (v418 >> v406 << 31) + v409;
          }
          else
          {
            v416 |= 0x100000u;
          }
LABEL_1103:
          if ((v416 & 0xF78) == 0 || (v416 & 0x1000080) != 0)
          {
            v426 = v418;
            goto LABEL_1141;
          }
          if (v406)
          {
            v426 = v418;
            goto LABEL_1116;
          }
          v408 = v415 + 1;
          v426 = *v415;
          if ((_DWORD)v418 == 255)
          {
            if (v426 >= 0x90)
            {
              v406 = 8;
              v426 = 255;
              v408 = v415;
              goto LABEL_1116;
            }
            v406 = 7;
          }
          else
          {
            v406 = 8;
          }
          ++v415;
LABEL_1116:
          if (((v426 >> --v406) & 1) != 0)
          {
            if (!v406)
            {
              v427 = *v415;
              if (v427 >= 0x90)
                v428 = 255;
              else
                v428 = *v415;
              if (v427 >= 0x90)
                v429 = 8;
              else
                v429 = 7;
              if (v427 >= 0x90)
                v430 = v415;
              else
                v430 = v415 + 1;
              v431 = (_DWORD)v426 == 255;
              if ((_DWORD)v426 == 255)
                v426 = v428;
              else
                v426 = *v415;
              if (v431)
                v406 = v429;
              else
                v406 = 8;
              if (v431)
                v408 = v430;
              else
                v408 = v415 + 1;
              if (v431)
                v415 = v430;
              else
                ++v415;
            }
            --v406;
            v432 = &v412[v413];
            *(v432 - 1) = v412[v413 - 1] | 0x100;
            v432[1] = v412[v413 + 1] | 0x40;
            v416 |= (((v426 >> v406) & 1) << 24) | 0x800080;
            *(_DWORD *)&v411[4 * v601 + v413 * 4] = v409 + (v426 >> v406 << 31);
          }
          else
          {
            v416 |= 0x800000u;
          }
LABEL_1141:
          if ((v416 & 0x7BC0) == 0 || (v416 & 0x8000400) != 0)
          {
LABEL_1165:
            v434 = v426;
            goto LABEL_1166;
          }
          if (v406)
          {
            v434 = v426;
            goto LABEL_1154;
          }
          v408 = v415 + 1;
          v434 = *v415;
          if ((_DWORD)v426 == 255)
          {
            if (v434 >= 0x90)
            {
              v406 = 8;
              v434 = 255;
              v408 = v415;
              goto LABEL_1154;
            }
            v406 = 7;
          }
          else
          {
            v406 = 8;
          }
          ++v415;
LABEL_1154:
          if (((v434 >> --v406) & 1) != 0)
          {
            if (v406)
            {
              v426 = v434;
LABEL_1164:
              --v406;
              v435 = &v412[v413];
              *(v435 - 1) = v412[v413 - 1] | 0x800;
              v435[1] = v412[v413 + 1] | 0x200;
              v416 |= (((v426 >> v406) & 1) << 27) | 0x4000400;
              *(_DWORD *)&v411[8 * v601 + v413 * 4] = v409 + (v426 >> v406 << 31);
              goto LABEL_1165;
            }
            v408 = v415 + 1;
            v426 = *v415;
            if ((_DWORD)v434 == 255)
            {
              if (v426 >= 0x90)
              {
                v406 = 8;
                v426 = 255;
                v408 = v415;
                goto LABEL_1164;
              }
              v406 = 7;
            }
            else
            {
              v406 = 8;
            }
            ++v415;
            goto LABEL_1164;
          }
          v416 |= 0x4000000u;
LABEL_1166:
          if ((v416 & 0x3DE00) == 0 || (v416 & 0x40002000) != 0)
            goto LABEL_1187;
          if (v406)
          {
            v407 = v434;
            goto LABEL_1176;
          }
          v408 = v415 + 1;
          v407 = *v415;
          if ((_DWORD)v434 == 255)
          {
            if (v407 >= 0x90)
            {
              v406 = 8;
              v407 = 255;
              v408 = v415;
              goto LABEL_1176;
            }
            v406 = 7;
          }
          else
          {
            v406 = 8;
          }
          ++v415;
LABEL_1176:
          v14 = v16;
          if (((v407 >> --v406) & 1) != 0)
          {
            if (v406)
            {
              v434 = v407;
              goto LABEL_1186;
            }
            v408 = v415 + 1;
            v434 = *v415;
            if ((_DWORD)v407 == 255)
            {
              if (v434 >= 0x90)
              {
                v406 = 8;
                v434 = 255;
                v408 = v415;
                goto LABEL_1186;
              }
              v406 = 7;
            }
            else
            {
              v406 = 8;
            }
            ++v415;
LABEL_1186:
            v436 = (v434 >> --v406) & 1;
            v412[v594 + v413] |= 4u;
            *(unsigned int *)((char *)v412 + v598 + v413 * 4) |= (v436 << 18) | 2;
            v412[v593 + v413] |= 1u;
            v437 = &v412[v413];
            *(v437 - 1) = v412[v413 - 1] | 0x4000;
            v437[1] = v412[v413 + 1] | 0x1000;
            v416 |= (v436 << 30) | 0x20002000;
            *(_DWORD *)&v411[12 * v601 + v413 * 4] = v409 + (v434 >> v406 << 31);
LABEL_1187:
            v407 = v434;
            v14 = v16;
          }
          else
          {
            v416 |= 0x20000000u;
          }
          v412[v413] = v416;
          goto LABEL_1189;
        }
        if (!((v37 != 1) | v590 & 1))
        {
          if (!BYTE6(v608) || BYTE4(v608) || !BYTE5(v608))
            kd_block_decoder::decode(v20, i, v22);
          BYTE4(v608) = v34;
          if (SDWORD1(v606) >= (int)v606 - 0x800000)
            v20 = (v606 - 0x800000);
          else
            v20 = DWORD1(v606);
          v438 = v606 - v20;
          v439 = DWORD1(v606) - v20;
          v440 = DWORD2(v606);
          v441 = HIDWORD(v606);
          v442 = (unsigned __int8 *)*((_QWORD *)&v607 + 1);
          v63 = v608;
          if (v583 < 1)
            goto LABEL_1600;
          v443 = v34 << v30 >> 1;
          v444 = v579;
          v445 = (int *)v580;
          v446 = v581;
          while (1)
          {
            v447 = v600;
            if ((int)v600 >= 1)
              break;
LABEL_1489:
            v446 += 3;
            v445 += 3 * v601;
            v263 = __OFSUB__(v444--, 1);
            if ((v444 < 0) ^ v263 | (v444 == 0))
              goto LABEL_1600;
          }
          while (1)
          {
            i = *v446;
            if ((i & 0x12480000) != 0)
            {
              if ((i & 0x80000) != 0)
              {
                v448 = *v445;
                v449 = (*v445 & 0x7FFFFFFFu) >> v39;
                v450 = 16;
                if ((i & 0x1EF) == 0)
                  v450 = 15;
                v451 = &v613;
                if ((i & 0x1EF) == 0)
                  v451 = &v612;
                if (v449 >= 4)
                {
                  v450 = 17;
                  v451 = &v614;
                }
                v452 = v609[v450];
                v453 = v452 & 1;
                v20 = (v20 - v452 + v453);
                if ((int)v20 < 0)
                {
                  v438 += v20;
                  v439 += v20;
                  v20 = v452 & 0xFFFFFFFE;
                  if (v439 < 0)
                  {
                    if (v438 >= (int)v20)
                    {
                      v453 = !(v452 & 1);
                      v458 = 264;
                      if ((i & 0x1EF) == 0)
                        v458 = 248;
                      if (v449 >= 4)
                        v458 = 280;
                      v456 = (__int128 *)(*(_QWORD *)((char *)v609 + v458) + 16);
                    }
                    else
                    {
                      v455 = 264;
                      if ((i & 0x1EF) == 0)
                        v455 = 248;
                      if (v449 >= 4)
                        v455 = 280;
                      v456 = *(__int128 **)((char *)v609 + v455);
                    }
                    v439 += v20;
                    *v451 = *v456;
                    if ((int)v20 >= 0x800000)
                    {
LABEL_1599:
                      v438 = v20;
LABEL_1600:
                      BYTE4(v608) = 0;
                      LODWORD(v606) = v438 + v20;
                      DWORD1(v606) = v439 + v20;
                      *((_QWORD *)&v606 + 1) = __PAIR64__(v441, v440);
                      *((_QWORD *)&v607 + 1) = v442;
                      goto LABEL_1608;
                    }
                  }
                  else
                  {
                    if (v438 >= 0x800000)
                      goto LABEL_1600;
                    if (v438 >= (int)v20)
                    {
                      v457 = 264;
                      if ((i & 0x1EF) == 0)
                        v457 = 248;
                      if (v449 >= 4)
                        v457 = 280;
                      v20 = *(_QWORD *)((char *)v609 + v457);
                    }
                    else
                    {
                      v453 = !(v452 & 1);
                      v454 = 264;
                      if ((i & 0x1EF) == 0)
                        v454 = 248;
                      if (v449 >= 4)
                        v454 = 280;
                      v20 = *(_QWORD *)((char *)v609 + v454) + 16;
                    }
                    *v451 = *(_OWORD *)v20;
                    LODWORD(v20) = v438;
                  }
                  v459 = v63;
                  do
                  {
                    if (!v440)
                    {
                      v461 = v442 + 1;
                      v460 = *v442;
                      v462 = v439 + v460;
                      if (v460 >= 0x90)
                        v463 = 255;
                      else
                        v463 = *v442;
                      if (v460 >= 0x90)
                        v464 = v459 + 1;
                      else
                        v464 = v63;
                      if (v460 < 0x90)
                        v465 = v459;
                      else
                        v465 = v459 + 1;
                      if (v460 < 0x90)
                      {
                        ++v442;
                        v466 = 7;
                      }
                      else
                      {
                        v462 = v439;
                        v466 = 8;
                      }
                      v467 = v441 == 255;
                      if (v441 == 255)
                        v441 = v463;
                      else
                        v441 = v460;
                      if (v467)
                        v63 = v464;
                      if (v467)
                        v459 = v465;
                      v14 = v16;
                      if (v467)
                        v439 = v462;
                      if (v467)
                      {
                        v440 = v466;
                      }
                      else
                      {
                        v442 = v461;
                        v440 = 8;
                      }
                      v439 += v441;
                    }
                    v468 = 2 * v20;
                    v439 *= 2;
                    --v440;
                    v94 = (int)v20 < 0x400000;
                    LODWORD(v20) = 2 * v20;
                  }
                  while (v94);
                  LODWORD(v20) = v468 - 0x800000;
                  if (v439 >= v468 - 0x800000)
                    v20 = v20;
                  else
                    v20 = v439;
                  v438 = v468 - v20;
                  v439 -= v20;
                }
                *v445 = ((v453 ^ 1) << v39) ^ v448 | v443;
              }
              if ((i & 0x400000) != 0)
              {
                v469 = v445[v601];
                v470 = (v469 & 0x7FFFFFFFu) >> v39;
                v471 = 16;
                if ((i & 0xF78) == 0)
                  v471 = 15;
                v472 = &v613;
                if ((i & 0xF78) == 0)
                  v472 = &v612;
                if (v470 >= 4)
                {
                  v471 = 17;
                  v472 = &v614;
                }
                v473 = v609[v471];
                v474 = v473 & 1;
                v20 = (v20 - v473 + v474);
                if ((int)v20 < 0)
                {
                  v438 += v20;
                  v439 += v20;
                  v20 = v473 & 0xFFFFFFFE;
                  if (v439 < 0)
                  {
                    if (v438 >= (int)v20)
                    {
                      v474 = !(v473 & 1);
                      v479 = 264;
                      if ((i & 0xF78) == 0)
                        v479 = 248;
                      if (v470 >= 4)
                        v479 = 280;
                      v477 = (__int128 *)(*(_QWORD *)((char *)v609 + v479) + 16);
                    }
                    else
                    {
                      v476 = 264;
                      if ((i & 0xF78) == 0)
                        v476 = 248;
                      if (v470 >= 4)
                        v476 = 280;
                      v477 = *(__int128 **)((char *)v609 + v476);
                    }
                    v439 += v20;
                    *v472 = *v477;
                    if ((int)v20 >= 0x800000)
                      goto LABEL_1599;
                  }
                  else
                  {
                    if (v438 >= 0x800000)
                      goto LABEL_1600;
                    if (v438 >= (int)v20)
                    {
                      v478 = 264;
                      if ((i & 0xF78) == 0)
                        v478 = 248;
                      if (v470 >= 4)
                        v478 = 280;
                      v20 = *(_QWORD *)((char *)v609 + v478);
                    }
                    else
                    {
                      v474 = !(v473 & 1);
                      v475 = 264;
                      if ((i & 0xF78) == 0)
                        v475 = 248;
                      if (v470 >= 4)
                        v475 = 280;
                      v20 = *(_QWORD *)((char *)v609 + v475) + 16;
                    }
                    *v472 = *(_OWORD *)v20;
                    LODWORD(v20) = v438;
                  }
                  v480 = v63;
                  do
                  {
                    if (!v440)
                    {
                      v482 = v442 + 1;
                      v481 = *v442;
                      v483 = v439 + v481;
                      if (v481 >= 0x90)
                        v484 = 255;
                      else
                        v484 = *v442;
                      if (v481 >= 0x90)
                        v485 = v480 + 1;
                      else
                        v485 = v63;
                      if (v481 < 0x90)
                        v486 = v480;
                      else
                        v486 = v480 + 1;
                      if (v481 < 0x90)
                      {
                        ++v442;
                        v487 = 7;
                      }
                      else
                      {
                        v483 = v439;
                        v487 = 8;
                      }
                      v488 = v441 == 255;
                      if (v441 == 255)
                        v441 = v484;
                      else
                        v441 = v481;
                      if (v488)
                        v63 = v485;
                      if (v488)
                        v480 = v486;
                      v14 = v16;
                      if (v488)
                        v439 = v483;
                      if (v488)
                      {
                        v440 = v487;
                      }
                      else
                      {
                        v442 = v482;
                        v440 = 8;
                      }
                      v439 += v441;
                    }
                    v489 = 2 * v20;
                    v439 *= 2;
                    --v440;
                    v94 = (int)v20 < 0x400000;
                    LODWORD(v20) = 2 * v20;
                  }
                  while (v94);
                  LODWORD(v20) = v489 - 0x800000;
                  if (v439 >= v489 - 0x800000)
                    v20 = v20;
                  else
                    v20 = v439;
                  v438 = v489 - v20;
                  v439 -= v20;
                }
                v445[v601] = ((v474 ^ 1) << v39) ^ v469 | v443;
              }
              if ((i & 0x2000000) != 0)
              {
                v490 = v445[2 * v601];
                v491 = (v490 & 0x7FFFFFFFu) >> v39;
                v492 = 16;
                if ((i & 0x7BC0) == 0)
                  v492 = 15;
                v493 = &v613;
                if ((i & 0x7BC0) == 0)
                  v493 = &v612;
                if (v491 >= 4)
                {
                  v492 = 17;
                  v493 = &v614;
                }
                v494 = v609[v492];
                v495 = v494 & 1;
                v20 = (v20 - v494 + v495);
                if ((int)v20 < 0)
                {
                  v438 += v20;
                  v439 += v20;
                  v20 = v494 & 0xFFFFFFFE;
                  if (v439 < 0)
                  {
                    if (v438 >= (int)v20)
                    {
                      v495 = !(v494 & 1);
                      v500 = 264;
                      if ((i & 0x7BC0) == 0)
                        v500 = 248;
                      if (v491 >= 4)
                        v500 = 280;
                      v498 = (__int128 *)(*(_QWORD *)((char *)v609 + v500) + 16);
                    }
                    else
                    {
                      v497 = 264;
                      if ((i & 0x7BC0) == 0)
                        v497 = 248;
                      if (v491 >= 4)
                        v497 = 280;
                      v498 = *(__int128 **)((char *)v609 + v497);
                    }
                    v439 += v20;
                    *v493 = *v498;
                    if ((int)v20 >= 0x800000)
                      goto LABEL_1599;
                  }
                  else
                  {
                    if (v438 >= 0x800000)
                      goto LABEL_1600;
                    if (v438 >= (int)v20)
                    {
                      v499 = 264;
                      if ((i & 0x7BC0) == 0)
                        v499 = 248;
                      if (v491 >= 4)
                        v499 = 280;
                      v20 = *(_QWORD *)((char *)v609 + v499);
                    }
                    else
                    {
                      v495 = !(v494 & 1);
                      v496 = 264;
                      if ((i & 0x7BC0) == 0)
                        v496 = 248;
                      if (v491 >= 4)
                        v496 = 280;
                      v20 = *(_QWORD *)((char *)v609 + v496) + 16;
                    }
                    *v493 = *(_OWORD *)v20;
                    LODWORD(v20) = v438;
                  }
                  v501 = v63;
                  do
                  {
                    if (!v440)
                    {
                      v503 = v442 + 1;
                      v502 = *v442;
                      v504 = v439 + v502;
                      if (v502 >= 0x90)
                        v505 = 255;
                      else
                        v505 = *v442;
                      if (v502 >= 0x90)
                        v506 = v501 + 1;
                      else
                        v506 = v63;
                      if (v502 < 0x90)
                        v507 = v501;
                      else
                        v507 = v501 + 1;
                      if (v502 < 0x90)
                      {
                        ++v442;
                        v508 = 7;
                      }
                      else
                      {
                        v504 = v439;
                        v508 = 8;
                      }
                      v509 = v441 == 255;
                      if (v441 == 255)
                        v441 = v505;
                      else
                        v441 = v502;
                      if (v509)
                        v63 = v506;
                      if (v509)
                        v501 = v507;
                      v14 = v16;
                      if (v509)
                        v439 = v504;
                      if (v509)
                      {
                        v440 = v508;
                      }
                      else
                      {
                        v442 = v503;
                        v440 = 8;
                      }
                      v439 += v441;
                    }
                    v510 = 2 * v20;
                    v439 *= 2;
                    --v440;
                    v94 = (int)v20 < 0x400000;
                    LODWORD(v20) = 2 * v20;
                  }
                  while (v94);
                  LODWORD(v20) = v510 - 0x800000;
                  if (v439 >= v510 - 0x800000)
                    v20 = v20;
                  else
                    v20 = v439;
                  v438 = v510 - v20;
                  v439 -= v20;
                }
                v445[2 * v601] = ((v495 ^ 1) << v39) ^ v490 | v443;
              }
              if ((i & 0x10000000) != 0)
              {
                v511 = v445[3 * v601];
                v512 = (v511 & 0x7FFFFFFFu) >> v39;
                v514 = i & 0x3DE00;
                v513 = (i & 0x3DE00) == 0;
                v515 = 16;
                if (v513)
                  v515 = 15;
                v516 = &v613;
                if (v513)
                  v516 = &v612;
                if (v512 >= 4)
                {
                  v515 = 17;
                  v516 = &v614;
                }
                v517 = v609[v515];
                i = v517 & 1;
                v20 = (v20 - v517 + i);
                if ((int)v20 < 0)
                {
                  v438 += v20;
                  v439 += v20;
                  v20 = v517 & 0xFFFFFFFE;
                  if (v439 < 0)
                  {
                    if (v438 >= (int)v20)
                    {
                      i = !(v517 & 1);
                      v522 = 264;
                      if (!v514)
                        v522 = 248;
                      if (v512 >= 4)
                        v522 = 280;
                      v520 = (__int128 *)(*(_QWORD *)((char *)v609 + v522) + 16);
                    }
                    else
                    {
                      v519 = 264;
                      if (!v514)
                        v519 = 248;
                      if (v512 >= 4)
                        v519 = 280;
                      v520 = *(__int128 **)((char *)v609 + v519);
                    }
                    v439 += v20;
                    *v516 = *v520;
                    if ((int)v20 >= 0x800000)
                      goto LABEL_1599;
                  }
                  else
                  {
                    if (v438 >= 0x800000)
                      goto LABEL_1600;
                    if (v438 >= (int)v20)
                    {
                      v521 = 264;
                      if (!v514)
                        v521 = 248;
                      if (v512 >= 4)
                        v521 = 280;
                      v20 = *(_QWORD *)((char *)v609 + v521);
                    }
                    else
                    {
                      LODWORD(i) = !(v517 & 1);
                      v518 = 264;
                      if (!v514)
                        v518 = 248;
                      if (v512 >= 4)
                        v518 = 280;
                      v20 = *(_QWORD *)((char *)v609 + v518) + 16;
                    }
                    *v516 = *(_OWORD *)v20;
                    LODWORD(v20) = v438;
                  }
                  v523 = v63;
                  do
                  {
                    if (!v440)
                    {
                      v525 = v442 + 1;
                      v524 = *v442;
                      v526 = v439 + v524;
                      if (v524 >= 0x90)
                        v527 = 255;
                      else
                        v527 = *v442;
                      if (v524 >= 0x90)
                        v528 = v523 + 1;
                      else
                        v528 = v63;
                      if (v524 < 0x90)
                        v529 = v523;
                      else
                        v529 = v523 + 1;
                      if (v524 < 0x90)
                      {
                        ++v442;
                        v530 = 7;
                      }
                      else
                      {
                        v526 = v439;
                        v530 = 8;
                      }
                      v531 = v441 == 255;
                      if (v441 == 255)
                        v441 = v527;
                      else
                        v441 = v524;
                      if (v531)
                        v63 = v528;
                      if (v531)
                        v523 = v529;
                      if (v531)
                        v439 = v526;
                      if (v531)
                      {
                        v440 = v530;
                      }
                      else
                      {
                        v442 = v525;
                        v440 = 8;
                      }
                      v14 = v16;
                      v439 += v441;
                    }
                    v532 = 2 * v20;
                    v439 *= 2;
                    --v440;
                    v94 = (int)v20 < 0x400000;
                    LODWORD(v20) = 2 * v20;
                  }
                  while (v94);
                  LODWORD(v20) = v532 - 0x800000;
                  if (v439 >= v532 - 0x800000)
                    v20 = v20;
                  else
                    v20 = v439;
                  v438 = v532 - v20;
                  v439 -= v20;
                }
                i = ((i ^ 1) << v39) ^ v511 | v443;
                v445[3 * v601] = i;
              }
            }
            else
            {
              for (i = v446[2]; !(_DWORD)i; v446 += 2)
              {
                v447 -= 2;
                v445 += 2;
                i = v446[4];
              }
            }
            ++v445;
            ++v446;
            v263 = __OFSUB__(v447--, 1);
            if ((v447 < 0) ^ v263 | (v447 == 0))
              goto LABEL_1489;
          }
        }
        if (v37 == 1)
        {
          if (!BYTE6(v608) || BYTE4(v608) | BYTE5(v608))
            kd_block_decoder::decode();
          BYTE4(v608) = v34;
          v533 = DWORD2(v606);
          v534 = HIDWORD(v606);
          v535 = (unsigned __int8 *)*((_QWORD *)&v607 + 1);
          if (v583 < 1)
          {
LABEL_1598:
            BYTE4(v608) = 0;
            *((_QWORD *)&v606 + 1) = __PAIR64__(v534, v533);
            *((_QWORD *)&v607 + 1) = v535;
            goto LABEL_1609;
          }
          v536 = v34 << v30 >> 1;
          v537 = v579;
          v538 = v580;
          v539 = v581;
          while ((int)v22 < 1)
          {
LABEL_1596:
            v539 += 3;
            v538 += 3 * v601;
            v263 = __OFSUB__(v537--, 1);
            if ((v537 < 0) ^ v263 | (v537 == 0))
              goto LABEL_1598;
          }
          v540 = v22;
          v541 = v535;
          while (2)
          {
            v542 = *v539;
            v20 = 306708480;
            if ((*v539 & 0x12480000) == 0)
            {
              if (!v539[2])
              {
                do
                {
                  v540 -= 2;
                  v538 += 2;
                  v543 = v539[4];
                  v539 += 2;
                }
                while (!v543);
              }
              goto LABEL_1594;
            }
            if ((v542 & 0x80000) != 0)
            {
              if (!v533)
              {
                v544 = v541 + 1;
                v545 = *v541;
                if (v545 >= 0x90)
                  v546 = 255;
                else
                  v546 = *v541;
                if (v545 >= 0x90)
                  v547 = 8;
                else
                  v547 = 7;
                if (v545 < 0x90)
                  ++v541;
                v548 = v534 == 255;
                if (v534 == 255)
                  v534 = v546;
                else
                  v534 = v545;
                if (v548)
                  v533 = v547;
                else
                  v533 = 8;
                if (v548)
                  v535 = v541;
                else
                  v535 = v544;
                if (!v548)
                  v541 = v544;
              }
              --v533;
              i = *v538;
              v20 = ((v34 & ~(v534 >> v533)) << v39) ^ i | v536;
              *v538 = v20;
              if ((v542 & 0x400000) != 0)
                goto LABEL_1531;
LABEL_1504:
              if ((v542 & 0x2000000) == 0)
                goto LABEL_1505;
LABEL_1552:
              if (!v533)
              {
                v554 = v541 + 1;
                v555 = *v541;
                if (v555 >= 0x90)
                  v556 = 255;
                else
                  v556 = *v541;
                if (v555 >= 0x90)
                  v557 = 8;
                else
                  v557 = 7;
                if (v555 < 0x90)
                  ++v541;
                v558 = v534 == 255;
                if (v534 == 255)
                  v534 = v556;
                else
                  v534 = v555;
                if (v558)
                  v533 = v557;
                else
                  v533 = 8;
                if (v558)
                  v535 = v541;
                else
                  v535 = v554;
                if (!v558)
                  v541 = v554;
              }
              --v533;
              i = v538[2 * v601];
              v20 = ((v34 & ~(v534 >> v533)) << v39) ^ i | v536;
              v538[2 * v601] = v20;
              if ((v542 & 0x10000000) == 0)
              {
LABEL_1594:
                ++v538;
                ++v539;
                v263 = __OFSUB__(v540--, 1);
                if ((v540 < 0) ^ v263 | (v540 == 0))
                  goto LABEL_1596;
                continue;
              }
            }
            else
            {
              if ((v542 & 0x400000) == 0)
                goto LABEL_1504;
LABEL_1531:
              if (!v533)
              {
                v549 = v541 + 1;
                v550 = *v541;
                if (v550 >= 0x90)
                  v551 = 255;
                else
                  v551 = *v541;
                if (v550 >= 0x90)
                  v552 = 8;
                else
                  v552 = 7;
                if (v550 < 0x90)
                  ++v541;
                v553 = v534 == 255;
                if (v534 == 255)
                  v534 = v551;
                else
                  v534 = v550;
                if (v553)
                  v533 = v552;
                else
                  v533 = 8;
                if (v553)
                  v535 = v541;
                else
                  v535 = v549;
                if (!v553)
                  v541 = v549;
              }
              --v533;
              i = v538[v601];
              v20 = ((v34 & ~(v534 >> v533)) << v39) ^ i | v536;
              v538[v601] = v20;
              if ((v542 & 0x2000000) != 0)
                goto LABEL_1552;
LABEL_1505:
              if ((v542 & 0x10000000) == 0)
                goto LABEL_1594;
            }
            break;
          }
          if (!v533)
          {
            v560 = v541 + 1;
            v559 = *v541;
            if (v559 >= 0x90)
              v561 = 255;
            else
              v561 = *v541;
            if (v559 >= 0x90)
              v562 = 8;
            else
              v562 = 7;
            if (v559 < 0x90)
              ++v541;
            v563 = v534 == 255;
            if (v534 == 255)
              v534 = v561;
            else
              v534 = v559;
            if (v563)
              v533 = v562;
            else
              v533 = 8;
            if (v563)
              v535 = v541;
            else
              v535 = v560;
            if (!v563)
              v541 = v560;
          }
          --v533;
          i = 3 * v601;
          v20 = v538[3 * v601];
          v538[3 * v601] = ((v34 & ~(v534 >> v533)) << v39) ^ v20 | v536;
          goto LABEL_1594;
        }
        if (!BYTE6(v608) || BYTE4(v608) || !BYTE5(v608))
          kd_block_decoder::decode(v20, i, v22);
        v20 = (uint64_t)v609;
        v56 = *((int *)v15 + 8);
        BYTE4(v608) = v34;
        if (SDWORD1(v606) >= (int)v606 - 0x800000)
          v57 = v606 - 0x800000;
        else
          v57 = DWORD1(v606);
        v58 = v606 - v57;
        v59 = DWORD1(v606) - v57;
        v60 = DWORD2(v606);
        v61 = HIDWORD(v606);
        v62 = (unsigned __int8 *)*((_QWORD *)&v607 + 1);
        v63 = v608;
        v64 = *((_QWORD *)&v610 + 1);
        v575 = DWORD1(v610);
        v65 = v610;
        if (v583 < 1)
          goto LABEL_1607;
        v66 = (uint64_t)*(&significance_luts + v56);
        v67 = (v34 << v30) + (v34 << v30 >> 1);
        v68 = v579;
        i = (uint64_t)v580;
        v69 = v581;
        while (1)
        {
          v574 = v68;
          if ((int)v600 >= 1)
            break;
LABEL_636:
          v69 += 3;
          i += 12 * v601;
          v68 = v574 - 1;
          if (v574 <= 1)
            goto LABEL_1607;
        }
        v70 = v600;
        while (1)
        {
          v71 = *v69;
          if (*v69)
          {
LABEL_93:
            if ((v71 & 0x300010) != 0)
              goto LABEL_341;
            v72 = *(unsigned __int8 *)(v66 + (v71 & 0x1EF));
            v73 = &v609[v72];
            v74 = *v73 & 1;
            v57 = v57 - *v73 + v74;
            if (v57 < 0)
            {
              v58 += v57;
              v59 += v57;
              v57 = *v73 & 0xFFFFFFFE;
              if (v59 < 0)
              {
                if (v58 >= v57)
                {
                  v74 = !(*(_BYTE *)v73 & 1);
                  v99 = (_OWORD *)(*((_QWORD *)&v609[v72] + 1) + 16);
                }
                else
                {
                  v99 = (_OWORD *)*((_QWORD *)&v609[v72] + 1);
                }
                v59 += v57;
                *(_OWORD *)v73 = *v99;
                if (v57 >= 0x800000)
                  goto LABEL_1601;
              }
              else
              {
                if (v58 >= 0x800000)
                  goto LABEL_1607;
                if (v58 >= v57)
                {
                  v79 = (_OWORD *)*((_QWORD *)&v609[v72] + 1);
                }
                else
                {
                  v74 = !(*(_BYTE *)v73 & 1);
                  v79 = (_OWORD *)(*((_QWORD *)&v609[v72] + 1) + 16);
                }
                *(_OWORD *)v73 = *v79;
                v57 = v58;
              }
              v126 = v63;
              do
              {
                if (!v60)
                {
                  v127 = v62 + 1;
                  v128 = *v62;
                  v129 = v59 + v128;
                  if (v128 >= 0x90)
                    v130 = 255;
                  else
                    v130 = *v62;
                  if (v128 >= 0x90)
                  {
                    v131 = v126 + 1;
                  }
                  else
                  {
                    ++v62;
                    v131 = v63;
                  }
                  if (v128 < 0x90)
                    v132 = v126;
                  else
                    v132 = v126 + 1;
                  if (v128 < 0x90)
                  {
                    v133 = 7;
                  }
                  else
                  {
                    v129 = v59;
                    v133 = 8;
                  }
                  v134 = v61 == 255;
                  if (v61 == 255)
                    v61 = v130;
                  else
                    v61 = v128;
                  if (v134)
                    v63 = v131;
                  else
                    v62 = v127;
                  if (v134)
                    v126 = v132;
                  if (v134)
                    v135 = v129;
                  else
                    v135 = v59;
                  if (v134)
                    v60 = v133;
                  else
                    v60 = 8;
                  v59 = v135 + v61;
                }
                v136 = 2 * v57;
                v59 *= 2;
                --v60;
                v94 = v57 < 0x400000;
                v57 *= 2;
              }
              while (v94);
              if (v59 >= v136 - 0x800000)
                v57 = v136 - 0x800000;
              else
                v57 = v59;
              v58 = v136 - v57;
              v59 -= v57;
              if (v74)
                goto LABEL_291;
            }
            else
            {
              if (!v74)
                goto LABEL_341;
LABEL_291:
              v137 = sign_lut[(*(v69 - 1) >> 2) & 4 | (v71 >> 1) & 0x41 | v69[1] & 0x10 | (((*(v69 - 1) >> 2) & 0x80004 | (v71 >> 1) & 0x820041 | v69[1] & 0x200010) >> 16)];
              v138 = v137 >> 1;
              v139 = &v611[v137 >> 1];
              v140 = *v139 & 1;
              v57 = v57 - *v139 + v140;
              if (v57 < 0)
              {
                v58 += v57;
                v59 += v57;
                v57 = *v139 & 0xFFFFFFFE;
                v34 = 1;
                v14 = v16;
                if (v59 < 0)
                {
                  if (v58 >= v57)
                  {
                    v140 = !(*(_BYTE *)v139 & 1);
                    v142 = (_OWORD *)(*((_QWORD *)&v611[v138] + 1) + 16);
                  }
                  else
                  {
                    v142 = (_OWORD *)*((_QWORD *)&v611[v138] + 1);
                  }
                  v59 += v57;
                  *(_OWORD *)v139 = *v142;
                  if (v57 >= 0x800000)
                    goto LABEL_1601;
                }
                else
                {
                  if (v58 >= 0x800000)
                    goto LABEL_1607;
                  if (v58 >= v57)
                  {
                    v141 = (_OWORD *)*((_QWORD *)&v611[v138] + 1);
                  }
                  else
                  {
                    v140 = !(*(_BYTE *)v139 & 1);
                    v141 = (_OWORD *)(*((_QWORD *)&v611[v138] + 1) + 16);
                  }
                  *(_OWORD *)v139 = *v141;
                  v57 = v58;
                }
                v143 = v63;
                do
                {
                  if (!v60)
                  {
                    v144 = v62 + 1;
                    v145 = *v62;
                    v146 = v59 + v145;
                    if (v145 >= 0x90)
                      v147 = 255;
                    else
                      v147 = *v62;
                    if (v145 >= 0x90)
                    {
                      v148 = v143 + 1;
                    }
                    else
                    {
                      ++v62;
                      v148 = v63;
                    }
                    if (v145 < 0x90)
                      v149 = v143;
                    else
                      v149 = v143 + 1;
                    if (v145 < 0x90)
                    {
                      v150 = 7;
                    }
                    else
                    {
                      v146 = v59;
                      v150 = 8;
                    }
                    v151 = v61 == 255;
                    if (v61 == 255)
                      v61 = v147;
                    else
                      v61 = v145;
                    if (v151)
                      v63 = v148;
                    else
                      v62 = v144;
                    if (v151)
                      v143 = v149;
                    if (v151)
                      v152 = v146;
                    else
                      v152 = v59;
                    if (v151)
                      v60 = v150;
                    else
                      v60 = 8;
                    v59 = v152 + v61;
                  }
                  v153 = 2 * v57;
                  v59 *= 2;
                  --v60;
                  v94 = v57 < 0x400000;
                  v57 *= 2;
                }
                while (v94);
                if (v59 >= v153 - 0x800000)
                  v57 = v153 - 0x800000;
                else
                  v57 = v59;
                v58 = v153 - v57;
                v59 -= v57;
              }
              v154 = v140 ^ v137 & 1;
              if ((v602 & 8) != 0)
              {
                v155 = v154 << 31;
              }
              else
              {
                v69[v587] |= 0x20000u;
                v69[v586] |= (v154 << 31) | 0x10000;
                v155 = v154 << 31;
                v69[v585] |= 0x8000u;
              }
              *(v69 - 1) |= 0x20u;
              v69[1] |= 8u;
              v71 |= (v154 << 21) | 0x10;
              *(_DWORD *)i = v155 + v67;
            }
LABEL_341:
            if ((v71 & 0x1800080) == 0)
            {
              v156 = *(unsigned __int8 *)(v66 + ((v71 >> 3) & 0x1EFLL));
              v157 = &v609[v156];
              v158 = *v157 & 1;
              v57 = v57 - *v157 + v158;
              if (v57 < 0)
              {
                v58 += v57;
                v59 += v57;
                v57 = *v157 & 0xFFFFFFFE;
                v34 = 1;
                v14 = v16;
                if (v59 < 0)
                {
                  if (v58 >= v57)
                  {
                    v158 = !(*(_BYTE *)v157 & 1);
                    v160 = (_OWORD *)(*((_QWORD *)&v609[v156] + 1) + 16);
                  }
                  else
                  {
                    v160 = (_OWORD *)*((_QWORD *)&v609[v156] + 1);
                  }
                  v59 += v57;
                  *(_OWORD *)v157 = *v160;
                  if (v57 >= 0x800000)
                    goto LABEL_1601;
                }
                else
                {
                  if (v58 >= 0x800000)
                    goto LABEL_1607;
                  if (v58 >= v57)
                  {
                    v159 = (_OWORD *)*((_QWORD *)&v609[v156] + 1);
                  }
                  else
                  {
                    v158 = !(*(_BYTE *)v157 & 1);
                    v159 = (_OWORD *)(*((_QWORD *)&v609[v156] + 1) + 16);
                  }
                  *(_OWORD *)v157 = *v159;
                  v57 = v58;
                }
                v161 = v63;
                do
                {
                  if (!v60)
                  {
                    v162 = v62 + 1;
                    v163 = *v62;
                    v164 = v59 + v163;
                    if (v163 >= 0x90)
                      v165 = 255;
                    else
                      v165 = *v62;
                    if (v163 >= 0x90)
                    {
                      v166 = v161 + 1;
                    }
                    else
                    {
                      ++v62;
                      v166 = v63;
                    }
                    if (v163 < 0x90)
                      v167 = v161;
                    else
                      v167 = v161 + 1;
                    if (v163 < 0x90)
                    {
                      v168 = 7;
                    }
                    else
                    {
                      v164 = v59;
                      v168 = 8;
                    }
                    v169 = v61 == 255;
                    if (v61 == 255)
                      v61 = v165;
                    else
                      v61 = v163;
                    if (v169)
                      v63 = v166;
                    else
                      v62 = v162;
                    if (v169)
                      v161 = v167;
                    if (v169)
                      v170 = v164;
                    else
                      v170 = v59;
                    if (v169)
                      v60 = v168;
                    else
                      v60 = 8;
                    v59 = v170 + v61;
                  }
                  v171 = 2 * v57;
                  v59 *= 2;
                  --v60;
                  v94 = v57 < 0x400000;
                  v57 *= 2;
                }
                while (v94);
                if (v59 >= v171 - 0x800000)
                  v57 = v171 - 0x800000;
                else
                  v57 = v59;
                v58 = v171 - v57;
                v59 -= v57;
              }
              v123 = v71;
              if (v158)
              {
LABEL_389:
                v172 = *(v69 - 1);
                v173 = v69[1];
                v174 = sign_lut[(v172 >> 5) & 4 | (v123 >> 4) & 0x41 | (v173 >> 3) & 0x10 | (((v172 >> 5) & 0x80004 | (v123 >> 4) & 0x820041 | (v173 >> 3) & 0x200010) >> 16)];
                v175 = v174 >> 1;
                v176 = &v611[v174 >> 1];
                v177 = *v176 & 1;
                v57 = v57 - *v176 + v177;
                if (v57 < 0)
                {
                  v58 += v57;
                  v59 += v57;
                  v57 = *v176 & 0xFFFFFFFE;
                  v14 = v16;
                  if (v59 < 0)
                  {
                    if (v58 >= v57)
                    {
                      v177 = !(*(_BYTE *)v176 & 1);
                      v179 = (_OWORD *)(*((_QWORD *)&v611[v175] + 1) + 16);
                    }
                    else
                    {
                      v179 = (_OWORD *)*((_QWORD *)&v611[v175] + 1);
                    }
                    v59 += v57;
                    *(_OWORD *)v176 = *v179;
                    v34 = 1;
                    if (v57 >= 0x800000)
                      goto LABEL_1601;
                  }
                  else
                  {
                    if (v58 >= 0x800000)
                      goto LABEL_1606;
                    if (v58 >= v57)
                    {
                      v178 = (_OWORD *)*((_QWORD *)&v611[v175] + 1);
                    }
                    else
                    {
                      v177 = !(*(_BYTE *)v176 & 1);
                      v178 = (_OWORD *)(*((_QWORD *)&v611[v175] + 1) + 16);
                    }
                    *(_OWORD *)v176 = *v178;
                    v57 = v58;
                  }
                  v180 = v63;
                  do
                  {
                    if (!v60)
                    {
                      v181 = v62 + 1;
                      v182 = *v62;
                      v183 = v59 + v182;
                      if (v182 >= 0x90)
                        v184 = 255;
                      else
                        v184 = *v62;
                      if (v182 >= 0x90)
                      {
                        v185 = v180 + 1;
                      }
                      else
                      {
                        ++v62;
                        v185 = v63;
                      }
                      if (v182 < 0x90)
                        v186 = v180;
                      else
                        v186 = v180 + 1;
                      if (v182 < 0x90)
                      {
                        v187 = 7;
                      }
                      else
                      {
                        v183 = v59;
                        v187 = 8;
                      }
                      v188 = v61 == 255;
                      if (v61 == 255)
                        v61 = v184;
                      else
                        v61 = v182;
                      if (v188)
                        v63 = v185;
                      else
                        v62 = v181;
                      if (v188)
                        v180 = v186;
                      if (v188)
                        v189 = v183;
                      else
                        v189 = v59;
                      if (v188)
                        v60 = v187;
                      else
                        v60 = 8;
                      v59 = v189 + v61;
                    }
                    v190 = 2 * v57;
                    v59 *= 2;
                    --v60;
                    v94 = v57 < 0x400000;
                    v57 *= 2;
                  }
                  while (v94);
                  if (v59 >= v190 - 0x800000)
                    v57 = v190 - 0x800000;
                  else
                    v57 = v59;
                  v58 = v190 - v57;
                  v59 -= v57;
                  v173 = v69[1];
                  v172 = *(v69 - 1);
                }
                v191 = v177 ^ v174 & 1;
                *(v69 - 1) = v172 | 0x100;
                v69[1] = v173 | 0x40;
                v71 = v123 | (v191 << 24) | 0x80;
                *(_DWORD *)(i + 4 * v601) = v67 + (v191 << 31);
              }
            }
            if ((v71 & 0xC000400) == 0)
            {
              v192 = *(unsigned __int8 *)(v66 + ((v71 >> 6) & 0x1EFLL));
              v193 = &v609[v192];
              v194 = *v193 & 1;
              v57 = v57 - *v193 + v194;
              if (v57 < 0)
              {
                v58 += v57;
                v59 += v57;
                v57 = *v193 & 0xFFFFFFFE;
                v34 = 1;
                v14 = v16;
                if (v59 < 0)
                {
                  if (v58 >= v57)
                  {
                    v194 = !(*(_BYTE *)v193 & 1);
                    v196 = (_OWORD *)(*((_QWORD *)&v609[v192] + 1) + 16);
                  }
                  else
                  {
                    v196 = (_OWORD *)*((_QWORD *)&v609[v192] + 1);
                  }
                  v59 += v57;
                  *(_OWORD *)v193 = *v196;
                  if (v57 >= 0x800000)
                    goto LABEL_1601;
                }
                else
                {
                  if (v58 >= 0x800000)
                    goto LABEL_1607;
                  if (v58 >= v57)
                  {
                    v195 = (_OWORD *)*((_QWORD *)&v609[v192] + 1);
                  }
                  else
                  {
                    v194 = !(*(_BYTE *)v193 & 1);
                    v195 = (_OWORD *)(*((_QWORD *)&v609[v192] + 1) + 16);
                  }
                  *(_OWORD *)v193 = *v195;
                  v57 = v58;
                }
                v197 = v63;
                do
                {
                  if (!v60)
                  {
                    v198 = v62 + 1;
                    v199 = *v62;
                    v200 = v59 + v199;
                    if (v199 >= 0x90)
                      v201 = 255;
                    else
                      v201 = *v62;
                    if (v199 >= 0x90)
                    {
                      v202 = v197 + 1;
                    }
                    else
                    {
                      ++v62;
                      v202 = v63;
                    }
                    if (v199 < 0x90)
                      v203 = v197;
                    else
                      v203 = v197 + 1;
                    if (v199 < 0x90)
                    {
                      v204 = 7;
                    }
                    else
                    {
                      v200 = v59;
                      v204 = 8;
                    }
                    v205 = v61 == 255;
                    if (v61 == 255)
                      v61 = v201;
                    else
                      v61 = v199;
                    if (v205)
                      v63 = v202;
                    else
                      v62 = v198;
                    if (v205)
                      v197 = v203;
                    if (v205)
                      v206 = v200;
                    else
                      v206 = v59;
                    if (v205)
                      v60 = v204;
                    else
                      v60 = 8;
                    v59 = v206 + v61;
                  }
                  v207 = 2 * v57;
                  v59 *= 2;
                  --v60;
                  v94 = v57 < 0x400000;
                  v57 *= 2;
                }
                while (v94);
                if (v59 >= v207 - 0x800000)
                  v57 = v207 - 0x800000;
                else
                  v57 = v59;
                v58 = v207 - v57;
                v59 -= v57;
              }
              v124 = v71;
              if (v194)
              {
LABEL_484:
                v208 = *(v69 - 1);
                v209 = v69[1];
                v210 = sign_lut[(v208 >> 8) & 4 | (v124 >> 7) & 0x41 | (v209 >> 6) & 0x10 | (((v208 >> 8) & 0x80004 | (v124 >> 7) & 0x820041 | (v209 >> 6) & 0x200010) >> 16)];
                v211 = v210 >> 1;
                v212 = &v611[v210 >> 1];
                v213 = *v212 & 1;
                v57 = v57 - *v212 + v213;
                if (v57 < 0)
                {
                  v58 += v57;
                  v59 += v57;
                  v57 = *v212 & 0xFFFFFFFE;
                  v14 = v16;
                  if (v59 < 0)
                  {
                    if (v58 >= v57)
                    {
                      v213 = !(*(_BYTE *)v212 & 1);
                      v215 = (_OWORD *)(*((_QWORD *)&v611[v211] + 1) + 16);
                    }
                    else
                    {
                      v215 = (_OWORD *)*((_QWORD *)&v611[v211] + 1);
                    }
                    v59 += v57;
                    *(_OWORD *)v212 = *v215;
                    v34 = 1;
                    if (v57 >= 0x800000)
                      goto LABEL_1601;
                  }
                  else
                  {
                    if (v58 >= 0x800000)
                      goto LABEL_1606;
                    if (v58 >= v57)
                    {
                      v214 = (_OWORD *)*((_QWORD *)&v611[v211] + 1);
                    }
                    else
                    {
                      v213 = !(*(_BYTE *)v212 & 1);
                      v214 = (_OWORD *)(*((_QWORD *)&v611[v211] + 1) + 16);
                    }
                    *(_OWORD *)v212 = *v214;
                    v57 = v58;
                  }
                  v216 = v63;
                  do
                  {
                    if (!v60)
                    {
                      v217 = v62 + 1;
                      v218 = *v62;
                      v219 = v59 + v218;
                      if (v218 >= 0x90)
                        v220 = 255;
                      else
                        v220 = *v62;
                      if (v218 >= 0x90)
                      {
                        v221 = v216 + 1;
                      }
                      else
                      {
                        ++v62;
                        v221 = v63;
                      }
                      if (v218 < 0x90)
                        v222 = v216;
                      else
                        v222 = v216 + 1;
                      if (v218 < 0x90)
                      {
                        v223 = 7;
                      }
                      else
                      {
                        v219 = v59;
                        v223 = 8;
                      }
                      v224 = v61 == 255;
                      if (v61 == 255)
                        v61 = v220;
                      else
                        v61 = v218;
                      if (v224)
                        v63 = v221;
                      else
                        v62 = v217;
                      if (v224)
                        v216 = v222;
                      if (v224)
                        v225 = v219;
                      else
                        v225 = v59;
                      if (v224)
                        v60 = v223;
                      else
                        v60 = 8;
                      v59 = v225 + v61;
                    }
                    v226 = 2 * v57;
                    v59 *= 2;
                    --v60;
                    v94 = v57 < 0x400000;
                    v57 *= 2;
                  }
                  while (v94);
                  if (v59 >= v226 - 0x800000)
                    v57 = v226 - 0x800000;
                  else
                    v57 = v59;
                  v58 = v226 - v57;
                  v59 -= v57;
                  v209 = v69[1];
                  v208 = *(v69 - 1);
                }
                v227 = v213 ^ v210 & 1;
                *(v69 - 1) = v208 | 0x800;
                v69[1] = v209 | 0x200;
                v71 = v124 | (v227 << 27) | 0x400;
                *(_DWORD *)(i + 8 * v601) = v67 + (v227 << 31);
              }
            }
            if ((v71 & 0x60002000) != 0)
            {
              v34 = 1;
              v14 = v16;
LABEL_633:
              *v69 = (v71 << 15) & 0x12480000 | v71 & 0xDB6FFFFF;
              goto LABEL_634;
            }
            v228 = *(unsigned __int8 *)(v66 + ((v71 >> 9) & 0x1EFLL));
            v229 = &v609[v228];
            v230 = *v229 & 1;
            v57 = v57 - *v229 + v230;
            v34 = 1;
            v14 = v16;
            if (v57 < 0)
            {
              v58 += v57;
              v59 += v57;
              v57 = *v229 & 0xFFFFFFFE;
              if (v59 < 0)
              {
                if (v58 >= v57)
                {
                  v230 = !(*(_BYTE *)v229 & 1);
                  v232 = (_OWORD *)(*((_QWORD *)&v609[v228] + 1) + 16);
                }
                else
                {
                  v232 = (_OWORD *)*((_QWORD *)&v609[v228] + 1);
                }
                v59 += v57;
                *(_OWORD *)v229 = *v232;
                if (v57 >= 0x800000)
                  goto LABEL_1601;
              }
              else
              {
                if (v58 >= 0x800000)
                  goto LABEL_1607;
                if (v58 >= v57)
                {
                  v231 = (_OWORD *)*((_QWORD *)&v609[v228] + 1);
                }
                else
                {
                  v230 = !(*(_BYTE *)v229 & 1);
                  v231 = (_OWORD *)(*((_QWORD *)&v609[v228] + 1) + 16);
                }
                *(_OWORD *)v229 = *v231;
                v57 = v58;
              }
              v233 = v63;
              do
              {
                if (!v60)
                {
                  v234 = v62 + 1;
                  v235 = *v62;
                  v236 = v59 + v235;
                  if (v235 >= 0x90)
                    v237 = 255;
                  else
                    v237 = *v62;
                  if (v235 >= 0x90)
                  {
                    v238 = v233 + 1;
                  }
                  else
                  {
                    ++v62;
                    v238 = v63;
                  }
                  if (v235 < 0x90)
                    v239 = v233;
                  else
                    v239 = v233 + 1;
                  if (v235 < 0x90)
                  {
                    v240 = 7;
                  }
                  else
                  {
                    v236 = v59;
                    v240 = 8;
                  }
                  v241 = v61 == 255;
                  if (v61 == 255)
                    v61 = v237;
                  else
                    v61 = v235;
                  v14 = v16;
                  if (v241)
                    v63 = v238;
                  else
                    v62 = v234;
                  if (v241)
                    v233 = v239;
                  if (v241)
                    v242 = v236;
                  else
                    v242 = v59;
                  if (v241)
                    v60 = v240;
                  else
                    v60 = 8;
                  v59 = v242 + v61;
                }
                v243 = 2 * v57;
                v59 *= 2;
                --v60;
                v94 = v57 < 0x400000;
                v57 *= 2;
              }
              while (v94);
              if (v59 >= v243 - 0x800000)
                v57 = v243 - 0x800000;
              else
                v57 = v59;
              v58 = v243 - v57;
              v59 -= v57;
              if (!v230)
                goto LABEL_633;
            }
            else if (!v230)
            {
              goto LABEL_633;
            }
            if ((v71 & 0x80000000) == 0)
              v125 = (v71 >> 10) & 0x20041;
            else
              v125 = (v71 >> 10) & 0x20041 | 0x800000;
            v34 = v71;
LABEL_585:
            v244 = sign_lut[(*(v69 - 1) >> 11) & 4 | v125 & 0x55 | (v69[1] >> 9) & 0x10 | (((*(v69 - 1) >> 11) & 0x80004 | v125 | (v69[1] >> 9) & 0x200010) >> 16)];
            v245 = v244 >> 1;
            v246 = (int *)&v611[v244 >> 1];
            v247 = *v246;
            v248 = *v246 & 1;
            v57 = v57 - *v246 + v248;
            if (v57 < 0)
            {
              v58 += v57;
              v59 += v57;
              v57 = v247 & 0xFFFFFFFE;
              v14 = v16;
              if (v59 < 0)
              {
                if (v58 >= v57)
                {
                  v248 = !(*(_BYTE *)v246 & 1);
                  v250 = (_OWORD *)(*((_QWORD *)&v611[v245] + 1) + 16);
                }
                else
                {
                  v250 = (_OWORD *)*((_QWORD *)&v611[v245] + 1);
                }
                v59 += v57;
                *(_OWORD *)v246 = *v250;
                if (v57 >= 0x800000)
                {
                  v58 = v247 & 0xFFFFFFFE;
LABEL_1606:
                  v34 = 1;
                  goto LABEL_1607;
                }
              }
              else
              {
                if (v58 >= 0x800000)
                  goto LABEL_1606;
                if (v58 >= v57)
                {
                  v249 = (_OWORD *)*((_QWORD *)&v611[v245] + 1);
                }
                else
                {
                  v248 = !(*(_BYTE *)v246 & 1);
                  v249 = (_OWORD *)(*((_QWORD *)&v611[v245] + 1) + 16);
                }
                *(_OWORD *)v246 = *v249;
                v57 = v58;
              }
              v251 = v63;
              do
              {
                if (!v60)
                {
                  v252 = v62 + 1;
                  v253 = *v62;
                  v254 = v59 + v253;
                  if (v253 >= 0x90)
                    v255 = 255;
                  else
                    v255 = *v62;
                  if (v253 >= 0x90)
                  {
                    v256 = v251 + 1;
                  }
                  else
                  {
                    ++v62;
                    v256 = v63;
                  }
                  if (v253 < 0x90)
                    v257 = v251;
                  else
                    v257 = v251 + 1;
                  if (v253 < 0x90)
                  {
                    v258 = 7;
                  }
                  else
                  {
                    v254 = v59;
                    v258 = 8;
                  }
                  v259 = v61 == 255;
                  if (v61 == 255)
                    v61 = v255;
                  else
                    v61 = v253;
                  v14 = v16;
                  if (v259)
                    v63 = v256;
                  else
                    v62 = v252;
                  if (v259)
                    v251 = v257;
                  if (v259)
                    v260 = v254;
                  else
                    v260 = v59;
                  if (v259)
                    v60 = v258;
                  else
                    v60 = 8;
                  v59 = v260 + v61;
                }
                v261 = 2 * v57;
                v59 *= 2;
                --v60;
                v94 = v57 < 0x400000;
                v57 *= 2;
              }
              while (v94);
              if (v59 >= v261 - 0x800000)
                v57 = v261 - 0x800000;
              else
                v57 = v59;
              v58 = v261 - v57;
              v59 -= v57;
            }
            else
            {
              v14 = v16;
            }
            v262 = v248 ^ v244 & 1;
            v69[v594] |= 4u;
            v69[v595] |= (v262 << 18) | 2;
            v69[v593] |= 1u;
            *(v69 - 1) |= 0x4000u;
            v69[1] |= 0x1000u;
            v71 = v34 | (v262 << 30) | 0x2000;
            *(_DWORD *)(i + 12 * v601) = v67 + (v262 << 31);
            v34 = 1;
            goto LABEL_633;
          }
          v75 = v65 & 1;
          if (!(v69[3] | v75) && (int)(v57 - 4 * v65) >= 0)
          {
            v70 -= 3;
            i += 12;
            v57 -= 4 * v65;
            v69 += 3;
            goto LABEL_634;
          }
          v57 = v57 - v65 + v75;
          if (v57 >= 0)
          {
            if ((v65 & 1) != 0)
              break;
            goto LABEL_634;
          }
          v58 += v57;
          v59 += v57;
          v57 = v65 & 0xFFFFFFFE;
          if (v59 < 0)
          {
            v59 += v57;
            if (v58 < v57)
              v80 = (unsigned int *)v64;
            else
              v80 = (unsigned int *)(v64 + 16);
            if (v58 < v57)
              v81 = (unsigned int *)(v64 + 4);
            else
              v81 = (unsigned int *)(v64 + 20);
            if (v58 < v57)
              v82 = (uint64_t *)(v64 + 8);
            else
              v82 = (uint64_t *)(v64 + 24);
            if (v58 >= v57)
              v75 ^= 1u;
            v64 = *v82;
            v575 = *v81;
            v65 = *v80;
            v14 = v16;
            if (v57 >= 0x800000)
            {
LABEL_1601:
              v58 = v57;
              goto LABEL_1607;
            }
          }
          else
          {
            if (v58 >= 0x800000)
            {
              v14 = v16;
              goto LABEL_1607;
            }
            v76 = (unsigned int *)(v64 + 4);
            v77 = (unsigned int *)(v64 + 16);
            if (v58 < v57)
              v76 = (unsigned int *)(v64 + 20);
            else
              v77 = (unsigned int *)v64;
            if (v58 < v57)
              v78 = (uint64_t *)(v64 + 24);
            else
              v78 = (uint64_t *)(v64 + 8);
            if (v58 < v57)
              v75 ^= 1u;
            v64 = *v78;
            v575 = *v76;
            v57 = v58;
            v65 = *v77;
            v14 = v16;
          }
          v83 = v63;
          do
          {
            if (!v60)
            {
              v84 = v62 + 1;
              v85 = *v62;
              v86 = v59 + v85;
              if (v85 >= 0x90)
                v87 = 255;
              else
                v87 = *v62;
              if (v85 >= 0x90)
              {
                v88 = v83 + 1;
              }
              else
              {
                ++v62;
                v88 = v63;
              }
              if (v85 < 0x90)
                v89 = v83;
              else
                v89 = v83 + 1;
              if (v85 < 0x90)
              {
                v90 = 7;
              }
              else
              {
                v86 = v59;
                v90 = 8;
              }
              v91 = v61 == 255;
              if (v61 == 255)
                v61 = v87;
              else
                v61 = v85;
              v14 = v16;
              if (v91)
                v63 = v88;
              else
                v62 = v84;
              if (v91)
                v83 = v89;
              if (v91)
                v92 = v86;
              else
                v92 = v59;
              if (v91)
                v60 = v90;
              else
                v60 = 8;
              v59 = v92 + v61;
            }
            v93 = 2 * v57;
            v59 *= 2;
            --v60;
            v94 = v57 < 0x400000;
            v57 *= 2;
          }
          while (v94);
          v57 = v59 >= v93 - 0x800000 ? v93 - 0x800000 : v59;
          v58 = v93 - v57;
          v59 -= v57;
          if (v75)
            break;
LABEL_634:
          i += 4;
          ++v69;
          v263 = __OFSUB__(v70--, 1);
          if ((v70 < 0) ^ v263 | (v70 == 0))
            goto LABEL_636;
        }
        v95 = v57 - 5636352;
        if (v57 >= 5636352)
        {
          v98 = 0;
          goto LABEL_211;
        }
        v58 += v95;
        v96 = v59 + v95;
        if (v59 + v95 < 0)
        {
          v96 = v59 + v57;
          v97 = v58 > 5636351;
          v58 = 5636352;
          goto LABEL_173;
        }
        if (v58 >= 0x800000)
        {
          v57 -= 5636352;
        }
        else
        {
          v97 = v58 < 5636352;
LABEL_173:
          if (v97)
            v98 = 2;
          else
            v98 = 0;
          v100 = v63;
          do
          {
            if (!v60)
            {
              v101 = v62 + 1;
              v102 = *v62;
              v103 = v96 + v102;
              if (v102 >= 0x90)
                v104 = 255;
              else
                v104 = *v62;
              if (v102 >= 0x90)
              {
                v105 = v100 + 1;
              }
              else
              {
                ++v62;
                v105 = v63;
              }
              if (v102 < 0x90)
                v106 = v100;
              else
                v106 = v100 + 1;
              if (v102 < 0x90)
              {
                v107 = 7;
              }
              else
              {
                v103 = v96;
                v107 = 8;
              }
              v108 = v61 == 255;
              if (v61 == 255)
                v61 = v104;
              else
                v61 = v102;
              if (v108)
                v63 = v105;
              else
                v62 = v101;
              v14 = v16;
              if (v108)
                v100 = v106;
              if (v108)
                v109 = v103;
              else
                v109 = v96;
              if (v108)
                v60 = v107;
              else
                v60 = 8;
              v96 = v109 + v61;
            }
            v110 = 2 * v58;
            v96 *= 2;
            --v60;
            v94 = v58 < 0x400000;
            v58 *= 2;
          }
          while (v94);
          if (v96 >= v110 - 0x800000)
            v95 = v110 - 0x800000;
          else
            v95 = v96;
          v58 = v110 - v95;
          v59 = v96 - v95;
LABEL_211:
          v57 = v95 - 5636352;
          if (v95 >= 5636352)
            goto LABEL_251;
          v58 += v57;
          v96 = v57 + v59;
          if (v57 + v59 < 0)
          {
            v96 = v95 + v59;
            v111 = v58 > 5636351;
            v58 = 5636352;
            goto LABEL_216;
          }
          if (v58 < 0x800000)
          {
            v111 = v58 < 5636352;
LABEL_216:
            v112 = v63;
            do
            {
              if (!v60)
              {
                v113 = v62 + 1;
                v114 = *v62;
                v115 = v96 + v114;
                if (v114 >= 0x90)
                  v116 = 255;
                else
                  v116 = *v62;
                if (v114 >= 0x90)
                {
                  v117 = v112 + 1;
                }
                else
                {
                  ++v62;
                  v117 = v63;
                }
                if (v114 < 0x90)
                  v118 = v112;
                else
                  v118 = v112 + 1;
                if (v114 < 0x90)
                {
                  v119 = 7;
                }
                else
                {
                  v115 = v96;
                  v119 = 8;
                }
                v120 = v61 == 255;
                if (v61 == 255)
                  v61 = v116;
                else
                  v61 = v114;
                v14 = v16;
                if (v120)
                  v63 = v117;
                else
                  v62 = v113;
                if (v120)
                  v112 = v118;
                if (v120)
                  v121 = v115;
                else
                  v121 = v96;
                if (v120)
                  v60 = v119;
                else
                  v60 = 8;
                v96 = v121 + v61;
              }
              v122 = 2 * v58;
              v96 *= 2;
              --v60;
              v94 = v58 < 0x400000;
              v58 *= 2;
            }
            while (v94);
            v98 |= v111;
            if (v96 >= v122 - 0x800000)
              v57 = v122 - 0x800000;
            else
              v57 = v96;
            v58 = v122 - v57;
            v59 = v96 - v57;
LABEL_251:
            v123 = 0;
            v124 = 0;
            v34 = 0;
            v125 = 0;
            switch(v98)
            {
              case 0:
                goto LABEL_291;
              case 1:
                goto LABEL_389;
              case 2:
                goto LABEL_484;
              case 3:
                goto LABEL_585;
              default:
                goto LABEL_93;
            }
          }
        }
        v59 = v96;
LABEL_1607:
        *(_QWORD *)&v610 = __PAIR64__(v575, v65);
        *((_QWORD *)&v610 + 1) = v64;
        BYTE4(v608) = 0;
        LODWORD(v606) = v58 + v57;
        DWORD1(v606) = v59 + v57;
        *((_QWORD *)&v606 + 1) = __PAIR64__(v61, v60);
        *((_QWORD *)&v607 + 1) = v62;
LABEL_1608:
        LODWORD(v608) = v63;
        v22 = v600;
LABEL_1609:
        v15 = a2;
        v564 = v599;
        if ((*((_BYTE *)a2 + 28) & 0x20) != 0 && v596 == 2)
        {
          v603[0] = 0;
          mq_decoder::mq_decode_run((mq_decoder *)&v606, v603);
          v565 = v603[0];
          mq_decoder::mq_decode_run((mq_decoder *)&v606, v603);
          v15 = a2;
          if (v603[0] + 4 * v565 == 10 || !*((_BYTE *)a2 + 37) && !*((_BYTE *)a2 + 36))
          {
            v22 = v600;
            v34 = 1;
            v14 = v16;
            v564 = v599;
            goto LABEL_1615;
          }
          v566 = v599 - 2;
          if (v599 < 2)
            v566 = 0;
          if (v577 && v578 > v566)
            v566 = v578;
          *((_DWORD *)a2 + 12) = v566;
          mq_decoder::finish((mq_decoder *)&v606, 0);
          v15 = a2;
LABEL_1627:
          if (*((_BYTE *)v15 + 37))
          {
            v605 = 0;
            *(_OWORD *)v603 = 0u;
            v604 = 0u;
            kdu_error::kdu_error((kdu_error *)v603, "Kakadu Core Error:\n");
            (*(void (**)(int *, const char *))(*(_QWORD *)v603 + 16))(v603, "Encountered incorrectly terminated codeword segment, or invalid SEGMARK symbol in code-block bit-stream.  You may like to use the \"resilient\" mode to recover from and conceal such errors.");
            kdu_error::~kdu_error((kdu_error *)v603);
          }
          v12 = v598;
          if (!*((_BYTE *)v15 + 120))
          {
            *((_BYTE *)v15 + 120) = 1;
            v605 = 0;
            *(_OWORD *)v603 = 0u;
            v604 = 0u;
            kdu_warning::kdu_warning((kdu_warning *)v603, "Kakadu Core Warning:\n");
            (*(void (**)(int *, const char *))(*(_QWORD *)v603 + 16))(v603, "One or more corrupted block bit-streams detected.\n");
            kdu_warning::~kdu_warning((kdu_warning *)v603);
            v15 = a2;
            v12 = v598;
          }
          goto LABEL_16;
        }
LABEL_1615:
        v36 = v589 - 1;
        if (v589 == 1)
        {
          v20 = mq_decoder::finish((mq_decoder *)&v606, v577 & !v582);
          v15 = a2;
          v22 = v600;
          v34 = 1;
          v14 = v16;
          v564 = v599;
          v36 = 0;
          if ((v20 & 1) == 0)
          {
            *((_DWORD *)a2 + 12) = v578;
            if ((*((_BYTE *)a2 + 28) & 0x20) != 0 && (int)v599 - v596 > v578)
              *((_DWORD *)a2 + 12) = v599 - v596;
            goto LABEL_1627;
          }
        }
        v35 = v564 + 1;
        v37 = v596 + 1;
        v591 += 4;
        v30 = v39;
      }
      while (v35 != v588);
    }
    v94 = v572-- <= 1;
    v12 = v598;
    if (!v94)
      continue;
    return kdu_block::finish_timing((clock_t)v15);
  }
}

void sub_187F5910C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  kdu_warning::~kdu_warning((kdu_warning *)&a55);
  _Unwind_Resume(a1);
}

void kd_block_decoder::~kd_block_decoder(kd_block_decoder *this)
{
  *(_QWORD *)this = off_1E1BB24A8;
}

{
  *(_QWORD *)this = off_1E1BB24A8;
  JUMPOUT(0x18D761C30);
}

void OUTLINED_FUNCTION_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 133, a4);
}

kd_decoder **kdu_decoder::kdu_decoder(kd_decoder **a1, int32x4_t *a2, uint64_t a3, int a4, int a5, kdu_thread_entity *a6, char *a7, float a8)
{
  kd_decoder *v16;

  *a1 = 0;
  v16 = (kd_decoder *)operator new();
  kd_decoder::kd_decoder(v16);
  *a1 = v16;
  kd_decoder::init((uint64_t)v16, a2, a3, a4, a5, a6, a7, a8);
  return a1;
}

void sub_187F59228(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4039ECD5E3);
  _Unwind_Resume(a1);
}

uint64_t kd_decoder::init(uint64_t a1, int32x4_t *a2, uint64_t a3, int a4, int a5, kdu_thread_entity *a6, char *a7, float a8)
{
  _QWORD *v8;
  __int16 K_max_prime;
  uint64_t result;
  __int32 v18;
  __int16 v19;
  __int16 v20;
  int v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  _WORD *v25;
  signed int v26;
  int v27;
  __int32 v28;
  __int32 v29;
  int v30;
  uint64_t v31;
  _DWORD *exception;
  uint64_t v33;
  int32x2_t v34;
  int32x2_t v35;
  int32x4_t v36;
  int32x4_t *v37;

  v37 = a2;
  v8 = (_QWORD *)(a1 + 88);
  if (*(_QWORD *)(a1 + 88) || *(_QWORD *)(a1 + 120))
    kd_decoder::init();
  if (a6)
    *(_QWORD *)(a1 + 120) = kdu_thread_entity::add_queue((uint64_t)a6, a1 + 8, a7, (uint64_t)"block decoder");
  *(_QWORD *)(a1 + 24) = a2;
  *(_WORD *)(a1 + 32) = kdu_subband::get_K_max((kdu_subband *)&v37);
  K_max_prime = kdu_subband::get_K_max_prime((kdu_subband *)&v37);
  *(_WORD *)(a1 + 34) = K_max_prime;
  if (*(__int16 *)(a1 + 32) > K_max_prime)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  *(_BYTE *)(a1 + 36) = kdu_subband::get_reversible((kdu_subband *)&v37);
  *(_BYTE *)(a1 + 37) = 0;
  *(float *)(a1 + 40) = kdu_subband::get_delta((kdu_subband *)&v37) * a8;
  v36 = 0uLL;
  kdu_subband::get_dims(&v37, &v36);
  v34 = 0;
  v35 = 0;
  kdu_subband::get_block_size((uint64_t *)&v37, &v35, &v34);
  result = (uint64_t)kdu_subband::get_valid_blocks((kdu_subband *)&v37, (int32x4_t *)(a1 + 44));
  v18 = v36.i32[2];
  *(_QWORD *)(a1 + 60) = v36.i64[1];
  v19 = v34.i16[0];
  *(_WORD *)(a1 + 70) = v34.i16[2];
  *(_WORD *)(a1 + 72) = v19;
  v20 = v35.i16[0];
  *(_WORD *)(a1 + 74) = v35.i16[2];
  *(_WORD *)(a1 + 76) = v20;
  *(_BYTE *)(a1 + 39) = 1;
  if (!a6)
  {
    *(_WORD *)(a1 + 78) = v20;
    v25 = (_WORD *)(a1 + 78);
    *(_WORD *)(a1 + 68) = 0;
    LOWORD(v22) = v18;
    if (v18 > v20)
      goto LABEL_24;
    goto LABEL_23;
  }
  result = kdu_thread_entity::get_num_threads(a6);
  v21 = *(__int16 *)(a1 + 76);
  v22 = *(_DWORD *)(a1 + 60);
  if ((int)result > 1)
  {
    v23 = *(__int16 *)(a1 + 76);
    if (v22 < v21)
      v23 = v22;
    v24 = (v23 * *(int *)(a1 + 64) + (v23 * *(int *)(a1 + 64) < 0 ? 0x1FFFuLL : 0)) >> 13;
    if (*(_DWORD *)(a1 + 56) <= (int)v24)
      kd_decoder::init();
    if ((int)v24 <= 1)
      LODWORD(v24) = 1;
    if (v24 >= 0x20)
      LOBYTE(v24) = 32;
    *(_BYTE *)(a1 + 39) = v24;
  }
  *(_WORD *)(a1 + 78) = v21;
  v25 = (_WORD *)(a1 + 78);
  *(_WORD *)(a1 + 68) = 0;
  if (v22 <= v21)
  {
LABEL_23:
    *v25 = v22;
    goto LABEL_24;
  }
  result = kdu_thread_entity::get_num_threads(a6);
  if ((int)result >= 2)
  {
    v26 = 8u / *(unsigned __int8 *)(a1 + 39) + 1;
    result = kdu_subband::get_band_idx((kdu_subband *)&v37);
    if ((int)result <= v26)
    {
      v27 = *(_DWORD *)(a1 + 60) - *(__int16 *)(a1 + 72);
      if (v27 >= *(__int16 *)(a1 + 76))
        LOWORD(v27) = *(_WORD *)(a1 + 76);
      *(_WORD *)(a1 + 78) += v27;
      v33 = kdu_node::access_resolution((kdu_node *)&v37);
      result = kdu_resolution::get_dwt_level((kdu_resolution *)&v33);
      *(_WORD *)(a1 + 68) = 64 - result;
    }
  }
LABEL_24:
  v28 = 0;
  *(_BYTE *)(a1 + 38) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  v29 = *(_DWORD *)(a1 + 64);
  if (v34.i32[1] < v29)
  {
    if (a4)
      v30 = 7;
    else
      v30 = 3;
    v28 = v30 & -v34.i32[1];
    *(_BYTE *)(a1 + 38) = v28;
  }
  *v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  if (v36.i32[3] < 1 || *(uint64_t *)((char *)v36.i64 + 4) <= 0)
  {
    *(_DWORD *)(a1 + 60) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 88) = a3;
    kdu_sample_allocator::pre_alloc(a3, a4, 0, v29 + v28 + 3, *(__int16 *)(a1 + 78));
    result = operator new[]();
    v31 = 104;
    if (a4)
      v31 = 96;
    *(_QWORD *)(a1 + v31) = result;
    *(_DWORD *)(a1 + 112) = a5;
  }
  return result;
}

void kd_decoder::~kd_decoder(kd_decoder *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E1BAB938;
  *((_QWORD *)this + 1) = &unk_1E1BAB970;
  v2 = *((_QWORD *)this + 12);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x20C8093837F09);
  v3 = *((_QWORD *)this + 13);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x20C8093837F09);
  v4 = *((_QWORD *)this + 2);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  *(_QWORD *)this = off_1E1BB1478;
  *((_QWORD *)this + 1) = off_1E1BABA78;
}

{
  kd_decoder::~kd_decoder(this);
  JUMPOUT(0x18D761C30);
}

void `non-virtual thunk to'kd_decoder::~kd_decoder(kd_decoder *this)
{
  kd_decoder::~kd_decoder((kd_decoder *)((char *)this - 8));
}

{
  kd_decoder::~kd_decoder((kd_decoder *)((char *)this - 8));
  JUMPOUT(0x18D761C30);
}

uint64_t kd_decoder::start(uint64_t result, kdu_thread_entity *this)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;

  v2 = result;
  if (!*(_BYTE *)(result + 37) && *(_DWORD *)(result + 64) && *(_DWORD *)(result + 60))
  {
    if (this)
      result = kdu_thread_entity::acquire_lock(this, 3, 1);
    v4 = *(__int16 *)(v2 + 78);
    if (*(_QWORD *)(v2 + 96))
    {
      if (v4 >= 1)
      {
        v5 = 0;
        v6 = *(unsigned __int8 *)(v2 + 38);
        do
        {
          result = kdu_sample_allocator::alloc16(*(kdu_sample_allocator **)(v2 + 88), 0, *(_DWORD *)(v2 + 64) + v6 + 3);
          v6 = *(unsigned __int8 *)(v2 + 38);
          *(_QWORD *)(*(_QWORD *)(v2 + 96) + 8 * v5++) = result + 2 * *(unsigned __int8 *)(v2 + 38);
        }
        while (v5 < *(__int16 *)(v2 + 78));
      }
    }
    else if (v4 >= 1)
    {
      v7 = 0;
      v8 = *(unsigned __int8 *)(v2 + 38);
      do
      {
        result = kdu_sample_allocator::alloc32(*(kdu_sample_allocator **)(v2 + 88), 0, *(_DWORD *)(v2 + 64) + v8 + 3);
        v8 = *(unsigned __int8 *)(v2 + 38);
        *(_QWORD *)(*(_QWORD *)(v2 + 104) + 8 * v7++) = result + 4 * *(unsigned __int8 *)(v2 + 38);
      }
      while (v7 < *(__int16 *)(v2 + 78));
    }
    *(_BYTE *)(v2 + 37) = 1;
    if (this)
    {
      kdu_thread_entity::release_lock(this, 3);
      return kdu_thread_entity::add_jobs((uint64_t)this, *(kdu_thread_queue **)(v2 + 120), *(unsigned __int8 *)(v2 + 39), 0);
    }
  }
  else
  {
    *(_BYTE *)(result + 37) = 1;
  }
  return result;
}

unsigned __int16 *kd_decoder::pull(unsigned __int16 *result, uint64_t a2, kdu_thread_entity *this)
{
  unsigned __int16 *v5;
  int v6;
  kdu_thread_queue *v7;
  int v8;
  int v9;
  int v10;
  unsigned __int16 v11;
  BOOL v12;
  signed __int16 v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  const void *v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  signed __int16 v24;
  kdu_thread_queue *v25;
  int v26;
  int v27;
  int v28;
  kdu_thread_entity *v29;

  v5 = result;
  if (!this && *((_QWORD *)result + 15))
    kd_decoder::pull();
  if (*(_DWORD *)a2 > *((_DWORD *)result + 28))
  {
    if (!*((_BYTE *)result + 37))
      result = (unsigned __int16 *)(*(uint64_t (**)(unsigned __int16 *, kdu_thread_entity *))(*(_QWORD *)result + 16))(result, this);
    if (*((int *)v5 + 15) >= 1)
    {
      v6 = v5[40];
      if (v6 == v5[41])
      {
        v5[40] = 0;
        v7 = (kdu_thread_queue *)*((_QWORD *)v5 + 15);
        if (v7)
        {
          if (v5[34])
          {
            v8 = (__int16)v5[38];
            if ((__int16)v5[39] <= v8)
              kd_decoder::pull();
            if (*((_DWORD *)v5 + 21))
            {
              if ((__int16)v6 <= v8)
                v5[40] = v8;
            }
            else
            {
              kdu_thread_entity::add_jobs((uint64_t)this, v7, *((unsigned __int8 *)v5 + 39), v5[34]);
              v7 = (kdu_thread_queue *)*((_QWORD *)v5 + 15);
            }
          }
          kdu_thread_entity::process_jobs(this, v7, 0, 1);
        }
        else
        {
          if (*((_BYTE *)v5 + 39) != 1)
            kd_decoder::pull();
          (*(void (**)(unsigned __int16 *, kdu_thread_entity *, _QWORD))(*(_QWORD *)v5 + 32))(v5, this, *((unsigned int *)v5 + 21));
        }
        v9 = *((_DWORD *)v5 + 21);
        if (v9)
        {
          v10 = *((_DWORD *)v5 + 15);
          v11 = v5[40];
          v12 = v10 < (__int16)v5[38];
          v13 = v11 + v10;
          if (!v12)
            v13 = v11 + v5[38];
        }
        else
        {
          v13 = v5[36];
        }
        v5[41] = v13;
        if ((__int16)v5[39] < v13)
          kd_decoder::pull();
        *((_DWORD *)v5 + 21) = v9 + 1;
      }
      v14 = *((_DWORD *)v5 + 16);
      v15 = *((int *)v5 + 28);
      if (*(_DWORD *)a2 != (_DWORD)v15 + v14)
        kd_decoder::pull();
      v16 = *((_QWORD *)v5 + 13);
      v17 = *(_QWORD *)(a2 + 8);
      if (v16)
      {
        if ((*(_BYTE *)(a2 + 6) & 2) != 0)
          v17 = 0;
        v18 = (void *)(v17 + 4 * v15);
        v19 = *(const void **)(v16 + 8 * (__int16)v5[40]);
        v20 = 4 * v14;
      }
      else
      {
        if ((*(_BYTE *)(a2 + 6) & 2) != 0)
          v21 = *(_QWORD *)(a2 + 8);
        else
          v21 = 0;
        v18 = (void *)(v21 + 2 * v15);
        v19 = *(const void **)(*((_QWORD *)v5 + 12) + 8 * (__int16)v5[40]);
        v20 = 2 * v14;
      }
      result = (unsigned __int16 *)memcpy(v18, v19, v20);
      v22 = *((_DWORD *)v5 + 15);
      v23 = v22 - 1;
      *((_DWORD *)v5 + 15) = v22 - 1;
      v24 = v5[40] + 1;
      v5[40] = v24;
      v25 = (kdu_thread_queue *)*((_QWORD *)v5 + 15);
      if (v25 && v24 >= (__int16)v5[41] && v22 >= 2)
      {
        v26 = v5[34];
        if (!v5[34])
          goto LABEL_40;
        v27 = (__int16)v5[38];
        if ((__int16)v5[39] <= v27)
          kd_decoder::pull();
        if (v23 <= v27)
        {
          v29 = this;
          v28 = 0;
          v26 = 0;
        }
        else
        {
LABEL_40:
          v28 = *((unsigned __int8 *)v5 + 39);
          v29 = this;
        }
        return (unsigned __int16 *)kdu_thread_entity::add_jobs((uint64_t)v29, v25, v28, v26);
      }
    }
  }
  return result;
}

void kd_decoder::do_job(kd_decoder *this, kdu_thread_entity *a2, int a3)
{
  kdu_thread_entity *v3;
  kd_decoder *v4;
  signed int v5;
  _QWORD *v6;
  _QWORD *v7;
  int v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  kd_decoder *v28;
  uint64_t v29;
  int v30;
  int v31;
  _QWORD *v32;
  int v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  int v40;
  int v41;
  unsigned int v42;
  int v43;
  size_t v44;
  _QWORD *v45;
  _QWORD *v46;
  int v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _WORD *v53;
  int v54;
  signed int v55;
  float v56;
  int v57;
  float v58;
  int v59;
  size_t v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int *v66;
  int v67;
  unsigned int v68;
  float v69;
  int v70;
  float v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  float *v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  float *v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  _WORD *v88;
  signed int v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _WORD *v95;
  int v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  _WORD *v102;
  int v103;
  BOOL v104;
  _DWORD *exception;
  _QWORD *v106;
  uint64_t *v108;
  uint64_t v109;
  _QWORD *v110;
  int v112;
  __int128 v113;
  __int128 v114;
  uint64_t v115;

  v3 = a2;
  v4 = this;
  v5 = *((unsigned __int8 *)this + 39);
  v7 = (_QWORD *)*((_QWORD *)this + 12);
  v6 = (_QWORD *)*((_QWORD *)this + 13);
  v8 = a3 / v5;
  if (((a3 / v5) & 1) != 0)
  {
    v9 = *((__int16 *)this + 38);
    v10 = &v6[v9];
    if (!v6)
      v10 = 0;
    v11 = &v7[v9];
    if (!v7)
      v11 = 0;
    if (*((__int16 *)this + 39) > *((__int16 *)this + 38))
    {
      v6 = v10;
      v7 = v11;
    }
  }
  if (v8 >= *((_DWORD *)this + 13))
    kd_decoder::do_job();
  v12 = *((_DWORD *)this + 14);
  v13 = *((unsigned int *)this + 12);
  v110 = v6;
  v106 = v7;
  if (v5 < 2)
  {
    if (v12 < 1)
      return;
  }
  else
  {
    v14 = a3 % v5 * v12;
    v15 = v14 / v5;
    v16 = (v12 + v14) / v5;
    v12 = v16 - v15;
    if (v16 <= v15)
      kd_decoder::do_job();
    if (v15 >= 1)
    {
      v13 = (v15 + v13);
      v17 = *((__int16 *)this + 35) + (v15 - 1) * *((__int16 *)this + 37);
      goto LABEL_15;
    }
  }
  v17 = 0;
LABEL_15:
  v18 = (uint64_t *)((char *)this + 24);
  v108 = (uint64_t *)((char *)this + 24);
  v109 = (v8 + *((_DWORD *)this + 11));
  do
  {
    v19 = kdu_subband::open_block(v18, v109 | (v13 << 32), 0, v3);
    if (!v19
      || ((v20 = v19,
           (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)v4 + 2) + 16))(*((_QWORD *)v4 + 2), v19),
           *(_BYTE *)(v20 + 24))
        ? (v21 = *(_DWORD *)(v20 + 16))
        : (v21 = *(_DWORD *)(v20 + 20)),
          *(_BYTE *)(v20 + 24) ? (v22 = *(unsigned int *)(v20 + 20)) : (v22 = *(unsigned int *)(v20 + 16)),
          v21 + v17 > *((_DWORD *)v4 + 16)))
    {
      exception = __cxa_allocate_exception(4uLL);
      *exception = -50;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    v112 = v21 + v17;
    if (*(_DWORD *)(v20 + 48))
    {
      if (*((__int16 *)v4 + 17) > *((__int16 *)v4 + 16))
        kd_decoder::adjust_roi_background((uint64_t)v4, (kdu_block *)v20);
      v23 = *(int *)(v20 + 4);
      v24 = *(_QWORD *)(v20 + 96) + 4 * *(_DWORD *)(v20 + 8) * (int)v23 + 4 * *(int *)(v20 + 12);
      v25 = (int)v22 - 1;
      if (*(_BYTE *)(v20 + 26))
        v26 = v21 - 1;
      else
        v26 = 0;
      if (*(_BYTE *)(v20 + 26))
        v27 = -1;
      else
        v27 = 1;
      v28 = v4;
      if (*(_BYTE *)(v20 + 25))
        v29 = -1;
      else
        v29 = 1;
      v30 = v26 + v17;
      if (!*(_BYTE *)(v20 + 25))
        v25 = 0;
      v31 = *((unsigned __int8 *)v28 + 36);
      if (v110)
      {
        v32 = &v110[v25];
        if (v31)
        {
          v33 = *((__int16 *)this + 16);
          if (v33 >= 32)
          {
            v115 = 0;
            v113 = 0u;
            v114 = 0u;
            kdu_error::kdu_error((kdu_error *)&v113, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v113 + 16))(&v113, "Insufficient implementation precision available for true reversible processing!");
            kdu_error::~kdu_error((kdu_error *)&v113);
          }
          v34 = 31 - v33;
          if (*(_BYTE *)(v20 + 24))
          {
            v3 = a2;
            if ((_DWORD)v22)
            {
              v35 = v30;
              v36 = 4 * v27;
              v37 = 4 * v23;
              do
              {
                if (v21)
                {
                  v38 = 0;
                  v39 = (unsigned int *)(*v32 + 4 * v35);
                  v40 = v21;
                  do
                  {
                    v41 = *(_DWORD *)(v24 + v38);
                    if (v41 < 0)
                      v42 = -((v41 & 0x7FFFFFFFu) >> v34);
                    else
                      v42 = v41 >> v34;
                    *v39 = v42;
                    v39 = (unsigned int *)((char *)v39 + v36);
                    v38 += v37;
                    --v40;
                  }
                  while (v40);
                }
                v32 += v29;
                v24 += 4;
                LODWORD(v22) = v22 - 1;
              }
              while ((_DWORD)v22);
            }
          }
          else
          {
            v3 = a2;
            if ((_DWORD)v22)
            {
              v62 = v30;
              v63 = 4 * v27;
              v64 = 4 * v23;
              do
              {
                if (v21)
                {
                  v65 = 0;
                  v66 = (unsigned int *)(*v32 + 4 * v62);
                  do
                  {
                    v67 = *(_DWORD *)(v24 + 4 * v65);
                    if (v67 < 0)
                      v68 = -((v67 & 0x7FFFFFFFu) >> v34);
                    else
                      v68 = v67 >> v34;
                    *v66 = v68;
                    v66 = (unsigned int *)((char *)v66 + v63);
                    ++v65;
                  }
                  while (v21 != (_DWORD)v65);
                }
                v32 += v29;
                v24 += v64;
                LODWORD(v22) = v22 - 1;
              }
              while ((_DWORD)v22);
            }
          }
        }
        else
        {
          v56 = *((float *)this + 10);
          v57 = *((__int16 *)this + 16);
          if (v57 > 31)
            v58 = v56 * (float)(1 << (v57 - 31));
          else
            v58 = v56 / (float)(int)(0x80000000 >> v57);
          if (*(_BYTE *)(v20 + 24))
          {
            if ((_DWORD)v22)
            {
              v72 = v30;
              v73 = 4 * v27;
              v74 = 4 * v23;
              do
              {
                if (v21)
                {
                  v75 = 0;
                  v76 = (float *)(*v32 + 4 * v72);
                  v77 = v21;
                  do
                  {
                    v78 = *(_DWORD *)(v24 + v75);
                    if (v78 < 0)
                      v78 = -(v78 & 0x7FFFFFFF);
                    *v76 = v58 * (float)v78;
                    v76 = (float *)((char *)v76 + v73);
                    v75 += v74;
                    --v77;
                  }
                  while (v77);
                }
                v32 += v29;
                v24 += 4;
                LODWORD(v22) = v22 - 1;
              }
              while ((_DWORD)v22);
            }
          }
          else if ((_DWORD)v22)
          {
            v79 = v30;
            v80 = 4 * v27;
            do
            {
              if (v21)
              {
                v81 = 0;
                v82 = (float *)(*v32 + 4 * v79);
                do
                {
                  v83 = *(_DWORD *)(v24 + 4 * v81);
                  if (v83 < 0)
                    v83 = -(v83 & 0x7FFFFFFF);
                  *v82 = v58 * (float)v83;
                  v82 = (float *)((char *)v82 + v80);
                  ++v81;
                }
                while (v21 != (_DWORD)v81);
              }
              v32 += v29;
              v24 += 4 * v23;
              LODWORD(v22) = v22 - 1;
            }
            while ((_DWORD)v22);
          }
        }
      }
      else
      {
        v46 = &v106[v25];
        if (v31)
        {
          v47 = *((__int16 *)this + 16);
          if (v47 >= 32)
          {
            v115 = 0;
            v113 = 0u;
            v114 = 0u;
            kdu_error::kdu_error((kdu_error *)&v113, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v113 + 16))(&v113, "Need 32 bits for 16-bit dequantized values");
            kdu_error::~kdu_error((kdu_error *)&v113);
          }
          v48 = 31 - v47;
          if (*(_BYTE *)(v20 + 24))
          {
            v3 = a2;
            if ((_DWORD)v22)
            {
              v49 = v30;
              v50 = 2 * v27;
              v51 = 4 * v23;
              do
              {
                if (v21)
                {
                  v52 = 0;
                  v53 = (_WORD *)(*v46 + 2 * v49);
                  v54 = v21;
                  do
                  {
                    v55 = *(_DWORD *)(v24 + v52);
                    if (v55 < 0)
                      v55 = -((v55 & 0x7FFFFFFFu) >> v48);
                    else
                      LOWORD(v55) = v55 >> v48;
                    *v53 = v55;
                    v53 = (_WORD *)((char *)v53 + v50);
                    v52 += v51;
                    --v54;
                  }
                  while (v54);
                }
                v46 += v29;
                v24 += 4;
                LODWORD(v22) = v22 - 1;
              }
              while ((_DWORD)v22);
            }
          }
          else
          {
            v3 = a2;
            if ((_DWORD)v22)
            {
              v84 = v30;
              v85 = 2 * v27;
              v86 = 4 * v23;
              do
              {
                if (v21)
                {
                  v87 = 0;
                  v88 = (_WORD *)(*v46 + 2 * v84);
                  do
                  {
                    v89 = *(_DWORD *)(v24 + 4 * v87);
                    if (v89 < 0)
                      v89 = -((v89 & 0x7FFFFFFFu) >> v48);
                    else
                      LOWORD(v89) = v89 >> v48;
                    *v88 = v89;
                    v88 = (_WORD *)((char *)v88 + v85);
                    ++v87;
                  }
                  while (v21 != (_DWORD)v87);
                }
                v46 += v29;
                v24 += v86;
                LODWORD(v22) = v22 - 1;
              }
              while ((_DWORD)v22);
            }
          }
        }
        else
        {
          v69 = *((float *)this + 10) * 8192.0;
          v70 = *((__int16 *)this + 16);
          if (v70 > 31)
            v71 = v69 * (float)(1 << (v70 - 31));
          else
            v71 = v69 / (float)(int)(0x80000000 >> v70);
          v90 = (int)(float)((float)(v71 * 4295000000.0) + 0.5);
          if (*(_BYTE *)(v20 + 24))
          {
            if ((_DWORD)v22)
            {
              v91 = v30;
              v92 = 2 * v27;
              v93 = 4 * v23;
              do
              {
                if (v21)
                {
                  v94 = 0;
                  v95 = (_WORD *)(*v46 + 2 * v91);
                  v96 = v21;
                  do
                  {
                    v97 = *(_DWORD *)(v24 + v94);
                    if (v97 < 0)
                      v97 = -(v97 & 0x7FFFFFFF);
                    *v95 = (((v97 + 0x8000) >> 16) * v90 + 0x8000) >> 16;
                    v95 = (_WORD *)((char *)v95 + v92);
                    v94 += v93;
                    --v96;
                  }
                  while (v96);
                }
                v46 += v29;
                v24 += 4;
                LODWORD(v22) = v22 - 1;
              }
              while ((_DWORD)v22);
            }
          }
          else if ((_DWORD)v22)
          {
            v98 = v30;
            v99 = 2 * v27;
            v100 = 4 * v23;
            do
            {
              if (v21)
              {
                v101 = 0;
                v102 = (_WORD *)(*v46 + 2 * v98);
                do
                {
                  v103 = *(_DWORD *)(v24 + 4 * v101);
                  if (v103 < 0)
                    v103 = -(v103 & 0x7FFFFFFF);
                  *v102 = (((v103 + 0x8000) >> 16) * v90 + 0x8000) >> 16;
                  v102 = (_WORD *)((char *)v102 + v99);
                  ++v101;
                }
                while (v21 != (_DWORD)v101);
              }
              v46 += v29;
              v24 += v100;
              LODWORD(v22) = v22 - 1;
            }
            while ((_DWORD)v22);
          }
        }
      }
    }
    else if (v110)
    {
      if ((int)v22 >= 1)
      {
        if (v21 >= 4)
          v43 = 4;
        else
          v43 = v21;
        v44 = 16 * ((v21 - v43 + 3) >> 2) + 16;
        v45 = v110;
        do
        {
          if (v21 >= 1)
            bzero((void *)(*v45 + 4 * v17), v44);
          ++v45;
          --v22;
        }
        while (v22);
      }
    }
    else if ((int)v22 >= 1)
    {
      if (v21 >= 4)
        v59 = 4;
      else
        v59 = v21;
      v60 = 8 * ((v21 - v59 + 3) >> 2) + 8;
      v61 = v106;
      do
      {
        if (v21 >= 1)
          bzero((void *)(*v61 + 2 * v17), v60);
        ++v61;
        --v22;
      }
      while (v22);
    }
    v18 = v108;
    kdu_subband::close_block((uint64_t)v108, (kdu_block *)v20, (uint64_t)v3);
    v13 = (v13 + 1);
    v17 = v112;
    v104 = __OFSUB__(v12--, 1);
    v4 = this;
  }
  while (!((v12 < 0) ^ v104 | (v12 == 0)));
}

void sub_187F5A1B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F5A1BC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Unwind_Exception *v19;

  _Unwind_Resume(v19);
}

uint64_t kd_decoder::adjust_roi_background(uint64_t this, kdu_block *a2)
{
  int v2;
  __int16 v3;
  __int16 v4;
  int v5;
  int *v6;
  int v7;
  int v8;
  BOOL v9;
  unsigned int v10;

  v2 = *((_DWORD *)a2 + 1) * ((*(_DWORD *)a2 + 3) >> 2);
  if (4 * v2)
  {
    v3 = *(_WORD *)(this + 32);
    v4 = *(_WORD *)(this + 34) - v3;
    v5 = (-1 << ~(_BYTE)v3) & 0x7FFFFFFF;
    v6 = (int *)*((_QWORD *)a2 + 12);
    v7 = -4 * v2;
    do
    {
      v8 = *v6;
      if (*v6)
        v9 = (v5 & *v6) == 0;
      else
        v9 = 0;
      if (v9)
      {
        if (v8 >= 0)
          v10 = v8 << v4;
        else
          v10 = (v8 << v4) | 0x80000000;
        *v6 = v10;
      }
      ++v6;
    }
    while (!__CFADD__(v7++, 1));
  }
  return this;
}

void `non-virtual thunk to'kd_decoder::do_job(kd_decoder *this, kdu_thread_entity *a2, int a3)
{
  kd_decoder::do_job((kd_decoder *)((char *)this - 8), a2, a3);
}

void kd_decoder::kd_decoder(kd_decoder *this)
{
  *(_QWORD *)this = &off_1E1BAB938;
  *((_QWORD *)this + 1) = &unk_1E1BAB970;
  kdu_block_decoder::kdu_block_decoder((kd_decoder *)((char *)this + 16));
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)((char *)this + 52) = 0;
  *(_QWORD *)((char *)this + 44) = 0;
  *((_BYTE *)this + 37) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 11) = 0;
}

void sub_187F5A2A4(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = off_1E1BB1478;
  v1[1] = off_1E1BABA78;
  _Unwind_Resume(a1);
}

kd_analysis **kdu_analysis::kdu_analysis(kd_analysis **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, float a8)
{
  kd_analysis *v16;

  *a1 = 0;
  v16 = (kd_analysis *)operator new();
  kd_analysis::kd_analysis(v16);
  *a1 = v16;
  kd_analysis::init(v16, a2, a3, a4, a5, a6, a7, a8);
  return a1;
}

void sub_187F5A364(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C405B8F8FE9);
  _Unwind_Resume(a1);
}

float *kd_analysis::init(uint64_t a1, int32x4_t *a2, kdu_sample_allocator *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, double a8)
{
  char reversible;
  int *v12;
  char kernel_id;
  float *result;
  __int32 v15;
  int v16;
  __int32 v17;
  int v18;
  __int32 v19;
  __int32 v20;
  __int32 v21;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t kernel_info;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  char v34;
  _DWORD *v35;
  int v36;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  _DWORD *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t kernel_coefficients;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  float *v56;
  _DWORD *v57;
  float v58;
  float v59;
  uint64_t v60;
  unsigned __int8 v61;
  unsigned __int8 *v62;
  float v63;
  uint64_t v64;
  float *v65;
  _DWORD *v66;
  float v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  float *v77;
  _DWORD *v78;
  float v79;
  float v80;
  uint64_t v81;
  unsigned __int8 v82;
  unsigned __int8 *v83;
  uint64_t v84;
  float *v85;
  uint64_t v86;
  float *v87;
  float v88;
  uint64_t v89;
  float *v90;
  _DWORD *v91;
  float v92;
  uint64_t v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  char v103;
  int v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  _QWORD *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  int v115;
  uint64_t v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  uint64x2_t v120;
  int v121;
  unsigned int v122;
  int64x2_t v123;
  unsigned int *v124;
  int64x2_t v125;
  int32x2_t v126;
  uint64_t bibo_gains;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  float v131;
  float v132;
  float v133;
  uint64_t v134;
  float v135;
  float *v136;
  float v137;
  float v138;
  float v139;
  float v141;
  float v142;
  float *v143;
  uint64_t i;
  float *v145;
  float v146;
  float *v147;
  uint64_t v148;
  float v149;
  float v150;
  float v151;
  int v153;
  float32x4_t v154;
  float32x4_t v155;
  uint64_t v156;
  uint64_t v157;
  unsigned int v158;
  kdu_roi_level *v159;
  uint64_t v160;
  uint64_t v161;
  kd_analysis *v162;
  uint64_t v163;
  int v164;
  unsigned int v165;
  int v166;
  char v170;
  kd_analysis *v172;
  kd_analysis *v173;
  int v174;
  int v175[2];
  float v176;
  float v177;
  float v178;
  float v179;
  int32x4_t v180;
  uint64_t v181;
  int32x4_t *v182;
  int v183[4];
  _QWORD v184[6];

  v184[4] = *MEMORY[0x1E0C80C00];
  v182 = a2;
  v181 = kdu_node::access_resolution((kdu_node *)&v182);
  if (a5)
  {
    if ((kdu_resolution::propagate_roi((kdu_resolution *)&v181) & 1) != 0)
    {
      kdu_roi_level::create((uint64_t *)(a1 + 144), v182, a5);
      v170 = 0;
      goto LABEL_6;
    }
    (*(void (**)(uint64_t))(*(_QWORD *)a5 + 16))(a5);
  }
  v170 = 1;
LABEL_6:
  reversible = kdu_resolution::get_reversible((kdu_resolution *)&v181);
  *(_OWORD *)(a1 + 48) = 0u;
  v12 = (int *)(a1 + 48);
  *(_BYTE *)(a1 + 40) = reversible;
  *(_BYTE *)(a1 + 41) = a4;
  *(_BYTE *)(a1 + 42) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_WORD *)(a1 + 98) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  kernel_id = kdu_node::get_kernel_id((kdu_node *)&v182);
  *(_QWORD *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  v180 = 0uLL;
  result = (float *)kdu_node::get_dims(&v182, &v180);
  v15 = v180.i32[0];
  v16 = v180.i32[1];
  v17 = v180.i32[2];
  v18 = v180.i32[3];
  v19 = v180.i32[3] + v180.i32[1];
  v20 = v180.i32[3] + v180.i32[1] - 1;
  v21 = v180.i32[0] + v180.i32[2] - 1;
  *(_DWORD *)(a1 + 112) = v180.i32[0];
  *(_DWORD *)(a1 + 116) = v21;
  *(_DWORD *)(a1 + 124) = v16;
  *(_DWORD *)(a1 + 128) = v20;
  v23 = v18 < 1 || v17 < 1;
  *(_BYTE *)(a1 + 142) = v23;
  *(_BYTE *)(a1 + 140) = v21 == v15;
  *(_BYTE *)(a1 + 141) = v20 == v16;
  if (v23)
    return result;
  v165 = v18;
  v166 = v19;
  v24 = kdu_node::access_child((kdu_node *)&v182, 0);
  v184[0] = v24;
  v25 = kdu_node::access_child((kdu_node *)&v182, 1u);
  v184[1] = v25;
  v26 = kdu_node::access_child((kdu_node *)&v182, 2u);
  v184[2] = v26;
  v184[3] = kdu_node::access_child((kdu_node *)&v182, 3u);
  if (!v24)
    kd_analysis::init();
  *(_BYTE *)(a1 + 43) = v26 != 0;
  v27 = v25 != 0;
  *(_BYTE *)(a1 + 44) = v27;
  v178 = 1.0;
  v179 = 1.0;
  v176 = 1.0;
  v177 = 1.0;
  if (!v26)
  {
    v164 = 0;
    kernel_info = 0;
    goto LABEL_35;
  }
  v183[0] = 0;
  *(_QWORD *)v175 = 0;
  v174 = 0;
  kernel_info = kdu_node::get_kernel_info((kdu_node *)&v182, (int *)(a1 + 48), &v179, &v178, (BOOL *)(a1 + 96), (BOOL *)(a1 + 98), v183, &v175[1], v175, &v174, 1);
  if (v175[1] <= v174)
    v29 = v174;
  else
    v29 = v175[1];
  if (v183[0] >= v175[0])
    v30 = v175[0];
  else
    v30 = v183[0];
  LODWORD(v31) = *(_DWORD *)(a1 + 48);
  if ((int)v31 > 4)
  {
    v32 = operator new[]();
    *(_QWORD *)(a1 + 184) = v32;
    LODWORD(v31) = *(_DWORD *)(a1 + 48);
  }
  else
  {
    v32 = a1 + 576;
  }
  *(_QWORD *)(a1 + 80) = v32;
  if ((int)v31 < 1)
  {
    v33 = 0;
    LODWORD(v26) = 0;
LABEL_33:
    v37 = a1 + 272;
    goto LABEL_34;
  }
  v33 = 0;
  LODWORD(v26) = 0;
  v34 = *(_BYTE *)(a1 + 40);
  v35 = (_DWORD *)(kernel_info + 8);
  v31 = v31;
  do
  {
    *(_WORD *)(v32 + 4) = *(v35 - 1);
    v36 = *(v35 - 2);
    *(_BYTE *)(v32 + 1) = v36;
    *(_BYTE *)(v32 + 2) = *v35;
    *(_WORD *)(v32 + 6) = v35[1];
    if (v33 <= v36)
      v33 = v36;
    *(_BYTE *)(v32 + 30) = kernel_id;
    *(_BYTE *)(v32 + 29) = v34;
    LODWORD(v26) = v36 + v26;
    v32 += 32;
    v35 += 4;
    --v31;
  }
  while (v31);
  if (v33 <= 4)
    goto LABEL_33;
  v37 = operator new[]();
  *(_QWORD *)(a1 + 168) = v37;
LABEL_34:
  v164 = v29 - v30;
  *(_QWORD *)(a1 + 56) = v37 + 8 * v33;
  *(_QWORD *)(a1 + 64) = v37;
  v27 = *(unsigned __int8 *)(a1 + 44);
LABEL_35:
  v38 = (int *)(a1 + 52);
  if (v27)
  {
    v183[0] = 0;
    *(_QWORD *)v175 = 0;
    v174 = 0;
    v39 = kdu_node::get_kernel_info((kdu_node *)&v182, (int *)(a1 + 52), &v177, &v176, (BOOL *)(a1 + 97), (BOOL *)(a1 + 99), v183, &v175[1], v175, &v174, 0);
    if (v39 == kernel_info)
    {
      v41 = *(_QWORD *)(a1 + 80);
    }
    else
    {
      v40 = *v12;
      if ((int)v40 + *v38 > 4)
      {
        v41 = operator new[]();
        *(_QWORD *)(a1 + 192) = v41;
      }
      else
      {
        v41 = a1 + 32 * v40 + 576;
      }
    }
    *(_QWORD *)(a1 + 88) = v41;
    if (v41 != *(_QWORD *)(a1 + 80))
    {
      v42 = *v38;
      if ((int)v42 >= 1)
      {
        v43 = *(_BYTE *)(a1 + 40);
        v44 = (_DWORD *)(v39 + 8);
        do
        {
          *(_WORD *)(v41 + 4) = *(v44 - 1);
          v45 = *(v44 - 2);
          *(_BYTE *)(v41 + 1) = v45;
          *(_BYTE *)(v41 + 2) = *v44;
          *(_WORD *)(v41 + 6) = v44[1];
          *(_BYTE *)(v41 + 30) = kernel_id;
          *(_BYTE *)(v41 + 29) = v43;
          LODWORD(v26) = v45 + v26;
          v41 += 32;
          v44 += 4;
          --v42;
        }
        while (v42);
      }
    }
    *(_DWORD *)(a1 + 132) = ((v166 + 1) >> 1) - ((v16 + 1) >> 1);
    *(_DWORD *)(a1 + 136) = (v166 >> 1) - (v16 >> 1);
  }
  else
  {
    *(_QWORD *)(a1 + 132) = v165;
  }
  if ((int)v26 < 9)
  {
    v46 = a1 + 208;
    v47 = a1 + 240;
  }
  else
  {
    v46 = operator new[]();
    *(_QWORD *)(a1 + 152) = v46;
    v47 = operator new[]();
    *(_QWORD *)(a1 + 160) = v47;
  }
  if (*(_BYTE *)(a1 + 43))
  {
    kernel_coefficients = kdu_node::get_kernel_coefficients((kdu_node *)&v182, 1);
    v49 = *v12;
    if (*v12 >= 1)
    {
      v50 = 0;
      v51 = *(_QWORD *)(a1 + 80);
      v52 = *(unsigned __int8 *)(a1 + 40);
      do
      {
        v53 = v51 + 32 * v50;
        *(_BYTE *)v53 = v50;
        *(_QWORD *)(v53 + 8) = v46;
        *(_QWORD *)(v53 + 16) = v47;
        *(_BYTE *)(v53 + 28) = 0;
        v54 = *(unsigned __int8 *)(v53 + 1);
        if (v54)
        {
          v55 = v54;
          v56 = (float *)kernel_coefficients;
          v57 = (_DWORD *)v46;
          v58 = 0.4;
          do
          {
            v59 = *v56;
            *v57 = *(_DWORD *)v56;
            if (v59 <= v58)
            {
              if (v59 < (float)-v58)
                v58 = -v59;
            }
            else
            {
              v58 = v59;
            }
            ++v57;
            ++v56;
            --v55;
          }
          while (v55);
          if (v52)
          {
LABEL_67:
            v61 = *(_BYTE *)(v51 + 32 * v50 + 2);
            if ((_DWORD)v54)
              goto LABEL_71;
            goto LABEL_74;
          }
          v60 = v51 + 32 * v50;
          v61 = 16;
          *(_BYTE *)(v60 + 2) = 16;
          v62 = (unsigned __int8 *)(v60 + 2);
          if (v58 >= 0.499)
          {
            v61 = 16;
            do
            {
              --v61;
              v58 = v58 * 0.5;
            }
            while (v58 >= 0.499);
            *v62 = v61;
            if (v61 < 0x10u)
            {
              *(_WORD *)(v51 + 32 * v50 + 6) = 1 << (v61 - 1);
LABEL_71:
              v63 = (float)(1 << v61);
              v64 = v54;
              v65 = (float *)v46;
              v66 = (_DWORD *)v47;
              do
              {
                v67 = *v65++;
                *v66++ = vcvtmd_s64_f64((float)(v67 * v63) + 0.5);
                --v64;
              }
              while (v64);
              v49 = *v12;
              goto LABEL_74;
            }
          }
        }
        else
        {
          if (v52)
            goto LABEL_67;
          v61 = 16;
          *(_BYTE *)(v51 + 32 * v50 + 2) = 16;
        }
        *(_WORD *)(v51 + 32 * v50 + 6) = 0x7FFF;
        if ((_DWORD)v54)
          goto LABEL_71;
LABEL_74:
        v46 += 4 * v54;
        v47 += 4 * v54;
        kernel_coefficients += 4 * v54;
        v68 = v51 + 32 * v50;
        *(_BYTE *)(v68 + 3) = 0;
        *(_DWORD *)(v68 + 24) = 0;
        ++v50;
      }
      while (v50 < v49);
    }
  }
  if (*(_BYTE *)(a1 + 44))
  {
    v69 = kdu_node::get_kernel_coefficients((kdu_node *)&v182, 0);
    if (*v38 >= 1)
    {
      v70 = 0;
      v71 = 0;
      v73 = *(_QWORD *)(a1 + 80);
      v72 = *(_QWORD *)(a1 + 88);
      while (1)
      {
        if (v72 == v73)
        {
          v84 = v72 + 32 * v70;
          v75 = *(unsigned __int8 *)(v84 + 1);
          if (*(_BYTE *)(v84 + 1))
          {
            v85 = *(float **)(v84 + 8);
            v86 = v75;
            v87 = (float *)v69;
            do
            {
              if (*v85 != *v87)
                kd_analysis::init();
              ++v87;
              ++v85;
              --v86;
            }
            while (v86);
          }
          goto LABEL_105;
        }
        v74 = v72 + 32 * v70;
        *(_BYTE *)v74 = v70;
        *(_DWORD *)(v74 + 24) = 0;
        *(_QWORD *)(v74 + 8) = v46;
        *(_QWORD *)(v74 + 16) = v47;
        *(_BYTE *)(v74 + 28) = 0;
        v75 = *(unsigned __int8 *)(v74 + 1);
        if ((_DWORD)v75)
        {
          v76 = v75;
          v77 = (float *)v69;
          v78 = (_DWORD *)v46;
          v79 = 0.4;
          do
          {
            v80 = *v77;
            *v78 = *(_DWORD *)v77;
            if (v80 <= v79)
            {
              if (v80 < (float)-v79)
                v79 = -v80;
            }
            else
            {
              v79 = v80;
            }
            ++v78;
            ++v77;
            --v76;
          }
          while (v76);
          if (*(_BYTE *)(a1 + 40))
          {
LABEL_98:
            v82 = *(_BYTE *)(v72 + 32 * v70 + 2);
            if ((_DWORD)v75)
              goto LABEL_102;
            goto LABEL_104;
          }
          v81 = v72 + 32 * v70;
          v82 = 16;
          *(_BYTE *)(v81 + 2) = 16;
          v83 = (unsigned __int8 *)(v81 + 2);
          if (v79 >= 0.499)
          {
            v82 = 16;
            do
            {
              --v82;
              v79 = v79 * 0.5;
            }
            while (v79 >= 0.499);
            *v83 = v82;
            if (v82 < 0x10u)
            {
              *(_WORD *)(v72 + 32 * v70 + 6) = 1 << (v82 - 1);
LABEL_102:
              v88 = (float)(1 << v82);
              v89 = v75;
              v90 = (float *)v46;
              v91 = (_DWORD *)v47;
              do
              {
                v92 = *v90++;
                *v91++ = vcvtmd_s64_f64((float)(v92 * v88) + 0.5);
                --v89;
              }
              while (v89);
              goto LABEL_104;
            }
          }
        }
        else
        {
          if (*(_BYTE *)(a1 + 40))
            goto LABEL_98;
          v82 = 16;
          *(_BYTE *)(v72 + 32 * v70 + 2) = 16;
        }
        *(_WORD *)(v72 + 32 * v70 + 6) = 0x7FFF;
        if ((_DWORD)v75)
          goto LABEL_102;
LABEL_104:
        v46 += 4 * v75;
        v47 += 4 * v75;
LABEL_105:
        v93 = v72 + 32 * v70;
        v94 = *(__int16 *)(v93 + 4);
        if ((v70 & 1) != 0)
          v95 = -1;
        else
          v95 = 1;
        v96 = (*(unsigned __int8 *)(a1 + 124) << 31 >> 31) & v95;
        if ((v70 & 1) != 0)
          v97 = 1;
        else
          v97 = -1;
        v98 = v96 - v94;
        if ((*(_BYTE *)(a1 + 128) & 1) != 0)
          v97 = 0;
        v99 = v75 + v94 + v97 - 1;
        if (v98 > v99)
          v99 = v98;
        v100 = v99 & ~(v99 >> 31);
        if (v100 >= 0x100)
          kd_analysis::init();
        if (v100 > v71)
          v71 = v100;
        v69 += 4 * v75;
        *(_BYTE *)(v93 + 3) = v100;
        if (++v70 >= *v38)
          goto LABEL_121;
      }
    }
  }
  LOBYTE(v71) = 0;
LABEL_121:
  v101 = *v12;
  if (*v12 <= 0)
  {
    v104 = *(_DWORD *)(a1 + 132);
    if (v104 <= *(_DWORD *)(a1 + 136))
      LOBYTE(v104) = *(_DWORD *)(a1 + 136);
    v103 = v104 + v71;
    goto LABEL_136;
  }
  if (*(_BYTE *)(a1 + 140))
  {
    v102 = *(_DWORD *)(a1 + 132);
    if (v102 <= *(_DWORD *)(a1 + 136))
      LOBYTE(v102) = *(_DWORD *)(a1 + 136);
    v103 = v102 + v71;
  }
  else
  {
    if (v101 > 4)
    {
      v105 = operator new[]();
      *(_QWORD *)(a1 + 200) = v105;
      v101 = *(_DWORD *)(a1 + 48);
    }
    else
    {
      v105 = a1 + 704;
    }
    *(_QWORD *)(a1 + 104) = v105 + 48;
    v106 = *(_DWORD *)(a1 + 132);
    if (v106 <= *(_DWORD *)(a1 + 136))
      LOBYTE(v106) = *(_DWORD *)(a1 + 136);
    v103 = v106 + v71;
    if (v101 < 1)
      goto LABEL_136;
  }
  if (*(_BYTE *)(a1 + 140))
  {
LABEL_136:
    *(_QWORD *)(a1 + 72) = 0;
    LODWORD(v107) = 1;
LABEL_137:
    v108 = 0;
    v107 = v107;
    do
    {
      v109 = *(_QWORD *)(a1 + 176);
      v110 = (_QWORD *)(v109 + v108 + 32);
      if (!v109)
      {
        v110 = (_QWORD *)(a1 + 368 + v108);
        v109 = a1 + 336;
      }
      *v110 = *(_QWORD *)(a1 + 72);
      *(_QWORD *)(a1 + 72) = v109 + v108;
      result = (float *)kd_vlift_line::pre_create((kd_vlift_line *)(v109 + v108), a3, *(_DWORD *)(a1 + 132), *(_DWORD *)(a1 + 136), *(_BYTE *)(a1 + 40), a4, v71, v103, *(_BYTE *)(a1 + 44));
      v108 += 40;
      --v107;
    }
    while (v107);
    goto LABEL_141;
  }
  result = (float *)kd_analysis::simulate_vertical_lifting((kd_analysis *)a1, v164);
  LODWORD(v107) = (_DWORD)result;
  if (result >= 7)
  {
    result = (float *)operator new[]();
    v143 = result;
    do
    {
      for (i = 0; i != 8; i += 4)
      {
        v145 = &v143[i];
        *v145 = 0.0;
        *((_WORD *)v145 + 3) = 0;
        *((_QWORD *)v145 + 1) = 0;
      }
      v143 += 10;
    }
    while (v143 != &result[10 * v107]);
    *(_QWORD *)(a1 + 176) = result;
  }
  *(_QWORD *)(a1 + 72) = 0;
  if ((_DWORD)v107)
    goto LABEL_137;
LABEL_141:
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(a1 + 112);
  LODWORD(v111) = *(_DWORD *)(a1 + 48);
  if (!*(_QWORD *)(a1 + 104))
  {
LABEL_147:
    if ((int)v111 >= 1)
    {
      v117 = *(_DWORD *)(a1 + 112);
      v118 = v111;
      v119 = (v111 + 1) & 0x1FFFFFFFELL;
      v120 = (uint64x2_t)vdupq_n_s64(v118 - 1);
      v121 = v117 | 1;
      v122 = (v117 | 0xFFFFFFFE) + v117 + 2;
      v123 = (int64x2_t)xmmword_18820C490;
      v124 = (unsigned int *)(*(_QWORD *)(a1 + 80) + 56);
      v125 = vdupq_n_s64(2uLL);
      do
      {
        v126 = vmovn_s64((int64x2_t)vcgeq_u64(v120, (uint64x2_t)v123));
        if ((v126.i8[0] & 1) != 0)
          *(v124 - 8) = v121;
        if ((v126.i8[4] & 1) != 0)
          *v124 = v122;
        v123 = vaddq_s64(v123, v125);
        v124 += 16;
        v119 -= 2;
      }
      while (v119);
    }
    goto LABEL_154;
  }
  if ((v111 & 0x80000000) == 0)
  {
    v112 = -1;
    v113 = -48;
    do
    {
      v114 = *(_DWORD *)(a1 + 116);
      v115 = v114;
      if (v112 >= 1)
      {
        v116 = *(_QWORD *)(a1 + 80) + 32 * v112;
        v115 = v114
             - ((v114 ^ v112) & 1)
             + 2 * (*(__int16 *)(v116 + 4) + *(unsigned __int8 *)(v116 + 1))
             - 2;
      }
      result = (float *)kd_vlift_queue::init(*(_QWORD *)(a1 + 104) + v113, *(_DWORD *)(a1 + 112), v114, v112++, *(_BYTE *)(a1 + 98), v115);
      v111 = *(int *)(a1 + 48);
      v113 += 48;
    }
    while (v112 < v111);
    goto LABEL_147;
  }
LABEL_154:
  *(int32x4_t *)v183 = vdupq_lane_s32(*(int32x2_t *)&a8, 0);
  *(_DWORD *)(a1 + 100) = 0;
  if (!*(_BYTE *)(a1 + 40))
  {
    v175[1] = 0;
    bibo_gains = kdu_node::get_bibo_gains((kdu_node *)&v182, &v175[1], 1);
    if (v175[1] != *v12)
      kd_analysis::init();
    v128 = bibo_gains;
    result = (float *)kdu_node::get_bibo_gains((kdu_node *)&v182, &v175[1], 0);
    v129 = v175[1];
    if (v175[1] != *v38)
      kd_analysis::init();
    v130 = *v12;
    v131 = *(float *)&a8;
    v132 = *(float *)&a8;
    v133 = *(float *)&a8;
    if ((int)v130 >= 1)
    {
      v131 = *(float *)&a8;
      v132 = *(float *)&a8;
      v133 = *(float *)&a8;
      if (!*(_BYTE *)(a1 + 140))
      {
        v134 = 0;
        v132 = *(float *)&a8 / v179;
        *(float *)v183 = *(float *)&a8 / v179;
        *(float *)&v183[1] = *(float *)&a8 / v179;
        v131 = *(float *)&a8 / v178;
        *(float *)&v183[2] = *(float *)&a8 / v178;
        *(float *)&v183[3] = *(float *)&a8 / v178;
        v135 = *result * *(float *)&a8;
        v136 = (float *)(v128 + 4);
        v137 = v135;
        v133 = *(float *)&a8;
        do
        {
          v138 = v137;
          v137 = v135 * *v136;
          if (v137 > v133)
            v133 = v135 * *v136;
          if ((_DWORD)a4)
          {
            v139 = v138 + v138;
            if (*(_BYTE *)(*(_QWORD *)(a1 + 80) + v134 + 28) && v139 > v133)
              v133 = v139;
          }
          v134 += 32;
          ++v136;
        }
        while (32 * v130 != v134);
      }
    }
    if (v175[1] >= 1 && !*(_BYTE *)(a1 + 141))
    {
      *(float *)v183 = v132 / v177;
      *(float *)&v183[1] = v132 / v176;
      *(float *)&v183[2] = v131 / v177;
      *(float *)&v183[3] = v131 / v176;
      v141 = *(float *)(v128 + 4 * (int)v130);
      if ((int)v130 < 1)
      {
        v142 = *(float *)&a8;
      }
      else
      {
        v142 = *(float *)&a8;
        if (*(float *)(v128 + 4 * (v130 - 1)) > v141)
          v141 = *(float *)(v128 + 4 * (v130 - 1));
      }
      v146 = v141 * v142;
      v147 = result + 1;
      v148 = 28;
      v149 = v146;
      do
      {
        v150 = v149;
        v149 = v146 * *v147;
        if (v149 > v133)
          v133 = v146 * *v147;
        if ((_DWORD)a4)
        {
          v151 = v150 + v150;
          if (*(_BYTE *)(*(_QWORD *)(a1 + 88) + v148) && v151 > v133)
            v133 = v151;
        }
        v148 += 32;
        ++v147;
        --v129;
      }
      while (v129);
    }
    if (v133 > 7.6)
    {
      v153 = *(_DWORD *)(a1 + 100);
      v154 = *(float32x4_t *)v183;
      v155.i64[0] = 0x3F0000003F000000;
      v155.i64[1] = 0x3F0000003F000000;
      do
      {
        v154 = vmulq_f32(v154, v155);
        ++v153;
        v133 = v133 * 0.5;
      }
      while (v133 > 7.6);
      *(float32x4_t *)v183 = v154;
      *(_DWORD *)(a1 + 100) = v153;
    }
  }
  v156 = 0;
  v157 = 0;
  v158 = 0;
  v159 = (kdu_roi_level *)(a1 + 144);
  v160 = a1 + 8;
  do
  {
    if (v184[v156])
    {
      if ((v170 & 1) != 0)
        v161 = 0;
      else
        v161 = kdu_roi_level::acquire_node(v159, v158);
      if (kdu_node::access_child((kdu_node *)&v184[v156], 0))
      {
        result = (float *)kdu_analysis::kdu_analysis(&v172, v184[v156], (uint64_t)a3, a4, v161, a6, a7, *(float *)&v183[v157]);
        v162 = v172;
      }
      else
      {
        v163 = kdu_node::access_subband((kdu_node *)&v184[v156]);
        result = (float *)kdu_encoder::kdu_encoder(&v173, v163, a3, a4, v161, a6, a7, *(float *)&v183[v157]);
        v162 = v173;
      }
      *(_QWORD *)(v160 + v156 * 8) = v162;
    }
    ++v158;
    ++v157;
    ++v156;
  }
  while (v157 != 4);
  return result;
}

kd_analysis **kdu_analysis::kdu_analysis(kd_analysis **a1, uint64_t a2, kdu_sample_allocator *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, float a8)
{
  kd_analysis *v15;
  int32x4_t *v16;
  double v17;
  uint64_t v19;

  v19 = a2;
  *a1 = 0;
  v15 = (kd_analysis *)operator new();
  kd_analysis::kd_analysis(v15);
  *a1 = v15;
  v16 = (int32x4_t *)kdu_resolution::access_node((kdu_resolution *)&v19);
  *(float *)&v17 = a8;
  kd_analysis::init((uint64_t)v15, v16, a3, a4, a5, a6, a7, v17);
  return a1;
}

void sub_187F5B26C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C405B8F8FE9);
  _Unwind_Resume(a1);
}

uint64_t kd_analysis::simulate_vertical_lifting(kd_analysis *this, int a2)
{
  int v3;
  int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64x2_t v15;
  int v16;
  unsigned int v17;
  int64x2_t v18;
  unsigned int *v19;
  int64x2_t v20;
  int32x2_t v21;
  int v22;
  uint64_t result;
  int v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;

  v41 = 0;
  v3 = *((_DWORD *)this + 28);
  v4 = *((_DWORD *)this + 29);
  if (v4 - (v3 + a2) - 2 <= 0)
    v5 = 0;
  else
    v5 = (v4 - (v3 + a2) - 2) & 0xFFFFFFFE;
  v6 = v4 - v5;
  *((_DWORD *)this + 30) = v3;
  if ((*((_DWORD *)this + 12) & 0x80000000) == 0)
  {
    v7 = -1;
    v8 = -48;
    do
    {
      v9 = v6;
      if (v7 >= 1)
      {
        v10 = *((_QWORD *)this + 10) + 32 * v7;
        v9 = v6
           - ((v4 ^ v7) & 1)
           + 2 * (*(__int16 *)(v10 + 4) + *(unsigned __int8 *)(v10 + 1))
           - 2;
      }
      kd_vlift_queue::init(*((_QWORD *)this + 13) + v8, *((_DWORD *)this + 30), v6, v7++, *((_BYTE *)this + 98), v9);
      v11 = *((int *)this + 12);
      v8 += 48;
    }
    while (v7 < v11);
    v12 = *((unsigned int *)this + 12);
    if ((int)v11 >= 1)
    {
      v13 = *((_DWORD *)this + 28);
      v14 = (v12 + 1) & 0x1FFFFFFFELL;
      v15 = (uint64x2_t)vdupq_n_s64(v12 - 1);
      v16 = v13 | 1;
      v17 = (v13 | 0xFFFFFFFE) + v13 + 2;
      v18 = (int64x2_t)xmmword_18820C490;
      v19 = (unsigned int *)(*((_QWORD *)this + 10) + 56);
      v20 = vdupq_n_s64(2uLL);
      do
      {
        v21 = vmovn_s64((int64x2_t)vcgeq_u64(v15, (uint64x2_t)v18));
        if ((v21.i8[0] & 1) != 0)
          *(v19 - 8) = v16;
        if ((v21.i8[4] & 1) != 0)
          *v19 = v17;
        v18 = vaddq_s64(v18, v20);
        v19 += 16;
        v14 -= 2;
      }
      while (v14);
    }
  }
  v22 = *((_DWORD *)this + 30);
  if (v22 > v6)
    return 0;
  LODWORD(result) = 0;
  do
  {
    if (v41 >= (int)result)
      LODWORD(result) = v41 + 1;
    v40 = result;
    ++v41;
    kd_vlift_queue::simulate_push_line(*((_QWORD *)this + 13) + 48 * -(v22 & 1), v22, &v41);
    v24 = (*((_DWORD *)this + 30) & 1) == 0;
    do
    {
      if (v24 < 0)
        break;
      v25 = 0;
      v26 = 0;
      v27 = -1;
      v28 = 48;
      do
      {
        v29 = v27 + 1;
        v30 = *((int *)this + 12);
        if (v27 + 1 >= v30)
          break;
        v31 = *((_QWORD *)this + 10);
        v32 = v31 + v25;
        v33 = *(_DWORD *)(v31 + v25 + 24);
        v34 = (v33 ^ 1) + 2 * *(__int16 *)(v31 + v25 + 4);
        if (v33 <= v6)
        {
          v35 = *((_QWORD *)this + 13);
          *(_DWORD *)(v35 + v28 - 60) = v33;
          if (*(_DWORD *)(v35 + v28 - 72) > v33
            || *(_DWORD *)(v35 + v28 - 68) < v33
            || !kd_vlift_queue::simulate_access_source((kd_vlift_queue *)(v35 + v28 - 48), v34, *(unsigned __int8 *)(v31 + v25 + 1), &v41))
          {
            goto LABEL_36;
          }
          kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((_QWORD *)this + 13) + v28 - 96), *(_DWORD *)(v32 + 24), &v41);
          v37 = v40;
          v36 = v41;
          if (v41 >= v40)
            v37 = v41 + 1;
          v38 = (*((_DWORD *)this + 12) - 1);
          v40 = v37;
          ++v41;
          if (v29 == v38)
          {
            v41 = v36;
            kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((_QWORD *)this + 13) + v28 - 48), v34, &v41);
          }
          else
          {
            kd_vlift_queue::simulate_push_line(*((_QWORD *)this + 13) + v28, *(_DWORD *)(v32 + 24), &v41);
            v24 = v27 + 3;
          }
        }
        else if (v29 != (_DWORD)v30 - 1
               || (kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((_QWORD *)this + 13) + v28 - 48), v34, &v41) & 1) == 0)
        {
          goto LABEL_36;
        }
        *(_DWORD *)(v32 + 24) += 2;
        v26 = 1;
LABEL_36:
        ++v27;
        v28 += 48;
        v25 += 32;
      }
      while (v27 < v24);
    }
    while ((v26 & 1) != 0);
    v39 = *((_DWORD *)this + 30);
    v22 = v39 + 1;
    *((_DWORD *)this + 30) = v39 + 1;
    result = v40;
  }
  while (v39 < v6);
  return result;
}

uint64_t kd_vlift_line::pre_create(kd_vlift_line *this, kdu_sample_allocator *a2, int a3, int a4, char a5, int a6, unsigned __int8 a7, char a8, BOOL a9)
{
  uint64_t result;

  result = kdu_line_buf::pre_create(this, a2, a3, a5, a6, a7, a8 - a3);
  if (a9)
    return kdu_line_buf::pre_create((kd_vlift_line *)((char *)this + 16), a2, a4, a5, a6, a7, a8 - a4);
  return result;
}

uint64_t kd_vlift_queue::init(uint64_t this, int a2, int a3, int a4, unsigned __int8 a5, int a6)
{
  int v6;

  *(_BYTE *)(this + 45) = a4;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = a3;
  *(_DWORD *)(this + 32) = a2 - 1000;
  *(_DWORD *)(this + 36) = a2 - 1000;
  *(_DWORD *)(this + 24) = a2 - 1000;
  *(_BYTE *)(this + 44) = a5;
  if (((a6 >= a3) & a5) != 0)
    v6 = 2 * a3 - a6;
  else
    v6 = a3 - 1;
  *(_DWORD *)(this + 40) = v6;
  if (a4 < 0)
  {
    *(_DWORD *)(this + 40) = a3 + 2;
    *(_DWORD *)(this + 32) = a3 + 2;
  }
  *(_DWORD *)(this + 28) = a2 - 1002;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  return this;
}

void kd_analysis::~kd_analysis(kd_roi_level **this)
{
  uint64_t i;
  kd_roi_level *v3;
  kd_roi_level *v4;
  kd_roi_level *v5;
  kd_roi_level *v6;
  kd_roi_level *v7;
  kd_roi_level *v8;
  kd_roi_level *v9;
  kd_roi_level *v10;

  *this = (kd_roi_level *)&off_1E1BABFC8;
  for (i = 1; i != 5; ++i)
  {
    v3 = this[i];
    if (v3)
    {
      (*(void (**)(kd_roi_level *))(*(_QWORD *)v3 + 8))(v3);
      this[i] = 0;
    }
  }
  if (this[18])
    kdu_roi_level::destroy(this + 18);
  v4 = this[19];
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1000C8052888210);
  v5 = this[20];
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C8052888210);
  v6 = this[21];
  if (v6)
    MEMORY[0x18D761C18](v6, 0x80C80B8603338);
  v7 = this[22];
  if (v7)
    MEMORY[0x18D761C18](v7, 0x1020C803C8EFFD9);
  v8 = this[23];
  if (v8)
    MEMORY[0x18D761C18](v8, 0x1090C805C18EE7CLL);
  v9 = this[24];
  if (v9)
    MEMORY[0x18D761C18](v9, 0x1090C805C18EE7CLL);
  v10 = this[25];
  if (v10)
    MEMORY[0x18D761C18](v10, 0x1020C806F595497);
  *this = (kd_roi_level *)off_1E1BB14A8;
}

{
  kd_analysis::~kd_analysis(this);
  JUMPOUT(0x18D761C30);
}

uint64_t kd_vlift_queue::simulate_push_line(uint64_t this, int a2, int *a3)
{
  if (((*(unsigned __int8 *)(this + 45) ^ a2) & 1) != 0)
    kd_vlift_queue::simulate_push_line();
  if (*(_DWORD *)(this + 32) <= a2 || *(_DWORD *)(this + 36) <= a2)
  {
    if (*(_DWORD *)(this + 28) < *(_DWORD *)(this + 24))
      *(_DWORD *)(this + 24) = a2;
    *(_DWORD *)(this + 28) = a2;
  }
  else
  {
    --*a3;
  }
  return this;
}

uint64_t kd_vlift_queue::simulate_access_update(kd_vlift_queue *this, int a2, int *a3)
{
  int v3;

  if (((*((unsigned __int8 *)this + 45) ^ a2) & 1) != 0 || *((_DWORD *)this + 9) > a2)
    kd_vlift_queue::simulate_access_update();
  *((_DWORD *)this + 9) = a2;
  v3 = *((_DWORD *)this + 6);
  if (v3 > a2 || *((_DWORD *)this + 7) < a2)
    return 0;
  *((_DWORD *)this + 9) = a2 + 2;
  do
  {
    if (v3 >= *((_DWORD *)this + 8))
      break;
    if (*((_DWORD *)this + 7) < v3)
      break;
    if (v3 >= *((_DWORD *)this + 10))
      break;
    *((_DWORD *)this + 6) = v3 + 2;
    --*a3;
    v3 = *((_DWORD *)this + 6);
  }
  while (v3 < *((_DWORD *)this + 9));
  return 1;
}

uint64_t kd_vlift_queue::simulate_access_source(kd_vlift_queue *this, int a2, int a3, int *a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;

  if (((*((unsigned __int8 *)this + 45) ^ a2) & 1) != 0 || *((_DWORD *)this + 8) > a2)
    kd_vlift_queue::simulate_access_source();
  *((_DWORD *)this + 8) = a2;
  if (a3 <= 0)
  {
    v7 = *((_DWORD *)this + 6);
LABEL_21:
    *((_DWORD *)this + 8) = a2 + 2;
    while (v7 < *((_DWORD *)this + 9)
         && v7 < *((_DWORD *)this + 8)
         && *((_DWORD *)this + 7) >= v7
         && v7 < *((_DWORD *)this + 10))
    {
      *((_DWORD *)this + 6) = v7 + 2;
      --*a4;
      v7 = *((_DWORD *)this + 6);
    }
    return 1;
  }
  else
  {
    v4 = a3 - 1;
    v5 = a2 + 2 * (a3 - 1);
    v6 = *(_DWORD *)this;
    v7 = *((_DWORD *)this + 6);
    while (1)
    {
      v8 = v5;
      while (1)
      {
        while (v8 < v6)
        {
          if (*((_BYTE *)this + 44))
            v8 = 2 * *(_DWORD *)this - v8;
          else
            v8 = ((v6 ^ v8) & 1) + v6;
        }
        v9 = *((_DWORD *)this + 1);
        if (v8 <= v9)
          break;
        if (*((_BYTE *)this + 44))
          v8 = 2 * v9 - v8;
        else
          v8 = v9 - ((v9 ^ v8) & 1);
      }
      if (v8 < v7 || v8 > *((_DWORD *)this + 7))
        return 0;
      v5 -= 2;
      if (v4-- <= 0)
        goto LABEL_21;
    }
  }
}

uint64_t kd_analysis::push(uint64_t result, int *a2, kdu_thread_entity *this)
{
  int v3;
  uint64_t v5;
  kdu_thread_entity *v6;
  uint64_t i;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  float *v15;
  uint64_t v16;
  _WORD *v17;
  _WORD *v18;
  _WORD *v19;
  int v20;
  int v21;
  float *v22;
  float *v23;
  int v24;
  int v25;
  float *v26;
  int v27;
  float v28;
  int v29;
  float v30;
  uint64_t v32;
  char v33;
  char v34;
  uint64_t v35;
  _WORD *v36;
  int j;
  uint64_t v38;
  char v39;
  char v40;
  uint64_t v41;
  _DWORD *v42;
  int k;
  uint64_t v44;
  uint64_t v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _BYTE *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char v64;
  char v65;
  int v66;
  uint64_t *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v86;
  uint64_t v87;
  unsigned int v88;

  v3 = *(_DWORD *)(result + 120);
  if (v3 > *(_DWORD *)(result + 116))
    kd_analysis::push();
  v5 = result;
  if (*(_BYTE *)(result + 40) != (*((_BYTE *)a2 + 6) & 1))
    kd_analysis::push();
  if (*(_BYTE *)(result + 142))
  {
    *(_DWORD *)(result + 120) = v3 + 1;
    return result;
  }
  v6 = this;
  if (!*(_BYTE *)(result + 42))
  {
    if (this)
      result = kdu_thread_entity::acquire_lock(this, 3, 1);
    for (i = *(_QWORD *)(v5 + 72); i; i = *(_QWORD *)(i + 32))
    {
      kdu_line_buf::create(i);
      result = kdu_line_buf::create(i + 16);
    }
    *(_BYTE *)(v5 + 42) = 1;
    if (v6)
      result = kdu_thread_entity::release_lock(v6, 3);
  }
  v9 = (_QWORD *)(v5 + 72);
  v8 = *(_QWORD *)(v5 + 72);
  if (!v8)
    kd_analysis::push();
  if (*(_BYTE *)(v5 + 43))
    v10 = *(_DWORD *)(v5 + 120) & 1;
  else
    v10 = 0;
  if (*(int *)(v5 + 48) < 1 || *(_BYTE *)(v5 + 140))
  {
    v11 = 0;
  }
  else
  {
    *(_QWORD *)(v5 + 72) = *(_QWORD *)(v8 + 32);
    *(_QWORD *)(v8 + 32) = 0;
    v11 = *(_QWORD *)(v5 + 104) + 48 * -v10;
    result = kd_vlift_queue::push_line(v11, *(_DWORD *)(v5 + 120), v8, (_QWORD *)(v5 + 72));
  }
  ++*(_DWORD *)(v5 + 120);
  v12 = *a2;
  if (*a2 != *(_DWORD *)(v5 + 136) + *(_DWORD *)(v5 + 132))
    kd_analysis::push();
  v13 = v12 + 1;
  v14 = (v12 + 1) >> 1;
  v15 = (float *)*((_QWORD *)a2 + 1);
  if (*(_BYTE *)(v5 + 44))
  {
    v16 = *(_DWORD *)(v5 + 124) & 1;
    if (*(_BYTE *)(v5 + 41))
    {
      v17 = 0;
      if ((*((_BYTE *)a2 + 6) & 2) == 0)
        v15 = 0;
      if ((*(_BYTE *)(v8 + 16 * v16 + 6) & 2) != 0)
        v17 = *(_WORD **)(v8 + 16 * v16 + 8);
      if ((*(_BYTE *)(v8 + 16 * !(*(_BYTE *)(v5 + 124) & 1) + 6) & 2) != 0)
        v18 = *(_WORD **)(v8 + 16 * !(*(_BYTE *)(v5 + 124) & 1) + 8);
      else
        v18 = 0;
      v24 = *(_DWORD *)(v5 + 100);
      if (v24)
      {
        if (v13 >= 2)
        {
          v25 = 0x8000 << v24 >> 16;
          do
          {
            *v17++ = (v25 + *(__int16 *)v15) >> *(_DWORD *)(v5 + 100);
            *v18++ = (v25 + *((__int16 *)v15++ + 1)) >> *(_DWORD *)(v5 + 100);
            --v14;
          }
          while (v14);
        }
      }
      else if (v13 >= 2)
      {
        do
        {
          *v17++ = *(_WORD *)v15;
          *v18++ = *((_WORD *)v15++ + 1);
          --v14;
        }
        while (v14);
      }
    }
    else
    {
      v22 = 0;
      if ((*((_BYTE *)a2 + 6) & 2) != 0)
        v15 = 0;
      if ((*(_BYTE *)(v8 + 16 * v16 + 6) & 2) == 0)
        v22 = *(float **)(v8 + 16 * v16 + 8);
      if ((*(_BYTE *)(v8 + 16 * !(*(_BYTE *)(v5 + 124) & 1) + 6) & 2) != 0)
        v23 = 0;
      else
        v23 = *(float **)(v8 + 16 * !(*(_BYTE *)(v5 + 124) & 1) + 8);
      v29 = *(_DWORD *)(v5 + 100);
      if (v29)
      {
        if (v13 >= 2)
        {
          v30 = 1.0 / (float)(1 << v29);
          do
          {
            *v22++ = v30 * *v15;
            *v23++ = v30 * v15[1];
            v15 += 2;
            --v14;
          }
          while (v14);
        }
      }
      else if (v13 >= 2)
      {
        do
        {
          *v22++ = *v15;
          *v23++ = v15[1];
          v15 += 2;
          --v14;
        }
        while (v14);
      }
    }
  }
  else if (*(_BYTE *)(v5 + 41))
  {
    v19 = 0;
    if ((*((_BYTE *)a2 + 6) & 2) == 0)
      v15 = 0;
    if ((*(_BYTE *)(v8 + 6) & 2) != 0)
      v19 = *(_WORD **)(v8 + 8);
    v20 = *(_DWORD *)(v5 + 100);
    if (v20)
    {
      if (v13 >= 2)
      {
        v21 = 0x8000 << v20 >> 16;
        do
        {
          *v19 = (v21 + *(__int16 *)v15) >> *(_DWORD *)(v5 + 100);
          v19[1] = (v21 + *((__int16 *)v15++ + 1)) >> *(_DWORD *)(v5 + 100);
          v19 += 2;
          --v14;
        }
        while (v14);
      }
    }
    else if (v13 >= 2)
    {
      do
      {
        *v19 = *(_WORD *)v15;
        v19[1] = *((_WORD *)v15++ + 1);
        v19 += 2;
        --v14;
      }
      while (v14);
    }
  }
  else
  {
    v26 = 0;
    if ((*((_BYTE *)a2 + 6) & 2) != 0)
      v15 = 0;
    if ((*(_BYTE *)(v8 + 6) & 2) == 0)
      v26 = *(float **)(v8 + 8);
    v27 = *(_DWORD *)(v5 + 100);
    if (v27)
    {
      if (v13 >= 2)
      {
        v28 = 1.0 / (float)(1 << v27);
        do
        {
          *v26 = v28 * *v15;
          v26[1] = v28 * v15[1];
          v15 += 2;
          v26 += 2;
          --v14;
        }
        while (v14);
      }
    }
    else if (v13 >= 2)
    {
      do
      {
        *v26 = *v15;
        v26[1] = v15[1];
        v15 += 2;
        v26 += 2;
        --v14;
      }
      while (v14);
    }
  }
  if (*(_BYTE *)(v5 + 140))
  {
    if (*(_BYTE *)(v5 + 40) && v10 != 0)
    {
      if (!*(_BYTE *)(v5 + 43))
        kd_analysis::push();
      if (*(_BYTE *)(v5 + 41))
      {
        v32 = 0;
        v33 = 1;
        do
        {
          v34 = v33;
          v35 = v8 + 16 * v32;
          if ((*(_BYTE *)(v35 + 6) & 2) != 0)
            v36 = *(_WORD **)(v35 + 8);
          else
            v36 = 0;
          for (j = *(_DWORD *)v35; j; --j)
            *v36++ *= 2;
          v33 = 0;
          v32 = 1;
        }
        while ((v34 & 1) != 0);
      }
      else
      {
        v38 = 0;
        v39 = 1;
        do
        {
          v40 = v39;
          v41 = v8 + 16 * v38;
          if ((*(_BYTE *)(v41 + 6) & 2) != 0)
            v42 = 0;
          else
            v42 = *(_DWORD **)(v41 + 8);
          for (k = *(_DWORD *)v41; k; --k)
            *v42++ *= 2;
          v39 = 0;
          v38 = 1;
        }
        while ((v40 & 1) != 0);
      }
    }
  }
  if (!v11)
    return kd_analysis::horizontal_analysis(v5, v8, v10, (uint64_t)v6);
  if (*(int *)(v5 + 48) < 1 || *(_BYTE *)(v5 + 140))
    kd_analysis::push();
  v44 = v10 ^ 1u;
  v86 = (_QWORD *)(v5 + 72);
  v87 = (uint64_t)v6;
  do
  {
    if ((v44 & 0x80000000) != 0)
      return result;
    v45 = 0;
    v46 = 0;
    do
    {
      v47 = *(int *)(v5 + 48);
      if (v45 >= v47)
        break;
      v48 = *(_QWORD *)(v5 + 80);
      v49 = v48 + 32 * v45;
      v51 = (int *)(v49 + 24);
      v50 = *(_DWORD *)(v49 + 24);
      v52 = (v50 ^ 1) + 2 * *(__int16 *)(v49 + 4);
      if (v50 <= *(_DWORD *)(v5 + 116))
      {
        v54 = *(_QWORD *)(v5 + 104);
        v55 = v45 - 1;
        v56 = v54 + 48 * (v45 - 1);
        *(_DWORD *)(v56 + 36) = v50;
        if (*(_DWORD *)(v56 + 24) > v50 || *(_DWORD *)(v54 + 48 * v55 + 28) < v50)
          continue;
        v88 = v44;
        v57 = v48 + 32 * v45;
        v59 = *(unsigned __int8 *)(v57 + 1);
        v58 = (_BYTE *)(v57 + 1);
        result = kd_vlift_queue::access_source((int *)(v54 + 48 * v45), v52, v59, *(_QWORD *)(v5 + 56), v9);
        if (!(_DWORD)result)
        {
          v44 = v88;
          continue;
        }
        v60 = kd_vlift_queue::access_update(*(_QWORD *)(v5 + 104) + 48 * v55, *v51, v9);
        v61 = *(_QWORD *)(v5 + 72);
        if (!v61)
          kd_analysis::push();
        if (*v58)
        {
          v62 = v60;
          v63 = 0;
          v64 = 1;
          do
          {
            v65 = v64;
            v66 = *(_DWORD *)(v5 + 4 * v63 + 132);
            if (v66)
            {
              v67 = *(uint64_t **)(v5 + 64);
              v68 = *v58;
              if (*(_BYTE *)(v5 + 41))
              {
                if (*v58)
                {
                  v69 = 0;
                  v70 = 8 * v68;
                  do
                  {
                    v71 = *(_QWORD *)(*(_QWORD *)(v5 + 56) + v69) + 16 * v63;
                    if ((*(_BYTE *)(v71 + 6) & 2) != 0)
                      v72 = *(_QWORD *)(v71 + 8);
                    else
                      v72 = 0;
                    v67[v69 / 8] = v72;
                    v69 += 8;
                  }
                  while (v70 != v69);
                }
                v73 = v62 + 16 * v63;
                if ((*(_BYTE *)(v73 + 6) & 2) != 0)
                  v74 = *(_QWORD *)(v73 + 8);
                else
                  v74 = 0;
                v81 = v61 + 16 * v63;
                if ((*(_BYTE *)(v81 + 6) & 2) != 0)
                  v82 = *(_QWORD *)(v81 + 8);
                else
                  v82 = 0;
                perform_analysis_lifting_step(v49, v67, v74, v82, v66, 0);
              }
              else
              {
                if (*v58)
                {
                  v75 = 0;
                  v76 = 8 * v68;
                  do
                  {
                    v77 = *(_QWORD *)(*(_QWORD *)(v5 + 56) + v75) + 16 * v63;
                    if ((*(_BYTE *)(v77 + 6) & 2) != 0)
                      v78 = 0;
                    else
                      v78 = *(_QWORD *)(v77 + 8);
                    v67[v75 / 8] = v78;
                    v75 += 8;
                  }
                  while (v76 != v75);
                }
                v79 = v62 + 16 * v63;
                if ((*(_BYTE *)(v79 + 6) & 2) != 0)
                  v80 = 0;
                else
                  v80 = *(_QWORD *)(v79 + 8);
                v83 = v61 + 16 * v63;
                if ((*(_BYTE *)(v83 + 6) & 2) != 0)
                  v84 = 0;
                else
                  v84 = *(_QWORD *)(v83 + 8);
                perform_analysis_lifting_step(v49, v67, v80, v84, v66, 0);
              }
            }
            v64 = 0;
            v63 = 1;
          }
          while ((v65 & 1) != 0);
        }
        if (v45 == *(_DWORD *)(v5 + 48) - 1)
        {
          v6 = (kdu_thread_entity *)v87;
          kd_analysis::horizontal_analysis(v5, v61, !(v45 & 1), v87);
          v9 = (_QWORD *)(v5 + 72);
          result = kd_vlift_queue::access_update(*(_QWORD *)(v5 + 104) + 48 * v45, v52, v86);
          if (result)
            result = kd_analysis::horizontal_analysis(v5, result, v45 & 1, v87);
          v44 = v88;
        }
        else
        {
          *(_QWORD *)(v5 + 72) = *(_QWORD *)(v61 + 32);
          *(_QWORD *)(v61 + 32) = 0;
          v9 = (_QWORD *)(v5 + 72);
          result = kd_vlift_queue::push_line(*(_QWORD *)(v5 + 104) + 48 * (v45 + 1), *v51, v61, v86);
          v44 = (v45 + 2);
          v6 = (kdu_thread_entity *)v87;
        }
LABEL_111:
        *v51 += 2;
        v46 = 1;
        continue;
      }
      if (v45 == (_DWORD)v47 - 1)
      {
        v53 = v44;
        result = kd_vlift_queue::access_update(*(_QWORD *)(v5 + 104) + 48 * v45, v52, v9);
        if (!result)
        {
          v44 = v53;
          continue;
        }
        result = kd_analysis::horizontal_analysis(v5, result, v45 & 1, (uint64_t)v6);
        v44 = v53;
        goto LABEL_111;
      }
    }
    while (v45++ < (int)v44);
  }
  while ((v46 & 1) != 0);
  return result;
}

uint64_t kd_vlift_queue::push_line(uint64_t result, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;

  if (((*(unsigned __int8 *)(result + 45) ^ a2) & 1) != 0)
    kd_vlift_queue::push_line();
  if (*(_DWORD *)(result + 32) <= a2 || *(_DWORD *)(result + 36) <= a2)
  {
    *(_QWORD *)(a3 + 32) = 0;
    v5 = *(_QWORD *)(result + 16);
    if (v5)
    {
      if (*(_DWORD *)(result + 28) + 2 != a2)
        kd_vlift_queue::push_line();
      *(_QWORD *)(v5 + 32) = a3;
      *(_QWORD *)(result + 16) = a3;
    }
    else
    {
      *(_QWORD *)(result + 8) = a3;
      *(_QWORD *)(result + 16) = a3;
      *(_DWORD *)(result + 24) = a2;
    }
    *(_DWORD *)(result + 28) = a2;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = *a4;
    for (*a4 = a3; ; *a4 = v4)
    {
      v4 = *(_QWORD *)(result + 8);
      *(_QWORD *)(result + 16) = v4;
      if (!v4)
        break;
      *(_QWORD *)(result + 8) = *(_QWORD *)(v4 + 32);
      *(_QWORD *)(v4 + 32) = *a4;
    }
  }
  return result;
}

uint64_t kd_analysis::horizontal_analysis(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5;
  int v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  int v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  _WORD *v21;
  _DWORD *v22;
  uint64_t v23;
  _WORD *v24;
  uint64_t v25;
  _WORD *v26;
  uint64_t v27;
  int v28;
  unsigned __int8 *v29;
  int v30;
  unint64_t v31;
  _WORD *v32;
  uint64_t v33;
  _WORD *v34;
  unint64_t v35;
  _WORD *v36;
  _BOOL4 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int *v41;
  int v42;
  uint64_t v43;
  char v44;
  int v45;
  __int16 *v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  float *v54;
  uint64_t v55;
  _DWORD *v56;
  uint64_t v57;
  int v58;
  unsigned __int8 *v59;
  int v60;
  unint64_t v61;
  _DWORD *v62;
  uint64_t v63;
  _DWORD *v64;
  unint64_t v65;
  _DWORD *v66;
  _BOOL4 v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  float *v71;
  float v72;
  float v73;
  int v74;
  uint64_t v75;
  char v76;
  int v77;
  int v78;
  _DWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  char v83;
  int v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  float v91;
  __int16 *v92;
  __int16 *v93;
  float *v94;
  _DWORD *v95;
  _DWORD *v96;
  uint64_t v97;

  if (*(_DWORD *)(result + 132) != *(_DWORD *)a2 || (v5 = result, *(_DWORD *)(result + 136) != *(_DWORD *)(a2 + 16)))
    kd_analysis::horizontal_analysis();
  if (*(_BYTE *)(result + 141)
    && *(int *)(result + 52) >= 1
    && *(_BYTE *)(result + 40)
    && (*(_BYTE *)(result + 124) & 1) != 0)
  {
    if (!*(_BYTE *)(result + 44))
      kd_analysis::horizontal_analysis();
    if (*(_BYTE *)(result + 41))
      **(_WORD **)(a2 + 24) *= 2;
    else
      **(_DWORD **)(a2 + 24) *= 2;
  }
  v7 = *(_DWORD *)(result + 52);
  if (v7 && !*(_BYTE *)(result + 141))
  {
    if (v7 < 1)
    {
LABEL_112:
      v97 = v5 + 16 * a3;
      (*(void (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v97 + 8) + 16))(*(_QWORD *)(v97 + 8), a2, a4);
      return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(v97 + 16) + 16))(*(_QWORD *)(v97 + 16), a2 + 16, a4);
    }
    v13 = 0;
    while (1)
    {
      v14 = *(_QWORD *)(v5 + 88);
      v15 = v14 + 32 * v13;
      v17 = *(unsigned __int8 *)(v15 + 1);
      v16 = (unsigned __int8 *)(v15 + 1);
      if (v17)
      {
        v18 = (v13 & 1) == 0;
        v19 = *(unsigned int *)(v5 + 4 * v18 + 132);
        v20 = v13 & 1;
        if (*(_BYTE *)(v5 + 41))
        {
          if ((*(_BYTE *)(a2 + 16 * (v13 & 1) + 6) & 2) != 0)
            v21 = *(_WORD **)(a2 + 16 * v20 + 8);
          else
            v21 = 0;
          v23 = a2 + 16 * v18;
          if ((*(_BYTE *)(v23 + 6) & 2) != 0)
            v24 = *(_WORD **)(v23 + 8);
          else
            v24 = 0;
          v25 = *(int *)(v5 + 4 * v20 + 132);
          v26 = &v21[v25];
          v27 = v14 + 32 * v13;
          v30 = *(unsigned __int8 *)(v27 + 3);
          v29 = (unsigned __int8 *)(v27 + 3);
          v28 = v30;
          if (*(_BYTE *)(v5 + 99))
          {
            if (v28)
            {
              v31 = 0;
              v32 = v26 - 1;
              v33 = -1;
              v34 = &v21[v25];
              do
              {
                v21[v33] = v21[v31 - ((*(_DWORD *)(v5 + 124) ^ v13) & 1) + 1];
                v34[v31++] = v32[v33 + ((*(_DWORD *)(v5 + 128) ^ v13) & 1)];
                --v33;
              }
              while (v31 < *v29);
            }
          }
          else if (v28)
          {
            v35 = 0;
            v36 = v21 - 1;
            do
            {
              *v36-- = *v21;
              v26[v35++] = *(v26 - 1);
            }
            while (v35 < *v29);
          }
          v37 = (*(unsigned __int8 *)(v5 + 124) << 31 >> 31) & (1 - 2 * v18);
          v38 = v14 + 32 * v13;
          v39 = *(__int16 *)(v38 + 4);
          v40 = *v16;
          v41 = *(int **)(v38 + 16);
          if ((_DWORD)v40 == 2 && (v42 = *v41, *v41 == v41[1]))
          {
            v43 = v14 + 32 * v13;
            v44 = *(_BYTE *)(v43 + 2);
            v45 = *(__int16 *)(v43 + 6);
            if (v42 == 1)
            {
              if ((int)v19 >= 1)
              {
                v92 = &v21[v39 + 1 + v37];
                do
                {
                  *v24++ += (*(v92 - 1) + v45 + *v92) >> v44;
                  ++v92;
                  --v19;
                }
                while (v19);
              }
            }
            else if (v42 == -1)
            {
              if ((int)v19 >= 1)
              {
                v46 = &v21[v39 + 1 + v37];
                do
                {
                  *v24++ += (v45 - (*(v46 - 1) + *v46)) >> v44;
                  ++v46;
                  --v19;
                }
                while (v19);
              }
            }
            else if ((int)v19 >= 1)
            {
              v93 = &v21[v39 + 1 + v37];
              do
              {
                *v24++ += (v45 + (*v93 + *(v93 - 1)) * v42) >> v44;
                ++v93;
                --v19;
              }
              while (v19);
            }
          }
          else if ((int)v19 >= 1)
          {
            v47 = 0;
            v48 = (uint64_t)&v21[v37 + v39];
            v49 = *(_BYTE *)(v38 + 2);
            v50 = *(__int16 *)(v38 + 6);
            do
            {
              v51 = v50;
              if ((_DWORD)v40)
              {
                v52 = 0;
                v51 = v50;
                do
                {
                  v51 += v41[v52] * *(__int16 *)(v48 + 2 * v52);
                  ++v52;
                }
                while (v40 != v52);
              }
              v24[v47++] += v51 >> v49;
              v48 += 2;
            }
            while (v47 != v19);
          }
        }
        else
        {
          if ((*(_BYTE *)(a2 + 16 * (v13 & 1) + 6) & 2) != 0)
            v22 = 0;
          else
            v22 = *(_DWORD **)(a2 + 16 * v20 + 8);
          v53 = a2 + 16 * v18;
          if ((*(_BYTE *)(v53 + 6) & 2) != 0)
            v54 = 0;
          else
            v54 = *(float **)(v53 + 8);
          v55 = *(int *)(v5 + 4 * v20 + 132);
          v56 = &v22[v55];
          v57 = v14 + 32 * v13;
          v60 = *(unsigned __int8 *)(v57 + 3);
          v59 = (unsigned __int8 *)(v57 + 3);
          v58 = v60;
          if (*(_BYTE *)(v5 + 99))
          {
            if (v58)
            {
              v61 = 0;
              v62 = v56 - 1;
              v63 = -1;
              v64 = &v22[v55];
              do
              {
                v22[v63] = v22[v61 - ((*(_DWORD *)(v5 + 124) ^ v13) & 1) + 1];
                v64[v61++] = v62[v63 + ((*(_DWORD *)(v5 + 128) ^ v13) & 1)];
                --v63;
              }
              while (v61 < *v59);
            }
          }
          else if (v58)
          {
            v65 = 0;
            v66 = v22 - 1;
            do
            {
              *v66-- = *v22;
              v56[v65++] = *(v56 - 1);
            }
            while (v65 < *v59);
          }
          v67 = (*(unsigned __int8 *)(v5 + 124) << 31 >> 31) & (1 - 2 * v18);
          v68 = v14 + 32 * v13;
          v69 = *(__int16 *)(v68 + 4);
          v70 = *v16;
          if ((_DWORD)v70 != 2)
          {
            v74 = *(unsigned __int8 *)(v5 + 40);
LABEL_75:
            v80 = (uint64_t)&v22[v67 + v69];
            if (v74)
            {
              if ((int)v19 >= 1)
              {
                v81 = 0;
                v82 = v14 + 32 * v13;
                v83 = *(_BYTE *)(v82 + 2);
                v84 = *(__int16 *)(v82 + 6);
                v85 = *(_QWORD *)(v82 + 16);
                do
                {
                  v86 = v84;
                  if ((_DWORD)v70)
                  {
                    v87 = 0;
                    v86 = v84;
                    do
                    {
                      v86 += *(_DWORD *)(v80 + v87) * *(_DWORD *)(v85 + v87);
                      v87 += 4;
                    }
                    while (4 * v70 != v87);
                  }
                  LODWORD(v54[v81++]) += v86 >> v83;
                  v80 += 4;
                }
                while (v81 != v19);
              }
            }
            else if ((int)v19 >= 1)
            {
              v88 = 0;
              v89 = *(_QWORD *)(v14 + 32 * v13 + 8);
              do
              {
                if ((_DWORD)v70)
                {
                  v90 = 0;
                  v91 = 0.0;
                  do
                  {
                    v91 = v91 + (float)(*(float *)(v89 + v90) * *(float *)(v80 + v90));
                    v90 += 4;
                  }
                  while (4 * v70 != v90);
                }
                else
                {
                  v91 = 0.0;
                }
                v54[v88] = v91 + v54[v88];
                ++v88;
                v80 += 4;
              }
              while (v88 != v19);
            }
            goto LABEL_111;
          }
          v71 = *(float **)(v68 + 8);
          v72 = *v71;
          v73 = v71[1];
          v74 = *(unsigned __int8 *)(v5 + 40);
          if (v72 != v73)
            goto LABEL_75;
          if (*(_BYTE *)(v5 + 40))
          {
            v75 = v14 + 32 * v13;
            v76 = *(_BYTE *)(v75 + 2);
            v77 = *(__int16 *)(v75 + 6);
            v78 = **(_DWORD **)(v75 + 16);
            if (v78 == 1)
            {
              if ((int)v19 >= 1)
              {
                v95 = &v22[v69 + 1 + v67];
                do
                {
                  *(_DWORD *)v54++ += (*(v95 - 1) + v77 + *v95) >> v76;
                  ++v95;
                  --v19;
                }
                while (v19);
              }
            }
            else if (v78 == -1)
            {
              if ((int)v19 >= 1)
              {
                v79 = &v22[v69 + 1 + v67];
                do
                {
                  *(_DWORD *)v54++ += (v77 - (*(v79 - 1) + *v79)) >> v76;
                  ++v79;
                  --v19;
                }
                while (v19);
              }
            }
            else if ((int)v19 >= 1)
            {
              v96 = &v22[v69 + 1 + v67];
              do
              {
                *(_DWORD *)v54++ += (v77 + (*v96 + *(v96 - 1)) * v78) >> v76;
                ++v96;
                --v19;
              }
              while (v19);
            }
          }
          else if ((int)v19 >= 1)
          {
            v94 = (float *)&v22[v69 + 1 + v67];
            do
            {
              *v54 = *v54 + (float)(v72 * (float)(*(v94 - 1) + *v94));
              ++v54;
              ++v94;
              --v19;
            }
            while (v19);
          }
        }
      }
LABEL_111:
      if (++v13 >= *(int *)(v5 + 52))
        goto LABEL_112;
    }
  }
  v8 = 0;
  v9 = 2 * a3;
  v10 = 1;
  do
  {
    v11 = v10;
    if (*(int *)(v5 + 4 * v8 + 132) >= 1)
    {
      v12 = *(_QWORD *)(v5 + 8 * (v8 | v9) + 8);
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 16))(v12, a2 + 16 * v8, a4);
    }
    v10 = 0;
    v8 = 1;
  }
  while ((v11 & 1) != 0);
  return result;
}

uint64_t kd_vlift_queue::access_update(uint64_t a1, int a2, _QWORD *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;

  if (((*(unsigned __int8 *)(a1 + 45) ^ a2) & 1) != 0 || *(_DWORD *)(a1 + 36) > a2)
    kd_vlift_queue::access_update();
  *(_DWORD *)(a1 + 36) = a2;
  v3 = *(_DWORD *)(a1 + 24);
  if (v3 > a2 || *(_DWORD *)(a1 + 28) < a2)
    return 0;
  v6 = *(_QWORD *)(a1 + 8);
  v4 = v6;
  if (v3 < a2)
  {
    v4 = *(_QWORD *)(a1 + 8);
    v7 = a2;
    do
    {
      v7 -= 2;
      v4 = *(_QWORD *)(v4 + 32);
    }
    while (v7 > v3);
  }
  if (!v4)
    kd_vlift_queue::access_update();
  v8 = a2 + 2;
  *(_DWORD *)(a1 + 36) = a2 + 2;
  if (*(_DWORD *)(a1 + 32) < a2 + 2)
    v8 = *(_DWORD *)(a1 + 32);
  while (v3 < v8 && v6 && v3 < *(_DWORD *)(a1 + 40))
  {
    v3 += 2;
    *(_DWORD *)(a1 + 24) = v3;
    v9 = *(_QWORD *)(v6 + 32);
    *(_QWORD *)(v6 + 32) = *a3;
    *a3 = v6;
    *(_QWORD *)(a1 + 8) = v9;
    if (!v9)
      *(_QWORD *)(a1 + 16) = 0;
    v6 = v9;
  }
  return v4;
}

uint64_t kd_vlift_queue::access_source(int *a1, int a2, int a3, uint64_t a4, _QWORD *a5)
{
  int v5;
  int v6;
  int v7;
  _QWORD *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t i;
  int v17;
  uint64_t v18;
  uint64_t v19;

  if (((*((unsigned __int8 *)a1 + 45) ^ a2) & 1) != 0 || a1[8] > a2)
    kd_vlift_queue::access_source();
  a1[8] = a2;
  v5 = a3 - 1;
  v6 = a2 + 2 * (a3 - 1);
  v7 = a1[7];
  if (v6 > v7 && v6 <= a1[1])
    return 0;
  if (a3 <= 0)
  {
    v11 = a1[6];
LABEL_25:
    v17 = a2 + 2;
    a1[8] = a2 + 2;
    if (a1[9] < a2 + 2)
      v17 = a1[9];
    if (v11 < v17)
    {
      v18 = *((_QWORD *)a1 + 1);
      do
      {
        if (!v18 || v11 >= a1[10])
          break;
        v11 += 2;
        a1[6] = v11;
        v19 = *(_QWORD *)(v18 + 32);
        *(_QWORD *)(v18 + 32) = *a5;
        *a5 = v18;
        *((_QWORD *)a1 + 1) = v19;
        if (!v19)
          *((_QWORD *)a1 + 2) = 0;
        v18 = v19;
      }
      while (v11 < v17);
    }
    return 1;
  }
  else
  {
    v8 = (_QWORD *)(a4 + 8 * v5);
    v9 = *a1;
    v10 = 2 * *a1;
    v11 = a1[6];
    while (1)
    {
      v12 = v6;
      while (1)
      {
        while (v12 < v9)
        {
          if (*((_BYTE *)a1 + 44))
            v12 = v10 - v12;
          else
            v12 = ((v9 ^ v12) & 1) + v9;
        }
        v13 = a1[1];
        if (v12 <= v13)
          break;
        if (*((_BYTE *)a1 + 44))
          v12 = 2 * v13 - v12;
        else
          v12 = v13 - ((v13 ^ v12) & 1);
      }
      v14 = 0;
      if (v12 > v7 || v12 < v11)
        break;
      for (i = *((_QWORD *)a1 + 1); ; i = *(_QWORD *)(i + 32))
      {
        *v8 = i;
        if (v12 <= v11)
          break;
        v12 -= 2;
      }
      v6 -= 2;
      --v8;
      if (v5-- <= 0)
        goto LABEL_25;
    }
  }
  return v14;
}

uint64_t perform_analysis_lifting_step(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  int v21;
  uint64_t v22;
  char v23;
  int v24;
  uint64_t v25;
  int v26;
  int *v27;
  uint64_t v28;
  uint64_t *v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;

  if (a5 >= 1)
  {
    if (a6 >= 16)
      v6 = 16;
    else
      v6 = a6;
    v7 = a6 - v6 + 7;
    v8 = v7 & 0xFFFFFFF8;
    v9 = 16 * (v7 >> 3) + 16;
    v10 = a6 - v8 - 8;
    v11 = a4 + v9;
    if (a6 >= 9)
      v12 = a3 + v9;
    else
      v12 = a3;
    if (a6 >= 9)
    {
      LODWORD(v13) = v10;
    }
    else
    {
      v11 = a4;
      LODWORD(v13) = a6;
    }
    v14 = v13 + a5;
    v15 = *(unsigned __int8 *)(result + 1);
    if ((_DWORD)v15 == 2 && (v16 = *(int **)(result + 16), v17 = *v16, *v16 == v16[1]))
    {
      v18 = *a2;
      v19 = a2[1];
      v20 = *(_BYTE *)(result + 2);
      v21 = 1 << v20 >> 1;
      if (v17 == 1)
      {
        v33 = (int)v13;
        do
        {
          result = *(unsigned __int16 *)(v12 + 2 * v33);
          *(_WORD *)(v11 + 2 * v33) = result
                                    + ((v21 + *(__int16 *)(v18 + 2 * v33) + *(__int16 *)(v19 + 2 * v33)) >> v20);
          ++v33;
        }
        while (v33 < v14);
      }
      else if (v17 == -1)
      {
        v22 = (int)v13;
        do
        {
          result = *(unsigned __int16 *)(v12 + 2 * v22);
          *(_WORD *)(v11 + 2 * v22) = result
                                    + ((v21 - (*(__int16 *)(v18 + 2 * v22) + *(__int16 *)(v19 + 2 * v22))) >> v20);
          ++v22;
        }
        while (v22 < v14);
      }
      else
      {
        v13 = (int)v13;
        do
        {
          result = *(unsigned __int16 *)(v12 + 2 * v13);
          *(_WORD *)(v11 + 2 * v13) = result
                                    + ((v21 + (*(__int16 *)(v19 + 2 * v13) + *(__int16 *)(v18 + 2 * v13)) * v17) >> v20);
          ++v13;
        }
        while (v13 < v14);
      }
    }
    else
    {
      v23 = *(_BYTE *)(result + 2);
      v24 = *(__int16 *)(result + 6);
      v25 = (int)v13;
      do
      {
        v26 = v24;
        if ((_DWORD)v15)
        {
          v27 = *(int **)(result + 16);
          v28 = v15;
          v29 = a2;
          v26 = v24;
          do
          {
            v31 = *v27++;
            v30 = v31;
            v32 = *v29++;
            v26 += v30 * *(__int16 *)(v32 + 2 * v25);
            --v28;
          }
          while (v28);
        }
        *(_WORD *)(v11 + 2 * v25) = *(_WORD *)(v12 + 2 * v25) + (v26 >> v23);
        ++v25;
      }
      while (v25 < v14);
    }
  }
  return result;
}

{
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  float *v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  int v22;
  int v23;
  char v24;
  int v25;
  uint64_t v26;
  int v27;
  int *v28;
  uint64_t v29;
  uint64_t *v30;
  int v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  uint64_t v39;

  if (a5 < 1)
    return result;
  if (a6 >= 8)
    v6 = 8;
  else
    v6 = a6;
  v7 = a6 - v6 + 3;
  v8 = v7 & 0xFFFFFFFC;
  v9 = 16 * (v7 >> 2) + 16;
  v10 = a3 + v9;
  v11 = a6 - v8 - 4;
  v12 = a4 + v9;
  if (a6 >= 5)
    v13 = v10;
  else
    v13 = a3;
  if (a6 >= 5)
  {
    LODWORD(v14) = v11;
  }
  else
  {
    v12 = a4;
    LODWORD(v14) = a6;
  }
  v15 = v14 + a5;
  v16 = *(unsigned __int8 *)(result + 1);
  if ((_DWORD)v16 == 2)
  {
    v17 = *(float **)(result + 8);
    v18 = *v17;
    if (*v17 == v17[1])
    {
      v19 = *a2;
      v20 = a2[1];
      if (*(_BYTE *)(result + 29))
      {
        v21 = *(_BYTE *)(result + 2);
        v22 = *(__int16 *)(result + 6);
        v23 = **(_DWORD **)(result + 16);
        v14 = (int)v14;
        if (v23 == 1)
        {
          do
          {
            result = *(unsigned int *)(v20 + 4 * v14);
            *(_DWORD *)(v12 + 4 * v14) = ((*(_DWORD *)(v19 + 4 * v14) + v22 + (int)result) >> v21)
                                       + *(_DWORD *)(v13 + 4 * v14);
            ++v14;
          }
          while (v14 < v15);
        }
        else if (v23 == -1)
        {
          do
          {
            result = *(unsigned int *)(v20 + 4 * v14);
            *(_DWORD *)(v12 + 4 * v14) = ((v22 - (*(_DWORD *)(v19 + 4 * v14) + (int)result)) >> v21)
                                       + *(_DWORD *)(v13 + 4 * v14);
            ++v14;
          }
          while (v14 < v15);
        }
        else
        {
          do
          {
            result = ((v22 + (*(_DWORD *)(v20 + 4 * v14) + *(_DWORD *)(v19 + 4 * v14)) * v23) >> v21);
            *(_DWORD *)(v12 + 4 * v14) = result + *(_DWORD *)(v13 + 4 * v14);
            ++v14;
          }
          while (v14 < v15);
        }
      }
      else
      {
        v39 = (int)v14;
        do
        {
          *(float *)(v12 + 4 * v39) = *(float *)(v13 + 4 * v39)
                                    + (float)(v18 * (float)(*(float *)(v19 + 4 * v39) + *(float *)(v20 + 4 * v39)));
          ++v39;
        }
        while (v39 < v15);
      }
      return result;
    }
    if (*(_BYTE *)(result + 29))
      goto LABEL_26;
LABEL_32:
    v34 = 0;
    v35 = v15;
    do
    {
      v36 = a2[v34];
      v37 = *(float *)(*(_QWORD *)(result + 8) + 4 * v34);
      v38 = (int)v14;
      do
      {
        *(float *)(v12 + 4 * v38) = *(float *)(v13 + 4 * v38) + (float)(v37 * *(float *)(v36 + 4 * v38));
        ++v38;
      }
      while (v38 < v35);
      ++v34;
      v13 = v12;
    }
    while (v34 < *(unsigned __int8 *)(result + 1));
    return result;
  }
  if (!*(_BYTE *)(result + 29))
  {
    if (!*(_BYTE *)(result + 1))
      return result;
    goto LABEL_32;
  }
LABEL_26:
  v24 = *(_BYTE *)(result + 2);
  v25 = *(__int16 *)(result + 6);
  v26 = (int)v14;
  do
  {
    v27 = v25;
    if ((_DWORD)v16)
    {
      v28 = *(int **)(result + 16);
      v29 = v16;
      v30 = a2;
      v27 = v25;
      do
      {
        v32 = *v28++;
        v31 = v32;
        v33 = *v30++;
        v27 += *(_DWORD *)(v33 + 4 * v26) * v31;
        --v29;
      }
      while (v29);
    }
    *(_DWORD *)(v12 + 4 * v26) = *(_DWORD *)(v13 + 4 * v26) + (v27 >> v24);
    ++v26;
  }
  while (v26 < v15);
  return result;
}

void kd_analysis::kd_analysis(kd_analysis *this)
{
  uint64_t v1;
  kd_analysis *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v1 = 0;
  *(_QWORD *)this = &off_1E1BABFC8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 18) = 0;
  v2 = (kd_analysis *)((char *)this + 336);
  do
  {
    v3 = v1;
    v4 = 2;
    do
    {
      v5 = (char *)this + v3;
      *((_DWORD *)v5 + 84) = 0;
      *((_WORD *)v5 + 171) = 0;
      *((_QWORD *)v5 + 43) = 0;
      v3 += 16;
      --v4;
    }
    while (v4);
    v2 = (kd_analysis *)((char *)v2 + 40);
    v1 += 40;
  }
  while (v2 != (kd_analysis *)((char *)this + 576));
  *((_QWORD *)this + 13) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_QWORD *)this + 25) = 0;
}

kd_synthesis **kdu_synthesis::kdu_synthesis(kd_synthesis **a1, uint64_t a2, kdu_sample_allocator *a3, uint64_t a4, uint64_t a5, uint64_t a6, float a7)
{
  kd_synthesis *v13;
  int32x4_t *v14;
  double v15;
  uint64_t v17;

  v17 = a2;
  *a1 = 0;
  v13 = (kd_synthesis *)operator new();
  kd_synthesis::kd_synthesis(v13);
  *a1 = v13;
  v14 = (int32x4_t *)kdu_resolution::access_node((kdu_resolution *)&v17);
  *(float *)&v15 = a7;
  kd_synthesis::init((uint64_t)v13, v14, a3, a4, 0, a5, a6, v15);
  return a1;
}

void sub_187F5D1B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C40833BFE5ALL);
  _Unwind_Resume(a1);
}

float *kd_synthesis::init(uint64_t a1, int32x4_t *a2, kdu_sample_allocator *a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, double a8)
{
  char reversible;
  char kernel_id;
  float *result;
  __int32 v14;
  __int32 v15;
  __int32 v16;
  __int32 v17;
  int v18;
  __int32 v19;
  __int32 v20;
  BOOL v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  int v31;
  int v32;
  int v33;
  char v34;
  _DWORD *v35;
  int v36;
  uint64_t v37;
  int v38;
  __int32 v39;
  __int32 v40;
  __int32 v41;
  int v42;
  __int32 v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  char v52;
  _DWORD *v53;
  int v54;
  __int32 v55;
  int v56;
  __int32 v57;
  __int32 v58;
  __int32 v59;
  __int32 v60;
  __int32 v61;
  __int32 v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  unsigned int v68;
  int v69;
  int v70;
  int v71;
  unsigned __int32 v72;
  __int32 v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t kernel_coefficients;
  int *v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  float *v90;
  _DWORD *v91;
  float v92;
  float v93;
  uint64_t v94;
  unsigned __int8 v95;
  unsigned __int8 *v96;
  float v97;
  uint64_t v98;
  float *v99;
  _DWORD *v100;
  float v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  float *v111;
  _DWORD *v112;
  float v113;
  float v114;
  uint64_t v115;
  unsigned __int8 v116;
  unsigned __int8 *v117;
  uint64_t v118;
  float *v119;
  uint64_t v120;
  float *v121;
  float v122;
  uint64_t v123;
  float *v124;
  _DWORD *v125;
  float v126;
  uint64_t v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  uint64_t v135;
  int v136;
  int v137;
  unsigned int v138;
  unsigned int v139;
  int v140;
  int v141;
  int v142;
  int v143;
  char v144;
  int v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  _QWORD *v151;
  int v152;
  int v153;
  uint64_t v154;
  int v155;
  int v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  int v162;
  int v163;
  uint64_t v164;
  uint64_t v165;
  _DWORD *v166;
  uint64_t bibo_gains;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  float v171;
  float v172;
  float v173;
  uint64_t v174;
  float v175;
  float *v176;
  float v177;
  float v178;
  float v179;
  float v181;
  float v182;
  float *v183;
  uint64_t v184;
  float v185;
  float v186;
  float v187;
  int v189;
  float32x4_t v190;
  float32x4_t v191;
  float *v192;
  uint64_t *v193;
  uint64_t j;
  uint64_t v195;
  kd_synthesis *v196;
  uint64_t v197;
  float *v198;
  uint64_t i;
  float *v200;
  _DWORD *exception;
  uint64_t kernel_info;
  int *v204;
  int *v205;
  kd_synthesis *v209;
  kd_synthesis *v210;
  int v211[2];
  int v212[2];
  float v213;
  float v214;
  float v215;
  float v216;
  int32x4_t v217;
  int32x4_t v218;
  uint64_t v219;
  int32x4_t *v220;
  float32x4_t v221;
  __int128 v222;
  __int128 v223;
  uint64_t v224;

  v224 = *MEMORY[0x1E0C80C00];
  v220 = a2;
  v219 = kdu_node::access_resolution((kdu_node *)&v220);
  reversible = kdu_resolution::get_reversible((kdu_resolution *)&v219);
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 40) = reversible;
  *(_BYTE *)(a1 + 206) = a4;
  *(_BYTE *)(a1 + 41) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  v204 = (int *)(a1 + 48);
  v205 = (int *)(a1 + 44);
  *(_WORD *)(a1 + 98) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 88) = 0;
  kernel_id = kdu_node::get_kernel_id((kdu_node *)&v220);
  *(_QWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  v218 = 0uLL;
  result = (float *)kdu_node::get_dims(&v220, &v218);
  v15 = v218.i32[0];
  v14 = v218.i32[1];
  v16 = v218.i32[2];
  v17 = v218.i32[0] + v218.i32[2] - 1;
  v18 = v218.i32[1] - a5;
  v19 = v218.i32[3] - 1;
  v21 = v218.i32[3] < 1;
  v20 = v218.i32[3] - 1 + v218.i32[1];
  *(_DWORD *)(a1 + 112) = v218.i32[0];
  *(_DWORD *)(a1 + 120) = v17;
  *(_DWORD *)(a1 + 184) = v14;
  *(_DWORD *)(a1 + 188) = v20;
  *(_DWORD *)(a1 + 200) = v18;
  *(_DWORD *)(a1 + 148) = v18;
  v21 = v21 || v16 < 1;
  v22 = v21;
  *(_BYTE *)(a1 + 209) = v22;
  *(_BYTE *)(a1 + 207) = v17 == v15;
  *(_BYTE *)(a1 + 208) = v19 == 0;
  if ((v22 & 1) != 0)
    return result;
  v222 = 0u;
  v223 = 0u;
  *(_QWORD *)&v222 = kdu_node::access_child((kdu_node *)&v220, 0);
  *((_QWORD *)&v222 + 1) = kdu_node::access_child((kdu_node *)&v220, 1u);
  *(_QWORD *)&v223 = kdu_node::access_child((kdu_node *)&v220, 2u);
  *((_QWORD *)&v223 + 1) = kdu_node::access_child((kdu_node *)&v220, 3u);
  if (!(_QWORD)v222)
    kd_synthesis::init();
  v217 = 0uLL;
  kdu_node::get_dims((int32x4_t **)&v222, &v217);
  v23 = *((_QWORD *)&v222 + 1);
  v24 = v223;
  *(_BYTE *)(a1 + 42) = (_QWORD)v223 != 0;
  v25 = v23 != 0;
  *(_BYTE *)(a1 + 43) = v25;
  v215 = 1.0;
  v216 = 1.0;
  v213 = 1.0;
  v214 = 1.0;
  *(_BYTE *)(a1 + 207) = 0;
  if (!v24)
  {
    v30 = a5;
    v31 = 0;
    v32 = 0;
    kernel_info = 0;
    *(_DWORD *)(a1 + 124) = *(_DWORD *)(a1 + 112);
    *(_DWORD *)(a1 + 140) = *(_DWORD *)(a1 + 120);
    goto LABEL_36;
  }
  *(_QWORD *)v211 = 0;
  *(_QWORD *)v212 = 0;
  kernel_info = kdu_node::get_kernel_info((kdu_node *)&v220, v205, &v216, &v215, (BOOL *)(a1 + 96), (BOOL *)(a1 + 98), &v212[1], v212, &v211[1], v211, 1);
  if (v212[0] <= v211[0])
    v26 = v211[0];
  else
    v26 = v212[0];
  if (v212[1] >= v211[1])
    v27 = v211[1];
  else
    v27 = v212[1];
  LODWORD(v28) = *(_DWORD *)(a1 + 44);
  if ((int)v28 > 4)
  {
    v29 = operator new[]();
    *(_QWORD *)(a1 + 248) = v29;
    LODWORD(v28) = *(_DWORD *)(a1 + 44);
  }
  else
  {
    v29 = a1 + 640;
  }
  *(_QWORD *)(a1 + 80) = v29;
  if ((int)v28 < 1)
  {
    v33 = 0;
    v32 = 0;
LABEL_28:
    v37 = a1 + 336;
    goto LABEL_29;
  }
  v33 = 0;
  v32 = 0;
  v34 = *(_BYTE *)(a1 + 40);
  v35 = (_DWORD *)(kernel_info + 8);
  v28 = v28;
  do
  {
    *(_WORD *)(v29 + 4) = *(v35 - 1);
    v36 = *(v35 - 2);
    *(_BYTE *)(v29 + 1) = v36;
    *(_BYTE *)(v29 + 2) = *v35;
    *(_WORD *)(v29 + 6) = v35[1];
    if (v33 <= v36)
      v33 = v36;
    *(_BYTE *)(v29 + 30) = kernel_id;
    *(_BYTE *)(v29 + 29) = v34;
    v32 += v36;
    v29 += 32;
    v35 += 4;
    --v28;
  }
  while (v28);
  if (v33 <= 4)
    goto LABEL_28;
  v37 = operator new[]();
  *(_QWORD *)(a1 + 232) = v37;
LABEL_29:
  *(_QWORD *)(a1 + 56) = v37 + 8 * v33;
  *(_QWORD *)(a1 + 64) = v37;
  v221 = 0uLL;
  kdu_node::get_dims((int32x4_t **)&v223, (int32x4_t *)&v221);
  v38 = v217.i32[2];
  v39 = 2 * v217.i32[0];
  v40 = 2 * (v217.i32[2] + v217.i32[0]) - 2;
  v41 = v221.i32[0];
  v42 = v221.i32[2];
  v43 = (2 * v221.i32[0]) | 1;
  *(_DWORD *)(a1 + 124) = 2 * v217.i32[0];
  *(_DWORD *)(a1 + 128) = v43;
  v44 = 2 * (v42 + v41) - 1;
  *(_DWORD *)(a1 + 140) = v40;
  *(_DWORD *)(a1 + 144) = v44;
  if (v42 <= 0)
  {
    *(_BYTE *)(a1 + 207) = 1;
    if (v39 != v40)
    {
      exception = __cxa_allocate_exception(4uLL);
      *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    v43 = v39 | 1;
    *(_DWORD *)(a1 + 128) = v39 | 1;
    v44 = v39 - 1;
    *(_DWORD *)(a1 + 144) = v39 - 1;
  }
  if (v38 <= 0)
  {
    *(_BYTE *)(a1 + 207) = 1;
    if (v43 != v44)
      kd_synthesis::init();
    *(_DWORD *)(a1 + 124) = v44 + 1;
    *(_DWORD *)(a1 + 140) = v44 - 1;
  }
  v30 = a5;
  v31 = v26 - v27;
  v25 = *(unsigned __int8 *)(a1 + 43);
LABEL_36:
  *(_BYTE *)(a1 + 208) = 0;
  if (v25)
  {
    *(_QWORD *)v211 = 0;
    *(_QWORD *)v212 = 0;
    v45 = kdu_node::get_kernel_info((kdu_node *)&v220, (int *)(a1 + 48), &v214, &v213, (BOOL *)(a1 + 97), (BOOL *)(a1 + 99), &v212[1], v212, &v211[1], v211, 0);
    if (v45 == kernel_info)
    {
      v47 = *(_QWORD *)(a1 + 80);
    }
    else
    {
      v46 = *v205;
      if ((int)v46 + *v204 > 4)
      {
        v47 = operator new[]();
        *(_QWORD *)(a1 + 256) = v47;
      }
      else
      {
        v47 = a1 + 32 * v46 + 640;
      }
    }
    *(_QWORD *)(a1 + 88) = v47;
    if (v47 != *(_QWORD *)(a1 + 80))
    {
      v51 = *v204;
      if ((int)v51 >= 1)
      {
        v52 = *(_BYTE *)(a1 + 40);
        v53 = (_DWORD *)(v45 + 8);
        do
        {
          *(_WORD *)(v47 + 4) = *(v53 - 1);
          v54 = *(v53 - 2);
          *(_BYTE *)(v47 + 1) = v54;
          *(_BYTE *)(v47 + 2) = *v53;
          *(_WORD *)(v47 + 6) = v53[1];
          *(_BYTE *)(v47 + 30) = kernel_id;
          *(_BYTE *)(v47 + 29) = v52;
          v32 += v54;
          v47 += 32;
          v53 += 4;
          --v51;
        }
        while (v51);
      }
    }
    v221 = 0uLL;
    kdu_node::get_dims((int32x4_t **)&v222 + 1, (int32x4_t *)&v221);
    v55 = v217.i32[1];
    v56 = v217.i32[3];
    v57 = 2 * v217.i32[1];
    v58 = 2 * (v217.i32[3] + v217.i32[1]) - 2;
    v59 = v221.i32[1];
    v60 = v221.i32[3];
    if (v221.i64[1] <= 0)
    {
      *(_BYTE *)(a1 + 208) = 1;
      v61 = v57;
      v62 = v57;
      if (v57 != v58)
        kd_synthesis::init();
    }
    else
    {
      v61 = 2 * v221.i32[1];
      v62 = 2 * (v221.i32[3] + v221.i32[1]);
    }
    v63 = v62 - 1;
    v64 = v61 | 1;
    if (v56 <= 0)
    {
      *(_BYTE *)(a1 + 208) = 1;
      if (v64 != v63)
        kd_synthesis::init();
      v57 = v61 + 2;
      v58 = v61;
    }
    if (v57 >= v64)
      v65 = v61 | 1;
    else
      v65 = v57;
    if (v58 > v63)
      v63 = v58;
    *(_DWORD *)(a1 + 152) = v65;
    *(_DWORD *)(a1 + 156) = v63;
    v66 = *(_DWORD *)(a1 + 148);
    if (v65 < (int)v66)
    {
      if ((_DWORD)a4)
        v67 = -8;
      else
        v67 = -4;
      do
        v66 += v67;
      while (v65 < (int)v66);
      *(_DWORD *)(a1 + 148) = v66;
    }
    v68 = ((v65 + 1) >> 1) - ((v66 + 1) >> 1);
    *(_BYTE *)(a1 + 168) = ((v65 + 1) >> 1) - ((v66 + 1) >> 1);
    v69 = (v65 >> 1) - (v66 >> 1);
    *(_BYTE *)(a1 + 169) = (v65 >> 1) - (v66 >> 1);
    v70 = (v63 >> 1) - ((v65 + 1) >> 1) + 1;
    v71 = ((v63 - 1) >> 1) - (v65 >> 1) + 1;
    *(_DWORD *)(a1 + 160) = v70;
    *(_DWORD *)(a1 + 164) = v71;
    v72 = v55 - ((v66 + 1) >> 1);
    *(_BYTE *)(a1 + 170) = v55 - ((v66 + 1) >> 1);
    v73 = v59 - (v66 >> 1);
    *(_BYTE *)(a1 + 171) = v73;
    *(_DWORD *)(a1 + 172) = v56;
    *(_DWORD *)(a1 + 176) = v60;
    v74 = (v55 - ((v66 + 1) >> 1)) - v68;
    if (v74 < 0
      || (v75 = v70 + v68 - (v56 + v72), v75 < 0)
      || v75 > 255
      || v73 - v69 < 0
      || (v76 = v71 + v69 - (v60 + v73), v76 < 0)
      || v76 >= 256)
    {
      kd_synthesis::init();
    }
    *(_BYTE *)(a1 + 180) = v74;
    *(_BYTE *)(a1 + 182) = v75;
    *(_BYTE *)(a1 + 181) = v73 - v69;
    *(_BYTE *)(a1 + 183) = v76;
    v77 = *(_DWORD *)(a1 + 184);
    v78 = *(_DWORD *)(a1 + 188);
    *(_BYTE *)(a1 + 205) = (v77 >> 1) - (v66 >> 1);
    *(_BYTE *)(a1 + 204) = ((v77 + 1) >> 1) - ((v66 + 1) >> 1);
    *(_DWORD *)(a1 + 192) = (v78 >> 1) - ((v77 + 1) >> 1) + 1;
    *(_DWORD *)(a1 + 196) = ((v78 - 1) >> 1) - (v77 >> 1) + 1;
  }
  else
  {
    v48 = *(_DWORD *)(a1 + 184);
    v49 = *(_DWORD *)(a1 + 188);
    *(_DWORD *)(a1 + 152) = v48;
    *(_DWORD *)(a1 + 156) = v49;
    *(_BYTE *)(a1 + 170) = v30;
    v50 = v49 - v48 + 1;
    *(_DWORD *)(a1 + 172) = v50;
    *(_BYTE *)(a1 + 171) = 0;
    *(_QWORD *)(a1 + 176) = 0;
    *(_WORD *)(a1 + 204) = (v48 - *(_BYTE *)(a1 + 148));
    *(_QWORD *)(a1 + 192) = v50;
  }
  if (v32 < 9)
  {
    v79 = a1 + 272;
    v80 = a1 + 304;
  }
  else
  {
    v79 = operator new[]();
    *(_QWORD *)(a1 + 216) = v79;
    v80 = operator new[]();
    *(_QWORD *)(a1 + 224) = v80;
  }
  if (*(_BYTE *)(a1 + 42))
  {
    kernel_coefficients = kdu_node::get_kernel_coefficients((kdu_node *)&v220, 1);
    v82 = (int *)(a1 + 44);
    v83 = *v205;
    if (*v205 >= 1)
    {
      v84 = 0;
      v85 = *(_QWORD *)(a1 + 80);
      v86 = *(unsigned __int8 *)(a1 + 40);
      do
      {
        v87 = v85 + 32 * v84;
        *(_BYTE *)v87 = v84;
        *(_QWORD *)(v87 + 8) = v79;
        *(_QWORD *)(v87 + 16) = v80;
        *(_BYTE *)(v87 + 28) = 0;
        v88 = *(unsigned __int8 *)(v87 + 1);
        if (v88)
        {
          v89 = v88;
          v90 = (float *)kernel_coefficients;
          v91 = (_DWORD *)v79;
          v92 = 0.4;
          do
          {
            v93 = *v90;
            *v91 = *(_DWORD *)v90;
            if (v93 <= v92)
            {
              if (v93 < (float)-v92)
                v92 = -v93;
            }
            else
            {
              v92 = v93;
            }
            ++v91;
            ++v90;
            --v89;
          }
          while (v89);
          if (v86)
          {
LABEL_91:
            v95 = *(_BYTE *)(v85 + 32 * v84 + 2);
            if ((_DWORD)v88)
              goto LABEL_95;
            goto LABEL_98;
          }
          v94 = v85 + 32 * v84;
          v95 = 16;
          *(_BYTE *)(v94 + 2) = 16;
          v96 = (unsigned __int8 *)(v94 + 2);
          if (v92 >= 0.499)
          {
            v95 = 16;
            do
            {
              --v95;
              v92 = v92 * 0.5;
            }
            while (v92 >= 0.499);
            *v96 = v95;
            if (v95 < 0x10u)
            {
              *(_WORD *)(v85 + 32 * v84 + 6) = 1 << (v95 - 1);
LABEL_95:
              v97 = (float)(1 << v95);
              v98 = v88;
              v99 = (float *)v79;
              v100 = (_DWORD *)v80;
              do
              {
                v101 = *v99++;
                *v100++ = vcvtmd_s64_f64((float)(v101 * v97) + 0.5);
                --v98;
              }
              while (v98);
              v83 = *v205;
              goto LABEL_98;
            }
          }
        }
        else
        {
          if (v86)
            goto LABEL_91;
          v95 = 16;
          *(_BYTE *)(v85 + 32 * v84 + 2) = 16;
        }
        *(_WORD *)(v85 + 32 * v84 + 6) = 0x7FFF;
        if ((_DWORD)v88)
          goto LABEL_95;
LABEL_98:
        v79 += 4 * v88;
        v80 += 4 * v88;
        kernel_coefficients += 4 * v88;
        v102 = v85 + 32 * v84;
        *(_BYTE *)(v102 + 3) = 0;
        *(_DWORD *)(v102 + 24) = 0;
        ++v84;
      }
      while (v84 < v83);
    }
  }
  else
  {
    v82 = (int *)(a1 + 44);
  }
  if (*(_BYTE *)(a1 + 43))
  {
    v103 = kdu_node::get_kernel_coefficients((kdu_node *)&v220, 0);
    if (*v204 >= 1)
    {
      v104 = 0;
      v105 = 0;
      v107 = *(_QWORD *)(a1 + 80);
      v106 = *(_QWORD *)(a1 + 88);
      v82 = (int *)(a1 + 44);
      while (1)
      {
        if (v106 == v107)
        {
          v118 = v106 + 32 * v104;
          v109 = *(unsigned __int8 *)(v118 + 1);
          if (*(_BYTE *)(v118 + 1))
          {
            v119 = *(float **)(v118 + 8);
            v120 = v109;
            v121 = (float *)v103;
            do
            {
              if (*v119 != *v121)
                kd_synthesis::init();
              ++v121;
              ++v119;
              --v120;
            }
            while (v120);
          }
          goto LABEL_131;
        }
        v108 = v106 + 32 * v104;
        *(_BYTE *)v108 = v104;
        *(_DWORD *)(v108 + 24) = 0;
        *(_QWORD *)(v108 + 8) = v79;
        *(_QWORD *)(v108 + 16) = v80;
        *(_BYTE *)(v108 + 28) = 0;
        v109 = *(unsigned __int8 *)(v108 + 1);
        if ((_DWORD)v109)
        {
          v110 = v109;
          v111 = (float *)v103;
          v112 = (_DWORD *)v79;
          v113 = 0.4;
          do
          {
            v114 = *v111;
            *v112 = *(_DWORD *)v111;
            if (v114 <= v113)
            {
              if (v114 < (float)-v113)
                v113 = -v114;
            }
            else
            {
              v113 = v114;
            }
            ++v112;
            ++v111;
            --v110;
          }
          while (v110);
          if (*(_BYTE *)(a1 + 40))
          {
LABEL_124:
            v116 = *(_BYTE *)(v106 + 32 * v104 + 2);
            if ((_DWORD)v109)
              goto LABEL_128;
            goto LABEL_130;
          }
          v115 = v106 + 32 * v104;
          v116 = 16;
          *(_BYTE *)(v115 + 2) = 16;
          v117 = (unsigned __int8 *)(v115 + 2);
          if (v113 >= 0.499)
          {
            v116 = 16;
            do
            {
              --v116;
              v113 = v113 * 0.5;
            }
            while (v113 >= 0.499);
            *v117 = v116;
            if (v116 < 0x10u)
            {
              *(_WORD *)(v106 + 32 * v104 + 6) = 1 << (v116 - 1);
LABEL_128:
              v122 = (float)(1 << v116);
              v123 = v109;
              v124 = (float *)v79;
              v125 = (_DWORD *)v80;
              do
              {
                v126 = *v124++;
                *v125++ = vcvtmd_s64_f64((float)(v126 * v122) + 0.5);
                --v123;
              }
              while (v123);
              goto LABEL_130;
            }
          }
        }
        else
        {
          if (*(_BYTE *)(a1 + 40))
            goto LABEL_124;
          v116 = 16;
          *(_BYTE *)(v106 + 32 * v104 + 2) = 16;
        }
        *(_WORD *)(v106 + 32 * v104 + 6) = 0x7FFF;
        if ((_DWORD)v109)
          goto LABEL_128;
LABEL_130:
        v79 += 4 * v109;
        v80 += 4 * v109;
LABEL_131:
        v127 = v106 + 32 * v104;
        v128 = *(__int16 *)(v127 + 4);
        if ((v104 & 1) != 0)
          v129 = -1;
        else
          v129 = 1;
        v130 = (*(unsigned __int8 *)(a1 + 152) << 31 >> 31) & v129;
        if ((v104 & 1) != 0)
          v131 = 1;
        else
          v131 = -1;
        v132 = v130 - v128;
        if ((*(_BYTE *)(a1 + 156) & 1) != 0)
          v131 = 0;
        v133 = v109 + v128 + v131 - 1;
        if (v132 > v133)
          v133 = v132;
        v134 = v133 & ~(v133 >> 31);
        if (v134 >= 0x100)
          kd_synthesis::init();
        if (v134 > v105)
          v105 = v134;
        v103 += 4 * v109;
        *(_BYTE *)(v127 + 3) = v134;
        if (++v104 >= *v204)
          goto LABEL_148;
      }
    }
    v105 = 0;
    v82 = (int *)(a1 + 44);
  }
  else
  {
    v105 = 0;
  }
LABEL_148:
  if (*v82 >= 1 && !*(_BYTE *)(a1 + 207))
  {
    if (*v82 > 4)
    {
      v135 = operator new[]();
      *(_QWORD *)(a1 + 264) = v135;
      v82 = (int *)(a1 + 44);
    }
    else
    {
      v135 = a1 + 768;
    }
    *(_QWORD *)(a1 + 104) = v135 + 48;
  }
  v136 = *(_DWORD *)(a1 + 172);
  v137 = v136 + *(unsigned __int8 *)(a1 + 170);
  if (*(_BYTE *)(a1 + 43))
  {
    v138 = *(unsigned __int8 *)(a1 + 168);
    v139 = *(unsigned __int8 *)(a1 + 169);
    if (v138 >= v139)
      v140 = *(unsigned __int8 *)(a1 + 169);
    else
      v140 = *(unsigned __int8 *)(a1 + 168);
    v141 = (v105 - v140) & ~((v105 - v140) >> 31);
    v142 = *(_DWORD *)(a1 + 160) + v138;
    v143 = *(_DWORD *)(a1 + 164) + v139;
    if (v142 <= v143)
      LOBYTE(v142) = v143;
    v144 = v142 + v105;
  }
  else
  {
    LOBYTE(v141) = 0;
    v144 = v136 + *(_BYTE *)(a1 + 170);
  }
  v145 = *(unsigned __int8 *)(a1 + 171);
  v146 = *(_DWORD *)(a1 + 176);
  if (*v82 < 1 || *(_BYTE *)(a1 + 207))
  {
    *(_QWORD *)(a1 + 72) = 0;
    LODWORD(v147) = 1;
LABEL_165:
    v148 = 0;
    v149 = v146 + v145;
    v147 = v147;
    do
    {
      v150 = *(_QWORD *)(a1 + 240);
      v151 = (_QWORD *)(v150 + v148 + 32);
      if (!v150)
      {
        v151 = (_QWORD *)(a1 + 432 + v148);
        v150 = a1 + 400;
      }
      *v151 = *(_QWORD *)(a1 + 72);
      *(_QWORD *)(a1 + 72) = v150 + v148;
      result = (float *)kd_vlift_line::pre_create((kd_vlift_line *)(v150 + v148), a3, v137, v149, *(_BYTE *)(a1 + 40), a4, v141, v144, *(_BYTE *)(a1 + 43));
      v148 += 40;
      --v147;
    }
    while (v147);
    goto LABEL_169;
  }
  result = (float *)kd_synthesis::simulate_vertical_lifting((kd_synthesis *)a1, v31);
  LODWORD(v147) = (_DWORD)result;
  if (result >= 7)
  {
    result = (float *)operator new[]();
    v198 = result;
    do
    {
      for (i = 0; i != 8; i += 4)
      {
        v200 = &v198[i];
        *v200 = 0.0;
        *((_WORD *)v200 + 3) = 0;
        *((_QWORD *)v200 + 1) = 0;
      }
      v198 += 10;
    }
    while (v198 != &result[10 * v147]);
    *(_QWORD *)(a1 + 240) = result;
  }
  *(_QWORD *)(a1 + 72) = 0;
  if ((_DWORD)v147)
    goto LABEL_165;
LABEL_169:
  *(_DWORD *)(a1 + 116) = *(_DWORD *)(a1 + 112);
  v152 = *(_DWORD *)(a1 + 124);
  v153 = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 132) = v152;
  *(_DWORD *)(a1 + 136) = v153;
  LODWORD(v154) = *(_DWORD *)(a1 + 44);
  if (!*(_QWORD *)(a1 + 104))
  {
LABEL_187:
    if ((int)v154 >= 1)
    {
      v165 = 0;
      v166 = (_DWORD *)(*(_QWORD *)(a1 + 80) + 24);
      do
      {
        *v166 = *(_DWORD *)(a1 + 4 * ((v165 & 1) == 0) + 124);
        v166 += 8;
        ++v165;
      }
      while (v154 != v165);
    }
    goto LABEL_190;
  }
  if (v152 >= v153)
    v155 = v153;
  else
    v155 = v152;
  if (*(_DWORD *)(a1 + 140) <= *(_DWORD *)(a1 + 144))
    v156 = *(_DWORD *)(a1 + 144);
  else
    v156 = *(_DWORD *)(a1 + 140);
  if ((v154 & 0x80000000) == 0)
  {
    v157 = -1;
    v158 = -48;
    do
    {
      v159 = a1 + 4 * (v157 & 1);
      if (*(_DWORD *)(v159 + 124) <= v155 + 1)
        v160 = v155;
      else
        v160 = *(_DWORD *)(v159 + 124);
      v161 = *(_DWORD *)(v159 + 140);
      if (v161 >= v156 - 1)
        v162 = v156;
      else
        v162 = v161;
      v163 = v162;
      if (v157 >= 1)
      {
        v164 = *(_QWORD *)(a1 + 80) + 32 * v157;
        v163 = v161 + 2 * (*(__int16 *)(v164 + 4) + *(unsigned __int8 *)(v164 + 1)) - 2;
      }
      result = (float *)kd_vlift_queue::init(*(_QWORD *)(a1 + 104) + v158, v160, v162, v157++, *(_BYTE *)(a1 + 98), v163);
      v154 = *(int *)(a1 + 44);
      v158 += 48;
    }
    while (v157 < v154);
    goto LABEL_187;
  }
LABEL_190:
  v221 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
  *(_DWORD *)(a1 + 100) = 0;
  if (!*(_BYTE *)(a1 + 40))
  {
    v212[1] = 0;
    bibo_gains = kdu_node::get_bibo_gains((kdu_node *)&v220, &v212[1], 1);
    if (v212[1] != *v205)
      kd_synthesis::init();
    v168 = bibo_gains;
    result = (float *)kdu_node::get_bibo_gains((kdu_node *)&v220, &v212[1], 0);
    v169 = v212[1];
    if (v212[1] != *v204)
      kd_synthesis::init();
    v170 = *v205;
    v171 = *(float *)&a8;
    v172 = *(float *)&a8;
    v173 = *(float *)&a8;
    if ((int)v170 >= 1)
    {
      v171 = *(float *)&a8;
      v172 = *(float *)&a8;
      v173 = *(float *)&a8;
      if (!*(_BYTE *)(a1 + 207))
      {
        v174 = 0;
        v172 = *(float *)&a8 / v216;
        v221.f32[0] = *(float *)&a8 / v216;
        v221.f32[1] = *(float *)&a8 / v216;
        v171 = *(float *)&a8 / v215;
        v221.f32[2] = *(float *)&a8 / v215;
        v221.f32[3] = *(float *)&a8 / v215;
        v175 = *result * *(float *)&a8;
        v176 = (float *)(v168 + 4);
        v177 = v175;
        v173 = *(float *)&a8;
        do
        {
          v178 = v177;
          v177 = v175 * *v176;
          if (v177 > v173)
            v173 = v175 * *v176;
          if ((_DWORD)a4)
          {
            v179 = v178 + v178;
            if (*(_BYTE *)(*(_QWORD *)(a1 + 80) + v174 + 28) && v179 > v173)
              v173 = v179;
          }
          v174 += 32;
          ++v176;
        }
        while (32 * v170 != v174);
      }
    }
    if (v212[1] >= 1 && !*(_BYTE *)(a1 + 208))
    {
      v221.f32[0] = v172 / v214;
      v221.f32[1] = v172 / v213;
      v221.f32[2] = v171 / v214;
      v221.f32[3] = v171 / v213;
      v181 = *(float *)(v168 + 4 * (int)v170);
      if ((int)v170 >= 1 && *(float *)(v168 + 4 * (v170 - 1)) > v181)
        v181 = *(float *)(v168 + 4 * (v170 - 1));
      v182 = v181 * *(float *)&a8;
      v183 = result + 1;
      v184 = 28;
      v185 = v182;
      do
      {
        v186 = v185;
        v185 = v182 * *v183;
        if (v185 > v173)
          v173 = v182 * *v183;
        if ((_DWORD)a4)
        {
          v187 = v186 + v186;
          if (*(_BYTE *)(*(_QWORD *)(a1 + 88) + v184) && v187 > v173)
            v173 = v187;
        }
        v184 += 32;
        ++v183;
        --v169;
      }
      while (v169);
    }
    if (v173 > 7.6)
    {
      v189 = *(_DWORD *)(a1 + 100);
      v190 = v221;
      v191.i64[0] = 0x3F0000003F000000;
      v191.i64[1] = 0x3F0000003F000000;
      do
      {
        v190 = vmulq_f32(v190, v191);
        ++v189;
        v173 = v173 * 0.5;
      }
      while (v173 > 7.6);
      v221 = v190;
      *(_DWORD *)(a1 + 100) = v189;
    }
  }
  v192 = (float *)&v221;
  v193 = (uint64_t *)&v222;
  for (j = 1; j != 5; ++j)
  {
    if (*v193)
    {
      v195 = *(unsigned __int8 *)(a1 + (((_BYTE)j - 1) & 1) + 170);
      if (kdu_node::access_child((kdu_node *)v193, 0))
      {
        result = (float *)kdu_synthesis::kdu_synthesis(&v209, *v193, (uint64_t)a3, a4, v195, a6, a7, *v192);
        v196 = v209;
      }
      else
      {
        v197 = kdu_node::access_subband((kdu_node *)v193);
        result = (float *)kdu_decoder::kdu_decoder(&v210, v197, a3, a4, v195, a6, a7, *v192);
        v196 = v210;
      }
      *(_QWORD *)(a1 + 8 * j) = v196;
    }
    ++v192;
    ++v193;
  }
  return result;
}

kd_synthesis **kdu_synthesis::kdu_synthesis(kd_synthesis **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, float a8)
{
  kd_synthesis *v16;

  *a1 = 0;
  v16 = (kd_synthesis *)operator new();
  kd_synthesis::kd_synthesis(v16);
  *a1 = v16;
  kd_synthesis::init(v16, a2, a3, a4, a5, a6, a7, a8);
  return a1;
}

void sub_187F5E378(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C40833BFE5ALL);
  _Unwind_Resume(a1);
}

uint64_t kd_synthesis::simulate_vertical_lifting(kd_synthesis *this, int a2)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  unsigned int i;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BOOL8 v30;
  uint64_t v31;
  char *v32;
  int v33;
  _DWORD *v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  int v47;
  char *v48;
  _DWORD *v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v3 = *((_DWORD *)this + 30);
  v4 = *((_DWORD *)this + 35);
  v5 = *((_DWORD *)this + 36);
  v54 = 0;
  v55 = v4;
  v56 = v5;
  v6 = *((_DWORD *)this + 28);
  v7 = v3 - (v6 + a2) - 2;
  if (v7 >= 1)
  {
    v8 = v7 & 0xFFFFFFFE;
    v3 -= v8;
    v4 -= v8;
    v5 -= v8;
    v55 = v4;
    v56 = v5;
  }
  *((_DWORD *)this + 29) = v6;
  v9 = *((_DWORD *)this + 31);
  v10 = *((_DWORD *)this + 32);
  *((_DWORD *)this + 33) = v9;
  *((_DWORD *)this + 34) = v10;
  if (v9 >= v10)
    v11 = v10;
  else
    v11 = v9;
  if (v4 <= v5)
    v12 = v5;
  else
    v12 = v4;
  if ((*((_DWORD *)this + 11) & 0x80000000) == 0)
  {
    v13 = -1;
    v14 = -48;
    do
    {
      if (*((_DWORD *)this + (v13 & 1) + 31) <= v11 + 1)
        v15 = v11;
      else
        v15 = *((_DWORD *)this + (v13 & 1) + 31);
      v16 = *(_DWORD *)((unint64_t)&v55 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v13 & 1)));
      if (v16 >= v12 - 1)
        v17 = v12;
      else
        v17 = *(_DWORD *)((unint64_t)&v55 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v13 & 1)));
      v18 = v17;
      if (v13 >= 1)
      {
        v19 = *((_QWORD *)this + 10) + 32 * v13;
        v18 = v16 + 2 * (*(__int16 *)(v19 + 4) + *(unsigned __int8 *)(v19 + 1)) - 2;
      }
      kd_vlift_queue::init(*((_QWORD *)this + 13) + v14, v15, v17, v13++, *((_BYTE *)this + 98), v18);
      v14 += 48;
    }
    while (v13 < *((int *)this + 11));
    v20 = *((unsigned int *)this + 11);
    if ((int)v20 >= 1)
    {
      v21 = 0;
      v22 = (_DWORD *)(*((_QWORD *)this + 10) + 24);
      do
      {
        *v22 = *((_DWORD *)this + ((v21 & 1) == 0) + 31);
        v22 += 8;
        ++v21;
      }
      while (v20 != v21);
    }
  }
  if (*((_DWORD *)this + 29) <= v3)
  {
    v53 = v3;
    v23 = 0;
    for (i = -1; ; i = v26)
    {
      while (2)
      {
        while ((i & 0x80000000) != 0)
        {
LABEL_51:
          i = !(*((_DWORD *)this + 29) & 1);
          if (kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((_QWORD *)this + 13) + 48 * -(*((_DWORD *)this + 29) & 1)), *((_DWORD *)this + 29), &v54))
          {
            v52 = *((_DWORD *)this + 29);
            *((_DWORD *)this + 29) = v52 + 1;
            i = -1;
            if (v52 >= v53)
              return v23;
          }
        }
        v26 = i + 1;
        v27 = 48 * i - 48;
        v28 = 32 * i;
        while (1)
        {
          v29 = v26 - 1;
          v30 = (((_DWORD)v26 - 1) & 1) == 0;
          v31 = *((unsigned int *)this + 11);
          if (v26 - 1 == v31)
          {
            v32 = (char *)this + 4 * ((((_DWORD)v26 - 1) & 1) == 0);
            v35 = *((_DWORD *)v32 + 33);
            v34 = v32 + 132;
            v33 = v35;
            if (v35 <= *(_DWORD *)((unint64_t)&v55 & 0xFFFFFFFFFFFFFFFBLL | (4 * ((((_DWORD)v26 - 1) & 1) == 0))))
            {
              v36 = v54++;
              if (v36 >= (int)v23)
                v23 = (v36 + 1);
              else
                v23 = v23;
              kd_vlift_queue::simulate_push_line(*((_QWORD *)this + 13) + v27, v33, &v54);
              *v34 += 2;
            }
            goto LABEL_50;
          }
          v37 = *((_QWORD *)this + 10);
          v38 = v37 + v28;
          v39 = *(_DWORD *)(v37 + v28 + 24);
          if (v39 <= *(_DWORD *)((unint64_t)&v55 | (4 * v30)))
            break;
LABEL_50:
          v27 -= 48;
          v28 -= 32;
          --v26;
          if (v29 <= 0)
            goto LABEL_51;
        }
        v40 = (int)v31;
        v41 = *(__int16 *)(v38 + 4);
        v42 = v40 - 1;
        v43 = *((_QWORD *)this + 13);
        if (v29 < v42)
        {
          v44 = v43 + 48 * v26;
          *(_DWORD *)(v44 + 36) = v39;
          if (*(_DWORD *)(v44 + 24) > v39 || *(_DWORD *)(v43 + 48 * v26 + 28) < v39)
          {
            i = v26 + 1;
            continue;
          }
        }
        break;
      }
      if ((kd_vlift_queue::simulate_access_source((kd_vlift_queue *)(v43 + v27 + 48), (v39 ^ 1u) + 2 * v41, *(unsigned __int8 *)(v37 + v28 + 1), &v54) & 1) != 0)
      {
        if (v29 == *((_DWORD *)this + 11) - 1)
        {
          v45 = v54;
          v46 = ++v54;
          v47 = *(_DWORD *)(v38 + 24);
          v48 = (char *)this + 4 * v30;
          v50 = *((_DWORD *)v48 + 33);
          v49 = v48 + 132;
          if (v47 != v50)
            kd_synthesis::simulate_vertical_lifting();
          if (v45 >= (int)v23)
            v23 = v46;
          else
            v23 = v23;
          *v49 = v47 + 2;
        }
        else
        {
          kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((_QWORD *)this + 13) + 48 * v26), *(_DWORD *)(v38 + 24), &v54);
          v51 = v54++;
          if (v51 >= (int)v23)
            v23 = (v51 + 1);
          else
            v23 = v23;
        }
        kd_vlift_queue::simulate_push_line(*((_QWORD *)this + 13) + v27, *(_DWORD *)(v38 + 24), &v54);
        *(_DWORD *)(v38 + 24) += 2;
        goto LABEL_50;
      }
    }
  }
  return 0;
}

void kd_synthesis::~kd_synthesis(kd_synthesis *this)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)this = &off_1E1BAC500;
  for (i = 8; i != 40; i += 8)
  {
    v3 = *(_QWORD *)((char *)this + i);
    if (v3)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
      *(_QWORD *)((char *)this + i) = 0;
    }
  }
  v4 = *((_QWORD *)this + 27);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1000C8052888210);
  v5 = *((_QWORD *)this + 28);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C8052888210);
  v6 = *((_QWORD *)this + 29);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x80C80B8603338);
  v7 = *((_QWORD *)this + 30);
  if (v7)
    MEMORY[0x18D761C18](v7, 0x1020C803C8EFFD9);
  v8 = *((_QWORD *)this + 31);
  if (v8)
    MEMORY[0x18D761C18](v8, 0x1090C805C18EE7CLL);
  v9 = *((_QWORD *)this + 32);
  if (v9)
    MEMORY[0x18D761C18](v9, 0x1090C805C18EE7CLL);
  v10 = *((_QWORD *)this + 33);
  if (v10)
    MEMORY[0x18D761C18](v10, 0x1020C806F595497);
  *(_QWORD *)this = off_1E1BB1478;
}

{
  kd_synthesis::~kd_synthesis(this);
  JUMPOUT(0x18D761C30);
}

uint64_t kd_synthesis::start(uint64_t a1, kdu_thread_entity *this)
{
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  if (!*(_BYTE *)(a1 + 41))
  {
    if (this)
      kdu_thread_entity::acquire_lock(this, 3, 1);
    for (i = *(_QWORD *)(a1 + 72); i; i = *(_QWORD *)(i + 32))
    {
      kdu_line_buf::create(i);
      kdu_line_buf::create(i + 16);
    }
    *(_BYTE *)(a1 + 41) = 1;
    if (this)
      kdu_thread_entity::release_lock(this, 3);
  }
  v5 = 0;
  v6 = a1 + 8;
  do
  {
    result = *(_QWORD *)(v6 + v5);
    if (result)
      result = (*(uint64_t (**)(uint64_t, kdu_thread_entity *))(*(_QWORD *)result + 16))(result, this);
    v5 += 8;
  }
  while (v5 != 32);
  return result;
}

uint64_t kd_synthesis::pull(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  __int16 *v14;
  uint64_t *v15;
  unsigned int v16;
  uint64_t v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _BYTE *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  char v42;
  int v43;
  uint64_t *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v63;
  char v64;
  char v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int *v69;
  int v70;
  unsigned int v71;
  int v72;
  int v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned __int16 *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int16 *v83;
  uint64_t v84;
  uint64_t v85;
  float *v86;
  uint64_t v87;
  uint64_t v88;
  unsigned __int16 *v89;
  int v90;
  int v91;
  __int16 v92;
  __int16 v93;
  float *v94;
  int v95;
  float v96;
  float *v97;
  int v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  _DWORD *exception;
  int v105;
  uint64_t v106;

  if (*(_BYTE *)(result + 209))
    return result;
  v5 = result;
  if (!*(_BYTE *)(result + 41))
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 16))(result, a3);
  if (*(_DWORD *)(v5 + 116) > *(_DWORD *)(v5 + 120))
    kd_synthesis::pull();
  v106 = a2;
  if (*(_BYTE *)(v5 + 42))
    v6 = *(_DWORD *)(v5 + 116) & 1;
  else
    v6 = 0;
  if (!*(_DWORD *)(v5 + 44) || *(_BYTE *)(v5 + 207))
  {
    v7 = *(_QWORD *)(v5 + 72);
    result = kd_synthesis::horizontal_synthesis(v5, v7, v6, a3);
    if (*(_BYTE *)(v5 + 207) && v6 && *(_BYTE *)(v5 + 40))
    {
      if (*(_BYTE *)(v5 + 206))
      {
        v8 = 0;
        v9 = 1;
        do
        {
          v10 = v9;
          v11 = v7 + 16 * v8;
          if ((*(_BYTE *)(v11 + 6) & 2) != 0)
            v12 = *(_QWORD *)(v11 + 8);
          else
            v12 = 0;
          v13 = *(_DWORD *)(v5 + 4 * v8 + 192);
          if (v13)
          {
            v14 = (__int16 *)(v12 + 2 * *(unsigned __int8 *)(v5 + v8 + 204));
            do
            {
              *v14 = *v14 >> 1;
              ++v14;
              --v13;
            }
            while (v13);
          }
          v9 = 0;
          v8 = 1;
        }
        while ((v10 & 1) != 0);
      }
      else
      {
        v63 = 0;
        v64 = 1;
        do
        {
          v65 = v64;
          v66 = v7 + 16 * v63;
          if ((*(_BYTE *)(v66 + 6) & 2) != 0)
            v67 = 0;
          else
            v67 = *(_QWORD *)(v66 + 8);
          v68 = *(_DWORD *)(v5 + 4 * v63 + 192);
          if (v68)
          {
            v69 = (int *)(v67 + 4 * *(unsigned __int8 *)(v5 + v63 + 204));
            do
            {
              *v69++ >>= 1;
              --v68;
            }
            while (v68);
          }
          v64 = 0;
          v63 = 1;
        }
        while ((v65 & 1) != 0);
      }
    }
    goto LABEL_89;
  }
  v15 = (uint64_t *)(v5 + 72);
  v16 = -1;
  do
  {
    if ((v16 & 0x80000000) != 0)
    {
LABEL_76:
      v16 = !(*(_DWORD *)(v5 + 116) & 1);
      result = kd_vlift_queue::access_update(*(_QWORD *)(v5 + 104) + 48 * -(*(_DWORD *)(v5 + 116) & 1), *(_DWORD *)(v5 + 116), (_QWORD *)(v5 + 72));
      v7 = result;
      continue;
    }
    v17 = v16;
    while (1)
    {
      v18 = (v17 & 1) == 0;
      v19 = *(unsigned int *)(v5 + 44);
      v20 = v5 + 4 * v18;
      if (v17 == v19)
      {
        v22 = *(_DWORD *)(v20 + 132);
        v21 = (int *)(v20 + 132);
        if (v22 <= v21[2])
        {
          v23 = *v15;
          if (!*v15)
          {
            exception = __cxa_allocate_exception(4uLL);
            v105 = -1;
LABEL_150:
            *exception = v105;
            __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
          }
          *(_QWORD *)(v5 + 72) = *(_QWORD *)(v23 + 32);
          *(_QWORD *)(v23 + 32) = 0;
          kd_synthesis::horizontal_synthesis(v5, v23, (v17 & 1) == 0, a3);
          result = kd_vlift_queue::push_line(*(_QWORD *)(v5 + 104) + 48 * v17 - 48, *v21, v23, (_QWORD *)(v5 + 72));
          *v21 += 2;
        }
        goto LABEL_74;
      }
      v24 = *(_QWORD *)(v5 + 80);
      v25 = v24 + 32 * v17;
      v27 = (int *)(v25 + 24);
      v26 = *(_DWORD *)(v25 + 24);
      if (v26 > *(_DWORD *)(v20 + 140))
        goto LABEL_74;
      v28 = *(__int16 *)(v25 + 4);
      v29 = (int)v19 - 1;
      v30 = *(_QWORD *)(v5 + 104);
      if (v17 < v29)
      {
        v31 = v30 + 48 * (v17 + 1);
        *(_DWORD *)(v31 + 36) = v26;
        if (*(_DWORD *)(v31 + 24) > v26 || *(_DWORD *)(v30 + 48 * (v17 + 1) + 28) < v26)
        {
          v7 = 0;
          v16 = v17 + 2;
          goto LABEL_77;
        }
      }
      v32 = v24 + 32 * v17;
      v34 = *(unsigned __int8 *)(v32 + 1);
      v33 = (_BYTE *)(v32 + 1);
      result = kd_vlift_queue::access_source((int *)(v30 + 48 * v17), (v26 ^ 1u) + 2 * v28, v34, *(_QWORD *)(v5 + 56), (_QWORD *)(v5 + 72));
      if ((result & 1) == 0)
        break;
      if (v17 == *(_DWORD *)(v5 + 44) - 1)
      {
        v35 = *v15;
        if (!*v15)
          goto LABEL_148;
        v36 = v5 + 4 * v18;
        v38 = *(_DWORD *)(v36 + 132);
        v37 = (_DWORD *)(v36 + 132);
        if (*v27 != v38)
          kd_synthesis::pull();
        kd_synthesis::horizontal_synthesis(v5, *v15, v18, a3);
        *v37 += 2;
      }
      else
      {
        v35 = kd_vlift_queue::access_update(*(_QWORD *)(v5 + 104) + 48 * (v17 + 1), *v27, (_QWORD *)(v5 + 72));
      }
      v39 = *v15;
      if (!*v15)
      {
LABEL_148:
        exception = __cxa_allocate_exception(4uLL);
        v105 = -50;
        goto LABEL_150;
      }
      *(_QWORD *)(v5 + 72) = *(_QWORD *)(v39 + 32);
      *(_QWORD *)(v39 + 32) = 0;
      result = kd_vlift_queue::push_line(*(_QWORD *)(v5 + 104) + 48 * v17 - 48, *v27, v39, (_QWORD *)(v5 + 72));
      if (*v33)
      {
        v40 = 0;
        v41 = 1;
        do
        {
          v42 = v41;
          v43 = *(_DWORD *)(v5 + 4 * v40 + 192);
          if (v43)
          {
            v44 = *(uint64_t **)(v5 + 64);
            v45 = *v33;
            if (*(_BYTE *)(v5 + 206))
            {
              if (*v33)
              {
                v46 = 0;
                v47 = 8 * v45;
                do
                {
                  v48 = *(_QWORD *)(*(_QWORD *)(v5 + 56) + v46) + 16 * v40;
                  if ((*(_BYTE *)(v48 + 6) & 2) != 0)
                    v49 = *(_QWORD *)(v48 + 8);
                  else
                    v49 = 0;
                  v44[v46 / 8] = v49;
                  v46 += 8;
                }
                while (v47 != v46);
              }
              v50 = v35 + 16 * v40;
              if ((*(_BYTE *)(v50 + 6) & 2) != 0)
                v51 = *(_QWORD *)(v50 + 8);
              else
                v51 = 0;
              v58 = v39 + 16 * v40;
              if ((*(_BYTE *)(v58 + 6) & 2) != 0)
                v59 = *(_QWORD *)(v58 + 8);
              else
                v59 = 0;
              result = perform_synthesis_lifting_step(v25, v44, v51, v59, v43, *(unsigned __int8 *)(v5 + v40 + 204));
            }
            else
            {
              if (*v33)
              {
                v52 = 0;
                v53 = 8 * v45;
                do
                {
                  v54 = *(_QWORD *)(*(_QWORD *)(v5 + 56) + v52) + 16 * v40;
                  if ((*(_BYTE *)(v54 + 6) & 2) != 0)
                    v55 = 0;
                  else
                    v55 = *(_QWORD *)(v54 + 8);
                  v44[v52 / 8] = v55;
                  v52 += 8;
                }
                while (v53 != v52);
              }
              v56 = v35 + 16 * v40;
              if ((*(_BYTE *)(v56 + 6) & 2) != 0)
                v57 = 0;
              else
                v57 = *(_QWORD *)(v56 + 8);
              v60 = v39 + 16 * v40;
              if ((*(_BYTE *)(v60 + 6) & 2) != 0)
                v61 = 0;
              else
                v61 = *(_QWORD *)(v60 + 8);
              result = perform_synthesis_lifting_step(v25, v44, v57, v61, v43, *(unsigned __int8 *)(v5 + v40 + 204));
            }
          }
          v41 = 0;
          v40 = 1;
        }
        while ((v42 & 1) != 0);
      }
      *v27 += 2;
LABEL_74:
      if (v17-- <= 0)
        goto LABEL_76;
    }
    v7 = 0;
    v16 = v17 + 1;
LABEL_77:
    ;
  }
  while (!v7);
LABEL_89:
  ++*(_DWORD *)(v5 + 116);
  v70 = *(_DWORD *)(v5 + 200);
  v71 = *(_DWORD *)(v5 + 188) - v70;
  v72 = (int)(v71 + 2) >> 1;
  v73 = v70 - *(_DWORD *)(v5 + 148);
  if (*(_BYTE *)(v5 + 43))
  {
    v74 = v70 & 1;
    v75 = v73 >> 1;
    v76 = *(_QWORD *)(v106 + 8);
    if (*(_BYTE *)(v5 + 206))
    {
      v77 = 0;
      if ((*(_BYTE *)(v106 + 6) & 2) == 0)
        v76 = 0;
      if ((*(_BYTE *)(v7 + 16 * v74 + 6) & 2) != 0)
        v77 = *(_QWORD *)(v7 + 16 * v74 + 8);
      v78 = v75;
      v79 = (unsigned __int16 *)(v77 + 2 * v75);
      v80 = v74 ^ 1;
      if ((*(_BYTE *)(v7 + 16 * v80 + 6) & 2) != 0)
        v81 = *(_QWORD *)(v7 + 16 * v80 + 8);
      else
        v81 = 0;
      v89 = (unsigned __int16 *)(v81 + 2 * v78);
      if (*(_DWORD *)(v5 + 100))
      {
        if (v71 <= 0xFFFFFFFD)
        {
          do
          {
            v90 = *v79++;
            *(_WORD *)v76 = v90 << *(_DWORD *)(v5 + 100);
            v91 = *v89++;
            *(_WORD *)(v76 + 2) = v91 << *(_DWORD *)(v5 + 100);
            v76 += 4;
            --v72;
          }
          while (v72);
        }
      }
      else if (v71 <= 0xFFFFFFFD)
      {
        do
        {
          v92 = *v79++;
          *(_WORD *)v76 = v92;
          v93 = *v89++;
          *(_WORD *)(v76 + 2) = v93;
          v76 += 4;
          --v72;
        }
        while (v72);
      }
    }
    else
    {
      v84 = 0;
      if ((*(_BYTE *)(v106 + 6) & 2) != 0)
        v76 = 0;
      if ((*(_BYTE *)(v7 + 16 * v74 + 6) & 2) == 0)
        v84 = *(_QWORD *)(v7 + 16 * v74 + 8);
      v85 = v75;
      v86 = (float *)(v84 + 4 * v75);
      v87 = v74 ^ 1;
      if ((*(_BYTE *)(v7 + 16 * v87 + 6) & 2) != 0)
        v88 = 0;
      else
        v88 = *(_QWORD *)(v7 + 16 * v87 + 8);
      v97 = (float *)(v88 + 4 * v85);
      v98 = *(_DWORD *)(v5 + 100);
      if (v98)
      {
        if (v71 <= 0xFFFFFFFD)
        {
          v99 = (float)(1 << v98);
          do
          {
            v100 = *v86++;
            *(float *)v76 = v100 * v99;
            v101 = *v97++;
            *(float *)(v76 + 4) = v101 * v99;
            v76 += 8;
            --v72;
          }
          while (v72);
        }
      }
      else if (v71 <= 0xFFFFFFFD)
      {
        do
        {
          v102 = *v86++;
          *(float *)v76 = v102;
          v103 = *v97++;
          *(float *)(v76 + 4) = v103;
          v76 += 8;
          --v72;
        }
        while (v72);
      }
    }
  }
  else
  {
    if (v73 >= 2)
      kd_synthesis::pull();
    v82 = *(_QWORD *)(v106 + 8);
    if (*(_BYTE *)(v5 + 206))
    {
      v83 = 0;
      if ((*(_BYTE *)(v106 + 6) & 2) == 0)
        v82 = 0;
      if ((*(_BYTE *)(v7 + 6) & 2) != 0)
        v83 = *(unsigned __int16 **)(v7 + 8);
      if (*(_DWORD *)(v5 + 100))
      {
        if (v71 <= 0xFFFFFFFD)
        {
          do
          {
            *(_WORD *)v82 = *v83 << *(_DWORD *)(v5 + 100);
            *(_WORD *)(v82 + 2) = v83[1] << *(_DWORD *)(v5 + 100);
            v83 += 2;
            v82 += 4;
            --v72;
          }
          while (v72);
        }
      }
      else if (v71 <= 0xFFFFFFFD)
      {
        do
        {
          *(_WORD *)v82 = *v83;
          *(_WORD *)(v82 + 2) = v83[1];
          v83 += 2;
          v82 += 4;
          --v72;
        }
        while (v72);
      }
    }
    else
    {
      v94 = 0;
      if ((*(_BYTE *)(v106 + 6) & 2) != 0)
        v82 = 0;
      if ((*(_BYTE *)(v7 + 6) & 2) == 0)
        v94 = *(float **)(v7 + 8);
      v95 = *(_DWORD *)(v5 + 100);
      if (v95)
      {
        if (v71 <= 0xFFFFFFFD)
        {
          v96 = (float)(1 << v95);
          do
          {
            *(float *)v82 = *v94 * v96;
            *(float *)(v82 + 4) = v94[1] * v96;
            v94 += 2;
            v82 += 8;
            --v72;
          }
          while (v72);
        }
      }
      else if (v71 <= 0xFFFFFFFD)
      {
        do
        {
          *(float *)v82 = *v94;
          *(float *)(v82 + 4) = v94[1];
          v94 += 2;
          v82 += 8;
          --v72;
        }
        while (v72);
      }
    }
  }
  return result;
}

uint64_t kd_synthesis::horizontal_synthesis(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  char v10;
  uint64_t v11;
  int *v12;
  int v13;
  uint64_t v14;
  int v15;
  __int16 *v16;
  __int16 *v17;
  __int16 v18;
  __int16 v19;
  unsigned int v20;
  int *v21;
  int *v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _WORD *v30;
  __int16 v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _DWORD *v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  unsigned __int8 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int8 *v44;
  int v45;
  _BOOL8 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _WORD *v54;
  uint64_t v55;
  _WORD *v56;
  uint64_t v57;
  unsigned __int8 *v58;
  int v59;
  int v60;
  unint64_t v61;
  _WORD *v62;
  uint64_t v63;
  _WORD *v64;
  unint64_t v65;
  _WORD *v66;
  _WORD *v67;
  _BOOL4 v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int *v72;
  int v73;
  uint64_t v74;
  char v75;
  int v76;
  __int16 *v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _DWORD *v85;
  uint64_t v86;
  _DWORD *v87;
  uint64_t v88;
  unsigned __int8 *v89;
  int v90;
  int v91;
  unint64_t v92;
  _DWORD *v93;
  uint64_t v94;
  _DWORD *v95;
  unint64_t v96;
  _DWORD *v97;
  float *v98;
  _BOOL4 v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  float *v103;
  float v104;
  float v105;
  int v106;
  uint64_t v107;
  char v108;
  int v109;
  int v110;
  _DWORD *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  char v115;
  int v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  float v121;
  __int16 *v122;
  __int16 *v123;
  float v124;
  float *v125;
  _DWORD *v126;
  _DWORD *v127;

  v6 = result;
  v7 = 0;
  v8 = 2 * a3;
  v9 = 1;
  do
  {
    v10 = v9;
    v11 = v6 + 4 * v7;
    v13 = *(_DWORD *)(v11 + 172);
    v12 = (int *)(v11 + 172);
    if (v13 >= 1)
    {
      v14 = *(_QWORD *)(v6 + 8 * (v7 | v8) + 8);
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v14 + 24))(v14, a2 + 16 * v7, a4);
      v15 = *(unsigned __int8 *)(v6 + v7 + 180);
      if (*(_BYTE *)(v6 + v7 + 180))
      {
        if (*(_BYTE *)(v6 + 206))
        {
          v16 = (__int16 *)(*(_QWORD *)(a2 + 16 * v7 + 8) + 2 * *(unsigned __int8 *)(v6 + v7 + 170));
          v19 = *v16;
          v17 = v16 - 1;
          v18 = v19;
          v20 = v15 + 1;
          do
          {
            *v17-- = v18;
            --v20;
          }
          while (v20 > 1);
        }
        else
        {
          v21 = (int *)(*(_QWORD *)(a2 + 16 * v7 + 8) + 4 * *(unsigned __int8 *)(v6 + v7 + 170));
          v24 = *v21;
          v22 = v21 - 1;
          v23 = v24;
          v25 = v15 + 1;
          do
          {
            *v22-- = v23;
            --v25;
          }
          while (v25 > 1);
        }
      }
      v26 = *(unsigned __int8 *)(v6 + v7 + 182);
      if (*(_BYTE *)(v6 + v7 + 182))
      {
        if (*(_BYTE *)(v6 + 206))
        {
          v27 = *(_QWORD *)(a2 + 16 * v7 + 8);
          v28 = *(unsigned __int8 *)(v6 + v7 + 170);
          v29 = *v12;
          v30 = (_WORD *)(v27 + 2 * v28 + 2 * v29);
          v31 = *(_WORD *)(v27 + 2 * (v29 + v28) - 2);
          v32 = v26 + 1;
          do
          {
            *v30++ = v31;
            --v32;
          }
          while (v32 > 1);
        }
        else
        {
          v33 = *(_QWORD *)(a2 + 16 * v7 + 8);
          v34 = *(unsigned __int8 *)(v6 + v7 + 170);
          v35 = *v12;
          v36 = (_DWORD *)(v33 + 4 * v34 + 4 * v35);
          v37 = *(_DWORD *)(v33 + 4 * (v35 + v34) - 4);
          v38 = v26 + 1;
          do
          {
            *v36++ = v37;
            --v38;
          }
          while (v38 > 1);
        }
      }
    }
    v9 = 0;
    v7 = 1;
  }
  while ((v10 & 1) != 0);
  LODWORD(v39) = *(_DWORD *)(v6 + 48);
  if ((_DWORD)v39)
  {
    if (*(_BYTE *)(v6 + 208))
    {
      if (*(_BYTE *)(v6 + 40) && (*(_BYTE *)(v6 + 152) & 1) != 0)
      {
        if (*(_BYTE *)(v6 + 206))
          *(_WORD *)(*(_QWORD *)(a2 + 24) + 2 * *(unsigned __int8 *)(v6 + 169)) = *(__int16 *)(*(_QWORD *)(a2 + 24) + 2 * *(unsigned __int8 *)(v6 + 169)) >> 1;
        else
          *(int *)(*(_QWORD *)(a2 + 24) + 4 * *(unsigned __int8 *)(v6 + 169)) >>= 1;
      }
      if (*(_BYTE *)(v6 + 208))
        return result;
      LODWORD(v39) = *(_DWORD *)(v6 + 48);
    }
    if ((int)v39 >= 1)
    {
      v39 = v39;
      do
      {
        v40 = v39 - 1;
        v41 = *(_QWORD *)(v6 + 88);
        v42 = (v39 - 1);
        v43 = v41 + 32 * v42;
        v45 = *(unsigned __int8 *)(v43 + 1);
        v44 = (unsigned __int8 *)(v43 + 1);
        if (v45)
        {
          v46 = (v40 & 1) == 0;
          v47 = *(unsigned int *)(v6 + 4 * v46 + 160);
          v48 = *(unsigned __int8 *)(v6 + v46 + 168);
          v49 = v40 & 1;
          if (*(_BYTE *)(v6 + 206))
          {
            if ((*(_BYTE *)(a2 + 16 * (v40 & 1) + 6) & 2) != 0)
              v50 = *(_QWORD *)(a2 + 16 * v49 + 8);
            else
              v50 = 0;
            v52 = a2 + 16 * v46;
            if ((*(_BYTE *)(v52 + 6) & 2) != 0)
              v53 = *(_QWORD *)(v52 + 8);
            else
              v53 = 0;
            result = *(unsigned __int8 *)(v6 + v49 + 168);
            v54 = (_WORD *)(v50 + 2 * result);
            v55 = *(int *)(v6 + 4 * v49 + 160);
            v56 = &v54[v55];
            v57 = v41 + 32 * v42;
            v60 = *(unsigned __int8 *)(v57 + 3);
            v58 = (unsigned __int8 *)(v57 + 3);
            v59 = v60;
            if (*(_BYTE *)(v6 + 99))
            {
              if (v59)
              {
                v61 = 0;
                v62 = v56 - 1;
                v63 = -1;
                v64 = &v54[v55];
                do
                {
                  v54[v63] = v54[v61 - ((*(_DWORD *)(v6 + 152) ^ v40) & 1) + 1];
                  v64[v61++] = v62[v63 + ((*(_DWORD *)(v6 + 156) ^ v40) & 1)];
                  --v63;
                }
                while (v61 < *v58);
              }
            }
            else if (v59)
            {
              v65 = 0;
              v66 = (_WORD *)(v50 + 2 * result - 2);
              do
              {
                *v66-- = *v54;
                v56[v65++] = *(v56 - 1);
              }
              while (v65 < *v58);
            }
            v67 = (_WORD *)(v53 + 2 * v48);
            v68 = (*(unsigned __int8 *)(v6 + 152) << 31 >> 31) & (1 - 2 * v46);
            v69 = v41 + 32 * v42;
            v70 = *(__int16 *)(v69 + 4);
            v71 = *v44;
            v72 = *(int **)(v69 + 16);
            if ((_DWORD)v71 == 2 && (v73 = *v72, *v72 == v72[1]))
            {
              v74 = v41 + 32 * v42;
              v75 = *(_BYTE *)(v74 + 2);
              v76 = *(__int16 *)(v74 + 6);
              if (v73 == 1)
              {
                if ((int)v47 >= 1)
                {
                  v122 = (__int16 *)(v50 + 2 * v70 + 2 * v68 + 2 * result + 2);
                  do
                  {
                    *v67++ -= (*(v122 - 1) + v76 + *v122) >> v75;
                    ++v122;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if (v73 == -1)
              {
                if ((int)v47 >= 1)
                {
                  v77 = (__int16 *)(v50 + 2 * v70 + 2 * v68 + 2 * result + 2);
                  do
                  {
                    *v67++ -= (v76 - (*(v77 - 1) + *v77)) >> v75;
                    ++v77;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if ((int)v47 >= 1)
              {
                v123 = (__int16 *)(v50 + 2 * v70 + 2 * v68 + 2 * result + 2);
                do
                {
                  *v67++ -= (v76 + (*v123 + *(v123 - 1)) * v73) >> v75;
                  ++v123;
                  --v47;
                }
                while (v47);
              }
            }
            else if ((int)v47 >= 1)
            {
              v78 = 0;
              v79 = (uint64_t)&v54[v68 + v70];
              v80 = *(_BYTE *)(v69 + 2);
              result = *(__int16 *)(v69 + 6);
              do
              {
                v81 = result;
                if ((_DWORD)v71)
                {
                  v82 = 0;
                  v81 = result;
                  do
                  {
                    v81 += v72[v82] * *(__int16 *)(v79 + 2 * v82);
                    ++v82;
                  }
                  while (v71 != v82);
                }
                v67[v78++] -= v81 >> v80;
                v79 += 2;
              }
              while (v78 != v47);
            }
          }
          else
          {
            if ((*(_BYTE *)(a2 + 16 * (v40 & 1) + 6) & 2) != 0)
              v51 = 0;
            else
              v51 = *(_QWORD *)(a2 + 16 * v49 + 8);
            v83 = a2 + 16 * v46;
            if ((*(_BYTE *)(v83 + 6) & 2) != 0)
              v84 = 0;
            else
              v84 = *(_QWORD *)(v83 + 8);
            result = *(unsigned __int8 *)(v6 + v49 + 168);
            v85 = (_DWORD *)(v51 + 4 * result);
            v86 = *(int *)(v6 + 4 * v49 + 160);
            v87 = &v85[v86];
            v88 = v41 + 32 * v42;
            v91 = *(unsigned __int8 *)(v88 + 3);
            v89 = (unsigned __int8 *)(v88 + 3);
            v90 = v91;
            if (*(_BYTE *)(v6 + 99))
            {
              if (v90)
              {
                v92 = 0;
                v93 = v87 - 1;
                v94 = -1;
                v95 = &v85[v86];
                do
                {
                  v85[v94] = v85[v92 - ((*(_DWORD *)(v6 + 152) ^ v40) & 1) + 1];
                  v95[v92++] = v93[v94 + ((*(_DWORD *)(v6 + 156) ^ v40) & 1)];
                  --v94;
                }
                while (v92 < *v89);
              }
            }
            else if (v90)
            {
              v96 = 0;
              v97 = (_DWORD *)(v51 + 4 * result - 4);
              do
              {
                *v97-- = *v85;
                v87[v96++] = *(v87 - 1);
              }
              while (v96 < *v89);
            }
            v98 = (float *)(v84 + 4 * v48);
            v99 = (*(unsigned __int8 *)(v6 + 152) << 31 >> 31) & (1 - 2 * v46);
            v100 = v41 + 32 * v42;
            v101 = *(__int16 *)(v100 + 4);
            v102 = *v44;
            if ((_DWORD)v102 != 2)
            {
              v106 = *(unsigned __int8 *)(v6 + 40);
LABEL_84:
              v112 = (uint64_t)&v85[v99 + v101];
              if (v106)
              {
                if ((int)v47 >= 1)
                {
                  v113 = 0;
                  v114 = v41 + 32 * v42;
                  v115 = *(_BYTE *)(v114 + 2);
                  v116 = *(__int16 *)(v114 + 6);
                  result = *(_QWORD *)(v114 + 16);
                  do
                  {
                    v117 = v116;
                    if ((_DWORD)v102)
                    {
                      v118 = 0;
                      v117 = v116;
                      do
                      {
                        v117 += *(_DWORD *)(v112 + v118) * *(_DWORD *)(result + v118);
                        v118 += 4;
                      }
                      while (4 * v102 != v118);
                    }
                    LODWORD(v98[v113++]) -= v117 >> v115;
                    v112 += 4;
                  }
                  while (v113 != v47);
                }
              }
              else if ((int)v47 >= 1)
              {
                v119 = 0;
                v120 = *(_QWORD *)(v41 + 32 * v42 + 8);
                do
                {
                  if ((_DWORD)v102)
                  {
                    result = 0;
                    v121 = 0.0;
                    do
                    {
                      v121 = v121 + (float)(*(float *)(v120 + result) * *(float *)(v112 + result));
                      result += 4;
                    }
                    while (4 * v102 != result);
                  }
                  else
                  {
                    v121 = 0.0;
                  }
                  v98[v119] = v98[v119] - v121;
                  ++v119;
                  v112 += 4;
                }
                while (v119 != v47);
              }
              continue;
            }
            v103 = *(float **)(v100 + 8);
            v104 = *v103;
            v105 = v103[1];
            v106 = *(unsigned __int8 *)(v6 + 40);
            if (v104 != v105)
              goto LABEL_84;
            if (*(_BYTE *)(v6 + 40))
            {
              v107 = v41 + 32 * v42;
              v108 = *(_BYTE *)(v107 + 2);
              v109 = *(__int16 *)(v107 + 6);
              v110 = **(_DWORD **)(v107 + 16);
              if (v110 == 1)
              {
                if ((int)v47 >= 1)
                {
                  v126 = (_DWORD *)(v51 + 4 * v101 + 4 * v99 + 4 * result + 4);
                  do
                  {
                    *(_DWORD *)v98++ -= (*(v126 - 1) + v109 + *v126) >> v108;
                    ++v126;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if (v110 == -1)
              {
                if ((int)v47 >= 1)
                {
                  v111 = (_DWORD *)(v51 + 4 * v101 + 4 * v99 + 4 * result + 4);
                  do
                  {
                    *(_DWORD *)v98++ -= (v109 - (*(v111 - 1) + *v111)) >> v108;
                    ++v111;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if ((int)v47 >= 1)
              {
                v127 = (_DWORD *)(v51 + 4 * v101 + 4 * v99 + 4 * result + 4);
                do
                {
                  *(_DWORD *)v98++ -= (v109 + (*v127 + *(v127 - 1)) * v110) >> v108;
                  ++v127;
                  --v47;
                }
                while (v47);
              }
            }
            else if ((int)v47 >= 1)
            {
              v124 = -v104;
              v125 = (float *)(v51 + 4 * v101 + 4 * v99 + 4 * result + 4);
              do
              {
                *v98 = *v98 + (float)(v124 * (float)(*(v125 - 1) + *v125));
                ++v98;
                ++v125;
                --v47;
              }
              while (v47);
            }
          }
        }
      }
      while (v39-- > 1);
    }
  }
  return result;
}

uint64_t perform_synthesis_lifting_step(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  int v21;
  uint64_t v22;
  char v23;
  int v24;
  uint64_t v25;
  int v26;
  int *v27;
  uint64_t v28;
  uint64_t *v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;

  if (a5 >= 1)
  {
    if (a6 >= 16)
      v6 = 16;
    else
      v6 = a6;
    v7 = a6 - v6 + 7;
    v8 = v7 & 0xFFFFFFF8;
    v9 = 16 * (v7 >> 3) + 16;
    v10 = a6 - v8 - 8;
    v11 = a4 + v9;
    if (a6 >= 9)
      v12 = a3 + v9;
    else
      v12 = a3;
    if (a6 >= 9)
    {
      LODWORD(v13) = v10;
    }
    else
    {
      v11 = a4;
      LODWORD(v13) = a6;
    }
    v14 = v13 + a5;
    v15 = *(unsigned __int8 *)(result + 1);
    if ((_DWORD)v15 == 2 && (v16 = *(int **)(result + 16), v17 = *v16, *v16 == v16[1]))
    {
      v18 = *a2;
      v19 = a2[1];
      v20 = *(_BYTE *)(result + 2);
      v21 = 1 << v20 >> 1;
      if (v17 == 1)
      {
        v33 = (int)v13;
        do
        {
          result = *(unsigned __int16 *)(v12 + 2 * v33);
          *(_WORD *)(v11 + 2 * v33) = result
                                    - ((v21 + *(__int16 *)(v18 + 2 * v33) + *(__int16 *)(v19 + 2 * v33)) >> v20);
          ++v33;
        }
        while (v33 < v14);
      }
      else if (v17 == -1)
      {
        v22 = (int)v13;
        do
        {
          result = *(unsigned __int16 *)(v12 + 2 * v22);
          *(_WORD *)(v11 + 2 * v22) = result
                                    - ((v21 - (*(__int16 *)(v18 + 2 * v22) + *(__int16 *)(v19 + 2 * v22))) >> v20);
          ++v22;
        }
        while (v22 < v14);
      }
      else
      {
        v13 = (int)v13;
        do
        {
          result = *(unsigned __int16 *)(v12 + 2 * v13);
          *(_WORD *)(v11 + 2 * v13) = result
                                    - ((v21 + (*(__int16 *)(v19 + 2 * v13) + *(__int16 *)(v18 + 2 * v13)) * v17) >> v20);
          ++v13;
        }
        while (v13 < v14);
      }
    }
    else
    {
      v23 = *(_BYTE *)(result + 2);
      v24 = *(__int16 *)(result + 6);
      v25 = (int)v13;
      do
      {
        v26 = v24;
        if ((_DWORD)v15)
        {
          v27 = *(int **)(result + 16);
          v28 = v15;
          v29 = a2;
          v26 = v24;
          do
          {
            v31 = *v27++;
            v30 = v31;
            v32 = *v29++;
            v26 += v30 * *(__int16 *)(v32 + 2 * v25);
            --v28;
          }
          while (v28);
        }
        *(_WORD *)(v11 + 2 * v25) = *(_WORD *)(v12 + 2 * v25) - (v26 >> v23);
        ++v25;
      }
      while (v25 < v14);
    }
  }
  return result;
}

{
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  float *v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  int v22;
  int v23;
  char v24;
  int v25;
  uint64_t v26;
  int v27;
  int *v28;
  uint64_t v29;
  uint64_t *v30;
  int v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  float v39;
  uint64_t v40;

  if (a5 < 1)
    return result;
  if (a6 >= 8)
    v6 = 8;
  else
    v6 = a6;
  v7 = a6 - v6 + 3;
  v8 = v7 & 0xFFFFFFFC;
  v9 = 16 * (v7 >> 2) + 16;
  v10 = a3 + v9;
  v11 = a6 - v8 - 4;
  v12 = a4 + v9;
  if (a6 >= 5)
    v13 = v10;
  else
    v13 = a3;
  if (a6 >= 5)
  {
    LODWORD(v14) = v11;
  }
  else
  {
    v12 = a4;
    LODWORD(v14) = a6;
  }
  v15 = v14 + a5;
  v16 = *(unsigned __int8 *)(result + 1);
  if ((_DWORD)v16 == 2)
  {
    v17 = *(float **)(result + 8);
    v18 = *v17;
    if (*v17 == v17[1])
    {
      v19 = *a2;
      v20 = a2[1];
      if (*(_BYTE *)(result + 29))
      {
        v21 = *(_BYTE *)(result + 2);
        v22 = *(__int16 *)(result + 6);
        v23 = **(_DWORD **)(result + 16);
        v14 = (int)v14;
        if (v23 == 1)
        {
          do
          {
            result = *(unsigned int *)(v20 + 4 * v14);
            *(_DWORD *)(v12 + 4 * v14) = *(_DWORD *)(v13 + 4 * v14)
                                       - ((*(_DWORD *)(v19 + 4 * v14) + v22 + (int)result) >> v21);
            ++v14;
          }
          while (v14 < v15);
        }
        else if (v23 == -1)
        {
          do
          {
            result = *(unsigned int *)(v20 + 4 * v14);
            *(_DWORD *)(v12 + 4 * v14) = *(_DWORD *)(v13 + 4 * v14)
                                       - ((v22 - (*(_DWORD *)(v19 + 4 * v14) + (int)result)) >> v21);
            ++v14;
          }
          while (v14 < v15);
        }
        else
        {
          do
          {
            result = ((v22 + (*(_DWORD *)(v20 + 4 * v14) + *(_DWORD *)(v19 + 4 * v14)) * v23) >> v21);
            *(_DWORD *)(v12 + 4 * v14) = *(_DWORD *)(v13 + 4 * v14) - result;
            ++v14;
          }
          while (v14 < v15);
        }
      }
      else
      {
        v39 = -v18;
        v40 = (int)v14;
        do
        {
          *(float *)(v12 + 4 * v40) = *(float *)(v13 + 4 * v40)
                                    + (float)(v39 * (float)(*(float *)(v19 + 4 * v40) + *(float *)(v20 + 4 * v40)));
          ++v40;
        }
        while (v40 < v15);
      }
      return result;
    }
    if (*(_BYTE *)(result + 29))
      goto LABEL_26;
LABEL_32:
    v34 = 0;
    v35 = v15;
    do
    {
      v36 = a2[v34];
      v37 = -*(float *)(*(_QWORD *)(result + 8) + 4 * v34);
      v38 = (int)v14;
      do
      {
        *(float *)(v12 + 4 * v38) = *(float *)(v13 + 4 * v38) + (float)(v37 * *(float *)(v36 + 4 * v38));
        ++v38;
      }
      while (v38 < v35);
      ++v34;
      v13 = v12;
    }
    while (v34 < *(unsigned __int8 *)(result + 1));
    return result;
  }
  if (!*(_BYTE *)(result + 29))
  {
    if (!*(_BYTE *)(result + 1))
      return result;
    goto LABEL_32;
  }
LABEL_26:
  v24 = *(_BYTE *)(result + 2);
  v25 = *(__int16 *)(result + 6);
  v26 = (int)v14;
  do
  {
    v27 = v25;
    if ((_DWORD)v16)
    {
      v28 = *(int **)(result + 16);
      v29 = v16;
      v30 = a2;
      v27 = v25;
      do
      {
        v32 = *v28++;
        v31 = v32;
        v33 = *v30++;
        v27 += *(_DWORD *)(v33 + 4 * v26) * v31;
        --v29;
      }
      while (v29);
    }
    *(_DWORD *)(v12 + 4 * v26) = *(_DWORD *)(v13 + 4 * v26) - (v27 >> v24);
    ++v26;
  }
  while (v26 < v15);
  return result;
}

void kd_synthesis::kd_synthesis(kd_synthesis *this)
{
  uint64_t v1;
  kd_synthesis *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;

  v1 = 0;
  *(_QWORD *)this = &off_1E1BAC500;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  v2 = (kd_synthesis *)((char *)this + 400);
  do
  {
    v3 = v1;
    v4 = 2;
    do
    {
      v5 = (char *)this + v3;
      *((_DWORD *)v5 + 100) = 0;
      *((_WORD *)v5 + 203) = 0;
      *((_QWORD *)v5 + 51) = 0;
      v3 += 16;
      --v4;
    }
    while (v4);
    v2 = (kd_synthesis *)((char *)v2 + 40);
    v1 += 40;
  }
  while (v2 != (kd_synthesis *)((char *)this + 640));
  *((_QWORD *)this + 13) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_QWORD *)this + 33) = 0;
}

uint64_t _cg_jpeg_fdct_islow(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t i;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;

  for (i = 0; i != 64; i += 8)
  {
    v4 = (_DWORD *)(result + 4 * i);
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + i) + a3);
    v6 = *v5;
    v7 = v5[7];
    v8 = v5[1];
    v9 = v5[6];
    v10 = (v9 + v8);
    v11 = v5[2];
    v12 = v5[5];
    v13 = (v12 + v11);
    v14 = v5[3];
    LODWORD(v5) = v5[4];
    v15 = (_DWORD)v5 + v14 + v7 + v6;
    v16 = v7 + v6 - ((_DWORD)v5 + v14);
    v17 = v13 + v10;
    v18 = v10 - v13;
    v19 = v6 - v7;
    v20 = v8 - v9;
    v21 = v11 - v12;
    LODWORD(v5) = v14 - (_DWORD)v5;
    v22 = 4433 * (v16 + (int)v18) + 1024;
    v23 = (unint64_t)(v22 + 6270 * v16) >> 11;
    v24 = (unint64_t)(v22 + 0x7FFFFFFC4DFLL * v18) >> 11;
    v25 = 9633 * ((int)v5 + v20 + v21 + v19) + 1024;
    v26 = v25 - 3196 * (v21 + v19);
    v27 = v25 - 16069 * ((int)v5 + v20);
    *v4 = 4 * (v15 + v17) - 4096;
    v4[1] = (unint64_t)(12299 * v19 - 7373 * ((int)v5 + v19) + v26) >> 11;
    v4[2] = v23;
    v4[3] = (unint64_t)(25172 * v20 - 20995 * (v21 + v20) + v27) >> 11;
    v4[4] = 4 * (v15 - v17);
    v4[5] = (unint64_t)(16819 * v21 - 20995 * (v21 + v20) + v26) >> 11;
    v4[6] = v24;
    v4[7] = (unint64_t)(2446 * (int)v5 - 7373 * ((int)v5 + v19) + v27) >> 11;
  }
  v28 = 0;
  do
  {
    v29 = (_DWORD *)(result + v28);
    v30 = *(_DWORD *)(result + v28);
    v31 = *(_DWORD *)(result + v28 + 224);
    v32 = v31 + v30;
    v33 = *(_DWORD *)(result + v28 + 32);
    v34 = *(_DWORD *)(result + v28 + 192);
    v35 = *(_DWORD *)(result + v28 + 64);
    v36 = *(_DWORD *)(result + v28 + 160);
    v37 = *(_DWORD *)(result + v28 + 96);
    v38 = *(_DWORD *)(result + v28 + 128);
    v39 = v32 + v38 + v37 + 2;
    v40 = v32 - (v38 + v37);
    v41 = v36 + v35 + (uint64_t)(v34 + v33);
    v42 = v34 + v33 - (uint64_t)(v36 + v35);
    v43 = v30 - v31;
    v44 = v33 - v34;
    v45 = v35 - v36;
    v46 = v37 - v38;
    *v29 = (unint64_t)(v39 + v41) >> 2;
    v29[32] = (unint64_t)(v39 - v41) >> 2;
    v47 = 4433 * (v40 + v42) + 0x4000;
    v29[16] = (unint64_t)(v47 + 6270 * v40) >> 15;
    v29[48] = (unint64_t)(v47 + 0x7FFFFFFFC4DFLL * v42) >> 15;
    v48 = v45 + (uint64_t)v43;
    v49 = v46 + v44;
    v50 = 9633 * (v49 + v48) + 0x4000;
    v51 = v50 - 3196 * v48;
    v52 = v50 - 16069 * v49;
    v53 = -7373 * (v46 + v43);
    v54 = -20995 * (v45 + (uint64_t)v44);
    v29[8] = (unint64_t)(v53 + 12299 * v43 + v51) >> 15;
    v29[24] = (unint64_t)(v54 + 25172 * v44 + v52) >> 15;
    v29[40] = (unint64_t)(v54 + 16819 * v45 + v51) >> 15;
    v29[56] = (unint64_t)(v53 + 2446 * v46 + v52) >> 15;
    v28 += 4;
  }
  while ((_DWORD)v28 != 32);
  return result;
}

_OWORD *jpeg_fdct_7x7(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  *result = 0u;
  result[1] = 0u;
  do
  {
    v4 = &result[v3];
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + a3);
    v6 = *v5;
    v7 = v5[6];
    v8 = v7 + v6;
    v9 = v5[1];
    v10 = v5[5];
    v11 = (v10 + v9);
    v12 = v5[2];
    v13 = v5[4];
    v14 = v13 + v12;
    v15 = v5[3];
    v16 = v6 - v7;
    v17 = v9 - v10;
    LODWORD(v5) = v12 - v13;
    v18 = v13 + v12 + v8;
    v19 = 4 * (v15 + v11 + v18) - 3584;
    v20 = v18 - 4 * v15;
    v21 = v8 - (v13 + v12);
    v22 = v11 - v14;
    v23 = (unint64_t)(7542 * v21 + 2578 * ((int)v11 - v14) + 2896 * v20 + 1024) >> 11;
    v24 = 7223 * (v8 - (int)v11) + 1024;
    v25 = (v24 + 2578 * v22 + 0x7FFFFFFE95FLL * (v11 - 2 * (unint64_t)v15)) >> 11;
    v4[6] = (unint64_t)(v24 - 7542 * v21 + 2896 * v20) >> 11;
    LODWORD(v24) = v17 + v16;
    v26 = 1395 * (v16 - v17);
    v27 = (_DWORD)v5 + v17;
    v28 = 5027 * ((int)v5 + v16) + 1024;
    *v4 = v19;
    v4[1] = (unint64_t)(v28 - v26 + 7663 * (int)v24) >> 11;
    v4[2] = v23;
    v4[3] = (unint64_t)(v26 - 11295 * v27 + 7663 * (int)v24 + 1024) >> 11;
    v4[4] = v25;
    v4[5] = (unint64_t)(v28 + 15326 * (int)v5 - 11295 * v27) >> 11;
    v3 += 2;
  }
  while (v3 != 14);
  v29 = 0;
  do
  {
    v30 = (_DWORD *)((char *)result + v29);
    v31 = *(_DWORD *)((char *)result + v29);
    v32 = *(_DWORD *)((char *)result + v29 + 192);
    v33 = v32 + v31;
    v34 = *(_DWORD *)((char *)result + v29 + 32);
    v35 = *(_DWORD *)((char *)result + v29 + 160);
    v36 = v35 + v34;
    v37 = *(_DWORD *)((char *)result + v29 + 64);
    v38 = *(_DWORD *)((char *)result + v29 + 128);
    v39 = v38 + v37;
    v40 = v38 + v37;
    v41 = *(int *)((char *)result + v29 + 96);
    v42 = v31 - v32;
    v43 = v34 - v35;
    v44 = v37 - v38;
    *v30 = (unint64_t)(10700 * (v41 + v36 + v40 + v33) + 0x4000) >> 15;
    v45 = 3783 * (v40 + v33 - 4 * v41);
    v46 = 9850 * (v33 - v39);
    v47 = 3367 * (v36 - v39);
    v30[16] = (unint64_t)(v47 + v46 + v45 + 0x4000) >> 15;
    v48 = 9434 * (v33 - v36) + 0x4000;
    v30[32] = (unint64_t)(v48 + v47 + 0x7FFFFFFFE272 * (v36 - 2 * v41)) >> 15;
    v30[48] = (unint64_t)(v48 - v46 + v45) >> 15;
    v49 = 10009 * (v43 + v42);
    v50 = 1822 * (v42 - v43);
    v51 = 6565 * (v44 + v42) + 0x4000;
    v30[8] = (unint64_t)(v51 - v50 + v49) >> 15;
    v30[24] = (unint64_t)(-14752 * (v44 + v43) + v50 + v49 + 0x4000) >> 15;
    v30[40] = (unint64_t)(v51 + 20017 * v44 - 14752 * (v44 + v43)) >> 15;
    v29 += 4;
  }
  while ((_DWORD)v29 != 28);
  return result;
}

_OWORD *jpeg_fdct_6x6(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  v4 = a3;
  *result = 0u;
  result[1] = 0u;
  do
  {
    v5 = (int *)&result[v3];
    v6 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + v4);
    v7 = *v6;
    v8 = v6[5];
    v9 = v6[1];
    v10 = v6[4];
    v11 = v10 + v9;
    v12 = v6[2];
    LODWORD(v6) = v6[3];
    v13 = (_DWORD)v6 + v12 + v8 + v7;
    v14 = v8 + v7 - ((_DWORD)v6 + v12);
    v15 = v7 - v8;
    v16 = v9 - v10;
    LODWORD(v6) = v12 - (_DWORD)v6;
    v17 = 4 * (v13 + v10 + v9) - 3072;
    v18 = (unint64_t)(5793 * (v13 - 2 * v11) + 1024) >> 11;
    v19 = (unint64_t)(2998 * ((int)v6 + v15) + 1024) >> 11;
    *v5 = v17;
    v5[1] = v19 + 4 * (v16 + v15);
    v5[2] = (10033 * v14 + 1024) >> 11;
    v5[3] = 4 * (v15 - (v16 + (_DWORD)v6));
    v5[4] = v18;
    v5[5] = v19 + 4 * ((_DWORD)v6 - v16);
    v3 += 2;
  }
  while (v3 != 12);
  v20 = 0;
  do
  {
    v21 = (_DWORD *)((char *)result + v20);
    v22 = *(_DWORD *)((char *)result + v20);
    v23 = *(_DWORD *)((char *)result + v20 + 160);
    v24 = *(_DWORD *)((char *)result + v20 + 32);
    v25 = *(_DWORD *)((char *)result + v20 + 128);
    v26 = v25 + v24;
    v27 = *(_DWORD *)((char *)result + v20 + 64);
    v28 = *(_DWORD *)((char *)result + v20 + 96);
    v29 = v28 + v27 + (uint64_t)(v23 + v22);
    v30 = v23 + v22 - (uint64_t)(v28 + v27);
    v31 = v22 - v23;
    v32 = v24 - v25;
    v33 = v27 - v28;
    *v21 = (unint64_t)(14564 * (v29 + v26) + 0x4000) >> 15;
    v21[16] = (unint64_t)(17837 * v30 + 0x4000) >> 15;
    v21[32] = (unint64_t)(10298 * (v29 - 2 * v26) + 0x4000) >> 15;
    v34 = 5331 * (v33 + v31) + 0x4000;
    v21[8] = (unint64_t)(v34 + 14564 * (v32 + v31)) >> 15;
    v21[24] = (unint64_t)(14564 * (v31 - (v32 + v33)) + 0x4000) >> 15;
    v21[40] = (unint64_t)(v34 + 14564 * (v33 - v32)) >> 15;
    v20 += 4;
  }
  while ((_DWORD)v20 != 24);
  return result;
}

_OWORD *jpeg_fdct_5x5(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  v4 = a3;
  result[2] = 0u;
  result[3] = 0u;
  *result = 0u;
  result[1] = 0u;
  do
  {
    v5 = &result[v3];
    v6 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + v4);
    v7 = *v6;
    v8 = v6[4];
    v9 = v8 + v7;
    v10 = v6[1];
    v11 = v6[3];
    v12 = v11 + v10;
    LODWORD(v6) = v6[2];
    v13 = v7 - v8;
    v14 = v10 - v11;
    LODWORD(v10) = 8 * (v11 + v10 + v9 + (_DWORD)v6) - 5120;
    LODWORD(v6) = v12 + v9 - 4 * (_DWORD)v6;
    v15 = 6476 * (v9 - v12) + 512;
    v16 = (unint64_t)(v15 + 2896 * (int)v6) >> 10;
    v5[4] = (unint64_t)(v15 - 2896 * (int)v6) >> 10;
    v17 = 6810 * ((int)v14 + v13) + 512;
    *v5 = v10;
    v5[1] = (unint64_t)(v17 + 4209 * v13) >> 10;
    v5[2] = v16;
    v5[3] = (unint64_t)(v17 + 0x3FFFFFFBA5CLL * v14) >> 10;
    v3 += 2;
  }
  while (v3 != 10);
  v18 = 0;
  do
  {
    v19 = (_DWORD *)((char *)result + v18);
    v20 = *(_DWORD *)((char *)result + v18);
    v21 = *(_DWORD *)((char *)result + v18 + 128);
    v22 = *(_DWORD *)((char *)result + v18 + 32);
    v23 = *(_DWORD *)((char *)result + v18 + 96);
    v24 = v23 + v22;
    v25 = *(int *)((char *)result + v18 + 64);
    v26 = v24 + v21 + v20;
    v27 = v21 + v20 - v24;
    v28 = v20 - v21;
    v29 = v22 - v23;
    *v19 = (unint64_t)(10486 * (v26 + v25) + 0x4000) >> 15;
    v30 = 3707 * (v26 - 4 * v25);
    v31 = 8290 * v27 + 0x4000;
    v19[16] = (unint64_t)(v31 + v30) >> 15;
    v19[32] = (unint64_t)(v31 - v30) >> 15;
    v32 = 8716 * (v29 + v28) + 0x4000;
    v19[8] = (unint64_t)(v32 + 5387 * v28) >> 15;
    v19[24] = (unint64_t)(v32 + 0x7FFFFFFFA6DCLL * v29) >> 15;
    v18 += 4;
  }
  while ((_DWORD)v18 != 20);
  return result;
}

int32x4_t jpeg_fdct_4x4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int64x2_t v18;
  int64x2_t v19;
  int64x2_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  __int128 v26;
  __int128 v27;
  int64x2_t v28;
  int64x2_t v29;
  int64x2_t v30;
  int64x2_t v31;
  int32x4_t v32;
  int64x2_t v33;
  int32x4_t result;

  v3 = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  v4 = a3;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  do
  {
    v5 = (_DWORD *)(a1 + 4 * v3);
    v6 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3) + v4);
    v7 = *v6;
    v8 = v6[3];
    v9 = v8 + v7;
    v10 = v6[1];
    v11 = v6[2];
    v12 = v11 + v10;
    v13 = v7 - v8;
    v14 = v10 - v11;
    v15 = 4433 * ((int)v14 + v13) + 256;
    *v5 = 16 * (v12 + v9) - 0x2000;
    v5[1] = (unint64_t)(v15 + 6270 * v13) >> 9;
    v5[2] = 16 * (v9 - v12);
    v5[3] = (unint64_t)(v15 + 0x1FFFFFFC4DFLL * v14) >> 9;
    v3 += 8;
  }
  while (v3 != 32);
  v16 = *(int32x4_t *)(a1 + 96);
  v17 = vaddq_s32(v16, *(int32x4_t *)a1);
  v18 = vdupq_n_s64(2uLL);
  v19 = vaddw_s32(v18, *(int32x2_t *)v17.i8);
  v20 = vaddw_high_s32(v18, v17);
  v21 = *(int32x4_t *)(a1 + 32);
  v22 = *(int32x4_t *)(a1 + 64);
  v23 = vaddq_s32(v22, v21);
  v24 = vsubq_s32(*(int32x4_t *)a1, v16);
  v25 = vsubq_s32(v21, v22);
  *(_QWORD *)&v26 = v25.i32[2];
  *((_QWORD *)&v26 + 1) = v25.i32[3];
  v27 = v26;
  *(_QWORD *)&v26 = v25.i32[0];
  *((_QWORD *)&v26 + 1) = v25.i32[1];
  *(int32x4_t *)a1 = vshrn_high_n_s64(vshrn_n_s64(vaddw_s32(v19, *(int32x2_t *)v23.i8), 2uLL), vaddw_high_s32(v20, v23), 2uLL);
  *(int32x4_t *)(a1 + 64) = vshrn_high_n_s64(vshrn_n_s64(vsubw_s32(v19, *(int32x2_t *)v23.i8), 2uLL), vsubw_high_s32(v20, v23), 2uLL);
  v28 = vaddl_s32(*(int32x2_t *)v25.i8, *(int32x2_t *)v24.i8);
  v29 = vaddl_high_s32(v25, v24);
  v29.i64[0] *= 4433;
  v29.i64[1] *= 4433;
  v28.i64[0] *= 4433;
  v28.i64[1] *= 4433;
  v30 = vdupq_n_s64(0x4000uLL);
  v31 = vaddq_s64(v28, v30);
  v32 = vdupq_n_s32(0x187Eu);
  v33 = vaddq_s64(v29, v30);
  v30.i64[0] = 0x7FFFFFFFC4DFLL * v27;
  v30.i64[1] = 0x7FFFFFFFC4DFLL * *((_QWORD *)&v27 + 1);
  v16.i64[0] = 0x7FFFFFFFC4DFLL * v26;
  v16.i64[1] = 0x7FFFFFFFC4DFLL * *((_QWORD *)&v26 + 1);
  *(int32x4_t *)(a1 + 32) = vshrn_high_n_s64(vshrn_n_s64(vmlal_s32(v31, *(int32x2_t *)v24.i8, *(int32x2_t *)v32.i8), 0xFuLL), vmlal_high_s32(v33, v24, v32), 0xFuLL);
  result = vshrn_high_n_s64(vshrn_n_s64(vaddq_s64(v31, (int64x2_t)v16), 0xFuLL), vaddq_s64(v33, v30), 0xFuLL);
  *(int32x4_t *)(a1 + 96) = result;
  return result;
}

_OWORD *jpeg_fdct_3x3(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  _DWORD *v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  *result = 0u;
  result[1] = 0u;
  do
  {
    v4 = &result[v3];
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + a3);
    v6 = *v5;
    v7 = v5[2];
    LODWORD(v5) = v5[1];
    v4[2] = (5793 * (v7 + v6 - 2 * (int)v5) + 256) >> 9;
    *v4 = 16 * (v7 + v6 + (_DWORD)v5) - 6144;
    v4[1] = (10033 * (v6 - v7) + 256) >> 9;
    v3 += 2;
  }
  while (v3 != 6);
  v8 = 0;
  do
  {
    v9 = (_DWORD *)((char *)result + v8);
    v10 = *(_DWORD *)((char *)result + v8);
    v11 = *(_DWORD *)((char *)result + v8 + 64);
    v12 = v11 + v10;
    v13 = *(int *)((char *)result + v8 + 32);
    *v9 = (unint64_t)(14564 * (v13 + v12) + 0x4000) >> 15;
    v9[16] = (unint64_t)(10298 * (v12 - 2 * v13) + 0x4000) >> 15;
    v9[8] = (unint64_t)(17837 * (v10 - v11) + 0x4000) >> 15;
    v8 += 4;
  }
  while ((_DWORD)v8 != 12);
  return result;
}

double jpeg_fdct_2x2(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  double result;
  unsigned __int8 *v4;
  int v5;
  int v6;
  unsigned __int8 *v7;
  int v8;
  int v9;

  result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v4 = (unsigned __int8 *)(*a2 + a3);
  v5 = *v4;
  LODWORD(v4) = v4[1];
  v6 = (_DWORD)v4 + v5;
  LODWORD(v4) = v5 - (_DWORD)v4;
  v7 = (unsigned __int8 *)(a2[1] + a3);
  v8 = *v7;
  LODWORD(v7) = v7[1];
  v9 = (_DWORD)v7 + v8;
  LODWORD(v7) = v8 - (_DWORD)v7;
  *(_DWORD *)a1 = 16 * (v9 + v6) - 0x2000;
  *(_DWORD *)(a1 + 4) = 16 * ((_DWORD)v7 + (_DWORD)v4);
  *(_DWORD *)(a1 + 32) = 16 * (v6 - v9);
  *(_DWORD *)(a1 + 36) = 16 * ((_DWORD)v4 - (_DWORD)v7);
  return result;
}

double jpeg_fdct_1x1(_OWORD *a1, _QWORD *a2, unsigned int a3)
{
  double result;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  *(_DWORD *)a1 = (*(unsigned __int8 *)(*a2 + a3) << 6) - 0x2000;
  return result;
}

_DWORD *jpeg_fdct_9x9(_DWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  _DWORD *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  _DWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _OWORD v56[2];
  uint64_t v57;

  v3 = 0;
  v57 = *MEMORY[0x1E0C80C00];
  memset(v56, 0, sizeof(v56));
  v4 = result;
  while (1)
  {
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + a3);
    v6 = *v5;
    v7 = v5[8];
    v8 = (v7 + v6);
    v9 = v5[1];
    v10 = v5[7];
    v11 = (v10 + v9);
    v12 = v5[2];
    v13 = v5[6];
    v14 = (v13 + v12);
    v15 = v5[3];
    v16 = v5[5];
    v17 = (v16 + v15);
    v18 = v5[4];
    v19 = v6 - v7;
    LODWORD(v5) = v9 - v10;
    v20 = v12 - v13;
    v21 = v14 + v8 + v17;
    v22 = 2 * (v21 + v18 + v11) - 2304;
    v23 = (unint64_t)(5793 * (v21 - 2 * (v18 + v11)) + 2048) >> 12;
    LODWORD(v11) = v11 - 2 * v18;
    v24 = 10887 * ((int)v8 - (int)v14) + 2048;
    v25 = (unint64_t)(v24 + 2012 * ((int)v17 - (int)v8) - 5793 * (int)v11) >> 12;
    v4[2] = (unint64_t)(v24 + 8875 * ((int)v14 - (int)v17) + 5793 * (int)v11) >> 12;
    v4[3] = (unint64_t)(10033 * (v19 - (v20 + v15 - v16)) + 2048) >> 12;
    v26 = 7447 * (v20 + v19);
    v27 = 3962 * (v15 - v16 + v19);
    *v4 = v22;
    v4[1] = (unint64_t)(v26 + 10033 * (int)v5 + v27 + 2048) >> 12;
    v28 = v20 - (v15 - v16);
    v4[4] = v25;
    v4[5] = (unint64_t)(v26 - 11409 * v28 - 10033 * (int)v5 + 2048) >> 12;
    v4[6] = v23;
    v4[7] = (unint64_t)(v27 - 10033 * (int)v5 + 11409 * v28 + 2048) >> 12;
    if ((_DWORD)v3 != 7)
      break;
    v4 = v56;
LABEL_6:
    ++v3;
  }
  if ((_DWORD)v3 != 8)
  {
    v4 += 8;
    goto LABEL_6;
  }
  v29 = 0;
  do
  {
    v30 = &result[v29];
    v31 = result[v29];
    v32 = *(_DWORD *)((char *)v56 + v29 * 4);
    v33 = v32 + v31;
    v34 = result[v29 + 8];
    v35 = result[v29 + 56];
    v36 = v35 + v34;
    v37 = result[v29 + 16];
    v38 = result[v29 + 48];
    v39 = v38 + v37;
    v40 = result[v29 + 24];
    v41 = result[v29 + 40];
    v42 = v41 + v40;
    v43 = v31 - v32;
    v44 = v37 - v38;
    v45 = v40 - v41;
    v46 = (int)result[v29 + 32];
    v47 = v34 - v35;
    v48 = v39 + v33 + v42;
    v49 = result;
    *v30 = (unint64_t)(12945 * (v48 + v46 + v36) + 0x4000) >> 15;
    v30[48] = (unint64_t)(9154 * (v48 - 2 * (v46 + v36)) + 0x4000) >> 15;
    v50 = 9154 * (v36 - 2 * v46);
    v51 = 17203 * (v33 - v39) + 0x4000;
    v30[16] = (unint64_t)(v51 + 14024 * (v39 - v42) + v50) >> 15;
    v30[32] = (unint64_t)(v51 + 3179 * (v42 - (uint64_t)v33) - v50) >> 15;
    v30[24] = (unint64_t)(15855 * (v43 - (v44 + v45)) + 0x4000) >> 15;
    v52 = 11768 * (v44 + v43);
    v53 = 6262 * (v45 + v43);
    v30[8] = (unint64_t)(v52 + 15855 * v47 + v53 + 0x4000) >> 15;
    v54 = 18029 * (v44 - v45);
    v30[40] = (unint64_t)(v52 - 15855 * v47 - v54 + 0x4000) >> 15;
    v55 = v53 - 15855 * v47;
    result = v49;
    v30[56] = (unint64_t)(v55 + v54 + 0x4000) >> 15;
    ++v29;
  }
  while ((_DWORD)(v29 * 4) != 32);
  return result;
}

unint64_t jpeg_fdct_10x10(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t result;
  _OWORD v57[4];
  uint64_t v58;

  v3 = 0;
  v58 = *MEMORY[0x1E0C80C00];
  memset(v57, 0, sizeof(v57));
  v4 = a1;
  while (1)
  {
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + a3);
    v6 = *v5;
    v7 = v5[9];
    v8 = v5[1];
    v9 = v5[8];
    v10 = (v9 + v8);
    v11 = v5[3];
    v12 = v5[6];
    v13 = (v12 + v11);
    v14 = v5[4];
    v15 = v5[5];
    v16 = v15 + v14 + v7 + v6;
    v17 = v7 + v6 - (v15 + v14);
    v18 = v13 + v10;
    v19 = v10 - v13;
    v20 = v6 - v7;
    v21 = v5[2];
    v22 = v5[7];
    v23 = v8 - v9;
    LODWORD(v9) = v22 + v21;
    v24 = v21 - v22;
    v25 = v11 - v12;
    LODWORD(v12) = v9 + v16 + v18;
    v26 = (0xFFFFFFFF204 * (v18 - (unint64_t)(2 * v9)) + 9373 * (v16 - 2 * (int)v9) + 2048) >> 12;
    v27 = 6810 * (v17 + (int)v19) + 2048;
    LODWORD(v9) = v14 - v15 + v20;
    v4[4] = v26;
    v4[5] = 2 * (v9 - (v23 - v25 + v24));
    *v4 = 2 * v12 - 2560;
    v4[1] = (unint64_t)(10323 * (int)v23
                             + 11443 * v20
                             + (v24 << 13)
                             + 5260 * (int)v25
                             + 1812 * (v14 - v15)
                             + 2048) >> 12;
    v28 = 2531 * ((int)v9 + (int)v23 - (int)v25) - (v24 << 13) + ((v23 - v25) << 12);
    v29 = -4815 * ((int)v25 + (int)v23) + 7791 * (v20 - (v14 - v15)) + 2048;
    v4[2] = (unint64_t)(v27 + 4209 * v17) >> 12;
    v4[3] = (unint64_t)(v29 + v28) >> 12;
    v4[6] = (unint64_t)(v27 + 0xFFFFFFFBA5CLL * v19) >> 12;
    v4[7] = (unint64_t)(v29 - v28) >> 12;
    if ((_DWORD)v3 != 7)
      break;
    v4 = v57;
LABEL_6:
    ++v3;
  }
  if ((_DWORD)v3 != 9)
  {
    v4 += 8;
    goto LABEL_6;
  }
  v30 = 0;
  do
  {
    v31 = &a1[v30];
    v32 = a1[v30];
    v33 = *(_DWORD *)((char *)&v57[2] + v30 * 4);
    v34 = a1[v30 + 8];
    v35 = *(_DWORD *)((char *)v57 + v30 * 4);
    v36 = a1[v30 + 24];
    v37 = a1[v30 + 48];
    v38 = a1[v30 + 32];
    v39 = a1[v30 + 40];
    v40 = v39 + v38 + (uint64_t)(v33 + v32);
    v41 = v33 + v32 - (uint64_t)(v39 + v38);
    v42 = v37 + v36 + (uint64_t)(v35 + v34);
    v43 = v35 + v34 - (uint64_t)(v37 + v36);
    v44 = a1[v30 + 16];
    v45 = v32 - v33;
    v46 = a1[v30 + 56];
    v47 = v34 - v35;
    v48 = v46 + v44;
    v49 = v44 - v46;
    *v31 = (unint64_t)(10486 * (v42 + v48 + v40) + 0x4000) >> 15;
    v31[32] = (unint64_t)(11997 * (v40 - 2 * v48) + 0x7FFFFFFFEE1ALL * (v42 - 2 * v48) + 0x4000) >> 15;
    v50 = 8716 * (v41 + v43) + 0x4000;
    v31[16] = (unint64_t)(v50 + 5387 * v41) >> 15;
    v31[48] = (unint64_t)(v50 + 0x7FFFFFFFA6DCLL * v43) >> 15;
    v51 = v38 - v39 + (uint64_t)v45;
    v52 = v47 - (uint64_t)(v36 - v37);
    v31[40] = (unint64_t)(10486 * (v51 - (v52 + v49)) + 0x4000) >> 15;
    v31[8] = (unint64_t)(13213 * v47
                              + 14647 * v45
                              + 10486 * v49
                              + 6732 * (v36 - v37)
                              + 2320 * (v38 - v39)
                              + 0x4000) >> 15;
    v53 = 5243 * v52 - 10486 * v49 + 3240 * (v51 + v52);
    v54 = -6163 * (v36 - v37 + (uint64_t)v47) + 9973 * (v45 - (uint64_t)(v38 - v39)) + 0x4000;
    result = (unint64_t)(v54 + v53) >> 15;
    v31[24] = result;
    v31[56] = (unint64_t)(v54 - v53) >> 15;
    ++v30;
  }
  while ((_DWORD)(v30 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_11x11(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _DWORD *v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  uint64_t v61;
  int v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t result;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _OWORD v82[6];
  uint64_t v83;

  v3 = 0;
  v83 = *MEMORY[0x1E0C80C00];
  memset(v82, 0, sizeof(v82));
  v4 = a1;
  while (1)
  {
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + a3);
    v6 = *v5;
    v7 = v5[10];
    v8 = (v7 + v6);
    v9 = v5[2];
    v10 = v5[8];
    v11 = (v10 + v9);
    v12 = v5[3];
    v13 = v5[7];
    v14 = (v13 + v12);
    v15 = v5[4];
    v16 = v5[6];
    v17 = (v16 + v15);
    v18 = v5[5];
    v19 = v8 - 2 * v5[5];
    v20 = v11 - 2 * v5[5];
    v21 = v14 - 2 * v5[5];
    v22 = v17 - 2 * v5[5];
    v23 = 1649 * ((int)v20 + (int)v22) + 11116 * ((int)v19 + (int)v21);
    v24 = v5[1];
    LODWORD(v5) = v5[9];
    v25 = v6 - v7;
    v26 = ((_DWORD)v5 + v24);
    LODWORD(v5) = v24 - (_DWORD)v5;
    LODWORD(v7) = v9 - v10;
    v27 = v12 - v13;
    v28 = v15 - v16;
    v29 = v26 + v8 + v11 + v14;
    v30 = v26 - 2 * v18;
    v31 = v29 + v18;
    v32 = v30 - v21;
    v33 = v17 + v31;
    v34 = 0xFFFFFFFDF6ALL * v21 + 7587 * ((int)v30 - (int)v21) + 0xFFFFFFFD37DLL * v22;
    v35 = 9746 * ((int)v19 - (int)v30) + 2048;
    v36 = v35 + 0xFFFFFFFCC25 * v19;
    v37 = v35 - v30 + (v30 << 9) + 0xFFFFFFFD494 * v20 + 4813 * (int)v22;
    v38 = v34 + v23;
    v39 = 10538 * ((int)v5 + (int)v25) + 2048;
    *v4 = 2 * v33 - 2816;
    v4[1] = (unint64_t)(v39
                             + 0xFFFFFFFC8F6 * v25
                             + 8756 * ((int)v7 + (int)v25)
                             + 6263 * (v27 + (int)v25)
                             + 3264 * (int)v28) >> 12;
    v40 = (unint64_t)(v38 + 2048) >> 12;
    LODWORD(v38) = v7 + (_DWORD)v5;
    v41 = v39 + 10456 * (int)v5;
    LODWORD(v5) = v27 + (_DWORD)v5;
    v4[2] = v40;
    v4[3] = (unint64_t)(v41 - 6263 * (int)v38 - 11467 * (int)v5 + 0xFFFFFFFDDCCLL * v28) >> 12;
    v4[4] = (unint64_t)(v37 + 7587 * v32) >> 12;
    v4[5] = (unint64_t)(-16294 * (int)v7
                             - 6263 * (int)v38
                             + 8756 * ((int)v7 + (int)v25)
                             + 3264 * (v27 + (int)v7)
                             + 11467 * (int)v28
                             + 2048) >> 12;
    v4[6] = (unint64_t)(v36 + 0xFFFFFFFE6C3 * v20 + v23) >> 12;
    v4[7] = (unint64_t)(10695 * v27
                             + 3264 * (v27 + (int)v7)
                             - 11467 * (int)v5
                             + 6263 * (v27 + (int)v25)
                             + 0xFFFFFFFD6D6 * v28
                             + 2048) >> 12;
    if ((_DWORD)v3 != 7)
      break;
    v4 = v82;
LABEL_6:
    ++v3;
  }
  if ((_DWORD)v3 != 10)
  {
    v4 += 8;
    goto LABEL_6;
  }
  v42 = 0;
  do
  {
    v43 = &a1[v42];
    v44 = a1[v42];
    v45 = *(_DWORD *)((char *)&v82[4] + v42 * 4);
    v46 = v45 + v44;
    v47 = a1[v42 + 8];
    v48 = *(_DWORD *)((char *)&v82[2] + v42 * 4);
    v49 = v48 + v47;
    v50 = a1[v42 + 16];
    v51 = *(_DWORD *)((char *)v82 + v42 * 4);
    v52 = v51 + v50;
    v53 = a1[v42 + 24];
    v54 = a1[v42 + 56];
    v55 = a1[v42 + 32];
    v56 = v44 - v45;
    v57 = a1[v42 + 48];
    v58 = v47 - v48;
    v59 = v57 + v55;
    v60 = v50 - v51;
    v61 = (int)a1[v42 + 40];
    v62 = v53 - v54;
    v63 = 8666 * (v49 + v46 + v52 + v54 + v53 + v57 + v55 + v61) + 0x4000;
    v64 = v46 - 2 * v61;
    v65 = v49 - 2 * v61;
    v66 = 10310 * (v64 - v65) + 0x4000;
    result = (v55 - v57);
    *v43 = v63 >> 15;
    v68 = v52 - 2 * v61;
    v69 = v66 + 540 * v65 + 0x7FFFFFFFD211 * v68;
    v70 = v54 + v53 - 2 * v61;
    v71 = v59 - 2 * v61;
    v72 = v66 + 0x7FFFFFFFC925 * v64 + 0x7FFFFFFFE54DLL * v68;
    v73 = 1744 * (v68 + v71) + 11759 * (v64 + v70);
    v74 = 8026 * (v65 - v70);
    v43[16] = (unint64_t)(v74 + 0x7FFFFFFFDD87 * v70 + 0x7FFFFFFFD0EALL * v71 + v73 + 0x4000) >> 15;
    v43[32] = (unint64_t)(v69 + 5091 * v71 + v74) >> 15;
    v43[48] = (unint64_t)(v72 + v73) >> 15;
    v75 = 9262 * (v60 + (uint64_t)v56);
    v76 = 6626 * (v62 + (uint64_t)v56);
    v77 = 11148 * (v58 + (uint64_t)v56) + 0x4000;
    v78 = -6626 * (v60 + (uint64_t)v58);
    v43[8] = (unint64_t)(v77 + 0x7FFFFFFFC5C7 * v56 + v75 + v76 + 3453 * (int)result) >> 15;
    v79 = 3453 * (v62 + (uint64_t)v60);
    v43[24] = (unint64_t)(v77
                               + 11061 * v58
                               + v78
                               - 12131 * (v62 + (uint64_t)v58)
                               + 0x7FFFFFFFDBD2 * (int)result) >> 15;
    v43[40] = (unint64_t)(v78 - 17237 * v60 + v75 + v79 + 12131 * (int)result + 0x4000) >> 15;
    v43[56] = (unint64_t)(v79
                               + 11314 * v62
                               + -12131 * (v62 + (uint64_t)v58)
                               + v76
                               + 0x7FFFFFFFD474 * (int)result
                               + 0x4000) >> 15;
    ++v42;
  }
  while ((_DWORD)(v42 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_12x12(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  _DWORD *v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t result;
  _OWORD v75[8];
  uint64_t v76;

  v3 = 0;
  v76 = *MEMORY[0x1E0C80C00];
  memset(v75, 0, sizeof(v75));
  v4 = a1;
  while (1)
  {
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + a3);
    v6 = *v5;
    v7 = v5[11];
    v8 = v5[1];
    v9 = v5[2];
    v10 = v5[9];
    v11 = (v10 + v9);
    v12 = v5[3];
    v13 = v5[8];
    v14 = (v13 + v12);
    v15 = v5[5];
    v16 = v5[6];
    v17 = v16 + v15 + v7 + v6;
    v18 = v7 + v6 - (v16 + v15);
    v19 = v14 + v11;
    v20 = v11 - v14;
    v21 = v5[10];
    v22 = v6 - v7;
    v23 = (v21 + v8);
    v24 = v8 - v21;
    v25 = v9 - v10;
    LODWORD(v6) = v5[4];
    v26 = v5[7];
    v27 = (v26 + v6);
    LODWORD(v10) = v6 - v26;
    v28 = v15 - v16;
    v29 = v23 - v27;
    LODWORD(v23) = v19 + v23 + v27 + v17 - 1536;
    v30 = v18 - (v29 + v20);
    v31 = v17 - v19;
    v32 = v29 - v20 + 11190 * (v18 + (int)v20);
    v33 = 6270 * v24 + 4433 * ((int)v10 + v24);
    v34 = -15137 * (int)v10 + 4433 * ((int)v10 + v24);
    v35 = v12 - v13 + v22;
    v36 = 9191 * ((int)v25 + (int)v22) + 4096;
    *v4 = v23;
    v4[1] = (unint64_t)(v36 + 0x1FFFFFFFED6ALL * v22 + 7053 * v35 + v33 + 1512 * (int)v28) >> 13;
    v4[2] = (unint64_t)(v32 + 4096) >> 13;
    v4[3] = (unint64_t)(v34 + 10703 * ((int)v22 - (v12 - v13)) + 0x1FFFFFFFEEAFLL * (v28 + v25) + 4096) >> 13;
    v37 = v12 - v13 + v25;
    v4[4] = (unint64_t)(10033 * v31 + 4096) >> 13;
    v4[5] = (unint64_t)(v36 - 19165 * (int)v25 - 1512 * v37 - v34 + 7053 * (int)v28) >> 13;
    v4[6] = v30;
    v4[7] = (unint64_t)(5946 * (v12 - v13) + 7053 * v35 - 1512 * v37 - v33 + 0x1FFFFFFFDC19 * v28 + 4096) >> 13;
    if ((_DWORD)v3 != 7)
      break;
    v4 = v75;
LABEL_6:
    ++v3;
  }
  if ((_DWORD)v3 != 11)
  {
    v4 += 8;
    goto LABEL_6;
  }
  v38 = 0;
  do
  {
    v39 = &a1[v38];
    v40 = a1[v38];
    v41 = *(_DWORD *)((char *)&v75[6] + v38 * 4);
    v42 = a1[v38 + 16];
    v43 = *(_DWORD *)((char *)&v75[2] + v38 * 4);
    v44 = a1[v38 + 24];
    v45 = *(_DWORD *)((char *)v75 + v38 * 4);
    v46 = a1[v38 + 40];
    v47 = a1[v38 + 48];
    v48 = v47 + v46 + (uint64_t)(v41 + v40);
    v49 = v41 + v40 - (uint64_t)(v47 + v46);
    v50 = v45 + v44 + (uint64_t)(v43 + v42);
    v51 = v43 + v42 - (uint64_t)(v45 + v44);
    v52 = a1[v38 + 8];
    v53 = *(_DWORD *)((char *)&v75[4] + v38 * 4);
    v54 = v40 - v41;
    v55 = v53 + v52;
    v56 = v52 - v53;
    v57 = a1[v38 + 32];
    v58 = v42 - v43;
    v59 = a1[v38 + 56];
    v60 = v59 + v57;
    v61 = v57 - v59;
    v62 = v46 - v47;
    v63 = v55 - (uint64_t)v60;
    *v39 = (unint64_t)(7282 * (v50 + v55 + v60 + v48) + 0x2000) >> 14;
    v39[48] = (unint64_t)(7282 * (v49 - (v63 + v51)) + 0x2000) >> 14;
    v64 = v48 - v50;
    v65 = v54;
    v39[32] = (unint64_t)(8918 * v64 + 0x2000) >> 14;
    v66 = v44 - v45;
    v39[16] = (unint64_t)(9947 * (v49 + v51) + 7282 * (v63 - v51) + 0x2000) >> 14;
    v67 = 3941 * (v61 + (uint64_t)v56);
    v68 = v67 + 5573 * v56;
    v69 = v67 - 13455 * v61;
    v70 = v58 + (uint64_t)v54;
    v71 = 6269 * (v66 + v54);
    v72 = 8170 * v70 + 0x2000;
    v39[8] = (unint64_t)(v72 + 0x3FFFFFFFEF7BLL * v65 + v71 + v68 + 1344 * v62) >> 14;
    result = v62 + (uint64_t)v58;
    v39[24] = (unint64_t)(v69 + 9514 * (v65 - v66) + 0x3FFFFFFFF09BLL * result + 0x2000) >> 14;
    v39[40] = (unint64_t)(v72 - 17036 * v58 - 1344 * (v66 + v58) - v69 + 6269 * v62) >> 14;
    v39[56] = (unint64_t)(v71 + 5285 * v66 - 1344 * (v66 + v58) - v68 + 0x3FFFFFFFE016 * v62 + 0x2000) >> 14;
    ++v38;
  }
  while ((_DWORD)(v38 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_13x13(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _DWORD *v39;
  int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t result;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _DWORD *v87;
  uint64_t v88;
  uint64_t v90;
  _OWORD v91[10];
  uint64_t v92;

  v3 = 0;
  v92 = *MEMORY[0x1E0C80C00];
  memset(v91, 0, sizeof(v91));
  v87 = a1;
  v88 = a3;
  while (1)
  {
    v90 = v3;
    v4 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + v88);
    v5 = *v4;
    v6 = v4[12];
    v7 = v4[1];
    v8 = v4[6];
    v9 = v6 + v5 - 2 * v8;
    v10 = v4[11];
    v11 = v10 + v7;
    v12 = v10 + v7 - 2 * v8;
    v13 = v4[2];
    v14 = v4[10];
    v15 = v14 + v13 - 2 * v8;
    v16 = v4[3];
    v17 = v4[9];
    v18 = (v17 + v16);
    v19 = v18 - 2 * v4[6];
    v20 = v4[4];
    v21 = v4[8];
    v22 = (v21 + v20);
    v23 = v22 - 2 * v4[6];
    v24 = v4[5];
    v25 = v4[7];
    v26 = (v25 + v24);
    v27 = v26 - 2 * v4[6];
    v28 = 11249 * v9
        + 8672 * v12
        + 4108 * v15
        + 0x1FFFFFFFFA8CLL * v19
        + 0x1FFFFFFFE64BLL * v23
        + 0x1FFFFFFFD7EELL * v27;
    v29 = v7 - v10;
    v30 = 9465 * (v9 - v15) - 3570 * ((int)v19 - (int)v23) - 2592 * (v12 - (int)v27);
    v31 = v20 - v21;
    v32 = 793 * (v9 + v15) - 7678 * ((int)v19 + (int)v23) + 3989 * (v12 + (int)v27);
    v33 = 7682 * (v16 - v17 + (int)v5 - (int)v6) + 2773 * ((int)v24 - (int)v25 + (int)v31);
    v34 = -2773 * (v13 - v14 + v29) + 7682 * ((int)v31 - ((int)v24 - (int)v25));
    v35 = 10832 * (v29 + (int)v5 - (int)v6) + 4096;
    v36 = v13 - v14 + v5 - v6;
    *a1 = v26 + v11 + v6 + v5 + v14 + v13 + v18 + v22 + v8 - 1664;
    a1[1] = (unint64_t)(v35 + 0x1FFFFFFFBF5BLL * (v5 - v6) + 9534 * v36 + 2611 * (int)v31 + v33) >> 13;
    v37 = v35 + 6859 * v29;
    LODWORD(v35) = v16 - v17 + v29;
    a1[2] = (unint64_t)(v28 + 4096) >> 13;
    a1[3] = (unint64_t)(v37 - 9534 * (int)v35 + 0x1FFFFFFFB511 * v31 + v34) >> 13;
    LODWORD(v31) = v16 - v17 + v13 - v14;
    a1[4] = (unint64_t)(v32 + v30 + 4096) >> 13;
    a1[5] = (unint64_t)(-12879 * (v13 - v14)
                             + 9534 * v36
                             - 5384 * (int)v31
                             + 18515 * ((int)v24 - (int)v25)
                             + v34
                             + 4096) >> 13;
    a1[6] = (unint64_t)(v30 - v32 + 4096) >> 13;
    a1[7] = (unint64_t)(18068 * (v16 - v17)
                             - 5384 * (int)v31
                             - 9534 * (int)v35
                             + 0x1FFFFFFFC83FLL * (v24 - v25)
                             + v33
                             + 4096) >> 13;
    if ((_DWORD)v90 != 7)
      break;
    a1 = v91;
LABEL_6:
    v3 = v90 + 1;
  }
  if ((_DWORD)v90 != 12)
  {
    a1 += 8;
    goto LABEL_6;
  }
  v38 = 0;
  do
  {
    v39 = &v87[v38];
    v40 = v87[v38];
    v41 = *(_DWORD *)((char *)&v91[8] + v38 * 4);
    v42 = v41 + v40;
    v43 = v87[v38 + 8];
    v44 = *(_DWORD *)((char *)&v91[6] + v38 * 4);
    v45 = v44 + v43;
    v46 = v87[v38 + 16];
    v47 = *(_DWORD *)((char *)&v91[4] + v38 * 4);
    v48 = v87[v38 + 24];
    v49 = *(_DWORD *)((char *)&v91[2] + v38 * 4);
    v50 = v47 + v46;
    v51 = v49 + v48;
    v52 = v87[v38 + 32];
    v53 = *(_DWORD *)((char *)v91 + v38 * 4);
    v54 = v53 + v52;
    v55 = v40 - v41;
    v56 = v49 + v48;
    v57 = v87[v38 + 40];
    v58 = v43 - v44;
    v59 = v87[v38 + 56];
    v60 = v46 - v47;
    v61 = v48 - v49;
    v62 = v59 + v57;
    v63 = v52 - v53;
    v64 = (int)v87[v38 + 48];
    v65 = v57 - v59;
    v66 = v45 + v42 + v50;
    v67 = v42 - 2 * v64;
    v68 = v45 - 2 * v64;
    v69 = v50 - 2 * v64;
    v70 = v56 - 2 * v64;
    v71 = v54 - 2 * v64;
    v72 = v66 + v51 + v54;
    v73 = v62 - 2 * v64;
    v74 = 7169 * (v67 - v69) - 2704 * (v70 - v71) - 1963 * (v68 - v73);
    v75 = v55;
    *v39 = (unint64_t)(6205 * (v72 + v62 + v64) + 0x2000) >> 14;
    v76 = v67 + v69;
    v77 = 8520 * v67 + 6568 * v68 + 3112 * v69 + 0x3FFFFFFFFBDELL * v70;
    v78 = 601 * v76 - 5816 * (v70 + v71);
    v79 = v77 + 0x3FFFFFFFEC87 * v71;
    v80 = v78 + 3021 * (v68 + v73);
    v81 = 5819 * (v61 + (uint64_t)v55) + 2100 * (v65 + (uint64_t)v63);
    v82 = v80 + v74;
    result = v74 - v80;
    v84 = -2100 * (v60 + (uint64_t)v58) + 5819 * (v63 - (uint64_t)v65);
    v85 = 8204 * (v58 + (uint64_t)v55) + 0x2000;
    v86 = 7221 * (v60 + (uint64_t)v55);
    v39[8] = (unint64_t)(v85 + 0x3FFFFFFFCF0ALL * v75 + v86 + 1978 * v63 + v81) >> 14;
    v39[32] = (unint64_t)(v82 + 0x2000) >> 14;
    v39[24] = (unint64_t)(v85 + 5195 * v58 - 7221 * (v61 + (uint64_t)v58) + 0x3FFFFFFFC73FLL * v63 + v84) >> 14;
    v39[48] = (unint64_t)(result + 0x2000) >> 14;
    v39[40] = (unint64_t)(v86 - 9754 * v60 - 4078 * (v61 + (uint64_t)v60) + 14023 * v65 + v84 + 0x2000) >> 14;
    v39[16] = (unint64_t)(v79 + 0x3FFFFFFFE1A6 * v73 + 0x2000) >> 14;
    v39[56] = (unint64_t)(-4078 * (v61 + (uint64_t)v60)
                               + 13685 * v61
                               - 7221 * (v61 + (uint64_t)v58)
                               + 0x3FFFFFFFD5C5 * v65
                               + v81
                               + 0x2000) >> 14;
    ++v38;
  }
  while ((_DWORD)(v38 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_14x14(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t result;
  uint64_t v79;
  _OWORD v81[12];
  uint64_t v82;

  v3 = 0;
  v82 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  v5 = a1;
  memset(v81, 0, sizeof(v81));
  while (1)
  {
    v6 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + v4);
    v7 = *v6;
    v8 = v6[13];
    v9 = v6[1];
    v10 = v6[12];
    v11 = (v10 + v9);
    v12 = v6[2];
    v13 = v6[11];
    v14 = (v13 + v12);
    v15 = v6[4];
    v16 = v6[9];
    v17 = (v16 + v15);
    v18 = v6[5];
    v19 = v6[8];
    v20 = (v19 + v18);
    v21 = v6[6];
    v22 = v6[7];
    v23 = v22 + v21 + v8 + v7;
    v24 = v8 + v7 - (v22 + v21);
    v25 = v20 + v11;
    v26 = v11 - v20;
    v27 = v17 + v14;
    v28 = v14 - v17;
    v29 = v7 - v8;
    v30 = v9 - v10;
    v31 = v6[3];
    v32 = v6[10];
    v33 = v12 - v13;
    LODWORD(v13) = v32 + v31;
    v34 = v31 - v32;
    LODWORD(v32) = v15 - v16;
    v35 = v18 - v19;
    v36 = 9058 * (v24 + (int)v26) + 4096;
    v37 = v36 + 5027 * (int)v28 + 2237 * v24;
    LODWORD(v18) = v18 - v19 - v32;
    v5[6] = (unint64_t)(v36 + 0x1FFFFFFFD3E1 * v28 + 0x1FFFFFFFC8FCLL * v26) >> 13;
    v5[7] = v29 + v34 - (v21 - v22) - (v33 + v30 + v18);
    v38 = 9810 * ((int)v33 + (int)v29) + 6164 * ((int)v21 - (int)v22 + (int)v32);
    v39 = 11512 * (int)v18 - (v34 << 13) - 1297 * ((int)v33 + (int)v30) + 4096;
    v5[4] = (0x1FFFFFFFE3C9 * (v27 - (unint64_t)(2 * v13))
           + 2578 * (v25 - 2 * (int)v13)
           + 10438 * (v23 - 2 * (int)v13)
           + 4096) >> 13;
    v5[5] = (unint64_t)(v39 + 0x1FFFFFFFB409 * v33 + 9175 * (int)v32 + v38) >> 13;
    v40 = 10935 * ((int)v30 + (int)v29) + 3826 * ((int)v35 - ((int)v21 - (int)v22));
    v5[2] = v37 >> 13;
    v5[3] = (unint64_t)(v39 + 0x1FFFFFFFF26ELL * v30 + 0x1FFFFFFF9DC4 * v35 + v40) >> 13;
    *v5 = v13 + v25 + v27 + v23 - 1792;
    v5[1] = (unint64_t)(v40 + (v34 << 13) + v21 - v22 + 0x1FFFFFFFDBF0 * (v21 - v22 + v29) + v38 + 4096) >> 13;
    if ((_DWORD)v3 != 7)
      break;
    v5 = v81;
LABEL_6:
    ++v3;
  }
  if ((_DWORD)v3 != 13)
  {
    v5 += 8;
    goto LABEL_6;
  }
  v41 = 0;
  do
  {
    v42 = &a1[v41];
    v43 = a1[v41];
    v44 = *(_DWORD *)((char *)&v81[10] + v41 * 4);
    v45 = a1[v41 + 8];
    v46 = *(_DWORD *)((char *)&v81[8] + v41 * 4);
    v47 = a1[v41 + 16];
    v48 = *(_DWORD *)((char *)&v81[6] + v41 * 4);
    v49 = a1[v41 + 24];
    v50 = *(_DWORD *)((char *)&v81[4] + v41 * 4);
    v51 = a1[v41 + 40];
    v52 = v48 + v47;
    v53 = a1[v41 + 48];
    v54 = a1[v41 + 56];
    v55 = v54 + v53 + (uint64_t)(v44 + v43);
    v56 = v44 + v43 - (uint64_t)(v54 + v53);
    v57 = *(_DWORD *)((char *)v81 + v41 * 4) + v51;
    v58 = v43 - v44;
    v59 = v57 + (uint64_t)(v46 + v45);
    v60 = v46 + v45;
    v61 = v45 - v46;
    v62 = v50 + v49;
    v63 = v47 - v48;
    v64 = a1[v41 + 32];
    v65 = *(_DWORD *)((char *)&v81[2] + v41 * 4);
    v66 = v60 - v57;
    v67 = v49 - v50;
    v68 = v65 + v64 + (uint64_t)v52;
    v69 = v52 - (uint64_t)(v65 + v64);
    LODWORD(v60) = v64 - v65;
    v70 = v51 - *(_DWORD *)((char *)v81 + v41 * 4);
    *v42 = (unint64_t)(5350 * (v68 + v62 + v59 + v55) + 0x2000) >> 14;
    v71 = 5915 * (v56 + v66) + 0x2000;
    v42[16] = (unint64_t)(v71 + 3283 * v69 + 1461 * v56) >> 14;
    v72 = (unint64_t)(v71 + 0x3FFFFFFFE330 * v69 + 0x3FFFFFFFDC12 * v66) >> 14;
    v73 = v63 + (uint64_t)v61;
    v42[48] = v72;
    v74 = v70 - (uint64_t)(v64 - v65);
    v42[56] = (unint64_t)(5350 * (v58 + (uint64_t)v67 - (v73 + v74 + v53 - v54)) + 0x2000) >> 14;
    v75 = 7518 * v74 - 5350 * v67 - 847 * v73 + 0x2000;
    v76 = v75 + 0x3FFFFFFFCE64 * v63;
    v42[32] = (unint64_t)(1684 * (v59 - 2 * v62)
                               + 0x3FFFFFFFED93 * (v68 - 2 * v62)
                               + 6817 * (v55 - 2 * v62)
                               + 0x2000) >> 14;
    v77 = v75 + 0x3FFFFFFFF723 * v61;
    result = 7141 * (v61 + (uint64_t)v58) + 2499 * (v70 - (uint64_t)(v53 - v54));
    v79 = 6406 * (v63 + (uint64_t)v58) + 4025 * (v53 - v54 + (uint64_t)(int)v60);
    v42[40] = (unint64_t)(v76 + 5992 * (int)v60 + v79) >> 14;
    v42[24] = (unint64_t)(v77 + 0x3FFFFFFFBFD9 * v70 + result) >> 14;
    v42[8] = (unint64_t)(result
                              + 0x3FFFFFFFE873 * v58
                              + 5350 * v67
                              + 0x3FFFFFFFFD59 * (v53 - v54)
                              + v79
                              + 0x2000) >> 14;
    ++v41;
  }
  while ((_DWORD)(v41 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_15x15(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t result;
  uint64_t v81;
  uint64_t v82;
  uint64_t v84;
  _OWORD v86[14];
  uint64_t v87;

  v3 = 0;
  v87 = *MEMORY[0x1E0C80C00];
  v84 = a3;
  v4 = a1;
  memset(v86, 0, sizeof(v86));
  while (1)
  {
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + v84);
    v6 = *v5;
    v7 = v5[14];
    v8 = (v7 + v6);
    v9 = v5[1];
    v10 = v5[13];
    v11 = (v10 + v9);
    v12 = v5[2];
    v13 = v5[12];
    v14 = (v13 + v12);
    v15 = v5[3];
    v16 = v5[11];
    v17 = (v16 + v15);
    v18 = v5[4];
    v19 = v5[10];
    v20 = (v19 + v18);
    v21 = v5[5];
    v22 = v5[9];
    v23 = (v22 + v21);
    v24 = v6 - v7;
    v25 = v5[6];
    v26 = v9 - v10;
    v27 = v5[8];
    v28 = (v27 + v25);
    v29 = v5[7];
    v30 = v15 - v16;
    v31 = v25 - v27;
    v32 = v20 + v8 + v23;
    v33 = v17 + v11 + v28;
    LODWORD(v27) = v29 + v14 + v32 + v33;
    v34 = 0x1FFFFFFFF204 * (v33 - 2 * (v29 + v14)) + 9373 * (v32 - 2 * (v29 + v14));
    v35 = v14 - 2 * v29 + ((unint64_t)(v20 + v11) >> 1);
    v36 = v28 - v35;
    v37 = 11332 * ((int)v8 - (int)v17) + 6476 * ((int)v11 - (int)v20) + 7752 * ((int)v28 - (int)v23) + 4096;
    v38 = v37 + 12543 * (v17 - v35) + 0x1FFFFFFFB860 * v36;
    v39 = v37 + 6541 * (v23 - v35) + 0x1FFFFFFFFD14 * (v8 - v35);
    v40 = 11018 * ((int)v18 - (int)v19 + v26)
        + 4712 * ((int)v21 - (int)v22 + (int)v30)
        + 11522 * ((int)v24 - (int)v31);
    *v4 = v27 - 1920;
    v4[1] = (unint64_t)(3897 * (int)v30
                             + 10033 * ((int)v12 - (int)v13)
                             + 0x1FFFFFFFEF8FLL * (v18 - v19)
                             + 13930 * (int)v31
                             + v40
                             + 4096) >> 13;
    v4[2] = v38 >> 13;
    v4[3] = (unint64_t)(6810 * (v26 - ((int)v30 + (int)v31))
                             + 11018 * ((int)v24 - ((int)v18 - (int)v19 + (int)v21 - (int)v22))
                             + 4096) >> 13;
    v4[4] = v39 >> 13;
    v4[5] = (unint64_t)(10033 * (v24 - (v12 - v13 + v30) + v21 - v22 + v31) + 4096) >> 13;
    v4[6] = (unint64_t)(v34 + 4096) >> 13;
    v4[7] = (unint64_t)(-17828 * v26
                             - 2912 * (int)v24
                             - 10033 * ((int)v12 - (int)v13)
                             + 0x1FFFFFFFE42FLL * (v21 - v22)
                             + v40
                             + 4096) >> 13;
    if ((_DWORD)v3 != 7)
      break;
    v4 = v86;
LABEL_6:
    ++v3;
  }
  if ((_DWORD)v3 != 14)
  {
    v4 += 8;
    goto LABEL_6;
  }
  v41 = 0;
  do
  {
    v42 = &a1[v41];
    v43 = a1[v41];
    v44 = *(_DWORD *)((char *)&v86[12] + v41 * 4);
    v45 = v44 + v43;
    v46 = a1[v41 + 8];
    v47 = *(_DWORD *)((char *)&v86[10] + v41 * 4);
    v48 = v47 + v46;
    v49 = a1[v41 + 16];
    v50 = *(_DWORD *)((char *)&v86[8] + v41 * 4);
    v51 = v50 + v49;
    v52 = a1[v41 + 24];
    v53 = *(_DWORD *)((char *)&v86[6] + v41 * 4);
    v54 = a1[v41 + 32];
    v55 = *(_DWORD *)((char *)&v86[4] + v41 * 4);
    v56 = v55 + v54;
    v57 = a1[v41 + 40];
    v58 = *(_DWORD *)((char *)&v86[2] + v41 * 4);
    v59 = a1[v41 + 48];
    v60 = *(_DWORD *)((char *)v86 + v41 * 4);
    v61 = v53 + v52;
    v62 = v43 - v44;
    v63 = v60 + v59;
    v64 = v46 - v47;
    v65 = (int)a1[v41 + 56];
    v66 = v49 - v50;
    v67 = v55 + v54;
    v68 = v52 - v53;
    v69 = v54 - v55;
    v70 = v59 - v60;
    v71 = v67 + v45 + v58 + v57;
    v72 = v61 + v48 + v63;
    v73 = v65 + v51;
    *v42 = (unint64_t)(9321 * (v72 + v71 + v73) + 0x4000) >> 15;
    v42[48] = (unint64_t)(0x7FFFFFFFF017 * (v72 - 2 * v73) + 10664 * (v71 - 2 * v73) + 0x4000) >> 15;
    v74 = v51 - 2 * v65 + ((v67 + v48) >> 1);
    v75 = v58 + v57 - v74;
    v76 = v45 - v74;
    v77 = 12893 * (v45 - v61) + 7369 * (v48 - (uint64_t)v56) + 8820 * (v63 - (uint64_t)(v58 + v57)) + 0x4000;
    v78 = v77 + 14271 * (v61 - v74) + 0x7FFFFFFFAE82 * (v63 - v74);
    v79 = v77 + 7442 * v75 + 0x7FFFFFFFFCACLL * v76;
    result = 4434 * v68 + 11415 * v66 + 0x7FFFFFFFED4CLL * v69;
    v81 = v57 - v58;
    v82 = 12536 * (v69 + (uint64_t)v64) + 5361 * (v81 + v68) + 13109 * (v62 - (uint64_t)v70);
    v42[8] = (unint64_t)(result + 15850 * v70 + v82 + 0x4000) >> 15;
    v42[24] = (unint64_t)(7748 * (v64 - (v68 + (uint64_t)v70)) + 12536 * (v62 - (v69 + v81)) + 0x4000) >> 15;
    v42[40] = (unint64_t)(11415 * (v62 - (v66 + (uint64_t)v68) + v81 + v70) + 0x4000) >> 15;
    v42[16] = v78 >> 15;
    v42[32] = v79 >> 15;
    v42[56] = (unint64_t)(-20284 * v64 - 3314 * v62 - 11415 * v66 + 0x7FFFFFFFE05ALL * v81 + v82 + 0x4000) >> 15;
    ++v41;
  }
  while ((_DWORD)(v41 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_16x16(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  _DWORD *v3;
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _DWORD *v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t result;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v81;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _OWORD v87[16];
  uint64_t v88;

  v3 = a1;
  v4 = 0;
  v88 = *MEMORY[0x1E0C80C00];
  v81 = a3;
  memset(v87, 0, sizeof(v87));
  while (1)
  {
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v4) + v81);
    v84 = *v5;
    v85 = v5[15];
    v86 = v4;
    v6 = (v85 + v84);
    v83 = v5[1];
    v7 = v5[14];
    v8 = v5[2];
    v9 = v5[13];
    v10 = v5[3];
    v11 = v5[12];
    v12 = (v11 + v10);
    v13 = v5[4];
    v14 = v5[11];
    v15 = (v14 + v13);
    v16 = v5[5];
    v17 = v5[10];
    v18 = v5[6];
    v19 = v5[7];
    v20 = v5[8];
    v21 = (v20 + v19);
    v22 = v21 + v6;
    v23 = v5[9];
    LODWORD(v5) = v23 + v18 + v7 + v83;
    v24 = v17 + v16 + v9 + v8;
    v25 = 10703 * ((int)v21 + (int)v6 - ((int)v15 + (int)v12)) + 4433 * ((int)v5 - v24);
    v26 = v6 - v21;
    v27 = v7 + v83 - (v23 + v18);
    v28 = v9 + v8 - (v17 + v16);
    LODWORD(v6) = v83 - v7;
    v29 = v8 - v9;
    v30 = 2260 * ((int)v12 - (int)v15 - v27) + 11363 * ((int)v26 - v28) + 1024;
    v31 = v30 + 17799 * v28 + 11893 * v27;
    v32 = v10 - v11;
    v33 = v18 - v23;
    v34 = v24 + v15 + v12 + (_DWORD)v5 + v22;
    v35 = v30 + 0x7FFFFFFDE07 * (v12 - v15) + 0x7FFFFFFF93ELL * v26;
    v36 = 11086 * ((int)v6 + (int)v84 - (int)v85) + 3363 * ((int)v33 - (v19 - v20));
    v37 = 10217 * (v29 + (int)v84 - (int)v85) + 5461 * (v19 - v20 + v16 - v17);
    v38 = 8956 * (v10 - v11 + (int)v84 - (int)v85) + 7350 * (v13 - v14 - (v19 - v20));
    v39 = 1136 * (v29 + (int)v6) + 11529 * ((int)v33 - (v16 - v17));
    v40 = -5461 * (v10 - v11 + (int)v6) - 10217 * ((int)v33 + v13 - v14);
    v41 = -11086 * (v10 - v11 + v29) + 3363 * (v16 - v17 - (v13 - v14));
    *v3 = 4 * v34 - 0x2000;
    v3[1] = (unint64_t)(v37 + 0x7FFFFFFB6D6 * (v84 - v85) + 6387 * (v19 - v20) + v36 + v38 + 1024) >> 11;
    v3[2] = v31 >> 11;
    v3[3] = (unint64_t)(v40 + 589 * (int)v6 + 0x7FFFFFFCAC1 * v33 + v39 + v36 + 1024) >> 11;
    v3[4] = (unint64_t)(v25 + 1024) >> 11;
    v3[5] = (unint64_t)(v41 + 1024 - 9222 * v29 + 10055 * (v16 - v17) + v39 + v37) >> 11;
    v3[6] = v35 >> 11;
    v3[7] = (unint64_t)(v41 + 1024 + 8728 * v32 + 17760 * (v13 - v14) + v40 + v38) >> 11;
    if ((_DWORD)v86 != 7)
      break;
    v3 = v87;
LABEL_6:
    v4 = v86 + 1;
  }
  if ((_DWORD)v86 != 15)
  {
    v3 += 8;
    goto LABEL_6;
  }
  v42 = 0;
  do
  {
    v43 = &a1[v42];
    v44 = a1[v42];
    v45 = *(_DWORD *)((char *)&v87[14] + v42 * 4);
    v46 = a1[v42 + 8];
    v47 = *(_DWORD *)((char *)&v87[12] + v42 * 4);
    v48 = a1[v42 + 16];
    v49 = *(_DWORD *)((char *)&v87[10] + v42 * 4);
    v50 = a1[v42 + 24];
    v51 = *(_DWORD *)((char *)&v87[8] + v42 * 4);
    v52 = a1[v42 + 32];
    v53 = a1[v42 + 40];
    v54 = *(_DWORD *)((char *)&v87[4] + v42 * 4);
    v55 = a1[v42 + 48];
    v56 = *(_DWORD *)((char *)&v87[2] + v42 * 4);
    v57 = a1[v42 + 56];
    v58 = *(_DWORD *)((char *)v87 + v42 * 4);
    v59 = v58 + v57 + (uint64_t)(v45 + v44);
    v60 = v45 + v44 - (uint64_t)(v58 + v57);
    v61 = v56 + v55 + (uint64_t)(v47 + v46);
    v62 = *(_DWORD *)((char *)&v87[6] + v42 * 4);
    v63 = v47 + v46 - (uint64_t)(v56 + v55);
    v64 = v54 + v53 + (uint64_t)(v49 + v48);
    v65 = v49 + v48 - (uint64_t)(v54 + v53);
    v66 = v62 + v52 + (uint64_t)(v51 + v50);
    v67 = v51 + v50 - (uint64_t)(v62 + v52);
    v68 = v44 - v45;
    v69 = v46 - v47;
    v70 = v48 - v49;
    v71 = v50 - v51;
    *v43 = (unint64_t)(v66 + v64 + v61 + v59 + 8) >> 4;
    v43[32] = (unint64_t)(10703 * (v59 - v66) + 4433 * (v61 - v64) + 0x10000) >> 17;
    v72 = 2260 * (v67 - v63) + 11363 * (v60 - v65) + 0x10000;
    v43[16] = (unint64_t)(v72 + 17799 * v65 + 11893 * v63) >> 17;
    v73 = v55 - v56;
    v43[48] = (unint64_t)(v72 + 0x1FFFFFFFFDE07 * v67 + 0x1FFFFFFFFF93ELL * v60) >> 17;
    result = 11086 * (v46 - v47 + (uint64_t)v68) + 3363 * (v73 - (v57 - v58));
    v75 = 10217 * (v70 + (uint64_t)v68) + 5461 * (v57 - v58 + (uint64_t)(v53 - v54));
    v76 = 8956 * (v71 + (uint64_t)v68) + 7350 * (v52 - v62 - (uint64_t)(v57 - v58));
    v77 = 1136 * (v70 + (uint64_t)v69) + 11529 * (v73 - (v53 - v54));
    v78 = -5461 * (v71 + (uint64_t)v69) - 10217 * (v73 + v52 - v62);
    v79 = -11086 * (v71 + (uint64_t)v70) + 3363 * (v53 - v54 - (uint64_t)(v52 - v62));
    v43[8] = (unint64_t)(v75 + 0x1FFFFFFFFB6D6 * v68 + 6387 * (v57 - v58) + result + v76 + 0x10000) >> 17;
    v43[24] = (unint64_t)(v78 + 589 * v69 + 0x1FFFFFFFFCAC1 * v73 + v77 + result + 0x10000) >> 17;
    v43[40] = (unint64_t)(v79 + 0x10000 - 9222 * v70 + 10055 * (v53 - v54) + v77 + v75) >> 17;
    v43[56] = (unint64_t)(v79 + 0x10000 + 8728 * v71 + 17760 * (v52 - v62) + v78 + v76) >> 17;
    ++v42;
  }
  while ((_DWORD)(v42 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_16x8(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _DWORD *v50;
  uint64_t v51;
  _DWORD *v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;

  v3 = 0;
  v4 = a3;
  do
  {
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3) + v4);
    v6 = *v5;
    v7 = v5[15];
    v8 = (v7 + v6);
    v9 = v5[1];
    v10 = v5[14];
    v11 = v5[2];
    v12 = v5[13];
    v13 = v5[3];
    v14 = v5[5];
    v15 = v5[10];
    v16 = v5[6];
    v17 = v5[9];
    v18 = v5[7];
    v19 = v5[8];
    v20 = (v19 + v18);
    v21 = v20 + v8;
    v22 = v8 - v20;
    v23 = v17 + v16 + v10 + v9;
    v24 = v10 + v9 - (v17 + v16);
    v25 = v15 + v14 + v12 + v11;
    v26 = v12 + v11 - (v15 + v14);
    LODWORD(v8) = v5[12];
    v27 = v6 - v7;
    v28 = v5[4];
    LODWORD(v7) = v9 - v10;
    v29 = (v8 + v13);
    v30 = v5[11];
    LODWORD(v6) = v11 - v12;
    v31 = (v30 + v28);
    LODWORD(v5) = v13 - v8;
    v32 = v29 - v31;
    LODWORD(v29) = v31 + v29;
    v33 = v16 - v17;
    v34 = v18 - v19;
    v35 = 11086 * ((int)v7 + (int)v27) + 3363 * ((int)v16 - (int)v17 - v34);
    v36 = v28 - v30;
    LODWORD(v31) = v14 - v15;
    v37 = 10703 * (v21 - (int)v29) + 4433 * (v23 - v25);
    v38 = v25 + v29 + v23 + v21;
    v39 = 2260 * ((int)v32 - v24) + 11363 * ((int)v22 - v26) + 1024;
    v40 = v39 + 17799 * v26;
    v41 = 10217 * ((int)v6 + (int)v27) + 5461 * (v34 + (int)v31);
    v42 = 8956 * ((int)v5 + (int)v27) + 7350 * (v36 - v34);
    v43 = v39 + 0x7FFFFFFDE07 * v32;
    v44 = 1136 * ((int)v6 + (int)v7) + 11529 * ((int)v33 - (int)v31);
    v45 = v40 + 11893 * v24;
    v46 = -5461 * ((int)v5 + (int)v7) - 10217 * ((int)v33 + v36);
    v47 = v41 + 0x7FFFFFFB6D6 * v27 + 6387 * v34 + v35 + v42;
    v48 = v46 + 589 * (int)v7 + 0x7FFFFFFCAC1 * v33 + v44 + v35;
    v49 = -11086 * ((int)v5 + (int)v6) + 3363 * ((int)v31 - v36) + 1024;
    v50 = (_DWORD *)(result + 4 * v3);
    v50[4] = (unint64_t)(v37 + 1024) >> 11;
    v50[5] = (unint64_t)(v49 - 9222 * (int)v6 + 10055 * (int)v31 + v44 + v41) >> 11;
    *v50 = 4 * v38 - 0x2000;
    v50[1] = (unint64_t)(v47 + 1024) >> 11;
    v50[2] = v45 >> 11;
    v50[3] = (unint64_t)(v48 + 1024) >> 11;
    v50[6] = (unint64_t)(v43 + 0x7FFFFFFF93ELL * v22) >> 11;
    v50[7] = (unint64_t)(v49 + 8728 * (int)v5 + 17760 * v36 + v46 + v42) >> 11;
    v3 += 8;
  }
  while (v3 != 64);
  v51 = 0;
  do
  {
    v52 = (_DWORD *)(result + v51);
    v53 = *(_DWORD *)(result + v51);
    v54 = *(_DWORD *)(result + v51 + 224);
    v55 = *(_DWORD *)(result + v51 + 32);
    v56 = *(_DWORD *)(result + v51 + 192);
    v57 = *(_DWORD *)(result + v51 + 64);
    v58 = *(_DWORD *)(result + v51 + 160);
    v59 = v58 + v57;
    v60 = *(_DWORD *)(result + v51 + 96);
    v61 = *(_DWORD *)(result + v51 + 128);
    v62 = v61 + v60 + (uint64_t)(v54 + v53);
    v63 = v54 + v53 - (uint64_t)(v61 + v60);
    v64 = v59 + v56 + v55;
    v65 = v56 + v55 - v59;
    v66 = v53 - v54;
    v67 = v60 - v61;
    *v52 = (unint64_t)(v64 + v62 + 4) >> 3;
    v52[32] = (unint64_t)(v62 - v64 + 4) >> 3;
    v68 = 4433 * (v63 + v65) + 0x8000;
    v52[16] = (unint64_t)(v68 + 6270 * v63) >> 16;
    v52[48] = (unint64_t)(v68 + 0xFFFFFFFFC4DFLL * v65) >> 16;
    v69 = v57 - v58 + (uint64_t)v66;
    v70 = v67 + v55 - v56;
    v71 = 9633 * (v70 + v69);
    v72 = v71 - 3196 * v69;
    v73 = v71 - 16069 * v70;
    v74 = -7373 * (v67 + v66) + 0x8000;
    v52[8] = (unint64_t)(v74 + 12299 * v66 + v72) >> 16;
    v75 = -20995 * (v57 - v58 + (uint64_t)(v55 - v56)) + 0x8000;
    v52[24] = (unint64_t)(v75 + 25172 * (v55 - v56) + v73) >> 16;
    v52[40] = (unint64_t)(v75 + 16819 * (v57 - v58) + v72) >> 16;
    v52[56] = (unint64_t)(v74 + 2446 * v67 + v73) >> 16;
    v51 += 4;
  }
  while ((_DWORD)v51 != 32);
  return result;
}

uint64_t jpeg_fdct_14x7(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  uint64_t v45;
  _DWORD *v46;
  int v47;
  int v48;
  uint64_t v49;
  int v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;

  v3 = 0;
  *(_OWORD *)(result + 224) = 0u;
  *(_OWORD *)(result + 240) = 0u;
  do
  {
    v4 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3) + a3);
    v5 = *v4;
    v6 = v4[13];
    v7 = v4[1];
    v8 = v4[12];
    v9 = v4[2];
    v10 = (v8 + v7);
    v11 = v4[11];
    v12 = (v11 + v9);
    v13 = v4[3];
    v14 = v4[5];
    v15 = v4[8];
    v16 = (v15 + v14);
    v17 = v4[6];
    v18 = v4[7];
    v19 = v18 + v17 + v6 + v5;
    v20 = v6 + v5 - (v18 + v17);
    v21 = v16 + v10;
    v22 = v10 - v16;
    v23 = v4[10];
    v24 = v5 - v6;
    LODWORD(v5) = v4[4];
    v25 = v7 - v8;
    v26 = v23 + v13;
    LODWORD(v4) = v4[9];
    v27 = v9 - v11;
    v28 = ((_DWORD)v4 + v5);
    v29 = v13 - v23;
    v30 = v28 + v12;
    v31 = v12 - v28;
    LODWORD(v4) = v5 - (_DWORD)v4;
    v32 = v14 - v15;
    v33 = v17 - v18;
    v34 = (2 * v26);
    LODWORD(v5) = v21 + v30 + v19;
    LODWORD(v15) = v19 - v34;
    v35 = 0x7FFFFFFE3C9 * (v30 - v34) + 2578 * (v21 - (int)v34);
    v36 = 9058 * (v20 + (int)v22) + 1024;
    v37 = v36 + 5027 * (int)v31;
    v38 = v35 + 10438 * (int)v15;
    v39 = v36 + 0x7FFFFFFD3E1 * v31;
    v40 = v37 + 2237 * v20;
    v41 = 9810 * ((int)v27 + (int)v24) + 6164 * ((int)v33 + (int)v4);
    v42 = 10935 * ((int)v25 + (int)v24) + 3826 * ((int)v32 - (int)v33);
    v43 = 11512 * ((int)v32 - (int)v4) - (v29 << 13) - 1297 * ((int)v27 + (int)v25) + 1024;
    v44 = (_DWORD *)(result + 4 * v3);
    v44[6] = (unint64_t)(v39 + 0x7FFFFFFC8FCLL * v22) >> 11;
    v44[7] = 4 * (v24 + v29 - v33 - (v27 + v25 + v32 - (_DWORD)v4));
    v44[4] = (unint64_t)(v38 + 1024) >> 11;
    v44[5] = (unint64_t)(v43 + 0x7FFFFFFB409 * v27 + 9175 * (int)v4 + v41) >> 11;
    v44[2] = v40 >> 11;
    v44[3] = (unint64_t)(v43 + 0x7FFFFFFF26ELL * v25 + 0x7FFFFFF9DC4 * v32 + v42) >> 11;
    *v44 = 4 * (v26 + v5) - 7168;
    v44[1] = (unint64_t)(v42 + (v29 << 13) + v33 + 0x7FFFFFFDBF0 * (v33 + v24) + v41 + 1024) >> 11;
    v3 += 8;
  }
  while (v3 != 56);
  v45 = 0;
  do
  {
    v46 = (_DWORD *)(result + v45);
    v47 = *(_DWORD *)(result + v45);
    v48 = *(_DWORD *)(result + v45 + 192);
    v49 = v48 + v47;
    v50 = *(_DWORD *)(result + v45 + 32);
    v51 = *(_DWORD *)(result + v45 + 160);
    v52 = v51 + v50;
    v53 = *(_DWORD *)(result + v45 + 64);
    v54 = *(_DWORD *)(result + v45 + 128);
    v55 = v54 + v53;
    v56 = v54 + v53;
    v57 = *(int *)(result + v45 + 96);
    v58 = v47 - v48;
    v59 = v50 - v51;
    v60 = v53 - v54;
    *v46 = (unint64_t)(10700 * (v57 + v52 + v56 + v49) + 0x8000) >> 16;
    v61 = 3783 * (v56 + v49 - 4 * v57);
    v62 = 9850 * (v49 - v55);
    v63 = 3367 * (v52 - v55);
    v46[16] = (unint64_t)(v63 + v62 + v61 + 0x8000) >> 16;
    v64 = 9434 * (v49 - v52) + 0x8000;
    v46[32] = (unint64_t)(v64 + v63 + 0xFFFFFFFFE272 * (v52 - 2 * v57)) >> 16;
    v46[48] = (unint64_t)(v64 - v62 + v61) >> 16;
    v65 = 10009 * (v59 + v58);
    v66 = 1822 * (v58 - v59);
    v67 = 6565 * (v60 + v58) + 0x8000;
    v46[8] = (unint64_t)(v67 - v66 + v65) >> 16;
    v46[24] = (unint64_t)(-14752 * (v60 + v59) + v66 + v65 + 0x8000) >> 16;
    v46[40] = (unint64_t)(v67 + 20017 * v60 - 14752 * (v60 + v59)) >> 16;
    v45 += 4;
  }
  while ((_DWORD)v45 != 32);
  return result;
}

_OWORD *jpeg_fdct_12x6(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  _DWORD *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  do
  {
    v4 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + a3);
    v5 = *v4;
    v6 = v4[11];
    v7 = v4[1];
    v8 = v4[2];
    v9 = v4[9];
    v10 = (v9 + v8);
    v11 = v4[3];
    v12 = v4[8];
    v13 = (v12 + v11);
    v14 = v4[5];
    v15 = v4[6];
    v16 = v15 + v14 + v6 + v5;
    v17 = v6 + v5 - (v15 + v14);
    v18 = v13 + v10;
    v19 = v10 - v13;
    v20 = v4[10];
    v21 = v5 - v6;
    v22 = (v20 + v7);
    v23 = v7 - v20;
    v24 = v8 - v9;
    LODWORD(v6) = v4[4];
    LODWORD(v4) = v4[7];
    v25 = ((_DWORD)v4 + v6);
    LODWORD(v9) = v6 - (_DWORD)v4;
    v26 = &result[v3];
    v27 = v14 - v15;
    v28 = v22 - v25;
    LODWORD(v8) = 4 * (v18 + v22 + v25 + v16) - 6144;
    LODWORD(v25) = v17 - (v22 - v25 + v19);
    LODWORD(v15) = v16 - v18;
    v29 = v28 - v19 + 11190 * (v17 + (int)v19);
    v30 = 6270 * v23 + 4433 * ((int)v9 + v23);
    v31 = -15137 * (int)v9 + 4433 * ((int)v9 + v23);
    LODWORD(v22) = v11 - v12 + v21;
    v32 = 9191 * ((int)v24 + (int)v21) + 1024;
    *v26 = v8;
    v26[1] = (unint64_t)(v32 + 0x7FFFFFFED6ALL * v21 + 7053 * (int)v22 + v30 + 1512 * (int)v27) >> 11;
    v26[2] = (unint64_t)(v29 + 1024) >> 11;
    v26[3] = (unint64_t)(v31 + 10703 * ((int)v21 - (v11 - v12)) + 0x7FFFFFFEEAFLL * (v27 + v24) + 1024) >> 11;
    v33 = v11 - v12 + v24;
    v26[4] = (unint64_t)(10033 * (int)v15 + 1024) >> 11;
    v26[5] = (unint64_t)(v32 - 19165 * (int)v24 - 1512 * v33 - v31 + 7053 * (int)v27) >> 11;
    v26[6] = 4 * v25;
    v26[7] = (unint64_t)(5946 * (v11 - v12)
                              + 7053 * (int)v22
                              - 1512 * v33
                              - v30
                              + 0x7FFFFFFDC19 * v27
                              + 1024) >> 11;
    v3 += 2;
  }
  while (v3 != 12);
  v34 = 0;
  do
  {
    v35 = (_DWORD *)((char *)result + v34);
    v36 = *(_DWORD *)((char *)result + v34);
    v37 = *(_DWORD *)((char *)result + v34 + 160);
    v38 = *(_DWORD *)((char *)result + v34 + 32);
    v39 = *(_DWORD *)((char *)result + v34 + 128);
    v40 = v39 + v38;
    v41 = *(_DWORD *)((char *)result + v34 + 64);
    v42 = *(_DWORD *)((char *)result + v34 + 96);
    v43 = v42 + v41 + (uint64_t)(v37 + v36);
    v44 = v37 + v36 - (uint64_t)(v42 + v41);
    v45 = v36 - v37;
    v46 = v38 - v39;
    v47 = v41 - v42;
    *v35 = (unint64_t)(14564 * (v43 + v40) + 0x8000) >> 16;
    v35[16] = (unint64_t)(17837 * v44 + 0x8000) >> 16;
    v35[32] = (unint64_t)(10298 * (v43 - 2 * v40) + 0x8000) >> 16;
    v48 = 5331 * (v47 + v45) + 0x8000;
    v35[8] = (unint64_t)(v48 + 14564 * (v46 + v45)) >> 16;
    v35[24] = (unint64_t)(14564 * (v45 - (v46 + v47)) + 0x8000) >> 16;
    v35[40] = (unint64_t)(v48 + 14564 * (v47 - v46)) >> 16;
    v34 += 4;
  }
  while ((_DWORD)v34 != 32);
  return result;
}

_OWORD *jpeg_fdct_10x5(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  do
  {
    v4 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + a3);
    v5 = *v4;
    v6 = v4[9];
    v7 = v4[1];
    v8 = v4[8];
    v9 = (v8 + v7);
    v10 = v4[3];
    v11 = v4[6];
    v12 = (v11 + v10);
    v13 = v4[4];
    v14 = v4[5];
    v15 = v14 + v13 + v6 + v5;
    v16 = v6 + v5 - (v14 + v13);
    v17 = v12 + v9;
    v18 = v9 - v12;
    v19 = v5 - v6;
    v20 = v4[2];
    v21 = v4[7];
    v22 = v7 - v8;
    LODWORD(v8) = v21 + v20;
    v23 = v20 - v21;
    v24 = &result[v3];
    v25 = v10 - v11;
    LODWORD(v12) = v8 + v15 + v17;
    v26 = (0x7FFFFFFF204 * (v17 - (unint64_t)(2 * v8)) + 9373 * (v15 - 2 * (int)v8) + 1024) >> 11;
    v27 = 6810 * (v16 + (int)v18) + 1024;
    LODWORD(v8) = v13 - v14 + v19;
    v24[4] = v26;
    v24[5] = 4 * (v8 - (v22 - v25 + v23));
    *v24 = 4 * v12 - 5120;
    v24[1] = (unint64_t)(10323 * (int)v22
                              + 11443 * v19
                              + (v23 << 13)
                              + 5260 * (int)v25
                              + 1812 * (v13 - v14)
                              + 1024) >> 11;
    v28 = 2531 * ((int)v8 + (int)v22 - (int)v25) - (v23 << 13) + ((v22 - v25) << 12);
    v29 = -4815 * ((int)v25 + (int)v22) + 7791 * (v19 - (v13 - v14)) + 1024;
    v24[2] = (unint64_t)(v27 + 4209 * v16) >> 11;
    v24[3] = (unint64_t)(v29 + v28) >> 11;
    v24[6] = (unint64_t)(v27 + 0x7FFFFFFBA5CLL * v18) >> 11;
    v24[7] = (unint64_t)(v29 - v28) >> 11;
    v3 += 2;
  }
  while (v3 != 10);
  v30 = 0;
  do
  {
    v31 = (_DWORD *)((char *)result + v30);
    v32 = *(_DWORD *)((char *)result + v30);
    v33 = *(_DWORD *)((char *)result + v30 + 128);
    v34 = *(_DWORD *)((char *)result + v30 + 32);
    v35 = *(_DWORD *)((char *)result + v30 + 96);
    v36 = v35 + v34;
    v37 = *(int *)((char *)result + v30 + 64);
    v38 = v36 + v33 + v32;
    v39 = v33 + v32 - v36;
    v40 = v32 - v33;
    v41 = v34 - v35;
    *v31 = (unint64_t)(10486 * (v38 + v37) + 0x4000) >> 15;
    v42 = 3707 * (v38 - 4 * v37);
    v43 = 8290 * v39 + 0x4000;
    v31[16] = (unint64_t)(v43 + v42) >> 15;
    v31[32] = (unint64_t)(v43 - v42) >> 15;
    v44 = 8716 * (v41 + v40) + 0x4000;
    v31[8] = (unint64_t)(v44 + 5387 * v40) >> 15;
    v31[24] = (unint64_t)(v44 + 0x7FFFFFFFA6DCLL * v41) >> 15;
    v30 += 4;
  }
  while ((_DWORD)v30 != 32);
  return result;
}

_OWORD *jpeg_fdct_8x4(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int64x2_t v29;
  int64x2_t v30;
  int32x4_t v31;
  _OWORD *v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int64x2_t v36;
  int32x4_t v37;
  int64x2_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t v41;
  int32x4_t v42;
  int64x2_t v43;
  int64x2_t v44;
  int64x2_t v45;
  int32x2_t v46;
  int64x2_t v47;
  int64x2_t v48;
  int64x2_t v49;
  int64x2_t v50;
  int64x2_t v51;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  do
  {
    v4 = &result[v3];
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + a3);
    v6 = *v5;
    v7 = v5[7];
    v8 = v5[1];
    v9 = v5[6];
    v10 = (v9 + v8);
    v11 = v5[2];
    v12 = v5[5];
    v13 = (v12 + v11);
    v14 = v5[3];
    LODWORD(v5) = v5[4];
    v15 = (_DWORD)v5 + v14 + v7 + v6;
    v16 = v7 + v6 - ((_DWORD)v5 + v14);
    v17 = v13 + v10;
    v18 = v10 - v13;
    v19 = v6 - v7;
    v20 = v8 - v9;
    v21 = v11 - v12;
    LODWORD(v5) = v14 - (_DWORD)v5;
    v22 = 4433 * (v16 + (int)v18) + 512;
    v23 = (unint64_t)(v22 + 6270 * v16) >> 10;
    v24 = (unint64_t)(v22 + 0x3FFFFFFC4DFLL * v18) >> 10;
    v25 = 9633 * ((int)v5 + v20 + v21 + v19) + 512;
    v26 = v25 - 3196 * (v21 + v19);
    v27 = v25 - 16069 * ((int)v5 + v20);
    *v4 = 8 * (v15 + v17) - 0x2000;
    v4[1] = (unint64_t)(12299 * v19 - 7373 * ((int)v5 + v19) + v26) >> 10;
    v4[2] = v23;
    v4[3] = (unint64_t)(25172 * v20 - 20995 * (v21 + v20) + v27) >> 10;
    v4[4] = 8 * (v15 - v17);
    v4[5] = (unint64_t)(16819 * v21 - 20995 * (v21 + v20) + v26) >> 10;
    v4[6] = v24;
    v4[7] = (unint64_t)(2446 * (int)v5 - 7373 * ((int)v5 + v19) + v27) >> 10;
    v3 += 2;
  }
  while (v3 != 8);
  v28 = 0;
  v29 = vdupq_n_s64(2uLL);
  v30 = vdupq_n_s64(0x4000uLL);
  v31 = vdupq_n_s32(0x187Eu);
  do
  {
    v32 = &result[v28];
    v33 = (int32x4_t)result[v28];
    v34 = (int32x4_t)result[v28 + 6];
    v35 = vaddq_s32(v34, v33);
    v36 = vaddw_s32(v29, *(int32x2_t *)v35.i8);
    v37 = (int32x4_t)result[v28 + 2];
    v38 = vaddw_high_s32(v29, v35);
    v39 = (int32x4_t)result[v28 + 4];
    v40 = vaddq_s32(v39, v37);
    v41 = vsubq_s32(v33, v34);
    v42 = vsubq_s32(v37, v39);
    v43.i64[0] = v42.i32[2];
    v43.i64[1] = v42.i32[3];
    v44 = v43;
    v43.i64[0] = v42.i32[0];
    v43.i64[1] = v42.i32[1];
    v45 = vaddw_high_s32(v38, v40);
    v46 = vshrn_n_s64(vaddw_s32(v36, *(int32x2_t *)v40.i8), 2uLL);
    v47 = (int64x2_t)vshrn_high_n_s64(vshrn_n_s64(vsubw_s32(v36, *(int32x2_t *)v40.i8), 2uLL), vsubw_high_s32(v38, v40), 2uLL);
    v48 = vaddl_high_s32(v42, v41);
    *v32 = vshrn_high_n_s64(v46, v45, 2uLL);
    v48.i64[0] *= 4433;
    v48.i64[1] *= 4433;
    v49 = vaddl_s32(*(int32x2_t *)v42.i8, *(int32x2_t *)v41.i8);
    v32[4] = v47;
    v49.i64[0] *= 4433;
    v49.i64[1] *= 4433;
    v47.i64[0] = 0x7FFFFFFFC4DFLL * v43.i64[0];
    v47.i64[1] = 0x7FFFFFFFC4DFLL * v43.i64[1];
    v50 = vaddq_s64(v49, v30);
    v51 = vaddq_s64(v48, v30);
    v44.i64[0] *= 0x7FFFFFFFC4DFLL;
    v44.i64[1] *= 0x7FFFFFFFC4DFLL;
    v32[2] = vshrn_high_n_s64(vshrn_n_s64(vmlal_s32(v50, *(int32x2_t *)v41.i8, *(int32x2_t *)v31.i8), 0xFuLL), vmlal_high_s32(v51, v41, v31), 0xFuLL);
    v32[6] = vshrn_high_n_s64(vshrn_n_s64(vaddq_s64(v50, v47), 0xFuLL), vaddq_s64(v51, v44), 0xFuLL);
    ++v28;
  }
  while (v28 != 2);
  return result;
}

_OWORD *jpeg_fdct_6x3(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  v4 = a3;
  result[2] = 0u;
  result[3] = 0u;
  *result = 0u;
  result[1] = 0u;
  do
  {
    v5 = (int *)&result[v3];
    v6 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + v4);
    v7 = *v6;
    v8 = v6[5];
    v9 = v6[1];
    v10 = v6[4];
    v11 = v10 + v9;
    v12 = v6[2];
    LODWORD(v6) = v6[3];
    v13 = (_DWORD)v6 + v12 + v8 + v7;
    v14 = v8 + v7 - ((_DWORD)v6 + v12);
    v15 = v7 - v8;
    v16 = v9 - v10;
    LODWORD(v6) = v12 - (_DWORD)v6;
    v17 = 8 * (v13 + v10 + v9) - 6144;
    v18 = (unint64_t)(5793 * (v13 - 2 * v11) + 512) >> 10;
    v19 = (unint64_t)(2998 * ((int)v6 + v15) + 512) >> 10;
    *v5 = v17;
    v5[1] = v19 + 8 * (v16 + v15);
    v5[2] = (10033 * v14 + 512) >> 10;
    v5[3] = 8 * (v15 - (v16 + (_DWORD)v6));
    v5[4] = v18;
    v5[5] = v19 + 8 * ((_DWORD)v6 - v16);
    v3 += 2;
  }
  while (v3 != 6);
  v20 = 0;
  do
  {
    v21 = (_DWORD *)((char *)result + v20);
    v22 = *(_DWORD *)((char *)result + v20);
    v23 = *(_DWORD *)((char *)result + v20 + 64);
    v24 = v23 + v22;
    v25 = *(int *)((char *)result + v20 + 32);
    *v21 = (unint64_t)(14564 * (v25 + v24) + 0x4000) >> 15;
    v21[16] = (unint64_t)(10298 * (v24 - 2 * v25) + 0x4000) >> 15;
    v21[8] = (unint64_t)(17837 * (v22 - v23) + 0x4000) >> 15;
    v20 += 4;
  }
  while ((_DWORD)v20 != 24);
  return result;
}

double jpeg_fdct_4x2(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  double result;
  unsigned __int8 *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;

  result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v4 = (unsigned __int8 *)(*a2 + a3);
  v5 = *v4;
  v6 = v4[3];
  v7 = v4[1];
  LODWORD(v4) = v4[2];
  v8 = (_DWORD)v4 + v7 + v6 + v5;
  v9 = v6 + v5 - ((_DWORD)v4 + v7);
  v10 = v5 - v6;
  LODWORD(v4) = v7 - (_DWORD)v4;
  v11 = 4433 * ((int)v4 + v10) + 512;
  v12 = v11 + 6270 * v10;
  v13 = v11 - 15137 * (int)v4;
  v14 = (unsigned __int8 *)(a2[1] + a3);
  LODWORD(v11) = *v14;
  v15 = v14[3];
  v16 = v14[1];
  LODWORD(v14) = v14[2];
  v17 = (_DWORD)v14 + v16 + v15 + v11;
  v18 = v15 + v11 - ((_DWORD)v14 + v16);
  LODWORD(v11) = v11 - v15;
  LODWORD(v14) = v16 - (_DWORD)v14;
  v19 = (_DWORD)v14 + v11;
  v20 = 6270 * (int)v11 + 4433 * ((int)v14 + (int)v11);
  v21 = -15137 * (int)v14 + 4433 * v19;
  *(_DWORD *)a1 = 8 * (v17 + v8) - 0x2000;
  *(_DWORD *)(a1 + 4) = (unint64_t)(v20 + v12) >> 10;
  *(_DWORD *)(a1 + 32) = 8 * (v8 - v17);
  *(_DWORD *)(a1 + 36) = (unint64_t)(v12 - v20) >> 10;
  *(_DWORD *)(a1 + 8) = 8 * (v18 + v9);
  *(_DWORD *)(a1 + 12) = (unint64_t)(v21 + v13) >> 10;
  *(_DWORD *)(a1 + 40) = 8 * (v9 - v18);
  *(_DWORD *)(a1 + 44) = (unint64_t)(v13 - v21) >> 10;
  return result;
}

double jpeg_fdct_2x1(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  double result;
  unsigned __int8 *v4;
  int v5;

  result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v4 = (unsigned __int8 *)(*a2 + a3);
  v5 = *v4;
  LODWORD(v4) = v4[1];
  *(_DWORD *)a1 = 32 * ((_DWORD)v4 + v5) - 0x2000;
  *(_DWORD *)(a1 + 4) = 32 * (v5 - (_DWORD)v4);
  return result;
}

uint64_t jpeg_fdct_8x16(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  _DWORD *v3;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t result;
  uint64_t v65;
  uint64_t v66;
  _OWORD v68[16];
  uint64_t v69;

  v3 = a1;
  v4 = 0;
  v69 = *MEMORY[0x1E0C80C00];
  memset(v68, 0, sizeof(v68));
  while (1)
  {
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v4) + a3);
    v6 = *v5;
    v7 = v5[7];
    v8 = v5[1];
    v9 = v5[6];
    v10 = (v9 + v8);
    v11 = v5[2];
    v12 = v5[5];
    v13 = (v12 + v11);
    v14 = v5[3];
    LODWORD(v5) = v5[4];
    v15 = (_DWORD)v5 + v14 + v7 + v6;
    v16 = v7 + v6 - ((_DWORD)v5 + v14);
    v17 = v13 + v10;
    v18 = v10 - v13;
    v19 = v6 - v7;
    v20 = v8 - v9;
    v21 = v11 - v12;
    LODWORD(v5) = v14 - (_DWORD)v5;
    v22 = 4433 * (v16 + (int)v18) + 1024;
    v23 = (unint64_t)(v22 + 6270 * v16) >> 11;
    v24 = (unint64_t)(v22 + 0x7FFFFFFC4DFLL * v18) >> 11;
    LODWORD(v13) = (_DWORD)v5 + v20 + v21 + v19;
    v25 = -3196 * (v21 + v19) + 9633 * (int)v13;
    v26 = -16069 * ((int)v5 + v20) + 9633 * (int)v13;
    v27 = -20995 * (v21 + v20);
    v28 = -7373 * ((int)v5 + v19) + 1024;
    *v3 = 4 * (v15 + v17) - 4096;
    v3[1] = (unint64_t)(v28 + 12299 * v19 + v25) >> 11;
    v3[2] = v23;
    v3[3] = (unint64_t)(v27 + 1024 + 25172 * v20 + v26) >> 11;
    v3[4] = 4 * (v15 - v17);
    v3[5] = (unint64_t)(v27 + 1024 + 16819 * v21 + v25) >> 11;
    v3[6] = v24;
    v3[7] = (unint64_t)(v28 + 2446 * (int)v5 + v26) >> 11;
    if ((_DWORD)v4 != 7)
      break;
    v3 = v68;
LABEL_6:
    ++v4;
  }
  if ((_DWORD)v4 != 15)
  {
    v3 += 8;
    goto LABEL_6;
  }
  v29 = 0;
  do
  {
    v30 = &a1[v29];
    v31 = a1[v29];
    v32 = *(_DWORD *)((char *)&v68[14] + v29 * 4);
    v33 = a1[v29 + 8];
    v34 = *(_DWORD *)((char *)&v68[12] + v29 * 4);
    v35 = a1[v29 + 16];
    v36 = *(_DWORD *)((char *)&v68[10] + v29 * 4);
    v37 = a1[v29 + 24];
    v38 = *(_DWORD *)((char *)&v68[8] + v29 * 4);
    v39 = a1[v29 + 32];
    v40 = a1[v29 + 40];
    v41 = *(_DWORD *)((char *)&v68[4] + v29 * 4);
    v42 = a1[v29 + 48];
    v43 = *(_DWORD *)((char *)&v68[2] + v29 * 4);
    v44 = a1[v29 + 56];
    v45 = *(_DWORD *)((char *)v68 + v29 * 4);
    v46 = v45 + v44 + (uint64_t)(v32 + v31);
    v47 = v32 + v31 - (uint64_t)(v45 + v44);
    v48 = v43 + v42 + (uint64_t)(v34 + v33);
    v49 = *(_DWORD *)((char *)&v68[6] + v29 * 4);
    v50 = v34 + v33 - (uint64_t)(v43 + v42);
    v51 = v41 + v40 + (uint64_t)(v36 + v35);
    v52 = v36 + v35 - (uint64_t)(v41 + v40);
    v53 = v49 + v39 + (uint64_t)(v38 + v37);
    v54 = v38 + v37 - (uint64_t)(v49 + v39);
    v55 = v31 - v32;
    v56 = v33 - v34;
    v57 = v35 - v36;
    v58 = v39 - v49;
    *v30 = (unint64_t)(v53 + v51 + v48 + v46 + 4) >> 3;
    v30[32] = (unint64_t)(10703 * (v46 - v53) + 4433 * (v48 - v51) + 0x8000) >> 16;
    v59 = 2260 * (v54 - v50) + 11363 * (v47 - v52) + 0x8000;
    v30[16] = (unint64_t)(v59 + 17799 * v52 + 11893 * v50) >> 16;
    v60 = v42 - v43;
    v30[48] = (unint64_t)(v59 + 0xFFFFFFFFDE07 * v54 + 0xFFFFFFFFF93ELL * v47) >> 16;
    v61 = 11086 * (v33 - v34 + (uint64_t)v55) + 3363 * (v60 - (v44 - v45));
    v62 = 10217 * (v57 + (uint64_t)v55) + 5461 * (v44 - v45 + (uint64_t)(v40 - v41));
    v63 = 8956 * (v37 - v38 + (uint64_t)v55) + 7350 * (v58 - (uint64_t)(v44 - v45));
    result = 1136 * (v57 + (uint64_t)v56) + 11529 * (v60 - (v40 - v41));
    v65 = -5461 * (v37 - v38 + (uint64_t)v56) - 10217 * (v60 + v58);
    v66 = -11086 * (v37 - v38 + (uint64_t)v57) + 3363 * (v40 - v41 - (uint64_t)v58);
    v30[8] = (unint64_t)(v62 + 0xFFFFFFFFB6D6 * v55 + 6387 * (v44 - v45) + v61 + v63 + 0x8000) >> 16;
    v30[24] = (unint64_t)(v65 + 589 * v56 + 0xFFFFFFFFCAC1 * v60 + result + v61 + 0x8000) >> 16;
    v30[40] = (unint64_t)(v66 + 0x8000 - 9222 * v57 + 10055 * (v40 - v41) + result + v62) >> 16;
    v30[56] = (unint64_t)(v66 + 0x8000 + 8728 * (v37 - v38) + 17760 * v58 + v65 + v63) >> 16;
    ++v29;
  }
  while ((_DWORD)(v29 * 4) != 32);
  return result;
}

_OWORD *jpeg_fdct_7x14(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _OWORD v68[12];
  uint64_t v69;

  v3 = 0;
  v69 = *MEMORY[0x1E0C80C00];
  memset(v68, 0, sizeof(v68));
  *result = 0u;
  result[1] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  v4 = result;
  result[14] = 0u;
  result[15] = 0u;
  while (1)
  {
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + a3);
    v6 = *v5;
    v7 = v5[6];
    v8 = v7 + v6;
    v9 = v5[1];
    v10 = v5[5];
    v11 = (v10 + v9);
    v12 = v5[2];
    v13 = v5[4];
    v14 = v13 + v12;
    v15 = v5[3];
    v16 = v6 - v7;
    v17 = v9 - v10;
    LODWORD(v5) = v12 - v13;
    v18 = v13 + v12 + v8;
    v19 = 4 * (v15 + v11 + v18) - 3584;
    v20 = v18 - 4 * v15;
    v21 = v8 - (v13 + v12);
    v22 = v11 - v14;
    v23 = (unint64_t)(7542 * v21 + 2578 * ((int)v11 - v14) + 2896 * v20 + 1024) >> 11;
    v24 = 7223 * (v8 - (int)v11) + 1024;
    v25 = (v24 + 2578 * v22 + 0x7FFFFFFE95FLL * (v11 - 2 * (unint64_t)v15)) >> 11;
    v4[6] = (unint64_t)(v24 - 7542 * v21 + 2896 * v20) >> 11;
    LODWORD(v24) = v17 + v16;
    v26 = 1395 * (v16 - v17);
    v27 = (_DWORD)v5 + v17;
    v28 = 5027 * ((int)v5 + v16) + 1024;
    *v4 = v19;
    v4[1] = (unint64_t)(v28 - v26 + 7663 * (int)v24) >> 11;
    v4[2] = v23;
    v4[3] = (unint64_t)(v26 - 11295 * v27 + 7663 * (int)v24 + 1024) >> 11;
    v4[4] = v25;
    v4[5] = (unint64_t)(v28 + 15326 * (int)v5 - 11295 * v27) >> 11;
    if ((_DWORD)v3 != 7)
      break;
    v4 = v68;
LABEL_6:
    ++v3;
  }
  if ((_DWORD)v3 != 13)
  {
    v4 += 8;
    goto LABEL_6;
  }
  v29 = 0;
  do
  {
    v30 = (_DWORD *)((char *)result + v29);
    v31 = *(_DWORD *)((char *)result + v29);
    v32 = *(_DWORD *)((char *)&v68[10] + v29);
    v33 = *(_DWORD *)((char *)result + v29 + 32);
    v34 = *(_DWORD *)((char *)&v68[8] + v29);
    v35 = *(_DWORD *)((char *)result + v29 + 64);
    v36 = *(_DWORD *)((char *)&v68[6] + v29);
    v37 = *(_DWORD *)((char *)result + v29 + 96);
    v38 = *(_DWORD *)((char *)&v68[4] + v29);
    v39 = *(_DWORD *)((char *)result + v29 + 160);
    v40 = *(_DWORD *)((char *)v68 + v29);
    v41 = v36 + v35;
    v42 = *(_DWORD *)((char *)result + v29 + 192);
    v43 = *(_DWORD *)((char *)result + v29 + 224);
    v44 = v43 + v42 + (uint64_t)(v32 + v31);
    v45 = v32 + v31 - (uint64_t)(v43 + v42);
    v46 = v31 - v32;
    v47 = v40 + v39 + (uint64_t)(v34 + v33);
    v48 = v34 + v33;
    v49 = v33 - v34;
    v50 = v38 + v37;
    v51 = v35 - v36;
    v52 = *(_DWORD *)((char *)result + v29 + 128);
    v53 = *(_DWORD *)((char *)&v68[2] + v29);
    v54 = v48 - (v40 + v39);
    LODWORD(v48) = v37 - v38;
    v55 = v53 + v52 + (uint64_t)v41;
    v56 = v41 - (uint64_t)(v53 + v52);
    v57 = v52 - v53;
    v58 = v39 - v40;
    *v30 = (unint64_t)(5350 * (v55 + v50 + v47 + v44) + 0x4000) >> 15;
    v59 = 5915 * (v45 + v54) + 0x4000;
    v30[16] = (unint64_t)(v59 + 3283 * v56 + 1461 * v45) >> 15;
    v60 = (unint64_t)(v59 + 0x7FFFFFFFE330 * v56 + 0x7FFFFFFFDC12 * v54) >> 15;
    v61 = v51 + (uint64_t)v49;
    v30[48] = v60;
    v62 = v58 - (uint64_t)v57;
    v30[56] = (unint64_t)(5350 * (v46 + (uint64_t)(int)v48 - (v61 + v62 + v42 - v43)) + 0x4000) >> 15;
    v63 = 7518 * v62 - 5350 * (int)v48 - 847 * v61 + 0x4000;
    v64 = v63 + 0x7FFFFFFFCE64 * v51;
    v30[32] = (unint64_t)(1684 * (v47 - 2 * v50)
                               + 0x7FFFFFFFED93 * (v55 - 2 * v50)
                               + 6817 * (v44 - 2 * v50)
                               + 0x4000) >> 15;
    v65 = v63 + 0x7FFFFFFFF723 * v49;
    v66 = 7141 * (v49 + (uint64_t)v46) + 2499 * (v58 - (uint64_t)(v42 - v43));
    v67 = 6406 * (v51 + (uint64_t)v46) + 4025 * (v42 - v43 + (uint64_t)v57);
    v30[40] = (unint64_t)(v64 + 5992 * v57 + v67) >> 15;
    v30[24] = (unint64_t)(v65 + 0x7FFFFFFFBFD9 * v58 + v66) >> 15;
    v30[8] = (unint64_t)(v66
                              + 0x7FFFFFFFE873 * v46
                              + 5350 * (int)v48
                              + 0x7FFFFFFFFD59 * (v42 - v43)
                              + v67
                              + 0x4000) >> 15;
    v29 += 4;
  }
  while ((_DWORD)v29 != 28);
  return result;
}

int *jpeg_fdct_6x12(int *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _OWORD v54[8];
  uint64_t v55;

  v3 = 0;
  v55 = *MEMORY[0x1E0C80C00];
  memset(v54, 0, sizeof(v54));
  *(_OWORD *)result = 0u;
  *((_OWORD *)result + 1) = 0u;
  *((_OWORD *)result + 2) = 0u;
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + 5) = 0u;
  *((_OWORD *)result + 6) = 0u;
  *((_OWORD *)result + 7) = 0u;
  *((_OWORD *)result + 8) = 0u;
  *((_OWORD *)result + 9) = 0u;
  *((_OWORD *)result + 10) = 0u;
  *((_OWORD *)result + 11) = 0u;
  v4 = a3;
  *((_OWORD *)result + 12) = 0u;
  *((_OWORD *)result + 13) = 0u;
  v5 = result;
  *((_OWORD *)result + 14) = 0u;
  *((_OWORD *)result + 15) = 0u;
  while (1)
  {
    v6 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + v4);
    v7 = *v6;
    v8 = v6[5];
    v9 = v6[1];
    v10 = v6[4];
    v11 = v10 + v9;
    v12 = v6[2];
    LODWORD(v6) = v6[3];
    v13 = (_DWORD)v6 + v12 + v8 + v7;
    v14 = v8 + v7 - ((_DWORD)v6 + v12);
    v15 = v7 - v8;
    v16 = v9 - v10;
    LODWORD(v6) = v12 - (_DWORD)v6;
    v17 = 4 * (v13 + v10 + v9) - 3072;
    v18 = (unint64_t)(5793 * (v13 - 2 * v11) + 1024) >> 11;
    v19 = (unint64_t)(2998 * ((int)v6 + v15) + 1024) >> 11;
    *v5 = v17;
    v5[1] = v19 + 4 * (v16 + v15);
    v5[2] = (10033 * v14 + 1024) >> 11;
    v5[3] = 4 * (v15 - (v16 + (_DWORD)v6));
    v5[4] = v18;
    v5[5] = v19 + 4 * ((_DWORD)v6 - v16);
    if ((_DWORD)v3 != 7)
      break;
    v5 = (int *)v54;
LABEL_6:
    ++v3;
  }
  if ((_DWORD)v3 != 11)
  {
    v5 += 8;
    goto LABEL_6;
  }
  v20 = 0;
  do
  {
    v21 = &result[v20];
    v22 = result[v20];
    v23 = *(_DWORD *)((char *)&v54[6] + v20 * 4);
    v24 = result[v20 + 16];
    v25 = *(_DWORD *)((char *)&v54[2] + v20 * 4);
    v26 = result[v20 + 24];
    v27 = *(_DWORD *)((char *)v54 + v20 * 4);
    v28 = result[v20 + 40];
    v29 = result[v20 + 48];
    v30 = v29 + v28 + (uint64_t)(v23 + v22);
    v31 = v23 + v22 - (uint64_t)(v29 + v28);
    v32 = v27 + v26 + (uint64_t)(v25 + v24);
    v33 = v25 + v24 - (uint64_t)(v27 + v26);
    v34 = result[v20 + 8];
    v35 = *(_DWORD *)((char *)&v54[4] + v20 * 4);
    v36 = v22 - v23;
    v37 = v35 + v34;
    v38 = v34 - v35;
    v39 = result[v20 + 32];
    v40 = v24 - v25;
    v41 = result[v20 + 56];
    v42 = v26 - v27;
    v43 = v41 + v39;
    v44 = v39 - v41;
    v45 = v28 - v29;
    v46 = v37 - (uint64_t)v43;
    *v21 = (unint64_t)(7282 * (v32 + v37 + v43 + v30) + 0x4000) >> 15;
    v21[48] = (unint64_t)(7282 * (v31 - (v46 + v33)) + 0x4000) >> 15;
    v47 = v36;
    v21[32] = (unint64_t)(8918 * (v30 - v32) + 0x4000) >> 15;
    v21[16] = (unint64_t)(9947 * (v31 + v33) + 7282 * (v46 - v33) + 0x4000) >> 15;
    v48 = 3941 * (v44 + (uint64_t)v38);
    v49 = v48 + 5573 * v38;
    v50 = v48 - 13455 * v44;
    v51 = v40 + (uint64_t)v36;
    v52 = 6269 * (v42 + (uint64_t)v36);
    v53 = 8170 * v51 + 0x4000;
    v21[8] = (unint64_t)(v53 + 0x7FFFFFFFEF7BLL * v47 + v52 + v49 + 1344 * v45) >> 15;
    v21[24] = (unint64_t)(v50 + 9514 * (v47 - v42) + 0x7FFFFFFFF09BLL * (v45 + (uint64_t)v40) + 0x4000) >> 15;
    v21[40] = (unint64_t)(v53 - 17036 * v40 - 1344 * (v42 + (uint64_t)v40) - v50 + 6269 * v45) >> 15;
    v21[56] = (unint64_t)(v52 + 5285 * v42 - 1344 * (v42 + (uint64_t)v40) - v49 + 0x7FFFFFFFE016 * v45 + 0x4000) >> 15;
    ++v20;
  }
  while ((_DWORD)(v20 * 4) != 24);
  return result;
}

_OWORD *jpeg_fdct_5x10(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _OWORD v44[4];
  uint64_t v45;

  v3 = 0;
  v45 = *MEMORY[0x1E0C80C00];
  memset(v44, 0, sizeof(v44));
  *result = 0u;
  result[1] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  v4 = a3;
  result[12] = 0u;
  result[13] = 0u;
  v5 = result;
  result[14] = 0u;
  result[15] = 0u;
  while (1)
  {
    v6 = (unsigned __int8 *)(*(_QWORD *)(a2 + 8 * v3) + v4);
    v7 = *v6;
    v8 = v6[4];
    v9 = v8 + v7;
    v10 = v6[1];
    v11 = v6[3];
    v12 = v11 + v10;
    LODWORD(v6) = v6[2];
    v13 = v7 - v8;
    v14 = v10 - v11;
    LODWORD(v10) = 4 * (v11 + v10 + v9 + (_DWORD)v6) - 2560;
    LODWORD(v6) = v12 + v9 - 4 * (_DWORD)v6;
    v15 = 6476 * (v9 - v12) + 1024;
    v16 = (unint64_t)(v15 + 2896 * (int)v6) >> 11;
    v5[4] = (unint64_t)(v15 - 2896 * (int)v6) >> 11;
    v17 = 6810 * ((int)v14 + v13) + 1024;
    *v5 = v10;
    v5[1] = (unint64_t)(v17 + 4209 * v13) >> 11;
    v5[2] = v16;
    v5[3] = (unint64_t)(v17 + 0x7FFFFFFBA5CLL * v14) >> 11;
    if ((_DWORD)v3 != 7)
      break;
    v5 = v44;
LABEL_6:
    ++v3;
  }
  if ((_DWORD)v3 != 9)
  {
    v5 += 8;
    goto LABEL_6;
  }
  v18 = 0;
  do
  {
    v19 = (_DWORD *)((char *)result + v18);
    v20 = *(_DWORD *)((char *)result + v18);
    v21 = *(_DWORD *)((char *)&v44[2] + v18);
    v22 = *(_DWORD *)((char *)result + v18 + 32);
    v23 = *(_DWORD *)((char *)v44 + v18);
    v24 = *(_DWORD *)((char *)result + v18 + 96);
    v25 = *(_DWORD *)((char *)result + v18 + 192);
    v26 = *(_DWORD *)((char *)result + v18 + 128);
    v27 = *(_DWORD *)((char *)result + v18 + 160);
    v28 = v27 + v26 + (uint64_t)(v21 + v20);
    v29 = v21 + v20 - (uint64_t)(v27 + v26);
    v30 = v25 + v24 + (uint64_t)(v23 + v22);
    v31 = v23 + v22 - (uint64_t)(v25 + v24);
    v32 = *(_DWORD *)((char *)result + v18 + 64);
    v33 = v20 - v21;
    v34 = *(_DWORD *)((char *)result + v18 + 224);
    v35 = v22 - v23;
    v36 = v34 + v32;
    v37 = v32 - v34;
    v38 = v26 - v27;
    *v19 = (unint64_t)(10486 * (v30 + v36 + v28) + 0x4000) >> 15;
    v19[32] = (unint64_t)(11997 * (v28 - 2 * v36) + 0x7FFFFFFFEE1ALL * (v30 - 2 * v36) + 0x4000) >> 15;
    v39 = 8716 * (v29 + v31) + 0x4000;
    v19[16] = (unint64_t)(v39 + 5387 * v29) >> 15;
    v19[48] = (unint64_t)(v39 + 0x7FFFFFFFA6DCLL * v31) >> 15;
    v40 = v38 + (uint64_t)v33;
    v41 = v35 - (uint64_t)(v24 - v25);
    v19[40] = (unint64_t)(10486 * (v40 - (v41 + v37)) + 0x4000) >> 15;
    v19[8] = (unint64_t)(13213 * v35
                              + 14647 * v33
                              + 10486 * v37
                              + 6732 * (v24 - v25)
                              + 2320 * v38
                              + 0x4000) >> 15;
    v42 = 5243 * v41 - 10486 * v37 + 3240 * (v40 + v41);
    v43 = -6163 * (v24 - v25 + (uint64_t)v35) + 9973 * (v33 - (uint64_t)v38) + 0x4000;
    v19[24] = (unint64_t)(v43 + v42) >> 15;
    v19[56] = (unint64_t)(v43 - v42) >> 15;
    v18 += 4;
  }
  while ((_DWORD)v18 != 20);
  return result;
}

_OWORD *jpeg_fdct_4x8(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  v4 = a3;
  *result = 0u;
  result[1] = 0u;
  do
  {
    v5 = &result[v3];
    v6 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + v4);
    v7 = *v6;
    v8 = v6[3];
    v9 = v8 + v7;
    v10 = v6[1];
    v11 = v6[2];
    v12 = v11 + v10;
    v13 = v7 - v8;
    v14 = v10 - v11;
    v15 = 4433 * ((int)v14 + v13) + 512;
    *v5 = 8 * (v12 + v9) - 4096;
    v5[1] = (unint64_t)(v15 + 6270 * v13) >> 10;
    v5[2] = 8 * (v9 - v12);
    v5[3] = (unint64_t)(v15 + 0x3FFFFFFC4DFLL * v14) >> 10;
    v3 += 2;
  }
  while (v3 != 16);
  v16 = 0;
  do
  {
    v17 = (_DWORD *)((char *)result + v16);
    v18 = *(_DWORD *)((char *)result + v16);
    v19 = *(_DWORD *)((char *)result + v16 + 224);
    v20 = v19 + v18;
    v21 = *(_DWORD *)((char *)result + v16 + 32);
    v22 = *(_DWORD *)((char *)result + v16 + 192);
    v23 = *(_DWORD *)((char *)result + v16 + 64);
    v24 = *(_DWORD *)((char *)result + v16 + 160);
    v25 = v24 + v23;
    v26 = *(_DWORD *)((char *)result + v16 + 96);
    v27 = *(_DWORD *)((char *)result + v16 + 128);
    v28 = v20 + v27 + v26 + 2;
    v29 = v20 - (v27 + v26);
    v30 = v25 + v22 + v21;
    v31 = v22 + v21 - v25;
    v32 = v18 - v19;
    v33 = v21 - v22;
    v34 = v23 - v24;
    v35 = v26 - v27;
    *v17 = (unint64_t)(v28 + v30) >> 2;
    v17[32] = (unint64_t)(v28 - v30) >> 2;
    v36 = 4433 * (v29 + v31) + 0x4000;
    v17[16] = (unint64_t)(v36 + 6270 * v29) >> 15;
    v17[48] = (unint64_t)(v36 + 0x7FFFFFFFC4DFLL * v31) >> 15;
    v37 = v34 + (uint64_t)v32;
    v38 = v35 + v33;
    v39 = 9633 * (v38 + v37) + 0x4000;
    v40 = v39 - 3196 * v37;
    v41 = v39 - 16069 * v38;
    v42 = -7373 * (v35 + v32);
    v43 = -20995 * (v34 + (uint64_t)v33);
    v17[8] = (unint64_t)(v42 + 12299 * v32 + v40) >> 15;
    v17[24] = (unint64_t)(v43 + 25172 * v33 + v41) >> 15;
    v17[40] = (unint64_t)(v43 + 16819 * v34 + v40) >> 15;
    v17[56] = (unint64_t)(v42 + 2446 * v35 + v41) >> 15;
    v16 += 4;
  }
  while ((_DWORD)v16 != 16);
  return result;
}

_OWORD *jpeg_fdct_3x6(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  _DWORD *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  *result = 0u;
  result[1] = 0u;
  do
  {
    v4 = &result[v3];
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + a3);
    v6 = *v5;
    v7 = v5[2];
    LODWORD(v5) = v5[1];
    v4[2] = (5793 * (v7 + v6 - 2 * (int)v5) + 512) >> 10;
    *v4 = 8 * (v7 + v6 + (_DWORD)v5) - 3072;
    v4[1] = (10033 * (v6 - v7) + 512) >> 10;
    v3 += 2;
  }
  while (v3 != 12);
  v8 = 0;
  do
  {
    v9 = (_DWORD *)((char *)result + v8);
    v10 = *(_DWORD *)((char *)result + v8);
    v11 = *(_DWORD *)((char *)result + v8 + 160);
    v12 = *(_DWORD *)((char *)result + v8 + 32);
    v13 = *(_DWORD *)((char *)result + v8 + 128);
    v14 = v13 + v12;
    v15 = *(_DWORD *)((char *)result + v8 + 64);
    v16 = *(_DWORD *)((char *)result + v8 + 96);
    v17 = v16 + v15 + (uint64_t)(v11 + v10);
    v18 = v11 + v10 - (uint64_t)(v16 + v15);
    v19 = v10 - v11;
    v20 = v12 - v13;
    v21 = v15 - v16;
    *v9 = (unint64_t)(14564 * (v17 + v14) + 0x4000) >> 15;
    v9[16] = (unint64_t)(17837 * v18 + 0x4000) >> 15;
    v9[32] = (unint64_t)(10298 * (v17 - 2 * v14) + 0x4000) >> 15;
    v22 = 5331 * (v21 + v19) + 0x4000;
    v9[8] = (unint64_t)(v22 + 14564 * (v20 + v19)) >> 15;
    v9[24] = (unint64_t)(14564 * (v19 - (v20 + v21)) + 0x4000) >> 15;
    v9[40] = (unint64_t)(v22 + 14564 * (v21 - v20)) >> 15;
    v8 += 4;
  }
  while ((_DWORD)v8 != 12);
  return result;
}

_OWORD *jpeg_fdct_2x4(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  char v7;
  char v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  *result = 0u;
  result[1] = 0u;
  do
  {
    v4 = &result[v3];
    v5 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3 * 4) + a3);
    v6 = *v5;
    LODWORD(v5) = v5[1];
    *v4 = (_DWORD)v5 + v6 - 256;
    v4[1] = v6 - (_DWORD)v5;
    v3 += 2;
  }
  while (v3 != 8);
  v7 = 1;
  do
  {
    v8 = v7;
    v9 = *((_DWORD *)result + 24);
    v10 = v9 + *(_DWORD *)result;
    v11 = *((_DWORD *)result + 8);
    v12 = *((_DWORD *)result + 16);
    v13 = *(_DWORD *)result - v9;
    v14 = v11 - v12;
    *(_DWORD *)result = 8 * (v12 + v11 + v10);
    *((_DWORD *)result + 16) = 8 * (v10 - (v12 + v11));
    v15 = 4433 * (v14 + v13) + 512;
    *((_DWORD *)result + 8) = (unint64_t)(v15 + 6270 * v13) >> 10;
    *((_DWORD *)result + 24) = (unint64_t)(v15 + 0x3FFFFFFC4DFLL * v14) >> 10;
    result = (_OWORD *)((char *)result + 4);
    v7 = 0;
  }
  while ((v8 & 1) != 0);
  return result;
}

double jpeg_fdct_1x2(_OWORD *a1, _QWORD *a2, unsigned int a3)
{
  double result;
  int v4;
  int v5;

  result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  v4 = *(unsigned __int8 *)(*a2 + a3);
  v5 = *(unsigned __int8 *)(a2[1] + a3);
  *(_DWORD *)a1 = 32 * (v5 + v4) - 0x2000;
  *((_DWORD *)a1 + 8) = 32 * (v4 - v5);
  return result;
}

void *_cg_jpeg_get_small(int a1, size_t size)
{
  return malloc_type_malloc(size, 0x80D6B4CDuLL);
}

void _cg_jpeg_free_small(int a1, void *a2)
{
  free(a2);
}

void *_cg_jpeg_get_large(int a1, size_t size)
{
  return malloc_type_malloc(size, 0x64AF2682uLL);
}

uint64_t _cg_jpeg_mem_available(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 88) - a4;
}

uint64_t _cg_jpeg_open_backing_store(_QWORD *a1, size_t (**a2)(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, size_t a5))
{
  char *v4;
  FILE *v5;
  FILE *v6;
  uint64_t result;
  uint64_t (**v8)(_QWORD);
  char v9[24];
  char v10[1024];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  bzero(v10, 0x400uLL);
  if (confstr(65537, v10, 0x400uLL)
    && (strcpy(v9, "libjpeg_temp-XXXXXX"), strlen(v9), __strncat_chk(), v4 = mktemp(v10), (v5 = fopen(v4, "w+b")) != 0))
  {
    v6 = v5;
    result = unlink(v4);
    a2[3] = (size_t (*)(uint64_t *, uint64_t, void *, uint64_t, size_t))v6;
  }
  else
  {
    a2[3] = 0;
    v8 = (uint64_t (**)(_QWORD))*a1;
    *((_DWORD *)v8 + 10) = 65;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    result = (*(uint64_t (**)(_QWORD *))*a1)(a1);
  }
  *a2 = read_backing_store;
  a2[1] = (size_t (*)(uint64_t *, uint64_t, void *, uint64_t, size_t))write_backing_store;
  a2[2] = (size_t (*)(uint64_t *, uint64_t, void *, uint64_t, size_t))close_backing_store;
  return result;
}

size_t read_backing_store(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, size_t a5)
{
  uint64_t v9;
  size_t result;
  uint64_t v11;

  if (fseek(*(FILE **)(a2 + 24), a4, 0))
  {
    v9 = *a1;
    *(_DWORD *)(v9 + 40) = 67;
    (*(void (**)(uint64_t *))v9)(a1);
  }
  result = fread(a3, 1uLL, a5, *(FILE **)(a2 + 24));
  if (result != a5)
  {
    v11 = *a1;
    *(_DWORD *)(v11 + 40) = 66;
    return (*(uint64_t (**)(uint64_t *))v11)(a1);
  }
  return result;
}

size_t write_backing_store(uint64_t *a1, uint64_t a2, const void *a3, uint64_t a4, size_t a5)
{
  uint64_t v9;
  size_t result;
  uint64_t v11;

  if (fseek(*(FILE **)(a2 + 24), a4, 0))
  {
    v9 = *a1;
    *(_DWORD *)(v9 + 40) = 67;
    (*(void (**)(uint64_t *))v9)(a1);
  }
  result = fwrite(a3, 1uLL, a5, *(FILE **)(a2 + 24));
  if (result != a5)
  {
    v11 = *a1;
    *(_DWORD *)(v11 + 40) = 68;
    return (*(uint64_t (**)(uint64_t *))v11)(a1);
  }
  return result;
}

uint64_t close_backing_store(uint64_t a1, uint64_t a2)
{
  return fclose(*(FILE **)(a2 + 24));
}

uint64_t _cg_jpeg_mem_init()
{
  return 1000000000;
}

void kdu_warning::kdu_warning(kdu_warning *this, const char *a2)
{
  *(_QWORD *)this = &off_1E1BABFF0;
  *((_QWORD *)this + 2) = 0;
}

void kdu_warning::~kdu_warning(kdu_warning *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1E1BABFF0;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v1 + 32))(v1, 1);
}

{
  kdu_warning::~kdu_warning(this);
}

{
  kdu_warning::~kdu_warning(this);
  JUMPOUT(0x18D761C30);
}

void sub_187F65914(_Unwind_Exception *a1, int a2)
{
  if (a2 < 0)
    __cxa_call_unexpected(a1);
  _Unwind_Resume(a1);
}

void sub_187F65974(_Unwind_Exception *a1, int a2)
{
  uint64_t v2;

  MEMORY[0x18D761C30](v2, 0x10F1C40713AC7E1);
  if (a2 < 0)
    __cxa_call_unexpected(a1);
  _Unwind_Resume(a1);
}

uint64_t kdu_warning::put_text(kdu_warning *this, const char *a2)
{
  uint64_t result;
  _BYTE *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  _WORD *v8;
  _WORD *v9;
  int v10;

  result = *((_QWORD *)this + 2);
  if (!result)
    return result;
  if (*a2 != 60 || a2[1] != 35 || a2[2] != 62 || a2[3])
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  v4 = (_BYTE *)*((_QWORD *)this + 3);
  if (v4)
  {
    if (*v4)
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 16))(result, *((_QWORD *)this + 3));
      v5 = (unsigned __int8 *)*((_QWORD *)this + 3);
      if (*v5)
      {
        v6 = v5 + 1;
        do
          *((_QWORD *)this + 3) = v6;
        while (*v6++);
        v5 = v6 - 1;
      }
      *((_QWORD *)this + 3) = v5 + 1;
      return result;
    }
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  }
  v8 = (_WORD *)*((_QWORD *)this + 4);
  if (!v8 || !*v8)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 24))(result, *((_QWORD *)this + 4));
  v9 = (_WORD *)*((_QWORD *)this + 4);
  if (*v9)
  {
    do
    {
      v10 = (unsigned __int16)v9[1];
      ++v9;
    }
    while (v10);
  }
  *((_QWORD *)this + 4) = v9 + 1;
  return result;
}

void kdu_error::kdu_error(kdu_error *this)
{
  *(_QWORD *)this = off_1E1BB30F8;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  kdu_error::put_text(this, "Kakadu Error:\n");
}

void kdu_error::kdu_error(kdu_error *this, const char *a2)
{
  *(_QWORD *)this = off_1E1BB30F8;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  if (*a2)
    kdu_error::put_text(this, a2);
}

void kdu_error::~kdu_error(kdu_error *this)
{
  uint64_t v1;
  _DWORD *exception;

  *(_QWORD *)this = off_1E1BB30F8;
  v1 = *((_QWORD *)this + 2);
  if (v1)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v1 + 32))(v1, 1);
  exception = __cxa_allocate_exception(4uLL);
  *exception = -1;
  __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
}

{
  kdu_error::~kdu_error(this);
}

{
  kdu_error::~kdu_error(this);
}

void sub_187F65B64(_Unwind_Exception *a1, int a2)
{
  if (a2 < 0)
    __cxa_call_unexpected(a1);
  _Unwind_Resume(a1);
}

void sub_187F65BA0(_Unwind_Exception *a1, int a2)
{
  uint64_t v2;

  MEMORY[0x18D761C30](v2, 0x10F1C40713AC7E1);
  if (a2 < 0)
    __cxa_call_unexpected(a1);
  _Unwind_Resume(a1);
}

uint64_t kdu_error::put_text(kdu_error *this, const char *a2)
{
  uint64_t result;
  _BYTE *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  _WORD *v8;
  _WORD *v9;
  int v10;

  result = *((_QWORD *)this + 2);
  if (!result)
    return result;
  if (*a2 != 60 || a2[1] != 35 || a2[2] != 62 || a2[3])
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  v4 = (_BYTE *)*((_QWORD *)this + 3);
  if (v4)
  {
    if (*v4)
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 16))(result, *((_QWORD *)this + 3));
      v5 = (unsigned __int8 *)*((_QWORD *)this + 3);
      if (*v5)
      {
        v6 = v5 + 1;
        do
          *((_QWORD *)this + 3) = v6;
        while (*v6++);
        v5 = v6 - 1;
      }
      *((_QWORD *)this + 3) = v5 + 1;
      return result;
    }
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  }
  v8 = (_WORD *)*((_QWORD *)this + 4);
  if (!v8 || !*v8)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 24))(result, *((_QWORD *)this + 4));
  v9 = (_WORD *)*((_QWORD *)this + 4);
  if (*v9)
  {
    do
    {
      v10 = (unsigned __int16)v9[1];
      ++v9;
    }
    while (v10);
  }
  *((_QWORD *)this + 4) = v9 + 1;
  return result;
}

uint64_t kdu_warning::flush(kdu_warning *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 32))(result, 0);
  return result;
}

uint64_t kdu_error::flush(kdu_error *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 32))(result, 0);
  return result;
}

uint64_t _cg_jpeg_add_quant_table(uint64_t a1, unsigned int a2, uint64_t a3, int a4, __int32 a5, double a6, int32x2_t a7, double a8, double a9, double a10, double a11, __n128 a12)
{
  int v17;
  void (**v18)(_QWORD);
  void (**v19)(_QWORD);
  uint64_t v20;
  uint64_t result;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  int64x2_t v25;
  int64x2_t v26;
  int64x2_t v27;
  int8x16_t v28;
  uint64x2_t v29;
  int64x2_t v30;
  int64x2_t v31;
  int64x2_t v32;
  int64x2_t v33;
  int64x2_t v34;
  int64x2_t v35;
  int64x2_t v36;
  int64x2_t v37;
  uint64_t v38;
  uint64_t v39;
  int64x2_t v40;
  int8x16_t v41;
  int8x16_t v42;
  int8x16_t v43;
  int64x2_t v44;
  int64x2_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  int32x4_t v51;
  int32x4_t v52;
  int32x4_t v53;
  int32x4_t v54;
  int8x16_t v55;

  v17 = *(_DWORD *)(a1 + 36);
  if (v17 != 100)
  {
    v18 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v18 + 10) = 21;
    *((_DWORD *)v18 + 12) = v17;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (a2 >= 4)
  {
    v19 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v19 + 10) = 32;
    *((_DWORD *)v19 + 12) = a2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  v20 = a1 + 8 * (int)a2;
  v23 = *(_QWORD *)(v20 + 112);
  v22 = (uint64_t *)(v20 + 112);
  result = v23;
  if (!v23)
  {
    result = _cg_jpeg_alloc_quant_table(a1);
    *v22 = result;
  }
  v24 = 0;
  v25 = vdupq_n_s64(a4);
  a7.i32[0] = a5;
  v26 = vdupq_n_s64(0x32uLL);
  v27 = vdupq_n_s64(1uLL);
  v28 = (int8x16_t)vdupq_n_s64(0x7FFFuLL);
  v29.i64[0] = 255;
  v29.i64[1] = 255;
  do
  {
    a12.n128_u32[0] = 0;
    v30 = *(int64x2_t *)(a3 + 16);
    v31.i64[0] = v30.u32[2];
    v31.i64[1] = v30.u32[3];
    v32 = v31;
    v31.i64[1] = v30.u32[1];
    v33.i64[0] = v25.i64[0] * *(_OWORD *)a3;
    v34.i64[0] = v25.i64[0] * *(_QWORD *)(a3 + 8);
    v33.i64[1] = v25.i64[1] * HIDWORD(*(_QWORD *)a3);
    v34.i64[1] = v25.i64[1] * HIDWORD(*(_OWORD *)a3);
    v30.i64[0] = v25.i64[0] * v30.u32[0];
    v30.i64[1] = v25.i64[1] * v31.i64[1];
    v32.i64[0] *= v25.i64[0];
    v32.i64[1] *= v25.i64[1];
    v35 = vaddq_s64(v30, v26);
    v36 = vaddq_s64(v34, v26);
    v37 = vaddq_s64(v33, v26);
    v37.i64[0] /= 100;
    v36.i64[0] /= 100;
    v38 = v35.i64[1];
    v39 = v35.i64[0];
    v40 = vaddq_s64(v32, v26);
    v32.i64[0] = v39 / 100;
    v37.i64[1] /= 100;
    v36.i64[1] /= 100;
    v32.i64[1] = v38 / 100;
    v40.i64[0] /= 100;
    v40.i64[1] /= 100;
    v41 = (int8x16_t)vcgtq_s64(v40, v27);
    v42 = (int8x16_t)vcgtq_s64(v32, v27);
    v43 = (int8x16_t)vsubq_s64((int64x2_t)vandq_s8((int8x16_t)v40, v41), (int64x2_t)vmvnq_s8(v41));
    v44 = (int64x2_t)vandq_s8((int8x16_t)v32, v42);
    v45 = (int64x2_t)vmvnq_s8(v42);
    v46 = (int8x16_t)vcgtq_s64(v36, v27);
    v47 = (int8x16_t)vsubq_s64(v44, v45);
    v48 = (int8x16_t)vsubq_s64((int64x2_t)vandq_s8((int8x16_t)v36, v46), (int64x2_t)vmvnq_s8(v46));
    v49 = (int8x16_t)vcgtq_s64(v37, v27);
    v50 = (int8x16_t)vsubq_s64((int64x2_t)vandq_s8((int8x16_t)v37, v49), (int64x2_t)vmvnq_s8(v49));
    v51 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v28, (uint64x2_t)v50), v50, v28);
    v52 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v28, (uint64x2_t)v48), v48, v28);
    v53 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v28, (uint64x2_t)v47), v47, v28);
    v54 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v28, (uint64x2_t)v43), v43, v28);
    v55 = (int8x16_t)vcltzq_s16(vshlq_n_s16((int16x8_t)vmovl_u8((uint8x8_t)vbic_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64((uint64x2_t)v51, v29), (int32x4_t)vcgtq_u64((uint64x2_t)v52, v29)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64((uint64x2_t)v53, v29), (int32x4_t)vcgtq_u64((uint64x2_t)v54, v29)))), (int8x8_t)vdup_lane_s32(vceq_s32(a7, (int32x2_t)a12.n128_u64[0]), 0))), 0xFuLL));
    a12 = (__n128)vorrq_s8((int8x16_t)(*(_OWORD *)&v55 & __PAIR128__(0xFF00FF00FF00FFLL, 0xFF00FF00FF00FFLL)), vbicq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32(v51, v52), (int16x8_t)vuzp1q_s32(v53, v54)), v55));
    *(__n128 *)(result + v24) = a12;
    a3 += 32;
    v24 += 16;
  }
  while (v24 != 128);
  *(_DWORD *)(result + 128) = 0;
  return result;
}

uint64_t _cg_jpeg_set_quality(uint64_t a1, int a2, __int32 a3, double a4, int32x2_t a5, double a6, double a7, double a8, double a9, __n128 a10)
{
  unsigned int v12;
  unsigned int v13;
  double v14;
  int32x2_t v15;
  double v16;
  double v17;
  double v18;
  double v19;
  __n128 v20;

  if (a2 <= 1)
    v12 = 1;
  else
    v12 = a2;
  if (v12 >= 0x64)
    v12 = 100;
  if (v12 > 0x31)
    v13 = 200 - 2 * v12;
  else
    v13 = 0x1388u / (unsigned __int16)v12;
  _cg_jpeg_add_quant_table(a1, 0, (uint64_t)&std_luminance_quant_tbl, v13, a3, a4, a5, a6, a7, a8, a9, a10);
  return _cg_jpeg_add_quant_table(a1, 1u, (uint64_t)&std_chrominance_quant_tbl, v13, a3, v14, v15, v16, v17, v18, v19, v20);
}

uint64_t _cg_jpeg_set_defaults(uint64_t a1, double a2, int32x2_t a3, double a4, double a5, double a6, double a7, __n128 a8)
{
  int v9;
  void (**v10)(_QWORD);
  double v11;
  int32x2_t v12;
  double v13;
  double v14;
  double v15;
  double v16;
  __n128 v17;

  v9 = *(_DWORD *)(a1 + 36);
  if (v9 != 100)
  {
    v10 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v10 + 10) = 21;
    *((_DWORD *)v10 + 12) = v9;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (!*(_QWORD *)(a1 + 104))
    *(_QWORD *)(a1 + 104) = (**(uint64_t (***)(uint64_t, _QWORD, uint64_t))(a1 + 8))(a1, 0, 960);
  *(_QWORD *)(a1 + 72) = 0x100000001;
  *(_DWORD *)(a1 + 88) = 8;
  _cg_jpeg_add_quant_table(a1, 0, (uint64_t)&std_luminance_quant_tbl, 50, 1, COERCE_DOUBLE(0x100000001), a3, a4, a5, a6, a7, a8);
  _cg_jpeg_add_quant_table(a1, 1u, (uint64_t)&std_chrominance_quant_tbl, 50, 1, v11, v12, v13, v14, v15, v16, v17);
  if (*(_QWORD *)(a1 + 160))
    _cg_jpeg_std_huff_table(a1, 1, 0);
  if (*(_QWORD *)(a1 + 192))
    _cg_jpeg_std_huff_table(a1, 0, 0);
  if (*(_QWORD *)(a1 + 168))
    _cg_jpeg_std_huff_table(a1, 1, 1u);
  if (*(_QWORD *)(a1 + 200))
    _cg_jpeg_std_huff_table(a1, 0, 1u);
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 0x101010101010101;
  *(_QWORD *)(a1 + 248) = 0x101010101010101;
  *(_QWORD *)(a1 + 256) = 0x505050505050505;
  *(_QWORD *)(a1 + 264) = 0x505050505050505;
  *(_QWORD *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 292) = *(_DWORD *)(a1 + 88) > 8;
  *(_QWORD *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 304) = 1;
  *(_QWORD *)(a1 + 316) = 0;
  *(_QWORD *)(a1 + 308) = 0;
  *(_WORD *)(a1 + 328) = 257;
  *(_BYTE *)(a1 + 330) = 0;
  *(_DWORD *)(a1 + 332) = 65537;
  *(_DWORD *)(a1 + 340) = 0;
  return _cg_jpeg_default_colorspace(a1);
}

uint64_t _cg_jpeg_default_colorspace(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t result;

  switch(*(_DWORD *)(a1 + 60))
  {
    case 0:
      v1 = 0;
      goto LABEL_3;
    case 1:
      v1 = 1;
      goto LABEL_3;
    case 2:
    case 3:
      v1 = 3;
      goto LABEL_3;
    case 4:
      v1 = 4;
      goto LABEL_3;
    case 5:
      v1 = 5;
      goto LABEL_3;
    case 6:
      v1 = 6;
      goto LABEL_3;
    case 7:
      v1 = 7;
LABEL_3:
      result = _cg_jpeg_set_colorspace(a1, v1);
      break;
    default:
      v2 = *(_QWORD *)a1;
      *(_DWORD *)(v2 + 40) = 10;
      result = (*(uint64_t (**)(uint64_t))v2)(a1);
      break;
  }
  return result;
}

uint64_t _cg_jpeg_set_colorspace(uint64_t result, int a2)
{
  uint64_t v3;
  int v4;
  uint64_t (**v5)(_QWORD);
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 v11;
  int v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;

  v3 = result;
  v4 = *(_DWORD *)(result + 36);
  if (v4 != 100)
  {
    v5 = *(uint64_t (***)(_QWORD))result;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v4;
    result = (**(uint64_t (***)(uint64_t))result)(result);
  }
  *(_DWORD *)(v3 + 96) = a2;
  *(_DWORD *)(v3 + 324) = 0;
  *(_DWORD *)(v3 + 336) = 0;
  switch(a2)
  {
    case 0:
      v6 = *(_DWORD *)(v3 + 56);
      *(_DWORD *)(v3 + 92) = v6;
      if ((v6 - 11) > 0xFFFFFFF5
        || (v7 = *(_QWORD *)v3,
            *(_DWORD *)(v7 + 40) = 27,
            *(_DWORD *)(v7 + 48) = v6,
            *(_DWORD *)(*(_QWORD *)v3 + 52) = 10,
            result = (**(uint64_t (***)(uint64_t))v3)(v3),
            v6 = *(_DWORD *)(v3 + 92),
            v6 >= 1))
      {
        v8 = 0;
        v9 = *(_QWORD *)(v3 + 104);
        do
        {
          *(_DWORD *)v9 = v8;
          *(_OWORD *)(v9 + 8) = xmmword_18820E710;
          *(_DWORD *)(v9 + 24) = 0;
          ++v8;
          v9 += 96;
        }
        while (v6 != v8);
      }
      break;
    case 1:
      *(_DWORD *)(v3 + 324) = 1;
      *(_DWORD *)(v3 + 92) = 1;
      v19 = *(_QWORD *)(v3 + 104);
      *(_DWORD *)v19 = 1;
      *(_OWORD *)(v19 + 8) = xmmword_18820E710;
      *(_DWORD *)(v19 + 24) = 0;
      break;
    case 2:
      *(_DWORD *)(v3 + 336) = 1;
      *(_DWORD *)(v3 + 92) = 3;
      v10 = *(_QWORD *)(v3 + 104);
      *(_DWORD *)v10 = 82;
      *(_QWORD *)(v10 + 8) = 0x100000001;
      v11 = *(_DWORD *)(v3 + 340) == 1;
      *(_DWORD *)(v10 + 16) = 0;
      *(_DWORD *)(v10 + 20) = v11;
      *(_DWORD *)(v10 + 24) = v11;
      *(_DWORD *)(v10 + 96) = 71;
      *(_OWORD *)(v10 + 104) = xmmword_18820E710;
      *(_DWORD *)(v10 + 120) = 0;
      v12 = 66;
      goto LABEL_17;
    case 3:
      *(_DWORD *)(v3 + 324) = 1;
      *(_DWORD *)(v3 + 92) = 3;
      v13 = *(_QWORD *)(v3 + 104);
      *(_DWORD *)v13 = 1;
      *(_OWORD *)(v13 + 8) = xmmword_18820E700;
      *(_DWORD *)(v13 + 24) = 0;
      *(_DWORD *)(v13 + 96) = 2;
      *(_QWORD *)&v14 = 0x100000001;
      *((_QWORD *)&v14 + 1) = 0x100000001;
      *(_OWORD *)(v13 + 104) = v14;
      *(_DWORD *)(v13 + 120) = 1;
      *(_DWORD *)(v13 + 192) = 3;
      *(_OWORD *)(v13 + 200) = v14;
      *(_DWORD *)(v13 + 216) = 1;
      break;
    case 4:
      *(_DWORD *)(v3 + 336) = 1;
      *(_DWORD *)(v3 + 92) = 4;
      v15 = *(_QWORD *)(v3 + 104);
      *(_DWORD *)v15 = 67;
      *(_OWORD *)(v15 + 8) = xmmword_18820E710;
      *(_DWORD *)(v15 + 24) = 0;
      *(_DWORD *)(v15 + 96) = 77;
      *(_OWORD *)(v15 + 104) = xmmword_18820E710;
      *(_DWORD *)(v15 + 120) = 0;
      *(_DWORD *)(v15 + 192) = 89;
      *(_OWORD *)(v15 + 200) = xmmword_18820E710;
      *(_DWORD *)(v15 + 216) = 0;
      *(_DWORD *)(v15 + 288) = 75;
      *(_OWORD *)(v15 + 296) = xmmword_18820E710;
      *(_DWORD *)(v15 + 312) = 0;
      break;
    case 5:
      *(_DWORD *)(v3 + 336) = 1;
      *(_DWORD *)(v3 + 92) = 4;
      v20 = *(_QWORD *)(v3 + 104);
      *(_DWORD *)v20 = 1;
      *(_OWORD *)(v20 + 8) = xmmword_18820E700;
      *(_DWORD *)(v20 + 24) = 0;
      *(_DWORD *)(v20 + 96) = 2;
      *(_QWORD *)&v21 = 0x100000001;
      *((_QWORD *)&v21 + 1) = 0x100000001;
      *(_OWORD *)(v20 + 104) = v21;
      *(_DWORD *)(v20 + 120) = 1;
      *(_DWORD *)(v20 + 192) = 3;
      *(_OWORD *)(v20 + 200) = v21;
      *(_DWORD *)(v20 + 216) = 1;
      *(_DWORD *)(v20 + 288) = 4;
      *(_OWORD *)(v20 + 296) = xmmword_18820E700;
      *(_DWORD *)(v20 + 312) = 0;
      break;
    case 6:
      *(_DWORD *)(v3 + 324) = 1;
      *(_BYTE *)(v3 + 328) = 2;
      *(_DWORD *)(v3 + 92) = 3;
      v10 = *(_QWORD *)(v3 + 104);
      *(_DWORD *)v10 = 114;
      *(_QWORD *)(v10 + 8) = 0x100000001;
      v11 = *(_DWORD *)(v3 + 340) == 1;
      *(_DWORD *)(v10 + 16) = 0;
      *(_DWORD *)(v10 + 20) = v11;
      *(_DWORD *)(v10 + 24) = v11;
      *(_DWORD *)(v10 + 96) = 103;
      *(_OWORD *)(v10 + 104) = xmmword_18820E710;
      *(_DWORD *)(v10 + 120) = 0;
      v12 = 98;
LABEL_17:
      *(_DWORD *)(v10 + 192) = v12;
      *(_QWORD *)(v10 + 200) = 0x100000001;
      *(_DWORD *)(v10 + 208) = 0;
      *(_DWORD *)(v10 + 212) = v11;
      *(_DWORD *)(v10 + 216) = v11;
      break;
    case 7:
      *(_DWORD *)(v3 + 324) = 1;
      *(_BYTE *)(v3 + 328) = 2;
      *(_DWORD *)(v3 + 92) = 3;
      v16 = *(_QWORD *)(v3 + 104);
      *(_DWORD *)v16 = 1;
      *(_OWORD *)(v16 + 8) = xmmword_18820E700;
      *(_DWORD *)(v16 + 24) = 0;
      *(_DWORD *)(v16 + 96) = 34;
      *(_QWORD *)&v17 = 0x100000001;
      *((_QWORD *)&v17 + 1) = 0x100000001;
      *(_OWORD *)(v16 + 104) = v17;
      *(_DWORD *)(v16 + 120) = 1;
      *(_DWORD *)(v16 + 192) = 35;
      *(_OWORD *)(v16 + 200) = v17;
      *(_DWORD *)(v16 + 216) = 1;
      break;
    default:
      v18 = *(_QWORD *)v3;
      *(_DWORD *)(v18 + 40) = 11;
      result = (*(uint64_t (**)(uint64_t))v18)(v3);
      break;
  }
  return result;
}

uint64_t _cg_jinit_marker_writer(uint64_t a1)
{
  uint64_t result;

  result = (**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 528) = result;
  *(_QWORD *)result = write_file_header;
  *(_QWORD *)(result + 8) = write_frame_header;
  *(_QWORD *)(result + 16) = write_scan_header;
  *(_QWORD *)(result + 24) = write_file_trailer;
  *(_QWORD *)(result + 32) = write_tables_only;
  *(_QWORD *)(result + 40) = write_marker_header;
  *(_QWORD *)(result + 48) = write_marker_byte;
  *(_DWORD *)(result + 56) = 0;
  return result;
}

uint64_t write_file_header(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  __int16 v4;
  __int16 v5;
  int v6;
  char v7;

  v2 = *(_QWORD *)(a1 + 528);
  emit_byte(a1, 255);
  result = emit_byte(a1, 216);
  *(_DWORD *)(v2 + 56) = 0;
  if (*(_DWORD *)(a1 + 324))
  {
    emit_byte(a1, 255);
    emit_byte(a1, 224);
    emit_byte(a1, 0);
    emit_byte(a1, 16);
    emit_byte(a1, 74);
    emit_byte(a1, 70);
    emit_byte(a1, 73);
    emit_byte(a1, 70);
    emit_byte(a1, 0);
    emit_byte(a1, *(_BYTE *)(a1 + 328));
    emit_byte(a1, *(_BYTE *)(a1 + 329));
    emit_byte(a1, *(_BYTE *)(a1 + 330));
    v4 = *(_WORD *)(a1 + 332);
    emit_byte(a1, SHIBYTE(v4));
    emit_byte(a1, v4);
    v5 = *(_WORD *)(a1 + 334);
    emit_byte(a1, SHIBYTE(v5));
    emit_byte(a1, v5);
    emit_byte(a1, 0);
    result = emit_byte(a1, 0);
  }
  if (*(_DWORD *)(a1 + 336))
  {
    emit_byte(a1, 255);
    emit_byte(a1, 238);
    emit_byte(a1, 0);
    emit_byte(a1, 14);
    emit_byte(a1, 65);
    emit_byte(a1, 100);
    emit_byte(a1, 111);
    emit_byte(a1, 98);
    emit_byte(a1, 101);
    emit_byte(a1, 0);
    emit_byte(a1, 100);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    v6 = *(_DWORD *)(a1 + 96);
    if (v6 == 3)
      v7 = 1;
    else
      v7 = 2 * (v6 == 5);
    return emit_byte(a1, v7);
  }
  return result;
}

uint64_t write_frame_header(uint64_t a1)
{
  int v2;
  int v3;
  int v4;
  int *v5;
  int v6;
  char v7;
  int *v8;
  int v9;
  uint64_t result;
  int v11;
  uint64_t v12;
  uint64_t v13;

  v2 = *(_DWORD *)(a1 + 92);
  if (v2 < 1)
  {
    v3 = 0;
  }
  else
  {
    v3 = 0;
    v4 = 0;
    v5 = (int *)(*(_QWORD *)(a1 + 104) + 16);
    do
    {
      v6 = *v5;
      v5 += 24;
      v3 += emit_dqt(a1, v6);
      ++v4;
      v2 = *(_DWORD *)(a1 + 92);
    }
    while (v4 < v2);
  }
  if (*(_DWORD *)(a1 + 292))
    goto LABEL_7;
  if (*(_DWORD *)(a1 + 348))
    goto LABEL_22;
  if (*(_DWORD *)(a1 + 88) != 8 || *(_DWORD *)(a1 + 476) != 8)
  {
    v9 = 0;
    goto LABEL_21;
  }
  if (v2 < 1)
  {
    v9 = 1;
  }
  else
  {
    v8 = (int *)(*(_QWORD *)(a1 + 104) + 24);
    v9 = 1;
    do
    {
      if (*(v8 - 1) > 1 || *v8 >= 2)
        v9 = 0;
      v8 += 24;
      --v2;
    }
    while (v2);
  }
  if (!v3 || !v9)
  {
LABEL_21:
    if (!*(_DWORD *)(a1 + 348))
    {
      if (v9)
      {
        v7 = -64;
        goto LABEL_23;
      }
      goto LABEL_39;
    }
LABEL_22:
    v7 = -62;
    goto LABEL_23;
  }
  v13 = *(_QWORD *)a1;
  *(_DWORD *)(v13 + 40) = 77;
  (*(void (**)(uint64_t, _QWORD))(v13 + 8))(a1, 0);
  if (!*(_DWORD *)(a1 + 292))
  {
    if (!*(_DWORD *)(a1 + 348))
    {
LABEL_39:
      v7 = -63;
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_7:
  if (*(_DWORD *)(a1 + 348))
    v7 = -54;
  else
    v7 = -55;
LABEL_23:
  result = emit_sof(a1, v7);
  v11 = *(_DWORD *)(a1 + 340);
  if (v11)
  {
    if (v11 != 1 || *(int *)(a1 + 92) <= 2)
    {
      v12 = *(_QWORD *)a1;
      *(_DWORD *)(v12 + 40) = 28;
      (*(void (**)(uint64_t))v12)(a1);
    }
    emit_byte(a1, 255);
    emit_byte(a1, 248);
    emit_byte(a1, 0);
    emit_byte(a1, 24);
    emit_byte(a1, 13);
    emit_byte(a1, 0);
    emit_byte(a1, 255);
    emit_byte(a1, 3);
    emit_byte(a1, *(_DWORD *)(*(_QWORD *)(a1 + 104) + 96));
    emit_byte(a1, **(_DWORD **)(a1 + 104));
    emit_byte(a1, *(_DWORD *)(*(_QWORD *)(a1 + 104) + 192));
    emit_byte(a1, 128);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 1);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 1);
    emit_byte(a1, 0);
    result = emit_byte(a1, 0);
  }
  if (*(_DWORD *)(a1 + 348))
  {
    if (*(_DWORD *)(a1 + 476) != 8)
    {
      emit_byte(a1, 255);
      emit_byte(a1, 218);
      emit_byte(a1, 0);
      emit_byte(a1, 6);
      emit_byte(a1, 0);
      emit_byte(a1, 0);
      emit_byte(a1, *(_DWORD *)(a1 + 476) * *(_DWORD *)(a1 + 476) - 1);
      return emit_byte(a1, 0);
    }
  }
  return result;
}

uint64_t write_scan_header(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t *v6;
  uint64_t v7;
  int16x8_t v8;
  int16x8_t v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  _DWORD *v20;
  int v21;
  int v22;
  int8x16_t v24;
  int8x16_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 528);
  if (*(_DWORD *)(a1 + 292))
  {
    v24 = 0uLL;
    v25 = 0uLL;
    v3 = *(unsigned int *)(a1 + 372);
    if ((int)v3 >= 1)
    {
      v4 = *(_DWORD *)(a1 + 460);
      v5 = *(_DWORD *)(a1 + 464);
      v6 = (uint64_t *)(a1 + 376);
      while (1)
      {
        v7 = *v6;
        if (!v4 && !*(_DWORD *)(a1 + 468))
          break;
        if (v5)
          goto LABEL_7;
LABEL_8:
        ++v6;
        if (!--v3)
          goto LABEL_12;
      }
      v25.i8[*(int *)(v7 + 20)] = 1;
      if (!v5)
        goto LABEL_8;
LABEL_7:
      v24.i8[*(int *)(v7 + 24)] = 1;
      goto LABEL_8;
    }
LABEL_12:
    v8 = vaddl_high_s8(v25, v24);
    v9 = vaddl_s8(*(int8x8_t *)v25.i8, *(int8x8_t *)v24.i8);
    v10 = vaddvq_s32(vaddq_s32(vaddl_s16(*(int16x4_t *)v9.i8, *(int16x4_t *)v8.i8), vaddl_high_s16(v9, v8)));
    if (v10)
    {
      emit_byte(a1, 255);
      emit_byte(a1, 204);
      v11 = 2 * v10 + 2;
      emit_byte(a1, SHIBYTE(v11));
      emit_byte(a1, v11 & 0xFE);
      v12 = 0;
      v13 = a1 + 224;
      do
      {
        if (v25.i8[v12])
        {
          emit_byte(a1, v12);
          emit_byte(a1, *(_BYTE *)(v13 + v12) + 16 * *(_BYTE *)(v13 + v12 + 16));
        }
        if (v24.i8[v12])
        {
          emit_byte(a1, v12 + 16);
          emit_byte(a1, *(_BYTE *)(v13 + v12 + 32));
        }
        ++v12;
      }
      while (v12 != 16);
    }
  }
  else if (*(int *)(a1 + 372) >= 1)
  {
    v14 = 47;
    do
    {
      v15 = *(_QWORD *)(a1 + 8 * v14);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468))
        emit_dht((_QWORD *)a1, *(_DWORD *)(v15 + 20), 0);
      if (*(_DWORD *)(a1 + 464))
        emit_dht((_QWORD *)a1, *(_DWORD *)(v15 + 24), 1);
      v16 = v14 - 46;
      ++v14;
    }
    while (v16 < *(int *)(a1 + 372));
  }
  if (*(_DWORD *)(a1 + 316) != *(_DWORD *)(v2 + 56))
  {
    emit_byte(a1, 255);
    emit_byte(a1, 221);
    emit_byte(a1, 0);
    emit_byte(a1, 4);
    v17 = *(_DWORD *)(a1 + 316);
    emit_byte(a1, SBYTE1(v17));
    emit_byte(a1, v17);
    *(_DWORD *)(v2 + 56) = *(_DWORD *)(a1 + 316);
  }
  emit_byte(a1, 255);
  emit_byte(a1, 218);
  v18 = 2 * *(_DWORD *)(a1 + 372) + 6;
  emit_byte(a1, (unsigned __int16)(2 * *(_WORD *)(a1 + 372) + 6) >> 8);
  emit_byte(a1, v18 & 0xFE);
  emit_byte(a1, *(_DWORD *)(a1 + 372));
  if (*(int *)(a1 + 372) >= 1)
  {
    v19 = 0;
    do
    {
      v20 = *(_DWORD **)(a1 + 8 * v19 + 376);
      emit_byte(a1, *v20);
      if (*(_DWORD *)(a1 + 460) || *(_DWORD *)(a1 + 468))
        LOBYTE(v21) = 0;
      else
        v21 = v20[5];
      v22 = *(_DWORD *)(a1 + 464);
      if (v22)
        v22 = v20[6];
      emit_byte(a1, v22 + 16 * v21);
      ++v19;
    }
    while (v19 < *(int *)(a1 + 372));
  }
  emit_byte(a1, *(_DWORD *)(a1 + 460));
  emit_byte(a1, *(_DWORD *)(a1 + 464));
  return emit_byte(a1, *(_DWORD *)(a1 + 472) + 16 * *(_DWORD *)(a1 + 468));
}

uint64_t write_file_trailer(uint64_t a1)
{
  emit_byte(a1, 255);
  return emit_byte(a1, 217);
}

uint64_t write_tables_only(uint64_t a1)
{
  uint64_t i;
  uint64_t j;
  uint64_t v4;

  emit_byte(a1, 255);
  emit_byte(a1, 216);
  for (i = 0; i != 4; ++i)
  {
    if (*(_QWORD *)(a1 + 8 * i + 112))
      emit_dqt(a1, i);
  }
  if (!*(_DWORD *)(a1 + 292))
  {
    for (j = 0; j != 4; ++j)
    {
      v4 = a1 + 8 * j;
      if (*(_QWORD *)(v4 + 160))
        emit_dht((_QWORD *)a1, j, 0);
      if (*(_QWORD *)(v4 + 192))
        emit_dht((_QWORD *)a1, j, 1);
    }
  }
  emit_byte(a1, 255);
  return emit_byte(a1, 217);
}

uint64_t write_marker_header(uint64_t *a1, char a2, unsigned int a3)
{
  __int16 v3;
  uint64_t v6;
  __int16 v7;

  v3 = a3;
  if (a3 >= 0xFFFE)
  {
    v6 = *a1;
    *(_DWORD *)(v6 + 40) = 12;
    (*(void (**)(uint64_t *))v6)(a1);
  }
  emit_byte((uint64_t)a1, 255);
  emit_byte((uint64_t)a1, a2);
  v7 = v3 + 2;
  emit_byte((uint64_t)a1, SHIBYTE(v7));
  return emit_byte((uint64_t)a1, v7);
}

uint64_t emit_byte(uint64_t result, char a2)
{
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  v2 = *(_QWORD *)(result + 40);
  v3 = (_BYTE *)(*(_QWORD *)v2)++;
  *v3 = a2;
  v4 = *(_QWORD *)(v2 + 8) - 1;
  *(_QWORD *)(v2 + 8) = v4;
  if (!v4)
  {
    v5 = (uint64_t *)result;
    result = (*(uint64_t (**)(void))(v2 + 24))();
    if (!(_DWORD)result)
    {
      v6 = *v5;
      *(_DWORD *)(v6 + 40) = 25;
      return (*(uint64_t (**)(uint64_t *))v6)(v5);
    }
  }
  return result;
}

uint64_t emit_dqt(uint64_t a1, int a2)
{
  char v2;
  uint64_t v4;
  void (**v5)(_QWORD);
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;

  v2 = a2;
  v4 = *(_QWORD *)(a1 + 8 * a2 + 112);
  if (!v4)
  {
    v5 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v5 + 10) = 54;
    *((_DWORD *)v5 + 12) = a2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  v6 = *(unsigned int *)(a1 + 488);
  if ((v6 & 0x80000000) != 0)
  {
    v7 = 0;
  }
  else
  {
    LODWORD(v7) = 0;
    v8 = *(int **)(a1 + 480);
    v9 = v6 + 1;
    do
    {
      v10 = *v8++;
      if (*(unsigned __int16 *)(v4 + 2 * v10) > 0xFFu)
        v7 = 1;
      else
        v7 = v7;
      --v9;
    }
    while (v9);
  }
  if (!*(_DWORD *)(v4 + 128))
  {
    emit_byte(a1, 255);
    emit_byte(a1, 219);
    v11 = *(_DWORD *)(a1 + 488);
    v12 = 2 * v11 + 5;
    v13 = v11 + 4;
    if ((_DWORD)v7)
      v14 = v12;
    else
      v14 = v13;
    emit_byte(a1, SHIBYTE(v14));
    emit_byte(a1, v14);
    emit_byte(a1, v2 + 16 * v7);
    if ((*(_DWORD *)(a1 + 488) & 0x80000000) == 0)
    {
      v15 = 0;
      do
      {
        v16 = *(_WORD *)(v4 + 2 * *(int *)(*(_QWORD *)(a1 + 480) + 4 * v15));
        if ((_DWORD)v7)
          emit_byte(a1, SHIBYTE(v16));
        emit_byte(a1, v16);
      }
      while (v15++ < *(int *)(a1 + 488));
    }
    *(_DWORD *)(v4 + 128) = 1;
  }
  return v7;
}

uint64_t emit_sof(uint64_t a1, char a2)
{
  int v4;
  void (**v5)(_QWORD);
  int v6;
  int v7;
  uint64_t result;
  int v9;
  _DWORD *v10;

  emit_byte(a1, 255);
  emit_byte(a1, a2);
  v4 = 3 * *(_DWORD *)(a1 + 92) + 8;
  emit_byte(a1, (unsigned __int16)(3 * *(_WORD *)(a1 + 92) + 8) >> 8);
  emit_byte(a1, v4);
  if (*(_WORD *)(a1 + 86) || *(_DWORD *)(a1 + 80) >= 0x10000u)
  {
    v5 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v5 + 10) = 42;
    *((_DWORD *)v5 + 12) = 0xFFFF;
    (**(void (***)(uint64_t))a1)(a1);
  }
  emit_byte(a1, *(_DWORD *)(a1 + 88));
  v6 = *(_DWORD *)(a1 + 84);
  emit_byte(a1, SBYTE1(v6));
  emit_byte(a1, v6);
  v7 = *(_DWORD *)(a1 + 80);
  emit_byte(a1, SBYTE1(v7));
  emit_byte(a1, v7);
  result = emit_byte(a1, *(_DWORD *)(a1 + 92));
  if (*(int *)(a1 + 92) >= 1)
  {
    v9 = 0;
    v10 = *(_DWORD **)(a1 + 104);
    do
    {
      emit_byte(a1, *v10);
      emit_byte(a1, v10[3] + 16 * v10[2]);
      result = emit_byte(a1, v10[4]);
      ++v9;
      v10 += 24;
    }
    while (v9 < *(_DWORD *)(a1 + 92));
  }
  return result;
}

_QWORD *emit_dht(_QWORD *result, int a2, int a3)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t *v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  uint64_t (**v9)(_QWORD);
  uint8x16_t v10;
  uint16x8_t v11;
  uint16x8_t v12;
  uint64_t v13;
  char v14;
  uint64_t i;
  char *v16;
  char v17;

  v3 = (uint64_t)result;
  v4 = &result[a2];
  v5 = v4 + 24;
  v6 = v4 + 20;
  if (a3)
    v7 = a2 + 16;
  else
    v7 = a2;
  if (a3)
    v6 = v5;
  v8 = *v6;
  if (!*v6)
  {
    v9 = (uint64_t (**)(_QWORD))*result;
    *((_DWORD *)v9 + 10) = 52;
    *((_DWORD *)v9 + 12) = v7;
    result = (_QWORD *)(*(uint64_t (**)(_QWORD *))*result)(result);
  }
  if (!*(_DWORD *)(v8 + 276))
  {
    emit_byte(v3, 255);
    emit_byte(v3, 196);
    v10 = *(uint8x16_t *)(v8 + 1);
    v11 = vmovl_high_u8(v10);
    v12 = vmovl_u8(*(uint8x8_t *)v10.i8);
    v12.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v12.i8, *(uint16x4_t *)v11.i8), (int32x4_t)vaddl_high_u16(v12, v11)));
    v13 = v12.u32[0];
    v14 = v12.i8[0] + 19;
    emit_byte(v3, (unsigned __int16)(v12.i16[0] + 19) >> 8);
    emit_byte(v3, v14);
    emit_byte(v3, v7);
    for (i = 0; i != 16; ++i)
      result = (_QWORD *)emit_byte(v3, *(_BYTE *)(v8 + 1 + i));
    if ((_DWORD)v13)
    {
      v16 = (char *)(v8 + 17);
      do
      {
        v17 = *v16++;
        result = (_QWORD *)emit_byte(v3, v17);
        --v13;
      }
      while (v13);
    }
    *(_DWORD *)(v8 + 276) = 1;
  }
  return result;
}

uint64_t jpeg_calc_jpeg_dimensions(uint64_t result)
{
  int32x2_t *v1;
  uint64_t (**v2)(_QWORD);
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;

  v1 = (int32x2_t *)result;
  if (*(_BYTE *)(result + 51) || *(_BYTE *)(result + 55))
  {
    v2 = *(uint64_t (***)(_QWORD))result;
    *((_DWORD *)v2 + 10) = 42;
    *((_DWORD *)v2 + 12) = 65500;
    result = (**(uint64_t (***)(uint64_t))result)(result);
  }
  v3 = v1[9].u32[0];
  v4 = v1[59].i32[1];
  v5 = v4 * v1[9].i32[1];
  if (v3 >= v5)
  {
    v1[10] = vmul_s32(v1[6], vdup_n_s32(v4));
    v7 = 0x100000001;
  }
  else if (v5 <= 2 * v3)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 2);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 2);
    v1[10].i32[1] = result;
    v7 = 0x200000002;
  }
  else if (3 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 3);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 3);
    v1[10].i32[1] = result;
    v7 = 0x300000003;
  }
  else if (v5 <= 4 * v3)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 4);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 4);
    v1[10].i32[1] = result;
    v7 = 0x400000004;
  }
  else if (5 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 5);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 5);
    v1[10].i32[1] = result;
    v7 = 0x500000005;
  }
  else if (6 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 6);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 6);
    v1[10].i32[1] = result;
    v7 = 0x600000006;
  }
  else if (7 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 7);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 7);
    v1[10].i32[1] = result;
    v7 = 0x700000007;
  }
  else if (v5 <= 8 * v3)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 8);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 8);
    v1[10].i32[1] = result;
    v7 = 0x800000008;
  }
  else if (9 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 9);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 9);
    v1[10].i32[1] = result;
    v7 = 0x900000009;
  }
  else if (10 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 10);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 10);
    v1[10].i32[1] = result;
    v7 = 0xA0000000ALL;
  }
  else if (11 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 11);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 11);
    v1[10].i32[1] = result;
    v7 = 0xB0000000BLL;
  }
  else if (12 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 12);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 12);
    v1[10].i32[1] = result;
    v7 = 0xC0000000CLL;
  }
  else if (13 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 13);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 13);
    v1[10].i32[1] = result;
    v7 = 0xD0000000DLL;
  }
  else if (14 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 14);
    result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 14);
    v1[10].i32[1] = result;
    v7 = 0xE0000000ELL;
  }
  else
  {
    v6 = v1[6].u32[0] * v4;
    if (15 * v3 >= v5)
    {
      v1[10].i32[0] = jdiv_round_up(v6, 15);
      result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 15);
      v1[10].i32[1] = result;
      v7 = 0xF0000000FLL;
    }
    else
    {
      v1[10].i32[0] = jdiv_round_up(v6, 16);
      result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 16);
      v1[10].i32[1] = result;
      v7 = 0x1000000010;
    }
  }
  v1[45] = (int32x2_t)v7;
  return result;
}

uint64_t _cg_jinit_compress_master(uint64_t a1)
{
  int v2;
  void (**v3)(uint64_t);
  unsigned int v4;
  int v5;
  void (**v6)(uint64_t);
  void (**v7)(uint64_t);
  int v8;

  v2 = *(_DWORD *)(a1 + 88);
  if (v2 != 8)
  {
    v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 16;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (!*(_DWORD *)(a1 + 52) || (v4 = *(_DWORD *)(a1 + 48)) == 0 || (v5 = *(_DWORD *)(a1 + 56), v5 <= 0))
  {
    v6 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v6 + 10) = 33;
    (*v6)(a1);
    v4 = *(_DWORD *)(a1 + 48);
    v5 = *(_DWORD *)(a1 + 56);
  }
  if ((v5 * (unint64_t)v4) >> 32)
  {
    v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 72;
    (*v7)(a1);
  }
  jpeg_calc_jpeg_dimensions(a1);
  _cg_jinit_c_master_control((uint64_t *)a1, 0);
  if (!*(_DWORD *)(a1 + 288))
  {
    _cg_jinit_color_converter((uint64_t *)a1);
    _cg_jinit_downsampler((uint64_t *)a1);
    _cg_jinit_c_prep_controller((uint64_t *)a1, 0);
  }
  _cg_jinit_forward_dct(a1);
  if (*(_DWORD *)(a1 + 292))
    jinit_arith_encoder(a1);
  else
    _cg_jinit_huff_encoder(a1);
  v8 = *(int *)(a1 + 272) > 1 || *(_DWORD *)(a1 + 296) != 0;
  _cg_jinit_c_coef_controller(a1, v8);
  _cg_jinit_c_main_controller((int *)a1, 0);
  _cg_jinit_marker_writer(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 8) + 48))(a1);
  return (**(uint64_t (***)(uint64_t))(a1 + 528))(a1);
}

uint64_t _cg_jpeg_fdct_ifast(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int32x4_t v40;
  int32x4_t *v41;
  int32x4_t v42;
  int32x4_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int32x4_t v46;
  int32x4_t v47;
  int32x4_t v48;
  int32x4_t v49;
  int32x4_t v50;
  int32x4_t v51;
  int32x4_t v52;
  int32x4_t v53;
  int32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t v64;
  int32x4_t v65;
  int32x4_t v66;
  int32x4_t v67;
  int32x4_t v68;
  int32x4_t v69;
  int32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;

  v3 = 0;
  v4 = a3;
  do
  {
    v5 = (int *)(result + 4 * v3);
    v6 = (unsigned __int8 *)(*(_QWORD *)(a2 + v3) + v4);
    v7 = *v6;
    v8 = v6[7];
    v9 = v8 + v7;
    v10 = v7 - v8;
    v11 = v6[1];
    v12 = v6[6];
    v13 = v12 + v11;
    v14 = v11 - v12;
    v15 = v6[2];
    v16 = v6[5];
    v17 = v16 + v15;
    v18 = v15 - v16;
    v19 = v6[3];
    LODWORD(v6) = v6[4];
    v20 = (_DWORD)v6 + v19;
    LODWORD(v6) = v19 - (_DWORD)v6;
    v21 = v20 + v9;
    v22 = v9 - v20;
    v23 = v17 + v13;
    v24 = v13 - v17;
    v25 = v21 + v23 - 1024;
    v26 = v21 - v23;
    v27 = 181 * (v24 + v22);
    v28 = v22 + (v27 >> 8);
    v29 = v22 - (v27 >> 8);
    LODWORD(v6) = (_DWORD)v6 + v18;
    v30 = v18 + v14;
    v31 = v14 + v10;
    v32 = (98 * ((int)v6 - v31)) >> 8;
    LODWORD(v6) = v32 + ((139 * (int)v6) >> 8);
    v33 = v32 + ((334 * v31) >> 8);
    v30 *= 181;
    v34 = v10 - (v30 >> 8);
    v5[4] = v26;
    v5[5] = (_DWORD)v6 + v34;
    v5[2] = v28;
    v5[3] = v34 - (_DWORD)v6;
    LODWORD(v6) = v10 + (v30 >> 8);
    *v5 = v25;
    v5[1] = v33 + (_DWORD)v6;
    v5[6] = v29;
    v5[7] = (_DWORD)v6 - v33;
    v3 += 8;
  }
  while (v3 != 64);
  v35 = result + 224;
  v36 = -32;
  v37.i64[0] = 0xB5000000B5;
  v37.i64[1] = 0xB5000000B5;
  v38.i64[0] = 0x6200000062;
  v38.i64[1] = 0x6200000062;
  v39.i64[0] = 0x8B0000008BLL;
  v39.i64[1] = 0x8B0000008BLL;
  v40 = vdupq_n_s32(0x14Eu);
  do
  {
    v41 = (int32x4_t *)(v35 + v36);
    v42 = *(int32x4_t *)(v35 + v36 - 192);
    v43 = *(int32x4_t *)(v35 + v36 + 32);
    v44 = vaddq_s32(v43, v42);
    v45 = vsubq_s32(v42, v43);
    v46 = *(int32x4_t *)(v35 + v36 - 160);
    v47 = *(int32x4_t *)(v35 + v36);
    v48 = vaddq_s32(v47, v46);
    v49 = vsubq_s32(v46, v47);
    v50 = *(int32x4_t *)(v35 + v36 - 128);
    v51 = *(int32x4_t *)(v35 + v36 - 32);
    v52 = vaddq_s32(v51, v50);
    v53 = vsubq_s32(v50, v51);
    v54 = *(int32x4_t *)(v35 + v36 - 96);
    v55 = *(int32x4_t *)(v35 + v36 - 64);
    v56 = vaddq_s32(v55, v54);
    v57 = vsubq_s32(v54, v55);
    v58 = vaddq_s32(v56, v44);
    v59 = vsubq_s32(v44, v56);
    v60 = vaddq_s32(v52, v48);
    v41[-12] = vaddq_s32(v58, v60);
    v41[-4] = vsubq_s32(v58, v60);
    v61 = vaddq_s32(vsubq_s32(v48, v52), v59);
    v62 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v61.i8, (int32x2_t)0xB5000000B5), 8uLL), vmull_high_s32(v61, v37), 8uLL);
    v41[-8] = vaddq_s32(v59, v62);
    *v41 = vsubq_s32(v59, v62);
    v63 = vaddq_s32(v57, v53);
    v64 = vaddq_s32(v53, v49);
    v65 = vaddq_s32(v49, v45);
    v66 = vsubq_s32(v63, v65);
    v67 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v66.i8, (int32x2_t)0x6200000062), 8uLL), vmull_high_s32(v66, v38), 8uLL);
    v68 = vaddq_s32(v67, vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v63.i8, (int32x2_t)0x8B0000008BLL), 8uLL), vmull_high_s32(v63, v39), 8uLL));
    v69 = vaddq_s32(v67, vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v65.i8, *(int32x2_t *)v40.i8), 8uLL), vmull_high_s32(v65, v40), 8uLL));
    v70 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v64.i8, (int32x2_t)0xB5000000B5), 8uLL), vmull_high_s32(v64, v37), 8uLL);
    v71 = vaddq_s32(v45, v70);
    v72 = vsubq_s32(v45, v70);
    v41[-2] = vaddq_s32(v68, v72);
    v41[-6] = vsubq_s32(v72, v68);
    v41[-10] = vaddq_s32(v69, v71);
    v41[2] = vsubq_s32(v71, v69);
    v36 += 16;
  }
  while (v36);
  return result;
}

uint64_t _cg_jinit_2pass_quantizer(uint64_t a1)
{
  uint64_t v2;
  void (**v3)(uint64_t);
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  int v7;
  int v8;
  void (**v9)(uint64_t);

  v2 = (**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 656) = v2;
  *(_QWORD *)v2 = start_pass_2_quant;
  *(_QWORD *)(v2 + 24) = new_color_map_2_quant;
  *(_QWORD *)(v2 + 64) = 0;
  *(_QWORD *)(v2 + 80) = 0;
  if (*(_DWORD *)(a1 + 144) != 3)
  {
    v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 48;
    (*v3)(a1);
  }
  v4 = 0;
  *(_QWORD *)(v2 + 48) = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 256);
  do
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 8))(a1, 1, 4096);
    *(_QWORD *)(*(_QWORD *)(v2 + 48) + v4) = result;
    v4 += 8;
  }
  while (v4 != 256);
  *(_DWORD *)(v2 + 56) = 1;
  if (!*(_DWORD *)(a1 + 132))
  {
    *(_QWORD *)(v2 + 32) = 0;
    goto LABEL_13;
  }
  v6 = *(unsigned int *)(a1 + 120);
  if ((int)v6 < 8)
  {
    v7 = 8;
    v8 = 58;
LABEL_11:
    v9 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v9 + 10) = v8;
    *((_DWORD *)v9 + 12) = v7;
    (**(void (***)(uint64_t))a1)(a1);
    goto LABEL_12;
  }
  if (v6 >= 0x101)
  {
    v7 = 256;
    v8 = 59;
    goto LABEL_11;
  }
LABEL_12:
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 16))(a1, 1, v6, 3);
  *(_QWORD *)(v2 + 32) = result;
  *(_DWORD *)(v2 + 40) = v6;
LABEL_13:
  if (*(_DWORD *)(a1 + 112))
  {
    *(_DWORD *)(a1 + 112) = 2;
    *(_QWORD *)(v2 + 64) = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 8))(a1, 1, 6 * (*(_DWORD *)(a1 + 136) + 2));
    return init_error_limit(a1);
  }
  return result;
}

void start_pass_2_quant(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  int v6;
  int v7;
  int v8;
  void (**v9)(_QWORD);
  size_t v10;
  void *v11;
  uint64_t i;

  v3 = *(_QWORD *)(a1 + 656);
  v4 = *(_QWORD *)(v3 + 48);
  if (*(_DWORD *)(a1 + 112))
  {
    *(_DWORD *)(a1 + 112) = 2;
    if (!a2)
    {
      v5 = pass2_fs_dither;
      goto LABEL_7;
    }
LABEL_5:
    *(_QWORD *)(v3 + 8) = prescan_quantize;
    *(_QWORD *)(v3 + 16) = finish_pass1;
    *(_DWORD *)(v3 + 56) = 1;
    goto LABEL_18;
  }
  if (a2)
    goto LABEL_5;
  v5 = pass2_no_dither;
LABEL_7:
  *(_QWORD *)(v3 + 8) = v5;
  *(_QWORD *)(v3 + 16) = finish_pass2;
  v6 = *(_DWORD *)(a1 + 156);
  if (v6 < 1)
  {
    v7 = 1;
    v8 = 58;
  }
  else
  {
    if (v6 < 0x101)
      goto LABEL_12;
    v7 = 256;
    v8 = 59;
  }
  v9 = *(void (***)(_QWORD))a1;
  *((_DWORD *)v9 + 10) = v8;
  *((_DWORD *)v9 + 12) = v7;
  (**(void (***)(uint64_t))a1)(a1);
LABEL_12:
  if (*(_DWORD *)(a1 + 112) == 2)
  {
    v10 = 6 * (*(_DWORD *)(a1 + 136) + 2);
    v11 = *(void **)(v3 + 64);
    if (!v11)
    {
      v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, size_t))(*(_QWORD *)(a1 + 8) + 8))(a1, 1, v10);
      *(_QWORD *)(v3 + 64) = v11;
    }
    bzero(v11, v10);
    if (!*(_QWORD *)(v3 + 80))
      init_error_limit(a1);
    *(_DWORD *)(v3 + 72) = 0;
  }
LABEL_18:
  if (*(_DWORD *)(v3 + 56))
  {
    for (i = 0; i != 256; i += 8)
      bzero(*(void **)(v4 + i), 0x1000uLL);
    *(_DWORD *)(v3 + 56) = 0;
  }
}

uint64_t new_color_map_2_quant(uint64_t result)
{
  *(_DWORD *)(*(_QWORD *)(result + 656) + 56) = 1;
  return result;
}

uint64_t init_error_limit(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;

  v1 = *(_QWORD *)(a1 + 656);
  result = (**(uint64_t (***)(void))(a1 + 8))();
  v3 = 0;
  v4 = 0;
  v5 = result + 1020;
  *(_QWORD *)(v1 + 80) = result + 1020;
  do
  {
    *(_DWORD *)(v5 + 4 * v4) = v4;
    *(_DWORD *)(v5 + 4 * v3) = v3;
    ++v4;
    --v3;
  }
  while (v4 != 16);
  v6 = 16;
  v7 = 271;
  v8 = 956;
  do
  {
    *(_DWORD *)(result + 4 * v7) = v6;
    *(_DWORD *)(result + v8) = -v6;
    v6 += (((_DWORD)v7++ - 254) & 1) == 0;
    v8 -= 4;
  }
  while (v7 != 303);
  v9 = 1212;
  for (i = 828; i != -4; i -= 4)
  {
    *(_DWORD *)(result + v9) = 32;
    *(_DWORD *)(result + i) = -32;
    v9 += 4;
  }
  return result;
}

uint64_t prescan_quantize(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  _BYTE *v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  int v11;

  if (a4 >= 1)
  {
    v4 = 0;
    v5 = *(_QWORD *)(*(_QWORD *)(result + 656) + 48);
    v6 = *(_DWORD *)(result + 136);
    do
    {
      if (v6)
      {
        v7 = *(_BYTE **)(a2 + 8 * v4);
        v8 = v6;
        do
        {
          v9 = *(_QWORD *)(v5 + (*v7 & 0xF8)) + ((16 * v7[1]) & 0xFC0);
          v10 = ((unint64_t)v7[2] >> 2) & 0x3E;
          v11 = *(unsigned __int16 *)(v9 + v10);
          if (((v11 + 1) & 0x10000) == 0)
            LOWORD(v11) = v11 + 1;
          *(_WORD *)(v9 + v10) = v11;
          v7 += 3;
          --v8;
        }
        while (v8);
      }
      ++v4;
    }
    while (v4 != a4);
  }
  return result;
}

uint64_t finish_pass1(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _DWORD *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  _BOOL4 v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  int *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  int v46;
  unsigned __int16 *v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t result;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v2 = *(_QWORD *)(a1 + 656);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(v2 + 32);
  v56 = v2;
  v3 = *(_DWORD *)(v2 + 40);
  v4 = (**(uint64_t (***)(void))(a1 + 8))();
  *(_OWORD *)v4 = xmmword_18820E730;
  *(_QWORD *)(v4 + 16) = 0x1F00000000;
  v58 = v4;
  v59 = a1;
  update_box(a1, v4);
  v5 = 1;
  if (v3 < 2)
    goto LABEL_35;
  v6 = 1;
  while (1)
  {
    if (v3 >= (unint64_t)(2 * v6))
    {
      v7 = 0;
      v12 = 0;
      v13 = v6;
      v10 = v58;
      v14 = v58;
      do
      {
        if (*(_QWORD *)(v14 + 32) > v12 && *(uint64_t *)(v14 + 24) > 0)
        {
          v12 = *(_QWORD *)(v14 + 32);
          v7 = v14;
        }
        v14 += 40;
        --v13;
      }
      while (v13);
    }
    else
    {
      v7 = 0;
      v8 = 0;
      v9 = v6;
      v10 = v58;
      v11 = v58;
      do
      {
        if (*(_QWORD *)(v11 + 24) > v8)
        {
          v8 = *(_QWORD *)(v11 + 24);
          v7 = v11;
        }
        v11 += 40;
        --v9;
      }
      while (v9);
    }
    if (!v7)
      break;
    v15 = v10 + 40 * v6;
    *(_DWORD *)(v15 + 20) = *(_DWORD *)(v7 + 20);
    *(_OWORD *)v15 = *(_OWORD *)v7;
    v16 = *(_DWORD *)(v7 + 20);
    *(_DWORD *)(v15 + 16) = *(_DWORD *)(v7 + 16);
    v17 = (_DWORD *)(v15 + 16);
    v19 = *(_DWORD *)v7;
    v18 = *(_DWORD *)(v7 + 4);
    v20 = 16 * (v18 - *(_DWORD *)v7);
    v22 = *(_DWORD *)(v7 + 8);
    v21 = *(_DWORD *)(v7 + 12);
    v23 = *(_DWORD *)(v7 + 16);
    v24 = v20 <= 12 * (v21 - v22);
    if (v20 <= 12 * (v21 - v22))
      v20 = 12 * (v21 - v22);
    if (v20 >= 8 * (v16 - v23))
      v25 = v24;
    else
      v25 = 2;
    if (v25 == 2)
    {
      v28 = v23 + v16;
      if (v23 + v16 < 0 != __OFADD__(v23, v16))
        ++v28;
      v27 = v28 >> 1;
      *(_DWORD *)(v7 + 20) = v27;
    }
    else if (v25 == 1)
    {
      v17 = (_DWORD *)(v10 + 40 * v6 + 8);
      v29 = v22 + v21;
      if (v22 + v21 < 0 != __OFADD__(v22, v21))
        ++v29;
      v27 = v29 >> 1;
      *(_DWORD *)(v7 + 12) = v27;
    }
    else
    {
      v26 = v19 + v18;
      if (v19 + v18 < 0 != __OFADD__(v19, v18))
        ++v26;
      v27 = v26 >> 1;
      *(_DWORD *)(v7 + 4) = v26 >> 1;
      v17 = (_DWORD *)(v10 + 40 * v6);
    }
    *v17 = v27 + 1;
    update_box(a1, v7);
    update_box(a1, v15);
    if (++v6 == v3)
      goto LABEL_34;
  }
  v3 = v6;
LABEL_34:
  v5 = v3;
  if (v3 >= 1)
  {
LABEL_35:
    v30 = 0;
    v55 = v5;
    v57 = v5;
    do
    {
      v31 = (int *)(v58 + 40 * v30);
      v32 = v31[1];
      v33 = *v31;
      if ((int)v33 <= v32)
      {
        v37 = 0;
        v36 = 0;
        v35 = 0;
        v34 = 0;
        v38 = (int *)(v58 + 40 * v30);
        v39 = v38[5];
        v40 = v38[4];
        v41 = v38[3];
        v42 = v38[2];
        v43 = v32 + 1;
        do
        {
          if ((int)v42 <= v41)
          {
            v44 = v42;
            do
            {
              if ((int)v40 <= v39)
              {
                v45 = (8 * v40) | 4;
                v46 = v39 - v40 + 1;
                v47 = (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v59 + 656) + 48) + 8 * v33)
                                         + (v44 << 6)
                                         + 2 * v40);
                do
                {
                  v48 = *v47++;
                  v49 = v34 + v48;
                  v50 = v35 + (int)v48 * (uint64_t)(int)((8 * v33) | 4);
                  v51 = v36 + (int)v48 * (uint64_t)(int)((4 * v44) | 2);
                  v52 = v37 + (int)v48 * (uint64_t)v45;
                  if (v48)
                  {
                    v34 = v49;
                    v35 = v50;
                    v36 = v51;
                    v37 = v52;
                  }
                  v45 += 8;
                  --v46;
                }
                while (v46);
              }
              ++v44;
            }
            while (v41 + 1 != (_DWORD)v44);
          }
          ++v33;
        }
        while (v43 != (_DWORD)v33);
      }
      else
      {
        v34 = 0;
        v35 = 0;
        v36 = 0;
        v37 = 0;
      }
      *(_BYTE *)(**(_QWORD **)(v59 + 160) + v30) = (v35 + (v34 >> 1)) / v34;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v59 + 160) + 8) + v30) = (v36 + (v34 >> 1)) / v34;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v59 + 160) + 16) + v30++) = (v37 + (v34 >> 1)) / v34;
    }
    while (v30 != v57);
    v5 = v55;
  }
  *(_DWORD *)(v59 + 156) = v5;
  v53 = *(_QWORD *)v59;
  *(_DWORD *)(v53 + 40) = 98;
  *(_DWORD *)(v53 + 48) = v5;
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v59 + 8))(v59, 1);
  *(_DWORD *)(v56 + 56) = 1;
  return result;
}

uint64_t pass2_fs_dither(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE *v14;
  int v15;
  _WORD *v16;
  int v17;
  uint64_t v18;
  int v19;
  __int16 v20;
  __int16 v21;
  __int16 v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;
  int v26;
  int v27;
  unsigned __int8 *v28;
  _WORD *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  _WORD *v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  __int16 v40;
  __int16 v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  __int16 v58;
  __int16 v59;
  uint64_t v60;
  uint64_t v61;
  __int16 v62;
  __int16 v63;
  __int16 v64;

  v56 = result;
  if (a4 >= 1)
  {
    v4 = 0;
    v5 = *(_QWORD *)(result + 656);
    v6 = *(_QWORD *)(v5 + 48);
    v7 = *(_DWORD *)(result + 136);
    result = *(_QWORD *)(result + 440);
    v8 = *(_QWORD *)(v5 + 80);
    v9 = *(uint64_t **)(v56 + 160);
    v10 = *v9;
    v11 = v9[1];
    v12 = v9[2];
    v44 = (v7 - 1);
    v42 = (3 * v7 + 3);
    v43 = (3 * v7 - 3);
    v45 = a4;
    v47 = *(_QWORD *)(v56 + 656);
    v46 = *(_DWORD *)(v56 + 136);
    v54 = *v9;
    v55 = *(_QWORD *)(v56 + 440);
    v52 = v12;
    v53 = v6;
    v51 = v8;
    do
    {
      v13 = *(_QWORD *)(a2 + 8 * v4);
      v14 = *(_BYTE **)(a3 + 8 * v4);
      v50 = v4;
      if (*(_DWORD *)(v5 + 72))
      {
        v15 = 0;
        v13 += v43;
        v14 += v44;
        v16 = (_WORD *)(*(_QWORD *)(v5 + 64) + 2 * v42);
        v17 = -3;
        v18 = -1;
      }
      else
      {
        v16 = *(_WORD **)(v5 + 64);
        v17 = 3;
        v15 = 1;
        v18 = 1;
      }
      *(_DWORD *)(v5 + 72) = v15;
      if (v7)
      {
        v19 = 0;
        v20 = 0;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v60 = v17;
        v61 = v17;
        v28 = (unsigned __int8 *)(v13 + 2);
        v29 = v16;
        v57 = v18;
        do
        {
          v62 = v23;
          v63 = v22;
          v64 = v21;
          v16 = &v29[v60];
          v30 = *(unsigned __int8 *)(result
                                   + *(int *)(v8 + 4 * ((v19 + (__int16)v29[v60] + 8) >> 4))
                                   + (unint64_t)*(v28 - 2));
          v31 = *(unsigned __int8 *)(result
                                   + *(int *)(v8 + 4 * ((v27 + (__int16)v29[v60 + 1] + 8) >> 4))
                                   + (unint64_t)*(v28 - 1));
          v32 = *(unsigned __int8 *)(result
                                   + *(int *)(v8 + 4 * ((v26 + (__int16)v29[v60 + 2] + 8) >> 4))
                                   + (unint64_t)*v28);
          v33 = (_WORD *)(*(_QWORD *)(v6 + 8 * (v30 >> 3)) + (v31 >> 2 << 6) + 2 * (v32 >> 3));
          v34 = (unsigned __int16)*v33;
          if (!*v33)
          {
            v35 = v11;
            v59 = v24;
            v58 = v25;
            fill_inverse_cmap(v56, v30 >> 3, v31 >> 2, v32 >> 3);
            v25 = v58;
            v24 = v59;
            v8 = v51;
            v12 = v52;
            v11 = v35;
            v18 = v57;
            v10 = v54;
            result = v55;
            v6 = v53;
            v34 = (unsigned __int16)*v33;
          }
          v36 = v34 - 1;
          *v14 = v36;
          v37 = v30 - *(unsigned __int8 *)(v10 + v36);
          v38 = v31 - *(unsigned __int8 *)(v11 + v36);
          v39 = v32 - *(unsigned __int8 *)(v12 + v36);
          v22 = 5 * v37 + v25;
          v40 = 3 * (v31 - *(unsigned __int8 *)(v11 + v36)) + v64;
          v21 = 5 * v38 + v24;
          v41 = 3 * (v32 - *(unsigned __int8 *)(v12 + v36)) + v20;
          v19 = 7 * v37;
          v20 = 5 * v39 + v62;
          v27 = 7 * v38;
          *v29 = 3 * (v30 - *(unsigned __int8 *)(v10 + v36)) + v63;
          v29[1] = v40;
          v26 = 7 * v39;
          v14 += v18;
          v28 += v61;
          v29[2] = v41;
          v29 = (_WORD *)((char *)v29 + v60 * 2);
          v23 = v39;
          v24 = v38;
          v25 = v37;
          --v7;
        }
        while (v7);
      }
      else
      {
        v22 = 0;
        v21 = 0;
        v20 = 0;
      }
      *v16 = v22;
      v16[1] = v21;
      v16[2] = v20;
      v4 = v50 + 1;
      v5 = v47;
      v7 = v46;
    }
    while (v50 + 1 != v45);
  }
  return result;
}

void pass2_no_dither(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  _BYTE *v10;
  unsigned __int8 *v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  __int16 *v16;
  __int16 v17;

  if (a4 >= 1)
  {
    v6 = 0;
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 656) + 48);
    v8 = *(_DWORD *)(a1 + 136);
    v9 = a4;
    do
    {
      if (v8)
      {
        v10 = *(_BYTE **)(a3 + 8 * v6);
        v11 = *(unsigned __int8 **)(a2 + 8 * v6);
        v12 = v8;
        do
        {
          v13 = (unint64_t)*v11 >> 3;
          v14 = (unint64_t)v11[1] >> 2;
          v15 = (unint64_t)v11[2] >> 3;
          v16 = (__int16 *)(*(_QWORD *)(v7 + 8 * v13) + (v14 << 6) + 2 * v15);
          v17 = *v16;
          if (!*v16)
          {
            fill_inverse_cmap(a1, v13, v14, v15);
            LOBYTE(v17) = *(_BYTE *)v16;
          }
          *v10++ = v17 - 1;
          v11 += 3;
          --v12;
        }
        while (v12);
      }
      ++v6;
    }
    while (v6 != v9);
  }
}

uint64_t update_box(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _WORD *v13;
  int v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  _WORD *v18;
  int v19;
  uint64_t v20;
  _WORD *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  _WORD *v25;
  int v26;
  uint64_t v27;
  _WORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  _WORD *v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  unsigned __int16 *v37;
  int v38;

  v2 = *(_QWORD *)(*(_QWORD *)(result + 656) + 48);
  LODWORD(v4) = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 12);
  v7 = v5;
  v8 = *(_DWORD *)(a2 + 16);
  v9 = *(_DWORD *)(a2 + 20);
  v10 = v8;
  if (v3 > *(_DWORD *)a2)
  {
    v11 = (int)v4;
    result = (v6 + 1);
    while (v5 > v6)
    {
LABEL_4:
      if (v3 + 1 == (_DWORD)++v11)
        goto LABEL_14;
    }
    v12 = v5;
    while (v8 > v9)
    {
LABEL_11:
      if ((_DWORD)result == (_DWORD)++v12)
        goto LABEL_4;
    }
    v13 = (_WORD *)(*(_QWORD *)(v2 + 8 * v11) + (v12 << 6) + 2 * v8);
    v14 = v9 - v8 + 1;
    while (!*v13)
    {
      ++v13;
      if (!--v14)
        goto LABEL_11;
    }
    *(_DWORD *)a2 = v11;
    LODWORD(v4) = v11;
  }
LABEL_14:
  if (v3 > (int)v4)
  {
    v15 = v3;
    result = (v6 + 1);
    while (v5 > v6)
    {
LABEL_17:
      v16 = v15-- <= (int)v4;
      if (v16)
        goto LABEL_28;
    }
    v17 = v5;
    while (v8 > v9)
    {
LABEL_25:
      if ((_DWORD)result == (_DWORD)++v17)
        goto LABEL_17;
    }
    v18 = (_WORD *)(*(_QWORD *)(v2 + 8 * v15) + (v17 << 6) + 2 * v8);
    v19 = v9 - v8 + 1;
    while (!*v18)
    {
      ++v18;
      if (!--v19)
        goto LABEL_25;
    }
    *(_DWORD *)(a2 + 4) = v15;
    v3 = v15;
  }
LABEL_28:
  if (v6 > v5)
  {
    result = (v3 + 1);
    while (v3 < (int)v4)
    {
LABEL_31:
      if (v6 + 1 == (_DWORD)++v7)
        goto LABEL_41;
    }
    v20 = (int)v4;
    while (v8 > v9)
    {
LABEL_38:
      if ((_DWORD)result == (_DWORD)++v20)
        goto LABEL_31;
    }
    v21 = (_WORD *)(*(_QWORD *)(v2 + 8 * v20) + (v7 << 6) + 2 * v8);
    v22 = v9 - v8 + 1;
    while (!*v21)
    {
      ++v21;
      if (!--v22)
        goto LABEL_38;
    }
    *(_DWORD *)(a2 + 8) = v7;
    v5 = v7;
  }
LABEL_41:
  if (v6 > v5)
  {
    v23 = v6;
    result = (v3 + 1);
    while (v3 < (int)v4)
    {
LABEL_44:
      v16 = v23-- <= v5;
      if (v16)
        goto LABEL_55;
    }
    v24 = (int)v4;
    while (v8 > v9)
    {
LABEL_52:
      if ((_DWORD)result == (_DWORD)++v24)
        goto LABEL_44;
    }
    v25 = (_WORD *)(*(_QWORD *)(v2 + 8 * v24) + (v23 << 6) + 2 * v8);
    v26 = v9 - v8 + 1;
    while (!*v25)
    {
      ++v25;
      if (!--v26)
        goto LABEL_52;
    }
    *(_DWORD *)(a2 + 12) = v23;
    v6 = v23;
  }
LABEL_55:
  if (v9 > v8)
  {
    result = (v3 + 1);
    while (v3 < (int)v4)
    {
LABEL_58:
      if (v9 + 1 == (_DWORD)++v10)
        goto LABEL_68;
    }
    v27 = (int)v4;
    while (v6 < v5)
    {
LABEL_65:
      if ((_DWORD)result == (_DWORD)++v27)
        goto LABEL_58;
    }
    v28 = (_WORD *)(*(_QWORD *)(v2 + 8 * v27) + ((uint64_t)v5 << 6) + 2 * v10);
    v29 = v6 - v5 + 1;
    while (!*v28)
    {
      v28 += 32;
      if (!--v29)
        goto LABEL_65;
    }
    *(_DWORD *)(a2 + 16) = v10;
    v8 = v10;
  }
LABEL_68:
  if (v9 > v8)
  {
    v30 = v9;
    result = (v3 + 1);
    while (v3 < (int)v4)
    {
LABEL_71:
      v16 = v30-- <= v8;
      if (v16)
        goto LABEL_82;
    }
    v31 = (int)v4;
    while (v6 < v5)
    {
LABEL_79:
      if ((_DWORD)result == (_DWORD)++v31)
        goto LABEL_71;
    }
    v32 = (_WORD *)(*(_QWORD *)(v2 + 8 * v31) + ((uint64_t)v5 << 6) + 2 * v30);
    v33 = v6 - v5 + 1;
    while (!*v32)
    {
      v32 += 32;
      if (!--v33)
        goto LABEL_79;
    }
    *(_DWORD *)(a2 + 20) = v30;
    v9 = v30;
  }
LABEL_82:
  *(_QWORD *)(a2 + 24) = 12 * (v6 - v5) * (uint64_t)(12 * (v6 - v5))
                       + 16 * (v3 - (int)v4) * (uint64_t)(16 * (v3 - (int)v4))
                       + 8 * (v9 - v8) * (uint64_t)(8 * (v9 - v8));
  v34 = 0;
  if (v3 >= (int)v4)
  {
    result = (v6 + 1);
    v4 = (int)v4;
    v35 = v3 + 1;
    do
    {
      if (v6 >= v5)
      {
        v36 = v5;
        do
        {
          if (v9 >= v8)
          {
            v37 = (unsigned __int16 *)(*(_QWORD *)(v2 + 8 * v4) + (v36 << 6) + 2 * v8);
            v38 = v9 - v8 + 1;
            do
            {
              if (*v37++)
                ++v34;
              --v38;
            }
            while (v38);
          }
          ++v36;
        }
        while ((_DWORD)result != (_DWORD)v36);
      }
      ++v4;
    }
    while (v35 != (_DWORD)v4);
  }
  *(_QWORD *)(a2 + 32) = v34;
  return result;
}

void fill_inverse_cmap(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  signed int v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  _QWORD *v62;
  _BYTE *v63;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _OWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t i;
  _OWORD v77[8];
  _OWORD v78[16];
  _QWORD __b[258];

  __b[256] = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 656) + 48);
  memset(v78, 0, sizeof(v78));
  memset(v77, 0, sizeof(v77));
  v9 = *(unsigned int *)(a1 + 156);
  bzero(__b, 0x800uLL);
  if ((int)v9 <= 0)
    goto LABEL_43;
  v10 = 0;
  v11 = (32 * (a2 >> 2)) | 4;
  v12 = 4 * a3;
  v13 = v12 & 0xFFFFFFFFFFFFFFE0 | 2;
  v14 = 8 * (int)a4;
  v15 = v14 & 0xFFFFFFFFFFFFFFE0 | 4;
  v16 = (8 * a2) | 0x1C;
  v17 = v12 | 0x1E;
  v18 = (v13 + (v12 | 0x1E)) >> 1;
  v19 = v14 | 0x1C;
  v20 = *(uint64_t **)(a1 + 160);
  v21 = *v20;
  v22 = v20[1];
  v23 = v20[2];
  v24 = 0x7FFFFFFFLL;
  do
  {
    v25 = *(unsigned __int8 *)(v21 + v10);
    v26 = v25 - v11;
    if (v25 < v11)
    {
      v27 = 2 * v26 * (uint64_t)(2 * v26);
      v26 = v25 - v16;
LABEL_9:
      v29 = 2 * v26;
      goto LABEL_10;
    }
    v28 = v25 - v16;
    if (v25 > v16)
    {
      v27 = 2 * v28 * (uint64_t)(2 * v28);
      goto LABEL_9;
    }
    if ((v11 + v16) >> 1 < v25)
    {
      v27 = 0;
      goto LABEL_9;
    }
    v27 = 0;
    v29 = 2 * v28;
LABEL_10:
    v30 = v29 * (uint64_t)v29;
    v31 = *(unsigned __int8 *)(v22 + v10);
    v32 = 3 * (v31 - (int)v13) * 3 * (v31 - (int)v13);
    v33 = 3 * (v31 - (int)v17);
    v34 = v33 * v33;
    if (v18 < v31)
      v34 = 3 * (v31 - (int)v13) * 3 * (v31 - (int)v13);
    v35 = v27 + v33 * v33;
    if ((int)v31 <= (int)v17)
    {
      v35 = v27;
      v32 = v34;
    }
    v36 = v27 + 3 * (v31 - v13) * 3 * (v31 - v13);
    if ((int)v31 < (int)v13)
    {
      v37 = 3 * (v31 - v17) * 3 * (v31 - v17);
    }
    else
    {
      v36 = v35;
      v37 = v32;
    }
    v38 = v37 + v30;
    v39 = *(unsigned __int8 *)(v23 + v10);
    v40 = (v39 - (int)v15) * (v39 - (int)v15);
    v41 = v39 - (int)v19;
    v42 = v41 * v41;
    if ((v15 + v19) >> 1 < v39)
      v42 = (v39 - (int)v15) * (v39 - (int)v15);
    v43 = v36 + v41 * v41;
    if ((int)v39 <= (int)v19)
    {
      v43 = v36;
      v40 = v42;
    }
    v44 = v36 + (v39 - v15) * (v39 - v15);
    if ((int)v39 < (int)v15)
    {
      v45 = (v39 - v19) * (v39 - v19);
    }
    else
    {
      v44 = v43;
      v45 = v40;
    }
    v46 = v38 + v45;
    __b[v10] = v44;
    if (v46 < v24)
      v24 = v46;
    ++v10;
  }
  while (v9 != v10);
  v47 = 0;
  v48 = 0;
  do
  {
    if (__b[v47] <= v24)
      *((_BYTE *)v78 + v48++) = v47;
    ++v47;
  }
  while (v9 != v47);
  memset_pattern16(__b, &unk_18820E740, 0x400uLL);
  if (v48 >= 1)
  {
    v49 = 0;
    v50 = (int)v13;
    v51 = (int)v15;
    do
    {
      v52 = *((unsigned __int8 *)v78 + v49);
      v53 = *(_QWORD **)(a1 + 160);
      v54 = 2 * (v11 - *(unsigned __int8 *)(*v53 + v52));
      v55 = v50 - *(unsigned __int8 *)(v53[1] + v52);
      v56 = v51 - *(unsigned __int8 *)(v53[2] + v52);
      v57 = 3 * v55 * 3 * v55 + v54 * (uint64_t)v54 + v56 * v56;
      v58 = 32 * v54 + 256;
      v59 = 72 * v55 + 144;
      v60 = 16 * v56 + 64;
      v61 = 3;
      v62 = __b;
      v63 = v77;
      do
      {
        v64 = v61;
        v65 = 7;
        v66 = v59;
        v67 = v57;
        do
        {
          v68 = 0;
          v69 = v65;
          v70 = v60;
          v71 = v67;
          do
          {
            if (v71 < v62[v68])
            {
              v62[v68] = v71;
              *v63 = v52;
            }
            v71 += v70;
            v70 += 128;
            ++v63;
            ++v68;
          }
          while ((_DWORD)(v68 * 8) != 32);
          v67 += v66;
          v66 += 288;
          v65 = v69 - 1;
          v62 = (_QWORD *)((char *)v62 + v68 * 8);
        }
        while (v69);
        v57 += v58;
        v58 += 512;
        v61 = v64 - 1;
      }
      while (v64);
      ++v49;
    }
    while (v49 != v48);
  }
LABEL_43:
  v72 = 0;
  v73 = v77;
  do
  {
    v74 = 0;
    v75 = *(_QWORD *)(v8 + 8 * (v72 + (int)(a2 & 0xFFFFFFFC)))
        + ((2 * a4) & 0x1FFFFFFF8)
        + ((uint64_t)(int)(a3 & 0xFFFFFFF8) << 6);
    do
    {
      for (i = 0; i != 4; ++i)
        *(_WORD *)(v75 + 2 * i) = *((unsigned __int8 *)v73 + i) + 1;
      ++v74;
      v75 += 64;
      v73 = (_OWORD *)((char *)v73 + 4);
    }
    while (v74 != 8);
    ++v72;
  }
  while (v72 != 4);
}

uint64_t _cg_jpeg_CreateDecompress(char *a1, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;

  *((_QWORD *)a1 + 1) = 0;
  if (a2 != 90)
  {
    v5 = *(_QWORD *)a1;
    *(_DWORD *)(v5 + 40) = 13;
    *(_DWORD *)(v5 + 48) = 90;
    *(_DWORD *)(*(_QWORD *)a1 + 52) = a2;
    (**(void (***)(char *))a1)(a1);
  }
  if (a3 != 664)
  {
    v6 = *(_QWORD *)a1;
    *(_DWORD *)(v6 + 40) = 22;
    *(_DWORD *)(v6 + 48) = 664;
    *(_DWORD *)(*(_QWORD *)a1 + 52) = a3;
    (**(void (***)(char *))a1)(a1);
  }
  v7 = *(_QWORD *)a1;
  v8 = *((_QWORD *)a1 + 3);
  bzero(a1, 0x298uLL);
  *(_QWORD *)a1 = v7;
  *((_QWORD *)a1 + 3) = v8;
  *((_DWORD *)a1 + 8) = 1;
  _cg_jinit_memory_mgr(a1);
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 5) = 0;
  *((_QWORD *)a1 + 51) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  _cg_jinit_marker_reader((uint64_t)a1);
  result = _cg_jinit_input_controller((uint64_t)a1);
  *((_DWORD *)a1 + 9) = 200;
  return result;
}

uint64_t _cg_jpeg_read_header(uint64_t a1, int a2)
{
  int v4;
  void (**v5)(_QWORD);
  uint64_t v6;
  uint64_t v7;

  v4 = *(_DWORD *)(a1 + 36);
  if ((v4 & 0xFFFFFFFE) != 0xC8)
  {
    v5 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v4;
    (**(void (***)(uint64_t))a1)(a1);
  }
  v6 = _cg_jpeg_consume_input((uint64_t *)a1);
  if ((_DWORD)v6 == 2)
  {
    if (a2)
    {
      v7 = *(_QWORD *)a1;
      *(_DWORD *)(v7 + 40) = 53;
      (*(void (**)(uint64_t))v7)(a1);
    }
    _cg_jpeg_abort(a1);
  }
  return v6;
}

uint64_t _cg_jpeg_consume_input(uint64_t *a1)
{
  int v2;
  uint64_t result;
  int v4;
  int *v5;
  int v6;
  int v7;
  int v8;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;

  v2 = *((_DWORD *)a1 + 9);
  result = 1;
  switch(v2)
  {
    case 200:
      (*(void (**)(uint64_t *))(a1[76] + 8))(a1);
      (*(void (**)(uint64_t *))(a1[5] + 16))(a1);
      *((_DWORD *)a1 + 9) = 201;
      goto LABEL_4;
    case 201:
LABEL_4:
      result = (*(uint64_t (**)(uint64_t *))a1[76])(a1);
      if ((_DWORD)result != 1)
        return result;
      v4 = *((_DWORD *)a1 + 14);
      switch(v4)
      {
        case 1:
          v11 = 1;
          break;
        case 4:
          if (*((_DWORD *)a1 + 97) && (v13 = *((unsigned __int8 *)a1 + 392), *((_BYTE *)a1 + 392)))
          {
            if (v13 != 2)
            {
              v14 = *a1;
              *(_DWORD *)(v14 + 40) = 116;
              *(_DWORD *)(v14 + 48) = v13;
              (*(void (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 0xFFFFFFFFLL);
            }
            v11 = 4;
            v4 = 5;
          }
          else
          {
            v4 = 4;
            v11 = 4;
          }
          break;
        case 3:
          v5 = (int *)a1[38];
          v6 = *v5;
          v7 = v5[24];
          v8 = v5[48];
          if (v6 != 1 || v7 != 2 || v8 != 3)
          {
            if (v6 == 1 && v7 == 34 && v8 == 35)
            {
              v11 = 2;
              v4 = 7;
              break;
            }
            if (v6 == 82 && v7 == 71 && v8 == 66)
              goto LABEL_31;
            if (v6 == 114 && v7 == 103 && v8 == 98)
            {
              v11 = 2;
              v4 = 6;
              break;
            }
            if (!*((_DWORD *)a1 + 94))
            {
              if (*((_DWORD *)a1 + 97))
              {
                v15 = *((unsigned __int8 *)a1 + 392);
                if (!*((_BYTE *)a1 + 392))
                {
LABEL_31:
                  v4 = 2;
                  v11 = 2;
                  break;
                }
                if (v15 != 1)
                {
                  v16 = *a1;
                  *(_DWORD *)(v16 + 40) = 116;
                  *(_DWORD *)(v16 + 48) = v15;
                  (*(void (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 0xFFFFFFFFLL);
                }
              }
              else
              {
                v17 = *a1;
                *(_DWORD *)(v17 + 48) = v6;
                *(_DWORD *)(v17 + 52) = v7;
                *(_DWORD *)(v17 + 56) = v8;
                *(_DWORD *)(v17 + 40) = 113;
                (*(void (**)(uint64_t *, uint64_t))(v17 + 8))(a1, 1);
              }
            }
          }
          v11 = 2;
          v4 = 3;
          break;
        default:
          v4 = 0;
          v11 = 0;
          break;
      }
      *((_DWORD *)a1 + 15) = v4;
      *((_DWORD *)a1 + 16) = v11;
      v18 = *((_DWORD *)a1 + 139);
      *((_DWORD *)a1 + 17) = v18;
      *((_DWORD *)a1 + 18) = v18;
      a1[10] = 0x3FF0000000000000;
      *(_OWORD *)(a1 + 11) = xmmword_18820E720;
      *(_OWORD *)(a1 + 13) = xmmword_18820E760;
      a1[20] = 0;
      *(_OWORD *)(a1 + 15) = xmmword_18820E770;
      result = 1;
      *((_DWORD *)a1 + 9) = 202;
      return result;
    case 202:
      return result;
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 210:
      return (*(uint64_t (**)(uint64_t *))a1[76])(a1);
    default:
      v12 = *a1;
      *(_DWORD *)(v12 + 40) = 21;
      *(_DWORD *)(v12 + 48) = v2;
      (*(void (**)(uint64_t *))*a1)(a1);
      return 0;
  }
}

uint64_t _cg_jpeg_input_complete(uint64_t a1)
{
  int v2;
  void (**v3)(uint64_t);

  v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 211) <= 0xFFFFFFF4)
  {
    v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  return *(unsigned int *)(*(_QWORD *)(a1 + 608) + 36);
}

uint64_t _cg_jpeg_has_multiple_scans(uint64_t a1)
{
  int v2;
  void (**v3)(uint64_t);

  v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 211) <= 0xFFFFFFF6)
  {
    v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  return *(unsigned int *)(*(_QWORD *)(a1 + 608) + 32);
}

uint64_t _cg_jpeg_finish_decompress(uint64_t a1)
{
  int v2;
  void (**v3)(uint64_t);
  void (**v4)(uint64_t);
  uint64_t v5;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 205) > 1 || *(_DWORD *)(a1 + 88))
  {
    if (v2 == 210)
      goto LABEL_10;
    if (v2 != 207)
    {
      v3 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v3 + 10) = 21;
      *((_DWORD *)v3 + 12) = v2;
      (**(void (***)(uint64_t))a1)(a1);
      goto LABEL_10;
    }
  }
  else
  {
    if (*(_DWORD *)(a1 + 168) < *(_DWORD *)(a1 + 140))
    {
      v4 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v4 + 10) = 69;
      (*v4)(a1);
    }
    (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 576) + 8))(a1);
  }
  *(_DWORD *)(a1 + 36) = 210;
LABEL_10:
  while (1)
  {
    v5 = *(_QWORD *)(a1 + 608);
    if (*(_DWORD *)(v5 + 36))
      break;
    result = (*(uint64_t (**)(uint64_t))v5)(a1);
    if (!(_DWORD)result)
      return result;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 40) + 48))(a1);
  _cg_jpeg_abort(a1);
  return 1;
}

uint64_t _cg_jinit_upsampler(uint64_t *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  int *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t *, uint64_t, uint64_t, _QWORD);
  uint64_t v22;
  uint64_t v23;

  result = (*(uint64_t (**)(void))a1[1])();
  v3 = result;
  a1[80] = result;
  *(_QWORD *)result = start_pass_upsample;
  *(_QWORD *)(result + 8) = sep_upsample;
  *(_DWORD *)(result + 16) = 0;
  if (*((_DWORD *)a1 + 100))
  {
    v4 = *a1;
    *(_DWORD *)(v4 + 40) = 26;
    result = (*(uint64_t (**)(uint64_t *))v4)(a1);
  }
  if (*((int *)a1 + 14) >= 1)
  {
    v5 = 0;
    v6 = v3 + 192;
    v7 = (_QWORD *)(v3 + 104);
    v8 = (int *)(a1[38] + 36);
    do
    {
      v9 = *((_DWORD *)a1 + 106);
      v10 = *(v8 - 7);
      v11 = *v8;
      v12 = v8[1] * *(v8 - 6) / *((_DWORD *)a1 + 107);
      v13 = *((_DWORD *)a1 + 104);
      v14 = *((_DWORD *)a1 + 105);
      *(_DWORD *)(v6 + 4 * v5) = v12;
      if (v8[4])
      {
        v15 = v11 * v10 / v9;
        if (v15 == v13 && v12 == v14)
        {
          *v7 = fullsize_upsample;
        }
        else
        {
          if (2 * v15 == v13 && v12 == v14)
          {
            *v7 = h2v1_upsample;
          }
          else if (2 * v15 == v13 && 2 * v12 == v14)
          {
            *v7 = h2v2_upsample;
          }
          else
          {
            v18 = v13 / v15;
            if (v13 % v15 || (v19 = v14 / v12, v14 % v12))
            {
              v20 = *a1;
              *(_DWORD *)(v20 + 40) = 39;
              (*(void (**)(uint64_t *))v20)(a1);
            }
            else
            {
              *v7 = int_upsample;
              v23 = v6 + v5;
              *(_BYTE *)(v23 + 40) = v18;
              *(_BYTE *)(v23 + 50) = v19;
            }
          }
          v21 = *(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _QWORD))(a1[1] + 16);
          v22 = _cg_jround_up(*((unsigned int *)a1 + 34), *((int *)a1 + 104));
          result = v21(a1, 1, v22, *((unsigned int *)a1 + 105));
          *(v7 - 10) = result;
        }
      }
      else
      {
        *v7 = noop_upsample;
      }
      v8 += 24;
      ++v5;
      ++v7;
    }
    while (v5 < *((int *)a1 + 14));
  }
  return result;
}

uint64_t start_pass_upsample(uint64_t result)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(result + 640);
  v2 = *(_DWORD *)(result + 140);
  *(_DWORD *)(v1 + 184) = *(_DWORD *)(result + 420);
  *(_DWORD *)(v1 + 188) = v2;
  return result;
}

uint64_t sep_upsample(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, _DWORD *a6, int a7)
{
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v15;
  uint64_t v16;
  void (**v17)(uint64_t, uint64_t, uint64_t, _QWORD);
  void (**v18)(uint64_t, uint64_t, uint64_t, _QWORD);
  void (*v19)(uint64_t, uint64_t, uint64_t, _QWORD);
  unsigned int v20;
  unsigned int v21;
  uint64_t result;
  unsigned int v23;
  signed int v24;

  v11 = *(_QWORD *)(a1 + 640);
  v12 = *(_DWORD *)(v11 + 184);
  v13 = *(_DWORD *)(a1 + 420);
  if (v12 >= v13)
  {
    if (*(int *)(a1 + 56) >= 1)
    {
      v15 = 0;
      v16 = *(_QWORD *)(a1 + 304);
      v17 = (void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(v11 + 104);
      do
      {
        v18 = v17 - 10;
        v19 = *v17++;
        v19(a1, v16, *(_QWORD *)(a2 + 8 * v15) + 8 * (*(_DWORD *)(v11 + 192 + 4 * v15) * *a3), v18);
        ++v15;
        v16 += 96;
      }
      while (v15 < *(int *)(a1 + 56));
      v13 = *(_DWORD *)(a1 + 420);
    }
    v12 = 0;
    *(_DWORD *)(v11 + 184) = 0;
  }
  v20 = v13 - v12;
  if (v20 >= *(_DWORD *)(v11 + 188))
    v20 = *(_DWORD *)(v11 + 188);
  if (v20 >= a7 - *a6)
    v21 = a7 - *a6;
  else
    v21 = v20;
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 648) + 8))(a1, v11 + 24);
  *a6 += v21;
  v23 = *(_DWORD *)(v11 + 188) - v21;
  v24 = *(_DWORD *)(v11 + 184) + v21;
  *(_DWORD *)(v11 + 184) = v24;
  *(_DWORD *)(v11 + 188) = v23;
  if (v24 >= *(_DWORD *)(a1 + 420))
    ++*a3;
  return result;
}

void noop_upsample(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  *a4 = 0;
}

void fullsize_upsample(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  *a4 = a3;
}

uint64_t h2v1_upsample(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  char *v10;
  char v11;

  v4 = *(_DWORD *)(result + 420);
  if (v4 >= 1)
  {
    v5 = 0;
    v6 = *a4;
    do
    {
      v7 = *(unsigned int *)(result + 136);
      if ((_DWORD)v7)
      {
        v8 = *(_BYTE **)(v6 + 8 * v5);
        v9 = &v8[v7];
        v10 = *(char **)(a3 + 8 * v5);
        do
        {
          v11 = *v10++;
          *v8 = v11;
          v8[1] = v11;
          v8 += 2;
        }
        while (v8 < v9);
        v4 = *(_DWORD *)(result + 420);
      }
      ++v5;
    }
    while (v5 < v4);
  }
  return result;
}

char *h2v2_upsample(char *result, uint64_t a2, uint64_t a3, char **a4)
{
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  char *v12;
  char v13;
  size_t v14;

  if (*((int *)result + 105) >= 1)
  {
    v5 = result;
    v6 = 0;
    v7 = 0;
    v8 = *a4;
    do
    {
      v9 = *((unsigned int *)v5 + 34);
      if ((_DWORD)v9)
      {
        v10 = *(_BYTE **)&v8[8 * v7];
        v11 = &v10[v9];
        v12 = *(char **)(a3 + 8 * v6);
        do
        {
          v13 = *v12++;
          *v10 = v13;
          v10[1] = v13;
          v10 += 2;
        }
        while (v10 < v11);
        v14 = *((unsigned int *)v5 + 34);
      }
      else
      {
        v14 = 0;
      }
      result = _cg_jcopy_sample_rows(v8, v7, (uint64_t)v8, v7 | 1, 1, v14);
      ++v6;
      v7 += 2;
    }
    while (*((_DWORD *)v5 + 105) > (int)v7);
  }
  return result;
}

_QWORD *int_upsample(_QWORD *result, uint64_t a2, uint64_t a3, char **a4)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  unsigned __int8 *v14;

  if (*((int *)result + 105) >= 1)
  {
    v4 = result;
    v5 = 0;
    v6 = 0;
    v7 = *a4;
    v8 = result[80] + *(int *)(a2 + 4);
    v9 = *(unsigned __int8 *)(v8 + 242);
    v10 = *(unsigned __int8 *)(v8 + 232);
    do
    {
      v11 = *((unsigned int *)v4 + 34);
      if ((_DWORD)v11)
      {
        v12 = *(char **)&v7[8 * v6];
        v13 = &v12[v11];
        v14 = *(unsigned __int8 **)(a3 + 8 * v5);
        do
        {
          if ((_DWORD)v10)
          {
            result = memset(v12, *v14, v10);
            v12 += (v10 - 1) + 1;
          }
          ++v14;
        }
        while (v12 < v13);
      }
      if (v9 >= 2)
        result = _cg_jcopy_sample_rows(v7, v6, (uint64_t)v7, (int)v6 + 1, (int)v9 - 1, *((unsigned int *)v4 + 34));
      ++v5;
      v6 += v9;
    }
    while (*((_DWORD *)v4 + 105) > (int)v6);
  }
  return result;
}

uint64_t _cg_jinit_d_post_controller(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD);
  uint64_t v12;

  result = (**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 600) = result;
  *(_QWORD *)result = start_pass_dpost;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  if (*(_DWORD *)(a1 + 108))
  {
    v5 = result;
    v6 = *(unsigned int *)(a1 + 420);
    *(_DWORD *)(result + 32) = v6;
    v7 = *(_QWORD *)(a1 + 8);
    v8 = *(_DWORD *)(a1 + 136);
    v9 = *(_DWORD *)(a1 + 144);
    v10 = (v9 * v8);
    if (a2)
    {
      v11 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(v7 + 32);
      v12 = _cg_jround_up(*(unsigned int *)(a1 + 140), v6);
      result = v11(a1, 1, 0, v10, v12, *(unsigned int *)(v5 + 32));
      *(_QWORD *)(v5 + 16) = result;
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(v7 + 16))(a1, 1, (v9 * v8));
      *(_QWORD *)(v5 + 24) = result;
    }
  }
  return result;
}

uint64_t start_pass_dpost(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(result + 600);
  if (a2 == 3)
  {
    if (!*(_QWORD *)(v2 + 16))
    {
      v3 = *(_QWORD *)result;
      *(_DWORD *)(v3 + 40) = 3;
      result = (*(uint64_t (**)(uint64_t))v3)(result);
    }
    v4 = post_process_prepass;
    goto LABEL_15;
  }
  if (a2 == 2)
  {
    if (!*(_QWORD *)(v2 + 16))
    {
      v5 = *(_QWORD *)result;
      *(_DWORD *)(v5 + 40) = 3;
      result = (*(uint64_t (**)(uint64_t))v5)(result);
    }
    v4 = post_process_2pass;
    goto LABEL_15;
  }
  if (a2)
  {
    v6 = *(_QWORD *)result;
    *(_DWORD *)(v6 + 40) = 3;
    result = (*(uint64_t (**)(uint64_t))v6)(result);
    goto LABEL_16;
  }
  if (!*(_DWORD *)(result + 108))
  {
    v4 = *(void **)(*(_QWORD *)(result + 640) + 8);
LABEL_15:
    *(_QWORD *)(v2 + 8) = v4;
    goto LABEL_16;
  }
  *(_QWORD *)(v2 + 8) = post_process_1pass;
  if (!*(_QWORD *)(v2 + 24))
  {
    result = (*(uint64_t (**)(void))(*(_QWORD *)(result + 8) + 56))();
    *(_QWORD *)(v2 + 24) = result;
  }
LABEL_16:
  *(_DWORD *)(v2 + 36) = 0;
  *(_DWORD *)(v2 + 40) = 0;
  return result;
}

uint64_t post_process_1pass(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v9;
  uint64_t result;

  v9 = a1[75];
  (*(void (**)(void))(a1[80] + 8))();
  result = (*(uint64_t (**)(_QWORD *, _QWORD, uint64_t, _QWORD))(a1[82] + 8))(a1, *(_QWORD *)(v9 + 24), a5 + 8 * *a6, 0);
  *a6 = *a6;
  return result;
}

uint64_t post_process_prepass(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t result;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;

  v11 = a1[75];
  v12 = *(_DWORD *)(v11 + 40);
  if (v12)
  {
    v13 = *(_QWORD *)(v11 + 24);
  }
  else
  {
    v13 = (*(uint64_t (**)(_QWORD *, _QWORD, _QWORD, _QWORD, uint64_t))(a1[1] + 56))(a1, *(_QWORD *)(v11 + 16), *(unsigned int *)(v11 + 36), *(unsigned int *)(v11 + 32), 1);
    *(_QWORD *)(v11 + 24) = v13;
    v12 = *(_DWORD *)(v11 + 40);
  }
  result = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(a1[80] + 8))(a1, a2, a3, a4, v13, v11 + 40, *(unsigned int *)(v11 + 32));
  v15 = *(_DWORD *)(v11 + 40);
  v16 = v15 - v12;
  if (v15 > v12)
  {
    result = (*(uint64_t (**)(_QWORD *, uint64_t, _QWORD, uint64_t))(a1[82] + 8))(a1, *(_QWORD *)(v11 + 24) + 8 * v12, 0, v16);
    *a6 += v16;
    v15 = *(_DWORD *)(v11 + 40);
  }
  v17 = *(_DWORD *)(v11 + 32);
  if (v15 >= v17)
    *(_QWORD *)(v11 + 36) = *(_DWORD *)(v11 + 36) + v17;
  return result;
}

uint64_t post_process_2pass(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, int a7)
{
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t result;
  unsigned int v19;
  unsigned int v20;

  v11 = *(_QWORD *)(a1 + 600);
  v12 = *(_DWORD *)(v11 + 40);
  if (v12)
  {
    v13 = *(_QWORD *)(v11 + 24);
  }
  else
  {
    v13 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 8) + 56))(a1, *(_QWORD *)(v11 + 16), *(unsigned int *)(v11 + 36), *(unsigned int *)(v11 + 32), 0);
    *(_QWORD *)(v11 + 24) = v13;
    v12 = *(_DWORD *)(v11 + 40);
  }
  v14 = *(_DWORD *)(v11 + 32) - v12;
  v15 = *a6;
  if (v14 >= a7 - (int)v15)
    v14 = a7 - v15;
  v16 = *(_DWORD *)(a1 + 140) - *(_DWORD *)(v11 + 36);
  if (v14 >= v16)
    v17 = v16;
  else
    v17 = v14;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 656) + 8))(a1, v13 + 8 * v12, a5 + 8 * v15, v17);
  *a6 += v17;
  v19 = *(_DWORD *)(v11 + 40) + v17;
  *(_DWORD *)(v11 + 40) = v19;
  v20 = *(_DWORD *)(v11 + 32);
  if (v19 >= v20)
    *(_QWORD *)(v11 + 36) = *(_DWORD *)(v11 + 36) + v20;
  return result;
}

_QWORD *KTX2ReadPlugin::KTX2ReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *result = &off_1E1BAF9C0;
  result[55] = 0;
  return result;
}

_QWORD *KTX2ReadPlugin::KTX2ReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *result = &off_1E1BAF9C0;
  result[55] = 0;
  return result;
}

void KTX2ReadPlugin::~KTX2ReadPlugin(KTX2ReadPlugin *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BAF9C0;
  v2 = *((_QWORD *)this + 55);
  if (v2)
    (**(void (***)(void))(v2 + 8))();
  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  KTX2ReadPlugin::~KTX2ReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t KTX2ReadPlugin::loadDataFromXPCObject(KTX2ReadPlugin *this, void *a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_ktx", &length);
    if (length == 32)
    {
      v6 = data;
      result = 0;
      v7 = v6[1];
      *(_OWORD *)((char *)this + 440) = *v6;
      *(_OWORD *)((char *)this + 456) = v7;
      *((_QWORD *)this + 55) = 0;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t KTX2ReadPlugin::saveDataToXPCObject(KTX2ReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_ktx", (char *)this + 440, 0x20uLL);
  return v4;
}

uint64_t KTX2ReadPlugin::initialize(KTX2ReadPlugin *this, IIODictionary *a2)
{
  uint64_t KTXTexture;
  uint64_t v4;
  unsigned __int16 *v5;
  int v6;
  char v7;
  CFStringRef *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  unsigned __int16 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int Size;
  unsigned __int16 *v22;
  _OWORD v23[4];
  uint64_t v24;

  v24 = 0;
  memset(v23, 0, sizeof(v23));
  IIOScanner::IIOScanner((IIOScanner *)v23, *((IIOImageReadSession **)this + 3));
  v22 = 0;
  if (!*((_BYTE *)this + 341))
    goto LABEL_19;
  KTXTexture = CreateKTXTexture(*((IIOImageReadSession **)this + 3));
  v4 = KTXTexture;
  if (!KTXTexture)
    goto LABEL_19;
  *(_QWORD *)((char *)this + 228) = *(_QWORD *)(KTXTexture + 36);
  *((_WORD *)this + 120) = 8;
  if (!GetKtx2FormatInfo(*(_DWORD *)(KTXTexture + 120), &v22))
    goto LABEL_19;
  v5 = v22;
  *((_WORD *)this + 120) = v22[1];
  if ((v5[12] & 2) != 0)
    *((_BYTE *)this + 345) = 1;
  v6 = *v5;
  if (v6 == 3)
  {
    v7 = 5;
  }
  else
  {
    if (v6 != 4)
    {
      *((_BYTE *)this + 246) = 5;
      v8 = (CFStringRef *)MEMORY[0x1E0C9D990];
      goto LABEL_14;
    }
    v7 = 3;
  }
  *((_BYTE *)this + 246) = v7;
  if (*((_BYTE *)this + 345))
    v8 = (CFStringRef *)MEMORY[0x1E0C9D958];
  else
    v8 = (CFStringRef *)MEMORY[0x1E0C9DA10];
LABEL_14:
  *((_QWORD *)this + 20) = CGColorSpaceCreateWithName(*v8);
  *((_DWORD *)this + 81) = 1380401696;
  v9 = *((_DWORD *)this + 57);
  v10 = *((_DWORD *)this + 58);
  v11 = *v22;
  if (v10 * (unint64_t)v9 * v11 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this
                                                                                         + 3)))
  {
    v17 = *((unsigned int *)this + 57);
    v18 = *((unsigned int *)this + 58);
    v19 = *v22;
    Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
    _cg_jpeg_mem_term("initialize", 153, "*** bad KTX: [%ldx%ld]  channels: %ld  fileSize: %d\n", v17, v18, v19, Size);
LABEL_19:
    kdebug_trace();
    v15 = 4294967246;
    goto LABEL_20;
  }
  v12 = *((unsigned __int16 *)this + 120);
  *((_WORD *)this + 121) = 4 * v12;
  *((_WORD *)this + 122) = 4;
  *((_BYTE *)this + 346) = 0;
  *((_QWORD *)this + 55) = v4;
  v13 = *((_DWORD *)this + 57);
  if (v13 >> 30)
    goto LABEL_19;
  v14 = 4 * v13 * (unint64_t)(v12 >> 3);
  if ((v14 & 0xFFFFFFFF00000000) != 0)
    goto LABEL_19;
  v15 = 0;
  *((_DWORD *)this + 59) = v14;
  v16 = v22;
  *((_QWORD *)this + 56) = *v22;
  *((_QWORD *)this + 57) = 4;
  *((_DWORD *)this + 116) = *((_DWORD *)v16 + 5);
  *((_WORD *)this + 188) = 1;
LABEL_20:
  IIOScanner::~IIOScanner((IIOScanner *)v23);
  return v15;
}

void sub_187F6A288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t KTX2ReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

IOSurfaceRef *KTX2ReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *BlockArray)
{
  unint64_t v8;
  unint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  IIOImageRead **v23;
  char *BaseAddress;
  size_t Height;
  size_t BytesPerRow;
  size_t v27;
  double v28;
  double v29;
  unint64_t v30;
  unsigned int v31;
  vImagePixelCount v32;
  vImagePixelCount v33;
  char *v34;
  uint64_t KTXTexture;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int8x16_t v39;
  int v40;
  unint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  size_t v46;
  size_t v47;
  char *v48;
  char *v49;
  int k;
  uint64_t v51;
  double v52;
  double v53;
  int v55;
  int v56;
  size_t v57;
  size_t v58;
  char *v59;
  char *v60;
  int i;
  __int16 v62;
  int v63;
  size_t v64;
  size_t v65;
  char *v66;
  char *v67;
  int j;
  mach_vm_size_t v69;
  unint64_t v70;
  unint64_t v71;
  int v72;
  IOSurfaceRef *v73;
  char *v74;
  char *v75;
  vImage_Buffer v76;
  vImage_Buffer dest;
  int v78;
  char *v79;
  size_t v80;
  uint64_t v81;
  size_t v82[2];
  CGRect v83;
  CGRect v84;

  v82[0] = 0;
  v9 = *((_QWORD *)this + 56);
  v8 = *((_QWORD *)this + 57);
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v10 = *((_DWORD *)this + 51);
    v11 = v10 >> 24;
    v12 = MEMORY[0x1E0C80978];
    if (v10 < 0)
    {
      v13 = __maskrune(v11, 0x40000uLL);
      v10 = *((_DWORD *)this + 51);
    }
    else
    {
      v13 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v11 + 60) & 0x40000;
    }
    if (v13)
      v14 = (v10 >> 24);
    else
      v14 = 46;
    v15 = v10 << 8 >> 24;
    if (v10 << 8 < 0)
    {
      v16 = __maskrune(v15, 0x40000uLL);
      v10 = *((_DWORD *)this + 51);
    }
    else
    {
      v16 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
    }
    if (v16)
      v17 = (v10 << 8 >> 24);
    else
      v17 = 46;
    v18 = (__int16)v10 >> 8;
    v19 = v8;
    if (v10 << 16 < 0)
    {
      v20 = __maskrune(v18, 0x40000uLL);
      v10 = *((_DWORD *)this + 51);
    }
    else
    {
      v20 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
    }
    if (v20)
      v21 = ((__int16)v10 >> 8);
    else
      v21 = 46;
    if ((v10 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v10, 0x40000uLL))
    {
LABEL_22:
      v22 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v14, v17, v21, (char)v22, iioTypeStr[a3], "virtual OSStatus KTX2ReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      v8 = v19;
      goto LABEL_26;
    }
    LOBYTE(v22) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v23 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v23)
    IIOImageReadSession::mapData(v23);
  if (a3 == 3)
  {
    v73 = BlockArray;
    BlockArray = (IOSurfaceRef *)IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v30) = *((_DWORD *)this + 73);
    v29 = (double)v30;
    v31 = *((_DWORD *)this + 74);
    v28 = (double)v31;
    v27 = *((unsigned int *)this + 75) * (unint64_t)v31;
    BaseAddress = (char *)_ImageIO_Malloc(v27, *((_QWORD *)this + 48), v82, (uint64_t)kImageMalloc_KTX2_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1)
      return 0;
    if (!BlockArray)
      return BlockArray;
    if (!*BlockArray)
      return 0;
    IOSurfaceLock(*BlockArray, 0, 0);
    BaseAddress = (char *)IOSurfaceGetBaseAddress(*BlockArray);
    Height = IOSurfaceGetHeight(*BlockArray);
    v73 = BlockArray;
    BytesPerRow = IOSurfaceGetBytesPerRow(*BlockArray);
    BlockArray = 0;
    v27 = BytesPerRow * Height;
    v82[0] = v27;
    v28 = 0.0;
    v29 = 0.0;
  }
  if (!BaseAddress)
    return BlockArray;
  v32 = *((unsigned int *)this + 73);
  v33 = *((unsigned int *)this + 74);
  v34 = BaseAddress;
  if (v9 >= v8
    || (v34 = (char *)malloc_type_calloc(*((unsigned int *)this + 74), *((unsigned int *)this + 75), 0x4760B7BCuLL)) != 0)
  {
    v74 = v34;
    v75 = BaseAddress;
    v72 = a3;
    v78 = *((_DWORD *)this + 52);
    v79 = v34;
    v80 = v27;
    v69 = v27;
    v81 = 0;
    KTXTexture = *((_QWORD *)this + 55);
    if (!KTXTexture)
    {
      KTXTexture = CreateKTXTexture(*((IIOImageReadSession **)this + 3));
      *((_QWORD *)this + 55) = KTXTexture;
    }
    (*(void (**)(void))(*(_QWORD *)(KTXTexture + 8) + 40))();
    v70 = v8;
    v71 = v9;
    if (v9 < v8)
    {
      v36 = *((_QWORD *)this + 56);
      v37 = *((unsigned __int16 *)this + 120);
      if (v36 == 3 && v37 == 8)
      {
        dest.data = v74;
        dest.height = v33;
        dest.width = v32;
        dest.rowBytes = (3 * v32 + 3) & 0x7FFFFFFFCLL;
        v76.data = BaseAddress;
        v76.height = v33;
        v76.width = v32;
        v76.rowBytes = 4 * v32;
        vImageConvert_RGB888toRGBA8888(&dest, 0, 0xFFu, &v76, 0, 0);
      }
      else if (v37 == 32)
      {
        if (*((_BYTE *)this + 345))
          v55 = 1006632960;
        else
          v55 = -1;
        if ((_DWORD)v33)
        {
          v56 = 0;
          v57 = (4 * v36);
          v58 = (12 - 4 * v36);
          v59 = v74;
          v60 = BaseAddress;
          do
          {
            for (i = v32; i; --i)
            {
              memcpy(v60, v59, v57);
              if ((_DWORD)v57 != 12)
                bzero(&v60[4 * *((_QWORD *)this + 56)], v58);
              *((_DWORD *)v60 + 3) = v55;
              v59 += 4 * *((_QWORD *)this + 56);
              v60 += 16;
            }
            ++v56;
          }
          while (v56 != (_DWORD)v33);
        }
      }
      else if (v37 == 16)
      {
        if (*((_BYTE *)this + 345))
          v62 = 15360;
        else
          v62 = -1;
        if ((_DWORD)v33)
        {
          v63 = 0;
          v64 = (2 * v36);
          v65 = (6 - 2 * v36);
          v66 = v74;
          v67 = BaseAddress;
          do
          {
            for (j = v32; j; --j)
            {
              memcpy(v67, v66, v64);
              if ((_DWORD)v64 != 6)
                bzero(&v67[2 * *((_QWORD *)this + 56)], v65);
              *((_WORD *)v67 + 3) = v62;
              v66 += 2 * *((_QWORD *)this + 56);
              v67 += 8;
            }
            ++v63;
          }
          while (v63 != (_DWORD)v33);
        }
      }
      else if (v37 == 8 && (_DWORD)v33)
      {
        v45 = 0;
        v46 = (3 - v36);
        v47 = *((_QWORD *)this + 56);
        v49 = v74;
        v48 = BaseAddress;
        do
        {
          for (k = v32; k; --k)
          {
            memcpy(v48, v49, v47);
            if (v47 != 3)
              bzero(&v48[*((_QWORD *)this + 56)], v46);
            v48[3] = -1;
            v49 += *((_QWORD *)this + 56);
            v48 += 4;
          }
          ++v45;
        }
        while (v45 != (_DWORD)v33);
      }
    }
    a3 = v72;
    BaseAddress = v75;
    if (*((_WORD *)this + 153) != 32 || *((_WORD *)this + 152) != 8)
      goto LABEL_50;
    dest.data = v75;
    v38 = *(_QWORD *)((char *)this + 292);
    v39.i64[0] = v38;
    v39.i64[1] = HIDWORD(v38);
    *(int8x16_t *)&dest.height = vextq_s8(v39, v39, 8uLL);
    dest.rowBytes = *((unsigned int *)this + 75);
    v40 = *((_DWORD *)this + 116);
    if (*((_BYTE *)this + 405))
    {
      if (v40 != 1)
        goto LABEL_48;
    }
    else if (v40)
    {
LABEL_48:
      if (*((_BYTE *)this + 406) == 1)
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
LABEL_50:
      if (v72 == 3)
      {
        v43 = 0;
        v83.origin.x = 0.0;
        v83.origin.y = 0.0;
        v83.size.width = v29;
        v83.size.height = v28;
        **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, v75, v69, v83, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
        if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
        {
          v44 = 0;
        }
        else
        {
          v84.origin.x = 0.0;
          v84.origin.y = 0.0;
          v84.size.width = v29;
          v84.size.height = v28;
          *(CGRect *)(&v44 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v84);
          v43 = v51;
          v29 = v52;
          v28 = v53;
        }
        v41 = v71;
        v42 = v74;
        BaseAddress = 0;
        *((_QWORD *)this + 15) = v43;
        *((_QWORD *)this + 16) = v44;
        *((double *)this + 17) = v29;
        *((double *)this + 18) = v28;
      }
      else
      {
        v41 = v71;
        IOSurfaceUnlock(*v73, 0, 0);
        v42 = v74;
      }
      BlockArray = 0;
      if (v41 < v70)
      {
        free(v42);
        BlockArray = 0;
      }
      goto LABEL_70;
    }
    LODWORD(v76.data) = 50331906;
    vImagePermuteChannels_ARGB8888(&dest, &dest, (const uint8_t *)&v76, 0x10u);
    goto LABEL_48;
  }
LABEL_70:
  if (a3 == 3 && BaseAddress)
    _ImageIO_Free((unint64_t)BaseAddress, v82[0]);
  return BlockArray;
}

uint64_t _cg_jpeg_start_decompress(uint64_t a1)
{
  int v2;
  uint64_t result;
  void (**v4)(_QWORD);
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_DWORD *)(a1 + 36);
  if (v2 == 204)
    return output_pass_setup(a1);
  if (v2 != 203)
  {
    if (v2 != 202)
    {
      v4 = *(void (***)(_QWORD))a1;
      *((_DWORD *)v4 + 10) = 21;
      *((_DWORD *)v4 + 12) = v2;
      (**(void (***)(uint64_t))a1)(a1);
      return output_pass_setup(a1);
    }
    _cg_jinit_master_decompress(a1);
    if (*(_DWORD *)(a1 + 88))
    {
      *(_DWORD *)(a1 + 36) = 207;
      return 1;
    }
    *(_DWORD *)(a1 + 36) = 203;
  }
  if (!*(_DWORD *)(*(_QWORD *)(a1 + 608) + 32))
  {
LABEL_21:
    *(_DWORD *)(a1 + 180) = *(_DWORD *)(a1 + 172);
    return output_pass_setup(a1);
  }
  v5 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    if (v5)
      (*(void (**)(uint64_t))v5)(a1);
    result = (**(uint64_t (***)(uint64_t))(a1 + 608))(a1);
    if (!(_DWORD)result)
      return result;
    if ((_DWORD)result == 2)
      goto LABEL_21;
    v5 = *(_QWORD *)(a1 + 16);
    if ((result & 0xFFFFFFFD) == 1 && v5 != 0)
    {
      v7 = *(_QWORD *)(v5 + 16);
      v8 = *(_QWORD *)(v5 + 8) + 1;
      *(_QWORD *)(v5 + 8) = v8;
      if (v8 >= v7)
        *(_QWORD *)(v5 + 16) = v7 + *(unsigned int *)(a1 + 432);
    }
  }
}

uint64_t output_pass_setup(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  BOOL v5;
  int v6;

  if (*(_DWORD *)(a1 + 36) != 204)
  {
    (**(void (***)(uint64_t))(a1 + 576))(a1);
    *(_DWORD *)(a1 + 168) = 0;
    *(_DWORD *)(a1 + 36) = 204;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 576) + 16))
  {
    v2 = *(unsigned int *)(a1 + 168);
    do
    {
      while (1)
      {
        v3 = *(unsigned int *)(a1 + 140);
        if (v2 < v3)
          break;
        (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 576) + 8))(a1);
        (**(void (***)(uint64_t))(a1 + 576))(a1);
        v2 = 0;
        *(_DWORD *)(a1 + 168) = 0;
        if (!*(_DWORD *)(*(_QWORD *)(a1 + 576) + 16))
          goto LABEL_12;
      }
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        *(_QWORD *)(v4 + 8) = v2;
        *(_QWORD *)(v4 + 16) = v3;
        (*(void (**)(uint64_t))v4)(a1);
        v2 = *(unsigned int *)(a1 + 168);
      }
      (*(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 584) + 8))(a1, 0, a1 + 168, 0);
      v5 = *(unsigned int *)(a1 + 168) == v2;
      v2 = *(unsigned int *)(a1 + 168);
    }
    while (!v5);
    return 0;
  }
  else
  {
LABEL_12:
    if (*(_DWORD *)(a1 + 92))
      v6 = 206;
    else
      v6 = 205;
    *(_DWORD *)(a1 + 36) = v6;
    return 1;
  }
}

uint64_t _cg_jpeg_read_scanlines(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  void (**v7)(uint64_t);
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  void (**v12)(uint64_t);
  unsigned int v13;

  v6 = *(_DWORD *)(a1 + 36);
  if (v6 != 205)
  {
    v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 21;
    *((_DWORD *)v7 + 12) = v6;
    (**(void (***)(uint64_t))a1)(a1);
  }
  v8 = *(unsigned int *)(a1 + 168);
  v9 = *(unsigned int *)(a1 + 140);
  if (v8 >= v9)
  {
    v12 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v12 + 10) = 126;
    ((void (*)(uint64_t, uint64_t))v12[1])(a1, 0xFFFFFFFFLL);
    return 0;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    if (v10)
    {
      *(_QWORD *)(v10 + 8) = v8;
      *(_QWORD *)(v10 + 16) = v9;
      (*(void (**)(uint64_t))v10)(a1);
    }
    v13 = 0;
    (*(void (**)(uint64_t, uint64_t, unsigned int *, uint64_t))(*(_QWORD *)(a1 + 584) + 8))(a1, a2, &v13, a3);
    result = v13;
    *(_DWORD *)(a1 + 168) += v13;
  }
  return result;
}

uint64_t _cg_jpeg_read_raw_data(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6;
  void (**v7)(uint64_t);
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (**v12)(uint64_t);
  void (**v13)(uint64_t);

  v6 = *(_DWORD *)(a1 + 36);
  if (v6 != 206)
  {
    v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 21;
    *((_DWORD *)v7 + 12) = v6;
    (**(void (***)(uint64_t))a1)(a1);
  }
  v8 = *(unsigned int *)(a1 + 168);
  v9 = *(unsigned int *)(a1 + 140);
  if (v8 >= v9)
  {
    v13 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v13 + 10) = 126;
    ((void (*)(uint64_t, uint64_t))v13[1])(a1, 0xFFFFFFFFLL);
    return 0;
  }
  v10 = *(_QWORD *)(a1 + 16);
  if (v10)
  {
    *(_QWORD *)(v10 + 8) = v8;
    *(_QWORD *)(v10 + 16) = v9;
    (*(void (**)(uint64_t))v10)(a1);
  }
  v11 = (*(_DWORD *)(a1 + 428) * *(_DWORD *)(a1 + 420));
  if (v11 > a3)
  {
    v12 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v12 + 10) = 24;
    (*v12)(a1);
  }
  if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)(a1 + 592) + 24))(a1, a2))
    return 0;
  *(_DWORD *)(a1 + 168) += v11;
  return v11;
}

uint64_t _cg_jpeg_start_output(uint64_t a1, int a2)
{
  int v4;
  void (**v5)(_QWORD);
  int v6;

  v4 = *(_DWORD *)(a1 + 36);
  if (v4 != 204 && v4 != 207)
  {
    v5 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v4;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (a2 <= 1)
    v6 = 1;
  else
    v6 = a2;
  if (*(_DWORD *)(*(_QWORD *)(a1 + 608) + 36) && v6 >= *(_DWORD *)(a1 + 172))
    v6 = *(_DWORD *)(a1 + 172);
  *(_DWORD *)(a1 + 180) = v6;
  return output_pass_setup(a1);
}

uint64_t _cg_jpeg_finish_output(uint64_t a1)
{
  int v2;
  void (**v3)(uint64_t);
  uint64_t v4;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 205) > 1)
  {
    if (v2 == 208)
      goto LABEL_6;
LABEL_5:
    v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
    goto LABEL_6;
  }
  if (!*(_DWORD *)(a1 + 88))
    goto LABEL_5;
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 576) + 8))(a1);
  *(_DWORD *)(a1 + 36) = 208;
LABEL_6:
  while (*(_DWORD *)(a1 + 172) <= *(_DWORD *)(a1 + 180))
  {
    v4 = *(_QWORD *)(a1 + 608);
    if (*(_DWORD *)(v4 + 36))
      break;
    result = (*(uint64_t (**)(uint64_t))v4)(a1);
    if (!(_DWORD)result)
      return result;
  }
  *(_DWORD *)(a1 + 36) = 207;
  return 1;
}

uint64_t _cg_jpeg_idct_float(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  __int16 *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  float *v10;
  int v11;
  int v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float *v39;
  float v40;
  uint64_t v41;
  float *v42;
  uint64_t v43;
  uint64_t v44;
  float *v45;
  _BYTE *v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  _OWORD v74[16];
  uint64_t v75;

  v5 = 0;
  v75 = *MEMORY[0x1E0C80C00];
  memset(v74, 0, sizeof(v74));
  v6 = (__int16 *)(a3 + 64);
  v7 = *(_QWORD *)(a2 + 88) + 128;
  v8 = 9;
  v9 = *(_QWORD *)(result + 440);
  do
  {
    v10 = (float *)(v7 + v5);
    v11 = (unsigned __int16)*(v6 - 24);
    v12 = (unsigned __int16)*(v6 - 16);
    if (v11 | v12)
      goto LABEL_9;
    if (*(v6 - 8) || *v6 || v6[8] || v6[16] || v6[24])
    {
      LOWORD(v12) = 0;
LABEL_9:
      v13 = *(v10 - 32) * (float)*(v6 - 32);
      v14 = *(v10 - 16) * (float)(__int16)v12;
      v15 = *v10 * (float)*v6;
      v16 = v10[16] * (float)v6[16];
      v17 = v13 + v15;
      v18 = v13 - v15;
      v19 = v14 + v16;
      v20 = -(float)((float)(v14 + v16) - (float)((float)(v14 - v16) * 1.4142));
      v21 = v17 + v19;
      v22 = v17 - v19;
      v23 = v18 + v20;
      v24 = v18 - v20;
      v25 = *(v10 - 24) * (float)(__int16)v11;
      v26 = *(v10 - 8) * (float)*(v6 - 8);
      v27 = v10[8] * (float)v6[8];
      v28 = v10[24] * (float)v6[24];
      v29 = v26 + v27;
      v30 = v27 - v26;
      v31 = v25 + v28;
      v32 = v25 - v28;
      v33 = v29 + v31;
      v34 = (float)(v31 - v29) * 1.4142;
      v35 = (float)(v30 + v32) * 1.8478;
      v36 = (float)(v35 + (float)(v30 * -2.6131)) - v33;
      v37 = v34 - v36;
      v38 = (float)(v35 + (float)(v32 * -1.0824)) - v37;
      v39 = (float *)((char *)v74 + v5);
      *v39 = v21 + v33;
      v39[56] = v21 - v33;
      v39[8] = v23 + v36;
      v39[48] = v23 - v36;
      v39[16] = v24 + v37;
      v39[40] = v24 - v37;
      v39[24] = v22 + v38;
      v40 = v22 - v38;
      v41 = 8;
      goto LABEL_10;
    }
    v40 = *(v10 - 32) * (float)*(v6 - 32);
    v42 = (float *)((char *)v74 + v5);
    *v42 = v40;
    v42[8] = v40;
    v42[16] = v40;
    v42[24] = v40;
    v42[32] = v40;
    v42[40] = v40;
    v42[48] = v40;
    v41 = 14;
LABEL_10:
    *(float *)((char *)&v74[v41] + v5) = v40;
    --v8;
    v5 += 4;
    ++v6;
  }
  while (v8 > 1);
  v43 = 0;
  v44 = v9 - 384;
  do
  {
    v45 = (float *)&v74[v43];
    v46 = (_BYTE *)(*(_QWORD *)(a4 + v43 * 4) + a5);
    v47 = v45[1];
    v48 = *v45 + 512.5;
    v49 = v45[4];
    v50 = v45[5];
    v51 = v48 + v49;
    v52 = v45[2];
    v53 = v45[3];
    v54 = v45[6];
    v55 = v45[7];
    v56 = v52 + v54;
    v57 = v48 - v49;
    v58 = -(float)((float)(v52 + v54) - (float)((float)(v52 - v54) * 1.4142));
    v59 = v50 + v53;
    v60 = v50 - v53;
    v61 = v51 + v56;
    v62 = v51 - v56;
    v63 = v47 + v55;
    v64 = v47 - v55;
    v65 = v59 + v63;
    v66 = v63 - v59;
    v67 = v57 + v58;
    v68 = v57 - v58;
    v69 = v66 * 1.4142;
    v70 = (float)(v60 + v64) * 1.8478;
    v71 = v70 + (float)(v64 * -1.0824);
    v72 = (float)(v70 + (float)(v60 * -2.6131)) - v65;
    v73 = v69 - v72;
    *v46 = *(_BYTE *)(v44 + ((int)(float)(v61 + v65) & 0x3FFLL));
    v46[7] = *(_BYTE *)(v44 + ((int)(float)(v61 - v65) & 0x3FFLL));
    v46[1] = *(_BYTE *)(v44 + ((int)(float)(v67 + v72) & 0x3FFLL));
    v46[6] = *(_BYTE *)(v44 + ((int)(float)(v67 - v72) & 0x3FFLL));
    v46[2] = *(_BYTE *)(v44 + ((int)(float)(v68 + v73) & 0x3FFLL));
    v46[5] = *(_BYTE *)(v44 + ((int)(float)(v68 - v73) & 0x3FFLL));
    v46[3] = *(_BYTE *)(v44 + ((int)(float)(v62 + (float)(v71 - v73)) & 0x3FFLL));
    v46[4] = *(_BYTE *)(v44 + ((int)(float)(v62 - (float)(v71 - v73)) & 0x3FFLL));
    v43 += 2;
  }
  while (v43 != 16);
  return result;
}

kd_encoder **kdu_encoder::kdu_encoder(kd_encoder **a1, int32x4_t *a2, uint64_t a3, int a4, uint64_t a5, kdu_thread_entity *a6, char *a7, float a8)
{
  kd_encoder *v16;

  *a1 = 0;
  v16 = (kd_encoder *)operator new();
  kd_encoder::kd_encoder(v16);
  *a1 = v16;
  kd_encoder::init((uint64_t)v16, a2, a3, a4, a5, a6, a7, a8);
  return a1;
}

void sub_187F6B2C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4018E1C327);
  _Unwind_Resume(a1);
}

uint64_t kd_encoder::init(uint64_t a1, int32x4_t *a2, uint64_t a3, int a4, uint64_t a5, kdu_thread_entity *a6, char *a7, float a8)
{
  float msb_wmse;
  BOOL roi_weight;
  uint64_t result;
  __int32 v18;
  __int16 v19;
  int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  _WORD *v24;
  signed int v25;
  __int32 v26;
  int v27;
  __int32 v28;
  __int32 v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  int32x2_t v36;
  int32x2_t v37;
  int32x4_t v38;
  int32x4_t *v39;

  v39 = a2;
  if (*(_QWORD *)(a1 + 96) || *(_QWORD *)(a1 + 136))
    kd_encoder::init();
  if (a6)
    *(_QWORD *)(a1 + 136) = kdu_thread_entity::add_queue((uint64_t)a6, a1 + 8, a7, (uint64_t)"block encoder");
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 104) = a5;
  *(_WORD *)(a1 + 32) = kdu_subband::get_K_max((kdu_subband *)&v39);
  *(_WORD *)(a1 + 34) = kdu_subband::get_K_max_prime((kdu_subband *)&v39);
  *(_BYTE *)(a1 + 36) = kdu_subband::get_reversible((kdu_subband *)&v39);
  *(_BYTE *)(a1 + 37) = 0;
  *(float *)(a1 + 40) = kdu_subband::get_delta((kdu_subband *)&v39) * a8;
  msb_wmse = kdu_subband::get_msb_wmse((kdu_subband *)&v39);
  *(_DWORD *)(a1 + 48) = 1065353216;
  *(float *)(a1 + 44) = msb_wmse;
  roi_weight = kdu_subband::get_roi_weight((kdu_subband *)&v39, (float *)(a1 + 48));
  v38 = 0uLL;
  kdu_subband::get_dims(&v39, &v38);
  v36 = 0;
  v37 = 0;
  kdu_subband::get_block_size((uint64_t *)&v39, &v37, &v36);
  result = (uint64_t)kdu_subband::get_valid_blocks((kdu_subband *)&v39, (int32x4_t *)(a1 + 52));
  v18 = v38.i32[2];
  *(_QWORD *)(a1 + 68) = v38.i64[1];
  v19 = v37.i16[0];
  *(_WORD *)(a1 + 78) = v36.i16[2];
  *(_WORD *)(a1 + 80) = v37.i16[2];
  *(_WORD *)(a1 + 82) = v19;
  *(_BYTE *)(a1 + 39) = 1;
  if (!a6)
  {
    *(_WORD *)(a1 + 84) = v19;
    v24 = (_WORD *)(a1 + 84);
    *(_WORD *)(a1 + 76) = 0;
    LOWORD(v21) = v18;
    if (v18 > v19)
      goto LABEL_23;
    goto LABEL_22;
  }
  result = kdu_thread_entity::get_num_threads(a6);
  v20 = *(__int16 *)(a1 + 82);
  v21 = *(_DWORD *)(a1 + 68);
  if ((int)result > 1)
  {
    v22 = *(__int16 *)(a1 + 82);
    if (v21 < v20)
      v22 = v21;
    v23 = (v22 * *(int *)(a1 + 72) + (v22 * *(int *)(a1 + 72) < 0 ? 0x1FFFuLL : 0)) >> 13;
    if (*(_DWORD *)(a1 + 64) <= (int)v23)
      kd_encoder::init();
    if ((int)v23 <= 1)
      LODWORD(v23) = 1;
    if (v23 >= 0x20)
      LOBYTE(v23) = 32;
    *(_BYTE *)(a1 + 39) = v23;
  }
  *(_WORD *)(a1 + 84) = v20;
  v24 = (_WORD *)(a1 + 84);
  *(_WORD *)(a1 + 76) = 0;
  if (v21 <= v20)
  {
LABEL_22:
    *v24 = v21;
    goto LABEL_23;
  }
  result = kdu_thread_entity::get_num_threads(a6);
  if ((int)result >= 2)
  {
    v25 = 8u / *(unsigned __int8 *)(a1 + 39) + 1;
    result = kdu_subband::get_band_idx((kdu_subband *)&v39);
    if ((int)result <= v25)
    {
      v26 = *(_DWORD *)(a1 + 68) - v36.i32[0];
      if (v26 >= *(__int16 *)(a1 + 82))
        LOWORD(v26) = *(_WORD *)(a1 + 82);
      *(_WORD *)(a1 + 84) += v26;
      v35 = kdu_node::access_resolution((kdu_node *)&v39);
      result = kdu_resolution::get_dwt_level((kdu_resolution *)&v35);
      *(_WORD *)(a1 + 76) = 64 - result;
    }
  }
LABEL_23:
  v27 = 0;
  *(_WORD *)(a1 + 86) = 0;
  v28 = v36.i32[1];
  *(_WORD *)(a1 + 88) = v36.i16[0];
  *(_DWORD *)(a1 + 92) = 0;
  *(_BYTE *)(a1 + 38) = 0;
  v29 = *(_DWORD *)(a1 + 72);
  if (v28 < v29)
  {
    v30 = -v28;
    if (a4)
      v31 = 7;
    else
      v31 = 3;
    v27 = v31 & v30;
    *(_BYTE *)(a1 + 38) = v27;
  }
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  if (v38.i32[3] < 1 || *(uint64_t *)((char *)v38.i64 + 4) <= 0)
  {
    *(_DWORD *)(a1 + 68) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 96) = a3;
    kdu_sample_allocator::pre_alloc(a3, a4, 0, v29 + v27, *(__int16 *)(a1 + 84));
    v32 = operator new[]();
    v33 = 120;
    if (a4)
      v33 = 112;
    *(_QWORD *)(a1 + v33) = v32;
    result = *(_QWORD *)(a1 + 104);
    if (result)
    {
      v34 = *(unsigned __int16 *)(a1 + 34) != *(unsigned __int16 *)(a1 + 32) || roi_weight;
      if ((v34 & 1) != 0)
      {
        if (!*(_BYTE *)a3)
          kdu_sample_allocator::pre_alloc();
        *(_DWORD *)(a3 + 4) += ((((*(_DWORD *)(a1 + 72) + 1) & 0xFFFFFFFE) + 15) & 0xFFFFFFF0) * *(__int16 *)(a1 + 84);
        result = operator new[]();
        *(_QWORD *)(a1 + 128) = result;
      }
      else
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
        *(_QWORD *)(a1 + 104) = 0;
      }
    }
  }
  return result;
}

void kd_encoder::~kd_encoder(kd_encoder *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = &off_1E1BAB998;
  *((_QWORD *)this + 1) = &unk_1E1BAB9C8;
  v2 = *((_QWORD *)this + 14);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x20C8093837F09);
  v3 = *((_QWORD *)this + 15);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x20C8093837F09);
  v4 = *((_QWORD *)this + 16);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x10C80436913F5);
  v5 = *((_QWORD *)this + 13);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5);
  v6 = *((_QWORD *)this + 2);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  *(_QWORD *)this = off_1E1BB14A8;
  *((_QWORD *)this + 1) = off_1E1BABA78;
}

{
  kd_encoder::~kd_encoder(this);
  JUMPOUT(0x18D761C30);
}

void `non-virtual thunk to'kd_encoder::~kd_encoder(kd_encoder *this)
{
  kd_encoder::~kd_encoder((kd_encoder *)((char *)this - 8));
}

{
  kd_encoder::~kd_encoder((kd_encoder *)((char *)this - 8));
  JUMPOUT(0x18D761C30);
}

uint64_t kd_encoder::push(uint64_t result, int *a2, kdu_thread_entity *this)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  int v16;
  kdu_thread_queue *v17;
  int v18;
  int v19;
  __int16 v20;
  __int16 v21;
  int v22;
  uint64_t v23;
  void *v24;
  const void *v25;
  int v26;
  unsigned __int16 v27;
  kdu_thread_queue *v28;
  int v29;
  int v30;
  int v31;
  __int16 v32;
  __int16 v33;

  v5 = result;
  if (!this && *(_QWORD *)(result + 136))
    kd_encoder::push();
  if (!*a2)
    return result;
  if (!*(_BYTE *)(result + 37))
  {
    if (this)
      kdu_thread_entity::acquire_lock(this, 3, 1);
    v6 = *(__int16 *)(v5 + 84);
    if (*(_QWORD *)(v5 + 112))
    {
      if (v6 >= 1)
      {
        v7 = 0;
        v8 = *(unsigned __int8 *)(v5 + 38);
        do
        {
          v9 = kdu_sample_allocator::alloc16(*(kdu_sample_allocator **)(v5 + 96), 0, *(_DWORD *)(v5 + 72) + v8);
          v8 = *(unsigned __int8 *)(v5 + 38);
          *(_QWORD *)(*(_QWORD *)(v5 + 112) + 8 * v7++) = v9 + 2 * *(unsigned __int8 *)(v5 + 38);
          v10 = *(__int16 *)(v5 + 84);
        }
        while (v7 < v10);
LABEL_15:
        LOWORD(v6) = v10;
      }
    }
    else if (v6 >= 1)
    {
      v11 = 0;
      v12 = *(unsigned __int8 *)(v5 + 38);
      do
      {
        v13 = kdu_sample_allocator::alloc32(*(kdu_sample_allocator **)(v5 + 96), 0, *(_DWORD *)(v5 + 72) + v12);
        v12 = *(unsigned __int8 *)(v5 + 38);
        *(_QWORD *)(*(_QWORD *)(v5 + 120) + 8 * v11++) = v13 + 4 * *(unsigned __int8 *)(v5 + 38);
        v10 = *(__int16 *)(v5 + 84);
      }
      while (v11 < v10);
      goto LABEL_15;
    }
    if (*(_QWORD *)(v5 + 128))
      v14 = (__int16)v6 < 1;
    else
      v14 = 1;
    if (!v14)
    {
      v15 = 0;
      do
        *(_QWORD *)(*(_QWORD *)(v5 + 128) + 8 * v15++) = kdu_sample_allocator::alloc16(*(kdu_sample_allocator **)(v5 + 96), 0, (*(_DWORD *)(v5 + 72) + 1) >> 1);
      while (v15 < *(__int16 *)(v5 + 84));
    }
    *(_BYTE *)(v5 + 37) = 1;
    if (this)
      kdu_thread_entity::release_lock(this, 3);
  }
  if (*(int *)(v5 + 68) <= 0)
    kd_encoder::push();
  v16 = *(unsigned __int16 *)(v5 + 86);
  if (v16 == *(unsigned __int16 *)(v5 + 88))
  {
    v17 = *(kdu_thread_queue **)(v5 + 136);
    if (!v17)
      kd_encoder::push();
    kdu_thread_entity::process_jobs(this, v17, 0, 1);
    v18 = *(__int16 *)(v5 + 84);
    v19 = *(__int16 *)(v5 + 82);
    if (v18 <= v19)
      v20 = 0;
    else
      v20 = *(_WORD *)(v5 + 82);
    if (*(__int16 *)(v5 + 88) <= v19)
      LOWORD(v16) = v20;
    else
      LOWORD(v16) = 0;
    *(_WORD *)(v5 + 86) = v16;
    if (*(_DWORD *)(v5 + 68) < v19)
      LOWORD(v19) = *(_DWORD *)(v5 + 68);
    v21 = v19 + v16;
    *(_WORD *)(v5 + 88) = v21;
    if (v18 < v21)
      kd_encoder::push();
  }
  v22 = *a2;
  if (*a2 != *(_DWORD *)(v5 + 72))
    kd_encoder::push();
  v23 = *(_QWORD *)(v5 + 120);
  if (v23)
  {
    v24 = *(void **)(v23 + 8 * (__int16)v16);
    if ((*((_BYTE *)a2 + 6) & 2) != 0)
      v25 = 0;
    else
      v25 = (const void *)*((_QWORD *)a2 + 1);
    v26 = 4 * v22;
  }
  else
  {
    v24 = *(void **)(*(_QWORD *)(v5 + 112) + 8 * (__int16)v16);
    if ((*((_BYTE *)a2 + 6) & 2) != 0)
      v25 = (const void *)*((_QWORD *)a2 + 1);
    else
      v25 = 0;
    v26 = 2 * v22;
  }
  memcpy(v24, v25, v26);
  result = *(_QWORD *)(v5 + 104);
  if (result)
  {
    if (this)
    {
      kdu_thread_entity::acquire_lock(this, 4, 1);
      result = *(_QWORD *)(v5 + 104);
    }
    result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)result + 24))(result, *(_QWORD *)(*(_QWORD *)(v5 + 128) + 8 * *(__int16 *)(v5 + 86)), *(unsigned int *)(v5 + 72));
    if (this)
      result = kdu_thread_entity::release_lock(this, 4);
  }
  --*(_DWORD *)(v5 + 68);
  v27 = *(_WORD *)(v5 + 86) + 1;
  *(_WORD *)(v5 + 86) = v27;
  if (*(unsigned __int16 *)(v5 + 88) == v27)
  {
    v28 = *(kdu_thread_queue **)(v5 + 136);
    v29 = *(unsigned __int8 *)(v5 + 39);
    if (v28)
    {
      result = kdu_thread_entity::add_jobs((uint64_t)this, v28, v29, *(unsigned __int16 *)(v5 + 76));
      if (!*(_WORD *)(v5 + 76) || *(_DWORD *)(v5 + 92))
        return result;
      v30 = *(__int16 *)(v5 + 82);
      if (*(__int16 *)(v5 + 88) > v30)
        kd_encoder::push();
      v31 = 1;
      v32 = *(_WORD *)(v5 + 82);
    }
    else
    {
      if (v29 != 1)
        kd_encoder::push();
      result = (*(uint64_t (**)(uint64_t, kdu_thread_entity *, _QWORD))(*(_QWORD *)v5 + 24))(v5, this, *(unsigned int *)(v5 + 92));
      v32 = 0;
      LOWORD(v30) = *(_WORD *)(v5 + 82);
      v31 = *(_DWORD *)(v5 + 92) + 1;
    }
    *(_WORD *)(v5 + 86) = v32;
    *(_DWORD *)(v5 + 92) = v31;
    if (*(_DWORD *)(v5 + 68) < (__int16)v30)
      LOWORD(v30) = *(_DWORD *)(v5 + 68);
    v33 = v30 + v32;
    *(_WORD *)(v5 + 88) = v33;
    if (*(__int16 *)(v5 + 84) < v33)
      kd_encoder::push();
  }
  return result;
}

void kd_encoder::do_job(kd_encoder *this, kdu_thread_entity *a2, int a3)
{
  signed int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t *v21;
  _DWORD *v22;
  _DWORD *v23;
  signed int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  unsigned int *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  unsigned __int16 *v38;
  int v39;
  char v40;
  unsigned int v41;
  int v42;
  int *v43;
  unsigned int *v44;
  int v45;
  unsigned int v46;
  _QWORD *v47;
  int v48;
  char v49;
  __int16 *v50;
  unsigned int *v51;
  int v52;
  int v53;
  unsigned int v54;
  float v55;
  float v56;
  float v57;
  float *v58;
  unsigned int *v59;
  int v60;
  float v61;
  unsigned int v62;
  int v63;
  uint64_t v64;
  int *v65;
  unsigned int v66;
  float v67;
  float v68;
  float v69;
  int v70;
  __int16 *v71;
  unsigned int *v72;
  int v73;
  int v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  float *v78;
  float v79;
  unsigned int v80;
  int v81;
  uint64_t v82;
  __int16 *v83;
  int v84;
  unsigned int v85;
  int v86;
  uint64_t v87;
  __int16 *v88;
  int v89;
  unsigned int v90;
  int v91;
  int v92;
  BOOL v93;
  int v94;
  uint64_t v95;
  int v96;
  int v97;
  int v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  int v102;
  int v103;
  _QWORD *v104;
  _BYTE *v105;
  int v106;
  unsigned __int16 *v107;
  int v108;
  int v109;
  _QWORD *v110;
  unsigned int *v111;
  char v112;
  char v113;
  _BYTE *v114;
  unsigned int *v115;
  int v116;
  uint64_t v117;
  _BYTE *v118;
  BOOL v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  float v125;
  _DWORD *exception;
  uint64_t v127;
  uint64_t *v128;
  kdu_thread_entity *v129;
  uint64_t v130;
  unsigned int conservative_slope_threshold;
  uint64_t v132;
  __int16 *v133;
  uint64_t v134;
  int v135;
  int v136;
  int v137;
  unsigned __int16 *v138;
  __int128 v139;
  __int128 v140;
  uint64_t v141;

  v5 = *((unsigned __int8 *)this + 39);
  v6 = *((_DWORD *)this + 16);
  v7 = *((_DWORD *)this + 13);
  v8 = *((unsigned int *)this + 14);
  v10 = *((_QWORD *)this + 14);
  v9 = *((_QWORD *)this + 15);
  v11 = *((_QWORD *)this + 16);
  v12 = a3 / v5;
  if (((a3 / v5) & 1) != 0)
  {
    v13 = *((__int16 *)this + 41);
    v14 = v9 + 8 * v13;
    if (!v9)
      v14 = 0;
    v15 = v10 + 8 * v13;
    if (!v10)
      v15 = 0;
    v16 = v11 + 8 * v13;
    if (!v11)
      v16 = 0;
    if (*((__int16 *)this + 42) > *((__int16 *)this + 41))
    {
      v9 = v14;
      v10 = v15;
      v11 = v16;
    }
  }
  if (v12 >= *((_DWORD *)this + 15))
    kd_encoder::do_job();
  v132 = v9;
  v127 = v10;
  v134 = v11;
  if (v5 >= 2)
  {
    v17 = a3 % v5 * v6;
    v18 = v17 / v5;
    v19 = (v6 + v17) / v5;
    v6 = v19 - v18;
    if (v19 <= v18)
      kd_encoder::do_job();
    if (v18 < 1)
    {
      v20 = 0;
    }
    else
    {
      v8 = (v18 + v8);
      v20 = *((__int16 *)this + 39) + (v18 - 1) * *((__int16 *)this + 40);
    }
    v21 = (uint64_t *)((char *)this + 24);
    conservative_slope_threshold = kdu_subband::get_conservative_slope_threshold((kd_encoder *)((char *)this + 24));
    goto LABEL_19;
  }
  v21 = (uint64_t *)((char *)this + 24);
  conservative_slope_threshold = kdu_subband::get_conservative_slope_threshold((kd_encoder *)((char *)this + 24));
  if (v6 >= 1)
  {
    v20 = 0;
LABEL_19:
    v129 = a2;
    v130 = (v12 + v7);
    v133 = (__int16 *)((char *)this + 32);
    v138 = (unsigned __int16 *)((char *)this + 34);
    v128 = v21;
    do
    {
      v22 = (_DWORD *)kdu_subband::open_block(v21, v130 | (v8 << 32), 0, a2);
      if (!v22)
      {
        exception = __cxa_allocate_exception(4uLL);
        *exception = -50;
        __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
      }
      v23 = v22;
      v24 = ((*v22 + 3) & 0xFFFFFFFC) * v22[1];
      if (v24 <= 0)
        kd_encoder::do_job();
      if (v22[28] < v24)
      {
        if (v24 <= 4096)
          v25 = 4096;
        else
          v25 = ((*v22 + 3) & 0xFFFFFFFC) * v22[1];
        kdu_block::set_max_samples((uint64_t)v22, v25);
      }
      v26 = *(_QWORD *)v23;
      v27 = HIDWORD(*(_QWORD *)v23);
      if (*((_QWORD *)v23 + 2) != *(_QWORD *)v23 || v23[3] || v23[2])
        kd_encoder::do_job();
      v28 = *((unsigned __int8 *)v23 + 24);
      if (*((_BYTE *)v23 + 24))
        v29 = *(_QWORD *)v23;
      else
        v29 = HIDWORD(*(_QWORD *)v23);
      if (*((_BYTE *)v23 + 24))
        v30 = HIDWORD(*(_QWORD *)v23);
      else
        v30 = *(_QWORD *)v23;
      if (v29 + v20 > *((_DWORD *)this + 18))
        kd_encoder::do_job();
      v135 = v29 + v20;
      v136 = v8;
      v31 = (unsigned int *)*((_QWORD *)v23 + 12);
      if (*((_BYTE *)v23 + 26))
        v32 = v29 - 1;
      else
        v32 = 0;
      if (*((_BYTE *)v23 + 26))
        v33 = -1;
      else
        v33 = 1;
      if (*((_BYTE *)v23 + 25))
        v34 = -1;
      else
        v34 = 1;
      v35 = v32 + (uint64_t)v20;
      if (*((_BYTE *)v23 + 25))
        v36 = v30 - 1;
      else
        v36 = 0;
      v137 = v6;
      if (v132)
      {
        v37 = (_QWORD *)(v132 + 8 * v36);
        v38 = (unsigned __int16 *)((char *)this + 32);
        if (*((_BYTE *)this + 36))
        {
          v39 = *v133;
          if (v39 >= 32)
          {
            v141 = 0;
            v139 = 0u;
            v140 = 0u;
            kdu_error::kdu_error((kdu_error *)&v139, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v139 + 16))(&v139, "Insufficient implementation precision available for true reversible compression!");
            kdu_error::~kdu_error((kdu_error *)&v139);
          }
          v40 = 31 - v39;
          if (!*((_BYTE *)v23 + 24))
          {
            if (v30)
            {
              v41 = 0;
              v63 = v30;
              do
              {
                if (v29)
                {
                  v64 = 0;
                  v65 = (int *)(*v37 + 4 * (int)v35);
                  do
                  {
                    if (*v65 >= 0)
                      v66 = *v65 << v40;
                    else
                      v66 = (-*v65 << v40) | 0x80000000;
                    v31[v64] = v66;
                    v41 |= v66;
                    v65 += v33;
                    ++v64;
                  }
                  while (v29 != (_DWORD)v64);
                }
                v37 += v34;
                v31 += v26 >> 32;
                --v63;
              }
              while (v63);
LABEL_139:
              v28 = 0;
              goto LABEL_141;
            }
            goto LABEL_140;
          }
          if (!v30)
            goto LABEL_111;
          v41 = 0;
          v42 = v30;
          do
          {
            if (v29)
            {
              v43 = (int *)(*v37 + 4 * (int)v35);
              v44 = v31;
              v45 = v29;
              do
              {
                if (*v43 >= 0)
                  v46 = *v43 << v40;
                else
                  v46 = (-*v43 << v40) | 0x80000000;
                *v44 = v46;
                v41 |= v46;
                v43 += v33;
                v44 += v26 >> 32;
                --v45;
              }
              while (v45);
            }
            v37 += v34;
            ++v31;
            --v42;
          }
          while (v42);
        }
        else
        {
          v55 = 1.0 / *((float *)this + 10);
          v56 = v55 / (float)(1 << (*((_WORD *)this + 16) - 31));
          v57 = v55 * (float)(int)(0x80000000 >> *((_WORD *)this + 16));
          if (*((__int16 *)this + 16) > 31)
            v57 = v56;
          if (!*((_BYTE *)v23 + 24))
          {
            if ((_DWORD)v26)
            {
              v41 = 0;
              v76 = *(_QWORD *)v23;
              do
              {
                if ((_DWORD)v27)
                {
                  v77 = 0;
                  v78 = (float *)(*v37 + 4 * (int)v35);
                  do
                  {
                    v79 = v57 * *v78;
                    v80 = (int)v79;
                    if (v79 < 0.0)
                      v80 = (int)(float)-v79 | 0x80000000;
                    v31[v77] = v80;
                    v41 |= v80;
                    v78 += v33;
                    ++v77;
                  }
                  while (v29 != (_DWORD)v77);
                }
                v37 += v34;
                v31 += v26 >> 32;
                --v76;
              }
              while (v76);
              goto LABEL_139;
            }
            goto LABEL_140;
          }
          if (!(_DWORD)v27)
            goto LABEL_111;
          v41 = 0;
          do
          {
            if ((_DWORD)v26)
            {
              v58 = (float *)(*v37 + 4 * (int)v35);
              v59 = v31;
              v60 = v29;
              do
              {
                v61 = v57 * *v58;
                v62 = (int)v61;
                if (v61 < 0.0)
                  v62 = (int)(float)-v61 | 0x80000000;
                *v59 = v62;
                v41 |= v62;
                v58 += v33;
                v59 += v26 >> 32;
                --v60;
              }
              while (v60);
            }
            v37 += v34;
            ++v31;
            LODWORD(v27) = v27 - 1;
          }
          while ((_DWORD)v27);
        }
      }
      else
      {
        v47 = (_QWORD *)(v127 + 8 * v36);
        v38 = (unsigned __int16 *)((char *)this + 32);
        if (*((_BYTE *)this + 36))
        {
          v48 = *v133;
          if (v48 >= 32)
            kd_encoder::do_job();
          v49 = 31 - v48;
          if (!*((_BYTE *)v23 + 24))
          {
            if ((_DWORD)v26)
            {
              v41 = 0;
              v81 = *(_QWORD *)v23;
              do
              {
                if ((_DWORD)v27)
                {
                  v82 = 0;
                  v83 = (__int16 *)(*v47 + 2 * (int)v35);
                  do
                  {
                    v84 = *v83;
                    if (v84 >= 0)
                      v85 = v84 << v49;
                    else
                      v85 = (-v84 << v49) | 0x80000000;
                    v31[v82] = v85;
                    v41 |= v85;
                    v83 += v33;
                    ++v82;
                  }
                  while (v29 != (_DWORD)v82);
                }
                v47 += v34;
                v31 += v26 >> 32;
                --v81;
              }
              while (v81);
              goto LABEL_139;
            }
            goto LABEL_140;
          }
          if (!(_DWORD)v27)
            goto LABEL_111;
          v41 = 0;
          do
          {
            if ((_DWORD)v26)
            {
              v50 = (__int16 *)(*v47 + 2 * (int)v35);
              v51 = v31;
              v52 = v29;
              do
              {
                v53 = *v50;
                if (v53 >= 0)
                  v54 = v53 << v49;
                else
                  v54 = (-v53 << v49) | 0x80000000;
                *v51 = v54;
                v41 |= v54;
                v50 += v33;
                v51 += v26 >> 32;
                --v52;
              }
              while (v52);
            }
            v47 += v34;
            ++v31;
            LODWORD(v27) = v27 - 1;
          }
          while ((_DWORD)v27);
        }
        else
        {
          v67 = 1.0 / (float)(*((float *)this + 10) * 8192.0);
          v68 = v67 / (float)(1 << (*((_WORD *)this + 16) - 31));
          v69 = v67 * (float)(int)(0x80000000 >> *((_WORD *)this + 16));
          if (*((__int16 *)this + 16) > 31)
            v69 = v68;
          v70 = (int)(float)(v69 + 0.5);
          if (!*((_BYTE *)v23 + 24))
          {
            if ((_DWORD)v26)
            {
              v41 = 0;
              v86 = *(_QWORD *)v23;
              do
              {
                if ((_DWORD)v27)
                {
                  v87 = 0;
                  v88 = (__int16 *)(*v47 + 2 * (int)v35);
                  do
                  {
                    v89 = *v88 * v70;
                    v90 = -v89 | 0x80000000;
                    if (v89 >= 0)
                      v90 = *v88 * v70;
                    v31[v87] = v90;
                    v41 |= v90;
                    v88 += v33;
                    ++v87;
                  }
                  while (v29 != (_DWORD)v87);
                }
                v47 += v34;
                v31 += v26 >> 32;
                --v86;
              }
              while (v86);
              goto LABEL_139;
            }
LABEL_140:
            v28 = 0;
            v41 = 0;
            goto LABEL_141;
          }
          if (!(_DWORD)v27)
          {
LABEL_111:
            v41 = 0;
            v28 = 1;
            goto LABEL_141;
          }
          v41 = 0;
          do
          {
            if ((_DWORD)v26)
            {
              v71 = (__int16 *)(*v47 + 2 * (int)v35);
              v72 = v31;
              v73 = v29;
              do
              {
                v74 = *v71 * v70;
                v75 = -v74 | 0x80000000;
                if (v74 >= 0)
                  v75 = *v71 * v70;
                *v72 = v75;
                v41 |= v75;
                v71 += v33;
                v72 += v26 >> 32;
                --v73;
              }
              while (v73);
            }
            v47 += v34;
            ++v31;
            LODWORD(v27) = v27 - 1;
          }
          while ((_DWORD)v27);
        }
      }
LABEL_141:
      v91 = (__int16)*v138;
      v92 = (__int16)*v38;
      v93 = __OFSUB__(v91, v92);
      v94 = v91 - v92;
      if ((v94 < 0) ^ v93 | (v94 == 0))
      {
        v97 = v137;
      }
      else
      {
        v95 = *((_QWORD *)v23 + 12);
        if (v94 < v92)
        {
          v141 = 0;
          v139 = 0u;
          v140 = 0u;
          kdu_error::kdu_error((kdu_error *)&v139, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v139 + 16))(&v139, "You have selected too small a value for the ROI up-shift parameter.  The up-shift should be at least as large as the largest number of magnitude bit-planes in any subband; otherwise, the foreground and background reg"
            "ions might not be properly distinguished by the decompressor.");
          kdu_error::~kdu_error((kdu_error *)&v139);
        }
        v96 = -1 << ~(_BYTE)v92;
        if (v28)
        {
          v97 = v137;
          if (v29)
          {
            v98 = v29;
            do
            {
              if (v30)
              {
                v99 = 0;
                do
                  *(_DWORD *)(v95 + 4 * v99++) &= v96;
                while (v30 != (_DWORD)v99);
              }
              v95 += 4 * (v26 >> 32);
              --v98;
            }
            while (v98);
          }
          v28 = 1;
        }
        else
        {
          v97 = v137;
          if (v30)
          {
            v100 = v30;
            do
            {
              if (v29)
              {
                v101 = 0;
                do
                  *(_DWORD *)(v95 + 4 * v101++) &= v96;
                while (v29 != (_DWORD)v101);
              }
              v95 += 4 * (v26 >> 32);
              --v100;
            }
            while (v100);
          }
          v28 = 0;
        }
      }
      if (!v134)
        goto LABEL_170;
      v102 = *v138;
      v103 = *v38;
      if (v102 == v103)
      {
        if (v30)
        {
          v104 = (_QWORD *)(v134 + 8 * v36);
          while (!v29)
          {
LABEL_168:
            v104 += v34;
            if (!--v30)
              goto LABEL_171;
          }
          v105 = (_BYTE *)(*v104 + (int)v35);
          v106 = v29;
          while (!*v105)
          {
            v105 += v33;
            if (!--v106)
              goto LABEL_168;
          }
LABEL_170:
          v30 = 1;
        }
LABEL_171:
        v107 = v38;
        v21 = v128;
        a2 = v129;
        goto LABEL_199;
      }
      v108 = (__int16)v103;
      v109 = (__int16)v102 - (__int16)v103;
      if (v109 < v108)
        kd_encoder::do_job();
      v110 = (_QWORD *)(v134 + 8 * v36);
      v111 = (unsigned int *)*((_QWORD *)v23 + 12);
      if (v28)
      {
        if (v30)
        {
          v112 = 0;
          v113 = 0;
          do
          {
            if (v29)
            {
              v114 = (_BYTE *)(*v110 + (int)v35);
              v115 = v111;
              v116 = v29;
              do
              {
                if (*v114)
                {
                  v112 = 1;
                }
                else
                {
                  *v115 = ((*v115 & 0x7FFFFFFF) >> v109) | *v115 & 0x80000000;
                  v113 = 1;
                }
                v114 += v33;
                v115 += v26 >> 32;
                --v116;
              }
              while (v116);
            }
            v110 += v34;
            ++v111;
            --v30;
          }
          while (v30);
LABEL_193:
          v21 = v128;
          a2 = v129;
          if ((v112 & 1) == 0)
            v41 = (v41 & 0x7FFFFFFF) >> v109;
          goto LABEL_196;
        }
      }
      else if (v30)
      {
        v112 = 0;
        v113 = 0;
        do
        {
          if (v29)
          {
            v117 = 0;
            v118 = (_BYTE *)(*v110 + v35);
            do
            {
              if (*v118)
              {
                v112 = 1;
              }
              else
              {
                v111[v117] = ((v111[v117] & 0x7FFFFFFF) >> v109) | v111[v117] & 0x80000000;
                v113 = 1;
              }
              v118 += v33;
              ++v117;
            }
            while (v29 != (_DWORD)v117);
          }
          v110 += v34;
          v111 += v26 >> 32;
          --v30;
        }
        while (v30);
        goto LABEL_193;
      }
      v113 = 0;
      v41 = (v41 & 0x7FFFFFFF) >> v109;
      v21 = v128;
      a2 = v129;
LABEL_196:
      v119 = (v113 & 1) == 0;
      v107 = (unsigned __int16 *)((char *)this + 34);
      if (v119)
        v107 = v38;
      v30 = 1;
LABEL_199:
      v120 = (__int16)*v107;
      if (v120 >= 31 && *((_BYTE *)this + 36) && (__int16)*v138 > (__int16)*v38 && !*((_BYTE *)v23 + 121))
      {
        *((_BYTE *)v23 + 121) = 1;
        v141 = 0;
        v139 = 0u;
        v140 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v139, "Kakadu Core Warning:\n");
        kdu_warning::~kdu_warning((kdu_warning *)&v139);
      }
      if (v120 >= 31)
        v121 = 31;
      else
        v121 = v120;
      v122 = v41 & 0x7FFFFFFF;
      if ((v41 & 0x7FFFFFFF) == 0)
      {
        v23[11] = 31;
LABEL_213:
        v123 = 0;
        v23[11] = v121;
        goto LABEL_214;
      }
      v123 = 3 * v121 + 1;
      v124 = -1;
      do
      {
        v122 *= 2;
        ++v124;
        v123 -= 3;
      }
      while ((v122 & 0x80000000) == 0);
      v23[11] = v124;
      if (v124 >= v121)
        goto LABEL_213;
LABEL_214:
      v23[12] = v123;
      v125 = *((float *)this + 11);
      if (v30)
        v125 = v125 * *((float *)this + 12);
      (*(void (**)(_QWORD, _DWORD *, _QWORD, _QWORD, uint64_t, uint64_t, double))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2), v23, *((unsigned __int8 *)this + 36), conservative_slope_threshold, 31, v35, v125);
      kdu_subband::close_block((uint64_t)v21, (kdu_block *)v23, (uint64_t)a2);
      v8 = (v136 + 1);
      v20 = v135;
      v93 = __OFSUB__(v97, 1);
      v6 = v97 - 1;
    }
    while (!((v6 < 0) ^ v93 | (v6 == 0)));
  }
}

void sub_187F6C6A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'kd_encoder::do_job(kd_encoder *this, kdu_thread_entity *a2, int a3)
{
  kd_encoder::do_job((kd_encoder *)((char *)this - 8), a2, a3);
}

void kd_encoder::kd_encoder(kd_encoder *this)
{
  *(_QWORD *)this = &off_1E1BAB998;
  *((_QWORD *)this + 1) = &unk_1E1BAB9C8;
  kdu_block_encoder::kdu_block_encoder((kd_encoder *)((char *)this + 16));
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)((char *)this + 60) = 0;
  *(_QWORD *)((char *)this + 52) = 0;
  *((_BYTE *)this + 37) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
}

void sub_187F6C730(_Unwind_Exception *a1)
{
  _QWORD *v1;

  *v1 = off_1E1BB14A8;
  v1[1] = off_1E1BABA78;
  _Unwind_Resume(a1);
}

void kd_multi_line::reset(kd_multi_line *this, int a2, float a3)
{
  char v4;
  float *v5;
  _WORD *v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  __int16 v15;
  unsigned int v16;

  v4 = *((_BYTE *)this + 6);
  if ((v4 & 2) != 0)
    v5 = 0;
  else
    v5 = (float *)*((_QWORD *)this + 1);
  if ((*((_BYTE *)this + 6) & 2) != 0)
    v6 = (_WORD *)*((_QWORD *)this + 1);
  else
    v6 = 0;
  v7 = v4 & 1;
  if (*((unsigned __int8 *)this + 36) != v7)
    kd_multi_line::reset();
  if (v7)
  {
    if (v6)
    {
      v8 = *((_DWORD *)this + 5);
      if (!a2)
        goto LABEL_18;
      if (v8 >= 1)
      {
        v9 = v8 + 1;
        do
        {
          *v6++ = a2;
          --v9;
        }
        while (v9 > 1);
      }
    }
    else
    {
      if (!v5)
        kd_multi_line::reset();
      v12 = *((_DWORD *)this + 5);
      if (a2)
      {
        if (v12 >= 1)
        {
          v13 = v12 + 1;
          do
          {
            *(_DWORD *)v5++ = a2;
            --v13;
          }
          while (v13 > 1);
        }
      }
      else
      {
        bzero(v5, 4 * v12);
      }
    }
  }
  else if (v6)
  {
    if (a3 == 0.0)
    {
      v8 = *((_DWORD *)this + 5);
LABEL_18:
      bzero(v6, 2 * v8);
      return;
    }
    v14 = *((_DWORD *)this + 5);
    if (v14 >= 1)
    {
      v15 = vcvtmd_s64_f64((float)(a3 * 8192.0) + 0.5);
      v16 = v14 + 1;
      do
      {
        *v6++ = v15;
        --v16;
      }
      while (v16 > 1);
    }
  }
  else
  {
    v10 = *((_DWORD *)this + 5);
    if (v10 >= 1)
    {
      v11 = v10 + 1;
      do
      {
        *v5++ = a3;
        --v11;
      }
      while (v11 > 1);
    }
  }
}

uint64_t kd_multi_line::apply_offset(uint64_t this, int a2, float a3)
{
  float *v3;
  _WORD *v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  __int16 v11;
  unsigned int v12;

  if ((*(_BYTE *)(this + 6) & 2) != 0)
    v3 = 0;
  else
    v3 = *(float **)(this + 8);
  if ((*(_BYTE *)(this + 6) & 2) != 0)
    v4 = *(_WORD **)(this + 8);
  else
    v4 = 0;
  if (*(_BYTE *)(this + 36))
  {
    if (a2)
    {
      v5 = *(_DWORD *)(this + 20);
      if (v3)
      {
        if (v5 >= 1)
        {
          v6 = v5 + 1;
          do
          {
            *(_DWORD *)v3++ += a2;
            --v6;
          }
          while (v6 > 1);
        }
      }
      else if (v5 >= 1)
      {
        v9 = v5 + 1;
        do
        {
          *v4++ += a2;
          --v9;
        }
        while (v9 > 1);
      }
    }
  }
  else if (a3 != 0.0)
  {
    if (v3)
    {
      v7 = *(_DWORD *)(this + 20);
      if (v7 >= 1)
      {
        v8 = v7 + 1;
        do
        {
          *v3 = *v3 + a3;
          ++v3;
          --v8;
        }
        while (v8 > 1);
      }
    }
    else
    {
      v10 = *(_DWORD *)(this + 20);
      if (v10 >= 1)
      {
        v11 = vcvtmd_s64_f64((float)(a3 * 8192.0) + 0.5);
        v12 = v10 + 1;
        do
        {
          *v4++ += v11;
          --v12;
        }
        while (v12 > 1);
      }
    }
  }
  return this;
}

uint64_t kd_multi_line::copy(uint64_t this, kd_multi_line *a2, int a3, float a4)
{
  int v4;
  float *v5;
  _WORD *v6;
  float *v7;
  __int16 *v8;
  unsigned int v9;
  float v10;
  float v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  __int16 v15;
  double v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  float v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  __int16 v25;
  unsigned int v26;
  __int16 v27;
  int v28;
  float v29;
  unsigned int v30;
  float v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;

  v4 = *((_DWORD *)a2 + 5);
  if (v4 != *(_DWORD *)(this + 20))
    kd_multi_line::copy();
  if ((*(_BYTE *)(this + 6) & 2) != 0)
    v5 = 0;
  else
    v5 = *(float **)(this + 8);
  if ((*(_BYTE *)(this + 6) & 2) != 0)
    v6 = *(_WORD **)(this + 8);
  else
    v6 = 0;
  if ((*((_BYTE *)a2 + 6) & 2) != 0)
    v7 = 0;
  else
    v7 = (float *)*((_QWORD *)a2 + 1);
  if ((*((_BYTE *)a2 + 6) & 2) != 0)
    v8 = (__int16 *)*((_QWORD *)a2 + 1);
  else
    v8 = 0;
  if (*(_BYTE *)(this + 36))
  {
    if (!*((_BYTE *)a2 + 36))
      kd_multi_line::copy();
    if (v5)
    {
      if (v4 >= 1)
      {
        v9 = v4 + 1;
        do
        {
          v10 = *v7++;
          *(_DWORD *)v5++ = LODWORD(v10) + a3;
          --v9;
        }
        while (v9 > 1);
      }
    }
    else if (v4 >= 1)
    {
      v14 = v4 + 1;
      do
      {
        v15 = *v8++;
        *v6++ = v15 + a3;
        --v14;
      }
      while (v14 > 1);
    }
  }
  else if (v5)
  {
    if (*((_BYTE *)a2 + 36))
    {
      if (v4 >= 1)
      {
        v11 = 1.0 / (float)(1 << *(_DWORD *)(this + 40));
        v12 = v4 + 1;
        do
        {
          v13 = *(_DWORD *)v7++;
          *v5++ = a4 + (float)((float)v13 * v11);
          --v12;
        }
        while (v12 > 1);
      }
    }
    else
    {
      v18 = *((_DWORD *)a2 + 10);
      v19 = *(_DWORD *)(this + 40);
      if (v18 == v19)
      {
        if (v4 >= 1)
        {
          v20 = v4 + 1;
          do
          {
            v21 = *v7++;
            *v5++ = v21 + a4;
            --v20;
          }
          while (v20 > 1);
        }
      }
      else if (v4 >= 1)
      {
        v28 = 1 << v18;
        v29 = (float)(1 << v19);
        v30 = v4 + 1;
        do
        {
          v31 = *v7++;
          *v5++ = a4 + (float)(v31 * (float)((float)v28 / v29));
          --v30;
        }
        while (v30 > 1);
      }
    }
  }
  else
  {
    v16 = (float)(a4 * 8192.0) + 0.5;
    if (*((_BYTE *)a2 + 36))
      v17 = 13;
    else
      v17 = *((_DWORD *)a2 + 10);
    v22 = vcvtmd_s64_f64(v16);
    v23 = v17 - *(_DWORD *)(this + 40);
    if (v23)
    {
      if (v23 < 1)
      {
        if (v4 >= 1)
        {
          v32 = -v23;
          v33 = (v22 << -(char)v23) + (1 << ~(_BYTE)v23);
          v34 = v4 + 1;
          do
          {
            v35 = *v8++;
            *v6++ = (v33 + v35) >> v32;
            --v34;
          }
          while (v34 > 1);
        }
      }
      else if (v4 >= 1)
      {
        v26 = v4 + 1;
        do
        {
          v27 = *v8++;
          *v6++ = (v27 << v23) + v22;
          --v26;
        }
        while (v26 > 1);
      }
    }
    else if (v4 >= 1)
    {
      v24 = v4 + 1;
      do
      {
        v25 = *v8++;
        *v6++ = v25 + v22;
        --v24;
      }
      while (v24 > 1);
    }
  }
  return this;
}

void kd_multi_transform::~kd_multi_transform(kd_multi_transform *this)
{
  _QWORD *i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)this = &off_1E1BB19A8;
  for (i = (_QWORD *)*((_QWORD *)this + 2); ; i = (_QWORD *)*((_QWORD *)this + 2))
  {
    *((_QWORD *)this + 3) = i;
    if (!i)
      break;
    *((_QWORD *)this + 2) = i[6];
    (*(void (**)(_QWORD *))(*i + 8))(i);
  }
  while (1)
  {
    v4 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 6) = v4;
    if (!v4)
      break;
    v3 = *(_QWORD *)(v4 + 8);
    *((_QWORD *)this + 5) = *(_QWORD *)(v4 + 16);
    if (v3)
      MEMORY[0x18D761C18](v3, 0x20C8093837F09);
    MEMORY[0x18D761C30](v4, 0x10A0C40AA2F9B3ELL);
  }
  v5 = *((_QWORD *)this + 7);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1020C80587BA0B9);
  v6 = *((_QWORD *)this + 4);
  if (v6)
  {
    v7 = v6 - 16;
    v8 = *(_QWORD *)(v6 - 8);
    if (v8)
    {
      v9 = v6 - 160;
      v10 = 160 * v8;
      do
      {
        kd_multi_component::~kd_multi_component((kd_multi_component *)(v9 + v10));
        v10 -= 160;
      }
      while (v10);
    }
    MEMORY[0x18D761C18](v7, 0x10A1C80A5FDC87BLL);
  }
  v11 = *((_QWORD *)this + 14);
  if (v11)
    MEMORY[0x18D761C18](v11, 0x1000C8052888210);
  v12 = *((_QWORD *)this + 16);
  if (v12)
    MEMORY[0x18D761C18](v12, 0x1000C8052888210);
  v13 = *((_QWORD *)this + 11);
  if (v13)
    MEMORY[0x18D761C18](v13, 0x1000C8077774924);
}

{
  kd_multi_transform::~kd_multi_transform(this);
  JUMPOUT(0x18D761C30);
}

uint64_t kd_multi_transform::construct(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, char a5, char a6, int a7, kdu_thread_entity *a8, char *a9, char a10)
{
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int *scratch_ints;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int reversible;
  uint64_t v31;
  int bit_depth;
  uint64_t v33;
  int v34;
  char *v35;
  char v36;
  uint64_t v37;
  int *v38;
  char v40;
  uint64_t v41;
  int *v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  void (**v54)(kd_multi_rxform_block *__hidden);
  BOOL v55;
  uint64_t v56;
  uint64_t *v57;
  int *v58;
  int v59;
  unsigned int v60;
  _QWORD *v61;
  uint64_t v62;
  int v63;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t tile_idx;
  uint64_t i;
  uint64_t v74;
  float *v75;
  int v76;
  uint64_t result;
  int *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  char v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t j;
  uint64_t v89;
  uint64_t k;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  BOOL v97;
  int v98;
  unsigned int *v99;
  uint64_t v100;
  uint64_t m;
  uint64_t v102;
  uint64_t v103;
  char v104;
  BOOL v105[4];
  int v106;
  BOOL v107;
  BOOL v108[2];
  float *v109[2];
  __int128 v110;
  uint64_t v111;
  int32x4_t v112;
  int v113[2];
  int v114[2];
  int v115[2];
  int v116[2];
  uint64_t *v117;
  uint64_t v118[2];

  v117 = a3;
  v118[0] = a2;
  v15 = (a5 & 1) == 0 && kdu_tile::get_ycc((kdu_tile *)&v117);
  *(_BYTE *)(a1 + 8) = v15;
  *(_QWORD *)v115 = 0;
  *(_QWORD *)v116 = 0;
  v16 = operator new();
  *(_DWORD *)v16 = 0;
  *(_QWORD *)(v16 + 8) = 0;
  *(_OWORD *)(v16 + 16) = 0u;
  *(_QWORD *)(a1 + 40) = v16;
  *(_QWORD *)(a1 + 48) = v16;
  if ((kdu_tile::get_mct_block_info(&v117, 0, 0, (unsigned int *)&v116[1], v116, &v115[1], v115, 0, 0, 0, 0, 0) & 1) == 0)kd_multi_transform::construct();
  *(_DWORD *)v16 = v116[1];
  *(_QWORD *)(v16 + 8) = operator new[]();
  v17 = v116[1];
  is_mul_ok(v116[1], 0xA0uLL);
  v18 = (_QWORD *)operator new[]();
  *v18 = 160;
  v18[1] = v17;
  v19 = v18 + 2;
  if ((_DWORD)v17)
  {
    v20 = v18 + 2;
    do
    {
      *v20 = &off_1E1BB18C8;
      *((_DWORD *)v20 + 6) = 0;
      *(_QWORD *)((char *)v20 + 38) = 0;
      *(_QWORD *)((char *)v20 + 30) = 0;
      *((_WORD *)v20 + 23) = 0;
      *((_DWORD *)v20 + 12) = -1;
      *(_QWORD *)((char *)v20 + 52) = 0;
      *(_QWORD *)((char *)v20 + 68) = 0;
      *(_QWORD *)((char *)v20 + 60) = 0;
      v20[10] = 0;
      v20[11] = 0;
      *((_DWORD *)v20 + 24) = -1;
      *((_DWORD *)v20 + 2) = 0;
      v20[2] = 0;
      *((_BYTE *)v20 + 104) = 0;
      *(_QWORD *)((char *)v20 + 108) = 0;
      *(_QWORD *)((char *)v20 + 124) = 0;
      *(_QWORD *)((char *)v20 + 116) = 0;
      v20[17] = 0;
      v20[18] = 0;
      v20[19] = 0;
      v20 += 20;
    }
    while (v20 != &v19[20 * (int)v17]);
  }
  *(_QWORD *)(a1 + 32) = v19;
  v21 = v116[1];
  if (a8)
  {
    *(_QWORD *)(a1 + 96) = a9;
    if (v21 >= 1)
    {
      v22 = 0;
      v23 = 0;
      do
      {
        v24 = kdu_thread_entity::add_queue((uint64_t)a8, (uint64_t)&v19[v22], a9, (uint64_t)"component processor");
        v19 = *(_QWORD **)(a1 + 32);
        v19[v22 + 2] = v24;
        ++v23;
        v21 = v116[1];
        v22 += 20;
      }
      while (v23 < v116[1]);
    }
  }
  *(_DWORD *)v105 = a4;
  scratch_ints = (int *)kd_multi_transform::get_scratch_ints((kd_multi_transform *)a1, v21);
  kdu_tile::get_mct_block_info(&v117, 0, 0, (unsigned int *)&v116[1], v116, &v115[1], v115, 0, 0, 0, 0, scratch_ints);
  if (v116[1] >= 1)
  {
    v26 = 0;
    v104 = a6 ^ 1;
    v27 = 2 * a7;
    do
    {
      v28 = *(_QWORD *)(a1 + 32);
      v29 = v28 + 160 * v26;
      *(_DWORD *)(v29 + 8) = scratch_ints[v26];
      *(_QWORD *)(*(_QWORD *)(v16 + 8) + 8 * v26) = v29 + 24;
      *(_DWORD *)(v29 + 96) = v26;
      *(_QWORD *)v114 = 0;
      *(_QWORD *)v114 = kdu_tile::access_component(&v117, *(_DWORD *)(v29 + 8));
      reversible = kdu_tile_comp::get_reversible((kdu_tile_comp *)v114);
      v31 = v28 + 160 * v26;
      if (reversible)
      {
        *(_BYTE *)(v31 + 60) = 1;
        if (*(_DWORD *)v105)
          goto LABEL_19;
      }
      else
      {
        *(_BYTE *)(v31 + 61) = 1;
        if (*(_DWORD *)v105)
        {
LABEL_19:
          *(_BYTE *)(v28 + 160 * v26 + 62) = 1;
          goto LABEL_24;
        }
      }
      bit_depth = kdu_tile_comp::get_bit_depth((kdu_tile_comp *)v114, 1);
      v33 = v28 + 160 * v26;
      if (bit_depth > 16)
      {
        v34 = *(unsigned __int8 *)(v33 + 60);
        v35 = (char *)(v33 + 62);
        if (v34)
          v36 = 1;
        else
          v36 = v104;
        *v35 = v36;
      }
      else
      {
        *(_BYTE *)(v33 + 62) = 0;
      }
LABEL_24:
      v37 = v28 + 160 * v26;
      *(_DWORD *)(v37 + 64) = kdu_tile_comp::get_bit_depth((kdu_tile_comp *)v114, 0);
      *(_QWORD *)v113 = 0;
      *(_QWORD *)v113 = kdu_tile_comp::access_resolution((uint64_t **)v114);
      v112 = 0uLL;
      kdu_resolution::get_dims((int32x4_t **)v113, &v112);
      *(_QWORD *)(v37 + 40) = v112.i64[1];
      v38 = (int *)(v37 + 40);
      if (!v112.i32[3] || !v112.i32[2])
      {
        v111 = 0;
        *(_OWORD *)v109 = 0u;
        v110 = 0u;
        kdu_error::kdu_error((kdu_error *)v109, "Kakadu Core Error:\n");
        (*((void (**)(float **, const char *))v109[0] + 2))(v109, "Unexpected kdu_resolution.");
        kdu_error::~kdu_error((kdu_error *)v109);
      }
      if (a8)
      {
        if ((int)kdu_thread_entity::get_num_threads(a8) <= 1 || v116[1] <= 1)
          v40 = 0;
        else
          v40 = a10;
      }
      else
      {
        v40 = 0;
      }
      v41 = v28 + 160 * v26;
      *(_DWORD *)(v41 + 128) = a7;
      v42 = (int *)(v41 + 128);
      *((_BYTE *)v42 - 24) = v40;
      *(v42 - 1) = a7;
      if ((v40 & 1) != 0)
      {
        *v42 = v27;
        v43 = *v38;
        v44 = 2 * a7;
        if (v27 > v43)
        {
          *v42 = v43;
          v45 = (v43 + 1) >> 1;
          v44 = v43;
LABEL_40:
          *(v42 - 1) = v45;
        }
      }
      else
      {
        v45 = *v38;
        v44 = a7;
        if (v45 < a7)
        {
          *v42 = v45;
          v44 = v45;
          goto LABEL_40;
        }
      }
      v46 = operator new[]();
      if (v44)
      {
        v47 = v46;
        do
        {
          *(_DWORD *)v47 = 0;
          *(_WORD *)(v47 + 6) = 0;
          *(_QWORD *)(v47 + 8) = 0;
          v47 += 16;
        }
        while (v47 != v46 + 16 * v44);
      }
      *(_QWORD *)(v28 + 160 * v26++ + 136) = v46;
    }
    while (v26 < v116[1]);
  }
  if (kdu_tile::get_mct_block_info(&v117, 0, 0, (unsigned int *)&v116[1], v116, &v115[1], v115, 0, 0, 0, 0, 0))
  {
    v48 = 0;
    do
    {
      if (*(_DWORD *)v16 != v116[1])
        kd_multi_transform::construct();
      v16 = operator new();
      *(_QWORD *)(v16 + 8) = 0;
      v49 = *(_QWORD *)(a1 + 48);
      *(_QWORD *)(v16 + 16) = 0;
      *(_QWORD *)(v16 + 24) = v49;
      *(_QWORD *)(v49 + 16) = v16;
      *(_QWORD *)(a1 + 48) = v16;
      *(_DWORD *)v16 = v116[0];
      *(_QWORD *)(v16 + 8) = operator new[]();
      if (v116[0] >= 1)
      {
        v50 = 0;
        v51 = 8 * v116[0];
        do
        {
          *(_QWORD *)(*(_QWORD *)(v16 + 8) + v50) = 0;
          v50 += 8;
        }
        while (v51 != v50);
      }
      v52 = 0;
      do
      {
        *(_WORD *)v108 = 0;
        v107 = 0;
        v112.i32[0] = 0;
        v114[0] = 0;
        v113[0] = 0;
        v106 = 0;
        v109[0] = 0;
        if (kdu_tile::get_mct_matrix_info((kdu_tile *)&v117, v48, v52, 0))
        {
          v53 = operator new();
          *(_QWORD *)(v53 + 20) = 0;
          *(_QWORD *)(v53 + 12) = 0;
          *(_OWORD *)(v53 + 32) = 0u;
          *(_OWORD *)(v53 + 48) = 0u;
          *(_QWORD *)v53 = &off_1E1BB22A0;
          *(_BYTE *)(v53 + 8) = 0;
          *(_QWORD *)(v53 + 104) = 0;
          v54 = &off_1E1BB22A0;
          *(_OWORD *)(v53 + 64) = 0u;
          *(_OWORD *)(v53 + 80) = 0u;
        }
        else if (kdu_tile::get_mct_rxform_info((kdu_tile *)&v117, v48, v52, 0, 0))
        {
          v53 = operator new();
          *(_QWORD *)(v53 + 20) = 0;
          *(_QWORD *)(v53 + 12) = 0;
          *(_OWORD *)(v53 + 32) = 0u;
          *(_OWORD *)(v53 + 48) = 0u;
          *(_QWORD *)v53 = &off_1E1BB22F0;
          *(_BYTE *)(v53 + 8) = 0;
          v54 = &off_1E1BB22F0;
          *(_QWORD *)(v53 + 64) = 0;
          *(_QWORD *)(v53 + 72) = 0;
        }
        else if (kdu_tile::get_mct_dependency_info((kdu_tile *)&v117, v48, v52, &v108[1], 0, 0, 0, 0, 0))
        {
          v53 = operator new();
          v55 = v108[1];
          *(_QWORD *)(v53 + 20) = 0;
          *(_QWORD *)(v53 + 12) = 0;
          *(_OWORD *)(v53 + 32) = 0u;
          *(_OWORD *)(v53 + 48) = 0u;
          *(_QWORD *)v53 = &off_1E1BB25B0;
          *(_BYTE *)(v53 + 8) = 0;
          *(_BYTE *)(v53 + 64) = v55;
          *(_QWORD *)(v53 + 120) = 0;
          *(_OWORD *)(v53 + 68) = 0u;
          *(_OWORD *)(v53 + 84) = 0u;
          v54 = &off_1E1BB25B0;
          *(_OWORD *)(v53 + 100) = 0u;
        }
        else if (kdu_tile::get_mct_dwt_info((kdu_tile *)&v117, v48, v52, &v108[1], v112.i32, v114, v113, &v106, v108, &v107, (const float **)v109, 0, 0))
        {
          v53 = operator new();
          *(_QWORD *)(v53 + 20) = 0;
          *(_QWORD *)(v53 + 12) = 0;
          *(_OWORD *)(v53 + 32) = 0u;
          *(_OWORD *)(v53 + 48) = 0u;
          *(_QWORD *)v53 = &off_1E1BB18F0;
          *(_BYTE *)(v53 + 8) = 0;
          *(_DWORD *)(v53 + 64) = 0;
          *(_QWORD *)(v53 + 72) = 0;
          *(_QWORD *)(v53 + 128) = 0;
          *(_QWORD *)(v53 + 92) = 0;
          *(_QWORD *)(v53 + 84) = 0;
          *(_QWORD *)(v53 + 104) = 0;
          *(_QWORD *)(v53 + 112) = 0;
          v54 = &off_1E1BB18F0;
          *(_DWORD *)(v53 + 120) = 0;
        }
        else
        {
          v53 = operator new();
          *(_QWORD *)(v53 + 20) = 0;
          *(_QWORD *)(v53 + 12) = 0;
          *(_OWORD *)(v53 + 32) = 0u;
          *(_OWORD *)(v53 + 48) = 0u;
          v54 = &off_1E1BB1D68;
          *(_QWORD *)v53 = &off_1E1BB1D68;
          *(_BYTE *)(v53 + 8) = 1;
        }
        v56 = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(v53 + 56) = v56;
        if (v56)
          v57 = (uint64_t *)(v56 + 48);
        else
          v57 = (uint64_t *)(a1 + 16);
        *v57 = v53;
        *(_QWORD *)(a1 + 24) = v53;
        ((void (*)(uint64_t, int, int, uint64_t *, int, int, uint64_t, uint64_t, kd_multi_transform *))v54[2])(v53, v48, v52++, v117, v115[1], v115[0], *(_QWORD *)(v16 + 24), v16, (kd_multi_transform *)a1);
      }
      while ((kdu_tile::get_mct_block_info(&v117, v48, v52, (unsigned int *)&v116[1], v116, &v115[1], v115, 0, 0, 0, 0, 0) & 1) != 0);
      ++v48;
    }
    while ((kdu_tile::get_mct_block_info(&v117, v48, 0, (unsigned int *)&v116[1], v116, &v115[1], v115, 0, 0, 0, 0, 0) & 1) != 0);
  }
  v58 = *(int **)(a1 + 48);
  v59 = *v58;
  if (*v58 < 1)
  {
    v60 = 0;
    v65 = 1;
    v63 = *(_DWORD *)v105;
  }
  else
  {
    v60 = 0;
    v61 = (_QWORD *)*((_QWORD *)v58 + 1);
    v62 = *v58;
    v63 = *(_DWORD *)v105;
    do
    {
      if (!*v61++)
        ++v60;
      --v62;
    }
    while (v62);
    v65 = v60 == 0;
    if (v60)
    {
      v66 = operator new[]();
      v67 = v66;
      do
      {
        *(_DWORD *)v67 = 0;
        *(_QWORD *)(v67 + 14) = 0;
        *(_QWORD *)(v67 + 6) = 0;
        *(_WORD *)(v67 + 22) = 0;
        *(_DWORD *)(v67 + 24) = -1;
        *(_QWORD *)(v67 + 28) = 0;
        *(_QWORD *)(v67 + 44) = 0;
        *(_QWORD *)(v67 + 36) = 0;
        *(_QWORD *)(v67 + 56) = 0;
        *(_QWORD *)(v67 + 64) = 0;
        *(_DWORD *)(v67 + 72) = -1;
        v67 += 80;
      }
      while (v67 != v66 + 80 * v60);
      *(_QWORD *)(a1 + 56) = v66;
      v58 = *(int **)(a1 + 48);
      v59 = *v58;
    }
    if (v59 >= 1)
    {
      v68 = 0;
      v69 = 0;
      do
      {
        v70 = *((_QWORD *)v58 + 1);
        v71 = *(_QWORD *)(v70 + 8 * v68);
        if (!v71)
        {
          v71 = *(_QWORD *)(a1 + 56) + 80 * v69;
          *(_QWORD *)(v70 + 8 * v68) = v71;
          ++v69;
          *(_BYTE *)(v71 + 38) = v105[0];
          *(_BYTE *)(v71 + 37) = 1;
          *(_BYTE *)(v71 + 39) = 1;
        }
        ++*(_DWORD *)(v71 + 28);
        v109[0] = 0;
        v109[1] = 0;
        tile_idx = kdu_tile::get_tile_idx((unsigned __int8 ***)&v117);
        kdu_codestream::get_tile_dims(v118, tile_idx, v68, (int32x4_t *)v109, 1);
        *(float **)(v71 + 16) = v109[1];
        *(_DWORD *)(v71 + 40) = kdu_codestream::get_bit_depth((kdu_codestream *)v118, v68++, 1);
        v58 = *(int **)(a1 + 48);
      }
      while (v68 < *v58);
    }
  }
  while ((kd_multi_transform::propagate_knowledge((kd_multi_transform *)a1, v63) & 1) != 0)
    ;
  for (i = *(_QWORD *)(a1 + 16); i; i = *(_QWORD *)(i + 48))
  {
    v74 = *(unsigned int *)(i + 12);
    if ((int)v74 >= 1)
    {
      v75 = (float *)(*(_QWORD *)(i + 16) + 48);
      do
      {
        v76 = *((_DWORD *)v75 - 2);
        if (v76 && *v75 != 0.0)
          *v75 = (float)(1.0 / (float)(1 << v76)) * *v75;
        v75 += 20;
        --v74;
      }
      while (v74);
    }
    (*(void (**)(uint64_t))(*(_QWORD *)i + 24))(i);
  }
  do
    result = kd_multi_transform::propagate_knowledge((kd_multi_transform *)a1, 0);
  while ((result & 1) != 0);
  v78 = *(int **)(a1 + 48);
  LODWORD(v79) = *v78;
  if (*v78 >= 1)
  {
    v80 = 0;
    do
    {
      v81 = *(_QWORD *)(*((_QWORD *)v78 + 1) + 8 * v80);
      result = kdu_codestream::get_signed((kdu_codestream *)v118, v80, 1);
      if ((result & 1) == 0)
      {
        *(_DWORD *)(v81 + 44) -= 1 << *(_DWORD *)(v81 + 40) >> 1;
        *(float *)(v81 + 48) = *(float *)(v81 + 48) + -0.5;
      }
      ++v80;
      v78 = *(int **)(a1 + 48);
      v79 = *v78;
    }
    while (v80 < v79);
  }
  v82 = (int)v79 < 1 || v65;
  if ((v82 & 1) == 0)
  {
    v83 = 0;
    do
    {
      v84 = *((_QWORD *)v78 + 1);
      v85 = *(_QWORD *)(v84 + 8 * v83);
      v86 = *(_QWORD *)(a1 + 56);
      if (v85 > v86 && v85 < v86 + 80 * v60)
      {
        if (!*(_BYTE *)(v85 + 39) || *(_BYTE *)(v85 + 36))
          kd_multi_transform::construct();
        while (*(_DWORD *)(v86 + 20) != *(_DWORD *)(v85 + 20) || *(float *)(v86 + 48) != *(float *)(v85 + 48))
        {
          v86 += 80;
          if (v86 >= v85)
            goto LABEL_113;
        }
        *(_QWORD *)(v84 + 8 * v83) = v86;
        v78 = *(int **)(a1 + 48);
        LODWORD(v79) = *v78;
      }
LABEL_113:
      ++v83;
    }
    while (v83 < (int)v79);
  }
  for (j = *(_QWORD *)(a1 + 16); j; j = *(_QWORD *)(j + 48))
  {
    v89 = *(unsigned int *)(j + 24);
    if ((int)v89 >= 1)
    {
      for (k = 0; k != v89; ++k)
      {
        while (1)
        {
          v91 = *(_QWORD *)(j + 32) + 8 * k;
          if (!*(_QWORD *)v91)
            break;
          v92 = *(_QWORD *)(*(_QWORD *)v91 + 56);
          if (!v92)
            break;
          *(_QWORD *)v91 = v92;
        }
      }
    }
    if (*(_BYTE *)(j + 8))
    {
      v93 = *(unsigned int *)(j + 12);
      if ((int)v93 >= 1)
      {
        v94 = 0;
        v95 = (_QWORD *)(*(_QWORD *)(j + 16) + 56);
        do
        {
          if (!*((_BYTE *)v95 - 17))
          {
            if (v94 >= (int)v89 || (v96 = *(_QWORD *)(*(_QWORD *)(j + 32) + 8 * v94)) == 0)
              kd_multi_transform::construct();
            if (*((_BYTE *)v95 - 20))
              v97 = *((_DWORD *)v95 - 3) == 0;
            else
              v97 = *((float *)v95 - 2) == 0.0;
            v98 = !v97;
            if (*(_QWORD *)(v96 + 56))
              kd_multi_transform::construct();
            if (*((unsigned __int8 *)v95 - 20) != *(unsigned __int8 *)(v96 + 36))
              kd_multi_transform::construct();
            if ((!v98 || *(int *)(v96 + 28) <= 1)
              && (*((_BYTE *)v95 - 20) || *(_DWORD *)(v96 + 40) == *((_DWORD *)v95 - 4)))
            {
              *v95 = v96;
              *(_DWORD *)(v96 + 44) += *((_DWORD *)v95 - 3);
              *(float *)(v96 + 48) = *((float *)v95 - 2) + *(float *)(v96 + 48);
              *(_DWORD *)(v96 + 28) = *((_DWORD *)v95 - 7) + *(_DWORD *)(v96 + 28) - 1;
            }
          }
          v95 += 10;
          ++v94;
        }
        while (v93 != v94);
      }
    }
  }
  v99 = *(unsigned int **)(a1 + 40);
  while (1)
  {
    v99 = (unsigned int *)*((_QWORD *)v99 + 2);
    if (!v99)
      break;
    v100 = *v99;
    if ((int)v100 >= 1)
    {
      for (m = 0; m != v100; ++m)
      {
        while (1)
        {
          v102 = *((_QWORD *)v99 + 1) + 8 * m;
          if (!*(_QWORD *)v102)
            break;
          v103 = *(_QWORD *)(*(_QWORD *)v102 + 56);
          if (!v103)
            break;
          *(_QWORD *)v102 = v103;
        }
      }
    }
  }
  return result;
}

void sub_187F6D9F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F6D9FC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_multi_transform::get_scratch_ints(kd_multi_transform *this, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t result;

  v3 = *((_DWORD *)this + 26);
  if (v3 >= a2)
    return *((_QWORD *)this + 14);
  *((_DWORD *)this + 26) = v3 + a2;
  v4 = *((_QWORD *)this + 14);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1000C8052888210);
  result = operator new[]();
  *((_QWORD *)this + 14) = result;
  return result;
}

uint64_t kd_multi_transform::propagate_knowledge(kd_multi_transform *this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  char v5;
  char v6;
  uint64_t *v7;
  char v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  char v12;
  char v13;
  char v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  char v18;
  int v19;
  uint64_t v20;
  char v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  _DWORD *v31;
  int v32;
  int v33;
  _QWORD *v34;
  int v35;
  int v36;
  char v37;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  BOOL v45;
  int v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  if (*((_BYTE *)this + 8))
  {
    v3 = *((_QWORD *)this + 5);
    if (*(int *)v3 <= 2)
      kd_multi_transform::propagate_knowledge();
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = *(uint64_t **)(v3 + 8);
    v8 = a2;
    do
    {
      v9 = (_BYTE *)v7[v4];
      v6 |= v9[36] != 0;
      v5 |= v9[37] != 0;
      v8 |= v9[38] != 0;
      ++v4;
    }
    while (v4 != 3);
    v10 = 0;
    v11 = 0;
    v12 = v6 & 1;
    v13 = v5 & 1;
    v14 = v8 & 1;
    v15 = *v7;
    v16 = *(_DWORD *)(*v7 + 20);
    do
    {
      v17 = v7[v10];
      *(_BYTE *)(v17 + 36) = v12;
      *(_BYTE *)(v17 + 37) = v13;
      *(_BYTE *)(v17 + 38) = v14;
      if (*(_DWORD *)(v17 + 20) != v16 || *(_DWORD *)(v17 + 16) != *(_DWORD *)(v15 + 16))
        v11 = 1;
      ++v10;
    }
    while (v10 != 3);
    v18 = v11;
  }
  else
  {
    v18 = 0;
  }
  LOBYTE(v19) = 0;
  v20 = *((_QWORD *)this + 2);
  if (!v20)
  {
    v21 = 0;
    if ((v18 & 1) == 0)
      goto LABEL_101;
LABEL_104:
    v62 = 0;
    v60 = 0u;
    v61 = 0u;
    kdu_error::kdu_error((kdu_error *)&v60, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v60 + 16))(&v60, "Cannot implement multi-component transform.  It seems that image components which must be processed by a common transform block (or decorrelating colour transform) have incompatible dimensions.  This error may also be detected if the sub-sampling factors associated with an MCT output image component vary from tile to tile or if relative component size change from resolution level to resolution level (due to incompatible Part-2 downsampling factor style usage).  While these latter conditions might not be strictly illegal, they are clearly foolish.");
    kdu_error::~kdu_error((kdu_error *)&v60);
  }
  v21 = 0;
  if ((v18 & 1) == 0)
  {
    v21 = 0;
    v19 = 0;
    do
    {
      v22 = *(_DWORD *)(v20 + 24);
      if (*(_BYTE *)(v20 + 8))
      {
        v23 = *(_DWORD *)(v20 + 12);
        if (v22 > v23)
          kd_multi_transform::propagate_knowledge();
        if (v23 >= 1)
        {
          v24 = 0;
          v18 = 0;
          v25 = 40;
          while (1)
          {
            v26 = *(_QWORD *)(v20 + 16);
            if (a2)
              *(_BYTE *)(v26 + v25 - 2) = 1;
            v27 = v26 + v25;
            if (*(_BYTE *)(v26 + v25 - 1))
              goto LABEL_44;
            v28 = *(_QWORD *)(*(_QWORD *)(v20 + 32) + 8 * v24);
            if (*(unsigned __int8 *)(v28 + 38) != *(unsigned __int8 *)(v27 - 2))
            {
              v19 = 1;
              *(_BYTE *)(v28 + 38) = 1;
              *(_BYTE *)(v27 - 2) = 1;
            }
            v29 = v26 + v25;
            if (*(unsigned __int8 *)(v28 + 37) != *(unsigned __int8 *)(v26 + v25 - 3))
            {
              v19 = 1;
              *(_BYTE *)(v28 + 37) = 1;
              *(_BYTE *)(v29 - 3) = 1;
            }
            if (*(unsigned __int8 *)(v28 + 36) != *(unsigned __int8 *)(v29 - 4))
            {
              v19 = 1;
              *(_BYTE *)(v28 + 36) = 1;
              *(_BYTE *)(v29 - 4) = 1;
            }
            v30 = (_DWORD *)(v28 + 16);
            v31 = (_DWORD *)(v26 + v25 - 24);
            v32 = *(_DWORD *)(v28 + 20);
            v33 = *(_DWORD *)(v26 + v25 - 20);
            if (v32 != v33 || *v30 != *v31)
            {
              if (v32 || *v30)
              {
                if (v33 || (v34 = (_QWORD *)(v28 + 16), *v31))
                {
                  v19 = 1;
                  v18 = 1;
                  goto LABEL_37;
                }
              }
              else
              {
                v34 = (_QWORD *)(v26 + v25 - 24);
                v31 = (_DWORD *)(v28 + 16);
              }
              *(_QWORD *)v31 = *v34;
              v19 = 1;
            }
LABEL_37:
            v35 = *(_DWORD *)(v28 + 40);
            v36 = *(_DWORD *)(v26 + v25);
            if (v35 != v36)
            {
              if (!v35)
              {
                *(_DWORD *)(v28 + 40) = v36;
LABEL_43:
                v19 = 1;
                goto LABEL_44;
              }
              if (!v36)
              {
                *(_DWORD *)(v26 + v25) = v35;
                goto LABEL_43;
              }
              v19 = 1;
              v21 = 1;
            }
LABEL_44:
            ++v24;
            v25 += 80;
            if (v24 >= *(int *)(v20 + 12))
              goto LABEL_98;
          }
        }
        v18 = 0;
      }
      else
      {
        if (v22 < 1)
        {
          v40 = 0;
          v39 = 0;
          v38 = 0;
          v37 = 0;
          v43 = a2;
        }
        else
        {
          v37 = 0;
          v38 = 0;
          v39 = 0;
          v40 = 0;
          v41 = *(uint64_t **)(v20 + 32);
          v42 = *(unsigned int *)(v20 + 24);
          v43 = a2;
          do
          {
            v44 = *v41;
            if (*v41)
            {
              v45 = *(_DWORD *)(v44 + 20) != v40 || *(_DWORD *)(v44 + 16) != v39;
              if (!(v38 & 1 | !v45))
              {
                v39 = *(_QWORD *)(v44 + 16);
                v40 = HIDWORD(*(_QWORD *)(v44 + 16));
                v38 = 1;
              }
              v43 |= *(_BYTE *)(v44 + 38) != 0;
              v37 |= *(_DWORD *)(v44 + 40) == 0;
            }
            ++v41;
            --v42;
          }
          while (v42);
        }
        v46 = *(_DWORD *)(v20 + 12);
        if (v46 < 1)
        {
          v47 = 0;
        }
        else
        {
          v47 = 0;
          v48 = *(_QWORD *)(v20 + 16) + 20;
          v49 = *(unsigned int *)(v20 + 12);
          do
          {
            v50 = *(_DWORD *)v48 != v40 || *(_DWORD *)(v48 - 4) != v39;
            if (!(v38 & 1 | !v50))
            {
              v39 = *(_QWORD *)(v48 - 4);
              v40 = HIDWORD(*(_QWORD *)(v48 - 4));
              v38 = 1;
            }
            v43 |= *(_BYTE *)(v48 + 18) != 0;
            v51 = *(_DWORD *)(v48 + 20);
            v48 += 80;
            v47 |= v51 == 0;
            --v49;
          }
          while (v49);
        }
        v52 = v39 | (v40 << 32);
        if (v22 < 1)
        {
          v18 = 0;
        }
        else
        {
          v53 = 0;
          v18 = 0;
          do
          {
            v54 = *(_QWORD *)(*(_QWORD *)(v20 + 32) + 8 * v53);
            if (v54)
            {
              if (*(_BYTE *)(v54 + 38) != (v43 & 1))
              {
                v19 = 1;
                *(_BYTE *)(v54 + 38) = 1;
              }
              if (*(_DWORD *)(v54 + 20) != v40 || *(_DWORD *)(v54 + 16) != v39)
              {
                if ((v38 & 1) == 0)
                  kd_multi_transform::propagate_knowledge();
                if (*(_DWORD *)(v54 + 20) || *(_DWORD *)(v54 + 16))
                {
                  v19 = 1;
                  v18 = 1;
                }
                else
                {
                  *(_QWORD *)(v54 + 16) = v52;
                  v22 = *(_DWORD *)(v20 + 24);
                  v19 = 1;
                }
              }
            }
            ++v53;
          }
          while (v53 < v22);
          v46 = *(_DWORD *)(v20 + 12);
        }
        if (v46 >= 1)
        {
          v55 = 0;
          v56 = 0;
          v57 = v43 & 1;
          do
          {
            v58 = *(_QWORD *)(v20 + 16) + v55;
            if (*(unsigned __int8 *)(v58 + 38) != v57)
            {
              v19 = 1;
              *(_BYTE *)(v58 + 38) = 1;
            }
            if (*(_DWORD *)(v58 + 20) != v40 || *(_DWORD *)(v58 + 16) != v39)
            {
              if ((v38 & 1) == 0)
                kd_multi_transform::propagate_knowledge();
              if (*(_DWORD *)(v58 + 20) || *(_DWORD *)(v58 + 16))
              {
                v19 = 1;
                v18 = 1;
              }
              else
              {
                *(_QWORD *)(v58 + 16) = v52;
                v46 = *(_DWORD *)(v20 + 12);
                v19 = 1;
              }
            }
            ++v56;
            v55 += 80;
          }
          while (v56 < v46);
        }
        v19 |= (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v20 + 32))(v20, v37 & 1, v47 & 1);
      }
LABEL_98:
      v20 = *(_QWORD *)(v20 + 48);
    }
    while (v20 && (v18 & 1) == 0);
  }
  if ((v18 & 1) != 0)
    goto LABEL_104;
LABEL_101:
  if ((v21 & 1) != 0)
  {
    v62 = 0;
    v60 = 0u;
    v61 = 0u;
    kdu_error::kdu_error((kdu_error *)&v60, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v60 + 16))(&v60, "Part-2 codestream declares a codestream component to have a different bit-depth (Sprecision) to the output component (Mprecision) with which it is directly associated.  While this is allowed, it makes very little sense, and Kakadu will not perform the required multiple scaling for irreversibly transformed components.");
    kdu_error::~kdu_error((kdu_error *)&v60);
  }
  return v19 & 1;
}

void sub_187F6E020(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F6E02C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kd_multi_transform::create_resources(kd_multi_transform *this)
{
  kd_multi_transform *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  kdu_sample_allocator *v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  int *v16;
  _BYTE *v17;
  uint64_t i;
  int v19;
  uint64_t v20;
  uint64_t j;
  uint64_t v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  BOOL v30;
  int v31;
  uint64_t k;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t m;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  BOOL v49;
  _OWORD v50[2];
  uint64_t v51;

  v1 = this;
  v2 = *((_QWORD *)this + 5);
  v3 = *(_DWORD *)v2;
  if (*(int *)v2 < 1)
  {
    v6 = 1;
  }
  else
  {
    v4 = 0;
    v5 = (kd_multi_transform *)((char *)this + 64);
    v6 = 1;
    do
    {
      v7 = *((_QWORD *)v1 + 4);
      if (*(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * v4) != v7 + 160 * v4 + 24)
        kd_multi_transform::create_resources();
      v8 = v7 + 160 * v4;
      v10 = *(_DWORD *)(v8 + 128);
      v9 = (int *)(v8 + 128);
      v11 = *((unsigned __int8 *)v9 - 68) == (*((unsigned __int8 *)v9 - 67) ^ 1);
      if (v10 >= 1)
      {
        v49 = *((unsigned __int8 *)v9 - 68) == (*((unsigned __int8 *)v9 - 67) ^ 1);
        v12 = 0;
        v13 = 0;
        v14 = v7 + 160 * v4;
        v15 = (_QWORD *)(v14 + 136);
        v16 = (int *)(v14 + 44);
        v17 = (_BYTE *)(v14 + 62);
        do
        {
          kdu_line_buf::pre_create((kdu_line_buf *)(*v15 + v12), v5, *v16, *((_BYTE *)v9 - 68), *v17 == 0, 2u, 2);
          ++v13;
          v12 += 16;
        }
        while (v13 < *v9);
        v1 = this;
        v2 = *((_QWORD *)this + 5);
        v3 = *(_DWORD *)v2;
        v11 = v49;
      }
      v6 &= v11;
      ++v4;
    }
    while (v4 < v3);
  }
  for (i = *((_QWORD *)v1 + 2); i; i = *(_QWORD *)(i + 48))
  {
    v19 = *(_DWORD *)(i + 12);
    if (v19 >= 1)
    {
      v20 = 0;
      for (j = 0; j < v19; ++j)
      {
        v22 = *(_QWORD *)(i + 16) + v20;
        v23 = *(unsigned __int8 *)(v22 + 36);
        v24 = v23 == (*(unsigned __int8 *)(v22 + 37) ^ 1);
        if (!*(_QWORD *)(v22 + 56))
        {
          kdu_line_buf::pre_create((kdu_line_buf *)v22, (kd_multi_transform *)((char *)v1 + 64), *(_DWORD *)(v22 + 20), v23 != 0, *(_BYTE *)(v22 + 38) == 0, 2u, 2);
          v19 = *(_DWORD *)(i + 12);
        }
        v6 &= v24;
        v20 += 80;
      }
    }
  }
  v25 = *((_QWORD *)v1 + 6);
  v26 = *(_DWORD *)v25;
  if (*(int *)v25 >= 1)
  {
    v27 = 0;
    do
    {
      v28 = *(_QWORD *)(*(_QWORD *)(v25 + 8) + 8 * v27);
      v29 = *(unsigned __int8 *)(v28 + 36);
      v30 = v29 == (*(unsigned __int8 *)(v28 + 37) ^ 1);
      if (!*(_QWORD *)(v28 + 56) && !*(_QWORD *)(v28 + 64) && (*(_DWORD *)(v28 + 72) & 0x80000000) != 0)
      {
        kdu_line_buf::pre_create((kdu_line_buf *)v28, (kd_multi_transform *)((char *)v1 + 64), *(_DWORD *)(v28 + 20), v29 != 0, *(_BYTE *)(v28 + 38) == 0, 2u, 2);
        v25 = *((_QWORD *)v1 + 6);
        v26 = *(_DWORD *)v25;
      }
      v6 &= v30;
      ++v27;
    }
    while (v27 < v26);
  }
  if ((v6 & 1) == 0)
  {
    v51 = 0;
    memset(v50, 0, sizeof(v50));
    kdu_error::kdu_error((kdu_error *)v50, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v50[0] + 16))(v50, "Cannot implement multi-component transform.  It seems that one or more transform steps require image samples to be treated as reversible, where other steps require the same image samples to be treated as irreversible.  This is illegal in Part-1 of the JPEG2000 standard.  Although Part-2 is not clear on the matter, Kakadu's implementation insists only that irreversibly compressed samples not be subjected to reversible multi-component transform processing during decompression -- this is eminently reasonable, since exact reversible processing of data which is not already exactly defined, makes no sense.  The reverse case, in which reversibly compressed data is processed using an irreversible multi-component transform, can make sense, particularly where there are multiple ways to render the same original reversibly compressed codestream components to MCT outputs.");
    kdu_error::~kdu_error((kdu_error *)v50);
  }
  kdu_sample_allocator::finalize((uint64_t)v1 + 64);
  v31 = **((_DWORD **)v1 + 5);
  if (v31 >= 1)
  {
    for (k = 0; k < v31; ++k)
    {
      v33 = *((_QWORD *)v1 + 4);
      v34 = v33 + 160 * k;
      v36 = *(_DWORD *)(v34 + 128);
      v35 = (int *)(v34 + 128);
      if (v36 >= 1)
      {
        v37 = 0;
        v38 = 0;
        v39 = (_QWORD *)(v33 + 160 * k + 136);
        do
        {
          kdu_line_buf::create(*v39 + v37);
          ++v38;
          v37 += 16;
        }
        while (v38 < *v35);
        v31 = **((_DWORD **)v1 + 5);
      }
    }
  }
  for (m = *((_QWORD *)v1 + 2); m; m = *(_QWORD *)(m + 48))
  {
    if (*(int *)(m + 12) >= 1)
    {
      v41 = 0;
      v42 = 0;
      do
      {
        v43 = *(_QWORD *)(m + 16);
        if (!*(_QWORD *)(v43 + v41 + 56))
        {
          kdu_line_buf::create(v43 + v41);
          if (*(_BYTE *)(v43 + v41 + 39))
            kd_multi_line::reset((kd_multi_line *)(v43 + v41), *(_DWORD *)(v43 + v41 + 44), *(float *)(v43 + v41 + 48));
        }
        ++v42;
        v41 += 80;
      }
      while (v42 < *(int *)(m + 12));
    }
  }
  v44 = *((_QWORD *)v1 + 6);
  v45 = *(_DWORD *)v44;
  if (*(int *)v44 >= 1)
  {
    v46 = 0;
    do
    {
      v47 = *(_QWORD *)(*(_QWORD *)(v44 + 8) + 8 * v46);
      if (!*(_QWORD *)(v47 + 56) && !*(_QWORD *)(v47 + 64) && (*(_DWORD *)(v47 + 72) & 0x80000000) != 0)
      {
        kdu_line_buf::create(*(_QWORD *)(*(_QWORD *)(v44 + 8) + 8 * v46));
        if (!*(_BYTE *)(v47 + 39))
          kd_multi_transform::create_resources();
        kd_multi_line::reset((kd_multi_line *)v47, *(_DWORD *)(v47 + 44), *(float *)(v47 + 48));
        v44 = *((_QWORD *)v1 + 6);
        v45 = *(_DWORD *)v44;
      }
      ++v46;
    }
    while (v46 < v45);
  }
}

void sub_187F6E428(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F6E434()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_multi_transform::get_scratch_floats(kd_multi_transform *this, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t result;

  v3 = *((_DWORD *)this + 30);
  if (v3 >= a2)
    return *((_QWORD *)this + 16);
  *((_DWORD *)this + 30) = v3 + a2;
  v4 = *((_QWORD *)this + 16);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1000C8052888210);
  result = operator new[]();
  *((_QWORD *)this + 16) = result;
  return result;
}

uint64_t kdu_multi_synthesis::create(uint64_t *a1, uint64_t a2, uint64_t *a3, int a4, char a5, char a6, int a7, kdu_thread_entity *a8, char *a9, char a10)
{
  uint64_t v18;

  v18 = operator new();
  *(_QWORD *)(v18 + 80) = 0;
  *(_QWORD *)(v18 + 88) = 0;
  *(_DWORD *)(v18 + 76) = 0;
  *(_BYTE *)(v18 + 72) = 1;
  *(_BYTE *)(v18 + 16) = 0;
  *(_DWORD *)(v18 + 128) = 0;
  *(_QWORD *)(v18 + 120) = 0;
  *(_OWORD *)(v18 + 24) = 0u;
  *(_OWORD *)(v18 + 40) = 0u;
  *(_OWORD *)(v18 + 56) = 0u;
  *(_QWORD *)(v18 + 96) = 0;
  *(_QWORD *)(v18 + 104) = 0;
  *(_DWORD *)(v18 + 112) = 0;
  *(_QWORD *)v18 = &off_1E1BB1940;
  *(_QWORD *)(v18 + 8) = &unk_1E1BB1988;
  *(_QWORD *)(v18 + 136) = 0;
  *(_QWORD *)(v18 + 144) = 0;
  *a1 = v18;
  return kd_multi_synthesis::create(v18, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t kd_multi_synthesis::create(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, char a5, char a6, int a7, kdu_thread_entity *a8, char *a9, char a10)
{
  kd_multi_transform *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  _BOOL8 v19;
  _BYTE *v20;
  uint64_t v21;
  _BOOL8 v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  int v31;
  _BYTE v33[8];
  _BYTE v34[8];
  uint64_t v35;
  uint64_t *v36;
  uint64_t *v37;

  v37 = a3;
  v12 = (kd_multi_transform *)(a1 + 8);
  kd_multi_transform::construct(a1 + 8, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  if (**(int **)(a1 + 48) >= 1)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = *(_QWORD *)(a1 + 40);
      if (a8)
        v16 = *(_QWORD *)(v15 + v13 + 16);
      else
        v16 = 0;
      v36 = 0;
      v17 = v15 + v13;
      v18 = (uint64_t *)kdu_tile::access_component(&v37, *(_DWORD *)(v15 + v13 + 8));
      v35 = 0;
      v36 = v18;
      v35 = kdu_tile_comp::access_resolution(&v36);
      if (kdu_resolution::which((kdu_resolution *)&v35))
      {
        v19 = *(_BYTE *)(v17 + 62) == 0;
        v20 = v33;
        kdu_synthesis::kdu_synthesis(v33, v35, a1 + 72, v19, a8, v16, 1.0);
      }
      else
      {
        v21 = kdu_resolution::access_subband((kdu_resolution *)&v35, 0);
        v22 = *(_BYTE *)(v17 + 62) == 0;
        v20 = v34;
        kdu_decoder::kdu_decoder(v34, v21, a1 + 72, v22, 0, a8, v16, 1.0);
      }
      *(_QWORD *)(v15 + v13 + 144) = *(_QWORD *)v20;
      ++v14;
      v13 += 160;
    }
    while (v14 < **(int **)(a1 + 48));
  }
  kd_multi_transform::create_resources(v12);
  v23 = operator new[]();
  *(_QWORD *)(a1 + 144) = v23;
  v24 = *(int **)(a1 + 56);
  if (*v24 >= 1)
  {
    v25 = 0;
    do
      *(_DWORD *)(v23 + 4 * v25++) = 0;
    while (v25 < *v24);
  }
  v26 = *(int *)(a1 + 84);
  if (**(int **)(a1 + 48) >= 1)
  {
    v27 = 0;
    v28 = 0;
    do
    {
      v29 = *(_QWORD *)(a1 + 40);
      v30 = (_DWORD *)(v29 + v27);
      (*(void (**)(_QWORD, kdu_thread_entity *))(**(_QWORD **)(v29 + v27 + 144) + 16))(*(_QWORD *)(v29 + v27 + 144), a8);
      if (*(_BYTE *)(v29 + v27 + 104))
      {
        v31 = v30[31];
        v30[29] = 0;
        v30[30] = v31;
        if (v31 > v30[10])
          kd_multi_synthesis::create();
        if (v31 >= 1)
          kdu_thread_entity::add_jobs((uint64_t)a8, *(kdu_thread_queue **)(v29 + v27 + 16), 1, 0);
      }
      ++v28;
      v27 += 160;
    }
    while (v28 < **(int **)(a1 + 48));
  }
  return v26;
}

void kd_multi_synthesis::~kd_multi_synthesis(kd_multi_synthesis *this)
{
  kd_multi_transform *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BB1940;
  *((_QWORD *)this + 1) = &unk_1E1BB1988;
  v2 = (kd_multi_synthesis *)((char *)this + 8);
  v3 = *((_QWORD *)this + 18);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8052888210);
  kd_multi_transform::~kd_multi_transform(v2);
  *(_QWORD *)this = off_1E1BB24F8;
}

{
  kd_multi_synthesis::~kd_multi_synthesis(this);
  JUMPOUT(0x18D761C30);
}

void `non-virtual thunk to'kd_multi_synthesis::~kd_multi_synthesis(kd_multi_synthesis *this)
{
  kd_multi_synthesis::~kd_multi_synthesis((kd_multi_synthesis *)((char *)this - 8));
}

{
  kd_multi_synthesis::~kd_multi_synthesis((kd_multi_synthesis *)((char *)this - 8));
  JUMPOUT(0x18D761C30);
}

BOOL kd_multi_synthesis::terminate_queues(_BOOL8 result, kdu_thread_entity *this)
{
  kdu_thread_queue *v2;

  if (this)
  {
    v2 = *(kdu_thread_queue **)(result + 104);
    if (!v2 || !*(_QWORD *)(*(_QWORD *)(result + 40) + 16))
      kd_multi_synthesis::terminate_queues();
    return kdu_thread_entity::terminate(this, v2, 1, 0);
  }
  return result;
}

uint64_t kd_multi_synthesis::get_size(kd_multi_synthesis *this, unsigned int a2)
{
  uint64_t v2;

  if ((a2 & 0x80000000) != 0 || (v2 = *((_QWORD *)this + 7), *(_DWORD *)v2 <= (signed int)a2))
    kd_multi_synthesis::get_size();
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * a2) + 16);
}

uint64_t kd_multi_synthesis::get_line(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t result;

  if ((a2 & 0x80000000) != 0 || (v5 = *(_QWORD *)(a1 + 56), *(_DWORD *)v5 <= (signed int)a2))
    kd_multi_synthesis::get_line();
  result = kd_multi_synthesis::get_line(a1, *(_QWORD *)(*(_QWORD *)(v5 + 8) + 8 * a2), *(unsigned int *)(*(_QWORD *)(a1 + 144) + 4 * a2), a3);
  if (result)
    ++*(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * a2);
  return result;
}

uint64_t kd_multi_synthesis::get_line(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  kd_multi_line *v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  _DWORD *v36;
  uint64_t v37;
  BOOL v38;
  char v39;
  int v40;
  uint64_t *v41;
  uint64_t i;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  _OWORD v58[2];
  uint64_t v59;

  if (*(_QWORD *)(a2 + 56))
    kd_multi_synthesis::get_line();
  v4 = a2;
  if (!*(_BYTE *)(a2 + 39))
  {
    v7 = *(_DWORD *)(a2 + 24);
    if (v7 == (_DWORD)a3)
    {
      v8 = *(_DWORD *)(a2 + 32);
      if (v8 <= 0)
        kd_multi_synthesis::get_line();
LABEL_6:
      *(_DWORD *)(v4 + 32) = v8 - 1;
      v9 = *(_QWORD *)(v4 + 64);
      if (v9)
        --*(_DWORD *)(v9 + 44);
      return v4;
    }
    if (v7 != (_DWORD)a3 - 1)
      kd_multi_synthesis::get_line();
    if (*(int *)(a2 + 32) > 0)
      return 0;
    v12 = *(_QWORD *)(a2 + 64);
    if (v12)
    {
      if (*(_BYTE *)(v12 + 8))
      {
        v13 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - *(_QWORD *)(v12 + 16)) >> 4);
        if ((v13 & 0x80000000) != 0 || *(_DWORD *)(v12 + 24) <= (int)v13)
          kd_multi_synthesis::get_line();
        v14 = *(_QWORD *)(v12 + 32);
        v15 = 8 * (int)v13;
        v16 = *(kd_multi_line **)(v14 + v15);
        if (!v16)
          kd_multi_synthesis::get_line();
        if (!kd_multi_synthesis::get_line(a1, *(_QWORD *)(v14 + v15), a3, a4))
          return 0;
        *(_DWORD *)(v4 + 24) = a3;
        *(_DWORD *)(v4 + 32) = *(_DWORD *)(v4 + 28);
        kd_multi_line::copy(v4, v16, *(_DWORD *)(v4 + 44), *(float *)(v4 + 48));
      }
      else
      {
        if (*(int *)(v12 + 44) > 0)
          return 0;
        v45 = *(_DWORD *)(v12 + 40);
        v46 = *(_DWORD *)(v12 + 24);
        while (v45 < v46)
        {
          v47 = *(_QWORD *)(*(_QWORD *)(v12 + 32) + 8 * v45);
          if (v47 && !*(_BYTE *)(v47 + 39))
          {
            if (!kd_multi_synthesis::get_line(a1, v47, a3, a4))
              return 0;
            ++*(_DWORD *)(v47 + 32);
            v48 = *(_QWORD *)(v47 + 64);
            if (v48)
              ++*(_DWORD *)(v48 + 44);
            v45 = *(_DWORD *)(v12 + 40);
            v46 = *(_DWORD *)(v12 + 24);
          }
          *(_DWORD *)(v12 + 40) = ++v45;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
        if (*(int *)(v12 + 24) >= 1)
        {
          v50 = 0;
          do
          {
            v51 = *(_QWORD *)(*(_QWORD *)(v12 + 32) + 8 * v50);
            if (v51)
            {
              if (*(_DWORD *)(v51 + 24) != (_DWORD)a3)
                kd_multi_synthesis::get_line();
              --*(_DWORD *)(v51 + 32);
              v52 = *(_QWORD *)(v51 + 64);
              if (v52)
                --*(_DWORD *)(v52 + 44);
            }
            ++v50;
          }
          while (v50 < *(int *)(v12 + 24));
        }
        if (*(int *)(v12 + 12) >= 1)
        {
          v53 = 0;
          v54 = 0;
          do
          {
            v55 = *(_QWORD *)(v12 + 16);
            v56 = v55 + v53;
            if (*(_DWORD *)(v55 + v53 + 32) || *(_DWORD *)(v56 + 24) != v7)
              kd_multi_synthesis::get_line();
            *(_DWORD *)(v56 + 24) = a3;
            v57 = *(_DWORD *)(v55 + v53 + 28);
            *(_DWORD *)(v56 + 32) = v57;
            *(_DWORD *)(v12 + 44) += v57;
            ++v54;
            v53 += 80;
          }
          while (v54 < *(int *)(v12 + 12));
        }
        *(_DWORD *)(v12 + 40) = 0;
      }
    }
    else
    {
      v17 = *(unsigned int *)(a2 + 72);
      if ((v17 & 0x80000000) != 0)
        kd_multi_synthesis::get_line();
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
      if (*(_QWORD *)(v18 + 8 * v17) != a2)
        kd_multi_synthesis::get_line();
      v19 = v17 >= 3 || *(_BYTE *)(a1 + 16) == 0;
      v20 = !v19;
      if (!v19)
      {
        v21 = 0;
        while (1)
        {
          v22 = *(_QWORD *)(v18 + v21);
          if (*(_DWORD *)(v22 + 24) != v7)
            kd_multi_synthesis::get_line();
          if (*(int *)(v22 + 32) >= 1)
            return 0;
          v21 += 8;
          if (v21 == 24)
          {
            LODWORD(v17) = 0;
            break;
          }
        }
      }
      v23 = v17;
      v24 = 160 * v17;
      do
      {
        v25 = *(_QWORD *)(a1 + 40);
        v26 = v25 + v24;
        v27 = *(_DWORD *)(v25 + v24 + 112);
        if (!v27)
        {
          if (*(_BYTE *)(v26 + 104))
          {
            if (!a4 || (v32 = v25 + v24, *(int *)(v25 + v24 + 120) <= 0))
              kd_multi_synthesis::get_line();
            kdu_thread_entity::process_jobs((kdu_thread_entity *)a4, *(kdu_thread_queue **)(v32 + 16), 0, 1);
            v33 = *(_DWORD *)(v32 + 116);
            v27 = *(_DWORD *)(v32 + 120);
            *(_DWORD *)(v32 + 108) = v33;
            if (v33 <= 0)
              v34 = v27;
            else
              v34 = 0;
            v35 = *(_DWORD *)(v32 + 40) - (v27 + a3);
            if (v35 >= *(_DWORD *)(v32 + 124))
              v35 = *(_DWORD *)(v32 + 124);
            *(_DWORD *)(v26 + 112) = v27;
            *(_DWORD *)(v32 + 116) = v34;
            *(_DWORD *)(v32 + 120) = v35;
            if (v35 >= 1)
            {
              kdu_thread_entity::add_jobs(a4, *(kdu_thread_queue **)(v32 + 16), 1, 0);
              v27 = *(_DWORD *)(v26 + 112);
            }
          }
          else
          {
            v36 = (_DWORD *)(v25 + v24);
            v37 = *(_QWORD *)(v25 + v24 + 16);
            if (a4)
              v38 = v37 == 0;
            else
              v38 = 1;
            v39 = !v38;
            if (a4 | v37 && (v39 & 1) == 0)
              kd_multi_synthesis::get_line();
            v36[27] = 0;
            v40 = v36[10] - a3;
            if (v40 >= v36[31])
              v40 = v36[31];
            v36[29] = 0;
            v36[30] = v40;
            (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v36 + 16))(v26, a4, 0);
            v27 = v36[30];
            *(_DWORD *)(v26 + 112) = v27;
            v36[30] = 0;
          }
        }
        v28 = *(_QWORD *)(v26 + 136);
        v29 = *(int *)(v26 + 108);
        *(_DWORD *)(v26 + 108) = v29 + 1;
        *(_OWORD *)(v26 + 24) = *(_OWORD *)(v28 + 16 * v29);
        *(_DWORD *)(v26 + 112) = v27 - 1;
        if (v23++ >= 2)
          v31 = 0;
        else
          v31 = v20;
        v24 += 160;
      }
      while ((v31 & 1) != 0);
      if (v20)
      {
        v41 = *(uint64_t **)(*(_QWORD *)(a1 + 48) + 8);
        if (kdu_convert_ycc_to_rgb(*v41, v41[1], v41[2], -1))
        {
          v59 = 0;
          memset(v58, 0, sizeof(v58));
          kdu_error::kdu_error((kdu_error *)v58, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v58[0] + 16))(v58, "Corrupt JP2 data");
          kdu_error::~kdu_error((kdu_error *)v58);
        }
        for (i = 0; i != 3; ++i)
        {
          v43 = v41[i];
          kd_multi_line::apply_offset(v43, *(_DWORD *)(v43 + 44), *(float *)(v43 + 48));
          v44 = *(_DWORD *)(v43 + 28);
          ++*(_DWORD *)(v43 + 24);
          *(_DWORD *)(v43 + 32) = v44;
        }
      }
      else
      {
        kd_multi_line::apply_offset(v4, *(_DWORD *)(v4 + 44), *(float *)(v4 + 48));
        v49 = *(_DWORD *)(v4 + 28);
        ++*(_DWORD *)(v4 + 24);
        *(_DWORD *)(v4 + 32) = v49;
      }
    }
    if (*(_DWORD *)(v4 + 24) != (_DWORD)a3 || (v8 = *(_DWORD *)(v4 + 32), v8 <= 0))
      kd_multi_synthesis::get_line();
    goto LABEL_6;
  }
  return v4;
}

void sub_187F6EEC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F6EED0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL kd_multi_synthesis::is_line_precise(kd_multi_synthesis *this, unsigned int a2)
{
  _BOOL8 result;
  uint64_t v4;

  result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    v4 = *((_QWORD *)this + 7);
    if (v4)
      return *(_DWORD *)v4 > (signed int)a2 && *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * a2) + 38) != 0;
  }
  return result;
}

BOOL kd_multi_synthesis::is_line_absolute(kd_multi_synthesis *this, unsigned int a2)
{
  _BOOL8 result;
  uint64_t v4;

  result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    v4 = *((_QWORD *)this + 7);
    if (v4)
      return *(_DWORD *)v4 > (signed int)a2 && *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * a2) + 36) != 0;
  }
  return result;
}

uint64_t kdu_multi_analysis::create(uint64_t *a1, uint64_t a2, uint64_t *a3, int a4, uint64_t a5, char a6, int a7, kdu_thread_entity *a8, char *a9, char a10)
{
  uint64_t v18;

  v18 = operator new();
  *(_QWORD *)(v18 + 80) = 0;
  *(_QWORD *)(v18 + 88) = 0;
  *(_DWORD *)(v18 + 76) = 0;
  *(_BYTE *)(v18 + 72) = 1;
  *(_BYTE *)(v18 + 16) = 0;
  *(_DWORD *)(v18 + 128) = 0;
  *(_QWORD *)(v18 + 120) = 0;
  *(_OWORD *)(v18 + 24) = 0u;
  *(_OWORD *)(v18 + 40) = 0u;
  *(_OWORD *)(v18 + 56) = 0u;
  *(_QWORD *)(v18 + 96) = 0;
  *(_QWORD *)(v18 + 104) = 0;
  *(_DWORD *)(v18 + 112) = 0;
  *(_QWORD *)v18 = &off_1E1BB13E0;
  *(_QWORD *)(v18 + 8) = &unk_1E1BB1428;
  *(_QWORD *)(v18 + 136) = 0;
  *(_QWORD *)(v18 + 144) = 0;
  *a1 = v18;
  return kd_multi_analysis::create(v18, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t kd_multi_analysis::create(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, uint64_t a5, char a6, int a7, kdu_thread_entity *a8, char *a9, char a10)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  _BOOL8 v20;
  _BYTE *v21;
  uint64_t v22;
  _BOOL8 v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t i;
  uint64_t v30;
  uint64_t v31;
  int v32;
  BOOL v33;
  int v34;
  uint64_t v35;
  kd_multi_transform *v37;
  _BYTE v38[8];
  _BYTE v39[8];
  int32x4_t v40;
  int32x4_t *v41;
  uint64_t *v42;
  uint64_t *v43;

  v43 = a3;
  v37 = (kd_multi_transform *)(a1 + 8);
  kd_multi_transform::construct(a1 + 8, a2, a3, a4, 0, a6, a7, a8, a9, a10);
  kd_multi_analysis::prepare_network_for_inversion((_QWORD *)a1);
  if (**(int **)(a1 + 48) >= 1)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = *(_QWORD *)(a1 + 40);
      if (a8)
        v16 = *(_QWORD *)(v15 + v13 + 16);
      else
        v16 = 0;
      v42 = 0;
      v17 = v15 + v13;
      v18 = (uint64_t *)kdu_tile::access_component(&v43, *(_DWORD *)(v15 + v13 + 8));
      v41 = 0;
      v42 = v18;
      v41 = (int32x4_t *)kdu_tile_comp::access_resolution(&v42);
      v40 = 0uLL;
      kdu_resolution::get_dims(&v41, &v40);
      if (a5)
        v19 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a5 + 16))(a5, *(unsigned int *)(v17 + 8), v40.i64[0], v40.i64[1]);
      else
        v19 = 0;
      if (kdu_resolution::which((kdu_resolution *)&v41))
      {
        v20 = *(_BYTE *)(v17 + 62) == 0;
        v21 = v38;
        kdu_analysis::kdu_analysis(v38, v41, a1 + 72, v20, v19, a8, v16, 1.0);
      }
      else
      {
        v22 = kdu_resolution::access_subband((kdu_resolution *)&v41, 0);
        v23 = *(_BYTE *)(v17 + 62) == 0;
        v21 = v39;
        kdu_encoder::kdu_encoder(v39, v22, a1 + 72, v23, v19, a8, v16, 1.0);
      }
      *(_QWORD *)(v15 + v13 + 152) = *(_QWORD *)v21;
      ++v14;
      v13 += 160;
    }
    while (v14 < **(int **)(a1 + 48));
  }
  kd_multi_transform::create_resources(v37);
  v24 = operator new[]();
  *(_QWORD *)(a1 + 144) = v24;
  v25 = *(int **)(a1 + 56);
  if (*v25 >= 1)
  {
    v26 = 0;
    do
      *(_DWORD *)(v24 + 4 * v26++) = 0;
    while (v26 < *v25);
  }
  v27 = **(_DWORD **)(a1 + 48);
  if (v27 >= 1)
  {
    v28 = 0;
    for (i = 0; i < v27; ++i)
    {
      v30 = *(_QWORD *)(a1 + 40);
      v31 = v30 + v28;
      v32 = *(_DWORD *)(v30 + v28 + 124);
      *(_DWORD *)(v30 + v28 + 112) = v32;
      if (v32 > *(_DWORD *)(v30 + v28 + 40))
        kd_multi_analysis::create();
      v33 = __OFSUB__(v32, 1);
      v34 = v32 - 1;
      if (v34 < 0 == v33)
      {
        v35 = v30 + v28;
        *(_OWORD *)(v31 + 24) = *(_OWORD *)*(_QWORD *)(v35 + 136);
        *(_DWORD *)(v35 + 108) = 1;
        *(_DWORD *)(v31 + 112) = v34;
        v27 = **(_DWORD **)(a1 + 48);
      }
      v28 += 160;
    }
  }
  return *(int *)(a1 + 84);
}

void kd_multi_analysis::~kd_multi_analysis(kd_multi_analysis *this)
{
  kd_multi_transform *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BB13E0;
  *((_QWORD *)this + 1) = &unk_1E1BB1428;
  v2 = (kd_multi_analysis *)((char *)this + 8);
  v3 = *((_QWORD *)this + 18);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8052888210);
  kd_multi_transform::~kd_multi_transform(v2);
  *(_QWORD *)this = off_1E1BB2460;
}

{
  kd_multi_analysis::~kd_multi_analysis(this);
  JUMPOUT(0x18D761C30);
}

void `non-virtual thunk to'kd_multi_analysis::~kd_multi_analysis(kd_multi_analysis *this)
{
  kd_multi_analysis::~kd_multi_analysis((kd_multi_analysis *)((char *)this - 8));
}

{
  kd_multi_analysis::~kd_multi_analysis((kd_multi_analysis *)((char *)this - 8));
  JUMPOUT(0x18D761C30);
}

BOOL kd_multi_analysis::terminate_queues(_BOOL8 result, kdu_thread_entity *this)
{
  kdu_thread_queue *v2;

  if (this)
  {
    v2 = *(kdu_thread_queue **)(result + 104);
    if (!v2 || !*(_QWORD *)(*(_QWORD *)(result + 40) + 16))
      kd_multi_analysis::terminate_queues();
    return kdu_thread_entity::terminate(this, v2, 1, 0);
  }
  return result;
}

_QWORD *kd_multi_analysis::prepare_network_for_inversion(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  _OWORD v35[2];
  uint64_t v36;

  v1 = this;
  v2 = this[4];
  if (v2)
  {
    v3 = 0;
    do
    {
      if (*(_BYTE *)(v2 + 8))
      {
        v4 = *(unsigned int *)(v2 + 24);
        if ((int)v4 >= 1)
        {
          v5 = 0;
          v6 = 8 * (*(_DWORD *)(v2 + 12) & ~(*(int *)(v2 + 12) >> 31));
          v7 = 8 * v4;
          v8 = 28;
          do
          {
            if (v6 == v5)
              kd_multi_analysis::prepare_network_for_inversion();
            if (!*(_DWORD *)(*(_QWORD *)(v2 + 16) + v8))
            {
              v9 = *(_QWORD *)(v2 + 32);
              v10 = *(_QWORD *)(v9 + v5);
              if (v10)
              {
                --*(_DWORD *)(v10 + 28);
                *(_QWORD *)(v9 + v5) = 0;
              }
            }
            v5 += 8;
            v8 += 80;
          }
          while (v7 != v5);
        }
      }
      else
      {
        this = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
        if (this)
        {
          v11 = *(unsigned int *)(v2 + 12);
          if ((int)v11 >= 1)
          {
            v12 = (_BYTE *)(*(_QWORD *)(v2 + 16) + 39);
            do
            {
              *v12 = 1;
              v12 += 80;
              --v11;
            }
            while (v11);
          }
          v13 = *(unsigned int *)(v2 + 24);
          if ((int)v13 >= 1)
          {
            v14 = 0;
            v15 = 8 * v13;
            do
            {
              v16 = *(_QWORD *)(v2 + 32);
              v17 = *(_QWORD *)(v16 + v14);
              if (v17)
              {
                --*(_DWORD *)(v17 + 28);
                *(_QWORD *)(v16 + v14) = 0;
              }
              v14 += 8;
            }
            while (v15 != v14);
          }
          v3 = (uint64_t)this;
        }
      }
      v2 = *(_QWORD *)(v2 + 56);
    }
    while (v2);
  }
  else
  {
    v3 = 0;
  }
  for (i = v1[3]; i; i = *(_QWORD *)(i + 48))
  {
    v19 = *(unsigned int *)(i + 24);
    if ((int)v19 >= 1)
    {
      v20 = 0;
      v21 = 8 * v19;
      v22 = 39;
      do
      {
        v23 = *(_QWORD *)(i + 32);
        v24 = *(_QWORD *)(v23 + v20);
        if (v24)
        {
          if (*(_BYTE *)(v24 + 39))
          {
            *(_QWORD *)(v23 + v20) = 0;
            --*(_DWORD *)(v24 + 28);
            if (*(_BYTE *)(i + 8))
              *(_BYTE *)(*(_QWORD *)(i + 16) + v22) = 1;
          }
        }
        v20 += 8;
        v22 += 80;
      }
      while (v21 != v20);
    }
  }
  v25 = (int *)v1[6];
  if (*v25 >= 1)
  {
    v26 = 0;
    do
    {
      if (*(int *)(*(_QWORD *)(*((_QWORD *)v25 + 1) + 8 * v26) + 28) <= 0)
      {
        v36 = 0;
        memset(v35, 0, sizeof(v35));
        kdu_error::kdu_error((kdu_error *)v35, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v35[0] + 16))(v35, "Cannot perform forward multi-component transform based on the source image components supplied.  The multi-component transform is defined from the perspective of decompression (i.e., synthesis, or inverse transformation).  Not all of the defined transform blocks may be invertible.  Also, if the defined transform blocks do not use all codestream components to produce final output image components during decompression, it will not be possible to work back from the final image components to codestream components which can be subjected to spatial wavelet transformation and coding.  One of these conditions has been encountered with the configuration you are targeting during compression.");
        if (v3)
        {
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v35[0] + 16))(v35, "  The following additional explanation is available ---- ");
          (*(void (**)(_OWORD *, uint64_t))(*(_QWORD *)&v35[0] + 16))(v35, v3);
        }
        kdu_error::~kdu_error((kdu_error *)v35);
      }
      ++v26;
    }
    while (v26 < *v25);
  }
  v27 = v1[7];
  v28 = *(_DWORD *)v27;
  if (*(int *)v27 >= 1)
  {
    v29 = 0;
    do
    {
      v30 = v1[4];
      if (v30)
      {
        v31 = *(_QWORD *)(*(_QWORD *)(v27 + 8) + 8 * v29);
        do
        {
          if (*(int *)(v31 + 28) < 2)
            break;
          v32 = *(unsigned int *)(v30 + 24);
          if ((int)v32 >= 1)
          {
            v33 = *(_QWORD **)(v30 + 32);
            while (*v33 != *(_QWORD *)(*(_QWORD *)(v27 + 8) + 8 * v29))
            {
              ++v33;
              if (!--v32)
                goto LABEL_52;
            }
            *v33 = 0;
            v27 = v1[7];
            v34 = *(_QWORD *)(*(_QWORD *)(v27 + 8) + 8 * v29);
            --*(_DWORD *)(v34 + 28);
          }
LABEL_52:
          v30 = *(_QWORD *)(v30 + 56);
        }
        while (v30);
        v28 = *(_DWORD *)v27;
      }
      ++v29;
    }
    while (v29 < v28);
  }
  return this;
}

void sub_187F6F6C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F6F6CC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_multi_analysis::get_size(kd_multi_analysis *this, unsigned int a2)
{
  uint64_t v2;

  if ((a2 & 0x80000000) != 0 || (v2 = *((_QWORD *)this + 7), *(_DWORD *)v2 <= (signed int)a2))
    kd_multi_analysis::get_size();
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 8) + 8 * a2) + 16);
}

uint64_t kd_multi_analysis::exchange_line(uint64_t a1, unsigned int a2, kd_multi_line *this, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v10;

  if ((a2 & 0x80000000) != 0 || (v5 = *(_QWORD *)(a1 + 56), *(_DWORD *)v5 <= (signed int)a2))
    kd_multi_analysis::exchange_line();
  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 144) + 4 * a2);
  v7 = *(_QWORD *)(*(_QWORD *)(v5 + 8) + 8 * a2);
  if ((int)v6 >= *(_DWORD *)(v7 + 16))
    return 0;
  if (*(_DWORD *)(v7 + 28) != 1)
    kd_multi_analysis::exchange_line();
  if (this)
  {
    if ((kd_multi_line *)v7 != this || *((_BYTE *)this + 32))
      kd_multi_analysis::exchange_line();
    v10 = a2;
    kd_multi_line::apply_offset((uint64_t)this, -*((_DWORD *)this + 11), -*((float *)this + 12));
    kd_multi_analysis::advance_line(a1, (uint64_t)this, v6, a4);
    LODWORD(v6) = v6 + 1;
    *(_DWORD *)(*(_QWORD *)(a1 + 144) + 4 * v10) = v6;
  }
  if (*(_DWORD *)(v7 + 24) != (_DWORD)v6 - 1)
    kd_multi_analysis::exchange_line();
  if (*(_BYTE *)(v7 + 32))
    return 0;
  else
    return v7;
}

uint64_t kd_multi_analysis::advance_line(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  BOOL v14;
  char v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t j;
  uint64_t v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  _DWORD *v29;
  uint64_t v30;
  BOOL v31;
  char v32;
  int v33;
  BOOL v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  uint64_t i;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  _OWORD v61[2];
  uint64_t v62;

  if (*(_DWORD *)(a2 + 28) != 1)
    kd_multi_analysis::advance_line();
  if (*(_DWORD *)(a2 + 24) != (_DWORD)a3 - 1)
    kd_multi_analysis::advance_line();
  *(_DWORD *)(a2 + 24) = a3;
  *(_BYTE *)(a2 + 32) = 0;
  if (!*(_BYTE *)(a2 + 39))
  {
    v7 = result;
    v8 = *(_QWORD *)(a2 + 64);
    if (v8)
    {
      if (!*(_BYTE *)(v8 + 8))
      {
        *(_BYTE *)(a2 + 32) = 1;
        v41 = *(_DWORD *)(v8 + 44);
        v34 = __OFSUB__(v41--, 1);
        *(_DWORD *)(v8 + 44) = v41;
        if (!((v41 < 0) ^ v34 | (v41 == 0)))
          return result;
        v42 = *(unsigned int *)(v8 + 24);
        v43 = *(_DWORD *)(v8 + 40);
        if (v43 < (int)v42)
        {
          v44 = 8 * v43;
          do
          {
            v45 = *(_QWORD *)(v8 + 32);
            v46 = *(_QWORD *)(v45 + v44);
            if (v46)
            {
              if (*(_BYTE *)(v46 + 39))
              {
                *(_QWORD *)(v45 + v44) = 0;
              }
              else if (*(_DWORD *)(v46 + 24) < (int)a3 && *(_BYTE *)(v46 + 32))
              {
                return result;
              }
            }
            *(_DWORD *)(v8 + 40) = ++v43;
            v44 += 8;
          }
          while ((_DWORD)v42 != v43);
        }
        if ((int)v42 >= 1)
        {
          v47 = 0;
          v48 = 8 * v42;
          do
          {
            v49 = *(_QWORD *)(v8 + 32);
            v50 = *(_QWORD *)(v49 + v47);
            if (v50 && *(_DWORD *)(v50 + 24) >= (int)a3)
            {
              v51 = *(_DWORD *)(v50 + 28);
              v34 = __OFSUB__(v51, 1);
              v52 = v51 - 1;
              if ((v52 < 0) ^ v34 | (v52 == 0))
                kd_multi_analysis::advance_line();
              *(_DWORD *)(v50 + 28) = v52;
              *(_QWORD *)(v49 + v47) = 0;
            }
            v47 += 8;
          }
          while (v48 != v47);
        }
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 56))(v8);
        v53 = *(_DWORD *)(v8 + 24);
        if (v53 >= 1)
        {
          for (i = 0; i < v53; ++i)
          {
            v55 = *(_QWORD *)(*(_QWORD *)(v8 + 32) + 8 * i);
            if (v55)
            {
              result = kd_multi_analysis::advance_line(v7, v55, a3, a4);
              v53 = *(_DWORD *)(v8 + 24);
            }
          }
        }
        if (*(int *)(v8 + 12) >= 1)
        {
          v56 = 0;
          v57 = 0;
          v58 = *(_QWORD *)(v8 + 16);
          do
          {
            *(_BYTE *)(v58 + v56 + 32) = 0;
            v58 = *(_QWORD *)(v8 + 16);
            v59 = *(_DWORD *)(v58 + v56 + 28);
            if (v59 >= 1)
            {
              if (v59 != 1)
                kd_multi_analysis::advance_line();
              ++*(_DWORD *)(v8 + 44);
            }
            ++v57;
            v56 += 80;
          }
          while (v57 < *(int *)(v8 + 12));
        }
        *(_DWORD *)(v8 + 40) = 0;
        goto LABEL_89;
      }
      v9 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - *(_QWORD *)(v8 + 16)) >> 4);
      if ((v9 & 0x80000000) != 0 || *(_DWORD *)(v8 + 24) <= (int)v9)
        kd_multi_analysis::advance_line();
      v10 = *(_QWORD *)(v8 + 32);
      v11 = *(_QWORD *)(v10 + 8 * (int)v9);
      v12 = *(_DWORD *)(v11 + 28);
      if (*(_DWORD *)(v11 + 24) < (int)a3)
      {
        if (v12 < 1 || *(_BYTE *)(v11 + 39))
          kd_multi_analysis::advance_line();
        kd_multi_line::copy(v11, (kd_multi_line *)a2, -*(_DWORD *)(v11 + 44), -*(float *)(v11 + 48));
        result = kd_multi_analysis::advance_line(v7, v11, a3, a4);
LABEL_89:
        if (*(_BYTE *)(a2 + 32))
          kd_multi_analysis::advance_line();
        return result;
      }
      v34 = __OFSUB__(v12, 1);
      v60 = v12 - 1;
      if ((v60 < 0) ^ v34 | (v60 == 0))
        kd_multi_analysis::advance_line();
      *(_DWORD *)(v11 + 28) = v60;
      *(_QWORD *)(v10 + 8 * (int)v9) = 0;
    }
    else
    {
      v13 = *(unsigned int *)(a2 + 72);
      if ((v13 & 0x80000000) != 0)
        kd_multi_analysis::advance_line();
      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 48) + 8) + 8 * v13) != a2)
        kd_multi_analysis::advance_line();
      v14 = v13 >= 3 || *(_BYTE *)(result + 16) == 0;
      v15 = !v14;
      if (v14)
      {
LABEL_30:
        v20 = ~(_DWORD)a3;
        v21 = v13;
        v22 = 160 * v13;
        do
        {
          v23 = *(_QWORD *)(v7 + 40);
          v24 = v23 + v22;
          v25 = *(_DWORD *)(v23 + v22 + 112);
          if (!v25)
          {
            if (*(_BYTE *)(v24 + 104))
            {
              if (!a4)
                kd_multi_analysis::advance_line();
              v26 = v23 + v22;
              v27 = *(_DWORD *)(v23 + v22 + 120);
              if (v27)
              {
                kdu_thread_entity::process_jobs((kdu_thread_entity *)a4, *(kdu_thread_queue **)(v26 + 16), 0, 1);
                v27 = 0;
                if (!*(_DWORD *)(v26 + 116))
                  v27 = *(_DWORD *)(v26 + 120);
              }
              v28 = *(_DWORD *)(v26 + 108) - v27;
              *(_DWORD *)(v26 + 116) = v27;
              *(_DWORD *)(v26 + 120) = v28;
              if (v27 >= 1)
                *(_DWORD *)(v26 + 108) = 0;
              result = kdu_thread_entity::add_jobs(a4, *(kdu_thread_queue **)(v23 + v22 + 16), 1, 0);
            }
            else
            {
              v29 = (_DWORD *)(v23 + v22);
              v30 = *(_QWORD *)(v23 + v22 + 16);
              if (a4)
                v31 = v30 == 0;
              else
                v31 = 1;
              v32 = !v31;
              if (a4 | v30 && (v32 & 1) == 0)
                kd_multi_analysis::advance_line();
              v33 = v29[27];
              v29[29] = 0;
              v29[30] = v33;
              v29[27] = 0;
              result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v29 + 16))(v23 + v22, a4, 0);
              v29[30] = 0;
            }
            v25 = *(_DWORD *)(v23 + v22 + 124);
            if (*(_DWORD *)(v23 + v22 + 40) + v20 < v25)
              v25 = *(_DWORD *)(v23 + v22 + 40) + v20;
            *(_DWORD *)(v24 + 112) = v25;
          }
          v34 = __OFSUB__(v25, 1);
          v35 = v25 - 1;
          if (v35 < 0 == v34)
          {
            v36 = v23 + v22;
            v37 = *(_QWORD *)(v23 + v22 + 136);
            v38 = *(int *)(v23 + v22 + 108);
            *(_DWORD *)(v36 + 108) = v38 + 1;
            *(_OWORD *)(v36 + 24) = *(_OWORD *)(v37 + 16 * v38);
            *(_DWORD *)(v24 + 112) = v35;
          }
          if (v21++ >= 2)
            v40 = 0;
          else
            v40 = v15;
          v22 += 160;
        }
        while ((v40 & 1) != 0);
        goto LABEL_89;
      }
      v16 = 0;
      *(_BYTE *)(a2 + 32) = 1;
      v17 = *(uint64_t **)(*(_QWORD *)(result + 48) + 8);
      while (*(_DWORD *)(v17[v16] + 24) >= (int)a3)
      {
        if (++v16 == 3)
        {
          result = kdu_convert_rgb_to_ycc(*v17, v17[1], v17[2]);
          if ((_DWORD)result)
          {
            v62 = 0;
            memset(v61, 0, sizeof(v61));
            kdu_error::kdu_error((kdu_error *)v61, "Kakadu Core Error:\n");
            (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v61[0] + 16))(v61, "Corrupt JP2 data");
            kdu_error::~kdu_error((kdu_error *)v61);
          }
          for (j = 0; j != 3; ++j)
          {
            v19 = v17[j];
            if (!*(_BYTE *)(v19 + 32))
              kd_multi_analysis::advance_line();
            *(_BYTE *)(v19 + 32) = 0;
          }
          LODWORD(v13) = 0;
          goto LABEL_30;
        }
      }
    }
  }
  return result;
}

void sub_187F6FCD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F6FCDC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL kd_multi_analysis::is_line_precise(kd_multi_analysis *this, unsigned int a2)
{
  _BOOL8 result;
  uint64_t v4;

  result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    v4 = *((_QWORD *)this + 7);
    if (v4)
      return *(_DWORD *)v4 > (signed int)a2 && *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * a2) + 38) != 0;
  }
  return result;
}

BOOL kd_multi_analysis::is_line_absolute(kd_multi_analysis *this, unsigned int a2)
{
  _BOOL8 result;
  uint64_t v4;

  result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    v4 = *((_QWORD *)this + 7);
    if (v4)
      return *(_DWORD *)v4 > (signed int)a2 && *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * a2) + 36) != 0;
  }
  return result;
}

float kd_multi_null_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, uint64_t a7, uint64_t a8, kd_multi_transform *a9)
{
  unint64_t scratch_ints;
  int *v17;
  float *scratch_floats;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  float result;
  uint64_t v24;
  uint64_t i;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36[2];
  int v37;
  int v38;
  uint64_t *v39;

  v39 = a4;
  v37 = a6;
  v38 = a5;
  scratch_ints = kd_multi_transform::get_scratch_ints(a9, a5 + 2 * a6);
  v17 = (int *)(scratch_ints + 4 * a5);
  scratch_floats = (float *)kd_multi_transform::get_scratch_floats(a9, a6);
  *(_QWORD *)v36 = 0;
  kdu_tile::get_mct_block_info(&v39, a2, a3, (unsigned int *)&v36[1], v36, &v38, &v37, scratch_ints, v17, scratch_floats, &v17[a6], 0);
  if (*(_QWORD *)v36 != __PAIR64__(*(_DWORD *)a7, *(_DWORD *)a8))
    kd_multi_null_block::initialize();
  v19 = v37;
  *(_DWORD *)(a1 + 12) = v37;
  is_mul_ok(v19, 0x50uLL);
  v20 = operator new[]();
  if ((_DWORD)v19)
  {
    v21 = v20;
    do
    {
      *(_DWORD *)v21 = 0;
      *(_QWORD *)(v21 + 14) = 0;
      *(_QWORD *)(v21 + 6) = 0;
      *(_WORD *)(v21 + 22) = 0;
      *(_DWORD *)(v21 + 24) = -1;
      *(_QWORD *)(v21 + 28) = 0;
      *(_QWORD *)(v21 + 44) = 0;
      *(_QWORD *)(v21 + 36) = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_QWORD *)(v21 + 64) = 0;
      *(_DWORD *)(v21 + 72) = -1;
      v21 += 80;
    }
    while (v21 != v20 + 80 * (int)v19);
  }
  *(_QWORD *)(a1 + 16) = v20;
  v22 = v38;
  if (v38 >= *(_DWORD *)(a1 + 12))
    v22 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 24) = v22;
  *(_QWORD *)(a1 + 32) = operator new[]();
  v24 = *(unsigned int *)(a1 + 24);
  if ((int)v24 >= 1)
  {
    for (i = 0; i != v24; ++i)
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * i) = *(_QWORD *)(*(_QWORD *)(a7 + 8) + 8 * *(int *)(scratch_ints + 4 * i));
  }
  v26 = *(unsigned int *)(a1 + 12);
  if ((int)v26 >= 1)
  {
    v27 = 0;
    v28 = 0;
    v29 = 80 * v26;
    do
    {
      v30 = *(_QWORD *)(a1 + 16);
      v31 = v30 + v27;
      *(_QWORD *)(v30 + v27 + 64) = a1;
      *(_QWORD *)(*(_QWORD *)(a8 + 8) + 8 * v17[v28]) = v30 + v27;
      if (v28 >= (int)v24)
      {
        *(_BYTE *)(v31 + 39) = 1;
      }
      else
      {
        v32 = *(_QWORD *)(a1 + 32);
        v33 = *(_QWORD *)(v32 + 8 * v28);
        *(_WORD *)(v31 + 36) = *(_WORD *)(v33 + 36);
        if (*(_BYTE *)(v33 + 39))
        {
          v34 = v30 + v27;
          *(_BYTE *)(v34 + 39) = 1;
          *(_DWORD *)(v34 + 44) = *(_DWORD *)(v33 + 44);
          *(_DWORD *)(v34 + 48) = *(_DWORD *)(v33 + 48);
          *(_QWORD *)(v32 + 8 * v28) = 0;
        }
        else
        {
          ++*(_DWORD *)(v33 + 28);
        }
      }
      v35 = v30 + v27;
      *(_DWORD *)(v35 + 44) += *(_DWORD *)(scratch_ints + 4 * a5 + 4 * a6 + 4 * v28);
      result = scratch_floats[v28] + *(float *)(v35 + 48);
      *(float *)(v35 + 48) = result;
      ++v28;
      v27 += 80;
    }
    while (v29 != v27);
  }
  return result;
}

uint64_t kd_multi_matrix_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, uint64_t a7, uint64_t a8, kd_multi_transform *a9)
{
  unint64_t scratch_ints;
  int *v17;
  float *scratch_floats;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float *v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t i;
  uint64_t v34;
  uint64_t v35;
  float v36;
  float *v37;
  float *v38;
  uint64_t v39;
  int v40[2];
  int v41;
  int v42;
  uint64_t *v43;

  v43 = a4;
  v41 = a6;
  v42 = a5;
  scratch_ints = kd_multi_transform::get_scratch_ints(a9, a6 + a5);
  v17 = (int *)(scratch_ints + 4 * a5);
  scratch_floats = (float *)kd_multi_transform::get_scratch_floats(a9, a6);
  *(_QWORD *)v40 = 0;
  kdu_tile::get_mct_block_info(&v43, a2, a3, (unsigned int *)&v40[1], v40, &v42, &v41, scratch_ints, v17, scratch_floats, 0, 0);
  if (*(_QWORD *)v40 != __PAIR64__(*(_DWORD *)a7, *(_DWORD *)a8))
    kd_multi_matrix_block::initialize();
  v19 = v41;
  *(_DWORD *)(a1 + 12) = v41;
  is_mul_ok(v19, 0x50uLL);
  v20 = operator new[]();
  if ((_DWORD)v19)
  {
    v21 = v20;
    do
    {
      *(_DWORD *)v21 = 0;
      *(_QWORD *)(v21 + 14) = 0;
      *(_QWORD *)(v21 + 6) = 0;
      *(_WORD *)(v21 + 22) = 0;
      *(_DWORD *)(v21 + 24) = -1;
      *(_QWORD *)(v21 + 28) = 0;
      *(_QWORD *)(v21 + 44) = 0;
      *(_QWORD *)(v21 + 36) = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_QWORD *)(v21 + 64) = 0;
      *(_DWORD *)(v21 + 72) = -1;
      v21 += 80;
    }
    while (v21 != v20 + 80 * (int)v19);
  }
  *(_QWORD *)(a1 + 16) = v20;
  *(_DWORD *)(a1 + 24) = v42;
  *(_QWORD *)(a1 + 32) = operator new[]();
  v22 = (float *)operator new[]();
  *(_QWORD *)(a1 + 64) = v22;
  result = kdu_tile::get_mct_matrix_info((kdu_tile *)&v43, a2, a3, v22);
  v24 = *(unsigned int *)(a1 + 24);
  if ((int)v24 >= 1)
  {
    v25 = 0;
    v26 = *(_QWORD *)(a1 + 32);
    do
    {
      *(_QWORD *)(v26 + 8 * v25) = *(_QWORD *)(*(_QWORD *)(a7 + 8) + 8 * *(int *)(scratch_ints + 4 * v25));
      v26 = *(_QWORD *)(a1 + 32);
      v27 = *(_QWORD *)(v26 + 8 * v25);
      if (v27)
        ++*(_DWORD *)(v27 + 28);
      ++v25;
    }
    while (v24 != v25);
  }
  v28 = *(unsigned int *)(a1 + 12);
  if ((int)v28 >= 1)
  {
    v29 = 0;
    do
    {
      v30 = *(_QWORD *)(a1 + 16) + v29;
      *(_QWORD *)(v30 + 64) = a1;
      v31 = *v17++;
      *(_QWORD *)(*(_QWORD *)(a8 + 8) + 8 * v31) = v30;
      *(_BYTE *)(v30 + 37) = 1;
      *(float *)&v31 = *scratch_floats++;
      *(_DWORD *)(v30 + 48) = v31;
      v29 += 80;
    }
    while (80 * v28 != v29);
  }
  if ((int)v24 >= 1)
  {
    v32 = 0;
    for (i = 0; i != v24; ++i)
    {
      v34 = *(_QWORD *)(a1 + 32);
      v35 = *(_QWORD *)(v34 + 8 * i);
      if (*(_BYTE *)(v35 + 39))
      {
        if ((int)v28 >= 1)
        {
          v36 = *(float *)(v35 + 48);
          v37 = (float *)(*(_QWORD *)(a1 + 64) + v32);
          v38 = (float *)(*(_QWORD *)(a1 + 16) + 48);
          v39 = v28;
          do
          {
            *v38 = *v38 + (float)(v36 * *v37);
            v38 += 20;
            v37 += v24;
            --v39;
          }
          while (v39);
        }
        --*(_DWORD *)(v35 + 28);
        *(_QWORD *)(v34 + 8 * i) = 0;
      }
      v32 += 4;
    }
  }
  return result;
}

uint64_t kd_multi_matrix_block::normalize_coefficients(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  float *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  float v17;
  float *v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;

  v1 = *(int *)(this + 24);
  v2 = *(unsigned int *)(this + 24);
  if ((int)v1 < 1)
  {
    v5 = 0;
  }
  else
  {
    v3 = 0;
    v4 = 0;
    v5 = 0;
    v6 = *(_QWORD *)(this + 32);
    do
    {
      v7 = *(_QWORD *)(v6 + 8 * v4);
      if (v7)
      {
        if (*(_BYTE *)(v7 + 39))
          kd_multi_matrix_block::normalize_coefficients();
        v8 = *(_DWORD *)(v7 + 40);
        if (v8)
        {
          v5 |= *(_BYTE *)(v7 + 38) != 0;
          v9 = *(unsigned int *)(this + 12);
          if ((int)v9 >= 1)
          {
            v10 = (float)(1 << v8);
            v11 = (float *)(*(_QWORD *)(this + 64) + v3);
            do
            {
              *v11 = *v11 * v10;
              v11 += v2;
              --v9;
            }
            while (v9);
          }
        }
        else
        {
          v5 = 1;
        }
      }
      ++v4;
      v3 += 4;
    }
    while (v4 != v2);
  }
  v12 = *(unsigned int *)(this + 12);
  if ((int)v12 >= 1)
  {
    v13 = 0;
    v14 = 0;
    v15 = *(_QWORD *)(this + 16);
    do
    {
      v16 = *(_DWORD *)(v15 + 80 * v14 + 40);
      if (v16)
      {
        v5 |= *(_BYTE *)(v15 + 80 * v14 + 38) != 0;
        if ((int)v2 >= 1)
        {
          v17 = 1.0 / (float)(1 << v16);
          v18 = (float *)(*(_QWORD *)(this + 64) + v13);
          v19 = v2;
          do
          {
            *v18 = v17 * *v18;
            ++v18;
            --v19;
          }
          while (v19);
        }
      }
      else
      {
        v5 = 1;
      }
      ++v14;
      v13 += 4 * v1;
    }
    while (v14 != v12);
  }
  if ((v5 & 1) != 0)
  {
    if ((int)v1 >= 1)
    {
      v20 = *(_QWORD *)(this + 32);
      do
      {
        if (*(_QWORD *)v20)
          *(_BYTE *)(*(_QWORD *)v20 + 38) = 1;
        v20 += 8;
        --v2;
      }
      while (v2);
    }
    if ((int)v12 >= 1)
    {
      v21 = (_BYTE *)(*(_QWORD *)(this + 16) + 38);
      do
      {
        *v21 = 1;
        v21 += 80;
        --v12;
      }
      while (v12);
    }
  }
  return this;
}

void kd_multi_matrix_block::perform_transform(kd_multi_matrix_block *this)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  float *v6;
  int v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  float *v14;
  int v15;
  uint64_t v16;
  float *v17;
  int v18;
  uint64_t v19;
  float *v20;
  float v21;
  _WORD *v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  BOOL v32;
  __int16 *v33;
  int v34;
  int v35;
  char v36;
  uint64_t v37;
  int *v38;
  int v39;
  uint64_t v40;
  int *v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;

  if (*((int *)this + 3) >= 1)
  {
    v2 = 0;
    while (1)
    {
      v3 = *((_QWORD *)this + 2);
      v4 = (unsigned int *)(v3 + 80 * v2);
      v5 = *v4;
      if ((*((_BYTE *)v4 + 6) & 2) != 0)
        break;
      v6 = (float *)*((_QWORD *)v4 + 1);
      if (!v6)
        break;
      if ((int)v5 >= 1)
      {
        v7 = *(_DWORD *)(v3 + 80 * v2 + 48);
        v8 = *v4;
        v9 = (_DWORD *)*((_QWORD *)v4 + 1);
        do
        {
          *v9++ = v7;
          --v8;
        }
        while (v8);
      }
      LODWORD(v10) = *((_DWORD *)this + 6);
      if ((int)v10 >= 1)
      {
        v11 = 0;
        do
        {
          v12 = *(_QWORD *)(*((_QWORD *)this + 4) + 8 * v11);
          if (v12)
          {
            v13 = *(float *)(*((_QWORD *)this + 8) + 4 * ((int)v11 + (int)v10 * (int)v2));
            if (v13 != 0.0)
            {
              if ((*(_BYTE *)(v12 + 6) & 2) != 0)
                v14 = 0;
              else
                v14 = *(float **)(v12 + 8);
              if (*(_BYTE *)(v12 + 36))
              {
                v15 = *(_DWORD *)(v12 + 40);
                if (v15 >= 1)
                  v13 = v13 * (float)(1.0 / (float)(1 << v15));
                if ((int)v5 >= 1)
                {
                  v16 = v5;
                  v17 = v6;
                  do
                  {
                    v18 = *(_DWORD *)v14++;
                    *v17 = *v17 + (float)(v13 * (float)v18);
                    ++v17;
                    --v16;
                  }
                  while (v16);
                }
              }
              else if ((int)v5 >= 1)
              {
                v19 = v5;
                v20 = v6;
                do
                {
                  v21 = *v14++;
                  *v20 = *v20 + (float)(v13 * v21);
                  ++v20;
                  --v19;
                }
                while (v19);
              }
            }
          }
          ++v11;
          v10 = *((int *)this + 6);
        }
        while (v11 < v10);
      }
LABEL_57:
      if (++v2 >= *((int *)this + 3))
        return;
    }
    if (*((_QWORD *)this + 10))
    {
      if ((*((_BYTE *)v4 + 6) & 2) != 0)
      {
LABEL_29:
        v22 = (_WORD *)*((_QWORD *)v4 + 1);
LABEL_32:
        v23 = (int *)*((_QWORD *)this + 11);
        bzero(v23, 4 * (int)v5);
        LODWORD(v24) = *((_DWORD *)this + 6);
        if ((int)v24 >= 1)
        {
          v25 = 0;
          v26 = *((_QWORD *)this + 10);
          v27 = *((_QWORD *)this + 4);
          do
          {
            v28 = v25 + v24 * v2;
            v29 = *(__int16 *)(v26 + 2 * v28);
            v30 = *(unsigned __int16 *)(v26 + 2 * v28);
            v31 = *(_QWORD *)(v27 + 8 * v25);
            if (v31)
              v32 = v30 == 0;
            else
              v32 = 1;
            if (!v32)
            {
              if ((*(_BYTE *)(v31 + 6) & 2) != 0)
                v33 = *(__int16 **)(v31 + 8);
              else
                v33 = 0;
              if (*(_BYTE *)(v31 + 36))
              {
                v34 = *(_DWORD *)(v31 + 40);
                if (v34 <= 0)
                  kd_multi_matrix_block::perform_transform();
                v35 = ((1 << (v34 - 14)) + v29) >> (v34 - 13);
                if (v34 < 0xE)
                {
                  v36 = 13 - v34;
                }
                else
                {
                  LOWORD(v30) = v35;
                  v36 = 0;
                }
                if ((int)v5 >= 1)
                {
                  v37 = v5;
                  v38 = v23;
                  do
                  {
                    v39 = *v33++;
                    *v38++ += (v39 << v36) * (__int16)v30;
                    --v37;
                  }
                  while (v37);
                }
              }
              else if ((int)v5 >= 1)
              {
                v40 = v5;
                v41 = v23;
                do
                {
                  v42 = *v33++;
                  *v41++ += v42 * v29;
                  --v40;
                }
                while (v40);
              }
            }
            ++v25;
            v24 = *((int *)this + 6);
          }
          while (v25 < v24);
        }
        if ((int)v5 >= 1)
        {
          v43 = *((_DWORD *)this + 24);
          v44 = (vcvtmd_s64_f64((float)(*(float *)(v3 + 80 * v2 + 48) * 8192.0) + 0.5) << v43) + (1 << v43 >> 1);
          do
          {
            v45 = *v23++;
            *v22++ = (int)(v44 + v45) >> v43;
            --v5;
          }
          while (v5);
        }
        goto LABEL_57;
      }
    }
    else
    {
      kd_multi_matrix_block::create_short_coefficients((uint64_t)this);
      if ((*((_BYTE *)v4 + 6) & 2) != 0)
        goto LABEL_29;
    }
    v22 = 0;
    goto LABEL_32;
  }
}

uint64_t kd_multi_matrix_block::create_short_coefficients(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (!*(_QWORD *)(this + 80))
  {
    v1 = this;
    v2 = *(unsigned int *)(this + 12);
    v3 = *(int *)(this + 24);
    if ((int)v2 < 1)
    {
      v6 = 0.00001;
    }
    else
    {
      v4 = 0;
      v5 = 0;
      v6 = 0.00001;
      do
      {
        if ((int)v3 >= 1)
        {
          v7 = *(_QWORD **)(this + 32);
          v8 = *(unsigned int *)(this + 24);
          v9 = v4;
          do
          {
            if (*v7)
            {
              v10 = *(float *)(*(_QWORD *)(this + 64) + v9);
              if (v10 <= v6)
              {
                if (v10 < (float)-v6)
                  v6 = -v10;
              }
              else
              {
                v6 = *(float *)(*(_QWORD *)(this + 64) + v9);
              }
            }
            v9 += 4;
            ++v7;
            --v8;
          }
          while (v8);
        }
        ++v5;
        v4 += 4 * v3;
      }
      while (v5 != v2);
    }
    *(_QWORD *)(this + 80) = operator new[]();
    this = operator new[]();
    *(_QWORD *)(v1 + 88) = this;
    *(_DWORD *)(v1 + 96) = 0;
    v11 = 1.0;
    if (v6 <= 16383.0)
    {
      v12 = 0;
      do
      {
        ++v12;
        v11 = v11 + v11;
      }
      while ((float)(v6 * v11) <= 16383.0);
      *(_DWORD *)(v1 + 96) = v12;
    }
    v13 = *(unsigned int *)(v1 + 12);
    if ((int)v13 >= 1)
    {
      v14 = 0;
      v15 = 0;
      v16 = *(unsigned int *)(v1 + 24);
      v17 = *(_DWORD *)(v1 + 24);
      do
      {
        if (v17 >= 1)
        {
          v18 = *(uint64_t **)(v1 + 32);
          v19 = *(_QWORD *)(v1 + 80);
          v20 = v16;
          this = v14;
          do
          {
            v21 = *v18;
            if (*v18)
            {
              LODWORD(v21) = vcvtmd_s64_f64((float)(v11 * *(float *)(*(_QWORD *)(v1 + 64) + 4 * this)) + 0.5);
              if ((int)v21 <= -32768)
                LODWORD(v21) = -32768;
              if ((int)v21 >= 0x7FFF)
                LOWORD(v21) = 0x7FFF;
            }
            *(_WORD *)(v19 + 2 * this++) = v21;
            ++v18;
            --v20;
          }
          while (v20);
        }
        ++v15;
        v14 += (int)v16;
      }
      while (v15 != v13);
    }
  }
  return this;
}

const char *kd_multi_matrix_block::prepare_for_inversion(kd_multi_matrix_block *this)
{
  const char *v1;
  uint64_t v3;
  int v4;
  int *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  double *v12;
  double *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  uint64_t v18;
  float *v19;
  float v20;
  double *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  double *v26;
  uint64_t v27;
  uint64_t v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double *v38;
  double *v39;
  uint64_t v40;
  double v41;
  uint64_t i;
  double v43;
  uint64_t v44;
  double *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  double v49;
  uint64_t v50;
  double v51;
  uint64_t j;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  double *v56;
  uint64_t v57;
  double *k;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  double v64;
  uint64_t v65;
  uint64_t v66;
  double *v67;
  uint64_t v68;
  double *v69;
  double v70;
  uint64_t v71;
  double *v72;
  double *v73;
  double v74;
  double v75;
  double v76;
  uint64_t m;
  uint64_t v78;
  double *v79;
  double v80;
  uint64_t v81;
  double *v82;
  double *v83;
  double v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t n;
  float *v88;
  int *v89;
  uint64_t v90;
  int v91;
  double v92;
  float v93;

  if (*((_QWORD *)this + 9))
    return 0;
  v3 = *((int *)this + 6);
  if (*((int *)this + 3) < 1)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v5 = (int *)(*((_QWORD *)this + 2) + 28);
    v6 = *((unsigned int *)this + 3);
    do
    {
      v7 = *v5;
      v5 += 20;
      if (v7 > 0)
        ++v4;
      --v6;
    }
    while (v6);
  }
  *((_DWORD *)this + 11) = v4;
  if (v4 < (int)v3)
    return "Encountered underdetermined system while trying to invert a multi-component transform block so as to convert "
           "MCT output components into codestream components during compression.";
  if ((int)v3 < 1)
  {
LABEL_17:
    *((_QWORD *)this + 9) = operator new[]();
    if (*((_QWORD *)this + 13))
      kd_multi_matrix_block::prepare_for_inversion();
    v10 = operator new[]();
    *((_QWORD *)this + 13) = v10;
    v11 = (double *)(v10 + 8 * v4 * (int)v3);
    v12 = &v11[v4 * (int)v3];
    v13 = &v12[v4 * (int)v3];
    v14 = *((unsigned int *)this + 3);
    if ((int)v14 >= 1)
    {
      v15 = 0;
      v16 = *((_QWORD *)this + 2);
      v17 = (double *)v10;
      do
      {
        if (*(int *)(v16 + 80 * v15 + 28) >= 1)
        {
          v18 = *((unsigned int *)this + 6);
          if ((int)v18 >= 1)
          {
            v19 = (float *)(*((_QWORD *)this + 8) + 4 * (int)v18 * (int)v15);
            do
            {
              v20 = *v19++;
              *v17++ = v20;
              --v18;
            }
            while (v18);
          }
        }
        ++v15;
      }
      while (v15 != v14);
    }
    v21 = &v13[(v3 * v3)];
    if ((int)v3 >= 1)
    {
      v22 = 0;
      v23 = 0;
      v24 = 8 * v3;
      v25 = 0.0;
      v26 = &v12[v4 * (int)v3];
      do
      {
        v27 = 0;
        v28 = 0;
        do
        {
          v29 = 0.0;
          if (v4)
          {
            v30 = v4;
            v31 = v10;
            do
            {
              v29 = v29 + *(double *)(v31 + v22) * *(double *)(v31 + v27);
              v31 += v24;
              --v30;
            }
            while (v30);
          }
          *v26++ = v29;
          if (v29 > v25 && v23 == v28)
            v25 = v29;
          ++v28;
          v27 += 8;
        }
        while (v28 != v3);
        ++v23;
        v22 += 8;
      }
      while (v23 != v3);
      v33 = 0;
      v34 = v25 * 1.0e-13;
      v35 = 16 * v4 * (int)v3;
      v36 = v10 + v35 + 8 * v3;
      v37 = 1;
      v1 = "Near singular irreversible decorrelation transform block encountered in multi-component transform description"
           ".  This can prevent the compression process from proceeding if there are no other paths back from the MCT out"
           "put components to the codestream components.";
      v38 = &v11[v4 * (int)v3];
      v39 = v38;
      do
      {
        v40 = v33 + (int)v3 * (int)v33;
        v41 = v13[v40];
        if (v33)
        {
          for (i = 0; i != v33; ++i)
            v41 = v41 - v39[i] * v39[i];
          if (v41 < v34)
            goto LABEL_89;
          v43 = sqrt(v41);
          v12[v40] = v43;
          v44 = v33;
          v45 = v38;
          do
          {
            *v45 = 0.0;
            v45 = (double *)((char *)v45 + v24);
            --v44;
          }
          while (v44);
        }
        else
        {
          if (v41 < v34)
            goto LABEL_89;
          v43 = sqrt(v41);
          v12[v40] = v43;
        }
        v46 = v33 + 1;
        if (v33 + 1 < (unint64_t)v3)
        {
          v47 = v36;
          v48 = v37;
          v49 = 1.0 / v43;
          do
          {
            v50 = v33 + v48 * v3;
            v51 = v13[v50];
            if (v33)
            {
              for (j = 0; j != v33; ++j)
                v51 = v51 - *(double *)(v47 + 8 * j) * v39[j];
            }
            v12[v50] = v49 * v51;
            ++v48;
            v47 += v24;
          }
          while (v48 != v3);
        }
        ++v37;
        v39 = (double *)((char *)v39 + v24);
        ++v38;
        v36 += v24;
        ++v33;
      }
      while (v46 != v3);
      v53 = 0;
      v54 = v10 + v35 + 8 * v3;
      v55 = 1;
      v56 = &v13[(v3 * v3)];
      do
      {
        v57 = v53;
        for (k = v56; v57; --v57)
        {
          *k = 0.0;
          k = (double *)((char *)k + v24);
        }
        v21[((int)v3 + 1) * (int)v53] = 1.0 / v12[((int)v3 + 1) * (int)v53];
        v59 = v53 + 1;
        if (v53 + 1 < (unint64_t)v3)
        {
          v60 = v54;
          v61 = v55;
          do
          {
            v62 = 0;
            v63 = 0;
            v64 = 0.0;
            do
            {
              v64 = v64 + *(double *)((char *)v56 + v62) * *(double *)(v60 + 8 * v63++);
              v62 += v24;
            }
            while (v61 != v63);
            v21[v61 * v3 + v53] = -v64 / v12[v61 + (int)v3 * (int)v61];
            ++v61;
            v60 += v24;
          }
          while (v61 != v3);
        }
        ++v55;
        ++v56;
        v54 += v24;
        ++v53;
      }
      while (v59 != v3);
    }
    if (v4)
    {
      v65 = 0;
      v66 = 8 * v3;
      v67 = (double *)v10;
      do
      {
        if ((int)v3 >= 1)
        {
          v68 = 0;
          v69 = v21;
          do
          {
            v70 = 0.0;
            v71 = v3;
            v72 = v67;
            v73 = v69;
            do
            {
              v74 = *v72++;
              v75 = v74;
              v76 = *v73++;
              v70 = v70 + v75 * v76;
              --v71;
            }
            while (v71);
            v12[v68 + v65 * v3] = v70;
            ++v68;
            v69 = (double *)((char *)v69 + v66);
          }
          while (v68 != v3);
        }
        ++v65;
        v67 = (double *)((char *)v67 + v66);
      }
      while (v65 != v4);
      for (m = 0; m != v4; ++m)
      {
        if ((int)v3 >= 1)
        {
          v78 = 0;
          v79 = v21;
          do
          {
            v80 = 0.0;
            v81 = v3;
            v82 = v12;
            v83 = v79;
            do
            {
              v84 = *v82++;
              v80 = v80 + v84 * *v83;
              v83 = (double *)((char *)v83 + v66);
              --v81;
            }
            while (v81);
            v11[(m + v78++ * v4)] = v80;
            ++v79;
          }
          while (v78 != v3);
        }
        v12 = (double *)((char *)v12 + v66);
      }
    }
    v85 = *((unsigned int *)this + 6);
    if ((int)v85 >= 1)
    {
      v86 = 0;
      for (n = 0; n != v85; ++n)
      {
        if ((int)v14 >= 1)
        {
          v88 = (float *)(*((_QWORD *)this + 9) + v86);
          v89 = (int *)(*((_QWORD *)this + 2) + 28);
          v90 = v14;
          do
          {
            v91 = *v89;
            v89 += 20;
            if (v91 < 1)
            {
              v93 = 0.0;
            }
            else
            {
              v92 = *v11++;
              v93 = v92;
            }
            *v88++ = v93;
            --v90;
          }
          while (v90);
        }
        v86 += 4 * (int)v14;
      }
    }
    v1 = 0;
LABEL_89:
    MEMORY[0x18D761C18]();
    *((_QWORD *)this + 13) = 0;
  }
  else
  {
    v8 = *((_QWORD *)this + 4);
    v1 = "Encountered an irreversible decorrelation transform block which operates on reversible codestream sample data. "
         " While we allow such transforms to be processed during decompression, it is unreasonable to generate reversibly"
         " compressed component samples using an irreversible inverse multi-component transform during compression.  Kaka"
         "du will not invert this transform during compression.  This can prevent the compression process from proceeding"
         " if there are no other paths back from the MCT output components to the codestream components.";
    v9 = v3;
    while (!*(_QWORD *)v8 || !*(_BYTE *)(*(_QWORD *)v8 + 36))
    {
      v8 += 8;
      if (!--v9)
        goto LABEL_17;
    }
  }
  return v1;
}

void kd_multi_matrix_block::perform_inverse(kd_multi_matrix_block *this)
{
  uint64_t i;
  unsigned int *v3;
  uint64_t v4;
  float *v5;
  float v6;
  uint64_t v7;
  float *v8;
  int v9;
  uint64_t j;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  float v14;
  uint64_t v15;
  float *v16;
  float v17;
  _WORD *v18;
  int *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int16 *v24;
  int v25;
  uint64_t v26;
  int *v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;

  if (!*((_QWORD *)this + 9))
    kd_multi_matrix_block::perform_inverse();
  if (*((int *)this + 6) >= 1)
  {
    for (i = 0; i < *((int *)this + 6); ++i)
    {
      v3 = *(unsigned int **)(*((_QWORD *)this + 4) + 8 * i);
      if (v3)
      {
        v4 = *v3;
        if ((*((_BYTE *)v3 + 6) & 2) != 0 || (v5 = (float *)*((_QWORD *)v3 + 1)) == 0)
        {
          if (*((_QWORD *)this + 10))
          {
            if ((*((_BYTE *)v3 + 6) & 2) != 0)
              goto LABEL_24;
LABEL_26:
            v18 = 0;
          }
          else
          {
            kd_multi_matrix_block::create_short_inverse_coefficients((uint64_t)this);
            if ((*((_BYTE *)v3 + 6) & 2) == 0)
              goto LABEL_26;
LABEL_24:
            v18 = (_WORD *)*((_QWORD *)v3 + 1);
          }
          v19 = (int *)*((_QWORD *)this + 11);
          bzero(v19, 4 * (int)v4);
          v20 = *((_DWORD *)this + 3);
          if (v20 >= 1)
          {
            v21 = 0;
            v22 = *((_QWORD *)this + 2);
            do
            {
              if (*(int *)(v22 + 80 * v21 + 28) >= 1)
              {
                v23 = v22 + 80 * v21;
                v24 = (*(_BYTE *)(v23 + 6) & 2) != 0 ? *(__int16 **)(v23 + 8) : 0;
                if ((int)v4 >= 1)
                {
                  v25 = *(__int16 *)(*((_QWORD *)this + 10) + 2 * ((int)v21 + v20 * (int)i));
                  v26 = v4;
                  v27 = v19;
                  do
                  {
                    v28 = *v24++;
                    *v27++ += v28 * v25;
                    --v26;
                  }
                  while (v26);
                  v20 = *((_DWORD *)this + 3);
                }
              }
              ++v21;
            }
            while (v21 < v20);
          }
          if ((int)v4 >= 1)
          {
            v29 = *((_DWORD *)this + 24);
            v30 = (1 << v29 >> 1) - (vcvtmd_s64_f64((float)(*((float *)v3 + 12) * 8192.0) + 0.5) << v29);
            do
            {
              v31 = *v19++;
              *v18++ = (int)(v30 + v31) >> v29;
              --v4;
            }
            while (v4);
          }
          continue;
        }
        if ((int)v4 >= 1)
        {
          v6 = -*((float *)v3 + 12);
          v7 = *v3;
          v8 = (float *)*((_QWORD *)v3 + 1);
          do
          {
            *v8++ = v6;
            --v7;
          }
          while (v7);
        }
        v9 = *((_DWORD *)this + 3);
        if (v9 >= 1)
        {
          for (j = 0; j < v9; ++j)
          {
            v11 = *((_QWORD *)this + 2);
            if (*(int *)(v11 + 80 * j + 28) >= 1)
            {
              v12 = v11 + 80 * j;
              if ((*(_BYTE *)(v12 + 6) & 2) != 0)
                v13 = 0;
              else
                v13 = *(float **)(v12 + 8);
              if ((int)v4 >= 1)
              {
                v14 = *(float *)(*((_QWORD *)this + 9) + 4 * ((int)j + v9 * (int)i));
                v15 = v4;
                v16 = v5;
                do
                {
                  v17 = *v13++;
                  *v16 = *v16 + (float)(v14 * v17);
                  ++v16;
                  --v15;
                }
                while (v15);
                v9 = *((_DWORD *)this + 3);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t kd_multi_matrix_block::create_short_inverse_coefficients(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  float v4;
  uint64_t v5;
  float *v6;
  float v7;
  float v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float v20;
  int v21;

  if (!*(_QWORD *)(this + 80))
  {
    v1 = this;
    v2 = *(unsigned int *)(this + 24);
    if ((int)v2 < 1)
    {
      v4 = 0.00001;
    }
    else
    {
      v3 = 0;
      v4 = 0.00001;
      do
      {
        if (*(_QWORD *)(*(_QWORD *)(this + 32) + 8 * v3))
        {
          v5 = *(unsigned int *)(this + 12);
          if ((int)v5 >= 1)
          {
            v6 = (float *)(*(_QWORD *)(this + 72) + 4 * (int)v5 * (int)v3);
            do
            {
              v7 = *v6;
              if (*v6 <= v4)
              {
                if (v7 < (float)-v4)
                  v4 = -v7;
              }
              else
              {
                v4 = *v6;
              }
              ++v6;
              --v5;
            }
            while (v5);
          }
        }
        ++v3;
      }
      while (v3 != v2);
    }
    *(_QWORD *)(this + 80) = operator new[]();
    this = operator new[]();
    *(_QWORD *)(v1 + 88) = this;
    *(_DWORD *)(v1 + 96) = 0;
    v8 = 1.0;
    if (v4 <= 16383.0)
    {
      v9 = 0;
      do
      {
        ++v9;
        v8 = v8 + v8;
      }
      while ((float)(v4 * v8) <= 16383.0);
      *(_DWORD *)(v1 + 96) = v9;
    }
    v10 = *(unsigned int *)(v1 + 24);
    if ((int)v10 >= 1)
    {
      v11 = 0;
      v12 = 0;
      v13 = *(unsigned int *)(v1 + 12);
      v14 = *(_DWORD *)(v1 + 12);
      do
      {
        if (v14 >= 1)
        {
          v15 = 0;
          v16 = *(_QWORD *)(*(_QWORD *)(v1 + 32) + 8 * v12);
          this = *(_QWORD *)(v1 + 80);
          v17 = v13;
          v18 = v11;
          do
          {
            if (v16)
            {
              v19 = v12 * (int)v13 + v15;
              v20 = v8 * *(float *)(*(_QWORD *)(v1 + 72) + 4 * v18);
            }
            else
            {
              v20 = 0.0;
              v19 = v18;
            }
            v21 = vcvtmd_s64_f64(v20 + 0.5);
            if (v21 <= -32768)
              v21 = -32768;
            if (v21 >= 0x7FFF)
              LOWORD(v21) = 0x7FFF;
            *(_WORD *)(this + 2 * v19) = v21;
            ++v15;
            ++v18;
            --v17;
          }
          while (v17);
        }
        ++v12;
        v11 += (int)v13;
      }
      while (v12 != v10);
    }
  }
  return this;
}

uint64_t kd_multi_rxform_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, uint64_t a7, uint64_t a8, kd_multi_transform *a9)
{
  unint64_t scratch_ints;
  int *v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  uint64_t result;
  char v23;
  int *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t i;
  uint64_t v33;
  int v34[2];
  int v35;
  int v36;
  uint64_t *v37;

  v37 = a4;
  v35 = a6;
  v36 = a5;
  if (a5 < a6)
    kd_multi_rxform_block::initialize();
  scratch_ints = kd_multi_transform::get_scratch_ints(a9, 4 * a5);
  v16 = (int *)(scratch_ints + 4 * a5);
  v17 = &v16[a5];
  *(_QWORD *)v34 = 0;
  kdu_tile::get_mct_block_info(&v37, a2, a3, (unsigned int *)&v34[1], v34, &v36, &v35, scratch_ints, v16, 0, v17, 0);
  if (*(_QWORD *)v34 != __PAIR64__(*(_DWORD *)a7, *(_DWORD *)a8))
    kd_multi_rxform_block::initialize();
  *(_DWORD *)(a1 + 24) = a5;
  *(_DWORD *)(a1 + 12) = a5;
  is_mul_ok(a5, 0x50uLL);
  v18 = operator new[]();
  if (a5)
  {
    v19 = v18;
    do
    {
      *(_DWORD *)v19 = 0;
      *(_QWORD *)(v19 + 14) = 0;
      *(_QWORD *)(v19 + 6) = 0;
      *(_WORD *)(v19 + 22) = 0;
      *(_DWORD *)(v19 + 24) = -1;
      *(_QWORD *)(v19 + 28) = 0;
      *(_QWORD *)(v19 + 44) = 0;
      *(_QWORD *)(v19 + 36) = 0;
      *(_QWORD *)(v19 + 56) = 0;
      *(_QWORD *)(v19 + 64) = 0;
      *(_DWORD *)(v19 + 72) = -1;
      v19 += 80;
    }
    while (v19 != v18 + 80 * a5);
  }
  *(_QWORD *)(a1 + 16) = v18;
  *(_QWORD *)(a1 + 32) = operator new[]();
  v20 = (a5 + a5 * a5);
  v21 = (int *)operator new[]();
  *(_QWORD *)(a1 + 64) = v21;
  result = kdu_tile::get_mct_rxform_info((kdu_tile *)&v37, a2, a3, v21, &v17[a5]);
  if ((int)v20 < 1)
  {
    v23 = 0;
  }
  else
  {
    v23 = 0;
    v24 = *(int **)(a1 + 64);
    do
    {
      v25 = *v24++;
      v23 |= (v25 - 0x8000) < 0xFFFF0001;
      --v20;
    }
    while (v20);
  }
  if (a5 >= 1)
  {
    v26 = 0;
    v27 = a5;
    v28 = *(_QWORD *)(a1 + 32);
    do
    {
      *(_QWORD *)(v28 + 8 * v26) = *(_QWORD *)(*(_QWORD *)(a7 + 8) + 8 * *(int *)(scratch_ints + 4 * v26));
      v28 = *(_QWORD *)(a1 + 32);
      v29 = *(_QWORD *)(v28 + 8 * v26);
      if (v29)
      {
        ++*(_DWORD *)(v29 + 28);
        *(_BYTE *)(v29 + 36) = 1;
        if ((v23 & 1) != 0)
          *(_BYTE *)(v29 + 38) = 1;
      }
      ++v26;
    }
    while (a5 != v26);
    v30 = v23 & 1;
    v31 = *(_QWORD *)(a1 + 16) + 36;
    do
    {
      *(_QWORD *)(v31 + 28) = a1;
      *(_BYTE *)v31 = 1;
      *(_BYTE *)(v31 + 2) = v30;
      v31 += 80;
      --v27;
    }
    while (v27);
  }
  if (v35 >= 1)
  {
    for (i = 0; i < v35; *(_DWORD *)(v33 + 44) = v17[i++])
    {
      v33 = *(_QWORD *)(a1 + 16) + 80 * v17[a5 + i];
      *(_QWORD *)(*(_QWORD *)(a8 + 8) + 8 * v16[i]) = v33;
    }
  }
  return result;
}

const char *kd_multi_rxform_block::prepare_for_inversion(kd_multi_rxform_block *this)
{
  int v1;
  int *v2;
  const char *v3;
  uint64_t v4;
  int v5;

  v1 = *((_DWORD *)this + 3);
  if (v1 < 1)
  {
LABEL_5:
    v3 = 0;
    *((_DWORD *)this + 11) = v1;
  }
  else
  {
    v2 = (int *)(*((_QWORD *)this + 2) + 28);
    v3 = "Reversible decorrelation transform block cannot be inverted unless all of its outputs can be computed by downst"
         "ream transform blocks, or by the application supplying them.";
    v4 = *((unsigned int *)this + 3);
    while (1)
    {
      v5 = *v2;
      v2 += 20;
      if (v5 < 1)
        break;
      if (!--v4)
        goto LABEL_5;
    }
  }
  return v3;
}

void kd_multi_rxform_block::perform_transform(kd_multi_rxform_block *this)
{
  uint64_t v1;
  uint64_t i;
  kd_multi_line *v4;
  kd_multi_line *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v15;
  char v16;
  int *v17;
  uint64_t v18;
  char v19;
  uint64_t m;
  int v21;
  uint64_t v22;
  int *v23;
  _DWORD *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t j;
  int v30;
  uint64_t v31;
  __int16 *v32;
  _DWORD *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t k;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  _OWORD v42[2];
  uint64_t v43;
  char v44[16];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v1 = *((unsigned int *)this + 3);
  if (*((_DWORD *)this + 6) != (_DWORD)v1)
    kd_multi_rxform_block::perform_transform();
  if ((int)v1 >= 1)
  {
    for (i = 0; i != v1; ++i)
    {
      v4 = (kd_multi_line *)(*((_QWORD *)this + 2) + 80 * i);
      v5 = *(kd_multi_line **)(*((_QWORD *)this + 4) + 8 * i);
      if (v5)
        kd_multi_line::copy((uint64_t)v4, v5, 0, 0.0);
      else
        kd_multi_line::reset(v4, 0, 0.0);
    }
  }
  if ((v1 & 0x80000000) == 0)
  {
    v6 = 0;
    v7 = (int)v1 + 1;
    while (1)
    {
      if (v6 == v1)
        v8 = -1;
      else
        v8 = ~(_DWORD)v6;
      v9 = (v1 + v8);
      v10 = (unsigned int *)(*((_QWORD *)this + 2) + 80 * (int)v9);
      v41 = *v10;
      v11 = *v10;
      if (!*((_QWORD *)this + 9))
      {
        v12 = *((_QWORD *)this + 2) + 80 * (int)v9;
        *((_QWORD *)this + 9) = operator new[]();
        v10 = (unsigned int *)v12;
      }
      v13 = *(_DWORD *)(*((_QWORD *)this + 8) + 4 * (v6 + (int)v9 * (int)v7));
      if (v13 < 0 && v6 == v1)
        v15 = -v13;
      else
        v15 = *(_DWORD *)(*((_QWORD *)this + 8) + 4 * (v6 + (int)v9 * (int)v7));
      v16 = -1;
      do
        ++v16;
      while (1 << v16 < v15);
      if (1 << v16 != v15)
      {
        v43 = 0;
        memset(v42, 0, sizeof(v42));
        kdu_error::kdu_error((kdu_error *)v42, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v42[0] + 16))(v42, "Multi-component reversible decorrelation transforms must have exact positive powers of 2 for the divisors which are used to scale and round the update terms.  The offending divisor is ");
        v47 = 0u;
        v48 = 0u;
        v45 = 0u;
        v46 = 0u;
        *(_OWORD *)v44 = 0u;
        if (BYTE8(v42[0]))
          sprintf(v44, "%x");
        else
          sprintf(v44, "%d");
        (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v42[0] + 16))(v42, v44);
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v42[0] + 16))(v42, ".");
        kdu_error::~kdu_error((kdu_error *)v42);
      }
      if ((int)v11 >= 1)
      {
        v17 = (int *)*((_QWORD *)this + 9);
        v18 = v11;
        do
        {
          *v17++ = v15 >> 1;
          --v18;
        }
        while (v18);
      }
      v19 = *((_BYTE *)v10 + 6);
      if ((v19 & 2) != 0 || !*((_QWORD *)v10 + 1))
      {
        if ((_DWORD)v1)
        {
          for (j = 0; j != v1; ++j)
          {
            if (j != v9)
            {
              v30 = *(_DWORD *)(*((_QWORD *)this + 8) + 4 * (v6 + j * v7));
              if (v30)
              {
                v31 = *((_QWORD *)this + 2) + 80 * j;
                v32 = (*(_BYTE *)(v31 + 6) & 2) != 0 ? *(__int16 **)(v31 + 8) : 0;
                if ((int)v11 >= 1)
                {
                  v33 = (_DWORD *)*((_QWORD *)this + 9);
                  v34 = v11;
                  do
                  {
                    v35 = *v32++;
                    *v33++ += v30 * v35;
                    --v34;
                  }
                  while (v34);
                }
              }
            }
          }
        }
        if ((v19 & 2) != 0)
        {
          v36 = *((_QWORD *)v10 + 1);
          if (v13 < 0)
          {
LABEL_67:
            if (v6 != v1)
              kd_multi_rxform_block::perform_transform();
            if ((int)v11 >= 1)
            {
              v38 = 0;
              do
              {
                *(_WORD *)(v36 + 2 * v38) = (*(int *)(*((_QWORD *)this + 9) + 4 * v38) >> v16)
                                          - *(_WORD *)(v36 + 2 * v38);
                ++v38;
              }
              while (v41 != v38);
            }
            goto LABEL_76;
          }
        }
        else
        {
          v36 = 0;
          if (v13 < 0)
            goto LABEL_67;
        }
        if ((int)v11 >= 1)
        {
          for (k = 0; k != v11; ++k)
            *(_WORD *)(v36 + 2 * k) -= *(int *)(*((_QWORD *)this + 9) + 4 * k) >> v16;
        }
      }
      else
      {
        if ((_DWORD)v1)
        {
          for (m = 0; m != v1; ++m)
          {
            if (m != v9)
            {
              v21 = *(_DWORD *)(*((_QWORD *)this + 8) + 4 * (v6 + m * v7));
              if (v21)
              {
                v22 = *((_QWORD *)this + 2) + 80 * m;
                v23 = (*(_BYTE *)(v22 + 6) & 2) != 0 ? 0 : *(int **)(v22 + 8);
                if ((int)v11 >= 1)
                {
                  v24 = (_DWORD *)*((_QWORD *)this + 9);
                  v25 = v11;
                  do
                  {
                    v26 = *v23++;
                    *v24++ += v26 * v21;
                    --v25;
                  }
                  while (v25);
                }
              }
            }
          }
        }
        v27 = *((_QWORD *)v10 + 1);
        if (v13 < 0)
        {
          if (v6 != v1)
            kd_multi_rxform_block::perform_transform();
          if ((int)v11 >= 1)
          {
            v39 = 0;
            do
            {
              *(_DWORD *)(v27 + v39) = (*(int *)(*((_QWORD *)this + 9) + v39) >> v16) - *(_DWORD *)(v27 + v39);
              v39 += 4;
            }
            while (4 * v11 != v39);
          }
        }
        else if ((int)v11 >= 1)
        {
          v28 = 0;
          do
          {
            *(_DWORD *)(v27 + v28) -= *(int *)(*((_QWORD *)this + 9) + v28) >> v16;
            v28 += 4;
          }
          while (4 * v11 != v28);
        }
      }
LABEL_76:
      if (++v6 == v1 + 1)
      {
        if ((int)v1 >= 1)
        {
          v40 = 0;
          do
          {
            kd_multi_line::apply_offset(*((_QWORD *)this + 2) + v40, *(_DWORD *)(*((_QWORD *)this + 2) + v40 + 44), 0.0);
            v40 += 80;
          }
          while (80 * v1 != v40);
        }
        return;
      }
    }
  }
}

void sub_187F71ABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F71AC8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_multi_rxform_block::perform_inverse(uint64_t this)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v11;
  char v12;
  int *v13;
  uint64_t v14;
  char v15;
  uint64_t i;
  int v17;
  uint64_t v18;
  int *v19;
  _DWORD *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t j;
  int v26;
  uint64_t v27;
  __int16 *v28;
  _DWORD *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t k;
  uint64_t v34;
  uint64_t v35;
  uint64_t m;
  int v38;
  _OWORD v39[2];
  uint64_t v40;
  char v41[16];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v1 = *(unsigned int *)(this + 12);
  if ((v1 & 0x80000000) != 0)
    return this;
  v2 = (_QWORD *)this;
  v3 = v1 + 1;
  v4 = *(unsigned int *)(this + 12);
  do
  {
    v5 = (v1 + ~((int)v4 % (int)v1));
    v6 = (unsigned int *)(v2[2] + 80 * (int)v5);
    v38 = *v6;
    v7 = *v6;
    if (!v2[9])
    {
      v8 = v2[2] + 80 * (int)v5;
      this = operator new[]();
      v2[9] = this;
      v6 = (unsigned int *)v8;
    }
    v9 = *(_DWORD *)(v2[8] + 4 * (v4 + (int)v5 * (int)v3));
    if (v9 < 0 && v4 == v1)
      v11 = -v9;
    else
      v11 = *(_DWORD *)(v2[8] + 4 * (v4 + (int)v5 * (int)v3));
    v12 = -1;
    do
      ++v12;
    while (1 << v12 < v11);
    if (1 << v12 != v11)
    {
      v40 = 0;
      memset(v39, 0, sizeof(v39));
      kdu_error::kdu_error((kdu_error *)v39, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v39[0] + 16))(v39, "Multi-component reversible decorrelation transforms must have exact positive powers of 2 for the divisors which are used to scale and round the update terms.  The offending divisor is ");
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      *(_OWORD *)v41 = 0u;
      if (BYTE8(v39[0]))
        sprintf(v41, "%x");
      else
        sprintf(v41, "%d");
      (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v39[0] + 16))(v39, v41);
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v39[0] + 16))(v39, ".");
      kdu_error::~kdu_error((kdu_error *)v39);
    }
    if ((int)v7 >= 1)
    {
      v13 = (int *)v2[9];
      v14 = v7;
      do
      {
        *v13++ = v11 >> 1;
        --v14;
      }
      while (v14);
    }
    v15 = *((_BYTE *)v6 + 6);
    if ((v15 & 2) == 0 && *((_QWORD *)v6 + 1))
    {
      if ((_DWORD)v1)
      {
        for (i = 0; i != v1; ++i)
        {
          if (i != v5)
          {
            v17 = *(_DWORD *)(v2[8] + 4 * (v4 + i * v3));
            if (v17)
            {
              v18 = v2[2] + 80 * i;
              v19 = (*(_BYTE *)(v18 + 6) & 2) != 0 ? 0 : *(int **)(v18 + 8);
              if ((int)v7 >= 1)
              {
                v20 = (_DWORD *)v2[9];
                v21 = v7;
                do
                {
                  v22 = *v19++;
                  *v20++ += v22 * v17;
                  --v21;
                }
                while (v21);
              }
            }
          }
        }
      }
      v23 = *((_QWORD *)v6 + 1);
      if (v9 < 0)
      {
        if (v4 != v1)
          kd_multi_rxform_block::perform_inverse();
        if ((int)v7 >= 1)
        {
          v35 = 0;
          do
          {
            *(_DWORD *)(v23 + v35) = (*(int *)(v2[9] + v35) >> v12) - *(_DWORD *)(v23 + v35);
            v35 += 4;
          }
          while (4 * v7 != v35);
        }
      }
      else if ((int)v7 >= 1)
      {
        v24 = 0;
        do
        {
          *(_DWORD *)(v23 + v24) += *(int *)(v2[9] + v24) >> v12;
          v24 += 4;
        }
        while (4 * v7 != v24);
      }
      continue;
    }
    if ((_DWORD)v1)
    {
      for (j = 0; j != v1; ++j)
      {
        if (j != v5)
        {
          v26 = *(_DWORD *)(v2[8] + 4 * (v4 + j * v3));
          if (v26)
          {
            v27 = v2[2] + 80 * j;
            v28 = (*(_BYTE *)(v27 + 6) & 2) != 0 ? *(__int16 **)(v27 + 8) : 0;
            if ((int)v7 >= 1)
            {
              v29 = (_DWORD *)v2[9];
              v30 = v7;
              do
              {
                v31 = *v28++;
                *v29++ += v26 * v31;
                --v30;
              }
              while (v30);
            }
          }
        }
      }
    }
    if ((v15 & 2) != 0)
    {
      v32 = *((_QWORD *)v6 + 1);
      if ((v9 & 0x80000000) == 0)
      {
LABEL_52:
        if ((int)v7 >= 1)
        {
          for (k = 0; k != v7; ++k)
            *(_WORD *)(v32 + 2 * k) += *(int *)(v2[9] + 4 * k) >> v12;
        }
        continue;
      }
    }
    else
    {
      v32 = 0;
      if ((v9 & 0x80000000) == 0)
        goto LABEL_52;
    }
    if (v4 != v1)
      kd_multi_rxform_block::perform_inverse();
    if ((int)v7 >= 1)
    {
      v34 = 0;
      do
      {
        *(_WORD *)(v32 + 2 * v34) = (*(int *)(v2[9] + 4 * v34) >> v12) - *(_WORD *)(v32 + 2 * v34);
        ++v34;
      }
      while (v38 != v34);
    }
  }
  while (v4-- > 0);
  if ((int)v1 >= 1)
  {
    for (m = 0; m != v1; ++m)
    {
      this = *(_QWORD *)(v2[4] + 8 * m);
      if (this)
        this = kd_multi_line::copy(this, (kd_multi_line *)(v2[2] + 80 * m), -*(_DWORD *)(this + 44), 0.0);
    }
  }
  return this;
}

void sub_187F71F28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F71F34()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kd_multi_dependency_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, _DWORD *a7, _DWORD *a8, kd_multi_transform *a9)
{
  unint64_t scratch_ints;
  int *v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  _DWORD *v32;
  _DWORD *v33;
  char v34;
  char v35;
  int *v36;
  uint64_t v37;
  int v38;
  int v39;
  unint64_t v40;
  int *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  int v57;
  unint64_t v58;
  _DWORD *v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  uint64_t *v66;

  v66 = a4;
  v64 = a6;
  v65 = a5;
  if (a5 < a6)
    kd_multi_dependency_block::initialize();
  scratch_ints = kd_multi_transform::get_scratch_ints(a9, 3 * a5);
  v16 = (int *)(scratch_ints + 4 * a5);
  v63 = 0;
  v58 = scratch_ints;
  kdu_tile::get_mct_block_info(&v66, a2, a3, (unsigned int *)&v63 + 1, (int *)&v63, &v65, &v64, scratch_ints, v16, 0, 0, 0);
  if (v63 != __PAIR64__(*a7, *a8))
    kd_multi_dependency_block::initialize();
  v61 = a2;
  v59 = a8;
  v17 = &v16[a5];
  *(_DWORD *)(a1 + 24) = a5;
  *(_DWORD *)(a1 + 12) = a5;
  is_mul_ok(a5, 0x50uLL);
  v18 = operator new[]();
  if (a5)
  {
    v19 = v18;
    do
    {
      *(_DWORD *)v19 = 0;
      *(_QWORD *)(v19 + 14) = 0;
      *(_QWORD *)(v19 + 6) = 0;
      *(_WORD *)(v19 + 22) = 0;
      *(_DWORD *)(v19 + 24) = -1;
      *(_QWORD *)(v19 + 28) = 0;
      *(_QWORD *)(v19 + 44) = 0;
      *(_QWORD *)(v19 + 36) = 0;
      *(_QWORD *)(v19 + 56) = 0;
      *(_QWORD *)(v19 + 64) = 0;
      *(_DWORD *)(v19 + 72) = -1;
      v19 += 80;
    }
    while (v19 != v18 + 80 * a5);
  }
  *(_QWORD *)(a1 + 16) = v18;
  v62 = 4 * a5;
  v20 = operator new[]();
  v21 = *(unsigned __int8 *)(a1 + 64);
  *(_QWORD *)(a1 + 32) = v20;
  v22 = a5 * a5;
  v23 = operator new[]();
  v57 = v21;
  v60 = (a5 * a5);
  if (!v21)
  {
    *(_QWORD *)(a1 + 88) = v23;
    v40 = operator new[]();
    *(_QWORD *)(a1 + 96) = v40;
    v41 = (int *)(*(_QWORD *)(a1 + 88) + 4 * (v22 - (a5 - 1) * a5 / 2));
    kdu_tile::get_mct_dependency_info((kdu_tile *)&v66, v61, a3, (BOOL *)(a1 + 64), *(_QWORD *)(a1 + 88) + 4 * (a5 * a5 - (a5 - 1) * a5 / 2), v40, 0, 0, &v16[a5]);
    if (*(_BYTE *)(a1 + 64))
      kd_multi_dependency_block::initialize();
    if (a5 >= 1)
    {
      v42 = 0;
      v43 = 0;
      do
      {
        if (v43)
        {
          v44 = 0;
          v45 = *(_QWORD *)(a1 + 88) + v42;
          do
          {
            v46 = *v41++;
            *(_DWORD *)(v45 + 4 * v44++) = v46;
          }
          while (v43 != v44);
        }
        if ((int)v43 < a5)
          bzero((void *)(*(_QWORD *)(a1 + 88) + 4 * (a5 + 1) * (int)v43), 4 * (a5 - 1 - v43) + 4);
        ++v43;
        v42 += v62;
      }
      while (v43 != a5);
    }
    if (v60 != ((uint64_t)v41 - *(_QWORD *)(a1 + 88)) >> 2)
      kd_multi_dependency_block::initialize();
    v34 = 0;
    v39 = 0;
    v33 = a7;
    v32 = v59;
    goto LABEL_38;
  }
  *(_QWORD *)(a1 + 72) = v23;
  v24 = operator new[]();
  *(_QWORD *)(a1 + 80) = v24;
  v25 = *(_QWORD *)(a1 + 72) + 4 * (v22 - (a5 + 1) * a5 / 2 + 1);
  kdu_tile::get_mct_dependency_info((kdu_tile *)&v66, v61, a3, (BOOL *)(a1 + 64), 0, 0, *(_QWORD *)(a1 + 72) + 4 * (a5 * a5 - (a5 + 1) * a5 / 2 + 1), v24, &v16[a5]);
  v56 = *(_BYTE *)(a1 + 64);
  if (!v56)
    kd_multi_dependency_block::initialize();
  v26 = *(_QWORD *)(a1 + 72);
  if (a5 >= 1)
  {
    v27 = 0;
    v28 = *(_QWORD *)(a1 + 72);
    do
    {
      if (v27)
      {
        v29 = 0;
        v25 += 4;
        do
        {
          *(_DWORD *)(v28 + 4 * v29++) = *(_DWORD *)(v25 - 4);
          v25 += 4;
        }
        while (v27 != v29);
        v30 = *(_DWORD *)(v25 - 4);
      }
      else
      {
        v30 = 1;
      }
      *(_DWORD *)(v26 + 4 * (v27 + (int)v27 * a5)) = v30;
      v31 = v27 + 1;
      if (v27 + 1 < a5)
        bzero((void *)(v26 + 4 * ((a5 + 1) * (int)v27 + 1)), 4 * (a5 - 2 - v27) + 4);
      v28 += v62;
      v27 = v31;
    }
    while (v31 != a5);
  }
  if (v60 != (v25 - v26) >> 2)
    kd_multi_dependency_block::initialize();
  v33 = a7;
  v32 = v59;
  v34 = v56;
  if (a5)
  {
    v35 = 0;
    v36 = *(int **)(a1 + 72);
    if (v60 <= 1)
      v37 = 1;
    else
      v37 = v60;
    do
    {
      v38 = *v36++;
      if ((v38 - 0x8000) < 0xFFFF0001)
        v35 = 1;
      --v37;
    }
    while (v37);
    v39 = v35 & 1;
LABEL_38:
    if (a5 >= 1)
    {
      v47 = 0;
      v48 = a5;
      v49 = *(_QWORD *)(a1 + 32);
      do
      {
        *(_QWORD *)(v49 + 8 * v47) = *(_QWORD *)(*((_QWORD *)v33 + 1) + 8 * *(int *)(v58 + 4 * v47));
        v49 = *(_QWORD *)(a1 + 32);
        v50 = *(_QWORD *)(v49 + 8 * v47);
        if (v50)
        {
          ++*(_DWORD *)(v50 + 28);
          if (v57)
            *(_BYTE *)(v50 + 36) = 1;
          if (v39)
            *(_BYTE *)(v50 + 38) = 1;
        }
        ++v47;
      }
      while (a5 != v47);
      v51 = *(_QWORD *)(a1 + 16) + 36;
      do
      {
        *(_QWORD *)(v51 + 28) = a1;
        *(_BYTE *)(v51 + 2) = v39;
        *(_BYTE *)v51 = v34;
        *(_BYTE *)(v51 + 1) = v34 ^ 1;
        v51 += 80;
        --v48;
      }
      while (v48);
    }
  }
  v52 = v64;
  if (v64 >= 1)
  {
    do
    {
      v53 = *v17++;
      v54 = *(_QWORD *)(a1 + 16) + 80 * v53;
      v55 = *v16++;
      *(_QWORD *)(*((_QWORD *)v32 + 1) + 8 * v55) = v54;
      --v52;
    }
    while (v52);
  }
}

const char *kd_multi_dependency_block::prepare_for_inversion(kd_multi_dependency_block *this)
{
  int v1;
  int *v2;
  const char *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v1 = *((_DWORD *)this + 3);
  if (v1 < 1)
  {
LABEL_5:
    v6 = *((unsigned int *)this + 6);
    if ((int)v6 < 1)
    {
LABEL_11:
      v3 = 0;
      *((_DWORD *)this + 11) = v1;
    }
    else
    {
      v7 = 0;
      v8 = 8 * v6;
      v3 = "Encountered an irreversible dependency transform block which operates on reversible codestream sample data.  "
           "While we allow such transforms to be processed during decompression, it is unreasonable to generate reversibl"
           "y compressed component samples using an irreversible inverse multi-component transform during compression.  K"
           "akadu will not invert this transform during compression.  This can prevent the compression process from proce"
           "eding if there are no other paths back from the MCT output components to the codestream components.";
      while (1)
      {
        if (!*((_BYTE *)this + 64))
        {
          v9 = *(_QWORD *)(*((_QWORD *)this + 4) + v7);
          if (v9)
          {
            if (*(_BYTE *)(v9 + 36))
              break;
          }
        }
        v7 += 8;
        if (v8 == v7)
          goto LABEL_11;
      }
    }
  }
  else
  {
    v2 = (int *)(*((_QWORD *)this + 2) + 28);
    v3 = "Dependency transform block cannot be inverted or partially inverted unless a contiguous prefix of the output co"
         "mponents can be computed by downstream transform blocks, or by the application supplying them.";
    v4 = *((unsigned int *)this + 3);
    while (1)
    {
      v5 = *v2;
      v2 += 20;
      if (v5 < 1)
        break;
      if (!--v4)
        goto LABEL_5;
    }
  }
  return v3;
}

uint64_t kd_multi_dependency_block::normalize_coefficients(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int *v12;
  int v13;
  _BOOL4 v14;
  float v15;
  float *v16;
  uint64_t v17;
  float v18;
  float *v19;
  uint64_t v20;
  _BYTE *v21;

  if (*(_BYTE *)(this + 64))
    return this;
  v1 = *(unsigned int *)(this + 12);
  if ((_DWORD)v1 != *(_DWORD *)(this + 24))
    kd_multi_dependency_block::normalize_coefficients();
  if ((int)v1 < 1)
    return this;
  v2 = 0;
  v3 = 0;
  v4 = *(_QWORD *)(this + 32);
  v5 = *(_QWORD *)(this + 16);
  v6 = 4 * v1;
  v7 = *(unsigned int *)(this + 12);
  for (i = 1; ; ++i)
  {
    v9 = *(_QWORD *)(v4 + 8 * v2);
    v10 = v5 + 80 * v2;
    v13 = *(_DWORD *)(v10 + 40);
    v12 = (int *)(v10 + 40);
    v11 = v13;
    if (v13)
      break;
    if (v9)
    {
      v11 = *(_DWORD *)(v9 + 40);
      *v12 = v11;
      v3 = 1;
      goto LABEL_11;
    }
    if (++v2 == v1)
      goto LABEL_24;
    v3 = 1;
LABEL_20:
    v7 += v1;
  }
  if (v9)
    v3 |= *(_DWORD *)(v9 + 40) == 0;
LABEL_11:
  v14 = *(_BYTE *)(v5 + 80 * v2 + 38) != 0;
  if (v11 >= 1)
  {
    v15 = (float)(1 << v11);
    if (v2 < v1 - 1)
    {
      v16 = (float *)(*(_QWORD *)(this + 88) + 4 * (v2 + v7));
      v17 = v1;
      do
      {
        *v16 = *v16 * v15;
        v16 = (float *)((char *)v16 + v6);
        --v17;
      }
      while (i != v17);
    }
    v18 = 1.0 / v15;
    if (v2)
    {
      v19 = (float *)(*(_QWORD *)(this + 88) + v6 * v2);
      v20 = v2;
      do
      {
        *v19 = v18 * *v19;
        ++v19;
        --v20;
      }
      while (v20);
    }
    *(float *)(*(_QWORD *)(this + 96) + 4 * v2) = v18
                                                                * *(float *)(*(_QWORD *)(this + 96)
                                                                           + 4 * v2);
  }
  v3 |= v14;
  if (++v2 != v1)
    goto LABEL_20;
  if ((v3 & 1) == 0)
    return this;
LABEL_24:
  v21 = (_BYTE *)(v5 + 38);
  do
  {
    *v21 = 1;
    if (*(_QWORD *)v4)
      *(_BYTE *)(*(_QWORD *)v4 + 38) = 1;
    v4 += 8;
    v21 += 80;
    --v1;
  }
  while (v1);
  return this;
}

void kd_multi_dependency_block::create_short_matrix(kd_multi_dependency_block *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  float v5;
  uint64_t i;
  uint64_t v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  if (!*((_QWORD *)this + 13) && !*((_BYTE *)this + 64))
  {
    v2 = *((unsigned int *)this + 3);
    if ((_DWORD)v2 != *((_DWORD *)this + 6))
      kd_multi_dependency_block::create_short_matrix();
    if ((int)v2 < 1)
    {
      v5 = 0.0;
    }
    else
    {
      v3 = 0;
      v4 = 0;
      v5 = 0.0;
      do
      {
        if (v4)
        {
          for (i = 0; i != v4; ++i)
          {
            v7 = *((_QWORD *)this + 11) + v3;
            v8 = *(float *)(v7 + 4 * i);
            if (v8 <= v5)
            {
              if (v8 < (float)-v5)
                v5 = -v8;
            }
            else
            {
              v5 = *(float *)(v7 + 4 * i);
            }
          }
        }
        ++v4;
        v3 += 4 * v2;
      }
      while (v4 != v2);
    }
    v9 = operator new[]();
    v10 = v9;
    *((_QWORD *)this + 13) = v9;
    *((_DWORD *)this + 28) = 0;
    v11 = 1.0;
    if (v5 <= 16383.0)
    {
      v12 = 0;
      do
      {
        ++v12;
        v11 = v11 + v11;
      }
      while ((float)(v5 * v11) <= 16383.0);
      *((_DWORD *)this + 28) = v12;
    }
    if ((int)v2 >= 1)
    {
      v13 = 0;
      v14 = v9;
      do
      {
        if (v13)
        {
          v15 = 0;
          v16 = *((_QWORD *)this + 11);
          do
          {
            v17 = vcvtmd_s64_f64((float)(v11 * *(float *)(v16 + 4 * v15)) + 0.5);
            if (v17 <= -32768)
              v17 = -32768;
            if (v17 >= 0x7FFF)
              LOWORD(v17) = 0x7FFF;
            *(_WORD *)(v14 + 2 * v15++) = v17;
          }
          while (v13 != v15);
        }
        if ((int)v2 > (int)v13)
          bzero((void *)(v10 + 2 * ((int)v2 + 1) * (int)v13), 2 * (v2 + ~(_DWORD)v13) + 2);
        ++v13;
        v14 += 2 * v2;
      }
      while (v13 != v2);
    }
  }
}

uint64_t kd_multi_dependency_block::perform_transform(uint64_t this)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  kd_multi_line *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  char v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  BOOL v26;
  uint64_t v27;
  _DWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int16 *v34;
  int v35;
  BOOL v36;
  uint64_t v37;
  _DWORD *v38;
  int v39;
  uint64_t j;
  float *v41;
  uint64_t i;
  uint64_t v43;
  float *v44;
  float v45;
  uint64_t v47;
  float *v48;
  float v49;
  uint64_t v50;
  int v51;
  int *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  __int16 *v59;
  int v60;
  BOOL v61;
  _DWORD *v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  _OWORD v69[2];
  uint64_t v70;
  char v71[16];
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v1 = *(_DWORD *)(this + 12);
  if (*(_DWORD *)(this + 24) != v1)
    kd_multi_dependency_block::perform_transform();
  if (v1 >= 1)
  {
    v2 = this;
    v3 = 0;
    v68 = *(unsigned int *)(this + 12);
    while (1)
    {
      if (v3 <= 1)
        v4 = 1;
      else
        v4 = v3;
      v5 = (int *)(*(_QWORD *)(v2 + 16) + 80 * v3);
      v6 = *(kd_multi_line **)(*(_QWORD *)(v2 + 32) + 8 * v3);
      v7 = *v5;
      v8 = *v5;
      if (!*(_BYTE *)(v2 + 64))
      {
        v10 = *(float *)(*(_QWORD *)(v2 + 96) + 4 * v3);
        if (v6)
          kd_multi_line::copy(*(_QWORD *)(v2 + 16) + 80 * v3, v6, 0, v10);
        else
          kd_multi_line::reset((kd_multi_line *)(*(_QWORD *)(v2 + 16) + 80 * v3), 0, v10);
        v11 = v68;
        if (v3)
        {
          if ((*((_BYTE *)v5 + 6) & 2) != 0 || (v41 = (float *)*((_QWORD *)v5 + 1)) == 0)
          {
            if (!*(_QWORD *)(v2 + 120))
            {
              *(_QWORD *)(v2 + 120) = operator new[]();
              v11 = v68;
            }
            if (!*(_QWORD *)(v2 + 104))
            {
              kd_multi_dependency_block::create_short_matrix((kd_multi_dependency_block *)v2);
              v11 = v68;
            }
            if ((*((_BYTE *)v5 + 6) & 2) != 0)
              v50 = *((_QWORD *)v5 + 1);
            else
              v50 = 0;
            v51 = *(_DWORD *)(v2 + 112);
            if ((int)v8 >= 1)
            {
              v52 = *(int **)(v2 + 120);
              v53 = v8;
              do
              {
                *v52++ = 1 << v51 >> 1;
                --v53;
              }
              while (v53);
            }
            v54 = 0;
            v55 = *(_QWORD *)(v2 + 16);
            v56 = *(_QWORD *)(v2 + 104);
            v57 = v3 * v11;
            do
            {
              v58 = v55 + 80 * v54;
              if ((*(_BYTE *)(v58 + 6) & 2) != 0)
                v59 = *(__int16 **)(v58 + 8);
              else
                v59 = 0;
              v60 = *(__int16 *)(v56 + 2 * (v54 + v57));
              if (*(_WORD *)(v56 + 2 * (v54 + v57)))
                v61 = v7 < 1;
              else
                v61 = 1;
              if (!v61)
              {
                v62 = *(_DWORD **)(v2 + 120);
                v63 = v7;
                do
                {
                  v64 = *v59++;
                  *v62++ += v64 * v60;
                  --v63;
                }
                while (v63);
              }
              ++v54;
            }
            while (v54 != v4);
            if ((int)v8 >= 1)
            {
              v65 = 0;
              do
              {
                *(_WORD *)(v50 + 2 * v65) += *(int *)(*(_QWORD *)(v2 + 120) + 4 * v65) >> v51;
                ++v65;
              }
              while (v7 != v65);
            }
          }
          else
          {
            for (i = 0; i != v3; ++i)
            {
              v43 = *(_QWORD *)(v2 + 16) + 80 * i;
              if ((*(_BYTE *)(v43 + 6) & 2) != 0)
                v44 = 0;
              else
                v44 = *(float **)(v43 + 8);
              v45 = *(float *)(*(_QWORD *)(v2 + 88) + 4 * (i + v3 * v68));
              if (v45 != 0.0 && (int)v8 >= 1)
              {
                v47 = v8;
                v48 = v41;
                do
                {
                  v49 = *v44++;
                  *v48 = *v48 + (float)(v49 * v45);
                  ++v48;
                  --v47;
                }
                while (v47);
              }
            }
          }
        }
        goto LABEL_99;
      }
      v9 = *(_QWORD *)(v2 + 80);
      if (v6)
        kd_multi_line::copy(*(_QWORD *)(v2 + 16) + 80 * v3, v6, *(_DWORD *)(v9 + 4 * v3), 0.0);
      else
        kd_multi_line::reset((kd_multi_line *)(*(_QWORD *)(v2 + 16) + 80 * v3), *(_DWORD *)(v9 + 4 * v3), 0.0);
      v11 = v68;
      if (v3)
      {
        v12 = v3 * v68;
        v13 = *(_DWORD *)(*(_QWORD *)(v2 + 72) + 4 * (v3 + (int)v68 * (int)v3));
        v14 = -1;
        do
          v15 = 1 << ++v14;
        while (1 << v14 < v13);
        if (v15 != v13)
        {
          v70 = 0;
          memset(v69, 0, sizeof(v69));
          kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v69[0] + 16))(v69, "Multi-component reversible dependency transforms must have exact positive powers of 2 on the diagonal of their triangular coefficient matrix; these are the divisors used to scale and round the prediction terms.  The "
            "offending divisor is ");
          v74 = 0u;
          v75 = 0u;
          v72 = 0u;
          v73 = 0u;
          *(_OWORD *)v71 = 0u;
          if (BYTE8(v69[0]))
            sprintf(v71, "%x");
          else
            sprintf(v71, "%d");
          (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v69[0] + 16))(v69, v71);
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v69[0] + 16))(v69, ".");
          kdu_error::~kdu_error((kdu_error *)v69);
        }
        v16 = *(_QWORD *)(v2 + 120);
        if (!v16)
        {
          v16 = operator new[]();
          *(_QWORD *)(v2 + 120) = v16;
        }
        if ((int)v8 >= 1)
        {
          v17 = v8;
          v18 = (int *)v16;
          do
          {
            *v18++ = v15 >> 1;
            --v17;
          }
          while (v17);
        }
        v19 = *((_QWORD *)v5 + 1);
        v11 = v68;
        if ((*((_BYTE *)v5 + 6) & 2) != 0)
        {
          v20 = *(_QWORD *)(v2 + 72);
LABEL_44:
          v31 = 0;
          v32 = *(_QWORD *)(v2 + 16);
          do
          {
            v33 = v32 + 80 * v31;
            if ((*(_BYTE *)(v33 + 6) & 2) != 0)
              v34 = *(__int16 **)(v33 + 8);
            else
              v34 = 0;
            v35 = *(_DWORD *)(v20 + 4 * (v31 + v12));
            if (v35)
              v36 = (int)v8 < 1;
            else
              v36 = 1;
            if (!v36)
            {
              v37 = v8;
              v38 = (_DWORD *)v16;
              do
              {
                v39 = *v34++;
                *v38++ += v35 * v39;
                --v37;
              }
              while (v37);
            }
            ++v31;
          }
          while (v31 != v4);
          if ((int)v8 >= 1)
          {
            for (j = 0; j != v8; ++j)
              *(_WORD *)(v19 + 2 * j) += *(int *)(*(_QWORD *)(v2 + 120) + 4 * j) >> v14;
          }
          goto LABEL_99;
        }
        v20 = *(_QWORD *)(v2 + 72);
        if (!v19)
          goto LABEL_44;
        v21 = 0;
        v22 = *(_QWORD *)(v2 + 16);
        do
        {
          v23 = v22 + 80 * v21;
          if ((*(_BYTE *)(v23 + 6) & 2) != 0)
            v24 = 0;
          else
            v24 = *(int **)(v23 + 8);
          v25 = *(_DWORD *)(v20 + 4 * (v21 + v12));
          if (v25)
            v26 = (int)v8 < 1;
          else
            v26 = 1;
          if (!v26)
          {
            v27 = v8;
            v28 = (_DWORD *)v16;
            do
            {
              v29 = *v24++;
              *v28++ += v29 * v25;
              --v27;
            }
            while (v27);
          }
          ++v21;
        }
        while (v21 != v4);
        if ((int)v8 >= 1)
        {
          v30 = 0;
          do
          {
            *(_DWORD *)(v19 + v30) += *(int *)(*(_QWORD *)(v2 + 120) + v30) >> v14;
            v30 += 4;
          }
          while (4 * v8 != v30);
        }
      }
LABEL_99:
      if (++v3 == v11)
      {
        v66 = 0;
        v67 = 80 * v11;
        do
        {
          this = kd_multi_line::apply_offset(*(_QWORD *)(v2 + 16) + v66, *(_DWORD *)(*(_QWORD *)(v2 + 16) + v66 + 44), *(float *)(*(_QWORD *)(v2 + 16) + v66 + 48));
          v66 += 80;
        }
        while (v67 != v66);
        return this;
      }
    }
  }
  return this;
}

void sub_187F72D9C(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F72DA8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

int *kd_multi_dependency_block::perform_inverse(int *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char v12;
  int v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;
  int *v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  int *v25;
  int v26;
  uint64_t v27;
  float *v28;
  uint64_t m;
  uint64_t v30;
  float *v31;
  float v32;
  uint64_t v34;
  float *v35;
  float v36;
  uint64_t v37;
  uint64_t j;
  uint64_t v39;
  __int16 *v40;
  int v41;
  BOOL v42;
  uint64_t v43;
  int *v44;
  int v45;
  uint64_t k;
  uint64_t v47;
  int v48;
  int *v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  __int16 *v57;
  int v58;
  BOOL v59;
  uint64_t v60;
  int *v61;
  int v62;
  uint64_t v63;
  int *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _OWORD v68[2];
  uint64_t v69;
  char v70[16];
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v1 = this[3];
  if (this[6] != (_DWORD)v1)
    kd_multi_dependency_block::perform_inverse();
  if ((int)v1 >= 1)
  {
    v2 = (uint64_t)this;
    v3 = 0;
    v67 = this[3];
    do
    {
      if (v3 <= 1)
        v4 = 1;
      else
        v4 = v3;
      v5 = *(_QWORD *)(v2 + 16);
      v6 = (int *)(v5 + 80 * v3);
      v7 = *(_QWORD *)(*(_QWORD *)(v2 + 32) + 8 * v3);
      v8 = *v6;
      v9 = *v6;
      if (*(_BYTE *)(v2 + 64))
      {
        if (!v3)
          goto LABEL_72;
        v64 = (int *)(v5 + 80 * v3);
        v65 = *(_QWORD *)(*(_QWORD *)(v2 + 32) + 8 * v3);
        v10 = v3 * v1;
        v11 = *(_DWORD *)(*(_QWORD *)(v2 + 72) + 4 * (v3 + (int)v1 * (int)v3));
        v12 = -1;
        do
          v13 = 1 << ++v12;
        while (1 << v12 < v11);
        if (v13 != v11)
        {
          v69 = 0;
          memset(v68, 0, sizeof(v68));
          kdu_error::kdu_error((kdu_error *)v68, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v68[0] + 16))(v68, "Multi-component reversible dependency transforms must have exact positive powers of 2 on the diagonal of their triangular coefficient matrix; these are the divisors used to scale and round the prediction terms.  The "
            "offending divisor is ");
          v73 = 0u;
          v74 = 0u;
          v71 = 0u;
          v72 = 0u;
          *(_OWORD *)v70 = 0u;
          if (BYTE8(v68[0]))
            sprintf(v70, "%x");
          else
            sprintf(v70, "%d");
          (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v68[0] + 16))(v68, v70);
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v68[0] + 16))(v68, ".");
          kdu_error::~kdu_error((kdu_error *)v68);
        }
        this = *(int **)(v2 + 120);
        if (!this)
        {
          this = (int *)operator new[]();
          *(_QWORD *)(v2 + 120) = this;
        }
        if ((int)v9 >= 1)
        {
          v14 = v9;
          v15 = this;
          do
          {
            *v15++ = v13 >> 1;
            --v14;
          }
          while (v14);
        }
        v6 = v64;
        v7 = v65;
        v16 = *((_QWORD *)v64 + 1);
        if ((*((_BYTE *)v64 + 6) & 2) != 0)
        {
          v17 = *(_QWORD *)(v2 + 16);
          v18 = *(_QWORD *)(v2 + 72);
          v1 = v67;
        }
        else
        {
          v17 = *(_QWORD *)(v2 + 16);
          v18 = *(_QWORD *)(v2 + 72);
          v1 = v67;
          if (v16)
          {
            for (i = 0; i != v4; ++i)
            {
              v20 = v17 + 80 * i;
              if ((*(_BYTE *)(v20 + 6) & 2) != 0)
                v21 = 0;
              else
                v21 = *(int **)(v20 + 8);
              v22 = *(_DWORD *)(v18 + 4 * (i + v10));
              if (v22)
                v23 = (int)v9 < 1;
              else
                v23 = 1;
              if (!v23)
              {
                v24 = v9;
                v25 = this;
                do
                {
                  v26 = *v21++;
                  *v25++ += v26 * v22;
                  --v24;
                }
                while (v24);
              }
            }
            if ((int)v9 >= 1)
            {
              v27 = 0;
              do
              {
                *(_DWORD *)(v16 + v27) -= *(int *)(*(_QWORD *)(v2 + 120) + v27) >> v12;
                v27 += 4;
              }
              while (4 * v9 != v27);
            }
            goto LABEL_72;
          }
        }
        for (j = 0; j != v4; ++j)
        {
          v39 = v17 + 80 * j;
          if ((*(_BYTE *)(v39 + 6) & 2) != 0)
            v40 = *(__int16 **)(v39 + 8);
          else
            v40 = 0;
          v41 = *(_DWORD *)(v18 + 4 * (j + v10));
          if (v41)
            v42 = (int)v9 < 1;
          else
            v42 = 1;
          if (!v42)
          {
            v43 = v9;
            v44 = this;
            do
            {
              v45 = *v40++;
              *v44++ += v41 * v45;
              --v43;
            }
            while (v43);
          }
        }
        if ((int)v9 >= 1)
        {
          for (k = 0; k != v9; ++k)
            *(_WORD *)(v16 + 2 * k) -= *(int *)(*(_QWORD *)(v2 + 120) + 4 * k) >> v12;
        }
LABEL_72:
        if (v7)
        {
          this = (int *)kd_multi_line::copy(v7, (kd_multi_line *)v6, -*(_DWORD *)(v7 + 44) - *(_DWORD *)(*(_QWORD *)(v2 + 80) + 4 * v3), 0.0);
LABEL_99:
          v1 = v67;
          goto LABEL_100;
        }
        goto LABEL_100;
      }
      if ((*((_BYTE *)v6 + 6) & 2) == 0)
      {
        v28 = (float *)*((_QWORD *)v6 + 1);
        if (v28)
        {
          if (v3)
          {
            for (m = 0; m != v3; ++m)
            {
              v30 = *(_QWORD *)(v2 + 16) + 80 * m;
              if ((*(_BYTE *)(v30 + 6) & 2) != 0)
                v31 = 0;
              else
                v31 = *(float **)(v30 + 8);
              v32 = *(float *)(*(_QWORD *)(v2 + 88) + 4 * (m + v3 * v1));
              if (v32 != 0.0 && (int)v9 >= 1)
              {
                v34 = v9;
                v35 = v28;
                do
                {
                  v36 = *v31++;
                  *v35 = *v35 - (float)(v36 * v32);
                  ++v35;
                  --v34;
                }
                while (v34);
              }
            }
          }
          goto LABEL_95;
        }
      }
      if (!v3)
        goto LABEL_95;
      if (*(_QWORD *)(v2 + 104))
      {
        if ((*((_BYTE *)v6 + 6) & 2) == 0)
          goto LABEL_75;
      }
      else
      {
        v47 = *(_QWORD *)(*(_QWORD *)(v2 + 32) + 8 * v3);
        kd_multi_dependency_block::create_short_matrix((kd_multi_dependency_block *)v2);
        v6 = (int *)(v5 + 80 * v3);
        v1 = v67;
        v7 = v47;
        if ((*((_BYTE *)v6 + 6) & 2) == 0)
        {
LABEL_75:
          v37 = 0;
          goto LABEL_76;
        }
      }
      v37 = *((_QWORD *)v6 + 1);
LABEL_76:
      v48 = *(_DWORD *)(v2 + 112);
      this = *(int **)(v2 + 120);
      if (!this)
      {
        v66 = v7;
        v49 = v6;
        this = (int *)operator new[]();
        *(_QWORD *)(v2 + 120) = this;
        v7 = v66;
        v1 = v67;
        v6 = v49;
      }
      if ((int)v9 >= 1)
      {
        v50 = v9;
        v51 = this;
        do
        {
          *v51++ = 1 << v48 >> 1;
          --v50;
        }
        while (v50);
      }
      v52 = 0;
      v53 = *(_QWORD *)(v2 + 16);
      v54 = *(_QWORD *)(v2 + 104);
      v55 = v3 * v1;
      do
      {
        v56 = v53 + 80 * v52;
        if ((*(_BYTE *)(v56 + 6) & 2) != 0)
          v57 = *(__int16 **)(v56 + 8);
        else
          v57 = 0;
        v58 = *(__int16 *)(v54 + 2 * (v52 + v55));
        if (*(_WORD *)(v54 + 2 * (v52 + v55)))
          v59 = v8 < 1;
        else
          v59 = 1;
        if (!v59)
        {
          v60 = v8;
          v61 = this;
          do
          {
            v62 = *v57++;
            *v61++ += v62 * v58;
            --v60;
          }
          while (v60);
        }
        ++v52;
      }
      while (v52 != v4);
      if ((int)v9 >= 1)
      {
        v63 = 0;
        do
        {
          *(_WORD *)(v37 + 2 * v63) -= *(int *)(*(_QWORD *)(v2 + 120) + 4 * v63) >> v48;
          ++v63;
        }
        while (v8 != v63);
      }
LABEL_95:
      if (v7)
      {
        if (*(_BYTE *)(v7 + 36) || *(_BYTE *)(v5 + 80 * v3 + 36))
          kd_multi_dependency_block::perform_inverse();
        this = (int *)kd_multi_line::copy(v7, (kd_multi_line *)v6, 0, -(float)(*(float *)(v7 + 48)- (float)((float)((float)-(float)(1 << *(_DWORD *)(v5 + 80 * v3 + 40))/ (float)(1 << *(_DWORD *)(v7 + 40)))* *(float *)(*(_QWORD *)(v2 + 96) + 4 * v3))));
        goto LABEL_99;
      }
LABEL_100:
      ++v3;
    }
    while (v3 != v1);
  }
  return this;
}

void sub_187F73364(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F73370()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_multi_dwt_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, uint64_t a7, _DWORD *a8, kd_multi_transform *a9)
{
  unint64_t scratch_ints;
  int *v16;
  _DWORD *v17;
  int *v18;
  int *v19;
  uint64_t mct_dwt_info;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  char v26;
  int v27;
  _DWORD *v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float *v41;
  uint64_t v42;
  _DWORD *v43;
  float v44;
  float v45;
  uint64_t v46;
  char v47;
  char *v48;
  int v49;
  int v50;
  unsigned int *v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  _OWORD *v60;
  float32x2_t v61;
  float64x2_t v62;
  uint64_t v63;
  uint64_t v69;
  uint64_t v70;
  _DWORD *v71;
  int v72;
  int *v73;
  unsigned int v74;
  signed int v75;
  int v76;
  int v77;
  BOOL v78;
  int v79;
  int v80;
  int v81;
  int v82;
  BOOL v83;
  int v84;
  int *v85;
  uint64_t v86;
  _QWORD *v87;
  _QWORD *v88;
  int32x2_t v89;
  uint64_t v90;
  uint64_t v91;
  int *v92;
  uint64_t v93;
  float32x2_t v94;
  int v95;
  uint64_t bibo_gains;
  double v97;
  double *v98;
  uint64_t v99;
  double v100;
  double v101;
  double v102;
  int v103;
  int v104;
  _DWORD *v105;
  int v106;
  int v107;
  int v108;
  uint64_t v109;
  int *v110;
  int *v111;
  float *v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int *v118;
  int v119;
  uint64_t v120;
  _QWORD *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  _DWORD *v125;
  _QWORD *v126;
  int v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  char v133;
  char v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  int v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  _DWORD *v146;
  int v147;
  int v148;
  _QWORD *v149;
  _DWORD *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t i;
  uint64_t v157;
  int *v158;
  uint64_t v159;
  _QWORD *v160;
  _DWORD *v161;
  _QWORD *v162;
  int v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  uint64_t v169;
  int v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  int v174;
  _DWORD *v175;
  int *v176;
  int v177;
  int v178;
  int v179;
  int v180;
  int v181;
  _QWORD *v182;
  uint64_t v183;
  _DWORD *v185;
  int v186;
  unint64_t v187;
  float *scratch_floats;
  int *v189;
  float64x2_t v190;
  int *v191;
  float64x2_t v192;
  int *v193;
  _DWORD *v194;
  char *v196;
  float64x2_t v197;
  double v198;
  double v199;
  uint64_t v200;
  uint64_t v201;
  int v202;
  int v203;
  float32x2_t v204;
  float *v205;
  int v206;
  int v207[2];
  int v208[2];
  int v209;
  int v210;
  uint64_t *v211[2];

  v211[0] = a4;
  v209 = a6;
  v210 = a5;
  scratch_ints = kd_multi_transform::get_scratch_ints(a9, 3 * a6 + 2 * a5);
  v191 = (int *)(scratch_ints + 4 * a5);
  v16 = &v191[a5];
  v17 = a8;
  v18 = &v16[a6];
  v186 = a6;
  *(_QWORD *)v208 = 0;
  scratch_floats = (float *)kd_multi_transform::get_scratch_floats(a9, a6);
  v189 = v16;
  v187 = scratch_ints;
  kdu_tile::get_mct_block_info(v211, a2, a3, (unsigned int *)&v208[1], v208, &v210, &v209, scratch_ints, v16, scratch_floats, &v18[a6], 0);
  if (*(_QWORD *)v208 != __PAIR64__(*(_DWORD *)a7, *a8))
    kd_multi_dwt_block::initialize();
  *(_QWORD *)v207 = 0;
  v206 = 0;
  v19 = (int *)(a1 + 84);
  v205 = 0;
  v196 = (char *)(a1 + 80);
  mct_dwt_info = kdu_tile::get_mct_dwt_info((kdu_tile *)v211, a2, a3, (BOOL *)(a1 + 80), (int *)(a1 + 64), v207, &v206, (int *)(a1 + 84), (BOOL *)(a1 + 81), (BOOL *)(a1 + 82), (const float **)&v205, v191, v18);
  if (!mct_dwt_info || *(int *)(a1 + 64) <= 0)
    kd_multi_dwt_block::initialize();
  v21 = mct_dwt_info;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  v22 = operator new[]();
  *(_QWORD *)(a1 + 88) = v22;
  v23 = *(unsigned int *)(a1 + 84);
  v24 = *(_DWORD *)(a1 + 120);
  if ((int)v23 >= 1)
  {
    v25 = 0;
    v26 = *(_BYTE *)(a1 + 80);
    v27 = *(_DWORD *)(a1 + 96);
    v28 = (_DWORD *)(v21 + 8);
    do
    {
      *(_BYTE *)v22 = v25;
      v29 = *(v28 - 2);
      *(_BYTE *)(v22 + 1) = v29;
      *(_BYTE *)(v22 + 2) = *v28;
      *(_BYTE *)(v22 + 3) = 0;
      *(_WORD *)(v22 + 4) = *(v28 - 1);
      *(_WORD *)(v22 + 6) = v28[1];
      *(_QWORD *)(v22 + 8) = 0;
      *(_QWORD *)(v22 + 16) = 0;
      *(_QWORD *)(v22 + 21) = 0;
      *(_BYTE *)(v22 + 30) = -1;
      *(_BYTE *)(v22 + 29) = v26;
      if (v24 < v29)
      {
        *(_DWORD *)(a1 + 120) = v29;
        v24 = v29;
      }
      v27 += v29;
      v28 += 4;
      ++v25;
      v22 += 32;
    }
    while (v23 != v25);
    *(_DWORD *)(a1 + 96) = v27;
  }
  *(_QWORD *)(a1 + 128) = operator new[]();
  *(_QWORD *)(a1 + 112) = operator new[]();
  v30 = operator new[]();
  *(_QWORD *)(a1 + 104) = v30;
  v31 = *(_DWORD *)(a1 + 84);
  if (v31 >= 1)
  {
    v32 = 0;
    v33 = 0;
    v34 = *(_QWORD *)(a1 + 88);
    v35 = *(_QWORD *)(a1 + 112);
    v36 = *(unsigned __int8 *)(a1 + 80);
    do
    {
      v37 = v30 + 4 * v33;
      v38 = v34 + 32 * v32;
      v39 = v35 + 4 * v33;
      *(_QWORD *)(v38 + 8) = v37;
      *(_QWORD *)(v38 + 16) = v39;
      v40 = *(unsigned __int8 *)(v38 + 1);
      if ((_DWORD)v40)
      {
        v41 = &v205[v33];
        v42 = v40;
        v43 = (_DWORD *)(v30 + 4 * v33);
        v44 = 0.4;
        do
        {
          v45 = *v41;
          *v43 = *(_DWORD *)v41;
          if (v45 <= v44)
          {
            if (v45 < (float)-v44)
              v44 = -v45;
          }
          else
          {
            v44 = v45;
          }
          ++v41;
          ++v43;
          --v42;
        }
        while (v42);
        if (!v36)
        {
          v46 = v34 + 32 * v32;
          v47 = 16;
          *(_BYTE *)(v46 + 2) = 16;
          v48 = (char *)(v46 + 2);
          if (v44 >= 0.499)
          {
            v47 = 16;
            do
            {
              --v47;
              v44 = v44 * 0.5;
            }
            while (v44 >= 0.499);
            *v48 = v47;
          }
          goto LABEL_27;
        }
      }
      else if (!v36)
      {
        v47 = 16;
        *(_BYTE *)(v34 + 32 * v32 + 2) = 16;
LABEL_27:
        v49 = 1 << v47;
        *(_WORD *)(v34 + 32 * v32 + 6) = v49 >> 1;
        goto LABEL_28;
      }
      v49 = 1 << *(_BYTE *)(v34 + 32 * v32 + 2);
LABEL_28:
      v207[1] = 0;
      if ((_DWORD)v40)
      {
        v50 = 0;
        do
        {
          *(_DWORD *)(v39 + 4 * v50) = vcvtmd_s64_f64((float)(*(float *)(v37 + 4 * v50) * (float)v49) + 0.5);
          v50 = v207[1] + 1;
          v207[1] = v50;
        }
        while (v50 < (int)v40);
        v31 = *v19;
      }
      v33 += v40;
      ++v32;
    }
    while (v32 < v31);
  }
  v51 = (unsigned int *)(a1 + 64);
  v207[1] = 0;
  if (v209 < 1)
  {
    v54 = v206;
    v53 = v207[0];
  }
  else
  {
    v52 = 0;
    v53 = v207[0];
    v54 = v206;
    do
    {
      v55 = v18[v52];
      if (v55 < 0 || (v56 = v55 + v207[0], v56 >= v206))
        kd_multi_dwt_block::initialize();
      if (v56 < v54)
        v54 = v56;
      if (v56 >= v53)
        v53 = v56 + 1;
      v207[1] = ++v52;
    }
    while (v209 != v52);
  }
  bzero(&v202, 0x288uLL);
  kdu_kernels::clear((uint64_t)&v202);
  v193 = (int *)(a1 + 84);
  kdu_kernels::init((uint64_t)&v202, *v19, v21, (int *)v205, *(_BYTE *)(a1 + 81), *(_BYTE *)(a1 + 82), *v196);
  v57 = (int)*v51;
  v58 = (_QWORD *)operator new[]();
  *v58 = 64;
  v58[1] = v57;
  if ((_DWORD)v57)
  {
    v59 = v57 << 6;
    v60 = v58 + 2;
    do
    {
      v60[1] = 0uLL;
      v60[2] = 0uLL;
      *v60 = 0uLL;
      v60 += 4;
      v59 -= 64;
    }
    while (v59);
  }
  *(_QWORD *)(a1 + 72) = v58 + 2;
  v207[1] = v203;
  if (v203 != *(_DWORD *)(a1 + 84))
    __assert_rtn("initialize", "multi_transform.cpp", 3114, "n == num_steps");
  v61 = v204;
  v200 = 0;
  v201 = 0;
  kdu_kernels::get_impulse_response(&v202, 2, &v207[1], (_DWORD *)&v201 + 1, &v201);
  kdu_kernels::get_impulse_response(&v202, 3, &v207[1], (_DWORD *)&v200 + 1, &v200);
  v194 = (_DWORD *)(a1 + 64);
  v63 = *v51;
  if ((int)v63 < 1)
  {
    v113 = 0;
    v110 = v191;
    v112 = scratch_floats;
    v111 = v189;
  }
  else
  {
    v185 = v17;
    v192 = vcvtq_f64_f32(v61);
    v62.f64[0] = 1.0;
    __asm { FMOV            V0.2D, #0.5 }
    v190 = _Q0;
    do
    {
      v197 = v62;
      v69 = *(_QWORD *)(a1 + 72);
      v70 = (v63 - 1);
      v71 = (_DWORD *)(v69 + (v70 << 6));
      *v71 = v207[0];
      v72 = v206 - v207[0];
      v71[1] = v206 - v207[0];
      v73 = v71 + 1;
      v74 = v53 - HIDWORD(v201) + ((v53 - HIDWORD(v201)) | 0xFFFFFFFE);
      v75 = (v53 - HIDWORD(v200)) & 0xFFFFFFFE;
      if ((int)(((v54 - v201) & 1) + v54 - v201) >= (int)((v54 - v200) | 1))
        v76 = (v54 - v200) | 1;
      else
        v76 = ((v54 - v201) & 1) + v54 - v201;
      if ((int)(v74 + 1) > v75)
        v77 = v74 + 1;
      else
        v77 = v75;
      v78 = v76 >= v207[0] && v77 <= v206;
      if (!v78)
      {
        v79 = 2 * v207[0];
        do
        {
          if (v72 >= 2)
            v80 = v76;
          else
            v80 = v207[0];
          if (v72 >= 2)
            v81 = v77;
          else
            v81 = v206;
          if (v79 - v80 >= v81)
            v82 = v79 - v80 + 1;
          else
            v82 = v81;
          v83 = v80 < v207[0];
          if (v80 <= v207[0])
            v80 = v207[0];
          if (v83)
            v81 = v82;
          v84 = 2 * v206 + ~v81;
          if (v84 >= v80)
            v84 = v80;
          if (v81 <= v206)
            v76 = v80;
          else
            v76 = v84;
          if (v81 >= v206)
            v77 = v206;
          else
            v77 = v81;
        }
        while (v76 < v207[0]);
      }
      v71[5] = v77 - v76;
      v85 = v71 + 5;
      *(v85 - 1) = v76;
      v86 = v69 + (v70 << 6);
      *(_QWORD *)(v86 + 32) = operator new[]();
      v87 = (_QWORD *)(v86 + 32);
      *(_QWORD *)(v86 + 40) = operator new[]();
      v88 = (_QWORD *)(v86 + 40);
      v207[1] = 0;
      v62 = v197;
      if (*v85 >= 1)
      {
        v90 = 0;
        do
        {
          *(_QWORD *)(*v87 + 8 * v90) = 0;
          *(_QWORD *)(*v88 + 8 * v90++) = 0;
          v207[1] = v90;
        }
        while (v90 < *v85);
      }
      v91 = v69 + (v70 << 6);
      *(_DWORD *)(v91 + 48) = 0;
      v92 = (int *)(v91 + 48);
      if (*v196)
      {
        *(_QWORD *)(v69 + (v70 << 6) + 52) = 0x400000003F800000;
      }
      else
      {
        if (*v73 > 1)
        {
          v95 = *v194 - v63;
          v198 = 0.0;
          v199 = 0.0;
          bibo_gains = kdu_kernels::get_bibo_gains((kdu_kernels *)&v202, v95, 0, 0, &v199, &v198);
          v97 = 1.0;
          if (v207[1] < *v193)
          {
            v98 = (double *)(bibo_gains + 8 * v207[1]);
            v99 = *v193 - (uint64_t)v207[1];
            do
            {
              v100 = *v98++;
              v101 = v100;
              if (v100 > v97)
                v97 = v101;
              --v99;
            }
            while (v99);
            v207[1] = *v193;
          }
          v102 = v197.f64[0] * v97;
          v62 = vdivq_f64((float64x2_t)vdupq_lane_s64(*(uint64_t *)&v197.f64[0], 0), v192);
          if (v102 > 6.0)
          {
            v103 = *v92;
            do
            {
              ++v103;
              v62 = vmulq_f64(v62, v190);
              v102 = v102 * 0.5;
            }
            while (v102 > 6.0);
            *v92 = v103;
          }
          v94 = vcvt_f32_f64(v62);
          v93 = v69 + (v70 << 6);
        }
        else
        {
          *(float *)v89.i32 = v197.f64[0];
          v93 = v69 + (v70 << 6);
          v94 = (float32x2_t)vdup_lane_s32(v89, 0);
        }
        *(float32x2_t *)(v93 + 52) = v94;
      }
      v206 = (v206 + 1) >> 1;
      v207[0] = (v207[0] + 1) >> 1;
      v104 = v76 + 1;
      v54 = (v76 + 1) >> 1;
      v53 = (v77 + 1) >> 1;
      v105 = (_DWORD *)(v69 + (v70 << 6));
      v106 = *v73 - (v206 - v207[0]);
      v105[2] = v206 - v207[0];
      v105[3] = v106;
      v107 = v53 - (v104 >> 1);
      v108 = *v85 - v107;
      v105[6] = v107;
      v105[7] = v108;
      v78 = v63-- <= 1;
    }
    while (!v78);
    v109 = *v194;
    v110 = v191;
    v112 = scratch_floats;
    v111 = v189;
    v113 = 0;
    if ((int)v109 < 1)
    {
      v17 = v185;
    }
    else
    {
      v114 = *v194;
      v17 = v185;
      do
      {
        v115 = *(_QWORD *)(a1 + 72);
        v116 = (v114 - 1);
        v117 = v115 + (v116 << 6);
        v207[1] = 0;
        v118 = (int *)(v117 + 20);
        v119 = *(_DWORD *)(v117 + 20);
        if (v114 == v109)
        {
          if (v119 >= 1)
          {
            v120 = 0;
            v121 = (_QWORD *)(v115 + (v116 << 6) + 32);
            v122 = 80 * v113;
            do
            {
              *(_QWORD *)(*v121 + 8 * v120++) = v122;
              v207[1] = v120;
              v122 += 80;
            }
            while (v120 < *v118);
            v113 += v120;
          }
        }
        else if (v119 >= 1)
        {
          v123 = 0;
          v124 = v115 + (v116 << 6);
          v125 = (_DWORD *)(v124 + 16);
          v126 = (_QWORD *)(v124 + 32);
          do
          {
            v127 = 2 * (v123 + *v125) - *(_DWORD *)(v117 + 80);
            if (v127 < 0 || v127 >= *(_DWORD *)(v117 + 84))
              v128 = 80 * v113++;
            else
              v128 = *(_QWORD *)(*(_QWORD *)(v117 + 96) + 8 * v127);
            *(_QWORD *)(*v126 + 8 * v123++) = v128;
            v207[1] = v123;
          }
          while (v123 < *v118);
        }
        v78 = v114-- <= 1;
      }
      while (!v78);
    }
  }
  *(_DWORD *)(a1 + 12) = v113;
  v129 = v113;
  is_mul_ok(v113, 0x50uLL);
  v130 = operator new[]();
  if (v129)
  {
    v131 = v130;
    do
    {
      *(_DWORD *)v131 = 0;
      *(_QWORD *)(v131 + 14) = 0;
      *(_QWORD *)(v131 + 6) = 0;
      *(_WORD *)(v131 + 22) = 0;
      *(_DWORD *)(v131 + 24) = -1;
      *(_QWORD *)(v131 + 28) = 0;
      *(_QWORD *)(v131 + 44) = 0;
      *(_QWORD *)(v131 + 36) = 0;
      *(_QWORD *)(v131 + 56) = 0;
      *(_QWORD *)(v131 + 64) = 0;
      *(_DWORD *)(v131 + 72) = -1;
      v131 += 80;
    }
    while (v131 != v130 + 80 * v129);
  }
  *(_QWORD *)(a1 + 16) = v130;
  v132 = *(_DWORD *)(a1 + 12);
  if (v132 < 1)
  {
    v132 = 0;
  }
  else
  {
    v133 = *v196;
    v134 = *v196 ^ 1;
    v135 = v130 + 36;
    v136 = *(unsigned int *)(a1 + 12);
    do
    {
      *(_QWORD *)(v135 + 28) = a1;
      *(_BYTE *)v135 = v133;
      *(_BYTE *)(v135 + 1) = v134;
      v135 += 80;
      --v136;
    }
    while (v136);
  }
  v207[1] = v132;
  v137 = *v194;
  if ((int)v137 <= 0)
  {
    *(_DWORD *)(a1 + 24) = 0;
  }
  else
  {
    v138 = 0;
    v139 = 0;
    do
    {
      v140 = *(_QWORD *)(a1 + 72);
      if (!v138)
      {
        v141 = *(_DWORD *)(v140 + 24);
        if (v141 >= 1)
        {
          v142 = 0;
          v143 = 8 * v139;
          v144 = 8 * (*(_DWORD *)(v140 + 16) & 1);
          do
          {
            *(_QWORD *)(*(_QWORD *)(v140 + 40) + v144) = v143;
            ++v142;
            v143 += 8;
            v144 += 16;
          }
          while (v142 < v141);
          v139 += v142;
        }
      }
      v145 = v140 + (v138 << 6);
      v207[1] = 0;
      v146 = (_DWORD *)(v145 + 28);
      if (*(int *)(v145 + 28) >= 1)
      {
        v147 = 0;
        v148 = 0;
        v149 = (_QWORD *)(v145 + 40);
        v150 = (_DWORD *)(v145 + 16);
        v151 = 8 * v139;
        do
        {
          *(_QWORD *)(*v149 + 8 * ((v147 + (*v150 & 1)) ^ 1u)) = v151;
          v207[1] = ++v148;
          v151 += 8;
          v147 += 2;
        }
        while (v148 < *v146);
        v139 += v148;
      }
      ++v138;
    }
    while (v138 != v137);
    *(_DWORD *)(a1 + 24) = v139;
  }
  *(_QWORD *)(a1 + 32) = operator new[]();
  v152 = *(unsigned int *)(a1 + 24);
  if ((int)v152 >= 1)
  {
    v153 = 0;
    v154 = 8 * v152;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + v153) = 0;
      v153 += 8;
    }
    while (v154 != v153);
  }
  v155 = *v194;
  if ((int)v155 >= 1)
  {
    for (i = 0; i != v155; ++i)
    {
      v157 = *(_QWORD *)(a1 + 72) + (i << 6);
      v207[1] = 0;
      v158 = (int *)(v157 + 20);
      if (*(int *)(v157 + 20) >= 1)
      {
        v159 = 0;
        v160 = (_QWORD *)(v157 + 32);
        v161 = (_DWORD *)(v157 + 16);
        v162 = (_QWORD *)(v157 + 40);
        do
        {
          *(_QWORD *)(*v160 + 8 * v159) += *(_QWORD *)(a1 + 16);
          if (!i || (((_DWORD)v159 + *v161) & 1) != 0)
          {
            *(_QWORD *)(*v162 + 8 * v159) += *(_QWORD *)(a1 + 32);
          }
          else if (*(_QWORD *)(*v162 + 8 * v159))
          {
            __assert_rtn("initialize", "multi_transform.cpp", 3279, "lev->dependencies[n] == NULL");
          }
          v207[1] = ++v159;
        }
        while (v159 < *v158);
      }
    }
  }
  v163 = v155;
  v164 = *(_QWORD *)(a1 + 72);
  v165 = v209;
  v207[1] = 0;
  if (v209 >= 1)
  {
    v166 = 0;
    v167 = v164 + (((int)v155 - 1) << 6);
    do
    {
      v168 = *(_DWORD *)v167 + v111[v186] - *(_DWORD *)(v167 + 16);
      if (v168 < 0 || v168 >= *(_DWORD *)(v167 + 20))
        __assert_rtn("initialize", "multi_transform.cpp", 3289, "(idx >= 0) && (idx < top_level->region_size)");
      v169 = *(_QWORD *)(*(_QWORD *)(v167 + 32) + 8 * v168);
      if (v169 != *(_QWORD *)(a1 + 16) + 80 * v168)
        __assert_rtn("initialize", "multi_transform.cpp", 3291, "line == (components + idx)");
      *(_QWORD *)(*((_QWORD *)v17 + 1) + 8 * *v111) = v169;
      *(_DWORD *)(v169 + 44) = v111[2 * v186];
      v170 = *(_DWORD *)v112++;
      *(_DWORD *)(v169 + 48) = v170;
      v207[1] = ++v166;
      ++v111;
    }
    while (v165 != v166);
  }
  v171 = v210;
  v207[1] = 0;
  if (v210 < 1)
    return kdu_kernels::reset((kdu_kernels *)&v202);
  if ((int)v155 < 1)
    goto LABEL_193;
  v172 = 0;
  do
  {
    v173 = 0;
    v174 = v110[v172];
    v175 = *(_DWORD **)(a1 + 72);
    v176 = v175 + 5;
    while (1)
    {
      if (v173)
        goto LABEL_172;
      v177 = v175[2];
      _VF = __OFSUB__(v174, v177);
      v178 = v174 - v177;
      if (v178 < 0 != _VF)
        break;
      v174 = v178;
LABEL_172:
      v179 = *(v176 - 2);
      _VF = __OFSUB__(v174, v179);
      v180 = v174 - v179;
      if (v180 < 0 != _VF)
      {
        v181 = (*(v176 - 5) | 1) + 2 * v174 - *(v176 - 1);
        if (v181 < 0 || v181 >= *v176)
          goto LABEL_193;
        goto LABEL_181;
      }
      ++v173;
      v176 += 16;
      v174 = v180;
      if (v163 == v173)
        goto LABEL_193;
    }
    v181 = *v175 + 2 * v174 + (*v175 & 1) - v175[4];
    if (v181 < 0 || v181 >= v175[5])
LABEL_193:
      __assert_rtn("initialize", "multi_transform.cpp", 3325, "dep_ref != NULL");
    v173 = 0;
LABEL_181:
    v182 = *(_QWORD **)(*(_QWORD *)&v175[16 * v173 + 10] + 8 * v181);
    if (!v182)
      goto LABEL_193;
    v183 = *(_QWORD *)(*(_QWORD *)(a7 + 8) + 8 * *(int *)(v187 + 4 * v172));
    *v182 = v183;
    if (v183)
    {
      ++*(_DWORD *)(v183 + 28);
      if (*v196)
        *(_BYTE *)(v183 + 36) = 1;
    }
    v207[1] = ++v172;
  }
  while (v172 != v171);
  return kdu_kernels::reset((kdu_kernels *)&v202);
}

void sub_187F7421C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  kdu_kernels::reset((kdu_kernels *)&a37);
  _Unwind_Resume(a1);
}

const char *kd_multi_dwt_block::prepare_for_inversion(kd_multi_dwt_block *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v1 = *((unsigned int *)this + 16);
  if ((int)v1 <= 0)
    kd_multi_dwt_block::prepare_for_inversion();
  v2 = *((_QWORD *)this + 9) + (v1 << 6);
  v3 = *(unsigned int *)(v2 - 60);
  if ((int)v3 < 1)
  {
LABEL_7:
    *((_DWORD *)this + 11) = v3;
    v7 = *((unsigned int *)this + 6);
    if ((int)v7 < 1)
    {
      return 0;
    }
    else
    {
      v8 = 0;
      v9 = 8 * v7;
      v5 = "Encountered an irreversible DWT transform block which operates on reversible codestream sample data.  While w"
           "e allow such transforms to be processed during decompression, it is unreasonable to generate reversibly compr"
           "essed component samples using an irreversible inverse multi-component transform during compression.  Kakadu w"
           "ill not invert this transform during compression.  This can prevent the compression process from proceeding i"
           "f there are no other paths back from the MCT output components to the codestream components.";
      while (1)
      {
        if (!*((_BYTE *)this + 80))
        {
          v10 = *(_QWORD *)(*((_QWORD *)this + 4) + v8);
          if (v10)
          {
            if (*(_BYTE *)(v10 + 36))
              break;
          }
        }
        v8 += 8;
        if (v9 == v8)
          return 0;
      }
    }
  }
  else if (*(_QWORD *)(v2 - 48) == *(_QWORD *)(v2 - 64))
  {
    v4 = *(_QWORD *)(v2 - 32);
    v5 = "DWT transform block cannot be inverted unless all output components can be computed by downstream transform blo"
         "cks in the multi-component transform network, or by the application supplying them.";
    v6 = v3;
    while (*(int *)(*(_QWORD *)v4 + 28) >= 1)
    {
      v4 += 8;
      if (!--v6)
        goto LABEL_7;
    }
  }
  else
  {
    return "DWT transform block cannot be inverted unless all output components can be computed by downstream transform b"
           "locks in the multi-component transform network, or by the application supplying them.";
  }
  return v5;
}

uint64_t kd_multi_dwt_block::normalize_coefficients(uint64_t this)
{
  int v1;
  char v2;
  int v3;
  _DWORD *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _OWORD v16[2];
  uint64_t v17;

  if (!*(_BYTE *)(this + 80))
  {
    v1 = *(_DWORD *)(this + 12);
    if (v1 < 1)
    {
      v3 = 0;
      v2 = 0;
    }
    else
    {
      v2 = 0;
      v3 = 0;
      v4 = (_DWORD *)(*(_QWORD *)(this + 16) + 40);
      v5 = *(unsigned int *)(this + 12);
      do
      {
        if (*v4 > v3)
          v3 = *v4;
        v2 |= *((_BYTE *)v4 - 2) != 0;
        v4 += 20;
        --v5;
      }
      while (v5);
    }
    v6 = (v3 == 0) | v2;
    LODWORD(v7) = *(_DWORD *)(this + 24);
    if ((int)v7 >= 1)
    {
      v8 = *(uint64_t **)(this + 32);
      v9 = *(unsigned int *)(this + 24);
      do
      {
        v10 = *v8;
        if (*v8 && (*(_BYTE *)(v10 + 38) || !*(_DWORD *)(v10 + 40)))
          v6 = 1;
        ++v8;
        --v9;
      }
      while (v9);
    }
    if (v1 >= 1)
    {
      v11 = 0;
      for (i = 0; i < v1; ++i)
      {
        v13 = *(_QWORD *)(this + 16) + v11;
        *(_BYTE *)(v13 + 38) = v6 & 1;
        if (!*(_BYTE *)(v13 + 37))
          kd_multi_dwt_block::normalize_coefficients();
        v14 = *(_DWORD *)(v13 + 40);
        if (v14)
        {
          if (v14 != v3)
          {
            v17 = 0;
            memset(v16, 0, sizeof(v16));
            kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
            (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, "Inconsistent bit-depths encountered amongst output image components produced by a DWT transform block embedded inside the multi-component transform network.  All output (i.e., synthesized) components produced by a single DWT block must be declared with the same bit-depth.  Anything else makes no sense, so Kakadu does not bother trying to accommodate this case.");
            kdu_error::~kdu_error((kdu_error *)v16);
          }
        }
        else
        {
          *(_DWORD *)(v13 + 40) = v3;
        }
        v11 += 80;
      }
      LODWORD(v7) = *(_DWORD *)(this + 24);
    }
    if ((int)v7 >= 1)
    {
      v15 = *(_QWORD *)(this + 32);
      v7 = v7;
      do
      {
        if (*(_QWORD *)v15)
          *(_BYTE *)(*(_QWORD *)v15 + 38) = v6 & 1;
        v15 += 8;
        --v7;
      }
      while (v7);
    }
  }
  return this;
}

void sub_187F744E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F744F0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_multi_dwt_block::propagate_bit_depths(kd_multi_dwt_block *this, int a2, int a3)
{
  uint64_t v3;
  int v4;
  int *v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t **v12;
  uint64_t v13;
  int v14;
  BOOL v15;
  char v16;
  char v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t **v25;
  int v26;
  uint64_t v27;

  if ((a2 & 1) == 0 && !a3)
    goto LABEL_28;
  v3 = *((unsigned int *)this + 3);
  if ((int)v3 >= 1)
  {
    v4 = 0;
    v5 = (int *)(*((_QWORD *)this + 2) + 40);
    v6 = *((unsigned int *)this + 3);
    do
    {
      v8 = *v5;
      v5 += 20;
      v7 = v8;
      if (v8)
      {
        if (v4)
        {
          v15 = v4 == v7;
          v4 = v7;
          if (!v15)
            goto LABEL_28;
        }
        else
        {
          v4 = v7;
        }
      }
      --v6;
    }
    while (v6);
    if (v4)
      goto LABEL_31;
  }
  if ((a2 & 1) != 0)
  {
LABEL_28:
    v16 = 0;
    return v16 & 1;
  }
  v9 = *((_QWORD *)this + 9);
  v10 = *(unsigned int *)(v9 + 20);
  if ((int)v10 < 1)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v11 = 0;
    v12 = *(uint64_t ***)(v9 + 40);
    do
    {
      if (*v12)
      {
        v13 = **v12;
        if (v13)
        {
          v14 = *(_DWORD *)(v13 + 40);
          if (v14)
          {
            if (v14 > v11)
              v11 = v14;
            v15 = v14 < v4 || v4 == 0;
            if (v15)
              v4 = v14;
          }
        }
      }
      ++v12;
      --v10;
    }
    while (v10);
    if (v4 <= 0 && v11 != v4)
      goto LABEL_28;
  }
LABEL_31:
  if (!a3)
  {
    v16 = 0;
    if (!a2)
      return v16 & 1;
    goto LABEL_42;
  }
  if ((int)v3 < 1)
  {
    v18 = 0;
  }
  else
  {
    v18 = 0;
    v19 = (int *)(*((_QWORD *)this + 2) + 40);
    do
    {
      if (!*v19)
      {
        *v19 = v4;
        v18 = 1;
      }
      v19 += 20;
      --v3;
    }
    while (v3);
  }
  v16 = v18;
  if (a2)
  {
LABEL_42:
    v20 = *((unsigned int *)this + 16);
    if ((int)v20 >= 1)
    {
      v21 = 0;
      v22 = *((_QWORD *)this + 9);
      do
      {
        v23 = v22 + (v21 << 6);
        v24 = *(unsigned int *)(v23 + 20);
        if ((int)v24 >= 1)
        {
          v25 = *(uint64_t ***)(v23 + 40);
          if (v21)
            v26 = v4 + 1;
          else
            v26 = v4;
          do
          {
            if (*v25)
            {
              v27 = **v25;
              if (v27)
              {
                if (!*(_DWORD *)(v27 + 40))
                {
                  *(_DWORD *)(v27 + 40) = v26;
                  v16 = 1;
                }
              }
            }
            ++v25;
            --v24;
          }
          while (v24);
        }
        ++v21;
      }
      while (v21 != v20);
    }
  }
  return v16 & 1;
}

void kd_multi_dwt_block::perform_transform(kd_multi_dwt_block *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _DWORD *v10;
  float *v11;
  float *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  uint64_t v17;
  float *v18;
  int *v19;
  float v20;
  float v21;
  int v22;
  __int16 *v23;
  _WORD *v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  float *v29;
  float v30;
  int v31;
  float v32;
  float v33;
  _DWORD *v34;
  int v35;
  int v36;
  uint64_t v37;
  char v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  _BYTE *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  char v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  BOOL v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int *v65;
  int v66;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char v71;
  float *v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  int *v76;
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  _DWORD *v83;

  if (*((int *)this + 16) < 1)
    return;
  v2 = 0;
  do
  {
    v3 = *((_QWORD *)this + 9);
    v4 = v3 + (v2 << 6);
    v6 = (int *)(v4 + 20);
    LODWORD(v5) = *(_DWORD *)(v4 + 20);
    v79 = v3;
    if ((int)v5 < 1)
      goto LABEL_53;
    v7 = 0;
    v8 = (_QWORD *)(v4 + 40);
    v9 = (_QWORD *)(v4 + 32);
    v10 = (_DWORD *)(v4 + 16);
    v11 = (float *)(v4 + 56);
    v82 = v3 + (v2 << 6);
    v12 = (float *)(v4 + 52);
    do
    {
      v13 = *(uint64_t **)(*v8 + 8 * v7);
      if (!v13)
        goto LABEL_10;
      v14 = *(_QWORD *)(*v9 + 8 * v7);
      v15 = *v13;
      if (!*v13)
      {
        kd_multi_line::reset((kd_multi_line *)v14, 0, 0.0);
        goto LABEL_10;
      }
      if (*((_BYTE *)this + 80))
      {
        kd_multi_line::copy(v14, (kd_multi_line *)v15, 0, 0.0);
        goto LABEL_10;
      }
      if (((*v10 + (_DWORD)v7) & 1) != 0)
        v16 = *v11 * 0.5;
      else
        v16 = *v12;
      v17 = *(unsigned int *)(v14 + 20);
      if ((*(_BYTE *)(v14 + 6) & 2) == 0)
      {
        v18 = *(float **)(v14 + 8);
        if (v18)
        {
          if (*(_BYTE *)(v15 + 36))
          {
            if ((*(_BYTE *)(v15 + 6) & 2) != 0)
              v19 = 0;
            else
              v19 = *(int **)(v15 + 8);
            if ((int)v17 >= 1)
            {
              v30 = v16 / (float)(1 << *(_DWORD *)(v14 + 40));
              do
              {
                v31 = *v19++;
                *v18++ = v30 * (float)v31;
                --v17;
              }
              while (v17);
            }
          }
          else
          {
            if ((*(_BYTE *)(v15 + 6) & 2) != 0)
              v29 = 0;
            else
              v29 = *(float **)(v15 + 8);
            if ((int)v17 >= 1)
            {
              v32 = (float)(v16 * (float)(1 << *(_DWORD *)(v15 + 40))) / (float)(1 << *(_DWORD *)(v14 + 40));
              do
              {
                v33 = *v29++;
                *v18++ = v32 * v33;
                --v17;
              }
              while (v17);
            }
          }
          goto LABEL_10;
        }
      }
      if (*(_BYTE *)(v15 + 36))
        v20 = 8192.0;
      else
        v20 = (float)(1 << *(_DWORD *)(v15 + 40));
      v21 = (float)(v16 / (float)(1 << *(_DWORD *)(v14 + 40))) * v20;
      v22 = 0;
      while (v21 < 16383.0)
      {
        v21 = v21 + v21;
        ++v22;
      }
      while (v21 > 32767.0)
      {
        v21 = v21 * 0.5;
        --v22;
      }
      if ((*(_BYTE *)(v15 + 6) & 2) != 0)
      {
        v23 = *(__int16 **)(v15 + 8);
        if ((*(_BYTE *)(v14 + 6) & 2) != 0)
        {
LABEL_30:
          v24 = *(_WORD **)(v14 + 8);
          goto LABEL_33;
        }
      }
      else
      {
        v23 = 0;
        if ((*(_BYTE *)(v14 + 6) & 2) != 0)
          goto LABEL_30;
      }
      v24 = 0;
LABEL_33:
      v25 = vcvtmd_s64_f64(v21 + 0.5);
      if (v22 < 0)
      {
        if ((int)v17 >= 1)
        {
          v27 = -v22;
          do
          {
            v28 = (unsigned __int16)*v23++;
            *v24++ = (v28 * (unsigned __int16)v25) << v27;
            --v17;
          }
          while (v17);
        }
      }
      else if ((int)v17 >= 1)
      {
        do
        {
          v26 = *v23++;
          *v24++ = (int)((1 << v22 >> 1) + v26 * v25) >> v22;
          --v17;
        }
        while (v17);
      }
LABEL_10:
      ++v7;
      v5 = *v6;
    }
    while (v7 < v5);
    v3 = v79;
    v4 = v82;
LABEL_53:
    v36 = *(_DWORD *)(v4 + 16);
    v34 = (_DWORD *)(v4 + 16);
    v35 = v36;
    if (*(v34 - 3) != 1)
    {
      v41 = *((unsigned int *)this + 21);
      v78 = v2;
      if ((int)v41 >= 1)
      {
        v42 = v35 + v5;
        v43 = v35 + v5 - 1;
        v44 = (_QWORD *)(v3 + (v2 << 6) + 32);
        v83 = v34;
        while (1)
        {
          v81 = v41;
          v45 = v41 - 1;
          v80 = v45;
          if (!((*v34 ^ v45) & 1) < (int)v5)
            break;
LABEL_98:
          v41 = v80;
          v34 = v83;
          if (v81 <= 1)
            goto LABEL_99;
        }
        v46 = *((_QWORD *)this + 11) + 32 * v45;
        v47 = (_BYTE *)(v46 + 1);
        v48 = ((*v34 ^ v45) & 1) == 0;
        while (1)
        {
          v49 = *(_QWORD *)(*v44 + 8 * v48);
          v50 = *(_DWORD *)(v49 + 20);
          v51 = *(_BYTE *)(v49 + 6);
          v52 = *(_QWORD *)(v49 + 8);
          v53 = (v51 & 2) != 0 ? v52 : 0;
          v54 = (v51 & 2) != 0 ? 0 : v52;
          v55 = *v47;
          if (*v47)
            break;
LABEL_93:
          if (v53)
          {
            perform_synthesis_lifting_step(v46, *((uint64_t **)this + 16), v53, v53, v50, 0);
          }
          else
          {
            if (!v54)
              kd_multi_dwt_block::perform_transform();
            perform_synthesis_lifting_step(v46, *((uint64_t **)this + 16), v54, v54, v50, 0);
          }
          v48 += 2;
          LODWORD(v5) = *v6;
          if (*v6 <= (int)v48)
            goto LABEL_98;
        }
        v56 = 0;
        v57 = *v83;
        v58 = ((*v83 + v48) ^ 1) + 2 * *(__int16 *)(v46 + 4);
        while (1)
        {
          v59 = v58 < v35;
          if (v58 < v35 || (v60 = v58, v58 >= v42))
          {
            v60 = v58;
            do
            {
              if (v59)
              {
                if (*((_BYTE *)this + 82))
                  v60 = 2 * v35 - v60;
                else
                  v60 = ((v60 ^ v35) & 1) + v35;
              }
              else if (*((_BYTE *)this + 82))
              {
                v60 = 2 * v43 - v60;
              }
              else
              {
                v60 = v43 - ((v60 ^ v43) & 1);
              }
              v59 = v60 < v35;
            }
            while (v60 < v35 || v60 >= v42);
          }
          v61 = v60 - v57;
          if (v60 - v57 < 0 || v61 >= (int)v5)
            kd_multi_dwt_block::perform_transform();
          v62 = *(_QWORD *)(*v44 + 8 * v61);
          if (v53)
          {
            if ((*(_BYTE *)(v62 + 6) & 2) != 0)
              goto LABEL_91;
          }
          else if ((*(_BYTE *)(v62 + 6) & 2) == 0)
          {
LABEL_91:
            v63 = *(_QWORD *)(v62 + 8);
            goto LABEL_92;
          }
          v63 = 0;
LABEL_92:
          *(_QWORD *)(*((_QWORD *)this + 16) + 8 * v56++) = v63;
          v58 += 2;
          if (v56 == v55)
            goto LABEL_93;
        }
      }
LABEL_99:
      v2 = v78;
      v3 = v79;
      if (*((_BYTE *)this + 80))
        goto LABEL_118;
      v64 = v79 + (v78 << 6);
      v66 = *(_DWORD *)(v64 + 48);
      v65 = (int *)(v64 + 48);
      if (v66 < 1 || (int)v5 < 1)
        goto LABEL_118;
      v68 = 0;
      while (1)
      {
        v69 = *(_QWORD *)(*(_QWORD *)(v79 + (v78 << 6) + 32) + 8 * v68);
        v70 = *(unsigned int *)(v69 + 20);
        v71 = *(_BYTE *)(v69 + 6);
        v72 = *(float **)(v69 + 8);
        if ((v71 & 2) != 0)
          break;
        v73 = *v65;
        if (!v72)
          goto LABEL_111;
        if ((int)v70 >= 1)
        {
          do
          {
            *v72 = *v72 * (float)(1 << v73);
            ++v72;
            --v70;
          }
          while (v70);
        }
LABEL_113:
        if (++v68 >= *v6)
          goto LABEL_118;
      }
      v73 = *v65;
LABEL_111:
      if ((int)v70 >= 1)
      {
        do
        {
          *(_WORD *)v72 = *(unsigned __int16 *)v72 << v73;
          v72 = (float *)((char *)v72 + 2);
          --v70;
        }
        while (v70);
      }
      goto LABEL_113;
    }
    if ((v35 & 1) != 0 && *((_BYTE *)this + 80))
    {
      v37 = **(_QWORD **)(v3 + (v2 << 6) + 32);
      v38 = *(_BYTE *)(v37 + 6);
      v39 = *(int **)(v37 + 8);
      v40 = *(unsigned int *)(v37 + 20);
      if ((v38 & 2) != 0 && v39)
      {
        if ((int)v40 >= 1)
        {
          do
          {
            *(_WORD *)v39 = *(__int16 *)v39 >> 1;
            v39 = (int *)((char *)v39 + 2);
            --v40;
          }
          while (v40);
        }
      }
      else if ((int)v40 >= 1)
      {
        do
        {
          *v39++ >>= 1;
          --v40;
        }
        while (v40);
      }
    }
    if (*(_DWORD *)(v3 + (v2 << 6) + 48))
      kd_multi_dwt_block::perform_transform();
LABEL_118:
    v74 = *((int *)this + 16);
    if (v2 >= v74 - 1 && *v6 >= 1)
    {
      v75 = 0;
      v76 = v6;
      v77 = (_QWORD *)(v3 + (v2 << 6) + 32);
      do
      {
        kd_multi_line::apply_offset(*(_QWORD *)(*v77 + 8 * v75), *(_DWORD *)(*(_QWORD *)(*v77 + 8 * v75) + 44), *(float *)(*(_QWORD *)(*v77 + 8 * v75) + 48));
        ++v75;
      }
      while (v75 < *v76);
      LODWORD(v74) = *((_DWORD *)this + 16);
    }
    ++v2;
  }
  while (v2 < (int)v74);
}

uint64_t kd_multi_dwt_block::perform_inverse(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  char v8;
  _WORD *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  _QWORD *v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  BOOL v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  float *v45;
  int v46;
  uint64_t v47;
  int *v48;
  uint64_t v49;
  _QWORD *v50;
  _QWORD *v51;
  _DWORD *v52;
  float *v53;
  float *v54;
  uint64_t *v55;
  uint64_t v56;
  float v57;
  uint64_t v58;
  float v59;
  float *v60;
  float *v61;
  int v62;
  __int16 *v63;
  _WORD *v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  int v68;
  int v69;
  __int16 v70;
  float v71;
  float v72;
  BOOL v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int *v79;
  int *v80;

  v1 = *(unsigned int *)(this + 64);
  if ((int)v1 >= 1)
  {
    v2 = this;
    do
    {
      v3 = *(_QWORD *)(v2 + 72);
      v4 = (v1 - 1);
      v5 = (int *)(v3 + (v4 << 6));
      v6 = v5[1];
      v78 = v1 - 1;
      if (v6 == 1)
      {
        if (v5[12])
          kd_multi_dwt_block::perform_inverse();
        if ((*(_BYTE *)v5 & 1) != 0 && *(_BYTE *)(v2 + 80))
        {
          v7 = **(_QWORD **)(v3 + (v4 << 6) + 32);
          v8 = *(_BYTE *)(v7 + 6);
          v9 = *(_WORD **)(v7 + 8);
          v10 = *(unsigned int *)(v7 + 20);
          if ((v8 & 2) != 0 && v9)
          {
            if ((int)v10 >= 1)
            {
              do
              {
                *v9++ *= 2;
                --v10;
              }
              while (v10);
            }
          }
          else if ((int)v10 >= 1)
          {
            do
            {
              *(_DWORD *)v9 *= 2;
              v9 += 2;
              --v10;
            }
            while (v10);
          }
        }
        goto LABEL_68;
      }
      if (!*(_BYTE *)(v2 + 80))
      {
        v37 = v3 + (v4 << 6);
        v38 = (int *)(v37 + 48);
        if (*(int *)(v37 + 48) >= 1)
        {
          v40 = *(_DWORD *)(v37 + 20);
          v39 = (int *)(v37 + 20);
          if (v40 >= 1)
          {
            v41 = 0;
            while (1)
            {
              v42 = *(_QWORD *)(*(_QWORD *)(v3 + (v4 << 6) + 32) + 8 * v41);
              v43 = *(unsigned int *)(v42 + 20);
              v44 = *(_BYTE *)(v42 + 6);
              v45 = *(float **)(v42 + 8);
              if ((v44 & 2) != 0)
                break;
              v46 = *v38;
              if (!v45)
                goto LABEL_62;
              if ((int)v43 >= 1)
              {
                do
                {
                  *v45 = (float)(1.0 / (float)(1 << v46)) * *v45;
                  ++v45;
                  --v43;
                }
                while (v43);
              }
LABEL_64:
              if (++v41 >= *v39)
              {
                v6 = v5[1];
                goto LABEL_13;
              }
            }
            v46 = *v38;
LABEL_62:
            if ((int)v43 >= 1)
            {
              do
              {
                this = (((0x10000 << (v46 - 1) >> 16) + *(__int16 *)v45) >> v46);
                *(_WORD *)v45 = this;
                v45 = (float *)((char *)v45 + 2);
                --v43;
              }
              while (v43);
            }
            goto LABEL_64;
          }
        }
      }
LABEL_13:
      v11 = *(_DWORD *)(v2 + 84);
      if (v11 < 1)
        goto LABEL_68;
      v12 = 0;
      v13 = *v5;
      v14 = v6 + *v5;
      v15 = v3 + (v4 << 6);
      v17 = *(_DWORD *)(v15 + 20);
      v15 += 20;
      v16 = v17;
      v79 = (int *)(v15 - 4);
      v80 = (int *)v15;
      v18 = (_QWORD *)(v15 + 12);
      v75 = v3;
      v76 = v1;
      v74 = (v1 - 1);
      do
      {
        if (!((*v79 ^ v12) & 1) >= v16)
          goto LABEL_51;
        v77 = v12;
        v19 = *(_QWORD *)(v2 + 88) + 32 * v12;
        v20 = (_BYTE *)(v19 + 1);
        v21 = ((*v79 ^ v12) & 1) == 0;
        do
        {
          v22 = *(_QWORD *)(*v18 + 8 * v21);
          v23 = *(_DWORD *)(v22 + 20);
          v24 = *(_BYTE *)(v22 + 6);
          v25 = *(_QWORD *)(v22 + 8);
          if ((v24 & 2) != 0)
            v26 = v25;
          else
            v26 = 0;
          if ((v24 & 2) != 0)
            v27 = 0;
          else
            v27 = v25;
          v28 = *v20;
          if (*v20)
          {
            v29 = 0;
            v30 = *v79;
            v31 = ((*v79 + v21) ^ 1) + 2 * *(__int16 *)(v19 + 4);
            do
            {
              v32 = v31 < v13;
              if (v31 < v13 || (v33 = v31, v31 >= v14))
              {
                v33 = v31;
                do
                {
                  if (v32)
                  {
                    if (*(_BYTE *)(v2 + 82))
                      v33 = 2 * v13 - v33;
                    else
                      v33 = ((v33 ^ v13) & 1) + v13;
                  }
                  else if (*(_BYTE *)(v2 + 82))
                  {
                    v33 = 2 * (v14 - 1) - v33;
                  }
                  else
                  {
                    v33 = v14 - 1 - ((v33 ^ (v14 - 1)) & 1);
                  }
                  v32 = v33 < v13;
                }
                while (v33 < v13 || v33 >= v14);
              }
              v34 = v33 - v30;
              if (v33 - v30 < 0 || v34 >= v16)
                kd_multi_dwt_block::perform_inverse();
              v35 = *(_QWORD *)(*v18 + 8 * v34);
              if (v26)
              {
                if ((*(_BYTE *)(v35 + 6) & 2) != 0)
                  goto LABEL_43;
              }
              else if ((*(_BYTE *)(v35 + 6) & 2) == 0)
              {
LABEL_43:
                v36 = *(_QWORD *)(v35 + 8);
                goto LABEL_44;
              }
              v36 = 0;
LABEL_44:
              *(_QWORD *)(*(_QWORD *)(v2 + 128) + 8 * v29++) = v36;
              v31 += 2;
            }
            while (v29 != v28);
          }
          if (v26)
          {
            this = perform_analysis_lifting_step(v19, *(uint64_t **)(v2 + 128), v26, v26, v23, 0);
          }
          else
          {
            if (!v27)
              kd_multi_dwt_block::perform_inverse();
            this = perform_analysis_lifting_step(v19, *(uint64_t **)(v2 + 128), v27, v27, v23, 0);
          }
          v21 += 2;
          v16 = *v80;
        }
        while (*v80 > (int)v21);
        v11 = *(_DWORD *)(v2 + 84);
        v3 = v75;
        v1 = v76;
        v4 = v74;
        v12 = v77;
LABEL_51:
        ++v12;
      }
      while (v12 < v11);
LABEL_68:
      v47 = v3 + (v4 << 6);
      v48 = (int *)(v47 + 20);
      if (*(int *)(v47 + 20) >= 1)
      {
        v49 = 0;
        v50 = (_QWORD *)(v47 + 40);
        v51 = (_QWORD *)(v47 + 32);
        v52 = (_DWORD *)(v47 + 16);
        v53 = (float *)(v47 + 56);
        v54 = (float *)(v47 + 52);
        do
        {
          v55 = *(uint64_t **)(*v50 + 8 * v49);
          if (v55)
          {
            this = *v55;
            if (*v55)
            {
              v56 = *(_QWORD *)(*v51 + 8 * v49);
              if (*(_BYTE *)(v2 + 80))
              {
                this = kd_multi_line::copy(this, (kd_multi_line *)v56, -*(_DWORD *)(this + 44), -*(float *)(this + 48));
              }
              else
              {
                if (((*v52 + (_DWORD)v49) & 1) != 0)
                  v57 = *v53 * 0.5;
                else
                  v57 = *v54;
                if (*(_BYTE *)(this + 36))
                  kd_multi_dwt_block::perform_inverse();
                v58 = *(unsigned int *)(v56 + 20);
                v59 = (float)(1 << *(_DWORD *)(v56 + 40)) / (float)(v57 * (float)(1 << *(_DWORD *)(this + 40)));
                if ((*(_BYTE *)(v56 + 6) & 2) != 0 || (v60 = *(float **)(v56 + 8)) == 0)
                {
                  v62 = 0;
                  while (v59 < 16383.0)
                  {
                    v59 = v59 + v59;
                    ++v62;
                  }
                  while (v59 > 32767.0)
                  {
                    v59 = v59 * 0.5;
                    --v62;
                  }
                  if ((*(_BYTE *)(v56 + 6) & 2) != 0)
                    v63 = *(__int16 **)(v56 + 8);
                  else
                    v63 = 0;
                  if ((*(_BYTE *)(this + 6) & 2) != 0)
                    v64 = *(_WORD **)(this + 8);
                  else
                    v64 = 0;
                  v65 = vcvtmd_s64_f64(v59 + 0.5);
                  v66 = vcvtmd_s64_f64((float)(*(float *)(this + 48) * 8192.0) + 0.5);
                  if (v62 < 0)
                  {
                    if ((int)v58 >= 1)
                    {
                      v69 = -v62;
                      do
                      {
                        v70 = *v63++;
                        *v64++ = ((v70 * (_WORD)v65) << v69) - v66;
                        --v58;
                      }
                      while (v58);
                    }
                  }
                  else if ((int)v58 >= 1)
                  {
                    v67 = (1 << v62 >> 1) - (v66 << v62);
                    do
                    {
                      v68 = *v63++;
                      *v64++ = (int)(v67 + v68 * v65) >> v62;
                      --v58;
                    }
                    while (v58);
                  }
                }
                else
                {
                  if ((*(_BYTE *)(this + 6) & 2) != 0)
                    v61 = 0;
                  else
                    v61 = *(float **)(this + 8);
                  if ((int)v58 >= 1)
                  {
                    v71 = -*(float *)(this + 48);
                    do
                    {
                      v72 = *v60++;
                      *v61++ = v71 + (float)(v72 * v59);
                      --v58;
                    }
                    while (v58);
                  }
                }
              }
            }
          }
          ++v49;
        }
        while (v49 < *v48);
      }
      v73 = v1 < 2;
      v1 = v78;
    }
    while (!v73);
  }
  return this;
}

void kd_multi_null_block::~kd_multi_null_block(kd_multi_null_block *this)
{
  kd_multi_block::~kd_multi_block(this);
  JUMPOUT(0x18D761C30);
}

uint64_t kd_multi_block::propagate_bit_depths(kd_multi_block *this)
{
  return 0;
}

const char *kd_multi_block::prepare_for_inversion(kd_multi_block *this)
{
  return "Unimplemented multi-component transform block inversion procedure.";
}

void kd_multi_matrix_block::~kd_multi_matrix_block(kd_multi_matrix_block *this)
{
  kd_multi_matrix_block::~kd_multi_matrix_block(this);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = &off_1E1BB22A0;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8052888210);
  v3 = *((_QWORD *)this + 9);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8052888210);
  v4 = *((_QWORD *)this + 10);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1000C80BDFB0063);
  v5 = *((_QWORD *)this + 11);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C8052888210);
  v6 = *((_QWORD *)this + 13);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x1000C8000313F17);
  kd_multi_block::~kd_multi_block(this);
}

void kd_multi_rxform_block::~kd_multi_rxform_block(kd_multi_rxform_block *this)
{
  kd_multi_rxform_block::~kd_multi_rxform_block(this);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BB22F0;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8052888210);
  v3 = *((_QWORD *)this + 9);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8052888210);
  kd_multi_block::~kd_multi_block(this);
}

void kd_multi_dependency_block::~kd_multi_dependency_block(kd_multi_dependency_block *this)
{
  kd_multi_dependency_block::~kd_multi_dependency_block(this);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = &off_1E1BB25B0;
  v2 = *((_QWORD *)this + 9);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8052888210);
  v3 = *((_QWORD *)this + 10);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8052888210);
  v4 = *((_QWORD *)this + 11);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1000C8052888210);
  v5 = *((_QWORD *)this + 12);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C8052888210);
  v6 = *((_QWORD *)this + 13);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x1000C80BDFB0063);
  v7 = *((_QWORD *)this + 15);
  if (v7)
    MEMORY[0x18D761C18](v7, 0x1000C8052888210);
  kd_multi_block::~kd_multi_block(this);
}

void kd_multi_dwt_block::~kd_multi_dwt_block(kd_multi_dwt_block *this)
{
  kd_multi_dwt_block::~kd_multi_dwt_block(this);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)this = &off_1E1BB18F0;
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    v3 = v2 - 16;
    v4 = *(_QWORD *)(v2 - 8);
    if (v4)
    {
      v5 = v2 - 64;
      v6 = v4 << 6;
      do
      {
        kd_multi_dwt_level::~kd_multi_dwt_level((kd_multi_dwt_level *)(v5 + v6));
        v6 -= 64;
      }
      while (v6);
    }
    MEMORY[0x18D761C18](v3, 0x1080C80D9599B8ALL);
  }
  v7 = *((_QWORD *)this + 11);
  if (v7)
    MEMORY[0x18D761C18](v7, 0x1090C805C18EE7CLL);
  v8 = *((_QWORD *)this + 13);
  if (v8)
    MEMORY[0x18D761C18](v8, 0x1000C8052888210);
  v9 = *((_QWORD *)this + 14);
  if (v9)
    MEMORY[0x18D761C18](v9, 0x1000C8052888210);
  v10 = *((_QWORD *)this + 16);
  if (v10)
  {
    MEMORY[0x18D761C18](v10, 0x20C8093837F09);
    *((_QWORD *)this + 16) = 0;
  }
  kd_multi_block::~kd_multi_block(this);
}

void kd_multi_component::~kd_multi_component(kd_multi_component *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E1BB18C8;
  v2 = *((_QWORD *)this + 18);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 18) = 0;
  }
  v3 = *((_QWORD *)this + 19);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    *((_QWORD *)this + 19) = 0;
  }
  v4 = *((_QWORD *)this + 17);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1020C805730B0C9);
  *(_QWORD *)this = off_1E1BABA78;
}

{
  kd_multi_component::~kd_multi_component(this);
  JUMPOUT(0x18D761C30);
}

uint64_t kd_multi_component::do_job(uint64_t this, kdu_thread_entity *a2)
{
  uint64_t v2;
  int v3;
  _QWORD *v4;
  uint64_t v5;

  if (*(int *)(this + 120) >= 1)
  {
    v2 = this;
    v3 = 0;
    do
    {
      v4 = *(_QWORD **)(v2 + 144);
      if (v4)
      {
        v5 = 3;
      }
      else
      {
        v4 = *(_QWORD **)(v2 + 152);
        v5 = 2;
      }
      this = (*(uint64_t (**)(void))(*v4 + 8 * v5))();
      ++v3;
    }
    while (v3 < *(_DWORD *)(v2 + 120));
  }
  return this;
}

void kd_multi_block::~kd_multi_block(kd_multi_block *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E1BB00A8;
  v2 = *((_QWORD *)this + 2);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1020C80587BA0B9);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x20C8093837F09);
}

void kd_multi_dwt_level::~kd_multi_dwt_level(kd_multi_dwt_level *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 4);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x20C8093837F09);
  v3 = *((_QWORD *)this + 5);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x80C80B8603338);
}

void _cg_jinit_c_master_control(uint64_t *a1, int a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int *v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  _DWORD *v23;
  int v24;
  _DWORD *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  unsigned int v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  int v56;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v65;
  _DWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  __int128 *v72;
  __int128 *v73;
  uint64_t v74;
  __int128 v75;
  __int128 v76;
  int v77;
  uint64_t v78;
  _DWORD *v79;
  int v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84;
  _BYTE *v86;
  int v87;
  int *v88;
  int v89;
  _DWORD __b[640];
  _OWORD v91[2];
  uint64_t v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  v3 = (*(uint64_t (**)(void))a1[1])();
  a1[62] = v3;
  *(_QWORD *)v3 = prepare_for_pass;
  *(_QWORD *)(v3 + 8) = pass_startup;
  *(_QWORD *)(v3 + 16) = finish_pass_master;
  *(_DWORD *)(v3 + 28) = 0;
  v4 = *((_DWORD *)a1 + 119);
  if ((v4 - 17) <= 0xFFFFFFEF)
  {
    v5 = *a1;
    *(_DWORD *)(v5 + 40) = 7;
    *(_DWORD *)(v5 + 48) = v4;
    *(_DWORD *)(*a1 + 52) = *((_DWORD *)a1 + 119);
    (*(void (**)(uint64_t *))*a1)(a1);
    v4 = *((_DWORD *)a1 + 119);
  }
  if ((v4 - 2) > 5)
    v6 = _cg_jpeg_natural_order;
  else
    v6 = (int *)*((_QWORD *)&off_1E1BBE520 + v4 - 2);
  a1[60] = (uint64_t)v6;
  if (v4 >= 8)
    v7 = 63;
  else
    v7 = v4 * v4 - 1;
  *((_DWORD *)a1 + 122) = v7;
  v8 = *((_DWORD *)a1 + 21);
  if (!v8 || !*((_DWORD *)a1 + 20) || *((int *)a1 + 23) <= 0)
  {
    v9 = *a1;
    *(_DWORD *)(v9 + 40) = 33;
    (*(void (**)(uint64_t *))v9)(a1);
    v8 = *((_DWORD *)a1 + 21);
  }
  if (v8 > 0xFFDC || *((_DWORD *)a1 + 20) >= 0xFFDDu)
  {
    v10 = *a1;
    *(_DWORD *)(v10 + 40) = 42;
    *(_DWORD *)(v10 + 48) = 65500;
    (*(void (**)(uint64_t *))*a1)(a1);
  }
  v11 = *((_DWORD *)a1 + 22);
  if ((v11 - 13) <= 0xFFFFFFFA)
  {
    v12 = *a1;
    *(_DWORD *)(v12 + 40) = 16;
    *(_DWORD *)(v12 + 48) = v11;
    (*(void (**)(uint64_t *))*a1)(a1);
  }
  v13 = *((_DWORD *)a1 + 23);
  if (v13 >= 11)
  {
    v14 = *a1;
    *(_DWORD *)(v14 + 40) = 27;
    *(_DWORD *)(v14 + 48) = v13;
    *(_DWORD *)(*a1 + 52) = 10;
    (*(void (**)(uint64_t *))*a1)(a1);
    v13 = *((_DWORD *)a1 + 23);
  }
  a1[44] = 0x100000001;
  if (v13 < 1)
  {
    v17 = 1;
  }
  else
  {
    v15 = 0;
    v16 = (int *)(a1[13] + 12);
    v17 = 1;
    v18 = 1;
    do
    {
      v19 = *(v16 - 1);
      if ((v19 - 5) < 0xFFFFFFFC || (v20 = *v16, (*v16 - 5) <= 0xFFFFFFFB))
      {
        v21 = *a1;
        *(_DWORD *)(v21 + 40) = 19;
        (*(void (**)(uint64_t *))v21)(a1);
        v18 = *((_DWORD *)a1 + 88);
        v19 = *(v16 - 1);
        v20 = *v16;
        v17 = *((_DWORD *)a1 + 89);
        v13 = *((_DWORD *)a1 + 23);
      }
      if (v18 <= v19)
        v18 = v19;
      *((_DWORD *)a1 + 88) = v18;
      if (v17 <= v20)
        v17 = v20;
      *((_DWORD *)a1 + 89) = v17;
      ++v15;
      v16 += 24;
    }
    while (v15 < v13);
    if (v13 >= 1)
    {
      v22 = 0;
      v23 = (_DWORD *)a1[13];
      while (1)
      {
        v23[1] = v22;
        v24 = *((_DWORD *)a1 + 90);
        if (*((_DWORD *)a1 + 72))
        {
          v23[9] = v24;
          v25 = v23 + 9;
          v26 = *((_DWORD *)a1 + 91);
        }
        else
        {
          if (*((_DWORD *)a1 + 76))
            v27 = 8;
          else
            v27 = 4;
          if (v24 <= v27)
          {
            v28 = 1;
            do
            {
              v29 = 2 * v28;
              if (*((_DWORD *)a1 + 88) % (2 * v28 * v23[2]))
                break;
              v28 *= 2;
            }
            while (v29 * v24 <= v27);
          }
          else
          {
            v28 = 1;
          }
          v24 *= v28;
          v23[9] = v24;
          v25 = v23 + 9;
          v26 = *((_DWORD *)a1 + 91);
          if (v26 <= v27)
          {
            v30 = 1;
            while (1)
            {
              v32 = 2 * v30;
              if (*((_DWORD *)a1 + 89) % (2 * v30 * v23[3]))
                goto LABEL_44;
              v30 *= 2;
              if (v32 * v26 > v27)
              {
                v30 = v32;
                goto LABEL_44;
              }
            }
          }
        }
        v30 = 1;
LABEL_44:
        v31 = v30 * v26;
        v23[10] = v30 * v26;
        if (v24 <= 2 * v30 * v26)
        {
          if (v31 > 2 * v24)
            v23[10] = 2 * v24;
        }
        else
        {
          *v25 = 2 * v31;
        }
        v23[7] = jdiv_round_up((int)v23[2] * (unint64_t)*((unsigned int *)a1 + 20), *((int *)a1 + 119) * (uint64_t)*((int *)a1 + 88));
        v23[8] = jdiv_round_up((int)v23[3] * (unint64_t)*((unsigned int *)a1 + 21), *((int *)a1 + 119) * (uint64_t)*((int *)a1 + 89));
        v23[11] = jdiv_round_up((int)v23[9] * (uint64_t)(int)v23[2] * *((unsigned int *)a1 + 20), *((int *)a1 + 119) * (uint64_t)*((int *)a1 + 88));
        v23[12] = jdiv_round_up((int)v23[10] * (uint64_t)(int)v23[3] * *((unsigned int *)a1 + 21), *((int *)a1 + 119) * (uint64_t)*((int *)a1 + 89));
        v23[13] = 0;
        ++v22;
        v23 += 24;
        if (v22 >= *((_DWORD *)a1 + 23))
        {
          v17 = *((_DWORD *)a1 + 89);
          break;
        }
      }
    }
  }
  *((_DWORD *)a1 + 92) = jdiv_round_up(*((unsigned int *)a1 + 21), *((int *)a1 + 119) * (uint64_t)v17);
  if (a1[35])
  {
    v33 = (int *)a1[35];
    v92 = 0;
    memset(v91, 0, sizeof(v91));
    bzero(__b, 0xA00uLL);
    if (*((int *)a1 + 68) <= 0)
    {
      v34 = *a1;
      *(_DWORD *)(v34 + 40) = 20;
      *(_DWORD *)(v34 + 48) = 0;
      (*(void (**)(uint64_t *))*a1)(a1);
      v33 = (int *)a1[35];
    }
    if (v33[5] || v33[6] != 63)
    {
      v36 = 1;
      *((_DWORD *)a1 + 87) = 1;
      v35 = *((unsigned int *)a1 + 23);
      if ((int)v35 >= 1)
      {
        memset(__b, 255, v35 << 8);
        v36 = 1;
      }
    }
    else
    {
      *((_DWORD *)a1 + 87) = 0;
      v35 = *((unsigned int *)a1 + 23);
      if ((int)v35 >= 1)
        bzero(v91, 4 * v35);
      v36 = 0;
    }
    if (*((int *)a1 + 68) >= 1)
    {
      v84 = v3;
      v37 = 1;
      v38 = v33;
      while (1)
      {
        v39 = *v38;
        if ((v39 - 5) <= 0xFFFFFFFB
          && (v40 = *a1,
              *(_DWORD *)(v40 + 40) = 27,
              *(_DWORD *)(v40 + 48) = v39,
              *(_DWORD *)(*a1 + 52) = 4,
              (*(void (**)(uint64_t *))*a1)(a1),
              (int)v39 < 1))
        {
          v45 = 0;
        }
        else
        {
          v41 = 0;
          do
          {
            v42 = v38[v41 + 1];
            if (v42 < 0 || v42 >= *((_DWORD *)a1 + 23))
            {
              v43 = *a1;
              *(_DWORD *)(v43 + 40) = 20;
              *(_DWORD *)(v43 + 48) = v37;
              (*(void (**)(uint64_t *))*a1)(a1);
            }
            if (v41 && v42 <= v38[(v41 - 1) + 1])
            {
              v44 = *a1;
              *(_DWORD *)(v44 + 40) = 20;
              *(_DWORD *)(v44 + 48) = v37;
              (*(void (**)(uint64_t *))*a1)(a1);
            }
            ++v41;
          }
          while (v39 != v41);
          v45 = 1;
        }
        v46 = v38[5];
        v89 = v38[6];
        v47 = v38[7];
        v48 = v38[8];
        if (!*((_DWORD *)a1 + 87))
        {
          if (__PAIR64__(v89, v46) != 0x3F00000000 || v47 || v48)
          {
            v60 = *a1;
            *(_DWORD *)(v60 + 40) = 18;
            *(_DWORD *)(v60 + 48) = v37;
            (*(void (**)(uint64_t *))*a1)(a1);
          }
          if (v45)
          {
            v61 = 0;
            do
            {
              v62 = v38[v61 + 1];
              if (*((_DWORD *)v91 + v62))
              {
                v63 = *a1;
                *(_DWORD *)(v63 + 40) = 20;
                *(_DWORD *)(v63 + 48) = v37;
                (*(void (**)(uint64_t *))*a1)(a1);
              }
              *((_DWORD *)v91 + v62) = 1;
              ++v61;
            }
            while (v39 != v61);
          }
          goto LABEL_123;
        }
        if (v46 > 0x3F
          || v89 < (int)v46
          || v89 > 63
          || (v47 & 0x80000000) != 0
          || (*((int *)a1 + 22) <= 8 ? (v49 = 10) : (v49 = 13), v47 > v49 || v48 < 0 || v48 > v49))
        {
          v59 = *a1;
          *(_DWORD *)(v59 + 40) = 18;
          *(_DWORD *)(v59 + 48) = v37;
          (*(void (**)(uint64_t *))*a1)(a1);
          if ((_DWORD)v46)
          {
LABEL_90:
            if ((_DWORD)v39 == 1)
              goto LABEL_92;
LABEL_91:
            v50 = *a1;
            *(_DWORD *)(v50 + 40) = 18;
            *(_DWORD *)(v50 + 48) = v37;
            (*(void (**)(uint64_t *))*a1)(a1);
            goto LABEL_92;
          }
        }
        else if ((_DWORD)v46)
        {
          goto LABEL_90;
        }
        if (v89)
          goto LABEL_91;
LABEL_92:
        if (v45)
        {
          v51 = 0;
          v87 = v89 - v46 + 1;
          v86 = &__b[v46];
          v88 = v38;
          while (1)
          {
            v52 = v38[v51 + 1];
            if ((_DWORD)v46 && (__b[64 * v52] & 0x80000000) != 0)
            {
              v53 = *a1;
              *(_DWORD *)(v53 + 40) = 18;
              *(_DWORD *)(v53 + 48) = v37;
              (*(void (**)(uint64_t *))*a1)(a1);
            }
            v54 = v46;
            if ((int)v46 <= v89)
              break;
LABEL_98:
            ++v51;
            v46 = v54;
            v38 = v88;
            if (v51 == v39)
              goto LABEL_123;
          }
          v55 = (int *)&v86[256 * v52];
          v56 = v87;
          while (2)
          {
            if (*v55 < 0)
            {
              if (v47)
                goto LABEL_106;
            }
            else if (v47 != *v55 || v48 != v47 - 1)
            {
LABEL_106:
              v58 = *a1;
              *(_DWORD *)(v58 + 40) = 18;
              *(_DWORD *)(v58 + 48) = v37;
              (*(void (**)(uint64_t *))*a1)(a1);
            }
            *v55++ = v48;
            if (!--v56)
              goto LABEL_98;
            continue;
          }
        }
LABEL_123:
        v38 += 9;
        if (v37++ >= *((_DWORD *)a1 + 68))
        {
          v36 = *((_DWORD *)a1 + 87);
          LODWORD(v35) = *((_DWORD *)a1 + 23);
          v3 = v84;
          break;
        }
      }
    }
    if (v36)
    {
      if ((int)v35 >= 1)
      {
        v65 = 0;
        v66 = __b;
        do
        {
          if ((*v66 & 0x80000000) != 0)
          {
            v67 = *a1;
            *(_DWORD *)(v67 + 40) = 46;
            (*(void (**)(uint64_t *))v67)(a1);
            LODWORD(v35) = *((_DWORD *)a1 + 23);
          }
          v66 += 64;
          ++v65;
        }
        while (v65 < (int)v35);
      }
    }
    else if ((int)v35 >= 1)
    {
      v68 = 0;
      do
      {
        if (!*((_DWORD *)v91 + v68))
        {
          v69 = *a1;
          *(_DWORD *)(v69 + 40) = 46;
          (*(void (**)(uint64_t *))v69)(a1);
          LODWORD(v35) = *((_DWORD *)a1 + 23);
        }
        ++v68;
      }
      while (v68 < (int)v35);
    }
    if (*((int *)a1 + 119) <= 7)
    {
      if (*((int *)a1 + 68) < 1)
      {
        v71 = 0;
      }
      else
      {
        v70 = 0;
        v71 = 0;
        v72 = (__int128 *)a1[35];
        v73 = v72;
        do
        {
          if (v70 != v71)
          {
            v74 = (uint64_t)v72 + 36 * v71;
            v75 = *v73;
            v76 = v73[1];
            *(_DWORD *)(v74 + 32) = *((_DWORD *)v73 + 8);
            *(_OWORD *)v74 = v75;
            *(_OWORD *)(v74 + 16) = v76;
          }
          v77 = *((_DWORD *)a1 + 122);
          if (*((_DWORD *)v72 + 9 * v71 + 5) <= v77)
          {
            v78 = (uint64_t)v72 + 36 * v71;
            v80 = *(_DWORD *)(v78 + 24);
            v79 = (_DWORD *)(v78 + 24);
            if (v80 > v77)
              *v79 = v77;
            ++v71;
          }
          ++v70;
          v73 = (__int128 *)((char *)v73 + 36);
        }
        while (v70 < *((int *)a1 + 68));
      }
      *((_DWORD *)a1 + 68) = v71;
    }
  }
  else
  {
    *((_DWORD *)a1 + 87) = 0;
    *((_DWORD *)a1 + 68) = 1;
  }
  v81 = *((_DWORD *)a1 + 74);
  if (v81)
  {
    *((_DWORD *)a1 + 73) = 0;
  }
  else if (!*((_DWORD *)a1 + 73) && (*((_DWORD *)a1 + 87) || (*((_DWORD *)a1 + 119) - 2) < 6))
  {
    *((_DWORD *)a1 + 74) = 1;
    v82 = a2;
    if (!a2)
      goto LABEL_158;
    goto LABEL_157;
  }
  if (!a2)
  {
    *(_DWORD *)(v3 + 44) = 0;
    *(_QWORD *)(v3 + 32) = 0;
    if (v81)
      goto LABEL_160;
LABEL_162:
    v83 = *((_DWORD *)a1 + 68);
    goto LABEL_163;
  }
  if (!v81)
  {
    *(_DWORD *)(v3 + 44) = 0;
    *(_QWORD *)(v3 + 32) = 2;
    goto LABEL_162;
  }
LABEL_157:
  v82 = 1;
LABEL_158:
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 32) = v82;
  *(_DWORD *)(v3 + 36) = 0;
LABEL_160:
  v83 = 2 * *((_DWORD *)a1 + 68);
LABEL_163:
  *(_DWORD *)(v3 + 40) = v83;
}

uint64_t prepare_for_pass(uint64_t a1)
{
  _DWORD *v2;
  int v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;

  v2 = *(_DWORD **)(a1 + 496);
  v3 = v2[8];
  if (v3 == 2)
    goto LABEL_16;
  if (v3 == 1)
  {
    select_scan_parameters(a1);
    per_scan_setup(a1);
    if (*(_DWORD *)(a1 + 460) || !*(_DWORD *)(a1 + 468))
    {
      (**(void (***)(uint64_t, uint64_t))(a1 + 560))(a1, 1);
      result = (**(uint64_t (***)(uint64_t, uint64_t))(a1 + 520))(a1, 2);
      goto LABEL_21;
    }
    v7 = v2[9] + 1;
    v2[8] = 2;
    v2[9] = v7;
LABEL_16:
    if (!*(_DWORD *)(a1 + 296))
    {
      select_scan_parameters(a1);
      per_scan_setup(a1);
    }
    (**(void (***)(uint64_t, _QWORD))(a1 + 560))(a1, 0);
    (**(void (***)(uint64_t, uint64_t))(a1 + 520))(a1, 2);
    if (!v2[11])
      (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 528) + 8))(a1);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 528) + 16))(a1);
    goto LABEL_21;
  }
  if (v3)
  {
    v6 = *(_QWORD *)a1;
    *(_DWORD *)(v6 + 40) = 49;
    result = (*(uint64_t (**)(uint64_t))v6)(a1);
    goto LABEL_22;
  }
  select_scan_parameters(a1);
  per_scan_setup(a1);
  if (!*(_DWORD *)(a1 + 288))
  {
    (**(void (***)(uint64_t))(a1 + 536))(a1);
    (**(void (***)(uint64_t))(a1 + 544))(a1);
    (**(void (***)(uint64_t, _QWORD))(a1 + 512))(a1, 0);
  }
  (**(void (***)(uint64_t))(a1 + 552))(a1);
  (**(void (***)(uint64_t, _QWORD))(a1 + 560))(a1, *(unsigned int *)(a1 + 296));
  if ((int)v2[10] <= 1)
    v4 = 0;
  else
    v4 = 3;
  (**(void (***)(uint64_t, uint64_t))(a1 + 520))(a1, v4);
  result = (**(uint64_t (***)(uint64_t, _QWORD))(a1 + 504))(a1, 0);
  if (!*(_DWORD *)(a1 + 296))
  {
    v2[6] = 1;
    goto LABEL_22;
  }
LABEL_21:
  v2[6] = 0;
LABEL_22:
  v8 = v2[9];
  v9 = v2[10];
  v2[7] = v8 == v9 - 1;
  v10 = *(_QWORD *)(a1 + 16);
  if (v10)
  {
    *(_DWORD *)(v10 + 24) = v8;
    *(_DWORD *)(v10 + 28) = v9;
  }
  return result;
}

uint64_t pass_startup(uint64_t a1)
{
  *(_DWORD *)(*(_QWORD *)(a1 + 496) + 24) = 0;
  (*(void (**)(void))(*(_QWORD *)(a1 + 528) + 8))();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 528) + 16))(a1);
}

uint64_t finish_pass_master(uint64_t a1)
{
  _DWORD *v2;
  uint64_t result;
  int v4;

  v2 = *(_DWORD **)(a1 + 496);
  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 560) + 16))();
  v4 = v2[8];
  switch(v4)
  {
    case 2:
      if (*(_DWORD *)(a1 + 296))
        v2[8] = 1;
LABEL_8:
      ++v2[11];
      break;
    case 1:
      v2[8] = 2;
      break;
    case 0:
      v2[8] = 2;
      if (!*(_DWORD *)(a1 + 296))
        goto LABEL_8;
      break;
  }
  ++v2[9];
  return result;
}

uint64_t select_scan_parameters(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  _QWORD *v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;

  v1 = result;
  v2 = *(_QWORD *)(result + 280);
  if (!v2)
  {
    LODWORD(v12) = *(_DWORD *)(result + 92);
    if ((int)v12 >= 5)
    {
      v13 = *(_QWORD *)result;
      *(_DWORD *)(v13 + 40) = 27;
      *(_DWORD *)(v13 + 48) = v12;
      *(_DWORD *)(*(_QWORD *)result + 52) = 4;
      result = (**(uint64_t (***)(uint64_t))result)(result);
      LODWORD(v12) = *(_DWORD *)(v1 + 92);
    }
    *(_DWORD *)(v1 + 372) = v12;
    if ((int)v12 >= 1)
    {
      v14 = *(_QWORD *)(v1 + 104);
      v12 = v12;
      v15 = (_QWORD *)(v1 + 376);
      do
      {
        *v15++ = v14;
        v14 += 96;
        --v12;
      }
      while (v12);
    }
    goto LABEL_12;
  }
  v3 = *(_DWORD *)(*(_QWORD *)(result + 496) + 44);
  v4 = *(unsigned int *)(v2 + 36 * v3);
  *(_DWORD *)(result + 372) = v4;
  if ((int)v4 >= 1)
  {
    v5 = *(_QWORD *)(result + 104);
    v6 = (int *)(v2 + 36 * v3 + 4);
    v7 = (_QWORD *)(result + 376);
    do
    {
      v8 = *v6++;
      *v7++ = v5 + 96 * v8;
      --v4;
    }
    while (v4);
  }
  if (!*(_DWORD *)(result + 348))
  {
LABEL_12:
    v10 = 0;
    *(_DWORD *)(v1 + 460) = 0;
    *(_QWORD *)(v1 + 464) = (*(_DWORD *)(v1 + 476) * *(_DWORD *)(v1 + 476) - 1);
    goto LABEL_13;
  }
  v9 = v2 + 36 * v3;
  *(_QWORD *)(result + 460) = *(_QWORD *)(v9 + 20);
  v11 = *(_DWORD *)(v9 + 28);
  v10 = *(_DWORD *)(v9 + 32);
  *(_DWORD *)(result + 468) = v11;
LABEL_13:
  *(_DWORD *)(v1 + 472) = v10;
  return result;
}

uint64_t per_scan_setup(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  unint64_t v21;

  v1 = result;
  v2 = *(_DWORD *)(result + 372);
  if (v2 == 1)
  {
    v3 = *(_QWORD *)(result + 376);
    v4 = *(_DWORD *)(v3 + 32);
    *(_DWORD *)(result + 408) = *(_DWORD *)(v3 + 28);
    *(_DWORD *)(result + 412) = v4;
    v5 = *(_DWORD *)(v3 + 36);
    *(_DWORD *)(v3 + 64) = 1;
    *(_DWORD *)(v3 + 68) = v5;
    v6 = *(_DWORD *)(v3 + 12);
    v7 = v4 % v6;
    *(_QWORD *)(v3 + 56) = 0x100000001;
    if (!v7)
      v7 = v6;
    *(_DWORD *)(v3 + 72) = 1;
    *(_DWORD *)(v3 + 76) = v7;
    *(_QWORD *)(result + 416) = 1;
  }
  else
  {
    if ((v2 - 5) <= 0xFFFFFFFB)
    {
      v8 = *(_QWORD *)result;
      *(_DWORD *)(v8 + 40) = 27;
      *(_DWORD *)(v8 + 48) = v2;
      *(_DWORD *)(*(_QWORD *)result + 52) = 4;
      (**(void (***)(uint64_t))result)(result);
    }
    *(_DWORD *)(v1 + 408) = jdiv_round_up(*(unsigned int *)(v1 + 80), *(int *)(v1 + 476) * (uint64_t)*(int *)(v1 + 352));
    result = jdiv_round_up(*(unsigned int *)(v1 + 84), *(int *)(v1 + 476) * (uint64_t)*(int *)(v1 + 356));
    *(_QWORD *)(v1 + 412) = result;
    if (*(int *)(v1 + 372) >= 1)
    {
      v9 = 0;
      do
      {
        v10 = *(_DWORD **)(v1 + 8 * v9 + 376);
        v11 = v10[2];
        v12 = v10[3];
        v13 = v12 * v11;
        v14 = v10[8];
        v15 = v10[9] * v11;
        v10[16] = v12 * v11;
        v10[17] = v15;
        v16 = v10[7] % v11;
        v10[14] = v11;
        v10[15] = v12;
        if (v16)
          v11 = v16;
        if (v14 % v12)
          v12 = v14 % v12;
        v10[18] = v11;
        v10[19] = v12;
        if (*(_DWORD *)(v1 + 416) + v13 >= 11)
        {
          v17 = *(_QWORD *)v1;
          *(_DWORD *)(v17 + 40) = 14;
          result = (*(uint64_t (**)(uint64_t))v17)(v1);
        }
        if (v13 >= 1)
        {
          v18 = v13 + 1;
          do
          {
            v19 = *(int *)(v1 + 416);
            *(_DWORD *)(v1 + 416) = v19 + 1;
            *(_DWORD *)(v1 + 4 * v19 + 420) = v9;
            --v18;
          }
          while (v18 > 1);
        }
        ++v9;
      }
      while (v9 < *(int *)(v1 + 372));
    }
  }
  v20 = *(_DWORD *)(v1 + 320);
  if (v20 >= 1)
  {
    v21 = *(unsigned int *)(v1 + 408) * (unint64_t)v20;
    if (v21 >= 0xFFFF)
      LODWORD(v21) = 0xFFFF;
    *(_DWORD *)(v1 + 316) = v21;
  }
  return result;
}

void kdrc_overlay::~kdrc_overlay(kdrc_overlay *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  v2 = *((_QWORD *)this + 13);
  v3 = *((_QWORD *)this + 16);
  if (!v2)
  {
    *((_QWORD *)this + 15) = 0;
    goto LABEL_6;
  }
  do
  {
    v4 = v2;
    v2 = *(_QWORD *)(v2 + 24);
    *(_QWORD *)(v4 + 24) = v3;
    v3 = v4;
  }
  while (v2);
  *((_QWORD *)this + 14) = v4;
  *((_QWORD *)this + 15) = 0;
  v3 = v4;
  *((_QWORD *)this + 13) = 0;
  do
  {
    *((_QWORD *)this + 16) = *(_QWORD *)(v3 + 24);
    MEMORY[0x18D761C30]();
    v3 = *((_QWORD *)this + 16);
LABEL_6:
    *((_QWORD *)this + 14) = v3;
  }
  while (v3);
}

uint64_t kdrc_overlay::set_geometry(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, unint64_t a7, unint64_t a8, unint64_t a9)
{
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v9 = HIDWORD(a7);
  v10 = HIDWORD(a8);
  if (*(_QWORD *)(result + 24) != a2
    || *(_QWORD *)(result + 32) != a3
    || *(unsigned __int8 *)(result + 40) != a4
    || *(unsigned __int8 *)(result + 41) != a5
    || *(unsigned __int8 *)(result + 42) != a6
    || *(_QWORD *)(result + 44) != a7
    || *(_OWORD *)(result + 52) != __PAIR128__(a9, a8))
  {
    *(_QWORD *)(result + 24) = a2;
    *(_QWORD *)(result + 32) = a3;
    *(_BYTE *)(result + 40) = a4;
    *(_BYTE *)(result + 41) = a5;
    *(_BYTE *)(result + 42) = a6;
    *(_QWORD *)(result + 44) = a7;
    *(_QWORD *)(result + 52) = a8;
    *(_QWORD *)(result + 60) = a9;
    if (a4)
      LODWORD(v11) = a8;
    else
      v11 = HIDWORD(a8);
    if (a4)
    {
      v12 = HIDWORD(a7);
    }
    else
    {
      LODWORD(v10) = a8;
      LODWORD(v12) = a7;
    }
    if (a4)
      LODWORD(v9) = a7;
    v13 = *(int *)(result + 20);
    v14 = (int)v11 * (uint64_t)SHIDWORD(a3) * v13 / (int)v9;
    if ((int)v14 >= (int)((int)v10 * (uint64_t)(int)a3 * v13 / (int)v12))
      LODWORD(v14) = (int)v10 * (uint64_t)(int)a3 * v13 / (int)v12;
    *(_DWORD *)(result + 68) = v14;
    v15 = *(_QWORD *)(result + 104);
    if (v15)
    {
      v16 = *(_QWORD *)(result + 128);
      do
      {
        v17 = v15;
        v15 = *(_QWORD *)(v15 + 24);
        *(_QWORD *)(v17 + 24) = v16;
        v16 = v17;
      }
      while (v15);
      *(_QWORD *)(result + 104) = 0;
      *(_QWORD *)(result + 128) = v17;
    }
    *(_QWORD *)(result + 80) = 0;
    *(_QWORD *)(result + 88) = 0;
    *(_QWORD *)(result + 112) = 0;
    *(_QWORD *)(result + 120) = 0;
  }
  return result;
}

BOOL kdrc_overlay::set_buffer_surface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t *v26;
  uint64_t i;
  uint64_t v28;
  int v29;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t *v34;
  __int128 v36;
  uint64_t v37;
  __int128 v38;
  unint64_t v39;
  unint64_t v40;
  __int128 v41;
  __int128 v42;

  *(_QWORD *)&v42 = a3;
  *((_QWORD *)&v42 + 1) = a4;
  if (!*(_QWORD *)a1)
    kdrc_overlay::set_buffer_surface();
  if (*(int *)(a1 + 48) < 1 || *(int *)(a1 + 44) < 1 || *(int *)(a1 + 56) < 1 || *(int *)(a1 + 52) <= 0)
    kdrc_overlay::set_buffer_surface();
  v41 = *(_OWORD *)(a1 + 72);
  kdu_dims::operator&=(&v41, (int *)&v42);
  *(_QWORD *)(a1 + 88) = a2;
  *(_OWORD *)(a1 + 72) = v42;
  v9 = HIDWORD(v41) + DWORD1(v41);
  v10 = DWORD2(v41) + v41;
  v11 = DWORD1(v42);
  v12 = HIDWORD(v42) + DWORD1(v42);
  v13 = DWORD2(v42) + v42;
  if (DWORD1(v41) == DWORD1(v42) && v12 == v9)
  {
    if (v13 > (int)v41 && v13 <= v10)
    {
      v11 = DWORD1(v41);
      v14 = v42;
      v10 = v41;
      goto LABEL_21;
    }
    if (v10 <= (int)v42 || (v11 = DWORD1(v41), v14 = DWORD2(v41) + v41, v10 = DWORD2(v42) + v42, (int)v41 > (int)v42))
    {
LABEL_36:
      v39 = v42;
      v40 = DWORD2(v42) | ((unint64_t)HIDWORD(v42) << 32);
      v22 = *(_QWORD *)(a1 + 104);
      if (v22)
      {
        v23 = *(_QWORD *)(a1 + 128);
        do
        {
          v24 = v22;
          v22 = *(_QWORD *)(v22 + 24);
          *(_QWORD *)(v24 + 24) = v23;
          v23 = v24;
        }
        while (v22);
        *(_QWORD *)(a1 + 104) = 0;
        *(_QWORD *)(a1 + 128) = v24;
      }
      *(_QWORD *)(a1 + 112) = 0;
      goto LABEL_41;
    }
  }
  else
  {
    if ((_DWORD)v41 != (_DWORD)v42 || v13 != v10)
      goto LABEL_36;
    if (v12 <= SDWORD1(v41) || v12 > v9)
    {
      if (v9 <= SDWORD1(v42))
        goto LABEL_36;
      v14 = v41;
      v11 = (HIDWORD(v41) + DWORD1(v41));
      v9 = HIDWORD(v42) + DWORD1(v42);
      if (SDWORD1(v41) > SDWORD1(v42))
        goto LABEL_36;
    }
    else
    {
      v14 = v41;
      v9 = DWORD1(v41);
    }
  }
LABEL_21:
  v39 = v14 | (v11 << 32);
  v40 = (v10 - v14) | ((unint64_t)(v9 - v11) << 32);
  v15 = (uint64_t *)(a1 + 104);
  v16 = *(_QWORD *)(a1 + 104);
  if (!v16)
  {
LABEL_41:
    *(_QWORD *)(a1 + 120) = 0;
    v15 = (uint64_t *)(a1 + 104);
    goto LABEL_42;
  }
  v17 = 0;
  do
  {
    v18 = *(_QWORD *)(v16 + 24);
    if (kdu_dims::intersects((_DWORD *)(v16 + 8), &v42) && !kdu_dims::intersects((_DWORD *)(v16 + 8), &v39))
    {
      v17 = v16;
    }
    else
    {
      v19 = (_QWORD *)(v17 + 24);
      if (!v17)
        v19 = (_QWORD *)(a1 + 104);
      *v19 = v18;
      if (v16 == *(_QWORD *)(a1 + 112))
      {
        if (v18)
          kdrc_overlay::set_buffer_surface();
        *(_QWORD *)(a1 + 112) = v17;
      }
      *(_QWORD *)(v16 + 24) = *(_QWORD *)(a1 + 128);
      *(_QWORD *)(a1 + 128) = v16;
    }
    v16 = v18;
  }
  while (v18);
  v20 = *(_QWORD **)(a1 + 104);
  *(_QWORD *)(a1 + 120) = 0;
  if (!v20)
  {
LABEL_42:
    v20 = 0;
    v25 = 0;
    v21 = *(_QWORD *)(a1 + 112);
    if (!v21)
      goto LABEL_44;
    goto LABEL_43;
  }
  v21 = *(_QWORD *)(a1 + 112);
  if (!v21)
LABEL_73:
    kdrc_overlay::set_buffer_surface();
LABEL_43:
  v25 = v20;
  if (*(_QWORD *)(v21 + 24))
    goto LABEL_73;
LABEL_44:
  v26 = &v39;
  if (a5)
    v26 = (unint64_t *)&v42;
  v38 = *(_OWORD *)v26;
  if (SHIDWORD(v38) >= 1 && SDWORD2(v38) >= 1)
  {
    kdrc_overlay::map_from_compositing_grid((kdrc_overlay *)a1, (int32x2_t *)&v38, v8);
    v37 = 0;
    jpx_meta_manager::load_matches((jpx_meta_manager *)(a1 + 8), 1, (int *)(a1 + 16), 0, 0);
    for (i = 0; ; i = v37)
    {
      v37 = jpx_meta_manager::enumerate_matches((uint64_t *)(a1 + 8), i, *(unsigned int *)(a1 + 16), 0xFFFFFFFFLL, 0, v38, *((uint64_t *)&v38 + 1), *(unsigned int *)(a1 + 68), 0);
      if (!v37)
      {
        v25 = (_QWORD *)*v15;
        return v25 != 0;
      }
      v36 = 0uLL;
      *(_QWORD *)&v36 = jpx_metanode::get_bounding_box((jpx_metanode *)&v37);
      *((_QWORD *)&v36 + 1) = v28;
      kdrc_overlay::map_to_compositing_grid((int32x2_t *)a1, (int32x2_t *)&v36);
      if (kdu_dims::intersects(&v36, &v39))
        goto LABEL_51;
      if (!kdu_dims::intersects(&v36, &v42))
        continue;
      v32 = (_QWORD *)*v15;
      if (!*v15)
      {
LABEL_51:
        v29 = *(_DWORD *)(a1 + 20);
        if (SHIDWORD(v36) >= v29 || SDWORD2(v36) >= v29)
        {
          v31 = *(_QWORD *)(a1 + 128);
          if (v31)
          {
            *(_QWORD *)(a1 + 128) = *(_QWORD *)(v31 + 24);
          }
          else
          {
            v31 = operator new();
            *(_OWORD *)v31 = 0u;
            *(_OWORD *)(v31 + 16) = 0u;
            *(_BYTE *)(v31 + 32) = 0;
          }
          *(_QWORD *)(v31 + 24) = 0;
          v33 = *(_QWORD *)(a1 + 112);
          if (v33)
            v34 = (uint64_t *)(v33 + 24);
          else
            v34 = v15;
          *v34 = v31;
          *(_QWORD *)(a1 + 112) = v31;
          *(_QWORD *)v31 = v37;
          *(_OWORD *)(v31 + 8) = v36;
          *(_BYTE *)(v31 + 32) = 0;
        }
      }
      else
      {
        while (*v32 != v37)
        {
          v32 = (_QWORD *)v32[3];
          if (!v32)
            goto LABEL_51;
        }
      }
    }
  }
  return v25 != 0;
}

int32x2_t kdrc_overlay::map_from_compositing_grid(kdrc_overlay *this, int32x2_t *a2, uint64_t a3)
{
  int32x2_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int32x2_t v21;
  int32x2_t v22;
  int32x2_t result;
  int v24;
  _DWORD *exception;

  v5 = vadd_s32(*a2, *(int32x2_t *)((char *)this + 60));
  *a2 = v5;
  v6 = *((int *)this + 14);
  v7 = v5.i32[1] * (uint64_t)(int)v6;
  v8 = *((_DWORD *)this + 12);
  if (v8 <= 1)
    v9 = 1;
  else
    v9 = v8;
  if ((v7 & 0x8000000000000000) != 0)
  {
    v10 = ~v7 / v9;
    if (v10 >> 31)
      kdrc_overlay::map_from_compositing_grid((uint64_t)this, (uint64_t)a2, a3);
    LODWORD(v10) = ~(_DWORD)v10;
  }
  else
  {
    v10 = v7 / v9;
    if (v10 >> 31)
      kdrc_overlay::map_from_compositing_grid((uint64_t)this, (uint64_t)a2, a3);
  }
  v11 = *((int *)this + 13);
  v12 = v5.i32[0] * (uint64_t)(int)v11;
  LODWORD(v13) = *((_DWORD *)this + 11);
  if ((int)v13 <= 1)
    v13 = 1;
  else
    v13 = v13;
  if ((v12 & 0x8000000000000000) != 0)
  {
    v14 = ~v12 / v13;
    if (v14 >> 31)
      kdrc_overlay::map_from_compositing_grid((uint64_t)this, (uint64_t)a2, a3);
    LODWORD(v14) = ~(_DWORD)v14;
  }
  else
  {
    v14 = v12 / v13;
    if (v14 >> 31)
      kdrc_overlay::map_from_compositing_grid((uint64_t)this, (uint64_t)a2, a3);
  }
  v15 = (a2[1].i32[1] + (uint64_t)v5.i32[1]) * v6;
  if (v15 <= 0)
  {
    v17 = -v15 / v9;
    if (v17 >= 0x80000001)
      goto LABEL_30;
    v16 = -(uint64_t)v17;
  }
  else
  {
    v16 = (v15 - 1) / v9;
    if (v16 >= 0x7FFFFFFF)
      goto LABEL_30;
    LODWORD(v16) = v16 + 1;
  }
  v18 = v11 * (a2[1].i32[0] + (uint64_t)v5.i32[0]);
  if (v18 <= 0)
  {
    v20 = -v18 / v13;
    if (v20 < 0x80000001)
    {
      v19 = -(uint64_t)v20;
      goto LABEL_27;
    }
LABEL_30:
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v19 = (v18 - 1) / v13;
  if (v19 >= 0x7FFFFFFF)
    goto LABEL_30;
  LODWORD(v19) = v19 + 1;
LABEL_27:
  *a2 = (int32x2_t)(v14 | ((unint64_t)v10 << 32));
  a2[1] = (int32x2_t)((v19 - v14) | ((unint64_t)(v16 - v10) << 32));
  kdu_dims::from_apparent((int32x4_t *)a2, *((unsigned __int8 *)this + 40), *((unsigned __int8 *)this + 41), *((unsigned __int8 *)this + 42));
  v21 = *(int32x2_t *)((char *)this + 32);
  v22 = vmul_s32(*a2, v21);
  result = vmul_s32(a2[1], v21);
  *a2 = v22;
  a2[1] = result;
  v24 = v22.i32[1] - *((_DWORD *)this + 7);
  a2->i32[0] = v22.i32[0] - *((_DWORD *)this + 6);
  a2->i32[1] = v24;
  return result;
}

int32x4_t *kdrc_overlay::map_to_compositing_grid(int32x2_t *this, int32x2_t *a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int32x4_t *result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  __int32 v32;
  _DWORD *exception;

  v4 = (uint64_t)vadd_s32(*a2, this[3]);
  *a2 = (int32x2_t)v4;
  if (this[4].i32[1] <= 1)
    v5 = 1;
  else
    v5 = this[4].u32[1];
  if (v4 <= 0)
    v6 = -(int)(-HIDWORD(v4) / v5);
  else
    v6 = (HIDWORD(v4) - 1) / v5 + 1;
  v7 = a2[1].i32[1] + HIDWORD(v4);
  if (this[4].i32[0] <= 1)
    v8 = 1;
  else
    v8 = this[4].u32[0];
  if ((int)v4 <= 0)
    v9 = -(int)(-(int)v4 / v8);
  else
    v9 = ((int)v4 - 1) / v8 + 1;
  v10 = a2[1].i32[0] + v4;
  if (v7 <= 0)
    v11 = -(int)(-v7 / v5);
  else
    v11 = (v7 - 1) / v5 + 1;
  if (v10 <= 0)
    v12 = -(int)(-v10 / v8);
  else
    v12 = (v10 - 1) / v8 + 1;
  *a2 = (int32x2_t)(v9 | (unint64_t)(v6 << 32));
  a2[1] = (int32x2_t)((v12 - v9) | ((unint64_t)(v11 - v6) << 32));
  result = kdu_dims::to_apparent((int32x4_t *)a2, this[5].u8[0], this[5].u8[1], this[5].u8[2]);
  v16 = (uint64_t)*a2;
  v17 = this[6].i32[0];
  v18 = (int)HIDWORD(*(unint64_t *)a2) * (uint64_t)(int)v17;
  v19 = this[7].i32[0];
  if (v19 <= 1)
    v20 = 1;
  else
    v20 = v19;
  if ((v18 & 0x8000000000000000) != 0)
  {
    v21 = ~v18 / v20;
    if (v21 >> 31)
      kdrc_overlay::map_from_compositing_grid((uint64_t)result, v14, v15);
    LODWORD(v21) = ~(_DWORD)v21;
  }
  else
  {
    v21 = v18 / v20;
    if (v21 >> 31)
      kdrc_overlay::map_from_compositing_grid((uint64_t)result, v14, v15);
  }
  v22 = this[5].i32[1];
  v23 = (int)v16 * (uint64_t)(int)v22;
  LODWORD(v24) = this[6].i32[1];
  if ((int)v24 <= 1)
    v24 = 1;
  else
    v24 = v24;
  if ((v23 & 0x8000000000000000) != 0)
  {
    v25 = ~v23 / v24;
    if (v25 >> 31)
      kdrc_overlay::map_from_compositing_grid((uint64_t)result, v14, v15);
    LODWORD(v25) = ~(_DWORD)v25;
  }
  else
  {
    v25 = v23 / v24;
    if (v25 >> 31)
      kdrc_overlay::map_from_compositing_grid((uint64_t)result, v14, v15);
  }
  v26 = (a2[1].i32[1] + (v16 >> 32)) * v17;
  if (v26 <= 0)
  {
    v28 = -v26 / v20;
    if (v28 >= 0x80000001)
      goto LABEL_48;
    v27 = -(uint64_t)v28;
  }
  else
  {
    v27 = (v26 - 1) / v20;
    if (v27 >= 0x7FFFFFFF)
      goto LABEL_48;
    LODWORD(v27) = v27 + 1;
  }
  v29 = v22 * (a2[1].i32[0] + (uint64_t)(int)v16);
  if (v29 <= 0)
  {
    v31 = -v29 / v24;
    if (v31 < 0x80000001)
    {
      v30 = -(uint64_t)v31;
      goto LABEL_45;
    }
LABEL_48:
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v30 = (v29 - 1) / v24;
  if (v30 >= 0x7FFFFFFF)
    goto LABEL_48;
  LODWORD(v30) = v30 + 1;
LABEL_45:
  *a2 = (int32x2_t)(v25 | ((unint64_t)v21 << 32));
  a2[1] = (int32x2_t)((v30 - v25) | ((unint64_t)(v27 - v21) << 32));
  v32 = v21 - this[8].i32[0];
  a2->i32[0] = v25 - this[7].i32[1];
  a2->i32[1] = v32;
  return result;
}

uint64_t kdrc_overlay::update_config(kdrc_overlay *this, int a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  int v5;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t i;
  uint64_t result;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  __int128 v35;

  if (a2 <= 1)
    v3 = 1;
  else
    v3 = a2;
  v4 = *((_DWORD *)this + 24);
  v5 = *((_DWORD *)this + 5);
  if (v4 == (_DWORD)a3 && (_DWORD)v3 == v5)
    return 0;
  *((_DWORD *)this + 24) = a3;
  v8 = (int)v3 < v5 && *((int *)this + 21) >= 1 && *((_DWORD *)this + 20) > 0;
  *((_DWORD *)this + 5) = v3;
  if (!*((_DWORD *)this + 12) || !*((_DWORD *)this + 11) || !*((_DWORD *)this + 14) || !*((_DWORD *)this + 13))
    return 0;
  v9 = *(_QWORD *)((char *)this + 44);
  v10 = *(_QWORD *)((char *)this + 52);
  if (*((_BYTE *)this + 40))
    v11 = *(_QWORD *)((char *)this + 44);
  else
    v11 = HIDWORD(v9);
  if (*((_BYTE *)this + 40))
  {
    v9 >>= 32;
    v12 = *(_QWORD *)((char *)this + 52);
  }
  else
  {
    v12 = HIDWORD(v10);
  }
  if (*((_BYTE *)this + 40))
    v10 >>= 32;
  v13 = *((int *)this + 8);
  v14 = (int)v12 * v3 * *((int *)this + 9) / (int)v11;
  *((_DWORD *)this + 17) = v14;
  v15 = (int)v10 * v3 * v13 / (int)v9;
  if ((int)v14 > (int)v15)
    *((_DWORD *)this + 17) = v15;
  v17 = (uint64_t *)((char *)this + 104);
  v16 = *((_QWORD *)this + 13);
  *((_QWORD *)this + 15) = 0;
  if (v16)
  {
    v18 = 0;
    v19 = 0;
    do
    {
      while (1)
      {
        v20 = v16;
        if (v4 != (_DWORD)a3)
          *(_BYTE *)(v16 + 32) = 0;
        v16 = *(_QWORD *)(v16 + 24);
        if (*(_DWORD *)(v20 + 20) < (int)v3 && *(_DWORD *)(v20 + 16) < (int)v3)
          break;
        v18 = v20;
        if (!v16)
          goto LABEL_40;
      }
      v21 = (_QWORD *)(v18 + 24);
      if (!v18)
        v21 = (_QWORD *)((char *)this + 104);
      *v21 = v16;
      if (!v16)
      {
        if (v20 != *((_QWORD *)this + 14))
          kdrc_overlay::update_config();
        *((_QWORD *)this + 14) = v18;
      }
      *(_QWORD *)(v20 + 24) = *((_QWORD *)this + 16);
      *((_QWORD *)this + 16) = v20;
      v19 = 1;
    }
    while (v16);
LABEL_40:
    if (v8)
    {
      v22 = *v17;
      if (*v17)
      {
        v23 = *((_QWORD *)this + 16);
        do
        {
          v24 = v22;
          v22 = *(_QWORD *)(v22 + 24);
          *(_QWORD *)(v24 + 24) = v23;
          v23 = v24;
        }
        while (v22);
        *((_QWORD *)this + 13) = 0;
        *((_QWORD *)this + 16) = v24;
      }
      goto LABEL_46;
    }
    if ((v19 & 1) != 0)
    {
      v32 = *v17;
      if (!*v17)
        return 1;
      result = 1;
      do
      {
        *(_BYTE *)(v32 + 32) = 0;
        v32 = *(_QWORD *)(v32 + 24);
      }
      while (v32);
      return result;
    }
    return 0;
  }
  if (!v8)
    return 0;
LABEL_46:
  *((_QWORD *)this + 14) = 0;
  v35 = *(_OWORD *)((char *)this + 72);
  kdrc_overlay::map_from_compositing_grid(this, (int32x2_t *)&v35, a3);
  v34 = 0;
  jpx_meta_manager::load_matches((kdrc_overlay *)((char *)this + 8), 1, (int *)this + 4, 0, 0);
  for (i = 0; ; i = v34)
  {
    result = jpx_meta_manager::enumerate_matches((uint64_t *)this + 1, i, *((unsigned int *)this + 4), 0xFFFFFFFFLL, 0, v35, *((uint64_t *)&v35 + 1), *((unsigned int *)this + 17), 0);
    v34 = result;
    if (!result)
      break;
    v33 = 0uLL;
    *(_QWORD *)&v33 = jpx_metanode::get_bounding_box((jpx_metanode *)&v34);
    *((_QWORD *)&v33 + 1) = v27;
    kdrc_overlay::map_to_compositing_grid((int32x2_t *)this, (int32x2_t *)&v33);
    if (kdu_dims::intersects(&v33, (_DWORD *)this + 18))
    {
      v28 = *((_DWORD *)this + 5);
      if (SHIDWORD(v33) >= v28 || SDWORD2(v33) >= v28)
      {
        v29 = *((_QWORD *)this + 16);
        if (v29)
        {
          *((_QWORD *)this + 16) = *(_QWORD *)(v29 + 24);
        }
        else
        {
          v29 = operator new();
          *(_OWORD *)v29 = 0u;
          *(_OWORD *)(v29 + 16) = 0u;
          *(_BYTE *)(v29 + 32) = 0;
        }
        *(_QWORD *)(v29 + 24) = 0;
        v30 = *((_QWORD *)this + 14);
        if (v30)
          v31 = (uint64_t *)(v30 + 24);
        else
          v31 = (uint64_t *)((char *)this + 104);
        *v31 = v29;
        *((_QWORD *)this + 14) = v29;
        *(_QWORD *)v29 = v34;
        *(_OWORD *)(v29 + 8) = v33;
        *(_BYTE *)(v29 + 32) = 0;
      }
    }
  }
  return result;
}

uint64_t kdrc_overlay::process(kdrc_overlay *this, kdu_dims *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  __int128 v14;

  v3 = *((_QWORD *)this + 11);
  if (!v3)
    return 0;
  v5 = *((_QWORD *)this + 15);
  if (v5 == *((_QWORD *)this + 14))
    return 0;
  if (!v5)
  {
    v5 = *((_QWORD *)this + 13);
    *((_QWORD *)this + 15) = v5;
  }
  while (1)
  {
    if (*(_BYTE *)(v5 + 32))
    {
      v6 = *(_QWORD *)(v5 + 24);
      if (!v6)
        return 0;
      goto LABEL_11;
    }
    if (*(_DWORD *)(v5 + 20) < *((_DWORD *)this + 21))
      goto LABEL_13;
    v7 = *(_DWORD *)(v5 + 16);
    v8 = *((_DWORD *)this + 20);
    v6 = *(_QWORD *)(v5 + 24);
    if (!v6)
      break;
    if (v7 < v8)
      goto LABEL_13;
LABEL_11:
    *((_QWORD *)this + 15) = v6;
    v5 = v6;
  }
  if (v7 >= v8)
    return 0;
LABEL_13:
  v9 = (int *)((char *)this + 72);
  if (((*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)this + 40))(*(_QWORD *)this, v3, *((_QWORD *)this + 9), *((_QWORD *)this + 10), *(_QWORD *)(v5 + 8), *(_QWORD *)(v5 + 16), *((unsigned int *)this + 4)) & 1) == 0)
  {
    *(_WORD *)((char *)&v13 + 1) = *(_WORD *)((char *)this + 41);
    LOBYTE(v13) = *((_BYTE *)this + 40);
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, int, _QWORD, _QWORD, _QWORD))(**(_QWORD **)this + 48))(*(_QWORD *)this, *((_QWORD *)this + 11), *((_QWORD *)this + 9), *((_QWORD *)this + 10), *(_QWORD *)(*((_QWORD *)this + 15) + 8), *(_QWORD *)(*((_QWORD *)this + 15) + 16), *((unsigned int *)this + 4), **((_QWORD **)this + 15), *((_DWORD *)this + 24), *((_QWORD *)this + 3), *((_QWORD *)this + 4), v13, *(_QWORD *)((char *)this + 44), *(_QWORD *)((char *)this + 52), *(_QWORD *)((char *)this + 60));
  }
  v10 = *((_QWORD *)this + 15);
  v11 = 1;
  *(_BYTE *)(v10 + 32) = 1;
  v14 = *(_OWORD *)(v10 + 8);
  kdu_dims::operator&=(&v14, v9);
  *(_OWORD *)a2 = v14;
  return v11;
}

int32x4_t kdu_dims::from_apparent(int32x4_t *this, int a2, int a3, int a4)
{
  int32x4_t result;

  if (a4)
  {
    this->i32[1] = 1 - (this->i32[1] + this->i32[3]);
    if (!a3)
    {
LABEL_3:
      if (!a2)
        return result;
LABEL_7:
      result = vrev64q_s32(*this);
      *this = result;
      return result;
    }
  }
  else if (!a3)
  {
    goto LABEL_3;
  }
  this->i32[0] = 1 - (this->i32[0] + this->i32[2]);
  if (a2)
    goto LABEL_7;
  return result;
}

int32x4_t *kdrc_codestream::init(kdrc_codestream *this, kdu_compressed_source *a2)
{
  uint64_t *v3;

  if (*((_QWORD *)this + 36))
    kdrc_codestream::init();
  v3 = (uint64_t *)((char *)this + 288);
  kdu_codestream::create((kd_codestream **)this + 36, a2);
  if (*(_BYTE *)this)
  {
    kdu_codestream::set_persistent(v3);
    kdu_codestream::augment_cache_threshold((kdu_codestream *)v3, *((_DWORD *)this + 1));
  }
  return kdu_codestream::get_dims((kdu_codestream *)v3, 0xFFFFFFFF, (int32x4_t *)((char *)this + 300), 0);
}

int32x4_t *kdrc_codestream::init(uint64_t a1, jx_codestream_source *a2)
{
  kd_codestream **v3;
  kdu_compressed_source *v4;
  jx_codestream_source *v6;

  v6 = a2;
  if (*(_QWORD *)(a1 + 288))
    kdrc_codestream::init();
  v3 = (kd_codestream **)(a1 + 288);
  v4 = (kdu_compressed_source *)(a1 + 8);
  jpx_codestream_source::open_stream(&v6, (jpx_input_box *)(a1 + 8));
  kdu_codestream::create(v3, v4);
  if (*(_BYTE *)a1)
  {
    kdu_codestream::set_persistent((uint64_t *)v3);
    kdu_codestream::augment_cache_threshold((kdu_codestream *)v3, *(_DWORD *)(a1 + 4));
  }
  return kdu_codestream::get_dims((kdu_codestream *)v3, 0xFFFFFFFF, (int32x4_t *)(a1 + 300), 0);
}

int32x4_t *kdrc_codestream::init(kdrc_codestream *this, mj2_video_source *a2, uint64_t a3, uint64_t a4)
{
  kd_codestream **v7;

  if (*((_QWORD *)this + 36))
    kdrc_codestream::init();
  v7 = (kd_codestream **)((char *)this + 288);
  (*(void (**)(mj2_video_source *, uint64_t))(*(_QWORD *)a2 + 104))(a2, a3);
  (*(void (**)(mj2_video_source *, uint64_t, char *))(*(_QWORD *)a2 + 168))(a2, a4, (char *)this + 8);
  kdu_codestream::create(v7, (kdrc_codestream *)((char *)this + 8));
  if (*(_BYTE *)this)
  {
    kdu_codestream::set_persistent((uint64_t *)v7);
    kdu_codestream::augment_cache_threshold((kdu_codestream *)v7, *((_DWORD *)this + 1));
  }
  return kdu_codestream::get_dims((kdu_codestream *)v7, 0xFFFFFFFF, (int32x4_t *)((char *)this + 300), 0);
}

uint64_t kdrc_codestream::restart(kdrc_codestream *this, mj2_video_source *a2, uint64_t a3, uint64_t a4)
{
  kd_codestream **v7;
  kdu_compressed_source *v8;

  if (!*((_QWORD *)this + 36))
    kdrc_codestream::restart();
  v7 = (kd_codestream **)((char *)this + 288);
  v8 = (kdrc_codestream *)((char *)this + 8);
  jpx_input_box::close((kdrc_codestream *)((char *)this + 8));
  (*(void (**)(mj2_video_source *, uint64_t))(*(_QWORD *)a2 + 104))(a2, a3);
  (*(void (**)(mj2_video_source *, uint64_t, kdu_compressed_source *))(*(_QWORD *)a2 + 168))(a2, a4, v8);
  kdu_codestream::restart(v7, v8);
  return 1;
}

uint64_t kdrc_codestream::attach(kdrc_codestream *this, kdrc_stream *a2)
{
  uint64_t v3;
  uint64_t *v4;

  if (*((_QWORD *)a2 + 142))
    kdrc_codestream::attach();
  v3 = *((_QWORD *)this + 40);
  *((_QWORD *)a2 + 143) = v3;
  *((_QWORD *)a2 + 144) = 0;
  if (v3)
  {
    if (*(_QWORD *)(v3 + 1152))
      kdrc_codestream::attach();
    *(_QWORD *)(v3 + 1152) = a2;
    *((_QWORD *)this + 40) = a2;
    *((_QWORD *)a2 + 142) = this;
    do
    {
      if (*(_BYTE *)(v3 + 1068))
      {
        kdu_region_decompressor::finish((kdu_region_decompressor *)(v3 + 120));
        *(_BYTE *)(*(_QWORD *)(v3 + 1136) + 296) = 0;
        *(_BYTE *)(v3 + 1068) = 0;
      }
      v3 = *(_QWORD *)(v3 + 1144);
    }
    while (v3);
  }
  else
  {
    *((_QWORD *)this + 40) = a2;
    *((_QWORD *)a2 + 142) = this;
  }
  if (*((_BYTE *)this + 296))
    kdrc_codestream::attach();
  v4 = (uint64_t *)((char *)this + 288);
  kdu_codestream::change_appearance(v4, 0, 0, 0);
  return kdu_codestream::apply_input_restrictions((uint64_t)v4, 0, 0, 0, 0, 0, 0);
}

double kdrc_codestream::detach(kdrc_codestream *this, kdrc_codestream **a2)
{
  kdrc_codestream *v2;
  kdrc_stream *v3;
  kdrc_codestream *v4;
  double result;

  if (a2[142] != this)
    kdrc_codestream::detach();
  v2 = a2[144];
  v3 = (kdrc_stream *)*((_QWORD *)this + 40);
  if (!v2)
  {
    if (v3 != (kdrc_stream *)a2)
      kdrc_codestream::detach();
    v4 = a2[143];
    *((_QWORD *)this + 40) = v4;
    if (!v4)
    {
      a2[142] = 0;
      a2[143] = 0;
      a2[144] = 0;
      goto LABEL_13;
    }
    *((_QWORD *)v4 + 144) = 0;
    v3 = v4;
    goto LABEL_9;
  }
  if (v3 == (kdrc_stream *)a2)
    kdrc_codestream::detach();
  *((_QWORD *)v2 + 143) = a2[143];
  v4 = a2[143];
  if (v4)
LABEL_9:
    *((_QWORD *)v4 + 144) = a2[144];
  result = 0.0;
  *((_OWORD *)a2 + 71) = 0u;
  a2[144] = 0;
  if (!v3)
  {
LABEL_13:
    kdrc_codestream::~kdrc_codestream(this);
    JUMPOUT(0x18D761C30);
  }
  return result;
}

uint64_t kdrc_codestream::move_to_head(uint64_t this, kdrc_stream *a2)
{
  kdrc_stream *v2;
  uint64_t v3;
  uint64_t v4;
  kdrc_stream *v5;
  kdrc_stream *v6;

  if (*((_QWORD *)a2 + 142) != this)
    kdrc_codestream::move_to_head();
  v2 = a2;
  v3 = this;
  v4 = *((_QWORD *)a2 + 144);
  v5 = *(kdrc_stream **)(this + 320);
  if (v4)
  {
    if (v5 == a2)
      kdrc_codestream::move_to_head();
    *(_QWORD *)(v4 + 1144) = *((_QWORD *)a2 + 143);
    v6 = (kdrc_stream *)*((_QWORD *)a2 + 143);
    if (!v6)
      goto LABEL_10;
  }
  else
  {
    if (v5 != a2)
      kdrc_codestream::move_to_head();
    v6 = (kdrc_stream *)*((_QWORD *)a2 + 143);
    *(_QWORD *)(this + 320) = v6;
    if (!v6)
    {
      *((_QWORD *)a2 + 143) = 0;
      *((_QWORD *)a2 + 144) = 0;
      goto LABEL_14;
    }
    *((_QWORD *)v6 + 144) = 0;
    v5 = v6;
  }
  *((_QWORD *)v6 + 144) = *((_QWORD *)a2 + 144);
LABEL_10:
  *((_QWORD *)a2 + 143) = v5;
  *((_QWORD *)a2 + 144) = 0;
  if (v5)
  {
    if (*((_QWORD *)v5 + 144))
      kdrc_codestream::move_to_head();
    *((_QWORD *)v5 + 144) = a2;
  }
LABEL_14:
  *(_QWORD *)(this + 320) = a2;
  do
  {
    if (*((_BYTE *)v2 + 1068))
    {
      this = kdu_region_decompressor::finish((kdrc_stream *)((char *)v2 + 120));
      *(_BYTE *)(*((_QWORD *)v2 + 142) + 296) = 0;
      *((_BYTE *)v2 + 1068) = 0;
    }
    v2 = (kdrc_stream *)*((_QWORD *)v2 + 143);
  }
  while (v2);
  if (*(_BYTE *)(v3 + 296))
    kdrc_codestream::move_to_head();
  return this;
}

uint64_t kdrc_codestream::move_to_tail(uint64_t this, kdrc_stream *a2)
{
  kdrc_stream *v2;
  uint64_t v3;
  uint64_t v4;
  kdrc_stream **v5;
  kdrc_stream *v6;
  kdrc_stream *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;

  if (*((_QWORD *)a2 + 142) != this)
    kdrc_codestream::move_to_tail();
  v2 = a2;
  v3 = this;
  v4 = *((_QWORD *)a2 + 144);
  v5 = (kdrc_stream **)(this + 320);
  v6 = *(kdrc_stream **)(this + 320);
  if (v4)
  {
    if (v6 == a2)
      kdrc_codestream::move_to_tail();
    *(_QWORD *)(v4 + 1144) = *((_QWORD *)a2 + 143);
    v7 = (kdrc_stream *)*((_QWORD *)a2 + 143);
    if (!v7)
      goto LABEL_11;
LABEL_10:
    *((_QWORD *)v7 + 144) = *((_QWORD *)a2 + 144);
    goto LABEL_11;
  }
  if (v6 != a2)
    kdrc_codestream::move_to_tail();
  v7 = (kdrc_stream *)*((_QWORD *)a2 + 143);
  *v5 = v7;
  if (v7)
  {
    *((_QWORD *)v7 + 144) = 0;
    goto LABEL_10;
  }
LABEL_11:
  v8 = 0;
  v9 = (_QWORD *)(this + 320);
  do
  {
    v10 = v8;
    v8 = *v9;
    v9 = (_QWORD *)(*v9 + 1144);
  }
  while (v8);
  *((_QWORD *)a2 + 144) = v10;
  *((_QWORD *)a2 + 143) = 0;
  if (v10)
  {
    *(_QWORD *)(v10 + 1144) = a2;
    v2 = *v5;
    if (!*v5)
      goto LABEL_20;
  }
  else
  {
    *v5 = a2;
  }
  do
  {
    if (*((_BYTE *)v2 + 1068))
    {
      this = kdu_region_decompressor::finish((kdrc_stream *)((char *)v2 + 120));
      *(_BYTE *)(*((_QWORD *)v2 + 142) + 296) = 0;
      *((_BYTE *)v2 + 1068) = 0;
    }
    v2 = (kdrc_stream *)*((_QWORD *)v2 + 143);
  }
  while (v2);
LABEL_20:
  if (*(_BYTE *)(v3 + 296))
    kdrc_codestream::move_to_tail();
  return this;
}

uint64_t kdrc_stream::kdrc_stream(uint64_t a1, uint64_t a2, char a3, int a4, uint64_t a5, uint64_t a6)
{
  kdu_channel_mapping::kdu_channel_mapping((kdu_channel_mapping *)(a1 + 64));
  kdu_region_decompressor::kdu_region_decompressor((kdu_region_decompressor *)(a1 + 120));
  *(_OWORD *)(a1 + 1052) = 0u;
  bzero((void *)(a1 + 376), 0x210uLL);
  *(_OWORD *)(a1 + 936) = 0u;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_OWORD *)(a1 + 920) = 0u;
  *(_OWORD *)(a1 + 972) = 0u;
  *(_OWORD *)(a1 + 988) = 0u;
  *(_OWORD *)(a1 + 1004) = 0u;
  *(_OWORD *)(a1 + 1020) = 0u;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  *(_QWORD *)(a1 + 32) = a5;
  *(_QWORD *)(a1 + 40) = a6;
  *(_WORD *)(a1 + 9) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 56) = 0x10000;
  *(_BYTE *)(a1 + 1068) = 0;
  *(_BYTE *)(a1 + 909) = 0;
  *(_QWORD *)(a1 + 1040) = 0;
  *(_BYTE *)(a1 + 1048) = 1;
  *(_BYTE *)(a1 + 1124) = 0;
  *(_DWORD *)(a1 + 1120) = 256;
  *(_QWORD *)(a1 + 1104) = -1;
  *(_QWORD *)(a1 + 1112) = 0;
  *(_OWORD *)(a1 + 1128) = 0u;
  *(_OWORD *)(a1 + 1144) = 0u;
  *(_OWORD *)(a1 + 360) = xmmword_18820E8F0;
  return a1;
}

void sub_187F77D38(_Unwind_Exception *a1)
{
  j2_colour_converter **v1;

  kdu_channel_mapping::~kdu_channel_mapping(v1);
  _Unwind_Resume(a1);
}

void kdrc_stream::~kdrc_stream(kdrc_stream *this)
{
  kdrc_codestream *v2;
  kdrc_overlay *v3;

  if (*((_BYTE *)this + 1068))
  {
    kdu_region_decompressor::finish((kdrc_stream *)((char *)this + 120));
    v2 = (kdrc_codestream *)*((_QWORD *)this + 142);
    *((_BYTE *)v2 + 296) = 0;
    *((_BYTE *)this + 1068) = 0;
  }
  else
  {
    v2 = (kdrc_codestream *)*((_QWORD *)this + 142);
    if (!v2)
      goto LABEL_5;
  }
  kdrc_codestream::detach(v2, (kdrc_codestream **)this);
  *((_QWORD *)this + 142) = 0;
LABEL_5:
  v3 = (kdrc_overlay *)*((_QWORD *)this + 6);
  if (v3)
  {
    kdrc_overlay::~kdrc_overlay(v3);
    MEMORY[0x18D761C30]();
  }
  kdu_region_decompressor::~kdu_region_decompressor((kdrc_stream *)((char *)this + 120));
  kdu_channel_mapping::~kdu_channel_mapping((j2_colour_converter **)this + 8);
}

double kdrc_stream::init(kdrc_stream *this, kdu_compressed_source *a2, kdrc_codestream **a3)
{
  uint64_t v5;
  uint64_t v7;
  int v8;
  int v9;
  double result;

  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  if (*((_QWORD *)this + 6))
    kdrc_stream::init();
  *(_WORD *)((char *)this + 9) = 0;
  *((_OWORD *)this + 69) = 0u;
  if (*((_QWORD *)this + 142))
    kdrc_stream::init();
  if (a3)
  {
    kdrc_codestream::attach(a3[142], this);
    v5 = *((_QWORD *)this + 142);
    if ((kdrc_codestream *)v5 != a3[142])
      kdrc_stream::init();
  }
  else
  {
    v5 = operator new();
    v7 = *((unsigned __int8 *)this + 8);
    v8 = *((_DWORD *)this + 3);
    jpx_input_box::jpx_input_box((jpx_input_box *)(v5 + 8));
    *(_QWORD *)(v5 + 288) = 0;
    *(_QWORD *)(v5 + 308) = 0;
    *(_QWORD *)(v5 + 300) = 0;
    *(_QWORD *)(v5 + 320) = 0;
    *(_BYTE *)(v5 + 296) = 0;
    *(_BYTE *)v5 = v7;
    *(_DWORD *)(v5 + 4) = v8;
    kdrc_codestream::init((kdrc_codestream *)v5, a2);
    kdrc_codestream::attach((kdrc_codestream *)v5, this);
    if (*((_QWORD *)this + 142) != v5)
      kdrc_stream::init();
  }
  v9 = -1;
  *((_DWORD *)this + 90) = -1;
  *((_DWORD *)this + 93) = 0;
  kdu_channel_mapping::configure((kdrc_stream *)((char *)this + 64), *(unsigned int **)(v5 + 288));
  if (*((int *)this + 16) >= 1)
    v9 = **((_DWORD **)this + 9);
  *((_DWORD *)this + 91) = v9;
  *((_DWORD *)this + 92) = v9;
  *((_DWORD *)this + 226) = kdu_codestream::get_min_dwt_levels((kdu_codestream *)(*((_QWORD *)this + 142) + 288));
  kdrc_stream::configure_subsampling(this);
  *((_BYTE *)this + 908) = kdu_codestream::can_flip((kdu_codestream *)(*((_QWORD *)this + 142) + 288));
  *((_BYTE *)this + 1068) = 0;
  *((_BYTE *)this + 909) = 0;
  *(_QWORD *)&result = kdrc_stream::invalidate_surface((__n128 *)this).n128_u64[0];
  return result;
}

void sub_187F77F38(void *a1)
{
  kdrc_codestream *v1;

  __cxa_begin_catch(a1);
  kdrc_codestream::~kdrc_codestream(v1);
  MEMORY[0x18D761C30]();
  __cxa_rethrow();
}

void sub_187F77F60(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void kdrc_stream::configure_subsampling(kdrc_stream *this)
{
  int v2;
  uint64_t v3;
  int num_components;
  char *v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t i;
  int v10;
  unint64_t v12;

  if ((*((_DWORD *)this + 92) & 0x80000000) != 0)
    kdrc_stream::configure_subsampling();
  v2 = *((_DWORD *)this + 226);
  if (v2 < 33)
  {
    if (v2 < 0)
      return;
  }
  else
  {
    v2 = 32;
    *((_DWORD *)this + 226) = 32;
  }
  v3 = v2;
  do
  {
    kdu_codestream::apply_input_restrictions(*((_QWORD *)this + 142) + 288, 0, 0, v3, 0, 0, *((_DWORD *)this + 93));
    if (v3 == *((_DWORD *)this + 226) && (*((_DWORD *)this + 90) & 0x80000000) == 0)
    {
      num_components = kdu_codestream::get_num_components((unsigned int **)(*((_QWORD *)this + 142) + 288), 1);
      if (num_components <= *((_DWORD *)this + 90))
      {
        *((_DWORD *)this + 92) = num_components - 1;
        *((_DWORD *)this + 90) = num_components - 1;
      }
    }
    v12 = 0;
    kdu_codestream::get_subsampling((kd_codestream **)(*((_QWORD *)this + 142) + 288), *((_DWORD *)this + 92), (uint64_t)&v12, 1);
    v5 = (char *)this + 8 * v3;
    v6 = v12;
    *((_QWORD *)v5 + 47) = v12;
    v7 = HIDWORD(v6);
    if ((*((_DWORD *)this + 90) & 0x80000000) != 0)
    {
      v8 = *((_DWORD *)this + 16);
      if (v8 >= 1)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_DWORD *)(*((_QWORD *)this + 9) + 4 * i);
          if (v10 != *((_DWORD *)this + 92))
          {
            kdu_codestream::get_subsampling((kd_codestream **)(*((_QWORD *)this + 142) + 288), v10, (uint64_t)&v12, 1);
            if (SHIDWORD(v12) >= (int)v7)
              v7 = v7;
            else
              v7 = HIDWORD(v12);
            if ((int)v12 < (int)v6)
              LODWORD(v6) = v12;
            v8 = *((_DWORD *)this + 16);
          }
        }
      }
    }
    *((_QWORD *)v5 + 80) = v6 | (v7 << 32);
  }
  while (v3-- > 0);
}

__n128 kdrc_stream::invalidate_surface(__n128 *this)
{
  __n128 *v2;
  __n128 result;

  v2 = (__n128 *)((char *)this + 1020);
  if (this[66].n128_u8[12])
  {
    kdu_region_decompressor::finish((kdu_region_decompressor *)&this[7].n128_i8[8]);
    *(_BYTE *)(this[71].n128_u64[0] + 296) = 0;
    this[66].n128_u8[12] = 0;
  }
  v2[2].n128_u64[0] = v2->n128_u64[0];
  v2[2].n128_u64[1] = 0;
  result = v2[2];
  this[68] = result;
  this[67] = result;
  this[70].n128_u8[4] = 0;
  this[70].n128_u32[0] = 256;
  return result;
}

double kdrc_stream::init(uint64_t a1, jx_codestream_source *a2, uint64_t a3, jpx_source *a4, int a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  char v14;
  int v15;
  int v16;
  int v17;
  int v18;
  j2_colour *v19;
  int v20;
  int v21;
  int precedence;
  int v24;
  int v25;
  int v26;
  double result;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  jx_codestream_source *v36;
  char v37[16];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v35 = a3;
  v36 = a2;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  if (*(_QWORD *)(a1 + 48))
    kdrc_stream::init();
  *(_DWORD *)(a1 + 1104) = jpx_codestream_source::get_codestream_id((jpx_codestream_source *)&v36);
  v10 = operator new();
  v11 = jpx_source::access_meta_manager(a4);
  v12 = *(_DWORD *)(a1 + 1104);
  *(_QWORD *)(v10 + 24) = 0;
  *(_QWORD *)(v10 + 32) = 0;
  *(_QWORD *)(v10 + 60) = 0;
  *(_QWORD *)v10 = 0;
  *(_QWORD *)(v10 + 8) = v11;
  *(_DWORD *)(v10 + 16) = v12;
  *(_DWORD *)(v10 + 20) = 8;
  *(_QWORD *)(v10 + 52) = 0;
  *(_QWORD *)(v10 + 44) = 0;
  *(_QWORD *)(v10 + 80) = 0;
  *(_QWORD *)(v10 + 88) = 0;
  *(_QWORD *)(v10 + 72) = 0;
  *(_DWORD *)(v10 + 96) = 0;
  *(_OWORD *)(v10 + 104) = 0u;
  *(_OWORD *)(v10 + 120) = 0u;
  *(_QWORD *)(a1 + 48) = v10;
  *(_DWORD *)(a1 + 1108) = jpx_layer_source::get_layer_id((jpx_layer_source *)&v35);
  *(_QWORD *)(a1 + 1112) = 0;
  *(_BYTE *)(a1 + 9) = a5;
  *(_BYTE *)(a1 + 10) = 0;
  if (*(_QWORD *)(a1 + 1136))
    kdrc_stream::init();
  if (a6)
  {
    kdrc_codestream::attach(*(kdrc_codestream **)(a6 + 1136), (kdrc_stream *)a1);
    if (*(_QWORD *)(a1 + 1136) != *(_QWORD *)(a6 + 1136))
      kdrc_stream::init();
  }
  else
  {
    v13 = operator new();
    v14 = *(_BYTE *)(a1 + 8);
    v15 = *(_DWORD *)(a1 + 12);
    jpx_input_box::jpx_input_box((jpx_input_box *)(v13 + 8));
    *(_QWORD *)(v13 + 288) = 0;
    *(_QWORD *)(v13 + 308) = 0;
    *(_QWORD *)(v13 + 300) = 0;
    *(_QWORD *)(v13 + 320) = 0;
    *(_BYTE *)(v13 + 296) = 0;
    *(_BYTE *)v13 = v14;
    *(_DWORD *)(v13 + 4) = v15;
    kdrc_codestream::init(v13, v36);
    kdrc_codestream::attach((kdrc_codestream *)v13, (kdrc_stream *)a1);
    if (*(_QWORD *)(a1 + 1136) != v13)
      kdrc_stream::init();
  }
  *(_DWORD *)(a1 + 360) = -1;
  *(_DWORD *)(a1 + 372) = 0;
  v30 = jpx_layer_source::access_channels((jpx_layer_source *)&v35);
  v29 = jpx_codestream_source::access_palette((jpx_codestream_source *)&v36);
  v28 = jpx_codestream_source::access_dimensions(&v36, 0);
  if (a5)
  {
    kdu_channel_mapping::clear((kdu_channel_mapping *)(a1 + 64));
    if ((kdu_channel_mapping::add_alpha_to_configuration(a1 + 64, v30, *(_DWORD *)(a1 + 1104), v29, (uint64_t)v28, 1) & 1) == 0)
    {
      if (!kdu_channel_mapping::add_alpha_to_configuration(a1 + 64, v30, *(_DWORD *)(a1 + 1104), v29, (uint64_t)v28, 0))
      {
        v34 = 0;
        v32 = 0u;
        v33 = 0u;
        kdu_error::kdu_error((kdu_error *)&v32, "Error in Kakadu Region Compositor:\n");
        (*(void (**)(__int128 *, const char *))(v32 + 16))(&v32, "Complex opacity representation for compositing layer (index, starting from 0, equals ");
        v41 = 0u;
        v39 = 0u;
        v40 = 0u;
        *(_OWORD *)v37 = 0u;
        v38 = 0u;
        if (BYTE8(v32))
          sprintf(v37, "%x");
        else
          sprintf(v37, "%d");
        (*(void (**)(__int128 *, char *))(v32 + 16))(&v32, v37);
        (*(void (**)(__int128 *, const char *))(v32 + 16))(&v32, ") cannot be implemented without the inclusion of multiple distinct alpha blending channels.");
        kdu_error::~kdu_error((kdu_error *)&v32);
      }
      goto LABEL_35;
    }
LABEL_33:
    v24 = 1;
    goto LABEL_37;
  }
  v16 = 0;
  v17 = 0;
  v31 = 0;
  v18 = 128;
  do
  {
    v19 = 0;
    v20 = 0;
    v21 = -10000;
    while (1)
    {
      v31 = jpx_layer_source::access_colour((jpx_layer_source *)&v35, v20);
      if (!v31)
        break;
      precedence = jp2_colour::get_precedence((jp2_colour *)&v31);
      ++v20;
      if (precedence < v18)
      {
        *(_DWORD *)v37 = 0;
        jp2_colour::get_icc_profile((jp2_colour *)&v31, (int *)v37);
        if (*(int *)v37 > 0 && v16 == 0)
        {
          v19 = (j2_colour *)v31;
          v17 = *(_DWORD *)v37;
        }
        else if (precedence > v21 && !v17)
        {
          v19 = (j2_colour *)v31;
          v21 = precedence;
        }
      }
    }
    if (!v19)
    {
      v34 = 0;
      v32 = 0u;
      v33 = 0u;
      kdu_error::kdu_error((kdu_error *)&v32, "Error in Kakadu Region Compositor:\n");
      (*(void (**)(__int128 *, const char *))(v32 + 16))(&v32, "Unable to find any colour description which can be used by the present implementation to render compositing layer (index, starting from 0, equals ");
      v41 = 0u;
      v39 = 0u;
      v40 = 0u;
      *(_OWORD *)v37 = 0u;
      v38 = 0u;
      if (BYTE8(v32))
        sprintf(v37, "%x");
      else
        sprintf(v37, "%d");
      (*(void (**)(__int128 *, char *))(v32 + 16))(&v32, v37);
      (*(void (**)(__int128 *, const char *))(v32 + 16))(&v32, ") to sRGB.");
      kdu_error::~kdu_error((kdu_error *)&v32);
    }
    ++v16;
    v18 = v21;
  }
  while (!kdu_channel_mapping::configure((j2_colour_converter **)(a1 + 64), v19, v30, *(_DWORD *)(a1 + 1104), v29, (uint64_t)v28));
  if ((kdu_channel_mapping::add_alpha_to_configuration(a1 + 64, v30, *(_DWORD *)(a1 + 1104), v29, (uint64_t)v28, 1) & 1) != 0)
    goto LABEL_33;
  if (kdu_channel_mapping::add_alpha_to_configuration(a1 + 64, v30, *(_DWORD *)(a1 + 1104), v29, (uint64_t)v28, 0))
  {
LABEL_35:
    v24 = 1;
    *(_BYTE *)(a1 + 10) = 1;
    goto LABEL_37;
  }
  v24 = 0;
LABEL_37:
  v25 = *(_DWORD *)(a1 + 64);
  if (v25 != *(_DWORD *)(a1 + 68) + v24)
    kdrc_stream::init();
  if (v25 < 1)
    v26 = -1;
  else
    v26 = **(_DWORD **)(a1 + 72);
  *(_DWORD *)(a1 + 364) = v26;
  *(_DWORD *)(a1 + 368) = v26;
  *(_DWORD *)(a1 + 904) = kdu_codestream::get_min_dwt_levels((kdu_codestream *)(*(_QWORD *)(a1 + 1136) + 288));
  kdrc_stream::configure_subsampling((kdrc_stream *)a1);
  *(_BYTE *)(a1 + 908) = kdu_codestream::can_flip((kdu_codestream *)(*(_QWORD *)(a1 + 1136) + 288));
  *(_BYTE *)(a1 + 1068) = 0;
  *(_BYTE *)(a1 + 909) = 0;
  *(_QWORD *)&result = kdrc_stream::invalidate_surface((__n128 *)a1).n128_u64[0];
  return result;
}

void sub_187F78688(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F78698(void *a1, int a2)
{
  kdrc_codestream *v2;

  if (a2)
  {
    __cxa_begin_catch(a1);
    kdrc_codestream::~kdrc_codestream(v2);
    MEMORY[0x18D761C30]();
    __cxa_rethrow();
  }
  sub_187F78738();
}

void sub_187F786CC()
{
  __cxa_end_catch();
  sub_187F78738();
}

void sub_187F786D8()
{
  uint64_t v0;

  MEMORY[0x18D761C30](v0, 0x10B0C40F8FFDE3CLL);
  sub_187F78738();
}

void sub_187F78714(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F78724(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  sub_187F78738();
}

void sub_187F78738()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

double kdrc_stream::init(kdrc_stream *this, mj2_video_source *a2, uint64_t a3, uint64_t a4, kdrc_codestream **a5)
{
  int v10;
  _QWORD *v11;
  uint64_t v12;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  j2_colour *v18;
  int v19;
  double result;
  _OWORD v21[2];
  uint64_t v22;
  char v23[16];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a2;
  *((_DWORD *)this + 6) = a3;
  *((_DWORD *)this + 7) = a4;
  if (*((_QWORD *)this + 6))
    kdrc_stream::init();
  *(_WORD *)((char *)this + 9) = 0;
  if (a4 > 1
    || (v10 = (*(uint64_t (**)(mj2_video_source *))(*(_QWORD *)a2 + 80))(a2), (_DWORD)a4) && !v10)
  {
    *(_QWORD *)&v25 = 0;
    *(_OWORD *)v23 = 0u;
    v24 = 0u;
    kdu_error::kdu_error((kdu_error *)v23, "Error in Kakadu Region Compositor:\n");
    kdu_error::~kdu_error((kdu_error *)v23);
  }
  (*(void (**)(mj2_video_source *, uint64_t))(*(_QWORD *)a2 + 104))(a2, a3);
  *((_DWORD *)this + 276) = mj2_video_source::get_stream_idx(a2, a4);
  *((_DWORD *)this + 277) = mj2_video_source::get_track_idx(a2) - 1;
  *((_QWORD *)this + 139) = 0;
  if (*((_QWORD *)this + 142))
    kdrc_stream::init();
  if (a5)
  {
    kdrc_codestream::attach(a5[142], this);
    v11 = a5 + 142;
    v12 = *((_QWORD *)this + 142);
    if (v12 != *v11)
      kdrc_stream::init();
  }
  else
  {
    v12 = operator new();
    v13 = *((_BYTE *)this + 8);
    v14 = *((_DWORD *)this + 3);
    jpx_input_box::jpx_input_box((jpx_input_box *)(v12 + 8));
    *(_QWORD *)(v12 + 288) = 0;
    *(_QWORD *)(v12 + 308) = 0;
    *(_QWORD *)(v12 + 300) = 0;
    *(_QWORD *)(v12 + 320) = 0;
    *(_BYTE *)(v12 + 296) = 0;
    *(_BYTE *)v12 = v13;
    *(_DWORD *)(v12 + 4) = v14;
    kdrc_codestream::init((kdrc_codestream *)v12, a2, a3, a4);
    kdrc_codestream::attach((kdrc_codestream *)v12, this);
    if (*((_QWORD *)this + 142) != v12)
      kdrc_stream::init();
  }
  kdu_codestream::enable_restart((uint64_t *)(v12 + 288));
  *((_DWORD *)this + 90) = -1;
  *((_DWORD *)this + 93) = 0;
  v15 = mj2_video_source::access_channels(a2);
  v16 = mj2_video_source::access_palette(a2);
  v17 = mj2_video_source::access_dimensions(a2);
  v18 = (j2_colour *)mj2_video_source::access_colour(a2);
  if ((kdu_channel_mapping::configure((j2_colour_converter **)this + 8, v18, v15, 0, v16, v17) & 1) == 0)
  {
    v22 = 0;
    memset(v21, 0, sizeof(v21));
    kdu_error::kdu_error((kdu_error *)v21, "Error in Kakadu Region Compositor:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v21[0] + 16))(v21, "Unable to find any colour description which can be used by the present implementation to render MJ2 track (index, starting from 0, equals ");
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    *(_OWORD *)v23 = 0u;
    if (BYTE8(v21[0]))
      sprintf(v23, "%x");
    else
      sprintf(v23, "%d");
    (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v21[0] + 16))(v21, v23);
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v21[0] + 16))(v21, ") to sRGB.");
    kdu_error::~kdu_error((kdu_error *)v21);
  }
  if (mj2_video_source::get_graphics_mode(a2) == 256)
  {
    kdu_channel_mapping::add_alpha_to_configuration((uint64_t)this + 64, v15, 0, v16, v17, 1);
  }
  else if (mj2_video_source::get_graphics_mode(a2) == 257
         && kdu_channel_mapping::add_alpha_to_configuration((uint64_t)this + 64, v15, 0, v16, v17, 0))
  {
    *((_BYTE *)this + 10) = 1;
  }
  if (*((int *)this + 16) < 1)
    v19 = -1;
  else
    v19 = **((_DWORD **)this + 9);
  *((_DWORD *)this + 91) = v19;
  *((_DWORD *)this + 92) = v19;
  *((_DWORD *)this + 226) = kdu_codestream::get_min_dwt_levels((kdu_codestream *)(*((_QWORD *)this + 142) + 288));
  kdrc_stream::configure_subsampling(this);
  *((_BYTE *)this + 908) = kdu_codestream::can_flip((kdu_codestream *)(*((_QWORD *)this + 142) + 288));
  *((_BYTE *)this + 1068) = 0;
  *((_BYTE *)this + 909) = 0;
  *(_QWORD *)&result = kdrc_stream::invalidate_surface((__n128 *)this).n128_u64[0];
  return result;
}

void sub_187F78AFC(void *a1, int a2)
{
  kdrc_codestream *v2;

  if (a2)
  {
    __cxa_begin_catch(a1);
    kdrc_codestream::~kdrc_codestream(v2);
    MEMORY[0x18D761C30]();
    __cxa_rethrow();
  }
  sub_187F78B90();
}

void sub_187F78B30()
{
  __cxa_end_catch();
  sub_187F78B90();
}

void sub_187F78B3C()
{
  uint64_t v0;

  MEMORY[0x18D761C30](v0, 0x10B0C40F8FFDE3CLL);
  sub_187F78B90();
}

void sub_187F78B5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F78B6C(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F78B7C(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  sub_187F78B90();
}

void sub_187F78B90()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

double kdrc_stream::change_frame(kdrc_stream *this, uint64_t a2)
{
  uint64_t v3;
  kdrc_codestream *v5;
  uint64_t v6;
  char v7;
  int v8;
  double result;

  v3 = *((_QWORD *)this + 2);
  if (v3 && *((_DWORD *)this + 6) != (_DWORD)a2)
  {
    if (*((_BYTE *)this + 1068))
    {
      kdu_region_decompressor::finish((kdrc_stream *)((char *)this + 120));
      *(_BYTE *)(*((_QWORD *)this + 142) + 296) = 0;
      *((_BYTE *)this + 1068) = 0;
      v3 = *((_QWORD *)this + 2);
    }
    *((_DWORD *)this + 6) = a2;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 104))(v3, a2);
    *((_DWORD *)this + 276) = mj2_video_source::get_stream_idx(*((mj2_video_source **)this + 2), *((_DWORD *)this + 7));
    v5 = (kdrc_codestream *)*((_QWORD *)this + 142);
    if (!v5
      || (kdrc_codestream::restart(v5, *((mj2_video_source **)this + 2), a2, *((unsigned int *)this + 7)),
          !*((_QWORD *)this + 142)))
    {
      v6 = operator new();
      v7 = *((_BYTE *)this + 8);
      v8 = *((_DWORD *)this + 3);
      jpx_input_box::jpx_input_box((jpx_input_box *)(v6 + 8));
      *(_QWORD *)(v6 + 288) = 0;
      *(_QWORD *)(v6 + 308) = 0;
      *(_QWORD *)(v6 + 300) = 0;
      *(_QWORD *)(v6 + 320) = 0;
      *(_BYTE *)(v6 + 296) = 0;
      *(_BYTE *)v6 = v7;
      *(_DWORD *)(v6 + 4) = v8;
      kdrc_codestream::init((kdrc_codestream *)v6, *((mj2_video_source **)this + 2), a2, *((unsigned int *)this + 7));
      kdrc_codestream::attach((kdrc_codestream *)v6, this);
      if (*((_QWORD *)this + 142) != v6)
        kdrc_stream::change_frame();
    }
    kdrc_stream::configure_subsampling(this);
    *(_QWORD *)&result = kdrc_stream::invalidate_surface((__n128 *)this).n128_u64[0];
  }
  return result;
}

void sub_187F78CE0(void *a1)
{
  kdrc_codestream *v1;

  __cxa_begin_catch(a1);
  kdrc_codestream::~kdrc_codestream(v1);
  MEMORY[0x18D761C30]();
  __cxa_rethrow();
}

void sub_187F78D08(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t *kdrc_stream::set_error_level(kdrc_stream *this, int a2)
{
  uint64_t v2;
  uint64_t *v3;
  char v5;

  v2 = *((_QWORD *)this + 142);
  if (!v2 || !*(_QWORD *)(v2 + 288))
    kdrc_stream::set_error_level();
  v3 = (uint64_t *)(v2 + 288);
  switch(a2)
  {
    case 2:
      v5 = 0;
      break;
    case 1:
      return kdu_codestream::set_fussy(v3);
    case 0:
      return kdu_codestream::set_fast(v3);
    default:
      v5 = 1;
      break;
  }
  return kdu_codestream::set_resilient(v3, v5);
}

uint64_t kdrc_stream::set_mode(__n128 *this, uint64_t a2, unsigned __int32 a3)
{
  uint64_t v3;
  unsigned __int32 v5;
  uint64_t i;

  v3 = a2;
  if ((int)a2 >= 0)
    v5 = a3;
  else
    v5 = 0;
  if (this[22].n128_u32[2] != (_DWORD)a2 || this[23].n128_u32[1] != v5)
  {
    for (i = *(_QWORD *)(this[71].n128_u64[0] + 320); i; i = *(_QWORD *)(i + 1144))
    {
      if (*(_BYTE *)(i + 1068))
      {
        kdu_region_decompressor::finish((kdu_region_decompressor *)(i + 120));
        *(_BYTE *)(*(_QWORD *)(i + 1136) + 296) = 0;
        *(_BYTE *)(i + 1068) = 0;
      }
    }
    this[22].n128_u32[2] = v3;
    this[23].n128_u32[1] = v5;
    if ((v3 & 0x80000000) != 0)
      LODWORD(v3) = this[22].n128_u32[3];
    this[23].n128_u32[0] = v3;
    kdrc_stream::configure_subsampling((kdrc_stream *)this);
    this[56].n128_u8[13] = 0;
    this[65].n128_u64[0] = 0;
    kdrc_stream::invalidate_surface(this);
    return this[22].n128_u32[2];
  }
  return v3;
}

uint64_t kdrc_stream::set_thread_env(uint64_t result, uint64_t a2, uint64_t a3)
{
  _OWORD v3[2];
  uint64_t v4;

  if (*(_QWORD *)(result + 32) != a2 && *(_BYTE *)(result + 1068))
  {
    v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3);
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  *(_QWORD *)(result + 32) = a2;
  *(_QWORD *)(result + 40) = a3;
  return result;
}

void sub_187F78EC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F78ECC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

unint64_t kdrc_stream::set_scale(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, int a8, float a9, unsigned __int8 a10, unsigned __int8 a11, int *a12)
{
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  BOOL v20;
  unint64_t v22;
  int v23;
  int v24;
  uint64_t i;
  int v26;
  BOOL v27;
  int v28;
  unint64_t v29;
  uint64_t v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  double v34;
  double v35;
  double v36;
  double v37;
  uint64_t v38;
  double v39;
  double v40;
  int v41;
  int v42;
  unsigned int v43;
  int *v44;
  int v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  _BOOL4 v51;
  BOOL v52;
  unint64_t v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  int v61;
  unsigned int v62;
  int v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  int v67;
  int v68;
  uint64_t v69;
  int32x4_t *v70;
  double v71;
  double v72;
  int *j;
  double v74;
  double v75;
  double v76;
  double v77;
  double v78;
  double v79;
  BOOL v80;
  double v81;
  signed int v82;
  int v83;
  signed int v84;
  int v85;
  unint64_t render_dims;
  uint64_t v87;
  unsigned int v88;
  unsigned int v89;
  uint64_t v90;
  BOOL v92;
  unint64_t v94;
  unint64_t v95;
  int v96;
  int32x4_t v97;
  __int128 v98;

  *(_QWORD *)&v98 = a2;
  *((_QWORD *)&v98 + 1) = a3;
  v14 = HIDWORD(a6);
  v15 = HIDWORD(a7);
  *a12 = 0;
  if (*(_QWORD *)(a1 + 16))
  {
    LODWORD(v16) = 0;
    LODWORD(v17) = 0;
    a2 = 0;
    a3 = 0;
    v18 = 0;
    LODWORD(v19) = 0;
    v98 = 0uLL;
  }
  else
  {
    v19 = HIDWORD(a2);
    v17 = HIDWORD(a3);
    LODWORD(v16) = a3;
    v18 = a2;
  }
  v20 = *(_BYTE *)(a1 + 909)
     && *(unsigned __int8 *)(a1 + 911) == a10
     && *(unsigned __int8 *)(a1 + 912) == a11
     && *(unsigned __int8 *)(a1 + 910) == a8
     && *(float *)(a1 + 916) == a9
     && *(_DWORD *)(a1 + 924) == (_DWORD)v19
     && *(_DWORD *)(a1 + 920) == v18
     && *(_DWORD *)(a1 + 932) == (_DWORD)v17
     && *(_DWORD *)(a1 + 928) == (_DWORD)v16
     && *(_QWORD *)(a1 + 936) == a4
     && *(_OWORD *)(a1 + 944) == __PAIR128__(a6, a5)
     && *(_DWORD *)(a1 + 964) == HIDWORD(a7)
     && *(_DWORD *)(a1 + 960) == (_DWORD)a7;
  *(_BYTE *)(a1 + 909) = 0;
  *(_BYTE *)(a1 + 911) = a10;
  *(_BYTE *)(a1 + 912) = a11;
  *(_BYTE *)(a1 + 910) = a8;
  *(float *)(a1 + 916) = a9;
  *(_OWORD *)(a1 + 920) = v98;
  *(_QWORD *)(a1 + 936) = a4;
  *(_QWORD *)(a1 + 944) = a5;
  *(_QWORD *)(a1 + 952) = a6;
  *(_QWORD *)(a1 + 960) = a7;
  if (((a10 & 1) != 0 || a11) && !*(_BYTE *)(a1 + 908))
  {
    i = 0;
    v43 = 0;
    v44 = a12;
    v45 = *a12 | 2;
LABEL_162:
    *v44 = v45;
    return v43 | (unint64_t)(i << 32);
  }
  v94 = a3;
  v95 = HIDWORD(a4);
  v22 = a2;
  v23 = a7;
  v92 = v20;
  v24 = a6;
  v96 = a4;
  for (i = *(_QWORD *)(*(_QWORD *)(a1 + 1136) + 320); i; i = *(_QWORD *)(i + 1144))
  {
    if (*(_BYTE *)(i + 1068))
    {
      kdu_region_decompressor::finish((kdu_region_decompressor *)(i + 120));
      *(_BYTE *)(*(_QWORD *)(i + 1136) + 296) = 0;
      *(_BYTE *)(i + 1068) = 0;
    }
  }
  v26 = v24;
  if ((_DWORD)v14 && v24)
  {
    v27 = (int)v17 < 1 || (int)v16 < 1;
    v28 = v27;
    v29 = v94;
    if (v28 == 1)
    {
      v30 = *(_QWORD *)(a1 + 1136);
      v31 = *(_DWORD *)(v30 + 312) * v14;
      if ((int)v15 <= 1)
        v32 = 1;
      else
        v32 = v15;
      if (v31 <= 0)
        v33 = -(int)(-v31 / v32);
      else
        v33 = (v31 - 1) / v32 + 1;
      v22 = 0;
      v46 = *(_DWORD *)(v30 + 308) * v24;
      if (v23 <= 1)
        v47 = 1;
      else
        v47 = v23;
      v48 = (v46 - 1) / v47;
      v27 = v46 <= 0;
      v49 = -(int)(-v46 / v47);
      if (!v27)
        v49 = v48 + 1;
      *((_QWORD *)&v98 + 1) = __PAIR64__(v33, v49);
      LODWORD(v16) = v49;
      v17 = __PAIR64__(v33, v49) >> 32;
      v29 = __PAIR64__(v33, v49);
    }
    v51 = SHIDWORD(a5) < 1 || (int)a5 < 1;
    v52 = !v51;
    if (v51)
      v53 = v29;
    else
      v53 = a5;
    if (v52)
      v42 = v96;
    else
      v42 = 0;
    if (v52)
      v41 = v95;
    else
      v41 = 0;
    if (v28)
    {
      v38 = *(_QWORD *)(a1 + 1136);
      v98 = *(_OWORD *)(v38 + 300);
      LODWORD(v16) = DWORD2(v98);
      LODWORD(v17) = HIDWORD(v98);
    }
    else
    {
      v54 = HIDWORD(v22) * v15;
      if ((int)v14 <= 1)
        v55 = 1;
      else
        v55 = v14;
      if (v54 <= 0)
        v56 = -(int)(-v54 / v55);
      else
        v56 = (v54 - 1) / v55 + 1;
      v57 = v22 * v23;
      if (v24 <= 1)
        v58 = 1;
      else
        v58 = v24;
      if (v57 <= 0)
        v59 = -(int)(-v57 / v58);
      else
        v59 = (v57 - 1) / v58 + 1;
      v60 = v16 + v22;
      v61 = (v17 + HIDWORD(v22)) * v15;
      if (v61 <= 0)
        v62 = -(int)(-v61 / v55);
      else
        v62 = (v61 - 1) / v55 + 1;
      v63 = v60 * v23;
      v64 = (v60 * v23 - 1) / v58;
      v65 = -(int)(-v63 / v58);
      if (v63 > 0)
        v65 = v64 + 1;
      v17 = v62 - v56;
      v16 = v65 - v59;
      *((_QWORD *)&v98 + 1) = v16 | (v17 << 32);
      v38 = *(_QWORD *)(a1 + 1136);
      v66 = v56 + *(_DWORD *)(v38 + 304);
      LODWORD(v98) = v59 + *(_DWORD *)(v38 + 300);
      DWORD1(v98) = v66;
    }
    v67 = *(_DWORD *)(a1 + 380);
    if (v67 < 1 || (v68 = *(_DWORD *)(a1 + 376), v68 < 1))
    {
      i = 0;
      v43 = 0;
LABEL_161:
      v44 = a12;
      v45 = *a12 | 1;
      goto LABEL_162;
    }
    v35 = (double)SHIDWORD(v53) / (double)(int)v17 * a9;
    v37 = (double)(int)v53 / (double)(int)v16 * a9;
    v39 = 2.0 / (double)SHIDWORD(v53);
    if ((int)v17 / v67 < SHIDWORD(v53))
      v39 = 2.0 / (double)(int)v17 * (double)v67;
    v40 = 2.0 / (double)(int)v53;
    if ((int)v16 / v68 < (int)v53)
      v40 = 2.0 / (double)(int)v16 * (double)v68;
  }
  else
  {
    v34 = (double)*(int *)(a1 + 380);
    v35 = a9 / v34;
    v36 = (double)*(int *)(a1 + 376);
    v37 = a9 / v36;
    v38 = *(_QWORD *)(a1 + 1136);
    v39 = 2.0 / (double)*(int *)(v38 + 312) * v34;
    v40 = 2.0 / (double)*(int *)(v38 + 308) * v36;
    v41 = v95;
    v42 = v96;
  }
  v69 = 0;
  v70 = (int32x4_t *)(a1 + 972);
  if (v39 <= 0.1)
    v71 = v39;
  else
    v71 = 0.1;
  if (v40 <= 0.1)
    v72 = v40;
  else
    v72 = 0.1;
  for (j = (int *)(a1 + 376); ; j += 2)
  {
    v74 = v35 * (double)j[67];
    if (v74 >= 1.0 - v71)
    {
      v75 = v37 * (double)j[66];
      if (v75 >= 1.0 - v72)
        break;
    }
    if (v69 >= *(int *)(a1 + 904))
    {
      i = 0;
      v43 = 0;
      *(_DWORD *)(a1 + 968) = v69;
      goto LABEL_161;
    }
    ++v69;
  }
  *(_DWORD *)(a1 + 968) = v69;
  v76 = v35 * (double)j[1];
  v77 = v37 * (double)*j;
  v78 = floor(v76 + 0.5);
  v79 = floor(v77 + 0.5);
  if (vabdd_f64(v78, v76) >= v71)
    v78 = v76;
  else
    v74 = v74 * (v78 / v76);
  if (vabdd_f64(v79, v77) >= v72)
    v79 = v77;
  else
    v75 = v75 * (v79 / v77);
  if (v74 < 1.0)
    v78 = v78 * (1.0 / v74);
  v80 = v75 < 1.0;
  v81 = v79 * (1.0 / v75);
  if (v80)
    v79 = v81;
  v82 = 1;
  *(_DWORD *)(a1 + 984) = 1;
  v83 = vcvtpd_s64_f64(v78);
  *(_DWORD *)(a1 + 976) = v83;
  if ((v71 + 1.0) * v78 >= (double)v83)
  {
    v84 = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 984) = v17;
    if (!(_DWORD)v14)
    {
      LODWORD(v17) = *(_DWORD *)(v38 + 312);
      *(_DWORD *)(a1 + 984) = v17;
    }
    if ((int)v17 <= 0)
      kdrc_stream::set_scale();
    if ((_DWORD)v17 == 1)
    {
      v84 = 1;
    }
    else
    {
      while (v78 * (double)(int)v17 > 1073741820.0)
      {
        v84 = v17 >> 1;
        *(_DWORD *)(a1 + 984) = v17 >> 1;
        v27 = v17 > 3;
        LODWORD(v17) = v17 >> 1;
        if (!v27)
          goto LABEL_124;
      }
      v84 = v17;
    }
LABEL_124:
    v83 = vcvtpd_s64_f64(v78 * (double)v84);
    *(_DWORD *)(a1 + 976) = v83;
  }
  *(_DWORD *)(a1 + 980) = 1;
  v85 = vcvtpd_s64_f64(v79);
  v70->i32[0] = v85;
  if ((v72 + 1.0) * v79 < (double)v85)
  {
    *(_DWORD *)(a1 + 980) = v16;
    if (!v26)
    {
      LODWORD(v16) = *(_DWORD *)(v38 + 308);
      *(_DWORD *)(a1 + 980) = v16;
    }
    if ((int)v16 <= 0)
      kdrc_stream::set_scale();
    if ((_DWORD)v16 == 1)
    {
      v82 = 1;
    }
    else
    {
      while (v79 * (double)(int)v16 > 1073741820.0)
      {
        v82 = v16 >> 1;
        *(_DWORD *)(a1 + 980) = v16 >> 1;
        v27 = v16 > 3;
        LODWORD(v16) = v16 >> 1;
        if (!v27)
          goto LABEL_135;
      }
      v82 = v16;
    }
LABEL_135:
    v85 = vcvtpd_s64_f64(v79 * (double)v82);
    v70->i32[0] = v85;
  }
  if ((_DWORD)v14 && v26)
  {
    LODWORD(i) = vcvtmd_s64_f64((double)v41 * ((double)v83 / (v78 * (double)v84) * a9) + 0.5);
    v43 = vcvtmd_s64_f64((double)v42 * ((double)v85 / (v79 * (double)v82) * a9) + 0.5);
    kdu_codestream::apply_input_restrictions(v38 + 288, 0, 0, v69, 0, (int *)&v98, *(_DWORD *)(a1 + 372));
  }
  else
  {
    kdu_codestream::apply_input_restrictions(v38 + 288, 0, 0, v69, 0, 0, *(_DWORD *)(a1 + 372));
    i = 0;
    v43 = 0;
  }
  kdu_codestream::change_appearance((uint64_t *)(*(_QWORD *)(a1 + 1136) + 288), a8, a10, a11);
  if (a8)
    *v70 = vrev64q_s32(*v70);
  v97 = 0uLL;
  kdu_codestream::get_dims((kdu_codestream *)(*(_QWORD *)(a1 + 1136) + 288), *(_DWORD *)(a1 + 368), &v97, 1);
  if ((unsigned __int32)v97.i32[3] >> 18 || v97.i32[2] >= 0x40000 || v97.i32[2] < 0)
    goto LABEL_161;
  render_dims = find_render_dims(v97.i64[0], v97.i64[1], v70->i64[0], *(_QWORD *)(a1 + 980));
  *(_QWORD *)(a1 + 988) = render_dims;
  *(_QWORD *)(a1 + 996) = v87;
  if (a8)
    v88 = v43;
  else
    v88 = i;
  if (a8)
    v89 = i;
  else
    v89 = v43;
  if (a11)
    i = 1 - v88 - HIDWORD(v87);
  else
    i = v88;
  if (a10)
    v43 = 1 - v89 - v87;
  else
    v43 = v89;
  *(_QWORD *)(a1 + 1004) = (render_dims - v43) | ((unint64_t)(HIDWORD(render_dims) - i) << 32);
  if (!v92)
  {
    *(_QWORD *)(a1 + 1040) = 0;
    kdrc_stream::invalidate_surface((__n128 *)a1);
  }
  *(_BYTE *)(a1 + 909) = 1;
  v90 = *(_QWORD *)(a1 + 48);
  if (v90)
    kdrc_overlay::set_geometry(v90, *(_QWORD *)(*(_QWORD *)(a1 + 1136) + 300), *(_QWORD *)(a1 + 8 * *(int *)(a1 + 968) + 376), a8, a10, a11, v70->i64[0], *(_QWORD *)(a1 + 980), *(_QWORD *)(a1 + 1004));
  return v43 | (unint64_t)(i << 32);
}

uint64_t kdrc_stream::set_buffer_surface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  _QWORD *v7;
  int v8;
  int *v9;
  uint64_t result;
  BOOL v11;
  __int128 v12;
  __int128 v13;

  *((_QWORD *)&v13 + 1) = a4;
  if (!*(_BYTE *)(a1 + 909))
    kdrc_stream::set_buffer_surface();
  v7 = (_QWORD *)(a1 + 1012);
  *(_QWORD *)(a1 + 1040) = a2;
  v8 = *(_DWORD *)(a1 + 1008) + HIDWORD(a3);
  LODWORD(v13) = *(_DWORD *)(a1 + 1004) + a3;
  DWORD1(v13) = v8;
  *(_QWORD *)(a1 + 1012) = v13;
  v9 = (int *)(a1 + 1020);
  result = kdu_dims::operator&=(&v13, (int *)(a1 + 988));
  v11 = (_QWORD)v13 == __PAIR64__(*(_DWORD *)(a1 + 1024), *v9)
     && HIDWORD(v13) == *(_DWORD *)(a1 + 1032)
     && DWORD2(v13) == *(_DWORD *)(a1 + 1028);
  *(_OWORD *)v9 = v13;
  if (a5)
  {
    if (*(_BYTE *)(a1 + 1068))
    {
      result = kdu_region_decompressor::finish((kdu_region_decompressor *)(a1 + 120));
      *(_BYTE *)(*(_QWORD *)(a1 + 1136) + 296) = 0;
      *(_BYTE *)(a1 + 1068) = 0;
    }
    v7[5] = v7[1];
    v7[6] = 0;
    v12 = *(_OWORD *)(v7 + 5);
    *(_OWORD *)(a1 + 1088) = v12;
    *(_OWORD *)(a1 + 1072) = v12;
    *(_BYTE *)(a1 + 1124) = 0;
    *(_DWORD *)(a1 + 1120) = 256;
  }
  else if (!v11)
  {
    if (*(_BYTE *)(a1 + 1068))
    {
      kdu_dims::operator&=((_DWORD *)(a1 + 1072), v9);
      kdu_dims::operator&=((_DWORD *)(a1 + 1088), v9);
      if (*(int *)(a1 + 1100) < 1 || *(int *)(a1 + 1096) <= 0)
      {
        if (*(_BYTE *)(a1 + 1068))
        {
          kdu_region_decompressor::finish((kdu_region_decompressor *)(a1 + 120));
          *(_BYTE *)(*(_QWORD *)(a1 + 1136) + 296) = 0;
          *(_BYTE *)(a1 + 1068) = 0;
        }
      }
    }
    kdu_dims::operator&=((_DWORD *)(a1 + 1052), v9);
    return kdrc_stream::update_completion_status(a1);
  }
  return result;
}

uint64_t kdrc_stream::update_completion_status(uint64_t this)
{
  int v1;
  int v2;
  uint64_t v3;
  int64_t v4;
  uint64_t v5;

  v1 = *(_DWORD *)(this + 1032);
  if (v1 < 1
    || (v2 = *(_DWORD *)(this + 1028), v2 < 1)
    || *(_DWORD *)(this + 1024) == *(_DWORD *)(this + 1056)
    && *(_DWORD *)(this + 1020) == *(_DWORD *)(this + 1052)
    && v1 == *(_DWORD *)(this + 1064)
    && v2 == *(_DWORD *)(this + 1060))
  {
    LODWORD(v3) = 0;
    *(_BYTE *)(this + 1124) = 1;
  }
  else
  {
    *(_BYTE *)(this + 1124) = 0;
    v4 = v2 * (unint64_t)v1;
    v5 = *(int *)(this + 1060) * (uint64_t)*(int *)(this + 1064);
    if (*(_BYTE *)(this + 1068))
      v5 = v5
         + *(int *)(this + 1080) * (uint64_t)*(int *)(this + 1084)
         - *(int *)(this + 1096) * (uint64_t)*(int *)(this + 1100);
    v3 = ((v4 - v5) << 8) / v4;
  }
  *(_DWORD *)(this + 1120) = v3;
  return this;
}

uint64_t kdrc_stream::process(kdrc_stream *this, int a2, int32x2_t *a3, int *a4)
{
  char *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  char v13;
  __int128 v14;
  uint64_t v15;
  kdu_region_decompressor *v16;
  int v17;
  int *v18;
  int min_dwt_levels;
  int v20;
  BOOL can_flip;
  _OWORD *v22;
  int v23;
  int v24;
  signed int v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _DWORD *exception;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  if (!*((_QWORD *)this + 130))
    kdrc_stream::process();
  v8 = (char *)this + 972;
  if (!*((_BYTE *)this + 1068) && *((int *)this + 258) >= 1 && *((int *)this + 257) >= 1)
  {
    *(_QWORD *)((char *)this + 1052) = *(_QWORD *)((char *)this + 1020);
    *(_QWORD *)((char *)this + 1060) = 0;
    v14 = *(_OWORD *)((char *)this + 1020);
    *((_OWORD *)this + 67) = v14;
    *((_OWORD *)this + 68) = v14;
    if (*((int *)this + 271) >= 1 && *((int *)this + 270) >= 1)
    {
      v15 = *((_QWORD *)this + 142);
      if (*(_BYTE *)(v15 + 296))
        kdrc_stream::process();
      v16 = (kdrc_stream *)((char *)this + 120);
      *((_DWORD *)this + 32) = 8;
      v17 = *((_DWORD *)this + 90);
      if (v17 >= 0)
        v18 = 0;
      else
        v18 = (int *)((char *)this + 64);
      if ((kdu_region_decompressor::start(v16, *(kd_codestream **)(v15 + 288), v18, v17, *((_DWORD *)this + 242), *((_DWORD *)this + 14), *((_QWORD *)this + 134), *((_QWORD *)this + 135), *(_QWORD *)v8, *((_QWORD *)v8 + 1), 0, *((_DWORD *)this + 93), 1, *((_QWORD *)this + 4), *((char **)this + 5)) & 1) == 0)goto LABEL_72;
      *(_BYTE *)(*((_QWORD *)this + 142) + 296) = 1;
      *((_BYTE *)this + 1068) = 1;
    }
  }
  a3[1] = 0;
  if (*((_BYTE *)this + 1068))
  {
    v9 = *((_QWORD *)this + 130);
    if (!*(_BYTE *)(v9 + 27))
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v9 + 24))(*((_QWORD *)this + 130), 0);
    v10 = *(_DWORD *)(v9 + 40);
    v11 = *(_DWORD *)(v9 + 44);
    v12 = *(_QWORD *)(v9 + 32);
    if (*((_BYTE *)this + 9))
    {
      v41 = *(_QWORD *)(v9 + 32);
      v13 = kdu_region_decompressor::process((uint64_t)this + 120, (uint64_t)&v41, 1u, v10, *((_QWORD *)v8 + 5), v11, a2, 0, (int *)this + 272, (uint64_t)a3, 8, 1u);
    }
    else
    {
      if ((*((_DWORD *)this + 90) & 0x80000000) == 0
        || (v34 = *((_QWORD *)this + 139)) == 0
        || !*(_BYTE *)(v34 + 232)
        || *((_DWORD *)this + 17) != *((_DWORD *)this + 16))
      {
        if (*((int *)this + 17) > 3)
        {
          v46 = 0u;
          v45 = 0u;
          v41 = v12;
          v42 = v12 + 1;
          v43 = v12 + 2;
          v44 = v12 + 3;
          if (!kdu_region_decompressor::process((uint64_t)this + 120, (uint64_t)&v41, 0, v10, *((_QWORD *)v8 + 5), v11, a2, 0, (int *)this + 272, (uint64_t)a3, 8, 1u))goto LABEL_27;
        }
        else if ((kdu_region_decompressor::process((kdrc_stream *)((char *)this + 120), v12, *((_QWORD *)v8 + 5), v10, v11, a2, 0, (int *)this + 272, (uint64_t)a3) & 1) == 0)
        {
LABEL_27:
          *(_BYTE *)(*((_QWORD *)this + 142) + 296) = 0;
          *((_BYTE *)this + 1068) = 0;
          if ((kdu_region_decompressor::finish((kdrc_stream *)((char *)this + 120)) & 1) != 0)
          {
            min_dwt_levels = kdu_codestream::get_min_dwt_levels((kdu_codestream *)(*((_QWORD *)this + 142) + 288));
            *((_DWORD *)this + 226) = min_dwt_levels;
            if (min_dwt_levels < *((_DWORD *)this + 242))
            {
              *((_DWORD *)this + 242) = min_dwt_levels;
              *((_BYTE *)this + 909) = 0;
              v20 = *a4 | 1;
LABEL_44:
              *a4 = v20;
              kdrc_stream::invalidate_surface((__n128 *)this);
              return 0;
            }
            if (*((_BYTE *)this + 912) || *((_BYTE *)this + 911))
            {
              can_flip = kdu_codestream::can_flip((kdu_codestream *)(*((_QWORD *)this + 142) + 288));
              *((_BYTE *)this + 908) = can_flip;
              if (!can_flip)
              {
                *((_BYTE *)this + 909) = 0;
                *(_WORD *)((char *)this + 911) = 0;
                v20 = *a4 | 2;
                goto LABEL_44;
              }
            }
            v22 = v8 + 80;
            kdu_dims::operator&=((_DWORD *)v8 + 20, (int *)this + 255);
            kdu_dims::operator&=((_DWORD *)this + 268, (int *)this + 255);
            v23 = *((_DWORD *)this + 266);
            if (v23 < 1 || (v24 = *((_DWORD *)v8 + 22), v24 <= 0))
            {
              *v22 = *((_OWORD *)this + 67);
            }
            else
            {
              v25 = *(_DWORD *)v22;
              v26 = *((unsigned int *)v8 + 21);
              v27 = v23 + v26;
              v28 = v24 + *(_DWORD *)v22;
              v29 = *((_DWORD *)this + 268);
              v30 = *((_DWORD *)this + 269);
              v31 = *((_DWORD *)this + 271) + v30;
              v32 = *((_DWORD *)this + 270) + v29;
              if ((_DWORD)v26 == v30 && v27 == v31)
              {
                if (v32 >= v25 && v28 >= v29)
                {
                  if (v25 >= v29)
                    v25 = *((_DWORD *)this + 268);
                  if (v28 <= v32)
                    v28 = *((_DWORD *)this + 270) + v29;
                }
              }
              else if (v25 == v29 && v28 == v32 && v31 >= (int)v26 && v27 >= v30)
              {
                v26 = (int)v26 >= v30 ? v30 : v26;
                if (v27 <= v31)
                  v27 = *((_DWORD *)this + 271) + v30;
              }
              *((_QWORD *)v8 + 10) = v25 | (unint64_t)(v26 << 32);
              *((_QWORD *)v8 + 11) = (v28 - v25) | ((unint64_t)(v27 - v26) << 32);
            }
            goto LABEL_68;
          }
LABEL_72:
          exception = __cxa_allocate_exception(4uLL);
          *exception = 0;
          __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
        }
LABEL_25:
        if (*((int *)this + 275) >= 1 && *((int *)this + 274) > 0)
        {
LABEL_68:
          *a3 = vsub_s32(*a3, *(int32x2_t *)(v8 + 32));
          goto LABEL_69;
        }
        goto LABEL_27;
      }
      if (*((_BYTE *)this + 1048))
        v35 = 2;
      else
        v35 = 1;
      v36 = v12 + v35;
      if (*((_BYTE *)this + 1048))
        v37 = 1;
      else
        v37 = 2;
      v38 = v12 + v37;
      v39 = 3;
      if (*((_BYTE *)this + 1048))
        v39 = 0;
      v41 = v36;
      v42 = v38;
      v43 = v12 + v39;
      v13 = kdu_region_decompressor::process((uint64_t)this + 120, (uint64_t)&v41, 1u, v10, *((_QWORD *)v8 + 5), v11, a2, 0, (int *)this + 272, (uint64_t)a3, 8, 1u);
    }
    if ((v13 & 1) == 0)
      goto LABEL_27;
    goto LABEL_25;
  }
LABEL_69:
  kdrc_stream::update_completion_status((uint64_t)this);
  return 1;
}

double kdrc_stream::adjust_refresh(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  int v5;
  int v6;
  uint64_t *v7;
  double result;
  unsigned int v9;
  unsigned int v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  *(_QWORD *)&v21 = a2;
  *((_QWORD *)&v21 + 1) = a3;
  if (!*(_BYTE *)(a1 + 909))
    kdrc_stream::adjust_refresh();
  v20 = *(_OWORD *)(a1 + 1020);
  v5 = *(_DWORD *)(a1 + 1008);
  v6 = *(_DWORD *)(a1 + 1004);
  LODWORD(v20) = v20 - v6;
  DWORD1(v20) -= v5;
  v19 = *(_OWORD *)(a1 + 1052);
  LODWORD(v19) = v19 - v6;
  DWORD1(v19) -= v5;
  v7 = (uint64_t *)&v21;
  kdu_dims::operator&=(&v19, (int *)&v21);
  v22 = v21;
  kdu_dims::operator&=(&v22, (int *)&v20);
  v9 = DWORD2(v22);
  if (SDWORD2(v22) < 1 || SHIDWORD(v22) < 1)
    return kdrc_refresh::add_region(a4, *v7, v7[1]);
  v10 = v22;
  v11 = DWORD1(v22);
  v12 = DWORD1(v21);
  v13 = DWORD1(v22) - DWORD1(v21);
  if (DWORD1(v22) - DWORD1(v21) < 0
    || (v14 = HIDWORD(v22) + DWORD1(v22),
        v15 = DWORD1(v21) - (HIDWORD(v22) + DWORD1(v22)) + HIDWORD(v21),
        (v15 & 0x80000000) != 0)
    || (v16 = (v22 - v21), (v16 & 0x80000000) != 0)
    || (v17 = (DWORD2(v22) + v22), v18 = (v21 - v17 + DWORD2(v21)), (v18 & 0x80000000) != 0))
  {
    kdrc_stream::adjust_refresh();
  }
  if ((_DWORD)v22 != (_DWORD)v21)
    result = kdrc_refresh::add_region(a4, v21, v16 | ((unint64_t)HIDWORD(v21) << 32));
  if ((_DWORD)v18)
    result = kdrc_refresh::add_region(a4, v17 | ((unint64_t)DWORD1(v21) << 32), v18 | ((unint64_t)HIDWORD(v21) << 32));
  if ((_DWORD)v11 != v12)
    result = kdrc_refresh::add_region(a4, v10 | ((unint64_t)DWORD1(v21) << 32), v9 | ((unint64_t)v13 << 32));
  if (v15)
    result = kdrc_refresh::add_region(a4, v10 | ((unint64_t)v14 << 32), v9 | ((unint64_t)v15 << 32));
  if (SHIDWORD(v19) >= 1 && SDWORD2(v19) >= 1)
  {
    v7 = (uint64_t *)&v19;
    return kdrc_refresh::add_region(a4, *v7, v7[1]);
  }
  return result;
}

double kdrc_refresh::add_region(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  __int128 *v6;
  __int128 *v7;
  __int128 *v8;
  double result;
  int v11;
  _QWORD *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  _QWORD *v24;
  __int128 v25;
  __int128 v26;

  *(_QWORD *)&v25 = a2;
  *((_QWORD *)&v25 + 1) = a3;
  if (SHIDWORD(a3) >= 1 && (int)a3 >= 1)
  {
    v5 = a1 + 1;
    v6 = (__int128 *)a1[1];
    if (v6)
    {
      v7 = 0;
      do
      {
        while (1)
        {
          v8 = v6;
          v6 = (__int128 *)*((_QWORD *)v6 + 2);
          v26 = *v8;
          kdu_dims::operator&=(&v26, (int *)&v25);
          if (SDWORD2(v26) < 1 || SHIDWORD(v26) < 1)
            goto LABEL_42;
          if (v25 == v26)
            return result;
          v11 = *((_DWORD *)v8 + 1);
          if (*v8 != v26)
            break;
          v12 = v7 + 1;
          if (!v7)
            v12 = v5;
          *v12 = v6;
          *((_QWORD *)v8 + 2) = *a1;
          *a1 = v8;
          if (!v6)
            goto LABEL_43;
        }
        if (DWORD1(v26) == DWORD1(v25) && HIDWORD(v25) == HIDWORD(v26))
        {
          v13 = DWORD2(v26) + v26;
          v14 = DWORD2(v25) + v25;
          v15 = v26 - v25;
          if ((_DWORD)v26 == (_DWORD)v25)
          {
            v15 = v14 - v13;
            LODWORD(v25) = DWORD2(v26) + v26;
LABEL_26:
            DWORD2(v25) = v15;
            goto LABEL_42;
          }
          if (v14 == v13)
            goto LABEL_26;
        }
        else if ((_DWORD)v26 == (_DWORD)v25 && DWORD2(v25) == DWORD2(v26))
        {
          v16 = HIDWORD(v26) + DWORD1(v26);
          v17 = HIDWORD(v25) + DWORD1(v25);
          v18 = DWORD1(v26) - DWORD1(v25);
          if (DWORD1(v26) == DWORD1(v25))
          {
            v18 = v17 - v16;
            DWORD1(v25) = HIDWORD(v26) + DWORD1(v26);
LABEL_32:
            HIDWORD(v25) = v18;
            goto LABEL_42;
          }
          if (v17 == v16)
            goto LABEL_32;
        }
        else
        {
          if (DWORD1(v26) != v11)
          {
            v19 = *(_DWORD *)v8;
LABEL_34:
            if (v19 == (_DWORD)v26 && *((_DWORD *)v8 + 2) == DWORD2(v26))
            {
              v22 = HIDWORD(v26) + DWORD1(v26);
              v23 = *((_DWORD *)v8 + 3) + v11;
              if (DWORD1(v26) == v11)
              {
                *((_DWORD *)v8 + 1) = v22;
                *((_DWORD *)v8 + 3) = v23 - v22;
              }
              else if (v23 == v22)
              {
                *((_DWORD *)v8 + 3) = DWORD1(v26) - v11;
              }
            }
            goto LABEL_42;
          }
          v19 = *(_DWORD *)v8;
          if (*((_DWORD *)v8 + 3) != HIDWORD(v26))
            goto LABEL_34;
          v20 = DWORD2(v26) + v26;
          v21 = *((_DWORD *)v8 + 2) + v19;
          if ((_DWORD)v26 == v19)
          {
            *(_DWORD *)v8 = v20;
            *((_DWORD *)v8 + 2) = v21 - v20;
          }
          else if (v21 == v20)
          {
            *((_DWORD *)v8 + 2) = v26 - v19;
          }
        }
LABEL_42:
        v7 = v8;
      }
      while (v6);
    }
LABEL_43:
    v24 = (_QWORD *)*a1;
    if (*a1)
    {
      *a1 = v24[2];
    }
    else
    {
      v24 = (_QWORD *)operator new();
      *v24 = 0;
      v24[1] = 0;
    }
    v24[2] = *v5;
    *v5 = v24;
    result = *(double *)&v25;
    *(_OWORD *)v24 = v25;
  }
  return result;
}

uint64_t kdrc_layer::kdrc_layer(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  __int128 v4;

  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 52) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  memset_pattern16((void *)(a1 + 88), &unk_18820E900, 0x10uLL);
  *(_QWORD *)&v3 = 0x100000001;
  *((_QWORD *)&v3 + 1) = 0x100000001;
  *(_OWORD *)(a1 + 104) = v3;
  *(_BYTE *)(a1 + 234) = 0;
  *(_WORD *)(a1 + 232) = 0;
  LOBYTE(v3) = 0;
  BYTE4(v3) = 0;
  BYTE8(v3) = 0;
  BYTE12(v3) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v3;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  v4 = *(_OWORD *)(a1 + 36);
  *(_OWORD *)(a1 + 52) = v4;
  *(_OWORD *)(a1 + 128) = v4;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 236) = -1;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  return a1;
}

void kdrc_layer::~kdrc_layer(kdrc_layer *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;
  kdrc_stream *v9;
  _BYTE *v10;
  _BYTE *v11;

  v2 = (_QWORD *)*((_QWORD *)this + 22);
  if (v2)
  {
    *v2 = 0;
    v2[10] = 0;
    v2[11] = 0;
    v3 = v2[13];
    if (v3)
    {
      v4 = v2[16];
      do
      {
        v5 = v3;
        v3 = *(_QWORD *)(v3 + 24);
        *(_QWORD *)(v5 + 24) = v4;
        v4 = v5;
      }
      while (v3);
      v2[13] = 0;
      v2[16] = v5;
    }
    v2[14] = 0;
    v2[15] = 0;
  }
  v6 = 0;
  v7 = 1;
  do
  {
    v8 = v7;
    v9 = (kdrc_stream *)*((_QWORD *)this + v6 + 9);
    if (v9)
      kdu_region_compositor::remove_stream(*(_QWORD *)this, v9, 1);
    v7 = 0;
    v6 = 1;
  }
  while ((v8 & 1) != 0);
  v10 = (_BYTE *)*((_QWORD *)this + 18);
  if (v10)
  {
    if (v10[24])
      (*(void (**)(_QWORD))(*(_QWORD *)v10 + 8))(*((_QWORD *)this + 18));
    else
      (*(void (**)(_QWORD))(**(_QWORD **)this + 64))(*(_QWORD *)this);
  }
  v11 = (_BYTE *)*((_QWORD *)this + 23);
  if (v11)
  {
    if (v11[24])
      (*(void (**)(_QWORD))(*(_QWORD *)v11 + 8))(*((_QWORD *)this + 23));
    else
      (*(void (**)(_QWORD))(**(_QWORD **)this + 64))(*(_QWORD *)this);
  }
}

uint64_t kdu_region_compositor::remove_stream(uint64_t this, kdrc_stream *a2, int a3)
{
  uint64_t v4;
  int v5;
  kdrc_stream *v7;
  kdrc_stream *v8;
  kdrc_stream *v9;
  _QWORD *v10;
  kdrc_stream *v11;
  kdrc_stream *v12;
  kdrc_stream *v13;
  _QWORD *v14;

  v4 = this;
  *((_QWORD *)a2 + 139) = 0;
  v5 = *((_DWORD *)a2 + 277);
  if (v5 < 0)
    a3 = 1;
  v7 = *(kdrc_stream **)(this + 496);
  if (v7)
  {
    if (v7 == a2)
    {
      v9 = 0;
LABEL_10:
      v10 = (_QWORD *)(this + 496);
      if (v9)
        v10 = (_QWORD *)((char *)v9 + 1128);
      *v10 = *((_QWORD *)a2 + 141);
      *((_QWORD *)a2 + 141) = *(_QWORD *)(this + 504);
      *(_QWORD *)(this + 504) = a2;
      *((_BYTE *)a2 + 1125) = 0;
      this = *((_QWORD *)a2 + 142);
      if (this)
        this = kdrc_codestream::move_to_tail(this, a2);
    }
    else
    {
      while (1)
      {
        v8 = (kdrc_stream *)*((_QWORD *)v7 + 141);
        if (!v8)
          break;
        v9 = v7;
        v7 = (kdrc_stream *)*((_QWORD *)v7 + 141);
        if (v8 == a2)
          goto LABEL_10;
      }
    }
  }
  if (a3)
  {
    v11 = *(kdrc_stream **)(v4 + 504);
    if (!v11)
      goto LABEL_29;
    if (v11 != a2)
    {
      while (1)
      {
        v12 = (kdrc_stream *)*((_QWORD *)v11 + 141);
        if (!v12)
          break;
        v13 = v11;
        v11 = (kdrc_stream *)*((_QWORD *)v11 + 141);
        if (v12 == a2)
          goto LABEL_21;
      }
LABEL_29:
      kdu_region_compositor::remove_stream();
    }
    v13 = 0;
LABEL_21:
    v14 = (_QWORD *)(v4 + 504);
    if (v13)
      v14 = (_QWORD *)((char *)v13 + 1128);
    *v14 = *((_QWORD *)a2 + 141);
    kdrc_stream::~kdrc_stream(a2);
    this = MEMORY[0x18D761C30]();
    if (v5 < 0)
    {
      if (!*(_QWORD *)(v4 + 16) || !*(_BYTE *)(v4 + 158))
        kdu_region_compositor::remove_stream();
      return jpx_input_box::close((jpx_input_box *)(v4 + 32));
    }
  }
  return this;
}

uint64_t kdrc_layer::init(uint64_t a1, jx_layer_source *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, char a8, char a9)
{
  uint64_t result;
  uint64_t active;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  int v26;
  int v27[2];
  uint64_t v28;
  jx_layer_source *v29;
  char v30[16];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v29 = a2;
  if (*(_QWORD *)(a1 + 72) || *(_QWORD *)(a1 + 80))
    kdrc_layer::init();
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 36) = a3;
  *(_QWORD *)(a1 + 44) = a4;
  *(_QWORD *)(a1 + 52) = a5;
  *(_QWORD *)(a1 + 60) = a6;
  *(_DWORD *)(a1 + 236) = jpx_layer_source::get_layer_id((jpx_layer_source *)&v29);
  *(_BYTE *)(a1 + 33) = a7;
  *(_BYTE *)(a1 + 34) = a8;
  *(_BYTE *)(a1 + 35) = a9;
  *(_BYTE *)(a1 + 120) = 0;
  result = jpx_layer_source::have_stream_headers(&v29);
  if ((_DWORD)result)
  {
    *(_QWORD *)v27 = 0;
    v28 = jpx_layer_source::access_channels((jpx_layer_source *)&v29);
    v26 = 0;
    jp2_channels::get_colour_mapping((jp2_channels *)&v28, 0, &v27[1], v27, &v26);
    active = kdu_region_compositor::add_active_stream(*(kdu_region_compositor **)a1, v26, *(_DWORD *)(a1 + 236), 0);
    *(_QWORD *)(a1 + 72) = active;
    if (!active)
    {
      v25 = 0;
      v23 = 0u;
      v24 = 0u;
      kdu_error::kdu_error((kdu_error *)&v23, "Error in Kakadu Region Compositor:\n");
      (*(void (**)(__int128 *, const char *))(v23 + 16))(&v23, "Unable to create compositing layer (index, starting from 0, equals ");
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      *(_OWORD *)v30 = 0u;
      if (BYTE8(v23))
        sprintf(v30, "%x");
      else
        sprintf(v30, "%d");
      (*(void (**)(__int128 *, char *))(v23 + 16))(&v23, v30);
      (*(void (**)(__int128 *, const char *))(v23 + 16))(&v23, "), since its primary codestream cannot be opened.");
      kdu_error::~kdu_error((kdu_error *)&v23);
    }
    *(_QWORD *)(active + 1112) = a1;
    v14 = v26;
    *(_WORD *)(a1 + 232) = 0;
    v15 = *(_QWORD *)(a1 + 72);
    if (*(_DWORD *)(v15 + 64) <= *(_DWORD *)(v15 + 68))
    {
      if ((int)jp2_channels::get_num_colours((jp2_channels *)&v28) >= 1)
      {
        v16 = 0;
        v17 = -1;
        v18 = -1;
        v19 = -1;
        while (jp2_channels::get_opacity_mapping((jp2_channels *)&v28, v16, &v27[1], v27, &v26) && v26 != v14)
        {
          if (v16)
          {
            if (v26 != v19 || v27[1] != v18 || v27[0] != v17)
            {
              v25 = 0;
              v23 = 0u;
              v24 = 0u;
              kdu_warning::kdu_warning((kdu_warning *)&v23, "Warning in Kakadu Region Compositor:\n");
              (*(void (**)(__int128 *, const char *))(v23 + 16))(&v23, "Unable to render compositing layer (index, starting from 0, equals ");
              v33 = 0u;
              v34 = 0u;
              v31 = 0u;
              v32 = 0u;
              *(_OWORD *)v30 = 0u;
              if (BYTE8(v23))
                sprintf(v30, "%x");
              else
                sprintf(v30, "%d");
              (*(void (**)(__int128 *, char *))(v23 + 16))(&v23, v30);
              (*(void (**)(__int128 *, const char *))(v23 + 16))(&v23, ") with alpha blending, since there are multiple distinct alpha channels for a single set of colour channels.");
              kdu_warning::~kdu_warning((kdu_warning *)&v23);
              break;
            }
          }
          else
          {
            v17 = v27[0];
            v18 = v27[1];
            v19 = v26;
          }
          if ((int)++v16 >= (int)jp2_channels::get_num_colours((jp2_channels *)&v28))
          {
            if (v19 < 0)
              goto LABEL_34;
            v20 = kdu_region_compositor::add_active_stream(*(kdu_region_compositor **)a1, v19, *(_DWORD *)(a1 + 236), 1);
            *(_QWORD *)(a1 + 80) = v20;
            if (v20)
            {
              *(_QWORD *)(v20 + 1112) = a1;
              *(_BYTE *)(a1 + 232) = 1;
              *(_BYTE *)(a1 + 233) = *(_BYTE *)(*(_QWORD *)(a1 + 80) + 10);
              goto LABEL_34;
            }
            v25 = 0;
            v23 = 0u;
            v24 = 0u;
            kdu_warning::kdu_warning((kdu_warning *)&v23, "Warning in Kakadu Region Compositor:\n");
            (*(void (**)(__int128 *, const char *))(v23 + 16))(&v23, "Unable to render compositing layer (index, starting from 0, equals ");
            v33 = 0u;
            v34 = 0u;
            v31 = 0u;
            v32 = 0u;
            *(_OWORD *)v30 = 0u;
            if (BYTE8(v23))
              sprintf(v30, "%x");
            else
              sprintf(v30, "%d");
            (*(void (**)(__int128 *, char *))(v23 + 16))(&v23, v30);
            (*(void (**)(__int128 *, const char *))(v23 + 16))(&v23, ") with alpha blending, since the codestream containing the alpha data cannot be opened.");
            kdu_warning::~kdu_warning((kdu_warning *)&v23);
            break;
          }
        }
      }
    }
    else
    {
      *(_BYTE *)(a1 + 232) = 1;
      *(_BYTE *)(a1 + 233) = *(_BYTE *)(v15 + 10);
    }
    v19 = -1;
LABEL_34:
    *(_QWORD *)v30 = 0;
    v22 = 0;
    *(_QWORD *)&v23 = 0;
    result = jpx_layer_source::get_codestream_registration((uint64_t *)&v29, 0, v30, &v23, &v22);
    v26 = result;
    if ((result & 0x80000000) == 0)
    {
      v21 = 1;
      do
      {
        if ((_DWORD)result == v14)
        {
          *(_QWORD *)(a1 + 88) = v23;
          *(_QWORD *)(a1 + 104) = v22;
        }
        else if ((_DWORD)result == v19)
        {
          *(_QWORD *)(a1 + 96) = v23;
          *(_QWORD *)(a1 + 112) = v22;
        }
        result = jpx_layer_source::get_codestream_registration((uint64_t *)&v29, v21++, v30, &v23, &v22);
        v26 = result;
      }
      while ((result & 0x80000000) == 0);
    }
  }
  return result;
}

void sub_187F7A9E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

uint64_t kdu_region_compositor::add_active_stream(kdu_region_compositor *this, int a2, int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  kdu_compressed_source *v19;
  jpx_source *v20;
  jx_codestream_source *v21;
  uint64_t v22;
  mj2_source *v24;
  mj2_video_source *v25;
  int v26[2];
  unsigned int v27[4];
  __int128 v28;
  uint64_t v29;

  if (*((_QWORD *)this + 1))
    a3 = 0;
  v8 = *((_QWORD *)this + 62);
  if (v8)
  {
    v9 = *((_QWORD *)this + 62);
    do
    {
      if (*(_DWORD *)(v9 + 1104) == a2 && (*(_DWORD *)(v9 + 1108) & 0x80000000) == 0)
        break;
      v9 = *(_QWORD *)(v9 + 1128);
    }
    while (v9);
  }
  else
  {
    v9 = 0;
  }
  v10 = *((_QWORD *)this + 63);
  if (v10)
  {
    v11 = 0;
    v12 = (_QWORD *)((char *)this + 504);
    v13 = *((_QWORD *)this + 63);
    do
    {
      v14 = v13;
      if (*(_DWORD *)(v13 + 1104) == a2)
      {
        if (!v9)
        {
          if (*(int *)(v13 + 1108) < 0)
            v9 = 0;
          else
            v9 = v13;
        }
        if (a3 < 0 || *(_DWORD *)(v13 + 1108) == a3)
        {
          if (v11)
            v12 = (_QWORD *)(v11 + 1128);
          *v12 = *(_QWORD *)(v13 + 1128);
          *(_QWORD *)(v13 + 1128) = v8;
          *((_QWORD *)this + 62) = v13;
          *(_BYTE *)(v13 + 1125) = 1;
          v17 = *(_QWORD *)(v13 + 1136);
          if (!v17)
          {
            v29 = 0;
            *(_OWORD *)v27 = 0u;
            v28 = 0u;
            kdu_error::kdu_error((kdu_error *)v27, "Error in Kakadu Region Compositor:\n");
            (*(void (**)(unsigned int *, const char *))(*(_QWORD *)v27 + 16))(v27, "Attempting to open a codestream which has already been found to contain an error.");
            kdu_error::~kdu_error((kdu_error *)v27);
          }
          kdrc_codestream::move_to_head(v17, (kdrc_stream *)v13);
          goto LABEL_44;
        }
      }
      v13 = *(_QWORD *)(v13 + 1128);
      v11 = v14;
    }
    while (v13);
    v15 = 0;
    while (1)
    {
      v16 = v10;
      if ((*(_DWORD *)(v10 + 1108) & 0x80000000) != 0 && *(_DWORD *)(v10 + 1104) == a2)
        break;
      v10 = *(_QWORD *)(v10 + 1128);
      v15 = v16;
      if (!v10)
        goto LABEL_35;
    }
    if (v15)
      v18 = (_QWORD *)(v15 + 1128);
    else
      v18 = (_QWORD *)((char *)this + 504);
    *v18 = *(_QWORD *)(v10 + 1128);
    kdrc_stream::~kdrc_stream((kdrc_stream *)v10);
    MEMORY[0x18D761C30]();
  }
LABEL_35:
  v14 = operator new();
  kdrc_stream::kdrc_stream(v14, (uint64_t)this, *((_BYTE *)this + 316), *((_DWORD *)this + 80), *((_QWORD *)this + 65), *((_QWORD *)this + 66));
  *(_QWORD *)(v14 + 1128) = *((_QWORD *)this + 62);
  *((_QWORD *)this + 62) = v14;
  *(_BYTE *)(v14 + 1125) = 1;
  if (a3 < 0 && !*((_QWORD *)this + 3))
  {
    if (*((_QWORD *)this + 1))
      kdu_region_compositor::add_active_stream();
    *(_QWORD *)v27 = jpx_source::access_codestream(*((jpx_source **)this + 2), a2, 1);
    jpx_codestream_source::open_stream((jx_codestream_source **)v27, (kdu_region_compositor *)((char *)this + 32));
    kdrc_stream::init((kdrc_stream *)v14, (kdu_region_compositor *)((char *)this + 32), (kdrc_codestream **)v9);
    goto LABEL_43;
  }
  v19 = (kdu_compressed_source *)*((_QWORD *)this + 1);
  if (v19)
  {
    kdrc_stream::init((kdrc_stream *)v14, v19, (kdrc_codestream **)v9);
LABEL_43:
    *(_DWORD *)(v14 + 1104) = a2;
    *(_DWORD *)(v14 + 1108) = a3;
    goto LABEL_44;
  }
  v20 = (jpx_source *)*((_QWORD *)this + 2);
  if (v20)
  {
    v21 = (jx_codestream_source *)jpx_source::access_codestream(v20, a2, 1);
    v22 = jpx_source::access_layer(*((jpx_source **)this + 2), a3, 1);
    kdrc_stream::init(v14, v21, v22, *((jpx_source **)this + 2), a4, v9);
  }
  else
  {
    v24 = (mj2_source *)*((_QWORD *)this + 3);
    if (!v24)
      kdu_region_compositor::add_active_stream();
    v27[0] = 0;
    *(_QWORD *)v26 = 0;
    mj2_source::find_stream(v24, a2, v27, &v26[1], v26);
    v25 = (mj2_video_source *)mj2_source::access_video_track(*((mj2_source **)this + 3), v27[0]);
    if (!v25)
      kdu_region_compositor::add_active_stream();
    kdrc_stream::init((kdrc_stream *)v14, v25, v26[1], v26[0], (kdrc_codestream **)v9);
  }
LABEL_44:
  kdrc_stream::set_error_level((kdrc_stream *)v14, *((_DWORD *)this + 78));
  *(_DWORD *)(v14 + 56) = *((_DWORD *)this + 82);
  return v14;
}

void sub_187F7AD30(void *a1)
{
  uint64_t v1;
  kdrc_stream *v2;

  __cxa_begin_catch(a1);
  __cxa_end_catch();
  kdu_region_compositor::remove_stream(v1, v2, 1);
  jpx_input_box::close((jpx_input_box *)(v1 + 32));
  JUMPOUT(0x187F7ACBCLL);
}

void sub_187F7AD84()
{
  uint64_t v0;

  MEMORY[0x18D761C30](v0, 0x10B0C4024755E16);
  JUMPOUT(0x187F7ADA0);
}

uint64_t kdrc_layer::init(uint64_t a1, mj2_video_source *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  char v7;
  int v10;
  uint64_t result;
  int stream_idx;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  char v17[16];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 72) || *(_QWORD *)(a1 + 80))
    kdrc_layer::init();
  v7 = a4;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  *(_BYTE *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 44) = 0;
  *(_QWORD *)(a1 + 36) = 0;
  *(_QWORD *)(a1 + 52) = a5;
  *(_QWORD *)(a1 + 60) = a6;
  *(_DWORD *)(a1 + 236) = mj2_video_source::get_track_idx(a2) - 1;
  *(_BYTE *)(a1 + 120) = 0;
  if ((a3 & 0x80000000) != 0 || (*(int (**)(mj2_video_source *))(*(_QWORD *)a2 + 96))(a2) <= (int)a3)
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu Region Compositor:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Unable to create compositing layer for MJ2 track ");
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    *(_OWORD *)v17 = 0u;
    if (BYTE8(v14))
      sprintf(v17, "%x");
    else
      sprintf(v17, "%d");
    (*(void (**)(__int128 *, char *))(v14 + 16))(&v14, v17);
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, ": requested frame index is out of range.");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  v10 = v7 & 1;
  if (v10 && !(*(unsigned int (**)(mj2_video_source *))(*(_QWORD *)a2 + 80))(a2))
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu Region Compositor:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Unable to create compositing layer for MJ2 track ");
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    *(_OWORD *)v17 = 0u;
    if (BYTE8(v14))
      sprintf(v17, "%x");
    else
      sprintf(v17, "%d");
    (*(void (**)(__int128 *, char *))(v14 + 16))(&v14, v17);
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, ": requested field does not exist (source is progressive, not interlaced).");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  (*(void (**)(mj2_video_source *, uint64_t))(*(_QWORD *)a2 + 104))(a2, a3);
  result = mj2_video_source::can_open_stream(a2, v10);
  if ((_DWORD)result)
  {
    stream_idx = mj2_video_source::get_stream_idx(a2, v10);
    if (stream_idx < 0)
      kdrc_layer::init();
    result = kdu_region_compositor::add_active_stream(*(kdu_region_compositor **)a1, stream_idx, *(_DWORD *)(a1 + 236), 0);
    *(_QWORD *)(a1 + 72) = result;
    if (!result)
    {
      v16 = 0;
      v14 = 0u;
      v15 = 0u;
      kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu Region Compositor:\n");
      (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Unable to create compositing layer for MJ2 track ");
      v20 = 0u;
      v21 = 0u;
      v18 = 0u;
      v19 = 0u;
      *(_OWORD *)v17 = 0u;
      if (BYTE8(v14))
        sprintf(v17, "%x");
      else
        sprintf(v17, "%d");
      (*(void (**)(__int128 *, char *))(v14 + 16))(&v14, v17);
      (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, ": codestream cannot be opened.");
      kdu_error::~kdu_error((kdu_error *)&v14);
    }
    *(_QWORD *)(result + 1112) = a1;
    *(_WORD *)(a1 + 232) = 0;
    v13 = *(_QWORD *)(a1 + 72);
    if (*(_DWORD *)(v13 + 64) > *(_DWORD *)(v13 + 68))
    {
      *(_BYTE *)(a1 + 232) = 1;
      *(_BYTE *)(a1 + 233) = *(_BYTE *)(v13 + 10);
    }
    *(_QWORD *)(a1 + 104) = 0x100000001;
    *(_QWORD *)(a1 + 88) = 0x100000001;
  }
  return result;
}

void sub_187F7B118(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F7B124(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t kdrc_layer::change_frame(kdrc_layer *this, int a2, int a3)
{
  uint64_t v5;
  uint64_t result;
  uint64_t v8;
  char v9;
  char v10;
  char *v11;
  kdrc_stream **v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  char v19;
  char v20;
  char *v21;
  kdrc_stream **v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v27;
  _OWORD v28[2];
  uint64_t v29;
  char v30[16];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v5 = *((_QWORD *)this + 9);
  result = *((_QWORD *)this + 2);
  if (v5)
  {
    if (result)
    {
      if (*((_DWORD *)this + 6) != a2 || *((_BYTE *)this + 32))
      {
        if (a2 < 0 || (*(int (**)(uint64_t))(*(_QWORD *)result + 96))(result) <= a2)
        {
          v29 = 0;
          memset(v28, 0, sizeof(v28));
          kdu_error::kdu_error((kdu_error *)v28, "Error in Kakadu Region Compositor:\n");
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v28[0] + 16))(v28, "Requested frame index for MJ2 track ");
          v33 = 0u;
          v34 = 0u;
          v31 = 0u;
          v32 = 0u;
          *(_OWORD *)v30 = 0u;
          if (BYTE8(v28[0]))
            sprintf(v30, "%x");
          else
            sprintf(v30, "%d");
          (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v28[0] + 16))(v28, v30);
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v28[0] + 16))(v28, " is out of range.");
          kdu_error::~kdu_error((kdu_error *)v28);
        }
        v8 = 0;
        *((_DWORD *)this + 6) = a2;
        v9 = 1;
        *((_BYTE *)this + 32) = 1;
        do
        {
          while (1)
          {
            v10 = v9;
            v11 = (char *)this + 8 * v8;
            v13 = *((_QWORD *)v11 + 9);
            v12 = (kdrc_stream **)(v11 + 72);
            v9 = v13;
            if (!v13)
              break;
            v14 = *((_DWORD *)this + 6);
            v15 = *((_DWORD *)this + 7) & 1 ^ v8;
            if (*((_DWORD *)this + 7) == 3 && v15 == 0)
              v17 = v14 + 1;
            else
              v17 = v14;
            (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 2) + 104))(*((_QWORD *)this + 2), v17);
            result = mj2_video_source::can_open_stream(*((mj2_video_source **)this + 2), v15);
            if (!(_DWORD)result)
              return result;
            if ((a3 & 1) != 0)
            {
              v9 = 0;
              v8 = 1;
              if ((v10 & 1) == 0)
                goto LABEL_31;
            }
            else
            {
              kdrc_stream::change_frame(*v12, v17);
              v9 = 0;
              v8 = 1;
              if ((v10 & 1) == 0)
                goto LABEL_41;
            }
          }
          v8 = 1;
        }
        while ((v10 & 1) != 0);
        if (!a3)
          goto LABEL_41;
LABEL_31:
        v18 = 0;
        v19 = 1;
        do
        {
          v20 = v19;
          v21 = (char *)this + 8 * v18;
          v23 = *((_QWORD *)v21 + 9);
          v22 = (kdrc_stream **)(v21 + 72);
          if (v23)
          {
            v24 = *((_DWORD *)this + 6);
            v25 = *((_DWORD *)this + 7);
            if (v25 == 3 && (_DWORD)v18 == 1)
              v27 = v24 + 1;
            else
              v27 = v24;
            (*(void (**)(_QWORD, uint64_t))(**((_QWORD **)this + 2) + 104))(*((_QWORD *)this + 2), v27);
            kdrc_stream::change_frame(*v22, v27);
          }
          v19 = 0;
          v18 = 1;
        }
        while ((v20 & 1) != 0);
LABEL_41:
        *((_BYTE *)this + 32) = 0;
      }
      return 1;
    }
  }
  else
  {
    if (result)
      *((_DWORD *)this + 6) = a2;
    kdrc_layer::reinit(this);
    return *((_QWORD *)this + 9) != 0;
  }
  return result;
}

void sub_187F7B3DC(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F7B3E8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL kdrc_layer::reinit(kdrc_layer *this)
{
  jx_layer_source *v2;

  if (!*((_QWORD *)this + 9))
  {
    v2 = (jx_layer_source *)*((_QWORD *)this + 1);
    if (v2)
      kdrc_layer::init((uint64_t)this, v2, *(_QWORD *)((char *)this + 36), *(_QWORD *)((char *)this + 44), *(_QWORD *)((char *)this + 52), *(_QWORD *)((char *)this + 60), *((_BYTE *)this + 33), *((_BYTE *)this + 34), *((_BYTE *)this + 35));
    else
      kdrc_layer::init((uint64_t)this, *((mj2_video_source **)this + 2), *((unsigned int *)this + 6), *((_DWORD *)this + 7), *(_QWORD *)((char *)this + 52), *(_QWORD *)((char *)this + 60));
  }
  return *((_QWORD *)this + 9) != 0;
}

__n128 *kdrc_layer::activate(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, char a6, char a7, char a8, unsigned int a9, int a10)
{
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char v20;
  char v21;
  uint64_t v22;
  __n128 *result;
  uint64_t v24;
  __n128 *v25;
  _BOOL4 v26;
  uint64_t v27;
  jx_layer_source *v28;
  uint64_t v29;
  char v30;
  char v31;
  uint64_t v32;
  kdrc_stream *v33;
  _QWORD *v34;
  kdrc_stream *v35;
  unint64_t v36;

  if (*(_QWORD *)(a1 + 72))
  {
    v17 = *(_QWORD *)(a1 + 176);
    if (v17)
      kdrc_layer::activate();
    v18 = 0;
    v36 = HIDWORD(a2);
    v19 = HIDWORD(a4);
    v20 = 1;
    do
    {
      v21 = v20;
      v22 = a1 + 8 * v18;
      v25 = *(__n128 **)(v22 + 72);
      v24 = v22 + 72;
      result = v25;
      if (v25)
      {
        if (!result[70].n128_u8[5])
        {
          v26 = (v17 & 1) != 0 && *(_QWORD *)(a1 + 8) != 0;
          result = (__n128 *)kdu_region_compositor::add_active_stream(*(kdu_region_compositor **)a1, result[69].n128_i32[0], result[69].n128_i32[1], v26);
          if (result != *(__n128 **)v24)
            kdrc_layer::activate();
        }
        result = (__n128 *)kdrc_stream::set_mode(result, 0xFFFFFFFFLL, 0);
        *(_QWORD *)(*(_QWORD *)v24 + 1112) = a1;
      }
      v20 = 0;
      LOBYTE(v17) = 1;
      v18 = 1;
    }
    while ((v21 & 1) != 0);
    *(_BYTE *)(a1 + 200) = 0;
    if (*(_DWORD *)(a1 + 56) != (_DWORD)v19 || *(_DWORD *)(a1 + 52) != (_DWORD)a4 || *(_QWORD *)(a1 + 60) != a5)
      *(_BYTE *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 52) = a4;
    *(_QWORD *)(a1 + 60) = a5;
    *(_BYTE *)(a1 + 33) = a6;
    *(_BYTE *)(a1 + 34) = a7;
    *(_BYTE *)(a1 + 35) = a8;
    if (*(_QWORD *)(a1 + 8))
    {
      v27 = a3;
      if (*(_DWORD *)(a1 + 40) != (_DWORD)v36
        || *(_DWORD *)(a1 + 36) != (_DWORD)a2
        || (v27 = a3, *(_QWORD *)(a1 + 44) != a3))
      {
        *(_BYTE *)(a1 + 120) = 0;
      }
      *(_QWORD *)(a1 + 36) = a2;
      *(_QWORD *)(a1 + 44) = v27;
    }
    else if (*(_DWORD *)(a1 + 28) != a10
           || (*(_DWORD *)(a1 + 24) != a9 || *(_BYTE *)(a1 + 32))
           && (result = (__n128 *)kdrc_layer::change_frame((kdrc_layer *)a1, a9, 1), (result & 1) == 0))
    {
      v29 = 0;
      v30 = 1;
      do
      {
        v31 = v30;
        v32 = a1 + 8 * v29;
        v35 = *(kdrc_stream **)(v32 + 72);
        v34 = (_QWORD *)(v32 + 72);
        v33 = v35;
        if (v35)
          kdu_region_compositor::remove_stream(*(_QWORD *)a1, v33, 1);
        v30 = 0;
        *v34 = 0;
        v29 = 1;
      }
      while ((v31 & 1) != 0);
      return (__n128 *)kdrc_layer::reinit((kdrc_layer *)a1);
    }
  }
  else
  {
    v28 = *(jx_layer_source **)(a1 + 8);
    if (v28)
      return (__n128 *)kdrc_layer::init(a1, v28, a2, a3, a4, a5, a6, a7, a8);
    else
      return (__n128 *)kdrc_layer::init(a1, *(mj2_video_source **)(a1 + 16), a9, a10, a4, a5);
  }
  return result;
}

uint64_t *kdrc_layer::deactivate(uint64_t *this)
{
  uint64_t *v1;
  uint64_t v2;
  char v3;
  char v4;
  kdrc_stream *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;

  v1 = this;
  v2 = 0;
  v3 = 1;
  do
  {
    v4 = v3;
    v5 = (kdrc_stream *)v1[v2 + 9];
    if (v5)
      this = (uint64_t *)kdu_region_compositor::remove_stream(*v1, v5, 0);
    v3 = 0;
    v2 = 1;
  }
  while ((v4 & 1) != 0);
  v6 = (_QWORD *)v1[22];
  if (v6)
  {
    *v6 = 0;
    v6[10] = 0;
    v6[11] = 0;
    v7 = v6[13];
    if (v7)
    {
      v8 = v6[16];
      do
      {
        v9 = v7;
        v7 = *(_QWORD *)(v7 + 24);
        *(_QWORD *)(v9 + 24) = v8;
        v8 = v9;
      }
      while (v7);
      v6[13] = 0;
      v6[16] = v9;
    }
    v6[14] = 0;
    v6[15] = 0;
    v1[22] = 0;
  }
  *((_BYTE *)v1 + 200) = 0;
  *((_BYTE *)v1 + 234) = 0;
  v10 = (_BYTE *)v1[23];
  if (v10)
  {
    if (v10[24])
      this = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 8))(v1[23]);
    else
      this = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)*v1 + 64))(*v1);
    v1[23] = 0;
  }
  return this;
}

uint64_t kdrc_layer::set_scale(kdrc_layer *this, int a2, int a3, unsigned __int8 a4, float a5, int *a6)
{
  int v9;
  int v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  int v16;
  _BOOL4 v17;
  uint64_t v18;
  char v19;
  char v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  _BYTE *v26;
  __int128 v27;
  unsigned __int8 v28;
  unsigned __int8 v29;

  v29 = a3;
  v28 = a4;
  *a6 = 0;
  if (!*((_QWORD *)this + 9))
    return 0;
  v9 = a3;
  if (*((_BYTE *)this + 32))
    kdrc_layer::change_frame(this, *((_DWORD *)this + 6), 0);
  v12 = *((unsigned __int8 *)this + 33);
  v13 = *((unsigned __int8 *)this + 35);
  if (a2)
  {
    if (*((_BYTE *)this + 34))
      v28 = a4 ^ 1;
    if (v13)
    {
      v14 = &v29;
LABEL_13:
      *v14 = v9 ^ 1;
      v9 = v29;
    }
  }
  else
  {
    if (*((_BYTE *)this + 34))
    {
      v9 ^= 1u;
      v29 = v9;
    }
    if (v13)
    {
      v14 = &v28;
      LOBYTE(v9) = a4;
      goto LABEL_13;
    }
  }
  v15 = v12 ^ a2;
  if (*((_BYTE *)this + 120))
  {
    v16 = v28;
    v17 = *((unsigned __int8 *)this + 122) == v9
       && *((unsigned __int8 *)this + 123) == v28
       && *((unsigned __int8 *)this + 121) == v15
       && *((float *)this + 31) == a5;
  }
  else
  {
    v17 = 0;
    v16 = v28;
  }
  v18 = 0;
  *((_BYTE *)this + 120) = 0;
  *((_BYTE *)this + 122) = v9;
  *((_BYTE *)this + 123) = v16;
  *((_BYTE *)this + 121) = v15;
  v19 = 1;
  *((float *)this + 31) = a5;
  while (1)
  {
    v20 = v19;
    v21 = (_QWORD *)((char *)this + 8 * v18);
    v22 = v21[9];
    if (v22)
    {
      v27 = 0uLL;
      *(_QWORD *)&v27 = kdrc_stream::set_scale(v22, *(_QWORD *)((char *)this + 36), *(_QWORD *)((char *)this + 44), *(_QWORD *)((char *)this + 52), *(_QWORD *)((char *)this + 60), v21[11], v21[13], v15 != 0, a5, v9 != 0, v16 != 0, a6);
      *((_QWORD *)&v27 + 1) = v23;
      if ((v20 & 1) != 0)
        *((_OWORD *)this + 8) = v27;
      else
        kdu_dims::operator&=((_DWORD *)this + 32, (int *)&v27);
      if (*((int *)this + 35) < 1 || *((int *)this + 34) <= 0)
        break;
    }
    v19 = 0;
    v18 = 1;
    if ((v20 & 1) == 0)
    {
      *((_BYTE *)this + 120) = 1;
      *((_QWORD *)this + 26) = 0;
      if (!v17)
      {
        v24 = (_BYTE *)*((_QWORD *)this + 18);
        if (v24)
        {
          if (v24[24])
            (*(void (**)(_QWORD))(*(_QWORD *)v24 + 8))(*((_QWORD *)this + 18));
          else
            (*(void (**)(_QWORD))(**(_QWORD **)this + 64))(*(_QWORD *)this);
          *((_QWORD *)this + 18) = 0;
        }
        v26 = (_BYTE *)*((_QWORD *)this + 23);
        if (v26)
        {
          if (v26[24])
            (*(void (**)(_QWORD))(*(_QWORD *)v26 + 8))(*((_QWORD *)this + 23));
          else
            (*(void (**)(_QWORD))(**(_QWORD **)this + 64))(*(_QWORD *)this);
          *((_QWORD *)this + 23) = 0;
          *((_BYTE *)this + 200) = 0;
        }
      }
      return *((_QWORD *)this + 16);
    }
  }
  return 0;
}

uint64_t kdrc_layer::set_buffer_surface(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  int v7;
  uint64_t *v8;
  _BOOL8 v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t buffer;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (a6)
    v7 = 0;
  else
    v7 = a7;
  *(_QWORD *)(result + 208) = a6;
  *(_QWORD *)(result + 216) = a2;
  *(_QWORD *)(result + 224) = a3;
  if (*(_QWORD *)(result + 72))
  {
    v8 = (uint64_t *)result;
    if (*(_BYTE *)(result + 120))
    {
      if (a6)
      {
        v14 = 1;
      }
      else if (*(_QWORD *)(result + 176))
      {
        v14 = *(_BYTE *)(result + 234) != 0;
      }
      else
      {
        v14 = 0;
      }
      v15 = *(_BYTE **)(result + 144);
      v27 = *(_QWORD *)(result + 160);
      v28 = *(_QWORD *)(result + 152);
      v29 = a4;
      v30 = a5;
      kdu_dims::operator&=(&v29, (int *)(result + 128));
      v16 = v30;
      v8[19] = v29;
      v8[20] = v16;
      v17 = v8[18];
      if (v17 && *((_DWORD *)v8 + 43) >= SHIDWORD(v16) && *((_DWORD *)v8 + 42) >= (int)v16)
      {
        (*(void (**)(uint64_t, _BOOL8))(*(_QWORD *)v17 + 16))(v17, v14);
        buffer = v8[18];
      }
      else
      {
        buffer = kdu_region_compositor::internal_allocate_buffer(*v8, v16, (uint64_t)(v8 + 21));
        v8[18] = buffer;
      }
      if (*((_BYTE *)v8 + 232))
        v19 = 0xFFFFFF;
      else
        v19 = -1;
      initialize_buffer_surface(buffer, v8[19], v8[20], 0, 0, 0, v19, v7);
      if (v15 && v15 != (_BYTE *)v8[18])
      {
        if (v15[24])
          (*(void (**)(_BYTE *))(*(_QWORD *)v15 + 8))(v15);
        else
          (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)*v8 + 64))(*v8, v15);
      }
      v20 = v8[22];
      if (v20)
      {
        if (!*((_BYTE *)v8 + 234) && kdrc_overlay::set_buffer_surface(v20, 0, v8[19], v8[20], 0))
        {
          *((_BYTE *)v8 + 234) = 1;
          if (!a6)
          {
            if (v14)
              kdrc_layer::set_buffer_surface();
            if (v8[30] || v8[31] || a2 != a4 || a3 != a5 || v8[23])
              kdrc_layer::set_buffer_surface();
            kdu_region_compositor::donate_compositing_buffer((_QWORD *)*v8, v8[18], v8[19], v8[20], v8[21]);
            v21 = v8[18];
            v8[26] = v21;
            v8[18] = kdu_region_compositor::internal_allocate_buffer(*v8, v16, (uint64_t)(v8 + 21));
            if (((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v21 + 16))(v21, 1) & 1) == 0)
              initialize_buffer_surface(v21, v8[19], v8[20], 0, 0, 0, -1, 0);
            initialize_buffer_surface(v8[18], v8[19], v8[20], v21, v8[19], v8[20], -1, 0);
          }
        }
        if (v8[22] && *((_BYTE *)v8 + 234))
        {
          v22 = (_BYTE *)v8[23];
          if (!v22 || *((_DWORD *)v8 + 49) < SHIDWORD(v16) || (v23 = v8[23], *((_DWORD *)v8 + 48) < (int)v16))
          {
            v23 = kdu_region_compositor::internal_allocate_buffer(*v8, v16, (uint64_t)(v8 + 24));
            v8[23] = v23;
          }
          initialize_buffer_surface(v23, v8[19], v8[20], (uint64_t)v22, v28, v27, 0xFFFFFF, 0);
          if (v22 && v22 != (_BYTE *)v8[23])
          {
            if (v22[24])
              (*(void (**)(_BYTE *))(*(_QWORD *)v22 + 8))(v22);
            else
              (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)*v8 + 64))(*v8, v22);
          }
          kdrc_overlay::set_buffer_surface(v8[22], v8[23], v8[19], v8[20], 0);
          while ((kdrc_overlay::process((kdrc_overlay *)v8[22], (kdu_dims *)&v29) & 1) != 0)
            ;
        }
      }
      v24 = 0;
      v25 = 1;
      do
      {
        v26 = v25;
        result = v8[v24 + 9];
        if (result)
          result = kdrc_stream::set_buffer_surface(result, v8[18], v8[19], v8[20], 1);
        v25 = 0;
        v24 = 1;
      }
      while ((v26 & 1) != 0);
    }
  }
  return result;
}

uint64_t kdu_region_compositor::internal_allocate_buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  int v7;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  if (!result)
  {
    v6 = operator new[]();
    *(_QWORD *)a3 = a2;
    result = operator new();
    *(_DWORD *)(result + 24) = 0;
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    *(_QWORD *)result = &off_1E1BB19C8;
    v7 = *(_DWORD *)(a3 + 4);
    *(_QWORD *)(result + 32) = v6;
    *(_DWORD *)(result + 40) = 4;
    *(_DWORD *)(result + 44) = v7;
    *(_WORD *)(result + 24) = 257;
  }
  *(_QWORD *)(result + 16) = *(_QWORD *)a3;
  return result;
}

uint64_t initialize_buffer_surface(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8)
{
  uint64_t v13;
  int v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int v31;
  _DWORD *v32;
  BOOL v33;
  unsigned int v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unint64_t v40;
  unsigned int v41;
  _DWORD *v42;
  char v43;
  unsigned int v44;
  char *v45;
  unsigned int v46;
  uint64_t v47;
  int v48;
  char *v49;
  unsigned int v50;
  int v51;
  unsigned int v52;
  _DWORD *v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  char v58;
  char v59;
  int v60;
  uint64_t v61;
  unsigned int v62;
  uint64_t v63;
  char *v64;
  char *v65;
  unsigned int v66;
  int *v67;
  int v68;
  int v69;
  uint64_t v70;
  unsigned int v71;
  unsigned int v72;
  uint64_t v73;
  int v74;
  char *v75;
  unsigned int v76;
  unsigned int v77;
  char *v78;
  _QWORD v79[2];
  unint64_t v80;
  uint64_t v81;

  v13 = result;
  v79[0] = a5;
  v79[1] = a6;
  if (!*(_BYTE *)(result + 27))
    result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 24))(result, 0);
  v14 = *(_DWORD *)(v13 + 40);
  v15 = *(int *)(v13 + 44);
  v16 = *(char **)(v13 + 32);
  if (!a4)
    goto LABEL_12;
  if (!*(_BYTE *)(a4 + 27))
    result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a4 + 24))(a4, 0);
  v17 = *(_QWORD *)(a4 + 32);
  if (v17
    && (v18 = *(int *)(a4 + 44),
        v80 = a2,
        v81 = a3,
        result = kdu_dims::operator&=(&v80, (int *)v79),
        v19 = v81,
        (int)v81 >= 1)
    && (v20 = HIDWORD(v81), v81 > 0))
  {
    v21 = HIDWORD(a2);
    v22 = HIDWORD(v80);
    v23 = HIDWORD(v80) - HIDWORD(a2);
    v24 = v80 - a2;
    v25 = HIDWORD(v79[0]);
    v26 = HIDWORD(v80) - HIDWORD(a2) + HIDWORD(v81);
    v27 = v81 + v80 - a2;
    v28 = HIDWORD(v80) - HIDWORD(v79[0]) + (v80 - LODWORD(v79[0])) * v18;
    v29 = v17 + 4 * v28;
    if ((int)v80 - LODWORD(v79[0]) <= (int)v80 - (int)a2)
    {
      v35 = v28;
      v36 = &v16[4 * (int)v15 * ((int)a3 - 1)];
      v37 = ((int)v81 - 1) * (int)v18;
      v38 = v29 + 4 * v37;
      v39 = a3 - v27;
      v40 = HIDWORD(a3);
      if (a8)
      {
        v36 -= 4 * v39 * (int)v15;
      }
      else if (v39 >= 1)
      {
        do
        {
          if (SHIDWORD(a3) >= 1)
          {
            v54 = 0;
            v55 = HIDWORD(a3) + 1;
            do
            {
              *(_DWORD *)&v36[v54] = a7;
              --v55;
              v54 += 4;
            }
            while (v55 > 1);
          }
          v36 -= 4 * v15;
          v33 = __OFSUB__(v39--, 1);
        }
        while (!((v39 < 0) ^ v33 | (v39 == 0)));
      }
      result = v23;
      v56 = -v15;
      v57 = a3 >> 32;
      if (HIDWORD(a3) - v26 < 1)
        v58 = 1;
      else
        v58 = a8;
      if (v23 < 1)
        v59 = 1;
      else
        v59 = a8;
      v60 = v20 + 1;
      v61 = -4 * v18;
      v62 = v21 + v40 - v22 - v20 + 1;
      v63 = 4 * (v19 >> 32) + 4 * v37 + 4 * v35 + v17 - 4;
      do
      {
        if (v25 <= (int)v21)
        {
          if ((a8 & 1) != 0)
          {
            v65 = &v36[4 * v23];
          }
          else
          {
            v72 = v23 + 1;
            v65 = v36;
            if (v23 >= 1)
            {
              do
              {
                *(_DWORD *)v65 = a7;
                v65 += 4;
                --v72;
              }
              while (v72 > 1);
            }
          }
          v73 = 0;
          v74 = v60;
          do
          {
            *(_DWORD *)&v65[v73] = *(_DWORD *)(v38 + v73);
            --v74;
            v73 += 4;
          }
          while (v74 > 1);
          if ((v58 & 1) == 0)
          {
            v75 = &v65[v73];
            v76 = v62;
            do
            {
              *(_DWORD *)v75 = a7;
              v75 += 4;
              --v76;
            }
            while (v76 > 1);
          }
        }
        else
        {
          if (a8)
          {
            v64 = &v36[4 * v26];
          }
          else
          {
            v64 = &v36[4 * v57];
            if ((int)v40 - v26 >= 1)
            {
              v66 = v62;
              do
              {
                *((_DWORD *)v64 - 1) = a7;
                v64 -= 4;
                --v66;
              }
              while (v66 > 1);
            }
          }
          v67 = (int *)v63;
          v68 = v60;
          do
          {
            v69 = *v67--;
            *((_DWORD *)v64 - 1) = v69;
            v64 -= 4;
            --v68;
          }
          while (v68 > 1);
          if ((v59 & 1) == 0)
          {
            v70 = -4;
            v71 = v23 + 1;
            do
            {
              *(_DWORD *)&v64[v70] = a7;
              --v71;
              v70 -= 4;
            }
            while (v71 > 1);
          }
        }
        v36 += 4 * v56;
        v38 += v61;
        v63 += v61;
        v33 = __OFSUB__((_DWORD)v19, 1);
        LODWORD(v19) = v19 - 1;
      }
      while (!(((int)v19 < 0) ^ v33 | ((_DWORD)v19 == 0)));
      if (v24 >= 1 && (a8 & 1) == 0)
      {
        do
        {
          if ((int)v40 >= 1)
          {
            v77 = v40 + 1;
            v78 = v36;
            do
            {
              *(_DWORD *)v78 = a7;
              v78 += 4;
              --v77;
            }
            while (v77 > 1);
          }
          v36 += 4 * v56;
          v33 = __OFSUB__(v24--, 1);
        }
        while (!((v24 < 0) ^ v33 | (v24 == 0)));
      }
    }
    else
    {
      if ((a8 & 1) != 0)
      {
        v16 += 4 * (int)v15 * v24;
      }
      else if (v24 >= 1)
      {
        do
        {
          if (SHIDWORD(a3) >= 1)
          {
            v41 = HIDWORD(a3) + 1;
            v42 = v16;
            do
            {
              *v42++ = a7;
              --v41;
            }
            while (v41 > 1);
          }
          v16 += 4 * v15;
          v33 = __OFSUB__(v24--, 1);
        }
        while (!((v24 < 0) ^ v33 | (v24 == 0)));
      }
      if (HIDWORD(a3) - v26 < 1)
        v43 = 1;
      else
        v43 = a8;
      result = (v20 + 1);
      v44 = HIDWORD(a2) + HIDWORD(a3) - v22 - v20 + 1;
      do
      {
        if ((a8 & 1) != 0)
        {
          v45 = &v16[4 * v23];
        }
        else
        {
          v46 = v23 + 1;
          v45 = v16;
          if (v23 >= 1)
          {
            do
            {
              *(_DWORD *)v45 = a7;
              v45 += 4;
              --v46;
            }
            while (v46 > 1);
          }
        }
        v47 = 0;
        v48 = result;
        do
        {
          *(_DWORD *)&v45[v47] = *(_DWORD *)(v29 + v47);
          --v48;
          v47 += 4;
        }
        while (v48 > 1);
        if ((v43 & 1) == 0)
        {
          v49 = &v45[v47];
          v50 = v44;
          do
          {
            *(_DWORD *)v49 = a7;
            v49 += 4;
            --v50;
          }
          while (v50 > 1);
        }
        v16 += 4 * v15;
        v29 += 4 * v18;
        v33 = __OFSUB__((_DWORD)v19, 1);
        LODWORD(v19) = v19 - 1;
      }
      while (!(((int)v19 < 0) ^ v33 | ((_DWORD)v19 == 0)));
      if ((a8 & 1) == 0)
      {
        v51 = a3 - v27;
        if ((int)a3 - v27 >= 1)
        {
          do
          {
            if (SHIDWORD(a3) >= 1)
            {
              v52 = HIDWORD(a3) + 1;
              v53 = v16;
              do
              {
                *v53++ = a7;
                --v52;
              }
              while (v52 > 1);
            }
            v16 += 4 * v15;
            v33 = __OFSUB__(v51--, 1);
          }
          while (!((v51 < 0) ^ v33 | (v51 == 0)));
        }
      }
    }
  }
  else
  {
LABEL_12:
    if ((a8 & 1) == 0)
    {
      if (v14 == 4)
      {
        if ((int)a3 >= 1)
        {
          v30 = HIDWORD(a3);
          do
          {
            if ((int)v30 >= 1)
            {
              v31 = HIDWORD(a3) + 1;
              v32 = v16;
              do
              {
                *v32++ = a7;
                --v31;
              }
              while (v31 > 1);
            }
            v16 += 4 * v15;
            v33 = __OFSUB__((_DWORD)a3, 1);
            LODWORD(a3) = a3 - 1;
          }
          while (!(((int)a3 < 0) ^ v33 | ((_DWORD)a3 == 0)));
        }
      }
      else if ((int)a3 >= 1)
      {
        v34 = a3 + 1;
        do
        {
          result = (uint64_t)memset(v16, 255, v14 * HIDWORD(a3));
          --v34;
        }
        while (v34 > 1);
      }
    }
  }
  return result;
}

_QWORD *kdu_region_compositor::donate_compositing_buffer(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  if (result[49])
    kdu_region_compositor::donate_compositing_buffer();
  if (result[50] != a3 || result[51] != a4)
    kdu_region_compositor::donate_compositing_buffer();
  v5 = result[59];
  if (!v5 || !*(_BYTE *)(v5 + 234))
    kdu_region_compositor::donate_compositing_buffer();
  result[49] = a2;
  result[52] = a5;
  return result;
}

uint64_t kdrc_layer::configure_overlay(uint64_t this, char a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;

  v4 = *(_QWORD *)(this + 72);
  if (v4)
  {
    v5 = this;
    if (*(_QWORD *)(this + 8))
    {
      if ((a2 & 1) != 0)
      {
        this = *(_QWORD *)(this + 176);
        if (this)
          goto LABEL_8;
        v8 = *(_QWORD **)(v4 + 48);
        *(_QWORD *)(v5 + 176) = v8;
        if (v8)
          *v8 = *(_QWORD *)v5;
        kdrc_layer::update_overlay(v5, 0, 1);
        this = *(_QWORD *)(v5 + 176);
        if (this)
        {
LABEL_8:
          this = kdrc_overlay::update_config((kdrc_overlay *)this, a3, a4);
          if ((_DWORD)this)
          {
            this = *(_QWORD *)(v5 + 184);
            if (this)
              this = initialize_buffer_surface(this, *(_QWORD *)(v5 + 152), *(_QWORD *)(v5 + 160), 0, 0, 0, 0xFFFFFF, 0);
            *(_BYTE *)(v5 + 200) = 1;
          }
        }
      }
      else
      {
        if (*(_BYTE *)(this + 234))
          *(_BYTE *)(this + 200) = 1;
        v9 = *(_QWORD **)(this + 176);
        if (v9)
        {
          *v9 = 0;
          v9[10] = 0;
          v9[11] = 0;
          v10 = v9[13];
          if (v10)
          {
            v11 = v9[16];
            do
            {
              v12 = v10;
              v10 = *(_QWORD *)(v10 + 24);
              *(_QWORD *)(v12 + 24) = v11;
              v11 = v12;
            }
            while (v10);
            v9[13] = 0;
            v9[16] = v12;
          }
          v9[14] = 0;
          v9[15] = 0;
          *(_QWORD *)(this + 176) = 0;
        }
        v13 = *(_BYTE **)(this + 184);
        if (v13)
        {
          if (v13[24])
            this = (*(uint64_t (**)(_QWORD))(*(_QWORD *)v13 + 8))(*(_QWORD *)(this + 184));
          else
            this = (*(uint64_t (**)(void))(**(_QWORD **)this + 64))();
          *(_QWORD *)(v5 + 184) = 0;
        }
      }
    }
  }
  return this;
}

uint64_t kdrc_layer::update_overlay(uint64_t this, int a2, int a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char v12;
  char v13;
  uint64_t buffer;
  BOOL v15;
  uint64_t v17;

  if (*(_QWORD *)(this + 72))
  {
    v3 = this;
    this = *(_QWORD *)(this + 176);
    if (this)
    {
      if (*(_BYTE *)(v3 + 120))
      {
        if (a2)
        {
          *(_QWORD *)this = 0;
          *(_QWORD *)(this + 80) = 0;
          *(_QWORD *)(this + 88) = 0;
          v6 = *(_QWORD *)(this + 104);
          if (v6)
          {
            v7 = *(_QWORD *)(this + 128);
            do
            {
              v8 = v6;
              v6 = *(_QWORD *)(v6 + 24);
              *(_QWORD *)(v8 + 24) = v7;
              v7 = v8;
            }
            while (v6);
            *(_QWORD *)(this + 104) = 0;
            *(_QWORD *)(this + 128) = v8;
          }
          *(_QWORD *)(this + 112) = 0;
          *(_QWORD *)(this + 120) = 0;
          this = *(_QWORD *)(v3 + 176);
          *(_QWORD *)this = *(_QWORD *)v3;
          if (*(_QWORD *)(v3 + 184))
          {
            initialize_buffer_surface(*(_QWORD *)(v3 + 184), *(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 160), 0, 0, 0, 0xFFFFFF, 0);
            this = *(_QWORD *)(v3 + 176);
          }
        }
        this = kdrc_overlay::set_buffer_surface(this, *(_QWORD *)(v3 + 184), *(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 160), 1);
        if ((_DWORD)this)
        {
          if (!*(_BYTE *)(v3 + 234))
          {
            *(_BYTE *)(v3 + 234) = 1;
            if (!*(_QWORD *)(v3 + 208))
            {
              if (*(_QWORD *)(v3 + 240) || *(_QWORD *)(v3 + 248) || *(_QWORD *)(v3 + 184))
                kdrc_layer::update_overlay();
              kdu_region_compositor::donate_compositing_buffer(*(_QWORD **)v3, *(_QWORD *)(v3 + 144), *(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 160), *(_QWORD *)(v3 + 168));
              *(_QWORD *)(v3 + 208) = *(_QWORD *)(v3 + 144);
              *(_QWORD *)(v3 + 144) = kdu_region_compositor::internal_allocate_buffer(*(_QWORD *)v3, *(_QWORD *)(v3 + 160), v3 + 168);
              v9 = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v3 + 208) + 16))(*(_QWORD *)(v3 + 208), 1);
              if ((v9 & 1) == 0)
                initialize_buffer_surface(*(_QWORD *)(v3 + 208), *(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 160), 0, 0, 0, -1, 0);
              v10 = v9 ^ 1;
              initialize_buffer_surface(*(_QWORD *)(v3 + 144), *(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 160), *(_QWORD *)(v3 + 208), *(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 160), -1, 0);
              v11 = 0;
              v12 = 1;
              do
              {
                v13 = v12;
                this = *(_QWORD *)(v3 + 8 * v11 + 72);
                if (this)
                  this = kdrc_stream::set_buffer_surface(this, *(_QWORD *)(v3 + 144), *(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 160), v10);
                v12 = 0;
                v11 = 1;
              }
              while ((v13 & 1) != 0);
            }
            if (!*(_QWORD *)(v3 + 184))
            {
              buffer = kdu_region_compositor::internal_allocate_buffer(*(_QWORD *)v3, *(_QWORD *)(v3 + 160), v3 + 192);
              *(_QWORD *)(v3 + 184) = buffer;
              initialize_buffer_surface(buffer, *(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 160), 0, 0, 0, 0xFFFFFF, 0);
              this = kdrc_overlay::set_buffer_surface(*(_QWORD *)(v3 + 176), *(_QWORD *)(v3 + 184), *(_QWORD *)(v3 + 152), *(_QWORD *)(v3 + 160), 0);
            }
          }
          if ((a3 & 1) == 0)
          {
            do
              this = kdrc_overlay::process(*(kdrc_overlay **)(v3 + 176), (kdu_dims *)&v17);
            while ((this & 1) != 0);
          }
        }
        if (*(_BYTE *)(v3 + 234))
          v15 = a3 == 0;
        else
          v15 = 1;
        if (!v15 && a2 != 0)
          *(_BYTE *)(v3 + 200) = 1;
      }
    }
  }
  return this;
}

uint64_t kdrc_layer::process_overlay(kdrc_layer *this, kdu_dims *a2)
{
  kdrc_overlay *v4;
  uint64_t result;
  int v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  char v11;
  uint64_t v12;

  v4 = (kdrc_overlay *)*((_QWORD *)this + 22);
  if (!v4)
  {
    if (!*((_BYTE *)this + 234))
    {
      result = 0;
      *((_BYTE *)this + 200) = 0;
      *((_BYTE *)this + 234) = 0;
      return result;
    }
    v6 = *((unsigned __int8 *)this + 200);
    *((_BYTE *)this + 200) = 0;
    *((_BYTE *)this + 234) = 0;
    if (v6)
    {
      v7 = (_BYTE *)*((_QWORD *)this + 18);
      *(_OWORD *)a2 = *(_OWORD *)((char *)this + 152);
      if (*((_QWORD *)this + 26)
        && kdu_region_compositor::retract_compositing_buffer(*(_QWORD *)this, (_QWORD *)this + 21))
      {
        v8 = *((_QWORD *)this + 26);
        *((_QWORD *)this + 18) = v8;
        *((_QWORD *)this + 26) = 0;
        if (*((_BYTE *)this + 232))
          kdrc_layer::process_overlay();
        initialize_buffer_surface(v8, *((_QWORD *)this + 19), *((_QWORD *)this + 20), (uint64_t)v7, *((_QWORD *)this + 19), *((_QWORD *)this + 20), -1, 0);
        (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)this + 18) + 16))(*((_QWORD *)this + 18), 0);
        v9 = 0;
        v10 = 1;
        do
        {
          v11 = v10;
          v12 = *((_QWORD *)this + v9 + 9);
          if (v12)
            kdrc_stream::set_buffer_surface(v12, *((_QWORD *)this + 18), *((_QWORD *)this + 19), *((_QWORD *)this + 20), 0);
          v10 = 0;
          v9 = 1;
        }
        while ((v11 & 1) != 0);
        if (v7[24])
          (*(void (**)(_BYTE *))(*(_QWORD *)v7 + 8))(v7);
        else
          (*(void (**)(_QWORD, _BYTE *))(**(_QWORD **)this + 64))(*(_QWORD *)this, v7);
      }
      return 1;
    }
    return 0;
  }
  if (!*((_BYTE *)this + 234))
    return 0;
  if (*((_BYTE *)this + 200))
  {
    while ((kdrc_overlay::process(*((kdrc_overlay **)this + 22), a2) & 1) != 0)
      ;
    *(_OWORD *)a2 = *(_OWORD *)((char *)this + 152);
    *((_BYTE *)this + 200) = 0;
    return 1;
  }
  return kdrc_overlay::process(v4, a2);
}

uint64_t kdu_region_compositor::retract_compositing_buffer(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 472);
  if (!v2)
    kdu_region_compositor::retract_compositing_buffer();
  if (!*(_QWORD *)(a1 + 392)
    || *(_QWORD *)(v2 + 240)
    || *(_BYTE *)(v2 + 232)
    || *(_BYTE *)(v2 + 234)
    || *(int *)(a1 + 356) >= 1 && *(int *)(a1 + 352) > 0)
  {
    return 0;
  }
  *(_QWORD *)(a1 + 392) = 0;
  *a2 = *(_QWORD *)(a1 + 416);
  return 1;
}

uint64_t kdrc_layer::update_composition(uint64_t result, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  int32x4_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  _BYTE *v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  unint64_t v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  int v31;
  int32x2_t v32;
  int32x2_t v33;
  int32x2_t v34;
  int32x2_t v35;
  int v36;
  uint32x2_t v37;
  BOOL v38;
  uint64_t v40;
  int v41;
  unint64_t v42;
  int v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  unsigned int v47;
  size_t v48;
  uint64_t v49;
  unsigned int v50;
  unsigned int v51;
  BOOL v53;
  uint64_t v54;
  unsigned int v55;
  const float *v56;
  uint64_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  int v67;
  int v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  unint64_t v76;
  unsigned int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int32x2_t v82;
  uint32x2_t v83;
  unint64_t v84;
  uint64_t v85;

  v84 = a2;
  v85 = a3;
  v4 = *(_QWORD *)(result + 208);
  if (v4)
  {
    v5 = result;
    if (*(_BYTE *)(result + 234))
    {
      if (*(_QWORD *)(*(_QWORD *)result + 472) == result)
      {
        v40 = a3;
        v41 = a2;
        v42 = HIDWORD(a2);
        if (!*(_BYTE *)(v4 + 27))
          (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v4 + 24))(*(_QWORD *)(result + 208), 0);
        v43 = *(_DWORD *)(v4 + 40);
        v44 = *(int *)(v4 + 44) * (uint64_t)v43;
        v45 = (char *)(*(_QWORD *)(v4 + 32)
                     + ((int)v42 - *(_DWORD *)(v5 + 220)) * v43
                     + (v41 - *(_DWORD *)(v5 + 216)) * (int)v44);
        if (v43 == 4)
        {
          if ((int)v40 >= 1)
          {
            do
            {
              if (SHIDWORD(v85) >= 1)
              {
                v46 = 0;
                v47 = HIDWORD(v85) + 1;
                do
                {
                  *(_DWORD *)&v45[v46] = a4;
                  v46 += 4;
                  --v47;
                }
                while (v47 > 1);
              }
              v45 += v44;
              v38 = __OFSUB__((_DWORD)v40, 1);
              LODWORD(v40) = v40 - 1;
            }
            while (!(((int)v40 < 0) ^ v38 | ((_DWORD)v40 == 0)));
          }
        }
        else if ((int)v40 >= 1)
        {
          v48 = v43 * HIDWORD(v40);
          v49 = (int)v44;
          v50 = v40 + 1;
          do
          {
            memset(v45, 255, v48);
            v45 += v49;
            --v50;
          }
          while (v50 > 1);
        }
      }
      kdu_dims::operator&=(&v84, (int *)(v5 + 152));
      result = kdu_dims::operator&=(&v84, (int *)(v5 + 216));
      if (*(_QWORD *)(v5 + 72) && SHIDWORD(v85) >= 1 && (int)v85 >= 1)
      {
        if (!*(_BYTE *)(v5 + 120) || (v11 = *(_QWORD *)(v5 + 144)) == 0)
          kdrc_layer::update_composition();
        if (!*(_BYTE *)(v11 + 27) || !*(_BYTE *)(v11 + 26))
          result = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v11 + 24))(*(_QWORD *)(v5 + 144), 1);
        v13 = *(_DWORD *)(v11 + 40);
        v12 = *(int *)(v11 + 44);
        v14 = (int)v12 * (uint64_t)v13;
        v16 = v84;
        v15 = HIDWORD(v84);
        v17 = (_BYTE *)(*(_QWORD *)(v11 + 32)
                      + (HIDWORD(v84) - *(_DWORD *)(v5 + 156)) * v13
                      + ((int)v84 - *(_DWORD *)(v5 + 152)) * (int)v14);
        v18 = *(_QWORD *)(v5 + 208);
        if (!*(_BYTE *)(v18 + 27) || !*(_BYTE *)(v18 + 26))
        {
          result = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v18 + 24))(*(_QWORD *)(v5 + 208), 1);
          v16 = v84;
          v15 = HIDWORD(v84);
        }
        v20 = *(_DWORD *)(v18 + 40);
        v19 = *(int *)(v18 + 44);
        v21 = (int)v19 * (uint64_t)v20;
        v22 = (_BYTE *)(*(_QWORD *)(v18 + 32)
                      + (v15 - *(_DWORD *)(v5 + 220)) * v20
                      + (v16 - *(_DWORD *)(v5 + 216)) * (int)v21);
        if (*(_BYTE *)(v5 + 232))
        {
          v23 = v85;
          if (*(_BYTE *)(v5 + 233))
          {
            if ((int)v85 >= 1)
            {
              v6.n128_u64[0] = 0xFFFFFFF8FFFFFFF0;
              v7.n128_u64[0] = 0x800000010;
              v8.n128_u64[0] = 0xFF000000FFLL;
              v9 = 0uLL;
              do
              {
                if (SHIDWORD(v85) >= 1)
                {
                  v24 = 0;
                  v25 = HIDWORD(v85) + 1;
                  do
                  {
                    v26 = *(unsigned int *)&v17[v24];
                    v27 = *(_DWORD *)&v22[v24];
                    v28 = kdrc_alpha_lut[v26 >> 24];
                    v29 = HIBYTE(*(_DWORD *)&v17[v24]) + HIBYTE(v27) - ((int)(HIBYTE(v27) * v28) >> 14);
                    v31 = v29 & ~(v29 >> 31);
                    if (v31 >= 255)
                      v31 = 255;
                    v30 = *(_DWORD *)&v22[v24]
                        + v26
                        - ((int)(*(_DWORD *)&v22[v24] * v28) >> 14);
                    result = v30 & ~(v30 >> 31);
                    v34 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)__PAIR64__(v26, v27), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                    v32 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)__PAIR64__(v27, v26), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                    v33 = vadd_s32(v32, v34);
                    v34.i32[1] = v32.i32[1];
                    v35 = vdup_n_s32(v28);
                    if ((int)result >= 255)
                      v36 = 255;
                    else
                      v36 = result;
                    v37 = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vsub_s32(v33, vshr_n_s32(vmul_s32(v34, v35), 0xEuLL)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                    *(_DWORD *)&v22[v24] = v37.i32[0] | (v31 << 24) | v36 | v37.i32[1];
                    v24 += 4;
                    --v25;
                  }
                  while (v25 > 1);
                }
                v17 += v12;
                v22 += v19;
                v38 = __OFSUB__(v23--, 1);
              }
              while (!((v23 < 0) ^ v38 | (v23 == 0)));
            }
          }
          else if ((int)v85 >= 1)
          {
            v53 = v13 != 4 || v20 != 4;
            v6.n128_u64[0] = 0xFF000000FFLL;
            v6.n128_u64[1] = 0xFF000000FFLL;
            v7 = 0uLL;
            do
            {
              if (SHIDWORD(v85) >= 1)
              {
                if (v53)
                  kdrc_layer::update_composition();
                v54 = 0;
                v55 = HIDWORD(v85) + 1;
                do
                {
                  result = v22[v54 + 1];
                  v56 = (const float *)&kdrc_alpha_lut[v17[v54]];
                  v8.n128_u8[0] = v17[v54 + 2];
                  LODWORD(v57) = v22[v54 + 2];
                  v8.n128_u8[4] = v17[v54 + 3];
                  HIDWORD(v57) = v22[v54 + 3];
                  v10.i8[0] = v22[v54];
                  v10.i8[2] = v17[v54 + 1];
                  v10.i16[2] = v8.n128_u16[0];
                  v10.i16[3] = v8.n128_i16[2];
                  v10 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v10.i8), (int8x16_t)v6);
                  v58.i32[0] = 255;
                  v58.i32[1] = v22[v54 + 1];
                  v58.i64[1] = v57;
                  v59 = vsubq_s32(v10, v58);
                  v59.i32[0] = veorq_s8((int8x16_t)v10, (int8x16_t)v6).u32[0];
                  v60 = (int32x4_t)vld1q_dup_f32(v56);
                  v58.i32[0] = v10.i32[0];
                  v9 = (__n128)vminq_s32(vmaxq_s32(vsraq_n_s32(v58, vmulq_s32(v59, v60), 0xEuLL), (int32x4_t)0), (int32x4_t)v6);
                  v8.n128_u64[0] = (unint64_t)vmovn_s32((int32x4_t)v9);
                  v8.n128_u64[0] = (unint64_t)vmovn_s16((int16x8_t)v8);
                  *(_DWORD *)&v22[v54] = v8.n128_u32[0];
                  v54 += 4;
                  --v55;
                }
                while (v55 > 1);
              }
              v17 += (int)v14;
              v22 += (int)v21;
              v38 = __OFSUB__(v23--, 1);
            }
            while (!((v23 < 0) ^ v38 | (v23 == 0)));
          }
        }
        else if ((int)v85 >= 1)
        {
          v51 = v85 + 1;
          do
          {
            result = (uint64_t)memcpy(v22, v17, SHIDWORD(v85) * (uint64_t)v13);
            v17 += v14;
            v22 += v21;
            --v51;
          }
          while (v51 > 1);
        }
        v61 = *(_QWORD *)(v5 + 184);
        if (v61)
        {
          if (!*(_BYTE *)(v61 + 27) || !*(_BYTE *)(v61 + 26))
            result = (*(uint64_t (**)(_QWORD, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)v61 + 24))(*(_QWORD *)(v5 + 184), 1, v6, v7, v8, v9);
          v62 = *(_DWORD *)(v61 + 40);
          v63 = *(int *)(v61 + 44);
          v64 = *(_QWORD *)(v61 + 32);
          v66 = v84;
          v65 = HIDWORD(v84);
          v67 = *(_DWORD *)(v5 + 152);
          v68 = *(_DWORD *)(v5 + 156);
          v69 = *(_QWORD *)(v5 + 208);
          if (!*(_BYTE *)(v69 + 27) || !*(_BYTE *)(v69 + 26))
            result = (*(uint64_t (**)(_QWORD, uint64_t, __n128, __n128, __n128, __n128))(*(_QWORD *)v69 + 24))(*(_QWORD *)(v5 + 208), 1, v6, v7, v8, v9);
          v70 = v85;
          if ((int)v85 >= 1)
          {
            v71 = v64 + (v65 - v68 + (v66 - v67) * (int)v63) * v62;
            v72 = *(int *)(v69 + 44);
            v73 = *(_QWORD *)(v69 + 32)
                + (HIDWORD(v84) - *(_DWORD *)(v5 + 220) + ((int)v84 - *(_DWORD *)(v5 + 216)) * (int)v72)
                * *(_DWORD *)(v69 + 40);
            do
            {
              if (SHIDWORD(v85) >= 1)
              {
                v74 = 0;
                v75 = HIDWORD(v85) + 1;
                do
                {
                  v76 = *(unsigned int *)(v71 + v74);
                  v77 = *(_DWORD *)(v73 + v74);
                  result = *(unsigned int *)((char *)kdrc_alpha_lut + ((v76 >> 22) & 0x3FC));
                  v78 = ((int)((HIBYTE(v77) ^ 0xFF) * result) >> 14) + HIBYTE(v77);
                  v80 = v78 & ~(v78 >> 31);
                  if (v80 >= 255)
                    v80 = 255;
                  v79 = (((*(_DWORD *)(v71 + v74) - v77) * (int)result) >> 14)
                      + v77;
                  v81 = v79 & ~(v79 >> 31);
                  if (v81 >= 255)
                    v81 = 255;
                  v82 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v77), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                  v83 = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vsra_n_s32(v82, vmul_s32(vsub_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v76), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), v82), vdup_n_s32(result)), 0xEuLL), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                  *(_DWORD *)(v73 + v74) = v83.i32[0] | (v80 << 24) | v81 | v83.i32[1];
                  v74 += 4;
                  --v75;
                }
                while (v75 > 1);
              }
              v71 += v63;
              v73 += v72;
              v38 = __OFSUB__(v70--, 1);
            }
            while (!((v70 < 0) ^ v38 | (v70 == 0)));
          }
        }
      }
    }
  }
  return result;
}

uint64_t kdrc_refresh::adjust(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD v9[2];

  v9[0] = a2;
  v9[1] = a3;
  v4 = (_QWORD *)(result + 8);
  v3 = *(_QWORD *)(result + 8);
  if (v3)
  {
    v5 = (_QWORD *)result;
    v6 = 0;
    do
    {
      v7 = *(_QWORD *)(v3 + 16);
      result = kdu_dims::operator&=((_DWORD *)v3, (int *)v9);
      if (*(int *)(v3 + 12) < 1 || *(int *)(v3 + 8) <= 0)
      {
        v8 = (_QWORD *)(v6 + 16);
        if (!v6)
          v8 = v4;
        *v8 = v7;
        *(_QWORD *)(v3 + 16) = *v5;
        *v5 = v3;
      }
      else
      {
        v6 = v3;
      }
      v3 = v7;
    }
    while (v7);
  }
  return result;
}

void kdrc_refresh::adjust(kdrc_refresh *this, kdrc_stream *a2)
{
  uint64_t *v2;
  uint64_t *v5;

  v2 = (uint64_t *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v2)
  {
    do
    {
      v5 = (uint64_t *)v2[2];
      kdrc_stream::adjust_refresh((uint64_t)a2, *v2, v2[1], this);
      v2[2] = *(_QWORD *)this;
      *(_QWORD *)this = v2;
      v2 = v5;
    }
    while (v5);
  }
}

uint64_t kdu_region_compositor::kdu_region_compositor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a1 = &off_1E1BB23E0;
  jpx_input_box::jpx_input_box((jpx_input_box *)(a1 + 32));
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  kdu_region_compositor::init(a1, a2, a3);
  return a1;
}

void sub_187F7D104(_Unwind_Exception *a1)
{
  jpx_input_box *v1;

  jpx_input_box::~jpx_input_box(v1);
  _Unwind_Resume(a1);
}

_QWORD *kdu_region_compositor::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 316) = 1;
  *(_DWORD *)(a1 + 320) = 256000;
  *(_DWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 424) = -1;
  *(_BYTE *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0x10000;
  *(_BYTE *)(a1 + 334) = 0;
  *(_WORD *)(a1 + 332) = 0;
  *(_QWORD *)(a1 + 336) = 1065353216;
  *(_DWORD *)(a1 + 428) = 257;
  *(_BYTE *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 436) = 0;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 440) = 1;
  result = (_QWORD *)operator new();
  *result = 0;
  result[1] = 0;
  *(_QWORD *)(a1 + 512) = result;
  if (a2)
  {
    if (*(_QWORD *)(a2 + 32))
      v7 = a2;
    else
      v7 = 0;
  }
  else
  {
    v7 = 0;
  }
  *(_QWORD *)(a1 + 520) = v7;
  if (v7)
    v8 = a3;
  else
    v8 = 0;
  *(_QWORD *)(a1 + 528) = v8;
  return result;
}

uint64_t kdu_region_compositor::create(uint64_t this, kdu_compressed_source *a2, int a3)
{
  _OWORD v3[2];
  uint64_t v4;

  if (*(_QWORD *)(this + 8) || *(_QWORD *)(this + 16) || *(_QWORD *)(this + 24))
  {
    v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu Region Compositor:\n");
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  *(_QWORD *)(this + 8) = a2;
  *(_BYTE *)(this + 316) = a3 >= 0;
  *(_DWORD *)(this + 320) = a3;
  return this;
}

void sub_187F7D298(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F7D2A4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_region_compositor::create(uint64_t this, jpx_source *a2, int a3)
{
  _OWORD v3[2];
  uint64_t v4;

  if (*(_QWORD *)(this + 8) || *(_QWORD *)(this + 16) || *(_QWORD *)(this + 24))
  {
    v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu Region Compositor:\n");
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  *(_QWORD *)(this + 16) = a2;
  *(_BYTE *)(this + 316) = a3 >= 0;
  *(_DWORD *)(this + 320) = a3;
  return this;
}

void sub_187F7D34C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F7D358()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

kdrc_queue *kdu_region_compositor::pre_destroy(kdu_region_compositor *this)
{
  kdrc_stream *v2;
  kdrc_stream *v3;
  _BYTE *v4;
  kdrc_refresh *v5;
  kdrc_queue *result;

  kdu_region_compositor::remove_compositing_layer((uint64_t *)this, -1, 1);
  while (1)
  {
    v2 = (kdrc_stream *)*((_QWORD *)this + 62);
    if (!v2)
      break;
    kdu_region_compositor::remove_stream((uint64_t)this, v2, 1);
  }
  while (1)
  {
    v3 = (kdrc_stream *)*((_QWORD *)this + 63);
    if (!v3)
      break;
    kdu_region_compositor::remove_stream((uint64_t)this, v3, 1);
  }
  v4 = (_BYTE *)*((_QWORD *)this + 49);
  if (v4)
  {
    if (v4[24])
      (*(void (**)(_QWORD))(*(_QWORD *)v4 + 8))(*((_QWORD *)this + 49));
    else
      (*(void (**)(kdu_region_compositor *))(*(_QWORD *)this + 64))(this);
    *((_QWORD *)this + 49) = 0;
  }
  v5 = (kdrc_refresh *)*((_QWORD *)this + 64);
  if (v5)
  {
    kdrc_refresh::~kdrc_refresh(v5);
    MEMORY[0x18D761C30]();
    *((_QWORD *)this + 64) = 0;
  }
  kdu_region_compositor::flush_composition_queue(this);
  while (1)
  {
    result = (kdrc_queue *)*((_QWORD *)this + 58);
    *((_QWORD *)this + 57) = result;
    if (!result)
      break;
    *((_QWORD *)this + 58) = *((_QWORD *)result + 3);
    kdrc_queue::~kdrc_queue(result);
    MEMORY[0x18D761C30]();
  }
  return result;
}

uint64_t *kdu_region_compositor::remove_compositing_layer(uint64_t *this, int a2, int a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t **v17;

  v5 = this;
  v6 = this[59];
  if (v6)
  {
    v7 = 0;
    v8 = this + 59;
    v9 = this + 60;
    do
    {
      v10 = *(_QWORD *)(v6 + 240);
      if (a2 < 0 || *(_DWORD *)(v6 + 236) == a2)
      {
        *((_BYTE *)v5 + 429) = 1;
        this = kdrc_layer::deactivate((uint64_t *)v6);
        if (v7)
        {
          v11 = (uint64_t *)(v7 + 240);
        }
        else
        {
          v11 = v5 + 59;
          if (v6 != *v8)
            kdu_region_compositor::remove_compositing_layer();
        }
        *v11 = v10;
        v12 = *v9;
        if (v10)
        {
          if (v6 == v12)
            kdu_region_compositor::remove_compositing_layer();
          v13 = (uint64_t *)(v10 + 248);
        }
        else
        {
          v13 = v5 + 60;
          if (v6 != v12)
            kdu_region_compositor::remove_compositing_layer();
        }
        *v13 = v7;
        *(_QWORD *)(v6 + 240) = v5[61];
        *(_QWORD *)(v6 + 248) = 0;
        v5[61] = v6;
      }
      else
      {
        v7 = v6;
      }
      v6 = v10;
    }
    while (v10);
  }
  if (a3)
  {
    this = (uint64_t *)v5[61];
    if (this)
    {
      v14 = 0;
      v15 = v5 + 61;
      do
      {
        v16 = (uint64_t *)this[30];
        if (a2 < 0 || *((_DWORD *)this + 59) == a2)
        {
          v17 = (uint64_t **)(v14 + 30);
          if (!v14)
            v17 = (uint64_t **)v15;
          *v17 = v16;
          kdrc_layer::~kdrc_layer((kdrc_layer *)this);
          MEMORY[0x18D761C30]();
        }
        else
        {
          v14 = this;
        }
        this = v16;
      }
      while (v16);
    }
  }
  return this;
}

_QWORD *kdu_region_compositor::flush_composition_queue(_QWORD *this)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;

  v1 = this[56];
  this[57] = v1;
  if (v1)
  {
    v2 = this;
    v3 = this[58];
    do
    {
      v4 = *(_QWORD *)(v1 + 24);
      v2[56] = v4;
      *(_QWORD *)(v1 + 24) = v3;
      v2[58] = v1;
      v5 = *(_BYTE **)v1;
      if (*(_QWORD *)v1)
      {
        if (v5[24])
          this = (_QWORD *)(*(uint64_t (**)(_BYTE *))(*(_QWORD *)v5 + 8))(v5);
        else
          this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v2 + 64))(v2);
        v1 = v2[58];
        *(_QWORD *)v1 = 0;
        v4 = v2[56];
      }
      v2[57] = v4;
      v3 = v1;
      v1 = v4;
    }
    while (v4);
  }
  return this;
}

uint64_t kdu_region_compositor::add_compositing_layer(uint64_t a1, int a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, int a7, int a8, char a9, unsigned int a10, int a11)
{
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  kdrc_stream *v18;
  uint64_t result;
  char v20;
  char v21;
  jpx_source *v24;
  _BOOL4 v25;
  _BOOL4 v26;
  mj2_source *v27;
  int track_type;
  uint64_t *v29;
  kdrc_stream *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  jpx_source *v46;
  jx_layer_source *v47;
  mj2_video_source *v48;
  char v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;

  v13 = HIDWORD(a5);
  if (a9)
    LODWORD(v13) = 1 - (HIDWORD(a6) + HIDWORD(a5));
  LODWORD(v14) = 1 - (a6 + a5);
  if (!a8)
    LODWORD(v14) = a5;
  if (a7)
    v15 = HIDWORD(a6);
  else
    v15 = a6;
  if (a7)
    v16 = v14;
  else
    v16 = v13;
  if (a7)
    v14 = v13;
  else
    v14 = v14;
  if (a7)
    v17 = a6;
  else
    v17 = HIDWORD(a6);
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  if (*(_QWORD *)(a1 + 8))
  {
    if (a2)
    {
      v57 = 0;
      v55 = 0uLL;
      v56 = 0uLL;
      kdu_error::kdu_error((kdu_error *)&v55, "Error in Kakadu Region Compositor:\n");
      kdu_error::~kdu_error((kdu_error *)&v55);
    }
    v18 = *(kdrc_stream **)(a1 + 496);
    if (v18)
    {
      kdu_region_compositor::remove_stream(a1, v18, 0);
      if (*(_QWORD *)(a1 + 496))
        kdu_region_compositor::add_compositing_layer();
    }
    kdu_region_compositor::add_active_stream((kdu_region_compositor *)a1, 0, 0, 0);
    kdrc_stream::set_mode(*(__n128 **)(a1 + 496), 0xFFFFFFFFLL, 0);
    result = 1;
    *(_BYTE *)(a1 + 429) = 1;
    return result;
  }
  v20 = a8;
  v21 = a7;
  v53 = v14;
  v24 = *(jpx_source **)(a1 + 16);
  if (v24)
  {
    v52 = v16;
    v54 = 0;
    v25 = jpx_source::count_compositing_layers(v24, &v54);
    if (!jpx_source::access_layer(*(jpx_source **)(a1 + 16), a2, 1))
    {
      if (a2 < 0 || (v54 <= a2 ? (v26 = v25) : (v26 = 0), v26))
      {
        v57 = 0;
        v55 = 0u;
        v56 = 0u;
        kdu_error::kdu_error((kdu_error *)&v55, "Error in Kakadu Region Compositor:\n");
        goto LABEL_35;
      }
      return 0;
    }
  }
  else
  {
    v27 = *(mj2_source **)(a1 + 24);
    if (!v27)
      kdu_region_compositor::add_compositing_layer();
    track_type = mj2_source::get_track_type(v27, a2 + 1);
    if (track_type == -1)
      return 0;
    v52 = v16;
    if (track_type != 1)
    {
      v57 = 0;
      v55 = 0u;
      v56 = 0u;
      kdu_error::kdu_error((kdu_error *)&v55, "Error in Kakadu Region Compositor:\n");
LABEL_35:
      kdu_error::~kdu_error((kdu_error *)&v55);
    }
  }
  v51 = v17;
  v29 = (uint64_t *)(a1 + 472);
  while (1)
  {
    v30 = *(kdrc_stream **)(a1 + 496);
    if (!v30 || *v29)
      break;
    kdu_region_compositor::remove_stream(a1, v30, 0);
  }
  jpx_input_box::close((jpx_input_box *)(a1 + 32));
  v31 = *(_QWORD *)(a1 + 472);
  v50 = v20;
  if (v31)
  {
    if (*(_DWORD *)(v31 + 236) == a2)
    {
      v32 = 0;
      v33 = *(_QWORD *)(a1 + 472);
LABEL_46:
      if (v32)
      {
        *(_QWORD *)(v32 + 240) = *(_QWORD *)(v33 + 240);
      }
      else
      {
        if (v33 != v31)
          kdu_region_compositor::add_compositing_layer();
        *v29 = *(_QWORD *)(v31 + 240);
      }
      v36 = *(_QWORD *)(v33 + 240);
      v37 = *(_QWORD *)(a1 + 480);
      if (v36)
      {
        if (v33 == v37)
          kdu_region_compositor::add_compositing_layer();
        *(_QWORD *)(v36 + 248) = *(_QWORD *)(v33 + 248);
      }
      else
      {
        if (v33 != v37)
          kdu_region_compositor::add_compositing_layer();
        *(_QWORD *)(a1 + 480) = v32;
      }
      v38 = 0;
      *(_QWORD *)(v33 + 240) = 0;
      *(_QWORD *)(v33 + 248) = 0;
      goto LABEL_69;
    }
    v34 = *(_QWORD *)(a1 + 472);
    while (1)
    {
      v33 = *(_QWORD *)(v34 + 240);
      if (!v33)
        break;
      v32 = v34;
      v34 = *(_QWORD *)(v34 + 240);
      if (*(_DWORD *)(v33 + 236) == a2)
        goto LABEL_46;
    }
  }
  v33 = *(_QWORD *)(a1 + 488);
  if (v33)
  {
    if (*(_DWORD *)(v33 + 236) == a2)
    {
      v35 = 0;
LABEL_64:
      v38 = 0;
      if (v35)
        v40 = (_QWORD *)(v35 + 240);
      else
        v40 = (_QWORD *)(a1 + 488);
      *v40 = *(_QWORD *)(v33 + 240);
      *(_QWORD *)(v33 + 240) = 0;
      *(_QWORD *)(v33 + 248) = 0;
      goto LABEL_69;
    }
    v39 = *(_QWORD *)(a1 + 488);
    while (1)
    {
      v33 = *(_QWORD *)(v39 + 240);
      if (!v33)
        break;
      v35 = v39;
      v39 = *(_QWORD *)(v39 + 240);
      if (*(_DWORD *)(v33 + 236) == a2)
        goto LABEL_64;
    }
  }
  v33 = operator new();
  kdrc_layer::kdrc_layer(v33, a1);
  v38 = 1;
LABEL_69:
  v49 = v21;
  v41 = a3;
  v42 = *(_QWORD *)(a1 + 480);
  if (v42)
  {
    v43 = v15;
    v44 = a4;
    *(_QWORD *)(v33 + 248) = v42;
    v45 = (uint64_t *)(v42 + 240);
    v29 = (uint64_t *)(a1 + 480);
  }
  else
  {
    v43 = v15;
    v44 = a4;
    v45 = (uint64_t *)(a1 + 480);
    if (*v29)
      kdu_region_compositor::add_compositing_layer();
  }
  *v45 = v33;
  *v29 = v33;
  *(_BYTE *)(a1 + 429) = 1;
  if (v38)
  {
    v46 = *(jpx_source **)(a1 + 16);
    if (v46)
    {
      v47 = (jx_layer_source *)jpx_source::access_layer(v46, a2, 1);
      kdrc_layer::init(v33, v47, v41, v44, v53 | (v52 << 32), v43 | (v51 << 32), v49, v50, a9);
    }
    else
    {
      v48 = (mj2_video_source *)mj2_source::access_video_track(*(mj2_source **)(a1 + 24), a2 + 1);
      kdrc_layer::init(v33, v48, a10, a11, v53 | (v52 << 32), v43 | (v51 << 32));
    }
  }
  else
  {
    kdrc_layer::activate(v33, v41, v44, v53 | (v52 << 32), v43 | (v51 << 32), v49, v50, a9, a10, a11);
  }
  return 1;
}

void sub_187F7DABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F7DAC8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Exception *v15;

  _Unwind_Resume(v15);
}

uint64_t kdu_region_compositor::set_single_component(kdu_region_compositor *this, int a2, uint64_t a3, unsigned __int32 a4)
{
  uint64_t i;
  kdrc_stream *v9;
  jpx_source *v10;
  int v11;
  int v12;
  mj2_source *v13;
  uint64_t v14;
  mj2_video_source *v15;
  __n128 *v16;
  unsigned int v18[4];
  __int128 v19;
  uint64_t v20;
  int v21[2];
  char v22[16];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((_BYTE *)this + 429) = 1;
  for (i = *((_QWORD *)this + 59); i; i = *((_QWORD *)this + 59))
    kdu_region_compositor::remove_compositing_layer((uint64_t *)this, *(_DWORD *)(i + 236), 0);
  if (*((_QWORD *)this + 60))
    kdu_region_compositor::set_single_component();
  while (1)
  {
    v9 = (kdrc_stream *)*((_QWORD *)this + 62);
    if (!v9)
      break;
    kdu_region_compositor::remove_stream((uint64_t)this, v9, 0);
  }
  if (*((_QWORD *)this + 1))
  {
    if (a2)
    {
      *(_QWORD *)&v24 = 0;
      *(_OWORD *)v22 = 0u;
      v23 = 0u;
      kdu_error::kdu_error((kdu_error *)v22, "Error in Kakadu Region Compositor:\n");
      kdu_error::~kdu_error((kdu_error *)v22);
    }
    goto LABEL_23;
  }
  v10 = (jpx_source *)*((_QWORD *)this + 2);
  if (!v10)
  {
    v13 = (mj2_source *)*((_QWORD *)this + 3);
    if (!v13)
      kdu_region_compositor::set_single_component();
    v18[0] = 0;
    *(_QWORD *)v21 = 0;
    if (mj2_source::find_stream(v13, a2, v18, &v21[1], v21))
    {
      if (!v18[0])
      {
        *(_QWORD *)&v24 = 0;
        *(_OWORD *)v22 = 0u;
        v23 = 0u;
        kdu_error::kdu_error((kdu_error *)v22, "Error in Kakadu Region Compositor:\n");
        kdu_error::~kdu_error((kdu_error *)v22);
      }
      v14 = mj2_source::access_video_track(*((mj2_source **)this + 3), v18[0]);
      v15 = (mj2_video_source *)v14;
      if (v14)
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 104))(v14, v21[1]);
        if (mj2_video_source::can_open_stream(v15, v21[0]))
          goto LABEL_23;
      }
    }
    return 0xFFFFFFFFLL;
  }
  v18[0] = 0;
  v11 = jpx_source::count_codestreams(v10, (int *)v18);
  if (!jpx_source::access_codestream(*((jpx_source **)this + 2), a2, 1))
  {
    if (a2 < 0 || ((int)v18[0] <= a2 ? (v12 = v11) : (v12 = 0), v12 == 1))
    {
      *(_QWORD *)&v24 = 0;
      *(_OWORD *)v22 = 0u;
      v23 = 0u;
      kdu_error::kdu_error((kdu_error *)v22, "Error in Kakadu Region Compositor:\n");
      kdu_error::~kdu_error((kdu_error *)v22);
    }
    return 0xFFFFFFFFLL;
  }
LABEL_23:
  if (!kdu_region_compositor::add_active_stream(this, a2, -1, 0))
  {
    v20 = 0;
    *(_OWORD *)v18 = 0u;
    v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Error in Kakadu Region Compositor:\n");
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    *(_OWORD *)v22 = 0u;
    if (LOBYTE(v18[2]))
      sprintf(v22, "%x");
    else
      sprintf(v22, "%d");
    (*(void (**)(unsigned int *, char *))(*(_QWORD *)v18 + 16))(v18, v22);
    (*(void (**)(unsigned int *, const char *))(*(_QWORD *)v18 + 16))(v18, ") cannot be opened.");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  v16 = (__n128 *)*((_QWORD *)this + 62);
  if (v16[69].n128_u32[0] != a2)
    kdu_region_compositor::set_single_component();
  return kdrc_stream::set_mode(v16, a3, a4);
}

void sub_187F7DE7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F7DE88(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

uint64_t kdu_region_compositor::set_scale(uint64_t this, int a2, int a3, int a4, float a5)
{
  float v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_DWORD *)(this + 340) = 0;
  if (!*(_BYTE *)(this + 324)
    || *(unsigned __int8 *)(this + 334) != a2
    || *(unsigned __int8 *)(this + 332) != a3
    || *(unsigned __int8 *)(this + 333) != a4)
  {
    *(_BYTE *)(this + 334) = a2;
    *(_BYTE *)(this + 332) = a3;
    *(_BYTE *)(this + 333) = a4;
    *(float *)(this + 336) = a5;
    *(_BYTE *)(this + 324) = 1;
    *(_BYTE *)(this + 429) = 1;
LABEL_10:
    *(_QWORD *)(this + 408) = 0;
    v6 = *(uint64_t **)(this + 512);
    v7 = v6[1];
    if (v7)
    {
      v8 = *v6;
      do
      {
        v9 = v7;
        v7 = *(_QWORD *)(v7 + 16);
        *(_QWORD *)(v9 + 16) = v8;
        v8 = v9;
      }
      while (v7);
      *v6 = v9;
      v6[1] = 0;
    }
    return this;
  }
  v5 = *(float *)(this + 336);
  if (*(_BYTE *)(this + 429) || v5 != a5)
  {
    *(_BYTE *)(this + 334) = a2;
    *(_BYTE *)(this + 332) = a3;
    *(_BYTE *)(this + 333) = a4;
    *(float *)(this + 336) = a5;
    *(_BYTE *)(this + 324) = 1;
    *(_BYTE *)(this + 429) = 1;
    if (v5 != a5)
      goto LABEL_10;
  }
  return this;
}

void kdu_region_compositor::set_buffer_surface(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int *v8;
  _BYTE *v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  kdrc_stream *i;
  __int128 v42;

  v8 = (int *)(a1 + 400);
  if (*(_QWORD *)(a1 + 400) != a2 || *(_QWORD *)(a1 + 408) != a3 || *(_DWORD *)(a1 + 424) != a4)
    kdu_region_compositor::flush_composition_queue((_QWORD *)a1);
  v9 = *(_BYTE **)(a1 + 392);
  if (!v9)
  {
    *(_DWORD *)(a1 + 424) = a4;
    if (!*(_BYTE *)(a1 + 429))
    {
      v12 = *(_QWORD *)(a1 + 400);
      v13 = *(_QWORD *)(a1 + 408);
      *(_QWORD *)&v42 = a2;
      *((_QWORD *)&v42 + 1) = a3;
      v16 = (uint64_t *)(a1 + 408);
      kdu_dims::operator&=(&v42, (int *)(a1 + 376));
      v11 = 0;
      *(_OWORD *)(a1 + 400) = v42;
      goto LABEL_20;
    }
LABEL_13:
    *(_QWORD *)(a1 + 400) = a2;
    *(_QWORD *)(a1 + 408) = a3;
    return;
  }
  v10 = *(_DWORD *)(a1 + 424);
  v11 = v10 != a4;
  *(_DWORD *)(a1 + 424) = a4;
  if (*(_BYTE *)(a1 + 429))
    goto LABEL_13;
  v12 = *(_QWORD *)(a1 + 400);
  v13 = *(_QWORD *)(a1 + 408);
  *(_QWORD *)&v42 = a2;
  *((_QWORD *)&v42 + 1) = a3;
  kdu_dims::operator&=(&v42, (int *)(a1 + 376));
  v14 = *((_QWORD *)&v42 + 1);
  *(_QWORD *)(a1 + 400) = v42;
  *(_QWORD *)(a1 + 408) = v14;
  v15 = (_DWORD *)(a1 + 416);
  if (*(_DWORD *)(a1 + 420) < SHIDWORD(v14) || *v15 < (int)v14)
    *(_QWORD *)(a1 + 392) = kdu_region_compositor::internal_allocate_buffer(a1, v14, (uint64_t)v15);
  v16 = (uint64_t *)(a1 + 408);
  if (v10 == a4)
  {
    v17 = (uint64_t)v9;
    v18 = v12;
    v19 = v13;
  }
  else
  {
    v17 = 0;
    v18 = 0;
    v19 = 0;
  }
  initialize_buffer_surface(*(_QWORD *)(a1 + 392), *(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 408), v17, v18, v19, *(_DWORD *)(a1 + 424), 0);
  if (v9 != *(_BYTE **)(a1 + 392))
  {
    if (v9[24])
      (*(void (**)(_BYTE *))(*(_QWORD *)v9 + 8))(v9);
    else
      (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 64))(a1, v9);
  }
LABEL_20:
  if (*(_QWORD *)(a1 + 472))
  {
    kdu_region_compositor::set_layer_buffer_surfaces(a1);
  }
  else
  {
    v20 = *(_QWORD *)(a1 + 496);
    if (!v20 || *(_QWORD *)(v20 + 1128) || (v21 = *(_QWORD *)(a1 + 392)) == 0)
      kdu_region_compositor::set_buffer_surface();
    kdrc_stream::set_buffer_surface(v20, v21, *(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 408), 0);
    *(_BYTE *)(a1 + 428) = 0;
  }
  *(_QWORD *)&v42 = v12;
  *((_QWORD *)&v42 + 1) = v13;
  kdu_dims::operator&=(&v42, v8);
  if (v11
    || (v22 = DWORD2(v42), v23 = HIDWORD(*((_QWORD *)&v42 + 1)), SHIDWORD(v42) < 1)
    || *(uint64_t *)((char *)&v42 + 4) <= 0)
  {
    v36 = *(uint64_t **)(a1 + 512);
    v38 = v36[1];
    if (v38)
    {
      v39 = *v36;
      do
      {
        v40 = v38;
        v38 = *(_QWORD *)(v38 + 16);
        *(_QWORD *)(v40 + 16) = v39;
        v39 = v40;
      }
      while (v38);
      *v36 = v40;
      v36[1] = 0;
    }
    v37 = *(_QWORD *)(a1 + 400);
    v35 = *(_QWORD *)(a1 + 408);
  }
  else
  {
    v24 = v16;
    v25 = v42;
    kdrc_refresh::adjust(*(_QWORD *)(a1 + 512), *(_QWORD *)(a1 + 400), *(_QWORD *)(a1 + 408));
    v26 = *(_QWORD *)(a1 + 400);
    v27 = (HIDWORD(v25) - HIDWORD(v26));
    if ((v27 & 0x80000000) != 0
      || (v28 = (v23 + HIDWORD(v25)),
          v29 = *(_DWORD *)(a1 + 412) - v28 + HIDWORD(v26),
          (v29 & 0x80000000) != 0)
      || (v30 = (v25 - v26), (v30 & 0x80000000) != 0)
      || (v31 = v22 + v25, v32 = v26 - (v22 + (_DWORD)v25) + *(_DWORD *)(a1 + 408),
                           (v32 & 0x80000000) != 0))
    {
      kdu_region_compositor::set_buffer_surface();
    }
    v33 = *v24;
    if (HIDWORD(v25) != HIDWORD(v26))
      kdrc_refresh::add_region(*(_QWORD **)(a1 + 512), v26 & 0xFFFFFFFF00000000 | v25, v22 | (unint64_t)(v27 << 32));
    if (v29)
      kdrc_refresh::add_region(*(_QWORD **)(a1 + 512), (v28 << 32) | v25, v22 | ((unint64_t)v29 << 32));
    v34 = v33 & 0xFFFFFFFF00000000;
    if (SHIDWORD(v33) >= 1 && (_DWORD)v25 != (_DWORD)v26)
      kdrc_refresh::add_region(*(_QWORD **)(a1 + 512), v26, v34 | v30);
    if (SHIDWORD(v33) < 1 || !(_DWORD)v32)
      goto LABEL_49;
    v35 = v34 | v32;
    v36 = *(uint64_t **)(a1 + 512);
    v37 = v26 & 0xFFFFFFFF00000000 | v31;
  }
  kdrc_refresh::add_region(v36, v37, v35);
LABEL_49:
  for (i = *(kdrc_stream **)(a1 + 496); i; i = (kdrc_stream *)*((_QWORD *)i + 141))
    kdrc_refresh::adjust(*(kdrc_refresh **)(a1 + 512), i);
}

uint64_t kdu_region_compositor::set_layer_buffer_surfaces(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  signed int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  _BOOL4 v15;
  BOOL v17;
  int v18;
  int v19;
  _BOOL4 v21;
  int v23;
  BOOL v24;
  int v25;

  v1 = *(_QWORD *)(this + 480);
  if (v1)
  {
    v2 = this;
    v3 = *(_QWORD *)(this + 408);
    v4 = *(unsigned int *)(this + 404);
    v5 = *(_DWORD *)(this + 400);
    v6 = v3 + v5;
    v7 = HIDWORD(v3) + v4;
    do
    {
      this = kdrc_layer::set_buffer_surface(v1, *(_QWORD *)(v2 + 400), *(_QWORD *)(v2 + 408), v5 | (unint64_t)(v4 << 32), v3, *(_QWORD *)(v2 + 392), *(unsigned __int8 *)(v2 + 431));
      *(_BYTE *)(v2 + 428) = 0;
      if (!*(_BYTE *)(v1 + 232))
      {
        v9 = *(_DWORD *)(v1 + 152);
        v8 = *(_DWORD *)(v1 + 156);
        v10 = *(_DWORD *)(v1 + 164) + v8;
        v11 = *(_DWORD *)(v1 + 160) + v9;
        if ((_DWORD)v4 == v8 && v7 == v10)
        {
          v21 = v6 <= v9 || v6 > v11;
          if (v5 >= v11 || v5 < v9)
            v23 = v5;
          else
            v23 = *(_DWORD *)(v1 + 160) + v9;
          v24 = !v21;
          if (v21)
            v25 = v23;
          else
            v25 = v5;
          if (!v24)
            v9 = v6;
          if (v25 <= *(_DWORD *)(v2 + 400))
            v5 = *(_DWORD *)(v2 + 400);
          else
            v5 = v25;
          if (v9 <= v5)
            v6 = v5;
          else
            v6 = v9;
          v3 = v3 & 0xFFFFFFFF00000000 | (v6 - v5);
        }
        else if (v5 == v9 && v6 == v11)
        {
          v15 = v7 <= v8 || v7 > v10;
          if ((int)v4 >= v10 || (int)v4 < v8)
            v10 = v4;
          v17 = !v15;
          if (v15)
            v18 = v10;
          else
            v18 = v4;
          if (!v17)
            v8 = v7;
          v19 = *(_DWORD *)(v2 + 404);
          if (v18 <= v19)
            v4 = v19;
          else
            v4 = v18;
          if (v8 <= (int)v4)
            v7 = v4;
          else
            v7 = v8;
          v3 = v3 | ((unint64_t)(v7 - v4) << 32);
        }
      }
      v1 = *(_QWORD *)(v1 + 248);
    }
    while (v1);
  }
  return this;
}

uint64_t kdu_region_compositor::get_total_composition_dims(kdu_region_compositor *this, kdu_dims *a2)
{
  uint64_t result;

  if (!*((_BYTE *)this + 429) || (result = kdu_region_compositor::update_composition(this), (_DWORD)result))
  {
    *(_OWORD *)a2 = *(_OWORD *)((char *)this + 376);
    return 1;
  }
  return result;
}

uint64_t kdu_region_compositor::update_composition(kdu_region_compositor *this)
{
  int *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  char v8;
  unint64_t v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;
  int v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  double v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  uint64_t v36;
  uint64_t v37;
  _BYTE *buffer;
  _BYTE *v39;
  uint64_t i;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  kdrc_stream *j;

  *((_DWORD *)this + 85) = 0;
  if (!*((_BYTE *)this + 324))
    return 0;
  v2 = (int *)((char *)this + 340);
  v3 = *((_QWORD *)this + 62);
  v4 = *((_QWORD *)this + 59);
  if (!v3)
  {
    if (v4)
      goto LABEL_12;
    return 0;
  }
  if (!v4)
  {
    if (*(_QWORD *)(v3 + 1128))
      kdu_region_compositor::update_composition();
    *((_QWORD *)this + 47) = kdrc_stream::set_scale(v3, 0, 0, 0, 0, 0, 0x100000001uLL, *((unsigned __int8 *)this + 334), *((float *)this + 84), *((_WORD *)this + 166), HIBYTE(*((_WORD *)this + 166)), v2);
    *((_QWORD *)this + 48) = v5;
    if (SHIDWORD(v5) < 1 || (int)v5 < 1)
    {
LABEL_10:
      result = 0;
      *((_BYTE *)this + 324) = 0;
      return result;
    }
    v35 = (int *)((char *)this + 376);
    goto LABEL_57;
  }
LABEL_12:
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  do
  {
    if (v4 != *((_QWORD *)this + 59) || *(_BYTE *)(v4 + 232) || *(_BYTE *)(v4 + 234))
      v8 = 1;
    if (*(_QWORD *)(v4 + 72))
    {
      v13 = kdrc_layer::set_scale((kdrc_layer *)v4, *((unsigned __int8 *)this + 334), *((unsigned __int8 *)this + 332), *((_BYTE *)this + 333), *((float *)this + 84), v2);
      if (v14 < 1 || v15 < 1)
        goto LABEL_10;
      if ((_DWORD)v9 == v12 && v10 == v11)
      {
        v12 = v15 + HIDWORD(v13);
        v11 = v14 + v13;
        v10 = v13;
        v9 = HIDWORD(v13);
      }
      else
      {
        if ((int)v9 >= SHIDWORD(v13))
          v9 = HIDWORD(v13);
        else
          v9 = v9;
        if (v10 >= (int)v13)
          v10 = v13;
        if (v15 + HIDWORD(v13) > v12)
          v12 = v15 + HIDWORD(v13);
        if (v11 <= v14 + (int)v13)
          v11 = v14 + v13;
      }
    }
    v4 = *(_QWORD *)(v4 + 240);
  }
  while (v4);
  v35 = (int *)((char *)this + 376);
  v17 = (v12 - v9);
  v18 = (v11 - v10);
  *((_QWORD *)this + 47) = v10 | (v9 << 32);
  *((_QWORD *)this + 48) = v18 | (v17 << 32);
  if ((int)v17 < 1 || (int)v18 < 1 || *((int *)this + 89) > 0 && *((int *)this + 88) >= 1)
  {
    v19 = *((_DWORD *)this + 89);
    if (v19 < 1 || (v20 = *((_DWORD *)this + 88), v20 <= 0))
    {
      v21 = *((_DWORD *)this + 90);
      v22 = *((_DWORD *)this + 91);
      v23 = *((_DWORD *)this + 93) - v22;
      v20 = *((_DWORD *)this + 92);
    }
    else
    {
      v21 = *((_DWORD *)this + 86);
      v22 = *((_DWORD *)this + 87);
      v23 = v19 - v22;
    }
    v24 = v20 - v21;
    v25 = *((float *)this + 84);
    v26 = vcvtmd_s64_f64((double)v22 * v25);
    LODWORD(v27) = vcvtmd_s64_f64((double)v21 * v25);
    v28 = vcvtpd_s64_f64(v25 * (double)v23) - v26;
    v29 = vcvtpd_s64_f64(v25 * (double)v24) - v27;
    v30 = v29 | (v28 << 32);
    v31 = v28 | (v29 << 32);
    if (*((_BYTE *)this + 334))
      v32 = v26;
    else
      v32 = v27;
    if (*((_BYTE *)this + 334))
    {
      v33 = v31;
    }
    else
    {
      LODWORD(v27) = v26;
      v33 = v30;
    }
    if (*((_BYTE *)this + 333))
      v27 = (1 - v27 - HIDWORD(v33));
    else
      v27 = v27;
    LODWORD(v34) = 1 - v32 - v33;
    if (*((_BYTE *)this + 332))
      v34 = v34;
    else
      v34 = v32;
    *((_QWORD *)this + 47) = v34 | (v27 << 32);
    *((_QWORD *)this + 48) = v33;
LABEL_57:
    kdu_dims::operator&=((_DWORD *)this + 100, v35);
    goto LABEL_58;
  }
  kdu_dims::operator&=((_DWORD *)this + 100, v35);
  if ((v8 & 1) == 0)
  {
    v39 = (_BYTE *)*((_QWORD *)this + 49);
    if (v39)
    {
      if (v39[24])
        (*(void (**)(_QWORD))(*(_QWORD *)v39 + 8))(*((_QWORD *)this + 49));
      else
        (*(void (**)(kdu_region_compositor *))(*(_QWORD *)this + 64))(this);
      *((_QWORD *)this + 49) = 0;
      *((_QWORD *)this + 52) = 0;
    }
    goto LABEL_71;
  }
LABEL_58:
  v36 = *((unsigned int *)this + 102);
  v37 = *((unsigned int *)this + 103);
  buffer = (_BYTE *)*((_QWORD *)this + 49);
  if (buffer)
  {
    if ((int)v37 <= *((_DWORD *)this + 105) && (int)v36 <= *((_DWORD *)this + 104))
      goto LABEL_70;
    if (buffer[24])
      (*(void (**)(_QWORD))(*(_QWORD *)buffer + 8))(*((_QWORD *)this + 49));
    else
      (*(void (**)(kdu_region_compositor *, _QWORD))(*(_QWORD *)this + 64))(this, *((_QWORD *)this + 49));
    *((_QWORD *)this + 49) = 0;
  }
  buffer = (_BYTE *)kdu_region_compositor::internal_allocate_buffer((uint64_t)this, v36 | (v37 << 32), (uint64_t)this + 416);
  *((_QWORD *)this + 49) = buffer;
LABEL_70:
  initialize_buffer_surface((uint64_t)buffer, *((_QWORD *)this + 50), *((_QWORD *)this + 51), 0, 0, 0, *((_DWORD *)this + 106), 0);
LABEL_71:
  if (*((_QWORD *)this + 59))
  {
    kdu_region_compositor::set_layer_buffer_surfaces((uint64_t)this);
    for (i = *((_QWORD *)this + 59); i; i = *(_QWORD *)(i + 240))
      kdrc_layer::configure_overlay(i, *((_BYTE *)this + 430), *((_DWORD *)this + 110), *((unsigned int *)this + 109));
  }
  else
  {
    kdrc_stream::set_buffer_surface(*((_QWORD *)this + 62), *((_QWORD *)this + 49), *((_QWORD *)this + 50), *((_QWORD *)this + 51), 1);
  }
  v41 = (uint64_t *)*((_QWORD *)this + 64);
  v42 = v41[1];
  if (v42)
  {
    v43 = *v41;
    do
    {
      v44 = v42;
      v42 = *(_QWORD *)(v42 + 16);
      *(_QWORD *)(v44 + 16) = v43;
      v43 = v44;
    }
    while (v42);
    *v41 = v44;
    v41[1] = 0;
  }
  kdrc_refresh::add_region(v41, *((_QWORD *)this + 50), *((_QWORD *)this + 51));
  for (j = (kdrc_stream *)*((_QWORD *)this + 62); j; j = (kdrc_stream *)*((_QWORD *)j + 141))
    kdrc_refresh::adjust(*((kdrc_refresh **)this + 64), j);
  *((_WORD *)this + 214) = 0;
  return 1;
}

uint64_t kdu_region_compositor::set_thread_env(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t j;
  uint64_t result;

  if (a2)
  {
    if (*(_QWORD *)(a2 + 32))
      v4 = a2;
    else
      v4 = 0;
  }
  else
  {
    v4 = 0;
  }
  if (v4)
    v5 = a3;
  else
    v5 = 0;
  if (v4 != a1[65] || v5 != a1[66])
  {
    for (i = a1[62]; i; i = *(_QWORD *)(i + 1128))
      kdrc_stream::set_thread_env(i, v4, v5);
    for (j = a1[63]; j; j = *(_QWORD *)(j + 1128))
      kdrc_stream::set_thread_env(j, v4, v5);
  }
  result = a1[65];
  a1[65] = v4;
  a1[66] = v5;
  return result;
}

uint64_t kdu_region_compositor::process(kdu_region_compositor *this, int a2, kdu_dims *a3)
{
  uint64_t result;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_DWORD *)this + 85) = 0;
  if (*((_BYTE *)this + 429))
  {
    result = kdu_region_compositor::update_composition(this);
    if (!(_DWORD)result)
      return result;
  }
  if (*((_BYTE *)this + 428))
    return 0;
  *((_BYTE *)this + 428) = 1;
  v7 = (_QWORD *)*((_QWORD *)this + 64);
  v8 = v7[1];
  if (!v8)
  {
    v11 = *((_QWORD *)this + 62);
    if (!v11)
      goto LABEL_29;
    v12 = 0;
    do
    {
      if (!*(_BYTE *)(v11 + 1124)
        && (*(_BYTE *)(v11 + 1068) || !*(_BYTE *)(*(_QWORD *)(v11 + 1136) + 296))
        && (!v12 || *(_DWORD *)(v11 + 1120) > *(_DWORD *)(v12 + 1120)))
      {
        v12 = v11;
      }
      v11 = *(_QWORD *)(v11 + 1128);
    }
    while (v11);
    if (v12)
    {
      if (*(_BYTE *)(v12 + 1124))
        kdu_region_compositor::process();
      *((_BYTE *)this + 428) = 0;
      if ((kdrc_stream::process((kdrc_stream *)v12, a2, (int32x2_t *)a3, (int *)this + 85) & 1) == 0)
      {
        if (!*((_DWORD *)this + 85))
          kdu_region_compositor::process();
        result = 0;
        *((_BYTE *)this + 324) = 0;
        *((_BYTE *)this + 429) = 1;
        return result;
      }
    }
    else
    {
LABEL_29:
      v13 = *((_QWORD *)this + 59);
      if (v13)
      {
        while (!*(_BYTE *)(v13 + 234) || (kdrc_layer::process_overlay((kdrc_layer *)v13, a3) & 1) == 0)
        {
          v13 = *(_QWORD *)(v13 + 240);
          if (!v13)
            goto LABEL_33;
        }
        goto LABEL_7;
      }
    }
LABEL_33:
    if (*((_BYTE *)this + 428))
      return 0;
    goto LABEL_8;
  }
  v9 = *(_QWORD *)(v8 + 16);
  *(_QWORD *)(v8 + 16) = *v7;
  *v7 = v8;
  v7[1] = v9;
  *(_OWORD *)a3 = *(_OWORD *)v8;
LABEL_7:
  *((_BYTE *)this + 428) = 0;
LABEL_8:
  if (!*((_QWORD *)this + 49))
    return 1;
  v10 = *((_QWORD *)this + 59);
  result = 1;
  if (v10 && *((int *)a3 + 3) >= 1 && *((int *)a3 + 2) >= 1)
  {
    do
    {
      kdrc_layer::update_composition(v10, *(_QWORD *)a3, *((_QWORD *)a3 + 1), *((_DWORD *)this + 106));
      v10 = *(_QWORD *)(v10 + 240);
    }
    while (v10);
    return 1;
  }
  return result;
}

_QWORD *kdu_region_compositor::reset(_QWORD *this)
{
  uint64_t i;

  for (i = this[62]; i; i = *(_QWORD *)(i + 1128))
    *(_BYTE *)(i + 1124) = 0;
  if (this[49])
    this[51] = 0;
  return this;
}

uint64_t kdu_region_compositor::get_next_codestream(kdu_region_compositor *this, kdrc_stream *a2, char a3, int a4)
{
  unsigned __int8 v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;

  if (a2 && !*((_BYTE *)a2 + 1125))
  {
    v7 = (char *)a2 + 1128;
    goto LABEL_9;
  }
  v4 = a3 ^ 1;
  v5 = (char *)this + 496;
  if (a2)
    v5 = (char *)a2 + 1128;
  v6 = *(_QWORD *)v5;
  if (!v6 && (a3 & 1) == 0)
  {
    v7 = (char *)this + 504;
LABEL_9:
    v4 = 0;
    v6 = *(_QWORD *)v7;
  }
  if (v6)
  {
    v8 = v6;
    while (a4)
    {
      if (*(_QWORD *)(*(_QWORD *)(v8 + 1136) + 320) == v8)
        return v8;
      v8 = *(_QWORD *)(v8 + 1128);
      if (((v8 == 0) & v4) == 1)
      {
        v4 = 0;
        v8 = *((_QWORD *)this + 63);
      }
      if (!v8)
        return 0;
    }
  }
  return v6;
}

uint64_t kdu_region_compositor::access_codestream(kdu_region_compositor *this, kdrc_stream *a2)
{
  uint64_t v3;
  uint64_t v4;

  if (!a2)
    return 0;
  v3 = *((_QWORD *)a2 + 142);
  v4 = *(_QWORD *)(v3 + 320);
  if (v4)
  {
    do
    {
      if (*(_BYTE *)(v4 + 1068))
      {
        kdu_region_decompressor::finish((kdu_region_decompressor *)(v4 + 120));
        *(_BYTE *)(*(_QWORD *)(v4 + 1136) + 296) = 0;
        *(_BYTE *)(v4 + 1068) = 0;
      }
      v4 = *(_QWORD *)(v4 + 1144);
    }
    while (v4);
    v3 = *((_QWORD *)a2 + 142);
  }
  return *(_QWORD *)(v3 + 288);
}

uint64_t kdu_region_compositor::paint_overlay(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10, int a11, int a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  int num_regions;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  signed int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  int v40;
  BOOL v41;
  int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  signed int v50;
  int v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  int v75;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  _DWORD *exception;
  signed int v83;
  int v84;
  unint64_t v85;
  unsigned int v86;
  unsigned int v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  int32x2_t v92[3];

  v92[0] = (int32x2_t)a3;
  v92[1] = (int32x2_t)a4;
  v91 = a8;
  num_regions = jpx_metanode::get_num_regions((jpx_metanode *)&v91);
  result = jpx_metanode::get_regions((jpx_metanode *)&v91);
  if (num_regions >= 1)
  {
    v24 = result;
    v25 = a10;
    if (a12 <= 1)
      v26 = 1;
    else
      v26 = a12;
    if (a11 <= 1)
      v27 = 1;
    else
      v27 = a11;
    v28 = a16 >> 32;
    if (a17 >> 32 <= 1)
      v29 = 1;
    else
      v29 = a17 >> 32;
    result = (int)a16;
    if ((int)a17 <= 1)
      v30 = 1;
    else
      v30 = (int)a17;
    v31 = ((char)a9 >> 7) & 0xFFFFFF00 | a9;
    if (v31 >= 2)
      v31 = 2;
    if (v31 <= -2)
      v31 = -2;
    v32 = (int)a6 * (uint64_t)SHIDWORD(a6);
    if ((a9 & 0x100) != 0)
      v33 = 0;
    else
      v33 = 0xFFFFFF;
    v84 = v33;
    v83 = v31 << 29;
    v88 = (a9 >> 8) % 6;
    v86 = v27;
    v87 = v26;
    v85 = v29;
    do
    {
      v34 = *(_QWORD *)v24;
      v35 = (*(_QWORD *)v24 & 0xFFFFFFFF00000000) + v25;
      v36 = HIDWORD(v35);
      if (v35 <= 0)
        v37 = -(int)(-HIDWORD(v35) / v26);
      else
        v37 = (HIDWORD(v35) - 1) / v26 + 1;
      v38 = v34 + v25;
      if ((int)v34 + (int)v25 <= 0)
        v39 = -(int)(-v38 / v27);
      else
        v39 = (v38 - 1) / v27 + 1;
      v40 = *(_DWORD *)(v24 + 12);
      v41 = __OFADD__((_DWORD)v36, v40);
      v42 = v36 + v40;
      if ((v42 < 0) ^ v41 | (v42 == 0))
        v43 = -(int)(-v42 / v26);
      else
        v43 = (v42 - 1) / v26 + 1;
      v44 = *(_DWORD *)(v24 + 8) + v38;
      if (v44 <= 0)
        v45 = -(int)(-v44 / v27);
      else
        v45 = (v44 - 1) / v27 + 1;
      v46 = v43 - v37;
      v47 = v45 - v39;
      v48 = v47 | (v46 << 32);
      v49 = v46 | (v47 << 32);
      if (a13)
        v50 = v37;
      else
        v50 = v39;
      if (a13)
        v37 = v39;
      else
        v49 = v48;
      if (a15)
        v51 = 1 - v37 - HIDWORD(v49);
      else
        v51 = v37;
      if (a14)
        v50 = 1 - v50 - v49;
      v52 = (int)v28 * (uint64_t)v51;
      if ((v52 & 0x8000000000000000) != 0)
      {
        v54 = ~v52 / v29;
        if (v54 >> 31)
          kdrc_overlay::map_from_compositing_grid(result, v22, v23);
        v53 = ~v54;
      }
      else
      {
        v53 = v52 / v29;
        if (v53 >> 31)
          kdrc_overlay::map_from_compositing_grid(result, v22, v23);
      }
      v55 = (int)result * (uint64_t)v50;
      if ((v55 & 0x8000000000000000) != 0)
      {
        v56 = ~v55 / v30;
        if (v56 >> 31)
          kdrc_overlay::map_from_compositing_grid(result, v22, v23);
        LODWORD(v56) = ~(_DWORD)v56;
      }
      else
      {
        v56 = v55 / v30;
        if (v56 >> 31)
          kdrc_overlay::map_from_compositing_grid(result, v22, v23);
      }
      v57 = (int)v28 * (uint64_t)(v51 + HIDWORD(v49));
      if (v57 <= 0)
      {
        v59 = -v57 / v29;
        if (v59 >= 0x80000001)
          goto LABEL_97;
        v58 = -(uint64_t)v59;
      }
      else
      {
        v58 = (v57 - 1) / v29;
        if (v58 >= 0x7FFFFFFF)
          goto LABEL_97;
        LODWORD(v58) = v58 + 1;
      }
      v60 = (int)result * (uint64_t)(v50 + (int)v49);
      if (v60 <= 0)
      {
        v62 = -v60 / v30;
        if (v62 >= 0x80000001)
        {
LABEL_97:
          exception = __cxa_allocate_exception(4uLL);
          *exception = -50;
          __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
        }
        v61 = -(uint64_t)v62;
      }
      else
      {
        v61 = (v60 - 1) / v30;
        if (v61 >= 0x7FFFFFFF)
          goto LABEL_97;
        LODWORD(v61) = v61 + 1;
      }
      v63 = v84;
      if (v32 > 63)
        v63 = 0;
      if (v32 >= 64 && v88 <= 5)
        v63 = dword_18820ED58[v88];
      v64 = v58 - v53;
      v65 = v61 - v56;
      v66 = v53 - HIDWORD(a18);
      v67 = v56 - a18;
      v68 = v63 - v83;
      v89 = (v56 - a18) | ((v53 - HIDWORD(a18)) << 32);
      v90 = (v61 - v56) | ((unint64_t)(v58 - v53) << 32);
      kdu_dims::operator&=(&v89, (int *)v92);
      v89 = (unint64_t)vsub_s32((int32x2_t)v89, v92[0]);
      if (SHIDWORD(v90) >= 1)
      {
        v69 = v90;
        if ((int)v90 >= 1)
        {
          if (*(_BYTE *)(a2 + 27)
            || ((*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, 0), v69 = v90, (int)v90 >= 1))
          {
            v70 = *(int *)(a2 + 44);
            v71 = *(_QWORD *)(a2 + 32) + 4 * (HIDWORD(v89) + (int)v89 * (int)v70);
            v72 = 4 * v70;
            do
            {
              if (SHIDWORD(v90) >= 1)
              {
                v73 = 0;
                v74 = HIDWORD(v90) + 1;
                do
                {
                  *(_DWORD *)(v71 + v73) = v68 - 1090519040;
                  v73 += 4;
                  --v74;
                }
                while (v74 > 1);
              }
              v71 += v72;
              v41 = __OFSUB__(v69--, 1);
            }
            while (!((v69 < 0) ^ v41 | (v69 == 0)));
          }
        }
      }
      LODWORD(v89) = v67 + 3;
      HIDWORD(v89) = v66 + 3;
      LODWORD(v90) = v65 - 6;
      HIDWORD(v90) = v64 - 6;
      kdu_dims::operator&=(&v89, (int *)v92);
      v89 = (unint64_t)vsub_s32((int32x2_t)v89, v92[0]);
      v75 = v90;
      if (SHIDWORD(v90) >= 1 && (int)v90 >= 1)
      {
        if (*(_BYTE *)(a2 + 27)
          || ((*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, 0), v75 = v90, (int)v90 >= 1))
        {
          v77 = *(int *)(a2 + 44);
          v78 = *(_QWORD *)(a2 + 32) + 4 * (HIDWORD(v89) + (int)v89 * (int)v77);
          v79 = 4 * v77;
          do
          {
            if (SHIDWORD(v90) >= 1)
            {
              v80 = 0;
              v81 = HIDWORD(v90) + 1;
              do
              {
                *(_DWORD *)(v78 + v80) = v68 + 1610612736;
                v80 += 4;
                --v81;
              }
              while (v81 > 1);
            }
            v78 += v79;
            v41 = __OFSUB__(v75--, 1);
          }
          while (!((v75 < 0) ^ v41 | (v75 == 0)));
        }
      }
      v24 += 20;
      v41 = __OFSUB__(num_regions--, 1);
      v25 = a10;
      v27 = v86;
      v26 = v87;
      v29 = v85;
      LODWORD(v28) = HIDWORD(a16);
      result = (int)a16;
    }
    while (!((num_regions < 0) ^ v41 | (num_regions == 0)));
  }
  return result;
}

uint64_t kdu_region_compositor::allocate_buffer()
{
  return 0;
}

void kdrc_codestream::~kdrc_codestream(kdrc_codestream *this)
{
  if (*((_QWORD *)this + 40))
    __assert_rtn("~kdrc_codestream", "region_compositor_local.h", 217, "head == NULL");
  if (*((_QWORD *)this + 36))
    kdu_codestream::destroy((kd_codestream **)this + 36);
  jpx_input_box::~jpx_input_box((kdrc_codestream *)((char *)this + 8));
}

void kdu_channel_mapping::~kdu_channel_mapping(j2_colour_converter **this)
{
  kdu_channel_mapping::clear((kdu_channel_mapping *)this);
  jp2_colour_converter::clear(this + 6);
}

void kdrc_refresh::~kdrc_refresh(kdrc_refresh *this)
{
  uint64_t i;

  for (i = *((_QWORD *)this + 1); i; i = *((_QWORD *)this + 1))
  {
    *((_QWORD *)this + 1) = *(_QWORD *)(i + 16);
    MEMORY[0x18D761C30]();
  }
  while (*(_QWORD *)this)
  {
    *(_QWORD *)this = *(_QWORD *)(*(_QWORD *)this + 16);
    MEMORY[0x18D761C30]();
  }
}

void kdrc_queue::~kdrc_queue(kdrc_queue *this)
{
  if (*(_QWORD *)this)
    __assert_rtn("~kdrc_queue", "region_compositor_local.h", 59, "composition_buffer == NULL");
}

void OUTLINED_FUNCTION_0_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 259, a4);
}

void OUTLINED_FUNCTION_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 254, a4);
}

uint64_t _cg_jpeg_idct_ifast(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  __int16 *v7;
  uint64_t v8;
  unsigned int v9;
  _DWORD *v10;
  unsigned __int16 v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unint64_t v33;
  _DWORD *v34;
  unint64_t v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  _BYTE *v45;
  int v46;
  unint64_t v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  unsigned int v62;
  int v63;
  int v64;
  unsigned int v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  int v69;
  int v70;
  uint64_t result;
  uint64_t v72;
  _OWORD v73[16];
  uint64_t v74;

  v5 = 0;
  v74 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  v7 = (__int16 *)(a3 + 64);
  v8 = *(_QWORD *)(a2 + 88) + 128;
  v9 = 9;
  memset(v73, 0, sizeof(v73));
  do
  {
    v10 = (_DWORD *)(v8 + v5);
    v11 = *(v7 - 16);
    if ((unsigned __int16)*(v7 - 24) | v11)
      goto LABEL_9;
    if (*(v7 - 8) || *v7 || v7[8] || v7[16] || v7[24])
    {
      v11 = 0;
LABEL_9:
      v12 = *(v10 - 32) * *(v7 - 32);
      v13 = *(v10 - 16) * (__int16)v11;
      v14 = *v10 * *v7;
      v15 = v10[16] * v7[16];
      v16 = v14 + v12;
      v17 = v12 - v14;
      v18 = v15 + v13;
      v19 = ((unint64_t)(362 * (v13 - v15)) >> 8) - (v15 + v13);
      v20 = v18 + v16;
      v21 = v16 - v18;
      v22 = v19 + v17;
      v23 = v17 - v19;
      v24 = *(v10 - 24) * *(v7 - 24);
      v25 = *(v10 - 8) * *(v7 - 8);
      v26 = v10[8] * v7[8];
      v27 = v10[24] * v7[24];
      v28 = v26 + v25;
      v29 = v26 - v25;
      v30 = v27 + v24;
      v31 = v24 - v27;
      v32 = v30 + v28;
      v33 = (unint64_t)(362 * (v30 - v28)) >> 8;
      v34 = (_DWORD *)((char *)v73 + v5);
      *v34 = v32 + v20;
      v35 = (unint64_t)(473 * (v31 + v29)) >> 8;
      v36 = v35 - (v32 + ((unint64_t)(669 * v29) >> 8));
      LODWORD(v33) = v33 - v36;
      v34[56] = v20 - v32;
      v34[8] = v36 + v22;
      v37 = v35 - ((unint64_t)(277 * v31) >> 8) - v33;
      v34[48] = v22 - v36;
      v34[16] = v33 + v23;
      v34[40] = v23 - v33;
      v34[24] = v37 + v21;
      v38 = v21 - v37;
      v39 = 8;
      goto LABEL_10;
    }
    v38 = *(v10 - 32) * *(v7 - 32);
    v40 = (int *)((char *)v73 + v5);
    *v40 = v38;
    v40[8] = v38;
    v40[16] = v38;
    v40[24] = v38;
    v40[32] = v38;
    v40[40] = v38;
    v40[48] = v38;
    v39 = 14;
LABEL_10:
    *(_DWORD *)((char *)&v73[v39] + v5) = v38;
    --v9;
    v5 += 4;
    ++v7;
  }
  while (v9 > 1);
  v41 = v6 - 384;
  v42 = 28;
  v43 = a5;
  do
  {
    v44 = (int *)((char *)v73 + v42);
    v45 = (_BYTE *)(*a4 + v43);
    v46 = *(_DWORD *)((char *)&v73[-1] + v42 - 8);
    v47 = (*(_DWORD *)((char *)&v73[-1] + v42 - 12) + 16400);
    v48 = *(_DWORD *)((char *)&v73[-1] + v42 - 4);
    if (*(_QWORD *)((char *)&v73[-1] + v42 - 8))
      goto LABEL_20;
    if (*(v44 - 4)
      || *(_DWORD *)((char *)v73 + v42 - 12)
      || *(_DWORD *)((char *)v73 + v42 - 8)
      || *(_DWORD *)((char *)v73 + v42 - 4)
      || *(_DWORD *)((char *)v73 + v42))
    {
      v48 = 0;
LABEL_20:
      v50 = *(v44 - 4);
      v49 = *(v44 - 3);
      v51 = v49 + v47;
      v52 = v47 - v49;
      v54 = *(v44 - 2);
      v53 = *(v44 - 1);
      v55 = v53 + v48;
      v56 = ((362 * (unint64_t)(v48 - v53)) >> 8) - (v53 + v48);
      v57 = v55 + v51;
      v58 = v51 - v55;
      v59 = v56 + v52;
      v60 = v52 - v56;
      v61 = v50 + v54;
      v62 = v54 - v50;
      v63 = *v44;
      v64 = v63 + v46;
      v65 = v46 - v63;
      v66 = v64 + v61;
      v67 = (362 * (unint64_t)(v64 - v61)) >> 8;
      *v45 = *(_BYTE *)(v41 + (((unint64_t)(v66 + v57) >> 5) & 0x3FF));
      v68 = (473 * (unint64_t)(v65 + v62)) >> 8;
      v69 = v66 + ((669 * (unint64_t)v62) >> 8);
      v45[7] = *(_BYTE *)(v41 + (((unint64_t)(v57 - v66) >> 5) & 0x3FF));
      v45[1] = *(_BYTE *)(v41 + (((unint64_t)(v68 - v69 + v59) >> 5) & 0x3FF));
      LODWORD(v67) = v67 - (v68 - v69);
      v45[6] = *(_BYTE *)(v41 + (((unint64_t)(v59 - (v68 - v69)) >> 5) & 0x3FF));
      v45[2] = *(_BYTE *)(v41 + (((unint64_t)(v67 + v60) >> 5) & 0x3FF));
      v70 = v68 - ((277 * (unint64_t)v65) >> 8) - v67;
      v45[5] = *(_BYTE *)(v41 + (((unint64_t)(v60 - v67) >> 5) & 0x3FF));
      v45[3] = *(_BYTE *)(v41 + (((unint64_t)(v70 + v58) >> 5) & 0x3FF));
      result = *(unsigned __int8 *)(v41 + (((unint64_t)(v58 - v70) >> 5) & 0x3FF));
      v72 = 4;
      goto LABEL_21;
    }
    result = *(unsigned __int8 *)(v41 + ((v47 >> 5) & 0x3FF));
    *(_DWORD *)v45 = vdup_n_s8(result).u32[0];
    v45[4] = result;
    v45[5] = result;
    v45[6] = result;
    v72 = 7;
LABEL_21:
    v45[v72] = result;
    ++a4;
    v42 += 32;
  }
  while (v42 != 284);
  return result;
}

uint64_t kdu_convert_rgb_to_ycc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  int v5;
  int v6;
  int v7;
  __int16 *v8;
  uint64_t result;
  int *v10;
  int *v11;
  unsigned int v12;
  int v13;
  int v14;
  __int16 *v15;
  __int16 *v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;

  v3 = *(_DWORD *)a1;
  if (*(_DWORD *)a2 != *(_DWORD *)a1 || *(_DWORD *)a3 != v3)
    return 0xFFFFFFFFLL;
  v5 = *(unsigned __int8 *)(a1 + 6);
  v6 = *(unsigned __int8 *)(a2 + 6);
  if (((v5 ^ v6) & 1) != 0)
    return 0xFFFFFFFFLL;
  v7 = *(unsigned __int8 *)(a3 + 6);
  if (((v5 ^ v7) & 1) != 0)
    return 0xFFFFFFFFLL;
  v8 = *(__int16 **)(a1 + 8);
  if ((v5 & 2) == 0 && v8)
  {
    if ((v7 & 2) == 0)
    {
      result = 0xFFFFFFFFLL;
      if ((v6 & 2) == 0)
      {
        v10 = *(int **)(a2 + 8);
        if (v10)
        {
          v11 = *(int **)(a3 + 8);
          if (v11)
          {
            if ((v5 & 1) != 0)
            {
              if (v3 >= 1)
              {
                v12 = v3 + 1;
                do
                {
                  result = 0;
                  v13 = *v11 - *v10;
                  v14 = *(_DWORD *)v8 - *v10;
                  *(_DWORD *)v8 = (*(_DWORD *)v8 + 2 * *v10 + *v11) >> 2;
                  v8 += 2;
                  *v10++ = v13;
                  *v11++ = v14;
                  --v12;
                }
                while (v12 > 1);
                return result;
              }
              return 0;
            }
            if (v3 < 1)
              return 0;
            v25 = v3 + 1;
            do
            {
              result = 0;
              v26 = *(float *)v8;
              v27 = *(float *)v11;
              v28 = *(float *)v10 * 0.587 + v26 * 0.299 + v27 * 0.114;
              v29 = (v27 - v28) * 0.564334086;
              v30 = v26 - v28;
              *(float *)&v28 = v28;
              *(_DWORD *)v8 = LODWORD(v28);
              v8 += 2;
              *(float *)&v28 = v29;
              *v10++ = LODWORD(v28);
              *(float *)&v30 = v30 * 0.713266762;
              *v11++ = LODWORD(v30);
              --v25;
            }
            while (v25 > 1);
          }
        }
      }
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  if ((v7 & 2) == 0)
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if (v8)
  {
    if ((v6 & 2) != 0)
    {
      v15 = *(__int16 **)(a2 + 8);
      if (v15)
      {
        v16 = *(__int16 **)(a3 + 8);
        if (v16)
        {
          if ((v5 & 1) != 0)
          {
            if (v3 < 1)
              return 0;
            v17 = v3 + 1;
            do
            {
              result = 0;
              v18 = *v8;
              v19 = *v15;
              v20 = *v16;
              *v8++ = (v18 + 2 * v19 + v20) >> 2;
              *v15++ = v20 - v19;
              *v16++ = v18 - v19;
              --v17;
            }
            while (v17 > 1);
          }
          else
          {
            if (v3 < 1)
              return 0;
            v21 = v3 + 1;
            do
            {
              result = 0;
              v22 = *v8;
              v23 = *v16;
              v24 = 9617 * *v15 + 4899 * v22 + 1868 * v23 + 0x2000;
              *v8++ = v24 >> 14;
              *v15++ = (9246 * (v23 - (v24 >> 14)) + 0x2000) >> 14;
              *v16++ = (11686 * (v22 - (v24 >> 14)) + 0x2000) >> 14;
              --v21;
            }
            while (v21 > 1);
          }
        }
      }
    }
  }
  return result;
}

uint64_t kdu_convert_ycc_to_rgb(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  int v7;
  int v8;
  int v9;
  float *v10;
  uint64_t result;
  int *v12;
  float *v13;
  unsigned int v14;
  int v15;
  int v16;
  __int16 *v17;
  __int16 *v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  double v28;
  double v29;
  double v30;
  float v31;

  if (a4 >= 0)
    v4 = a4;
  else
    v4 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 < v4 || *(_DWORD *)a2 < v4 || *(_DWORD *)a3 < v4)
    return 0xFFFFFFFFLL;
  v7 = *(unsigned __int8 *)(a1 + 6);
  v8 = *(unsigned __int8 *)(a2 + 6);
  if (((v7 ^ v8) & 1) != 0)
    return 0xFFFFFFFFLL;
  v9 = *(unsigned __int8 *)(a3 + 6);
  if (((v7 ^ v9) & 1) != 0)
    return 0xFFFFFFFFLL;
  v10 = *(float **)(a1 + 8);
  if ((v7 & 2) == 0 && v10)
  {
    if ((v9 & 2) == 0)
    {
      result = 0xFFFFFFFFLL;
      if ((v8 & 2) == 0)
      {
        v12 = *(int **)(a2 + 8);
        if (v12)
        {
          v13 = *(float **)(a3 + 8);
          if (v13)
          {
            if ((v7 & 1) != 0)
            {
              if (v4 >= 1)
              {
                v14 = v4 + 1;
                do
                {
                  result = 0;
                  v15 = *(_DWORD *)v10 - ((*(_DWORD *)v13 + *v12) >> 2);
                  v16 = v15 + *v12;
                  *(_DWORD *)v10++ = v15 + *(_DWORD *)v13;
                  *v12++ = v15;
                  *(_DWORD *)v13++ = v16;
                  --v14;
                }
                while (v14 > 1);
                return result;
              }
              return 0;
            }
            if (v4 < 1)
              return 0;
            v27 = v4 + 1;
            do
            {
              result = 0;
              v28 = *v10;
              v29 = *(float *)v12;
              v30 = *v13;
              v31 = v28 + v30 * 1.402;
              *v10++ = v31;
              *(float *)&v30 = v28 + v30 * -0.714136286 + v29 * -0.344136286;
              *v12++ = LODWORD(v30);
              *(float *)&v28 = v28 + v29 * 1.772;
              *v13++ = *(float *)&v28;
              --v27;
            }
            while (v27 > 1);
          }
        }
      }
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  if ((v9 & 2) == 0)
    return 0xFFFFFFFFLL;
  result = 0xFFFFFFFFLL;
  if (v10)
  {
    if ((v8 & 2) != 0)
    {
      v17 = *(__int16 **)(a2 + 8);
      if (v17)
      {
        v18 = *(__int16 **)(a3 + 8);
        if (v18)
        {
          if ((v7 & 1) != 0)
          {
            if (v4 < 1)
              return 0;
            v19 = v4 + 1;
            do
            {
              result = 0;
              v20 = *v17;
              v21 = *v18;
              v22 = *(unsigned __int16 *)v10 - ((v21 + v20) >> 2);
              *(_WORD *)v10 = *(_WORD *)v10 - ((v21 + v20) >> 2) + v21;
              v10 = (float *)((char *)v10 + 2);
              *v17++ = v22;
              *v18++ = v22 + v20;
              --v19;
            }
            while (v19 > 1);
          }
          else
          {
            if (v4 < 1)
              return 0;
            v23 = v4 + 1;
            do
            {
              result = 0;
              v24 = *v17;
              v25 = *v18;
              v26 = (*(__int16 *)v10 << 14) | 0x2000;
              *(_WORD *)v10 = (v26 + 22970 * v25) >> 14;
              v10 = (float *)((char *)v10 + 2);
              *v17++ = (v26 + 1073736186 * v24 + 1073730124 * v25) >> 14;
              *v18++ = (v26 + 29032 * v24) >> 14;
              --v23;
            }
            while (v23 > 1);
          }
        }
      }
    }
  }
  return result;
}

uint64_t jpeg_core_output_dimensions(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t result;
  int v8;
  int v9;
  int *v10;

  v2 = *(int *)(a1 + 556);
  v3 = *(_DWORD *)(a1 + 72);
  v4 = v2 * *(_DWORD *)(a1 + 68);
  if (v4 <= v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(*(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(*(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0x100000001;
    v8 = 1;
  }
  else if (v4 <= 2 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(2 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(2 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0x200000002;
    v8 = 2;
  }
  else if (v4 <= 3 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(3 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(3 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0x300000003;
    v8 = 3;
  }
  else if (v4 <= 4 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(4 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(4 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0x400000004;
    v8 = 4;
  }
  else if (v4 <= 5 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(5 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(5 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0x500000005;
    v8 = 5;
  }
  else if (v4 <= 6 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(6 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(6 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0x600000006;
    v8 = 6;
  }
  else if (v4 <= 7 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(7 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(7 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0x700000007;
    v8 = 7;
  }
  else if (v4 <= 8 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(8 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(8 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0x800000008;
    v8 = 8;
  }
  else if (v4 <= 9 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(9 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(9 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0x900000009;
    v8 = 9;
  }
  else if (v4 <= 10 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(10 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(10 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0xA0000000ALL;
    v8 = 10;
  }
  else if (v4 <= 11 * v3)
  {
    v8 = 11;
    *(_DWORD *)(a1 + 136) = jdiv_round_up(11 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(11 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0xB0000000BLL;
  }
  else if (v4 <= 12 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(12 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(12 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0xC0000000CLL;
    v8 = 12;
  }
  else if (v4 <= 13 * v3)
  {
    v8 = 13;
    *(_DWORD *)(a1 + 136) = jdiv_round_up(13 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(13 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0xD0000000DLL;
  }
  else if (v4 <= 14 * v3)
  {
    *(_DWORD *)(a1 + 136) = jdiv_round_up(14 * *(unsigned int *)(a1 + 48), v2);
    result = jdiv_round_up(14 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(_QWORD *)(a1 + 424) = 0xE0000000ELL;
    v8 = 14;
  }
  else
  {
    v5 = 15 * v3;
    v6 = *(unsigned int *)(a1 + 48);
    if (v4 <= v5)
    {
      *(_DWORD *)(a1 + 136) = jdiv_round_up(15 * v6, v2);
      result = jdiv_round_up(15 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
      *(_DWORD *)(a1 + 140) = result;
      *(_QWORD *)(a1 + 424) = 0xF0000000FLL;
      v8 = 15;
    }
    else
    {
      *(_DWORD *)(a1 + 136) = jdiv_round_up(16 * v6, v2);
      result = jdiv_round_up(16 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
      *(_DWORD *)(a1 + 140) = result;
      *(_QWORD *)(a1 + 424) = 0x1000000010;
      v8 = 16;
    }
  }
  v9 = *(_DWORD *)(a1 + 56);
  if (v9 >= 1)
  {
    v10 = (int *)(*(_QWORD *)(a1 + 304) + 40);
    do
    {
      *(v10 - 1) = v8;
      *v10 = v8;
      v10 += 24;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t _cg_jinit_input_controller(uint64_t a1)
{
  uint64_t result;

  result = (**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 608) = result;
  *(_QWORD *)result = consume_markers;
  *(_QWORD *)(result + 8) = reset_input_controller;
  *(_QWORD *)(result + 16) = start_input_pass_0;
  *(_QWORD *)(result + 24) = finish_input_pass;
  *(_QWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 1;
  return result;
}

uint64_t consume_markers(uint64_t *a1)
{
  _DWORD *v1;
  uint64_t v2;
  uint64_t v5;
  __n128 v6;
  int v7;
  void (**v8)(_QWORD);
  int v9;
  void (**v10)(_QWORD);
  int v11;
  void (**v12)(_QWORD);
  int v13;
  uint64_t v14;
  uint64_t v15;
  int32x2_t v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  _BOOL4 v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;

  v1 = (_DWORD *)a1[76];
  v2 = 2;
  if (v1[9])
    return v2;
  while (1)
  {
    v5 = (*(uint64_t (**)(uint64_t *))(a1[77] + 8))(a1);
    if ((_DWORD)v5 != 1)
      break;
    v7 = v1[10];
    if (v7)
    {
      if (v7 != 1)
      {
        if (*((_DWORD *)a1 + 112))
          goto LABEL_86;
        goto LABEL_37;
      }
      if (*((_DWORD *)a1 + 13) > 0xFFDCu || *((_DWORD *)a1 + 12) >= 0xFFDDu)
      {
        v8 = (void (**)(_QWORD))*a1;
        *((_DWORD *)v8 + 10) = 42;
        *((_DWORD *)v8 + 12) = 65500;
        (*(void (**)(uint64_t *))*a1)(a1);
      }
      v9 = *((_DWORD *)a1 + 74);
      if ((v9 - 13) <= 0xFFFFFFFA)
      {
        v10 = (void (**)(_QWORD))*a1;
        *((_DWORD *)v10 + 10) = 16;
        *((_DWORD *)v10 + 12) = v9;
        (*(void (**)(uint64_t *))*a1)(a1);
      }
      v11 = *((_DWORD *)a1 + 14);
      if (v11 >= 11)
      {
        v12 = (void (**)(_QWORD))*a1;
        *((_DWORD *)v12 + 10) = 27;
        *((_DWORD *)v12 + 12) = v11;
        *(_DWORD *)(*a1 + 52) = 10;
        (*(void (**)(uint64_t *))*a1)(a1);
        v11 = *((_DWORD *)a1 + 14);
      }
      a1[52] = 0x100000001;
      if (v11 >= 1)
      {
        v13 = 0;
        v14 = a1[38] + 8;
        v6.n128_u64[0] = 0x100000001;
        do
        {
          if ((*(_DWORD *)v14 - 5) >= 0xFFFFFFFC && (*(_DWORD *)(v14 + 4) - 5) > 0xFFFFFFFB)
          {
            v16 = *(int32x2_t *)v14;
          }
          else
          {
            v15 = *a1;
            *(_DWORD *)(v15 + 40) = 19;
            (*(void (**)(uint64_t *, __n128))v15)(a1, v6);
            v6.n128_u64[0] = a1[52];
            v16 = *(int32x2_t *)v14;
            v11 = *((_DWORD *)a1 + 14);
          }
          v6.n128_u64[0] = (unint64_t)vmax_s32((int32x2_t)v6.n128_u64[0], v16);
          a1[52] = v6.n128_u64[0];
          ++v13;
          v14 += 96;
        }
        while (v13 < v11);
      }
      if (*((_DWORD *)a1 + 78) || *((_DWORD *)a1 + 79) && *((_DWORD *)a1 + 112))
      {
LABEL_21:
        v17 = 8;
LABEL_22:
        *((_DWORD *)a1 + 139) = v17;
        a1[70] = (uint64_t)&_cg_jpeg_natural_order;
        *((_DWORD *)a1 + 142) = 63;
        goto LABEL_23;
      }
      v24 = *((_DWORD *)a1 + 136);
      if (v24 > 79)
      {
        if (v24 > 167)
        {
          if (v24 > 223)
          {
            if (v24 == 224)
            {
              v17 = 15;
              goto LABEL_22;
            }
            if (v24 == 255)
            {
              v17 = 16;
              goto LABEL_22;
            }
          }
          else
          {
            if (v24 == 168)
            {
              v17 = 13;
              goto LABEL_22;
            }
            if (v24 == 195)
            {
              v17 = 14;
              goto LABEL_22;
            }
          }
        }
        else if (v24 > 119)
        {
          if (v24 == 120)
          {
            v17 = 11;
            goto LABEL_22;
          }
          if (v24 == 143)
          {
            v17 = 12;
            goto LABEL_22;
          }
        }
        else
        {
          if (v24 == 80)
          {
            v17 = 9;
            goto LABEL_22;
          }
          if (v24 == 99)
          {
            v17 = 10;
            goto LABEL_22;
          }
        }
      }
      else if (v24 > 23)
      {
        if (v24 > 47)
        {
          if (v24 == 48)
          {
            v17 = 7;
            *((_DWORD *)a1 + 139) = 7;
            a1[70] = (uint64_t)&jpeg_natural_order7;
            v25 = 48;
            goto LABEL_78;
          }
          if (v24 == 63)
            goto LABEL_21;
        }
        else
        {
          if (v24 == 24)
          {
            v17 = 5;
            *((_DWORD *)a1 + 139) = 5;
            a1[70] = (uint64_t)&jpeg_natural_order5;
            v25 = 24;
            goto LABEL_78;
          }
          if (v24 == 35)
          {
            v17 = 6;
            *((_DWORD *)a1 + 139) = 6;
            a1[70] = (uint64_t)&jpeg_natural_order6;
            v25 = 35;
            goto LABEL_78;
          }
        }
      }
      else if (v24 > 7)
      {
        if (v24 == 8)
        {
          v17 = 3;
          *((_DWORD *)a1 + 139) = 3;
          a1[70] = (uint64_t)&jpeg_natural_order3;
          v25 = 8;
          goto LABEL_78;
        }
        if (v24 == 15)
        {
          v17 = 4;
          *((_DWORD *)a1 + 139) = 4;
          a1[70] = (uint64_t)&jpeg_natural_order4;
          v25 = 15;
          goto LABEL_78;
        }
      }
      else
      {
        if (!v24)
        {
          v17 = 1;
          *((_DWORD *)a1 + 139) = 1;
          a1[70] = (uint64_t)&_cg_jpeg_natural_order;
          *((_DWORD *)a1 + 142) = 0;
          goto LABEL_23;
        }
        if (v24 == 3)
        {
          v17 = 2;
          *((_DWORD *)a1 + 139) = 2;
          a1[70] = (uint64_t)&jpeg_natural_order2;
          v25 = 3;
LABEL_78:
          *((_DWORD *)a1 + 142) = v25;
          goto LABEL_23;
        }
      }
      v26 = *a1;
      *(_DWORD *)(v26 + 40) = 17;
      *(_DWORD *)(v26 + 48) = *((_DWORD *)a1 + 135);
      *(_DWORD *)(*a1 + 52) = *((_DWORD *)a1 + 136);
      *(_DWORD *)(*a1 + 56) = *((_DWORD *)a1 + 137);
      *(_DWORD *)(*a1 + 60) = *((_DWORD *)a1 + 138);
      (*(void (**)(uint64_t *))*a1)(a1);
      v17 = *((_DWORD *)a1 + 139);
      v11 = *((_DWORD *)a1 + 14);
LABEL_23:
      *((_DWORD *)a1 + 106) = v17;
      *((_DWORD *)a1 + 107) = v17;
      if (v11 >= 1)
      {
        v18 = 0;
        v19 = a1[38] + 40;
        do
        {
          v20 = *((_DWORD *)a1 + 139);
          *(_DWORD *)(v19 - 4) = v20;
          *(_DWORD *)v19 = v20;
          *(_DWORD *)(v19 - 12) = jdiv_round_up(*(int *)(v19 - 32) * (unint64_t)*((unsigned int *)a1 + 12), *((int *)a1 + 104) * (uint64_t)v20);
          *(_DWORD *)(v19 - 8) = jdiv_round_up(*(int *)(v19 - 28) * (unint64_t)*((unsigned int *)a1 + 13), *((int *)a1 + 139) * (uint64_t)*((int *)a1 + 105));
          *(_DWORD *)(v19 + 4) = jdiv_round_up(*(int *)(v19 - 32) * (unint64_t)*((unsigned int *)a1 + 12), *((int *)a1 + 104));
          *(_DWORD *)(v19 + 8) = jdiv_round_up(*(int *)(v19 - 28) * (unint64_t)*((unsigned int *)a1 + 13), *((int *)a1 + 105));
          *(_DWORD *)(v19 + 12) = 1;
          *(_QWORD *)(v19 + 40) = 0;
          ++v18;
          v19 += 96;
        }
        while (v18 < *((_DWORD *)a1 + 14));
        v17 = *((_DWORD *)a1 + 139);
      }
      *((_DWORD *)a1 + 108) = jdiv_round_up(*((unsigned int *)a1 + 13), *((int *)a1 + 105) * (uint64_t)v17);
      v21 = *((_DWORD *)a1 + 112);
      v22 = v21 < *((_DWORD *)a1 + 14) || *((_DWORD *)a1 + 79) != 0;
      *(_DWORD *)(a1[76] + 32) = v22;
      if (v21)
      {
LABEL_86:
        v1[10] = 0;
        return 1;
      }
LABEL_37:
      v1[10] = 2;
    }
    else
    {
      if (!v1[8])
      {
        v23 = *a1;
        *(_DWORD *)(v23 + 40) = 36;
        (*(void (**)(uint64_t *))v23)(a1);
      }
      if (*((_DWORD *)a1 + 112))
      {
        start_input_pass_0(a1);
        return 1;
      }
    }
  }
  if ((_DWORD)v5 != 2)
    return v5;
  v1[9] = 1;
  if (v1[10])
  {
    if (*(_DWORD *)(a1[77] + 28))
    {
      v27 = *a1;
      *(_DWORD *)(v27 + 40) = 62;
      (*(void (**)(uint64_t *))v27)(a1);
    }
  }
  else
  {
    v28 = *((_DWORD *)a1 + 43);
    if (*((_DWORD *)a1 + 45) > v28)
      *((_DWORD *)a1 + 45) = v28;
  }
  return 2;
}

uint64_t reset_input_controller(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 608);
  *(_QWORD *)v2 = consume_markers;
  *(_QWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 40) = 1;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  result = (**(uint64_t (***)(uint64_t))(a1 + 616))(a1);
  *(_QWORD *)(a1 + 192) = 0;
  return result;
}

uint64_t start_input_pass_0(uint64_t *a1)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  int v6;
  int v7;
  void (**v8)(_QWORD);
  uint64_t v9;
  _DWORD *v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void (**v23)(_QWORD);
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t result;

  v2 = *((_DWORD *)a1 + 112);
  if (v2 == 1)
  {
    v3 = a1[57];
    v4 = *(_DWORD *)(v3 + 32);
    *((_DWORD *)a1 + 122) = *(_DWORD *)(v3 + 28);
    *((_DWORD *)a1 + 123) = v4;
    *(_QWORD *)(v3 + 56) = 0x100000001;
    LODWORD(v5) = 1;
    v6 = *(_DWORD *)(v3 + 36);
    *(_DWORD *)(v3 + 64) = 1;
    *(_DWORD *)(v3 + 68) = v6;
    v7 = v4 % *(_DWORD *)(v3 + 12);
    if (!v7)
      v7 = *(_DWORD *)(v3 + 12);
    *(_DWORD *)(v3 + 72) = 1;
    *(_DWORD *)(v3 + 76) = v7;
    a1[62] = 1;
LABEL_20:
    v20 = 0;
    do
    {
      v21 = a1[v20 + 57];
      if (!*(_QWORD *)(v21 + 80))
      {
        v22 = *(unsigned int *)(v21 + 16);
        if (v22 > 3 || !a1[v22 + 25])
        {
          v23 = (void (**)(_QWORD))*a1;
          *((_DWORD *)v23 + 10) = 54;
          *((_DWORD *)v23 + 12) = v22;
          (*(void (**)(uint64_t *))*a1)(a1);
        }
        v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 132);
        v5 = a1[(int)v22 + 25];
        *(_OWORD *)v24 = *(_OWORD *)v5;
        v25 = *(_OWORD *)(v5 + 16);
        v26 = *(_OWORD *)(v5 + 32);
        v27 = *(_OWORD *)(v5 + 64);
        *(_OWORD *)(v24 + 48) = *(_OWORD *)(v5 + 48);
        *(_OWORD *)(v24 + 64) = v27;
        *(_OWORD *)(v24 + 16) = v25;
        *(_OWORD *)(v24 + 32) = v26;
        v28 = *(_OWORD *)(v5 + 80);
        v29 = *(_OWORD *)(v5 + 96);
        v30 = *(_OWORD *)(v5 + 112);
        *(_DWORD *)(v24 + 128) = *(_DWORD *)(v5 + 128);
        *(_OWORD *)(v24 + 96) = v29;
        *(_OWORD *)(v24 + 112) = v30;
        *(_OWORD *)(v24 + 80) = v28;
        *(_QWORD *)(v21 + 80) = v24;
        LODWORD(v5) = *((_DWORD *)a1 + 112);
      }
      ++v20;
    }
    while (v20 < (int)v5);
    goto LABEL_27;
  }
  if ((v2 - 5) <= 0xFFFFFFFB)
  {
    v8 = (void (**)(_QWORD))*a1;
    *((_DWORD *)v8 + 10) = 27;
    *((_DWORD *)v8 + 12) = v2;
    *(_DWORD *)(*a1 + 52) = 4;
    (*(void (**)(uint64_t *))*a1)(a1);
  }
  *((_DWORD *)a1 + 122) = jdiv_round_up(*((unsigned int *)a1 + 12), *((int *)a1 + 139) * (uint64_t)*((int *)a1 + 104));
  *((_DWORD *)a1 + 123) = jdiv_round_up(*((unsigned int *)a1 + 13), *((int *)a1 + 139) * (uint64_t)*((int *)a1 + 105));
  *((_DWORD *)a1 + 124) = 0;
  if (*((int *)a1 + 112) >= 1)
  {
    v9 = 0;
    do
    {
      v10 = (_DWORD *)a1[v9 + 57];
      v11 = v10[2];
      v12 = v10[3];
      v13 = v12 * v11;
      v14 = v10[8];
      v15 = v10[9] * v11;
      v10[16] = v12 * v11;
      v10[17] = v15;
      v16 = v10[7] % v11;
      v10[14] = v11;
      v10[15] = v12;
      if (v16)
        v11 = v16;
      if (v14 % v12)
        v12 = v14 % v12;
      v10[18] = v11;
      v10[19] = v12;
      if (*((_DWORD *)a1 + 124) + v13 >= 11)
      {
        v17 = *a1;
        *(_DWORD *)(v17 + 40) = 14;
        (*(void (**)(uint64_t *))v17)(a1);
      }
      if (v13 >= 1)
      {
        v18 = v13 + 1;
        do
        {
          v19 = *((int *)a1 + 124);
          *((_DWORD *)a1 + 124) = v19 + 1;
          *((_DWORD *)a1 + v19 + 125) = v9;
          --v18;
        }
        while (v18 > 1);
      }
      ++v9;
      v5 = *((int *)a1 + 112);
    }
    while (v9 < v5);
    if ((int)v5 >= 1)
      goto LABEL_20;
  }
LABEL_27:
  (*(void (**)(uint64_t *))a1[78])(a1);
  result = (*(uint64_t (**)(uint64_t *))a1[74])(a1);
  *(_QWORD *)a1[76] = *(_QWORD *)(a1[74] + 8);
  return result;
}

uint64_t finish_input_pass(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 624) + 16))();
  **(_QWORD **)(a1 + 608) = consume_markers;
  return result;
}

uint64_t jx_fragment_list::init(jx_fragment_list *this, jp2_input_box *a2)
{
  unsigned int v5[2];
  unsigned int v6;
  unsigned __int16 v7[5];
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  unsigned __int16 v11;

  if (*((_DWORD *)a2 + 12) != 1718383476)
    jx_fragment_list::init();
  *((_QWORD *)this + 2) = 0;
  *((_DWORD *)this + 1) = 0;
  v11 = 0;
  if (!jp2_input_box::read(a2, &v11))
  {
    v10 = 0;
    v8 = 0u;
    v9 = 0u;
    kdu_error::kdu_error((kdu_error *)&v8, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v8 + 16))(&v8, "Error encountered reading fragment list (flst) box.  Unable to read the initial fragment count.");
    kdu_error::~kdu_error((kdu_error *)&v8);
  }
  for (*(_QWORD *)&v7[1] = this; v11; --v11)
  {
    v7[0] = 0;
    v6 = 0;
    *(_QWORD *)v5 = 0;
    if (!jp2_input_box::read(a2, &v6)
      || !jp2_input_box::read(a2, &v5[1])
      || !jp2_input_box::read(a2, v5)
      || !jp2_input_box::read(a2, v7))
    {
      v10 = 0;
      v8 = 0u;
      v9 = 0u;
      kdu_error::kdu_error((kdu_error *)&v8, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v8 + 16))(&v8, "Error encountered reading fragment list (flst) box.  Contents of box terminated prematurely.");
      kdu_error::~kdu_error((kdu_error *)&v8);
    }
    jpx_fragment_list::add_fragment((uint64_t *)&v7[1], v7[0], v5[1] | ((unint64_t)v6 << 32), v5[0]);
  }
  return (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
}

void sub_187F80A68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F80A74(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Exception *v13;

  _Unwind_Resume(v13);
}

uint64_t *jpx_fragment_list::add_fragment(uint64_t *this, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 *v14;
  unint64_t v15;
  __int128 v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;

  v7 = *this;
  v8 = *(_DWORD *)(*this + 4);
  if (v8 == *(_DWORD *)*this)
  {
    v9 = (uint64_t)this;
    v10 = 2 * v8 + 8;
    *(_DWORD *)v7 = v10;
    is_mul_ok(v10, 0x18uLL);
    v11 = operator new[]();
    v7 = *(_QWORD *)v9;
    this = *(uint64_t **)(*(_QWORD *)v9 + 8);
    if (this)
    {
      v12 = *(int *)(v7 + 4);
      if ((int)v12 >= 1)
      {
        v13 = 0;
        v14 = *(__int128 **)(*(_QWORD *)v9 + 8);
        v15 = v11;
        do
        {
          v16 = *v14;
          *(_QWORD *)(v15 + 16) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v15 = v16;
          v15 += 24;
          ++v13;
          v14 = (__int128 *)((char *)v14 + 24);
        }
        while (v13 < v12);
      }
      this = (uint64_t *)MEMORY[0x18D761C18]();
      v7 = *(_QWORD *)v9;
    }
    *(_QWORD *)(v7 + 8) = v11;
    v8 = *(_DWORD *)(v7 + 4);
  }
  else
  {
    v11 = *(_QWORD *)(v7 + 8);
  }
  v17 = (_QWORD *)(v11 + 24 * v8);
  if ((unint64_t)(v17 - 3) >= v11 && *((_DWORD *)v17 - 2) == a2 && (v18 = *(v17 - 2), v18 + *(v17 - 3) == a3))
  {
    *(v17 - 2) = v18 + a4;
  }
  else
  {
    *(_DWORD *)(v7 + 4) = v8 + 1;
    v19 = v11 + 24 * v8;
    *(_DWORD *)(v19 + 16) = a2;
    *v17 = a3;
    *(_QWORD *)(v19 + 8) = a4;
  }
  *(_QWORD *)(v7 + 16) += a4;
  return this;
}

void jpx_input_box::jpx_input_box(jpx_input_box *this)
{
  uint64_t v1;

  jp2_input_box::jp2_input_box(this);
  *(_QWORD *)v1 = &off_1E1BADE00;
  *(_QWORD *)(v1 + 184) = 0;
  *(_QWORD *)(v1 + 192) = 0;
  *(_DWORD *)(v1 + 240) = -1;
  *(_DWORD *)(v1 + 200) = -1;
  *(_QWORD *)(v1 + 272) = 0;
  *(_OWORD *)(v1 + 208) = 0u;
  *(_OWORD *)(v1 + 224) = 0u;
  *(_QWORD *)(v1 + 248) = 0;
  *(_QWORD *)(v1 + 256) = 0;
  *(_DWORD *)(v1 + 264) = 0;
}

uint64_t jpx_input_box::open_next(jpx_input_box *this)
{
  if (*((_QWORD *)this + 32))
    return 0;
  else
    return jp2_input_box::open_next(this);
}

uint64_t jpx_input_box::open_as(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  if (*(_BYTE *)(a1 + 126))
  {
    v9 = 0;
    v7 = 0u;
    v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  if (!a4)
  {
    v9 = 0;
    v7 = 0u;
    v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  *(_QWORD *)(a1 + 184) = a2;
  *(_QWORD *)(a1 + 256) = a4;
  if (!*(_QWORD *)(a4 + 32))
    *(_QWORD *)(a1 + 192) = a3;
  *(_OWORD *)(a1 + 8) = xmmword_18820CDD0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = a5;
  if (a2)
    v5 = *(_QWORD *)(a2 + 16);
  else
    v5 = 0;
  *(_QWORD *)(a1 + 56) = v5;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = v5;
  *(_QWORD *)(a1 + 96) = -1;
  *(_QWORD *)(a1 + 104) = -1;
  *(_QWORD *)(a1 + 112) = -1;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 124) = 0x10000;
  *(_DWORD *)(a1 + 128) = 3;
  *(_OWORD *)(a1 + 136) = xmmword_18820CDD0;
  *(_DWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 200) = -1;
  *(_DWORD *)(a1 + 240) = -1;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  return 1;
}

void sub_187F80D98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F80DA4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jpx_input_box::close(jpx_input_box *this)
{
  FILE *v2;
  uint64_t v3;

  v2 = (FILE *)*((_QWORD *)this + 29);
  if (v2)
  {
    fclose(v2);
    *((_QWORD *)this + 29) = 0;
  }
  v3 = *((_QWORD *)this + 34);
  if (v3)
  {
    MEMORY[0x18D761C18](v3, 0x1000C8077774924);
    *((_QWORD *)this + 34) = 0;
  }
  *((_DWORD *)this + 66) = 0;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 60) = -1;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 32) = 0;
  return jp2_input_box::close(this);
}

BOOL jpx_input_box::seek(jpx_input_box *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (!*((_QWORD *)this + 32))
    return jp2_input_box::seek(this, a2);
  if (*((_QWORD *)this + 10))
    jpx_input_box::seek();
  v2 = *((_QWORD *)this + 17);
  if (v2 != a2)
  {
    if (a2 < 0)
    {
      v3 = 0;
    }
    else
    {
      v3 = *((_QWORD *)this + 11);
      if (v3 >= a2)
        v3 = a2;
    }
    *((_QWORD *)this + 17) = v3;
    if ((*((_DWORD *)this + 50) & 0x80000000) != 0 || v3 < *((_QWORD *)this + 26) || v3 >= *((_QWORD *)this + 27))
    {
      *((_DWORD *)this + 50) = -1;
      *((_QWORD *)this + 27) = 0;
      *((_QWORD *)this + 28) = 0;
      *((_QWORD *)this + 26) = 0;
    }
    else
    {
      *((_QWORD *)this + 28) += v3 - v2;
    }
  }
  return 1;
}

size_t jpx_input_box::read(FILE **this, unsigned __int8 *a2, int64_t a3)
{
  int v3;
  unsigned __int8 *v4;
  uint64_t v6;
  _QWORD *v7;
  FILE *v8;
  FILE *v9;
  uint64_t p_high;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  FILE *v16;
  uint64_t v17;
  FILE *v18;
  FILE *v19;
  const char *url;
  FILE *v21;
  uint64_t v22;
  FILE *v23;
  FILE *v24;
  char *v25;
  FILE *v26;
  unsigned int v27;
  uint64_t v28;
  FILE *v29;
  FILE *v30;
  uint64_t v31;
  FILE *v32;
  unsigned __int8 *base;
  FILE *v34;
  FILE *v35;
  unsigned __int8 *v36;
  FILE *v37;
  BOOL v38;

  v3 = a3;
  v4 = a2;
  if (!this[32])
    return jp2_input_box::read((jp2_input_box *)this, a2, a3);
  if ((int)a3 >= 1)
  {
    v6 = 0;
    v7 = this + 24;
    v8 = this[17];
    while (1)
    {
      if (((_DWORD)this[25] & 0x80000000) != 0 || (uint64_t)v8 >= (uint64_t)this[27])
      {
        if (((unint64_t)v8 & 0x8000000000000000) != 0)
          goto LABEL_48;
        v9 = this[23];
        p_high = HIDWORD(v9->_p);
        if ((int)p_high < 1)
          goto LABEL_48;
        v11 = 0;
        v12 = *(_QWORD *)&v9->_r + 8;
        v13 = (uint64_t)v8;
        while (1)
        {
          v14 = v13 - *(_QWORD *)v12;
          if (v14 < 0)
            break;
          ++v11;
          v12 += 24;
          v13 = v14;
          if (p_high == v11)
            goto LABEL_48;
        }
        *((_DWORD *)this + 50) = v11;
        if ((v11 & 0x80000000) != 0 || (int)p_high <= (int)v11)
        {
LABEL_48:
          *((_DWORD *)this + 50) = -1;
          return v6;
        }
        v15 = *(_DWORD *)(v12 + 8);
        v16 = *(FILE **)(v12 - 8);
        this[28] = v16;
        v17 = *(_QWORD *)v12;
        this[28] = (FILE *)((char *)v16 + v13);
        v18 = (FILE *)((char *)v8 - v13);
        this[26] = v18;
        this[27] = (FILE *)((char *)v18 + v17);
        if (v15 != *((_DWORD *)this + 60))
        {
          v19 = this[29];
          if (v19)
          {
            fclose(v19);
            this[29] = 0;
            *((_DWORD *)this + 60) = -1;
          }
          if (v15)
          {
            if (!*v7)
              goto LABEL_48;
            url = jp2_data_references::get_url((jp2_data_references *)(this + 24), v15);
            if (!url)
              goto LABEL_48;
            if (*url)
            {
              v21 = jpx_input_box::url_fopen((jpx_input_box *)this, url);
              this[29] = v21;
              if (!v21)
                goto LABEL_48;
            }
          }
          this[31] = 0;
          *((_DWORD *)this + 60) = v15;
        }
      }
      v22 = (uint64_t)this[28];
      v23 = this[29];
      if ((FILE *)v22 != this[31])
      {
        if (v23)
        {
          fseek(this[29], v22, 0);
          v22 = (uint64_t)this[28];
          v23 = this[29];
        }
        this[31] = (FILE *)v22;
      }
      v24 = this[17];
      v25 = (char *)v24 + v3;
      v26 = this[27];
      v27 = (_DWORD)v26 - (_DWORD)v24;
      if ((uint64_t)v25 <= (uint64_t)v26)
        v28 = v3;
      else
        v28 = v27;
      if (v23)
      {
        LODWORD(v28) = fread(v4, 1uLL, (int)v28, v23);
        if (!(_DWORD)v28)
          return v6;
      }
      else
      {
        v29 = this[32];
        if (*(_QWORD *)&v29->_bf._size)
          return v6;
        (*((void (**)(FILE *))v29->_p + 2))(v29);
        v30 = this[32];
        v31 = (uint64_t)this[17];
        if (*(_QWORD *)&v30->_lbfsize != v31)
        {
          v32 = *(FILE **)&v30->_flags;
          if (v32)
          {
            fseek(v32, v31, 0);
          }
          else
          {
            base = v30->_bf._base;
            if (base)
              (*(void (**)(unsigned __int8 *))(*(_QWORD *)base + 40))(base);
          }
        }
        v34 = this[32];
        v35 = *(FILE **)&v34->_flags;
        if (v35)
        {
          LODWORD(v28) = fread(v4, 1uLL, (int)v28, v35);
        }
        else
        {
          v36 = v34->_bf._base;
          if (v36)
            LODWORD(v28) = (*(uint64_t (**)(unsigned __int8 *, unsigned __int8 *, uint64_t))(*(_QWORD *)v36 + 32))(v36, v4, v28);
        }
        v37 = this[32];
        *(_QWORD *)&v37->_lbfsize = (char *)this[17] + (int)v28;
        (*((void (**)(FILE *))v37->_p + 3))(v37);
        if (!(_DWORD)v28)
          return v6;
      }
      v6 = (v28 + v6);
      v4 += (int)v28;
      v8 = (FILE *)((char *)this[17] + (int)v28);
      this[17] = v8;
      this[28] = (FILE *)((char *)this[28] + (int)v28);
      this[31] = (FILE *)((char *)this[31] + (int)v28);
      v38 = __OFSUB__(v3, (_DWORD)v28);
      v3 -= v28;
      if ((v3 < 0) ^ v38 | (v3 == 0))
        return v6;
    }
  }
  return 0;
}

FILE *jpx_input_box::url_fopen(jpx_input_box *this, const char *__s)
{
  const char *v2;
  int v4;
  int v5;
  const char *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  char *v11;
  const char *v12;
  char *v13;
  char *v14;
  int v15;

  v2 = __s;
  v4 = *(unsigned __int8 *)__s;
  if (!*__s || v4 != 47 && v4 != 92 && (__s[1] != 58 || (v5 = *((unsigned __int8 *)__s + 2), v5 != 47) && v5 != 92))
  {
    v6 = *(const char **)(*((_QWORD *)this + 32) + 8);
    if (v6)
    {
      v7 = strlen(__s);
      v8 = strlen(v6) + v7 + 2;
      v9 = *((_DWORD *)this + 66);
      if (v8 <= v9)
      {
        v11 = (char *)*((_QWORD *)this + 34);
      }
      else
      {
        *((_DWORD *)this + 66) = v8 + v9;
        v10 = *((_QWORD *)this + 34);
        if (v10)
          MEMORY[0x18D761C18](v10, 0x1000C8077774924);
        v11 = (char *)operator new[]();
        *((_QWORD *)this + 34) = v11;
      }
      strcpy(v11, v6);
      v12 = (const char *)*((_QWORD *)this + 34);
      v13 = (char *)&v12[strlen(v12)];
      do
      {
        v14 = v13;
        if (v13 <= v12)
          break;
        --v13;
        v15 = *(v14 - 1);
        if (v15 == 92)
          break;
      }
      while (v15 != 47);
      strcpy(v14, v2);
      v2 = (const char *)*((_QWORD *)this + 34);
    }
  }
  return fopen(v2, "rb");
}

uint64_t jx_compatibility::init_ftyp(jx_compatibility *this, jp2_input_box *a2)
{
  int v4;
  int v5;
  char v6;
  int v7;
  int v8;
  _OWORD v10[2];
  uint64_t v11;
  unsigned int v12;
  unsigned int v13[2];

  if (*((_DWORD *)a2 + 12) != 1718909296)
    jx_compatibility::init_ftyp();
  *(_QWORD *)v13 = 0;
  v12 = 0;
  jp2_input_box::read(a2, &v13[1]);
  jp2_input_box::read(a2, v13);
  LOBYTE(v4) = 0;
  LOBYTE(v5) = 0;
  v6 = 0;
  if (jp2_input_box::read(a2, &v12))
  {
    v6 = 0;
    v5 = 0;
    v4 = 0;
    do
    {
      if (v12 == 1785755680)
        v7 = 1;
      else
        v7 = v4;
      if (v12 == 1785755746)
      {
        v7 = 1;
        v8 = 1;
      }
      else
      {
        v8 = v5;
      }
      if (v12 == 1785737760)
      {
        v6 = 1;
      }
      else
      {
        v4 = v7;
        v5 = v8;
      }
    }
    while (jp2_input_box::read(a2, &v12));
  }
  if (((*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2) & 1) == 0)
  {
    v11 = 0;
    memset(v10, 0, sizeof(v10));
    kdu_error::kdu_error((kdu_error *)v10, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v10[0] + 16))(v10, "JP2-family data source contains a malformed file type box.");
    kdu_error::~kdu_error((kdu_error *)v10);
  }
  if (((v6 | v4) & 1) != 0)
  {
    *(_BYTE *)this = v13[1] == 1785737760 || (v4 & 1) == 0;
    *((_BYTE *)this + 1) = v6 & 1;
    *((_BYTE *)this + 2) = v5 & 1;
    *((_BYTE *)this + 3) = 0;
  }
  return (v6 | v4) & 1;
}

void sub_187F81468(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F81474()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jx_compatibility::init_rreq(jx_compatibility *this, jp2_input_box *a2)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t result;
  int *v33;
  unsigned __int16 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  unsigned __int16 v38;
  __int16 v39;

  if (*((_DWORD *)a2 + 12) != 1920099697)
    jx_compatibility::init_rreq();
  v39 = 0;
  (*(void (**)(jp2_input_box *, __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v39, 1);
  if ((_BYTE)v39)
  {
    v4 = 0;
    v5 = 0;
    v6 = 24;
    do
    {
      if (v6 >= 0)
        v7 = v6;
      else
        v7 = 24;
      v4 += v6 >> 31;
      (*(void (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v39 + 1, 1);
      *((_DWORD *)this + v4 + 10) |= HIBYTE(v39) << v7;
      if (v5 > 0x1E)
        break;
      ++v5;
      v6 = v7 - 8;
    }
    while (v5 < v39);
    if ((_BYTE)v39)
    {
      v8 = 0;
      v9 = 0;
      v10 = 24;
      do
      {
        if (v10 >= 0)
          v11 = v10;
        else
          v11 = 24;
        v8 += v10 >> 31;
        (*(void (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v39 + 1, 1);
        *((_DWORD *)this + v8 + 18) |= HIBYTE(v39) << v11;
        if (v9 > 0x1E)
          break;
        ++v9;
        v10 = v11 - 8;
      }
      while (v9 < v39);
    }
  }
  v38 = 0;
  if (!jp2_input_box::read(a2, &v38))
  {
    v37 = 0;
    v35 = 0u;
    v36 = 0u;
    kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Malformed reader requirements (rreq) box found in JPX data source.  Box terminated unexpectedly.");
    kdu_error::~kdu_error((kdu_error *)&v35);
  }
  *((_BYTE *)this + 3) = 1;
  v12 = v38;
  *((_DWORD *)this + 3) = v38;
  *((_DWORD *)this + 4) = v12;
  v13 = (void *)operator new[]();
  v14 = v13;
  if (v12)
    bzero(v13, 100 * ((100 * (unint64_t)v12 - 100) / 0x64) + 100);
  *((_QWORD *)this + 3) = v14;
  if (*((int *)this + 4) >= 1)
  {
    v15 = 0;
    do
    {
      v16 = *((_QWORD *)this + 3);
      jp2_input_box::read(a2, (unsigned __int16 *)(v16 + 100 * v15));
      if ((_BYTE)v39)
      {
        v17 = 0;
        v18 = 0;
        v19 = 24;
        do
        {
          if (v19 >= 0)
            v20 = v19;
          else
            v20 = 24;
          v17 += v19 >> 31;
          (*(void (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v39 + 1, 1);
          v21 = v16 + 100 * v15 + 4 * v17;
          *(_DWORD *)(v21 + 68) |= HIBYTE(v39) << v20;
          if (v18 > 0x1E)
            break;
          ++v18;
          v19 = v20 - 8;
        }
        while (v18 < v39);
      }
      *(_BYTE *)(v16 + 100 * v15 + 2) = *(unsigned __int16 *)(v16 + 100 * v15) != 16;
      ++v15;
    }
    while (v15 < *((int *)this + 4));
  }
  v34 = 0;
  if (!jp2_input_box::read(a2, &v34))
  {
    v37 = 0;
    v35 = 0u;
    v36 = 0u;
    kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Malformed reader requirements (rreq) box found in JPX data source.  Box terminated unexpectedly.");
    kdu_error::~kdu_error((kdu_error *)&v35);
  }
  v22 = v34;
  *((_DWORD *)this + 8) = v34;
  *((_DWORD *)this + 9) = v22;
  v23 = (void *)operator new[]();
  v24 = v23;
  if (v22)
    bzero(v23, 116 * ((116 * (unint64_t)v22 - 116) / 0x74) + 116);
  *((_QWORD *)this + 13) = v24;
  if (*((int *)this + 9) >= 1)
  {
    v25 = 0;
    v33 = (int *)this;
    do
    {
      v26 = *((_QWORD *)this + 13);
      if ((*(unsigned int (**)(jp2_input_box *, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v26 + 116 * v25, 16) != 16)
      {
        v37 = 0;
        v35 = 0u;
        v36 = 0u;
        kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Malformed reader requirements (rreq) box found in JPX data source. Box terminated unexpectedly.");
        kdu_error::~kdu_error((kdu_error *)&v35);
      }
      if ((_BYTE)v39)
      {
        v27 = 0;
        v28 = 0;
        v29 = 24;
        do
        {
          if (v29 >= 0)
            v30 = v29;
          else
            v30 = 24;
          if ((*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v39 + 1, 1) != 1)
          {
            v37 = 0;
            v35 = 0u;
            v36 = 0u;
            kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
            (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Malformed reader requirements (rreq) box found in JPX data source. Box terminated unexpectedly.");
            kdu_error::~kdu_error((kdu_error *)&v35);
          }
          v27 += v29 >> 31;
          v31 = v26 + 116 * v25 + 4 * v27;
          *(_DWORD *)(v31 + 84) |= HIBYTE(v39) << v30;
          if (v28 > 0x1E)
            break;
          ++v28;
          v29 = v30 - 8;
        }
        while (v28 < v39);
      }
      *(_BYTE *)(v26 + 116 * v25++ + 16) = 0;
      this = (jx_compatibility *)v33;
    }
    while (v25 < v33[9]);
  }
  result = (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
  if ((result & 1) == 0)
  {
    v37 = 0;
    v35 = 0u;
    v36 = 0u;
    kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Malformed reader requirements (rreq) box found in JPX data source.  Box appears to be too long.");
    kdu_error::~kdu_error((kdu_error *)&v35);
  }
  return result;
}

void sub_187F819AC(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F819B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

double jx_composition::add_frame(jx_composition *this)
{
  uint64_t v2;
  uint64_t v3;
  double result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *((_QWORD *)this + 60);
  if (v2)
  {
    if (*(_BYTE *)(v2 + 16))
      *((_QWORD *)this + 61) = v2;
    v3 = operator new();
    *(_QWORD *)v3 = 0;
    *(_QWORD *)(v3 + 8) = 0;
    *(_BYTE *)(v3 + 16) = 0;
    result = 0.0;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    v5 = *((_QWORD *)this + 60);
    v6 = *((_QWORD *)this + 61);
    *(_QWORD *)(v5 + 48) = v3;
    *(_QWORD *)(v3 + 56) = v5;
    *((_QWORD *)this + 60) = v3;
    *(_QWORD *)(v3 + 40) = v6;
    *((_DWORD *)this + 125) = *((_DWORD *)this + 124);
  }
  else
  {
    v7 = operator new();
    *(_QWORD *)v7 = 0;
    *(_QWORD *)(v7 + 8) = 0;
    *(_BYTE *)(v7 + 16) = 0;
    result = 0.0;
    *(_OWORD *)(v7 + 24) = 0u;
    *(_OWORD *)(v7 + 40) = 0u;
    *(_QWORD *)(v7 + 56) = 0;
    *((_QWORD *)this + 59) = v7;
    *((_QWORD *)this + 60) = v7;
  }
  return result;
}

void jx_composition::donate_composition_box(jx_composition *this, jp2_input_box *a2, jx_source *a3)
{
  _OWORD v5[2];
  uint64_t v6;

  if (*((_BYTE *)this + 214))
  {
    v6 = 0;
    memset(v5, 0, sizeof(v5));
    kdu_warning::kdu_warning((kdu_warning *)v5, "Warning in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "JPX data source appears to contain multiple composition boxes!! This is illegal.  All but first will be ignored.");
    kdu_warning::~kdu_warning((kdu_warning *)v5);
  }
  else
  {
    jp2_input_box::transplant((jx_composition *)((char *)this + 88), a2);
    *((_DWORD *)this + 114) = 0;
    jx_composition::finish(this, a3);
  }
}

void sub_187F81B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_warning::~kdu_warning((kdu_warning *)&a9);
  _Unwind_Resume(a1);
}

BOOL jx_composition::finish(jx_composition *this, jx_source *a2)
{
  uint64_t v2;
  jp2_input_box *v5;
  int v6;
  int v7;
  unsigned int v8;
  BOOL v9;
  BOOL v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t i;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  BOOL v38;
  uint64_t v40;
  unsigned __int16 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  unsigned int v45[2];

  if (!*(_BYTE *)this)
  {
    do
    {
      if (*((_BYTE *)this + 214))
        goto LABEL_7;
      if (*((_BYTE *)a2 + 216))
        return *((_BYTE *)a2 + 216) != 0;
    }
    while ((jx_source::parse_next_top_level_box(a2, 0) & 1) != 0);
    if (!*((_BYTE *)this + 214))
      return *((_BYTE *)a2 + 216) != 0;
LABEL_7:
    if (*((_DWORD *)this + 34) != 1668246896)
      jx_composition::finish();
    v5 = (jx_composition *)((char *)this + 88);
    if (!jp2_input_box::is_complete((jx_composition *)((char *)this + 88)))
      return 0;
    while (1)
    {
      while (1)
      {
        if (!*((_BYTE *)this + 398) && !jp2_input_box::open((jx_composition *)((char *)this + 272), v5))
        {
          jp2_input_box::close(v5);
          v2 = 1;
          *(_BYTE *)this = 1;
          jx_composition::assign_layer_indices((uint64_t)this);
          jx_composition::remove_invisible_instructions((uint64_t)this);
          return v2;
        }
        v6 = *((_DWORD *)this + 80);
        if (v6 == 1768846196)
          break;
        if (v6 != 1668247668)
          goto LABEL_83;
        if (!jp2_input_box::is_complete((jx_composition *)((char *)this + 272)))
          return 0;
        *(_QWORD *)v45 = 0;
        LOBYTE(v41) = 0;
        if (!jp2_input_box::read((jx_composition *)((char *)this + 272), &v45[1])
          || !jp2_input_box::read((jx_composition *)((char *)this + 272), v45)
          || ((v7 = (*(uint64_t (**)(char *, unsigned __int16 *, uint64_t))(*((_QWORD *)this + 34) + 32))((char *)this + 272, &v41, 1), v8 = v45[1], v7 == 1)? (v9 = v45[1] == 0): (v9 = 1), !v9 ? (v10 = v45[0] == 0) : (v10 = 1), v10))
        {
          v44 = 0;
          v42 = 0u;
          v43 = 0u;
          kdu_error::kdu_error((kdu_error *)&v42, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v42 + 16))(&v42, "Malformed Composition Options (copt) box found in JPX data source.  Insufficient or illegal field values encountered.  The height and width parameters must also be non-zero.");
          kdu_error::~kdu_error((kdu_error *)&v42);
        }
        *((_DWORD *)this + 117) = v45[0];
        *((_DWORD *)this + 116) = v8;
        if (v41 == 255)
          v11 = 0;
        else
          v11 = v41 + 1;
        *((_DWORD *)this + 115) = v11;
LABEL_83:
        jp2_input_box::close((jx_composition *)((char *)this + 272));
      }
      if (!jp2_input_box::is_complete((jx_composition *)((char *)this + 272)))
        return 0;
      LOWORD(v45[0]) = 0;
      v41 = 0;
      v45[1] = 0;
      if (!jp2_input_box::read((jx_composition *)((char *)this + 272), (unsigned __int16 *)v45)
        || !jp2_input_box::read((jx_composition *)((char *)this + 272), &v41)
        || !jp2_input_box::read((jx_composition *)((char *)this + 272), &v45[1]))
      {
        v44 = 0;
        v42 = 0u;
        v43 = 0u;
        kdu_error::kdu_error((kdu_error *)&v42, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v42 + 16))(&v42, "Malformed Instruction Set (inst) box found in JPX data source.  Insufficient fields encountered.");
        kdu_error::~kdu_error((kdu_error *)&v42);
      }
      v12 = LOWORD(v45[0]);
      if ((v45[0] & 0x27) != 0)
        break;
      jp2_input_box::close((jx_composition *)((char *)this + 272));
      ++*((_DWORD *)this + 114);
    }
    v40 = *((_QWORD *)this + 51) - (*((_QWORD *)this + 44) + *((int *)this + 112));
    v13 = v41;
    while (1)
    {
      v14 = *((_QWORD *)this + 60);
      if (v14)
        v15 = *(_QWORD *)(v14 + 32);
      else
        v15 = 0;
      if (jx_composition::parse_instruction(this, v12 & 1, (v12 >> 1) & 1, (v12 >> 2) & 1, (v12 >> 5) & 1, v45[1]))
      {
        v16 = 0;
        do
        {
          v17 = *(_QWORD *)(*((_QWORD *)this + 60) + 32);
          v18 = v16 + 1;
          *(_DWORD *)(v17 + 16) = *((_DWORD *)this + 114);
          *(_DWORD *)(v17 + 20) = v16;
          v19 = jx_composition::parse_instruction(this, v12 & 1, (v12 >> 1) & 1, (v12 >> 2) & 1, (v12 >> 5) & 1, v45[1]);
          v16 = v18;
        }
        while (v19);
      }
      if (!*((_BYTE *)this + 397) && *((_QWORD *)this + 45) - *((_QWORD *)this + 51) + *((int *)this + 112) >= 1)
      {
        v44 = 0;
        v42 = 0u;
        v43 = 0u;
        kdu_error::kdu_error((kdu_error *)&v42, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v42 + 16))(&v42, "Malformed Instruction Set (inst) box encountered in JPX data source.  Box appears to be too long.");
        kdu_error::~kdu_error((kdu_error *)&v42);
      }
      jp2_input_box::seek((jx_composition *)((char *)this + 272), v40);
      v20 = v13 - 1;
      if (v13 <= 1)
        goto LABEL_80;
      v21 = *((_QWORD *)this + 60);
      if (v21 == v14 || !*(_DWORD *)v21)
        goto LABEL_80;
      if (v14)
      {
        if (v21 != *(_QWORD *)(v14 + 48) || *(_QWORD *)(v14 + 32) != v15)
          goto LABEL_80;
      }
      else if (v21 != *((_QWORD *)this + 59))
      {
        goto LABEL_80;
      }
      v22 = *((_DWORD *)this + 125);
      v23 = *(_DWORD *)(v21 + 12);
      if (v22 < v23)
      {
        v24 = 0x7FFFFFFF;
LABEL_56:
        v26 = *(_QWORD *)(v21 + 24);
        if (v26)
        {
          v27 = 0;
          v28 = *(_DWORD *)(v21 + 12);
          do
          {
            v29 = *(_DWORD *)(v26 + 8);
            if (v29 == v23)
            {
              ++v27;
            }
            else if (v29)
            {
              goto LABEL_80;
            }
            --v28;
            v26 = *(_QWORD *)(v26 + 56);
          }
          while (v26);
          if (v28)
LABEL_89:
            jx_composition::finish();
        }
        else
        {
          v27 = 0;
          if (v23)
            goto LABEL_89;
        }
        if ((v24 & 0x80000000) != 0)
          jx_composition::finish();
        if (v24 >= 2)
        {
          jx_composition::add_frame(this);
          v30 = *((_QWORD *)this + 60);
          *((_DWORD *)this + 124) -= *(_DWORD *)(v30 + 12);
          *(_DWORD *)(v30 + 8) = *(_DWORD *)(v21 + 12) - v27;
          *(_BYTE *)(v30 + 16) = *(_BYTE *)(v21 + 16);
          *(_DWORD *)v30 = *(_DWORD *)v21;
          for (i = *(_QWORD *)(v21 + 24); i; i = *(_QWORD *)(i + 56))
          {
            v32 = jx_frame::add_instruction(*((jx_frame **)this + 60), *(_BYTE *)(i + 12));
            *(_DWORD *)v32 = -1;
            *(_OWORD *)(v32 + 24) = *(_OWORD *)(i + 24);
            *(_OWORD *)(v32 + 40) = *(_OWORD *)(i + 40);
            v33 = *(_DWORD *)(i + 8);
            *(_DWORD *)(v32 + 8) = v33;
            if (!v33)
              *(_DWORD *)(v32 + 4) = *(_DWORD *)(*((_QWORD *)this + 60) + 8);
          }
          v34 = v24 - 1;
          if ((__int16)v41 == -1)
          {
            v35 = *((_QWORD *)this + 60);
            *(_DWORD *)(v35 + 4) = v34;
          }
          else
          {
            v35 = *((_QWORD *)this + 60);
            if (v13 <= (int)v24)
            {
              *(_DWORD *)(v35 + 4) = v20;
              v34 = v13 - 1;
              v20 = 0;
            }
            else
            {
              *(_DWORD *)(v35 + 4) = v34;
              v20 -= v34;
            }
          }
          v36 = *((_DWORD *)this + 124) - *(_DWORD *)(v35 + 12) * v34;
          if (v34 >= 0)
            v37 = v36;
          else
            v37 = 0;
          *((_DWORD *)this + 124) = v37;
          v13 = v20;
        }
        goto LABEL_80;
      }
      v25 = v22 / v23;
      v24 = v25 - 1;
      if (v25 != 1)
        goto LABEL_56;
LABEL_80:
      v38 = __OFSUB__(v13--, 1);
      if (v13 < 0 != v38)
      {
        ++*((_DWORD *)this + 114);
        v5 = (jx_composition *)((char *)this + 88);
        goto LABEL_83;
      }
    }
  }
  return 1;
}

void sub_187F820CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F820D8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Exception *v13;

  _Unwind_Resume(v13);
}

uint64_t jx_source::parse_next_top_level_box(jx_source *this, int a2)
{
  uint64_t result;
  uint64_t v4;
  int v5;
  jx_codestream_source *v6;
  uint64_t v7;
  unint64_t v8;
  _DWORD *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  BOOL v15;
  jx_layer_source *v16;
  jx_layer_source **v17;
  int v18;
  int v19;
  jx_codestream_source *v20;
  uint64_t v21;
  uint64_t v22;
  jx_layer_source *v23;
  jx_layer_source **v24;
  unint64_t v25;
  _DWORD *v26;
  int v27;
  jx_layer_source *v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  if (*((_BYTE *)this + 216) || *((_BYTE *)this + 17))
  {
    if (a2)
      jx_source::parse_next_top_level_box();
    return 0;
  }
  if ((a2 & 1) == 0)
  {
    if (*((_BYTE *)this + 158))
      jx_source::parse_next_top_level_box();
    if ((jp2_input_box::open_next((jx_source *)((char *)this + 32)) & 1) == 0)
    {
      v4 = *(_QWORD *)(*(_QWORD *)this + 32);
      if (v4)
      {
        LOBYTE(v29) = 0;
        (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, __int128 *))(*(_QWORD *)v4 + 80))(v4, 4, 0, 0, &v29);
        if (!(_BYTE)v29)
          return 0;
      }
      if ((jp2_input_box::open_next((jx_source *)((char *)this + 32)) & 1) == 0)
      {
        *((_BYTE *)this + 216) = 1;
        if (*((_DWORD *)this + 6) || *((int *)this + 5) < 1)
          return 0;
        v15 = *((_QWORD *)this + 142) == 0;
        do
        {
          v16 = (jx_layer_source *)operator new();
          jx_layer_source::jx_layer_source(v16, this, *((_DWORD *)this + 6));
          if (v15)
            v17 = (jx_layer_source **)((char *)this + 1112);
          else
            v17 = (jx_layer_source **)(*((_QWORD *)this + 142) + 800);
          v15 = 0;
          result = 0;
          *v17 = v16;
          *((_QWORD *)this + 142) = v16;
          v18 = *((_DWORD *)this + 5);
          v19 = *((_DWORD *)this + 6) + 1;
          *((_DWORD *)this + 6) = v19;
        }
        while (v19 < v18);
        return result;
      }
    }
  }
  *((_BYTE *)this + 17) = 1;
  v5 = *((_DWORD *)this + 20);
  if (v5 > 1785737826)
  {
    if (v5 <= 1785750375)
    {
      if (v5 == 1785737827)
        goto LABEL_25;
      if (v5 != 1785737832)
        goto LABEL_32;
      if (*((_BYTE *)this + 408))
      {
        v31 = 0;
        v29 = 0u;
        v30 = 0u;
        kdu_error::kdu_error((kdu_error *)&v29, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "JP2-family data source contains more than one top-level JP2 header (jp2h) box.");
        kdu_error::~kdu_error((kdu_error *)&v29);
      }
      *((_BYTE *)this + 408) = 1;
      jp2_input_box::transplant((jx_source *)((char *)this + 224), (jx_source *)((char *)this + 32));
      jx_source::finish_jp2_header_box(this);
      goto LABEL_77;
    }
    if (v5 != 1785750376)
    {
      if (v5 != 1785752680 || *((_BYTE *)this + 16))
        goto LABEL_32;
      v22 = *((_QWORD *)this + 142);
      v23 = (jx_layer_source *)operator new();
      jx_layer_source::jx_layer_source(v23, this, *((_DWORD *)this + 6));
      if (v22)
        v24 = (jx_layer_source **)(*((_QWORD *)this + 142) + 800);
      else
        v24 = (jx_layer_source **)((char *)this + 1112);
      *v24 = v23;
      *((_QWORD *)this + 142) = v23;
      ++*((_DWORD *)this + 6);
      jx_layer_source::donate_jplh_box(v23, (jx_source *)((char *)this + 32));
      if (*((_BYTE *)this + 158))
      {
        v31 = 0;
        v29 = 0u;
        v30 = 0u;
        kdu_error::kdu_error((kdu_error *)&v29, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "top-level JP2 header box is still open, parsing failed.");
        kdu_error::~kdu_error((kdu_error *)&v29);
      }
      goto LABEL_77;
    }
    v20 = (jx_codestream_source *)*((_QWORD *)this + 138);
    if (v20)
    {
      v21 = *((_QWORD *)this + 140);
      if (!v21 || (v20 = *(jx_codestream_source **)(v21 + 856)) != 0)
      {
        *((_QWORD *)this + 140) = v20;
        goto LABEL_72;
      }
      v20 = (jx_codestream_source *)operator new();
      jx_codestream_source::jx_codestream_source(v20, this, *(jp2_family_src **)this, *((_DWORD *)this + 5), *((_BYTE *)this + 16));
      *(_QWORD *)(*((_QWORD *)this + 140) + 856) = v20;
    }
    else
    {
      v20 = (jx_codestream_source *)operator new();
      jx_codestream_source::jx_codestream_source(v20, this, *(jp2_family_src **)this, *((_DWORD *)this + 5), *((_BYTE *)this + 16));
      *((_QWORD *)this + 138) = v20;
    }
    *((_QWORD *)this + 140) = v20;
    ++*((_DWORD *)this + 5);
LABEL_72:
    jx_codestream_source::donate_chdr_box(v20, (jx_source *)((char *)this + 32));
    if (*((_BYTE *)this + 158))
    {
      v31 = 0;
      v29 = 0u;
      v30 = 0u;
      kdu_error::kdu_error((kdu_error *)&v29, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "top-level JP2 header box is still open, parsing failed.");
      kdu_error::~kdu_error((kdu_error *)&v29);
    }
    goto LABEL_77;
  }
  if (v5 <= 1685348971)
  {
    if (v5 == 1634955107)
      goto LABEL_35;
    if (v5 == 1668246896)
    {
      jx_composition::donate_composition_box((jx_source *)((char *)this + 1336), (jx_source *)((char *)this + 32), this);
      if (*((_BYTE *)this + 158))
      {
        v31 = 0;
        v29 = 0u;
        v30 = 0u;
        kdu_error::kdu_error((kdu_error *)&v29, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "top-level JP2 header box is still open, parsing failed.");
        kdu_error::~kdu_error((kdu_error *)&v29);
      }
      goto LABEL_77;
    }
LABEL_32:
    v8 = *((unsigned int *)this + 569);
    if (!(_DWORD)v8)
      goto LABEL_35;
    if ((int)v8 >= 1)
    {
      v9 = (_DWORD *)*((_QWORD *)this + 285);
      if (*v9 == v5)
      {
LABEL_35:
        v10 = (uint64_t *)*((_QWORD *)this + 233);
        v11 = operator new();
        v12 = *v10;
        *(_OWORD *)(v11 + 8) = 0u;
        *(_OWORD *)(v11 + 24) = 0u;
        *(_OWORD *)(v11 + 40) = 0u;
        *(_OWORD *)(v11 + 56) = 0u;
        *(_OWORD *)(v11 + 72) = 0u;
        *(_OWORD *)(v11 + 104) = 0u;
        *(_OWORD *)(v11 + 88) = 0u;
        *(_QWORD *)v11 = v12;
        v13 = v10[9];
        *(_QWORD *)(v11 + 88) = v13;
        if (v13)
          v14 = (uint64_t *)(v13 + 80);
        else
          v14 = v10 + 8;
        *v14 = v11;
        v10[9] = v11;
        *(_QWORD *)(v11 + 56) = v10;
        ++*((_DWORD *)v10 + 12);
        jx_metanode::donate_input_box((jx_metanode *)v11, (jx_source *)((char *)this + 32));
        if (*((_BYTE *)this + 158))
        {
          v31 = 0;
          v29 = 0u;
          v30 = 0u;
          kdu_error::kdu_error((kdu_error *)&v29, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "top-level JP2 header box is still open, parsing failed.");
          kdu_error::~kdu_error((kdu_error *)&v29);
        }
        goto LABEL_77;
      }
      v25 = 0;
      v26 = v9 + 1;
      while (v8 - 1 != v25)
      {
        v27 = v26[v25++];
        if (v27 == v5)
        {
          if (v25 < v8)
            goto LABEL_35;
          break;
        }
      }
    }
    jp2_input_box::close((jx_source *)((char *)this + 32));
    goto LABEL_77;
  }
  if (v5 != 1685348972)
  {
    if (v5 != 1718903404)
      goto LABEL_32;
LABEL_25:
    v6 = (jx_codestream_source *)*((_QWORD *)this + 138);
    if (v6)
    {
      v7 = *((_QWORD *)this + 141);
      if (!v7 || (v6 = *(jx_codestream_source **)(v7 + 856)) != 0)
      {
        *((_QWORD *)this + 141) = v6;
        goto LABEL_68;
      }
      v6 = (jx_codestream_source *)operator new();
      jx_codestream_source::jx_codestream_source(v6, this, *(jp2_family_src **)this, *((_DWORD *)this + 5), *((_BYTE *)this + 16));
      *(_QWORD *)(*((_QWORD *)this + 141) + 856) = v6;
    }
    else
    {
      v6 = (jx_codestream_source *)operator new();
      jx_codestream_source::jx_codestream_source(v6, this, *(jp2_family_src **)this, *((_DWORD *)this + 5), *((_BYTE *)this + 16));
      *((_QWORD *)this + 138) = v6;
    }
    *((_QWORD *)this + 141) = v6;
    ++*((_DWORD *)this + 5);
LABEL_68:
    jx_codestream_source::donate_codestream_box(v6, (jx_source *)((char *)this + 32));
    if (*((_BYTE *)this + 158))
    {
      v31 = 0;
      v29 = 0u;
      v30 = 0u;
      kdu_error::kdu_error((kdu_error *)&v29, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "top-level JP2 header box is still open, parsing failed.");
      kdu_error::~kdu_error((kdu_error *)&v29);
    }
    goto LABEL_77;
  }
  if (*((_BYTE *)this + 672))
  {
    v31 = 0;
    v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)&v29, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "JP2-family data source appears to contain more than one data reference (dtbl) box.  At most one should be found in the file.");
    kdu_error::~kdu_error((kdu_error *)&v29);
  }
  *((_BYTE *)this + 672) = 1;
  jp2_input_box::transplant((jx_source *)((char *)this + 680), (jx_source *)((char *)this + 32));
  if (jp2_input_box::is_complete((jx_source *)((char *)this + 680)))
  {
    j2_data_references::init((jx_source *)((char *)this + 656), (jx_source *)((char *)this + 680));
    if (*((_BYTE *)this + 806))
      jx_source::parse_next_top_level_box();
  }
LABEL_77:
  *((_BYTE *)this + 17) = 0;
  if (!*((_BYTE *)this + 16) || *((_DWORD *)this + 6) || *((int *)this + 5) < 1)
    return 1;
  if (*((_QWORD *)this + 139))
    return 0;
  v28 = (jx_layer_source *)operator new();
  jx_layer_source::jx_layer_source(v28, this, 0);
  *((_QWORD *)this + 139) = v28;
  *((_QWORD *)this + 142) = v28;
  result = 1;
  *((_DWORD *)this + 6) = 1;
  return result;
}

void sub_187F828A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B0C40CB50D696);
  _Unwind_Resume(a1);
}

BOOL jx_composition::parse_instruction(jx_composition *this, int a2, int a3, int a4, unsigned int a5, int a6)
{
  unsigned int v7;
  _BOOL8 result;
  uint64_t v13;
  unsigned int v14;
  unint64_t v15;
  char v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  jx_frame *v20;
  char v21;
  uint64_t v22;
  signed int v23;
  signed int v24;
  uint64_t v25;
  unsigned int v26[2];
  unsigned int v27[2];
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  unsigned int v31[2];

  v7 = a5;
  if ((a2 & 1) == 0 && (a3 & 1) == 0 && (a4 & 1) == 0 && !a5)
    return 0;
  if (a2)
  {
    *(_QWORD *)v31 = 0;
    result = jp2_input_box::read((jx_composition *)((char *)this + 272), &v31[1]);
    if (!result)
      return result;
    if (!jp2_input_box::read((jx_composition *)((char *)this + 272), v31))
    {
      v30 = 0;
      v28 = 0u;
      v29 = 0u;
      kdu_error::kdu_error((kdu_error *)&v28, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Malformed Instruction Set (inst) box found in JPX data source.  Terminated unexpectedly.");
      kdu_error::~kdu_error((kdu_error *)&v28);
    }
    v14 = v31[0];
    v13 = v31[1];
    if (!a3)
      goto LABEL_12;
  }
  else
  {
    v14 = 0;
    v13 = 0;
    if (!a3)
    {
LABEL_12:
      v15 = *((_QWORD *)this + 58);
      goto LABEL_19;
    }
  }
  *(_QWORD *)v31 = 0;
  if (!jp2_input_box::read((jx_composition *)((char *)this + 272), &v31[1]) && !a2)
    return 0;
  if (!jp2_input_box::read((jx_composition *)((char *)this + 272), v31))
  {
    v30 = 0;
    v28 = 0u;
    v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Malformed Instruction Set (inst) box found in JPX data source.  Terminated unexpectedly.");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  v15 = v31[0] | ((unint64_t)v31[1] << 32);
LABEL_19:
  *(_QWORD *)v31 = 0;
  if (!a4)
    goto LABEL_29;
  if (!jp2_input_box::read((jx_composition *)((char *)this + 272), &v31[1]) && (a2 & 1) == 0 && !a3)
    return 0;
  if (!jp2_input_box::read((jx_composition *)((char *)this + 272), v31))
  {
    v30 = 0;
    v28 = 0u;
    v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Malformed Instruction Set (inst) box found in JPX data source.  Terminated unexpectedly.");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  if ((v31[1] & 0x80000000) != 0)
  {
    v31[1] &= ~0x80000000;
LABEL_29:
    v16 = 1;
    if (!v7)
      goto LABEL_27;
    goto LABEL_30;
  }
  v16 = 0;
  if (v7)
  {
LABEL_30:
    *(_QWORD *)v26 = 0;
    *(_QWORD *)v27 = 0;
    if (jp2_input_box::read((jx_composition *)((char *)this + 272), &v27[1]) || (a2 & 1) != 0 || (a3 & 1) != 0 || a4)
    {
      if (!jp2_input_box::read((jx_composition *)((char *)this + 272), v27)
        || !jp2_input_box::read((jx_composition *)((char *)this + 272), &v26[1])
        || !jp2_input_box::read((jx_composition *)((char *)this + 272), v26))
      {
        v30 = 0;
        v28 = 0u;
        v29 = 0u;
        kdu_error::kdu_error((kdu_error *)&v28, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Malformed Instruction Set (inst) box found in JPX data source.  Terminated unexpectedly.");
        kdu_error::~kdu_error((kdu_error *)&v28);
      }
      v7 = v27[0];
      v19 = v27[1];
      v17 = v26[0];
      v18 = v26[1];
      goto LABEL_39;
    }
    return 0;
  }
LABEL_27:
  v17 = 0;
  v18 = 0;
  v19 = 0;
LABEL_39:
  v20 = (jx_frame *)*((_QWORD *)this + 60);
  if (!v20 || *(_DWORD *)v20)
  {
    jx_composition::add_frame(this);
    v20 = (jx_frame *)*((_QWORD *)this + 60);
  }
  if (v31[1])
    v21 = 1;
  else
    v21 = v16;
  v22 = jx_frame::add_instruction(v20, v21);
  *(_DWORD *)(v22 + 24) = v7;
  *(_DWORD *)(v22 + 28) = v19;
  *(_DWORD *)(v22 + 32) = v17;
  *(_DWORD *)(v22 + 36) = v18;
  *(_QWORD *)(v22 + 40) = v14 | (unint64_t)(v13 << 32);
  *(_QWORD *)(v22 + 48) = v15;
  *(_DWORD *)v22 = -1;
  v23 = v31[0];
  *(_DWORD *)(v22 + 8) = v31[0];
  v24 = *((_DWORD *)this + 124);
  if (v23 < v24)
    v23 = v24 - 1;
  *((_DWORD *)this + 124) = v23;
  v25 = *((_QWORD *)this + 60);
  *(_DWORD *)v25 = v31[1] * a6;
  *(_BYTE *)(v25 + 16) = v16;
  return 1;
}

void sub_187F82C88(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F82C94(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t jx_frame::add_instruction(jx_frame *this, char a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;

  ++*((_DWORD *)this + 3);
  v4 = *((_QWORD *)this + 4);
  result = operator new();
  *(_DWORD *)(result + 8) = 0;
  *(_QWORD *)result = 0;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_QWORD *)(result + 16) = -1;
  *(_WORD *)(result + 12) = 0;
  if (v4)
  {
    v6 = *((_QWORD *)this + 4);
    *(_QWORD *)(result + 56) = 0;
    *(_QWORD *)(v6 + 56) = result;
    *(_QWORD *)(result + 64) = v6;
  }
  else
  {
    *(_QWORD *)(result + 56) = 0;
    *(_QWORD *)(result + 64) = 0;
    *((_QWORD *)this + 3) = result;
  }
  *((_QWORD *)this + 4) = result;
  *(_BYTE *)(result + 12) = a2;
  return result;
}

uint64_t jx_composition::assign_layer_indices(uint64_t this)
{
  uint64_t v1;
  int v2;
  uint64_t i;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v9;
  BOOL v10;
  _OWORD v11[2];
  uint64_t v12;

  v1 = *(_QWORD *)(this + 472);
  if (v1)
  {
    v2 = 0;
    do
    {
      for (i = *(_QWORD *)(v1 + 24); i; i = *(_QWORD *)(i + 56))
      {
        if ((*(_DWORD *)i & 0x80000000) != 0)
          *(_DWORD *)i = v2++;
        v4 = *(_DWORD *)(i + 8);
        if (v4 >= 1)
        {
          v5 = v1;
          v6 = i;
          do
          {
            v6 = *(_QWORD *)(v6 + 56);
            if (!v6)
            {
              v7 = *(_DWORD *)(v5 + 4);
              if (v7 >= 1 && v1 != v5)
              {
                v4 -= *(_DWORD *)(v5 + 12) * v7;
                if (v4 <= 0)
                {
                  v12 = 0;
                  memset(v11, 0, sizeof(v11));
                  kdu_error::kdu_error((kdu_error *)v11, "Error in Kakadu File Format Support:\n");
                  (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v11[0] + 16))(v11, "Illegal re-use count found in a compositing instruction within the JPX composition box.  The specified re-use counts found in the box lead to multiple conflicting definitions for the compositing layer which should be used by a particular instruction.");
                  kdu_error::~kdu_error((kdu_error *)v11);
                }
              }
              v5 = *(_QWORD *)(v5 + 48);
              if (!v5)
                goto LABEL_25;
              v6 = *(_QWORD *)(v5 + 24);
            }
            v9 = __OFSUB__(v4--, 1);
          }
          while (!((v4 < 0) ^ v9 | (v4 == 0)));
          if (v6)
            v10 = v4 == 0;
          else
            v10 = 0;
          if (v10)
            *(_DWORD *)v6 = *(_DWORD *)i;
        }
LABEL_25:
        ;
      }
      v1 = *(_QWORD *)(v1 + 48);
    }
    while (v1);
  }
  return this;
}

void sub_187F82E80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F82E8C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jx_composition::remove_invisible_instructions(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;

  v1 = *(_QWORD *)(this + 472);
  if (v1)
  {
    v2 = this;
    v3 = (_QWORD *)(this + 480);
    do
    {
      v4 = (_QWORD *)(v1 + 24);
      this = *(_QWORD *)(v1 + 24);
      v5 = *(_QWORD *)(v1 + 48);
      if (this)
      {
        do
        {
          v6 = *(_QWORD *)(this + 56);
          if (!*(_BYTE *)(this + 12))
          {
            --*(_DWORD *)(v1 + 12);
            v7 = *(_QWORD *)(this + 64);
            if (v7)
            {
              v8 = (uint64_t *)(v7 + 56);
            }
            else
            {
              v8 = (uint64_t *)(v1 + 24);
              if (*v4 != this)
                jx_composition::remove_invisible_instructions();
            }
            *v8 = v6;
            if (v6)
            {
              v9 = (_QWORD *)(v6 + 64);
            }
            else
            {
              v9 = (_QWORD *)(v1 + 32);
              if (*(_QWORD *)(v1 + 32) != this)
                jx_composition::remove_invisible_instructions();
            }
            *v9 = v7;
            MEMORY[0x18D761C30]();
          }
          this = v6;
        }
        while (v6);
        if (*v4)
          goto LABEL_22;
      }
      if (*(_DWORD *)(v1 + 12))
        jx_composition::remove_invisible_instructions();
      v10 = *(_QWORD *)(v1 + 56);
      if (v10)
      {
        *(_QWORD *)(v10 + 48) = v5;
        *(_DWORD *)v10 += *(_DWORD *)v1;
        if (!v5)
          goto LABEL_20;
      }
      else
      {
        if (*(_QWORD *)(v2 + 472) != v1)
          jx_composition::remove_invisible_instructions();
        *(_QWORD *)(v2 + 472) = v5;
        if (!v5)
        {
LABEL_20:
          v11 = v3;
          if (*v3 != v1)
            jx_composition::remove_invisible_instructions();
          goto LABEL_21;
        }
      }
      v11 = (_QWORD *)(v5 + 56);
LABEL_21:
      *v11 = v10;
      jx_frame::reset((jx_frame *)v1);
      this = MEMORY[0x18D761C30](v1, 0x1020C406ACA6742);
LABEL_22:
      v1 = v5;
    }
    while (v5);
  }
  return this;
}

BOOL jpx_source::count_compositing_layers(jpx_source *this, int *a2)
{
  uint64_t v4;
  _BOOL8 result;
  int v6;

  v4 = *((_QWORD *)this + 1);
  if (v4 && *(_BYTE *)(v4 + 15))
  {
    if (!*(_BYTE *)(v4 + 16))
    {
      while (1)
      {
        v4 = *((_QWORD *)this + 1);
        if (*(_BYTE *)(v4 + 216))
          break;
        if ((jx_source::parse_next_top_level_box((jx_source *)v4, 0) & 1) == 0)
        {
          v4 = *((_QWORD *)this + 1);
          break;
        }
      }
    }
    v6 = *(_DWORD *)(v4 + 24);
    *a2 = v6;
    if (v6 <= 0 && *(_BYTE *)(v4 + 16))
      *a2 = 1;
    return *(_BYTE *)(v4 + 216) || *(_BYTE *)(v4 + 16) != 0;
  }
  else
  {
    result = 0;
    *a2 = 0;
  }
  return result;
}

uint64_t jpx_source::access_layer(jpx_source *this, int a2, int a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v8;
  int v9;

  v3 = *((_QWORD *)this + 1);
  if (!v3)
    return 0;
  v4 = a2;
  v5 = 0;
  if ((a2 & 0x80000000) == 0)
  {
    if (*(_BYTE *)(v3 + 15))
    {
      if (a2 && *(_BYTE *)(v3 + 16))
        return 0;
      while (1)
      {
        v8 = *((_QWORD *)this + 1);
        v9 = *(_DWORD *)(v8 + 24);
        if (v9 > v4 || *(_BYTE *)(v8 + 216))
          break;
        if ((jx_source::parse_next_top_level_box((jx_source *)v8, 0) & 1) == 0)
        {
          v8 = *((_QWORD *)this + 1);
          v9 = *(_DWORD *)(v8 + 24);
          break;
        }
      }
      if (v9 <= v4)
        return 0;
      v5 = *(_QWORD *)(v8 + 1112);
      if (v4 >= 1)
      {
        do
        {
          v5 = *(_QWORD *)(v5 + 800);
          --v4;
        }
        while (v4);
      }
      if (!jx_layer_source::finish((jx_layer_source *)v5)
        || a3 && !*(_BYTE *)(v5 + 13) && !jx_layer_source::check_stream_headers((jx_layer_source *)v5))
      {
        return 0;
      }
    }
  }
  return v5;
}

uint64_t jpx_layer_source::access_channels(jpx_layer_source *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (!*(_QWORD *)this || !*(_BYTE *)(v1 + 12))
    jpx_layer_source::access_channels();
  return v1 + 608;
}

void jx_numlist::~jx_numlist(jx_numlist *this)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v4;
  BOOL v5;

  v2 = *((_QWORD *)this + 2);
  if (v2)
    v3 = v2 == (_QWORD)this + 8;
  else
    v3 = 1;
  if (!v3)
    MEMORY[0x18D761C18]();
  v4 = *((_QWORD *)this + 5);
  if (v4)
    v5 = v4 == (_QWORD)this + 32;
  else
    v5 = 1;
  if (!v5)
    MEMORY[0x18D761C18]();
}

unsigned int *jx_numlist::add_codestream(unsigned int *this, int a2)
{
  unsigned int *v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int *v12;
  _DWORD *v13;
  int v14;

  v3 = this;
  LODWORD(v4) = *this;
  if ((int)*this < 1)
  {
    v8 = 0;
    if ((_DWORD)v4)
    {
LABEL_9:
      v10 = this[1];
      if ((int)v4 >= v10)
      {
        this[1] = v10 + 8;
        v9 = operator new[]();
        LODWORD(v4) = *v3;
        this = (unsigned int *)*((_QWORD *)v3 + 2);
        if ((int)*v3 < 1)
        {
          v8 = 0;
        }
        else
        {
          v11 = *v3;
          v12 = (int *)*((_QWORD *)v3 + 2);
          v13 = (_DWORD *)v9;
          do
          {
            v14 = *v12++;
            *v13++ = v14;
            --v11;
          }
          while (v11);
          v8 = v4;
        }
        if (this != v3 + 2 && this)
        {
          this = (unsigned int *)MEMORY[0x18D761C18](this, 0x1000C8052888210);
          LODWORD(v4) = *v3;
        }
        *((_QWORD *)v3 + 2) = v9;
      }
      else
      {
        v9 = *((_QWORD *)this + 2);
      }
    }
    else
    {
LABEL_6:
      v4 = *((_QWORD *)this + 2);
      if (v4)
        jx_numlist::add_codestream();
      this[1] = 1;
      v9 = (uint64_t)(this + 2);
      *((_QWORD *)this + 2) = this + 2;
    }
    *v3 = v4 + 1;
    *(_DWORD *)(v9 + 4 * v8) = a2;
  }
  else
  {
    v5 = (int *)*((_QWORD *)this + 2);
    v6 = *this;
    while (1)
    {
      v7 = *v5++;
      if (v7 == a2)
        break;
      if (!--v6)
      {
        v8 = *this;
        if ((_DWORD)v4)
          goto LABEL_9;
        goto LABEL_6;
      }
    }
  }
  return this;
}

uint64_t jx_numlist::add_compositing_layer(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int *v12;
  _DWORD *v13;
  int v14;

  v3 = this;
  LODWORD(v4) = *(_DWORD *)(this + 24);
  if ((int)v4 < 1)
  {
    v8 = 0;
    if ((_DWORD)v4)
    {
LABEL_9:
      v10 = *(_DWORD *)(this + 28);
      if ((int)v4 >= v10)
      {
        *(_DWORD *)(this + 28) = v10 + 8;
        v9 = operator new[]();
        LODWORD(v4) = *(_DWORD *)(v3 + 24);
        this = *(_QWORD *)(v3 + 40);
        if ((int)v4 < 1)
        {
          v8 = 0;
        }
        else
        {
          v11 = *(unsigned int *)(v3 + 24);
          v12 = *(int **)(v3 + 40);
          v13 = (_DWORD *)v9;
          do
          {
            v14 = *v12++;
            *v13++ = v14;
            --v11;
          }
          while (v11);
          v8 = v4;
        }
        if (this != v3 + 32)
        {
          if (this)
          {
            this = MEMORY[0x18D761C18](this, 0x1000C8052888210);
            LODWORD(v4) = *(_DWORD *)(v3 + 24);
          }
        }
        *(_QWORD *)(v3 + 40) = v9;
      }
      else
      {
        v9 = *(_QWORD *)(this + 40);
      }
    }
    else
    {
      v4 = *(_QWORD *)(this + 40);
      if (v4)
        jx_numlist::add_compositing_layer();
      *(_DWORD *)(this + 28) = 1;
      v9 = this + 32;
      *(_QWORD *)(this + 40) = this + 32;
    }
    *(_DWORD *)(v3 + 24) = v4 + 1;
    *(_DWORD *)(v9 + 4 * v8) = a2;
  }
  else
  {
    v5 = *(int **)(this + 40);
    v6 = *(unsigned int *)(this + 24);
    while (1)
    {
      v7 = *v5++;
      if (v7 == a2)
        break;
      if (!--v6)
      {
        v8 = *(_DWORD *)(this + 24);
        goto LABEL_9;
      }
    }
  }
  return this;
}

int *jx_regions::set_num_regions(int *this, int a2)
{
  int *v2;
  int v3;
  int v4;
  BOOL v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 *v12;
  uint64_t v13;
  __int128 v14;

  v2 = this;
  v3 = a2 & ~(a2 >> 31);
  v4 = this[1];
  if (v3 <= v4)
  {
LABEL_19:
    *v2 = v3;
    return this;
  }
  if (v3 != 1)
  {
    v6 = v4 + v3;
    this[1] = v4 + v3;
    is_mul_ok(v4 + v3, 0x14uLL);
    v7 = operator new[]();
    v8 = v7;
    if (v6)
    {
      v9 = 20 * v6;
      v10 = v7;
      do
      {
        *(_QWORD *)v10 = 0;
        *(_QWORD *)(v10 + 8) = 0;
        *(_DWORD *)(v10 + 15) = 0;
        v10 += 20;
        v9 -= 20;
      }
      while (v9);
    }
    v11 = *v2;
    this = (int *)*((_QWORD *)v2 + 4);
    if ((int)v11 >= 1)
    {
      v12 = (__int128 *)*((_QWORD *)v2 + 4);
      v13 = v8;
      do
      {
        v14 = *v12;
        *(_DWORD *)(v13 + 15) = *(_DWORD *)((char *)v12 + 15);
        *(_OWORD *)v13 = v14;
        v13 += 20;
        v12 = (__int128 *)((char *)v12 + 20);
        --v11;
      }
      while (v11);
    }
    if (this && this != v2 + 2)
      this = (int *)MEMORY[0x18D761C18](this, 0x1000C80CC583DEELL);
    *((_QWORD *)v2 + 4) = v8;
    goto LABEL_19;
  }
  if (v4)
    v5 = 0;
  else
    v5 = *((_QWORD *)this + 4) == 0;
  if (!v5)
    jx_regions::set_num_regions();
  *(_QWORD *)this = 0x100000001;
  *((_QWORD *)this + 4) = this + 2;
  return this;
}

void jx_metanode::~jx_metanode(jx_metanode *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  jx_numlist *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  const char *v15;
  int v16;
  jx_metanode *v17;
  uint64_t v18;
  jx_metanode *v19;

  switch(*((_BYTE *)this + 15))
  {
    case 0:
      v2 = *((_QWORD *)this + 2);
      if (v2)
      {
        v3 = 0x10A0C409059F215;
        goto LABEL_15;
      }
      break;
    case 1:
      v8 = (jx_numlist *)*((_QWORD *)this + 2);
      if (v8)
      {
        jx_numlist::~jx_numlist(v8);
        v3 = 0x1010C40B2C1990FLL;
        goto LABEL_15;
      }
      break;
    case 2:
      v4 = *((_QWORD *)this + 2);
      if (v4)
      {
        v5 = *(_QWORD *)(v4 + 32);
        if (v5)
          v6 = v5 == v4 + 8;
        else
          v6 = 1;
        if (!v6)
          MEMORY[0x18D761C18]();
        v2 = v4;
        v3 = 0x1020C40ED299F00;
LABEL_15:
        MEMORY[0x18D761C30](v2, v3);
      }
      break;
    case 3:
      v7 = *((_QWORD *)this + 2);
      if (v7)
        MEMORY[0x18D761C18](v7, 0x1000C8077774924);
      break;
    default:
      break;
  }
  v9 = *((_QWORD *)this + 3);
  if (*((_BYTE *)this + 14))
  {
    if (!v9)
      goto LABEL_22;
    jp2_input_box::~jp2_input_box((jp2_input_box *)(v9 + 184));
    jp2_input_box::~jp2_input_box((jp2_input_box *)v9);
    v10 = 0x10A0C40BA7D9750;
  }
  else
  {
    if (!v9)
      goto LABEL_22;
    jp2_output_box::~jp2_output_box((jp2_output_box *)(v9 + 80));
    jp2_output_box::~jp2_output_box((jp2_output_box *)v9);
    v10 = 0x10B0C40C8E48792;
  }
  MEMORY[0x18D761C30](v9, v10);
LABEL_22:
  v11 = *((_QWORD *)this + 7);
  if (v11)
  {
    v12 = *((_QWORD *)this + 11);
    if (v12)
    {
      *(_QWORD *)(v12 + 80) = *((_QWORD *)this + 10);
      v13 = *((_QWORD *)this + 10);
      if (v13)
      {
LABEL_25:
        v14 = (_QWORD *)(v13 + 88);
LABEL_32:
        *v14 = v12;
        *((_QWORD *)this + 7) = 0;
        *((_QWORD *)this + 10) = 0;
        *((_QWORD *)this + 11) = 0;
        goto LABEL_33;
      }
    }
    else
    {
      if (*(jx_metanode **)(v11 + 64) != this)
      {
        v15 = "this == parent->head";
        v16 = 2676;
        goto LABEL_42;
      }
      v13 = *((_QWORD *)this + 10);
      *(_QWORD *)(v11 + 64) = v13;
      if (v13)
        goto LABEL_25;
    }
    v17 = *(jx_metanode **)(v11 + 72);
    v14 = (_QWORD *)(v11 + 72);
    if (v17 == this)
      goto LABEL_32;
    v15 = "this == parent->tail";
    v16 = 2683;
LABEL_42:
    __assert_rtn("~jx_metanode", "jpx.cpp", v16, v15);
  }
  if (*((_QWORD *)this + 10) || *((_QWORD *)this + 11))
  {
    v15 = "(next_sibling == NULL) && (prev_sibling == NULL)";
    v16 = 2691;
    goto LABEL_42;
  }
LABEL_33:
  v18 = *((_QWORD *)this + 12);
  if (v18)
    jx_metagroup::unlink(v18, this);
  if (*((_QWORD *)this + 13) || *((_QWORD *)this + 14) || *((_QWORD *)this + 12))
  {
    v15 = "(next_link == NULL) && (prev_link == NULL) && (metagroup == NULL)";
    v16 = 2695;
    goto LABEL_42;
  }
  while (1)
  {
    v19 = (jx_metanode *)*((_QWORD *)this + 8);
    if (!v19)
      break;
    jx_metanode::~jx_metanode(v19);
    MEMORY[0x18D761C30]();
  }
}

uint64_t jx_metagroup::unlink(uint64_t this, jx_metanode *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;

  if (*((_QWORD *)a2 + 12) != this)
    jx_metagroup::unlink();
  v2 = *((_QWORD *)a2 + 14);
  if (v2)
  {
    *(_QWORD *)(v2 + 104) = *((_QWORD *)a2 + 13);
    v3 = *((_QWORD *)a2 + 13);
    if (v3)
    {
LABEL_4:
      v4 = (_QWORD *)(v3 + 112);
      goto LABEL_8;
    }
  }
  else
  {
    if (*(jx_metanode **)this != a2)
      jx_metagroup::unlink();
    v3 = *((_QWORD *)a2 + 13);
    *(_QWORD *)this = v3;
    if (v3)
      goto LABEL_4;
  }
  v4 = (_QWORD *)(this + 8);
  if (*(jx_metanode **)(this + 8) != a2)
    jx_metagroup::unlink();
LABEL_8:
  *v4 = v2;
  *((_QWORD *)a2 + 12) = 0;
  *((_QWORD *)a2 + 13) = 0;
  *((_QWORD *)a2 + 14) = 0;
  if (!*(_QWORD *)this)
  {
    v5 = *(_QWORD *)(this + 16);
    if (v5)
    {
      if (*(_DWORD *)(v5 + 16))
        jx_metagroup::unlink();
      v6 = 0xAAAAAAAAAAAAAAABLL * ((this - v5 - 128) >> 3);
      if ((v6 & 0xFFFFFFC0) != 0)
        jx_metagroup::unlink();
      return jx_roigroup::delete_child(*(_QWORD *)(this + 16), (v6 >> 3) | ((v6 & 7) << 32));
    }
  }
  return this;
}

uint64_t jx_metanode::add_numlist(int32x2_t *this, int a2, const int *a3, int a4, const int *a5, char a6)
{
  uint64_t v12;
  uint64_t v13;
  int32x2_t v14;
  int32x2_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;

  v12 = operator new();
  v13 = v12;
  v14 = *this;
  *(_OWORD *)(v12 + 88) = 0u;
  *(_OWORD *)(v12 + 24) = 0u;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_OWORD *)(v12 + 72) = 0u;
  *(_OWORD *)(v12 + 104) = 0u;
  *(_OWORD *)(v12 + 8) = 0u;
  *(int32x2_t *)v12 = v14;
  v15 = this[9];
  *(int32x2_t *)(v12 + 88) = v15;
  if (v15)
    v16 = (uint64_t *)(*(_QWORD *)&v15 + 80);
  else
    v16 = (uint64_t *)&this[8];
  *v16 = v12;
  this[9] = (int32x2_t)v12;
  *(_QWORD *)(v12 + 56) = this;
  this[6] = vadd_s32(this[6], (int32x2_t)0x100000001);
  *(_DWORD *)(v12 + 8) = 1852601204;
  *(_BYTE *)(v12 + 12) = 1;
  *(_BYTE *)(v12 + 15) = 1;
  v17 = operator new();
  *(_OWORD *)v17 = 0u;
  *(_OWORD *)(v17 + 16) = 0u;
  *(_OWORD *)(v17 + 32) = 0u;
  *(_QWORD *)(v17 + 48) = 0;
  *(_QWORD *)(v13 + 16) = v17;
  if (a2 >= 1)
  {
    *(_DWORD *)v17 = a2;
    *(_DWORD *)(v17 + 4) = a2;
    v18 = 4 * a2;
    v19 = operator new[]();
    v20 = 0;
    *(_QWORD *)(*(_QWORD *)(v13 + 16) + 16) = v19;
    do
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 16) + 16) + v20) = a3[v20 / 4];
      v20 += 4;
    }
    while (v18 != v20);
    v17 = *(_QWORD *)(v13 + 16);
  }
  if (a4 >= 1)
  {
    *(_DWORD *)(v17 + 28) = a4;
    *(_DWORD *)(*(_QWORD *)(v13 + 16) + 24) = a4;
    v21 = 4 * a4;
    v22 = operator new[]();
    v23 = 0;
    *(_QWORD *)(*(_QWORD *)(v13 + 16) + 40) = v22;
    do
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 16) + 40) + v23) = a5[v23 / 4];
      v23 += 4;
    }
    while (v21 != v23);
    v17 = *(_QWORD *)(v13 + 16);
  }
  *(_BYTE *)(v17 + 48) = a6;
  jx_meta_manager::link(*(jx_meta_manager **)v13, (jx_metanode *)v13);
  return v13;
}

void jx_meta_manager::link(jx_meta_manager *this, jx_metanode *a2)
{
  jx_metanode *v2;
  int v4;
  char *v5;
  char *v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  char *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  float *v19;
  jx_metanode *v20;
  _DWORD *v21;
  _DWORD *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  _DWORD *exception;
  uint64_t v34;
  jx_metanode *v35;
  jx_meta_manager *v36;
  float32x2x2_t v37;

  v2 = a2;
  *((_QWORD *)this + 42) = a2;
  v4 = *((unsigned __int8 *)a2 + 15);
  if (v4 == 2)
  {
    v7 = 0;
    v8 = (_DWORD *)*((_QWORD *)a2 + 2);
    v9 = v8[2];
    v10 = v8[3];
    v12 = v8[4];
    v11 = v8[5];
    if (v11 <= v12)
      v11 = v12;
    do
    {
      v13 = v7 + 1;
      if (v7 > 0x1E)
        break;
      v14 = 8 << v7++;
    }
    while (v11 > v14);
    v15 = (char *)this + 8 * v13;
    v16 = *((_QWORD *)v15 + 9);
    v17 = v13 - 1;
    if (v16)
      goto LABEL_17;
    v18 = operator new();
    *(_QWORD *)(v18 + 40) = 0;
    *(_QWORD *)(v18 + 24) = 0;
    *(_QWORD *)(v18 + 32) = 0;
    jp2_output_box::jp2_output_box((jp2_output_box *)(v18 + 48));
    *(_QWORD *)v18 = this;
    *(_QWORD *)(v18 + 8) = 0;
    *(_DWORD *)(v18 + 16) = 0;
    *(_DWORD *)(v18 + 20) = v17;
    v37.val[0] = (float32x2_t)vshl_u32((uint32x2_t)0x8000000400, (uint32x2_t)vdup_n_s32(v17));
    v37.val[1] = v37.val[0];
    v19 = (float *)(v18 + 32);
    vst2_f32(v19, v37);
    bzero((void *)(v18 + 128), 0x600uLL);
    while (1)
    {
      *((_QWORD *)v15 + 9) = v18;
      v16 = v18;
LABEL_17:
      if (v10 < *(_DWORD *)(v16 + 36) && v9 < *(_DWORD *)(v16 + 32))
        break;
      v18 = operator new();
      jx_roigroup::jx_roigroup(v18, (uint64_t)this, v17, *(_DWORD *)(v16 + 16) + 1);
      *(_QWORD *)(v18 + 128) = v16;
      *(_QWORD *)(v16 + 8) = v18;
    }
    v36 = this;
    v35 = v2;
    v21 = (_DWORD *)(v16 + 24);
    v22 = (_DWORD *)(v16 + 28);
    v23 = v10 - *(_DWORD *)(v16 + 28);
    if (v23 < 0 || (v24 = v9 - *(_DWORD *)(v16 + 24), v24 < 0))
    {
LABEL_29:
      exception = __cxa_allocate_exception(4uLL);
      *exception = -50;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    while (1)
    {
      v25 = v23 / *(_DWORD *)(v16 + 44);
      if (v25 > 7 || (v26 = v24 / *(_DWORD *)(v16 + 40), v26 >= 8))
        jx_meta_manager::link();
      v27 = v16 + 128;
      v28 = 8 * v26;
      if (*(int *)(v16 + 16) < 1)
        break;
      v29 = v27 + 8 * v28;
      v30 = *(_QWORD *)(v29 + 8 * v25);
      if (!v30)
      {
        v31 = operator new();
        jx_roigroup::jx_roigroup(v31, (uint64_t)v36, v17, *(_DWORD *)(v16 + 16) - 1);
        *(_QWORD *)(v29 + 8 * v25) = v31;
        *(_QWORD *)(v31 + 8) = v16;
        v32 = *v22 + *(_DWORD *)(v16 + 44) * v25;
        v30 = *(_QWORD *)(v29 + 8 * v25);
        *(_DWORD *)(v30 + 24) = *v21 + *(_DWORD *)(v16 + 40) * v26;
        *(_DWORD *)(v30 + 28) = v32;
      }
      v21 = (_DWORD *)(v30 + 24);
      v22 = (_DWORD *)(v30 + 28);
      v23 = v10 - *(_DWORD *)(v30 + 28);
      if ((v23 & 0x80000000) == 0)
      {
        v24 = v9 - *(_DWORD *)(v30 + 24);
        v16 = v30;
        if ((v24 & 0x80000000) == 0)
          continue;
      }
      goto LABEL_29;
    }
    v5 = (char *)(v27 + 24 * (int)v28 + 24 * v25);
    *((_QWORD *)v5 + 2) = v16;
    v2 = v35;
    *((_QWORD *)v35 + 12) = v5;
    v6 = v5 + 8;
  }
  else if (v4 == 1)
  {
    v5 = (char *)this + 56;
    *((_QWORD *)a2 + 12) = (char *)this + 56;
    v6 = (char *)this + 64;
  }
  else
  {
    if (*((_DWORD *)a2 + 2) == 1718773093)
      return;
    v20 = a2;
    while (1)
    {
      v20 = (jx_metanode *)*((_QWORD *)v20 + 7);
      if (!v20)
        break;
      if (*((unsigned __int8 *)v20 + 15) - 1 < 2)
        return;
    }
    v5 = (char *)this + 32;
    *((_QWORD *)a2 + 12) = (char *)this + 32;
    v6 = (char *)this + 40;
  }
  v34 = *(_QWORD *)v6;
  *((_QWORD *)v2 + 13) = 0;
  *((_QWORD *)v2 + 14) = v34;
  if (v34)
    v5 = (char *)(v34 + 104);
  *(_QWORD *)v5 = v2;
  *(_QWORD *)v6 = v2;
}

void sub_187F83D94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B0C40E01A6C06);
  _Unwind_Resume(a1);
}

uint64_t jx_metanode::update_completed_descendants(jx_metanode *this)
{
  uint64_t i;
  uint64_t v2;
  int v3;

  if (!*((_BYTE *)this + 13) || !*((_BYTE *)this + 12))
    return 0xFFFFFFFFLL;
  for (i = *((_QWORD *)this + 7); i; this = (jx_metanode *)v2)
  {
    v2 = i;
    if (!*((_BYTE *)this + 13) || *((_DWORD *)this + 13) != *((_DWORD *)this + 12))
      break;
    v3 = *(_DWORD *)(i + 52);
    if (v3 >= *(_DWORD *)(v2 + 48))
      return 0xFFFFFFFFLL;
    *(_DWORD *)(v2 + 52) = v3 + 1;
    i = *(_QWORD *)(v2 + 56);
  }
  return 0;
}

BOOL jx_metanode::donate_input_box(jx_metanode *this, jp2_input_box *a2)
{
  uint64_t v4;
  int v5;

  if (*((_QWORD *)this + 3) || *((_BYTE *)this + 12) || *((_BYTE *)this + 13))
    jx_metanode::donate_input_box();
  *((_BYTE *)this + 14) = 1;
  v4 = operator new();
  jx_metaread::jx_metaread((jx_metaread *)v4);
  *((_QWORD *)this + 3) = v4;
  v5 = *((_DWORD *)a2 + 12);
  *((_DWORD *)this + 2) = v5;
  if (v5 == 1634955107)
  {
    jp2_input_box::transplant((jp2_input_box *)v4, a2);
  }
  else
  {
    jp2_input_box::transplant((jp2_input_box *)(v4 + 184), a2);
    *((_BYTE *)this + 13) = 1;
  }
  return jx_metanode::finish_reading(this);
}

void sub_187F83ECC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A0C40BA7D9750);
  _Unwind_Resume(a1);
}

BOOL jx_metanode::finish_reading(jx_metanode *this)
{
  uint64_t v2;
  uint64_t v3;
  _BOOL8 result;
  uint64_t v5;
  int64_t v6;
  uint64_t v7;
  jx_codestream_source *v8;
  jx_layer_source *v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  int v21;
  uint64_t v22;
  signed int v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  signed int v39;
  uint64_t v40;
  int v41;
  int v42;
  unsigned __int8 *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  unsigned int v48[2];
  unsigned int v49;
  __int16 v50;
  unsigned __int8 v51;
  _BYTE v52[17];
  __int128 v53;
  uint64_t v54;

  if (!*((_BYTE *)this + 14))
    return 1;
  v2 = *((_QWORD *)this + 3);
  if (!v2)
  {
    if (!*((_BYTE *)this + 12) || !*((_BYTE *)this + 13))
      jx_metanode::finish_reading();
    return 1;
  }
  if (*((_BYTE *)this + 12))
  {
LABEL_4:
    while (!*((_BYTE *)this + 13))
    {
      v7 = *((_QWORD *)this + 3);
      v8 = *(jx_codestream_source **)(v7 + 368);
      if (v8)
      {
        if (!jx_codestream_source::finish(v8, 0))
          return 0;
      }
      else
      {
        v9 = *(jx_layer_source **)(v7 + 376);
        if (v9)
        {
          if (!jx_layer_source::finish(v9))
            return 0;
        }
        else
        {
          if (!*(_BYTE *)(v7 + 126))
          {
            v54 = 0;
            *(_OWORD *)&v52[1] = 0u;
            v53 = 0u;
            kdu_error::kdu_error((kdu_error *)&v52[1], "Error in Kakadu File Format Support:\n");
            (*(void (**)(_BYTE *, const char *))(*(_QWORD *)&v52[1] + 16))(&v52[1], "ASOC box not found");
            kdu_error::~kdu_error((kdu_error *)&v52[1]);
          }
          if (*(_BYTE *)(v7 + 310))
            jx_metanode::finish_reading();
          if (jp2_input_box::open((jp2_input_box *)(v7 + 184), (jp2_input_box *)v7))
          {
            v10 = *((_QWORD *)this + 3);
            v11 = *(_DWORD *)(v10 + 232);
            if (v11 == 1634955107)
              goto LABEL_37;
            v12 = *(unsigned int *)(*(_QWORD *)this + 436);
            if (!(_DWORD)v12)
              goto LABEL_37;
            if ((int)v12 < 1)
              goto LABEL_45;
            v13 = *(_DWORD **)(*(_QWORD *)this + 440);
            if (*v13 == v11)
              goto LABEL_37;
            v14 = 1;
            do
            {
              v15 = v14;
              if (v12 == v14)
                break;
              v16 = v13[v14++];
            }
            while (v16 != v11);
            if (v15 < v12)
            {
LABEL_37:
              v17 = operator new();
              v18 = *(_QWORD *)this;
              *(_OWORD *)(v17 + 88) = 0u;
              *(_OWORD *)(v17 + 8) = 0u;
              *(_OWORD *)(v17 + 24) = 0u;
              *(_OWORD *)(v17 + 40) = 0u;
              *(_OWORD *)(v17 + 56) = 0u;
              *(_OWORD *)(v17 + 72) = 0u;
              *(_OWORD *)(v17 + 104) = 0u;
              *(_QWORD *)v17 = v18;
              v19 = *((_QWORD *)this + 9);
              *(_QWORD *)(v17 + 88) = v19;
              if (v19)
                v20 = (uint64_t *)(v19 + 80);
              else
                v20 = (uint64_t *)((char *)this + 64);
              *v20 = v17;
              *((_QWORD *)this + 9) = v17;
              *(_QWORD *)(v17 + 56) = this;
              ++*((_DWORD *)this + 12);
              jx_metanode::donate_input_box((jx_metanode *)v17, (jp2_input_box *)(*((_QWORD *)this + 3) + 184));
            }
            else
            {
LABEL_45:
              jp2_input_box::close((jp2_input_box *)(v10 + 184));
            }
          }
          else
          {
            result = jp2_input_box::is_complete(*((jp2_input_box **)this + 3));
            if (!result)
              return result;
            *((_BYTE *)this + 13) = 1;
            jx_metanode::update_completed_descendants(this);
          }
        }
      }
    }
    v3 = *((_QWORD *)this + 3);
    if (v3)
    {
      jp2_input_box::~jp2_input_box((jp2_input_box *)(v3 + 184));
      jp2_input_box::~jp2_input_box((jp2_input_box *)v3);
      MEMORY[0x18D761C30]();
    }
    *((_QWORD *)this + 3) = 0;
    return 1;
  }
  if (!*(_BYTE *)(v2 + 310))
  {
    if (!*(_BYTE *)(v2 + 126))
      jx_metanode::finish_reading();
    jp2_input_box::open((jp2_input_box *)(v2 + 184), (jp2_input_box *)v2);
    v2 = *((_QWORD *)this + 3);
    if (!*(_BYTE *)(v2 + 310))
      return 0;
    *((_DWORD *)this + 2) = *(_DWORD *)(v2 + 232);
  }
  result = jp2_input_box::is_complete((jp2_input_box *)(v2 + 184));
  *((_BYTE *)this + 12) = result;
  if (result)
  {
    v5 = *((_QWORD *)this + 3);
    if (*(_BYTE *)(v5 + 309))
      v6 = -1;
    else
      v6 = *(_QWORD *)(v5 + 272) - *(_QWORD *)(v5 + 320) + *(unsigned int *)(v5 + 360);
    v21 = *((_DWORD *)this + 2);
    if (v21 == 1852601204)
    {
      *((_BYTE *)this + 15) = 1;
      v22 = operator new();
      *(_OWORD *)v22 = 0u;
      *(_OWORD *)(v22 + 16) = 0u;
      *(_OWORD *)(v22 + 32) = 0u;
      *(_QWORD *)(v22 + 48) = 0;
      *((_QWORD *)this + 2) = v22;
      if (!(_DWORD)v6 || (v6 & 3) != 0)
      {
        v54 = 0;
        *(_OWORD *)&v52[1] = 0uLL;
        v53 = 0uLL;
        kdu_error::kdu_error((kdu_error *)&v52[1], "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v52[1]);
      }
      if ((int)v6 >= 4)
      {
        v23 = (v6 >> 2) + 1;
        do
        {
          *(_DWORD *)&v52[1] = 0;
          jp2_input_box::read((jp2_input_box *)(*((_QWORD *)this + 3) + 184), (unsigned int *)&v52[1]);
          if (*(_DWORD *)&v52[1])
          {
            if ((*(_DWORD *)&v52[1] & 0x1000000) != 0)
            {
              jx_numlist::add_codestream(*((unsigned int **)this + 2), *(_DWORD *)&v52[1] & 0xFFFFFF);
            }
            else if ((*(_DWORD *)&v52[1] & 0x2000000) != 0)
            {
              jx_numlist::add_compositing_layer(*((_QWORD *)this + 2), *(_DWORD *)&v52[1] & 0xFFFFFF);
            }
          }
          else
          {
            *(_BYTE *)(*((_QWORD *)this + 2) + 48) = 1;
          }
          --v23;
        }
        while (v23 > 1);
      }
    }
    else if (v21 == 1919904100 && (int)v6 >= 2)
    {
      *((_BYTE *)this + 15) = 2;
      v24 = operator new();
      *(_QWORD *)(v24 + 32) = 0;
      *(_DWORD *)(v24 + 40) = 0;
      *(_QWORD *)(v24 + 8) = 0;
      *(_QWORD *)(v24 + 16) = 0;
      *(_QWORD *)v24 = 0;
      *(_DWORD *)(v24 + 23) = 0;
      *((_QWORD *)this + 2) = v24;
      v52[0] = 0;
      (*(void (**)(uint64_t, _BYTE *, uint64_t))(*(_QWORD *)(*((_QWORD *)this + 3) + 184) + 32))(*((_QWORD *)this + 3) + 184, v52, 1);
      jx_regions::set_num_regions(*((int **)this + 2), v52[0]);
      if (v52[0])
      {
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v28 = 0;
        LODWORD(v29) = 0;
        v30 = 12;
        do
        {
          v51 = 0;
          v50 = 0;
          v49 = 0;
          *(_QWORD *)v48 = 0;
          v47 = 0;
          if ((*(unsigned int (**)(uint64_t, unsigned __int8 *, uint64_t))(*(_QWORD *)(*((_QWORD *)this + 3)
                                                                                               + 184)
                                                                                   + 32))(*((_QWORD *)this + 3) + 184, &v51, 1) != 1|| (*(unsigned int (**)(uint64_t, char *, uint64_t))(*(_QWORD *)(*((_QWORD *)this + 3) + 184)+ 32))(*((_QWORD *)this + 3) + 184, (char *)&v50 + 1, 1) != 1|| (*(unsigned int (**)(uint64_t, __int16 *, uint64_t))(*(_QWORD *)(*((_QWORD *)this + 3) + 184)+ 32))(*((_QWORD *)this + 3) + 184, &v50, 1) != 1|| !jp2_input_box::read((jp2_input_box *)(*((_QWORD *)this + 3) + 184), &v49)|| !jp2_input_box::read((jp2_input_box *)(*((_QWORD *)this + 3) + 184), &v48[1])|| !jp2_input_box::read((jp2_input_box *)(*((_QWORD *)this + 3) + 184), v48)|| !jp2_input_box::read((jp2_input_box *)(*((_QWORD *)this + 3) + 184), &v47)|| v51 > 1u|| HIBYTE(v50) >= 2u)
          {
            v54 = 0;
            *(_OWORD *)&v52[1] = 0u;
            v53 = 0u;
            kdu_error::kdu_error((kdu_error *)&v52[1], "Error in Kakadu File Format Support:\n");
            kdu_error::~kdu_error((kdu_error *)&v52[1]);
          }
          *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 2) + 32) + v30 + 4) = HIBYTE(v50) == 1;
          v31 = *(_QWORD *)(*((_QWORD *)this + 2) + 32) + v30;
          v32 = v47;
          v33 = v48[0];
          if (*(_BYTE *)(v31 + 4))
          {
            v33 = v48[0] | 1;
            v32 = v47 | 1;
            v47 |= 1u;
            v48[0] |= 1u;
          }
          *(_BYTE *)(v31 + 5) = v51 == 1;
          *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 2) + 32) + v30 + 6) = v50;
          v34 = *(_QWORD *)(*((_QWORD *)this + 2) + 32) + v30;
          v35 = v33 >> 1;
          if (*(_BYTE *)(v34 + 4))
            v36 = v32 >> 1;
          else
            v36 = 0;
          if (!*(_BYTE *)(v34 + 4))
            v35 = 0;
          v37 = v48[1] - v36;
          v38 = v49 - v35;
          *(_QWORD *)(v34 - 12) = v37 | (v38 << 32);
          *(_DWORD *)(v34 - 4) = v32;
          *(_DWORD *)v34 = v33;
          if ((int)v33 >= (int)v32)
            v39 = v32;
          else
            v39 = v33;
          v40 = *((_QWORD *)this + 2);
          if (v30 == 12)
          {
            *(_DWORD *)(v40 + 40) = v39;
            v27 = v38 + v33;
            v26 = v37 + v32;
            v29 = v38;
            v28 = v37;
          }
          else
          {
            if (v39 > *(_DWORD *)(v40 + 40))
              *(_DWORD *)(v40 + 40) = v39;
            v41 = v38 + v33;
            v42 = v37 + v32;
            if ((int)v38 >= (int)v29)
              v29 = v29;
            else
              v29 = v38;
            if ((int)v37 < v28)
              v28 = v37;
            if (v41 > v27)
              v27 = v41;
            if (v42 > v26)
              v26 = v42;
          }
          ++v25;
          v30 += 20;
        }
        while (v25 < v52[0]);
      }
      else
      {
        v29 = 0;
        v28 = 0;
        v27 = 0;
        v26 = 0;
      }
      *(_QWORD *)(*((_QWORD *)this + 2) + 8) = v28 | (unint64_t)(v29 << 32);
      *(_QWORD *)(*((_QWORD *)this + 2) + 16) = (v26 - v28) | ((unint64_t)(v27 - v29) << 32);
    }
    else if (v21 == 1818389536 && (int)v6 >= 1 && (int)v6 < 0x2000)
    {
      *((_BYTE *)this + 15) = 3;
      v43 = (unsigned __int8 *)operator new[]();
      *((_QWORD *)this + 2) = v43;
      jp2_input_box::read((jp2_input_box *)(*((_QWORD *)this + 3) + 184), v43, v6);
      *(_BYTE *)(*((_QWORD *)this + 2) + v6) = 0;
    }
    else
    {
      *((_BYTE *)this + 15) = 0;
      if (v21 == 1970628964)
      {
        *((_QWORD *)this + 5) = 0;
        *((_QWORD *)this + 4) = 0;
        jp2_input_box::read((jp2_input_box *)(v5 + 184), (unsigned __int8 *)this + 32, 16);
      }
      v44 = operator new();
      *(_OWORD *)(v44 + 8) = xmmword_18820CDD0;
      *(_DWORD *)(v44 + 24) = 0;
      *(_DWORD *)(v44 + 32) = 0;
      *(_QWORD *)(v44 + 40) = 0;
      *((_QWORD *)this + 2) = v44;
      *(_QWORD *)v44 = **(_QWORD **)this;
      v45 = *((_QWORD *)this + 3);
      v46 = *(_DWORD *)(v45 + 208);
      *(_OWORD *)(v44 + 8) = *(_OWORD *)(v45 + 192);
      *(_DWORD *)(v44 + 24) = v46;
    }
    jp2_input_box::close((jp2_input_box *)(*((_QWORD *)this + 3) + 184));
    jx_meta_manager::link(*(jx_meta_manager **)this, this);
    if (*((_BYTE *)this + 13))
      jx_metanode::update_completed_descendants(this);
    goto LABEL_4;
  }
  return result;
}

void sub_187F846E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F846EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Exception *v13;

  _Unwind_Resume(v13);
}

BOOL jx_codestream_source::finish(jx_codestream_source *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 result;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  jx_metaread *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  jx_metanode *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  jx_metaread *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BOOL4 is_complete;
  int *v28;
  _OWORD v29[2];
  uint64_t v30;

  if (*((_BYTE *)this + 20))
  {
    if (a2)
    {
      v4 = *((_QWORD *)this + 69);
      if (v4 < 0)
      {
        if (!*((_QWORD *)this + 68))
          goto LABEL_11;
      }
      else if (!v4 && !*((_DWORD *)this + 140))
      {
        goto LABEL_11;
      }
    }
    return 1;
  }
  do
  {
LABEL_11:
    v5 = *((_QWORD *)this + 65);
    if (v5 < 0)
    {
      if (!*((_QWORD *)this + 64))
        continue;
    }
    else if (!v5 && !*((_DWORD *)this + 132))
    {
      continue;
    }
    if (!a2)
      break;
    v6 = *((_QWORD *)this + 69);
    if (v6 < 0)
    {
      if (*((_QWORD *)this + 68))
        break;
      continue;
    }
    if (v6 || *((_DWORD *)this + 140))
      break;
  }
  while (!*((_BYTE *)this + 23)
       && !*(_BYTE *)(*(_QWORD *)this + 216)
       && (jx_source::parse_next_top_level_box(*(jx_source **)this, 0) & 1) != 0);
  if (!*((_BYTE *)this + 150))
    goto LABEL_63;
  is_complete = jp2_input_box::is_complete((jx_codestream_source *)((char *)this + 24));
  v28 = (int *)((char *)this + 16);
  while (*((_BYTE *)this + 334)
       || jp2_input_box::open((jx_codestream_source *)((char *)this + 208), (jx_codestream_source *)((char *)this + 24)))
  {
    result = jp2_input_box::is_complete((jx_codestream_source *)((char *)this + 208));
    v8 = *((_DWORD *)this + 64);
    if (v8 > 1768449137)
    {
      if (v8 == 1885564018)
      {
        if (!result)
          return result;
        j2_palette::init((jx_codestream_source *)((char *)this + 440), (jx_codestream_source *)((char *)this + 208));
      }
      else
      {
        if (v8 != 1768449138)
        {
LABEL_36:
          if (jx_source::test_box_filter(*(jx_source **)this, v8))
          {
            v9 = (uint64_t *)*((_QWORD *)this + 67);
            if (!v9)
            {
              v10 = jx_metanode::add_numlist(*(int32x2_t **)(*(_QWORD *)this + 1864), 1, v28, 0, 0, 0);
              *((_QWORD *)this + 67) = v10;
              *(_BYTE *)(v10 + 14) = 1;
              v11 = (jx_metaread *)operator new();
              jx_metaread::jx_metaread(v11);
              *(_QWORD *)(*((_QWORD *)this + 67) + 24) = v11;
              v9 = (uint64_t *)*((_QWORD *)this + 67);
              *(_QWORD *)(v9[3] + 368) = this;
            }
            v12 = operator new();
            v13 = *v9;
            *(_OWORD *)(v12 + 8) = 0u;
            *(_OWORD *)(v12 + 24) = 0u;
            *(_OWORD *)(v12 + 40) = 0u;
            *(_OWORD *)(v12 + 56) = 0u;
            *(_OWORD *)(v12 + 72) = 0u;
            *(_OWORD *)(v12 + 104) = 0u;
            *(_OWORD *)(v12 + 88) = 0u;
            *(_QWORD *)v12 = v13;
            v14 = v9[9];
            *(_QWORD *)(v12 + 88) = v14;
            if (v14)
              v15 = (uint64_t *)(v14 + 80);
            else
              v15 = v9 + 8;
            *v15 = v12;
            v9[9] = v12;
            *(_QWORD *)(v12 + 56) = v9;
            ++*((_DWORD *)v9 + 12);
            jx_metanode::donate_input_box((jx_metanode *)v12, (jx_codestream_source *)((char *)this + 208));
            if (*((_BYTE *)this + 334))
              jx_codestream_source::finish();
          }
          else
          {
            jp2_input_box::close((jx_codestream_source *)((char *)this + 208));
          }
          continue;
        }
        if (!result)
          return result;
        j2_dimensions::init((jx_codestream_source *)((char *)this + 392), (jx_codestream_source *)((char *)this + 208));
      }
    }
    else if (v8 == 1651532643)
    {
      if (!result)
        return result;
      j2_dimensions::process_bpcc_box((jx_codestream_source *)((char *)this + 392), (jx_codestream_source *)((char *)this + 208));
      *((_BYTE *)this + 432) = 1;
    }
    else
    {
      if (v8 != 1668112752)
        goto LABEL_36;
      if (!result)
        return result;
      j2_component_map::init((jx_codestream_source *)((char *)this + 472), (jx_codestream_source *)((char *)this + 208));
    }
  }
  if (!is_complete)
  {
    if ((*((_DWORD *)this + 100) & 0x80000000) != 0
      || !*((_BYTE *)this + 432)
      || !*((_BYTE *)this + 440)
      || *((int *)this + 125) < 1)
    {
      goto LABEL_62;
    }
    v19 = *((_QWORD *)this + 67);
    if (!v19)
    {
      v20 = jx_metanode::add_numlist(*(int32x2_t **)(*(_QWORD *)this + 1864), 1, v28, 0, 0, 0);
      *((_QWORD *)this + 67) = v20;
      *(_BYTE *)(v20 + 14) = 1;
      v21 = (jx_metaread *)operator new();
      jx_metaread::jx_metaread(v21);
      *(_QWORD *)(*((_QWORD *)this + 67) + 24) = v21;
      v19 = *((_QWORD *)this + 67);
    }
    *(_QWORD *)(*(_QWORD *)(v19 + 24) + 368) = 0;
    jp2_input_box::transplant(*(jp2_input_box **)(v19 + 24), (jx_codestream_source *)((char *)this + 24));
    if (*((_BYTE *)this + 150))
      jx_codestream_source::finish();
LABEL_63:
    if (!*((_BYTE *)this + 23))
    {
      v22 = *((_QWORD *)this + 65);
      if (v22 < 0)
      {
        if (*((_QWORD *)this + 64))
          goto LABEL_64;
      }
      else if (v22 || *((_DWORD *)this + 132))
      {
        goto LABEL_64;
      }
      if (!*(_BYTE *)(*(_QWORD *)this + 216))
        return 0;
    }
LABEL_64:
    if (*((_BYTE *)this + 20))
    {
      if (!a2)
        return 1;
    }
    else
    {
      if ((*((_DWORD *)this + 100) & 0x80000000) != 0)
      {
        v23 = *(_QWORD *)this;
        if (!*(_BYTE *)(*(_QWORD *)this + 600))
        {
          result = jx_source::finish_jp2_header_box(*(jx_source **)this);
          if (!result)
            return result;
        }
        if ((*(_DWORD *)(v23 + 616) & 0x80000000) != 0)
        {
          v30 = 0;
          memset(v29, 0, sizeof(v29));
          kdu_error::kdu_error((kdu_error *)v29, "Error in Kakadu File Format Support:\n");
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v29[0] + 16))(v29, "JPX source contains no image header box for a codestream.  The image header (ihdr) box cannot be found in a codestream header (chdr) box, and does not exist within a default JP2 header (jp2h) box.");
          kdu_error::~kdu_error((kdu_error *)v29);
        }
        j2_dimensions::copy((jx_codestream_source *)((char *)this + 392), (j2_dimensions *)(v23 + 608));
      }
      if (*((_BYTE *)this + 440))
        goto LABEL_83;
      v24 = *(_QWORD *)this;
      if (!*(_BYTE *)(*(_QWORD *)this + 600))
      {
        result = jx_source::finish_jp2_header_box(*(jx_source **)this);
        if (!result)
          return result;
      }
      if (*(_BYTE *)(v24 + 864))
        j2_palette::copy((jx_codestream_source *)((char *)this + 440), (j2_palette *)(v24 + 864));
      if (*((_BYTE *)this + 440))
      {
LABEL_83:
        if (*((int *)this + 125) <= 0)
        {
          v25 = *(_QWORD *)this;
          if (!*(_BYTE *)(*(_QWORD *)this + 600))
          {
            result = jx_source::finish_jp2_header_box(*(jx_source **)this);
            if (!result)
              return result;
          }
          if (*(int *)(v25 + 924) <= 0)
            j2_component_map::init_missing_cmap(v25 + 896, (uint64_t)this + 392);
          j2_component_map::copy((uint64_t)this + 472, v25 + 896);
        }
      }
      j2_dimensions::finalize((uint64_t)this + 392);
      j2_palette::finalize((uint64_t)this + 440);
      j2_component_map::finalize((uint64_t)this + 472, (jx_codestream_source *)((char *)this + 392), (jx_codestream_source *)((char *)this + 440));
      *((_BYTE *)this + 20) = 1;
      if (!a2)
        return 1;
    }
    v26 = *((_QWORD *)this + 69);
    if (v26 < 0)
    {
      if (!*((_QWORD *)this + 68))
        return 0;
    }
    else if (!v26 && !*((_DWORD *)this + 140))
    {
      return 0;
    }
    return 1;
  }
  jp2_input_box::close((jx_codestream_source *)((char *)this + 24));
  v16 = (jx_metanode *)*((_QWORD *)this + 67);
  if (v16)
  {
    *((_BYTE *)v16 + 13) = 1;
    jx_metanode::update_completed_descendants(v16);
    v17 = *((_QWORD *)this + 67);
    v18 = *(_QWORD *)(v17 + 24);
    if (v18)
    {
      jp2_input_box::~jp2_input_box((jp2_input_box *)(v18 + 184));
      jp2_input_box::~jp2_input_box((jp2_input_box *)v18);
      MEMORY[0x18D761C30]();
      v17 = *((_QWORD *)this + 67);
    }
    *(_QWORD *)(v17 + 24) = 0;
  }
LABEL_62:
  if (!*((_BYTE *)this + 150))
    goto LABEL_63;
  return 0;
}

void sub_187F84CB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A0C40BA7D9750);
  _Unwind_Resume(a1);
}

BOOL jx_layer_source::finish(jx_layer_source *this)
{
  _BOOL8 result;
  uint64_t v3;
  jx_source *v4;
  jx_layer_source *v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  jx_metaread *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  j2_colour *v14;
  j2_colour *v15;
  j2_colour *v16;
  jx_metanode *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  jx_codestream_source *codestream;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t size;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  j2_colour *v37;
  uint64_t v38;
  uint64_t v39;
  float v40;
  char *v41;
  unsigned int v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  j2_colour *v49;
  j2_colour *v50;
  j2_colour *v51;
  uint64_t v52;
  uint64_t v53;
  jx_metaread *v54;
  int *v55;
  _BOOL4 is_complete;
  j2_resolution *v57;
  char *v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  if (*((_BYTE *)this + 12))
    return 1;
  do
  {
    v3 = *((_QWORD *)this + 72);
    if (v3 < 0)
    {
      if (*((_QWORD *)this + 71))
        break;
      goto LABEL_8;
    }
    if (v3 || *((_DWORD *)this + 146))
      break;
LABEL_8:
    v4 = *(jx_source **)this;
  }
  while (!*(_BYTE *)(*(_QWORD *)this + 216)
       && !*((_BYTE *)v4 + 16)
       && (jx_source::parse_next_top_level_box(v4, 0) & 1) != 0);
  if (!*((_BYTE *)this + 142))
    goto LABEL_62;
  is_complete = jp2_input_box::is_complete((jx_layer_source *)((char *)this + 16));
  if (*((_BYTE *)this + 326))
    v5 = (jx_layer_source *)((char *)this + 200);
  else
    v5 = (jx_layer_source *)((char *)this + 16);
  v57 = (jx_layer_source *)((char *)this + 592);
  v55 = (int *)((char *)this + 8);
  while (1)
  {
    if (!*((_BYTE *)this + 510) && (jp2_input_box::open((jx_layer_source *)((char *)this + 384), v5) & 1) == 0)
    {
      if (v5 != (jx_layer_source *)((char *)this + 200))
        break;
      if (!jp2_input_box::is_complete((jx_layer_source *)((char *)this + 200)))
        break;
      if (!jp2_input_box::close((jx_layer_source *)((char *)this + 200)))
        break;
      v5 = (jx_layer_source *)((char *)this + 16);
      if (!jp2_input_box::open((jx_layer_source *)((char *)this + 384), (jx_layer_source *)((char *)this + 16)))break;
    }
    if (*((_DWORD *)this + 108) == 1667723888)
    {
      if (!*((_BYTE *)this + 326))
      {
        jp2_input_box::transplant((jx_layer_source *)((char *)this + 200), (jx_layer_source *)((char *)this + 384));
        v5 = (jx_layer_source *)((char *)this + 200);
        continue;
      }
LABEL_24:
      jp2_input_box::close((jx_layer_source *)((char *)this + 384));
      continue;
    }
    result = jp2_input_box::is_complete((jx_layer_source *)((char *)this + 384));
    v6 = *((_DWORD *)this + 108);
    if (v6 <= 1668441446)
    {
      if (v6 == 1667523942)
      {
LABEL_42:
        if (!result)
          return result;
        j2_channels::init((jx_layer_source *)((char *)this + 608), (jx_layer_source *)((char *)this + 384));
        continue;
      }
      if (v6 == 1668246642)
      {
        if (!result)
          return result;
        v14 = (jx_layer_source *)((char *)this + 648);
        if (!*((_BYTE *)this + 326))
        {
          v61 = 0;
          v59 = 0u;
          v60 = 0u;
          kdu_warning::kdu_warning((kdu_warning *)&v59, "Warning in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v59 + 16))(&v59, "Colour description (colr) box found inside a compositing layer header (jplh) box, but not wrapped by a colour group (cgrp) box.  This is technically a violation of the JPX standard, but we will parse the box anyway.");
          kdu_warning::~kdu_warning((kdu_warning *)&v59);
          v14 = (jx_layer_source *)((char *)this + 648);
        }
        do
        {
          v15 = v14;
          v14 = (j2_colour *)*((_QWORD *)v14 + 13);
        }
        while (v14);
        if (*(_BYTE *)v15)
        {
          v16 = (j2_colour *)operator new();
          j2_colour::j2_colour(v16);
          *((_QWORD *)v15 + 13) = v16;
        }
        else
        {
          v16 = v15;
        }
        j2_colour::init(v16, (jx_layer_source *)((char *)this + 384));
        continue;
      }
    }
    else
    {
      switch(v6)
      {
        case 1668441447:
          if (!result)
            return result;
          jx_registration::init((jx_layer_source *)((char *)this + 760), (jx_layer_source *)((char *)this + 384));
          continue;
        case 1869636468:
          goto LABEL_42;
        case 1919251232:
          if (!result)
            return result;
          j2_resolution::init(v57, (jx_layer_source *)((char *)this + 384));
          continue;
      }
    }
    if (!jx_source::test_box_filter(*(jx_source **)this, v6))
      goto LABEL_24;
    v7 = (uint64_t *)*((_QWORD *)this + 99);
    if (!v7)
    {
      v8 = jx_metanode::add_numlist(*(int32x2_t **)(*(_QWORD *)this + 1864), 0, 0, 1, v55, 0);
      *((_QWORD *)this + 99) = v8;
      *(_BYTE *)(v8 + 14) = 1;
      v9 = (jx_metaread *)operator new();
      jx_metaread::jx_metaread(v9);
      *(_QWORD *)(*((_QWORD *)this + 99) + 24) = v9;
      v7 = (uint64_t *)*((_QWORD *)this + 99);
      *(_QWORD *)(v7[3] + 376) = this;
    }
    v10 = operator new();
    v11 = *v7;
    *(_OWORD *)(v10 + 8) = 0u;
    *(_OWORD *)(v10 + 24) = 0u;
    *(_OWORD *)(v10 + 40) = 0u;
    *(_OWORD *)(v10 + 56) = 0u;
    *(_OWORD *)(v10 + 72) = 0u;
    *(_OWORD *)(v10 + 104) = 0u;
    *(_OWORD *)(v10 + 88) = 0u;
    *(_QWORD *)v10 = v11;
    v12 = v7[9];
    *(_QWORD *)(v10 + 88) = v12;
    if (v12)
      v13 = (uint64_t *)(v12 + 80);
    else
      v13 = v7 + 8;
    *v13 = v10;
    v7[9] = v10;
    *(_QWORD *)(v10 + 56) = v7;
    ++*((_DWORD *)v7 + 12);
    jx_metanode::donate_input_box((jx_metanode *)v10, (jx_layer_source *)((char *)this + 384));
    if (*((_BYTE *)this + 510))
      jx_layer_source::finish();
  }
  if (is_complete)
  {
    jp2_input_box::close((jx_layer_source *)((char *)this + 16));
    v17 = (jx_metanode *)*((_QWORD *)this + 99);
    if (v17)
    {
      *((_BYTE *)v17 + 13) = 1;
      jx_metanode::update_completed_descendants(v17);
      v18 = *((_QWORD *)this + 99);
      v19 = *(_QWORD *)(v18 + 24);
      if (v19)
      {
        jp2_input_box::~jp2_input_box((jp2_input_box *)(v19 + 184));
        jp2_input_box::~jp2_input_box((jp2_input_box *)v19);
        MEMORY[0x18D761C30]();
        v18 = *((_QWORD *)this + 99);
      }
      *(_QWORD *)(v18 + 24) = 0;
    }
LABEL_61:
    if (!*((_BYTE *)this + 142))
      goto LABEL_62;
    return 0;
  }
  if (!*((_BYTE *)this + 648)
    || *((_BYTE *)this + 326)
    || !*((_DWORD *)this + 153)
    || *(float *)v57 <= 0.0
    || *((int *)this + 191) < 1)
  {
    goto LABEL_61;
  }
  v52 = *((_QWORD *)this + 99);
  if (!v52)
  {
    v53 = jx_metanode::add_numlist(*(int32x2_t **)(*(_QWORD *)this + 1864), 0, 0, 1, v55, 0);
    *((_QWORD *)this + 99) = v53;
    *(_BYTE *)(v53 + 14) = 1;
    v54 = (jx_metaread *)operator new();
    jx_metaread::jx_metaread(v54);
    *(_QWORD *)(*((_QWORD *)this + 99) + 24) = v54;
    v52 = *((_QWORD *)this + 99);
  }
  *(_QWORD *)(*(_QWORD *)(v52 + 24) + 376) = 0;
  jp2_input_box::transplant(*(jp2_input_box **)(v52 + 24), (jx_layer_source *)((char *)this + 16));
  if (*((_BYTE *)this + 142))
    jx_layer_source::finish();
LABEL_62:
  v20 = *((_QWORD *)this + 72);
  if (v20 < 0)
  {
    if (!*((_QWORD *)this + 71))
    {
LABEL_67:
      if (!*(_BYTE *)(*(_QWORD *)this + 216) && !*(_BYTE *)(*(_QWORD *)this + 16))
        return 0;
    }
  }
  else if (!v20 && !*((_DWORD *)this + 146))
  {
    goto LABEL_67;
  }
  jx_registration::finalize((jx_layer_source *)((char *)this + 760), *((_DWORD *)this + 2));
  LODWORD(v21) = *((_DWORD *)this + 191);
  if ((int)v21 >= 1)
  {
    v22 = 0;
    v23 = 0;
    while (1)
    {
      codestream = (jx_codestream_source *)jx_source::get_codestream(*(jx_source **)this, *(_DWORD *)(*((_QWORD *)this + 96) + v22));
      if (!codestream)
        break;
      if (!jx_codestream_source::finish(codestream, 1))
        return 0;
      ++v23;
      v21 = *((int *)this + 191);
      v22 += 20;
      if (v23 >= v21)
        goto LABEL_74;
    }
    if (*(_BYTE *)(*(_QWORD *)this + 216))
    {
      v61 = 0;
      v59 = 0u;
      v60 = 0u;
      kdu_error::kdu_error((kdu_error *)&v59, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v59 + 16))(&v59, "Encountered a JPX compositing layer box which utilizes a non-existent codestream!");
      kdu_error::~kdu_error((kdu_error *)&v59);
    }
    return 0;
  }
LABEL_74:
  if (*((_DWORD *)this + 197) && *((_DWORD *)this + 196))
    goto LABEL_102;
  *((_QWORD *)this + 98) = 0;
  if ((int)v21 <= 0)
  {
    v31 = 0;
    v32 = 0;
    v33 = *((_DWORD *)this + 195);
    if (v33 <= 1)
      v33 = 1;
    goto LABEL_95;
  }
  v25 = 0;
  v26 = 0;
  v27 = *((_QWORD *)this + 96);
  while (2)
  {
    *(_QWORD *)&v59 = jx_source::get_codestream(*(jx_source **)this, *(_DWORD *)(v27 + v25));
    v58 = jpx_codestream_source::access_dimensions((jx_codestream_source **)&v59, 0);
    size = jp2_dimensions::get_size((jp2_dimensions *)&v58);
    v27 = *((_QWORD *)this + 96);
    v29 = *(_DWORD *)(v27 + v25 + 8) + *(_DWORD *)(v27 + v25 + 16) * HIDWORD(size);
    v30 = *(_DWORD *)(v27 + v25 + 4) + *(_DWORD *)(v27 + v25 + 12) * size;
    if (!v25)
    {
      *((_DWORD *)this + 197) = v29;
      v31 = v29;
LABEL_84:
      *((_DWORD *)this + 196) = v30;
      v32 = v30;
      goto LABEL_85;
    }
    v31 = *((_DWORD *)this + 197);
    if (v29 < v31)
    {
      *((_DWORD *)this + 197) = v29;
      v31 = v29;
    }
    v32 = *((_DWORD *)this + 196);
    if (v30 < v32)
      goto LABEL_84;
LABEL_85:
    ++v26;
    v25 += 20;
    if (v26 < *((int *)this + 191))
      continue;
    break;
  }
  v33 = *((_DWORD *)this + 195);
  if (v33 <= 1)
    v33 = 1;
  if (v31 > 0)
  {
    v34 = (v31 - 1) / v33 + 1;
    goto LABEL_96;
  }
LABEL_95:
  v34 = -(int)(-v31 / v33);
LABEL_96:
  *((_DWORD *)this + 197) = v34;
  v35 = *((_DWORD *)this + 194);
  if (v35 <= 1)
    v35 = 1;
  if (v32 <= 0)
    v36 = -(int)(-v32 / v35);
  else
    v36 = (v32 - 1) / v35 + 1;
  *((_DWORD *)this + 196) = v36;
LABEL_102:
  v37 = (jx_layer_source *)((char *)this + 648);
  if (*((_BYTE *)this + 648))
  {
LABEL_103:
    if (*((_DWORD *)this + 153))
      goto LABEL_108;
    v38 = *(_QWORD *)this;
    if (*(_BYTE *)(*(_QWORD *)this + 600) || (result = jx_source::finish_jp2_header_box(*(jx_source **)this)))
    {
      if (*(_DWORD *)(v38 + 940))
        j2_channels::copy((jx_layer_source *)((char *)this + 608), (j2_channels *)(v38 + 936));
LABEL_108:
      if (*((float *)this + 148) > 0.0)
      {
LABEL_113:
        v41 = (char *)this + 648;
        do
        {
          v42 = *((_DWORD *)v41 + 2);
          v41 = (char *)*((_QWORD *)v41 + 13);
          if (v41)
            v43 = v42 == 0;
          else
            v43 = 0;
        }
        while (v43);
        j2_channels::finalize((unsigned int *)this + 152, v42, 0);
        if (*((int *)this + 191) >= 1)
        {
          v44 = 0;
          v45 = 0;
          do
          {
            v46 = *(_DWORD *)(*((_QWORD *)this + 96) + v44);
            v47 = jx_source::get_codestream(*(jx_source **)this, v46);
            if (!v47)
              jx_layer_source::finish();
            j2_channels::find_cmap_channels((unsigned int *)this + 152, (j2_component_map *)(v47 + 472), v46);
            ++v45;
            v44 += 20;
          }
          while (v45 < *((int *)this + 191));
        }
        if (!j2_channels::all_cmap_channels_found((jx_layer_source *)((char *)this + 608)))
        {
          v61 = 0;
          v59 = 0u;
          v60 = 0u;
          kdu_error::kdu_error((kdu_error *)&v59, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v59 + 16))(&v59, "JP2/JPX source is internally inconsistent.  Either an explicit channel mapping box, or the set of channels implicitly identified by a colour space box, cannot all be associated with available code-stream image components.");
          kdu_error::~kdu_error((kdu_error *)&v59);
        }
        do
        {
          j2_colour::finalize(v37, (jx_layer_source *)((char *)this + 608));
          v37 = (j2_colour *)*((_QWORD *)v37 + 13);
        }
        while (v37);
        result = 1;
        *((_BYTE *)this + 12) = 1;
      }
      else
      {
        v39 = *(_QWORD *)this;
        if (*(_BYTE *)(*(_QWORD *)this + 600) || (result = jx_source::finish_jp2_header_box(*(jx_source **)this)))
        {
          v40 = *(float *)(v39 + 1088);
          if (v40 > 0.0)
          {
            *((float *)this + 148) = v40;
            *((_DWORD *)this + 149) = *(_DWORD *)(v39 + 1092);
            *((_QWORD *)this + 75) = *(_QWORD *)(v39 + 1096);
          }
          goto LABEL_113;
        }
      }
    }
  }
  else
  {
    v48 = *(_QWORD *)this;
    if (*(_BYTE *)(*(_QWORD *)this + 600) || (result = jx_source::finish_jp2_header_box(*(jx_source **)this)))
    {
      v49 = (j2_colour *)(v48 + 976);
      v50 = (jx_layer_source *)((char *)this + 648);
      do
      {
        if (!*(_BYTE *)v49)
          break;
        if (*(_BYTE *)v50)
        {
          v51 = (j2_colour *)operator new();
          j2_colour::j2_colour(v51);
          *((_QWORD *)v50 + 13) = v51;
          v50 = v51;
        }
        else
        {
          v51 = v50;
        }
        j2_colour::copy(v51, v49);
        v49 = (j2_colour *)*((_QWORD *)v49 + 13);
      }
      while (v49);
      goto LABEL_103;
    }
  }
  return result;
}

void sub_187F855B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A0C40BA7D9750);
  _Unwind_Resume(a1);
}

uint64_t jx_metanode::load_recursive(uint64_t this)
{
  uint64_t v1;
  jx_metanode *i;

  v1 = this;
  if (*(_BYTE *)(this + 14) && *(_QWORD *)(this + 24) && (!*(_BYTE *)(this + 12) || !*(_BYTE *)(this + 13)))
    this = jx_metanode::finish_reading((jx_metanode *)this);
  for (i = *(jx_metanode **)(v1 + 64); i; i = (jx_metanode *)*((_QWORD *)i + 10))
  {
    if (*(_DWORD *)(v1 + 52) == *(_DWORD *)(v1 + 48))
      break;
    this = jx_metanode::load_recursive(i);
  }
  return this;
}

uint64_t jpx_metanode::get_num_regions(jpx_metanode *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (!*(_QWORD *)this || *(_BYTE *)(v1 + 15) != 2)
    return 0;
  if (!*(_BYTE *)(v1 + 12))
    jpx_metanode::get_num_regions();
  return **(unsigned int **)(v1 + 16);
}

uint64_t jpx_metanode::get_regions(jpx_metanode *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this && *(_BYTE *)(v1 + 15) == 2)
    return *(_QWORD *)(*(_QWORD *)(v1 + 16) + 32);
  else
    return 0;
}

uint64_t jpx_metanode::get_bounding_box(jpx_metanode *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)this;
  if (*(_QWORD *)this && *(_BYTE *)(v1 + 15) == 2 && (v2 = *(_QWORD *)(v1 + 16), *(int *)v2 >= 1))
    return *(_QWORD *)(v2 + 8);
  else
    return 0;
}

uint64_t jx_source::get_codestream(jx_source *this, int a2)
{
  uint64_t result;

  while (*((_DWORD *)this + 5) <= a2 && (jx_source::parse_next_top_level_box(this, 0) & 1) != 0)
    ;
  result = *((_QWORD *)this + 138);
  if (a2 >= 1 && result)
  {
    do
    {
      result = *(_QWORD *)(result + 856);
      if (a2 < 2)
        break;
      --a2;
    }
    while (result);
  }
  return result;
}

uint64_t jx_source::get_compositing_layer(jx_source *this, int a2)
{
  uint64_t result;

  while (*((_DWORD *)this + 6) <= a2 && (jx_source::parse_next_top_level_box(this, 0) & 1) != 0)
    ;
  result = *((_QWORD *)this + 139);
  if (a2 >= 1 && result)
  {
    do
    {
      result = *(_QWORD *)(result + 800);
      if (a2 < 2)
        break;
      --a2;
    }
    while (result);
  }
  return result;
}

uint64_t jx_roigroup::delete_child(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  jx_roigroup *v7;
  uint64_t v8;
  uint64_t i;
  _DWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;

  if ((int)a2 > 7 || (a2 & 0x8000000080000000) != 0 || (v2 = HIDWORD(a2), SHIDWORD(a2) > 7))
LABEL_19:
    jx_roigroup::delete_child();
  v3 = result;
  while (1)
  {
    v4 = v2 + 8 * a2;
    v5 = v3 + 128;
    v6 = v4;
    if (*(_DWORD *)(v3 + 16))
      break;
    if (*(_QWORD *)(v5 + 24 * v4))
      jx_roigroup::delete_child();
    for (i = 128; i != 1664; i += 24)
    {
      if (*(_QWORD *)(v3 + i))
        return result;
    }
LABEL_15:
    v10 = *(_DWORD **)(v3 + 8);
    if (!v10)
    {
      v11 = *(_QWORD *)v3 + 8 * *(int *)(v3 + 20);
      v13 = *(_QWORD *)(v11 + 80);
      v12 = (_QWORD *)(v11 + 80);
      if (v13 == v3)
      {
        *v12 = 0;
        jx_roigroup::~jx_roigroup((jx_roigroup *)v3);
        JUMPOUT(0x18D761C30);
      }
      jx_roigroup::delete_child();
    }
    LODWORD(v2) = (*(_DWORD *)(v3 + 28) - v10[7]) / v10[11];
    LODWORD(a2) = (*(_DWORD *)(v3 + 24) - v10[6]) / v10[10];
    if ((a2 | v2) >= 8)
      jx_roigroup::delete_child();
    if (*(_QWORD *)&v10[2 * (v2 + 8 * a2) + 32] != v3)
      jx_roigroup::delete_child();
    v3 = *(_QWORD *)(v3 + 8);
    if ((a2 & 0x80000000) != 0)
      goto LABEL_19;
  }
  v7 = *(jx_roigroup **)(v5 + 8 * v4);
  if (!v7)
    jx_roigroup::delete_child();
  jx_roigroup::~jx_roigroup(v7);
  result = MEMORY[0x18D761C30]();
  v8 = 0;
  *(_QWORD *)(v5 + 8 * v6) = 0;
  while (!*(_QWORD *)(v5 + v8))
  {
    v8 += 8;
    if (v8 == 512)
      goto LABEL_15;
  }
  return result;
}

void jx_roigroup::~jx_roigroup(jx_roigroup *this)
{
  jx_roigroup **v2;
  unsigned int i;

  if (*((_DWORD *)this + 4))
  {
    v2 = (jx_roigroup **)((char *)this + 128);
    for (i = 65; i > 1; --i)
    {
      if (*v2)
      {
        jx_roigroup::~jx_roigroup(*v2);
        MEMORY[0x18D761C30]();
      }
      ++v2;
    }
  }
  jp2_output_box::~jp2_output_box((jx_roigroup *)((char *)this + 48));
}

void jx_meta_manager::jx_meta_manager(jx_meta_manager *this)
{
  void *v2;

  jp2_output_box::jp2_output_box((jx_meta_manager *)((char *)this + 344));
  *((_QWORD *)this + 53) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_QWORD *)this + 42) = 0;
  *((_QWORD *)this + 54) = 0x600000006;
  v2 = (void *)operator new[]();
  *((_QWORD *)this + 55) = v2;
  qmemcpy(v2, " lbl lmxi2pjtslndiordiuu", 24);
}

void sub_187F85A80(_Unwind_Exception *a1)
{
  jp2_output_box *v1;

  jp2_output_box::~jp2_output_box(v1);
  _Unwind_Resume(a1);
}

void jx_meta_manager::~jx_meta_manager(jx_meta_manager *this)
{
  jx_metanode *v2;
  uint64_t i;
  jx_roigroup *v4;
  uint64_t v5;

  v2 = (jx_metanode *)*((_QWORD *)this + 3);
  if (v2)
  {
    jx_metanode::~jx_metanode(v2);
    MEMORY[0x18D761C30]();
  }
  *((_QWORD *)this + 3) = 0;
  for (i = 80; i != 336; i += 8)
  {
    v4 = *(jx_roigroup **)((char *)this + i);
    if (v4)
    {
      jx_roigroup::~jx_roigroup(v4);
      MEMORY[0x18D761C30]();
    }
  }
  v5 = *((_QWORD *)this + 55);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C8052888210);
  jp2_output_box::~jp2_output_box((jx_meta_manager *)((char *)this + 344));
}

BOOL jpx_meta_manager::load_matches(jpx_meta_manager *this, int a2, int *a3, int a4, int *a5)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v10;
  int v11;
  jx_codestream_source *codestream;
  int v13;
  jx_layer_source *compositing_layer;

  LODWORD(v6) = a4;
  LODWORD(v8) = a2;
  v10 = *(_QWORD *)(*(_QWORD *)this + 336);
  while ((jx_source::parse_next_top_level_box(*(jx_source **)(*(_QWORD *)this + 8), 0) & 1) != 0)
    ;
  if ((int)v8 >= 1)
  {
    v8 = v8;
    do
    {
      v11 = *a3++;
      codestream = (jx_codestream_source *)jx_source::get_codestream(*(jx_source **)(*(_QWORD *)this + 8), v11);
      if (codestream)
        jx_codestream_source::finish(codestream, 0);
      --v8;
    }
    while (v8);
  }
  if ((int)v6 >= 1)
  {
    v6 = v6;
    do
    {
      v13 = *a5++;
      compositing_layer = (jx_layer_source *)jx_source::get_compositing_layer(*(jx_source **)(*(_QWORD *)this + 8), v13);
      if (compositing_layer)
        jx_layer_source::finish(compositing_layer);
      --v6;
    }
    while (v6);
  }
  jx_metanode::load_recursive(*(_QWORD *)(*(_QWORD *)this + 24));
  return v10 != *(_QWORD *)(*(_QWORD *)this + 336);
}

uint64_t jpx_meta_manager::enumerate_matches(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v13;
  int *v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  unsigned int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  int *v37;
  int v38;
  int v39;
  int v40;
  _DWORD *v41;
  int v42;
  int v43;
  int *v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _BOOL4 v53;
  uint64_t v54;
  unsigned int *v55;
  uint64_t v56;
  uint64_t v57;
  BOOL v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  _QWORD v67[2];

  v67[0] = a6;
  v67[1] = a7;
  v9 = *a1;
  if (!*a1)
    return 0;
  v10 = a2;
  v11 = __OFSUB__(HIDWORD(a7), 1);
  if (SHIDWORD(a7) >= 1)
  {
    v11 = __OFSUB__((_DWORD)a7, 1);
    if ((int)a7 >= 1)
    {
      if (a2)
      {
        v13 = *(_QWORD *)(a2 + 96);
        v14 = *(int **)(v13 + 16);
        v15 = -1431655765 * ((unint64_t)(v13 - (_QWORD)v14 - 128) >> 3);
        v11 = __OFSUB__(v15, 64);
        if (v15 >= 0x40)
          jpx_meta_manager::enumerate_matches();
        v16 = v14[5];
        v17 = v16 + 1;
        v18 = v15 >> 3;
        v19 = v15 - 8 * v18;
        v20 = HIDWORD(a6) + (-8 << v16) + 1;
        v21 = *(_QWORD *)(a2 + 104);
      }
      else
      {
        v19 = 0;
        v18 = 0;
        v20 = 0;
        v14 = 0;
        v17 = 0;
        v21 = 0;
      }
      v32 = HIDWORD(a7) + HIDWORD(a6);
      v33 = a7 + a6;
      if ((int)(a4 & a3) < 0 != v11)
        v34 = a5;
      else
        v34 = 1;
LABEL_49:
      v35 = v17;
      v36 = v14;
      v10 = v21;
      while (1)
      {
        if (!v14 && v35 > 31)
          return v10;
        if (v10)
          break;
        if (v14)
        {
          if (v19 <= 6 && v14[7] + v14[11] * (v19 + 1) < v32)
          {
            ++v19;
            goto LABEL_78;
          }
          if (v18 > 6 || v14[6] + v14[10] * (v18 + 1) >= v33)
          {
            v14 = 0;
            v21 = 0;
            v41 = (_DWORD *)*((_QWORD *)v36 + 1);
            v17 = v35;
            if (v41)
            {
              v19 = (v36[7] - v41[7]) / v41[11];
              if (v19 > 7
                || (v18 = (v36[6] - v41[6]) / v41[10], v18 < 0)
                || (v21 = 0,
                    v20 = HIDWORD(v67[0]) + (-8 << v41[5]) + 1,
                    v14 = (int *)*((_QWORD *)v36 + 1),
                    v17 = v35,
                    v18 >= 8))
              {
                jpx_meta_manager::enumerate_matches();
              }
            }
            goto LABEL_49;
          }
          v40 = v20 - v14[7];
          if (v40 < 0)
          {
            v19 = 0;
            ++v18;
LABEL_78:
            v37 = v14;
            v17 = v35;
          }
          else
          {
            ++v18;
            v37 = v14;
            v17 = v35;
            v19 = v40 / v14[11];
          }
LABEL_79:
          v43 = v19 + 8 * v18;
          if (v37[4] < 1)
          {
            v14 = v37;
          }
          else
          {
            v21 = 0;
            v44 = *(int **)&v37[2 * v43 + 32];
            v14 = v37;
            if (!v44)
              goto LABEL_49;
            while (1)
            {
              v14 = v44;
              v45 = (-8 << v44[5]) | 1;
              v20 = v45 + HIDWORD(v67[0]);
              v46 = v45 + HIDWORD(v67[0]) - v44[7];
              if (v46 < 0)
                v19 = 0;
              else
                v19 = v46 / v44[11];
              v47 = v45 + LODWORD(v67[0]) - v44[6];
              if (v47 < 0)
                v18 = 0;
              else
                v18 = v47 / v44[10];
              if (v19 > 7 || v18 >= 8)
                jpx_meta_manager::enumerate_matches();
              v43 = v19 + 8 * v18;
              if (v14[4] <= 0)
                break;
              v44 = *(int **)&v14[2 * v43 + 32];
              if (!v44)
              {
                v21 = 0;
                goto LABEL_49;
              }
            }
            v37 = v14;
          }
          v21 = 0;
          v10 = *(_QWORD *)&v37[6 * v43 + 32];
          if (!v10)
            goto LABEL_49;
LABEL_95:
          if (*(_BYTE *)(v10 + 15) != 2 || (v48 = *(_QWORD *)(v10 + 16)) == 0)
            jpx_meta_manager::enumerate_matches();
          if (*(_DWORD *)(v48 + 40) < (int)a8)
            goto LABEL_126;
          v65 = v20;
          v66 = a5;
          v49 = a8;
          v50 = a4;
          v51 = a3;
          v63 = v18;
          v64 = v19;
          v52 = v34;
          v53 = kdu_dims::intersects((_DWORD *)(v48 + 8), v67);
          v34 = v52;
          v18 = v63;
          v19 = v64;
          a3 = v51;
          a4 = v50;
          a8 = v49;
          v20 = v65;
          a5 = v66;
          if (!v53)
            goto LABEL_126;
          if ((_DWORD)v34)
          {
            v54 = *(_QWORD *)(v10 + 56);
            if (!v54)
              goto LABEL_126;
            while (1)
            {
              if (*(_BYTE *)(v54 + 15) == 1)
              {
                v55 = *(unsigned int **)(v54 + 16);
                if (v55)
                  break;
              }
              v54 = *(_QWORD *)(v54 + 56);
              if (!v54)
                goto LABEL_126;
            }
            if (v66 && !*((_BYTE *)v55 + 48))
              goto LABEL_126;
            if ((v51 & 0x80000000) != 0)
            {
              v58 = 1;
            }
            else
            {
              v56 = *v55;
              if ((int)v56 < 1)
              {
                LODWORD(v57) = 0;
              }
              else
              {
                v57 = 0;
                while (*(_DWORD *)(*((_QWORD *)v55 + 2) + 4 * v57) != (_DWORD)v51)
                {
                  if (v56 == ++v57)
                  {
                    LODWORD(v57) = *v55;
                    break;
                  }
                }
              }
              v58 = (_DWORD)v57 != (_DWORD)v56;
            }
            if ((v50 & 0x80000000) == 0)
            {
              v59 = v55[6];
              if ((int)v59 < 1)
              {
                LODWORD(v60) = 0;
              }
              else
              {
                v60 = 0;
                v61 = *((_QWORD *)v55 + 5);
                while (*(_DWORD *)(v61 + 4 * v60) != (_DWORD)v50)
                {
                  if (v59 == ++v60)
                  {
                    LODWORD(v60) = v59;
                    break;
                  }
                }
              }
              if ((_DWORD)v60 == (_DWORD)v59)
                v58 = 0;
            }
            if (!v58)
            {
LABEL_126:
              v21 = *(_QWORD *)(v10 + 104);
              goto LABEL_49;
            }
          }
          return v10;
        }
        v10 = 0;
        v17 = v35 + 1;
        v37 = *(int **)(*a1 + 8 * v35++ + 80);
        if (v37)
        {
          v38 = (-8 << v37[5]) | 1;
          v20 = v38 + HIDWORD(v67[0]);
          v39 = v38 + HIDWORD(v67[0]) - v37[7];
          if (v39 < 0)
            v19 = 0;
          else
            v19 = v39 / v37[11];
          v42 = v38 + LODWORD(v67[0]) - v37[6];
          if (v42 < 0)
            v18 = 0;
          else
            v18 = v42 / v37[10];
          v14 = 0;
          v21 = 0;
          if (v19 > 7)
            goto LABEL_49;
          v21 = 0;
          if (v18 > 7)
            goto LABEL_49;
          goto LABEL_79;
        }
      }
      v17 = v35;
      goto LABEL_95;
    }
  }
  if ((int)(a4 & a3) < 0 == v11 || a5)
  {
    v23 = (uint64_t *)(v9 + 56);
    while (1)
    {
      while (1)
      {
        while (1)
        {
LABEL_15:
          v24 = v23;
          if (v10)
          {
            if (*(uint64_t **)(v10 + 96) != v23)
              jpx_meta_manager::enumerate_matches();
            v24 = (uint64_t *)(v10 + 104);
          }
          v10 = *v24;
          if (!*v24)
            return v10;
          if (*(_BYTE *)(v10 + 15) == 1)
          {
            v25 = *(unsigned int **)(v10 + 16);
            if (v25)
              break;
          }
        }
        if (a9)
          break;
LABEL_26:
        if (!a5 || *((_BYTE *)v25 + 48))
        {
          if ((a3 & 0x80000000) != 0)
            goto LABEL_36;
          v27 = *v25;
          if ((int)v27 < 1)
          {
            LODWORD(v28) = 0;
          }
          else
          {
            v28 = 0;
            while (*(_DWORD *)(*((_QWORD *)v25 + 2) + 4 * v28) != (_DWORD)a3)
            {
              if (v27 == ++v28)
                goto LABEL_15;
            }
          }
          if ((_DWORD)v28 != (_DWORD)v27)
          {
LABEL_36:
            if ((a4 & 0x80000000) != 0)
              return v10;
            v29 = v25[6];
            if ((int)v29 < 1)
            {
              LODWORD(v30) = 0;
            }
            else
            {
              v30 = 0;
              v31 = *((_QWORD *)v25 + 5);
              while (*(_DWORD *)(v31 + 4 * v30) != (_DWORD)a4)
              {
                if (v29 == ++v30)
                  goto LABEL_15;
              }
            }
            if ((_DWORD)v30 != (_DWORD)v29)
              return v10;
          }
        }
      }
      v26 = *(_QWORD *)(v10 + 64);
      if (v26)
      {
        while (*(_BYTE *)(v26 + 15) == 2)
        {
          v26 = *(_QWORD *)(v26 + 104);
          if (!v26)
            goto LABEL_15;
        }
        goto LABEL_26;
      }
    }
  }
  if (a2)
  {
    if (*(_QWORD *)(a2 + 96) != v9 + 32)
      jpx_meta_manager::enumerate_matches();
    v22 = a2 + 104;
  }
  else
  {
    v22 = v9 + 32;
  }
  return *(_QWORD *)v22;
}

uint64_t jx_registration::init(jx_registration *this, jp2_input_box *a2)
{
  _BOOL4 v4;
  int v5;
  _BOOL4 v6;
  BOOL v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  _DWORD *v20;
  int v21;
  _OWORD v23[2];
  uint64_t v24;
  __int16 v25;
  __int16 v26;
  unsigned __int16 v27;
  unsigned __int16 v28[2];
  char v29[16];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)this + 1))
  {
    *(_QWORD *)&v31 = 0;
    *(_OWORD *)v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)v29, "Error in Kakadu File Format Support:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, "JPX data source appears to contain multiple JPX Codestream Registration (creg) boxes within the same compositing layer header (jplh) box.");
    kdu_error::~kdu_error((kdu_error *)v29);
  }
  *((_QWORD *)this + 3) = 0;
  *(_DWORD *)v28 = 0;
  if (!jp2_input_box::read(a2, &v28[1])
    || ((v4 = jp2_input_box::read(a2, v28), (v5 = v28[1]) != 0) ? (v6 = v4) : (v6 = 0),
        v6 ? (v7 = v28[0] == 0) : (v7 = 1),
        v7))
  {
    *(_QWORD *)&v31 = 0;
    *(_OWORD *)v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)v29, "Error in Kakadu File Format Support:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, "Malformed Codestream Registration (creg) box found in JPX data source.  Insufficient or illegal fields encountered.");
    kdu_error::~kdu_error((kdu_error *)v29);
  }
  *((_DWORD *)this + 4) = v28[0];
  *((_DWORD *)this + 5) = v5;
  if (*((_BYTE *)a2 + 125)
    || (v8 = *((_DWORD *)a2 + 44) + *((_DWORD *)a2 + 22) - *((_DWORD *)a2 + 34),
        HIDWORD(v9) = -1431655765 * v8 + 715827882,
        LODWORD(v9) = HIDWORD(v9),
        (v9 >> 1) >= 0x2AAAAAAB))
  {
    *(_QWORD *)&v31 = 0;
    *(_OWORD *)v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)v29, "Error in Kakadu File Format Support:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, "Malformed Codestream Registration (creg) box found in JPX data source.  Box size does not seem to be equal to 4+6k where k must be the number of referenced codestreams.");
    kdu_error::~kdu_error((kdu_error *)v29);
  }
  if (v8 < 0)
  {
    *(_QWORD *)&v31 = 0;
    *(_OWORD *)v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)v29, "Error in Kakadu File Format Support:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, "Malformed Codestream Registration.");
    kdu_error::~kdu_error((kdu_error *)v29);
  }
  *(_DWORD *)this = v8 / 6;
  *((_DWORD *)this + 1) = v8 / 6;
  v10 = v8 / 6;
  is_mul_ok(v10, 0x14uLL);
  v11 = operator new[]();
  if ((v8 + 5) >= 0xB)
  {
    v12 = (_QWORD *)(v11 + 4);
    v13 = 20 * v10;
    do
    {
      *v12 = 0;
      v12[1] = 0;
      v12 = (_QWORD *)((char *)v12 + 20);
      v13 -= 20;
    }
    while (v13);
  }
  *((_QWORD *)this + 1) = v11;
  if (*((int *)this + 1) >= 1)
  {
    v14 = 0;
    v15 = 0;
    do
    {
      v16 = *((_QWORD *)this + 1);
      v27 = 0;
      v26 = 0;
      v25 = 0;
      if (!jp2_input_box::read(a2, &v27)
        || (*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v26 + 1, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v26, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)a2 + 32))(a2, (char *)&v25 + 1, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(_QWORD *)a2 + 32))(a2, &v25, 1) != 1)
      {
        break;
      }
      if (!HIBYTE(v26) || !(_BYTE)v26)
      {
        v24 = 0;
        memset(v23, 0, sizeof(v23));
        kdu_error::kdu_error((kdu_error *)v23, "Error in Kakadu File Format Support:\n");
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v23[0] + 16))(v23, "Malformed Codestream Registration (creg) box found in JPX data source.  Illegal (zero-valued) resolution parameters found for codestream ");
        v32 = 0u;
        v33 = 0u;
        v30 = 0u;
        v31 = 0u;
        *(_OWORD *)v29 = 0u;
        if (BYTE8(v23[0]))
          sprintf(v29, "%x");
        else
          sprintf(v29, "%u");
        (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v23[0] + 16))(v23, v29);
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v23[0] + 16))(v23, ".");
        kdu_error::~kdu_error((kdu_error *)v23);
      }
      v17 = HIBYTE(v25);
      if (*((_DWORD *)this + 5) > (int)HIBYTE(v25))
      {
        v18 = v25;
        if (*((_DWORD *)this + 4) > (int)v25)
          continue;
      }
      *(_QWORD *)&v31 = 0;
      *(_OWORD *)v29 = 0u;
      v30 = 0u;
      kdu_error::kdu_error((kdu_error *)v29, "Error in Kakadu File Format Support:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v29 + 16))(v29, "Malformed Codestream Registration (creg) box found in JPX data source.  Alignment offsets must be strictly less than the denominator (point density) parameters, as explained in the JPX standard (accounting for corrigenda).");
      kdu_error::~kdu_error((kdu_error *)v29);
      v19 = v27;
      v20 = (_DWORD *)(v16 + v14);
      v21 = HIBYTE(v26);
      v20[3] = v26;
      v20[4] = v21;
      v20[1] = v18;
      v20[2] = v17;
      *v20 = v19;
      ++v15;
      v14 += 20;
    }
    while (v15 < *((int *)this + 1));
  }
  return (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
}

void sub_187F8667C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F86688(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Unwind_Exception *v19;

  _Unwind_Resume(v19);
}

double jx_registration::finalize(jx_registration *this, int a2)
{
  uint64_t v4;
  double result;

  if (!*((_QWORD *)this + 1))
  {
    *(_QWORD *)this = 0x100000001;
    v4 = operator new[]();
    *(_DWORD *)v4 = a2;
    result = 0.0;
    *(_OWORD *)(v4 + 4) = xmmword_18820EDC0;
    *((_QWORD *)this + 1) = v4;
    *((_QWORD *)this + 2) = 0x100000001;
  }
  return result;
}

uint64_t jx_codestream_source::donate_chdr_box(jx_codestream_source *this, jp2_input_box *a2)
{
  char *v4;
  uint64_t v5;
  _DWORD *exception;

  if (*((_BYTE *)this + 23))
    return (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
  v4 = (char *)this + 512;
  v5 = *((_QWORD *)this + 65);
  if (v5 < 0)
  {
    if (*(_QWORD *)v4)
      goto LABEL_15;
  }
  else if (v5 || *((_DWORD *)this + 132))
  {
LABEL_15:
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  if (*((_BYTE *)this + 150) || *((_BYTE *)this + 334))
    goto LABEL_15;
  if (v5 < 0)
  {
    if (!*(_QWORD *)v4)
      goto LABEL_12;
LABEL_14:
    jx_codestream_source::donate_chdr_box();
  }
  if (*((_DWORD *)this + 132))
    goto LABEL_14;
LABEL_12:
  jp2_input_box::transplant((jx_codestream_source *)((char *)this + 24), a2);
  *(_OWORD *)v4 = *((_OWORD *)this + 2);
  *((_DWORD *)v4 + 4) = *((_DWORD *)this + 12);
  return jx_codestream_source::finish(this, 0);
}

