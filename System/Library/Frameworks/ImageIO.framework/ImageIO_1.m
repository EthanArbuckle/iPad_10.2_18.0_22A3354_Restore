IIO_Reader *CreateReader_AppleJPEG(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierJPEG, ".jpg.jpeg.jpe.jfif.jps.", 1246774599, 24, 0);
  *(_QWORD *)v0 = &off_1E1BB1FE0;
  return v0;
}

void sub_187EA1C30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void IIO_Reader::IIO_Reader(IIO_Reader *this, const __CFString *const *a2, const char *a3, int a4, uint64_t a5, uint64_t a6)
{
  *(_QWORD *)this = &off_1E1BAB4F8;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *((_DWORD *)this + 6) = a4;
  *((_QWORD *)this + 4) = a5;
  *((_QWORD *)this + 5) = a6;
  *((_BYTE *)this + 48) = 1;
}

IIO_Writer *CreateWriter_TIFF(void)
{
  IIO_Writer *v0;

  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierTIFF, 1414088262, -1, 185061183);
  *(_QWORD *)v0 = off_1E1BB09D8;
  return v0;
}

void sub_187EA1CDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_KTX2(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_ktx2, 1263818802);
  return v0;
}

void sub_187EA1D4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_ICNS(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_icns, 1229147731);
  return v0;
}

void sub_187EA1DBC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

IIO_Writer *CreateWriter_HEIC(void)
{
  IIO_Writer *v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_HEVC_EncodingSupported)
    return 0;
  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierHEIC, 1212500291, -1, 688805893);
  *(_QWORD *)v0 = &off_1E1BB0988;
  return v0;
}

void sub_187EA1E60(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

IIO_Writer *CreateWriter_AVCI(void)
{
  IIO_Writer *v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_AVCI_EncodingSupported)
    return 0;
  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierHEIC, 1212500291, 1, 688785413);
  *(_QWORD *)v0 = &off_1E1BB0988;
  *((_QWORD *)v0 + 2) = CFSTR("public.avci");
  return v0;
}

void sub_187EA1F14(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_PVR(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_pvr, 1347834400);
  return v0;
}

void sub_187EA1F84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_PSD(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_psd, 1347634208);
  return v0;
}

void sub_187EA1FF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_PNG(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_png, 1347307296);
  return v0;
}

void sub_187EA2064(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_PBM(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_pbm, 1346522400);
  return v0;
}

void sub_187EA20D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_JP2(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_jp2, 1246769696);
  return v0;
}

void sub_187EA2144(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

IIO_Writer *CreateWriter_ICO(void)
{
  IIO_Writer *v0;

  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierICO, 1229147936, 6, 150996993);
  *(_QWORD *)v0 = off_1E1BAF708;
  return v0;
}

void sub_187EA21CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

IIO_Writer *CreateWriter_GIF(void)
{
  IIO_Writer *v0;

  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierGIF, 1195984416, -1, 671352853);
  *(_QWORD *)v0 = off_1E1BAF6B8;
  return v0;
}

void sub_187EA2254(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_EXR(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_exr, 1163416096);
  return v0;
}

void sub_187EA22C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

uint64_t IIOGeneric_Writer::IIOGeneric_Writer(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  v4 = *a2;
  v5 = a2[9];
  v6 = *((_DWORD *)a2 + 20);
  *(_DWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = v5;
  *(_DWORD *)(a1 + 40) = v6;
  *(_BYTE *)(a1 + 44) = 1;
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_1E1BB1060;
  v7 = a2[11];
  *(_QWORD *)(a1 + 48) = v7;
  if (!v7)
    LogError("IIOGeneric_Writer", 190, "*** ERROR: IIOGeneric_Writer::IIOGeneric_Writer called with invalid pluginInfo (writeProc is nil)");
  return a1;
}

IIO_Writer *CreateWriter_BMP(void)
{
  IIO_Writer *v0;

  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierBMP, 1112363040, 1, 150997009);
  *(_QWORD *)v0 = off_1E1BAF668;
  return v0;
}

void sub_187EA23C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_ATX(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_atx, 1096046624);
  return v0;
}

void sub_187EA2434(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

IIO_Writer *CreateWriter_BC(void)
{
  IIO_Writer *v0;

  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierBC, 1111695392, 1, 704727045);
  *(_QWORD *)v0 = off_1E1BAD168;
  return v0;
}

void sub_187EA24BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void ChopUpSingleUncompressedStrip(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  BOOL v17;

  if (_TIFFGetStrileOffsetOrByteCountValue(a1, 0) || !*(_DWORD *)(a1 + 12))
  {
    v2 = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
    if (*(_WORD *)(a1 + 170) != 1)
      ChopUpSingleUncompressedStrip_cold_1();
    v9 = v2;
    if (*(_WORD *)(a1 + 122) != 6 || (*(_BYTE *)(a1 + 17) & 0x40) != 0)
      v10 = 1;
    else
      v10 = *(unsigned __int16 *)(a1 + 338);
    v11 = TIFFVTileSize64(a1, v10, v3, v4, v5, v6, v7, v8);
    v12 = v11;
    if (v11 <= 0x2000)
    {
      if (!v11)
        return;
      v13 = 0x2000u / (unsigned __int16)v11;
      v10 = (v10 * v13);
      v12 = v11 * v13;
    }
    if ((_DWORD)v10)
    {
      if (v10 < *(_DWORD *)(a1 + 132))
      {
        v14 = *(_DWORD *)(a1 + 92);
        if (v14 < -(int)v10)
        {
          v15 = v10 + v14 - 1;
          if (v10 <= v15)
          {
            v16 = v15 / v10;
            v17 = v15 / v10 >= 0xF4241 && *(_DWORD *)(a1 + 12) == 0;
            if (!v17
              || v9 < (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200))
              && v12 <= ((*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200)) - v9) / (v16 - 1))
            {
              allocChoppedUpStripArrays(a1, v16, v12, v10);
            }
          }
        }
      }
    }
  }
}

unint64_t TIFFVTileSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  int v41;

  if (!*(_DWORD *)(a1 + 104) || !*(_DWORD *)(a1 + 100) || !*(_DWORD *)(a1 + 108))
    return 0;
  v9 = a2;
  if (*(_WORD *)(a1 + 170) != 1
    || *(_WORD *)(a1 + 122) != 6
    || *(_WORD *)(a1 + 130) != 3
    || (*(_BYTE *)(a1 + 17) & 0x40) != 0)
  {
    v17 = a2;
    v18 = _cg_TIFFTileRowSize64(a1, a2, a3, a4, a5, a6, a7, a8);
    return _TIFFMultiply64(a1, v17, v18, "TIFFVTileSize64", v19, v20, v21, v22);
  }
  v41 = 0;
  _cg_TIFFGetFieldDefaulted(a1, 530, a3, a4, a5, a6, a7, a8, (uint64_t)&v41);
  if ((unsigned __int16)v41 > 4u || ((1 << v41) & 0x16) == 0 || HIWORD(v41) > 4u || ((1 << SBYTE2(v41)) & 0x16) == 0)
  {
    TIFFErrorExtR(a1, "TIFFVTileSize64", "Invalid YCbCr subsampling (%dx%d)", v10, v11, v12, v13, v14, v41);
    return 0;
  }
  v15 = *(_DWORD *)(a1 + 100);
  if (v15 >= -(unsigned __int16)v41)
    v16 = 0;
  else
    v16 = ((unsigned __int16)v41 + v15 - 1) / (unsigned __int16)v41;
  if (-HIWORD(v41) > v9)
    v24 = (v9 + HIWORD(v41) - 1) / HIWORD(v41);
  else
    v24 = 0;
  v25 = _TIFFMultiply64(a1, v16, (unsigned __int16)(HIWORD(v41) * v41 + 2), "TIFFVTileSize64", v11, v12, v13, v14);
  v30 = _TIFFMultiply64(a1, v25, *(unsigned __int16 *)(a1 + 116), "TIFFVTileSize64", v26, v27, v28, v29);
  v35 = _TIFFMultiply64(a1, v25, *(unsigned __int16 *)(a1 + 116), "TIFFVTileSize64", v31, v32, v33, v34);
  if ((v30 & 7) != 0)
    v40 = (v35 >> 3) + 1;
  else
    v40 = v35 >> 3;
  return _TIFFMultiply64(a1, v40, v24, "TIFFVTileSize64", v36, v37, v38, v39);
}

uint64_t _cg_TIFFTileRowSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t result;
  char *v12;
  char v13;

  if (!*(_DWORD *)(a1 + 104))
  {
    v12 = "Tile length is zero";
    goto LABEL_14;
  }
  v9 = *(unsigned int *)(a1 + 100);
  if (!(_DWORD)v9)
  {
    v12 = "Tile width is zero";
    goto LABEL_14;
  }
  v10 = _TIFFMultiply64(a1, *(unsigned __int16 *)(a1 + 116), v9, "TIFFTileRowSize", a5, a6, a7, a8);
  if (*(_WORD *)(a1 + 170) == 1)
  {
    if (!*(_WORD *)(a1 + 130))
    {
      v12 = "Samples per pixel is zero";
      goto LABEL_14;
    }
    v10 = _TIFFMultiply64(a1, v10, *(unsigned __int16 *)(a1 + 130), "TIFFTileRowSize", a5, a6, a7, a8);
  }
  if ((v10 & 7) != 0)
    result = (v10 >> 3) + 1;
  else
    result = v10 >> 3;
  if (!result)
  {
    v12 = "Computed tile row size is zero";
LABEL_14:
    TIFFErrorExtR(a1, "TIFFTileRowSize64", v12, a4, a5, a6, a7, a8, v13);
    return 0;
  }
  return result;
}

uint64_t TIFFReadPlugin::decodeStripChunky(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v3;
  unint64_t v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t PixelConverter;
  uint64_t v15;
  unsigned int v16;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  float *v24;
  float *v25;
  uint64_t v26;
  size_t v27;
  int v28;
  int v29;
  float *v30;
  float *v31;
  float *v32;
  float *v33;
  float *v34;
  float *v35;
  uint64_t v36;
  int v38;
  uint64_t v39;
  void *v40;
  unsigned int v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;

  v3 = *(_QWORD *)(a1 + 480);
  v4 = *(unsigned int *)(a1 + 472);
  v47 = 0;
  v48 = 0;
  if (!(_DWORD)v4)
    return 4294967246;
  v13 = malloc_type_malloc(v3, 0x589C959AuLL);
  if (*(unsigned __int16 *)(a1 + 456) == 32845)
  {
    PixelConverter = 0;
    goto LABEL_17;
  }
  v47 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  v48 = v15;
  v16 = *(unsigned __int16 *)(a1 + 244);
  if (v16 > *(unsigned __int16 *)(a1 + 308))
    LOWORD(v48) = *(_WORD *)(a1 + 308);
  if (*(_WORD *)(a1 + 274) == 32 && *(_WORD *)(a1 + 272) == 8)
  {
    if (v16 == 3)
    {
      BYTE6(v47) = -1;
      BYTE4(v47) = 0;
      if (*(_BYTE *)(a1 + 405))
        v17 = 2;
      else
        v17 = 5;
LABEL_15:
      BYTE5(v47) = v17;
      goto LABEL_16;
    }
    if (v16 == 4)
    {
      v17 = 2;
      BYTE4(v47) = 2;
      if (!*(_BYTE *)(a1 + 405))
        v17 = 3;
      goto LABEL_15;
    }
  }
LABEL_16:
  PixelConverter = ImageIOPixelConverter::CreatePixelConverter((uint64_t)&v47);
LABEL_17:
  v18 = *(_DWORD *)(a3 + 20);
  if (v18 >= *(_DWORD *)(a3 + 24))
  {
LABEL_51:
    v36 = 0;
    if (!PixelConverter)
      goto LABEL_53;
  }
  else
  {
    v19 = (v3 / v4);
    v39 = a2;
    v40 = v13;
    v44 = PixelConverter;
    v45 = a3;
    v42 = v3;
    v43 = v19;
    v38 = v4;
    while (1)
    {
      v20 = *(_DWORD *)(a1 + 472) ? _cg_TIFFComputeStrip(a2, v18, 0, v8, v9, v10, v11, v12) : 0;
      if (_cg_TIFFReadEncodedStrip(a2, v20, v13, -1, v9, v10, v11, v12) > v3)
        break;
      v21 = v18 + v4;
      v22 = *(_DWORD *)(a3 + 24);
      if (v18 + v4 >= v22)
        v23 = *(_DWORD *)(a3 + 24);
      else
        v23 = v18 + v4;
      v46 = v23;
      if (v18 < v23)
      {
        v41 = v18 + v4;
        v24 = (float *)(*(_QWORD *)a3 + (v18 - *(_DWORD *)(a3 + 20)) * *(_DWORD *)(a3 + 36));
        v25 = (float *)v13;
        do
        {
          if (*(unsigned __int16 *)(a1 + 456) == 32845)
          {
            if (*(_WORD *)(a1 + 240) == 32)
              ConvertLineXYZToRGB<float>(v25, v24, *(_DWORD *)(a3 + 28));
          }
          else
          {
            v26 = *(unsigned __int16 *)(a1 + 244);
            v27 = *(unsigned __int16 *)(a1 + 308);
            if (v26 > v27)
            {
              v28 = *(_DWORD *)(a1 + 228);
              if (v42 >= ((*(unsigned __int16 *)(a1 + 242) + 7) >> 3) * v28)
              {
                v29 = *(unsigned __int16 *)(a1 + 240);
                if (v29 == 32)
                {
                  if (v28)
                  {
                    v32 = v25;
                    v33 = v25;
                    do
                    {
                      memmove(v32, v33, 4 * v27);
                      v33 += v26;
                      v32 += v27;
                      --v28;
                    }
                    while (v28);
                  }
                }
                else if (v29 == 16)
                {
                  if (v28)
                  {
                    v34 = v25;
                    v35 = v25;
                    do
                    {
                      memmove(v34, v35, 2 * v27);
                      v35 = (float *)((char *)v35 + 2 * v26);
                      v34 = (float *)((char *)v34 + 2 * v27);
                      --v28;
                    }
                    while (v28);
                  }
                }
                else if (v29 == 8 && v28)
                {
                  v30 = v25;
                  v31 = v25;
                  do
                  {
                    memmove(v30, v31, v27);
                    v31 = (float *)((char *)v31 + v26);
                    v30 = (float *)((char *)v30 + v27);
                    --v28;
                  }
                  while (v28);
                }
              }
            }
            PixelConverter = v44;
            a3 = v45;
            (*(void (**)(uint64_t, float *, float *, _QWORD))(*(_QWORD *)v44 + 24))(v44, v25, v24, *(unsigned int *)(v45 + 28));
            v19 = v43;
          }
          v24 = (float *)((char *)v24 + *(unsigned int *)(a3 + 36));
          v25 = (float *)((char *)v25 + v19);
          ++v18;
        }
        while (v18 < v46);
        v22 = *(_DWORD *)(a3 + 24);
        a2 = v39;
        v13 = v40;
        v3 = v42;
        LODWORD(v4) = v38;
        v21 = v41;
      }
      v18 = v21;
      if (v21 >= v22)
        goto LABEL_51;
    }
    v36 = 4294967246;
    if (!PixelConverter)
      goto LABEL_53;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)PixelConverter + 8))(PixelConverter);
LABEL_53:
  if (v13)
    free(v13);
  return v36;
}

uint64_t IIOPixelConverterRGB::convertRow(IIOPixelConverterRGB *this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  _QWORD v8[4];
  _QWORD v9[4];

  v4 = *((unsigned __int8 *)this + 37);
  v5 = *((unsigned __int8 *)this + 40);
  if (v5 <= *((unsigned __int8 *)this + 41))
    v5 = *((unsigned __int8 *)this + 41);
  v6 = (*((unsigned __int8 *)this + 53) * a4 * *((unsigned __int8 *)this + 56)) >> 3;
  v9[0] = a2;
  v9[1] = 1;
  v9[2] = a4;
  v9[3] = (v4 * a4 * v5) >> 3;
  v8[0] = a3;
  v8[1] = 1;
  v8[2] = a4;
  v8[3] = v6;
  return (*(uint64_t (**)(IIOPixelConverterRGB *, _QWORD *, _QWORD *))(*(_QWORD *)this + 16))(this, v9, v8);
}

uint64_t IIOPixelConverterRGB::convert(IIOPixelConverterRGB *this, vImage_Buffer *srcs, vImage_Buffer *dests)
{
  vImagePixelCount height;
  vImagePixelCount v7;
  vImagePixelCount width;
  vImagePixelCount v9;
  char *v10;
  char *v11;
  size_t v12;
  size_t rowBytes;
  int v14;
  __int128 v15;
  vImageConverter *v16;
  vImage_Error v17;
  const char *v18;
  int v19;
  vImagePixelCount v20;
  vImagePixelCount v21;
  char *data;
  vImagePixelCount v23;
  size_t v24;
  uint64_t v25;
  vImagePixelCount v26;
  unint64_t v27;
  void *v28;
  vImagePixelCount v29;
  vImagePixelCount v30;
  size_t v31;
  vImage_Error v32;
  vImage_Error v33;
  const char *v34;
  vImage_Error v35;
  vImage_Error v36;
  const char *v37;
  vImage_Error v38;
  vImage_Error v39;
  const char *v40;
  uint64_t v41;
  int v42;
  int v43;
  const char *v44;
  const char *v45;
  vImage_Buffer dest;

  if (*((unsigned __int8 *)this + 40) > *((unsigned __int8 *)this + 41))
  {
    if (*((_BYTE *)this + 36) == 8)
    {
      height = srcs->height;
      if (height)
      {
        v7 = 0;
        width = srcs->width;
        do
        {
          if (width)
          {
            v9 = 0;
            v10 = (char *)dests->data + dests->rowBytes * v7;
            v11 = (char *)srcs->data + srcs->rowBytes * v7;
            v12 = *((unsigned __int8 *)this + 56);
            do
            {
              memcpy(v10, v11, v12);
              v11 += *((unsigned __int8 *)this + 40);
              v12 = *((unsigned __int8 *)this + 56);
              v10 += v12;
              ++v9;
              width = srcs->width;
            }
            while (v9 < width);
            height = srcs->height;
          }
          ++v7;
        }
        while (v7 < height);
      }
    }
    else
    {
      bzero(dests->data, dests->height * dests->rowBytes);
    }
    goto LABEL_60;
  }
  if (*((_BYTE *)this + 73))
  {
    vImagePermuteChannels_ARGB8888(srcs, dests, &gPermuteMap[4 * *((int *)this + 17)], 0);
    goto LABEL_60;
  }
  if (*((unsigned __int8 *)this + 32) == *((unsigned __int8 *)this + 49)
    && *((_DWORD *)this + 9) == *((_DWORD *)this + 13))
  {
    rowBytes = srcs->rowBytes;
    if (rowBytes >= dests->rowBytes)
      rowBytes = dests->rowBytes;
    memcpy(dests->data, srcs->data, rowBytes * srcs->height);
    v14 = *((unsigned __int8 *)this + 65);
    if (v14 == 2)
    {
      v20 = dests->height;
      if (v20)
      {
        LODWORD(v21) = 0;
        data = (char *)dests->data;
        v23 = dests->width;
        v24 = dests->rowBytes;
        do
        {
          if (v23)
          {
            v25 = 0;
            do
            {
              *(_DWORD *)&data[4 * v25] = bswap32(*(_DWORD *)&data[4 * v25]);
              ++v25;
            }
            while (v23 > v25);
          }
          data += v24;
          v21 = (v21 + 1);
        }
        while (v20 > v21);
      }
    }
    else if (v14 == 1)
    {
      v15 = *(_OWORD *)&dests->width;
      *(_OWORD *)&dest.data = *(_OWORD *)&dests->data;
      *(_OWORD *)&dest.width = v15;
      dest.width = v15 * *((unsigned __int8 *)this + 41);
      vImageByteSwap_Planar16U(&dest, &dest, 0x10u);
    }
    goto LABEL_60;
  }
  if (*((_BYTE *)this + 16))
  {
    v16 = (vImageConverter *)*((_QWORD *)this + 1);
    if (v16)
    {
      v17 = iio_vImageConvert_AnyToAny(v16, srcs, dests, 0, 0);
      if (!v17)
        goto LABEL_60;
      v18 = IIO_vImageErrorString(v17);
      _cg_jpeg_mem_term("convert", 1158, "*** vImageConvert_AnyToAny: %s\n", v18);
    }
    _cg_jpeg_mem_term("convert", 1162, "   falling back to own convertAnyToAny [RGB]\n");
    ImageIOPixelConverter::convertAnyToAny(this, srcs, dests);
    goto LABEL_60;
  }
  v19 = *((_DWORD *)this + 9);
  if (v19 > 134744318)
  {
    if (v19 == 134744319)
    {
      if (*((_BYTE *)this + 64))
        vImageConvert_RGB888toBGRA8888(srcs, 0, 0xFFu, dests, 0, 0);
      else
        vImageConvert_RGB888toRGBA8888(srcs, 0, 0xFFu, dests, 0, 0);
    }
    else
    {
      if (v19 != 168430082)
        goto LABEL_60;
      if (*((_DWORD *)this + 13) != 134744072)
        vImageConvert_ARGB2101010ToARGB16U(srcs, dests, 0, 1023, &gPermuteMap[4 * *((int *)this + 17)], 0);
    }
    goto LABEL_54;
  }
  if (v19 != 84215041)
  {
    if (v19 != 84280831)
      goto LABEL_60;
    if (*((_BYTE *)this + 64))
      vImageConvert_RGB565toBGRA8888(0xFFu, srcs, dests, 0);
    else
      vImageConvert_RGB565toRGBA8888(0xFFu, srcs, dests, 0);
LABEL_54:
    *((_DWORD *)this + 17) = 0;
    goto LABEL_60;
  }
  v26 = srcs->height;
  v27 = 3 * srcs->width;
  if (!is_mul_ok(v27, v26))
    return 0;
  v28 = malloc_type_malloc(v27 * v26, 0xE0BDB114uLL);
  v29 = srcs->height;
  v30 = srcs->width;
  dest.data = v28;
  dest.height = v29;
  dest.width = v30;
  dest.rowBytes = 3 * v30;
  if (v28)
  {
    v31 = dests->rowBytes;
    dests->rowBytes = srcs->rowBytes;
    v32 = vImageConvert_RGBA5551toRGB565(srcs, dests, 0);
    if (v32)
    {
      v33 = v32;
      v34 = IIO_vImageErrorString(v32);
      printf("*** vImageConvert_RGBA5551toRGB565: %ld '%s'\n", v33, v34);
    }
    v35 = vImageConvert_RGB565toRGB888(dests, &dest, 0);
    if (v35)
    {
      v36 = v35;
      v37 = IIO_vImageErrorString(v35);
      printf("*** vImageConvert_RGB565toRGB888: %ld '%s'\n", v36, v37);
    }
    dests->rowBytes = v31;
    if (*((_BYTE *)this + 64))
      v38 = vImageConvert_RGB888toBGRA8888(&dest, 0, 0xFFu, dests, 0, 0);
    else
      v38 = vImageConvert_RGB888toRGBA8888(&dest, 0, 0xFFu, dests, 0, 0);
    v39 = v38;
    if (v38)
    {
      v40 = IIO_vImageErrorString(v38);
      printf("*** vImageConvert_RGB888toRGBA8888: %ld '%s'\n", v39, v40);
    }
    free(dest.data);
  }
  *((_DWORD *)this + 17) = 4 * *((unsigned __int8 *)this + 48);
LABEL_60:
  if (!*((_BYTE *)this + 73))
  {
    v41 = *((int *)this + 17);
    if (!gPermuteMap[4 * v41]
      && ((0x8433uLL >> v41) & 1) != 0
      && ((0xCC21uLL >> v41) & 1) != 0
      && *((_BYTE *)this + 65)
      && *((_QWORD *)this + 1)
      && !*((_BYTE *)this + 72))
    {
      *((_BYTE *)this + 72) = 1;
      v42 = *((unsigned __int8 *)this + 40);
      v43 = *((unsigned __int8 *)this + 56);
      v44 = PixelTypeStr(*((_BYTE *)this + 32));
      v45 = PixelTypeStr(*((_BYTE *)this + 49));
      _cg_jpeg_mem_term("convert", 1243, "⭕️  check result - converter is no longer swapping (%d-->%d)  %s --> %s\n", v42, v43, v44, v45);
    }
  }
  return 0;
}

uint64_t _cg_TIFFReadEncodedStrip(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int64_t StripSize;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  unsigned __int16 v22;

  v22 = 0;
  StripSize = TIFFReadEncodedStripGetStripSize((_DWORD *)a1, a2, &v22, a4, a5, a6, a7, a8);
  v19 = StripSize;
  if (StripSize != -1)
  {
    if (StripSize > a4 || a4 == -1 || *(_WORD *)(a1 + 120) != 1 || (*(_DWORD *)(a1 + 16) & 0x20800) != 0)
    {
      if (StripSize > a4 && a4 != -1)
        v19 = a4;
      if (TIFFFillStrip(a1, a2, v13, v14, v15, v16, v17, v18))
      {
        if ((*(int (**)(uint64_t, void *, size_t, _QWORD))(a1 + 1024))(a1, a3, v19, v22) >= 1)
        {
LABEL_13:
          (*(void (**)(uint64_t, void *, size_t))(a1 + 1248))(a1, a3, v19);
          return v19;
        }
      }
      else
      {
        bzero(a3, v19);
      }
    }
    else if (TIFFReadRawStrip1(a1, a2, a3, StripSize, "TIFFReadEncodedStrip") == StripSize)
    {
      if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0)
        TIFFReverseBits((unsigned __int8 *)a3, v19);
      goto LABEL_13;
    }
    return -1;
  }
  return v19;
}

uint64_t _cg_TIFFComputeStrip(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;

  v8 = *(_DWORD *)(a1 + 132);
  if (!v8)
  {
    TIFFErrorExt(*(_QWORD *)(a1 + 1200), "TIFFComputeStrip", "Unexpected rowsperstrip: %lu", a4, a5, a6, a7, a8, 0);
    return 0;
  }
  v9 = a2 / v8;
  if (*(_WORD *)(a1 + 170) == 2)
  {
    if (*(unsigned __int16 *)(a1 + 130) > a3)
      return v9 + *(_DWORD *)(a1 + 224) * a3;
    TIFFErrorExtR(a1, "TIFFComputeStrip", "%lu: Sample out of range, max %lu", a4, a5, a6, a7, a8, a3);
    return 0;
  }
  return v9;
}

uint64_t TIFFStartStrip(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t result;
  unsigned int v12;
  uint64_t v13;
  char v14;

  v10 = *(_DWORD *)(a1 + 16);
  if ((v10 & 0x20) == 0)
  {
    result = (*(uint64_t (**)(uint64_t))(a1 + 960))(a1);
    if (!(_DWORD)result)
      return result;
    v10 = *(_DWORD *)(a1 + 16) | 0x20;
    *(_DWORD *)(a1 + 16) = v10;
  }
  *(_DWORD *)(a1 + 884) = a2;
  v12 = *(_DWORD *)(a1 + 224);
  if (v12)
  {
    *(_DWORD *)(a1 + 876) = *(_DWORD *)(a1 + 132) * (a2 % v12);
    *(_DWORD *)(a1 + 16) = v10 & 0xFFEFFFFF;
    if ((v10 & 0x20000) != 0)
    {
      *(_OWORD *)(a1 + 1152) = 0u;
    }
    else
    {
      *(_QWORD *)(a1 + 1152) = *(_QWORD *)(a1 + 1120);
      v13 = *(_QWORD *)(a1 + 1144);
      if (v13 < 1)
      {
        *(_QWORD *)(a1 + 1160) = TIFFGetStrileByteCount(a1, a2);
        v12 = *(_DWORD *)(a1 + 224);
      }
      else
      {
        *(_QWORD *)(a1 + 1160) = v13;
      }
    }
    result = (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 968))(a1, (unsigned __int16)(a2 / v12));
    if ((_DWORD)result)
      return 1;
    else
      *(_DWORD *)(a1 + 884) = -1;
  }
  else
  {
    TIFFErrorExt(*(_QWORD *)(a1 + 1200), "TIFFStartStrip", "Zero strips per image", a4, a5, a6, a7, a8, v14);
    return 0;
  }
  return result;
}

uint64_t _TIFFNoPreCode()
{
  return 1;
}

uint64_t TIFFFillStrip(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  int64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v30;
  uint64_t v31;

  if ((*(_BYTE *)(a1 + 18) & 2) == 0)
  {
    v10 = TIFFGetStrileByteCount(a1, a2);
    v18 = v10;
    if (v10 <= 0)
    {
      TIFFErrorExtR(a1, "TIFFFillStrip", "Invalid strip byte count %llu, strip %u", v13, v14, v15, v16, v17, v10);
      return 0;
    }
    if ((unint64_t)v10 > 0x100000)
    {
      v19 = _cg_TIFFStripSize(a1, v11, v12, v13, v14, v15, v16, v17);
      if (v19)
      {
        if (v19 < (v18 - 4096) / 0xAuLL)
        {
          v20 = 10 * v19 + 4096;
          TIFFErrorExtR(a1, "TIFFFillStrip", "Too large strip byte count %llu, strip %u. Limiting to %llu", v13, v14, v15, v16, v17, v18);
          v18 = v20;
        }
      }
    }
    v21 = *(_DWORD *)(a1 + 16);
    if ((v21 & 0x800) != 0)
    {
      if ((unint64_t)v18 > *(_QWORD *)(a1 + 1176)
        || TIFFGetStrileOffset(a1, a2) > (unint64_t)(*(_QWORD *)(a1 + 1176) - v18))
      {
        TIFFGetStrileOffset(a1, a2);
        TIFFErrorExtR(a1, "TIFFFillStrip", "Read error on strip %u; got %llu bytes, expected %llu",
          v23,
          v24,
          v25,
          v26,
          v27,
          a2);
        *(_DWORD *)(a1 + 884) = -1;
        return 0;
      }
      v21 = *(_DWORD *)(a1 + 16);
      if ((v21 & 0x800) != 0 && ((unsigned __int16)v21 & (*(_WORD *)(a1 + 126) | 0x100)) != 0)
      {
        if ((v21 & 0x200) != 0)
        {
          v30 = *(char **)(a1 + 1120);
          if (v30)
          {
            _TIFFfreeExt(a1, v30);
            *(_QWORD *)(a1 + 1120) = 0;
            v21 = *(_DWORD *)(a1 + 16);
          }
        }
        *(_DWORD *)(a1 + 16) = v21 & 0xFFFFFDFF;
        *(_QWORD *)(a1 + 1128) = v18;
        v31 = *(_QWORD *)(a1 + 1168);
        *(_QWORD *)(a1 + 1120) = v31 + TIFFGetStrileOffset(a1, a2);
        *(_QWORD *)(a1 + 1136) = 0;
        *(_QWORD *)(a1 + 1144) = v18;
        *(_DWORD *)(a1 + 16) |= 0x800000u;
        return TIFFStartStrip(a1, a2, a3, a4, a5, a6, a7, a8);
      }
    }
    v22 = *(_QWORD *)(a1 + 1128);
    if (v18 > v22)
    {
      *(_DWORD *)(a1 + 884) = -1;
      if ((v21 & 0x200) == 0)
      {
        TIFFErrorExtR(a1, "TIFFFillStrip", "Data buffer too small to hold strip %u", v13, v14, v15, v16, v17, a2);
        return 0;
      }
    }
    if ((v21 & 0x800000) != 0)
    {
      v22 = 0;
      *(_DWORD *)(a1 + 884) = -1;
      v21 &= ~0x800000u;
      *(_OWORD *)(a1 + 1120) = 0u;
      *(_DWORD *)(a1 + 16) = v21;
    }
    if ((v21 & 0x800) != 0)
    {
      if (v18 > v22 && !TIFFReadBufferSetup(a1, 0, v18, v13, v14, v15, v16, v17))
        return 0;
      v28 = TIFFReadRawStrip1(a1, a2, *(void **)(a1 + 1120), v18, "TIFFFillStrip");
    }
    else
    {
      v28 = TIFFReadRawStripOrTile2(a1, a2, 1, v18, "TIFFFillStrip");
    }
    if (v28 != v18)
      return 0;
    *(_QWORD *)(a1 + 1136) = 0;
    *(_QWORD *)(a1 + 1144) = v18;
    if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0)
      TIFFReverseBits(*(unsigned __int8 **)(a1 + 1120), v18);
  }
  return TIFFStartStrip(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t TIFFReadRawStripOrTile2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int v5;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x800) != 0)
    TIFFReadRawStripOrTile2_cold_2();
  if ((v5 & 0x20000) != 0)
    TIFFReadRawStripOrTile2_cold_1();
  v11 = TIFFGetStrileOffset(a1, a2);
  if (_TIFFSeekOK(a1, v11))
  {
    if (TIFFReadAndRealloc(a1, a4, 0, a3, a2, a5, v15, v16))
      return a4;
    else
      return -1;
  }
  else
  {
    if ((_DWORD)a3)
      TIFFErrorExtR(a1, a5, "Seek error at scanline %u, strip %u", v12, v13, v14, v15, v16, *(_DWORD *)(a1 + 876));
    else
      TIFFErrorExtR(a1, a5, "Seek error at row %u, col %u, tile %u", v12, v13, v14, v15, v16, *(_DWORD *)(a1 + 876));
    return -1;
  }
}

uint64_t TIFFReadAndRealloc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  _BOOL4 v17;
  uint64_t v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t result;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  int v32;

  v8 = a4;
  v12 = 0;
  v13 = a3 + a2;
  v14 = (uint64_t *)(a1 + 1120);
  v15 = 0x100000;
  do
  {
    if (a2 <= v12)
      return 1;
    v17 = v15 < 1048576000 && a2 - v12 >= v15;
    v18 = *(_QWORD *)(a1 + 1128);
    v19 = v13 > v18;
    if (v17 && v19)
      v20 = 10 * v15;
    else
      v20 = v15;
    if (v17 && v19)
      v21 = v15;
    else
      v21 = a2 - v12;
    v22 = v12 + a3 + v21;
    if (v22 <= v18)
    {
      result = *v14;
      if (!*v14)
        return result;
    }
    else
    {
      if ((*(_BYTE *)(a1 + 17) & 2) == 0)
        TIFFReadAndRealloc_cold_1();
      v23 = (v22 + 1023) & 0xFFFFFFFFFFFFFC00;
      *(_QWORD *)(a1 + 1128) = v23;
      if (!v23)
      {
        v31 = "Invalid buffer size";
        goto LABEL_28;
      }
      result = (uint64_t)_TIFFreallocExt((_QWORD *)a1, *(char **)(a1 + 1120), v23, a4, a5, (uint64_t)a6, a7, a8);
      if (!result)
      {
        TIFFErrorExtR(a1, a6, "No space for data buffer at scanline %u", v25, v26, v27, v28, v29, *(_DWORD *)(a1 + 876));
        _TIFFfreeExt(a1, *(char **)(a1 + 1120));
        result = 0;
        *v14 = 0;
        v14[1] = 0;
        return result;
      }
      *v14 = result;
    }
    v30 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), result + a3 + v12, v21);
    v12 += v30;
    v15 = v20;
  }
  while (v30 == v21);
  bzero((void *)(*(_QWORD *)(a1 + 1120) + a3 + v12), *(_QWORD *)(a1 + 1128) - a3 - v12);
  if (v8)
  {
    TIFFErrorExtR(a1, a6, "Read error at scanline %u; got %lld bytes, expected %lld",
      a4,
      a5,
      (uint64_t)a6,
      a7,
      a8,
      *(_DWORD *)(a1 + 876));
    return 0;
  }
  v32 = *(_DWORD *)(a1 + 876);
  v31 = "Read error at row %u, col %u, tile %u; got %lld bytes, expected %lld";
LABEL_28:
  TIFFErrorExtR(a1, a6, v31, a4, a5, (uint64_t)a6, a7, a8, v32);
  return 0;
}

uint64_t TIFFGetStrileOffset(uint64_t a1, uint64_t a2)
{
  return _TIFFGetStrileOffsetOrByteCountValue(a1, a2);
}

uint64_t TIFFGetStrileByteCount(uint64_t a1, uint64_t a2)
{
  return _TIFFGetStrileOffsetOrByteCountValue(a1, a2);
}

uint64_t DumpModeDecode(uint64_t a1, char *__dst, int64_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int64_t v10;

  v10 = *(_QWORD *)(a1 + 1160);
  if (v10 >= __n)
  {
    if (*(char **)(a1 + 1152) != __dst)
    {
      _TIFFmemcpy(__dst, *(const void **)(a1 + 1152), __n);
      __dst = *(char **)(a1 + 1152);
      v10 = *(_QWORD *)(a1 + 1160);
    }
    *(_QWORD *)(a1 + 1152) = &__dst[__n];
    *(_QWORD *)(a1 + 1160) = v10 - __n;
    return 1;
  }
  else
  {
    TIFFErrorExtR(a1, "DumpModeDecode", "Not enough data for scanline %u, expected a request for at most %lld bytes, got a request for %lld bytes", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
    return 0;
  }
}

void allocChoppedUpStripArrays(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  unint64_t *v31;
  char *v32;
  unint64_t v33;

  v8 = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
  v9 = _TIFFGetStrileOffsetOrByteCountValue(a1, (*(_DWORD *)(a1 + 228) - 1));
  v10 = _TIFFGetStrileOffsetOrByteCountValue(a1, (*(_DWORD *)(a1 + 228) - 1));
  if (!__CFADD__(v10, v9))
  {
    v15 = v10 + v9 - v8;
    if (v10 + v9 >= v8)
    {
      if (a2 <= 0x640000
        || 16 * (unint64_t)a2 <= (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200)))
      {
        v17 = a2;
        v18 = (char *)_TIFFCheckMalloc((const char **)a1, a2, 8, (uint64_t)"for chopped \"StripByteCounts\" array", v11, v12, v13, v14);
        v23 = (char *)_TIFFCheckMalloc((const char **)a1, a2, 8, (uint64_t)"for chopped \"StripOffsets\" array", v19, v20, v21, v22);
        v30 = v23;
        if (v18 && v23)
        {
          if (a2)
          {
            v31 = (unint64_t *)v23;
            v32 = v18;
            do
            {
              if (a3 >= v15)
                a3 = v15;
              *(_QWORD *)v32 = a3;
              v32 += 8;
              if (a3)
                v33 = v8;
              else
                v33 = 0;
              *v31++ = v33;
              v8 += a3;
              v15 -= a3;
              --v17;
            }
            while (v17);
          }
          *(_DWORD *)(a1 + 224) = a2;
          *(_DWORD *)(a1 + 228) = a2;
          _cg_TIFFSetField(a1, 278, v24, v25, v26, v27, v28, v29, a4);
          _TIFFfreeExt(a1, *(char **)(a1 + 240));
          _TIFFfreeExt(a1, *(char **)(a1 + 232));
          *(_QWORD *)(a1 + 232) = v30;
          *(_QWORD *)(a1 + 240) = v18;
          *(_DWORD *)(a1 + 16) |= 0x4000000u;
        }
        else
        {
          if (v18)
            _TIFFfreeExt(a1, v18);
          if (v30)
            _TIFFfreeExt(a1, v30);
        }
      }
      else
      {
        TIFFWarningExtR(a1, "allocChoppedUpStripArrays", "Requested memory size for StripByteCount and StripOffsets %llu is greater than filesize %llu. Memory not allocated", v16, v11, v12, v13, v14, 16 * a2);
      }
    }
  }
}

uint64_t _TIFFGetStrileOffsetOrByteCountValue(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t *v11;
  int8x8_t *v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  int v17;
  uint64_t result;
  uint64_t v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  uint8x8_t v41;
  unsigned __int32 v42;
  int8x8_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int8x8_t v52;
  char *v53;
  uint64_t v54;
  unsigned int v55;
  unsigned int v56;
  unint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  _BYTE *v61;
  int v62;
  int8x8_t v63;
  char v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char v68;
  uint64_t v69;
  int8x8_t v70;
  _BYTE v71[8192];
  uint64_t v72;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v10 = v6;
  v11 = (uint64_t *)v5;
  v12 = (int8x8_t *)v4;
  v13 = v3;
  v14 = v2;
  v72 = *MEMORY[0x1E0C80C00];
  if (v6)
    *v6 = 0;
  v15 = *(_DWORD *)(v2 + 16);
  if ((v15 & 0x5000000) != 0x1000000)
    goto LABEL_9;
  if ((v15 & 0x2000000) == 0 || (v16 = *(_QWORD *)(v4 + 8), v16 <= 4))
  {
    v17 = _TIFFFillStrilesInternal(v2, 1);
    if (v10 && !v17)
      *v10 = 1;
    goto LABEL_9;
  }
  if (v16 <= v3)
    goto LABEL_65;
  v19 = *(unsigned int *)(v2 + 248);
  if (v19 <= v3)
  {
    v20 = *(_DWORD *)(v2 + 248);
    if (v3 >= 0xF4241)
    {
      if (v3 > (unint64_t)(*(uint64_t (**)(_QWORD))(v2 + 1240))(*(_QWORD *)(v2 + 1200)) >> 2)
      {
        TIFFErrorExtR(v14, "_TIFFFetchStrileValue", "File too short", v5, (uint64_t)v6, v7, v8, v9, v64);
        goto LABEL_65;
      }
      v20 = *(_DWORD *)(v14 + 248);
    }
    v21 = *(_DWORD *)(v14 + 228);
    if (v20 || v21 >= 0x100000)
    {
      v22 = v13 + 1 > 0x80000 ? v13 + 1 : 0x80000;
      v23 = v22 << (v22 < 0x7FFFFFFF);
      if (v23 < v21)
        v21 = v23;
    }
    if (v21 <= v13)
      _TIFFGetStrileOffsetOrByteCountValue_cold_2();
    v24 = _TIFFreallocExt((_QWORD *)v14, *(char **)(v14 + 232), 8 * v21, v5, (uint64_t)v6, v7, v8, v9);
    v30 = _TIFFreallocExt((_QWORD *)v14, *(char **)(v14 + 240), 8 * v21, v25, v26, v27, v28, v29);
    if (v24)
    {
      *(_QWORD *)(v14 + 232) = v24;
      if (v30)
      {
        *(_QWORD *)(v14 + 240) = v30;
        *(_DWORD *)(v14 + 248) = v21;
        memset(&v24[v19], 255, 8 * (v21 - v19));
        memset((void *)(*(_QWORD *)(v14 + 240) + 8 * v19), 255, 8 * (*(_DWORD *)(v14 + 248) - v19));
        goto LABEL_32;
      }
    }
    else if (v30)
    {
      *(_QWORD *)(v14 + 240) = v30;
    }
    TIFFErrorExtR(v14, "_TIFFFetchStrileValue", "Cannot allocate strip offset and bytecount arrays", v31, v32, v33, v34, v35, v64);
    _TIFFfreeExt(v14, *(char **)(v14 + 232));
    *(_QWORD *)(v14 + 232) = 0;
    _TIFFfreeExt(v14, *(char **)(v14 + 240));
    *(_QWORD *)(v14 + 240) = 0;
    *(_DWORD *)(v14 + 248) = 0;
  }
LABEL_32:
  v36 = *v11;
  if (!*v11)
    goto LABEL_65;
  v37 = *(_DWORD *)(v14 + 248);
  if (v37 <= v13)
    goto LABEL_65;
  if (*(_QWORD *)(v36 + 8 * v13) != -1)
    goto LABEL_9;
  if (*(_QWORD *)&v12[1] <= 4uLL)
    _TIFFGetStrileOffsetOrByteCountValue_cold_1();
  v38 = *(_DWORD *)(v14 + 16);
  v39 = v12->u16[1];
  if (v39 > 0xF)
  {
    if (v39 != 16 && v39 != 17)
      goto LABEL_60;
    v40 = 8;
  }
  else
  {
    if (v39 != 3)
    {
      if (v39 == 4)
      {
        v40 = 4;
        goto LABEL_44;
      }
LABEL_60:
      v53 = "Invalid type for [Strip|Tile][Offset/ByteCount] tag";
LABEL_62:
      TIFFErrorExtR(v14, "_TIFFPartialReadStripArray", v53, v5, (uint64_t)v6, v7, v8, v9, v64);
      *(_QWORD *)(v36 + 8 * (int)v13) = 0;
      goto LABEL_64;
    }
    v40 = 2;
  }
LABEL_44:
  v69 = v40;
  bzero(v71, 0x2000uLL);
  if ((v38 & 0x80000) == 0)
  {
    v42 = v12[2].u32[0];
    v70.i32[0] = v42;
    if ((v38 & 0x80) != 0)
    {
      TIFFSwabLong((__int32 *)&v70, v41);
      v42 = v70.i32[0];
    }
    v43 = (int8x8_t)v42;
    goto LABEL_51;
  }
  v43 = v12[2];
  v70 = v43;
  if ((v38 & 0x80) != 0)
  {
    TIFFSwabLong8(&v70);
    v43 = v70;
  }
  if ((*(_QWORD *)&v43 & 0x8000000000000000) != 0)
  {
    v64 = v13;
    v53 = "Cannot read offset/size for strile %d";
    goto LABEL_62;
  }
LABEL_51:
  v68 = v38;
  v44 = *(_QWORD *)&v43 + (int)v69 * (uint64_t)(int)v13;
  v45 = v44 & 0xFFFFFFFFFFFFF000;
  v46 = (v44 & 0xFFFFFFFFFFFFF000) + 4096;
  if (v44 + v69 > v46)
    v46 = (v44 & 0xFFFFFFFFFFFFF000) + 0x2000;
  if (*(_QWORD *)&v43 + v69 * (unint64_t)v37 < v46)
    v46 = *(_QWORD *)&v43 + v69 * (unint64_t)v37;
  if (v46 <= v45)
  {
    TIFFErrorExtR(v14, "_TIFFPartialReadStripArray", "Cannot read offset/size for strile %d", v5, (uint64_t)v6, v7, v8, v9, v13);
    *(_QWORD *)(v36 + 8 * (int)v13) = 0;
    goto LABEL_64;
  }
  v65 = v46 - v45;
  v67 = v46;
  if (!_TIFFSeekOK(v14, v45))
  {
    *(_QWORD *)(v36 + 8 * (int)v13) = 0;
    goto LABEL_64;
  }
  if ((*(uint64_t (**)(_QWORD, _BYTE *, uint64_t))(v14 + 1208))(*(_QWORD *)(v14 + 1200), v71, v65) < v65)
  {
    TIFFErrorExtR(v14, "_TIFFPartialReadStripArray", "Cannot read offset/size for strile around ~%d", v47, v48, v49, v50, v51, v13);
LABEL_64:
    *(_QWORD *)(*v11 + 8 * v13) = 0;
    goto LABEL_65;
  }
  v54 = v44 & 0xFFF;
  v55 = ((unsigned __int16)v44 & 0xFFFu) / v69;
  if ((int)(v13 - v55) < 0)
    v55 = v13;
  v56 = v13 - v55;
  v57 = v67;
  if (v13 - v55 < v37)
  {
    v58 = 0;
    v59 = -v55;
    v60 = *(_QWORD *)&v43 + v69 + v69 * ((int)v13 + (uint64_t)v59);
    v61 = &v71[v54 + (int)v69 * (uint64_t)v59];
    v66 = v60;
    do
    {
      if (v60 + v58 > v57)
        break;
      v62 = v12->u16[1];
      if (v62 == 16)
        goto LABEL_78;
      if (v62 == 4)
      {
        v63 = (int8x8_t)*(unsigned int *)&v61[v58];
        v70.i32[0] = *(_DWORD *)&v61[v58];
        if (v68 < 0)
        {
          v52 = TIFFSwabLong((__int32 *)&v70, (uint8x8_t)v52);
          v60 = v66;
          v57 = v67;
          v63 = (int8x8_t)v70.u32[0];
        }
        goto LABEL_82;
      }
      if (v62 != 3)
      {
LABEL_78:
        v63 = *(int8x8_t *)&v61[v58];
        v70 = v63;
        if (v68 < 0)
        {
          v52 = TIFFSwabLong8(&v70);
          v60 = v66;
          v57 = v67;
          v63 = v70;
        }
      }
      else
      {
        v63 = (int8x8_t)*(unsigned __int16 *)&v61[v58];
        v70.i16[0] = *(_WORD *)&v61[v58];
        if (v68 < 0)
        {
          TIFFSwabShort(&v70);
          v60 = v66;
          v57 = v67;
          v63 = (int8x8_t)v70.u16[0];
        }
      }
LABEL_82:
      *(int8x8_t *)(v36 + 8 * (int)v56) = v63;
      v58 += v69;
      ++v56;
    }
    while (v56 < v37);
  }
LABEL_9:
  if (*v11 && *(_DWORD *)(v14 + 228) > v13)
    return *(_QWORD *)(*v11 + 8 * v13);
LABEL_65:
  result = 0;
  if (v10)
    *v10 = 1;
  return result;
}

uint64_t _cg_TIFFStripSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v9 = *(_DWORD *)(a1 + 132);
  v10 = *(_DWORD *)(a1 + 92);
  if (v9 >= v10)
    v11 = v10;
  else
    v11 = v9;
  v12 = TIFFVStripSize64(a1, v11, a3, a4, a5, a6, a7, a8);
  return _TIFFCastUInt64ToSSize(a1, v12, "TIFFStripSize", v13, v14, v15, v16, v17);
}

uint64_t TIFFReadEncodedStripGetStripSize(_DWORD *a1, unsigned int a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t result;
  char v25;

  if (!TIFFCheckRead((uint64_t)a1, 0, (uint64_t)a3, a4, a5, a6, a7, a8))
    return -1;
  if (a1[57] <= a2)
  {
    TIFFErrorExtR((uint64_t)a1, "TIFFReadEncodedStrip", "%u: Strip out of range, max %u", v12, v13, v14, v15, v16, a2);
    return -1;
  }
  v17 = a1[33];
  v18 = a1[23];
  if (v17 >= v18)
    v17 = a1[23];
  if (!v17)
  {
    TIFFErrorExtR((uint64_t)a1, "TIFFReadEncodedStrip", "rowsperstrip is zero", v12, v13, v14, v15, v16, v25);
    return -1;
  }
  v19 = v18 / v17;
  if (v18 % v17)
    ++v19;
  v20 = a2 / v19;
  v21 = a2 % v19;
  if (a3)
    *a3 = v20;
  v22 = v18 - v21 * v17;
  if (v22 >= v17)
    v23 = v17;
  else
    v23 = v22;
  result = TIFFVStripSize((uint64_t)a1, v23, v11, v12, v13, v14, v15, v16);
  if (!result)
    return -1;
  return result;
}

uint64_t TIFFVStripSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v9 = TIFFVStripSize64(a1, a2, a3, a4, a5, a6, a7, a8);
  return _TIFFCastUInt64ToSSize(a1, v9, "TIFFVStripSize", v10, v11, v12, v13, v14);
}

unint64_t TIFFVStripSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  BOOL v10;
  int v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char v38;
  int v39;

  v8 = a2;
  if ((_DWORD)a2 == -1)
    v8 = *(_DWORD *)(a1 + 92);
  if (*(_WORD *)(a1 + 170) != 1 || *(_WORD *)(a1 + 122) != 6 || (*(_BYTE *)(a1 + 17) & 0x40) != 0)
  {
    v14 = _cg_TIFFScanlineSize64(a1, a2, a3, a4, a5, a6, a7, a8);
    return _TIFFMultiply64(a1, v8, v14, "TIFFVStripSize64", v15, v16, v17, v18);
  }
  v39 = 0;
  if (*(_WORD *)(a1 + 130) != 3)
  {
    v20 = "Invalid td_samplesperpixel value";
LABEL_22:
    TIFFErrorExtR(a1, "TIFFVStripSize64", v20, a4, a5, a6, a7, a8, v38);
    return 0;
  }
  _cg_TIFFGetFieldDefaulted(a1, 530, a3, a4, a5, a6, a7, a8, (uint64_t)&v39);
  if ((unsigned __int16)v39 > 4u
    || ((1 << v39) & 0x16) == 0
    || (HIWORD(v39) != 4 ? (v10 = HIWORD(v39) - 3 >= 0xFFFFFFFE) : (v10 = 1),
        v10 ? (v11 = 0) : (v11 = 1),
        !HIWORD(v39) || v11))
  {
    v38 = v39;
    v20 = "Invalid YCbCr subsampling (%dx%d)";
    goto LABEL_22;
  }
  v12 = *(_DWORD *)(a1 + 88);
  if (v12 >= -(unsigned __int16)v39)
    v13 = 0;
  else
    v13 = ((unsigned __int16)v39 + v12 - 1) / (unsigned __int16)v39;
  if (v8 < -HIWORD(v39))
    v21 = (v8 + HIWORD(v39) - 1) / HIWORD(v39);
  else
    v21 = 0;
  v22 = _TIFFMultiply64(a1, v13, HIWORD(v39) * (unsigned __int16)v39 + 2, "TIFFVStripSize64", a5, a6, a7, a8);
  v27 = _TIFFMultiply64(a1, v22, *(unsigned __int16 *)(a1 + 116), "TIFFVStripSize64", v23, v24, v25, v26);
  v32 = _TIFFMultiply64(a1, v22, *(unsigned __int16 *)(a1 + 116), "TIFFVStripSize64", v28, v29, v30, v31);
  if ((v27 & 7) != 0)
    v37 = (v32 >> 3) + 1;
  else
    v37 = v32 >> 3;
  return _TIFFMultiply64(a1, v37, v21, "TIFFVStripSize64", v33, v34, v35, v36);
}

unint64_t _cg_TIFFScanlineSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unint64_t result;
  char *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  unsigned __int16 v31;
  int v32;

  v8 = a1;
  if (*(_WORD *)(a1 + 170) != 1)
  {
    v18 = *(unsigned int *)(a1 + 88);
    v19 = *(unsigned __int16 *)(a1 + 116);
    goto LABEL_24;
  }
  if (*(_WORD *)(a1 + 122) != 6)
  {
    v20 = *(_DWORD *)(a1 + 88);
LABEL_23:
    v18 = _TIFFMultiply64(v8, v20, *(unsigned __int16 *)(v8 + 130), "TIFFScanlineSize64", a5, a6, a7, a8);
    v19 = *(unsigned __int16 *)(v8 + 116);
    a1 = v8;
LABEL_24:
    result = (_TIFFMultiply64(a1, v18, v19, "TIFFScanlineSize64", a5, a6, a7, a8) + 7) >> 3;
    if (result)
      return result;
    goto LABEL_25;
  }
  if (*(_WORD *)(a1 + 130) != 3 || (*(_BYTE *)(a1 + 17) & 0x40) != 0)
  {
    v20 = *(_DWORD *)(a1 + 88);
    v31 = 0;
    _cg_TIFFGetFieldDefaulted(a1, 530, a3, a4, a5, a6, a7, a8, (uint64_t)&v31);
    if (v31 >= 2u)
    {
      v21 = 0;
      if (v20 < -v31)
        v21 = (v20 + v31 - 1) / v31;
      v20 = v21 * v31;
    }
    goto LABEL_23;
  }
  v32 = 0;
  _cg_TIFFGetFieldDefaulted(a1, 530, a3, a4, a5, a6, a7, a8, (uint64_t)&v32);
  if ((unsigned __int16)v32 > 4u
    || ((1 << v32) & 0x16) == 0
    || (HIWORD(v32) != 4 ? (v14 = HIWORD(v32) - 3 >= 0xFFFFFFFE) : (v14 = 1),
        v14 ? (v15 = 0) : (v15 = 1),
        !HIWORD(v32) || (v15 & 1) != 0))
  {
    v23 = "Invalid YCbCr subsampling";
    goto LABEL_26;
  }
  v16 = *(_DWORD *)(v8 + 88);
  if (v16 >= -(unsigned __int16)v32)
    v17 = 0;
  else
    v17 = ((unsigned __int16)v32 + v16 - 1) / (unsigned __int16)v32;
  v24 = _TIFFMultiply64(v8, v17, HIWORD(v32) * (unsigned __int16)v32 + 2, "TIFFScanlineSize64", v10, v11, v12, v13);
  v29 = _TIFFMultiply64(v8, v24, *(unsigned __int16 *)(v8 + 116), "TIFFScanlineSize64", v25, v26, v27, v28);
  result = ((v29 + 7) >> 3) / HIWORD(v32);
  if (!result)
  {
LABEL_25:
    v23 = "Computed scanline size is zero";
LABEL_26:
    TIFFErrorExtR(v8, "TIFFScanlineSize64", v23, v9, v10, v11, v12, v13, v30);
    return 0;
  }
  return result;
}

unint64_t _TIFFMultiply64(uint64_t a1, unint64_t a2, unint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3 || is_mul_ok(a3, a2))
    return a3 * a2;
  TIFFErrorExtR(a1, a4, "Integer overflow in %s", (uint64_t)a4, a5, a6, a7, a8, (char)a4);
  return 0;
}

uint64_t TIFFCheckRead(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;
  char *v9;
  char vars0;

  if (*(_DWORD *)(a1 + 12) == 1)
  {
    v8 = *(const char **)a1;
    v9 = "File not open for reading";
  }
  else
  {
    if (((*(_DWORD *)(a1 + 16) >> 10) & 1) == a2)
      return 1;
    if (a2)
      v9 = "Can not read tiles from a striped image";
    else
      v9 = "Can not read scanlines from a tiled image";
    v8 = *(const char **)a1;
  }
  TIFFErrorExtR(a1, v8, v9, a4, a5, a6, a7, a8, vars0);
  return 0;
}

char *TIFFFetchDirectory(uint64_t a1, uint64_t a2, _QWORD *a3, int8x8_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int16 v18;
  unsigned int v19;
  unint64_t v20;
  int v21;
  unsigned int v22;
  char *result;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint8x8_t v31;
  int v32;
  char *v33;
  char *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  size_t v41;
  unint64_t v42;
  _QWORD *v43;
  int8x8_t v44;
  _QWORD *v45;
  unsigned int v46;
  _QWORD *v47;
  char *v48;
  int v49;
  int8x8_t *v50;
  uint64_t v51;
  const char *v52;
  int8x8_t v53;
  unsigned __int16 __dst;

  if (!a3)
    TIFFFetchDirectory_cold_1();
  *(_QWORD *)(a1 + 24) = a2;
  if (a4)
    *a4 = 0;
  __dst = 0;
  v11 = *(_DWORD *)(a1 + 16);
  v12 = *(_QWORD *)(a1 + 24);
  if ((v11 & 0x800) == 0)
  {
    if (_TIFFSeekOK(a1, v12))
    {
      if ((*(_BYTE *)(a1 + 18) & 8) != 0)
      {
        v53 = 0;
        if ((*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v53, 8) == 8)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabLong8(&v53);
          v18 = v53.i16[0];
          if (*(_QWORD *)&v53 <= 0x1000uLL)
          {
            __dst = v53.i16[0];
            v19 = 20;
            goto LABEL_26;
          }
          goto LABEL_43;
        }
      }
      else if ((*(uint64_t (**)(_QWORD, unsigned __int16 *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &__dst, 2) == 2)
      {
        if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
          TIFFSwabShort(&__dst);
        v18 = __dst;
        if (__dst <= 0x1000u)
        {
          v19 = 12;
LABEL_26:
          result = (char *)_TIFFCheckMalloc((const char **)a1, v18, v19, (uint64_t)"to read TIFF directory", a5, a6, a7, a8);
          if (!result)
            return result;
          v24 = result;
          v25 = (*(uint64_t (**)(_QWORD, char *, _QWORD))(a1 + 1208))(*(_QWORD *)(a1 + 1200), result, v19 * __dst);
          if (v25 == v19 * __dst)
          {
            if (!a4)
              goto LABEL_67;
            if ((*(_BYTE *)(a1 + 18) & 8) == 0)
            {
              v53.i32[0] = 0;
              if ((*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v53, 4) != 4)v53.i32[0] = 0;
              LOBYTE(v32) = *(_BYTE *)(a1 + 16);
LABEL_33:
              if ((v32 & 0x80) != 0)
                TIFFSwabLong((__int32 *)&v53, v31);
              *a4 = (int8x8_t)v53.u32[0];
              goto LABEL_67;
            }
            if ((*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), a4, 8) != 8)
              *a4 = 0;
            LOBYTE(v32) = *(_BYTE *)(a1 + 16);
            goto LABEL_60;
          }
          v52 = *(const char **)a1;
          v34 = "%.100s: Can not read TIFF directory";
LABEL_48:
          TIFFErrorExtR(a1, "TIFFFetchDirectory", v34, v26, v27, v28, v29, v30, (char)v52);
LABEL_83:
          _TIFFfreeExt(a1, v24);
          return 0;
        }
        goto LABEL_43;
      }
      TIFFErrorExtR(a1, "TIFFFetchDirectory", "%s: Can not read TIFF directory count", (uint64_t)a4, a5, a6, a7, a8, *(_QWORD *)a1);
    }
    else
    {
      TIFFErrorExtR(a1, "TIFFFetchDirectory", "%s: Seek error accessing TIFF directory", v13, v14, v15, v16, v17, *(_QWORD *)a1);
    }
    return 0;
  }
  if ((v12 & 0x8000000000000000) != 0)
    goto LABEL_38;
  if ((v11 & 0x80000) == 0)
  {
    if (v12 <= 0x7FFFFFFFFFFFFFFDLL)
    {
      v20 = v12 + 2;
      if ((int64_t)(v12 + 2) <= *(_QWORD *)(a1 + 1176))
      {
        _TIFFmemcpy(&__dst, (const void *)(*(_QWORD *)(a1 + 1168) + v12), 2uLL);
        if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
          TIFFSwabShort(&__dst);
        v21 = __dst;
        if (__dst <= 0x1000u)
        {
          v22 = 12;
          goto LABEL_50;
        }
LABEL_43:
        v33 = "Sanity check on directory count failed, this is probably not a valid IFD offset";
        goto LABEL_44;
      }
    }
LABEL_38:
    v33 = "Can not read TIFF directory count";
LABEL_44:
    TIFFErrorExtR(a1, "TIFFFetchDirectory", v33, (uint64_t)a4, a5, a6, a7, a8, (char)v52);
    return 0;
  }
  v53 = 0;
  if (v12 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_38;
  v20 = v12 + 8;
  if ((int64_t)(v12 + 8) > *(_QWORD *)(a1 + 1176))
    goto LABEL_38;
  _TIFFmemcpy(&v53, (const void *)(*(_QWORD *)(a1 + 1168) + v12), 8uLL);
  if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
    TIFFSwabLong8(&v53);
  if (*(_QWORD *)&v53 > 0x1000uLL)
    goto LABEL_43;
  v21 = v53.u16[0];
  __dst = v53.i16[0];
  v22 = 20;
LABEL_50:
  if (!v21)
  {
    v33 = "Sanity check on directory count failed, zero tag directories not supported";
    goto LABEL_44;
  }
  v35 = (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200));
  if (__dst * (unint64_t)v22 > v35)
  {
    TIFFWarningExtR(a1, "TIFFFetchDirectory", "Requested memory size for TIFF directory of %llu is greater than filesize %llu. Memory not allocated, TIFF directory not read", v36, v37, v38, v39, v40, __dst * v22);
    return 0;
  }
  result = (char *)_TIFFCheckMalloc((const char **)a1, __dst, v22, (uint64_t)"to read TIFF directory", v37, v38, v39, v40);
  if (!result)
    return result;
  v24 = result;
  v41 = v22 * __dst;
  if ((int64_t)(v20 + v41) > *(_QWORD *)(a1 + 1176))
  {
    v34 = "Can not read TIFF directory";
    goto LABEL_48;
  }
  _TIFFmemcpy(result, (const void *)(*(_QWORD *)(a1 + 1168) + v20), v41);
  if (!a4)
    goto LABEL_67;
  v42 = v20 + v22 * __dst;
  v32 = *(_DWORD *)(a1 + 16);
  if ((v32 & 0x80000) == 0)
  {
    v53.i32[0] = 0;
    if (v42 <= 0x7FFFFFFFFFFFFFFBLL && (int64_t)(v42 + 4) <= *(_QWORD *)(a1 + 1176))
    {
      _TIFFmemcpy(&v53, (const void *)(*(_QWORD *)(a1 + 1168) + v42), 4uLL);
      v32 = *(_DWORD *)(a1 + 16);
    }
    goto LABEL_33;
  }
  if (v42 <= 0x7FFFFFFFFFFFFFF7 && (int64_t)(v42 + 8) <= *(_QWORD *)(a1 + 1176))
  {
    _TIFFmemcpy(a4, (const void *)(*(_QWORD *)(a1 + 1168) + v42), 8uLL);
    v32 = *(_DWORD *)(a1 + 16);
  }
  else
  {
    *a4 = 0;
  }
LABEL_60:
  if ((v32 & 0x80) != 0)
    TIFFSwabLong8(a4);
LABEL_67:
  v43 = _TIFFCheckMalloc((const char **)a1, __dst, 32, (uint64_t)"to read TIFF directory", v27, v28, v29, v30);
  if (!v43)
    goto LABEL_83;
  v45 = v43;
  if (__dst)
  {
    v46 = 0;
    v47 = v43 + 2;
    v48 = v24;
    do
    {
      *((_BYTE *)v47 + 8) = 0;
      v49 = *(_DWORD *)(a1 + 16);
      if ((v49 & 0x80) != 0)
      {
        TIFFSwabShort(v48);
        v49 = *(_DWORD *)(a1 + 16);
        *((_WORD *)v47 - 8) = *(_WORD *)v48;
        if ((v49 & 0x80) != 0)
        {
          TIFFSwabShort(v48 + 2);
          v49 = *(_DWORD *)(a1 + 16);
        }
      }
      else
      {
        *((_WORD *)v47 - 8) = *(_WORD *)v48;
      }
      *((_WORD *)v47 - 7) = *((_WORD *)v48 + 1);
      v50 = (int8x8_t *)(v48 + 4);
      if ((v49 & 0x80000) != 0)
      {
        if ((v49 & 0x80) != 0)
          v44 = TIFFSwabLong8(v50);
        *(v47 - 1) = *(_QWORD *)(v48 + 4);
        *v47 = *(_QWORD *)(v48 + 12);
        v51 = 20;
      }
      else
      {
        if ((v49 & 0x80) != 0)
          v44 = TIFFSwabLong((__int32 *)v50, (uint8x8_t)v44);
        *(v47 - 1) = *((unsigned int *)v48 + 1);
        *v47 = 0;
        *(_DWORD *)v47 = *((_DWORD *)v48 + 2);
        v51 = 12;
      }
      v48 += v51;
      ++v46;
      v47 += 4;
    }
    while (v46 < __dst);
  }
  _TIFFfreeExt(a1, v24);
  *a3 = v45;
  return (char *)__dst;
}

_BYTE *TIFFSwabShort(_BYTE *result)
{
  char v1;

  v1 = result[1];
  result[1] = *result;
  *result = v1;
  return result;
}

int8x8_t TIFFSwabLong(__int32 *a1, uint8x8_t a2)
{
  int16x8_t v2;
  int8x8_t result;

  a2.i32[0] = *a1;
  v2 = (int16x8_t)vmovl_u8(a2);
  *(int16x4_t *)v2.i8 = vrev64_s16(*(int16x4_t *)v2.i8);
  result = vmovn_s16(v2);
  *a1 = result.i32[0];
  return result;
}

unint64_t myTIFFReadProc(IIOImageReadSession **a1, _BYTE *a2, unint64_t a3)
{
  unint64_t Bytes;
  IIOImageWriteSession *v5;
  unint64_t v6;

  if (a1)
  {
    if (a1[2])
    {
      Bytes = IIOImageReadSession::getBytes(a1[2], a2, a3);
LABEL_6:
      v6 = Bytes;
      goto LABEL_8;
    }
    v5 = a1[3];
    if (v5)
    {
      Bytes = IIOImageWriteSession::getBytes(v5, a2, a3);
      goto LABEL_6;
    }
  }
  v6 = 0;
LABEL_8:
  if (v6 != a3)
    _cg_jpeg_mem_term("myTIFFReadProc", 34, "*** expected: %lld   got: %lld\n", a3, v6);
  return v6;
}

uint64_t TIFFFetchStripThing(uint64_t a1, unsigned __int16 *a2, unsigned int a3, _QWORD *a4)
{
  unint64_t v8;
  int v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  _DWORD *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  const char *v22;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  void *__src;

  __src = 0;
  v8 = a3;
  v9 = TIFFReadDirEntryLong8ArrayWithLimit(a1, (uint64_t)a2, (int8x8_t **)&__src, a3);
  if (v9)
  {
    v10 = v9;
    v11 = TIFFFieldWithTag((_QWORD *)a1, *a2);
    if (v11)
      v15 = (const char *)*((_QWORD *)v11 + 4);
    else
      v15 = "unknown tagname";
    TIFFReadDirEntryOutputErr(a1, v10, "TIFFFetchStripThing", (uint64_t)v15, 0, v12, v13, v14);
    return 0;
  }
  if (*((_QWORD *)a2 + 1) >= v8)
  {
    v24 = (char *)__src;
    goto LABEL_12;
  }
  v16 = TIFFFieldWithTag((_QWORD *)a1, *a2);
  v17 = getenv("LIBTIFF_STRILE_ARRAY_MAX_RESIZE_COUNT");
  if (!v17)
  {
    v21 = 1000000;
    if (v16)
      goto LABEL_7;
LABEL_15:
    v22 = "unknown tagname";
    goto LABEL_16;
  }
  v21 = atoi(v17);
  if (!v16)
    goto LABEL_15;
LABEL_7:
  v22 = (const char *)*((_QWORD *)v16 + 4);
LABEL_16:
  TIFFReadDirEntryOutputErr(a1, 1, "TIFFFetchStripThing", (uint64_t)v22, v21 >= a3, v18, v19, v20);
  if (v21 < a3)
  {
LABEL_24:
    _TIFFfreeExt(a1, (char *)__src);
    return 0;
  }
  if (a3 > 0xC80000 && 8 * v8 > (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200)))
  {
    TIFFWarningExtR(a1, "TIFFFetchStripThing", "Requested memory size for StripArray of %llu is greater than filesize %llu. Memory not allocated", v29, v25, v26, v27, v28, 8 * v8);
    goto LABEL_24;
  }
  v30 = (char *)_TIFFCheckMalloc((const char **)a1, v8, 8, (uint64_t)"for strip array", v25, v26, v27, v28);
  if (!v30)
    goto LABEL_24;
  v24 = v30;
  v31 = *((_QWORD *)a2 + 1);
  v32 = (char *)__src;
  if (v31)
  {
    _TIFFmemcpy(v30, __src, 8 * *((_QWORD *)a2 + 1));
    v31 = *((unsigned int *)a2 + 2);
  }
  _TIFFmemset(&v24[8 * v31], 0, 8 * (a3 - v31));
  _TIFFfreeExt(a1, v32);
LABEL_12:
  *a4 = v24;
  return 1;
}

uint64_t TIFFReadDirEntryLong8ArrayWithLimit(uint64_t a1, uint64_t a2, int8x8_t **a3, unint64_t a4)
{
  unsigned int v4;
  BOOL v5;
  int v6;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int8x8_t *v18;
  int v19;
  unsigned int v20;
  int8x8_t *v21;
  unsigned int v22;
  char *v23;
  int8x8_t v24;
  char *v25;
  char *v26;
  int8x8_t *v27;
  unsigned int v28;
  uint64_t v29;
  char *v30;
  char *v31;
  int8x8_t *v32;
  unsigned int v33;
  char *v34;
  __int32 *v35;
  unsigned __int32 v36;
  char *v37;
  int8x8_t *v38;
  unsigned int v39;
  char *v40;
  int8x8_t *v41;
  unsigned int v42;
  char *v43;
  __int32 *v44;
  uint64_t v45;
  int8x8_t *v47;
  unsigned int v48;

  v4 = *(unsigned __int16 *)(a2 + 2);
  v5 = v4 > 0x11;
  v6 = (1 << v4) & 0x3035A;
  if (v5 || v6 == 0)
    return 2;
  v48 = 0;
  v47 = 0;
  v17 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v48, 8u, (void **)&v47, a4);
  if ((_DWORD)v17 || (v18 = v47) == 0)
  {
    *a3 = 0;
  }
  else
  {
    v19 = *(unsigned __int16 *)(a2 + 2);
    if (v19 == 16)
    {
      *a3 = v47;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabArrayOfLong8(v18, v48);
      return 0;
    }
    else if (v19 == 17)
    {
      v20 = v48;
      if (v48)
      {
        v21 = v47;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabLong8(v21);
          if (((*(unint64_t *)v21 >> 61) & 4) != 0)
            break;
          ++v21;
          if (!--v20)
            goto LABEL_15;
        }
        v17 = (*(unint64_t *)v21 >> 61) & 4;
        v29 = a1;
        v30 = (char *)v18;
LABEL_64:
        _TIFFfreeExt(v29, v30);
        return v17;
      }
LABEL_15:
      v17 = 0;
      *a3 = v18;
    }
    else
    {
      v22 = v48;
      v23 = (char *)_TIFFmallocExt((_QWORD *)a1, 8 * v48, v11, v12, v13, v14, v15, v16);
      if (v23)
      {
        v25 = v23;
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v22)
            {
              v26 = v23;
              v27 = v18;
              do
              {
                v28 = v27->u8[0];
                v27 = (int8x8_t *)((char *)v27 + 1);
                *(_QWORD *)v26 = v28;
                v26 += 8;
                --v22;
              }
              while (v22);
            }
            goto LABEL_59;
          case 3:
            if (v22)
            {
              v31 = v23;
              v32 = v18;
              do
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabShort(v32);
                v33 = v32->u16[0];
                v32 = (int8x8_t *)((char *)v32 + 2);
                *(_QWORD *)v31 = v33;
                v31 += 8;
                --v22;
              }
              while (v22);
            }
            goto LABEL_59;
          case 4:
            if (v22)
            {
              v34 = v23;
              v35 = (__int32 *)v18;
              do
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  v24 = TIFFSwabLong(v35, (uint8x8_t)v24);
                v36 = *v35++;
                *(_QWORD *)v34 = v36;
                v34 += 8;
                --v22;
              }
              while (v22);
            }
            goto LABEL_59;
          case 6:
            if (!v22)
              goto LABEL_59;
            v37 = v23;
            v38 = v18;
            while (1)
            {
              v39 = v38->u8[0];
              if (((v39 >> 5) & 4) != 0)
                break;
              v38 = (int8x8_t *)((char *)v38 + 1);
              *(_QWORD *)v37 = (char)v39;
              v37 += 8;
              if (!--v22)
                goto LABEL_59;
            }
            v17 = (v39 >> 5) & 4;
            goto LABEL_63;
          case 8:
            if (!v22)
              goto LABEL_59;
            v40 = v23;
            v41 = v18;
            while (1)
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabShort(v41);
              v42 = v41->u16[0];
              if (((v42 >> 13) & 4) != 0)
                break;
              v41 = (int8x8_t *)((char *)v41 + 2);
              *(_QWORD *)v40 = (__int16)v42;
              v40 += 8;
              if (!--v22)
                goto LABEL_59;
            }
            v17 = (v42 >> 13) & 4;
            goto LABEL_63;
          case 9:
            if (!v22)
              goto LABEL_59;
            v43 = v23;
            v44 = (__int32 *)v18;
            break;
          default:
            goto LABEL_59;
        }
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v24 = TIFFSwabLong(v44, (uint8x8_t)v24);
          v45 = *v44;
          if (((v45 >> 29) & 4) != 0)
            break;
          ++v44;
          *(_QWORD *)v43 = v45;
          v43 += 8;
          if (!--v22)
          {
LABEL_59:
            _TIFFfreeExt(a1, (char *)v18);
            v17 = 0;
            *a3 = (int8x8_t *)v25;
            return v17;
          }
        }
        v17 = (v45 >> 29) & 4;
LABEL_63:
        _TIFFfreeExt(a1, (char *)v18);
        v29 = a1;
        v30 = v25;
        goto LABEL_64;
      }
      _TIFFfreeExt(a1, (char *)v18);
      return 7;
    }
  }
  return v17;
}

uint64_t TIFFReadDirEntryArrayWithLimit(uint64_t a1, uint64_t a2, _DWORD *a3, unsigned int a4, void **a5, unint64_t a6)
{
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  unint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  void *v29;
  _QWORD *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34[2];
  void *v35;

  v12 = TIFFDataWidth(*(unsigned __int16 *)(a2 + 2));
  v18 = *(_QWORD *)(a2 + 8);
  if (v18 >= a6)
    v19 = a6;
  else
    v19 = *(_QWORD *)(a2 + 8);
  if (v19)
    v20 = v12 == 0;
  else
    v20 = 1;
  if (!v20)
  {
    v22 = v12;
    if (v18 >= 0xA)
      LODWORD(v23) = 10;
    else
      v23 = *(_QWORD *)(a2 + 8);
    if (v19 > 0x7FFFFFFF / v12 || v19 > 0x7FFFFFFF / a4)
      return 6;
    *a3 = v19;
    v25 = v12 * v19;
    if (!(_DWORD)v25)
      TIFFReadDirEntryArrayWithLimit_cold_1();
    if (v25 >= 0x6400001 && (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200)) < v25)
    {
      TIFFWarningExtR(a1, "ReadDirEntryArray", "Requested memory size for tag %d (0x%x) %u is greater than filesize %llu. Memory not allocated, tag not read", v26, v13, v14, v15, v16, *(_WORD *)a2);
      return 7;
    }
    v27 = *(_DWORD *)(a1 + 16);
    if ((v27 & 0x800) != 0)
    {
      if (*(_QWORD *)(a1 + 1176) < v25)
        return 3;
    }
    else
    {
      v28 = v27 & 0x80000;
      if (v25 >= 9 && v28 || v25 >= 5 && !v28)
      {
        v29 = 0;
        v35 = 0;
        goto LABEL_31;
      }
    }
    v30 = _TIFFCheckMalloc((const char **)a1, *a3, (int)v22, (uint64_t)"ReadDirEntryArray", v13, v14, v15, v16);
    v35 = v30;
    if (!v30)
      return 7;
    v29 = v30;
    v27 = *(_DWORD *)(a1 + 16);
LABEL_31:
    v31 = v22 * v23;
    if ((v27 & 0x80000) != 0)
    {
      if (v31 > 8 || v25 > 8)
      {
        *(_QWORD *)v34 = *(_QWORD *)(a2 + 16);
        if ((v27 & 0x80) != 0)
        {
          TIFFSwabLong8((int8x8_t *)v34);
          v27 = *(_DWORD *)(a1 + 16);
        }
        v32 = *(_QWORD *)v34;
        if ((v27 & 0x800) == 0)
          goto LABEL_37;
        goto LABEL_45;
      }
    }
    else if (v31 > 4 || v25 > 4)
    {
      v34[0] = *(_DWORD *)(a2 + 16);
      if ((v27 & 0x80) != 0)
      {
        TIFFSwabLong(v34, v17);
        v27 = *(_DWORD *)(a1 + 16);
      }
      v32 = v34[0];
      if ((v27 & 0x800) == 0)
      {
LABEL_37:
        v33 = TIFFReadDirEntryDataAndRealloc(a1, v32, v25, (char **)&v35);
        goto LABEL_46;
      }
LABEL_45:
      v33 = TIFFReadDirEntryData(a1, v32, v25, v29);
LABEL_46:
      v21 = v33;
      if ((_DWORD)v33)
      {
        _TIFFfreeExt(a1, (char *)v35);
        return v21;
      }
LABEL_48:
      v21 = 0;
      *a5 = v35;
      return v21;
    }
    _TIFFmemcpy(v29, (const void *)(a2 + 16), v25);
    goto LABEL_48;
  }
  v21 = 0;
  *a5 = 0;
  return v21;
}

_QWORD *_TIFFCheckMalloc(const char **a1, int64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _TIFFCheckRealloc(a1, 0, a2, a3, a4, a6, a7, a8);
}

uint64_t TIFFDataWidth(unsigned int a1)
{
  if (a1 > 0x12)
    return 0;
  else
    return dword_18820F178[a1];
}

void *_TIFFmalloc(void *result)
{
  if (result)
    return malloc_type_malloc((size_t)result, 0x2F5D605AuLL);
  return result;
}

_QWORD *_TIFFmallocExt(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *result;

  if (!a1)
    return _TIFFmalloc((void *)a2);
  v10 = a1[170];
  if (v10 >= 1 && v10 < a2)
  {
    TIFFErrorExtR((uint64_t)a1, "_TIFFmallocExt", "Memory allocation of %llu bytes is beyond the %llu byte limit defined in open options", a4, a5, a6, a7, a8, a2);
    return 0;
  }
  v12 = a1[171];
  if (v12 < 1)
    return _TIFFmalloc((void *)a2);
  v13 = a1[172];
  if (a2 > 0x7FFFFFFFFFFFFFEFLL || v12 - v13 < a2)
  {
    TIFFErrorExtR((uint64_t)a1, "_TIFFmallocExt", "Cumulated memory allocation of %llu + %llu bytes is beyond the %llu cumulated byte limit defined in open options", a4, a5, a6, a7, a8, v13);
    return 0;
  }
  result = _TIFFmalloc((void *)(a2 + 16));
  if (result)
  {
    a1[172] += a2;
    *result = a2;
    result += 2;
  }
  return result;
}

uint64_t TIFFReadDirEntryDataAndRealloc(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  _BOOL4 v15;
  BOOL v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if ((*(_BYTE *)(a1 + 17) & 8) != 0)
    TIFFReadDirEntryDataAndRealloc_cold_1();
  if (!_TIFFSeekOK(a1, a2))
    return 3;
  v12 = 0;
  v13 = 0x100000;
  while (1)
  {
    if (a3 <= v12)
      return 0;
    v14 = a3 - v12 >= v13;
    v15 = v13 < 1048576000;
    v16 = v15 && v14;
    v17 = v15 && v14 ? v13 : a3 - v12;
    v18 = (char *)_TIFFreallocExt((_QWORD *)a1, *a4, v17 + v12, v7, v8, v9, v10, v11);
    if (!v18)
      break;
    if (v16)
      v13 *= 10;
    *a4 = v18;
    v24 = (*(uint64_t (**)(_QWORD, char *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v18[v12], v17);
    v12 += v24;
    if (v24 != v17)
      return 3;
  }
  TIFFErrorExtR(a1, *(const char **)a1, "Failed to allocate memory for %s (%lld elements of %lld bytes each)", v19, v20, v21, v22, v23, (char)"TIFFReadDirEntryArray");
  return 7;
}

_QWORD *_TIFFCheckRealloc(const char **a1, char *a2, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  uint64_t v11;
  BOOL v12;
  _QWORD *result;

  v8 = a5;
  if (a3 < 1
    || a4 < 1
    || ((v11 = a4 * a3, 0x7FFFFFFFFFFFFFFFuLL / a4 >= a3) ? (v12 = v11 == 0) : (v12 = 1),
        v12 || (result = _TIFFreallocExt(a1, a2, v11, a4, a5, a6, a7, a8)) == 0))
  {
    TIFFErrorExtR((uint64_t)a1, *a1, "Failed to allocate memory for %s (%lld elements of %lld bytes each)", a4, a5, a6, a7, a8, v8);
    return 0;
  }
  return result;
}

void *_TIFFrealloc(void *a1, size_t a2)
{
  return malloc_type_realloc(a1, a2, 0xCE847D52uLL);
}

_QWORD *_TIFFreallocExt(_QWORD *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *result;
  uint64_t v16;
  uint64_t v17;

  if (!a1)
    return _TIFFrealloc(a2, a3);
  v10 = a1[170];
  if (v10 >= 1 && v10 < a3)
  {
    TIFFErrorExtR((uint64_t)a1, "_TIFFreallocExt", "Memory allocation of %llu bytes is beyond the %llu byte limit defined in open options", a4, a5, a6, a7, a8, a3);
    return 0;
  }
  v12 = a1[171];
  if (v12 < 1)
    return _TIFFrealloc(a2, a3);
  if (a2)
  {
    v14 = *((_QWORD *)a2 - 2);
    a2 -= 16;
    v13 = v14;
    if (v14 > a1[172])
      _TIFFreallocExt_cold_1();
  }
  else
  {
    v13 = 0;
  }
  v16 = a3 - v13;
  if (a3 > v13)
  {
    v17 = a1[172];
    if (a3 > 0x7FFFFFFFFFFFFFEFLL || v13 + v12 - v17 < a3)
    {
      TIFFErrorExtR((uint64_t)a1, "_TIFFreallocExt", "Cumulated memory allocation of %llu + %llu bytes is beyond the %llu cumulated byte limit defined in open options", a4, a5, a6, a7, a8, v17);
      return 0;
    }
  }
  result = _TIFFrealloc(a2, a3 + 16);
  if (result)
  {
    a1[172] += v16;
    *result = a3;
    result += 2;
  }
  return result;
}

BOOL _TIFFSeekOK(uint64_t a1, uint64_t a2)
{
  return (a2 & 0x8000000000000000) == 0
      && (*(uint64_t (**)(_QWORD))(a1 + 1224))(*(_QWORD *)(a1 + 1200)) == a2;
}

unint64_t myTIFFSeekProc(IIOImageReadSession **a1, unint64_t a2, int a3)
{
  IIOImageWriteSession *v4;

  if (!a1)
    return 0;
  if (a1[2])
    return IIOImageReadSession::seek(a1[2], a2, a3);
  v4 = a1[3];
  if (v4)
    return IIOImageWriteSession::seek(v4, a2, a3);
  else
    return 0;
}

uint64_t ImageIOPixelConverter::CreatePixelConverter(uint64_t a1)
{
  uint64_t v1;
  uint64_t v4;

  v1 = 0;
  switch(*(_DWORD *)a1)
  {
    case 0:
      v1 = operator new();
      IIOPixelConverterGray::IIOPixelConverterGray(v1, *(_BYTE *)(a1 + 4), *(_BYTE *)(a1 + 8), *(unsigned __int8 *)(a1 + 10), *(unsigned __int8 *)(a1 + 6), *(_BYTE *)(a1 + 5), *(unsigned __int8 *)(a1 + 12), *(_BYTE *)(a1 + 14), 0);
      break;
    case 1:
      v1 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v1, *(_BYTE *)(a1 + 4), *(_BYTE *)(a1 + 8), *(unsigned __int8 *)(a1 + 10), *(unsigned __int8 *)(a1 + 10), *(unsigned __int8 *)(a1 + 10), *(unsigned __int8 *)(a1 + 6), *(_BYTE *)(a1 + 5), *(_BYTE *)(a1 + 12), *(_BYTE *)(a1 + 14), 0);
      break;
    case 2:
      v1 = operator new();
      IIOPixelConverterCMYK::IIOPixelConverterCMYK(v1, *(_BYTE *)(a1 + 4), *(_BYTE *)(a1 + 8), *(unsigned __int8 *)(a1 + 10), *(unsigned __int8 *)(a1 + 10), *(unsigned __int8 *)(a1 + 10), *(unsigned __int8 *)(a1 + 10), 0, *(_BYTE *)(a1 + 5), *(_BYTE *)(a1 + 12), *(_BYTE *)(a1 + 14), 0);
      break;
    case 3:
      v1 = operator new();
      LOBYTE(v4) = 0;
      IIOPixelConverterLab::IIOPixelConverterLab(v1, *(_BYTE *)(a1 + 4), *(_BYTE *)(a1 + 8), *(unsigned __int8 *)(a1 + 10), *(unsigned __int8 *)(a1 + 6), *(_BYTE *)(a1 + 5), *(unsigned __int8 *)(a1 + 12), *(_BYTE *)(a1 + 14), v4, 0);
      break;
    case 5:
      v1 = operator new();
      IIOPixelConverterIndexed::IIOPixelConverterIndexed(v1, *(_BYTE *)(a1 + 4), *(_BYTE *)(a1 + 8), *(unsigned __int8 *)(a1 + 10), *(_BYTE *)(a1 + 5), *(unsigned __int8 *)(a1 + 12), *(_BYTE *)(a1 + 14), 0);
      break;
    default:
      return v1;
  }
  return v1;
}

void sub_187EA5AC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C4050BC5624);
  _Unwind_Resume(a1);
}

void IIOPixelConverterRGB::~IIOPixelConverterRGB(IIOPixelConverterRGB *this)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(this);
  JUMPOUT(0x18D761C30);
}

void ImageIOPixelConverter::~ImageIOPixelConverter(ImageIOPixelConverter *this)
{
  vImageConverter *v1;

  *(_QWORD *)this = off_1E1BB2228;
  v1 = (vImageConverter *)*((_QWORD *)this + 1);
  if (v1)
    vImageConverter_Release(v1);
}

uint64_t IIOPixelConverterRGB::IIOPixelConverterRGB(uint64_t a1, char a2, char a3, uint32_t a4, int a5, int a6, int a7, char a8, unsigned __int8 a9, char a10, uint64_t a11)
{
  int v13;
  int v14;
  int v15;
  unsigned int v17;
  int v18;
  CGBitmapInfo v19;
  BOOL v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  CGBitmapInfo v27;
  int v28;
  vImageConverterRef v29;
  const char *v30;
  vImage_CGImageFormat destFormat;
  vImage_CGImageFormat srcFormat;
  vImage_Error error;

  *(_BYTE *)(a1 + 72) = 0;
  error = 0;
  *(_QWORD *)a1 = &off_1E1BB1FB0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 49) = a8;
  *(_QWORD *)(a1 + 24) = a11;
  *(_BYTE *)(a1 + 17) = 1;
  *(_BYTE *)(a1 + 65) = a10;
  *(_BYTE *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 36) = (a4 << 24) | (a5 << 16) | (a6 << 8) | a7;
  if (a7)
    v13 = a9;
  else
    v13 = 0;
  *(_DWORD *)(a1 + 52) = (16843008 * a9) | v13;
  *(_BYTE *)(a1 + 73) = 0;
  ImageIOPixelConverter::extractInfo(a1);
  v14 = *(_DWORD *)(a1 + 36);
  if (v14 > 134744318)
  {
    if (v14 == 168430082)
      goto LABEL_10;
    v15 = 134744319;
  }
  else
  {
    if (v14 == 84215041)
      goto LABEL_10;
    v15 = 84280831;
  }
  if (v14 == v15)
    goto LABEL_10;
  *(_BYTE *)(a1 + 16) = 1;
  if (v14 == 134744072 && *(_DWORD *)(a1 + 52) == 134744072)
  {
    switch(*(_BYTE *)(a1 + 32))
    {
      case 2:
        *(_BYTE *)(a1 + 73) = 1;
        v17 = (*(_BYTE *)(a1 + 49) - 2);
        if (v17 >= 4)
          goto LABEL_10;
        break;
      case 3:
        *(_BYTE *)(a1 + 73) = 1;
        v23 = (*(_BYTE *)(a1 + 49) - 2);
        if (v23 >= 4)
          goto LABEL_10;
        v17 = v23 + 4;
        break;
      case 4:
        *(_BYTE *)(a1 + 73) = 1;
        v24 = (*(_BYTE *)(a1 + 49) - 2);
        if (v24 >= 4)
          goto LABEL_10;
        v17 = v24 + 8;
        break;
      case 5:
        *(_BYTE *)(a1 + 73) = 1;
        v25 = (*(_BYTE *)(a1 + 49) - 2);
        if (v25 >= 4)
          goto LABEL_10;
        v17 = v25 + 12;
        break;
      default:
        goto LABEL_17;
    }
    *(_DWORD *)(a1 + 68) = v17;
    goto LABEL_10;
  }
LABEL_17:
  if (*(_BYTE *)(a1 + 73))
  {
LABEL_10:
    *(_BYTE *)(a1 + 16) = 0;
    return a1;
  }
  memset(&srcFormat.colorSpace, 0, 32);
  v18 = *(unsigned __int8 *)(a1 + 41);
  srcFormat.bitsPerComponent = a4;
  srcFormat.bitsPerPixel = v18 * a4;
  v19 = *(_DWORD *)(a1 + 44);
  srcFormat.bitmapInfo = v19;
  v20 = a4 == 8 && v18 == 4;
  v21 = !v20;
  if (v20)
  {
    v22 = 0x4000;
  }
  else
  {
    if (a4 != 16)
    {
      v21 = 0;
      goto LABEL_39;
    }
    srcFormat.bitmapInfo = v19 | 0x1000;
    if (*(_BYTE *)(a1 + 32) != 22)
    {
      v21 = 1;
      goto LABEL_39;
    }
    v22 = 4352;
  }
  srcFormat.bitmapInfo = v19 | v22;
LABEL_39:
  memset(&destFormat.colorSpace, 0, 32);
  v26 = *(unsigned __int8 *)(a1 + 56);
  destFormat.bitsPerComponent = a9;
  destFormat.bitsPerPixel = v26 * a9;
  v27 = *(_DWORD *)(a1 + 60);
  destFormat.bitmapInfo = v27;
  if (a9 == 8 && v26 == 4)
  {
    if ((*(_BYTE *)(a1 + 49) - 2) >= 4u)
      v28 = 0x4000;
    else
      v28 = dword_18822E270[(char)(*(_BYTE *)(a1 + 49) - 2)];
  }
  else if (a9 == 16)
  {
    v28 = 4096;
  }
  else
  {
    if (a9 != 32)
      goto LABEL_49;
    v28 = 0x2000;
  }
  v27 |= v28;
  destFormat.bitmapInfo = v27;
LABEL_49:
  if (v21 && *(_BYTE *)(a1 + 49) == 22)
    destFormat.bitmapInfo = v27 | 0x100;
  v29 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0, &error);
  *(_QWORD *)(a1 + 8) = v29;
  if (!v29 || error)
  {
    v30 = IIO_vImageErrorString(error);
    _cg_jpeg_mem_term("IIOPixelConverterRGB", 1078, "*** IIOPixelConverterRGB could not create vImageConverter '%s'\n", v30);
  }
  return a1;
}

{
  return IIOPixelConverterRGB::IIOPixelConverterRGB(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

void sub_187EA5E9C(_Unwind_Exception *a1)
{
  ImageIOPixelConverter *v1;

  ImageIOPixelConverter::~ImageIOPixelConverter(v1);
  _Unwind_Resume(a1);
}

uint64_t ImageIOPixelConverter::extractInfo(uint64_t this)
{
  unint64_t v1;
  int v2;
  char v3;
  char v4;
  unint64_t v5;
  char v6;
  char v7;
  int v8;

  v1 = *(char *)(this + 32);
  if (v1 <= 0x18)
  {
    v2 = dword_18822E1D4[v1];
    v3 = byte_18822E238[v1];
    v4 = byte_18822E251[v1];
    *(_DWORD *)(this + 44) = v2;
    *(_BYTE *)(this + 41) = v3;
    *(_BYTE *)(this + 48) = v4;
  }
  v5 = *(char *)(this + 49);
  if (v5 <= 0x18)
  {
    v6 = byte_18822E238[v5];
    v7 = byte_18822E251[v5];
    *(_DWORD *)(this + 60) = dword_18822E1D4[v5];
    *(_BYTE *)(this + 56) = v6;
    *(_BYTE *)(this + 64) = v7;
  }
  *(_DWORD *)(this + 68) = 0;
  if (*(_BYTE *)(this + 41) == 3)
  {
    v8 = *(unsigned __int8 *)(this + 64);
    if (*(_DWORD *)(this + 60) == 4)
      v8 |= 2u;
    if (*(_BYTE *)(this + 48))
      v8 |= 4u;
LABEL_18:
    *(_DWORD *)(this + 68) = v8 | 8;
    return this;
  }
  if (*(_BYTE *)(this + 56) == 4)
  {
    v8 = *(unsigned __int8 *)(this + 64);
    if (*(_BYTE *)(this + 64))
    {
      v8 = 1;
      *(_DWORD *)(this + 68) = 1;
    }
    if (*(_DWORD *)(this + 60) == 4)
    {
      v8 |= 2u;
      *(_DWORD *)(this + 68) = v8;
    }
    if (*(_BYTE *)(this + 48))
    {
      v8 |= 4u;
      *(_DWORD *)(this + 68) = v8;
    }
    if (*(_DWORD *)(this + 44) == 4)
      goto LABEL_18;
  }
  return this;
}

unint64_t IIOReadPlugin::getPixelConverterCreationParams(IIOReadPlugin *this)
{
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  IIOReadPlugin *v5;
  unsigned __int8 v6;

  v2 = *((unsigned int *)this + 80);
  v3 = *((unsigned __int8 *)this + 246);
  if (*((_BYTE *)this + 246))
    v4 = (unint64_t)*((unsigned __int8 *)this + 240) << 48;
  else
    v4 = 0;
  v5 = (IIOReadPlugin *)IIOReadPlugin::determinePixelType(this, (CGColorSpaceModel)*((_DWORD *)this + 80), *((unsigned __int8 *)this + 310));
  v6 = v5;
  if ((_DWORD)v5 == 2)
  {
    if (*((_BYTE *)this + 404) == 1)
      v6 = 3;
    else
      v6 = 2;
  }
  return v4 | ((unint64_t)v6 << 40) | (IIOReadPlugin::determinePixelType(v5, (CGColorSpaceModel)v2, v3) << 32) | v2;
}

uint64_t IIOReadPlugin::determinePixelType(IIOReadPlugin *this, CGColorSpaceModel a2, unsigned int a3)
{
  unsigned __int8 v3;
  BOOL v4;
  char v5;
  unint64_t v6;
  unint64_t v7;

  v3 = -1;
  switch(a2)
  {
    case kCGColorSpaceModelMonochrome:
      v4 = a3 >= 7;
      v5 = 8 * a3;
      v6 = 0x7080708070806;
      goto LABEL_7;
    case kCGColorSpaceModelRGB:
      v4 = a3 >= 7;
      v5 = 8 * a3;
      v6 = 0x4020402040200;
      goto LABEL_7;
    case kCGColorSpaceModelCMYK:
      v4 = a3 >= 7;
      v5 = 8 * a3;
      v6 = 0xA0B0A0B0A0B09;
      goto LABEL_7;
    case kCGColorSpaceModelLab:
      v4 = a3 >= 7;
      v5 = 8 * a3;
      v6 = 0xF100F100F100ELL;
      goto LABEL_7;
    case kCGColorSpaceModelIndexed:
      v4 = a3 >= 7;
      v5 = 8 * a3;
      v6 = 0xD0D0D0D0D0D0CLL;
LABEL_7:
      v7 = v6 >> v5;
      if (v4)
        v3 = -1;
      else
        v3 = v7;
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t _TIFFtrue()
{
  return 1;
}

uint64_t _CGImageWriteSessionFinalize(_QWORD *a1)
{
  unint64_t v2;
  uint64_t result;

  do
    v2 = __ldxr(&gWriteSessionCount);
  while (__stxr(v2 - 1, &gWriteSessionCount));
  result = a1[3];
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImageWriteSession::~IIOImageWriteSession(IIOImageWriteSession *this)
{
  IIOImageWriteSession::~IIOImageWriteSession(this);
  JUMPOUT(0x18D761C30);
}

{
  const void *v2;
  const void *v3;
  FILE *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_1E1BB1F60;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 2) = 0;
  v3 = (const void *)*((_QWORD *)this + 3);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 3) = 0;
  v4 = (FILE *)*((_QWORD *)this + 4);
  if (v4)
  {
    if ((gIIODebugFlags & 0x200000000000) != 0)
    {
      ImageIOLog("<<< _CGImageWriteSessionFinalize: [%p] closing FILE* %p\n", this, v4);
      v4 = (FILE *)*((_QWORD *)this + 4);
    }
    fclose(v4);
    *((_BYTE *)this + 73) = 0;
  }
  *((_QWORD *)this + 4) = 0;
  v5 = (const void *)*((_QWORD *)this + 5);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 5) = 0;
  v6 = (const void *)*((_QWORD *)this + 6);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 6) = 0;
}

void WXMPMeta_SetErrorCallback_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  XMP_ReadWriteLock *v12;

  v12 = (XMP_ReadWriteLock *)(a1 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 16), 1);
  *a6 = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 216))(a1, a2, a3, a4, a5);
  XMP_AutoLock::~XMP_AutoLock(&v12);
}

uint64_t XMPMeta::SetErrorCallback(uint64_t this, unsigned __int8 (*a2)(BOOL (*)(void *, unsigned __int8, int, const char *), void *, unsigned __int8, int, const char *), BOOL (*a3)(void *, unsigned __int8, int, const char *), void *a4, int a5)
{
  if (!a2)
    XMPMeta::SetErrorCallback();
  *(_DWORD *)(this + 364) = 0;
  *(_BYTE *)(this + 368) = 0;
  *(_QWORD *)(this + 376) = a2;
  *(_QWORD *)(this + 384) = a3;
  *(_QWORD *)(this + 392) = a4;
  *(_DWORD *)(this + 360) = a5;
  return this;
}

CGImageRef CGImageSourceCreateThumbnailAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  const __CFDictionary *v3;
  IIODictionary *v6;
  unsigned int v7;
  CFTypeID v8;
  CFTypeID v9;
  int v10;
  int v11;
  uint64_t v12;
  CGImage *v13;
  int v14;
  unsigned __int8 v15;
  char v16;
  CGImage *v17;
  IIO_Reader *v18;
  int v19;
  IIO_Reader *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  CGColorSpace *ColorSpace;
  int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  IIO_Reader *v44;
  uint64_t v46;
  int v47;
  unsigned int Uint32ForKey;
  char v49;
  int BoolForKey;
  const __CFDictionary *v51[3];
  int v52;
  const __CFDictionary *v53[4];

  v3 = options;
  memset(v53, 0, 24);
  v6 = IIODictionary::IIODictionary((IIODictionary *)v53, options, 1);
  IIOPackSrcInputInfo(v6, index);
  kdebug_trace();
  IIOInitDebugFlags();
  v7 = (gIIODebugFlags >> 12) & 3;
  if (v7)
    ImageIODebugOptions(v7, "A", "CGImageSourceCreateThumbnailAtIndex", isrc, 0, index, v3);
  v52 = 0;
  if (!isrc)
  {
    LogError("CGImageSourceCreateThumbnailAtIndex", 5017, "*** ERROR: CGImageSourceCreateThumbnailAtIndex: source is nil\n");
LABEL_108:
    v13 = 0;
    v12 = 0;
    v14 = 0;
    Uint32ForKey = -1;
    LOBYTE(v10) = -1;
    v49 = -1;
    BoolForKey = 255;
    v47 = 255;
    goto LABEL_37;
  }
  v8 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v8 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCreateThumbnailAtIndex", 5018, "*** ERROR: CGImageSourceCreateThumbnailAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_108;
  }
  if (v3)
  {
    v9 = CFGetTypeID(v3);
    if (v9 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCreateThumbnailAtIndex", 5021, "*** ERROR: CGImageSourceCreateThumbnailAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
      v3 = 0;
    }
  }
  if (IIODictionary::containsKey((IIODictionary *)v53, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways")))BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v53, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways"));
  else
    BoolForKey = 255;
  if (IIODictionary::containsKey((IIODictionary *)v53, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent")))v49 = IIODictionary::getBoolForKey((IIODictionary *)v53, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent"));
  else
    v49 = -1;
  if (IIODictionary::containsKey((IIODictionary *)v53, CFSTR("kCGImageSourceCreateThumbnailWithTransform")))v10 = IIODictionary::getBoolForKey((IIODictionary *)v53, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
  else
    v10 = 255;
  if (IIODictionary::containsKey((IIODictionary *)v53, CFSTR("kCGImageSourceThumbnailMaxPixelSize")))
  {
    Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v53, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
    v11 = 1;
  }
  else
  {
    Uint32ForKey = -1;
    v11 = 255;
  }
  v47 = v11;
  v12 = *((_QWORD *)isrc + 3);
  if (v12 && !IIOImageSource::isProxy((IIOImageSource *)v12))
  {
    if (*(_BYTE *)(v12 + 65))
    {
      LogError("CGImageSourceCreateThumbnailAtIndex", 5041, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
      v13 = 0;
      v14 = 0;
    }
    else
    {
      v14 = 1848598816;
      if (BoolForKey == 1)
      {
        v15 = IIODictionary::containsKey((IIODictionary *)v53, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
        v16 = v10 == 255 ? v15 : 1;
        if ((v16 & 1) == 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)(v12 + 200));
          v17 = IIOImageSource::createImageAtIndex((IIOImageSource *)v12, index, v53, &v52);
          v18 = *(IIO_Reader **)(v12 + 80);
          v19 = 1848598816;
          if (v18)
            v19 = IIO_Reader::osType(v18);
          pthread_mutex_unlock((pthread_mutex_t *)(v12 + 200));
          if (v17)
            goto LABEL_47;
        }
      }
      pthread_mutex_lock((pthread_mutex_t *)(v12 + 200));
      v13 = IIOImageSource::createThumbnailAtIndex((IIOImageSource *)v12, index, v53, &v52);
      v20 = *(IIO_Reader **)(v12 + 80);
      if (v20)
        v14 = IIO_Reader::osType(v20);
      pthread_mutex_unlock((pthread_mutex_t *)(v12 + 200));
    }
  }
  else
  {
    LogError("CGImageSourceCreateThumbnailAtIndex", 5067, "*** ERROR: CGImageSourceGetSource returned NULL\n");
    v13 = 0;
    v14 = 0;
  }
LABEL_37:
  v17 = v13;
  if ((gIIODebugFlags & 0x800000000000) != 0)
  {
    v17 = v13;
    if (!v13)
    {
      ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCreateThumbnailAtIndex", 5071, "could not create thumbnail-CGImageRef");
      v17 = 0;
    }
  }
  if (v13 || !v12)
  {
    v19 = v14;
    if (!v17)
      goto LABEL_105;
    goto LABEL_47;
  }
  if (IIOImageSource::isProxy((IIOImageSource *)v12))
    goto LABEL_102;
  kdebug_trace();
  LODWORD(v21) = v14 >> 24;
  if (v3)
  {
    v22 = MEMORY[0x1E0C80978];
    v23 = v14 < 0
        ? __maskrune(v14 >> 24, 0x40000uLL)
        : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v21 + 60) & 0x40000;
    v26 = v23 ? v21 : 46;
    v46 = v26;
    v27 = v14 << 8 >> 24;
    v28 = v14 << 8 < 0 ? __maskrune(v14 << 8 >> 24, 0x40000uLL) : *(_DWORD *)(v22 + 4 * v27 + 60) & 0x40000;
    v29 = v28 ? v27 : 46;
    v30 = (__int16)v14 >> 8;
    if (v14 << 16 < 0)
    {
      v32 = __maskrune((__int16)v14 >> 8, 0x40000uLL);
      v31 = v22;
    }
    else
    {
      v31 = v22;
      v32 = *(_DWORD *)(v22 + 4 * v30 + 60) & 0x40000;
    }
    v33 = (v14 << 24) <= 0x7F000000
        ? *(_DWORD *)(v31 + 4 * (char)v14 + 60) & 0x40000
        : __maskrune((char)v14, 0x40000uLL);
    v34 = v32 ? v30 : 46;
    v35 = v33 ? (char)v14 : 46;
    LogError("CGImageSourceCreateThumbnailAtIndex", 5079, "*** ERROR: CGImageSourceCreateThumbnailAtIndex[%ld] - '%c%c%c%c' - failed to create thumbnail [%d] {alw:%d, abs: %d tra:%d max:%d}\n", index, v46, v29, v34, v35, v52, (char)BoolForKey, v49, (char)v10, Uint32ForKey);
  }
  else
  {
    v25 = v14 < 0
        ? __maskrune(v14 >> 24, 0x40000uLL)
        : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v21 + 60) & 0x40000;
    v21 = v25 ? v21 : 46;
    v36 = v14 << 8 >> 24;
    v37 = v14 << 8 < 0
        ? __maskrune(v14 << 8 >> 24, 0x40000uLL)
        : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v36 + 60) & 0x40000;
    v38 = v37 ? v36 : 46;
    v39 = (__int16)v14 >> 8;
    v40 = v14 << 16 < 0
        ? __maskrune((__int16)v14 >> 8, 0x40000uLL)
        : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v39 + 60) & 0x40000;
    v41 = (v14 << 24) <= 0x7F000000
        ? *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v14 + 60) & 0x40000
        : __maskrune((char)v14, 0x40000uLL);
    v42 = v40 ? v39 : 46;
    v43 = v41 ? (char)v14 : 46;
    LogError("CGImageSourceCreateThumbnailAtIndex", 5076, "*** ERROR: CGImageSourceCreateThumbnailAtIndex[%ld] - '%c%c%c%c' - failed to create thumbnail (no options) [%d]\n", index, v21, v38, v42, v43, v52);
  }
  if (BoolForKey != 255)
  {
LABEL_102:
    v17 = 0;
    v19 = v14;
    goto LABEL_105;
  }
  if (v47 != 1)
  {
    LogError("CGImageSourceCreateThumbnailAtIndex", 5096, "*** ERROR: CGImageSourceCreateThumbnailAtIndex[%ld]  'FromImageAlways' / 'FromImageIfAbsent' / 'ThumbnailMaxPixelSize' were not specified - no thumbnail created'\n", index);
    goto LABEL_102;
  }
  memset(v51, 0, sizeof(v51));
  IIODictionary::IIODictionary((IIODictionary *)v51, v3, 1);
  IIODictionary::setObjectForKey((IIODictionary *)v51, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageSourceCreateThumbnailFromImageAlways"));
  pthread_mutex_lock((pthread_mutex_t *)(v12 + 200));
  v17 = IIOImageSource::createThumbnailAtIndex((IIOImageSource *)v12, index, v51, &v52);
  v44 = *(IIO_Reader **)(v12 + 80);
  if (v44)
    v19 = IIO_Reader::osType(v44);
  else
    v19 = 1848598816;
  pthread_mutex_unlock((pthread_mutex_t *)(v12 + 200));
  IIODictionary::~IIODictionary((IIODictionary *)v51);
  if (v17)
  {
LABEL_47:
    CGImageGetWidth(v17);
    CGImageGetHeight(v17);
    CGImageGetBitsPerPixel(v17);
    CGImageGetBitsPerComponent(v17);
    ColorSpace = CGImageGetColorSpace(v17);
    CGColorSpaceGetModel(ColorSpace);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(v17);
    if ((gIIODebugFlags & 0x10000000) != 0)
    {
      CFShow(v17);
      CGImageDumpToFile();
    }
  }
LABEL_105:
  kdebug_trace();
  IIO_CheckHeadroom("CGImageSourceCreateThumbnailAtIndex", v19, v17, (IIODictionary *)v53);
  IIODictionary::~IIODictionary((IIODictionary *)v53);
  return v17;
}

void sub_187EA6C7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 128));
  _Unwind_Resume(a1);
}

CGImage *IIOImageSource::createThumbnailAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3, int *a4)
{
  CGImage *v8;
  const void *v9;
  CGImage *v10;
  _BOOL4 BoolForKey;
  int v12;
  unsigned int v13;
  _BOOL4 v14;
  unsigned __int8 Uint32ForKey;
  unsigned int v16;
  BOOL v17;
  char v18;
  int v19;
  _BOOL4 v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  const char *v24;
  const __CFString *ObjectForKey;
  int v26;
  double v27;
  unsigned int v28;
  uint64_t v29;
  _QWORD *v30;
  double v31;
  int v32;
  const void *v33;
  int v34;
  const void *v35;
  uint64_t Source;
  const __CFDictionary **v37;
  CGImage *v38;
  IIOImagePlus *v39;
  IIODictionary *ImagePropertiesAtIndex;
  int v41;
  int v42;
  unsigned __int8 v43;
  int v44;
  int v45;
  unsigned int v46;
  unsigned __int8 v47;
  IIODictionary *v48;
  IIODictionary *PropertiesAtIndexInternal;
  IIODictionary *v50;
  const __CFString *v51;
  int v52;
  IIODictionary *Properties;
  int v54;
  uint64_t v55;
  int v56;
  unsigned __int8 v57;
  char *v58;
  unsigned __int8 v59;
  int v60;
  int v61;
  IIODictionary *v62;
  unsigned int v63;
  int v64;
  int v65;
  const char *v66;
  int v67;
  unsigned int v68;
  int v69;
  IIODictionary *v70;
  int v71;
  signed int v72;
  unsigned int v73;
  unsigned int v74;
  int v75;
  int v76;
  unsigned int v77;
  unsigned int v78;
  int v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  int v85;
  CGImage *Image;
  CGImage *v87;
  unsigned int Height;
  unsigned int v89;
  uint64_t v91;
  float FloatForKey;
  float v93;
  _BOOL4 v94;
  float v95;
  unsigned int v96;
  unsigned int v97;
  double v98;
  double v99;
  double v100;
  double v101;
  double v102;
  double v103;
  double v104;
  double v105;
  float v106;
  float v107;
  float v108;
  double v109;
  double v110;
  double v111;
  double v112;
  unint64_t v113;
  double v114;
  unint64_t v115;
  unint64_t v116;
  IIOImageSource *v117;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel v119;
  size_t v120;
  unsigned int v121;
  char v122;
  IIOImageReadSession *v123;
  CGColorSpaceModel Model;
  size_t BitsPerComponent;
  CGBitmapInfo BitmapInfo;
  CGBitmapInfo v127;
  int v128;
  int v129;
  BOOL v130;
  int v131;
  __IOSurface *v132;
  __IOSurface *v133;
  signed int PixelFormat;
  signed int v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unsigned int v142;
  int v143;
  uint64_t v144;
  unsigned int v145;
  int v146;
  uint64_t v147;
  unsigned int v148;
  uint64_t v149;
  int v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  unsigned int v154;
  int v155;
  IIO_Reader *v156;
  const __CFString *v157;
  CFComparisonResult v158;
  _BOOL4 v159;
  char v160;
  char v161;
  IIO_Reader *v162;
  const __CFString *v163;
  unsigned int v164;
  CGInterpolationQuality v165;
  unint64_t v167;
  CGColorRenderingIntent RenderingIntent;
  uint64_t ValidRows;
  int v170;
  IIODictionary *v171;
  IIODictionary *v172;
  IIODictionary *v173;
  unint64_t v175;
  unint64_t v176;
  unsigned __int8 v177;
  CGBitmapInfo v178;
  uint64_t v179;
  IIOImageReadSession *v180;
  IIOImageReadSession *v181;
  IIOImageReadSession *v182;
  IIODictionary *v183;
  int shouldCacheImageBlocks;
  BOOL v185[8];
  unint64_t v186;
  IIODictionary *v187;
  CGColorSpace *space;
  uint64_t v189;
  _BOOL4 v190;
  unsigned __int8 v191;
  float64x2_t v192;
  uint64_t v193;
  unsigned int v194;
  int v195;
  int *v196;
  unint64_t v197;
  IIODictionary **v198;
  unsigned int v199;
  unsigned int v200[2];
  int v201;
  _BYTE v202[24];
  CGAffineTransform v203;
  _BYTE v204[16];
  void *value;
  double v206;
  double v207;
  double v208;
  double v209;
  float64x2_t v210;
  __int128 v211;
  __int128 v212;
  uint64_t v213;
  unint64_t v214;
  CGImageAlphaInfo v215;
  unsigned int v216[2];
  int v217[3];

  v217[0] = -50;
  *(_QWORD *)v216 = 0;
  v215 = kCGImageAlphaNone;
  v214 = 0;
  v213 = 0;
  v211 = 0u;
  v212 = 0u;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if (!IIOImageSource::bindToReader(this))
    goto LABEL_305;
  if (IIOImageSource::updatedCount(this) <= a2)
  {
    v8 = 0;
    v9 = 0;
LABEL_12:
    v10 = 0;
    goto LABEL_305;
  }
  v196 = a4;
  v197 = a2;
  BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)a3, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways"));
  v12 = IIODictionary::getBoolForKey((IIODictionary *)a3, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent"));
  v13 = IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent"));
  v14 = IIODictionary::getBoolForKey((IIODictionary *)a3, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)a3, CFSTR("Orientation"));
  v16 = Uint32ForKey - 1;
  v17 = v16 >= 8;
  if (v16 >= 8)
    v18 = 1;
  else
    v18 = Uint32ForKey;
  v177 = v18;
  v19 = !v17 || v14;
  v201 = v19;
  if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceShouldCache")))
    v20 = IIODictionary::getBoolForKey((IIODictionary *)a3, CFSTR("kCGImageSourceShouldCache"));
  else
    v20 = 0;
  if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceThumbnailMaxPixelSize")))
  {
    v21 = IIODictionary::getUint32ForKey((IIODictionary *)a3, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
    if (!((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 10) + 184))(*((_QWORD *)this + 10)) | BoolForKey | v12))
      v12 |= v13 ^ 1;
  }
  else
  {
    v21 = 0;
  }
  IIOImageSource::updateThumbnailInfo(this, (IIODictionary *)a3, &v216[1], v216);
  if (v216[1] <= v216[0])
    v22 = v216[0];
  else
    v22 = v216[1];
  if (v21)
    v23 = v21;
  else
    v23 = v22;
  if (v216[1] && v216[0] && v23 > v216[1] && v23 > v216[0])
  {
    LogError("createThumbnailAtIndex", 2363, "*** ERROR: kCGImageSourceThumbnailMaxPixelSize: %d is larger than image-dimension: %dx%d\n", v23, v216[1], v216[0]);
    IIODictionary::removeObjectForKey((IIODictionary *)a3, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
    if (v216[1] <= v216[0])
      v23 = v216[0];
    else
      v23 = v216[1];
    v12 = 1;
  }
  v24 = getprogname();
  if (!strncasecmp("Camera", v24, 7uLL))
  {
    if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceDecodeRequest")))
    {
      ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)a3, CFSTR("kCGImageSourceDecodeRequest"));
      if (CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToHDR"), 0) == kCFCompareEqualTo)
      {
        if ((IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceDecodeRequestOptions")) & 1) == 0)
        {
          IIODictionary::IIODictionary((IIODictionary *)&v206);
          IIODictionary::setObjectForKey((IIODictionary *)a3, *(const void **)&v207, CFSTR("kCGImageSourceDecodeRequestOptions"));
          IIODictionary::~IIODictionary((IIODictionary *)&v206);
        }
        IIODictionary::setObjectForKeyGroup((IIODictionary *)a3, (const void *)*MEMORY[0x1E0C9AE40], CFSTR("kCGGenerateFlexGTC"), CFSTR("kCGImageSourceDecodeRequestOptions"));
        if (IIODictionary::getBoolForKeyGroup((IIODictionary *)a3, CFSTR("kCGGenerateFlexGTC"), CFSTR("kCGImageSourceDecodeRequestOptions")))LogError("createThumbnailAtIndex", 2387, "*** Camera - creating kCGGenerateFlexGTC\n");
      }
    }
  }
  *(_QWORD *)&v27 = IIOImageSource::getThumbnailInfoAtIndex((uint64_t)this, 0, v23, (uint64_t)&v211).n128_u64[0];
  v28 = HIDWORD(v211);
  if (HIDWORD(v211) <= v212)
    v28 = v212;
  if (v26)
    v28 = 0;
  v194 = v28;
  v29 = *((_QWORD *)this + 2);
  if (!v29)
  {
    _cg_jpeg_mem_term("createThumbnailAtIndex", 2405, "*** Error: imageReadRef returned NULL\n", v27);
LABEL_316:
    v8 = 0;
    v9 = 0;
LABEL_321:
    v10 = 0;
    a4 = v196;
    goto LABEL_305;
  }
  v30 = CGImageReadSessionCreate(*((const void **)this + 2));
  if (!v30)
  {
    _cg_jpeg_mem_term("createThumbnailAtIndex", 2408, "*** Error: CGImageReadSessionCreate returned NULL\n", v31);
    goto LABEL_316;
  }
  v199 = v23;
  v190 = BoolForKey;
  v32 = v12;
  v33 = v30;
  v34 = v20;
  CGImageSourceGetSource(v29);
  v35 = v33;
  Source = CGImageSourceGetSource((uint64_t)v33);
  v37 = (const __CFDictionary **)operator new();
  IIODictionary::IIODictionary((IIODictionary *)v37, a3[1], 1);
  IIODictionary::removeObjectForKey((IIODictionary *)v37, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways"));
  IIODictionary::removeObjectForKey((IIODictionary *)v37, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent"));
  if (((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 208))(*((_QWORD *)this + 10)) & 1) == 0)
    IIODictionary::removeObjectForKey((IIODictionary *)v37, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
  IIODictionary::removeObjectForKey((IIODictionary *)v37, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
  IIODictionary::removeObjectForKey((IIODictionary *)v37, CFSTR("kCGImageSourceSubsampleFactor"));
  IIODictionary::removeObjectForKey((IIODictionary *)v37, CFSTR("kCGImageSourceShouldPreferRGB32"));
  v10 = (CGImage *)CGImagePlusCreateWithSession(v33, *((_QWORD *)this + 14), v37[1], *((_QWORD *)this + 1));
  (*((void (**)(const __CFDictionary **))*v37 + 1))(v37);
  if (!v10)
  {
    _cg_jpeg_mem_term("createThumbnailAtIndex", 2432, "*** Error: ipRef is NULL\n");
    a4 = v196;
    v9 = v33;
    v8 = 0;
    goto LABEL_305;
  }
  v180 = (IIOImageReadSession *)Source;
  v38 = v10;
  v39 = (IIOImagePlus *)*((_QWORD *)v10 + 3);
  shouldCacheImageBlocks = IIOImagePlus::shouldCacheImageBlocks(v39);
  v198 = (IIODictionary **)v39;
  IIOImagePlus::setShouldCacheImageBlocks((uint64_t)v39, v34);
  ImagePropertiesAtIndex = (IIODictionary *)IIOImageSource::getImagePropertiesAtIndex(this, v197);
  v41 = v213;
  v42 = v201;
  if (v213 > 1u)
    v42 = 1;
  v183 = ImagePropertiesAtIndex;
  if (v42 == 1)
  {
    if (ImagePropertiesAtIndex
      && IIODictionary::containsKey(ImagePropertiesAtIndex, CFSTR("Orientation")))
    {
      v43 = IIODictionary::getUint32ForKey(v183, CFSTR("Orientation"));
      v187 = 0;
      v9 = v35;
      v8 = v38;
      v44 = v32;
      v45 = v190;
      v46 = v194;
    }
    else
    {
      v206 = 0.0;
      v207 = 0.0;
      v208 = 0.0;
      IIODictionary::IIODictionary((IIODictionary *)&v206);
      IIODictionary::setObjectForKey(v48, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageSourceSkipMetadata"));
      v9 = v35;
      v8 = v38;
      v44 = v32;
      v45 = v190;
      v46 = v194;
      PropertiesAtIndexInternal = IIOImageSource::getPropertiesAtIndexInternal(this, v197, (const __CFDictionary **)&v206);
      v50 = PropertiesAtIndexInternal;
      if (PropertiesAtIndexInternal
        && IIODictionary::containsKey(PropertiesAtIndexInternal, CFSTR("Orientation")))
      {
        v43 = IIODictionary::getUint32ForKey(v50, CFSTR("Orientation"));
      }
      else
      {
        v43 = 1;
      }
      v187 = v50;
      IIODictionary::~IIODictionary((IIODictionary *)&v206);
    }
    if ((v43 - 9) < 0xF8u)
      v47 = 1;
    else
      v47 = v43;
  }
  else
  {
    v187 = 0;
    v47 = 1;
    v9 = v35;
    v8 = v38;
    v44 = v32;
    v45 = v190;
    v46 = v194;
  }
  if (!v41)
    LOBYTE(v41) = v47;
  if (!(v46 | v199))
  {
    _cg_jpeg_mem_term("createThumbnailAtIndex", 2473, "*** NOTE: no kCGImageSourceThumbnailMaxPixelSize specified using 'full image size'\n");
    v45 = 1;
    v199 = 10000;
  }
  if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceDecodeRequest")))
  {
    v51 = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)a3, CFSTR("kCGImageSourceDecodeRequest"));
    if (CFStringCompare(v51, CFSTR("kCGImageSourceDecodeToHDR"), 0))
      CFStringCompare(v51, CFSTR("kCGImageSourceDecodeToSDR"), 0);
  }
  v191 = v41;
  if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 10) + 184))(*((_QWORD *)this + 10)))
  {
    v52 = v45 ^ 1;
    if (!BYTE2(v213))
      v52 = 1;
    if ((v45 & v52 & 1) != 0)
    {
      Properties = 0;
      v54 = 1;
      v45 = 1;
    }
    else
    {
      if (v46)
        v55 = v46;
      else
        v55 = v199;
      v217[0] = IIO_Reader::initializeThumbnail(*((const void ****)this + 10), (uint64_t)v8, v197, v55);
      if (v217[0])
      {
        v54 = 1;
      }
      else
      {
        v56 = v201;
        if (v201)
          v57 = v177;
        else
          v57 = v47;
        v58 = (char *)&byte_18820F0E2[8 * v41 + v57];
        v59 = v41;
        v54 = *(v58 - 9);
        if (v54 != v59)
          v56 = 1;
        v201 = v56;
      }
      IIOImagePlus::copyPropertiesToRoot(v198);
      Properties = (IIODictionary *)IIOImagePlus::getProperties((IIOImagePlus *)v198);
      v45 = 0;
    }
  }
  else
  {
    Properties = 0;
    v54 = 1;
  }
  v60 = v217[0];
  v61 = v44 | v45;
  if (!v217[0])
    v61 = 0;
  v195 = v61;
  if (v61 != 1)
  {
    a4 = v196;
    v70 = v187;
    v63 = v199;
    goto LABEL_130;
  }
  if (((v44 ^ 1 | v45) & 1) == 0)
  {
    v62 = (IIODictionary *)IIOImagePlus::getProperties((IIOImagePlus *)v198);
    IIODictionary::setObjectForKey(v62, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("needsPostProcessing"));
  }
  IIOImageReadSession::rewind((uint64_t)v180);
  v63 = v199;
  v64 = IIO_Reader::callInitializeImageAtOffset(*((_QWORD *)this + 10), (uint64_t)v8, v197, v199, 0, *((char *)this + 53));
  v217[0] = v64;
  if (v64 == -1400)
  {
    ImageIOLog("‼️ retrying 'initializeImageAtOffset' (ImageIOXPCService crashed?)\n");
    v65 = IIO_Reader::callInitializeImageAtOffset(*((_QWORD *)this + 10), (uint64_t)v8, v197, v199, 0, *((char *)this + 53));
    v217[0] = v65;
    v66 = "❌";
    if (!v65)
      v66 = "✅";
    ImageIOLog("%s retrying 'initializeImageAtOffset'  err: %d\n", v66, v65);
    v64 = v217[0];
  }
  a4 = v196;
  if (!v64)
  {
    if (v201
      && ((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 208))(*((_QWORD *)this + 10)) & 1) == 0)
    {
      v54 = byte_18820F0E2[8 * v47 - 9 + v177];
    }
    else
    {
      v54 = 1;
    }
    v70 = v187;
    goto LABEL_127;
  }
  v67 = IIO_Reader::osType(*((IIO_Reader **)this + 10));
  v68 = v67 >> 24;
  if (v67 < 0)
    v69 = __maskrune(v68, 0x40000uLL);
  else
    v69 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v68 + 60) & 0x40000;
  v70 = v187;
  if (v69)
    v71 = IIO_Reader::osType(*((IIO_Reader **)this + 10)) & 0xFF000000;
  else
    v71 = 771751936;
  v72 = IIO_Reader::osType(*((IIO_Reader **)this + 10)) << 8;
  v73 = v72 >> 24;
  if (v72 < 0)
  {
    if (__maskrune(v73, 0x40000uLL))
      goto LABEL_110;
  }
  else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v73 + 60) & 0x40000) != 0)
  {
LABEL_110:
    v74 = IIO_Reader::osType(*((IIO_Reader **)this + 10)) >> 16;
    goto LABEL_113;
  }
  LOBYTE(v74) = 46;
LABEL_113:
  v75 = IIO_Reader::osType(*((IIO_Reader **)this + 10));
  v76 = v75 << 16;
  v77 = (__int16)v75 >> 8;
  if (v76 < 0)
  {
    if (__maskrune(v77, 0x40000uLL))
      goto LABEL_115;
LABEL_117:
    LOBYTE(v78) = 46;
    goto LABEL_118;
  }
  if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v77 + 60) & 0x40000) == 0)
    goto LABEL_117;
LABEL_115:
  v78 = IIO_Reader::osType(*((IIO_Reader **)this + 10)) >> 8;
LABEL_118:
  v79 = IIO_Reader::osType(*((IIO_Reader **)this + 10));
  if ((v79 << 24) <= 0x7F000000)
    v80 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v79 + 60) & 0x40000;
  else
    v80 = __maskrune((char)v79, 0x40000uLL);
  v81 = (v71 >> 24);
  v82 = (char)v74;
  v83 = (char)v78;
  if (v80)
    v84 = IIO_Reader::osType(*((IIO_Reader **)this + 10));
  else
    v84 = 46;
  LogError("createThumbnailAtIndex", 2592, "*** ERROR: '%c%c%c%c' initialize image failed  err: %d\n", v81, v82, v83, v84, v217[0]);
  a4 = v196;
LABEL_127:
  v85 = v201;
  if (v54 != v191)
    v85 = 1;
  v201 = v85;
  IIOImagePlus::copyPropertiesToRoot(v198);
  Properties = (IIODictionary *)IIOImagePlus::getProperties((IIOImagePlus *)v198);
  v60 = v217[0];
LABEL_130:
  if (v60)
  {
    _cg_jpeg_mem_term("createThumbnailAtIndex", 2600, "*** ERROR: callInitializeImageAtOffset err:%d\n", v60);
    goto LABEL_12;
  }
  IIOImagePlus::setShouldCacheImageBlocks((uint64_t)v198, shouldCacheImageBlocks);
  Image = IIOImagePlus::createImage((IIOImagePlus *)v198, *((CGImageSource **)this + 1), v217);
  if (!Image)
  {
    _cg_jpeg_mem_term("createThumbnailAtIndex", 2608, "*** ERROR: createImage err:%d\n", v217[0]);
    goto LABEL_321;
  }
  v87 = Image;
  v216[1] = CGImageGetWidth(Image);
  Height = CGImageGetHeight(v87);
  v216[0] = Height;
  if (!v216[1] || !Height)
  {
    CFRelease(v87);
    goto LABEL_321;
  }
  if (v216[1] <= Height)
    v89 = Height;
  else
    v89 = v216[1];
  if (v63 > v216[1] && v63 > Height)
    v91 = v89;
  else
    v91 = v63;
  *(_QWORD *)v200 = v91;
  if (!v201)
  {
    if (Properties && IIODictionary::containsKey(Properties, "disorientation"))
      LOBYTE(v54) = IIODictionary::getUint32ForKey(Properties, CFSTR("disorientation"));
    goto LABEL_155;
  }
  if (!v70
    || !IIODictionary::containsKey(v70, CFSTR("DPIWidth"))
    || !IIODictionary::containsKey(v70, CFSTR("DPIHeight")))
  {
LABEL_155:
    FloatForKey = 72.0;
    v95 = 72.0;
    goto LABEL_156;
  }
  FloatForKey = IIODictionary::getFloatForKey(v70, CFSTR("DPIWidth"));
  v93 = IIODictionary::getFloatForKey(v70, CFSTR("DPIHeight"));
  v94 = FloatForKey < 1.0;
  if (v93 < 1.0)
    v94 = 1;
  if (v94)
  {
    FloatForKey = 72.0;
    v95 = 72.0;
  }
  else
  {
    v95 = v93;
  }
LABEL_156:
  if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 10) + 208))(*((_QWORD *)this + 10)))
  {
    v97 = v216[0];
    v96 = v216[1];
    IIOImageSource::makeThumbTransform(FloatForKey, v95, v216[1], v216[0], 1, (uint64_t)&v206);
  }
  else
  {
    v97 = v216[0];
    v96 = v216[1];
    IIOImageSource::makeThumbTransform(FloatForKey, v95, v216[1], v216[0], v54, (uint64_t)&v206);
  }
  v99 = v206;
  v98 = v207;
  v101 = v208;
  v100 = v209;
  v102 = (double)v96;
  v103 = (double)v97;
  v104 = v208 * (double)v97 + v206 * (double)v96;
  v105 = v209 * (double)v97 + v207 * (double)v96;
  v106 = v104;
  v107 = v105;
  v108 = (float)v200[0] / fmaxf(fabsf(v106), fabsf(v107));
  if (v108 >= 1.0)
  {
    v192 = v210;
    v111 = fabs(v104);
    v112 = fabs(v105);
  }
  else
  {
    v99 = v206 * v108;
    v98 = v207 * v108;
    v101 = v208 * v108;
    v100 = v209 * v108;
    v192 = vmulq_n_f64(v210, v108);
    v109 = v101 * v103 + v99 * v102;
    v110 = v100 * v103 + v98 * v102;
    v111 = fabs(v109);
    v112 = fabs(v110);
  }
  v113 = (unint64_t)rint(v111);
  v114 = rint(v112);
  if ((unint64_t)v114 <= 1)
    v115 = 1;
  else
    v115 = (unint64_t)v114;
  if (v113 <= 1)
    v116 = 1;
  else
    v116 = v113;
  v117 = (IIOImageSource *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 216))(*((_QWORD *)this + 10));
  if (v115 != v216[0] || v116 != v216[1] || !(_DWORD)v117)
  {
    v122 = v54;
    v123 = *(IIOImageReadSession **)v200;
    if (v116 >= v200[0])
      v116 = *(_QWORD *)v200;
    if (v115 < v200[0])
      v123 = (IIOImageReadSession *)v115;
    v181 = v123;
    space = IIOImageSource::createThumbnailColorspace(v117, v87, &v215, &v214);
    Model = CGColorSpaceGetModel(space);
    BitsPerComponent = CGImageGetBitsPerComponent(v87);
    BitmapInfo = CGImageGetBitmapInfo(v87);
    v127 = v215;
    v178 = BitmapInfo;
    if (BitsPerComponent == 32)
    {
      if (Model)
        BitsPerComponent = 32;
      else
        BitsPerComponent = 16;
      if (Model)
        v131 = 0x2000;
      else
        v131 = 4096;
      if ((v215 & 0x1F) - 1 >= 4)
      {
        if ((v215 & 0x1F) - 5 >= 2)
        {
          if ((v215 & 0x1F) == 0)
          {
            v155 = v131 | 5;
            if (v214 > 1)
              v127 = v155;
          }
        }
        else
        {
          v127 = v131 | 5;
        }
      }
      else
      {
        v127 = v131 | 1;
      }
      v127 |= 0x100u;
    }
    else if (BitsPerComponent == 16)
    {
      if ((v215 & 0x1F) - 1 >= 4)
      {
        if ((v215 & 0x1F) - 5 >= 2)
        {
          if ((v215 & 0x1F) == 0 && v214 > 1)
            v127 = 4101;
        }
        else
        {
          v127 = 4102;
        }
      }
      else
      {
        v127 = 4097;
      }
      v127 |= BitmapInfo & 0x100;
      BitsPerComponent = 16;
    }
    v186 = v116;
    v175 = v214;
    v176 = ImageIOAlignRowBytes(v214 * v116 * (BitsPerComponent >> 3), 0x10uLL);
    v156 = (IIO_Reader *)*((_QWORD *)this + 10);
    if (v156)
    {
      v157 = (const __CFString *)IIO_Reader::utType(v156);
      v158 = CFStringCompare(v157, CFSTR("com.leafamerica.raw-image"), 0);
      v159 = 0;
      v160 = v201;
      if (v122 == 1)
        v160 = 0;
      if (v158 == kCFCompareEqualTo || (v160 & 1) != 0)
      {
LABEL_268:
        if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceThumbnailInterpolationQuality")))
        {
          v164 = IIODictionary::getUint32ForKey((IIODictionary *)a3, CFSTR("kCGImageSourceThumbnailInterpolationQuality"));
          if (v164 >= 4)
            v165 = kCGInterpolationDefault;
          else
            v165 = v164;
          if (!v159)
          {
LABEL_276:
            if ((v178 & 0xF0000) == 0x30000 && BitsPerComponent == 10)
              v167 = 8;
            else
              v167 = BitsPerComponent;
            v203.a = v99;
            v203.b = v98;
            v203.c = v101;
            v203.d = v100;
            *(float64x2_t *)&v203.tx = v192;
            RenderingIntent = CGImageGetRenderingIntent(v87);
            v10 = CGImageCreateCopyWithParametersNew(v87, 0, &v203, v186, (unint64_t)v181, v167, v167 * v175, v176, space, v127, 1, RenderingIntent, v165, 0);
            if (v10)
            {
              LODWORD(v206) = 0;
              CGImageGetHeadroomInfo();
              CGImageSetHeadroom();
              if (!v159)
              {
LABEL_285:
                if (space)
                  CGColorSpaceRelease(space);
                CGImageRelease(v87);
                goto LABEL_288;
              }
            }
            else
            {
              _cg_jpeg_mem_term("createThumbnailAtIndex", 2893, "*** ERROR: CGImageCreateCopyWithParametersNew returned NULL\n");
              if (!v159)
                goto LABEL_285;
            }
            CGImageProviderSetProperty();
            goto LABEL_285;
          }
        }
        else
        {
          v165 = kCGInterpolationDefault;
          if (!v159)
            goto LABEL_276;
        }
        CGImageGetImageProvider();
        CGImageProviderGetProperty();
        CGImageProviderSetProperty();
        goto LABEL_276;
      }
    }
    else
    {
      v161 = v201;
      if (v122 == 1)
        v161 = 0;
      if ((v161 & 1) != 0)
      {
        v159 = 0;
        goto LABEL_268;
      }
    }
    v98 = 0.0;
    if ((v99 > 0.995 || v100 > 0.995) && (v162 = (IIO_Reader *)*((_QWORD *)this + 10)) != 0)
    {
      v163 = (const __CFString *)IIO_Reader::utType(v162);
      v159 = CFStringCompare(v163, CFSTR("public.png"), 0) == kCFCompareEqualTo;
    }
    else
    {
      v159 = 0;
    }
    v99 = 0.0;
    v101 = 0.0;
    v100 = 0.0;
    goto LABEL_268;
  }
  ColorSpace = CGImageGetColorSpace(v87);
  v119 = CGColorSpaceGetModel(ColorSpace);
  CGImageGetImageProvider();
  v120 = CGImageGetBitsPerComponent(v87);
  if (v119 == kCGColorSpaceModelMonochrome)
  {
    v128 = 843264056;
    v129 = 843264310;
    v130 = v120 > 8;
    goto LABEL_192;
  }
  if (v120 != 10)
  {
    v130 = v120 > 8;
    v128 = 1111970369;
    v129 = 1815491698;
LABEL_192:
    if (v130)
      v121 = v129;
    else
      v121 = v128;
    goto LABEL_195;
  }
  v121 = 1815162994;
LABEL_195:
  v206 = 0.0;
  v207 = 0.0;
  v208 = 0.0;
  IIODictionary::IIODictionary((IIODictionary *)&v206);
  IIONumber::IIONumber((IIONumber *)v204, v121);
  IIODictionary::setObjectForKey((IIODictionary *)&v206, value, CFSTR("kCGImageSurfaceFormatRequest"));
  IIONumber::~IIONumber((IIONumber *)v204);
  if ((gIIODebugFlags & 0x2000000) != 0)
    LogPixelFormat(v121, "createThumbnailAtIndex", 2719);
  v132 = (__IOSurface *)CGImageProviderCopyIOSurface();
  v133 = v132;
  if (v132)
  {
    PixelFormat = IOSurfaceGetPixelFormat(v132);
    v135 = PixelFormat;
    if (v121 != PixelFormat)
    {
      v136 = MEMORY[0x1E0C80978];
      LODWORD(v137) = HIBYTE(v121);
      v138 = MEMORY[0x1E0C80978] + 60;
      if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * HIBYTE(v121)) & 0x40000) != 0)
        v137 = v137;
      else
        v137 = 46;
      v193 = v137;
      LODWORD(v139) = HIWORD(v121) & 0x77;
      if ((*(_DWORD *)(v138 + 4 * v139) & 0x40000) != 0)
        v139 = v139;
      else
        v139 = 46;
      v189 = v139;
      LODWORD(v140) = (v121 >> 8) & 0x77;
      if ((*(_DWORD *)(v138 + 4 * v140) & 0x40000) != 0)
        v140 = v140;
      else
        v140 = 46;
      *(_QWORD *)v185 = v140;
      if ((*(_DWORD *)(v138 + 4 * (v121 & 0x7F)) & 0x40000) != 0)
        v141 = v121 & 0x7F;
      else
        v141 = 46;
      v182 = (IIOImageReadSession *)v141;
      v142 = PixelFormat >> 24;
      if (PixelFormat < 0)
        v143 = __maskrune(PixelFormat >> 24, 0x40000uLL);
      else
        v143 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v142 + 60) & 0x40000;
      if (v143)
        v144 = v142;
      else
        v144 = 46;
      v179 = v144;
      v145 = v135 << 8 >> 24;
      if (v135 << 8 < 0)
        v146 = __maskrune(v135 << 8 >> 24, 0x40000uLL);
      else
        v146 = *(_DWORD *)(v136 + 4 * v145 + 60) & 0x40000;
      if (v146)
        v147 = v145;
      else
        v147 = 46;
      v148 = (__int16)v135 >> 8;
      if (v135 << 16 < 0)
      {
        v150 = __maskrune((__int16)v135 >> 8, 0x40000uLL);
        v149 = v136;
      }
      else
      {
        v149 = v136;
        v150 = *(_DWORD *)(v136 + 4 * v148 + 60) & 0x40000;
      }
      if ((v135 << 24) <= 0x7F000000)
        v151 = *(_DWORD *)(v149 + 4 * (char)v135 + 60) & 0x40000;
      else
        v151 = __maskrune((char)v135, 0x40000uLL);
      if (v150)
        v152 = v148;
      else
        v152 = 46;
      if (v151)
        v153 = (char)v135;
      else
        v153 = 46;
      _cg_jpeg_mem_term("createThumbnailAtIndex", 2727, "*** NOTE: requested pixelformat: '%c%c%c%c' -- got: '%c%c%c%c'\n", v193, v189, *(_QWORD *)v185, v182, v179, v147, v152, v153);
    }
    CGImageRelease(v87);
    v87 = CGImageCreateFromIOSurface(v133, 0);
    if ((gIIODebugFlags & 0x2000000) != 0)
      LogSurfaceFormat(v133, "surface", "createThumbnailAtIndex", 2732);
    CFRelease(v133);
    CGImageSetProperty();
    v154 = IIO_Reader::osType(*((IIO_Reader **)this + 10));
    IIOString::IIOString((IIOString *)v204, v154);
    CGImageSetProperty();
    IIOString::~IIOString((IIOString *)v204);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v206);
  v10 = v87;
LABEL_288:
  a4 = v196;
  if (v195)
  {
    ValidRows = IIOImagePlus::getValidRows((IIOImagePlus *)v198);
    if (ValidRows == *(_QWORD *)(IIOImagePlus::getSourceGeom((IIOImagePlus *)v198) + 8))
      IIOImagePlus::setStatus((uint64_t)v198, kCGImageStatusComplete);
  }
  if (v10)
  {
    if ((v201 & 1) != 0)
    {
      v170 = 1;
    }
    else if (v183 && IIODictionary::containsKey(v183, CFSTR("Orientation")))
    {
      v170 = IIODictionary::getUint32ForKey(v183, CFSTR("Orientation"));
    }
    else
    {
      v206 = 0.0;
      v207 = 0.0;
      v208 = 0.0;
      IIODictionary::IIODictionary((IIODictionary *)&v206);
      IIODictionary::setObjectForKey(v171, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageSourceSkipMetadata"));
      IIONumber::IIONumber((IIONumber *)v202, v200[0]);
      IIODictionary::setObjectForKey((uint64_t)&v206, (uint64_t)v202, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
      IIONumber::~IIONumber((IIONumber *)v202);
      v172 = IIOImageSource::getPropertiesAtIndexInternal(this, v197, (const __CFDictionary **)&v206);
      v173 = v172;
      if (v172 && IIODictionary::containsKey(v172, CFSTR("Orientation")))
        v170 = IIODictionary::getUint32ForKey(v173, CFSTR("Orientation"));
      else
        v170 = 1;
      IIODictionary::~IIODictionary((IIODictionary *)&v206);
    }
    IIONumber::IIONumber((IIONumber *)&v206, v170);
    CGImageSetProperty();
    IIONumber::~IIONumber((IIONumber *)&v206);
  }
LABEL_305:
  if (v217[0])
  {
    CGImageRelease(v10);
    v10 = 0;
  }
  if (a4)
    *a4 = v217[0];
  if (v9)
    CFRelease(v9);
  if (v8)
    CFRelease(v8);
  return v10;
}

void sub_187EA81C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 240));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AppleJPEG::initImageAtOffset(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  IIOReadPlugin *v8;
  int v9;

  v8 = (IIOReadPlugin *)operator new();
  v9 = IIO_Reader::osType(a1);
  AppleJPEGReadPlugin::AppleJPEGReadPlugin((uint64_t)v8, a2, a3, 0, 0, 0, 1246774599, 0, v9);
  IIOReadPlugin::setUTIWithReader(v8, a1);
  if (a4)
  {
    IIOReadPlugin::setDecodeMode((uint64_t)v8, 3);
    IIOReadPlugin::setDestMaxPixelSize((uint64_t)v8, a4);
  }
  return IIOReadPlugin::callInitialize(v8);
}

void sub_187EA8310(void *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40C020E1A5);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187EA82F8);
}

uint64_t IIO_Reader::initImageAtOffset(IIO_Reader *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  IIOReadPlugin *v11;

  if ((IIO_XPCServer() & 1) != 0)
    return 4294967246;
  v11 = (IIOReadPlugin *)(*(uint64_t (**)(IIO_Reader *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 248))(a1, a2, a3, a5);
  IIOReadPlugin::setUTIWithReader(v11, a1);
  if (a4)
  {
    if (v11)
    {
      IIOReadPlugin::setDecodeMode((uint64_t)v11, 3);
      IIOReadPlugin::setDestMaxPixelSize((uint64_t)v11, a4);
    }
  }
  return IIOReadPlugin::callInitialize(v11);
}

void sub_187EA83E4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187EA83C8);
}

void sub_187EA83F4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187EA8378);
}

uint64_t IIOReadPlugin::setUTIWithReader(IIOReadPlugin *this, IIO_Reader *a2)
{
  uint64_t result;

  *((_QWORD *)this + 9) = IIOImageSource::cf(a2);
  result = IIO_Reader::osType(a2);
  *((_DWORD *)this + 51) = result;
  return result;
}

uint64_t IIO_Reader_PNG::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  PNGReadPlugin::PNGReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187EA84B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40251C7B2ALL);
  _Unwind_Resume(a1);
}

double PNGReadPlugin::PNGReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  double result;

  v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)v5 = &off_1E1BAD7B8;
  result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(_OWORD *)(v5 + 472) = 0u;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  return result;
}

uint64_t IIO_Reader_HEIF::initImageAtOffset(CFStringRef **a1, uint64_t a2, int a3, int a4)
{
  CFComparisonResult v9;
  IIOReadPlugin *v10;
  int v11;

  if ((IIO_XPCServer() & 1) != 0)
    return 4294967246;
  v9 = CFStringCompare(*a1[1], CFSTR("public.jpeg"), 0);
  v10 = (IIOReadPlugin *)operator new();
  v11 = IIO_Reader::osType((IIO_Reader *)a1);
  HEIFReadPlugin::HEIFReadPlugin((uint64_t)v10, a2, a3, 0, 0, v9 == kCFCompareEqualTo, v11);
  IIOReadPlugin::setDestMaxPixelSize((uint64_t)v10, a4);
  return IIOReadPlugin::callInitialize(v10);
}

void sub_187EA85CC(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187EA8534);
}

uint64_t IIOReadPlugin::setDestMaxPixelSize(uint64_t this, int a2)
{
  *(_DWORD *)(this + 212) = a2;
  return this;
}

uint64_t HEIFReadPlugin::HEIFReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5, char a6, int a7)
{
  uint64_t result;

  result = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a7);
  *(_QWORD *)result = &off_1E1BAE158;
  *(_OWORD *)(result + 440) = 0u;
  *(_OWORD *)(result + 456) = 0u;
  *(_OWORD *)(result + 472) = 0u;
  *(_OWORD *)(result + 488) = 0u;
  *(_OWORD *)(result + 504) = 0u;
  if (a7 == 1246774599)
  {
    *(_QWORD *)(result + 456) = a4;
    *(_QWORD *)(result + 464) = a5;
  }
  *(_DWORD *)(result + 476) = 1;
  *(_BYTE *)(result + 491) = a6;
  *(_BYTE *)(result + 340) = 1;
  return result;
}

double AppleJPEGReadPlugin::AppleJPEGReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, char a6, int a7, uint64_t a8, int a9)
{
  uint64_t v9;
  double result;

  JPEGReadPlugin::JPEGReadPlugin(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  *(_QWORD *)v9 = &off_1E1BB19F8;
  result = 0.0;
  *(_OWORD *)(v9 + 504) = 0u;
  *(_OWORD *)(v9 + 520) = 0u;
  *(_OWORD *)(v9 + 536) = 0u;
  *(_OWORD *)(v9 + 552) = 0u;
  *(_OWORD *)(v9 + 568) = 0u;
  *(_OWORD *)(v9 + 584) = 0u;
  *(_OWORD *)(v9 + 600) = 0u;
  *(_OWORD *)(v9 + 616) = 0u;
  *(_OWORD *)(v9 + 632) = 0u;
  *(_OWORD *)(v9 + 648) = 0u;
  *(_OWORD *)(v9 + 664) = 0u;
  *(_QWORD *)(v9 + 680) = 0;
  return result;
}

double JPEGReadPlugin::JPEGReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, char a6, int a7, uint64_t a8, int a9)
{
  uint64_t v13;
  double result;

  v13 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a9);
  *(_QWORD *)v13 = &off_1E1BAF8A0;
  result = 0.0;
  *(_OWORD *)(v13 + 448) = 0u;
  *(_OWORD *)(v13 + 464) = 0u;
  *(_OWORD *)(v13 + 480) = 0u;
  *(_QWORD *)(v13 + 496) = 0;
  *(_DWORD *)(v13 + 452) = a7;
  *(_BYTE *)(v13 + 472) = a6;
  *(_QWORD *)(v13 + 456) = a4;
  *(_QWORD *)(v13 + 464) = a5;
  *(_QWORD *)(v13 + 440) = 0;
  return result;
}

uint64_t IIO_Reader::canApplyTransform(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader_AppleJPEG::hasCustomThumbnailProc(IIO_Reader_AppleJPEG *this)
{
  return 1;
}

uint64_t IIO_Reader_ATX::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  ATXReadPlugin::ATXReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187EA87CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4001FED7D0);
  _Unwind_Resume(a1);
}

double ATXReadPlugin::ATXReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  double result;

  v5 = CommonASTCReadPlugin::CommonASTCReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)v5 = &off_1E1BAC560;
  result = 0.0;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  *(_OWORD *)(v5 + 520) = 0u;
  *(_OWORD *)(v5 + 536) = 0u;
  *(_OWORD *)(v5 + 552) = 0u;
  *(_OWORD *)(v5 + 568) = 0u;
  *(_OWORD *)(v5 + 584) = 0u;
  *(_OWORD *)(v5 + 600) = 0u;
  *(_OWORD *)(v5 + 616) = 0u;
  *(_QWORD *)(v5 + 632) = 0;
  return result;
}

uint64_t CommonASTCReadPlugin::CommonASTCReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  __int128 v12;

  v6 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)v6 = &off_1E1BB1E20;
  v7 = v6 + 472;
  *(_QWORD *)(v6 + 472) = 0;
  *(_QWORD *)(v6 + 480) = 0;
  *(_QWORD *)(v6 + 444) = 0;
  *(_QWORD *)(v6 + 452) = 0;
  *(_QWORD *)(v6 + 436) = 0;
  std::allocate_shared[abi:ne180100]<ASTCTextureImp,std::allocator<ASTCTextureImp>,unsigned int &,void>((unsigned int *)(v6 + 208), &v12);
  std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>(v7, &v12);
  v8 = (std::__shared_weak_count *)*((_QWORD *)&v12 + 1);
  if (*((_QWORD *)&v12 + 1))
  {
    v9 = (unint64_t *)(*((_QWORD *)&v12 + 1) + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  *(_QWORD *)(a1 + 464) = 0;
  return a1;
}

void sub_187EA88DC(_Unwind_Exception *a1)
{
  IIOReadPlugin *v1;
  uint64_t v2;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v2);
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void ASTCTextureImp::ASTCTextureImp(ASTCTextureImp *this, int a2)
{
  *((_DWORD *)this + 2) = a2;
  *(_QWORD *)this = &off_1E1BADFA8;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_QWORD *)this + 30) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 168), 0);
}

void sub_187EA8958(_Unwind_Exception *a1, uint64_t a2, const char *a3)
{
  uint64_t v3;

  _cg_jpeg_mem_term(v3, a2, a3);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::hasCustomThumbnailProc(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader_TIFF::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  TIFFReadPlugin::TIFFReadPlugin(v8, a2, a3, a4, 0, v9);
  return v8;
}

void sub_187EA89F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40FF4BE457);
  _Unwind_Resume(a1);
}

double TIFFReadPlugin::TIFFReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5, int a6)
{
  uint64_t v7;
  double result;

  v7 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a6);
  *(_QWORD *)v7 = &off_1E1BAFD08;
  result = 0.0;
  *(_OWORD *)(v7 + 440) = 0u;
  *(_OWORD *)(v7 + 456) = 0u;
  *(_OWORD *)(v7 + 472) = 0u;
  *(_OWORD *)(v7 + 488) = 0u;
  *(_OWORD *)(v7 + 504) = 0u;
  *(_OWORD *)(v7 + 520) = 0u;
  *(_OWORD *)(v7 + 536) = 0u;
  *(_OWORD *)(v7 + 552) = 0u;
  *(_BYTE *)(v7 + 566) = a5;
  return result;
}

uint64_t IIOImagePlus::getSourceGeom(IIOImagePlus *this)
{
  return (uint64_t)this + 40;
}

uint64_t IIOImagePlus::getValidRows(IIOImagePlus *this)
{
  return *((_QWORD *)this + 29);
}

__n128 IIOImageSource::getThumbnailInfoAtIndex(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *(_QWORD *)(a1 + 176);
  v5 = *(_QWORD *)(a1 + 184);
  while (v4 != v5)
  {
    if (*(_DWORD *)(v4 + 28) == a2
      && (*(_DWORD *)(v4 + 12) >= a3 || *(_DWORD *)(v4 + 16) >= a3)
      && (v4 + 40 == v5 || !*(_BYTE *)(v4 + 35)))
    {
      result = *(__n128 *)v4;
      v7 = *(_OWORD *)(v4 + 16);
      *(_QWORD *)(a4 + 32) = *(_QWORD *)(v4 + 32);
      *(__n128 *)a4 = result;
      *(_OWORD *)(a4 + 16) = v7;
      return result;
    }
    v4 += 40;
  }
  return result;
}

void IIOImageSource::updateThumbnailInfo(IIOImageSource *this, IIODictionary *a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int v8;
  IIO_Reader *v9;
  int v10;
  int v11;
  IIODictionary *Properties;
  const __CFArray *v13;
  unsigned int Uint32ForKey;
  const __CFDictionary *ObjectForKey;
  const __CFString **v16;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFDictionary *ValueAtIndex;
  const __CFArray *Value;
  const __CFArray *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD v25[5];
  int v26;
  unsigned int v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  if (*((_QWORD *)this + 23) != *((_QWORD *)this + 22))
    return;
  v8 = IIOImageSource::isRAWFile(this);
  v9 = (IIO_Reader *)*((_QWORD *)this + 10);
  if (!v9)
  {
    if (v8)
      v11 = 1918990112;
    else
      v11 = 1970170734;
    goto LABEL_12;
  }
  v10 = IIO_Reader::osType(v9);
  if (v8)
    v11 = 1918990112;
  else
    v11 = v10;
  if (!*((_QWORD *)this + 10))
  {
LABEL_12:
    Properties = (IIODictionary *)IIOImageSource::getProperties(this, a2);
    if (Properties)
      goto LABEL_14;
    goto LABEL_13;
  }
  Properties = (IIODictionary *)*((_QWORD *)this + 12);
  if (Properties)
    goto LABEL_14;
LABEL_13:
  Properties = (IIODictionary *)IIOImageSource::getProperties(this, a2);
LABEL_14:
  LODWORD(v13) = 0;
  if (v11 > 1212829766)
  {
    if (v11 != 1918990112)
    {
      Uint32ForKey = 0;
      if (v11 != 1212829767)
        goto LABEL_41;
    }
LABEL_22:
    if (!Properties)
      goto LABEL_29;
    v16 = (const __CFString **)&kCGImagePropertyImages;
    if (v8)
      v16 = (const __CFString **)kIIOPropertyRawImagesArray;
    ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(Properties, *v16, CFSTR("{FileContents}"));
    v13 = ObjectForKeyGroup;
    if (ObjectForKeyGroup)
    {
      if (CFArrayGetCount(ObjectForKeyGroup))
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v13, 0);
        v29 = 0;
        v30 = 0;
        v31 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v29, ValueAtIndex);
        LODWORD(v13) = IIODictionary::getUint32ForKey((IIODictionary *)&v29, CFSTR("Width"));
        Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)&v29, CFSTR("Height"));
        IIODictionary::~IIODictionary((IIODictionary *)&v29);
        if (!v8)
          goto LABEL_33;
LABEL_31:
        Value = IIODictionary::getObjectForKeyGroup(Properties, CFSTR("Thumbnails"), CFSTR("{raw}"));
        goto LABEL_35;
      }
      ValueAtIndex = 0;
      Uint32ForKey = 0;
      LODWORD(v13) = 0;
      if (v8)
        goto LABEL_31;
    }
    else
    {
      ValueAtIndex = 0;
      Uint32ForKey = 0;
      if (v8)
        goto LABEL_31;
    }
LABEL_33:
    if (!ValueAtIndex)
    {
      v20 = 0;
LABEL_36:
      v29 = 0;
      v30 = 0;
      v31 = 0;
      IIOArray::IIOArray((IIOArray *)&v29, v20);
      v25[0] = MEMORY[0x1E0C809B0];
      v25[1] = 0x40000000;
      v25[2] = ___ZN14IIOImageSource19updateThumbnailInfoEP13IIODictionaryPjS2__block_invoke;
      v25[3] = &__block_descriptor_tmp_3;
      v25[4] = this;
      v26 = (int)v13;
      v27 = Uint32ForKey;
      v28 = v8;
      IIOArray::enumerate((uint64_t)&v29, (uint64_t)v25);
      v21 = *((_QWORD *)this + 22);
      v22 = *((_QWORD *)this + 23);
      v23 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v22 - v21) >> 3));
      if (v22 == v21)
        v24 = 0;
      else
        v24 = v23;
      std::__introsort<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *,false>(v21, v22, v24, 1);
      IIOArray::~IIOArray((IIOArray *)&v29);
      if (!(_DWORD)v13)
        goto LABEL_41;
      goto LABEL_40;
    }
    Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, CFSTR("ThumbnailImages"));
LABEL_35:
    v20 = Value;
    goto LABEL_36;
  }
  if (v11 == 1212500291)
    goto LABEL_22;
  Uint32ForKey = 0;
  if (v11 != 1212500307)
  {
LABEL_41:
    _cg_jpeg_mem_term("updateThumbnailInfo", 2181, "*** ERROR: IIOImageSource::updateThumbnailInfo did not get image dimensions (%d x %d)\n", (_DWORD)v13, Uint32ForKey);
    goto LABEL_42;
  }
  if (!Properties)
  {
LABEL_29:
    LODWORD(v13) = 0;
    Uint32ForKey = 0;
    goto LABEL_41;
  }
  ObjectForKey = IIODictionary::getObjectForKey(Properties, CFSTR("{HEICS}"));
  v29 = 0;
  v30 = 0;
  v31 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v29, ObjectForKey);
  LODWORD(v13) = IIODictionary::getUint32ForKey((IIODictionary *)&v29, CFSTR("CanvasPixelWidth"));
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)&v29, CFSTR("CanvasPixelHeight"));
  IIODictionary::~IIODictionary((IIODictionary *)&v29);
  if (!(_DWORD)v13)
    goto LABEL_41;
LABEL_40:
  if (!Uint32ForKey)
    goto LABEL_41;
LABEL_42:
  if (a3)
    *a3 = v13;
  if (a4)
    *a4 = Uint32ForKey;
}

void sub_187EA8E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CFDictionaryRef CGImageSourceCopyProperties(CGImageSourceRef isrc, CFDictionaryRef options)
{
  unsigned int v4;
  CFTypeID v5;
  CFTypeID v6;
  uint64_t v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  IIO_Reader *v10;
  _QWORD v12[3];

  kdebug_trace();
  IIOInitDebugFlags();
  v4 = (gIIODebugFlags >> 12) & 3;
  if (v4)
    ImageIODebugOptions(v4, "A", "CGImageSourceCopyProperties", isrc, 0, -1, options);
  if (!isrc)
  {
    LogError("CGImageSourceCopyProperties", 4836, "*** ERROR: CGImageSourceCopyProperties: source is nil\n");
LABEL_19:
    v9 = 0;
    goto LABEL_20;
  }
  v5 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v5 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCopyProperties", 4837, "*** ERROR: CGImageSourceCopyProperties: source is not a CGImageSourceRef\n");
    goto LABEL_19;
  }
  if (options)
  {
    v6 = CFGetTypeID(options);
    if (v6 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCopyProperties", 4840, "*** ERROR: CGImageSourceCopyProperties: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  v7 = *((_QWORD *)isrc + 3);
  if (!v7)
    goto LABEL_19;
  memset(v12, 0, sizeof(v12));
  IIODictionary::IIODictionary((IIODictionary *)v12, options);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 200));
  if (IIOImageSource::isProxy((IIOImageSource *)v7))
    v8 = (const __CFDictionary *)IIOImageSource::proxyCopyProperties((IIODictionary **)v7, (IIODictionary *)v12);
  else
    v8 = IIOImageSource::copyProperties((IIOImageSource *)v7, (IIODictionary *)v12);
  v9 = v8;
  v10 = *(IIO_Reader **)(v7 + 80);
  if (v10)
    IIO_Reader::osType(v10);
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 200));
  IIODictionary::~IIODictionary((IIODictionary *)v12);
LABEL_20:
  kdebug_trace();
  return v9;
}

void sub_187EA9060(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CFDictionaryRef IIOImageSource::copyProperties(IIOImageSource *this, IIODictionary *a2)
{
  CFDictionaryRef result;

  result = (CFDictionaryRef)IIOImageSource::getProperties(this, a2);
  if (result)
    return CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *((CFDictionaryRef *)result + 1));
  return result;
}

uint64_t IIOImageSource::getProperties(IIOImageSource *this, IIODictionary *a2)
{
  IIOImageRead *Source;
  IIOImageRead *v5;
  IIODictionary *v6;
  CFIndex Size;
  _QWORD *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  IIO_ReaderHandler *v15;
  int v16;
  const char *v17;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v20;
  __n128 v21;
  int v22;
  _BYTE v23[28];
  int v24;
  _QWORD v25[2];
  void *v26;

  if (!IIOImageSource::bindToReader(this))
    return 0;
  Source = (IIOImageRead *)CGImageSourceGetSource(*((_QWORD *)this + 2));
  v5 = Source;
  if (!*((_QWORD *)this + 12))
    goto LABEL_5;
  if (!IIOImageRead::isFinal(Source))
  {
    if (*((_QWORD *)this + 12))
    {
LABEL_6:
      Size = IIOImageRead::getSize(v5);
      IIONumber::IIONumber((IIONumber *)v25, Size);
      IIOImageSource::addProperty(this, 0, CFSTR("FileSize"), v26);
      IIONumber::~IIONumber((IIONumber *)v25);
      if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 10) + 176))(*((_QWORD *)this + 10)))
      {
        v8 = CGImageReadSessionCreate(*((const void **)this + 2));
        if (v8)
        {
          v9 = v8;
          v24 = -1;
          v10 = (const void *)IIO_Reader::utType(*((IIO_Reader **)this + 10));
          IIODebugCallbackPriv(v10, "addSourceProps");
          v25[0] = 0;
          v25[1] = 0;
          v26 = 0;
          IIODictionary::IIODictionary((IIODictionary *)v25);
          v11 = (const void *)*MEMORY[0x1E0C9AE50];
          v12 = (const void *)*MEMORY[0x1E0C9AE40];
          if (*((_BYTE *)this + 50))
            v13 = (const void *)*MEMORY[0x1E0C9AE50];
          else
            v13 = (const void *)*MEMORY[0x1E0C9AE40];
          IIODictionary::setObjectForKey((IIODictionary *)v25, v13, CFSTR("shouldExposeMultiFrameContents"));
          if (*((_BYTE *)this + 52))
            v14 = v11;
          else
            v14 = v12;
          IIODictionary::setObjectForKey((IIODictionary *)v25, v14, CFSTR("useImageSequence"));
          IIONumber::IIONumber((IIONumber *)v23, *((char *)this + 53));
          IIODictionary::setObjectForKey((uint64_t)v25, (uint64_t)v23, CFSTR("kCGImageSourceForceUseServer"));
          IIONumber::~IIONumber((IIONumber *)v23);
          v15 = (IIO_ReaderHandler *)(*(uint64_t (**)(_QWORD, const void *, _QWORD, _QWORD, _QWORD *, IIODictionary *, int *))(**((_QWORD **)this + 10) + 48))(*((_QWORD *)this + 10), v9, *((_QWORD *)this + 1), *((_QWORD *)this + 12), v25, a2, &v24);
          if ((_DWORD)v15 == -48)
          {
            ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v15);
            v20 = IIO_ReaderHandler::readerForType(ReaderHandler, 1212500291);
            if (v20)
            {
              v21 = _cg_jpeg_mem_term("getProperties", 1530, "    JPEG contains 'MPF' marker --> switch to 'HEIC' plugin\n");
              *((_QWORD *)this + 10) = v20;
              (*(void (**)(IIO_Reader *, const void *, _QWORD, _QWORD, _QWORD *, IIODictionary *, int *, __n128))(*(_QWORD *)v20 + 48))(v20, v9, *((_QWORD *)this + 1), *((_QWORD *)this + 12), v25, a2, &v24, v21);
            }
          }
          else if ((_DWORD)v15 == -1400)
          {
            ImageIOLog("‼️ retrying 'updateSourceProperties' (ImageIOXPCService crashed?)\n");
            v16 = (*(uint64_t (**)(_QWORD, const void *, _QWORD, _QWORD, _QWORD *, IIODictionary *, int *))(**((_QWORD **)this + 10) + 48))(*((_QWORD *)this + 10), v9, *((_QWORD *)this + 1), *((_QWORD *)this + 12), v25, a2, &v24);
            v17 = "❌";
            if (!v16)
              v17 = "✅";
            ImageIOLog("%s retrying 'updateSourceProperties'  err: %d\n", v17, v16);
          }
          v22 = v24;
          pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
          *((_DWORD *)this + 22) = v22;
          pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
          CFRelease(v9);
          IIODictionary::~IIODictionary((IIODictionary *)v25);
        }
      }
      return *((_QWORD *)this + 12);
    }
LABEL_5:
    v6 = (IIODictionary *)operator new();
    IIODictionary::IIODictionary(v6);
    *((_QWORD *)this + 12) = v6;
    goto LABEL_6;
  }
  return *((_QWORD *)this + 12);
}

void sub_187EA9368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIOImageSource::addProperty(IIOImageSource *this, const __CFString *a2, const __CFString *a3, const void *a4)
{
  IIODictionary *v8;

  if (a3)
  {
    v8 = (IIODictionary *)*((_QWORD *)this + 12);
    if (!v8)
    {
      v8 = (IIODictionary *)operator new();
      IIODictionary::IIODictionary(v8);
      *((_QWORD *)this + 12) = v8;
    }
    if (a2)
    {
      if (a4)
        IIODictionary::setObjectForKeyGroup(v8, a4, a3, a2);
      else
        IIODictionary::removeObjectForKeyGroup(v8, a3, a2);
    }
    else if (a4)
    {
      IIODictionary::setObjectForKey(v8, a4, a3);
    }
    else
    {
      IIODictionary::removeObjectForKey(v8, a3);
    }
  }
  else
  {
    LogError("addProperty", 1457, "*** ERROR: key parameter is nil\n", a4);
  }
}

void sub_187EA94BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::callUpdateSourceProperties(uint64_t a1, uint64_t a2, uint64_t a3, IIODictionary *a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  IIOImageRead *v14;
  IIOImageRead *v15;
  char v16;
  IIOXPCClient *IIOXPCClient;
  xpc_object_t v18;
  void *v19;
  IIOImageReadSession *v20;
  xpc_object_t v21;
  xpc_object_t v22;
  const char *v23;
  _xpc_connection_s *v24;
  dispatch_queue_s *v25;
  xpc_object_t v26;
  void *v27;
  xpc_object_t message_dict;
  xpc_object_t source_dict;
  uint64_t error_code;
  const char *v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  int v35;
  uint64_t Source;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  unsigned int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  int v65;
  uint64_t v66;
  unsigned int v67;
  int v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  const __CFDictionary *v72;
  uint64_t v73;
  uint64_t v74;
  const __CFDictionary *v75[3];
  void *v76[3];
  void *v77;

  if ((IIO_XPCServer() & 1) != 0
    || ((v14 = (IIOImageRead *)CGImageSourceGetRead(a3), (v15 = v14) == 0)
      ? (v16 = -1)
      : (v14 = (IIOImageRead *)IIOImageRead::forceUseServer(v14), v16 = (char)v14),
        IIOXPCClient = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient(v14),
        !IIOXPCClient::useServerForSourceProperties(IIOXPCClient, v15, a1, v16)))
  {
    Source = CGImageSourceGetSource(a2);
    return (*(uint64_t (**)(uint64_t, uint64_t, IIODictionary *, uint64_t, uint64_t, _DWORD *))(*(_QWORD *)a1 + 56))(a1, Source, a4, a5, a6, a7);
  }
  else
  {
    kdebug_trace();
    v18 = xpc_dictionary_create(0, 0, 0);
    if (v18)
    {
      v19 = v18;
      v20 = (IIOImageReadSession *)CGImageSourceGetSource(a2);
      v77 = 0;
      v21 = iio_xpc_add_message_dict(v19);
      v22 = iio_xpc_add_source_dict(v19);
      xpc_dictionary_set_uint64(v19, "iio_xpc_message_id", 3uLL);
      memset(v76, 0, sizeof(v76));
      IIOString::IIOString((IIOString *)v76, **(const void ***)(a1 + 8));
      v23 = (const char *)IIOString::utf8String((IIOString *)v76);
      xpc_dictionary_set_string(v22, "iio_xpc_src_utitype", v23);
      xpc_dictionary_set_uint64(v22, "iio_xpc_src_ostype", *(unsigned int *)(a1 + 24));
      IIOImageReadSession::addDataToXPCDictionary(v20, v19, &v77);
      iio_xpc_dictionary_add_CFDictionary(v22, "iio_xpc_src_options");
      if (a6)
        iio_xpc_dictionary_add_CFDictionary(v21, "iio_xpc_msg_call_options");
      iio_xpc_dictionary_add_CFDictionary(v22, "iio_xpc_src_properties");
      v24 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(IIOXPCClient);
      v25 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(IIOXPCClient);
      v26 = IIOXPCClient::send_message_with_reply(IIOXPCClient, v24, v25, v19);
      v27 = v26;
      if (v26)
      {
        message_dict = iio_xpc_get_message_dict(v26);
        source_dict = iio_xpc_get_source_dict(v27);
        error_code = iio_xpc_dictionary_get_error_code(message_dict);
        v32 = error_code;
        if ((_DWORD)error_code)
        {
          if ((_DWORD)error_code == -1400)
          {
            v33 = *(_DWORD *)(a1 + 24);
            v34 = v33 >> 24;
            if (v33 < 0)
            {
              v35 = __maskrune(v34, 0x40000uLL);
              v33 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              v35 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v34 + 60) & 0x40000;
            }
            if (v35)
              v45 = (v33 >> 24);
            else
              v45 = 46;
            v46 = v33 << 8 >> 24;
            if (v33 << 8 < 0)
            {
              v47 = __maskrune(v46, 0x40000uLL);
              v33 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              v47 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v46 + 60) & 0x40000;
            }
            if (v47)
              v51 = (v33 << 8 >> 24);
            else
              v51 = 46;
            v52 = (__int16)v33 >> 8;
            if (v33 << 16 < 0)
            {
              v53 = __maskrune(v52, 0x40000uLL);
              v33 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              v53 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v52 + 60) & 0x40000;
            }
            if (v53)
              v57 = ((__int16)v33 >> 8);
            else
              v57 = 46;
            if ((v33 << 24) <= 0x7F000000)
              v58 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v33 + 60) & 0x40000;
            else
              v58 = __maskrune((char)v33, 0x40000uLL);
            if (v58)
              v59 = *(char *)(a1 + 24);
            else
              v59 = 46;
            IIOXPCLog("❌ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_SOURCEPROPERTIES XPC connection interrupted\n", v45, v51, v57, v59);
          }
          else
          {
            v41 = *(_DWORD *)(a1 + 24);
            v42 = v41 >> 24;
            v43 = MEMORY[0x1E0C80978];
            if (v41 < 0)
            {
              v44 = __maskrune(v42, 0x40000uLL);
              v41 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              v44 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v42 + 60) & 0x40000;
            }
            if (v44)
              v48 = (v41 >> 24);
            else
              v48 = 46;
            v49 = v41 << 8 >> 24;
            if (v41 << 8 < 0)
            {
              v50 = __maskrune(v49, 0x40000uLL);
              v41 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              v50 = *(_DWORD *)(v43 + 4 * v49 + 60) & 0x40000;
            }
            if (v50)
              v54 = (v41 << 8 >> 24);
            else
              v54 = 46;
            v55 = (__int16)v41 >> 8;
            if (v41 << 16 < 0)
            {
              v56 = __maskrune(v55, 0x40000uLL);
              v41 = *(_DWORD *)(a1 + 24);
            }
            else
            {
              v56 = *(_DWORD *)(v43 + 4 * v55 + 60) & 0x40000;
            }
            if (v56)
              v60 = ((__int16)v41 >> 8);
            else
              v60 = 46;
            if ((v41 << 24) <= 0x7F000000)
              v61 = *(_DWORD *)(v43 + 4 * (char)v41 + 60) & 0x40000;
            else
              v61 = __maskrune((char)v41, 0x40000uLL);
            if (v61)
              v62 = *(char *)(a1 + 24);
            else
              v62 = 46;
            IIOXPCLog("❌ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_SOURCEPROPERTIES error: %lld\n", v48, v54, v60, v62, (int)v32);
          }
        }
        else if (source_dict)
        {
          v38 = *(_DWORD *)(a1 + 24);
          v39 = v38 >> 24;
          if (v38 < 0)
          {
            v40 = __maskrune(v39, 0x40000uLL);
            v38 = *(_DWORD *)(a1 + 24);
          }
          else
          {
            v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v39 + 60) & 0x40000;
          }
          LODWORD(v63) = v38 >> 24;
          if (v40)
            v63 = v63;
          else
            v63 = 46;
          v74 = v63;
          v64 = v38 << 8 >> 24;
          if (v38 << 8 < 0)
          {
            v65 = __maskrune(v64, 0x40000uLL);
            v38 = *(_DWORD *)(a1 + 24);
          }
          else
          {
            v65 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v64 + 60) & 0x40000;
          }
          LODWORD(v66) = v38 << 8 >> 24;
          if (v65)
            v66 = v66;
          else
            v66 = 46;
          v73 = v66;
          v67 = (__int16)v38 >> 8;
          if (v38 << 16 < 0)
          {
            v68 = __maskrune(v67, 0x40000uLL);
            v38 = *(_DWORD *)(a1 + 24);
          }
          else
          {
            v68 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v67 + 60) & 0x40000;
          }
          if (v68)
            v69 = ((__int16)v38 >> 8);
          else
            v69 = 46;
          if ((v38 << 24) <= 0x7F000000)
            v70 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v38 + 60) & 0x40000;
          else
            v70 = __maskrune((char)v38, 0x40000uLL);
          if (v70)
            v71 = *(char *)(a1 + 24);
          else
            v71 = 46;
          IIOXPCLog("✅ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_SOURCEPROPERTIES: OK\n", v74, v73, v69, v71);
          v72 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_properties");
          if (v72)
          {
            memset(v75, 0, sizeof(v75));
            IIODictionary::IIODictionary((IIODictionary *)v75, v72, 1);
            IIODictionary::removeAllObjects(a4);
            IIODictionary::appendDictionary(a4, v75);
            CFRelease(v72);
            IIODictionary::~IIODictionary((IIODictionary *)v75);
          }
          *a7 = xpc_dictionary_get_int64(source_dict, "iio_xpc_src_status");
        }
        _cg_jpeg_mem_term(IIOXPCClient, v27, v31);
        xpc_release(v27);
      }
      else
      {
        IIOXPCLog("❌ ImageIOXPC: XPC_READPLUGIN_SOURCEPROPERTIES error null-reply\n");
        v32 = 4294967246;
      }
      if (v77)
      {
        if (v20)
          IIOImageReadSession::releaseBytePointer((IIOImageRead **)v20, v77);
      }
      xpc_release(v19);
      IIOString::~IIOString((IIOString *)v76);
    }
    else
    {
      v32 = 4294967246;
    }
    kdebug_trace();
    return v32;
  }
}

void sub_187EA9B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOXPCClient::useServerForSourceProperties(IIOXPCClient *a1, IIOImageRead *a2, uint64_t a3, int a4)
{
  return IIOXPCClient::useServerForCall(a1, a2, a3, a4, 3, 1);
}

uint64_t CGImageSourceGetRead(uint64_t a1)
{
  uint64_t v1;

  if (a1 && (v1 = *(_QWORD *)(a1 + 24)) != 0)
    return CGImageSourceGetSource(*(_QWORD *)(v1 + 16));
  else
    return 0;
}

uint64_t IIO_Reader_PNG::hasCustomSourcePropertiesProc(IIO_Reader_PNG *this)
{
  return 1;
}

uint64_t IIO_Reader::hasCustomSourcePropertiesProc(IIO_Reader *this)
{
  return 0;
}

__n128 IIOImageSource::makeThumbTransform@<Q0>(float a1@<S0>, float a2@<S1>, unint64_t a3@<X1>, unint64_t a4@<X2>, int a5@<W3>, uint64_t a6@<X8>)
{
  float v7;
  BOOL v8;
  float v9;
  int v10;
  double *v11;
  __n128 result;
  __int128 v13;
  double v14[6];
  double v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  double v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  double v25;
  double v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  double v30;
  uint64_t v31;
  double v32;
  uint64_t v33;
  double v34;
  double v35;
  uint64_t v36;
  double v37;
  double v38;
  uint64_t v39;
  double v40;
  double v41;
  uint64_t v42;
  uint64_t v43;
  double v44;
  uint64_t v45;
  double v46;
  double v47;
  __int128 v48;
  __int128 v49;
  double v50;
  double v51;
  uint64_t v52;
  double v53;
  uint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v7 = a2 / a1;
  if (a2 <= a1)
    v7 = 1.0;
  v8 = a1 <= a2;
  v9 = a1 / a2;
  v14[0] = v7;
  v14[1] = 0.0;
  v14[2] = 0.0;
  if (v8)
    v9 = 1.0;
  v14[3] = v9;
  v14[4] = 0.0;
  v14[5] = 0.0;
  v15 = (float)-v7;
  v16 = 0;
  v17 = 0;
  v18 = v9;
  v19 = (float)(v7 * (float)a3);
  v20 = 0;
  v21 = v15;
  v22 = 0;
  v23 = 0;
  v24 = (float)-v9;
  v25 = v19;
  v26 = (float)(v9 * (float)a4);
  v27 = v7;
  v28 = 0;
  v29 = 0;
  v30 = v24;
  v31 = 0;
  v32 = v26;
  v33 = 0;
  v34 = v15;
  v35 = v24;
  v36 = 0;
  v37 = v26;
  v38 = v19;
  v39 = 0;
  v40 = v15;
  v41 = v9;
  v42 = 0;
  v43 = 0;
  v44 = v19;
  v45 = 0;
  v46 = v7;
  v47 = v9;
  v49 = 0u;
  v48 = 0u;
  v50 = v7;
  v51 = v24;
  v52 = 0;
  v53 = v26;
  v54 = 0;
  if ((a5 - 9) >= 0xFFFFFFF8)
    v10 = a5 - 1;
  else
    v10 = 0;
  v11 = &v14[6 * v10];
  result = *(__n128 *)v11;
  v13 = *((_OWORD *)v11 + 2);
  *(_OWORD *)(a6 + 16) = *((_OWORD *)v11 + 1);
  *(_OWORD *)(a6 + 32) = v13;
  *(__n128 *)a6 = result;
  return result;
}

uint64_t IIO_Reader::canScaleThumbnailToFinalSize(IIO_Reader *this)
{
  return 0;
}

CGImage *CGImageCreateCopyWithParametersNew(CGImage *a1, CGColor *a2, CGAffineTransform *a3, unint64_t a4, unint64_t a5, unint64_t a6, size_t a7, unint64_t a8, CGColorSpaceRef space, CGBitmapInfo a10, BOOL a11, CGColorRenderingIntent a12, CGInterpolationQuality a13, BOOL a14)
{
  CGColorSpace *v19;
  size_t Width;
  size_t Height;
  size_t v22;
  CGBitmapInfo v23;
  unsigned int v24;
  unsigned int v25;
  CGColorSpaceModel Model;
  CGColorSpaceModel v27;
  CGImage *v28;
  CGColorSpace *DeviceGray;
  CGColorSpace *v30;
  CGImage *CopyWithColorSpace;
  CGContext *v32;
  unint64_t v33;
  FILE *v34;
  const char *v35;
  size_t v36;
  _BOOL4 v37;
  _BOOL4 v38;
  unint64_t v39;
  BOOL v40;
  CGBitmapInfo v41;
  int v42;
  int v43;
  unsigned int v44;
  char *v45;
  double v46;
  double v47;
  void *Data;
  __int128 v49;
  CGImage *v50;
  uint64_t v51;
  CGImageRef Image;
  double v53;
  CGImage *v54;
  CGImageRef CopyWithBitmapInfo;
  uint64_t v59;
  unint64_t v60;
  size_t v61;
  unint64_t v62;
  unint64_t v63;
  int v66;
  CGAffineTransform transform;
  CGRect v69;
  CGRect v70;
  CGRect v71;

  if ((gIIODebugFlags & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateCopyWithParametersNew");
  v19 = CGColorSpaceRetain(space);
  if (!a4 || !a5)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 525, "*** ERROR: bad dimension: %dx%d\n");
    goto LABEL_25;
  }
  if (!a1)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 526, "*** ERROR: image is NULL\n");
LABEL_25:
    if (!v19)
      return 0;
    goto LABEL_49;
  }
  Width = CGImageGetWidth(a1);
  Height = CGImageGetHeight(a1);
  if (a6 > 0x20 || ((1 << a6) & 0x100010100) == 0)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 528, "*** ERROR: bad bitsPerComponent '%d'\n");
    goto LABEL_25;
  }
  if (!v19)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 529, "*** ERROR: targetColorSpace is NULL\n");
    return 0;
  }
  v22 = Height;
  v23 = a10;
  v24 = a10 & 0x1F;
  if (_GetMinimalPixelSize(v19, a6, v24) > a7)
  {
    _GetMinimalPixelSize(v19, a6, a10 & 0x1F);
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 530, "*** ERROR: bpp: %d   minPixelSize: %d");
    goto LABEL_49;
  }
  if (a8 < (a7 * a4 + 7) >> 3)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 531, "*** ERROR: bad bytesPerRow %d for width: %d bpc: %d\n");
    goto LABEL_49;
  }
  if (CGColorSpaceGetType() == 7)
  {
    CGColorSpaceGetType();
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 532, "*** ERROR: bad targetColorSpaceType %d\n");
    goto LABEL_49;
  }
  if (!_ValidAlphaInfo(a6, a7, v19, a10 & 0x1F))
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 533, "*** ERROR: bad bpc:%d bpp:%d alpha:%d\n");
    goto LABEL_49;
  }
  v62 = v22;
  v63 = Width;
  v25 = a10 & 0xFFFFFFE0;
  Model = CGColorSpaceGetModel(v19);
  v27 = Model;
  if (Model != kCGColorSpaceModelRGB)
  {
    v60 = a8;
    v61 = a7;
    if (Model == kCGColorSpaceModelCMYK)
    {
      v66 = 0;
      if (a6 != 8 || a7 != 40 || v24 - 1 > 3)
        goto LABEL_65;
      a8 = (4 * (a4 & 0x7FFFFFFFFFFFFFFLL) + 15) & 0x3FFFFFFFFFFFFFF0;
      v66 = 1;
      LODWORD(a7) = 40;
    }
    else
    {
      if (a6 == 8 && a7 == 16 && Model == kCGColorSpaceModelMonochrome)
      {
        if (v24 - 1 >= 4)
        {
          if (v24 - 5 < 2)
            v23 = v25 | 5;
        }
        else
        {
          v23 = v25 | 1;
        }
        v66 = 0;
        a8 = (2 * a4 + 15) & 0xFFFFFFFFFFFFFFF0;
        LODWORD(a7) = 16;
        goto LABEL_65;
      }
      v66 = 0;
      if (a6 != 16 || a7 != 32 || (a10 & 0x1F) == 0 || Model)
        goto LABEL_65;
      a8 = (4 * a4 + 15) & 0xFFFFFFFFFFFFFFF0;
      v66 = 1;
      LODWORD(a7) = 32;
    }
    v23 = a10 & 0xFFFFFFE0;
    goto LABEL_65;
  }
  if ((a10 & 0x100) == 0)
  {
    if (a6 == 8 && a7 == 24 && (a10 & 0x1F) == 0)
    {
LABEL_18:
      v23 = v25 | 5;
      goto LABEL_59;
    }
    if (a7 == 32 && a6 == 8 && v24 == 4)
    {
      v23 = v25 | 2;
      goto LABEL_59;
    }
    if (a7 != 32 || a6 != 8 || v24 != 3)
    {
      if (a7 != 32 || a6 != 8 || v24 != 6)
      {
        if ((a7 != 32 || a6 != 8 || v24 != 5)
          && (a6 != 16 || a7 != 48 || (a10 & 0x1F) != 0)
          && (a7 != 64 || a6 != 16 || v24 != 6))
        {
          if (v24 == 3 && a6 == 16 && a7 == 64)
            v23 = v25 | 1;
          goto LABEL_59;
        }
        goto LABEL_18;
      }
      v23 = v25 | 6;
LABEL_59:
      v60 = a8;
      v61 = a7;
      v66 = 0;
      if (v23 == a10)
      {
        v23 = a10;
      }
      else
      {
        LODWORD(a7) = 4 * a6;
        a8 = (((4 * a6 * a4) >> 3) + 15) & 0x3FFFFFFFFFFFFFF0;
      }
      goto LABEL_65;
    }
LABEL_58:
    v23 = v25 | 1;
    goto LABEL_59;
  }
  if (a6 != 16 && a6 != 32)
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 548, "*** ERROR: bitsPerPixel: %d alphaInfo:%d\n");
LABEL_49:
    CGColorSpaceRelease(v19);
    return 0;
  }
  if (v24 - 1 < 4)
  {
    if (a7 == 64 || a7 == 128)
      goto LABEL_58;
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 561, "*** ERROR: bitsPerPixel: %d alphaInfo:%d\n");
    goto LABEL_49;
  }
  if (v24 - 5 < 2)
  {
    if (a7 == 64 || a7 == 128)
      goto LABEL_18;
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 566, "*** ERROR: bitsPerPixel: %d alphaInfo:%d\n");
    goto LABEL_49;
  }
  if ((a10 & 0x1F) == 0)
  {
    if (a7 == 48 || a7 == 96)
      goto LABEL_18;
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 553, "*** ERROR: bitsPerPixel: %d alphaInfo:%d\n");
    goto LABEL_49;
  }
  v66 = 0;
  v60 = a8;
  v61 = a7;
LABEL_65:
  CGImageGetColorSpace(a1);
  if (!CGColorSpaceEqualToColorSpace())
    goto LABEL_74;
  if (v27 == kCGColorSpaceModelMonochrome)
  {
    DeviceGray = CGColorSpaceCreateDeviceGray();
    goto LABEL_72;
  }
  if (v27 == kCGColorSpaceModelRGB)
  {
    DeviceGray = CGColorSpaceCreateDeviceRGB();
    goto LABEL_72;
  }
  if (v27 != kCGColorSpaceModelCMYK)
  {
LABEL_74:
    CopyWithColorSpace = 0;
    v30 = 0;
    goto LABEL_76;
  }
  DeviceGray = CGColorSpaceCreateDeviceCMYK();
LABEL_72:
  v30 = DeviceGray;
  if (DeviceGray)
    CopyWithColorSpace = CGImageCreateCopyWithColorSpace(a1, DeviceGray);
  else
    CopyWithColorSpace = 0;
LABEL_76:
  if (v66)
  {
    v59 = 0;
    v32 = (CGContext *)CGBitmapContextCreateWithAlpha();
    if (!v32)
      v33 = _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 688, "*** ERROR: CGBitmapContextCreateWithAlpha returned NULL\n", 0).n128_u64[0];
    if ((gIIODebugFlags & 0x400000000) != 0)
    {
      v34 = (FILE *)*MEMORY[0x1E0C80C10];
      v35 = "\nCGImageCreateCopyWithParametersNew - CGBitmapContextCreateWithAlpha\n";
      v36 = 69;
LABEL_101:
      fwrite(v35, v36, 1uLL, v34);
    }
  }
  else
  {
    v37 = v27 == kCGColorSpaceModelCMYK;
    v38 = v23 != 0;
    v39 = 64;
    if (a6 == 8)
      v39 = 32;
    v40 = !v37 || !v38;
    if (v37 && v38)
      v41 = 0;
    else
      v41 = v23;
    if (v40)
    {
      v42 = a7;
    }
    else
    {
      a8 = (v39 >> 3) * a4;
      v42 = v39;
    }
    if (a14)
      v43 = v41;
    else
      v43 = v41 | 0x1000;
    if (a6 != 16)
      v43 = v41;
    if (a6 == 32)
      v44 = v43 | 0x100;
    else
      v44 = v43;
    v59 = 0;
    v32 = (CGContext *)CGBitmapContextCreateWithDictionary();
    if (!v32)
    {
      _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 748, "*** ERROR: CGBitmapContextCreateWithDictionary returned NULL\n", 0);
      v45 = IIO_BitmapInfoString(v44);
      v33 = _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 749, "           size: %d x %d  rb: %d   bpc: %d   bpp: %d   bmi: %04X (%s)\n", a4, a5, a8, a6, v42, v44, v45).n128_u64[0];
    }
    if ((gIIODebugFlags & 0x400000000) != 0)
    {
      v34 = (FILE *)*MEMORY[0x1E0C80C10];
      v35 = "\nCGImageCreateCopyWithParametersNew - CGBitmapContextCreateWithDictionary\n";
      v36 = 74;
      goto LABEL_101;
    }
  }
  if (v32)
  {
    v46 = (double)a4;
    v47 = (double)a5;
    if (a2)
    {
      Data = CGBitmapContextGetData(v32);
      if (CGColorGetAlpha(a2) != 1.0)
        memset(Data, 255, a8 * a5);
      CGContextSetFillColorWithColor(v32, a2);
      v69.origin.x = 0.0;
      v69.origin.y = 0.0;
      v69.size.width = (double)a4;
      v69.size.height = (double)a5;
      CGContextFillRect(v32, v69);
    }
    else
    {
      v70.origin.x = 0.0;
      v70.origin.y = 0.0;
      v70.size.width = (double)a4;
      v70.size.height = (double)a5;
      CGContextClearRect(v32, v70);
    }
    CGContextSetInterpolationQuality(v32, a13);
    if (a3->a != 0.0 || a3->b != 0.0 || a3->c != 0.0 || a3->d != 0.0)
    {
      v46 = (double)v63;
      v47 = (double)v62;
      v49 = *(_OWORD *)&a3->c;
      *(_OWORD *)&transform.a = *(_OWORD *)&a3->a;
      *(_OWORD *)&transform.c = v49;
      *(_OWORD *)&transform.tx = *(_OWORD *)&a3->tx;
      CGContextConcatCTM(v32, &transform);
    }
    if (CopyWithColorSpace)
      v50 = CopyWithColorSpace;
    else
      v50 = a1;
    v71.origin.x = 0.0;
    v71.origin.y = 0.0;
    v71.size.width = v46;
    v71.size.height = v47;
    CGContextDrawImage(v32, v71, v50);
    if (CGImageGetImageProvider() && (v51 = *MEMORY[0x1E0C9AE50], v51 == CGImageProviderGetProperty()))
    {
      LogError("CGImageCreateCopyWithParametersNew", 805, "*** ERROR: image decode failed due to 'kCMPhotoError_XPCError'\n");
    }
    else
    {
      Image = CGBitmapContextCreateImage(v32);
      if (Image)
      {
        v54 = Image;
        if ((gIIODebugFlags & 0x400000000) != 0)
          fwrite("\nCGBitmapContextCreateImage:\n", 0x1DuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
        CGImageSetProperty();
        CGImageSetProperty();
        v28 = CGImageCreateCopyWithColorSpace(v54, v19);
        if ((gIIODebugFlags & 0x400000000) != 0)
          fwrite("\nCGImageCreateCopyWithColorSpace:\n", 0x22uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
        CGImageRelease(v54);
        if (v28)
        {
          if (!v66
            || (CopyWithBitmapInfo = CGImageCreateCopyWithBitmapInfo(v28, 0, v61, v60, a10, a11, a12),
                CFRelease(v28),
                (v28 = CopyWithBitmapInfo) != 0))
          {
            CGImageSetProperty();
          }
        }
        else
        {
          _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 852, "*** ERROR: dstImage is NULL\n");
        }
        goto LABEL_129;
      }
      _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 834, "*** ERROR: CGBitmapContextCreateImage returned NULL\n", v53, v59);
    }
  }
  else
  {
    _cg_jpeg_mem_term("CGImageCreateCopyWithParametersNew", 757, "*** ERROR: context is NULL\n", *(double *)&v33, v59);
  }
  v28 = 0;
LABEL_129:
  CGColorSpaceRelease(v19);
  if (v30)
    CGColorSpaceRelease(v30);
  if (CopyWithColorSpace)
    CGImageRelease(CopyWithColorSpace);
  if (v32)
    CFRelease(v32);
  return v28;
}

BOOL _ValidAlphaInfo(uint64_t a1, size_t a2, CGColorSpaceRef space, unsigned int a4)
{
  if (!a4)
    return CGColorSpaceGetNumberOfComponents(space) * a1 == a2;
  if (a4 <= 4)
    return a1 + a1 * CGColorSpaceGetNumberOfComponents(space) <= a2;
  if (a4 - 5 > 1)
    return 0;
  return CGColorSpaceGetNumberOfComponents(space) * a1 < a2;
}

uint64_t IIOReadPlugin::setDecodeMode(uint64_t result, char a2)
{
  *(_BYTE *)(result + 216) = a2;
  return result;
}

uint64_t IIO_Reader_GIF::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  GIFReadPlugin::GIFReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187EAA868(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4034E73E8FLL);
  _Unwind_Resume(a1);
}

_QWORD *GIFReadPlugin::GIFReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *result = &off_1E1BACAC8;
  *(_QWORD *)((char *)result + 436) = 0;
  return result;
}

uint64_t IIO_Reader_ASTC::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  ASTCReadPlugin::ASTCReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187EAA92C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F05BA732);
  _Unwind_Resume(a1);
}

uint64_t ASTCReadPlugin::ASTCReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result;

  result = CommonASTCReadPlugin::CommonASTCReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)result = &off_1E1BADE88;
  *(_QWORD *)(result + 502) = -1;
  *(_QWORD *)(result + 488) = -1;
  *(_QWORD *)(result + 496) = -1;
  *(_WORD *)(result + 504) = 0;
  return result;
}

uint64_t IIO_Reader_GIF::hasCustomSourcePropertiesProc(IIO_Reader_GIF *this)
{
  return 1;
}

uint64_t IIO_Reader_GIF::updateSourceProperties(IIO_Reader_GIF *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  return IIO_Reader_GIF::parse(this, a2, a4, a6, 0, a3);
}

uint64_t IIO_Reader_HEIF::hasCustomSourcePropertiesProc(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::updateSourceProperties(IIO_Reader_HEIF *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  GlobalHEIFInfo *v9;
  char BoolForKey;
  char v11;
  uint64_t v12;
  int NumberOfAuxImages;
  int v14;
  unsigned int v15;
  const __CFString *v16;
  HEIFGroupItem *HEIFAuxImageAtIndex;
  int GroupPictureIndexListCount;
  int GroupType;
  int v20;
  int v21;
  int v22;
  __CFString *MonoscopicImageLocationString;
  int DisparityAdjustment;
  int StereoAggressorCount;
  const __CFString *v26;
  unsigned int j;
  IIOImageSource *StereoAggressorAtIndex;
  const void *v29;
  const void *Ref;
  float Severity;
  unsigned int i;
  int GroupPictureIndexAtIndex;
  int IsAnonymous;
  int NumberOfMainImages;
  int v36;
  IIODictionary *v37;
  HEIFMainImage *HEIFMainImageAtIndex;
  int v39;
  int v40;
  const void *ColorSpaceName;
  unsigned int k;
  HEIFMainImage *v43;
  double FrameDuration;
  const CFStringRef *v45;
  const __CFString *v46;
  int v47;
  char v48;
  HEIFMainImage *v49;
  int v50;
  int v51;
  int v52;
  const void *v53;
  _BOOL4 v54;
  IIONumber *v55;
  int FrameCount;
  unsigned int n;
  HEIFGroupItem *HEIFThumbnailImageAtIndex;
  int v59;
  int v60;
  int v61;
  int v62;
  IIONumber *v63;
  unsigned int ii;
  HEIFAuxImage *v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  const __CFString *v72;
  uint64_t Size;
  const __CFString *v74;
  CFComparisonResult v75;
  CFComparisonResult v76;
  CFComparisonResult v77;
  CFComparisonResult v78;
  CFComparisonResult v79;
  float v80;
  int v81;
  unsigned int jj;
  HEIFAlternateImage *HEIFAlternateImageAtIndex;
  int PrimaryImageIndex;
  uint64_t v86;
  void *v88;
  HEIFMainImage *v90;
  IIO_Reader_HEIF *v91;
  unsigned int m;
  uint64_t v93;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  void *v97;
  void *v98;
  _BYTE v99[24];
  _BYTE v100[24];
  _BYTE v101[24];
  CFMutableArrayRef v102;
  const void *v103;
  const void *v104;
  CFMutableArrayRef v105;
  const void *v106;
  const void *v107;
  CFMutableArrayRef v108;
  const void *v109;
  const void *v110;
  CFMutableArrayRef v111;
  const void *v112;
  const void *v113;
  CFMutableArrayRef v114;
  const void *v115;
  uint64_t v116;

  IIO_LoadHEIFSymbols();
  v9 = IIOImageReadSession::globalInfoForType(a2, 1212500294);
  if (!v9)
  {
    v9 = (GlobalHEIFInfo *)operator new();
    GlobalHEIFInfo::GlobalHEIFInfo(v9);
    IIOImageReadSession::setGlobalInfo((IIOImageRead **)a2, 1212500294, v9, (void (*)(void *))globalHEIFInfoReleaseProc);
    if (IIODictionary::containsKey(a4, "shouldExposeMultiFrameContents"))
    {
      BoolForKey = IIODictionary::getBoolForKey(a4, CFSTR("shouldExposeMultiFrameContents"));
      GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v9, BoolForKey);
    }
    if (IIODictionary::containsKey(a4, "useImageSequence"))
    {
      v11 = IIODictionary::getBoolForKey(a4, CFSTR("useImageSequence"));
      GlobalHEIFInfo::setUseHEIFSequence((uint64_t)v9, v11);
    }
  }
  v12 = (*(uint64_t (**)(IIO_Reader_HEIF *, GlobalHEIFInfo *, IIOImageReadSession *, _QWORD))(*(_QWORD *)this + 272))(this, v9, a2, 0);
  v86 = v12;
  if ((_DWORD)v12)
  {
    LogError("updateSourceProperties", 728, "*** ERROR: extractImageInfo failed: %d\n", v12);
  }
  else
  {
    NumberOfAuxImages = HEIFMainImage::getNumberOfAuxImages(v9);
    v90 = v9;
    if (NumberOfAuxImages)
    {
      v14 = NumberOfAuxImages;
      v91 = this;
      v114 = 0;
      v115 = 0;
      v116 = 0;
      IIOArray::IIOArray((IIOArray *)&v114);
      v15 = 0;
      v16 = CFSTR("Alternate");
      do
      {
        HEIFAuxImageAtIndex = (HEIFGroupItem *)HEIFMainImage::getHEIFAuxImageAtIndex(v9, v15);
        if (HEIFAuxImageAtIndex)
        {
          v111 = 0;
          v112 = 0;
          v113 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v111);
          GroupPictureIndexListCount = HEIFGroupItem::getGroupPictureIndexListCount(HEIFAuxImageAtIndex);
          GroupType = HEIFGroupItem::getGroupType(HEIFAuxImageAtIndex);
          if (GroupType == 1634497650)
          {
            IIODictionary::setObjectForKey((IIODictionary *)&v111, v16, CFSTR("GroupType"));
            v108 = 0;
            v109 = 0;
            v110 = 0;
            IIOArray::IIOArray((IIOArray *)&v108);
            if (GroupPictureIndexListCount)
            {
              for (i = 0; i != GroupPictureIndexListCount; ++i)
              {
                GroupPictureIndexAtIndex = HEIFGroupItem::getGroupPictureIndexAtIndex(HEIFAuxImageAtIndex, i);
                IIONumber::IIONumber((IIONumber *)&v105, GroupPictureIndexAtIndex);
                IIOArray::addObject(&v108, v107);
                IIONumber::~IIONumber((IIONumber *)&v105);
              }
            }
            IIODictionary::setObjectForKey((IIODictionary *)&v111, v109, CFSTR("GroupImages"));
            IIOArray::~IIOArray((IIOArray *)&v108);
          }
          else if (GroupType == 1937007986 && (GroupPictureIndexListCount & 0xFFFFFFFE) == 2)
          {
            IIODictionary::setObjectForKey((IIODictionary *)&v111, CFSTR("StereoPair"), CFSTR("GroupType"));
            v20 = HEIFGroupItem::getGroupPictureIndexAtIndex(HEIFAuxImageAtIndex, 0);
            IIONumber::IIONumber((IIONumber *)&v108, v20);
            IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, CFSTR("GroupImageIndexLeft"));
            IIONumber::~IIONumber((IIONumber *)&v108);
            v21 = HEIFGroupItem::getGroupPictureIndexAtIndex(HEIFAuxImageAtIndex, 1u);
            IIONumber::IIONumber((IIONumber *)&v108, v21);
            IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, CFSTR("GroupImageIndexRight"));
            IIONumber::~IIONumber((IIONumber *)&v108);
            if (GroupPictureIndexListCount == 3)
            {
              v22 = HEIFGroupItem::getGroupPictureIndexAtIndex(HEIFAuxImageAtIndex, 2u);
              IIONumber::IIONumber((IIONumber *)&v108, v22);
              IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, CFSTR("GroupImageIndexMonoscopic"));
              IIONumber::~IIONumber((IIONumber *)&v108);
              MonoscopicImageLocationString = HEIFGroupItem::getMonoscopicImageLocationString(HEIFAuxImageAtIndex);
              if (MonoscopicImageLocationString)
                IIODictionary::setObjectForKey((IIODictionary *)&v111, MonoscopicImageLocationString, CFSTR("GroupImageIndexMonoscopicImageLocation"));
            }
            if (HEIFGroupItem::hasDisparityAdjustment(HEIFAuxImageAtIndex))
            {
              DisparityAdjustment = HEIFGroupItem::getDisparityAdjustment(HEIFAuxImageAtIndex);
              IIONumber::IIONumber((IIONumber *)&v108, DisparityAdjustment);
              IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, CFSTR("GroupImageDisparityAdjustment"));
              IIONumber::~IIONumber((IIONumber *)&v108);
            }
            StereoAggressorCount = HEIFGroupItem::getStereoAggressorCount(HEIFAuxImageAtIndex);
            if (StereoAggressorCount)
            {
              v26 = v16;
              v108 = 0;
              v109 = 0;
              v110 = 0;
              IIOArray::IIOArray((IIOArray *)&v108);
              for (j = 0; j != StereoAggressorCount; ++j)
              {
                StereoAggressorAtIndex = (IIOImageSource *)HEIFGroupItem::getStereoAggressorAtIndex(HEIFAuxImageAtIndex, j);
                v105 = 0;
                v106 = 0;
                v107 = 0;
                IIODictionary::IIODictionary((IIODictionary *)&v105);
                v29 = (const void *)IIOImageSource::cf(StereoAggressorAtIndex);
                IIODictionary::setObjectForKey((IIODictionary *)&v105, v29, CFSTR("Type"));
                if (IIOImageSource::imageReadRef(StereoAggressorAtIndex))
                {
                  Ref = (const void *)IIOImageSource::imageReadRef(StereoAggressorAtIndex);
                  IIODictionary::setObjectForKey((IIODictionary *)&v105, Ref, CFSTR("SubTypeURI"));
                }
                if (HEIFStereoAggressor::hasSeverity(StereoAggressorAtIndex))
                {
                  Severity = HEIFStereoAggressor::getSeverity(StereoAggressorAtIndex);
                  IIONumber::IIONumber((IIONumber *)&v102, Severity);
                  IIODictionary::setObjectForKey((IIODictionary *)&v105, v104, CFSTR("Severity"));
                  IIONumber::~IIONumber((IIONumber *)&v102);
                }
                IIOArray::addObject(&v108, v106);
                IIODictionary::~IIODictionary((IIODictionary *)&v105);
              }
              IIODictionary::setObjectForKey((IIODictionary *)&v111, v109, CFSTR("GroupImageStereoAggressors"));
              v16 = v26;
              IIOArray::~IIOArray((IIOArray *)&v108);
            }
          }
          IsAnonymous = TIFFFieldIsAnonymous((uint64_t)HEIFAuxImageAtIndex);
          IIONumber::IIONumber((IIONumber *)&v108, IsAnonymous);
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, CFSTR("GroupIndex"));
          IIONumber::~IIONumber((IIONumber *)&v108);
          IIOArray::addObject(&v114, v112);
          IIODictionary::~IIODictionary((IIODictionary *)&v111);
        }
        ++v15;
      }
      while (v15 != v14);
      IIODictionary::setObjectForKey(a3, v115, CFSTR("{Groups}"));
      IIOArray::~IIOArray((IIOArray *)&v114);
      this = v91;
    }
    if (GlobalHEIFInfo::hasHEIFSequence(v9) && IIOImageRead::trustedURL(v9))
    {
      NumberOfMainImages = GlobalHEIFInfo::getNumberOfMainImages(v9);
      if (NumberOfMainImages)
      {
        v36 = NumberOfMainImages;
        v114 = 0;
        v115 = 0;
        v116 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v114);
        IIODictionary::setObjectForKey(v37, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("CanAnimate"));
        HEIFMainImageAtIndex = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v9, 0);
        v39 = HEIFMainImage::width(HEIFMainImageAtIndex);
        v40 = HEIFMainImage::height(HEIFMainImageAtIndex);
        ColorSpaceName = (const void *)HEIFMainImage::getColorSpaceName(HEIFMainImageAtIndex);
        if (v39)
        {
          IIONumber::IIONumber((IIONumber *)&v111, v39);
          IIODictionary::setObjectForKey((IIODictionary *)&v114, v113, CFSTR("CanvasPixelWidth"));
          IIONumber::~IIONumber((IIONumber *)&v111);
        }
        if (v40)
        {
          IIONumber::IIONumber((IIONumber *)&v111, v40);
          IIODictionary::setObjectForKey((IIODictionary *)&v114, v113, CFSTR("CanvasPixelHeight"));
          IIONumber::~IIONumber((IIONumber *)&v111);
        }
        if (ColorSpaceName)
          IIODictionary::setObjectForKey((IIODictionary *)&v114, ColorSpaceName, CFSTR("NamedColorSpace"));
        v111 = 0;
        v112 = 0;
        v113 = 0;
        IIOArray::IIOArray((IIOArray *)&v111);
        for (k = 0; k != v36; ++k)
        {
          v43 = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v9, k);
          FrameDuration = HEIFMainImage::getFrameDuration(v43);
          v108 = 0;
          v109 = 0;
          v110 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v108);
          IIONumber::IIONumber((IIONumber *)v101, FrameDuration);
          IIODictionary::setObjectForKey((uint64_t)&v108, (uint64_t)v101, CFSTR("DelayTime"));
          IIONumber::~IIONumber((IIONumber *)v101);
          IIOArray::addObject(&v111, v109);
          IIODictionary::~IIODictionary((IIODictionary *)&v108);
        }
        IIODictionary::setObjectForKey((IIODictionary *)&v114, v112, CFSTR("FrameInfo"));
        v45 = &kCGImagePropertyAVISDictionary;
        if (*((_DWORD *)this + 6) != 1096173907)
          v45 = &kCGImagePropertyHEICSDictionary;
        v46 = *v45;
        IIODictionary::setObjectForKey(a3, v115, *v45);
        IIONumber::IIONumber((IIONumber *)v100, 0);
        IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v100, CFSTR("LoopCount"), v46);
        IIONumber::~IIONumber((IIONumber *)v100);
        IIOArray::~IIOArray((IIOArray *)&v111);
        IIODictionary::~IIODictionary((IIODictionary *)&v114);
      }
    }
    else
    {
      v114 = 0;
      v115 = 0;
      v116 = 0;
      IIOArray::IIOArray((IIOArray *)&v114);
      v47 = GlobalHEIFInfo::getNumberOfMainImages(v9);
      IIONumber::IIONumber((IIONumber *)&v111, v47);
      IIODictionary::setObjectForKeyGroup(a3, v113, CFSTR("ImageCount"), CFSTR("{FileContents}"));
      IIONumber::~IIONumber((IIONumber *)&v111);
      if (GlobalHEIFInfo::hasHEIFSequence(v9))
      {
        v88 = (void *)*MEMORY[0x1E0C9AE50];
        IIODictionary::setObjectForKey(a3, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("CanAnimate"));
      }
      else
      {
        IIODictionary::setObjectForKey(a3, (const void *)*MEMORY[0x1E0C9AE40], CFSTR("CanAnimate"));
        v88 = (void *)*MEMORY[0x1E0C9AE50];
      }
      v48 = 0;
      for (m = 0; m < GlobalHEIFInfo::getNumberOfMainImages(v9); ++m)
      {
        v49 = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v9, m);
        v111 = 0;
        v112 = 0;
        v113 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v111);
        v50 = HEIFMainImage::width(v49);
        v51 = HEIFMainImage::height(v49);
        v52 = *((_DWORD *)v49 + 38);
        v53 = (const void *)HEIFMainImage::getColorSpaceName(v49);
        v54 = a5
           && IIODictionary::containsKey(a5, CFSTR("kCGImageSourceAddHEIFContainerItemID"))
           && IIODictionary::getBoolForKey(a5, CFSTR("kCGImageSourceAddHEIFContainerItemID"));
        IIONumber::IIONumber((IIONumber *)&v108, m);
        IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, CFSTR("ImageIndex"));
        IIONumber::~IIONumber((IIONumber *)&v108);
        if (v50)
        {
          IIONumber::IIONumber(v55, v50);
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, CFSTR("Width"));
          IIONumber::~IIONumber((IIONumber *)&v108);
        }
        if (v51)
        {
          IIONumber::IIONumber(v55, v51);
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, CFSTR("Height"));
          IIONumber::~IIONumber((IIONumber *)&v108);
        }
        if (v52)
        {
          IIONumber::IIONumber(v55, v52);
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, CFSTR("Orientation"));
          IIONumber::~IIONumber((IIONumber *)&v108);
        }
        if (v53)
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v53, CFSTR("NamedColorSpace"));
        if (v54)
        {
          FrameCount = GlobalGIFInfo::lastFrameCount(v49);
          IIONumber::IIONumber((IIONumber *)v99, FrameCount);
          IIODictionary::setObjectForKey((uint64_t)&v111, (uint64_t)v99, CFSTR("ContainerItemID"));
          IIONumber::~IIONumber((IIONumber *)v99);
        }
        v108 = 0;
        v109 = 0;
        v110 = 0;
        IIOArray::IIOArray((IIOArray *)&v108);
        for (n = 0; n < HEIFMainImage::getNumberOfThumbnailImages(v49); ++n)
        {
          v105 = 0;
          v106 = 0;
          v107 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v105);
          HEIFThumbnailImageAtIndex = (HEIFGroupItem *)HEIFMainImage::getHEIFThumbnailImageAtIndex(v49, n);
          v59 = HEIFGroupItem::getGroupType(HEIFThumbnailImageAtIndex);
          v60 = TIFFFieldIsAnonymous((uint64_t)HEIFThumbnailImageAtIndex);
          v61 = IIO_Reader::osType(HEIFThumbnailImageAtIndex);
          v62 = HEIFThumbnailImage::dataLength(HEIFThumbnailImageAtIndex);
          if (v59)
          {
            IIONumber::IIONumber((IIONumber *)&v102, v59);
            IIODictionary::setObjectForKey((IIODictionary *)&v105, v104, CFSTR("Width"));
            IIONumber::~IIONumber((IIONumber *)&v102);
          }
          if (v60)
          {
            IIONumber::IIONumber((IIONumber *)&v102, v60);
            IIODictionary::setObjectForKey((IIODictionary *)&v105, v104, CFSTR("Height"));
            IIONumber::~IIONumber((IIONumber *)&v102);
          }
          if (v61)
          {
            IIONumber::IIONumber((IIONumber *)&v102, v61);
            IIODictionary::setObjectForKey((IIODictionary *)&v105, v104, CFSTR("ThumbnailOffset"));
            IIONumber::~IIONumber((IIONumber *)&v102);
            IIONumber::IIONumber(v63, v62);
            IIODictionary::setObjectForKey((IIODictionary *)&v105, v104, CFSTR("ThumbnailSize"));
            IIONumber::~IIONumber((IIONumber *)&v102);
          }
          if (v52)
          {
            IIONumber::IIONumber((IIONumber *)&v102, v52);
            IIODictionary::setObjectForKey((IIODictionary *)&v105, v104, CFSTR("Orientation"));
            IIONumber::~IIONumber((IIONumber *)&v102);
          }
          IIOArray::addObject(&v108, v106);
          IIODictionary::~IIODictionary((IIODictionary *)&v105);
        }
        IIODictionary::setObjectForKey((IIODictionary *)&v111, v109, CFSTR("ThumbnailImages"));
        v105 = 0;
        v106 = 0;
        v107 = 0;
        IIOArray::IIOArray((IIOArray *)&v105);
        for (ii = 0; ii < HEIFMainImage::getNumberOfAuxImages(v49); ++ii)
        {
          v102 = 0;
          v103 = 0;
          v104 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v102);
          v65 = (HEIFAuxImage *)HEIFMainImage::getHEIFAuxImageAtIndex(v49, ii);
          v66 = HEIFAuxImage::auxiliaryType(v65);
          v67 = v66;
          if (v66 < 6 || v66 == 99)
          {
            v68 = HEIFGroupItem::getGroupType(v65);
            v69 = TIFFFieldIsAnonymous((uint64_t)v65);
            v70 = HEIFGroupItem::getDisparityAdjustment(v65);
            v71 = HEIFAuxImage::auxiliaryPixelFormat(v65);
            if (v68)
            {
              IIONumber::IIONumber((IIONumber *)&v96, v68);
              IIODictionary::setObjectForKey((IIODictionary *)&v102, v98, CFSTR("Width"));
              IIONumber::~IIONumber((IIONumber *)&v96);
            }
            if (v69)
            {
              IIONumber::IIONumber((IIONumber *)&v96, v69);
              IIODictionary::setObjectForKey((IIODictionary *)&v102, v98, CFSTR("Height"));
              IIONumber::~IIONumber((IIONumber *)&v96);
            }
            if (v70)
            {
              IIONumber::IIONumber((IIONumber *)&v96, v70);
              IIODictionary::setObjectForKey((IIODictionary *)&v102, v98, CFSTR("Orientation"));
              IIONumber::~IIONumber((IIONumber *)&v96);
            }
            if (v71)
            {
              IIONumber::IIONumber((IIONumber *)&v96, v71);
              IIODictionary::setObjectForKey((IIODictionary *)&v102, v98, CFSTR("PixelFormat"));
              IIONumber::~IIONumber((IIONumber *)&v96);
            }
            v72 = CFSTR("kCGImageAuxiliaryDataTypeDisparity");
            switch(v67)
            {
              case 1u:
                goto LABEL_105;
              case 2u:
                v72 = CFSTR("kCGImageAuxiliaryDataTypeDepth");
                goto LABEL_105;
              case 3u:
                goto LABEL_107;
              case 4u:
                goto LABEL_93;
              case 5u:
                v72 = CFSTR("kCGImageAuxiliaryDataTypePortraitEffectsMatte");
                goto LABEL_105;
              default:
                if (v67 == 99)
                {
LABEL_93:
                  Size = IIOImageWriteSession::getSize(v65);
                  if (Size)
                    v74 = (const __CFString *)Size;
                  else
                    v74 = CFSTR("unknown URN");
                  v75 = CFStringCompare(v74, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte, 0);
                  v72 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationSkinMatte");
                  if (v75 == kCFCompareEqualTo)
                    goto LABEL_105;
                  v76 = CFStringCompare(v74, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte, 0);
                  v72 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationHairMatte");
                  if (v76 == kCFCompareEqualTo)
                    goto LABEL_105;
                  v77 = CFStringCompare(v74, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte, 0);
                  v72 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationTeethMatte");
                  if (v77
                    && (v78 = CFStringCompare(v74, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte, 0), v72 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationGlassesMatte"), v78)&& (v79 = CFStringCompare(v74, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte, 0), v72 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationSkyMatte"), v79))
                  {
                    if (CFStringCompare(v74, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap, 0))
                    {
                      IIODictionary::setObjectForKey((IIODictionary *)&v102, v74, CFSTR("AuxiliaryDataType"));
                    }
                    else
                    {
                      IIODictionary::setObjectForKey((IIODictionary *)&v102, CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), CFSTR("AuxiliaryDataType"));
                      v80 = HEIFAuxImage::meteorHeadroomFromMakerNote(v65);
                      if (v80 != 0.0 || (v80 = HEIFAuxImage::meteorHeadroomFromProperties(v65), v80 != 0.0))
                      {
                        IIONumber::IIONumber((IIONumber *)&v96, v80);
                        IIODictionary::setObjectForKey((IIODictionary *)&v102, v98, CFSTR("HDRHeadroom"));
                        IIONumber::~IIONumber((IIONumber *)&v96);
                      }
                    }
                  }
                  else
                  {
LABEL_105:
                    IIODictionary::setObjectForKey((IIODictionary *)&v102, v72, CFSTR("AuxiliaryDataType"));
                  }
                }
                else
                {
                  _cg_jpeg_mem_term("updateSourceProperties", 1035, "*** ERROR: auxType %d is not handled", v67);
                }
LABEL_107:
                IIOArray::addObject(&v105, v103);
                break;
            }
          }
          IIODictionary::~IIODictionary((IIODictionary *)&v102);
        }
        v9 = v90;
        if (IIOArray::getCount((IIOArray *)&v105))
        {
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v106, CFSTR("AuxiliaryData"));
          v48 = 1;
        }
        v102 = 0;
        v103 = 0;
        v104 = 0;
        IIOArray::IIOArray((IIOArray *)&v102);
        v81 = HEIFGroupItem::getStereoAggressorCount(v49);
        if (v81)
        {
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v88, CFSTR("FlexRange"));
          for (jj = 0; jj != v81; ++jj)
          {
            v96 = 0;
            v97 = 0;
            v98 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v96);
            v93 = 0;
            v94 = 0;
            v95 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v93);
            HEIFAlternateImageAtIndex = (HEIFAlternateImage *)HEIFMainImage::getHEIFAlternateImageAtIndex(v49, jj);
            HEIFAlternateImage::addInfoToProperties(HEIFAlternateImageAtIndex, (IIODictionary *)&v96);
            IIOArray::addObject(&v102, v97);
            HEIFAlternateImage::addAsAuxImageToProperties(HEIFAlternateImageAtIndex, (IIODictionary *)&v93);
            if ((v48 & 1) == 0)
              IIODictionary::setObjectForKey((IIODictionary *)&v111, v106, CFSTR("AuxiliaryData"));
            IIOArray::addObject(&v105, v94);
            IIODictionary::~IIODictionary((IIODictionary *)&v93);
            IIODictionary::~IIODictionary((IIODictionary *)&v96);
            v48 = 1;
          }
        }
        if (IIOArray::getCount((IIOArray *)&v102))
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v103, CFSTR("DerivationDetails"));
        IIOArray::addObject(&v114, v112);
        IIOArray::~IIOArray((IIOArray *)&v102);
        IIOArray::~IIOArray((IIOArray *)&v105);
        IIOArray::~IIOArray((IIOArray *)&v108);
        IIODictionary::~IIODictionary((IIODictionary *)&v111);
      }
      IIODictionary::setObjectForKeyGroup(a3, v115, CFSTR("Images"), CFSTR("{FileContents}"));
      if (GlobalHEIFInfo::getNumberOfMainImages(v9) >= 2)
      {
        PrimaryImageIndex = GlobalHEIFInfo::getPrimaryImageIndex(v9);
        IIONumber::IIONumber((IIONumber *)&v111, PrimaryImageIndex);
        IIODictionary::setObjectForKey(a3, v113, CFSTR("PrimaryImage"));
        IIONumber::~IIONumber((IIONumber *)&v111);
      }
      IIOArray::~IIOArray((IIOArray *)&v114);
    }
  }
  return v86;
}

void sub_187EABB1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIONumber::~IIONumber((IIONumber *)(v1 - 152));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 128));
  _Unwind_Resume(a1);
}

uint64_t HEIFMainImage::getNumberOfThumbnailImages(HEIFMainImage *this)
{
  return (*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3;
}

uint64_t HEIFGroupItem::getGroupType(HEIFGroupItem *this)
{
  return *((unsigned int *)this + 2);
}

void IIOTextureHandler::~IIOTextureHandler(IIOTextureHandler *this)
{
  IIOTextureHandler::~IIOTextureHandler(this);
  JUMPOUT(0x18D761C30);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E1BB10B0;
  if (*((_QWORD *)this + 5))
  {
    IIOImageReadSession::unmapData(*((const char ***)this + 6));
    CFRelease(*((CFTypeRef *)this + 5));
  }
  *((_QWORD *)this + 5) = 0;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 3) = 0;
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

const char *IIOImageReadSession::unmapData(const char **this)
{
  return IIOImageRead::unmapData(this[4]);
}

IIO_Reader *CGImageSourceGetTypeWithData(const __CFData *a1, const __CFString *a2, _BYTE *a3)
{
  IIO_ReaderHandler *v6;
  IIO_Reader ***ReaderHandler;

  IIOInitDebugFlags();
  v6 = (IIO_ReaderHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((int)v6, "S", "CGImageSourceGetTypeWithData", 0, 0, -1, 0);
  ReaderHandler = (IIO_Reader ***)IIO_ReaderHandler::GetReaderHandler(v6);
  return IIO_ReaderHandler::typeForData(ReaderHandler, a1, a2, 0, a3);
}

uint64_t IIOTextureHandler::ReleaseTextureInfo(uint64_t this, void *a2)
{
  if (this)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 8))(this);
  return this;
}

CGImageSourceStatus CGImageSourceGetStatus(CGImageSourceRef isrc)
{
  unsigned int v2;
  CFTypeID v3;
  uint64_t v4;
  CGImageSourceStatus v5;
  IIO_Reader *v6;

  kdebug_trace();
  IIOInitDebugFlags();
  v2 = (gIIODebugFlags >> 12) & 3;
  if (v2)
    ImageIODebugOptions(v2, "A", "CGImageSourceGetStatus", isrc, 0, -1, 0);
  if (!isrc)
  {
    LogError("CGImageSourceGetStatus", 5366, "*** ERROR: CGImageSourceGetStatus: source is nil\n");
LABEL_9:
    v5 = kCGImageStatusInvalidData;
    goto LABEL_17;
  }
  v3 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v3 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetStatus", 5367, "*** ERROR: CGImageSourceGetStatus: source is not a CGImageSourceRef\n");
    goto LABEL_9;
  }
  v4 = *((_QWORD *)isrc + 3);
  if (!v4 || IIOImageSource::isProxy(*((IIOImageSource **)isrc + 3)))
    goto LABEL_9;
  if (*(_BYTE *)(v4 + 65))
  {
    LogError("CGImageSourceGetStatus", 5372, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_9;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 200));
  if (IIOImageSource::bindToReader((IIOImageSource *)v4))
    v5 = *(_DWORD *)(v4 + 88);
  else
    v5 = kCGImageStatusInvalidData;
  v6 = *(IIO_Reader **)(v4 + 80);
  if (v6)
    IIO_Reader::osType(v6);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 200));
LABEL_17:
  kdebug_trace();
  return v5;
}

void __destroy_helper_block_e8_48c55_ZTSNSt3__16vectorI13IIODecodeInfoNS_9allocatorIS1_EEEE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

uint64_t _TIFFCheckDirNumberAndOffset(uint64_t a1, unsigned int a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _OWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _OWORD *v36;
  uint64_t v37;
  char v38;
  _QWORD v39[2];
  __int128 v40;

  if (!a3)
    return 0;
  v6 = *(_QWORD **)(a1 + 48);
  if (!v6)
  {
    v6 = TIFFHashSetNew((uint64_t (*)())hashFuncOffsetToNumber, (BOOL (*)(uint64_t, uint64_t))equalFuncOffsetToNumber, (uint64_t)MEMORY[0x1E0C834A8]);
    *(_QWORD *)(a1 + 48) = v6;
    if (!v6)
      goto LABEL_21;
  }
  if (*(_QWORD *)(a1 + 56))
    goto LABEL_7;
  v12 = TIFFHashSetNew((uint64_t (*)())hashFuncNumberToOffset, equalFuncNumberToOffset, 0);
  *(_QWORD *)(a1 + 56) = v12;
  if (!v12)
  {
LABEL_21:
    TIFFErrorExtR(a1, "_TIFFCheckDirNumberAndOffset", "Not enough memory", v7, v8, v9, v10, v11, v38);
    return 1;
  }
  v6 = *(_QWORD **)(a1 + 48);
LABEL_7:
  *(_QWORD *)&v40 = a3;
  *((_QWORD *)&v40 + 1) = a2;
  v13 = TIFFHashSetLookup((uint64_t)v6, (uint64_t)&v40);
  if (!v13)
  {
    v20 = TIFFHashSetLookup(*(_QWORD *)(a1 + 56), (uint64_t)&v40);
    if (v20)
    {
      if (*v20 == a3)
        return 1;
      v39[0] = *v20;
      v39[1] = a2;
      v21 = TIFFHashSetLookup(*(_QWORD *)(a1 + 56), (uint64_t)v39);
      if (v21)
        TIFFHashSetRemove(*(_QWORD *)(a1 + 56), (uint64_t)v21);
      v22 = TIFFHashSetLookup(*(_QWORD *)(a1 + 48), (uint64_t)v39);
      if (v22)
        TIFFHashSetRemove(*(_QWORD *)(a1 + 48), (uint64_t)v22);
      v23 = malloc_type_malloc(0x10uLL, 0x1000040D9A13B51uLL);
      if (!v23)
        return 0;
      v24 = (uint64_t)v23;
      *v23 = v40;
      if (TIFFHashSetInsert(*(_QWORD *)(a1 + 48), (uint64_t)v23))
      {
        if (TIFFHashSetInsert(*(_QWORD *)(a1 + 56), v24))
          return 1;
        v30 = "Insertion in tif_map_dir_number_to_offset failed";
      }
      else
      {
        v30 = "Insertion in tif_map_dir_offset_to_number failed";
      }
    }
    else
    {
      if ((int)TIFFHashSetSize(*(_QWORD *)(a1 + 48)) >= 0x100000)
      {
        TIFFErrorExtR(a1, "_TIFFCheckDirNumberAndOffset", "Cannot handle more than %u TIFF directories", v31, v32, v33, v34, v35, 0);
        return 0;
      }
      v36 = malloc_type_malloc(0x10uLL, 0x1000040D9A13B51uLL);
      if (v36)
      {
        v37 = (uint64_t)v36;
        *v36 = v40;
        if ((TIFFHashSetInsert(*(_QWORD *)(a1 + 48), (uint64_t)v36) & 1) != 0)
        {
          if ((TIFFHashSetInsert(*(_QWORD *)(a1 + 56), v37) & 1) != 0)
            return 1;
          v30 = "Insertion in tif_map_dir_number_to_offset failed";
        }
        else
        {
          v30 = "Insertion in tif_map_dir_offset_to_number failed";
        }
      }
      else
      {
        v30 = "malloc(sizeof(TIFFOffsetAndDirNumber)) failed";
      }
    }
    TIFFErrorExtR(a1, "_TIFFCheckDirNumberAndOffset", v30, v25, v26, v27, v28, v29, v38);
    return 0;
  }
  if (*((_DWORD *)v13 + 2) == a2)
    return 1;
  TIFFWarningExtR(a1, "_TIFFCheckDirNumberAndOffset", "TIFF directory %d has IFD looping to directory %u at offset 0x%llx (%llu)", v14, v15, v16, v17, v18, a2 - 1);
  return 0;
}

_QWORD *TIFFHashSetNew(uint64_t (*a1)(), BOOL (*a2)(uint64_t a1, uint64_t a2), uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t (*v8)();
  BOOL (*v9)(uint64_t, uint64_t);
  void *v10;

  v6 = malloc_type_malloc(0x40uLL, 0x10A0040F3714300uLL);
  v7 = v6;
  if (v6)
  {
    v8 = TIFFHashSetHashPointer;
    if (a1)
      v8 = a1;
    v9 = TIFFHashSetEqualPointer;
    if (a2)
      v9 = a2;
    *v6 = v8;
    v6[1] = v9;
    v6[2] = a3;
    *((_DWORD *)v6 + 8) = 0;
    v10 = malloc_type_calloc(0x35uLL, 8uLL, 0x2004093837F09uLL);
    v7[3] = v10;
    if (v10)
    {
      *(_QWORD *)((char *)v7 + 36) = 0x3500000000;
      v7[6] = 0;
      *((_DWORD *)v7 + 14) = 0;
      *((_BYTE *)v7 + 60) = 0;
    }
    else
    {
      free(v7);
      return 0;
    }
  }
  return v7;
}

_QWORD *TIFFHashSetLookup(uint64_t a1, uint64_t a2)
{
  _QWORD *result;

  if (!a1)
    TIFFHashSetLookup_cold_1();
  result = TIFFHashSetFindPtr(a1, a2);
  if (result)
    return (_QWORD *)*result;
  return result;
}

uint64_t TIFFHashSetInsert(uint64_t a1, uint64_t a2)
{
  uint64_t *Ptr;
  uint64_t *v5;
  void (*v6)(uint64_t);
  int v7;
  int v8;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  void (*v15)(uint64_t);

  if (!a1)
    TIFFHashSetInsert_cold_1();
  Ptr = TIFFHashSetFindPtr(a1, a2);
  if (Ptr)
  {
    v5 = Ptr;
    v6 = *(void (**)(uint64_t))(a1 + 16);
    if (v6)
      v6(*Ptr);
    *v5 = a2;
    return 1;
  }
  v7 = *(_DWORD *)(a1 + 32);
  if (v7 >= 2 * *(_DWORD *)(a1 + 40) / 3)
  {
    v8 = *(_DWORD *)(a1 + 36);
  }
  else
  {
    if (!*(_BYTE *)(a1 + 60))
      goto LABEL_16;
    v8 = *(_DWORD *)(a1 + 36);
    if (v7 > *(_DWORD *)(a1 + 40) / 2 || v8 < 1)
      goto LABEL_16;
  }
  *(_DWORD *)(a1 + 36) = v8 + 1;
  if (!TIFFHashSetRehash(a1))
  {
    --*(_DWORD *)(a1 + 36);
    goto LABEL_22;
  }
LABEL_16:
  v10 = (*(uint64_t (**)(uint64_t))a1)(a2);
  v11 = *(int *)(a1 + 40);
  v12 = *(_QWORD **)(a1 + 48);
  if (v12)
  {
    *v12 = 0;
    --*(_DWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 48) = v12[1];
LABEL_20:
    *v12 = a2;
    v13 = *(_QWORD *)(a1 + 24);
    v12[1] = *(_QWORD *)(v13 + 8 * (v10 % v11));
    *(_QWORD *)(v13 + 8 * (v10 % v11)) = v12;
    ++*(_DWORD *)(a1 + 32);
    return 1;
  }
  v12 = malloc_type_malloc(0x10uLL, 0xA0040BD48D6D6uLL);
  if (v12)
    goto LABEL_20;
LABEL_22:
  v15 = *(void (**)(uint64_t))(a1 + 16);
  if (v15)
    v15(a2);
  return 0;
}

_QWORD *TIFFHashSetFindPtr(uint64_t a1, uint64_t a2)
{
  _QWORD *i;

  for (i = *(_QWORD **)(*(_QWORD *)(a1 + 24)
                       + 8 * ((*(uint64_t (**)(uint64_t))a1)(a2) % (unint64_t)*(int *)(a1 + 40)));
        i;
        i = (_QWORD *)i[1])
  {
    if (((*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(*i, a2) & 1) != 0)
      break;
  }
  return i;
}

uint64_t hashFuncOffsetToNumber(_QWORD *a1)
{
  return *a1 ^ HIDWORD(*a1);
}

uint64_t hashFuncNumberToOffset(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t TIFFHashSetSize(uint64_t a1)
{
  if (!a1)
    TIFFHashSetSize_cold_1();
  return *(unsigned int *)(a1 + 32);
}

void ___ZN17IIO_ReaderHandler16GetReaderHandlerEv_block_invoke()
{
  IIO_ReaderHandler *v0;

  v0 = (IIO_ReaderHandler *)operator new();
  IIO_ReaderHandler::IIO_ReaderHandler(v0);
  IIO_ReaderHandler::GetReaderHandler(void)::gIIO_ReaderHandler = (uint64_t)v0;
}

void sub_187EAC688(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40EEBF52FBLL);
  _Unwind_Resume(a1);
}

void IIO_ReaderHandler::IIO_ReaderHandler(IIO_ReaderHandler *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 18) = 1065353216;
  *(_QWORD *)this = off_1E1BB10D0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 20) = 0;
  CFAbsoluteTimeGetCurrent();
  IIO_ReaderHandler::buildPluginList(this);
  CFAbsoluteTimeGetCurrent();
  if (IIO_XPCServer())
  {
    getpid();
    ImageIOLogInternal("*** ImageIOXPCService:  process %d buildPluginList: %g ms\n");
  }
  else
  {
    getpid();
    ImageIOLogInternal("*** ImageIO:  process %d buildPluginList: %g ms\n");
  }
}

void sub_187EAC76C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  va_list va;

  va_start(va, a4);
  std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::~__hash_table(v4 + 40);
  std::vector<std::unique_ptr<IIO_Reader>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void ___ZN12IIOXPCClient15GetIIOXPCClientEv_block_invoke()
{
  uint64_t v0;

  v0 = operator new();
  *(_QWORD *)v0 = &off_1E1BAC250;
  *(_QWORD *)(v0 + 8) = 0;
  *(_QWORD *)(v0 + 96) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v0 + 32), 0);
  IIOInitDebugFlags();
  IIOXPCClient::GetIIOXPCClient(void)::gIIOXPCClient = v0;
}

void sub_187EAC7E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409FA54CB2);
  _Unwind_Resume(a1);
}

uint64_t IIOGetBundleIdentifer()
{
  if (IIOGetBundleIdentifer::onceToken != -1)
    dispatch_once(&IIOGetBundleIdentifer::onceToken, &__block_literal_global_22);
  return IIOGetBundleIdentifer::gBundleIdentifer;
}

void _providerRelease(CGDataProvider *a1)
{
  CGDataProviderReleaseBytePtr();
  CGDataProviderRelease(a1);
}

void AdobeXMPCore_Int::IDOMImplementationRegistry_I::DestoryDOMImplementationRegistry(AdobeXMPCore_Int::IDOMImplementationRegistry_I *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  AdobeXMPCore_Int::ManageDOMImplementationRegistry((AdobeXMPCore_Int *)1, &v4);
  v1 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void AdobeXMPCore_Int::ManageDOMImplementationRegistry(AdobeXMPCore_Int *this@<X0>, uint64_t *a2@<X8>)
{
  int v2;
  unsigned __int8 v4;
  uint64_t v5;
  char *v6;
  AdobeXMPCore_Int::RDFDOMParserImpl *v7;
  char *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  AdobeXMPCore_Int::RDFDOMSerializerImpl *v15;
  char *v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  char *v29;
  std::__shared_weak_count *v30;
  char *v31;
  std::__shared_weak_count *v32;

  v2 = (int)this;
  if ((v4 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<AdobeXMPCore::IDOMImplementationRegistry_v1>::~shared_ptr[abi:ne180100], &AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry, &dword_187E34000);
  }
  v5 = AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry;
  if (v2)
  {
    if (AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry)
    {
      std::shared_ptr<AdobeXMPCore::INode_v1>::reset[abi:ne180100](&AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry);
      v5 = AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry;
    }
  }
  else if (!AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry)
  {
    v6 = (char *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x58);
    *((_QWORD *)v6 + 9) = 0;
    *((_QWORD *)v6 + 10) = 0;
    *((_QWORD *)v6 + 7) = off_1E1BBB148;
    *((_QWORD *)v6 + 8) = off_1E1BBB1B0;
    *((_QWORD *)v6 + 2) = 0;
    *(_QWORD *)v6 = off_1E1BBB088;
    *((_QWORD *)v6 + 1) = v6 + 16;
    *((_QWORD *)v6 + 6) = 0;
    *((_QWORD *)v6 + 5) = 0;
    *((_QWORD *)v6 + 3) = 0;
    *((_QWORD *)v6 + 4) = v6 + 40;
    v7 = (AdobeXMPCore_Int::RDFDOMParserImpl *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x80);
    AdobeXMPCore_Int::RDFDOMParserImpl::RDFDOMParserImpl(v7);
    AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::RDFDOMParserImpl>((char *)v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCore/source/DOMImplementationRegistryImpl.cpp", 66, 1, &v29);
    v8 = v29;
    if (v29)
      v8 = &v29[*(_QWORD *)(*(_QWORD *)v29 - 64)];
    v31 = v8;
    v32 = v30;
    v29 = 0;
    v30 = 0;
    (*(void (**)(char *, const char *, char **))(*(_QWORD *)v6 + 120))(v6, "rdf", &v31);
    v9 = v32;
    if (v32)
    {
      p_shared_owners = (unint64_t *)&v32->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    v12 = v30;
    if (v30)
    {
      v13 = (unint64_t *)&v30->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    v15 = (AdobeXMPCore_Int::RDFDOMSerializerImpl *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x70);
    AdobeXMPCore_Int::RDFDOMSerializerImpl::RDFDOMSerializerImpl(v15);
    AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::RDFDOMSerializerImpl>((char *)v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCore/source/DOMImplementationRegistryImpl.cpp", 67, 1, &v29);
    v16 = v29;
    if (v29)
      v16 = &v29[*(_QWORD *)(*(_QWORD *)v29 - 64)];
    v31 = v16;
    v32 = v30;
    v29 = 0;
    v30 = 0;
    (*(void (**)(char *, const char *, char **))(*(_QWORD *)v6 + 128))(v6, "rdf", &v31);
    v17 = v32;
    if (v32)
    {
      v18 = (unint64_t *)&v32->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
    v20 = v30;
    if (v30)
    {
      v21 = (unint64_t *)&v30->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    (**(void (***)(char *))&v6[*(_QWORD *)(*(_QWORD *)v6 - 208)])(&v6[*(_QWORD *)(*(_QWORD *)v6 - 208)]);
    std::shared_ptr<AdobeXMPCore_Int::DOMImplementationRegistryImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::DOMImplementationRegistryImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(&v31, (uint64_t)v6, 8, 1);
    std::shared_ptr<AdobeXMPCore::IDOMImplementationRegistry_v1>::operator=[abi:ne180100]<AdobeXMPCore_Int::DOMImplementationRegistryImpl,void>(&AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry, (uint64_t)&v31);
    v23 = v32;
    if (v32)
    {
      v24 = (unint64_t *)&v32->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    v5 = AdobeXMPCore_Int::ManageDOMImplementationRegistry(BOOL)::sDOMImplementationRegistry;
  }
  v26 = qword_1EDF047F0;
  *a2 = v5;
  a2[1] = v26;
  if (v26)
  {
    v27 = (unint64_t *)(v26 + 8);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
}

void sub_187EACC14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t _cg_TIFFReadDirectory(uint64_t a1)
{
  int8x8_t *v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  unsigned int v25;
  char *v26;
  int v27;
  unsigned __int16 *i;
  int v29;
  unsigned __int16 *v30;
  int v31;
  unsigned __int16 *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint8x8_t v53;
  int v54;
  int8x8_t *v55;
  unsigned __int16 *v56;
  const char *v57;
  char *v58;
  int v59;
  uint8x8_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const char *v68;
  uint64_t v69;
  int v70;
  unsigned __int16 *v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  int v86;
  int v87;
  _QWORD *v88;
  int v89;
  _QWORD *v90;
  const char *v91;
  int v92;
  int v93;
  int8x8_t *v94;
  unsigned __int16 *v95;
  unsigned int v96;
  unint64_t v97;
  _DWORD *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unsigned int v113;
  _DWORD *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unsigned int v121;
  _DWORD *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unsigned __int16 *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  int v136;
  char *v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  _DWORD *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  const char *v152;
  int8x8_t v153;
  int v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  _DWORD *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  const char *v165;
  unsigned __int16 *v166;
  unsigned __int16 *v167;
  __int32 *v168;
  char *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  int v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  unsigned int v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  int v200;
  unsigned int v201;
  unsigned int v202;
  int v203;
  __int16 v204;
  uint64_t v205;
  unsigned __int16 v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  _QWORD *v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  void *v218;
  __int16 v219;
  int v220;
  const char *v221;
  const char *v222;
  int v223;
  _DWORD *v224;
  uint64_t v225;
  unint64_t v226;
  __int16 v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  int v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  char v240;
  char v241;
  int v242;
  int v243;
  unsigned __int16 *__dst;
  _BYTE *v245;
  char *v246;
  unsigned int v247;
  void *__src;

  v247 = -1;
  v2 = (int8x8_t *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
  {
    result = 0;
    *(_QWORD *)(a1 + 24) = 0;
    return result;
  }
  result = _TIFFCheckDirNumberAndOffset(a1, *(_DWORD *)(a1 + 880) + 1, *(_QWORD *)(a1 + 32));
  if ((_DWORD)result)
  {
    __src = 0;
    v9 = TIFFFetchDirectory(a1, v3, &__src, v2, v5, v6, v7, v8);
    if (!v9)
    {
      v241 = v3;
      v26 = "Failed to read directory at offset %llu";
      goto LABEL_10;
    }
    v15 = v9;
    ++*(_DWORD *)(a1 + 880);
    (*(void (**)(uint64_t))(a1 + 1072))(a1);
    v21 = 0;
    v22 = 0;
    v23 = (unsigned __int16 *)__src;
    v24 = (unsigned __int16 *)__src;
    while (1)
    {
      v25 = *v24;
      if (v22 > v25)
        break;
      v22 = v25 + 1;
      ++v21;
      v24 += 16;
      if (v15 <= (unsigned __int16)v21)
        goto LABEL_12;
    }
    TIFFWarningExtR(a1, "TIFFReadDirectoryCheckOrder", "Invalid TIFF directory; tags are not sorted in ascending order",
      v16,
      v17,
      v18,
      v19,
      v20,
      v240);
    v23 = (unsigned __int16 *)__src;
LABEL_12:
    v27 = 0;
    for (i = v23 + 16; v15 > (unsigned __int16)++v27; i += 16)
    {
      v29 = *v23;
      v30 = i;
      v31 = v27;
      v32 = i;
      do
      {
        v33 = *v32;
        v32 += 16;
        if (v29 == v33)
          *((_BYTE *)v30 + 24) = 1;
        ++v31;
        v30 = v32;
      }
      while (v15 > (unsigned __int16)v31);
      v23 += 16;
    }
    *(_DWORD *)(a1 + 16) &= 0xFBEFFFBF;
    _cg_TIFFFreeDirectory(a1);
    TIFFDefaultDirectory(a1);
    v40 = _TIFFmallocExt((_QWORD *)a1, 16 * v15, v34, v35, v36, v37, v38, v39);
    *(_QWORD *)(a1 + 456) = v40;
    if (!v40)
    {
      v57 = "TIFFReadDirectory";
      v58 = "Failed to allocate memory for counting IFD data size at reading";
      goto LABEL_79;
    }
    v245 = (_BYTE *)(a1 + 72);
    _cg_TIFFSetField(a1, 284, v41, v42, v43, v44, v45, v46, 1);
    v54 = 0;
    v55 = (int8x8_t *)__src;
    v56 = (unsigned __int16 *)__src;
    while (*v56 != 277)
    {
      v56 += 16;
      if (v15 <= (unsigned __int16)++v54)
        goto LABEL_27;
    }
    if (!TIFFFetchNormalTag(a1, v56, 0))
      goto LABEL_80;
    *((_BYTE *)v56 + 24) = 1;
    v55 = (int8x8_t *)__src;
LABEL_27:
    v59 = 0;
    while (v55->i16[0] != 259)
    {
      v55 += 4;
      if (v15 <= (unsigned __int16)++v59)
      {
        if (!_cg_TIFFSetField(a1, 259, v47, v48, v49, v50, v51, v52, 1))
          goto LABEL_80;
        goto LABEL_39;
      }
    }
    LOWORD(v246) = 0;
    v61 = TIFFReadDirEntryShort(a1, v55, &v246, v53);
    if (v61 == 1)
      v61 = TIFFReadDirEntryPersampleShort(a1, (uint64_t)v55, &v246);
    if (v61)
    {
      v68 = "Compression";
      v69 = a1;
      goto LABEL_36;
    }
    if (!_cg_TIFFSetField(a1, 259, v62, v63, v64, v65, v66, v67, (unsigned __int16)v246))
    {
LABEL_80:
      if (__src)
        _TIFFfreeExt(a1, (char *)__src);
      return 0;
    }
    v55[3].i8[0] = 1;
LABEL_39:
    v70 = 0;
    v71 = (unsigned __int16 *)__src;
    while (1)
    {
      if (!*((_BYTE *)v71 + 24))
      {
        v72 = *v71;
        TIFFReadDirectoryFindFieldInfo(a1, v72, (int *)&v247);
        v73 = v247;
        if (v247 == -1)
        {
          TIFFWarningExtR(a1, "TIFFReadDirectory", "Unknown field with tag %hu (0x%hx) encountered", v42, v43, v44, v45, v46, v72);
          v79 = (int *)_TIFFCreateAnonField((_QWORD *)a1, *v71, v71[1], v74, v75, v76, v77, v78);
          if (!v79 || !_TIFFMergeFields(a1, v79, 1, v80, v81, v82, v83, v84))
          {
            TIFFWarningExtR(a1, "TIFFReadDirectory", "Registering anonymous field with tag %hu (0x%hx) failed", v80, v81, v82, v83, v84, *v71);
LABEL_57:
            *((_BYTE *)v71 + 24) = 1;
            goto LABEL_58;
          }
          v72 = *v71;
          TIFFReadDirectoryFindFieldInfo(a1, v72, (int *)&v247);
          v73 = v247;
          if (v247 == -1)
            _cg_TIFFReadDirectory_cold_1();
        }
        if (!*((_BYTE *)v71 + 24))
        {
          v85 = *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 1256) + 8 * v73) + 24);
          if (!(_DWORD)v85)
            goto LABEL_57;
          if (v72 - 256 <= 0x1C)
          {
            if (((1 << v72) & 0x10400003) != 0)
              goto LABEL_56;
            if (((1 << v72) & 0x820000) != 0)
            {
LABEL_61:
              *(_DWORD *)&v245[(v85 >> 3) & 0x1FFC] |= 1 << v85;
              goto LABEL_58;
            }
          }
          if (v72 - 322 <= 0x10)
          {
            v86 = 1 << (v72 - 66);
            if ((v86 & 0x10003) != 0)
              goto LABEL_56;
            if ((v86 & 0xC) != 0)
              goto LABEL_61;
          }
          if (v72 - 32997 < 2)
          {
LABEL_56:
            if (!TIFFFetchNormalTag(a1, v71, 0))
              goto LABEL_80;
            goto LABEL_57;
          }
          if (!_TIFFCheckFieldIsValidForCodec(a1, v72))
            goto LABEL_57;
        }
      }
LABEL_58:
      ++v70;
      v71 += 16;
      if (v15 <= (unsigned __int16)v70)
      {
        if (*(_WORD *)(a1 + 120) == 6 && *(_WORD *)(a1 + 170) == 2)
        {
          if (!_TIFFFillStrilesInternal(a1, 1))
            goto LABEL_80;
          v87 = 0;
          v88 = (char *)__src + 8;
          while (*((_WORD *)v88 - 4) != 273)
          {
            ++v87;
            v88 += 4;
            if (v15 <= (unsigned __int16)v87)
              goto LABEL_76;
          }
          if (*v88 == 1)
          {
            v89 = 0;
            v90 = (char *)__src + 8;
            while (*((_WORD *)v90 - 4) != 279)
            {
              ++v89;
              v90 += 4;
              if (v15 <= (unsigned __int16)v89)
                goto LABEL_76;
            }
            if (*v90 == 1)
            {
              *(_WORD *)(a1 + 170) = 1;
              TIFFWarningExtR(a1, "TIFFReadDirectory", "Planarconfig tag value assumed incorrect, assuming data is contig instead of chunky", v42, v43, v44, v45, v46, v241);
            }
          }
        }
LABEL_76:
        if ((*v245 & 2) == 0)
        {
          v91 = "ImageLength";
          goto LABEL_78;
        }
        v92 = 0;
        v93 = 0;
        v94 = (int8x8_t *)__src;
        __dst = (unsigned __int16 *)(a1 + 288);
        v95 = (unsigned __int16 *)(a1 + 256);
        while (2)
        {
          if (v94[3].i8[0])
            goto LABEL_86;
          v96 = v94->u16[0];
          if (v96 > 0x13F)
          {
            if (v94->u16[0] > 0x152u)
            {
              if (v96 - 340 < 2)
              {
                v246 = 0;
                if (*(_QWORD *)&v94[1] != *(unsigned __int16 *)(a1 + 130))
                {
                  if ((EvaluateIFDdatasizeReading(a1, v94) & 1) == 0)
                    goto LABEL_80;
                  v105 = 1;
LABEL_242:
                  LODWORD(v112) = v94->u16[0];
LABEL_243:
                  v224 = TIFFFieldWithTag((_QWORD *)a1, v112);
                  if (v224)
                    v68 = (const char *)*((_QWORD *)v224 + 4);
                  else
                    v68 = "unknown tagname";
                  v69 = a1;
                  v61 = v105;
LABEL_36:
                  TIFFReadDirEntryOutputErr(v69, v61, "TIFFReadDirectory", (uint64_t)v68, 0, v65, v66, v67);
                  goto LABEL_80;
                }
                v242 = v92;
                v129 = v95;
                v105 = TIFFReadDirEntryDoubleArray(a1, (uint64_t)v94, (__int32 **)&v246);
                if ((EvaluateIFDdatasizeReading(a1, v94) & 1) == 0)
                  goto LABEL_80;
                if (v105)
                  goto LABEL_242;
                v136 = *(_DWORD *)(a1 + 16);
                *(_DWORD *)(a1 + 16) = v136 | 0x400000;
                v137 = v246;
                v138 = _cg_TIFFSetField(a1, v94->u16[0], v130, v131, v132, v133, v134, v135, (uint64_t)v246);
                *(_DWORD *)(a1 + 16) = v136;
                _TIFFfreeExt(a1, v137);
                if (!v138)
                  goto LABEL_80;
                v95 = v129;
                v92 = v242;
                goto LABEL_86;
              }
              if (v96 == 32996 || v96 == 339)
                goto LABEL_109;
              goto LABEL_141;
            }
            if (v96 == 320)
              goto LABEL_102;
            if (v96 == 324)
              goto LABEL_116;
            if (v96 != 325)
              goto LABEL_141;
          }
          else
          {
            if (v94->u16[0] <= 0x116u)
            {
              if (v96 != 255)
              {
                if (v96 != 258)
                {
                  if (v96 != 273)
                    goto LABEL_141;
LABEL_116:
                  v113 = v94->u16[1];
                  if ((v113 > 0x10 || ((1 << v113) & 0x10018) == 0)
                    && (*(_DWORD *)(a1 + 12) != 2 || v94->i16[1] || *(_QWORD *)&v94[1] || *(_QWORD *)&v94[2]))
                  {
                    v114 = TIFFFieldWithTag((_QWORD *)a1, v96);
                    if (v114)
                      v120 = *((_QWORD *)v114 + 4);
                    else
                      LOBYTE(v120) = "unknown tagname";
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "Invalid data type for tag %s", v115, v116, v117, v118, v119, v120);
                  }
                  v166 = v95;
LABEL_164:
                  _TIFFmemcpy(v166, v94, 0x20uLL);
                  if ((EvaluateIFDdatasizeReading(a1, v94) & 1) == 0)
                    goto LABEL_80;
                  goto LABEL_86;
                }
LABEL_109:
                LOWORD(v246) = 0;
                v105 = TIFFReadDirEntryShort(a1, v94, &v246, v60);
                if (!EvaluateIFDdatasizeReading(a1, v94))
                  goto LABEL_80;
                if (v105 == 1)
                  v105 = TIFFReadDirEntryPersampleShort(a1, (uint64_t)v94, &v246);
                v112 = v94->u16[0];
                if (v105)
                  goto LABEL_243;
                if (!_cg_TIFFSetField(a1, v112, v106, v107, v108, v109, v110, v111, (unsigned __int16)v246))goto LABEL_80;
                if (v94->i16[0] == 258)
                  v92 = 1;
                goto LABEL_86;
              }
              LOWORD(v246) = 0;
              if (TIFFReadDirEntryShort(a1, v94, &v246, v60))
                goto LABEL_86;
              if ((unsigned __int16)v246 == 2)
              {
                v145 = 1;
              }
              else
              {
                if ((unsigned __int16)v246 != 3)
                  goto LABEL_86;
                v145 = 2;
              }
              _cg_TIFFSetField(a1, 254, v139, v140, v141, v142, v143, v144, v145);
LABEL_86:
              ++v93;
              v94 += 4;
              if (v15 <= (unsigned __int16)v93)
              {
                CalcFinalIFDdatasizeReading(a1, v15);
                if (*(_WORD *)(a1 + 120) == 6)
                {
                  if ((*(_BYTE *)(a1 + 73) & 1) != 0)
                  {
                    if (*(_WORD *)(a1 + 122) == 2)
                    {
                      *(_WORD *)(a1 + 122) = 6;
                      TIFFWarningExtR(a1, "TIFFReadDirectory", "Photometric tag value assumed incorrect, assuming data is YCbCr instead of RGB", v172, v173, v174, v175, v176, v241);
                    }
                  }
                  else
                  {
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "Photometric tag is missing, assuming data is YCbCr", v172, v173, v174, v175, v176, v241);
                    if (!_cg_TIFFSetField(a1, 262, v177, v178, v179, v180, v181, v182, 6))
                      goto LABEL_80;
                  }
                  v183 = *(_DWORD *)v245;
                  if ((*(_DWORD *)v245 & 0x40) == 0)
                  {
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "BitsPerSample tag is missing, assuming 8 bits per sample", v172, v173, v174, v175, v176, v241);
                    if (!_cg_TIFFSetField(a1, 258, v184, v185, v186, v187, v188, v189, 8))
                      goto LABEL_80;
                    v183 = *(_DWORD *)v245;
                  }
                  if ((v183 & 0x10000) == 0)
                  {
                    v190 = *(unsigned __int16 *)(a1 + 122);
                    if (v190 == 2)
                    {
                      TIFFWarningExtR(a1, "TIFFReadDirectory", "SamplesPerPixel tag is missing, assuming correct SamplesPerPixel value is 3", v172, v173, v174, v175, v176, v241);
                      if (!_cg_TIFFSetField(a1, 277, v191, v192, v193, v194, v195, v196, 3))
                        goto LABEL_80;
                      v190 = *(unsigned __int16 *)(a1 + 122);
                    }
                    if (v190 >= 2)
                    {
                      if (v190 == 6)
                      {
                        TIFFWarningExtR(a1, "TIFFReadDirectory", "SamplesPerPixel tag is missing, applying correct SamplesPerPixel value of 3", v172, v173, v174, v175, v176, v241);
                        v197 = 3;
                        goto LABEL_186;
                      }
                    }
                    else
                    {
                      v197 = 1;
LABEL_186:
                      if (!_cg_TIFFSetField(a1, 277, v171, v172, v173, v174, v175, v176, v197))
                        goto LABEL_80;
                    }
                  }
                }
                if ((*v245 & 4) != 0)
                {
                  v199 = _cg_TIFFNumberOfTiles(a1, v170, v171, v172, v173, v174, v175, v176);
                  v201 = *(_DWORD *)(a1 + 16) | 0x400;
                }
                else
                {
                  v199 = _cg_TIFFNumberOfStrips(a1, v170, v171, v172, v173, v174, v175, v176);
                  v200 = *(_DWORD *)(a1 + 132);
                  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 88);
                  *(_DWORD *)(a1 + 104) = v200;
                  *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 96);
                  v201 = *(_DWORD *)(a1 + 16) & 0xFFFFFBFF;
                }
                *(_DWORD *)(a1 + 228) = v199;
                *(_DWORD *)(a1 + 16) = v201;
                if (!(_DWORD)v199)
                {
                  if ((v201 & 0x400) != 0)
                    v222 = "tiles";
                  else
                    v222 = "strips";
                  TIFFErrorExtR(a1, "TIFFReadDirectory", "Cannot handle zero number of %s", v42, v43, v44, v45, v46, (char)v222);
                  goto LABEL_80;
                }
                *(_DWORD *)(a1 + 224) = v199;
                if (*(_WORD *)(a1 + 170) == 2)
                  *(_DWORD *)(a1 + 224) = v199 / *(unsigned __int16 *)(a1 + 130);
                if ((*(_DWORD *)v245 & 0x2000000) == 0)
                {
                  if ((_DWORD)v199 == 1 && *(_WORD *)(a1 + 120) == 6 && (v201 & 0x400) == 0)
                  {
                    *(_DWORD *)v245 |= 0x2000000u;
                    goto LABEL_198;
                  }
                  if ((v201 & 0x400) != 0)
                    v91 = "TileOffsets";
                  else
                    v91 = "StripOffsets";
LABEL_78:
                  v57 = "MissingRequired";
                  v240 = (char)v91;
                  v58 = "TIFF directory is missing required \"%s\" field";
LABEL_79:
                  TIFFErrorExtR(a1, v57, v58, v42, v43, v44, v45, v46, v240);
                  goto LABEL_80;
                }
LABEL_198:
                if (*(_DWORD *)(a1 + 12) != 2
                  || !*v95
                  || *(_QWORD *)(a1 + 264)
                  || *(_WORD *)(a1 + 258)
                  || *(_QWORD *)(a1 + 272)
                  || !*__dst
                  || *(_QWORD *)(a1 + 296)
                  || *(_WORD *)(a1 + 290)
                  || *(_QWORD *)(a1 + 304))
                {
                  if ((v201 & 0x1000000) == 0
                    && (*v95 && !TIFFFetchStripThing(a1, v95, v199, (_QWORD *)(a1 + 232))
                     || *__dst
                     && !TIFFFetchStripThing(a1, __dst, *(_DWORD *)(a1 + 228), (_QWORD *)(a1 + 240))))
                  {
                    goto LABEL_80;
                  }
                }
                else
                {
                  TIFFSetupStrips(a1, v198, v199, v42, v43, v44, v45, v46);
                }
                v202 = *(unsigned __int16 *)(a1 + 122);
                v203 = _TIFFGetMaxColorChannels(v202);
                if (v203)
                {
                  v204 = v203;
                  if (*(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212) > v203)
                  {
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.", v42, v43, v44, v45, v46, v241);
                    v205 = *(unsigned __int16 *)(a1 + 212);
                    v206 = *(_WORD *)(a1 + 130) - v204;
                    *(_WORD *)(a1 + 212) = v206;
                    v212 = _TIFFcallocExt((_QWORD *)a1, v206, 2, v207, v208, v209, v210, v211);
                    if (!v212)
                    {
                      TIFFErrorExtR(a1, "TIFFReadDirectory", "Failed to allocate memory for temporary new sampleinfo array (%hu 16 bit elements)", v213, v214, v215, v216, v217, *(_WORD *)(a1 + 212));
                      goto LABEL_80;
                    }
                    v218 = v212;
                    if ((_DWORD)v205)
                      memcpy(v212, *(const void **)(a1 + 216), 2 * v205);
                    _TIFFsetShortArrayExt((_QWORD *)a1, (char **)(a1 + 216), v218, *(unsigned __int16 *)(a1 + 212), v214, v215, v216, v217);
                    _TIFFfreeExt(a1, (char *)v218);
                    v202 = *(unsigned __int16 *)(a1 + 122);
                  }
                }
                if (v202 == 3 && (*(_BYTE *)(a1 + 75) & 4) == 0)
                {
                  if (*(unsigned __int16 *)(a1 + 116) < 8u)
                  {
                    v91 = "Colormap";
                    goto LABEL_78;
                  }
                  if (*(_WORD *)(a1 + 130) == 3)
                    v219 = 2;
                  else
                    v219 = 1;
                  *(_WORD *)(a1 + 122) = v219;
                }
                if (*(_WORD *)(a1 + 120) == 6)
                  goto LABEL_260;
                if ((*(_BYTE *)(a1 + 75) & 1) == 0)
                {
                  v220 = *(unsigned __int16 *)(a1 + 170);
                  if (v220 == 2)
                  {
                    if (*(_DWORD *)(a1 + 228) == *(unsigned __int16 *)(a1 + 130))
                      goto LABEL_226;
                  }
                  else if (v220 != 1 || *(_DWORD *)(a1 + 228) <= 1u)
                  {
LABEL_226:
                    v221 = "TIFF directory is missing required \"StripByteCounts\" field, calculating from imagelength";
LABEL_238:
                    TIFFWarningExtR(a1, "TIFFReadDirectory", v221, v42, v43, v44, v45, v46, v241);
                    if ((EstimateStripByteCounts(a1, (uint64_t)__src, v15) & 0x80000000) != 0)
                      goto LABEL_80;
                    goto LABEL_260;
                  }
                  v91 = "StripByteCounts";
                  goto LABEL_78;
                }
                v223 = *(_DWORD *)(a1 + 16);
                if (*(_DWORD *)(a1 + 228) == 1 && (v223 & 0x400) == 0)
                {
                  if (ByteCountLooksBad(a1))
                  {
                    v221 = "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength";
                    goto LABEL_238;
                  }
                  v223 = *(_DWORD *)(a1 + 16);
                }
                if ((v223 & 0x1000000) == 0
                  && *(_WORD *)(a1 + 170) == 1
                  && *(_DWORD *)(a1 + 228) >= 3u
                  && *(_WORD *)(a1 + 120) == 1)
                {
                  v225 = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
                  if (v225 != _TIFFGetStrileOffsetOrByteCountValue(a1, 1)
                    && _TIFFGetStrileOffsetOrByteCountValue(a1, 0)
                    && _TIFFGetStrileOffsetOrByteCountValue(a1, 1))
                  {
                    v221 = "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength";
                    goto LABEL_238;
                  }
                }
LABEL_260:
                if (__src)
                {
                  _TIFFfreeExt(a1, (char *)__src);
                  __src = 0;
                }
                if ((*(_BYTE *)(a1 + 74) & 8) == 0)
                {
                  v226 = *(unsigned __int16 *)(a1 + 116);
                  if (v226 <= 0xF)
                    v227 = ~(unsigned __int16)(-1 << v226);
                  else
                    v227 = -1;
                  *(_WORD *)(a1 + 138) = v227;
                }
                (*(void (**)(uint64_t))(a1 + 952))(a1);
                if (*(_WORD *)(a1 + 170) == 1)
                {
                  v235 = *(unsigned __int16 *)(a1 + 120);
                  if (*(_DWORD *)(a1 + 228) != 1)
                    goto LABEL_273;
                  if (v235 != 1
                    || (*(_DWORD *)(a1 + 16) & 0x8400) != 0x8000
                    || (ChopUpSingleUncompressedStrip(a1), *(_WORD *)(a1 + 170) == 1))
                  {
                    v235 = *(unsigned __int16 *)(a1 + 120);
LABEL_273:
                    if (v235 == 1
                      && (*(_DWORD *)(a1 + 16) & 0x8400) == 0x8000
                      && _cg_TIFFStripSize64(a1, v228, v229, v230, v231, v232, v233, v234) >> 31)
                    {
                      TryChopUpUncompressedBigTiff(a1, v228, v229, v230, v231, v232, v233, v234);
                    }
                  }
                }
                *(_DWORD *)(a1 + 16) &= 0xFFDFFFF7;
                *(_DWORD *)(a1 + 876) = -1;
                *(_DWORD *)(a1 + 884) = -1;
                *(_QWORD *)(a1 + 928) = -1;
                *(_QWORD *)(a1 + 936) = -1;
                v236 = _cg_TIFFScanlineSize(a1, v228, v229, v230, v231, v232, v233, v234);
                *(_QWORD *)(a1 + 1104) = v236;
                if (v236)
                {
                  if ((*(_BYTE *)(a1 + 17) & 4) == 0)
                  {
                    if (!_cg_TIFFStripSize(a1, v237, v238, v10, v11, v12, v13, v14))
                    {
                      v26 = "Cannot handle zero strip size";
                      goto LABEL_10;
                    }
                    return 1;
                  }
                  v239 = _cg_TIFFTileSize(a1, v237, v238, v10, v11, v12, v13, v14);
                  *(_QWORD *)(a1 + 936) = v239;
                  if (v239)
                    return 1;
                  v26 = "Cannot handle zero tile size";
                }
                else
                {
                  v26 = "Cannot handle zero scanline size";
                }
LABEL_10:
                TIFFErrorExtR(a1, "TIFFReadDirectory", v26, v10, v11, v12, v13, v14, v241);
                return 0;
              }
              continue;
            }
            if (v96 - 280 < 2)
              goto LABEL_109;
            if (v96 != 279)
            {
              if (v96 == 301)
              {
LABEL_102:
                v246 = 0;
                if (v92)
                {
                  v97 = *(unsigned __int16 *)(a1 + 116);
                  if (v97 < 0x19)
                  {
                    v153 = v94[1];
                    if (v96 == 301 && *(_QWORD *)&v153 == 1 << v97 || *(_QWORD *)&v153 == 3 << v97)
                    {
                      v154 = TIFFReadDirEntryShortArray(a1, (uint64_t)v94, &v246);
                      if ((EvaluateIFDdatasizeReading(a1, v94) & 1) == 0)
                        goto LABEL_80;
                      if (!v154)
                      {
                        v243 = v92;
                        v167 = v95;
                        v168 = (__int32 *)v246;
                        _cg_TIFFSetField(a1, v94->u16[0], v155, v156, v157, v158, v159, v160, (uint64_t)v246);
                        v169 = (char *)v168;
                        v95 = v167;
                        v92 = v243;
                        _TIFFfreeExt(a1, v169);
                        goto LABEL_86;
                      }
                    }
                    else
                    {
                      if ((EvaluateIFDdatasizeReading(a1, v94) & 1) == 0)
                        goto LABEL_80;
                      v154 = 1;
                    }
                    v161 = TIFFFieldWithTag((_QWORD *)a1, v94->u16[0]);
                    if (v161)
                      v165 = (const char *)*((_QWORD *)v161 + 4);
                    else
                      v165 = "unknown tagname";
                    TIFFReadDirEntryOutputErr(a1, v154, "TIFFReadDirectory", (uint64_t)v165, 1, v162, v163, v164);
                  }
                  else
                  {
                    v98 = TIFFFieldWithTag((_QWORD *)a1, v96);
                    if (v98)
                      v104 = (const char *)*((_QWORD *)v98 + 4);
                    else
                      v104 = "unknown tagname";
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "Ignoring %s because BitsPerSample=%hu>24", v99, v100, v101, v102, v103, (char)v104);
                  }
                }
                else
                {
                  v146 = TIFFFieldWithTag((_QWORD *)a1, v96);
                  if (v146)
                    v152 = (const char *)*((_QWORD *)v146 + 4);
                  else
                    v152 = "unknown tagname";
                  TIFFWarningExtR(a1, "TIFFReadDirectory", "Ignoring %s since BitsPerSample tag not found", v147, v148, v149, v150, v151, (char)v152);
                }
                goto LABEL_86;
              }
LABEL_141:
              TIFFFetchNormalTag(a1, (unsigned __int16 *)v94, 1);
              goto LABEL_86;
            }
          }
          break;
        }
        v121 = v94->u16[1];
        if ((v121 > 0x10 || ((1 << v121) & 0x10018) == 0)
          && (*(_DWORD *)(a1 + 12) != 2 || v94->i16[1] || *(_QWORD *)&v94[1] || *(_QWORD *)&v94[2]))
        {
          v122 = TIFFFieldWithTag((_QWORD *)a1, v96);
          if (v122)
            v128 = *((_QWORD *)v122 + 4);
          else
            LOBYTE(v128) = "unknown tagname";
          TIFFWarningExtR(a1, "TIFFReadDirectory", "Invalid data type for tag %s", v123, v124, v125, v126, v127, v128);
        }
        v166 = (unsigned __int16 *)(a1 + 288);
        goto LABEL_164;
      }
    }
  }
  return result;
}

uint64_t TIFFReadDirectoryFindFieldInfo(uint64_t result, unsigned int a2, int *a3)
{
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;

  v3 = *(_DWORD *)(result + 1264);
  if (v3)
  {
    v4 = *(_QWORD *)(result + 1256);
    v5 = -1;
    while (1)
    {
      v6 = (uint64_t)(v3 + v5 + (v3 + v5 < 0)) >> 1;
      v7 = **(_DWORD **)(v4 + 8 * ((v3 + v5) / 2));
      if (v7 == a2)
        break;
      if (v7 >= a2)
        v3 = (v3 + v5) / 2;
      else
        v5 = (v3 + v5) / 2;
      if (v5 + 1 == v3)
        goto LABEL_8;
    }
    v9 = v4 - 8;
    while (v6)
    {
      v10 = v6 - 1;
      v11 = **(_DWORD **)(v9 + 8 * v6--);
      if (v11 != a2)
      {
        v8 = v10 + 1;
        goto LABEL_14;
      }
    }
    v8 = 0;
  }
  else
  {
LABEL_8:
    v8 = -1;
  }
LABEL_14:
  *a3 = v8;
  return result;
}

uint64_t TIFFFetchNormalTag(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  __int16 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  uint64_t v13;
  int v14;
  char *v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t result;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  int v64;
  char v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t v82;
  int v83;
  char v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  char *v99;
  uint64_t v100;
  int v101;
  uint8x8_t v102;
  char *v103;
  unsigned int v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  char *v121;
  int v122;
  uint64_t v123;
  char *v124;
  char *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  char *v134;
  unint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  _QWORD *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  __int32 *v152;
  unsigned int v153;
  int8x8_t *__s;
  unsigned int v155;

  v155 = 0;
  v6 = *a2;
  TIFFReadDirectoryFindFieldInfo(a1, *a2, (int *)&v155);
  if (v155 == -1)
  {
    TIFFErrorExtR(a1, "TIFFFetchNormalTag", "No definition found for tag %hu", v7, v8, v9, v10, v11, v6);
    return 0;
  }
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 1256) + 8 * v155);
  if (!v13)
    TIFFFetchNormalTag_cold_1();
  switch(*(_DWORD *)(v13 + 16))
  {
    case 0:
      TIFFErrorExtR(a1, "TIFFFetchNormalTag", "Defined set_field_type of custom tag %u (%s) is TIFF_SETGET_UNDEFINED and thus tag is not read from file", v7, v8, v9, v10, v11, *(_DWORD *)v13);
      return 1;
    case 1:
      *(double *)&__s = 0.0;
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_6();
      v14 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      if (v14)
        goto LABEL_238;
      v15 = (char *)__s;
      if (*(double *)&__s == 0.0)
      {
        if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0)
          return 0;
        v17 = 0;
        goto LABEL_265;
      }
      v16 = *((_QWORD *)a2 + 1);
      if (!v16)
        goto LABEL_255;
      if (__s->i8[v16 - 1])
      {
        if (*((_QWORD *)a2 + 1))
        {
          v17 = 0;
          do
          {
            if (!__s->i8[v17])
              goto LABEL_256;
            ++v17;
          }
          while (*((_QWORD *)a2 + 1) != v17);
          v17 = *((_QWORD *)a2 + 1);
        }
        else
        {
LABEL_255:
          v17 = 0;
        }
LABEL_256:
        if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0)
          goto LABEL_276;
        goto LABEL_265;
      }
      v17 = strlen((const char *)__s);
      if (!EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2))
        goto LABEL_276;
LABEL_265:
      v135 = *((unsigned int *)a2 + 2);
      if (v17 + 1 >= v135)
      {
        if (v17 + 1 > v135)
        {
          TIFFWarningExtR(a1, "TIFFFetchNormalTag", "ASCII value for tag \"%s\" does not end in null byte. Forcing it to be null", v128, v129, v130, v131, v132, *(_QWORD *)(v13 + 32));
          v142 = *((_QWORD *)a2 + 1) + 1;
          if (HIDWORD(v142))
            TIFFFetchNormalTag_cold_5();
          v143 = _TIFFmallocExt((_QWORD *)a1, v142, v136, v137, v138, v139, v140, v141);
          if (!v143)
          {
LABEL_275:
            if (v15)
            {
LABEL_276:
              v126 = a1;
              v125 = v15;
LABEL_250:
              _TIFFfreeExt(v126, v125);
            }
            return 0;
          }
          v150 = (uint64_t)v143;
          v151 = *((_QWORD *)a2 + 1);
          if (v151)
          {
            _TIFFmemcpy(v143, v15, *((_QWORD *)a2 + 1));
            v151 = *((unsigned int *)a2 + 2);
          }
          *(_BYTE *)(v150 + v151) = 0;
          if (v15)
            _TIFFfreeExt(a1, v15);
          v44 = _cg_TIFFSetField(a1, *a2, v144, v145, v146, v147, v148, v149, v150);
          v15 = (char *)v150;
          goto LABEL_278;
        }
      }
      else
      {
        TIFFWarningExtR(a1, "TIFFFetchNormalTag", "ASCII value for tag \"%s\" contains null byte in value; value incorrectly truncated during reading due to impl"
          "ementation limitations",
          v128,
          v129,
          v130,
          v131,
          v132,
          *(_QWORD *)(v13 + 32));
      }
      v44 = _cg_TIFFSetField(a1, *a2, v127, v128, v129, v130, v131, v132, (uint64_t)v15);
      if (!v15)
        goto LABEL_280;
LABEL_278:
      v133 = a1;
      v134 = v15;
LABEL_279:
      _TIFFfreeExt(v133, v134);
LABEL_280:
      if (v44)
        goto LABEL_238;
      return 0;
    case 2:
      LOBYTE(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_8();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_7();
      v14 = TIFFReadDirEntryByte(a1, (int8x8_t *)a2, &__s, *(uint8x8_t *)&v12);
      if (v14)
        goto LABEL_238;
      v21 = *a2;
      v22 = __s;
      goto LABEL_40;
    case 3:
      LOBYTE(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_10();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_9();
      v14 = TIFFReadDirEntrySbyte(a1, (int8x8_t *)a2, (__int8 *)&__s, *(uint8x8_t *)&v12);
      if (v14)
        goto LABEL_238;
      v21 = *a2;
      v22 = (char)__s;
      goto LABEL_40;
    case 4:
      LOWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_12();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_11();
      v14 = TIFFReadDirEntryShort(a1, (int8x8_t *)a2, &__s, *(uint8x8_t *)&v12);
      if (v14)
        goto LABEL_238;
      v21 = *a2;
      v22 = (unsigned __int16)__s;
      goto LABEL_40;
    case 5:
      LOWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_14();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_13();
      v14 = TIFFReadDirEntrySshort(a1, (int8x8_t *)a2, &__s, *(uint8x8_t *)&v12);
      if (v14)
        goto LABEL_238;
      v21 = *a2;
      v22 = (__int16)__s;
      goto LABEL_40;
    case 6:
      LODWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_16();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_15();
      v23 = TIFFReadDirEntryLong(a1, (int8x8_t *)a2, (__int32 *)&__s, *(uint8x8_t *)&v12);
      goto LABEL_38;
    case 7:
      LODWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_18();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_17();
      v23 = TIFFReadDirEntrySlong(a1, (int8x8_t *)a2, (__int32 *)&__s, *(uint8x8_t *)&v12);
LABEL_38:
      v14 = v23;
      if (v23)
        goto LABEL_238;
      v21 = *a2;
      v22 = __s;
LABEL_40:
      result = _cg_TIFFSetField(a1, v21, v18, v19, v20, v9, v10, v11, v22);
      if (!(_DWORD)result)
        return result;
      goto LABEL_238;
    case 8:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_20();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_19();
      v25 = TIFFReadDirEntryLong8(a1, (int8x8_t *)a2, (int8x8_t *)&__s, *(uint8x8_t *)&v12);
      goto LABEL_62;
    case 9:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_22();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_21();
      v25 = TIFFReadDirEntrySlong8(a1, (int8x8_t *)a2, (int8x8_t *)&__s, *(uint8x8_t *)&v12);
      goto LABEL_62;
    case 0xA:
      LODWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_24();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_23();
      v14 = TIFFReadDirEntryFloat(a1, (int8x8_t *)a2, (__int32 *)&__s, v12);
      if (v14)
        goto LABEL_238;
      if (!EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2))
        return 0;
      v32 = *a2;
      *(double *)&v33 = *(float *)&__s;
      goto LABEL_58;
    case 0xB:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_26();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_25();
      v14 = TIFFReadDirEntryDouble(a1, (int8x8_t *)a2, (double *)&__s, v12);
      if (v14)
        goto LABEL_238;
      if (!EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2))
        return 0;
      v32 = *a2;
      v33 = (uint64_t)__s;
LABEL_58:
      v34 = _cg_TIFFSetField(a1, v32, v26, v27, v28, v29, v30, v31, v33);
      goto LABEL_65;
    case 0xC:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 1)
        TIFFFetchNormalTag_cold_28();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_27();
      v25 = TIFFReadDirEntryIfd8(a1, (int8x8_t *)a2, (int8x8_t *)&__s, *(uint8x8_t *)&v12);
LABEL_62:
      v14 = v25;
      if (v25)
        goto LABEL_238;
      if (!EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2))
        return 0;
      v34 = _cg_TIFFSetField(a1, *a2, v35, v36, v37, v38, v39, v40, (uint64_t)__s);
LABEL_65:
      if (!v34)
        return 0;
      goto LABEL_238;
    case 0xD:
      TIFFFetchNormalTag_cold_4();
    case 0xE:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 2)
        TIFFFetchNormalTag_cold_31();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_30();
      if (*((_QWORD *)a2 + 1) != 2)
      {
        TIFFWarningExtR(a1, "TIFFFetchNormalTag", "incorrect count for field \"%s\", expected 2, got %llu", v7, v8, v9, v10, v11, *(_QWORD *)(v13 + 32));
        return 0;
      }
      v14 = TIFFReadDirEntryShortArray(a1, (uint64_t)a2, (char **)&__s);
      if (v14)
        goto LABEL_238;
      v15 = (char *)__s;
      if (*(double *)&__s == 0.0)
        TIFFFetchNormalTag_cold_29();
      v44 = _cg_TIFFSetField(a1, *a2, v41, v42, v43, v9, v10, v11, __s->u16[0]);
      goto LABEL_278;
    case 0x10:
      *(double *)&__s = 0.0;
      v45 = *(__int16 *)(v13 + 4);
      if (v45 <= 0)
        TIFFFetchNormalTag_cold_32();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_33();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v45)
        goto LABEL_117;
      v46 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x11:
      *(double *)&__s = 0.0;
      v47 = *(__int16 *)(v13 + 4);
      if (v47 <= 0)
        TIFFFetchNormalTag_cold_34();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_35();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v47)
        goto LABEL_117;
      v46 = TIFFReadDirEntrySbyteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x12:
      *(double *)&__s = 0.0;
      v48 = *(__int16 *)(v13 + 4);
      if (v48 <= 0)
        TIFFFetchNormalTag_cold_36();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_37();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v48)
        goto LABEL_117;
      v46 = TIFFReadDirEntryShortArray(a1, (uint64_t)a2, (char **)&__s);
      goto LABEL_114;
    case 0x13:
      *(double *)&__s = 0.0;
      v49 = *(__int16 *)(v13 + 4);
      if (v49 <= 0)
        TIFFFetchNormalTag_cold_38();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_39();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v49)
        goto LABEL_117;
      v46 = TIFFReadDirEntrySshortArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x14:
      *(double *)&__s = 0.0;
      v50 = *(__int16 *)(v13 + 4);
      if (v50 <= 0)
        TIFFFetchNormalTag_cold_40();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_41();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v50)
        goto LABEL_117;
      v46 = TIFFReadDirEntryLongArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_114;
    case 0x15:
      *(double *)&__s = 0.0;
      v51 = *(__int16 *)(v13 + 4);
      if (v51 <= 0)
        TIFFFetchNormalTag_cold_42();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_43();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v51)
        goto LABEL_117;
      v46 = TIFFReadDirEntrySlongArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x16:
      *(double *)&__s = 0.0;
      v52 = *(__int16 *)(v13 + 4);
      if (v52 <= 0)
        TIFFFetchNormalTag_cold_44();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_45();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v52)
        goto LABEL_117;
      v46 = TIFFReadDirEntryLong8ArrayWithLimit(a1, (uint64_t)a2, &__s, 0xFFFFFFFFFFFFFFFFLL);
      goto LABEL_114;
    case 0x17:
      *(double *)&__s = 0.0;
      v53 = *(__int16 *)(v13 + 4);
      if (v53 <= 0)
        TIFFFetchNormalTag_cold_46();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_47();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v53)
        goto LABEL_117;
      v46 = TIFFReadDirEntrySlong8Array(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x18:
      *(double *)&__s = 0.0;
      v54 = *(__int16 *)(v13 + 4);
      if (v54 <= 0)
        TIFFFetchNormalTag_cold_48();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_49();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v54)
        goto LABEL_117;
      v46 = TIFFReadDirEntryFloatArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x19:
      *(double *)&__s = 0.0;
      v55 = *(__int16 *)(v13 + 4);
      if (v55 <= 0)
        TIFFFetchNormalTag_cold_50();
      if (*(_BYTE *)(v13 + 27))
        TIFFFetchNormalTag_cold_51();
      if (*((_QWORD *)a2 + 1) != (unsigned __int16)v55)
      {
LABEL_117:
        TIFFWarningExtR(a1, "TIFFFetchNormalTag", "incorrect count for field \"%s\", expected %d, got %llu", v7, v8, v9, v10, v11, *(_QWORD *)(v13 + 32));
        return 0;
      }
      v46 = TIFFReadDirEntryDoubleArray(a1, (uint64_t)a2, (__int32 **)&__s);
LABEL_114:
      v14 = v46;
      if (v46)
        goto LABEL_238;
      if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0)
        goto LABEL_248;
      v62 = *a2;
      v63 = (char *)__s;
      v64 = _cg_TIFFSetField(a1, v62, v56, v57, v58, v59, v60, v61, (uint64_t)__s);
      goto LABEL_228;
    case 0x1B:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_53();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_52();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v14 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      if (v14)
        goto LABEL_238;
      v65 = EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2);
      v72 = (char *)__s;
      if ((v65 & 1) == 0)
      {
        if (*(double *)&__s == 0.0)
          return 0;
        goto LABEL_259;
      }
      v73 = *((_QWORD *)a2 + 1);
      if (*(double *)&__s == 0.0)
      {
        v81 = 0;
        goto LABEL_284;
      }
      if (!v73 || !__s->i8[v73 - 1])
      {
        v81 = (char *)__s;
        goto LABEL_284;
      }
      TIFFWarningExtR(a1, "TIFFFetchNormalTag", "ASCII value for ASCII array tag \"%s\" does not end in null byte. Forcing it to be null", v67, v68, v69, v70, v71, *(_QWORD *)(v13 + 32));
      v80 = (char *)_TIFFmallocExt((_QWORD *)a1, (*((_DWORD *)a2 + 2) + 1), v74, v75, v76, v77, v78, v79);
      if (!v80)
      {
LABEL_259:
        v126 = a1;
        v125 = v72;
        goto LABEL_250;
      }
      v81 = v80;
      v82 = *((_QWORD *)a2 + 1);
      if (v82)
      {
        _TIFFmemcpy(v80, v72, *((_QWORD *)a2 + 1));
        v82 = *((unsigned int *)a2 + 2);
      }
      v81[v82] = 0;
      ++*((_QWORD *)a2 + 1);
      _TIFFfreeExt(a1, v72);
      v73 = *((_QWORD *)a2 + 1);
LABEL_284:
      v122 = _cg_TIFFSetField(a1, *a2, v66, v67, v68, v69, v70, v71, (unsigned __int16)v73);
      if (v81)
      {
        v123 = a1;
        v124 = v81;
LABEL_245:
        _TIFFfreeExt(v123, v124);
      }
LABEL_246:
      if (!v122)
        return 0;
      v14 = 0;
LABEL_238:
      if (v14)
      {
        TIFFReadDirEntryOutputErr(a1, v14, "TIFFFetchNormalTag", *(_QWORD *)(v13 + 32), a3, v9, v10, v11);
        return 0;
      }
      return 1;
    case 0x1C:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_55();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_54();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x1D:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_57();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_56();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntrySbyteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x1E:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_59();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_58();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntryShortArray(a1, (uint64_t)a2, (char **)&__s);
      goto LABEL_237;
    case 0x1F:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_61();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_60();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntrySshortArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x20:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_63();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_62();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntryLongArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_237;
    case 0x21:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_65();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_64();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntrySlongArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x22:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_67();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_66();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntryLong8ArrayWithLimit(a1, (uint64_t)a2, &__s, 0xFFFFFFFFFFFFFFFFLL);
      goto LABEL_237;
    case 0x23:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_69();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_68();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntrySlong8Array(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x24:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_71();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_70();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntryFloatArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x25:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_73();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_72();
      if (*((_QWORD *)a2 + 1) >> 16)
        goto LABEL_173;
      v83 = TIFFReadDirEntryDoubleArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_237;
    case 0x26:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1)
        TIFFFetchNormalTag_cold_75();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_74();
      if (*((_QWORD *)a2 + 1) >> 16)
      {
LABEL_173:
        v14 = 1;
        goto LABEL_238;
      }
      v83 = TIFFReadDirEntryIfd8Array(a1, (uint64_t)a2, &__s);
LABEL_237:
      v14 = v83;
      if (v83)
        goto LABEL_238;
      if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0)
        goto LABEL_248;
      v121 = (char *)__s;
      v122 = _cg_TIFFSetField(a1, *a2, v115, v116, v117, v118, v119, v120, a2[4]);
      if (!v121)
        goto LABEL_246;
      v123 = a1;
      v124 = v121;
      goto LABEL_245;
    case 0x27:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_77();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_76();
      v14 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      if (v14)
        goto LABEL_238;
      v84 = EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2);
      v15 = (char *)__s;
      if ((v84 & 1) == 0)
        goto LABEL_275;
      if (*(double *)&__s == 0.0)
      {
        v99 = 0;
      }
      else
      {
        v91 = *((_QWORD *)a2 + 1);
        if (v91 && __s->i8[v91 - 1])
        {
          TIFFWarningExtR(a1, "TIFFFetchNormalTag", "ASCII value for ASCII array tag \"%s\" does not end in null byte. Forcing it to be null", v86, v87, v88, v89, v90, *(_QWORD *)(v13 + 32));
          v98 = (char *)_TIFFmallocExt((_QWORD *)a1, (*((_DWORD *)a2 + 2) + 1), v92, v93, v94, v95, v96, v97);
          if (!v98)
            goto LABEL_276;
          v99 = v98;
          v100 = *((_QWORD *)a2 + 1);
          if (v100)
          {
            _TIFFmemcpy(v98, v15, *((_QWORD *)a2 + 1));
            v100 = *((unsigned int *)a2 + 2);
          }
          v99[v100] = 0;
          ++*((_QWORD *)a2 + 1);
          _TIFFfreeExt(a1, v15);
        }
        else
        {
          v99 = (char *)__s;
        }
      }
      v44 = _cg_TIFFSetField(a1, *a2, v85, v86, v87, v88, v89, v90, *((_QWORD *)a2 + 1));
      if (!v99)
        goto LABEL_280;
      v133 = a1;
      v134 = v99;
      goto LABEL_279;
    case 0x28:
      *(double *)&__s = 0.0;
      v153 = 0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_79();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_78();
      if (*(_DWORD *)v13 == 33723 && a2[1] == 4)
      {
        v152 = 0;
        v101 = TIFFReadDirEntryArrayWithLimit(a1, (uint64_t)a2, &v153, 4u, (void **)&v152, 0xFFFFFFFFFFFFFFFFLL);
        v14 = v101;
        if (v101 || (v103 = (char *)v152) == 0)
        {
          *(double *)&__s = 0.0;
          if (v101)
            goto LABEL_238;
        }
        else
        {
          v104 = v153;
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabArrayOfLong(v152, v153, v102);
          __s = (int8x8_t *)v103;
          v153 = 4 * v104;
        }
      }
      else
      {
        v14 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
        v153 = *((_QWORD *)a2 + 1);
        if (v14)
          goto LABEL_238;
      }
      if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0)
      {
LABEL_248:
        v125 = (char *)__s;
        if (*(double *)&__s == 0.0)
          return 0;
        v126 = a1;
        goto LABEL_250;
      }
      v112 = *a2;
      v63 = (char *)__s;
      v113 = v153;
LABEL_227:
      v64 = _cg_TIFFSetField(a1, v112, v106, v107, v108, v109, v110, v111, v113);
LABEL_228:
      v114 = v64;
      if (v63)
        _TIFFfreeExt(a1, v63);
      if (v114)
        goto LABEL_238;
      return 0;
    case 0x29:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_81();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_80();
      v105 = TIFFReadDirEntrySbyteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x2A:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_83();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_82();
      v105 = TIFFReadDirEntryShortArray(a1, (uint64_t)a2, (char **)&__s);
      goto LABEL_224;
    case 0x2B:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_85();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_84();
      v105 = TIFFReadDirEntrySshortArray(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x2C:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_87();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_86();
      v105 = TIFFReadDirEntryLongArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_224;
    case 0x2D:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_89();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_88();
      v105 = TIFFReadDirEntrySlongArray(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x2E:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_91();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_90();
      v105 = TIFFReadDirEntryLong8ArrayWithLimit(a1, (uint64_t)a2, &__s, 0xFFFFFFFFFFFFFFFFLL);
      goto LABEL_224;
    case 0x2F:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_93();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_92();
      v105 = TIFFReadDirEntrySlong8Array(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x30:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_95();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_94();
      v105 = TIFFReadDirEntryFloatArray(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x31:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_97();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_96();
      v105 = TIFFReadDirEntryDoubleArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_224;
    case 0x32:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3)
        TIFFFetchNormalTag_cold_99();
      if (*(_BYTE *)(v13 + 27) != 1)
        TIFFFetchNormalTag_cold_98();
      v105 = TIFFReadDirEntryIfd8Array(a1, (uint64_t)a2, &__s);
LABEL_224:
      v14 = v105;
      if (v105)
        goto LABEL_238;
      if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0)
        goto LABEL_248;
      v112 = *a2;
      v113 = *((_QWORD *)a2 + 1);
      v63 = (char *)__s;
      goto LABEL_227;
    case 0x33:
      TIFFFetchNormalTag_cold_3();
    default:
      TIFFFetchNormalTag_cold_2();
  }
}

uint64_t _cg_TIFFSetField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return TIFFVSetField(a1, a2, (uint64_t)&a9);
}

uint64_t _TIFFVSetField(uint64_t a1, int a2, unsigned __int16 *a3)
{
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  int v14;
  int v15;
  unsigned __int16 *v16;
  uint64_t v17;
  uint64_t v18;
  const void **v19;
  int64_t v20;
  const void **v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char **v25;
  unsigned __int16 *v26;
  unint64_t *p_src;
  _QWORD *v28;
  int64_t v29;
  unsigned __int16 *v30;
  uint64_t v31;
  char **v32;
  const void **v33;
  const void *v34;
  _QWORD *v35;
  int64_t v36;
  uint64_t v37;
  unsigned __int16 *v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned __int16 *v42;
  int v43;
  unsigned __int16 *v44;
  unsigned __int16 *v45;
  int v46;
  unsigned __int16 *v47;
  unsigned __int16 *v48;
  unsigned __int16 *v49;
  unsigned __int16 *v50;
  unsigned __int16 *v51;
  unsigned __int16 *v52;
  int v53;
  uint64_t (*v54)();
  unsigned __int16 *v55;
  unsigned __int16 *v56;
  unsigned __int16 *v57;
  int v58;
  unsigned __int16 *v59;
  int v60;
  int v61;
  int v62;
  unsigned __int16 *v63;
  unsigned __int16 *v64;
  int v65;
  double *v66;
  double *v67;
  unsigned __int16 *v68;
  int v69;
  unsigned __int16 *v70;
  unsigned __int16 *v71;
  int v72;
  unsigned __int16 *v73;
  int v74;
  unsigned __int16 *v75;
  unsigned int v76;
  unsigned int v77;
  unsigned __int16 *v79;
  double *v80;
  double *v81;
  unint64_t v82;
  int v83;
  char **v84;
  const void **v85;
  unsigned __int16 *v86;
  unsigned __int16 *v87;
  int v88;
  unsigned __int16 *v89;
  int v90;
  unsigned __int16 *v91;
  int v92;
  unsigned __int16 *v93;
  unsigned int v94;
  const void *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  unsigned __int16 *v105;
  int v106;
  int v107;
  unsigned __int16 *v108;
  int v109;
  double *v110;
  const void **v111;
  int v112;
  char *v113;
  uint64_t v114;
  _QWORD *v115;
  int v116;
  _QWORD *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  const char *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  _DWORD *v135;
  char *v137;
  int Size;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unsigned __int16 *v144;
  unsigned int v145;
  const char *v146;
  int v147;
  int v148;
  int v149;
  int *v150;
  const char **v151;
  size_t v152;
  uint64_t v153;
  uint64_t v154;
  _QWORD *v155;
  void *v156;
  int v157;
  const void **v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  int v164;
  uint64_t v165;
  uint64_t v166;
  unsigned __int16 *v167;
  void *v168;
  size_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  unsigned __int16 *v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  char *v178;
  int v179;
  uint64_t v180;
  uint64_t v181;
  unsigned __int16 *v182;
  unsigned __int16 *v183;
  unsigned __int16 *v184;
  unsigned __int16 *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  double *v191;
  unsigned __int16 *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  double *v198;
  float v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  char v205;
  unint64_t __src;
  unsigned int v207;
  unsigned __int16 *v208;

  v208 = a3;
  v207 = 0;
  v6 = TIFFFindField((_QWORD *)a1, a2, 0);
  if (!v6)
    return 0;
  v12 = (uint64_t)v6;
  v13 = (_BYTE *)(a1 + 72);
  v14 = *((unsigned __int16 *)v6 + 12);
  if (v14 == 65)
    v15 = 0;
  else
    v15 = a2;
  if (v15 <= 319)
  {
    switch(v15)
    {
      case 254:
        v16 = v208;
        v208 += 4;
        *(_DWORD *)(a1 + 112) = *(_DWORD *)v16;
        goto LABEL_158;
      case 256:
        v50 = v208;
        v208 += 4;
        *(_DWORD *)(a1 + 88) = *(_DWORD *)v50;
        goto LABEL_158;
      case 257:
        v51 = v208;
        v208 += 4;
        *(_DWORD *)(a1 + 92) = *(_DWORD *)v51;
        goto LABEL_158;
      case 258:
        v52 = v208;
        v208 += 4;
        v53 = *(_DWORD *)v52;
        *(_WORD *)(a1 + 116) = v53;
        if ((*(_BYTE *)(a1 + 16) & 0x80) == 0)
          goto LABEL_158;
        v17 = 1;
        if ((unsigned __int16)v53 > 0x1Fu)
        {
          if ((unsigned __int16)v53 == 32)
            goto LABEL_164;
          if ((unsigned __int16)v53 == 64 || (unsigned __int16)v53 == 128)
          {
            v54 = (uint64_t (*)())_TIFFSwab64BitData;
            goto LABEL_175;
          }
        }
        else
        {
          switch((unsigned __int16)v53)
          {
            case 8u:
              v54 = _TIFFNoPostDecode;
              goto LABEL_175;
            case 0x10u:
              goto LABEL_163;
            case 0x18u:
              v54 = (uint64_t (*)())_TIFFSwab24BitData;
              goto LABEL_175;
          }
        }
        goto LABEL_159;
      case 259:
        v71 = v208;
        v208 += 4;
        v72 = *(_DWORD *)v71;
        if ((*v13 & 0x80) == 0)
          goto LABEL_68;
        if (*(unsigned __int16 *)(a1 + 120) == (unsigned __int16)v72)
          goto LABEL_158;
        (*(void (**)(uint64_t))(a1 + 1072))(a1);
        *(_DWORD *)(a1 + 16) &= ~0x20u;
LABEL_68:
        v17 = TIFFSetCompressionScheme(a1, (unsigned __int16)v72);
        if (!(_DWORD)v17)
          return v17;
        *(_WORD *)(a1 + 120) = v72;
        goto LABEL_159;
      case 262:
        v55 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 122) = *(_DWORD *)v55;
        goto LABEL_158;
      case 263:
        v56 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 124) = *(_DWORD *)v56;
        goto LABEL_158;
      case 266:
        v57 = v208;
        v208 += 4;
        v58 = *(_DWORD *)v57;
        if ((unsigned __int16)v58 - 3 < 0xFFFFFFFE)
          goto LABEL_140;
        *(_WORD *)(a1 + 126) = v58;
        goto LABEL_158;
      case 274:
        v73 = v208;
        v208 += 4;
        v74 = *(_DWORD *)v73;
        if ((unsigned __int16)v74 - 9 < 0xFFFFFFF8)
          goto LABEL_140;
        *(_WORD *)(a1 + 128) = v74;
        goto LABEL_158;
      case 277:
        v59 = v208;
        v208 += 4;
        v60 = *(_DWORD *)v59;
        v61 = (unsigned __int16)*(_DWORD *)v59;
        if (!(unsigned __int16)*(_DWORD *)v59)
          goto LABEL_140;
        if (*(unsigned __int16 *)(a1 + 130) != (unsigned __int16)v60)
        {
          if (*(_QWORD *)(a1 + 144))
          {
            TIFFWarningExtR(a1, "_TIFFVSetField", "SamplesPerPixel tag value is changing, but SMinSampleValue tag was read with a different value. Canceling it", v7, v8, v9, v10, v11, v205);
            *(_DWORD *)(a1 + 76) &= ~2u;
            _TIFFfreeExt(a1, *(char **)(a1 + 144));
            *(_QWORD *)(a1 + 144) = 0;
          }
          if (*(_QWORD *)(a1 + 152))
          {
            TIFFWarningExtR(a1, "_TIFFVSetField", "SamplesPerPixel tag value is changing, but SMaxSampleValue tag was read with a different value. Canceling it", v7, v8, v9, v10, v11, v205);
            *(_DWORD *)(a1 + 76) &= ~4u;
            _TIFFfreeExt(a1, *(char **)(a1 + 152));
            *(_QWORD *)(a1 + 152) = 0;
          }
          if (*(_QWORD *)(a1 + 344))
          {
            v62 = *(unsigned __int16 *)(a1 + 212);
            if ((v61 - v62) >= 2 && *(unsigned __int16 *)(a1 + 130) - v62 <= 1)
            {
              TIFFWarningExtR(a1, "_TIFFVSetField", "SamplesPerPixel tag value is changing, but TransferFunction was read with a different value. Canceling it", v7, v8, v9, v10, v11, v205);
              *(_DWORD *)(a1 + 76) &= ~0x1000u;
              _TIFFfreeExt(a1, *(char **)(a1 + 344));
              *(_QWORD *)(a1 + 344) = 0;
            }
          }
        }
        *(_WORD *)(a1 + 130) = v60;
        goto LABEL_158;
      case 278:
        v75 = v208;
        v208 += 4;
        v76 = *(_DWORD *)v75;
        if (!v76)
          goto LABEL_133;
        v77 = *(_DWORD *)(a1 + 92);
        if (v76 > v77 && v77 != 0)
          v76 = *(_DWORD *)(a1 + 92);
        *(_DWORD *)(a1 + 132) = v76;
        if ((*(_BYTE *)(a1 + 72) & 4) == 0)
        {
          *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 88);
          *(_DWORD *)(a1 + 104) = v76;
        }
        goto LABEL_158;
      case 280:
        v63 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 136) = *(_DWORD *)v63;
        goto LABEL_158;
      case 281:
        v79 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 138) = *(_DWORD *)v79;
        goto LABEL_158;
      case 282:
        v80 = (double *)v208;
        v208 += 4;
        if (*v80 < 0.0)
          goto LABEL_84;
        *(float *)(a1 + 160) = _TIFFClampDoubleToFloat(*v80);
        goto LABEL_158;
      case 283:
        v81 = (double *)v208;
        v208 += 4;
        if (*v81 < 0.0)
        {
LABEL_84:
          TIFFFieldWithTag((_QWORD *)a1, a2);
          TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad value %f for \"%s\" tag", v130, v131, v132, v133, v134, *(_QWORD *)a1);
          return 0;
        }
        *(float *)(a1 + 164) = _TIFFClampDoubleToFloat(*v81);
        break;
      case 284:
        v64 = v208;
        v208 += 4;
        v65 = *(_DWORD *)v64;
        if ((unsigned __int16)v65 - 3 < 0xFFFFFFFE)
          goto LABEL_140;
        *(_WORD *)(a1 + 170) = v65;
        goto LABEL_158;
      case 286:
        v66 = (double *)v208;
        v208 += 4;
        *(float *)(a1 + 172) = _TIFFClampDoubleToFloat(*v66);
        goto LABEL_158;
      case 287:
        v67 = (double *)v208;
        v208 += 4;
        *(float *)(a1 + 176) = _TIFFClampDoubleToFloat(*v67);
        goto LABEL_158;
      case 296:
        v68 = v208;
        v208 += 4;
        v69 = *(_DWORD *)v68;
        if ((unsigned __int16)v69 - 4 < 0xFFFFFFFD)
          goto LABEL_140;
        *(_WORD *)(a1 + 168) = v69;
        goto LABEL_158;
      case 297:
        v70 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 180) = *(_DWORD *)v70;
        v208 = v70 + 8;
        *(_WORD *)(a1 + 182) = *((_DWORD *)v70 + 2);
        goto LABEL_158;
      case 301:
        v82 = 0;
        if (*(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212) <= 1)
          v83 = 1;
        else
          v83 = 3;
        v207 = v83;
        v84 = (char **)(a1 + 344);
        do
        {
          v85 = (const void **)v208;
          v208 += 4;
          v17 = 1;
          setByteArray((_QWORD *)a1, v84, *v85, 1 << *(_WORD *)(a1 + 116), 2, v9, v10, v11);
          ++v82;
          ++v84;
        }
        while (v82 < v207);
        goto LABEL_159;
      default:
        goto LABEL_125;
    }
    goto LABEL_158;
  }
  if (v15 > 530)
  {
    if (v15 > 32994)
    {
      switch(v15)
      {
        case 32995:
          v30 = v208;
          v208 += 4;
          LODWORD(v30) = (unsigned __int16)*(_DWORD *)v30;
          *(_WORD *)(a1 + 212) = (_DWORD)v30 != 0;
          v17 = 1;
          if (!(_DWORD)v30)
            goto LABEL_159;
          LOWORD(__src) = 1;
          v25 = (char **)(a1 + 216);
          p_src = &__src;
          v28 = (_QWORD *)a1;
          v29 = 1;
LABEL_15:
          v31 = 2;
          goto LABEL_30;
        case 32996:
          v42 = v208;
          v208 += 4;
          v43 = *(_DWORD *)v42;
          if ((v43 & 0xFFFC) == 0)
          {
            *(_WORD *)(a1 + 118) = 0x3000100020004uLL >> (16 * v43);
            goto LABEL_158;
          }
LABEL_140:
          TIFFFieldWithTag((_QWORD *)a1, a2);
          v129 = *(const char **)a1;
          goto LABEL_141;
        case 32997:
          v44 = v208;
          v208 += 4;
          *(_DWORD *)(a1 + 96) = *(_DWORD *)v44;
          goto LABEL_158;
        case 32998:
          v45 = v208;
          v208 += 4;
          v46 = *(_DWORD *)v45;
          if (v46)
          {
            *(_DWORD *)(a1 + 108) = v46;
            goto LABEL_158;
          }
LABEL_133:
          TIFFFieldWithTag((_QWORD *)a1, a2);
          v129 = *(const char **)a1;
LABEL_141:
          TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad value %u for \"%s\" tag", v124, v125, v126, v127, v128, (char)v129);
          return 0;
        default:
          if (v15 == 33723)
          {
            v48 = v208;
            v208 += 4;
            v29 = *(unsigned int *)v48;
            *(_DWORD *)(a1 + 396) = v29;
            v25 = (char **)(a1 + 400);
            v208 = v48 + 8;
            p_src = (unint64_t *)*((_QWORD *)v48 + 1);
            v17 = 1;
            v28 = 0;
            v31 = 1;
LABEL_30:
            setByteArray(v28, v25, p_src, v29, v31, v9, v10, v11);
            goto LABEL_159;
          }
          if (v15 != 65563)
            goto LABEL_125;
          v38 = v208;
          v208 += 4;
          v39 = *v38;
          v40 = *(_DWORD *)(a1 + 16);
          if (v39 == 1)
            v41 = v40 | 0x400000;
          else
            v41 = v40 & 0xFFBFFFFF;
LABEL_157:
          *(_DWORD *)(a1 + 16) = v41;
          break;
      }
      goto LABEL_158;
    }
    if (v15 == 531)
    {
      v47 = v208;
      v208 += 4;
      *(_WORD *)(a1 + 340) = *(_DWORD *)v47;
      goto LABEL_158;
    }
    if (v15 == 532)
    {
      v32 = (char **)(a1 + 368);
      v33 = (const void **)v208;
      v208 += 4;
      v34 = *v33;
      v35 = (_QWORD *)a1;
      v36 = 6;
      v37 = 4;
LABEL_124:
      setByteArray(v35, v32, v34, v36, v37, v9, v10, v11);
      goto LABEL_158;
    }
LABEL_125:
    if (!*((_WORD *)v6 + 12))
    {
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Ignored %stag \"%s\" (not supported by libtiff)", v7, v8, v9, v10, v11, *(_QWORD *)a1);
      return 0;
    }
    if (v14 != 65)
    {
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Invalid %stag \"%s\" (not supported by codec)", v7, v8, v9, v10, v11, *(_QWORD *)a1);
      return 0;
    }
    v112 = *(_DWORD *)(a1 + 408);
    v113 = *(char **)(a1 + 416);
    if (v112 < 1)
    {
LABEL_131:
      v116 = v112 + 1;
      *(_DWORD *)(a1 + 408) = v116;
      v117 = _TIFFreallocExt((_QWORD *)a1, v113, 24 * v116, v7, v8, v9, v10, v11);
      if (!v117)
      {
        TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Failed to allocate space for list of custom values", v118, v119, v120, v121, v122, *(_QWORD *)a1);
        return 0;
      }
      *(_QWORD *)(a1 + 416) = v117;
      v123 = &v117[3 * *(int *)(a1 + 408)];
      *(v123 - 3) = v12;
      v115 = v123 - 3;
      v115[2] = 0;
      *((_DWORD *)v115 + 2) = 0;
    }
    else
    {
      v114 = *(unsigned int *)(a1 + 408);
      v115 = *(_QWORD **)(a1 + 416);
      while (*(_DWORD *)*v115 != a2)
      {
        v115 += 3;
        if (!--v114)
          goto LABEL_131;
      }
      v137 = (char *)v115[2];
      if (v137)
      {
        _TIFFfreeExt(a1, v137);
        v115[2] = 0;
      }
    }
    Size = TIFFFieldSetGetSize(v12);
    if (!Size)
    {
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad field type %d for \"%s\"", v139, v140, v141, v142, v143, *(_QWORD *)a1);
      return 0;
    }
    if (*(_DWORD *)(v12 + 8) == 2)
    {
      if (*(_BYTE *)(v12 + 27))
      {
        if (*(__int16 *)(v12 + 6) != -3)
          _TIFFVSetField_cold_1();
        v144 = v208;
        v208 += 4;
        v145 = *(_DWORD *)v144;
        v208 = v144 + 8;
        v146 = (const char *)*((_QWORD *)v144 + 1);
        goto LABEL_181;
      }
      v151 = (const char **)v208;
      v208 += 4;
      v146 = *v151;
      v152 = strlen(*v151);
      v145 = v152 + 1;
      if (!((v152 + 1) >> 31))
      {
LABEL_181:
        *((_DWORD *)v115 + 2) = v145;
        setByteArray((_QWORD *)a1, (char **)v115 + 2, v146, v145, 1, v141, v142, v143);
        v17 = 1;
        goto LABEL_159;
      }
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Too long string value for \"%s\". Maximum supported is 2147483647 bytes", v153, v154, v141, v142, v143, *(_QWORD *)a1);
      return 0;
    }
    v147 = Size;
    v148 = *(__int16 *)(v12 + 6);
    v149 = *(unsigned __int16 *)(v12 + 6);
    if (*(_BYTE *)(v12 + 27))
    {
      v150 = (int *)v208;
      v208 += 4;
      v148 = *v150;
      goto LABEL_178;
    }
    if (v149 != 0xFFFF)
    {
      if (v149 == 65534)
      {
        v148 = *(unsigned __int16 *)(a1 + 130);
      }
      else if (v149 == 65533)
      {
        goto LABEL_185;
      }
LABEL_178:
      *((_DWORD *)v115 + 2) = v148;
      if (!v148)
      {
        TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Null count for \"%s\" (type %d, writecount %d, passcount %d)", v139, v140, v141, v142, v143, *(_QWORD *)a1);
        return 0;
      }
      goto LABEL_186;
    }
LABEL_185:
    v148 = 1;
    *((_DWORD *)v115 + 2) = 1;
LABEL_186:
    v155 = _TIFFCheckMalloc((const char **)a1, v148, Size, (uint64_t)"custom tag binary object", v140, v141, v142, v143);
    v115[2] = v155;
    if (v155)
    {
      v156 = v155;
      if (*(_DWORD *)v12 == 336 && !strcmp(*(const char **)(v12 + 32), "DotRange"))
      {
        v167 = v208;
        v208 += 4;
        LOWORD(__src) = *(_DWORD *)v167;
        v208 = v167 + 8;
        WORD1(__src) = *((_DWORD *)v167 + 2);
        v168 = (void *)v115[2];
        v169 = 4;
LABEL_234:
        _TIFFmemcpy(v168, &__src, v169);
        goto LABEL_158;
      }
      if (*(_BYTE *)(v12 + 27) || *(unsigned __int16 *)(v12 + 6) > 0xFFFCu || (v157 = *((_DWORD *)v115 + 2), v157 >= 2))
      {
        v158 = (const void **)v208;
        v208 += 4;
        _TIFFmemcpy(v156, *v158, *((int *)v115 + 2) * (uint64_t)v147);
        if ((*(_BYTE *)(a1 + 18) & 8) != 0)
          goto LABEL_158;
        v164 = *(_DWORD *)(*v115 + 8);
        if (v164 == 17)
        {
          v170 = *((unsigned int *)v115 + 2);
          if ((int)v170 < 1)
            goto LABEL_158;
          v171 = 0;
          while (1)
          {
            v172 = *(_QWORD *)(v115[2] + 8 * v171);
            if (v172 != (int)v172)
              break;
            ++v171;
            v17 = 1;
            if (v170 == v171)
              goto LABEL_159;
          }
          TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad SLONG8 value %lli at %d. array position for \"%s\" tag %d in ClassicTIFF. Tag won't be written to file", v159, v160, v161, v162, v163, *(_QWORD *)a1);
        }
        else
        {
          if (v164 != 16)
            goto LABEL_158;
          v165 = *((unsigned int *)v115 + 2);
          if ((int)v165 < 1)
            goto LABEL_158;
          v166 = 0;
          while (!HIDWORD(*(_QWORD *)(v115[2] + 8 * v166)))
          {
            ++v166;
            v17 = 1;
            if (v165 == v166)
              goto LABEL_159;
          }
          TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad LONG8 value %llu at %d. array position for \"%s\" tag %d in ClassicTIFF. Tag won't be written to file", v159, v160, v161, v162, v163, *(_QWORD *)a1);
        }
      }
      else
      {
        if (v157 != 1)
          _TIFFVSetField_cold_3();
        switch(*(_DWORD *)(v12 + 8))
        {
          case 1:
          case 6:
          case 7:
            v173 = v208;
            v208 += 4;
            LOBYTE(__src) = *(_DWORD *)v173;
            goto LABEL_233;
          case 3:
          case 8:
            v184 = v208;
            v208 += 4;
            LOWORD(__src) = *(_DWORD *)v184;
            goto LABEL_233;
          case 4:
          case 9:
          case 0xD:
            v182 = v208;
            v208 += 4;
            LODWORD(__src) = *(_DWORD *)v182;
            goto LABEL_233;
          case 5:
          case 0xA:
            if (v147 == 8)
              goto LABEL_226;
            v198 = (double *)v208;
            v208 += 4;
            v199 = *v198;
            *(float *)&__src = v199;
            _TIFFmemcpy(v156, &__src, v147);
            if (v147 != 4)
              TIFFErrorExtR(a1, "_TIFFVSetField", "Rational2Double: .set_field_type in not 4 but %d", v200, v201, v202, v203, v204, v147);
            goto LABEL_158;
          case 0xB:
            v191 = (double *)v208;
            v208 += 4;
            LODWORD(__src) = _TIFFClampDoubleToFloat(*v191);
            goto LABEL_233;
          case 0xC:
LABEL_226:
            v183 = v208;
            v208 += 4;
            __src = *(_QWORD *)v183;
LABEL_233:
            v168 = v156;
            v169 = v147;
            goto LABEL_234;
          case 0x10:
          case 0x12:
            v185 = v208;
            v208 += 4;
            __src = *(_QWORD *)v185;
            _TIFFmemcpy(v156, &__src, v147);
            if ((*(_BYTE *)(a1 + 18) & 8) != 0 || !HIDWORD(__src))
              goto LABEL_158;
            TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad LONG8 or IFD8 value %llu for \"%s\" tag %d in ClassicTIFF. Tag won't be written to file", v186, v187, v188, v189, v190, *(_QWORD *)a1);
            break;
          case 0x11:
            v192 = v208;
            v208 += 4;
            __src = *(_QWORD *)v192;
            _TIFFmemcpy(v156, &__src, v147);
            if ((*(_BYTE *)(a1 + 18) & 8) != 0 || __src == (int)__src)
              goto LABEL_158;
            TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad SLONG8 value %lli for \"%s\" tag %d in ClassicTIFF. Tag won't be written to file", v193, v194, v195, v196, v197, *(_QWORD *)a1);
            break;
          default:
            _TIFFmemset(v156, 0, v147);
            return 0;
        }
      }
      v174 = *(unsigned int *)(a1 + 408);
      if ((int)v174 < 1)
LABEL_217:
        _TIFFVSetField_cold_2();
      v175 = 0;
      v176 = *(_QWORD *)(a1 + 416);
      v177 = 16;
      while (**(_DWORD **)(v176 + v177 - 16) != a2)
      {
        ++v175;
        v177 += 24;
        if (v174 == v175)
          goto LABEL_217;
      }
      v178 = *(char **)(v176 + v177);
      if (v178)
      {
        _TIFFfreeExt(a1, v178);
        *(_QWORD *)(v176 + v177) = 0;
        LODWORD(v174) = *(_DWORD *)(a1 + 408);
      }
      v179 = v174 - 1;
      *(_DWORD *)(a1 + 408) = v179;
      if (v179 > (int)v175)
      {
        v180 = v177 - 16;
        do
        {
          v17 = 0;
          v181 = *(_QWORD *)(a1 + 416) + v180;
          ++v175;
          *(_OWORD *)v181 = *(_OWORD *)(v181 + 24);
          *(_QWORD *)(v181 + 16) = *(_QWORD *)(v181 + 40);
          v180 += 24;
        }
        while (v175 < *(int *)(a1 + 408));
        return v17;
      }
    }
    return 0;
  }
  switch(v15)
  {
    case 320:
      v17 = 1;
      v18 = 1 << *(_WORD *)(a1 + 116);
      v19 = (const void **)v208;
      v208 += 4;
      v20 = v18;
      setByteArray((_QWORD *)a1, (char **)(a1 + 184), *v19, v18, 2, v9, v10, v11);
      v21 = (const void **)v208;
      v208 += 4;
      setByteArray((_QWORD *)a1, (char **)(a1 + 192), *v21, v20, 2, v22, v23, v24);
      v25 = (char **)(a1 + 200);
      v26 = v208;
      v208 += 4;
      p_src = *(unint64_t **)v26;
      v28 = (_QWORD *)a1;
      v29 = v20;
      goto LABEL_15;
    case 321:
      v86 = v208;
      v208 += 4;
      *(_WORD *)(a1 + 208) = *(_DWORD *)v86;
      v208 = v86 + 8;
      *(_WORD *)(a1 + 210) = *((_DWORD *)v86 + 2);
      break;
    case 322:
      v87 = v208;
      v208 += 4;
      v88 = *(_DWORD *)v87;
      if ((*(_DWORD *)v87 & 0xF) == 0)
        goto LABEL_155;
      if (*(_DWORD *)(a1 + 12))
        goto LABEL_133;
      TIFFWarningExtR(a1, *(const char **)a1, "Nonstandard tile width %u, convert file", v7, v8, v9, v10, v11, v88);
LABEL_155:
      *(_DWORD *)(a1 + 100) = v88;
      goto LABEL_156;
    case 323:
      v89 = v208;
      v208 += 4;
      v90 = *(_DWORD *)v89;
      if ((*(_DWORD *)v89 & 0xF) == 0)
        goto LABEL_98;
      if (*(_DWORD *)(a1 + 12))
        goto LABEL_133;
      TIFFWarningExtR(a1, *(const char **)a1, "Nonstandard tile length %u, convert file", v7, v8, v9, v10, v11, v90);
LABEL_98:
      *(_DWORD *)(a1 + 104) = v90;
LABEL_156:
      v41 = *(_DWORD *)(a1 + 16) | 0x400;
      goto LABEL_157;
    case 324:
    case 325:
    case 326:
    case 327:
    case 328:
    case 329:
    case 331:
    case 332:
    case 335:
    case 336:
    case 337:
      goto LABEL_125;
    case 330:
      if ((*(_BYTE *)(a1 + 17) & 0x20) == 0)
      {
        v91 = v208;
        v208 += 4;
        v92 = *(_DWORD *)v91;
        *(_WORD *)(a1 + 320) = *(_DWORD *)v91;
        v32 = (char **)(a1 + 328);
        v208 = v91 + 8;
        v34 = (const void *)*((_QWORD *)v91 + 1);
        v36 = (unsigned __int16)v92;
        goto LABEL_123;
      }
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Sorry, cannot nest SubIFDs", v7, v8, v9, v10, v11, *(_QWORD *)a1);
      return 0;
    case 333:
      v93 = v208;
      v208 += 4;
      v94 = *v93;
      v207 = v94;
      v208 = v93 + 8;
      v95 = (const void *)*((_QWORD *)v93 + 1);
      v17 = countInkNamesString((_QWORD *)a1, v94, (unint64_t)v95, v7, v8, v9, v10, v11);
      if (!(_DWORD)v17)
        return v17;
      setByteArray((_QWORD *)a1, (char **)(a1 + 384), v95, v207, 1, v96, v97, v98);
      *(_DWORD *)(a1 + 376) = v207;
      v104 = *(_DWORD *)(a1 + 76);
      if ((v104 & 0x40000) != 0)
      {
        if (*(unsigned __int16 *)(a1 + 392) != (_DWORD)v17)
        {
          TIFFErrorExtR(a1, "_TIFFVSetField", "Warning %s; Tag %s:\n"
            "  Value %hu of NumberOfInks is different from the number of inks %hu.\n"
            "  -> NumberOfInks value adapted to %hu",
            v99,
            v100,
            v101,
            v102,
            v103,
            *(_QWORD *)a1);
          *(_WORD *)(a1 + 392) = v17;
        }
      }
      else
      {
        *(_WORD *)(a1 + 392) = v17;
        *(_DWORD *)(a1 + 76) = v104 | 0x40000;
      }
      if ((*(_BYTE *)(a1 + 74) & 1) != 0 && (_DWORD)v17 != *(unsigned __int16 *)(a1 + 130))
        TIFFErrorExtR(a1, "_TIFFVSetField", "Warning %s; Tag %s:\n  Value %hu of NumberOfInks is different from the SamplesPerPixel value %hu",
          v99,
          v100,
          v101,
          v102,
          v103,
          *(_QWORD *)a1);
      break;
    case 334:
      v105 = v208;
      v208 += 4;
      v106 = *(_DWORD *)v105;
      v107 = (unsigned __int16)*(_DWORD *)v105;
      if ((*(_BYTE *)(a1 + 77) & 0x40) == 0)
      {
        *(_WORD *)(a1 + 392) = v106;
        if ((*(_BYTE *)(a1 + 74) & 1) != 0 && v107 != *(unsigned __int16 *)(a1 + 130))
          TIFFErrorExtR(a1, "_TIFFVSetField", "Warning %s; Tag %s:\n  Value %u of NumberOfInks is different from the SamplesPerPixel value %hu",
            v7,
            v8,
            v9,
            v10,
            v11,
            *(_QWORD *)a1);
        break;
      }
      if (v107 == *(unsigned __int16 *)(a1 + 392))
        break;
      TIFFErrorExtR(a1, "_TIFFVSetField", "Error %s; Tag %s:\n"
        "  It is not possible to set the value %u for NumberOfInks\n"
        "  which is different from the number of inks in the InkNames tag (%hu)",
        v7,
        v8,
        v9,
        v10,
        v11,
        *(_QWORD *)a1);
      return 0;
    case 338:
      if (!setExtraSamples(a1, a3, &v207, v7, v8, v9, v10, v11))
        goto LABEL_140;
      break;
    case 339:
      v108 = v208;
      v208 += 4;
      v109 = *(_DWORD *)v108;
      if ((unsigned __int16)v109 - 7 < 0xFFFFFFFA)
        goto LABEL_140;
      *(_WORD *)(a1 + 118) = v109;
      if ((unsigned __int16)v109 == 5
        && *(_WORD *)(a1 + 116) == 32
        && *(__int32 *(**)(uint8x8_t, uint64_t, __int32 *, uint64_t))(a1 + 1248) == _TIFFSwab32BitData)
      {
LABEL_163:
        v54 = (uint64_t (*)())_TIFFSwab16BitData;
LABEL_175:
        *(_QWORD *)(a1 + 1248) = v54;
        break;
      }
      if ((unsigned __int16)v109 - 5 <= 1
        && *(_WORD *)(a1 + 116) == 64
        && *(int8x8_t *(**)(uint64_t, int8x8_t *, uint64_t))(a1 + 1248) == _TIFFSwab64BitData)
      {
LABEL_164:
        v54 = (uint64_t (*)())_TIFFSwab32BitData;
        goto LABEL_175;
      }
      break;
    case 340:
      v32 = (char **)(a1 + 144);
      goto LABEL_120;
    case 341:
      v32 = (char **)(a1 + 152);
LABEL_120:
      if ((*(_BYTE *)(a1 + 18) & 0x40) == 0)
      {
        v110 = (double *)v208;
        v208 += 4;
        setDoubleArrayOneValue((_QWORD *)a1, v32, *(unsigned __int16 *)(a1 + 130), v7, v8, v9, v10, v11, *v110);
        break;
      }
      v111 = (const void **)v208;
      v208 += 4;
      v34 = *v111;
      v36 = *(unsigned __int16 *)(a1 + 130);
LABEL_123:
      v35 = (_QWORD *)a1;
      v37 = 8;
      goto LABEL_124;
    default:
      if (v15 != 530)
        goto LABEL_125;
      v49 = v208;
      v208 += 4;
      *(_WORD *)(a1 + 336) = *(_DWORD *)v49;
      v208 = v49 + 8;
      *(_WORD *)(a1 + 338) = *((_DWORD *)v49 + 2);
      break;
  }
LABEL_158:
  v17 = 1;
LABEL_159:
  v135 = TIFFFieldWithTag((_QWORD *)a1, a2);
  if (v135)
    *(_DWORD *)&v13[((unint64_t)*((unsigned __int16 *)v135 + 12) >> 3) & 0x1FFC] |= 1 << *((_WORD *)v135 + 12);
  *(_DWORD *)(a1 + 16) |= 8u;
  return v17;
}

uint64_t TIFFVSetField(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = TIFFFindField((_QWORD *)a1, a2, 0);
  if (v6)
  {
    if ((_DWORD)a2 == 257 || (*(_BYTE *)(a1 + 16) & 0x40) == 0 || *((_BYTE *)v6 + 26))
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 1280))(a1, a2, a3);
    TIFFErrorExtR(a1, "TIFFSetField", "%s: Cannot modify tag \"%s\" while writing", v7, v8, v9, v10, v11, *(_QWORD *)a1);
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFSetField", "%s: Unknown %stag %u", v7, v8, v9, v10, v11, *(_QWORD *)a1);
  }
  return 0;
}

_DWORD *TIFFFieldWithTag(_QWORD *a1, int a2)
{
  char v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;

  v2 = a2;
  v9 = TIFFFindField(a1, a2, 0);
  if (!v9)
    TIFFWarningExtR((uint64_t)a1, "TIFFFieldWithTag", "Warning, unknown tag 0x%x", v4, v5, v6, v7, v8, v2);
  return v9;
}

uint64_t TIFFReadDirEntryShort(uint64_t a1, int8x8_t *a2, _BYTE *a3, uint8x8_t a4)
{
  uint64_t result;
  unsigned __int32 v7;
  unsigned int v8;
  int8x8_t __dst;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
      result = 0;
      LOWORD(v8) = a2[2].u8[0];
      goto LABEL_26;
    case 3:
      *(_WORD *)a3 = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabShort(a3);
      return 0;
    case 4:
    case 9:
      v7 = a2[2].u32[0];
      __dst.i32[0] = v7;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        v7 = __dst.i32[0];
      }
      if (HIWORD(v7))
        goto LABEL_24;
      result = 0;
LABEL_18:
      *(_WORD *)a3 = v7;
      break;
    case 6:
      v8 = a2[2].i8[0];
      if (((v8 >> 5) & 4) != 0)
        return (v8 >> 5) & 4;
      result = 0;
LABEL_26:
      *(_WORD *)a3 = v8;
      return result;
    case 8:
      v7 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v7 = __dst.u16[0];
      }
      result = (v7 >> 13) & 4;
      if (((v7 >> 13) & 4) == 0)
        goto LABEL_18;
      return result;
    case 0x10:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!(_DWORD)result)
        goto LABEL_22;
      return result;
    case 0x11:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!(_DWORD)result)
      {
LABEL_22:
        if (*(_QWORD *)&__dst >> 16)
        {
LABEL_24:
          result = 4;
        }
        else
        {
          result = 0;
          *(_WORD *)a3 = __dst.i16[0];
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t _TIFFCheckFieldIsValidForCodec(uint64_t a1, int a2)
{
  uint64_t result;
  unsigned int v5;
  int v6;

  if (((a2 - 292) > 0x37 || ((1 << (a2 - 36)) & 0x80001C02000003) == 0)
    && ((a2 - 512) > 9 || ((1 << a2) & 0x38F) == 0)
    && a2 != 50674)
  {
    return 1;
  }
  result = (uint64_t)_cg_TIFFIsCODECConfigured(*(unsigned __int16 *)(a1 + 120));
  if ((_DWORD)result)
  {
    v5 = *(unsigned __int16 *)(a1 + 120);
    if (v5 <= 0x8002)
    {
      switch(*(_WORD *)(a1 + 120))
      {
        case 2:
        case 3:
        case 4:
          goto LABEL_16;
        case 5:
        case 8:
          return a2 == 317;
        case 6:
          if ((a2 - 512) >= 0xA)
            return 0;
          result = dword_18820F2DC[a2 - 512];
          break;
        case 7:
          return a2 == 347;
        default:
          return 0;
      }
      return result;
    }
    if (*(unsigned __int16 *)(a1 + 120) > 0x8846u)
    {
      if (v5 == 34887)
        return a2 == 50674;
      if (v5 == 34925)
        return a2 == 317;
      v6 = 50000;
    }
    else
    {
      if (v5 == 32771)
      {
LABEL_16:
        if ((a2 - 326) < 3)
          return 1;
        if (a2 == 293)
        {
          if (v5 == 4)
            return 1;
        }
        else if (a2 == 292 && v5 == 3)
        {
          return 1;
        }
        return 0;
      }
      if (v5 == 32909)
        return a2 == 317;
      v6 = 32946;
    }
    if (v5 != v6)
      return 0;
    return a2 == 317;
  }
  return result;
}

uint64_t _TIFFCastUInt64ToSSize(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (a2 < 0)
  {
    a2 = 0;
    if (a1)
    {
      if (a3)
      {
        TIFFErrorExtR(a1, a3, "Integer overflow", a4, a5, a6, a7, a8, vars0);
        return 0;
      }
    }
  }
  return a2;
}

uint64_t TIFFReadDirEntryLong(uint64_t a1, int8x8_t *a2, __int32 *a3, uint8x8_t a4)
{
  uint64_t result;
  unsigned __int32 v7;
  unsigned __int32 v8;
  unsigned int v9;
  int8x8_t __dst;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
      result = 0;
      v7 = a2[2].u8[0];
      goto LABEL_28;
    case 3:
      v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v8 = __dst.u16[0];
      }
      result = 0;
      goto LABEL_21;
    case 4:
      *a3 = a2[2].i32[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabLong(a3, a4);
      return 0;
    case 6:
      v7 = a2[2].i8[0];
      if (((v7 >> 5) & 4) != 0)
      {
        result = (v7 >> 5) & 4;
      }
      else
      {
        result = 0;
LABEL_28:
        *a3 = v7;
      }
      break;
    case 8:
      v9 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v9 = __dst.u16[0];
      }
      result = (v9 >> 13) & 4;
      if (((v9 >> 13) & 4) != 0)
        return result;
      v7 = (__int16)v9;
      goto LABEL_28;
    case 9:
      v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        v8 = __dst.i32[0];
      }
      result = (v8 >> 29) & 4;
      if (((v8 >> 29) & 4) == 0)
LABEL_21:
        *a3 = v8;
      return result;
    case 0x10:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!(_DWORD)result)
        goto LABEL_25;
      return result;
    case 0x11:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!(_DWORD)result)
      {
LABEL_25:
        if (HIDWORD(*(_QWORD *)&__dst))
        {
          result = 4;
        }
        else
        {
          result = 0;
          *a3 = __dst.i32[0];
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntryPersampleShort(uint64_t a1, uint64_t a2, _WORD *a3)
{
  uint64_t v3;
  char *v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  void *v12;

  if (*(_QWORD *)(a2 + 8) < (unint64_t)*(unsigned __int16 *)(a1 + 130))
    return 1;
  v12 = 0;
  v3 = TIFFReadDirEntryShortArray(a1, a2, (char **)&v12);
  if (!(_DWORD)v3)
  {
    v6 = (char *)v12;
    if (v12)
    {
      v7 = *(unsigned __int16 *)(a1 + 130);
      v8 = *(unsigned __int16 *)v12;
      *a3 = v8;
      v9 = 2;
      while ((_WORD)--v7)
      {
        v10 = *(unsigned __int16 *)&v6[v9];
        v9 += 2;
        if (v10 != v8)
        {
          v3 = 5;
          goto LABEL_10;
        }
      }
      v3 = 0;
LABEL_10:
      _TIFFfreeExt(a1, v6);
    }
  }
  return v3;
}

void _TIFFfreeExt(uint64_t a1, char *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (a1 && a2 && *(uint64_t *)(a1 + 1368) >= 1)
  {
    v2 = *((_QWORD *)a2 - 2);
    a2 -= 16;
    v3 = *(_QWORD *)(a1 + 1376);
    v4 = v3 - v2;
    if (v3 < v2)
      _TIFFfreeExt_cold_1();
    *(_QWORD *)(a1 + 1376) = v4;
  }
  _TIFFfree(a2);
}

uint64_t TIFFReadDirEntryShortArray(uint64_t a1, uint64_t a2, char **a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int v18;
  unsigned int v19;
  char *v20;
  int v21;
  unsigned int v22;
  char *v23;
  int8x8_t v24;
  char *v25;
  int v26;
  char *v27;
  char *v28;
  __int16 v29;
  uint64_t v30;
  char *v31;
  char *v32;
  int8x8_t *v33;
  int8x8_t v34;
  char *v35;
  __int32 *v36;
  __int32 v37;
  char *v38;
  char *v39;
  unsigned int v40;
  char *v41;
  __int32 *v42;
  __int32 v43;
  char *v44;
  int8x8_t *v45;
  int8x8_t v46;
  char *v48;
  unsigned int v49;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x11;
  v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0)
    return 2;
  v49 = 0;
  v48 = 0;
  v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v49, 2u, (void **)&v48, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)v16 || (v17 = v48) == 0)
  {
    *a3 = 0;
  }
  else
  {
    v18 = *(unsigned __int16 *)(a2 + 2);
    if (v18 == 3)
    {
      *a3 = v48;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabArrayOfShort((uint64_t)v17, v49);
      return 0;
    }
    else if (v18 == 8)
    {
      v19 = v49;
      if (v49)
      {
        v20 = v48;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabShort(v20);
          v21 = *(unsigned __int16 *)v20 >> 13;
          if ((v21 & 4) != 0)
            break;
          v20 += 2;
          if (!--v19)
            goto LABEL_15;
        }
        v16 = v21 & 4;
        v30 = a1;
        v31 = v17;
LABEL_67:
        _TIFFfreeExt(v30, v31);
        return v16;
      }
LABEL_15:
      v16 = 0;
      *a3 = v17;
    }
    else
    {
      v22 = v49;
      v23 = (char *)_TIFFmallocExt((_QWORD *)a1, 2 * v49, v10, v11, v12, v13, v14, v15);
      if (v23)
      {
        v25 = v23;
        v26 = *(unsigned __int16 *)(a2 + 2);
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v22)
            {
              v27 = v23;
              v28 = v17;
              do
              {
                v29 = *v28++;
                *(_WORD *)v27 = v29;
                v27 += 2;
                --v22;
              }
              while (v22);
            }
            goto LABEL_63;
          case 2:
          case 3:
          case 5:
          case 7:
          case 8:
            goto LABEL_63;
          case 4:
            if (!v22)
              goto LABEL_63;
            v35 = v23;
            v36 = (__int32 *)v17;
            while (1)
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                v24 = TIFFSwabLong(v36, (uint8x8_t)v24);
              v37 = *v36;
              if (HIWORD(*v36))
                goto LABEL_64;
              ++v36;
              *(_WORD *)v35 = v37;
              v35 += 2;
              if (!--v22)
                goto LABEL_63;
            }
          case 6:
            if (!v22)
              goto LABEL_63;
            v38 = v23;
            v39 = v17;
            while (1)
            {
              v40 = *v39;
              if (((v40 >> 5) & 4) != 0)
                break;
              ++v39;
              *(_WORD *)v38 = v40;
              v38 += 2;
              if (!--v22)
                goto LABEL_63;
            }
            v16 = (v40 >> 5) & 4;
            goto LABEL_66;
          case 9:
            if (!v22)
              goto LABEL_63;
            v41 = v23;
            v42 = (__int32 *)v17;
            break;
          default:
            if (v26 == 16)
            {
              if (!v22)
                goto LABEL_63;
              v44 = v23;
              v45 = (int8x8_t *)v17;
              while (1)
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabLong8(v45);
                v46 = *v45;
                if (*(unint64_t *)v45 >> 16)
                  break;
                ++v45;
                *(_WORD *)v44 = v46.i16[0];
                v44 += 2;
                if (!--v22)
                  goto LABEL_63;
              }
            }
            else
            {
              if (v26 != 17 || !v22)
                goto LABEL_63;
              v32 = v23;
              v33 = (int8x8_t *)v17;
              while (1)
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabLong8(v33);
                v34 = *v33;
                if (*(unint64_t *)v33 >> 16)
                  break;
                ++v33;
                *(_WORD *)v32 = v34.i16[0];
                v32 += 2;
                if (!--v22)
                  goto LABEL_63;
              }
            }
            goto LABEL_64;
        }
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v24 = TIFFSwabLong(v42, (uint8x8_t)v24);
          v43 = *v42;
          if (HIWORD(*v42))
            break;
          ++v42;
          *(_WORD *)v41 = v43;
          v41 += 2;
          if (!--v22)
          {
LABEL_63:
            _TIFFfreeExt(a1, v17);
            v16 = 0;
            *a3 = v25;
            return v16;
          }
        }
LABEL_64:
        v16 = 4;
LABEL_66:
        _TIFFfreeExt(a1, v17);
        v30 = a1;
        v31 = v25;
        goto LABEL_67;
      }
      _TIFFfreeExt(a1, v17);
      return 7;
    }
  }
  return v16;
}

uint64_t TIFFSwabArrayOfShort(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  char *v3;
  char v4;

  if (a2 >= 1)
  {
    v2 = a2 + 1;
    v3 = (char *)(result + 1);
    do
    {
      v4 = *v3;
      *v3 = *(v3 - 1);
      *(v3 - 1) = v4;
      --v2;
      v3 += 2;
    }
    while (v2 > 1);
  }
  return result;
}

unint64_t _cg_TIFFStripSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;

  v8 = *(_DWORD *)(a1 + 132);
  v9 = *(_DWORD *)(a1 + 92);
  if (v8 >= v9)
    v10 = v9;
  else
    v10 = v8;
  return TIFFVStripSize64(a1, v10, a3, a4, a5, a6, a7, a8);
}

uint64_t _cg_TIFFScanlineSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v9 = _cg_TIFFScanlineSize64(a1, a2, a3, a4, a5, a6, a7, a8);
  return _TIFFCastUInt64ToSSize(a1, v9, "TIFFScanlineSize", v10, v11, v12, v13, v14);
}

uint64_t _TIFFGetMaxColorChannels(unsigned int a1)
{
  uint64_t v1;

  if (a1 > 0xA)
  {
LABEL_6:
    if (a1 != 32845)
      return 0;
    return 3;
  }
  v1 = 1;
  if (((1 << a1) & 0x744) != 0)
    return 3;
  if (((1 << a1) & 0xB) == 0)
  {
    if (((1 << a1) & 0x30) != 0)
      return 4;
    goto LABEL_6;
  }
  return v1;
}

uint64_t TIFFSetCompressionScheme(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  char **v5;
  char *v7;

  v4 = &registeredCODECS;
  while (1)
  {
    v4 = (uint64_t *)*v4;
    if (!v4)
      break;
    v5 = (char **)v4[1];
    if (*((unsigned __int16 *)v5 + 4) == (unsigned __int16)a2)
      goto LABEL_4;
  }
  if ("None")
  {
    v5 = &_TIFFBuiltinCODECS;
    while (*((unsigned __int16 *)v5 + 4) != (unsigned __int16)a2)
    {
      v7 = v5[3];
      v5 += 3;
      if (!v7)
        goto LABEL_9;
    }
LABEL_4:
    _TIFFSetDefaultCompressionState(a1);
    return ((uint64_t (*)(uint64_t, uint64_t))v5[2])(a1, a2);
  }
LABEL_9:
  _TIFFSetDefaultCompressionState(a1);
  return 1;
}

uint64_t TIFFInitDumpMode(_QWORD *a1)
{
  a1[119] = DumpFixupTags;
  a1[126] = DumpModeDecode;
  a1[128] = DumpModeDecode;
  a1[130] = DumpModeDecode;
  a1[127] = DumpModeEncode;
  a1[129] = DumpModeEncode;
  a1[131] = DumpModeEncode;
  a1[133] = DumpModeSeek;
  return 1;
}

uint64_t DumpFixupTags()
{
  return 1;
}

_QWORD *__copy_helper_block_e8_48c55_ZTSNSt3__16vectorI13IIODecodeInfoNS_9allocatorIS1_EEEE(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  v2 = (_QWORD *)(a1 + 48);
  v2[2] = 0;
  return std::vector<IIODecodeInfo>::__init_with_size[abi:ne180100]<IIODecodeInfo*,IIODecodeInfo*>(v2, *(const void **)(a2 + 48), *(_QWORD *)(a2 + 56), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 3));
}

uint64_t iioSkipCallback(int a1, IIOImageReadSession **a2)
{
  if (IIOImageReadSession::skipBytes(*a2, a1) == a1)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

IIOImageRead *IIOImageReadSession::skipBytes(IIOImageReadSession *this, uint64_t a2)
{
  IIOImageRead *v2;
  IIOImageReadSession *v3;
  IIOImageRead *result;
  IIOImageRead *v5;
  CFIndex Size;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t Bytes;
  _BYTE v11[8192];
  uint64_t v12;

  v3 = (IIOImageReadSession *)MEMORY[0x1E0C80A78](this, a2);
  v12 = *MEMORY[0x1E0C80C00];
  result = (IIOImageRead *)*((_QWORD *)v3 + 4);
  if (result)
  {
    v5 = v2;
    Size = IIOImageRead::getSize(result);
    if (Size == -1)
    {
      bzero(v11, 0x2000uLL);
      if (v5)
      {
        v8 = (unint64_t)v5;
        do
        {
          if (v8 >= 0x400)
            v9 = 1024;
          else
            v9 = v8;
          Bytes = IIOImageReadSession::getBytes(v3, v11, v9);
          if (!Bytes)
            break;
          v8 -= Bytes;
        }
        while (v8);
      }
      else
      {
        v8 = 0;
      }
      return (IIOImageRead *)((char *)v5 - v8);
    }
    else
    {
      v7 = *((_QWORD *)v3 + 5);
      if (Size - v7 >= (unint64_t)v5)
        result = v5;
      else
        result = (IIOImageRead *)(Size - v7);
      *((_QWORD *)v3 + 5) = (char *)result + v7;
    }
  }
  return result;
}

const __CFArray *createArrayPropertyValue(CGImageMetadata *a1, uint64_t a2, const char *a3, uint64_t a4, const char *a5)
{
  const __CFArray *Mutable;
  const __CFAllocator *v10;
  uint64_t v11;
  XMPMeta *v12;
  const char *v13;
  const __CFString *v14;
  CFIndex Count;
  const __CFString *v16;
  const char *v17;
  const __CFString *v18;
  const __CFString *NamespacePrefixForNamespace;
  const char *v20;
  void **v21;
  CFIndex v22;
  uint64_t v23;
  const __CFString *v24;
  void **v25;
  CFStringRef v26;
  CGImageMetadataTagRef v27;
  _DWORD *v28;
  void **v29;
  void **v30;
  void **v31;
  const void *v32;
  CGImageMetadataType v33;
  const __CFString *NamespaceURIForPropertyPath;
  CGImageMetadataTag *ValueAtIndex;
  CGImageMetadataTagRef v36;
  CFTypeID v37;
  const __CFString *v38;
  _DWORD *v39;
  const char *v40;
  void **v41;
  const char *v42;
  __CFDictionary *StructPropertyValue;
  CGImageMetadataTagRef v44;
  CGImageMetadataTagRef v45;
  CFTypeID v46;
  void **v47;
  CFStringRef v48;
  CGImageMetadataTagRef v49;
  uint64_t v50;
  CGImageMetadataTagRef v51;
  CFIndex idx;
  const __CFString *PropertyNameFromPath;
  const __CFString *PropertyPrefixFromPath;
  const __CFString *v56;
  const __CFString *v57;
  const __CFString *cf;
  const __CFString *v59;
  uint64_t (**v61)();
  _DWORD *v62;
  uint64_t (**v63)();
  _DWORD *v64;
  uint64_t (**v65)();
  _DWORD *v66;
  uint64_t v67;
  void *__p[2];
  uint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  void *v73[2];
  uint64_t v74;
  void *v75[2];
  uint64_t v76;

  v75[0] = 0;
  v75[1] = 0;
  v76 = 0;
  v73[0] = 0;
  v73[1] = 0;
  v74 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  __p[0] = 0;
  __p[1] = 0;
  v69 = 0;
  v66 = 0;
  v67 = 0;
  v65 = 0;
  TXMPIterator<std::string>::TXMPIterator(&v65, a2, a3, a5, 0);
  Mutable = 0;
  if (a3 && a4 && a5)
  {
    if (TXMPIterator<std::string>::Next((uint64_t)&v65, (uint64_t)v75, (uint64_t)&v70, (uint64_t)__p, (uint64_t *)((char *)&v67 + 4)))
    {
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v59 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a5, 0x8000100u);
      v56 = CFStringCreateWithCString(v10, a3, 0x8000100u);
      PropertyPrefixFromPath = createPropertyPrefixFromPath(v59);
      PropertyNameFromPath = createPropertyNameFromPath(v59);
      Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x1E0C9B378]);
      if (Mutable)
      {
        while (1)
        {
          do
          {
            if (!TXMPIterator<std::string>::Next((uint64_t)&v65, (uint64_t)v75, (uint64_t)&v70, (uint64_t)__p, &v67))
              goto LABEL_104;
            v11 = HIBYTE(v72);
            if (v72 < 0)
              v11 = v71;
          }
          while (!v11);
          if (v76 >= 0)
            v12 = (XMPMeta *)v75;
          else
            v12 = (XMPMeta *)v75[0];
          TXMPMeta<std::string>::GetNamespacePrefix(v12, (uint64_t)v73);
          if (v72 >= 0)
            v13 = (const char *)&v70;
          else
            v13 = v70;
          v14 = CFStringCreateWithCString(v10, v13, 0x8000100u);
          Count = CFArrayGetCount(Mutable);
          v16 = CFStringCreateWithFormat(v10, 0, CFSTR("[%ld]"), Count);
          if (v76 >= 0)
            v17 = (const char *)v75;
          else
            v17 = (const char *)v75[0];
          v18 = CFStringCreateWithCString(v10, v17, 0x8000100u);
          NamespacePrefixForNamespace = createNamespacePrefixForNamespace(v18);
          CGImageMetadataRegisterNamespaceForPrefix(a1, v18, NamespacePrefixForNamespace, 0);
          if ((v67 & 0x80010000) == 0)
          {
            if ((v67 & 0x1F00) == 0)
            {
              v22 = CFArrayGetCount(Mutable);
              v23 = v22;
              if ((v67 & 0x20) == 0)
              {
                v24 = CFStringCreateWithFormat(v10, 0, CFSTR("[%ld]"), v22);
                if (v24)
                {
                  if (v69 >= 0)
                    v25 = __p;
                  else
                    v25 = (void **)__p[0];
                  v26 = CFStringCreateWithCString(v10, (const char *)v25, 0x8000100u);
                  if (v26)
                  {
                    v27 = CGImageMetadataTagCreate(v56, PropertyPrefixFromPath, v24, kCGImageMetadataTypeString, v26);
                    if (v27)
                    {
                      CFArrayAppendValue(Mutable, v27);
                      CFRelease(v27);
                    }
                    CFRelease(v26);
                  }
                  CFRelease(v24);
                }
                goto LABEL_20;
              }
              NamespaceURIForPropertyPath = createNamespaceURIForPropertyPath(v14);
              cf = createNamespacePrefixForNamespace(NamespaceURIForPropertyPath);
              v57 = createPropertyNameFromPath(v14);
              idx = v23 - 1;
              if (v23 < 1)
                goto LABEL_97;
              ValueAtIndex = (CGImageMetadataTag *)CFArrayGetValueAtIndex(Mutable, idx);
              v36 = ValueAtIndex;
              if (!ValueAtIndex)
                goto LABEL_97;
              v37 = CFGetTypeID(ValueAtIndex);
              if (v37 == CFStringGetTypeID())
              {
                v38 = CFStringCreateWithFormat(v10, 0, CFSTR("[%ld]"), idx);
                if (!v38)
                  goto LABEL_97;
                v36 = CGImageMetadataTagCreate(v56, PropertyPrefixFromPath, v38, kCGImageMetadataTypeString, v36);
                if (v36)
                {
                  CFArraySetValueAtIndex(Mutable, idx, v36);
                  CFRelease(v36);
                }
                CFRelease(v38);
                if (!v36)
                  goto LABEL_97;
LABEL_90:
                if (v69 >= 0)
                  v47 = __p;
                else
                  v47 = (void **)__p[0];
                v48 = CFStringCreateWithCString(v10, (const char *)v47, 0x8000100u);
                if (v48)
                {
                  v49 = CGImageMetadataTagCreate(NamespaceURIForPropertyPath, cf, v57, kCGImageMetadataTypeString, v48);
                  if (v49)
                  {
                    v50 = (uint64_t)v36;
                    v51 = v49;
                    CGImageMetadataTagAppendQualifier(a1, v50, v49);
                    CFRelease(v51);
                  }
                  CFRelease(v48);
                }
              }
              else
              {
                v46 = CFGetTypeID(v36);
                if (v46 == CGImageMetadataTagGetTypeID())
                  goto LABEL_90;
              }
LABEL_97:
              if (NamespaceURIForPropertyPath)
                CFRelease(NamespaceURIForPropertyPath);
              if (cf)
                CFRelease(cf);
              if (v57)
                CFRelease(v57);
              goto LABEL_20;
            }
            if ((v67 & 0x200) != 0)
            {
              v28 = *(_DWORD **)(a2 + 8);
              v63 = &off_1E1BB2B60;
              v64 = v28;
              WXMPMeta_IncrementRefCount_1((uint64_t)v28);
              if (v76 >= 0)
                v29 = v75;
              else
                v29 = (void **)v75[0];
              if (v74 >= 0)
                v30 = v73;
              else
                v30 = (void **)v73[0];
              if (v72 >= 0)
                v31 = (void **)&v70;
              else
                v31 = (void **)v70;
              v32 = (const void *)createArrayPropertyValue(a1, &v63, v29, v30, v31);
              v63 = &off_1E1BB2B60;
              WXMPMeta_DecrementRefCount_1(v64);
              v64 = 0;
              if ((v67 & 0x1000) != 0)
              {
                v33 = kCGImageMetadataTypeAlternateText;
              }
              else if ((v67 & 0x800) != 0)
              {
                v33 = kCGImageMetadataTypeAlternateArray;
              }
              else if ((v67 & 0x400) != 0)
              {
                v33 = kCGImageMetadataTypeArrayOrdered;
              }
              else
              {
                v33 = kCGImageMetadataTypeArrayUnordered;
              }
              v45 = CGImageMetadataTagCreate(v18, NamespacePrefixForNamespace, v16, v33, v32);
              if (v32)
                CFRelease(v32);
              if (v45)
              {
                CFArrayAppendValue(Mutable, v45);
                CFRelease(v45);
              }
              goto LABEL_81;
            }
            if ((v67 & 0x100) != 0)
            {
              v39 = *(_DWORD **)(a2 + 8);
              v61 = &off_1E1BB2B60;
              v62 = v39;
              WXMPMeta_IncrementRefCount_1((uint64_t)v39);
              if (v76 >= 0)
                v40 = (const char *)v75;
              else
                v40 = (const char *)v75[0];
              if (v74 >= 0)
                v41 = v73;
              else
                v41 = (void **)v73[0];
              if (v72 >= 0)
                v42 = (const char *)&v70;
              else
                v42 = v70;
              StructPropertyValue = createStructPropertyValue(a1, (uint64_t)&v61, v40, (uint64_t)v41, v42);
              v61 = &off_1E1BB2B60;
              WXMPMeta_DecrementRefCount_1(v62);
              v62 = 0;
              v44 = CGImageMetadataTagCreate(v18, NamespacePrefixForNamespace, v16, kCGImageMetadataTypeStructure, StructPropertyValue);
              if (StructPropertyValue)
                CFRelease(StructPropertyValue);
              if (v44)
              {
                CFArrayAppendValue(Mutable, v44);
                CFRelease(v44);
              }
LABEL_81:
              TXMPIterator<std::string>::Skip((uint64_t)&v65, 1);
              goto LABEL_20;
            }
            v20 = (const char *)&v70;
            if (v72 < 0)
              v20 = v70;
            v21 = __p;
            if (v69 < 0)
              v21 = (void **)__p[0];
            printf("UNKNOWN - %s = \"%s\", 0x%X\n", v20, (const char *)v21, v67);
          }
LABEL_20:
          if (v14)
            CFRelease(v14);
          if (v16)
            CFRelease(v16);
          if (v18)
            CFRelease(v18);
          if (NamespacePrefixForNamespace)
            CFRelease(NamespacePrefixForNamespace);
        }
      }
LABEL_104:
      if (v59)
        CFRelease(v59);
      if (PropertyNameFromPath)
        CFRelease(PropertyNameFromPath);
      if (v56)
        CFRelease(v56);
      if (PropertyPrefixFromPath)
        CFRelease(PropertyPrefixFromPath);
    }
    else
    {
      Mutable = 0;
    }
  }
  v65 = &off_1E1BAC3F0;
  WXMPIterator_DecrementRefCount_1(v66);
  if (SHIBYTE(v69) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v72) < 0)
    operator delete(v70);
  if (SHIBYTE(v74) < 0)
    operator delete(v73[0]);
  if (SHIBYTE(v76) < 0)
    operator delete(v75[0]);
  return Mutable;
}

void sub_187EB17B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,_DWORD *a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  WXMPIterator_DecrementRefCount_1(a26);
  if (a33 < 0)
    operator delete(__p);
  if (*(char *)(v33 - 137) < 0)
    operator delete(*(void **)(v33 - 160));
  if (*(char *)(v33 - 113) < 0)
    operator delete(*(void **)(v33 - 136));
  if (*(char *)(v33 - 89) < 0)
    operator delete(*(void **)(v33 - 112));
  _Unwind_Resume(a1);
}

__CFDictionary *createStructPropertyValue(CGImageMetadata *a1, uint64_t a2, const char *a3, uint64_t a4, const char *a5)
{
  __CFDictionary *Mutable;
  CGImageMetadataTagRef v11;
  uint64_t v12;
  XMPMeta *v13;
  const char *v14;
  const __CFString *v15;
  const __CFString *NamespaceURIForPropertyPath;
  const __CFString *NamespacePrefixForNamespace;
  const __CFString *PropertyNameFromPath;
  void **v19;
  const char *v20;
  const __CFString *v21;
  const __CFString *v22;
  const char *CStringPtr;
  const char *v24;
  const char *v25;
  const char *v26;
  _DWORD *v27;
  void **v28;
  void **v29;
  void **v30;
  const void *v31;
  CGImageMetadataType v32;
  const __CFString *v33;
  const __CFString *v34;
  const char *v35;
  CFStringRef v36;
  CGImageMetadataTagRef v37;
  _DWORD *v38;
  void **v39;
  void **v40;
  void **v41;
  const void *v42;
  CGImageMetadataTagRef v43;
  CGImageMetadataTagRef v44;
  CFStringRef v45;
  CGImageMetadataTagRef v46;
  const __CFString *v48;
  const __CFString *cf;
  const __CFAllocator *alloc;
  CGImageMetadata *metadata;
  uint64_t (**v52)();
  _DWORD *v53;
  uint64_t (**v54)();
  _DWORD *v55;
  CFErrorRef err;
  uint64_t (**v57)();
  _DWORD *v58;
  uint64_t v59;
  char *cStr[2];
  uint64_t v61;
  void *__p[2];
  uint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  void *v67[2];
  uint64_t v68;

  v67[0] = 0;
  v67[1] = 0;
  v68 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  __p[0] = 0;
  __p[1] = 0;
  v63 = 0;
  cStr[0] = 0;
  cStr[1] = 0;
  v61 = 0;
  v58 = 0;
  v59 = 0;
  v57 = 0;
  TXMPIterator<std::string>::TXMPIterator(&v57, a2, a3, a5, 0);
  Mutable = 0;
  if (!a3 || !a4 || !a5)
    goto LABEL_108;
  if (!TXMPIterator<std::string>::Next((uint64_t)&v57, (uint64_t)v67, (uint64_t)&v64, (uint64_t)cStr, (uint64_t *)((char *)&v59 + 4)))
  {
    Mutable = 0;
    goto LABEL_108;
  }
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    goto LABEL_108;
  metadata = a1;
  v11 = 0;
  while (TXMPIterator<std::string>::Next((uint64_t)&v57, (uint64_t)v67, (uint64_t)&v64, (uint64_t)cStr, &v59))
  {
    v12 = HIBYTE(v66);
    if (v66 < 0)
      v12 = v65;
    if (v12 && (v59 & 0x80010000) == 0)
    {
      if (v68 >= 0)
        v13 = (XMPMeta *)v67;
      else
        v13 = (XMPMeta *)v67[0];
      TXMPMeta<std::string>::GetNamespacePrefix(v13, (uint64_t)__p);
      if (v66 >= 0)
        v14 = (const char *)&v64;
      else
        v14 = v64;
      v15 = CFStringCreateWithCString(alloc, v14, 0x8000100u);
      NamespaceURIForPropertyPath = createNamespaceURIForPropertyPath(v15);
      NamespacePrefixForNamespace = createNamespacePrefixForNamespace(NamespaceURIForPropertyPath);
      PropertyNameFromPath = createPropertyNameFromPath(v15);
      err = 0;
      if (!CGImageMetadataRegisterNamespaceForPrefix(metadata, NamespaceURIForPropertyPath, NamespacePrefixForNamespace, &err))
      {
        v19 = __p;
        if (v63 < 0)
          v19 = (void **)__p[0];
        v20 = (const char *)v67;
        if (v68 < 0)
          v20 = (const char *)v67[0];
        LogError("createStructPropertyValue", 1005, "An error occurred while registering prefix '%s' for namespace '%s'\n", (const char *)v19, v20);
        if (err)
        {
          v21 = CFErrorCopyFailureReason(err);
          v22 = v21;
          if (v21)
          {
            CStringPtr = CFStringGetCStringPtr(v21, 0);
            LogError("createStructPropertyValue", 1011, "Failure Reason: %s\n", CStringPtr);
            CFRelease(v22);
          }
        }
      }
      if ((v59 & 0x1F00) != 0)
      {
        if ((v59 & 0x200) != 0)
        {
          v27 = *(_DWORD **)(a2 + 8);
          v54 = &off_1E1BB2B60;
          v55 = v27;
          WXMPMeta_IncrementRefCount_1((uint64_t)v27);
          if (v68 >= 0)
            v28 = v67;
          else
            v28 = (void **)v67[0];
          if (v63 >= 0)
            v29 = __p;
          else
            v29 = (void **)__p[0];
          if (v66 >= 0)
            v30 = (void **)&v64;
          else
            v30 = (void **)v64;
          v31 = (const void *)createArrayPropertyValue(metadata, &v54, v28, v29, v30);
          v54 = &off_1E1BB2B60;
          WXMPMeta_DecrementRefCount_1(v55);
          v55 = 0;
          if ((v59 & 0x1000) != 0)
          {
            v32 = kCGImageMetadataTypeAlternateText;
          }
          else if ((v59 & 0x800) != 0)
          {
            v32 = kCGImageMetadataTypeAlternateArray;
          }
          else if ((v59 & 0x400) != 0)
          {
            v32 = kCGImageMetadataTypeArrayOrdered;
          }
          else
          {
            v32 = kCGImageMetadataTypeArrayUnordered;
          }
          v44 = CGImageMetadataTagCreate(NamespaceURIForPropertyPath, NamespacePrefixForNamespace, PropertyNameFromPath, v32, v31);
          if (v31)
            CFRelease(v31);
          if (v44)
          {
            CFDictionaryAddValue(Mutable, PropertyNameFromPath, v44);
            if (v11)
              CFRelease(v11);
          }
          else
          {
            v44 = v11;
          }
          TXMPIterator<std::string>::Skip((uint64_t)&v57, 1);
          v11 = v44;
        }
        else if ((v59 & 0x100) != 0)
        {
          v38 = *(_DWORD **)(a2 + 8);
          v52 = &off_1E1BB2B60;
          v53 = v38;
          WXMPMeta_IncrementRefCount_1((uint64_t)v38);
          if (v68 >= 0)
            v39 = v67;
          else
            v39 = (void **)v67[0];
          if (v63 >= 0)
            v40 = __p;
          else
            v40 = (void **)__p[0];
          if (v66 >= 0)
            v41 = (void **)&v64;
          else
            v41 = (void **)v64;
          v42 = (const void *)createStructPropertyValue(metadata, &v52, v39, v40, v41);
          v52 = &off_1E1BB2B60;
          WXMPMeta_DecrementRefCount_1(v53);
          v53 = 0;
          v43 = CGImageMetadataTagCreate(NamespaceURIForPropertyPath, NamespacePrefixForNamespace, PropertyNameFromPath, kCGImageMetadataTypeStructure, v42);
          if (v42)
            CFRelease(v42);
          if (v43)
          {
            CFDictionaryAddValue(Mutable, PropertyNameFromPath, v43);
            if (v11)
              CFRelease(v11);
          }
          else
          {
            v43 = v11;
          }
          TXMPIterator<std::string>::Skip((uint64_t)&v57, 1);
          v11 = v43;
        }
        else
        {
          v24 = (const char *)&v64;
          if (v66 < 0)
            v24 = v64;
          v25 = (const char *)cStr;
          if (v61 < 0)
            v25 = cStr[0];
          LogMetadata("createStructPropertyValue", 1130, "Unknown property type encounted while parsing XMP - %s = \"%s\", 0x%X\n", v24, v25, v59);
        }
      }
      else if ((v59 & 0x20) != 0)
      {
        v33 = createNamespaceURIForPropertyPath(v15);
        v34 = createNamespacePrefixForNamespace(v33);
        v48 = createPropertyNameFromPath(v15);
        cf = v34;
        if (v11)
        {
          v35 = v61 >= 0 ? (const char *)cStr : cStr[0];
          v36 = CFStringCreateWithCString(alloc, v35, 0x8000100u);
          if (v36)
          {
            v37 = CGImageMetadataTagCreate(v33, v34, v48, kCGImageMetadataTypeString, v36);
            if (v37)
            {
              CGImageMetadataTagAppendQualifier(metadata, (uint64_t)v11, v37);
              CFRelease(v37);
            }
            CFRelease(v36);
          }
        }
        if (v33)
          CFRelease(v33);
        if (cf)
          CFRelease(cf);
        if (v48)
          CFRelease(v48);
      }
      else
      {
        if (SHIBYTE(v61) < 0)
        {
          v26 = cStr[0];
          if (!cStr[0])
            goto LABEL_97;
        }
        else
        {
          v26 = (const char *)cStr;
        }
        v45 = CFStringCreateWithCString(alloc, v26, 0x8000100u);
        if (v45)
        {
          v46 = CGImageMetadataTagCreate(NamespaceURIForPropertyPath, NamespacePrefixForNamespace, PropertyNameFromPath, kCGImageMetadataTypeString, v45);
          if (v46)
          {
            CFDictionaryAddValue(Mutable, PropertyNameFromPath, v46);
            if (v11)
              CFRelease(v11);
          }
          else
          {
            v46 = v11;
          }
          CFRelease(v45);
          v11 = v46;
        }
      }
LABEL_97:
      if (v15)
        CFRelease(v15);
      if (NamespaceURIForPropertyPath)
        CFRelease(NamespaceURIForPropertyPath);
      if (NamespacePrefixForNamespace)
        CFRelease(NamespacePrefixForNamespace);
      if (PropertyNameFromPath)
        CFRelease(PropertyNameFromPath);
    }
  }
  if (v11)
    CFRelease(v11);
LABEL_108:
  v57 = &off_1E1BAC3F0;
  WXMPIterator_DecrementRefCount_1(v58);
  if (SHIBYTE(v61) < 0)
    operator delete(cStr[0]);
  if (SHIBYTE(v63) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v66) < 0)
    operator delete(v64);
  if (SHIBYTE(v68) < 0)
    operator delete(v67[0]);
  return Mutable;
}

void sub_187EB1F0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,_DWORD *a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  uint64_t v35;

  WXMPIterator_DecrementRefCount_1(a22);
  if (a29 < 0)
    operator delete(__p);
  if (a35 < 0)
    operator delete(a30);
  if (*(char *)(v35 - 113) < 0)
    operator delete(*(void **)(v35 - 136));
  if (*(char *)(v35 - 89) < 0)
    operator delete(*(void **)(v35 - 112));
  _Unwind_Resume(a1);
}

CFStringRef createNamespacePrefixForNamespace(const __CFString *a1)
{
  XMPMeta *UTF8String;
  const __CFAllocator *v2;
  void **v3;
  const __CFString *v4;
  const __CFString *v5;
  CFStringRef Copy;
  CFStringRef v7;
  CFRange range;
  void *__p[2];
  uint64_t v11;
  CFRange v12;
  CFRange v13;

  __p[0] = 0;
  __p[1] = 0;
  v11 = 0;
  if (!a1)
    return 0;
  IIOString::IIOString((IIOString *)&range, a1);
  UTF8String = (XMPMeta *)IIOString::createUTF8String((IIOString *)&range);
  IIOString::~IIOString((IIOString *)&range);
  if (!UTF8String)
    return 0;
  if (TXMPMeta<std::string>::GetNamespacePrefix(UTF8String, (uint64_t)__p)
    && ((v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00], v11 >= 0) ? (v3 = __p) : (v3 = (void **)__p[0]),
        v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)v3, 0x8000100u),
        (v5 = v4) != 0))
  {
    range.location = 0;
    range.length = 0;
    v12.length = CFStringGetLength(v4);
    v12.location = 0;
    if (CFStringFindWithOptions(v5, CFSTR(":"), v12, 0, &range))
    {
      v13.length = range.location;
      v13.location = 0;
      Copy = CFStringCreateWithSubstring(v2, v5, v13);
    }
    else
    {
      Copy = CFStringCreateCopy(v2, v5);
    }
    v7 = Copy;
    CFRelease(v5);
  }
  else
  {
    v7 = 0;
  }
  free(UTF8String);
  if (SHIBYTE(v11) < 0)
    operator delete(__p[0]);
  return v7;
}

void sub_187EB2134(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *TXMPIterator<std::string>::TXMPIterator(_QWORD *a1, uint64_t a2, const char *a3, const char *a4, unsigned int a5)
{
  _QWORD *exception;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  *a1 = &off_1E1BAC3F0;
  a1[1] = 0;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPIterator_PropCTor_1(*(_QWORD *)(a2 + 8), a3, a4, a5, v9);
  if (*(_QWORD *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v8 = *(_QWORD *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((_BYTE *)exception + 16) = 0;
  }
  a1[1] = *((_QWORD *)&v9[0] + 1);
  return a1;
}

_QWORD *TXMPIterator<std::string>::TXMPIterator(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  *a1 = &off_1E1BAC3F0;
  a1[1] = 0;
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPIterator_PropCTor_1(*(_QWORD *)(a2 + 8), "", "", a3, v7);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
  a1[1] = *((_QWORD *)&v7[0] + 1);
  return a1;
}

void WXMPIterator_PropCTor_1(uint64_t a1, const char *a2, const char *a3, unsigned int a4, _QWORD *a5)
{
  const char *v8;
  const char *v9;
  XMPIterator *v10;
  int v11;
  XMP_ReadWriteLock *v12;

  *a5 = 0;
  if (a2)
    v8 = a2;
  else
    v8 = "";
  if (a3)
    v9 = a3;
  else
    v9 = "";
  v12 = (XMP_ReadWriteLock *)(a1 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 16), 0);
  v10 = (XMPIterator *)operator new();
  XMPIterator::XMPIterator(v10, (const XMPMeta *)a1, v8, v9, a4);
  v11 = *((_DWORD *)v10 + 2);
  *((_DWORD *)v10 + 2) = v11 + 1;
  if (v11)
    __assert_rtn("WXMPIterator_PropCTor_1", "WXMPIterator.cpp", 54, "iter->clientRefs == 1");
  a5[1] = v10;
  XMP_AutoLock::~XMP_AutoLock(&v12);
}

void sub_187EB2378(void *a1, int a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  void *v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  va_list va;

  va_start(va, a3);
  MEMORY[0x18D761C30](v4, 0x10F3C40652ADE5BLL);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  if (a2 == 3)
  {
    v8 = __cxa_begin_catch(a1);
    *(_DWORD *)(v3 + 32) = *(_DWORD *)v8;
    v9 = (const char *)*((_QWORD *)v8 + 1);
    if (!v9)
      v9 = v5;
    *(_QWORD *)(v3 + 8) = "XMP";
  }
  else
  {
    v10 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      *(_DWORD *)(v3 + 32) = 13;
      v11 = (*(uint64_t (**)(void *))(*(_QWORD *)v10 + 16))(v10);
      if (v11)
        v9 = (const char *)v11;
      else
        v9 = v5;
    }
    else
    {
      *(_DWORD *)(v3 + 32) = 14;
      v9 = "Caught unknown exception";
    }
  }
  *(_QWORD *)v3 = v9;
  __cxa_end_catch();
  JUMPOUT(0x187EB2338);
}

CGColorSpaceRef CGColorSpaceCreateCalRGB(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  CFStringRef *v24;
  CGColorSpaceRef v25;
  const void *v27;
  const void *Profile;
  float v29;
  _BYTE v31[24];
  _BYTE v32[24];
  _BYTE v33[24];
  _BYTE v34[24];
  _BYTE v35[24];
  _BYTE v36[24];
  _BYTE v37[24];
  _BYTE v38[24];
  _BYTE v39[24];
  _BYTE v40[24];
  _BYTE v41[24];
  CFMutableArrayRef v42;
  const void *v43;
  uint64_t v44;
  _QWORD v45[3];

  if (IIOChromaticitiesMatchAdobeRGB(a1, a2, a3, a4, a5, a6, a7, a8, a9))
  {
    v24 = (CFStringRef *)MEMORY[0x1E0C9D8F8];
  }
  else if (IIOChromaticitiesMatchSRGB(a1, a2, a3, a4, a5, a6, a7, a8, a9))
  {
    v24 = (CFStringRef *)MEMORY[0x1E0C9DA10];
  }
  else
  {
    if (!IIOChromaticitiesMatchLinearSRGB(a1, a2, a3, a4, a5, a6, a7, a8, a9))
    {
      memset(v45, 0, sizeof(v45));
      IIODictionary::IIODictionary((IIODictionary *)v45);
      v42 = 0;
      v43 = 0;
      v44 = 0;
      IIOArray::IIOArray((IIOArray *)&v42);
      v27 = (const void *)*MEMORY[0x1E0C9AE50];
      IIODictionary::setObjectForKey((IIODictionary *)v45, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("skipPhosphorsCheck"));
      IIODictionary::setObjectForKey((IIODictionary *)v45, CFSTR("Calibrated RGB Colorspace"), CFSTR("description"));
      IIODictionary::setObjectForKey((IIODictionary *)v45, v27, CFSTR("unrestrictedGamma"));
      IIODictionary::setObjectForKey((IIODictionary *)v45, CFSTR("displayRGB"), CFSTR("profileType"));
      IIONumber::IIONumber((IIONumber *)v41, v29);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v41, CFSTR("gammaR"));
      IIONumber::~IIONumber((IIONumber *)v41);
      IIONumber::IIONumber((IIONumber *)v40, v29);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v40, CFSTR("gammaG"));
      IIONumber::~IIONumber((IIONumber *)v40);
      IIONumber::IIONumber((IIONumber *)v39, v29);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v39, CFSTR("gammaB"));
      IIONumber::~IIONumber((IIONumber *)v39);
      IIONumber::IIONumber((IIONumber *)v38, a1);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v38, CFSTR("whitePointx"));
      IIONumber::~IIONumber((IIONumber *)v38);
      IIONumber::IIONumber((IIONumber *)v37, a2);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v37, CFSTR("whitePointy"));
      IIONumber::~IIONumber((IIONumber *)v37);
      IIONumber::IIONumber((IIONumber *)v36, a3);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v36, CFSTR("phosphorRx"));
      IIONumber::~IIONumber((IIONumber *)v36);
      IIONumber::IIONumber((IIONumber *)v35, a4);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v35, CFSTR("phosphorRy"));
      IIONumber::~IIONumber((IIONumber *)v35);
      IIONumber::IIONumber((IIONumber *)v34, a5);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v34, CFSTR("phosphorGx"));
      IIONumber::~IIONumber((IIONumber *)v34);
      IIONumber::IIONumber((IIONumber *)v33, a6);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v33, CFSTR("phosphorGy"));
      IIONumber::~IIONumber((IIONumber *)v33);
      IIONumber::IIONumber((IIONumber *)v32, a7);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v32, CFSTR("phosphorBx"));
      IIONumber::~IIONumber((IIONumber *)v32);
      IIONumber::IIONumber((IIONumber *)v31, a8);
      IIODictionary::setObjectForKey((uint64_t)v45, (uint64_t)v31, CFSTR("phosphorBy"));
      IIONumber::~IIONumber((IIONumber *)v31);
      IIOAddDateComponents(&v42);
      IIODictionary::setObjectForKey((IIODictionary *)v45, v43, CFSTR("Date"));
      Profile = (const void *)ColorSyncMakeProfile();
      IIOArray::~IIOArray((IIOArray *)&v42);
      IIODictionary::~IIODictionary((IIODictionary *)v45);
      if (!Profile)
        return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
      v25 = (CGColorSpaceRef)MEMORY[0x18D760CA0](Profile, 0);
      CFRelease(Profile);
      if (!v25)
        return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
      return v25;
    }
    v24 = (CFStringRef *)MEMORY[0x1E0C9DA00];
  }
  v25 = CGColorSpaceCreateWithName(*v24);
  if (!v25)
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  return v25;
}

void sub_187EB2808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  va_list va;

  va_start(va, a6);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)(v6 - 144));
  IIODictionary::~IIODictionary((IIODictionary *)(v6 - 120));
  _Unwind_Resume(a1);
}

BOOL IIOChromaticitiesMatchSRGB(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  return fabs(a1 + -0.3127) < 0.0005
      && fabs(a2 + -0.329) < 0.0005
      && fabs(a3 + -0.64) < 0.0005
      && fabs(a4 + -0.33) < 0.0005
      && fabs(a5 + -0.3) < 0.0005
      && fabs(a6 + -0.6) < 0.0005
      && fabs(a7 + -0.15) < 0.0005
      && fabs(a8 + -0.06) < 0.0005
      && fabs(a9 + -2.2) < 0.0005;
}

BOOL IIOChromaticitiesMatchAdobeRGB(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  return fabs(a1 + -0.3127) < 0.0005
      && fabs(a2 + -0.329) < 0.0005
      && fabs(a3 + -0.64) < 0.0005
      && fabs(a4 + -0.33) < 0.0005
      && fabs(a5 + -0.21) < 0.0005
      && fabs(a6 + -0.71) < 0.0005
      && fabs(a7 + -0.15) < 0.0005
      && fabs(a8 + -0.06) < 0.0005
      && fabs(a9 + -2.2) < 0.0005;
}

CGColorSpace *IIOImageSource::createThumbnailColorspace(IIOImageSource *this, CGImageRef image, CGImageAlphaInfo *a3, unint64_t *a4)
{
  CGImageAlphaInfo AlphaInfo;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  int Type;
  _BOOL4 IsOpaque;
  _BOOL4 v12;
  CGColorSpaceRef v13;
  CGColorSpace *v14;
  CGImageAlphaInfo v15;
  CFStringRef Name;
  const char *v17;
  _BYTE v19[24];

  AlphaInfo = CGImageGetAlphaInfo(image);
  ColorSpace = CGImageGetColorSpace(image);
  Model = CGColorSpaceGetModel(ColorSpace);
  Type = CGColorSpaceGetType();
  IsOpaque = _ImageIsOpaque(image);
  if (Model)
  {
    v12 = IsOpaque;
    if (Model != kCGColorSpaceModelRGB || Type == 7)
      v13 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
    else
      v13 = CGColorSpaceRetain(ColorSpace);
    v14 = v13;
    *a4 = 4;
    if (v12)
      v15 = kCGImageAlphaNoneSkipFirst;
    else
      v15 = kCGImageAlphaPremultipliedFirst;
    *a3 = v15;
    CGImageGetBitmapInfo(image);
  }
  else
  {
    v14 = CGColorSpaceRetain(ColorSpace);
    if (AlphaInfo)
    {
      *a4 = 2;
      *a3 = kCGImageAlphaPremultipliedLast;
    }
    else
    {
      *a4 = 1;
      *a3 = kCGImageAlphaNone;
    }
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    Name = CGColorSpaceGetName(v14);
    IIOString::IIOString((IIOString *)v19, Name);
    v17 = (const char *)IIOString::utf8String((IIOString *)v19);
    ImageIOLog("COL createThumbnailColorspace: '%s'\n", v17);
    IIOString::~IIOString((IIOString *)v19);
  }
  return v14;
}

void sub_187EB2C40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
  CGColorSpace *ColorSpace;
  unsigned int v7;
  uint64_t ImageProvider;
  const __CFNumber *Property;
  int v10;
  const char *v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  const __CFData *v25;
  IIOImageRead *Source;
  char *v27;
  int v28;
  const char *v29;
  CFTypeID v30;
  CFTypeID v31;
  CFTypeID v32;
  uint64_t v33;
  IIO_Reader *v34;
  const char *v35;
  size_t BitsPerComponent;
  size_t BytesPerRow;
  size_t Height;
  size_t Width;
  UInt8 buffer[8];
  _QWORD v41[3];
  char __str[16];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  CFRange v48;

  v47 = *MEMORY[0x1E0C80C00];
  memset(v41, 0, sizeof(v41));
  IIODictionary::IIODictionary((IIODictionary *)v41, properties);
  if (image)
  {
    CGImageGetWidth(image);
    CGImageGetHeight(image);
  }
  IIOPackDstInputInfo((IIODictionary *)v41);
  if (image)
  {
    CGImageGetBitsPerPixel(image);
    CGImageGetBitsPerComponent(image);
    ColorSpace = CGImageGetColorSpace(image);
    CGColorSpaceGetModel(ColorSpace);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(image);
  }
  kdebug_trace();
  IIO_LoadHEIFSymbols();
  v7 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    *(_OWORD *)__str = 0u;
    if (image)
    {
      ImageProvider = CGImageGetImageProvider();
      if (ImageProvider && (Property = (const __CFNumber *)CGImageProviderGetProperty()) != 0)
      {
        IIONumber::IIONumber((IIONumber *)buffer, Property);
        v10 = IIONumber::uint32Num((IIONumber *)buffer);
        IIONumber::~IIONumber((IIONumber *)buffer);
      }
      else
      {
        v10 = 0;
      }
      Width = CGImageGetWidth(image);
      Height = CGImageGetHeight(image);
      BytesPerRow = CGImageGetBytesPerRow(image);
      BitsPerComponent = CGImageGetBitsPerComponent(image);
      v11 = "IP";
      if (!ImageProvider)
        v11 = "DP";
      v35 = v11;
      v12 = v10 >> 24;
      v13 = MEMORY[0x1E0C80978];
      if (v10 < 0)
        v14 = __maskrune(v10 >> 24, 0x40000uLL);
      else
        v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
      if (v14)
        v15 = v12;
      else
        v15 = 46;
      v16 = v10 << 8 >> 24;
      if (v10 << 8 < 0)
        v17 = __maskrune(v10 << 8 >> 24, 0x40000uLL);
      else
        v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
      if (v17)
        v18 = v16;
      else
        v18 = 46;
      v19 = (__int16)v10 >> 8;
      if (v10 << 16 < 0)
        v20 = __maskrune((__int16)v10 >> 8, 0x40000uLL);
      else
        v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
      if ((v10 << 24) <= 0x7F000000)
        v21 = *(_DWORD *)(v13 + 4 * (char)v10 + 60) & 0x40000;
      else
        v21 = __maskrune((char)v10, 0x40000uLL);
      if (v20)
        v22 = v19;
      else
        v22 = 46;
      if (v21)
        v23 = (char)v10;
      else
        v23 = 46;
      snprintf(__str, 0x50uLL, "[%p] {%ld,%ld}  rb:%ld  bpc:%ld  (%s) %c%c%c%c", image, Width, Height, BytesPerRow, BitsPerComponent, v35, v15, v18, v22, v23);
      v7 = gIIODebugFlags;
    }
    else
    {
      strcpy(__str, "(NULL)");
    }
    v24 = (v7 >> 12) & 3;
    if (v24)
      ImageIODebugOptions(v24, "A", "CGImageDestinationAddImage", 0, __str, -1, properties);
    v25 = (const __CFData *)CGImageGetProperty();
    *(_QWORD *)buffer = 0;
    if (v25)
    {
      v48.location = 0;
      v48.length = 8;
      CFDataGetBytes(v25, v48, buffer);
      Source = (IIOImageRead *)CGImageSourceGetSource(*(uint64_t *)buffer);
      v27 = IIOImageRead::copySourceInfo(Source);
      free(v27);
    }
  }
  if (idst)
    v28 = 5051;
  else
    v28 = 5050;
  if (idst)
    v29 = "*** ERROR: CGImageDestinationAddImage: cgImage is nil\n";
  else
    v29 = "*** ERROR: CGImageDestinationAddImage: destination is nil\n";
  if (!idst || !image)
    goto LABEL_64;
  v30 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1)
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_24);
  if (v30 != CGImageDestinationGetTypeID::id)
  {
    LogError("CGImageDestinationAddImage", 5052, "*** ERROR: CGImageDestinationAddImage: destination is not a CGImageDestinationRef\n");
    goto LABEL_65;
  }
  v31 = CFGetTypeID(image);
  if (v31 != CGImageGetTypeID())
  {
    v29 = "*** ERROR: CGImageDestinationAddImage: cgImage is not a CGImageRef\n";
    v28 = 5053;
LABEL_64:
    LogError("CGImageDestinationAddImage", v28, v29);
    goto LABEL_65;
  }
  if (properties)
  {
    v32 = CFGetTypeID(properties);
    if (v32 != CFDictionaryGetTypeID())
      LogError("CGImageDestinationAddImage", 5056, "*** ERROR: CGImageDestinationAddImage: properties parameter is not a CFDictionaryRef - ignoring\n");
  }
  v33 = *((_QWORD *)idst + 3);
  if (v33)
  {
    IIOImageDestination::addImage(*((IIOImageDestination **)idst + 3), image, (IIODictionary *)v41, 1);
    v34 = *(IIO_Reader **)(v33 + 64);
    if (v34)
      IIO_Reader::osType(v34);
  }
LABEL_65:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v41);
}

void sub_187EB3168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28)
{
  IIONumber::~IIONumber((IIONumber *)&a25);
  IIODictionary::~IIODictionary((IIODictionary *)&a28);
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::addImage(IIOImageDestination *this, void *cf, IIODictionary *a3, int a4)
{
  CFTypeID v8;

  if (*((_QWORD *)this + 2))
  {
    if (*((_BYTE *)this + 225))
    {
      LogError("addImage", 2782, "*** ERROR: image destination was already finalized\n");
    }
    else if (*((_BYTE *)this + 224))
    {
      LogError("addImage", 2783, "*** ERROR: CGImageDestinationAddImage call is not allowed for this image destination (destination was updated with CGImageDestinationCopyImageSource)\n");
    }
    else if (cf)
    {
      v8 = CFGetTypeID(cf);
      if (v8 == CGImageGetTypeID())
      {
        IIOImageDestination::addImageInternal(this, (CGImage *)cf, a3, a4);
        return 0;
      }
      LogError("addImage", 2785, "*** ERROR: image parameter is not a CGImageRef\n");
    }
    else
    {
      LogError("addImage", 2784, "*** ERROR: image parameter is nil\n");
    }
  }
  else
  {
    LogError("addImage", 2781, "*** ERROR: cannot add image - invalid image destination\n");
  }
  return 4294967246;
}

uint64_t _ImageGetBitmapInfo(CGImage *a1)
{
  int AlphaInfo;

  AlphaInfo = _ImageGetAlphaInfo(a1);
  return CGImageGetBitmapInfo(a1) & 0xFFFFFFE0 | AlphaInfo;
}

CGImageRef IIOImageDestination::create1BitImage(IIOImageDestination *this, CGImageRef image, IIODictionary *a3, int a4)
{
  size_t BitsPerComponent;
  size_t v9;
  unsigned int v10;
  size_t Uint32ForKey;
  CGColorSpace *ColorSpace;
  CGImageRef v13;
  int Uint32ForKeyGroup;
  unsigned __int8 v16;
  _BYTE v17[24];
  _BYTE v18[24];

  BitsPerComponent = CGImageGetBitsPerComponent(image);
  v9 = BitsPerComponent;
  if (BitsPerComponent != 8 && BitsPerComponent != 1
    || (HEIFAuxImage::auxiliaryPixelFormat(*((HEIFAuxImage **)this + 8)) & 0x100) == 0)
  {
    return 0;
  }
  v10 = IIODictionary::containsKey(a3, CFSTR("Depth"));
  Uint32ForKey = v9;
  if (v10)
    Uint32ForKey = IIODictionary::getUint32ForKey(a3, CFSTR("Depth"));
  if (Uint32ForKey != 1)
    return 0;
  if (v9 == 8)
  {
    ColorSpace = CGImageGetColorSpace(image);
    if (CGColorSpaceGetModel(ColorSpace))
    {
      v13 = 0;
    }
    else
    {
      if (IIODictionary::containsKey(a3, CFSTR("kCGImagePropertyThreshold")))
        v16 = IIODictionary::getUint32ForKey(a3, CFSTR("kCGImagePropertyThreshold"));
      else
        v16 = 0x80;
      v13 = Create1BitImageFromImageRefWithOrientation(image, a4, v16);
      if (v13)
      {
        IIONumber::IIONumber((IIONumber *)v18, 1);
        IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v18, CFSTR("Orientation"));
        IIONumber::~IIONumber((IIONumber *)v18);
        *((_WORD *)this + 100) = 1;
      }
    }
  }
  else
  {
    v13 = CGImageRetain(image);
  }
  if (CFStringCompare(*((CFStringRef *)this + 9), CFSTR("public.tiff"), 0) == kCFCompareEqualTo)
  {
    Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(a3, CFSTR("Compression"), CFSTR("{TIFF}"));
    if ((Uint32ForKeyGroup - 3) >= 2)
    {
      _cg_jpeg_mem_term("create1BitImage", 2101, "*** {TIFF} dictionary does not contain compression information - using COMPRESSION_CCITTFAX4\n");
      Uint32ForKeyGroup = 4;
    }
    IIONumber::IIONumber((IIONumber *)v17, Uint32ForKeyGroup);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v17, CFSTR("Compression"), CFSTR("{TIFF}"));
    IIONumber::~IIONumber((IIONumber *)v17);
  }
  return v13;
}

void sub_187EB34DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::addImageInternal(IIOImageDestination *this, CGImage *a2, IIODictionary *a3, int a4)
{
  double Current;
  CGImage *v9;
  CGImage *v10;
  CGImageRef *v11;
  uint64_t v12;
  IIODictionary *v13;
  IIODictionary *v14;
  const __CFDictionary *v15;
  IIOImageDestination *v16;
  uint64_t v17;
  const __CFDictionary *ObjectForKey;
  CGColorRef v19;
  CFTypeID v20;
  CGColorSpace *v21;
  int v22;
  int v23;
  BOOL *v24;
  IIOImageDestination *v25;
  IIOImageDestination *v26;
  CGImage *v27;
  IIODictionary *v28;
  CFAbsoluteTime v29;
  int OptimizeForSharing;
  unsigned int Width;
  unsigned int Height;
  int v34;
  __CFDictionary *v35;
  __CFDictionary *v36;
  const __CFString *Property;
  const __CFNumber *v38;
  uint64_t AlphaInfo;
  BOOL v40;
  const void *PixelDataProviderConforming;
  CGImage *v42;
  double v43;
  CGImage *v44;
  CGImage *CGImageConforming;
  size_t v46;
  size_t v47;
  CGImage *v48;
  BOOL v49[31];
  BOOL v50;
  vImage_CGImageFormat components;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v50 = 0;
  if (CGImageGetMask())
  {
    v9 = IIOImageCreateWithImageAndMaskInterleaved(a2, 0);
    v10 = v9;
    if (v9)
      a2 = v9;
  }
  else
  {
    v10 = 0;
  }
  *((_QWORD *)this + 22) = 0;
  v11 = (CGImageRef *)((char *)this + 176);
  *((_WORD *)this + 100) = 1;
  *((_BYTE *)this + 221) = 0;
  *((_BYTE *)this + 214) = 0;
  v12 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = v12 + 1;
  *((_QWORD *)this + 7) = v12;
  v13 = (IIODictionary *)operator new();
  v14 = v13;
  if (a3)
  {
    v15 = (const __CFDictionary *)*((_QWORD *)a3 + 1);
    if (a4)
      v16 = IIODictionary::IIODictionary(v13, v15, 1);
    else
      v16 = IIODictionary::IIODictionary(v13, v15);
  }
  else
  {
    IIODictionary::IIODictionary(v13);
  }
  IIOImageDestination::cleanupDestinationProperties(v16, v14);
  IIOImageDestination::setImagePropertiesAtIndex(this, v14, *((_QWORD *)this + 7));
  v17 = HEIFAuxImage::auxiliaryPixelFormat(*((HEIFAuxImage **)this + 8));
  if (IIODictionary::containsKey(v14, CFSTR("kCGImageDestinationAllowAlpha")))
  {
    if (IIODictionary::getBoolForKey(v14, CFSTR("kCGImageDestinationAllowAlpha")))
      v17 = v17;
    else
      v17 = v17 & 0xE1FFFFFF;
  }
  ObjectForKey = IIODictionary::getObjectForKey(v14, CFSTR("kCGImageDestinationBackgroundColor"));
  if (ObjectForKey
    && (v19 = ObjectForKey, v20 = CFGetTypeID(ObjectForKey), v20 == CGColorGetTypeID())
    && CGColorGetAlpha(v19) == 1.0)
  {
    CFRetain(v19);
  }
  else
  {
    v21 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
    *(_OWORD *)&components.bitsPerComponent = xmmword_1882125C0;
    v19 = CGColorCreate(v21, (const CGFloat *)&components.bitsPerComponent);
    CFRelease(v21);
  }
  v22 = IIOGetExifOrientation(v14, 1u);
  *((_WORD *)this + 100) = v22;
  if (IIODictionary::getBoolForKey(v14, CFSTR("kCGImageSourceCreateThumbnailWithTransform")))
    v23 = 1;
  else
    v23 = IIO_Writer::canWriteExifOrientation(*((IIO_Writer **)this + 8)) ^ 1;
  IIOImageDestination::updateCompression((CFStringRef *)this, v14);
  *((_QWORD *)this + 22) = IIOImageDestination::create1BitImage(this, a2, v14, v22);
  if (CGImageIsMask(a2))
  {
    if (*v11)
    {
      CGImageRelease(*v11);
      *v11 = 0;
    }
    *((_QWORD *)this + 22) = CreateImageFromMask(a2);
  }
  IIOImageDestination::updateCreateHDRGainMapFlag(this, a2, v14);
  IIOImageDestination::updateCreateISOGainMapFlag(this, a2, v14);
  if (*((_BYTE *)this + 219) != 1)
  {
    if (*((_BYTE *)this + 220) == 1)
    {
      memset(&components, 0, 24);
      IIODictionary::IIODictionary((IIODictionary *)&components);
      if (!IIOImageDestination::createCreateSDRandISOGainMapFromHDR(v26, a2, (void **)v14, (CGImage **)this + 22, (IIODictionary *)&components))
      {
        IIOImageDestination::setSourceImageAtIndex(this, *((CGImageRef *)this + 22), *((_QWORD *)this + 7));
        IIOImageDestination::setPixelProviderAtIndex((uint64_t)this, (const void *)*MEMORY[0x1E0C9B0D0], *((_QWORD *)this + 7));
        *((_BYTE *)this + 226) = 1;
        IIOImageDestination::addAuxiliaryDataInfo(this, CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"), (const void **)&components);
      }
      goto LABEL_32;
    }
    OptimizeForSharing = IIOImageDestination::GetOptimizeForSharing(v14, 0, v24);
    *((_BYTE *)this + 221) = OptimizeForSharing;
    if (OptimizeForSharing)
    {
      if ((IIODictionary::containsKey(v14, CFSTR("kCGImageDestinationImageMaxPixelSize")) & 1) == 0)
      {
        Width = CGImageGetWidth(a2);
        Height = CGImageGetHeight(a2);
        if (Width <= Height)
          v34 = Height;
        else
          v34 = Width;
        IIONumber::IIONumber((IIONumber *)v49, v34);
        IIODictionary::setObjectForKey((uint64_t)v14, (uint64_t)v49, CFSTR("kCGImageDestinationImageMaxPixelSize"));
        IIONumber::~IIONumber((IIONumber *)v49);
      }
      v35 = IIODictionary::getObjectForKey(v14, CFSTR("{PNG}"));
      v36 = v35;
      if (v35)
      {
        CFDictionaryRemoveValue(v35, CFSTR("Gamma"));
        CFDictionaryRemoveValue(v36, CFSTR("Chromaticities"));
      }
    }
    Property = (const __CFString *)CGImageGetProperty();
    v38 = (const __CFNumber *)CGImageGetProperty();
    if (v38)
    {
      memset(&components, 0, 24);
      IIONumber::IIONumber((IIONumber *)&components, v38);
      *((_DWORD *)this + 49) = IIONumber::uint32Num((IIONumber *)&components);
      IIONumber::~IIONumber((IIONumber *)&components);
    }
    if (Property)
    {
      if (CFStringCompare(Property, CFSTR("public.avci"), 0) == kCFCompareEqualTo
        || CFStringCompare(Property, CFSTR("public.heic"), 0) == kCFCompareEqualTo
        || (AlphaInfo = CFStringCompare(Property, CFSTR("public.heics"), 0)) == 0)
      {
        AlphaInfo = CFStringCompare(*((CFStringRef *)this + 9), CFSTR("public.jpeg"), 0);
        if (!AlphaInfo)
        {
          AlphaInfo = CGImageGetAlphaInfo(a2);
          if (AlphaInfo <= 6 && ((1 << AlphaInfo) & 0x61) != 0)
            *((_BYTE *)this + 213) = 1;
        }
      }
      if (IIO_ReaderHandler::UseAppleJPEG((IIO_ReaderHandler *)AlphaInfo)
        && CFStringCompare(Property, CFSTR("public.jpeg"), 0) == kCFCompareEqualTo)
      {
        v40 = CFStringCompare(*((CFStringRef *)this + 9), CFSTR("public.jpeg"), 0) == kCFCompareEqualTo;
        goto LABEL_73;
      }
    }
    else
    {
      IIO_ReaderHandler::UseAppleJPEG(v38);
    }
    v40 = 0;
LABEL_73:
    if (*((_BYTE *)this + 218) == 1)
      v40 = 0;
    *((_BYTE *)this + 214) = v40;
    if (!*((_BYTE *)this + 213) || *((_BYTE *)this + 212))
    {
      IIOImageDestination::swapWriterIfNeeded((IIO_Writer **)this, a2, 0);
      v17 = HEIFAuxImage::auxiliaryPixelFormat(*((HEIFAuxImage **)this + 8));
    }
    if ((IIOImageDestination::handleDestinationImageMaxPixelSize(this, a2, v14, &v50) & 1) != 0)
    {
LABEL_79:
      if (v50)
      {
        PixelDataProviderConforming = 0;
      }
      else
      {
        if (*((_QWORD *)this + 22))
          v42 = (CGImage *)*((_QWORD *)this + 22);
        else
          v42 = a2;
        PixelDataProviderConforming = (const void *)IIOImageDestination::createPixelDataProviderConforming((uint64_t)this, v42, *((unsigned __int16 *)this + 100), v23, v19, v17, v14);
        if (!PixelDataProviderConforming)
        {
          *(_QWORD *)&v43 = _cg_jpeg_mem_term("addImageInternal", 2696, "*** createPixelDataProviderConforming failed (nil) _newImage=%p   cgImage=%p\n", *v11, a2).n128_u64[0];
          if ((gIIODebugFlags & 0x10000000000) != 0)
            ImageIOLog("CGImagePixelDataProviderCreateConforming returned NULL.\n\n", v43);
          v44 = *v11;
          if (!*v11)
          {
            CGImageConforming = IIOImageDestination::createCGImageConforming((uint64_t)this, a2, *((unsigned __int16 *)this + 100), v19, v17);
            *((_QWORD *)this + 22) = CGImageConforming;
            if (!CGImageConforming)
            {
              LogError("addImageInternal", 2703, "*** ERROR: image could not be converted to destination format.\n");
              goto LABEL_40;
            }
            CGImageSetProperty();
            v44 = *v11;
          }
          *(_QWORD *)&components.renderingIntent = 0;
          components.bitmapInfo = CGImageGetBitmapInfo(v44);
          components.bitsPerComponent = CGImageGetBitsPerComponent(*v11);
          components.bitsPerPixel = CGImageGetBitsPerPixel(*v11);
          components.colorSpace = CGImageGetColorSpace(*v11);
          components.decode = CGImageGetDecode(*v11);
          components.version = 0;
          components.renderingIntent = CGImageGetRenderingIntent(*v11);
          PixelDataProviderConforming = (const void *)CGImagePixelDataProviderCreate(*v11, &components, v19);
          if (!PixelDataProviderConforming)
            _cg_jpeg_mem_term("addImageInternal", 2717, "*** createPixelDataProviderConforming-fallback failed (nil)\n");
        }
      }
      goto LABEL_103;
    }
    if (*((_BYTE *)this + 213))
    {
      PixelDataProviderConforming = 0;
      *((_QWORD *)this + 21) = CGImageRetain(a2);
    }
    else
    {
      if (*((_BYTE *)this + 221))
      {
        if ((gIIODebugFlags & 0x8000300000) != 0)
          ImageIOLog("COL optimizeColorForSharing - full size image (kCGImageDestinationImageMaxPixelSize not specified)\n");
        _cg_jpeg_mem_term("addImageInternal", 2664, "    optimizeColorForSharing - full size image (kCGImageDestinationImageMaxPixelSize not specified)\n");
      }
      if (!*((_BYTE *)this + 214))
        goto LABEL_79;
      *((_BYTE *)this + 212) = 1;
      *((_DWORD *)this + 52) = 1;
      *((_QWORD *)this + 21) = CGImageRetain(a2);
      v46 = CGImageGetWidth(a2);
      if (v46 <= CGImageGetHeight(a2))
        v47 = CGImageGetHeight(a2);
      else
        v47 = CGImageGetWidth(a2);
      PixelDataProviderConforming = 0;
      *((_QWORD *)this + 23) = v47;
    }
LABEL_103:
    if (*((_QWORD *)this + 22))
      v48 = (CGImage *)*((_QWORD *)this + 22);
    else
      v48 = a2;
    IIOImageDestination::setSourceImageAtIndex(this, v48, *((_QWORD *)this + 7));
    IIOImageDestination::setPixelProviderAtIndex((uint64_t)this, PixelDataProviderConforming, *((_QWORD *)this + 7));
    if (PixelDataProviderConforming)
      CFRelease(PixelDataProviderConforming);
    goto LABEL_33;
  }
  memset(&components, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)&components);
  if (!IIOImageDestination::createCreateSDRandHDRGainMapFromHDR(v25, a2, (void **)v14, (CGImage **)this + 22, (IIODictionary *)&components))
  {
    IIOImageDestination::setSourceImageAtIndex(this, *((CGImageRef *)this + 22), *((_QWORD *)this + 7));
    IIOImageDestination::setPixelProviderAtIndex((uint64_t)this, (const void *)*MEMORY[0x1E0C9B0D0], *((_QWORD *)this + 7));
    *((_BYTE *)this + 226) = 1;
    IIOImageDestination::addAuxiliaryDataInfo(this, CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), (const void **)&components);
  }
LABEL_32:
  IIODictionary::~IIODictionary((IIODictionary *)&components);
LABEL_33:
  if (IIODictionary::getBoolForKey(v14, CFSTR("kCGImageMetadataShouldExcludeGPS")))
    IIODictionary::removeObjectForKey(v14, CFSTR("{GPS}"));
  if (CFStringCompare(*((CFStringRef *)this + 9), CFSTR("com.compuserve.gif"), 0))
  {
    if (CFStringCompare(*((CFStringRef *)this + 9), CFSTR("public.heics"), 0) == kCFCompareEqualTo)
      IIOImageDestination::handlePerFrameHEICSSaving(this, v27, v28);
  }
  else
  {
    IIOImageDestination::handlePerFrameGIFSaving(this, a2, v14);
  }
  *((_BYTE *)this + 226) = 1;
LABEL_40:
  if (v10)
    CGImageRelease(v10);
  if (v19)
    CGColorRelease(v19);
  if (*v11)
  {
    CGImageRelease(*v11);
    *v11 = 0;
  }
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    v29 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    IIOImageDestination::addImage - %g ms\n", (v29 - Current) * 1000.0);
  }
  return 0;
}

void sub_187EB3E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIOImageDestination::handleDestinationImageMaxPixelSize(IIOImageDestination *this, CGImage *a2, IIODictionary *a3, BOOL *a4)
{
  const __CFDictionary *v8;
  unsigned int v9;
  _BOOL4 v10;
  unsigned int v11;
  unint64_t Uint32ForKey;
  _BOOL4 v13;
  const char *v14;
  const char *v15;
  const char *v16;
  int v17;
  int v18;
  const char *v19;
  CGImage *v20;
  CGImage *ThumbNew;
  const void *v22;
  CGImage *ThumbnailAtIndex;
  CGImage *v24;
  size_t Width;
  size_t Height;
  CGImage *v27;
  _BYTE v29[16];
  void *value;
  uint64_t v31;
  CFDictionaryRef options;
  uint64_t v33;
  _BYTE v34[24];
  _BYTE v35[24];

  *a4 = 0;
  if ((gIIODebugFlags & 0x2000000000000) != 0)
    IIODebugOrientation("handleDestinationImageMaxPixelSize", 2121, a3);
  v8 = IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationImageMaxPixelSize"));
  if ((_DWORD)v8)
  {
    if (IIODictionary::getBoolForKey(a3, CFSTR("kCGImageSourceCreateThumbnailWithTransform")))
    {
      v9 = IIOGetExifOrientation(a3, 0);
      v10 = v9 > 1;
      if (v9 <= 1)
        v11 = 1;
      else
        v11 = v9;
    }
    else
    {
      v10 = 0;
      v11 = 1;
    }
    Uint32ForKey = IIODictionary::getUint32ForKey(a3, CFSTR("kCGImageDestinationImageMaxPixelSize"));
    if (*((_BYTE *)this + 214) && IIODictionary::containsKey(a3, CFSTR("IMAGEIO_USE_LIBJPEG")))
    {
      v13 = !IIODictionary::getBoolForKey(a3, CFSTR("IMAGEIO_USE_LIBJPEG"));
      if (!*((_BYTE *)this + 214))
        LOBYTE(v13) = 0;
      *((_BYTE *)this + 214) = v13;
    }
    if (*((_BYTE *)this + 213))
    {
      if ((gIIODebugFlags & 0x2000000000000) != 0)
      {
        v14 = "NO";
        if (v10)
          v14 = "YES";
        ImageIOLog("%s bakeInOrientation: _HEIC_to_JPEG %s\n", "-o- ", v14);
      }
      *((_QWORD *)this + 21) = CGImageRetain(a2);
      *((_QWORD *)this + 23) = Uint32ForKey;
      *a4 = 1;
    }
    else if (*((_BYTE *)this + 214))
    {
      if ((gIIODebugFlags & 0x2000000000000) != 0)
      {
        v15 = "NO";
        if (v10)
          v15 = "YES";
        ImageIOLog("%s bakeInOrientation: _useAppleJPEG_resize %s\n", "-o- ", v15);
      }
      *((_BYTE *)this + 212) = 1;
      *((_QWORD *)this + 21) = CGImageRetain(a2);
      *((_QWORD *)this + 23) = Uint32ForKey;
      *a4 = 1;
    }
    else
    {
      if ((gIIODebugFlags & 0x2000000000000) != 0)
      {
        v16 = "NO";
        if (v10)
          v16 = "YES";
        ImageIOLog("%s bakeInOrientation: default %s\n", "-o- ", v16);
      }
      if (IIODictionary::containsKey(a3, CFSTR("Depth")))
      {
        v17 = IIODictionary::getUint32ForKey(a3, CFSTR("Depth"));
        if (CFStringCompare(*((CFStringRef *)this + 9), CFSTR("public.jpeg"), 0) == kCFCompareEqualTo)
          v17 = -1;
      }
      else
      {
        v17 = -1;
      }
      v18 = 2 * *((unsigned __int8 *)this + 221);
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        if (*((_BYTE *)this + 221))
          v19 = "on";
        else
          v19 = "off";
        ImageIOLog("COL adding image [%p] with optimizeColorForSharing turned %s\n", a2, v19);
      }
      v20 = (CGImage *)*((_QWORD *)this + 22);
      if (v10)
      {
        if (v20)
        {
          CGImageRelease(v20);
          *((_QWORD *)this + 22) = 0;
        }
        ThumbNew = CGImageCreateThumbNew(a2, Uint32ForKey, v11, v17, v18);
        *((_QWORD *)this + 22) = ThumbNew;
        if (ThumbNew)
          *((_WORD *)this + 100) = 1;
        if ((gIIODebugFlags & 0x2000000000000) != 0)
          ImageIOLog("%s CGImageCreateThumbNew: maxPixelSize: %d  exifOrientation: %d\n", "-o- ", Uint32ForKey, v11);
        IIONumber::IIONumber((IIONumber *)v35, 1);
        IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v35, CFSTR("Orientation"));
        IIONumber::~IIONumber((IIONumber *)v35);
        IIONumber::IIONumber((IIONumber *)v34, 1);
        IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v34, CFSTR("Orientation"), CFSTR("{TIFF}"));
        IIONumber::~IIONumber((IIONumber *)v34);
      }
      else
      {
        if (v20)
        {
          CGImageRelease(v20);
          *((_QWORD *)this + 22) = 0;
        }
        if (!*((_QWORD *)this + 20))
          goto LABEL_59;
        v31 = 0;
        options = 0;
        v33 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v31);
        IIONumber::IIONumber((IIONumber *)v29, Uint32ForKey);
        IIODictionary::setObjectForKey((IIODictionary *)&v31, value, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
        IIONumber::~IIONumber((IIONumber *)v29);
        v22 = (const void *)*MEMORY[0x1E0C9AE50];
        IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent"));
        ThumbnailAtIndex = CGImageSourceCreateThumbnailAtIndex(*((CGImageSourceRef *)this + 20), *((_QWORD *)this + 7), options);
        v24 = ThumbnailAtIndex;
        if (ThumbnailAtIndex)
        {
          Width = CGImageGetWidth(ThumbnailAtIndex);
          Height = CGImageGetHeight(v24);
          if (Width >= Uint32ForKey
            || Height >= Uint32ForKey
            || (CGImageRelease(v24),
                IIODictionary::removeObjectForKey((IIODictionary *)&v31, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent")), IIODictionary::setObjectForKey((IIODictionary *)&v31, v22, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways")), (v24 = CGImageSourceCreateThumbnailAtIndex(*((CGImageSourceRef *)this + 20), *((_QWORD *)this + 7), options)) != 0))
          {
            if (*((_BYTE *)this + 221))
              v27 = CGImageCreateThumbNew(v24, Uint32ForKey, *((_DWORD *)this + 14), v17, v18);
            else
              v27 = CGImageRetain(v24);
            *((_QWORD *)this + 22) = v27;
            CGImageRelease(v24);
          }
        }
        IIODictionary::~IIODictionary((IIODictionary *)&v31);
        if (!*((_QWORD *)this + 22))
LABEL_59:
          *((_QWORD *)this + 22) = CGImageCreateThumbNew(a2, Uint32ForKey, 0, v17, v18);
      }
    }
  }
  return v8;
}

void sub_187EB4370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::createPixelDataProviderConforming(uint64_t a1, CGImageRef image, uint64_t a3, int a4, void *a5, uint64_t a6, IIODictionary *a7)
{
  const CGFloat *Decode;
  double Current;
  uint64_t v16;
  size_t BitsPerComponent;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  unsigned int Type;
  const __CFString *v21;
  unsigned int v22;
  unsigned int v23;
  CGBitmapInfo BitmapInfo;
  CGBitmapInfo v25;
  char *v26;
  unsigned int v27;
  int v28;
  _BOOL4 v29;
  int v30;
  int v31;
  const char *v32;
  unsigned int v33;
  int v34;
  _BOOL4 v36;
  _BOOL4 v37;
  int v38;
  CGColorSpace *v39;
  CGImage *CopyWithColorSpace;
  CGImage *v41;
  int v42;
  int v43;
  int v44;
  BOOL v45;
  int v46;
  _BOOL4 v47;
  int v48;
  int v49;
  int v50;
  BOOL v51;
  BOOL v52;
  int v53;
  _BOOL4 v55;
  _BOOL4 v57;
  int v60;
  _BOOL4 v61;
  int v62;
  int v63;
  _BOOL4 HasMask;
  BOOL v65;
  CGColorSpace *v66;
  size_t MinimalPixelSize;
  size_t v68;
  char v69;
  char v70;
  int v71;
  CGColor *v72;
  int v73;
  unsigned int v74;
  int v77;
  char v78;
  char v79;
  unsigned int v80;
  BOOL v81;
  int v82;
  int v83;
  char v84;
  int v85;
  CGColorSpace *v86;
  char v87;
  char v88;
  CFStringRef *v89;
  CGColorSpaceRef v90;
  int v91;
  size_t v92;
  const CGFloat *v93;
  char *v94;
  CFAbsoluteTime v95;
  unsigned int v97;
  int v98;
  BOOL v99;
  int v100;
  _BOOL4 v101;
  char v102;
  int v103;
  unsigned int v104;
  char v105;
  int EndianInfo;
  double *v107;
  size_t BitsPerPixel;
  void *v109;
  int v110;
  int IsFloat;
  int AlphaInfo;
  vImage_CGImageFormat v113;

  Decode = CGImageGetDecode(image);
  Current = CFAbsoluteTimeGetCurrent();
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("CGImageDestination - CGImagePixelDataProviderCreateConforming\n");
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      ImageIOLog("-------------------------------------------------------------\n");
      if ((gIIODebugFlags & 0x10000000000) != 0)
        ImageIOLog("           writerMode:  %s [0x%X]\n", IIO_WriterModeString(CGImagePluginWriteModes)::output, a6);
    }
  }
  memset(&v113, 0, sizeof(v113));
  if (a3 != 1 && a4)
  {
    if ((gIIODebugFlags & 0x2000000000000) != 0)
      ImageIOLog("*** ERROR: Orientation '%d' not handled - fallback to old CGImageCreateConforming.\n", a3);
    v16 = 0;
    goto LABEL_335;
  }
  v109 = a5;
  *(_QWORD *)&v113.bitmapInfo = _ImageGetBitmapInfo(image);
  v113.bitsPerComponent = (unsigned __int16)CGImageGetBitsPerComponent(image);
  v113.bitsPerPixel = (unsigned __int16)CGImageGetBitsPerPixel(image);
  v113.colorSpace = CGImageGetColorSpace(image);
  v113.decode = CGImageGetDecode(image);
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  BitsPerPixel = CGImageGetBitsPerPixel(image);
  ColorSpace = CGImageGetColorSpace(image);
  Model = CGColorSpaceGetModel(ColorSpace);
  Type = CGColorSpaceGetType();
  AlphaInfo = _ImageGetAlphaInfo(image);
  EndianInfo = _ImageGetEndianInfo(image);
  IsFloat = _ImageIsFloat(image);
  v21 = *(const __CFString **)(a1 + 72);
  v107 = (double *)Decode;
  if (v21)
    v101 = CFStringCompare(v21, CFSTR("public.tiff"), 0) == kCFCompareEqualTo;
  else
    v101 = 0;
  v16 = 0;
  if ((a6 & 0x7F000000) == 0 || (a6 & 0x1FF00) == 0 || !image || (a6 & 0x7F) == 0)
    goto LABEL_335;
  v22 = IIOImageDestination::adjustWriteModesForWriter(a1, a6, BitsPerComponent, Model, AlphaInfo, *(_DWORD *)(a1 + 40), ColorSpace, a7);
  v23 = v22;
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("       new writerMode:  %s [0x%X]\n", IIO_WriterModeString(CGImagePluginWriteModes)::output, v22);
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      BitmapInfo = CGImageGetBitmapInfo(image);
      v25 = CGImageGetBitmapInfo(image);
      v26 = IIO_BitmapInfoString(v25);
      ImageIOLog("     image bitmapInfo:  0x%X %s\n", BitmapInfo, v26);
    }
  }
  if (Type == 7)
  {
    ColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
    v27 = CGColorSpaceGetType();
    Model = CGColorSpaceGetModel(ColorSpace);
    v28 = 1;
    v29 = Model == kCGColorSpaceModelRGB;
    if (Model == kCGColorSpaceModelRGB)
    {
      v30 = 1;
      if ((v23 & 0x10) != 0)
        goto LABEL_33;
    }
  }
  else
  {
    LOBYTE(v28) = Model == kCGColorSpaceModelRGB;
    v29 = Model == kCGColorSpaceModelRGB;
    v27 = Type;
  }
  v31 = !v29;
  if (Type == 7)
    v31 = 1;
  if ((v23 & 1) == 0)
    v31 = 1;
  if (v31 != 1 || (v28 & 1) == 0)
  {
    v28 = v29;
    v30 = Model;
LABEL_33:
    v110 = 1;
    v29 = v28;
    Model = v30;
    goto LABEL_34;
  }
  v110 = 0;
LABEL_34:
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("            csIndexed: %d\n", Type == 7);
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      v32 = IIO_ColorModelString(Model);
      ImageIOLog("              csModel: %d = %s\n", Model, v32);
      if ((gIIODebugFlags & 0x10000000000) != 0)
        ImageIOLog("            indexedOK: %d\n", v110);
    }
  }
  v104 = Type;
  if (((Type == 7) & ((v23 & 0x10) >> 4)) != 0)
    v33 = v23 & 0xF9FFFFFF;
  else
    v33 = v23;
  v34 = (v23 & 0x11) == 0 || !v29;
  v36 = (v23 & 2) == 0 || Model != kCGColorSpaceModelCMYK;
  if (v34 == 1 && v36)
  {
    if (Model == kCGColorSpaceModelLab)
    {
      if ((v23 & 8) != 0)
        goto LABEL_55;
    }
    else if (Model == kCGColorSpaceModelMonochrome && (v23 & 0x24) != 0)
    {
      goto LABEL_55;
    }
    v38 = 0;
    goto LABEL_69;
  }
LABEL_55:
  v37 = CGColorSpaceUsesExtendedRange(ColorSpace);
  v38 = 1;
  if ((v37 & IsFloat) == 1 && (v33 & 0x10000) == 0 && (v33 & 0x8000) == 0)
  {
    if (v29)
    {
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL extended-sRGB --> P3\n");
      v16 = IIOImageDestination::createPixelDataProviderForExtendedRange(a1, image, &v113, v109, v33, a7);
      if (!v16)
        _cg_jpeg_mem_term("createPixelDataProviderConforming", 1080, "*** createPixelDataProviderForExtendedRange failed (nil)\n");
      goto LABEL_335;
    }
    if (Model == kCGColorSpaceModelMonochrome)
    {
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL extended-Gray --> gray\n");
      v38 = 1;
    }
  }
LABEL_69:
  if (!v38 && Model == kCGColorSpaceModelDeviceN && BitsPerComponent == 1 && (v33 & 0x100) != 0)
  {
    v39 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
    CopyWithColorSpace = CGImageCreateCopyWithColorSpace(image, v39);
    if (CopyWithColorSpace)
    {
      v41 = CopyWithColorSpace;
      v113.colorSpace = v39;
      v16 = CGImagePixelDataProviderCreate(CopyWithColorSpace, &v113, (CGColor *)v109);
      CGImageRelease(v41);
    }
    else
    {
      v16 = 0;
    }
LABEL_333:
    if (v39)
      CGColorSpaceRelease(v39);
    goto LABEL_335;
  }
  v102 = v38;
  if ((gIIODebugFlags & 0x10000000000) != 0)
    ImageIOLog("         spaceModelOK: %d\n", v38);
  if (v27 < 6 && ((0x27u >> v27) & 1) != 0)
    v42 = 1;
  else
    v42 = (v27 != 9) & (v33 >> 18);
  v105 = v42;
  if ((gIIODebugFlags & 0x10000000000) != 0)
    ImageIOLog("          spaceTypeOK: %d\n", v42);
  if (BitsPerComponent == 1 && (v33 & 0x100) != 0)
    goto LABEL_110;
  if (BitsPerComponent == 2 && (v33 & 0x200) != 0)
    goto LABEL_110;
  if (BitsPerComponent == 4 && (v33 & 0x400) != 0)
    goto LABEL_110;
  if (BitsPerComponent == 8 && (v33 & 0x800) != 0)
    goto LABEL_110;
  if (BitsPerComponent == 16 && (v33 & 0x1000) != 0)
    goto LABEL_110;
  if (BitsPerComponent == 16 && (v33 & 0x4000) != 0)
    goto LABEL_110;
  v43 = v33 & 0x10000;
  v44 = IsFloat ^ 1;
  if (BitsPerComponent == 16 && v43 && !v44)
    goto LABEL_110;
  v45 = (v33 & 0x2000) != 0 && BitsPerComponent == 32;
  v46 = v45 ? IsFloat ^ 1 : 1;
  if (v46 != 1)
    goto LABEL_110;
  v47 = BitsPerComponent != 32;
  v48 = v33 & 0x8000;
  if ((v33 & 0x8000) == 0)
    v47 = 1;
  if (((v47 | v44) & 1) == 0)
  {
LABEL_110:
    v43 = v33 & 0x10000;
    v48 = v33 & 0x8000;
    v49 = 1;
  }
  else
  {
    v49 = 0;
  }
  v50 = IsFloat ^ 1;
  if (v43)
    v50 = 1;
  v98 = v48;
  if (v48)
    v50 = 1;
  v103 = v49 & v50;
  if ((gIIODebugFlags & 0x10000000000) != 0
    && (ImageIOLog("          bitsPerComp: %zu\n", BitsPerComponent), (gIIODebugFlags & 0x10000000000) != 0))
  {
    ImageIOLog("              depthOK: %d\n", v103);
    v99 = ((1 << (AlphaInfo + 24)) & v33 & 0x7F000000) != 0;
    if ((gIIODebugFlags & 0x10000000000) != 0)
      ImageIOLog("              alphaOK: %d\n", ((1 << (AlphaInfo + 24)) & v33 & 0x7F000000) != 0);
  }
  else
  {
    v99 = ((1 << (AlphaInfo + 24)) & v33 & 0x7F000000) != 0;
  }
  v97 = v43;
  if (BitsPerComponent == 1 && !EndianInfo && (v33 & 0x100) != 0)
    goto LABEL_176;
  if (BitsPerComponent == 2 && !EndianInfo && (v33 & 0x200) != 0)
    goto LABEL_176;
  if (BitsPerComponent == 4 && !EndianInfo && (v33 & 0x400) != 0)
    goto LABEL_176;
  if (BitsPerComponent == 8 && !EndianInfo && (v33 & 0x800) != 0)
    goto LABEL_176;
  if (BitsPerComponent == 8 && EndianInfo == 0x2000 && (v33 & 0x800) != 0 && (v33 & 0x40) != 0)
    goto LABEL_176;
  v51 = BitsPerComponent != 16;
  if (BitsPerComponent == 16 && EndianInfo == 12288 && (v33 & 0x1000) != 0)
    goto LABEL_176;
  if (BitsPerComponent == 16 && !EndianInfo && (v33 & 0x1000) != 0)
    goto LABEL_176;
  if (EndianInfo != 4096)
    v51 = 1;
  if (!v51 && (v33 & 0x4000) != 0)
    goto LABEL_176;
  v52 = !v43 || v51;
  v53 = IsFloat ^ 1;
  if (!v52 && !v53)
    goto LABEL_176;
  v55 = BitsPerComponent != 32 || EndianInfo != 0x4000;
  if ((v33 & 0x2000) == 0)
    v55 = 1;
  if ((v55 | v53) != 1)
    goto LABEL_176;
  v57 = BitsPerComponent != 32 || EndianInfo != 0;
  if ((v33 & 0x2000) == 0)
    v57 = 1;
  if ((v57 | v53) != 1)
  {
LABEL_176:
    v60 = 1;
  }
  else if (BitsPerComponent != 32 || EndianInfo != 0x2000 || v98 == 0)
  {
    v60 = 0;
  }
  else
  {
    v60 = IsFloat;
  }
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("          bitsPerComp: %zd\n", BitsPerComponent);
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      ImageIOLog("           endianInfo: %d [0x%X]\n", EndianInfo, EndianInfo);
      if ((gIIODebugFlags & 0x10000000000) != 0)
        ImageIOLog("             endianOK: %d\n", v60);
    }
  }
  if (v107)
  {
    v61 = *v107 == 1.0 && v107[1] == 0.0;
    if (*v107 == 0.0)
    {
      v62 = v107[1] == 1.0;
      if (Model)
        goto LABEL_194;
    }
    else
    {
      v62 = 0;
      if (Model)
        goto LABEL_194;
    }
  }
  else
  {
    v61 = 0;
    v62 = 1;
    if (Model)
      goto LABEL_194;
  }
  v63 = v61 & (v23 >> 5);
  if (BitsPerComponent == 1)
    v63 = 1;
  v62 = v63 | v62 & (v23 >> 2);
LABEL_194:
  if ((gIIODebugFlags & 0x10000000000) != 0)
    ImageIOLog("             decodeOK: %d\n", v62);
  v100 = v62;
  HasMask = _ImageHasMask();
  v65 = HasMask;
  if ((gIIODebugFlags & 0x10000000000) != 0)
    ImageIOLog("               maskOK: %d\n", !HasMask);
  v66 = CGImageGetColorSpace(image);
  MinimalPixelSize = _GetMinimalPixelSize(v66, BitsPerComponent, AlphaInfo);
  v68 = MinimalPixelSize;
  if ((gIIODebugFlags & 0x10000000000) != 0)
    ImageIOLog("                bppOK: %d\n", BitsPerPixel == MinimalPixelSize);
  v69 = IIO_CGImageWrapsIOSurface((uint64_t)image, 1);
  v70 = v103 & v105 & v110 & v102 & v100 & !v65 & v99 & v60;
  if (BitsPerPixel != v68)
    v70 = 0;
  if ((v70 & 1) == 0 && (*(_DWORD *)&v69 & ((v33 & 0x80000) >> 19)) == 0)
  {
    if (_ImageIsOpaque(image))
    {
      if ((v33 & 0x40000000) != 0)
      {
        v72 = 0;
        v73 = 6;
        v71 = v98;
      }
      else
      {
        v71 = v98;
        v72 = 0;
        if ((v33 & 0x20000000) != 0)
        {
          v73 = 5;
        }
        else if ((v33 & 0x1000000) != 0)
        {
          v73 = 0;
        }
        else if ((v33 & 0x8000000) != 0)
        {
          v73 = 3;
        }
        else if ((v33 & 0x10000000) != 0)
        {
          v73 = 4;
        }
        else if ((v33 & 0x2000000) != 0)
        {
          v73 = 1;
        }
        else if ((v33 & 0x4000000) != 0)
        {
          v73 = 2;
        }
        else
        {
          v73 = 0x1000000;
        }
      }
LABEL_243:
      if ((v33 & 0x1000000) != 0 && (v73 - 7) >= 0xFFFFFFFE && Model == kCGColorSpaceModelCMYK)
        v77 = 0;
      else
        v77 = v73;
      v78 = v102;
      if ((v103 & 1) == 0)
      {
        if ((v33 & 0x1FF00) == 0x2000)
          goto LABEL_257;
        v79 = IsFloat;
        if ((v33 & 0xA000) == 0)
          v79 = 0;
        if ((v79 & 1) != 0)
        {
LABEL_257:
          BitsPerComponent = 32;
        }
        else if (v97 && IsFloat == 1 || BitsPerComponent >= 9 && (v33 & 0x5000) != 0)
        {
          BitsPerComponent = 16;
        }
        else
        {
          v91 = (v33 >> 11) & 1;
          if ((v33 & 0x15000) == 0)
            v91 = 1;
          if (v91)
            BitsPerComponent = 8;
          else
            BitsPerComponent = 16;
          v78 = v102;
        }
      }
      if ((v60 & 1) == 0)
      {
        if (BitsPerComponent == 16 && (v33 & 0x14000) != 0)
        {
          v80 = v77 | 0x1000;
          goto LABEL_275;
        }
        v81 = BitsPerComponent != 32 || v71 == 0;
        v82 = IsFloat ^ 1;
        if (v81)
          v82 = 1;
        if (v82)
          v83 = 0;
        else
          v83 = 0x2000;
        EndianInfo = v83;
      }
      v80 = EndianInfo | v77;
      if (BitsPerComponent != 16)
      {
        if (BitsPerComponent == 32)
          v80 |= 0x100u;
LABEL_279:
        v84 = v78 ^ 1 | v105 ^ 1;
        v85 = v110;
        if (v104 != 7)
          v85 = 0;
        if ((v84 & 1) == 0 && v85)
        {
          v86 = CGImageGetColorSpace(image);
LABEL_291:
          v90 = CGColorSpaceRetain(v86);
LABEL_323:
          v39 = v90;
          goto LABEL_324;
        }
        if ((v84 & 1) == 0)
        {
          v86 = ColorSpace;
          goto LABEL_291;
        }
        v87 = v102 ^ 1;
        if (Model == kCGColorSpaceModelCMYK)
          v88 = v102 ^ 1;
        else
          v88 = 1;
        if ((v88 & 1) == 0)
        {
LABEL_289:
          v89 = (CFStringRef *)MEMORY[0x1E0C9D968];
LABEL_322:
          v90 = CGColorSpaceCreateWithName(*v89);
          goto LABEL_323;
        }
        if (Model)
          v87 = 1;
        if ((v87 & 1) != 0)
        {
          if ((v23 & 1) != 0 && (v80 & 0x100) != 0)
          {
            v89 = (CFStringRef *)MEMORY[0x1E0C9D958];
            goto LABEL_322;
          }
          if ((v23 & 1) != 0)
          {
            v89 = (CFStringRef *)MEMORY[0x1E0C9DA10];
            goto LABEL_322;
          }
          if ((v23 & 2) != 0)
            goto LABEL_289;
          if ((v23 & 4) == 0)
          {
            v39 = 0;
LABEL_324:
            v92 = _GetMinimalPixelSize(v39, BitsPerComponent, v77);
            v113.bitsPerComponent = BitsPerComponent;
            v113.bitsPerPixel = v92;
            v113.colorSpace = v39;
            *(_QWORD *)&v113.bitmapInfo = v80;
            v93 = v107;
            if (!v100)
              v93 = 0;
            v113.decode = v93;
            if ((gIIODebugFlags & 0x10000000000) != 0)
            {
              ImageIOLog("CGImagePixelDataProviderCreate\n");
              if ((gIIODebugFlags & 0x10000000000) != 0)
              {
                v94 = IIO_BitmapInfoString(v80);
                ImageIOLog("        newBitmapInfo: %d  %s\n", v80, v94);
                if ((gIIODebugFlags & 0x10000000000) != 0)
                {
                  ImageIOLog("    newbits/Component: %d\n", BitsPerComponent);
                  if ((gIIODebugFlags & 0x10000000000) != 0)
                    ImageIOLog("        newbits/Pixel: %zd\n", v92);
                }
              }
            }
            v16 = CGImagePixelDataProviderCreate(image, &v113, v72);
            if (!v16)
              _cg_jpeg_mem_term("createPixelDataProviderConforming", 1433, "*** CGImagePixelDataProviderCreate failed (nil)\n");
            goto LABEL_333;
          }
        }
        v89 = (CFStringRef *)MEMORY[0x1E0C9D978];
        goto LABEL_322;
      }
LABEL_275:
      if (IsFloat)
      {
        v80 |= v97 >> 8;
      }
      else if ((v33 & 0x5000) == 0)
      {
        v80 |= 0x100u;
      }
      goto LABEL_279;
    }
    v74 = AlphaInfo - 1;
    if ((v33 & 0x2000000) != 0 && (v74 < 2 || v101 && (gIIODebugFlags & 0x800000000) == 0))
    {
      v73 = 1;
    }
    else if ((v33 & 0x4000000) != 0 && (v74 < 2 || v101 && (gIIODebugFlags & 0x800000000) == 0))
    {
      v73 = 2;
    }
    else
    {
      if ((v33 & 0x8000000) == 0)
      {
        if ((v33 & 0x10000000) != 0)
          v73 = 4;
        else
          v73 = 1;
        if ((v33 & 0x12000000) == 0)
          v73 = 2;
        v71 = v98;
        if ((v33 & 0x16000000) == 0)
        {
          if ((v33 & 0x40000000) != 0)
            v73 = 6;
          else
            v73 = ((int)(4 * v33) >> 31) & 5;
        }
        goto LABEL_240;
      }
      v73 = 3;
    }
    v71 = v98;
LABEL_240:
    if ((v33 & 0x1E000000) != 0)
      v72 = 0;
    else
      v72 = (CGColor *)v109;
    goto LABEL_243;
  }
  v16 = CGImagePixelDataProviderCreate(image, &v113, (CGColor *)v109);
  if (!v16)
    _cg_jpeg_mem_term("createPixelDataProviderConforming", 1272, "*** CGImagePixelDataProviderCreate (orig image) failed (nil)\n");
LABEL_335:
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    v95 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    IIOImageDestination::createPixelDataProviderConforming - %g ms\n", (v95 - Current) * 1000.0);
  }
  return v16;
}

size_t _GetMinimalPixelSize(CGColorSpace *a1, uint64_t a2, int a3)
{
  size_t NumberOfComponents;
  size_t v6;

  NumberOfComponents = CGColorSpaceGetNumberOfComponents(a1);
  if (a3)
    v6 = NumberOfComponents + 1;
  else
    v6 = NumberOfComponents;
  return v6 * a2;
}

BOOL _ImageIsOpaque(CGImage *a1)
{
  int AlphaInfo;

  if (_ImageHasMask())
    return 0;
  AlphaInfo = _ImageGetAlphaInfo(a1);
  return AlphaInfo != 7 && (AlphaInfo - 5) < 0xFFFFFFFC;
}

uint64_t _ImageGetAlphaInfo(CGImage *a1)
{
  CGImageAlphaInfo AlphaInfo;
  size_t BitsPerPixel;
  CGColorSpace *ColorSpace;
  size_t NumberOfComponents;
  size_t v6;
  CGImageAlphaInfo v7;
  BOOL v8;

  AlphaInfo = CGImageGetAlphaInfo(a1);
  BitsPerPixel = CGImageGetBitsPerPixel(a1);
  ColorSpace = CGImageGetColorSpace(a1);
  if (ColorSpace)
    NumberOfComponents = CGColorSpaceGetNumberOfComponents(ColorSpace);
  else
    NumberOfComponents = 0;
  v6 = CGImageGetBitsPerComponent(a1) * NumberOfComponents;
  if (BitsPerPixel == v6)
    v7 = kCGImageAlphaNone;
  else
    v7 = AlphaInfo;
  if (v7)
    v8 = 0;
  else
    v8 = BitsPerPixel > v6;
  if (v8)
    return 5;
  else
    return v7;
}

BOOL _ImageHasMask()
{
  return CGImageGetClipPath() || CGImageGetMask() || CGImageGetMaskingColors() != 0;
}

void IIOImageDestination::cleanupDestinationProperties(IIOImageDestination *this, IIODictionary *a2)
{
  const __CFDictionary *ObjectForKey;

  if (IIODictionary::containsKey(a2, CFSTR("HasAlpha")))
  {
    ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("HasAlpha"));
    IIODictionary::setObjectForKey(a2, ObjectForKey, CFSTR("kCGImageDestinationAllowAlpha"));
    IIODictionary::removeObjectForKey(a2, CFSTR("HasAlpha"));
  }
}

__n128 IIOImageDestination::setImagePropertiesAtIndex(IIOImageDestination *this, IIODictionary *a2, unsigned int a3)
{
  _BYTE *v4;
  void **v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __n128 result;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;

  v4 = (_BYTE *)*((_QWORD *)this + 16);
  v6 = (char *)*((_QWORD *)this + 17);
  v5 = (void **)((char *)this + 128);
  v7 = v6 - v4;
  if (a3 >= ((unint64_t)(v6 - v4) >> 3))
  {
    v11 = *((_DWORD *)this + 12);
    if (a3 >= v11)
    {
      return _cg_jpeg_mem_term("setImagePropertiesAtIndex", 4268, "setImagePropertiesAtIndex index (%d) larger than vectorCount (%d) and image count (%d\n", a3, (unint64_t)(v6 - v4) >> 3, v11);
    }
    else
    {
      v12 = a3;
      v13 = v7 >> 3;
      if (v7 >> 3 <= (unint64_t)a3)
      {
        v15 = (_QWORD *)((char *)this + 144);
        do
        {
          if ((unint64_t)v6 >= *v15)
          {
            if ((v13 + 1) >> 61)
              std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
            v16 = *v15 - (_QWORD)v4;
            v17 = v16 >> 2;
            if (v16 >> 2 <= v13 + 1)
              v17 = v13 + 1;
            if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
              v18 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v18 = v17;
            if (v18)
              v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v15, v18);
            else
              v19 = 0;
            v20 = &v19[8 * v13];
            *(_QWORD *)v20 = 0;
            v6 = v20 + 8;
            v22 = (char *)*((_QWORD *)this + 16);
            v21 = (char *)*((_QWORD *)this + 17);
            if (v21 != v22)
            {
              do
              {
                v23 = *((_QWORD *)v21 - 1);
                v21 -= 8;
                *((_QWORD *)v20 - 1) = v23;
                v20 -= 8;
              }
              while (v21 != v22);
              v21 = (char *)*v5;
            }
            *((_QWORD *)this + 16) = v20;
            *((_QWORD *)this + 17) = v6;
            *((_QWORD *)this + 18) = &v19[8 * v18];
            if (v21)
              operator delete(v21);
          }
          else
          {
            *(_QWORD *)v6 = 0;
            v6 += 8;
          }
          *((_QWORD *)this + 17) = v6;
          v4 = (_BYTE *)*((_QWORD *)this + 16);
          v13 = (v6 - v4) >> 3;
        }
        while (v13 <= v12);
      }
      *(_QWORD *)&v4[8 * v12] = a2;
    }
  }
  else
  {
    v8 = a3;
    v9 = *(_QWORD *)&v4[8 * a3];
    if (v9)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
      v4 = *v5;
    }
    *(_QWORD *)&v4[8 * v8] = a2;
  }
  return result;
}

uint64_t IIOImageDestination::adjustWriteModesForWriter(uint64_t a1, uint64_t a2, int a3, int a4, int a5, unsigned int a6, CGColorSpace *a7, IIODictionary *this)
{
  uint64_t v16;
  const __CFString *v17;
  uint64_t Uint32ForKey;
  BOOL v19;
  unsigned int v22;
  int v23;
  unsigned int v24;
  IIODictionary *v26;
  IIODictionary *v27;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v29;
  __CFString **v30;
  _BOOL4 v32;
  IIO_WriterHandler *WriterHandler;
  IIODictionary *v34;
  IIO_Reader *WriterForType;
  const __CFString *v36;
  CGColorSpace *v37;

  if (!*(_QWORD *)(a1 + 64) || !*(_QWORD *)(a1 + 72))
    return 0;
  v16 = a2;
  if (this)
  {
    v16 = a2;
    if (IIODictionary::containsKey(this, CFSTR("kCGImageDestinationAllowAlpha")))
    {
      if (IIODictionary::getBoolForKey(this, CFSTR("kCGImageDestinationAllowAlpha")))
        v16 = a2;
      else
        v16 = a2 & 0xE1FFFFFF;
    }
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 72), CFSTR("public.png"), 0) == kCFCompareEqualTo)
  {
    if (a3 > 7)
      goto LABEL_42;
    if (a4 == 5)
    {
      if ((a5 - 1) > 3)
        goto LABEL_42;
    }
    else if (!a4 && (a5 - 1) >= 4)
    {
      goto LABEL_42;
    }
    LODWORD(v16) = v16 & 0xFFFFF8FF;
LABEL_42:
    if (a6 <= 1)
      v16 = v16;
    else
      v16 = v16 & 0xFFFFBFFF;
    goto LABEL_45;
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 72), CFSTR("public.heic"), 0) == kCFCompareEqualTo)
  {
    if (a5)
      v19 = 0;
    else
      v19 = a3 == 16;
    if (v19 && a4 == 1)
      v16 = v16 & 0xFFFEAFFF;
    else
      v16 = v16;
    goto LABEL_45;
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 72), CFSTR("public.jpeg"), 0) == kCFCompareEqualTo)
  {
    if (((a4 == 0) & (a2 >> 2)) != 0)
      v16 = v16 & 0x9FFFFFFF;
    else
      v16 = v16;
    goto LABEL_45;
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 72), CFSTR("com.microsoft.bmp"), 0) == kCFCompareEqualTo)
  {
    if (a4 != 5 || a3 == 8)
      v16 = v16;
    else
      v16 = v16 & 0xFFFFFFEF;
    goto LABEL_45;
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 72), CFSTR("com.apple.atx"), 0) == kCFCompareEqualTo)
  {
    v26 = *(IIODictionary **)(a1 + 88);
    if (v26 && IIODictionary::containsKey(v26, CFSTR("kCGImagePropertyEncoder")))
    {
      v27 = *(IIODictionary **)(a1 + 88);
    }
    else
    {
      if (!this)
        goto LABEL_60;
      if (!IIODictionary::containsKey(this, CFSTR("kCGImagePropertyEncoder")))
        goto LABEL_46;
      v27 = this;
    }
    ObjectForKey = IIODictionary::getObjectForKey(v27, CFSTR("kCGImagePropertyEncoder"));
    if (ObjectForKey)
    {
      if (CFEqual(ObjectForKey, CFSTR("kCGImageProperty420fEncoder")))
        v16 = v16 & 0xF4FFFFFF;
      else
        v16 = v16;
    }
LABEL_45:
    if (!this)
      goto LABEL_60;
    goto LABEL_46;
  }
  v17 = CFSTR("org.khronos.ktx");
  Uint32ForKey = CFStringCompare(*(CFStringRef *)(a1 + 72), CFSTR("org.khronos.ktx"), 0);
  if (!Uint32ForKey)
  {
    if (!this)
      goto LABEL_93;
    if (IIODictionary::containsKey(this, CFSTR("kCGImagePropertyEncoder")))
    {
      v29 = IIODictionary::getObjectForKey(this, CFSTR("kCGImagePropertyEncoder"));
      if (CFEqual(v29, CFSTR("kCGImagePropertyPVREncoder")))
      {
        v30 = kCGImageTypeIdentifierPVR;
LABEL_85:
        v17 = *v30;
        goto LABEL_86;
      }
      if (CFEqual(v29, CFSTR("kCGImagePropertyBCEncoder")))
      {
        v30 = kCGImageTypeIdentifierBC;
        goto LABEL_85;
      }
      if (CFEqual(v29, CFSTR("kCGImagePropertyASTCEncoder")))
        v17 = CFSTR("org.khronos.astc");
    }
LABEL_86:
    Uint32ForKey = (uint64_t)IIODictionary::containsKey(this, CFSTR("kCGImagePropertyBCFormat"));
    if ((_DWORD)Uint32ForKey)
    {
      Uint32ForKey = (uint64_t)IIODictionary::getUint32ForKey(this, CFSTR("kCGImagePropertyBCFormat"));
      v32 = (Uint32ForKey & 0xFFFFFFFD) != 0x8DBC && (Uint32ForKey - 36496) < 0xFFFFFFFE;
      goto LABEL_94;
    }
LABEL_93:
    v32 = 0;
LABEL_94:
    WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler((IIO_WriterHandler *)Uint32ForKey);
    WriterForType = IIO_WriterHandler::findWriterForType(WriterHandler, v17, (const __CFString *)1, this, v34);
    if (WriterForType)
      LODWORD(v16) = HEIFAuxImage::auxiliaryPixelFormat(WriterForType);
    if (v32)
      v16 = v16 & 0xFFFE7FFF;
    else
      v16 = v16;
    if (a7)
    {
      switch(a4)
      {
        case 2:
          v16 = v16 & 0xFFFBFFFF;
          break;
        case 1:
          if (!IIO_CGColorSpaceNameMatchesName(a7, (const __CFString *)*MEMORY[0x1E0C9DA10])
            && !IIO_CGColorSpaceNameMatchesName(a7, (const __CFString *)*MEMORY[0x1E0C9D908]))
          {
            v36 = (const __CFString *)*MEMORY[0x1E0C9D8F8];
            v37 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D8F8]);
            if (IIO_CGColorSpaceNameMatchesName(a7, v36))
              v16 = v16;
            else
              v16 = v16 & 0xFFFBFFFF;
            CGColorSpaceRelease(v37);
          }
          break;
        case 0:
          if (IIO_CGColorSpaceNameMatchesName(a7, (const __CFString *)*MEMORY[0x1E0C9D978]))
            v16 = v16;
          else
            v16 = v16 & 0xFFFBFFFF;
          break;
      }
    }
    goto LABEL_45;
  }
  if (CFStringCompare(*(CFStringRef *)(a1 + 72), CFSTR("com.compuserve.gif"), 0))
  {
    CFStringCompare(*(CFStringRef *)(a1 + 72), CFSTR("com.apple.icns"), 0);
    goto LABEL_45;
  }
  if (!this)
    goto LABEL_60;
  if (IIODictionary::containsKeyGroup(this, CFSTR("ImageColorMap"), CFSTR("{GIF}")))
    v16 = v16 | 0x1000000;
  else
    v16 = v16;
LABEL_46:
  if (!IIODictionary::containsKey(this, CFSTR("Depth")))
    goto LABEL_60;
  v22 = IIODictionary::getUint32ForKey(this, CFSTR("Depth"));
  switch(v22)
  {
    case 8u:
      if ((a2 & 0x800) == 0)
        goto LABEL_60;
LABEL_55:
      v24 = v16 & 0xFFFF5FFF;
      if (v22 >= 0x11)
        v24 = v16;
      if (v22 >= 9)
        v16 = v24;
      else
        v16 = v24 & 0xFFFEAFFF;
      goto LABEL_60;
    case 0x20u:
      v23 = 40960;
      break;
    case 0x10u:
      v23 = 86016;
      break;
    default:
      goto LABEL_60;
  }
  if ((a2 & v23) != 0)
    goto LABEL_55;
LABEL_60:
  if ((_DWORD)v16 == (_DWORD)a2)
    return a2;
  if ((gIIODebugFlags & 0x10000000000) != 0)
    ImageIOLog("        adjusted mode: 0x%X  ->  0x%X\n", a2, v16);
  return v16;
}

void sub_187EB5A54(_Unwind_Exception *a1)
{
  CGColorSpace *v1;

  CGColorSpaceRelease(v1);
  _Unwind_Resume(a1);
}

__n128 IIOImageDestination::setPixelProviderAtIndex(uint64_t a1, const void *a2, CFIndex a3)
{
  unsigned int Count;
  const void *v7;
  __n128 result;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 96));
  v7 = (const void *)*MEMORY[0x1E0C9B0D0];
  if (!a2)
    a2 = (const void *)*MEMORY[0x1E0C9B0D0];
  if (a3 < Count)
    goto LABEL_4;
  if (*(_QWORD *)(a1 + 48) > a3)
  {
    while (CFArrayGetCount(*(CFArrayRef *)(a1 + 96)) <= a3)
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 96), v7);
LABEL_4:
    CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 96), a3, a2);
    return result;
  }
  return _cg_jpeg_mem_term("setPixelProviderAtIndex", 4186, "setImageMedadataAtIndex index (%d) larger than arrayCount (%d) and image count (%d)\n", a3, Count, *(_QWORD *)(a1 + 48));
}

__n128 IIOImageDestination::setSourceImageAtIndex(IIOImageDestination *this, CGImageRef image, uint64_t a3)
{
  uint64_t v4;
  void **v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  CGImage *v9;
  __n128 result;
  unsigned int v11;
  unint64_t v12;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v4 = *((_QWORD *)this + 13);
  v6 = (_QWORD *)*((_QWORD *)this + 14);
  v5 = (void **)((char *)this + 104);
  v7 = ((uint64_t)v6 - v4) >> 3;
  if (a3 >= v7)
  {
    v11 = *((_DWORD *)this + 12);
    if (a3 >= v11)
    {
      return _cg_jpeg_mem_term("setSourceImageAtIndex", 4227, "setSourceImageAtIndex index (%d) larger than vectorCount (%d) and image count (%d\n", a3, ((uint64_t)v6 - v4) >> 3, v11);
    }
    else
    {
      v12 = a3;
      if (v7 <= a3)
      {
        v14 = (_QWORD *)((char *)this + 120);
        do
        {
          if ((unint64_t)v6 >= *v14)
          {
            if ((v7 + 1) >> 61)
              std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
            v15 = *v14 - v4;
            v16 = v15 >> 2;
            if (v15 >> 2 <= v7 + 1)
              v16 = v7 + 1;
            if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
              v17 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v17 = v16;
            if (v17)
              v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v14, v17);
            else
              v18 = 0;
            v19 = &v18[8 * v7];
            *(_QWORD *)v19 = 0;
            v6 = v19 + 8;
            v21 = (char *)*((_QWORD *)this + 13);
            v20 = (char *)*((_QWORD *)this + 14);
            if (v20 != v21)
            {
              do
              {
                v22 = *((_QWORD *)v20 - 1);
                v20 -= 8;
                *((_QWORD *)v19 - 1) = v22;
                v19 -= 8;
              }
              while (v20 != v21);
              v20 = (char *)*v5;
            }
            *((_QWORD *)this + 13) = v19;
            *((_QWORD *)this + 14) = v6;
            *((_QWORD *)this + 15) = &v18[8 * v17];
            if (v20)
              operator delete(v20);
          }
          else
          {
            *v6++ = 0;
          }
          *((_QWORD *)this + 14) = v6;
          v4 = *((_QWORD *)this + 13);
          v7 = ((uint64_t)v6 - v4) >> 3;
        }
        while (v7 <= v12);
      }
      *((_QWORD *)*v5 + v12) = CGImageRetain(image);
    }
  }
  else
  {
    v8 = a3;
    v9 = *(CGImage **)(v4 + 8 * a3);
    if (v9)
      CGImageRelease(v9);
    *((_QWORD *)*v5 + v8) = CGImageRetain(image);
  }
  return result;
}

uint64_t IIOImageDestination::GetOptimizeForSharing(IIOImageDestination *this, IIODictionary *a2, BOOL *a3)
{
  uint64_t result;
  const __CFString *ObjectForKey;
  CFTypeID v7;
  CFTypeID v8;
  CFComparisonResult v9;

  if (a2)
    *(_BYTE *)a2 = 0;
  if (!this)
    return 0;
  result = (uint64_t)IIODictionary::containsKey(this, CFSTR("kCGImageDestinationOptimizeColorForSharing"));
  if (!(_DWORD)result)
    return result;
  ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(this, CFSTR("kCGImageDestinationOptimizeColorForSharing"));
  v7 = CFGetTypeID(ObjectForKey);
  if (v7 == CFBooleanGetTypeID())
    return ObjectForKey == (const __CFString *)*MEMORY[0x1E0C9AE50];
  v8 = CFGetTypeID(ObjectForKey);
  if (v8 != CFStringGetTypeID())
    return 0;
  v9 = CFStringCompare(ObjectForKey, CFSTR("sRGB"), 0);
  result = v9 == kCFCompareEqualTo;
  if (a2)
  {
    if (v9 == kCFCompareEqualTo)
    {
      result = 1;
      *(_BYTE *)a2 = 1;
    }
  }
  return result;
}

uint64_t IIOImageDestination::swapWriterIfNeeded(IIO_Writer **this, CGImage *a2, int a3)
{
  const __CFString *v6;
  uint64_t result;
  IIO_WriterHandler *v8;
  int v9;
  CGImageAlphaInfo AlphaInfo;
  CGColorSpace *ColorSpace;

  v6 = (const __CFString *)IIO_Writer::utType(this[8]);
  result = CFStringCompare(v6, CFSTR("public.jpeg"), 0);
  if (result)
    return result;
  result = IIO_WriterHandler::GetWriterHandler(0);
  v8 = (IIO_WriterHandler *)result;
  if (a3)
  {
    result = (uint64_t)IIO_WriterHandler::findWriterForTypeAndAlternateType((IIO_WriterHandler *)result, CFSTR("public.heic"), CFSTR("public.jpeg"), 1, 0);
    if (!result)
      return result;
    *((_WORD *)this + 106) = 256;
    if (*((_DWORD *)this + 52) == 5)
      v9 = 6;
    else
      v9 = 4;
    *((_DWORD *)this + 52) = v9;
LABEL_9:
    this[8] = (IIO_Writer *)result;
    return result;
  }
  if (a2)
  {
    AlphaInfo = CGImageGetAlphaInfo(a2);
    ColorSpace = CGImageGetColorSpace(a2);
    result = CGColorSpaceGetModel(ColorSpace);
    if (AlphaInfo != kCGImageAlphaNoneSkipLast || (_DWORD)result)
    {
      result = IIO_CGImageWrapsIOSurface((uint64_t)a2, 1);
      if ((_DWORD)result)
      {
        result = (uint64_t)IIO_WriterHandler::findWriterForTypeAndAlternateType(v8, CFSTR("public.heic"), CFSTR("public.jpeg"), 1, 0);
        if (result)
          goto LABEL_9;
      }
    }
  }
  return result;
}

void IIOImageDestination::updateCompression(CFStringRef *this, IIODictionary *a2)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v5;
  uint64_t v6;
  void *value;
  uint64_t v8;

  if (CFStringCompare(this[9], CFSTR("public.tiff"), 0) == kCFCompareEqualTo)
  {
    if ((IIODictionary::containsKey(a2, CFSTR("{TIFF}")) & 1) == 0)
    {
      v6 = 0;
      value = 0;
      v8 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v6);
      IIODictionary::setObjectForKey(a2, value, CFSTR("{TIFF}"));
      IIODictionary::~IIODictionary((IIODictionary *)&v6);
    }
    if (IIODictionary::containsKey(a2, CFSTR("Compression")))
    {
      ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("Compression"));
      IIODictionary::setObjectForKeyGroup(a2, ObjectForKey, CFSTR("Compression"), CFSTR("{TIFF}"));
      IIODictionary::removeObjectForKey(a2, CFSTR("Compression"));
      if (IIODictionary::getUint32ForKeyGroup(a2, CFSTR("Compression"), CFSTR("{TIFF}")) >= 2)
      {
        IIODictionary::removeObjectForKeyGroup(a2, CFSTR("TileWidth"), CFSTR("{TIFF}"));
        IIODictionary::removeObjectForKeyGroup(a2, CFSTR("TileLength"), CFSTR("{TIFF}"));
      }
    }
  }
  if (CFStringCompare(this[9], CFSTR("com.truevision.tga-image"), 0) == kCFCompareEqualTo
    && IIODictionary::containsKey(a2, CFSTR("Compression")))
  {
    if (IIODictionary::containsKey(a2, CFSTR("{TGA}")))
    {
      v5 = IIODictionary::getObjectForKey(a2, CFSTR("Compression"));
      IIODictionary::setObjectForKeyGroup(a2, v5, CFSTR("Compression"), CFSTR("{TGA}"));
      IIODictionary::removeObjectForKey(a2, CFSTR("Compression"));
    }
  }
}

void sub_187EB6050(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_ReaderHandler::UseAppleJPEG(IIO_ReaderHandler *this)
{
  if (IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck != -1)
    dispatch_once(&IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck, &__block_literal_global_28_0);
  return IIO_ReaderHandler::UseAppleJPEG(void)::gUseAppleJPEGPlugin;
}

uint64_t IIO_Writer::canWriteExifOrientation(IIO_Writer *this)
{
  return (*((unsigned __int8 *)this + 42) >> 1) & 1;
}

uint64_t IIO_CGImageWrapsIOSurface(uint64_t result, int a2)
{
  uint64_t Property;
  BOOL v4;

  if (result)
  {
    result = CGImageGetImageProvider();
    if (result)
    {
      Property = CGImageProviderGetProperty();
      if (Property)
        v4 = Property == *MEMORY[0x1E0C9AE50];
      else
        v4 = 0;
      result = v4;
      if (!v4)
      {
        if (a2)
          return CGImageProviderGetCallbackVersion() > 1;
      }
    }
  }
  return result;
}

uint64_t _ImageIsFloat(CGImage *a1)
{
  return (CGImageGetBitmapInfo(a1) >> 8) & 1;
}

uint64_t _ImageGetEndianInfo(CGImage *a1)
{
  return CGImageGetBitmapInfo(a1) & 0x7000;
}

uint64_t IIOGetExifOrientation(IIODictionary *a1, unsigned __int16 a2)
{
  unsigned __int16 Uint32ForKey;

  if (a1)
  {
    if (IIODictionary::containsKey(a1, CFSTR("Orientation")))
    {
      Uint32ForKey = (unsigned __int16)IIODictionary::getUint32ForKey(a1, CFSTR("Orientation"));
    }
    else if (IIODictionary::containsKeyGroup(a1, CFSTR("Orientation"), CFSTR("{TIFF}")))
    {
      Uint32ForKey = (unsigned __int16)IIODictionary::getUint32ForKeyGroup(a1, CFSTR("Orientation"), CFSTR("{TIFF}"));
    }
    else
    {
      Uint32ForKey = 1;
    }
    if ((unsigned __int16)(Uint32ForKey - 9) >= 0xFFF8u)
      return Uint32ForKey;
    else
      return a2;
  }
  else
  {
    return 1;
  }
}

uint64_t CGImagePixelDataProviderCreate(CGImage *a1, vImage_CGImageFormat *a2, CGColor *a3)
{
  uint64_t Instance;
  unint64_t v7;
  uint64_t v8;
  int v9;

  if (a1 && a2->colorSpace)
  {
    if (CGImagePixelDataProviderGetTypeID::once != -1)
      dispatch_once(&CGImagePixelDataProviderGetTypeID::once, &__block_literal_global_27);
    Instance = _CFRuntimeCreateInstance();
    *(_DWORD *)(Instance + 16) = 1;
    do
      v7 = __ldxr(&gPDPCount);
    while (__stxr(v7 + 1, &gPDPCount));
    v8 = operator new();
    IIOImagePixelDataProvider::IIOImagePixelDataProvider((IIOImagePixelDataProvider *)v8, a1, a2, a3);
    v9 = *(_DWORD *)(v8 + 220);
    if (!v9)
    {
      *(_QWORD *)(Instance + 24) = v8;
      *(_QWORD *)(v8 + 8) = Instance;
      return Instance;
    }
    LogWarning("CGImagePixelDataProviderCreate", 1650, "*** <CGImagePixelDataProviderRef:%p> could not create <IIOImagePixelDataProvider:%p>  %d\n", (const void *)Instance, (const void *)v8, v9);
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    CFRelease((CFTypeRef)Instance);
  }
  return 0;
}

void sub_187EB6334(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C400B9EDD37);
  _Unwind_Resume(a1);
}

void IIOImagePixelDataProvider::IIOImagePixelDataProvider(IIOImagePixelDataProvider *this, CGImage *a2, vImage_CGImageFormat *a3, CGColor *a4)
{
  int v4;

  *(_QWORD *)this = &off_1E1BB2590;
  if (a2)
  {
    if (a3)
    {
      if (a3->colorSpace)
      {
        IIOImagePixelDataProvider::setup(this, a2, a3, a4);
        return;
      }
      v4 = -3;
    }
    else
    {
      v4 = -2;
    }
  }
  else
  {
    v4 = -1;
  }
  *((_DWORD *)this + 55) = v4;
}

void IIOImagePixelDataProvider::setup(IIOImagePixelDataProvider *this, CGImage *a2, vImage_CGImageFormat *a3, CGColorRef color)
{
  vImageConverterRef *v8;
  IIOImagePixelDataProvider *Height;
  const CGFloat *Components;
  int v11;
  size_t Width;
  uint64_t v13;
  uint64_t (*v14)(IIOImagePixelDataProvider *__hidden, void *, void *, unint64_t);
  vImageConverterRef v15;
  size_t v16;
  int v17;
  const char *v18;
  unsigned int v19;
  int v20;
  int v21;
  char *v22;
  unsigned int v23;
  int v24;
  int v25;
  char *v26;
  const void *Property;
  const __CFNumber *v28;
  const __CFNumber *v29;
  CFTypeID v30;
  uint64_t (*v31)(IIOImagePixelDataProvider *__hidden, void *, void *, unint64_t);
  uint64_t v32;
  vImage_Error error;
  _OWORD v34[8];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)((char *)this + 120) = 0u;
  v8 = (vImageConverterRef *)((char *)this + 120);
  *((_QWORD *)this + 1) = 0;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 26) = CGColorRetain(color);
  *(_WORD *)((char *)this + 217) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_BYTE *)this + 248) = 0;
  *((_DWORD *)this + 55) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 2) = CGImageRetain(a2);
  *((_QWORD *)this + 3) = CGImageGetWidth(a2);
  Height = (IIOImagePixelDataProvider *)CGImageGetHeight(a2);
  *((_QWORD *)this + 4) = Height;
  *((_QWORD *)this + 28) = 0;
  *((_QWORD *)this + 29) = 0;
  IIOImagePixelDataProvider::initvImageCGImageFormat(Height, a2, (vImage_CGImageFormat *)this + 1);
  *((_QWORD *)this + 10) = *(_QWORD *)&a3->bitsPerComponent;
  *((_QWORD *)this + 11) = CGColorSpaceRetain(a3->colorSpace);
  *((_QWORD *)this + 12) = *(_QWORD *)&a3->bitmapInfo;
  *((_QWORD *)this + 13) = a3->decode;
  *((_DWORD *)this + 28) = CGImageGetRenderingIntent(*((CGImageRef *)this + 2));
  memset(v34, 0, sizeof(v34));
  if (color)
  {
    CGColorGetColorSpace(color);
    if (CGColorSpaceEqualToColorSpace())
    {
      Components = CGColorGetComponents(color);
    }
    else if (IIO_ConvertCGColorToColorComponents(color, *((_QWORD *)this + 11)))
    {
      Components = (const CGFloat *)v34;
    }
    else
    {
      Components = 0;
    }
  }
  else
  {
    Components = 0;
  }
  v11 = *((_DWORD *)this + 14) & 0xF0000;
  if (v11 == 196608)
  {
    _cg_jpeg_mem_term("setup", 160, "*** NOTE: vImageConverter_CreateWithCGImageFormat cannot handle kCGImagePixelFormatRGB101010 - using workaround\n");
    *((_QWORD *)this + 16) = CGImageGetBytesPerRow(*((CGImageRef *)this + 2));
    v13 = CGImageGetWidth(*((CGImageRef *)this + 2)) * ((unint64_t)*((unsigned int *)this + 21) >> 3);
    *((_QWORD *)this + 18) = v13;
    v14 = IIOImagePixelDataProvider::GetBytesDataProviderRGB101010;
LABEL_13:
    *((_QWORD *)this + 22) = v14;
    *((_QWORD *)this + 20) = CGImageGetHeight(*((CGImageRef *)this + 2)) * v13;
    return;
  }
  if (v11 == 0x40000)
  {
    *((_BYTE *)this + 218) = 1;
    *((_QWORD *)this + 10) = 0x4000000010;
    *((_QWORD *)this + 16) = CGImageGetBytesPerRow(*((CGImageRef *)this + 2));
    Width = CGImageGetWidth(*((CGImageRef *)this + 2));
    v13 = 8 * Width;
    *((_QWORD *)this + 18) = 8 * Width;
    if (Width >> 61)
      abort();
    v14 = IIOImagePixelDataProvider::GetBytesDataProviderCIF10;
    goto LABEL_13;
  }
  error = 0;
  v15 = vImageConverter_CreateWithCGImageFormat((const vImage_CGImageFormat *)this + 1, (const vImage_CGImageFormat *)this + 2, Components, 0x10u, &error);
  *v8 = v15;
  if (!v15)
  {
    v17 = error;
    v18 = IIO_vImageErrorString(error);
    LogWarning("setup", 174, "Could not create vImageConverter, vImageConverter_CreateWithCGImageFormat: err=%d [%s]\n", v17, v18);
    v19 = *((_DWORD *)this + 14);
    v20 = *((_DWORD *)this + 10);
    v21 = *((_DWORD *)this + 11);
    v22 = IIO_BitmapInfoString(v19);
    _cg_jpeg_mem_term("setup", 175, "*** srcFormat: bpc: %d   bpp: %d  bmi: 0x%08X %s\n", v20, v21, v19, v22);
    v23 = *((_DWORD *)this + 24);
    v24 = *((_DWORD *)this + 20);
    v25 = *((_DWORD *)this + 21);
    v26 = IIO_BitmapInfoString(v23);
    _cg_jpeg_mem_term("setup", 176, "*** dstFormat: bpc: %d   bpp: %d  bmi: 0x%08X %s\n", v24, v25, v23, v26);
    *((_DWORD *)this + 55) = -5;
    return;
  }
  *((_QWORD *)this + 16) = CGImageGetBytesPerRow(*((CGImageRef *)this + 2));
  v16 = CGImageGetWidth(*((CGImageRef *)this + 2)) * *((unsigned int *)this + 21) + 7;
  *((_QWORD *)this + 18) = v16 >> 3;
  if (*((_QWORD *)this + 16) > v16 >> 3 && *((_DWORD *)this + 14) == *((_DWORD *)this + 24))
  {
    if (vImageCGImageFormat_IsEqual((const vImage_CGImageFormat *)this + 1, (const vImage_CGImageFormat *)this + 2))
    {
      *((_QWORD *)this + 18) = *((_QWORD *)this + 16);
    }
    else if (*((_DWORD *)this + 11) <= *((_DWORD *)this + 21))
    {
      _cg_jpeg_mem_term("setup", 194, "*** image: %p  bad rowbytes?   size: %5zd x %5zd      _srcRowBytes: %d   _dstRowBytes: %d\n", *((const void **)this + 2), *((_QWORD *)this + 3), *((_QWORD *)this + 4), *((_QWORD *)this + 16), *((_QWORD *)this + 18));
    }
  }
  if (CGImageGetImageProvider())
  {
    Property = (const void *)CGImageProviderGetProperty();
    if (Property)
    {
      if (CFEqual(Property, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
      {
        v28 = (const __CFNumber *)CGImageProviderGetProperty();
        if (v28)
        {
          v29 = v28;
          v30 = CFGetTypeID(v28);
          if (v30 == CFNumberGetTypeID())
            CFNumberGetValue(v29, kCFNumberLongType, (char *)this + 168);
        }
      }
    }
    v31 = IIOImagePixelDataProvider::GetBytesImageProvider;
LABEL_30:
    *((_QWORD *)this + 22) = v31;
    goto LABEL_31;
  }
  *((_QWORD *)this + 22) = IIOImagePixelDataProvider::GetBytesDataProvider;
  if (CGImageGetDataProvider(a2) && CGDataProviderGetSizeOfData() == -1)
  {
    if (!vImageCGImageFormat_IsEqual((const vImage_CGImageFormat *)this + 1, (const vImage_CGImageFormat *)this + 2))
    {
      if (!vImageConverter_MustOperateOutOfPlace(*v8, 0, 0, 0) && *((_QWORD *)this + 18) >= *((_QWORD *)this + 16))
        *((_BYTE *)this + 248) = 1;
      v31 = IIOImagePixelDataProvider::GetBytesCGAccessSessionConvert;
      goto LABEL_30;
    }
    *((_QWORD *)this + 22) = IIOImagePixelDataProvider::GetBytesCGAccessSessionNoConvert;
    *((_QWORD *)this + 18) = *((_QWORD *)this + 16);
  }
LABEL_31:
  v32 = *((_QWORD *)this + 18);
  *((_QWORD *)this + 20) = CGImageGetHeight(*((CGImageRef *)this + 2)) * v32;
  if ((gIIODebugFlags & 0x400000000) != 0)
    vImageConverter_Print();
}

const CGFloat *IIOImagePixelDataProvider::initvImageCGImageFormat(IIOImagePixelDataProvider *this, CGImageRef image, vImage_CGImageFormat *a3)
{
  const CGFloat *result;

  a3->bitsPerComponent = CGImageGetBitsPerComponent(image);
  a3->bitsPerPixel = CGImageGetBitsPerPixel(image);
  a3->colorSpace = CGImageGetColorSpace(image);
  a3->bitmapInfo = CGImageGetBitmapInfo(image);
  a3->renderingIntent = CGImageGetRenderingIntent(image);
  a3->version = 0;
  result = CGImageGetDecode(image);
  a3->decode = result;
  return result;
}

uint64_t ASTCReadPlugin::extractMetadata(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  unsigned int Val32;
  size_t v6;
  unint64_t v7;
  const char *v8;
  char v9;
  unint64_t v10;
  const char *v11;
  char v12;
  int Val8;
  uint64_t v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v3 = *(unsigned int *)(a2 + 60);
  v25 = 0;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v21, *(IIOImageReadSession **)(a1 + 24));
  if (v3 + 64 < (unint64_t)v22)
  {
    v4 = *((_QWORD *)&v21 + 1) + 64;
    v20 = 0;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    IIOScanner::IIOScanner((IIOScanner *)&v16, (unsigned __int8 *)(*((_QWORD *)&v21 + 1) + 64), v3, *(_BYTE *)(a1 + 344));
    while (1)
    {
      if (*((_QWORD *)&v17 + 1) + 4 >= v3
        || (Val32 = IIOScanner::getVal32((IIOScanner *)&v16), v3 - *((_QWORD *)&v17 + 1) <= Val32)
        || (v6 = (Val32 + 3) & 0xFFFFFFFC, v7 = *((_QWORD *)&v17 + 1) + v6, *((_QWORD *)&v17 + 1) + v6 > v3)
        || *(_QWORD *)(a1 + 184) <= v6)
      {
LABEL_37:
        v14 = 1;
        IIOScanner::~IIOScanner((IIOScanner *)&v16);
        goto LABEL_38;
      }
      v8 = (const char *)(v4 + *((_QWORD *)&v17 + 1));
      if (!strncmp((const char *)(v4 + *((_QWORD *)&v17 + 1)), "KTXorientation", v6))
      {
        IIOScanner::skip((uint64_t)&v16, 15);
        v10 = v3 - *((_QWORD *)&v17 + 1);
        if (v3 - *((_QWORD *)&v17 + 1) < 7)
          goto LABEL_33;
        v11 = (const char *)(v4 + *((_QWORD *)&v17 + 1));
        if (!strncmp((const char *)(v4 + *((_QWORD *)&v17 + 1)), "S=r,T=d", v6))
        {
LABEL_21:
          v12 = 1;
LABEL_32:
          *(_BYTE *)(a1 + 509) = v12;
          goto LABEL_33;
        }
        if (!strncmp(v11, "S=r,T=u", v6))
        {
          v12 = 4;
          goto LABEL_32;
        }
        if (v10 >= 0xC && (!strncmp(v11, "S=r,T=d,R=i", v6) || !strncmp(v11, "S=r,T=u,R=o", v6)))
          goto LABEL_21;
      }
      else
      {
        if (!strncmp(v8, "ColorSpace_APPLE", v6))
        {
          IIOScanner::skip((uint64_t)&v16, 17);
          Val8 = IIOScanner::getVal8((IIOScanner *)&v16);
        }
        else
        {
          if (!strncmp(v8, "Compression_APPLE", v6))
          {
            IIOScanner::skip((uint64_t)&v16, 18);
LABEL_26:
            *(_BYTE *)(a1 + 508) = 1;
            goto LABEL_33;
          }
          if (!strncmp(v8, "AlphaInfo_APPLE", v6))
          {
            IIOScanner::skip((uint64_t)&v16, 16);
            v9 = IIOScanner::getVal8((IIOScanner *)&v16);
LABEL_28:
            if ((v9 & 0xF8) == 0x30)
              *(_BYTE *)(a1 + 507) = v9 - 48;
            goto LABEL_33;
          }
          if (strncmp(v8, "ColorSpace", v6))
          {
            if (!strncmp(v8, "Compression", v6))
            {
              IIOScanner::skip((uint64_t)&v16, 12);
              goto LABEL_26;
            }
            if (strncmp(v8, "AlphaInfo", v6))
              goto LABEL_33;
            IIOScanner::skip((uint64_t)&v16, 10);
            v9 = IIOScanner::getVal8((IIOScanner *)&v16);
            goto LABEL_28;
          }
          IIOScanner::skip((uint64_t)&v16, 11);
          Val8 = IIOScanner::getVal8((IIOScanner *)&v16);
        }
        if ((Val8 - 48) <= 4)
          *(_BYTE *)(a1 + 506) = Val8 - 48;
      }
LABEL_33:
      if (v7 >= v3)
        goto LABEL_37;
      IIOScanner::seek((IIOScanner *)&v16, v7);
    }
  }
  _cg_jpeg_mem_term("extractMetadata", 153, "*** invalid KTX file: KTXHeader: %d  metadatSize: %d    fileSize: %d\n", 64, v3, (_DWORD)v22);
  v14 = 0;
LABEL_38:
  IIOScanner::~IIOScanner((IIOScanner *)&v21);
  return v14;
}

void sub_187EB6C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

void sub_187EB6C58(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187EB6C0CLL);
}

void sub_187EB6C88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x187EB6C48);
}

uint64_t IIO_Reader_PBM::testHeader(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  int Val8;
  int v4;
  int v5;
  uint64_t v7;
  unsigned __int8 v8;
  _OWORD v11[2];
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = 0;
  v12 = 0u;
  v13 = 0u;
  memset(v11, 0, sizeof(v11));
  IIOScanner::IIOScanner((IIOScanner *)v11, a2, a3, 0);
  Val8 = IIOScanner::getVal8((IIOScanner *)v11);
  v4 = IIOScanner::getVal8((IIOScanner *)v11);
  v5 = v4;
  v7 = Val8 == 42 && v4 == 23;
  if (Val8 == 80 && ((v4 - 49) < 7 || v4 == 102 || v4 == 70))
  {
    *((_QWORD *)&v12 + 1) = GetPBMLookupTable();
    v8 = IIOScanner::lookupVal8((IIOScanner *)v11);
    if ((v8 + 2) >= 0xFEu)
    {
      while ((v8 & 0xFE) == 0xFC)
        v8 = IIOScanner::lookupVal8((IIOScanner *)v11);
      if (v8 == 254)
      {
        while (IIOScanner::lookupVal8((IIOScanner *)v11) != 252)
          ;
        v8 = -4;
      }
      if (v8 != 0xFF || v5 == 55)
        v7 = 1;
      else
        v7 = v7;
    }
  }
  IIOScanner::~IIOScanner((IIOScanner *)v11);
  return v7;
}

void sub_187EB6DB4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187EB6D94);
}

void sub_187EB6DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a9);
  _Unwind_Resume(a1);
}

uint64_t IIOScanner::getVal8(IIOScanner *this)
{
  unint64_t v1;
  uint64_t v2;
  _DWORD *exception;

  v1 = *((_QWORD *)this + 3);
  if (v1 >= *((_QWORD *)this + 2))
  {
    LogError("getVal8", 149, "*** IIOScanner::getVal8 reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v2 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 3) = v1 + 1;
  return *(unsigned __int8 *)(v2 + v1);
}

uint64_t CGImageWriteSessionCreateWithFile(const __CFString *a1)
{
  IIOImageWriteSession *v2;

  if (!a1)
    return 0;
  v2 = (IIOImageWriteSession *)operator new();
  IIOImageWriteSession::IIOImageWriteSession(v2, a1);
  if (*((_DWORD *)v2 + 19))
  {
    (*(void (**)(IIOImageWriteSession *))(*(_QWORD *)v2 + 8))(v2);
    return 0;
  }
  return CGImageWriteSessionCreateWith_wSession(v2);
}

void sub_187EB6ED0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

void IIOImageWriteSession::IIOImageWriteSession(IIOImageWriteSession *this, CFStringRef string)
{
  CFIndex MaximumSizeOfFileSystemRepresentation;
  char *v5;
  size_t v6;
  IIOImageWriteSession *v7;
  char *TempFileName;
  char *v9;
  FILE *v10;
  int v11;
  int *v12;
  char *v13;

  *(_QWORD *)this = &off_1E1BB1F60;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_WORD *)this + 36) = 1;
  *((_QWORD *)this + 10) = this;
  *((_QWORD *)this + 11) = this;
  *((_DWORD *)this + 19) = 0;
  if (!string)
  {
    *((_DWORD *)this + 19) = -50;
    return;
  }
  MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(string);
  v5 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation + 6, 0x4FDC185DuLL);
  if (CFStringGetFileSystemRepresentation(string, v5, MaximumSizeOfFileSystemRepresentation) == 1)
  {
    v6 = strlen(v5);
    v7 = (IIOImageWriteSession *)reallocf(v5, v6 + 1);
    if (!v7)
      return;
    v5 = (char *)v7;
    TempFileName = IIOImageWriteSession::createTempFileName(v7, (char *)v7);
    if (TempFileName)
    {
      v9 = TempFileName;
      v10 = fopen(TempFileName, "w+b");
      *((_QWORD *)this + 4) = v10;
      if (v10)
      {
        *((_BYTE *)this + 73) = 1;
        if ((gIIODebugFlags & 0x200000000000) != 0)
          ImageIOLog(">>> CGImageWriteSessionCreateWithFile: creating FILE* %p\n", v10);
        *((_QWORD *)this + 6) = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9);
        *((_QWORD *)this + 5) = CFRetain(string);
      }
      else
      {
        *((_DWORD *)this + 19) = *__error();
        v11 = *__error();
        v12 = __error();
        v13 = strerror(*v12);
        LogError("IIOImageWriteSession", 122, "*** ERROR: cannot create: '%s'\n         error = %d (%s)\n", v9, v11, v13);
      }
      free(v9);
    }
    else
    {
      *((_DWORD *)this + 19) = -37;
    }
    goto LABEL_10;
  }
  *((_DWORD *)this + 19) = -4172;
  if (v5)
LABEL_10:
    free(v5);
}

uint64_t CGImageWriteSessionCreateWithMutableData(const void *a1)
{
  IIOImageWriteSession *v2;

  if (!a1)
    return 0;
  v2 = (IIOImageWriteSession *)operator new();
  IIOImageWriteSession::IIOImageWriteSession(v2, a1);
  if (*((_DWORD *)v2 + 19))
  {
    (*(void (**)(IIOImageWriteSession *))(*(_QWORD *)v2 + 8))(v2);
    return 0;
  }
  return CGImageWriteSessionCreateWith_wSession(v2);
}

void sub_187EB710C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

void IIOImageWriteSession::IIOImageWriteSession(IIOImageWriteSession *this, CFTypeRef cf)
{
  CFIndex Length;

  *(_QWORD *)this = &off_1E1BB1F60;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_WORD *)this + 36) = 2;
  *((_QWORD *)this + 10) = this;
  *((_QWORD *)this + 11) = this;
  *((_DWORD *)this + 19) = 0;
  *((_QWORD *)this + 3) = CFRetain(cf);
  Length = CFDataGetLength((CFDataRef)cf);
  *((_QWORD *)this + 7) = Length;
  if (Length)
  {
    CFDataSetLength(*((CFMutableDataRef *)this + 3), 0);
    *((_QWORD *)this + 7) = 0;
  }
}

{
  *(_QWORD *)this = &off_1E1BB1F60;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_WORD *)this + 36) = 3;
  *((_QWORD *)this + 10) = this;
  *((_QWORD *)this + 11) = this;
  *((_DWORD *)this + 19) = 0;
  *((_QWORD *)this + 2) = CFRetain(cf);
  *((_QWORD *)this + 3) = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
}

char *IIOImageWriteSession::createTempFileName(IIOImageWriteSession *this, char *a2)
{
  char *v3;
  int *v4;
  size_t v5;
  char *v6;
  char *v7;
  size_t v8;

  if (_xpc_runtime_is_app_sandboxed())
  {
    v3 = (char *)_amkrtemp();
    if (v3)
      return v3;
    v4 = __error();
    LogWarning("createTempFileName", 496, " _amkrtemp(\"%s\") failed.  errno = %d\n", a2, *v4);
  }
  v5 = strlen(a2);
  v3 = (char *)malloc_type_malloc(v5 + 7, 0x178ABBB0uLL);
  strncpy(v3, a2, v5 + 1);
  if ((_xpc_runtime_is_app_sandboxed() & 1) == 0)
  {
    v6 = strrchr(v3, 47);
    if (v6)
      v7 = v6 + 1;
    else
      v7 = v3;
    v8 = strlen(v7);
    memmove(v7 + 1, v7, v8 + 1);
    *v7 = 46;
    strcat(v3, "-XXXX");
    mktemp(v3);
  }
  return v3;
}

CFDataRef CGImageMetadataCreateXMPData(CGImageMetadataRef metadata, CFDictionaryRef options)
{
  CGImageMetadataRef v3;
  const __CFDictionary *v4;
  CFTypeID v5;
  CFTypeID v6;
  CFDictionaryRef *v7;
  CFDictionaryRef *v8;
  CFIndex length;

  v3 = metadata;
  if (metadata)
  {
    v4 = (const __CFDictionary *)*((_QWORD *)metadata + 3);
    if (v4)
      CFDictionaryGetCount(v4);
  }
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataCreateXMPData", 0, 0, -1, 0);
  length = 0;
  if (v3)
  {
    v5 = CFGetTypeID(v3);
    if (CGImageMetadataGetTypeID::once != -1)
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
    if (v5 == CGImageMetadataGetTypeID::id
      && (!options || (v6 = CFGetTypeID(options), v6 == CFDictionaryGetTypeID()))
      && (v7 = SerializeMetadataForXMP((CFDictionaryRef *)v3, (size_t *)&length)) != 0)
    {
      v8 = v7;
      v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v7, length);
      free(v8);
      if (v3)
        CFDataGetLength(v3);
    }
    else
    {
      v3 = 0;
    }
  }
  kdebug_trace();
  return v3;
}

CFDictionaryRef *SerializeMetadataForXMP(CFDictionaryRef *cf, size_t *a2)
{
  CFDictionaryRef *SXMPMetaFromMetadata;
  CFTypeID v4;
  const __CFDictionary *v5;
  size_t size;
  char *v7;
  std::string *v8;
  std::string v10;

  if (!a2)
    return 0;
  SXMPMetaFromMetadata = cf;
  *a2 = 0;
  if (!cf)
    return SXMPMetaFromMetadata;
  v4 = CFGetTypeID(cf);
  if (v4 != CGImageMetadataGetTypeID())
    return 0;
  v5 = SXMPMetaFromMetadata[3];
  if (v5)
  {
    if (!CFDictionaryGetCount(v5))
      return 0;
  }
  memset(&v10, 0, sizeof(v10));
  if ((IIO_InitializeXMPToolkit() & 1) == 0)
    return 0;
  SXMPMetaFromMetadata = (CFDictionaryRef *)CreateSXMPMetaFromMetadata(SXMPMetaFromMetadata);
  if (SXMPMetaFromMetadata)
  {
    std::string::erase(&v10, 0, 0xFFFFFFFFFFFFFFFFLL);
    TXMPMeta<std::string>::SerializeToBuffer((uint64_t)SXMPMetaFromMetadata, (uint64_t)&v10, 16, 0, "", "", 0);
    (*((void (**)(CFDictionaryRef *))*SXMPMetaFromMetadata + 1))(SXMPMetaFromMetadata);
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v10.__r_.__value_.__r.__words[2]);
    else
      size = v10.__r_.__value_.__l.__size_;
    v7 = (char *)malloc_type_malloc(size, 0x100004077774924uLL);
    SXMPMetaFromMetadata = (CFDictionaryRef *)v7;
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v8 = &v10;
    else
      v8 = (std::string *)v10.__r_.__value_.__r.__words[0];
    strncpy(v7, (const char *)v8, size);
    *a2 = size;
  }
  IIO_TerminateXMPToolkit();
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v10.__r_.__value_.__l.__data_);
  return SXMPMetaFromMetadata;
}

void ___Z23IIODetermineHEIFSupportv_block_invoke()
{
  BOOL v0;
  BOOL v1;
  BOOL v2;
  BOOL v3;
  BOOL v4;
  BOOL v5;
  BOOL v6;
  char v7;
  char v8;

  if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec)
  {
    v7 = 0;
    if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(0, 1785750887, 0, &v7))
      v0 = 1;
    else
      v0 = v7 == 0;
    if (!v0)
      gHEIF_JPEG_DecodingSupported = 1;
    if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(0, 1752589105, 0, &v7))
      v1 = 1;
    else
      v1 = v7 == 0;
    if (!v1)
      gHEIF_HEVC_DecodingSupported = 1;
    if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(0, 1635148593, 0, &v7))
      v2 = 1;
    else
      v2 = v7 == 0;
    if (!v2)
      gHEIF_AVCI_DecodingSupported = 1;
    if (gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(0, 1635135537, 0, &v7))
      v3 = 1;
    else
      v3 = v7 == 0;
    if (!v3)
      gHEIF_AVIF_DecodingSupported = 1;
    if (!gFunc_CMPhotoDecompressionSupportedForContainerAndCodec(2, 1786276896, 0, &v7) && v7)
      gHEIF_JPEGXL_DecodingSupported = 1;
  }
  if (gFunc_CMPhotoCompressionSupportedForContainerAndCodec)
  {
    v8 = 0;
    if (gFunc_CMPhotoCompressionSupportedForContainerAndCodec(0, 1785750887, 0, &v8))
      v4 = 1;
    else
      v4 = v8 == 0;
    if (!v4)
      gHEIF_JPEG_EncodingSupported = 1;
    if (gFunc_CMPhotoCompressionSupportedForContainerAndCodec(0, 1752589105, 0, &v8))
      v5 = 1;
    else
      v5 = v8 == 0;
    if (!v5)
      gHEIF_HEVC_EncodingSupported = 1;
    if (gFunc_CMPhotoCompressionSupportedForContainerAndCodec(0, 1635148593, 0, &v8))
      v6 = 1;
    else
      v6 = v8 == 0;
    if (!v6)
      gHEIF_AVCI_EncodingSupported = 1;
  }
}

CGImageSourceRef CGImageSourceCreateIncremental(CFDictionaryRef options)
{
  CFTypeID v2;
  uint64_t v3;
  pthread_mutex_t *v4;
  const void *v5;
  unsigned int v6;
  _QWORD v8[3];

  kdebug_trace();
  IIOInitDebugFlags();
  if (options)
  {
    v2 = CFGetTypeID(options);
    if (v2 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCreateIncremental", 4601, "*** ERROR: CGImageSourceCreateIncremental: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, options);
  v3 = operator new();
  IIOImageSource::IIOImageSource((IIOImageSource *)v3, (IIODictionary *)v8);
  v4 = (pthread_mutex_t *)(v3 + 200);
  pthread_mutex_lock((pthread_mutex_t *)(v3 + 200));
  v5 = (const void *)CGImageSourceRefCreateWith_ImageSource(v3);
  pthread_mutex_unlock(v4);
  v6 = (gIIODebugFlags >> 12) & 3;
  if (v6)
    ImageIODebugOptions(v6, "A", "CGImageSourceCreateIncremental", v5, 0, -1, options);
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return (CGImageSourceRef)v5;
}

void sub_187EB794C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MEMORY[0x18D761C30](v2, 0x10E1C40B803A584);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, IIODictionary *a2)
{
  *(_QWORD *)this = &off_1E1BAE3E0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  IIOImageSource::setup((uint64_t)this, 6);
  if (a2)
    IIOImageSource::extractOptions(this, a2);
}

void sub_187EB79E8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 184) = v5;
    operator delete(v5);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 128) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t png_handle_tIME(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  uint64_t result;
  const char *v7;
  uint64_t v8;
  _DWORD v9[2];

  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if (a2 && (*(_BYTE *)(a2 + 9) & 2) != 0)
  {
    png_crc_finish(a1, a3);
    v7 = "duplicate";
    return png_chunk_benign_error(a1, v7);
  }
  if ((v4 & 4) != 0)
    *(_DWORD *)(a1 + 76) = v4 | 8;
  if ((_DWORD)a3 != 7)
  {
    png_crc_finish(a1, a3);
    v7 = "invalid";
    return png_chunk_benign_error(a1, v7);
  }
  *(_DWORD *)((char *)v9 + 3) = 0;
  v9[0] = 0;
  v8 = 0;
  png_crc_read(a1, (Bytef *)v9, 7u);
  result = png_crc_finish(a1, 0);
  if (!(_DWORD)result)
  {
    BYTE6(v8) = BYTE2(v9[1]);
    *(_DWORD *)((char *)&v8 + 2) = *(_DWORD *)((char *)v9 + 2);
    LOWORD(v8) = bswap32(LOWORD(v9[0])) >> 16;
    return png_set_tIME(a1, a2, (uint64_t)&v8);
  }
  return result;
}

uint64_t png_set_tIME(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2 && a3 && (*(_BYTE *)(result + 77) & 2) == 0)
  {
    if (*(unsigned __int8 *)(a3 + 2) - 13 >= 0xFFFFFFF4
      && *(unsigned __int8 *)(a3 + 3) - 32 >= 0xFFFFFFE1
      && *(unsigned __int8 *)(a3 + 4) <= 0x17u
      && *(unsigned __int8 *)(a3 + 5) <= 0x3Bu
      && *(unsigned __int8 *)(a3 + 6) < 0x3Du)
    {
      *(_QWORD *)(a2 + 168) = *(_QWORD *)a3;
      *(_DWORD *)(a2 + 8) |= 0x200u;
    }
    else
    {
      return png_warning(result, "Ignoring invalid time value");
    }
  }
  return result;
}

uint64_t CGImageSourceSetAllowableTypes(const void *a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceSetAllowableTypes", 0, 0, -1, 0);
  return IIODecodingSetAllowableTypes(a1);
}

void sub_187EB7C24(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

_QWORD *AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::MemoryAllocatorWrapperImpl(_QWORD *this)
{
  *this = &off_1E1BBABB0;
  this[1] = 0;
  return this;
}

uint64_t IIO_Reader_TIFF::getImageCount(IIO_Reader_TIFF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  unint64_t v7;
  int Val16;
  int v9;
  int v10;
  int v11;
  GlobalTIFFInfo *v12;
  unint64_t TiffOffset;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  int IFDCount;
  int v22;
  unsigned __int16 v23;
  unsigned __int16 v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  int v28;
  unint64_t v29;
  __int128 v30;
  int v31;
  _BOOL4 v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned __int16 v37;
  unsigned __int16 v38;
  int v39;
  unint64_t *v41;
  unint64_t *v42;
  unint64_t *v43;
  unint64_t *v44;
  unint64_t *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t *v54;
  unint64_t *v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  char *v60;
  unint64_t *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  char *v66;
  unint64_t *v67;
  unint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t *v71;
  unint64_t *v72;
  unint64_t v73;
  char *v74;
  int v75;
  uint64_t v76;
  IIOImageRead **v77;
  unint64_t *v78;
  unint64_t *v79;
  unint64_t *v80;
  unint64_t v81;
  uint64_t v82;
  BOOL v83;
  unint64_t v84;
  char *v85;
  unint64_t v86;
  char *v87;
  char *v88;
  uint64_t v89;
  uint64_t v90;
  int v92;
  IIOImageReadSession *v93;
  unsigned int *v94;
  GlobalTIFFInfo *v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int v98;
  _BYTE v99[20];
  _QWORD *v100;
  _QWORD *v101;
  uint64_t v102;
  _QWORD *v103;
  _QWORD *v104;
  uint64_t v105;
  _QWORD *v106;
  _QWORD *v107;
  uint64_t v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  uint64_t v113;
  unint64_t *v114;
  unint64_t *v115;
  unint64_t v116;
  unint64_t *v117;
  unint64_t *v118;
  unint64_t v119;
  unint64_t *v120;
  unint64_t *v121;
  _QWORD v122[2];

  v120 = 0;
  v121 = 0;
  v122[0] = 0;
  v117 = 0;
  v118 = 0;
  v119 = 0;
  v114 = 0;
  v115 = 0;
  v116 = 0;
  v113 = 0;
  v111 = 0u;
  v112 = 0u;
  v109 = 0u;
  v110 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v109, a2);
  v94 = a5;
  SetupTIFFErrorHandler();
  v7 = v110;
  if ((unint64_t)v110 < 9
    || (Val16 = IIOScanner::getVal16((IIOScanner *)&v109),
        GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)&v109, Val16 != 19789),
        v9 = IIOScanner::getVal16((IIOScanner *)&v109),
        v10 = v9,
        (v9 & 0xFFFE) != 0x2A))
  {
    LODWORD(v76) = 0;
    v90 = 4294967246;
    if (a5)
      goto LABEL_184;
    goto LABEL_185;
  }
  if (v9 == 43)
  {
    v11 = IIOScanner::getVal16((IIOScanner *)&v109);
    IIOScanner::skip((uint64_t)&v109, 2);
  }
  else
  {
    v11 = 4;
  }
  LODWORD(v111) = v11;
  v12 = (GlobalTIFFInfo *)operator new();
  GlobalTIFFInfo::GlobalTIFFInfo(v12, v10 == 43);
  TiffOffset = IIOScanner::getTiffOffset((IIOScanner *)&v109);
  v14 = TiffOffset;
  v92 = Val16;
  v93 = a2;
  v95 = v12;
  if (TiffOffset < 8 || TiffOffset >= v7)
    goto LABEL_159;
  do
  {
    v106 = 0;
    v107 = 0;
    v108 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v106, v120, (uint64_t)v121, v121 - v120);
    v15 = v107;
    v16 = v106;
    if (v106 != v107)
    {
      v16 = v106;
      while (*v16 != v14)
      {
        if (++v16 == v107)
        {
          v16 = v107;
          break;
        }
      }
    }
    if (v106)
    {
      v107 = v106;
      operator delete(v106);
    }
    if (v16 != v15)
      break;
    v103 = 0;
    v104 = 0;
    v105 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v103, v117, (uint64_t)v118, v118 - v117);
    v17 = v104;
    v18 = v103;
    if (v103 != v104)
    {
      v18 = v103;
      while (*v18 != v14)
      {
        if (++v18 == v104)
        {
          v18 = v104;
          break;
        }
      }
    }
    if (v103)
    {
      v104 = v103;
      operator delete(v103);
    }
    if (v18 != v17)
      break;
    v100 = 0;
    v101 = 0;
    v102 = 0;
    std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(&v100, v114, (uint64_t)v115, v115 - v114);
    v19 = v101;
    v20 = v100;
    if (v100 != v101)
    {
      v20 = v100;
      while (*v20 != v14)
      {
        if (++v20 == v101)
        {
          v20 = v101;
          break;
        }
      }
    }
    if (v100)
    {
      v101 = v100;
      operator delete(v100);
    }
    if (v20 != v19)
      break;
    if (v7 < v14)
    {
      _cg_jpeg_mem_term("getImageCount", 203, "bogus offsetIFD\n");
      break;
    }
    IIOScanner::seek((IIOScanner *)&v109, v14);
    IFDCount = IIOScanner::getIFDCount((IIOScanner *)&v109);
    v22 = IFDCount;
    if ((IFDCount & 0xFF80) != 0)
      break;
    memset(v99, 0, sizeof(v99));
    if (!(_WORD)IFDCount)
    {
      v36 = 0;
      v27 = 0;
      v26 = 0;
      v25 = 0;
      v38 = 0;
      v37 = 0;
      v39 = 0;
      v28 = 1;
      goto LABEL_81;
    }
    v96 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 1;
    do
    {
      if (v10 == 43)
      {
        IIOScanner::getBigTiffTag((unint64_t)&v109, (uint64_t)v99);
        v29 = *(_QWORD *)&v99[4];
      }
      else
      {
        v98 = 0;
        v97 = 0;
        IIOScanner::getTiffTag((uint64_t)&v109, (uint64_t)&v97);
        *(_DWORD *)v99 = v97;
        *(_QWORD *)&v30 = HIDWORD(v97);
        *((_QWORD *)&v30 + 1) = v98;
        *(_OWORD *)&v99[4] = v30;
        v29 = HIDWORD(v97);
      }
      if (v29 > v7)
      {
        _cg_jpeg_mem_term("getImageCount", 236, "unexpected tag-dataSize=%ld\n", v29);
        goto LABEL_159;
      }
      v31 = *(unsigned __int16 *)v99;
      if (*(unsigned __int16 *)v99 <= 0x114u)
      {
        switch(*(_WORD *)v99)
        {
          case 0xFE:
            v32 = *(_QWORD *)&v99[12] != 0xFFFFFFFFLL;
            if (*(_QWORD *)&v99[12] != 0xFFFFFFFFLL)
              v27 = *(_DWORD *)&v99[12];
            goto LABEL_67;
          case 0x100:
            v32 = *(_QWORD *)&v99[12] != 0xFFFFFFFFLL;
            if (*(_QWORD *)&v99[12] != 0xFFFFFFFFLL)
              v26 = *(_DWORD *)&v99[12];
            goto LABEL_67;
          case 0x101:
            v32 = *(_QWORD *)&v99[12] != 0xFFFFFFFFLL;
            if (*(_QWORD *)&v99[12] != 0xFFFFFFFFLL)
              v25 = *(_DWORD *)&v99[12];
            goto LABEL_67;
          case 0x103:
            v32 = *(_QWORD *)&v99[12] != 0xFFFFFFFFLL;
            if (*(_QWORD *)&v99[12] != 0xFFFFFFFFLL)
              v24 = *(_WORD *)&v99[12];
            goto LABEL_67;
          case 0x106:
            v32 = *(_QWORD *)&v99[12] != 0xFFFFFFFFLL;
            if (*(_QWORD *)&v99[12] != 0xFFFFFFFFLL)
              v23 = *(_WORD *)&v99[12];
            goto LABEL_67;
          default:
            goto LABEL_68;
        }
        goto LABEL_68;
      }
      switch(*(unsigned __int16 *)v99)
      {
        case 0x115u:
          v32 = *(_QWORD *)&v99[12] != 0xFFFFFFFFLL;
          v33 = v96;
          if (*(_QWORD *)&v99[12] != 0xFFFFFFFFLL)
            v33 = *(_DWORD *)&v99[12];
          LODWORD(v96) = v33;
          goto LABEL_67;
        case 0x11Cu:
          v32 = *(_QWORD *)&v99[12] != 0xFFFFFFFFLL;
          v34 = HIDWORD(v96);
          if (*(_QWORD *)&v99[12] != 0xFFFFFFFFLL)
            v34 = *(_DWORD *)&v99[12];
          HIDWORD(v96) = v34;
LABEL_67:
          v28 &= v32;
          break;
        case 0x8649u:
          *((_QWORD *)v95 + 8) = *(_QWORD *)&v99[12];
          *((_QWORD *)v95 + 9) = v29;
          break;
      }
LABEL_68:
      v35 = (v29 == 0) & (v31 == 254) & (v28 ^ 1);
      if (v35)
        v27 = 0;
      v28 |= v35;
      if (v31 == 258)
        v28 = (*(unsigned __int16 *)&v99[2] - 3 < 2) & v28;
      --v22;
    }
    while ((_WORD)v22);
    v36 = 0;
    if (v23 > 0xAu || v23 == 7)
    {
      v38 = v96;
      v37 = WORD2(v96);
      if (v23 - 32844 >= 2)
        v36 = 1;
    }
    else
    {
      v38 = v96;
      v37 = WORD2(v96);
    }
    v39 = 0;
    if (v24 > 0x7FFDu)
    {
      if ((v24 - 32766 > 7 || ((1 << (v24 + 2)) & 0xA1) == 0)
        && (v24 - 32908 > 0x26 || ((1 << (v24 + 116)) & 0x4000000003) == 0)
        && v24 - 34676 >= 2)
      {
LABEL_110:
        v39 = 1;
      }
    }
    else if (v24 > 8u || v24 == 6)
    {
      goto LABEL_110;
    }
LABEL_81:
    if ((v26 - 1) >= 0xF4240 || !v25 || v25 >= 0xF4241 || v27 > 2)
      goto LABEL_96;
    if (v37 > 2u || v38 > 0x14u)
      v36 = 1;
    if (((v36 | v39) & 1) != 0 || ((v28 ^ 1) & 1) != 0)
    {
LABEL_96:
      v43 = v115;
      if ((unint64_t)v115 >= v116)
      {
        v45 = v114;
        v46 = v115 - v114;
        v47 = v46 + 1;
        if ((unint64_t)(v46 + 1) >> 61)
          goto LABEL_194;
        v48 = v116 - (_QWORD)v114;
        if ((uint64_t)(v116 - (_QWORD)v114) >> 2 > v47)
          v47 = v48 >> 2;
        if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
          v49 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v49 = v47;
        if (v49)
        {
          v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)&v116, v49);
          v45 = v114;
          v43 = v115;
        }
        else
        {
          v50 = 0;
        }
        v51 = (unint64_t *)&v50[8 * v46];
        *v51 = v14;
        v44 = v51 + 1;
        while (v43 != v45)
        {
          v52 = *--v43;
          *--v51 = v52;
        }
        v114 = v51;
        v115 = v44;
        v116 = (unint64_t)&v50[8 * v49];
        if (v45)
          operator delete(v45);
      }
      else
      {
        *v115 = v14;
        v44 = v43 + 1;
      }
      v115 = v44;
      goto LABEL_118;
    }
    if ((v27 & 0xFFFFFFFD) == 0)
    {
      v53 = v121;
      if ((unint64_t)v121 < v122[0])
      {
        *v121 = v14;
        v54 = v53 + 1;
LABEL_157:
        v121 = v54;
        goto LABEL_118;
      }
      v61 = v120;
      v62 = v121 - v120;
      v63 = v62 + 1;
      if (!((unint64_t)(v62 + 1) >> 61))
      {
        v64 = v122[0] - (_QWORD)v120;
        if ((uint64_t)(v122[0] - (_QWORD)v120) >> 2 > v63)
          v63 = v64 >> 2;
        if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8)
          v65 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v65 = v63;
        if (v65)
        {
          v66 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v122, v65);
          v61 = v120;
          v53 = v121;
        }
        else
        {
          v66 = 0;
        }
        v69 = (unint64_t *)&v66[8 * v62];
        *v69 = v14;
        v54 = v69 + 1;
        while (v53 != v61)
        {
          v70 = *--v53;
          *--v69 = v70;
        }
        v120 = v69;
        v121 = v54;
        v122[0] = &v66[8 * v65];
        if (v61)
          operator delete(v61);
        goto LABEL_157;
      }
LABEL_194:
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    v41 = v118;
    if ((unint64_t)v118 < v119)
    {
      *v118 = v14;
      v42 = v41 + 1;
      goto LABEL_150;
    }
    v55 = v117;
    v56 = v118 - v117;
    v57 = v56 + 1;
    if ((unint64_t)(v56 + 1) >> 61)
      goto LABEL_194;
    v58 = v119 - (_QWORD)v117;
    if ((uint64_t)(v119 - (_QWORD)v117) >> 2 > v57)
      v57 = v58 >> 2;
    if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8)
      v59 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v59 = v57;
    if (v59)
    {
      v60 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)&v119, v59);
      v55 = v117;
      v41 = v118;
    }
    else
    {
      v60 = 0;
    }
    v67 = (unint64_t *)&v60[8 * v56];
    *v67 = v14;
    v42 = v67 + 1;
    while (v41 != v55)
    {
      v68 = *--v41;
      *--v67 = v68;
    }
    v117 = v67;
    v118 = v42;
    v119 = (unint64_t)&v60[8 * v59];
    if (v55)
      operator delete(v55);
LABEL_150:
    v118 = v42;
LABEL_118:
    if (*((_QWORD *)&v110 + 1) <= (unint64_t)(v110 - 4))
      v14 = IIOScanner::getTiffOffset((IIOScanner *)&v109);
  }
  while (v14);
LABEL_159:
  v71 = v120;
  v72 = v121;
  v73 = v121 - v120;
  if ((_DWORD)v73)
  {
    v74 = (char *)v95;
    v75 = v92;
    if (((unint64_t)((char *)v121 - (char *)v120) >> 3) != v118 - v117)
      v118 = v117;
    v76 = v121 - v120;
    v77 = (IIOImageRead **)v93;
    a5 = v94;
  }
  else
  {
    v79 = v117;
    v78 = v118;
    if (v118 == v117)
    {
      LODWORD(v76) = 0;
      a5 = v94;
      v74 = (char *)v95;
      v77 = (IIOImageRead **)v93;
      v75 = v92;
    }
    else
    {
      v77 = (IIOImageRead **)v93;
      a5 = v94;
      if ((unint64_t)v121 >= v122[0])
      {
        v81 = v73 + 1;
        v74 = (char *)v95;
        if ((v73 + 1) >> 61)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v82 = v122[0] - (_QWORD)v120;
        if ((uint64_t)(v122[0] - (_QWORD)v120) >> 2 > v81)
          v81 = v82 >> 2;
        v83 = (unint64_t)v82 >= 0x7FFFFFFFFFFFFFF8;
        v84 = 0x1FFFFFFFFFFFFFFFLL;
        if (!v83)
          v84 = v81;
        v75 = v92;
        if (v84)
        {
          v85 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v122, v84);
          v84 = v86;
          v71 = v120;
          v72 = v121;
        }
        else
        {
          v85 = 0;
        }
        v87 = &v85[8 * v73];
        v88 = &v85[8 * v84];
        *(_QWORD *)v87 = *v79;
        v80 = (unint64_t *)(v87 + 8);
        while (v72 != v71)
        {
          v89 = *--v72;
          *((_QWORD *)v87 - 1) = v89;
          v87 -= 8;
        }
        v120 = (unint64_t *)v87;
        v121 = v80;
        v122[0] = v88;
        if (v71)
          operator delete(v71);
      }
      else
      {
        *v121 = *v117;
        v80 = v72 + 1;
        v74 = (char *)v95;
        v75 = v92;
      }
      v121 = v80;
      v78 = v117;
      v71 = v120;
      v73 = v80 - v120;
      LODWORD(v76) = 1;
      v72 = v80;
    }
    v118 = v78;
  }
  v74[8] = v75 == 19789;
  std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(v74 + 16, (char *)v71, (uint64_t)v72, v73);
  std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(v74 + 40, (char *)v117, (uint64_t)v118, v118 - v117);
  IIOImageReadSession::setGlobalInfo(v77, 1414088262, v74, (void (*)(void *))ReleaseTIFFGlobalInfo);
  v90 = 0;
  if (a5)
LABEL_184:
    *a5 = v76;
LABEL_185:
  IIOScanner::~IIOScanner((IIOScanner *)&v109);
  if (v114)
  {
    v115 = v114;
    operator delete(v114);
  }
  if (v117)
  {
    v118 = v117;
    operator delete(v117);
  }
  if (v120)
  {
    v121 = v120;
    operator delete(v120);
  }
  return v90;
}

void sub_187EB8724(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v17;

  __cxa_begin_catch(a1);
  *(_QWORD *)(v17 - 128) = *(_QWORD *)(v17 - 136);
  __cxa_end_catch();
  JUMPOUT(0x187EB86F0);
}

void sub_187EB8798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v33;
  void *v35;
  void *v36;
  void *v37;

  IIOScanner::~IIOScanner((IIOScanner *)&a33);
  v35 = *(void **)(v33 - 160);
  if (v35)
  {
    *(_QWORD *)(v33 - 152) = v35;
    operator delete(v35);
  }
  v36 = *(void **)(v33 - 136);
  if (v36)
  {
    *(_QWORD *)(v33 - 128) = v36;
    operator delete(v36);
  }
  v37 = *(void **)(v33 - 112);
  if (v37)
  {
    *(_QWORD *)(v33 - 104) = v37;
    operator delete(v37);
  }
  _Unwind_Resume(a1);
}

BOOL TIFFReadPlugin::isValidTIFF(TIFFReadPlugin *this)
{
  int Val16;
  int v3;
  int v4;
  unint64_t i;
  _QWORD *v6;
  _QWORD **v7;
  _QWORD *v8;
  _QWORD **v9;
  unint64_t v10;
  _QWORD *v11;
  _BOOL8 v12;
  _DWORD *exception;
  unint64_t v15;
  uint64_t v16;
  __int128 *v17;
  __int128 v18;
  uint64_t *v19;
  _QWORD *v20[2];
  _OWORD v21[2];
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  memset(v21, 0, sizeof(v21));
  IIOScanner::IIOScanner((IIOScanner *)v21, *((IIOImageReadSession **)this + 3));
  v20[0] = 0;
  v20[1] = 0;
  v19 = (uint64_t *)v20;
  IIOScanner::seek((IIOScanner *)v21, *((_QWORD *)this + 24));
  Val16 = IIOScanner::getVal16((IIOScanner *)v21);
  if (Val16 == 18761 || Val16 == 19789)
  {
    GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v21, Val16 == 18761);
    v3 = IIOScanner::getVal16((IIOScanner *)v21);
    if (v3 == 43)
    {
      v4 = IIOScanner::getVal16((IIOScanner *)v21);
      IIOScanner::skip((uint64_t)v21, 2);
    }
    else
    {
      v4 = 4;
    }
    LODWORD(v22) = v4;
    v16 = 0;
    v18 = 0u;
    v17 = &v18;
    IIOScanner::seek((IIOScanner *)v21, *((_QWORD *)this + 24) + 4);
    if (v3 == 43)
      IIOScanner::skip((uint64_t)v21, 4);
    for (i = IIOScanner::getTiffOffset((IIOScanner *)v21); ; i = IIOScanner::getTiffOffset((IIOScanner *)v21))
    {
      v15 = i;
      if (!i)
        break;
      v6 = v20[0];
      if (v20[0])
      {
        v7 = v20;
        do
        {
          v8 = v6;
          v9 = v7;
          v10 = v6[4];
          v11 = v6 + 1;
          if (v10 >= i)
          {
            v11 = v8;
            v7 = (_QWORD **)v8;
          }
          v6 = (_QWORD *)*v11;
        }
        while (v6);
        if (v7 != v20)
        {
          if (v10 < i)
            v8 = v9;
          if (i >= v8[4])
          {
            ++HIWORD(v16);
            break;
          }
        }
      }
      std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(&v19, &v15, (uint64_t *)&v15);
      TIFFReadPlugin::isValidIFD((uint64_t)this, (unint64_t)v21, v3 == 43, v15, (uint64_t)&v16, 0);
      if ((_DWORD)v24)
      {
        exception = __cxa_allocate_exception(4uLL);
        *exception = -1;
        __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
      }
    }
    v12 = (HIWORD(v16) | WORD2(v16)) == 0;
    std::__tree<unsigned long long>::destroy((uint64_t)&v17, (_QWORD *)v18);
  }
  else
  {
    v12 = 0;
  }
  std::__tree<unsigned long long>::destroy((uint64_t)&v19, v20[0]);
  IIOScanner::~IIOScanner((IIOScanner *)v21);
  return v12;
}

unint64_t IIOScanner::getTiffOffset(IIOScanner *this)
{
  if (*((_DWORD *)this + 8) == 4)
    return IIOScanner::getVal32(this);
  else
    return IIOScanner::getVal64(this);
}

uint64_t *std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void GlobalTIFFInfo::GlobalTIFFInfo(GlobalTIFFInfo *this, char a2)
{
  *(_QWORD *)this = &off_1E1BAE138;
  *((_BYTE *)this + 8) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_BYTE *)this + 80) = a2;
}

void SetupTIFFErrorHandler(void)
{
  if ((IIO_XPCServer() & 1) == 0 && SetupTIFFErrorHandler(void)::setupOnce != -1)
    dispatch_once(&SetupTIFFErrorHandler(void)::setupOnce, &__block_literal_global_35);
}

size_t (*_cg_TIFFSetWarningHandler(size_t (*a1)(const char *a1, const char *a2, va_list a3)))(const char *a1, const char *a2, va_list a3)
{
  size_t (*v1)(const char *, const char *, va_list);

  v1 = _TIFFwarningHandler;
  _TIFFwarningHandler = a1;
  return v1;
}

uint64_t ___ZL25_CFDataCreateWithProviderP14CGDataProvider_block_invoke()
{
  uint64_t result;

  result = IOPreferencesGetBoolean("ImageIO_CopyInputData", 0, 0);
  gCopyInputData = result;
  return result;
}

uint64_t ___ZN12IIOImageRead14CreateWithDataEPK8__CFDatab_block_invoke()
{
  uint64_t result;

  result = IOPreferencesGetBoolean("ImageIO_CopyInputData", 0, 0);
  gCopyInputData = result;
  return result;
}

uint64_t IOPreferencesGetBoolean(const char *a1, uint64_t a2, BOOL *a3)
{
  char *v6;
  const char *v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  CFTypeID v11;
  BOOL v12;
  CFComparisonResult v13;
  int valuePtr;

  v6 = getenv(a1);
  if (v6)
  {
    v7 = v6;
    if (!strcasecmp(v6, "YES"))
      a2 = 1;
    else
      a2 = strcasecmp(v7, "NO") && atoi(v7) != 0;
    v12 = 1;
    goto LABEL_28;
  }
  v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x600u);
  if (!v8)
  {
    v12 = 0;
    goto LABEL_28;
  }
  v9 = v8;
  v10 = (const __CFString *)CFPreferencesCopyAppValue(v8, (CFStringRef)*MEMORY[0x1E0C9B248]);
  if (!v10)
  {
    v10 = (const __CFString *)CFPreferencesCopyValue(v9, CFSTR("com.apple.ImageIO"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
    if (!v10)
    {
      v12 = 0;
      goto LABEL_27;
    }
  }
  v11 = CFGetTypeID(v10);
  if (v11 != CFBooleanGetTypeID())
  {
    if (v11 == CFNumberGetTypeID())
    {
      if (!CFNumberIsFloatType((CFNumberRef)v10))
      {
        valuePtr = 0;
        CFNumberGetValue((CFNumberRef)v10, kCFNumberIntType, &valuePtr);
        a2 = valuePtr != 0;
        goto LABEL_10;
      }
    }
    else if (v11 == CFStringGetTypeID())
    {
      v12 = 1;
      if (CFStringCompare(v10, CFSTR("YES"), 1uLL))
      {
        v12 = 1;
        if (CFStringCompare(v10, CFSTR("NO"), 1uLL))
        {
          v12 = 1;
          if (CFStringCompare(v10, CFSTR("1"), 1uLL))
          {
            v13 = CFStringCompare(v10, CFSTR("0"), 1uLL);
            v12 = v13 == kCFCompareEqualTo;
            if (v13)
              a2 = a2;
            else
              a2 = 0;
          }
          else
          {
            a2 = 1;
          }
        }
        else
        {
          a2 = 0;
        }
      }
      else
      {
        a2 = 1;
      }
      goto LABEL_26;
    }
    v12 = 0;
    goto LABEL_26;
  }
  a2 = v10 == (const __CFString *)*MEMORY[0x1E0C9AE50];
LABEL_10:
  v12 = 1;
LABEL_26:
  CFRelease(v10);
LABEL_27:
  CFRelease(v9);
LABEL_28:
  if (a3)
    *a3 = v12;
  return a2;
}

void CGImageSourceUpdateData(CGImageSourceRef isrc, CFDataRef data, BOOL final)
{
  _BOOL8 v3;
  const UInt8 *BytePtr;
  CFIndex Length;
  const char *v8;
  __darwin_ct_rune_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  CFTypeID v27;
  CFTypeID v28;
  uint64_t v29;
  IIO_Reader *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  const char *v42;
  CFIndex v43;
  char __str[16];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v3 = final;
  v49 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  IIOInitDebugFlags();
  if ((gIIODebugFlags & 0x3000) == 0)
    goto LABEL_50;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  *(_OWORD *)__str = 0u;
  if (!data || CFDataGetLength(data) < 9)
  {
    strcpy(__str, "(NULL)");
    goto LABEL_48;
  }
  BytePtr = CFDataGetBytePtr(data);
  Length = CFDataGetLength(data);
  v8 = "NO ";
  if (v3)
    v8 = "YES";
  v42 = v8;
  v43 = Length;
  v9 = *BytePtr;
  v41 = BytePtr[1];
  v40 = BytePtr[2];
  v39 = BytePtr[3];
  v38 = BytePtr[4];
  v37 = BytePtr[5];
  v36 = BytePtr[6];
  v35 = BytePtr[7];
  v10 = MEMORY[0x1E0C80978];
  if ((v9 & 0x80) != 0)
  {
    if (__maskrune(v9, 0x40000uLL))
      goto LABEL_8;
  }
  else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * *BytePtr + 60) & 0x40000) != 0)
  {
LABEL_8:
    v11 = *BytePtr;
    goto LABEL_12;
  }
  v11 = 46;
LABEL_12:
  v34 = v11;
  v12 = BytePtr[1];
  if ((char)BytePtr[1] < 0)
  {
    if (__maskrune(v12, 0x40000uLL))
      goto LABEL_14;
  }
  else if ((*(_DWORD *)(v10 + 4 * v12 + 60) & 0x40000) != 0)
  {
LABEL_14:
    v13 = BytePtr[1];
    goto LABEL_17;
  }
  v13 = 46;
LABEL_17:
  v33 = v13;
  v14 = BytePtr[2];
  if ((char)BytePtr[2] < 0)
  {
    if (__maskrune(v14, 0x40000uLL))
      goto LABEL_19;
  }
  else if ((*(_DWORD *)(v10 + 4 * v14 + 60) & 0x40000) != 0)
  {
LABEL_19:
    v15 = BytePtr[2];
    goto LABEL_22;
  }
  v15 = 46;
LABEL_22:
  v32 = v15;
  v16 = BytePtr[3];
  if ((char)BytePtr[3] < 0)
  {
    if (__maskrune(v16, 0x40000uLL))
      goto LABEL_24;
  }
  else if ((*(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000) != 0)
  {
LABEL_24:
    v17 = BytePtr[3];
    goto LABEL_27;
  }
  v17 = 46;
LABEL_27:
  v31 = v17;
  v18 = BytePtr[4];
  if ((char)BytePtr[4] < 0)
  {
    if (__maskrune(v18, 0x40000uLL))
      goto LABEL_29;
  }
  else if ((*(_DWORD *)(v10 + 4 * v18 + 60) & 0x40000) != 0)
  {
LABEL_29:
    v19 = BytePtr[4];
    goto LABEL_32;
  }
  v19 = 46;
LABEL_32:
  v20 = BytePtr[5];
  if ((char)BytePtr[5] < 0)
  {
    if (__maskrune(v20, 0x40000uLL))
      goto LABEL_34;
  }
  else if ((*(_DWORD *)(v10 + 4 * v20 + 60) & 0x40000) != 0)
  {
LABEL_34:
    v21 = BytePtr[5];
    goto LABEL_37;
  }
  v21 = 46;
LABEL_37:
  v22 = BytePtr[6];
  if ((char)BytePtr[6] < 0)
  {
    if (__maskrune(v22, 0x40000uLL))
      goto LABEL_39;
  }
  else if ((*(_DWORD *)(v10 + 4 * v22 + 60) & 0x40000) != 0)
  {
LABEL_39:
    v23 = BytePtr[6];
    goto LABEL_42;
  }
  v23 = 46;
LABEL_42:
  v24 = BytePtr[7];
  if ((char)BytePtr[7] < 0)
  {
    if (__maskrune(v24, 0x40000uLL))
      goto LABEL_44;
LABEL_46:
    v25 = 46;
    goto LABEL_47;
  }
  if ((*(_DWORD *)(v10 + 4 * v24 + 60) & 0x40000) == 0)
    goto LABEL_46;
LABEL_44:
  v25 = BytePtr[7];
LABEL_47:
  snprintf(__str, 0x50uLL, "[%p]-(%ld) final:%s  | %02X %02X %02X %02X  %02X %02X %02X %02X | %c%c%c%c %c%c%c%c", data, v43, v42, v9, v41, v40, v39, v38, v37, v36, v35, v34, v33, v32, v31, v19,
    v21,
    v23,
    v25);
LABEL_48:
  v26 = (gIIODebugFlags >> 12) & 3;
  if (v26)
    ImageIODebugOptions(v26, "A", "CGImageSourceUpdateData", isrc, __str, -1, 0);
LABEL_50:
  if (isrc)
  {
    if (data)
    {
      v27 = CFGetTypeID(isrc);
      if (CGImageSourceGetTypeID::once != -1)
        dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
      if (v27 == CGImageSourceGetTypeID::id)
      {
        v28 = CFGetTypeID(data);
        if (v28 == CFDataGetTypeID())
        {
          v29 = *((_QWORD *)isrc + 3);
          if (v29 && !IIOImageSource::isProxy((IIOImageSource *)v29))
          {
            pthread_mutex_lock((pthread_mutex_t *)(v29 + 200));
            IIOImageSource::updateData((IIOImageSource *)v29, data, (__CFData *)v3);
            v30 = *(IIO_Reader **)(v29 + 80);
            if (v30)
              IIO_Reader::osType(v30);
            pthread_mutex_unlock((pthread_mutex_t *)(v29 + 200));
          }
        }
        else
        {
          LogError("CGImageSourceUpdateData", 4698, "*** ERROR: CGImageSourceUpdateData: data is not a CFDataRef\n");
        }
      }
      else
      {
        LogError("CGImageSourceUpdateData", 4697, "*** ERROR: CGImageSourceUpdateData: source is not a CGImageSourceRef\n");
      }
    }
    else
    {
      LogError("CGImageSourceUpdateData", 4696, "*** ERROR: CGImageSourceUpdateData: data is nil\n");
    }
  }
  else
  {
    LogError("CGImageSourceUpdateData", 4695, "*** ERROR: CGImageSourceUpdateData: source is nil\n");
  }
  kdebug_trace();
}

const char *IIOImageSource::updateData(IIOImageSource *this, const __CFData *a2, __CFData *a3)
{
  IIOImageRead *Source;
  IIOImageRead *v7;
  const char *result;
  const char *v9;
  unint64_t v10;

  Source = (IIOImageRead *)CGImageSourceGetSource(*((_QWORD *)this + 2));
  v7 = Source;
  if (Source && IIOImageRead::isFinal(Source))
    return LogError("updateData", 833, "*** ERROR: image source was already finalized\n");
  if ((gIIODebugFlags & 0x10000000) != 0)
  {
    if ((_DWORD)a3)
      v9 = "imageDataProg-final";
    else
      v9 = "imageDataProg-part";
    ImageIO_saveImageData(v9, a2);
  }
  if (v7)
  {
    v10 = *((_QWORD *)this + 5);
    result = (const char *)CFDataGetLength(a2);
    if (v10 > (unint64_t)result)
      goto LABEL_20;
    *((_QWORD *)this + 5) = CFDataGetLength(a2);
    result = (const char *)IIOImageRead::updateData(v7, a2, (int)a3);
    if ((gIIODebugFlags & 0x2000000000) != 0)
    {
      if (a2)
        CFDataGetLength(a2);
      result = ImageIOLog("    %s - update - isr=%p  rref=%p  data=%p  size=%8ld  final=%s\n");
    }
  }
  else
  {
    *((_QWORD *)this + 5) = CFDataGetLength(a2);
    result = (const char *)CGImageReadCreateWithData(*((_QWORD *)this + 1), a2, a3);
    *((_QWORD *)this + 2) = result;
    if ((gIIODebugFlags & 0x2000000000) != 0)
    {
      if (a2)
        CFDataGetLength(a2);
      result = ImageIOLog("    %s - new    - isr=%p  rref=%p  data=%p  size=%8ld  final=%s\n");
    }
  }
  *((_WORD *)this + 16) = 256;
LABEL_20:
  if ((_DWORD)a3)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
    *((_DWORD *)this + 22) = 0;
    return (const char *)pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
  }
  return result;
}

uint64_t IIOImageRead::updateData(IIOImageRead *this, const __CFData *a2, int a3)
{
  pthread_mutex_t *v6;
  const void *v7;
  const void *v8;
  CFIndex Length;

  v6 = (pthread_mutex_t *)((char *)this + 376);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  v7 = (const void *)*((_QWORD *)this + 5);
  if (v7)
    CFRelease(v7);
  v8 = (const void *)*((_QWORD *)this + 4);
  *((_QWORD *)this + 5) = 0;
  if (a2)
  {
    *((_QWORD *)this + 4) = CFRetain(a2);
    Length = CFDataGetLength(a2);
  }
  else
  {
    Length = 0;
    *((_QWORD *)this + 4) = 0;
  }
  *((_QWORD *)this + 10) = Length;
  *((_BYTE *)this + 64) = a3;
  if (a3)
    *((_BYTE *)this + 65) = 0;
  if (v8)
    CFRelease(v8);
  return pthread_mutex_unlock(v6);
}

uint64_t png_handle_bKGD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  int v6;
  const char *v7;
  uint64_t result;
  int v9;
  int v10;
  int v11;
  unsigned __int8 *v12;
  __int16 v13;
  unsigned int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  __int16 v22;

  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v4 & 4) != 0 || (v6 = *(unsigned __int8 *)(a1 + 391), (v4 & 2) == 0) && v6 == 3)
  {
    png_crc_finish(a1, a3);
    v7 = "out of place";
    return png_chunk_benign_error(a1, v7);
  }
  if (a2 && (*(_BYTE *)(a2 + 8) & 0x20) != 0)
  {
    png_crc_finish(a1, a3);
    v7 = "duplicate";
    return png_chunk_benign_error(a1, v7);
  }
  if ((v6 & 2) != 0)
    v9 = 6;
  else
    v9 = 2;
  if (v6 == 3)
    v10 = 1;
  else
    v10 = v9;
  if (v10 != (_DWORD)a3)
  {
    png_crc_finish(a1, a3);
    v7 = "invalid";
    return png_chunk_benign_error(a1, v7);
  }
  v22 = 0;
  v21 = 0;
  v19 = 0;
  v20 = 0;
  png_crc_read(a1, (Bytef *)&v21, a3);
  result = png_crc_finish(a1, 0);
  if (!(_DWORD)result)
  {
    v11 = *(unsigned __int8 *)(a1 + 391);
    if (v11 == 3)
    {
      LOBYTE(v19) = v21;
      if (!a2 || !*(_WORD *)(a2 + 32))
      {
        HIWORD(v19) = 0;
        *(_DWORD *)((char *)&v19 + 2) = 0;
LABEL_40:
        v20 = 0;
        return png_set_bKGD(a1, a2, (uint64_t)&v19);
      }
      if (*(unsigned __int16 *)(a2 + 32) > v21)
      {
        v12 = (unsigned __int8 *)(*(_QWORD *)(a1 + 368) + 3 * v21);
        WORD1(v19) = *v12;
        WORD2(v19) = v12[1];
        v13 = v12[2];
LABEL_39:
        HIWORD(v19) = v13;
        goto LABEL_40;
      }
      v16 = "invalid index";
      return png_chunk_benign_error(a1, v16);
    }
    v14 = *(unsigned __int8 *)(a1 + 392);
    if ((v11 & 2) == 0)
    {
      if (v14 >= 9)
      {
        v15 = BYTE1(v21);
      }
      else if ((_BYTE)v21 || (v15 = BYTE1(v21), BYTE1(v21) >> v14))
      {
        v16 = "invalid gray level";
        return png_chunk_benign_error(a1, v16);
      }
      LOBYTE(v19) = 0;
      v20 = v15 | (v21 << 8);
      HIWORD(v19) = v20;
      WORD2(v19) = v20;
      WORD1(v19) = v20;
      return png_set_bKGD(a1, a2, (uint64_t)&v19);
    }
    if (v14 >= 9)
    {
      v18 = BYTE2(v21);
      v17 = v22;
    }
    else
    {
      if ((_BYTE)v21 || BYTE2(v21) || (v17 = v22, (_BYTE)v22))
      {
        v16 = "invalid color";
        return png_chunk_benign_error(a1, v16);
      }
      v18 = 0;
    }
    LOBYTE(v19) = 0;
    WORD1(v19) = _byteswap_ushort(v21);
    WORD2(v19) = HIBYTE(v21) | (unsigned __int16)(v18 << 8);
    v13 = HIBYTE(v22) | (unsigned __int16)(v17 << 8);
    goto LABEL_39;
  }
  return result;
}

uint64_t png_set_bKGD(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2)
  {
    if (a3)
    {
      *(_QWORD *)(a2 + 202) = *(_QWORD *)a3;
      *(_WORD *)(a2 + 210) = *(_WORD *)(a3 + 8);
      *(_DWORD *)(a2 + 8) |= 0x20u;
    }
  }
  return result;
}

double ___ZL21sDefaultErrorCallbackv_block_invoke()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  *(_QWORD *)(v0 + 8) = 1;
  *(_BYTE *)(v0 + 16) = 0;
  *(_QWORD *)v0 = off_1E1BBC028;
  result = 0.0;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 56) = 0u;
  qword_1ECDD91C8 = v0;
  return result;
}

double ___ZL21sDefaultErrorCallbackv_block_invoke_0()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  *(_QWORD *)&result = 1;
  *(_QWORD *)(v0 + 8) = 1;
  *(_BYTE *)(v0 + 16) = 0;
  *(_QWORD *)v0 = &off_1E1BBBFF8;
  *(_QWORD *)(v0 + 32) = 0;
  *(_QWORD *)(v0 + 40) = 0;
  *(_QWORD *)(v0 + 24) = 0;
  gDefaultErrorCallback = v0;
  return result;
}

void IIOIOSurfaceWrapper::~IIOIOSurfaceWrapper(IIOIOSurfaceWrapper *this)
{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(this);
  JUMPOUT(0x18D761C30);
}

uint64_t AppleJPEGReadPlugin::createImageBlockSetWithHardwareDecode(unsigned __int8 *a1, const void *a2, uint64_t a3, const __CFDictionary *a4, int *a5)
{
  unsigned int Uint32ForKey;
  int v11;
  int v12;
  uint64_t ImageBlockFromIOSurface;
  _BYTE v15[16];
  void *value;
  _QWORD v17[3];
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __IOSurface *v21;

  v21 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v18);
  memset(v17, 0, sizeof(v17));
  IIODictionary::IIODictionary((IIODictionary *)v17, a4);
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v17, CFSTR("kCGImageSurfaceFormatRequest"));
  v11 = a1[405];
  if (Uint32ForKey == 875704422)
    _cg_jpeg_mem_term("createImageBlockSetWithHardwareDecode", 4082, "    requested '420f' format will be ignored (creating a monochrome/RGBx blockset)\n");
  if (v11)
    IIONumber::IIONumber((IIONumber *)v15, 1380401729);
  else
    IIONumber::IIONumber((IIONumber *)v15, 1111970369);
  IIODictionary::setObjectForKey((IIODictionary *)&v18, value, CFSTR("kCGImageSurfaceFormatRequest"));
  IIONumber::~IIONumber((IIONumber *)v15);
  v12 = (*(uint64_t (**)(unsigned __int8 *, uint64_t, uint64_t, __IOSurface **, _QWORD))(*(_QWORD *)a1 + 216))(a1, a3, v19, &v21, 0);
  if (v12)
    _cg_jpeg_mem_term("createImageBlockSetWithHardwareDecode", 4095, "*** ERROR: copyIOSurfaceImp returned: %d\n", v12);
  if (!v21)
  {
    ImageBlockFromIOSurface = 0;
    if (!a5)
      goto LABEL_11;
    goto LABEL_10;
  }
  ImageBlockFromIOSurface = AppleJPEGReadPlugin::createImageBlockFromIOSurface((uint64_t)a1, v21, a2, a3);
  IIO_IOSurfaceRelease(v21);
  if (a5)
LABEL_10:
    *a5 = v12;
LABEL_11:
  IIODictionary::~IIODictionary((IIODictionary *)v17);
  IIODictionary::~IIODictionary((IIODictionary *)&v18);
  return ImageBlockFromIOSurface;
}

void sub_187EB9AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  va_list va1;
  uint64_t v10;
  uint64_t v11;
  va_list va2;

  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v8 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  _Unwind_Resume(a1);
}

void IIO_IOSurfaceRelease(__IOSurface *a1)
{
  CFTypeRef v2;
  const void *v3;
  void *BaseAddress;
  size_t AllocSize;

  if (a1)
  {
    if (CFGetRetainCount(a1) == 1)
    {
      v2 = IOSurfaceCopyValue(a1, CFSTR("com.apple.ImageIO.ImageIO_Malloced"));
      if (v2)
      {
        v3 = v2;
        BaseAddress = IOSurfaceGetBaseAddress(a1);
        AllocSize = IOSurfaceGetAllocSize(a1);
        if (BaseAddress)
          _ImageIO_Free((unint64_t)BaseAddress, AllocSize);
        CFRelease(v3);
      }
    }
    CFRelease(a1);
  }
}

uint64_t IIO_UpdateIOSurfaceOwnershipIdentity(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;

  v3 = IIO_XPCServer();
  v4 = 0;
  if (a2)
  {
    if (v3)
    {
      v4 = IOSurfaceSetOwnershipIdentity();
      if ((_DWORD)v4)
        _cg_jpeg_mem_term("IIO_UpdateIOSurfaceOwnershipIdentity", 340, "*** ERROR: IOSurfaceSetOwnershipIdentity failed: %d", v4);
    }
  }
  return v4;
}

uint64_t AppleJPEGReadPlugin::createImageBlockFromIOSurface(uint64_t a1, __IOSurface *a2, const void *a3, uint64_t a4)
{
  vImagePixelCount v8;
  vImagePixelCount v9;
  size_t v10;
  int v11;
  uint64_t v12;
  size_t PlaneCount;
  char *BaseAddressOfPlane;
  vImagePixelCount HeightOfPlane;
  size_t BytesPerRowOfPlane;
  unint64_t v17;
  size_t v18;
  void *v19;
  int *v20;
  vImage_Error v21;
  vImage_Error v22;
  const char *v23;
  const void *v24;
  int v25;
  size_t v26;
  char *v27;
  double v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  double v33;
  double v34;
  unint64_t v35;
  int v37;
  uint64_t v38;
  vImagePixelCount WidthOfPlane;
  const void *v40;
  char *__dst;
  vImage_Buffer dest;
  vImage_Buffer srcCbCr;
  vImage_Buffer srcYp;
  int v45;
  int v46;
  size_t v47[2];
  CGRect v48;
  CGRect v49;

  v47[0] = 0;
  v8 = *(unsigned int *)(a1 + 292);
  v9 = *(unsigned int *)(a1 + 296);
  v10 = *(unsigned int *)(a1 + 300);
  v46 = 197121;
  v45 = 66051;
  v11 = *(unsigned __int8 *)(a1 + 405);
  *(_DWORD *)(a1 + 104) = 1;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, 1uLL);
  v12 = 0;
  if (IOSurfaceLock(a2, 1u, 0))
    return v12;
  v40 = a3;
  PlaneCount = IOSurfaceGetPlaneCount(a2);
  __dst = (char *)_ImageIO_Malloc(v10 * (unint64_t)v9, *(_QWORD *)(a1 + 384), v47, (uint64_t)kImageMalloc_APPLEJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
  if (__dst)
  {
    v37 = v11;
    v38 = a4;
    BaseAddressOfPlane = (char *)IOSurfaceGetBaseAddressOfPlane(a2, 0);
    HeightOfPlane = IOSurfaceGetHeightOfPlane(a2, 0);
    WidthOfPlane = IOSurfaceGetWidthOfPlane(a2, 0);
    BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a2, 0);
    v18 = BytesPerRowOfPlane;
    if (PlaneCount < 2)
    {
      if (HeightOfPlane == v9 && WidthOfPlane == v8)
      {
        v19 = __dst;
        if (BytesPerRowOfPlane == v10)
        {
          memcpy(__dst, BaseAddressOfPlane, v10 * (unint64_t)v9);
        }
        else
        {
          if (BytesPerRowOfPlane >= v10)
            v26 = v10;
          else
            v26 = BytesPerRowOfPlane;
          if ((_DWORD)v9)
          {
            v27 = __dst;
            do
            {
              memcpy(v27, BaseAddressOfPlane, v26);
              BaseAddressOfPlane += v18;
              v27 += v10;
              LODWORD(v9) = v9 - 1;
            }
            while ((_DWORD)v9);
          }
        }
      }
      else
      {
        srcYp.data = BaseAddressOfPlane;
        srcYp.height = HeightOfPlane;
        srcYp.width = WidthOfPlane;
        srcYp.rowBytes = BytesPerRowOfPlane;
        v19 = __dst;
        srcCbCr.data = __dst;
        srcCbCr.height = v9;
        srcCbCr.width = v8;
        srcCbCr.rowBytes = v10;
        v25 = *(_DWORD *)(a1 + 324);
        if (v25 == 1196573017)
        {
          vImageScale_Planar8(&srcYp, &srcCbCr, 0, 0);
        }
        else if (v25 == 1380401696)
        {
          vImageScale_ARGB8888(&srcYp, &srcCbCr, 0, 0);
        }
      }
    }
    else
    {
      srcYp.data = BaseAddressOfPlane;
      srcYp.height = HeightOfPlane;
      srcYp.width = WidthOfPlane;
      srcYp.rowBytes = BytesPerRowOfPlane;
      srcCbCr.data = IOSurfaceGetBaseAddressOfPlane(a2, 1uLL);
      srcCbCr.height = IOSurfaceGetHeightOfPlane(a2, 1uLL);
      srcCbCr.width = IOSurfaceGetWidthOfPlane(a2, 1uLL);
      srcCbCr.rowBytes = IOSurfaceGetBytesPerRowOfPlane(a2, 1uLL);
      dest.width = v8;
      dest.rowBytes = v10;
      v19 = __dst;
      dest.data = __dst;
      dest.height = v9;
      if (AppleJPEGReadPlugin::createImageBlockFromIOSurface(__IOSurface *,InfoRec *,CGImageProvider *)::YpCbCrToARGBCreate != -1)
        dispatch_once(&AppleJPEGReadPlugin::createImageBlockFromIOSurface(__IOSurface *,InfoRec *,CGImageProvider *)::YpCbCrToARGBCreate, &__block_literal_global_160);
      if (v37)
        v20 = &v46;
      else
        v20 = &v45;
      v21 = vImageConvert_420Yp8_CbCr8ToARGB8888(&srcYp, &srcCbCr, &dest, &AppleJPEGReadPlugin::createImageBlockFromIOSurface(__IOSurface *,InfoRec *,CGImageProvider *)::conversion, (const uint8_t *)v20, 0xFFu, 0);
      if (v21)
      {
        v22 = v21;
        v23 = IIO_vImageErrorString(v21);
        _cg_jpeg_mem_term("createImageBlockFromIOSurface", 4033, "*** ERROR: vImageConvert_420Yp8_CbCr8ToARGB8888 returned %ld (%s)\n", v22, v23);
        a4 = v38;
        v24 = a3;
LABEL_31:
        v12 = 0;
        if (a4)
        {
          v35 = *(unsigned int *)(a1 + 104);
          if ((_DWORD)v35)
            v12 = IIOReadPlugin::imageBlockSetCreate(a1, a4, v35, *(double *)(a1 + 136), *(double *)(a1 + 144), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), v24);
        }
        IOSurfaceUnlock(a2, 1u, 0);
        if (v19)
          _ImageIO_Free((unint64_t)v19, v47[0]);
        goto LABEL_36;
      }
    }
    LODWORD(v17) = *(_DWORD *)(a1 + 292);
    v28 = (double)v17;
    LODWORD(v17) = *(_DWORD *)(a1 + 296);
    v29 = (double)v17;
    v30 = 0;
    v48.origin.x = 0.0;
    v48.origin.y = 0.0;
    v48.size.width = v28;
    v48.size.height = v29;
    **(_QWORD **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v19, v47[0], v48, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
    if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
    {
      v31 = 0;
    }
    else
    {
      v49.origin.x = 0.0;
      v49.origin.y = 0.0;
      v49.size.width = v28;
      v49.size.height = v29;
      *(CGRect *)(&v31 - 1) = CGRectUnion(*(CGRect *)(a1 + 120), v49);
      v30 = v32;
      v28 = v33;
      v29 = v34;
    }
    a4 = v38;
    v24 = v40;
    v19 = 0;
    *(_QWORD *)(a1 + 120) = v30;
    *(_QWORD *)(a1 + 128) = v31;
    *(double *)(a1 + 136) = v28;
    *(double *)(a1 + 144) = v29;
    goto LABEL_31;
  }
  v12 = 0;
LABEL_36:
  if (a4)
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  return v12;
}

uint64_t IIODecodingSetAllowableTypes(const void *a1)
{
  uint64_t v1;
  CFTypeID v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v1 = 4294967246;
  v9 = -50;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFArrayGetTypeID())
    {
      v5[0] = MEMORY[0x1E0C809B0];
      v5[1] = 0x40000000;
      v5[2] = __IIODecodingSetAllowableTypes_block_invoke;
      v5[3] = &unk_1E1BBD118;
      v5[4] = &v6;
      v5[5] = a1;
      if (IIODecodingSetAllowableTypes::onceToken != -1)
        dispatch_once(&IIODecodingSetAllowableTypes::onceToken, v5);
      v1 = *((unsigned int *)v7 + 6);
    }
    else
    {
      v1 = 4294967246;
      *((_DWORD *)v7 + 6) = -50;
    }
  }
  _Block_object_dispose(&v6, 8);
  return v1;
}

void sub_187EBA0F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_187EBA1C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t ___Z22hardware_supports_astcv_block_invoke()
{
  uint64_t result;

  result = MGGetBoolAnswer();
  hardware_supports_astc(void)::supportsASTC = result;
  return result;
}

uint64_t displayCheck(void)
{
  uint64_t result;

  result = MGGetBoolAnswer();
  gIsWideGamutDisplay = result;
  return result;
}

uint64_t TIFFReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  IIOImageRead **v20;
  _BOOL4 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  IIOImageRead *v30;
  void *BaseAddress;
  int BlockArray;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  size_t v38;
  void *v39;
  char *v40;
  __int128 v41;
  __int128 v42;
  char *v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  char *v48;
  char *v49;
  __int128 v50;
  __int128 v51;
  char *v52;
  __int128 v53;
  __int128 v54;
  char *v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t *v60;
  unint64_t *v61;
  const char **v62;
  unsigned int *v64;
  unsigned int *v65;
  CGRect *v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;
  IOSurfaceRef *v72;
  _QWORD block[6];
  void *__p;
  void *v75;
  uint64_t v76;
  IIOImageRead *v77;
  __int128 v78;
  __int128 v79;
  unint64_t v80;
  char *v81;
  char *v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t v86;
  int v87;
  CGRect v88;
  CGRect v89;

  v84 = 0;
  v85 = &v84;
  v86 = 0x2000000000;
  v87 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v8 = *((_DWORD *)this + 51);
    v9 = v8 >> 24;
    v10 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v11 = __maskrune(v9, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    }
    if (v11)
      v12 = (v8 >> 24);
    else
      v12 = 46;
    v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v14 = __maskrune(v13, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v8 << 8 >> 24);
    else
      v15 = 46;
    v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = ((__int16)v8 >> 8);
    else
      v18 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      v19 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, (char)v19, iioTypeStr[a3], "virtual OSStatus TIFFReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    LOBYTE(v19) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  if (!*((_BYTE *)this + 414))
  {
    v22 = 4294967115;
    goto LABEL_80;
  }
  v20 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v20)
  {
    v21 = IIOImageReadSession::mapData(v20);
    v20 = (IIOImageRead **)*((_QWORD *)this + 3);
  }
  else
  {
    v21 = 0;
  }
  v30 = IIOImageReadSession::globalInfoForType((IIOImageReadSession *)v20, 1414088262);
  if (v30)
  {
    if (a3 == 3)
    {
      TIFFReadPlugin::calculateBlockCount(this);
      BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
      v72 = a4;
      *((_DWORD *)v85 + 6) = BlockArray;
      v78 = 0uLL;
      if (*((_DWORD *)this + 26))
      {
        v33 = 0;
        v34 = 0;
        while (1)
        {
          *(_QWORD *)&v79 = __PAIR64__(v33, v34);
          v35 = *((_DWORD *)this + 27);
          v36 = *((_DWORD *)this + 74);
          if (v35 + v33 > v36)
            v35 = v36 - v33;
          v33 += v35;
          *((_QWORD *)&v79 + 1) = __PAIR64__(*((_DWORD *)this + 73), v33);
          v37 = *((_DWORD *)this + 75);
          v80 = __PAIR64__(v37, v35);
          v38 = v37 * (unint64_t)v35;
          v39 = (void *)_ImageIO_Malloc(v38, *((_QWORD *)this + 48), (size_t *)&v78 + 1, (uint64_t)kImageMalloc_TIFF_Data[0], *((_DWORD *)this + 108), 0, 0);
          *(_QWORD *)&v78 = v39;
          if (!v39)
            break;
          memset(v39, 255, v38);
          v40 = v82;
          if ((unint64_t)v82 >= v83)
          {
            v44 = v81;
            v45 = 0xCCCCCCCCCCCCCCCDLL * ((v82 - v81) >> 3);
            v46 = v45 + 1;
            if (v45 + 1 > 0x666666666666666)
              std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
            if (0x999999999999999ALL * ((uint64_t)(v83 - (_QWORD)v81) >> 3) > v46)
              v46 = 0x999999999999999ALL * ((uint64_t)(v83 - (_QWORD)v81) >> 3);
            if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v83 - (_QWORD)v81) >> 3) >= 0x333333333333333)
              v47 = 0x666666666666666;
            else
              v47 = v46;
            if (v47)
            {
              v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>((uint64_t)&v83, v47);
              v44 = v81;
              v40 = v82;
            }
            else
            {
              v48 = 0;
            }
            v49 = &v48[40 * v45];
            v50 = v78;
            v51 = v79;
            *((_QWORD *)v49 + 4) = v80;
            *(_OWORD *)v49 = v50;
            *((_OWORD *)v49 + 1) = v51;
            if (v40 == v44)
            {
              v55 = &v48[40 * v45];
            }
            else
            {
              v52 = &v48[40 * v45];
              do
              {
                v53 = *(_OWORD *)(v40 - 40);
                v54 = *(_OWORD *)(v40 - 24);
                v55 = v52 - 40;
                *((_QWORD *)v52 - 1) = *((_QWORD *)v40 - 1);
                *(_OWORD *)(v52 - 24) = v54;
                *(_OWORD *)(v52 - 40) = v53;
                v40 -= 40;
                v52 -= 40;
              }
              while (v40 != v44);
            }
            v43 = v49 + 40;
            v81 = v55;
            v82 = v49 + 40;
            v83 = (unint64_t)&v48[40 * v47];
            if (v44)
              operator delete(v44);
          }
          else
          {
            v41 = v78;
            v42 = v79;
            *((_QWORD *)v82 + 4) = v80;
            *(_OWORD *)v40 = v41;
            *((_OWORD *)v40 + 1) = v42;
            v43 = v40 + 40;
          }
          v82 = v43;
          if (++v34 >= *((_DWORD *)this + 26))
            goto LABEL_61;
        }
        BaseAddress = 0;
        a3 = 3;
        goto LABEL_67;
      }
LABEL_61:
      BaseAddress = 0;
      a3 = 3;
      a4 = v72;
      goto LABEL_63;
    }
    if (a3 != 1)
    {
      BaseAddress = 0;
      goto LABEL_63;
    }
    if (a4 && *a4)
    {
      IOSurfaceLock(*a4, 0, 0);
      BaseAddress = IOSurfaceGetBaseAddress(*a4);
      IOSurfaceGetHeight(*a4);
      IOSurfaceGetBytesPerRow(*a4);
LABEL_63:
      v56 = 0xCCCCCCCCCCCCCCCDLL * ((v82 - v81) >> 3);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 1174405120;
      block[2] = ___ZN14TIFFReadPlugin14decodeImageImpEP18IIODecodeParameter12IIOImageTypePP11__IOSurfacePP10__CVBufferPP15CGImageBlockSet_block_invoke;
      block[3] = &unk_1E1BBCF38;
      block[5] = this;
      __p = 0;
      v75 = 0;
      v76 = 0;
      std::vector<IIODecodeInfo>::__init_with_size[abi:ne180100]<IIODecodeInfo*,IIODecodeInfo*>(&__p, v81, (uint64_t)v82, v56);
      v77 = v30;
      block[4] = &v84;
      dispatch_apply(v56, 0, block);
      if (__p)
      {
        v75 = __p;
        operator delete(__p);
      }
      if (*((_DWORD *)v85 + 6))
      {
        *((_DWORD *)this + 26) = 0;
      }
      else if (a3 == 3)
      {
        v64 = (unsigned int *)v81;
        v65 = (unsigned int *)v82;
        if (v81 != v82)
        {
          v66 = (CGRect *)MEMORY[0x1E0C9D628];
          do
          {
            LODWORD(v57) = v64[5];
            v67 = (double)v57;
            LODWORD(v57) = v64[7];
            LODWORD(v58) = v64[8];
            v68 = (double)v57;
            v69 = (double)v58;
            v88.origin.x = 0.0;
            v88.origin.y = v67;
            v88.size.width = v68;
            v88.size.height = v69;
            *(_QWORD *)(*((_QWORD *)this + 12) + 8 * v64[4]) = IIOReadPlugin::createImageBlock(this, *(void **)v64, *((_QWORD *)v64 + 1), v88, v64[9], *((unsigned __int8 *)this + 343));
            if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *v66))
            {
              v57 = 0;
            }
            else
            {
              v89.origin.x = 0.0;
              v89.origin.y = v67;
              v89.size.width = v68;
              v89.size.height = v69;
              *(CGRect *)&v57 = CGRectUnion(*(CGRect *)((char *)this + 120), v89);
              v67 = *(double *)&v58;
              v68 = v70;
              v69 = v71;
            }
            *((_QWORD *)this + 15) = v57;
            *((double *)this + 16) = v67;
            *((double *)this + 17) = v68;
            *((double *)this + 18) = v69;
            *(_QWORD *)v64 = 0;
            v64 += 10;
          }
          while (v64 != v65);
        }
      }
      else if (a3 == 1)
      {
        IOSurfaceUnlock(*a4, 0, 0);
      }
      goto LABEL_67;
    }
  }
  else
  {
    _cg_jpeg_mem_term("decodeImageImp", 2230, "*** globalInfoForType('TIFF') failed...\n");
  }
  BaseAddress = 0;
LABEL_67:
  v59 = *((_QWORD *)this + 55);
  if (v59)
  {
    _cg_TIFFClose(v59, v23, v24, v25, v26, v27, v28, v29);
    *((_QWORD *)this + 55) = 0;
  }
  if (a3 == 3 && BaseAddress)
  {
    v60 = (unint64_t *)v81;
    v61 = (unint64_t *)v82;
    while (v60 != v61)
    {
      if (*v60)
        _ImageIO_Free(*v60, v60[1]);
      v60 += 5;
    }
  }
  if (v21)
  {
    v62 = (const char **)*((_QWORD *)this + 3);
    if (v62)
      IIOImageReadSession::unmapData(v62);
  }
  v22 = *((unsigned int *)v85 + 6);
LABEL_80:
  if (v81)
  {
    v82 = v81;
    operator delete(v81);
  }
  _Block_object_dispose(&v84, 8);
  return v22;
}

void sub_187EBA87C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 176);
  if (v3)
  {
    *(_QWORD *)(v1 - 168) = v3;
    operator delete(v3);
  }
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void *_cg_TIFFSetErrorHandlerExt(void *a1)
{
  void *v1;

  v1 = _TIFFerrorHandlerExt;
  _TIFFerrorHandlerExt = a1;
  return v1;
}

size_t (*_cg_TIFFSetErrorHandler(size_t (*a1)(const char *a1, char *a2, va_list a3)))(const char *a1, char *a2, va_list a3)
{
  size_t (*v1)(const char *, char *, va_list);

  v1 = _TIFFerrorHandler;
  _TIFFerrorHandler = a1;
  return v1;
}

os_log_t ___ZL13ImageIOLoggeriPKcS0_iS0_Pc_block_invoke()
{
  const char *v0;
  os_log_t result;

  v0 = getprogname();
  result = os_log_create("com.apple.imageio", v0);
  gIIO_Log = (uint64_t)result;
  return result;
}

void IIOLoadCoreMediaSymbols(void)
{
  if (IIOLoadCoreMediaSymbols(void)::once != -1)
    dispatch_once(&IIOLoadCoreMediaSymbols(void)::once, &__block_literal_global_579);
  if (!gFunc_CMBufferQueueCreate)
    LogFault("IIOLoadCoreMediaSymbols", 826, "*** Failed to load 'CoreMedia' symbols ***\n");
}

uint64_t CGImageSourceEnableRestrictedDecoding()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceEnableRestrictedDecoding", 0, 0, -1, 0);
  return IIOEnableRestrictedDecoding();
}

uint64_t CGImageSourceDisableHardwareDecoding()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceDisableHardwareDecoding", 0, 0, -1, 0);
  return IIODisableHardwareDecoding();
}

uint64_t ___ZN25IIOImagePixelDataProvider24createEncodingTempBufferEPmS0__block_invoke()
{
  uint64_t result;
  unint64_t v1;
  size_t v2;
  size_t v3;
  unint64_t v4;
  int v5;

  v5 = 0;
  v3 = 4;
  v4 = 0;
  v2 = 8;
  result = sysctlbyname("hw.physicalcpu_max", &v5, &v3, 0, 0);
  v1 = 0x100000;
  if (!(_DWORD)result && v3 == 4)
  {
    result = sysctlbyname("hw.l2cachesize", &v4, &v2, 0, 0);
    v1 = 0x100000;
    if (!(_DWORD)result && v2 == 8)
      v1 = v4 >> 1;
  }
  if (v1 >= 0x100000)
    v1 = 0x100000;
  IIOImagePixelDataProvider::createEncodingTempBuffer(unsigned long *,unsigned long *)::recommendedBufferSize = v1;
  return result;
}

uint64_t IIODisableHardwareDecoding()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  kdebug_trace();
  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = -50;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IIODisableHardwareDecoding_block_invoke;
  block[3] = &unk_1E1BC4CD8;
  block[4] = &v3;
  if (IIODisableHardwareDecoding::onceToken != -1)
    dispatch_once(&IIODisableHardwareDecoding::onceToken, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t IIOLoadCMPhotoSymbols(void)
{
  uint64_t result;
  void *v1;
  int v2;
  int APIVersion;
  char __path[72];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  strcpy(__path, "/System/Library/PrivateFrameworks/CMPhoto.framework/CMPhoto");
  result = (uint64_t)dlopen(__path, 257);
  if (result)
  {
    v1 = (void *)result;
    gFunc_CMPhotoCompressionCreateContainerFromImageExt = (uint64_t)dlsym((void *)result, "CMPhotoCompressionCreateContainerFromImageExt");
    if (gFunc_CMPhotoCompressionCreateContainerFromImageExt)
    {
      v2 = 0;
    }
    else
    {
      puts("❌  failed to load 'CMPhotoCompressionCreateContainerFromImageExt' ");
      v2 = 1;
    }
    gFunc_CMPhotoCompressionCreateDataContainerFromImage = (uint64_t)dlsym(v1, "CMPhotoCompressionCreateDataContainerFromImage");
    if (!gFunc_CMPhotoCompressionCreateDataContainerFromImage)
    {
      puts("❌  failed to load 'CMPhotoCompressionCreateDataContainerFromImage' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddAuxiliaryImage = dlsym(v1, "CMPhotoCompressionSessionAddAuxiliaryImage");
    if (!gFunc_CMPhotoCompressionSessionAddAuxiliaryImage)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddAuxiliaryImage' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddAuxiliaryImageFromDictionaryRepresentation = (uint64_t)dlsym(v1, "CMPhotoCompressionSessionAddAuxiliaryImageFromDictionaryRepresentation");
    if (!gFunc_CMPhotoCompressionSessionAddAuxiliaryImageFromDictionaryRepresentation)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddAuxiliaryImageFromDictionaryRepresentation' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddCustomMetadata = dlsym(v1, "CMPhotoCompressionSessionAddCustomMetadata");
    if (!gFunc_CMPhotoCompressionSessionAddCustomMetadata)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddCustomMetadata' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddExif = dlsym(v1, "CMPhotoCompressionSessionAddExif");
    if (!gFunc_CMPhotoCompressionSessionAddExif)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddExif' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddGroup = dlsym(v1, "CMPhotoCompressionSessionAddGroup");
    if (!gFunc_CMPhotoCompressionSessionAddGroup)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddGroup' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddGroupProperties = dlsym(v1, "CMPhotoCompressionSessionAddGroupProperties");
    if (!gFunc_CMPhotoCompressionSessionAddGroupProperties)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddGroupProperties' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddImage = dlsym(v1, "CMPhotoCompressionSessionAddImage");
    if (!gFunc_CMPhotoCompressionSessionAddImage)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddImage' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddImageHandleToGroup = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoCompressionSessionAddImageHandleToGroup");
    if (!gFunc_CMPhotoCompressionSessionAddImageHandleToGroup)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddImageHandleToGroup' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddImageToSequence = dlsym(v1, "CMPhotoCompressionSessionAddImageToSequence");
    if (!gFunc_CMPhotoCompressionSessionAddImageToSequence)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddImageToSequence' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddTmapImageOneShot = dlsym(v1, "CMPhotoCompressionSessionAddTmapImageOneShot");
    if (!gFunc_CMPhotoCompressionSessionAddTmapImageOneShot)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddTmapImageOneShot' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddThumbnail = dlsym(v1, "CMPhotoCompressionSessionAddThumbnail");
    if (!gFunc_CMPhotoCompressionSessionAddThumbnail)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddThumbnail' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionAddXMP = dlsym(v1, "CMPhotoCompressionSessionAddXMP");
    if (!gFunc_CMPhotoCompressionSessionAddXMP)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionAddXMP' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionCloseContainer = (uint64_t)dlsym(v1, "CMPhotoCompressionSessionCloseContainer");
    if (!gFunc_CMPhotoCompressionSessionCloseContainer)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionCloseContainer' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionCloseContainerAndCopyBacking = dlsym(v1, "CMPhotoCompressionSessionCloseContainerAndCopyBacking");
    if (!gFunc_CMPhotoCompressionSessionCloseContainerAndCopyBacking)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionCloseContainerAndCopyBacking' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionCreate = dlsym(v1, "CMPhotoCompressionSessionCreate");
    if (!gFunc_CMPhotoCompressionSessionCreate)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionCreate' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionEndImageSequence = dlsym(v1, "CMPhotoCompressionSessionEndImageSequence");
    if (!gFunc_CMPhotoCompressionSessionEndImageSequence)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionEndImageSequence' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionInvalidate = dlsym(v1, "CMPhotoCompressionSessionInvalidate");
    if (!gFunc_CMPhotoCompressionSessionInvalidate)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionInvalidate' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionOpenEmptyContainer = dlsym(v1, "CMPhotoCompressionSessionOpenEmptyContainer");
    if (!gFunc_CMPhotoCompressionSessionOpenEmptyContainer)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionOpenEmptyContainer' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionOpenExistingContainerForModification = dlsym(v1, "CMPhotoCompressionSessionOpenExistingContainerForModification");
    if (!gFunc_CMPhotoCompressionSessionOpenExistingContainerForModification)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionOpenExistingContainerForModification' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionReleaseHardwareResources = dlsym(v1, "CMPhotoCompressionSessionReleaseHardwareResources");
    if (!gFunc_CMPhotoCompressionSessionReleaseHardwareResources)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionReleaseHardwareResources' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSessionStartImageSequence = dlsym(v1, "CMPhotoCompressionSessionStartImageSequence");
    if (!gFunc_CMPhotoCompressionSessionStartImageSequence)
    {
      puts("❌  failed to load 'CMPhotoCompressionSessionStartImageSequence' ");
      ++v2;
    }
    gFunc_CMPhotoCompressionSupportedForContainerAndCodec = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoCompressionSupportedForContainerAndCodec");
    if (!gFunc_CMPhotoCompressionSupportedForContainerAndCodec)
    {
      puts("❌  failed to load 'CMPhotoCompressionSupportedForContainerAndCodec' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageCGColorSpaceForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyAuxiliaryImageCGColorSpaceForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageCGColorSpaceForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyAuxiliaryImageCGColorSpaceForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithOptions = dlsym(v1, "CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyDebugMetadataForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyDebugMetadataForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyDebugMetadataForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyDebugMetadataForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyExifForIndexWithOptions = dlsym(v1, "CMPhotoDecompressionContainerCopyExifForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyExifForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyExifForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyFormatDescriptionForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyFormatDescriptionForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyFormatDescriptionForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyFormatDescriptionForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyGroupsDescriptionArray = dlsym(v1, "CMPhotoDecompressionContainerCopyGroupsDescriptionArray");
    if (!gFunc_CMPhotoDecompressionContainerCopyGroupsDescriptionArray)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyGroupsDescriptionArray' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions = dlsym(v1, "CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyImagePropertiesForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyImagePropertiesForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyImagePropertiesForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyImagePropertiesForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyStereoMetadataForIndex = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerCopyStereoMetadataForIndex");
    if (!gFunc_CMPhotoDecompressionContainerCopyStereoMetadataForIndex)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyStereoMetadataForIndex' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyXMPForIndexWithOptions = dlsym(v1, "CMPhotoDecompressionContainerCopyXMPForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyXMPForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyXMPForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation = dlsym(v1, "CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation");
    if (!gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex");
    if (!gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithOptions = dlsym(v1, "CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription = dlsym(v1, "CMPhotoDecompressionContainerCreateDictionaryDescription");
    if (!gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCreateDictionaryDescription' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateImageForIndex = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __n128))dlsym(v1, "CMPhotoDecompressionContainerCreateImageForIndex");
    if (!gFunc_CMPhotoDecompressionContainerCreateImageForIndex)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCreateImageForIndex' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex");
    if (!gFunc_CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateSequenceContainer = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionContainerCreateSequenceContainer");
    if (!gFunc_CMPhotoDecompressionContainerCreateSequenceContainer)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCreateSequenceContainer' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __n128))dlsym(v1, "CMPhotoDecompressionContainerCreateThumbnailImageForIndex");
    if (!gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerCreateThumbnailImageForIndex' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetAuxiliaryImageCountForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetAuxiliaryImageCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetAuxiliaryImageCountForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetAuxiliaryImageCountForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetAuxiliaryImageTypeForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetAuxiliaryImageTypeForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetAuxiliaryImageTypeForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetAuxiliaryImageTypeForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetCustomMetadataCountForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetCustomMetadataCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetCustomMetadataCountForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetCustomMetadataCountForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetDebugMetadataCountForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetDebugMetadataCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetDebugMetadataCountForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetDebugMetadataCountForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetExifCountForIndexWithOptions = dlsym(v1, "CMPhotoDecompressionContainerGetExifCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetExifCountForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetExifCountForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetImageCountWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetImageCountWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetImageCountWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetImageCountWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetSequenceCount = dlsym(v1, "CMPhotoDecompressionContainerGetSequenceCount");
    if (!gFunc_CMPhotoDecompressionContainerGetSequenceCount)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetSequenceCount' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetThumbnailCountForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetThumbnailCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetThumbnailCountForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetThumbnailCountForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetThumbnailGeometryForIndexWithOptions = (uint64_t)dlsym(v1, "CMPhotoDecompressionContainerGetThumbnailGeometryForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetThumbnailGeometryForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetThumbnailGeometryForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerGetXMPCountForIndexWithOptions = dlsym(v1, "CMPhotoDecompressionContainerGetXMPCountForIndexWithOptions");
    if (!gFunc_CMPhotoDecompressionContainerGetXMPCountForIndexWithOptions)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerGetXMPCountForIndexWithOptions' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionContainerJFIFTranscode = dlsym(v1, "CMPhotoDecompressionContainerJFIFTranscode");
    if (!gFunc_CMPhotoDecompressionContainerJFIFTranscode)
    {
      puts("❌  failed to load 'CMPhotoDecompressionContainerJFIFTranscode' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionDetectContainerFormat = (uint64_t)dlsym(v1, "CMPhotoDecompressionDetectContainerFormat");
    if (!gFunc_CMPhotoDecompressionDetectContainerFormat)
    {
      puts("❌  failed to load 'CMPhotoDecompressionDetectContainerFormat' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionDetectContainerFormatAndCodec = (uint64_t)dlsym(v1, "CMPhotoDecompressionDetectContainerFormatAndCodec");
    if (!gFunc_CMPhotoDecompressionDetectContainerFormatAndCodec)
    {
      puts("❌  failed to load 'CMPhotoDecompressionDetectContainerFormatAndCodec' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionCreate = (uint64_t (*)(_QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionSessionCreate");
    if (!gFunc_CMPhotoDecompressionSessionCreate)
    {
      puts("❌  failed to load 'CMPhotoDecompressionSessionCreate' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionCreateContainer = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionSessionCreateContainer");
    if (!gFunc_CMPhotoDecompressionSessionCreateContainer)
    {
      puts("❌  failed to load 'CMPhotoDecompressionSessionCreateContainer' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionFlushCachedBuffers = (uint64_t (*)(_QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionSessionFlushCachedBuffers");
    if (!gFunc_CMPhotoDecompressionSessionFlushCachedBuffers)
    {
      puts("❌  failed to load 'CMPhotoDecompressionSessionFlushCachedBuffers' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionReleaseHardwareResources = (uint64_t)dlsym(v1, "CMPhotoDecompressionSessionReleaseHardwareResources");
    if (!gFunc_CMPhotoDecompressionSessionReleaseHardwareResources)
    {
      puts("❌  failed to load 'CMPhotoDecompressionSessionReleaseHardwareResources' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionSupportedForContainerAndCodec = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionSupportedForContainerAndCodec");
    if (!gFunc_CMPhotoDecompressionSupportedForContainerAndCodec)
    {
      puts("❌  failed to load 'CMPhotoDecompressionSupportedForContainerAndCodec' ");
      ++v2;
    }
    gFunc_CMPhotoDecompressionSessionDetachSurface = (uint64_t (*)(_QWORD, _QWORD))dlsym(v1, "CMPhotoDecompressionSessionDetachSurface");
    if (!gFunc_CMPhotoDecompressionSessionDetachSurface)
    {
      puts("❌  failed to load 'CMPhotoDecompressionSessionDetachSurface' ");
      ++v2;
    }
    gFunc_CMPhotoGetAPIVersion = (uint64_t (*)(void))dlsym(v1, "CMPhotoGetAPIVersion");
    if (!gFunc_CMPhotoGetAPIVersion)
    {
      puts("❌  failed to load 'CMPhotoGetAPIVersion' ");
      ++v2;
    }
    gFunc_CMPhotoJPEGCreateJPEGFromIOSurface = dlsym(v1, "CMPhotoJPEGCreateJPEGFromIOSurface");
    if (!gFunc_CMPhotoJPEGCreateJPEGFromIOSurface)
    {
      puts("❌  failed to load 'CMPhotoJPEGCreateJPEGFromIOSurface' ");
      ++v2;
    }
    gFunc_CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize = dlsym(v1, "CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize");
    if (!gFunc_CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize)
    {
      puts("❌  failed to load 'CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_EXIFMetadata = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_EXIFMetadata");
    if (!gIIO_kCMPhotoCompressionContainerDescription_EXIFMetadata)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerDescription_EXIFMetadata' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_Extrinsics_Position = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_Extrinsics_Position");
    if (!gIIO_kCMPhotoCompressionContainerDescription_Extrinsics_Position)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerDescription_Extrinsics_Position' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment");
    if (!gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_StereoAggressors = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_GroupProperty_StereoAggressors");
    if (!gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_StereoAggressors)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerDescription_GroupProperty_StereoAggressors' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation");
    if (!gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_Intrinsics = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_Intrinsics");
    if (!gIIO_kCMPhotoCompressionContainerDescription_Intrinsics)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerDescription_Intrinsics' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_Orientation = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_Orientation");
    if (!gIIO_kCMPhotoCompressionContainerDescription_Orientation)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerDescription_Orientation' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerDescription_XMPMetadata = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerDescription_XMPMetadata");
    if (!gIIO_kCMPhotoCompressionContainerDescription_XMPMetadata)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerDescription_XMPMetadata' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerOption_BackingType = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerOption_BackingType");
    if (!gIIO_kCMPhotoCompressionContainerOption_BackingType)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerOption_BackingType' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerOption_Format = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerOption_Format");
    if (!gIIO_kCMPhotoCompressionContainerOption_Format)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerOption_Format' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionContainerOption_StripExistingMetadata = (uint64_t)dlsym(v1, "kCMPhotoCompressionContainerOption_StripExistingMetadata");
    if (!gIIO_kCMPhotoCompressionContainerOption_StripExistingMetadata)
    {
      puts("❌  failed to load 'kCMPhotoCompressionContainerOption_StripExistingMetadata' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_ApplyTransform = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_ApplyTransform");
    if (!gIIO_kCMPhotoCompressionOption_ApplyTransform)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_ApplyTransform' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_BitDepth = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_BitDepth");
    if (!gIIO_kCMPhotoCompressionOption_BitDepth)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_BitDepth' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_CodecType = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_CodecType");
    if (!gIIO_kCMPhotoCompressionOption_CodecType)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_CodecType' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_ColorSpace = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_ColorSpace");
    if (!gIIO_kCMPhotoCompressionOption_ColorSpace)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_ColorSpace' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_EnableSoftwareHEVCEncoder = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_EnableSoftwareHEVCEncoder");
    if (!gIIO_kCMPhotoCompressionOption_EnableSoftwareHEVCEncoder)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_EnableSoftwareHEVCEncoder' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_ForceHighSpeed = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_ForceHighSpeed");
    if (!gIIO_kCMPhotoCompressionOption_ForceHighSpeed)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_ForceHighSpeed' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_ImageOrientation = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_ImageOrientation");
    if (!gIIO_kCMPhotoCompressionOption_ImageOrientation)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_ImageOrientation' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_IntrinsicsMatrix = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_IntrinsicsMatrix");
    if (!gIIO_kCMPhotoCompressionOption_IntrinsicsMatrix)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_IntrinsicsMatrix' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_MaxPixelSize = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_MaxPixelSize");
    if (!gIIO_kCMPhotoCompressionOption_MaxPixelSize)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_MaxPixelSize' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_PreferSoftwareCodec = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_PreferSoftwareCodec");
    if (!gIIO_kCMPhotoCompressionOption_PreferSoftwareCodec)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_PreferSoftwareCodec' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_PrimaryImage = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_PrimaryImage");
    if (!gIIO_kCMPhotoCompressionOption_PrimaryImage)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_PrimaryImage' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_QualityControllerParameters = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_QualityControllerParameters");
    if (!gIIO_kCMPhotoCompressionOption_QualityControllerParameters)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_QualityControllerParameters' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_QualityControllerType = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_QualityControllerType");
    if (!gIIO_kCMPhotoCompressionOption_QualityControllerType)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_QualityControllerType' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_RequireHardwareCodec = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_RequireHardwareCodec");
    if (!gIIO_kCMPhotoCompressionOption_RequireHardwareCodec)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_RequireHardwareCodec' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_RGBToYUVDithering = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_RGBToYUVDithering");
    if (!gIIO_kCMPhotoCompressionOption_RGBToYUVDithering)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_RGBToYUVDithering' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_Subsampling = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_Subsampling");
    if (!gIIO_kCMPhotoCompressionOption_Subsampling)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_Subsampling' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_Tiling = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_Tiling");
    if (!gIIO_kCMPhotoCompressionOption_Tiling)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_Tiling' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_UseVTCompression = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_UseVTCompression");
    if (!gIIO_kCMPhotoCompressionOption_UseVTCompression)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_UseVTCompression' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionSessionOption_UseCodecSessionPool = (uint64_t)dlsym(v1, "kCMPhotoCompressionSessionOption_UseCodecSessionPool");
    if (!gIIO_kCMPhotoCompressionSessionOption_UseCodecSessionPool)
    {
      puts("❌  failed to load 'kCMPhotoCompressionSessionOption_UseCodecSessionPool' ");
      ++v2;
    }
    gIIO_kCMPhotoCustomMetadata_Data = (uint64_t)dlsym(v1, "kCMPhotoCustomMetadata_Data");
    if (!gIIO_kCMPhotoCustomMetadata_Data)
    {
      puts("❌  failed to load 'kCMPhotoCustomMetadata_Data' ");
      ++v2;
    }
    gIIO_kCMPhotoCustomMetadata_Name = (uint64_t)dlsym(v1, "kCMPhotoCustomMetadata_Name");
    if (!gIIO_kCMPhotoCustomMetadata_Name)
    {
      puts("❌  failed to load 'kCMPhotoCustomMetadata_Name' ");
      ++v2;
    }
    gIIO_kCMPhotoCustomMetadata_URI = (uint64_t)dlsym(v1, "kCMPhotoCustomMetadata_URI");
    if (!gIIO_kCMPhotoCustomMetadata_URI)
    {
      puts("❌  failed to load 'kCMPhotoCustomMetadata_URI' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AlphaPremultiplication = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AlphaPremultiplication");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AlphaPremultiplication)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_AlphaPremultiplication' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AlternateImages = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AlternateImages");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AlternateImages)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_AlternateImages' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AudioTrackCount = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AudioTrackCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AudioTrackCount)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_AudioTrackCount' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImageCount = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryImageCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImageCount)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryImageCount' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImages = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryImages");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImages)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryImages' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryType = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryType");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryType)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryType' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_BitDepth = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_BitDepth");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_BitDepth)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_BitDepth' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_CodecType = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_CodecType");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_CodecType)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_CodecType' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ColorSpace = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ColorSpace");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ColorSpace)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_ColorSpace' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_CustomMetadataPayloads' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DataLength = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DataLength");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DataLength)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_DataLength' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DataOffset = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DataOffset");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DataOffset)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_DataOffset' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DebugPayloads = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DebugPayloads");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DebugPayloads)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_DebugPayloads' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DerivationDetails = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DerivationDetails");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DerivationDetails)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_DerivationDetails' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapPixelFormat = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_DerivationGainMapPixelFormat");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapPixelFormat)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_DerivationGainMapPixelFormat' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Dimensions = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_Dimensions");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_Dimensions)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_Dimensions' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ExifPayloads = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ExifPayloads");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ExifPayloads)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_ExifPayloads' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Group_PictureIndexList = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_Group_PictureIndexList");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_Group_PictureIndexList)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_Group_PictureIndexList' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Group_Type = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_Group_Type");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_Group_Type)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_Group_Type' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_GroupsList = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_GroupsList");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_GroupsList)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_GroupsList' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ImageSequenceCount = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ImageSequenceCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ImageSequenceCount)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_ImageSequenceCount' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ItemID = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ItemID");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ItemID)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_ItemID' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ItemType = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ItemType");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ItemType)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_ItemType' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_MainImages = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_MainImages");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_MainImages)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_MainImages' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromProperties = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromProperties");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromProperties)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromProperties' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NamedColorSpace = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NamedColorSpace");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NamedColorSpace)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_NamedColorSpace' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_ColorPrimaries = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NclxColor_ColorPrimaries");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_ColorPrimaries)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_NclxColor_ColorPrimaries' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_TransferFunction = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NclxColor_TransferFunction");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_TransferFunction)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_NclxColor_TransferFunction' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_YCbCrMatrix = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NclxColor_YCbCrMatrix");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NclxColor_YCbCrMatrix)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_NclxColor_YCbCrMatrix' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_NclxColor = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_NclxColor");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_NclxColor)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_NclxColor' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_Orientation = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_Orientation");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_Orientation)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_Orientation' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_PrimaryImageIndex = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_PrimaryImageIndex");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_PrimaryImageIndex)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_PrimaryImageIndex' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDependsOnOthers = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceSampleDependsOnOthers");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDependsOnOthers)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceSampleDependsOnOthers' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDuration = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceSampleDuration");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleDuration)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceSampleDuration' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleIsDependedOnByOthers = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceSampleIsDependedOnByOthers");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceSampleIsDependedOnByOthers)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceSampleIsDependedOnByOthers' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceSamplePTS = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceSamplePTS");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceSamplePTS)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceSamplePTS' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_SequenceTracksDescription = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_SequenceTracksDescription");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_SequenceTracksDescription)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_SequenceTracksDescription' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImageCount = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ThumbnailImageCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImageCount)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_ThumbnailImageCount' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImages = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_ThumbnailImages");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImages)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_ThumbnailImages' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_TiffOffset = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_TiffOffset");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_TiffOffset)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_TiffOffset' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_TileDimensions = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_TileDimensions");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_TileDimensions)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_TileDimensions' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_VideoTrackCount = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_VideoTrackCount");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_VideoTrackCount)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_VideoTrackCount' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerDescription_XMPPayloads = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerDescription_XMPPayloads");
    if (!gIIO_kCMPhotoDecompressionContainerDescription_XMPPayloads)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerDescription_XMPPayloads' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_AccelerationMode = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_AccelerationMode");
    if (!gIIO_kCMPhotoDecompressionOption_AccelerationMode)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_AccelerationMode' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_AlternateIndex = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_AlternateIndex");
    if (!gIIO_kCMPhotoDecompressionOption_AlternateIndex)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_AlternateIndex' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_ApplyTransform = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_ApplyTransform");
    if (!gIIO_kCMPhotoDecompressionOption_ApplyTransform)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_ApplyTransform' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_BackCGImageWithIOSurface = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_BackCGImageWithIOSurface");
    if (!gIIO_kCMPhotoDecompressionOption_BackCGImageWithIOSurface)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_BackCGImageWithIOSurface' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputHeadRoom = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_DecodeToHDROutputHeadRoom");
    if (!gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputHeadRoom)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_DecodeToHDROutputHeadRoom' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputMode = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_DecodeToHDROutputMode");
    if (!gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputMode)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_DecodeToHDROutputMode' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer");
    if (!gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputOptions = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_DecodeToHDROutputOptions");
    if (!gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputOptions)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_DecodeToHDROutputOptions' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata");
    if (!gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace");
    if (!gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap = (uint64_t)dlsym(v1, "kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap");
    if (!gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_ForceHighSpeed = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_ForceHighSpeed");
    if (!gIIO_kCMPhotoDecompressionOption_ForceHighSpeed)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_ForceHighSpeed' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_MaxPixelSize = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_MaxPixelSize");
    if (!gIIO_kCMPhotoDecompressionOption_MaxPixelSize)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_MaxPixelSize' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_OutputPixelFormat = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_OutputPixelFormat");
    if (!gIIO_kCMPhotoDecompressionOption_OutputPixelFormat)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_OutputPixelFormat' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_RestrictedDecoding = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_RestrictedDecoding");
    if (!gIIO_kCMPhotoDecompressionOption_RestrictedDecoding)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_RestrictedDecoding' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_SourceCropRect = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_SourceCropRect");
    if (!gIIO_kCMPhotoDecompressionOption_SourceCropRect)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_SourceCropRect' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_TiledDownsampling = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_TiledDownsampling");
    if (!gIIO_kCMPhotoDecompressionOption_TiledDownsampling)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_TiledDownsampling' ");
      ++v2;
    }
    gIIO_kCMPhotoDecompressionOption_UseProvidedPixelBuffer = (uint64_t)dlsym(v1, "kCMPhotoDecompressionOption_UseProvidedPixelBuffer");
    if (!gIIO_kCMPhotoDecompressionOption_UseProvidedPixelBuffer)
    {
      puts("❌  failed to load 'kCMPhotoDecompressionOption_UseProvidedPixelBuffer' ");
      ++v2;
    }
    gIIO_kCMPhotoJPEGCustomLumaQuantTable = (uint64_t)dlsym(v1, "kCMPhotoJPEGCustomLumaQuantTable");
    if (!gIIO_kCMPhotoJPEGCustomLumaQuantTable)
    {
      puts("❌  failed to load 'kCMPhotoJPEGCustomLumaQuantTable' ");
      ++v2;
    }
    gIIO_kCMPhotoJPEGCustomChromaQuantTable = (uint64_t)dlsym(v1, "kCMPhotoJPEGCustomChromaQuantTable");
    if (!gIIO_kCMPhotoJPEGCustomChromaQuantTable)
    {
      puts("❌  failed to load 'kCMPhotoJPEGCustomChromaQuantTable' ");
      ++v2;
    }
    gIIO_kCMPhotoJPEGSoftwareEncode = (uint64_t)dlsym(v1, "kCMPhotoJPEGSoftwareEncode");
    if (!gIIO_kCMPhotoJPEGSoftwareEncode)
    {
      puts("❌  failed to load 'kCMPhotoJPEGSoftwareEncode' ");
      ++v2;
    }
    gIIO_kCMPhotoMetadata_TonemapAlternateHDRHeadroom = (uint64_t)dlsym(v1, "kCMPhotoMetadata_TonemapAlternateHDRHeadroom");
    if (!gIIO_kCMPhotoMetadata_TonemapAlternateHDRHeadroom)
    {
      puts("❌  failed to load 'kCMPhotoMetadata_TonemapAlternateHDRHeadroom' ");
      ++v2;
    }
    gIIO_kCMPhotoMetadata_TonemapBaseColorIsWorkingColor = (uint64_t)dlsym(v1, "kCMPhotoMetadata_TonemapBaseColorIsWorkingColor");
    if (!gIIO_kCMPhotoMetadata_TonemapBaseColorIsWorkingColor)
    {
      puts("❌  failed to load 'kCMPhotoMetadata_TonemapBaseColorIsWorkingColor' ");
      ++v2;
    }
    gIIO_kCMPhotoMetadata_TonemapBaseHDRHeadroom = (uint64_t)dlsym(v1, "kCMPhotoMetadata_TonemapBaseHDRHeadroom");
    if (!gIIO_kCMPhotoMetadata_TonemapBaseHDRHeadroom)
    {
      puts("❌  failed to load 'kCMPhotoMetadata_TonemapBaseHDRHeadroom' ");
      ++v2;
    }
    gIIO_kCMPhotoMetadata_TonemapChannelMetadataKeys = (uint64_t)dlsym(v1, "kCMPhotoMetadata_TonemapChannelMetadataKeys");
    if (!gIIO_kCMPhotoMetadata_TonemapChannelMetadataKeys)
    {
      puts("❌  failed to load 'kCMPhotoMetadata_TonemapChannelMetadataKeys' ");
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_AlternateOffset = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_AlternateOffset");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_AlternateOffset)
    {
      puts("❌  failed to load 'kCMPhotoMetadataTonemapChannel_AlternateOffset' ");
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_BaseOffset = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_BaseOffset");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_BaseOffset)
    {
      puts("❌  failed to load 'kCMPhotoMetadataTonemapChannel_BaseOffset' ");
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_GainMapMax = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_GainMapMax");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_GainMapMax)
    {
      puts("❌  failed to load 'kCMPhotoMetadataTonemapChannel_GainMapMax' ");
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_GainMapMin = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_GainMapMin");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_GainMapMin)
    {
      puts("❌  failed to load 'kCMPhotoMetadataTonemapChannel_GainMapMin' ");
      ++v2;
    }
    gIIO_kCMPhotoMetadataTonemapChannel_Gamma = (uint64_t)dlsym(v1, "kCMPhotoMetadataTonemapChannel_Gamma");
    if (!gIIO_kCMPhotoMetadataTonemapChannel_Gamma)
    {
      puts("❌  failed to load 'kCMPhotoMetadataTonemapChannel_Gamma' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_Alpha = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_Alpha");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_Alpha)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_Alpha' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_Depth");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_Depth' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte' ");
      ++v2;
    }
    gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap = (uint64_t)dlsym(v1, "kCMPhotoAuxiliaryImageTypeURN_HDRGainMap");
    if (!gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap)
    {
      puts("❌  failed to load 'kCMPhotoAuxiliaryImageTypeURN_HDRGainMap' ");
      ++v2;
    }
    gIIO_kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN = (uint64_t)dlsym(v1, "kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN");
    if (!gIIO_kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN)
    {
      puts("❌  failed to load 'kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN' ");
      ++v2;
    }
    gIIO_kCMPhotoQualityControllerParameter_QualityValue = (uint64_t)dlsym(v1, "kCMPhotoQualityControllerParameter_QualityValue");
    if (!gIIO_kCMPhotoQualityControllerParameter_QualityValue)
    {
      puts("❌  failed to load 'kCMPhotoQualityControllerParameter_QualityValue' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverter = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverter");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverter)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_ColorConverter' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverterCallback = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverterCallback");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverterCallback)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_ColorConverterCallback' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverterCGColorSpace = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverterCGColorSpace");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverterCGColorSpace)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_ColorConverterCGColorSpace' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverterUserPointer = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverterUserPointer");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverterUserPointer)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_ColorConverterUserPointer' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ColorConverterVersion = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ColorConverterVersion");
    if (!gIIO_kCMPhotoTranscodeOption_ColorConverterVersion)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_ColorConverterVersion' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_IncludeAuxiliaryImages = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_IncludeAuxiliaryImages");
    if (!gIIO_kCMPhotoTranscodeOption_IncludeAuxiliaryImages)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_IncludeAuxiliaryImages' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_IncludeMetadata = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_IncludeMetadata");
    if (!gIIO_kCMPhotoTranscodeOption_IncludeMetadata)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_IncludeMetadata' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_IncludeThumbnail = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_IncludeThumbnail");
    if (!gIIO_kCMPhotoTranscodeOption_IncludeThumbnail)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_IncludeThumbnail' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_PreferSoftwareEncode = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_PreferSoftwareEncode");
    if (!gIIO_kCMPhotoTranscodeOption_PreferSoftwareEncode)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_PreferSoftwareEncode' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_PreserveAndModifyGainMap = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_PreserveAndModifyGainMap");
    if (!gIIO_kCMPhotoTranscodeOption_PreserveAndModifyGainMap)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_PreserveAndModifyGainMap' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_ReplacementImageProperties = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_ReplacementImageProperties");
    if (!gIIO_kCMPhotoTranscodeOption_ReplacementImageProperties)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_ReplacementImageProperties' ");
      ++v2;
    }
    gIIO_kCMPhotoTranscodeOption_RestrictedTranscoding = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_RestrictedTranscoding");
    if (!gIIO_kCMPhotoTranscodeOption_RestrictedTranscoding)
    {
      puts("❌  failed to load 'kCMPhotoTranscodeOption_RestrictedTranscoding' ");
      ++v2;
    }
    result = (uint64_t)dlsym(v1, "kCMPhotoTranscodeOption_Strips");
    gIIO_kCMPhotoTranscodeOption_Strips = result;
    if (!result)
    {
      result = puts("❌  failed to load 'kCMPhotoTranscodeOption_Strips' ");
      ++v2;
    }
    if (v2)
    {
      APIVersion = gFunc_CMPhotoGetAPIVersion();
      return (uint64_t)LogError("IIOLoadCMPhotoSymbols", 746, "❌  ERROR: failed to load %d CMPhoto symbols (APIVersion at compile: %d  -  APIVersion installed: %d)\n", v2, 137, APIVersion);
    }
  }
  return result;
}

CGImageSourceStatus CGImageSourceGetStatusAtIndex(CGImageSourceRef isrc, size_t index)
{
  unsigned int v4;
  CFTypeID v5;
  uint64_t v6;
  CGImageSourceStatus StatusAtIndex;
  IIO_Reader *v8;

  kdebug_trace();
  IIOInitDebugFlags();
  v4 = (gIIODebugFlags >> 12) & 3;
  if (v4)
    ImageIODebugOptions(v4, "A", "CGImageSourceGetStatusAtIndex", isrc, 0, index, 0);
  if (!isrc)
  {
    LogError("CGImageSourceGetStatusAtIndex", 5400, "*** ERROR: CGImageSourceGetStatusAtIndex: source is nil\n");
LABEL_9:
    StatusAtIndex = kCGImageStatusInvalidData;
    goto LABEL_17;
  }
  v5 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v5 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetStatusAtIndex", 5401, "*** ERROR: CGImageSourceGetStatusAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_9;
  }
  v6 = *((_QWORD *)isrc + 3);
  if (!v6 || IIOImageSource::isProxy((IIOImageSource *)v6))
    goto LABEL_9;
  if (*(_BYTE *)(v6 + 65))
  {
    LogError("CGImageSourceGetStatusAtIndex", 5406, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_9;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 200));
  if ((IIOImageSource::bindToReader((IIOImageSource *)v6) & 1) != 0)
    StatusAtIndex = IIOImageSource::iPlusGetStatusAtIndex((IIOImageSource *)v6, index);
  else
    StatusAtIndex = *(_DWORD *)(v6 + 88);
  v8 = *(IIO_Reader **)(v6 + 80);
  if (v8)
    IIO_Reader::osType(v8);
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 200));
LABEL_17:
  kdebug_trace();
  return StatusAtIndex;
}

uint64_t IIOImageSource::iPlusGetStatusAtIndex(IIOImageSource *this, unint64_t a2)
{
  uint64_t Status;
  IIOImagePlus *ImagePlus;
  unint64_t v6;
  int v8;

  if (IIOImageSource::bindToReader(this))
    Status = *((unsigned int *)this + 22);
  else
    Status = 4294967292;
  ImagePlus = (IIOImagePlus *)IIOImageSource::getImagePlus(this, a2);
  if (ImagePlus)
  {
    Status = IIOImagePlus::getStatus(ImagePlus);
    if ((_DWORD)Status == -1)
    {
      v6 = IIOImageSource::updatedCount(this);
      v8 = v6 < 2 || v6 - 1 <= a2;
      return (v8 << 31 >> 31);
    }
  }
  return Status;
}

CFStringRef CreateEXIFDataTimeStringWithXMPDateTimeString(const __CFString *a1)
{
  int DateTimeStructFromXMPDateTimeString;
  CFStringRef result;
  tm v3;
  char __str[8];
  uint64_t v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)__str = 0;
  v5 = 0;
  v6 = 0;
  memset(&v3, 0, sizeof(v3));
  DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v3, 0, 0);
  result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    snprintf(__str, 0x14uLL, "%04d:%02d:%02d %02d:%02d:%02d", v3.tm_year + 1900, v3.tm_mon + 1, v3.tm_mday, v3.tm_hour, v3.tm_min, v3.tm_sec);
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __str, 0x600u);
  }
  return result;
}

uint64_t GetDateTimeStructFromXMPDateTimeString(const __CFString *cf, tm *a2, BOOL *a3, BOOL *a4)
{
  uint64_t v4;
  CFTypeID v8;
  char *v9;
  char *v10;
  uint64_t v11;
  BOOL *v12;
  __int128 v13;
  char *v15;
  int v16;
  int v17;
  CFIndex Length;
  double v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v4 = (uint64_t)a2;
  v27 = 0;
  v25 = 0u;
  v26 = 0u;
  v24 = 0u;
  v23 = 0;
  v21 = 0u;
  v22 = 0u;
  v20 = 0u;
  if (a2)
  {
    a2->tm_zone = 0;
    *(_OWORD *)&a2->tm_mon = 0uLL;
    *(_OWORD *)&a2->tm_isdst = 0uLL;
    *(_OWORD *)&a2->tm_sec = 0uLL;
    if (!cf)
      return 0;
    v8 = CFGetTypeID(cf);
    if (v8 != CFStringGetTypeID())
      return 0;
    Length = CFStringGetLength(cf);
    v9 = (char *)malloc_type_malloc(Length + 1, 0x314760DBuLL);
    if (!v9)
      return 0;
    v10 = v9;
    v19 = 0.0;
    if (!CFStringGetCString(cf, v9, Length + 1, 0x600u))
      goto LABEL_69;
    tzset();
    if (a3)
      *a3 = 0;
    if (a4)
      *a4 = 0;
    if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d:%lf+%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19, (char *)&v20 + 8, (char *)&v20 + 4) == 8|| sscanf(v10, "%04d%02d%02dT%02d%02d%lf+%02d%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19,
           (char *)&v20 + 8,
           (char *)&v20 + 4) == 8)
    {
      LODWORD(v24) = (int)v19;
LABEL_13:
      *(int32x2_t *)&v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
      v11 = 3600 * SDWORD2(v20) + 60 * SDWORD1(v20);
      goto LABEL_18;
    }
    if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d:%lf-%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19, (char *)&v20 + 8, (char *)&v20 + 4) == 8|| sscanf(v10, "%04d%02d%02dT%02d%02d%lf-%02d%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19,
           (char *)&v20 + 8,
           (char *)&v20 + 4) == 8)
    {
      LODWORD(v24) = (int)v19;
      goto LABEL_17;
    }
    if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d:%lfZ", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19) == 6)
    {
      LODWORD(v24) = (int)v19;
      *(int32x2_t *)&v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
      *((_QWORD *)&v26 + 1) = 0;
      if (a3)
        *a3 = 1;
      v12 = a4;
      if (!a4)
        goto LABEL_22;
      v15 = &v10[Length];
      goto LABEL_35;
    }
    if (sscanf(v10, "%04d%02d%02dT%02d%02d%lfZ", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v19) == 6)
    {
      LODWORD(v24) = (int)v19;
      *(int32x2_t *)&v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
      *((_QWORD *)&v26 + 1) = 0;
      if (a3)
        *a3 = 1;
      v12 = a4;
      if (!a4)
        goto LABEL_22;
      v15 = &v10[Length];
LABEL_35:
      v16 = *(v15 - 1);
      goto LABEL_36;
    }
    if (Length > 18)
    {
      if (Length == 19)
      {
        if (sscanf(v10, "%04d:%02d:%02d %02d:%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, &v24) == 6)
        {
          *(int32x2_t *)&v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
          goto LABEL_56;
        }
      }
      else if (Length == 22)
      {
        if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d+%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, (char *)&v20 + 8, (char *)&v20 + 4) == 7)goto LABEL_13;
        if (sscanf(v10, "%04d-%02d-%02dT%02d:%02d-%02d:%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4, (char *)&v20 + 8, (char *)&v20 + 4) == 7)
        {
LABEL_17:
          *(int32x2_t *)&v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
          v11 = -3600 * DWORD2(v20) - 60 * DWORD1(v20);
LABEL_18:
          *((_QWORD *)&v26 + 1) = v11;
          if (a3)
            *a3 = 1;
          v12 = a4;
          if (!a4)
            goto LABEL_22;
LABEL_21:
          *v12 = 1;
LABEL_22:
          v13 = v25;
          *(_OWORD *)v4 = v24;
          *(_OWORD *)(v4 + 16) = v13;
          *(_OWORD *)(v4 + 32) = v26;
          *(_QWORD *)(v4 + 48) = v27;
          v4 = 1;
LABEL_23:
          free(v10);
          return v4;
        }
      }
    }
    else
    {
      if (Length == 10)
      {
        if (sscanf(v10, "%04d-%02d-%02d", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC) == 3)
        {
LABEL_63:
          *(int32x2_t *)&v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
          goto LABEL_22;
        }
        if (sscanf(v10, "%02d:%02d:%02d", (char *)&v24 + 8, (char *)&v24 + 4, &v24) == 3)
          goto LABEL_56;
        v17 = sscanf(v10, "%04d:%02d:%02d");
        goto LABEL_62;
      }
      if (Length == 17
        && sscanf(v10, "%04d-%02d-%02dT%02d:%02dZ", (char *)&v25 + 4, &v25, (unint64_t)&v24 | 0xC, (char *)&v24 + 8, (char *)&v24 + 4) == 5)
      {
        *(int32x2_t *)&v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
        *((_QWORD *)&v26 + 1) = 0;
        if (a3)
          *a3 = 1;
        v12 = a4;
        v16 = v10[16];
LABEL_36:
        if (v16 != 90)
          goto LABEL_22;
        goto LABEL_21;
      }
    }
    if (sscanf(v10, "%02d:%02d:%02d", (char *)&v24 + 8, (char *)&v24 + 4, &v24) == 3)
    {
LABEL_56:
      v12 = a3;
      if (!a3)
        goto LABEL_22;
      goto LABEL_21;
    }
    if (Length == 4)
    {
      if (sscanf(v10, "%04d", (char *)&v25 + 4) == 1)
      {
        DWORD1(v25) -= 1900;
        HIDWORD(v24) = 1;
        goto LABEL_22;
      }
      goto LABEL_69;
    }
    if (Length == 7)
    {
      if (sscanf(v10, "%04d-%02d", (char *)&v25 + 4, &v25) == 2)
      {
        *(int32x2_t *)&v25 = vadd_s32(*(int32x2_t *)&v25, (int32x2_t)0xFFFFF894FFFFFFFFLL);
        HIDWORD(v24) = 1;
        goto LABEL_22;
      }
      goto LABEL_69;
    }
    if (Length != 8)
      goto LABEL_69;
    v17 = sscanf(v10, "%04d%02d%02d");
LABEL_62:
    if (v17 == 3)
      goto LABEL_63;
LABEL_69:
    v4 = 0;
    goto LABEL_23;
  }
  return v4;
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  CFStringRef v11;
  CFStringRef v12;
  unsigned int v13;
  IIO_WriterHandler *v14;
  IIO_WriterHandler *WriterHandler;
  IIODictionary *v16;
  IIO_Reader *WriterForType;
  uint64_t v18;
  const __CFString *v19;
  CGImageDestination *v20;
  IIO_Reader *v22;
  _QWORD v23[128];
  char buffer[16];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  IIOInitDebugFlags();
  kdebug_trace();
  if (!url)
  {
    LogError("CGImageDestinationCreateWithURL", 4915, "*** ERROR: CGImageDestinationCreateWithURL: url is nil\n");
    goto LABEL_19;
  }
  if (!type)
  {
    LogError("CGImageDestinationCreateWithURL", 4916, "*** ERROR: CGImageDestinationCreateWithURL: type is nil\n");
    goto LABEL_19;
  }
  if (!count)
    _cg_jpeg_mem_term("CGImageDestinationCreateWithURL", 4918, "*** CGImageDestinationCreateWithURL: capacity is 0\n");
  v8 = CFGetTypeID(url);
  if (v8 != CFURLGetTypeID())
  {
    LogError("CGImageDestinationCreateWithURL", 4919, "*** ERROR: CGImageDestinationCreateWithURL: url is not a CFURLRef\n");
    goto LABEL_19;
  }
  v9 = CFGetTypeID(type);
  if (v9 != CFStringGetTypeID())
  {
    LogError("CGImageDestinationCreateWithURL", 4920, "*** ERROR: CGImageDestinationCreateWithURL: type is not a CFStringRef\n");
    goto LABEL_19;
  }
  if (options)
  {
    v10 = CFGetTypeID(options);
    if (v10 != CFDictionaryGetTypeID())
    {
      LogError("CGImageDestinationCreateWithURL", 4923, "*** ERROR: CGImageDestinationCreateWithURL: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    v26 = 0u;
    v27 = 0u;
    *(_OWORD *)buffer = 0u;
    v25 = 0u;
    bzero(v23, 0x400uLL);
    v11 = IIO_CFURLCopyResolvedFileSystemPath(url);
    if (v11)
    {
      v12 = v11;
      CFStringGetCString(type, buffer, 64, 0x600u);
      _CFStringGetFileSystemRepresentation();
      v13 = (gIIODebugFlags >> 12) & 3;
      if (v13)
        ImageIODebugOptions(v13, "A", "CGImageDestinationCreateWithURL", 0, (const char *)v23, -1, options);
      CFRelease(v12);
    }
  }
  memset(v23, 0, 24);
  v14 = IIODictionary::IIODictionary((IIODictionary *)v23, options);
  WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v14);
  WriterForType = IIO_WriterHandler::findWriterForType(WriterHandler, type, (const __CFString *)count, (IIODictionary *)v23, v16);
  if (!WriterForType)
    goto LABEL_18;
  v18 = operator new();
  IIOImageDestination::IIOImageDestination((IIOImageDestination *)v18, url, WriterForType, v19, count, (IIODictionary *)v23);
  if (!*(_DWORD *)(v18 + 228))
  {
    IIODictionary::~IIODictionary((IIODictionary *)v23);
    v20 = (CGImageDestination *)CGImageDestinationRefCreateWith_ImageDestination((IIOImageDestination *)v18);
    v22 = *(IIO_Reader **)(v18 + 64);
    if (v22)
    {
      IIO_Reader::osType(v22);
      if (v20)
      {
LABEL_23:
        kdebug_trace();
        return v20;
      }
    }
    else if (v20)
    {
      goto LABEL_23;
    }
    LogError("CGImageDestinationCreateWithURL", 4937, "*** ERROR: CGImageDestinationCreateWithURL: failed to create 'CGImageDestinationRef' object\n");
    goto LABEL_19;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
LABEL_18:
  IIODictionary::~IIODictionary((IIODictionary *)v23);
  LogError("CGImageDestinationCreateWithURL", 4940, "*** ERROR: CGImageDestinationCreateWithURL: failed to create 'CGImageDestinationRef'\n");
LABEL_19:
  kdebug_trace();
  kdebug_trace();
  return 0;
}

void sub_187EBDC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  MEMORY[0x18D761C30](v9, 0x10E1C40255C1624);
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  _Unwind_Resume(a1);
}

void GlobalGIFInfo::GlobalGIFInfo(GlobalGIFInfo *this)
{
  char *v2;

  *(_OWORD *)((char *)this + 136) = 0u;
  v2 = (char *)this + 136;
  *(_QWORD *)this = &off_1E1BACBE8;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 72), 0);
  std::vector<GIFFrameInfo>::resize((uint64_t)v2, 0);
  *((_QWORD *)this + 27) = 0;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
}

void sub_187EBDD0C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v6;
  void *v7;

  v6 = *v4;
  *v4 = 0;
  if (v6)
    std::default_delete<IIOColorMap>::operator()[abi:ne180100]((uint64_t)v4, v6);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v3);
  v7 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 144) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

void std::vector<GIFFrameInfo>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<GIFFrameInfo>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 40 * a2;
  }
}

uint64_t png_handle_sBIT(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  const char *v6;
  uint64_t result;
  int v9;
  unsigned __int8 v10;
  uint64_t v11;
  int *v12;
  char v13;
  char v14;
  char *v15;
  char v16;
  char v17;
  char v18;
  int v19;

  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v4 & 6) != 0)
  {
    png_crc_finish(a1, a3);
    v6 = "out of place";
    return png_chunk_benign_error(a1, v6);
  }
  if (a2 && (*(_BYTE *)(a2 + 8) & 2) != 0)
  {
    png_crc_finish(a1, a3);
    v6 = "duplicate";
    return png_chunk_benign_error(a1, v6);
  }
  v9 = *(unsigned __int8 *)(a1 + 391);
  if (v9 == 3)
  {
    v10 = 8;
  }
  else
  {
    v9 = *(unsigned __int8 *)(a1 + 395);
    v10 = *(_BYTE *)(a1 + 392);
  }
  if (a3 <= 4 && v9 == (_DWORD)a3)
  {
    v19 = 16843009 * v10;
    png_crc_read(a1, (Bytef *)&v19, a3);
    result = png_crc_finish(a1, 0);
    if (!(_DWORD)result)
    {
      if ((_DWORD)a3)
      {
        v11 = a3;
        v12 = &v19;
        while (1)
        {
          v13 = *(_BYTE *)v12;
          v12 = (int *)((char *)v12 + 1);
          if ((v13 - 1) >= v10)
            return png_chunk_benign_error(a1, "invalid");
          if (!--v11)
            goto LABEL_17;
        }
      }
      else
      {
LABEL_17:
        v14 = v19;
        if ((*(_BYTE *)(a1 + 391) & 2) != 0)
        {
          v15 = (char *)&v19 + 3;
          v16 = BYTE1(v19);
          v17 = BYTE2(v19);
        }
        else
        {
          v15 = (char *)&v19 + 1;
          *(_BYTE *)(a1 + 507) = v19;
          v16 = v14;
          v17 = v14;
        }
        v18 = *v15;
        *(_BYTE *)(a1 + 504) = v14;
        *(_BYTE *)(a1 + 505) = v16;
        *(_BYTE *)(a1 + 506) = v17;
        *(_BYTE *)(a1 + 508) = v18;
        return png_set_sBIT(a1, a2, a1 + 504);
      }
    }
  }
  else
  {
    png_chunk_benign_error(a1, "invalid");
    return png_crc_finish(a1, a3);
  }
  return result;
}

uint64_t png_set_sBIT(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2)
  {
    if (a3)
    {
      *(_DWORD *)(a2 + 176) = *(_DWORD *)a3;
      *(_BYTE *)(a2 + 180) = *(_BYTE *)(a3 + 4);
      *(_DWORD *)(a2 + 8) |= 2u;
    }
  }
  return result;
}

IIOColorMap *GIFColorMap::GIFColorMap(IIOColorMap *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;

  IIOColorMap::IIOColorMap(a1, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  v4 = (void *)operator new[]();
  v5 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v4;
  if (v5)
  {
    MEMORY[0x18D761C18](v5, 0x1000C8033FC2DF1);
    v4 = (void *)*((_QWORD *)a1 + 2);
  }
  memcpy(v4, *(const void **)(a2 + 16), 3 * *(unsigned int *)a1);
  return a1;
}

void sub_187EBDFFC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8033FC2DF1);
  _Unwind_Resume(exception_object);
}

void IIOColorMap::IIOColorMap(IIOColorMap *this, int a2, int a3)
{
  uint64_t v4;
  uint64_t v5;

  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  *((_BYTE *)this + 8) = 0;
  *((_QWORD *)this + 2) = 0;
  v4 = operator new[]();
  v5 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = v4;
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C8033FC2DF1);
}

void sub_187EBE094(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8033FC2DF1);
  _Unwind_Resume(exception_object);
}

size_t CGImageSourceGetPrimaryImageIndex(CGImageSourceRef isrc)
{
  unsigned int v2;
  CFTypeID v3;
  uint64_t v4;
  unsigned int PrimaryImageIndex;
  size_t v6;
  IIO_Reader *v7;

  kdebug_trace();
  IIOInitDebugFlags();
  v2 = (gIIODebugFlags >> 12) & 3;
  if (v2)
    ImageIODebugOptions(v2, "A", "CGImageSourceGetPrimaryImageIndex", isrc, 0, -1, 0);
  if (!isrc)
  {
    LogError("CGImageSourceGetPrimaryImageIndex", 5429, "*** ERROR: CGImageSourceGetPrimaryImageIndex: source is nil\n");
LABEL_20:
    v6 = 0;
    goto LABEL_16;
  }
  v3 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v3 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetPrimaryImageIndex", 5430, "*** ERROR: CGImageSourceGetPrimaryImageIndex: source is not a CGImageSourceRef\n");
    goto LABEL_20;
  }
  v4 = *((_QWORD *)isrc + 3);
  if (!v4)
  {
    v6 = 0;
    goto LABEL_16;
  }
  if (*(_BYTE *)(v4 + 65))
  {
    LogError("CGImageSourceGetPrimaryImageIndex", 5435, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_20;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 200));
  if (IIOImageSource::isProxy((IIOImageSource *)v4))
    PrimaryImageIndex = IIOImageSource::proxyGetPrimaryImageIndex((IIODictionary **)v4);
  else
    PrimaryImageIndex = IIOImageSource::getPrimaryImageIndex((IIO_Reader **)v4);
  v6 = PrimaryImageIndex;
  v7 = *(IIO_Reader **)(v4 + 80);
  if (v7)
    IIO_Reader::osType(v7);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 200));
LABEL_16:
  kdebug_trace();
  return v6;
}

const __CFDictionary *IIOImageSource::getPrimaryImageIndex(IIO_Reader **this)
{
  IIODictionary *Properties;
  IIO_Reader *v3;

  Properties = (IIODictionary *)IIOImageSource::getProperties((IIOImageSource *)this, 0);
  v3 = this[10];
  if (v3)
  {
    if (IIO_Reader::osType(v3) == 1212500291)
    {
      if (Properties)
        return IIODictionary::getUint32ForKey(Properties, CFSTR("PrimaryImage"));
    }
    else if (IIO_Reader::osType(this[10]) == 1096173894 && Properties != 0)
    {
      return IIODictionary::getUint32ForKey(Properties, CFSTR("PrimaryImage"));
    }
  }
  return 0;
}

__IOSurface *IIOImageProviderInfo::CopyIOSurface(uint64_t *a1, const void *a2, const __CFDictionary *a3)
{
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  __IOSurface *v21;
  __IOSurface *v22;
  CFTypeRef v23;
  float v24;
  CFTypeRef v25;
  float v26;
  char v28[24];
  char __str[8];
  uint64_t v30;
  CFTypeRef value;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    CGImageProviderGetBitmapInfo();
    v6 = *a1;
    IIOPackCopyCallbackInfo(*a1, a3);
    if (v6)
      v7 = *(_DWORD *)(v6 + 128);
    else
      v7 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
  }
  v8 = v7;
  kdebug_trace();
  IIOInitDebugFlags();
  if (!a1)
    goto LABEL_38;
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_QWORD *)__str = 0;
    v9 = v8 >> 24;
    v10 = MEMORY[0x1E0C80978];
    v11 = v8 < 0 ? __maskrune(v8 >> 24, 0x40000uLL) : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    v12 = v11 ? v9 : 46;
    v13 = v8 << 8 >> 24;
    v14 = v8 << 8 < 0 ? __maskrune(v8 << 8 >> 24, 0x40000uLL) : *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    v15 = v14 ? v13 : 46;
    v16 = (__int16)v8 >> 8;
    v17 = v8 << 16 < 0 ? __maskrune((__int16)v8 >> 8, 0x40000uLL) : *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    v18 = v17 ? v16 : 46;
    v19 = (v8 << 24) <= 0x7F000000
        ? *(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000
        : __maskrune((char)v8, 0x40000uLL);
    v20 = v19 ? (char)v8 : 46;
    snprintf(__str, 8uLL, "%c%c%c%c", v12, v15, v18, v20);
    if ((unsigned __int16)gIIODebugFlags >> 14)
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyIOSurface", a2, __str, -1, a3);
  }
  if (v6 && (v21 = IIOImageProviderInfo::copyIOSurface(v6, a2, (uint64_t)a3), (v22 = v21) != 0))
  {
    v23 = IOSurfaceCopyValue(v21, CFSTR("IOSurfaceContentHeadroom"));
    if (v23)
    {
      CFRelease(v23);
    }
    else
    {
      CGImageProviderGetContentHeadroom();
      *(_QWORD *)__str = 0;
      v30 = 0;
      value = 0;
      IIONumber::IIONumber((IIONumber *)__str, v24);
      v25 = value;
      if (value)
      {
        if ((gIIODebugFlags & 0x300000) != 0)
        {
          IIONumber::IIONumber((IIONumber *)v28, (const __CFNumber *)value);
          v26 = IIONumber::floatNum((IIONumber *)v28);
          ImageIOLog("☀️  %s - updating <IOSurface: %p>  headroom: %g\n", "CopyIOSurface", v22, v26);
          IIONumber::~IIONumber((IIONumber *)v28);
        }
        IOSurfaceSetValue(v22, CFSTR("IOSurfaceContentHeadroom"), v25);
      }
      IIONumber::~IIONumber((IIONumber *)__str);
    }
    IOSurfaceGetWidth(v22);
    IOSurfaceGetHeight(v22);
    IOSurfaceGetPixelFormat(v22);
  }
  else
  {
LABEL_38:
    kdebug_trace();
    v22 = 0;
  }
  kdebug_trace();
  return v22;
}

void sub_187EBEA10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

__IOSurface *IIOImageProviderInfo::copyIOSurface(uint64_t a1, const void *a2, uint64_t a3)
{
  char v5;
  CFTypeRef *v7;
  const __CFDictionary *v8;
  CFTypeID v9;
  const void *v10;
  const void *Value;
  IIOImageRead **Source;
  const char **v13;
  _BOOL4 v14;
  uint64_t v15;
  __IOSurface *v16;
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  signed int PixelFormat;
  signed int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  uint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;

  v5 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x400000000000) != 0)
  {
    ImageIOLog("\n");
    ImageIOLog("*** copyIOSurface *** %p\n", a2);
    v5 = gIIODebugFlags;
  }
  if ((v5 & 0xC) != 0)
    *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent();
  if (!*(_QWORD *)(a1 + 224))
  {
    v15 = gIIODebugFlags;
    if ((gIIODebugFlags & 0x400000000000) == 0)
    {
      v16 = 0;
      goto LABEL_29;
    }
LABEL_28:
    ImageIOLog("    copyIOSurface - IOSurface = NULL\n");
    v16 = 0;
    v15 = gIIODebugFlags;
LABEL_29:
    if (v16 || (v15 & 0x800000000000) == 0)
      return v16;
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "copyIOSurface", 2409, "returned ioSurface is NULL\n");
    return 0;
  }
  v7 = *(CFTypeRef **)(a1 + 112);
  if (!v7)
  {
    v8 = 0;
LABEL_16:
    LogFault("copyIOSurface", 2358, "header '%p' is not a CFDictionary...\n", v8);
    return 0;
  }
  v8 = (const __CFDictionary *)*v7;
  if (!*v7)
    goto LABEL_16;
  v9 = CFGetTypeID(*v7);
  if (v9 != CFDictionaryGetTypeID())
    goto LABEL_16;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 144));
  v10 = (const void *)*MEMORY[0x1E0C9AE50];
  if (v10 == CFDictionaryGetValue(v8, CFSTR("kImageIOInfoHeader_pluginHandlesReMapping"))
    || (Value = CFDictionaryGetValue(v8, CFSTR("kImageIOInfoHeader_session"))) == 0)
  {
    v14 = 0;
    v13 = 0;
  }
  else
  {
    Source = (IIOImageRead **)CGImageSourceGetSource((uint64_t)Value);
    v13 = (const char **)Source;
    if (Source)
      v14 = IIOImageReadSession::mapData(Source);
    else
      v14 = 0;
  }
  v16 = (__IOSurface *)(*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a1 + 224))(*(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 16), a3);
  if (v16 && (gIIODebugFlags & 0xC) != 0)
  {
    *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136);
    IIOImageProviderInfo::logSurfaceDecodingTime((IIOImageProviderInfo *)a1, v16);
  }
  if (v14 && v13)
    IIOImageReadSession::unmapData(v13);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144));
  v15 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x400000000000) == 0)
    goto LABEL_29;
  if (!v16)
    goto LABEL_28;
  Width = IOSurfaceGetWidth(v16);
  Height = IOSurfaceGetHeight(v16);
  BytesPerRow = IOSurfaceGetBytesPerRow(v16);
  PixelFormat = IOSurfaceGetPixelFormat(v16);
  v21 = PixelFormat;
  v22 = PixelFormat >> 24;
  v23 = MEMORY[0x1E0C80978];
  if (PixelFormat < 0)
    v24 = __maskrune(PixelFormat >> 24, 0x40000uLL);
  else
    v24 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v22 + 60) & 0x40000;
  if (v24)
    v26 = v22;
  else
    v26 = 46;
  v27 = v21 << 8 >> 24;
  if (v21 << 8 < 0)
    v28 = __maskrune(v21 << 8 >> 24, 0x40000uLL);
  else
    v28 = *(_DWORD *)(v23 + 4 * v27 + 60) & 0x40000;
  if (v28)
    v29 = v27;
  else
    v29 = 46;
  v30 = (__int16)v21 >> 8;
  if (v21 << 16 < 0)
    v31 = __maskrune((__int16)v21 >> 8, 0x40000uLL);
  else
    v31 = *(_DWORD *)(v23 + 4 * v30 + 60) & 0x40000;
  if (v31)
    v32 = v30;
  else
    v32 = 46;
  if ((v21 << 24) <= 0x7F000000)
    v33 = *(_DWORD *)(v23 + 4 * (char)v21 + 60) & 0x40000;
  else
    v33 = __maskrune((char)v21, 0x40000uLL);
  if (v33)
    v34 = (char)v21;
  else
    v34 = 46;
  ImageIOLog("    copyIOSurface - <IOSurface:%p> '%c%c%c%c'  {%ld, %ld} rb: %ld\n", v16, v26, v29, v32, v34, Width, Height, BytesPerRow);
  return v16;
}

IOSurfaceRef IIO_Reader::CopyIOSurfaceProc(uint64_t a1, uint64_t a2, const void *a3)
{
  IIOReadPlugin *v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  double v20;
  double v21;
  double v22;
  double v23;
  int v24;
  CGColorSpace *ColorSpace;
  unsigned int v26;
  int v27;
  __n128 v28;
  int v29;
  const char *v30;
  int v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  IOSurfaceRef result;
  uint64_t v56;
  unsigned int v57;
  int v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  _DWORD *exception;
  _OWORD v66[5];
  uint64_t v67;
  IOSurfaceRef SurfaceWithFormat;

  SurfaceWithFormat = 0;
  v6 = *(IIOReadPlugin **)(a1 + 8);
  if ((*(unsigned int (**)(IIOReadPlugin *, const void *))(*(_QWORD *)v6 + 72))(v6, a3))
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v7 = (*(uint64_t (**)(IIOReadPlugin *))(*(_QWORD *)v6 + 24))(v6);
  v8 = *((_DWORD *)v6 + 51);
  v9 = v8 >> 24;
  v10 = MEMORY[0x1E0C80978];
  if (v8 < 0)
  {
    v11 = __maskrune(v9, 0x40000uLL);
    v8 = *((_DWORD *)v6 + 51);
  }
  else
  {
    v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
  }
  if (v11)
    v12 = (v8 >> 24);
  else
    v12 = 46;
  v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    v14 = __maskrune(v13, 0x40000uLL);
    v8 = *((_DWORD *)v6 + 51);
  }
  else
  {
    v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14)
    v15 = (v8 << 8 >> 24);
  else
    v15 = 46;
  v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    v17 = __maskrune(v16, 0x40000uLL);
    v8 = *((_DWORD *)v6 + 51);
  }
  else
  {
    v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17)
    v18 = ((__int16)v8 >> 8);
  else
    v18 = 46;
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
      goto LABEL_22;
LABEL_24:
    LOBYTE(v19) = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL))
    goto LABEL_24;
LABEL_22:
  v19 = *((_DWORD *)v6 + 51);
LABEL_25:
  _cg_jpeg_mem_term("CopyIOSurfaceProc", 1591, "*** IIO_Reader::CopyIOSurfaceProc - using new '%c%c%c%c'- callDecodeImage [kIIOImageType_IOSurface]\n", v12, v15, v18, (char)v19);
  CGImageProviderGetSize();
  v21 = v20;
  v23 = v22;
  if (v7)
  {
    v24 = (*(uint64_t (**)(IIOReadPlugin *))(*(_QWORD *)v6 + 16))(v6);
    ColorSpace = (CGColorSpace *)CGImageProviderGetColorSpace();
    SurfaceWithFormat = IIO_CreateSurfaceWithFormat(v24, (unint64_t)v21, (unint64_t)v23, ColorSpace);
    if (!SurfaceWithFormat)
    {
      v34 = v24 >> 24;
      if (v24 < 0)
        v35 = __maskrune(v24 >> 24, 0x40000uLL);
      else
        v35 = *(_DWORD *)(v10 + 4 * v34 + 60) & 0x40000;
      if (v35)
        v56 = v34;
      else
        v56 = 46;
      v57 = v24 << 8 >> 24;
      if (v24 << 8 < 0)
        v58 = __maskrune(v24 << 8 >> 24, 0x40000uLL);
      else
        v58 = *(_DWORD *)(v10 + 4 * v57 + 60) & 0x40000;
      if (v58)
        v59 = v57;
      else
        v59 = 46;
      v60 = (__int16)v24 >> 8;
      if (v24 << 16 < 0)
        v61 = __maskrune((__int16)v24 >> 8, 0x40000uLL);
      else
        v61 = *(_DWORD *)(v10 + 4 * v60 + 60) & 0x40000;
      if ((v24 << 24) <= 0x7F000000)
        v62 = *(_DWORD *)(v10 + 4 * (char)v24 + 60) & 0x40000;
      else
        v62 = __maskrune((char)v24, 0x40000uLL);
      if (v61)
        v63 = v60;
      else
        v63 = 46;
      if (v62)
        v64 = (char)v24;
      else
        v64 = 46;
      _cg_jpeg_mem_term("CopyIOSurfaceProc", 1599, "*** ERROR: IIO_CreateSurfaceWithFormat '%c%c%c%c'\n", v56, v59, v63, v64);
      return 0;
    }
  }
  v67 = 0;
  memset(v66, 0, sizeof(v66));
  v26 = IIOReadPlugin::index(v6);
  IIODecodeParameter::IIODecodeParameter((uint64_t)v66, a1, a2, v26, a3, 0.0, 0.0, v21, v23, v21, v23);
  v27 = IIOReadPlugin::callDecodeImage((uint64_t)v6, (uint64_t)v66, 1, &SurfaceWithFormat, 0, 0);
  if (v27 == -1400)
  {
    ImageIOLog("‼️ retrying 'decodeImage' (ImageIOXPCService crashed?)\n");
    v29 = IIOReadPlugin::callDecodeImage((uint64_t)v6, (uint64_t)v66, 1, &SurfaceWithFormat, 0, 0);
    v27 = v29;
    v30 = "❌";
    if (!v29)
      v30 = "✅";
    ImageIOLog("%s retrying 'decodeImage'  err: %d\n", v30, v29);
  }
  if (v27)
  {
    if (v27 != -56)
      goto LABEL_59;
    v31 = *((_DWORD *)v6 + 51);
    v32 = v31 >> 24;
    if (v31 < 0)
    {
      v33 = __maskrune(v32, 0x40000uLL);
      v31 = *((_DWORD *)v6 + 51);
    }
    else
    {
      v33 = *(_DWORD *)(v10 + 4 * v32 + 60) & 0x40000;
    }
    if (v33)
      v36 = (v31 >> 24);
    else
      v36 = 46;
    v37 = v31 << 8 >> 24;
    if (v31 << 8 < 0)
    {
      v38 = __maskrune(v37, 0x40000uLL);
      v31 = *((_DWORD *)v6 + 51);
    }
    else
    {
      v38 = *(_DWORD *)(v10 + 4 * v37 + 60) & 0x40000;
    }
    if (v38)
      v39 = (v31 << 8 >> 24);
    else
      v39 = 46;
    v40 = (__int16)v31 >> 8;
    if (v31 << 16 < 0)
    {
      v41 = __maskrune(v40, 0x40000uLL);
      v31 = *((_DWORD *)v6 + 51);
    }
    else
    {
      v41 = *(_DWORD *)(v10 + 4 * v40 + 60) & 0x40000;
    }
    if (v41)
      v42 = ((__int16)v31 >> 8);
    else
      v42 = 46;
    if ((v31 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v31 + 60) & 0x40000) != 0)
        goto LABEL_55;
    }
    else if (__maskrune((char)v31, 0x40000uLL))
    {
LABEL_55:
      v43 = *((char *)v6 + 204);
LABEL_58:
      LogError("CopyIOSurfaceProc", 1615, "*** IIO_Reader::CopyIOSurfaceProc - '%c%c%c%c'- does not support 'callDecodeImage'\n", v36, v39, v42, v43);
LABEL_59:
      v44 = *((_DWORD *)v6 + 51);
      v45 = v44 >> 24;
      if (v44 < 0)
      {
        v46 = __maskrune(v45, 0x40000uLL);
        v44 = *((_DWORD *)v6 + 51);
      }
      else
      {
        v46 = *(_DWORD *)(v10 + 4 * v45 + 60) & 0x40000;
      }
      if (v46)
        v47 = (v44 >> 24);
      else
        v47 = 46;
      v48 = v44 << 8 >> 24;
      if (v44 << 8 < 0)
      {
        v49 = __maskrune(v48, 0x40000uLL);
        v44 = *((_DWORD *)v6 + 51);
      }
      else
      {
        v49 = *(_DWORD *)(v10 + 4 * v48 + 60) & 0x40000;
      }
      if (v49)
        v50 = (v44 << 8 >> 24);
      else
        v50 = 46;
      v51 = (__int16)v44 >> 8;
      if (v44 << 16 < 0)
      {
        v52 = __maskrune(v51, 0x40000uLL);
        v44 = *((_DWORD *)v6 + 51);
      }
      else
      {
        v52 = *(_DWORD *)(v10 + 4 * v51 + 60) & 0x40000;
      }
      if (v52)
        v53 = ((__int16)v44 >> 8);
      else
        v53 = 46;
      if ((v44 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v10 + 4 * (char)v44 + 60) & 0x40000) != 0)
          goto LABEL_79;
      }
      else if (__maskrune((char)v44, 0x40000uLL))
      {
LABEL_79:
        v54 = *((char *)v6 + 204);
LABEL_82:
        v28 = _cg_jpeg_mem_term("CopyIOSurfaceProc", 1618, "*** ERROR: '%c%c%c%c' callDecodeImage failed [%d]\n", v47, v50, v53, v54, v27);
        goto LABEL_83;
      }
      v54 = 46;
      goto LABEL_82;
    }
    v43 = 46;
    goto LABEL_58;
  }
LABEL_83:
  if ((*(unsigned int (**)(IIOReadPlugin *, __n128))(*(_QWORD *)v6 + 256))(v6, v28))
    IIOReadPlugin::debugWriteIOSurface(v6, SurfaceWithFormat);
  (*(void (**)(IIOReadPlugin *))(*(_QWORD *)v6 + 80))(v6);
  IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)v66);
  result = SurfaceWithFormat;
  if ((gIIODebugFlags & 0x800000000000) != 0 && !SurfaceWithFormat)
  {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CopyIOSurfaceProc", 1631, "could not create IOSurfaceRef");
    return SurfaceWithFormat;
  }
  return result;
}

void sub_187EBF3D4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;

  __cxa_begin_catch(a1);
  *(_QWORD *)(v15 - 104) = 0;
  __cxa_end_catch();
  JUMPOUT(0x187EBF268);
}

uint64_t IIOReadPlugin::shouldDebugWriteImageBlocks(IIOReadPlugin *this)
{
  return *((unsigned __int8 *)this + 176);
}

uint64_t IIOReadPlugin::canHandleRemoteIOSurface(IIOReadPlugin *this)
{
  return 0;
}

BOOL ___Z15AppleEXREnabledv_block_invoke()
{
  _BOOL8 result;

  result = IIOLoadAppleOpenExrSymbols();
  if (!result)
    gAppleEXREnabled = 1;
  return result;
}

BOOL IIOLoadAppleOpenExrSymbols(void)
{
  void *v0;
  void *v1;

  v0 = dlopen("/usr/lib/libAppleEXR.dylib", 257);
  v1 = v0;
  if (v0)
  {
    gFunc_axr_get_version = (uint64_t)dlsym(v0, "axr_get_version");
    gFunc_axr_channel_type_get_name = (uint64_t)dlsym(v1, "axr_channel_type_get_name");
    gFunc_axr_compression_get_name = dlsym(v1, "axr_compression_get_name");
    gFunc_axr_error_get_name = dlsym(v1, "axr_error_get_name");
    gFunc_axr_flags_get_name = (uint64_t)dlsym(v1, "axr_flags_get_name");
    gFunc_axr_line_order_get_name = (uint64_t)dlsym(v1, "axr_line_order_get_name");
    gFunc_axr_property_flags_get_name = (uint64_t)dlsym(v1, "axr_property_flags_get_name");
    gFunc_axr_type_get_name = (uint64_t)dlsym(v1, "axr_type_get_name");
    gFunc_axr_type_get_size = (uint64_t)dlsym(v1, "axr_type_get_size");
    gFunc_axr_introspect_data = (uint64_t (*)(_QWORD, _QWORD, _QWORD))dlsym(v1, "axr_introspect_data");
    gFunc_axr_data_create = dlsym(v1, "axr_data_create");
    gFunc_axr_data_create_logical_image_list = dlsym(v1, "axr_data_create_logical_image_list");
    gFunc_axr_data_get_channel_count = dlsym(v1, "axr_data_get_channel_count");
    gFunc_axr_data_get_channel_info = dlsym(v1, "axr_data_get_channel_info");
    gFunc_axr_data_get_layer_count = (uint64_t)dlsym(v1, "axr_data_get_layer_count");
    gFunc_axr_data_get_layer_info = (uint64_t)dlsym(v1, "axr_data_get_layer_info");
    gFunc_axr_data_get_level_count = (uint64_t)dlsym(v1, "axr_data_get_level_count");
    gFunc_axr_data_get_level_size = (uint64_t)dlsym(v1, "axr_data_get_level_size");
    gFunc_axr_data_get_part_count = dlsym(v1, "axr_data_get_part_count");
    gFunc_axr_data_get_part_info = dlsym(v1, "axr_data_get_part_info");
    gFunc_axr_data_get_property_count = (uint64_t (*)(_QWORD, _QWORD))dlsym(v1, "axr_data_get_property_count");
    gFunc_axr_data_get_property = (_QWORD *(*)(_QWORD *__return_ptr, _QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "axr_data_get_property");
    gFunc_axr_decoder_create = (uint64_t)dlsym(v1, "axr_decoder_create");
    gFunc_axr_decoder_copy = (uint64_t)dlsym(v1, "axr_decoder_copy");
    gFunc_axr_decoder_append_channel = (uint64_t)dlsym(v1, "axr_decoder_append_channel");
    gFunc_axr_decoder_append_constant_value_channel = (uint64_t)dlsym(v1, "axr_decoder_append_constant_value_channel");
    gFunc_axr_decoder_clear_channel_list = (uint64_t)dlsym(v1, "axr_decoder_clear_channel_list");
    gFunc_axr_decoder_create_colorspace = dlsym(v1, "axr_decoder_create_colorspace");
    gFunc_axr_decoder_get_channel_count = dlsym(v1, "axr_decoder_get_channel_count");
    gFunc_axr_decoder_get_channel_info = (uint64_t)dlsym(v1, "axr_decoder_get_channel_info");
    gFunc_axr_decoder_get_data = (uint64_t)dlsym(v1, "axr_decoder_get_data");
    gFunc_axr_decoder_get_info = (uint64_t)dlsym(v1, "axr_decoder_get_info");
    gFunc_axr_decoder_get_read_pixels_info = dlsym(v1, "axr_decoder_get_read_pixels_info");
    gFunc_axr_decoder_get_read_planes_info = (uint64_t)dlsym(v1, "axr_decoder_get_read_planes_info");
    gFunc_axr_decoder_get_read_rgba_pixels_info = dlsym(v1, "axr_decoder_get_read_rgba_pixels_info");
    gFunc_axr_decoder_translate_channel_index = (uint64_t)dlsym(v1, "axr_decoder_translate_channel_index");
    gFunc_axr_decoder_set_subregion = (uint64_t)dlsym(v1, "axr_decoder_set_subregion");
    gFunc_axr_decoder_read_pixels = dlsym(v1, "axr_decoder_read_pixels");
    gFunc_axr_decoder_read_planes = (uint64_t)dlsym(v1, "axr_decoder_read_planes");
    gFunc_axr_decoder_read_rgba_pixels = dlsym(v1, "axr_decoder_read_rgba_pixels");
    gFunc_axr_encoder_append_part = dlsym(v1, "axr_encoder_append_part");
    gFunc_axr_encoder_compress = dlsym(v1, "axr_encoder_compress");
    gFunc_axr_encoder_create = dlsym(v1, "axr_encoder_create");
    gFunc_axr_part_append_attribute = (uint64_t)dlsym(v1, "axr_part_append_attribute");
    gFunc_axr_part_append_channels = dlsym(v1, "axr_part_append_channels");
    gFunc_axr_part_create = (uint64_t)dlsym(v1, "axr_part_create");
    gFunc_axr_part_set_preview = (uint64_t)dlsym(v1, "axr_part_set_preview");
    gFunc_axr_part_set_chromaticities = dlsym(v1, "axr_part_set_chromaticities");
    gFunc_axr_part_create_colorspace = dlsym(v1, "axr_part_create_colorspace");
    gFunc_axr_logical_image_list_create_decoder = dlsym(v1, "axr_logical_image_list_create_decoder");
    gFunc_axr_logical_image_list_deserialize = (uint64_t)dlsym(v1, "axr_logical_image_list_deserialize");
    gFunc_axr_logical_image_list_get_default_image_index = (uint64_t)dlsym(v1, "axr_logical_image_list_get_default_image_index");
    gFunc_axr_logical_image_list_get_default_view_index = (uint64_t)dlsym(v1, "axr_logical_image_list_get_default_view_index");
    gFunc_axr_logical_image_list_get_image_count = dlsym(v1, "axr_logical_image_list_get_image_count");
    gFunc_axr_logical_image_list_get_image_info = dlsym(v1, "axr_logical_image_list_get_image_info");
    gFunc_axr_logical_image_list_get_image_name = dlsym(v1, "axr_logical_image_list_get_image_name");
    gFunc_axr_logical_image_list_get_serialized_size = (uint64_t)dlsym(v1, "axr_logical_image_list_get_serialized_size");
    gFunc_axr_logical_image_list_get_view_count = dlsym(v1, "axr_logical_image_list_get_view_count");
    gFunc_axr_logical_image_list_get_view_name = dlsym(v1, "axr_logical_image_list_get_view_name");
    gFunc_axr_logical_image_list_is_equal = (uint64_t)dlsym(v1, "axr_logical_image_list_is_equal");
    gFunc_axr_logical_image_list_serialize = (uint64_t)dlsym(v1, "axr_logical_image_list_serialize");
  }
  return v1 != 0;
}

uint64_t IIOLoadCoreVideoSymbols(void)
{
  uint64_t result;
  void *v1;
  char v2[72];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  strcpy(v2, "/System/Library/Frameworks/CoreVideo.framework/CoreVideo");
  result = (uint64_t)dlopen(v2, 257);
  if (result)
  {
    v1 = (void *)result;
    gFunc_CVPixelBufferCreateWithBytes = dlsym((void *)result, "CVPixelBufferCreateWithBytes");
    if (!gFunc_CVPixelBufferCreateWithBytes)
      puts("❌  failed to load 'CVPixelBufferCreateWithBytes' ");
    gFunc_CVPixelBufferRelease = (__n128 (*)(__n128))dlsym(v1, "CVPixelBufferRelease");
    if (!gFunc_CVPixelBufferRelease)
      puts("❌  failed to load 'CVPixelBufferRelease' ");
    gFunc_CVPixelBufferCreateWithBytes = dlsym(v1, "CVPixelBufferCreateWithBytes");
    if (!gFunc_CVPixelBufferCreateWithBytes)
      puts("❌  failed to load 'CVPixelBufferCreateWithBytes' ");
    gFunc_CVPixelBufferRelease = (__n128 (*)(__n128))dlsym(v1, "CVPixelBufferRelease");
    if (!gFunc_CVPixelBufferRelease)
      puts("❌  failed to load 'CVPixelBufferRelease' ");
    gFunc_CVPixelBufferLockBaseAddress = (uint64_t (*)(_QWORD, _QWORD))dlsym(v1, "CVPixelBufferLockBaseAddress");
    if (!gFunc_CVPixelBufferLockBaseAddress)
      puts("❌  failed to load 'CVPixelBufferLockBaseAddress' ");
    gFunc_CVPixelBufferUnlockBaseAddress = (double (*)(_QWORD, _QWORD, __n128))dlsym(v1, "CVPixelBufferUnlockBaseAddress");
    if (!gFunc_CVPixelBufferUnlockBaseAddress)
      puts("❌  failed to load 'CVPixelBufferUnlockBaseAddress' ");
    gFunc_CVPixelBufferGetWidth = (uint64_t (*)(_QWORD))dlsym(v1, "CVPixelBufferGetWidth");
    if (!gFunc_CVPixelBufferGetWidth)
      puts("❌  failed to load 'CVPixelBufferGetWidth' ");
    gFunc_CVPixelBufferGetHeight = (uint64_t (*)(_QWORD))dlsym(v1, "CVPixelBufferGetHeight");
    if (!gFunc_CVPixelBufferGetHeight)
      puts("❌  failed to load 'CVPixelBufferGetHeight' ");
    gFunc_CVPixelBufferGetIOSurface = (uint64_t (*)(_QWORD))dlsym(v1, "CVPixelBufferGetIOSurface");
    if (!gFunc_CVPixelBufferGetIOSurface)
      puts("❌  failed to load 'CVPixelBufferGetIOSurface' ");
    gFunc_CVPixelBufferGetPixelFormatType = (uint64_t (*)(_QWORD))dlsym(v1, "CVPixelBufferGetPixelFormatType");
    if (!gFunc_CVPixelBufferGetPixelFormatType)
      puts("❌  failed to load 'CVPixelBufferGetPixelFormatType' ");
    gFunc_CVPixelBufferGetBaseAddress = (uint64_t (*)(_QWORD))dlsym(v1, "CVPixelBufferGetBaseAddress");
    if (!gFunc_CVPixelBufferGetBaseAddress)
      puts("❌  failed to load 'CVPixelBufferGetBaseAddress' ");
    gFunc_CVPixelBufferGetBytesPerRow = (uint64_t (*)(_QWORD))dlsym(v1, "CVPixelBufferGetBytesPerRow");
    if (!gFunc_CVPixelBufferGetBytesPerRow)
      puts("❌  failed to load 'CVPixelBufferGetBytesPerRow' ");
    gFunc_CVPixelBufferGetDataSize = (uint64_t)dlsym(v1, "CVPixelBufferGetDataSize");
    if (!gFunc_CVPixelBufferGetDataSize)
      puts("❌  failed to load 'CVPixelBufferGetDataSize' ");
    gFunc_CVPixelBufferIsPlanar = (uint64_t (*)(_QWORD))dlsym(v1, "CVPixelBufferIsPlanar");
    if (!gFunc_CVPixelBufferIsPlanar)
      puts("❌  failed to load 'CVPixelBufferIsPlanar' ");
    gFunc_CVBufferSetAttachment = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CVBufferSetAttachment");
    if (!gFunc_CVBufferSetAttachment)
      puts("❌  failed to load 'CVBufferSetAttachment' ");
    gFunc_CVPixelBufferCreateWithIOSurface = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))dlsym(v1, "CVPixelBufferCreateWithIOSurface");
    if (!gFunc_CVPixelBufferCreateWithIOSurface)
      puts("❌  failed to load 'CVPixelBufferCreateWithIOSurface' ");
    gFunc_CVBufferCopyAttachment = dlsym(v1, "CVBufferCopyAttachment");
    if (!gFunc_CVBufferCopyAttachment)
      puts("❌  failed to load 'CVBufferCopyAttachment' ");
    gFunc_CVBufferCopyAttachments = dlsym(v1, "CVBufferCopyAttachments");
    if (!gFunc_CVBufferCopyAttachments)
      puts("❌  failed to load 'CVBufferCopyAttachments' ");
    gFunc_CVImageBufferCreateColorSpaceFromAttachments = dlsym(v1, "CVImageBufferCreateColorSpaceFromAttachments");
    if (!gFunc_CVImageBufferCreateColorSpaceFromAttachments)
      puts("❌  failed to load 'CVImageBufferCreateColorSpaceFromAttachments' ");
    gFunc_CVImageBufferGetColorSpace = dlsym(v1, "CVImageBufferGetColorSpace");
    if (!gFunc_CVImageBufferGetColorSpace)
      puts("❌  failed to load 'CVImageBufferGetColorSpace' ");
    gFunc_CVImageBufferSetColorSpace = (uint64_t (*)(_QWORD, _QWORD))dlsym(v1, "CVImageBufferSetColorSpace");
    if (!gFunc_CVImageBufferSetColorSpace)
      puts("❌  failed to load 'CVImageBufferSetColorSpace' ");
    gFunc_CVMetalTextureCacheCreate = dlsym(v1, "CVMetalTextureCacheCreate");
    if (!gFunc_CVMetalTextureCacheCreate)
      puts("❌  failed to load 'CVMetalTextureCacheCreate' ");
    gFunc_CVMetalTextureCacheCreateTextureFromImage = dlsym(v1, "CVMetalTextureCacheCreateTextureFromImage");
    if (!gFunc_CVMetalTextureCacheCreateTextureFromImage)
      puts("❌  failed to load 'CVMetalTextureCacheCreateTextureFromImage' ");
    gFunc_CVMetalTextureGetTexture = dlsym(v1, "CVMetalTextureGetTexture");
    if (!gFunc_CVMetalTextureGetTexture)
      puts("❌  failed to load 'CVMetalTextureGetTexture' ");
    gFunc_CVPixelBufferGetHeightOfPlane = dlsym(v1, "CVPixelBufferGetHeightOfPlane");
    if (!gFunc_CVPixelBufferGetHeightOfPlane)
      puts("❌  failed to load 'CVPixelBufferGetHeightOfPlane' ");
    gFunc_CVPixelBufferGetWidthOfPlane = dlsym(v1, "CVPixelBufferGetWidthOfPlane");
    if (!gFunc_CVPixelBufferGetWidthOfPlane)
      puts("❌  failed to load 'CVPixelBufferGetWidthOfPlane' ");
    gFunc_CVPixelBufferGetBytesPerRowOfPlane = dlsym(v1, "CVPixelBufferGetBytesPerRowOfPlane");
    if (!gFunc_CVPixelBufferGetBytesPerRowOfPlane)
      puts("❌  failed to load 'CVPixelBufferGetBytesPerRowOfPlane' ");
    gFunc_CVPixelBufferGetBaseAddressOfPlane = dlsym(v1, "CVPixelBufferGetBaseAddressOfPlane");
    if (!gFunc_CVPixelBufferGetBaseAddressOfPlane)
      puts("❌  failed to load 'CVPixelBufferGetBaseAddressOfPlane' ");
    gFunc_CVPixelBufferRetain = dlsym(v1, "CVPixelBufferRetain");
    if (!gFunc_CVPixelBufferRetain)
      puts("❌  failed to load 'CVPixelBufferRetain' ");
    gFunc_CVPixelFormatDescriptionCreateWithPixelFormatType = (uint64_t (*)(_QWORD, _QWORD))dlsym(v1, "CVPixelFormatDescriptionCreateWithPixelFormatType");
    if (!gFunc_CVPixelFormatDescriptionCreateWithPixelFormatType)
      puts("❌  failed to load 'CVPixelFormatDescriptionCreateWithPixelFormatType' ");
    gFunc_CVColorPrimariesGetStringForIntegerCodePoint = dlsym(v1, "CVColorPrimariesGetStringForIntegerCodePoint");
    if (!gFunc_CVColorPrimariesGetStringForIntegerCodePoint)
      puts("❌  failed to load 'CVColorPrimariesGetStringForIntegerCodePoint' ");
    gFunc_CVTransferFunctionGetStringForIntegerCodePoint = dlsym(v1, "CVTransferFunctionGetStringForIntegerCodePoint");
    if (!gFunc_CVTransferFunctionGetStringForIntegerCodePoint)
      puts("❌  failed to load 'CVTransferFunctionGetStringForIntegerCodePoint' ");
    gFunc_CVYCbCrMatrixGetStringForIntegerCodePoint = dlsym(v1, "CVYCbCrMatrixGetStringForIntegerCodePoint");
    if (!gFunc_CVYCbCrMatrixGetStringForIntegerCodePoint)
      puts("❌  failed to load 'CVYCbCrMatrixGetStringForIntegerCodePoint' ");
    gFunc_CVYCbCrMatrixGetIntegerCodePointForString = dlsym(v1, "CVYCbCrMatrixGetIntegerCodePointForString");
    if (!gFunc_CVYCbCrMatrixGetIntegerCodePointForString)
      puts("❌  failed to load 'CVYCbCrMatrixGetIntegerCodePointForString' ");
    gIIO_kCVImageBufferAlphaChannelIsOpaque = (uint64_t)dlsym(v1, "kCVImageBufferAlphaChannelIsOpaque");
    if (!gIIO_kCVImageBufferAlphaChannelIsOpaque)
      puts("❌  failed to load 'kCVImageBufferAlphaChannelIsOpaque' ");
    gIIO_kCVImageBufferAlphaChannelModeKey = (uint64_t)dlsym(v1, "kCVImageBufferAlphaChannelModeKey");
    if (!gIIO_kCVImageBufferAlphaChannelModeKey)
      puts("❌  failed to load 'kCVImageBufferAlphaChannelModeKey' ");
    gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha = (uint64_t)dlsym(v1, "kCVImageBufferAlphaChannelMode_StraightAlpha");
    if (!gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha)
      puts("❌  failed to load 'kCVImageBufferAlphaChannelMode_StraightAlpha' ");
    gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha = (uint64_t)dlsym(v1, "kCVImageBufferAlphaChannelMode_PremultipliedAlpha");
    if (!gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha)
      puts("❌  failed to load 'kCVImageBufferAlphaChannelMode_PremultipliedAlpha' ");
    gIIO_kCVImageBufferCGColorSpaceKey = (uint64_t)dlsym(v1, "kCVImageBufferCGColorSpaceKey");
    if (!gIIO_kCVImageBufferCGColorSpaceKey)
      puts("❌  failed to load 'kCVImageBufferCGColorSpaceKey' ");
    gIIO_kCVPixelBufferPixelFormatTypeKey = (uint64_t)dlsym(v1, "kCVPixelBufferPixelFormatTypeKey");
    if (!gIIO_kCVPixelBufferPixelFormatTypeKey)
      puts("❌  failed to load 'kCVPixelBufferPixelFormatTypeKey' ");
    gIIO_kCVPixelBufferPixelFormatDescriptionKey = (uint64_t)dlsym(v1, "kCVPixelBufferPixelFormatDescriptionKey");
    if (!gIIO_kCVPixelBufferPixelFormatDescriptionKey)
      puts("❌  failed to load 'kCVPixelBufferPixelFormatDescriptionKey' ");
    gIIO_kCVPixelFormatConstant = (uint64_t)dlsym(v1, "kCVPixelFormatConstant");
    if (!gIIO_kCVPixelFormatConstant)
      puts("❌  failed to load 'kCVPixelFormatConstant' ");
    gIIO_kCVPixelFormatBitsPerBlock = (uint64_t)dlsym(v1, "kCVPixelFormatBitsPerBlock");
    if (!gIIO_kCVPixelFormatBitsPerBlock)
      puts("❌  failed to load 'kCVPixelFormatBitsPerBlock' ");
    gIIO_kCVPixelBufferWidthKey = (uint64_t)dlsym(v1, "kCVPixelBufferWidthKey");
    if (!gIIO_kCVPixelBufferWidthKey)
      puts("❌  failed to load 'kCVPixelBufferWidthKey' ");
    gIIO_kCVPixelBufferHeightKey = (uint64_t)dlsym(v1, "kCVPixelBufferHeightKey");
    if (!gIIO_kCVPixelBufferHeightKey)
      puts("❌  failed to load 'kCVPixelBufferHeightKey' ");
    gIIO_kCVPixelBufferBytesPerRowAlignmentKey = (uint64_t)dlsym(v1, "kCVPixelBufferBytesPerRowAlignmentKey");
    if (!gIIO_kCVPixelBufferBytesPerRowAlignmentKey)
      puts("❌  failed to load 'kCVPixelBufferBytesPerRowAlignmentKey' ");
    gIIO_kCVImageBufferYCbCrMatrixKey = (uint64_t)dlsym(v1, "kCVImageBufferYCbCrMatrixKey");
    if (!gIIO_kCVImageBufferYCbCrMatrixKey)
      puts("❌  failed to load 'kCVImageBufferYCbCrMatrixKey' ");
    gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020 = (uint64_t)dlsym(v1, "kCVImageBufferYCbCrMatrix_ITU_R_2020");
    if (!gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020)
      puts("❌  failed to load 'kCVImageBufferYCbCrMatrix_ITU_R_2020' ");
    gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4 = (uint64_t)dlsym(v1, "kCVImageBufferYCbCrMatrix_ITU_R_601_4");
    if (!gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4)
      puts("❌  failed to load 'kCVImageBufferYCbCrMatrix_ITU_R_601_4' ");
    gIIO_kCVImageBufferYCbCrMatrix_ITU_R_709_2 = (uint64_t)dlsym(v1, "kCVImageBufferYCbCrMatrix_ITU_R_709_2");
    if (!gIIO_kCVImageBufferYCbCrMatrix_ITU_R_709_2)
      puts("❌  failed to load 'kCVImageBufferYCbCrMatrix_ITU_R_709_2' ");
    gIIO_kCVPixelFormatContainsRGB = (uint64_t)dlsym(v1, "kCVPixelFormatContainsRGB");
    if (!gIIO_kCVPixelFormatContainsRGB)
      puts("❌  failed to load 'kCVPixelFormatContainsRGB' ");
    gIIO_kCVPixelFormatContainsYCbCr = (uint64_t)dlsym(v1, "kCVPixelFormatContainsYCbCr");
    if (!gIIO_kCVPixelFormatContainsYCbCr)
      puts("❌  failed to load 'kCVPixelFormatContainsYCbCr' ");
    gIIO_kCVPixelFormatContainsGrayscale = (uint64_t)dlsym(v1, "kCVPixelFormatContainsGrayscale");
    if (!gIIO_kCVPixelFormatContainsGrayscale)
      puts("❌  failed to load 'kCVPixelFormatContainsGrayscale' ");
    gIIO_kCVPixelFormatHorizontalSubsampling = (uint64_t)dlsym(v1, "kCVPixelFormatHorizontalSubsampling");
    if (!gIIO_kCVPixelFormatHorizontalSubsampling)
      puts("❌  failed to load 'kCVPixelFormatHorizontalSubsampling' ");
    gIIO_kCVPixelFormatVerticalSubsampling = (uint64_t)dlsym(v1, "kCVPixelFormatVerticalSubsampling");
    if (!gIIO_kCVPixelFormatVerticalSubsampling)
      puts("❌  failed to load 'kCVPixelFormatVerticalSubsampling' ");
    gIIO_kCVImageBufferChromaLocationBottomFieldKey = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocationBottomFieldKey");
    if (!gIIO_kCVImageBufferChromaLocationBottomFieldKey)
      puts("❌  failed to load 'kCVImageBufferChromaLocationBottomFieldKey' ");
    gIIO_kCVImageBufferChromaLocationTopFieldKey = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocationTopFieldKey");
    if (!gIIO_kCVImageBufferChromaLocationTopFieldKey)
      puts("❌  failed to load 'kCVImageBufferChromaLocationTopFieldKey' ");
    gIIO_kCVImageBufferChromaLocation_Bottom = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_Bottom");
    if (!gIIO_kCVImageBufferChromaLocation_Bottom)
      puts("❌  failed to load 'kCVImageBufferChromaLocation_Bottom' ");
    gIIO_kCVImageBufferChromaLocation_BottomLeft = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_BottomLeft");
    if (!gIIO_kCVImageBufferChromaLocation_BottomLeft)
      puts("❌  failed to load 'kCVImageBufferChromaLocation_BottomLeft' ");
    gIIO_kCVImageBufferChromaLocation_Center = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_Center");
    if (!gIIO_kCVImageBufferChromaLocation_Center)
      puts("❌  failed to load 'kCVImageBufferChromaLocation_Center' ");
    gIIO_kCVImageBufferChromaLocation_DV420 = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_DV420");
    if (!gIIO_kCVImageBufferChromaLocation_DV420)
      puts("❌  failed to load 'kCVImageBufferChromaLocation_DV420' ");
    gIIO_kCVImageBufferChromaLocation_Left = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_Left");
    if (!gIIO_kCVImageBufferChromaLocation_Left)
      puts("❌  failed to load 'kCVImageBufferChromaLocation_Left' ");
    gIIO_kCVImageBufferChromaLocation_Top = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_Top");
    if (!gIIO_kCVImageBufferChromaLocation_Top)
      puts("❌  failed to load 'kCVImageBufferChromaLocation_Top' ");
    gIIO_kCVImageBufferChromaLocation_TopLeft = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_TopLeft");
    if (!gIIO_kCVImageBufferChromaLocation_TopLeft)
      puts("❌  failed to load 'kCVImageBufferChromaLocation_TopLeft' ");
    gIIO_kCVImageBufferChromaSubsamplingKey = (uint64_t)dlsym(v1, "kCVImageBufferChromaSubsamplingKey");
    if (!gIIO_kCVImageBufferChromaSubsamplingKey)
      puts("❌  failed to load 'kCVImageBufferChromaSubsamplingKey' ");
    gIIO_kCVImageBufferChromaSubsampling_411 = (uint64_t)dlsym(v1, "kCVImageBufferChromaSubsampling_411");
    if (!gIIO_kCVImageBufferChromaSubsampling_411)
      puts("❌  failed to load 'kCVImageBufferChromaSubsampling_411' ");
    gIIO_kCVImageBufferChromaSubsampling_420 = (uint64_t)dlsym(v1, "kCVImageBufferChromaSubsampling_420");
    if (!gIIO_kCVImageBufferChromaSubsampling_420)
      puts("❌  failed to load 'kCVImageBufferChromaSubsampling_420' ");
    gIIO_kCVImageBufferChromaSubsampling_422 = (uint64_t)dlsym(v1, "kCVImageBufferChromaSubsampling_422");
    if (!gIIO_kCVImageBufferChromaSubsampling_422)
      puts("❌  failed to load 'kCVImageBufferChromaSubsampling_422' ");
    gIIO_kCVImageBufferColorPrimariesKey = (uint64_t)dlsym(v1, "kCVImageBufferColorPrimariesKey");
    if (!gIIO_kCVImageBufferColorPrimariesKey)
      puts("❌  failed to load 'kCVImageBufferColorPrimariesKey' ");
    gIIO_kCVImageBufferContentLightLevelInfoKey = (uint64_t)dlsym(v1, "kCVImageBufferContentLightLevelInfoKey");
    if (!gIIO_kCVImageBufferContentLightLevelInfoKey)
      puts("❌  failed to load 'kCVImageBufferContentLightLevelInfoKey' ");
    gIIO_kCVImageBufferGammaLevelKey = (uint64_t)dlsym(v1, "kCVImageBufferGammaLevelKey");
    if (!gIIO_kCVImageBufferGammaLevelKey)
      puts("❌  failed to load 'kCVImageBufferGammaLevelKey' ");
    gIIO_kCVImageBufferMasteringDisplayColorVolumeKey = (uint64_t)dlsym(v1, "kCVImageBufferMasteringDisplayColorVolumeKey");
    if (!gIIO_kCVImageBufferMasteringDisplayColorVolumeKey)
      puts("❌  failed to load 'kCVImageBufferMasteringDisplayColorVolumeKey' ");
    gIIO_kCVImageBufferTransferFunctionKey = (uint64_t)dlsym(v1, "kCVImageBufferTransferFunctionKey");
    if (!gIIO_kCVImageBufferTransferFunctionKey)
      puts("❌  failed to load 'kCVImageBufferTransferFunctionKey' ");
    gIIO_kCVImageBufferTransferFunction_UseGamma = (uint64_t)dlsym(v1, "kCVImageBufferTransferFunction_UseGamma");
    if (!gIIO_kCVImageBufferTransferFunction_UseGamma)
      puts("❌  failed to load 'kCVImageBufferTransferFunction_UseGamma' ");
    gIIO_kCVPixelFormatPlanes = (uint64_t)dlsym(v1, "kCVPixelFormatPlanes");
    if (!gIIO_kCVPixelFormatPlanes)
      puts("❌  failed to load 'kCVPixelFormatPlanes' ");
    gIIO_kCVPixelFormatBitsPerComponent = (uint64_t)dlsym(v1, "kCVPixelFormatBitsPerComponent");
    if (!gIIO_kCVPixelFormatBitsPerComponent)
      puts("❌  failed to load 'kCVPixelFormatBitsPerComponent' ");
    gIIO_kCVPixelFormatComponentRange = (uint64_t)dlsym(v1, "kCVPixelFormatComponentRange");
    if (!gIIO_kCVPixelFormatComponentRange)
      puts("❌  failed to load 'kCVPixelFormatComponentRange' ");
    gIIO_kCVPixelFormatComponentRange_FullRange = (uint64_t)dlsym(v1, "kCVPixelFormatComponentRange_FullRange");
    if (!gIIO_kCVPixelFormatComponentRange_FullRange)
      puts("❌  failed to load 'kCVPixelFormatComponentRange_FullRange' ");
    result = (uint64_t)dlsym(v1, "kCVPixelFormatComponentRange_VideoRange");
    gIIO_kCVPixelFormatComponentRange_VideoRange = result;
    if (!result)
      result = puts("❌  failed to load 'kCVPixelFormatComponentRange_VideoRange' ");
  }
  if (!gFunc_CVPixelBufferLockBaseAddress)
    return (uint64_t)LogFault("IIOLoadCoreVideoSymbols", 217, "*** Failed to load 'CoreVideo' symbols ***\n");
  return result;
}

uint64_t png_warning(uint64_t a1, _BYTE *a2)
{
  uint64_t i;
  uint64_t (*v3)(void);
  FILE **v5;

  if (a1)
  {
    if (*a2 == 35)
    {
      for (i = 1; i != 15; ++i)
      {
        if (a2[i] == 32)
          break;
      }
    }
    else
    {
      LODWORD(i) = 0;
    }
    v3 = *(uint64_t (**)(void))(a1 + 8);
    if (v3)
      return v3();
  }
  else
  {
    LODWORD(i) = 0;
  }
  v5 = (FILE **)MEMORY[0x1E0C80C10];
  fprintf((FILE *)*MEMORY[0x1E0C80C10], "libpng warning: %s", &a2[i]);
  return fputc(10, *v5);
}

uint64_t ___ZN19AppleJPEGReadPlugin20copyImageBlockSetImpEP7InfoRecP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke()
{
  return IOPreferencesGetBoolean("ImageIO_Tint_AppleJPEG", 0, 0);
}

dispatch_queue_t ___ZN13IIOReadPlugin16cacheImmediatelyEPK14__CFDictionaryP7CGImage_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("CacheImmediatelyQueue", 0);
  IIOReadPlugin::cacheImmediately(__CFDictionary const*,CGImage *)::cacheQueue = (uint64_t)result;
  return result;
}

uint64_t XMP_Node::XMP_Node(uint64_t a1, uint64_t a2, __int128 *a3, __int128 *a4, int a5)
{
  std::string *v8;
  __int128 v9;
  __int128 v10;
  int v11;
  std::string *v12;

  *(_DWORD *)(a1 + 8) = a5;
  *(_QWORD *)a1 = &off_1E1BB2CB8;
  v8 = (std::string *)(a1 + 16);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 16), *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v9 = *a3;
    *(_QWORD *)(a1 + 32) = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 40), *(const std::string::value_type **)a4, *((_QWORD *)a4 + 1));
  }
  else
  {
    v10 = *a4;
    *(_QWORD *)(a1 + 56) = *((_QWORD *)a4 + 2);
    *(_OWORD *)(a1 + 40) = v10;
  }
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 64) = a2;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  if (std::string::find(v8, 58, 0) != -1)
    return a1;
  v11 = *(char *)(a1 + 39);
  if ((v11 & 0x80000000) == 0)
  {
    v12 = v8;
    if (v11 != 2)
      goto LABEL_14;
LABEL_13:
    if (LOWORD(v12->__r_.__value_.__l.__data_) == 23899)
      return a1;
    goto LABEL_14;
  }
  if (*(_QWORD *)(a1 + 24) == 2)
  {
    v12 = (std::string *)v8->__r_.__value_.__r.__words[0];
    goto LABEL_13;
  }
LABEL_14:
  if ((*(_DWORD *)(a1 + 8) & 0x80000000) == 0 && *(_QWORD *)(a1 + 64))
    __assert_rtn("XMP_Node", "XMPCore_Impl.hpp", 359, "(name.find(':') != XMP_VarString::npos) || (name == \"[]\") || (options & ((XMP_OptionBits)0x80000000UL)) || (parent == 0)");
  return a1;
}

void sub_187EC0938(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t GlobalGIFInfo::lastImageDescOffset(GlobalGIFInfo *this)
{
  return *((_QWORD *)this + 24);
}

uint64_t GlobalGIFInfo::lastFrameCount(GlobalGIFInfo *this)
{
  return *((unsigned int *)this + 50);
}

uint64_t RDF_Parser::AddQualifierNode(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  int v7;
  _BOOL4 v8;
  _QWORD *v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t *v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  int v30;
  unint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  _QWORD *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  uint64_t v52;

  v7 = *(char *)(a3 + 23);
  if (v7 < 0)
  {
    if (*(_QWORD *)(a3 + 8) == 8)
    {
      v9 = *(_QWORD **)a3;
      v8 = **(_QWORD **)a3 == 0x676E616C3A6C6D78;
      goto LABEL_6;
    }
  }
  else if (v7 == 8)
  {
    v8 = *(_QWORD *)a3 == 0x676E616C3A6C6D78;
    v9 = (_QWORD *)a3;
LABEL_6:
    v10 = *v9 == 0x657079743A666472;
    goto LABEL_8;
  }
  v8 = 0;
  v10 = 0;
LABEL_8:
  v11 = operator new();
  XMP_Node::XMP_Node(v11, a2, (__int128 *)a3, a4, 32);
  v52 = v11;
  if (v8 || v10)
  {
    if (v8)
    {
      v12 = *(uint64_t **)(a2 + 96);
      if (v12 == *(uint64_t **)(a2 + 104))
      {
        v23 = *(_QWORD *)(a2 + 112);
        if ((unint64_t)v12 >= v23)
        {
          v33 = v23 - (_QWORD)v12;
          v34 = v33 >> 2;
          if ((unint64_t)(v33 >> 2) <= 1)
            v34 = 1;
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
            v35 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v35 = v34;
          v36 = std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a2 + 112, v35);
          v38 = &v36[v37];
          *v36 = v11;
          v24 = v36 + 1;
          v40 = *(char **)(a2 + 96);
          v39 = *(char **)(a2 + 104);
          if (v39 != v40)
          {
            do
            {
              v41 = *((_QWORD *)v39 - 1);
              v39 -= 8;
              *--v36 = v41;
            }
            while (v39 != v40);
            v39 = *(char **)(a2 + 96);
          }
          *(_QWORD *)(a2 + 96) = v36;
          *(_QWORD *)(a2 + 104) = v24;
          *(_QWORD *)(a2 + 112) = v38;
          if (v39)
            operator delete(v39);
        }
        else
        {
          *v12 = v11;
          v24 = v12 + 1;
        }
        *(_QWORD *)(a2 + 104) = v24;
      }
      else
      {
        std::vector<XMP_Node *>::insert(a2 + 96, *(char **)(a2 + 96), (char *)&v52);
      }
      v30 = *(_DWORD *)(a2 + 8) | 0x40;
    }
    else
    {
      if (!v10)
        RDF_Parser::AddQualifierNode();
      v16 = *(uint64_t **)(a2 + 96);
      if (v16 == *(uint64_t **)(a2 + 104))
      {
        v31 = *(_QWORD *)(a2 + 112);
        if ((unint64_t)v16 >= v31)
        {
          v42 = v31 - (_QWORD)v16;
          v43 = v42 >> 2;
          if ((unint64_t)(v42 >> 2) <= 1)
            v43 = 1;
          if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
            v44 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v44 = v43;
          v45 = std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a2 + 112, v44);
          v47 = &v45[v46];
          *v45 = v11;
          v32 = v45 + 1;
          v49 = *(char **)(a2 + 96);
          v48 = *(char **)(a2 + 104);
          if (v48 != v49)
          {
            do
            {
              v50 = *((_QWORD *)v48 - 1);
              v48 -= 8;
              *--v45 = v50;
            }
            while (v48 != v49);
            v48 = *(char **)(a2 + 96);
          }
          *(_QWORD *)(a2 + 96) = v45;
          *(_QWORD *)(a2 + 104) = v32;
          *(_QWORD *)(a2 + 112) = v47;
          if (v48)
            operator delete(v48);
        }
        else
        {
          *v16 = v11;
          v32 = v16 + 1;
        }
        *(_QWORD *)(a2 + 104) = v32;
      }
      else
      {
        std::vector<XMP_Node *>::insert(a2 + 96, (char *)&v16[((unint64_t)*(unsigned int *)(a2 + 8) >> 6) & 1], (char *)&v52);
      }
      v30 = *(_DWORD *)(a2 + 8) | 0x80;
    }
    *(_DWORD *)(a2 + 8) = v30;
  }
  else
  {
    v13 = *(_QWORD *)(a2 + 112);
    v14 = *(uint64_t **)(a2 + 104);
    if ((unint64_t)v14 >= v13)
    {
      v17 = *(_QWORD *)(a2 + 96);
      v18 = ((uint64_t)v14 - v17) >> 3;
      if ((unint64_t)(v18 + 1) >> 61)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v19 = v13 - v17;
      v20 = v19 >> 2;
      if (v19 >> 2 <= (unint64_t)(v18 + 1))
        v20 = v18 + 1;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v21 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v21 = v20;
      if (v21)
        v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a2 + 112, v21);
      else
        v22 = 0;
      v25 = (uint64_t *)&v22[8 * v18];
      v26 = &v22[8 * v21];
      *v25 = v11;
      v15 = v25 + 1;
      v28 = *(char **)(a2 + 96);
      v27 = *(char **)(a2 + 104);
      if (v27 != v28)
      {
        do
        {
          v29 = *((_QWORD *)v27 - 1);
          v27 -= 8;
          *--v25 = v29;
        }
        while (v27 != v28);
        v27 = *(char **)(a2 + 96);
      }
      *(_QWORD *)(a2 + 96) = v25;
      *(_QWORD *)(a2 + 104) = v15;
      *(_QWORD *)(a2 + 112) = v26;
      if (v27)
        operator delete(v27);
    }
    else
    {
      *v14 = v11;
      v15 = v14 + 1;
    }
    *(_QWORD *)(a2 + 104) = v15;
    v30 = *(_DWORD *)(a2 + 8);
  }
  *(_DWORD *)(a2 + 8) = v30 | 0x10;
  return v52;
}

void sub_187EC0CD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

uint64_t RDF_Parser::AddQualifierNode(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3)
{
  uint64_t v3;
  _QWORD v5[3];

  v3 = *((unsigned __int8 *)a3 + 39);
  if ((v3 & 0x80u) != 0)
    v3 = *((_QWORD *)a3 + 3);
  if (v3)
    return RDF_Parser::AddQualifierNode((uint64_t)this, (uint64_t)a2, (uint64_t)a3 + 40, (__int128 *)a3 + 4);
  v5[0] = 202;
  v5[1] = "XML namespace required for all elements and attributes";
  v5[2] = 0;
  GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)v5, 0);
  return 0;
}

void GifSetApplier(const void *a1, IIODictionary *a2)
{
  int v4;
  const __CFString *v5;
  const __CFString *v6;
  char __str[16];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v9 = 0u;
  v10 = 0u;
  *(_OWORD *)__str = 0u;
  v8 = 0u;
  v4 = gCommentIndex++;
  snprintf(__str, 0x40uLL, "Comment %d", v4);
  v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __str, 0x600u);
  if (v5)
  {
    v6 = v5;
    IIODictionary::setObjectForKeyGroup(a2, a1, v5, CFSTR("{GIF}"));
    CFRelease(v6);
  }
}

char *CodePoint_from_UTF8(char *result, unint64_t a2, unsigned int *a3, unint64_t *a4)
{
  unint64_t v4;

  if (!a2)
  {
    v4 = 0;
    goto LABEL_5;
  }
  if ((*result & 0x80000000) == 0)
  {
    *a3 = *result;
    v4 = 1;
LABEL_5:
    *a4 = v4;
    return result;
  }
  return CodePoint_from_UTF8_Multi(result, a2, a3, a4);
}

unsigned __int8 *NormalizeLangValue(unsigned __int8 *result)
{
  int v1;
  uint64_t v2;
  _BOOL8 v3;
  uint64_t i;
  uint64_t v5;
  int v6;
  int v7;
  unsigned __int8 *v8;
  int v9;
  unsigned __int8 *v10;
  int v11;
  int v12;

  if ((char)result[23] < 0)
    result = *(unsigned __int8 **)result;
  while (1)
  {
    v1 = *result;
    if (!*result || v1 == 45)
      break;
    if ((v1 - 65) <= 0x19)
      *result = v1 + 32;
    ++result;
  }
  v2 = 0;
  v3 = v1 == 45;
  for (i = v3; ; ++i)
  {
    v5 = v3 + v2;
    v6 = result[v3 + v2];
    if (!result[v3 + v2] || v6 == 45)
      break;
    if ((v6 - 65) <= 0x19)
      result[v5] = v6 + 32;
    ++v2;
  }
  if (v2 == 2)
  {
    v7 = result[v3];
    if ((v7 - 97) <= 0x19)
      result[v3] = v7 - 32;
    v8 = &result[v3];
    v9 = v8[1];
    if ((v9 - 97) <= 0x19)
      v8[1] = v9 - 32;
  }
  if (result[v5] == 45)
    ++i;
  v10 = &result[i];
  while (1)
  {
    v11 = *v10;
    if (!*v10)
      break;
    do
    {
      if (v11 == 45)
        break;
      if ((v11 - 65) <= 0x19)
        *v10 = v11 + 32;
      v12 = *++v10;
      v11 = v12;
    }
    while (v12);
    if (v11 == 45)
      ++v10;
  }
  return result;
}

std::string *NormalizeLangArray(std::string *result)
{
  _QWORD *data;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  uint64_t *v10;
  int v11;
  uint64_t *v12;
  int v13;
  uint64_t v15;
  _QWORD *exception;

  if ((result->__r_.__value_.__s.__data_[9] & 0x10) == 0)
    NormalizeLangArray();
  data = result[3].__r_.__value_.__l.__data_;
  v2 = result[3].__r_.__value_.__l.__size_ - (_QWORD)data;
  if (v2)
  {
    v3 = 0;
    v4 = v2 >> 3;
    if ((unint64_t)(v2 >> 3) <= 1)
      v4 = 1;
    do
    {
      v5 = data[v3];
      v6 = *(uint64_t **)(v5 + 96);
      if (v6 == *(uint64_t **)(v5 + 104))
        goto LABEL_29;
      v7 = *v6;
      v8 = (_QWORD *)(v7 + 16);
      v9 = *(char *)(v7 + 39);
      if (v9 < 0)
      {
        if (*(_QWORD *)(v7 + 24) != 8)
          goto LABEL_29;
        v8 = (_QWORD *)*v8;
      }
      else if (v9 != 8)
      {
        goto LABEL_29;
      }
      if (*v8 != 0x676E616C3A6C6D78)
      {
LABEL_29:
        exception = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)exception = 203;
        exception[1] = "AltText array items must have an xml:lang qualifier";
        *((_BYTE *)exception + 16) = 0;
      }
      v10 = (uint64_t *)(v7 + 40);
      v11 = *(char *)(v7 + 63);
      if (v11 < 0)
      {
        if (*(_QWORD *)(v7 + 48) != 9)
          goto LABEL_21;
        v10 = (uint64_t *)*v10;
      }
      else if (v11 != 9)
      {
        goto LABEL_21;
      }
      v12 = (uint64_t *)*v10;
      v13 = *((unsigned __int8 *)v10 + 8);
      if (v12 == (uint64_t *)0x6C75616665642D78 && v13 == 116)
      {
        if (v3)
        {
          v15 = *data;
          *data = v5;
          *(_QWORD *)(result[3].__r_.__value_.__r.__words[0] + 8 * v3) = v15;
        }
        if (v2 == 16)
          return std::string::operator=((std::string *)(*(_QWORD *)(result[3].__r_.__value_.__r.__words[0] + 8) + 40), (const std::string *)(*(_QWORD *)result[3].__r_.__value_.__l.__data_ + 40));
        return result;
      }
LABEL_21:
      ++v3;
    }
    while (v4 != v3);
  }
  return result;
}

XMP_Node *FindQualifierNode(uint64_t a1, char *__s, int a3, char **a4)
{
  char **v8;
  char *v9;
  uint64_t v10;
  uint64_t i;
  XMP_Node *v12;
  _QWORD *v13;
  size_t v14;
  XMP_Node *v15;
  int v16;
  int v17;
  int v18;
  BOOL v19;
  int v20;
  char *v21;
  char *v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  XMP_Node **v33;
  char *v34;
  char *v35;
  char *v36;
  XMP_Node *v37;
  _BOOL4 v38;
  XMP_Node *v41;

  v41 = 0;
  if (*__s == 63)
    FindQualifierNode();
  v9 = *(char **)(a1 + 96);
  v8 = (char **)(a1 + 96);
  v10 = *(_QWORD *)(a1 + 104) - (_QWORD)v9;
  if (v10)
  {
    for (i = v10 >> 3; i; --i)
    {
      v12 = *(XMP_Node **)v9;
      if (*(_QWORD *)(*(_QWORD *)v9 + 64) != a1)
        FindQualifierNode();
      v13 = (_QWORD *)((char *)v12 + 16);
      v14 = strlen(__s);
      if (*((char *)v12 + 39) < 0)
      {
        if (v14 != *((_QWORD *)v12 + 3))
          goto LABEL_13;
        if (v14 == -1)
LABEL_73:
          std::string::__throw_out_of_range[abi:ne180100]();
        v13 = (_QWORD *)*v13;
      }
      else
      {
        if (v14 != *((unsigned __int8 *)v12 + 39))
          goto LABEL_13;
        if (v14 == -1)
          goto LABEL_73;
      }
      if (!memcmp(v13, __s, v14))
      {
        v41 = v12;
        if (a4)
        {
          *a4 = v9;
          goto LABEL_59;
        }
LABEL_64:
        v38 = v12 == 0;
LABEL_65:
        if (v38 && a3 != 0)
          FindQualifierNode();
        return v12;
      }
LABEL_13:
      v9 += 8;
    }
  }
  if (a3)
  {
    v15 = (XMP_Node *)operator new();
    XMP_Node::XMP_Node(v15, (XMP_Node *)a1, __s, 32800);
    v41 = v15;
    v16 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v16 | 0x10;
    v17 = strcmp(__s, "xml:lang");
    v18 = strcmp(__s, "rdf:type");
    if (v17)
      v19 = v18 == 0;
    else
      v19 = 1;
    v20 = !v19;
    if (v17)
    {
      if (v18)
      {
        v21 = *(char **)(a1 + 96);
        v22 = *(char **)(a1 + 104);
        if (v21 == v22)
          v23 = 1;
        else
          v23 = v20;
        if (v23 != 1)
        {
LABEL_49:
          v32 = std::vector<XMP_Node *>::insert((uint64_t)v8, v21, (char *)&v41);
          if (a4)
          {
            *a4 = v32;
            goto LABEL_59;
          }
          goto LABEL_63;
        }
LABEL_38:
        v25 = *(_QWORD *)(a1 + 112);
        if ((unint64_t)v22 >= v25)
        {
          v27 = (v22 - v21) >> 3;
          v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 61)
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          v29 = v25 - (_QWORD)v21;
          if (v29 >> 2 > v28)
            v28 = v29 >> 2;
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8)
            v30 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v30 = v28;
          if (v30)
            v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 112, v30);
          else
            v31 = 0;
          v33 = (XMP_Node **)&v31[8 * v27];
          v34 = &v31[8 * v30];
          *v33 = v15;
          v26 = v33 + 1;
          v36 = *(char **)(a1 + 96);
          v35 = *(char **)(a1 + 104);
          if (v35 != v36)
          {
            do
            {
              v37 = (XMP_Node *)*((_QWORD *)v35 - 1);
              v35 -= 8;
              *--v33 = v37;
            }
            while (v35 != v36);
            v35 = *v8;
          }
          *(_QWORD *)(a1 + 96) = v33;
          *(_QWORD *)(a1 + 104) = v26;
          *(_QWORD *)(a1 + 112) = v34;
          if (v35)
            operator delete(v35);
        }
        else
        {
          *(_QWORD *)v22 = v15;
          v26 = v22 + 8;
        }
        *(_QWORD *)(a1 + 104) = v26;
        if (a4)
        {
          *a4 = (char *)(v26 - 1);
          goto LABEL_59;
        }
LABEL_63:
        v12 = v41;
        goto LABEL_64;
      }
      v24 = v16 | 0x90;
      *(_DWORD *)(a1 + 8) = v16 | 0x90;
      v21 = *(char **)(a1 + 96);
      v22 = *(char **)(a1 + 104);
      if (v21 == v22)
        LOBYTE(v20) = 1;
      if ((v20 & 1) != 0)
        goto LABEL_38;
    }
    else
    {
      v24 = v16 | 0x50;
      *(_DWORD *)(a1 + 8) = v16 | 0x50;
      v21 = *(char **)(a1 + 96);
      v22 = *(char **)(a1 + 104);
      if (v21 == v22)
        LOBYTE(v20) = 1;
      if ((v20 & 1) != 0)
        goto LABEL_38;
      if (v18)
        goto LABEL_49;
    }
    v21 += 8 * ((v24 >> 6) & 1);
    goto LABEL_49;
  }
LABEL_59:
  v12 = v41;
  v38 = v41 == 0;
  if (!a4 || !v41)
    goto LABEL_65;
  if (v41 != *(XMP_Node **)*a4)
    FindQualifierNode();
  return v12;
}

void sub_187EC13CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

std::string *DetectAltText(std::string *result)
{
  int v1;
  std::string::size_type size;
  std::string::pointer data;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v1 = result->__r_.__value_.__r.__words[1];
  if ((v1 & 0x800) == 0)
    DetectAltText();
  data = result[3].__r_.__value_.__l.__data_;
  size = result[3].__r_.__value_.__l.__size_;
  v4 = (uint64_t)(size - (_QWORD)data) >> 3;
  v5 = 0;
  if ((std::string::pointer)size != data)
  {
    if (v4 <= 1)
      v6 = 1;
    else
      v6 = (uint64_t)(size - (_QWORD)data) >> 3;
    while ((*(_DWORD *)(*(_QWORD *)&data[8 * v5] + 8) & 0x1F40) == 0x40)
    {
      if (v6 == ++v5)
      {
        v5 = v6;
        break;
      }
    }
  }
  if ((std::string::pointer)size != data && v5 == v4)
  {
    LODWORD(result->__r_.__value_.__r.__words[1]) = v1 | 0x1000;
    return NormalizeLangArray(result);
  }
  return result;
}

void ReadPhotoshopImageResource(uint64_t a1, uint64_t a2, unint64_t a3)
{
  const __CFString *v5;
  unint64_t v6;
  const __CFString *v7;
  const char *v8;
  unint64_t v9;
  const __CFString *v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  unsigned int v14;
  BOOL v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int64_t v19;
  CGPoint *v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t v25;
  CGPoint *v26;
  CGFloat v27;
  CGFloat v28;
  double v29;
  CGFloat v30;
  __CFDictionary *v31;
  CFStringRef v32;
  CFStringRef v33;
  __CFString *Mutable;
  uint64_t i;
  const void *v36;
  const __CFDictionary *v37;
  const void *Value;
  CGImageMetadataTagRef v39;
  CGImageMetadataTagRef v40;
  int v41;
  CGPoint *v42;
  unsigned __int8 *v43;
  char v44;
  uint64_t v45;
  CGPath *path;
  int64_t v47;
  size_t v48;
  const __CFAllocator *allocator;
  CFStringRef v51;
  const __CFDictionary *theDict;
  unint64_t v53;
  unint64_t v54;
  CGImageMetadata *cf;
  unint64_t v56;
  char __dst[16];
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (a3 >= 0xD)
  {
    v5 = 0;
    v6 = 0;
    v54 = a3 - 7;
    cf = 0;
    theDict = 0;
    v53 = a3 - 4;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v7 = CFSTR("%02X");
    while (1)
    {
      if (*(_DWORD *)(a2 + v6) != 1296646712)
        goto LABEL_64;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      *(_OWORD *)__dst = 0u;
      v58 = 0u;
      v8 = (const char *)(a2 + v6 + 6);
      v9 = *(unsigned __int8 *)v8;
      if (v54 - v6 < v9)
        break;
      v10 = v7;
      v11 = *(unsigned __int16 *)(v6 + a2 + 4);
      strncpy(__dst, v8 + 1, *(unsigned __int8 *)v8);
      __dst[v9] = 0;
      v12 = ((_WORD)v9 + 2) & 0x1FE;
      v13 = v12 + v6 + 6;
      if (v13 + 3 > a3)
      {
        if (v5)
          CFRelease(v5);
        v41 = 261;
        v5 = (const __CFString *)cf;
        if (!cf)
          goto LABEL_72;
        goto LABEL_71;
      }
      if (v13 > v53 || ((v14 = *(_DWORD *)(a2 + v13), v13 += 4, a3 >= v13) ? (v15 = v14 == 0) : (v15 = 1), v15))
      {
        v7 = v10;
      }
      else
      {
        v51 = v5;
        v16 = bswap32(v14);
        if (a3 - v13 < v16)
        {
          LogError("ReadPhotoshopImageResource", 284, "*** ERROR: Corrupt 8BIM data. Reported 8BIM length (%zu bytes) exceeds actual length (%zu bytes).\n", v16, a3 - v13);
          v5 = v51;
          v37 = theDict;
          goto LABEL_78;
        }
        v17 = __rev16(v11);
        if (v17 == 1028)
        {
          v7 = v10;
          if (cf)
            CFRelease(cf);
          cf = CreateMetadataFromIPTCDatabuffer((_BYTE *)(a2 + v13), v16);
        }
        else
        {
          v7 = v10;
          if (v17 - 2000 > 0x3E6 || v16 % 0x1A)
          {
            if (v17 == 2999)
            {
              if (v51)
                CFRelease(v51);
              if (v16 <= *(unsigned __int8 *)(a2 + v13))
              {
                LogError("ReadPhotoshopImageResource", 310, "*** ERROR: Corrupt Photoshop Image Resources Field (id=%d), Pascal string length exceeds size of field", 2999);
                v5 = 0;
                v37 = theDict;
                goto LABEL_78;
              }
              v51 = CFStringCreateWithPascalString(allocator, (ConstStr255Param)(a2 + v13), 0);
            }
            else if (v17 == 1061 && v14 == 0x10000000)
            {
              Mutable = CFStringCreateMutable(allocator, 32);
              for (i = 0; i != 16; ++i)
                CFStringAppendFormat(Mutable, 0, v10, *(unsigned __int8 *)(a2 + v13 + i));
              v36 = *(const void **)(a1 + 64);
              if (v36)
                CFRelease(v36);
              *(_QWORD *)(a1 + 64) = Mutable;
            }
          }
          else
          {
            v45 = 0;
            path = CGPathCreateMutable();
            v18 = 0;
            v19 = 0;
            v44 = 0;
            v48 = 0;
            v20 = 0;
            v21 = a2 + v6 + v12;
            while (2)
            {
              v22 = v18 + 13;
              while (1)
              {
                v23 = __rev16(*(unsigned __int16 *)(v21 + v22 - 3));
                v56 = 2;
                if (v23 > 5)
                  break;
                if (((1 << v23) & 0x36) == 0)
                {
                  if (v23)
                  {
                    if (v20)
                    {
                      add_points_to_path(path, v20, 3 * v45, v44 & 1);
                      free(v20);
                    }
                    v45 = __rev16(*(unsigned __int16 *)(v21 + v22 - 1));
                    v48 = v45 + 2 * v45;
                    v20 = (CGPoint *)malloc_type_calloc(v48, 0x10uLL, 0x1000040451B5BE8uLL);
                    v44 = 0;
                    v19 = 0;
                  }
                  else
                  {
                    if (v20)
                    {
                      add_points_to_path(path, v20, 3 * v45, v44 & 1);
                      free(v20);
                    }
                    v25 = __rev16(*(unsigned __int16 *)(v21 + v22 - 1));
                    if (!(_DWORD)v25)
                      goto LABEL_41;
                    v45 = v25;
                    v48 = 3 * v25;
                    v20 = (CGPoint *)malloc_type_calloc(3 * v25, 0x10uLL, 0x1000040451B5BE8uLL);
                    v19 = 0;
                    v44 = 1;
                  }
                  break;
                }
                if (v20)
                {
                  v47 = v19;
                  if (v19 <= (uint64_t)(v48 - 3))
                  {
                    v43 = (unsigned __int8 *)(v21 + v22 - 3);
                    v26 = &v20[v19];
                    v26->x = read_point(v43, &v56);
                    v26->y = v27;
                    v42 = &v20[v47];
                    v26[1].x = read_point(v43, &v56);
                    v26[1].y = v28;
                    v7 = v10;
                    v29 = read_point(v43, &v56);
                    v19 = v47 + 3;
                    v42[2].x = v29;
                    v42[2].y = v30;
                  }
                  else
                  {
                    LogError("createPathWithData", 159, "*** ERROR: corrupt 8BIM data");
                    v19 = v47;
                  }
                  break;
                }
                v24 = v22 + 13;
                v22 += 26;
                if (v24 >= v16)
                  goto LABEL_41;
              }
              v18 = v22 + 13;
              if (v22 + 13 < v16)
                continue;
              break;
            }
            if (v20)
            {
              add_points_to_path(path, v20, 3 * v45, v44 & 1);
              free(v20);
            }
LABEL_41:
            v31 = theDict;
            if (!theDict)
              v31 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            if (path)
            {
              if (v31)
              {
                v32 = CFStringCreateWithCString(allocator, __dst, 0);
                if (v32)
                {
                  v33 = v32;
                  CFDictionarySetValue(v31, v32, path);
                  CFRelease(v33);
                }
              }
            }
            theDict = v31;
            CGPathRelease(path);
          }
        }
        v13 += ((_DWORD)v16 + 1) & 0xFFFFFFFE;
        v5 = v51;
      }
      v6 = v13;
      if (v13 + 12 >= a3)
        goto LABEL_64;
    }
    if (cf)
      CFRelease(cf);
    v41 = 247;
    if (!v5)
      goto LABEL_72;
LABEL_71:
    CFRelease(v5);
LABEL_72:
    LogError("ReadPhotoshopImageResource", v41, "*** ERROR: parsing 8BIM header, exceeds buffer length.\n");
    return;
  }
  theDict = 0;
  v5 = 0;
  cf = 0;
LABEL_64:
  CGImageMetadataMerge(a1, (uint64_t)cf, 0);
  v37 = theDict;
  if (theDict && v5)
  {
    Value = CFDictionaryGetValue(theDict, v5);
    v39 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/ImageIO/1.0/"), CFSTR("iio"), CFSTR("PSIRClippingPath"), kCGImageMetadataTypeString, Value);
    if (v39)
    {
      v40 = v39;
      CGImageMetadataAddTag(a1, v39);
      CFRelease(v40);
    }
    goto LABEL_79;
  }
LABEL_78:
  if (v5)
LABEL_79:
    CFRelease(v5);
  if (v37)
    CFRelease(v37);
  if (cf)
    CFRelease(cf);
}

uint64_t IIOEnableRestrictedDecoding()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  kdebug_trace();
  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = -50;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IIOEnableRestrictedDecoding_block_invoke;
  block[3] = &unk_1E1BC4D00;
  block[4] = &v3;
  if (IIOEnableRestrictedDecoding::onceToken != -1)
    dispatch_once(&IIOEnableRestrictedDecoding::onceToken, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

CFStringRef CreateIPTCTimeStringWithXMPDateTimeString(const __CFString *a1)
{
  int DateTimeStructFromXMPDateTimeString;
  CFStringRef result;
  uint64_t v3;
  BOOL v4[2];
  tm v5;

  memset(&v5, 0, sizeof(v5));
  *(_WORD *)v4 = 0;
  DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v5, &v4[1], v4);
  result = 0;
  if (DateTimeStructFromXMPDateTimeString && v4[1])
  {
    if (v4[0])
    {
      LODWORD(v3) = v5.tm_gmtoff % 3600 / 60;
      if ((int)v3 >= 0)
        v3 = v3;
      else
        v3 = (v5.tm_gmtoff % 3600 / -60);
      return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%02d%02d%02d%+03d%02d"), v5.tm_hour, v5.tm_min, v5.tm_sec, v5.tm_gmtoff / 3600, v3);
    }
    else
    {
      return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%02d%02d%02d"), v5.tm_hour, v5.tm_min, v5.tm_sec);
    }
  }
  return result;
}

CFStringRef CreateIPTCDateStringWithXMPDateTimeString(const __CFString *a1)
{
  int DateTimeStructFromXMPDateTimeString;
  CFStringRef result;
  tm v3;
  char __str[8];
  char v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  *(_QWORD *)__str = 0;
  memset(&v3, 0, sizeof(v3));
  DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v3, 0, 0);
  result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    snprintf(__str, 9uLL, "%04d%02d%02d", v3.tm_year + 1900, v3.tm_mon + 1, v3.tm_mday);
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __str, 0x600u);
  }
  return result;
}

CGImageMetadataType CGImageMetadataTagGetType(CGImageMetadataTagRef tag)
{
  uint64_t v2;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataTagGetType", 0, 0, -1, 0);
  if (tag && (v2 = *((_QWORD *)tag + 3)) != 0)
    return *(_DWORD *)(v2 + 40);
  else
    return -1;
}

uint64_t CGImageMetadataTagGetPrefix(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 24);
    if (v1)
      return *(_QWORD *)(v1 + 24);
    else
      return 0;
  }
  return result;
}

uint64_t CGImageMetadataTagGetNamespace(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 24);
    if (v1)
      return *(_QWORD *)(v1 + 16);
    else
      return 0;
  }
  return result;
}

BOOL CGImageMetadataTagAppendQualifier(CGImageMetadata *a1, uint64_t a2, const void *a3)
{
  _BOOL8 v4;
  uint64_t Source;
  uint64_t v7;
  uint64_t v9;
  CFTypeID v10;
  CFTypeID TypeID;
  CFTypeID v12;
  __CFArray *v13;
  CFTypeID v14;
  CFMutableArrayRef Mutable;
  CFStringRef v16;
  CFStringRef v17;
  char *UTF8String;
  const char *CStringPtr;
  const char *v20;
  const __CFString *v21;
  const __CFString *v22;
  const char *v23;
  CFErrorRef err[3];

  v4 = a2;
  Source = CGImageSourceGetSource(a2);
  v7 = CGImageSourceGetSource((uint64_t)a3);
  if (!v4)
    return v4;
  v9 = v7;
  v10 = CFGetTypeID((CFTypeRef)v4);
  TypeID = CGImageMetadataTagGetTypeID();
  v4 = 0;
  if (!a3 || v10 != TypeID)
    return v4;
  v12 = CFGetTypeID(a3);
  if (v12 != CGImageMetadataTagGetTypeID())
    return 0;
  if (*(_DWORD *)(Source + 40) != 1)
  {
    v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Failed to add qualifier '%@:%@' to tag '%@:%@'. Qualifiers may only be added to string tags - not arrays or structures."), *(_QWORD *)(v9 + 24), *(_QWORD *)(v9 + 32), *(_QWORD *)(Source + 24), *(_QWORD *)(Source + 32));
    if (v16)
    {
      v17 = v16;
      IIOString::IIOString((IIOString *)err, v16);
      UTF8String = (char *)IIOString::createUTF8String((IIOString *)err);
      IIOString::~IIOString((IIOString *)err);
      if (UTF8String)
      {
        LogMetadata("CGImageMetadataTagAppendQualifier", 427, UTF8String);
        free(UTF8String);
      }
      CFRelease(v17);
    }
    return 0;
  }
  v13 = *(__CFArray **)(Source + 56);
  if (!v13 || (v14 = CFGetTypeID(*(CFTypeRef *)(Source + 56)), v14 != CFArrayGetTypeID()))
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v13 = Mutable;
      *(_QWORD *)(Source + 56) = Mutable;
      goto LABEL_11;
    }
    return 0;
  }
LABEL_11:
  err[0] = 0;
  v4 = CGImageMetadataRegisterNamespaceForPrefix(a1, *(CFStringRef *)(v9 + 16), *(CFStringRef *)(v9 + 24), err);
  if (v4)
  {
    CFArrayAppendValue(v13, a3);
  }
  else
  {
    CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(v9 + 24), 0);
    v20 = CFStringGetCStringPtr(*(CFStringRef *)(v9 + 16), 0);
    LogMetadata("CGImageMetadataTagAppendQualifier", 408, "An error occurred while registering prefix '%s' for namespace '%s'\n", CStringPtr, v20);
    if (err[0])
    {
      v21 = CFErrorCopyFailureReason(err[0]);
      if (v21)
      {
        v22 = v21;
        v23 = CFStringGetCStringPtr(v21, 0);
        LogMetadata("CGImageMetadataTagAppendQualifier", 414, "Failure Reason: %s\n", v23);
        CFRelease(v22);
      }
    }
  }
  return v4;
}

void sub_187EC2014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageCreatePixelBufferAttributesForHDRTarget(int a1, void *a2, void *a3, _QWORD *a4)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();
  return IIOCreatePixelBufferAttributesForHDRType(a1, a2, a3, a4);
}

uint64_t IIOCreatePixelBufferAttributesForHDRType(int a1, void *a2, void *a3, _QWORD *a4)
{
  void *v8;
  id v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  unsigned int v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  unsigned int v22;
  uint64_t v23;
  id v24;
  void *v25;
  CGColorSpace *v26;
  __CFString *v27;
  _BOOL4 v28;
  int v29;
  void *v30;
  void *v31;
  unint64_t v32;
  CGColorSpaceRef v33;
  const __CFString *v34;
  CGColorSpace *v35;
  unsigned int v36;
  uint64_t v37;
  void *v38;
  int v39;
  id v40;
  __CFString *v41;
  void *v42;
  void *v43;
  double v44;
  double v45;
  __CFString *v46;
  int v47;
  char isKindOfClass;
  void *v49;
  void **v50;
  const __CFString *v51;
  int v52;
  CGColorSpace *v53;
  CGColorSpace *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v62;
  void *v63;
  void *v64;
  unsigned int v65;
  int v66;
  _QWORD *v67;
  void *v68;
  void *v69;
  unint64_t v70;
  unint64_t v71;
  void *v72;
  __CFString *name;
  double v74;

  v8 = (void *)MEMORY[0x18D7626F8]();
  v9 = a2;
  v10 = a3;
  +[HDRImageConverter imageConverterWithOptions:](HDRImageConverter, "imageConverterWithOptions:", v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v11, "canProcessPixelBufferWithAttributes:", v9) & 1) != 0)
  {
    v67 = a4;
    v72 = v11;
    objc_msgSend(v9, "objectForKeyedSubscript:", *(_QWORD *)gIIO_kCVPixelBufferWidthKey);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v71 = objc_msgSend(v12, "unsignedLongValue");

    objc_msgSend(v9, "objectForKeyedSubscript:", *(_QWORD *)gIIO_kCVPixelBufferHeightKey);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v70 = objc_msgSend(v13, "unsignedLongValue");

    objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("kCGTargetPixelFormat"));
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = objc_msgSend(v14, "unsignedIntValue");

    objc_msgSend(v9, "objectForKeyedSubscript:", *(_QWORD *)gIIO_kCVPixelBufferPixelFormatTypeKey);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = objc_msgSend(v16, "unsignedIntValue");

    if ((_DWORD)v15)
      v18 = v15;
    else
      v18 = v17;
    v19 = (void *)gFunc_CVPixelFormatDescriptionCreateWithPixelFormatType(0, v18);
    v68 = v19;
    objc_msgSend(v19, "objectForKeyedSubscript:", *(_QWORD *)gIIO_kCVPixelFormatContainsYCbCr);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v66 = objc_msgSend(v20, "BOOLValue");

    objc_msgSend(v9, "objectForKeyedSubscript:", *(_QWORD *)gIIO_kCVImageBufferCGColorSpaceKey);
    v21 = (void *)objc_claimAutoreleasedReturnValue();

    v69 = v8;
    if ((_DWORD)v15)
    {
      if (objc_msgSend(v11, "isPixelFormatSupported:", v15))
        v22 = v15;
      else
        v22 = 0;
      v65 = v22;
    }
    else
    {
      v65 = 0;
    }
    objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("kCGTargetYCCMatrix"));
    v24 = (id)objc_claimAutoreleasedReturnValue();
    if (v24 && (objc_msgSend(v11, "isYCCMatrixSupported:", v24) & 1) == 0)
    {

      v24 = 0;
    }
    objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("kCGTargetColorSpace"));
    name = (__CFString *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "objectForKeyedSubscript:");
    v25 = (void *)objc_claimAutoreleasedReturnValue();

    if (name)
    {
      v26 = CGColorSpaceCreateWithName(name);
      if (v26)
        goto LABEL_22;
      LogError("IIOCreatePixelBufferAttributesForHDRType", 564, "Unrecognized color space name: \"%s\"", (const char *)-[__CFString UTF8String](objc_retainAutorelease(name), "UTF8String"));
    }
    if (!v25)
    {
      v26 = 0;
      v28 = 0;
      v29 = 1;
LABEL_24:
      switch(a1)
      {
        case 1:
          if (((v29 | v25 | v28) & 1) != 0)
            v33 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D908]);
          else
            v33 = CGColorSpaceRetain(v26);
          v35 = v33;
          if (v66)
            v36 = 875704422;
          else
            v36 = 1111970369;
          if (v65)
            v37 = v65;
          else
            v37 = v36;
          if (!v66)
          {
LABEL_54:
            v38 = 0;
LABEL_55:
            v40 = v38;
            goto LABEL_56;
          }
          break;
        case 2:
          if (((v29 | v25 ^ 1) & 1) != 0)
          {
            if (((v29 | !v28) & 1) != 0)
            {
              v34 = (const __CFString *)IIODefaultHDRColorSpace((CGColorSpace *)v21);
              v35 = CGColorSpaceCreateWithName(v34);
            }
            else
            {
              v35 = CGColorSpaceRetain(v26);
              objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("kCGTargetHeadroom"));
              v42 = (void *)objc_claimAutoreleasedReturnValue();
              if (v42 && CGColorSpaceContainsFlexGTCInfo())
              {
                v43 = (void *)CGColorSpaceCopyFlexGTCInfo();
                v74 = 0.0;
                if (+[HDRImage getGainMapHeadroom:fromFlexGTCInfo:](HDRImage, "getGainMapHeadroom:fromFlexGTCInfo:", &v74, v43))
                {
                  objc_msgSend(v42, "doubleValue");
                  if (v44 < v74)
                  {
                    if ((gIIODebugFlags & 0x300000) != 0)
                    {
                      objc_msgSend(v42, "doubleValue");
                      ImageIOLog("☀️ Requested headroom (%0.1f) is less than native headroom (%0.1f), dropping FlexGTC info", v45, v74);
                    }
                    if (CGColorSpaceGetCICPInfo())
                    {
                      CGColorSpaceRelease(v35);
                      v35 = (CGColorSpace *)CGColorSpaceCreateFromCICP();
                    }
                  }
                }

              }
            }
            if ((gIIODebugFlags & 0x300000) != 0)
            {
              v46 = objc_retainAutorelease((id)CFCopyDescription(v35));
              ImageIOLog("☀️ HDR output colorspace: %s", (const char *)-[__CFString UTF8String](v46, "UTF8String"));

            }
            if (v65)
              v37 = v65;
            else
              v37 = 2019963440;
            v47 = v66;
            if (!v65)
              v47 = 1;
            if (v47 == 1)
            {
              if (v24)
              {
                v24 = v24;
                v41 = 0;
                v40 = v24;
                goto LABEL_108;
              }
              IIODefaultHDRYCCMatrix(v35);
              v40 = (id)objc_claimAutoreleasedReturnValue();
              v24 = 0;
            }
            else
            {
              v40 = 0;
            }
LABEL_56:
            v41 = 0;
LABEL_108:
            v57 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", 5);
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", v71);
            v58 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v57, "setObject:forKeyedSubscript:", v58, *(_QWORD *)gIIO_kCVPixelBufferWidthKey);

            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", v70);
            v59 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v57, "setObject:forKeyedSubscript:", v59, *(_QWORD *)gIIO_kCVPixelBufferHeightKey);

            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v37);
            v60 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v57, "setObject:forKeyedSubscript:", v60, *(_QWORD *)gIIO_kCVPixelBufferPixelFormatTypeKey);

            objc_msgSend(v57, "setObject:forKeyedSubscript:", v35, *(_QWORD *)gIIO_kCVImageBufferCGColorSpaceKey);
            objc_msgSend(v57, "setObject:forKeyedSubscript:", v40, *(_QWORD *)gIIO_kCVImageBufferYCbCrMatrixKey);
            objc_msgSend(v57, "setObject:forKeyedSubscript:", v41, CFSTR("kCGFlexRangeAlternateColorSpace"));
            *v67 = v57;

            v23 = 0;
            v19 = v68;
            goto LABEL_109;
          }
          v35 = CGColorSpaceRetain(v26);
          if (v65)
            v37 = v65;
          else
            v37 = 1380411457;
          v39 = v66;
          if (!v65)
            v39 = 0;
          if (v39 != 1)
            goto LABEL_54;
          break;
        case 3:
          objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("kCGFlexRangeOptions"));
          v30 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v30)
          {
            v35 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
            v40 = 0;
            v41 = 0;
            v37 = 1278226488;
            v32 = 2;
LABEL_107:
            v70 /= v32;
            v71 /= v32;
            goto LABEL_108;
          }
          objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("kCGFlexRangeOptions"));
          v63 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v63, "objectForKeyedSubscript:", CFSTR("kCGFlexRangeSubsample"));
          v31 = (void *)objc_claimAutoreleasedReturnValue();
          v62 = v31;
          if (v31)
          {
            if (objc_msgSend(v31, "BOOLValue"))
              v32 = 2;
            else
              v32 = 1;
          }
          else
          {
            v32 = 2;
          }
          objc_msgSend(v63, "objectForKeyedSubscript:", CFSTR("kCGFlexRangeAlternateColorSpace"));
          v64 = (void *)objc_claimAutoreleasedReturnValue();
          if (!v64 || (objc_opt_class(), isKindOfClass = objc_opt_isKindOfClass(), v49 = v64, (isKindOfClass & 1) == 0))
          {
            if ((v28 | v25) != 1)
            {
              IIODefaultHDRColorSpace((CGColorSpace *)v21);
              v51 = (const __CFString *)objc_claimAutoreleasedReturnValue();
              goto LABEL_90;
            }
            if (v21 && (LODWORD(v74) = 0, CGColorSpaceGetCICPInfo()) && LOBYTE(v74) == 12)
              v50 = (void **)MEMORY[0x1E0C9D908];
            else
              v50 = (void **)MEMORY[0x1E0C9DA10];
            v49 = *v50;
          }
          v51 = v49;
LABEL_90:
          v41 = (__CFString *)v51;
          if (v65)
            v37 = v65;
          else
            v37 = 1278226488;
          v52 = v66;
          if (!v65)
            v52 = 0;
          if (v52 == 1)
          {
            if (!v24)
            {
              v53 = CGColorSpaceCreateWithName(v51);
              if (v29)
                v54 = (CGColorSpace *)v21;
              else
                v54 = v26;
              objc_msgSend(v63, "objectForKeyedSubscript:", CFSTR("kCGFlexRangeUseAlternateColor"));
              v55 = (void *)objc_claimAutoreleasedReturnValue();
              v56 = v55;
              if (v55 && (objc_msgSend(v55, "BOOLValue") & (v53 != 0)) != 0)
                v54 = v53;
              IIODefaultHDRYCCMatrix(v54);
              v24 = (id)objc_claimAutoreleasedReturnValue();
              CGColorSpaceRelease(v53);

            }
            v24 = v24;
            v40 = v24;
          }
          else
          {
            v40 = 0;
          }

          v35 = 0;
          goto LABEL_107;
        default:
          LogError("IIOCreatePixelBufferAttributesForHDRType", 686, "Unsupported HDR type: %d", a1);
          v23 = 4294967246;
LABEL_109:

          v11 = v72;
          v8 = v69;
          goto LABEL_110;
      }
      v38 = v24;
      if (!v24)
        v38 = *(void **)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4;
      goto LABEL_55;
    }
    if ((gIIODebugFlags & 0x300000) != 0)
    {
      v27 = objc_retainAutorelease((id)CFCopyDescription(v25));
      ImageIOLog("☀️ Using provided alternate space: %s", (const char *)-[__CFString UTF8String](v27, "UTF8String"));

    }
    v26 = (CGColorSpace *)v25;
LABEL_22:
    LODWORD(v25) = CGColorSpaceUsesExtendedRange(v26);
    v28 = CGColorSpaceUsesITUR_2100TF(v26);
    v29 = 0;
    goto LABEL_24;
  }
  v23 = 4294967246;
LABEL_110:

  objc_autoreleasePoolPop(v8);
  return v23;
}

void sub_187EC297C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, _Unwind_Exception *exception_object,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  _Unwind_Resume(a1);
}

uint64_t CGImageConvertHDRPixelBufferToSDR(uint64_t a1, uint64_t a2, void *a3)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();
  return IIOConvertHDRData(a1, a2, a3);
}

uint64_t IIOConvertHDRData(uint64_t a1, uint64_t a2, void *a3)
{
  void *v6;
  id v7;
  void *v8;
  HDRImage *v9;
  HDRImage *v10;
  void *v11;
  uint64_t v12;

  v6 = (void *)MEMORY[0x18D7626F8]();
  v7 = a3;
  objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v9 = -[HDRImage initWithImageBuffer:gainMapBuffer:gainMapMetadata:imageProperties:]([HDRImage alloc], "initWithImageBuffer:gainMapBuffer:gainMapMetadata:imageProperties:", a1, 0, v8, v7);
  v10 = -[HDRImage initWithImageBuffer:]([HDRImage alloc], "initWithImageBuffer:", a2);
  +[HDRImageConverter imageConverterWithOptions:](HDRImageConverter, "imageConverterWithOptions:", v7);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v11, "convertImage:toImage:", v9, v10))
    v12 = 0;
  else
    v12 = 4294967246;

  objc_autoreleasePoolPop(v6);
  return v12;
}

void sub_187EC2C28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t CGImageApplyHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();
  return IIOApplyHDRGainMap(a1, a2, a3, a4);
}

uint64_t IIOApplyHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  void *v8;
  id v9;
  void *v10;
  HDRImage *v11;
  void *v12;
  CFTypeID v13;
  void *v14;
  void *v15;
  void *v16;
  HDRImage *v17;
  void *v18;
  void *v19;
  float v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  void *v30;
  int v31;
  id v32;
  void *v33;
  void *v34;
  int v35;
  void *v36;
  int v37;
  void *v38;
  void *v39;
  id v40;
  void *v41;
  void *v42;
  id v43;
  CGColorSpace *CopyWithFlexGTCInfo;
  CGColorSpace *v45;
  __CFString *v46;
  uint64_t v47;
  uint64_t v49;
  double v50;

  v8 = (void *)MEMORY[0x18D7626F8]();
  v9 = a4;
  objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  v11 = -[HDRImage initWithImageBuffer:gainMapBuffer:gainMapMetadata:imageProperties:]([HDRImage alloc], "initWithImageBuffer:gainMapBuffer:gainMapMetadata:imageProperties:", a1, a2, v10, v9);
  if (-[HDRImage type](v11, "type") == 6)
  {
    objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("kCGFlexRangeAlternateColorSpace"));
    v12 = (void *)objc_claimAutoreleasedReturnValue();

    if (v12)
    {
      v13 = CFGetTypeID(v12);
      if (v13 == CGColorSpaceGetTypeID())
      {
        -[HDRImage flexRangeParams](v11, "flexRangeParams");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v14, "setAlternateColorSpace:", v12);

      }
      else
      {
        LogError("IIOApplyHDRGainMap", 228, "kCGFlexRangeAlternateColorSpace option must be a CGColorSpace object");
      }
    }
    else
    {
      LogError("IIOApplyHDRGainMap", 226, "kCGFlexRangeAlternateColorSpace option must be set for FlexRange");
    }
  }
  objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("Orientation"));
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  if (v15)
  {
    objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("Orientation"));
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    -[HDRImage setGainMapOrientation:](v11, "setGainMapOrientation:", objc_msgSend(v16, "intValue"));

  }
  v17 = -[HDRImage initWithImageBuffer:]([HDRImage alloc], "initWithImageBuffer:", a3);
  v49 = a3;
  objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("kCGTargetHeadroom"));
  v18 = (void *)objc_claimAutoreleasedReturnValue();

  if (v18)
  {
    objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("kCGTargetHeadroom"));
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "floatValue");
    v21 = v20;

  }
  else
  {
    v21 = 16.0;
  }
  -[HDRImage headroom](v11, "headroom");
  v23 = v22;
  -[HDRImage headroom](v17, "headroom");
  if (v23 >= v21)
    v25 = v21;
  else
    v25 = v23;
  if (v25 >= v24)
    v26 = v24;
  else
    v26 = v25;
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    -[HDRImage headroom](v11, "headroom");
    v28 = v27;
    -[HDRImage headroom](v17, "headroom");
    ImageIOLog("☀️  gain map headroom: %0.1f requested: %0.1f capacity: %0.1f -> %0.1f\n", v28, v21, v29, v26);
  }
  -[HDRImage setHeadroom:](v17, "setHeadroom:", v26);
  +[HDRImageConverter imageConverterWithOptions:](HDRImageConverter, "imageConverterWithOptions:", v9);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = objc_msgSend(v30, "convertImage:toImage:", v11, v17);
  v32 = v9;
  v33 = v32;
  if (v32)
  {
    objc_msgSend(v32, "objectForKeyedSubscript:", CFSTR("kCGGenerateFlexGTC"));
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    v35 = objc_msgSend(v34, "BOOLValue");

    objc_msgSend(v33, "objectForKeyedSubscript:", CFSTR("kCGImageSourceGenerateImageSpecificLumaScaling"));
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    v37 = objc_msgSend(v36, "BOOLValue");

    if ((v35 | v37) == 1)
    {
      if ((gIIODebugFlags & 0x300000) != 0)
        ImageIOLog("☀️  generating FlexGTC info as requested...\n");
      -[HDRImage colorSpace](v17, "colorSpace");
      if (CGColorSpaceContainsFlexGTCInfo())
      {
        -[HDRImage colorSpace](v17, "colorSpace");
        v38 = (void *)CGColorSpaceCopyFlexGTCInfo();
        v39 = v38;
        if ((gIIODebugFlags & 0x300000) != 0)
        {
          objc_msgSend(v38, "description");
          v40 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          ImageIOLog("☀️  destination already has FlexGTC info: %s\n", (const char *)objc_msgSend(v40, "UTF8String"));

        }
        v50 = 0.0;
        if (+[HDRImage getGainMapHeadroom:fromFlexGTCInfo:](HDRImage, "getGainMapHeadroom:fromFlexGTCInfo:", &v50, v39)&& vabdd_f64(v50, v26) > 0.01)
        {
          LogError("IIOApplyHDRGainMap", 261, "FlexGTC headroom (%0.01f) doesn't match target headroom (%0.01f)", v50, v26);
        }

      }
      else
      {
        objc_msgSend(v30, "generateToneMappingCurveForImage:targetHeadroom:", v11, v26);
        v41 = (void *)objc_claimAutoreleasedReturnValue();
        v42 = v41;
        if ((gIIODebugFlags & 0x300000) != 0)
        {
          objc_msgSend(v41, "description");
          v43 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          ImageIOLog("☀️  generated FlexGTC info: %s\n", (const char *)objc_msgSend(v43, "UTF8String"));

        }
        if (v42)
        {
          -[HDRImage colorSpace](v17, "colorSpace");
          CopyWithFlexGTCInfo = (CGColorSpace *)IIO_ColorSpaceCreateCopyWithFlexGTCInfo();
          v45 = CopyWithFlexGTCInfo;
          if ((gIIODebugFlags & 0x300000) != 0)
          {
            v46 = objc_retainAutorelease((id)CFCopyDescription(CopyWithFlexGTCInfo));
            ImageIOLog("☀️  generated FlexGTC space: %s\n", (const char *)-[__CFString UTF8String](v46, "UTF8String"));

          }
          if (v45)
          {
            gFunc_CVImageBufferSetColorSpace(v49, v45);
            CGColorSpaceRelease(v45);
          }
          else
          {
            LogError("IIOApplyHDRGainMap", 274, "Failed to generate FlexGTC color space");
          }
        }
        else
        {
          LogError("IIOApplyHDRGainMap", 277, "Failed to generate FlexGTC info");
        }

      }
    }
  }
  if (v31)
    v47 = 0;
  else
    v47 = 4294967246;

  objc_autoreleasePoolPop(v8);
  return v47;
}

void sub_187EC3194(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t CGImageCreateHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();
  return IIOConvertHDRGainMap(a1, 0, a2, a3, 0, a4);
}

uint64_t IIOCreateHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return IIOConvertHDRGainMap(a1, 0, a2, a3, 0, a4);
}

uint64_t CGImageConvertHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CGImageMetadata **a5, void *a6)
{
  IIOInitDebugFlags();
  IIO_LoadCMPhotoSymbols();
  return IIOConvertHDRGainMap(a1, a2, a3, a4, a5, a6);
}

uint64_t IIOConvertHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CGImageMetadata **a5, void *a6)
{
  void *v12;
  id v13;
  void *v14;
  HDRImage *v15;
  void *v16;
  CFTypeID v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  float v23;
  double v24;
  double v25;
  double v26;
  double v27;
  void *v28;
  void *v29;
  HDRImage *v30;
  void *v31;
  CGImageMetadata *v32;
  uint64_t v33;

  v12 = (void *)MEMORY[0x18D7626F8]();
  v13 = a6;
  objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
  v14 = (void *)objc_claimAutoreleasedReturnValue();

  v15 = -[HDRImage initWithImageBuffer:gainMapBuffer:gainMapMetadata:imageProperties:]([HDRImage alloc], "initWithImageBuffer:gainMapBuffer:gainMapMetadata:imageProperties:", a1, a2, v14, v13);
  if (-[HDRImage type](v15, "type") == 6)
  {
    objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("kCGFlexRangeAlternateColorSpace"));
    v16 = (void *)objc_claimAutoreleasedReturnValue();

    if (v16)
    {
      v17 = CFGetTypeID(v16);
      if (v17 == CGColorSpaceGetTypeID())
      {
        -[HDRImage flexRangeParams](v15, "flexRangeParams");
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v18, "setAlternateColorSpace:", v16);

      }
      else
      {
        LogError("IIOConvertHDRGainMap", 317, "kCGFlexRangeAlternateColorSpace option must be a CGColorSpace object");
      }
    }
    else
    {
      LogError("IIOConvertHDRGainMap", 315, "kCGFlexRangeAlternateColorSpace option must be set for FlexRange");
    }
  }
  objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("Orientation"));
  v19 = (void *)objc_claimAutoreleasedReturnValue();

  if (v19)
  {
    objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("Orientation"));
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    -[HDRImage setGainMapOrientation:](v15, "setGainMapOrientation:", objc_msgSend(v20, "intValue"));

  }
  objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("kCGTargetHeadroom"));
  v21 = (void *)objc_claimAutoreleasedReturnValue();

  if (v21)
  {
    objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("kCGTargetHeadroom"));
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v22, "floatValue");
    v24 = v23;

  }
  else
  {
    v24 = 8.0;
  }
  -[HDRImage headroom](v15, "headroom");
  if (v25 >= v24)
    v26 = v24;
  else
    v26 = v25;
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    -[HDRImage headroom](v15, "headroom");
    ImageIOLog("☀️  gain map headroom: %0.1f requested: %0.1f -> %0.1f\n", v27, v24, v26);
  }
  objc_msgSend(v13, "objectForKeyedSubscript:", CFSTR("kCGFlexRangeOptions"));
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  if (v28 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    +[HDRImage flexRangeParametersWithHeadroom:options:](HDRImage, "flexRangeParametersWithHeadroom:options:", v28, v26);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v29 = 0;
  }
  v30 = -[HDRImage initWithImageBuffer:gainMapBuffer:flexRangeParameters:]([HDRImage alloc], "initWithImageBuffer:gainMapBuffer:flexRangeParameters:", a3, a4, v29);
  -[HDRImage setHeadroom:](v30, "setHeadroom:", v26);
  +[HDRImageConverter imageConverterWithOptions:](HDRImageConverter, "imageConverterWithOptions:", v13);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v31, "convertImage:toImage:", v15, v30)
    && (!v29
      ? (v32 = +[HDRImage createGainMapMetadataWithHeadroom:](HDRImage, "createGainMapMetadataWithHeadroom:", v26)): (v32 = (CGImageMetadata *)objc_msgSend(v29, "createFlexRangeMetadata")), v32))
  {
    v33 = 0;
    if (a5)
      *a5 = v32;
  }
  else
  {
    v33 = 4294967246;
  }

  objc_autoreleasePoolPop(v12);
  return v33;
}

void sub_187EC3654(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t CGImageCreateFlexGTCInfo(uint64_t a1, uint64_t a2, _QWORD *a3, void *a4)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();
  return IIOCreateHDRFlexGTCInfo(a1, a2, a3, a4);
}

uint64_t IIOCreateHDRFlexGTCInfo(uint64_t a1, uint64_t a2, _QWORD *a3, void *a4)
{
  void *v8;
  id v9;
  void *v10;
  HDRImage *v11;
  void *v12;
  CFTypeID v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  float v19;
  double v20;
  double v21;
  double v22;
  double v23;
  void *v24;
  void *v25;
  void *v26;
  id v27;
  uint64_t v28;

  v8 = (void *)MEMORY[0x18D7626F8]();
  v9 = a4;
  objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  v11 = -[HDRImage initWithImageBuffer:gainMapBuffer:gainMapMetadata:imageProperties:]([HDRImage alloc], "initWithImageBuffer:gainMapBuffer:gainMapMetadata:imageProperties:", a1, a2, v10, v9);
  if (-[HDRImage type](v11, "type") == 6)
  {
    objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("kCGFlexRangeAlternateColorSpace"));
    v12 = (void *)objc_claimAutoreleasedReturnValue();

    if (v12)
    {
      v13 = CFGetTypeID(v12);
      if (v13 == CGColorSpaceGetTypeID())
      {
        -[HDRImage flexRangeParams](v11, "flexRangeParams");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v14, "setAlternateColorSpace:", v12);

      }
      else
      {
        LogError("IIOCreateHDRFlexGTCInfo", 391, "kCGFlexRangeAlternateColorSpace option must be a CGColorSpace object");
      }
    }
    else
    {
      LogError("IIOCreateHDRFlexGTCInfo", 389, "kCGFlexRangeAlternateColorSpace option must be set for FlexRange");
    }
  }
  objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("Orientation"));
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  if (v15)
  {
    objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("Orientation"));
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    -[HDRImage setGainMapOrientation:](v11, "setGainMapOrientation:", objc_msgSend(v16, "intValue"));

  }
  objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("kCGTargetHeadroom"));
  v17 = (void *)objc_claimAutoreleasedReturnValue();

  if (v17)
  {
    objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("kCGTargetHeadroom"));
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v18, "floatValue");
    v20 = v19;

  }
  else
  {
    v20 = 8.0;
  }
  -[HDRImage headroom](v11, "headroom");
  if (v21 >= v20)
    v22 = v20;
  else
    v22 = v21;
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    -[HDRImage headroom](v11, "headroom");
    ImageIOLog("☀️ FlexGTC gain map headroom: %0.1f requested: %0.1f -> %0.1f\n", v23, v20, v22);
  }
  +[HDRImageConverter imageConverterWithOptions:](HDRImageConverter, "imageConverterWithOptions:", v9);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v24, "generateToneMappingCurveForImage:targetHeadroom:", v11, v22);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = v25;
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    objc_msgSend(v25, "description");
    v27 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    ImageIOLog("☀️ FlexGTC curve data: %s", (const char *)objc_msgSend(v27, "UTF8String"));

  }
  if (a3 && v26)
    *a3 = v26;
  if (v26)
    v28 = 0;
  else
    v28 = 4294967246;

  objc_autoreleasePoolPop(v8);
  return v28;
}

void sub_187EC39C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t CGImageCreateFlexRangeMetadata(uint64_t a1, uint64_t *a2)
{
  IIOInitDebugFlags();
  IIO_LoadCMPhotoSymbols();
  return IIOCreateFlexRangeMetadataFromDictionary(a1, a2);
}

uint64_t IIOCreateFlexRangeMetadataFromDictionary(uint64_t a1, uint64_t *a2)
{
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[HDRFlexRangeParameters flexRangeParametersFromDictionary:](HDRFlexRangeParameters, "flexRangeParametersFromDictionary:", a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  if (v3 && (v5 = objc_msgSend(v3, "createFlexRangeMetadata")) != 0)
  {
    v6 = 0;
    *a2 = v5;
  }
  else
  {
    v6 = 4294967246;
  }

  return v6;
}

void sub_187EC3AC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CGImageCreateFlexRangeDictionary(uint64_t a1, _QWORD *a2)
{
  IIOInitDebugFlags();
  IIO_LoadCMPhotoSymbols();
  return IIOCreateFlexRangeDictionaryFromMetadata(a1, a2);
}

uint64_t IIOCreateFlexRangeDictionaryFromMetadata(uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;

  +[HDRFlexRangeParameters flexRangeParametersFromMetadata:](HDRFlexRangeParameters, "flexRangeParametersFromMetadata:", a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  if (v3)
  {
    objc_msgSend(v3, "createFlexRangeDictionary");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = v5;
    if (v5)
    {
      v7 = 0;
      *a2 = v5;
    }
    else
    {
      v7 = 4294967246;
    }

  }
  else
  {
    v7 = 4294967246;
  }

  return v7;
}

void sub_187EC3B84(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double CGImageGetHDRGainMapHeadroom(uint64_t a1, uint64_t a2)
{
  IIOInitDebugFlags();
  IIO_LoadCMPhotoSymbols();
  return IIOHDRGainMapMetadataGetHeadroom(a1, a2);
}

double IIOHDRGainMapMetadataGetHeadroom(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  float v7;
  float v8;
  float v9;
  double v10;
  double v12;

  v4 = (void *)MEMORY[0x18D7626F8]();
  if (a1)
  {
    +[HDRFlexRangeParameters flexRangeParametersFromMetadata:](HDRFlexRangeParameters, "flexRangeParametersFromMetadata:", a1);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = v5;
    if (v5)
    {
      objc_msgSend(v5, "baseHeadroom");
      v8 = v7;
      objc_msgSend(v6, "alternateHeadroom");
      v10 = exp2(fmaxf(v8, v9));
LABEL_6:

      goto LABEL_10;
    }
    v12 = 0.0;
    if (+[HDRImage getGainMapHeadroom:fromMetadata:](HDRImage, "getGainMapHeadroom:fromMetadata:", &v12, a1))
    {
      v10 = v12;
      goto LABEL_6;
    }
  }
  v12 = 0.0;
  if (+[HDRImage getGainMapHeadroom:fromProperties:](HDRImage, "getGainMapHeadroom:fromProperties:", &v12, a2))
  {
    v10 = v12;
  }
  else
  {
    v10 = 1.0;
  }
LABEL_10:
  objc_autoreleasePoolPop(v4);
  return v10;
}

void sub_187EC3CA8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t IIOCreateHDRGainMapMetadata(CGImageMetadata **a1, double a2)
{
  void *v4;
  CGImageMetadata *v5;
  uint64_t v6;

  v4 = (void *)MEMORY[0x18D7626F8]();
  v5 = +[HDRImage createGainMapMetadataWithHeadroom:](HDRImage, "createGainMapMetadataWithHeadroom:", a2);
  if (a1)
    *a1 = v5;
  if (v5)
    v6 = 0;
  else
    v6 = 4294967246;
  objc_autoreleasePoolPop(v4);
  return v6;
}

uint64_t IIODefaultHDRColorSpace(CGColorSpace *a1)
{
  if (a1)
    CGColorSpaceGetCICPInfo();
  return *MEMORY[0x1E0C9D9C8];
}

uint64_t IIODefaultHDRYCCMatrix(CGColorSpace *a1)
{
  if (a1)
    CGColorSpaceGetCICPInfo();
  return *(_QWORD *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4;
}

void sub_187EC40E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_187EC4344(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187EC45C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187EC4800(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_187EC4E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_187EC5064(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_187EC50E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC52E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_187EC55F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_187EC59BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187EC5B54(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC5C84(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC5EC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_187EC60F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187EC6190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)HDRImage;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void sub_187EC6544(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_187EC66F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC682C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC69B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC6C70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187EC6D84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187EC7134(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187EC7AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a65;
  char a69;
  void *v69;
  uint64_t v70;

  _Block_object_dispose(&a39, 8);
  _Block_object_dispose(&a50, 8);
  _Block_object_dispose(&a54, 8);
  _Block_object_dispose(&a65, 8);
  _Block_object_dispose(&a69, 8);
  _Block_object_dispose(&STACK[0x240], 8);
  _Block_object_dispose(&STACK[0x260], 8);
  _Block_object_dispose(&STACK[0x2B8], 8);
  _Block_object_dispose(&STACK[0x2D8], 8);
  _Block_object_dispose((const void *)(v70 - 216), 8);
  _Block_object_dispose((const void *)(v70 - 184), 8);
  _Block_object_dispose((const void *)(v70 - 96), 8);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

__n128 __Block_byref_object_copy__55(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v3;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

__n128 __Block_byref_object_copy__58(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void sub_187EC7D70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC7ED0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC8054(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC8454(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC8AAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC8C20(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC9330(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC944C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC94C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC9534(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EC9918(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187EC99AC()
{
  JUMPOUT(0x187EC99A0);
}

id HDRPixelTransformInDescription(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  const __CFString *v5;
  void *v6;
  void *v7;
  void *v8;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("[%g,%g,%g,%g,%g,%g]"), COERCE_FLOAT(*(_QWORD *)(a1 + 96)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(a1 + 96))), COERCE_FLOAT(*(_QWORD *)(a1 + 104)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(a1 + 104))), COERCE_FLOAT(*(_QWORD *)(a1 + 112)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(a1 + 112))));
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = (void *)v2;
  v4 = (void *)MEMORY[0x1E0CB3940];
  v5 = CFSTR("RGB");
  switch(*(_DWORD *)a1)
  {
    case 0:
      v5 = CFSTR("N/A");
      goto LABEL_6;
    case 1:
      goto LABEL_6;
    case 2:
      YCCMatrixToString(*(simd_float3x3 *)(a1 + 48));
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      HDRPixelRangeToString(*(__n128 *)(a1 + 16), *(__n128 *)(a1 + 32));
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "stringWithFormat:", CFSTR("%@ %@ %@ affine: %@"), CFSTR("YCC"), v6, v7, v3);
      v8 = (void *)objc_claimAutoreleasedReturnValue();

      goto LABEL_7;
    case 3:
      v5 = CFSTR("Y");
      goto LABEL_6;
    default:
      v5 = CFSTR("???");
LABEL_6:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ affine: %@"), v5, v2);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_7:

      return v8;
  }
}

void sub_187EC9B00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

__CFString *HDRColorTRCToString(uint64_t a1)
{
  __CFString *v1;
  double v2;
  double v3;
  double v5;
  double v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v1 = CFSTR("none");
  switch(*(_DWORD *)a1)
  {
    case 0:
      return v1;
    case 1:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Y = X^%g"), *(float *)(a1 + 44), v7, v8, v9, v10, v11, v12, v13);
      goto LABEL_22;
    case 2:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Y = (%g*X+%g)^%g [X >= %g], Y = 0 [X < %g]"), *(float *)(a1 + 16), *(float *)(a1 + 20), *(float *)(a1 + 44), (float)((float)-*(float *)(a1 + 20) / *(float *)(a1 + 16)), (float)((float)-*(float *)(a1 + 20) / *(float *)(a1 + 16)), v11, v12, v13);
      goto LABEL_22;
    case 3:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Y = (%g*X+%g)^%g + %g [X >= %g], Y = %g [X < %g]"), *(float *)(a1 + 16), *(float *)(a1 + 20), *(float *)(a1 + 44), *(float *)(a1 + 24), (float)((float)-*(float *)(a1 + 20) / *(float *)(a1 + 16)), *(float *)(a1 + 24), (float)((float)-*(float *)(a1 + 20) / *(float *)(a1 + 16)), v13);
      goto LABEL_22;
    case 4:
      v2 = *(float *)(a1 + 44);
      v3 = *(float *)(a1 + 28);
      if (fabs(v2 + -2.4) < 0.0000999999975
        && fabs(v3 + -0.04045) < 0.0000999999975
        && fabs(*(float *)(a1 + 24) + -0.0773993808) < 0.0000999999975)
      {
        return CFSTR("sRGB -> Linear");
      }
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Y = (%g*X+%g)^%g [X >= %g], Y = %g*X [X < %g]"), *(float *)(a1 + 16), *(float *)(a1 + 20), *(_QWORD *)&v2, *(_QWORD *)&v3, *(float *)(a1 + 24), *(_QWORD *)&v3, v12, v13);
      goto LABEL_22;
    case 5:
      v5 = *(float *)(a1 + 44);
      v6 = *(float *)(a1 + 28);
      if (fabs(v5 + -0.416666667) < 0.0000999999975
        && fabs(v6 + -0.00313080495) < 0.0000999999975
        && fabs(*(float *)(a1 + 24) + -12.92) < 0.0000999999975)
      {
        return CFSTR("Linear -> sRGB");
      }
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Y = (%g*X+%g)^%g + %g [X >= %g], Y = %g*X + %g [X < %g]"), *(float *)(a1 + 16), *(float *)(a1 + 20), *(_QWORD *)&v5, *(float *)(a1 + 32), *(_QWORD *)&v6, *(float *)(a1 + 24), *(float *)(a1 + 36), *(_QWORD *)&v6);
LABEL_22:
      v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
      return v1;
    case 6:
      return CFSTR("LUT");
    case 7:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("PQ EOTF (scale=%g)"), *(float *)(a1 + 36), v7, v8, v9, v10, v11, v12, v13);
      goto LABEL_22;
    case 8:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("PQ EOTF Inv (scale=%g)"), *(float *)(a1 + 36), v7, v8, v9, v10, v11, v12, v13);
      goto LABEL_22;
    case 9:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("HLG EOTF (scale=%g, black=%g)"), (float)(*(float *)(a1 + 28) * 12.0), *(float *)(a1 + 36), v8, v9, v10, v11, v12, v13);
      goto LABEL_22;
    case 0xA:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("HLG EOTF Inv (scale=%g, black=%g)"), *(float *)(a1 + 32), *(float *)(a1 + 36), v8, v9, v10, v11, v12, v13);
      goto LABEL_22;
    case 0xB:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("HLG EOTF Inv (scale=%g, black=%g) x OOTF (scale=%g, gamma=%g)"), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), (float)(*(float *)(a1 + 44) + 1.0), v10, v11, v12, v13);
      goto LABEL_22;
    default:
      return CFSTR("????");
  }
}

__CFString *HDRColorMatrixToString(uint64_t a1)
{
  double v2;
  double v3;
  double v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (*(_BYTE *)(a1 + 48))
    return CFSTR("identity");
  v2 = COERCE_FLOAT(*(_OWORD *)a1);
  v3 = COERCE_FLOAT(HIDWORD(*(_QWORD *)(a1 + 16)));
  if (vabdd_f64(v2 / 0.822426, v3 / 0.96679826) >= 0.0000999999975
    || fabs(v3 / 0.96679826 + *(float *)(a1 + 40) / -0.9105512) >= 0.0000999999975)
  {
    if (vabdd_f64(v2 / 1.22500277, v3 / 1.04207075) >= 0.0000999999975
      || fabs(v3 / 1.04207075 + *(float *)(a1 + 40) / -1.09823489) >= 0.0000999999975)
    {
      if (vabdd_f64(v2 / 0.62737658, v3 / 0.91951445) >= 0.0000999999975
        || fabs(v3 / 0.91951445 + *(float *)(a1 + 40) / -0.895617337) >= 0.0000999999975)
      {
        v4 = *(float *)(a1 + 40);
        if (vabdd_f64(v2 / 1.66059811, v3 / 1.1329555) >= 0.0000999999975
          || fabs(v3 / 1.1329555 + v4 / -1.1187012) >= 0.0000999999975)
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("{{%f,%f,%f},{%f,%f,%f},{%f,%f,%f}}"), *(_QWORD *)&v2, COERCE_FLOAT(HIDWORD(*(_QWORD *)a1)), COERCE_FLOAT(*(_QWORD *)(a1 + 8)), COERCE_FLOAT(*(_OWORD *)(a1 + 16)), *(_QWORD *)&v3, COERCE_FLOAT(*(_QWORD *)(a1 + 24)), *(float *)(a1 + 32), *(float *)(a1 + 36), *(_QWORD *)&v4);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("BT.2020 -> sRGB (scale=%g)"), v3 / 1.1329555, v5, v6, v7, v8, v9, v10, v11, v12);
        }
      }
      else
      {
        objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("sRGB -> BT.2020 (scale=%g)"), v3 / 0.91951445, v5, v6, v7, v8, v9, v10, v11, v12);
      }
    }
    else
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("P3 -> sRGB (scale=%g)"), v3 / 1.04207075, v5, v6, v7, v8, v9, v10, v11, v12);
    }
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("sRGB -> P3 (scale=%g)"), v3 / 0.96679826, v5, v6, v7, v8, v9, v10, v11, v12);
  }
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

__CFString *HDRToneMappingToString(float *a1)
{
  float v1;
  __CFString *v3;
  __CFString *result;
  uint64_t v5;

  v1 = *a1;
  v3 = CFSTR("none");
  switch(LODWORD(v1))
  {
    case 0:
      goto LABEL_9;
    case 1:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("PQ EETF (scale=%g)"), a1[10], v5);
      goto LABEL_8;
    case 2:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("HLG OOTF (scale=%g, gamma=%g)"), a1[10], (float)(a1[11] + 1.0));
      goto LABEL_8;
    case 3:
      return CFSTR("EXR Tone Mapping");
    case 4:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("RWTMO (scale=%g)"), a1[9], v5);
      goto LABEL_8;
    case 5:
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("FlexGTC (scale=%g)"), a1[10], v5);
LABEL_8:
      v3 = (__CFString *)objc_claimAutoreleasedReturnValue();
LABEL_9:
      result = v3;
      break;
    default:
      result = CFSTR("???");
      break;
  }
  return result;
}

__CFString *HDRGainMappingToString(float *a1)
{
  float v1;
  __CFString *v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  double v12;
  double v13;
  void *v14;
  double v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;

  v1 = *a1;
  if (*(_DWORD *)a1)
  {
    if (LODWORD(v1) == 2)
    {
      v3 = a1[24];
      v4 = a1[25];
      v45 = v3;
      v5 = a1[26];
      v6 = a1[8];
      v7 = a1[9];
      v44 = v6;
      v8 = a1[10];
      v42 = a1[5];
      v43 = a1[4];
      v9 = a1[12];
      v10 = a1[13];
      v40 = v9;
      v41 = a1[6];
      v11 = a1[14];
      v39 = v10;
      v38 = a1[16];
      v35 = a1[18];
      v36 = a1[17];
      v34 = a1[20];
      v12 = a1[21];
      v13 = a1[22];
      v14 = (void *)MEMORY[0x1E0CB3940];
      v37 = exp2f(v3 * (float)(v6 + v9));
      v15 = exp2f(v4 * (float)(v7 + v10));
      objc_msgSend(v14, "stringWithFormat:", CFSTR("FlexRange {Y = 2^([%g,%g,%g]*([%g,%g,%g] * (G^[%g,%g,%g]) + [%g,%g,%g])) * (X + [%g,%g,%g]) - [%g,%g,%g]} (headroom=[%g,%g,%g])"), *(_QWORD *)&v45, v4, v5, *(_QWORD *)&v44, v7, v8, *(_QWORD *)&v43, *(_QWORD *)&v42, *(_QWORD *)&v41, *(_QWORD *)&v40, *(_QWORD *)&v39, v11, *(_QWORD *)&v38, *(_QWORD *)&v36, *(_QWORD *)&v35, *(_QWORD *)&v34,
        *(_QWORD *)&v12,
        *(_QWORD *)&v13,
        *(_QWORD *)&v37,
        *(_QWORD *)&v15,
        exp2f(v5 * (float)(v8 + v11)));
    }
    else
    {
      if (LODWORD(v1) != 1)
      {
        v2 = CFSTR("???");
        return v2;
      }
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Meteor+ {Y = (%g * (G^%g) + %g) * X} (headroom=%g)"), a1[8], a1[4], a1[12], (float)(a1[8] + 1.0), v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28,
        v29,
        v30,
        v31,
        v32,
        v33);
    }
    v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v2 = CFSTR("none");
  }
  return v2;
}

void sub_187ECA740(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187ECA7E4()
{
  JUMPOUT(0x187ECA7D8);
}

id HDRPixelTransformOutDescription(simd_float3x3 *a1)
{
  int16x4_t v2;
  uint16x4_t v3;
  uint16x4_t v4;
  uint16x4_t v5;
  uint16x4_t v6;
  uint16x4_t v7;
  uint16x4_t v8;
  uint16x4_t v9;
  uint16x4_t v10;
  unsigned __int16 v11;
  uint16x4_t v12;
  const __CFString *v13;
  __CFString *v14;
  uint64_t v15;
  const __CFString *v16;
  void *v17;
  uint64_t v18;
  const __CFString *v19;
  void *v20;
  void *v21;
  void *v22;

  if (a1->columns[0].i32[0] == 2)
  {
    v2 = *(int16x4_t *)a1[2].columns[0].f32;
    v3 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x200020001);
    v3.i16[3] = v3.i16[2];
    if ((vminv_u16(v3) & 0x8000) != 0)
    {
      v14 = CFSTR("420");
    }
    else
    {
      v4 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x400040002);
      v4.i16[3] = v4.i16[2];
      if ((vminv_u16(v4) & 0x8000) != 0)
      {
        v14 = CFSTR("420/2");
      }
      else
      {
        v5 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x800080004);
        v5.i16[3] = v5.i16[2];
        if ((vminv_u16(v5) & 0x8000) != 0)
        {
          v14 = CFSTR("420/4");
        }
        else
        {
          v6 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x100020001);
          v6.i16[3] = v6.i16[2];
          if ((vminv_u16(v6) & 0x8000) != 0)
          {
            v14 = CFSTR("422");
          }
          else
          {
            v7 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x200040002);
            v7.i16[3] = v7.i16[2];
            if ((vminv_u16(v7) & 0x8000) != 0)
            {
              v14 = CFSTR("422/2");
            }
            else
            {
              v8 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x400080004);
              v8.i16[3] = v8.i16[2];
              if ((vminv_u16(v8) & 0x8000) != 0)
              {
                v14 = CFSTR("422/4");
              }
              else
              {
                v9 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x1000100010001);
                v9.i16[3] = v9.i16[2];
                if ((vminv_u16(v9) & 0x8000) != 0)
                {
                  v14 = CFSTR("444");
                }
                else
                {
                  v10 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x2000200020002);
                  v10.i16[3] = v10.i16[2];
                  v11 = vminv_u16(v10);
                  v12 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x4000400040004);
                  v12.i16[3] = v12.i16[2];
                  if ((vminv_u16(v12) & 0x8000) != 0)
                    v13 = CFSTR("444/4");
                  else
                    v13 = 0;
                  if ((v11 & 0x8000) != 0)
                    v14 = CFSTR("444/2");
                  else
                    v14 = (__CFString *)v13;
                }
              }
            }
          }
        }
      }
    }
    v18 = a1->columns[0].i32[0];
    if (v18 > 3)
      v19 = CFSTR("???");
    else
      v19 = off_1E1BBE020[v18];
    v20 = (void *)MEMORY[0x1E0CB3940];
    YCCMatrixToString(a1[1]);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    HDRPixelRangeToString((__n128)a1->columns[1], (__n128)a1->columns[2]);
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v20, "stringWithFormat:", CFSTR("%@ %@ %@ subsample: %@"), v19, v21, v22, v14);
    v17 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("1/%u"), a1[2].columns[0].u16[0]);
    v14 = (__CFString *)objc_claimAutoreleasedReturnValue();
    v15 = a1->columns[0].i32[0];
    if (v15 > 3)
      v16 = CFSTR("???");
    else
      v16 = off_1E1BBE020[v15];
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ subsample: %@"), v16, v14);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
  }

  return v17;
}

void sub_187ECAA74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

const __CFString *YCCMatrixToString(simd_float3x3 a1)
{
  double v1;
  double v3;

  v1 = a1.columns[2].f32[0];
  if (fabs(v1 + -1.402) < 0.001 && fabs(a1.columns[1].f32[2] + -1.772) < 0.001)
    return CFSTR("601(in)");
  if (fabs(v1 + -1.5748) < 0.0001 && fabs(a1.columns[1].f32[2] + -1.8556) < 0.0001)
    return CFSTR("709(in)");
  if (fabs(v1 + -1.4746) < 0.0001 && fabs(a1.columns[1].f32[2] + -1.8814) < 0.0001)
    return CFSTR("2020(in)");
  v3 = a1.columns[0].f32[0];
  if (fabs(v3 + -0.299) < 0.001 && fabs(a1.columns[1].f32[0] + -0.587) < 0.001 && fabs(v1 + -0.114) < 0.001)
    return CFSTR("601(out)");
  if (fabs(v3 + -0.2126) < 0.0001 && fabs(a1.columns[1].f32[0] + -0.7152) < 0.0001 && fabs(v1 + -0.0722) < 0.0001)
    return CFSTR("709(out)");
  if (fabs(v3 + -0.2627) >= 0.0001 || fabs(a1.columns[1].f32[0] + -0.678) >= 0.0001 || fabs(v1 + -0.0593) >= 0.0001)
    return CFSTR("???");
  return CFSTR("2020(out)");
}

__CFString *HDRPixelRangeToString(__n128 a1, __n128 a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  __CFString *v5;

  v4 = a1.n128_f32[0] == 1.0 && a1.n128_f32[1] == 1.0;
  if (v4 && a2.n128_f32[0] == 0.0 && a2.n128_f32[1] == 0.0)
  {
    v5 = CFSTR("Full Range");
  }
  else
  {
    if (fabs(a1.n128_f32[0] + -1.0) < 0.0000999999975)
    {
      if (fabsf(a1.n128_f32[1] + -1.0039) < 0.0001 || fabsf(a1.n128_f32[1] + -0.99608) < 0.0001)
      {
        v5 = CFSTR("Full Range (8-bits)");
        return v5;
      }
      if (fabsf(a1.n128_f32[1] + -1.001) < 0.0001 || fabsf(a1.n128_f32[1] + -0.99902) < 0.0001)
      {
        v5 = CFSTR("Full Range (10-bits)");
        return v5;
      }
      if (fabsf(a1.n128_f32[1] + -1.0002) < 0.0001 || fabsf(a1.n128_f32[1] + -0.99976) < 0.0001)
      {
        v5 = CFSTR("Full Range (12-bits)");
        return v5;
      }
      if (fabsf(a1.n128_f32[1] + -1.0) < 0.0001 || fabsf(a1.n128_f32[1] + -0.99998) < 0.0001)
      {
        v5 = CFSTR("Full Range (16-bits)");
        return v5;
      }
    }
    if ((fabsf(a1.n128_f32[0] + -1.1644) >= 0.0001 || fabsf(a1.n128_f32[1] + -1.1384) >= 0.0001)
      && (fabsf(a1.n128_f32[0] + -0.85882) >= 0.0001 || fabsf(a1.n128_f32[1] + -0.87843) >= 0.0001))
    {
      if ((fabsf(a1.n128_f32[0] + -1.1678) >= 0.0001 || fabsf(a1.n128_f32[1] + -1.1417) >= 0.0001)
        && (fabsf(a1.n128_f32[0] + -0.85631) >= 0.0001 || fabsf(a1.n128_f32[1] + -0.87586) >= 0.0001))
      {
        if ((fabsf(a1.n128_f32[0] + -1.1687) >= 0.0001 || fabsf(a1.n128_f32[1] + -1.1426) >= 0.0001)
          && (fabsf(a1.n128_f32[0] + -0.85568) >= 0.0001 || fabsf(a1.n128_f32[1] + -0.87521) >= 0.0001))
        {
          if ((fabsf(a1.n128_f32[0] + -1.1689) >= 0.0001 || fabsf(a1.n128_f32[1] + -1.1428) >= 0.0001)
            && (fabsf(a1.n128_f32[0] + -0.85548) >= 0.0001 || fabsf(a1.n128_f32[1] + -0.87501) >= 0.0001))
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("[scale:(%f,%f,%f) offset:(%f,%f,%f)]"), a1.n128_f32[0], a1.n128_f32[1], a1.n128_f32[2], a2.n128_f32[0], a2.n128_f32[1], a2.n128_f32[2], v2, v3);
            v5 = (__CFString *)objc_claimAutoreleasedReturnValue();
          }
          else
          {
            v5 = CFSTR("Video Range (16-bits)");
          }
        }
        else
        {
          v5 = CFSTR("Video Range (12-bits)");
        }
      }
      else
      {
        v5 = CFSTR("Video Range (10-bits)");
      }
    }
    else
    {
      v5 = CFSTR("Video Range (8-bits)");
    }
  }
  return v5;
}

void sub_187ECB100(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187ECB5C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  _Unwind_Resume(a1);
}

void sub_187ECBA48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_187ECBDD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187ECBEA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187ECC420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;

  _Unwind_Resume(a1);
}

void sub_187ECC858(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t xdr::PixelFormat::choosePixelFormat(int a1, int a2, _QWORD *a3)
{
  unsigned __int16 v6;
  _QWORD *v7;
  void (**v8)(xdr::PixelFormatBGRA8Unorm *__hidden);
  int v9;
  unsigned __int16 v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  const char *v36;

  if (a1 <= 1278226735)
  {
    if (a1 > 875836517)
    {
      if (a1 > 1111970368)
      {
        if (a1 == 1111970369)
        {
          if (!a2)
          {
            if (a3)
            {
              v7 = (_QWORD *)operator new();
              v8 = &off_1E1BBBF50;
              goto LABEL_58;
            }
            return 1;
          }
          goto LABEL_85;
        }
        if (a1 != 1278226488)
        {
          if (a1 == 1278226534)
          {
            if (a2)
              goto LABEL_85;
            if (!a3)
              return 1;
            v7 = (_QWORD *)operator new();
            v8 = &off_1E1BBBEA8;
            goto LABEL_58;
          }
LABEL_60:
          v13 = a1 >> 24;
          v14 = MEMORY[0x1E0C80978];
          if (a1 < 0)
            v15 = __maskrune(a1 >> 24, 0x40000uLL);
          else
            v15 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v13 + 60) & 0x40000;
          if (v15)
            v16 = v13;
          else
            v16 = 46;
          v17 = a1 << 8 >> 24;
          if (a1 << 8 < 0)
            v18 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
          else
            v18 = *(_DWORD *)(v14 + 4 * v17 + 60) & 0x40000;
          if (v18)
            v19 = v17;
          else
            v19 = 46;
          v20 = (__int16)a1 >> 8;
          if (a1 << 16 < 0)
            v21 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
          else
            v21 = *(_DWORD *)(v14 + 4 * v20 + 60) & 0x40000;
          if (v21)
            v22 = v20;
          else
            v22 = 46;
          if ((a1 << 24) <= 0x7F000000)
            v23 = *(_DWORD *)(v14 + 4 * (char)a1 + 60) & 0x40000;
          else
            v23 = __maskrune((char)a1, 0x40000uLL);
          if (v23)
            v24 = (char)a1;
          else
            v24 = 46;
          LogError("choosePixelFormat", 254, "Unsupported pixel format: '%c%c%c%c'", v16, v19, v22, v24);
          goto LABEL_85;
        }
LABEL_41:
        if (!a2)
        {
          if (a3)
          {
            v7 = (_QWORD *)operator new();
            v8 = &off_1E1BBBE38;
            goto LABEL_58;
          }
          return 1;
        }
        goto LABEL_85;
      }
      if (a1 != 875836518)
      {
        v11 = 875836534;
        goto LABEL_39;
      }
LABEL_40:
      if (a2 == 1)
      {
        if (a3)
        {
          v7 = (_QWORD *)operator new();
          v8 = &off_1E1BBBEE0;
          goto LABEL_58;
        }
        return 1;
      }
      goto LABEL_41;
    }
    if (a1 > 875704933)
    {
      if (a1 == 875704934)
        goto LABEL_40;
      v10 = 12918;
    }
    else
    {
      if (a1 == 875704422)
        goto LABEL_40;
      v10 = 12406;
    }
    v11 = v10 | 0x34320000;
LABEL_39:
    if (a1 != v11)
      goto LABEL_60;
    goto LABEL_40;
  }
  if (a1 > 2016686641)
  {
    if (a1 > 2019963439)
    {
      if (a1 == 2019963440 || a1 == 2019963442)
      {
LABEL_33:
        if (a2)
        {
          if (a3)
          {
            v7 = (_QWORD *)operator new();
            v8 = &off_1E1BBBF18;
            goto LABEL_58;
          }
          return 1;
        }
LABEL_56:
        if (a3)
        {
          v7 = (_QWORD *)operator new();
          v8 = &off_1E1BBBE70;
          goto LABEL_58;
        }
        return 1;
      }
      v9 = 2019963956;
      goto LABEL_32;
    }
    if (a1 == 2016686642)
      goto LABEL_33;
    v6 = 13364;
LABEL_31:
    v9 = v6 | 0x78340000;
LABEL_32:
    if (a1 == v9)
      goto LABEL_33;
    goto LABEL_60;
  }
  if (a1 > 1815162993)
  {
    if (a1 == 1815162994)
    {
      if (!a2)
      {
        if (a3)
        {
          v7 = (_QWORD *)operator new();
          v8 = &off_1E1BBBFC0;
          goto LABEL_58;
        }
        return 1;
      }
    }
    else
    {
      if (a1 != 1815491698)
      {
        v6 = 12848;
        goto LABEL_31;
      }
      if (!a2)
      {
        if (a3)
        {
          v7 = (_QWORD *)operator new();
          v8 = &off_1E1B81800;
          goto LABEL_58;
        }
        return 1;
      }
    }
LABEL_85:
    v12 = 0;
    if (!a3)
      return v12;
    goto LABEL_86;
  }
  if (a1 == 1278226736)
  {
    if (!a2)
      goto LABEL_56;
    goto LABEL_85;
  }
  if (a1 != 1380411457)
    goto LABEL_60;
  if (a2)
    goto LABEL_85;
  if (!a3)
    return 1;
  v7 = (_QWORD *)operator new();
  v8 = &off_1E1BBBF88;
LABEL_58:
  *v7 = v8;
  *a3 = v7;
  v12 = 1;
LABEL_86:
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    v25 = a1 >> 24;
    if (a1 < 0)
      v26 = __maskrune(a1 >> 24, 0x40000uLL);
    else
      v26 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v25 + 60) & 0x40000;
    if (v26)
      v27 = v25;
    else
      v27 = 46;
    v28 = a1 << 8 >> 24;
    if (a1 << 8 < 0)
      v29 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
    else
      v29 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v28 + 60) & 0x40000;
    if (v29)
      v30 = v28;
    else
      v30 = 46;
    v31 = (__int16)a1 >> 8;
    if (a1 << 16 < 0)
      v32 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
    else
      v32 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v31 + 60) & 0x40000;
    if (v32)
      v33 = v31;
    else
      v33 = 46;
    if ((a1 << 24) <= 0x7F000000)
      v34 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)a1 + 60) & 0x40000;
    else
      v34 = __maskrune((char)a1, 0x40000uLL);
    if (v34)
      v35 = (char)a1;
    else
      v35 = 46;
    if (*a3)
      v36 = (const char *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*a3 + 32))(*a3);
    else
      v36 = "???";
    ImageIOLog("☀️  PixelFormat::choosePixelFormat: '%c%c%c%c' plane: %u -> %s\n", v27, v30, v33, v35, a2, v36);
  }
  return v12;
}

void sub_187ECCF64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187ECD470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60)
{
  if (a14)
    (*(void (**)(uint64_t))(*(_QWORD *)a14 + 8))(a14);
  if (a15)
    (*(void (**)(uint64_t))(*(_QWORD *)a15 + 8))(a15);
  if (a17)
    (*(void (**)(uint64_t))(*(_QWORD *)a17 + 8))(a17);
  if (a18)
    (*(void (**)(uint64_t))(*(_QWORD *)a18 + 8))(a18);
  if (a55)
    (*(void (**)(uint64_t))(*(_QWORD *)a55 + 8))(a55);
  if (a56)
    (*(void (**)(uint64_t))(*(_QWORD *)a56 + 8))(a56);
  if (a59)
    (*(void (**)(uint64_t))(*(_QWORD *)a59 + 8))(a59);
  if (a60)
    (*(void (**)(uint64_t))(*(_QWORD *)a60 + 8))(a60);
  _Unwind_Resume(exception_object);
}

void sub_187ECDB78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62)
{
  if (a35)
    (*(void (**)(uint64_t))(*(_QWORD *)a35 + 8))(a35);
  if (a36)
    (*(void (**)(uint64_t))(*(_QWORD *)a36 + 8))(a36);
  if (a61)
    (*(void (**)(uint64_t))(*(_QWORD *)a61 + 8))(a61);
  if (a62)
    (*(void (**)(uint64_t))(*(_QWORD *)a62 + 8))(a62);
  if (STACK[0x360])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x360] + 8))(STACK[0x360]);
  if (STACK[0x368])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x368] + 8))(STACK[0x368]);
  if (STACK[0x380])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x380] + 8))(STACK[0x380]);
  if (STACK[0x388])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x388] + 8))(STACK[0x388]);
  if (STACK[0x3A0])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x3A0] + 8))(STACK[0x3A0]);
  if (STACK[0x3A8])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x3A8] + 8))(STACK[0x3A8]);
  _Unwind_Resume(a1);
}

void sub_187ECE4BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t a64;
  uint64_t a66;
  uint64_t a67;
  uint64_t a69;
  uint64_t a70;

  if (a63)
    (*(void (**)(uint64_t))(*(_QWORD *)a63 + 8))(a63);
  if (a64)
    (*(void (**)(uint64_t))(*(_QWORD *)a64 + 8))(a64);
  if (a66)
    (*(void (**)(uint64_t))(*(_QWORD *)a66 + 8))(a66);
  if (a67)
    (*(void (**)(uint64_t))(*(_QWORD *)a67 + 8))(a67);
  if (a69)
    (*(void (**)(uint64_t))(*(_QWORD *)a69 + 8))(a69);
  if (a70)
    (*(void (**)(uint64_t))(*(_QWORD *)a70 + 8))(a70);
  if (STACK[0x390])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x390] + 8))(STACK[0x390]);
  if (STACK[0x398])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x398] + 8))(STACK[0x398]);
  if (STACK[0x3B0])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x3B0] + 8))(STACK[0x3B0]);
  if (STACK[0x3B8])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x3B8] + 8))(STACK[0x3B8]);
  if (STACK[0x3D0])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x3D0] + 8))(STACK[0x3D0]);
  if (STACK[0x3D8])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x3D8] + 8))(STACK[0x3D8]);
  _Unwind_Resume(a1);
}

void sub_187ECF018(_Unwind_Exception *a1)
{
  if (STACK[0x310])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x310] + 8))(STACK[0x310]);
  if (STACK[0x318])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x318] + 8))(STACK[0x318]);
  if (STACK[0x3E0])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x3E0] + 8))(STACK[0x3E0]);
  if (STACK[0x3E8])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x3E8] + 8))(STACK[0x3E8]);
  if (STACK[0x4B0])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x4B0] + 8))(STACK[0x4B0]);
  if (STACK[0x4B8])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x4B8] + 8))(STACK[0x4B8]);
  if (STACK[0x6F0])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x6F0] + 8))(STACK[0x6F0]);
  if (STACK[0x6F8])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x6F8] + 8))(STACK[0x6F8]);
  if (STACK[0x710])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x710] + 8))(STACK[0x710]);
  if (STACK[0x718])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x718] + 8))(STACK[0x718]);
  if (STACK[0x730])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x730] + 8))(STACK[0x730]);
  if (STACK[0x738])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x738] + 8))(STACK[0x738]);
  if (STACK[0x750])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x750] + 8))(STACK[0x750]);
  if (STACK[0x758])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x758] + 8))(STACK[0x758]);
  _Unwind_Resume(a1);
}

void sub_187ECF3F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56)
{
  if (a55)
    (*(void (**)(uint64_t))(*(_QWORD *)a55 + 8))(a55);
  if (a56)
    (*(void (**)(uint64_t))(*(_QWORD *)a56 + 8))(a56);
  if (STACK[0x2B0])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x2B0] + 8))(STACK[0x2B0]);
  if (STACK[0x2B8])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x2B8] + 8))(STACK[0x2B8]);
  if (STACK[0x2D0])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x2D0] + 8))(STACK[0x2D0]);
  if (STACK[0x2D8])
    (*(void (**)(unint64_t))(*(_QWORD *)STACK[0x2D8] + 8))(STACK[0x2D8]);
  _Unwind_Resume(a1);
}

void xdr::dispatch_compute_luma_gain_histogram<(unsigned short)2,(unsigned short)2,(unsigned short)4>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int32 a6, uint16x4_t a7, double a8, uint32x4_t a9)
{
  uint16x4_t v12;
  int8x8_t v15;
  uint32x2_t v16;
  float32x2_t v17;
  __int128 v23;
  void *v24;
  uint64_t v25;
  uint32x2_t v26;
  __int128 v27;
  uint32x2_t v28;
  _QWORD v29[7];
  _QWORD v30[4];
  uint64_t v31;
  _QWORD block[4];
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint16x4_t v39;
  __int16 v40;
  __int16 v41;
  __int16 v42;
  __int16 v43;

  v12 = a7;
  a7.i32[0] = a6;
  v15 = (int8x8_t)vmovl_u16(a7).u64[0];
  a9.i64[0] = 0x700000007;
  v16 = (uint32x2_t)vand_s8((int8x8_t)*(_OWORD *)&vaddw_u16(a9, a7), (int8x8_t)0xFFFF0000FFFFLL);
  v28 = vshr_n_u32(v16, 3uLL);
  v17 = vadd_f32((float32x2_t)vorr_s8(vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000));
  __asm { FMOV            V3.2S, #1.0 }
  *(float32x2_t *)&v23 = vdiv_f32(_D3, v17);
  *((float32x2_t *)&v23 + 1) = vdiv_f32(0, v17);
  v26 = vshr_n_u32(vsra_n_u32((uint32x2_t)0x700000007, v16, 3uLL), 3uLL);
  v27 = v23;
  v24 = malloc_type_calloc(0x40uLL, 0x1000uLL, 0x1000040BAFFE814uLL);
  v25 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN3xdr36dispatch_compute_luma_gain_histogramILt2ELt2ELt4EEEvRKNS_7imageInES3_RKNS_16colorTransformInERKNS_15gainTransformInERNS_11histogram2DEDv2_fDv2_t_block_invoke;
  block[3] = &__block_descriptor_104_e8_v16__0Q8l;
  v41 = v26.i16[2];
  v40 = v26.i16[0];
  v43 = v28.i16[2];
  v42 = v28.i16[0];
  v34 = a1;
  v35 = a2;
  v36 = a3;
  v37 = a4;
  v38 = v24;
  v39 = v12;
  v33 = v27;
  dispatch_apply(0x40uLL, 0, block);
  v30[0] = 0;
  v30[1] = v30;
  v30[2] = 0x2020000000;
  v30[3] = &v31;
  v31 = 0;
  v29[0] = v25;
  v29[1] = 3221225472;
  v29[2] = ___ZN3xdr36dispatch_compute_luma_gain_histogramILt2ELt2ELt4EEEvRKNS_7imageInES3_RKNS_16colorTransformInERKNS_15gainTransformInERNS_11histogram2DEDv2_fDv2_t_block_invoke_2;
  v29[3] = &unk_1E1BBE0E8;
  v29[5] = v24;
  v29[6] = a5;
  v29[4] = v30;
  dispatch_apply(0x20uLL, 0, v29);
  free(v24);
  _Block_object_dispose(v30, 8);
}

void xdr::PixelFormatBGRA8Unorm::~PixelFormatBGRA8Unorm(xdr::PixelFormatBGRA8Unorm *this)
{
  JUMPOUT(0x18D761C30);
}

double xdr::PixelFormatBGRA8Unorm::read(xdr::PixelFormatBGRA8Unorm *this, const unsigned __int8 *a2, int a3, uint8x8_t a4)
{
  int8x16_t v4;
  double result;

  a4.i32[0] = *(_DWORD *)&a2[4 * a3];
  v4 = (int8x16_t)vrev64q_s32((int32x4_t)vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a4)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)), (float32x4_t)vdupq_n_s32(0x437F0000u)));
  *(_QWORD *)&result = vextq_s8(v4, v4, 0xCuLL).u64[0];
  return result;
}

int8x8_t xdr::PixelFormatBGRA8Unorm::write(int32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int8x16_t v4;
  float32x4_t v5;
  float32x4_t v6;
  int16x8_t v7;
  int8x8_t result;

  v4 = (int8x16_t)vrev64q_s32(a1);
  v5 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  v6.i64[0] = 0x3F0000003F000000;
  v6.i64[1] = 0x3F0000003F000000;
  v7 = (int16x8_t)vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v6, v5, (float32x4_t)vextq_s8(v4, v4, 0xCuLL)), (float32x4_t)0), v5));
  *(int16x4_t *)v7.i8 = vmovn_s32((int32x4_t)v7);
  result = vmovn_s16(v7);
  *(_DWORD *)(a3 + 4 * a4) = result.i32[0];
  return result;
}

const char *xdr::PixelFormatBGRA8Unorm::name(xdr::PixelFormatBGRA8Unorm *this)
{
  return "BGRA8Unorm";
}

void xdr::PixelFormatR8Unorm::~PixelFormatR8Unorm(xdr::PixelFormatR8Unorm *this)
{
  JUMPOUT(0x18D761C30);
}

__n64 xdr::PixelFormatR8Unorm::read(xdr::PixelFormatR8Unorm *this, const unsigned __int8 *a2, int a3, float a4)
{
  __n64 result;

  LOBYTE(a4) = a2[a3];
  result.n64_f32[0] = (float)LODWORD(a4) / 255.0;
  result.n64_u32[1] = 0;
  return result;
}

double xdr::PixelFormatR8Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4;
  float32x4_t v5;
  double result;

  v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  v5.i64[0] = 0x3F0000003F000000;
  v5.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v5, v4, a1), (float32x4_t)0), v4).u64[0];
  *(_BYTE *)(a3 + a4) = (int)*(float *)&result;
  return result;
}

const char *xdr::PixelFormatR8Unorm::name(xdr::PixelFormatR8Unorm *this)
{
  return "R8Unorm";
}

void xdr::PixelFormatRG8Unorm::~PixelFormatRG8Unorm(xdr::PixelFormatRG8Unorm *this)
{
  JUMPOUT(0x18D761C30);
}

float32x2_t xdr::PixelFormatRG8Unorm::read(xdr::PixelFormatRG8Unorm *this, const unsigned __int8 *a2, int a3)
{
  const unsigned __int8 *v3;
  int8x8_t v4;

  v3 = &a2[2 * a3];
  v4.i32[0] = *v3;
  v4.i32[1] = v3[1];
  return vdiv_f32(vadd_f32((float32x2_t)vorr_s8(v4, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), (float32x2_t)vdup_n_s32(0x437F0000u));
}

double xdr::PixelFormatRG8Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4;
  _BYTE *v5;
  float32x4_t v6;
  double result;

  v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  v5 = (_BYTE *)(a3 + 2 * a4);
  v6.i64[0] = 0x3F0000003F000000;
  v6.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v6, v4, a1), (float32x4_t)0), v4)).u64[0];
  v5[1] = BYTE4(result);
  *v5 = LOBYTE(result);
  return result;
}

const char *xdr::PixelFormatRG8Unorm::name(xdr::PixelFormatRG8Unorm *this)
{
  return "RG8Unorm";
}

void xdr::PixelFormatR16Unorm::~PixelFormatR16Unorm(xdr::PixelFormatR16Unorm *this)
{
  JUMPOUT(0x18D761C30);
}

__n64 xdr::PixelFormatR16Unorm::read(xdr::PixelFormatR16Unorm *this, const unsigned __int8 *a2, int a3, float a4)
{
  __n64 result;

  LOWORD(a4) = *(_WORD *)&a2[2 * a3];
  result.n64_f32[0] = (float)LODWORD(a4) / 65535.0;
  result.n64_u32[1] = 0;
  return result;
}

double xdr::PixelFormatR16Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4;
  float32x4_t v5;
  double result;

  v4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
  v5.i64[0] = 0x3F0000003F000000;
  v5.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v5, v4, a1), (float32x4_t)0), v4).u64[0];
  *(_WORD *)(a3 + 2 * a4) = (int)*(float *)&result;
  return result;
}

const char *xdr::PixelFormatR16Unorm::name(xdr::PixelFormatR16Unorm *this)
{
  return "R16Unorm";
}

void xdr::PixelFormatRG16Unorm::~PixelFormatRG16Unorm(xdr::PixelFormatRG16Unorm *this)
{
  JUMPOUT(0x18D761C30);
}

float32x2_t xdr::PixelFormatRG16Unorm::read(xdr::PixelFormatRG16Unorm *this, const unsigned __int8 *a2, int a3)
{
  const unsigned __int8 *v3;
  int8x8_t v4;

  v3 = &a2[4 * a3];
  v4.i32[0] = *(unsigned __int16 *)v3;
  v4.i32[1] = *((unsigned __int16 *)v3 + 1);
  return vdiv_f32(vadd_f32((float32x2_t)vorr_s8(v4, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), (float32x2_t)vdup_n_s32(0x477FFF00u));
}

double xdr::PixelFormatRG16Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4;
  _WORD *v5;
  float32x4_t v6;
  double result;

  v4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
  v5 = (_WORD *)(a3 + 4 * a4);
  v6.i64[0] = 0x3F0000003F000000;
  v6.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v6, v4, a1), (float32x4_t)0), v4)).u64[0];
  v5[1] = WORD2(result);
  *v5 = LOWORD(result);
  return result;
}

const char *xdr::PixelFormatRG16Unorm::name(xdr::PixelFormatRG16Unorm *this)
{
  return "RG16Unorm";
}

void xdr::PixelFormatBGR10A2Unorm::~PixelFormatBGR10A2Unorm(xdr::PixelFormatBGR10A2Unorm *this)
{
  JUMPOUT(0x18D761C30);
}

double xdr::PixelFormatBGR10A2Unorm::read(xdr::PixelFormatBGR10A2Unorm *this, const unsigned __int8 *a2, int a3)
{
  const float *v3;
  uint32x4_t v4;
  double result;

  v3 = (const float *)&a2[4 * a3];
  v4 = (uint32x4_t)vld1q_dup_f32(v3);
  *(_QWORD *)&result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_18820C000), (int8x16_t)xmmword_18820C010)), (float32x4_t)xmmword_18820C020).u64[0];
  return result;
}

int32x2_t xdr::PixelFormatBGR10A2Unorm::write(int8x16_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  int8x16_t v7;
  int32x4_t v8;
  int8x16_t v9;
  int32x2_t result;

  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  v5 = vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v4, (float32x4_t)xmmword_18820C030, (float32x4_t)vextq_s8(a1, a1, 0xCuLL)), (float32x4_t)0), (float32x4_t)xmmword_18820C030);
  v6.i64[0] = 0x4F0000004F000000;
  v6.i64[1] = 0x4F0000004F000000;
  v7 = (int8x16_t)vcgtq_f32(v5, v6);
  v8 = vcvtq_s32_f32(vsubq_f32(v5, (float32x4_t)vandq_s8((int8x16_t)v6, v7)));
  v6.i64[0] = 0x8000000080000000;
  v6.i64[1] = 0x8000000080000000;
  v9 = (int8x16_t)vshlq_u32((uint32x4_t)vaddq_s32((int32x4_t)vandq_s8(v7, (int8x16_t)v6), v8), (uint32x4_t)xmmword_18820C040);
  *(int32x2_t *)v9.i8 = vadd_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
  result = vadd_s32(*(int32x2_t *)v9.i8, vdup_lane_s32(*(int32x2_t *)v9.i8, 1));
  *(_DWORD *)(a3 + 4 * a4) = result.i32[0];
  return result;
}

const char *xdr::PixelFormatBGR10A2Unorm::name(xdr::PixelFormatBGR10A2Unorm *this)
{
  return "BGR10A2Unorm";
}

void xdr::PixelFormatRGBA16Float::~PixelFormatRGBA16Float(xdr::PixelFormatRGBA16Float *this)
{
  JUMPOUT(0x18D761C30);
}

double xdr::PixelFormatRGBA16Float::read(xdr::PixelFormatRGBA16Float *this, const unsigned __int8 *a2, int a3)
{
  double result;

  *(_QWORD *)&result = vcvtq_f32_f16(*(float16x4_t *)&a2[8 * a3]).u64[0];
  return result;
}

float16x4_t xdr::PixelFormatRGBA16Float::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float16x4_t result;

  result = vcvt_f16_f32(a1);
  *(float16x4_t *)(a3 + 8 * a4) = result;
  return result;
}

const char *xdr::PixelFormatRGBA16Float::name(xdr::PixelFormatRGBA16Float *this)
{
  return "RGBA16Float";
}

void xdr::PixelFormatRGBA16Unorm::~PixelFormatRGBA16Unorm(xdr::PixelFormatRGBA16Unorm *this)
{
  JUMPOUT(0x18D761C30);
}

double xdr::PixelFormatRGBA16Unorm::read(xdr::PixelFormatRGBA16Unorm *this, const unsigned __int8 *a2, int a3)
{
  double result;

  *(_QWORD *)&result = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)&a2[8 * a3]), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)), (float32x4_t)vdupq_n_s32(0x477FFF00u)).u64[0];
  return result;
}

int16x4_t xdr::PixelFormatRGBA16Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4;
  float32x4_t v5;
  int16x4_t result;

  v4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
  v5.i64[0] = 0x3F0000003F000000;
  v5.i64[1] = 0x3F0000003F000000;
  result = vmovn_s32(vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v5, v4, a1), (float32x4_t)0), v4)));
  *(int16x4_t *)(a3 + 8 * a4) = result;
  return result;
}

const char *xdr::PixelFormatRGBA16Unorm::name(xdr::PixelFormatRGBA16Unorm *this)
{
  return "RGBA16Unorm";
}

void xdr::PixelFormatR32Float::~PixelFormatR32Float(xdr::PixelFormatR32Float *this)
{
  JUMPOUT(0x18D761C30);
}

double xdr::PixelFormatR32Float::read(xdr::PixelFormatR32Float *this, const unsigned __int8 *a2, int a3)
{
  double result;

  *(_QWORD *)&result = *(unsigned int *)&a2[4 * a3];
  return result;
}

void xdr::PixelFormatR32Float::write(float a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  *(float *)(a3 + 4 * a4) = a1;
}

const char *xdr::PixelFormatR32Float::name(xdr::PixelFormatR32Float *this)
{
  return "R32Float";
}

uint64_t _ZN3xdr8ImageBoxI19HDRPixelTransformInLNS_7TextureIDv2_tDv2_fDv2_iE10AccessModeE0EEC2EP10__CVBufferRKS1_(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = (uint64_t *)(a1 + 16);
  *(_QWORD *)(a1 + 24) = 0;
  v5 = *a3;
  if (*a3 == 3)
    goto LABEL_4;
  if (v5 == 2)
  {
    v7 = operator new();
    xdr::PixelBufferTexture::PixelBufferTexture(v7, *(const void **)a1, 0, 0);
    *(_QWORD *)(a1 + 16) = v7;
    v8 = operator new();
    xdr::PixelBufferTexture::PixelBufferTexture(v8, *(const void **)a1, 1u, 0);
    *(_QWORD *)(a1 + 24) = v8;
    return a1;
  }
  if (v5 == 1)
  {
LABEL_4:
    v6 = operator new();
    xdr::PixelBufferTexture::PixelBufferTexture(v6, *(const void **)a1, 0, 0);
    *v4 = v6;
  }
  return a1;
}

void sub_187ECFBC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40AFB6B84ELL);
  _Unwind_Resume(a1);
}

uint64_t xdr::PixelBufferTexture::PixelBufferTexture(uint64_t a1, const void *a2, unsigned int a3, int a4)
{
  uint64_t v8;
  __int16 WidthOfPlane;
  __int16 HeightOfPlane;
  int PixelFormatType;

  v8 = a3;
  WidthOfPlane = gFunc_CVPixelBufferGetWidthOfPlane(a2, a3);
  HeightOfPlane = gFunc_CVPixelBufferGetHeightOfPlane(a2, v8);
  *(_DWORD *)(a1 + 8) = a4;
  *(_WORD *)(a1 + 12) = WidthOfPlane;
  *(_WORD *)(a1 + 14) = HeightOfPlane;
  *(_QWORD *)a1 = &off_1E1BBBE08;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = CFRetain(a2);
  if (!gFunc_CVPixelBufferLockBaseAddress(a2, a4 == 0))
  {
    *(_QWORD *)(a1 + 24) = gFunc_CVPixelBufferGetBaseAddressOfPlane(a2, v8);
    *(_QWORD *)(a1 + 32) = gFunc_CVPixelBufferGetBytesPerRowOfPlane(a2, v8);
  }
  PixelFormatType = gFunc_CVPixelBufferGetPixelFormatType(a2);
  xdr::PixelFormat::choosePixelFormat(PixelFormatType, a3, (_QWORD *)(a1 + 40));
  return a1;
}

void xdr::PixelBufferTexture::~PixelBufferTexture(xdr::PixelBufferTexture *this, __n128 a2)
{
  xdr::PixelBufferTexture::~PixelBufferTexture(this, a2);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BBBE08;
  v3 = *((_QWORD *)this + 5);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  gFunc_CVPixelBufferUnlockBaseAddress(*((_QWORD *)this + 2), *((_DWORD *)this + 2) == 0, a2);
  CFRelease(*((CFTypeRef *)this + 2));
}

double xdr::PixelBufferTexture::read(uint64_t a1, __int32 a2, uint16x4_t a3)
{
  int8x8_t v3;
  uint32x2_t v4;
  int16x4_t v5;
  uint64_t v6;
  uint64_t v7;
  double result;

  a3.i32[0] = a2;
  v3 = (int8x8_t)vmovl_u16(a3).u64[0];
  v4.i32[0] = *(unsigned __int16 *)(a1 + 12);
  v4.i32[1] = *(unsigned __int16 *)(a1 + 14);
  v5 = (int16x4_t)vcgt_u32(v4, (uint32x2_t)vand_s8(v3, (int8x8_t)0xFFFF0000FFFFLL));
  if ((vminv_u16((uint16x4_t)vuzp1_s16(v5, v5)) & 0x8000) == 0)
    return 0.0;
  v6 = *(_QWORD *)(a1 + 40);
  if (!v6)
    return 0.0;
  v7 = *(_QWORD *)(a1 + 24);
  if (!v7)
    return 0.0;
  (*(void (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)v6 + 16))(*(_QWORD *)(a1 + 40), v7 + *(_QWORD *)(a1 + 32) * v3.u16[2], (unsigned __int16)a2);
  return result;
}

uint64_t xdr::PixelBufferTexture::write(uint64_t result, __int32 a2, double a3, uint16x4_t a4)
{
  int8x8_t v4;
  uint32x2_t v5;
  int16x4_t v6;
  uint64_t v7;
  uint64_t v8;

  a4.i32[0] = a2;
  v4 = (int8x8_t)vmovl_u16(a4).u64[0];
  v5.i32[0] = *(unsigned __int16 *)(result + 12);
  v5.i32[1] = *(unsigned __int16 *)(result + 14);
  v6 = (int16x4_t)vcgt_u32(v5, (uint32x2_t)vand_s8(v4, (int8x8_t)0xFFFF0000FFFFLL));
  if ((vminv_u16((uint16x4_t)vuzp1_s16(v6, v6)) & 0x8000) != 0)
  {
    v7 = *(_QWORD *)(result + 40);
    if (v7)
    {
      v8 = *(_QWORD *)(result + 24);
      if (v8)
        return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)v7 + 24))(*(_QWORD *)(result + 40), v8 + *(_QWORD *)(result + 32) * v4.u16[2], (unsigned __int16)a2);
    }
  }
  return result;
}

uint64_t _ZN3xdr8ImageBoxI20HDRPixelTransformOutLNS_7TextureIDv2_tDv2_fDv2_iE10AccessModeE1EEC2EP10__CVBufferRKS1_(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = (uint64_t *)(a1 + 16);
  *(_QWORD *)(a1 + 24) = 0;
  v5 = *a3;
  if (*a3 == 3)
    goto LABEL_4;
  if (v5 == 2)
  {
    v7 = operator new();
    xdr::PixelBufferTexture::PixelBufferTexture(v7, *(const void **)a1, 0, 1);
    *(_QWORD *)(a1 + 16) = v7;
    v8 = operator new();
    xdr::PixelBufferTexture::PixelBufferTexture(v8, *(const void **)a1, 1u, 1);
    *(_QWORD *)(a1 + 24) = v8;
    return a1;
  }
  if (v5 == 1)
  {
LABEL_4:
    v6 = operator new();
    xdr::PixelBufferTexture::PixelBufferTexture(v6, *(const void **)a1, 0, 1);
    *v4 = v6;
  }
  return a1;
}

void sub_187ECFF6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40AFB6B84ELL);
  _Unwind_Resume(a1);
}

_QWORD *xdr::ColorBox<HDRColorTransformIn>::ColorBox(_QWORD *a1, uint64_t a2)
{
  xdr::TableTexture **v4;
  xdr::TableTexture *v5;
  xdr::TableTexture *v6;

  *a1 = a2;
  a1[1] = 0;
  v4 = (xdr::TableTexture **)(a1 + 1);
  a1[2] = 0;
  if (*(_DWORD *)a2 == 6)
  {
    v5 = (xdr::TableTexture *)operator new();
    xdr::TableTexture::TableTexture(v5, *(NSData **)(a2 + 64));
    *v4 = v5;
  }
  if (*(_DWORD *)(a2 + 80) == 5)
  {
    v6 = (xdr::TableTexture *)operator new();
    xdr::TableTexture::TableTexture(v6, *(NSData **)(a2 + 144));
    a1[2] = v6;
  }
  return a1;
}

void sub_187ED003C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40B7F8E0AELL);
  _Unwind_Resume(a1);
}

xdr::TableTexture *xdr::TableTexture::TableTexture(xdr::TableTexture *this, NSData *a2)
{
  NSData *v3;
  unint64_t v4;
  NSData *v5;
  uint64_t v6;
  NSData *v7;

  v3 = a2;
  v4 = -[NSData length](v3, "length");
  *((_DWORD *)this + 2) = 0;
  *((_WORD *)this + 6) = v4 >> 2;
  *(_QWORD *)this = &off_1E1BBBDD8;
  *((_QWORD *)this + 2) = 0;
  v5 = objc_retainAutorelease(v3);
  v6 = -[NSData bytes](v5, "bytes");
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = v6;
  v7 = v5;
  *((_QWORD *)this + 2) = v7;
  xdr::PixelFormat::choosePixelFormat(1278226534, 0, (_QWORD *)this + 4);

  return this;
}

void sub_187ED00F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void xdr::TableTexture::~TableTexture(xdr::TableTexture *this)
{
  void *v1;
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BBBDD8;
  v1 = (void *)*((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);

}

{
  void *v1;
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BBBDD8;
  v1 = (void *)*((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);

  JUMPOUT(0x18D761C30);
}

double xdr::TableTexture::read(xdr::TableTexture *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  double result;

  if (*((unsigned __int16 *)this + 6) <= a2)
    return 0.0;
  v3 = *((_QWORD *)this + 4);
  if (!v3)
    return 0.0;
  v5 = *((_QWORD *)this + 3);
  if (!v5)
    return 0.0;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3 + 16))(v3, v5, a2);
  return result;
}

uint64_t xdr::TableTexture::write(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  if (*(unsigned __int16 *)(result + 12) > a2)
  {
    v2 = result;
    result = *(_QWORD *)(result + 32);
    if (result)
    {
      v4 = *(_QWORD *)(v2 + 24);
      if (v4)
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 24))(result, v4, a2);
    }
  }
  return result;
}

_QWORD *xdr::ColorBox<HDRColorTransformOut>::ColorBox(_QWORD *a1, uint64_t a2)
{
  xdr::TableTexture **v4;
  xdr::TableTexture *v5;
  xdr::TableTexture *v6;

  *a1 = a2;
  a1[1] = 0;
  v4 = (xdr::TableTexture **)(a1 + 1);
  a1[2] = 0;
  if (*(_DWORD *)(a2 + 208) == 6)
  {
    v5 = (xdr::TableTexture *)operator new();
    xdr::TableTexture::TableTexture(v5, *(NSData **)(a2 + 272));
    *v4 = v5;
  }
  if (*(_DWORD *)(a2 + 64) == 5)
  {
    v6 = (xdr::TableTexture *)operator new();
    xdr::TableTexture::TableTexture(v6, *(NSData **)(a2 + 128));
    a1[2] = v6;
  }
  return a1;
}

void sub_187ED02BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40B7F8E0AELL);
  _Unwind_Resume(a1);
}

void ___ZN3xdr36dispatch_convert_image_to_image_loopILt1ELt1EEEvRKNS_7imageInERKNS_8imageOutERKNS_16colorTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(uint64_t a1, __int16 a2, double a3, uint16x4_t a4)
{
  int v6;
  float32x4_t *v7;
  float32x4_t v8;
  unsigned __int32 v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0x100000000;
  v11 = 1;
  if (*(_WORD *)(a1 + 80))
  {
    v6 = 0;
    do
    {
      HIWORD(v9) = a2;
      LOWORD(v9) = v6;
      v7 = *(float32x4_t **)(a1 + 56);
      *(double *)v8.i64 = xdr::convert_image_to_image(*(_QWORD *)(a1 + 48), *(float32x4_t **)(a1 + 64), *(float32x4_t **)(a1 + 72), v9, &v10, *(int8x16_t *)(a1 + 32), a4);
      v12 = v8;
      xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v7, &v12, v9, *(int16x4_t *)v8.f32);
      ++v6;
    }
    while (*(unsigned __int16 *)(a1 + 80) > (unsigned __int16)v6);
  }
}

double xdr::convert_image_to_image(uint64_t a1, float32x4_t *a2, float32x4_t *a3, __int32 a4, _DWORD *a5, int8x16_t a6, uint16x4_t a7)
{
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;

  a7.i32[0] = a4;
  xdr::image_sample(a1, a5, COERCE_DOUBLE(vmla_f32((float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL), vadd_f32((float32x2_t)vorr_s8((int8x8_t)*(_OWORD *)&vmovl_u16(a7), (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), *(float32x2_t *)a6.i8)));
  *(double *)v10.i64 = xdr::apply_color_trc((uint64_t)a2, v9);
  *(double *)v11.i64 = xdr::apply_tone_mapping((uint64_t)&a2[5], v10);
  if (!a2[17].i8[0])
    v11 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a2[14], v11.f32[0]), a2[15], *(float32x2_t *)v11.f32, 1), a2[16], v11, 2);
  if (!a3[3].i8[0])
    v11 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a3, v11.f32[0]), a3[1], *(float32x2_t *)v11.f32, 1), a3[2], v11, 2);
  *(double *)v12.i64 = xdr::apply_tone_mapping((uint64_t)&a3[4], v11);
  return xdr::apply_color_trc((uint64_t)&a3[13], v12);
}

__int16 xdr::image_write_loop<(unsigned short)1,(unsigned short)1>@<H0>(float32x4_t *a1@<X0>, float32x4_t *a2@<X1>, uint64_t a3@<X2>, int16x4_t a4@<D0>)
{
  __int32 v6;
  __n128 v7;
  uint64_t v8;
  uint16x4_t v9;
  uint16x4_t v10;
  int8x16_t v12;

  v6 = a1[1].i32[0];
  if (v6 == 3)
  {
LABEL_4:
    if (a1[7].i16[0] != 1)
      return a4.i16[0];
    v7 = (__n128)vmlaq_f32(a1[3], *a2, a1[2]);
    v7.n128_u32[3] = 1.0;
    v8 = a1->i64[0];
    goto LABEL_6;
  }
  if (v6 != 2)
  {
    if (v6 != 1)
      return a4.i16[0];
    goto LABEL_4;
  }
  a4 = *(int16x4_t *)a1[7].f32;
  v9 = (uint16x4_t)vceq_s16(a4, (int16x4_t)0x200020001);
  v9.i16[3] = v9.i16[2];
  if ((vminv_u16(v9) & 0x8000) == 0)
  {
    v10 = (uint16x4_t)vceq_s16(a4, (int16x4_t)0x100020001);
    v10.i16[3] = v10.i16[2];
    if ((vminv_u16(v10) & 0x8000) == 0)
    {
      a4 = vceq_s16(a4, (int16x4_t)0x1000100010001);
      a4.i16[3] = a4.i16[2];
      a4.i16[0] = vminv_u16((uint16x4_t)a4);
      if (a4.i16[0] < 0)
      {
        v12 = (int8x16_t)vmlaq_f32(a1[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1[4], COERCE_FLOAT(*a2)), a1[5], *(float32x2_t *)a2->f32, 1), a1[6], *a2, 2), a1[2]);
        (*(void (**)(float))(*(_QWORD *)a1->i64[0] + 24))(*(float *)v12.i32);
        v7.n128_u64[0] = vextq_s8(v12, v12, 4uLL).u64[0];
        v7.n128_u64[1] = 0x3F80000000000000;
        v8 = a1->i64[1];
LABEL_6:
        (*(void (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v8 + 24))(v8, a3, v7);
      }
    }
  }
  return a4.i16[0];
}

void xdr::image_sample(uint64_t a1, _DWORD *a2, double a3)
{
  float32x2_t v5;

  v5 = vadd_f32(*(float32x2_t *)(a1 + 128), vmla_lane_f32(vmul_n_f32(*(float32x2_t *)(a1 + 112), *(float *)&a3), *(float32x2_t *)(a1 + 120), *(float32x2_t *)&a3, 1));
  _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE6sampleERKNS_7SamplerES2_S3_(*(_QWORD *)a1, a2, v5, 0);
  if (*(_DWORD *)(a1 + 16) == 2)
    _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE6sampleERKNS_7SamplerES2_S3_(*(_QWORD *)(a1 + 8), a2, v5, 0);
}

double xdr::apply_color_trc(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v4;
  int8x16_t v5;
  simd_float4 v11;
  simd_float4 v12;
  float32x4_t v13;
  float32x4_t v14;
  simd_float4 v15;
  int8x16_t v16;
  simd_float4 v18;
  float32x4_t v19;
  int32x2_t v20;
  int8x16_t v21;
  int32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x4_t v26;
  simd_float4 v27;
  int8x16_t v28;
  simd_float4 v30;
  float32x4_t v31;
  float32x4_t v32;
  int32x2_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  simd_float4 v39;
  int8x16_t v40;
  simd_float4 v42;
  float32x4_t v43;
  int32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  simd_float4 v47;
  int8x16_t v48;
  simd_float4 v50;
  int32x4_t v51;
  unsigned __int16 *v52;
  float32x4_t v53;
  int32x4_t v54;
  float v55;
  int32x4_t v56;
  float v57;
  int8x16_t v58;
  simd_float4 v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  simd_float4 v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  int8x16_t v69;
  float32x4_t v72;
  simd_float4 v74;
  int8x16_t v75;
  int32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  simd_float4 v80;
  float32x4_t v81;
  float32x4_t v82;
  int32x4_t v83;
  float32x4_t v85;
  float32x4_t v86;
  simd_float4 v88;
  float32x4_t v90;
  int32x4_t v91;
  float32x4_t v92;
  float32x4_t v94;
  float v95;
  float32x4_t v96;
  float v98;
  float v99;
  float32x4_t v100;
  int32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  int32x4_t v108;
  float32x4_t v109;
  int8x16_t v110;
  int8x16_t v111;
  int8x16_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  uint64_t v121;
  int v122;

  v2 = a2;
  switch(*(_DWORD *)a1)
  {
    case 1:
      v4 = vabsq_f32(a2);
      v4.i32[3] = 0;
      v11 = (simd_float4)vmaxnmq_f32(v4, (float32x4_t)xmmword_18820C0B0);
      v5.i64[0] = 0x8000000080000000;
      v5.i64[1] = 0x8000000080000000;
      __asm { FMOV            V3.4S, #1.0 }
      v113 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, v5), _Q3), (int8x16_t)0);
      v11.i32[3] = 0;
      v12 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v12.i32[3] = 0;
      goto LABEL_12;
    case 2:
      v13 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0), a2, COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      v14 = vabsq_f32(v13);
      v14.i32[3] = 0;
      v15 = (simd_float4)vmaxnmq_f32(v14, (float32x4_t)xmmword_18820C0B0);
      v16.i64[0] = 0x8000000080000000;
      v16.i64[1] = 0x8000000080000000;
      v114 = v2;
      __asm { FMOV            V4.4S, #1.0 }
      v104 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v13), (int8x16_t)vcgtzq_f32(v13)), vorrq_s8(vandq_s8((int8x16_t)v13, v16), _Q4), (int8x16_t)0);
      v15.i32[3] = 0;
      v18 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v18.i32[3] = 0;
      v19 = (float32x4_t)_simd_pow_f4(v15, v18);
      *(float *)v20.i32 = (float)-*(float *)(a1 + 20) / *(float *)(a1 + 16);
      v21 = (int8x16_t)vmulq_f32(v19, v104);
      v22 = vcgtq_f32((float32x4_t)vdupq_lane_s32(v20, 0), v114);
      v22.i32[3] = 0;
      v23 = (int8x16_t)vcltzq_s32(v22);
      v24 = 0uLL;
      goto LABEL_8;
    case 3:
      v25 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0), a2, COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      v26 = vabsq_f32(v25);
      v26.i32[3] = 0;
      v27 = (simd_float4)vmaxnmq_f32(v26, (float32x4_t)xmmword_18820C0B0);
      v28.i64[0] = 0x8000000080000000;
      v28.i64[1] = 0x8000000080000000;
      v115 = v2;
      __asm { FMOV            V4.4S, #1.0 }
      v105 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v25), (int8x16_t)vcgtzq_f32(v25)), vorrq_s8(vandq_s8((int8x16_t)v25, v28), _Q4), (int8x16_t)0);
      v27.i32[3] = 0;
      v30 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v30.i32[3] = 0;
      v31 = (float32x4_t)_simd_pow_f4(v27, v30);
      v32 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0);
      *(float *)v33.i32 = (float)-*(float *)(a1 + 20) / *(float *)(a1 + 16);
      v34 = (float32x4_t)vdupq_lane_s32(v33, 0);
      v35 = (int8x16_t)vaddq_f32(v32, vmulq_f32(v31, v105));
      v36 = v115;
      goto LABEL_6;
    case 4:
      v37 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0), a2, COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      v38 = vabsq_f32(v37);
      v38.i32[3] = 0;
      v39 = (simd_float4)vmaxnmq_f32(v38, (float32x4_t)xmmword_18820C0B0);
      v40.i64[0] = 0x8000000080000000;
      v40.i64[1] = 0x8000000080000000;
      v116 = v2;
      __asm { FMOV            V4.4S, #1.0 }
      v106 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v37), (int8x16_t)vcgtzq_f32(v37)), vorrq_s8(vandq_s8((int8x16_t)v37, v40), _Q4), (int8x16_t)0);
      v39.i32[3] = 0;
      v42 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v42.i32[3] = 0;
      v43 = (float32x4_t)_simd_pow_f4(v39, v42);
      v36 = v116;
      v35 = (int8x16_t)vmulq_f32(v43, v106);
      v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 28), 0);
      v32 = vmulq_n_f32(v116, COERCE_FLOAT(*(_QWORD *)(a1 + 24)));
LABEL_6:
      v44 = vcgtq_f32(v34, v36);
      v44.i32[3] = 0;
      v2.i64[0] = vbslq_s8((int8x16_t)vcltzq_s32(v44), (int8x16_t)v32, v35).u64[0];
      return *(double *)v2.i64;
    case 5:
      v45 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0), a2, COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      v46 = vabsq_f32(v45);
      v46.i32[3] = 0;
      v47 = (simd_float4)vmaxnmq_f32(v46, (float32x4_t)xmmword_18820C0B0);
      v48.i64[0] = 0x8000000080000000;
      v48.i64[1] = 0x8000000080000000;
      v117 = v2;
      __asm { FMOV            V4.4S, #1.0 }
      v107 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v45), (int8x16_t)vcgtzq_f32(v45)), vorrq_s8(vandq_s8((int8x16_t)v45, v48), _Q4), (int8x16_t)0);
      v47.i32[3] = 0;
      v50 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v50.i32[3] = 0;
      v21 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 32), 0), vmulq_f32((float32x4_t)_simd_pow_f4(v47, v50), v107));
      v24 = (int8x16_t)vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 36), 0), v117, COERCE_FLOAT(*(_QWORD *)(a1 + 24)));
      v51 = vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 28), 0), v117);
      v51.i32[3] = 0;
      v23 = (int8x16_t)vcltzq_s32(v51);
LABEL_8:
      v2.i64[0] = vbslq_s8(v23, v24, v21).u64[0];
      return *(double *)v2.i64;
    case 6:
      v2.i32[3] = 0;
      v52 = *(unsigned __int16 **)(a1 + 64);
      v53 = vmaxnmq_f32(v2, (float32x4_t)0);
      v53.i32[3] = 0;
      v118 = vminnmq_f32(v53, (float32x4_t)xmmword_18820C060);
      v122 = 1;
      v121 = 0x100000000;
      *(double *)v54.i64 = xdr::Texture<unsigned short,float,int>::sample(v52, &v121, 0, v118.f32[0], 1.0);
      v108 = v54;
      v122 = 1;
      v121 = 0x100000000;
      *(double *)v56.i64 = xdr::Texture<unsigned short,float,int>::sample(v52, &v121, 0, v118.f32[1], v55);
      v101 = v56;
      v122 = 1;
      v121 = 0x100000000;
      xdr::Texture<unsigned short,float,int>::sample(v52, &v121, 0, v118.f32[2], v57);
      v2.i64[0] = vzip1q_s32(v108, v101).u64[0];
      return *(double *)v2.i64;
    case 7:
      v58.i64[0] = 0x8000000080000000;
      v58.i64[1] = 0x8000000080000000;
      __asm { FMOV            V2.4S, #1.0 }
      v113 = vmulq_n_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgtzq_f32(a2)), vorrq_s8(vandq_s8((int8x16_t)a2, v58), _Q2), (int8x16_t)0), COERCE_FLOAT(*(_QWORD *)(a1 + 36)));
      v60 = (simd_float4)vabsq_f32(a2);
      v60.i32[3] = 0;
      v61 = (float32x4_t)_simd_pow_f4(v60, (simd_float4)xmmword_18820C090);
      v62 = vaddq_f32(v61, (float32x4_t)vdupq_n_s32(0xBF560000));
      v62.i32[3] = 0;
      v11 = (simd_float4)vdivq_f32(vmaxnmq_f32(v62, (float32x4_t)0), vmlaq_f32((float32x4_t)vdupq_n_s32(0x4196D000u), (float32x4_t)vdupq_n_s32(0xC1958000), v61));
      v11.i32[3] = 0;
      v12 = (simd_float4)xmmword_18820C0A0;
      goto LABEL_12;
    case 8:
      v63.i64[0] = 0x8000000080000000;
      v63.i64[1] = 0x8000000080000000;
      __asm { FMOV            V1.4S, #1.0 }
      v109 = (float32x4_t)_Q1;
      v113 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, v63), _Q1), (int8x16_t)0);
      v65 = (simd_float4)vmulq_n_f32(vabsq_f32(v2), COERCE_FLOAT(*(_QWORD *)(a1 + 36)));
      v65.i32[3] = 0;
      v66 = (float32x4_t)_simd_pow_f4(v65, (simd_float4)xmmword_18820C070);
      v11 = (simd_float4)vdivq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3F560000u), (float32x4_t)vdupq_n_s32(0x4196D000u), v66), vmlaq_f32(v109, (float32x4_t)vdupq_n_s32(0x41958000u), v66));
      v11.i32[3] = 0;
      v12 = (simd_float4)xmmword_18820C080;
LABEL_12:
      v67 = (float32x4_t)_simd_pow_f4(v11, v12);
      goto LABEL_15;
    case 9:
      v68 = vabsq_f32(vmulq_n_f32(a2, COERCE_FLOAT(*(_OWORD *)(a1 + 32))));
      v69.i64[0] = 0x8000000080000000;
      v69.i64[1] = 0x8000000080000000;
      __asm
      {
        FMOV            V1.4S, #1.0
        FMOV            V3.4S, #3.0
      }
      v72 = vmulq_f32(v68, _Q3);
      v72.i32[3] = 0;
      v113 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, v69), _Q1), (int8x16_t)0);
      v110 = (int8x16_t)vsqrtq_f32(v72);
      v100 = v68;
      __asm { FMOV            V1.4S, #12.0 }
      v74 = (simd_float4)vmlaq_f32(vnegq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0)), _Q1, v68);
      v74.i32[3] = 0;
      v75 = (int8x16_t)vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0), (float32x4_t)_simd_log_f4(v74), COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      v76 = vcgtq_f32(v100, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 28), 0));
      v76.i32[3] = 0;
      v67 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v76), v75, v110);
      goto LABEL_15;
    case 0xA:
      a2.i32[0] = *(_DWORD *)(a1 + 36);
      v77 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), vabsq_f32(v2), 1.0 - a2.f32[0]);
      v77.i32[3] = 0;
      v78 = vmaxnmq_f32(v77, (float32x4_t)0);
      v77.i64[0] = 0x8000000080000000;
      v77.i64[1] = 0x8000000080000000;
      __asm { FMOV            V2.4S, #1.0 }
      v113 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, (int8x16_t)v77), _Q2), (int8x16_t)0);
      v102 = v78;
      v111 = (int8x16_t)vmulq_n_f32(vmulq_f32(v78, v78), COERCE_FLOAT(*(_OWORD *)(a1 + 32)));
      v80 = (simd_float4)vdivq_f32(vsubq_f32(v78, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0)), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 16), 0));
      v80.i32[3] = 0;
      v81 = (float32x4_t)_simd_exp_f4(v80);
      v82.i64[0] = 0x3F0000003F000000;
      v82.i64[1] = 0x3F0000003F000000;
      v83 = vcgtq_f32(v102, v82);
      v83.i32[3] = 0;
      v67 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v83), (int8x16_t)vmulq_n_f32(vaddq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0)), COERCE_FLOAT(*(_QWORD *)(a1 + 28))), v111);
LABEL_15:
      v2.i64[0] = vmulq_f32(v113, v67).u64[0];
      break;
    case 0xB:
      a2.i32[0] = *(_DWORD *)(a1 + 36);
      v85 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), vabsq_f32(v2), 1.0 - a2.f32[0]);
      v85.i32[3] = 0;
      v86 = vmaxnmq_f32(v85, (float32x4_t)0);
      v85.i64[0] = 0x8000000080000000;
      v85.i64[1] = 0x8000000080000000;
      __asm { FMOV            V2.4S, #1.0 }
      v119 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, (int8x16_t)v85), _Q2), (int8x16_t)0);
      v103 = v86;
      v112 = (int8x16_t)vmulq_n_f32(vmulq_f32(v86, v86), COERCE_FLOAT(*(_OWORD *)(a1 + 32)));
      v88 = (simd_float4)vdivq_f32(vsubq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0)), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 16), 0));
      v88.i32[3] = 0;
      _Q0 = (float32x4_t)_simd_exp_f4(v88);
      v90.i64[0] = 0x3F0000003F000000;
      v90.i64[1] = 0x3F0000003F000000;
      v91 = vcgtq_f32(v103, v90);
      v91.i32[3] = 0;
      v92 = vmulq_f32(v119, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v91), (int8x16_t)vmulq_n_f32(vaddq_f32(_Q0, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0)), COERCE_FLOAT(*(_QWORD *)(a1 + 28))), v112));
      _Q0.i32[0] = v92.i32[2];
      v91.i32[0] = v92.i32[1];
      _Q2 = *(float32x4_t *)(a1 + 48);
      v94 = vmulq_f32(_Q2, v92);
      v95 = v92.f32[0];
      v120 = v92;
      v96 = vaddq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v94.f32, 1));
      _Q3 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 2), v96);
      _Q0.f32[0] = fmaxf(v95, fmaxf(*(float *)v91.i32, _Q0.f32[0]));
      __asm { FMLA            S3, S0, V2.S[3] }
      v98 = fmaxf(fabsf(*(float *)_Q3.i32), 0.000061035);
      _Q2.i64[0] = 0x8000000080000000;
      _Q2.i64[1] = 0x8000000080000000;
      v96.i32[0] = 1.0;
      LODWORD(v99) = vbslq_s8((int8x16_t)_Q2, (int8x16_t)v96, _Q3).u32[0];
      if (*(float *)_Q3.i32 == 0.0)
        v99 = 0.0;
      v2.i64[0] = vmulq_n_f32(v120, *(float *)(a1 + 40) * (float)(v99 * powf(v98, *(float *)(a1 + 44)))).u64[0];
      break;
    default:
      return *(double *)v2.i64;
  }
  return *(double *)v2.i64;
}

double xdr::apply_tone_mapping(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float32x4_t v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v24;
  float v25;
  int8x16_t v26;
  float32_t v27;
  float v28;
  float v29;
  float v30;
  float32x4_t v31;
  simd_float4 v33;
  float32x4_t v34;
  int32x4_t v35;
  float32x4_t v36;
  simd_float4 v37;
  simd_float4 v38;
  float32x4_t v39;
  unsigned int v40;
  int32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float v45;
  float v46;
  float v47;
  float v48;
  unsigned __int16 *v49;
  float v53;
  double v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  int8x16_t v63;
  float32x4_t v64;
  float v65;
  int32x2_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float v69;
  float32x4_t v70;
  float32x4_t v71;
  uint64_t v72;
  int v73;

  v2 = a2;
  switch(*(_DWORD *)a1)
  {
    case 1:
      v3 = *(float *)(a1 + 16);
      v4 = *(float *)(a1 + 20);
      v5 = *(float *)(a1 + 24);
      v6 = *(float *)(a1 + 28);
      v7 = *(float *)(a1 + 32);
      v8 = *(float *)(a1 + 36);
      v9 = *(float *)(a1 + 40);
      v10 = vmulq_f32(*(float32x4_t *)(a1 + 48), a2);
      v65 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0];
      v67 = v2;
      v11 = powf(fminf(fmaxf(v65 / v9, 0.0), 1.0), 0.1593);
      v12 = (float)((float)(v11 * 18.852) + 0.83594) / ((float)(v11 * 18.688) + 1.0);
      v13 = powf(v12, 78.844);
      v14 = xdr::pq_eetf<float>(v13, v4, v3, v6, v5, v7, v8);
      v15 = 1.0;
      if (v65 > 0.0)
      {
        v16 = powf(v14, 0.012683);
        v15 = (float)(v9 * powf(fmaxf(v16 + -0.83594, 0.0) / (float)((float)(v16 * -18.688) + 18.852), 6.2774)) / v65;
      }
      v2.i64[0] = vmulq_n_f32(v67, v15).u64[0];
      break;
    case 2:
      _Q0 = *(float32x4_t *)(a1 + 48);
      _Q1 = vmulq_f32(_Q0, v2);
      _Q2 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)_Q1, 2), vaddq_f32(_Q1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.f32, 1)));
      v68 = v2;
      _Q1.f32[0] = fmaxf(v2.f32[0], fmaxf(v2.f32[1], v2.f32[2]));
      __asm { FMLA            S2, S1, V0.S[3] }
      v24 = *(float *)(a1 + 40);
      v25 = fmaxf(fabsf(*(float *)_Q2.i32), 0.000061035);
      v2.i32[0] = 1.0;
      v26.i64[0] = 0x8000000080000000;
      v26.i64[1] = 0x8000000080000000;
      v2.i32[0] = vbslq_s8(v26, (int8x16_t)v2, _Q2).u32[0];
      if (*(float *)_Q2.i32 == 0.0)
        v2.f32[0] = 0.0;
      v27 = v2.f32[0];
      v28 = powf(v25, *(float *)(a1 + 44));
      v2 = v68;
      v29 = v24 * (float)(v27 * v28);
      goto LABEL_19;
    case 3:
      LODWORD(v30) = HIDWORD(*(_QWORD *)(a1 + 28));
      v66 = *(int32x2_t *)(a1 + 28);
      LODWORD(v69) = *(_QWORD *)(a1 + 36);
      v31 = vsubq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 16), 0));
      v31.i32[3] = 0;
      v60 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0);
      v61 = vmulq_n_f32(vmaxnmq_f32(v31, (float32x4_t)0), COERCE_FLOAT(*(_QWORD *)(a1 + 20)));
      __asm { FMOV            V0.4S, #1.0 }
      v63 = (int8x16_t)_Q0;
      v33 = (simd_float4)vmlaq_n_f32(_Q0, vsubq_f32(v61, v60), *(float *)v66.i32);
      v33.i32[3] = 0;
      v34 = (float32x4_t)_simd_log_f4(v33);
      v35 = vcgtq_f32(v61, v60);
      v35.i32[3] = 0;
      v62 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v35), (int8x16_t)vaddq_f32(v60, vdivq_f32(v34, (float32x4_t)vdupq_lane_s32(v66, 0))), (int8x16_t)v61);
      v36 = vabsq_f32(v62);
      v36.i32[3] = 0;
      v37 = (simd_float4)vmaxnmq_f32(v36, (float32x4_t)xmmword_18820C0B0);
      v35.i64[0] = 0x8000000080000000;
      v35.i64[1] = 0x8000000080000000;
      v64 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v62), (int8x16_t)vcgtzq_f32(v62)), vorrq_s8(vandq_s8((int8x16_t)v62, (int8x16_t)v35), v63), (int8x16_t)0);
      v37.i32[3] = 0;
      v38 = (simd_float4)vdupq_lane_s32(v66, 1);
      v38.i32[3] = 0;
      v39 = (float32x4_t)_simd_pow_f4(v37, v38);
      if (v30 == 1.0)
        v40 = 0;
      else
        v40 = -1;
      v41 = vdupq_n_s32(v40);
      v41.i32[3] = 0;
      v42 = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v41), (int8x16_t)vmulq_f32(v39, v64), (int8x16_t)v62), v69);
      v42.i32[3] = 0;
      v43 = vmaxnmq_f32(v42, (float32x4_t)0);
      v43.i32[3] = 0;
      v2.i64[0] = vminnmq_f32(v43, (float32x4_t)xmmword_18820C060).u64[0];
      break;
    case 4:
      if (!*(_BYTE *)(a1 + 112))
        v2 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 64), a2.f32[0]), *(float32x4_t *)(a1 + 80), *(float32x2_t *)a2.f32, 1), *(float32x4_t *)(a1 + 96), a2, 2);
      v44 = vmulq_n_f32(v2, COERCE_FLOAT(*(_QWORD *)(a1 + 36)));
      v45 = fmaxf(v44.f32[0], fmaxf(v44.f32[1], v44.f32[2]));
      if (v45 >= 1.0)
      {
        v55 = *(float *)(a1 + 52);
        v56 = *(float *)(a1 + 48);
        v57 = v45 * *(float *)(a1 + 56);
        v71 = v44;
        v58 = xdr::rw_spline<float>((float *)(a1 + 16), v45);
        v44 = v71;
        if (v56 < v45)
          v58 = v55;
        if (v45 < 1.0)
          v58 = v57;
        v46 = v58 / v45;
      }
      else
      {
        v46 = *(float *)(a1 + 56);
      }
      v2.i64[0] = vmulq_n_f32(v44, v46).u64[0];
      break;
    case 5:
      if (!*(_BYTE *)(a1 + 112))
        v2 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 64), a2.f32[0]), *(float32x4_t *)(a1 + 80), *(float32x2_t *)a2.f32, 1), *(float32x4_t *)(a1 + 96), a2, 2);
      v70 = v2;
      v47 = v2.f32[2];
      v48 = v2.f32[1];
      v49 = *(unsigned __int16 **)(a1 + 128);
      _Q3 = *(_OWORD *)(a1 + 48);
      _S1 = fmaxf(v70.f32[0], fmaxf(v48, v47));
      __asm { FMLA            S0, S1, V3.S[3] }
      v53 = *(float *)(a1 + 40);
      v73 = 1;
      v72 = 0x100000000;
      v54 = xdr::Texture<unsigned short,float,int>::sample(v49, &v72, 0, _S0, _S1);
      v2 = v70;
      v29 = v53 * *(float *)&v54;
LABEL_19:
      v2.i64[0] = vmulq_n_f32(v2, v29).u64[0];
      break;
    default:
      return *(double *)v2.i64;
  }
  return *(double *)v2.i64;
}

float xdr::pq_eetf<float>(float a1, float a2, float a3, float a4, float a5, float a6, float a7)
{
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;

  v7 = a3 - a2;
  v8 = (float)(a1 - a2) / v7;
  v9 = (float)(v8 - a6) * a7;
  v10 = (1.0 - a6) * ((float)(v9 * (float)(v9 * v9)) + (float)(v9 * v9) * -2.0 + v9)
      + (1.0 - ((float)(v9 * v9) * 3.0 - (float)(v9 * (float)(v9 * v9)) * 2.0)) * a6
      + ((float)(v9 * v9) * 3.0 + (float)(v9 * (float)(v9 * v9)) * -2.0) * a5;
  if (v8 > a6)
    v8 = v10;
  v11 = (1.0 - v8) * (1.0 - v8);
  v12 = v8 + (float)(a4 * (float)(v11 * v11));
  if (v8 > 1.0)
    v12 = v8;
  if (v8 <= 0.0)
    v13 = a4;
  else
    v13 = v12;
  return a2 + (float)(v13 * v7);
}

float xdr::rw_spline<float>(float *a1, float a2)
{
  float v2;
  float v3;

  v2 = (a2 + -1.0) * a1[4];
  v3 = a1[3] * (float)(a1[2] + sqrtf(a1[1] + (float)(*a1 * a2)));
  if (*a1 == 0.0)
    v3 = v2;
  return (float)(a1[10] * (float)((float)(1.0 - v3) * (float)(1.0 - v3))) + (v3 + (float)(1.0 - v3) * 2.0) * a1[9] * v3;
}

uint64_t ___ZN3xdr36dispatch_convert_image_to_image_loopILt2ELt1EEEvRKNS_7imageInERKNS_8imageOutERKNS_16colorTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(uint64_t result, unsigned int a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t *v8;
  int8x16_t v9;
  __int128 v10;
  uint16x4_t v11;
  __int128 v12;
  int32x2_t v13;
  int8x16_t v14;
  __int32 v15;
  __int32 v16;
  __int32 v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v18 = 0x100000000;
  v19 = 1;
  if (*(_WORD *)(result + 80))
  {
    v3 = result;
    v4 = 0;
    do
    {
      HIWORD(v15) = a2;
      LOWORD(v15) = v4;
      v5 = *(_QWORD *)(v3 + 48);
      v6 = *(_QWORD *)(v3 + 56);
      v7 = *(float32x4_t **)(v3 + 64);
      v8 = *(float32x4_t **)(v3 + 72);
      v9 = *(int8x16_t *)(v3 + 32);
      v20 = 0u;
      v21 = 0u;
      v13 = (int32x2_t)vshl_u32((uint32x2_t)__PAIR64__(a2, v4), (uint32x2_t)1);
      v14 = v9;
      HIWORD(v17) = v13.i16[2];
      LOWORD(v17) = v13.i16[0];
      *(double *)&v10 = xdr::convert_image_to_image(v5, v7, v8, v17, &v18, v9, (uint16x4_t)v13);
      v20 = v10;
      *(int32x2_t *)&v10 = vadd_s32(v13, (int32x2_t)1);
      HIWORD(v16) = WORD2(v10);
      LOWORD(v16) = v10;
      *(double *)&v12 = xdr::convert_image_to_image(v5, v7, v8, v16, &v18, v14, v11);
      v21 = v12;
      result = xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(v6, (uint64_t)&v20, v15, *(uint16x4_t *)&v12);
      ++v4;
    }
    while (*(unsigned __int16 *)(v3 + 80) > (unsigned __int16)v4);
  }
  return result;
}

uint64_t xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(uint64_t result, uint64_t a2, __int32 a3, uint16x4_t a4)
{
  float32x4_t *v5;
  uint32x2_t v6;
  int v7;
  uint64_t v8;
  int32x2_t v9;
  char v10;
  char v11;
  __n128 v12;
  int32x2_t v13;
  int16x4_t v14;
  uint16x4_t v15;
  uint16x4_t v16;
  uint16x4_t v17;
  uint64_t v18;
  int32x2_t v19;
  char v20;
  char v21;
  int32x2_t v22;
  __n128 v23;
  uint64_t v24;
  int32x2_t v25;
  float32x2_t v26;
  char v27;
  char v28;
  int8x16_t v29;
  int32x2_t v30;
  __n128 v31;
  uint32x2_t v32;
  int8x16_t v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;

  v5 = (float32x4_t *)result;
  a4.i32[0] = a3;
  v6 = (uint32x2_t)vmovl_u16(a4).u64[0];
  v7 = *(_DWORD *)(result + 16);
  if (v7 == 3)
  {
LABEL_4:
    if (*(_WORD *)(result + 112) == 1)
    {
      v8 = 0;
      v9 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
      v10 = 1;
      do
      {
        v11 = v10;
        v12 = (__n128)vmlaq_f32(v5[3], *(float32x4_t *)(a2 + 16 * v8), v5[2]);
        v12.n128_u32[3] = 1.0;
        v13 = vadd_s32((int32x2_t)v8, v9);
        HIWORD(v34) = v13.i16[2];
        LOWORD(v34) = v13.i16[0];
        result = (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v34, v12);
        v10 = 0;
        v8 = 1;
      }
      while ((v11 & 1) != 0);
    }
    return result;
  }
  if (v7 != 2)
  {
    if (v7 != 1)
      return result;
    goto LABEL_4;
  }
  v14 = *(int16x4_t *)(result + 112);
  v15 = (uint16x4_t)vceq_s16(v14, (int16x4_t)0x200020001);
  v15.i16[3] = v15.i16[2];
  if ((vminv_u16(v15) & 0x8000) == 0)
  {
    v16 = (uint16x4_t)vceq_s16(v14, (int16x4_t)0x100020001);
    v16.i16[3] = v16.i16[2];
    if ((vminv_u16(v16) & 0x8000) != 0)
    {
      v24 = 0;
      v25 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
      v6.i32[0] = a3;
      v32 = v6;
      v26 = 0;
      v27 = 1;
      do
      {
        v28 = v27;
        v29 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], COERCE_FLOAT(*(_OWORD *)(a2 + 16 * v24))), v5[5], *(float32x2_t *)(a2 + 16 * v24), 1), v5[6], *(float32x4_t *)(a2 + 16 * v24), 2), v5[2]);
        v26 = vadd_f32(v26, (float32x2_t)*(_OWORD *)&vextq_s8(v29, v29, 4uLL));
        v30 = vadd_s32((int32x2_t)v24, v25);
        HIWORD(v37) = v30.i16[2];
        LOWORD(v37) = v30.i16[0];
        (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v37, *(float *)v29.i32);
        v27 = 0;
        v24 = 1;
      }
      while ((v28 & 1) != 0);
      HIWORD(v36) = v32.i16[2];
      LOWORD(v36) = v32.i16[0];
      v31.n128_u64[0] = (unint64_t)vmul_f32(v26, (float32x2_t)0x3F0000003F000000);
      v31.n128_u64[1] = 0x3F80000000000000;
      return (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[1] + 24))(v5->i64[1], v36, v31);
    }
    else
    {
      v17 = (uint16x4_t)vceq_s16(v14, (int16x4_t)0x1000100010001);
      v17.i16[3] = v17.i16[2];
      if ((vminv_u16(v17) & 0x8000) != 0)
      {
        v18 = 0;
        v19 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
        v20 = 1;
        do
        {
          v21 = v20;
          v33 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], COERCE_FLOAT(*(_OWORD *)(a2 + 16 * v18))), v5[5], *(float32x2_t *)(a2 + 16 * v18), 1), v5[6], *(float32x4_t *)(a2 + 16 * v18), 2), v5[2]);
          v22 = vadd_s32((int32x2_t)v18, v19);
          HIWORD(v35) = v22.i16[2];
          LOWORD(v35) = v22.i16[0];
          (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v35, *(float *)v33.i32);
          v23.n128_u64[0] = vextq_s8(v33, v33, 4uLL).u64[0];
          v23.n128_u64[1] = 0x3F80000000000000;
          result = (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[1] + 24))(v5->i64[1], v35, v23);
          v20 = 0;
          v18 = 1;
        }
        while ((v21 & 1) != 0);
      }
    }
  }
  return result;
}

float32x4_t *xdr::convert_image_to_image_loop<(unsigned short)2,(unsigned short)2>(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, uint64_t a5, _DWORD *a6, int8x16_t a7)
{
  uint64_t v13;
  int32x2_t v14;
  uint16x4_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  __int128 v19;
  _OWORD *v20;
  uint16x4_t v21;
  __int128 v22;
  int8x16_t v24;
  __int32 v25;
  __int32 v26;
  _OWORD v27[4];
  uint64_t v28;

  v24 = a7;
  v13 = 0;
  v28 = *MEMORY[0x1E0C80C00];
  a7.i32[0] = a5;
  v14 = (int32x2_t)vmovl_u16(*(uint16x4_t *)a7.i8).u64[0];
  v15 = 0;
  memset(v27, 0, sizeof(v27));
  v16 = vadd_s32(v14, v14);
  do
  {
    v17.i32[0] = 0;
    v17.i32[1] = v13;
    v18 = vadd_s32(v16, v17);
    HIWORD(v26) = v18.i16[2];
    LOWORD(v26) = v18.i16[0];
    *(double *)&v19 = xdr::convert_image_to_image(a1, a3, a4, v26, a6, v24, v15);
    v20 = &v27[v13];
    *v20 = v19;
    *(int32x2_t *)&v19 = vadd_s32((int32x2_t)__PAIR64__(v13, 1), v16);
    HIWORD(v25) = WORD2(v19);
    LOWORD(v25) = v19;
    *(double *)&v22 = xdr::convert_image_to_image(a1, a3, a4, v25, a6, v24, v21);
    v20[2] = v22;
    ++v13;
  }
  while (v13 != 2);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a2, (uint64_t)v27, a5, *(uint16x4_t *)&v22);
}

float32x4_t *xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(float32x4_t *result, uint64_t a2, uint64_t a3, uint16x4_t a4)
{
  float32x4_t *v6;
  int32x2_t v7;
  __int32 v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  char v12;
  char v13;
  __n128 v19;
  uint64_t v20;
  int16x4_t v21;
  uint16x4_t v22;
  uint16x4_t v23;
  uint16x4_t v24;
  uint16x4_t v25;
  uint64_t v26;
  float32x4_t v27;
  char v28;
  uint64_t v29;
  char v30;
  char v31;
  char v32;
  float32x4_t v33;
  __n128 v34;
  uint64_t v36;
  int8x8_t v37;
  char v38;
  float v39;
  uint64_t v40;
  char v41;
  char v42;
  char v43;
  __n128 v44;
  int8x8_t v45;
  uint64_t v46;
  int8x8_t v47;
  float32x2_t v48;
  char v49;
  uint64_t v50;
  char v51;
  char v52;
  char v53;
  float32x4_t v54;
  int8x16_t v55;
  int8x8_t v56;
  uint64_t v58;
  int8x8_t v59;
  __int16 v60;
  char v61;
  uint64_t v62;
  char v63;
  float32x2_t v64;
  char v65;
  char v66;
  float32x4_t v67;
  int8x16_t v68;
  int8x8_t v69;
  __n128 v70;
  uint64_t v71;
  int8x8_t v72;
  char v73;
  uint64_t v74;
  char v75;
  char v76;
  char v77;
  float32x4_t v78;
  int8x8_t v79;
  __n128 v80;
  unsigned __int16 v81;
  int8x16_t v82;
  int8x16_t v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;

  v6 = result;
  a4.i32[0] = a3;
  v7 = (int32x2_t)vmovl_u16(a4).u64[0];
  v8 = result[1].i32[0];
  if (v8 != 3)
  {
    if (v8 == 2)
    {
      v21 = *(int16x4_t *)result[7].f32;
      v22 = (uint16x4_t)vceq_s16(v21, (int16x4_t)0x200020001);
      v22.i16[3] = v22.i16[2];
      if ((vminv_u16(v22) & 0x8000) != 0)
      {
        v46 = 0;
        v47 = (int8x8_t)vadd_s32(v7, v7);
        v48 = 0;
        v49 = 1;
        do
        {
          v50 = 0;
          v51 = v49;
          v52 = 1;
          do
          {
            v53 = v52;
            v54 = *(float32x4_t *)(a2 + 32 * v50 + 16 * v46);
            v55 = (int8x16_t)vmlaq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6[4], v54.f32[0]), v6[5], *(float32x2_t *)v54.f32, 1), v6[6], v54, 2), v6[2]);
            v48 = vadd_f32(v48, (float32x2_t)*(_OWORD *)&vextq_s8(v55, v55, 4uLL));
            v56 = vorr_s8((int8x8_t)__PAIR64__(v46, v50), v47);
            HIWORD(v88) = v56.i16[2];
            LOWORD(v88) = v56.i16[0];
            (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v88, *(float *)v55.i32);
            v52 = 0;
            v50 = 1;
          }
          while ((v53 & 1) != 0);
          v49 = 0;
          v46 = 1;
        }
        while ((v51 & 1) != 0);
        __asm { FMOV            V0.2S, #0.25 }
        v19.n128_u64[0] = (unint64_t)vmul_f32(v48, _D0);
      }
      else
      {
        v23 = (uint16x4_t)vceq_s16(v21, (int16x4_t)0x100020001);
        v23.i16[3] = v23.i16[2];
        if ((vminv_u16(v23) & 0x8000) != 0)
        {
          v58 = 0;
          v59 = (int8x8_t)vadd_s32(v7, v7);
          v21.i32[0] = a3;
          v81 = vmovl_u16((uint16x4_t)v21).u16[0];
          v60 = 2 * v7.i16[2];
          v61 = 1;
          do
          {
            v62 = 0;
            v63 = v61;
            v64 = 0;
            v65 = 1;
            do
            {
              v66 = v65;
              v67 = *(float32x4_t *)(a2 + 32 * v62 + 16 * v58);
              v68 = (int8x16_t)vmlaq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6[4], v67.f32[0]), v6[5], *(float32x2_t *)v67.f32, 1), v6[6], v67, 2), v6[2]);
              v64 = vadd_f32(v64, (float32x2_t)*(_OWORD *)&vextq_s8(v68, v68, 4uLL));
              v69 = vorr_s8((int8x8_t)__PAIR64__(v58, v62), v59);
              HIWORD(v87) = v69.i16[2];
              LOWORD(v87) = v69.i16[0];
              (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v87, *(float *)v68.i32);
              v65 = 0;
              v62 = 1;
            }
            while ((v66 & 1) != 0);
            v70.n128_u64[0] = (unint64_t)vmul_f32(v64, (float32x2_t)0x3F0000003F000000);
            v70.n128_u64[1] = 0x3F80000000000000;
            HIWORD(v86) = v60 | v58;
            LOWORD(v86) = v81;
            result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[1] + 24))(v6->i64[1], v86, v70);
            v61 = 0;
            v58 = 1;
          }
          while ((v63 & 1) != 0);
          return result;
        }
        v24 = (uint16x4_t)vceq_s16(v21, (int16x4_t)0x1000100010001);
        v24.i16[3] = v24.i16[2];
        if ((vminv_u16(v24) & 0x8000) != 0)
        {
          v71 = 0;
          v72 = (int8x8_t)vadd_s32(v7, v7);
          v73 = 1;
          do
          {
            v74 = 0;
            v75 = v73;
            v76 = 1;
            do
            {
              v77 = v76;
              v78 = *(float32x4_t *)(a2 + 32 * v74 + 16 * v71);
              v83 = (int8x16_t)vmlaq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6[4], v78.f32[0]), v6[5], *(float32x2_t *)v78.f32, 1), v6[6], v78, 2), v6[2]);
              v79 = vorr_s8((int8x8_t)__PAIR64__(v71, v74), v72);
              HIWORD(v85) = v79.i16[2];
              LOWORD(v85) = v79.i16[0];
              (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v85, *(float *)v83.i32);
              v80.n128_u64[0] = vextq_s8(v83, v83, 4uLL).u64[0];
              v80.n128_u64[1] = 0x3F80000000000000;
              result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[1] + 24))(v6->i64[1], v85, v80);
              v76 = 0;
              v74 = 1;
            }
            while ((v77 & 1) != 0);
            v73 = 0;
            v71 = 1;
          }
          while ((v75 & 1) != 0);
          return result;
        }
        v25 = (uint16x4_t)vceq_s16(v21, (int16x4_t)0x2000200020002);
        v25.i16[3] = v25.i16[2];
        if ((vminv_u16(v25) & 0x8000) == 0)
          return result;
        v26 = 0;
        v27 = 0uLL;
        v28 = 1;
        do
        {
          v29 = 0;
          v30 = v28;
          v31 = 1;
          do
          {
            v32 = v31;
            v33 = *(float32x4_t *)(a2 + 32 * v29 + 16 * v26);
            v27 = vaddq_f32(v27, vmlaq_f32(result[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(result[4], v33.f32[0]), result[5], *(float32x2_t *)v33.f32, 1), result[6], v33, 2), result[2]));
            v29 = 1;
            v31 = 0;
          }
          while ((v32 & 1) != 0);
          v28 = 0;
          v26 = 1;
        }
        while ((v30 & 1) != 0);
        v34.n128_f32[0] = 0.25 * v27.f32[0];
        v34.n128_u32[1] = 0;
        v34.n128_u32[2] = 0;
        v34.n128_u32[3] = 1.0;
        v82 = (int8x16_t)v27;
        (*(void (**)(__n128))(*(_QWORD *)result->i64[0] + 24))(v34);
        __asm { FMOV            V1.2S, #0.25 }
        v19.n128_u64[0] = (unint64_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v82, v82, 4uLL), _D1);
      }
      v19.n128_u64[1] = 0x3F80000000000000;
      v20 = v6->i64[1];
      return (float32x4_t *)(*(uint64_t (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v20 + 24))(v20, a3, v19);
    }
    if (v8 != 1)
      return result;
  }
  v9 = result[7].u16[0];
  if (v9 != 1)
  {
    if (v9 != 2)
      return result;
    v10 = 0;
    v11 = 0uLL;
    v12 = 1;
    do
    {
      v13 = v12;
      v11 = vaddq_f32(vaddq_f32(v11, *(float32x4_t *)(a2 + 16 * v10)), *(float32x4_t *)(a2 + 16 * v10 + 32));
      v10 = 1;
      v12 = 0;
    }
    while ((v13 & 1) != 0);
    __asm { FMOV            V1.4S, #0.25 }
    v19 = (__n128)vmlaq_f32(result[3], vmulq_f32(v11, _Q1), result[2]);
    v19.n128_u32[3] = 1.0;
    v20 = result->i64[0];
    return (float32x4_t *)(*(uint64_t (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v20 + 24))(v20, a3, v19);
  }
  v36 = 0;
  v37 = (int8x8_t)vadd_s32(v7, v7);
  v38 = 1;
  v39 = 1.0;
  do
  {
    v40 = 0;
    v41 = v38;
    v42 = 1;
    do
    {
      v43 = v42;
      v44 = (__n128)vmlaq_f32(v6[3], *(float32x4_t *)(a2 + 32 * v40 + 16 * v36), v6[2]);
      v44.n128_f32[3] = v39;
      v45 = vorr_s8((int8x8_t)__PAIR64__(v36, v40), v37);
      HIWORD(v84) = v45.i16[2];
      LOWORD(v84) = v45.i16[0];
      result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v84, v44);
      v39 = 1.0;
      v42 = 0;
      v40 = 1;
    }
    while ((v43 & 1) != 0);
    v38 = 0;
    v36 = 1;
  }
  while ((v41 & 1) != 0);
  return result;
}

void ___ZN3xdr44dispatch_convert_gainmap_image_to_image_loopILt1ELt1EEEvRKNS_7imageInES3_RKNS_8imageOutERKNS_16colorTransformInERKNS_15gainTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(uint64_t a1, __int16 a2, double a3, uint16x4_t a4)
{
  int v6;
  float32x4_t *v7;
  float32x4_t v8;
  unsigned __int32 v9;
  uint64_t v10;
  int v11;
  float32x4_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0x100000000;
  v11 = 1;
  if (*(_WORD *)(a1 + 96))
  {
    v6 = 0;
    do
    {
      HIWORD(v9) = a2;
      LOWORD(v9) = v6;
      v7 = *(float32x4_t **)(a1 + 64);
      *(double *)v8.i64 = xdr::convert_gainmap_image_to_image(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(float32x4_t **)(a1 + 72), *(float32x4_t **)(a1 + 80), *(float32x4_t **)(a1 + 88), v9, &v10, *(int8x16_t *)(a1 + 32), a4);
      v12 = v8;
      xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v7, &v12, v9, *(int16x4_t *)v8.f32);
      ++v6;
    }
    while (*(unsigned __int16 *)(a1 + 96) > (unsigned __int16)v6);
  }
}

double xdr::convert_gainmap_image_to_image(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, __int32 a6, _DWORD *a7, int8x16_t a8, uint16x4_t a9)
{
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v21;
  double v22;
  float32x4_t v23;

  a9.i32[0] = a6;
  v22 = COERCE_DOUBLE(vmla_f32((float32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL), vadd_f32((float32x2_t)vorr_s8((int8x8_t)*(_OWORD *)&vmovl_u16(a9), (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), *(float32x2_t *)a8.i8));
  xdr::image_sample(a1, a7, v22);
  v21 = v14;
  xdr::image_sample(a2, a7, v22);
  v23 = v15;
  *(double *)v16.i64 = xdr::apply_color_trc((uint64_t)a3, v21);
  *(double *)v17.i64 = xdr::apply_tone_mapping((uint64_t)&a3[5], v16);
  if (!a3[17].i8[0])
    v17 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3[14], v17.f32[0]), a3[15], *(float32x2_t *)v17.f32, 1), a3[16], v17, 2);
  *(double *)v18.i64 = xdr::apply_gain_mapping((uint64_t)a4, v17, v23);
  if (!a4[10].i8[0])
    v18 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a4[7], v18.f32[0]), a4[8], *(float32x2_t *)v18.f32, 1), a4[9], v18, 2);
  if (!a5[3].i8[0])
    v18 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a5, v18.f32[0]), a5[1], *(float32x2_t *)v18.f32, 1), a5[2], v18, 2);
  *(double *)v19.i64 = xdr::apply_tone_mapping((uint64_t)&a5[4], v18);
  return xdr::apply_color_trc((uint64_t)&a5[13], v19);
}

double xdr::apply_gain_mapping(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  unint64_t v3;
  simd_float4 v5;
  float32x4_t v6;
  simd_float4 v7;
  int8x16_t v8;
  simd_float4 v14;
  float32x4_t v15;
  simd_float4 v16;
  int8x16_t v17;
  simd_float4 v19;

  v3 = a2.i64[0];
  if (*(_DWORD *)a1 == 2)
  {
    v14 = *(simd_float4 *)(a1 + 16);
    v15 = vabsq_f32(a3);
    v15.i32[3] = 0;
    v16 = (simd_float4)vmaxnmq_f32(v15, (float32x4_t)xmmword_18820C0B0);
    v17.i64[0] = 0x8000000080000000;
    v17.i64[1] = 0x8000000080000000;
    __asm { FMOV            V4.4S, #1.0 }
    v16.i32[3] = 0;
    v14.i32[3] = 0;
    v19 = (simd_float4)vmulq_f32(*(float32x4_t *)(a1 + 96), vmlaq_f32(*(float32x4_t *)(a1 + 48), vmulq_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgtzq_f32(a3)), vorrq_s8(vandq_s8((int8x16_t)a3, v17), _Q4), (int8x16_t)0), (float32x4_t)_simd_pow_f4(v16, v14)), *(float32x4_t *)(a1 + 32)));
    v19.i32[3] = 0;
    v3 = vmlaq_f32(vnegq_f32(*(float32x4_t *)(a1 + 80)), vaddq_f32(*(float32x4_t *)(a1 + 64), a2), (float32x4_t)_simd_exp2_f4(v19)).u64[0];
  }
  else if (*(_DWORD *)a1 == 1)
  {
    v5 = *(simd_float4 *)(a1 + 16);
    v6 = vabsq_f32(a3);
    v6.i32[3] = 0;
    v7 = (simd_float4)vmaxnmq_f32(v6, (float32x4_t)xmmword_18820C0B0);
    v8.i64[0] = 0x8000000080000000;
    v8.i64[1] = 0x8000000080000000;
    __asm { FMOV            V4.4S, #1.0 }
    v7.i32[3] = 0;
    v5.i32[3] = 0;
    v3 = vmulq_f32(a2, vmlaq_f32(*(float32x4_t *)(a1 + 48), vmulq_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgtzq_f32(a3)), vorrq_s8(vandq_s8((int8x16_t)a3, v8), _Q4), (int8x16_t)0), (float32x4_t)_simd_pow_f4(v7, v5)), *(float32x4_t *)(a1 + 32))).u64[0];
  }
  return *(double *)&v3;
}

uint64_t ___ZN3xdr44dispatch_convert_gainmap_image_to_image_loopILt2ELt1EEEvRKNS_7imageInES3_RKNS_8imageOutERKNS_16colorTransformInERKNS_15gainTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(uint64_t result, unsigned int a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float32x4_t *v8;
  float32x4_t *v9;
  float32x4_t *v10;
  int8x16_t v11;
  __int128 v12;
  uint16x4_t v13;
  __int128 v14;
  int32x2_t v15;
  int8x16_t v16;
  __int32 v17;
  __int32 v18;
  __int32 v19;
  uint64_t v20;
  int v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v20 = 0x100000000;
  v21 = 1;
  if (*(_WORD *)(result + 96))
  {
    v3 = result;
    v4 = 0;
    do
    {
      HIWORD(v17) = a2;
      LOWORD(v17) = v4;
      v5 = *(_QWORD *)(v3 + 48);
      v6 = *(_QWORD *)(v3 + 56);
      v7 = *(_QWORD *)(v3 + 64);
      v8 = *(float32x4_t **)(v3 + 72);
      v9 = *(float32x4_t **)(v3 + 80);
      v10 = *(float32x4_t **)(v3 + 88);
      v11 = *(int8x16_t *)(v3 + 32);
      v22 = 0u;
      v23 = 0u;
      v15 = (int32x2_t)vshl_u32((uint32x2_t)__PAIR64__(a2, v4), (uint32x2_t)1);
      v16 = v11;
      HIWORD(v19) = v15.i16[2];
      LOWORD(v19) = v15.i16[0];
      *(double *)&v12 = xdr::convert_gainmap_image_to_image(v5, v6, v8, v9, v10, v19, &v20, v11, (uint16x4_t)v15);
      v22 = v12;
      *(int32x2_t *)&v12 = vadd_s32(v15, (int32x2_t)1);
      HIWORD(v18) = WORD2(v12);
      LOWORD(v18) = v12;
      *(double *)&v14 = xdr::convert_gainmap_image_to_image(v5, v6, v8, v9, v10, v18, &v20, v16, v13);
      v23 = v14;
      result = xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(v7, (uint64_t)&v22, v17, *(uint16x4_t *)&v14);
      ++v4;
    }
    while (*(unsigned __int16 *)(v3 + 96) > (unsigned __int16)v4);
  }
  return result;
}

float32x4_t *xdr::convert_gainmap_image_to_image_loop<(unsigned short)2,(unsigned short)2>(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, unsigned __int32 a7, _DWORD *a8, int8x16_t a9)
{
  uint64_t v15;
  int32x2_t v16;
  uint16x4_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  __int128 v21;
  _OWORD *v22;
  uint16x4_t v23;
  __int128 v24;
  int8x16_t v28;
  __int32 v29;
  __int32 v30;
  _OWORD v31[4];
  uint64_t v32;

  v28 = a9;
  v15 = 0;
  v32 = *MEMORY[0x1E0C80C00];
  a9.i32[0] = a7;
  v16 = (int32x2_t)vmovl_u16(*(uint16x4_t *)a9.i8).u64[0];
  v17 = 0;
  memset(v31, 0, sizeof(v31));
  v18 = vadd_s32(v16, v16);
  do
  {
    v19.i32[0] = 0;
    v19.i32[1] = v15;
    v20 = vadd_s32(v18, v19);
    HIWORD(v30) = v20.i16[2];
    LOWORD(v30) = v20.i16[0];
    *(double *)&v21 = xdr::convert_gainmap_image_to_image(a1, a2, a4, a5, a6, v30, a8, v28, v17);
    v22 = &v31[v15];
    *v22 = v21;
    *(int32x2_t *)&v21 = vadd_s32((int32x2_t)__PAIR64__(v15, 1), v18);
    HIWORD(v29) = WORD2(v21);
    LOWORD(v29) = v21;
    *(double *)&v24 = xdr::convert_gainmap_image_to_image(a1, a2, a4, a5, a6, v29, a8, v28, v23);
    v22[2] = v24;
    ++v15;
  }
  while (v15 != 2);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a3, (uint64_t)v31, a7, *(uint16x4_t *)&v24);
}

void ___ZN3xdr44dispatch_convert_image_to_gainmap_image_loopILt1ELt1EEEvRKNS_7imageInERKNS_8imageOutES6_RKNS_16colorTransformInES9_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t a1, __int16 a2, double a3, uint16x4_t a4)
{
  int v6;
  uint64_t v7;
  float32x4_t *v8;
  float32x4_t *v9;
  float32x4_t *v10;
  float32x4_t *v11;
  float32x4_t *v12;
  uint64_t v13;
  int8x16_t v14;
  float32x4_t v15;
  int16x4_t v16;
  unsigned __int32 v17;
  uint64_t v18;
  int v19;
  float32x4_t v20;
  float32x4_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v18 = 0x100000000;
  v19 = 1;
  if (*(_WORD *)(a1 + 104))
  {
    v6 = 0;
    do
    {
      HIWORD(v17) = a2;
      LOWORD(v17) = v6;
      v7 = *(_QWORD *)(a1 + 48);
      v8 = *(float32x4_t **)(a1 + 56);
      v10 = *(float32x4_t **)(a1 + 64);
      v9 = *(float32x4_t **)(a1 + 72);
      v11 = *(float32x4_t **)(a1 + 80);
      v12 = *(float32x4_t **)(a1 + 88);
      v13 = *(_QWORD *)(a1 + 96);
      v14 = *(int8x16_t *)(a1 + 32);
      v20 = 0uLL;
      *(double *)v15.i64 = xdr::convert_image_to_gainmap_image(v7, v9, v11, v12, v13, &v20, v17, &v18, v14, a4);
      v21 = v15;
      v16 = (int16x4_t)xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v8, &v21, v17, *(int16x4_t *)v15.f32);
      xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v10, &v20, v17, v16);
      ++v6;
    }
    while (*(unsigned __int16 *)(a1 + 104) > (unsigned __int16)v6);
  }
}

double xdr::convert_image_to_gainmap_image(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, uint64_t a5, _OWORD *a6, __int32 a7, _DWORD *a8, int8x16_t a9, uint16x4_t a10)
{
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  __int128 v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v25;
  float32x4_t v26;

  a10.i32[0] = a7;
  xdr::image_sample(a1, a8, COERCE_DOUBLE(vmla_f32((float32x2_t)*(_OWORD *)&vextq_s8(a9, a9, 8uLL), vadd_f32((float32x2_t)vorr_s8((int8x8_t)*(_OWORD *)&vmovl_u16(a10), (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), *(float32x2_t *)a9.i8)));
  v25 = v15;
  *(double *)v16.i64 = xdr::apply_color_trc((uint64_t)a2, v15);
  *(double *)v17.i64 = xdr::apply_tone_mapping((uint64_t)&a2[5], v16);
  if (!a2[17].i8[0])
    v17 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a2[14], v17.f32[0]), a2[15], *(float32x2_t *)v17.f32, 1), a2[16], v17, 2);
  v26 = v17;
  *(double *)v18.i64 = xdr::apply_color_trc((uint64_t)a3, v25);
  *(double *)v19.i64 = xdr::apply_tone_mapping((uint64_t)&a3[5], v18);
  v20 = v19;
  if (!a3[17].i8[0])
    v20 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3[14], v19.f32[0]), a3[15], *(float32x2_t *)v19.f32, 1), a3[16], v19, 2);
  *(double *)&v21 = xdr::apply_gain_transform(a5, v26, v20);
  *a6 = v21;
  if (a4[3].i8[0])
    v22 = v26;
  else
    v22 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a4, v26.f32[0]), a4[1], *(float32x2_t *)v26.f32, 1), a4[2], v26, 2);
  *(double *)v23.i64 = xdr::apply_tone_mapping((uint64_t)&a4[4], v22);
  return xdr::apply_color_trc((uint64_t)&a4[13], v23);
}

double xdr::apply_gain_transform(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int32x2_t v10;
  double v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  simd_float4 v18;
  simd_float4 v19;
  simd_float4 v20;
  int8x16_t v21;
  float32x4_t v22;
  simd_float4 v23;
  int8x16_t v24;

  if (!*(_BYTE *)(a1 + 160))
  {
    v5 = *(float32x4_t *)(a1 + 128);
    v4 = *(float32x4_t *)(a1 + 144);
    v6 = *(float32x4_t *)(a1 + 112);
    a2 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6, a2.f32[0]), v5, *(float32x2_t *)a2.f32, 1), v4, a2, 2);
    a3 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6, a3.f32[0]), v5, *(float32x2_t *)a3.f32, 1), v4, a3, 2);
  }
  if (*(_BYTE *)(a1 + 208))
  {
    v7 = *(float32x4_t *)(a1 + 192);
    a2.i32[3] = fmaxf(a2.f32[0], fmaxf(a2.f32[1], a2.f32[2]));
    v8 = (int8x16_t)vmulq_f32(a2, v7);
    *(float32x2_t *)v8.i8 = vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
    a3.i32[3] = fmaxf(a3.f32[0], fmaxf(a3.f32[1], a3.f32[2]));
    v9 = (int8x16_t)vmulq_f32(a3, v7);
    *(float32x2_t *)v9.i8 = vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
    a2 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1)), 0);
    a3 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1)), 0);
  }
  v10 = *(int32x2_t *)(a1 + 176);
  a2.i32[3] = 0;
  v11 = 0.0;
  v12 = vmaxnmq_f32(a2, (float32x4_t)0);
  v12.i32[3] = 0;
  v13 = (float32x4_t)vdupq_lane_s32(v10, 0);
  v13.i32[3] = 0;
  a3.i32[3] = 0;
  v14 = vmaxnmq_f32(a3, (float32x4_t)0);
  v14.i32[3] = 0;
  v15 = (float32x4_t)vdupq_lane_s32(v10, 1);
  v16 = vminnmq_f32(v12, v13);
  v15.i32[3] = 0;
  v17 = vminnmq_f32(v14, v15);
  if (*(_DWORD *)a1 == 2)
  {
    v19 = (simd_float4)vdivq_f32(vaddq_f32(v17, *(float32x4_t *)(a1 + 80)), vaddq_f32(v16, *(float32x4_t *)(a1 + 64)));
    v19.i32[3] = 0;
    v18 = _simd_log2_f4(v19);
    goto LABEL_9;
  }
  if (*(_DWORD *)a1 == 1)
  {
    v18 = (simd_float4)vdivq_f32(vaddq_f32(v17, *(float32x4_t *)(a1 + 64)), vaddq_f32(v16, *(float32x4_t *)(a1 + 64)));
LABEL_9:
    v20 = *(simd_float4 *)(a1 + 16);
    v21 = (int8x16_t)vmlaq_f32(*(float32x4_t *)(a1 + 48), (float32x4_t)v18, *(float32x4_t *)(a1 + 32));
    v22 = vabsq_f32((float32x4_t)v21);
    v22.i32[3] = 0;
    v23 = (simd_float4)vmaxnmq_f32(v22, (float32x4_t)xmmword_18820C0B0);
    v24.i64[0] = 0x8000000080000000;
    v24.i64[1] = 0x8000000080000000;
    __asm { FMOV            V4.4S, #1.0 }
    v23.i32[3] = 0;
    v20.i32[3] = 0;
    *(_QWORD *)&v11 = vmulq_f32((float32x4_t)_simd_pow_f4(v23, v20), (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)v21), (int8x16_t)vcgtzq_f32((float32x4_t)v21)), vorrq_s8(vandq_s8(v21, v24), _Q4), (int8x16_t)0)).u64[0];
  }
  return v11;
}

uint64_t ___ZN3xdr44dispatch_convert_image_to_gainmap_image_loopILt2ELt1EEEvRKNS_7imageInERKNS_8imageOutES6_RKNS_16colorTransformInES9_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v5;
  int v6;
  __int32 v7;
  uint64_t v8;
  int v9;

  v8 = 0x100000000;
  v9 = 1;
  if (*(_WORD *)(result + 104))
  {
    v5 = result;
    v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      result = xdr::convert_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)1>(*(_QWORD *)(v5 + 48), *(_QWORD *)(v5 + 56), *(_QWORD *)(v5 + 64), *(float32x4_t **)(v5 + 72), *(float32x4_t **)(v5 + 80), *(float32x4_t **)(v5 + 88), *(_QWORD *)(v5 + 96), v7, *(int8x16_t *)(v5 + 32), a4, &v8);
      ++v6;
    }
    while (*(unsigned __int16 *)(v5 + 104) > (unsigned __int16)v6);
  }
  return result;
}

uint64_t xdr::convert_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)1>(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, uint64_t a7, __int32 a8, int8x16_t a9, uint16x4_t a10, _DWORD *a11)
{
  __int128 v19;
  uint16x4_t v20;
  __int128 v21;
  uint16x4_t v22;
  int32x2_t v24;
  __int32 v26;
  __int32 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  a10.i32[0] = a8;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v24 = (int32x2_t)vshl_u32((uint32x2_t)*(_OWORD *)&vmovl_u16(a10), (uint32x2_t)1);
  HIWORD(v27) = v24.i16[2];
  LOWORD(v27) = v24.i16[0];
  *(double *)&v19 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, &v28, v27, a11, a9, (uint16x4_t)v24);
  v30 = v19;
  *(int32x2_t *)&v19 = vadd_s32(v24, (int32x2_t)1);
  HIWORD(v26) = WORD2(v19);
  LOWORD(v26) = v19;
  *(double *)&v21 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, &v29, v26, a11, a9, v20);
  v31 = v21;
  xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(a2, (uint64_t)&v30, a8, *(uint16x4_t *)&v21);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(a3, (uint64_t)&v28, a8, v22);
}

float32x4_t *xdr::convert_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)2>(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, uint64_t a7, unsigned __int32 a8, int8x16_t a9, _DWORD *a10)
{
  uint64_t v15;
  uint64_t v16;
  uint16x4_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  __int128 v22;
  int32x2_t v23;
  uint16x4_t v24;
  __int128 v25;
  uint16x4_t v26;
  int8x16_t v31;
  __int32 v32;
  __int32 v33;
  _OWORD v34[4];
  _OWORD v35[4];
  uint64_t v36;

  v31 = a9;
  v15 = 0;
  v16 = 0;
  v36 = *MEMORY[0x1E0C80C00];
  a9.i32[0] = a8;
  v17 = 0;
  memset(v35, 0, sizeof(v35));
  v18 = (int32x2_t)vmovl_u16(*(uint16x4_t *)a9.i8).u64[0];
  memset(v34, 0, sizeof(v34));
  v19 = vadd_s32(v18, v18);
  do
  {
    v20.i32[0] = 0;
    v20.i32[1] = v16;
    v21 = vadd_s32(v19, v20);
    HIWORD(v33) = v21.i16[2];
    LOWORD(v33) = v21.i16[0];
    *(double *)&v22 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, &v34[v15], v33, a10, v31, v17);
    v23.i32[1] = v16;
    v23.i32[0] = 1;
    v24 = (uint16x4_t)vadd_s32(v23, v19);
    v35[v15] = v22;
    HIWORD(v32) = v24.i16[2];
    LOWORD(v32) = v24.i16[0];
    *(double *)&v25 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, &v34[v15 + 2], v32, a10, v31, v24);
    v35[v15 + 2] = v25;
    ++v16;
    ++v15;
  }
  while (v16 != 2);
  xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a2, (uint64_t)v35, a8, *(uint16x4_t *)&v25);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a3, (uint64_t)v34, a8, v26);
}

uint64_t ___ZN3xdr44dispatch_convert_image_to_gainmap_image_loopILt4ELt2EEEvRKNS_7imageInERKNS_8imageOutES6_RKNS_16colorTransformInES9_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v5;
  int v6;
  __int32 v7;
  uint64_t v8;
  int v9;

  v8 = 0x100000000;
  v9 = 1;
  if (*(_WORD *)(result + 104))
  {
    v5 = result;
    v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      result = xdr::convert_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)2>(*(_QWORD *)(v5 + 48), *(_QWORD *)(v5 + 56), *(_QWORD *)(v5 + 64), *(float32x4_t **)(v5 + 72), *(float32x4_t **)(v5 + 80), *(float32x4_t **)(v5 + 88), *(_QWORD *)(v5 + 96), v7, *(int8x16_t *)(v5 + 32), a4, &v8);
      ++v6;
    }
    while (*(unsigned __int16 *)(v5 + 104) > (unsigned __int16)v6);
  }
  return result;
}

uint64_t xdr::convert_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)2>(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, uint64_t a7, __int32 a8, int8x16_t a9, uint16x4_t a10, _DWORD *a11)
{
  int8x16_t v15;
  uint64_t v17;
  uint64_t v18;
  uint16x4_t v19;
  int32x2_t v20;
  uint64_t v21;
  int32x2_t v22;
  __int128 v23;
  uint16x4_t v24;
  uint64_t v29;
  __int32 v31;
  _OWORD v32[8];
  _BYTE v33[136];
  uint64_t v34;

  v15 = a9;
  v17 = 0;
  v18 = 0;
  v34 = *MEMORY[0x1E0C80C00];
  a10.i32[0] = a8;
  v19 = (uint16x4_t)vmovl_u16(a10).u64[0];
  v20 = (int32x2_t)vshl_u32((uint32x2_t)v19, (uint32x2_t)0x100000002);
  memset(v33, 0, 128);
  memset(v32, 0, sizeof(v32));
  do
  {
    v21 = 0;
    v29 = v17;
    do
    {
      v22 = vadd_s32((int32x2_t)__PAIR64__(v18, v21), v20);
      HIWORD(v31) = v22.i16[2];
      LOWORD(v31) = v22.i16[0];
      *(double *)&v23 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, (_OWORD *)((char *)v32 + v17), v31, a11, v15, v19);
      v15 = a9;
      *(_OWORD *)&v33[v17] = v23;
      ++v21;
      v17 += 32;
    }
    while (v21 != 4);
    ++v18;
    v17 = v29 + 16;
  }
  while (v18 != 2);
  xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(a2, (uint64_t)v33, a8, *(uint16x4_t *)&v23);
  return xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(a3, (uint64_t)v32, a8, v24);
}

uint64_t xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(uint64_t result, uint64_t a2, __int32 a3, uint16x4_t a4)
{
  float32x4_t *v5;
  uint32x2_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int32x2_t v10;
  char v11;
  uint64_t v17;
  char v18;
  char v19;
  float32x4_t v20;
  char v21;
  __n128 v22;
  int32x2_t v23;
  int16x4_t v24;
  uint16x4_t v25;
  uint16x4_t v26;
  uint16x4_t v27;
  uint16x4_t v28;
  uint16x4_t v29;
  uint64_t v30;
  int32x2_t v31;
  float32x2_t v32;
  char v33;
  uint64_t v35;
  char v36;
  char v37;
  float32x4_t v38;
  uint64_t v39;
  char v40;
  char v41;
  char v42;
  float32x4_t v43;
  __n128 v44;
  int32x2_t v45;
  __n128 v46;
  uint64_t v47;
  int32x2_t v48;
  char v49;
  float v50;
  uint64_t v51;
  char v52;
  float32x4_t *v53;
  float32x4_t v54;
  __n128 v55;
  int32x2_t v56;
  uint64_t v57;
  int32x2_t v58;
  int32x2_t v59;
  char v60;
  uint64_t v62;
  char v63;
  float32x2_t v64;
  char v65;
  uint64_t v66;
  char v67;
  char v68;
  char v69;
  uint64_t v70;
  float32x4_t v71;
  int8x16_t v72;
  int32x2_t v73;
  __n128 v74;
  int32x2_t v75;
  uint64_t v76;
  int32x2_t v77;
  int v78;
  __int16 v79;
  char v80;
  uint16x4_t v81;
  uint64_t v82;
  char v83;
  uint64_t v84;
  char v85;
  uint64_t v86;
  char v87;
  float32x2_t v88;
  char v89;
  char v90;
  uint64_t v91;
  float32x4_t v92;
  int8x16_t v93;
  int32x2_t v94;
  __n128 v95;
  uint64_t v96;
  int32x2_t v97;
  char v98;
  uint64_t v99;
  char v100;
  float32x4_t *v101;
  float32x4_t v102;
  int32x2_t v103;
  __n128 v104;
  unsigned int v105;
  int32x2_t v106;
  char v107;
  uint64_t v109;
  char v110;
  char v111;
  float32x4_t v112;
  uint64_t v113;
  char v114;
  char v115;
  char v116;
  float32x4_t v117;
  __n128 v118;
  int32x2_t v119;
  __n128 v120;
  unsigned __int16 v121;
  float32x4_t v122;
  int8x16_t v123;
  int8x16_t v124;
  int8x16_t v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;

  v5 = (float32x4_t *)result;
  a4.i32[0] = a3;
  v6 = (uint32x2_t)vmovl_u16(a4).u64[0];
  v7 = *(_DWORD *)(result + 16);
  if (v7 == 3)
  {
LABEL_4:
    v8 = *(unsigned __int16 *)(result + 112);
    if (v8 == 1)
    {
      v47 = 0;
      v48 = (int32x2_t)vshl_u32(v6, (uint32x2_t)0x100000002);
      v49 = 1;
      v50 = 1.0;
      do
      {
        v51 = 0;
        v52 = v49;
        v53 = (float32x4_t *)(a2 + 16 * v47);
        do
        {
          v54 = *v53;
          v53 += 2;
          v55 = (__n128)vmlaq_f32(v5[3], v54, v5[2]);
          v55.n128_f32[3] = v50;
          v56 = vadd_s32((int32x2_t)__PAIR64__(v47, v51), v48);
          HIWORD(v126) = v56.i16[2];
          LOWORD(v126) = v56.i16[0];
          result = (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v126, v55);
          v50 = 1.0;
          ++v51;
        }
        while (v51 != 4);
        v49 = 0;
        v47 = 1;
      }
      while ((v52 & 1) != 0);
    }
    else if (v8 == 2)
    {
      v9 = 0;
      v10 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
      v11 = 1;
      __asm { FMOV            V0.4S, #0.25 }
      v122 = _Q0;
      do
      {
        v17 = 0;
        v18 = v11;
        v19 = 1;
        v20 = 0uLL;
        do
        {
          v21 = v19;
          v20 = vaddq_f32(vaddq_f32(v20, *(float32x4_t *)(a2 + (v9 << 6) + 16 * v17)), *(float32x4_t *)(a2 + 32 * ((2 * v9) | 1) + 16 * v17));
          v17 = 1;
          v19 = 0;
        }
        while ((v21 & 1) != 0);
        v22 = (__n128)vmlaq_f32(v5[3], vmulq_f32(v20, v122), v5[2]);
        v22.n128_u32[3] = 1.0;
        v23 = vadd_s32((int32x2_t)v9, v10);
        HIWORD(v127) = v23.i16[2];
        LOWORD(v127) = v23.i16[0];
        result = (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v127, v22);
        v11 = 0;
        v9 = 1;
      }
      while ((v18 & 1) != 0);
    }
    return result;
  }
  if (v7 != 2)
  {
    if (v7 != 1)
      return result;
    goto LABEL_4;
  }
  v24 = *(int16x4_t *)(result + 112);
  v25 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x200020001);
  v25.i16[3] = v25.i16[2];
  if ((vminv_u16(v25) & 0x8000) != 0)
  {
    v57 = 0;
    v58 = (int32x2_t)vshl_u32(v6, (uint32x2_t)0x100000002);
    v59 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
    v60 = 1;
    __asm { FMOV            V10.2S, #0.25 }
    do
    {
      v62 = 0;
      v63 = v60;
      v64 = 0;
      v65 = 1;
      do
      {
        v66 = 0;
        v67 = v65;
        v68 = 1;
        do
        {
          v69 = v68;
          v70 = v66 | (2 * v57);
          v71 = *(float32x4_t *)(a2 + 32 * v70 + 16 * v62);
          v72 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v71.f32[0]), v5[5], *(float32x2_t *)v71.f32, 1), v5[6], v71, 2), v5[2]);
          v64 = vadd_f32(v64, (float32x2_t)*(_OWORD *)&vextq_s8(v72, v72, 4uLL));
          v73 = vadd_s32((int32x2_t)__PAIR64__(v62, v70), v58);
          HIWORD(v135) = v73.i16[2];
          LOWORD(v135) = v73.i16[0];
          (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v135, *(float *)v72.i32);
          v68 = 0;
          v66 = 1;
        }
        while ((v69 & 1) != 0);
        v65 = 0;
        v62 = 1;
      }
      while ((v67 & 1) != 0);
      v74.n128_u64[0] = (unint64_t)vmul_f32(v64, _D10);
      v74.n128_u64[1] = 0x3F80000000000000;
      v75 = vadd_s32((int32x2_t)v57, v59);
      HIWORD(v134) = v75.i16[2];
      LOWORD(v134) = v75.i16[0];
      result = (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[1] + 24))(v5->i64[1], v134, v74);
      v60 = 0;
      v57 = 1;
    }
    while ((v63 & 1) != 0);
  }
  else
  {
    v26 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x100020001);
    v26.i16[3] = v26.i16[2];
    if ((vminv_u16(v26) & 0x8000) != 0)
    {
      v76 = 0;
      v77 = (int32x2_t)vshl_u32(v6, (uint32x2_t)0x100000002);
      v78 = 2 * a3;
      v79 = 2 * v6.i16[2];
      v80 = 1;
      v81.i32[1] = 1065353216;
      do
      {
        v82 = 0;
        v83 = v80;
        v84 = 2 * v76;
        v81.i32[0] = v78 | v76;
        v121 = vmovl_u16(v81).u16[0];
        v85 = 1;
        do
        {
          v86 = 0;
          v87 = v85;
          v88 = 0;
          v89 = 1;
          do
          {
            v90 = v89;
            v91 = v86 | v84;
            v92 = *(float32x4_t *)(a2 + 32 * v91 + 16 * v82);
            v93 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v92.f32[0]), v5[5], *(float32x2_t *)v92.f32, 1), v5[6], v92, 2), v5[2]);
            v88 = vadd_f32(v88, (float32x2_t)*(_OWORD *)&vextq_s8(v93, v93, 4uLL));
            v94 = vadd_s32((int32x2_t)__PAIR64__(v82, v91), v77);
            HIWORD(v133) = v94.i16[2];
            LOWORD(v133) = v94.i16[0];
            (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v133, *(float *)v93.i32);
            v89 = 0;
            v86 = 1;
          }
          while ((v90 & 1) != 0);
          v95.n128_u64[0] = (unint64_t)vmul_f32(v88, (float32x2_t)0x3F0000003F000000);
          v95.n128_u64[1] = 0x3F80000000000000;
          HIWORD(v132) = v79 | v82;
          LOWORD(v132) = v121;
          result = (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[1] + 24))(v5->i64[1], v132, v95);
          v85 = 0;
          v82 = 1;
        }
        while ((v87 & 1) != 0);
        v80 = 0;
        v76 = 1;
      }
      while ((v83 & 1) != 0);
    }
    else
    {
      v27 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x1000100010001);
      v27.i16[3] = v27.i16[2];
      if ((vminv_u16(v27) & 0x8000) != 0)
      {
        v96 = 0;
        v97 = (int32x2_t)vshl_u32(v6, (uint32x2_t)0x100000002);
        v98 = 1;
        do
        {
          v99 = 0;
          v100 = v98;
          v101 = (float32x4_t *)(a2 + 16 * v96);
          do
          {
            v102 = *v101;
            v101 += 2;
            v124 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v102.f32[0]), v5[5], *(float32x2_t *)v102.f32, 1), v5[6], v102, 2), v5[2]);
            v103 = vadd_s32((int32x2_t)__PAIR64__(v96, v99), v97);
            HIWORD(v131) = v103.i16[2];
            LOWORD(v131) = v103.i16[0];
            (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v131, *(float *)v124.i32);
            v104.n128_u64[0] = vextq_s8(v124, v124, 4uLL).u64[0];
            v104.n128_u64[1] = 0x3F80000000000000;
            result = (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[1] + 24))(v5->i64[1], v131, v104);
            ++v99;
          }
          while (v99 != 4);
          v98 = 0;
          v96 = 1;
        }
        while ((v100 & 1) != 0);
      }
      else
      {
        v28 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x2000200020002);
        v28.i16[3] = v28.i16[2];
        if ((vminv_u16(v28) & 0x8000) != 0)
        {
          v105 = 0;
          v106 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
          v107 = 1;
          __asm { FMOV            V10.2S, #0.25 }
          do
          {
            v109 = 0;
            v110 = v107;
            v111 = 1;
            v112 = 0uLL;
            do
            {
              v113 = 0;
              v114 = v111;
              v115 = 1;
              do
              {
                v116 = v115;
                v117 = *(float32x4_t *)(a2 + 32 * v113 + 16 * v109);
                v112 = vaddq_f32(v112, vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v117.f32[0]), v5[5], *(float32x2_t *)v117.f32, 1), v5[6], v117, 2), v5[2]));
                v113 = 1;
                v115 = 0;
              }
              while ((v116 & 1) != 0);
              v111 = 0;
              v109 = 1;
            }
            while ((v114 & 1) != 0);
            v118.n128_f32[0] = 0.25 * v112.f32[0];
            v118.n128_u32[1] = 0;
            v118.n128_u32[2] = 0;
            v118.n128_u32[3] = 1.0;
            v119 = vadd_s32((int32x2_t)v105, v106);
            HIWORD(v130) = v119.i16[2];
            LOWORD(v130) = v119.i16[0];
            v125 = (int8x16_t)v112;
            (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v130, v118);
            v120.n128_u64[0] = (unint64_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v125, v125, 4uLL), _D10);
            v120.n128_u64[1] = 0x3F80000000000000;
            result = (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[1] + 24))(v5->i64[1], v130, v120);
            v107 = 0;
            v105 = 1;
          }
          while ((v110 & 1) != 0);
        }
        else
        {
          v29 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x200040002);
          v29.i16[3] = v29.i16[2];
          if ((vminv_u16(v29) & 0x8000) != 0)
          {
            v30 = 0;
            v31 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
            v6.i32[0] = a3;
            *(uint32x2_t *)v123.i8 = v6;
            v32 = 0;
            v33 = 1;
            __asm { FMOV            V10.2S, #0.25 }
            do
            {
              v35 = 0;
              v36 = v33;
              v37 = 1;
              v38 = 0uLL;
              do
              {
                v39 = 0;
                v40 = v37;
                v41 = 1;
                do
                {
                  v42 = v41;
                  v43 = *(float32x4_t *)(a2 + 32 * (v39 | (2 * v30)) + 16 * v35);
                  v38 = vaddq_f32(v38, vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v43.f32[0]), v5[5], *(float32x2_t *)v43.f32, 1), v5[6], v43, 2), v5[2]));
                  v39 = 1;
                  v41 = 0;
                }
                while ((v42 & 1) != 0);
                v37 = 0;
                v35 = 1;
              }
              while ((v40 & 1) != 0);
              v32 = vmla_f32(v32, _D10, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v38, (int8x16_t)v38, 4uLL));
              v44.n128_f32[0] = 0.25 * v38.f32[0];
              v44.n128_u32[1] = 0;
              v44.n128_u32[2] = 0;
              v44.n128_u32[3] = 1.0;
              v45 = vadd_s32((int32x2_t)v30, v31);
              HIWORD(v129) = v45.i16[2];
              LOWORD(v129) = v45.i16[0];
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[0] + 24))(v5->i64[0], v129, v44);
              v33 = 0;
              v30 = 1;
            }
            while ((v36 & 1) != 0);
            HIWORD(v128) = v123.i16[2];
            LOWORD(v128) = v123.i16[0];
            v46.n128_u64[0] = (unint64_t)vmul_f32(v32, (float32x2_t)0x3F0000003F000000);
            v46.n128_u64[1] = 0x3F80000000000000;
            return (*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v5->i64[1] + 24))(v5->i64[1], v128, v46);
          }
        }
      }
    }
  }
  return result;
}

float32x4_t *xdr::convert_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)4>(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, uint64_t a7, unsigned __int32 a8, int8x16_t a9, uint16x4_t a10, _DWORD *a11)
{
  int8x16_t v15;
  uint64_t v17;
  uint64_t v18;
  int32x2_t v19;
  int32x2_t v20;
  uint64_t v21;
  int32x2_t v22;
  float32x4_t v23;
  uint16x4_t v24;
  uint64_t v29;
  __int32 v31;
  float32x4_t v32[16];
  float32x4_t v33[16];
  uint64_t v34;

  v15 = a9;
  v17 = 0;
  v18 = 0;
  v34 = *MEMORY[0x1E0C80C00];
  a10.i32[0] = a8;
  v19 = (int32x2_t)vmovl_u16(a10).u64[0];
  memset(v33, 0, sizeof(v33));
  v20 = vshl_n_s32(v19, 2uLL);
  memset(v32, 0, sizeof(v32));
  do
  {
    v21 = 0;
    v29 = v17;
    do
    {
      v22 = vadd_s32((int32x2_t)__PAIR64__(v18, v21), v20);
      HIWORD(v31) = v22.i16[2];
      LOWORD(v31) = v22.i16[0];
      *(double *)v23.i64 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, (float32_t *)((char *)v32[0].f32 + v17), v31, a11, v15, (uint16x4_t)v19);
      v15 = a9;
      *(float32x4_t *)((char *)v33 + v17) = v23;
      ++v21;
      v17 += 64;
    }
    while (v21 != 4);
    ++v18;
    v17 = v29 + 16;
  }
  while (v18 != 4);
  xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(a2, v33, a8, *(uint16x4_t *)v23.f32);
  return xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(a3, v32, a8, v24);
}

float32x4_t *xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(float32x4_t *result, float32x4_t *a2, uint64_t a3, uint16x4_t a4)
{
  float32x4_t *v6;
  int32x2_t v7;
  __int32 v8;
  int v9;
  uint64_t v10;
  float32x4_t v11;
  uint64_t i;
  __n128 v18;
  uint64_t v19;
  int16x4_t v20;
  uint16x4_t v21;
  uint16x4_t v22;
  uint16x4_t v23;
  uint16x4_t v24;
  uint16x4_t v25;
  uint16x4_t v26;
  uint64_t v27;
  int8x8_t v28;
  float32x2_t v29;
  char v30;
  uint64_t v32;
  char v33;
  char v34;
  uint64_t v35;
  char v36;
  float32x4_t v37;
  char v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  char v42;
  char v43;
  float32x4_t v44;
  __n128 v45;
  int8x8_t v46;
  uint64_t v47;
  int32x2_t v48;
  float v49;
  uint64_t v50;
  float32x4_t *v51;
  float32x4_t v52;
  __n128 v53;
  int32x2_t v54;
  uint64_t v55;
  int8x8_t v56;
  char v57;
  uint64_t v59;
  char v60;
  char v61;
  uint64_t v62;
  char v63;
  char v64;
  float32x4_t v65;
  char v66;
  __n128 v67;
  int8x8_t v68;
  uint64_t v69;
  int32x2_t v70;
  int8x8_t v71;
  char v72;
  uint64_t v74;
  char v75;
  uint64_t v76;
  char v77;
  float32x2_t v78;
  char v79;
  uint64_t v80;
  char v81;
  uint64_t v82;
  char v83;
  char v84;
  uint64_t v85;
  float32x4_t v86;
  int8x16_t v87;
  int32x2_t v88;
  __n128 v89;
  int8x8_t v90;
  uint64_t v91;
  int32x2_t v92;
  int v93;
  __int16 v94;
  char v95;
  uint64_t v96;
  char v97;
  uint64_t v98;
  uint64_t v99;
  float32x2_t v100;
  char v101;
  char v102;
  uint64_t v103;
  float32x4_t v104;
  int8x16_t v105;
  int32x2_t v106;
  __n128 v107;
  uint64_t v108;
  int32x2_t v109;
  uint64_t v110;
  float32x4_t *v111;
  float32x4_t v112;
  int32x2_t v113;
  __n128 v114;
  int v115;
  int8x8_t v116;
  char v117;
  int v119;
  char v120;
  char v121;
  uint64_t v122;
  char v123;
  float32x4_t v124;
  char v125;
  uint64_t v126;
  char v127;
  char v128;
  char v129;
  float32x4_t v130;
  __n128 v131;
  int8x8_t v132;
  __n128 v133;
  uint64_t v134;
  int8x8_t v135;
  int v136;
  char v137;
  uint64_t v139;
  char v140;
  uint64_t v141;
  float32x2_t v142;
  char v143;
  uint64_t v144;
  char v145;
  float32x4_t v146;
  char v147;
  uint64_t v148;
  char v149;
  uint64_t v150;
  char v151;
  char v152;
  float32x4_t v153;
  __n128 v154;
  int8x8_t v155;
  __n128 v156;
  char v157;
  unsigned __int16 v158;
  unsigned __int32 v159;
  float32x4_t v160;
  int8x16_t v161;
  int8x16_t v162;
  int8x16_t v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  unsigned int v167;
  unsigned int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  unsigned int v173;
  unsigned int v174;

  v6 = result;
  a4.i32[0] = a3;
  v7 = (int32x2_t)vmovl_u16(a4).u64[0];
  v8 = result[1].i32[0];
  if (v8 == 3)
    goto LABEL_4;
  if (v8 != 2)
  {
    if (v8 != 1)
      return result;
LABEL_4:
    v9 = result[7].u16[0];
    switch(v9)
    {
      case 1:
        v47 = 0;
        v48 = vshl_n_s32(v7, 2uLL);
        v49 = 1.0;
        do
        {
          v50 = 0;
          v51 = a2;
          do
          {
            v52 = *v51;
            v51 += 4;
            v53 = (__n128)vmlaq_f32(v6[3], v52, v6[2]);
            v53.n128_f32[3] = v49;
            v54 = vadd_s32((int32x2_t)__PAIR64__(v47, v50), v48);
            HIWORD(v164) = v54.i16[2];
            LOWORD(v164) = v54.i16[0];
            result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v164, v53);
            v49 = 1.0;
            ++v50;
          }
          while (v50 != 4);
          ++v47;
          ++a2;
        }
        while (v47 != 4);
        break;
      case 2:
        v55 = 0;
        v56 = (int8x8_t)vadd_s32(v7, v7);
        v57 = 1;
        __asm { FMOV            V0.4S, #0.25 }
        v160 = _Q0;
        do
        {
          v59 = 0;
          v60 = v57;
          v61 = 1;
          do
          {
            v62 = 0;
            v63 = v61;
            v64 = 1;
            v65 = 0uLL;
            do
            {
              v66 = v64;
              v65 = vaddq_f32(vaddq_f32(v65, a2[8 * v59 + (v62 | (2 * v55))]), a2[4 * ((2 * v59) | 1) + (v62 | (2 * v55))]);
              v62 = 1;
              v64 = 0;
            }
            while ((v66 & 1) != 0);
            v67 = (__n128)vmlaq_f32(v6[3], vmulq_f32(v65, v160), v6[2]);
            v67.n128_u32[3] = 1.0;
            v68 = vorr_s8((int8x8_t)__PAIR64__(v55, v59), v56);
            HIWORD(v165) = v68.i16[2];
            LOWORD(v165) = v68.i16[0];
            result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v165, v67);
            v61 = 0;
            v59 = 1;
          }
          while ((v63 & 1) != 0);
          v57 = 0;
          v55 = 1;
        }
        while ((v60 & 1) != 0);
        break;
      case 4:
        v10 = 0;
        v11 = 0uLL;
        do
        {
          for (i = 0; i != 16; i += 4)
            v11 = vaddq_f32(v11, a2[i]);
          ++v10;
          ++a2;
        }
        while (v10 != 4);
        __asm { FMOV            V1.4S, #0.25 }
        v18 = (__n128)vmlaq_f32(result[3], vmulq_f32(v11, _Q1), result[2]);
        v18.n128_u32[3] = 1.0;
        v19 = result->i64[0];
        return (float32x4_t *)(*(uint64_t (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v19 + 24))(v19, a3, v18);
      default:
        return result;
    }
    return result;
  }
  v20 = *(int16x4_t *)result[7].f32;
  v21 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x200020001);
  v21.i16[3] = v21.i16[2];
  if ((vminv_u16(v21) & 0x8000) != 0)
  {
    v69 = 0;
    v70 = vshl_n_s32(v7, 2uLL);
    v71 = (int8x8_t)vadd_s32(v7, v7);
    v72 = 1;
    __asm { FMOV            V10.2S, #0.25 }
    do
    {
      v74 = 0;
      v157 = v72;
      v75 = 1;
      do
      {
        v76 = 0;
        v77 = v75;
        v78 = 0;
        v79 = 1;
        do
        {
          v80 = 0;
          v81 = v79;
          v82 = v76 | (2 * v69);
          v83 = 1;
          do
          {
            v84 = v83;
            v85 = v80 | (2 * v74);
            v86 = a2[4 * v85 + v82];
            v87 = (int8x16_t)vmlaq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6[4], v86.f32[0]), v6[5], *(float32x2_t *)v86.f32, 1), v6[6], v86, 2), v6[2]);
            v78 = vadd_f32(v78, (float32x2_t)*(_OWORD *)&vextq_s8(v87, v87, 4uLL));
            v88 = vadd_s32((int32x2_t)__PAIR64__(v82, v85), v70);
            HIWORD(v174) = v88.i16[2];
            LOWORD(v174) = v88.i16[0];
            (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v174, *(float *)v87.i32);
            v83 = 0;
            v80 = 1;
          }
          while ((v84 & 1) != 0);
          v79 = 0;
          v76 = 1;
        }
        while ((v81 & 1) != 0);
        v89.n128_u64[0] = (unint64_t)vmul_f32(v78, _D10);
        v89.n128_u64[1] = 0x3F80000000000000;
        v90 = vorr_s8((int8x8_t)__PAIR64__(v69, v74), v71);
        HIWORD(v173) = v90.i16[2];
        LOWORD(v173) = v90.i16[0];
        result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[1] + 24))(v6->i64[1], v173, v89);
        v75 = 0;
        v74 = 1;
      }
      while ((v77 & 1) != 0);
      v72 = 0;
      v69 = 1;
    }
    while ((v157 & 1) != 0);
  }
  else
  {
    v22 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x100020001);
    v22.i16[3] = v22.i16[2];
    if ((vminv_u16(v22) & 0x8000) != 0)
    {
      v91 = 0;
      v92 = vshl_n_s32(v7, 2uLL);
      v93 = 2 * a3;
      v94 = 4 * v7.i16[2];
      v95 = 1;
      v7.i32[1] = 1065353216;
      do
      {
        v96 = 0;
        v97 = v95;
        v98 = 2 * v91;
        v7.i32[0] = v93 | v91;
        v158 = vmovl_u16((uint16x4_t)v7).u16[0];
        do
        {
          v99 = 0;
          v100 = 0;
          v101 = 1;
          do
          {
            v102 = v101;
            v103 = v99 | v98;
            v104 = a2[4 * v103 + v96];
            v105 = (int8x16_t)vmlaq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6[4], v104.f32[0]), v6[5], *(float32x2_t *)v104.f32, 1), v6[6], v104, 2), v6[2]);
            v100 = vadd_f32(v100, (float32x2_t)*(_OWORD *)&vextq_s8(v105, v105, 4uLL));
            v106 = vadd_s32((int32x2_t)__PAIR64__(v96, v103), v92);
            HIWORD(v172) = v106.i16[2];
            LOWORD(v172) = v106.i16[0];
            (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v172, *(float *)v105.i32);
            v101 = 0;
            v99 = 1;
          }
          while ((v102 & 1) != 0);
          v107.n128_u64[0] = (unint64_t)vmul_f32(v100, (float32x2_t)0x3F0000003F000000);
          v107.n128_u64[1] = 0x3F80000000000000;
          HIWORD(v171) = v94 + v96;
          LOWORD(v171) = v158;
          result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[1] + 24))(v6->i64[1], v171, v107);
          ++v96;
        }
        while (v96 != 4);
        v95 = 0;
        v91 = 1;
      }
      while ((v97 & 1) != 0);
    }
    else
    {
      v23 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x1000100010001);
      v23.i16[3] = v23.i16[2];
      if ((vminv_u16(v23) & 0x8000) != 0)
      {
        v108 = 0;
        v109 = vshl_n_s32(v7, 2uLL);
        do
        {
          v110 = 0;
          v111 = a2;
          do
          {
            v112 = *v111;
            v111 += 4;
            v161 = (int8x16_t)vmlaq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6[4], v112.f32[0]), v6[5], *(float32x2_t *)v112.f32, 1), v6[6], v112, 2), v6[2]);
            v113 = vadd_s32((int32x2_t)__PAIR64__(v108, v110), v109);
            HIWORD(v170) = v113.i16[2];
            LOWORD(v170) = v113.i16[0];
            (*(void (**)(uint64_t, _QWORD, float))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v170, *(float *)v161.i32);
            v114.n128_u64[0] = vextq_s8(v161, v161, 4uLL).u64[0];
            v114.n128_u64[1] = 0x3F80000000000000;
            result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[1] + 24))(v6->i64[1], v170, v114);
            ++v110;
          }
          while (v110 != 4);
          ++v108;
          ++a2;
        }
        while (v108 != 4);
      }
      else
      {
        v24 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x2000200020002);
        v24.i16[3] = v24.i16[2];
        if ((vminv_u16(v24) & 0x8000) != 0)
        {
          v115 = 0;
          v116 = (int8x8_t)vadd_s32(v7, v7);
          v117 = 1;
          __asm { FMOV            V10.2S, #0.25 }
          do
          {
            v119 = 0;
            v120 = v117;
            v121 = 1;
            do
            {
              v122 = 0;
              v123 = v121;
              v124 = 0uLL;
              v125 = 1;
              do
              {
                v126 = 0;
                v127 = v125;
                v128 = 1;
                do
                {
                  v129 = v128;
                  v130 = a2[4 * v126 + v122];
                  v124 = vaddq_f32(v124, vmlaq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6[4], v130.f32[0]), v6[5], *(float32x2_t *)v130.f32, 1), v6[6], v130, 2), v6[2]));
                  v126 = 1;
                  v128 = 0;
                }
                while ((v129 & 1) != 0);
                v125 = 0;
                v122 = 1;
              }
              while ((v127 & 1) != 0);
              v131.n128_f32[0] = 0.25 * v124.f32[0];
              v131.n128_u32[1] = 0;
              v131.n128_u32[2] = 0;
              v131.n128_u32[3] = 1.0;
              v132 = vorr_s8((int8x8_t)__PAIR64__(v115, v119), v116);
              HIWORD(v169) = v132.i16[2];
              LOWORD(v169) = v132.i16[0];
              v162 = (int8x16_t)v124;
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v169, v131);
              v133.n128_u64[0] = (unint64_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v162, v162, 4uLL), _D10);
              v133.n128_u64[1] = 0x3F80000000000000;
              result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[1] + 24))(v6->i64[1], v169, v133);
              v121 = 0;
              v119 = 1;
            }
            while ((v123 & 1) != 0);
            v117 = 0;
            v115 = 1;
          }
          while ((v120 & 1) != 0);
        }
        else
        {
          v25 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x200040002);
          v25.i16[3] = v25.i16[2];
          if ((vminv_u16(v25) & 0x8000) != 0)
          {
            v134 = 0;
            v135 = (int8x8_t)vadd_s32(v7, v7);
            v20.i32[0] = a3;
            v159 = vmovl_u16((uint16x4_t)v20).u32[0];
            v136 = 2 * v7.i32[1];
            v137 = 1;
            __asm { FMOV            V9.2S, #0.25 }
            do
            {
              v139 = 0;
              v140 = v137;
              LODWORD(v141) = v159;
              HIDWORD(v141) = v136 | v134;
              v163.i64[0] = v141;
              v142 = 0;
              v143 = 1;
              do
              {
                v144 = 0;
                v145 = v143;
                v146 = 0uLL;
                v147 = 1;
                do
                {
                  v148 = 0;
                  v149 = v147;
                  v150 = v144 | (2 * v134);
                  v151 = 1;
                  do
                  {
                    v152 = v151;
                    v153 = a2[4 * (v148 | (2 * v139)) + v150];
                    v146 = vaddq_f32(v146, vmlaq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6[4], v153.f32[0]), v6[5], *(float32x2_t *)v153.f32, 1), v6[6], v153, 2), v6[2]));
                    v148 = 1;
                    v151 = 0;
                  }
                  while ((v152 & 1) != 0);
                  v147 = 0;
                  v144 = 1;
                }
                while ((v149 & 1) != 0);
                v142 = vmla_f32(v142, _D9, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v146, (int8x16_t)v146, 4uLL));
                v154.n128_f32[0] = 0.25 * v146.f32[0];
                v154.n128_u32[1] = 0;
                v154.n128_u32[2] = 0;
                v154.n128_u32[3] = 1.0;
                v155 = vorr_s8((int8x8_t)__PAIR64__(v134, v139), v135);
                HIWORD(v168) = v155.i16[2];
                LOWORD(v168) = v155.i16[0];
                (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v168, v154);
                v143 = 0;
                v139 = 1;
              }
              while ((v145 & 1) != 0);
              HIWORD(v167) = v163.i16[2];
              LOWORD(v167) = v163.i16[0];
              v156.n128_u64[0] = (unint64_t)vmul_f32(v142, (float32x2_t)0x3F0000003F000000);
              v156.n128_u64[1] = 0x3F80000000000000;
              result = (float32x4_t *)(*(uint64_t (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[1] + 24))(v6->i64[1], v167, v156);
              v137 = 0;
              v134 = 1;
            }
            while ((v140 & 1) != 0);
          }
          else
          {
            v26 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x400040002);
            v26.i16[3] = v26.i16[2];
            if ((vminv_u16(v26) & 0x8000) != 0)
            {
              v27 = 0;
              v28 = (int8x8_t)vadd_s32(v7, v7);
              v29 = 0;
              v30 = 1;
              __asm { FMOV            V10.2S, #0.25 }
              do
              {
                v32 = 0;
                v33 = v30;
                v34 = 1;
                do
                {
                  v35 = 0;
                  v36 = v34;
                  v37 = 0uLL;
                  v38 = 1;
                  do
                  {
                    v39 = 0;
                    v40 = v38;
                    v41 = v35 | (2 * v27);
                    v42 = 1;
                    do
                    {
                      v43 = v42;
                      v44 = a2[4 * (v39 | (2 * v32)) + v41];
                      v37 = vaddq_f32(v37, vmlaq_f32(v6[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6[4], v44.f32[0]), v6[5], *(float32x2_t *)v44.f32, 1), v6[6], v44, 2), v6[2]));
                      v39 = 1;
                      v42 = 0;
                    }
                    while ((v43 & 1) != 0);
                    v38 = 0;
                    v35 = 1;
                  }
                  while ((v40 & 1) != 0);
                  v29 = vmla_f32(v29, _D10, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v37, (int8x16_t)v37, 4uLL));
                  v45.n128_f32[0] = 0.25 * v37.f32[0];
                  v45.n128_u32[1] = 0;
                  v45.n128_u32[2] = 0;
                  v45.n128_u32[3] = 1.0;
                  v46 = vorr_s8((int8x8_t)__PAIR64__(v27, v32), v28);
                  HIWORD(v166) = v46.i16[2];
                  LOWORD(v166) = v46.i16[0];
                  (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v6->i64[0] + 24))(v6->i64[0], v166, v45);
                  v34 = 0;
                  v32 = 1;
                }
                while ((v36 & 1) != 0);
                v30 = 0;
                v27 = 1;
              }
              while ((v33 & 1) != 0);
              v18.n128_u64[0] = (unint64_t)vmul_f32(v29, _D10);
              v18.n128_u64[1] = 0x3F80000000000000;
              v19 = v6->i64[1];
              return (float32x4_t *)(*(uint64_t (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v19 + 24))(v19, a3, v18);
            }
          }
        }
      }
    }
  }
  return result;
}

void ___ZN3xdr52dispatch_convert_gainmap_image_to_gainmap_image_loopILt1ELt1EEEvRKNS_7imageInES3_RKNS_8imageOutES6_RKNS_16colorTransformInERKNS_15gainTransformInES9_SC_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t a1, unsigned __int16 a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  float32x4_t *v7;
  float32x4_t *v8;
  float32x4_t *v9;
  float32x4_t *v10;
  float32x4_t *v11;
  float32x4_t *v12;
  float32x4_t *v13;
  uint64_t v14;
  int8x16_t v15;
  float32x4_t v16;
  int16x4_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  float32x4_t v21;
  float32x4_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v19 = 0x100000000;
  v20 = 1;
  if (*(_WORD *)(a1 + 128))
  {
    v4 = 0;
    do
    {
      HIWORD(v18) = a2;
      LOWORD(v18) = v4;
      v5 = *(_QWORD *)(a1 + 48);
      v6 = *(_QWORD *)(a1 + 56);
      v7 = *(float32x4_t **)(a1 + 64);
      v8 = *(float32x4_t **)(a1 + 72);
      v9 = *(float32x4_t **)(a1 + 80);
      v10 = *(float32x4_t **)(a1 + 88);
      v11 = *(float32x4_t **)(a1 + 96);
      v12 = *(float32x4_t **)(a1 + 104);
      v13 = *(float32x4_t **)(a1 + 112);
      v14 = *(_QWORD *)(a1 + 120);
      v15 = *(int8x16_t *)(a1 + 32);
      v21 = 0uLL;
      *(double *)v16.i64 = xdr::convert_gainmap_image_to_gainmap_image(v5, v6, v9, v10, v11, v12, v13, v14, v15, &v21, v4, a2, &v19);
      v22 = v16;
      v17 = (int16x4_t)xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v7, &v22, v18, *(int16x4_t *)v16.f32);
      xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v8, &v21, v18, v17);
      ++v4;
    }
    while (*(unsigned __int16 *)(a1 + 128) > (unsigned __int16)v4);
  }
}

double xdr::convert_gainmap_image_to_gainmap_image(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, uint64_t a8, int8x16_t a9, _OWORD *a10, unsigned __int16 a11, unsigned __int16 a12, _DWORD *a13)
{
  int8x8_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  __int128 v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v34;
  float32x4_t v35;
  double v36;
  float32x4_t v37;

  v20.i32[0] = a11;
  v20.i32[1] = a12;
  v36 = COERCE_DOUBLE(vmla_f32((float32x2_t)*(_OWORD *)&vextq_s8(a9, a9, 8uLL), vadd_f32((float32x2_t)vorr_s8(v20, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), *(float32x2_t *)a9.i8));
  xdr::image_sample(a1, a13, v36);
  v34 = v21;
  xdr::image_sample(a2, a13, v36);
  v35 = v22;
  *(double *)v23.i64 = xdr::apply_color_trc((uint64_t)a3, v34);
  *(double *)v24.i64 = xdr::apply_tone_mapping((uint64_t)&a3[5], v23);
  if (!a3[17].i8[0])
    v24 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3[14], v24.f32[0]), a3[15], *(float32x2_t *)v24.f32, 1), a3[16], v24, 2);
  *(double *)v25.i64 = xdr::apply_gain_mapping((uint64_t)a4, v24, v35);
  if (!a4[10].i8[0])
    v25 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a4[7], v25.f32[0]), a4[8], *(float32x2_t *)v25.f32, 1), a4[9], v25, 2);
  v37 = v25;
  *(double *)v26.i64 = xdr::apply_color_trc((uint64_t)a5, v34);
  *(double *)v27.i64 = xdr::apply_tone_mapping((uint64_t)&a5[5], v26);
  if (!a5[17].i8[0])
    v27 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a5[14], v27.f32[0]), a5[15], *(float32x2_t *)v27.f32, 1), a5[16], v27, 2);
  *(double *)v28.i64 = xdr::apply_gain_mapping((uint64_t)a6, v27, v35);
  v29 = v28;
  if (!a6[10].i8[0])
    v29 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a6[7], v28.f32[0]), a6[8], *(float32x2_t *)v28.f32, 1), a6[9], v28, 2);
  *(double *)&v30 = xdr::apply_gain_transform(a8, v37, v29);
  *a10 = v30;
  if (a7[3].i8[0])
    v31 = v37;
  else
    v31 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a7, v37.f32[0]), a7[1], *(float32x2_t *)v37.f32, 1), a7[2], v37, 2);
  *(double *)v32.i64 = xdr::apply_tone_mapping((uint64_t)&a7[4], v31);
  return xdr::apply_color_trc((uint64_t)&a7[13], v32);
}

uint64_t ___ZN3xdr52dispatch_convert_gainmap_image_to_gainmap_image_loopILt2ELt1EEEvRKNS_7imageInES3_RKNS_8imageOutES6_RKNS_16colorTransformInERKNS_15gainTransformInES9_SC_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v5;
  int v6;
  __int32 v7;
  uint64_t v8;
  int v9;

  v8 = 0x100000000;
  v9 = 1;
  if (*(_WORD *)(result + 128))
  {
    v5 = result;
    v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      result = xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)1>(*(_QWORD *)(v5 + 48), *(_QWORD *)(v5 + 56), *(_QWORD *)(v5 + 64), *(_QWORD *)(v5 + 72), *(float32x4_t **)(v5 + 80), *(float32x4_t **)(v5 + 88), *(float32x4_t **)(v5 + 96), *(float32x4_t **)(v5 + 104), *(int8x16_t *)(v5 + 32), a4, *(float32x4_t **)(v5 + 112), *(_QWORD *)(v5 + 120), v7, &v8);
      ++v6;
    }
    while (*(unsigned __int16 *)(v5 + 128) > (unsigned __int16)v6);
  }
  return result;
}

uint64_t xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, float32x4_t *a8, int8x16_t a9, uint16x4_t a10, float32x4_t *a11, uint64_t a12, __int32 a13, _DWORD *a14)
{
  __int128 v20;
  __int128 v21;
  uint16x4_t v22;
  int32x2_t v24;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  a10.i32[0] = a13;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v24 = (int32x2_t)vshl_u32((uint32x2_t)*(_OWORD *)&vmovl_u16(a10), (uint32x2_t)1);
  *(double *)&v20 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a11, a12, a9, &v28, v24.u16[0], v24.u16[2], a14);
  v30 = v20;
  *(int32x2_t *)&v20 = vadd_s32(v24, (int32x2_t)1);
  *(double *)&v21 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a11, a12, a9, &v29, v20, WORD2(v20), a14);
  v31 = v21;
  xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(a3, (uint64_t)&v30, a13, *(uint16x4_t *)&v21);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(a4, (uint64_t)&v28, a13, v22);
}

float32x4_t *xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)2>(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, float32x4_t *a8, int8x16_t a9, float32x4_t *a10, uint64_t a11, unsigned __int32 a12, _DWORD *a13)
{
  uint64_t v13;
  uint64_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int32x2_t v22;
  int32x2_t v23;
  __int128 v24;
  __int128 v25;
  uint16x4_t v26;
  int8x16_t v31;
  _OWORD v32[4];
  _OWORD v33[4];
  uint64_t v34;

  v31 = a9;
  v13 = 0;
  v14 = 0;
  v34 = *MEMORY[0x1E0C80C00];
  a9.i32[0] = a12;
  v15 = (int32x2_t)vmovl_u16(*(uint16x4_t *)a9.i8).u64[0];
  memset(v33, 0, sizeof(v33));
  memset(v32, 0, sizeof(v32));
  v16 = vadd_s32(v15, v15);
  do
  {
    v22.i32[0] = 0;
    v22.i32[1] = v14;
    v23 = vadd_s32(v16, v22);
    *(double *)&v24 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a10, a11, v31, &v32[v13], v23.u16[0], v23.u16[2], a13);
    v33[v13] = v24;
    DWORD1(v24) = v14;
    LODWORD(v24) = 1;
    *(int32x2_t *)&v24 = vadd_s32(*(int32x2_t *)&v24, v16);
    *(double *)&v25 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a10, a11, v31, &v32[v13 + 2], v24, WORD2(v24), a13);
    v33[v13 + 2] = v25;
    ++v14;
    ++v13;
  }
  while (v14 != 2);
  xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a3, (uint64_t)v33, a12, *(uint16x4_t *)&v25);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a4, (uint64_t)v32, a12, v26);
}

uint64_t ___ZN3xdr52dispatch_convert_gainmap_image_to_gainmap_image_loopILt4ELt2EEEvRKNS_7imageInES3_RKNS_8imageOutES6_RKNS_16colorTransformInERKNS_15gainTransformInES9_SC_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v5;
  int v6;
  __int32 v7;
  uint64_t v8;
  int v9;

  v8 = 0x100000000;
  v9 = 1;
  if (*(_WORD *)(result + 128))
  {
    v5 = result;
    v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      result = xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)2>(*(_QWORD *)(v5 + 48), *(_QWORD *)(v5 + 56), *(_QWORD *)(v5 + 64), *(_QWORD *)(v5 + 72), *(float32x4_t **)(v5 + 80), *(float32x4_t **)(v5 + 88), *(float32x4_t **)(v5 + 96), *(float32x4_t **)(v5 + 104), *(int8x16_t *)(v5 + 32), a4, *(float32x4_t **)(v5 + 112), *(_QWORD *)(v5 + 120), v7, &v8);
      ++v6;
    }
    while (*(unsigned __int16 *)(v5 + 128) > (unsigned __int16)v6);
  }
  return result;
}

uint64_t xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)2>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, float32x4_t *a8, int8x16_t a9, uint16x4_t a10, float32x4_t *a11, uint64_t a12, __int32 a13, _DWORD *a14)
{
  int8x16_t v16;
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21;
  uint64_t v22;
  int32x2_t v23;
  __int128 v24;
  uint16x4_t v25;
  uint64_t v29;
  float32x4_t *v30;
  float32x4_t *v31;
  _OWORD v33[8];
  _OWORD v34[8];
  uint64_t v35;

  v16 = a9;
  v19 = 0;
  v20 = 0;
  v35 = *MEMORY[0x1E0C80C00];
  a10.i32[0] = a13;
  v21 = (int32x2_t)vshl_u32((uint32x2_t)*(_OWORD *)&vmovl_u16(a10), (uint32x2_t)0x100000002);
  memset(v34, 0, sizeof(v34));
  memset(v33, 0, sizeof(v33));
  v30 = a6;
  v31 = a5;
  do
  {
    v22 = 0;
    v29 = v19;
    do
    {
      v23 = vadd_s32((int32x2_t)__PAIR64__(v20, v22), v21);
      *(double *)&v24 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a11, a12, v16, (_OWORD *)((char *)v33 + v19), v23.u16[0], v23.u16[2], a14);
      v16 = a9;
      a6 = v30;
      a5 = v31;
      *(_OWORD *)((char *)v34 + v19) = v24;
      ++v22;
      v19 += 32;
    }
    while (v22 != 4);
    ++v20;
    v19 = v29 + 16;
  }
  while (v20 != 2);
  xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(a3, (uint64_t)v34, a13, *(uint16x4_t *)&v24);
  return xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(a4, (uint64_t)v33, a13, v25);
}

float32x4_t *xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)4>(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, float32x4_t *a8, int8x16_t a9, uint16x4_t a10, float32x4_t *a11, uint64_t a12, unsigned __int32 a13, _DWORD *a14)
{
  int8x16_t v16;
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21;
  uint64_t v22;
  int32x2_t v23;
  float32x4_t v24;
  uint16x4_t v25;
  uint64_t v29;
  float32x4_t *v30;
  float32x4_t *v31;
  float32x4_t v33[16];
  float32x4_t v34[16];
  uint64_t v35;

  v16 = a9;
  v19 = 0;
  v20 = 0;
  v35 = *MEMORY[0x1E0C80C00];
  a10.i32[0] = a13;
  memset(v34, 0, sizeof(v34));
  v21 = vshl_n_s32((int32x2_t)*(_OWORD *)&vmovl_u16(a10), 2uLL);
  memset(v33, 0, sizeof(v33));
  v30 = a6;
  v31 = a5;
  do
  {
    v22 = 0;
    v29 = v19;
    do
    {
      v23 = vadd_s32((int32x2_t)__PAIR64__(v20, v22), v21);
      *(double *)v24.i64 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a11, a12, v16, (float32_t *)((char *)v33[0].f32 + v19), v23.u16[0], v23.u16[2], a14);
      v16 = a9;
      a6 = v30;
      a5 = v31;
      *(float32x4_t *)((char *)v34 + v19) = v24;
      ++v22;
      v19 += 64;
    }
    while (v22 != 4);
    ++v20;
    v19 = v29 + 16;
  }
  while (v20 != 4);
  xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(a3, v34, a13, *(uint16x4_t *)v24.f32);
  return xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(a4, v33, a13, v25);
}

void ___ZN3xdr36dispatch_compute_luma_gain_histogramILt2ELt2ELt4EEEvRKNS_7imageInES3_RKNS_16colorTransformInERKNS_15gainTransformInERNS_11histogram2DEDv2_fDv2_t_block_invoke(uint64_t a1, unint64_t a2)
{
  uint16x4_t v2;
  unsigned int v5;
  int32x2_t v6;
  unsigned __int16 v7;
  unsigned int v8;
  int8x8_t v9;
  uint32x2_t v10;
  int16x4_t v11;
  int32x2_t v12;
  __int32 v13;
  uint64_t v14;
  int v15;

  v2 = (uint16x4_t)0x100000000;
  v14 = 0x100000000;
  v15 = 1;
  if (*(_WORD *)(a1 + 98))
  {
    v5 = 0;
    v6.i32[0] = a2 & 7;
    v6.i32[1] = a2 >> 3;
    v2.i16[0] = *(_WORD *)(a1 + 96);
    v2.i16[2] = *(_WORD *)(a1 + 98);
    v12 = v6;
    do
    {
      v7 = v2.u16[2];
      if (v2.i16[0])
      {
        v8 = 0;
        do
        {
          v9 = (int8x8_t)vmla_s32((int32x2_t)__PAIR64__(v5, v8), (int32x2_t)v2, v6);
          v10.i32[0] = *(unsigned __int16 *)(a1 + 100);
          v10.i32[1] = *(unsigned __int16 *)(a1 + 102);
          v11 = (int16x4_t)vcgt_u32(v10, (uint32x2_t)vand_s8(v9, (int8x8_t)0xFFFF0000FFFFLL));
          if ((vminv_u16((uint16x4_t)vuzp1_s16(v11, v11)) & 0x8000) != 0)
          {
            HIWORD(v13) = v9.i16[2];
            LOWORD(v13) = v9.i16[0];
            v2 = xdr::compute_luma_gain_histogram_loop<(unsigned short)2,(unsigned short)2,(unsigned short)4>(*(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(float32x4_t **)(a1 + 64), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80) + (a2 << 12), v13, &v14, *(uint16x4_t *)(a1 + 88), *(int8x16_t *)(a1 + 32));
            v6 = v12;
            v2.i16[0] = *(_WORD *)(a1 + 96);
            v2.i16[2] = *(_WORD *)(a1 + 98);
            v7 = v2.u16[2];
          }
          ++v8;
        }
        while ((unsigned __int16)v8 < v2.u16[0]);
      }
      ++v5;
    }
    while ((unsigned __int16)v5 < v7);
  }
}

uint16x4_t xdr::compute_luma_gain_histogram_loop<(unsigned short)2,(unsigned short)2,(unsigned short)4>(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4, uint64_t a5, __int32 a6, _DWORD *a7, uint16x4_t a8, int8x16_t a9)
{
  int v15;
  int32x2_t v16;
  int8x8_t v17;
  uint64_t v18;
  float32x2_t v19;
  int8x8_t v20;
  float32x2_t v21;
  char v22;
  int v29;
  char v30;
  char v31;
  char v32;
  double v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  simd_float4 v42;
  simd_float4 v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  int16x4_t v49;
  uint16x4_t result;
  float32x2_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x2_t v54;
  float32x2_t v55;
  float32x4_t v56;
  float32x4_t v57;
  int8x16_t v58;
  float32x4_t v59;

  v51 = (float32x2_t)a8;
  v15 = 0;
  a8.i32[0] = a6;
  v16 = (int32x2_t)vmovl_u16(a8).u64[0];
  v17 = (int8x8_t)vadd_s32(v16, v16);
  v54 = (float32x2_t)vextq_s8(a9, a9, 8uLL).u64[0];
  v55 = *(float32x2_t *)a9.i8;
  v18 = (uint64_t)&a3[5];
  v19 = 0;
  v20 = (int8x8_t)vdup_n_s32(0x4B400000u);
  v21 = (float32x2_t)vdup_n_s32(0xCB400000);
  v53 = (float32x4_t)vdupq_n_s32(0x3EAAAAABu);
  v22 = 1;
  __asm
  {
    FMOV            V8.2S, #4.0
    FMOV            V0.4S, #1.0
  }
  v52 = _Q0;
  do
  {
    v29 = 0;
    v30 = v22;
    v31 = 1;
    do
    {
      v32 = v31;
      v33 = COERCE_DOUBLE(vmla_f32(v54, vmul_f32(vadd_f32(vadd_f32((float32x2_t)vorr_s8(vand_s8(vorr_s8((int8x8_t)__PAIR64__(v15, v29), v17), (int8x8_t)0xFFFF0000FFFFLL), v20), v21), (float32x2_t)0x3F0000003F000000), _D8), v55));
      xdr::image_sample(a1, a7, v33);
      v56 = v34;
      xdr::image_sample(a2, a7, v33);
      v58 = v35;
      *(double *)v36.i64 = xdr::apply_color_trc((uint64_t)a3, v56);
      *(double *)v37.i64 = xdr::apply_tone_mapping(v18, v36);
      if (!a3[17].i8[0])
        v37 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3[14], v37.f32[0]), a3[15], *(float32x2_t *)v37.f32, 1), a3[16], v37, 2);
      *(double *)v38.i64 = xdr::apply_gain_mapping(a4, v37, (float32x4_t)v58);
      v39 = v38;
      v40 = (float32x4_t)v58;
      if ((*(_DWORD *)a4 - 1) <= 1)
      {
        v41 = vabsq_f32((float32x4_t)v58);
        v41.i32[3] = 0;
        v42 = *(simd_float4 *)(a4 + 16);
        v43 = (simd_float4)vmaxnmq_f32(v41, (float32x4_t)xmmword_18820C0B0);
        v44.i64[0] = 0x8000000080000000;
        v44.i64[1] = 0x8000000080000000;
        v57 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)v58), (int8x16_t)vcgtzq_f32((float32x4_t)v58)), vorrq_s8(vandq_s8(v58, v44), v52), (int8x16_t)0);
        v59 = v39;
        v43.i32[3] = 0;
        v42.i32[3] = 0;
        v45 = (float32x4_t)_simd_pow_f4(v43, v42);
        v39 = v59;
        v40 = vmulq_f32(v57, v45);
      }
      v31 = 0;
      v46 = vmulq_f32(v39, v53);
      v46.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v46, 2), vaddq_f32(v46, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v46.f32, 1))).f32[0];
      v46.f32[0] = v46.f32[0] + (float)((float)(fmaxf(v39.f32[0], fmaxf(v39.f32[1], v39.f32[2])) - v46.f32[0]) * 0.5);
      v47 = vmulq_f32(v40, v53);
      v46.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).u32[0];
      v19 = vadd_f32(v19, *(float32x2_t *)v46.f32);
      v29 = 1;
    }
    while ((v32 & 1) != 0);
    v22 = 0;
    v15 = 1;
  }
  while ((v30 & 1) != 0);
  __asm { FMOV            V0.2S, #0.25 }
  v49 = (int16x4_t)vcvt_n_s32_f32(vmul_f32(vmul_f32(v51, _D0), v19), 5uLL);
  result = vmin_u16((uint16x4_t)vuzp1_s16(v49, v49).u32[0], (uint16x4_t)2031647);
  ++*(_DWORD *)(a5 + ((unint64_t)result.u16[0] << 7) + 4 * result.u16[1]);
  return result;
}

void sub_187ED5778(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v8 = v7;

  _Unwind_Resume(a1);
}

void sub_187ED58A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187ED5910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)HDRImageConverter_Metal;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_187ED59CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187ED5B64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187ED5E10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_187ED625C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_187ED6870(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187ED6AA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187ED6B88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_187ED6C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_187ED6D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_187ED6FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_187ED722C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_187ED7464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_187ED760C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_187ED772C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_187ED786C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_187ED78E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187ED7B78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187ED80D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,uint64_t a27,void *a28,void *a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36)
{
  void *v36;

  _Unwind_Resume(a1);
}

void sub_187ED87F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30,uint64_t a31,void *a32,void *a33,void *a34,void *a35,uint64_t a36,uint64_t a37,void *a38,void *a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,void *a46)
{
  void *v46;

  _Unwind_Resume(a1);
}

void sub_187ED8FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,void *a35,void *a36,uint64_t a37,void *a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,void *a50,void *a51,void *a52)
{
  void *v52;

  _Unwind_Resume(a1);
}

void sub_187ED98F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,void *a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,void *a58,void *a59,void *a60,void *a61,void *a62,void *a63)
{
  void *a64;
  void *v64;

  _Unwind_Resume(a1);
}

void sub_187ED9F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,uint64_t a23,void *a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36)
{
  void *v36;

  _Unwind_Resume(a1);
}

void sub_187EDA50C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_187EDA658(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void sub_187EDA6FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187EDA814(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187EDAC10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void sub_187EDADE4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v4;

  _Unwind_Resume(a1);
}

void sub_187EDAE9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_187EDAFAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_187EDB404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35)
{
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;

  _Unwind_Resume(a1);
}

void sub_187EDB52C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_187EDB644(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187EDB768(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187EDB860(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_187EDB8FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EDB994(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EDBD80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_187EDBE84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{

  _Unwind_Resume(a1);
}

void sub_187EDBF14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_187EDBF9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_187EDC024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_187EDC0B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{

  _Unwind_Resume(a1);
}

void sub_187EDC150(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_187EDC538(_Unwind_Exception *a1)
{

  _Unwind_Resume(a1);
}

uint64_t _cg_jinit_huff_encoder(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  _OWORD *v4;

  result = (**(uint64_t (***)(void))(a1 + 8))();
  v3 = 0;
  *(_QWORD *)(a1 + 560) = result;
  *(_QWORD *)result = start_pass_huff;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  do
  {
    v4 = (_OWORD *)(result + v3);
    v4[6] = 0uLL;
    v4[10] = 0uLL;
    v4[8] = 0uLL;
    v3 += 16;
  }
  while (v3 != 32);
  if (*(_DWORD *)(a1 + 348))
    *(_QWORD *)(result + 240) = 0;
  return result;
}

void start_pass_huff(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t (*v5)(uint64_t *, uint64_t);
  int v6;
  void *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  signed int v11;
  uint64_t v12;
  void (**v13)(_QWORD);
  uint64_t v14;
  void *v15;
  _QWORD *v16;
  void *v17;
  signed int v18;
  uint64_t v19;
  void (**v20)(_QWORD);
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *v24;

  v4 = *(_QWORD *)(a1 + 560);
  if (a2)
  {
    *(_QWORD *)(v4 + 16) = finish_pass_gather;
    if (!*(_DWORD *)(a1 + 348))
    {
      v5 = encode_mcu_gather;
LABEL_13:
      *(_QWORD *)(v4 + 8) = v5;
      goto LABEL_17;
    }
  }
  else
  {
    *(_QWORD *)(v4 + 16) = finish_pass_huff;
    if (!*(_DWORD *)(a1 + 348))
    {
      v5 = encode_mcu_huff;
      goto LABEL_13;
    }
  }
  *(_QWORD *)(v4 + 216) = a1;
  *(_DWORD *)(v4 + 192) = a2;
  v6 = *(_DWORD *)(a1 + 460);
  if (*(_DWORD *)(a1 + 468))
  {
    if (v6)
    {
      *(_QWORD *)(v4 + 8) = encode_mcu_AC_refine;
      if (!*(_QWORD *)(v4 + 240))
        *(_QWORD *)(v4 + 240) = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1000);
      goto LABEL_16;
    }
    v7 = encode_mcu_DC_refine;
  }
  else if (v6)
  {
    v7 = encode_mcu_AC_first;
  }
  else
  {
    v7 = encode_mcu_DC_first;
  }
  *(_QWORD *)(v4 + 8) = v7;
LABEL_16:
  v8 = *(_DWORD *)(*(_QWORD *)(a1 + 376) + 24);
  *(_DWORD *)(v4 + 228) = 0;
  *(_DWORD *)(v4 + 232) = 0;
  *(_DWORD *)(v4 + 224) = v8;
LABEL_17:
  if (*(int *)(a1 + 372) >= 1)
  {
    v9 = 0;
    do
    {
      v10 = *(_QWORD *)(a1 + 8 * v9 + 376);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468))
      {
        v11 = *(_DWORD *)(v10 + 20);
        v12 = v11;
        if (a2)
        {
          if (v11 >= 4)
          {
            v13 = *(void (***)(_QWORD))a1;
            *((_DWORD *)v13 + 10) = 52;
            *((_DWORD *)v13 + 12) = v11;
            (**(void (***)(uint64_t))a1)(a1);
          }
          v14 = v4 + 8 * v12;
          v17 = *(void **)(v14 + 128);
          v16 = (_QWORD *)(v14 + 128);
          v15 = v17;
          if (!v17)
          {
            v15 = (void *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2056);
            *v16 = v15;
          }
          bzero(v15, 0x808uLL);
        }
        else
        {
          jpeg_make_c_derived_tbl(a1, 1, v11, (_QWORD *)(v4 + 8 * v11 + 64));
        }
        *(_DWORD *)(v4 + 36 + 4 * v9) = 0;
      }
      if (*(_DWORD *)(a1 + 464))
      {
        v18 = *(_DWORD *)(v10 + 24);
        v19 = v18;
        if (a2)
        {
          if (v18 >= 4)
          {
            v20 = *(void (***)(_QWORD))a1;
            *((_DWORD *)v20 + 10) = 52;
            *((_DWORD *)v20 + 12) = v18;
            (**(void (***)(uint64_t))a1)(a1);
          }
          v21 = v4 + 8 * v19;
          v24 = *(void **)(v21 + 160);
          v23 = (_QWORD *)(v21 + 160);
          v22 = v24;
          if (!v24)
          {
            v22 = (void *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2056);
            *v23 = v22;
          }
          bzero(v22, 0x808uLL);
        }
        else
        {
          jpeg_make_c_derived_tbl(a1, 0, v18, (_QWORD *)(v4 + 8 * v18 + 96));
        }
      }
      ++v9;
    }
    while (v9 < *(int *)(a1 + 372));
  }
  *(_QWORD *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 32) = 0;
  *(_QWORD *)(v4 + 56) = *(unsigned int *)(a1 + 316);
}

void finish_pass_gather(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[2];
  _QWORD v17[3];

  v17[2] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 560);
  if (*(_DWORD *)(a1 + 348))
    emit_eobrun(*(_QWORD *)(a1 + 560));
  v17[0] = 0;
  v17[1] = 0;
  v16[0] = 0;
  v16[1] = 0;
  if (*(int *)(a1 + 372) >= 1)
  {
    v3 = 47;
    do
    {
      v4 = *(_QWORD *)(a1 + 8 * v3);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468))
      {
        v5 = *(int *)(v4 + 20);
        if (!*((_DWORD *)v17 + v5))
        {
          v6 = a1 + 8 * v5;
          v9 = *(_QWORD *)(v6 + 160);
          v8 = (uint64_t *)(v6 + 160);
          v7 = v9;
          if (!v9)
          {
            v7 = _cg_jpeg_alloc_huff_table(a1);
            *v8 = v7;
          }
          jpeg_gen_optimal_table((uint64_t *)a1, v7, *(_QWORD *)(v2 + 8 * v5 + 128));
          *((_DWORD *)v17 + v5) = 1;
        }
      }
      if (*(_DWORD *)(a1 + 464))
      {
        v10 = *(int *)(v4 + 24);
        if (!*((_DWORD *)v16 + v10))
        {
          v11 = a1 + 8 * v10;
          v14 = *(_QWORD *)(v11 + 192);
          v13 = (uint64_t *)(v11 + 192);
          v12 = v14;
          if (!v14)
          {
            v12 = _cg_jpeg_alloc_huff_table(a1);
            *v13 = v12;
          }
          jpeg_gen_optimal_table((uint64_t *)a1, v12, *(_QWORD *)(v2 + 8 * v10 + 160));
          *((_DWORD *)v16 + v10) = 1;
        }
      }
      v15 = v3 - 46;
      ++v3;
    }
    while (v15 < *(int *)(a1 + 372));
  }
}

__n128 finish_pass_huff(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  __n128 result;
  _QWORD *v6;
  uint64_t v7;
  __n128 v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __n128 v15;
  uint64_t *v16;

  v2 = a1[70];
  v3 = (uint64_t *)a1[5];
  v4 = *v3;
  if (*((_DWORD *)a1 + 87))
  {
    *(_QWORD *)(v2 + 200) = v4;
    *(_QWORD *)(v2 + 208) = v3[1];
    emit_eobrun(v2);
    flush_bits_e(v2);
    v6 = (_QWORD *)a1[5];
    *v6 = *(_QWORD *)(v2 + 200);
    v6[1] = *(_QWORD *)(v2 + 208);
  }
  else
  {
    v7 = v3[1];
    v12 = v4;
    v13 = v7;
    v8 = *(__n128 *)(v2 + 40);
    v14 = *(_OWORD *)(v2 + 24);
    v15 = v8;
    v16 = a1;
    if (!flush_bits_s((uint64_t)&v12))
    {
      v9 = *a1;
      *(_DWORD *)(v9 + 40) = 25;
      (*(void (**)(uint64_t *))v9)(a1);
    }
    v10 = (_QWORD *)a1[5];
    v11 = v13;
    *v10 = v12;
    v10[1] = v11;
    result = v15;
    *(_OWORD *)(v2 + 24) = v14;
    *(__n128 *)(v2 + 40) = result;
  }
  return result;
}

uint64_t encode_mcu_DC_first(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  _BYTE *v30;
  uint64_t v31;
  int v32;
  uint64_t *v33;
  uint64_t v34;
  int v35;
  unint64_t v36;
  _BYTE *v37;
  uint64_t v38;
  _BYTE *v39;
  uint64_t v40;
  int v41;
  _QWORD *v42;
  uint64_t v43;
  int v44;
  int v45;

  v4 = a1[70];
  v5 = (uint64_t *)a1[5];
  v7 = *v5;
  v6 = v5[1];
  *(_QWORD *)(v4 + 200) = v7;
  *(_QWORD *)(v4 + 208) = v6;
  if (*((_DWORD *)a1 + 79) && !*(_DWORD *)(v4 + 56))
    emit_restart_e(v4, *(_DWORD *)(v4 + 60));
  if (*((int *)a1 + 104) >= 1)
  {
    v8 = 0;
    do
    {
      v9 = *((int *)a1 + v8 + 105);
      v10 = *(int *)(a1[v9 + 47] + 20);
      v11 = **(__int16 **)(a2 + 8 * v8) >> *((_DWORD *)a1 + 118);
      v12 = v4 + 4 * v9;
      v13 = *(_DWORD *)(v12 + 36);
      *(_DWORD *)(v12 + 36) = v11;
      v14 = v11 - v13;
      if (v11 == v13)
      {
        v15 = 0;
      }
      else
      {
        if (v14 >= 0)
          v16 = v11 - v13;
        else
          v16 = v13 - v11;
        v17 = -1;
        do
        {
          ++v17;
          v18 = v16 > 1;
          v16 >>= 1;
        }
        while (v18);
        v15 = v17 + 1;
        if (v17 >= 0xB)
        {
          v19 = *a1;
          *(_DWORD *)(v19 + 40) = 6;
          (*(void (**)(uint64_t *))v19)(a1);
        }
      }
      v20 = v15;
      if (*(_DWORD *)(v4 + 192))
      {
        ++*(_QWORD *)(*(_QWORD *)(v4 + 8 * v10 + 128) + 8 * v15);
      }
      else
      {
        v21 = *(_QWORD *)(v4 + 8 * v10 + 64);
        v22 = *(_DWORD *)(v21 + 4 * v15);
        v23 = v21 + v15;
        v24 = *(char *)(v23 + 1024);
        if (*(_BYTE *)(v23 + 1024)
          || (v33 = *(uint64_t **)(v4 + 216),
              v34 = *v33,
              *(_DWORD *)(v34 + 40) = 41,
              (*(void (**)(uint64_t *))v34)(v33),
              !*(_DWORD *)(v4 + 192)))
        {
          v25 = ~(-1 << v24) & v22;
          v26 = *(_DWORD *)(v4 + 32) + v24;
          v27 = (v25 << (24 - (*(_BYTE *)(v4 + 32) + v24))) | *(_QWORD *)(v4 + 24);
          if (v26 < 8)
          {
            v32 = v26;
          }
          else
          {
            do
            {
              v28 = *(_BYTE **)(v4 + 200);
              *(_QWORD *)(v4 + 200) = v28 + 1;
              *v28 = BYTE2(v27);
              v29 = *(_QWORD *)(v4 + 208) - 1;
              *(_QWORD *)(v4 + 208) = v29;
              if (!v29)
                dump_buffer_e((_QWORD *)v4);
              if ((~(_DWORD)v27 & 0xFF0000) == 0)
              {
                v30 = *(_BYTE **)(v4 + 200);
                *(_QWORD *)(v4 + 200) = v30 + 1;
                *v30 = 0;
                v31 = *(_QWORD *)(v4 + 208) - 1;
                *(_QWORD *)(v4 + 208) = v31;
                if (!v31)
                  dump_buffer_e((_QWORD *)v4);
              }
              v27 <<= 8;
              v32 = v26 - 8;
              v18 = v26 <= 15;
              v26 -= 8;
            }
            while (!v18);
          }
          *(_QWORD *)(v4 + 24) = v27;
          *(_DWORD *)(v4 + 32) = v32;
        }
      }
      if (v20 && !*(_DWORD *)(v4 + 192))
      {
        v35 = *(_DWORD *)(v4 + 32) + v20;
        v36 = ((unint64_t)(~(-1 << v20) & (v14 + (v14 >> 31))) << (24
                                                                                      - (*(_BYTE *)(v4 + 32)
                                                                                       + v20))) | *(_QWORD *)(v4 + 24);
        if (v35 < 8)
        {
          v41 = *(_DWORD *)(v4 + 32) + v20;
        }
        else
        {
          do
          {
            v37 = *(_BYTE **)(v4 + 200);
            *(_QWORD *)(v4 + 200) = v37 + 1;
            *v37 = BYTE2(v36);
            v38 = *(_QWORD *)(v4 + 208) - 1;
            *(_QWORD *)(v4 + 208) = v38;
            if (!v38)
              dump_buffer_e((_QWORD *)v4);
            if ((~(_DWORD)v36 & 0xFF0000) == 0)
            {
              v39 = *(_BYTE **)(v4 + 200);
              *(_QWORD *)(v4 + 200) = v39 + 1;
              *v39 = 0;
              v40 = *(_QWORD *)(v4 + 208) - 1;
              *(_QWORD *)(v4 + 208) = v40;
              if (!v40)
                dump_buffer_e((_QWORD *)v4);
            }
            v36 <<= 8;
            v41 = v35 - 8;
            v18 = v35 <= 15;
            v35 -= 8;
          }
          while (!v18);
        }
        *(_QWORD *)(v4 + 24) = v36;
        *(_DWORD *)(v4 + 32) = v41;
      }
      ++v8;
    }
    while (v8 < *((int *)a1 + 104));
  }
  v42 = (_QWORD *)a1[5];
  v43 = *(_QWORD *)(v4 + 208);
  *v42 = *(_QWORD *)(v4 + 200);
  v42[1] = v43;
  v44 = *((_DWORD *)a1 + 79);
  if (v44)
  {
    v45 = *(_DWORD *)(v4 + 56);
    if (!v45)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      v45 = v44;
    }
    *(_DWORD *)(v4 + 56) = v45 - 1;
  }
  return 1;
}

uint64_t encode_mcu_AC_first(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  BOOL v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  _BYTE *v25;
  uint64_t v26;
  _BYTE *v27;
  uint64_t v28;
  int v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;
  int v33;
  int v34;

  v4 = a1[70];
  v5 = (uint64_t *)a1[5];
  v7 = *v5;
  v6 = v5[1];
  *(_QWORD *)(v4 + 200) = v7;
  *(_QWORD *)(v4 + 208) = v6;
  if (*((_DWORD *)a1 + 79) && !*(_DWORD *)(v4 + 56))
    emit_restart_e(v4, *(_DWORD *)(v4 + 60));
  v8 = *((_DWORD *)a1 + 116);
  v9 = *((int *)a1 + 115);
  if ((int)v9 <= v8)
  {
    v10 = 0;
    v11 = *((_DWORD *)a1 + 118);
    v12 = a1[60];
    v13 = v8 + 1;
    v14 = *a2;
    do
    {
      v15 = *(__int16 *)(v14 + 2 * *(int *)(v12 + 4 * v9));
      if (*(_WORD *)(v14 + 2 * *(int *)(v12 + 4 * v9))
        && (v15 >= 0 ? (v16 = v15 >> v11) : (v16 = -v15 >> v11),
            v15 < 0 ? (v17 = ~(-v15 >> v11)) : (v17 = v15 >> v11),
            v16))
      {
        if (*(_DWORD *)(v4 + 228))
          emit_eobrun(v4);
        if (v10 >= 16)
        {
          do
          {
            emit_ac_symbol(v4, *(_DWORD *)(v4 + 224), 240);
            v18 = v10 > 0x1F;
            v10 -= 16;
          }
          while (v18);
        }
        if (v16 >= 2)
        {
          v20 = 0;
          do
          {
            ++v20;
            v18 = v16 > 3;
            v16 >>= 1;
          }
          while (v18);
          v19 = v20 + 1;
          if (v20 >= 0xA)
          {
            v21 = *a1;
            *(_DWORD *)(v21 + 40) = 6;
            (*(void (**)(uint64_t *))v21)(a1);
          }
        }
        else
        {
          v19 = 1;
        }
        emit_ac_symbol(v4, *(_DWORD *)(v4 + 224), v19 + 16 * v10);
        if (*(_DWORD *)(v4 + 192))
        {
          v10 = 0;
        }
        else
        {
          v22 = ~(-1 << v19) & v17;
          v23 = *(_DWORD *)(v4 + 32) + v19;
          v24 = (v22 << (24 - (*(_BYTE *)(v4 + 32) + v19))) | *(_QWORD *)(v4 + 24);
          if (v23 < 8)
          {
            v29 = v23;
          }
          else
          {
            do
            {
              v25 = *(_BYTE **)(v4 + 200);
              *(_QWORD *)(v4 + 200) = v25 + 1;
              *v25 = BYTE2(v24);
              v26 = *(_QWORD *)(v4 + 208) - 1;
              *(_QWORD *)(v4 + 208) = v26;
              if (!v26)
                dump_buffer_e((_QWORD *)v4);
              if ((~(_DWORD)v24 & 0xFF0000) == 0)
              {
                v27 = *(_BYTE **)(v4 + 200);
                *(_QWORD *)(v4 + 200) = v27 + 1;
                *v27 = 0;
                v28 = *(_QWORD *)(v4 + 208) - 1;
                *(_QWORD *)(v4 + 208) = v28;
                if (!v28)
                  dump_buffer_e((_QWORD *)v4);
              }
              v24 <<= 8;
              v29 = v23 - 8;
              v18 = v23 <= 15;
              v23 -= 8;
            }
            while (!v18);
          }
          v10 = 0;
          *(_QWORD *)(v4 + 24) = v24;
          *(_DWORD *)(v4 + 32) = v29;
        }
      }
      else
      {
        ++v10;
      }
      ++v9;
    }
    while (v13 != (_DWORD)v9);
    if (v10 >= 1)
    {
      v30 = *(_DWORD *)(v4 + 228) + 1;
      *(_DWORD *)(v4 + 228) = v30;
      if (v30 == 0x7FFF)
        emit_eobrun(v4);
    }
  }
  v31 = (_QWORD *)a1[5];
  v32 = *(_QWORD *)(v4 + 208);
  *v31 = *(_QWORD *)(v4 + 200);
  v31[1] = v32;
  v33 = *((_DWORD *)a1 + 79);
  if (v33)
  {
    v34 = *(_DWORD *)(v4 + 56);
    if (!v34)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      v34 = v33;
    }
    *(_DWORD *)(v4 + 56) = v34 - 1;
  }
  return 1;
}

uint64_t encode_mcu_DC_refine(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  _BYTE *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  int v18;
  _QWORD *v19;
  uint64_t v20;
  int v21;
  int v22;

  v4 = *(_QWORD *)(a1 + 560);
  v5 = *(uint64_t **)(a1 + 40);
  v7 = *v5;
  v6 = v5[1];
  *(_QWORD *)(v4 + 200) = v7;
  *(_QWORD *)(v4 + 208) = v6;
  if (*(_DWORD *)(a1 + 316) && !*(_DWORD *)(v4 + 56))
    emit_restart_e(v4, *(_DWORD *)(v4 + 60));
  v8 = *(_DWORD *)(a1 + 416);
  if (v8 >= 1)
  {
    v9 = 0;
    v10 = *(_DWORD *)(a1 + 472);
    do
    {
      if (!*(_DWORD *)(v4 + 192))
      {
        v11 = *(_DWORD *)(v4 + 32);
        v12 = ((unint64_t)((**(__int16 **)(a2 + 8 * v9) >> v10) & 1) << (23 - v11)) | *(_QWORD *)(v4 + 24);
        if (v11 < 7)
        {
          v18 = v11 + 1;
        }
        else
        {
          v13 = v11 + 9;
          do
          {
            v14 = *(_BYTE **)(v4 + 200);
            *(_QWORD *)(v4 + 200) = v14 + 1;
            *v14 = BYTE2(v12);
            v15 = *(_QWORD *)(v4 + 208) - 1;
            *(_QWORD *)(v4 + 208) = v15;
            if (!v15)
              dump_buffer_e((_QWORD *)v4);
            if ((~(_DWORD)v12 & 0xFF0000) == 0)
            {
              v16 = *(_BYTE **)(v4 + 200);
              *(_QWORD *)(v4 + 200) = v16 + 1;
              *v16 = 0;
              v17 = *(_QWORD *)(v4 + 208) - 1;
              *(_QWORD *)(v4 + 208) = v17;
              if (!v17)
                dump_buffer_e((_QWORD *)v4);
            }
            v12 <<= 8;
            v13 -= 8;
          }
          while (v13 > 15);
          v8 = *(_DWORD *)(a1 + 416);
          v18 = v13 - 8;
        }
        *(_QWORD *)(v4 + 24) = v12;
        *(_DWORD *)(v4 + 32) = v18;
      }
      ++v9;
    }
    while (v9 < v8);
  }
  v19 = *(_QWORD **)(a1 + 40);
  v20 = *(_QWORD *)(v4 + 208);
  *v19 = *(_QWORD *)(v4 + 200);
  v19[1] = v20;
  v21 = *(_DWORD *)(a1 + 316);
  if (v21)
  {
    v22 = *(_DWORD *)(v4 + 56);
    if (!v22)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      v22 = v21;
    }
    *(_DWORD *)(v4 + 56) = v22 - 1;
  }
  return 1;
}

uint64_t encode_mcu_AC_refine(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int *v15;
  unsigned int *v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  _BYTE *v21;
  int v22;
  unsigned int v23;
  BOOL v24;
  int v25;
  unint64_t v26;
  int v27;
  _BYTE *v28;
  uint64_t v29;
  _BYTE *v30;
  uint64_t v31;
  int v32;
  int v33;
  unsigned int v34;
  _QWORD *v35;
  int v36;
  int v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _OWORD v42[16];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 560);
  v5 = *(_QWORD **)(a1 + 40);
  *(_QWORD *)(v4 + 200) = *v5;
  *(_QWORD *)(v4 + 208) = v5[1];
  if (*(_DWORD *)(a1 + 316) && !*(_DWORD *)(v4 + 56))
    emit_restart_e(v4, *(_DWORD *)(v4 + 60));
  v6 = *(_DWORD *)(a1 + 464);
  v7 = *(_DWORD *)(a1 + 460);
  v39 = a1;
  if (v7 <= v6)
  {
    v10 = 0;
    v11 = *(_DWORD *)(a1 + 472);
    v12 = *a2;
    v13 = v7;
    v14 = v6 + 1;
    v40 = *(_QWORD *)(a1 + 480);
    v15 = (int *)(v40 + 4 * v7);
    v16 = (unsigned int *)v42 + v7;
    memset(v42, 0, sizeof(v42));
    do
    {
      v17 = *v15++;
      v18 = *(__int16 *)(v12 + 2 * v17);
      if (v18 < 0)
        v18 = -v18;
      v19 = v18 >> v11;
      *v16++ = v19;
      if (v19 == 1)
        v10 = v7;
      ++v7;
    }
    while (v14 != v7);
    v9 = 0;
    v20 = 0;
    v41 = v10;
    v21 = (_BYTE *)(*(_QWORD *)(v4 + 240) + *(unsigned int *)(v4 + 232));
    do
    {
      v22 = *((_DWORD *)v42 + v13);
      if (v22)
      {
        if ((int)v20 < 16)
        {
          v8 = v20;
          v23 = v9;
        }
        else
        {
          v8 = v20;
          v23 = v9;
          if (v13 <= v41)
          {
            do
            {
              emit_eobrun(v4);
              emit_ac_symbol(v4, *(_DWORD *)(v4 + 224), 240);
              v8 = (v20 - 16);
              emit_buffered_bits(v4, v21, v9);
              v9 = 0;
              v23 = 0;
              v21 = *(_BYTE **)(v4 + 240);
              v24 = v20 > 0x1F;
              LODWORD(v20) = v20 - 16;
            }
            while (v24);
          }
        }
        if (v22 < 2)
        {
          emit_eobrun(v4);
          emit_ac_symbol(v4, *(_DWORD *)(v4 + 224), (16 * v8) | 1);
          if (!*(_DWORD *)(v4 + 192))
          {
            v25 = *(_DWORD *)(v4 + 32);
            v26 = ((unint64_t)((*(unsigned __int16 *)(v12 + 2 * *(int *)(v40 + 4 * v13)) >> 15) ^ 1u) << (23 - v25)) | *(_QWORD *)(v4 + 24);
            if (v25 < 7)
            {
              v32 = v25 + 1;
            }
            else
            {
              v27 = v25 + 9;
              do
              {
                v28 = *(_BYTE **)(v4 + 200);
                *(_QWORD *)(v4 + 200) = v28 + 1;
                *v28 = BYTE2(v26);
                v29 = *(_QWORD *)(v4 + 208) - 1;
                *(_QWORD *)(v4 + 208) = v29;
                if (!v29)
                  dump_buffer_e((_QWORD *)v4);
                if ((~(_DWORD)v26 & 0xFF0000) == 0)
                {
                  v30 = *(_BYTE **)(v4 + 200);
                  *(_QWORD *)(v4 + 200) = v30 + 1;
                  *v30 = 0;
                  v31 = *(_QWORD *)(v4 + 208) - 1;
                  *(_QWORD *)(v4 + 208) = v31;
                  if (!v31)
                    dump_buffer_e((_QWORD *)v4);
                }
                v26 <<= 8;
                v27 -= 8;
              }
              while (v27 > 15);
              v32 = v27 - 8;
            }
            *(_QWORD *)(v4 + 24) = v26;
            *(_DWORD *)(v4 + 32) = v32;
          }
          emit_buffered_bits(v4, v21, v23);
          v8 = 0;
          v9 = 0;
          v21 = *(_BYTE **)(v4 + 240);
        }
        else
        {
          v9 = v23 + 1;
          v21[v23] = v22 & 1;
        }
      }
      else
      {
        v8 = (v20 + 1);
      }
      ++v13;
      v20 = v8;
    }
    while (v14 != (_DWORD)v13);
  }
  else
  {
    LODWORD(v8) = 0;
    v9 = 0;
  }
  if ((int)v8 > 0 || v9)
  {
    v33 = *(_DWORD *)(v4 + 228) + 1;
    v34 = *(_DWORD *)(v4 + 232) + v9;
    *(_DWORD *)(v4 + 228) = v33;
    *(_DWORD *)(v4 + 232) = v34;
    if (v33 == 0x7FFF || v34 >= 0x3AA)
      emit_eobrun(v4);
  }
  v35 = *(_QWORD **)(v39 + 40);
  *v35 = *(_QWORD *)(v4 + 200);
  v35[1] = *(_QWORD *)(v4 + 208);
  v36 = *(_DWORD *)(v39 + 316);
  if (v36)
  {
    v37 = *(_DWORD *)(v4 + 56);
    if (!v37)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      v37 = v36;
    }
    *(_DWORD *)(v4 + 56) = v37 - 1;
  }
  return 1;
}

uint64_t encode_mcu_gather(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int16 *v9;
  uint64_t v10;
  _DWORD *v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  BOOL v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  signed int v26;
  int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v33;
  uint64_t v34;

  v3 = a1[70];
  if (*((_DWORD *)a1 + 79))
  {
    v4 = *(_DWORD *)(v3 + 56);
    if (!v4)
    {
      if (*((int *)a1 + 93) < 1)
      {
        v4 = *((_DWORD *)a1 + 79);
      }
      else
      {
        v5 = 0;
        do
          *(_DWORD *)(v3 + 36 + 4 * v5++) = 0;
        while (v5 < *((int *)a1 + 93));
        v4 = *((_DWORD *)a1 + 79);
      }
    }
    *(_DWORD *)(v3 + 56) = v4 - 1;
  }
  if (*((int *)a1 + 104) >= 1)
  {
    v6 = 0;
    v33 = v3;
    v34 = a2;
    do
    {
      v7 = *((int *)a1 + v6 + 105);
      v8 = a1[v7 + 47];
      v9 = *(__int16 **)(a2 + 8 * v6);
      v10 = v3 + 4 * v7;
      v12 = *(_DWORD *)(v10 + 36);
      v11 = (_DWORD *)(v10 + 36);
      v13 = *(_QWORD *)(v3 + 8 * *(int *)(v8 + 20) + 128);
      v14 = *(_QWORD **)(v3 + 8 * *(int *)(v8 + 24) + 160);
      v15 = *((unsigned int *)a1 + 122);
      v16 = a1[60];
      LODWORD(v8) = *v9;
      v17 = v8 - v12;
      if ((_DWORD)v8 == v12)
      {
        v18 = 0;
      }
      else
      {
        if (v17 >= 0)
          v19 = v17;
        else
          v19 = -v17;
        v20 = -1;
        do
        {
          ++v20;
          v21 = v19 > 1;
          v19 >>= 1;
        }
        while (v21);
        v18 = v20 + 1;
        if (v20 >= 0xB)
        {
          v22 = *a1;
          *(_DWORD *)(v22 + 40) = 6;
          (*(void (**)(uint64_t *))v22)(a1);
        }
      }
      ++*(_QWORD *)(v13 + 8 * v18);
      if ((int)v15 >= 1)
      {
        v23 = 0;
        v24 = v15 + 1;
        v25 = 1;
        do
        {
          while (1)
          {
            v26 = v23;
            LOWORD(v23) = v9[*(int *)(v16 + 4 * v25)];
            if (!(_WORD)v23)
              break;
            if (v26 >= 16)
            {
              if (v26 >= 31)
                v27 = 31;
              else
                v27 = v26;
              v28 = v26 - v27 + 15;
              v26 = v26 - (v28 & 0xFFFFFFF0) - 16;
              v14[240] += (v28 >> 4) + 1;
            }
            if ((v23 & 0x8000u) != 0)
              v23 = -(__int16)v23;
            v23 = (unsigned __int16)v23;
            if ((unsigned __int16)v23 >= 2u)
            {
              v30 = 0;
              do
              {
                ++v30;
                v21 = v23 > 3;
                v23 >>= 1;
              }
              while (v21);
              v29 = v30 + 1;
              if (v30 >= 0xA)
              {
                v31 = *a1;
                *(_DWORD *)(v31 + 40) = 6;
                (*(void (**)(uint64_t *))v31)(a1);
              }
            }
            else
            {
              v29 = 1;
            }
            v23 = 0;
            ++v14[16 * v26 + v29];
            if (++v25 == v24)
              goto LABEL_42;
          }
          v23 = v26 + 1;
          ++v25;
        }
        while (v25 != v24);
        if ((v26 & 0x80000000) == 0)
          ++*v14;
      }
LABEL_42:
      v3 = v33;
      a2 = v34;
      *v11 = **(__int16 **)(v34 + 8 * v6++);
    }
    while (v6 < *((int *)a1 + 104));
  }
  return 1;
}

uint64_t encode_mcu_huff(uint64_t *a1, uint64_t a2)
{
  int *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int16 *v10;
  char *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  BOOL v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  uint64_t result;
  _BYTE *v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  int v35;
  _BYTE *v36;
  uint64_t v37;
  _BYTE *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  int v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  _BYTE *v52;
  uint64_t *v53;
  uint64_t v54;
  _BYTE *v55;
  uint64_t *v56;
  uint64_t v57;
  int v58;
  unsigned int v59;
  int v60;
  unsigned int v61;
  uint64_t *v62;
  uint64_t v63;
  int v64;
  unsigned int v65;
  uint64_t v66;
  int v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int v71;
  unint64_t v72;
  _BYTE *v73;
  uint64_t *v74;
  uint64_t v75;
  _BYTE *v76;
  uint64_t *v77;
  uint64_t v78;
  unsigned int v79;
  unsigned int v80;
  _BYTE *v81;
  uint64_t *v82;
  uint64_t v83;
  _BYTE *v84;
  uint64_t *v85;
  uint64_t v86;
  BOOL v87;
  unsigned int v88;
  int v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  unint64_t v94;
  _BYTE *v95;
  uint64_t *v96;
  uint64_t v97;
  _BYTE *v98;
  uint64_t *v99;
  uint64_t v100;
  int v101;
  _QWORD *v102;
  __int128 v103;
  int v104;
  int v105;
  int v106;
  _BYTE *v107;
  _BYTE *v108;
  uint64_t v109;
  int *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t *v114;
  uint64_t v115;
  _DWORD *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unsigned int *v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  uint64_t *v124;

  v3 = (int *)a1;
  v4 = a1[70];
  v124 = 0;
  v122 = 0u;
  v123 = 0u;
  v121 = 0u;
  v5 = (_QWORD *)a1[5];
  v6 = v5[1];
  *(_QWORD *)&v121 = *v5;
  *((_QWORD *)&v121 + 1) = v6;
  v7 = *(_OWORD *)(v4 + 40);
  v122 = *(_OWORD *)(v4 + 24);
  v123 = v7;
  v124 = a1;
  if (*((_DWORD *)a1 + 79) && !*(_DWORD *)(v4 + 56))
  {
    v106 = *(_DWORD *)(v4 + 60);
    result = flush_bits_s((uint64_t)&v121);
    if (!(_DWORD)result)
      return result;
    v107 = (_BYTE *)v121;
    *(_QWORD *)&v121 = v121 + 1;
    *v107 = -1;
    if (--*((_QWORD *)&v121 + 1))
    {
      v108 = (_BYTE *)v121;
    }
    else
    {
      v109 = v124[5];
      result = (*(uint64_t (**)(void))(v109 + 24))();
      if (!(_DWORD)result)
        return result;
      v108 = *(_BYTE **)v109;
      *((_QWORD *)&v121 + 1) = *(_QWORD *)(v109 + 8);
    }
    *(_QWORD *)&v121 = v108 + 1;
    *v108 = v106 - 48;
    v110 = (int *)v124;
    v6 = --*((_QWORD *)&v121 + 1);
    if (!*((_QWORD *)&v121 + 1))
    {
      v111 = v124[5];
      result = (*(uint64_t (**)(uint64_t *))(v111 + 24))(v124);
      if (!(_DWORD)result)
        return result;
      v6 = *(_QWORD *)(v111 + 8);
      *(_QWORD *)&v121 = *(_QWORD *)v111;
      *((_QWORD *)&v121 + 1) = v6;
    }
    if (v110[93] >= 1)
    {
      v112 = 0;
      do
        *((_DWORD *)&v122 + v112++ + 3) = 0;
      while (v112 < v110[93]);
    }
  }
  if (v3[104] >= 1)
  {
    v8 = 0;
    v115 = a2;
    do
    {
      v9 = v3[v8 + 105];
      v117 = v8;
      v10 = *(__int16 **)(a2 + 8 * v8);
      v11 = (char *)&v121 + 4 * v9;
      v12 = *((_DWORD *)v11 + 7);
      v116 = v11 + 28;
      v13 = *(_QWORD *)&v3[2 * v9 + 94];
      v14 = *(_QWORD *)(v4 + 8 * *(int *)(v13 + 20) + 64);
      v15 = v124;
      v119 = *((unsigned int *)v124 + 122);
      v120 = *(unsigned int **)(v4 + 8 * *(int *)(v13 + 24) + 96);
      v118 = v124[60];
      LODWORD(v13) = *v10;
      v16 = v13 - v12;
      if ((_DWORD)v13 == v12)
      {
        v17 = 0;
      }
      else
      {
        if (v16 >= 0)
          v18 = v16;
        else
          v18 = -v16;
        v19 = -1;
        do
        {
          ++v19;
          v20 = v18 > 1;
          v18 >>= 1;
        }
        while (v20);
        v17 = v19 + 1;
        if (v19 >= 0xB)
        {
          v21 = *v124;
          *(_DWORD *)(v21 + 40) = 6;
          (*(void (**)(uint64_t *))v21)(v15);
        }
      }
      v22 = *(_DWORD *)(v14 + 4 * v17);
      v23 = v14 + v17;
      v24 = *(char *)(v23 + 1024);
      if (!*(_BYTE *)(v23 + 1024))
      {
        v25 = *v15;
        *(_DWORD *)(v25 + 40) = 41;
        (*(void (**)(uint64_t *))v25)(v15);
      }
      v26 = DWORD2(v122) + v24;
      v27 = ((unint64_t)(~(-1 << v24) & v22) << (24 - (BYTE8(v122) + v24))) | v122;
      if (DWORD2(v122) + v24 < 8)
      {
        v33 = DWORD2(v122) + v24;
      }
      else
      {
        do
        {
          v28 = (_BYTE *)v121;
          *(_QWORD *)&v121 = v121 + 1;
          *v28 = BYTE2(v27);
          v6 = --*((_QWORD *)&v121 + 1);
          if (!*((_QWORD *)&v121 + 1))
          {
            v29 = v124[5];
            result = (*(uint64_t (**)(void))(v29 + 24))();
            if (!(_DWORD)result)
              return result;
            v6 = *(_QWORD *)(v29 + 8);
            *(_QWORD *)&v121 = *(_QWORD *)v29;
            *((_QWORD *)&v121 + 1) = v6;
          }
          if ((~(_DWORD)v27 & 0xFF0000) == 0)
          {
            v31 = (_BYTE *)v121;
            *(_QWORD *)&v121 = v121 + 1;
            *v31 = 0;
            v6 = --*((_QWORD *)&v121 + 1);
            if (!*((_QWORD *)&v121 + 1))
            {
              v32 = v124[5];
              result = (*(uint64_t (**)(void))(v32 + 24))();
              if (!(_DWORD)result)
                return result;
              v6 = *(_QWORD *)(v32 + 8);
              *(_QWORD *)&v121 = *(_QWORD *)v32;
              *((_QWORD *)&v121 + 1) = v6;
            }
          }
          v27 <<= 8;
          v33 = v26 - 8;
          v20 = v26 <= 15;
          v26 -= 8;
        }
        while (!v20);
      }
      v34 = v17;
      *(_QWORD *)&v122 = v27;
      DWORD2(v122) = v33;
      if (v17)
      {
        v35 = v33 + v17;
        v27 |= (unint64_t)(~(-1 << v34) & (v16 + (v16 >> 31))) << (24
                                                                                      - (v33
                                                                                       + v34));
        if ((int)(v33 + v34) < 8)
        {
          v33 += v34;
        }
        else
        {
          do
          {
            v36 = (_BYTE *)v121;
            *(_QWORD *)&v121 = v121 + 1;
            *v36 = BYTE2(v27);
            v6 = --*((_QWORD *)&v121 + 1);
            if (!*((_QWORD *)&v121 + 1))
            {
              v37 = v124[5];
              result = (*(uint64_t (**)(void))(v37 + 24))();
              if (!(_DWORD)result)
                return result;
              v6 = *(_QWORD *)(v37 + 8);
              *(_QWORD *)&v121 = *(_QWORD *)v37;
              *((_QWORD *)&v121 + 1) = v6;
            }
            if ((~(_DWORD)v27 & 0xFF0000) == 0)
            {
              v38 = (_BYTE *)v121;
              *(_QWORD *)&v121 = v121 + 1;
              *v38 = 0;
              v6 = --*((_QWORD *)&v121 + 1);
              if (!*((_QWORD *)&v121 + 1))
              {
                v39 = v124[5];
                result = (*(uint64_t (**)(void))(v39 + 24))();
                if (!(_DWORD)result)
                  return result;
                v6 = *(_QWORD *)(v39 + 8);
                *(_QWORD *)&v121 = *(_QWORD *)v39;
                *((_QWORD *)&v121 + 1) = v6;
              }
            }
            v27 <<= 8;
            v33 = v35 - 8;
            v20 = v35 <= 15;
            v35 -= 8;
          }
          while (!v20);
        }
        *(_QWORD *)&v122 = v27;
        DWORD2(v122) = v33;
      }
      v40 = v118;
      if ((int)v119 >= 1)
      {
        v41 = 1;
        v114 = (uint64_t *)v3;
        do
        {
          v42 = 0;
          v43 = v41;
          while (1)
          {
            v44 = *(int *)(v40 + 4 * v43);
            v45 = v10[v44];
            if (v10[v44])
              break;
            ++v42;
            if (v119 + 1 == ++v43)
            {
              v88 = *v120;
              v89 = *((char *)v120 + 1024);
              if (!*((_BYTE *)v120 + 1024))
              {
                v90 = v124;
                v91 = *v124;
                *(_DWORD *)(v91 + 40) = 41;
                (*(void (**)(uint64_t *))v91)(v90);
              }
              v92 = ~(-1 << v89) & v88;
              v93 = v33 + v89;
              v94 = (v92 << (24 - (v33 + v89))) | v27;
              v3 = (int *)v114;
              if (v33 + v89 < 8)
              {
                v101 = v33 + v89;
              }
              else
              {
                do
                {
                  v95 = (_BYTE *)v121;
                  *(_QWORD *)&v121 = v121 + 1;
                  *v95 = BYTE2(v94);
                  v6 = --*((_QWORD *)&v121 + 1);
                  if (!*((_QWORD *)&v121 + 1))
                  {
                    v96 = (uint64_t *)v124[5];
                    result = ((uint64_t (*)(void))v96[3])();
                    if (!(_DWORD)result)
                      return result;
                    v97 = *v96;
                    v6 = v96[1];
                    *(_QWORD *)&v121 = v97;
                    *((_QWORD *)&v121 + 1) = v6;
                  }
                  if ((~(_DWORD)v94 & 0xFF0000) == 0)
                  {
                    v98 = (_BYTE *)v121;
                    *(_QWORD *)&v121 = v121 + 1;
                    *v98 = 0;
                    v6 = --*((_QWORD *)&v121 + 1);
                    if (!*((_QWORD *)&v121 + 1))
                    {
                      v99 = (uint64_t *)v124[5];
                      result = ((uint64_t (*)(void))v99[3])();
                      if (!(_DWORD)result)
                        return result;
                      v100 = *v99;
                      v6 = v99[1];
                      *(_QWORD *)&v121 = v100;
                      *((_QWORD *)&v121 + 1) = v6;
                    }
                  }
                  v94 <<= 8;
                  v101 = v93 - 8;
                  v20 = v93 <= 15;
                  v93 -= 8;
                }
                while (!v20);
              }
              *(_QWORD *)&v122 = v94;
              DWORD2(v122) = v101;
              goto LABEL_118;
            }
          }
          v113 = v4;
          if (v42 < 0x10)
          {
            v58 = v42;
          }
          else
          {
            do
            {
              v46 = v120[240];
              v47 = *((char *)v120 + 1264);
              if (!*((_BYTE *)v120 + 1264))
              {
                v48 = v124;
                v49 = *v124;
                *(_DWORD *)(v49 + 40) = 41;
                (*(void (**)(uint64_t *))v49)(v48);
              }
              v50 = ~(-1 << v47) & v46;
              v51 = v33 + v47;
              v27 |= v50 << (24 - (v33 + v47));
              if (v33 + v47 < 8)
              {
                v33 += v47;
              }
              else
              {
                do
                {
                  v52 = (_BYTE *)v121;
                  *(_QWORD *)&v121 = v121 + 1;
                  *v52 = BYTE2(v27);
                  v6 = --*((_QWORD *)&v121 + 1);
                  if (!*((_QWORD *)&v121 + 1))
                  {
                    v53 = (uint64_t *)v124[5];
                    result = ((uint64_t (*)(void))v53[3])();
                    if (!(_DWORD)result)
                      return result;
                    v54 = *v53;
                    v6 = v53[1];
                    *(_QWORD *)&v121 = v54;
                    *((_QWORD *)&v121 + 1) = v6;
                  }
                  if ((~(_DWORD)v27 & 0xFF0000) == 0)
                  {
                    v55 = (_BYTE *)v121;
                    *(_QWORD *)&v121 = v121 + 1;
                    *v55 = 0;
                    v6 = --*((_QWORD *)&v121 + 1);
                    if (!*((_QWORD *)&v121 + 1))
                    {
                      v56 = (uint64_t *)v124[5];
                      result = ((uint64_t (*)(void))v56[3])();
                      if (!(_DWORD)result)
                        return result;
                      v57 = *v56;
                      v6 = v56[1];
                      *(_QWORD *)&v121 = v57;
                      *((_QWORD *)&v121 + 1) = v6;
                    }
                  }
                  v27 <<= 8;
                  v33 = v51 - 8;
                  v20 = v51 > 0xF;
                  v51 -= 8;
                }
                while (v20);
              }
              *(_QWORD *)&v122 = v27;
              DWORD2(v122) = v33;
              v58 = v42 - 16;
              v20 = v42 <= 31;
              v42 -= 16;
            }
            while (!v20);
          }
          if (v45 >= 0)
            v59 = v45;
          else
            v59 = -v45;
          if (v59 >= 2)
          {
            v61 = 0;
            do
            {
              ++v61;
              v20 = v59 > 3;
              v59 >>= 1;
            }
            while (v20);
            v60 = v61 + 1;
            if (v61 >= 0xA)
            {
              v62 = v124;
              v63 = *v124;
              *(_DWORD *)(v63 + 40) = 6;
              (*(void (**)(uint64_t *))v63)(v62);
            }
          }
          else
          {
            v60 = 1;
          }
          v64 = v60 + 16 * v58;
          v65 = v120[v64];
          v66 = (uint64_t)v120 + v64;
          v67 = *(char *)(v66 + 1024);
          if (!*(_BYTE *)(v66 + 1024))
          {
            v68 = v124;
            v69 = *v124;
            *(_DWORD *)(v69 + 40) = 41;
            (*(void (**)(uint64_t *))v69)(v68);
          }
          v70 = ~(-1 << v67) & v65;
          v71 = v33 + v67;
          v72 = (v70 << (24 - (v33 + v67))) | v27;
          if (v33 + v67 < 8)
          {
            v79 = v33 + v67;
            v4 = v113;
          }
          else
          {
            v4 = v113;
            do
            {
              v73 = (_BYTE *)v121;
              *(_QWORD *)&v121 = v121 + 1;
              *v73 = BYTE2(v72);
              v6 = --*((_QWORD *)&v121 + 1);
              if (!*((_QWORD *)&v121 + 1))
              {
                v74 = (uint64_t *)v124[5];
                result = ((uint64_t (*)(void))v74[3])();
                if (!(_DWORD)result)
                  return result;
                v75 = *v74;
                v6 = v74[1];
                *(_QWORD *)&v121 = v75;
                *((_QWORD *)&v121 + 1) = v6;
              }
              if ((~(_DWORD)v72 & 0xFF0000) == 0)
              {
                v76 = (_BYTE *)v121;
                *(_QWORD *)&v121 = v121 + 1;
                *v76 = 0;
                v6 = --*((_QWORD *)&v121 + 1);
                if (!*((_QWORD *)&v121 + 1))
                {
                  v77 = (uint64_t *)v124[5];
                  result = ((uint64_t (*)(void))v77[3])();
                  if (!(_DWORD)result)
                    return result;
                  v78 = *v77;
                  v6 = v77[1];
                  *(_QWORD *)&v121 = v78;
                  *((_QWORD *)&v121 + 1) = v6;
                }
              }
              v72 <<= 8;
              v79 = v71 - 8;
              v20 = v71 > 0xF;
              v71 -= 8;
            }
            while (v20);
          }
          v80 = v79 + v60;
          v27 = ((unint64_t)(~(-1 << v60) & (v45 + (v45 >> 15))) << (24
                                                                                        - (v79
                                                                                         + v60))) | v72;
          if ((int)(v79 + v60) < 8)
          {
            v33 = v79 + v60;
          }
          else
          {
            do
            {
              v81 = (_BYTE *)v121;
              *(_QWORD *)&v121 = v121 + 1;
              *v81 = BYTE2(v27);
              v6 = --*((_QWORD *)&v121 + 1);
              if (!*((_QWORD *)&v121 + 1))
              {
                v82 = (uint64_t *)v124[5];
                result = ((uint64_t (*)(void))v82[3])();
                if (!(_DWORD)result)
                  return result;
                v83 = *v82;
                v6 = v82[1];
                *(_QWORD *)&v121 = v83;
                *((_QWORD *)&v121 + 1) = v6;
              }
              if ((~(_DWORD)v27 & 0xFF0000) == 0)
              {
                v84 = (_BYTE *)v121;
                *(_QWORD *)&v121 = v121 + 1;
                *v84 = 0;
                v6 = --*((_QWORD *)&v121 + 1);
                if (!*((_QWORD *)&v121 + 1))
                {
                  v85 = (uint64_t *)v124[5];
                  result = ((uint64_t (*)(void))v85[3])();
                  if (!(_DWORD)result)
                    return result;
                  v86 = *v85;
                  v6 = v85[1];
                  *(_QWORD *)&v121 = v86;
                  *((_QWORD *)&v121 + 1) = v6;
                }
              }
              v27 <<= 8;
              v33 = v80 - 8;
              v20 = v80 > 0xF;
              v80 -= 8;
            }
            while (v20);
          }
          *(_QWORD *)&v122 = v27;
          DWORD2(v122) = v33;
          v41 = v43 + 1;
          v87 = v119 == v43;
          v3 = (int *)v114;
          v40 = v118;
        }
        while (!v87);
      }
LABEL_118:
      a2 = v115;
      *v116 = **(__int16 **)(v115 + 8 * v117);
      v8 = v117 + 1;
    }
    while (v117 + 1 < v3[104]);
  }
  v102 = (_QWORD *)*((_QWORD *)v3 + 5);
  *v102 = v121;
  v102[1] = v6;
  v103 = v123;
  *(_OWORD *)(v4 + 24) = v122;
  *(_OWORD *)(v4 + 40) = v103;
  v104 = v3[79];
  if (v104)
  {
    v105 = *(_DWORD *)(v4 + 56);
    if (!v105)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      v105 = v104;
    }
    *(_DWORD *)(v4 + 56) = v105 - 1;
  }
  return 1;
}

void jpeg_make_c_derived_tbl(uint64_t a1, int a2, unsigned int a3, _QWORD *a4)
{
  void (**v8)(uint64_t);
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  _OWORD *v13;
  uint64_t v14;
  uint64_t i;
  size_t v16;
  void (**v17)(uint64_t);
  int v18;
  unsigned int v19;
  int v20;
  char v21;
  _DWORD *v22;
  char *v23;
  int v24;
  void (**v25)(uint64_t);
  unsigned __int8 *v26;
  _BYTE *v27;
  int *v28;
  uint64_t v29;
  unsigned int v30;
  void (**v31)(uint64_t);
  int v32;
  int v33;
  _DWORD v34[257];
  _BYTE v35[264];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  memset(v35, 0, 257);
  if (a3 >= 4)
  {
    v8 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v8 + 10) = 52;
    *((_DWORD *)v8 + 12) = a3;
    (**(void (***)(uint64_t))a1)(a1);
  }
  v9 = a1 + 8 * (int)a3;
  v10 = (uint64_t *)(v9 + 160);
  v11 = (uint64_t *)(v9 + 192);
  if (a2)
    v11 = v10;
  v12 = *v11;
  if (!*v11)
    v12 = _cg_jpeg_std_huff_table(a1, a2, a3);
  v13 = (_OWORD *)*a4;
  if (!*a4)
  {
    v13 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1280);
    *a4 = v13;
  }
  v33 = a2;
  LODWORD(v14) = 0;
  for (i = 1; i != 17; ++i)
  {
    v16 = *(unsigned __int8 *)(v12 + i);
    if ((int)v14 + (int)v16 >= 257)
    {
      v17 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v17 + 10) = 9;
      (*v17)(a1);
    }
    if ((_DWORD)v16)
    {
      memset(&v35[(int)v14], i, v16);
      LODWORD(v14) = v14 + v16;
    }
  }
  bzero(v34, 0x404uLL);
  v35[(int)v14] = 0;
  v18 = v35[0];
  if (v35[0])
  {
    v19 = 0;
    v20 = 0;
    v21 = v35[0];
    do
    {
      if (v18 == v21)
      {
        v22 = &v34[v20];
        v23 = &v35[v20 + 1];
        do
        {
          *v22++ = v19++;
          v24 = *v23++;
          ++v20;
        }
        while (v18 == v24);
      }
      if (1 << v18 <= v19)
      {
        v25 = *(void (***)(uint64_t))a1;
        *((_DWORD *)v25 + 10) = 9;
        (*v25)(a1);
      }
      v19 *= 2;
      ++v18;
      v21 = v35[v20];
    }
    while (v21);
  }
  v13[79] = 0u;
  v13[78] = 0u;
  v13[77] = 0u;
  v13[76] = 0u;
  v13[75] = 0u;
  v13[74] = 0u;
  v13[73] = 0u;
  v13[72] = 0u;
  v13[71] = 0u;
  v13[70] = 0u;
  v13[69] = 0u;
  v13[68] = 0u;
  v13[67] = 0u;
  v13[66] = 0u;
  v13[65] = 0u;
  v13[64] = 0u;
  if ((int)v14 >= 1)
  {
    v26 = (unsigned __int8 *)(v12 + 17);
    v27 = v35;
    v28 = v34;
    v14 = v14;
    do
    {
      v30 = *v26++;
      v29 = v30;
      if (v33 && v29 > 0xF || *((_BYTE *)v13 + v29 + 1024))
      {
        v31 = *(void (***)(uint64_t))a1;
        *((_DWORD *)v31 + 10) = 9;
        (*v31)(a1);
      }
      v32 = *v28++;
      *((_DWORD *)v13 + v29) = v32;
      LOBYTE(v32) = *v27++;
      *((_BYTE *)v13 + v29 + 1024) = v32;
      --v14;
    }
    while (v14);
  }
}

uint64_t emit_eobrun(uint64_t result)
{
  int v1;
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  BOOL v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  int v15;

  v1 = *(_DWORD *)(result + 228);
  if (v1)
  {
    v2 = result;
    if (v1 == 1)
    {
      v3 = 0;
    }
    else
    {
      v4 = -1;
      do
      {
        ++v4;
        v5 = v1 > 3;
        v1 >>= 1;
      }
      while (v5);
      v3 = v4 + 1;
      if (v4 >= 0xE)
      {
        v6 = *(uint64_t **)(result + 216);
        v7 = *v6;
        *(_DWORD *)(v7 + 40) = 41;
        (*(void (**)(uint64_t *))v7)(v6);
      }
    }
    emit_ac_symbol(v2, *(_DWORD *)(v2 + 224), 16 * v3);
    if (v3 && !*(_DWORD *)(v2 + 192))
    {
      v8 = *(unsigned int *)(v2 + 228) & (unint64_t)~(-1 << v3);
      v9 = *(_DWORD *)(v2 + 32) + v3;
      v10 = (v8 << (24 - v9)) | *(_QWORD *)(v2 + 24);
      if (v9 < 8)
      {
        v15 = v9;
      }
      else
      {
        do
        {
          v11 = *(_BYTE **)(v2 + 200);
          *(_QWORD *)(v2 + 200) = v11 + 1;
          *v11 = BYTE2(v10);
          v12 = *(_QWORD *)(v2 + 208) - 1;
          *(_QWORD *)(v2 + 208) = v12;
          if (!v12)
            dump_buffer_e((_QWORD *)v2);
          if ((~(_DWORD)v10 & 0xFF0000) == 0)
          {
            v13 = *(_BYTE **)(v2 + 200);
            *(_QWORD *)(v2 + 200) = v13 + 1;
            *v13 = 0;
            v14 = *(_QWORD *)(v2 + 208) - 1;
            *(_QWORD *)(v2 + 208) = v14;
            if (!v14)
              dump_buffer_e((_QWORD *)v2);
          }
          v10 <<= 8;
          v15 = v9 - 8;
          v5 = v9 <= 15;
          v9 -= 8;
        }
        while (!v5);
      }
      *(_QWORD *)(v2 + 24) = v10;
      *(_DWORD *)(v2 + 32) = v15;
    }
    *(_DWORD *)(v2 + 228) = 0;
    result = emit_buffered_bits(v2, *(_BYTE **)(v2 + 240), *(_DWORD *)(v2 + 232));
    *(_DWORD *)(v2 + 232) = 0;
  }
  return result;
}

double jpeg_gen_optimal_table(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  int v7;
  unsigned int v8;
  _BYTE *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t i;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  char v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _BYTE *v39;
  char v40;
  int v41;
  double result;
  _DWORD __b[257];
  _DWORD v44[257];
  __int128 v45;
  __int128 v46;
  char v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  bzero(__b, 0x404uLL);
  v6 = 0;
  *(_QWORD *)(a3 + 2048) = 1;
  v7 = 256;
  while (1)
  {
    if (!*(_QWORD *)(a3 + 8 * v6))
      goto LABEL_5;
    if (v6 > 0xFF)
      break;
    __b[v7] = v6;
    v7 = v6;
LABEL_5:
    ++v6;
  }
  __b[v7] = -1;
  v8 = __b[256];
  if ((__b[256] & 0x80000000) == 0)
  {
    v9 = (_BYTE *)(a2 + 17);
    do
    {
      v10 = __b[v8];
      if ((v10 & 0x80000000) != 0)
      {
        v12 = 256;
      }
      else
      {
        v11 = *(_QWORD *)(a3 + 8 * v8);
        v12 = 256;
        v13 = v8;
        do
        {
          if (*(_QWORD *)(a3 + 8 * v10) > v11)
          {
            v8 = v10;
            v12 = v13;
            v11 = *(_QWORD *)(a3 + 8 * v10);
          }
          v13 = v10;
          v10 = __b[v10];
        }
        while ((v10 & 0x80000000) == 0);
        v10 = __b[v8];
      }
      __b[v12] = v10;
      *v9++ = v8;
      v8 = __b[256];
    }
    while ((__b[256] & 0x80000000) == 0);
  }
  v47 = 0;
  v45 = 0u;
  v46 = 0u;
  bzero(v44, 0x404uLL);
  memset(__b, 255, sizeof(__b));
LABEL_17:
  v14 = 0;
  LODWORD(v15) = -1;
  v16 = 1000000000;
  while (1)
  {
    do
    {
      v17 = *(_QWORD *)(a3 + 8 * v14);
      if (v17)
        v18 = v17 <= v16;
      else
        v18 = 0;
      v19 = !v18;
      if (v19)
        v15 = v15;
      else
        v15 = v14;
      if (!v19)
        v16 = *(_QWORD *)(a3 + 8 * v14);
      ++v14;
    }
    while (v14 != 257);
    v20 = 0;
    LODWORD(v21) = -1;
    v22 = 1000000000;
    do
    {
      v23 = *(_QWORD *)(a3 + 8 * v20);
      if (v23)
        v24 = v23 <= v22;
      else
        v24 = 0;
      v25 = !v24 || v15 == v20;
      if (v25)
        v21 = v21;
      else
        v21 = v20;
      if (!v25)
        v22 = *(_QWORD *)(a3 + 8 * v20);
      ++v20;
    }
    while (v20 != 257);
    if ((v21 & 0x80000000) != 0)
      break;
    *(_QWORD *)(a3 + 8 * (int)v15) += *(_QWORD *)(a3 + 8 * v21);
    *(_QWORD *)(a3 + 8 * v21) = 0;
    ++v44[(int)v15];
    v26 = __b[(int)v15];
    if ((v26 & 0x80000000) != 0)
    {
      v15 = (int)v15;
    }
    else
    {
      do
      {
        v15 = v26;
        ++v44[v26];
        v26 = __b[v26];
      }
      while ((v26 & 0x80000000) == 0);
    }
    v14 = 0;
    __b[v15] = v21;
    ++v44[v21];
    v27 = __b[v21];
    LODWORD(v15) = -1;
    v16 = 1000000000;
    if ((v27 & 0x80000000) == 0)
    {
      do
      {
        ++v44[v27];
        v27 = __b[v27];
      }
      while ((v27 & 0x80000000) == 0);
      goto LABEL_17;
    }
  }
  for (i = 0; i != 257; ++i)
  {
    v29 = (int)v44[i];
    if ((_DWORD)v29)
    {
      if ((int)v29 >= 33)
      {
        v30 = *a1;
        *(_DWORD *)(v30 + 40) = 40;
        (*(void (**)(uint64_t *))v30)(a1);
      }
      ++*((_BYTE *)&v45 + v29);
    }
  }
  v31 = 32;
  v32 = 29;
  do
  {
    v33 = *((_BYTE *)&v45 + v31);
    if (v33)
    {
      v34 = v31 - 1;
      do
      {
        v35 = v31 - 2;
        if (!*((_BYTE *)&v45 + v31 - 2))
        {
          v36 = v32;
          do
          {
            if (v36 == -1)
            {
              v37 = *a1;
              *(_DWORD *)(v37 + 40) = 40;
              (*(void (**)(uint64_t *))v37)(a1);
            }
          }
          while (!*((unsigned __int8 *)&v45 + v36--));
          v35 = v36 + 1;
        }
        *((_BYTE *)&v45 + v31) = v33 - 2;
        ++*((_BYTE *)&v45 + v34);
        *((_BYTE *)&v45 + (int)v35 + 1) += 2;
        --*((_BYTE *)&v45 + v35);
        v33 = *((_BYTE *)&v45 + v31);
      }
      while (v33);
    }
    else
    {
      v34 = v31 - 1;
    }
    --v32;
    v18 = v31 > 0x11;
    v31 = v34;
  }
  while (v18);
  v39 = (char *)&v46 + 1;
  do
  {
    v41 = *--v39;
    v40 = v41;
  }
  while (!v41);
  *v39 = v40 - 1;
  result = *(double *)&v45;
  *(_OWORD *)a2 = v45;
  *(_BYTE *)(a2 + 16) = v46;
  *(_DWORD *)(a2 + 276) = 0;
  return result;
}

uint64_t emit_ac_symbol(uint64_t result, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  int v18;
  BOOL v19;

  v3 = result;
  if (*(_DWORD *)(result + 192))
  {
    v4 = *(_QWORD *)(result + 8 * a2 + 160);
    ++*(_QWORD *)(v4 + 8 * a3);
  }
  else
  {
    v5 = *(_QWORD *)(result + 8 * a2 + 96);
    v6 = *(_DWORD *)(v5 + 4 * a3);
    v7 = v5 + a3;
    v8 = *(char *)(v7 + 1024);
    if (*(_BYTE *)(v7 + 1024)
      || (v9 = *(uint64_t **)(result + 216),
          v10 = *v9,
          *(_DWORD *)(v10 + 40) = 41,
          result = (*(uint64_t (**)(uint64_t *))v10)(v9),
          !*(_DWORD *)(v3 + 192)))
    {
      v11 = ~(-1 << v8) & v6;
      v12 = *(_DWORD *)(v3 + 32) + v8;
      v13 = (v11 << (24 - (*(_BYTE *)(v3 + 32) + v8))) | *(_QWORD *)(v3 + 24);
      if (v12 < 8)
      {
        v18 = v12;
      }
      else
      {
        do
        {
          v14 = *(_BYTE **)(v3 + 200);
          *(_QWORD *)(v3 + 200) = v14 + 1;
          *v14 = BYTE2(v13);
          v15 = *(_QWORD *)(v3 + 208) - 1;
          *(_QWORD *)(v3 + 208) = v15;
          if (!v15)
            result = dump_buffer_e((_QWORD *)v3);
          if ((~(_DWORD)v13 & 0xFF0000) == 0)
          {
            v16 = *(_BYTE **)(v3 + 200);
            *(_QWORD *)(v3 + 200) = v16 + 1;
            *v16 = 0;
            v17 = *(_QWORD *)(v3 + 208) - 1;
            *(_QWORD *)(v3 + 208) = v17;
            if (!v17)
              result = dump_buffer_e((_QWORD *)v3);
          }
          v13 <<= 8;
          v18 = v12 - 8;
          v19 = v12 <= 15;
          v12 -= 8;
        }
        while (!v19);
      }
      *(_QWORD *)(v3 + 24) = v13;
      *(_DWORD *)(v3 + 32) = v18;
    }
  }
  return result;
}

uint64_t emit_buffered_bits(uint64_t result, _BYTE *a2, int a3)
{
  uint64_t v3;
  int v4;
  int v6;
  unint64_t v7;
  int v8;
  _BYTE *v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  int v13;

  if (a3)
  {
    v3 = result;
    if (!*(_DWORD *)(result + 192))
    {
      v4 = a3;
LABEL_4:
      v6 = *(_DWORD *)(v3 + 32);
      v7 = ((unint64_t)(*a2 & 1) << (23 - v6)) | *(_QWORD *)(v3 + 24);
      if (v6 < 7)
      {
        v13 = v6 + 1;
      }
      else
      {
        v8 = v6 + 9;
        do
        {
          v9 = *(_BYTE **)(v3 + 200);
          *(_QWORD *)(v3 + 200) = v9 + 1;
          *v9 = BYTE2(v7);
          v10 = *(_QWORD *)(v3 + 208) - 1;
          *(_QWORD *)(v3 + 208) = v10;
          if (!v10)
            result = dump_buffer_e((_QWORD *)v3);
          if ((~(_DWORD)v7 & 0xFF0000) == 0)
          {
            v11 = *(_BYTE **)(v3 + 200);
            *(_QWORD *)(v3 + 200) = v11 + 1;
            *v11 = 0;
            v12 = *(_QWORD *)(v3 + 208) - 1;
            *(_QWORD *)(v3 + 208) = v12;
            if (!v12)
              result = dump_buffer_e((_QWORD *)v3);
          }
          v7 <<= 8;
          v8 -= 8;
        }
        while (v8 > 15);
        v13 = v8 - 8;
      }
      *(_QWORD *)(v3 + 24) = v7;
      *(_DWORD *)(v3 + 32) = v13;
      while (--v4)
      {
        ++a2;
        if (!*(_DWORD *)(v3 + 192))
          goto LABEL_4;
      }
    }
  }
  return result;
}

uint64_t dump_buffer_e(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1[27] + 40);
  result = (*(uint64_t (**)(void))(v2 + 24))();
  if (!(_DWORD)result)
  {
    v4 = (uint64_t *)a1[27];
    v5 = *v4;
    *(_DWORD *)(v5 + 40) = 25;
    result = (*(uint64_t (**)(uint64_t *))v5)(v4);
  }
  v6 = *(_QWORD *)(v2 + 8);
  a1[25] = *(_QWORD *)v2;
  a1[26] = v6;
  return result;
}

uint64_t flush_bits_e(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;
  _BYTE *v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;

  v1 = result;
  if (!*(_DWORD *)(result + 192))
  {
    v2 = *(_DWORD *)(result + 32);
    if (v2 >= 1)
    {
      v3 = (127 << (17 - v2)) | *(_QWORD *)(result + 24);
      v4 = v2 + 15;
      do
      {
        v5 = *(_BYTE **)(v1 + 200);
        *(_QWORD *)(v1 + 200) = v5 + 1;
        *v5 = BYTE2(v3);
        v6 = *(_QWORD *)(v1 + 208) - 1;
        *(_QWORD *)(v1 + 208) = v6;
        if (!v6)
          result = dump_buffer_e((_QWORD *)v1);
        if ((~(_DWORD)v3 & 0xFF0000) == 0)
        {
          v7 = *(_BYTE **)(v1 + 200);
          *(_QWORD *)(v1 + 200) = v7 + 1;
          *v7 = 0;
          v8 = *(_QWORD *)(v1 + 208) - 1;
          *(_QWORD *)(v1 + 208) = v8;
          if (!v8)
            result = dump_buffer_e((_QWORD *)v1);
        }
        LODWORD(v3) = (_DWORD)v3 << 8;
        v4 -= 8;
      }
      while (v4 > 15);
    }
  }
  *(_QWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 32) = 0;
  return result;
}

uint64_t flush_bits_s(uint64_t a1)
{
  int v2;
  uint64_t v3;
  int v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = *(_DWORD *)(a1 + 24);
  if (v2 >= 1)
  {
    v3 = (127 << (17 - v2)) | *(_QWORD *)(a1 + 16);
    v4 = v2 + 15;
    do
    {
      v5 = (_BYTE *)(*(_QWORD *)a1)++;
      *v5 = BYTE2(v3);
      v6 = *(_QWORD *)(a1 + 8) - 1;
      *(_QWORD *)(a1 + 8) = v6;
      if (!v6)
      {
        v7 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 40);
        result = (*(uint64_t (**)(void))(v7 + 24))();
        if (!(_DWORD)result)
          return result;
        v9 = *(_QWORD *)(v7 + 8);
        *(_QWORD *)a1 = *(_QWORD *)v7;
        *(_QWORD *)(a1 + 8) = v9;
      }
      if ((~(_DWORD)v3 & 0xFF0000) == 0)
      {
        v10 = (_BYTE *)(*(_QWORD *)a1)++;
        *v10 = 0;
        v11 = *(_QWORD *)(a1 + 8) - 1;
        *(_QWORD *)(a1 + 8) = v11;
        if (!v11)
        {
          v12 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 40);
          result = (*(uint64_t (**)(void))(v12 + 24))();
          if (!(_DWORD)result)
            return result;
          v13 = *(_QWORD *)(v12 + 8);
          *(_QWORD *)a1 = *(_QWORD *)v12;
          *(_QWORD *)(a1 + 8) = v13;
        }
      }
      LODWORD(v3) = (_DWORD)v3 << 8;
      v4 -= 8;
    }
    while (v4 > 15);
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return 1;
}

uint64_t emit_restart_e(uint64_t a1, char a2)
{
  uint64_t result;
  _BYTE *v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = emit_eobrun(a1);
  if (!*(_DWORD *)(a1 + 192))
  {
    result = flush_bits_e(a1);
    v5 = *(_BYTE **)(a1 + 200);
    *(_QWORD *)(a1 + 200) = v5 + 1;
    *v5 = -1;
    v6 = *(_QWORD *)(a1 + 208) - 1;
    *(_QWORD *)(a1 + 208) = v6;
    if (!v6)
      result = dump_buffer_e((_QWORD *)a1);
    v7 = *(_BYTE **)(a1 + 200);
    *(_QWORD *)(a1 + 200) = v7 + 1;
    *v7 = a2 - 48;
    v8 = *(_QWORD *)(a1 + 208) - 1;
    *(_QWORD *)(a1 + 208) = v8;
    if (!v8)
      result = dump_buffer_e((_QWORD *)a1);
  }
  v9 = *(_QWORD *)(a1 + 216);
  if (*(_DWORD *)(v9 + 460))
  {
    *(_DWORD *)(a1 + 228) = 0;
    *(_DWORD *)(a1 + 232) = 0;
  }
  else if (*(int *)(v9 + 372) >= 1)
  {
    v10 = 0;
    do
      *(_DWORD *)(a1 + 36 + 4 * v10++) = 0;
    while (v10 < *(int *)(v9 + 372));
  }
  return result;
}

uint64_t xf20toRGB16f<(ImageIOVectorLevel)0>::operator()(uint64_t a1, unsigned __int16 **a2, unsigned __int16 **a3, _QWORD *a4, __int16 *a5)
{
  unint64_t v5;
  __int16 *v6;
  unint64_t v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  uint64_t v10;
  unint64_t v11;
  _WORD *v12;
  unsigned __int16 *v13;
  unint64_t v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  _WORD *v17;
  unint64_t v18;
  _WORD *v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  float v33;
  float v37;
  float v43;
  float v47;
  float v50;
  float v52;
  float v55;
  unint64_t v62;
  float v67;
  float v71;
  float v83;

  v5 = a4[1];
  v6 = (__int16 *)&kDefaultXF20ToRGB16fConversion;
  if (a5)
    v6 = a5;
  if (v5)
  {
    v7 = 0;
    v8 = a2[3];
    v9 = a3[3];
    v11 = a4[2];
    v10 = a4[3];
    v12 = (_WORD *)*a4;
    v13 = *a3;
    v15 = *a2;
    v14 = (unint64_t)a2[1];
    do
    {
      if ((v7 | 1) >= v14)
        v16 = v15;
      else
        v16 = (unsigned __int16 *)((char *)v15 + (_QWORD)v8);
      v17 = (_WORD *)((char *)v12 + v10);
      if ((v7 | 1) >= v5)
        v17 = v12;
      if (v11 >= 2)
      {
        v18 = 0;
        v20 = v13;
        v21 = v16;
        v22 = v15;
        v19 = v12;
        do
        {
          _H7 = *v6;
          __asm { FCVT            S7, H7 }
          _H16 = v6[1];
          __asm { FCVT            S16, H16 }
          _H17 = v6[2];
          __asm { FCVT            S17, H17 }
          v33 = (float)((float)(v20[1] >> 6) / 1023.0) - _S16;
          _S5 = (float)((float)(*v20 >> 6) / 1023.0) - _S17;
          LOWORD(_S16) = v6[3];
          __asm { FCVT            S16, H16 }
          LOWORD(_S17) = v6[4];
          __asm { FCVT            S17, H17 }
          v37 = (float)((float)((float)(*v22 >> 6) / 1023.0) - _S7) * _S16;
          _S18 = v37 + (float)(v33 * _S17);
          _H19 = v6[6];
          __asm { FCVT            S19, H19 }
          _H20 = v6[5];
          __asm { FCVT            S20, H20 }
          v43 = v37 + (float)(v33 * _S19);
          _H22 = v6[7];
          __asm { FCVT            S22, H22 }
          _S1 = v37 + (float)(_S5 * _S22);
          v47 = (float)((float)((float)(v22[1] >> 6) / 1023.0) - _S7) * _S16;
          _S21 = v43 + (float)(_S5 * _S20);
          _S23 = v47 + (float)(v33 * _S17);
          v50 = v47 + (float)(v33 * _S19);
          _S2 = v47 + (float)(_S5 * _S22);
          v52 = (float)((float)((float)(*v21 >> 6) / 1023.0) - _S7) * _S16;
          _S24 = v50 + (float)(_S5 * _S20);
          _S25 = v52 + (float)(v33 * _S17);
          v55 = v52 + (float)(v33 * _S19);
          _S3 = v52 + (float)(_S5 * _S22);
          _S4 = (float)((float)((float)(v21[1] >> 6) / 1023.0) - _S7) * _S16;
          _S7 = v55 + (float)(_S5 * _S20);
          _S16 = _S4 + (float)(v33 * _S17);
          _S6 = (float)(_S4 + (float)(v33 * _S19)) + (float)(_S5 * _S20);
          __asm
          {
            FCVT            H17, S25
            FCVT            H3, S3
          }
          *v17 = LOWORD(_S17);
          v17[2] = LOWORD(_S3);
          _S3 = _S4 + (float)(_S5 * _S22);
          __asm
          {
            FCVT            H4, S7
            FCVT            H5, S16
          }
          v17[3] = LOWORD(_S5);
          v17[1] = LOWORD(_S4);
          __asm { FCVT            H4, S6 }
          v17[4] = LOWORD(_S4);
          __asm { FCVT            H3, S3 }
          v17[5] = LOWORD(_S3);
          __asm { FCVT            H3, S18 }
          v17 += 6;
          *v19 = LOWORD(_S3);
          __asm { FCVT            H3, S21 }
          v19[1] = LOWORD(_S3);
          __asm
          {
            FCVT            H1, S1
            FCVT            H3, S23
          }
          v19[2] = LOWORD(_S1);
          v19[3] = LOWORD(_S3);
          __asm { FCVT            H1, S24 }
          v19[4] = LOWORD(_S1);
          __asm { FCVT            H1, S2 }
          v19[5] = LOWORD(_S1);
          v19 += 6;
          v62 = v18 + 4;
          v18 += 2;
          v22 += 2;
          v21 += 2;
          v20 += 2;
        }
        while (v62 <= v11);
      }
      else
      {
        v18 = 0;
        v19 = v12;
      }
      if (v18 < v11)
      {
        _H5 = *v6;
        __asm { FCVT            S5, H5 }
        _H6 = v6[1];
        __asm { FCVT            S6, H6 }
        v67 = (float)((float)(*(unsigned __int16 *)((char *)v13 + ((2 * v18) | 2)) >> 6) / 1023.0) - _S6;
        LOWORD(_S6) = v6[2];
        __asm { FCVT            S6, H6 }
        _S3 = (float)((float)(v13[v18] >> 6) / 1023.0) - _S6;
        LOWORD(_S6) = v6[3];
        __asm { FCVT            S6, H6 }
        v71 = (float)((float)((float)(v15[v18] >> 6) / 1023.0) - _S5) * _S6;
        _H7 = v6[4];
        __asm { FCVT            S7, H7 }
        _S16 = v71 + (float)(v67 * _S7);
        _H17 = v6[6];
        __asm { FCVT            S17, H17 }
        _H19 = v6[5];
        __asm { FCVT            S19, H19 }
        _S18 = (float)(v71 + (float)(v67 * _S17)) + (float)(_S3 * _S19);
        _H20 = v6[7];
        __asm { FCVT            S20, H20 }
        _S1 = v71 + (float)(_S3 * _S20);
        v83 = (float)((float)((float)(v16[v18] >> 6) / 1023.0) - _S5) * _S6;
        _S5 = v83 + (float)(v67 * _S7);
        _S4 = (float)(v83 + (float)(v67 * _S17)) + (float)(_S3 * _S19);
        _S2 = v83 + (float)(_S3 * _S20);
        __asm { FCVT            H3, S5 }
        *v17 = LOWORD(_S3);
        __asm { FCVT            H3, S4 }
        v17[1] = LOWORD(_S3);
        __asm { FCVT            H2, S2 }
        v17[2] = LOWORD(_S2);
        __asm { FCVT            H2, S16 }
        *v19 = LOWORD(_S2);
        __asm { FCVT            H2, S18 }
        v19[1] = LOWORD(_S2);
        __asm { FCVT            H1, S1 }
        v19[2] = LOWORD(_S1);
      }
      v15 += (uint64_t)v8;
      v13 = (unsigned __int16 *)((char *)v13 + (_QWORD)v9);
      v12 += v10;
      v7 += 2;
    }
    while (v7 < v5);
  }
  return 0;
}

uint64_t xf20toRGBA1010102<(ImageIOVectorLevel)0>::operator()(uint64_t a1, unsigned __int16 **a2, unsigned __int16 **a3, unint64_t **a4, char *a5)
{
  float16x4_t v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unsigned __int16 *v18;
  float32x2_t v19;
  unint64_t v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  uint64_t v31;
  float32x2_t v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  uint32x2_t v40;
  uint32x2_t v41;
  float32x2_t v42;
  float32x2_t v44;
  float32x2_t v46;
  float32x2_t v48;
  float32x2_t v50;
  float32x2_t v51;
  float32x2_t v52;
  float32x2_t v53;
  float32x2_t v54;
  float32x2_t v55;
  float32x2_t v56;
  float32x2_t v57;
  float32x2_t v58;
  float32x2_t v59;
  unint64_t v60;
  float32x2_t v61;
  float v66;
  float16x4_t v67;
  float v68;
  float32x2_t v69;
  float32x2_t v71;
  float v72;
  uint32x2_t v73;
  float v74;
  unsigned int v75;
  int32x2_t v76;
  unsigned __int32 v78;
  float v79;
  float v80;
  float32x2_t v81;
  int32x2_t v82;

  v10 = (unint64_t)a4[1];
  v11 = (char *)&kDefaultXF20ToRGB16fConversion;
  if (a5)
    v11 = a5;
  if (v10)
  {
    v12 = 0;
    v13 = a2[3];
    v14 = a3[3];
    v16 = (unint64_t)a4[2];
    v15 = a4[3];
    v17 = *a4;
    v18 = *a3;
    v19 = (float32x2_t)vdup_n_s32(0x447FC000u);
    __asm { FMOV            V3.2S, #1.0 }
    v26 = *a2;
    v25 = (unint64_t)a2[1];
    do
    {
      if ((v12 | 1) >= v25)
        v27 = v26;
      else
        v27 = (unsigned __int16 *)((char *)v26 + (_QWORD)v13);
      v28 = (unint64_t *)((char *)v17 + (_QWORD)v15);
      if ((v12 | 1) >= v10)
        v28 = v17;
      if (v16 >= 2)
      {
        v31 = 0;
        _D16.i16[0] = *(_WORD *)v11;
        __asm { FCVT            S20, H16 }
        _D16.i32[0] = *(_DWORD *)(v11 + 2);
        _D16 = (float16x4_t)vrev64_s32((int32x2_t)*(_OWORD *)&vcvtq_f32_f16(_D16));
        _H17 = *((_WORD *)v11 + 3);
        __asm { FCVT            S17, H17 }
        _H18 = *((_WORD *)v11 + 6);
        __asm { FCVT            S18, H18 }
        v9.i32[0] = *((_DWORD *)v11 + 2);
        _D19.i16[0] = *((_WORD *)v11 + 7);
        __asm { FCVT            S19, H19 }
        _D19 = (float16x4_t)vdup_lane_s32((int32x2_t)_D19, 0);
        _D20 = (float32x2_t)vdup_lane_s32((int32x2_t)_D20, 0);
        v9 = (float16x4_t)vcvtq_f32_f16(v9).u64[0];
        v36 = (float32x2_t)vrev64_s32((int32x2_t)v9);
        v37 = v18;
        v38 = v27;
        v39 = v26;
        v30 = v17;
        do
        {
          v40.i32[0] = *v39;
          v40.i32[1] = v39[1];
          v41.i32[0] = *v38;
          v42 = vdiv_f32(vcvt_f32_u32(vshr_n_u32(v40, 6uLL)), v19);
          v41.i32[1] = v38[1];
          v40.i32[0] = *v37;
          v40.i32[1] = v37[1];
          _D23 = vsub_f32(vdiv_f32(vcvt_f32_u32(vshr_n_u32(v40, 6uLL)), v19), (float32x2_t)_D16);
          v44 = vmul_n_f32(vsub_f32(vdiv_f32(vcvt_f32_u32(vshr_n_u32(v41, 6uLL)), v19), _D20), _S17);
          __asm { FMLA            S26, S18, V23.S[1] }
          v46 = (float32x2_t)__PAIR64__(v44.u32[1], _S26);
          __asm { FMLA            S26, S18, V23.S[1] }
          v48 = (float32x2_t)vrev64_s32((int32x2_t)_D23);
          _D29 = (float32x2_t)__PAIR64__(_S26, v44.u32[0]);
          v50 = vminnm_f32(vmla_f32(v46, v36, _D23), _D3);
          v51 = vminnm_f32(vmla_f32(_D29, (float32x2_t)v9, v48), _D3);
          v52 = vminnm_f32(vmla_n_f32(v44, (float32x2_t)_D19, _D23.f32[0]), _D3);
          v53 = vmul_n_f32(vsub_f32(v42, _D20), _S17);
          __asm { FMLA            S29, S18, V23.S[1] }
          v54 = (float32x2_t)__PAIR64__(v53.u32[1], _D29.u32[0]);
          __asm { FMLA            S29, S18, V23.S[1] }
          v55 = (float32x2_t)__PAIR64__(_D29.u32[0], v53.u32[0]);
          v56 = vmla_n_f32(v53, (float32x2_t)_D19, _D23.f32[0]);
          v57 = vminnm_f32(vmla_f32(v54, v36, _D23), _D3);
          v58 = vminnm_f32(vmla_f32(v55, (float32x2_t)v9, v48), _D3);
          v59 = vminnm_f32(v56, _D3);
          *v28++ = *(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v50, v19), (int8x8_t)vcgtz_f32(v50)))), (uint32x2_t)0x140000000ALL), (int8x8_t)vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v52, v19), (int8x8_t)vcgtz_f32(v52))))), (int8x8_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v51, v19), (int8x8_t)vcgtz_f32(v51)))), (uint32x2_t)0xA00000014)) | 0xC0000000C0000000;
          *v30++ = *(_QWORD *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v57, v19), (int8x8_t)vcgtz_f32(v57)))), (uint32x2_t)0x140000000ALL), (int8x8_t)vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v59, v19), (int8x8_t)vcgtz_f32(v59))))), (int8x8_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v58, v19), (int8x8_t)vcgtz_f32(v58)))), (uint32x2_t)0xA00000014)) | 0xC0000000C0000000;
          v29 = v31 + 2;
          v60 = v31 + 4;
          v39 += 2;
          v38 += 2;
          v37 += 2;
          v31 += 2;
        }
        while (v60 <= v16);
      }
      else
      {
        v29 = 0;
        v30 = v17;
      }
      if (v29 < v16)
      {
        _D18.i16[0] = *(_WORD *)v11;
        __asm { FCVT            S18, H18 }
        _D19.i16[0] = *((_WORD *)v11 + 3);
        __asm { FCVT            S19, H19 }
        v61.f32[0] = (float)((float)((float)(v26[v29] >> 6) / 1023.0) - _D18.f32[0]) * *(float *)_D19.i32;
        _H20 = *((_WORD *)v11 + 6);
        __asm { FCVT            S20, H20 }
        _H21 = *((_WORD *)v11 + 7);
        __asm { FCVT            S21, H21 }
        v66 = (float)((float)((float)(v27[v29] >> 6) / 1023.0) - _D18.f32[0]) * *(float *)_D19.i32;
        _D18.i16[0] = *(unsigned __int16 *)((char *)v18 + ((2 * v29) | 2));
        _D18.i16[2] = v18[v29];
        _D19.i32[0] = *(_DWORD *)(v11 + 2);
        v67 = (float16x4_t)vcvtq_f32_f16(_D19).u64[0];
        _D18 = vsub_f32(vdiv_f32(vcvt_f32_u32(vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)_D18, (int8x8_t)0xFFFF0000FFFFLL), 6uLL)), v19), (float32x2_t)v67);
        v67.i32[0] = *((_DWORD *)v11 + 2);
        _D19 = (float16x4_t)vcvtq_f32_f16(v67).u64[0];
        v68 = vmlas_n_f32(v61.f32[0], _S20, _D18.f32[0]);
        v69 = (float32x2_t)__PAIR64__(COERCE_UNSIGNED_INT(vmlas_n_f32(v66, _S20, _D18.f32[0])), LODWORD(v66));
        __asm { FMLA            S17, S21, V18.S[1] }
        v71 = vminnm_f32(vmla_f32(v69, (float32x2_t)_D19, _D18), _D3);
        v72 = fminf(_S17, 1.0);
        v73 = vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v71, v19), (int8x8_t)vcgtz_f32(v71))));
        if (v72 <= 0.0)
          v74 = 0.0;
        else
          v74 = v72 * 1023.0;
        v75 = rintf(v74);
        v76 = (int32x2_t)vshl_u32(v73, (uint32x2_t)0xA00000014);
        _D20 = (float32x2_t)vdup_lane_s32(v76, 1);
        __asm { FMLA            S23, S21, V18.S[1] }
        v78 = vorr_s8((int8x8_t)v76, (int8x8_t)_D20).u32[0] | v75 | 0xC0000000;
        v79 = fminf(_S23, 1.0);
        if (v79 <= 0.0)
          v80 = 0.0;
        else
          v80 = v79 * 1023.0;
        v61.f32[1] = v68;
        v81 = vminnm_f32(vmla_f32(v61, (float32x2_t)_D19, _D18), _D3);
        v82 = (int32x2_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v81, v19), (int8x8_t)vcgtz_f32(v81)))), (uint32x2_t)0xA00000014);
        *(_DWORD *)v28 = v78;
        _D16 = (float16x4_t)vorr_s8((int8x8_t)v82, (int8x8_t)vdup_lane_s32(v82, 1));
        *(_DWORD *)v30 = _D16.i32[0] | rintf(v80) | 0xC0000000;
      }
      v26 += (uint64_t)v13;
      v18 = (unsigned __int16 *)((char *)v18 + (_QWORD)v14);
      v17 = (unint64_t *)((char *)v17 + 2 * (_QWORD)v15);
      v12 += 2;
    }
    while (v12 < v10);
  }
  return 0;
}

uint64_t ConvertXF20toRGB16f(unsigned __int16 **a1, unsigned __int16 **a2, _QWORD *a3, __int16 *a4)
{
  uint64_t VectorLevel;
  char v10;

  VectorLevel = ImageIOSIMD_GetVectorLevel();
  if ((VectorLevel & 1) != 0)
    return xf20toRGB16f<(ImageIOVectorLevel)1>::operator()((uint64_t)&v10, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3, a4);
  xf20toRGB16f<(ImageIOVectorLevel)0>::operator()(VectorLevel, a1, a2, a3, a4);
  return 0;
}

uint64_t ConvertXF20toRGBA1010102(unsigned __int16 **a1, unsigned __int16 **a2, unint64_t **a3, __int16 *a4)
{
  uint64_t VectorLevel;
  char v10;

  VectorLevel = ImageIOSIMD_GetVectorLevel();
  if ((VectorLevel & 1) != 0)
    return xf20toRGBA1010102<(ImageIOVectorLevel)1>::operator()((uint64_t)&v10, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3, a4);
  xf20toRGBA1010102<(ImageIOVectorLevel)0>::operator()(VectorLevel, a1, a2, a3, (char *)a4);
  return 0;
}

void *GetXF20toRGB16fConversionInfo(int a1, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = &kDefaultXF20ToRGB16fConversion;
  if (a2)
    v2 = &kXF20ToRGB16fConversion_Rec601_VideoRange;
  v3 = &kXF20ToRGB16fConversion_Rec2020_FullRange;
  if (a2)
    v3 = &kXF20ToRGB16fConversion_Rec2020_VideoRange;
  v4 = &kXF20ToRGB16fConversion_Rec709_FullRange;
  if (a2)
    v4 = &kXF20ToRGB16fConversion_Rec709_VideoRange;
  if (a1 != 1)
    v4 = 0;
  if ((a1 - 9) >= 2)
    v5 = v4;
  else
    v5 = v3;
  if ((a1 - 5) >= 2)
    return v5;
  else
    return v2;
}

uint64_t xf20toRGB16f<(ImageIOVectorLevel)1>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
  uint16x8_t v8;
  uint16x8_t *v9;
  uint16x8_t *v10;
  unint64_t v11;
  int8x16_t *v12;
  unint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int32x2_t v17;
  float32x4_t v18;
  uint64_t v19;
  float32x4_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint16x8_t *v28;
  int8x16_t *v29;
  uint64_t v30;
  int8x16_t *v31;
  uint16x8_t *v32;
  uint16x8_t *v33;
  uint16x8_t v34;
  float32x4_t v35;
  uint16x8_t v36;
  float32x4_t v37;
  float32x4_t v38;
  uint16x8_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int16x8_t v51;
  int16x8_t v52;
  int16x8_t v53;
  int8x16_t v54;
  unint64_t v55;
  uint16x8_t *v56;
  size_t v57;
  size_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  uint64_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v77;
  float32x4_t v78;
  uint16x8_t v79;
  uint16x8_t v80;
  float32x4_t v81;
  uint16x8_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  int32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  int16x8_t v91;
  int16x8_t v92;
  float16x8_t v93;
  int8x16_t v94;
  unint64_t v95;
  uint64_t v96;
  size_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  int32x4_t v105;
  int16x8_t v106;
  char v108;
  int32x2_t v109;
  int32x2_t v110;
  unint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  int8x16_t v126;
  uint16x8_t v127;
  float32x4_t v128;
  float32x4_t v129;
  uint16x8_t v130;
  uint16x8_t v131;
  uint16x8_t __dst;
  _OWORD v133[2];
  int8x16_t __src;
  int8x16_t v135;
  int8x16_t v136;
  _OWORD v137[3];
  uint64_t v138;
  int8x16x2_t v139;
  int8x16x2_t v140;
  int8x16x2_t v141;
  int8x16x2_t v142;
  int8x16x2_t v143;
  int8x16x2_t v144;
  int8x16x2_t v145;
  int8x16x2_t v146;
  int8x16x2_t v147;
  int8x16x2_t v148;
  int8x16x2_t v149;
  int8x16x2_t v150;
  int8x16x2_t v151;
  int8x16x2_t v152;
  int8x16x2_t v153;
  int8x16x2_t v154;

  v138 = *MEMORY[0x1E0C80C00];
  memset(v133, 0, sizeof(v133));
  VEC::xf20Constants::xf20Constants((float *)v133, a5);
  v9 = *(uint16x8_t **)a2;
  v10 = *(uint16x8_t **)a3;
  v12 = *(int8x16_t **)a4;
  v11 = *(_QWORD *)(a4 + 8);
  v13 = *(_QWORD *)(a4 + 16);
  v14.i64[0] = *(_QWORD *)((char *)v133 + 12);
  v14.i64[1] = *(_QWORD *)((char *)v133 + 12);
  v15 = (float32x4_t)vrev64q_s32((int32x4_t)v14);
  v16.i32[0] = vdupq_lane_s32(*(int32x2_t *)((char *)&v133[1] + 8), 1).u32[0];
  v16.i32[1] = DWORD2(v133[0]);
  v16.i64[1] = __PAIR64__(DWORD2(v133[0]), HIDWORD(v133[1]));
  v17 = *(int32x2_t *)((char *)&v133[1] + 4);
  v18 = (float32x4_t)vdupq_lane_s64(__SPAIR64__(DWORD1(v133[0]), DWORD2(v133[1])), 0);
  v108 = v11;
  if (v11 >= 2)
  {
    v19 = 0;
    v113 = *(_QWORD *)(a3 + 24);
    v114 = *(_QWORD *)(a2 + 24);
    v111 = v11 >> 1;
    v112 = *(_QWORD *)(a4 + 24);
    v20 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)&v133[1] + 4), 0);
    v21.i64[0] = 0x4B004B004B004B00;
    v21.i64[1] = 0x4B004B004B004B00;
    v22 = (int8x16_t)xmmword_18820C2E0;
    v23 = (float32x4_t)vdupq_n_s32(0x3A802008u);
    v24 = (float32x4_t)vdupq_n_s32(0xC6002008);
    v25 = (int8x16_t)xmmword_18820C2F0;
    v26 = (int8x16_t)xmmword_18820C300;
    v27 = (int8x16_t)xmmword_18820C310;
    v122 = v15;
    v124 = v14;
    v118 = v18;
    v120 = v16;
    v109 = *(int32x2_t *)((char *)&v133[1] + 4);
    v117 = v20;
    v128 = v24;
    v129 = v23;
    do
    {
      v28 = (uint16x8_t *)((char *)v9 + v114);
      v29 = (int8x16_t *)((char *)v12 + v112);
      if (v13 >= 8)
      {
        v30 = 0;
        v33 = v9;
        v32 = v10;
        v31 = v12;
        do
        {
          v34 = *v33++;
          v8 = vshrq_n_u16(v34, 6uLL);
          v35 = vmlaq_f32(v24, v23, (float32x4_t)vqtbl2q_s8(*(int8x16x2_t *)(&v8 - 1), v25));
          v36 = *v28++;
          v143.val[1] = (int8x16_t)vshrq_n_u16(v36, 6uLL);
          v37 = vmlaq_f32(v24, v23, (float32x4_t)vqtbl2q_s8(*(int8x16x2_t *)(&v8 - 1), v22));
          v143.val[0] = v21;
          v38 = (float32x4_t)vqtbl2q_s8(v143, v22);
          v143.val[1] = (int8x16_t)vmlaq_f32(v24, v23, (float32x4_t)vqtbl2q_s8(v143, v25));
          v39 = *v32++;
          v147.val[1] = (int8x16_t)vshrq_n_u16(v39, 6uLL);
          v147.val[0] = v21;
          v143.val[0] = vqtbl2q_s8(v147, v22);
          v40 = vmlaq_f32(v24, v23, v38);
          v147.val[0] = (int8x16_t)vmlaq_f32(v24, v23, (float32x4_t)vqtbl2q_s8(v147, v25));
          v41 = vmlaq_f32(v24, v23, (float32x4_t)v143.val[0]);
          v42 = vmlaq_f32(vmlaq_f32(v20, (float32x4_t)vrev64q_s32((int32x4_t)v147.val[0]), v15), (float32x4_t)v147.val[0], v14);
          v147.val[1] = (int8x16_t)vmlaq_f32(vmlaq_f32(v20, (float32x4_t)vrev64q_s32((int32x4_t)v41), v15), v41, v14);
          v143.val[0] = (int8x16_t)vmlaq_f32(v16, (float32x4_t)v147.val[0], v18);
          v147.val[0] = (int8x16_t)vmlaq_f32(v16, v41, v18);
          v43 = (float32x4_t)vtrn2q_s32((int32x4_t)v147.val[0], (int32x4_t)v147.val[0]);
          v44 = (float32x4_t)vtrn2q_s32((int32x4_t)v143.val[0], (int32x4_t)v143.val[0]);
          v147.val[0] = (int8x16_t)vtrn1q_s32((int32x4_t)v147.val[0], (int32x4_t)v147.val[0]);
          v143.val[0] = (int8x16_t)vtrn1q_s32((int32x4_t)v143.val[0], (int32x4_t)v143.val[0]);
          v45 = vmlaq_n_f32(v44, v35, *(float *)v133);
          v46 = vmlaq_n_f32(v42, v35, *(float *)v133);
          v47 = vmlaq_n_f32(v42, (float32x4_t)v143.val[1], *(float *)v133);
          v48 = vmlaq_n_f32((float32x4_t)v143.val[0], v35, *(float *)v133);
          v49 = vmlaq_n_f32((float32x4_t)v147.val[1], v37, *(float *)v133);
          v50 = vmlaq_n_f32((float32x4_t)v147.val[0], v37, *(float *)v133);
          v143.val[0] = (int8x16_t)vmlaq_n_f32((float32x4_t)v143.val[0], (float32x4_t)v143.val[1], *(float *)v133);
          v147.val[0] = (int8x16_t)vmlaq_n_f32((float32x4_t)v147.val[0], v40, *(float *)v133);
          v51 = (int16x8_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v45), vmlaq_n_f32(v43, v37, *(float *)v133));
          v143.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_n_f32(v44, (float32x4_t)v143.val[1], *(float *)v133)), vmlaq_n_f32(v43, v40, *(float *)v133));
          v52 = (int16x8_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v47), vmlaq_n_f32((float32x4_t)v147.val[1], v40, *(float *)v133));
          v53 = (int16x8_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v46), v49);
          v149.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v48), v50);
          v151.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32((float32x4_t)v143.val[0]), (float32x4_t)v147.val[0]);
          v147.val[0] = (int8x16_t)vzip2q_s16(v51, v53);
          v149.val[0] = (int8x16_t)vzip1q_s16(v51, v53);
          v54 = vqtbl2q_s8(v149, v26);
          v147.val[1] = v149.val[1];
          v149.val[0] = vextq_s8(v149.val[0], v147.val[0], 0xCuLL);
          *v31 = v54;
          v31[1] = vqtbl2q_s8(v149, (int8x16_t)xmmword_18820C320);
          v31[2] = vqtbl2q_s8(v147, v27);
          v139.val[0] = (int8x16_t)vzip2q_s16((int16x8_t)v143.val[1], v52);
          v151.val[0] = (int8x16_t)vzip1q_s16((int16x8_t)v143.val[1], v52);
          v31 += 3;
          v143.val[0] = vqtbl2q_s8(v151, v26);
          v139.val[1] = v151.val[1];
          v151.val[0] = vextq_s8(v151.val[0], v139.val[0], 0xCuLL);
          *v29 = v143.val[0];
          v29[1] = vqtbl2q_s8(v151, (int8x16_t)xmmword_18820C320);
          v29[2] = vqtbl2q_s8(v139, v27);
          v29 += 3;
          v55 = v30 + 16;
          v30 += 8;
        }
        while (v55 <= v13);
      }
      else
      {
        v30 = 0;
        v31 = v12;
        v32 = v10;
        v33 = v9;
      }
      if ((v13 & 7) != 0)
      {
        v115 = v13 - v30;
        v116 = v19;
        v131 = 0u;
        __dst = 0u;
        v130 = 0u;
        v56 = v10;
        v57 = 2 * (v13 - v30);
        v126 = v21;
        v127 = v8;
        memcpy(&__dst, v33, v57);
        memcpy(&v131, v28, v57);
        v58 = v57 + 2;
        v10 = v56;
        memcpy(&v130, v32, v58 & 0xFFFFFFFFFFFFFFFCLL);
        v140.val[1] = (int8x16_t)vshrq_n_u16(__dst, 6uLL);
        v140.val[0] = v126;
        v59 = (float32x4_t)vqtbl2q_s8(v140, (int8x16_t)xmmword_18820C2E0);
        v140.val[1] = (int8x16_t)vmlaq_f32(v128, v129, (float32x4_t)vqtbl2q_s8(v140, (int8x16_t)xmmword_18820C2F0));
        v140.val[0] = (int8x16_t)vmlaq_f32(v128, v129, v59);
        v142.val[1] = (int8x16_t)vshrq_n_u16(v131, 6uLL);
        v142.val[0] = v126;
        v60 = (float32x4_t)vqtbl2q_s8(v142, (int8x16_t)xmmword_18820C2E0);
        v142.val[1] = (int8x16_t)vmlaq_f32(v128, v129, (float32x4_t)vqtbl2q_s8(v142, (int8x16_t)xmmword_18820C2F0));
        v142.val[0] = (int8x16_t)vmlaq_f32(v128, v129, v60);
        v145.val[1] = (int8x16_t)vshrq_n_u16(v130, 6uLL);
        v145.val[0] = v126;
        v61 = (float32x4_t)vqtbl2q_s8(v145, (int8x16_t)xmmword_18820C2E0);
        v145.val[1] = (int8x16_t)vmlaq_f32(v128, v129, (float32x4_t)vqtbl2q_s8(v145, (int8x16_t)xmmword_18820C2F0));
        v145.val[0] = (int8x16_t)vmlaq_f32(v128, v129, v61);
        v62 = vmlaq_f32(vmlaq_f32(v117, (float32x4_t)vrev64q_s32((int32x4_t)v145.val[1]), v122), (float32x4_t)v145.val[1], v124);
        v63 = vmlaq_f32(vmlaq_f32(v117, (float32x4_t)vrev64q_s32((int32x4_t)v145.val[0]), v122), (float32x4_t)v145.val[0], v124);
        v64 = (int32x4_t)vmlaq_f32(v120, (float32x4_t)v145.val[1], v118);
        v145.val[1] = (int8x16_t)vmlaq_f32(v120, (float32x4_t)v145.val[0], v118);
        v145.val[0] = (int8x16_t)vtrn2q_s32((int32x4_t)v145.val[1], (int32x4_t)v145.val[1]);
        v65 = (float32x4_t)vtrn2q_s32(v64, v64);
        v145.val[1] = (int8x16_t)vtrn1q_s32((int32x4_t)v145.val[1], (int32x4_t)v145.val[1]);
        v66 = (float32x4_t)vtrn1q_s32(v64, v64);
        v67 = vmlaq_n_f32(v65, (float32x4_t)v140.val[1], *(float *)v133);
        v68 = vmlaq_n_f32(v62, (float32x4_t)v140.val[1], *(float *)v133);
        v69 = vmlaq_n_f32(v63, (float32x4_t)v140.val[0], *(float *)v133);
        v70 = vmlaq_n_f32(v62, (float32x4_t)v142.val[1], *(float *)v133);
        v71 = vmlaq_n_f32(v63, (float32x4_t)v142.val[0], *(float *)v133);
        v72 = vmlaq_n_f32(v66, (float32x4_t)v140.val[1], *(float *)v133);
        v140.val[1] = (int8x16_t)vmlaq_n_f32((float32x4_t)v145.val[1], (float32x4_t)v140.val[0], *(float *)v133);
        v73 = vmlaq_n_f32(v66, (float32x4_t)v142.val[1], *(float *)v133);
        v145.val[1] = (int8x16_t)vmlaq_n_f32((float32x4_t)v145.val[1], (float32x4_t)v142.val[0], *(float *)v133);
        v140.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v67), vmlaq_n_f32((float32x4_t)v145.val[0], (float32x4_t)v140.val[0], *(float *)v133));
        v142.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_n_f32(v65, (float32x4_t)v142.val[1], *(float *)v133)), vmlaq_n_f32((float32x4_t)v145.val[0], (float32x4_t)v142.val[0], *(float *)v133));
        v142.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v68), v69);
        v145.val[0] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v70), v71);
        v150.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v72), (float32x4_t)v140.val[1]);
        v148.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v73), (float32x4_t)v145.val[1]);
        v152.val[0] = (int8x16_t)vzip2q_s16((int16x8_t)v140.val[0], (int16x8_t)v142.val[1]);
        v150.val[0] = (int8x16_t)vzip1q_s16((int16x8_t)v140.val[0], (int16x8_t)v142.val[1]);
        v140.val[0] = vqtbl2q_s8(v150, (int8x16_t)xmmword_18820C300);
        v152.val[1] = v150.val[1];
        v150.val[0] = vextq_s8(v150.val[0], v152.val[0], 0xCuLL);
        __src = v140.val[0];
        v135 = vqtbl2q_s8(v150, (int8x16_t)xmmword_18820C320);
        v150.val[0] = (int8x16_t)vzip2q_s16((int16x8_t)v142.val[0], (int16x8_t)v145.val[0]);
        v148.val[0] = (int8x16_t)vzip1q_s16((int16x8_t)v142.val[0], (int16x8_t)v145.val[0]);
        v140.val[0] = vqtbl2q_s8(v148, (int8x16_t)xmmword_18820C300);
        v150.val[1] = v148.val[1];
        v148.val[0] = vextq_s8(v148.val[0], v150.val[0], 0xCuLL);
        v136 = vqtbl2q_s8(v152, (int8x16_t)xmmword_18820C310);
        v137[0] = v140.val[0];
        v137[1] = vqtbl2q_s8(v148, (int8x16_t)xmmword_18820C320);
        v137[2] = vqtbl2q_s8(v150, (int8x16_t)xmmword_18820C310);
        memcpy(v31, &__src, 6 * v115);
        memcpy(v29, v137, 6 * v115);
        v27 = (int8x16_t)xmmword_18820C310;
        v26 = (int8x16_t)xmmword_18820C300;
        v25 = (int8x16_t)xmmword_18820C2F0;
        v22 = (int8x16_t)xmmword_18820C2E0;
        v24 = v128;
        v23 = v129;
        v21 = v126;
        v8 = v127;
        v20 = v117;
        v18 = v118;
        v19 = v116;
        v17 = v109;
        v16 = v120;
        v15 = v122;
        v14 = v124;
      }
      v9 = (uint16x8_t *)((char *)v9 + 2 * v114);
      v10 = (uint16x8_t *)((char *)v10 + v113);
      v12 = (int8x16_t *)((char *)v12 + 2 * v112);
      ++v19;
    }
    while (v19 != v111);
  }
  if ((v108 & 1) != 0)
  {
    if (v13 >= 8)
    {
      v74 = 0;
      v75 = (float32x4_t)vdupq_n_s32(0x3A802008u);
      v76 = (float32x4_t)vdupq_n_s32(0xC6002008);
      v77.i64[0] = 0x4B004B004B004B00;
      v77.i64[1] = 0x4B004B004B004B00;
      v78 = (float32x4_t)vdupq_lane_s32(v17, 0);
      do
      {
        v79 = *v9++;
        v80 = vshrq_n_u16(v79, 6uLL);
        v81 = vmlaq_f32(v76, v75, (float32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v77.i8, (int8x16_t)xmmword_18820C2F0));
        v82 = *v10++;
        v154.val[1] = (int8x16_t)vshrq_n_u16(v82, 6uLL);
        v154.val[0] = v77;
        v83 = (float32x4_t)vqtbl2q_s8(v154, (int8x16_t)xmmword_18820C2E0);
        v84 = vmlaq_f32(v76, v75, (float32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v77.i8, (int8x16_t)xmmword_18820C2E0));
        v154.val[0] = (int8x16_t)vmlaq_f32(v76, v75, (float32x4_t)vqtbl2q_s8(v154, (int8x16_t)xmmword_18820C2F0));
        v85 = vmlaq_f32(v76, v75, v83);
        v86 = vmlaq_f32(vmlaq_f32(v78, (float32x4_t)vrev64q_s32((int32x4_t)v154.val[0]), v15), (float32x4_t)v154.val[0], v14);
        v87 = (int32x4_t)vmlaq_f32(v16, (float32x4_t)v154.val[0], v18);
        v154.val[0] = (int8x16_t)vmlaq_f32(v16, v85, v18);
        v88 = (float32x4_t)vtrn2q_s32(v87, v87);
        v89 = vmlaq_n_f32(v86, v81, *(float *)v133);
        v90 = vmlaq_n_f32((float32x4_t)vtrn1q_s32(v87, v87), v81, *(float *)v133);
        v91 = (int16x8_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_n_f32(v88, v81, *(float *)v133)), vmlaq_n_f32((float32x4_t)vtrn2q_s32((int32x4_t)v154.val[0], (int32x4_t)v154.val[0]), v84, *(float *)v133));
        v92 = (int16x8_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v89), vmlaq_n_f32(vmlaq_f32(vmlaq_f32(v78, (float32x4_t)vrev64q_s32((int32x4_t)v85), v15), v85, v14), v84, *(float *)v133));
        v93 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v90), vmlaq_n_f32((float32x4_t)vtrn1q_s32((int32x4_t)v154.val[0], (int32x4_t)v154.val[0]), v84, *(float *)v133));
        v154.val[1] = (int8x16_t)vzip1q_s16(v91, v92);
        v153.val[0] = (int8x16_t)vzip2q_s16(v91, v92);
        v94 = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v154 + 16), (int8x16_t)xmmword_18820C300);
        v153.val[1] = (int8x16_t)v93;
        v154.val[1] = vextq_s8(v154.val[1], v153.val[0], 0xCuLL);
        *v12 = v94;
        v12[1] = vqtbl2q_s8(*(int8x16x2_t *)((char *)&v154 + 16), (int8x16_t)xmmword_18820C320);
        v12[2] = vqtbl2q_s8(v153, (int8x16_t)xmmword_18820C310);
        v12 += 3;
        v95 = v74 + 16;
        v74 += 8;
      }
      while (v95 <= v13);
    }
    else
    {
      v74 = 0;
    }
    if ((v13 & 7) != 0)
    {
      v96 = v13 - v74;
      v131 = 0u;
      __dst = 0u;
      v97 = 2 * (v13 - v74);
      v123 = v15;
      v125 = v14;
      v119 = v18;
      v121 = v16;
      v110 = v17;
      memcpy(&__dst, v9, v97);
      memcpy(&v131, v10, (v97 + 2) & 0xFFFFFFFFFFFFFFFCLL);
      v141.val[1] = (int8x16_t)vshrq_n_u16(__dst, 6uLL);
      v141.val[0].i64[0] = 0x4B004B004B004B00;
      v141.val[0].i64[1] = 0x4B004B004B004B00;
      v98 = (float32x4_t)vdupq_n_s32(0x3A802008u);
      v99 = (float32x4_t)vdupq_n_s32(0xC6002008);
      v100 = vmlaq_f32(v99, v98, (float32x4_t)vqtbl2q_s8(v141, (int8x16_t)xmmword_18820C2F0));
      v101 = vmlaq_f32(v99, v98, (float32x4_t)vqtbl2q_s8(v141, (int8x16_t)xmmword_18820C2E0));
      v141.val[1] = (int8x16_t)vshrq_n_u16(v131, 6uLL);
      v102 = (float32x4_t)vqtbl2q_s8(v141, (int8x16_t)xmmword_18820C2E0);
      v141.val[1] = (int8x16_t)vmlaq_f32(v99, v98, (float32x4_t)vqtbl2q_s8(v141, (int8x16_t)xmmword_18820C2F0));
      v103 = vmlaq_f32(v99, v98, v102);
      v104 = (float32x4_t)vdupq_lane_s32(v110, 0);
      v141.val[0] = (int8x16_t)vmlaq_f32(v121, (float32x4_t)v141.val[1], v119);
      v105 = (int32x4_t)vmlaq_f32(v121, v103, v119);
      v106 = (int16x8_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_n_f32((float32x4_t)vtrn2q_s32((int32x4_t)v141.val[0], (int32x4_t)v141.val[0]), v100, *(float *)v133)), vmlaq_n_f32((float32x4_t)vtrn2q_s32(v105, v105), v101, *(float *)v133));
      v141.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_n_f32(vmlaq_f32(vmlaq_f32(v104, (float32x4_t)vrev64q_s32((int32x4_t)v141.val[1]), v123), (float32x4_t)v141.val[1], v125), v100, *(float *)v133)), vmlaq_n_f32(vmlaq_f32(vmlaq_f32(v104, (float32x4_t)vrev64q_s32((int32x4_t)v103), v123), v103, v125), v101, *(float *)v133));
      v144.val[1] = (int8x16_t)vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(vmlaq_n_f32((float32x4_t)vtrn1q_s32((int32x4_t)v141.val[0], (int32x4_t)v141.val[0]), v100, *(float *)v133)), vmlaq_n_f32((float32x4_t)vtrn1q_s32(v105, v105), v101, *(float *)v133));
      v146.val[0] = (int8x16_t)vzip2q_s16(v106, (int16x8_t)v141.val[1]);
      v144.val[0] = (int8x16_t)vzip1q_s16(v106, (int16x8_t)v141.val[1]);
      v141.val[0] = vqtbl2q_s8(v144, (int8x16_t)xmmword_18820C300);
      v146.val[1] = v144.val[1];
      v144.val[0] = vextq_s8(v144.val[0], v146.val[0], 0xCuLL);
      __src = v141.val[0];
      v135 = vqtbl2q_s8(v144, (int8x16_t)xmmword_18820C320);
      v136 = vqtbl2q_s8(v146, (int8x16_t)xmmword_18820C310);
      memcpy(v12, &__src, 6 * v96);
    }
  }
  return 0;
}

uint64_t xf20toRGBA1010102<(ImageIOVectorLevel)1>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
  uint16x8_t *v8;
  uint16x8_t *v9;
  unint64_t v10;
  int32x4_t *v11;
  unint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int32x2_t v16;
  float32x4_t v17;
  uint64_t v18;
  float32x4_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  int32x4_t v31;
  uint16x8_t *v32;
  int32x4_t *v33;
  uint64_t v34;
  int32x4_t *v35;
  uint16x8_t *v36;
  uint16x8_t *v37;
  uint64_t v38;
  uint16x8_t v39;
  uint16x8_t v40;
  float32x4_t v41;
  uint16x8_t v42;
  float32x4_t v43;
  float32x4_t v44;
  uint16x8_t v45;
  float32x4_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  int32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  int32x4_t v64;
  int32x4_t v65;
  float32x4_t v66;
  unint64_t v67;
  size_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int32x4_t v75;
  int32x4_t v76;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  int32x4_t v86;
  uint64_t v87;
  uint64_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  int8x16_t v92;
  float32x4_t v93;
  int32x4_t v95;
  uint16x8_t v96;
  uint16x8_t v97;
  uint16x8_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  int32x4_t v104;
  unint64_t v105;
  uint64_t v106;
  size_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  int32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v126;
  int32x2_t v127;
  int32x2_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  uint16x8_t v147[2];
  int32x4_t __src;
  int32x4_t v149;
  uint16x8_t v150;
  uint16x8_t v151;
  uint16x8_t __dst;
  _OWORD v153[3];
  int8x16x2_t v154;
  int8x16x2_t v155;
  int8x16x2_t v156;
  int8x16x2_t v157;

  memset(v153, 0, 32);
  VEC::xf20Constants::xf20Constants((float *)v153, a5);
  v8 = *(uint16x8_t **)a2;
  v9 = *(uint16x8_t **)a3;
  v11 = *(int32x4_t **)a4;
  v10 = *(_QWORD *)(a4 + 8);
  v12 = *(_QWORD *)(a4 + 16);
  v13.i64[0] = *(_QWORD *)((char *)v153 + 12);
  v13.i64[1] = *(_QWORD *)((char *)v153 + 12);
  v14 = (float32x4_t)vrev64q_s32((int32x4_t)v13);
  v15.i32[0] = vdupq_lane_s32(*(int32x2_t *)((char *)&v153[1] + 8), 1).u32[0];
  v15.i32[1] = DWORD2(v153[0]);
  v15.i64[1] = __PAIR64__(DWORD2(v153[0]), HIDWORD(v153[1]));
  v16 = *(int32x2_t *)((char *)&v153[1] + 4);
  v17 = (float32x4_t)vdupq_lane_s64(__SPAIR64__(DWORD1(v153[0]), DWORD2(v153[1])), 0);
  if (v10 >= 2)
  {
    v18 = 0;
    v131 = *(_QWORD *)(a3 + 24);
    v132 = *(_QWORD *)(a2 + 24);
    v129 = v10 >> 1;
    v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)((char *)&v153[1] + 4), 0);
    v20 = (int8x16_t)xmmword_18820C2E0;
    v21 = (int8x16_t)xmmword_18820C2F0;
    v22 = (float32x4_t)vdupq_n_s32(0x3A802008u);
    v23 = (float32x4_t)vdupq_n_s32(0xC6002008);
    v24 = (float32x4_t)vdupq_n_s32(0x447FC000u);
    v130 = *(_QWORD *)(a4 + 24);
    v25.i64[0] = 0x4B004B004B004B00;
    v25.i64[1] = 0x4B004B004B004B00;
    __asm { FMOV            V13.4S, #1.0 }
    v31.i64[0] = 0x300000003;
    v31.i64[1] = 0x300000003;
    v139 = v14;
    v141 = v13;
    v135 = v17;
    v137 = v15;
    v127 = *(int32x2_t *)((char *)&v153[1] + 4);
    v126 = *(_QWORD *)(a4 + 8);
    v134 = v19;
    v143 = v23;
    v144 = v22;
    v145 = _Q13;
    v146 = v24;
    do
    {
      v32 = (uint16x8_t *)((char *)v8 + v132);
      v33 = (int32x4_t *)((char *)v11 + v130);
      if (v12 >= 8)
      {
        v38 = 0;
        v37 = v8;
        v36 = v9;
        v35 = v11;
        do
        {
          v39 = *v37++;
          v40 = vshrq_n_u16(v39, 6uLL);
          v41 = vmlaq_f32(v23, v22, (float32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v25.i8, v21));
          v42 = *v32++;
          v156.val[1] = (int8x16_t)vshrq_n_u16(v42, 6uLL);
          v156.val[0] = v25;
          v43 = (float32x4_t)vqtbl2q_s8(v156, v20);
          v44 = vmlaq_f32(v23, v22, (float32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v25.i8, v20));
          v45 = *v36++;
          v46 = vmlaq_f32(v23, v22, (float32x4_t)vqtbl2q_s8(v156, v21));
          v156.val[0] = (int8x16_t)vshrq_n_u16(v45, 6uLL);
          v47 = v25;
          v48 = vmlaq_f32(v23, v22, (float32x4_t)vqtbl2q_s8(v156, v21));
          v49 = vmlaq_f32(v23, v22, (float32x4_t)vqtbl2q_s8(v156, v20));
          v50 = vmlaq_f32(v23, v22, v43);
          v51 = vmlaq_f32(vmlaq_f32(v19, (float32x4_t)vrev64q_s32((int32x4_t)v48), v14), v48, v13);
          v156.val[0] = (int8x16_t)vmlaq_f32(vmlaq_f32(v19, (float32x4_t)vrev64q_s32((int32x4_t)v49), v14), v49, v13);
          v52 = (int32x4_t)vmlaq_f32(v15, v48, v17);
          v156.val[1] = (int8x16_t)vmlaq_f32(v15, v49, v17);
          v53 = (float32x4_t)vtrn2q_s32((int32x4_t)v156.val[1], (int32x4_t)v156.val[1]);
          v54 = (float32x4_t)vtrn2q_s32(v52, v52);
          v156.val[1] = (int8x16_t)vtrn1q_s32((int32x4_t)v156.val[1], (int32x4_t)v156.val[1]);
          v55 = (float32x4_t)vtrn1q_s32(v52, v52);
          v56 = vmlaq_n_f32(v54, v41, *(float *)v153);
          v57 = vmlaq_n_f32(v53, v44, *(float *)v153);
          v58 = vmlaq_n_f32(v53, v50, *(float *)v153);
          v59 = (float32x4_t)v156.val[0];
          v60 = vmlaq_n_f32(v51, v41, *(float *)v153);
          v156.val[0] = (int8x16_t)vmlaq_n_f32((float32x4_t)v156.val[0], v50, *(float *)v153);
          v61 = vmlaq_n_f32(v55, v41, *(float *)v153);
          v62 = vmlaq_n_f32((float32x4_t)v156.val[1], v44, *(float *)v153);
          v63 = vmlaq_n_f32(v59, v44, *(float *)v153);
          v156.val[1] = (int8x16_t)vmlaq_n_f32((float32x4_t)v156.val[1], v50, *(float *)v153);
          v64 = (int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32(v54, v46, *(float *)v153), _Q13), v24));
          v65 = (int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32(v51, v46, *(float *)v153), _Q13), v24));
          v66 = vminnmq_f32(vmlaq_n_f32(v55, v46, *(float *)v153), _Q13);
          *v35 = vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v61, _Q13), v24)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v60, _Q13), v24)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v56, _Q13), v24)), v31, 0xAuLL), 0xAuLL), 0xAuLL);
          v35[1] = vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v62, _Q13), v24)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v63, _Q13), v24)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v57, _Q13), v24)), v31, 0xAuLL), 0xAuLL), 0xAuLL);
          v35 += 2;
          *v33 = vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(v66, v24)), vsliq_n_s32(v65, vsliq_n_s32(v64, v31, 0xAuLL), 0xAuLL), 0xAuLL);
          v33[1] = vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32((float32x4_t)v156.val[1], _Q13), v24)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32((float32x4_t)v156.val[0], _Q13), v24)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v58, _Q13), v24)), v31, 0xAuLL), 0xAuLL), 0xAuLL);
          v33 += 2;
          v34 = v38 + 8;
          v67 = v38 + 16;
          v38 += 8;
        }
        while (v67 <= v12);
      }
      else
      {
        v34 = 0;
        v35 = v11;
        v36 = v9;
        v37 = v8;
      }
      if ((v12 & 7) != 0)
      {
        v133 = v12 - v34;
        v151 = 0u;
        __dst = 0u;
        v150 = 0u;
        v68 = 2 * (v12 - v34);
        memcpy(&__dst, v37, v68);
        memcpy(&v151, v32, v68);
        memcpy(&v150, v36, (v68 + 2) & 0xFFFFFFFFFFFFFFFCLL);
        v154.val[1] = (int8x16_t)vshrq_n_u16(__dst, 6uLL);
        v154.val[0] = v25;
        v69 = vmlaq_f32(v143, v144, (float32x4_t)vqtbl2q_s8(v154, (int8x16_t)xmmword_18820C2F0));
        v70 = vmlaq_f32(v143, v144, (float32x4_t)vqtbl2q_s8(v154, (int8x16_t)xmmword_18820C2E0));
        v154.val[1] = (int8x16_t)vshrq_n_u16(v151, 6uLL);
        v71 = vmlaq_f32(v143, v144, (float32x4_t)vqtbl2q_s8(v154, (int8x16_t)xmmword_18820C2F0));
        v72 = vmlaq_f32(v143, v144, (float32x4_t)vqtbl2q_s8(v154, (int8x16_t)xmmword_18820C2E0));
        v154.val[1] = (int8x16_t)vshrq_n_u16(v150, 6uLL);
        v154.val[0] = v25;
        v73 = vmlaq_f32(v143, v144, (float32x4_t)vqtbl2q_s8(v154, (int8x16_t)xmmword_18820C2F0));
        v74 = vmlaq_f32(v143, v144, (float32x4_t)vqtbl2q_s8(v154, (int8x16_t)xmmword_18820C2E0));
        v154.val[0] = (int8x16_t)vmlaq_f32(vmlaq_f32(v134, (float32x4_t)vrev64q_s32((int32x4_t)v73), v139), v73, v141);
        v154.val[1] = (int8x16_t)vmlaq_f32(vmlaq_f32(v134, (float32x4_t)vrev64q_s32((int32x4_t)v74), v139), v74, v141);
        v75 = (int32x4_t)vmlaq_f32(v137, v73, v135);
        v76 = (int32x4_t)vmlaq_f32(v137, v74, v135);
        v77 = (float32x4_t)vtrn2q_s32(v76, v76);
        v78 = (float32x4_t)vtrn2q_s32(v75, v75);
        v79 = (float32x4_t)vtrn1q_s32(v76, v76);
        v80 = (float32x4_t)vtrn1q_s32(v75, v75);
        v81 = vmlaq_n_f32(v78, v69, *(float *)v153);
        v82 = vmlaq_n_f32(v78, v71, *(float *)v153);
        v83 = vmlaq_n_f32((float32x4_t)v154.val[0], v69, *(float *)v153);
        v154.val[0] = (int8x16_t)vmlaq_n_f32((float32x4_t)v154.val[0], v71, *(float *)v153);
        v84 = vmlaq_n_f32(v80, v69, *(float *)v153);
        v85 = vmlaq_n_f32(v80, v71, *(float *)v153);
        v86.i64[0] = 0x300000003;
        v86.i64[1] = 0x300000003;
        __src = vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v84, v145), v146)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v83, v145), v146)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v81, v145), v146)), v86, 0xAuLL), 0xAuLL), 0xAuLL);
        v149 = vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32(v79, v70, *(float *)v153), v145), v146)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32((float32x4_t)v154.val[1], v70, *(float *)v153), v145), v146)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32(v77, v70, *(float *)v153), v145), v146)), v86, 0xAuLL), 0xAuLL), 0xAuLL);
        v71.i64[0] = 0x300000003;
        v71.i64[1] = 0x300000003;
        v147[0] = (uint16x8_t)vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v85, v145), v146)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32((float32x4_t)v154.val[0], v145), v146)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v82, v145), v146)), (int32x4_t)v71, 0xAuLL), 0xAuLL), 0xAuLL);
        v147[1] = (uint16x8_t)vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32(v79, v72, *(float *)v153), v145), v146)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32((float32x4_t)v154.val[1], v72, *(float *)v153), v145), v146)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32(v77, v72, *(float *)v153), v145), v146)), (int32x4_t)v71, 0xAuLL), 0xAuLL), 0xAuLL);
        memcpy(v35, &__src, 4 * v133);
        memcpy(v33, v147, 4 * v133);
        v31.i64[0] = 0x300000003;
        v31.i64[1] = 0x300000003;
        _Q13 = v145;
        v24 = v146;
        v23 = v143;
        v22 = v144;
        v21 = (int8x16_t)xmmword_18820C2F0;
        v20 = (int8x16_t)xmmword_18820C2E0;
        v19 = v134;
        v17 = v135;
        LOBYTE(v10) = v126;
        v16 = v127;
        v15 = v137;
        v14 = v139;
        v13 = v141;
      }
      v8 = (uint16x8_t *)((char *)v8 + 2 * v132);
      v9 = (uint16x8_t *)((char *)v9 + v131);
      v11 = (int32x4_t *)((char *)v11 + 2 * v130);
      ++v18;
    }
    while (v18 != v129);
  }
  if ((v10 & 1) != 0)
  {
    if (v12 >= 8)
    {
      v88 = 0;
      v89 = (float32x4_t)vdupq_n_s32(0x3A802008u);
      v90 = (float32x4_t)vdupq_n_s32(0xC6002008);
      v91 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      v92.i64[0] = 0x4B004B004B004B00;
      v92.i64[1] = 0x4B004B004B004B00;
      v93 = (float32x4_t)vdupq_lane_s32(v16, 0);
      __asm { FMOV            V16.4S, #1.0 }
      v95.i64[0] = 0x300000003;
      v95.i64[1] = 0x300000003;
      do
      {
        v96 = *v8++;
        v97 = vshrq_n_u16(v96, 6uLL);
        v98 = *v9++;
        v157.val[1] = (int8x16_t)vshrq_n_u16(v98, 6uLL);
        v157.val[0] = v92;
        v99 = (float32x4_t)vqtbl2q_s8(v157, (int8x16_t)xmmword_18820C2E0);
        v100 = vmlaq_f32(v90, v89, (float32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v92.i8, (int8x16_t)xmmword_18820C2F0));
        v157.val[0] = (int8x16_t)vmlaq_f32(v90, v89, (float32x4_t)vqtbl2q_s8(v157, (int8x16_t)xmmword_18820C2F0));
        v101 = vmlaq_f32(v90, v89, v99);
        v102 = vmlaq_f32(v90, v89, (float32x4_t)vqtbl2q_s8(*(int8x16x2_t *)v92.i8, (int8x16_t)xmmword_18820C2E0));
        v103 = vmlaq_f32(vmlaq_f32(v93, (float32x4_t)vrev64q_s32((int32x4_t)v157.val[0]), v14), (float32x4_t)v157.val[0], v13);
        v104 = (int32x4_t)vmlaq_f32(v15, (float32x4_t)v157.val[0], v17);
        v157.val[0] = (int8x16_t)vmlaq_f32(v15, v101, v17);
        v157.val[0] = (int8x16_t)vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32((float32x4_t)vtrn1q_s32((int32x4_t)v157.val[0], (int32x4_t)v157.val[0]), v102, *(float *)v153), _Q16), v91)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32(vmlaq_f32(vmlaq_f32(v93, (float32x4_t)vrev64q_s32((int32x4_t)v101), v14), v101,
                                                          v13),
                                                        v102,
                                                        *(float *)v153),
                                                      _Q16),
                                                    v91)),
                                     vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32((float32x4_t)vtrn2q_s32((int32x4_t)v157.val[0], (int32x4_t)v157.val[0]), v102, *(float *)v153), _Q16), v91)), v95, 0xAuLL), 0xAuLL), 0xAuLL);
        *v11 = vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32((float32x4_t)vtrn1q_s32(v104, v104), v100, *(float *)v153), _Q16), v91)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32(v103, v100, *(float *)v153), _Q16), v91)), vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32((float32x4_t)vtrn2q_s32(v104, v104), v100, *(float *)v153), _Q16), v91)), v95, 0xAuLL), 0xAuLL), 0xAuLL);
        v11[1] = (int32x4_t)v157.val[0];
        v11 += 2;
        v87 = v88 + 8;
        v105 = v88 + 16;
        v88 += 8;
      }
      while (v105 <= v12);
    }
    else
    {
      v87 = 0;
    }
    if ((v12 & 7) != 0)
    {
      v106 = v12 - v87;
      v147[0] = 0u;
      __dst = 0u;
      v107 = 2 * (v12 - v87);
      v140 = v14;
      v142 = v13;
      v136 = v17;
      v138 = v15;
      v128 = v16;
      memcpy(v147, v8, v107);
      memcpy(&__dst, v9, (v107 + 2) & 0xFFFFFFFFFFFFFFFCLL);
      v155.val[1] = (int8x16_t)vshrq_n_u16(v147[0], 6uLL);
      v155.val[0].i64[0] = 0x4B004B004B004B00;
      v155.val[0].i64[1] = 0x4B004B004B004B00;
      v108 = (float32x4_t)vdupq_n_s32(0x3A802008u);
      v109 = (float32x4_t)vdupq_n_s32(0xC6002008);
      v110 = vmlaq_f32(v109, v108, (float32x4_t)vqtbl2q_s8(v155, (int8x16_t)xmmword_18820C2F0));
      v111 = vmlaq_f32(v109, v108, (float32x4_t)vqtbl2q_s8(v155, (int8x16_t)xmmword_18820C2E0));
      v155.val[1] = (int8x16_t)vshrq_n_u16(__dst, 6uLL);
      v112 = (float32x4_t)vqtbl2q_s8(v155, (int8x16_t)xmmword_18820C2E0);
      v155.val[1] = (int8x16_t)vmlaq_f32(v109, v108, (float32x4_t)vqtbl2q_s8(v155, (int8x16_t)xmmword_18820C2F0));
      v113 = vmlaq_f32(v109, v108, v112);
      v114 = (float32x4_t)vdupq_lane_s32(v128, 0);
      v115 = vmlaq_f32(vmlaq_f32(v114, (float32x4_t)vrev64q_s32((int32x4_t)v155.val[1]), v140), (float32x4_t)v155.val[1], v142);
      v155.val[0] = (int8x16_t)vmlaq_f32(v138, (float32x4_t)v155.val[1], v136);
      v116 = (int32x4_t)vmlaq_f32(v138, v113, v136);
      v155.val[1] = (int8x16_t)vmlaq_n_f32((float32x4_t)vtrn2q_s32(v116, v116), v111, *(float *)v153);
      v117 = vmlaq_n_f32(vmlaq_f32(vmlaq_f32(v114, (float32x4_t)vrev64q_s32((int32x4_t)v113), v140), v113, v142), v111, *(float *)v153);
      v118 = vmlaq_n_f32((float32x4_t)vtrn1q_s32(v116, v116), v111, *(float *)v153);
      __asm { FMOV            V5.4S, #1.0 }
      v120 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      v121 = (int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32((float32x4_t)vtrn2q_s32((int32x4_t)v155.val[0], (int32x4_t)v155.val[0]), v110, *(float *)v153), _Q5), v120));
      v155.val[1] = (int8x16_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32((float32x4_t)v155.val[1], _Q5), v120));
      v122 = (int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(vmlaq_n_f32(v115, v110, *(float *)v153), _Q5), v120));
      v123 = (int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v117, _Q5), v120));
      v155.val[0] = (int8x16_t)vminnmq_f32(vmlaq_n_f32((float32x4_t)vtrn1q_s32((int32x4_t)v155.val[0], (int32x4_t)v155.val[0]), v110, *(float *)v153), _Q5);
      v124 = (int32x4_t)vcvtnq_u32_f32(vmulq_f32(vminnmq_f32(v118, _Q5), v120));
      v118.i64[0] = 0x300000003;
      v118.i64[1] = 0x300000003;
      __src = vsliq_n_s32((int32x4_t)vcvtnq_u32_f32(vmulq_f32((float32x4_t)v155.val[0], v120)), vsliq_n_s32(v122, vsliq_n_s32(v121, (int32x4_t)v118, 0xAuLL), 0xAuLL), 0xAuLL);
      v149 = vsliq_n_s32(v124, vsliq_n_s32(v123, vsliq_n_s32((int32x4_t)v155.val[1], (int32x4_t)v118, 0xAuLL), 0xAuLL), 0xAuLL);
      memcpy(v11, &__src, 4 * v106);
    }
  }
  return 0;
}

float VEC::xf20Constants::xf20Constants(float *a1, __int16 *a2)
{
  __int16 *v2;
  float result;

  v2 = (__int16 *)&kDefaultXF20ToRGB16fConversion;
  if (a2)
    v2 = a2;
  _H0 = v2[3];
  __asm { FCVT            S0, H0 }
  _H1 = v2[4];
  __asm { FCVT            S1, H1 }
  *a1 = _S0;
  a1[1] = _S1;
  _H2 = *v2;
  __asm { FCVT            S2, H2 }
  _H3 = v2[1];
  __asm { FCVT            S3, H3 }
  _H4 = v2[5];
  __asm { FCVT            S4, H4 }
  a1[2] = -(float)((float)(_S1 * _S3) + (float)(_S2 * _S0));
  a1[3] = _S4;
  LOWORD(_S1) = v2[6];
  __asm { FCVT            S1, H1 }
  _H5 = v2[2];
  __asm { FCVT            S5, H5 }
  a1[4] = _S1;
  a1[5] = -(float)((float)((float)(_S3 * _S1) + (float)(_S2 * _S0)) + (float)(_S5 * _S4));
  LOWORD(_S1) = v2[7];
  __asm { FCVT            S1, H1 }
  result = -(float)((float)(_S5 * _S1) + (float)(_S2 * _S0));
  a1[6] = _S1;
  a1[7] = result;
  return result;
}

_OWORD *_cg_EGifOpen(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  _OWORD *v6;
  _OWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *inited;
  void *v11;

  v6 = malloc_type_malloc(0x70uLL, 0x10A00402F952F05uLL);
  if (v6)
  {
    v7 = v6;
    v6[5] = 0u;
    v6[6] = 0u;
    v6[3] = 0u;
    v6[4] = 0u;
    v6[1] = 0u;
    v6[2] = 0u;
    *v6 = 0u;
    v8 = malloc_type_malloc(0x4150uLL, 0x10A0040B4BDD98EuLL);
    if (v8)
    {
      v9 = v8;
      bzero(v8, 0x4150uLL);
      inited = _InitHashTable();
      v9[2088] = inited;
      if (inited)
      {
        *((_QWORD *)v7 + 12) = v9;
        v9[5] = 0;
        *(_DWORD *)v9 = 1;
        v9[7] = a2;
        *((_QWORD *)v7 + 11) = a1;
        *((_BYTE *)v9 + 16712) = 0;
        *((_DWORD *)v7 + 20) = 0;
        return v7;
      }
      free(v7);
      v11 = v9;
    }
    else
    {
      v11 = v7;
    }
    free(v11);
  }
  v7 = 0;
  if (a3)
    *a3 = 7;
  return v7;
}

const char *EGifGetGifVersion(const char *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  int v15;

  v1 = *((_QWORD *)result + 12);
  v2 = *((unsigned int *)result + 6);
  if ((int)v2 < 1)
  {
LABEL_17:
    v11 = *((unsigned int *)result + 16);
    if ((int)v11 >= 1)
    {
      v12 = (int *)(*((_QWORD *)result + 9) + 16);
      do
      {
        v14 = *v12;
        v12 += 6;
        v13 = v14;
        v15 = (1 << (v14 + 7)) & 0x61;
        if ((v14 - 249) <= 6 && v15 != 0 || v13 == 1)
          *(_BYTE *)(v1 + 16712) = 1;
        --v11;
      }
      while (v11);
    }
    if (*(_BYTE *)(v1 + 16712))
      return "GIF89a";
    else
      return "GIF87a";
  }
  else
  {
    v3 = 0;
    v4 = *((_QWORD *)result + 7);
    while (1)
    {
      v5 = *(unsigned int *)(v4 + 56 * v3 + 40);
      if ((int)v5 >= 1)
        break;
LABEL_16:
      if (++v3 == v2)
        goto LABEL_17;
    }
    v6 = *(_QWORD *)(v4 + 56 * v3 + 48);
    v7 = v6 + 24 * v5;
    while (v6 < v7)
    {
      v8 = *(_DWORD *)(v6 + 16);
      if ((v8 - 249) <= 6 && ((1 << (v8 + 7)) & 0x61) != 0 || v8 == 1)
        *(_BYTE *)(v1 + 16712) = 1;
      v6 += 24;
      if (!--v5)
        goto LABEL_16;
    }
    __break(0x5519u);
  }
  return result;
}

size_t _cg_EGifPutScreenDesc(uint64_t a1, __int16 a2, __int16 a3, int a4, __int16 a5, int *a6)
{
  _WORD *v7;
  size_t result;
  int v9;
  char *GifVersion;
  int v16;
  int v17;
  char *v18;
  int v19;
  int v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  __int16 *v24;
  __int16 v25;
  char v26;
  __int16 __ptr;
  __int16 v28;

  v26 = 0;
  v25 = 0;
  v7 = *(_WORD **)(a1 + 96);
  if ((*v7 & 2) != 0)
  {
    result = 0;
    v9 = 3;
    goto LABEL_27;
  }
  if ((*v7 & 1) != 0)
  {
    GifVersion = (char *)EGifGetGifVersion((const char *)a1);
    result = strlen(GifVersion);
    if (GifVersion < &GifVersion[result])
    {
      v16 = InternalWrite(a1, GifVersion, result);
      result = strlen(GifVersion);
      if (result != v16)
      {
LABEL_26:
        result = 0;
        v9 = 2;
        goto LABEL_27;
      }
      *(_WORD *)a1 = a2;
      *(_WORD *)(a1 + 2) = a3;
      *(_WORD *)(a1 + 4) = a4;
      *(_WORD *)(a1 + 6) = a5;
      if (!a6)
      {
        v19 = 0;
        *(_QWORD *)(a1 + 16) = 0;
        goto LABEL_15;
      }
      v17 = *a6;
      v18 = (char *)*((_QWORD *)a6 + 2);
      if (!v18 || v17 >= 1)
      {
        result = (size_t)_cg_GifMakeMapObject(*a6, v18);
        if (!result || v17 >= 1)
        {
          *(_QWORD *)(a1 + 16) = result;
          if (!result)
          {
            v9 = 7;
            goto LABEL_27;
          }
          v19 = 128;
LABEL_15:
          __ptr = a2;
          InternalWrite(a1, &__ptr, 2uLL);
          v28 = a3;
          InternalWrite(a1, &v28, 2uLL);
          if (a6)
          {
            v20 = (a6[1] + 255) | v19 | (16 * a4 + 240);
            LOBYTE(v25) = (*((_BYTE *)a6 + 4) - 1) | v19 | (16 * a4 - 16);
            if (!*((_BYTE *)a6 + 8))
              goto LABEL_20;
            v21 = v20 | 8;
          }
          else
          {
            v21 = v19 | (16 * a4 - 16) | 7;
          }
          LOBYTE(v25) = v21;
LABEL_20:
          HIBYTE(v25) = a5;
          v26 = *(_BYTE *)(a1 + 8);
          InternalWrite(a1, &v25, 3uLL);
          if (!a6 || *a6 < 1)
          {
LABEL_25:
            *v7 |= 2u;
            return 1;
          }
          v22 = 0;
          v23 = 0;
          while (1)
          {
            v24 = (__int16 *)(*((_QWORD *)a6 + 2) + v22);
            v25 = *v24;
            v26 = *((_BYTE *)v24 + 2);
            if (InternalWrite(a1, &v25, 3uLL) != 3)
              goto LABEL_26;
            ++v23;
            v22 += 3;
            if (v23 >= *a6)
              goto LABEL_25;
          }
        }
      }
    }
    __break(0x5519u);
    return result;
  }
  result = 0;
  v9 = 10;
LABEL_27:
  *(_DWORD *)(a1 + 80) = v9;
  return result;
}

size_t InternalWrite(uint64_t a1, void *__ptr, size_t a3)
{
  uint64_t v3;
  uint64_t (*v4)(void);

  v3 = *(_QWORD *)(a1 + 96);
  v4 = *(uint64_t (**)(void))(v3 + 56);
  if (v4)
    return v4();
  else
    return fwrite(__ptr, 1uLL, a3, *(FILE **)(v3 + 40));
}

void _cg_EGifPutImageDesc(uint64_t a1, __int16 a2, __int16 a3, int a4, int a5, int a6, int *a7)
{
  uint64_t v14;
  int v15;
  void **v16;
  int v17;
  char *v18;
  char *MapObject;
  char v20;
  char v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  __int16 v30;
  char __ptr;
  __int16 v32;
  __int16 v33;
  __int16 v34;
  __int16 v35;
  __int16 v36;
  char v37;

  v32 = 0;
  v14 = *(_QWORD *)(a1 + 96);
  if ((*(_WORD *)v14 & 4) != 0 && *(_QWORD *)(v14 + 32) >= 0xFFFF0001uLL)
  {
    v15 = 4;
LABEL_38:
    *(_DWORD *)(a1 + 80) = v15;
    return;
  }
  if ((*(_WORD *)v14 & 1) == 0)
  {
    v15 = 10;
    goto LABEL_38;
  }
  *(_WORD *)(a1 + 32) = a2;
  *(_WORD *)(a1 + 34) = a3;
  *(_WORD *)(a1 + 36) = a4;
  *(_WORD *)(a1 + 38) = a5;
  *(_BYTE *)(a1 + 40) = a6;
  if (a7)
  {
    v16 = *(void ***)(a1 + 48);
    if (v16)
    {
      _cg_GifFreeMapObject(v16);
      *(_QWORD *)(a1 + 48) = 0;
    }
    v17 = *a7;
    v18 = (char *)*((_QWORD *)a7 + 2);
    if (v18 && v17 < 1 || (MapObject = _cg_GifMakeMapObject(*a7, v18)) != 0 && v17 < 1)
    {
      __break(0x5519u);
      return;
    }
    *(_QWORD *)(a1 + 48) = MapObject;
    if (!MapObject)
    {
      v15 = 7;
      goto LABEL_38;
    }
    v20 = 0x80;
  }
  else
  {
    v20 = 0;
    *(_QWORD *)(a1 + 48) = 0;
  }
  __ptr = 44;
  InternalWrite(a1, &__ptr, 1uLL);
  v33 = a2;
  InternalWrite(a1, &v33, 2uLL);
  v34 = a3;
  InternalWrite(a1, &v34, 2uLL);
  v35 = a4;
  InternalWrite(a1, &v35, 2uLL);
  v36 = a5;
  InternalWrite(a1, &v36, 2uLL);
  if (a6)
    v21 = 64;
  else
    v21 = 0;
  v22 = v20 | v21;
  if (a7)
  {
    __ptr = (*((_BYTE *)a7 + 4) - 1) | v22;
    InternalWrite(a1, &__ptr, 1uLL);
    if (*a7 >= 1)
    {
      v23 = 0;
      v24 = 0;
      while (1)
      {
        v25 = *((_QWORD *)a7 + 2) + v23;
        __ptr = *(_BYTE *)v25;
        v32 = *(_WORD *)(v25 + 1);
        if (InternalWrite(a1, &__ptr, 3uLL) != 3)
          break;
        ++v24;
        v23 += 3;
        if (v24 >= *a7)
          goto LABEL_26;
      }
      v15 = 2;
      goto LABEL_38;
    }
  }
  else
  {
    __ptr = v22;
    InternalWrite(a1, &__ptr, 1uLL);
  }
LABEL_26:
  v26 = *(_QWORD *)(a1 + 16);
  v27 = *(_QWORD *)(a1 + 48);
  if (!(v26 | v27))
  {
    v15 = 5;
    goto LABEL_38;
  }
  *(_WORD *)v14 |= 4u;
  *(_QWORD *)(v14 + 32) = a5 * (uint64_t)a4;
  if (v27)
    v26 = v27;
  v28 = *(_QWORD *)(a1 + 96);
  v29 = *(_DWORD *)(v26 + 4);
  if (v29 <= 2)
    v30 = 2;
  else
    v30 = v29;
  v37 = v30;
  InternalWrite(a1, &v37, 1uLL);
  *(_BYTE *)(v28 + 64) = 0;
  *(_WORD *)(v28 + 4) = v30;
  *(_WORD *)(v28 + 6) = 1 << v30;
  *(_WORD *)(v28 + 8) = (1 << v30) + 1;
  *(_WORD *)(v28 + 10) = (1 << v30) + 2;
  *(_WORD *)(v28 + 12) = v30 + 1;
  *(_WORD *)(v28 + 14) = 1 << (v30 + 1);
  *(_WORD *)(v28 + 18) = 4097;
  *(_WORD *)(v28 + 22) = 0;
  *(_QWORD *)(v28 + 24) = 0;
  _ClearHashTable(*(void **)(v28 + 16704));
  if (!EGifCompressOutput(a1, *(__int16 *)(v28 + 6)))
    *(_DWORD *)(a1 + 80) = 8;
}

uint64_t _cg_EGifPutLine(uint64_t result, unsigned __int8 *a2, signed int a3)
{
  uint64_t v3;
  int v4;
  unint64_t v5;
  char *v6;
  uint64_t v8;
  char v9;
  unsigned __int8 *v10;

  v3 = *(_QWORD *)(result + 96);
  if ((*(_WORD *)v3 & 1) == 0)
  {
    v4 = 10;
LABEL_7:
    *(_DWORD *)(result + 80) = v4;
    return 0;
  }
  if (!a3 && *(_WORD *)(result + 36))
    goto LABEL_18;
  v5 = *(_QWORD *)(v3 + 32);
  if (v5 < a3)
  {
    v4 = 6;
    goto LABEL_7;
  }
  *(_QWORD *)(v3 + 32) = v5 - a3;
  v6 = &CodeMask[*(__int16 *)(v3 + 4)];
  if (v6 < &CodeMask[9] && v6 >= CodeMask)
  {
    if (a3 >= 1)
    {
      v8 = a3;
      v9 = *v6;
      v10 = a2;
      do
      {
        *v10++ &= v9;
        --v8;
      }
      while (v8);
    }
    if ((a3 & 0x80000000) == 0)
      return EGifCompressLine(result, a2, a3);
  }
LABEL_18:
  __break(0x5519u);
  return result;
}

uint64_t EGifCompressLine(uint64_t result, unsigned __int8 *a2, signed int a3)
{
  size_t v4;
  uint64_t v5;
  void *v6;
  int v7;
  unsigned int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unint64_t v11;
  int v12;
  int v13;
  int v14;
  __int16 v15;

  v4 = result;
  v5 = *(_QWORD *)(result + 96);
  v6 = *(void **)(v5 + 16704);
  v7 = *(__int16 *)(v5 + 18);
  if (v7 == 4097)
  {
    if (!a3)
    {
LABEL_25:
      __break(0x5519u);
      return result;
    }
    v7 = *a2;
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  if ((int)v8 < a3)
  {
    v9 = &a2[a3];
    v10 = &a2[v8];
    v11 = a3 - (unint64_t)v8;
    while (v10 < v9 && v10 >= a2)
    {
      v12 = *v10;
      result = _ExistsHashTable((unint64_t)v6, v12 | (v7 << 8));
      v13 = result;
      if ((result & 0x80000000) != 0)
      {
        if (!EGifCompressOutput(v4, v7))
          goto LABEL_24;
        v14 = *(__int16 *)(v5 + 10);
        if (v14 < 4095)
        {
          ++*(_WORD *)(v5 + 10);
          result = _InsertHashTable((unint64_t)v6, v12 | (v7 << 8), v14);
        }
        else
        {
          if (!EGifCompressOutput(v4, *(__int16 *)(v5 + 6)))
            goto LABEL_24;
          *(_WORD *)(v5 + 10) = *(_WORD *)(v5 + 8) + 1;
          v15 = *(_WORD *)(v5 + 4) + 1;
          *(_WORD *)(v5 + 12) = v15;
          *(_WORD *)(v5 + 14) = 1 << v15;
          result = (uint64_t)_ClearHashTable(v6);
        }
        v13 = v12;
      }
      ++v10;
      v7 = v13;
      if (!--v11)
        goto LABEL_19;
    }
    goto LABEL_25;
  }
  v13 = v7;
LABEL_19:
  *(_WORD *)(v5 + 18) = v13;
  if (*(_QWORD *)(v5 + 32)
    || EGifCompressOutput(v4, v13)
    && EGifCompressOutput(v4, *(__int16 *)(v5 + 8))
    && EGifCompressOutput(v4, 4096))
  {
    return 1;
  }
LABEL_24:
  result = 0;
  *(_DWORD *)(v4 + 80) = 8;
  return result;
}

uint64_t _cg_EGifPutExtension(uint64_t a1, int a2, int a3, void *a4)
{
  uint64_t v5;
  int v7;
  __int16 __ptr;
  char v10;
  int v11;

  v11 = a3;
  v10 = 0;
  __ptr = 0;
  if ((**(_WORD **)(a1 + 96) & 1) != 0)
  {
    if (a2)
    {
      v7 = a3;
      LOBYTE(__ptr) = 33;
      HIBYTE(__ptr) = a2;
      v10 = a3;
      InternalWrite(a1, &__ptr, 3uLL);
    }
    else
    {
      InternalWrite(a1, &v11, 1uLL);
      v7 = v11;
    }
    InternalWrite(a1, a4, v7);
    LOBYTE(__ptr) = 0;
    v5 = 1;
    InternalWrite(a1, &__ptr, 1uLL);
  }
  else
  {
    v5 = 0;
    *(_DWORD *)(a1 + 80) = 10;
  }
  return v5;
}

uint64_t _cg_EGifPutExtensionLeader(uint64_t a1, char a2)
{
  uint64_t v2;
  _BYTE __ptr[3];

  __ptr[2] = 0;
  if ((**(_WORD **)(a1 + 96) & 1) != 0)
  {
    __ptr[0] = 33;
    __ptr[1] = a2;
    InternalWrite(a1, __ptr, 2uLL);
    return 1;
  }
  else
  {
    v2 = 0;
    *(_DWORD *)(a1 + 80) = 10;
  }
  return v2;
}

uint64_t _cg_EGifPutExtensionBlock(uint64_t a1, int a2, void *a3)
{
  uint64_t v4;
  char __ptr;

  if ((**(_WORD **)(a1 + 96) & 1) != 0)
  {
    __ptr = a2;
    v4 = 1;
    InternalWrite(a1, &__ptr, 1uLL);
    InternalWrite(a1, a3, a2);
  }
  else
  {
    v4 = 0;
    *(_DWORD *)(a1 + 80) = 10;
  }
  return v4;
}

uint64_t _cg_EGifPutExtensionTrailer(uint64_t a1)
{
  uint64_t v1;
  char __ptr;

  if ((**(_WORD **)(a1 + 96) & 1) != 0)
  {
    __ptr = 0;
    v1 = 1;
    InternalWrite(a1, &__ptr, 1uLL);
  }
  else
  {
    v1 = 0;
    *(_DWORD *)(a1 + 80) = 10;
  }
  return v1;
}

uint64_t _cg_EGifCloseFile(uint64_t result, int *a2)
{
  _QWORD *v2;
  void *v3;
  int v5;
  FILE *v6;
  void **v7;
  void **v8;
  void *v9;
  char __ptr;

  if (result)
  {
    v2 = (_QWORD *)result;
    v3 = *(void **)(result + 96);
    if (!v3)
      return 0;
    if ((*(_WORD *)v3 & 1) == 0)
    {
      if (a2)
      {
        v5 = 10;
LABEL_16:
        *a2 = v5;
        goto LABEL_17;
      }
      goto LABEL_17;
    }
    v6 = (FILE *)*((_QWORD *)v3 + 5);
    __ptr = 59;
    InternalWrite(result, &__ptr, 1uLL);
    v7 = (void **)v2[6];
    if (v7)
    {
      _cg_GifFreeMapObject(v7);
      v2[6] = 0;
    }
    v8 = (void **)v2[2];
    if (v8)
    {
      _cg_GifFreeMapObject(v8);
      v2[2] = 0;
    }
    v9 = (void *)*((_QWORD *)v3 + 2088);
    if (v9)
      free(v9);
    free(v3);
    if (v6 && fclose(v6))
    {
      if (a2)
      {
        v5 = 9;
        goto LABEL_16;
      }
LABEL_17:
      free(v2);
      return 0;
    }
    free(v2);
    if (a2)
      *a2 = 0;
    return 1;
  }
  return result;
}

uint64_t EGifCompressOutput(size_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  __int16 v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;
  int v12;
  __int16 v13;

  v4 = *(_QWORD *)(a1 + 96);
  if (a2 == 4096)
  {
    if (*(__int16 *)(v4 + 22) < 1)
    {
      v6 = 1;
    }
    else
    {
      v5 = *(_QWORD *)(v4 + 24);
      v6 = 1;
      do
      {
        if (!EGifBufferedOutput(a1, (_BYTE *)(v4 + 64), v5))
          v6 = 0;
        v5 = *(_QWORD *)(v4 + 24) >> 8;
        *(_QWORD *)(v4 + 24) = v5;
        v7 = (__int16)(*(_WORD *)(v4 + 22) - 8);
        *(_WORD *)(v4 + 22) -= 8;
      }
      while (v7 > 0);
    }
    *(_WORD *)(v4 + 22) = 0;
    if (EGifBufferedOutput(a1, (_BYTE *)(v4 + 64), 4096))
      v11 = v6;
    else
      v11 = 0;
  }
  else
  {
    v8 = *(_WORD *)(v4 + 22);
    v9 = ((uint64_t)a2 << v8) | *(_QWORD *)(v4 + 24);
    *(_QWORD *)(v4 + 24) = v9;
    v10 = *(_WORD *)(v4 + 12) + v8;
    *(_WORD *)(v4 + 22) = v10;
    if (v10 < 8)
    {
      v11 = 1;
    }
    else
    {
      LODWORD(v11) = 1;
      do
      {
        if (EGifBufferedOutput(a1, (_BYTE *)(v4 + 64), v9))
          v11 = v11;
        else
          v11 = 0;
        v9 = *(_QWORD *)(v4 + 24) >> 8;
        *(_QWORD *)(v4 + 24) = v9;
        v12 = (__int16)(*(_WORD *)(v4 + 22) - 8);
        *(_WORD *)(v4 + 22) -= 8;
      }
      while (v12 > 7);
    }
  }
  if (a2 <= 4095 && *(__int16 *)(v4 + 10) >= *(__int16 *)(v4 + 14))
  {
    v13 = *(_WORD *)(v4 + 12) + 1;
    *(_WORD *)(v4 + 12) = v13;
    *(_WORD *)(v4 + 14) = 1 << v13;
  }
  return v11;
}

size_t EGifBufferedOutput(size_t result, _BYTE *__ptr, int a3)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  int v7;
  uint64_t v8;
  _BYTE *v9;

  v4 = result;
  if (a3 == 4096)
  {
    if (!*__ptr
      || InternalWrite(result, __ptr, *__ptr + 1) == *__ptr + 1)
    {
      *__ptr = 0;
      v5 = 1;
      if (InternalWrite(v4, __ptr, 1uLL) == 1)
        return v5;
    }
    goto LABEL_15;
  }
  v6 = a3;
  v7 = *__ptr;
  if (v7 == 255)
  {
    result = InternalWrite(result, __ptr, 0x100uLL);
    if ((_DWORD)result != *__ptr + 1)
    {
LABEL_15:
      v5 = 0;
      *(_DWORD *)(v4 + 80) = 2;
      return v5;
    }
    v7 = 0;
  }
  v8 = (v7 + 1);
  *__ptr = v8;
  v9 = &__ptr[v8];
  if (v9 >= __ptr + 256 || v9 < __ptr)
  {
    __break(0x5519u);
    return result;
  }
  *v9 = v6;
  return 1;
}

unint64_t _cg_GifQuantizeBuffer(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  int *v12;
  int *v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t result;
  unint64_t v20;
  char *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unsigned __int8 *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v37;
  uint64_t i;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _BYTE *v42;
  _BYTE *v43;
  _BYTE *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  unint64_t v50;
  uint64_t v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  int v56;
  unsigned int v57;
  int v58;
  _BYTE *v59;
  unsigned int v60;
  int v61;
  _BYTE *v62;
  unint64_t v63;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _DWORD *v68;
  unsigned __int8 *v69;
  int v71;
  char *v72;
  _BYTE *v73;
  uint64_t v74;
  _DWORD *v75;
  unint64_t *v76;
  char *v77;
  unint64_t *v78;
  uint64_t v79;
  unint64_t *v80;
  uint64_t v81;
  size_t v82;
  char *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t *v86;
  uint64_t v87;
  unint64_t *v88;
  unint64_t v89;
  unint64_t *v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  int v96;
  int v97;
  uint64_t v98;
  char *v99;
  char *v101;
  uint64_t v102;
  char v103;
  char v104;
  unint64_t v105;
  char v106;
  char v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  char *v111;
  unint64_t v112;
  unint64_t v113;
  char *v114;
  BOOL v115;
  char *v116;
  _BYTE *v119;
  char v120;
  _BYTE *v121;
  char *v122;
  _BYTE *v123;
  char *v124;
  _BYTE *v125;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  char *v132;
  uint64_t v134;
  unsigned __int8 *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  _BYTE *v139;
  int v141;
  int v142;
  int v143;
  unsigned __int8 *v144;
  unsigned __int8 *v145;
  unsigned __int8 *v146;
  _BYTE *v147;
  unint64_t v148;
  char *v149;
  BOOL v150;
  BOOL v151;
  uint64_t v153;
  unsigned __int8 *v154;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  unsigned __int8 *v162;
  unsigned __int8 *v163;
  _BYTE *v164;
  unint64_t v165;
  uint64_t v166;
  int *v167;
  char *v168;
  int v169;
  unsigned __int8 *v170;
  unsigned __int8 *v171;
  unsigned __int8 *v172;
  unint64_t v173;
  unint64_t v174;
  _BYTE v175[3];
  _BYTE v176[13];
  unint64_t v177;
  _QWORD v178[1021];
  char v179[16];

  MEMORY[0x1E0C80A78](a1, a2);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  *(_QWORD *)v179 = *MEMORY[0x1E0C80C00];
  bzero(v175, 0x2000uLL);
  v18 = *v13;
  result = (unint64_t)malloc_type_malloc(0xC0000uLL, 0x1020040EFA1817AuLL);
  if (result)
    v20 = result + 786432;
  else
    v20 = 0;
  if (!result)
    return result;
  v21 = (char *)result;
  v22 = 0;
  v23 = (unint64_t)&v11[v15 * (unint64_t)v17];
  v24 = (unint64_t)&v9[v15 * (unint64_t)v17];
  v25 = (unint64_t)&v7[v15 * (unint64_t)v17];
  v26 = v3 + v18;
  v27 = result;
  v174 = (unint64_t)&v5[v15 * (unint64_t)v17];
  v28 = v11;
  do
  {
    if (v27 >= v20 || v27 < result)
      goto LABEL_211;
    *(_BYTE *)v27 = v22 >> 10;
    *(_BYTE *)(v27 + 1) = (v22 >> 5) & 0x1F;
    *(_BYTE *)(v27 + 2) = v22 & 0x1F;
    *(_QWORD *)(v27 + 8) = 0;
    ++v22;
    v27 += 24;
  }
  while (v22 != 0x8000);
  v29 = v15 * v17;
  if ((int)v29 >= 1)
  {
    v30 = v15 * v17;
    v31 = v11;
    v32 = v9;
    v33 = v7;
    do
    {
      if ((unint64_t)v31 >= v23
        || v31 < v11
        || (unint64_t)v32 >= v24
        || v32 < v9
        || (unint64_t)v33 >= v25
        || v33 < v7)
      {
        goto LABEL_211;
      }
      v34 = (*v31 << 7) & 0x7C00 | (32 * (((unint64_t)*v32 >> 3) & 0x1F)) | ((unint64_t)*v33 >> 3);
      v35 = result + 24 * v34;
      if (v35 >= v20 || v35 < result)
        goto LABEL_211;
      ++*(_QWORD *)(result + 24 * v34 + 8);
      ++v33;
      ++v32;
      ++v31;
      --v30;
    }
    while (v30);
  }
  v37 = 0;
  for (i = 0; i != 256; ++i)
  {
    v39 = 0;
    v40 = (unint64_t)&v175[32 * i];
    *(_DWORD *)(v40 + 8) = 0;
    v41 = v40 | 3;
    *(_QWORD *)(v40 + 16) = 0;
    *(_QWORD *)(v40 + 24) = 0;
    v42 = &v175[v37];
    do
    {
      v43 = &v42[v39];
      if ((unint64_t)&v42[v39] >= v41 || (unint64_t)v43 < v40)
        goto LABEL_211;
      *v43 = 0;
      v45 = v43 + 3;
      if ((unint64_t)v45 >= (v40 | 6) || (unint64_t)v45 < v41)
        goto LABEL_211;
      *v45 = -1;
      ++v39;
    }
    while (v39 != 3);
    v37 += 32;
  }
  v46 = 0;
  v47 = 8;
  do
  {
    if (*(uint64_t *)&v21[v47] > 0)
      break;
    ++v46;
    v47 += 24;
  }
  while (v46 != 0x8000);
  v48 = &v21[24 * v46];
  if (v48)
  {
    if ((unint64_t)v48 >= v20 || v48 < v21)
      goto LABEL_211;
  }
  v178[0] = &v21[24 * v46];
  v50 = (unint64_t)(v48 + 24);
  if (v46 > 0x7FFE)
  {
    v52 = 1;
    v53 = (unint64_t)v48;
  }
  else
  {
    v51 = 24 * v46;
    v52 = 1;
    v53 = (unint64_t)v48;
    do
    {
      v54 = (unint64_t)&v21[v51 + 24];
      if (v54 >= v20 || v54 < (unint64_t)v21)
        goto LABEL_211;
      if (*(uint64_t *)&v21[v51 + 32] >= 1)
      {
        if (v53 + 24 > v50 || (unint64_t)v48 > v53)
          goto LABEL_211;
        *(_QWORD *)(v53 + 16) = v54;
        ++v52;
        v48 = v21;
        v50 = v20;
        v53 = (unint64_t)&v21[v51 + 24];
      }
      v51 += 24;
    }
    while (v51 != 786408);
  }
  if (v53 + 24 > v50 || (unint64_t)v48 > v53)
    goto LABEL_211;
  *(_QWORD *)(v53 + 16) = 0;
  *(_DWORD *)&v176[5] = v52;
  v177 = v15 * (unint64_t)v17;
  v56 = *v13;
  if (*v13 < 2)
  {
    v58 = 1;
    goto LABEL_143;
  }
  v165 = v3 + v18;
  v166 = v15 * v17;
  v162 = v11;
  v163 = v9;
  v164 = v5;
  v167 = v13;
  v168 = v21;
  v169 = *v13;
  v57 = 0;
  v173 = v20;
  v58 = 1;
  v59 = v175;
  v171 = &v9[v15 * (unint64_t)v17];
  v172 = &v11[v15 * (unint64_t)v17];
  v170 = &v7[v15 * (unint64_t)v17];
  do
  {
    v60 = 0;
    v61 = -1;
    v62 = v176;
    do
    {
      v63 = (unint64_t)&v175[32 * v60];
      if (v63 >= (unint64_t)v179 || v63 < (unint64_t)v175)
        goto LABEL_211;
      v65 = 0;
      v66 = v63 | 3;
      v67 = v63 | 6;
      v68 = (_DWORD *)(v63 + 8);
      do
      {
        v69 = &v62[v65];
        if ((unint64_t)&v62[v65] >= v67 || (unint64_t)v69 < v66)
          goto LABEL_211;
        v71 = *v69;
        if (v61 < v71 && *v68 >= 2u)
        {
          SortRGBAxis = v65;
          v57 = v60;
          v61 = v71;
        }
        ++v65;
      }
      while (v65 != 3);
      ++v60;
      v62 += 32;
    }
    while (v60 != v58);
    if (v61 == -1)
      goto LABEL_141;
    v72 = &v175[32 * v57];
    if (v72 >= v179 || v72 < v175)
      goto LABEL_211;
    v73 = &v175[32 * v57];
    v75 = v73 + 8;
    v74 = *((unsigned int *)v73 + 2);
    v76 = (unint64_t *)malloc_type_malloc(8 * v74, 0x2004093837F09uLL);
    if (v76)
      v77 = (char *)&v76[v74];
    else
      v77 = 0;
    if (!v76)
    {
      free(v168);
      return 0;
    }
    v78 = v76;
    v81 = *((_QWORD *)v73 + 3);
    v80 = (unint64_t *)(v73 + 24);
    v79 = v81;
    v82 = *v75;
    if ((_DWORD)v82 && v79)
    {
      v83 = (char *)v76;
      v84 = 1;
      while (v83 < v77 && v83 >= (char *)v76)
      {
        *(_QWORD *)v83 = v79;
        v83 += 8;
        if (v84 < v82)
        {
          v79 = *(_QWORD *)(v79 + 16);
          ++v84;
          if (v79)
            continue;
        }
        goto LABEL_91;
      }
LABEL_211:
      __break(0x5519u);
    }
LABEL_91:
    qsort(v76, v82, 8uLL, (int (__cdecl *)(const void *, const void *))SortCmpRtn);
    v85 = (*v75 - 1);
    if (*v75 != 1)
    {
      v86 = v78 + 1;
      v87 = (*v75 - 1);
      while (v86 < (unint64_t *)v77 && v86 >= v78)
      {
        *(_QWORD *)(*(v86 - 1) + 16) = *v86;
        ++v86;
        if (!--v87)
          goto LABEL_98;
      }
      goto LABEL_211;
    }
    v85 = 0;
LABEL_98:
    v88 = &v78[v85];
    if (v88 >= (unint64_t *)v77 || v88 < v78)
      goto LABEL_211;
    *(_QWORD *)(*v88 + 16) = 0;
    v89 = *v78;
    *v80 = *v78;
    free(v78);
    v90 = &v178[4 * v57 - 1];
    v91 = *(_QWORD *)(v89 + 8);
    v92 = *(_QWORD *)(v89 + 16);
    if (v92)
    {
      v93 = *(_QWORD *)(v92 + 8);
      v94 = (*v90 >> 1) - v91 - v93;
      v23 = (unint64_t)v172;
      v20 = v173;
      v25 = (unint64_t)v170;
      v24 = (unint64_t)v171;
      if (v94 >= 0 && (v95 = *(_QWORD *)(v92 + 16)) != 0)
      {
        v96 = 2;
        do
        {
          v89 = v92;
          v92 = v95;
          v97 = v96;
          v91 += v93;
          v93 = *(_QWORD *)(v95 + 8);
          v94 -= v93;
          if (v94 < 0)
            break;
          v95 = *(_QWORD *)(v95 + 16);
          ++v96;
        }
        while (v95);
      }
      else
      {
        v97 = 1;
      }
    }
    else
    {
      v97 = 1;
      v23 = (unint64_t)v172;
      v20 = v173;
      v25 = (unint64_t)v170;
      v24 = (unint64_t)v171;
    }
    v98 = SortRGBAxis;
    v99 = (char *)(v89 + SortRGBAxis);
    if ((unint64_t)v99 >= v89 + 3 || (unint64_t)v99 < v89)
      goto LABEL_211;
    v101 = &v175[32 * v58];
    if (v101 >= v179 || v101 < v175)
      goto LABEL_211;
    v102 = 0;
    v103 = *v99;
    v104 = *(_BYTE *)(v92 + SortRGBAxis);
    v105 = (unint64_t)&v175[32 * v58];
    *(_QWORD *)(v105 + 24) = v92;
    v106 = 8 * v103;
    v107 = 8 * v104;
    *(_QWORD *)(v89 + 16) = 0;
    *(_QWORD *)(v105 + 16) = v91;
    *v90 -= v91;
    v108 = (unint64_t)&v175[32 * v57];
    v109 = v108 | 3;
    *(_DWORD *)(v105 + 8) = *v75 - v97;
    *v75 = v97;
    v110 = v108 | 6;
    v111 = v101 + 3;
    v112 = v105 | 3;
    v113 = v105 | 6;
    do
    {
      v114 = &v72[v102];
      v115 = &v72[v102] < v72 + 3 && v114 >= v72;
      v116 = &v59[v102 + 32];
      if (!v115 || v116 >= v111 || v116 < v101)
        goto LABEL_211;
      v120 = *v114;
      v119 = v114 + 3;
      *v116 = v120;
      if ((unint64_t)v119 >= v110)
        goto LABEL_211;
      if ((unint64_t)v119 < v109)
        goto LABEL_211;
      v121 = &v59[v102 + 35];
      if ((unint64_t)v121 >= v113 || (unint64_t)v121 < v112)
        goto LABEL_211;
      *v121 = *v119;
      ++v102;
    }
    while (v102 != 3);
    v122 = &v101[v98];
    if (&v101[v98] >= v111)
      goto LABEL_211;
    if (v122 < v101)
      goto LABEL_211;
    v123 = (_BYTE *)(v112 + v98);
    if (v112 + v98 >= v113)
      goto LABEL_211;
    if ((unint64_t)v123 < v112)
      goto LABEL_211;
    *v123 += *v122 - v107;
    *v122 = v107;
    v124 = &v72[v98];
    if (&v72[v98] < v72)
      goto LABEL_211;
    v125 = (_BYTE *)(v109 + v98);
    if ((unint64_t)v125 < v109)
      goto LABEL_211;
    *v125 = v106 - *v124;
    ++v58;
    v59 += 32;
  }
  while (v58 != v169);
  v58 = v169;
LABEL_141:
  v5 = v164;
  v28 = v162;
  v9 = v163;
  v13 = v167;
  v21 = v168;
  v56 = *v167;
  v29 = v166;
  v26 = v165;
LABEL_143:
  if (v58 < v56 && v58 < v56)
  {
    v127 = v56;
    v128 = v3 + 3 * v58;
    v129 = v127 - v58;
    while (v128 < v26 && v128 >= v3)
    {
      *(_BYTE *)(v128 + 2) = 0;
      *(_WORD *)v128 = 0;
      v128 += 3;
      if (!--v129)
        goto LABEL_151;
    }
    goto LABEL_211;
  }
LABEL_151:
  v130 = 0;
  v131 = v3 + v58;
  do
  {
    v132 = &v175[32 * v130];
    if (v132 >= v179 || v132 < v175)
      goto LABEL_211;
    v134 = *((unsigned int *)v132 + 2);
    if ((int)v134 >= 1)
    {
      v135 = (unsigned __int8 *)v178[4 * v130];
      if (v135)
      {
        v136 = 0;
        v137 = 0;
        v138 = 0;
        do
        {
          v135[3] = v130;
          v136 += *v135;
          v137 += v135[1];
          v138 += v135[2];
          v135 = (unsigned __int8 *)*((_QWORD *)v135 + 2);
        }
        while (v135);
      }
      else
      {
        v138 = 0;
        v137 = 0;
        v136 = 0;
      }
      v139 = (_BYTE *)(v3 + 3 * v130);
      if ((unint64_t)v139 >= v131 || (unint64_t)v139 < v3)
        goto LABEL_211;
      *v139 = 8 * v136 / v134;
      v139[1] = 8 * v137 / v134;
      v139[2] = 8 * v138 / v134;
    }
    ++v130;
  }
  while (v130 != v58);
  if ((int)v29 >= 1)
  {
    v141 = 0;
    v142 = 0;
    v143 = 0;
    v144 = v28;
    v145 = v9;
    v146 = v7;
    v147 = v5;
    while ((unint64_t)v144 < v23
         && v144 >= v28
         && (unint64_t)v145 < v24
         && v145 >= v9
         && (unint64_t)v146 < v25
         && v146 >= v7)
    {
      v148 = (*v144 << 7) & 0x7C00 | (32 * (((unint64_t)*v145 >> 3) & 0x1F)) | ((unint64_t)*v146 >> 3);
      v149 = &v21[24 * v148];
      v150 = (unint64_t)v149 < v20 && v149 >= v21;
      v151 = !v150 || (unint64_t)v147 >= v174;
      if (v151 || v147 < v5)
        break;
      v153 = v21[24 * v148 + 3];
      *v147 = v153;
      v154 = (unsigned __int8 *)(v3 + 3 * v153);
      if ((unint64_t)v154 >= v131 || (unint64_t)v154 < v3)
        break;
      v156 = *v144++;
      v157 = *v154 - v156;
      if (v157 < 0)
        v157 = -v157;
      if (v143 <= v157)
        v143 = v157;
      v158 = *v145++;
      v159 = v154[1] - v158;
      if (v159 < 0)
        v159 = -v159;
      if (v142 <= v159)
        v142 = v159;
      v160 = *v146++;
      v161 = v154[2] - v160;
      if (v161 < 0)
        v161 = -v161;
      if (v141 <= v161)
        v141 = v161;
      ++v147;
      if (!--v29)
        goto LABEL_208;
    }
    goto LABEL_211;
  }
  v143 = 0;
  v142 = 0;
  v141 = 0;
LABEL_208:
  fprintf((FILE *)*MEMORY[0x1E0C80C10], "Quantization L(0) errors: Red = %d, Green = %d, Blue = %d.\n", v143, v142, v141);
  free(v21);
  *v13 = v58;
  return 1;
}

unint64_t *SortCmpRtn(unint64_t *result, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t v9;
  unsigned __int8 *v10;

  v2 = *result;
  v3 = *result + 3;
  v4 = *result + SortRGBAxis;
  if (v4 < v3 && v4 >= v2)
  {
    v6 = (SortRGBAxis + 1) % 3u;
    v7 = (unsigned __int8 *)(v2 + v6);
    if (v2 + v6 < v3 && (unint64_t)v7 >= v2)
    {
      v9 = (SortRGBAxis + 2) % 3u;
      v10 = (unsigned __int8 *)(v2 + v9);
      if (v2 + v9 < v3 && (unint64_t)v10 >= v2)
        return (unint64_t *)(((*(unsigned __int8 *)(v2 + SortRGBAxis) << 16) | (*v7 << 8) | *v10)
                                  - ((*(unsigned __int8 *)(*a2 + SortRGBAxis) << 16) | (*(unsigned __int8 *)(*a2 + v6) << 8) | *(unsigned __int8 *)(*a2 + v9)));
    }
  }
  __break(0x5519u);
  return result;
}

size_t _cg_DGifGetLine(size_t result, char *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  unint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v3 = result;
  v4 = *(_QWORD *)(result + 96);
  if ((*(_WORD *)v4 & 8) == 0)
  {
    v5 = 111;
LABEL_10:
    result = 0;
    *(_DWORD *)(v3 + 80) = v5;
    return result;
  }
  if (!(_DWORD)a3)
  {
    if (*(_WORD *)(result + 36))
    {
LABEL_20:
      __break(0x5519u);
      return result;
    }
    v9 = *(_QWORD *)(v4 + 32);
    v6 = (unint64_t *)(v4 + 32);
    if (v9 <= 0xFFFF0000)
    {
      a3 = 0;
      goto LABEL_13;
    }
LABEL_9:
    v5 = 108;
    goto LABEL_10;
  }
  v7 = *(_QWORD *)(v4 + 32);
  v6 = (unint64_t *)(v4 + 32);
  v8 = v7 - (int)a3;
  *v6 = v8;
  if (v8 > 0xFFFF0000)
    goto LABEL_9;
  if ((a3 & 0x80000000) != 0)
    goto LABEL_20;
LABEL_13:
  result = DGifDecompressLine(result, a2, a3);
  if ((_DWORD)result)
  {
    if (*v6)
    {
      return 1;
    }
    else
    {
      v10 = 0;
      do
      {
        result = _cg_DGifGetCodeNext(v3, (uint64_t)&v10);
        if (!(_DWORD)result)
          break;
        result = 1;
      }
      while (v10);
    }
  }
  return result;
}

size_t DGifDecompressLine(size_t result, char *a2, uint64_t a3)
{
  _WORD *v3;
  uint64_t v4;
  size_t v6;
  int v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  unsigned __int16 *v17;
  unsigned __int16 *v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  int64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  size_t v26;
  char *v27;
  char *v28;
  unsigned __int16 *v29;
  uint64_t v30;
  int v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  BOOL v34;
  uint64_t v35;
  int v36;
  int v37;
  unsigned __int16 *v38;
  int v39;
  int v40;
  unsigned __int16 *v41;
  int v42;
  int v43;
  unsigned __int16 *v44;
  char *v45;
  char *v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  unsigned __int16 *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _WORD *v60;
  char *v61;
  BOOL v62;
  BOOL v63;
  uint64_t v65;
  char *v66;
  char *v68;
  char *v70;
  size_t v71;
  char *v72;
  int v73;
  int v74;
  uint64_t v75;
  int v76;

  v3 = *(_WORD **)(result + 96);
  v4 = (__int16)v3[10];
  if ((int)v4 > 4095)
    return 0;
  v6 = result;
  v74 = (__int16)v3[4];
  v7 = (__int16)v3[3];
  v8 = (__int16)v3[8];
  if (v3[10] && (int)a3 >= 1)
  {
    v9 = (__int16)v3[10];
    v10 = v4 - 1;
    if ((int)a3 - 1 < v10)
      v10 = a3 - 1;
    v11 = v10 + 1;
    v12 = v11;
    v13 = (char *)v3 + 319;
    v14 = a2;
    while (1)
    {
      v15 = &v13[v9];
      if (&v13[v9] >= (char *)v3 + 4415 || v15 < (char *)v3 + 320)
        break;
      *v14++ = *v15;
      --v9;
      if (!--v11)
      {
        v4 = v9;
        goto LABEL_16;
      }
    }
LABEL_136:
    __break(0x5519u);
  }
  else
  {
    v12 = 0;
LABEL_16:
    if ((int)v12 >= (int)a3)
    {
      LOWORD(v21) = v4;
      LOWORD(v4) = v8;
LABEL_132:
      v3[8] = v4;
      v3[10] = v21;
      return 1;
    }
    else
    {
      v73 = v7;
      v17 = v3 + 4256;
      v18 = v3 + 8352;
      v19 = (char *)v3 + 8511;
      v76 = 0;
      v20 = (int)a3;
      v70 = (char *)(v3 + 160);
      v21 = v4;
      v71 = (size_t)&a2[a3];
      v72 = (char *)v3 + 4415;
      while (1)
      {
        v75 = v21;
        v22 = v20;
        v23 = v19;
        v24 = v12;
        v25 = a3;
        v26 = v6;
        result = DGifDecompressInput(v6, &v76);
        if (!(_DWORD)result)
          break;
        LODWORD(v4) = v76;
        if (v76 == v74)
        {
          result = 0;
          *(_DWORD *)(v26 + 80) = 113;
          return result;
        }
        if (v76 == v73)
        {
          memset(v3 + 4256, 16, 0x2000uLL);
          v3[5] = v3[4] + 1;
          LOWORD(v4) = v3[2] + 1;
          v3[6] = v4;
          v3[7] = 1 << v4;
          LODWORD(v4) = 4112;
          v3[8] = 4112;
          v6 = v26;
          a3 = v25;
          v12 = v24;
          v19 = v23;
          v20 = v22;
          v21 = v75;
        }
        else
        {
          if (v76 >= v73)
          {
            v33 = &v17[v76];
            v34 = v33 < v18 && v33 >= v17;
            v6 = v26;
            a3 = v25;
            v12 = v24;
            v19 = v23;
            v20 = v22;
            v28 = (char *)v3 + 4415;
            v35 = v75;
            if (!v34)
              goto LABEL_136;
            if (*v33 == 4112)
            {
              if (v76 == (__int16)v3[5] - 2)
              {
                LOBYTE(v36) = v8;
                if (v8 > v73)
                {
                  v37 = 4097;
                  v36 = v8;
                  do
                  {
                    if (!--v37)
                      break;
                    if (v36 > 4095)
                      goto LABEL_71;
                    v38 = &v17[v36];
                    if (v38 >= v18 || v38 < v17)
                      goto LABEL_136;
                    v36 = *v38;
                  }
                  while (v36 > v73);
                }
              }
              else
              {
                LOBYTE(v36) = v76;
                if (v76 > v73)
                {
                  v40 = 4097;
                  v36 = v76;
                  do
                  {
                    if (!--v40)
                      break;
                    if (v36 > 4095)
                    {
LABEL_71:
                      LOBYTE(v36) = 16;
                      break;
                    }
                    v41 = &v17[v36];
                    if (v41 >= v18 || v41 < v17)
                      goto LABEL_136;
                    v36 = *v41;
                  }
                  while (v36 > v73);
                }
              }
              v45 = &v70[(int)v75];
              if (v45 >= v72 || v45 < v70)
                goto LABEL_136;
              *v45 = v36;
              v47 = &v72[(__int16)v3[5] - 2];
              if (v47 >= v19 || v47 < v72)
                goto LABEL_136;
              v35 = (v75 + 1);
              *v47 = v36;
              v39 = v8;
            }
            else
            {
              v39 = v76;
            }
            if ((int)v35 > 4094)
              goto LABEL_133;
            v49 = 0;
            v50 = (int)v35;
            v51 = v35 << 32;
            v52 = (uint64_t)v3 + (int)v35 + 320;
            while (v39 > v73 && v39 <= 4095)
            {
              v53 = &v72[v39];
              if (v53 >= v19)
                goto LABEL_136;
              if (v53 < v72)
                goto LABEL_136;
              v54 = (char *)(v52 + v49);
              if (v52 + v49 >= (unint64_t)v72)
                goto LABEL_136;
              if (v54 < v70)
                goto LABEL_136;
              *v54 = *v53;
              v55 = &v17[v39];
              if (v55 >= v18 || v55 < v17)
                goto LABEL_136;
              v39 = *v55;
              ++v49;
              v51 += 0x100000000;
              if ((int)v35 + v49 == 4095)
                goto LABEL_133;
            }
            if (v39 >= 4096)
            {
LABEL_133:
              result = 0;
              *(_DWORD *)(v6 + 80) = 112;
              return result;
            }
            v56 = &v70[v51 >> 32];
            if (v56 >= v72 || v56 < v70)
              goto LABEL_136;
            v57 = (v35 + 1);
            *v56 = v39;
            v21 = v57 + v49;
            if ((_DWORD)v57 + (_DWORD)v49 && (int)v24 < (int)v25)
            {
              v58 = 0;
              v59 = (int)v35 + v49;
              v60 = v3 + 160;
              while (1)
              {
                v61 = (char *)v60 + v50 + v49;
                v62 = v61 < v72 && v61 >= v70;
                result = (size_t)&a2[(int)v24 + v58];
                v63 = !v62 || result >= v71;
                if (v63 || result < (unint64_t)a2)
                  goto LABEL_136;
                v65 = v58 + 1;
                *(_BYTE *)result = *((_BYTE *)v60 + v59);
                if (v59 != v58)
                {
                  result = v65 + (int)v24;
                  v60 = (_WORD *)((char *)v60 - 1);
                  ++v58;
                  if ((uint64_t)result < v20)
                    continue;
                }
                v21 = (v57 + v49 - v65);
                v12 = (v24 + v65);
                break;
              }
            }
          }
          else
          {
            v27 = &a2[(int)v24];
            v6 = v26;
            v19 = v23;
            v20 = v22;
            v28 = (char *)v3 + 4415;
            v21 = v75;
            if ((unint64_t)v27 >= v71 || v27 < a2)
              goto LABEL_136;
            a3 = v25;
            v12 = (v24 + 1);
            *v27 = v76;
          }
          if (v8 != 4112)
          {
            v29 = &v17[(__int16)v3[5] - 2];
            if (v29 >= v18 || v29 < v17)
              goto LABEL_136;
            if (*v29 == 4112)
            {
              *v29 = v8;
              v30 = (__int16)v3[5];
              if ((_DWORD)v4 == (__int16)v3[5] - 2)
              {
                if (v8 > v73)
                {
                  v31 = 4097;
                  do
                  {
                    if (!--v31)
                      break;
                    if (v8 > 4095)
                    {
                      LOBYTE(v8) = 16;
                      break;
                    }
                    v32 = &v17[v8];
                    if (v32 >= v18 || v32 < v17)
                      goto LABEL_136;
                    v8 = *v32;
                  }
                  while (v8 > v73);
                }
                v66 = &v28[v30 - 2];
                if (v66 >= v19 || v66 < v28)
                  goto LABEL_136;
                *v66 = v8;
              }
              else
              {
                LOBYTE(v42) = v4;
                if ((int)v4 > v73)
                {
                  v43 = 4097;
                  v42 = v4;
                  do
                  {
                    if (!--v43)
                      break;
                    if (v42 > 4095)
                    {
                      LOBYTE(v42) = 16;
                      break;
                    }
                    v44 = &v17[v42];
                    if (v44 >= v18 || v44 < v17)
                      goto LABEL_136;
                    v42 = *v44;
                  }
                  while (v42 > v73);
                }
                v68 = &v28[v30 - 2];
                if (v68 >= v19 || v68 < v28)
                  goto LABEL_136;
                *v68 = v42;
              }
            }
          }
        }
        v8 = v4;
        if ((int)v12 >= (int)a3)
          goto LABEL_132;
      }
    }
  }
  return result;
}

size_t DGifDecompressInput(size_t result, _DWORD *a2)
{
  size_t v2;
  uint64_t v3;
  int v4;
  int v5;
  int v7;
  uint64_t v8;
  unsigned __int8 *v9;
  _BYTE *v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v14;
  uint64_t v15;
  int (*v16)(size_t, uint64_t, uint64_t);
  size_t v17;
  uint64_t v18;
  int (*v19)(size_t, uint64_t);
  __int16 v20;
  char *v21;
  unint64_t v23;
  int v24;
  int v25;

  v2 = result;
  v3 = *(_QWORD *)(result + 96);
  v4 = *(__int16 *)(v3 + 12);
  if (v4 > 12)
  {
LABEL_2:
    result = 0;
    v5 = 112;
    goto LABEL_3;
  }
  v7 = *(__int16 *)(v3 + 22);
  if (v7 >= v4)
  {
LABEL_24:
    v21 = (char *)&DGifDecompressInput_CodeMasks + 2 * (__int16)v4;
    if (v21 < &jpt_187EE2E14 && v21 >= (char *)&DGifDecompressInput_CodeMasks)
    {
      v23 = *(_QWORD *)(v3 + 24);
      *a2 = v23 & *((_WORD *)&DGifDecompressInput_CodeMasks + (__int16)v4);
      *(_QWORD *)(v3 + 24) = v23 >> v4;
      *(_WORD *)(v3 + 22) = v7 - v4;
      v24 = *(__int16 *)(v3 + 10);
      if (v24 <= 4096)
      {
        *(_WORD *)(v3 + 10) = v24 + 1;
        v25 = *(__int16 *)(v3 + 14);
        if ((__int16)v4 <= 11 && v24 >= v25)
        {
          *(_WORD *)(v3 + 14) = 2 * v25;
          *(_WORD *)(v3 + 12) = v4 + 1;
        }
      }
      return 1;
    }
    else
    {
LABEL_37:
      __break(0x5519u);
    }
    return result;
  }
  v9 = (unsigned __int8 *)(v3 + 64);
  LOBYTE(v8) = *(_BYTE *)(v3 + 64);
  v10 = (_BYTE *)(v3 + 65);
  while ((_BYTE)v8)
  {
    v11 = *v10;
    *v10 = v11 + 1;
    v12 = &v9[v11];
    if ((unint64_t)v12 >= v3 + 320 || v12 < v9)
      goto LABEL_37;
    v14 = *v12;
LABEL_23:
    LOBYTE(v8) = v8 - 1;
    *(_BYTE *)(v3 + 64) = v8;
    *(_QWORD *)(v3 + 24) |= v14 << v7;
    v20 = v7 + 8;
    v7 = (__int16)(v7 + 8);
    *(_WORD *)(v3 + 22) = v20;
    if (v7 >= (__int16)v4)
      goto LABEL_24;
  }
  v15 = *(_QWORD *)(v2 + 96);
  v16 = *(int (**)(size_t, uint64_t, uint64_t))(v15 + 48);
  if (v16)
    v17 = v16(v2, v3 + 64, 1);
  else
    v17 = fread((void *)(v3 + 64), 1uLL, 1uLL, *(FILE **)(v15 + 40));
  if (v17 == 1)
  {
    if (!*v9)
      goto LABEL_2;
    v18 = *(_QWORD *)(v2 + 96);
    v19 = *(int (**)(size_t, uint64_t))(v18 + 48);
    result = v19 ? v19(v2, v3 + 65) : fread((void *)(v3 + 65), 1uLL, *v9, *(FILE **)(v18 + 40));
    v8 = *v9;
    if (result == v8)
    {
      v14 = *(unsigned __int8 *)(v3 + 65);
      *(_BYTE *)(v3 + 65) = 2;
      LOWORD(v7) = *(_WORD *)(v3 + 22);
      LOWORD(v4) = *(_WORD *)(v3 + 12);
      goto LABEL_23;
    }
  }
  result = 0;
  v5 = 102;
LABEL_3:
  *(_DWORD *)(v2 + 80) = v5;
  return result;
}

void *_InitHashTable()
{
  void *v0;
  void *v1;

  v0 = malloc_type_malloc(0x8000uLL, 0x1000040B0612BB1uLL);
  v1 = v0;
  if (v0)
    memset(v0, 255, 0x8000uLL);
  return v1;
}

void *_ClearHashTable(void *a1)
{
  return memset(a1, 255, 0x8000uLL);
}

unint64_t _InsertHashTable(unint64_t result, unsigned int a2, __int16 a3)
{
  unsigned int i;
  int *v4;

  for (i = a2 ^ (a2 >> 12); ; LOWORD(i) = i + 1)
  {
    i &= 0x1FFFu;
    v4 = (int *)(result + 4 * i);
    if ((unint64_t)v4 >= result + 0x8000 || (unint64_t)v4 < result)
    {
      __break(0x5519u);
      return result;
    }
    if (*v4 >= 0xFFFFF000)
      break;
  }
  *v4 = a3 & 0xFFF | (a2 << 12);
  return result;
}

uint64_t _ExistsHashTable(unint64_t a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int *v3;
  unsigned int v5;

  LOWORD(v2) = (a2 ^ (a2 >> 12)) & 0x1FFF;
  v3 = (unsigned int *)(a1 + 4 * (unsigned __int16)v2);
  if ((unint64_t)v3 < a1 + 0x8000 && (unint64_t)v3 >= a1)
  {
    while (1)
    {
      v5 = *v3;
      if (v5 >> 12 == 0xFFFFF)
        break;
      if (v5 >> 12 == a2)
        return v5 & 0xFFF;
      v2 = ((_WORD)v2 + 1) & 0x1FFF;
      v3 = (unsigned int *)(a1 + 4 * v2);
      if ((unint64_t)v3 >= a1 + 0x8000 || (unint64_t)v3 < a1)
        goto LABEL_12;
    }
  }
  else
  {
LABEL_12:
    __break(0x5519u);
  }
  return 0xFFFFFFFFLL;
}

IIODictionary *CreatePropertiesFromAppleMakerNote(unsigned __int8 *a1, unint64_t a2)
{
  IIODictionary *v4;
  int Val16;
  int v6;
  char v7;
  int v8;
  const __CFString *v9;
  int v10;
  const __CFAllocator *v11;
  _BOOL4 v12;
  CFIndex v13;
  unsigned int v14;
  UInt8 *v15;
  int v16;
  __CFArray *Mutable;
  unsigned int v18;
  CFNumberRef v19;
  int v20;
  CFIndex v21;
  __CFArray *v22;
  const __CFData *v23;
  unsigned int v24;
  int v25;
  int v26;
  CFNumberRef v27;
  unsigned int v28;
  CFNumberRef v29;
  int v30;
  CFNumberRef v31;
  int Val32;
  int v33;
  const __CFString *v34;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFData *v36;
  CFTypeID v37;
  const __CFString *v39;
  unint64_t valuePtr;
  void *value[2];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  _OWORD v46[4];
  BOOL v47[8];
  uint64_t v48;
  _DWORD v49[4];

  kdebug_trace();
  v49[0] = 0;
  v48 = 0;
  *(_QWORD *)v47 = 0;
  memset(v46, 0, sizeof(v46));
  IIOScanner::IIOScanner((IIOScanner *)v46, a1, a2, 0);
  if (a2 - 64513 <= 0xFFFFFFFFFFFF040ELL)
  {
    _cg_jpeg_mem_term("CreatePropertiesFromAppleMakerNote", 185, "*** ERROR: bad makerNote length: %d\n", a2);
    v4 = 0;
    goto LABEL_97;
  }
  IIOScanner::skip((uint64_t)v46, 10);
  Val16 = IIOScanner::getVal16((IIOScanner *)v46);
  if (Val16 != 1)
  {
    _cg_jpeg_mem_term("CreatePropertiesFromAppleMakerNote", 193, "*** ERROR: cannot handle version '%d' makernote\n", Val16);
    goto LABEL_88;
  }
  v6 = IIOScanner::getVal16((IIOScanner *)v46);
  if (v6 == 19789)
  {
    v7 = 0;
  }
  else
  {
    if (v6 != 18761)
    {
LABEL_88:
      v4 = 0;
      goto LABEL_96;
    }
    v7 = 1;
  }
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v46, v7);
  v8 = IIOScanner::getVal16((IIOScanner *)v46);
  if (&a1[12 * v8 + 10] > &a1[a2])
    goto LABEL_88;
  v4 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v4);
  IIODictionary::IIODictionary((IIODictionary *)value);
  v9 = CFSTR("{MakerApple}");
  IIODictionary::setObjectForKey(v4, value[1], CFSTR("{MakerApple}"));
  IIODictionary::~IIODictionary((IIODictionary *)value);
  if (!v8)
    goto LABEL_90;
  v10 = 0;
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (2)
  {
    if (*(_DWORD *)v47)
      goto LABEL_84;
    IIOScanner::getTiffTag((uint64_t)v46, (uint64_t)&v48);
    if (HIDWORD(v48) >= a2)
    {
      _cg_jpeg_mem_term("CreatePropertiesFromAppleMakerNote", 222, "*** AppleMakerNote: bad tag count (%d) for size '%d'\n", HIDWORD(v48), a2);
      goto LABEL_90;
    }
    v12 = 0;
    v13 = 0;
    v14 = HIDWORD(v48);
    v15 = (UInt8 *)v49;
    v16 = 0;
    switch(WORD1(v48))
    {
      case 1:
      case 2:
      case 6:
      case 7:
        goto LABEL_17;
      case 3:
      case 8:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
        break;
      case 4:
      case 9:
        v14 = 4 * HIDWORD(v48);
        goto LABEL_16;
      case 5:
      case 0xA:
      case 0x10:
      case 0x11:
      case 0x12:
        v14 = 8 * HIDWORD(v48);
LABEL_16:
        v12 = HIDWORD(v48) > 1;
LABEL_17:
        v13 = v14;
        if (v14 > a2)
          goto LABEL_84;
        if (v14 >= 5)
        {
          if (!a1 || v49[0] >= a2 || v49[0] + (unint64_t)v14 > a2)
            goto LABEL_84;
          v15 = &a1[v49[0]];
          v16 = 1;
        }
        else
        {
          v15 = (UInt8 *)v49;
          v16 = v14;
        }
        break;
      default:
        v15 = (UInt8 *)v49;
        v16 = 0;
        break;
    }
    switch(WORD1(v48))
    {
      case 7:
        v23 = CFDataCreate(v11, v15, v13);
        if (!v23)
          goto LABEL_84;
        Mutable = (__CFArray *)CFPropertyListCreateWithData(v11, v23, 0, 0, 0);
        if (Mutable)
          CFRelease(v23);
        else
          Mutable = v23;
        goto LABEL_81;
      case 8:
      case 0xB:
      case 0xC:
      case 0xD:
      case 0xE:
      case 0xF:
        goto LABEL_40;
      case 9:
        if (!v12)
        {
          v22 = CFNumberCreate(v11, kCFNumberSInt32Type, v49);
LABEL_62:
          Mutable = v22;
          if (!v22)
            goto LABEL_84;
          goto LABEL_81;
        }
        v45 = 0;
        v43 = 0u;
        v44 = 0u;
        *(_OWORD *)value = 0u;
        v42 = 0u;
        IIOScanner::IIOScanner((IIOScanner *)value, v15, (4 * HIDWORD(v48)), v47[4]);
        if (HIDWORD(v48) < a2)
        {
          Mutable = CFArrayCreateMutable(v11, HIDWORD(v48), MEMORY[0x1E0C9B378]);
          if (Mutable)
          {
            if (HIDWORD(v48))
            {
              v39 = v9;
              v28 = 0;
              while (1)
              {
                LODWORD(valuePtr) = 0;
                LODWORD(valuePtr) = IIOScanner::getVal32((IIOScanner *)value);
                v29 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
                if (!v29)
                  break;
                CFArrayAppendValue(Mutable, v29);
                CFRelease(v29);
                ++v28;
                v30 = HIDWORD(v48);
                if (v28 >= HIDWORD(v48))
                  goto LABEL_76;
              }
              v30 = HIDWORD(v48);
LABEL_76:
              if (v28 == v30)
              {
LABEL_77:
                v9 = v39;
              }
              else
              {
LABEL_78:
                v9 = v39;
                CFRelease(Mutable);
LABEL_79:
                Mutable = 0;
              }
            }
LABEL_80:
            IIOScanner::~IIOScanner((IIOScanner *)value);
            if (!Mutable)
              goto LABEL_84;
LABEL_81:
            v34 = CFStringCreateWithFormat(v11, 0, CFSTR("%hu"), (unsigned __int16)v48);
            if (v34)
            {
              IIODictionary::setObjectForKeyGroup(v4, Mutable, v34, v9);
              CFRelease(v34);
            }
            CFRelease(Mutable);
            goto LABEL_84;
          }
          IIOScanner::~IIOScanner((IIOScanner *)value);
LABEL_84:
          if (++v10 == v8)
            goto LABEL_90;
          continue;
        }
LABEL_89:
        IIOScanner::~IIOScanner((IIOScanner *)value);
LABEL_90:
        if (IIODictionary::containsKeyGroup(v4, CFSTR("49"), v9))
        {
          ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(v4, CFSTR("49"), v9);
          v36 = ObjectForKeyGroup;
          if (ObjectForKeyGroup)
          {
            v37 = CFGetTypeID(ObjectForKeyGroup);
            if (v37 == CFDataGetTypeID())
            {
              if (CFDataGetLength(v36) <= 43)
                LogError("CreatePropertiesFromAppleMakerNote", 464, "*** ERROR: {MakerApple} tag 49 has wrong size - this may crash in 'PhotosUIPrivate' (rdar://89839720)\n");
            }
            else
            {
              IIODictionary::removeObjectForKeyGroup(v4, CFSTR("49"), v9);
            }
          }
        }
LABEL_96:
        kdebug_trace();
LABEL_97:
        IIOScanner::~IIOScanner((IIOScanner *)v46);
        return v4;
      case 0xA:
        v45 = 0;
        v43 = 0u;
        v44 = 0u;
        *(_OWORD *)value = 0u;
        v42 = 0u;
        IIOScanner::IIOScanner((IIOScanner *)value, v15, (8 * HIDWORD(v48)), v47[4]);
        if (!v12)
        {
          Val32 = IIOScanner::getVal32((IIOScanner *)value);
          v33 = IIOScanner::getVal32((IIOScanner *)value);
          if (!v33)
            goto LABEL_79;
          *(float *)&valuePtr = (float)Val32 / (float)v33;
          v31 = CFNumberCreate(v11, kCFNumberFloatType, &valuePtr);
          goto LABEL_66;
        }
        Mutable = CFArrayCreateMutable(v11, HIDWORD(v48), MEMORY[0x1E0C9B378]);
        if (!Mutable)
          goto LABEL_80;
        v39 = v9;
        if (HIDWORD(v48))
        {
          v24 = 0;
          do
          {
            v25 = IIOScanner::getVal32((IIOScanner *)value);
            v26 = IIOScanner::getVal32((IIOScanner *)value);
            if (!v26)
              break;
            *(float *)&valuePtr = (float)v25 / (float)v26;
            v27 = CFNumberCreate(v11, kCFNumberFloatType, &valuePtr);
            if (!v27)
              break;
            CFArrayAppendValue(Mutable, v27);
            CFRelease(v27);
            ++v24;
          }
          while (v24 < HIDWORD(v48));
        }
        else
        {
          v24 = 0;
        }
        if (v24 == HIDWORD(v48))
          goto LABEL_77;
        goto LABEL_78;
      case 0x10:
      case 0x11:
        v45 = 0;
        v43 = 0u;
        v44 = 0u;
        *(_OWORD *)value = 0u;
        v42 = 0u;
        IIOScanner::IIOScanner((IIOScanner *)value, v15, (8 * HIDWORD(v48)), v47[4]);
        if (!v12)
        {
          valuePtr = 0;
          valuePtr = IIOScanner::getVal64((IIOScanner *)value);
          v31 = CFNumberCreate(v11, kCFNumberSInt64Type, &valuePtr);
LABEL_66:
          Mutable = v31;
          goto LABEL_80;
        }
        if (HIDWORD(v48) >= a2)
          goto LABEL_89;
        Mutable = CFArrayCreateMutable(v11, HIDWORD(v48), MEMORY[0x1E0C9B378]);
        if (!Mutable || !HIDWORD(v48))
          goto LABEL_80;
        v39 = v9;
        v18 = 0;
        while (1)
        {
          valuePtr = 0;
          valuePtr = IIOScanner::getVal64((IIOScanner *)value);
          v19 = CFNumberCreate(v11, kCFNumberSInt64Type, &valuePtr);
          if (!v19)
            break;
          CFArrayAppendValue(Mutable, v19);
          CFRelease(v19);
          ++v18;
          v20 = HIDWORD(v48);
          if (v18 >= HIDWORD(v48))
            goto LABEL_69;
        }
        v20 = HIDWORD(v48);
LABEL_69:
        if (v18 != v20)
          goto LABEL_78;
        goto LABEL_77;
      default:
        if (WORD1(v48) == 2)
        {
          if (v16)
            v21 = v13 - 1;
          else
            v21 = 0;
          if (v21 >= 1)
          {
            v22 = (__CFArray *)CFStringCreateWithBytes(v11, v15, v21, 0x8000100u, 1u);
            goto LABEL_62;
          }
        }
        else
        {
LABEL_40:
          _cg_jpeg_mem_term("CreatePropertiesFromAppleMakerNote", 432, "*** ERROR: '%d'-tagType was not handled when creating properties from AppleMakerNote\n", WORD1(v48));
        }
        goto LABEL_84;
    }
  }
}

void sub_187EE343C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

void IIOTag::updateTypeAndCount(IIOTag *this)
{
  __int16 v2;
  unsigned int StringLenMax;
  uint64_t v4;
  uint64_t SizeForTiffType;
  unsigned int v6;
  __int16 v7;
  _QWORD v8[3];

  *((_BYTE *)this + 40) = 1;
  switch(*((_WORD *)this + 4))
  {
    case 1:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 0xA:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x12:
    case 0x14:
    case 0x19:
    case 0x1B:
    case 0x1C:
    case 0x1E:
    case 0x1F:
    case 0x22:
    case 0x26:
    case 0x28:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3F:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x48:
    case 0x49:
    case 0x4A:
    case 0x52:
    case 0x53:
    case 0x55:
    case 0x58:
    case 0x59:
      v2 = 9;
      goto LABEL_3;
    case 2:
    case 3:
    case 0x31:
    case 0x3E:
    case 0x40:
    case 0x4C:
    case 0x4E:
    case 0x4F:
    case 0x50:
    case 0x51:
    case 0x54:
    case 0x5A:
      goto LABEL_23;
    case 8:
    case 0x24:
      *((_WORD *)this + 5) = 10;
      StringLenMax = 3;
      goto LABEL_4;
    case 0xB:
    case 0x11:
    case 0x15:
    case 0x18:
    case 0x20:
    case 0x29:
    case 0x2A:
    case 0x2B:
      *((_WORD *)this + 5) = 2;
      StringLenMax = 36;
      goto LABEL_4;
    case 0xC:
    case 0x13:
      v7 = 10;
      goto LABEL_20;
    case 0x16:
      *((_WORD *)this + 5) = 7;
      *((_BYTE *)this + 40) = 0;
      goto LABEL_24;
    case 0x17:
    case 0x25:
      v2 = 16;
      goto LABEL_3;
    case 0x1A:
      *((_WORD *)this + 5) = 2;
      StringLenMax = 5;
      goto LABEL_4;
    case 0x1D:
    case 0x21:
    case 0x27:
    case 0x30:
    case 0x4B:
    case 0x4D:
      v2 = 10;
LABEL_3:
      *((_WORD *)this + 5) = v2;
      StringLenMax = 1;
      goto LABEL_4;
    case 0x23:
      v7 = 9;
LABEL_20:
      *((_WORD *)this + 5) = v7;
      StringLenMax = 2;
      goto LABEL_4;
    case 0x57:
      *((_WORD *)this + 5) = 2;
      StringLenMax = IIOTag::getStringLenMax(this, 0x24u);
      goto LABEL_4;
    default:
      if (IIO_OSAppleInternalBuild())
      {
        LogError("updateTypeAndCount", 745, "*** ERROR: Unknown AppleMakerNote tag '%d'. If this tagID was added recently, please file a bug against ImageIO to add support for the new tagID.\n", *((unsigned __int16 *)this + 4));
        *((_BYTE *)this + 40) = 0;
LABEL_23:
        *((_WORD *)this + 5) = 7;
LABEL_24:
        StringLenMax = IIOTag::getByteCountOfCFObject(this);
LABEL_4:
        *((_DWORD *)this + 3) = StringLenMax;
      }
      else
      {
        LogError("updateTypeAndCount", 752, "*** ERROR: Unknown AppleMakerNote tag '%d' - ignoring...\n", *((unsigned __int16 *)this + 4));
        StringLenMax = *((_DWORD *)this + 3);
      }
      v4 = StringLenMax;
      SizeForTiffType = GetSizeForTiffType(*((unsigned __int16 *)this + 5));
      *((_QWORD *)this + 2) = SizeForTiffType * v4;
      if (SizeForTiffType * v4 && *((_WORD *)this + 5) == 2)
      {
        memset(v8, 0, sizeof(v8));
        IIOString::IIOString((IIOString *)v8, *((const void **)this + 4));
        v6 = IIOString::length((IIOString *)v8);
        if (v6)
        {
          if (*((_BYTE *)IIOString::utf8String((IIOString *)v8) + v6 - 1))
          {
            *((_DWORD *)this + 3) += GetSizeForTiffType(*((unsigned __int16 *)this + 5));
            *((_QWORD *)this + 2) += GetSizeForTiffType(*((unsigned __int16 *)this + 5));
          }
        }
        IIOString::~IIOString((IIOString *)v8);
      }
      return;
  }
}

void sub_187EE3660(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIOTag::~IIOTag(IIOTag *this)
{
  JUMPOUT(0x18D761C30);
}

uint64_t IIOTag::CreateTagWithProperty(const __CFString *this, const void *a2, const void *a3)
{
  uint64_t v5;

  v5 = operator new();
  *(_QWORD *)v5 = &off_1E1BB28F0;
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_QWORD *)(v5 + 40) = 0;
  *(_WORD *)(v5 + 8) = CFStringGetIntValue(this);
  *(_QWORD *)(v5 + 32) = a2;
  IIOTag::updateTypeAndCount((IIOTag *)v5);
  *(_QWORD *)(v5 + 48) = 0;
  return v5;
}

void sub_187EE370C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10C1C40C78C77A5);
  _Unwind_Resume(a1);
}

uint64_t IIOTag::getStringLenMax(IIOTag *this, unsigned int a2)
{
  const __CFString *v3;
  CFTypeID TypeID;
  uint64_t result;

  v3 = (const __CFString *)*((_QWORD *)this + 4);
  TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(v3))
    return 0;
  LODWORD(result) = CFStringGetLength(v3);
  if (result >= a2)
    return a2;
  else
    return result;
}

CFIndex IIOTag::getByteCountOfCFObject(IIOTag *this)
{
  const __CFData *v1;
  CFTypeID TypeID;
  CFIndex Length;
  CFTypeID v4;
  const char *v5;
  const __CFData *Data;
  const __CFData *v7;
  _QWORD v9[3];

  v1 = (const __CFData *)*((_QWORD *)this + 4);
  if (!*((_BYTE *)this + 40))
    goto LABEL_7;
  TypeID = CFDataGetTypeID();
  if (TypeID == CFGetTypeID(v1))
    return CFDataGetLength(v1);
  v4 = CFStringGetTypeID();
  if (v4 == CFGetTypeID(v1))
  {
    memset(v9, 0, sizeof(v9));
    IIOString::IIOString((IIOString *)v9, v1);
    v5 = (const char *)IIOString::utf8String((IIOString *)v9);
    if (v5)
      Length = strlen(v5) + 1;
    else
      Length = 0;
    IIOString::~IIOString((IIOString *)v9);
  }
  else
  {
LABEL_7:
    Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (Data)
    {
      v7 = Data;
      Length = CFDataGetLength(Data);
      CFRelease(v7);
    }
    else
    {
      return 0;
    }
  }
  return Length;
}

void sub_187EE3874(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

BOOL IIOTag::TagCompare(IIOTag *this, IIOTag *a2, IIOTag *a3)
{
  return *((unsigned __int16 *)this + 4) < *((unsigned __int16 *)a2 + 4);
}

uint64_t IIOTag::writePropertyAndData(IIOTag *this, IIOWriteStream *a2, IIOWriteStream *a3)
{
  uint64_t result;
  int v7;
  unsigned int v8;
  unsigned __int8 v9[4];

  IIOWriteStream::write16((uint64_t)a2, *((_WORD *)this + 4));
  IIOWriteStream::write16((uint64_t)a2, *((_WORD *)this + 5));
  IIOWriteStream::write32((uint64_t)a2, *((_DWORD *)this + 3));
  if (*((_QWORD *)this + 2) > 4uLL)
  {
    v7 = *((_DWORD *)this + 12);
    v8 = IIOImageSource::count(a3) + v7;
    IIOWriteStream::write32((uint64_t)a2, v8);
    *((_DWORD *)this + 6) = v8;
    return IIOTag::writeData((CFTypeRef *)this, a3);
  }
  else
  {
    result = IIOTag::writeData((CFTypeRef *)this, a2);
    if ((result & 0xFFFFFFFC) == 0)
    {
      *(_DWORD *)v9 = 0;
      return (uint64_t)IIOWriteStream::writeBytes(a2, v9, (4 - result));
    }
  }
  return result;
}

uint64_t IIOTag::writeData(CFTypeRef *this, IIOWriteStream *a2)
{
  CFTypeID v4;
  IIOTag *TypeID;
  IIOTag *v6;
  IIOArray *v7;
  size_t v8;
  void *v9;
  uint64_t (*v10)(uint64_t, const __CFNumber *, uint64_t, _BYTE *);
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;

  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 0;
  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 0;
  v4 = CFGetTypeID(this[4]);
  TypeID = (IIOTag *)CFArrayGetTypeID();
  v6 = TypeID;
  if ((IIOTag *)v4 == TypeID)
  {
    v7 = (IIOArray *)operator new();
    TypeID = IIOArray::IIOArray(v7, (const __CFArray *)this[4]);
  }
  else
  {
    v7 = 0;
  }
  switch(*((_WORD *)this + 5))
  {
    case 1:
    case 2:
    case 6:
    case 7:
      v8 = IIOTag::writeBytes((IIOTag *)this, a2);
      goto LABEL_24;
    case 3:
    case 8:
      if ((IIOTag *)v4 == v6)
      {
        v19[3] = (uint64_t)this[2] + v23[3];
        v16 = MEMORY[0x1E0C809B0];
        v9 = &unk_1E1BBE410;
        v10 = ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_2;
        v11 = &v16;
        goto LABEL_14;
      }
      IIOTag::writeBits16(TypeID, a2, (const __CFNumber *)this[4]);
      v8 = 2;
      goto LABEL_24;
    case 4:
    case 9:
    case 0xD:
      if ((IIOTag *)v4 == v6)
      {
        v19[3] = (uint64_t)this[2] + v23[3];
        v15 = MEMORY[0x1E0C809B0];
        v9 = &unk_1E1BBE438;
        v10 = ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_3;
        v11 = &v15;
        goto LABEL_14;
      }
      IIOTag::writeBits32(TypeID, a2, (const __CFNumber *)this[4]);
      v8 = 4;
      goto LABEL_24;
    case 5:
    case 0xA:
      if ((IIOTag *)v4 == v6)
      {
        v19[3] = (uint64_t)this[2] + v23[3];
        v17 = MEMORY[0x1E0C809B0];
        v9 = &unk_1E1BBCDE8;
        v10 = ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke;
        v11 = &v17;
        goto LABEL_14;
      }
      IIOTag::writeRational(TypeID, a2, (const __CFNumber *)this[4]);
      goto LABEL_23;
    case 0x10:
    case 0x11:
    case 0x12:
      if ((IIOTag *)v4 == v6)
      {
        v19[3] = (uint64_t)this[2] + v23[3];
        v14 = MEMORY[0x1E0C809B0];
        v9 = &unk_1E1BBE460;
        v10 = ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_4;
        v11 = &v14;
LABEL_14:
        v11[1] = 0x40000000;
        v11[2] = (uint64_t)v10;
        v11[3] = (uint64_t)v9;
        v11[6] = (uint64_t)this;
        v11[7] = (uint64_t)a2;
        v11[4] = (uint64_t)&v22;
        v11[5] = (uint64_t)&v18;
        IIOArray::enumerate((uint64_t)v7, (uint64_t)v11);
LABEL_15:
        if (v7)
LABEL_16:
          (*(void (**)(IIOArray *))(*(_QWORD *)v7 + 8))(v7);
      }
      else
      {
        IIOTag::writeBits64(TypeID, a2, (const __CFNumber *)this[4]);
LABEL_23:
        v8 = 8;
LABEL_24:
        v23[3] = v8;
        if (v7)
          goto LABEL_16;
      }
      v12 = v23[3];
      _Block_object_dispose(&v18, 8);
      _Block_object_dispose(&v22, 8);
      return v12;
    default:
      _cg_jpeg_mem_term("writeData", 894, "*** unhandled tagType (%d) for tagID %d\n", *((unsigned __int16 *)this + 5), *((unsigned __int16 *)this + 4));
      goto LABEL_15;
  }
}

void sub_187EE3C30(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Block_object_dispose((const void *)(v2 - 112), 8);
  _Block_object_dispose((const void *)(v2 - 80), 8);
  _Unwind_Resume(a1);
}

size_t IIOTag::writeBytes(IIOTag *this, IIOWriteStream *a2)
{
  CFTypeID TypeID;
  const __CFData *Data;
  CFTypeID v6;
  const char *v7;
  unsigned __int8 *v8;
  unsigned int v9;
  const __CFData *v10;
  unint64_t Length;
  size_t v12;
  unsigned __int8 *BytePtr;
  size_t v14;
  unsigned int v15;
  unsigned __int8 v18;
  _QWORD v19[3];

  if (!*((_BYTE *)this + 40))
    goto LABEL_7;
  TypeID = CFDataGetTypeID();
  if (TypeID == CFGetTypeID(*((CFTypeRef *)this + 4)))
  {
    Data = (const __CFData *)CFRetain(*((CFTypeRef *)this + 4));
    goto LABEL_8;
  }
  v6 = CFStringGetTypeID();
  if (v6 != CFGetTypeID(*((CFTypeRef *)this + 4)))
  {
LABEL_7:
    Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *((CFPropertyListRef *)this + 4), kCFPropertyListBinaryFormat_v1_0, 0, 0);
LABEL_8:
    v10 = Data;
    if (!Data)
      return 0;
    Length = CFDataGetLength(Data);
    v12 = *((_QWORD *)this + 2);
    if (Length < v12)
      v12 = CFDataGetLength(v10);
    BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v10);
    IIOWriteStream::writeBytes(a2, BytePtr, v12);
    CFRelease(v10);
    return v12;
  }
  memset(v19, 0, sizeof(v19));
  IIOString::IIOString((IIOString *)v19, *((const void **)this + 4));
  v7 = (const char *)IIOString::utf8String((IIOString *)v19);
  v8 = (unsigned __int8 *)v7;
  if (v7)
    v9 = strlen(v7);
  else
    v9 = 0;
  v14 = v9;
  v12 = *((_QWORD *)this + 2);
  if (v12 - 1 <= v9)
  {
    if (v12 - 1 < v9)
    {
      LogError("writeBytes", 929, "*** ERROR: {MakerApple} tag-%d: expected string length: %d (got: %d) --> clipping\n", *((unsigned __int16 *)this + 4), v12 - 1, v9);
      v12 = *((_QWORD *)this + 2);
    }
    IIOWriteStream::writeBytes(a2, v8, v12);
  }
  else
  {
    LogError("writeBytes", 936, "*** ERROR: {MakerApple} tag-%d: expected string length: %d (got: %d) --> padding\n", *((unsigned __int16 *)this + 4), v12 - 1, v9);
    IIOWriteStream::writeBytes(a2, v8, v14);
    v18 = 46;
    if (*((_QWORD *)this + 2) - 1 > v14)
    {
      v15 = v14 + 1;
      do
        IIOWriteStream::writeBytes(a2, &v18, 1uLL);
      while (*((_QWORD *)this + 2) - 1 > (unint64_t)v15++);
    }
    v18 = 0;
    IIOWriteStream::writeBytes(a2, &v18, 1uLL);
    v12 = 0;
  }
  IIOString::~IIOString((IIOString *)v19);
  return v12;
}

void sub_187EE3E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke(uint64_t a1, const __CFNumber *a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;

  result = IIOTag::writeRational((IIOTag *)a1, *(IIOWriteStream **)(a1 + 56), a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 8;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)
                                                                                + 24))
    *a4 = 1;
  return result;
}

uint64_t IIOTag::writeRational(IIOTag *this, IIOWriteStream *a2, const __CFNumber *a3)
{
  float v4;
  unsigned int v6;
  unsigned int v7[6];

  IIONumber::IIONumber((IIONumber *)v7, a3);
  v4 = IIONumber::floatNum((IIONumber *)v7);
  IIONumber::~IIONumber((IIONumber *)v7);
  v6 = 1;
  v7[0] = 0;
  SRationalApprox(v4, (int *)v7, &v6);
  IIOWriteStream::write32((uint64_t)a2, v7[0]);
  IIOWriteStream::write32((uint64_t)a2, v6);
  return 8;
}

void sub_187EE3F8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_2(uint64_t a1, const __CFNumber *a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;

  result = IIOTag::writeBits16((IIOTag *)a1, *(IIOWriteStream **)(a1 + 56), a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 2;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)
                                                                                + 24))
    *a4 = 1;
  return result;
}

uint64_t IIOTag::writeBits16(IIOTag *this, IIOWriteStream *a2, const __CFNumber *a3)
{
  __int16 v4;
  _BYTE v6[24];

  IIONumber::IIONumber((IIONumber *)v6, a3);
  v4 = IIONumber::uint16Num((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  IIOWriteStream::write16((uint64_t)a2, v4);
  return 2;
}

void sub_187EE4058(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_3(uint64_t a1, const __CFNumber *a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;

  result = IIOTag::writeBits32((IIOTag *)a1, *(IIOWriteStream **)(a1 + 56), a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 4;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)
                                                                                + 24))
    *a4 = 1;
  return result;
}

uint64_t IIOTag::writeBits32(IIOTag *this, IIOWriteStream *a2, const __CFNumber *a3)
{
  unsigned int v4;
  _BYTE v6[24];

  IIONumber::IIONumber((IIONumber *)v6, a3);
  v4 = IIONumber::uint32Num((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  IIOWriteStream::write32((uint64_t)a2, v4);
  return 4;
}

void sub_187EE4124(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_4(uint64_t a1, const __CFNumber *a2, uint64_t a3, _BYTE *a4)
{
  uint64_t result;

  result = IIOTag::writeBits64((IIOTag *)a1, *(IIOWriteStream **)(a1 + 56), a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 8;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) >= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)
                                                                                + 24))
    *a4 = 1;
  return result;
}

uint64_t IIOTag::writeBits64(IIOTag *this, IIOWriteStream *a2, const __CFNumber *a3)
{
  unint64_t v4;
  _BYTE v6[24];

  IIONumber::IIONumber((IIONumber *)v6, a3);
  v4 = IIONumber::uint64Num((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  IIOWriteStream::write64((uint64_t)a2, v4);
  return 8;
}

void sub_187EE41F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void AppleMakerNoteWriter::AppleMakerNoteWriter(AppleMakerNoteWriter *this, const __CFDictionary *a2, char a3)
{
  _QWORD v4[5];
  _QWORD v5[3];

  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_1E1BB1E00;
  *((_QWORD *)this + 1) = a2;
  *((_BYTE *)this + 16) = a3;
  memset(v5, 0, sizeof(v5));
  IIODictionary::IIODictionary((IIODictionary *)v5, a2);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZN20AppleMakerNoteWriterC2EPK14__CFDictionaryb_block_invoke;
  v4[3] = &__block_descriptor_tmp_18;
  v4[4] = this;
  IIODictionary::enumerate((uint64_t)v5, v4);
  IIODictionary::~IIODictionary((IIODictionary *)v5);
}

void sub_187EE42A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  void **v7;
  void *v9;
  va_list va;

  va_start(va, a6);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  v9 = *v7;
  if (*v7)
  {
    *(_QWORD *)(v6 + 32) = v9;
    operator delete(v9);
  }
  _Unwind_Resume(a1);
}

void ___ZN20AppleMakerNoteWriterC2EPK14__CFDictionaryb_block_invoke(uint64_t a1, const __CFString *this, void *a3)
{
  _QWORD *v3;
  uint64_t TagWithProperty;
  uint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  if ((void *)*MEMORY[0x1E0C9B0D0] != a3)
  {
    v3 = *(_QWORD **)(a1 + 32);
    TagWithProperty = IIOTag::CreateTagWithProperty(this, a3, a3);
    v5 = (uint64_t *)v3[4];
    v6 = v3[5];
    if ((unint64_t)v5 >= v6)
    {
      v8 = v3[3];
      v9 = ((uint64_t)v5 - v8) >> 3;
      if ((unint64_t)(v9 + 1) >> 61)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v10 = v6 - v8;
      v11 = v10 >> 2;
      if (v10 >> 2 <= (unint64_t)(v9 + 1))
        v11 = v9 + 1;
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
        v12 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      if (v12)
        v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(v3 + 5), v12);
      else
        v13 = 0;
      v14 = (uint64_t *)&v13[8 * v9];
      v15 = &v13[8 * v12];
      *v14 = TagWithProperty;
      v7 = v14 + 1;
      v17 = (char *)v3[3];
      v16 = (char *)v3[4];
      if (v16 != v17)
      {
        do
        {
          v18 = *((_QWORD *)v16 - 1);
          v16 -= 8;
          *--v14 = v18;
        }
        while (v16 != v17);
        v16 = (char *)v3[3];
      }
      v3[3] = v14;
      v3[4] = v7;
      v3[5] = v15;
      if (v16)
        operator delete(v16);
    }
    else
    {
      *v5 = TagWithProperty;
      v7 = v5 + 1;
    }
    v3[4] = v7;
  }
}

void AppleMakerNoteWriter::~AppleMakerNoteWriter(AppleMakerNoteWriter *this)
{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = &off_1E1BB1E00;
  v2 = (_QWORD *)*((_QWORD *)this + 3);
  v3 = (_QWORD *)*((_QWORD *)this + 4);
  if (v2 != v3)
  {
    do
    {
      if (*v2)
        (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 8))(*v2);
      ++v2;
    }
    while (v2 != v3);
    v2 = (_QWORD *)*((_QWORD *)this + 3);
  }
  *((_QWORD *)this + 4) = v2;
  if (v2)
    operator delete(v2);
}

{
  AppleMakerNoteWriter::~AppleMakerNoteWriter(this);
  JUMPOUT(0x18D761C30);
}

uint64_t AppleMakerNoteWriter::writePropertiesAndData(AppleMakerNoteWriter *this, IIOWriteStream *a2, IIOWriteStream *a3)
{
  __int16 v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  IIOTag **v11;
  IIOTag **v12;
  IIOTag *v13;
  BOOL (*v15)(IIOTag *, IIOTag *, IIOTag *);

  IIOWriteStream::writeBytes(a2, "Apple iOS", 0xAuLL);
  IIOWriteStream::write16((uint64_t)a2, 1);
  if (*((_BYTE *)this + 16))
    v6 = 18761;
  else
    v6 = 19789;
  IIOWriteStream::write16((uint64_t)a2, v6);
  IIOWriteStream::write16((uint64_t)a2, (*((_DWORD *)this + 8) - *((_DWORD *)this + 6)) >> 3);
  v7 = *((_QWORD *)this + 3);
  v8 = (uint64_t *)*((_QWORD *)this + 4);
  v9 = 126 - 2 * __clz(((uint64_t)v8 - v7) >> 3);
  v15 = IIOTag::TagCompare;
  if (v8 == (uint64_t *)v7)
    v10 = 0;
  else
    v10 = v9;
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,false>(v7, v8, (uint64_t (**)(uint64_t, uint64_t))&v15, v10, 1);
  v12 = (IIOTag **)*((_QWORD *)this + 3);
  v11 = (IIOTag **)*((_QWORD *)this + 4);
  while (v12 != v11)
  {
    v13 = *v12++;
    IIOTag::writePropertyAndData(v13, a2, a3);
  }
  return IIOWriteStream::write32((uint64_t)a2, 0);
}

void AppleMakerNoteWriter::writeToBuffer(AppleMakerNoteWriter *this, unsigned __int8 *__b, size_t a3)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  _OWORD v10[2];
  uint64_t v11;
  _OWORD v12[2];
  uint64_t v13;

  v6 = (uint64_t *)*((_QWORD *)this + 3);
  v5 = (uint64_t *)*((_QWORD *)this + 4);
  v7 = 12 * (v5 - v6) + 20;
  for (i = a3 - v7; v6 != v5; *(_QWORD *)(v9 + 48) = v7)
    v9 = *v6++;
  memset(__b, 85, a3);
  v13 = 0;
  memset(v12, 0, sizeof(v12));
  IIOWriteStream::IIOWriteStream((IIOWriteStream *)v12, __b, v7, *((_BYTE *)this + 16));
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  IIOWriteStream::IIOWriteStream((IIOWriteStream *)v10, &__b[v7], i, *((_BYTE *)this + 16));
  AppleMakerNoteWriter::writePropertiesAndData(this, (IIOWriteStream *)v12, (IIOWriteStream *)v10);
  IIOWriteStream::~IIOWriteStream((IIOWriteStream *)v10);
  IIOWriteStream::~IIOWriteStream((IIOWriteStream *)v12);
}

void sub_187EE4624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  IIOWriteStream::~IIOWriteStream((IIOWriteStream *)&a9);
  IIOWriteStream::~IIOWriteStream((IIOWriteStream *)&a15);
  _Unwind_Resume(a1);
}

uint64_t AppleMakerNoteGetLength(const __CFDictionary *a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v8 = 0u;
  v9 = 0u;
  v7 = 0u;
  AppleMakerNoteWriter::AppleMakerNoteWriter((AppleMakerNoteWriter *)&v7, a1, 0);
  if (*((_QWORD *)&v8 + 1) == (_QWORD)v9)
  {
    v1 = 0;
  }
  else
  {
    v1 = 0;
    v2 = (uint64_t *)*((_QWORD *)&v8 + 1);
    do
    {
      v3 = *v2++;
      v4 = *(_QWORD *)(v3 + 16);
      if (v4 <= 4)
        v4 = 0;
      v1 += v4;
    }
    while (v2 != (uint64_t *)v9);
  }
  v5 = v1 + 12 * ((uint64_t)(v9 - *((_QWORD *)&v8 + 1)) >> 3) + 20;
  AppleMakerNoteWriter::~AppleMakerNoteWriter((AppleMakerNoteWriter *)&v7);
  return v5;
}

void AppleMakerNoteWriteToBuffer(const __CFDictionary *a1, unsigned __int8 *a2, size_t a3, char a4)
{
  _OWORD v8[3];

  kdebug_trace();
  memset(v8, 0, sizeof(v8));
  AppleMakerNoteWriter::AppleMakerNoteWriter((AppleMakerNoteWriter *)v8, a1, a4);
  AppleMakerNoteWriter::writeToBuffer((AppleMakerNoteWriter *)v8, a2, a3);
  kdebug_trace();
  AppleMakerNoteWriter::~AppleMakerNoteWriter((AppleMakerNoteWriter *)v8);
}

void sub_187EE4780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  AppleMakerNoteWriter::~AppleMakerNoteWriter((AppleMakerNoteWriter *)&a9);
  _Unwind_Resume(a1);
}

void std::vector<IIOTag *>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E1B80120, MEMORY[0x1E0DE42D0]);
}

void sub_187EE47E4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,false>(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  char v18;
  BOOL v19;
  uint64_t v20;

  v8 = (uint64_t *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        result = (*a3)(*(a2 - 1), *v9);
        if ((_DWORD)result)
        {
          v20 = *v9;
          *v9 = *(a2 - 1);
          *(a2 - 1) = v20;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9, v9 + 1, a2 - 1, (unsigned int (**)(_QWORD))a3);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9, v9 + 1, v9 + 2, a2 - 1, (unsigned int (**)(_QWORD))a3);
      case 5uLL:
        return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1, (unsigned int (**)(_QWORD))a3);
      default:
        if (v12 <= 191)
        {
          if ((a5 & 1) != 0)
            return std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)v9, a2, a3);
          else
            return std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)v9, a2, a3);
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(&v9[v13 >> 1], v9, a2 - 1, (unsigned int (**)(_QWORD))a3);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9, &v9[v13 >> 1], a2 - 1, (unsigned int (**)(_QWORD))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9 + 1, v15 - 1, a2 - 2, (unsigned int (**)(_QWORD))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9 + 2, &v9[v14 + 1], a2 - 3, (unsigned int (**)(_QWORD))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v15 - 1, v15, &v9[v14 + 1], (unsigned int (**)(_QWORD))a3);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (((*a3)(*(v9 - 1), *v9) & 1) == 0)
          {
            result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>(v9, a2, a3);
            v9 = (uint64_t *)result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>(v9, a2, a3);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9, v17, (unsigned int (**)(_QWORD))a3);
          v9 = v17 + 1;
          result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v17 + 1, a2, (unsigned int (**)(_QWORD))a3);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,false>(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        if (v9 != a2)
          return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,IIOTag **>((char *)v9, (char *)a2, a2, a3);
        return result;
    }
  }
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;

  if ((uint64_t *)result != a2)
  {
    v4 = (_QWORD *)result;
    v5 = (uint64_t *)(result + 8);
    if ((uint64_t *)(result + 8) != a2)
    {
      v7 = 0;
      v8 = (uint64_t *)result;
      do
      {
        v10 = *v8;
        v9 = v8[1];
        v8 = v5;
        result = (*a3)(v9, v10);
        if ((_DWORD)result)
        {
          v11 = *v8;
          v12 = v7;
          while (1)
          {
            *(_QWORD *)((char *)v4 + v12 + 8) = *(_QWORD *)((char *)v4 + v12);
            if (!v12)
              break;
            result = (*a3)(v11, *(_QWORD *)((char *)v4 + v12 - 8));
            v12 -= 8;
            if ((result & 1) == 0)
            {
              v13 = (_QWORD *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }
          v13 = v4;
LABEL_10:
          *v13 = v11;
        }
        v5 = v8 + 1;
        v7 += 8;
      }
      while (v8 + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(uint64_t result, _QWORD *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  _QWORD *v4;
  _QWORD *i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;

  if ((_QWORD *)result != a2)
  {
    v4 = (_QWORD *)result;
    for (i = (_QWORD *)(result + 8); v4 + 1 != a2; i = v4 + 1)
    {
      v8 = *v4;
      v7 = v4[1];
      v4 = i;
      result = (*a3)(v7, v8);
      if ((_DWORD)result)
      {
        v9 = *v4;
        v10 = v4;
        do
        {
          v11 = v10;
          v12 = *--v10;
          *v11 = v12;
          result = (*a3)(v9, *(v11 - 2));
        }
        while ((result & 1) != 0);
        *v10 = v9;
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned int (**a4)(_QWORD))
{
  char v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v8 = ((uint64_t (*)(_QWORD, _QWORD))*a4)(*a2, *a1);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a4)(*a3, *a2);
  if ((v8 & 1) == 0)
  {
    if (!(_DWORD)result)
      return result;
    v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    if (!((unsigned int (*)(_QWORD, _QWORD))*a4)(*a2, *a1))
      return 1;
    v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2;
  }
  v10 = *a1;
  if (!(_DWORD)result)
  {
    *a1 = *a2;
    *a2 = v10;
    if (!(*a4)(*a3))
      return 1;
    v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    return 2;
  }
  *a1 = *a3;
  *a3 = v10;
  return 1;
}

uint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t *v4;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = a2;
  v6 = *a1;
  if (((*a3)(*a1, *(a2 - 1)) & 1) != 0)
  {
    v7 = a1;
    do
    {
      v8 = v7[1];
      ++v7;
    }
    while (((*a3)(v6, v8) & 1) == 0);
  }
  else
  {
    v9 = a1 + 1;
    do
    {
      v7 = v9;
      if (v9 >= v4)
        break;
      ++v9;
    }
    while (!(*a3)(v6, *v7));
  }
  if (v7 < v4)
  {
    do
      v10 = *--v4;
    while (((*a3)(v6, v10) & 1) != 0);
  }
  while (v7 < v4)
  {
    v11 = *v7;
    *v7 = *v4;
    *v4 = v11;
    do
    {
      v12 = v7[1];
      ++v7;
    }
    while (!(*a3)(v6, v12));
    do
      v13 = *--v4;
    while (((*a3)(v6, v13) & 1) != 0);
  }
  if (v7 - 1 != a1)
    *a1 = *(v7 - 1);
  *(v7 - 1) = v6;
  return v7;
}

uint64_t *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v6 = 0;
  v7 = *a1;
  do
    v8 = (*a3)(a1[++v6], v7);
  while ((v8 & 1) != 0);
  v9 = &a1[v6];
  v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2)
        break;
      v12 = *--a2;
    }
    while (((*a3)(v12, v7) & 1) == 0);
  }
  else
  {
    do
      v11 = *--a2;
    while (!(*a3)(v11, v7));
  }
  if (v9 < a2)
  {
    v13 = a2;
    v14 = v9;
    do
    {
      v15 = *v14;
      *v14 = *v13;
      *v13 = v15;
      do
      {
        v16 = v14[1];
        ++v14;
      }
      while (((*a3)(v16, v7) & 1) != 0);
      do
        v17 = *--v13;
      while (!(*a3)(v17, v7));
    }
    while (v14 < v13);
    v10 = v14 - 1;
  }
  if (v10 != a1)
    *a1 = *v10;
  *v10 = v7;
  return v10;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(_QWORD *a1, _QWORD *a2, unsigned int (**a3)(_QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;

  v6 = a2 - a1;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*(a2 - 1), *a1))
      {
        v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      v9 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a3);
      v10 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*v10, *v9))
    {
      v13 = *v10;
      v14 = v11;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_QWORD *)((char *)a1 + v14 + 24) = *(_QWORD *)((char *)a1 + v14 + 16);
        if (v14 == -16)
          break;
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, _QWORD))*a3)(v13, *((_QWORD *)v15 + 1)) & 1) == 0)
        {
          v16 = (_QWORD *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v13;
      if (++v12 == 8)
        return v10 + 1 == a2;
    }
    v9 = v10;
    v11 += 8;
    if (++v10 == a2)
      return 1;
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unsigned int (**a5)(_QWORD))
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a2, a3, a5);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a4, *a3);
  if ((_DWORD)result)
  {
    v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a3, *a2);
    if ((_DWORD)result)
    {
      v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a2, *a1);
      if ((_DWORD)result)
      {
        v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, unsigned int (**a6)(_QWORD))
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a2, a3, a4, a6);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a5, *a4);
  if ((_DWORD)result)
  {
    v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a4, *a3);
    if ((_DWORD)result)
    {
      v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a3, *a2);
      if ((_DWORD)result)
      {
        v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a2, *a1);
        if ((_DWORD)result)
        {
          v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

uint64_t *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,IIOTag **>(char *a1, char *a2, uint64_t *a3, uint64_t (**a4)(uint64_t, uint64_t))
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;

  if (a1 != a2)
  {
    v8 = a2 - a1;
    v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[8 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)a1, (unsigned int (**)(_QWORD, _QWORD))a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != (char *)a3)
    {
      v14 = (uint64_t *)a2;
      do
      {
        if ((*a4)(*v14, *(_QWORD *)a1))
        {
          v15 = *v14;
          *v14 = *(_QWORD *)a1;
          *(_QWORD *)a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)a1, (unsigned int (**)(_QWORD, _QWORD))a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = (char *)a3;
    }
    if (v8 >= 9)
    {
      v16 = (unint64_t)v8 >> 3;
      v17 = a2 - 8;
      do
      {
        v18 = *(_QWORD *)a1;
        v19 = (char *)std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, (unsigned int (**)(_QWORD, _QWORD))a4, v16);
        if (v17 == v19)
        {
          *(_QWORD *)v19 = v18;
        }
        else
        {
          *(_QWORD *)v19 = *(_QWORD *)v17;
          *(_QWORD *)v17 = v18;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)a1, (uint64_t)(v19 + 8), a4, (v19 + 8 - a1) >> 3);
        }
        v17 -= 8;
      }
      while (v16-- > 2);
    }
    return (uint64_t *)v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(uint64_t result, unsigned int (**a2)(_QWORD, _QWORD), uint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;

  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      v10 = ((uint64_t)a4 - result) >> 2;
      v11 = v10 + 1;
      v12 = (_QWORD *)(result + 8 * (v10 + 1));
      v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(*v12, v12[1]))
      {
        ++v12;
        v11 = v13;
      }
      result = ((uint64_t (*)(_QWORD, _QWORD))*a2)(*v12, *v5);
      if ((result & 1) == 0)
      {
        v14 = *v5;
        do
        {
          v15 = v12;
          *v5 = *v12;
          if (v7 < v11)
            break;
          v16 = (2 * v11) | 1;
          v12 = (_QWORD *)(v6 + 8 * v16);
          if (2 * v11 + 2 < a3)
          {
            if ((*a2)(*v12, v12[1]))
            {
              ++v12;
              v16 = 2 * v11 + 2;
            }
          }
          result = ((uint64_t (*)(_QWORD, uint64_t))*a2)(*v12, v14);
          v5 = v15;
          v11 = v16;
        }
        while (!(_DWORD)result);
        *v15 = v14;
      }
    }
  }
  return result;
}

_QWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(_QWORD *a1, unsigned int (**a2)(_QWORD, _QWORD), uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = &a1[v6 + 1];
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    v9 = (uint64_t *)(a2 - 8);
    result = (*a3)(*v8, *(_QWORD *)(a2 - 8));
    if ((_DWORD)result)
    {
      v10 = *v9;
      do
      {
        v11 = v8;
        *v9 = *v8;
        if (!v7)
          break;
        v7 = (v7 - 1) >> 1;
        v8 = (uint64_t *)(v6 + 8 * v7);
        result = (*a3)(*v8, v10);
        v9 = v11;
      }
      while ((result & 1) != 0);
      *v11 = v10;
    }
  }
  return result;
}

void kd_roi_level_node::~kd_roi_level_node(kd_roi_level_node *this)
{
  int v2;
  uint64_t i;
  uint64_t v4;

  *(_QWORD *)this = &off_1E1BB1448;
  if (*((_BYTE *)this + 17))
    __assert_rtn("~kd_roi_level_node", "roi.cpp", 55, "!active");
  if (*((_QWORD *)this + 5))
  {
    v2 = *((_DWORD *)this + 7);
    if (v2 < 1)
      goto LABEL_9;
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD *)(*((_QWORD *)this + 5) + 8 * i);
      if (v4)
      {
        MEMORY[0x18D761C18](v4, 0x1000C8077774924);
        v2 = *((_DWORD *)this + 7);
      }
    }
    if (*((_QWORD *)this + 5))
LABEL_9:
      MEMORY[0x18D761C18]();
  }
  *(_QWORD *)this = off_1E1BAC530;
}

{
  kd_roi_level_node::~kd_roi_level_node(this);
  JUMPOUT(0x18D761C30);
}

void *kd_roi_level_node::pull(kd_roi_level_node *this, unsigned __int8 *__dst, int a3)
{
  void *result;
  int v7;
  int v8;
  int v9;
  int v10;

  if (!*((_BYTE *)this + 17) || *((_DWORD *)this + 5) != a3 || *((int *)this + 6) < 1)
    kd_roi_level_node::pull();
  while (!*((_DWORD *)this + 9))
    kd_roi_level::advance(*((kd_roi_level **)this + 1));
  result = memcpy(__dst, *(const void **)(*((_QWORD *)this + 5) + 8 * *((int *)this + 8)), a3);
  v7 = *((_DWORD *)this + 8);
  v8 = *((_DWORD *)this + 9) - 1;
  v9 = *((_DWORD *)this + 6);
  if (v7 + 1 == *((_DWORD *)this + 7))
    v10 = 0;
  else
    v10 = v7 + 1;
  *((_DWORD *)this + 8) = v10;
  *((_DWORD *)this + 9) = v8;
  *((_DWORD *)this + 6) = v9 - 1;
  return result;
}

_BYTE *kd_roi_level::advance(kd_roi_level *this)
{
  int v2;
  int v3;
  int v4;
  char *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  _BYTE *result;
  int v18;
  _BYTE *v19;
  char *v20;
  unsigned int v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  char v27;
  kd_roi_level_node *v28;
  char *v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  int v42;
  uint64_t v43;
  int v44;
  char v45;
  int v46;
  uint64_t v47;
  int v48;
  char v49;
  uint64_t v50;
  BOOL v52;
  kd_roi_level_node *v53;

  if (!*(_QWORD *)this)
    kd_roi_level::advance();
  v2 = *((_DWORD *)this + 12);
  v3 = *((_DWORD *)this + 14) + v2;
  v4 = *((_DWORD *)this + 16);
  if (v4 >= v3)
    kd_roi_level::advance();
  if (*((_BYTE *)this + 108))
  {
    v5 = (char *)this + 8 * (v4 & 1);
    v6 = *((_DWORD *)v5 + 19) + v4;
    v7 = *((_DWORD *)v5 + 23) + v4;
    if (v6 <= v2)
      v4 = *((_DWORD *)this + 12);
    else
      v4 = v6;
    if (v7 >= v3)
      v8 = v3 - 1;
    else
      v8 = v7;
    if (v8 - v4 + 1 > *((_DWORD *)this + 28))
      kd_roi_level::advance();
  }
  else
  {
    v8 = *((_DWORD *)this + 16);
  }
  v10 = *((_DWORD *)this + 17);
  v9 = *((_DWORD *)this + 18);
  if (v8 >= v9 + v10)
  {
    v11 = *((_DWORD *)this + 28);
    do
    {
      v12 = *((_DWORD *)this + 29) + v9;
      if (v12 < v11)
        v11 = 0;
      (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)this + 24))(*(_QWORD *)this, *(_QWORD *)(*((_QWORD *)this + 15) + 8 * (v12 - v11)), *((unsigned int *)this + 15));
      v9 = *((_DWORD *)this + 18);
      v11 = *((_DWORD *)this + 28);
      if (v9 == v11)
      {
        v13 = *((_DWORD *)this + 29) + 1;
        *((_DWORD *)this + 29) = v13;
        v10 = *((_DWORD *)this + 17) + 1;
        *((_DWORD *)this + 17) = v10;
        if (v13 == v9)
          *((_DWORD *)this + 29) = 0;
      }
      else
      {
        *((_DWORD *)this + 18) = ++v9;
        v10 = *((_DWORD *)this + 17);
      }
    }
    while (v8 >= v9 + v10);
  }
  if (v4 - v10 < 0)
    kd_roi_level::advance();
  v14 = *((_DWORD *)this + 29) + v4 - v10;
  if (v14 >= *((_DWORD *)this + 28))
    v15 = *((_DWORD *)this + 28);
  else
    v15 = 0;
  v16 = v14 - v15;
  result = memcpy(*((void **)this + 16), *(const void **)(*((_QWORD *)this + 15) + 8 * (v14 - v15)), *((int *)this + 15));
  if (v4 < v8)
  {
    do
    {
      if (v16 + 1 == *((_DWORD *)this + 28))
        v16 = 0;
      else
        ++v16;
      v18 = *((_DWORD *)this + 15);
      if (v18 >= 1)
      {
        v19 = (_BYTE *)*((_QWORD *)this + 16);
        v20 = *(char **)(*((_QWORD *)this + 15) + 8 * v16);
        v21 = v18 + 1;
        do
        {
          v22 = *v20++;
          *v19++ |= v22;
          --v21;
        }
        while (v21 > 1);
      }
      ++v4;
    }
    while (v4 != v8);
  }
  if (*((_BYTE *)this + 108))
    v23 = 2 * (*((_DWORD *)this + 16) & 1);
  else
    v23 = 0;
  if (*((_BYTE *)this + 109))
  {
    v24 = 0;
    v25 = v23;
    v26 = 1;
    do
    {
      v27 = v26;
      if (!*((_BYTE *)this + v25 + 40))
      {
        v28 = (kd_roi_level_node *)*((_QWORD *)this + v25 + 1);
        if (!v28)
          kd_roi_level::advance();
        result = (_BYTE *)kd_roi_level_node::advance(v28);
        if (result)
        {
          v29 = (char *)this + 8 * v24;
          v30 = *((int *)v29 + 20);
          v31 = *((_DWORD *)v29 + 24);
          v32 = *((_DWORD *)this + 13);
          v33 = ((_BYTE)v32 + (_BYTE)v24) & 1;
          LODWORD(v34) = *((_DWORD *)this + 15) + ~(_DWORD)v33;
          v35 = ((int)v34 >> 1) + 1;
          v36 = *((_QWORD *)this + 16);
          v37 = v36 + v33;
          if ((v34 & 0x80000000) != 0 || (((_DWORD)v33 + (_DWORD)v30) & 0x80000000) == 0)
          {
            v44 = ((int)v34 >> 1) + 1;
          }
          else
          {
            v38 = v23 ^ v32;
            v39 = v38 << 63 >> 63;
            v40 = v36 + v33 - (v38 & 1);
            do
            {
              v41 = 0;
              if (v31 >= (int)v34)
                v42 = v34;
              else
                v42 = v31;
              if (v42 >= -(int)v33)
              {
                v43 = 0;
                v41 = 0;
                do
                  v41 |= *(_BYTE *)(v40 + v43++);
                while (v39 + v43 - 1 < v42);
              }
              *result++ = v41;
              v44 = v35 - 1;
              LODWORD(v34) = v34 - 2;
              v37 += 2;
              if (v35 <= 1)
                break;
              LODWORD(v33) = v33 + 2;
              v39 -= 2;
              --v35;
            }
            while ((_DWORD)v33 + (_DWORD)v30 < 0);
          }
          if (v44 < 1 || (int)v34 < v31)
          {
            v48 = v44;
          }
          else
          {
            do
            {
              if ((int)v30 <= v31)
              {
                v45 = 0;
                v46 = v31 - v30 + 1;
                v47 = v30;
                do
                {
                  v45 |= *(_BYTE *)(v37 + v47++);
                  --v46;
                }
                while (v46);
              }
              else
              {
                v45 = 0;
              }
              *result++ = v45;
              v48 = v44 - 1;
              LODWORD(v34) = v34 - 2;
              v37 += 2;
              if (v44 <= 1)
                break;
              --v44;
            }
            while ((int)v34 >= v31);
          }
          if (v48 >= 1)
          {
            v34 = (int)v34;
            do
            {
              if (v34 >= v30)
              {
                v49 = 0;
                v50 = v30;
                do
                  v49 |= *(_BYTE *)(v37 + v50);
                while (v50++ < v34);
              }
              else
              {
                v49 = 0;
              }
              *result++ = v49;
              v34 -= 2;
              v37 += 2;
              v52 = __OFSUB__(v48--, 1);
            }
            while (!((v48 < 0) ^ v52 | (v48 == 0)));
          }
        }
      }
      v26 = 0;
      ++v25;
      ++v23;
      v24 = 1;
    }
    while ((v27 & 1) != 0);
  }
  else
  {
    v53 = (kd_roi_level_node *)*((_QWORD *)this + v23 + 1);
    if (!v53)
      kd_roi_level::advance();
    result = (_BYTE *)kd_roi_level_node::advance(v53);
    if (result)
      result = memcpy(result, *((const void **)this + 16), *((int *)this + 15));
  }
  ++*((_DWORD *)this + 16);
  if (*((_DWORD *)this + 11) == 4)
  {
    result = (_BYTE *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 16))(*(_QWORD *)this);
    *(_QWORD *)this = 0;
  }
  return result;
}

uint64_t kd_roi_level_node::advance(kd_roi_level_node *this)
{
  int v2;
  int v3;
  void *v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t result;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;

  if (*((_BYTE *)this + 17))
  {
    v2 = *((_DWORD *)this + 9);
    if (*((_DWORD *)this + 6) <= v2)
      kd_roi_level_node::advance();
    v3 = *((_DWORD *)this + 7);
    if (v2 == v3)
    {
      v3 = v2 + 2;
      v4 = (void *)operator new[]();
      bzero(v4, 8 * (v2 + 2));
      v6 = *((_DWORD *)this + 7);
      v5 = *((_DWORD *)this + 8);
      if (v6 < 1)
      {
        v6 = 0;
      }
      else
      {
        v7 = *((_QWORD *)this + 5);
        v8 = *((_DWORD *)this + 7);
        v9 = *((_DWORD *)this + 8);
        do
        {
          if (v9 == v6)
            v9 = 0;
          if (v5 == v3)
            v5 = 0;
          *((_QWORD *)v4 + v5++) = *(_QWORD *)(v7 + 8 * v9++);
          --v8;
        }
        while (v8);
      }
      *((_QWORD *)this + 5) = v4;
      *((_DWORD *)this + 7) = v3;
      if (v6 < v3)
      {
        v11 = v2 - v6 + 2;
        do
        {
          if (v5 == v3)
            v12 = 0;
          else
            v12 = v5;
          *((_QWORD *)v4 + v12) = operator new[]();
          v5 = v12 + 1;
          --v11;
        }
        while (v11);
        v3 = *((_DWORD *)this + 7);
      }
    }
    v13 = *((_DWORD *)this + 9);
    v14 = *((_DWORD *)this + 8) + v13;
    if (v14 >= v3)
      v15 = v3;
    else
      v15 = 0;
    *((_DWORD *)this + 9) = v13 + 1;
    return *(_QWORD *)(*((_QWORD *)this + 5) + 8 * (v14 - v15));
  }
  else
  {
    result = 0;
    *((_BYTE *)this + 16) = 0;
  }
  return result;
}

_DWORD *kd_roi_level_node::release(kd_roi_level_node *this)
{
  *((_WORD *)this + 8) = 0;
  return kd_roi_level::notify_release(*((_DWORD **)this + 1), this);
}

_DWORD *kd_roi_level::notify_release(_DWORD *this, kd_roi_level_node *a2)
{
  _QWORD *v2;
  uint64_t v3;
  char *v4;
  int v5;

  v2 = this;
  v3 = 0;
  while (*(kd_roi_level_node **)&this[2 * v3 + 2] != a2)
  {
    if (++v3 == 4)
      goto LABEL_9;
  }
  v4 = (char *)this + v3;
  if (v4[40])
LABEL_9:
    kd_roi_level::notify_release();
  v4[40] = 1;
  v5 = this[11] + 1;
  this[11] = v5;
  if (v5 == 4)
  {
    this = (_DWORD *)(*(uint64_t (**)(void))(**(_QWORD **)this + 16))();
    *v2 = 0;
  }
  return this;
}

uint64_t kdu_roi_level::create(uint64_t *a1, int32x4_t *a2, uint64_t a3)
{
  uint64_t v6;

  v6 = operator new();
  *(_QWORD *)(v6 + 48) = 0;
  *(_QWORD *)(v6 + 56) = 0;
  *(_DWORD *)(v6 + 112) = 0;
  *(_OWORD *)v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_QWORD *)(v6 + 32) = 0;
  *(_OWORD *)(v6 + 76) = 0u;
  *(_OWORD *)(v6 + 92) = 0u;
  *(_QWORD *)(v6 + 120) = 0;
  *(_QWORD *)(v6 + 128) = 0;
  *a1 = v6;
  return kd_roi_level::init(v6, a2, a3);
}

void sub_187EE5EFC(void *a1)
{
  kd_roi_level **v1;

  __cxa_begin_catch(a1);
  if (*v1)
    kdu_roi_level::create(*v1);
  *v1 = 0;
  __cxa_rethrow();
}

void sub_187EE5F18(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t kd_roi_level::init(uint64_t a1, int32x4_t *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  __int32 v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  char v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  unsigned int v23;
  BOOL v24[2];
  float v25;
  int32x4_t v26;
  int32x4_t *v27;
  int32x4_t *v28;

  v28 = a2;
  *(_QWORD *)a1 = a3;
  kdu_node::get_dims(&v28, (int32x4_t *)(a1 + 48));
  v4 = 0;
  *(_DWORD *)(a1 + 44) = 0;
  do
  {
    v27 = 0;
    v5 = kdu_node::access_child((kdu_node *)&v28, v4);
    v27 = (int32x4_t *)v5;
    if (v5)
    {
      v26 = 0uLL;
      kdu_node::get_dims(&v27, &v26);
      v5 = operator new();
      v6 = 0;
      v7 = v26.i32[2];
      v8 = HIDWORD(v26.i64[1]);
      *(_QWORD *)v5 = &off_1E1BB1448;
      *(_QWORD *)(v5 + 8) = a1;
      *(_WORD *)(v5 + 16) = 1;
      *(_DWORD *)(v5 + 20) = v8;
      *(_DWORD *)(v5 + 24) = v7;
      *(_QWORD *)(v5 + 36) = 0;
      *(_QWORD *)(v5 + 28) = 0;
      *(_DWORD *)(v5 + 44) = 0;
    }
    else
    {
      ++*(_DWORD *)(a1 + 44);
      v6 = 1;
    }
    *(_QWORD *)(a1 + 8 * v4 + 8) = v5;
    *(_BYTE *)(a1 + v4++ + 40) = v6;
  }
  while (v4 != 4);
  v10 = *(_QWORD *)(a1 + 16);
  v9 = *(_QWORD *)(a1 + 24);
  *(_BYTE *)(a1 + 109) = v10 != 0;
  v11 = v9 != 0;
  *(_BYTE *)(a1 + 108) = v11;
  v25 = 0.0;
  v26.i32[0] = 0;
  LODWORD(v27) = 0;
  *(_WORD *)v24 = 0;
  if (v10)
  {
    kdu_node::get_kernel_info((kdu_node *)&v28, v26.i32, (float *)&v27, &v25, &v24[1], v24, (int *)(a1 + 80), (int *)(a1 + 96), (int *)(a1 + 88), (int *)(a1 + 104), 0);
    v11 = *(unsigned __int8 *)(a1 + 108);
  }
  v12 = 1;
  if (v11)
  {
    kdu_node::get_kernel_info((kdu_node *)&v28, v26.i32, (float *)&v27, &v25, &v24[1], v24, (int *)(a1 + 76), (int *)(a1 + 92), (int *)(a1 + 84), (int *)(a1 + 100), 1);
    v13 = 0;
    v14 = 0;
    do
    {
      v15 = v12;
      v16 = a1 + 8 * v13;
      if (v14 <= *(_DWORD *)(v16 + 92))
        v14 = *(_DWORD *)(v16 + 92);
      v17 = *(_DWORD *)(v16 + 76);
      if (v14 <= -v17)
        v14 = -v17;
      v13 = 1;
      LOBYTE(v12) = 0;
    }
    while ((v15 & 1) != 0);
    v12 = (2 * v14) | 1;
  }
  *(_DWORD *)(a1 + 112) = v12;
  *(_QWORD *)(a1 + 120) = operator new[]();
  v18 = *(unsigned int *)(a1 + 112);
  if ((int)v18 >= 1)
  {
    v19 = 0;
    v20 = 8 * v18;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 120) + v19) = 0;
      v19 += 8;
    }
    while (v20 != v19);
    v21 = 0;
    do
      *(_QWORD *)(*(_QWORD *)(a1 + 120) + 8 * v21++) = operator new[]();
    while (v21 < *(int *)(a1 + 112));
  }
  result = operator new[]();
  *(_QWORD *)(a1 + 128) = result;
  *(_DWORD *)(a1 + 116) = 0;
  v23 = *(_DWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 68) = v23;
  *(_DWORD *)(a1 + 64) = v23;
  return result;
}

kd_roi_level *kdu_roi_level::destroy(kd_roi_level **this)
{
  kd_roi_level *result;

  result = *this;
  if (result)
  {
    kd_roi_level::~kd_roi_level(result);
    result = (kd_roi_level *)MEMORY[0x18D761C30]();
  }
  *this = 0;
  return result;
}

uint64_t kdu_roi_level::acquire_node(kdu_roi_level *this, unsigned int a2)
{
  uint64_t result;

  if (a2 >= 4)
    kdu_roi_level::acquire_node();
  result = *(_QWORD *)(*(_QWORD *)this + 8 * a2 + 8);
  if (result)
  {
    if (!*(_BYTE *)(result + 16))
      kdu_roi_level::acquire_node();
    *(_WORD *)(result + 16) = 256;
  }
  return result;
}

void kd_roi_level::~kd_roi_level(kd_roi_level *this)
{
  uint64_t i;
  uint64_t v3;
  int v4;
  uint64_t j;
  uint64_t v6;
  uint64_t v7;

  for (i = 8; i != 40; i += 8)
  {
    v3 = *(_QWORD *)((char *)this + i);
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  }
  if (*((_QWORD *)this + 15))
  {
    v4 = *((_DWORD *)this + 28);
    if (v4 < 1)
      goto LABEL_12;
    for (j = 0; j < v4; ++j)
    {
      v6 = *(_QWORD *)(*((_QWORD *)this + 15) + 8 * j);
      if (v6)
      {
        MEMORY[0x18D761C18](v6, 0x1000C8077774924);
        v4 = *((_DWORD *)this + 28);
      }
    }
    if (*((_QWORD *)this + 15))
LABEL_12:
      MEMORY[0x18D761C18]();
  }
  v7 = *((_QWORD *)this + 16);
  if (v7)
    MEMORY[0x18D761C18](v7, 0x1000C8077774924);
  if (*(_QWORD *)this)
    (*(void (**)(_QWORD))(**(_QWORD **)this + 16))(*(_QWORD *)this);
}

uint64_t kd_tile::kd_tile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  _OWORD v13[2];
  uint64_t v14;

  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  v10 = a1 + 104;
  *(_DWORD *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_OWORD *)(a1 + 228) = 0u;
  *(_QWORD *)(a1 + 244) = 0;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 24) = a3;
  if (*(_QWORD *)(a3 + 16))
  {
    v14 = 0;
    memset(v13, 0, sizeof(v13));
    kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v13[0] + 16))(v13, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v13[0] + 16))(v13, "tref->tile == NULL");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v13[0] + 16))(v13, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v13);
  }
  *(_QWORD *)(a1 + 12) = a4;
  *(_DWORD *)(a1 + 8) = HIDWORD(a4) + *(_DWORD *)(a2 + 224) * a4;
  *(_BYTE *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v11 = *(_QWORD *)(a2 + 8);
  if (v11 && ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v11 + 552) + 24))(*(_QWORD *)(v11 + 552)) & 2) != 0)
    kd_precinct_pointer_server::initialize(v10, *(kd_buf_server **)(a2 + 48));
  *(_QWORD *)(a1 + 212) = a5;
  *(_QWORD *)(a1 + 220) = a6;
  *(_QWORD *)(a1 + 236) = 0;
  *(_BYTE *)(a1 + 328) = 0;
  *(_BYTE *)(a1 + 287) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_BYTE *)(a1 + 297) = 0;
  *(_QWORD *)(a1 + 289) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_QWORD *)(a1 + 308) = 0;
  *(_QWORD *)(a1 + 300) = 0;
  return a1;
}

void sub_187EE6494(_Unwind_Exception *a1)
{
  uint64_t *v1;

  kd_precinct_pointer_server::disable(v1);
  _Unwind_Resume(a1);
}

uint64_t kd_precinct_pointer_server::initialize(uint64_t this, kd_buf_server *a2)
{
  if (*(_QWORD *)this)
    kd_precinct_pointer_server::initialize();
  *(_QWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_WORD *)(this + 60) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_QWORD *)this = a2;
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

void kd_tile::~kd_tile(kd_tile *this)
{
  kd_pp_markers *v2;
  uint64_t v3;
  kdu_message *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  kd_mct_stage *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int i;
  kdu_params *v16;
  uint64_t v17;
  char v18[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (*(kd_tile **)(*(_QWORD *)this + 440) == this)
  {
    *(_QWORD *)&v20 = 0;
    *(_OWORD *)v18 = 0u;
    v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "Assert ");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "this != codestream->active_tile");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  if (*((_BYTE *)this + 288))
    kd_tile::remove_from_in_progress_list((uint64_t *)this);
  v2 = (kd_pp_markers *)*((_QWORD *)this + 10);
  if (v2)
  {
    kd_pp_markers::~kd_pp_markers(v2);
    MEMORY[0x18D761C30]();
  }
  v3 = *((_QWORD *)this + 11);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  if (*((_QWORD *)this + 3))
  {
    v4 = **(kdu_message ***)this;
    if (!v4 || *((_BYTE *)this + 287))
      goto LABEL_17;
    (*(void (**)(_QWORD, const char *))(*(_QWORD *)v4 + 16))(**(_QWORD **)this, "\n>> New attributes for tile ");
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    *(_OWORD *)v18 = 0u;
    if (*((_BYTE *)v4 + 8))
      sprintf(v18, "%x");
    else
      sprintf(v18, "%d");
    (*(void (**)(kdu_message *, char *))(*(_QWORD *)v4 + 16))(v4, v18);
    (*(void (**)(kdu_message *, const char *))(*(_QWORD *)v4 + 16))(v4, ":\n");
    kdu_params::textualize_attributes(*(_QWORD *)(*(_QWORD *)this + 24), v4, *((_DWORD *)this + 2), *((_DWORD *)this + 2), 1);
    (*(void (**)(kdu_message *, _QWORD))(*(_QWORD *)v4 + 32))(v4, 0);
    if (*((_QWORD *)this + 3))
    {
LABEL_17:
      if (!*((_BYTE *)this + 287) && !*((_BYTE *)this + 290))
      {
        for (i = 1; ; ++i)
        {
          v16 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(_QWORD *)this + 24), i);
          if (!v16)
            break;
          v17 = kdu_params::access_unique(v16, *((_DWORD *)this + 2), -1, 0);
          if (v17)
            (*(void (**)(uint64_t))(*(_QWORD *)v17 + 16))(v17);
        }
      }
    }
  }
  v5 = *((_QWORD *)this + 12);
  if (v5)
    MEMORY[0x18D761C30](v5, 0x1020C40539952E0);
  v6 = *((_QWORD *)this + 34);
  if (v6)
  {
    v7 = v6 - 16;
    v8 = *(_QWORD *)(v6 - 8);
    if (v8)
    {
      v9 = v6 - 224;
      v10 = 224 * v8;
      do
      {
        kd_tile_comp::~kd_tile_comp((kd_tile_comp *)(v9 + v10));
        v10 -= 224;
      }
      while (v10);
    }
    MEMORY[0x18D761C18](v7, 0x10A0C802A3299D9);
  }
  while (1)
  {
    v11 = (kd_mct_stage *)*((_QWORD *)this + 32);
    *((_QWORD *)this + 33) = v11;
    if (!v11)
      break;
    *((_QWORD *)this + 32) = *((_QWORD *)v11 + 7);
    kd_mct_stage::~kd_mct_stage(v11);
    MEMORY[0x18D761C30]();
  }
  v12 = *((_QWORD *)this + 3);
  if (v12 && *(kd_tile **)(v12 + 16) != this)
  {
    *(_QWORD *)&v20 = 0;
    *(_OWORD *)v18 = 0u;
    v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "Assert ");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "tile_ref->tile == this");
    (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  if (*((_BYTE *)this + 290))
  {
    if (!*((_QWORD *)this + 3))
    {
      *(_QWORD *)&v20 = 0;
      *(_OWORD *)v18 = 0u;
      v19 = 0u;
      kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "Assert ");
      (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "tile_ref != NULL");
      (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v18);
    }
    kd_tile::withdraw_from_unloadable_list((uint64_t *)this);
    v13 = 0;
    v14 = *((_QWORD *)this + 3);
  }
  else
  {
    v14 = *((_QWORD *)this + 3);
    if (*((_BYTE *)this + 287))
    {
      if (!v14)
      {
        *(_QWORD *)&v20 = 0;
        *(_OWORD *)v18 = 0u;
        v19 = 0u;
        kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "Assert ");
        (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, "tile_ref != NULL");
        (*(void (**)(char *, const char *))(*(_QWORD *)v18 + 16))(v18, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v18);
      }
      v13 = 0;
    }
    else
    {
      if (!v14)
        goto LABEL_35;
      v13 = -1;
    }
  }
  *(_QWORD *)(v14 + 16) = v13;
  kd_buf_server::augment_structure_bytes(*(_QWORD *)(*(_QWORD *)this + 48), -*((_DWORD *)this + 70));
LABEL_35:
  kd_precinct_pointer_server::disable((uint64_t *)this + 13);
}

void sub_187EE6998(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

uint64_t *kd_tile::remove_from_in_progress_list(uint64_t *this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  if (*((_BYTE *)this + 288))
  {
    v1 = *this;
    v2 = *(_DWORD *)(*this + 360);
    if (v2 <= 0)
    {
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "Assert ");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "codestream->num_incomplete_tiles > 0");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    *(_DWORD *)(v1 + 360) = v2 - 1;
    v3 = this[6];
    if (v3)
    {
      *(_QWORD *)(v3 + 40) = this[5];
      v4 = this[5];
      if (v4)
      {
LABEL_6:
        *(_QWORD *)(v4 + 48) = this[6];
LABEL_13:
        *((_BYTE *)this + 288) = 0;
        this[5] = 0;
        this[6] = 0;
        return this;
      }
    }
    else
    {
      if (*(uint64_t **)(v1 + 336) != this)
      {
        v7 = 0;
        v5 = 0u;
        v6 = 0u;
        kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "Assert ");
        (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "this == codestream->tiles_in_progress_head");
        (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v5);
      }
      v4 = this[5];
      *(_QWORD *)(v1 + 336) = v4;
      if (v4)
        goto LABEL_6;
    }
    if (*(uint64_t **)(v1 + 344) != this)
    {
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "Assert ");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "this == codestream->tiles_in_progress_tail");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    *(_QWORD *)(v1 + 344) = this[6];
    goto LABEL_13;
  }
  return this;
}

void sub_187EE6BA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EE6BB0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

_BYTE *kdu_message::operator<<(_BYTE *a1)
{
  char v3[16];
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = 0u;
  v7 = 0u;
  v4 = 0u;
  v5 = 0u;
  *(_OWORD *)v3 = 0u;
  if (a1[8])
    sprintf(v3, "%x");
  else
    sprintf(v3, "%d");
  (*(void (**)(_BYTE *, char *))(*(_QWORD *)a1 + 16))(a1, v3);
  return a1;
}

uint64_t *kd_tile::withdraw_from_unloadable_list(uint64_t *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  int v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  if (!*((_BYTE *)this + 290))
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "Assert ");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "is_unloadable");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  v1 = this[8];
  if (v1)
  {
    *(_QWORD *)(v1 + 56) = this[7];
    v2 = this[7];
    if (v2)
    {
LABEL_5:
      *(_QWORD *)(v2 + 64) = this[8];
      v3 = *this;
      goto LABEL_12;
    }
  }
  else
  {
    if (*(uint64_t **)(*this + 480) != this)
    {
      v8 = 0;
      v6 = 0u;
      v7 = 0u;
      kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "Assert ");
      (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "codestream->unloadable_tiles_head == this");
      (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v6);
    }
    v2 = this[7];
    *(_QWORD *)(*this + 480) = v2;
    if (v2)
      goto LABEL_5;
  }
  v3 = *this;
  if (*(uint64_t **)(*this + 488) != this)
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "Assert ");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "codestream->unloadable_tiles_tail == this");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  *(_QWORD *)(v3 + 488) = this[8];
LABEL_12:
  v4 = this + 7;
  if (*(uint64_t **)(v3 + 496) == this)
    *(_QWORD *)(v3 + 496) = *v4;
  *v4 = 0;
  this[8] = 0;
  v5 = *(_DWORD *)(v3 + 504);
  *(_DWORD *)(v3 + 504) = v5 - 1;
  if (v5 <= 0)
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "Assert ");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "codestream->num_unloadable_tiles >= 0");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  *((_BYTE *)this + 290) = 0;
  return this;
}

void sub_187EE6EF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EE6F00()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_buf_server::augment_structure_bytes(uint64_t this, int a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 40) + a2;
  *(_QWORD *)(this + 40) = v2;
  if (v2 < 0)
    kd_buf_server::augment_structure_bytes();
  if (v2 > *(_QWORD *)(this + 48))
    *(_QWORD *)(this + 48) = v2;
  return this;
}

uint64_t kd_tile::release(kd_tile *this)
{
  uint64_t result;
  kd_pp_markers *v3;
  uint64_t v4;
  uint64_t v5;
  kd_tile *v6;
  int v7;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  kdu_message *v23;
  kdu_params *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v30[16];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 3) || *(kd_tile **)(*(_QWORD *)this + 440) == this)
  {
    *(_QWORD *)&v32 = 0;
    *(_OWORD *)v30 = 0u;
    v31 = 0u;
    kdu_error::kdu_error((kdu_error *)v30, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v30 + 16))(v30, "Assert ");
    (*(void (**)(char *, const char *))(*(_QWORD *)v30 + 16))(v30, "(tile_ref != NULL) && (this != codestream->active_tile)");
    (*(void (**)(char *, const char *))(*(_QWORD *)v30 + 16))(v30, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v30);
  }
  if (*(_QWORD *)(*(_QWORD *)this + 8) && !*((_BYTE *)this + 287) && *((_BYTE *)this + 184))
  {
    *((_QWORD *)this + 4) = 0;
    v3 = (kd_pp_markers *)*((_QWORD *)this + 10);
    if (v3)
    {
      kd_pp_markers::~kd_pp_markers(v3);
      MEMORY[0x18D761C30]();
      *((_QWORD *)this + 10) = 0;
    }
    v4 = *((_QWORD *)this + 11);
    if (v4)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
      *((_QWORD *)this + 11) = 0;
    }
    v5 = *((_QWORD *)this + 12);
    if (v5)
    {
      MEMORY[0x18D761C30](v5, 0x1020C40539952E0);
      *((_QWORD *)this + 12) = 0;
    }
    kd_precinct_pointer_server::disable((uint64_t *)this + 13);
    v6 = this;
    v7 = *((_DWORD *)this + 47);
    if (v7 >= 1)
    {
      for (i = 0; i < v7; ++i)
      {
        v9 = *((_QWORD *)v6 + 34);
        v10 = v9 + 224 * i;
        v13 = *(_DWORD *)(v10 + 68);
        v12 = (int *)(v10 + 68);
        v11 = v13;
        if ((v13 & 0x80000000) == 0)
        {
          v14 = 0;
          v15 = (_QWORD *)(v9 + 224 * i + 176);
          do
          {
            if (*(_DWORD *)(*v15 + 704 * v14 + 192) * *(_DWORD *)(*v15 + 704 * v14 + 196) >= 1)
            {
              v16 = 0;
              v17 = (uint64_t *)(*v15 + 704 * v14 + 232);
              v18 = 8 * (*(_DWORD *)(*v15 + 704 * v14 + 192) * *(_DWORD *)(*v15 + 704 * v14 + 196));
              do
              {
                v19 = *v17;
                v20 = *(_QWORD *)(*v17 + v16);
                if (v20)
                  v21 = (*(_QWORD *)(*v17 + v16) & 1) == 0;
                else
                  v21 = 0;
                if (v21)
                {
                  *(_QWORD *)(v20 + 8) = 0;
                  kd_precinct::closing((unsigned __int8 **)v20);
                  kd_precinct_size_class::release(*(kd_precinct_size_class **)(v20 + 72), (kd_precinct *)v20);
                }
                *(_QWORD *)(v19 + v16) = 0;
                v16 += 8;
              }
              while (v18 != v16);
              v11 = *v12;
            }
          }
          while (v14++ < v11);
          v6 = this;
          v7 = *((_DWORD *)this + 47);
        }
      }
    }
    v23 = **(kdu_message ***)v6;
    if (v23)
    {
      if (*((_BYTE *)v6 + 287))
        goto LABEL_45;
      (*(void (**)(_QWORD, const char *))(*(_QWORD *)v23 + 16))(**(_QWORD **)v6, "\n>> New attributes for tile ");
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      *(_OWORD *)v30 = 0u;
      if (*((_BYTE *)v23 + 8))
        sprintf(v30, "%x");
      else
        sprintf(v30, "%d");
      (*(void (**)(kdu_message *, char *))(*(_QWORD *)v23 + 16))(v23, v30);
      (*(void (**)(kdu_message *, const char *))(*(_QWORD *)v23 + 16))(v23, ":\n");
      kdu_params::textualize_attributes(*(_QWORD *)(*(_QWORD *)this + 24), v23, *((_DWORD *)this + 2), *((_DWORD *)this + 2), 1);
      (*(void (**)(kdu_message *, _QWORD))(*(_QWORD *)v23 + 32))(v23, 0);
      v6 = this;
    }
    if (!*((_BYTE *)v6 + 287) && !*((_BYTE *)v6 + 290))
    {
      v24 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(_QWORD *)v6 + 24), 1);
      v6 = this;
      if (v24)
      {
        v25 = 2;
        do
        {
          v26 = kdu_params::access_unique(v24, *((_DWORD *)v6 + 2), -1, 0);
          if (v26)
            (*(void (**)(uint64_t))(*(_QWORD *)v26 + 16))(v26);
          v24 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(_QWORD *)this + 24), v25++);
          v6 = this;
        }
        while (v24);
      }
    }
LABEL_45:
    if (*(kd_tile **)(*((_QWORD *)v6 + 3) + 16) != v6)
    {
      *(_QWORD *)&v32 = 0;
      *(_OWORD *)v30 = 0u;
      v31 = 0u;
      kdu_error::kdu_error((kdu_error *)v30, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v30 + 16))(v30, "Assert ");
      (*(void (**)(char *, const char *))(*(_QWORD *)v30 + 16))(v30, "tile_ref->tile == this");
      (*(void (**)(char *, const char *))(*(_QWORD *)v30 + 16))(v30, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v30);
    }
    if (*((_BYTE *)v6 + 290))
    {
      kd_tile::withdraw_from_unloadable_list((uint64_t *)v6);
      v6 = this;
      v27 = *((_QWORD *)this + 3);
    }
    else
    {
      v27 = *((_QWORD *)v6 + 3);
      if (!*((_BYTE *)v6 + 287))
      {
        *(_QWORD *)(v27 + 16) = -1;
        goto LABEL_51;
      }
    }
    *(_QWORD *)(v27 + 16) = 0;
LABEL_51:
    result = kd_buf_server::augment_structure_bytes(*(_QWORD *)(*(_QWORD *)v6 + 48), -*((_DWORD *)v6 + 70));
    *((_DWORD *)this + 70) = 0;
    *((_QWORD *)this + 3) = 0;
    *((_DWORD *)this + 2) = -1;
    v28 = *(_QWORD *)this;
    *((_QWORD *)this + 9) = *(_QWORD *)(*(_QWORD *)this + 512);
    *(_QWORD *)(v28 + 512) = this;
    return result;
  }
  kd_tile::~kd_tile(this);
  return MEMORY[0x18D761C30]();
}

void sub_187EE740C(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EE7418(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t kd_tile::initialize(kd_tile *this)
{
  kd_tile *v1;
  uint64_t v2;
  kdu_params *v3;
  kdu_params *v4;
  kdu_params *v5;
  kdu_params *v6;
  kdu_params *v7;
  int v8;
  uint64_t v9;
  char v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v18;
  int64_t v19;
  int64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  unsigned int v35;
  kdu_params *v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  _OWORD *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned __int8 v58;
  uint64_t v59;
  int v60;
  int v61;
  int v62;
  int v64;
  uint64_t v65;
  int v66;
  unsigned int v67;
  int v68;
  int v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char v87;
  uint64_t v88;
  _BYTE *v89;
  char v90;
  int v91;
  float v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  unsigned int v99;
  uint64_t v100;
  int v101;
  float v102;
  int v103;
  int v104;
  float v105;
  uint64_t v106;
  uint64_t v107;
  float v108;
  char v109;
  uint64_t v110;
  uint64_t v111;
  char v112;
  uint64_t v113;
  float *v114;
  float v115;
  uint64_t v116;
  __int16 v117;
  float energy_gain;
  unsigned int v119;
  float v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  int *v124;
  unsigned int v125;
  char v126;
  int v127;
  uint64_t v128;
  int v129;
  int *v130;
  int v131;
  int v132;
  int v133;
  uint64_t v134;
  int *v135;
  __int16 v136;
  unint64_t partition_indices;
  uint64_t v138;
  _DWORD *v139;
  _DWORD *v140;
  int v141;
  int v142;
  uint64_t v143;
  int v144;
  int v145;
  int v146;
  int v147;
  unint64_t v148;
  uint64_t v149;
  int v150;
  int v151;
  int v152;
  int v153;
  uint64_t v154;
  uint64_t result;
  _DWORD *exception;
  kdu_params *v157;
  kdu_params *v158;
  kdu_params *v159;
  unint64_t v160;
  char v161;
  uint64_t v162;
  int *v163;
  int v164;
  unsigned __int8 *v165;
  kdu_params *v166;
  unsigned __int8 *v167;
  unsigned __int8 *v168;
  int *v169;
  _DWORD *v170;
  uint64_t *v171;
  _BYTE *v172;
  kd_tile *v173;
  _QWORD *v174;
  kd_resolution *v175;
  int v176;
  kdu_params *v177;
  _OWORD *v178;
  uint64_t v179;
  kdu_params *v180;
  int v181;
  int *v182;
  uint64_t v183;
  _BYTE *v184;
  float v185;
  int v186;
  int v187;
  float v188;
  float v189;
  int v190;
  BOOL v191[16];
  __int128 v192;
  uint64_t v193;
  int v194[4];
  __int128 v195;
  uint64_t v196;
  uint64_t v197;
  BOOL v198[10];

  v1 = this;
  if (*((_BYTE *)this + 293))
  {
    v196 = 0;
    *(_OWORD *)v194 = 0u;
    v195 = 0u;
    kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Assert ");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "!needs_reinit");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v194);
  }
  v2 = *(_QWORD *)this;
  *((_DWORD *)this + 47) = *(_DWORD *)(*(_QWORD *)this + 168);
  *(_QWORD *)((char *)this + 300) = 0;
  if (*(_QWORD *)(v2 + 8))
  {
    if (!*((_BYTE *)this + 292))
    {
      *((_QWORD *)this + 4) = **((_QWORD **)this + 3);
      if ((kd_tile::read_tile_part_header(this) & 1) == 0)
      {
        v196 = 0;
        *(_OWORD *)v194 = 0u;
        v195 = 0u;
        kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "read_failure in kd_tile::initialize ");
        kdu_error::~kdu_error((kdu_error *)v194);
      }
    }
  }
  v3 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(_QWORD *)v1 + 24), "COD");
  if (!v3)
  {
    v196 = 0;
    *(_OWORD *)v194 = 0u;
    v195 = 0u;
    kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Assert ");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "cod != NULL");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v194);
  }
  v159 = (kdu_params *)kdu_params::access_relation(v3, *((_DWORD *)v1 + 2), -1, 0, 1);
  v4 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(_QWORD *)v1 + 24), "QCD");
  if (!v4)
  {
    v196 = 0;
    *(_OWORD *)v194 = 0u;
    v195 = 0u;
    kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Assert ");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "qcd != NULL");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v194);
  }
  v158 = (kdu_params *)kdu_params::access_relation(v4, *((_DWORD *)v1 + 2), -1, 0, 1);
  v5 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(_QWORD *)v1 + 24), "RGN");
  if (!v5)
  {
    v196 = 0;
    *(_OWORD *)v194 = 0u;
    v195 = 0u;
    kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Assert ");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "rgn != NULL");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v194);
  }
  v157 = (kdu_params *)kdu_params::access_relation(v5, *((_DWORD *)v1 + 2), -1, 0, 1);
  v6 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(_QWORD *)v1 + 24), "ORG");
  if (!v6)
  {
    v196 = 0;
    *(_OWORD *)v194 = 0u;
    v195 = 0u;
    kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Assert ");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "org != NULL");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v194);
  }
  v7 = (kdu_params *)kdu_params::access_relation(v6, *((_DWORD *)v1 + 2), -1, 0, 1);
  if (!kdu_params::get(v159, "Cuse_sop", 0, 0, (BOOL *)v1 + 284, 1, 1, 1)
    || !kdu_params::get(v159, "Cuse_eph", 0, 0, (BOOL *)v1 + 285, 1, 1, 1)
    || !kdu_params::get(v159, "Cycc", 0, 0, (BOOL *)v1 + 286, 1, 1, 1)
    || !kdu_params::get(v159, "Calign_blk_last", 0, 0, (int *)v1 + 61, 1, 1, 1)
    || !kdu_params::get(v159, "Calign_blk_last", 0, 1, (int *)v1 + 62, 1, 1, 1)
    || (kdu_params::get(v159, "Clayers", 0, 0, (int *)v1 + 48, 1, 1, 1) & 1) == 0)
  {
    v196 = 0;
    *(_OWORD *)v194 = 0u;
    v195 = 0u;
    kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Corrupt jp2 file: invalid COD parameters ");
    kdu_error::~kdu_error((kdu_error *)v194);
  }
  v8 = *((_DWORD *)v1 + 48);
  v9 = *(_QWORD *)v1;
  if (v8 > *(_DWORD *)(*(_QWORD *)v1 + 256))
    *(_DWORD *)(v9 + 256) = v8;
  if (*(_QWORD *)(v9 + 16))
  {
    v194[0] = 0;
    if ((kdu_params::get(v7, "ORGtparts", 0, 0, v194, 1, 1, 1) & 1) == 0)
      v194[0] = 0;
    if ((kdu_params::get(v7, "ORGgen_plt", 0, 0, (BOOL *)v1 + 294, 1, 1, 1) & 1) == 0)
      *((_BYTE *)v1 + 294) = 0;
    v10 = v194[0];
    *((_BYTE *)v1 + 295) = v194[0] & 1;
    *((_BYTE *)v1 + 296) = (v10 & 4) != 0;
    *((_BYTE *)v1 + 297) = (v10 & 2) != 0;
  }
  if (*((_QWORD *)v1 + 32))
  {
    v196 = 0;
    *(_OWORD *)v194 = 0u;
    v195 = 0u;
    kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Assert ");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "mct_head == NULL");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v194);
  }
  if (*(_BYTE *)(*(_QWORD *)v1 + 164))
    kd_mct_stage::create_stages((int **)v1 + 32, (int **)v1 + 33, *(kdu_params **)(*(_QWORD *)v1 + 24), *((_DWORD *)v1 + 2), *((_DWORD *)v1 + 47), *(_QWORD *)(*(_QWORD *)v1 + 312), *(_DWORD *)(*(_QWORD *)v1 + 176), *(_QWORD *)(*(_QWORD *)v1 + 320));
  v11 = *((int *)v1 + 47);
  *((_DWORD *)v1 + 49) = *((_DWORD *)v1 + 48);
  is_mul_ok(v11, 0xE0uLL);
  v12 = (_QWORD *)operator new[]();
  *v12 = 224;
  v12[1] = v11;
  v13 = v12 + 2;
  __asm { FMOV            V8.2S, #-1.0 }
  if ((_DWORD)v11)
  {
    v18 = v12 + 2;
    do
    {
      *((_OWORD *)v18 + 12) = 0uLL;
      *((_OWORD *)v18 + 13) = 0uLL;
      *((_OWORD *)v18 + 10) = 0uLL;
      *((_OWORD *)v18 + 11) = 0uLL;
      *((_OWORD *)v18 + 8) = 0uLL;
      *((_OWORD *)v18 + 9) = 0uLL;
      *((_OWORD *)v18 + 6) = 0uLL;
      *((_OWORD *)v18 + 7) = 0uLL;
      *((_OWORD *)v18 + 4) = 0uLL;
      *((_OWORD *)v18 + 5) = 0uLL;
      *((_OWORD *)v18 + 2) = 0uLL;
      *((_OWORD *)v18 + 3) = 0uLL;
      *(_OWORD *)v18 = 0uLL;
      *((_OWORD *)v18 + 1) = 0uLL;
      v18[19] = _D8;
      v18 += 28;
    }
    while (v18 != &v13[28 * (int)v11]);
  }
  *((_QWORD *)v1 + 34) = v13;
  *((_DWORD *)v1 + 51) = 0;
  LODWORD(v19) = *((_DWORD *)v1 + 47);
  if ((int)v19 >= 1)
  {
    v20 = 0;
    v164 = 336;
    v173 = v1;
    while (1)
    {
      *((_WORD *)v13 + 92) = 257;
      v13[19] = _D8;
      v21 = *(_QWORD *)v1;
      *v13 = *(_QWORD *)v1;
      v13[1] = v1;
      v22 = (uint64_t *)(*(_QWORD *)(v21 + 312) + 104 * v20);
      v13[2] = v22;
      *((_DWORD *)v13 + 6) = v20;
      v23 = *v22;
      *(_QWORD *)((char *)v13 + 28) = v23;
      v24 = *((_DWORD *)v1 + 54);
      if (SHIDWORD(v23) <= 1)
        v25 = 1;
      else
        v25 = HIDWORD(v23);
      if (v24 <= 0)
        v26 = -(int)(-v24 / v25);
      else
        v26 = (v24 - 1) / v25 + 1;
      v27 = *((_DWORD *)v1 + 56);
      _VF = __OFADD__(v27, v24);
      v28 = v27 + v24;
      if ((v28 < 0) ^ _VF | (v28 == 0))
        v29 = -(int)(-v28 / v25);
      else
        v29 = (v28 - 1) / v25 + 1;
      v30 = *((_DWORD *)v1 + 53);
      if ((int)v23 <= 1)
        v31 = 1;
      else
        v31 = v23;
      if (v30 <= 0)
        v32 = -(int)(-v30 / v31);
      else
        v32 = (v30 - 1) / v31 + 1;
      v33 = *((_DWORD *)v1 + 55);
      _VF = __OFADD__(v33, v30);
      v34 = v33 + v30;
      if ((v34 < 0) ^ _VF | (v34 == 0))
        v35 = -(int)(-v34 / v31);
      else
        v35 = (v34 - 1) / v31 + 1;
      *(_QWORD *)((char *)v13 + 36) = v32 | (unint64_t)(v26 << 32);
      v178 = (_OWORD *)((char *)v13 + 36);
      *(_QWORD *)((char *)v13 + 44) = (v35 - v32) | ((unint64_t)(v29 - v26) << 32);
      v36 = (kdu_params *)kdu_params::access_relation(v159, *((_DWORD *)v1 + 2), v20, 0, 1);
      v177 = (kdu_params *)kdu_params::access_relation(v158, *((_DWORD *)v1 + 2), v20, 0, 1);
      v180 = (kdu_params *)kdu_params::access_relation(v157, *((_DWORD *)v1 + 2), v20, 0, 1);
      v166 = v36;
      if (!v36 || !v177 || !v180)
      {
        v196 = 0;
        *(_OWORD *)v194 = 0u;
        v195 = 0u;
        kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Assert ");
        (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "(coc != NULL) && (qcc != NULL) && (rgc != NULL)");
        (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v194);
      }
      *(_WORD *)v198 = 0;
      v197 = 0;
      v163 = (int *)v13 + 17;
      if (!kdu_params::get(v36, "Clevels", 0, 0, (int *)v13 + 17, 1, 1, 1)
        || *v163 > 32
        || !kdu_params::get(v36, "Creversible", 0, 0, (BOOL *)v13 + 76, 1, 1, 1)
        || !kdu_params::get(v36, "Ckernels", 0, 0, (int *)v13 + 20, 1, 1, 1)
        || !kdu_params::get(v36, "Cuse_precincts", 0, 0, &v198[1], 1, 1, 1)
        || !kdu_params::get(v36, "Cblk", 0, 0, (int *)v13 + 41, 1, 1, 1)
        || !kdu_params::get(v36, "Cblk", 0, 1, (int *)v13 + 42, 1, 1, 1)
        || !kdu_params::get(v36, "Cmodes", 0, 0, (int *)v13 + 43, 1, 1, 1)
        || (kdu_params::get(v36, "Catk", 0, 0, (int *)&v197, 1, 1, 1) & 1) == 0)
      {
        v196 = 0;
        *(_OWORD *)v194 = 0u;
        v195 = 0u;
        kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Corrupt jp2 file: invalid COD parameters ");
        kdu_error::~kdu_error((kdu_error *)v194);
      }
      bzero(v194, 0x288uLL);
      kdu_kernels::clear((uint64_t)v194);
      kd_tile_comp::initialize_kernel_parameters((kd_tile_comp *)v13, v197, (kdu_kernels *)v194);
      if (!*((_BYTE *)v13 + 76)
        && (!kdu_params::get(v177, "Qderived", 0, 0, v198, 1, 1, 1)
         || v198[0] && (kdu_params::get(v177, "Qabs_steps", 0, 0, (float *)&v197 + 1, 1, 1, 1) & 1) == 0))
      {
        v193 = 0;
        *(_OWORD *)v191 = 0u;
        v192 = 0u;
        kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
        (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Tile-components which are compressed using the irreversible processing path must have quantization parameters specified in the QCD/QCC marker segments, either explicitly, or through implicit derivation from the quantization parameters for the LL subband, as explained in the JPEG2000 standard, ISO/IEC 15444-3.  The present set of code-stream parameters is not legal.");
        kdu_error::~kdu_error((kdu_error *)v191);
      }
      v190 = 0;
      if (*(_QWORD *)(*(_QWORD *)v1 + 8) || (kdu_params::get(v180, "Rlevels", 0, 0, &v190, 1, 1, 1) & 1) == 0)
        v190 = 0;
      v189 = 0.0;
      if ((kdu_params::get(v36, "Cweight", 0, 0, &v189, 1, 1, 1) & 1) == 0)
        v189 = 1.0;
      v37 = *((_DWORD *)v13 + 17);
      *((_DWORD *)v13 + 18) = v37;
      v38 = *(_QWORD *)v1;
      if (v37 < *(_DWORD *)(*(_QWORD *)v1 + 248))
        *(_DWORD *)(v38 + 248) = v37;
      if (*((_BYTE *)v13 + 76))
        v39 = *((unsigned __int8 *)v1 + 286) | 4;
      else
        v39 = 7;
      *((_DWORD *)v13 + 40) = v39;
      v40 = *(_DWORD *)(v38 + 160);
      if (v40 == 1)
      {
        if (*((int *)v13 + 42) > 64 || *((int *)v13 + 41) >= 65)
        {
          v193 = 0;
          *(_OWORD *)v191 = 0u;
          v192 = 0u;
          kdu_warning::kdu_warning((kdu_warning *)v191, "Kakadu Core Warning:\n");
          (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Profile violation detected (code-stream is technically illegal).  Profile-1 code-streams may not have code-block dimensions larger than 64.  You should set \"Sprofile\" to 2.");
          *(_DWORD *)(*(_QWORD *)v1 + 160) = 2;
          kdu_warning::~kdu_warning((kdu_warning *)v191);
        }
      }
      else if (!v40)
      {
        v41 = *((_DWORD *)v13 + 42);
        if (v41 == *((_DWORD *)v13 + 41) && (v41 == 32 || v41 == 64))
        {
          if ((*((_BYTE *)v13 + 172) & 0xB) != 0)
          {
            v193 = 0;
            *(_OWORD *)v191 = 0u;
            v192 = 0u;
            kdu_warning::kdu_warning((kdu_warning *)v191, "Kakadu Core Warning:\n");
            (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Profile violation detected (code-stream is technically illegal).  Profile-0 code-streams may not use the BYPASS, RESET or CAUSAL block coder mode switches.  You should set \"Sprofile\" to 1 or 2.");
            *(_DWORD *)(*(_QWORD *)v1 + 160) = 2;
            kdu_warning::~kdu_warning((kdu_warning *)v191);
          }
        }
        else
        {
          v193 = 0;
          *(_OWORD *)v191 = 0u;
          v192 = 0u;
          kdu_warning::kdu_warning((kdu_warning *)v191, "Kakadu Core Warning:\n");
          (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Profile violation detected (code-stream is technically illegal).  Profile-0 code-streams must have nominally square code-block dimensions, measuring 32x32 or 64x64.  You should set \"Sprofile\" to 1 or 2.");
          *(_DWORD *)(*(_QWORD *)v1 + 160) = 2;
          kdu_warning::~kdu_warning((kdu_warning *)v191);
        }
      }
      if (*(_DWORD *)(*(_QWORD *)v1 + 160) != 3 && (*((_DWORD *)v1 + 62) || *((_DWORD *)v1 + 61)))
      {
        v193 = 0;
        *(_OWORD *)v191 = 0u;
        v192 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)v191, "Kakadu Core Warning:\n");
          "' to avoid this warning message.");
        *(_DWORD *)(*(_QWORD *)v1 + 160) = 3;
        kdu_warning::~kdu_warning((kdu_warning *)v191);
      }
      v42 = *((_DWORD *)v13 + 42);
      if (!v42 || v42 > 0x2000 || (v43 = *((_DWORD *)v13 + 41)) == 0 || v43 > 0x2000)
      {
        v193 = 0;
        *(_OWORD *)v191 = 0u;
        v192 = 0u;
        kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
        (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "JP2 file is corrupt - illegal code block size");
        kdu_error::~kdu_error((kdu_error *)v191);
      }
      if (*(_QWORD *)(*(_QWORD *)v1 + 16))
        *((float *)v13 + 38) = kd_tile::find_multicomponent_energy_gain(v1, v20, 0);
      v160 = v20;
      v44 = *v163 + 1;
      is_mul_ok(v44, 0x2C0uLL);
      v45 = (_QWORD *)operator new[]();
      *v45 = 704;
      v45[1] = v44;
      v46 = v45 + 2;
      if ((_DWORD)v44)
      {
        v47 = v45 + 2;
        do
        {
          v48 = 0;
          *((_OWORD *)v47 + 3) = 0uLL;
          *((_OWORD *)v47 + 4) = 0uLL;
          *(_OWORD *)((char *)v47 + 84) = 0uLL;
          *(_OWORD *)((char *)v47 + 100) = 0uLL;
          v49 = v47 + 86;
          *(_OWORD *)(v47 + 21) = 0uLL;
          *(_OWORD *)(v47 + 23) = 0uLL;
          *(_OWORD *)(v47 + 25) = 0uLL;
          do
          {
            v50 = &v45[v48];
            *((_OWORD *)v50 + 18) = 0uLL;
            *((_OWORD *)v50 + 19) = 0uLL;
            v51 = (_OWORD *)((char *)&v45[v48 + 43] + 4);
            *v51 = 0uLL;
            v51[1] = 0uLL;
            v51[2] = 0uLL;
            v51[3] = 0uLL;
            v48 += 18;
          }
          while (v48 != 54);
          *v47 = 0;
          v47[1] = 0;
          v47[2] = 0;
          *(_OWORD *)((char *)v47 + 222) = 0uLL;
          *(_OWORD *)((char *)v47 + 238) = 0uLL;
          *((_WORD *)v47 + 127) = 0;
          *((_BYTE *)v47 + 221) = 1;
          v47[20] = 0;
          v47 += 88;
          v45 += 88;
          *v49 = 0;
          v49[1] = 0;
        }
        while (v47 != &v46[88 * v44]);
      }
      v164 += 224;
      v13[22] = v46;
      v52 = *((unsigned int *)v13 + 17);
      if ((v52 & 0x80000000) == 0)
      {
        v53 = 704 * v52;
        v54 = -(int)v52;
        v174 = v13;
        do
        {
          v55 = v13[22];
          v56 = v55 + v53;
          *(_QWORD *)v56 = *(_QWORD *)v1;
          *(_QWORD *)(v56 + 8) = v13;
          *(_BYTE *)(v56 + 24) = v52;
          v57 = *((unsigned int *)v13 + 17);
          v58 = v54 + v57 + ((_DWORD)v52 != 0);
          *(_BYTE *)(v56 + 25) = v58;
          v59 = v13[2] + v54 + (int)v57;
          v60 = *(unsigned __int8 *)(v59 + 21);
          *(_BYTE *)(v56 + 26) = v60;
          v61 = *(unsigned __int8 *)(v59 + 54);
          *(_BYTE *)(v56 + 27) = v61;
          *(_BYTE *)(v56 + 220) = v190 >= v58;
          v62 = v54;
          if (v52 == v57)
          {
            *(_QWORD *)(v56 + 32) = 0;
            *(_OWORD *)(v56 + 48) = *v178;
          }
          else
          {
            *(_QWORD *)(v56 + 32) = v56 + 736;
            *(_QWORD *)(v56 + 824) = v56 + 32;
            v65 = v13[2] + v54 + (int)v57 - 1;
            _ZF = v60 == *(unsigned __int8 *)(v65 + 21);
            *(_BYTE *)(v56 + 80) = 2 * _ZF;
            v64 = *(unsigned __int8 *)(v65 + 54);
            LODWORD(v65) = *(_DWORD *)(v56 + 756);
            v66 = *(_DWORD *)(v56 + 764) + v65;
            if (_ZF)
              v65 = v65;
            else
              v65 = (((int)v65 + 1) >> 1);
            if (!_ZF)
              v66 = (v66 + 1) >> 1;
            v67 = *(_DWORD *)(v56 + 752);
            v68 = *(_DWORD *)(v56 + 760) + v67;
            _ZF = v61 == v64;
            v69 = 2 * (v61 == v64);
            *(_BYTE *)(v56 + 81) = v69;
            if (!_ZF)
            {
              v67 = (int)(v67 - v69 + 1) >> 1;
              v68 = (v68 - v69 + 1) >> 1;
            }
            v70 = v67 | (unint64_t)(v65 << 32);
            v71 = (v68 - v67) | ((unint64_t)(v66 - v65) << 32);
            v72 = v55 + v53;
            *(_QWORD *)(v72 + 48) = v70;
            *(_QWORD *)(v72 + 56) = v71;
          }
          kd_resolution::build_decomposition_structure((kd_resolution *)(v55 + v53), v166, (kdu_kernels *)v194);
          v73 = v55 + v53;
          *(_QWORD *)(v55 + v53 + 168) = *(_QWORD *)((char *)v1 + 244);
          if (v198[1])
          {
            if (!kdu_params::get(v166, "Cprecincts", v62 + *v163, 0, (int *)(v73 + 176), 1, 1, 1)
              || (kdu_params::get(v166, "Cprecincts", v62 + *v163, 1, (int *)(v55 + v53 + 180), 1, 1, 1) & 1) == 0)
            {
              v193 = 0;
              *(_OWORD *)v191 = 0u;
              v192 = 0u;
              kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
              (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Assert ");
              (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "0");
              (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, " FAILED");
              kdu_error::~kdu_error((kdu_error *)v191);
            }
          }
          else
          {
            *(_QWORD *)(v73 + 176) = 0x800000008000;
          }
          v74 = v55 + v53;
          if (*(int *)(v55 + v53 + 176) * (uint64_t)*(int *)(v55 + v53 + 180) <= 0)
          {
            v193 = 0;
            *(_OWORD *)v191 = 0u;
            v192 = 0u;
            kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
            (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Corrupt jp2 file: precinct_partition size causes arithmetic overflow. ");
            kdu_error::~kdu_error((kdu_error *)v191);
          }
          check_coding_partition(*(_QWORD *)(v73 + 168), *(_QWORD *)(v74 + 176));
          v75 = v52;
          v76 = v55 + v53;
          v183 = v55;
          *(_QWORD *)(v76 + 200) = get_partition_indices(*(_QWORD *)(v73 + 168), *(_QWORD *)(v74 + 176), *(_QWORD *)(v55 + v53 + 48), *(_QWORD *)(v55 + v53 + 56));
          *(_QWORD *)(v76 + 208) = v77;
          *(_OWORD *)(v76 + 184) = *(_OWORD *)(v76 + 200);
          v78 = *(unsigned int *)(v76 + 192) * (unint64_t)*(unsigned int *)(v76 + 196);
          v79 = 8 * (int)v78 + (uint64_t)(v164 + 704);
          if (v79 != (int)v79 || 8 * (int)v78 != 8 * (_DWORD)v78)
          {
            v193 = 0;
            *(_OWORD *)v191 = 0u;
            v192 = 0u;
            kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
            (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Corrupt jp2 file: precinct_partition size causes arithmetic overflow. ");
            kdu_error::~kdu_error((kdu_error *)v191);
          }
          if ((v78 & 0x80000000) != 0)
          {
            v193 = 0;
            *(_OWORD *)v191 = 0u;
            v192 = 0u;
            kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
            (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Corrupt jp2 file: bad 'precinct_indices'. ");
            kdu_error::~kdu_error((kdu_error *)v191);
          }
          v80 = (_QWORD *)operator new[]();
          v181 = v62;
          v164 += 8 * v78 + 704;
          *v80 = 8;
          v80[1] = (int)v78;
          v81 = v80 + 2;
          if (v78 << 32)
            bzero(v80 + 2, 8 * (int)v78);
          *(_QWORD *)(v183 + v53 + 232) = v81;
          v1 = v173;
          *((_DWORD *)v173 + 51) += v78;
          v82 = *(_QWORD *)v173;
          v83 = v160;
          if (v160 > 3)
          {
            v13 = v174;
          }
          else
          {
            v13 = v174;
            if (!v53 && *(int *)(v82 + 160) <= 1)
            {
              v84 = *(_QWORD *)(v56 + 8);
              if (*(_DWORD *)(v84 + 32) * *(_DWORD *)(v183 + 60) > 128
                || *(_DWORD *)(v84 + 28) * *(_DWORD *)(v183 + 56) >= 129)
              {
                v193 = 0;
                *(_OWORD *)v191 = 0u;
                v192 = 0u;
                kdu_warning::kdu_warning((kdu_warning *)v191, "Kakadu Core Warning:\n");
                (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Profile violation detected (code-stream is technically illegal).  Profile-0 and Profile-1 code-streams must have sufficient DWT levels to permit extraction of a low resolution image which is no larger than 128x128.   Try setting a larger value for \"Clevels\" or else set \"Sprofile\" to 2.");
                *(_DWORD *)(*(_QWORD *)v173 + 160) = 2;
                kdu_warning::~kdu_warning((kdu_warning *)v191);
                v82 = *(_QWORD *)v173;
              }
            }
          }
          if (!*(_DWORD *)(v82 + 160)
            && *(int *)(v183 + v53 + 60) <= 128
            && *(int *)(v183 + v53 + 56) <= 128
            && *(int *)(v76 + 192) * (uint64_t)*(int *)(v76 + 196) > 1)
          {
            v193 = 0;
            *(_OWORD *)v191 = 0u;
            v192 = 0u;
            kdu_warning::kdu_warning((kdu_warning *)v191, "Kakadu Core Warning:\n");
            (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Profile violation detected (code-stream is technically illegal).  Profile-0 code-streams may have multiple precincts only in those tile-component resolutions whose dimensions are greater than 128x128.");
            *(_DWORD *)(*(_QWORD *)v173 + 160) = 2;
            kdu_warning::~kdu_warning((kdu_warning *)v191);
          }
          v52 = v75 - 1;
          v53 -= 704;
          v54 = v181 + 1;
        }
        while (v75 >= 1);
        LODWORD(v85) = *v163;
        if (*v163 < 0)
          goto LABEL_227;
        v86 = 0;
        v176 = 0;
        v87 = 1;
        do
        {
          v88 = v13[22];
          v175 = (kd_resolution *)(v88 + 704 * v86);
          v89 = (char *)v175 + 221;
          if ((v87 & 1) != 0)
          {
            if (*v89)
            {
              v90 = 1;
            }
            else
            {
              v90 = 0;
              *(_BYTE *)(*(_QWORD *)v1 + 280) = 1;
            }
          }
          else
          {
            v90 = 0;
            *v89 = 0;
          }
          v188 = 0.0;
          v91 = kdu_params::get(v166, "Clev_weights", (int)v85 - (int)v86, 0, &v188, 1, 1, 1);
          v161 = v90;
          v92 = v188;
          if (!v91)
            v92 = 1.0;
          v188 = v189 * v92;
          v172 = (_BYTE *)(v88 + 704 * v86 + 222);
          v162 = v86;
          if (*v172)
          {
            v93 = 0;
            v94 = v88 + 704 * v86;
            v167 = (unsigned __int8 *)(v94 + 27);
            v168 = (unsigned __int8 *)(v94 + 26);
            v165 = (unsigned __int8 *)(v94 + 25);
            v182 = (int *)(v94 + 168);
            v184 = (_BYTE *)(v94 + 24);
            v170 = (_DWORD *)(v94 + 176);
            v171 = (uint64_t *)(v94 + 240);
            v169 = (int *)(v94 + 180);
            do
            {
              v95 = *v171;
              v96 = *v171 + 144 * v93;
              if (*(kd_resolution **)(v96 + 8) != v175)
              {
                v193 = 0;
                *(_OWORD *)v191 = 0u;
                v192 = 0u;
                kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
                (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Assert ");
                (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "band->resolution == res");
                (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, " FAILED");
                kdu_error::~kdu_error((kdu_error *)v191);
              }
              v186 = 0;
              v187 = 0;
              v97 = v93 + v176;
              v179 = v96;
              if (*((_BYTE *)v13 + 76))
              {
                if ((kdu_params::get(v177, "Qabs_ranges", v97, 0, &v186, 1, 1, 1) & 1) == 0)
                {
                  v193 = 0;
                  *(_OWORD *)v191 = 0u;
                  v192 = 0u;
                  kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Assert ");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "0");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, " FAILED");
                  kdu_error::~kdu_error((kdu_error *)v191);
                }
                v98 = v95 + 144 * v93;
                *(_BYTE *)(v98 + 57) = v186;
                *(float *)(v98 + 60) = 1.0 / (float)(1 << *(_DWORD *)(v13[2] + 16));
              }
              else
              {
                v185 = 0.0;
                if (v198[0])
                {
                  v99 = *(unsigned __int16 *)(v95 + 144 * v93 + 52);
                  v100 = v13[2] + *((int *)v13 + 17);
                  v101 = (v99 & 3)
                       + *v168
                       + *v167
                       + ((v99 >> 8) & 3)
                       - (*(unsigned __int8 *)(v100 + 21)
                        + *(unsigned __int8 *)(v100 + 54));
                  v102 = *((float *)&v197 + 1);
                  if ((v101 & 1) != 0)
                    v102 = *((float *)&v197 + 1) * 1.4142;
                  v103 = (v101 & 1) + v101;
                  v104 = v103 >> 2;
                  if (v103 < 4)
                    v105 = v102 * (float)(1 << -(char)v104);
                  else
                    v105 = v102 / (float)(1 << v104);
                  v185 = v105;
                }
                else
                {
                  if ((kdu_params::get(v177, "Qabs_steps", v97, 0, &v185, 1, 1, 1) & 1) == 0)
                  {
                    exception = __cxa_allocate_exception(4uLL);
                    *exception = -1;
                    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
                  }
                  v105 = v185;
                }
                if (v105 <= 0.0)
                {
                  v193 = 0;
                  *(_OWORD *)v191 = 0u;
                  v192 = 0u;
                  kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Assert ");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "delta > 0.0F");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, " FAILED");
                  kdu_error::~kdu_error((kdu_error *)v191);
                }
                v106 = v95 + 144 * v93;
                *(_BYTE *)(v106 + 57) = 0;
                v107 = v106 + 57;
                *(float *)(v107 + 3) = v105;
                v108 = v185;
                if (v185 < 1.0)
                {
                  v109 = 0;
                  do
                  {
                    ++v109;
                    v108 = v108 + v108;
                  }
                  while (v108 < 1.0);
                  *(_BYTE *)v107 = v109;
                  v185 = v108;
                }
                if (v108 >= 2.0)
                {
                  v193 = 0;
                  *(_OWORD *)v191 = 0u;
                  v192 = 0u;
                  kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Assert ");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "delta < 2.0F");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, " FAILED");
                  kdu_error::~kdu_error((kdu_error *)v191);
                }
              }
              if ((kdu_params::get(v177, "Qguard", 0, 0, &v187, 1, 1, 1) & 1) == 0)
              {
                v193 = 0;
                *(_OWORD *)v191 = 0u;
                v192 = 0u;
                kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
                (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Assert ");
                (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "0");
                (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, " FAILED");
                kdu_error::~kdu_error((kdu_error *)v191);
              }
              v110 = v95 + 144 * v93;
              *(_BYTE *)(v110 + 58) = v187;
              v111 = v110 + 58;
              if ((kdu_params::get(v180, "Rweight", 0, 0, (float *)(v111 + 14), 1, 1, 1) & 1) == 0)
                *(_DWORD *)(v111 + 14) = -1082130432;
              *(_BYTE *)v111 = *(_BYTE *)(v95 + 144 * v93 + 57) + *(_BYTE *)v111 - 1;
              if ((kdu_params::get(v180, "Rshift", 0, 0, &v187, 1, 1, 1) & 1) != 0)
              {
                v112 = v187;
                if (v187 >= 38 && *(int *)(*(_QWORD *)v1 + 160) <= 1)
                {
                  v193 = 0;
                  *(_OWORD *)v191 = 0u;
                  v192 = 0u;
                  kdu_warning::kdu_warning((kdu_warning *)v191, "Kakadu Core Warning:\n");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Profile violation detected (code-stream is technically illegal).  The \"Rshift\" attribute may not exceed 37, except in Profile-2 (the unrestricted profile).");
                  *(_DWORD *)(*(_QWORD *)v1 + 160) = 2;
                  kdu_warning::~kdu_warning((kdu_warning *)v191);
                  v112 = v187;
                }
              }
              else
              {
                v112 = 0;
                v187 = 0;
              }
              *(_BYTE *)(v95 + 144 * v93 + 59) = *(_BYTE *)v111 + v112;
              if (*(_QWORD *)(*(_QWORD *)v1 + 8))
              {
                *(_QWORD *)(v95 + 144 * v93 + 64) = 0;
              }
              else
              {
                v113 = v95 + 144 * v93;
                v114 = (float *)(v113 + 68);
                if (kdu_params::get(v166, "Cband_weights", 3 * *v165 - *(unsigned __int8 *)(v113 + 54), 0, (float *)(v113 + 68), 1, 1, 1))
                {
                  v115 = *v114;
                }
                else
                {
                  *v114 = 1.0;
                  v115 = 1.0;
                }
                *v114 = v188 * v115;
                if (!*v184)
                  *v114 = v189;
                v191[2] = 0;
                *(_WORD *)v191 = 0;
                v116 = v95 + 144 * v93;
                v117 = *(_WORD *)(v116 + 52);
                *(_WORD *)v191 = (v117 & 4) != 0;
                v191[1] = (v117 & 8) != 0;
                v191[2] = (v117 & 0x10) != 0;
                energy_gain = kdu_kernels::get_energy_gain((kdu_kernels *)v194, *v168, v117 & 3, v191);
                *(float *)(v116 + 64) = energy_gain;
                v119 = *(unsigned __int16 *)(v116 + 52);
                v191[0] = (v119 & 0x400) != 0;
                v191[1] = (v119 & 0x800) != 0;
                v191[2] = (v119 & 0x1000) != 0;
                v120 = kdu_kernels::get_energy_gain((kdu_kernels *)v194, *v167, (v119 >> 8) & 3, v191);
                *(float *)(v116 + 64) = *(float *)(v116 + 64) * v120;
              }
              v121 = v95 + 144 * v93;
              *(_QWORD *)(v121 + 76) = *(_QWORD *)v182;
              v122 = v121 + 76;
              v123 = *(_QWORD *)((char *)v13 + 164);
              *(_QWORD *)(v121 + 84) = v123;
              v124 = (int *)(v121 + 84);
              v125 = *((unsigned __int16 *)v124 - 16);
              v126 = v125 & 3;
              v127 = (v125 >> 8) & 3;
              if (*v184)
              {
                *(_DWORD *)(v95 + 144 * v93 + 88) <<= v126;
                *v124 = (_DWORD)v123 << v127;
              }
              kdu_dims::operator&=((_DWORD *)v122, v182);
              v128 = v95 + 144 * v93;
              v131 = *(_DWORD *)(v128 + 88);
              v130 = (int *)(v128 + 88);
              v129 = v131;
              if (!v131 || (v132 = *v124) == 0)
              {
                v193 = 0;
                *(_OWORD *)v191 = 0u;
                v192 = 0u;
                kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
                (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Corrupt jp2 file: degenerate band->block_partition.size\n");
                kdu_error::~kdu_error((kdu_error *)v191);
              }
              v133 = *v169;
              v134 = v95 + 144 * v93;
              *(_DWORD *)(v134 + 124) = *v170 / v132;
              v135 = (int *)(v134 + 124);
              v135[1] = v133 / v129;
              if (*v184)
              {
                v136 = *((_WORD *)v124 - 16);
                if ((v136 & 0x1C) != 0)
                  *(_DWORD *)(v122 + 4) = 0;
                if ((v136 & 0x1C00) != 0)
                  *(_DWORD *)v122 = 0;
                *v130 = v129 >> v126;
                *v124 = v132 >> v127;
                if (v129 >> v126 < 1 || v132 >> v127 <= 0)
                {
                  v193 = 0;
                  *(_OWORD *)v191 = 0u;
                  v192 = 0u;
                  kdu_error::kdu_error((kdu_error *)v191, "Kakadu Core Error:\n");
                  (*(void (**)(BOOL *, const char *))(*(_QWORD *)v191 + 16))(v191, "Precinct partition dimensions too small!  Must not be so small that the induced code-block partition becomes smaller than 1 sample wide or 1 sample high within any subband.");
                  kdu_error::~kdu_error((kdu_error *)v191);
                }
              }
              check_coding_partition(*(_QWORD *)v122, *(_QWORD *)(v122 + 8));
              partition_indices = get_partition_indices(*(_QWORD *)v122, *(_QWORD *)(v122 + 8), *(_QWORD *)(v179 + 16), *(_QWORD *)(v179 + 24));
              v138 = v95 + 144 * v93;
              *(_QWORD *)(v138 + 132) = 0;
              v139 = (_DWORD *)(v138 + 132);
              v142 = *(_DWORD *)(v138 + 136);
              v140 = (_DWORD *)(v138 + 136);
              v141 = v142;
              *(_QWORD *)(v140 - 11) = partition_indices;
              *(_QWORD *)(v140 - 9) = v143;
              v144 = v135[1];
              if (1 << v142 < v144)
              {
                do
                  ++v141;
                while (1 << v141 < v144);
                *v140 = v141;
              }
              v145 = *v135;
              v1 = v173;
              v13 = v174;
              if (v145 >= 2)
              {
                v146 = 0;
                do
                  v147 = 2 << v146++;
                while (v147 < v145);
                *v139 = v146;
              }
              ++v93;
              v148 = *v172;
            }
            while (v93 < v148);
          }
          else
          {
            LODWORD(v148) = 0;
          }
          kd_resolution::complete_initialization(v175);
          v87 = v161;
          v176 += v148;
          v86 = v162 + 1;
          v85 = *v163;
        }
        while (v162 < v85);
      }
      v83 = v160;
LABEL_227:
      kdu_kernels::reset((kdu_kernels *)v194);
      v20 = v83 + 1;
      v13 += 28;
      v19 = *((int *)v1 + 47);
      if (v20 >= v19)
        goto LABEL_230;
    }
  }
  v164 = 336;
LABEL_230:
  if (*((_BYTE *)v1 + 286))
  {
    if ((int)v19 < 3
      || (v149 = *((_QWORD *)v1 + 34), v150 = *(unsigned __int8 *)(v149 + 76), v150 != *(unsigned __int8 *)(v149 + 300))
      || v150 != *(unsigned __int8 *)(v149 + 524)
      || (v151 = *(_DWORD *)(v149 + 32), v151 != *(_DWORD *)(v149 + 256))
      || (v152 = *(_DWORD *)(v149 + 28), v152 != *(_DWORD *)(v149 + 252))
      || v151 != *(_DWORD *)(v149 + 480)
      || v152 != *(_DWORD *)(v149 + 476))
    {
      v196 = 0;
      *(_OWORD *)v194 = 0u;
      v195 = 0u;
      kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Illegal colour transform specified when image has insufficient or incompatible colour components.");
      kdu_error::~kdu_error((kdu_error *)v194);
    }
  }
  v153 = *((_DWORD *)v1 + 48);
  *((_DWORD *)v1 + 50) = v153;
  *((_DWORD *)v1 + 52) = *((_DWORD *)v1 + 51) * v153;
  *((_BYTE *)v1 + 292) = 1;
  *((_BYTE *)v1 + 316) = 0;
  *(_QWORD *)((char *)v1 + 308) = 0;
  v154 = operator new();
  *(_QWORD *)(v154 + 16) = 0;
  *(_OWORD *)(v154 + 68) = 0u;
  *(_OWORD *)(v154 + 84) = 0u;
  *(_OWORD *)(v154 + 156) = 0u;
  *(_OWORD *)(v154 + 172) = 0u;
  *(_QWORD *)v154 = v1;
  kd_packet_sequencer::init((kd_packet_sequencer *)v154);
  *((_QWORD *)v1 + 12) = v154;
  if (*((_DWORD *)v1 + 70))
  {
    v196 = 0;
    *(_OWORD *)v194 = 0u;
    v195 = 0u;
    kdu_error::kdu_error((kdu_error *)v194, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "Assert ");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, "structure_bytes == 0");
    (*(void (**)(int *, const char *))(*(_QWORD *)v194 + 16))(v194, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v194);
  }
  *((_DWORD *)v1 + 70) = v164 + 208;
  kd_buf_server::augment_structure_bytes(*(_QWORD *)(*(_QWORD *)v1 + 48), v164 + 208);
  if (!*(_BYTE *)(*(_QWORD *)v1 + 417))
    kd_tile::set_elements_of_interest((int **)v1);
  result = kdu_params::check_typical_tile(*(kdu_params **)(*(_QWORD *)v1 + 24), *((_DWORD *)v1 + 2));
  *((_BYTE *)v1 + 184) = result;
  return result;
}

void sub_187EE93FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  kdu_error::~kdu_error((kdu_error *)&a45);
}

void sub_187EE9408(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  _Unwind_Exception *v45;

  _Unwind_Resume(v45);
}

uint64_t kd_tile::read_tile_part_header(kd_tile *this)
{
  uint64_t v2;
  kdu_params *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t offset;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  unsigned __int16 *v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  kd_pp_markers *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int i;
  uint64_t v45;
  int v46;
  _BYTE *v47;
  kdu_params *v48;
  kdu_params *v49;
  kdu_params *v50;
  kdu_params *v51;
  kdu_params *v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  kd_pp_markers *v57;
  uint64_t v58;
  uint64_t v59;
  kd_pp_markers *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  _OWORD v69[2];
  uint64_t v70;
  uint64_t v71;
  char v72[16];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)(*(_QWORD *)this + 8))
  {
    *(_QWORD *)&v74 = 0;
    *(_OWORD *)v72 = 0u;
    v73 = 0u;
    kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
    (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "codestream->in != NULL");
    (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v72);
  }
  if (*(_BYTE *)(v2 + 418))
  {
    if (*((_DWORD *)this + 76))
    {
      *(_QWORD *)&v74 = 0;
      *(_OWORD *)v72 = 0u;
      v73 = 0u;
      kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "next_tpart == 0");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v72);
    }
    if (*((_BYTE *)this + 290))
      kd_tile::withdraw_from_unloadable_list((uint64_t *)this);
    kd_codestream::unload_tiles_to_cache_threshold(*(_QWORD *)this);
    if (kd_compressed_input::set_tileheader_scope(*(kd_compressed_input **)(*(_QWORD *)this + 8)))
    {
      v3 = *(kdu_params **)(*(_QWORD *)this + 24);
      if (kd_marker::read(*(kd_marker **)(*(_QWORD *)this + 32), 0, 0))
      {
        do
        {
          v4 = *(_QWORD *)(*(_QWORD *)this + 32);
          v5 = *(unsigned __int16 *)(v4 + 16);
          if ((_DWORD)v5 == 65377)
          {
            *(_QWORD *)&v74 = 0;
            *(_OWORD *)v72 = 0u;
            v73 = 0u;
            kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "You cannot use PPM or PPT marker segments (packed packet headers) with cached compressed data sources.");
            kdu_error::~kdu_error((kdu_error *)v72);
          }
          kdu_params::translate_marker_segment(v3, v5, *(unsigned int *)(v4 + 20), *(unsigned __int8 **)(v4 + 32), *((_DWORD *)this + 2), 0);
        }
        while ((kd_marker::read(*(kd_marker **)(*(_QWORD *)this + 32), 0, 0) & 1) != 0);
      }
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)this + 8) + 544))
      {
        *(_QWORD *)&v74 = 0;
        *(_OWORD *)v72 = 0u;
        v73 = 0u;
        kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Found non-marker code while parsing tile header marker segments.  Chances are that a marker segment length field is incorrect!");
        kdu_error::~kdu_error((kdu_error *)v72);
      }
      kdu_params::finalize_all(v3, *((_DWORD *)this + 2), 1);
    }
    else
    {
      *((_BYTE *)this + 287) = 1;
    }
    *(_QWORD *)((char *)this + 300) = 0x100000001;
    ++*(_DWORD *)(*(_QWORD *)this + 460);
    *((_BYTE *)this + 328) = 1;
    if (*((_BYTE *)this + 291))
    {
      *(_QWORD *)&v74 = 0;
      *(_OWORD *)v72 = 0u;
      v73 = 0u;
      kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "!closed");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v72);
    }
    kd_tile::adjust_unloadability((uint64_t *)this);
    return 1;
  }
  if (*((_BYTE *)this + 328))
  {
LABEL_17:
    if (*(kd_tile **)(v2 + 440) == this)
    {
      *(_QWORD *)&v74 = 0;
      *(_OWORD *)v72 = 0u;
      v73 = 0u;
      kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "this != codestream->active_tile");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v72);
    }
    return 0;
  }
  if (*((int *)this + 75) >= 1 && *((int *)this + 76) >= 255)
  {
    kd_tile::finished_reading(this);
    v2 = *(_QWORD *)this;
    goto LABEL_17;
  }
  v7 = *(_QWORD *)(v2 + 440);
  while (2)
  {
    if (!v7)
      goto LABEL_46;
    *(_QWORD *)&v69[0] = 0;
    v71 = 0;
    if (!*(_QWORD *)(v7 + 96))
    {
      *(_QWORD *)&v74 = 0;
      *(_OWORD *)v72 = 0u;
      v73 = 0u;
      kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Invalid code-stream!\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "\t'active->sequencer' is NULL");
      kdu_error::~kdu_error((kdu_error *)v72);
    }
    do
    {
      v8 = kd_packet_sequencer::next_in_sequence(*(uint64_t **)(v7 + 96), (uint64_t *)v69, &v71);
      if (!v8)
        break;
      v9 = *v8;
      if (!*v8)
      {
        v9 = kd_precinct_ref::instantiate_precinct(v8, *(uint64_t *)&v69[0], v71);
        goto LABEL_42;
      }
      if ((v9 & 1) == 0 && !*(_BYTE *)(v9 + 17))
      {
        if (v9 == 3)
        {
          v9 = 0;
        }
        else if (*(_BYTE *)(v9 + 20))
        {
          kd_precinct_size_class::withdraw_from_inactive_list(*(_QWORD *)(v9 + 72), (kd_precinct *)v9);
          kd_precinct::activate(v9);
        }
LABEL_42:
        if (!kd_precinct::desequence_packet((kd_precinct *)v9))
          break;
      }
    }
    while (v7 == *(_QWORD *)(*(_QWORD *)this + 440));
    if (v7 == *(_QWORD *)(*(_QWORD *)this + 440))
    {
      *(_QWORD *)(*(_QWORD *)this + 440) = 0;
      kd_tile::adjust_unloadability((uint64_t *)v7);
    }
LABEL_46:
    if (*(kd_tile **)(*((_QWORD *)this + 3) + 16) != this)
    {
      *(_QWORD *)&v74 = 0;
      *(_OWORD *)v72 = 0u;
      v73 = 0u;
      kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "tile_ref->tile == this");
      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v72);
    }
    v10 = *(_QWORD *)this;
    v11 = *(_QWORD *)(*(_QWORD *)this + 72);
    if (!v11)
    {
      if (*(__int16 *)(*(_QWORD *)(v10 + 32) + 16) != -112)
      {
        v13 = *(_BYTE **)(v10 + 8);
        if (!v13[544])
        {
          v14 = *(_QWORD *)(v10 + 448);
          if (v14 <= 0)
          {
            *(_QWORD *)&v74 = 0;
            *(_OWORD *)v72 = 0u;
            v73 = 0u;
            kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
            (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "codestream->next_sot_address > 0");
            (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
            kdu_error::~kdu_error((kdu_error *)v72);
          }
          offset = kd_compressed_input::get_offset(*(kd_compressed_input **)(v10 + 8));
          (*(void (**)(_BYTE *, uint64_t))(*(_QWORD *)v13 + 16))(v13, v14 - offset);
          kd_marker::read(*(kd_marker **)(*(_QWORD *)this + 32), 0, 0);
LABEL_69:
          v10 = *(_QWORD *)this;
        }
      }
LABEL_70:
      *(_QWORD *)(v10 + 448) = 0;
      goto LABEL_71;
    }
    v12 = (uint64_t *)*((_QWORD *)this + 4);
    if (v12)
    {
      kd_compressed_input::seek(*(_QWORD *)(v10 + 8), *v12);
      *((_QWORD *)this + 4) = *(_QWORD *)(*((_QWORD *)this + 4) + 8);
      kd_marker::read(*(kd_marker **)(*(_QWORD *)this + 32), 0, 0);
      v10 = *(_QWORD *)this;
      goto LABEL_71;
    }
    if (*(_BYTE *)(v11 + 24) || (v16 = (_QWORD *)*((_QWORD *)this + 3), *v16) && !v16[1])
    {
      *((_DWORD *)this + 75) = *((_DWORD *)this + 76);
      kd_tile::finished_reading(this);
      return 0;
    }
    if (*(__int16 *)(*(_QWORD *)(v10 + 32) + 16) == -112
      && *(_DWORD *)(v10 + 224) == 1
      && *(_DWORD *)(v10 + 220) == 1)
    {
      goto LABEL_70;
    }
    v17 = *(_QWORD *)(v10 + 8);
    v18 = *(_QWORD *)(v10 + 448);
    if (*(_BYTE *)(v17 + 544))
      v19 = 1;
    else
      v19 = v18 < 1;
    if (!v19)
    {
      kd_compressed_input::seek(v17, v18);
      kd_marker::read(*(kd_marker **)(*(_QWORD *)this + 32), 0, 0);
      goto LABEL_69;
    }
    if (v18 < 0)
      return 0;
LABEL_71:
    if (!*(_BYTE *)(*(_QWORD *)(v10 + 8) + 544))
    {
      v20 = *(_QWORD *)(v10 + 32);
      if (*(__int16 *)(v20 + 16) != -112)
      {
        *(_QWORD *)&v74 = 0;
        *(_OWORD *)v72 = 0u;
        v73 = 0u;
        kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Invalid marker code found in code-stream!\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "\tExpected SOT marker and got ");
        print_marker_code(*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)this + 32) + 16), (kdu_message *)v72);
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, ".");
        kdu_error::~kdu_error((kdu_error *)v72);
      }
      if (*(_DWORD *)(v20 + 20) != 8)
      {
        *(_QWORD *)&v74 = 0;
        *(_OWORD *)v72 = 0u;
        v73 = 0u;
        kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "seg_length == 8");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v72);
      }
      v21 = *(unsigned __int16 **)(v20 + 32);
      v22 = __rev16(*v21);
      v23 = *(_DWORD *)(v21 + 1);
      v68 = *((unsigned __int8 *)v21 + 6);
      v24 = *((unsigned __int8 *)v21 + 7);
      v25 = *(_DWORD *)(v10 + 224);
      if (v22 >= *(_DWORD *)(v10 + 220) * v25)
      {
        *(_QWORD *)&v74 = 0;
        *(_OWORD *)v72 = 0u;
        v73 = 0u;
        kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Corrupt SOT marker segment found in codestream: tile-number lies outside the range of available tiles derived from the SIZ marker segment.");
        kdu_error::~kdu_error((kdu_error *)v72);
      }
      v26 = (v22 / v25);
      v27 = (v22 % v25);
      v28 = v27 - *(_DWORD *)(v10 + 232);
      v29 = v26 - *(_DWORD *)(v10 + 228);
      if (v28 < 0 || v29 < 0 || (v30 = *(_DWORD *)(v10 + 240), v28 >= v30) || v29 >= *(_DWORD *)(v10 + 236))
      {
        *(_QWORD *)&v74 = 0;
        *(_OWORD *)v72 = 0u;
        v73 = 0u;
        kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "(rel_sot_idx.x >= 0) && (rel_sot_idx.y >= 0) && (rel_sot_idx.x < codestream->tile_indices.size.x) && (rel_sot_idx.y < codestream->tile_indices.size.y)");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v72);
      }
      v31 = *(_QWORD *)(v10 + 328);
      v32 = kd_compressed_input::get_offset(*(kd_compressed_input **)(v10 + 8));
      v67 = bswap32(v23);
      v33 = v31 + 24 * v28;
      v34 = v30 * v29;
      v35 = (_QWORD *)(v33 + 24 * v34);
      v36 = *(_QWORD *)this;
      v66 = v32 - *(int *)(*(_QWORD *)(*(_QWORD *)this + 32) + 20) - 4;
      if (!*(_QWORD *)(*(_QWORD *)this + 448))
      {
        *(_QWORD *)(v36 + 448) = v66 + v67;
        v41 = *(_QWORD *)(v36 + 72);
        if (v41)
        {
          if (!*(_BYTE *)(v41 + 24) && (!*v35 || *(_QWORD *)(v33 + 24 * (int)v34 + 8)))
          {
            kd_tpart_pointer_server::add_tpart(v41, (_QWORD *)(v33 + 24 * v34), v66);
            if (!(_DWORD)v67)
            {
              *(_QWORD *)(v33 + 24 * (int)v34 + 8) = 0;
              *(_QWORD *)(*(_QWORD *)this + 448) = -1;
            }
          }
        }
      }
      v37 = *(_QWORD *)(v33 + 24 * (int)v34 + 16);
      if (v37 == -1)
      {
LABEL_88:
        v38 = *(_QWORD *)this;
        v39 = *(kd_pp_markers **)(*(_QWORD *)this + 40);
        if (v39)
        {
          kd_pp_markers::ignore_tpart(v39);
          v38 = *(_QWORD *)this;
        }
        v40 = *(_QWORD *)(v38 + 32);
        *(_WORD *)(v40 + 16) = 0;
        *(_DWORD *)(v40 + 20) = 0;
        *(_BYTE *)(v40 + 40) = 0;
        goto LABEL_91;
      }
      if (v37)
      {
        if (*(_BYTE *)(v37 + 328))
          goto LABEL_88;
        if (*(_BYTE *)(v37 + 293))
        {
          if (!*(_BYTE *)(*(_QWORD *)this + 408))
          {
            *(_QWORD *)&v74 = 0;
            *(_OWORD *)v72 = 0u;
            v73 = 0u;
            kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
            (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "codestream->allow_restart");
            (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
            kdu_error::~kdu_error((kdu_error *)v72);
          }
          kd_tile::reinitialize((kd_tile *)v37);
          goto LABEL_91;
        }
      }
      if ((kd_tile *)v37 != this)
      {
        if (*(_QWORD *)(*(_QWORD *)this + 72))
        {
          if (v37)
          {
            if (!*(_QWORD *)(v37 + 32))
            {
              v42 = *(_QWORD *)(v33 + 24 * (int)v34 + 8);
              *(_QWORD *)(v37 + 32) = v42;
              if (!v42)
              {
                *(_QWORD *)(v37 + 32) = *v35;
                v43 = *(_DWORD *)(v37 + 304);
                if (v43 >= 2)
                {
                  for (i = 1; i < v43; ++i)
                  {
                    v45 = *(_QWORD *)(*(_QWORD *)(v37 + 32) + 8);
                    *(_QWORD *)(v37 + 32) = v45;
                    if (!v45)
                    {
                      *(_QWORD *)&v74 = 0;
                      *(_OWORD *)v72 = 0u;
                      v73 = 0u;
                      kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
                      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
                      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "active->tpart_ptrs != NULL");
                      (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
                      kdu_error::~kdu_error((kdu_error *)v72);
                    }
                  }
                }
              }
            }
          }
          goto LABEL_91;
        }
        if (!(_DWORD)v67)
        {
          kd_tile::finished_reading(this);
          return 0;
        }
      }
      if (!v37)
      {
        kd_codestream::create_tile(*(_QWORD *)this, v26 | (v27 << 32));
        goto LABEL_91;
      }
      if (*(_DWORD *)(v37 + 8) != v22)
      {
        *(_QWORD *)&v74 = 0;
        *(_OWORD *)v72 = 0u;
        v73 = 0u;
        kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "active->t_num == sot_tnum");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v72);
      }
      if (*(_DWORD *)(v37 + 304) != v68)
      {
        v70 = 0;
        memset(v69, 0, sizeof(v69));
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v69[0] + 16))(v69, "Missing or out-of-sequence tile-parts for tile number ");
        v75 = 0u;
        v76 = 0u;
        v73 = 0u;
        v74 = 0u;
        *(_OWORD *)v72 = 0u;
        if (BYTE8(v69[0]))
          sprintf(v72, "%x");
        else
          sprintf(v72, "%d");
        (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v69[0] + 16))(v69, v72);
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v69[0] + 16))(v69, " in code-stream!");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      if (v24)
      {
        v46 = *(_DWORD *)(v37 + 300);
        if (v46)
        {
          if (v46 != v24)
          {
            *(_QWORD *)&v74 = 0;
            *(_OWORD *)v72 = 0u;
            v73 = 0u;
            kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "The number of tile-parts for tile number ");
            v47 = kdu_message::operator<<(v72);
            (*(void (**)(_BYTE *, const char *))(*(_QWORD *)v47 + 16))(v47, " is identified by different non-zero values in different SOT markers for the tile!");
            kdu_error::~kdu_error((kdu_error *)v72);
          }
        }
        else
        {
          *(_DWORD *)(v37 + 300) = v24;
        }
      }
      if (*(_BYTE *)(v37 + 290))
        kd_tile::withdraw_from_unloadable_list((uint64_t *)v37);
      kd_codestream::unload_tiles_to_cache_threshold(*(_QWORD *)this);
      v48 = *(kdu_params **)(*(_QWORD *)this + 24);
      v49 = (kdu_params *)kdu_params::access_cluster(v48, "COD");
      v50 = (kdu_params *)kdu_params::access_relation(v49, v22, -1, 0, 1);
      if (!v50)
      {
        *(_QWORD *)&v74 = 0;
        *(_OWORD *)v72 = 0u;
        v73 = 0u;
        kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "cod != NULL");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v72);
      }
      v51 = (kdu_params *)kdu_params::access_cluster(v48, "POC");
      v52 = (kdu_params *)kdu_params::access_relation(v51, v22, -1, 0, 1);
      if (!v52)
      {
        *(_QWORD *)&v74 = 0;
        *(_OWORD *)v72 = 0u;
        v73 = 0u;
        kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "poc != NULL");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v72);
      }
      if (*(_QWORD *)(v37 + 80))
      {
        *(_QWORD *)&v74 = 0;
        *(_OWORD *)v72 = 0u;
        v73 = 0u;
        kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "active->ppt_markers == NULL");
        (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v72);
      }
      if (!kd_marker::read(*(kd_marker **)(*(_QWORD *)this + 32), 0, 0))
      {
LABEL_172:
        if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)this + 8) + 544))
        {
          *(_QWORD *)&v74 = 0;
          *(_OWORD *)v72 = 0u;
          v73 = 0u;
          kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Found non-marker code while looking for SOD marker to terminate a tile-part header.  Chances are that a marker segment length field is incorrect!");
          kdu_error::~kdu_error((kdu_error *)v72);
        }
        return 0;
      }
      do
      {
        v53 = *(_QWORD *)(*(_QWORD *)this + 32);
        v54 = *(unsigned __int16 *)(v53 + 16);
        switch(v54)
        {
          case 65368:
            kd_precinct_pointer_server::add_plt_marker(v37 + 104, v53, v50, v52);
            break;
          case 65377:
            if (!*(_DWORD *)(*(_QWORD *)this + 160))
            {
              *(_QWORD *)&v74 = 0;
              *(_OWORD *)v72 = 0u;
              v73 = 0u;
              kdu_warning::kdu_warning((kdu_warning *)v72, "Kakadu Core Warning:\n");
              (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Profile violation detected (code-stream is technically illegal).  PPT marker segments may not appear within a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.");
              *(_DWORD *)(*(_QWORD *)this + 160) = 2;
              kdu_warning::~kdu_warning((kdu_warning *)v72);
            }
            v55 = *(_QWORD *)(v37 + 80);
            if (!v55)
            {
              v55 = operator new();
              *(_QWORD *)(v55 + 8) = 0;
              *(_QWORD *)(v37 + 80) = v55;
            }
            kd_pp_markers::add_marker(v55, *(_QWORD *)(*(_QWORD *)this + 32));
            break;
          case 65427:
            goto LABEL_150;
          default:
            kdu_params::translate_marker_segment(v48, *(unsigned __int16 *)(v53 + 16), *(unsigned int *)(v53 + 20), *(unsigned __int8 **)(v53 + 32), v22, v68);
            break;
        }
      }
      while ((kd_marker::read(*(kd_marker **)(*(_QWORD *)this + 32), 0, 0) & 1) != 0);
      if (!v54)
        goto LABEL_172;
LABEL_150:
      kdu_params::finalize_all(v48, v22, 1);
      v56 = kd_compressed_input::get_offset(*(kd_compressed_input **)(*(_QWORD *)this + 8));
      v57 = *(kd_pp_markers **)(*(_QWORD *)this + 40);
      if (*(_QWORD *)(v37 + 80))
      {
        if (v57)
        {
          *(_QWORD *)&v74 = 0;
          *(_OWORD *)v72 = 0u;
          v73 = 0u;
          kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Use of both PPM and PPT marker segments is illegal!");
          kdu_error::~kdu_error((kdu_error *)v72);
        }
        v58 = *(_QWORD *)(v37 + 88);
        if (!v58)
        {
          v58 = operator new();
          v59 = *(_QWORD *)(*(_QWORD *)this + 48);
          *(_QWORD *)(v58 + 536) = v58 + 14;
          *(_QWORD *)(v58 + 528) = v58 + 14;
          *(_WORD *)(v58 + 544) = 0;
          *(_QWORD *)v58 = &off_1E1BAC4D0;
          *(_QWORD *)(v58 + 584) = v59;
          *(_QWORD *)(v58 + 552) = 0;
          *(_QWORD *)(v58 + 568) = 0;
          *(_QWORD *)(v58 + 560) = 0;
          *(_QWORD *)(v37 + 88) = v58;
        }
        kd_pp_markers::transfer_tpart(*(kd_pp_markers **)(v37 + 80), (kd_pph_input *)v58);
        v60 = *(kd_pp_markers **)(v37 + 80);
        if (v60)
        {
          kd_pp_markers::~kd_pp_markers(v60);
          MEMORY[0x18D761C30]();
        }
        *(_QWORD *)(v37 + 80) = 0;
        goto LABEL_162;
      }
      v61 = v67;
      if (v57)
      {
        v62 = *(_QWORD *)(v37 + 88);
        if (!v62)
        {
          v62 = operator new();
          v63 = *(_QWORD *)this;
          v64 = *(_QWORD *)(*(_QWORD *)this + 48);
          *(_QWORD *)(v62 + 536) = v62 + 14;
          *(_QWORD *)(v62 + 528) = v62 + 14;
          *(_WORD *)(v62 + 544) = 0;
          *(_QWORD *)v62 = &off_1E1BAC4D0;
          *(_QWORD *)(v62 + 584) = v64;
          *(_QWORD *)(v62 + 552) = 0;
          *(_QWORD *)(v62 + 568) = 0;
          *(_QWORD *)(v62 + 560) = 0;
          *(_QWORD *)(v37 + 88) = v62;
          v57 = *(kd_pp_markers **)(v63 + 40);
        }
        kd_pp_markers::transfer_tpart(v57, (kd_pph_input *)v62);
LABEL_162:
        v61 = v67;
      }
      if ((_DWORD)v61)
      {
        v65 = v66 + v61;
        if (v65 - v56 < 0)
        {
          *(_QWORD *)&v74 = 0;
          *(_OWORD *)v72 = 0u;
          v73 = 0u;
          kdu_error::kdu_error((kdu_error *)v72, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "Assert ");
          (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, "tpart_body_length >= 0");
          (*(void (**)(char *, const char *))(*(_QWORD *)v72 + 16))(v72, " FAILED");
          kdu_error::~kdu_error((kdu_error *)v72);
        }
        kd_precinct_pointer_server::start_tpart_body((uint64_t *)(v37 + 104), v56, v65 - v56, v50, v52, *(_QWORD *)(v37 + 88) != 0, 0);
      }
      else
      {
        kd_precinct_pointer_server::start_tpart_body((uint64_t *)(v37 + 104), v56, 0, v50, v52, *(_QWORD *)(v37 + 88) != 0, 1);
      }
      ++*(_DWORD *)(v37 + 304);
      *(_QWORD *)(*(_QWORD *)this + 440) = v37;
      kd_tile::adjust_unloadability((uint64_t *)v37);
      ++*(_DWORD *)(*(_QWORD *)this + 460);
LABEL_91:
      v7 = *(_QWORD *)(*(_QWORD *)this + 440);
      if ((kd_tile *)v7 == this)
        return 1;
      continue;
    }
    break;
  }
  if (*(_QWORD *)(v10 + 448))
    return 0;
  result = 0;
  *(_QWORD *)(v10 + 448) = -1;
  return result;
}

void sub_187EEAB04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EEAB10(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Exception *v21;

  _Unwind_Resume(v21);
}

float kd_tile_comp::initialize_kernel_parameters(kd_tile_comp *this, int a2, kdu_kernels *a3)
{
  _BYTE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  _DWORD *v25;
  int v26;
  float result;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  BOOL v32;

  v32 = *((_BYTE *)this + 76);
  v5 = (char *)this + 84;
  kd_create_dwt_description(*((_DWORD *)this + 20), a2, *(kdu_params **)(*(_QWORD *)this + 24), *(_DWORD *)(*((_QWORD *)this + 1) + 8), &v32, (BOOL *)this + 84, (BOOL *)this + 85, (unsigned int *)this + 22, (_QWORD *)this + 12, (_QWORD *)this + 14);
  if (*((_BYTE *)this + 76) != v32)
  {
    v31 = 0;
    v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "Assert ");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "reversible == kernel_rev");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v29);
  }
  if (*v5)
  {
    v6 = *((_QWORD *)this + 12);
    *((_QWORD *)this + 13) = v6;
    *((_QWORD *)this + 15) = *((_QWORD *)this + 14);
    LODWORD(v7) = *((_DWORD *)this + 22);
  }
  else
  {
    v8 = *((int *)this + 22);
    v9 = (void *)operator new[]();
    v10 = v9;
    if ((_DWORD)v8)
      bzero(v9, 16 * v8);
    *((_QWORD *)this + 13) = v10;
    v11 = *((unsigned int *)this + 22);
    if ((int)v11 >= 1)
    {
      v12 = 0;
      v13 = (int *)*((_QWORD *)this + 12);
      do
      {
        v14 = *v13;
        v13 += 4;
        v12 += v14;
        --v11;
      }
      while (v11);
    }
    v15 = operator new[]();
    *((_QWORD *)this + 15) = v15;
    v7 = *((unsigned int *)this + 22);
    v6 = *((_QWORD *)this + 12);
    if ((int)v7 >= 1)
    {
      v16 = 0;
      v17 = 0;
      v18 = *((_QWORD *)this + 13);
      do
      {
        v19 = (unsigned int *)(v6 + 16 * v16);
        v20 = v18 + 16 * v16;
        v21 = *v19;
        *(_DWORD *)v20 = v21;
        *(_DWORD *)(v20 + 4) = (~(2 * v16) & 2) - (v21 + v19[1]);
        *(_QWORD *)(v20 + 8) = *((_QWORD *)v19 + 1);
        if ((int)v21 <= 0)
        {
          v23 = v21 + v17;
        }
        else
        {
          v22 = *((_QWORD *)this + 14);
          v23 = v21 + v17;
          v24 = v17 - 1;
          v25 = (_DWORD *)(v15 + 4 * v17);
          do
            *v25++ = *(_DWORD *)(v22 + 4 * (v24 + (int)v21--));
          while (v21);
        }
        ++v16;
        v17 = v23;
      }
      while (v16 != v7);
    }
  }
  kdu_kernels::init((uint64_t)a3, v7, v6, *((int **)this + 14), *((_BYTE *)this + 84), *((_BYTE *)this + 85), *((_BYTE *)this + 76));
  v28 = 0;
  kdu_kernels::get_impulse_response(a3, 2, (_DWORD *)&v28 + 1, (_DWORD *)this + 34, (_DWORD *)this + 35);
  kdu_kernels::get_impulse_response(a3, 3, &v28, (_DWORD *)this + 36, (_DWORD *)this + 37);
  if (SHIDWORD(v28) < *((_DWORD *)this + 35)
    || SHIDWORD(v28) < -*((_DWORD *)this + 34)
    || (int)v28 < *((_DWORD *)this + 37)
    || (int)v28 < -*((_DWORD *)this + 36))
  {
    v31 = 0;
    v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "Assert ");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "(low_hlen >= low_support_max) && (low_hlen >= -low_support_min) && (high_hlen >= high_support_max) && (high_hlen >= -high_support_min)");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v29);
  }
  v26 = *((_DWORD *)a3 + 2);
  *((_DWORD *)this + 32) = *((_DWORD *)a3 + 8);
  result = *((float *)a3 + 9);
  *((float *)this + 33) = result;
  if (v26 != *((_DWORD *)this + 22))
  {
    v31 = 0;
    v29 = 0u;
    v30 = 0u;
    kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "Assert ");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "nsteps == kernel_num_steps");
    (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v29);
  }
  return result;
}

void sub_187EEB078(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EEB084(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Exception *v13;

  _Unwind_Resume(v13);
}

float kd_tile::find_multicomponent_energy_gain(kd_tile *this, int a2, int a3)
{
  uint64_t v4;
  float v5;
  int v6;
  int v7;
  int v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v19;
  double v20;
  float *v21;
  int v22;
  double v23;
  uint64_t v24;
  uint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v33;
  _DWORD *v34;
  double v35;
  double v36;
  double v37;
  int *v41;
  int v42;
  int v43[8];
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (a3 && *(_DWORD *)(*(_QWORD *)this + 184))
  {
    v44 = 0;
    memset(v43, 0, sizeof(v43));
    kdu_error::kdu_error((kdu_error *)v43, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(_QWORD *)v43 + 16))(v43, "Assert ");
    (*(void (**)(int *, const char *))(*(_QWORD *)v43 + 16))(v43, "codestream->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS");
    (*(void (**)(int *, const char *))(*(_QWORD *)v43 + 16))(v43, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v43);
  }
  v4 = *((_QWORD *)this + 32);
  if (!v4)
  {
    if (a2 > 2 || !*((_BYTE *)this + 286) || *((int *)this + 47) < 3)
    {
      v26 = *(_QWORD *)(*(_QWORD *)this + 320);
      if (!a3
        || (v27 = *(_DWORD *)(v26 + 48 * a2 + 16), v20 = 0.0, (v27 & 0x80000000) == 0)
        && *(_BYTE *)(*((_QWORD *)this + 34) + 224 * v27 + 185))
      {
        v28 = 1 << *(_DWORD *)(v26 + 48 * a2);
        v20 = 1.0 / (float)v28 * (1.0 / (float)v28);
      }
      goto LABEL_61;
    }
    memset(v43, 0, 24);
    v24 = *((_QWORD *)this + 34);
    if (*(_BYTE *)(v24 + 224 * a2 + 76))
    {
      if (a2 == 1)
      {
        *(int64x2_t *)v43 = vdupq_n_s64(0x3FB0000000000000uLL);
        *(_QWORD *)&v43[4] = 0x3FE2000000000000;
        goto LABEL_55;
      }
      if (a2)
      {
        *(_QWORD *)&v43[4] = 0x3FB0000000000000;
        _Q0 = xmmword_18820C460;
LABEL_54:
        *(_OWORD *)v43 = _Q0;
LABEL_55:
        v33 = 0;
        v34 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)this + 320) + 16);
        v20 = 0.0;
        do
        {
          if (!a3 || (*v34 & 0x80000000) == 0 && *(_BYTE *)(v24 + 224 * *v34 + 185))
          {
            v35 = 1.0 / (float)(1 << *(v34 - 4));
            v20 = v20 + *(double *)&v43[v33] * v35 * v35;
          }
          v33 += 2;
          v34 += 12;
        }
        while (v33 != 6);
        goto LABEL_61;
      }
    }
    else
    {
      if (a2 == 1)
      {
        *(_OWORD *)&v43[2] = xmmword_18820C470;
        goto LABEL_55;
      }
      if (a2)
      {
        _Q0 = xmmword_18820C480;
        goto LABEL_54;
      }
    }
    *(_QWORD *)&v43[4] = 0x3FF0000000000000;
    __asm { FMOV            V0.2D, #1.0 }
    goto LABEL_54;
  }
  v5 = 1.0;
  v6 = a2;
  v7 = a2;
  while (1)
  {
    v42 = -1;
    v43[0] = 0;
    v8 = *(_DWORD *)(v4 + 32);
    v41 = (int *)(v4 + 32);
    if (v8 <= 0)
      break;
LABEL_10:
    for (i = 0; i < v8; ++i)
    {
      v10 = *(_QWORD *)(v4 + 40);
      if (!a3 || *(_DWORD *)(v10 + 152 * i + 36))
      {
        v11 = v10 + 152 * i;
        v14 = *(_DWORD *)(v11 + 8);
        v13 = (int *)(v11 + 8);
        v12 = v14;
        if (v14 >= 1)
        {
          v15 = 0;
          v16 = v10 + 152 * i;
          do
          {
            if (!a3 || *(_BYTE *)(*(_QWORD *)(v16 + 24) + v15))
            {
              v17 = *(_DWORD *)(*(_QWORD *)(v16 + 16) + 4 * v15);
              if (v17 >= v6 && v17 <= v7)
              {
                v19 = *(_QWORD *)(v4 + 48);
                if (v19)
                  v5 = *(float *)(*(_QWORD *)(v19 + 24) + 48 * v17 + 44);
                kd_mct_block::analyze_sensitivity(v16, v15, v5, v43, &v42, a3);
                v12 = *v13;
              }
            }
            ++v15;
          }
          while (v15 < v12);
          v8 = *v41;
        }
      }
    }
    v7 = v42;
    v6 = v43[0];
    v4 = *(_QWORD *)(v4 + 56);
    if (!v4)
    {
      v20 = 0.0;
      if (v43[0] <= v42)
      {
        v21 = (float *)(*(_QWORD *)(*((_QWORD *)this + 33) + 24) + 48 * v43[0] + 44);
        v22 = v42 - v43[0] + 1;
        do
        {
          if (*((_BYTE *)v21 - 4) || (a3 & 1) == 0)
          {
            v23 = (float)(*v21 / (float)(1 << *((_DWORD *)v21 - 11)));
            v20 = v20 + v23 * v23;
          }
          v21 += 12;
          --v22;
        }
        while (v22);
      }
      goto LABEL_61;
    }
  }
  while (1)
  {
    v4 = *(_QWORD *)(v4 + 56);
    if (!v4)
      break;
    v42 = -1;
    v43[0] = 0;
    v8 = *(_DWORD *)(v4 + 32);
    if (v8 >= 1)
    {
      v6 = 0;
      v41 = (int *)(v4 + 32);
      v7 = -1;
      goto LABEL_10;
    }
  }
  v20 = 0.0;
LABEL_61:
  v36 = (double)(1 << *(_DWORD *)(*(_QWORD *)(*(_QWORD *)this + 312) + 104 * a2 + 16));
  v37 = v20 * (v36 * v36);
  if (v37 < 0.0001)
    return 0.0001;
  return v37;
}

void sub_187EEB51C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EEB528()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kd_resolution::build_decomposition_structure(kd_resolution *this, kdu_params *a2, kdu_kernels *a3)
{
  uint64_t v4;
  uint64_t v5;
  __int16 *v6;
  __int16 *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  int v14;
  char *v15;
  __int16 v16;
  unsigned __int8 v17;
  unint64_t i;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t j;
  unsigned int v25;
  unsigned __int8 v26;
  int v27;
  uint64_t v28;
  _OWORD *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  float *v45;
  uint64_t v46;
  float bibo_gain;
  double *bibo_gains;
  uint64_t v49;
  float *v50;
  double v51;
  float v52;
  float v53;
  double *v54;
  uint64_t v55;
  float *v56;
  double v57;
  float v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t v61;
  __int16 v63;
  char v64;
  double v65;
  uint64_t v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  _WORD v70[58];
  _WORD v71[52];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)v70 = 3;
  memset(v71, 0, 98);
  memset(&v70[2], 0, 98);
  *((_BYTE *)this + 222) = 1;
  if (*((_BYTE *)this + 24))
  {
    if (a2)
    {
      kdu_params::get(a2, "Cdecomp", *((unsigned __int8 *)this + 25) - 1, 0, (int *)v70, 1, 1, 1);
      v4 = *(unsigned int *)v70;
    }
    else
    {
      v4 = 3;
    }
    v5 = cod_params::transpose_decomp((cod_params *)v4);
    *((_BYTE *)this + 222) = cod_params::expand_decomp_bands(*(unsigned int *)v70, (uint64_t)v71, v6) - 1;
    cod_params::expand_decomp_bands(v5, (uint64_t)&v70[2], v7);
  }
  else
  {
    v71[0] = 0;
  }
  if (*((_QWORD *)this + 30))
  {
    v69 = 0;
    v67 = 0u;
    v68 = 0u;
    kdu_error::kdu_error((kdu_error *)&v67, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "Assert ");
    (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "subbands == NULL");
    (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v67);
  }
  v8 = *((unsigned __int8 *)this + 222);
  if (v8 > 3)
  {
    v10 = 144 * v8;
    v9 = (char *)operator new[]();
    v11 = 0;
    do
    {
      v12 = &v9[v11];
      *((_OWORD *)v12 + 1) = 0uLL;
      *((_OWORD *)v12 + 2) = 0uLL;
      *(_OWORD *)(v12 + 76) = 0uLL;
      *(_OWORD *)(v12 + 92) = 0uLL;
      *(_OWORD *)(v12 + 108) = 0uLL;
      v11 += 144;
      *(_OWORD *)(v12 + 124) = 0uLL;
    }
    while (v10 != v11);
    *((_QWORD *)this + 31) = v9;
    LODWORD(v8) = *((unsigned __int8 *)this + 222);
  }
  else
  {
    v9 = (char *)this + 256;
  }
  *((_QWORD *)this + 30) = v9;
  if ((_DWORD)v8)
  {
    v13 = 0;
    v14 = *((unsigned __int8 *)this + 24);
    v15 = v9 + 50;
    do
    {
      *(_QWORD *)(v15 - 50) = 0;
      *(_QWORD *)(v15 - 42) = this;
      *v15 = 1;
      if (v14)
        v16 = v71[v13 + 1];
      else
        v16 = 0;
      v15[5] = v13;
      *((_WORD *)v15 + 1) = v16;
      v15 += 144;
      ++v13;
    }
    while (v8 != v13);
    v17 = *((_BYTE *)this + 222);
    if (v17)
    {
      for (i = 0; i < v17; *(_BYTE *)(v22 + 144 * i++ + 56) = v20)
      {
        v19 = *((unsigned __int8 *)this + 24);
        if (*((_BYTE *)this + 24))
          v19 = (unsigned __int16)v70[i + 3];
        v20 = 0;
        v21 = __rev16(v19);
        v22 = *((_QWORD *)this + 30);
        if ((v17 & 0xFE) != 0)
          v23 = v17;
        else
          v23 = 1;
        for (j = 52; *(unsigned __int16 *)(v22 + j) != v21; j += 144)
        {
          if (v23 == ++v20)
          {
            v69 = 0;
            v67 = 0u;
            v68 = 0u;
            kdu_error::kdu_error((kdu_error *)&v67, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "Assert ");
            (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "k < num_subbands");
            (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v67);
          }
        }
      }
    }
  }
  if (*((_QWORD *)this + 28))
  {
    v69 = 0;
    v67 = 0u;
    v68 = 0u;
    kdu_error::kdu_error((kdu_error *)&v67, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "Assert ");
    (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "intermediate_nodes == NULL");
    (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v67);
  }
  v25 = 0;
  v26 = 0;
  *((_BYTE *)this + 223) = 0;
  v27 = *(_DWORD *)v70;
  do
  {
    v25 += 2;
    if (((v27 >> v25) & 3) != 0)
      *((_BYTE *)this + 223) = ++v26;
  }
  while (v25 < 0x1D);
  v28 = operator new[]();
  if (v26)
  {
    v29 = (_OWORD *)(v28 + 52);
    v30 = 136 * v26;
    do
    {
      *(_OWORD *)((char *)v29 - 20) = 0uLL;
      *(_OWORD *)((char *)v29 - 36) = 0uLL;
      *v29 = 0uLL;
      v29[1] = 0uLL;
      v29 = (_OWORD *)((char *)v29 + 136);
      v30 -= 136;
    }
    while (v30);
  }
  *((_QWORD *)this + 28) = v28;
  *((_QWORD *)this + 5) = this;
  *((_BYTE *)this + 82) = 0;
  if (*((_BYTE *)this + 223))
  {
    v31 = 0;
    v32 = 88;
    do
    {
      if (!*((_BYTE *)this + 24))
      {
        v69 = 0;
        v67 = 0u;
        v68 = 0u;
        kdu_error::kdu_error((kdu_error *)&v67, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "Assert ");
        (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "res_level > 0");
        (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v67);
      }
      v33 = 0;
      v34 = *((_QWORD *)this + 28) + 136 * v31;
      *(_QWORD *)v34 = 0;
      *(_QWORD *)(v34 + 8) = this;
      *(_BYTE *)(v34 + 50) = 0;
      *(_QWORD *)(v34 + 128) = 0;
      do
      {
        *(_QWORD *)(*((_QWORD *)this + 28) + v32 + v33) = 0;
        v33 += 8;
      }
      while (v33 != 32);
      ++v31;
      v32 += 136;
    }
    while (v31 < *((unsigned __int8 *)this + 223));
  }
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_BYTE *)this + 221) = 1;
  if (*((_BYTE *)this + 24))
  {
    v35 = 0;
    v36 = *((_QWORD *)this + 1);
    v37 = *(_QWORD *)(*(_QWORD *)this + 312);
    v38 = *(_DWORD *)(v36 + 24);
    v66 = 0;
    v39 = v37 + 104 * v38 + *((unsigned __int8 *)this + 25);
    v40 = *(unsigned __int8 *)(v39 + 21) - *((unsigned __int8 *)this + 26);
    v41 = v40 + 2 * (*(unsigned __int8 *)(v39 + 54) - *((unsigned __int8 *)this + 27));
    if ((v40 & 1) != 0)
      v35 = *(_BYTE *)(v36 + 88);
    *((_BYTE *)this + 152) = v35;
    if ((v41 & 2) != 0)
      v42 = *(_BYTE *)(v36 + 88);
    else
      v42 = 0;
    *((_BYTE *)this + 153) = v42;
    v45 = (float *)operator new[]();
    v46 = *((unsigned __int8 *)this + 152);
    *((_QWORD *)this + 20) = v45;
    bibo_gain = kdu_kernels::get_bibo_gain(a3, *((unsigned __int8 *)this + 26), 0, 0);
    *v45 = bibo_gain;
    if (*((_BYTE *)this + 152))
    {
      *(_QWORD *)&v67 = 0;
      v65 = 0.0;
      bibo_gains = (double *)kdu_kernels::get_bibo_gains(a3, *((unsigned __int8 *)this + 26), 0, 0, (double *)&v67, &v65);
      v49 = *((unsigned __int8 *)this + 152);
      if (*((_BYTE *)this + 152))
      {
        v50 = v45 + 1;
        do
        {
          v51 = *bibo_gains++;
          v52 = v51;
          *v50++ = v52;
          --v49;
        }
        while (v49);
      }
    }
    v53 = kdu_kernels::get_bibo_gain(a3, *((unsigned __int8 *)this + 27), 0, 0);
    v45[v46 + 1] = v53;
    if (*((_BYTE *)this + 153))
    {
      *(_QWORD *)&v67 = 0;
      v65 = 0.0;
      v54 = (double *)kdu_kernels::get_bibo_gains(a3, *((unsigned __int8 *)this + 27), 0, 0, (double *)&v67, &v65);
      v55 = *((unsigned __int8 *)this + 153);
      if (*((_BYTE *)this + 153))
      {
        v56 = &v45[v46 + 2];
        do
        {
          v57 = *v54++;
          v58 = v57;
          *v56++ = v58;
          --v55;
        }
        while (v55);
      }
    }
    BYTE2(v65) = 0;
    LOWORD(v65) = 0;
    v64 = 0;
    v63 = 0;
    if (v41 != (v70[0] & 3))
    {
      v69 = 0;
      v67 = 0u;
      v68 = 0u;
      kdu_error::kdu_error((kdu_error *)&v67, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "Assert (dfs_mask == (decomp & 3)) FAILED! \n");
      kdu_error::~kdu_error((kdu_error *)&v67);
    }
    v59 = 0;
    v60 = 0;
    *(int *)v70 >>= 2;
    do
    {
      v61 = v59 + 1;
      if (v59 + 1 == (v41 & ((_DWORD)v59 + 1)))
      {
        *((_QWORD *)this + v59 + 16) = create_child_node((uint64_t)this + 32, (int)v59 + 1, v41, *((_QWORD *)this + 28), &v66, *((_QWORD *)this + 30), (_DWORD *)&v66 + 1, v70[0] & 0x3FF, 1, (int)v59 + 1, 0, 0, 0, (BOOL *)&v65, 0, (BOOL *)&v63, a3);
        *(int *)v70 >>= 10;
        v60 = v66;
        if ((int)v66 > *((unsigned __int8 *)this + 223) || SHIDWORD(v66) > *((unsigned __int8 *)this + 222))
        {
          v69 = 0;
          v67 = 0u;
          v68 = 0u;
          kdu_error::kdu_error((kdu_error *)&v67, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "Assert ");
          (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "(next_inode_idx <= (int) num_intermediate_nodes) && (next_band_idx <= (int) num_subbands)");
          (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, " FAILED");
          kdu_error::~kdu_error((kdu_error *)&v67);
        }
      }
      ++v59;
    }
    while (v61 != 3);
    if (__PAIR64__(v60, HIDWORD(v66)) != __PAIR64__(*((unsigned __int8 *)this + 223), *((unsigned __int8 *)this + 222)))
    {
      v69 = 0;
      v67 = 0u;
      v68 = 0u;
      kdu_error::kdu_error((kdu_error *)&v67, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "Assert ");
      (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, "(next_inode_idx == (int) num_intermediate_nodes) && (next_band_idx == (int) num_subbands)");
      (*(void (**)(__int128 *, const char *))(v67 + 16))(&v67, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v67);
    }
  }
  else
  {
    v43 = *((_QWORD *)this + 30);
    *((_QWORD *)this + 15) = v43;
    *(_QWORD *)v43 = (char *)this + 32;
    *(_OWORD *)(v43 + 16) = *((_OWORD *)this + 3);
    v44 = *((_QWORD *)this + 30);
    *(_WORD *)(v44 + 48) = 514;
    *(_BYTE *)(v44 + 54) = 0;
  }
}

void sub_187EEBE38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EEBE44(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Exception *v21;

  _Unwind_Resume(v21);
}

uint64_t check_coding_partition(uint64_t result, unint64_t a2)
{
  unsigned int v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unsigned int v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v2 = a2;
  if ((result & 0xFFFFFFFEFFFFFFFELL) != 0)
  {
    v9 = 0;
    v7 = 0u;
    v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v7 + 16))(&v7, "Coding partitions (code-blocks and precinct partitions) must have origin coordinates equal to 1 or 0 only!");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  v3 = HIDWORD(a2);
  if (SHIDWORD(a2) >= 2)
  {
    while ((v3 & 1) == 0)
    {
      LODWORD(v4) = v3 >> 1;
      v5 = v3 > 3;
      LODWORD(v3) = v3 >> 1;
      if (!v5)
        goto LABEL_8;
    }
    goto LABEL_15;
  }
  v4 = HIDWORD(a2);
LABEL_8:
  if ((_DWORD)v4 != 1)
    goto LABEL_15;
  if ((int)a2 >= 2)
  {
    while ((v2 & 1) == 0)
    {
      v6 = v2 >> 1;
      v5 = v2 > 3;
      v2 >>= 1;
      if (!v5)
        goto LABEL_14;
    }
    goto LABEL_15;
  }
  v6 = a2;
LABEL_14:
  if (v6 != 1)
  {
LABEL_15:
    v9 = 0;
    v7 = 0u;
    v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v7 + 16))(&v7, "Coding partitions (namely, code-block and precinct partitions) must have exact power-of-2 dimensions!");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  return result;
}

void sub_187EEBFC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EEBFD0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

unint64_t get_partition_indices(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  unsigned int v5;
  unint64_t v6;
  unsigned int v7;
  _DWORD *exception;

  v4 = (HIDWORD(a3) - HIDWORD(a1));
  v5 = a3 - a1;
  if (!(_DWORD)a2)
    goto LABEL_15;
  v6 = HIDWORD(a2);
  if (!HIDWORD(a2))
    goto LABEL_15;
  if (SHIDWORD(a2) <= 1)
    LODWORD(v6) = 1;
  v4 = (v4 & 0x80000000) != 0 ? ~(~(_DWORD)v4 / v6) : v4 / v6;
  v7 = (int)a2 <= 1 ? 1 : a2;
  if ((v5 & 0x80000000) != 0)
    v5 = ~(~v5 / v7);
  else
    v5 /= v7;
  if ((int)a3 - (int)a1 + a4 <= 0)
  {
    if ((v4 & 0x80000000) != 0)
    {
LABEL_19:
      exception = __cxa_allocate_exception(4uLL);
      *exception = -50;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
  }
  else
  {
LABEL_15:
    if ((v4 & 0x80000000) != 0)
      goto LABEL_19;
  }
  if ((v5 & 0x80000000) != 0)
    goto LABEL_19;
  return v5 | (unint64_t)(v4 << 32);
}

uint64_t kdu_dims::operator&=(_DWORD *a1, int *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *a1;
  v2 = a1[1];
  v4 = *a2;
  v5 = a2[1];
  v6 = a2[3] + v5;
  if (a1[3] + v2 < v6)
    v6 = a1[3] + v2;
  if (a1[2] + *a1 >= a2[2] + *a2)
    v7 = a2[2] + v4;
  else
    v7 = a1[2] + *a1;
  if (v2 < v5)
  {
    a1[1] = v5;
    v2 = v5;
  }
  if (v3 < v4)
  {
    *a1 = v4;
    v3 = v4;
  }
  v8 = (v6 - v2);
  v9 = (v7 - v3);
  *((_QWORD *)a1 + 1) = v9 | (v8 << 32);
  if ((v8 & 0x80000000) != 0)
  {
    a1[3] = 0;
    if ((v9 & 0x80000000) == 0)
      return *(_QWORD *)a1;
LABEL_14:
    a1[2] = 0;
    return *(_QWORD *)a1;
  }
  if ((v9 & 0x80000000) != 0)
    goto LABEL_14;
  return *(_QWORD *)a1;
}

uint64_t kd_resolution::complete_initialization(kd_resolution *this)
{
  int v2;
  _OWORD *v3;
  _DWORD *v4;
  int *v5;
  char v6;
  int v7;
  char v8;
  char v9;
  char v10;
  uint64_t result;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  unsigned __int8 *v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  BOOL v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;

  v2 = 0;
  *((_DWORD *)this + 54) = 0;
  v3 = (_OWORD *)((char *)this + 168);
  v4 = (_DWORD *)((char *)this + 100);
  v5 = (int *)((char *)this + 48);
  v6 = 1;
  do
  {
    v7 = 0;
    v8 = v6;
    v38 = v2;
    v9 = 1;
    do
    {
      v10 = v9;
      *(_OWORD *)v4 = *v3;
      *(int32x2_t *)((char *)this + 100) = vmla_s32(*(int32x2_t *)((char *)this + 100), *(int32x2_t *)((char *)this + 108), vadd_s32(*(int32x2_t *)((char *)this + 184), (int32x2_t)__PAIR64__(v7, v38)));
      result = kdu_dims::operator&=(v4, v5);
      if (*((int *)this + 28) >= 1 && *((int *)this + 27) >= 1)
      {
        if (*((_BYTE *)this + 223))
        {
          v12 = 0;
          v13 = 0;
          do
          {
            v14 = *((_QWORD *)this + 28) + v12;
            LODWORD(v15) = *(_DWORD *)(*(_QWORD *)v14 + 68);
            LODWORD(v16) = *(_DWORD *)(*(_QWORD *)v14 + 72);
            v17 = *(unsigned __int8 *)(v14 + 48);
            v18 = *(unsigned __int8 *)(v14 + 49);
            v19 = *(_DWORD *)(*(_QWORD *)v14 + 80) + v16;
            v20 = *(_DWORD *)(*(_QWORD *)v14 + 76) + v15;
            result = ((int)(v19 - v17 + 1) >> 1);
            if (v17 <= 1)
              v16 = ((int)(v16 - v17 + 1) >> 1);
            else
              v16 = v16;
            if (v17 <= 1)
              v19 = (int)(v19 - v17 + 1) >> 1;
            if (v18 <= 1)
              v15 = ((int)(v15 - v18 + 1) >> 1);
            else
              v15 = v15;
            if (v18 <= 1)
              v20 = (int)(v20 - v18 + 1) >> 1;
            *(_QWORD *)(v14 + 68) = v15 | (v16 << 32);
            *(_QWORD *)(v14 + 76) = (v20 - v15) | ((unint64_t)(v19 - v16) << 32);
            ++v13;
            v12 += 136;
          }
          while (v13 < *((unsigned __int8 *)this + 223));
        }
        if (*((_BYTE *)this + 222))
        {
          v21 = 0;
          v22 = 0;
          do
          {
            v23 = *((_QWORD *)this + 30);
            v24 = (unsigned __int8 *)(v23 + 144 * v21);
            v25 = *(_DWORD *)(*(_QWORD *)v24 + 68);
            LODWORD(v26) = *(_DWORD *)(*(_QWORD *)v24 + 72);
            v27 = *(_DWORD *)(*(_QWORD *)v24 + 76);
            v28 = v24[48];
            v29 = v24[49];
            v30 = v27 + v25;
            if (v28 <= 1)
              v26 = ((int)(v26 - v28 + 1) >> 1);
            else
              v26 = v26;
            v31 = (int)(v30 - v29 + 1) >> 1;
            v32 = v29 > 1;
            if (v29 <= 1)
              v33 = ((int)(v25 - v29 + 1) >> 1);
            else
              v33 = v25;
            if (v32)
              v34 = v30;
            else
              v34 = v31;
            result = get_partition_indices(*(_QWORD *)(v23 + 144 * v21 + 76), *(_QWORD *)(v23 + 144 * v21 + 84), v33 | (v26 << 32), v34 - (int)v33);
            v22 += HIDWORD(v35) * v35;
            if (HIDWORD(v35) * (int)v35 >= 2)
            {
              do
              {
                v36 = ((HIDWORD(v35) + 1) >> 1);
                v37 = (((int)v35 + 1) >> 1);
                v35 = v37 | (v36 << 32);
                LODWORD(v36) = v36 * v37;
                v22 += v36;
              }
              while ((int)v36 > 1);
            }
            ++v21;
          }
          while (v21 < *((unsigned __int8 *)this + 222));
        }
        else
        {
          v22 = 0;
        }
        if (v22 > *((_DWORD *)this + 54))
          *((_DWORD *)this + 54) = v22;
      }
      v9 = 0;
      v7 = 1;
    }
    while ((v10 & 1) != 0);
    v6 = 0;
    v2 = 1;
  }
  while ((v8 & 1) != 0);
  return result;
}

uint64_t kd_tile::set_elements_of_interest(int **this)
{
  int **v1;
  int *v2;
  int v3;
  uint64_t result;
  unint64_t v5;
  int *v6;
  int *v7;
  int *v8;
  int v9;
  int *v10;
  int *v11;
  BOOL v12;
  int *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  BOOL v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  int *v28;
  unint64_t v29;
  unsigned int v30;
  int *v31;
  int *v32;
  _QWORD *v33;
  uint64_t v34;
  int *v35;
  int *v36;
  int *v37;
  int *v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  int v56;
  BOOL v57;
  uint64_t v58;
  unsigned int v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  BOOL v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  uint64_t v71;
  unint64_t v72;
  unsigned __int8 *v73;
  int v74;
  uint64_t v75;
  unint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  unsigned int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  unsigned int v88;
  int v89;
  int v90;
  unsigned int v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  unsigned __int8 *v95;
  int v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  _DWORD *v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  unsigned int v106;
  unsigned int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  unsigned int v113;
  int v114;
  int v115;
  unsigned int v116;
  int v117;
  uint64_t v118;
  _QWORD *v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  int *v127;
  _BYTE *v128;
  uint64_t v129;
  unint64_t v130;
  int **v131;
  int v132;
  _QWORD *v133;
  int *v134;
  unsigned __int8 *v135;
  _OWORD *v136;
  _BYTE *v137;
  uint64_t *v138;
  uint64_t v139;
  uint64_t v140;
  int *v141;
  __int128 v142;
  __int128 v143;
  uint64_t v144;

  v1 = this;
  v2 = *this;
  if (this[32] && !*((_QWORD *)v2 + 2) && !v2[46])
  {
    kd_mct_stage::apply_output_restrictions(this[33], *((_QWORD *)v2 + 40), 0, 0);
    v2 = *v1;
  }
  v3 = v2[63];
  if (v3 >= *((_DWORD *)v1 + 48))
    v3 = *((_DWORD *)v1 + 48);
  *((_DWORD *)v1 + 49) = v3;
  v142 = *(_OWORD *)((char *)v1 + 212);
  result = kdu_dims::operator&=(&v142, v2 + 66);
  *(_OWORD *)((char *)v1 + 228) = v142;
  if (*((_QWORD *)*v1 + 1) && !*((_BYTE *)*v1 + 417))
  {
    *((_DWORD *)v1 + 50) = *((_DWORD *)v1 + 49);
    *((_DWORD *)v1 + 52) = 0;
    v132 = 1;
  }
  else
  {
    v132 = 0;
  }
  if (*((int *)v1 + 47) >= 1)
  {
    v5 = 0;
    v131 = v1;
    while (1)
    {
      v6 = v1[34];
      v7 = &v6[56 * v5];
      *((_BYTE *)v7 + 185) = 1;
      v7[39] = -1082130432;
      v8 = *v1;
      if (!*((_QWORD *)*v1 + 2))
        break;
      LOBYTE(v6[56 * v5 + 46]) = 1;
LABEL_21:
      v13 = &v6[56 * v5];
      v14 = v13[7];
      if (!*(_QWORD *)(v13 + 7))
      {
        v144 = 0;
        v142 = 0u;
        v143 = 0u;
        kdu_error::kdu_error((kdu_error *)&v142, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v142 + 16))(&v142, "File corruption: tc->sub_sampling = (0,0)\n");
        kdu_error::~kdu_error((kdu_error *)&v142);
      }
      v15 = *((_DWORD *)v1 + 57);
      v16 = *((_DWORD *)v1 + 58);
      v17 = *((_DWORD *)v1 + 59);
      v18 = *((_DWORD *)v1 + 60);
      if (v13[8] <= 1)
        v19 = 1;
      else
        v19 = v13[8];
      if (v16 <= 0)
        v20 = -(int)(-v16 / v19);
      else
        v20 = (v16 - 1) / v19 + 1;
      v21 = __OFADD__(v18, v16);
      v22 = v18 + v16;
      if ((v22 < 0) ^ v21 | (v22 == 0))
        v23 = -(int)(-v22 / v19);
      else
        v23 = (v22 - 1) / v19 + 1;
      if (v14 <= 1)
        v24 = 1;
      else
        v24 = v14;
      if (v15 <= 0)
        v25 = -(int)(-v15 / v24);
      else
        v25 = (v15 - 1) / v24 + 1;
      v21 = __OFADD__(v17, v15);
      v26 = v17 + v15;
      if ((v26 < 0) ^ v21 | (v26 == 0))
        v27 = -(int)(-v26 / v24);
      else
        v27 = (v26 - 1) / v24 + 1;
      v130 = v5;
      v28 = &v6[56 * v5];
      *(_QWORD *)(v28 + 13) = v25 | (unint64_t)(v20 << 32);
      v136 = v28 + 13;
      v29 = (v27 - v25) | ((unint64_t)(v23 - v20) << 32);
      v30 = v28[17];
      *(_QWORD *)(v28 + 15) = v29;
      LODWORD(v29) = v30 - (*v1)[61];
      v28[18] = v29;
      v31 = v28 + 18;
      if ((v29 & 0x80000000) == 0)
      {
        v32 = &v6[56 * v5];
        v34 = *((_QWORD *)v32 + 22);
        v33 = v32 + 44;
        if (!v34)
        {
          v144 = 0;
          v142 = 0u;
          v143 = 0u;
          kdu_error::kdu_error((kdu_error *)&v142, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v142 + 16))(&v142, "File corruption: tc->resolutions = NULL\n");
          kdu_error::~kdu_error((kdu_error *)&v142);
        }
        if ((v30 & 0x80000000) == 0)
        {
          v35 = &v6[56 * v130];
          v36 = v35 + 34;
          v37 = v35 + 35;
          v38 = v35 + 36;
          v39 = v35 + 37;
          v137 = v35 + 46;
          v40 = v30;
          v133 = v33;
          v134 = v31;
          v141 = v35 + 37;
          do
          {
            v140 = *v33;
            v41 = *v33 + 704 * v40;
            v44 = *(_QWORD *)(v41 + 32);
            v42 = v41 + 32;
            v43 = v44;
            if (v44)
            {
              v45 = *(_QWORD *)(v43 + 32);
              v46 = *(_QWORD *)(v43 + 40);
              v47 = *(unsigned __int8 *)(v42 + 48);
              v48 = *(unsigned __int8 *)(v42 + 49);
              if (v40 >= *v31)
              {
                v64 = HIDWORD(v46) + HIDWORD(v45);
                LODWORD(v46) = v46 + v45;
                v65 = (int)(HIDWORD(v46) + HIDWORD(v45) - v47 + 1) >> 1;
                v66 = v47 > 1;
                if (v47 <= 1)
                  v67 = ((int)(HIDWORD(v45) - v47 + 1) >> 1);
                else
                  v67 = HIDWORD(v45);
                if (!v66)
                  v64 = v65;
                if (v48 <= 1)
                  v45 = ((int)(v45 - v48 + 1) >> 1);
                else
                  v45 = v45;
                if (v48 <= 1)
                  v61 = (int)(v46 - v48 + 1) >> 1;
                else
                  v61 = v46;
                v62 = v45 | (v67 << 32);
                v63 = (v64 - v67);
              }
              else
              {
                v49 = *v36;
                v50 = *v37;
                v51 = HIDWORD(v46) + HIDWORD(v45);
                v52 = v46 + v45;
                if (*(_BYTE *)(v42 + 48))
                  v53 = *v39;
                else
                  v53 = *v37;
                if (*(_BYTE *)(v42 + 48))
                  v54 = *v38;
                else
                  v54 = *v36;
                v55 = (int)(HIDWORD(v45) - (v53 + v47) + 1) >> 1;
                v56 = (int)(v51 - (v54 + v47) + 1) >> 1;
                v57 = v47 > 1;
                if (v47 <= 1)
                  v58 = v55;
                else
                  v58 = HIDWORD(v45);
                if (!v57)
                  v51 = v56;
                if (*(_BYTE *)(v42 + 49))
                {
                  v50 = *v39;
                  v49 = *v38;
                }
                v59 = (int)(v45 - (v50 + v48) + 1) >> 1;
                v60 = (int)(v52 - (v49 + v48) + 1) >> 1;
                if (v48 <= 1)
                  v45 = v59;
                else
                  v45 = v45;
                if (v48 <= 1)
                  v61 = v60;
                else
                  v61 = v52;
                v62 = v45 | (v58 << 32);
                v63 = (v51 - v58);
              }
              *(_QWORD *)(v42 + 32) = v62;
              *(_QWORD *)(v42 + 40) = (v61 - v45) | (unint64_t)(v63 << 32);
            }
            else
            {
              *(_OWORD *)(v42 + 32) = *v136;
            }
            result = kdu_dims::operator&=((_DWORD *)(v42 + 32), (int *)(v42 + 16));
            v68 = v140;
            v69 = v140 + 704 * v40;
            *(_QWORD *)(v69 + 84) = 0;
            v70 = (uint64_t *)(v69 + 84);
            v70[1] = 0;
            if (v40 <= *v31 && *v137)
            {
              v138 = v70;
              v139 = v40;
              v71 = v140 + 704 * v40;
              v74 = *(unsigned __int8 *)(v71 + 223);
              v73 = (unsigned __int8 *)(v71 + 223);
              LODWORD(v72) = v74;
              if (v74)
              {
                v75 = 0;
                v76 = 0;
                v77 = (_QWORD *)(v140 + 704 * v40 + 224);
                do
                {
                  v78 = *v77 + v75;
                  LODWORD(v79) = *(_DWORD *)(*(_QWORD *)v78 + 32);
                  LODWORD(v80) = *(_DWORD *)(*(_QWORD *)v78 + 36);
                  v81 = *(unsigned __int8 *)(v78 + 48);
                  v82 = *(unsigned __int8 *)(v78 + 49);
                  v83 = *v36;
                  v84 = *(_DWORD *)(*(_QWORD *)v78 + 44) + v80;
                  v85 = *(_DWORD *)(*(_QWORD *)v78 + 40) + v79;
                  if (*(_BYTE *)(v78 + 48))
                    v86 = *v141;
                  else
                    v86 = *v37;
                  if (*(_BYTE *)(v78 + 48))
                    v87 = *v38;
                  else
                    v87 = *v36;
                  v88 = (int)(v80 - (v86 + v81) + 1) >> 1;
                  v89 = (int)(v84 - (v87 + v81) + 1) >> 1;
                  if (v81 <= 1)
                    v80 = v88;
                  else
                    v80 = v80;
                  if (v81 <= 1)
                    v84 = v89;
                  if (*(_BYTE *)(v78 + 49))
                    v90 = *v141;
                  else
                    v90 = *v37;
                  if (*(_BYTE *)(v78 + 49))
                    v83 = *v38;
                  v91 = (int)(v79 - (v90 + v82) + 1) >> 1;
                  v92 = (int)(v85 - (v83 + v82) + 1) >> 1;
                  if (v82 <= 1)
                    v79 = v91;
                  else
                    v79 = v79;
                  if (v82 <= 1)
                    v85 = v92;
                  *(_QWORD *)(v78 + 32) = v79 | (v80 << 32);
                  *(_QWORD *)(v78 + 40) = (v85 - v79) | ((unint64_t)(v84 - v80) << 32);
                  v93 = v78 + 32;
                  kdu_dims::operator&=((_DWORD *)v93, (int *)(v93 - 16));
                  ++v76;
                  *(_QWORD *)(v93 + 28) = 0;
                  *(_QWORD *)(v93 + 20) = 0;
                  v72 = *v73;
                  v75 += 136;
                }
                while (v76 < v72);
                v40 = v139;
                v68 = v140;
              }
              v94 = v68 + 704 * v40;
              v96 = *(unsigned __int8 *)(v94 + 222);
              v95 = (unsigned __int8 *)(v94 + 222);
              if (v96)
              {
                v135 = v73;
                v97 = 0;
                v98 = 0;
                v99 = (uint64_t *)(v68 + 704 * v40 + 240);
                do
                {
                  v100 = *v99;
                  v101 = *(_DWORD **)(*v99 + v97);
                  if (!v101)
                  {
                    v144 = 0;
                    v142 = 0u;
                    v143 = 0u;
                    kdu_error::kdu_error((kdu_error *)&v142, "Kakadu Core Error:\n");
                    (*(void (**)(__int128 *, const char *))(v142 + 16))(&v142, "corrupt file: band->parent == NULL\n");
                    kdu_error::~kdu_error((kdu_error *)&v142);
                  }
                  LODWORD(v102) = v101[8];
                  LODWORD(v103) = v101[9];
                  v104 = v101[10];
                  v105 = v100 + v97;
                  v106 = *(unsigned __int8 *)(v100 + v97 + 48);
                  v107 = *(unsigned __int8 *)(v100 + v97 + 49);
                  v108 = *v36;
                  v109 = v101[11] + v103;
                  v110 = v104 + v102;
                  if (*(_BYTE *)(v100 + v97 + 48))
                    v111 = *v141;
                  else
                    v111 = *v37;
                  if (*(_BYTE *)(v100 + v97 + 48))
                    v112 = *v38;
                  else
                    v112 = *v36;
                  v113 = (int)(v103 - (v111 + v106) + 1) >> 1;
                  v114 = (int)(v109 - (v112 + v106) + 1) >> 1;
                  if (v106 <= 1)
                    v103 = v113;
                  else
                    v103 = v103;
                  if (v106 <= 1)
                    v109 = v114;
                  if (*(_BYTE *)(v100 + v97 + 49))
                    v115 = *v141;
                  else
                    v115 = *v37;
                  if (*(_BYTE *)(v100 + v97 + 49))
                    v108 = *v38;
                  v116 = (int)(v102 - (v115 + v107) + 1) >> 1;
                  v117 = (int)(v110 - (v108 + v107) + 1) >> 1;
                  if (v107 <= 1)
                    v102 = v116;
                  else
                    v102 = v102;
                  if (v107 <= 1)
                    v110 = v117;
                  *(_QWORD *)(v105 + 32) = v102 | (v103 << 32);
                  *(_QWORD *)(v105 + 40) = (v110 - v102) | ((unint64_t)(v109 - v103) << 32);
                  kdu_dims::operator&=((_DWORD *)(v105 + 32), (int *)(v105 + 16));
                  *(_QWORD *)(v105 + 108) = get_partition_indices(*(_QWORD *)(v105 + 76), *(_QWORD *)(v105 + 84), *(_QWORD *)(v105 + 32), *(_QWORD *)(v105 + 40));
                  *(_QWORD *)(v105 + 116) = v118;
                  if (*(int *)(v105 + 44) >= 1 && *(int *)(v105 + 40) >= 1)
                    kd_node::adjust_cover(*(_QWORD *)(v100 + v97), *(_QWORD *)(v105 + 32), *(_QWORD *)(v105 + 40), *(unsigned __int8 *)(v105 + 48), *(unsigned __int8 *)(v105 + 49));
                  ++v98;
                  v97 += 144;
                }
                while (v98 < *v95);
                LODWORD(v72) = *v135;
                v40 = v139;
              }
              if ((_DWORD)v72)
              {
                v119 = (_QWORD *)(v140 + 704 * v40 + 224);
                v120 = v72 + 1;
                v121 = 136 * v72;
                do
                {
                  v122 = *v119 + v121;
                  if (*(int *)(v122 - 92) >= 1 && *(int *)(v122 - 96) >= 1)
                    kd_node::adjust_cover(*(_QWORD *)(v122 - 136), *(_QWORD *)(*v119 + v121 - 84), *(_QWORD *)(*v119 + v121 - 76), *(unsigned __int8 *)(*v119 + v121 - 88), *(unsigned __int8 *)(*v119 + v121 - 87));
                  --v120;
                  v121 -= 136;
                }
                while (v120 > 1);
              }
              v123 = v140 + 704 * v40;
              *(_QWORD *)(v123 + 200) = get_partition_indices(*(_QWORD *)(v123 + 168), *(_QWORD *)(v123 + 176), *v138, v138[1]);
              *(_QWORD *)(v123 + 208) = v124;
              result = kdu_dims::operator&=((_DWORD *)(v123 + 200), (int *)(v123 + 184));
              v33 = v133;
              v31 = v134;
              v39 = v141;
              v1 = v131;
              if (v132)
                *((_DWORD *)v131 + 52) += *(_DWORD *)(v140 + 704 * v40 + 212)
                                        * *((_DWORD *)v131 + 50)
                                        * *(_DWORD *)(v140 + 704 * v40 + 208);
            }
            else
            {
              v125 = v140 + 704 * v40;
              *(_QWORD *)(v125 + 200) = 0;
              *(_QWORD *)(v125 + 208) = 0;
            }
            v57 = v40-- <= 0;
          }
          while (!v57);
        }
      }
      v5 = v130 + 1;
      if ((uint64_t)(v130 + 1) >= *((int *)v1 + 47))
        return result;
    }
    if (v8[46] == 1)
    {
      v9 = *(_DWORD *)(*((_QWORD *)v8 + 39) + 104 * v5 + 88);
    }
    else
    {
      v10 = v1[32];
      if (!v10)
      {
        if (v5 <= 2 && *((_BYTE *)v1 + 286))
        {
          v126 = 0;
          v127 = &v6[56 * v5];
          *((_BYTE *)v127 + 184) = 0;
          v128 = v127 + 46;
          v129 = 16;
          while (v126 >= v8[44] || (*(_DWORD *)(*((_QWORD *)v8 + 40) + v129) & 0x80000000) != 0)
          {
            ++v126;
            v129 += 48;
            if (v126 == 3)
              goto LABEL_21;
          }
          *v128 = 1;
          goto LABEL_21;
        }
        v12 = (uint64_t)v5 < v8[44] && *(_DWORD *)(*((_QWORD *)v8 + 40) + 48 * v5 + 16) >= 0;
        v11 = &v6[56 * v5];
        goto LABEL_20;
      }
      v9 = *(_DWORD *)(*((_QWORD *)v10 + 1) + 4 * v5);
    }
    v11 = &v6[56 * v5];
    v12 = v9 >= 0;
LABEL_20:
    *((_BYTE *)v11 + 184) = v12;
    goto LABEL_21;
  }
  return result;
}

void sub_187EECCE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EECCF0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Exception *v21;

  _Unwind_Resume(v21);
}

uint64_t kd_tile::finished_reading(kd_tile *this)
{
  int v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int *v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t *v15;
  BOOL v16;
  _OWORD v18[2];
  uint64_t v19;

  if (!*((_BYTE *)this + 292))
    return 0;
  if (*(kd_tile **)(*(_QWORD *)this + 440) == this)
  {
    if (*((_BYTE *)this + 328))
    {
      v19 = 0;
      memset(v18, 0, sizeof(v18));
      kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, "Assert ");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, "!exhausted");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v18[0] + 16))(v18, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v18);
    }
    *(_QWORD *)(*(_QWORD *)this + 440) = 0;
    kd_tile::adjust_unloadability((uint64_t *)this);
  }
  else
  {
    kd_tile::adjust_unloadability((uint64_t *)this);
    if (*((_BYTE *)this + 328))
      return 0;
  }
  *((_BYTE *)this + 328) = 1;
  if (*((_BYTE *)this + 291))
  {
    if (!*(_BYTE *)(*(_QWORD *)this + 408))
    {
      kd_tile::release(this);
      return 1;
    }
  }
  else
  {
    v3 = *((_DWORD *)this + 47);
    if (v3 >= 1)
    {
      for (i = 0; i < v3; ++i)
      {
        v5 = *((_QWORD *)this + 34);
        v6 = v5 + 224 * i;
        v9 = *(_DWORD *)(v6 + 68);
        v8 = (int *)(v6 + 68);
        v7 = v9;
        if ((v9 & 0x80000000) == 0)
        {
          v10 = 0;
          v11 = (_QWORD *)(v5 + 224 * i + 176);
          do
          {
            if (*(_DWORD *)(*v11 + 704 * v10 + 192) * *(_DWORD *)(*v11 + 704 * v10 + 196) >= 1)
            {
              v12 = 0;
              v13 = (_QWORD *)(*v11 + 704 * v10 + 232);
              v14 = 8 * (*(_DWORD *)(*v11 + 704 * v10 + 192) * *(_DWORD *)(*v11 + 704 * v10 + 196));
              do
              {
                v15 = *(uint64_t **)(*v13 + v12);
                if (v15)
                  v16 = (*(_QWORD *)(*v13 + v12) & 1) == 0;
                else
                  v16 = 0;
                if (v16)
                  kd_precinct::finished_desequencing(v15);
                v12 += 8;
              }
              while (v14 != v12);
              v7 = *v8;
            }
          }
          while (v10++ < v7);
          v3 = *((_DWORD *)this + 47);
        }
      }
    }
  }
  return 0;
}

void sub_187EECEE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EECEF0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_tile::recycle(kd_tile *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  kd_mct_stage *v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  int v37;
  uint64_t v38;
  unsigned int *v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned __int8 *v56;
  int v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int v66;
  uint64_t v67;
  unsigned __int8 *v68;
  int v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  unsigned int v76;
  int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  int v82;
  uint64_t result;
  int v84;
  uint64_t v85;
  int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  int v92;
  uint64_t v94;
  _OWORD *v95;
  unsigned int v96;
  unint64_t v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;

  if (*((_DWORD *)this + 70))
  {
    v100 = 0;
    v98 = 0u;
    v99 = 0u;
    kdu_error::kdu_error((kdu_error *)&v98, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "Assert ");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "structure_bytes == 0");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v98);
  }
  if (*((_QWORD *)this + 3) || (*((_DWORD *)this + 2) & 0x80000000) == 0 || !*((_BYTE *)this + 184))
  {
    v100 = 0;
    v98 = 0u;
    v99 = 0u;
    kdu_error::kdu_error((kdu_error *)&v98, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "Assert ");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "(tile_ref == NULL) && (t_num < 0) && is_typical");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v98);
  }
  *((_QWORD *)this + 3) = a2;
  *(_QWORD *)((char *)this + 12) = a3;
  v7 = *(_QWORD *)this;
  *((_DWORD *)this + 2) = HIDWORD(a3) + *(_DWORD *)(*(_QWORD *)this + 224) * a3;
  *((_BYTE *)this + 184) = 0;
  *(_QWORD *)((char *)this + 212) = a4;
  *(_QWORD *)((char *)this + 220) = a5;
  *(_QWORD *)((char *)this + 236) = 0;
  *((_QWORD *)this + 9) = 0;
  if (*((_QWORD *)this + 10)
    || *((_QWORD *)this + 11)
    || *((_QWORD *)this + 12)
    || *((_QWORD *)this + 7)
    || *((_QWORD *)this + 8))
  {
    v100 = 0;
    v98 = 0u;
    v99 = 0u;
    kdu_error::kdu_error((kdu_error *)&v98, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "Assert ");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "(ppt_markers == NULL) && (packed_headers == NULL) && (sequencer == NULL) && (unloadable_next == NULL) && (unloadable_prev == NULL)");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v98);
  }
  *((_BYTE *)this + 328) = 0;
  *((_BYTE *)this + 287) = 0;
  *((_DWORD *)this + 80) = 0;
  *((_BYTE *)this + 293) = 0;
  *(_DWORD *)((char *)this + 289) = 0;
  *((_BYTE *)this + 316) = 0;
  *(_QWORD *)((char *)this + 308) = 0;
  *(_QWORD *)((char *)this + 300) = 0;
  if (*((_DWORD *)this + 47) != *(_DWORD *)(v7 + 168))
  {
    v100 = 0;
    v98 = 0u;
    v99 = 0u;
    kdu_error::kdu_error((kdu_error *)&v98, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "Assert ");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "num_components == codestream->num_components");
    (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v98);
  }
  if (*(_QWORD *)(v7 + 8))
  {
    *((_QWORD *)this + 4) = **((_QWORD **)this + 3);
    v86 = kd_tile::read_tile_part_header(this) ^ 1;
    v7 = *(_QWORD *)this;
  }
  else
  {
    v86 = 0;
  }
  if ((kdu_params::check_typical_tile(*(kdu_params **)(v7 + 24), *((_DWORD *)this + 2)) & 1) != 0 || (v86 & 1) != 0)
  {
    *((_BYTE *)this + 184) = 1;
    v15 = *((_DWORD *)this + 47);
    v14 = *((_DWORD *)this + 48);
    *((_DWORD *)this + 49) = v14;
    v16 = *((_QWORD *)this + 34);
    *((_DWORD *)this + 51) = 0;
    if (v15 < 1)
    {
      v82 = 0;
      v17 = 336;
    }
    else
    {
      v96 = 0;
      v90 = HIDWORD(a5) + HIDWORD(a4) - 1;
      v91 = a5 + a4;
      v92 = HIDWORD(a5) + HIDWORD(a4);
      v88 = -(HIDWORD(a5) + HIDWORD(a4));
      v89 = a5 + a4 - 1;
      v87 = -(a5 + a4);
      v17 = 336;
      do
      {
        *(_WORD *)(v16 + 184) = 257;
        *(_DWORD *)(v16 + 156) = -1082130432;
        if (*(int *)(v16 + 32) <= 1)
          v18 = 1;
        else
          v18 = *(_DWORD *)(v16 + 32);
        if (a4 <= 0)
          v19 = -(int)(-HIDWORD(a4) / v18);
        else
          v19 = (HIDWORD(a4) - 1) / v18 + 1;
        if (v92 <= 0)
          v20 = -(int)(v88 / v18);
        else
          v20 = v90 / v18 + 1;
        if (*(int *)(v16 + 28) <= 1)
          v21 = 1;
        else
          v21 = *(_DWORD *)(v16 + 28);
        if ((int)a4 <= 0)
          v22 = -(int)(-(int)a4 / v21);
        else
          v22 = ((int)a4 - 1) / v21 + 1;
        if (v91 <= 0)
          v23 = -(int)(v87 / v21);
        else
          v23 = v89 / v21 + 1;
        v17 += 224;
        *(_QWORD *)(v16 + 36) = v22 | (unint64_t)(v19 << 32);
        *(_QWORD *)(v16 + 44) = (v23 - v22) | ((unint64_t)(v20 - v19) << 32);
        v24 = *(unsigned int *)(v16 + 68);
        v95 = (_OWORD *)(v16 + 36);
        *(_DWORD *)(v16 + 72) = v24;
        if ((v24 & 0x80000000) == 0)
        {
          v94 = v16;
          do
          {
            v25 = *(_QWORD *)(v16 + 176);
            if (v24 == *(_DWORD *)(v16 + 68))
            {
              v26 = v25 + 704 * v24;
              *(_OWORD *)(v26 + 48) = *v95;
              v27 = *(_QWORD *)(v26 + 48);
              v28 = *(_QWORD *)(v26 + 56);
            }
            else
            {
              v29 = v25 + 704 * v24;
              v31 = *(_DWORD **)(v29 + 32);
              v30 = v29 + 32;
              LODWORD(v32) = v31[4];
              LODWORD(v33) = v31[5];
              v34 = *(unsigned __int8 *)(v30 + 48);
              v35 = *(unsigned __int8 *)(v30 + 49);
              v36 = v31[7] + v33;
              v37 = v31[6] + v32;
              if (v34 <= 1)
                v33 = ((int)(v33 - v34 + 1) >> 1);
              else
                v33 = v33;
              if (v34 <= 1)
                v36 = (int)(v36 - v34 + 1) >> 1;
              if (v35 <= 1)
                v32 = ((int)(v32 - v35 + 1) >> 1);
              else
                v32 = v32;
              if (v35 <= 1)
                v37 = (int)(v37 - v35 + 1) >> 1;
              v27 = v32 | (v33 << 32);
              v28 = (v37 - v32) | ((unint64_t)(v36 - v33) << 32);
              *(_QWORD *)(v30 + 16) = v27;
              *(_QWORD *)(v30 + 24) = v28;
            }
            v38 = v25 + 704 * v24;
            v40 = *(_DWORD *)(v38 + 196);
            v39 = (unsigned int *)(v38 + 196);
            *(_QWORD *)(v39 - 45) = 0;
            v41 = *(v39 - 1) * v40;
            *(_QWORD *)(v39 + 1) = get_partition_indices(*(_QWORD *)(v39 - 7), *(_QWORD *)(v39 - 5), v27, v28);
            *(_QWORD *)(v39 + 3) = v42;
            *(_OWORD *)(v39 - 3) = *(_OWORD *)(v39 + 1);
            v97 = *(v39 - 1) * (unint64_t)*v39;
            if (v41 != (_DWORD)v97)
            {
              v43 = v25 + 704 * v24;
              v46 = *(_QWORD *)(v43 + 232);
              v45 = (_QWORD *)(v43 + 232);
              v44 = v46;
              if (v46)
              {
                v49 = *(_QWORD *)(v44 - 8);
                v48 = v44 - 8;
                v47 = v49;
                if (v49)
                {
                  v50 = 8 * v47;
                  do
                  {
                    kd_precinct_ref::~kd_precinct_ref((kd_precinct_ref *)(v48 + v50));
                    v50 -= 8;
                  }
                  while (v50);
                }
                MEMORY[0x18D761C18](v48 - 8, 0x1000C8000313F17);
              }
              v51 = (_QWORD *)operator new[]();
              *v51 = 8;
              v51[1] = (int)v97;
              v52 = v51 + 2;
              if (v97 << 32)
                bzero(v51 + 2, 8 * (int)v97);
              *v45 = v52;
              v16 = v94;
            }
            *((_DWORD *)this + 51) += v97;
            v53 = *(_QWORD *)this;
            if (v96 <= 3 && !v24 && *(int *)(v53 + 160) <= 1)
            {
              v54 = *(_QWORD *)(v25 + 8);
              if (*(_DWORD *)(v54 + 32) * *(_DWORD *)(v25 + 60) > 128
                || *(_DWORD *)(v54 + 28) * *(_DWORD *)(v25 + 56) >= 129)
              {
                v100 = 0;
                v98 = 0u;
                v99 = 0u;
                kdu_warning::kdu_warning((kdu_warning *)&v98, "Kakadu Core Warning:\n");
                (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "Profile violation detected (code-stream is technically illegal).  Profile-0 and Profile-1 code-streams must have sufficient DWT levels to permit extraction of a low resolution image which is no larger than 128x128.   Try setting a larger value for \"Clevels\" or else set \"Sprofile\" to 2.");
                *(_DWORD *)(*(_QWORD *)this + 160) = 2;
                kdu_warning::~kdu_warning((kdu_warning *)&v98);
                v53 = *(_QWORD *)this;
              }
            }
            if (!*(_DWORD *)(v53 + 160)
              && *(int *)(v25 + 704 * v24 + 60) <= 128
              && *(int *)(v25 + 704 * v24 + 56) <= 128
              && (int)*(v39 - 1) * (uint64_t)(int)*v39 >= 2)
            {
              v100 = 0;
              v98 = 0u;
              v99 = 0u;
              kdu_warning::kdu_warning((kdu_warning *)&v98, "Kakadu Core Warning:\n");
              (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "Profile violation detected (code-stream is technically illegal).  Profile-0 code-streams may have multiple precincts only in those tile-component resolutions whose dimensions are greater than 128x128.");
              *(_DWORD *)(*(_QWORD *)this + 160) = 2;
              kdu_warning::~kdu_warning((kdu_warning *)&v98);
            }
            v55 = v25 + 704 * v24;
            v57 = *(unsigned __int8 *)(v55 + 223);
            v56 = (unsigned __int8 *)(v55 + 223);
            if (v57)
            {
              v58 = 0;
              v59 = 0;
              do
              {
                v60 = *(_QWORD *)(v25 + 704 * v24 + 224) + v58;
                LODWORD(v61) = *(_DWORD *)(*(_QWORD *)v60 + 16);
                LODWORD(v62) = *(_DWORD *)(*(_QWORD *)v60 + 20);
                v63 = *(unsigned __int8 *)(v60 + 48);
                v64 = *(unsigned __int8 *)(v60 + 49);
                v65 = *(_DWORD *)(*(_QWORD *)v60 + 28) + v62;
                v66 = *(_DWORD *)(*(_QWORD *)v60 + 24) + v61;
                if (v63 <= 1)
                  v62 = ((int)(v62 - v63 + 1) >> 1);
                else
                  v62 = v62;
                if (v63 <= 1)
                  v65 = (int)(v65 - v63 + 1) >> 1;
                if (v64 <= 1)
                  v61 = ((int)(v61 - v64 + 1) >> 1);
                else
                  v61 = v61;
                if (v64 <= 1)
                  v66 = (int)(v66 - v64 + 1) >> 1;
                *(_QWORD *)(v60 + 16) = v61 | (v62 << 32);
                *(_QWORD *)(v60 + 24) = (v66 - v61) | ((unint64_t)(v65 - v62) << 32);
                ++v59;
                v58 += 136;
              }
              while (v59 < *v56);
            }
            v67 = v25 + 704 * v24;
            v69 = *(unsigned __int8 *)(v67 + 222);
            v68 = (unsigned __int8 *)(v67 + 222);
            if (v69)
            {
              v70 = 0;
              v71 = 0;
              do
              {
                v72 = *(_QWORD *)(v25 + 704 * v24 + 240) + v70;
                LODWORD(v73) = *(_DWORD *)(*(_QWORD *)v72 + 16);
                LODWORD(v74) = *(_DWORD *)(*(_QWORD *)v72 + 20);
                v75 = *(unsigned __int8 *)(v72 + 48);
                v76 = *(unsigned __int8 *)(v72 + 49);
                v77 = *(_DWORD *)(*(_QWORD *)v72 + 28) + v74;
                v78 = *(_DWORD *)(*(_QWORD *)v72 + 24) + v73;
                if (v75 <= 1)
                  v74 = ((int)(v74 - v75 + 1) >> 1);
                else
                  v74 = v74;
                if (v75 <= 1)
                  v77 = (int)(v77 - v75 + 1) >> 1;
                if (v76 <= 1)
                  v73 = ((int)(v73 - v76 + 1) >> 1);
                else
                  v73 = v73;
                if (v76 <= 1)
                  v78 = (int)(v78 - v76 + 1) >> 1;
                v79 = v73 | (v74 << 32);
                *(_QWORD *)(v72 + 16) = v79;
                *(_QWORD *)(v72 + 24) = (v78 - v73) | ((unint64_t)(v77 - v74) << 32);
                *(_QWORD *)(v72 + 92) = get_partition_indices(*(_QWORD *)(v72 + 76), *(_QWORD *)(v72 + 84), v79, v78 - (int)v73);
                *(_QWORD *)(v72 + 100) = v80;
                ++v71;
                v70 += 144;
              }
              while (v71 < *v68);
            }
            v17 += 704 + 8 * v97;
            kd_resolution::complete_initialization((kd_resolution *)(v25 + 704 * v24));
          }
          while (v24-- > 0);
        }
        v16 += 224;
        ++v96;
      }
      while ((signed int)v96 < *((_DWORD *)this + 47));
      v14 = *((_DWORD *)this + 48);
      v82 = *((_DWORD *)this + 51);
    }
    *((_DWORD *)this + 50) = v14;
    *((_DWORD *)this + 52) = v82 * v14;
    *((_BYTE *)this + 292) = 1;
    *(_QWORD *)((char *)this + 308) = 0;
    *((_BYTE *)this + 316) = 0;
    if (*((_QWORD *)this + 12))
    {
      v100 = 0;
      v98 = 0u;
      v99 = 0u;
      kdu_error::kdu_error((kdu_error *)&v98, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "Assert ");
      (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "sequencer == NULL");
      (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v98);
    }
    v84 = v17;
    v85 = operator new();
    *(_QWORD *)(v85 + 16) = 0;
    *(_OWORD *)(v85 + 68) = 0u;
    *(_OWORD *)(v85 + 84) = 0u;
    *(_OWORD *)(v85 + 156) = 0u;
    *(_OWORD *)(v85 + 172) = 0u;
    *(_QWORD *)v85 = this;
    kd_packet_sequencer::init((kd_packet_sequencer *)v85);
    *((_QWORD *)this + 12) = v85;
    if (*((_DWORD *)this + 70))
    {
      v100 = 0;
      v98 = 0u;
      v99 = 0u;
      kdu_error::kdu_error((kdu_error *)&v98, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "Assert ");
      (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, "structure_bytes == 0");
      (*(void (**)(__int128 *, const char *))(v98 + 16))(&v98, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v98);
    }
    *((_DWORD *)this + 70) = v84 + 208;
    result = kd_buf_server::augment_structure_bytes(*(_QWORD *)(*(_QWORD *)this + 48), v84 + 208);
    if (!*(_BYTE *)(*(_QWORD *)this + 417))
      result = kd_tile::set_elements_of_interest((int **)this);
    if (v86)
      return kd_tile::finished_reading(this);
  }
  else
  {
    v8 = *((_QWORD *)this + 34);
    if (v8)
    {
      v9 = v8 - 16;
      v10 = *(_QWORD *)(v8 - 8);
      if (v10)
      {
        v11 = v8 - 224;
        v12 = 224 * v10;
        do
        {
          kd_tile_comp::~kd_tile_comp((kd_tile_comp *)(v11 + v12));
          v12 -= 224;
        }
        while (v12);
      }
      MEMORY[0x18D761C18](v9, 0x10A0C802A3299D9);
    }
    v13 = (kd_mct_stage *)*((_QWORD *)this + 32);
    *((_QWORD *)this + 34) = 0;
    while (1)
    {
      *((_QWORD *)this + 33) = v13;
      if (!v13)
        break;
      *((_QWORD *)this + 32) = *((_QWORD *)v13 + 7);
      kd_mct_stage::~kd_mct_stage(v13);
      MEMORY[0x18D761C30]();
      v13 = (kd_mct_stage *)*((_QWORD *)this + 32);
    }
    *((_BYTE *)this + 292) = 1;
    *(_DWORD *)((char *)this + 294) = 0;
    return kd_tile::initialize(this);
  }
  return result;
}

void sub_187EEDA58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1020C40539952E0);
  _Unwind_Resume(a1);
}

uint64_t *kd_tile::restart(kd_tile *this)
{
  kd_tile *v1;
  kdu_message *v2;
  uint64_t v3;
  uint64_t *result;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  int v17;
  __int128 v18;
  uint64_t v19;
  unint64_t v20;
  _OWORD *v21;
  __int128 v22;
  uint64_t v23;
  unsigned __int8 *v24;
  int v25;
  uint64_t v26;
  unint64_t v27;
  _OWORD *v28;
  uint64_t v29;
  int v30;
  int *v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t i;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  int *v43;
  uint64_t v44;
  uint64_t *v45;
  char v46[16];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;

  v1 = this;
  v51 = *MEMORY[0x1E0C80C00];
  v2 = **(kdu_message ***)this;
  if (v2)
  {
    if (*((_BYTE *)this + 288))
    {
      kd_tile::remove_from_in_progress_list((uint64_t *)this);
      v2 = **(kdu_message ***)v1;
    }
    (*(void (**)(kdu_message *, const char *))(*(_QWORD *)v2 + 16))(v2, "\n>> New attributes for tile ");
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    *(_OWORD *)v46 = 0u;
    if (*((_BYTE *)v2 + 8))
      sprintf(v46, "%x");
    else
      sprintf(v46, "%d");
    (*(void (**)(kdu_message *, char *))(*(_QWORD *)v2 + 16))(v2, v46);
    (*(void (**)(kdu_message *, const char *))(*(_QWORD *)v2 + 16))(v2, ":\n");
    kdu_params::textualize_attributes(*(_QWORD *)(*(_QWORD *)v1 + 24), v2, *((_DWORD *)v1 + 2), *((_DWORD *)v1 + 2), 1);
    (*(void (**)(kdu_message *, _QWORD))(*(_QWORD *)v2 + 32))(v2, 0);
  }
  *((_BYTE *)v1 + 184) = 0;
  *((_QWORD *)v1 + 4) = 0;
  v3 = *((_QWORD *)v1 + 11);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_QWORD *)v1 + 11) = 0;
  result = kd_precinct_pointer_server::disable((uint64_t *)v1 + 13);
  *(_WORD *)((char *)v1 + 291) = 0;
  *((_BYTE *)v1 + 293) = 1;
  v6 = *((_DWORD *)v1 + 47);
  v5 = *((_DWORD *)v1 + 48);
  *((_DWORD *)v1 + 50) = v5;
  v7 = *((_DWORD *)v1 + 51) * v5;
  *(_QWORD *)((char *)v1 + 236) = 0;
  *((_BYTE *)v1 + 328) = 0;
  *((_DWORD *)v1 + 52) = v7;
  *((_BYTE *)v1 + 316) = 0;
  *((_DWORD *)v1 + 80) = 0;
  *((_DWORD *)v1 + 78) = 0;
  *((_QWORD *)v1 + 38) = 0;
  *((_DWORD *)v1 + 75) = 0;
  if (v6 >= 1)
  {
    v8 = 0;
    v43 = (int *)v1;
    do
    {
      v9 = *((_QWORD *)v1 + 34);
      v44 = v8;
      v10 = v9 + 224 * v8;
      v12 = *(_DWORD *)(v10 + 68);
      v11 = (int *)(v10 + 68);
      *((_WORD *)v11 + 58) = 257;
      v11[22] = -1082130432;
      v11[1] = v12;
      *((_OWORD *)v11 - 1) = *((_OWORD *)v11 - 2);
      if ((v12 & 0x80000000) == 0)
      {
        v13 = 0;
        v45 = (uint64_t *)(v9 + 224 * v8 + 176);
        do
        {
          v14 = *v45;
          v15 = *v45 + 704 * v13;
          v17 = *(unsigned __int8 *)(v15 + 223);
          v16 = (unsigned __int8 *)(v15 + 223);
          *(_QWORD *)(v16 - 207) = 0;
          v18 = *(_OWORD *)(v16 - 175);
          *(_OWORD *)(v16 - 139) = v18;
          *(_OWORD *)(v16 - 159) = v18;
          *(_OWORD *)(v16 - 23) = *(_OWORD *)(v16 - 39);
          if (v17)
          {
            v19 = 0;
            v20 = 0;
            do
            {
              v21 = (_OWORD *)(*(_QWORD *)(v14 + 704 * v13 + 224) + v19);
              v22 = v21[1];
              *(_OWORD *)((char *)v21 + 52) = v22;
              v21[2] = v22;
              ++v20;
              v19 += 136;
            }
            while (v20 < *v16);
          }
          v23 = v14 + 704 * v13;
          v25 = *(unsigned __int8 *)(v23 + 222);
          v24 = (unsigned __int8 *)(v23 + 222);
          if (v25)
          {
            v26 = 0;
            v27 = 0;
            do
            {
              v28 = (_OWORD *)(*(_QWORD *)(v14 + 704 * v13 + 240) + v26);
              v28[2] = v28[1];
              *(_OWORD *)((char *)v28 + 108) = *(_OWORD *)((char *)v28 + 92);
              ++v27;
              v26 += 144;
            }
            while (v27 < *v24);
          }
          v29 = v14 + 704 * v13;
          v32 = *(_DWORD *)(v29 + 192);
          v31 = (int *)(v29 + 192);
          v30 = v32;
          if (v32 >= 1)
          {
            v33 = 0;
            v34 = v14 + 704 * v13;
            v37 = *(_DWORD *)(v34 + 196);
            v36 = v34 + 196;
            v35 = v37;
            do
            {
              if (v35 >= 1)
              {
                for (i = 0; i < v35; *(_QWORD *)(v39 + 8 * i++) = 0)
                {
                  v39 = *(_QWORD *)(v36 + 36) + 8 * v33 * v35;
                  v40 = *(_QWORD *)(v39 + 8 * i);
                  if (v40)
                    v41 = (*(_QWORD *)(v39 + 8 * i) & 1) == 0;
                  else
                    v41 = 0;
                  if (v41)
                  {
                    *(_QWORD *)(v40 + 8) = 0;
                    kd_precinct::closing((unsigned __int8 **)v40);
                    result = (uint64_t *)kd_precinct_size_class::release(*(kd_precinct_size_class **)(v40 + 72), (kd_precinct *)v40);
                    v35 = *(_DWORD *)v36;
                  }
                }
                v30 = *v31;
              }
              ++v33;
            }
            while (v33 < v30);
          }
        }
        while (v13++ < *v11);
      }
      v1 = (kd_tile *)v43;
      v8 = v44 + 1;
    }
    while (v44 + 1 < v43[47]);
  }
  return result;
}

uint64_t kd_tile::reinitialize(kd_tile *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  kd_mct_stage *v10;
  int v11;
  uint64_t result;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  if (!*((_BYTE *)this + 293) || *((_BYTE *)this + 289))
  {
    v15 = 0;
    v13 = 0u;
    v14 = 0u;
    kdu_error::kdu_error((kdu_error *)&v13, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v13 + 16))(&v13, "Assert ");
    (*(void (**)(__int128 *, const char *))(v13 + 16))(&v13, "needs_reinit && !is_open");
    (*(void (**)(__int128 *, const char *))(v13 + 16))(&v13, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v13);
  }
  *((_BYTE *)this + 293) = 0;
  v2 = *((_QWORD *)this + 3);
  if (*(kd_tile **)(v2 + 16) != this)
  {
    v15 = 0;
    v13 = 0u;
    v14 = 0u;
    kdu_error::kdu_error((kdu_error *)&v13, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v13 + 16))(&v13, "Assert ");
    (*(void (**)(__int128 *, const char *))(v13 + 16))(&v13, "tile_ref->tile == this");
    (*(void (**)(__int128 *, const char *))(v13 + 16))(&v13, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v13);
  }
  *((_QWORD *)this + 4) = *(_QWORD *)v2;
  v3 = *(_QWORD *)this;
  if (*(_QWORD *)(*(_QWORD *)this + 8))
  {
    if (!kd_tile::read_tile_part_header(this))
    {
      v11 = 1;
LABEL_23:
      *((_BYTE *)this + 292) = 1;
      kd_packet_sequencer::init(*((kd_packet_sequencer **)this + 12));
      if (*(_BYTE *)(*(_QWORD *)this + 417))
      {
        if (!v11)
        {
LABEL_26:
          result = kdu_params::check_typical_tile(*(kdu_params **)(*(_QWORD *)this + 24), *((_DWORD *)this + 2));
          *((_BYTE *)this + 184) = result;
          return result;
        }
      }
      else
      {
        kd_tile::set_elements_of_interest((int **)this);
        if (!v11)
          goto LABEL_26;
      }
      kd_tile::finished_reading(this);
      goto LABEL_26;
    }
    v3 = *(_QWORD *)this;
  }
  if ((kdu_params::any_changes(*(kdu_params **)(v3 + 24)) & 1) == 0)
  {
    v11 = 0;
    goto LABEL_23;
  }
  v4 = *((_QWORD *)this + 12);
  if (v4)
    MEMORY[0x18D761C30](v4, 0x1020C40539952E0);
  *((_QWORD *)this + 12) = 0;
  v5 = *((_QWORD *)this + 34);
  if (v5)
  {
    v6 = v5 - 16;
    v7 = *(_QWORD *)(v5 - 8);
    if (v7)
    {
      v8 = v5 - 224;
      v9 = 224 * v7;
      do
      {
        kd_tile_comp::~kd_tile_comp((kd_tile_comp *)(v8 + v9));
        v9 -= 224;
      }
      while (v9);
    }
    MEMORY[0x18D761C18](v6, 0x10A0C802A3299D9);
  }
  v10 = (kd_mct_stage *)*((_QWORD *)this + 32);
  *((_QWORD *)this + 34) = 0;
  while (1)
  {
    *((_QWORD *)this + 33) = v10;
    if (!v10)
      break;
    *((_QWORD *)this + 32) = *((_QWORD *)v10 + 7);
    kd_mct_stage::~kd_mct_stage(v10);
    MEMORY[0x18D761C30]();
    v10 = (kd_mct_stage *)*((_QWORD *)this + 32);
  }
  *(_DWORD *)((char *)this + 294) = 0;
  *((_BYTE *)this + 292) = 1;
  kd_buf_server::augment_structure_bytes(*(_QWORD *)(*(_QWORD *)this + 48), -*((_DWORD *)this + 70));
  *((_DWORD *)this + 70) = 0;
  return kd_tile::initialize(this);
}

void sub_187EEE0F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EEE0FC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t *kd_tile::open(kd_tile *this)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  int v17;
  int v18;
  int32x2_t *v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  int32x2_t v23;
  int32x2_t *v24;
  int v25;
  int v26;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t *v33;
  uint64_t v34;
  BOOL v35;
  int v36;
  unsigned int v38;
  uint64_t *result;
  _DWORD *v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t *v43;
  int *v44;
  char v45;
  int *v46;
  int32x2_t v47;
  int32x2_t v48;
  int v49;
  uint64_t v50;
  int v51;
  int32x2_t v52;
  int32x2_t v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;

  v1 = (uint64_t *)this;
  if (*((_BYTE *)this + 289))
  {
    v56 = 0;
    v54 = 0u;
    v55 = 0u;
    kdu_error::kdu_error((kdu_error *)&v54, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "You must close a tile before you can re-open it.");
    kdu_error::~kdu_error((kdu_error *)&v54);
  }
  if (!*((_QWORD *)this + 34))
  {
    v56 = 0;
    v54 = 0u;
    v55 = 0u;
    kdu_error::kdu_error((kdu_error *)&v54, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "kd_tile::initialize failed.");
    kdu_error::~kdu_error((kdu_error *)&v54);
  }
  v2 = *(_QWORD *)this;
  if (*(_BYTE *)(*(_QWORD *)this + 417))
  {
    kd_tile::set_elements_of_interest((int **)this);
    v2 = *v1;
  }
  if (*(_QWORD *)(v2 + 16))
  {
    if (*((_BYTE *)v1 + 288) || v1[5])
    {
      v56 = 0;
      v54 = 0u;
      v55 = 0u;
      kdu_error::kdu_error((kdu_error *)&v54, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "Assert ");
      (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "(!is_in_progress) && (in_progress_next == NULL)");
      (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v54);
    }
    v3 = *(_QWORD *)(v2 + 344);
    v1[6] = v3;
    v4 = (uint64_t **)(v3 ? v3 + 40 : v2 + 336);
    *v4 = v1;
    *(_QWORD *)(v2 + 344) = v1;
    *((_BYTE *)v1 + 288) = 1;
    if (*((int *)v1 + 47) >= 1)
    {
      v5 = 0;
      v41 = v1;
      while (1)
      {
        v6 = v1[34];
        v7 = *(_QWORD *)(*v1 + 352) + 88 * v5;
        v8 = v6 + 224 * v5;
        v11 = *(_DWORD *)(v8 + 68);
        v9 = (_DWORD *)(v8 + 68);
        v10 = v11;
        if ((v11 & 0x80000000) == 0)
          break;
LABEL_75:
        v38 = 33 - v10;
        do
        {
          kd_global_rescomp::notify_tile_status(v7, *(uint64_t *)((char *)v1 + 212), *(uint64_t *)((char *)v1 + 220), 0);
          v36 = *((_DWORD *)v1 + 47);
          v7 += 88 * v36;
          --v38;
        }
        while (v38 > 1);
LABEL_77:
        if (++v5 >= v36)
          goto LABEL_78;
      }
      v40 = v9;
      v45 = 0;
      v43 = (uint64_t *)(v6 + 224 * v5 + 176);
      while (1)
      {
        v12 = *v43;
        v13 = *v43 + 704 * v10;
        v14 = *(_QWORD *)(v13 + 16);
        v45 |= v14 != 0;
        if ((v45 & 1) != 0)
        {
          if (v14 != v7)
          {
            v56 = 0;
            v54 = 0u;
            v55 = 0u;
            kdu_error::kdu_error((kdu_error *)&v54, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "Assert ");
            (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "res->rescomp == rc");
            (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v54);
          }
          goto LABEL_71;
        }
        *(_QWORD *)(v13 + 16) = v7;
        kd_global_rescomp::notify_tile_status(v7, *(uint64_t *)((char *)v1 + 212), *(uint64_t *)((char *)v1 + 220), 1);
        if (*(_BYTE *)(v12 + 704 * v10 + 24))
        {
          v15 = v12 + 704 * v10;
          v17 = *(_DWORD *)(v15 + 196);
          v16 = (int *)(v15 + 196);
          if (v17 >= 1)
          {
            v44 = (int *)(v12 + 704 * v10 + 192);
            if (*v44 >= 1)
              break;
          }
        }
LABEL_71:
        v36 = *((_DWORD *)v1 + 47);
        v7 += 88 * v36;
        if (v10-- <= 0)
        {
          if ((v45 & 1) != 0)
            goto LABEL_77;
          LODWORD(v10) = *v40;
          if ((int)*v40 > 31)
            goto LABEL_77;
          goto LABEL_75;
        }
      }
      v18 = 0;
      v42 = v10;
      v19 = (int32x2_t *)(v12 + 704 * v10);
      v48 = v19[16];
      v20 = v19[17];
      v21 = *(int32x2_t *)(v16 - 3);
      v52 = 0;
      v53 = 0;
      v22 = v19[22];
      v23 = vmla_s32(v19[21], v22, v21);
      v46 = (int *)&v19[6];
      v47 = v20;
      v24 = v19 + 29;
      while (1)
      {
        v49 = v18;
        if ((v18 & 1) != 0)
        {
          if (*v16 < 2 || *(_QWORD *)&v48 == 0)
            goto LABEL_69;
          v25 = *v16 - 1;
          if ((v18 & 2) == 0)
          {
LABEL_27:
            v26 = 0;
            goto LABEL_38;
          }
        }
        else
        {
          v25 = 0;
          if ((v18 & 2) == 0)
            goto LABEL_27;
        }
        if (*v44 >= 2 && *(_QWORD *)&v47 != 0)
        {
          v26 = *v44 - 1;
LABEL_38:
          v52 = vmla_s32(v23, v22, (int32x2_t)__PAIR64__(v25, v26));
          v53 = v22;
          kdu_dims::operator&=(&v52, v46);
          if ((!*(_QWORD *)&v48 || v53.i32[1] == 1 && (v52.i8[4] & 1) == 0)
            && (!*(_QWORD *)&v47 || v53.i32[0] == 1 && (v52.i8[0] & 1) == 0))
          {
            if (v48)
            {
              v29 = 1;
            }
            else
            {
              if (v25)
              {
                v56 = 0;
                v54 = 0u;
                v55 = 0u;
                kdu_error::kdu_error((kdu_error *)&v54, "Kakadu Core Error:\n");
                (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "Assert ");
                (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "p_idx.x == 0");
                (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, " FAILED");
                kdu_error::~kdu_error((kdu_error *)&v54);
              }
              v29 = *v16;
            }
            v51 = v29;
            if (v47)
            {
              v30 = 1;
LABEL_54:
              v50 = v25;
              while (v51 < 1)
              {
LABEL_67:
                ++v26;
                v35 = __OFSUB__(v30--, 1);
                if ((v30 < 0) ^ v35 | (v30 == 0))
                  goto LABEL_69;
              }
              v31 = v50;
              v32 = v51 + 1;
              while (2)
              {
                v33 = (uint64_t *)(*(_QWORD *)v24 + 8 * (v31 + *v16 * (uint64_t)v26));
                v34 = *v33;
                if (!*v33)
                  goto LABEL_63;
                if (v34 == 3)
                {
                  v34 = 0;
                  goto LABEL_66;
                }
                if ((v34 & 1) != 0)
                {
LABEL_63:
                  v34 = kd_precinct_ref::instantiate_precinct(v33, v13, v26 | (unint64_t)(v31 << 32));
                }
                else
                {
                  if (*(_BYTE *)(v34 + 20))
                  {
                    kd_precinct_size_class::withdraw_from_inactive_list(*(_QWORD *)(v34 + 72), (kd_precinct *)v34);
                    goto LABEL_65;
                  }
                  if (*(_BYTE *)(v34 + 19))
LABEL_65:
                    kd_precinct::activate(v34);
                }
LABEL_66:
                kd_global_rescomp::add_ready_precinct(v7, (_QWORD *)v34);
                --v32;
                ++v31;
                if (v32 <= 1)
                  goto LABEL_67;
                continue;
              }
            }
            if (v26)
            {
              v56 = 0;
              v54 = 0u;
              v55 = 0u;
              kdu_error::kdu_error((kdu_error *)&v54, "Kakadu Core Error:\n");
              (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "Assert ");
              (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, "p_idx.y == 0");
              (*(void (**)(__int128 *, const char *))(v54 + 16))(&v54, " FAILED");
              kdu_error::~kdu_error((kdu_error *)&v54);
            }
            v30 = *v44;
            if (*v44 >= 1)
              goto LABEL_54;
          }
        }
LABEL_69:
        v18 = v49 + 1;
        if (v49 == 3)
        {
          v1 = v41;
          v10 = v42;
          goto LABEL_71;
        }
      }
    }
  }
LABEL_78:
  *((_BYTE *)v1 + 289) = 1;
  result = kd_tile::adjust_unloadability(v1);
  ++*(_DWORD *)(*v1 + 260);
  return result;
}

void sub_187EEE76C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EEE778(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  _Unwind_Exception *v25;

  _Unwind_Resume(v25);
}

uint64_t *kd_tile::adjust_unloadability(uint64_t *this)
{
  uint64_t v1;

  v1 = *this;
  if (*(_BYTE *)(*this + 417) && (*(_QWORD *)(v1 + 72) || *(_BYTE *)(v1 + 418)))
  {
    if (*((_BYTE *)this + 289) || *(uint64_t **)(v1 + 440) == this)
    {
      if (*((_BYTE *)this + 290))
        return kd_tile::withdraw_from_unloadable_list(this);
    }
    else if (!*((_BYTE *)this + 290))
    {
      return (uint64_t *)kd_tile::add_to_unloadable_list((uint64_t)this);
    }
  }
  else if (*((_BYTE *)this + 290))
  {
    kd_tile::adjust_unloadability();
  }
  return this;
}

uint64_t kd_node::adjust_cover(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;

  if ((a3 & 0x8000000080000000) == 0)
  {
    if (a4 <= 1)
      v5 = a4 + 2 * HIDWORD(a2);
    else
      v5 = HIDWORD(a2);
    if (a4 <= 1)
      v6 = a4 + 2 * (HIDWORD(a3) + HIDWORD(a2)) - 1;
    else
      v6 = HIDWORD(a3) + HIDWORD(a2);
    if (a5 <= 1)
      v7 = a5 + 2 * (_DWORD)a2;
    else
      v7 = a2;
    if (a5 <= 1)
      v8 = a5 + 2 * (a3 + a2) - 1;
    else
      v8 = a3 + a2;
    v9 = *(_DWORD *)(result + 64);
    if (v9 < 1 || (v10 = *(_DWORD *)(result + 60), v10 <= 0))
    {
      *(_QWORD *)(result + 52) = v7 | (v5 << 32);
      *(_QWORD *)(result + 60) = (v8 - v7) | ((unint64_t)(v6 - v5) << 32);
    }
    else
    {
      v11 = *(_DWORD *)(result + 56) - v5;
      if (v11 < 1)
      {
        LODWORD(v5) = *(_DWORD *)(result + 56);
      }
      else
      {
        *(_DWORD *)(result + 56) = v5;
        v9 += v11;
        *(_DWORD *)(result + 64) = v9;
      }
      v12 = v6 - v5;
      if (v12 > v9)
        *(_DWORD *)(result + 64) = v12;
      v13 = *(_DWORD *)(result + 52) - v7;
      if (v13 < 1)
      {
        LODWORD(v7) = *(_DWORD *)(result + 52);
      }
      else
      {
        *(_DWORD *)(result + 52) = v7;
        v10 += v13;
        *(_DWORD *)(result + 60) = v10;
      }
      v14 = v8 - v7;
      if (v14 > v10)
        *(_DWORD *)(result + 60) = v14;
    }
  }
  return result;
}

uint64_t kd_tile::add_to_unloadable_list(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v1 = this;
  if (*(_BYTE *)(this + 290))
  {
    v7 = 0;
    v5 = 0u;
    v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "Assert ");
    (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "!is_unloadable");
    (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  v2 = *(_QWORD *)this;
  v3 = *(_QWORD *)(*(_QWORD *)this + 488);
  *(_QWORD *)(this + 56) = 0;
  *(_QWORD *)(this + 64) = v3;
  if (v3)
  {
    v4 = (_QWORD *)(v3 + 56);
  }
  else
  {
    if (*(_QWORD *)(v2 + 480))
    {
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "Assert ");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "codestream->unloadable_tiles_head == NULL");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    v4 = (_QWORD *)(v2 + 480);
  }
  *v4 = this;
  *(_QWORD *)(v2 + 488) = this;
  ++*(_DWORD *)(v2 + 504);
  *(_BYTE *)(this + 290) = 1;
  if (!*(_QWORD *)(v2 + 496))
  {
    this = kdu_dims::intersects((_DWORD *)(this + 212), (_DWORD *)(v2 + 264));
    if ((this & 1) == 0)
      *(_QWORD *)(*(_QWORD *)v1 + 496) = v1;
  }
  return this;
}

void sub_187EEEA94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EEEAA0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL kdu_dims::intersects(_DWORD *a1, _DWORD *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;

  v2 = a1[1];
  v3 = a1[3];
  v4 = a2[1];
  if (v3 + v2 <= v4)
    return 0;
  v5 = a1[2];
  if (v5 + *a1 <= *a2)
    return 0;
  v6 = a2[3];
  if (v2 >= v6 + v4)
    return 0;
  v7 = a2[2];
  if (*a1 >= v7 + *a2)
    return 0;
  return v3 > 0 && v5 > 0 && v6 > 0 && v7 > 0;
}

uint64_t kd_precinct::desequence_packet(kd_precinct *this)
{
  kd_tile *v2;
  uint64_t packet;
  int v4;
  int v5;

  if (*((_BYTE *)this + 17) || *((_BYTE *)this + 18))
    kd_precinct::desequence_packet();
  v2 = *(kd_tile **)(*(_QWORD *)(*(_QWORD *)this + 8) + 8);
  packet = kd_precinct::read_packet((uint64_t **)this);
  if ((_DWORD)packet)
  {
    v4 = *((_DWORD *)this + 7) + 1;
    *((_DWORD *)this + 7) = v4;
    if (v4 == *((_DWORD *)v2 + 48))
      kd_precinct::finished_desequencing((uint64_t *)this);
    ++*((_DWORD *)v2 + 78);
    if (*((_BYTE *)this + 21))
    {
      if (*((_DWORD *)this + 7) <= *((_DWORD *)v2 + 50))
      {
        v5 = *((_DWORD *)v2 + 77) + 1;
        *((_DWORD *)v2 + 77) = v5;
        if (v5 == *((_DWORD *)v2 + 52))
          kd_tile::finished_reading(v2);
      }
    }
  }
  return packet;
}

uint64_t kd_compressed_input::get_offset(kd_compressed_input *this)
{
  if (*((_BYTE *)this + 608))
    kd_compressed_input::get_offset();
  return *((_QWORD *)this + 70) - (_QWORD)this + *((_QWORD *)this + 66) - 14;
}

uint64_t *kd_precinct::finished_desequencing(uint64_t *this)
{
  if (!*((_BYTE *)this + 17))
  {
    *((_BYTE *)this + 17) = 1;
    if (!*((_DWORD *)this + 7))
    {
      *((_BYTE *)this + 18) = 1;
      this[5] = 0;
    }
    if (!*((_DWORD *)this + 9))
      return kd_precinct::release(this);
  }
  return this;
}

uint64_t kd_tile::generate_tile_part(kd_tile *this, int a2, unsigned __int16 *a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int marker_segments;
  _DWORD *v8;
  int v9;
  int v10;
  uint64_t *v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  int v23;
  kdu_output *v24;
  int v25;
  int v26;
  uint64_t result;
  int v28;
  uint64_t v29;
  kd_precinct **v30;
  uint64_t v31;
  char *v32;
  int v33;
  char v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  BOOL v39;
  kd_precinct **v40;
  uint64_t v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _BOOL4 v47;
  _QWORD *v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v61;
  uint64_t v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  char v66[16];
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 77) == *((_DWORD *)this + 52))
    return 0;
  if (!*((_BYTE *)this + 288))
  {
    *(_QWORD *)&v68 = 0;
    *(_OWORD *)v66 = 0u;
    v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Assert ");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "is_in_progress");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  v4 = *((_DWORD *)this + 76);
  if (v4 >= 255)
  {
    v65 = 0;
    v63 = 0u;
    v64 = 0u;
    kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Too many tile-parts for tile ");
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    *(_OWORD *)v66 = 0u;
    if (BYTE8(v63))
      sprintf(v66, "%x");
    else
      sprintf(v66, "%d");
    (*(void (**)(__int128 *, char *))(v63 + 16))(&v63, v66);
    (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, ".  No tile may have more than 255 parts.");
    kdu_error::~kdu_error((kdu_error *)&v63);
  }
  if (*(int *)(*(_QWORD *)this + 104) >= 1 && *(_DWORD *)(*(_QWORD *)this + 108) <= v4)
  {
    v65 = 0;
    v63 = 0u;
    v64 = 0u;
    kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Too many tile-parts for tile ");
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    *(_OWORD *)v66 = 0u;
    if (BYTE8(v63))
      sprintf(v66, "%x");
    else
      sprintf(v66, "%d");
    (*(void (**)(__int128 *, char *))(v63 + 16))(&v63, v66);
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    *(_OWORD *)v66 = 0u;
    if (BYTE8(v63))
      sprintf(v66, "%x");
    else
      sprintf(v66, "%d");
    (*(void (**)(__int128 *, char *))(v63 + 16))(&v63, v66);
    (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, ".");
    kdu_error::~kdu_error((kdu_error *)&v63);
  }
  v5 = *(_QWORD *)this;
  if (*(_DWORD *)(*(_QWORD *)this + 364) < a2)
  {
    *(_QWORD *)&v68 = 0;
    *(_OWORD *)v66 = 0u;
    v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "Assert ");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, "max_layers <= codestream->num_sized_layers");
    (*(void (**)(char *, const char *))(*(_QWORD *)v66 + 16))(v66, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  v6 = *((unsigned int *)this + 76);
  *((_DWORD *)this + 76) = v6 + 1;
  marker_segments = kdu_params::generate_marker_segments(*(kdu_params **)(v5 + 24), 0, *((_DWORD *)this + 2), v6);
  bzero(v66, 0x400uLL);
  v8 = *(_DWORD **)this;
  if (!*(_DWORD *)(*(_QWORD *)this + 160))
  {
    v9 = v8[114];
    if ((v9 & 0x80000000) == 0)
    {
      if (v9 != *((_DWORD *)this + 2))
      {
        v65 = 0;
        v63 = 0u;
        v64 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v63, "Kakadu Core Warning:\n");
        (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Profile violation detected (code-stream is technically illegal).  In a Profile-0 code-stream, all first tile-parts of all tiles must appear first, in exactly the same order as their respective tile numbers.");
        *(_DWORD *)(*(_QWORD *)this + 160) = 2;
        kdu_warning::~kdu_warning((kdu_warning *)&v63);
        v8 = *(_DWORD **)this;
        v9 = *(_DWORD *)(*(_QWORD *)this + 456);
      }
      if (v9 + 1 == v8[55] * v8[56])
        v10 = -1;
      else
        v10 = v9 + 1;
      v8[114] = v10;
    }
  }
  v61 = 0;
  v62 = 0;
  kd_packet_sequencer::save_state(*((_BYTE **)this + 12));
  v11 = kd_packet_sequencer::next_in_sequence(*((uint64_t **)this + 12), &v62, &v61);
  if (!v11)
  {
LABEL_71:
    --*((_DWORD *)this + 76);
    kd_packet_sequencer::restore_state(*((uint64_t **)this + 12));
    return 0;
  }
  v12 = 0;
  v13 = marker_segments + 14;
  v57 = -1;
  v14 = -1;
  v15 = -1;
  LODWORD(v16) = -1;
  while (1)
  {
    v17 = *v11;
    if (!*v11)
      goto LABEL_35;
    if (v17 == 3)
      goto LABEL_135;
    if ((v17 & 1) != 0)
    {
LABEL_35:
      v17 = kd_precinct_ref::instantiate_precinct(v11, v62, v61);
      if (!v17)
      {
LABEL_135:
        v65 = 0;
        v63 = 0u;
        v64 = 0u;
        kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Assert ");
        (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "precinct != NULL");
        (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v63);
      }
    }
    else
    {
      if (*(_BYTE *)(v17 + 20))
      {
        kd_precinct_size_class::withdraw_from_inactive_list(*(_QWORD *)(v17 + 72), (kd_precinct *)v17);
LABEL_38:
        kd_precinct::activate(v17);
        goto LABEL_39;
      }
      if (*(_BYTE *)(v17 + 19))
        goto LABEL_38;
    }
LABEL_39:
    if (*(int *)(v17 + 36) > 0)
      break;
    v18 = *(_DWORD *)(v17 + 28);
    if (v18 >= *((_DWORD *)this + 48))
    {
      v65 = 0;
      v63 = 0u;
      v64 = 0u;
      kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Assert ");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "layer_idx < num_layers");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v63);
    }
    if (v15 < 0)
    {
      v15 = *(unsigned __int8 *)(*(_QWORD *)v17 + 24);
      v14 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v17 + 8) + 24);
      v57 = *(_DWORD *)(v17 + 28);
    }
    if (*((_BYTE *)this + 295) && v15 != *(unsigned __int8 *)(*(_QWORD *)v17 + 24)
      || *((_BYTE *)this + 296) && v14 != *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v17 + 8) + 24)
      || *((_BYTE *)this + 297) && v57 != v18)
    {
      break;
    }
    v19 = *(_QWORD *)(v17 + 40);
    if (!v19 || (v20 = *(_QWORD *)(v19 + 8 * v18)) == 0)
    {
      v65 = 0;
      v63 = 0u;
      v64 = 0u;
      kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Attempting to generate tile-part data without first determining packet lengths.  This may be a consequence of incomplete simulation of the packet construction process.");
      kdu_error::~kdu_error((kdu_error *)&v63);
    }
    v13 += v20;
    if (*((_BYTE *)this + 294))
    {
      if ((v16 & 0x80000000) != 0)
      {
        LODWORD(v16) = 0;
        *(_DWORD *)v66 = 5;
      }
      v21 = 1;
      if (v20 >= 128)
      {
        do
        {
          v22 = (unint64_t)v20 >> 14;
          v20 = (unint64_t)v20 >> 7;
          ++v21;
        }
        while (v22);
      }
      v23 = *(_DWORD *)&v66[4 * v16];
      *(_DWORD *)&v66[4 * v16] = v23 + v21;
      if (v23 + v21 >= 65538)
      {
        *(_DWORD *)&v66[4 * v16] = v23;
        if ((int)v16 >= 255)
        {
          v65 = 0;
          v63 = 0u;
          v64 = 0u;
          kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Cannot satisfy the request to generate PLT marker segments!  There are so many packets in one tile-part that it is beyond the capacity of the maximum 256 marker segments to represent length information for all tile-parts!!");
          kdu_error::~kdu_error((kdu_error *)&v63);
        }
        v13 += v23;
        v16 = (int)v16 + 1;
        *(_DWORD *)&v66[4 * v16] = v21 + 5;
      }
    }
    ++*(_DWORD *)(v17 + 28);
    ++*((_DWORD *)this + 77);
    v11 = kd_packet_sequencer::next_in_sequence(*((uint64_t **)this + 12), &v62, &v61);
    ++v12;
    if (!v11)
      goto LABEL_65;
  }
  if (!v12)
    goto LABEL_71;
LABEL_65:
  if ((v16 & 0x80000000) == 0)
    v13 += *(int *)&v66[4 * v16];
  v58 = v13;
  if (v13 >= 0x100000000)
  {
    v65 = 0;
    v63 = 0u;
    v64 = 0u;
    kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Length of current tile-part exceeds the maximum value which can be represented by the 32-bit length field in the SOT marker!  You will have to split the code-stream into smaller tile-parts -- see the \"ORGtparts\" parameter attribute.");
    kdu_error::~kdu_error((kdu_error *)&v63);
  }
  v24 = *(kdu_output **)(*(_QWORD *)this + 16);
  v55 = *((_QWORD *)v24 + 65);
  v56 = *((_QWORD *)v24 + 68);
  kdu_output::put(v24, 255);
  kdu_output::put(v24, 144);
  kdu_output::put(v24, 0);
  kdu_output::put(v24, 10);
  v25 = *((_DWORD *)this + 2);
  kdu_output::put(v24, SBYTE1(v25));
  kdu_output::put(v24, v25);
  kdu_output::put(v24, v58);
  kdu_output::put(v24, *((_BYTE *)this + 304) - 1);
  if (*(int *)(*(_QWORD *)this + 104) < 1)
  {
    if (*((_DWORD *)this + 77) == *((_DWORD *)this + 52))
      v26 = *((_DWORD *)this + 76);
    else
      LOBYTE(v26) = 0;
  }
  else
  {
    v26 = *(_DWORD *)(*(_QWORD *)this + 108);
  }
  kdu_output::put(v24, v26);
  **(_QWORD **)(*(_QWORD *)this + 368) += (int)(kdu_params::generate_marker_segments(*(kdu_params **)(*(_QWORD *)this + 24), v24, *((_DWORD *)this + 2), (*((_DWORD *)this + 76) - 1))+ 12);
  if ((int)v16 >= 0)
  {
    if (!*((_BYTE *)this + 294))
    {
      v65 = 0;
      v63 = 0u;
      v64 = 0u;
      kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Assert ");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "insert_plt_segments");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v63);
    }
    kd_packet_sequencer::restore_state(*((uint64_t **)this + 12));
    v28 = 0;
    LODWORD(v29) = -1;
    while (1)
    {
      v30 = (kd_precinct **)kd_packet_sequencer::next_in_sequence(*((uint64_t **)this + 12), &v62, &v61);
      if (!v30)
      {
        v65 = 0;
        v63 = 0u;
        v64 = 0u;
        kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Assert ");
        (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "p_ref != NULL");
        (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v63);
      }
      v31 = (uint64_t)*v30;
      if (*v30)
      {
        if (v31 == 3)
        {
          v31 = 0;
          goto LABEL_90;
        }
        if ((v31 & 1) == 0)
        {
          if (*(_BYTE *)(v31 + 20))
          {
            kd_precinct_size_class::withdraw_from_inactive_list(*(_QWORD *)(v31 + 72), *v30);
            kd_precinct::activate(v31);
          }
          else if (*(_BYTE *)(v31 + 19))
          {
            kd_precinct::activate((uint64_t)*v30);
          }
          goto LABEL_90;
        }
      }
      v31 = kd_precinct_ref::instantiate_precinct((uint64_t *)v30, v62, v61);
LABEL_90:
      if ((v29 & 0x80000000) != 0 || !*(_DWORD *)&v66[4 * v29])
      {
        kdu_output::put(v24, 255);
        kdu_output::put(v24, 88);
        v29 = (int)v29 + 1;
        v32 = &v66[4 * v29];
        v33 = *(_DWORD *)v32;
        v34 = *(_DWORD *)v32 - 2;
        kdu_output::put(v24, (unsigned __int16)(*(_DWORD *)v32 - 2) >> 8);
        kdu_output::put(v24, v34);
        kdu_output::put(v24, v29);
        *(_DWORD *)v32 = v33 - 5;
      }
      v35 = 0;
      v36 = *(_QWORD *)(*(_QWORD *)(v31 + 40) + 8 * *(int *)(v31 + 28));
      do
      {
        v37 = v36 >> v35;
        v35 += 7;
      }
      while (v37 > 127);
      v38 = v35 - 7;
      do
      {
        kdu_output::put(v24, (v36 >> v38) & 0x7F | ((v38 != 0) << 7));
        --*(_DWORD *)&v66[4 * (int)v29];
        v39 = v38 <= 6;
        v38 -= 7;
      }
      while (!v39);
      ++*(_DWORD *)(v31 + 28);
      ++*((_DWORD *)this + 77);
      if (++v28 == v12)
      {
        if (*(_DWORD *)&v66[4 * (int)v29])
        {
          v65 = 0;
          v63 = 0u;
          v64 = 0u;
          kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Assert ");
          (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "plt_seg_lengths[current_plt_seg] == 0");
          (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, " FAILED");
          kdu_error::~kdu_error((kdu_error *)&v63);
        }
        break;
      }
    }
  }
  kdu_output::put(v24, 255);
  kdu_output::put(v24, 147);
  **(_QWORD **)(*(_QWORD *)this + 368) += 2;
  kd_packet_sequencer::restore_state(*((uint64_t **)this + 12));
  while (2)
  {
    v40 = (kd_precinct **)kd_packet_sequencer::next_in_sequence(*((uint64_t **)this + 12), &v62, &v61);
    if (!v40)
    {
      v65 = 0;
      v63 = 0u;
      v64 = 0u;
      kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Assert ");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "p_ref != NULL");
      (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v63);
    }
    v41 = (uint64_t)*v40;
    if (*v40)
      v42 = ((unint64_t)*v40 & 1) == 0;
    else
      v42 = 0;
    if (v42)
    {
      if (*(_BYTE *)(v41 + 20))
      {
        kd_precinct_size_class::withdraw_from_inactive_list(*(_QWORD *)(v41 + 72), *v40);
        kd_precinct::activate(v41);
      }
      else if (*(_BYTE *)(v41 + 19))
      {
        kd_precinct::activate((uint64_t)*v40);
      }
    }
    else
    {
      v41 = kd_precinct_ref::instantiate_precinct((uint64_t *)v40, v62, v61);
    }
    v43 = *(int *)(v41 + 28);
    if ((int)v43 < a2)
    {
      v44 = kd_precinct::write_packet((kd_precinct *)v41, a3[v43], 0);
      v45 = *(_QWORD *)this;
      v46 = *(_QWORD *)(*(_QWORD *)this + 368);
      goto LABEL_119;
    }
    v47 = (int)v43 < *(_DWORD *)(*(_QWORD *)this + 364);
    v44 = kd_precinct::write_packet((kd_precinct *)v41, 0, 1);
    v45 = *(_QWORD *)this;
    v46 = *(_QWORD *)(*(_QWORD *)this + 368);
    if (v47)
LABEL_119:
      v48 = (_QWORD *)(v46 + 8 * v43);
    else
      v48 = (_QWORD *)(v46 + 8 * *(int *)(v45 + 364) - 8);
    *v48 += v44;
    if (--v12)
      continue;
    break;
  }
  if (v58 != *((_QWORD *)v24 + 68) - (v56 + v55) + *((_QWORD *)v24 + 65))
  {
    v65 = 0;
    v63 = 0u;
    v64 = 0u;
    kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "Assert ");
    (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, "tpart_bytes == (out->get_bytes_written() - start_bytes)");
    (*(void (**)(__int128 *, const char *))(v63 + 16))(&v63, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v63);
  }
  v50 = *(_DWORD *)(v45 + 104);
  v49 = v45 + 104;
  ++*(_DWORD *)(v49 + 356);
  if (v50 >= 1)
    kd_tlm_generator::add_tpart_length(v49, *((_DWORD *)this + 2), v58);
  if (*((_DWORD *)this + 77) != *((_DWORD *)this + 52))
    return v58;
  if (*(int *)(*(_QWORD *)this + 104) >= 1)
  {
    v51 = *(_DWORD *)(*(_QWORD *)this + 108);
    v52 = *((_DWORD *)this + 76);
    while (v51 > v52)
    {
      kdu_output::put(v24, 255);
      kdu_output::put(v24, 144);
      kdu_output::put(v24, 0);
      kdu_output::put(v24, 10);
      v53 = *((_DWORD *)this + 2);
      kdu_output::put(v24, SBYTE1(v53));
      kdu_output::put(v24, v53);
      kdu_output::put(v24, 12);
      kdu_output::put(v24, *((_BYTE *)this + 304));
      kdu_output::put(v24, *(_BYTE *)(*(_QWORD *)this + 108));
      kdu_output::put(v24, 255);
      kdu_output::put(v24, 147);
      v54 = *(_QWORD *)this;
      **(_QWORD **)(*(_QWORD *)this + 368) += 14;
      kd_tlm_generator::add_tpart_length(v54 + 104, *((_DWORD *)this + 2), 0xEuLL);
      v52 = *((_DWORD *)this + 76) + 1;
      *((_DWORD *)this + 76) = v52;
      v51 = *(_DWORD *)(*(_QWORD *)this + 108);
    }
  }
  kd_tile::remove_from_in_progress_list((uint64_t *)this);
  if (!*((_BYTE *)this + 291))
    return v58;
  result = v58;
  if (!*(_BYTE *)(*(_QWORD *)this + 408))
  {
    kd_tile::release(this);
    return v58;
  }
  return result;
}

void sub_187EEFB6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

uint64_t kdu_output::put(kdu_output *this, int a2)
{
  kdu_output::put(this, SHIBYTE(a2));
  kdu_output::put(this, SBYTE2(a2));
  kdu_output::put(this, SBYTE1(a2));
  kdu_output::put(this, a2);
  return 4;
}

uint64_t kdu_output::put(kdu_output *this, char a2)
{
  _BYTE *v4;

  v4 = (_BYTE *)*((_QWORD *)this + 65);
  if (v4 == *((_BYTE **)this + 66))
  {
    (*(void (**)(kdu_output *))(*(_QWORD *)this + 16))(this);
    v4 = (_BYTE *)*((_QWORD *)this + 65);
    if ((unint64_t)v4 >= *((_QWORD *)this + 66))
      kdu_output::put();
  }
  *((_QWORD *)this + 65) = v4 + 1;
  *v4 = a2;
  return 1;
}

uint64_t kd_precinct::write_packet(kd_precinct *this, unsigned int a2, char a3)
{
  char v3;
  uint64_t v5;
  kdu_output *v6;
  uint64_t v7;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  _OWORD v37[2];
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  kdu_output *v41;

  v3 = a3;
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8) + 8);
  v6 = *(kdu_output **)(**(_QWORD **)this + 16);
  if ((a3 & 1) != 0)
  {
    v7 = 0;
    v39 = 0x700000000;
    v40 = 0;
    v41 = v6;
  }
  else
  {
    if (*(_BYTE *)(*(_QWORD *)this + 222))
    {
      v9 = 0;
      v7 = 0;
      do
      {
        v10 = *((_QWORD *)this + 6);
        if (!*((_DWORD *)this + 7))
          kd_block::reset_output_tree(*(_QWORD *)(v10 + 32 * v9 + 24), *(_QWORD *)(v10 + 32 * v9 + 16));
        v11 = v10 + 32 * v9;
        v12 = *(_DWORD *)(v11 + 16) * *(_DWORD *)(v11 + 20);
        if (v12 >= 1)
        {
          v13 = 0;
          v14 = (_QWORD *)(v11 + 24);
          v15 = 40 * v12;
          do
          {
            v7 += (int)kd_block::start_packet((kd_block *)(*v14 + v13), *((_DWORD *)this + 7), a2);
            v13 += 40;
          }
          while (v15 != v13);
        }
        ++v9;
      }
      while (v9 < *(unsigned __int8 *)(*(_QWORD *)this + 222));
      v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8) + 8);
      v3 = a3;
    }
    else
    {
      v7 = 0;
      v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8) + 8);
    }
    if (*(_BYTE *)(v16 + 284))
    {
      kdu_output::put(v6, 255);
      kdu_output::put(v6, 145);
      kdu_output::put(v6, 0);
      kdu_output::put(v6, 4);
      v17 = *(_DWORD *)(v5 + 308);
      kdu_output::put(v6, SBYTE1(v17));
      kdu_output::put(v6, v17);
      v7 += 6;
    }
    v39 = 0x800000000;
    v40 = 0;
    v41 = v6;
    kd_header_out::put_bit((unsigned __int8 *)&v39, 1u);
    v18 = *(_QWORD *)this;
    if (*(_BYTE *)(*(_QWORD *)this + 222))
    {
      v19 = 0;
      do
      {
        v20 = *((_QWORD *)this + 6) + 32 * v19;
        v21 = *(_DWORD *)(v20 + 16) * *(_DWORD *)(v20 + 20);
        if (v21 >= 1)
        {
          v22 = 0;
          v23 = (_QWORD *)(v20 + 24);
          v24 = 40 * v21;
          do
          {
            kd_block::write_packet_header((unsigned __int8 *)(*v23 + v22), (kd_header_out *)&v39, *((_DWORD *)this + 7), 0);
            v22 += 40;
          }
          while (v24 != v22);
          v18 = *(_QWORD *)this;
        }
        ++v19;
      }
      while (v19 < *(unsigned __int8 *)(v18 + 222));
    }
  }
  v25 = v7 + (int)kd_header_out::finish((kd_header_out *)&v39);
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8) + 8) + 285))
  {
    kdu_output::put(v6, 255);
    kdu_output::put(v6, 146);
    v25 += 2;
  }
  if ((v3 & 1) == 0)
  {
    v26 = *(_QWORD *)this;
    if (*(_BYTE *)(*(_QWORD *)this + 222))
    {
      v27 = 0;
      do
      {
        v28 = *((_QWORD *)this + 6) + 32 * v27;
        v29 = *(_DWORD *)(v28 + 16) * *(_DWORD *)(v28 + 20);
        if (v29 >= 1)
        {
          v30 = 0;
          v31 = (_QWORD *)(v28 + 24);
          v32 = 40 * v29;
          do
          {
            kd_block::write_body_bytes((_DWORD *)(*v31 + v30), v6);
            v30 += 40;
          }
          while (v32 != v30);
          v26 = *(_QWORD *)this;
        }
        ++v27;
      }
      while (v27 < *(unsigned __int8 *)(v26 + 222));
    }
  }
  v33 = *((int *)this + 7);
  if (v25 != *(_QWORD *)(*((_QWORD *)this + 5) + 8 * v33))
  {
    v38 = 0;
    memset(v37, 0, sizeof(v37));
    kdu_error::kdu_error((kdu_error *)v37, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v37[0] + 16))(v37, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v37[0] + 16))(v37, "check_bytes == packet_bytes[next_layer_idx]");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v37[0] + 16))(v37, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v37);
  }
  v34 = v33 + 1;
  *((_DWORD *)this + 7) = v34;
  ++*(_DWORD *)(v5 + 308);
  if (v34 == *(_DWORD *)(v5 + 192))
    kd_global_rescomp::close_ready_precinct(*(kd_global_rescomp **)(*(_QWORD *)this + 16), this);
  return v25;
}

void sub_187EF0090(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EF009C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

kdu_thread_entity *kdu_tile::close(uint64_t **a1, kdu_thread_entity *this)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int *v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t i;
  uint64_t *v25;
  BOOL v26;
  kdu_thread_entity *result;
  kdu_thread_entity *v29;
  uint64_t v31;
  int *v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  if (this)
    kdu_thread_entity::acquire_lock(this, 0, 1);
  v29 = this;
  v3 = *a1;
  if (!*((_BYTE *)*a1 + 289))
  {
    v35 = 0;
    v33 = 0u;
    v34 = 0u;
    kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, "Assert ");
    (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, "0");
    (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v33);
  }
  v4 = *v3;
  --*(_DWORD *)(*v3 + 260);
  *((_BYTE *)v3 + 289) = 0;
  if (*((_BYTE *)v3 + 291))
  {
    v35 = 0;
    v33 = 0u;
    v34 = 0u;
    kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, "Assert ");
    (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, "!state->closed");
    (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v33);
  }
  if (*(_QWORD *)(v4 + 8) && *((int *)v3 + 47) >= 1)
  {
    v5 = 0;
    do
    {
      v6 = v3[34];
      v7 = v6 + 224 * v5;
      v8 = *(_DWORD *)(v7 + 68);
      v32 = (int *)(v7 + 68);
      if ((v8 & 0x80000000) == 0)
      {
        v9 = 0;
        v31 = v5;
        v10 = (_QWORD *)(v6 + 224 * v5 + 176);
        do
        {
          v11 = *v10 + 704 * v9;
          v14 = *(_DWORD *)(v11 + 200);
          v12 = v11 + 200;
          v13 = v14;
          v16 = (int *)(v12 + 8);
          v15 = *(_DWORD *)(v12 + 8);
          if (v15 >= 1)
          {
            v17 = 0;
            v18 = v13 - *(_DWORD *)(v12 - 16);
            v19 = *v10 + 704 * v9;
            v22 = *(_DWORD *)(v19 + 212);
            v21 = v19 + 212;
            v20 = v22;
            v23 = 8 * (*(_DWORD *)(v12 + 4) - *(_DWORD *)(v12 - 12));
            do
            {
              if (v20 >= 1)
              {
                for (i = 0; i < v20; ++i)
                {
                  v25 = *(uint64_t **)(*(_QWORD *)(v21 + 20) + 8 * v18 * *(_DWORD *)(v21 - 16) + v23 + 8 * i);
                  if (v25)
                    v26 = (*(_QWORD *)(*(_QWORD *)(v21 + 20) + 8 * v18 * *(_DWORD *)(v21 - 16) + v23 + 8 * i) & 1) == 0;
                  else
                    v26 = 0;
                  if (v26)
                  {
                    kd_precinct::release(v25);
                    v20 = *(_DWORD *)v21;
                  }
                }
                v15 = *v16;
              }
              ++v17;
              ++v18;
            }
            while (v17 < v15);
            v8 = *v32;
          }
        }
        while (v9++ < v8);
        v5 = v31;
        v3 = *a1;
      }
      ++v5;
    }
    while (v5 < *((int *)v3 + 47));
    v4 = *v3;
  }
  if ((!*(_BYTE *)(v4 + 417) || *((_BYTE *)v3 + 287))
    && ((*((_BYTE *)v3 + 291) = 1, *(_QWORD *)(v4 + 8)) && *((_BYTE *)v3 + 328)
     || *(_QWORD *)(v4 + 16) && *((_DWORD *)v3 + 77) == *((_DWORD *)v3 + 52))
    && !*(_BYTE *)(v4 + 408))
  {
    kd_tile::release((kd_tile *)v3);
    *a1 = 0;
  }
  else
  {
    kd_tile::adjust_unloadability(v3);
  }
  *a1 = 0;
  result = v29;
  if (v29)
    return (kdu_thread_entity *)kdu_thread_entity::release_lock(v29, 0);
  return result;
}

void sub_187EF03B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EF03C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Exception *v13;

  _Unwind_Resume(v13);
}

uint64_t kdu_thread_entity::acquire_lock(kdu_thread_entity *this, int a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  kdu_thread_entity *v7;
  uint64_t result;
  _DWORD *exception;

  if (a2 < 0
    || *((_DWORD *)this + 12) <= a2
    || (v4 = *((_QWORD *)this + 7),
        v5 = v4 + 80 * a2,
        v7 = *(kdu_thread_entity **)(v5 + 72),
        v6 = (_QWORD *)(v5 + 72),
        v7 == this))
  {
    kdu_thread_entity::acquire_lock();
  }
  if (a3 && **((_BYTE **)this + 5))
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = *(_DWORD *)(*((_QWORD *)this + 5) + 4);
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  result = v4 + 80 * a2;
  if (*(_BYTE *)(result + 64))
    result = pthread_mutex_lock((pthread_mutex_t *)result);
  *v6 = this;
  return result;
}

uint64_t kdu_thread_entity::release_lock(kdu_thread_entity *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  kdu_thread_entity *v5;
  uint64_t result;

  if (a2 < 0
    || *((_DWORD *)this + 12) <= a2
    || (v2 = *((_QWORD *)this + 7),
        v3 = v2 + 80 * a2,
        v5 = *(kdu_thread_entity **)(v3 + 72),
        v4 = (_QWORD *)(v3 + 72),
        v5 != this))
  {
    kdu_thread_entity::release_lock();
  }
  result = v2 + 80 * a2;
  *v4 = 0;
  if (*(_BYTE *)(result + 64))
    return pthread_mutex_unlock((pthread_mutex_t *)result);
  return result;
}

uint64_t *kd_precinct::release(uint64_t *this)
{
  uint64_t v1;
  _QWORD *v2;
  BOOL v3;
  int v4;

  v1 = *(_QWORD *)*this;
  if (!*(_QWORD *)(v1 + 8))
    kd_precinct::release();
  *((_DWORD *)this + 9) = 0;
  *((_BYTE *)this + 19) = 1;
  if (*((_BYTE *)this + 18) || *((_BYTE *)this + 17) && !*(_BYTE *)(v1 + 417))
  {
    this = (uint64_t *)this[1];
    v2 = (_QWORD *)*this;
    if (*this)
      v3 = (*this & 1) == 0;
    else
      v3 = 0;
    if (!v3)
      kd_precinct::release();
    if (!*((_BYTE *)v2 + 20))
    {
      *((_BYTE *)v2 + 19) = 1;
      if (!*((_BYTE *)v2 + 18))
        return kd_precinct_ref::close(this);
      if (*(_BYTE *)(*(_QWORD *)*v2 + 418))
        return kd_precinct_ref::close(this);
      v4 = *((_DWORD *)v2 + 8);
      if (v4 && v4 != *((_DWORD *)v2 + 7))
        return kd_precinct_ref::close(this);
      else
        return kd_precinct_size_class::move_to_inactive_list((uint64_t *)v2[9], (kd_precinct *)v2);
    }
  }
  return this;
}

uint64_t kdu_tile::get_tile_idx(unsigned __int8 ***this)
{
  uint64_t v1;
  unsigned __int8 *v2;
  int v3;
  int v4;
  int v5;
  BOOL v6;
  unsigned int v7;
  uint64_t v8;

  LODWORD(v1) = *((_DWORD *)*this + 3);
  v2 = **this;
  v3 = v2[409];
  v4 = v2[410];
  v5 = v2[411];
  v6 = v3 == 0;
  if (v3)
    v7 = *((_DWORD *)*this + 3);
  else
    v7 = *((_DWORD *)*this + 4);
  if (!v6)
    LODWORD(v1) = *((_DWORD *)*this + 4);
  if (v5)
    v8 = -v7;
  else
    v8 = v7;
  if (v4)
    v1 = -(int)v1;
  else
    v1 = v1;
  return v1 | (v8 << 32);
}

BOOL kdu_tile::get_ycc(kdu_tile *this)
{
  uint64_t v1;
  _BOOL8 result;
  uint64_t v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  _OWORD v7[2];
  uint64_t v8;

  v1 = *(_QWORD *)this;
  if (*(_BYTE *)(*(_QWORD *)this + 286) && *(int *)(v1 + 188) >= 3)
  {
    v3 = 184;
    while (*(_BYTE *)(*(_QWORD *)(v1 + 272) + v3))
    {
      v3 += 224;
      if (v3 == 856)
      {
        if (*(_DWORD *)(*(_QWORD *)v1 + 184) != 1)
          return 1;
        v4 = 88;
        do
        {
          v5 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 312) + v4);
          if (v5 < 0)
          {
            v8 = 0;
            memset(v7, 0, sizeof(v7));
            kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
            (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, "Assert ");
            (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, "apparent_idx >= 0");
            (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, " FAILED");
            kdu_error::~kdu_error((kdu_error *)v7);
          }
          result = *(_BYTE *)(*(_QWORD *)(v1 + 272) + 224 * v5 + 185) != 0;
          if (!*(_BYTE *)(*(_QWORD *)(v1 + 272) + 224 * v5 + 185))
            break;
          v6 = v4 == 296;
          v4 += 104;
        }
        while (!v6);
        return result;
      }
    }
  }
  return 0;
}

void sub_187EF0718(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF0724()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kdu_tile::set_components_of_interest(uint64_t **this, signed int a2, unsigned int *a3)
{
  unsigned int *v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  uint64x2_t v20;
  int64x2_t v21;
  BOOL *v22;
  int64x2_t v23;
  int32x2_t v24;
  uint64_t v25;
  _DWORD *v26;

  v3 = a3;
  v4 = *this;
  v5 = **this;
  v6 = *(_DWORD *)(v5 + 184);
  if (v6 || !v4[32])
  {
    v7 = v4[34];
    v8 = v6 == 1;
    v9 = 180;
    if (v8)
      v9 = 172;
    v10 = *(unsigned int *)(v5 + v9);
    if (a2)
    {
      if (a3)
      {
        if ((int)v10 >= 1)
        {
          v11 = (_BYTE *)(v7 + 185);
          v12 = v10;
          do
          {
            *v11 = 0;
            v11 += 224;
            --v12;
          }
          while (v12);
        }
        if (a2 >= 1)
        {
          v13 = a2;
          do
          {
            v15 = *v3++;
            v14 = v15;
            if ((v15 & 0x80000000) == 0 && v14 < (int)v10)
              *(_BYTE *)(v7 + 224 * v14 + 185) = 1;
            --v13;
          }
          while (v13);
        }
      }
      else if ((int)v10 >= 1)
      {
        v18 = 0;
        v19 = (v10 + 1) & 0x1FFFFFFFELL;
        v20 = (uint64x2_t)vdupq_n_s64(v10 - 1);
        v21 = (int64x2_t)xmmword_18820C490;
        v22 = (BOOL *)(v7 + 409);
        v23 = vdupq_n_s64(2uLL);
        do
        {
          v24 = vmovn_s64((int64x2_t)vcgeq_u64(v20, (uint64x2_t)v21));
          if ((v24.i8[0] & 1) != 0)
            *(v22 - 224) = v18 < a2;
          if ((v24.i8[4] & 1) != 0)
            *v22 = v18 + 1 < a2;
          v18 += 2;
          v21 = vaddq_s64(v21, v23);
          v22 += 448;
        }
        while (v19 != v18);
      }
    }
    else if ((int)v10 >= 1)
    {
      v17 = (_BYTE *)(v7 + 185);
      do
      {
        *v17 = 1;
        v17 += 224;
        --v10;
      }
      while (v10);
    }
  }
  else
  {
    kd_mct_stage::apply_output_restrictions((int *)v4[33], *(_QWORD *)(v5 + 320), a2, a3);
    v4 = *this;
  }
  v25 = *((unsigned int *)v4 + 47);
  if ((int)v25 >= 1)
  {
    v26 = (_DWORD *)(v4[34] + 156);
    do
    {
      *v26 = -1082130432;
      v26 += 56;
      --v25;
    }
    while (v25);
  }
}

uint64_t kdu_tile::get_mct_block_info(uint64_t **this, int a2, int a3, unsigned int *a4, int *a5, int *a6, int *a7, unint64_t a8, int *a9, float *a10, int *a11, int *a12)
{
  int v16;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  _BOOL4 ycc;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  unsigned int v33;
  int *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  unsigned __int8 *v51;
  int v52;
  uint64_t v53;
  int v54;
  unsigned __int8 *v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  unsigned __int8 *v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  uint64_t *v64;
  uint64_t v65;
  int v66;
  char v67;
  int v68;
  int v69;
  uint64_t v70;
  int v71;
  unsigned __int8 *v72;
  uint64_t v73;
  int v74;
  int v75;
  int v76;
  uint64_t v77;
  int v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t result;
  int v86;
  uint64_t v87;
  int v88;
  int v89;
  int v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  int v99;
  _BOOL4 v100;
  _DWORD *exception;
  __int128 v103;
  __int128 v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int v107;
  uint64_t v108;

  v16 = a3;
  v108 = *MEMORY[0x1E0C80C00];
  v18 = **this;
  v19 = *(_DWORD *)(v18 + 184);
  if (v19 == 1 || (v20 = (*this)[32]) == 0)
  {
    if (a3 | a2)
      return 0;
    v26 = 172;
    if (v19 != 1)
      v26 = 180;
    v27 = *(_DWORD *)(v18 + v26);
    *a5 = v27;
    *a7 = v27;
    *a6 = v27;
    *a4 = v27;
    ycc = kdu_tile::get_ycc((kdu_tile *)this);
    if (v19 == 1 || !ycc)
    {
      v106 = -1;
      v107 = -1;
      v41 = (unint64_t)a10;
      if (!ycc)
      {
        v39 = 0;
LABEL_55:
        v48 = *a4;
        v49 = *a5;
        if (*a5 >= 1)
        {
          v50 = 0;
          v51 = (unsigned __int8 *)((*this)[34] + 185);
          do
          {
            v52 = *v51;
            v51 += 224;
            if (!v52)
            {
              --*a4;
              --*a6;
              --*a7;
              v49 = *a5;
            }
            ++v50;
          }
          while (v50 < v49);
        }
        if (a9)
        {
          if (v49 < 1)
          {
            v54 = 0;
          }
          else
          {
            v53 = 0;
            v54 = 0;
            v55 = (unsigned __int8 *)((*this)[34] + 185);
            do
            {
              v56 = *v55;
              v55 += 224;
              if (v56)
              {
                a9[v54++] = v53;
                v49 = *a5;
              }
              ++v53;
            }
            while (v53 < v49);
          }
          if (v54 != *a7)
          {
            v105 = 0;
            v103 = 0u;
            v104 = 0u;
            kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "k == num_block_outputs");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v103);
          }
        }
        if (v41 | (unint64_t)a11)
        {
          v57 = *a5;
          if (*a5 < 1)
          {
            v59 = 0;
          }
          else
          {
            v58 = 0;
            v59 = 0;
            v60 = (unsigned __int8 *)((*this)[34] + 185);
            v61 = 20;
            v62 = 96;
            do
            {
              v63 = *v60;
              v60 += 224;
              if (v63)
              {
                if (v19 == 1)
                  v64 = (uint64_t *)(*(_QWORD *)(v18 + 312) + v62);
                else
                  v64 = (uint64_t *)(*(_QWORD *)(v18 + 320) + 48 * *(int *)(*(_QWORD *)(v18 + 320) + v61) + 8);
                v65 = *v64;
                if (*(_BYTE *)(v65 + 20))
                  v66 = 0;
                else
                  v66 = 1 << (*(_DWORD *)(v65 + 16) - 1);
                if (a11)
                  a11[v59] = v66;
                if (v41)
                  *(float *)(v41 + 4 * v59) = (float)v66;
                ++v59;
                v57 = *a5;
              }
              ++v58;
              v61 += 48;
              v62 += 104;
            }
            while (v58 < v57);
          }
          if (v59 != *a7)
          {
            v105 = 0;
            v103 = 0u;
            v104 = 0u;
            kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "k == num_block_outputs");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v103);
          }
        }
        if (!(a8 | (unint64_t)a12))
          return 1;
        if (v19 != 1)
        {
          v67 = v39 ^ 1;
          if (!a12)
            v67 = 1;
          if ((v67 & 1) == 0)
          {
            *(_QWORD *)a12 = 0x100000000;
            a12[2] = 2;
          }
          if (v39)
            v68 = 3;
          else
            v68 = 0;
          v69 = *a5;
          if (*a5 < 1)
          {
            v71 = 0;
          }
          else
          {
            v70 = 0;
            v71 = 0;
            v72 = (unsigned __int8 *)((*this)[34] + 185);
            v73 = 20;
            do
            {
              v74 = *v72;
              v72 += 224;
              if (v74)
              {
                v75 = *(_DWORD *)(*(_QWORD *)(v18 + 320) + v73);
                if ((v39 & (v75 < 3)) != 0)
                  v76 = *(_DWORD *)(*(_QWORD *)(v18 + 320) + v73);
                else
                  v76 = v68;
                if (a12)
                  a12[v76] = v75;
                if (a8)
                  *(_DWORD *)(a8 + 4 * v71) = v76;
                v68 += !(v39 & (v75 < 3));
                ++v71;
                v69 = *a5;
              }
              ++v70;
              v73 += 48;
            }
            while (v70 < v69);
          }
          if (v68 != *a4)
          {
            v105 = 0;
            v103 = 0u;
            v104 = 0u;
            kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "non_ycc_idx == num_stage_inputs");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v103);
          }
          if (v71 != *a6)
          {
            v105 = 0;
            v103 = 0u;
            v104 = 0u;
            kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "k == num_block_inputs");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v103);
          }
          return 1;
        }
        if ((int)v48 < 1)
        {
          v78 = 0;
LABEL_153:
          if (v78 != *a6)
          {
            v105 = 0;
            v103 = 0u;
            v104 = 0u;
            kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "k == num_block_inputs");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v103);
          }
          return 1;
        }
        v77 = 0;
        v78 = 0;
        if (v39)
          v79 = 3;
        else
          v79 = 0;
        v80 = v106;
        v81 = HIDWORD(v106);
        v82 = v107;
        v83 = 185;
        while (1)
        {
          if (v80 == v77)
          {
            v84 = 0;
            if (a12)
              goto LABEL_125;
            goto LABEL_126;
          }
          if (v81 == v77)
          {
            v84 = 1;
            if (a12)
              goto LABEL_125;
            goto LABEL_126;
          }
          if (v82 == v77)
            break;
          if (*(_BYTE *)((*this)[34] + v83))
          {
            v84 = v79++;
            if (!a12)
              goto LABEL_126;
LABEL_125:
            a12[v84] = v77;
LABEL_126:
            if (a8)
              *(_DWORD *)(a8 + 4 * v78) = v84;
            ++v78;
          }
          ++v77;
          v83 += 224;
          if (v48 == v77)
            goto LABEL_153;
        }
        v84 = 2;
        if (a12)
          goto LABEL_125;
        goto LABEL_126;
      }
    }
    else
    {
      v40 = 16;
      v41 = (unint64_t)a10;
      while (1)
      {
        v42 = *(_DWORD *)(*(_QWORD *)(v18 + 320) + v40);
        if ((v42 & 0x80000000) == 0)
        {
          if (*(_BYTE *)((*this)[34] + 224 * v42 + 185))
            break;
        }
        v40 += 48;
        if (v40 == 160)
        {
          v39 = 0;
          v106 = -1;
          v107 = -1;
          goto LABEL_55;
        }
      }
      v106 = -1;
      v107 = -1;
    }
    v30 = 0;
    v31 = *this;
    v32 = **this;
    v33 = *a4;
    v34 = (int *)(*(_QWORD *)(v32 + 312) + 88);
    v35 = 16;
    do
    {
      v36 = *v34;
      v34 += 26;
      *((_DWORD *)&v106 + v30) = v36;
      if (v36 < 0 || (v37 = *(int *)(v32 + 176), v30 > v37))
      {
LABEL_195:
        exception = __cxa_allocate_exception(4uLL);
        *exception = -50;
        __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
      }
      if (v19 != 1)
      {
        if (v30 >= v37)
          goto LABEL_195;
        v38 = *(_DWORD *)(*(_QWORD *)(v18 + 320) + v35);
        if ((v38 & 0x80000000) != 0)
          goto LABEL_195;
        if (!*(_BYTE *)(v31[34] + 224 * v38 + 185))
          *a4 = ++v33;
      }
      ++v30;
      v35 += 48;
    }
    while (v30 != 3);
    v39 = 1;
    goto LABEL_55;
  }
  if (a2 >= 1)
  {
    do
    {
      v21 = a2;
      v20 = *(_QWORD *)(v20 + 56);
      --a2;
    }
    while (v21 >= 2 && v20);
    if (!v20)
      return 0;
  }
  *a4 = *(_DWORD *)(v20 + 4);
  *a5 = *(_DWORD *)(v20 + 20);
  if (a12)
  {
    if (a2)
    {
      v105 = 0;
      v103 = 0u;
      v104 = 0u;
      kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "stage_idx == 0");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v103);
    }
    v22 = *(_DWORD *)v20;
    if (*(int *)v20 < 1)
    {
      v24 = 0;
    }
    else
    {
      v23 = 0;
      v24 = 0;
      do
      {
        if (v24 >= *(_DWORD *)(v20 + 4))
          break;
        v25 = *(_DWORD *)(*(_QWORD *)(v20 + 8) + 4 * v23);
        if ((v25 & 0x80000000) == 0)
        {
          if (v25 != v24)
          {
            v105 = 0;
            v103 = 0u;
            v104 = 0u;
            kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "stage->input_required_indices[n] == m");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v103);
          }
          a12[v24++] = v23;
          v22 = *(_DWORD *)v20;
        }
        ++v23;
      }
      while (v23 < v22);
    }
    if (v24 != *(_DWORD *)(v20 + 4))
    {
      v105 = 0;
      v103 = 0u;
      v104 = 0u;
      kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "m == stage->num_required_inputs");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v103);
    }
  }
  v43 = *(_DWORD *)(v20 + 32);
  if (v43 <= a3)
    return 0;
  v44 = *(_QWORD *)(v20 + 40);
  if (v43 >= 1)
  {
    v45 = 0;
    v47 = a8;
    v46 = (unint64_t)a10;
    do
    {
      if (*(int *)(v44 + 36) >= 1)
      {
        if (!v16)
          goto LABEL_135;
        --v16;
      }
      ++v45;
      v44 += 152;
    }
    while (v43 != v45);
    return 0;
  }
  v45 = 0;
  v47 = a8;
  v46 = (unint64_t)a10;
LABEL_135:
  if (v45 == v43)
    return 0;
  *a6 = *(_DWORD *)(v44 + 12);
  *a7 = *(_DWORD *)(v44 + 36);
  if (v47)
  {
    v86 = *(_DWORD *)(v44 + 8);
    if (v86 < 1)
    {
      v88 = 0;
    }
    else
    {
      v87 = 0;
      v88 = 0;
      do
      {
        if (v88 >= *(_DWORD *)(v44 + 12))
          break;
        if (*(_BYTE *)(*(_QWORD *)(v44 + 24) + v87))
        {
          v89 = *(_DWORD *)(*(_QWORD *)(v20 + 8) + 4 * *(int *)(*(_QWORD *)(v44 + 16) + 4 * v87));
          if (v89 < 0)
          {
            v105 = 0;
            v103 = 0u;
            v104 = 0u;
            kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "stage->input_required_indices[idx] >= 0");
            (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v103);
          }
          *(_DWORD *)(v47 + 4 * v88++) = v89;
          v86 = *(_DWORD *)(v44 + 8);
        }
        ++v87;
      }
      while (v87 < v86);
    }
    if (v88 != *(_DWORD *)(v44 + 12))
    {
      v105 = 0;
      v103 = 0u;
      v104 = 0u;
      kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "m == block->num_required_inputs");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v103);
    }
  }
  if (a9)
  {
    v90 = *(_DWORD *)(v44 + 32);
    if (v90 < 1)
    {
      v92 = 0;
    }
    else
    {
      v91 = 0;
      v92 = 0;
      do
      {
        if (v92 >= *(_DWORD *)(v44 + 36))
          break;
        v93 = *(_QWORD *)(v20 + 24);
        v94 = *(_DWORD *)(*(_QWORD *)(v44 + 40) + 4 * v91);
        if (*(_BYTE *)(v93 + 48 * v94 + 40))
        {
          a9[v92++] = *(_DWORD *)(v93 + 48 * v94 + 16);
          v90 = *(_DWORD *)(v44 + 32);
        }
        ++v91;
      }
      while (v91 < v90);
    }
    if (v92 != *(_DWORD *)(v44 + 36))
    {
      v105 = 0;
      v103 = 0u;
      v104 = 0u;
      kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "m == block->num_apparent_outputs");
      (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v103);
    }
  }
  if (*(_QWORD *)(v44 + 64) && !*(_QWORD *)(v44 + 80))
  {
    if (v46 | (unint64_t)a11)
    {
      v97 = *(_DWORD *)(v44 + 32);
      if (v97 < 1)
      {
        v99 = 0;
      }
      else
      {
        v98 = 0;
        v99 = 0;
        do
        {
          if (v99 >= *(_DWORD *)(v44 + 36))
            break;
          if (*(_BYTE *)(*(_QWORD *)(v20 + 24) + 48 * *(int *)(*(_QWORD *)(v44 + 40) + 4 * v98) + 40))
          {
            v100 = v46 != 0;
            LODWORD(v103) = 0;
            kdu_params::get(*(kdu_params **)(v44 + 64), "Mvector_coeffs", v98, 0, (float *)&v103, 1, 1, 1);
            v46 = (unint64_t)a10;
            if (v100)
              LODWORD(a10[v99]) = v103;
            if (a11)
              a11[v99] = vcvtmd_s64_f64(*(float *)&v103 + 0.5);
            ++v99;
            v97 = *(_DWORD *)(v44 + 32);
          }
          ++v98;
        }
        while (v98 < v97);
      }
      if (v99 != *(_DWORD *)(v44 + 36))
      {
        v105 = 0;
        v103 = 0u;
        v104 = 0u;
        kdu_error::kdu_error((kdu_error *)&v103, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "Assert ");
        (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, "m == block->num_apparent_outputs");
        (*(void (**)(__int128 *, const char *))(v103 + 16))(&v103, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v103);
      }
    }
    return 1;
  }
  if (v46)
  {
    v95 = *(unsigned int *)(v44 + 36);
    if ((int)v95 >= 1)
      bzero((void *)v46, 4 * v95);
  }
  if (!a11 || *(int *)(v44 + 36) < 1)
    return 1;
  v96 = 0;
  result = 1;
  do
    a11[v96++] = 0;
  while (v96 < *(int *)(v44 + 36));
  return result;
}

void sub_187EF1684(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EF1690(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Exception *v13;

  _Unwind_Resume(v13);
}

uint64_t kdu_tile::get_mct_matrix_info(kdu_tile *this, int a2, int a3, float *a4)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  int i;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t j;
  _OWORD v16[2];
  uint64_t v17;

  if (*(_DWORD *)(**(_QWORD **)this + 184))
    return 0;
  v6 = *(_QWORD *)(*(_QWORD *)this + 256);
  if (a2 >= 1 && v6)
  {
    do
    {
      v6 = *(_QWORD *)(v6 + 56);
      if (a2 < 2)
        break;
      --a2;
    }
    while (v6);
  }
  if (!v6)
    return 0;
  v7 = *(_DWORD *)(v6 + 32);
  if (v7 <= a3)
    return 0;
  v8 = *(_QWORD *)(v6 + 40);
  if (v7 >= 1)
  {
    for (i = 0; i != v7; ++i)
    {
      if (*(int *)(v8 + 36) >= 1)
      {
        if (!a3)
          goto LABEL_18;
        --a3;
      }
      v8 += 152;
    }
    return 0;
  }
  i = 0;
LABEL_18:
  if (i == v7 || !*(_QWORD *)(v8 + 72) || *(_BYTE *)(v8 + 57) || *(_BYTE *)(v8 + 56))
    return 0;
  if (a4)
  {
    v10 = *(_DWORD *)(v8 + 32);
    if (v10 < 1)
    {
      v12 = 0;
    }
    else
    {
      v11 = 0;
      v12 = 0;
      v13 = 0;
      do
      {
        v14 = *(_DWORD *)(v8 + 8);
        if (*(_BYTE *)(*(_QWORD *)(v6 + 24) + 48 * *(int *)(*(_QWORD *)(v8 + 40) + 4 * v11) + 40))
        {
          if (v14 >= 1)
          {
            for (j = 0; j < v14; ++j)
            {
              if (*(_BYTE *)(*(_QWORD *)(v8 + 24) + j))
              {
                LODWORD(v16[0]) = 0;
                kdu_params::get(*(kdu_params **)(v8 + 72), "Mmatrix_coeffs", v13 + j, 0, (float *)v16, 1, 1, 1);
                a4[v12++] = *(float *)v16;
                v14 = *(_DWORD *)(v8 + 8);
              }
            }
            v10 = *(_DWORD *)(v8 + 32);
            v13 += j;
          }
        }
        else
        {
          v13 += v14;
        }
        ++v11;
      }
      while (v11 < v10);
    }
    if (v12 != *(_DWORD *)(v8 + 12) * *(_DWORD *)(v8 + 36))
    {
      v17 = 0;
      memset(v16, 0, sizeof(v16));
      kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, "Assert ");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, "c_out==(block->num_apparent_outputs*block->num_required_inputs)");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v16[0] + 16))(v16, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v16);
    }
  }
  return 1;
}

void sub_187EF1998(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF19A4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_tile::get_mct_rxform_info(kdu_tile *this, int a2, int a3, int *a4, int *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int i;
  uint64_t v12;
  uint64_t j;
  int v14;
  uint64_t v15;
  int v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  if (*(_DWORD *)(**(_QWORD **)this + 184))
    return 0;
  v8 = *(_QWORD *)(*(_QWORD *)this + 256);
  if (a2 >= 1 && v8)
  {
    do
    {
      v8 = *(_QWORD *)(v8 + 56);
      if (a2 < 2)
        break;
      --a2;
    }
    while (v8);
  }
  if (!v8)
    return 0;
  v9 = *(_DWORD *)(v8 + 32);
  if (v9 <= a3)
    return 0;
  v10 = *(_QWORD *)(v8 + 40);
  if (v9 >= 1)
  {
    for (i = 0; i != v9; ++i)
    {
      if (*(int *)(v10 + 36) >= 1)
      {
        if (!a3)
          goto LABEL_17;
        --a3;
      }
      v10 += 152;
    }
    return 0;
  }
  i = 0;
LABEL_17:
  if (i == v9 || !*(_QWORD *)(v10 + 72) || *(_BYTE *)(v10 + 57) || !*(_BYTE *)(v10 + 56))
    return 0;
  if (*(_DWORD *)(v10 + 12) != *(_DWORD *)(v10 + 8))
  {
    v19 = 0;
    v17 = 0u;
    v18 = 0u;
    kdu_error::kdu_error((kdu_error *)&v17, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v17 + 16))(&v17, "Assert ");
    (*(void (**)(__int128 *, const char *))(v17 + 16))(&v17, "block->num_required_inputs == block->num_inputs");
    (*(void (**)(__int128 *, const char *))(v17 + 16))(&v17, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v17);
  }
  if (a4)
  {
    v12 = (*(_DWORD *)(v10 + 12) + *(_DWORD *)(v10 + 12) * *(_DWORD *)(v10 + 12));
    if ((int)v12 >= 1)
    {
      for (j = 0; j != v12; ++j)
      {
        LODWORD(v17) = 0;
        kdu_params::get(*(kdu_params **)(v10 + 72), "Mmatrix_coeffs", j, 0, (float *)&v17, 1, 1, 1);
        a4[j] = vcvtmd_s64_f64(*(float *)&v17 + 0.5);
      }
    }
  }
  if (a5)
  {
    v14 = *(_DWORD *)(v10 + 32);
    if (v14 < 1)
    {
      v16 = 0;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      do
      {
        if (v16 >= *(_DWORD *)(v10 + 36))
          break;
        if (*(_BYTE *)(*(_QWORD *)(v8 + 24) + 48 * *(int *)(*(_QWORD *)(v10 + 40) + 4 * v15) + 40))
        {
          a5[v16++] = v15;
          v14 = *(_DWORD *)(v10 + 32);
        }
        ++v15;
      }
      while (v15 < v14);
    }
    if (v16 != *(_DWORD *)(v10 + 36))
    {
      v19 = 0;
      v17 = 0u;
      v18 = 0u;
      kdu_error::kdu_error((kdu_error *)&v17, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v17 + 16))(&v17, "Assert ");
      (*(void (**)(__int128 *, const char *))(v17 + 16))(&v17, "m == block->num_apparent_outputs");
      (*(void (**)(__int128 *, const char *))(v17 + 16))(&v17, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v17);
    }
  }
  return 1;
}

void sub_187EF1C60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF1C6C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_tile::get_mct_dependency_info(kdu_tile *this, int a2, int a3, BOOL *a4, unint64_t a5, unint64_t a6, unint64_t a7, unint64_t a8, int *a9)
{
  uint64_t v14;
  int v15;
  uint64_t v16;
  int i;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  if (*(_DWORD *)(**(_QWORD **)this + 184))
    return 0;
  v14 = *(_QWORD *)(*(_QWORD *)this + 256);
  if (a2 >= 1 && v14)
  {
    do
    {
      v14 = *(_QWORD *)(v14 + 56);
      if (a2 < 2)
        break;
      --a2;
    }
    while (v14);
  }
  if (!v14)
    return 0;
  v15 = *(_DWORD *)(v14 + 32);
  if (v15 <= a3)
    return 0;
  v16 = *(_QWORD *)(v14 + 40);
  if (v15 >= 1)
  {
    for (i = 0; i != v15; ++i)
    {
      if (*(int *)(v16 + 36) >= 1)
      {
        if (!a3)
          goto LABEL_17;
        --a3;
      }
      v16 += 152;
    }
    return 0;
  }
  i = 0;
LABEL_17:
  if (i == v15 || !*(_QWORD *)(v16 + 80) || *(_BYTE *)(v16 + 57))
    return 0;
  *a4 = *(_BYTE *)(v16 + 56);
  if (*(_BYTE *)(v16 + 56))
  {
    if (a5 | a6)
    {
      v31 = 0;
      v29 = 0u;
      v30 = 0u;
      kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "Assert ");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "(irrev_coefficients == NULL) && (irrev_offsets == NULL)");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v29);
    }
    if (a7)
    {
      v18 = *(_DWORD *)(v16 + 12) + *(_DWORD *)(v16 + 12) * *(_DWORD *)(v16 + 12);
      if (v18 >= 4)
      {
        v19 = 0;
        v20 = (v18 >> 1) - 1;
        do
        {
          LODWORD(v29) = 0;
          kdu_params::get(*(kdu_params **)(v16 + 80), "Mtriang_coeffs", v19, 0, (float *)&v29, 1, 1, 1);
          *(_DWORD *)(a7 + 4 * v19++) = vcvtmd_s64_f64(*(float *)&v29 + 0.5);
        }
        while (v20 != v19);
      }
    }
    if (a8 && *(int *)(v16 + 12) >= 1)
    {
      v21 = 0;
      do
      {
        LODWORD(v29) = 0;
        kdu_params::get(*(kdu_params **)(v16 + 64), "Mvector_coeffs", v21, 0, (float *)&v29, 1, 1, 1);
        *(_DWORD *)(a8 + 4 * v21++) = vcvtmd_s64_f64(*(float *)&v29 + 0.5);
      }
      while (v21 < *(int *)(v16 + 12));
    }
  }
  else
  {
    if (a7 | a8)
    {
      v31 = 0;
      v29 = 0u;
      v30 = 0u;
      kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "Assert ");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "(rev_coefficients == NULL) && (rev_offsets == NULL)");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v29);
    }
    if (a5)
    {
      v22 = (*(_DWORD *)(v16 + 12) - 1) * *(_DWORD *)(v16 + 12);
      if (v22 >= 2)
      {
        v23 = 0;
        v24 = v22 >> 1;
        do
        {
          LODWORD(v29) = 0;
          kdu_params::get(*(kdu_params **)(v16 + 80), "Mtriang_coeffs", v23, 0, (float *)&v29, 1, 1, 1);
          *(_DWORD *)(a5 + 4 * v23++) = v29;
        }
        while (v24 != v23);
      }
    }
    if (a6 && *(int *)(v16 + 12) >= 1)
    {
      v25 = 0;
      do
      {
        LODWORD(v29) = 0;
        kdu_params::get(*(kdu_params **)(v16 + 64), "Mvector_coeffs", v25, 0, (float *)&v29, 1, 1, 1);
        *(_DWORD *)(a6 + 4 * v25++) = v29;
      }
      while (v25 < *(int *)(v16 + 12));
    }
  }
  if (a9)
  {
    v26 = *(_DWORD *)(v16 + 32);
    if (v26 < 1)
    {
      v28 = 0;
    }
    else
    {
      v27 = 0;
      v28 = 0;
      do
      {
        if (v28 >= *(_DWORD *)(v16 + 36))
          break;
        if (*(_BYTE *)(*(_QWORD *)(v14 + 24) + 48 * *(int *)(*(_QWORD *)(v16 + 40) + 4 * v27) + 40))
        {
          a9[v28++] = v27;
          v26 = *(_DWORD *)(v16 + 32);
        }
        ++v27;
      }
      while (v27 < v26);
    }
    if (v28 != *(_DWORD *)(v16 + 36))
    {
      v31 = 0;
      v29 = 0u;
      v30 = 0u;
      kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "Assert ");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, "m == block->num_apparent_outputs");
      (*(void (**)(__int128 *, const char *))(v29 + 16))(&v29, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v29);
    }
  }
  return 1;
}

void sub_187EF20F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF2100()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_tile::get_mct_dwt_info(kdu_tile *this, int a2, int a3, BOOL *a4, int *a5, int *a6, int *a7, int *a8, BOOL *a9, BOOL *a10, const float **a11, int *a12, int *a13)
{
  uint64_t v14;
  int v15;
  uint64_t v16;
  int i;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  if (*(_DWORD *)(**(_QWORD **)this + 184))
    return 0;
  v14 = *(_QWORD *)(*(_QWORD *)this + 256);
  if (a2 >= 1 && v14)
  {
    do
    {
      v14 = *(_QWORD *)(v14 + 56);
      if (a2 < 2)
        break;
      --a2;
    }
    while (v14);
  }
  if (!v14)
    return 0;
  v15 = *(_DWORD *)(v14 + 32);
  if (v15 <= a3)
    return 0;
  v16 = *(_QWORD *)(v14 + 40);
  if (v15 >= 1)
  {
    for (i = 0; i != v15; ++i)
    {
      if (*(int *)(v16 + 36) >= 1)
      {
        if (!a3)
          goto LABEL_18;
        --a3;
      }
      v16 += 152;
    }
    return 0;
  }
  i = 0;
LABEL_18:
  if (i == v15)
    return 0;
  if (!*(_QWORD *)(v16 + 104))
    return 0;
  v18 = *(_DWORD *)(v16 + 92);
  if (v18 < 1 || *(_BYTE *)(v16 + 57))
    return 0;
  *a4 = *(_BYTE *)(v16 + 56);
  *a5 = v18;
  v19 = *(_DWORD *)(v16 + 96);
  *a6 = v19;
  *a7 = *(_DWORD *)(v16 + 8) + v19;
  *a8 = *(_DWORD *)(v16 + 88);
  *a9 = *(_BYTE *)(v16 + 100);
  *a10 = *(_BYTE *)(v16 + 101);
  *a11 = *(const float **)(v16 + 112);
  if (a12)
  {
    v20 = *(_DWORD *)(v16 + 8);
    if (v20 < 1)
    {
      v22 = 0;
    }
    else
    {
      v21 = 0;
      v22 = 0;
      do
      {
        if (v22 >= *(_DWORD *)(v16 + 12))
          break;
        if (*(_BYTE *)(*(_QWORD *)(v16 + 24) + v21))
        {
          a12[v22++] = v21;
          v20 = *(_DWORD *)(v16 + 8);
        }
        ++v21;
      }
      while (v21 < v20);
    }
    if (v22 != *(_DWORD *)(v16 + 12))
    {
      v28 = 0;
      v26 = 0u;
      v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, "Assert ");
      (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, "m == block->num_required_inputs");
      (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
  }
  if (a13)
  {
    v23 = *(_DWORD *)(v16 + 32);
    if (v23 < 1)
    {
      v25 = 0;
    }
    else
    {
      v24 = 0;
      v25 = 0;
      do
      {
        if (v25 >= *(_DWORD *)(v16 + 36))
          break;
        if (*(_BYTE *)(*(_QWORD *)(v14 + 24) + 48 * *(int *)(*(_QWORD *)(v16 + 40) + 4 * v24) + 40))
        {
          a13[v25++] = v24;
          v23 = *(_DWORD *)(v16 + 32);
        }
        ++v24;
      }
      while (v24 < v23);
    }
    if (v25 != *(_DWORD *)(v16 + 36))
    {
      v28 = 0;
      v26 = 0u;
      v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, "Assert ");
      (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, "m == block->num_apparent_outputs");
      (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
  }
  return *(_QWORD *)(v16 + 104);
}

void sub_187EF23E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF23F4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_tile::access_component(uint64_t **this, unsigned int a2)
{
  uint64_t *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  _OWORD v7[2];
  uint64_t v8;

  if ((a2 & 0x80000000) != 0)
    return 0;
  v2 = *this;
  v3 = **this;
  if (*(_DWORD *)(v3 + 172) <= (signed int)a2)
    return 0;
  v4 = -991146299 * ((uint64_t)(*(_QWORD *)(*(_QWORD *)(v3 + 312) + 104 * a2 + 96) - *(_QWORD *)(v3 + 312)) >> 3);
  if (v4 < 0 || *((_DWORD *)v2 + 47) <= v4)
  {
    v8 = 0;
    memset(v7, 0, sizeof(v7));
    kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, "(true_idx >= 0) && (true_idx < state->num_components)");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v7);
  }
  v5 = v2[34] + 224 * v4;
  if (*(_BYTE *)(v5 + 184))
    return v5;
  else
    return 0;
}

void sub_187EF2518(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF2524()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kd_tile_comp::~kd_tile_comp(kd_tile_comp *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *((_QWORD *)this + 12);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C80451B5BE8);
  v3 = *((_QWORD *)this + 13);
  if (v3 && v3 != *((_QWORD *)this + 12))
    MEMORY[0x18D761C18](v3, 0x1000C80451B5BE8);
  v4 = *((_QWORD *)this + 14);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1000C8052888210);
  v5 = *((_QWORD *)this + 15);
  if (v5 && v5 != *((_QWORD *)this + 14))
    MEMORY[0x18D761C18](v5, 0x1000C8052888210);
  v6 = *((_QWORD *)this + 22);
  if (v6)
  {
    v7 = v6 - 16;
    v8 = *(_QWORD *)(v6 - 8);
    if (v8)
    {
      v9 = v6 - 704;
      v10 = 704 * v8;
      do
      {
        kd_resolution::~kd_resolution((kd_resolution *)(v9 + v10));
        v10 -= 704;
      }
      while (v10);
    }
    MEMORY[0x18D761C18](v7, 0x10A0C80EE9AF17DLL);
  }
}

uint64_t kdu_tile_comp::get_reversible(kdu_tile_comp *this)
{
  return *(unsigned __int8 *)(*(_QWORD *)this + 76);
}

uint64_t kdu_tile_comp::get_bit_depth(kdu_tile_comp *this, int a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)this;
  result = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)this + 16) + 16);
  if (a2)
    return (*(_DWORD *)(v2 + 160) + result);
  return result;
}

uint64_t kdu_tile_comp::access_resolution(uint64_t **this, int a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  if (a2 < 0 || (v2 = *this, *((_DWORD *)*this + 18) < a2))
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "Attempting to access a non-existent resolution level within some tile-component.  Problem almost certainly caused by trying to discard more resolution levels than the number of DWT levels used to compress a tile-component.");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  v3 = v2[22];
  if (!*(_BYTE *)(v3 + 704 * a2 + 221))
  {
    v4 = *v2;
    if (*(_BYTE *)(v4 + 410) || *(_BYTE *)(v4 + 411))
    {
      v8 = 0;
      v6 = 0u;
      v7 = 0u;
      kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v6);
    }
  }
  return v3 + 704 * a2;
}

void sub_187EF273C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF2748()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_tile_comp::access_resolution(uint64_t **this)
{
  return kdu_tile_comp::access_resolution(this, *((_DWORD *)*this + 18));
}

uint64_t create_child_node(uint64_t a1, unsigned int a2, char a3, uint64_t a4, _DWORD *a5, uint64_t a6, _DWORD *a7, unsigned int a8, int a9, unsigned int a10, char a11, char a12, int a13, BOOL *a14, int a15, BOOL *a16, kdu_kernels *a17)
{
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v23;
  char v24;
  int v25;
  int v26;
  char v27;
  int v28;
  int v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  double *bibo_gains;
  uint64_t v37;
  float *v38;
  double v39;
  float v40;
  double *v41;
  uint64_t v42;
  float *v43;
  double v44;
  float v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  unsigned int v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t i;
  uint64_t v55;
  char v57;
  int v60;
  double v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;

  if ((a9 - 1) >= 3)
  {
    v66 = 0;
    v64 = 0u;
    v65 = 0u;
    kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
    (*(void (**)(void))(v64 + 16))();
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "(sub_level >= 1) && (sub_level <= 3)");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v64);
  }
  if (a9 == 2)
    v17 = 0;
  else
    v17 = a8 >> 2;
  v18 = a8 & 3;
  if ((a8 & 3) != 0)
  {
    v19 = (*a5)++;
    v20 = a4 + 136 * v19;
    v21 = v20;
  }
  else
  {
    v21 = 0;
    v22 = (*a7)++;
    v20 = a6 + 144 * v22;
  }
  *(_QWORD *)v20 = a1;
  if ((a3 & 1) != 0)
  {
    *(_BYTE *)(v20 + 48) = a2 & 1;
    if (a13 >= 3)
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
      (*(void (**)(void))(v64 + 16))();
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "num_hor_extra_stages < 3");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v64);
    }
    v60 = a13 + 1;
    a14[a13] = (a2 & 1) != 0;
    if ((a2 & 1) != 0)
      v23 = 1;
    else
      v23 = a11;
    if ((a2 & 1) != 0 && a11)
    {
      *(_BYTE *)(*(_QWORD *)(v20 + 8) + 221) = 0;
      v57 = 1;
    }
    else
    {
      v57 = v23;
    }
  }
  else
  {
    *(_BYTE *)(v20 + 48) = 2;
    v57 = a11;
    if ((a2 & 1) != 0)
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
      (*(void (**)(void))(v64 + 16))();
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "!(child_idx & 1)");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v64);
    }
    v60 = a13;
  }
  v24 = a12;
  if ((a3 & 2) != 0)
  {
    v26 = (a2 >> 1) & 1;
    *(_BYTE *)(v20 + 49) = (a2 & 2) != 0;
    if (a15 >= 3)
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
      (*(void (**)(void))(v64 + 16))();
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "num_vert_extra_stages < 3");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v64);
    }
    v25 = a15 + 1;
    a16[a15] = v26 != 0;
    if (v26)
      v27 = 1;
    else
      v27 = a12;
    if (v26 && a12)
    {
      *(_BYTE *)(*(_QWORD *)(v20 + 8) + 221) = 0;
      v24 = 1;
    }
    else
    {
      v24 = v27;
    }
  }
  else
  {
    *(_BYTE *)(v20 + 49) = 2;
    if ((a2 & 2) != 0)
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
      (*(void (**)(void))(v64 + 16))();
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "!(child_idx & 2)");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v64);
    }
    v25 = a15;
  }
  if (v21)
  {
    if ((a8 & 3) == 0)
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
      (*(void (**)(void))(v64 + 16))();
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "next_branch_mask != 0");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v64);
    }
    if ((a8 & 1) != 0)
      v28 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v20 + 8) + 8) + 88);
    else
      LOBYTE(v28) = 0;
    *(_BYTE *)(v21 + 120) = v28;
    if ((a8 & 2) != 0)
      v29 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v20 + 8) + 8) + 88);
    else
      LOBYTE(v29) = 0;
    *(_BYTE *)(v21 + 121) = v29;
    v30 = (_DWORD *)operator new[]();
    *(_QWORD *)(v21 + 128) = v30;
    v31 = *(unsigned __int8 *)(v21 + 120);
    v32 = *(_QWORD *)(a1 + 128);
    v33 = *(unsigned __int8 *)(a1 + 120);
    *v30 = *(_DWORD *)(v32 + 4 * (v33 & 0xFE));
    v30[v31 + 1] = *(_DWORD *)(v32 + 4 * (v33 + (*(_BYTE *)(a1 + 121) & 0xFE)) + 4);
    *(_QWORD *)&v64 = 0;
    v63 = 0.0;
    v34 = *(_QWORD *)(a1 + 8);
    v35 = *(unsigned __int8 *)(v34 + 27);
    if (v31)
    {
      bibo_gains = (double *)kdu_kernels::get_bibo_gains(a17, *(unsigned __int8 *)(v34 + 26), v60, a14, (double *)&v64, &v63);
      v37 = *(unsigned __int8 *)(v21 + 120);
      if (*(_BYTE *)(v21 + 120))
      {
        v38 = (float *)(v30 + 1);
        do
        {
          v39 = *bibo_gains++;
          v40 = v39;
          *v38++ = v40;
          --v37;
        }
        while (v37);
      }
    }
    if (*(_BYTE *)(v21 + 121))
    {
      v41 = (double *)kdu_kernels::get_bibo_gains(a17, v35, v25, a16, (double *)&v64, &v63);
      v42 = *(unsigned __int8 *)(v21 + 121);
      if (*(_BYTE *)(v21 + 121))
      {
        v43 = (float *)&v30[v31 + 2];
        do
        {
          v44 = *v41++;
          v45 = v44;
          *v43++ = v45;
          --v42;
        }
        while (v42);
      }
    }
  }
  LODWORD(v46) = *(_DWORD *)(a1 + 16);
  LODWORD(v47) = *(_DWORD *)(a1 + 20);
  v48 = *(unsigned __int8 *)(v20 + 48);
  v49 = *(unsigned __int8 *)(v20 + 49);
  v50 = *(_DWORD *)(a1 + 28) + v47;
  v51 = *(_DWORD *)(a1 + 24) + v46;
  if (v48 <= 1)
    v47 = ((int)(v47 - v48 + 1) >> 1);
  else
    v47 = v47;
  if (v48 <= 1)
    v50 = (int)(v50 - v48 + 1) >> 1;
  if (v49 <= 1)
    v46 = ((int)(v46 - v49 + 1) >> 1);
  else
    v46 = v46;
  if (v49 <= 1)
    v51 = (int)(v51 - v49 + 1) >> 1;
  *(_QWORD *)(v20 + 16) = v46 | (v47 << 32);
  *(_QWORD *)(v20 + 24) = (v51 - v46) | ((unint64_t)(v50 - v47) << 32);
  if ((_DWORD)v18)
  {
    v52 = v20;
    for (i = 0; i != 4; ++i)
    {
      if (i == (v18 & i))
      {
        HIDWORD(v55) = v60;
        BYTE1(v55) = v24;
        LOBYTE(v55) = v57;
        *(_QWORD *)(v21 + 8 * i + 88) = create_child_node(v21, i, v18, a4, a5, a6, a7, v17 & 3, __PAIR64__(a10, a9 + 1), v55, a14, v25, a16, a17);
        v17 >>= 2;
      }
    }
  }
  else
  {
    if (!*(_BYTE *)(v20 + 50))
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
      (*(void (**)(void))(v64 + 16))();
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "result->is_leaf");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v64);
    }
    v52 = v20;
    *(_BYTE *)(v20 + 54) = a10;
  }
  return v52;
}

void sub_187EF2E64()
{
  uint64_t v0;

  kdu_error::~kdu_error((kdu_error *)(v0 - 128));
}

void sub_187EF2E70()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_resolution::which(kdu_resolution *this)
{
  _OWORD v2[2];
  uint64_t v3;

  if (!*(_QWORD *)this)
  {
    v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v2[0] + 16))(v2, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v2[0] + 16))(v2, "state != NULL");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v2[0] + 16))(v2, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  return *(unsigned __int8 *)(*(_QWORD *)this + 24);
}

void sub_187EF2F7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF2F88()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_resolution::get_dwt_level(kdu_resolution *this)
{
  return *(unsigned __int8 *)(*(_QWORD *)this + 25);
}

int32x4_t *kdu_resolution::get_dims(int32x4_t **this, int32x4_t *a2)
{
  _OWORD v3[2];
  uint64_t v4;

  if (!*this)
  {
    v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v3[0] + 16))(v3, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v3[0] + 16))(v3, "state != NULL");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v3[0] + 16))(v3, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  *a2 = (*this)[4];
  return kdu_dims::to_apparent(a2, *(unsigned __int8 *)((*this)->i64[0] + 409), *(unsigned __int8 *)((*this)->i64[0] + 410), *(unsigned __int8 *)((*this)->i64[0] + 411));
}

void sub_187EF3064(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF3070()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

int32x4_t *kdu_dims::to_apparent(int32x4_t *this, int a2, int a3, int a4)
{
  if (a2)
  {
    *this = vrev64q_s32(*this);
    if (!a4)
    {
LABEL_3:
      if (!a3)
        return this;
LABEL_7:
      this->i32[0] = 1 - (this->i32[0] + this->i32[2]);
      return this;
    }
  }
  else if (!a4)
  {
    goto LABEL_3;
  }
  this->i32[1] = 1 - (this->i32[1] + this->i32[3]);
  if (a3)
    goto LABEL_7;
  return this;
}

uint64_t kd_precinct::load_required_packets(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;

  if (*(_BYTE *)(this + 18))
  {
    v1 = this;
    v2 = *(_QWORD *)(this + 40);
    if (v2)
    {
      if (!*(_DWORD *)(this + 32))
      {
        if (!*(_BYTE *)(this + 17) || *(_DWORD *)(this + 28) < *(_DWORD *)(this + 24))
          kd_precinct::load_required_packets();
        this = kd_compressed_input::seek(*(_QWORD *)(**(_QWORD **)this + 8), v2);
        do
        {
          if (*(_DWORD *)(v1 + 32) >= *(_DWORD *)(v1 + 24))
            break;
          this = kd_precinct::read_packet((uint64_t **)v1);
        }
        while ((this & 1) != 0);
      }
    }
  }
  return this;
}

uint64_t kdu_resolution::get_reversible(kdu_resolution *this)
{
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)this + 8) + 76);
}

uint64_t kdu_resolution::propagate_roi(kdu_resolution *this)
{
  return *(unsigned __int8 *)(*(_QWORD *)this + 220);
}

uint64_t kdu_resolution::access_node(kdu_resolution *this)
{
  _OWORD v2[2];
  uint64_t v3;

  if (!*(_QWORD *)this)
  {
    v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v2[0] + 16))(v2, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v2[0] + 16))(v2, "state != NULL");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v2[0] + 16))(v2, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  return *(_QWORD *)this + 32;
}

void sub_187EF3208(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF3214()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_resolution::access_subband(kdu_resolution *this, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  _OWORD v7[2];
  uint64_t v8;

  v2 = *(_QWORD *)this;
  v3 = a2 - (*(_BYTE *)(*(_QWORD *)this + 24) != 0);
  if (v3 < 0 || v3 >= *(unsigned __int8 *)(v2 + 222))
  {
    v8 = 0;
    memset(v7, 0, sizeof(v7));
    kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, "(band_idx >= 0) && (band_idx < state->num_subbands)");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v7);
  }
  v4 = *(_QWORD *)(v2 + 240);
  v5 = a2 - (*(_BYTE *)(*(_QWORD *)this + 24) != 0);
  if (*(_BYTE *)(*(_QWORD *)v2 + 409))
    v5 = *(unsigned __int8 *)(v4 + 144 * v3 + 56);
  return v4 + 144 * v5;
}

void sub_187EF3300(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF330C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_node::access_child(kdu_node *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v5;
  signed int v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  if (a2 >= 4)
  {
    v12 = 0;
    v10 = 0u;
    v11 = 0u;
    kdu_error::kdu_error((kdu_error *)&v10, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v10 + 16))(&v10, "Assert ");
    (*(void (**)(__int128 *, const char *))(v10 + 16))(&v10, "(child_idx >= 0) && (child_idx <= 3)");
    (*(void (**)(__int128 *, const char *))(v10 + 16))(&v10, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v10);
  }
  v2 = *(_QWORD *)this;
  if (*(_BYTE *)(*(_QWORD *)this + 50))
    return 0;
  v5 = __rbit32(a2) >> 30;
  if (*(_BYTE *)(**(_QWORD **)(v2 + 8) + 409))
    v6 = v5;
  else
    v6 = a2;
  v3 = *(_QWORD *)(v2 + 8 * v6 + 88);
  if (v3)
  {
    v7 = *(_QWORD *)(v3 + 8);
    if (!*(_BYTE *)(v7 + 24))
    {
      v8 = v7 + 32;
      if (v6)
        v9 = 0;
      else
        v9 = v3 == v8;
      if (!v9)
      {
        v12 = 0;
        v10 = 0u;
        v11 = 0u;
        kdu_error::kdu_error((kdu_error *)&v10, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v10 + 16))(&v10, "Assert ");
        (*(void (**)(__int128 *, const char *))(v10 + 16))(&v10, "(child_idx==LL_BAND) && (result==&(result->resolution->node))");
        (*(void (**)(__int128 *, const char *))(v10 + 16))(&v10, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v10);
      }
      v3 = *(_QWORD *)(v3 + 88);
      if (!*(_BYTE *)(v3 + 50))
      {
        v12 = 0;
        v10 = 0u;
        v11 = 0u;
        kdu_error::kdu_error((kdu_error *)&v10, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v10 + 16))(&v10, "Assert ");
        (*(void (**)(__int128 *, const char *))(v10 + 16))(&v10, "result->is_leaf");
        (*(void (**)(__int128 *, const char *))(v10 + 16))(&v10, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v10);
      }
    }
  }
  return v3;
}

void sub_187EF34F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF3500()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_node::access_subband(kdu_node *this)
{
  if (*(_BYTE *)(*(_QWORD *)this + 50))
    return *(_QWORD *)this;
  else
    return 0;
}

uint64_t kdu_node::access_resolution(kdu_node *this)
{
  return *(_QWORD *)(*(_QWORD *)this + 8);
}

int32x4_t *kdu_node::get_dims(int32x4_t **this, int32x4_t *a2)
{
  unsigned __int8 *v4;
  int32x4_t *result;
  int32x4_t *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  __int32 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v4 = *(unsigned __int8 **)(*this)->i64[1];
  *a2 = (*this)[2];
  result = kdu_dims::to_apparent(a2, v4[409], v4[410], v4[411]);
  if (*((_WORD *)v4 + 205))
  {
    v6 = *this;
    if (*this == (int32x4_t *)((*this)->i64[1] + 32))
    {
      v8 = 0;
      v7 = 0;
    }
    else
    {
      v7 = 0;
      v8 = 0;
      do
      {
        if (v4[409])
          v9 = v6[3].u8[1];
        else
          v9 = v6[3].u8[0];
        if (v4[409])
          v10 = v6[3].u8[0];
        else
          v10 = v6[3].u8[1];
        if (v9 == 1 && v4[411])
        {
          if (v8)
          {
            v14 = 0;
            v12 = 0u;
            v13 = 0u;
            kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "Assert ");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "!offset.x");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v12);
          }
          v8 = 1;
        }
        if (v10 == 1 && v4[410])
        {
          if (v7)
          {
            v14 = 0;
            v12 = 0u;
            v13 = 0u;
            kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "Assert ");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "!offset.y");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v12);
          }
          v7 = 1;
        }
        v6 = (int32x4_t *)v6->i64[0];
      }
      while (v6 != (int32x4_t *)(v6->i64[1] + 32));
    }
    v11 = a2->i32[1] - v8;
    a2->i32[0] -= v7;
    a2->i32[1] = v11;
  }
  return result;
}

void sub_187EF373C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF3748()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_node::get_kernel_id(kdu_node *this)
{
  return *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8) + 8) + 80);
}

uint64_t kdu_node::get_kernel_info(kdu_node *this, int *a2, float *a3, float *a4, BOOL *a5, BOOL *a6, int *a7, int *a8, int *a9, int *a10, BOOL a11)
{
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;

  v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8) + 8);
  v12 = 410;
  if (!a11)
    v12 = 411;
  v13 = *(unsigned __int8 *)(*(_QWORD *)v11 + v12);
  *a2 = *(_DWORD *)(v11 + 88);
  *a3 = *(float *)(v11 + 128);
  *a4 = *(float *)(v11 + 132);
  *a5 = *(_BYTE *)(v11 + 84);
  *a6 = *(_BYTE *)(v11 + 85);
  if (v13)
  {
    *a7 = -*(_DWORD *)(v11 + 140);
    *a8 = -*(_DWORD *)(v11 + 136);
    *a9 = -*(_DWORD *)(v11 + 148);
    v14 = -*(_DWORD *)(v11 + 144);
    v15 = v11 + 104;
  }
  else
  {
    *a7 = *(_DWORD *)(v11 + 136);
    *a8 = *(_DWORD *)(v11 + 140);
    *a9 = *(_DWORD *)(v11 + 144);
    v14 = *(_DWORD *)(v11 + 148);
    v15 = v11 + 96;
  }
  *a10 = v14;
  return *(_QWORD *)v15;
}

uint64_t kdu_node::get_kernel_coefficients(kdu_node *this, int a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)this + 8) + 8);
  v3 = 410;
  if (!a2)
    v3 = 411;
  v4 = 15;
  if (!*(_BYTE *)(*v2 + v3))
    v4 = 14;
  return v2[v4];
}

uint64_t kdu_node::get_bibo_gains(kdu_node *this, int *a2, int a3)
{
  uint64_t *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 v7;

  v3 = *(uint64_t **)this;
  v4 = (*(_BYTE *)(**(_QWORD **)(*(_QWORD *)this + 8) + 409) != 0) ^ a3;
  if (*(_BYTE *)(*(_QWORD *)this + 50))
  {
    *a2 = 0;
    v5 = *v3;
    v6 = *(_QWORD *)(*v3 + 128);
    if (v4)
      v7 = *(_BYTE *)(v5 + 121);
    else
      v7 = *(_BYTE *)(v5 + 120);
    return v6 + 4 * (v7 & 0xFE);
  }
  else if (v4)
  {
    *a2 = *((unsigned __int8 *)v3 + 121);
    return v3[16] + 4 * *((unsigned __int8 *)v3 + 120) + 4;
  }
  else
  {
    *a2 = *((unsigned __int8 *)v3 + 120);
    return v3[16];
  }
}

uint64_t kdu_subband::get_band_idx(kdu_subband *this)
{
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)this + 8) + 24))
    return *(unsigned __int8 *)(*(_QWORD *)this + 55) + 1;
  else
    return *(unsigned __int8 *)(*(_QWORD *)this + 55);
}

uint64_t kdu_subband::get_K_max(kdu_subband *this)
{
  return *(unsigned __int8 *)(*(_QWORD *)this + 58);
}

uint64_t kdu_subband::get_K_max_prime(kdu_subband *this)
{
  return *(unsigned __int8 *)(*(_QWORD *)this + 59);
}

uint64_t kdu_subband::get_reversible(kdu_subband *this)
{
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8) + 8) + 76);
}

float kdu_subband::get_delta(kdu_subband *this)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8) + 8) + 76))
    return *(float *)(*(_QWORD *)this + 60);
  return result;
}

float kdu_subband::get_msb_wmse(kdu_subband *this)
{
  uint64_t v1;
  _QWORD *v2;
  float result;
  double v4;
  unsigned int v5;
  char v6;
  BOOL v7;
  double v8;
  float v9;
  double v10;
  double v11;

  v1 = *(_QWORD *)this;
  v2 = *(_QWORD **)(*(_QWORD *)this + 8);
  result = 1.0;
  if (!*(_QWORD *)(*v2 + 8))
  {
    v4 = *(float *)(v1 + 60);
    v5 = *(unsigned __int8 *)(v1 + 59);
    if (v5 < 0x1F)
    {
      v6 = *(_BYTE *)(v1 + 59);
    }
    else
    {
      do
      {
        v4 = v4 * 1073741820.0;
        v6 = v5 - 30;
        v7 = v5 > 0x3C;
        v5 -= 30;
      }
      while (v7);
    }
    v8 = v4 * (double)(1 << (v6 - 1)) * (v4 * (double)(1 << (v6 - 1))) * *(float *)(v1 + 64);
    v9 = *(float *)(v2[1] + 152);
    v10 = v9;
    v7 = v9 <= 0.0;
    v11 = 1.0;
    if (!v7)
      v11 = v10;
    return v8 * v11 * *(float *)(v1 + 68) * *(float *)(v1 + 68);
  }
  return result;
}

BOOL kdu_subband::get_roi_weight(kdu_subband *this, float *a2)
{
  float v2;

  v2 = *(float *)(*(_QWORD *)this + 72);
  if (v2 >= 0.0)
    *a2 = v2 * v2;
  return v2 >= 0.0;
}

int32x4_t *kdu_subband::get_dims(int32x4_t **this, int32x4_t *a2)
{
  unsigned __int8 *v4;
  int32x4_t *result;
  int32x4_t *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  __int32 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v4 = *(unsigned __int8 **)(*this)->i64[1];
  *a2 = (*this)[2];
  result = kdu_dims::to_apparent(a2, v4[409], v4[410], v4[411]);
  if (*((_WORD *)v4 + 205))
  {
    v6 = *this;
    if (*this == (int32x4_t *)((*this)->i64[1] + 32))
    {
      v8 = 0;
      v7 = 0;
    }
    else
    {
      v7 = 0;
      v8 = 0;
      do
      {
        if (v4[409])
          v9 = v6[3].u8[1];
        else
          v9 = v6[3].u8[0];
        if (v4[409])
          v10 = v6[3].u8[0];
        else
          v10 = v6[3].u8[1];
        if (v9 == 1 && v4[411])
        {
          if (v8)
          {
            v14 = 0;
            v12 = 0u;
            v13 = 0u;
            kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "Assert ");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "!offset.x");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v12);
          }
          v8 = 1;
        }
        if (v10 == 1 && v4[410])
        {
          if (v7)
          {
            v14 = 0;
            v12 = 0u;
            v13 = 0u;
            kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "Assert ");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "!offset.y");
            (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v12);
          }
          v7 = 1;
        }
        v6 = (int32x4_t *)v6->i64[0];
      }
      while (v6 != (int32x4_t *)(v6->i64[1] + 32));
    }
    v11 = a2->i32[1] - v8;
    a2->i32[0] -= v7;
    a2->i32[1] = v11;
  }
  return result;
}

void sub_187EF3C08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF3C14()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

int32x4_t *kdu_subband::get_valid_blocks(kdu_subband *this, int32x4_t *a2)
{
  unsigned __int8 *v2;

  v2 = **(unsigned __int8 ***)(*(_QWORD *)this + 8);
  *a2 = *(int32x4_t *)(*(_QWORD *)this + 108);
  return kdu_dims::to_apparent(a2, v2[409], v2[410], v2[411]);
}

int32x2_t kdu_subband::get_block_size(uint64_t *a1, int32x2_t *a2, int32x2_t *a3)
{
  _BYTE *v5;
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int32x2_t result;
  __int128 v21;

  v5 = **(_BYTE ***)(*a1 + 8);
  *a2 = *(int32x2_t *)(*a1 + 84);
  v6 = *a1;
  v7 = **(unsigned __int8 ***)(*a1 + 8);
  v8 = *(_DWORD *)(*a1 + 108);
  v9 = *(_DWORD *)(*a1 + 116);
  v10 = v7[409];
  v11 = v7[410];
  v12 = v7[411];
  v13 = v10 == 0;
  if (v10)
    v14 = *(_DWORD *)(*a1 + 112);
  else
    v14 = *(_DWORD *)(*a1 + 108);
  if (v13)
  {
    v8 = *(_DWORD *)(*a1 + 112);
    v15 = *(_DWORD *)(*a1 + 116);
  }
  else
  {
    v15 = *(_DWORD *)(*a1 + 120);
  }
  if (v13)
    v9 = *(_DWORD *)(*a1 + 120);
  v16 = 1 - v8 - v9;
  if (v12)
    v17 = v16;
  else
    v17 = v8;
  v18 = 1 - v14 - v15;
  if (!v11)
    v18 = v14;
  if (v5[411])
    v17 = -v17;
  if (v5[410])
    v18 = -v18;
  if (v5[409])
    v19 = v18;
  else
    v19 = v17;
  if (!v5[409])
    v17 = v18;
  v21 = *(_OWORD *)(v6 + 76);
  LODWORD(v21) = v21 + DWORD2(v21) * v17;
  DWORD1(v21) += v19 * HIDWORD(v21);
  kdu_dims::operator&=(&v21, (int *)(v6 + 32));
  *a3 = *(int32x2_t *)((char *)&v21 + 8);
  if (v5[409])
  {
    *a2 = vrev64_s32(*a2);
    result = vrev64_s32(*a3);
    *a3 = result;
  }
  return result;
}

uint64_t kdu_subband::open_block(uint64_t *a1, unint64_t a2, _DWORD *a3, kdu_thread_entity *a4)
{
  unint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  _BOOL4 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  int *v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  kd_block *v39;
  _DWORD *v40;
  uint64_t *v42;
  uint64_t *v43;
  uint64_t v44;
  __int128 v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v4 = HIDWORD(a2);
  v5 = (_DWORD *)*a1;
  v6 = *(_QWORD *)(*a1 + 8);
  v7 = *(_QWORD *)v6;
  if (*(_BYTE *)(*(_QWORD *)v6 + 411))
    LODWORD(v4) = -HIDWORD(a2);
  if (*(_BYTE *)(*(_QWORD *)v6 + 410))
    v8 = -(int)a2;
  else
    v8 = a2;
  if (*(_BYTE *)(*(_QWORD *)v6 + 409))
    v9 = v8;
  else
    v9 = v4;
  if (!*(_BYTE *)(*(_QWORD *)v6 + 409))
    LODWORD(v4) = v8;
  v10 = v5[28];
  v11 = v4 - v5[27];
  if (v9 - v10 < 0 || v9 - v10 >= v5[30] || v11 < 0 || v11 >= v5[29])
  {
    v52 = 0;
    v50 = 0u;
    v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Assert ");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "(block_idx.x >= 0) && (block_idx.x < state->region_indices.size.x) && (block_idx.y >= 0) && (block_idx.y < state->region_indices.size.y)");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  v12 = *(_QWORD *)(*(_QWORD *)(v6 + 8) + 8);
  if (!*(_BYTE *)(v12 + 289))
  {
    v52 = 0;
    v50 = 0u;
    v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Assert ");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "tile->is_open");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  v13 = v4;
  v14 = v9;
  v15 = ((v9 >> v5[34]) - *(_DWORD *)(v6 + 188));
  v16 = (((int)v4 >> v5[33]) - *(_DWORD *)(v6 + 184));
  v17 = *(_DWORD *)(v6 + 196);
  v18 = v15 + v16 * v17;
  if (*(int *)(v6 + 192) * (uint64_t)v17 <= v18)
    return 0;
  v19 = v18;
  v20 = *(_QWORD *)(v6 + 232);
  v21 = *(_QWORD *)(v20 + 8 * v19);
  if (v21)
    v22 = (*(_QWORD *)(v20 + 8 * v19) & 1) == 0;
  else
    v22 = 0;
  if (v22 && !*(_BYTE *)(v21 + 20) && !*(_BYTE *)(v21 + 19))
  {
    v23 = 0;
    goto LABEL_37;
  }
  v23 = a4 != 0;
  if (a4)
  {
    kdu_thread_entity::acquire_lock(a4, 0, 1);
    v20 = *(_QWORD *)(v6 + 232);
    v21 = *(_QWORD *)(v20 + 8 * v19);
  }
  if (!v21)
    goto LABEL_34;
  if (v21 == 3)
    goto LABEL_36;
  if ((v21 & 1) != 0)
  {
LABEL_34:
    v25 = kd_precinct_ref::instantiate_precinct((uint64_t *)(v20 + 8 * v19), v6, (v15 << 32) | v16);
    if (v25)
    {
      v21 = v25;
      goto LABEL_37;
    }
LABEL_36:
    v52 = 0;
    v50 = 0u;
    v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "You are permitted to open each code-block only once from an open tile before closing that tile.  If the codestream object is marked as persistent, you may re-open code-blocks only after re-opening their containing tiles.");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  if (*(_BYTE *)(v21 + 20))
  {
    kd_precinct_size_class::withdraw_from_inactive_list(*(_QWORD *)(v21 + 72), (kd_precinct *)v21);
    kd_precinct::activate(v21);
LABEL_37:
    v26 = a1;
    goto LABEL_38;
  }
  v26 = a1;
  if (*(_BYTE *)(v21 + 19))
    kd_precinct::activate(v21);
LABEL_38:
  if (*(_QWORD *)(v7 + 8) && *(_DWORD *)(v21 + 32) < *(_DWORD *)(v21 + 24))
  {
    if (a4)
      v27 = v23;
    else
      v27 = 1;
    if ((v27 & 1) == 0)
    {
      LOBYTE(v23) = 1;
      kdu_thread_entity::acquire_lock(a4, 0, 1);
    }
    if (*(_BYTE *)(v7 + 418) || *(_BYTE *)(v12 + 328))
    {
LABEL_47:
      kd_precinct::load_required_packets(v21);
      if (!v23)
        goto LABEL_51;
      goto LABEL_50;
    }
    while (1)
    {
      if (*(_DWORD *)(v21 + 28) >= *(_DWORD *)(v21 + 24))
        goto LABEL_47;
      if (v12 != *(_QWORD *)(v7 + 440) && (kd_tile::read_tile_part_header((kd_tile *)v12) & 1) == 0)
      {
        if (*(_BYTE *)(v12 + 291))
        {
          v52 = 0;
          v50 = 0u;
          v51 = 0u;
          kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Assert ");
          (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "!tile->closed");
          (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, " FAILED");
          kdu_error::~kdu_error((kdu_error *)&v50);
        }
        kd_tile::finished_reading((kd_tile *)v12);
        goto LABEL_47;
      }
      *(_QWORD *)&v48 = 0;
      v49 = 0;
      v42 = *(uint64_t **)(v12 + 96);
      if (!v42)
      {
        v52 = 0;
        v50 = 0u;
        v51 = 0u;
        kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Corrupt jp2 data: tile->sequencer = NULL");
        kdu_error::~kdu_error((kdu_error *)&v50);
      }
      v43 = kd_packet_sequencer::next_in_sequence(v42, (uint64_t *)&v48, &v49);
      if (!v43)
        goto LABEL_89;
      v44 = *v43;
      if (*v43)
      {
        if ((v44 & 1) != 0 || *(_BYTE *)(v44 + 17))
          goto LABEL_90;
        if (v44 == 3)
        {
          v44 = 0;
        }
        else if (*(_BYTE *)(v44 + 20))
        {
          kd_precinct_size_class::withdraw_from_inactive_list(*(_QWORD *)(v44 + 72), (kd_precinct *)v44);
          kd_precinct::activate(v44);
        }
      }
      else
      {
        v44 = kd_precinct_ref::instantiate_precinct(v43, v48, v49);
      }
      if ((kd_precinct::desequence_packet((kd_precinct *)v44) & 1) == 0)
LABEL_89:
        kd_tile::read_tile_part_header((kd_tile *)v12);
LABEL_90:
      if (*(_BYTE *)(v12 + 328))
        goto LABEL_47;
    }
  }
  if (v23)
LABEL_50:
    kdu_thread_entity::release_lock(a4, 0);
LABEL_51:
  v28 = *v26;
  v48 = *(_OWORD *)(*v26 + 76);
  LODWORD(v48) = v48 + DWORD2(v48) * v13;
  DWORD1(v48) += HIDWORD(v48) * v14;
  kdu_dims::operator&=(&v48, (int *)(v28 + 16));
  if (SDWORD2(v48) * (uint64_t)SHIDWORD(v48) <= 0)
  {
    v52 = 0;
    v50 = 0u;
    v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Assert ");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "band_dims.area() > 0");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  v29 = *(_QWORD *)(v21 + 48);
  v30 = *(unsigned __int8 *)(*v26 + 55);
  v31 = v14 - *(_DWORD *)(v29 + 32 * v30 + 12);
  v32 = v13 - *(_DWORD *)(v29 + 32 * v30 + 8);
  if (v31 < 0 || v32 < 0 || (v33 = v29 + 32 * v30, v31 >= *(_DWORD *)(v33 + 20)) || v32 >= *(_DWORD *)(v33 + 16))
  {
    v52 = 0;
    v50 = 0u;
    v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Assert ");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "(block_idx.x >= 0) && (block_idx.y >= 0) && (block_idx.x < pband->block_indices.size.x) && (block_idx.y < pband->block_indices.size.y)");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  if (a4)
    v24 = *((_QWORD *)a4 + 10) + 144;
  else
    v24 = *(_QWORD *)(v7 + 56);
  if (*(_QWORD *)(v24 + 168))
  {
    v52 = 0;
    v50 = 0u;
    v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Assert ");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "result->precinct == NULL");
    (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  *(_QWORD *)(v24 + 168) = v21;
  *(_QWORD *)(v24 + 176) = *(_QWORD *)(v29 + 32 * v30 + 24) + 40 * v31 + 40 * *(_DWORD *)(v29 + 32 * v30 + 20) * v32;
  *(_QWORD *)v24 = *((_QWORD *)&v48 + 1);
  v34 = (int *)(*v26 + 32);
  v50 = v48;
  kdu_dims::operator&=(&v50, v34);
  v35 = v50;
  v36 = DWORD1(v50);
  *(_QWORD *)(v24 + 16) = *((_QWORD *)&v50 + 1);
  v37 = v36 - DWORD1(v48);
  *(_DWORD *)(v24 + 8) = v35 - v48;
  *(_DWORD *)(v24 + 12) = v37;
  v38 = *v26;
  *(_DWORD *)(v24 + 28) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*v26 + 8) + 8) + 172);
  *(_DWORD *)(v24 + 32) = *(unsigned __int8 *)(v38 + 54);
  *(_DWORD *)(v24 + 40) = *(unsigned __int8 *)(v38 + 59);
  *(_WORD *)(v24 + 25) = *(_WORD *)(v7 + 410);
  *(_BYTE *)(v24 + 24) = *(_BYTE *)(v7 + 409);
  *(_BYTE *)(v24 + 36) = *(_BYTE *)(v7 + 412);
  *(_BYTE *)(v24 + 37) = *(_BYTE *)(v7 + 414);
  v39 = *(kd_block **)(v24 + 176);
  if (*(_QWORD *)(v7 + 8))
  {
    v40 = a3;
    if (v39 && kd_block::retrieve_data(v39, (kdu_block *)v24, *(_DWORD *)(v21 + 24)))
    {
      v52 = 0;
      v50 = 0u;
      v51 = 0u;
      kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Corrupt JP2 data");
      goto LABEL_69;
    }
  }
  else
  {
    v40 = a3;
    if (*(_QWORD *)v39)
    {
      v52 = 0;
      v50 = 0u;
      v51 = 0u;
      kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v50 + 16))(&v50, "Attempting to open the same code-block more than once for writing!");
LABEL_69:
      kdu_error::~kdu_error((kdu_error *)&v50);
    }
  }
  if (v40)
    *v40 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v21 + 8) + 8) + 304) - 1;
  return v24;
}

void sub_187EF4584(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EF4590(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

double kdu_subband::close_block(uint64_t a1, kdu_block *a2, uint64_t a3)
{
  int *v4;
  kd_block *v5;
  uint64_t v6;
  int *v7;
  kd_block *block_state;
  double result;
  int v10;
  uint64_t v11;
  int updated;
  int v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v4 = (int *)*((_QWORD *)a2 + 21);
  v5 = (kd_block *)*((_QWORD *)a2 + 22);
  v6 = **(_QWORD **)(*(_QWORD *)a1 + 8);
  if (!v4)
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "precinct != NULL");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  if (a3)
  {
    v7 = *(int **)(a3 + 80);
    if (v7 + 36 == (int *)a2)
    {
      *((_QWORD *)a2 + 21) = 0;
      block_state = (kd_block *)kd_thread_env::get_block_state((kd_thread_env *)v7, (kd_codestream *)v6, (kd_precinct *)v4, v5);
      if (!*(_QWORD *)(v6 + 8))
      {
        kd_block::store_data(block_state, a2, (kd_thread_buf_server *)(v7 + 8290));
        if (*(_QWORD *)(v6 + 64))
          kd_compressed_stats::update_stats((uint64_t)(v7 + 82), (int *)a2);
        if (!*(_QWORD *)(v6 + 16))
          kd_thread_env::flush((uint64_t)v7, 1);
      }
      if (v7[8302] >= 6)
        kd_thread_env::flush((uint64_t)v7, 0);
      return result;
    }
LABEL_7:
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "((env == NULL) && (result == cs->block)) || ((env != NULL) && (result == &(env->get_state()->block)))");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  if (*(kdu_block **)(v6 + 56) != a2)
    goto LABEL_7;
  *((_QWORD *)a2 + 21) = 0;
  if (v4[9] <= 0)
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "precinct->num_outstanding_blocks > 0");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  if (*(_QWORD *)(v6 + 8))
  {
    if (!*(_BYTE *)(v6 + 417))
      kd_block::cleanup((uint64_t)v5, *(kd_buf_server **)(v6 + 48));
    v10 = v4[9] - 1;
    v4[9] = v10;
    if (!v10)
      kd_precinct::release((uint64_t *)v4);
  }
  else
  {
    v11 = *(_QWORD *)(v6 + 64);
    if (v11)
    {
      updated = kd_compressed_stats::update_stats(v11, (int *)a2);
      kd_compressed_stats::update_quant_slope_thresholds(*(_QWORD *)(v6 + 64));
    }
    else
    {
      updated = 0;
    }
    if (*(_QWORD *)v5)
    {
      v16 = 0;
      v14 = 0u;
      v15 = 0u;
      kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Assert ");
      (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "block->empty()");
      (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v14);
    }
    kd_block::store_data(v5, a2, *(kd_buf_server **)(v6 + 48));
    v13 = v4[9] - 1;
    v4[9] = v13;
    if (updated && !*(_BYTE *)(v6 + 422))
    {
      kd_codestream::trim_compressed_data(v6);
      v13 = v4[9];
    }
    if (!v13)
      *(_QWORD *)&result = kd_global_rescomp::add_ready_precinct(*(_QWORD *)(*(_QWORD *)v4 + 16), v4).n128_u64[0];
  }
  return result;
}

void sub_187EF4990(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF499C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_thread_env::get_block_state(kd_thread_env *this, kd_codestream *a2, kd_precinct *a3, kd_block *a4)
{
  _DWORD *v8;
  uint64_t result;
  int v10;

  v8 = (_DWORD *)((char *)this + 33208);
  if (*((_DWORD *)this + 8302) == 8)
    kd_thread_env::flush((uint64_t)this, 1);
  *((_QWORD *)this + 16) = a2;
  result = (uint64_t)this + 33216;
  v10 = 8;
  while (*(_QWORD *)(result + 40))
  {
    result += 56;
    if (!--v10)
      return 0;
  }
  ++*v8;
  *(_QWORD *)(result + 40) = a3;
  *(_QWORD *)(result + 48) = a4;
  *(_BYTE *)(*((_QWORD *)this + 17) + 88) = 1;
  return result;
}

uint64_t kd_compressed_stats::update_stats(uint64_t a1, int *a2)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = (_DWORD *)(a1 + 32808);
  v3 = *(_QWORD *)(a1 + 32) + *a2 * (uint64_t)a2[1];
  *(_QWORD *)(a1 + 32) = v3;
  v4 = a2[12];
  if ((int)v4 >= 1)
  {
    LODWORD(v5) = 0;
    v6 = (int *)*((_QWORD *)a2 + 7);
    v7 = (unsigned __int16 *)*((_QWORD *)a2 + 8);
    do
    {
      v8 = *v6++;
      v5 = v8 + (int)v5;
      LODWORD(v8) = *v7++;
      v9 = v8;
      if ((_DWORD)v8)
      {
        v10 = v9 >> 4;
        if (*v2 > (int)v10)
          *v2 = v10;
        if (*(_DWORD *)(a1 + 32812) < (int)v10)
          *(_DWORD *)(a1 + 32812) = v10;
        v11 = a1 + 8 * v10;
        v12 = *(_QWORD *)(v11 + 40) + v5;
        LODWORD(v5) = 0;
        *(_QWORD *)(v11 + 40) = v12;
      }
      --v4;
    }
    while (v4);
  }
  if (!*(_BYTE *)(a1 + 32824))
    return 0;
  v13 = *(_QWORD *)(a1 + 16);
  if (v3 <= v13)
    return 0;
  *(_QWORD *)(a1 + 16) = v13 + ((*(_QWORD *)(a1 + 8) + 7) >> 4);
  return 1;
}

uint64_t kd_block::cleanup(uint64_t this, kd_buf_server *a2)
{
  uint64_t v3;
  _QWORD *v4;

  v3 = this;
  v4 = *(_QWORD **)this;
  for (*(_QWORD *)(this + 8) = *(_QWORD *)this; v4; *(_QWORD *)(v3 + 8) = *(_QWORD *)v3)
  {
    *(_QWORD *)v3 = *v4;
    this = kd_buf_server::release((uint64_t)a2, (uint64_t)v4);
    v4 = *(_QWORD **)v3;
  }
  *(_BYTE *)(v3 + 18) = -1;
  return this;
}

uint64_t kd_compressed_stats::update_quant_slope_thresholds(uint64_t this)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  double v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;

  v1 = *(_DWORD *)(this + 32812);
  v2 = *(int *)(this + 32808);
  if (v1 >= (int)v2)
  {
    v3 = 0;
    v4 = *(double *)this;
    v5 = v1;
    v1 = v2 - 1;
    v6 = v5;
    while (1)
    {
      v3 += *(_QWORD *)(this + 40 + 8 * v6);
      if (v3 > (uint64_t)(*(double *)this * (double)(uint64_t)(*(_QWORD *)(this + 24) + *(_QWORD *)(this + 32))))
        break;
      v7 = v6-- <= v2;
      if (v7)
      {
        LODWORD(v6) = v2 - 1;
        break;
      }
    }
    v8 = 0;
    *(_DWORD *)(this + 32816) = v6;
    while (1)
    {
      v8 += *(_QWORD *)(this + 40 + 8 * v5);
      if (v8 > (uint64_t)(v4 * (double)*(uint64_t *)(this + 8)))
        break;
      v7 = v5-- <= v2;
      if (v7)
        goto LABEL_14;
    }
    v1 = v5;
  }
  else
  {
    *(_DWORD *)(this + 32816) = v1;
  }
LABEL_14:
  *(_DWORD *)(this + 32820) = v1;
  return this;
}

uint64_t kdu_subband::get_conservative_slope_threshold(kdu_subband *this)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  BOOL v4;
  int v5;
  unsigned int v6;

  v1 = **(_QWORD **)(*(_QWORD *)this + 8);
  v2 = *(_QWORD *)(v1 + 64);
  if (v2)
  {
    v3 = 16 * *(_DWORD *)(v2 + 32816);
    v4 = __OFSUB__(v3, 1);
    v5 = v3 - 1;
    if ((v5 < 0) ^ v4 | (v5 == 0))
      LOWORD(v5) = 1;
  }
  else
  {
    LOWORD(v5) = 1;
  }
  v6 = *(unsigned __int16 *)(v1 + 464);
  if (v6 <= (unsigned __int16)v5)
    return (unsigned __int16)v5;
  else
    return v6;
}

uint64_t kd_precinct::initialize(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t result;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  unint64_t partition_indices;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  int *v46;
  int v47;
  _DWORD *v48;
  int v49;
  unsigned int v50;
  int v51;
  int v52;
  int v53;
  unsigned int v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  _OWORD v61[2];
  uint64_t v62;

  v6 = *a2;
  v5 = a2[1];
  v7 = *((_DWORD *)a2 + 47) + HIDWORD(a3);
  v8 = *(_QWORD *)(v5 + 8);
  v9 = *((_DWORD *)a2 + 46) + a3;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 13) = 0;
  *(_WORD *)(a1 + 21) = 1;
  if (*(_QWORD *)(v6 + 8))
  {
    if (!*(_BYTE *)(v6 + 417))
    {
      if (*(_DWORD *)(v5 + 72) < (int)*((unsigned __int8 *)a2 + 24)
        || !*(_BYTE *)(v5 + 184)
        || (v10 = *((_DWORD *)a2 + 51), v7 < v10)
        || (v11 = *((_DWORD *)a2 + 50), v9 < v11)
        || v7 >= *((_DWORD *)a2 + 53) + v10
        || v9 >= *((_DWORD *)a2 + 52) + v11)
      {
        *(_BYTE *)(a1 + 21) = 0;
      }
    }
  }
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(v8 + 196);
  *(_QWORD *)(a1 + 36) = 0;
  *(_QWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_OWORD *)((char *)a2 + 100) = *(_OWORD *)(a2 + 21);
  v12 = *((_DWORD *)a2 + 26) + *((_DWORD *)a2 + 28) * v7;
  *((_DWORD *)a2 + 25) += *((_DWORD *)a2 + 27) * v9;
  *((_DWORD *)a2 + 26) = v12;
  result = kdu_dims::operator&=((_DWORD *)a2 + 25, (int *)a2 + 12);
  if (*((int *)a2 + 28) < 1 || *((int *)a2 + 27) <= 0)
  {
    v62 = 0;
    memset(v61, 0, sizeof(v61));
    kdu_error::kdu_error((kdu_error *)v61, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v61[0] + 16))(v61, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v61[0] + 16))(v61, "(resolution->node.prec_dims.size.x > 0) && (resolution->node.prec_dims.size.y > 0)");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v61[0] + 16))(v61, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v61);
  }
  v14 = *(_BYTE *)(v6 + 417) && !*(_BYTE *)(v8 + 289)
     || *(_DWORD *)(v5 + 72) < (int)*((unsigned __int8 *)a2 + 24)
     || *(_BYTE *)(v5 + 184) == 0;
  *(_QWORD *)(a1 + 48) = a1 + 80;
  v15 = *((unsigned __int8 *)a2 + 222);
  v60 = a1 + 80 + 32 * v15;
  v57 = v8;
  if (*((_BYTE *)a2 + 223))
  {
    v16 = 0;
    v17 = 0;
    do
    {
      v18 = a2[28] + v16;
      LODWORD(v19) = *(_DWORD *)(*(_QWORD *)v18 + 68);
      LODWORD(v20) = *(_DWORD *)(*(_QWORD *)v18 + 72);
      v21 = *(unsigned __int8 *)(v18 + 48);
      v22 = *(unsigned __int8 *)(v18 + 49);
      v23 = *(_DWORD *)(*(_QWORD *)v18 + 80) + v20;
      v24 = *(_DWORD *)(*(_QWORD *)v18 + 76) + v19;
      result = ((int)(v23 - v21 + 1) >> 1);
      if (v21 <= 1)
        v20 = ((int)(v20 - v21 + 1) >> 1);
      else
        v20 = v20;
      if (v21 <= 1)
        v23 = (int)(v23 - v21 + 1) >> 1;
      if (v22 <= 1)
        v19 = ((int)(v19 - v22 + 1) >> 1);
      else
        v19 = v19;
      if (v22 <= 1)
        v24 = (int)(v24 - v22 + 1) >> 1;
      *(_QWORD *)(v18 + 68) = v19 | (v20 << 32);
      *(_QWORD *)(v18 + 76) = (v24 - v19) | ((unint64_t)(v23 - v20) << 32);
      ++v17;
      v16 += 136;
    }
    while (v17 < *((unsigned __int8 *)a2 + 223));
    LODWORD(v15) = *((unsigned __int8 *)a2 + 222);
  }
  if ((_DWORD)v15)
  {
    v25 = 0;
    do
    {
      v26 = *(_QWORD *)(a1 + 48);
      v27 = a2[30];
      v28 = (unsigned __int8 *)(v27 + 144 * v25);
      *(_QWORD *)(v26 + 32 * v25) = v28;
      LODWORD(v29) = *(_DWORD *)(*(_QWORD *)v28 + 68);
      LODWORD(v30) = *(_DWORD *)(*(_QWORD *)v28 + 72);
      v31 = v28[48];
      v32 = v28[49];
      v33 = *(_DWORD *)(*(_QWORD *)v28 + 76) + v29;
      if (v31 <= 1)
        v30 = ((int)(v30 - v31 + 1) >> 1);
      else
        v30 = v30;
      if (v32 <= 1)
        v29 = ((int)(v29 - v32 + 1) >> 1);
      else
        v29 = v29;
      if (v32 <= 1)
        v33 = (int)(v33 - v32 + 1) >> 1;
      v34 = v27 + 144 * v25;
      partition_indices = get_partition_indices(*(_QWORD *)(v34 + 76), *(_QWORD *)(v34 + 84), v29 | (v30 << 32), v33 - (int)v29);
      v58 = v25;
      v36 = v26 + 32 * v25;
      *(_QWORD *)(v36 + 16) = v37;
      v38 = v36 + 16;
      *(_QWORD *)(v38 - 8) = partition_indices;
      result = (uint64_t)kd_block::build_tree(v37, (void **)&v60, *(int *)(*(_QWORD *)(a1 + 72) + 24) + a1 - v60);
      *(_QWORD *)(v38 + 8) = result;
      v61[0] = 0uLL;
      v61[0] = *(_OWORD *)(v34 + 76);
      v39 = DWORD2(v61[0]);
      v59 = DWORD1(v61[0]) + *(_DWORD *)(v38 - 4) * HIDWORD(v61[0]);
      v40 = LODWORD(v61[0]) + *(_DWORD *)(v38 - 8) * DWORD2(v61[0]);
      v41 = *(_QWORD *)(v38 + 8);
      if (*(_QWORD *)(v6 + 8))
      {
        LODWORD(v61[0]) += *(_DWORD *)(v38 - 8) * DWORD2(v61[0]);
        v42 = *(_DWORD *)v38;
        if (*(int *)v38 >= 1)
        {
          v43 = 0;
          v44 = v26 + 32 * v58;
          v47 = *(_DWORD *)(v44 + 20);
          v46 = (int *)(v44 + 20);
          v45 = v47;
          v48 = v28 + 32;
          do
          {
            DWORD1(v61[0]) = v59;
            if (v45 >= 1)
            {
              v49 = 0;
              do
              {
                v50 = *(_DWORD *)(a2[1] + 172);
                if (v50 >= 0x100)
                  kd_precinct::initialize();
                *(_BYTE *)(v41 + 25) = v50;
                if (v14 || (result = kdu_dims::intersects(v61, v48), (result & 1) == 0))
                {
                  if (!*(_BYTE *)(v6 + 417))
                    *(_BYTE *)(v41 + 18) = -1;
                }
                else
                {
                  ++*(_DWORD *)(a1 + 36);
                }
                ++v49;
                DWORD1(v61[0]) += HIDWORD(v61[0]);
                v41 += 40;
                v45 = *v46;
              }
              while (v49 < *v46);
              v39 = DWORD2(v61[0]);
              v40 = v61[0];
              v42 = *(_DWORD *)v38;
            }
            ++v43;
            v40 += v39;
            LODWORD(v61[0]) = v40;
          }
          while (v43 < v42);
        }
      }
      else
      {
        v51 = *(_DWORD *)v38;
        if (*(int *)v38 >= 1)
        {
          v52 = 0;
          v53 = *(_DWORD *)(v26 + 32 * v25 + 20);
          do
          {
            if (v53 >= 1)
            {
              v54 = *(_DWORD *)(a2[1] + 172);
              if (v54 > 0xFF)
              {
                *(_QWORD *)&v61[0] = __PAIR64__(v59, v40);
                __assert_rtn("set_modes", "compressed_local.h", 3520, "modes == (modes & 0xFF)");
              }
              v55 = *(_DWORD *)(a1 + 36);
              v56 = v53;
              do
              {
                *(_BYTE *)(v41 + 25) = v54;
                v41 += 40;
                --v56;
              }
              while (v56);
              *(_DWORD *)(a1 + 36) = v53 + v55;
            }
            ++v52;
            v40 += v39;
          }
          while (v52 != v51);
        }
      }
      v25 = v58 + 1;
    }
    while (v58 + 1 < (unint64_t)*((unsigned __int8 *)a2 + 222));
  }
  if (!*(_DWORD *)(a1 + 36) && *(_QWORD *)(v6 + 8))
    *(_BYTE *)(a1 + 19) = 1;
  if (*(_BYTE *)(v57 + 287))
    *(_DWORD *)(a1 + 32) = -1;
  return result;
}

void sub_187EF51A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EF51B4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

unsigned __int8 **kd_precinct::closing(unsigned __int8 **this)
{
  unsigned __int8 **v1;
  unsigned __int8 *v2;
  unint64_t v3;
  kd_buf_server *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD v11[2];
  uint64_t v12;

  v1 = this;
  if (this[1])
  {
    v12 = 0;
    memset(v11, 0, sizeof(v11));
    kdu_error::kdu_error((kdu_error *)v11, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v11[0] + 16))(v11, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v11[0] + 16))(v11, "ref == NULL");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v11[0] + 16))(v11, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v11);
  }
  v2 = *this;
  if ((*this)[222])
  {
    v3 = 0;
    v4 = *(kd_buf_server **)(*(_QWORD *)v2 + 48);
    do
    {
      v5 = (uint64_t)&v1[6][32 * v3];
      v7 = *(_QWORD *)(v5 + 24);
      v6 = (_QWORD *)(v5 + 24);
      if (v7)
      {
        v8 = *(_DWORD *)&v1[6][32 * v3 + 16] * *(_DWORD *)&v1[6][32 * v3 + 20];
        if (v8 >= 1)
        {
          v9 = 0;
          v10 = 40 * v8;
          do
          {
            this = (unsigned __int8 **)kd_block::cleanup(*v6 + v9, v4);
            v9 += 40;
          }
          while (v10 != v9);
          v2 = *v1;
        }
        *v6 = 0;
      }
      ++v3;
    }
    while (v3 < v2[222]);
  }
  if (!*((_BYTE *)v1 + 18))
  {
    this = (unsigned __int8 **)v1[5];
    if (this)
    {
      this = (unsigned __int8 **)MEMORY[0x18D761C18](this, 0x1000C8000313F17);
      v1[5] = 0;
    }
  }
  return this;
}

void sub_187EF5314(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF5320()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_precinct::activate(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  int *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int *v17;
  int v18;
  _DWORD *v19;
  int v20;
  _OWORD v21[2];
  uint64_t v22;

  v1 = this;
  v2 = *(_QWORD *)this;
  v3 = *(_QWORD *)(*(_QWORD *)this + 8);
  v4 = *(_QWORD *)(v3 + 8);
  if (!*(_BYTE *)(this + 19) || *(_DWORD *)(this + 36) || !*(_BYTE *)(v4 + 289))
  {
    v22 = 0;
    memset(v21, 0, sizeof(v21));
    kdu_error::kdu_error((kdu_error *)v21, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v21[0] + 16))(v21, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v21[0] + 16))(v21, "released && (num_outstanding_blocks == 0) && tile->is_open");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v21[0] + 16))(v21, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v21);
  }
  *(_BYTE *)(this + 19) = 0;
  *(_DWORD *)(this + 24) = *(_DWORD *)(v4 + 196);
  if (*(_DWORD *)(v3 + 72) >= (int)*(unsigned __int8 *)(v2 + 24) && *(_BYTE *)(v3 + 184) && *(_BYTE *)(v2 + 222))
  {
    v5 = 0;
    do
    {
      v6 = *(_QWORD *)(v1 + 48);
      v7 = *(_QWORD *)(v2 + 240);
      v21[0] = 0uLL;
      v21[0] = *(_OWORD *)(v7 + 144 * v5 + 76);
      v8 = (_DWORD *)(v6 + 32 * v5);
      v10 = v8 + 4;
      v9 = v8[4];
      v11 = DWORD2(v21[0]);
      v12 = v8[3];
      v13 = LODWORD(v21[0]) + v8[2] * DWORD2(v21[0]);
      LODWORD(v21[0]) = v13;
      if (v9 >= 1)
      {
        v14 = 0;
        v15 = DWORD1(v21[0]) + v12 * HIDWORD(v21[0]);
        v18 = v8[5];
        v17 = v8 + 5;
        v16 = v18;
        v19 = (_DWORD *)(v7 + 144 * v5 + 32);
        do
        {
          DWORD1(v21[0]) = v15;
          if (v16 >= 1)
          {
            v20 = 0;
            do
            {
              this = kdu_dims::intersects(v21, v19);
              if ((_DWORD)this)
                ++*(_DWORD *)(v1 + 36);
              ++v20;
              DWORD1(v21[0]) += HIDWORD(v21[0]);
              v16 = *v17;
            }
            while (v20 < *v17);
            v11 = DWORD2(v21[0]);
            v13 = v21[0];
            v9 = *v10;
          }
          ++v14;
          v13 += v11;
          LODWORD(v21[0]) = v13;
        }
        while (v14 < v9);
        v2 = *(_QWORD *)v1;
      }
      ++v5;
    }
    while (v5 < *(unsigned __int8 *)(v2 + 222));
  }
  return this;
}

void sub_187EF5510(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF551C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_precinct::read_packet(uint64_t **this)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v16;
  char v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  kd_block *v23;
  int *v24;
  int v25;
  BOOL v26;
  unsigned int v27;
  int v28;
  char v29;
  uint64_t v30;
  uint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int *v36;
  int v37;
  kd_input *v38;
  _BYTE *v39;
  uint64_t v40;
  _BYTE *v41;
  _BYTE *v42;
  _DWORD *exception;
  int v44;
  int v45;
  unsigned __int8 v46;
  _QWORD v47[2];
  __int128 v48;
  __int128 v49;
  uint64_t v50;

  v2 = *((_DWORD *)this + 8);
  if (v2 < 0)
  {
    if (!*((_BYTE *)this + 18))
    {
      v50 = 0;
      v48 = 0u;
      v49 = 0u;
      kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Assert ");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "addressable");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v48);
    }
    return 0;
  }
  v3 = **this;
  v4 = *(_QWORD *)((*this)[1] + 8);
  if (v2 >= *(_DWORD *)(v4 + 192))
  {
    v50 = 0;
    v48 = 0u;
    v49 = 0u;
    kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Assert ");
    (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "num_packets_read < tile->num_layers");
    (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v48);
  }
  if (!*((_BYTE *)this + 18) && v4 != *(_QWORD *)(v3 + 440))
  {
    v50 = 0;
    v48 = 0u;
    v49 = 0u;
    kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Assert ");
    (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "addressable || (tile == codestream->active_tile)");
    (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v48);
  }
  v5 = *(_QWORD *)((*this)[1] + 8);
  v6 = *(unsigned __int8 *)(v5 + 284);
  v7 = *(_BYTE *)(v5 + 284) && *(_BYTE *)(v3 + 413) && *(_BYTE *)(v3 + 412) != 0;
  if (*((_BYTE *)this + 16))
    return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
  v9 = *(unsigned __int8 *)(v5 + 285);
  if (!*(_BYTE *)(v4 + 316))
    goto LABEL_25;
  v10 = *(_DWORD *)(v4 + 320);
  if (v10 >= 0x10000)
  {
    v50 = 0;
    v48 = 0u;
    v49 = 0u;
    kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Assert ");
    (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "(sop_num >= 0) && (sop_num < (1<<16))");
    (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v48);
  }
  if ((_WORD)v10 != (unsigned __int16)*(_DWORD *)(v4 + 312))
    return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
  if (*(_BYTE *)(v4 + 316))
  {
    v11 = *(_DWORD *)(v4 + 320);
    if (v11 >= 0x10000)
    {
      v50 = 0;
      v48 = 0u;
      v49 = 0u;
      kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Assert ");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "(sop_num >= 0) && (sop_num < (1<<16))");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v48);
    }
    if ((_WORD)v11 != (unsigned __int16)*(_DWORD *)(v4 + 312))
    {
      v50 = 0;
      v48 = 0u;
      v49 = 0u;
      kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Assert ");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "compare_sop_num(tile->next_sop_sequence_num, tile->next_input_packet_num) == 0");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v48);
    }
    *(_BYTE *)(v4 + 316) = 0;
  }
  else
  {
LABEL_25:
    v12 = *(_QWORD *)(v3 + 32);
    while (kd_marker::read((kd_marker *)v12, 1, v7))
    {
      v12 = *(_QWORD *)(v3 + 32);
      v13 = *(unsigned __int16 *)(v12 + 16);
      if (v13 == 65424)
      {
        if (*(_BYTE *)(*(_QWORD *)(v3 + 8) + 544))
          goto LABEL_37;
        *(_QWORD *)(v3 + 440) = 0;
        kd_tile::adjust_unloadability((uint64_t *)v4);
        return 0;
      }
      if (v6 && v13 == 65425)
      {
        if (*((_BYTE *)this + 18))
          break;
        v27 = __rev16(**(unsigned __int16 **)(v12 + 32));
        if (!compare_sop_num(v27, *(_DWORD *)(v4 + 312)))
          break;
        if (!*(_BYTE *)(v3 + 412))
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
          kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Out-of-sequence SOP marker found while attempting to read a packet from the code-stream!\n");
          (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "\tFound sequence number ");
          v41 = kdu_message::operator<<(&v48);
          (*(void (**)(_BYTE *, const char *))(*(_QWORD *)v41 + 16))(v41, ", but expected ");
          v42 = kdu_message::operator<<(v41);
          (*(void (**)(_BYTE *, const char *))(*(_QWORD *)v42 + 16))(v42, ".\n");
          (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Use the resilient option if you would like to try to recover from this error.");
          kdu_error::~kdu_error((kdu_error *)&v48);
        }
        *(_BYTE *)(v4 + 316) = 1;
        *(_DWORD *)(v4 + 320) = v27;
        return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
      }
      if ((v7 & 1) == 0)
      {
        if (!*(_BYTE *)(v3 + 412))
        {
          v50 = 0;
          v48 = 0u;
          v49 = 0u;
          kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Illegal marker code found while attempting to read a packet from the code-stream!\n");
          (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "\tIllegal marker code is ");
          print_marker_code(*(unsigned __int16 *)(*(_QWORD *)(v3 + 32) + 16), (kdu_message *)&v48);
          (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, ".\n");
          (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Use the resilient option if you would like to try to recover from this error.");
          kdu_error::~kdu_error((kdu_error *)&v48);
        }
        return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
      }
    }
  }
  v14 = *(_QWORD *)(v3 + 8);
  if (*(_BYTE *)(v14 + 544))
  {
LABEL_37:
    kd_tile::finished_reading((kd_tile *)v4);
    if (!*((_DWORD *)this + 8) && *((_BYTE *)this + 18))
    {
      v8 = 0;
      *((_DWORD *)this + 8) = -1;
      return v8;
    }
    return 0;
  }
  if (*(_BYTE *)(v3 + 416) && (*((_DWORD *)this + 8) >= *((_DWORD *)this + 6) || !*((_BYTE *)this + 21)))
  {
    v45 = 1;
    kd_compressed_input::set_suspend(v14, 1);
  }
  else
  {
    v45 = 0;
  }
  v16 = *(_QWORD *)(v4 + 88);
  if (!v16)
    v16 = *(_QWORD *)(v3 + 8);
  v17 = 0;
  v47[0] = v16;
  v47[1] = 0;
  if (!*(_BYTE *)(v3 + 412))
  {
    if (!*(_BYTE *)(v3 + 414))
      goto LABEL_53;
    v17 = 1;
  }
  *(_BYTE *)(v16 + 547) = v17;
  *(_WORD *)(v16 + 545) = 1;
LABEL_53:
  v44 = v9;
  if (kd_header_in::get_bit((kd_header_in *)v47) && (v18 = *this, *((_BYTE *)*this + 222)))
  {
    v19 = 0;
    v20 = 0;
    do
    {
      v21 = (uint64_t)&this[6][4 * v19];
      v22 = *(_DWORD *)(v21 + 16);
      if (v22 >= 1)
      {
        v23 = *(kd_block **)(v21 + 24);
        v24 = (int *)(v21 + 20);
        do
        {
          if (*v24 >= 1)
          {
            v25 = *v24 + 1;
            do
            {
              v20 += (int)kd_block::parse_packet_header(v23, (kd_header_in *)v47, *(kd_buf_server **)(v3 + 48), *((_DWORD *)this + 8));
              v23 = (kd_block *)((char *)v23 + 40);
              --v25;
            }
            while (v25 > 1);
          }
          v26 = __OFSUB__(v22--, 1);
        }
        while (!((v22 < 0) ^ v26 | (v22 == 0)));
        v18 = *this;
      }
      ++v19;
    }
    while (v19 < *((unsigned __int8 *)v18 + 222));
  }
  else
  {
    v20 = 0;
  }
  kd_header_in::finish((uint64_t)v47);
  if (*(_BYTE *)(v16 + 545))
  {
    *(_BYTE *)(v16 + 545) = 0;
    if (*(_BYTE *)(v16 + 544))
    {
      *(_BYTE *)(v16 + 546) = 0;
    }
    else if (*(_BYTE *)(v16 + 546))
    {
      v50 = 0;
      v48 = 0u;
      v49 = 0u;
      kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Assert ");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "0");
      (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v48);
    }
  }
  if (v44)
  {
    v46 = 0;
    if (kd_input::get((kd_input *)v16, &v46))
      v28 = v46;
    else
      v28 = 0;
    if (kd_input::get((kd_input *)v16, &v46))
      v28 = v46 | (v28 << 8);
    if (*(_BYTE *)(v16 + 544))
    {
      if (v16 == *(_QWORD *)(v4 + 88))
      {
        v50 = 0;
        v48 = 0u;
        v49 = 0u;
        kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Exhausted PPM/PPT marker segment data while attempting to parse a packet header!");
        kdu_error::~kdu_error((kdu_error *)&v48);
      }
      if (!*(_BYTE *)(*(_QWORD *)(v3 + 8) + 544))
      {
        v50 = 0;
        v48 = 0u;
        v49 = 0u;
        kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Assert ");
        (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "codestream->in->failed()");
        (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v48);
      }
      kd_tile::finished_reading((kd_tile *)v4);
      if (!*((_DWORD *)this + 8) && *((_BYTE *)this + 18))
        *((_DWORD *)this + 8) = -1;
      if (v45)
        kd_compressed_input::set_suspend(*(_QWORD *)(v3 + 8), 0);
      return 0;
    }
    if (v28 != 65426)
    {
      if (!*(_BYTE *)(v3 + 412) || v16 != *(_QWORD *)(v3 + 8))
      {
        v50 = 0;
        v48 = 0u;
        v49 = 0u;
        kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Expected to find EPH marker following packet header.  Found ");
        print_marker_code(v28, (kdu_message *)&v48);
        (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, " instead.");
        kdu_error::~kdu_error((kdu_error *)&v48);
      }
      if (!v45)
        return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
      v40 = v16;
LABEL_127:
      kd_compressed_input::set_suspend(v40, 0);
      return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
    }
  }
  if (v20 >= 1)
  {
    if (*(_BYTE *)(v3 + 412))
    {
      v29 = 0;
    }
    else
    {
      if (!*(_BYTE *)(v3 + 414))
        goto LABEL_101;
      v29 = 1;
    }
    v30 = *(_QWORD *)(v3 + 8);
    *(_BYTE *)(v30 + 547) = v29;
    *(_WORD *)(v30 + 545) = 1;
LABEL_101:
    v31 = *this;
    if (*((_BYTE *)*this + 222))
    {
      v32 = 0;
      do
      {
        v33 = (uint64_t)&this[6][4 * v32];
        v34 = *(_DWORD *)(v33 + 16);
        if (v34 >= 1)
        {
          v35 = *(_QWORD *)(v33 + 24);
          v36 = (int *)(v33 + 20);
          do
          {
            if (*v36 >= 1)
            {
              v37 = *v36 + 1;
              do
              {
                v38 = *(kd_input **)(v3 + 8);
                if (*((_BYTE *)v38 + 544))
                {
                  exception = __cxa_allocate_exception(4uLL);
                  *exception = -1;
                  __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
                }
                kd_block::read_body_bytes(v35, v38, *(kd_buf_server **)(v3 + 48));
                v35 += 40;
                --v37;
              }
              while (v37 > 1);
            }
            v26 = __OFSUB__(v34--, 1);
          }
          while (!((v34 < 0) ^ v26 | (v34 == 0)));
          v31 = *this;
        }
        ++v32;
      }
      while (v32 < *((unsigned __int8 *)v31 + 222));
    }
  }
  v39 = *(_BYTE **)(v3 + 8);
  if (v39[545])
  {
    v39[545] = 0;
    if (v39[544])
    {
      v39[546] = 0;
    }
    else if (v39[546])
    {
      if (!*(_BYTE *)(v3 + 412))
      {
        v50 = 0;
        v48 = 0u;
        v49 = 0u;
        kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v48 + 16))(&v48, "Packet body terminated with an FF!");
        kdu_error::~kdu_error((kdu_error *)&v48);
      }
      kd_input::putback((uint64_t)v39, 255);
      if (!v45)
        return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
      v40 = *(_QWORD *)(v3 + 8);
      goto LABEL_127;
    }
  }
  ++*((_DWORD *)this + 8);
  if (v45)
    kd_compressed_input::set_suspend(*(_QWORD *)(v3 + 8), 0);
  return 1;
}

void sub_187EF6000(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EF600C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, uint64_t a11, uint64_t a12, __int128 a13, __int128 a14, uint64_t a15)
{
  _Unwind_Exception *v15;

  _Unwind_Resume(v15);
}

void sub_187EF649C()
{
  __cxa_end_catch();
  JUMPOUT(0x187EF5B2CLL);
}

void sub_187EF64B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EF64BC()
{
  __cxa_end_catch();
  JUMPOUT(0x187EF60D8);
}

uint64_t compare_sop_num(unsigned int a1, int a2)
{
  unsigned int v2;
  _OWORD v5[2];
  uint64_t v6;

  if (a1 >= 0x10000)
  {
    v6 = 0;
    memset(v5, 0, sizeof(v5));
    kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "(sop_num >= 0) && (sop_num < (1<<16))");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v5);
  }
  v2 = a1 - a2;
  if ((_WORD)a1 == (_WORD)a2)
    return 0;
  if ((unsigned __int16)(a1 - a2) >= 0x8001u && (int)(a1 - a2) <= 0)
    return v2 - 0x10000;
  else
    return v2;
}

void sub_187EF6614(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF6620()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_precinct::handle_corrupt_packet(kd_precinct *this)
{
  uint64_t *v2;
  _QWORD *v3;
  int v4;
  BOOL v5;
  BOOL v6;
  BOOL v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v20;
  int v21;
  int v22;
  signed int v23;
  int v25;
  int v26;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  if (*((_BYTE *)this + 18))
  {
    v30 = 0;
    v28 = 0u;
    v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Encountered a corrupted packet while using packet length information to access the compressed data source in a random access fashion.  To process corrupted code-streams in an error resilient manner, you must disable seeking on the compressed data source (i.e., force sequential access) as well as enabling the resilient parsing mode.");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  v2 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)this + 8) + 8);
  v3 = (_QWORD *)*v2;
  v4 = *(unsigned __int8 *)(*v2 + 413);
  *((_BYTE *)this + 16) = 1;
  v5 = v4 == 0;
  v6 = *((_BYTE *)v2 + 316) == 0;
  v7 = v4 == 0;
  while (!v6)
  {
    v10 = *((_DWORD *)v2 + 80);
    v11 = *((_DWORD *)v2 + 78);
    if (v10 >= 0x10000)
    {
      v30 = 0;
      v28 = 0u;
      v29 = 0u;
      kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Assert ");
      (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "(sop_num >= 0) && (sop_num < (1<<16))");
      (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v28);
    }
LABEL_13:
    v14 = v10 - v11;
    if ((_WORD)v10 == (_WORD)v11)
      goto LABEL_42;
    if ((unsigned __int16)(v10 - v11) >= 0x8001u && v14 <= 0)
      v14 -= 0x10000;
    if (v14 <= 0)
    {
LABEL_42:
      v25 = 0;
      *((_BYTE *)v2 + 316) = 0;
      v7 = v5;
    }
    else
    {
      v16 = *((_DWORD *)v2 + 80);
      v17 = *((_DWORD *)v2 + 78);
      if (v16 >= 0x10000)
      {
        v30 = 0;
        v28 = 0u;
        v29 = 0u;
        kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Assert ");
        (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "(sop_num >= 0) && (sop_num < (1<<16))");
        (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v28);
      }
      v18 = v16 - v17;
      if ((_WORD)v16 == (_WORD)v17)
        goto LABEL_31;
      if ((unsigned __int16)(v16 - v17) >= 0x8001u && v18 <= 0)
        v18 -= 0x10000;
      if (v18 < 4 || v7)
      {
LABEL_31:
        v20 = *((_DWORD *)v2 + 80);
        v21 = *((_DWORD *)v2 + 51);
        v22 = *((_DWORD *)v2 + 48);
        if (v20 >= 0x10000)
        {
          v30 = 0;
          v28 = 0u;
          v29 = 0u;
          kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Assert ");
          (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "(sop_num >= 0) && (sop_num < (1<<16))");
          (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, " FAILED");
          kdu_error::~kdu_error((kdu_error *)&v28);
        }
        v23 = v20 - v22 * v21;
        if ((_WORD)v20 == (_WORD)v22 * (_WORD)v21)
          goto LABEL_41;
        if ((unsigned __int16)(v20 - v22 * v21) >= 0x8001u && v23 <= 0)
          v23 -= 0x10000;
        if (v23 < 0)
        {
          v25 = *((unsigned __int8 *)v2 + 316);
        }
        else
        {
LABEL_41:
          v25 = 0;
          *((_BYTE *)v2 + 316) = 0;
          v7 = v5;
        }
      }
      else
      {
        v25 = 0;
        *((_BYTE *)v2 + 316) = 0;
        v7 = 1;
      }
    }
    v6 = 1;
    if (v25)
    {
      v26 = *((_DWORD *)this + 8);
      if (v26 >= *((_DWORD *)v2 + 48))
      {
        v30 = 0;
        v28 = 0u;
        v29 = 0u;
        kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Assert ");
        (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "num_packets_read < tile->num_layers");
        (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v28);
      }
      *((_DWORD *)this + 8) = v26 + 1;
      return 1;
    }
  }
  v8 = v3[4];
  while ((kd_marker::read((kd_marker *)v8, 1, 1) & 1) != 0)
  {
    v8 = v3[4];
    v9 = *(unsigned __int16 *)(v8 + 16);
    if (v9 == 65425)
    {
      v12 = *(unsigned __int8 **)(v8 + 32);
      v13 = *v12;
      *((_DWORD *)v2 + 80) = v13 << 8;
      v10 = v12[1] | (v13 << 8);
      *((_DWORD *)v2 + 80) = v10;
      *((_BYTE *)v2 + 316) = 1;
      v11 = *((_DWORD *)v2 + 78);
      goto LABEL_13;
    }
    if (v9 == 65424)
    {
      v3[55] = 0;
      kd_tile::adjust_unloadability(v2);
      return 0;
    }
  }
  if (!*(_BYTE *)(v3[1] + 544))
  {
    v30 = 0;
    v28 = 0u;
    v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "Assert ");
    (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, "codestream->in->failed()");
    (*(void (**)(__int128 *, const char *))(v28 + 16))(&v28, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  kd_tile::finished_reading((kd_tile *)v2);
  return 0;
}

void sub_187EF6AA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF6AB4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_compressed_input::set_suspend(uint64_t this, int a2)
{
  uint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  if (!*(_BYTE *)(this + 608))
  {
    v2 = *(_QWORD *)(this + 592);
    if (v2)
      v3 = 1;
    else
      v3 = a2 == 0;
    if (v3)
    {
      if (v2)
      {
        if ((a2 & 1) == 0)
        {
          v4 = *(_QWORD *)(this + 528);
          v5 = v4 - v2 + *(_QWORD *)(this + 584);
          *(_QWORD *)(this + 584) = v5;
          *(_QWORD *)(this + 592) = 0;
          v6 = *(_QWORD *)(this + 568) + v5 - *(_QWORD *)(this + 560);
          v7 = *(_QWORD *)(this + 536);
          v8 = v7 - this - 14;
          v9 = v6 < v8;
          v10 = v6 - v8;
          if (v9)
          {
            *(_QWORD *)(this + 600) = v7;
            v11 = v7 + v10;
            *(_QWORD *)(this + 536) = v11;
            if (v11 < v4)
            {
              *(_BYTE *)(this + 544) = 1;
              *(_QWORD *)(this + 584) = v5 - v4 + v11;
              *(_QWORD *)(this + 536) = v4;
            }
          }
        }
      }
    }
    else
    {
      *(_QWORD *)(this + 592) = *(_QWORD *)(this + 528);
      v12 = *(_QWORD *)(this + 600);
      if (v12)
      {
        if (v12 <= *(_QWORD *)(this + 536))
          kd_compressed_input::set_suspend();
        *(_QWORD *)(this + 536) = v12;
        *(_QWORD *)(this + 600) = 0;
      }
    }
  }
  return this;
}

uint64_t kd_header_in::get_bit(kd_header_in *this)
{
  int v2;
  int v3;
  int v4;
  _QWORD *exception;

  v2 = *((_DWORD *)this + 3);
  if (!v2)
  {
    if (*((unsigned __int8 *)this + 8) == 255)
      v3 = 7;
    else
      v3 = 8;
    *((_DWORD *)this + 3) = v3;
    if (!kd_input::get(*(kd_input **)this, (unsigned __int8 *)this + 8))
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = this;
    }
    v2 = *((_DWORD *)this + 3);
  }
  v4 = v2 - 1;
  *((_DWORD *)this + 3) = v4;
  return (*((unsigned __int8 *)this + 8) >> v4) & 1;
}

uint64_t kd_header_in::finish(uint64_t this)
{
  uint64_t v1;
  _QWORD *exception;

  if (!*(_DWORD *)(this + 12))
  {
    v1 = this;
    if (*(unsigned __int8 *)(this + 8) == 255)
    {
      *(_DWORD *)(this + 12) = 7;
      this = kd_input::get(*(kd_input **)this, (unsigned __int8 *)(this + 8));
      if ((this & 1) == 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        *exception = v1;
      }
    }
  }
  return this;
}

uint64_t kd_input::get(kd_input *this, unsigned __int8 *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  unsigned int v6;

  if (*((_BYTE *)this + 544))
    return 0;
  v5 = (unsigned __int8 *)*((_QWORD *)this + 66);
  if (v5 == *((unsigned __int8 **)this + 67))
  {
    result = (*(uint64_t (**)(kd_input *))(*(_QWORD *)this + 24))(this);
    if (!(_DWORD)result)
      return result;
    v5 = (unsigned __int8 *)*((_QWORD *)this + 66);
  }
  *((_QWORD *)this + 66) = v5 + 1;
  v6 = *v5;
  *a2 = v6;
  if (*((_BYTE *)this + 545))
  {
    if (*((_BYTE *)this + 546))
    {
      if (v6 >= 0x90)
      {
        kd_input::process_unexpected_marker((unsigned __int8 *)this, v6);
        v6 = *a2;
      }
    }
    *((_BYTE *)this + 546) = v6 == 255;
  }
  return 1;
}

uint64_t kd_input::putback(uint64_t this, char a2)
{
  unint64_t v2;

  if (*(_BYTE *)(this + 544))
    kd_input::putback();
  if (*(_BYTE *)(this + 545))
    kd_input::putback();
  v2 = *(_QWORD *)(this + 528);
  if (v2 <= this + 8)
    kd_input::putback();
  *(_QWORD *)(this + 528) = v2 - 1;
  *(_BYTE *)(v2 - 1) = a2;
  return this;
}

uint64_t kd_precinct::simulate_packet(kd_precinct *this, uint64_t *a2, int a3, unsigned int a4, int a5, char a6, uint64_t a7, int a8)
{
  int v13;
  kd_buf_server *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t result;
  char v41;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v61;
  _QWORD v63[3];
  __int128 v64;
  __int128 v65;
  uint64_t v66;

  v13 = *((_DWORD *)this + 6);
  v57 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 8) + 8);
  if (v13 != *(_DWORD *)(v57 + 192))
  {
    v66 = 0;
    v64 = 0u;
    v65 = 0u;
    kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Assert ");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "required_layers == tile->num_layers");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v64);
  }
  v14 = *(kd_buf_server **)(**(_QWORD **)this + 48);
  if (v13 <= a3)
  {
    v66 = 0;
    v64 = 0u;
    v65 = 0u;
    kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Assert ");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "layer_idx < required_layers");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v64);
  }
  if (*((_DWORD *)this + 9))
  {
    v66 = 0;
    v64 = 0u;
    v65 = 0u;
    kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "You may not currently flush compressed code-stream data without completing the compression of all code-blocks in all precincts of all tiles.");
    kdu_error::~kdu_error((kdu_error *)&v64);
  }
  v15 = *((_QWORD *)this + 5);
  if (!v15)
  {
    if (a3)
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Assert ");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "layer_idx == 0");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v64);
    }
    v15 = operator new[]();
    *((_QWORD *)this + 5) = v15;
    goto LABEL_13;
  }
  if (!a3)
  {
LABEL_13:
    v16 = *((unsigned int *)this + 6);
    if ((int)v16 >= 1)
    {
      v17 = 0;
      v18 = 3;
      if (!*(_BYTE *)(v57 + 285))
        v18 = 1;
      v19 = 8 * v16;
      do
      {
        *(_QWORD *)(*((_QWORD *)this + 5) + v17) = v18;
        v17 += 8;
      }
      while (v19 != v17);
      v15 = *((_QWORD *)this + 5);
    }
  }
  *(_QWORD *)(v15 + 8 * a3) = 0;
  v61 = a2;
  if ((a8 & 1) != 0)
  {
    if (!a5 || (a6 & 1) == 0)
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Assert ");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "last_layer && finalize_layer");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v64);
    }
    v20 = *(_QWORD *)this;
    if (*(_BYTE *)(*(_QWORD *)this + 222))
    {
      v21 = 0;
      do
      {
        v22 = *((_QWORD *)this + 6) + 32 * v21;
        v23 = *(_DWORD *)(v22 + 16) * *(_DWORD *)(v22 + 20);
        if (v23 >= 1)
        {
          v24 = 0;
          v25 = (_QWORD *)(v22 + 24);
          v26 = 40 * v23;
          do
          {
            kd_block::trim_data((kd_block *)(*v25 + v24), a4, v14);
            v24 += 40;
          }
          while (v26 != v24);
          v20 = *(_QWORD *)this;
        }
        ++v21;
      }
      while (v21 < *(unsigned __int8 *)(v20 + 222));
      v58 = *(unsigned __int8 *)(v20 + 222);
    }
    else
    {
      v58 = 0;
    }
  }
  else
  {
    v58 = *(unsigned __int8 *)(*(_QWORD *)this + 222);
  }
  v27 = 0;
  while (1)
  {
    v28 = 7;
    if (!*(_BYTE *)(v57 + 284))
      v28 = 1;
    *a2 = v28;
    if (*(_BYTE *)(v57 + 285))
      *a2 = v28 + 2;
    if (*(_BYTE *)(*(_QWORD *)this + 222))
      break;
    v30 = 0;
LABEL_58:
    v63[0] = 0x800000000;
    v63[1] = 0;
    v63[2] = 0;
    kd_header_out::put_bit((unsigned __int8 *)v63, 1u);
    v43 = *(_QWORD *)this;
    if (*(_BYTE *)(*(_QWORD *)this + 222))
    {
      v44 = 0;
      do
      {
        v45 = *((_QWORD *)this + 6) + 32 * v44;
        v46 = *(_DWORD *)(v45 + 16) * *(_DWORD *)(v45 + 20);
        if (v46 >= 1)
        {
          v47 = 0;
          v48 = (_QWORD *)(v45 + 24);
          v49 = 40 * v46;
          do
          {
            kd_block::write_packet_header((unsigned __int8 *)(*v48 + v47), (kd_header_out *)v63, a3, 1);
            v47 += 40;
          }
          while (v49 != v47);
          v43 = *(_QWORD *)this;
        }
        ++v44;
      }
      while (v44 < *(unsigned __int8 *)(v43 + 222));
    }
    a2 = v61;
    v50 = *v61 + (int)(kd_header_out::finish((kd_header_out *)v63) - 1);
    *v61 = v50;
    result = v50 + v30;
    if (v50 + v30 > a7)
    {
      if (a5)
      {
        if (!a8)
        {
          v66 = 0;
          v64 = 0u;
          v65 = 0u;
          kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Assert ");
          (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "trim_to_limit");
          (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
          kdu_error::~kdu_error((kdu_error *)&v64);
        }
        v51 = v58;
        while (1)
        {
          v58 = v51;
          v52 = (int)v51;
          while (1)
          {
            v53 = *((_QWORD *)this + 6);
            if (!v27)
              break;
            if ((kd_block::trim_data((kd_block *)(*(_QWORD *)(v53 + 32 * v52 + 24) + 40 * --v27), (unsigned __int16)(a4 + 1), v14) & 1) != 0)goto LABEL_81;
          }
          if ((int)v58 <= 0)
          {
            v66 = 0;
            v64 = 0u;
            v65 = 0u;
            kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Assert ");
            (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "last_trimmed_subband >= 0");
            (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v64);
          }
          v51 = (v58 - 1);
          v27 = *(_DWORD *)(v53 + 32 * v52 - 16) * *(_DWORD *)(v53 + 32 * v52 - 12);
        }
      }
      return result;
    }
    if (a5 && *(_BYTE *)(*(_QWORD *)this + 222))
    {
      v54 = 0;
      v55 = 0;
      do
      {
        kd_block::save_output_tree(*(_QWORD *)(*((_QWORD *)this + 6) + v54 + 24), *(_QWORD *)(*((_QWORD *)this + 6) + v54 + 16));
        ++v55;
        v54 += 32;
      }
      while (v55 < *(unsigned __int8 *)(*(_QWORD *)this + 222));
LABEL_81:
      a2 = v61;
    }
    v56 = *a2 + v30;
    if (v56 <= a7)
    {
      *(_QWORD *)(*((_QWORD *)this + 5) + 8 * a3) = v56;
      return *a2 + v30;
    }
  }
  v29 = 0;
  v30 = 0;
  while (1)
  {
    v31 = *((_QWORD *)this + 6);
    v32 = v31 + 32 * v29;
    v35 = *(_QWORD *)(v32 + 24);
    v34 = (_QWORD *)(v32 + 24);
    v33 = v35;
    v36 = *(v34 - 1);
    if (a3)
      kd_block::restore_output_tree(v33, v36);
    else
      kd_block::reset_output_tree(v33, v36);
    v37 = *((_DWORD *)v34 - 2) * *(_DWORD *)(v31 + 32 * v29 + 20);
    if (v37 >= 1)
    {
      v38 = 0;
      v39 = 40 * v37;
      do
      {
        v30 += (int)kd_block::start_packet((kd_block *)(*v34 + v38), a3, a4);
        v38 += 40;
      }
      while (v39 != v38);
    }
    result = *v61 + v30;
    v41 = a5 ^ 1;
    if (result <= a7)
      v41 = 1;
    if ((v41 & 1) == 0 && (a8 & 1) == 0)
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Assert ");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "trim_to_limit");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v64);
    }
    if (result > a7 && a5 == 0)
      return result;
    if (++v29 >= (unint64_t)*(unsigned __int8 *)(*(_QWORD *)this + 222))
      goto LABEL_58;
  }
}

void sub_187EF7558(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EF7564(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Unwind_Exception *v19;

  _Unwind_Resume(v19);
}

unsigned __int8 *kd_header_out::put_bit(unsigned __int8 *this, unsigned int a2)
{
  char v2;
  char *v3;
  int v4;
  char v5;

  if (a2 >= 2)
    kd_header_out::put_bit();
  v2 = a2;
  v3 = (char *)this;
  v4 = *((_DWORD *)this + 1);
  if (v4)
  {
    v5 = 2 * *this;
  }
  else
  {
    this = (unsigned __int8 *)*((_QWORD *)this + 2);
    if (this)
      this = (unsigned __int8 *)kdu_output::put((kdu_output *)this, *v3);
    v5 = 0;
    ++*((_DWORD *)v3 + 2);
    if (*v3 == 255)
      v4 = 7;
    else
      v4 = 8;
  }
  *v3 = v5 + v2;
  *((_DWORD *)v3 + 1) = v4 - 1;
  return this;
}

uint64_t kd_header_out::finish(kd_header_out *this)
{
  int v2;
  int v3;
  kdu_output *v4;
  uint64_t result;

  v2 = *((_DWORD *)this + 1);
  if (v2 >= 8)
    return *((unsigned int *)this + 2);
  v3 = *(unsigned __int8 *)this << v2;
  *(_BYTE *)this = v3;
  v4 = (kdu_output *)*((_QWORD *)this + 2);
  if (v4)
  {
    kdu_output::put(v4, v3);
    LOBYTE(v3) = *(_BYTE *)this;
  }
  result = (*((_DWORD *)this + 2) + 1);
  *((_DWORD *)this + 2) = result;
  if ((_BYTE)v3 == 0xFF)
  {
    if (*((_QWORD *)this + 2))
    {
      kdu_output::put(*((kdu_output **)this + 2), 0);
      LODWORD(result) = *((_DWORD *)this + 2);
    }
    result = (result + 1);
    *((_DWORD *)this + 2) = result;
  }
  return result;
}

uint64_t *kd_precinct_ref::close(uint64_t *this)
{
  uint64_t v1;
  BOOL v2;
  uint64_t *v3;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v1 = *this;
  if (*this)
    v2 = (*this & 1) == 0;
  else
    v2 = 0;
  if (v2)
  {
    v3 = this;
    if (*(uint64_t **)(v1 + 8) != this)
    {
      v6 = 0;
      memset(v5, 0, sizeof(v5));
      kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "Assert ");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "precinct->ref == this");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v5);
    }
    *(_QWORD *)(v1 + 8) = 0;
    kd_precinct::closing((unsigned __int8 **)v1);
    if (*(_BYTE *)(v1 + 18))
      v4 = (2 * *(_QWORD *)(v1 + 40)) | 1;
    else
      v4 = 3;
    *v3 = v4;
    return (uint64_t *)kd_precinct_size_class::release(*(kd_precinct_size_class **)(v1 + 72), (kd_precinct *)v1);
  }
  return this;
}

void sub_187EF77D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF77DC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

_QWORD *kd_precinct_size_class::augment_free_list(kd_precinct_size_class *this)
{
  int v2;
  _QWORD *result;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v2 = *((_DWORD *)this + 6);
  if (v2 < 0)
  {
    v7 = 0;
    v5 = 0u;
    v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "Heap exhausted.  Unable to allocate memory for code-block state information.");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  result = malloc_type_malloc(v2, 0x1BBB2766uLL);
  if (!result)
  {
    v7 = 0;
    v5 = 0u;
    v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "Heap exhausted.  Unable to allocate sufficient memory for code-block state information.");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  result[9] = this;
  result[7] = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = result;
  v4 = *((int *)this + 6);
  ++*((_DWORD *)this + 7);
  *(_QWORD *)(*(_QWORD *)this + 8) += v4;
  return result;
}

void sub_187EF78D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF78E4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t *kd_precinct_size_class::move_to_inactive_list(uint64_t *this, kd_precinct *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _OWORD v5[2];
  uint64_t v6;

  if (*((_QWORD *)a2 + 8) || *((_QWORD *)a2 + 7) || *((_BYTE *)a2 + 20))
  {
    v6 = 0;
    memset(v5, 0, sizeof(v5));
    kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "(precinct->prev == NULL) && (precinct->next == NULL) && !precinct->inactive");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v5);
  }
  *((_BYTE *)a2 + 20) = 1;
  v2 = *this;
  v3 = *(_QWORD *)(*this + 24);
  *((_QWORD *)a2 + 8) = v3;
  if (v3)
    v4 = (_QWORD *)(v3 + 56);
  else
    v4 = (_QWORD *)(v2 + 16);
  *v4 = a2;
  *(_QWORD *)(v2 + 24) = a2;
  return this;
}

void sub_187EF79D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF79E4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_precinct_size_class::withdraw_from_inactive_list(uint64_t this, kd_precinct *a2)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  if (!*((_BYTE *)a2 + 20))
  {
    v6 = 0;
    v4 = 0u;
    v5 = 0u;
    kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v4 + 16))(&v4, "Assert ");
    (*(void (**)(__int128 *, const char *))(v4 + 16))(&v4, "precinct->inactive");
    (*(void (**)(__int128 *, const char *))(v4 + 16))(&v4, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v4);
  }
  v2 = *((_QWORD *)a2 + 8);
  if (v2)
  {
    *(_QWORD *)(v2 + 56) = *((_QWORD *)a2 + 7);
    v3 = *((_QWORD *)a2 + 7);
    if (v3)
    {
LABEL_5:
      *(_QWORD *)(v3 + 64) = *((_QWORD *)a2 + 8);
      goto LABEL_12;
    }
  }
  else
  {
    if (*(kd_precinct **)(*(_QWORD *)this + 16) != a2)
    {
      v6 = 0;
      v4 = 0u;
      v5 = 0u;
      kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v4 + 16))(&v4, "Assert ");
      (*(void (**)(__int128 *, const char *))(v4 + 16))(&v4, "precinct == server->inactive_head");
      (*(void (**)(__int128 *, const char *))(v4 + 16))(&v4, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v4);
    }
    v3 = *((_QWORD *)a2 + 7);
    *(_QWORD *)(*(_QWORD *)this + 16) = v3;
    if (v3)
      goto LABEL_5;
  }
  if (*(kd_precinct **)(*(_QWORD *)this + 24) != a2)
  {
    v6 = 0;
    v4 = 0u;
    v5 = 0u;
    kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v4 + 16))(&v4, "Assert ");
    (*(void (**)(__int128 *, const char *))(v4 + 16))(&v4, "precinct == server->inactive_tail");
    (*(void (**)(__int128 *, const char *))(v4 + 16))(&v4, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v4);
  }
  *(_QWORD *)(*(_QWORD *)this + 24) = *((_QWORD *)a2 + 8);
LABEL_12:
  *((_BYTE *)a2 + 20) = 0;
  *((_QWORD *)a2 + 7) = 0;
  *((_QWORD *)a2 + 8) = 0;
  return this;
}

void sub_187EF7BCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF7BD8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_precinct_server::get(kd_precinct_server *this, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  _OWORD v10[2];
  uint64_t v11;

  v6 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    while (*(_DWORD *)(v6 + 16) != a2 || *(_DWORD *)(v6 + 20) != a3)
    {
      v6 = *(_QWORD *)(v6 + 40);
      if (!v6)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v6 = operator new();
    v7 = *((_QWORD *)this + 4);
    *(_DWORD *)(v6 + 16) = a2;
    *(_DWORD *)(v6 + 20) = a3;
    *(_QWORD *)v6 = this;
    *(_QWORD *)(v6 + 8) = v7;
    *(_QWORD *)(v6 + 28) = 0;
    *(_DWORD *)(v6 + 36) = 0;
    *(_DWORD *)(v6 + 24) = 40 * a2 + 32 * a3 + 84;
    *(_QWORD *)(v6 + 40) = *(_QWORD *)this;
    *(_QWORD *)this = v6;
  }
  for (i = *((_QWORD *)this + 2); i; i = *((_QWORD *)this + 2))
  {
    if (*(_QWORD *)(*((_QWORD *)this + 4) + 56) >= *(_QWORD *)(*((_QWORD *)this + 4) + 40)
                                                    + 220 * *(_QWORD *)(*((_QWORD *)this + 4) + 24))
      break;
    if (!*(_BYTE *)(i + 19) || !*(_BYTE *)(i + 20))
    {
      v11 = 0;
      memset(v10, 0, sizeof(v10));
      kdu_error::kdu_error((kdu_error *)v10, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v10[0] + 16))(v10, "Assert ");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v10[0] + 16))(v10, "tmp->released && tmp->inactive");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v10[0] + 16))(v10, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v10);
    }
    kd_precinct_ref::close(*(uint64_t **)(i + 8));
  }
  return kd_precinct_size_class::get((kd_precinct_size_class *)v6);
}

void sub_187EF7D8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF7D98()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_precinct_size_class::get(kd_precinct_size_class *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 4);
  if (!v2)
  {
    kd_precinct_size_class::augment_free_list(this);
    v2 = *((_QWORD *)this + 4);
  }
  *((_QWORD *)this + 4) = *(_QWORD *)(v2 + 56);
  *(_QWORD *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  kd_buf_server::augment_structure_bytes(*((_QWORD *)this + 1), *((_DWORD *)this + 6));
  return v2;
}

uint64_t kd_precinct_ref::instantiate_precinct(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  v6 = kd_precinct_server::get(*(kd_precinct_server **)(*(_QWORD *)a2 + 80), *(_DWORD *)(a2 + 216), *(unsigned __int8 *)(a2 + 222));
  kd_precinct::initialize(v6, (uint64_t *)a2, a3);
  *(_QWORD *)(v6 + 8) = a1;
  v7 = *a1;
  if ((*a1 & 1) != 0)
  {
    *(_BYTE *)(v6 + 18) = 1;
    *(_QWORD *)(v6 + 40) = v7 >> 1;
    *a1 = v6;
    if ((v6 & 1) != 0)
    {
      v17 = 0;
      v15 = 0u;
      v16 = 0u;
      kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "Assert ");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "!(state & 1)");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v15);
    }
    if (!*(_BYTE *)(*(_QWORD *)a2 + 415))
    {
      if (*(int *)(v6 + 36) <= 0)
      {
        v17 = 0;
        v15 = 0u;
        v16 = 0u;
        kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "Assert ");
        (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "result->num_outstanding_blocks > 0");
        (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v15);
      }
      *(_BYTE *)(v6 + 17) = 1;
      v10 = *(int **)(*(_QWORD *)(a2 + 8) + 8);
      goto LABEL_19;
    }
  }
  else
  {
    if (v7)
    {
      v17 = 0;
      v15 = 0u;
      v16 = 0u;
      kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "Assert ");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "state == 0");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v15);
    }
    *a1 = v6;
    if ((v6 & 1) != 0)
    {
      v17 = 0;
      v15 = 0u;
      v16 = 0u;
      kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "Assert ");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "!(state & 1)");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v15);
    }
    v8 = *(_QWORD *)a2;
    if (*(_BYTE *)(*(_QWORD *)a2 + 418) || *(_BYTE *)(v8 + 415))
    {
      v9 = *(_QWORD *)(a2 + 8);
      v10 = *(int **)(v9 + 8);
      v11 = HIDWORD(a3) + *(_DWORD *)(a2 + 196) * (int)a3;
      if (*(_BYTE *)(a2 + 24))
      {
        v12 = -704 * *(unsigned __int8 *)(a2 + 24);
        do
        {
          v11 += *(int *)(a2 + v12 + 192) * (uint64_t)*(int *)(a2 + v12 + 196);
          v12 += 704;
        }
        while (v12);
      }
      v13 = v10[2] + (*(int *)(v9 + 24) + v11 * v10[47]) * *(int *)(v8 + 224) * *(int *)(v8 + 220);
      *(_BYTE *)(v6 + 18) = 1;
      *(_QWORD *)(v6 + 40) = ~v13;
      if (!*(_BYTE *)(*(_QWORD *)a2 + 415))
      {
        *(_BYTE *)(v6 + 17) = 1;
LABEL_19:
        *(_DWORD *)(v6 + 28) = v10[48];
      }
    }
  }
  return v6;
}

void sub_187EF80EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF80F8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_precinct_size_class::release(kd_precinct_size_class *this, kd_precinct *a2)
{
  if (*((_BYTE *)a2 + 20))
    kd_precinct_size_class::withdraw_from_inactive_list((uint64_t)this, a2);
  *((_QWORD *)a2 + 7) = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = a2;
  return kd_buf_server::augment_structure_bytes(*((_QWORD *)this + 1), -*((_DWORD *)this + 6));
}

BOOL kd_precinct_ref::set_address(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  kd_tile *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  if (a4 <= 0)
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "seek_address > 0");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(kd_tile **)(v4 + 8);
  v6 = *a1;
  if (*a1)
    v7 = (*a1 & 1) == 0;
  else
    v7 = 0;
  if (!v7)
  {
    v8 = *(_QWORD *)v5;
    *a1 = (2 * a4) | 1;
    if (!*(_BYTE *)(v8 + 417))
    {
      if (*(_DWORD *)(v4 + 72) < (int)*(unsigned __int8 *)(a2 + 24))
        return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
      if (!*(_BYTE *)(v4 + 184))
        return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
      v9 = *(_DWORD *)(a2 + 188) + HIDWORD(a3);
      v10 = *(_DWORD *)(a2 + 204);
      if (v9 < v10)
        return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
      v11 = *(_DWORD *)(a2 + 184) + a3;
      v12 = *(_DWORD *)(a2 + 200);
      if (v11 < v12 || v9 >= *(_DWORD *)(a2 + 212) + v10 || v11 >= *(_DWORD *)(a2 + 208) + v12)
        return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
    }
LABEL_18:
    *((_DWORD *)v5 + 77) += *((_DWORD *)v5 + 50);
    return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
  }
  if (*(_DWORD *)(v6 + 28))
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "precinct->next_layer_idx == 0");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  *(_DWORD *)(v6 + 28) = *((_DWORD *)v5 + 48);
  *(_BYTE *)(v6 + 18) = 1;
  *(_QWORD *)(v6 + 40) = a4;
  kd_precinct::finished_desequencing((uint64_t *)v6);
  if (*(_BYTE *)(v6 + 21))
    goto LABEL_18;
  return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
}

void sub_187EF83A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187EF83AC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t *kd_precinct_pointer_server::disable(uint64_t *this)
{
  uint64_t *i;
  uint64_t *v2;

  if (*this)
  {
    for (i = this; ; this = (uint64_t *)kd_buf_server::release(*i, (uint64_t)v2))
    {
      v2 = (uint64_t *)i[1];
      i[2] = (uint64_t)v2;
      if (!v2)
        break;
      i[1] = *v2;
    }
    *i = 0;
  }
  return this;
}

void kd_mct_stage::~kd_mct_stage(kd_mct_stage *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *((_QWORD *)this + 1);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8052888210);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1020C806B39A6A2);
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    v5 = v4 - 16;
    v6 = *(_QWORD *)(v4 - 8);
    if (v6)
    {
      v7 = v4 - 152;
      v8 = 152 * v6;
      do
      {
        kd_mct_block::~kd_mct_block((kd_mct_block *)(v7 + v8));
        v8 -= 152;
      }
      while (v8);
    }
    MEMORY[0x18D761C18](v5, 0x10B0C80C861A3ACLL);
  }
}

void kd_mct_block::~kd_mct_block(kd_mct_block *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = *((_QWORD *)this + 2);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8052888210);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8077774924);
  v4 = *((_QWORD *)this + 5);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1000C8052888210);
  v5 = *((_QWORD *)this + 13);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C80451B5BE8);
  v6 = *((_QWORD *)this + 14);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x1000C8052888210);
  v7 = *((_QWORD *)this + 18);
  if (v7)
    MEMORY[0x18D761C18](v7, 0x1000C8052888210);
  v8 = *((_QWORD *)this + 6);
  if (v8)
  {
    v11 = *(_QWORD *)(v8 - 8);
    v10 = v8 - 8;
    v9 = v11;
    if (v11)
    {
      v12 = 24 * v9;
      do
      {
        v13 = *(_QWORD *)(v10 + v12);
        if (v13)
          MEMORY[0x18D761C18](v13, 0x1000C8052888210);
        v12 -= 24;
      }
      while (v12);
    }
    MEMORY[0x18D761C18](v10 - 8, 0x1080C80C4643742);
  }
}

void kd_resolution::~kd_resolution(kd_resolution *this)
{
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v2 = *((_QWORD *)this + 20);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8052888210);
  v3 = *((unsigned __int8 *)this + 223);
  if (*((_BYTE *)this + 223))
  {
    v4 = 0;
    v5 = 128;
    do
    {
      v6 = *(_QWORD *)(*((_QWORD *)this + 28) + v5);
      if (v6)
      {
        MEMORY[0x18D761C18](v6, 0x1000C8052888210);
        v3 = *((unsigned __int8 *)this + 223);
      }
      ++v4;
      v5 += 136;
    }
    while (v4 < v3);
  }
  v7 = *((_QWORD *)this + 29);
  if (v7)
  {
    v10 = *(_QWORD *)(v7 - 8);
    v9 = v7 - 8;
    v8 = v10;
    if (v10)
    {
      v11 = 8 * v8;
      do
      {
        kd_precinct_ref::~kd_precinct_ref((kd_precinct_ref *)(v9 + v11));
        v11 -= 8;
      }
      while (v11);
    }
    MEMORY[0x18D761C18](v9 - 8, 0x1000C8000313F17);
  }
  v12 = *((_QWORD *)this + 31);
  if (v12)
    MEMORY[0x18D761C18](v12, 0x1020C8068AD3B9FLL);
  v13 = *((_QWORD *)this + 28);
  if (v13)
    MEMORY[0x18D761C18](v13, 0x10A0C80A1ACF372);
}

void kd_precinct_ref::~kd_precinct_ref(kd_precinct_ref *this)
{
  BOOL v1;

  if (*(_QWORD *)this)
    v1 = (*(_QWORD *)this & 1) == 0;
  else
    v1 = 0;
  if (v1)
    kd_precinct_ref::close((uint64_t *)this);
}

uint64_t _cg_JP2ResetSource(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 56);
  _cg_JP2TearDownJP2Storage((_QWORD *)a1);
  OpenJP2Input(a1, (_QWORD *)v2);
  kdu_region_compositor::add_compositing_layer(*(_QWORD *)(v2 + 24), 0, 0, 0, 0, 0, 0, 0, 0, 0, 2);
  kdu_region_compositor::set_scale(*(_QWORD *)(v2 + 24), 0, 0, 0, *(float *)(v2 + 48));
  if (*(_BYTE *)(a1 + 179))
    kdu_region_compositor::set_single_component(*(kdu_region_compositor **)(v2 + 24), 0, 1, 1u);
  return 0;
}

void sub_187EF87C8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187EF87B8);
}

_QWORD *_cg_JP2TearDownJP2Storage(_QWORD *result)
{
  _QWORD *v1;
  jp2_family_src *v2;
  uint64_t v3;
  uint64_t v4;

  v1 = (_QWORD *)result[7];
  if (v1)
  {
    v2 = (jp2_family_src *)v1[1];
    if (v2)
      jp2_family_src::close(v2);
    v3 = v1[2];
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    if (*v1)
      (*(void (**)(_QWORD))(*(_QWORD *)*v1 + 8))(*v1);
    v4 = v1[3];
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    result = (_QWORD *)v1[1];
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  return result;
}

uint64_t OpenJP2Input(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  jpx_source *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;

  v4 = (_QWORD *)operator new();
  *v4 = &off_1E1BABE58;
  v4[1] = a1;
  *a2 = v4;
  v4[2] = 0;
  (*(void (**)(_QWORD, _QWORD))(a1 + 32))(*(_QWORD *)a1, *(_QWORD *)(a1 + 16));
  v5 = operator new();
  *(_QWORD *)v5 = &off_1E1BAFFE8;
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_QWORD *)(v5 + 40) = -1;
  *(_QWORD *)(v5 + 48) = -1;
  *(_QWORD *)(v5 + 56) = -1;
  *(_DWORD *)(v5 + 64) = -1;
  *(_DWORD *)(v5 + 72) = 0;
  *(_BYTE *)(v5 + 68) = 0;
  a2[1] = v5;
  v6 = (jpx_source *)operator new();
  jpx_source::jpx_source(v6);
  a2[2] = v6;
  jp2_family_src::open((jp2_family_src *)a2[1], (kdu_compressed_source *)*a2);
  v7 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)a2[2] + 16))(a2[2], a2[1], 1);
  if ((v7 & 0x80000000) != 0)
  {
    jp2_family_src::close((jp2_family_src *)a2[1]);
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 40))(*a2, 0);
    v9 = operator new();
    kdu_region_compositor::kdu_region_compositor(v9, 0, 0);
    *(_QWORD *)v9 = &off_1E1BB17F8;
    *(_OWORD *)(v9 + 536) = 0u;
    a2[3] = v9;
    kdu_region_compositor::create(v9, (kdu_compressed_source *)*a2, 256000);
  }
  else
  {
    v8 = operator new();
    kdu_region_compositor::kdu_region_compositor(v8, 0, 0);
    *(_QWORD *)v8 = &off_1E1BB17F8;
    *(_OWORD *)(v8 + 536) = 0u;
    a2[3] = v8;
    kdu_region_compositor::create(v8, (jpx_source *)a2[2], 256000);
  }
  return v7 >> 31;
}

void sub_187EF8A28(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C4077C1191CLL);
  _Unwind_Resume(a1);
}

uint64_t JP2SetOptimalScalingFactor(_QWORD *a1)
{
  uint64_t v2;
  float v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  double v7;
  float v9;
  uint64_t total_composition_dims;
  __int128 v12;

  v2 = a1[7];
  v3 = 1.0;
  kdu_region_compositor::set_scale(*(_QWORD *)(v2 + 24), 0, 0, 0, 1.0);
  v12 = 0uLL;
  kdu_region_compositor::get_total_composition_dims(*(kdu_region_compositor **)(v2 + 24), (kdu_dims *)&v12);
  v4 = a1[20];
  v5 = a1[21];
  if (v5 >= 2)
  {
    do
    {
      v3 = v3 * 0.5;
      v6 = v5 > 3;
      v5 >>= 1;
    }
    while (v6);
  }
  if (v4 >= 0x10)
  {
    v7 = (double)v4;
    while ((float)(v3 * (float)(unint64_t)SHIDWORD(v12)) * 0.5 >= v7
         || (float)(v3 * (float)(unint64_t)SDWORD2(v12)) * 0.5 >= v7)
      v3 = v3 * 0.5;
  }
  v9 = 0.015625;
  if (v3 >= 0.015625)
    v9 = v3;
  *(float *)(v2 + 48) = v9;
  while (1)
  {
    kdu_region_compositor::set_scale(*(_QWORD *)(v2 + 24), 0, 0, 0, v9);
    total_composition_dims = kdu_region_compositor::get_total_composition_dims(*(kdu_region_compositor **)(v2 + 24), (kdu_dims *)(v2 + 32));
    if ((total_composition_dims & 1) != 0)
      break;
    v9 = *(float *)(v2 + 48) + *(float *)(v2 + 48);
    *(float *)(v2 + 48) = v9;
    if (v9 > 1.0)
    {
      *(_OWORD *)(v2 + 32) = v12;
      fwrite("get_total_composition_dims never succeeded\n", 0x2BuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      return total_composition_dims;
    }
  }
  return total_composition_dims;
}

uint64_t _cg_JP2SetupDecompressor(uint64_t a1, uint64_t a2)
{
  int *v4;
  int *next_codestream;
  uint64_t v6;
  int v7;
  int v8;
  int space;
  const UInt8 *icc_profile;
  int v11;
  const void *v12;
  _BOOL4 has_opacity;
  _BOOL4 has_premultiplied_opacity;
  BOOL v15;
  unsigned int v16;
  int v17;
  int v18;
  int num_luts;
  kdrc_stream *v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  _DWORD *exception;
  uint64_t v25;
  int v26[2];
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v4 = (int *)malloc_type_calloc(0x38uLL, 1uLL, 0x628993D8uLL);
  *(_QWORD *)(a2 + 56) = v4;
  LOBYTE(a1) = OpenJP2Input(a1, v4);
  kdu_region_compositor::add_compositing_layer(*((_QWORD *)v4 + 3), 0, 0, 0, 0, 0, 0, 0, 0, 0, 2);
  if ((a1 & 1) != 0)
  {
    next_codestream = (int *)kdu_region_compositor::get_next_codestream(*((kdu_region_compositor **)v4 + 3), 0, 1, 1);
    kdu_region_compositor::access_codestream(*((kdu_region_compositor **)v4 + 3), (kdrc_stream *)next_codestream);
    v6 = next_codestream[16];
    *(_QWORD *)(a2 + 88) = v6;
    *(_QWORD *)(a2 + 120) = v6;
    if (v6 >= 3)
      v7 = 16;
    else
      v7 = 17;
    *(_DWORD *)(a2 + 80) = v7;
    if (*(_BYTE *)(a2 + 177) && v6 >= 3)
    {
      *(_DWORD *)(a2 + 108) = 5;
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  v30 = 0;
  v30 = jpx_source::access_layer(*((jpx_source **)v4 + 2), 0, 1);
  if (!v30)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v8 = 0;
  v28 = 0;
  v29 = jpx_layer_source::access_channels((jpx_layer_source *)&v30);
  v27 = 0;
  while (1)
  {
    v27 = jpx_layer_source::access_colour((jpx_layer_source *)&v30, v8);
    if (!v27)
      break;
    space = jp2_colour::get_space((jp2_colour *)&v27);
    if (!v8 || space == 102 || space == 101 || space == 100)
    {
      v28 = v27;
      *(_DWORD *)(a2 + 80) = space;
      *(_QWORD *)(a2 + 88) = (int)jp2_colour::get_num_colours((jp2_colour *)&v28);
      v26[0] = 0;
      icc_profile = (const UInt8 *)jp2_colour::get_icc_profile((jp2_colour *)&v28, v26);
      v11 = v26[0];
      *(_DWORD *)(a2 + 104) = v26[0];
      if (icc_profile)
      {
        v12 = *(const void **)(a2 + 96);
        if (v12)
        {
          CFRelease(v12);
          v11 = v26[0];
        }
        *(_QWORD *)(a2 + 96) = CFDataCreate(0, icc_profile, v11);
      }
    }
    ++v8;
  }
  has_opacity = jp2_channels::has_opacity((jp2_channels *)&v29);
  has_premultiplied_opacity = jp2_channels::has_premultiplied_opacity((jp2_channels *)&v29);
  v15 = has_premultiplied_opacity;
  v16 = has_opacity || has_premultiplied_opacity;
  v17 = *(_DWORD *)(a2 + 80);
  if (v17 == 100 || v17 == 17)
  {
    *(_BYTE *)(a2 + 177) = 0;
LABEL_23:
    v18 = 0;
    goto LABEL_26;
  }
  if (!*(_BYTE *)(a2 + 177))
    goto LABEL_23;
  v18 = 5;
LABEL_26:
  if (v16)
    v18 = 3;
  if (has_premultiplied_opacity)
    v18 = 1;
  *(_DWORD *)(a2 + 108) = v18;
  *(_QWORD *)(a2 + 120) = (int)jp2_channels::get_num_colours((jp2_channels *)&v29) + (unint64_t)v16;
  *(_BYTE *)(a2 + 176) = v15;
  *(_QWORD *)v26 = 0;
  *(_QWORD *)v26 = jpx_source::access_codestream(*((jpx_source **)v4 + 2), 0, 1);
  if (*(_QWORD *)v26)
  {
    v25 = jpx_codestream_source::access_palette((jpx_codestream_source *)v26);
    if (v25)
    {
      num_luts = jp2_palette::get_num_luts((jp2_palette *)&v25);
      if (num_luts >= 1 && (int)jp2_palette::get_num_entries((jp2_palette *)&v25) <= 256)
      {
        *(_QWORD *)(a2 + 120) = 1;
        *(_QWORD *)(a2 + 88) = num_luts;
        *(_BYTE *)(a2 + 179) = 1;
        if (v16)
        {
          *(_QWORD *)(a2 + 120) = 0;
          *(_BYTE *)(a2 + 176) = 0;
LABEL_36:
          *(_DWORD *)(a2 + 108) = 0;
        }
      }
    }
  }
LABEL_37:
  v20 = (kdrc_stream *)kdu_region_compositor::get_next_codestream(*((kdu_region_compositor **)v4 + 3), 0, 1, 1);
  kdu_region_compositor::access_codestream(*((kdu_region_compositor **)v4 + 3), v20);
  if (*(_BYTE *)(a2 + 179))
    kdu_region_compositor::set_single_component(*((kdu_region_compositor **)v4 + 3), 0, 1, 1u);
  result = JP2SetOptimalScalingFactor((_QWORD *)a2) - 1;
  v22 = v4[11];
  *(_QWORD *)(a2 + 64) = v22;
  *(_QWORD *)(a2 + 72) = v4[10];
  *(_QWORD *)(a2 + 112) = 8;
  if (*(_BYTE *)(a2 + 177))
    v23 = 32;
  else
    v23 = 8 * *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 128) = v23;
  *(_QWORD *)(a2 + 136) = (unint64_t)(v23 * v22) >> 3;
  return result;
}

void sub_187EF8F18(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  jp2_family_src::close(*(jp2_family_src **)(v1 + 8));
  __cxa_end_catch();
  JUMPOUT(0x187EF8EE0);
}

void sub_187EF8F6C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t _cg_JP2DecompressBlock(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  uint64_t v10;
  const UInt8 *BytePtr;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  const char *v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  int v21;
  uint64_t v22;
  const __CFData *v23;
  _QWORD v25[2];

  v10 = *(_QWORD *)(a1 + 56);
  BytePtr = *(const UInt8 **)(a1 + 152);
  if (!BytePtr)
  {
    v23 = *(const __CFData **)(a1 + 144);
    if (!v23)
      goto LABEL_23;
    BytePtr = CFDataGetBytePtr(v23);
    if (!BytePtr)
      goto LABEL_23;
  }
  v12 = *(_QWORD *)(a1 + 128);
  v25[0] = 0;
  v25[1] = 0;
  if ((a2 & 0x80000000) != 0 || (v13 = *(_QWORD *)(a1 + 64), v13 < (int)a4 + (int)a2))
  {
    v15 = "origin_x >= 0 && origin_x + size_x <= info->width";
    v16 = 692;
    goto LABEL_28;
  }
  if ((a3 & 0x80000000) != 0 || (v14 = *(_QWORD *)(a1 + 72), v14 < (int)(a5 + a3)))
  {
    v15 = "origin_y >= 0 && origin_y + size_y <= info->height";
    v16 = 693;
    goto LABEL_28;
  }
  v15 = "size_x > 0 && size_x <= info->width";
  v16 = 694;
  if ((int)a4 < 1 || v13 < (int)a4)
LABEL_28:
    __assert_rtn("_cg_JP2DecompressBlock", "JP2LibDecompress.cpp", v16, v15);
  if (a5 < 1 || v14 < a5)
  {
    v15 = "size_y > 0 && size_y <= info->height";
    v16 = 695;
    goto LABEL_28;
  }
  if (!v10)
    abort();
  v17 = v12 >> 3;
  v18 = *(_QWORD *)(v10 + 24);
  *(_QWORD *)(v18 + 536) = BytePtr;
  *(_DWORD *)(v18 + 548) = a4;
  *(_DWORD *)(v18 + 544) = v17;
  kdu_region_compositor::set_buffer_surface(v18, a3 | (unint64_t)(a2 << 32), a5 | (unint64_t)(a4 << 32), -1);
  *(_QWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  v19 = (a5 * a4 * v17);
  while (1)
  {
    v20 = *(_BYTE **)(v10 + 24);
    if (v20[428])
    {
      if (!v20[429])
        break;
    }
    if (((*(uint64_t (**)(_BYTE *, uint64_t, _QWORD *))(*(_QWORD *)v20 + 32))(v20, v19, v25) & 1) == 0)
      break;
    v21 = *(unsigned __int8 *)(a1 + 178);
    if (*(_BYTE *)(a1 + 178))
    {
      if (*(_DWORD *)(a1 + 48))
        v21 = -1;
      else
        v21 = 0;
    }
    if (v21)
    {
      v22 = 0xFFFFFFFFLL;
      goto LABEL_24;
    }
  }
LABEL_23:
  v22 = 0;
LABEL_24:
  kdu_region_compositor::reset(*(_QWORD **)(v10 + 24));
  *(_OWORD *)(*(_QWORD *)(v10 + 24) + 536) = 0u;
  return v22;
}

void sub_187EF9148(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187EF90A8);
}

void _cg_JP2TearDownDecompressor(_QWORD *a1)
{
  void *v2;
  const void *v3;

  v2 = (void *)a1[7];
  if (v2)
  {
    _cg_JP2TearDownJP2Storage(a1);
    free(v2);
  }
  v3 = (const void *)a1[18];
  if (v3)
    CFRelease(v3);
}

void _cg_JP2GetDisplayResolution(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = 1116733440;
  *a3 = 1116733440;
}

_BYTE *_cg_JP2GetPalette(uint64_t a1, unsigned int a2, int *a3, _DWORD *a4)
{
  uint64_t v4;
  int num_entries;
  unsigned int num_luts;
  uint64_t v10;
  unsigned int v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  unsigned __int16 *v17;
  _BYTE *v18;
  int v19;
  uint64_t v21;
  uint64_t v22;

  *a3 = 0;
  *a4 = 0;
  if (!a1)
    return 0;
  if (!*(_BYTE *)(a1 + 179))
    return 0;
  v4 = *(_QWORD *)(a1 + 56);
  if (!v4)
    return 0;
  v22 = jpx_source::access_codestream(*(jpx_source **)(v4 + 16), 0, 1);
  if (!v22)
    return 0;
  v21 = jpx_codestream_source::access_palette((jpx_codestream_source *)&v22);
  if (!v21)
    return 0;
  num_entries = jp2_palette::get_num_entries((jp2_palette *)&v21);
  num_luts = jp2_palette::get_num_luts((jp2_palette *)&v21);
  if ((int)num_luts >= (int)a2)
    v10 = a2;
  else
    v10 = num_luts;
  if ((int)v10 >= 1)
  {
    v11 = 0;
    while ((int)jp2_palette::get_bit_depth((jp2_palette *)&v21, v11) <= 8)
    {
      if ((_DWORD)v10 == ++v11)
        goto LABEL_13;
    }
    return 0;
  }
LABEL_13:
  *a3 = num_entries;
  *a4 = v10;
  v12 = malloc_type_malloc((int)v10 * num_entries, 0xE4D35983uLL);
  if (v12)
  {
    v13 = operator new[]();
    if ((int)v10 >= 1)
    {
      v14 = 0;
      v15 = v12;
      do
      {
        jp2_palette::get_lut(&v21, v14, v13);
        v16 = num_entries;
        v17 = (unsigned __int16 *)v13;
        v18 = v15;
        if (num_entries >= 1)
        {
          do
          {
            v19 = *v17++;
            *v18 = (v19 + 4096) >> 5;
            v18 += v10;
            --v16;
          }
          while (v16);
        }
        ++v14;
        ++v15;
      }
      while (v14 != v10);
    }
    MEMORY[0x18D761C18](v13, 0x1000C80BDFB0063);
  }
  return v12;
}

void MyJP2Source::~MyJP2Source(MyJP2Source *this)
{
  *(_QWORD *)this = off_1E1BB2340;
}

{
  *(_QWORD *)this = off_1E1BB2340;
  JUMPOUT(0x18D761C30);
}

uint64_t kdu_compressed_source::close(kdu_compressed_source *this)
{
  return 1;
}

uint64_t MyJP2Source::get_capabilities(MyJP2Source *this)
{
  return 3;
}

uint64_t MyJP2Source::read(MyJP2Source *this, unsigned __int8 *a2, int a3)
{
  uint64_t v5;
  uint64_t result;

  v5 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 2) += a3;
  result = (*(uint64_t (**)(_QWORD, unsigned __int8 *, _QWORD))(v5 + 24))(*(_QWORD *)v5, a2, a3);
  if ((int)result < a3)
    *(_DWORD *)(*((_QWORD *)this + 1) + 48) = -1;
  return result;
}

uint64_t MyJP2Source::seek(MyJP2Source *this, uint64_t a2)
{
  *((_QWORD *)this + 2) = a2;
  (*(void (**)(_QWORD, uint64_t))(*((_QWORD *)this + 1) + 32))(**((_QWORD **)this + 1), *(_QWORD *)(*((_QWORD *)this + 1) + 16) + a2);
  return 1;
}

uint64_t kdu_compressed_source::get_pos(kdu_compressed_source *this)
{
  return -1;
}

uint64_t kdu_compressed_source::set_tileheader_scope(kdu_compressed_source *this)
{
  return 0;
}

uint64_t kdu_compressed_source::set_precinct_scope(kdu_compressed_source *this)
{
  return 0;
}

uint64_t kdu_compressed_source::get_capabilities(kdu_compressed_source *this)
{
  return 1;
}

uint64_t kdu_compressed_source::seek(kdu_compressed_source *this)
{
  return 0;
}

void jp2_family_src::~jp2_family_src(jp2_family_src *this)
{
  *(_QWORD *)this = &off_1E1BAFFE8;
  jp2_family_src::close(this);
}

{
  *(_QWORD *)this = &off_1E1BAFFE8;
  jp2_family_src::close(this);
  JUMPOUT(0x18D761C30);
}

void MyRegionCompositor::~MyRegionCompositor(MyRegionCompositor *this)
{
  MyRegionCompositor::~MyRegionCompositor(this);
  JUMPOUT(0x18D761C30);
}

{
  *(_QWORD *)this = &off_1E1BB17F8;
  kdu_region_compositor::pre_destroy(this);
  *(_OWORD *)((char *)this + 536) = 0u;
  kdu_region_compositor::~kdu_region_compositor(this);
}

uint64_t kdu_region_compositor::custom_paint_overlay()
{
  return 0;
}

uint64_t MyRegionCompositor::allocate_buffer(uint64_t a1)
{
  uint64_t result;

  if (!*(_QWORD *)(a1 + 536))
    return 0;
  result = operator new();
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_QWORD *)result = &off_1E1BB0AB8;
  *(_QWORD *)(result + 32) = *(_QWORD *)(a1 + 536);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a1 + 544);
  return result;
}

uint64_t MyRegionCompositor::delete_buffer(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
  return result;
}

void kdu_region_compositor::~kdu_region_compositor(kdu_region_compositor *this)
{
  *(_QWORD *)this = &off_1E1BB23E0;
  kdu_region_compositor::pre_destroy(this);
  jpx_input_box::~jpx_input_box((kdu_region_compositor *)((char *)this + 32));
}

{
  kdu_region_compositor::~kdu_region_compositor(this);
  JUMPOUT(0x18D761C30);
}

void jpx_input_box::~jpx_input_box(jpx_input_box *this)
{
  *(_QWORD *)this = &off_1E1BADE00;
  jpx_input_box::close(this);
  jp2_input_box::~jp2_input_box(this);
}

{
  jpx_input_box::~jpx_input_box(this);
  JUMPOUT(0x18D761C30);
}

void MyCompositorBuf::~MyCompositorBuf(MyCompositorBuf *this)
{
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E1BB19C8;
}

{
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E1BB19C8;
  JUMPOUT(0x18D761C30);
}

uint64_t kdu_compositor_buf::set_read_accessibility(kdu_compositor_buf *this)
{
  *((_BYTE *)this + 25) = 1;
  return 1;
}

uint64_t kdu_compositor_buf::lock_buf(uint64_t this, char a2)
{
  *(_BYTE *)(this + 26) = 1;
  *(_BYTE *)(this + 27) = a2;
  return this;
}

void kdu_compositor_buf::~kdu_compositor_buf(kdu_compositor_buf *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1E1BB19C8;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x18D761C18](v1, 0x1000C8077774924);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1E1BB19C8;
  v1 = *((_QWORD *)this + 4);
  if (v1)
    MEMORY[0x18D761C18](v1, 0x1000C8077774924);
  JUMPOUT(0x18D761C30);
}

double kd_thread_group::get_queue(kd_thread_group *this)
{
  char *v2;
  char *v3;
  _QWORD *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  unsigned int v8;
  double result;

  v2 = (char *)*((_QWORD *)this + 801);
  if (v2)
  {
    v3 = (char *)*((_QWORD *)v2 + 7);
  }
  else
  {
    v4 = malloc_type_malloc(0x34087uLL, 0xD5807C5AuLL);
    *v4 = *((_QWORD *)this + 802);
    *((_QWORD *)this + 802) = v4;
    bzero(v4 + 1, 0x3407FuLL);
    v5 = -((_DWORD)v4 + 8) & 0x7F;
    v6 = (char *)v4 + v5 + 8;
    v7 = (char *)*((_QWORD *)this + 801);
    v2 = (char *)v4 + v5 - 6648;
    v8 = v5 ^ 0x35A7F;
    do
    {
      v3 = v7;
      *((_QWORD *)v2 + 839) = v7;
      v7 = v6;
      v6 += 6656;
      v2 += 6656;
      v8 -= 6656;
    }
    while (v8 >> 10 > 0xC);
  }
  *((_QWORD *)this + 801) = v3;
  *((_QWORD *)v2 + 7) = 0;
  *((_QWORD *)v2 + 2) = this;
  result = NAN;
  *((_QWORD *)v2 + 47) = -1;
  *((_DWORD *)v2 + 24) = -1;
  return result;
}

double kd_thread_group::release_queues(kd_thread_group *a1, uint64_t a2, char a3)
{
  kdu_thread_queue *i;
  double result;

  for (i = *(kdu_thread_queue **)(a2 + 48); i; i = *(kdu_thread_queue **)(a2 + 48))
  {
    *(_QWORD *)(a2 + 48) = *((_QWORD *)i + 4);
    kd_thread_group::release_queues(a1, i, 0);
  }
  if ((a3 & 1) == 0)
  {
    result = 0.0;
    *(_OWORD *)(a2 + 352) = 0u;
    *(_OWORD *)(a2 + 368) = 0u;
    *(_OWORD *)(a2 + 320) = 0u;
    *(_OWORD *)(a2 + 336) = 0u;
    *(_OWORD *)(a2 + 288) = 0u;
    *(_OWORD *)(a2 + 304) = 0u;
    *(_OWORD *)(a2 + 256) = 0u;
    *(_OWORD *)(a2 + 272) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 240) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)(a2 + 208) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_QWORD *)(a2 + 56) = *((_QWORD *)a1 + 801);
    *((_QWORD *)a1 + 801) = a2;
  }
  return result;
}

kdu_thread_queue *kdu_thread_queue::find_unassigned_job(kdu_thread_queue *this, int a2)
{
  kdu_thread_queue *v2;
  int v3;
  unsigned int v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  kdu_thread_queue *v11;

  v2 = this;
  v3 = *((_DWORD *)this + 27);
  if (!v3)
  {
    v5 = 0;
    v6 = 0;
    v7 = (uint64_t)this;
    do
    {
      v8 = *(unsigned int *)(v7 + 116);
      if (*(_DWORD *)(v7 + 112) > v5)
      {
        v6 = (int *)v7;
        v5 = *(_DWORD *)(v7 + 112);
      }
      if ((int)v8 < 1)
      {
LABEL_9:
        this = *(kdu_thread_queue **)(v7 + 24);
        if (this)
          goto LABEL_12;
      }
      else
      {
        v9 = (int *)(v7 + 132);
        while (1)
        {
          v10 = *v9;
          v9 += 8;
          if (v10 == a2)
            break;
          if (!--v8)
            goto LABEL_9;
        }
      }
      if (*(int *)(v7 + 104) < 1)
      {
        if (v6)
        {
          if (v6[25] <= 0)
            kdu_thread_queue::find_unassigned_job();
          return kdu_thread_queue::make_secondary_job_runnable((kdu_thread_queue *)v6);
        }
        else
        {
          if (*(_DWORD *)(v7 + 100))
            kdu_thread_queue::find_unassigned_job();
          return 0;
        }
      }
      kdu_thread_queue::make_primary_jobs_runnable(v7);
      this = v2;
LABEL_12:
      v3 = *((_DWORD *)this + 27);
      v7 = (uint64_t)this;
    }
    while (!v3);
  }
LABEL_21:
  while (v3 > *((_DWORD *)this + 22))
  {
    this = (kdu_thread_queue *)*((_QWORD *)this + 6);
    if (!this)
      goto LABEL_30;
    v11 = 0;
    do
    {
      v3 = *((_DWORD *)this + 27);
      if (v3 >= 1)
      {
        v11 = this;
        if (!*((_DWORD *)this + 19))
          goto LABEL_21;
      }
      this = (kdu_thread_queue *)*((_QWORD *)this + 4);
    }
    while (this);
    if (!v11)
LABEL_30:
      kdu_thread_queue::find_unassigned_job();
    v3 = *((_DWORD *)v11 + 27);
    this = v11;
  }
  return this;
}

uint64_t kdu_thread_queue::make_primary_jobs_runnable(uint64_t this)
{
  _DWORD *v1;
  int v2;
  uint64_t v3;
  int v4;
  _DWORD *v5;
  int v6;

  v1 = (_DWORD *)this;
  v2 = *(_DWORD *)(this + 84);
  if (*(_DWORD *)(this + 104) > v2)
  {
    v3 = *(_QWORD *)(this + 48);
    if (v3)
    {
      do
      {
        if (*(int *)(v3 + 104) >= 1)
          this = kdu_thread_queue::make_primary_jobs_runnable((kdu_thread_queue *)v3);
        v3 = *(_QWORD *)(v3 + 32);
      }
      while (v3);
      v2 = v1[21];
    }
  }
  if (v2 >= 1)
  {
    v4 = v1[22] + v2;
    v1[21] = 0;
    v1[22] = v4;
    v5 = v1;
    do
    {
      v6 = v5[27] + v2;
      v5[26] -= v2;
      v5[27] = v6;
      v5 = (_DWORD *)*((_QWORD *)v5 + 3);
    }
    while (v5);
  }
  if (v1[26])
    kdu_thread_queue::make_primary_jobs_runnable();
  return this;
}

kdu_thread_queue *kdu_thread_queue::make_secondary_job_runnable(kdu_thread_queue *this)
{
  int v1;
  kdu_thread_queue *v2;
  int v3;
  kdu_thread_queue *v4;
  int v5;
  int v6;
  uint64_t v7;
  kdu_thread_queue *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  kdu_thread_queue *v14;
  BOOL v15;
  uint64_t secondary_job_runnable;
  unsigned int v17;
  unsigned int v18;

  v1 = *((_DWORD *)this + 25);
  if (v1 < 1 || (v2 = this, !*((_DWORD *)this + 28)) || *((_DWORD *)this + 27) || *((_DWORD *)this + 26))
    kdu_thread_queue::make_secondary_job_runnable();
  if (v1 == *((_DWORD *)this + 20))
  {
    if (!*((_DWORD *)this + 18))
      kdu_thread_queue::make_secondary_job_runnable();
    v3 = *((_DWORD *)this + 22) + 1;
    *((_DWORD *)this + 22) = v3;
    if (v3 == v1)
      *((_DWORD *)this + 18) = 0;
    v4 = this;
    do
    {
      v5 = *((_DWORD *)v4 + 26);
      v6 = *((_DWORD *)v4 + 27) + 1;
      *((_DWORD *)v4 + 27) = v6;
      if (v5 + v6 == *((_DWORD *)v4 + 25))
        *((_DWORD *)v4 + 28) = 0;
      v4 = (kdu_thread_queue *)*((_QWORD *)v4 + 3);
    }
    while (v4);
  }
  else
  {
    v7 = *((_QWORD *)this + 6);
    if (!v7)
      goto LABEL_56;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = *(_DWORD *)(v7 + 112);
      if (v11)
      {
        if (*(_DWORD *)(v7 + 100))
        {
          if (*(_DWORD *)(v7 + 108) || *(_DWORD *)(v7 + 104) || *(_DWORD *)(v7 + 88) || *(_DWORD *)(v7 + 84))
            kdu_thread_queue::make_secondary_job_runnable();
          if (v11 <= v9)
            v12 = v9;
          else
            v12 = *(_DWORD *)(v7 + 112);
          if (v8)
            v13 = v10;
          else
            v13 = *(_DWORD *)(v7 + 112);
          if (v8)
          {
            v14 = v8;
          }
          else
          {
            v12 = v10;
            v14 = (kdu_thread_queue *)v7;
          }
          v15 = v11 > v10;
          if (v11 <= v10)
            v9 = v12;
          else
            v9 = v10;
          if (v11 <= v10)
            v10 = v13;
          else
            v10 = *(_DWORD *)(v7 + 112);
          if (v15)
            v8 = (kdu_thread_queue *)v7;
          else
            v8 = v14;
        }
        else
        {
          *(_DWORD *)(v7 + 112) = 0;
        }
      }
      v7 = *(_QWORD *)(v7 + 32);
    }
    while (v7);
    if (!v8)
LABEL_56:
      kdu_thread_queue::make_secondary_job_runnable();
    secondary_job_runnable = kdu_thread_queue::make_secondary_job_runnable(v8);
    v17 = *((_DWORD *)v8 + 28);
    if (v9 > v17)
      v17 = v9;
    v18 = *((_DWORD *)v2 + 18);
    if (v18)
    {
      if (*((_DWORD *)v2 + 20) <= *((_DWORD *)v2 + 21) + *((_DWORD *)v2 + 22))
        kdu_thread_queue::make_secondary_job_runnable();
      if (v18 > v17)
        v17 = *((_DWORD *)v2 + 18);
    }
    *((_DWORD *)v2 + 28) = v17;
    v2 = (kdu_thread_queue *)secondary_job_runnable;
    if (!secondary_job_runnable)
      kdu_thread_queue::make_secondary_job_runnable();
  }
  return v2;
}

uint64_t kdu_thread_queue::make_subtree_jobs_runnable(uint64_t this)
{
  _DWORD *v1;
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  _DWORD *v7;
  int v8;
  int v9;
  int v10;
  BOOL v11;

  v1 = (_DWORD *)this;
  v2 = *(_DWORD *)(this + 80);
  v3 = *(_DWORD *)(this + 88);
  v4 = v2 - v3;
  if (*(_DWORD *)(this + 100) - *(_DWORD *)(this + 108) > v2 - v3)
  {
    v5 = *(_QWORD *)(this + 48);
    if (v5)
    {
      do
      {
        if (*(_DWORD *)(v5 + 100) > *(_DWORD *)(v5 + 108))
          this = kdu_thread_queue::make_subtree_jobs_runnable((kdu_thread_queue *)v5);
        v5 = *(_QWORD *)(v5 + 32);
      }
      while (v5);
      v2 = v1[20];
      v3 = v1[22];
      v4 = v2 - v3;
    }
  }
  if (v4 >= 1)
  {
    v6 = v1[21];
    v1[21] = 0;
    v1[22] = v2;
    v7 = v1;
    v1[18] = 0;
    do
    {
      v8 = v7[27] + v4;
      v9 = v7[25];
      v10 = v7[26] - v6;
      v7[26] = v10;
      v7[27] = v8;
      if (v10 + v8 == v9)
        v7[28] = 0;
      v7 = (_DWORD *)*((_QWORD *)v7 + 3);
    }
    while (v7);
    v3 = v2;
  }
  v11 = v1[27] == v1[25] && v3 == v2;
  if (!v11 || v1[26])
    kdu_thread_queue::make_subtree_jobs_runnable();
  return this;
}

uint64_t kdu_thread_queue::install_synchronization_point(kdu_thread_queue *this, kdu_worker *a2, char a3, int a4)
{
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  char *v12;
  char *v13;
  uint64_t result;
  kdu_thread_queue *v15;

  if (*((_DWORD *)this + 27) < *((_DWORD *)this + 25))
    kdu_thread_queue::make_subtree_jobs_runnable((uint64_t)this);
  v8 = *((int *)this + 29);
  if ((int)v8 >= 8)
    kdu_thread_queue::install_synchronization_point();
  *((_DWORD *)this + 29) = v8 + 1;
  v9 = *((_DWORD *)this + 20);
  v10 = v9 + *((_DWORD *)this + 23);
  v11 = *((_DWORD *)this + 19) + v9;
  v12 = (char *)this + 32 * v8;
  *((_DWORD *)v12 + 32) = 0;
  v13 = v12 + 128;
  *((_DWORD *)v13 - 2) = v10;
  *((_DWORD *)v13 - 1) = v11;
  *((_DWORD *)v13 + 1) = a4;
  *((_QWORD *)v13 + 1) = a2;
  v13[16] = a3;
  v13[17] = 0;
  result = 1;
  if (!(_DWORD)v8 && v11 <= 0)
  {
    v15 = (kdu_thread_queue *)*((_QWORD *)this + 6);
    if (!v15)
      goto LABEL_12;
    do
    {
      if (kdu_thread_queue::install_synchronization_point(v15, 0, 0, -1))
        ++*(_DWORD *)v13;
      v15 = (kdu_thread_queue *)*((_QWORD *)v15 + 4);
    }
    while (v15);
    if (*(int *)v13 > 0)
    {
      return 1;
    }
    else
    {
LABEL_12:
      result = 0;
      *((_DWORD *)this + 29) = 0;
    }
  }
  return result;
}

BOOL kdu_event::set(kdu_event *this)
{
  uint64_t v1;
  int v2;

  v1 = 1;
  if (!*((_BYTE *)this + 48))
  {
    *((_BYTE *)this + 48) = 1;
    if (*((_BYTE *)this + 49))
      v2 = pthread_cond_broadcast((pthread_cond_t *)this);
    else
      v2 = pthread_cond_signal((pthread_cond_t *)this);
    return v2 == 0;
  }
  return v1;
}

BOOL kdu_thread_entity::terminate(kdu_thread_entity *this, kdu_thread_queue *a2, char a3, int *a4)
{
  kdu_thread_queue *v6;
  unsigned __int8 *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  kdu_thread_queue *v15;
  char v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;

  v6 = a2;
  kdu_thread_entity::synchronize(this, a2);
  v8 = (unsigned __int8 *)*((_QWORD *)this + 5);
  v9 = *v8;
  if (a4 && *v8)
    *a4 = *((_DWORD *)v8 + 1);
  if (!v6)
  {
    v10 = *((_QWORD *)this + 4);
    if (!*(_QWORD *)(v10 + 1224))
      return v9 == 0;
    v6 = (kdu_thread_queue *)(v10 + 1176);
    a3 = 1;
  }
  if (*((_DWORD *)v6 + 20) != *((_DWORD *)v6 + 25))
    kdu_thread_entity::terminate();
  v11 = *((_QWORD *)this + 4);
  if (*(_BYTE *)(v11 + 2160))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 2096));
    v11 = *((_QWORD *)this + 4);
  }
  v12 = *(unsigned int *)(v11 + 128);
  if ((int)v12 >= 1)
  {
    for (i = 0; i != v12; ++i)
    {
      v14 = *(_QWORD *)(v11 + 8 * i + 136);
      v15 = *(kdu_thread_queue **)(v14 + 64);
      if (v15 == v6)
        v16 = a3;
      else
        v16 = 0;
      if (v15 && (v16 & 1) == 0)
      {
        if (v15 == v6)
          goto LABEL_24;
        do
        {
          v15 = (kdu_thread_queue *)*((_QWORD *)v15 + 3);
          if (v15)
            v17 = v15 == v6;
          else
            v17 = 1;
        }
        while (!v17);
        if (v15)
LABEL_24:
          *(_QWORD *)(v14 + 64) = 0;
      }
    }
  }
  if ((a3 & 1) == 0)
  {
    if (*((_DWORD *)v6 + 20))
      kdu_thread_entity::terminate();
    v18 = *((_QWORD *)v6 + 5);
    if (!v18)
    {
      v30 = *((_QWORD *)v6 + 3);
      if (*(kdu_thread_queue **)(v30 + 48) != v6)
        kdu_thread_entity::terminate();
      v19 = *((_QWORD *)v6 + 4);
      *(_QWORD *)(v30 + 48) = v19;
      if (!v19)
        goto LABEL_31;
      goto LABEL_30;
    }
    *(_QWORD *)(v18 + 32) = *((_QWORD *)v6 + 4);
    v19 = *((_QWORD *)v6 + 4);
    if (v19)
LABEL_30:
      *(_QWORD *)(v19 + 40) = v18;
  }
LABEL_31:
  if (*(_BYTE *)(v11 + 2160))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 2096));
    v11 = *((_QWORD *)this + 4);
  }
  v20 = kd_thread_group::release_queues((kd_thread_group *)v11, (uint64_t)v6, a3);
  v21 = *((_QWORD *)this + 4);
  if (!*(_QWORD *)(v21 + 1224))
  {
    if (*((_DWORD *)this + 2) || *(_DWORD *)(v21 + 1168))
      kdu_thread_entity::terminate();
    (*(void (**)(kdu_thread_entity *, _QWORD, double))(*(_QWORD *)this + 56))(this, **((unsigned __int8 **)this + 5), v20);
    v22 = 1;
    *((_BYTE *)this + 72) = 1;
    v23 = *((_QWORD *)this + 4);
    if (*(_BYTE *)(v23 + 2160))
    {
      pthread_mutex_lock((pthread_mutex_t *)(v23 + 2096));
      v23 = *((_QWORD *)this + 4);
    }
    *(_DWORD *)(v23 + 1168) = 1;
    *(_BYTE *)(v23 + 2088) = 1;
    LODWORD(v24) = *(_DWORD *)(v23 + 128);
    if ((int)v24 >= 2)
    {
      v25 = 1;
      v26 = 2224;
      do
      {
        kdu_event::set((kdu_event *)(v23 + v26));
        ++v25;
        v23 = *((_QWORD *)this + 4);
        v24 = *(int *)(v23 + 128);
        v26 += 56;
      }
      while (v25 < v24);
      v22 = *(_DWORD *)(v23 + 1168);
    }
    if (v22 < (int)v24)
    {
      do
      {
        kdu_event::wait((pthread_cond_t *)(v23 + 2168), (pthread_mutex_t *)(v23 + 2096));
        v23 = *((_QWORD *)this + 4);
        LODWORD(v24) = *(_DWORD *)(v23 + 128);
      }
      while (*(_DWORD *)(v23 + 1168) < (int)v24);
    }
    if (*(_DWORD *)(v23 + 1560))
      kdu_thread_entity::terminate();
    *(_BYTE *)(v23 + 2088) = 0;
    *(_DWORD *)(v23 + 1168) = 0;
    if ((int)v24 >= 1)
    {
      v24 = v24;
      v27 = v23 + 136;
      do
      {
        if (!*(_BYTE *)(*(_QWORD *)v27 + 72))
          kdu_thread_entity::terminate();
        *(_BYTE *)(*(_QWORD *)v27 + 72) = 0;
        v27 += 8;
        --v24;
      }
      while (v24);
    }
    v28 = *((_QWORD *)this + 5);
    *(_BYTE *)v28 = 0;
    *(_DWORD *)(v28 + 4) = -1;
    if (*(_BYTE *)(v23 + 2160))
      pthread_mutex_unlock((pthread_mutex_t *)(v23 + 2096));
  }
  return v9 == 0;
}

BOOL kdu_mutex::unlock(kdu_mutex *this)
{
  return *((_BYTE *)this + 64) && pthread_mutex_unlock((pthread_mutex_t *)this) == 0;
}

uint64_t kdu_thread_entity::get_num_threads(kdu_thread_entity *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 4);
  if (v1)
    return *(unsigned int *)(v1 + 128);
  else
    return 0;
}

uint64_t kdu_thread_entity::add_queue(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  kd_thread_group *v5;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v5 = *(kd_thread_group **)(a1 + 32);
  if (!v5)
    return 0;
  if (a3)
    v8 = a3;
  else
    v8 = (char *)v5 + 1176;
  kd_thread_group::get_queue(v5);
  v10 = v9;
  *(_DWORD *)v9 = *(_DWORD *)v8 + 1;
  *(_QWORD *)(v9 + 8) = a4;
  *(_QWORD *)(v9 + 64) = a2;
  *(_QWORD *)(v9 + 24) = v8;
  v11 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v11 + 2160))
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 2096));
  v12 = *((_QWORD *)v8 + 6);
  *(_QWORD *)(v10 + 32) = v12;
  if (v12)
    *(_QWORD *)(v12 + 40) = v10;
  *((_QWORD *)v8 + 6) = v10;
  v13 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v13 + 2160))
    pthread_mutex_unlock((pthread_mutex_t *)(v13 + 2096));
  return v10;
}

uint64_t kdu_thread_entity::add_jobs(uint64_t this, kdu_thread_queue *a2, int a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v21;
  uint64_t v22;
  kdu_thread_queue *v23;
  int v24;
  uint64_t v25;
  kdu_thread_queue *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  kdu_thread_queue *v36;
  int v37;
  int v38;
  int v39;
  kdu_thread_queue *v40;
  kdu_thread_queue *v41;
  int v42;
  uint64_t v43;
  _DWORD *exception;

  if (a3 < 0)
    kdu_thread_entity::add_jobs();
  v7 = this;
  v8 = *(_QWORD *)(this + 32);
  if (*(_BYTE *)(v8 + 2160))
    this = pthread_mutex_lock((pthread_mutex_t *)(v8 + 2096));
  if (**(_BYTE **)(v7 + 40))
  {
    kdu_mutex::unlock((kdu_mutex *)(*(_QWORD *)(v7 + 32) + 2096));
    exception = __cxa_allocate_exception(4uLL);
    *exception = *(_DWORD *)(*(_QWORD *)(v7 + 40) + 4);
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v9 = *((_DWORD *)a2 + 20);
  v10 = *((_DWORD *)a2 + 21);
  v11 = *((_DWORD *)a2 + 22);
  v12 = v9 - (v10 + v11);
  if ((v12 | a3) < 0)
    kdu_thread_entity::add_jobs();
  if (!(v12 | a3))
    goto LABEL_61;
  if (a4)
    v13 = a3;
  else
    v13 = 0;
  if (a4)
    v14 = 0;
  else
    v14 = a3;
  v15 = v12 + v14;
  v16 = v9 + a3;
  v17 = v15 + v10;
  *((_DWORD *)a2 + 20) = v9 + a3;
  *((_DWORD *)a2 + 21) = v15 + v10;
  v18 = *(_QWORD *)(v7 + 32);
  v19 = *(_DWORD *)(v18 + 648);
  if (v19 >= 1 && v16 >= 1)
  {
    *((_DWORD *)a2 + 21) = 0;
    if (!v17)
    {
      if (!v13)
        kdu_thread_entity::add_jobs();
      --v13;
      v17 = 1;
    }
    v21 = v17;
    v15 = -v10;
    v11 += v17;
    *((_DWORD *)a2 + 22) = v11;
    v17 = 0;
    if (!v13)
      goto LABEL_29;
LABEL_19:
    if (!a4)
      kdu_thread_entity::add_jobs();
    v22 = -a4;
    *((_DWORD *)a2 + 18) = v22;
    v23 = a2;
    do
    {
      v24 = *((_DWORD *)v23 + 26) + v15;
      *((_DWORD *)v23 + 25) += a3;
      *((_DWORD *)v23 + 26) = v24;
      v25 = *((unsigned int *)v23 + 28);
      *((_DWORD *)v23 + 27) += v21;
      if (v25 < v22)
      {
        *((_DWORD *)v23 + 28) = v22;
        v25 = v22;
      }
      v23 = (kdu_thread_queue *)*((_QWORD *)v23 + 3);
      v22 = v25;
    }
    while (v23);
    goto LABEL_34;
  }
  v21 = 0;
  if (v13)
    goto LABEL_19;
LABEL_29:
  if (v17 + v11 != v16)
    kdu_thread_entity::add_jobs();
  *((_DWORD *)a2 + 18) = 0;
  v26 = a2;
  do
  {
    v27 = *((_DWORD *)v26 + 25) + a3;
    v28 = *((_DWORD *)v26 + 26) + v15;
    *((_DWORD *)v26 + 25) = v27;
    *((_DWORD *)v26 + 26) = v28;
    v29 = *((_DWORD *)v26 + 27) + v21;
    *((_DWORD *)v26 + 27) = v29;
    if (v29 + v28 == v27)
      *((_DWORD *)v26 + 28) = 0;
    v26 = (kdu_thread_queue *)*((_QWORD *)v26 + 3);
  }
  while (v26);
LABEL_34:
  if (v19 < 1)
    goto LABEL_62;
  v30 = v11 - 1;
  if (v11 < 1 || *((_DWORD *)a2 + 19) || (*((_DWORD *)a2 + 24) & 0x80000000) == 0)
    goto LABEL_62;
  v31 = *(unsigned int *)(v18 + 128);
  if ((int)v31 < 1)
    goto LABEL_70;
  v32 = 0;
  v33 = -1;
  v34 = 0x7FFFFFFF;
  do
  {
    v35 = v18 + 8 * v32;
    if (!*(_QWORD *)(v35 + 656))
    {
      v36 = *(kdu_thread_queue **)(*(_QWORD *)(v35 + 136) + 64);
      if (v36)
      {
        v37 = *(_DWORD *)v36;
        v38 = *(_DWORD *)a2;
        if (*(_DWORD *)a2 <= *(_DWORD *)v36)
        {
          v39 = 0;
          v40 = a2;
        }
        else
        {
          v39 = 0;
          v40 = a2;
          do
          {
            ++v39;
            v40 = (kdu_thread_queue *)*((_QWORD *)v40 + 3);
            v38 = *(_DWORD *)v40;
          }
          while (*(_DWORD *)v40 > v37);
        }
        while (v37 > v38)
        {
          ++v39;
          v36 = (kdu_thread_queue *)*((_QWORD *)v36 + 3);
          v37 = *(_DWORD *)v36;
        }
        while (v40 != v36)
        {
          v39 += 2;
          v40 = (kdu_thread_queue *)*((_QWORD *)v40 + 3);
          v36 = (kdu_thread_queue *)*((_QWORD *)v36 + 3);
        }
      }
      else
      {
        v39 = 0;
      }
      if (v39 < v34)
      {
        v33 = v32;
        v34 = v39;
      }
    }
    ++v32;
  }
  while (v32 != v31);
  if (v33 < 1 || *(_QWORD *)(v18 + 8 * v33 + 656))
LABEL_70:
    kdu_thread_entity::add_jobs();
  *((_DWORD *)a2 + 19) = 1;
  *((_DWORD *)a2 + 20) = v16 - 1;
  *((_DWORD *)a2 + 22) = v30;
  v41 = a2;
  do
  {
    --*((_DWORD *)v41 + 25);
    --*((_DWORD *)v41 + 27);
    v41 = (kdu_thread_queue *)*((_QWORD *)v41 + 3);
  }
  while (v41);
  v42 = *((_DWORD *)a2 + 23);
  *((_DWORD *)a2 + 23) = v42 + 1;
  *((_DWORD *)a2 + 24) = v42;
  *(_QWORD *)(v18 + 8 * v33 + 656) = a2;
  v43 = *(_QWORD *)(v7 + 32);
  --*(_DWORD *)(v43 + 648);
  this = kdu_event::set((kdu_event *)(v43 + 56 * v33 + 2168));
LABEL_61:
  v18 = *(_QWORD *)(v7 + 32);
LABEL_62:
  if (*(_BYTE *)(v18 + 2160))
    return pthread_mutex_unlock((pthread_mutex_t *)(v18 + 2096));
  return this;
}

BOOL kdu_thread_entity::synchronize(kdu_thread_entity *this, kdu_thread_queue *a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  __int128 v16;
  uint64_t v18;

  v2 = *((_QWORD *)this + 4);
  if (!v2)
    return 1;
  if (*(int *)(v2 + 5752) >= 1)
  {
    v5 = 0;
    v6 = 72;
    do
    {
      if (*(kdu_thread_entity **)(*(_QWORD *)(v2 + 5760) + v6) == this)
      {
        (*(void (**)(kdu_thread_entity *, _QWORD))(*(_QWORD *)this + 32))(this, 0);
        v2 = *((_QWORD *)this + 4);
      }
      ++v5;
      v6 += 80;
    }
    while (v5 < *(int *)(v2 + 5752));
  }
  if (a2)
    goto LABEL_10;
  if (*(_QWORD *)(v2 + 1224))
  {
    a2 = (kdu_thread_queue *)(v2 + 1176);
LABEL_10:
    if (*(_BYTE *)(v2 + 2160))
      pthread_mutex_lock((pthread_mutex_t *)(v2 + 2096));
    if (!*((_QWORD *)a2 + 6) && *((_DWORD *)a2 + 20) + *((_DWORD *)a2 + 23))
      kdu_thread_entity::synchronize();
    if (kdu_thread_queue::install_synchronization_point(a2, 0, 0, *((_DWORD *)this + 2)))
    {
      v7 = *((_QWORD *)this + 4);
      if (*(_BYTE *)(v7 + 2160))
        pthread_mutex_unlock((pthread_mutex_t *)(v7 + 2096));
      v8 = kdu_thread_entity::process_jobs(this, a2, 1, 0);
      v9 = *((_QWORD *)this + 4);
      if (*(_BYTE *)(v9 + 2160))
        pthread_mutex_lock((pthread_mutex_t *)(v9 + 2096));
      v10 = *((_DWORD *)a2 + 29);
      if ((v8 & 1) != 0)
      {
        if (v10 < 1
          || (v11 = *((_DWORD *)a2 + 33), v11 != *((_DWORD *)this + 2))
          || !kdu_thread_queue::check_condition(a2, 1, v11))
        {
          kdu_thread_entity::synchronize();
        }
        v12 = *((int *)a2 + 29);
        v13 = v12 - 1;
        *((_DWORD *)a2 + 29) = v12 - 1;
        if ((int)v12 >= 2)
        {
          v14 = 0;
          v15 = (_OWORD *)((char *)a2 + 152);
          do
          {
            ++v14;
            v16 = v15[1];
            *(v15 - 2) = *v15;
            *(v15 - 1) = v16;
            v15 += 2;
          }
          while (v14 < v13);
          kdu_thread_entity::process_outstanding_sync_points(this, a2);
        }
      }
      else if (v10 && *((_DWORD *)a2 + 33) == *((_DWORD *)this + 2))
      {
        kdu_thread_entity::synchronize();
      }
    }
    v18 = *((_QWORD *)this + 4);
    if (*(_BYTE *)(v18 + 2160))
      pthread_mutex_unlock((pthread_mutex_t *)(v18 + 2096));
  }
  return **((_BYTE **)this + 5) == 0;
}

uint64_t kdu_thread_entity::process_jobs(kdu_thread_entity *this, kdu_thread_queue *a2, int a3, int a4)
{
  uint64_t v8;
  int v9;
  int v10;
  kdu_thread_queue *v11;
  int v12;
  kdu_thread_queue *v13;
  kdu_thread_queue *v14;
  kdu_thread_queue *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  int v20;
  int v21;
  kdu_thread_queue *v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  kdu_thread_queue *unassigned_job;
  uint64_t v38;
  BOOL v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  kdu_thread_queue **v44;
  uint64_t v45;
  int v46;
  kdu_thread_queue *v47;
  kdu_thread_queue *v48;
  uint64_t v49;
  int v50;
  int v51;
  uint64_t v52;
  int *v53;
  int v54;
  int v55;
  int v56;
  _DWORD *v57;
  kdu_thread_queue *v58;
  unsigned int v59;
  uint64_t v60;
  BOOL v62;
  uint64_t v63;
  _DWORD *exception;

  v8 = *((_QWORD *)this + 4);
  if (!a2 && v8 && !*((_DWORD *)this + 2))
    kdu_thread_entity::process_jobs();
  if (*(_BYTE *)(v8 + 2160))
    pthread_mutex_lock((pthread_mutex_t *)(v8 + 2096));
  if (a2)
  {
    if ((a3 & 1) == 0)
    {
      v9 = *((_DWORD *)a2 + 21);
      if (v9 >= 1)
      {
        v10 = *((_DWORD *)a2 + 22) + v9;
        *((_DWORD *)a2 + 21) = 0;
        *((_DWORD *)a2 + 22) = v10;
        v11 = a2;
        do
        {
          v12 = *((_DWORD *)v11 + 27) + v9;
          *((_DWORD *)v11 + 26) -= v9;
          *((_DWORD *)v11 + 27) = v12;
          v11 = (kdu_thread_queue *)*((_QWORD *)v11 + 3);
        }
        while (v11);
      }
    }
  }
  v13 = 0;
  v14 = 0;
  while (1)
  {
    v15 = v13 ? v13 : a2;
    if (!v15)
    {
      v15 = (kdu_thread_queue *)*((_QWORD *)this + 8);
      if (!v15)
        break;
    }
    if (!v14)
      goto LABEL_65;
LABEL_18:
    if (**((_BYTE **)this + 5) && (a4 & 1) != 0)
    {
LABEL_184:
      kdu_mutex::unlock((kdu_mutex *)(*((_QWORD *)this + 4) + 2096));
      goto LABEL_185;
    }
    if (a2
      || (v24 = *((_QWORD *)this + 4), v25 = *(_DWORD *)(v24 + 1560), v25 < 1)
      || *(_QWORD *)(v24 + 8 * *((int *)this + 2) + 656) != 1)
    {
      if (!v14)
        goto LABEL_161;
      v16 = *((_QWORD *)this + 4);
      v17 = v16 + 8 * *((int *)this + 2);
      if (*(kdu_thread_queue **)(v17 + 656) == v14)
      {
        v23 = *((_DWORD *)v14 + 24);
        if (v23 < 0)
          kdu_thread_entity::process_jobs();
        *((_DWORD *)v14 + 24) = -1;
        *(_QWORD *)(v17 + 656) = 1;
        v16 = *((_QWORD *)this + 4);
      }
      else
      {
        v18 = *((_DWORD *)v14 + 20);
        v19 = __OFSUB__(v18, 1);
        v20 = v18 - 1;
        if (v20 < 0 != v19 || (v21 = *((_DWORD *)v14 + 22), v21 <= 0))
          kdu_thread_entity::process_jobs();
        *((_DWORD *)v14 + 20) = v20;
        *((_DWORD *)v14 + 22) = v21 - 1;
        v22 = v14;
        do
        {
          --*((_DWORD *)v22 + 25);
          --*((_DWORD *)v22 + 27);
          v22 = (kdu_thread_queue *)*((_QWORD *)v22 + 3);
        }
        while (v22);
        ++*((_DWORD *)v14 + 19);
        v23 = *((_DWORD *)v14 + 23);
        *((_DWORD *)v14 + 23) = v23 + 1;
      }
      if (*(_BYTE *)(v16 + 2160))
        pthread_mutex_unlock((pthread_mutex_t *)(v16 + 2096));
      (*(void (**)(void))(**((_QWORD **)v14 + 8) + 16))();
      v30 = *((_QWORD *)this + 4);
      if (*(_BYTE *)(v30 + 2160))
        pthread_mutex_lock((pthread_mutex_t *)(v30 + 2096));
      v31 = *((_DWORD *)v14 + 19);
      if (**((_BYTE **)this + 5))
      {
        if (v31)
          kdu_thread_entity::process_jobs();
LABEL_43:
        v13 = 0;
        v14 = 0;
        if (a4)
          goto LABEL_184;
      }
      else
      {
        if (v31 <= 0)
          kdu_thread_entity::process_jobs();
        if (*((_QWORD *)v14 + 6))
          goto LABEL_47;
        v49 = *((_QWORD *)v14 + 3);
        if (!v49 || !*(_DWORD *)(v49 + 108))
          goto LABEL_47;
        if (*((int *)v14 + 29) < 1)
          goto LABEL_109;
        v50 = *((_DWORD *)v14 + 30);
        if (v23 >= v50)
          goto LABEL_109;
        if (*(int *)(v49 + 116) < 1 || *(int *)(v49 + 128) <= 0)
          kdu_thread_entity::process_jobs();
        if (*((int *)v14 + 22) > 0)
        {
          if (*((_DWORD *)v14 + 23) >= v50)
          {
LABEL_47:
            if (((*(uint64_t (**)(kdu_thread_entity *))(*(_QWORD *)this + 48))(this) & 1) == 0)
            {
              v48 = 0;
              v31 = *((_DWORD *)v14 + 19);
              goto LABEL_110;
            }
            v32 = *((_QWORD *)this + 4);
            if (*(_BYTE *)(v32 + 2160))
              pthread_mutex_unlock((pthread_mutex_t *)(v32 + 2096));
            (*(void (**)(kdu_thread_entity *, _QWORD))(*(_QWORD *)this + 40))(this, **((unsigned __int8 **)this + 5));
            v33 = *((_QWORD *)this + 4);
            if (*(_BYTE *)(v33 + 2160))
              pthread_mutex_lock((pthread_mutex_t *)(v33 + 2096));
            v31 = *((_DWORD *)v14 + 19);
            if (**((_BYTE **)this + 5))
            {
              if (v31)
                kdu_thread_entity::process_jobs();
              goto LABEL_43;
            }
          }
LABEL_109:
          v48 = 0;
          goto LABEL_110;
        }
        v48 = *(kdu_thread_queue **)(v49 + 48);
        if (!v48)
          goto LABEL_47;
        while (*((int *)v48 + 29) < 1 || *((int *)v48 + 22) < 1 || *((_DWORD *)v48 + 23) >= *((_DWORD *)v48 + 30))
        {
          v48 = (kdu_thread_queue *)*((_QWORD *)v48 + 4);
          if (!v48)
            goto LABEL_47;
        }
LABEL_110:
        *((_DWORD *)v14 + 19) = v31 - 1;
        if (*((int *)v14 + 29) >= 1)
        {
          v51 = 0;
          do
          {
            if (v23 < *((_DWORD *)v14 + 8 * v51 + 30))
            {
              v52 = (uint64_t)v14 + 32 * v51 + 120;
              v55 = *(_DWORD *)(v52 + 4);
              v53 = (int *)(v52 + 4);
              v54 = v55;
              if (v55 <= 0)
                kdu_thread_entity::process_jobs();
              v56 = v54 - 1;
              *v53 = v56;
              if (!v51)
              {
                if (v56)
                  goto LABEL_116;
                v57 = (_DWORD *)((char *)v14 + 128);
                if (*((_DWORD *)v14 + 32))
                  kdu_thread_entity::process_jobs();
                v58 = (kdu_thread_queue *)*((_QWORD *)v14 + 6);
                if (!v58)
                  goto LABEL_123;
                do
                {
                  if (kdu_thread_queue::install_synchronization_point(v58, 0, 0, -1))
                    ++*v57;
                  v58 = (kdu_thread_queue *)*((_QWORD *)v58 + 4);
                }
                while (v58);
                if (*v57)
LABEL_116:
                  v51 = 0;
                else
LABEL_123:
                  v51 = (int)(kdu_thread_entity::process_outstanding_sync_points(this, v14) << 31) >> 31;
              }
            }
            ++v51;
          }
          while (v51 < *((_DWORD *)v14 + 29));
        }
        v59 = *((_DWORD *)v14 + 95);
        if ((v59 & 0x80000000) == 0)
        {
          if (*((_DWORD *)v14 + 21))
            kdu_thread_entity::process_jobs();
          if (!(*((_DWORD *)v14 + 22) + *((_DWORD *)v14 + 19)))
          {
            if (v59 == *((_DWORD *)this + 2))
              kdu_thread_entity::process_jobs();
            kdu_event::set((kdu_event *)(*((_QWORD *)this + 4) + 56 * v59 + 2168));
          }
        }
        if (a2 && kdu_thread_queue::check_condition(a2, a3, *((_DWORD *)this + 2)))
        {
          if (v48)
            kdu_thread_entity::process_jobs();
          goto LABEL_161;
        }
        if (!v48)
        {
          if (*((int *)v14 + 22) <= 0)
            v48 = 0;
          else
            v48 = v14;
        }
        *((_QWORD *)this + 8) = v14;
        v13 = v14;
        v14 = v48;
      }
    }
    else
    {
      if (*(int *)(v24 + 128) <= 1)
        kdu_thread_entity::process_jobs();
      v26 = *(_QWORD *)(v24 + 1568);
      if (v25 < 2)
      {
        LODWORD(v28) = 1;
      }
      else
      {
        v27 = 0;
        do
        {
          *(_QWORD *)(v24 + 8 * v27 + 1568) = *(_QWORD *)(v24 + 8 * v27 + 1576);
          v24 = *((_QWORD *)this + 4);
          v28 = *(int *)(v24 + 1560);
          v29 = v27 + 2;
          ++v27;
        }
        while (v29 < v28);
      }
      *(_DWORD *)(v24 + 1560) = v28 - 1;
      if (*(_BYTE *)(v24 + 2160))
        pthread_mutex_unlock((pthread_mutex_t *)(v24 + 2096));
      if ((*(unsigned int (**)(kdu_thread_entity *))(*(_QWORD *)this + 48))(this))
        (*(void (**)(kdu_thread_entity *, _QWORD))(*(_QWORD *)this + 40))(this, **((unsigned __int8 **)this + 5));
      (*(void (**)(uint64_t, kdu_thread_entity *, uint64_t))(*(_QWORD *)v26 + 16))(v26, this, 0xFFFFFFFFLL);
      v13 = 0;
      v14 = 0;
      v60 = *((_QWORD *)this + 4);
      if (*(_BYTE *)(v60 + 2160))
      {
        pthread_mutex_lock((pthread_mutex_t *)(v60 + 2096));
        v13 = 0;
        v14 = 0;
      }
    }
  }
  v15 = (kdu_thread_queue *)(*((_QWORD *)this + 4) + 1176);
  if (v14)
    goto LABEL_18;
LABEL_65:
  while (!a2)
  {
    if (*(_DWORD *)(*((_QWORD *)this + 4) + 1560))
    {
      v14 = 0;
      goto LABEL_18;
    }
LABEL_69:
    unassigned_job = kdu_thread_queue::find_unassigned_job(v15, *((_DWORD *)this + 2));
    if (unassigned_job)
    {
      v14 = unassigned_job;
      goto LABEL_18;
    }
    v38 = *((_QWORD *)this + 4);
    if (*(_BYTE *)(v38 + 2089)
      || ((v34 = **((unsigned __int8 **)this + 5), **((_BYTE **)this + 5)) ? (v39 = a4 == 0) : (v39 = 1), !v39))
    {
      if (*(_BYTE *)(v38 + 2160))
        pthread_mutex_unlock((pthread_mutex_t *)(v38 + 2096));
      if (!a4)
        return 0;
LABEL_185:
      exception = __cxa_allocate_exception(4uLL);
      *exception = *(_DWORD *)(*((_QWORD *)this + 5) + 4);
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    if (a2)
    {
      if (a3)
      {
        if (*((int *)a2 + 29) < 1 || (v40 = *((_DWORD *)a2 + 33), v40 != *((_DWORD *)this + 2)))
          kdu_thread_entity::process_jobs();
        *((_DWORD *)a2 + 94) = v40;
      }
      else
      {
        v40 = *((_DWORD *)this + 2);
        *((_DWORD *)a2 + 95) = v40;
      }
    }
    else
    {
      if (*(_BYTE *)(v38 + 2088) && !*((_BYTE *)this + 72))
      {
        if (*(_BYTE *)(v38 + 2160))
        {
          pthread_mutex_unlock((pthread_mutex_t *)(v38 + 2096));
          v34 = **((unsigned __int8 **)this + 5);
        }
        (*(void (**)(kdu_thread_entity *, BOOL))(*(_QWORD *)this + 56))(this, v34 != 0);
        v35 = *((_QWORD *)this + 4);
        if (*(_BYTE *)(v35 + 2160))
        {
          pthread_mutex_lock((pthread_mutex_t *)(v35 + 2096));
          v35 = *((_QWORD *)this + 4);
        }
        *((_BYTE *)this + 72) = 1;
        v36 = *(_DWORD *)(v35 + 1168) + 1;
        *(_DWORD *)(v35 + 1168) = v36;
        if (v36 == *(_DWORD *)(v35 + 128))
        {
          kdu_event::set((kdu_event *)(v35 + 2168));
          v35 = *((_QWORD *)this + 4);
        }
        v15 = (kdu_thread_queue *)(v35 + 1176);
        continue;
      }
      v40 = *((_DWORD *)this + 2);
      if (!v40)
        kdu_thread_entity::process_jobs();
      v41 = v38 + 8 * v40;
      if (!*(_QWORD *)(v41 + 656))
        kdu_thread_entity::process_jobs();
      ++*(_DWORD *)(v38 + 648);
      *(_QWORD *)(v41 + 656) = 0;
      v38 = *((_QWORD *)this + 4);
    }
    v42 = v38 + 56 * v40;
    *(_BYTE *)(v42 + 2216) = 0;
    kdu_event::wait((pthread_cond_t *)(v42 + 2168), (pthread_mutex_t *)(v38 + 2096));
    if (a2)
    {
      if (a3)
        *((_DWORD *)a2 + 94) = -1;
      else
        *((_DWORD *)a2 + 95) = -1;
    }
    else
    {
      v43 = *((_QWORD *)this + 4);
      v44 = (kdu_thread_queue **)(v43 + 8 * *((int *)this + 2) + 656);
      v14 = *v44;
      if (*v44)
      {
        if (v14 == (kdu_thread_queue *)1)
          kdu_thread_entity::process_jobs();
        if (v14 != (kdu_thread_queue *)(v43 + 1176))
        {
          if ((*((_DWORD *)v14 + 24) & 0x80000000) != 0)
            kdu_thread_entity::process_jobs();
          goto LABEL_18;
        }
        *v44 = (kdu_thread_queue *)1;
      }
      else
      {
        if (*(int *)(v43 + 648) <= 0)
          kdu_thread_entity::process_jobs();
        *v44 = (kdu_thread_queue *)1;
        v45 = *((_QWORD *)this + 4);
        --*(_DWORD *)(v45 + 648);
        v46 = *(unsigned __int8 *)(v45 + 2088);
        v47 = (kdu_thread_queue *)(v45 + 1176);
        if (v46)
          v15 = v47;
      }
    }
  }
  if (!kdu_thread_queue::check_condition(a2, a3, *((_DWORD *)this + 2)))
    goto LABEL_69;
  if (**((_BYTE **)this + 5))
    v62 = a4 == 0;
  else
    v62 = 1;
  if (!v62)
    goto LABEL_184;
LABEL_161:
  v63 = *((_QWORD *)this + 4);
  if (*(_BYTE *)(v63 + 2160))
    pthread_mutex_unlock((pthread_mutex_t *)(v63 + 2096));
  if ((*(unsigned int (**)(kdu_thread_entity *))(*(_QWORD *)this + 48))(this))
    (*(void (**)(kdu_thread_entity *, _QWORD))(*(_QWORD *)this + 40))(this, **((unsigned __int8 **)this + 5));
  return 1;
}

void sub_187EFAFCC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

BOOL kdu_thread_queue::check_condition(kdu_thread_queue *this, int a2, int a3)
{
  if (a2)
  {
    if (*((int *)this + 29) <= 0)
      kdu_thread_queue::check_condition();
    if (*((_DWORD *)this + 33) != a3 || *((_DWORD *)this + 31))
      return 0;
    return *((_DWORD *)this + 32) == 0;
  }
  else
  {
    if (*((_DWORD *)this + 21))
      kdu_thread_entity::process_jobs();
    return *((_DWORD *)this + 22) + *((_DWORD *)this + 19) == 0;
  }
}

uint64_t kdu_thread_entity::process_outstanding_sync_points(kdu_thread_entity *this, kdu_thread_queue *a2)
{
  int v2;
  char v5;
  char *v6;
  char *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _BOOL4 v21;
  int v22;
  int *v23;
  int v24;
  int v25;

  v2 = *((_DWORD *)a2 + 29);
  if (v2 < 1)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    v6 = (char *)a2 + 120;
    v7 = (char *)a2 + 152;
    while (*((int *)a2 + 31) <= 0 && *((int *)a2 + 32) <= 0)
    {
      v8 = *((_DWORD *)a2 + 33);
      v9 = *((_QWORD *)a2 + 17);
      if ((v8 & 0x80000000) == 0)
      {
        if (v9)
          kdu_thread_entity::process_outstanding_sync_points();
        if (v8 == *((_DWORD *)a2 + 94))
          kdu_event::set((kdu_event *)(*((_QWORD *)this + 4) + 56 * v8 + 2168));
        return v5 & 1;
      }
      if (v9)
      {
        if (*((_BYTE *)a2 + 145))
          return v5 & 1;
        v10 = *((_QWORD *)this + 4);
        if (*((_BYTE *)a2 + 144) && *(int *)(v10 + 128) >= 2 && (v11 = *(int *)(v10 + 1560), (int)v11 <= 63))
        {
          *(_DWORD *)(v10 + 1560) = v11 + 1;
          *(_QWORD *)(v10 + 8 * v11 + 1568) = v9;
          v12 = *((_QWORD *)this + 4);
          v13 = *(_DWORD *)(v12 + 648);
          v14 = __OFSUB__(v13, 1);
          v15 = v13 - 1;
          if (v15 < 0 == v14)
          {
            v16 = *(unsigned int *)(v12 + 128);
            if ((int)v16 < 2)
LABEL_44:
              kdu_thread_entity::process_outstanding_sync_points();
            v17 = (_QWORD *)(v12 + 664);
            v18 = 56 * v16;
            v19 = -2224;
            while (*v17)
            {
              ++v17;
              v19 -= 56;
              if (v18 + v19 == -2168)
                goto LABEL_44;
            }
            *(_DWORD *)(v12 + 648) = v15;
            *v17 = v12 + 1176;
            kdu_event::set((kdu_event *)(*((_QWORD *)this + 4) - v19));
          }
        }
        else
        {
          *((_BYTE *)a2 + 145) = 1;
          if (*(_BYTE *)(v10 + 2160))
          {
            pthread_mutex_unlock((pthread_mutex_t *)(v10 + 2096));
            v9 = *((_QWORD *)a2 + 17);
          }
          (*(void (**)(uint64_t, kdu_thread_entity *, uint64_t))(*(_QWORD *)v9 + 16))(v9, this, 0xFFFFFFFFLL);
          if ((*(unsigned int (**)(kdu_thread_entity *))(*(_QWORD *)this + 48))(this))
            (*(void (**)(kdu_thread_entity *, _QWORD))(*(_QWORD *)this + 40))(this, **((unsigned __int8 **)this + 5));
          v20 = *((_QWORD *)this + 4);
          if (*(_BYTE *)(v20 + 2160))
            pthread_mutex_lock((pthread_mutex_t *)(v20 + 2096));
          *((_BYTE *)a2 + 145) = 0;
        }
        v21 = 0;
        *((_QWORD *)a2 + 17) = 0;
        v2 = *((_DWORD *)a2 + 29);
      }
      else
      {
        v21 = *((_QWORD *)a2 + 3) != 0;
      }
      v22 = v2--;
      *((_DWORD *)a2 + 29) = v2;
      if (v22 >= 2)
        memmove(v6, v7, 32 * v2);
      if (v21)
      {
        v23 = (int *)*((_QWORD *)a2 + 3);
        if (v23[29] < 1 || (v24 = v23[32], v24 < 1) || v23[31])
          kdu_thread_entity::process_outstanding_sync_points();
        v25 = v24 - 1;
        v23[32] = v25;
        if (!v25)
        {
          kdu_thread_entity::process_outstanding_sync_points(this, (kdu_thread_queue *)v23);
          v2 = *((_DWORD *)a2 + 29);
        }
      }
      v5 = 1;
      if (v2 <= 0)
        return v5 & 1;
    }
  }
  return v5 & 1;
}

uint64_t kdu_event::wait(pthread_cond_t *this, pthread_mutex_t *a2)
{
  uint64_t result;

  if (LOBYTE(this[1].__sig))
    return 1;
  while (BYTE2(this[1].__sig) && !pthread_cond_wait(this, a2))
  {
    if (LOBYTE(this[1].__sig))
    {
      result = 1;
      goto LABEL_8;
    }
  }
  result = 0;
LABEL_8:
  if (!BYTE1(this[1].__sig))
    LOBYTE(this[1].__sig) = 0;
  return result;
}

void kdu_channel_mapping::kdu_channel_mapping(kdu_channel_mapping *this)
{
  *(_DWORD *)this = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  kdu_channel_mapping::clear(this);
}

void sub_187EFB37C(_Unwind_Exception *a1)
{
  uint64_t v1;

  jp2_colour_converter::clear((j2_colour_converter **)(v1 + 48));
  _Unwind_Resume(a1);
}

j2_colour_converter *kdu_channel_mapping::clear(kdu_channel_mapping *this)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*((_QWORD *)this + 5))
  {
    v2 = *(_DWORD *)this;
    if (*(int *)this < 1)
      goto LABEL_8;
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(*((_QWORD *)this + 5) + 8 * v3);
      if (v4)
      {
        MEMORY[0x18D761C18](v4, 0x1000C80BDFB0063);
        v2 = *(_DWORD *)this;
      }
      ++v3;
    }
    while (v3 < v2);
    if (*((_QWORD *)this + 5))
LABEL_8:
      MEMORY[0x18D761C18]();
  }
  *((_QWORD *)this + 5) = 0;
  v5 = *((_QWORD *)this + 1);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C8052888210);
  *((_QWORD *)this + 1) = 0;
  v6 = *((_QWORD *)this + 2);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x1000C8052888210);
  *((_QWORD *)this + 2) = 0;
  v7 = *((_QWORD *)this + 3);
  if (v7)
    MEMORY[0x18D761C18](v7, 0x1000C8077774924);
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = 0;
  *((_DWORD *)this + 8) = 0;
  return jp2_colour_converter::clear((j2_colour_converter **)this + 6);
}

int *kdu_channel_mapping::set_num_channels(int *this, int a2)
{
  int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  _DWORD *v12;
  _DWORD *v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (a2 < 0)
    kdu_channel_mapping::set_num_channels();
  v3 = this;
  if (*this < a2)
  {
    v5 = *((_QWORD *)this + 1);
    v4 = *((_QWORD *)this + 2);
    v6 = *((_QWORD *)this + 3);
    *((_QWORD *)this + 1) = operator new[]();
    *((_QWORD *)v3 + 2) = operator new[]();
    v7 = operator new[]();
    *((_QWORD *)v3 + 3) = v7;
    if (!v5)
    {
LABEL_14:
      if ((int)v5 < a2)
      {
        v11 = (_BYTE *)(*((_QWORD *)v3 + 3) + v5);
        v12 = (_DWORD *)(*((_QWORD *)v3 + 2) + 4 * v5);
        v13 = (_DWORD *)(*((_QWORD *)v3 + 1) + 4 * v5);
        v14 = a2 - (unint64_t)v5;
        do
        {
          *v13++ = -1;
          *v12++ = 8;
          *v11++ = 0;
          --v14;
        }
        while (v14);
      }
      v15 = *((_QWORD *)v3 + 5);
      this = (int *)operator new[]();
      *((_QWORD *)v3 + 5) = this;
      if (v15)
      {
        v16 = *v3;
        if (a2 >= *v3)
          v17 = *v3;
        else
          v17 = a2;
        if (v17 < 1)
        {
          v17 = 0;
        }
        else
        {
          v18 = 0;
          do
          {
            *(_QWORD *)(*((_QWORD *)v3 + 5) + v18) = *(_QWORD *)(v15 + v18);
            v18 += 8;
          }
          while (8 * v17 != v18);
        }
        if (v17 < v16)
        {
          v19 = v17;
          do
          {
            v20 = *(_QWORD *)(v15 + 8 * v19);
            if (v20)
            {
              MEMORY[0x18D761C18](v20, 0x1000C80BDFB0063);
              v16 = *v3;
            }
            ++v19;
          }
          while (v16 > (int)v19);
        }
        this = (int *)MEMORY[0x18D761C18](v15, 0x20C8093837F09);
      }
      else
      {
        v17 = 0;
      }
      if (v17 < a2)
      {
        v21 = v17;
        do
          *(_QWORD *)(*((_QWORD *)v3 + 5) + 8 * v21++) = 0;
        while (a2 != v21);
      }
      goto LABEL_36;
    }
    if (a2 && *v3 >= 1)
    {
      v8 = 0;
      v9 = *((_QWORD *)v3 + 1);
      v10 = *((_QWORD *)v3 + 2);
      do
      {
        *(_DWORD *)(v9 + 4 * v8) = *(_DWORD *)(v5 + 4 * v8);
        *(_DWORD *)(v10 + 4 * v8) = *(_DWORD *)(v4 + 4 * v8);
        *(_BYTE *)(v7 + v8) = *(_BYTE *)(v6 + v8);
        ++v8;
      }
      while (v8 < a2 && (uint64_t)v8 < *v3);
      MEMORY[0x18D761C18](v5, 0x1000C8052888210);
    }
    else
    {
      MEMORY[0x18D761C18](v5, 0x1000C8052888210);
      LODWORD(v8) = 0;
      LODWORD(v5) = 0;
      if (!v4)
        goto LABEL_12;
    }
    MEMORY[0x18D761C18](v4, 0x1000C8052888210);
    LODWORD(v5) = v8;
LABEL_12:
    if (v6)
      MEMORY[0x18D761C18](v6, 0x1000C8077774924);
    goto LABEL_14;
  }
LABEL_36:
  *v3 = a2;
  return this;
}

uint64_t kdu_channel_mapping::configure(kdu_channel_mapping *a1, unsigned int *a2)
{
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;

  v9 = a2;
  kdu_channel_mapping::clear(a1);
  if ((int)kdu_codestream::get_num_components(&v9, 1) < 3)
    v3 = 1;
  else
    v3 = 3;
  kdu_channel_mapping::set_num_channels((int *)a1, v3);
  v8 = 0;
  kdu_codestream::get_subsampling((kd_codestream **)&v9, 0, (uint64_t)&v8, 1);
  if (*(int *)a1 < 1)
  {
    LODWORD(v4) = 0;
  }
  else
  {
    v4 = 0;
    do
    {
      *(_DWORD *)(*((_QWORD *)a1 + 1) + 4 * v4) = v4;
      *(_DWORD *)(*((_QWORD *)a1 + 2) + 4 * v4) = kdu_codestream::get_bit_depth((kdu_codestream *)&v9, v4, 1);
      *(_BYTE *)(*((_QWORD *)a1 + 3) + v4) = kdu_codestream::get_signed((kdu_codestream *)&v9, v4, 1);
      v7 = 0;
      kdu_codestream::get_subsampling((kd_codestream **)&v9, v4, (uint64_t)&v7, 1);
      if (v7 != v8)
        break;
      ++v4;
    }
    while (v4 < *(int *)a1);
  }
  v5 = *(_DWORD *)a1;
  if ((int)v4 < *(_DWORD *)a1)
  {
    v5 = 1;
    *(_DWORD *)a1 = 1;
  }
  *((_DWORD *)a1 + 1) = v5;
  return 1;
}

uint64_t kdu_channel_mapping::configure(j2_colour_converter **a1, j2_colour *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  _BOOL4 v9;
  uint64_t v10;
  int num_colours;
  int v12;
  uint64_t v13;
  int num_entries;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  int v21;
  int v22[4];
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v27 = a3;
  v25 = a6;
  v26 = a5;
  kdu_channel_mapping::clear((kdu_channel_mapping *)a1);
  v9 = jp2_colour_converter::init(a1 + 6, a2, 0, 0);
  v10 = 0;
  if (v9)
  {
    num_colours = jp2_channels::get_num_colours((jp2_channels *)&v27);
    kdu_channel_mapping::set_num_channels((int *)a1, num_colours);
    v12 = *(_DWORD *)a1;
    *((_DWORD *)a1 + 1) = *(_DWORD *)a1;
    if (v12 <= 0)
    {
      v24 = 0;
      *(_OWORD *)v22 = 0u;
      v23 = 0u;
      kdu_error::kdu_error((kdu_error *)v22, "Error in Kakadu Region Decompressor:\n");
      kdu_error::~kdu_error((kdu_error *)v22);
    }
    if (v12 >= 17)
    {
      v24 = 0;
      *(_OWORD *)v22 = 0u;
      v23 = 0u;
      kdu_error::kdu_error((kdu_error *)v22, "Error in Kakadu Region Decompressor:\n");
      kdu_error::~kdu_error((kdu_error *)v22);
    }
    v13 = 0;
    while (1)
    {
      v21 = 0;
      v22[0] = 0;
      jp2_channels::get_colour_mapping((jp2_channels *)&v27, v13, (int *)a1[1] + v13, v22, &v21);
      if (v21 != a4)
        break;
      if (v22[0] < 0)
      {
        *((_DWORD *)a1[2] + v13) = jp2_dimensions::get_bit_depth((jp2_dimensions *)&v25, *((_DWORD *)a1[1] + v13));
        v19 = jp2_dimensions::get_signed((jp2_dimensions *)&v25, *((_DWORD *)a1[1] + v13));
      }
      else
      {
        num_entries = jp2_palette::get_num_entries((jp2_palette *)&v26);
        if (num_entries > 1024)
          kdu_channel_mapping::configure();
        v15 = num_entries;
        v16 = 0;
        do
          ++v16;
        while (1 << v16 < num_entries);
        *((_DWORD *)a1 + 8) = v16;
        if (*((_QWORD *)a1[5] + v13))
          kdu_channel_mapping::configure();
        *((_QWORD *)a1[5] + v13) = operator new[]();
        jp2_palette::get_lut(&v26, v22[0], *((_QWORD *)a1[5] + v13));
        if (v15 < 1 << *((_DWORD *)a1 + 8))
        {
          v17 = v15;
          do
          {
            v18 = *((_QWORD *)a1[5] + v13);
            *(_WORD *)(v18 + 2 * v17++) = *(_WORD *)(v18 + 2 * (v15 - 1));
          }
          while (v17 < 1 << *((_DWORD *)a1 + 8));
        }
        *((_DWORD *)a1[2] + v13) = jp2_palette::get_bit_depth((jp2_palette *)&v26, v22[0]);
        v19 = jp2_palette::get_signed((jp2_palette *)&v26, v22[0]);
      }
      *((_BYTE *)a1[3] + v13++) = v19;
      if (v13 >= *(int *)a1)
        return 1;
    }
    kdu_channel_mapping::clear((kdu_channel_mapping *)a1);
    return 0;
  }
  return v10;
}

void sub_187EFBAB8(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EFBAC4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t kdu_channel_mapping::add_alpha_to_configuration(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, char a6)
{
  int num_colours;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  BOOL v15;
  unsigned int i;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  uint64_t v20;
  int num_entries;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  int v28;
  int v29[2];
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v31 = a4;
  v32 = a2;
  v30 = a5;
  num_colours = jp2_channels::get_num_colours((jp2_channels *)&v32);
  kdu_channel_mapping::set_num_channels((int *)a1, *(_DWORD *)(a1 + 4));
  if (num_colours < 1)
    return 0;
  v10 = 0;
  v11 = -1;
  v12 = -1;
  do
  {
    v13 = v12;
    *(_QWORD *)v29 = 0;
    v14 = v11;
    v28 = 0;
    v12 = -1;
    if (jp2_channels::get_opacity_mapping((jp2_channels *)&v32, v10, v29, &v29[1], &v28))
    {
      v11 = -1;
      if (v28 == a3)
      {
        v12 = v29[0];
        if (v10)
        {
          v15 = v13 == v29[0] || v14 == v29[1];
          if (v15)
            v12 = v13;
          else
            v12 = -1;
          if (v15)
            v11 = v14;
          else
            v11 = -1;
        }
        else
        {
          v11 = v29[1];
        }
      }
    }
    else
    {
      v11 = -1;
    }
    ++v10;
  }
  while (num_colours != v10);
  if (v12 < 0 && (a6 & 1) == 0)
  {
    for (i = 0; i != num_colours; ++i)
    {
      *(_QWORD *)v29 = 0;
      v28 = 0;
      v17 = -1;
      if (jp2_channels::get_premult_mapping((jp2_channels *)&v32, i, v29, &v29[1], &v28))
      {
        v18 = -1;
        if (v28 == a3)
        {
          v17 = v29[0];
          if (i)
          {
            v19 = v12 == v29[0] || v11 == v29[1];
            if (v19)
              v17 = v12;
            else
              v17 = -1;
            if (v19)
              v18 = v11;
            else
              v18 = -1;
          }
          else
          {
            v18 = v29[1];
          }
        }
      }
      else
      {
        v18 = -1;
      }
      v11 = v18;
      v12 = v17;
    }
    if ((v17 & 0x80000000) == 0)
      goto LABEL_37;
    return 0;
  }
  v17 = v12;
  v18 = v11;
  if (v12 < 0)
    return 0;
LABEL_37:
  kdu_channel_mapping::set_num_channels((int *)a1, *(_DWORD *)(a1 + 4) + 1);
  v20 = *(int *)(a1 + 4);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v20) = v17;
  if ((v18 & 0x80000000) != 0)
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 16) + 4 * v20) = jp2_dimensions::get_bit_depth((jp2_dimensions *)&v30, v17);
    v26 = jp2_dimensions::get_signed((jp2_dimensions *)&v30, v17);
  }
  else
  {
    num_entries = jp2_palette::get_num_entries((jp2_palette *)&v31);
    if (num_entries > 1024)
      kdu_channel_mapping::add_alpha_to_configuration();
    v22 = num_entries;
    v23 = 0;
    do
      ++v23;
    while (1 << v23 < num_entries);
    *(_DWORD *)(a1 + 32) = v23;
    if (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v20))
      kdu_channel_mapping::add_alpha_to_configuration();
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v20) = operator new[]();
    jp2_palette::get_lut(&v31, v18, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v20));
    if (v22 < 1 << *(_DWORD *)(a1 + 32))
    {
      v24 = v22;
      do
      {
        v25 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v20);
        *(_WORD *)(v25 + 2 * v24++) = *(_WORD *)(v25 + 2 * (v22 - 1));
      }
      while (v24 < 1 << *(_DWORD *)(a1 + 32));
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 16) + 4 * v20) = jp2_palette::get_bit_depth((jp2_palette *)&v31, v18);
    v26 = jp2_palette::get_signed((jp2_palette *)&v31, v18);
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 24) + v20) = v26;
  return 1;
}

void kdu_region_decompressor::kdu_region_decompressor(kdu_region_decompressor *this)
{
  *(_QWORD *)this = &off_1E1BB2540;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 13) = 0;
  *(_QWORD *)((char *)this + 44) = 0;
  *((_BYTE *)this + 40) = 1;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_BYTE *)this + 120) = 0;
  *((_DWORD *)this + 55) = 0;
  *(_QWORD *)((char *)this + 188) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = 0;
  *(_DWORD *)((char *)this + 79) = 0;
  *(_QWORD *)((char *)this + 84) = 0;
  *(_QWORD *)((char *)this + 100) = 0;
  *(_QWORD *)((char *)this + 92) = 0;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 156) = 0u;
  *(_OWORD *)((char *)this + 140) = 0u;
  *(_OWORD *)((char *)this + 124) = 0u;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
}

void kdu_region_decompressor::~kdu_region_decompressor(kdu_region_decompressor *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = &off_1E1BB2540;
  *((_BYTE *)this + 80) = 1;
  kdu_region_decompressor::finish(this);
  v2 = *((_QWORD *)this + 25);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1020C809FEE3416);
  v3 = *((_QWORD *)this + 26);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8052888210);
  v4 = *((_QWORD *)this + 21);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1020C80E3042B83);
  v5 = *((_QWORD *)this + 29);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x10C80436913F5);
  v6 = *((_QWORD *)this + 8);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x1000C8077774924);
}

{
  kdu_region_decompressor::~kdu_region_decompressor(this);
  JUMPOUT(0x18D761C30);
}

uint64_t kdu_region_decompressor::finish(kdu_region_decompressor *this)
{
  kdu_thread_entity *v2;
  kdu_thread_queue *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;

  v2 = (kdu_thread_entity *)*((_QWORD *)this + 2);
  if (v2)
  {
    v3 = (kdu_thread_queue *)*((_QWORD *)this + 3);
    if (v3)
      kdu_thread_entity::terminate(v2, v3, 0, 0);
  }
  *((_QWORD *)this + 3) = 0;
  if (*((_BYTE *)this + 80))
  {
    v4 = 0;
  }
  else
  {
    if (*((_BYTE *)this + 120))
      kdu_tile::close((uint64_t **)this + 14, *((kdu_thread_entity **)this + 2));
    v4 = 1;
  }
  *((_BYTE *)this + 120) = 0;
  *((_BYTE *)this + 80) = 0;
  *((_QWORD *)this + 2) = 0;
  v5 = *((_QWORD *)this + 4);
  if (v5)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 16))(v5, 0);
    v6 = *((_QWORD *)this + 4);
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    *((_QWORD *)this + 4) = 0;
  }
  if (*((int *)this + 48) >= 1)
  {
    v7 = 0;
    v8 = 32;
    do
    {
      v9 = *((_QWORD *)this + 25) + v8;
      *(_QWORD *)(v9 - 8) = 0;
      *(_DWORD *)v9 = 0;
      *(_WORD *)(v9 + 6) = 0;
      *(_QWORD *)(v9 + 8) = 0;
      v10 = *((_QWORD *)this + 25) + v8;
      *(_DWORD *)(v10 + 16) = 0;
      *(_WORD *)(v10 + 22) = 0;
      *(_QWORD *)(v10 + 24) = 0;
      ++v7;
      v8 += 112;
    }
    while (v7 < *((int *)this + 48));
  }
  if (*((int *)this + 40) >= 1)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      for (i = 0; i != 48; i += 16)
      {
        v14 = *((_QWORD *)this + 21) + v11 + i;
        *(_DWORD *)(v14 + 8) = 0;
        *(_WORD *)(v14 + 14) = 0;
        *(_QWORD *)(v14 + 16) = 0;
      }
      v15 = *((_QWORD *)this + 21) + 96 * v12++;
      *(_OWORD *)(v15 + 72) = 0uLL;
      *(_OWORD *)(v15 + 56) = 0uLL;
      v11 += 96;
    }
    while (v12 < *((int *)this + 40));
  }
  *((_QWORD *)this + 9) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_BYTE *)this + 40) = 1;
  *((_DWORD *)this + 48) = 0;
  *(_QWORD *)((char *)this + 148) = 0;
  *(_QWORD *)((char *)this + 140) = 0;
  return v4;
}

uint64_t kdu_region_decompressor::set_num_channels(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;

  v3 = this;
  if (*(_DWORD *)(this + 156) < a2)
  {
    *(_DWORD *)(this + 156) = a2;
    v4 = *(_QWORD *)(this + 168);
    v5 = a2;
    if (v4)
    {
      MEMORY[0x18D761C18](v4, 0x1020C80E3042B83);
      v5 = *(_DWORD *)(v3 + 156);
    }
    is_mul_ok(v5, 0x60uLL);
    this = operator new[]();
    if (v5)
    {
      v6 = this;
      do
      {
        v7 = 8;
        do
        {
          v8 = v6 + v7;
          *(_DWORD *)v8 = 0;
          *(_WORD *)(v8 + 6) = 0;
          *(_QWORD *)(v8 + 8) = 0;
          v7 += 16;
        }
        while (v8 + 16 != v6 + 56);
        v6 += 96;
      }
      while (v6 != this + 96 * v5);
    }
    *(_QWORD *)(v3 + 168) = this;
  }
  *(_DWORD *)(v3 + 160) = a2;
  *(_DWORD *)(v3 + 164) = a2;
  if (a2 >= 1)
  {
    v9 = a2;
    v10 = (_BYTE *)(*(_QWORD *)(v3 + 168) + 92);
    do
    {
      *(_QWORD *)(v10 - 92) = 0;
      *(_QWORD *)(v10 - 12) = 0;
      *((_DWORD *)v10 - 1) = 0;
      *v10 = 0;
      v10 += 96;
      --v9;
    }
    while (v9);
  }
  return this;
}

uint64_t kdu_region_decompressor::add_component(kdu_region_decompressor *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t result;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  int *v26;
  _DWORD *v27;
  int *v28;
  int v29;
  uint64_t v30;

  v4 = *((unsigned int *)this + 48);
  if ((int)v4 < 1)
  {
LABEL_5:
    if ((_DWORD)v4 != *((_DWORD *)this + 47))
      goto LABEL_27;
    v8 = 2 * v4;
    v9 = (2 * v4) | 1;
    *((_DWORD *)this + 47) = v9;
    v10 = *((_QWORD *)this + 25);
    is_mul_ok(v9, 0x70uLL);
    v11 = operator new[]();
    v12 = 0;
    do
    {
      v13 = v11 + v12;
      *(_DWORD *)(v13 + 32) = 0;
      *(_QWORD *)(v13 + 38) = 0;
      *(_QWORD *)(v13 + 44) = 0;
      *(_OWORD *)(v13 + 54) = 0uLL;
      *(_OWORD *)(v13 + 70) = 0uLL;
      *(_OWORD *)(v13 + 86) = 0uLL;
      v12 += 112;
      *(_OWORD *)(v13 + 96) = 0uLL;
    }
    while (112 * v8 + 112 != v12);
    *((_QWORD *)this + 25) = v11;
    if (*((int *)this + 48) < 1)
    {
      if (!v10)
      {
LABEL_21:
        v26 = (int *)*((_QWORD *)this + 26);
        v27 = (_DWORD *)operator new[]();
        *((_QWORD *)this + 26) = v27;
        v4 = *((unsigned int *)this + 48);
        if ((int)v4 < 1)
        {
          if (!v26)
            goto LABEL_27;
        }
        else
        {
          v28 = v26;
          do
          {
            v29 = *v28++;
            *v27++ = v29;
            --v4;
          }
          while (v4);
        }
        MEMORY[0x18D761C18](v26, 0x1000C8052888210);
        LODWORD(v4) = *((_DWORD *)this + 48);
LABEL_27:
        *((_DWORD *)this + 48) = v4 + 1;
        v30 = *((_QWORD *)this + 25);
        *(_DWORD *)(*((_QWORD *)this + 26) + 4 * (int)v4) = a2;
        result = v30 + 112 * (int)v4;
        *(_DWORD *)result = v4;
        *(_DWORD *)(result + 8) = 0;
        *(_BYTE *)(result + 17) = 0;
        return result;
      }
    }
    else
    {
      v14 = 0;
      v15 = 0;
      do
      {
        v16 = (_OWORD *)(*((_QWORD *)this + 25) + v14);
        v17 = *(_OWORD *)(v10 + v14);
        v18 = *(_OWORD *)(v10 + v14 + 32);
        v16[1] = *(_OWORD *)(v10 + v14 + 16);
        v16[2] = v18;
        *v16 = v17;
        v19 = *(_OWORD *)(v10 + v14 + 48);
        v20 = *(_OWORD *)(v10 + v14 + 64);
        v21 = *(_OWORD *)(v10 + v14 + 96);
        v16[5] = *(_OWORD *)(v10 + v14 + 80);
        v16[6] = v21;
        v16[3] = v19;
        v16[4] = v20;
        ++v15;
        v14 += 112;
      }
      while (v15 < *((int *)this + 48));
    }
    MEMORY[0x18D761C18](v10, 0x1020C809FEE3416);
    v23 = *((unsigned int *)this + 40);
    if ((int)v23 >= 1)
    {
      v24 = (_QWORD *)*((_QWORD *)this + 21);
      do
      {
        if (*v24)
        {
          v25 = 0x6DB6DB6DB6DB6DB7 * ((*v24 - v10) >> 4);
          if ((v25 & 0x80000000) != 0 || *((_DWORD *)this + 48) <= (int)v25)
            kdu_region_decompressor::add_component();
          *v24 = *((_QWORD *)this + 25) + 112 * (int)v25;
        }
        v24 += 12;
        --v23;
      }
      while (v23);
    }
    goto LABEL_21;
  }
  v5 = 0;
  v6 = (int *)*((_QWORD *)this + 26);
  while (1)
  {
    v7 = *v6++;
    if (v7 == a2)
      return *((_QWORD *)this + 25) + v5;
    v5 += 112;
    if (112 * v4 == v5)
      goto LABEL_5;
  }
}

unint64_t find_render_dims(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *exception;

  v4 = a4 >> 32;
  v5 = (a3 >> 32) - 1;
  v6 = SHIDWORD(a3) * (uint64_t)SHIDWORD(a1) - (v5 >> 1);
  if (a4 >> 32 <= 1)
    v4 = 1;
  if (v6 <= 0)
  {
    v8 = ((v5 >> 1) - SHIDWORD(a3) * (uint64_t)SHIDWORD(a1)) / v4;
    if (v8 >= 0x80000001)
      goto LABEL_24;
    v7 = -(uint64_t)v8;
  }
  else
  {
    v7 = (v6 - 1) / v4;
    if (v7 >= 0x7FFFFFFF)
      goto LABEL_24;
    LODWORD(v7) = v7 + 1;
  }
  v9 = v5 >> 1;
  v10 = (int)(((a2 & 0xFFFFFFFF00000000) + a1) >> 32) * (uint64_t)SHIDWORD(a3);
  v11 = v10 <= v9;
  v12 = v10 - v9;
  if (v11)
  {
    if (-v12 / v4 >= 0x80000001)
      goto LABEL_24;
  }
  else if ((v12 - 1) / v4 >= 0x7FFFFFFF)
  {
    goto LABEL_24;
  }
  v13 = (int)a4;
  v14 = (int)a3 - 1;
  v15 = (int)a3 * (uint64_t)(int)a1 - (v14 >> 1);
  if ((int)a4 <= 1)
    v13 = 1;
  if (v15 <= 0)
  {
    v17 = ((v14 >> 1) - (int)a3 * (uint64_t)(int)a1) / v13;
    if (v17 >= 0x80000001)
      goto LABEL_24;
    v16 = -(uint64_t)v17;
  }
  else
  {
    v16 = (v15 - 1) / v13;
    if (v16 >= 0x7FFFFFFF)
      goto LABEL_24;
    LODWORD(v16) = v16 + 1;
  }
  v18 = v14 >> 1;
  v19 = ((int)a2 + (int)a1) * (uint64_t)(int)a3;
  v11 = v19 <= v18;
  v20 = v19 - v18;
  if (!v11)
  {
    if ((v20 - 1) / v13 < 0x7FFFFFFF)
      return v16 | ((unint64_t)v7 << 32);
LABEL_24:
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  if (-v20 / v13 >= 0x80000001)
    goto LABEL_24;
  return v16 | ((unint64_t)v7 << 32);
}

uint64_t kdu_region_decompressor::start(kdu_region_decompressor *this, kd_codestream *a2, int *a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, int a12, char a13, uint64_t a14, char *a15)
{
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  int v34;
  int32x4_t *v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  int8x8_t *v51;
  _DWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _WORD *v57;
  uint64_t v58;
  int v59;
  int v60;
  BOOL v61;
  int v62;
  uint64_t v63;
  __int32 v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  __int32 v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  int v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _DWORD *exception;
  int32x4_t *v82;
  int v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  __int128 v94;
  kd_codestream *v95[2];

  v21 = a14;
  *((_QWORD *)&v94 + 1) = a8;
  v95[0] = a2;
  *(_QWORD *)&v94 = a7;
  *((_QWORD *)this + 2) = a14;
  if (a14)
    v21 = kdu_thread_entity::add_queue(a14, 0, a15, (uint64_t)"region decompressor");
  *(_QWORD *)((char *)this + 140) = 0;
  *((_QWORD *)this + 3) = v21;
  *((_QWORD *)this + 9) = a2;
  *((_BYTE *)this + 81) = a11;
  *((_BYTE *)this + 82) = a13;
  *((_BYTE *)this + 80) = 0;
  *((_BYTE *)this + 120) = 0;
  *((_DWORD *)this + 54) = a5;
  *((_DWORD *)this + 48) = 0;
  *((_WORD *)this + 92) = 0;
  *((_QWORD *)this + 22) = 0;
  *(_QWORD *)((char *)this + 148) = 0;
  if (a3)
  {
    if (*a3 <= 0)
    {
      v93 = 0;
      v91 = 0u;
      v92 = 0u;
      kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
      kdu_error::~kdu_error((kdu_error *)&v91);
    }
    kdu_region_decompressor::set_num_channels((uint64_t)this, *a3);
    v22 = a3[1];
    *((_DWORD *)this + 41) = v22;
    if (v22 > *((_DWORD *)this + 40))
    {
      v93 = 0;
      v91 = 0u;
      v92 = 0u;
      kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
      kdu_error::~kdu_error((kdu_error *)&v91);
    }
    v23 = *((_QWORD *)a3 + 6);
    *((_QWORD *)this + 22) = a3 + 12;
    if (v23 && jp2_colour_converter::is_non_trivial((jp2_colour_converter *)(a3 + 12)))
    {
      v24 = *((_QWORD *)this + 22);
    }
    else
    {
      v24 = 0;
      *((_QWORD *)this + 22) = 0;
    }
    *((_BYTE *)this + 184) = v24 != 0;
    if (*a3 >= 1)
    {
      v25 = 0;
      v26 = 0;
      do
      {
        v27 = kdu_region_decompressor::add_component(this, *(_DWORD *)(*((_QWORD *)a3 + 1) + 4 * v26));
        v28 = *((_QWORD *)this + 21);
        *(_QWORD *)(v28 + v25) = v27;
        v29 = a3[8];
        if (v29 <= 0)
        {
          *(_QWORD *)(v28 + v25 + 80) = 0;
        }
        else
        {
          v30 = *(_QWORD *)(*((_QWORD *)a3 + 5) + 8 * v26);
          *(_QWORD *)(v28 + v25 + 80) = v30;
          if (v30)
            *(_DWORD *)(v27 + 8) = v29;
        }
        v31 = v28 + v25;
        *(_DWORD *)(v31 + 88) = *(_DWORD *)(*((_QWORD *)a3 + 2) + 4 * v26);
        *(_BYTE *)(v31 + 92) = *(_BYTE *)(*((_QWORD *)a3 + 3) + v26++);
        *(_QWORD *)(v31 + 64) = 0;
        *(_QWORD *)(v31 + 72) = 0;
        *(_QWORD *)(v31 + 56) = 0;
        v25 += 96;
      }
      while (v26 < *a3);
    }
  }
  else
  {
    kdu_region_decompressor::set_num_channels((uint64_t)this, 1);
    v32 = kdu_region_decompressor::add_component(this, a4);
    v33 = (uint64_t *)*((_QWORD *)this + 21);
    *v33 = v32;
    v33[10] = 0;
  }
  if (SHIDWORD(a10) < 1 || (int)a10 <= 0)
  {
    v93 = 0;
    v91 = 0u;
    v92 = 0u;
    kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
    kdu_error::~kdu_error((kdu_error *)&v91);
  }
  if (SHIDWORD(a9) < SHIDWORD(a10) || (int)a9 < (int)a10)
  {
    v93 = 0;
    v91 = 0u;
    v92 = 0u;
    kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
    kdu_error::~kdu_error((kdu_error *)&v91);
  }
  v34 = a12;
  kdu_codestream::apply_input_restrictions((uint64_t)v95, *((_DWORD *)this + 48), *((_QWORD *)this + 26), a5, a6, 0, a12);
  v84 = a5;
  v35 = (int32x4_t *)**((_QWORD **)this + 21);
  v89 = 0;
  v90 = 0;
  kdu_codestream::get_subsampling(v95, v35->i32[0], (uint64_t)&v90, 1);
  v36 = v90;
  v37 = HIDWORD(v90);
  LODWORD(v38) = *((_DWORD *)this + 48);
  if ((int)v38 >= 1)
  {
    v82 = v35;
    v83 = a6;
    v39 = 0;
    v40 = 0;
    do
    {
      v41 = *((_QWORD *)this + 25);
      v42 = v41 + v39;
      *(_DWORD *)(v41 + v39 + 4) = kdu_codestream::get_bit_depth((kdu_codestream *)v95, *(_DWORD *)(v41 + v39), 1);
      *(_BYTE *)(v42 + 16) = kdu_codestream::get_signed((kdu_codestream *)v95, *(_DWORD *)(v41 + v39), 1);
      *(_DWORD *)(v42 + 12) = 0;
      kdu_codestream::get_subsampling(v95, *(_DWORD *)(v41 + v39), (uint64_t)&v89, 1);
      if (SHIDWORD(v89) > v37)
        v37 = HIDWORD(v89);
      v88 = SHIDWORD(a9) * (uint64_t)SHIDWORD(v89);
      v86 = SHIDWORD(a10) * (uint64_t)SHIDWORD(v90);
      if ((int)v89 > v36)
        v36 = v89;
      v87 = (int)a9 * (uint64_t)(int)v89;
      v85 = (int)a10 * (uint64_t)(int)v90;
      if ((reduce_ratio_to_ints(&v88, &v86) & 1) == 0 || (reduce_ratio_to_ints(&v87, &v85) & 1) == 0)
      {
        v93 = 0;
        v91 = 0u;
        v92 = 0u;
        kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
        (*(void (**)(__int128 *, const char *))(v91 + 16))(&v91, "Unable to represent all component expansion factors as rational numbers whose numerator and denominator can both be expressed as 32-bit signed integers.  This is a very unusual condition.");
        kdu_error::~kdu_error((kdu_error *)&v91);
      }
      v43 = v88;
      v44 = v86;
      if (v88 < v86 || v87 < v85)
      {
        v93 = 0;
        v91 = 0u;
        v92 = 0u;
        kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
        kdu_error::~kdu_error((kdu_error *)&v91);
      }
      v45 = v88 / v86;
      if (!(v88 % v86))
      {
        v88 /= v86;
        v86 = 1;
        v44 = 1;
        v43 = v45;
      }
      v46 = v87;
      v47 = v85;
      v48 = v87 / v85;
      if (!(v87 % v85))
      {
        v87 /= v85;
        v85 = 1;
        v47 = 1;
        v46 = v48;
      }
      v49 = v41 + v39;
      *(_DWORD *)(v49 + 80) = v46;
      *(_DWORD *)(v49 + 84) = v43;
      *(_DWORD *)(v49 + 88) = v47;
      *(_DWORD *)(v49 + 92) = v44;
      *(_QWORD *)(v49 + 96) = 0;
      v50 = *(_DWORD *)(v41 + v39);
      v51 = (int8x8_t *)(v41 + v39 + 104);
      kdu_codestream::get_registration(v95, v50, *(_QWORD *)(v49 + 88), v51, 1);
      if (v39)
      {
        if (*((_BYTE *)this + 184))
        {
          v52 = (_DWORD *)*((_QWORD *)this + 25);
          if (*(_DWORD *)(v49 + 80) != v52[20] || *(_DWORD *)(v49 + 88) != v52[22] || v51->i32[0] != v52[26])
            *((_WORD *)this + 92) = 256;
        }
      }
      ++v40;
      v38 = *((int *)this + 48);
      v39 += 112;
    }
    while (v40 < v38);
    v34 = a12;
    a6 = v83;
    v35 = v82;
  }
  v53 = *((unsigned int *)this + 40);
  if ((int)v53 >= 1)
  {
    v54 = *((_QWORD *)this + 21) + 88;
    v55 = *((unsigned int *)this + 40);
    do
    {
      if (!*(_DWORD *)v54)
      {
        v56 = *(_QWORD *)(v54 - 88);
        *(_DWORD *)v54 = *(_DWORD *)(v56 + 4);
        *(_BYTE *)(v54 + 4) = *(_BYTE *)(v56 + 16);
      }
      v54 += 96;
      --v55;
    }
    while (v55);
    v57 = (_WORD *)(*((_QWORD *)this + 21) + 94);
    do
    {
      v58 = *(_QWORD *)(v57 - 47);
      ++*(_DWORD *)(v58 + 12);
      *v57 = 0;
      if (!*(_QWORD *)(v57 - 7))
      {
        v59 = *((_DWORD *)this + 2);
        if (v59 >= 16)
          v59 = 16;
        v60 = *(_DWORD *)(v58 + 4);
        v61 = __OFSUB__(v59, v60);
        v62 = v59 - v60;
        if (!((v62 < 0) ^ v61 | (v62 == 0)))
          *v57 = ((0x10000 << v62) - 0x10000) / ((-1 << v62) + (1 << v59));
      }
      v57 += 48;
      --v53;
    }
    while (v53);
  }
  kdu_codestream::apply_input_restrictions((uint64_t)v95, v38, *((_QWORD *)this + 26), v84, a6, 0, v34);
  kdu_codestream::get_dims((kdu_codestream *)v95, v35->i32[0], v35 + 4, 1);
  *(_QWORD *)((char *)this + 140) = find_render_dims(v35[4].i64[0], v35[4].i64[1], v35[5].i64[0], v35[5].i64[1]);
  *(_QWORD *)((char *)this + 148) = v63;
  v91 = *(_OWORD *)((char *)this + 140);
  kdu_dims::operator&=(&v91, (int *)&v94);
  if (v94 != v91)
  {
    v93 = 0;
    v91 = 0u;
    v92 = 0u;
    kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
    kdu_error::~kdu_error((kdu_error *)&v91);
  }
  v64 = v35[5].i32[3];
  LODWORD(v65) = v35[5].i32[1];
  v66 = SDWORD1(v94) * (uint64_t)v64;
  if ((int)v65 <= 1)
    v65 = 1;
  else
    v65 = v65;
  if ((v66 & 0x8000000000000000) != 0)
  {
    v67 = ~v66 / v65;
    if (v67 >> 31)
      goto LABEL_92;
    LODWORD(v67) = ~(_DWORD)v67;
  }
  else
  {
    v67 = v66 / v65;
    if (v67 >> 31)
      goto LABEL_83;
  }
  v68 = v64 * (uint64_t)(HIDWORD(v91) + DWORD1(v94));
  if (v68 <= 0)
  {
    v70 = -v68 / v65;
    if (v70 > 0x80000000)
      goto LABEL_94;
    v69 = -(uint64_t)v70;
  }
  else
  {
    v69 = (v68 - 1) / v65;
    if (v69 > 0x7FFFFFFE)
      goto LABEL_94;
    LODWORD(v69) = v69 + 1;
  }
  v71 = v35[5].i32[2];
  LODWORD(v72) = v35[5].i32[0];
  v73 = (int)v94 * (uint64_t)v71;
  if ((int)v72 <= 1)
    v72 = 1;
  else
    v72 = v72;
  if ((v73 & 0x8000000000000000) != 0)
  {
    v74 = ~v73 / v72;
    if (!(v74 >> 31))
    {
      LODWORD(v74) = ~(_DWORD)v74;
      goto LABEL_86;
    }
LABEL_92:
    v75 = "(num >= (kdu_long) KDU_INT32_MIN)";
    v76 = 254;
LABEL_93:
    __assert_rtn("long_floor_ratio", "kdu_utils.h", v76, v75);
  }
  v74 = v73 / v72;
  if (v74 >> 31)
  {
LABEL_83:
    v75 = "(num <= (kdu_long) KDU_INT32_MAX)";
    v76 = 259;
    goto LABEL_93;
  }
LABEL_86:
  v77 = v71 * (uint64_t)(DWORD2(v91) + (int)v94);
  if (v77 <= 0)
  {
    v79 = -v77 / v72;
    if (v79 <= 0x80000000)
    {
      v78 = -(uint64_t)v79;
      goto LABEL_91;
    }
LABEL_94:
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v78 = (v77 - 1) / v72;
  if (v78 >= 0x7FFFFFFF)
    goto LABEL_94;
  LODWORD(v78) = v78 + 1;
LABEL_91:
  v91 = 0uLL;
  kdu_codestream::map_region((uint64_t *)v95, v35->i32[0], (v74 - 2 * v36 / (int)v90) | ((unint64_t)(v67 - 2 * v37 / SHIDWORD(v90)) << 32), (2 * v36 / (int)v90 - (v74 - 2 * v36 / (int)v90) + v78) | ((unint64_t)(2 * v37 / SHIDWORD(v90) - (v67 - 2 * v37 / SHIDWORD(v90)) + v69) << 32), (uint64_t)&v91, 1);
  kdu_codestream::apply_input_restrictions((uint64_t)v95, *((_DWORD *)this + 48), *((_QWORD *)this + 26), v84, a6, (int *)&v91, v34);
  kdu_codestream::get_valid_tiles((kdu_codestream *)v95, (int32x4_t *)((char *)this + 84));
  *(_QWORD *)((char *)this + 100) = *(_QWORD *)((char *)this + 84);
  *((_BYTE *)this + 120) = 0;
  return 1;
}

void sub_187EFCEFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EFCF0C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  kdu_region_decompressor *v23;
  int v24;
  _Unwind_Exception *v25;
  unsigned int *v26;

  if (v24 == 1)
  {
    v26 = (unsigned int *)__cxa_begin_catch(v25);
    if (a9)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a9 + 32))(a9, *v26);
    kdu_region_decompressor::finish(v23);
    __cxa_end_catch();
    JUMPOUT(0x187EFCE94);
  }
  _Unwind_Resume(v25);
}

uint64_t reduce_ratio_to_ints(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *a1;
  if (*a1 < 1)
    return 0;
  v3 = *a2;
  if (*a2 < 1)
    return 0;
  if (!(v2 % (unint64_t)v3))
  {
    *a1 = v2 / (unint64_t)v3;
    v3 = 1;
    *a2 = 1;
    v2 = *a1;
  }
  if (v2 <= 0x7FFFFFFF && !((unint64_t)v3 >> 31))
    return 1;
  v5 = 2;
  while (1)
  {
    if (v2 >= v3)
      v6 = v3;
    else
      v6 = v2;
    while (v2 % v5 || v3 % v5)
    {
      if (++v5 >= v6)
        return 0;
    }
    *a1 = v2 / v5;
    v3 = *a2 / v5;
    *a2 = v3;
    v2 = *a1;
    if (*a1 <= 0x7FFFFFFF)
    {
      v4 = 1;
      if (v3 <= 0x7FFFFFFF)
        break;
    }
  }
  return v4;
}

kdu_thread_entity *kdu_region_decompressor::open_tile(kdu_region_decompressor *this)
{
  unint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int32x4_t *v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _BYTE *v13;
  uint64_t v14;
  BOOL v15;
  kdu_thread_entity *result;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  char *v36;
  uint64_t v37;
  uint64_t j;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t k;
  _QWORD *v46;
  _DWORD *exception;
  __int128 v48;

  if (*((_BYTE *)this + 120))
    kdu_region_decompressor::open_tile();
  if (*((_DWORD *)this + 25) - *((_DWORD *)this + 21) >= *((_DWORD *)this + 23)
    || *((_DWORD *)this + 26) - *((_DWORD *)this + 22) >= *((_DWORD *)this + 24))
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v2 = *(_QWORD *)((char *)this + 100);
  *((_QWORD *)this + 14) = kdu_codestream::open_tile((uint64_t *)this + 9, v2, *((kdu_thread_entity **)this + 2));
  if ((int)kdu_codestream::get_min_dwt_levels((kdu_region_decompressor *)((char *)this + 72)) < *((_DWORD *)this + 54)
    || !kdu_codestream::can_flip((kdu_region_decompressor *)((char *)this + 72)))
  {
    return kdu_tile::close((uint64_t **)this + 14, *((kdu_thread_entity **)this + 2));
  }
  *((_BYTE *)this + 120) = 1;
  v3 = *((_DWORD *)this + 26) + 1;
  *((_DWORD *)this + 26) = v3;
  v4 = *((_DWORD *)this + 22);
  if (v3 - v4 >= *((_DWORD *)this + 24))
  {
    ++*((_DWORD *)this + 25);
    *((_DWORD *)this + 26) = v4;
  }
  if (*((int *)this + 48) >= 1)
  {
    v5 = 0;
    v6 = 0;
    do
    {
      v7 = (int32x4_t *)(*((_QWORD *)this + 25) + v5);
      v7[1].i64[1] = 0;
      v7[1].i8[1] = *((_BYTE *)this + 81) ^ 1;
      v7[1].i8[3] = 0;
      kdu_codestream::get_tile_dims((uint64_t *)this + 9, v2, v7->i32[0], v7 + 4, 1);
      ++v6;
      v5 += 112;
    }
    while (v6 < *((int *)this + 48));
  }
  kdu_multi_synthesis::create((uint64_t *)this + 4, *((_QWORD *)this + 9), *((uint64_t **)this + 14), *((unsigned __int8 *)this + 81), 0, *((_BYTE *)this + 82), 1, *((kdu_thread_entity **)this + 2), *((char **)this + 3), 0);
  if (*((int *)this + 48) >= 1)
  {
    v8 = 0;
    for (i = 0; i < *((int *)this + 48); ++i)
    {
      v10 = *((_QWORD *)this + 25);
      v11 = v10 + v8;
      v12 = (*(uint64_t (**)(_QWORD, _QWORD))(**((_QWORD **)this + 4) + 40))(*((_QWORD *)this + 4), *(unsigned int *)(v10 + v8));
      *(_BYTE *)(v10 + v8 + 17) = v12 ^ 1;
      if (*(int *)(v10 + v8 + 72) <= 0)
        kdu_line_buf::pre_create((kdu_line_buf *)(v11 + 32), (kdu_region_decompressor *)((char *)this + 40), *(_DWORD *)(v11 + 76), 0, v12 ^ 1, 2u, 2);
      if (*(int *)(v11 + 8) >= 1)
        kdu_line_buf::pre_create((kdu_line_buf *)(v10 + v8 + 48), (kdu_region_decompressor *)((char *)this + 40), *(_DWORD *)(v10 + v8 + 76), 1, 1, 2u, 2);
      if (*(_DWORD *)(v10 + v8 + 12) == 1
        && !*(_DWORD *)(v11 + 8)
        && *(_BYTE *)(v11 + 17)
        && (v14 = v10 + v8, *(_DWORD *)(v10 + v8 + 84) == 1))
      {
        v15 = *(_DWORD *)(v14 + 92) == 1;
        *(_BYTE *)(v14 + 18) = v15;
        v13 = (_BYTE *)(v14 + 18);
        if (!v15
          || !(*(unsigned int (**)(_QWORD, _QWORD))(**((_QWORD **)this + 4) + 48))(*((_QWORD *)this + 4), *(unsigned int *)(v10 + v8)))
        {
          goto LABEL_21;
        }
      }
      else
      {
        v13 = (_BYTE *)(v10 + 112 * i + 18);
      }
      *v13 = 0;
LABEL_21:
      v8 += 112;
    }
  }
  v17 = (uint64_t *)*((_QWORD *)this + 21);
  v18 = *v17;
  *(_QWORD *)((char *)this + 124) = find_render_dims(*(_QWORD *)(*v17 + 64), *(_QWORD *)(*v17 + 72), *(_QWORD *)(*v17 + 80), *(_QWORD *)(*v17 + 88));
  *(_QWORD *)((char *)this + 132) = v19;
  v48 = *(_OWORD *)((char *)this + 140);
  kdu_dims::operator&=(&v48, (int *)this + 31);
  v20 = v48;
  v21 = DWORD1(v48);
  if (*(_QWORD *)((char *)this + 124) != (_QWORD)v48 || *(_QWORD *)((char *)this + 132) != *((_QWORD *)&v48 + 1))
    kdu_region_decompressor::open_tile();
  v22 = *((unsigned int *)this + 48);
  if ((int)v22 >= 1)
  {
    v23 = (_DWORD *)(*((_QWORD *)this + 25) + 108);
    do
    {
      v25 = (int)*(v23 - 7);
      v24 = (int)*(v23 - 6);
      v26 = v24 - ((v24 + 4) >> 3);
      v27 = *(v23 - 5);
      v28 = *(v23 - 4);
      if (v28 == 1)
        v26 = (v24 - 1) >> 1;
      v29 = *v23 - *(_DWORD *)(v18 + 108) + v24 + v24 * *(v23 - 10) - (v26 + v21 * v28);
      v30 = v25 - ((v25 + 4) >> 3);
      if (v27 == 1)
        v30 = (v25 - 1) >> 1;
      *(v23 - 3) = *(v23 - 1) - *(_DWORD *)(v18 + 104) + v25 + v25 * *(v23 - 11) - (v30 + v20 * v27);
      *(v23 - 2) = v29;
      v23 += 28;
      --v22;
    }
    while (v22);
  }
  if (*((int *)this + 40) >= 1)
  {
    v31 = 0;
    v32 = 0;
    do
    {
      v33 = *((_QWORD *)this + 21);
      v34 = v33 + 96 * v32;
      v35 = *(_BYTE *)(*(_QWORD *)v34 + 17);
      if (*(_QWORD *)(v34 + 80))
        v35 = 1;
      *(_BYTE *)(v34 + 93) = v35;
      v36 = (char *)(v34 + 93);
      if (*((_QWORD *)this + 22))
        v35 = 1;
      *v36 = v35;
      v37 = v33 + v31;
      for (j = 8; j != 56; j += 16)
        kdu_line_buf::pre_create((kdu_line_buf *)(v37 + j), (kdu_region_decompressor *)((char *)this + 40), *((_DWORD *)this + 34), 0, *v36, 2u, 2);
      ++v32;
      v31 += 96;
    }
    while (v32 < *((int *)this + 40));
  }
  result = (kdu_thread_entity *)kdu_sample_allocator::finalize((uint64_t)this + 40);
  if (*((int *)this + 48) >= 1)
  {
    v39 = 0;
    v40 = 0;
    do
    {
      v41 = *((_QWORD *)this + 25);
      if (*(int *)(v41 + v39 + 8) >= 1)
      {
        result = (kdu_thread_entity *)kdu_line_buf::create(v41 + v39 + 48);
        v41 = *((_QWORD *)this + 25);
      }
      v42 = v41 + v39;
      if (*(int *)(v42 + 72) <= 0)
        result = (kdu_thread_entity *)kdu_line_buf::create(v42 + 32);
      ++v40;
      v39 += 112;
    }
    while (v40 < *((int *)this + 48));
  }
  if (*((int *)this + 40) >= 1)
  {
    v43 = 0;
    v44 = 0;
    do
    {
      for (k = 8; k != 56; k += 16)
        result = (kdu_thread_entity *)kdu_line_buf::create(*((_QWORD *)this + 21) + v43 + k);
      v46 = (_QWORD *)(*((_QWORD *)this + 21) + 96 * v44++);
      v46[7] = 0;
      v46[8] = 0;
      v46[9] = 0;
      v43 += 96;
    }
    while (v44 < *((int *)this + 40));
  }
  return result;
}

uint64_t kdu_line_buf::pre_create(kdu_line_buf *this, kdu_sample_allocator *a2, int a3, char a4, int a5, unsigned __int8 a6, char a7)
{
  char v11;
  char v12;
  unsigned __int8 v13;
  uint64_t result;

  if (*((_BYTE *)this + 7) || *((_QWORD *)this + 1))
    kdu_line_buf::pre_create();
  *(_DWORD *)this = a3;
  if (a5)
    v11 = 2;
  else
    v11 = 0;
  *((_BYTE *)this + 6) = v11 | a4;
  *((_QWORD *)this + 1) = a2;
  *((_BYTE *)this + 4) = a6;
  if (a5)
    v12 = 7;
  else
    v12 = 3;
  v13 = (v12 & -a7) + a7;
  *((_BYTE *)this + 5) = v13;
  kdu_sample_allocator::pre_alloc((uint64_t)a2, a5, a6, a3 + v13, 1);
  result = kdu_sample_allocator::pre_alloc((uint64_t)a2, a5, *((unsigned __int8 *)this + 4), *((unsigned __int8 *)this + 5) + a3, 1);
  *((_BYTE *)this + 7) = 1;
  return result;
}

uint64_t kdu_sample_allocator::finalize(uint64_t this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;

  if (!*(_BYTE *)this)
    kdu_sample_allocator::finalize();
  v1 = this;
  *(_BYTE *)this = 0;
  v2 = *(_DWORD *)(this + 4);
  if (v2 > *(_DWORD *)(this + 12))
  {
    *(_DWORD *)(this + 12) = v2;
    v3 = *(_QWORD *)(this + 24);
    if (v3)
      MEMORY[0x18D761C18](v3, 0x1000C8077774924);
    this = operator new[]();
    *(_QWORD *)(v1 + 16) = this + (this & 8);
    *(_QWORD *)(v1 + 24) = this;
    v2 = *(_DWORD *)(v1 + 4);
  }
  if (v2)
  {
    if (!*(_QWORD *)(v1 + 16))
      kdu_sample_allocator::finalize();
  }
  return this;
}

uint64_t kdu_line_buf::create(uint64_t this)
{
  uint64_t v1;
  char v2;
  kdu_sample_allocator *v3;
  int v4;
  int v5;

  if (*(_BYTE *)(this + 7))
  {
    v1 = this;
    *(_BYTE *)(this + 7) = 0;
    v2 = *(_BYTE *)(this + 6);
    v3 = *(kdu_sample_allocator **)(this + 8);
    v4 = *(unsigned __int8 *)(v1 + 4);
    v5 = *(_DWORD *)v1 + *(unsigned __int8 *)(v1 + 5);
    if ((v2 & 2) != 0)
      this = kdu_sample_allocator::alloc16(v3, v4, v5);
    else
      this = kdu_sample_allocator::alloc32(v3, v4, v5);
    *(_QWORD *)(v1 + 8) = this;
  }
  return this;
}

uint64_t kdu_region_decompressor::close_tile(kdu_region_decompressor *this)
{
  kdu_thread_entity *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  _QWORD *v11;

  if (!*((_BYTE *)this + 120))
    kdu_region_decompressor::close_tile();
  v2 = (kdu_thread_entity *)*((_QWORD *)this + 2);
  if (v2 && *((_QWORD *)this + 3))
  {
    kdu_thread_entity::terminate(*((kdu_thread_entity **)this + 2), *((kdu_thread_queue **)this + 3), 1, 0);
    v2 = (kdu_thread_entity *)*((_QWORD *)this + 2);
  }
  *((_BYTE *)this + 120) = 0;
  kdu_tile::close((uint64_t **)this + 14, v2);
  result = *((_QWORD *)this + 4);
  if (result)
  {
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)result + 16))(result, 0);
    result = *((_QWORD *)this + 4);
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    *((_QWORD *)this + 4) = 0;
  }
  if (*((int *)this + 48) >= 1)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = *((_QWORD *)this + 25) + v4;
      *(_QWORD *)(v6 + 24) = 0;
      *(_DWORD *)(v6 + 32) = 0;
      *(_WORD *)(v6 + 54) = 0;
      *(_QWORD *)(v6 + 56) = 0;
      ++v5;
      *(_QWORD *)(v6 + 38) = 0;
      *(_QWORD *)(v6 + 44) = 0;
      v4 += 112;
    }
    while (v5 < *((int *)this + 48));
  }
  if (*((int *)this + 40) >= 1)
  {
    v7 = 0;
    v8 = 0;
    do
    {
      for (i = 0; i != 48; i += 16)
      {
        v10 = *((_QWORD *)this + 21) + v7 + i;
        *(_DWORD *)(v10 + 8) = 0;
        *(_WORD *)(v10 + 14) = 0;
        *(_QWORD *)(v10 + 16) = 0;
      }
      v11 = (_QWORD *)(*((_QWORD *)this + 21) + 96 * v8++);
      v11[7] = 0;
      v11[8] = 0;
      v11[9] = 0;
      v7 += 96;
    }
    while (v8 < *((int *)this + 40));
  }
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_BYTE *)this + 40) = 1;
  return result;
}

uint64_t kdu_region_decompressor::process(uint64_t a1, uint64_t a2, unsigned __int8 a3, int a4, uint64_t a5, int a6, int a7, int a8, int *a9, uint64_t a10, int a11, unsigned __int8 a12)
{
  int v17;
  int *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;

  v17 = a12;
  v18 = a9;
  if (((*(_DWORD *)(a1 + 164) == 1) & a3) != 0)
    v19 = 2;
  else
    v19 = 0;
  v20 = v19 + *(_DWORD *)(a1 + 160);
  *(_DWORD *)(a1 + 224) = v20;
  if (v20 > *(_DWORD *)(a1 + 220))
  {
    v21 = a6;
    v22 = a7;
    *(_DWORD *)(a1 + 220) = v20;
    v23 = *(_QWORD *)(a1 + 232);
    if (v23)
      MEMORY[0x18D761C18](v23, 0x10C80436913F5);
    *(_QWORD *)(a1 + 232) = operator new[]();
    v20 = *(_DWORD *)(a1 + 224);
    a7 = v22;
    v18 = a9;
    a6 = v21;
    v17 = a12;
  }
  if (v20 >= 1)
  {
    v24 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 232) + v24) = *(_QWORD *)(a2 + v24);
      v24 += 8;
    }
    while (8 * v20 != v24);
    if (v20 >= 5)
    {
      v25 = 8 * v20;
      v26 = 32;
      do
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 232) + v26) = 0;
        v26 += 8;
      }
      while (v25 != v26);
    }
  }
  if (v17)
    v27 = a4;
  else
    v27 = 1;
  return kdu_region_decompressor::process_generic((kdu_region_decompressor *)a1, 1, a4, a5, v27 * a6, a7, a8, v18, a10, a11, 0);
}

uint64_t kdu_region_decompressor::process_generic(kdu_region_decompressor *this, int a2, int a3, uint64_t a4, int a5, int a6, int a7, int *a8, uint64_t a9, int a10, unsigned __int8 a11)
{
  uint64_t v11;
  BOOL v13;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  BOOL v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t i;
  uint64_t v43;
  unsigned int *v44;
  uint64_t v45;
  _DWORD *v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  void *v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  _WORD *v63;
  int v64;
  int v65;
  int v66;
  __int16 *v67;
  float v68;
  float v69;
  int v70;
  unsigned int v71;
  float v72;
  int v73;
  __int16 v74;
  char v75;
  int v76;
  int v77;
  int v78;
  unsigned int v79;
  int v80;
  int v81;
  __int16 v82;
  int v83;
  int v84;
  int v85;
  unsigned int v86;
  int v87;
  int v88;
  __int16 v89;
  unsigned int v90;
  __int16 v91;
  int v92;
  int v93;
  int v94;
  unsigned int v95;
  __int16 v96;
  __int16 v97;
  int v98;
  __int16 v99;
  uint64_t v100;
  char v101;
  uint64_t v102;
  uint64_t v103;
  BOOL v104;
  _DWORD *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  _BOOL8 v109;
  uint64_t v110;
  _WORD *v111;
  uint64_t v112;
  int v113;
  _WORD *v114;
  const char *v115;
  const char *v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  uint64_t v123;
  char v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char v128;
  _WORD *v129;
  void *v130;
  void *v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  unsigned int v138;
  int v139;
  int v140;
  int v141;
  unsigned int v142;
  unsigned int v143;
  int v144;
  size_t v145;
  int v146;
  int v147;
  int v148;
  unsigned int v149;
  unsigned int v150;
  int v151;
  int v152;
  int v153;
  uint64_t v154;
  __int16 *v155;
  __int16 *v156;
  uint64_t v157;
  int v158;
  int v159;
  signed int v160;
  unsigned int v161;
  int v162;
  int v163;
  uint64_t v164;
  unsigned int v165;
  int v166;
  int v167;
  unsigned int v168;
  uint64_t v169;
  __int16 v170;
  unsigned int v171;
  uint64_t v172;
  int v173;
  uint64_t v174;
  __int16 v175;
  int v176;
  int v177;
  uint64_t v178;
  unsigned int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  int v185;
  __int16 *v186;
  __int16 *v187;
  __int16 v188;
  __int16 v189;
  int v190;
  signed int v191;
  unsigned int v192;
  int v193;
  char v194;
  char v195;
  __int16 *v196;
  unsigned __int16 *v197;
  int v198;
  int v199;
  int v200;
  int v201;
  signed int v202;
  unsigned int v203;
  float *v204;
  float *v205;
  float v206;
  int v207;
  int v208;
  int v209;
  int v210;
  signed int v211;
  unsigned int v212;
  int *v213;
  int *v214;
  int v215;
  int v216;
  int v217;
  int v218;
  signed int v219;
  unsigned int v220;
  int v221;
  __int16 v222;
  __int16 v223;
  unsigned int v224;
  int v225;
  int v226;
  int v227;
  int v228;
  int v229;
  int v230;
  unsigned int v231;
  float *v232;
  float *v233;
  float v234;
  int v235;
  int v236;
  int v237;
  int v238;
  signed int v239;
  unsigned int v240;
  char v241;
  int v242;
  int *v243;
  int *v244;
  int v245;
  int v246;
  int v247;
  int v248;
  signed int v249;
  unsigned int v250;
  int v251;
  int v252;
  unsigned int v253;
  __int16 v254;
  int v255;
  int v256;
  unsigned int v257;
  int v258;
  int v259;
  int v260;
  unsigned int v261;
  __int16 v262;
  unsigned int v263;
  int v264;
  int v265;
  int v266;
  __int16 v267;
  __int16 v268;
  int v269;
  int v270;
  int v271;
  int v272;
  int v273;
  int v274;
  int v275;
  int v276;
  __int16 v277;
  int v278;
  float v279;
  int v280;
  int v281;
  unsigned int v282;
  int v283;
  int v284;
  int v285;
  int v286;
  int v287;
  int v288;
  unsigned int v289;
  int v290;
  int v291;
  int v292;
  float v293;
  int v294;
  int v295;
  int v296;
  int v297;
  int v298;
  int v299;
  int v300;
  int v301;
  int v302;
  int v303;
  int v304;
  __int16 *v305;
  _WORD *v306;
  uint64_t v307;
  __int16 v308;
  unsigned int v309;
  unsigned int v310;
  int v311;
  int v312;
  __int16 *v313;
  uint64_t v314;
  int v315;
  _WORD *v316;
  int v317;
  unsigned int v318;
  int v319;
  int v320;
  int v321;
  float v322;
  int v323;
  int v324;
  int v325;
  int v326;
  int v327;
  unsigned int v328;
  int v329;
  unsigned int v330;
  int v331;
  int v332;
  int v333;
  int v334;
  float v335;
  int v336;
  int v337;
  int v338;
  int v339;
  int v340;
  unsigned int v341;
  int v342;
  unsigned int v343;
  int v344;
  int v345;
  float v346;
  int v347;
  int v348;
  int v349;
  int v350;
  float v351;
  int v352;
  int v353;
  int v354;
  int v355;
  int v356;
  uint64_t v357;
  int v358;
  float v359;
  int v360;
  int v361;
  float v362;
  int v363;
  int v364;
  int v365;
  int v366;
  float v367;
  int v368;
  int v369;
  int v370;
  int v371;
  int v372;
  uint64_t v373;
  int v374;
  float v375;
  int v376;
  unsigned int v377;
  int v378;
  int v379;
  int v380;
  unsigned int v381;
  int v382;
  int v383;
  int v384;
  int v385;
  int v386;
  int v387;
  int v388;
  uint64_t v389;
  unsigned int v390;
  int v391;
  int v392;
  int v393;
  int v394;
  int v395;
  int v396;
  int v397;
  int v398;
  int v399;
  uint64_t v400;
  unsigned int v401;
  int v402;
  int v403;
  int v404;
  int v405;
  uint64_t v406;
  char v407;
  __int16 *v408;
  unsigned int v409;
  unsigned int v410;
  int v411;
  uint64_t *v412;
  _QWORD *v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  _DWORD *v417;
  char v418;
  uint64_t v419;
  uint64_t j;
  uint64_t v421;
  int *v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  int v426;
  int v427;
  int v428;
  int v429;
  int v430;
  _WORD *v431;
  __int16 *v432;
  int *v433;
  uint64_t v434;
  char v435;
  void *v436;
  int *v437;
  int v438;
  int *v439;
  unsigned int v440;
  int v441;
  int v442;
  int v443;
  unsigned int v444;
  int v445;
  uint64_t v446;
  const void *v447;
  size_t v448;
  unsigned int v449;
  int v450;
  int v451;
  int v452;
  __int16 *v453;
  unsigned int v454;
  int v455;
  int v456;
  int v457;
  unsigned int v458;
  __int16 v459;
  unsigned int v460;
  int v461;
  int v462;
  int v463;
  unsigned int v464;
  int v465;
  int v466;
  int v467;
  unsigned int v468;
  int v469;
  int v470;
  int v471;
  int v472;
  uint64_t *v473;
  _QWORD *v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  _WORD *v479;
  uint64_t v480;
  uint64_t v481;
  unsigned int v482;
  _BOOL4 v483;
  int v484;
  int v485;
  uint64_t v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  int v491;
  int v492;
  _DWORD *v493;
  uint64_t v494;
  const char *v495;
  _DWORD *v496;
  _DWORD *v497;
  int v498;
  _DWORD *exception;
  char *v500;
  int *v501;
  int v502;
  int v503;
  unint64_t v504;
  _DWORD *v505;
  int v506;
  int v507;
  int v508;
  int v509;
  int v510;
  uint64_t v511;
  uint64_t v512;
  int v513;
  int v514;
  _OWORD v515[2];
  uint64_t v516;

  v11 = a9;
  *(_QWORD *)(a9 + 8) = 0;
  if (*((_BYTE *)this + 80))
    return 0;
  v13 = a8[3] < 1 || a8[2] < 1;
  if (v13)
    return 0;
  if (!*((_BYTE *)this + 120))
  {
    kdu_region_decompressor::open_tile(this);
    if (!*((_BYTE *)this + 120))
      return 0;
  }
  v515[0] = *(_OWORD *)((char *)this + 124);
  kdu_dims::operator&=(v515, a8);
  v22 = *((_QWORD *)&v515[0] + 1);
  if (SDWORD2(v515[0]) >= 1)
  {
    v23 = HIDWORD(*((_QWORD *)&v515[0] + 1));
    if (*((uint64_t *)&v515[0] + 1) > 0)
    {
      v509 = v515[0];
      v24 = HIDWORD(*(_QWORD *)&v515[0]);
      v502 = a8[3] + a8[1];
      v503 = HIDWORD(v515[0]) + DWORD1(v515[0]);
      if (HIDWORD(v515[0]) + DWORD1(v515[0]) != v502 && *((_DWORD *)this + 26) == *((_DWORD *)this + 22))
        __assert_rtn("process_generic", "kdu_region_decompressor.cpp", 2650, "last_tile_in_row || (next_tile_idx.x != valid_tiles.pos.x)");
      v501 = a8;
      v505 = (_DWORD *)((char *)this + 124);
      v25 = DWORD2(v515[0]) + LODWORD(v515[0]);
      *(_QWORD *)a9 = *(_QWORD *)&v515[0];
      *(_QWORD *)(a9 + 8) = v22;
      *(_DWORD *)(a9 + 8) = 0;
      v504 = v22;
      if (a5 || a6 >= 1)
      {
        v26 = *(int *)(**((_QWORD **)this + 21) + 84)
            * (uint64_t)a6
            * *(int *)(**((_QWORD **)this + 21) + 80)
            / (SHIDWORD(v22)
             * (uint64_t)*(int *)(**((_QWORD **)this + 21) + 92)
             * *(int *)(**((_QWORD **)this + 21) + 88))
            + 1;
        if (a5)
        {
          if (*v505 + v26 <= v25)
            v31 = *(int *)(**((_QWORD **)this + 21) + 84)
                * (uint64_t)a6
                * *(int *)(**((_QWORD **)this + 21) + 80)
                / (SHIDWORD(v22)
                 * (uint64_t)*(int *)(**((_QWORD **)this + 21) + 92)
                 * *(int *)(**((_QWORD **)this + 21) + 88))
                + 1;
          else
            v31 = v25 - *v505;
          if (v31 > 0)
          {
            v32 = *((unsigned int *)this + 56);
            v33 = v24;
            if ((int)v32 >= 1)
            {
              v34 = 0;
              v35 = (((int)v24 - HIDWORD(a4)) * a3 + (v509 - (int)a4) * (uint64_t)a5) * a2;
              do
              {
                v36 = *((_QWORD *)this + 29);
                v37 = *(_QWORD *)(v36 + v34);
                if (v37)
                  *(_QWORD *)(v36 + v34) = v37 + v35;
                v34 += 8;
              }
              while (8 * v32 != v34);
            }
            goto LABEL_44;
          }
LABEL_822:
          exception = __cxa_allocate_exception(4uLL);
          *exception = -1;
          __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
        }
      }
      else
      {
        v26 = v22;
      }
      if (!(a7 / (int)v23))
      {
        v516 = 0;
        memset(v515, 0, sizeof(v515));
        kdu_error::kdu_error((kdu_error *)v515, "Error in Kakadu Region Decompressor:\n");
        (*(void (**)(void))(*(_QWORD *)&v515[0] + 16))();
        kdu_error::~kdu_error((kdu_error *)v515);
      }
      if (v26 >= a7 / (int)v23)
        v38 = a7 / (int)v23;
      else
        v38 = v26;
      if (*v505 + v38 <= v25)
        v31 = v38;
      else
        v31 = v25 - *v505;
      v11 = a9;
      if (v31 >= 1)
      {
        a5 = *(_DWORD *)(a9 + 12) * a3;
        LODWORD(v32) = *((_DWORD *)this + 56);
        v33 = *(_DWORD *)(a9 + 4);
LABEL_44:
        v514 = *((_DWORD *)this + 32);
        v513 = v33 - v514;
        v39 = *(unsigned int *)(v11 + 12);
        v500 = "(dp != NULL) && indices.is_absolute() && (indices.get_width() >= i)";
        v40 = a3;
        v511 = a5 * a2;
        v512 = (int)(v32 - a11);
        v41 = *((_DWORD *)this + 48);
        v506 = a3;
        v507 = v33;
        v508 = a2;
        while (1)
        {
          v510 = v31;
          if (v41 >= 1)
          {
            for (i = 0; i < *((int *)this + 48); ++i)
            {
              v43 = *((_QWORD *)this + 25);
              v44 = (unsigned int *)(v43 + 112 * i);
              if ((int)v44[18] <= 0)
              {
                v51 = v43 + 112 * i;
                v53 = *(_QWORD *)(v51 + 24);
                v52 = (_QWORD *)(v51 + 24);
                if (!v53)
                {
                  v54 = v43 + 112 * i;
                  v56 = *(_DWORD *)(v54 + 32);
                  v54 += 32;
                  v55 = v56;
                  *v52 = v54;
                  v57 = *(void **)(v54 + 8);
                  if ((*(_BYTE *)(v54 + 6) & 2) == 0 && v57)
                  {
LABEL_808:
                    v496 = __cxa_allocate_exception(4uLL);
                    *v496 = -50;
                    __cxa_throw(v496, MEMORY[0x1E0DE4EF0], 0);
                  }
                  if ((_DWORD)v55)
                    bzero(v57, 2 * v55);
                  *(_BYTE *)(v43 + 112 * i + 19) = 1;
                }
                continue;
              }
              v45 = v43 + 112 * i;
              v48 = *(_DWORD *)(v45 + 96);
              v46 = (_DWORD *)(v45 + 96);
              v47 = v48;
              v50 = (uint64_t *)(v46 - 18);
              v49 = *((_QWORD *)v46 - 9);
              if (v48 <= 0)
              {
                if (v49)
                {
                  *v46 = *(_DWORD *)(v43 + 112 * i + 80) + v47;
                  *v50 = 0;
                }
              }
              else if (v49)
              {
                continue;
              }
              v58 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 4) + 32))(*((_QWORD *)this + 4), *v44, *((_QWORD *)this + 2));
              *v50 = v58;
              if (!v58)
                goto LABEL_808;
              v59 = *(_DWORD *)(v43 + 112 * i + 8);
              if (v59 >= 1)
              {
                v60 = v43 + 112 * i;
                if ((*(_BYTE *)(v60 + 54) & 2) == 0)
                {
                  v61 = 218;
                  goto LABEL_795;
                }
                v61 = 218;
                if ((*(_BYTE *)(v60 + 54) & 1) == 0)
                  goto LABEL_795;
                v62 = v43 + 112 * i;
                v63 = *(_WORD **)(v62 + 56);
                if (!v63)
                  goto LABEL_795;
                v64 = *(_DWORD *)v58;
                if (*(_DWORD *)(v62 + 48) < *(_DWORD *)v58)
                  goto LABEL_795;
                v65 = *(_DWORD *)(v60 + 4);
                v66 = *(unsigned __int8 *)(v60 + 16);
                v67 = *(__int16 **)(v58 + 8);
                if ((*(_BYTE *)(v58 + 6) & 2) != 0)
                {
                  if ((*(_BYTE *)(v58 + 6) & 1) != 0)
                  {
                    if (!v67)
                    {
LABEL_814:
                      v61 = 249;
                      goto LABEL_816;
                    }
                    if (v64 >= 1)
                    {
                      v90 = (0x8000 << v65) >> 16;
                      if (v66)
                        v91 = 0;
                      else
                        v91 = v90;
                      v92 = -65536 << v59;
                      v93 = -65536 << v59 >> 16;
                      v94 = ~(v92 >> 16);
                      v95 = v64 + 1;
                      do
                      {
                        v96 = *v67++;
                        v97 = v96 + v91;
                        v98 = (__int16)(v96 + v91);
                        if (v98 >= 0)
                          v99 = v94;
                        else
                          v99 = 0;
                        if ((v93 & v98) != 0)
                          v97 = v99;
                        *v63++ = v97;
                        --v95;
                      }
                      while (v95 > 1);
                    }
                  }
                  else
                  {
                    if (!v67)
                    {
LABEL_815:
                      v61 = 281;
LABEL_816:
                      v495 = "0";
LABEL_794:
                      v500 = (char *)v495;
LABEL_795:
                      __assert_rtn("convert_samples_to_palette_indices", "kdu_region_decompressor.cpp", v61, v500);
                    }
                    if (v59 > 0xC)
                    {
                      v61 = 256;
                      v495 = "downshift > 0";
                      goto LABEL_794;
                    }
                    if (v64 >= 1)
                    {
                      v75 = 13 - v59;
                      v76 = ((0x8000 << (13 - v59)) + ((v66 == 0) << 28)) >> 16;
                      v77 = -65536 << v59;
                      v78 = ~(0xFFFF << v59);
                      v79 = v64 + 1;
                      do
                      {
                        v80 = *v67++;
                        v81 = (v76 + v80) >> v75;
                        if ((v81 & 0x8000) != 0)
                          v82 = 0;
                        else
                          v82 = v78;
                        if ((v77 & (v81 << 16)) != 0)
                          LOWORD(v81) = v82;
                        *v63++ = v81;
                        --v79;
                      }
                      while (v79 > 1);
                    }
                  }
                }
                else if ((*(_BYTE *)(v58 + 6) & 1) != 0)
                {
                  if (!v67)
                    goto LABEL_814;
                  v83 = 1 << v65 >> 1;
                  if (v66)
                    v84 = 0;
                  else
                    v84 = v83;
                  if (v64 >= 1)
                  {
                    v85 = -1 << v59;
                    v86 = v64 + 1;
                    do
                    {
                      v87 = *(_DWORD *)v67;
                      v67 += 2;
                      v88 = v87 + v84;
                      if (v87 + v84 < 0 != __OFADD__(v87, v84))
                        v89 = 0;
                      else
                        v89 = ~(_WORD)v85;
                      if ((v88 & v85) != 0)
                        LOWORD(v88) = v89;
                      *v63++ = v88;
                      --v86;
                    }
                    while (v86 > 1);
                  }
                }
                else
                {
                  if (!v67)
                    goto LABEL_815;
                  v68 = (float)(1 << v59);
                  v69 = (float)(v68 * 0.5) + 0.5;
                  if (v66)
                    v69 = 0.5;
                  if (v64 >= 1)
                  {
                    v70 = -1 << v59;
                    v71 = v64 + 1;
                    do
                    {
                      v72 = *(float *)v67;
                      v67 += 2;
                      v73 = (int)(float)(v69 + (float)(v72 * v68));
                      if (v73 >= 0)
                        v74 = ~(_WORD)v70;
                      else
                        v74 = 0;
                      if ((v70 & v73) != 0)
                        LOWORD(v73) = v74;
                      *v63++ = v73;
                      --v71;
                    }
                    while (v71 > 1);
                  }
                }
              }
              *(_BYTE *)(v43 + 112 * i + 19) = 1;
              --v44[18];
              ++v44[16];
            }
          }
          if (*((int *)this + 40) < 1)
            goto LABEL_652;
          v100 = 0;
          v101 = 0;
          do
          {
            v102 = *((_QWORD *)this + 21);
            v103 = *(_QWORD *)(v102 + 96 * v100);
            if (!*(_BYTE *)(v103 + 19))
              goto LABEL_645;
            if (*(_BYTE *)(v103 + 18))
              v104 = v507 == v514;
            else
              v104 = 0;
            if (v104 && (v105 = *(_DWORD **)(v103 + 24), (int)v39 <= *v105))
            {
              *(_QWORD *)(v102 + 96 * v100 + 64) = v105;
            }
            else
            {
              v106 = v102 + 96 * v100;
              v107 = *(_QWORD *)(v106 + 64);
              *(_QWORD *)(v106 + 56) = v107;
              v108 = v106 + 8;
              v109 = v106 + 8 == v107;
              v110 = v106 + 8 + 16 * v109;
              *(_QWORD *)(v106 + 64) = v110;
              if (!v107)
                *(_QWORD *)(v106 + 56) = v110;
              v111 = *(_WORD **)(v102 + 96 * v100 + 80);
              if (v111)
              {
                v112 = v108 + 16 * v109;
                if ((*(_BYTE *)(v112 + 6) & 2) == 0)
                {
                  v113 = 314;
LABEL_811:
                  v115 = "interpolate_and_map";
                  v116 = "(dp != NULL) && !dst->is_absolute()";
                  goto LABEL_802;
                }
                v113 = 314;
                if ((*(_BYTE *)(v112 + 6) & 1) != 0)
                  goto LABEL_811;
                v114 = *(_WORD **)(v112 + 8);
                v115 = "interpolate_and_map";
                v116 = "(dp != NULL) && !dst->is_absolute()";
                if (!v114)
                  goto LABEL_802;
                v117 = *(_DWORD *)(v103 + 48);
                if (v117)
                {
                  v118 = *(_DWORD *)(v103 + 100);
                  v119 = *(_DWORD *)(v103 + 84);
                  v120 = *(_DWORD *)(v103 + 92);
                  v121 = v118 - v120 * v513;
                  if (v120 == 1)
                  {
                    if (v121 <= 0)
                    {
                      v122 = 0;
                      do
                      {
                        v121 += v119;
                        ++v122;
                      }
                      while (v121 < 1);
                      v117 -= v122;
                    }
                    else
                    {
                      v122 = 0;
                    }
                  }
                  else
                  {
                    v122 = 0;
                    if (v121 <= -v119)
                    {
                      v139 = v119 + v118 - v120 * v513;
                      v140 = 1 - v119;
                      if (v139 <= 1 - v119)
                        v141 = 1 - v119;
                      else
                        v141 = v139;
                      v142 = v141 - v139 - (v139 < v140);
                      if (v119 <= 1)
                        v143 = 1;
                      else
                        v143 = *(_DWORD *)(v103 + 84);
                      if (v139 >= v140)
                        v144 = v142 / v143;
                      else
                        v144 = v142 / v143 + 1;
                      v122 = v144 + 1;
                      v121 += (v144 + 1) * v119;
                      v117 += ~v144;
                    }
                  }
                  if (v117 <= 1)
                    v152 = 1;
                  else
                    v152 = v117;
                  if (v117 <= 0)
                    v153 = v117 - 1;
                  else
                    v153 = 0;
                  if ((*(_BYTE *)(v103 + 54) & 2) == 0 || (v154 = *(_QWORD *)(v103 + 56)) == 0)
                  {
                    v113 = 360;
                    v115 = "interpolate_and_map";
                    v116 = "sp != NULL";
                    goto LABEL_802;
                  }
                  v155 = (__int16 *)(v154 + 2 * (v153 + v122));
                  v157 = *v155;
                  v156 = v155 + 1;
                  v158 = (unsigned __int16)v111[v157];
                  v159 = v152 - 1;
                  if (v120 == 1)
                  {
                    if ((int)v39 < 1 || v121 < 1)
                    {
                      v160 = v39;
                    }
                    else
                    {
                      v160 = v39;
                      do
                      {
                        v161 = v160;
                        *v114++ = v158;
                        --v160;
                        if (v161 < 2)
                          break;
                        v13 = v121-- > 1;
                      }
                      while (v13);
                    }
                    v166 = v160 / v119;
                    if (v160 / v119 >= v159)
                      v167 = v152 - 1;
                    else
                      v167 = v160 / v119;
                    if (v119 == 1)
                    {
                      if (v167 >= 1)
                      {
                        v171 = v167 + 1;
                        do
                        {
                          v172 = *v156++;
                          *v114++ = v111[v172];
                          --v171;
                        }
                        while (v171 > 1);
                      }
                    }
                    else if (v119 == 2)
                    {
                      if (v167 >= 1)
                      {
                        v168 = v167 + 1;
                        do
                        {
                          v169 = *v156++;
                          v170 = v111[v169];
                          *v114 = v170;
                          v114[1] = v170;
                          v114 += 2;
                          --v168;
                        }
                        while (v168 > 1);
                      }
                    }
                    else if (v167 >= 1)
                    {
                      v173 = v167;
                      do
                      {
                        v174 = *v156++;
                        v175 = v111[v174];
                        v176 = v119;
                        do
                        {
                          *v114++ = v175;
                          --v176;
                        }
                        while (v176);
                        v28 = __OFSUB__(v173--, 1);
                      }
                      while (!((v173 < 0) ^ v28 | (v173 == 0)));
                    }
                    v177 = v160 - v167 * v119;
                    if (v159 > v166)
                      v178 = 0;
                    else
                      v178 = -1;
                    if (v177 >= 1)
                    {
                      v179 = v177 + 1;
                      do
                      {
                        *v114++ = v111[v156[v178]];
                        --v179;
                      }
                      while (v179 > 1);
                    }
                  }
                  else if ((int)v39 >= 1)
                  {
                    v162 = v39 + 1;
                    v163 = v158;
                    while (1)
                    {
                      if (v121 < 1 && v159 >= 1)
                      {
                        v121 += v119;
                        if (v121 < 1)
                        {
                          v113 = 408;
                          v115 = "interpolate_and_map";
                          goto LABEL_801;
                        }
                        v164 = *v156++;
                        v163 = v158;
                        v158 = (unsigned __int16)v111[v164];
                        --v159;
                      }
                      v165 = ((__int16)v158 + (__int16)v163) >> 1;
                      if (v121 >= (3 * v119) >> 2)
                        v165 = v163 + (((__int16)v158 - (__int16)v163 + 2) >> 2);
                      if (v121 <= v119 >> 1)
                        v165 = v158 + (((__int16)v163 - (__int16)v158 + 2) >> 2);
                      if (v121 <= v119 >> 2)
                        LOWORD(v165) = v158;
                      *v114++ = v165;
                      v121 -= v120;
                      if (--v162 <= 1)
                        goto LABEL_633;
                    }
                  }
                }
                else if ((int)v39 >= 1)
                {
                  v138 = v39 + 1;
                  do
                  {
                    *v114++ = *v111;
                    --v138;
                  }
                  while (v138 > 1);
                }
                goto LABEL_633;
              }
              v123 = *(_QWORD *)(v103 + 24);
              v124 = *(_BYTE *)(v123 + 6);
              if ((v124 & 2) != 0)
                v125 = *(_QWORD *)(v123 + 8);
              else
                v125 = 0;
              if ((*(_BYTE *)(v123 + 6) & 2) != 0)
                v126 = 0;
              else
                v126 = *(_QWORD *)(v123 + 8);
              v127 = v108 + 16 * v109;
              v128 = *(_BYTE *)(v127 + 6);
              v129 = *(_WORD **)(v127 + 8);
              if ((v128 & 2) != 0)
                v130 = *(void **)(v127 + 8);
              else
                v130 = 0;
              if ((v128 & 2) != 0)
                v131 = 0;
              else
                v131 = v129;
              if ((v128 & 1) != 0)
              {
                v113 = 448;
                v115 = "interpolate_and_convert";
                v116 = "!dst->is_absolute()";
                goto LABEL_802;
              }
              v132 = *(_DWORD *)v123;
              if (*(_DWORD *)v123)
              {
                v133 = *(_DWORD *)(v103 + 100);
                v134 = *(_DWORD *)(v103 + 84);
                v135 = *(_DWORD *)(v103 + 92);
                v136 = v133 - v135 * v513;
                if (v135 == 1)
                {
                  if (v136 <= 0)
                  {
                    v137 = 0;
                    do
                    {
                      v136 += v134;
                      ++v137;
                    }
                    while (v136 < 1);
                    v132 -= v137;
                  }
                  else
                  {
                    v137 = 0;
                  }
                }
                else
                {
                  v137 = 0;
                  if (v136 <= -v134)
                  {
                    v146 = v134 + v133 - v135 * v513;
                    v147 = 1 - v134;
                    if (v146 <= 1 - v134)
                      v148 = 1 - v134;
                    else
                      v148 = v146;
                    v149 = v148 - v146 - (v146 < v147);
                    if (v134 <= 1)
                      v150 = 1;
                    else
                      v150 = *(_DWORD *)(v103 + 84);
                    v13 = v146 < v147;
                    v151 = v149 / v150;
                    if (v13)
                      ++v151;
                    v137 = v151 + 1;
                    v136 += (v151 + 1) * v134;
                    v132 += ~v151;
                  }
                }
                v180 = (3 * v134) >> 2;
                v181 = v134 >> 1;
                v182 = v134 >> 2;
                if (v132 <= 1)
                  v183 = 1;
                else
                  v183 = v132;
                if (v132 <= 0)
                  v184 = v132 - 1;
                else
                  v184 = 0;
                v185 = v184 + v137;
                if ((v124 & 1) != 0)
                {
                  v193 = *(_DWORD *)(v103 + 4);
                  v194 = v193 - 13;
                  v195 = 13 - v193;
                  if (!v125)
                  {
                    if (v126 && v130)
                    {
                      v213 = (int *)(v126 + 4 * v185);
                      v215 = *v213;
                      v214 = v213 + 1;
                      v216 = v183 - 1;
                      v217 = v215 << v195;
                      v218 = v215 >> v194;
                      if (v193 < 13)
                        v218 = v217;
                      if (v135 == 1)
                      {
                        if ((int)v39 < 1 || v136 < 1)
                        {
                          v219 = v39;
                        }
                        else
                        {
                          v219 = v39;
                          do
                          {
                            v220 = v219;
                            *v129++ = v218;
                            --v219;
                            if (v220 < 2)
                              break;
                            v13 = v136-- > 1;
                          }
                          while (v13);
                        }
                        v326 = v219 / v134;
                        if (v219 / v134 >= v216)
                          v327 = v183 - 1;
                        else
                          v327 = v219 / v134;
                        if (v134 == 1 && v193 <= 12)
                        {
                          if (v327 >= 1)
                          {
                            v328 = v327 + 1;
                            do
                            {
                              v329 = *v214++;
                              *v129++ = v329 << v195;
                              --v328;
                            }
                            while (v328 > 1);
                          }
                        }
                        else if (v134 == 1)
                        {
                          if (v327 >= 1)
                          {
                            v330 = v327 + 1;
                            do
                            {
                              v331 = *v214++;
                              *v129++ = v331 >> v194;
                              --v330;
                            }
                            while (v330 > 1);
                          }
                        }
                        else if (v134 == 2)
                        {
                          if (v327 >= 1)
                          {
                            v377 = v327 + 1;
                            do
                            {
                              v378 = *v214++;
                              v379 = v378 << v195;
                              v380 = v378 >> v194;
                              if (v193 < 13)
                                LOWORD(v380) = v379;
                              *v129 = v380;
                              v129[1] = v380;
                              v129 += 2;
                              --v377;
                            }
                            while (v377 > 1);
                          }
                        }
                        else
                        {
                          v385 = v327;
                          if (v327 >= 1)
                          {
                            do
                            {
                              v386 = *v214 >> v194;
                              if (v193 < 13)
                                LOWORD(v386) = *v214 << v195;
                              v387 = v134;
                              do
                              {
                                *v129++ = v386;
                                --v387;
                              }
                              while (v387);
                              ++v214;
                              v28 = __OFSUB__(v385--, 1);
                            }
                            while (!((v385 < 0) ^ v28 | (v385 == 0)));
                          }
                        }
                        v388 = v219 - v327 * v134;
                        if (v216 > v326)
                          v389 = 0;
                        else
                          v389 = -1;
                        if (v388 >= 1)
                        {
                          v390 = v388 + 1;
                          do
                          {
                            v391 = v214[v389];
                            v392 = v391 << v195;
                            v393 = v391 >> v194;
                            if (v193 < 13)
                              LOWORD(v393) = v392;
                            *v129++ = v393;
                            --v390;
                          }
                          while (v390 > 1);
                        }
                      }
                      else
                      {
                        v283 = v39 + 1;
                        v284 = v218;
                        if ((int)v39 >= 1)
                        {
                          do
                          {
                            if (v136 < 1)
                            {
                              v285 = v216 - 1;
                              if (v216 >= 1)
                              {
                                v136 += v134;
                                if (v136 < 1)
                                {
                                  v113 = 652;
                                  goto LABEL_800;
                                }
                                v286 = *v214++;
                                v287 = v286 << v195;
                                v288 = v286 >> v194;
                                v284 = v218;
                                if (v193 >= 13)
                                  v218 = v288;
                                else
                                  v218 = v287;
                                v216 = v285;
                              }
                            }
                            v289 = v284 + ((v218 - v284 + 2) >> 2);
                            if (v136 < v180)
                              v289 = (v218 + v284) >> 1;
                            if (v136 <= v181)
                              v289 = v218 + ((v284 - v218 + 2) >> 2);
                            if (v136 <= v182)
                              LOWORD(v289) = v218;
                            *v129++ = v289;
                            v136 -= v135;
                            --v283;
                          }
                          while (v283 > 1);
                        }
                      }
                    }
                    else
                    {
                      v113 = 750;
                      if (!v126)
                      {
LABEL_821:
                        v115 = "interpolate_and_convert";
                        v116 = "0";
                        goto LABEL_802;
                      }
                      v115 = "interpolate_and_convert";
                      v116 = "0";
                      if (!v131)
                        goto LABEL_802;
                      v241 = v193 - 29;
                      v242 = 29 - v193;
                      v243 = (int *)(v126 + 4 * v185);
                      v245 = *v243;
                      v244 = v243 + 1;
                      v246 = v183 - 1;
                      v247 = v245 << v242;
                      v248 = v245 >> v241;
                      if (v242 > 0)
                        v248 = v247;
                      if (v135 == 1)
                      {
                        if ((int)v39 < 1 || v136 < 1)
                        {
                          v249 = v39;
                        }
                        else
                        {
                          v249 = v39;
                          do
                          {
                            v250 = v249;
                            *(_DWORD *)v129 = v248;
                            v129 += 2;
                            --v249;
                            if (v250 < 2)
                              break;
                            v13 = v136-- > 1;
                          }
                          while (v13);
                        }
                        v339 = v249 / v134;
                        if (v249 / v134 >= v246)
                          v340 = v183 - 1;
                        else
                          v340 = v249 / v134;
                        if (v134 == 1 && v242 >= 1)
                        {
                          if (v340 >= 1)
                          {
                            v341 = v340 + 1;
                            do
                            {
                              v342 = *v244++;
                              *(_DWORD *)v129 = v342 << v242;
                              v129 += 2;
                              --v341;
                            }
                            while (v341 > 1);
                          }
                        }
                        else if (v134 == 1)
                        {
                          if (v340 >= 1)
                          {
                            v343 = v340 + 1;
                            do
                            {
                              v344 = *v244++;
                              *(_DWORD *)v129 = v344 >> v241;
                              v129 += 2;
                              --v343;
                            }
                            while (v343 > 1);
                          }
                        }
                        else if (v134 == 2)
                        {
                          if (v340 >= 1)
                          {
                            v381 = v340 + 1;
                            do
                            {
                              v382 = *v244++;
                              v383 = v382 << v242;
                              v384 = v382 >> v241;
                              if (v242 > 0)
                                v384 = v383;
                              *(_DWORD *)v129 = v384;
                              *((_DWORD *)v129 + 1) = v384;
                              v129 += 4;
                              --v381;
                            }
                            while (v381 > 1);
                          }
                        }
                        else
                        {
                          v394 = v340;
                          if (v340 >= 1)
                          {
                            do
                            {
                              v395 = *v244++;
                              v396 = v395 << v242;
                              v397 = v395 >> v241;
                              if (v242 > 0)
                                v397 = v396;
                              v398 = v134;
                              do
                              {
                                *(_DWORD *)v129 = v397;
                                v129 += 2;
                                --v398;
                              }
                              while (v398);
                              v28 = __OFSUB__(v394--, 1);
                            }
                            while (!((v394 < 0) ^ v28 | (v394 == 0)));
                          }
                        }
                        v399 = v249 - v340 * v134;
                        if (v246 > v339)
                          v400 = 0;
                        else
                          v400 = -1;
                        if (v399 >= 1)
                        {
                          v401 = v399 + 1;
                          do
                          {
                            v402 = v244[v400];
                            v403 = v402 << v242;
                            v404 = v402 >> v241;
                            if (v242 > 0)
                              v404 = v403;
                            *(_DWORD *)v129 = v404;
                            v129 += 2;
                            --v401;
                          }
                          while (v401 > 1);
                        }
                      }
                      else
                      {
                        v297 = v39 + 1;
                        v298 = v248;
                        if ((int)v39 >= 1)
                        {
                          do
                          {
                            if (v136 < 1)
                            {
                              v299 = v246 - 1;
                              if (v246 >= 1)
                              {
                                v136 += v134;
                                if (v136 < 1)
                                {
                                  v113 = 728;
                                  goto LABEL_800;
                                }
                                v300 = *v244++;
                                v301 = v300 << v242;
                                v302 = v300 >> v241;
                                v298 = v248;
                                if (v242 <= 0)
                                  v248 = v302;
                                else
                                  v248 = v301;
                                v246 = v299;
                              }
                            }
                            v303 = v298 + ((v248 - v298 + 2) >> 2);
                            if (v136 < v180)
                              v303 = (v248 + v298) >> 1;
                            if (v136 <= v181)
                              v303 = v248 + ((v298 - v248 + 2) >> 2);
                            if (v136 <= v182)
                              v303 = v248;
                            *(_DWORD *)v129 = v303;
                            v129 += 2;
                            v136 -= v135;
                            --v297;
                          }
                          while (v297 > 1);
                        }
                      }
                    }
                    goto LABEL_633;
                  }
                  if (!v130)
                  {
                    v113 = 502;
                    goto LABEL_805;
                  }
                  v196 = (__int16 *)(v125 + 2 * v185);
                  v198 = *v196;
                  v197 = (unsigned __int16 *)(v196 + 1);
                  v199 = v183 - 1;
                  v200 = v198 << v195;
                  v201 = v198 >> v194;
                  if (v193 < 13)
                    v201 = v200;
                  if (v135 != 1)
                  {
                    if ((int)v39 >= 1)
                    {
                      v225 = v39 + 1;
                      v226 = v201;
                      do
                      {
                        if (v136 < 1)
                        {
                          v227 = v199 - 1;
                          if (v199 >= 1)
                          {
                            v136 += v134;
                            if (v136 < 1)
                            {
                              v113 = 578;
                              goto LABEL_800;
                            }
                            v228 = (__int16)*v197++;
                            v229 = v228 << v195;
                            v230 = v228 >> v194;
                            v226 = v201;
                            if (v193 >= 13)
                              v201 = v230;
                            else
                              v201 = v229;
                            v199 = v227;
                          }
                        }
                        v231 = ((__int16)v201 + (__int16)v226) >> 1;
                        if (v136 >= v180)
                          v231 = v226 + (((__int16)v201 - (__int16)v226 + 2) >> 2);
                        if (v136 <= v181)
                          v231 = v201 + (((__int16)v226 - (__int16)v201 + 2) >> 2);
                        if (v136 <= v182)
                          LOWORD(v231) = v201;
                        *v129++ = v231;
                        v136 -= v135;
                        --v225;
                      }
                      while (v225 > 1);
                    }
                    goto LABEL_633;
                  }
                  if ((int)v39 < 1 || v136 < 1)
                  {
                    v202 = v39;
                  }
                  else
                  {
                    v202 = v39;
                    do
                    {
                      v203 = v202;
                      *v129++ = v201;
                      --v202;
                      if (v203 < 2)
                        break;
                      v13 = v136-- > 1;
                    }
                    while (v13);
                  }
                  v255 = v202 / v134;
                  if (v202 / v134 >= v199)
                    v256 = v183 - 1;
                  else
                    v256 = v202 / v134;
                  if (v134 != 1)
                  {
                    if (v134 == 2)
                    {
                      if (v256 >= 1)
                      {
                        v257 = v256 + 1;
                        do
                        {
                          v258 = (__int16)*v197++;
                          v259 = v258 << v195;
                          v260 = v258 >> v194;
                          if (v193 < 13)
                            LOWORD(v260) = v259;
                          *v129 = v260;
                          v129[1] = v260;
                          v129 += 2;
                          --v257;
                        }
                        while (v257 > 1);
                        goto LABEL_471;
                      }
LABEL_472:
                      v271 = v256;
                    }
                    else
                    {
                      v270 = v256;
                      v271 = v256;
                      if (v256 >= 1)
                      {
                        do
                        {
                          v272 = (__int16)*v197++;
                          v273 = v272 << v195;
                          v274 = v272 >> v194;
                          if (v193 < 13)
                            LOWORD(v274) = v273;
                          v275 = v134;
                          do
                          {
                            *v129++ = v274;
                            --v275;
                          }
                          while (v275);
                          v28 = __OFSUB__(v270--, 1);
                        }
                        while (!((v270 < 0) ^ v28 | (v270 == 0)));
LABEL_471:
                        v271 = 0;
                      }
                    }
                    v312 = v202 - v256 * v134;
                    if (v312 >= 1)
                    {
                      v313 = (__int16 *)&v197[v271];
                      if (v199 > v255)
                        v314 = 0;
                      else
                        v314 = -1;
                      v315 = v313[v314];
                      v316 = &v129[v271 * v134];
                      v317 = v315 << v195;
                      if (v193 >= 13)
                        LOWORD(v317) = v315 >> v194;
                      v318 = v312 + 1;
                      do
                      {
                        *v316++ = v317;
                        --v318;
                      }
                      while (v318 > 1);
                    }
                    goto LABEL_633;
                  }
                  if (v193 >= 13)
                  {
                    if (v256 >= 1)
                    {
                      v310 = v256 + 1;
                      do
                      {
                        v311 = (__int16)*v197++;
                        *v129++ = v311 >> v194;
                        --v310;
                      }
                      while (v310 > 1);
                      goto LABEL_471;
                    }
                  }
                  else if (v256 >= 1)
                  {
                    v263 = v256 + 1;
                    do
                    {
                      v264 = *v197++;
                      *v129++ = v264 << v195;
                      --v263;
                    }
                    while (v263 > 1);
                    goto LABEL_471;
                  }
                  goto LABEL_472;
                }
                if (!v125)
                {
                  if (v126 && v130)
                  {
                    v204 = (float *)(v126 + 4 * v185);
                    v206 = *v204;
                    v205 = v204 + 1;
                    v207 = v183 - 1;
                    v208 = (int)(float)(0.5 - (float)(v206 * 8192.0));
                    v209 = (int)(float)((float)(v206 * 8192.0) + 0.5);
                    if ((float)(v206 * 8192.0) < 0.0)
                      v210 = -v208;
                    else
                      LOWORD(v210) = v209;
                    if (v135 == 1)
                    {
                      if ((int)v39 < 1 || v136 < 1)
                      {
                        v211 = v39;
                      }
                      else
                      {
                        v211 = v39;
                        do
                        {
                          v212 = v211;
                          *v129++ = v210;
                          --v211;
                          if (v212 < 2)
                            break;
                          v13 = v136-- > 1;
                        }
                        while (v13);
                      }
                      v319 = v211 / v134;
                      if (v211 / v134 >= v207)
                        v320 = v183 - 1;
                      else
                        v320 = v211 / v134;
                      if (v134 == 1)
                      {
                        if (v320 >= 1)
                        {
                          v345 = v320 + 1;
                          do
                          {
                            v346 = *v205++;
                            v347 = (int)(float)(0.5 - (float)(v346 * 8192.0));
                            v348 = (int)(float)((float)(v346 * 8192.0) + 0.5);
                            if ((float)(v346 * 8192.0) < 0.0)
                              v349 = -v347;
                            else
                              LOWORD(v349) = v348;
                            *v129++ = v349;
                            --v345;
                          }
                          while (v345 > 1);
                        }
                      }
                      else if (v134 == 2)
                      {
                        if (v320 >= 1)
                        {
                          v321 = v320 + 1;
                          do
                          {
                            v322 = *v205++;
                            v323 = (int)(float)(0.5 - (float)(v322 * 8192.0));
                            v324 = (int)(float)((float)(v322 * 8192.0) + 0.5);
                            if ((float)(v322 * 8192.0) < 0.0)
                              v325 = -v323;
                            else
                              LOWORD(v325) = v324;
                            *v129 = v325;
                            v129[1] = v325;
                            v129 += 2;
                            --v321;
                          }
                          while (v321 > 1);
                        }
                      }
                      else
                      {
                        v350 = v320;
                        if (v320 >= 1)
                        {
                          do
                          {
                            v351 = *v205++;
                            v352 = (int)(float)(0.5 - (float)(v351 * 8192.0));
                            v353 = (int)(float)((float)(v351 * 8192.0) + 0.5);
                            if ((float)(v351 * 8192.0) < 0.0)
                              v354 = -v352;
                            else
                              LOWORD(v354) = v353;
                            v355 = v134;
                            do
                            {
                              *v129++ = v354;
                              --v355;
                            }
                            while (v355);
                            v28 = __OFSUB__(v350--, 1);
                          }
                          while (!((v350 < 0) ^ v28 | (v350 == 0)));
                        }
                      }
                      v356 = v211 - v320 * v134;
                      if (v207 > v319)
                        v357 = 0;
                      else
                        v357 = -1;
                      if (v356 >= 1)
                      {
                        v358 = v356 + 1;
                        do
                        {
                          v359 = v205[v357] * 8192.0;
                          if (v359 < 0.0)
                            v360 = -(int)(float)(0.5 - v359);
                          else
                            LOWORD(v360) = (int)(float)(v359 + 0.5);
                          *v129++ = v360;
                          --v358;
                        }
                        while (v358 > 1);
                      }
                    }
                    else
                    {
                      v276 = v39 + 1;
                      v277 = v210;
                      if ((int)v39 >= 1)
                      {
                        do
                        {
                          if (v136 < 1)
                          {
                            v278 = v207 - 1;
                            if (v207 >= 1)
                            {
                              v136 += v134;
                              if (v136 < 1)
                              {
                                v113 = 899;
                                goto LABEL_800;
                              }
                              v279 = *v205++;
                              v280 = (int)(float)(0.5 - (float)(v279 * 8192.0));
                              v281 = (int)(float)((float)(v279 * 8192.0) + 0.5);
                              v277 = v210;
                              if ((float)(v279 * 8192.0) < 0.0)
                                v210 = -v280;
                              else
                                LOWORD(v210) = v281;
                              v207 = v278;
                            }
                          }
                          v282 = ((__int16)v210 + v277) >> 1;
                          if (v136 >= v180)
                            LOWORD(v282) = v277 + (((__int16)v210 - v277 + 2) >> 2);
                          if (v136 <= v181)
                            LOWORD(v282) = v210 + ((v277 - (__int16)v210 + 2) >> 2);
                          if (v136 <= v182)
                            LOWORD(v282) = v210;
                          *v129++ = v282;
                          v136 -= v135;
                          --v276;
                        }
                        while (v276 > 1);
                      }
                    }
                  }
                  else
                  {
                    v113 = 1006;
                    if (!v126)
                      goto LABEL_821;
                    v115 = "interpolate_and_convert";
                    v116 = "0";
                    if (!v131)
                      goto LABEL_802;
                    v232 = (float *)(v126 + 4 * v185);
                    v234 = *v232;
                    v233 = v232 + 1;
                    v235 = v183 - 1;
                    v236 = (int)(float)(0.5 - (float)(v234 * 536870000.0));
                    v237 = (int)(float)((float)(v234 * 536870000.0) + 0.5);
                    if ((float)(v234 * 536870000.0) < 0.0)
                      v238 = -v236;
                    else
                      v238 = v237;
                    if (v135 == 1)
                    {
                      if ((int)v39 < 1 || v136 < 1)
                      {
                        v239 = v39;
                      }
                      else
                      {
                        v239 = v39;
                        do
                        {
                          v240 = v239;
                          *(_DWORD *)v129 = v238;
                          v129 += 2;
                          --v239;
                          if (v240 < 2)
                            break;
                          v13 = v136-- > 1;
                        }
                        while (v13);
                      }
                      v332 = v239 / v134;
                      if (v239 / v134 >= v235)
                        v333 = v183 - 1;
                      else
                        v333 = v239 / v134;
                      if (v134 == 1)
                      {
                        if (v333 >= 1)
                        {
                          v361 = v333 + 1;
                          do
                          {
                            v362 = *v233++;
                            v363 = (int)(float)(0.5 - (float)(v362 * 536870000.0));
                            v364 = (int)(float)((float)(v362 * 536870000.0) + 0.5);
                            if ((float)(v362 * 536870000.0) < 0.0)
                              v365 = -v363;
                            else
                              v365 = v364;
                            *(_DWORD *)v129 = v365;
                            v129 += 2;
                            --v361;
                          }
                          while (v361 > 1);
                        }
                      }
                      else if (v134 == 2)
                      {
                        if (v333 >= 1)
                        {
                          v334 = v333 + 1;
                          do
                          {
                            v335 = *v233++;
                            v336 = (int)(float)(0.5 - (float)(v335 * 536870000.0));
                            v337 = (int)(float)((float)(v335 * 536870000.0) + 0.5);
                            if ((float)(v335 * 536870000.0) < 0.0)
                              v338 = -v336;
                            else
                              v338 = v337;
                            *(_DWORD *)v129 = v338;
                            *((_DWORD *)v129 + 1) = v338;
                            v129 += 4;
                            --v334;
                          }
                          while (v334 > 1);
                        }
                      }
                      else
                      {
                        v366 = v333;
                        if (v333 >= 1)
                        {
                          do
                          {
                            v367 = *v233++;
                            v368 = (int)(float)(0.5 - (float)(v367 * 536870000.0));
                            v369 = (int)(float)((float)(v367 * 536870000.0) + 0.5);
                            if ((float)(v367 * 536870000.0) < 0.0)
                              v370 = -v368;
                            else
                              v370 = v369;
                            v371 = v134;
                            do
                            {
                              *(_DWORD *)v129 = v370;
                              v129 += 2;
                              --v371;
                            }
                            while (v371);
                            v28 = __OFSUB__(v366--, 1);
                          }
                          while (!((v366 < 0) ^ v28 | (v366 == 0)));
                        }
                      }
                      v372 = v239 - v333 * v134;
                      if (v235 > v332)
                        v373 = 0;
                      else
                        v373 = -1;
                      if (v372 >= 1)
                      {
                        v374 = v372 + 1;
                        do
                        {
                          v375 = v233[v373] * 536870000.0;
                          if (v375 < 0.0)
                            v376 = -(int)(float)(0.5 - v375);
                          else
                            v376 = (int)(float)(v375 + 0.5);
                          *(_DWORD *)v129 = v376;
                          v129 += 2;
                          --v374;
                        }
                        while (v374 > 1);
                      }
                    }
                    else
                    {
                      v290 = v39 + 1;
                      v291 = v238;
                      if ((int)v39 >= 1)
                      {
                        do
                        {
                          if (v136 < 1)
                          {
                            v292 = v235 - 1;
                            if (v235 >= 1)
                            {
                              v136 += v134;
                              if (v136 < 1)
                              {
                                v113 = 983;
                                goto LABEL_800;
                              }
                              v293 = *v233++;
                              v294 = (int)(float)(0.5 - (float)(v293 * 536870000.0));
                              v295 = (int)(float)((float)(v293 * 536870000.0) + 0.5);
                              v291 = v238;
                              if ((float)(v293 * 536870000.0) < 0.0)
                                v238 = -v294;
                              else
                                v238 = v295;
                              v235 = v292;
                            }
                          }
                          v296 = v291 + ((v238 - v291 + 2) >> 2);
                          if (v136 < v180)
                            v296 = (v238 + v291) >> 1;
                          if (v136 <= v181)
                            v296 = v238 + ((v291 - v238 + 2) >> 2);
                          if (v136 <= v182)
                            v296 = v238;
                          *(_DWORD *)v129 = v296;
                          v129 += 2;
                          v136 -= v135;
                          --v290;
                        }
                        while (v290 > 1);
                      }
                    }
                  }
                  goto LABEL_633;
                }
                if (!v130)
                {
                  v113 = 756;
LABEL_805:
                  v115 = "interpolate_and_convert";
                  v116 = "dp16 != NULL";
                  goto LABEL_802;
                }
                v186 = (__int16 *)(v125 + 2 * v185);
                v189 = *v186;
                v187 = v186 + 1;
                v188 = v189;
                v190 = v183 - 1;
                if (v135 != 1)
                {
                  v221 = v39 + 1;
                  v222 = v188;
                  if ((int)v39 >= 1)
                  {
                    while (1)
                    {
                      if (v136 < 1 && v190 >= 1)
                      {
                        v136 += v134;
                        if (v136 < 1)
                        {
                          v113 = 817;
LABEL_800:
                          v115 = "interpolate_and_convert";
LABEL_801:
                          v116 = "expand_counter > 0";
LABEL_802:
                          __assert_rtn(v115, "kdu_region_decompressor.cpp", v113, v116);
                        }
                        v222 = v188;
                        v223 = *v187++;
                        v188 = v223;
                        --v190;
                      }
                      v224 = (v188 + v222) >> 1;
                      if (v136 >= v180)
                        LOWORD(v224) = v222 + ((v188 - v222 + 2) >> 2);
                      if (v136 <= v181)
                        LOWORD(v224) = v188 + ((v222 - v188 + 2) >> 2);
                      if (v136 <= v182)
                        LOWORD(v224) = v188;
                      *v129++ = v224;
                      v136 -= v135;
                      if (--v221 <= 1)
                        goto LABEL_633;
                    }
                  }
                  goto LABEL_633;
                }
                if ((int)v39 < 1 || v136 < 1)
                {
                  v191 = v39;
                }
                else
                {
                  v191 = v39;
                  do
                  {
                    v192 = v191;
                    *v129++ = v188;
                    --v191;
                    if (v192 < 2)
                      break;
                    v13 = v136-- > 1;
                  }
                  while (v13);
                }
                v251 = v191 / v134;
                if (v191 / v134 >= v190)
                  v252 = v183 - 1;
                else
                  v252 = v191 / v134;
                if (v134 == 1)
                {
                  if (v252 < 1)
                    goto LABEL_460;
                  v261 = v252 + 1;
                  do
                  {
                    v262 = *v187++;
                    *v129++ = v262;
                    --v261;
                  }
                  while (v261 > 1);
                }
                else
                {
                  if (v134 == 2)
                  {
                    if (v252 >= 1)
                    {
                      v253 = v252 + 1;
                      do
                      {
                        v254 = *v187++;
                        *v129 = v254;
                        v129[1] = v254;
                        v129 += 2;
                        --v253;
                      }
                      while (v253 > 1);
                      goto LABEL_387;
                    }
LABEL_460:
                    v266 = v252;
LABEL_461:
                    v304 = v191 - v252 * v134;
                    if (v304 >= 1)
                    {
                      v305 = &v187[v266];
                      v306 = &v129[v266 * v134];
                      if (v190 > v251)
                        v307 = 0;
                      else
                        v307 = -1;
                      v308 = v305[v307];
                      v309 = v304 + 1;
                      do
                      {
                        *v306++ = v308;
                        --v309;
                      }
                      while (v309 > 1);
                    }
                    goto LABEL_633;
                  }
                  v265 = v252;
                  v266 = v252;
                  if (v252 < 1)
                    goto LABEL_461;
                  do
                  {
                    v268 = *v187++;
                    v267 = v268;
                    v269 = v134;
                    do
                    {
                      *v129++ = v267;
                      --v269;
                    }
                    while (v269);
                    v28 = __OFSUB__(v265--, 1);
                  }
                  while (!((v265 < 0) ^ v28 | (v265 == 0)));
                }
LABEL_387:
                v266 = 0;
                goto LABEL_461;
              }
              if (v130)
              {
                if ((int)v39 >= 1)
                {
                  v131 = v130;
                  v145 = 2 * v39;
LABEL_244:
                  bzero(v131, v145);
                }
              }
              else if ((int)v39 >= 1)
              {
                v145 = 4 * v39;
                goto LABEL_244;
              }
            }
LABEL_633:
            v405 = *(unsigned __int16 *)(v102 + 96 * v100 + 94);
            if (*(_WORD *)(v102 + 96 * v100 + 94))
            {
              v406 = *(_QWORD *)(v102 + 96 * v100 + 64);
              if (*(_DWORD *)v406 < (int)v39)
              {
                v113 = 1018;
                v115 = "apply_white_stretch";
                v116 = "num_cols <= line->get_width()";
                goto LABEL_802;
              }
              v407 = *(_BYTE *)(v406 + 6);
              v408 = *(__int16 **)(v406 + 8);
              if ((v407 & 2) != 0 && v408)
              {
                if ((int)v39 >= 1)
                {
                  v409 = v39 + 1;
                  do
                  {
                    *v408 = *v408 - ((-4096 * v405) >> 16) + ((*v408 * v405) >> 16);
                    ++v408;
                    --v409;
                  }
                  while (v409 > 1);
                }
              }
              else if ((int)v39 >= 1)
              {
                v410 = v39 + 1;
                do
                {
                  *(_DWORD *)v408 += ((*(int *)v408 >> 16) + 4096) * v405;
                  v408 += 2;
                  --v410;
                }
                while (v410 > 1);
              }
            }
            v101 = 1;
LABEL_645:
            ++v100;
          }
          while (v100 < *((int *)this + 40));
          if (((*((_BYTE *)this + 184) != 0) & v101) == 1)
          {
            v411 = *((_DWORD *)this + 41);
            if (v411 > 2)
            {
              v413 = (_QWORD *)*((_QWORD *)this + 21);
              v412 = (uint64_t *)*((_QWORD *)this + 22);
              v414 = v413[8];
              v415 = v413[20];
              v416 = v413[32];
              if (v411 == 3)
                jp2_colour_converter::convert_rgb(v412, v414, v415, v416, v39);
              else
                jp2_colour_converter::convert_rgb4(v412, v414, v415, v416, v413[44], v39);
            }
            else
            {
              jp2_colour_converter::convert_lum(*((uint64_t **)this + 22), *(_QWORD *)(*((_QWORD *)this + 21) + 64), v39);
            }
          }
LABEL_652:
          v41 = *((_DWORD *)this + 48);
          if (v41 < 1)
            goto LABEL_658;
          v417 = (_DWORD *)(*((_QWORD *)this + 25) + 72);
          v418 = 1;
          v419 = *((unsigned int *)this + 48);
          do
          {
            *((_BYTE *)v417 - 53) = 0;
            if ((int)v417[6] <= 0)
              v418 &= *v417 < 1;
            v417 += 28;
            --v419;
          }
          while (v419);
          if ((v418 & 1) != 0)
          {
LABEL_658:
            if (*v505 == v509)
            {
              if (*((int *)this + 40) >= 1)
              {
                for (j = 0; j < *((int *)this + 40); ++j)
                {
                  v421 = *((_QWORD *)this + 21);
                  v422 = *(int **)(v421 + 96 * j);
                  if (v422[22] == 1)
                  {
                    if (*((_BYTE *)this + 185) && (v422[24] > 1 || v422[18] < 1))
                    {
                      v434 = v421 + 96 * j;
                      *(_QWORD *)(v434 + 72) = v434 + 40;
                      v435 = *(_BYTE *)(v434 + 46);
                      if ((v435 & 2) != 0)
                        v436 = *(void **)(v421 + 96 * j + 48);
                      else
                        v436 = 0;
                      v446 = *(_QWORD *)(v421 + 96 * j + 64);
                      if ((*(_BYTE *)(v446 + 6) & 2) != 0)
                      {
                        v447 = *(const void **)(v446 + 8);
                        if (!v436)
                          goto LABEL_700;
LABEL_698:
                        v448 = 2 * (int)v39;
                      }
                      else
                      {
                        v447 = 0;
                        if (v436)
                          goto LABEL_698;
LABEL_700:
                        if ((v435 & 2) != 0)
                        {
                          v436 = 0;
                          if ((*(_BYTE *)(v446 + 6) & 2) == 0)
                            goto LABEL_726;
LABEL_702:
                          v447 = 0;
                        }
                        else
                        {
                          v436 = *(void **)(v421 + 96 * j + 48);
                          if ((*(_BYTE *)(v446 + 6) & 2) != 0)
                            goto LABEL_702;
LABEL_726:
                          v447 = *(const void **)(v446 + 8);
                        }
                        v448 = 4 * (int)v39;
                      }
                      memcpy(v436, v447, v448);
                      continue;
                    }
                    *(_QWORD *)(v421 + 96 * j + 72) = *(_QWORD *)(v421 + 96 * j + 64);
                  }
                  else
                  {
                    v423 = v421 + 96 * j;
                    *(_QWORD *)(v423 + 72) = v423 + 40;
                    v424 = *(_QWORD *)(v423 + 56);
                    if (!v424 || (v425 = *(_QWORD *)(v421 + 96 * j + 64)) == 0)
                    {
                      v497 = __cxa_allocate_exception(4uLL);
                      *v497 = -50;
                      __cxa_throw(v497, MEMORY[0x1E0DE4EF0], 0);
                    }
                    v426 = v422[24];
                    v427 = v422[20];
                    v428 = (3 * v427) >> 2;
                    v429 = v427 >> 1;
                    v430 = v427 >> 2;
                    if ((*(_BYTE *)(v421 + 96 * j + 46) & 2) != 0 && (v431 = *(_WORD **)(v421 + 96 * j + 48)) != 0)
                    {
                      if ((*(_BYTE *)(v424 + 6) & 2) != 0)
                        v432 = *(__int16 **)(v424 + 8);
                      else
                        v432 = 0;
                      if ((*(_BYTE *)(v425 + 6) & 2) == 0)
                      {
                        v438 = 1069;
LABEL_818:
                        __assert_rtn("interpolate_between_lines", "kdu_region_decompressor.cpp", v438, "(sp1 != NULL) && (sp2 != NULL) && (dp != NULL)");
                      }
                      v438 = 1069;
                      if (!v432)
                        goto LABEL_818;
                      v453 = *(__int16 **)(v425 + 8);
                      if (!v453)
                        goto LABEL_818;
                      if (v430 >= v426)
                      {
                        if ((int)v39 >= 1)
                        {
                          v458 = v39 + 1;
                          do
                          {
                            v459 = *v453++;
                            *v431++ = v459;
                            --v458;
                          }
                          while (v458 > 1);
                        }
                      }
                      else if (v429 >= v426)
                      {
                        if ((int)v39 >= 1)
                        {
                          v464 = v39 + 1;
                          do
                          {
                            v466 = *v453++;
                            v465 = v466;
                            v467 = *v432++;
                            *v431++ = v465 + ((v467 - v465 + 2) >> 2);
                            --v464;
                          }
                          while (v464 > 1);
                        }
                      }
                      else if (v428 <= v426)
                      {
                        v468 = v39 + 1;
                        if ((int)v39 >= 1)
                        {
                          do
                          {
                            v470 = *v432++;
                            v469 = v470;
                            v471 = *v453++;
                            *v431++ = v469 + ((v471 - v469 + 2) >> 2);
                            --v468;
                          }
                          while (v468 > 1);
                        }
                      }
                      else if ((int)v39 >= 1)
                      {
                        v454 = v39 + 1;
                        do
                        {
                          v456 = *v453++;
                          v455 = v456;
                          v457 = *v432++;
                          *v431++ = (v457 + v455) >> 1;
                          --v454;
                        }
                        while (v454 > 1);
                      }
                    }
                    else
                    {
                      if ((*(_BYTE *)(v424 + 6) & 2) != 0)
                        v433 = 0;
                      else
                        v433 = *(int **)(v424 + 8);
                      if ((*(_BYTE *)(v425 + 6) & 2) != 0)
                        v437 = 0;
                      else
                        v437 = *(int **)(v425 + 8);
                      v438 = 1096;
                      if ((*(_BYTE *)(v421 + 96 * j + 46) & 2) != 0)
                        goto LABEL_818;
                      if (!v433)
                        goto LABEL_818;
                      if (!v437)
                        goto LABEL_818;
                      v439 = *(int **)(v421 + 96 * j + 48);
                      if (!v439)
                        goto LABEL_818;
                      if (v430 >= v426)
                      {
                        if ((int)v39 >= 1)
                        {
                          v444 = v39 + 1;
                          do
                          {
                            v445 = *v437++;
                            *v439++ = v445;
                            --v444;
                          }
                          while (v444 > 1);
                        }
                      }
                      else if (v429 >= v426)
                      {
                        if ((int)v39 >= 1)
                        {
                          v449 = v39 + 1;
                          do
                          {
                            v451 = *v437++;
                            v450 = v451;
                            v452 = *v433++;
                            *v439++ = v450 + ((v452 - v450 + 2) >> 2);
                            --v449;
                          }
                          while (v449 > 1);
                        }
                      }
                      else if (v428 <= v426)
                      {
                        v460 = v39 + 1;
                        if ((int)v39 >= 1)
                        {
                          do
                          {
                            v462 = *v433++;
                            v461 = v462;
                            v463 = *v437++;
                            *v439++ = v461 + ((v463 - v461 + 2) >> 2);
                            --v460;
                          }
                          while (v460 > 1);
                        }
                      }
                      else if ((int)v39 >= 1)
                      {
                        v440 = v39 + 1;
                        do
                        {
                          v442 = *v437++;
                          v441 = v442;
                          v443 = *v433++;
                          *v439++ = (v443 + v441) >> 1;
                          --v440;
                        }
                        while (v440 > 1);
                      }
                    }
                  }
                }
              }
              if (*((_BYTE *)this + 185))
              {
                v472 = *((_DWORD *)this + 41);
                if (v472 > 2)
                {
                  v474 = (_QWORD *)*((_QWORD *)this + 21);
                  v473 = (uint64_t *)*((_QWORD *)this + 22);
                  v475 = v474[9];
                  v476 = v474[21];
                  v477 = v474[33];
                  if (v472 == 3)
                    jp2_colour_converter::convert_rgb(v473, v475, v476, v477, v39);
                  else
                    jp2_colour_converter::convert_rgb4(v473, v475, v476, v477, v474[45], v39);
                }
                else
                {
                  jp2_colour_converter::convert_lum(*((uint64_t **)this + 22), *(_QWORD *)(*((_QWORD *)this + 21) + 72), v39);
                }
              }
              if (*((int *)this + 56) >= 1)
              {
                v478 = 0;
                while (1)
                {
                  v479 = *(_WORD **)(*((_QWORD *)this + 29) + 8 * v478);
                  if (v479)
                  {
                    v480 = *((_QWORD *)this + 21);
                    if (v478)
                    {
                      if (v478 >= *((int *)this + 40))
                        v481 = 0;
                      else
                        v481 = v478;
                      v480 += 96 * v481;
                    }
                    if (v478 >= v512 && a11)
                    {
                      if (v508 != 1)
                        __assert_rtn("process_generic", "kdu_region_decompressor.cpp", 2976, "sample_bytes == 1");
                      v482 = v39 + 1;
                      if ((int)v39 >= 1)
                      {
                        do
                        {
                          *(_BYTE *)v479 = -1;
                          v479 = (_WORD *)((char *)v479 + v40);
                          --v482;
                        }
                        while (v482 > 1);
                      }
                      goto LABEL_769;
                    }
                    if (a10)
                    {
                      v483 = 0;
                      if (v508 != 1)
                      {
                        v484 = a10;
                        if (v508 != 2)
                        {
                          v498 = 3007;
                          goto LABEL_820;
                        }
                        goto LABEL_768;
                      }
                      v485 = a10;
                    }
                    else
                    {
                      if (v508 == 2)
                      {
                        v484 = *(_DWORD *)(v480 + 88);
                        v483 = *(_BYTE *)(v480 + 92) != 0;
LABEL_768:
                        transfer_fixed_point(*(_QWORD *)(v480 + 72), v39, v506, v479, v484, v483);
                        goto LABEL_769;
                      }
                      if (v508 != 1)
                      {
                        v498 = 2993;
LABEL_820:
                        __assert_rtn("process_generic", "kdu_region_decompressor.cpp", v498, "0");
                      }
                      v485 = *(_DWORD *)(v480 + 88);
                      v483 = *(_BYTE *)(v480 + 92) != 0;
                    }
                    transfer_fixed_point(*(_QWORD *)(v480 + 72), v39, v506, v479, v485, v483);
                  }
LABEL_769:
                  ++v478;
                  v486 = *((int *)this + 56);
                  if (v478 >= v486)
                  {
                    if ((int)v486 >= 1)
                    {
                      v487 = 0;
                      v488 = 8 * *((unsigned int *)this + 56);
                      do
                      {
                        v489 = *((_QWORD *)this + 29);
                        v490 = *(_QWORD *)(v489 + v487);
                        if (v490)
                          *(_QWORD *)(v489 + v487) = v490 + v511;
                        v487 += 8;
                      }
                      while (v488 != v487);
                    }
                    break;
                  }
                }
              }
              ++v509;
              v504 = (v504 - 1) | v504 & 0xFFFFFFFF00000000;
              ++*(_DWORD *)(a9 + 8);
              if (v503 == v502)
              {
                v491 = *v505 + 1;
                v492 = v491 - *v501;
                if (v491 <= *v501)
                  __assert_rtn("process_generic", "kdu_region_decompressor.cpp", 3021, "y > 0");
                *v501 = v491;
                v501[2] -= v492;
              }
            }
            v41 = *((_DWORD *)this + 48);
            if (v41 >= 1)
            {
              v493 = (_DWORD *)(*((_QWORD *)this + 25) + 96);
              v494 = *((unsigned int *)this + 48);
              do
              {
                *v493 -= *(v493 - 2);
                v493 += 28;
                --v494;
              }
              while (v494);
            }
            ++*((_DWORD *)this + 31);
            --*((_DWORD *)this + 33);
          }
          --v31;
          if (v510 <= 1)
          {
            if (SHIDWORD(v504) < 1 || (int)v504 <= 0)
              goto LABEL_785;
            return 1;
          }
        }
      }
      goto LABEL_822;
    }
  }
  if (*((_DWORD *)this + 26) == *((_DWORD *)this + 22))
  {
    v27 = *((_DWORD *)this + 33) + *((_DWORD *)this + 31);
    v28 = __OFSUB__(v27, *a8);
    v29 = v27 - *a8;
    if (!((v29 < 0) ^ v28 | (v29 == 0)))
    {
      v30 = a8[2];
      if (v29 >= v30)
        v29 = a8[2];
      *a8 += v29;
      a8[2] = v30 - v29;
    }
  }
LABEL_785:
  kdu_region_decompressor::close_tile(this);
  return 1;
}

void sub_187EFFCE8()
{
  uint64_t v0;

  kdu_error::~kdu_error((kdu_error *)(v0 - 160));
}

void sub_187EFFCF8()
{
  uint64_t v0;
  _Unwind_Exception *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;

  if (v2 == 1)
  {
    v3 = *(unsigned int *)__cxa_begin_catch(v1);
    *(_BYTE *)(v0 + 80) = 1;
    v4 = *(_QWORD *)(v0 + 16);
    if (v4)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 32))(v4, v3);
    __cxa_end_catch();
    JUMPOUT(0x187EFDAE4);
  }
  _Unwind_Resume(v1);
}

uint64_t kdu_region_decompressor::process(kdu_region_decompressor *this, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int *a8, uint64_t a9)
{
  int v17;
  int v18;
  uint64_t v19;
  unsigned __int8 v20;
  uint64_t v21;
  uint64_t i;
  uint64_t v23;
  _OWORD v25[2];
  uint64_t v26;

  v17 = *((_DWORD *)this + 41);
  if (v17 == 2)
  {
    v26 = 0;
    memset(v25, 0, sizeof(v25));
    kdu_error::kdu_error((kdu_error *)v25, "Error in Kakadu Region Decompressor:\n");
    kdu_error::~kdu_error((kdu_error *)v25);
  }
  if (v17 == 1)
    v18 = 4;
  else
    v18 = v17 + 1;
  *((_DWORD *)this + 56) = v18;
  if (*((_DWORD *)this + 55) < v18)
  {
    *((_DWORD *)this + 55) = v18;
    v19 = *((_QWORD *)this + 29);
    if (v19)
      MEMORY[0x18D761C18](v19, 0x10C80436913F5);
    *((_QWORD *)this + 29) = operator new[]();
  }
  if (a4 == 4)
  {
    **((_QWORD **)this + 29) = a2;
    *(_QWORD *)(*((_QWORD *)this + 29) + 8) = a2 + 1;
    *(_QWORD *)(*((_QWORD *)this + 29) + 16) = a2 + 2;
    *(_QWORD *)(*((_QWORD *)this + 29) + 24) = a2 + 3;
    v20 = *((_DWORD *)this + 40) == *((_DWORD *)this + 41);
  }
  else
  {
    v21 = *((unsigned int *)this + 40);
    if ((int)v21 < 1)
    {
      LODWORD(v21) = 0;
    }
    else
    {
      for (i = 0; i != v21; ++i)
        *(_QWORD *)(*((_QWORD *)this + 29) + 8 * i) = a2 + i;
    }
    v23 = *((unsigned int *)this + 56);
    if ((int)v21 < (int)v23)
    {
      v21 = v21;
      do
        *(_QWORD *)(*((_QWORD *)this + 29) + 8 * v21++) = 0;
      while (v23 != v21);
    }
    v20 = 0;
  }
  return kdu_region_decompressor::process_generic(this, 1, a4, a3, a5 * a4, a6, a7, a8, a9, 8, v20);
}

void sub_187EFFF64(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187EFFF70()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t transfer_fixed_point(uint64_t result, int a2, int a3, _BYTE *a4, int a5, int a6)
{
  __int16 *v6;
  char v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  char v13;
  char v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  char v19;
  char v20;
  char v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  signed int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  char v31;
  char v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  char v43;
  unsigned int v44;
  int v45;
  int v46;
  char v47;

  if (*(_DWORD *)result < a2)
    transfer_fixed_point();
  v6 = *(__int16 **)(result + 8);
  if ((*(_BYTE *)(result + 6) & 2) == 0)
  {
    if ((*(_BYTE *)(result + 6) & 1) == 0 && v6)
    {
      if (a5 > 8)
      {
        v20 = a5 - 29;
        if (a5 < 0x1D)
          v20 = 0;
        v21 = 29 - a5;
        if (a5 > 0x1D)
          v21 = 0;
        v22 = (1 << v21) >> 1;
        v23 = -128 >> v20;
        if (a6)
        {
          v24 = 127;
        }
        else
        {
          v23 = 0;
          v24 = 255;
        }
        if (!a6)
          v22 += 4096;
        if (a2 >= 1)
        {
          v25 = v24 >> v20;
          v26 = a2 + 1;
          do
          {
            v27 = *(_DWORD *)v6;
            v6 += 2;
            v28 = (int)(v27 + v22) >> v21;
            if (v28 >= v25)
              v29 = v25;
            else
              v29 = v28;
            if (v28 >= v23)
              v30 = v29;
            else
              v30 = v23;
            *a4 = v30 << v20;
            a4 += a3;
            --v26;
          }
          while (v26 > 1);
        }
      }
      else
      {
        v7 = 29 - a5;
        v8 = (1 << (29 - a5) >> 1) + 0x10000000;
        v9 = -1 << a5;
        if ((a6 & 1) != 0)
        {
          if (a2 >= 1)
          {
            v10 = a2 + 1;
            do
            {
              v11 = *(_DWORD *)v6;
              v6 += 2;
              v12 = (v11 + v8) >> v7;
              if (v12 >= 0)
                v13 = ~(_BYTE)v9;
              else
                v13 = 0;
              if ((v12 & v9) != 0)
                LOBYTE(v12) = v13;
              *a4 = v12 - ((1 << a5) >> 1);
              a4 += a3;
              --v10;
            }
            while (v10 > 1);
          }
        }
        else if (a2 >= 1)
        {
          v40 = a2 + 1;
          do
          {
            v41 = *(_DWORD *)v6;
            v6 += 2;
            v42 = (v41 + v8) >> v7;
            if (v42 >= 0)
              v43 = ~(_BYTE)v9;
            else
              v43 = 0;
            if ((v42 & v9) != 0)
              LOBYTE(v42) = v43;
            *a4 = v42;
            a4 += a3;
            --v40;
          }
          while (v40 > 1);
        }
      }
      return result;
    }
LABEL_85:
    transfer_fixed_point();
  }
  if (!v6)
    goto LABEL_85;
  if ((*(_BYTE *)(result + 6) & 1) != 0)
    transfer_fixed_point();
  if (a5 > 8)
  {
    v31 = a5 - 13;
    if (a5 < 0xD)
      v31 = 0;
    v32 = 13 - a5;
    if (a5 > 0xD)
      v32 = 0;
    v33 = (1 << v32) >> 1;
    v34 = -128 >> v31;
    if (a6)
    {
      v35 = 127;
    }
    else
    {
      v34 = 0;
      v35 = 255;
    }
    if (!a6)
      v33 += 4096;
    if (a2 >= 1)
    {
      v36 = v35 >> v31;
      v37 = a2 + 1;
      do
      {
        v38 = *v6++;
        v39 = (int)(v33 + v38) >> v32;
        result = (__int16)v39;
        if ((int)result > v36)
          v39 = v36;
        if ((int)result < (__int16)v34)
          v39 = v34;
        *a4 = v39 << v31;
        a4 += a3;
        --v37;
      }
      while (v37 > 1);
    }
  }
  else
  {
    v14 = 13 - a5;
    v15 = ((0x8000 << (13 - a5)) >> 16) + 4096;
    if ((a6 & 1) != 0)
    {
      if (a2 >= 1)
      {
        v16 = a2 + 1;
        do
        {
          v17 = *v6++;
          v18 = (v17 + (__int16)v15) >> v14;
          if ((v18 & 0x8000) != 0)
            v19 = 0;
          else
            v19 = ~(-1 << a5);
          if (((-65536 << a5) & (v18 << 16)) != 0)
            LOBYTE(v18) = v19;
          *a4 = v18 - ((0x8000 << a5) >> 16);
          a4 += a3;
          --v16;
        }
        while (v16 > 1);
      }
    }
    else if (a2 >= 1)
    {
      v44 = a2 + 1;
      do
      {
        v45 = *v6++;
        v46 = (v45 + (__int16)v15) >> v14;
        if ((v46 & 0x8000) != 0)
          v47 = 0;
        else
          v47 = ~(-1 << a5);
        if (((-65536 << a5) & (v46 << 16)) != 0)
          LOBYTE(v46) = v47;
        *a4 = v46;
        a4 += a3;
        --v44;
      }
      while (v44 > 1);
    }
  }
  return result;
}

uint64_t transfer_fixed_point(uint64_t result, int a2, int a3, _WORD *a4, int a5, int a6)
{
  __int16 *v6;
  char v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  __int16 v13;
  char v14;
  char v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  __int16 v20;
  char v21;
  char v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  signed int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  __int16 v33;
  int v34;
  unsigned int v35;
  int v36;
  int v37;
  __int16 v38;
  unsigned int v39;
  int v40;
  int v41;
  __int16 v42;
  int v43;
  unsigned int v44;
  int v45;
  signed int v46;
  unsigned int v47;
  int v48;
  int v49;
  signed int v50;
  int v51;
  unsigned int v52;
  __int16 v53;
  int v54;

  if (*(_DWORD *)result < a2)
    transfer_fixed_point();
  v6 = *(__int16 **)(result + 8);
  if ((*(_BYTE *)(result + 6) & 2) == 0)
  {
    if ((*(_BYTE *)(result + 6) & 1) == 0 && v6)
    {
      if (a5 > 16)
      {
        v21 = a5 - 29;
        if (a5 < 0x1D)
          v21 = 0;
        v22 = 29 - a5;
        if (a5 > 0x1D)
          v22 = 0;
        v23 = (1 << v22) >> 1;
        v24 = -32768 >> v21;
        if (a6)
        {
          v25 = 0x7FFF;
        }
        else
        {
          v24 = 0;
          v25 = 0xFFFF;
        }
        if (!a6)
          v23 += 4096;
        if (a2 >= 1)
        {
          v26 = v25 >> v21;
          v27 = a2 + 1;
          do
          {
            v28 = *(_DWORD *)v6;
            v6 += 2;
            v29 = (int)(v28 + v23) >> v22;
            if (v29 >= v26)
              v30 = v26;
            else
              v30 = v29;
            if (v29 >= v24)
              v31 = v30;
            else
              v31 = v24;
            *a4 = (v31 << v21);
            --v27;
            a4 += a3;
          }
          while (v27 > 1);
        }
      }
      else
      {
        v7 = 29 - a5;
        v8 = (1 << (29 - a5) >> 1) + 0x10000000;
        v9 = -1 << a5;
        if ((a6 & 1) != 0)
        {
          if (a2 >= 1)
          {
            v10 = a2 + 1;
            do
            {
              v11 = *(_DWORD *)v6;
              v6 += 2;
              v12 = (v11 + v8) >> v7;
              if (v12 >= 0)
                v13 = ~(_WORD)v9;
              else
                v13 = 0;
              if ((v12 & v9) != 0)
                LOWORD(v12) = v13;
              *a4 = v12 - ((1 << a5) >> 1);
              --v10;
              a4 += a3;
            }
            while (v10 > 1);
          }
        }
        else if (a2 >= 1)
        {
          v35 = a2 + 1;
          do
          {
            v36 = *(_DWORD *)v6;
            v6 += 2;
            v37 = (v36 + v8) >> v7;
            if (v37 >= 0)
              v38 = ~(_WORD)v9;
            else
              v38 = 0;
            if ((v37 & v9) != 0)
              LOWORD(v37) = v38;
            *a4 = v37;
            --v35;
            a4 += a3;
          }
          while (v35 > 1);
        }
      }
      return result;
    }
LABEL_98:
    transfer_fixed_point();
  }
  if (!v6)
    goto LABEL_98;
  if ((*(_BYTE *)(result + 6) & 1) != 0)
    transfer_fixed_point();
  v14 = a5 - 13;
  if (a5 > 13)
  {
    if (a5 > 0x10)
    {
      v43 = -32768 >> v14;
      if (a6)
      {
        v44 = 0x7FFF;
      }
      else
      {
        v43 = 0;
        v44 = 0xFFFF;
      }
      if (a6)
        v45 = 0;
      else
        v45 = 4096;
      if (a2 >= 1)
      {
        v46 = v44 >> v14;
        v47 = a2 + 1;
        do
        {
          v48 = *v6++;
          v49 = v45 + v48;
          if (v45 + v48 >= v46)
            v50 = v46;
          else
            v50 = v49;
          if (v49 >= v43)
            v51 = v50;
          else
            v51 = v43;
          *a4 = v51 << v14;
          --v47;
          a4 += a3;
        }
        while (v47 > 1);
      }
    }
    else if ((a6 & 1) != 0)
    {
      if (a2 >= 1)
      {
        v32 = a2 + 1;
        do
        {
          v33 = *v6++;
          v34 = (__int16)(v33 + 4096) & ~((__int16)(v33 + 4096) >> 31);
          if (v34 >= 0x1FFF)
            v34 = 0x1FFF;
          *a4 = (v34 + 61440) << v14;
          --v32;
          a4 += a3;
        }
        while (v32 > 1);
      }
    }
    else if (a2 >= 1)
    {
      v52 = a2 + 1;
      do
      {
        v53 = *v6++;
        v54 = (__int16)(v53 + 4096) & ~((__int16)(v53 + 4096) >> 31);
        if (v54 >= 0x1FFF)
          v54 = 0x1FFF;
        *a4 = v54 << v14;
        --v52;
        a4 += a3;
      }
      while (v52 > 1);
    }
  }
  else
  {
    v15 = 13 - a5;
    v16 = ((0x8000 << (13 - a5)) >> 16) + 4096;
    if ((a6 & 1) != 0)
    {
      if (a2 >= 1)
      {
        v17 = a2 + 1;
        do
        {
          v18 = *v6++;
          v19 = (v18 + (__int16)v16) >> v15;
          if ((v19 & 0x8000) != 0)
            v20 = 0;
          else
            v20 = ~(-1 << a5);
          if (((-65536 << a5) & (v19 << 16)) != 0)
            LOWORD(v19) = v20;
          *a4 = v19 - ((0x8000 << a5) >> 16);
          --v17;
          a4 += a3;
        }
        while (v17 > 1);
      }
    }
    else if (a2 >= 1)
    {
      v39 = a2 + 1;
      do
      {
        v40 = *v6++;
        v41 = (v40 + (__int16)v16) >> v15;
        if ((v41 & 0x8000) != 0)
          v42 = 0;
        else
          v42 = ~(-1 << a5);
        if (((-65536 << a5) & (v41 << 16)) != 0)
          LOWORD(v41) = v42;
        *a4 = v41;
        --v39;
        a4 += a3;
      }
      while (v39 > 1);
    }
  }
  return result;
}

uint64_t kdu_sample_allocator::pre_alloc(uint64_t this, int a2, int a3, int a4, int a5)
{
  char v5;

  if (!*(_BYTE *)this)
    kdu_sample_allocator::pre_alloc();
  if (a2)
    v5 = 1;
  else
    v5 = 2;
  *(_DWORD *)(this + 4) += ((((a4 << v5) + 15) & 0xFFFFFFF0) + (((a3 << v5) + 15) & 0xFFFFFFF0)) * a5;
  return this;
}

uint64_t kdu_sample_allocator::alloc16(kdu_sample_allocator *this, int a2, int a3)
{
  signed int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;

  if (*(_BYTE *)this)
    kdu_sample_allocator::alloc16();
  v3 = (a2 + 7) & 0xFFFFFFF8;
  v4 = *((_QWORD *)this + 2);
  v5 = *((_DWORD *)this + 1);
  v6 = *((int *)this + 2);
  v7 = v6 + 2 * (((a3 + 7) & 0x7FFFFFF8) + v3);
  *((_DWORD *)this + 2) = v7;
  if (v7 > v5)
    kdu_sample_allocator::alloc16();
  return v4 + v6 + 2 * v3;
}

uint64_t kdu_sample_allocator::alloc32(kdu_sample_allocator *this, int a2, int a3)
{
  signed int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;

  if (*(_BYTE *)this)
    kdu_sample_allocator::alloc32();
  v3 = (a2 + 3) & 0xFFFFFFFC;
  v4 = *((_QWORD *)this + 2);
  v5 = *((_DWORD *)this + 1);
  v6 = *((int *)this + 2);
  v7 = v6 + 4 * (((a3 + 3) & 0x3FFFFFFC) + v3);
  *((_DWORD *)this + 2) = v7;
  if (v7 > v5)
    kdu_sample_allocator::alloc32();
  return v4 + v6 + 4 * v3;
}

void kdu_block::kdu_block(kdu_block *this)
{
  *((_QWORD *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_WORD *)this + 18) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  *(_DWORD *)((char *)this + 23) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_WORD *)this + 60) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 20) = 0;
}

void kdu_block::~kdu_block(kdu_block *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *((_QWORD *)this + 7);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C8052888210);
  v3 = *((_QWORD *)this + 8);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C80BDFB0063);
  v4 = *((_QWORD *)this + 9);
  if (v4)
    MEMORY[0x18D761C18](v4 - 1, 0x1000C8077774924);
  v5 = *((_QWORD *)this + 16);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C8052888210);
  v6 = *((_QWORD *)this + 13);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x1000C8052888210);
}

uint64_t kdu_block::set_max_passes(uint64_t this, int a2, int a3)
{
  int v3;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _WORD *v13;
  int *v14;
  _DWORD *v15;
  _WORD *v16;
  int v17;

  v3 = *(_DWORD *)(this + 88);
  if (v3 < a2)
  {
    v5 = this;
    if (v3)
      v6 = a3 == 0;
    else
      v6 = 1;
    if (v6)
    {
      v7 = *(_QWORD *)(this + 56);
      if (v7)
        MEMORY[0x18D761C18](v7, 0x1000C8052888210);
      v8 = *(_QWORD *)(v5 + 64);
      if (v8)
        MEMORY[0x18D761C18](v8, 0x1000C80BDFB0063);
      *(_QWORD *)(v5 + 56) = operator new[]();
      this = operator new[]();
      *(_QWORD *)(v5 + 64) = this;
      goto LABEL_21;
    }
    v9 = operator new[]();
    v10 = operator new[]();
    v11 = *(unsigned int *)(v5 + 88);
    v12 = *(_QWORD *)(v5 + 56);
    if ((int)v11 < 1)
    {
      if (!v12)
      {
LABEL_18:
        this = *(_QWORD *)(v5 + 64);
        if (this)
          this = MEMORY[0x18D761C18](this, 0x1000C80BDFB0063);
        *(_QWORD *)(v5 + 56) = v9;
        *(_QWORD *)(v5 + 64) = v10;
LABEL_21:
        *(_DWORD *)(v5 + 88) = a2;
        return this;
      }
    }
    else
    {
      v13 = *(_WORD **)(v5 + 64);
      v14 = *(int **)(v5 + 56);
      v15 = (_DWORD *)v9;
      v16 = (_WORD *)v10;
      do
      {
        v17 = *v14++;
        *v15++ = v17;
        LOWORD(v17) = *v13++;
        *v16++ = v17;
        --v11;
      }
      while (v11);
    }
    MEMORY[0x18D761C18](v12, 0x1000C8052888210);
    goto LABEL_18;
  }
  return this;
}

uint64_t kdu_block::set_max_bytes(uint64_t this, int a2, int a3)
{
  int v3;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;

  v3 = *(_DWORD *)(this + 92);
  if (v3 < a2)
  {
    v5 = this;
    if (v3)
      v6 = a3 == 0;
    else
      v6 = 1;
    if (v6)
    {
      v7 = *(_QWORD *)(this + 72);
      if (v7)
        MEMORY[0x18D761C18](v7 - 1, 0x1000C8077774924);
      this = operator new[]();
      *(_QWORD *)(v5 + 72) = this + 1;
      *(_QWORD *)(v5 + 80) = this;
    }
    else
    {
      v8 = operator new[]();
      *(_QWORD *)(v5 + 80) = v8;
      v9 = v8 + 1;
      v10 = *(char **)(v5 + 72);
      memcpy((void *)(v8 + 1), v10, *(int *)(v5 + 92));
      this = MEMORY[0x18D761C18](v10 - 1, 0x1000C8077774924);
      *(_QWORD *)(v5 + 72) = v9;
    }
    *(_DWORD *)(v5 + 92) = a2;
  }
  return this;
}

uint64_t kdu_block::set_max_samples(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t v4;

  if (*(_DWORD *)(this + 112) < a2)
  {
    v3 = this;
    v4 = *(_QWORD *)(this + 128);
    if (v4)
      MEMORY[0x18D761C18](v4, 0x1000C8052888210);
    this = operator new[]();
    *(_QWORD *)(v3 + 128) = this;
    *(_QWORD *)(v3 + 96) = this;
    *(_DWORD *)(v3 + 112) = a2;
    if ((this & 3) != 0)
      kdu_block::set_max_samples();
    *(_QWORD *)(v3 + 96) = this + 4 * (-(this >> 2) & 3);
  }
  return this;
}

uint64_t kdu_block::set_max_contexts(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t v4;

  if (*(_DWORD *)(this + 116) < a2)
  {
    v3 = this;
    v4 = *(_QWORD *)(this + 104);
    if (v4)
      MEMORY[0x18D761C18](v4, 0x1000C8052888210);
    this = operator new[]();
    *(_QWORD *)(v3 + 104) = this;
    *(_DWORD *)(v3 + 116) = a2;
  }
  return this;
}

uint64_t kd_block::parse_packet_header(kd_block *this, kd_header_in *a2, kd_buf_server *a3, unsigned __int16 a4)
{
  uint64_t result;
  kd_block *v8;
  kd_block *v9;
  kd_block *v10;
  kd_block *v11;
  uint64_t v12;
  kd_block *v13;
  unsigned int v14;
  uint64_t v15;
  int bit;
  unsigned int v18;
  kd_block *v20;
  int v21;
  int v22;
  int v23;
  kd_block *v24;
  kd_block *v25;
  kd_block *v26;
  kd_block *v27;
  uint64_t v28;
  kd_block *v29;
  unsigned __int8 v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  kd_block *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  char v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  int bits;
  int v46;
  __int16 v47;
  _DWORD *exception;
  __int16 v49;
  struct type_info *v50;
  int v51;

  *((_WORD *)this + 13) = 0;
  if (*((_BYTE *)this + 24))
  {
    result = kd_header_in::get_bit(a2);
    if (!(_DWORD)result)
      return result;
  }
  else
  {
    if (*((unsigned __int16 *)this + 11) != *((unsigned __int16 *)this + 10))
    {
      exception = __cxa_allocate_exception(4uLL);
      v51 = 999;
LABEL_100:
      *exception = v51;
      v50 = (struct type_info *)MEMORY[0x1E0DE4EF0];
      goto LABEL_95;
    }
    v8 = (kd_block *)*((_QWORD *)this + 4);
    if (v8)
    {
      v9 = 0;
      v10 = this;
      do
      {
        v11 = v10;
        v10 = v8;
        *((_QWORD *)v11 + 4) = v9;
        v8 = (kd_block *)*((_QWORD *)v8 + 4);
        v9 = v11;
      }
      while (v8);
    }
    else
    {
      v11 = 0;
      v10 = this;
    }
    v12 = 0;
    v13 = 0;
    *((_QWORD *)v10 + 4) = v11;
    v14 = (unsigned __int16)(a4 + 1);
    do
    {
      if (*((unsigned __int16 *)v10 + 11) >= (unsigned __int16)v12)
      {
        v15 = *((unsigned __int16 *)v10 + 10);
        LOWORD(v12) = *((_WORD *)v10 + 11);
      }
      else
      {
        *((_WORD *)v10 + 11) = v12;
        *((_WORD *)v10 + 10) = v12;
        v15 = v12;
      }
      if ((unsigned __int16)v12 == (unsigned __int16)v15 && v14 > (unsigned __int16)v12)
      {
        LOWORD(v15) = v12;
        do
        {
          *((_WORD *)v10 + 11) = v15 + 1;
          bit = kd_header_in::get_bit(a2);
          v15 = *((unsigned __int16 *)v10 + 10);
          if (!bit)
          {
            v15 = (v15 + 1);
            *((_WORD *)v10 + 10) = v15;
          }
          v18 = *((unsigned __int16 *)v10 + 11);
        }
        while (v18 == (unsigned __int16)v15 && v14 > v18);
      }
      v20 = (kd_block *)*((_QWORD *)v10 + 4);
      *((_QWORD *)v10 + 4) = v13;
      v12 = v15;
      v13 = v10;
      v10 = v20;
    }
    while (v20);
    v21 = *((unsigned __int16 *)this + 11);
    v22 = *((unsigned __int16 *)this + 10);
    if (v21 != v22 && v22 != a4)
    {
      exception = __cxa_allocate_exception(2uLL);
      v49 = 21;
      goto LABEL_94;
    }
    if (v21 == v22)
      return 0;
  }
  v23 = *((unsigned __int8 *)this + 18);
  if (*((_BYTE *)this + 24))
  {
    if (v23 != 255)
      goto LABEL_56;
    goto LABEL_57;
  }
  if (*((_BYTE *)this + 17))
    goto LABEL_53;
  do
  {
    v24 = (kd_block *)*((_QWORD *)this + 4);
    if (v24)
    {
      v25 = 0;
      v26 = this;
      do
      {
        v27 = v26;
        v26 = v24;
        *((_QWORD *)v27 + 4) = v25;
        v24 = (kd_block *)*((_QWORD *)v24 + 4);
        v25 = v27;
      }
      while (v24);
    }
    else
    {
      v27 = 0;
      v26 = this;
    }
    v28 = 0;
    v29 = 0;
    *((_QWORD *)v26 + 4) = v27;
    v30 = *((_BYTE *)this + 24) + 1;
    do
    {
      if (*((unsigned __int8 *)v26 + 24) >= v28)
      {
        v31 = *((unsigned __int8 *)v26 + 17);
        LOBYTE(v28) = *((_BYTE *)v26 + 24);
      }
      else
      {
        *((_BYTE *)v26 + 24) = v28;
        *((_BYTE *)v26 + 17) = v28;
        v31 = v28;
      }
      if (v31 == v28 && v28 < v30)
      {
        LOBYTE(v31) = v28;
        while (1)
        {
          *((_BYTE *)v26 + 24) = v31 + 1;
          v32 = kd_header_in::get_bit(a2);
          v31 = *((unsigned __int8 *)v26 + 17);
          if (!v32)
          {
            v31 = (v31 + 1);
            *((_BYTE *)v26 + 17) = v31;
            if (v31 >= 0x4Bu)
              break;
          }
          v33 = *((unsigned __int8 *)v26 + 24);
          if (v33 != v31 || v33 >= v30)
            goto LABEL_51;
        }
        *((_BYTE *)this + 24) = 0;
        *((_BYTE *)this + 18) = 0;
        exception = __cxa_allocate_exception(2uLL);
        v49 = 74;
LABEL_94:
        *(_WORD *)exception = v49;
        v50 = (struct type_info *)MEMORY[0x1E0DE4F18];
LABEL_95:
        __cxa_throw(exception, v50, 0);
      }
LABEL_51:
      v34 = (kd_block *)*((_QWORD *)v26 + 4);
      *((_QWORD *)v26 + 4) = v29;
      v28 = v31;
      v29 = v26;
      v26 = v34;
    }
    while (v34);
  }
  while (*((unsigned __int8 *)this + 17) == *((unsigned __int8 *)this + 24));
LABEL_53:
  *((_WORD *)this + 11) = 0;
  *((_BYTE *)this + 24) = 3;
  if (*((_BYTE *)this + 19))
  {
    exception = __cxa_allocate_exception(4uLL);
    v51 = 998;
    goto LABEL_100;
  }
  if (v23 != 255)
  {
    kd_block::start_buffering(this, a3);
LABEL_56:
    kd_block::put_byte(this, SHIBYTE(a4), a3);
    kd_block::put_byte(this, a4, a3);
  }
LABEL_57:
  v35 = kd_header_in::get_bit(a2);
  v36 = v35 + 1;
  if (v35 >= 1)
  {
    v36 += kd_header_in::get_bit(a2);
    if (v36 >= 3)
    {
      v36 += kd_header_in::get_bits(a2, 2);
      if (v36 >= 6)
      {
        v36 += kd_header_in::get_bits(a2, 5);
        if (v36 >= 37)
          v36 += kd_header_in::get_bits(a2, 7);
      }
    }
  }
  while (kd_header_in::get_bit(a2))
  {
    v37 = *((unsigned __int8 *)this + 24);
    if (v37 == 255)
      goto LABEL_96;
    *((_BYTE *)this + 24) = v37 + 1;
  }
  v38 = *((unsigned __int8 *)this + 19);
  if (v36 >= 1)
  {
    v39 = *((_BYTE *)this + 25);
    while (1)
    {
      if ((v39 & 4) != 0)
        v40 = 1;
      else
        v40 = v36;
      if ((-1431655765 * (v38 - 10)) >= 0x55555556)
        v41 = 1;
      else
        v41 = 2;
      if (v38 <= 9)
        v41 = 10 - v38;
      if (v41 >= v36)
        v41 = v36;
      v42 = (v39 & 5) == 1 ? v41 : v40;
      v43 = -2;
      do
        v44 = 1 << (v43++ + 2);
      while (v44 <= v42);
      bits = kd_header_in::get_bits(a2, *((unsigned __int8 *)this + 24) + v43);
      if (bits >= 0x8000)
        break;
      v46 = *((unsigned __int16 *)this + 13);
      if (bits >= 0x10000 - v46)
        break;
      *((_WORD *)this + 13) = v46 + bits;
      v36 -= v42;
      if (v23 != 255)
      {
        if (v36 <= 0)
          v47 = bits;
        else
          v47 = bits | 0x8000;
        kd_block::put_byte(this, SHIBYTE(v47), a3);
        kd_block::put_byte(this, v47, a3);
        kd_block::put_byte(this, v42, a3);
      }
      v38 += v42;
      if (v36 <= 0)
        goto LABEL_90;
    }
LABEL_96:
    exception = __cxa_allocate_exception(2uLL);
    v49 = 13;
    goto LABEL_94;
  }
LABEL_90:
  *((_BYTE *)this + 19) = v38;
  if (v23 != 255)
    *((_BYTE *)this + 18) = v38;
  return *((unsigned __int16 *)this + 13);
}

uint64_t kd_block::start_buffering(kd_block *this, kd_buf_server *a2)
{
  uint64_t result;

  if (*(_QWORD *)this)
    kd_block::start_buffering();
  result = kd_buf_server::get(a2);
  *(_QWORD *)this = result;
  *((_QWORD *)this + 1) = result;
  *((_BYTE *)this + 16) = 0;
  return result;
}

uint64_t kd_block::put_byte(kd_block *this, char a2, kd_buf_server *a3)
{
  uint64_t result;
  unsigned int v6;

  result = *((_QWORD *)this + 1);
  if (!result)
    kd_block::put_byte();
  v6 = *((unsigned __int8 *)this + 16);
  if (v6 == 55)
  {
    *((_BYTE *)this + 16) = 0;
    result = kd_buf_server::get(a3);
    **((_QWORD **)this + 1) = result;
    *((_QWORD *)this + 1) = result;
    v6 = *((unsigned __int8 *)this + 16);
  }
  *((_BYTE *)this + 16) = v6 + 1;
  *(_BYTE *)(result + v6 + 9) = a2;
  return result;
}

uint64_t kd_header_in::get_bits(kd_header_in *this, int a2)
{
  int v2;
  uint64_t v4;
  unsigned int v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  BOOL v10;
  _QWORD *exception;

  if (a2 < 1)
    return 0;
  v2 = a2;
  LODWORD(v4) = 0;
  v6 = (unsigned __int8 *)this + 8;
  v5 = *((unsigned __int8 *)this + 8);
  v7 = *((_DWORD *)this + 3);
  do
  {
    if (!v7)
    {
      if (v5 == 255)
        v8 = 7;
      else
        v8 = 8;
      *((_DWORD *)this + 3) = v8;
      if (!kd_input::get(*(kd_input **)this, v6))
      {
        exception = __cxa_allocate_exception(8uLL);
        *exception = this;
      }
      v7 = *((_DWORD *)this + 3);
      v5 = *((unsigned __int8 *)this + 8);
    }
    if (v2 >= v7)
      v9 = v7;
    else
      v9 = v2;
    v7 -= v9;
    *((_DWORD *)this + 3) = v7;
    v4 = (v5 >> v7) & ~(255 << v9) | ((_DWORD)v4 << v9);
    v10 = __OFSUB__(v2, v9);
    v2 -= v9;
  }
  while (!((v2 < 0) ^ v10 | (v2 == 0)));
  return v4;
}

uint64_t kd_block::read_body_bytes(uint64_t this, kd_input *a2, kd_buf_server *a3)
{
  int v3;
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t v8;
  int v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  int v13;
  _DWORD *exception;

  v3 = *(unsigned __int16 *)(this + 26);
  *(_WORD *)(this + 26) = 0;
  if (v3)
  {
    v6 = this;
    if (*(unsigned __int8 *)(this + 18) == 255)
    {
      if (*(_QWORD *)this)
      {
        exception = __cxa_allocate_exception(4uLL);
        *exception = -1;
        __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
      }
      v12 = kd_buf_server::get(a3);
      do
      {
        if (*((_BYTE *)a2 + 544))
          break;
        v13 = v3 >= 55 ? 55 : v3;
        kd_input::read(a2, (unsigned __int8 *)(v12 + 9), v13);
        v11 = __OFSUB__(v3, v13);
        v3 -= v13;
      }
      while (!((v3 < 0) ^ v11 | (v3 == 0)));
      return kd_buf_server::release((uint64_t)a3, v12);
    }
    else
    {
      v7 = *(_BYTE *)(this + 16);
      do
      {
        if (v7 == 55)
        {
          v8 = kd_buf_server::get(a3);
          v7 = 0;
          **(_QWORD **)(v6 + 8) = v8;
          *(_QWORD *)(v6 + 8) = v8;
          *(_BYTE *)(v6 + 16) = 0;
          v9 = 55;
        }
        else
        {
          v9 = 55 - v7;
          v8 = *(_QWORD *)(v6 + 8);
        }
        if (v3 >= v9)
          v10 = v9;
        else
          v10 = v3;
        this = kd_input::read(a2, (unsigned __int8 *)(v8 + v7 + 9), v10);
        if (!(_DWORD)this)
          break;
        v7 = *(_BYTE *)(v6 + 16) + this;
        *(_BYTE *)(v6 + 16) = v7;
        *(_WORD *)(v6 + 22) += this;
        v11 = __OFSUB__(v3, (_DWORD)this);
        v3 -= this;
      }
      while (!((v3 < 0) ^ v11 | (v3 == 0)));
    }
  }
  return this;
}

uint64_t kd_block::retrieve_data(kd_block *this, kdu_block *a2, int a3)
{
  int v3;
  int v7;
  int v8;
  unsigned __int8 *v9;
  int v10;
  uint64_t v11;
  int byte;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  BOOL v23;
  int bytes;
  uint64_t result;
  _DWORD *exception;
  uint64_t *v27[2];

  v3 = *((unsigned __int8 *)this + 18);
  if (v3 == 255)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  *((_DWORD *)a2 + 12) = 0;
  *((_DWORD *)a2 + 11) = *((unsigned __int8 *)this + 17);
  if (!*((_BYTE *)this + 24))
    return 0;
  v7 = *((unsigned __int16 *)this + 11);
  if (v7 + 2 > *((_DWORD *)a2 + 23))
  {
    kdu_block::set_max_bytes((uint64_t)a2, v7 + 4096, 0);
    v3 = *((unsigned __int8 *)this + 18);
  }
  if (*((_DWORD *)a2 + 22) < v3)
  {
    kdu_block::set_max_passes((uint64_t)a2, v3 + 32, 0);
    v3 = *((unsigned __int8 *)this + 18);
  }
  v8 = *((unsigned __int16 *)this + 11);
  v9 = (unsigned __int8 *)*((_QWORD *)a2 + 9);
  v27[0] = *(uint64_t **)this;
  v27[1] = 0;
  if (!v3)
    return 0;
  v10 = 0;
  v11 = 0;
  while (2)
  {
    byte = kd_block_reader::get_byte((kd_block_reader *)v27);
    v13 = kd_block_reader::get_byte((kd_block_reader *)v27) | (byte << 8);
    if (v13 >= a3)
      return 0;
    v14 = v11;
    if (*((_DWORD *)a2 + 12) != v10)
      kd_block::retrieve_data();
    do
    {
      v15 = (char)kd_block_reader::get_byte((kd_block_reader *)v27);
      v16 = kd_block_reader::get_byte((kd_block_reader *)v27);
      v17 = kd_block_reader::get_byte((kd_block_reader *)v27);
      if (v17)
      {
        v18 = v16 & 0xFFFF00FF | (v15 << 8);
        if (v15 >= 0)
          v19 = v18;
        else
          v19 = v18 & 0x7FFF;
        v14 = v14;
        if (v14 <= *((unsigned __int8 *)this + 18))
          v20 = *((unsigned __int8 *)this + 18);
        else
          v20 = v14;
        v21 = v17 + 1;
        while (v20 != v14)
        {
          *(_DWORD *)(*((_QWORD *)a2 + 7) + 4 * v14) = v19;
          *(_WORD *)(*((_QWORD *)a2 + 8) + 2 * v14++) = 0;
          --v21;
          v19 = 0;
          if (v21 <= 1)
            goto LABEL_21;
        }
        return 0xFFFFFFFFLL;
      }
LABEL_21:
      ;
    }
    while (v15 < 0);
    if (!(_BYTE)v14)
      kd_block::retrieve_data();
    *(_WORD *)(*((_QWORD *)a2 + 8) + 2 * v14 - 2) = ~(_WORD)v13;
    if (v11 < v14)
    {
      while (1)
      {
        v22 = *(_DWORD *)(*((_QWORD *)a2 + 7) + 4 * v11);
        v23 = __OFSUB__(v8, v22);
        v8 -= v22;
        if (v8 < 0 != v23)
          return 0;
        *((_DWORD *)a2 + 12) = v11 + 1;
        if (v22 >= 1)
        {
          do
          {
            bytes = kd_block_reader::get_bytes(v27, v9, v22);
            v9 += bytes;
            v23 = __OFSUB__(v22, bytes);
            v22 -= bytes;
          }
          while (!((v22 < 0) ^ v23 | (v22 == 0)));
        }
        LOBYTE(v11) = v11 + 1;
        if (v11 >= v14)
        {
          v11 = v14;
          break;
        }
      }
    }
    result = 0;
    v10 = v11;
    if (v11 < *((unsigned __int8 *)this + 18))
      continue;
    return result;
  }
}

uint64_t kd_block_reader::get_byte(kd_block_reader *this)
{
  int v1;
  _QWORD *v2;
  _DWORD *exception;

  v1 = *((_DWORD *)this + 2);
  v2 = *(_QWORD **)this;
  if (v1 == 55)
  {
    *((_DWORD *)this + 2) = 0;
    v2 = (_QWORD *)*v2;
    *(_QWORD *)this = v2;
    if (!v2)
    {
      exception = __cxa_allocate_exception(4uLL);
      *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    v1 = 0;
  }
  *((_DWORD *)this + 2) = v1 + 1;
  return *((unsigned __int8 *)v2 + v1 + 9);
}

uint64_t kd_block_reader::get_bytes(uint64_t **this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  uint64_t *v4;
  int v5;
  int v6;
  _DWORD *exception;

  LODWORD(v3) = *((_DWORD *)this + 2);
  if ((_DWORD)v3 == 55)
  {
    LODWORD(v3) = 0;
    *((_DWORD *)this + 2) = 0;
    v4 = (uint64_t *)**this;
    *this = v4;
    if (!v4)
    {
      exception = __cxa_allocate_exception(4uLL);
      *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
  }
  v5 = v3 + a3;
  if ((int)v3 + a3 >= 55)
    v5 = 55;
  if ((int)v3 >= v5)
  {
    v6 = v3;
  }
  else
  {
    v3 = (int)v3;
    do
      *a2++ = *((_BYTE *)*this + v3++ + 9);
    while (v5 != v3);
    LODWORD(v3) = *((_DWORD *)this + 2);
    v6 = v5;
  }
  *((_DWORD *)this + 2) = v6;
  return (v5 - v3);
}

uint64_t kd_block::store_data(kd_block *this, kdu_block *a2, kd_buf_server *a3)
{
  int v4;
  uint64_t result;
  int v8;
  uint64_t v9;
  int v10;
  __int16 v11;
  unsigned int v12;
  char *v13;
  int v14;
  int v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;

  if (*((_DWORD *)a2 + 7) != *((unsigned __int8 *)this + 25))
    kd_block::store_data();
  v4 = *((_DWORD *)a2 + 11);
  if (v4 >= 255)
    kd_block::store_data();
  if (*((int *)a2 + 12) > 255)
    kd_block::store_data();
  if (*(_QWORD *)this)
    kd_block::store_data();
  *((_BYTE *)this + 17) = v4;
  result = kd_block::start_buffering(this, a3);
  v8 = *((_DWORD *)a2 + 12);
  *((_BYTE *)this + 18) = v8;
  if (v8 < 1)
  {
    if ((*((_DWORD *)a2 + 23) & 0x80000000) == 0)
      goto LABEL_23;
LABEL_29:
    kd_block::store_data();
  }
  v9 = 0;
  v10 = 0;
  do
  {
    v11 = *(_WORD *)(*((_QWORD *)a2 + 8) + 2 * v9);
    kd_block::put_byte(this, SHIBYTE(v11), a3);
    kd_block::put_byte(this, v11, a3);
    v12 = *(_DWORD *)(*((_QWORD *)a2 + 7) + 4 * v9);
    if (v12 >= 0x10000)
      kd_block::store_data();
    v10 += v12;
    kd_block::put_byte(this, SBYTE1(v12), a3);
    result = kd_block::put_byte(this, v12, a3);
    ++v9;
  }
  while (v9 < *((int *)a2 + 12));
  if (v10 > *((_DWORD *)a2 + 23))
    goto LABEL_29;
  if (v10 >= 1)
  {
    v13 = (char *)*((_QWORD *)a2 + 9);
    do
    {
      v14 = *((unsigned __int8 *)this + 16);
      if (v14 == 55)
      {
        result = kd_buf_server::get(a3);
        **((_QWORD **)this + 1) = result;
        *((_QWORD *)this + 1) = result;
        *((_BYTE *)this + 16) = 0;
        v15 = 55;
      }
      else
      {
        v15 = 55 - v14;
      }
      if (v15 >= v10)
        v15 = v10;
      if (v15)
      {
        v16 = v15;
        do
        {
          v17 = *v13++;
          v18 = *((_QWORD *)this + 1);
          v19 = *((unsigned __int8 *)this + 16);
          *((_BYTE *)this + 16) = v19 + 1;
          *(_BYTE *)(v18 + v19 + 9) = v17;
          --v16;
        }
        while (v16);
      }
      v10 -= v15;
    }
    while (v10 >= 1);
  }
LABEL_23:
  *((_QWORD *)this + 1) = *(_QWORD *)this;
  *((_BYTE *)this + 16) = 0;
  return result;
}

uint64_t *kd_block::store_data(kd_block *this, kdu_block *a2, kd_thread_buf_server *a3)
{
  int v3;
  uint64_t *result;
  int v8;
  uint64_t v9;
  int v10;
  __int16 v11;
  unsigned int v12;
  char *v13;
  int v14;
  int v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;

  v3 = *((_DWORD *)a2 + 11);
  if (v3 >= 255)
    kd_block::store_data();
  if (*((int *)a2 + 12) > 255)
    kd_block::store_data();
  if (*(_QWORD *)this)
    kd_block::store_data();
  *((_BYTE *)this + 17) = v3;
  result = kd_block::start_buffering(this, a3);
  v8 = *((_DWORD *)a2 + 12);
  *((_BYTE *)this + 18) = v8;
  if (v8 < 1)
  {
    if ((*((_DWORD *)a2 + 23) & 0x80000000) == 0)
      goto LABEL_22;
LABEL_27:
    kd_block::store_data();
  }
  v9 = 0;
  v10 = 0;
  do
  {
    v11 = *(_WORD *)(*((_QWORD *)a2 + 8) + 2 * v9);
    kd_block::put_byte(this, SHIBYTE(v11), a3);
    kd_block::put_byte(this, v11, a3);
    v12 = *(_DWORD *)(*((_QWORD *)a2 + 7) + 4 * v9);
    if (v12 >= 0x10000)
      kd_block::store_data();
    v10 += v12;
    kd_block::put_byte(this, SBYTE1(v12), a3);
    result = kd_block::put_byte(this, v12, a3);
    ++v9;
  }
  while (v9 < *((int *)a2 + 12));
  if (v10 > *((_DWORD *)a2 + 23))
    goto LABEL_27;
  if (v10 >= 1)
  {
    v13 = (char *)*((_QWORD *)a2 + 9);
    do
    {
      v14 = *((unsigned __int8 *)this + 16);
      if (v14 == 55)
      {
        result = kd_thread_buf_server::get(a3);
        **((_QWORD **)this + 1) = result;
        *((_QWORD *)this + 1) = result;
        *((_BYTE *)this + 16) = 0;
        v15 = 55;
      }
      else
      {
        v15 = 55 - v14;
      }
      if (v15 >= v10)
        v15 = v10;
      if (v15)
      {
        v16 = v15;
        do
        {
          v17 = *v13++;
          v18 = *((_QWORD *)this + 1);
          v19 = *((unsigned __int8 *)this + 16);
          *((_BYTE *)this + 16) = v19 + 1;
          *(_BYTE *)(v18 + v19 + 9) = v17;
          --v16;
        }
        while (v16);
      }
      v10 -= v15;
    }
    while (v10 >= 1);
  }
LABEL_22:
  *((_QWORD *)this + 1) = *(_QWORD *)this;
  *((_BYTE *)this + 16) = 0;
  return result;
}

uint64_t *kd_block::start_buffering(kd_block *this, kd_thread_buf_server *a2)
{
  uint64_t *result;

  if (*(_QWORD *)this)
    kd_block::start_buffering();
  result = kd_thread_buf_server::get(a2);
  *(_QWORD *)this = result;
  *((_QWORD *)this + 1) = result;
  *((_BYTE *)this + 16) = 0;
  return result;
}

uint64_t *kd_block::put_byte(kd_block *this, char a2, kd_thread_buf_server *a3)
{
  uint64_t *result;
  unsigned int v6;

  result = (uint64_t *)*((_QWORD *)this + 1);
  if (!result)
    kd_block::put_byte();
  v6 = *((unsigned __int8 *)this + 16);
  if (v6 == 55)
  {
    *((_BYTE *)this + 16) = 0;
    result = kd_thread_buf_server::get(a3);
    **((_QWORD **)this + 1) = result;
    *((_QWORD *)this + 1) = result;
    v6 = *((unsigned __int8 *)this + 16);
  }
  *((_BYTE *)this + 16) = v6 + 1;
  *((_BYTE *)result + v6 + 9) = a2;
  return result;
}

uint64_t *kd_thread_buf_server::get(kd_thread_buf_server *this)
{
  uint64_t *result;
  uint64_t v3;

  result = (uint64_t *)*((_QWORD *)this + 3);
  if (!result)
  {
    kd_thread_buf_server::augment_local_store(this, 0);
    result = (uint64_t *)*((_QWORD *)this + 3);
  }
  v3 = *result;
  *((_QWORD *)this + 3) = *result;
  if (!v3)
    *((_QWORD *)this + 4) = 0;
  *result = 0;
  --*((_DWORD *)this + 3);
  return result;
}

uint64_t kd_block::trim_data(kd_block *this, unsigned int a2, kd_buf_server *a3)
{
  kd_block *v5;
  unsigned int v6;
  int v7;
  int v8;
  unsigned int v9;
  char v10;
  int byte;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v17;
  kd_block *v18;
  int v19;
  char *v20;
  int v22;
  kd_block *v23;
  uint64_t v24;

  if (!*((_BYTE *)this + 18))
    return 0;
  v5 = this;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = *((_BYTE *)this + 16);
  v24 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = *(_QWORD *)this;
  *((_BYTE *)this + 16) = 0;
  while (1)
  {
    byte = kd_block::get_byte(v5);
    v12 = kd_block::get_byte(v5) | (byte << 8);
    if (v12 - 1 < a2)
      break;
    v13 = kd_block::get_byte(v5);
    v8 += kd_block::get_byte(v5) + (v13 << 8);
    v14 = v9 + 1;
    if (v12)
    {
      v7 = v8;
      v6 = v9 + 1;
    }
    v15 = *((unsigned __int8 *)v5 + 18);
    ++v9;
    if (v14 >= v15)
    {
      v9 = v14;
      goto LABEL_9;
    }
  }
  v15 = *((unsigned __int8 *)v5 + 18);
LABEL_9:
  *((_QWORD *)v5 + 1) = v24;
  *((_BYTE *)v5 + 16) = v10;
  if (v9 == v15)
    return 0;
  v17 = 4 * v6 + 55;
  v18 = v5;
  do
  {
    v18 = *(kd_block **)v18;
    v17 -= 55;
  }
  while (v17 > 55);
  if (4 * (v15 - v6))
  {
    v19 = 4 * v6 - 4 * v15;
    do
    {
      if (v17 == 55)
      {
        v17 = 0;
        v18 = *(kd_block **)v18;
      }
      v20 = (char *)v18 + v17++;
      v20[9] = 0;
    }
    while (!__CFADD__(v19++, 1));
    v15 = *((unsigned __int8 *)v5 + 18);
  }
  v22 = v7 + 4 * v15 + 55;
  do
  {
    v5 = *(kd_block **)v5;
    v22 -= 55;
  }
  while (v22 > 55);
  while (1)
  {
    v23 = *(kd_block **)v5;
    if (!*(_QWORD *)v5)
      break;
    *(_QWORD *)v5 = *(_QWORD *)v23;
    kd_buf_server::release((uint64_t)a3, (uint64_t)v23);
  }
  return 1;
}

uint64_t kd_block::get_byte(kd_block *this)
{
  unsigned int v1;
  uint64_t *v2;
  uint64_t v3;

  v1 = *((unsigned __int8 *)this + 16);
  if (v1 == 55)
  {
    *((_BYTE *)this + 16) = 0;
    v2 = (uint64_t *)*((_QWORD *)this + 1);
    v3 = *v2;
    *((_QWORD *)this + 1) = *v2;
    if (!v3)
      kd_block::get_byte();
    v1 = 0;
  }
  else
  {
    v3 = *((_QWORD *)this + 1);
  }
  *((_BYTE *)this + 16) = v1 + 1;
  return *(unsigned __int8 *)(v3 + v1 + 9);
}

uint64_t kd_block::start_packet(kd_block *this, int a2, unsigned int a3)
{
  __int16 v4;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  char v11;
  int v12;
  unsigned int v13;
  int byte;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t i;
  unsigned int v19;

  v4 = a2;
  if (a2)
  {
    LODWORD(v6) = *((unsigned __int8 *)this + 19);
    v7 = *((unsigned __int8 *)this + 18);
  }
  else
  {
    *((_BYTE *)this + 19) = 0;
    *((_QWORD *)this + 1) = *(_QWORD *)this;
    *((_BYTE *)this + 16) = 0;
    *((_WORD *)this + 10) = -1;
    v7 = *((unsigned __int8 *)this + 18);
    if (!*((_BYTE *)this + 18))
      *((_BYTE *)this + 17) = -1;
    v6 = *((_QWORD *)this + 4);
    if (v6)
    {
      while (1)
      {
        v17 = *((unsigned __int8 *)this + 17);
        if (*(unsigned __int8 *)(v6 + 17) <= v17)
          break;
        *(_BYTE *)(v6 + 17) = v17;
        v6 = *(_QWORD *)(v6 + 32);
        if (!v6)
          goto LABEL_3;
      }
      LODWORD(v6) = 0;
    }
  }
LABEL_3:
  *((_BYTE *)this + 22) = 0;
  *((_WORD *)this + 13) = 0;
  v8 = v7 - v6;
  if (v7 == (_DWORD)v6)
  {
    result = 0;
    *((_WORD *)this + 10) = -1;
  }
  else
  {
    v10 = *((_QWORD *)this + 1);
    v11 = *((_BYTE *)this + 16);
    if (v8 >= 1)
    {
      v12 = 0;
      v13 = 0;
      do
      {
        byte = kd_block::get_byte(this);
        v15 = kd_block::get_byte(this) | (byte << 8);
        if (v15 - 1 < a3)
          break;
        v16 = kd_block::get_byte(this);
        ++v12;
        v13 += kd_block::get_byte(this) + (v16 << 8);
        if (v15)
        {
          *((_BYTE *)this + 22) = v12;
          if (v13 >= 0x10000)
            kd_block::start_packet();
          *((_WORD *)this + 13) = v13;
        }
      }
      while (v8 != v12);
      LODWORD(v6) = *((unsigned __int8 *)this + 19);
    }
    *((_QWORD *)this + 1) = v10;
    *((_BYTE *)this + 16) = v11;
    if (!(_DWORD)v6)
    {
      if (*((_BYTE *)this + 22))
      {
        *((_WORD *)this + 10) = v4;
        for (i = *((_QWORD *)this + 4); i; i = *(_QWORD *)(i + 32))
        {
          v19 = *((unsigned __int16 *)this + 10);
          if (*(unsigned __int16 *)(i + 20) <= v19)
            break;
          *(_WORD *)(i + 20) = v19;
        }
      }
      else
      {
        *((_WORD *)this + 10) = -1;
      }
    }
    return *((unsigned __int16 *)this + 13);
  }
  return result;
}

unsigned __int8 *kd_block::write_packet_header(unsigned __int8 *this, kd_header_out *a2, __int16 a3, int a4)
{
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned int v12;
  unsigned __int8 *v13;
  unsigned __int16 v14;
  unsigned int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  unsigned __int8 v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int i;
  int v35;
  BOOL v36;
  unsigned int v37;
  unsigned int j;
  char v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  int v46;
  char v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  int byte;
  int v53;
  int v54;
  unsigned int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  unsigned int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  unsigned int v67;
  int v68;
  char v69;
  char v70;
  uint64_t v71;
  int v73;
  int v74;
  int v75;
  int v76;
  signed int v77;
  signed int v78;
  int v79;
  int v80;
  char v81;

  v5 = (uint64_t)this;
  v6 = this[22];
  if (this[19])
  {
    this = kd_header_out::put_bit((unsigned __int8 *)a2, v6 != 0);
    if (!v6)
      return this;
    goto LABEL_24;
  }
  v7 = *((unsigned __int16 *)this + 10);
  if (!this[22])
  {
    if (v7 == 0xFFFF)
      goto LABEL_6;
LABEL_11:
    kd_block::write_packet_header();
  }
  if (v7 == 0xFFFF)
    goto LABEL_11;
LABEL_6:
  *((_WORD *)this + 11) = a3;
  v8 = *((_QWORD *)this + 4);
  if (v8)
  {
    v9 = 0;
    v10 = this;
    do
    {
      v11 = v10;
      v10 = (unsigned __int8 *)v8;
      *((_QWORD *)v11 + 4) = v9;
      v8 = *(_QWORD *)(v8 + 32);
      v9 = v11;
    }
    while (v8);
  }
  else
  {
    v11 = 0;
    v10 = this;
  }
  LOWORD(v12) = 0;
  v13 = 0;
  *((_QWORD *)v10 + 4) = v11;
  v14 = *((_WORD *)this + 11) + 1;
  do
  {
    v15 = *((unsigned __int16 *)v10 + 11);
    if (v15 < (unsigned __int16)v12)
    {
      *((_WORD *)v10 + 11) = v12;
      LOWORD(v15) = v12;
    }
    v12 = *((unsigned __int16 *)v10 + 10);
    if (v12 >= (unsigned __int16)v15 && (unsigned __int16)v15 < v14)
    {
      do
      {
        *((_WORD *)v10 + 11) = v15 + 1;
        this = kd_header_out::put_bit((unsigned __int8 *)a2, (unsigned __int16)v12 <= (unsigned __int16)v15);
        v12 = *((unsigned __int16 *)v10 + 10);
        v15 = *((unsigned __int16 *)v10 + 11);
      }
      while (v12 >= v15 && v15 < v14);
    }
    if (v12 >= (unsigned __int16)v15)
      LOWORD(v12) = v15;
    v16 = (unsigned __int8 *)*((_QWORD *)v10 + 4);
    *((_QWORD *)v10 + 4) = v13;
    v13 = v10;
    v10 = v16;
  }
  while (v16);
  *(_BYTE *)(v5 + 22) = v6;
  if (v6)
  {
LABEL_24:
    if (!*(_BYTE *)(v5 + 19))
    {
      *(_BYTE *)(v5 + 24) = 0;
      do
      {
        v17 = *(_QWORD *)(v5 + 32);
        if (v17)
        {
          v18 = 0;
          v19 = v5;
          do
          {
            v20 = v19;
            v19 = v17;
            *(_QWORD *)(v20 + 32) = v18;
            v17 = *(_QWORD *)(v17 + 32);
            v18 = v20;
          }
          while (v17);
        }
        else
        {
          v20 = 0;
          v19 = v5;
        }
        LOBYTE(v21) = 0;
        v22 = 0;
        *(_QWORD *)(v19 + 32) = v20;
        v23 = *(_BYTE *)(v5 + 24) + 1;
        do
        {
          v24 = *(unsigned __int8 *)(v19 + 24);
          if (v24 < v21)
          {
            *(_BYTE *)(v19 + 24) = v21;
            LOBYTE(v24) = v21;
          }
          v21 = *(unsigned __int8 *)(v19 + 17);
          if (v21 >= v24 && v24 < v23)
          {
            do
            {
              *(_BYTE *)(v19 + 24) = v24 + 1;
              kd_header_out::put_bit((unsigned __int8 *)a2, v21 <= v24);
              v21 = *(unsigned __int8 *)(v19 + 17);
              v24 = *(unsigned __int8 *)(v19 + 24);
            }
            while (v21 >= v24 && v24 < v23);
          }
          if (v21 >= v24)
            LOBYTE(v21) = v24;
          v25 = *(_QWORD *)(v19 + 32);
          *(_QWORD *)(v19 + 32) = v22;
          v22 = v19;
          v19 = v25;
        }
        while (v25);
      }
      while (*(unsigned __int8 *)(v5 + 24) <= *(unsigned __int8 *)(v5 + 17));
      *(_BYTE *)(v5 + 24) = 3;
    }
    v26 = *(unsigned __int8 *)(v5 + 22) - 1;
    if (v26 >= 1)
      v27 = 1;
    else
      v27 = *(unsigned __int8 *)(v5 + 22) - 1;
    v28 = v26 - v27;
    kd_header_out::put_bit((unsigned __int8 *)a2, v27);
    if (v27)
    {
      v29 = v28 >= 1 ? 1 : v28;
      v30 = v28 - v29;
      kd_header_out::put_bit((unsigned __int8 *)a2, v29);
      if (v29)
      {
        v31 = 3;
        v32 = v30 >= 3 ? 3 : v30;
        do
          kd_header_out::put_bit((unsigned __int8 *)a2, (v32 >> (v31-- - 2)) & 1);
        while (v31 > 1);
        v28 = v30 - v32;
        if (v30 >= 3)
        {
          v33 = v28 >= 31 ? 31 : v28;
          for (i = 6; i > 1; --i)
            kd_header_out::put_bit((unsigned __int8 *)a2, (v33 >> (i - 2)) & 1);
          v35 = v28 - v33;
          v36 = v28 < 31;
          v28 = v35;
          if (!v36)
          {
            if (v35 >= 127)
              v37 = 127;
            else
              v37 = v35;
            for (j = 8; j > 1; --j)
              kd_header_out::put_bit((unsigned __int8 *)a2, (v37 >> (j - 2)) & 1);
            v28 = v35 - v37;
          }
        }
      }
    }
    if (v28)
      kd_block::write_packet_header();
    v39 = *(_BYTE *)(v5 + 25);
    v71 = *(_QWORD *)(v5 + 8);
    v70 = *(_BYTE *)(v5 + 16);
    v40 = *(unsigned __int8 *)(v5 + 22);
    v81 = v39;
    v41 = 0;
    if (*(_BYTE *)(v5 + 22))
    {
      v42 = *(unsigned __int8 *)(v5 + 19);
      v73 = v39 & 5;
      do
      {
        v79 = v41;
        v43 = 0;
        if ((v39 & 4) != 0)
          v44 = 1;
        else
          v44 = v40;
        if ((-1431655765 * (v42 - 10)) >= 0x55555556)
          v45 = 1;
        else
          v45 = 2;
        if (v42 <= 9)
          v45 = 10 - v42;
        if (v45 >= v40)
          v45 = v40;
        if (v73 == 1)
          v46 = v45;
        else
          v46 = v44;
        v47 = -2;
        do
        {
          v48 = v43;
          v49 = 1 << (v47 + 2);
          ++v47;
          ++v43;
        }
        while (v49 <= v46);
        v75 = *(unsigned __int8 *)(v5 + 24);
        v77 = v40;
        if (v46 < 1)
        {
          v50 = 0;
        }
        else
        {
          v50 = 0;
          v51 = v46 + 1;
          do
          {
            kd_block::get_byte((kd_block *)v5);
            kd_block::get_byte((kd_block *)v5);
            byte = kd_block::get_byte((kd_block *)v5);
            v50 += kd_block::get_byte((kd_block *)v5) + (byte << 8);
            --v51;
          }
          while (v51 > 1);
        }
        if (v50 >= 1 << (v75 + v47))
        {
          v53 = v75 + v48;
          do
          {
            kd_header_out::put_bit((unsigned __int8 *)a2, 1u);
            ++*(_BYTE *)(v5 + 24);
            v54 = 1 << v53++;
          }
          while (v50 >= v54);
        }
        v41 = v50 + v79;
        v42 += v46;
        v40 = v77 - v46;
        v39 = v81;
      }
      while (v77 > v46);
    }
    if (v41 != *(unsigned __int16 *)(v5 + 26))
      kd_block::write_packet_header();
    this = kd_header_out::put_bit((unsigned __int8 *)a2, 0);
    *(_QWORD *)(v5 + 8) = v71;
    *(_BYTE *)(v5 + 16) = v70;
    v55 = *(unsigned __int8 *)(v5 + 22);
    if (*(_BYTE *)(v5 + 22))
    {
      v56 = 0;
      v57 = *(unsigned __int8 *)(v5 + 19);
      v74 = v39 & 5;
      do
      {
        v58 = 0;
        if ((v39 & 4) != 0)
          v59 = 1;
        else
          v59 = v55;
        if ((-1431655765 * (v57 - 10)) >= 0x55555556)
          v60 = 1;
        else
          v60 = 2;
        if (v57 <= 9)
          v60 = 10 - v57;
        if (v60 >= v55)
          v60 = v55;
        if (v74 == 1)
          v61 = v60;
        else
          v61 = v59;
        v62 = -2;
        do
        {
          v63 = v58;
          v64 = 1 << (v62++ + 2);
          ++v58;
        }
        while (v64 <= v61);
        v65 = *(unsigned __int8 *)(v5 + 24);
        v78 = v55;
        v80 = v56;
        v76 = v57;
        v66 = 0;
        if (v61 >= 1)
        {
          v67 = v61 + 1;
          do
          {
            kd_block::get_byte((kd_block *)v5);
            kd_block::get_byte((kd_block *)v5);
            v68 = kd_block::get_byte((kd_block *)v5);
            this = (unsigned __int8 *)kd_block::get_byte((kd_block *)v5);
            v66 += (_DWORD)this + (v68 << 8);
            --v67;
          }
          while (v67 > 1);
        }
        if (v66 >= 1 << (v65 + v62))
          kd_block::write_packet_header();
        if (v65 + v62 >= 1)
        {
          do
            this = kd_header_out::put_bit((unsigned __int8 *)a2, (v66 >> (v65 + v63-- - 2)) & 1);
          while ((v65 + v63) > 1);
        }
        v56 = v66 + v80;
        v57 = v61 + v76;
        v55 = v78 - v61;
        v39 = v81;
      }
      while (v78 > v61);
    }
    else
    {
      v56 = 0;
    }
    if (v56 != *(unsigned __int16 *)(v5 + 26))
      kd_block::write_packet_header();
    if (a4)
    {
      *(_QWORD *)(v5 + 8) = v71;
      *(_BYTE *)(v5 + 16) = v70;
    }
    else
    {
      v69 = *(_BYTE *)(v5 + 19);
      if (!v69)
        *(_WORD *)(v5 + 20) = 4 * *(unsigned __int8 *)(v5 + 18);
      *(_BYTE *)(v5 + 19) = *(_BYTE *)(v5 + 22) + v69;
      *(_BYTE *)(v5 + 22) = 0;
    }
  }
  return this;
}

_DWORD *kd_block::write_body_bytes(_DWORD *this, kdu_output *a2)
{
  int v2;
  _DWORD *v4;
  unsigned __int16 v5;
  char *v6;
  int v7;
  int v8;
  int v9;

  v2 = *((unsigned __int16 *)this + 13);
  if (*((_WORD *)this + 13))
  {
    v4 = this;
    v5 = *((_WORD *)this + 10);
    v6 = *(char **)this;
    v7 = (unsigned __int16)(v5
                          - 55
                          * ((((unsigned __int16)(v5 - ((10725 * v5) >> 16)) >> 1)
                            + ((10725 * v5) >> 16)) >> 5));
    v8 = v5 + 55;
    while (1)
    {
      v8 -= 55;
      if (v8 < 55)
        break;
      v6 = *(char **)v6;
      if (!v6)
        kd_block::write_body_bytes();
    }
    *((_WORD *)this + 10) = v5 + v2;
    *((_WORD *)this + 13) = 0;
    do
    {
      if (!v6)
        kd_block::write_body_bytes();
      if (55 - v7 >= v2)
        v9 = v2;
      else
        v9 = 55 - v7;
      v2 -= v9;
      this = kdu_output::write(a2, &v6[v7 + 9], v9);
      v7 = 0;
      v6 = *(char **)v6;
    }
    while (v2 > 0);
    *((_BYTE *)v4 + 22) = 0;
  }
  return this;
}

_DWORD *kdu_output::write(_DWORD *this, char *a2, int a3)
{
  int v3;
  _DWORD *v5;
  int v6;
  int v7;
  char v8;
  _BYTE *v9;

  if (a3 >= 1)
  {
    v3 = a3;
    v5 = this;
    do
    {
      v6 = v5[132] - v5[130];
      if (!v6)
      {
        this = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)v5 + 16))(v5);
        v6 = v5[132] - v5[130];
      }
      if (v3 < v6)
        v6 = v3;
      if (v6)
      {
        v7 = v6;
        do
        {
          v8 = *a2++;
          v9 = (_BYTE *)*((_QWORD *)v5 + 65);
          *((_QWORD *)v5 + 65) = v9 + 1;
          *v9 = v8;
          --v7;
        }
        while (v7);
      }
      v3 -= v6;
    }
    while (v3 >= 1);
  }
  return this;
}

char *kd_block::build_tree(unint64_t a1, void **a2, uint64_t a3)
{
  int v3;
  unint64_t v4;
  signed int v5;
  int v6;
  int v7;
  unint64_t v8;
  char *v9;
  signed int v10;
  int v11;
  char *v12;
  unsigned int v13;
  char *v14;
  unsigned int v15;
  _DWORD *exception;

  v3 = a1;
  v4 = HIDWORD(a1);
  v5 = HIDWORD(a1) * a1;
  if (HIDWORD(a1) * (_DWORD)a1 < 0)
    kd_block::build_tree();
  v6 = 1;
  if (v5 >= 2)
  {
    v7 = a1;
    v8 = HIDWORD(a1);
    do
    {
      LODWORD(v8) = ((int)v8 + 1) >> 1;
      v7 = (v7 + 1) >> 1;
      v5 += v7 * v8;
      ++v6;
    }
    while (v7 * (int)v8 > 1);
  }
  if (!v5)
    return 0;
  v9 = (char *)*a2;
  *a2 = (char *)*a2 + 40 * v5;
  if (40 * v5 > a3)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v10 = v5;
  bzero(v9, 40 * v5);
  v11 = 0;
  v12 = v9;
  do
  {
    if (v3 >= 1)
    {
      v13 = 0;
      v14 = &v12[40 * v3 * (int)v4];
      do
      {
        if ((int)v4 >= 1)
        {
          v15 = 0;
          do
          {
            *((_QWORD *)v12 + 4) = &v14[40 * (v13 >> 1) * (((int)v4 + 1) >> 1) + 40 * (v15 >> 1)];
            if (v11 == v6 - 1)
            {
              if (v15 | v13)
                kd_block::build_tree();
              *((_QWORD *)v12 + 4) = 0;
            }
            ++v15;
            v12 += 40;
          }
          while ((_DWORD)v4 != v15);
        }
        ++v13;
      }
      while (v13 != v3);
    }
    v3 = (v3 + 1) >> 1;
    ++v11;
    LODWORD(v4) = ((int)v4 + 1) >> 1;
  }
  while (v11 != v6);
  if (v12 != &v9[40 * v10])
    kd_block::build_tree();
  return v9;
}

uint64_t kd_block::reset_output_tree(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  int v3;
  char v4;
  int v5;
  int v6;
  int v7;

  if ((_DWORD)a2)
  {
    v2 = HIDWORD(a2);
    if (HIDWORD(a2))
    {
      v3 = 0;
      v4 = 1;
      while ((v4 & 1) == 0)
      {
        if ((int)a2 >= 1)
        {
          v5 = 0;
          do
          {
            if ((int)v2 >= 1)
            {
              v6 = v2;
              do
              {
                *(_BYTE *)(result + 24) = 0;
                *(_BYTE *)(result + 17) = -1;
                *(_DWORD *)(result + 20) = 0xFFFF;
                result += 40;
                --v6;
              }
              while (v6);
            }
            ++v5;
          }
          while (v5 != (_DWORD)a2);
          v3 = v2 & ~((int)v2 >> 31);
          goto LABEL_13;
        }
        v7 = 0;
LABEL_14:
        v4 = 0;
        LODWORD(a2) = ((int)a2 + 1) >> 1;
        LODWORD(v2) = ((int)v2 + 1) >> 1;
        if (v3 <= 1 && v7 <= 1)
          return result;
      }
      result += 40 * (int)a2 * (int)v2;
      v3 = v2;
LABEL_13:
      v7 = a2;
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t kd_block::save_output_tree(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  int v3;
  char v4;
  int v5;
  int v6;
  int v7;
  int v8;
  _QWORD *v9;
  char v10;
  BOOL v11;
  unsigned int v12;

  if ((_DWORD)a2)
  {
    v2 = HIDWORD(a2);
    if (HIDWORD(a2))
    {
      v3 = 0;
      v4 = 1;
      do
      {
        if ((int)a2 < 1)
        {
          v12 = 0;
        }
        else
        {
          v5 = 0;
          v3 = v2 & ~((int)v2 >> 31);
          do
          {
            if ((int)v2 >= 1)
            {
              v6 = 0;
              do
              {
                if ((v4 & 1) != 0)
                {
                  v7 = *(unsigned __int8 *)(result + 22);
                  v8 = *(unsigned __int8 *)(result + 16) + 4 * v7;
                  if (v8 < 0x38)
                  {
                    v10 = *(_BYTE *)(result + 16) + 4 * v7;
                  }
                  else
                  {
                    v9 = *(_QWORD **)(result + 8);
                    do
                    {
                      v9 = (_QWORD *)*v9;
                      *(_QWORD *)(result + 8) = v9;
                      if (!v9)
                        kd_block::save_output_tree();
                      v10 = v8 - 55;
                      v11 = v8 <= 110;
                      v8 -= 55;
                    }
                    while (!v11);
                  }
                  *(_BYTE *)(result + 16) = v10;
                  *(_BYTE *)(result + 19) += v7;
                  *(_BYTE *)(result + 22) = 0;
                  *(_BYTE *)(result + 20) = *(_BYTE *)(result + 24);
                }
                else
                {
                  *(_WORD *)result = *(_WORD *)(result + 20);
                  *(_WORD *)(result + 8) = *(_WORD *)(result + 22);
                  *(_BYTE *)(result + 16) = *(_BYTE *)(result + 24);
                }
                ++v6;
                result += 40;
              }
              while (v6 != (_DWORD)v2);
            }
            ++v5;
          }
          while (v5 != (_DWORD)a2);
          v12 = a2;
        }
        v4 = 0;
        LODWORD(a2) = ((int)a2 + 1) >> 1;
        LODWORD(v2) = ((int)v2 + 1) >> 1;
      }
      while (v3 > 1 || v12 > 1);
    }
  }
  return result;
}

uint64_t kd_block::restore_output_tree(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  int v3;
  char v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;

  if ((_DWORD)a2)
  {
    v2 = HIDWORD(a2);
    if (HIDWORD(a2))
    {
      v3 = 0;
      v4 = 1;
      do
      {
        if ((v4 & 1) != 0)
        {
          if ((int)a2 >= 1)
          {
            v5 = 0;
            do
            {
              if ((int)v2 >= 1)
              {
                v6 = v2;
                do
                {
                  *(_BYTE *)(result + 24) = *(_BYTE *)(result + 20);
                  result += 40;
                  --v6;
                }
                while (v6);
              }
              ++v5;
            }
            while (v5 != (_DWORD)a2);
LABEL_18:
            v3 = v2 & ~((int)v2 >> 31);
            v9 = a2;
            goto LABEL_20;
          }
        }
        else if ((int)a2 >= 1)
        {
          v7 = 0;
          do
          {
            if ((int)v2 >= 1)
            {
              v8 = v2;
              do
              {
                *(_WORD *)(result + 20) = *(_WORD *)result;
                *(_WORD *)(result + 22) = *(_WORD *)(result + 8);
                *(_BYTE *)(result + 24) = *(_BYTE *)(result + 16);
                result += 40;
                --v8;
              }
              while (v8);
            }
            ++v7;
          }
          while (v7 != (_DWORD)a2);
          goto LABEL_18;
        }
        v9 = 0;
LABEL_20:
        v4 = 0;
        LODWORD(a2) = ((int)a2 + 1) >> 1;
        LODWORD(v2) = ((int)v2 + 1) >> 1;
      }
      while (v3 > 1 || v9 > 1);
    }
  }
  return result;
}

_QWORD *_cg_jinit_color_converter(uint64_t *a1)
{
  _QWORD *result;
  _QWORD *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t (*v19)(uint64_t, unsigned __int8 **, _QWORD *, unsigned int, int);
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  result = (_QWORD *)(*(uint64_t (**)(void))a1[1])();
  v3 = result;
  a1[67] = (uint64_t)result;
  *result = null_method;
  v4 = *((_DWORD *)a1 + 15);
  if (v4 > 7)
    goto LABEL_51;
  if (((1 << v4) & 0xCC) == 0)
  {
    if (((1 << v4) & 0x30) != 0)
    {
      if (*((_DWORD *)a1 + 14) == 4)
        goto LABEL_5;
      goto LABEL_4;
    }
    if (v4 == 1)
    {
      if (*((_DWORD *)a1 + 14) == 1)
        goto LABEL_5;
      goto LABEL_4;
    }
LABEL_51:
    if (*((int *)a1 + 14) > 0)
      goto LABEL_5;
    goto LABEL_4;
  }
  if (*((_DWORD *)a1 + 14) != 3)
  {
LABEL_4:
    v5 = *a1;
    *(_DWORD *)(v5 + 40) = 10;
    result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v5)(a1);
  }
LABEL_5:
  if (*((_DWORD *)a1 + 85) && (*((_DWORD *)a1 + 24) | 4) != 6)
  {
    v6 = *a1;
    *(_DWORD *)(v6 + 40) = 28;
    result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v6)(a1);
  }
  v7 = *((_DWORD *)a1 + 24);
  switch(v7)
  {
    case 1:
      if (*((_DWORD *)a1 + 23) != 1)
      {
        v12 = *a1;
        *(_DWORD *)(v12 + 40) = 11;
        result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v12)(a1);
      }
      switch(*((_DWORD *)a1 + 15))
      {
        case 1:
        case 3:
        case 7:
          v11 = grayscale_convert;
          goto LABEL_56;
        case 2:
          v19 = rgb_gray_convert;
          goto LABEL_58;
        default:
          goto LABEL_50;
      }
    case 2:
    case 6:
      if (*((_DWORD *)a1 + 23) != 3)
      {
        v8 = *a1;
        *(_DWORD *)(v8 + 40) = 11;
        result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v8)(a1);
        v7 = *((_DWORD *)a1 + 24);
      }
      if (*((_DWORD *)a1 + 15) != v7)
      {
        v9 = *a1;
        *(_DWORD *)(v9 + 40) = 28;
        result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v9)(a1);
      }
      v10 = *((_DWORD *)a1 + 85);
      if (v10 == 1)
      {
        v11 = rgb_rgb1_convert;
      }
      else
      {
        if (v10)
          goto LABEL_50;
        v11 = rgb_convert;
      }
      goto LABEL_56;
    case 3:
      if (*((_DWORD *)a1 + 23) != 3)
      {
        v13 = *a1;
        *(_DWORD *)(v13 + 40) = 11;
        result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v13)(a1);
      }
      v14 = *((_DWORD *)a1 + 15);
      if (v14 == 3)
        goto LABEL_55;
      if (v14 != 2)
        goto LABEL_50;
      goto LABEL_49;
    case 4:
      if (*((_DWORD *)a1 + 23) != 4)
      {
        v15 = *a1;
        *(_DWORD *)(v15 + 40) = 11;
        result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v15)(a1);
      }
      if (*((_DWORD *)a1 + 15) != 4)
        goto LABEL_37;
      goto LABEL_55;
    case 5:
      if (*((_DWORD *)a1 + 23) != 4)
      {
        v17 = *a1;
        *(_DWORD *)(v17 + 40) = 11;
        result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v17)(a1);
      }
      v18 = *((_DWORD *)a1 + 15);
      if (v18 == 5)
        goto LABEL_55;
      if (v18 != 4)
        goto LABEL_50;
      v19 = cmyk_ycck_convert;
      goto LABEL_58;
    case 7:
      if (*((_DWORD *)a1 + 23) != 3)
      {
        v20 = *a1;
        *(_DWORD *)(v20 + 40) = 11;
        result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v20)(a1);
      }
      v21 = *((_DWORD *)a1 + 15);
      switch(v21)
      {
        case 7:
          goto LABEL_55;
        case 3:
          v24 = a1[13];
          *(_DWORD *)(v24 + 148) = 1;
          *(_DWORD *)(v24 + 244) = 1;
LABEL_55:
          v11 = null_convert;
LABEL_56:
          v3[1] = v11;
          break;
        case 2:
          v22 = a1[13];
          *(_DWORD *)(v22 + 148) = 1;
          *(_DWORD *)(v22 + 244) = 1;
LABEL_49:
          v19 = rgb_ycc_convert;
LABEL_58:
          *v3 = rgb_ycc_start;
          v3[1] = v19;
          break;
        default:
LABEL_50:
          v23 = *a1;
          *(_DWORD *)(v23 + 40) = 28;
          return (_QWORD *)(*(uint64_t (**)(uint64_t *))v23)(a1);
      }
      return result;
    default:
      if (v7 == *((_DWORD *)a1 + 15) && *((_DWORD *)a1 + 23) == *((_DWORD *)a1 + 14))
        goto LABEL_55;
LABEL_37:
      v16 = *a1;
      *(_DWORD *)(v16 + 40) = 28;
      result = (_QWORD *)(*(uint64_t (**)(uint64_t *))v16)(a1);
      goto LABEL_55;
  }
}

uint64_t grayscale_convert(uint64_t result, _BYTE **a2, _QWORD *a3, unsigned int a4, int a5)
{
  int v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  int v9;

  if (a5 >= 1)
  {
    v5 = *(_DWORD *)(result + 48);
    v6 = *(int *)(result + 56);
    do
    {
      if (v5)
      {
        v7 = *(_BYTE **)(*a3 + 8 * a4);
        v8 = *a2;
        v9 = v5;
        do
        {
          *v7++ = *v8;
          v8 += v6;
          --v9;
        }
        while (v9);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

_QWORD *rgb_ycc_start(uint64_t a1)
{
  uint64_t v1;
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v1 = *(_QWORD *)(a1 + 536);
  result = (_QWORD *)(**(uint64_t (***)(void))(a1 + 8))();
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  *(_QWORD *)(v1 + 16) = result;
  v10 = 0x8000;
  do
  {
    *result = v8;
    result[256] = v5;
    result[512] = v10;
    v11 = v9 + 8421375;
    v9 += 0x8000;
    result[1792] = v7;
    v8 += 19595;
    v7 -= 5329;
    result[768] = v3;
    result[1024] = v4;
    result[1280] = v11;
    result[1536] = v6;
    ++result;
    v6 -= 27439;
    v5 += 38470;
    v10 += 7471;
    v4 -= 21710;
    v3 -= 11058;
  }
  while (v9 != 0x800000);
  return result;
}

uint64_t rgb_gray_convert(uint64_t result, unsigned __int8 **a2, _QWORD *a3, unsigned int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  unsigned __int8 *v8;
  uint64_t v9;

  if (a5 >= 1)
  {
    v5 = *(_QWORD *)(*(_QWORD *)(result + 536) + 16);
    v6 = *(unsigned int *)(result + 48);
    do
    {
      if ((_DWORD)v6)
      {
        v7 = *(_BYTE **)(*a3 + 8 * a4);
        v8 = *a2;
        v9 = v6;
        do
        {
          *v7++ = (*(_DWORD *)(v5 + 8 * v8[1] + 2048)
                 + *(_QWORD *)(v5 + 8 * *v8)
                 + *(_DWORD *)(v5 + 8 * v8[2] + 4096)) >> 16;
          v8 += 3;
          --v9;
        }
        while (v9);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb_convert(uint64_t result, _BYTE **a2, _QWORD *a3, unsigned int a4, int a5)
{
  uint64_t v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;

  if (a5 >= 1)
  {
    v5 = *(unsigned int *)(result + 48);
    do
    {
      if ((_DWORD)v5)
      {
        v6 = *(_BYTE **)(*a3 + 8 * a4);
        v7 = *(_BYTE **)(a3[1] + 8 * a4);
        v8 = *(_BYTE **)(a3[2] + 8 * a4);
        v9 = *a2;
        v10 = v5;
        do
        {
          *v6++ = *v9;
          *v7++ = v9[1];
          *v8++ = v9[2];
          v9 += 3;
          --v10;
        }
        while (v10);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb_rgb1_convert(uint64_t result, _BYTE **a2, _QWORD *a3, unsigned int a4, int a5)
{
  uint64_t v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  char v12;

  if (a5 >= 1)
  {
    v5 = *(unsigned int *)(result + 48);
    do
    {
      if ((_DWORD)v5)
      {
        v6 = *(_BYTE **)(*a3 + 8 * a4);
        v7 = *(_BYTE **)(a3[1] + 8 * a4);
        v8 = *(_BYTE **)(a3[2] + 8 * a4);
        v9 = *a2;
        v10 = v5;
        do
        {
          v11 = v9[1];
          v12 = v9[2];
          *v6++ = (*v9 - v11) ^ 0x80;
          *v7++ = v11;
          *v8++ = (v12 - v11) ^ 0x80;
          v9 += 3;
          --v10;
        }
        while (v10);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb_ycc_convert(uint64_t result, unsigned __int8 **a2, _QWORD *a3, unsigned int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  _DWORD *v14;
  int v15;

  if (a5 >= 1)
  {
    v5 = *(_QWORD *)(*(_QWORD *)(result + 536) + 16);
    v6 = *(unsigned int *)(result + 48);
    do
    {
      if ((_DWORD)v6)
      {
        v7 = *(_BYTE **)(*a3 + 8 * a4);
        v8 = *(_BYTE **)(a3[1] + 8 * a4);
        v9 = *(_BYTE **)(a3[2] + 8 * a4);
        v10 = *a2;
        v11 = v6;
        do
        {
          v12 = v5 + 8 * *v10;
          v13 = (_DWORD *)(v5 + 8 * v10[1]);
          v14 = (_DWORD *)(v5 + 8 * v10[2]);
          *v7++ = (v13[512] + *(_QWORD *)v12 + v14[1024]) >> 16;
          v15 = v14[2560];
          result = (v13[2048] + *(_DWORD *)(v12 + 6144) + v15) >> 16;
          *v8++ = (v13[2048] + *(_DWORD *)(v12 + 6144) + v15) >> 16;
          *v9++ = (v13[3072] + *(_DWORD *)(v12 + 10240) + v14[3584]) >> 16;
          v10 += 3;
          --v11;
        }
        while (v11);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t null_convert(uint64_t result, uint64_t *a2, uint64_t a3, unsigned int a4, int a5)
{
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  int v11;

  if (a5 >= 1)
  {
    v5 = *(_DWORD *)(result + 48);
    v6 = *(unsigned int *)(result + 92);
    v7 = *(_DWORD *)(result + 92);
    do
    {
      if (v7 >= 1)
      {
        v8 = 0;
        do
        {
          if (v5)
          {
            v9 = *(_BYTE **)(*(_QWORD *)(a3 + 8 * v8) + 8 * a4);
            v10 = *a2;
            v11 = v5;
            do
            {
              *v9++ = *(_BYTE *)(v10 + v8);
              v10 += (int)v6;
              --v11;
            }
            while (v11);
          }
          ++v8;
        }
        while (v8 != v6);
      }
      ++a2;
      ++a4;
    }
    while (a5-- > 1);
  }
  return result;
}

uint64_t cmyk_ycck_convert(uint64_t result, _BYTE **a2, _QWORD *a3, unsigned int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  _BYTE *v12;
  unsigned __int8 v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;

  if (a5 >= 1)
  {
    v5 = *(_QWORD *)(*(_QWORD *)(result + 536) + 16);
    v6 = *(unsigned int *)(result + 48);
    do
    {
      if ((_DWORD)v6)
      {
        v7 = *(_BYTE **)(*a3 + 8 * a4);
        v8 = *(_BYTE **)(a3[1] + 8 * a4);
        v9 = *(_BYTE **)(a3[2] + 8 * a4);
        v10 = *(_BYTE **)(a3[3] + 8 * a4);
        v11 = v6;
        v12 = *a2;
        do
        {
          v13 = ~*v12;
          v14 = v12[1] ^ 0xFF;
          v15 = v12[2] ^ 0xFF;
          *v10++ = v12[3];
          *v7++ = (*(_QWORD *)(v5 + 8 * (v14 | 0x100u))
                 + *(_QWORD *)(v5 + 8 * v13)
                 + *(_QWORD *)(v5 + 8 * (v15 | 0x200u))) >> 16;
          *v8++ = (*(_QWORD *)(v5 + 8 * (v14 | 0x400u))
                 + *(_QWORD *)(v5 + 8 * (v13 | 0x300u))
                 + *(_QWORD *)(v5 + 8 * (v15 | 0x500u))) >> 16;
          v16 = v13 | 0x500;
          v17 = v14 | 0x600;
          result = *(_QWORD *)(v5 + 8 * v16);
          *v9++ = (*(_QWORD *)(v5 + 8 * v17)
                 + (_DWORD)result
                 + *(_QWORD *)(v5 + 8 * (v15 | 0x700u))) >> 16;
          v12 += 4;
          --v11;
        }
        while (v11);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

_QWORD *_cg_jinit_c_prep_controller(uint64_t *a1, int a2)
{
  uint64_t v3;
  _QWORD *result;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a2)
  {
    v3 = *a1;
    *(_DWORD *)(v3 + 40) = 3;
    (*(void (**)(uint64_t *))v3)(a1);
  }
  result = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 112);
  v5 = result;
  a1[64] = (uint64_t)result;
  *result = start_pass_prep;
  if (*(_DWORD *)(a1[68] + 16))
  {
    result[1] = pre_process_context;
    v16 = *((int *)a1 + 89);
    result = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 8 * *((_DWORD *)a1 + 23) * 5 * (int)v16);
    if (*((int *)a1 + 23) >= 1)
    {
      v6 = result;
      v7 = 0;
      v8 = a1[13];
      v15 = (3 * v16);
      v14 = 40 * (_DWORD)v16;
      v9 = &result[4 * (int)v16];
      do
      {
        v10 = (char *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1, 1, (uint64_t)(*((int *)a1 + 90) * (unint64_t)*(unsigned int *)(v8 + 28) * *((int *)a1 + 88))/ *(int *)(v8 + 8), v15);
        result = memcpy(&v6[v16], v10, 8 * (int)v15);
        if ((int)v16 >= 1)
        {
          v11 = 0;
          do
          {
            v6[v11] = *(_QWORD *)&v10[16 * v16 + v11 * 8];
            v9[v11] = *(_QWORD *)&v10[v11 * 8];
            ++v11;
          }
          while (v16 != v11);
        }
        v5[v7 + 2] = &v6[v16];
        v6 = (_QWORD *)((char *)v6 + v14);
        ++v7;
        v8 += 96;
        v9 = (_QWORD *)((char *)v9 + v14);
      }
      while (v7 < *((int *)a1 + 23));
    }
  }
  else
  {
    result[1] = pre_process_data;
    if (*((int *)a1 + 23) >= 1)
    {
      v12 = 0;
      v13 = (unsigned int *)(a1[13] + 28);
      do
      {
        result = (_QWORD *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _QWORD))(a1[1] + 16))(a1, 1, (uint64_t)(*((int *)a1 + 90) * (unint64_t)*v13 * *((int *)a1 + 88)) / (int)*(v13 - 5), *((unsigned int *)a1 + 89));
        v5[v12++ + 2] = result;
        v13 += 24;
      }
      while (v12 < *((int *)a1 + 23));
    }
  }
  return result;
}

_QWORD *start_pass_prep(_QWORD *result, int a2)
{
  _QWORD *v2;
  _DWORD *v3;
  uint64_t v4;
  int v5;

  v2 = result;
  v3 = (_DWORD *)result[64];
  if (a2)
  {
    v4 = *result;
    *(_DWORD *)(v4 + 40) = 3;
    result = (_QWORD *)(*(uint64_t (**)(_QWORD *))v4)(result);
  }
  v5 = *((_DWORD *)v2 + 13);
  v3[25] = 0;
  v3[26] = 0;
  v3[24] = v5;
  v3[27] = 2 * *((_DWORD *)v2 + 89);
  return result;
}

char *pre_process_context(char *result, uint64_t a2, _DWORD *a3, unsigned int a4, uint64_t a5, unsigned int *a6, unsigned int a7)
{
  unsigned int v7;
  unsigned int v9;
  char *v11;
  _DWORD *v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t i;
  int v24;
  int v25;
  char *v26;
  size_t v27;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  int v35;
  _DWORD *v38;

  if (*a6 < a7)
  {
    v7 = a7;
    v9 = a4;
    v11 = result;
    v12 = (_DWORD *)*((_QWORD *)result + 64);
    v35 = 3 * *((_DWORD *)result + 89);
    v38 = v12 + 4;
    do
    {
      v13 = *a3;
      if (v9 <= v13)
      {
        if (v12[24])
          return result;
        v20 = v12[25];
        v21 = v12[27];
        if (v20 < v21)
        {
          v22 = *((_DWORD *)v11 + 23);
          if (v22 >= 1)
          {
            for (i = 0; i < v22; ++i)
            {
              v24 = v12[25];
              v25 = v12[27];
              if (v24 < v25)
              {
                v26 = *(char **)&v12[2 * i + 4];
                v27 = *((unsigned int *)v11 + 12);
                v28 = v24 - 1;
                do
                  _cg_jcopy_sample_rows(v26, v28, (uint64_t)v26, v24++, 1, v27);
                while (v25 != v24);
                v22 = *((_DWORD *)v11 + 23);
              }
            }
            v21 = v12[27];
            v7 = a7;
            v9 = a4;
          }
          v12[25] = v21;
          v29 = *a6;
LABEL_28:
          result = (char *)(*(uint64_t (**)(char *, _DWORD *, _QWORD, uint64_t, uint64_t))(*((_QWORD *)v11 + 68)
                                                                                                 + 8))(v11, v38, v12[26], a5, v29);
          ++*a6;
          v30 = *((_DWORD *)v11 + 89);
          v31 = v12[25];
          v32 = v12[26] + v30;
          if (v32 >= v35)
            v32 = 0;
          v12[26] = v32;
          if (v31 >= v35)
          {
            v31 = 0;
            v12[25] = 0;
          }
          v12[27] = v31 + v30;
          LODWORD(v29) = *a6;
          continue;
        }
      }
      else
      {
        if (v12[27] - v12[25] >= v9 - v13)
          v14 = v9 - v13;
        else
          v14 = v12[27] - v12[25];
        result = (char *)(*(uint64_t (**)(char *, uint64_t, _DWORD *))(*((_QWORD *)v11 + 67) + 8))(v11, a2 + 8 * v13, v38);
        if (v12[24] == *((_DWORD *)v11 + 13))
        {
          v15 = *((_DWORD *)v11 + 23);
          if (v15 >= 1)
          {
            v16 = 0;
            v17 = *((_DWORD *)v11 + 89);
            do
            {
              if (v17 >= 1)
              {
                v18 = 0;
                v19 = -1;
                do
                {
                  result = _cg_jcopy_sample_rows(*(char **)&v12[2 * v16 + 4], 0, *(_QWORD *)&v12[2 * v16 + 4], v19, 1, *((unsigned int *)v11 + 12));
                  v17 = *((_DWORD *)v11 + 89);
                  ++v18;
                  --v19;
                }
                while (v18 < v17);
                v15 = *((_DWORD *)v11 + 23);
              }
              ++v16;
            }
            while (v16 < v15);
          }
        }
        *a3 += v14;
        v20 = v12[25] + v14;
        v12[24] -= v14;
        v12[25] = v20;
        v21 = v12[27];
        v9 = a4;
      }
      v29 = *a6;
      if (v20 == v21)
        goto LABEL_28;
    }
    while (v29 < v7);
  }
  return result;
}

char *pre_process_data(char *result, uint64_t a2, unsigned int *a3, unsigned int a4, uint64_t a5, unsigned int *a6, unsigned int a7)
{
  unsigned int v7;
  unsigned int v8;
  uint64_t v10;
  unsigned int v11;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  int v16;
  int v17;
  BOOL v18;
  int v19;
  int v21;
  uint64_t i;
  int v23;
  int v24;
  char *v25;
  size_t v26;
  int v27;
  int v28;
  uint64_t v29;
  _DWORD *v30;
  int v31;
  int v32;
  char *v33;
  size_t v34;
  int v35;
  int v36;
  uint64_t v41;

  v7 = *a3;
  if (*a3 < a4)
  {
    v8 = a7;
    v10 = a5;
    v11 = a4;
    v13 = a2;
    v14 = result;
    v15 = *((_QWORD *)result + 64);
    v41 = v15 + 16;
    do
    {
      if (*a6 >= v8)
        return result;
      if (*((_DWORD *)v14 + 89) - *(_DWORD *)(v15 + 100) >= v11 - v7)
        v16 = v11 - v7;
      else
        v16 = *((_DWORD *)v14 + 89) - *(_DWORD *)(v15 + 100);
      result = (char *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*((_QWORD *)v14 + 67) + 8))(v14, v13 + 8 * v7, v41);
      *a3 += v16;
      v17 = *(_DWORD *)(v15 + 100) + v16;
      v18 = *(_DWORD *)(v15 + 96) == v16;
      *(_DWORD *)(v15 + 96) -= v16;
      *(_DWORD *)(v15 + 100) = v17;
      v19 = *((_DWORD *)v14 + 89);
      if (v18 && v17 < v19)
      {
        v21 = *((_DWORD *)v14 + 23);
        if (v21 >= 1)
        {
          for (i = 0; i < v21; ++i)
          {
            v23 = *(_DWORD *)(v15 + 100);
            v24 = *((_DWORD *)v14 + 89);
            if (v23 < v24)
            {
              v25 = *(char **)(v15 + 8 * i + 16);
              v26 = *((unsigned int *)v14 + 12);
              v27 = v23 - 1;
              do
                _cg_jcopy_sample_rows(v25, v27, (uint64_t)v25, v23++, 1, v26);
              while (v24 != v23);
              v21 = *((_DWORD *)v14 + 23);
            }
          }
          v19 = *((_DWORD *)v14 + 89);
          v8 = a7;
          v10 = a5;
          v11 = a4;
          v13 = a2;
        }
        *(_DWORD *)(v15 + 100) = v19;
      }
      else if (v17 != v19)
      {
        goto LABEL_23;
      }
      result = (char *)(*(uint64_t (**)(char *, uint64_t, _QWORD, uint64_t, _QWORD))(*((_QWORD *)v14 + 68) + 8))(v14, v41, 0, v10, *a6);
      *(_DWORD *)(v15 + 100) = 0;
      ++*a6;
LABEL_23:
      if (!*(_DWORD *)(v15 + 96) && *a6 < v8)
      {
        v28 = *((_DWORD *)v14 + 23);
        if (v28 >= 1)
        {
          v29 = 0;
          v30 = (_DWORD *)*((_QWORD *)v14 + 13);
          do
          {
            v31 = v30[10] * v30[3] / *((_DWORD *)v14 + 91);
            v32 = *a6 * v31;
            if (v32 < (int)(v31 * v8))
            {
              v33 = *(char **)(v10 + 8 * v29);
              v34 = (v30[9] * v30[7]);
              v35 = v32 - 1;
              v36 = v31 * (v8 - *a6);
              do
              {
                result = _cg_jcopy_sample_rows(v33, v35, (uint64_t)v33, v32++, 1, v34);
                --v36;
              }
              while (v36);
              v28 = *((_DWORD *)v14 + 23);
              v8 = a7;
              v10 = a5;
            }
            ++v29;
            v30 += 24;
          }
          while (v29 < v28);
        }
        *a6 = v8;
        return result;
      }
      v7 = *a3;
    }
    while (*a3 < v11);
  }
  return result;
}

uint64_t _cg_jpeg_idct_islow(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, unsigned int a5)
{
  uint64_t v5;
  __int16 *v6;
  uint64_t v7;
  unsigned int v8;
  _DWORD *v9;
  unsigned __int16 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  unint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t result;
  int *v45;
  _BYTE *v46;
  int v47;
  unint64_t v48;
  uint64_t v49;
  BOOL v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  unint64_t v71;
  int v72;
  int v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  _OWORD v78[16];
  uint64_t v79;

  v5 = 0;
  v79 = *MEMORY[0x1E0C80C00];
  v76 = *(_QWORD *)(a1 + 440);
  v6 = (__int16 *)(a3 + 64);
  v7 = *(_QWORD *)(a2 + 88) + 128;
  v8 = 9;
  memset(v78, 0, sizeof(v78));
  do
  {
    v9 = (_DWORD *)(v7 + v5);
    v10 = *(v6 - 16);
    if ((unsigned __int16)*(v6 - 24) | v10)
      goto LABEL_9;
    if (*(v6 - 8) || *v6 || v6[8] || v6[16] || v6[24])
    {
      v10 = 0;
LABEL_9:
      v11 = *v9 * *v6;
      v12 = ((uint64_t)(*(v9 - 32) * *(v6 - 32)) << 13) | 0x400;
      v13 = v12 + (v11 << 13);
      v14 = v12 - (v11 << 13);
      v15 = (int)*(v9 - 16) * (uint64_t)(__int16)v10;
      v16 = (int)v9[16] * (uint64_t)v6[16];
      v17 = 4433 * (v15 + v16);
      v18 = v17 + 6270 * v15;
      v19 = v17 - 15137 * v16;
      v20 = v18 + v13;
      v21 = v13 - v18;
      v22 = v19 + v14;
      v23 = v14 - v19;
      v24 = (int)v9[24] * (uint64_t)v6[24];
      v25 = (int)v9[8] * (uint64_t)v6[8];
      v26 = *(v9 - 8);
      v27 = (int)*(v9 - 24) * (uint64_t)*(v6 - 24);
      v28 = v24 + v26 * (uint64_t)*(v6 - 8);
      v29 = 9633 * (v25 + v27 + v28);
      v30 = v29 - 16069 * v28;
      v31 = v29 - 3196 * (v25 + v27);
      v32 = -7373 * (v24 + v27);
      v33 = v32 + 2446 * v24 + v30;
      v34 = v32 + 12299 * v27 + v31;
      v35 = -20995 * (v25 + v26 * (uint64_t)*(v6 - 8));
      v36 = v35 + 16819 * v25 + v31;
      v37 = v35 + 25172 * v26 * (uint64_t)*(v6 - 8) + v30;
      v38 = (_DWORD *)((char *)v78 + v5);
      *v38 = (unint64_t)(v34 + v20) >> 11;
      v38[56] = (unint64_t)(v20 - v34) >> 11;
      v38[8] = (unint64_t)(v37 + v22) >> 11;
      v38[48] = (unint64_t)(v22 - v37) >> 11;
      v38[16] = (unint64_t)(v36 + v23) >> 11;
      v38[40] = (unint64_t)(v23 - v36) >> 11;
      v38[24] = (unint64_t)(v33 + v21) >> 11;
      v39 = (unint64_t)(v21 - v33) >> 11;
      v40 = 8;
      goto LABEL_10;
    }
    LODWORD(v39) = 4 * *(v6 - 32) * *(v9 - 32);
    v41 = (_DWORD *)((char *)v78 + v5);
    *v41 = v39;
    v41[8] = v39;
    v41[16] = v39;
    v41[24] = v39;
    v41[32] = v39;
    v41[40] = v39;
    v41[48] = v39;
    v40 = 14;
LABEL_10:
    *(_DWORD *)((char *)&v78[v40] + v5) = v39;
    --v8;
    v5 += 4;
    ++v6;
  }
  while (v8 > 1);
  v42 = v76 - 384;
  v43 = 28;
  result = 4294959923;
  do
  {
    v45 = (int *)((char *)v78 + v43);
    v46 = (_BYTE *)(*a4 + a5);
    v47 = *(_DWORD *)((char *)&v78[-1] + v43 - 8);
    v48 = *(int *)((char *)&v78[-1] + v43 - 12) + 16400;
    v49 = *(unsigned int *)((char *)&v78[-1] + v43 - 4);
    if (v47)
      v50 = 0;
    else
      v50 = v49 == 0;
    if (!v50)
      goto LABEL_24;
    if (*(v45 - 4)
      || *(_DWORD *)((char *)v78 + v43 - 12)
      || *(_DWORD *)((char *)v78 + v43 - 8)
      || *(_DWORD *)((char *)v78 + v43 - 4)
      || *(_DWORD *)((char *)v78 + v43))
    {
      LODWORD(v49) = 0;
LABEL_24:
      v52 = *(v45 - 4);
      v51 = *(v45 - 3);
      v53 = v48 + v51;
      v54 = ((_DWORD)v48 + v51) << 13;
      v55 = ((_DWORD)v48 - v51) << 13;
      v57 = *(v45 - 2);
      v56 = *(v45 - 1);
      v58 = 4433 * (v56 + v49);
      v59 = v58 + 6270 * v49;
      v60 = v58 - 15137 * v56;
      v61 = v59 + (v53 << 13);
      v62 = v54 - v59;
      v63 = v60 + v55;
      v64 = v55 - v60;
      v65 = *v45;
      v66 = 9633 * (v52 + v65 + v57 + v47);
      v67 = v66 - 16069 * (v52 + v65);
      v68 = v66 - 3196 * (v57 + v47);
      v69 = -7373 * (v65 + v47);
      v70 = v69 + 12299 * v47 + v68;
      *v46 = *(_BYTE *)(v42 + (((unint64_t)(v70 + v61) >> 18) & 0x3FF));
      v71 = (v61 - v70);
      v72 = -20995 * (v52 + v57);
      v73 = v72 + 25172 * v52 + v67;
      v46[7] = *(_BYTE *)(v42 + ((v71 >> 18) & 0x3FF));
      v46[1] = *(_BYTE *)(v42 + (((unint64_t)(v73 + v63) >> 18) & 0x3FF));
      v74 = v72 + 16819 * v57 + v68;
      v46[6] = *(_BYTE *)(v42 + (((unint64_t)(v63 - v73) >> 18) & 0x3FF));
      v46[2] = *(_BYTE *)(v42 + (((unint64_t)(v74 + v64) >> 18) & 0x3FF));
      LODWORD(v71) = v69 + 2446 * v65 + v67;
      v46[5] = *(_BYTE *)(v42 + (((unint64_t)(v64 - v74) >> 18) & 0x3FF));
      v46[3] = *(_BYTE *)(v42 + (((unint64_t)(v71 + v62) >> 18) & 0x3FF));
      LOBYTE(v74) = *(_BYTE *)(v42 + (((unint64_t)(v62 - v71) >> 18) & 0x3FF));
      v75 = 4;
      goto LABEL_25;
    }
    v74 = *(unsigned __int8 *)(v42 + ((v48 >> 5) & 0x3FF));
    *(_DWORD *)v46 = vdup_n_s8(v74).u32[0];
    v46[4] = v74;
    v46[5] = v74;
    v46[6] = v74;
    v75 = 7;
LABEL_25:
    v46[v75] = v74;
    ++a4;
    v43 += 32;
  }
  while (v43 != 284);
  return result;
}

uint64_t jpeg_idct_7x7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t result;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  _BYTE *v57;
  int v58;
  int v59;
  int v60;
  uint64_t v61;
  _OWORD v63[12];
  int v64;
  uint64_t v65;

  v5 = 0;
  v65 = *MEMORY[0x1E0C80C00];
  v61 = *(_QWORD *)(a1 + 440);
  v64 = 0;
  memset(v63, 0, sizeof(v63));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)v63 + v5;
    v8 = (_DWORD *)(v6 + 4 * v5);
    v9 = (__int16 *)(a3 + 2 * v5);
    v10 = ((uint64_t)(*v8 * *v9) << 13) | 0x400;
    v11 = (int)v8[16] * (uint64_t)v9[16];
    v12 = (int)v8[32] * (uint64_t)v9[32];
    v13 = (int)v8[48] * (uint64_t)v9[48];
    v14 = 7223 * (v12 - v13);
    v15 = 2578 * (v11 - v12);
    v16 = v10 - 15083 * v12 + v15 + v14;
    v17 = v10 + 10438 * (v11 + v13);
    v18 = v14 - 637 * v13 + v17;
    v19 = v15 - 20239 * v11 + v17;
    v20 = v10 + 11585 * (v12 - (v11 + v13));
    v21 = (int)v8[8] * (uint64_t)v9[8];
    v22 = (int)v8[24] * (uint64_t)v9[24];
    v23 = (int)v8[40] * (uint64_t)v9[40];
    v24 = 7663 * (v21 + v22);
    v25 = 1395 * (v21 - v22);
    v26 = v24 - v25;
    v27 = v24 + v25 - 11295 * (v22 + v23);
    v28 = 5027 * (v21 + v23);
    v29 = v28 + v26;
    v30 = v28 + 15326 * v23 - 11295 * (v22 + v23);
    *v7 = (unint64_t)(v29 + v18) >> 11;
    v7[42] = (unint64_t)(v18 - v29) >> 11;
    v7[7] = (unint64_t)(v27 + v16) >> 11;
    v7[35] = (unint64_t)(v16 - v27) >> 11;
    v7[14] = (unint64_t)(v30 + v19) >> 11;
    v7[28] = (unint64_t)(v19 - v30) >> 11;
    v7[21] = v20 >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 7);
  v31 = 0;
  v32 = v61 - 384;
  result = 11585;
  do
  {
    v34 = *a4++;
    v35 = *(_DWORD *)((char *)v63 + v31 + 4);
    v36 = (*(_DWORD *)((char *)v63 + v31) << 13) + 134348800;
    v38 = *(_DWORD *)((char *)&v63[1] + v31 + 4);
    v37 = *(_DWORD *)((char *)&v63[1] + v31 + 8);
    v39 = *(_DWORD *)((char *)&v63[1] + v31);
    v40 = 7223 * (v39 - v37);
    v42 = *(_DWORD *)((char *)v63 + v31 + 8);
    v41 = *(_DWORD *)((char *)v63 + v31 + 12);
    v43 = 2578 * (v42 - v39);
    v44 = v43 + v40;
    v45 = v37 + v42;
    v46 = v40 - 637 * v37;
    v47 = 7663 * (v41 + v35);
    v48 = v43 - 20239 * v42;
    v49 = 1395 * (v35 - v41);
    v50 = v47 - v49;
    v51 = v47 + v49;
    v52 = v36 + 10438 * v45;
    v53 = v46 + v52;
    v54 = 5027 * (v38 + v35);
    v55 = v50 + v54;
    v56 = v36 - 15083 * v39 + v44;
    v57 = (_BYTE *)(v34 + a5);
    *v57 = *(_BYTE *)(v32 + (((unint64_t)(v55 + v53) >> 18) & 0x3FF));
    v58 = -11295 * (v38 + v41);
    v59 = v51 + v58;
    v57[6] = *(_BYTE *)(v32 + (((unint64_t)(v53 - v55) >> 18) & 0x3FF));
    v60 = v54 + 15326 * v38 + v58;
    v57[1] = *(_BYTE *)(v32 + (((unint64_t)(v59 + v56) >> 18) & 0x3FF));
    v57[5] = *(_BYTE *)(v32 + (((unint64_t)(v56 - v59) >> 18) & 0x3FF));
    v57[2] = *(_BYTE *)(v32 + (((unint64_t)(v60 + v48 + v52) >> 18) & 0x3FF));
    v57[4] = *(_BYTE *)(v32 + (((unint64_t)(v48 + v52 - v60) >> 18) & 0x3FF));
    v57[3] = *(_BYTE *)(v32 + (((unint64_t)(v36 + 11585 * (v39 - v45)) >> 18) & 0x3FF));
    v31 += 28;
  }
  while (v31 != 196);
  return result;
}

uint64_t jpeg_idct_6x6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  uint64_t result;
  _OWORD v43[9];
  uint64_t v44;

  v5 = 0;
  v44 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  memset(v43, 0, sizeof(v43));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)v43 + v5;
    v9 = (_DWORD *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    v12 = (int)v9[32] * (uint64_t)v10[32];
    v13 = v11 + 5793 * v12;
    v14 = (unint64_t)(v11 - 11586 * v12) >> 11;
    v15 = 10033 * (int)v9[16] * (uint64_t)v10[16];
    v16 = v15 + v13;
    v17 = v13 - v15;
    v18 = (int)v9[8] * (uint64_t)v10[8];
    v19 = (int)v9[24] * (uint64_t)v10[24];
    v20 = (int)v9[40] * (uint64_t)v10[40];
    v21 = 2998 * (v18 + v20);
    v22 = v21 + ((v18 + v19) << 13);
    v23 = v21 + ((v20 - v19) << 13);
    LODWORD(v18) = v18 - (v19 + v20);
    *v8 = (unint64_t)(v22 + v16) >> 11;
    v8[30] = (unint64_t)(v16 - v22) >> 11;
    v8[6] = v14 + 4 * v18;
    v8[24] = v14 - 4 * v18;
    v8[12] = (unint64_t)(v23 + v17) >> 11;
    v8[18] = (unint64_t)(v17 - v23) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 6);
  v24 = 0;
  v25 = v6 - 384;
  v26 = a5;
  do
  {
    v27 = *a4++;
    v28 = (_BYTE *)(v27 + v26);
    v29 = *(_DWORD *)((char *)v43 + v24 + 4);
    v30 = *(_DWORD *)((char *)&v43[1] + v24);
    v31 = *(_DWORD *)((char *)&v43[1] + v24 + 4);
    v32 = (*(_DWORD *)((char *)v43 + v24) << 13) + 134348800;
    v33 = v32 + 5793 * v30;
    v34 = *(_DWORD *)((char *)v43 + v24 + 12);
    v35 = 10033 * *(_DWORD *)((char *)v43 + v24 + 8);
    v36 = 2998 * (v31 + v29);
    v37 = v36 + ((v34 + v29) << 13);
    v38 = v31 - v34;
    v39 = v29 - (v34 + v31);
    v40 = v32 - 11586 * v30;
    *v28 = *(_BYTE *)(v25 + (((unint64_t)(v37 + v33 + v35) >> 18) & 0x3FF));
    v41 = v36 + (v38 << 13);
    v28[5] = *(_BYTE *)(v25 + (((unint64_t)(v33 + v35 - v37) >> 18) & 0x3FF));
    v28[1] = *(_BYTE *)(v25 + (((unint64_t)(v40 + (v39 << 13)) >> 18) & 0x3FF));
    v28[4] = *(_BYTE *)(v25 + (((unint64_t)(v40 - (v39 << 13)) >> 18) & 0x3FF));
    v28[2] = *(_BYTE *)(v25 + (((unint64_t)(v41 + v33 - v35) >> 18) & 0x3FF));
    result = *(unsigned __int8 *)(v25 + (((unint64_t)(v33 - v35 - v41) >> 18) & 0x3FF));
    v28[3] = result;
    v24 += 24;
  }
  while (v24 != 144);
  return result;
}

uint64_t jpeg_idct_5x5(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t result;
  uint64_t v28;
  int v29;
  _BYTE *v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  _OWORD v43[6];
  int v44;
  uint64_t v45;

  v5 = 0;
  v45 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  v44 = 0;
  memset(v43, 0, sizeof(v43));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)v43 + v5;
    v9 = (_DWORD *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    v12 = (int)v9[16] * (uint64_t)v10[16];
    v13 = v9[32];
    v14 = 6476 * (v12 + v13 * (uint64_t)v10[32]);
    v15 = v12 - v13 * (uint64_t)v10[32];
    v16 = v11 + 2896 * v15;
    v17 = v16 + v14;
    v18 = v16 - v14;
    v19 = v11 + 0x7FFFFFFD2C0 * v15;
    v20 = (int)v9[8] * (uint64_t)v10[8];
    v21 = (int)v9[24] * (uint64_t)v10[24];
    v22 = 6810 * (v20 + v21);
    v23 = v22 + 4209 * v20;
    v24 = v22 - 17828 * v21;
    *v8 = (unint64_t)(v23 + v17) >> 11;
    v8[20] = (unint64_t)(v17 - v23) >> 11;
    v8[5] = (unint64_t)(v24 + v18) >> 11;
    v8[15] = (unint64_t)(v18 - v24) >> 11;
    v8[10] = v19 >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 5);
  v25 = 0;
  v26 = v6 - 384;
  result = a5;
  do
  {
    v28 = *a4++;
    v29 = *(_DWORD *)((char *)v43 + v25 + 4);
    v30 = (_BYTE *)(v28 + result);
    v31 = (*(_DWORD *)((char *)v43 + v25) << 13) + 134348800;
    v32 = *(_DWORD *)((char *)v43 + v25 + 8);
    v33 = *(_DWORD *)((char *)v43 + v25 + 12);
    v34 = *(_DWORD *)((char *)&v43[1] + v25);
    v35 = 6476 * (v34 + v32);
    v36 = v32 - v34;
    v37 = v31 + 2896 * v36;
    v38 = 6810 * (v33 + v29);
    v39 = v37 + v35;
    v40 = v38 + 4209 * v29;
    v41 = v38 - 17828 * v33;
    *v30 = *(_BYTE *)(v26 + (((unint64_t)(v40 + v37 + v35) >> 18) & 0x3FF));
    v42 = v37 - v35;
    v30[4] = *(_BYTE *)(v26 + (((unint64_t)(v39 - v40) >> 18) & 0x3FF));
    v30[1] = *(_BYTE *)(v26 + (((unint64_t)(v41 + v42) >> 18) & 0x3FF));
    v30[3] = *(_BYTE *)(v26 + (((unint64_t)(v42 - v41) >> 18) & 0x3FF));
    v30[2] = *(_BYTE *)(v26 + (((unint64_t)(v31 + 268423872 * v36) >> 18) & 0x3FF));
    v25 += 20;
  }
  while (v25 != 100);
  return result;
}

uint64_t _cg_jpeg_idct_4x4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t result;
  _OWORD v38[4];
  uint64_t v39;

  v5 = 0;
  v39 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  memset(v38, 0, sizeof(v38));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)v38 + v5;
    v9 = (_DWORD *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = *v9 * *v10;
    v12 = v9[16] * v10[16];
    v13 = v12 + v11;
    v14 = 4 * (v12 + v11);
    v15 = v11 - v12;
    v16 = (int)v9[8] * (uint64_t)v10[8];
    v17 = (int)v9[24] * (uint64_t)v10[24];
    v18 = 4433 * (v16 + v17) + 1024;
    v19 = (unint64_t)(v18 + 6270 * v16) >> 11;
    v20 = (unint64_t)(v18 - 15137 * v17) >> 11;
    *v8 = v19 + 4 * v13;
    v8[12] = v14 - v19;
    v8[4] = v20 + 4 * v15;
    v8[8] = 4 * v15 - v20;
    ++v5;
  }
  while ((_DWORD)v5 != 4);
  v21 = 0;
  v22 = v6 - 384;
  v23 = a5;
  do
  {
    v24 = *a4++;
    v25 = (_BYTE *)(v24 + v23);
    v26 = DWORD1(v38[v21]);
    v27 = DWORD2(v38[v21]);
    v28 = HIDWORD(v38[v21]);
    v29 = LODWORD(v38[v21]) + 16400;
    v30 = v29 + v27;
    v31 = (v29 + v27) << 13;
    v32 = v29 - v27;
    v33 = 4433 * (v28 + v26);
    v34 = v32 << 13;
    v35 = v33 + 6270 * v26;
    v36 = v33 - 15137 * v28;
    *v25 = *(_BYTE *)(v22 + (((unint64_t)(v35 + (v30 << 13)) >> 18) & 0x3FF));
    v25[3] = *(_BYTE *)(v22 + (((unint64_t)(v31 - v35) >> 18) & 0x3FF));
    result = *(unsigned __int8 *)(v22 + (((unint64_t)(v36 + (v32 << 13)) >> 18) & 0x3FF));
    v25[1] = result;
    v25[2] = *(_BYTE *)(v22 + (((unint64_t)(v34 - v36) >> 18) & 0x3FF));
    ++v21;
  }
  while (v21 != 4);
  return result;
}

uint64_t jpeg_idct_3x3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  int v19;
  int v20;
  int v21;
  unint64_t v22;
  int v23;
  uint64_t result;
  _OWORD v25[2];
  int v26;
  uint64_t v27;

  v5 = 0;
  v27 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  v26 = 0;
  memset(v25, 0, sizeof(v25));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)v25 + v5;
    v9 = (_DWORD *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    v12 = (int)v9[16] * (uint64_t)v10[16];
    v13 = v11 + 5793 * v12;
    v14 = 10033 * (int)v9[8] * (uint64_t)v10[8];
    *v8 = (unint64_t)(v14 + v13) >> 11;
    v8[6] = (unint64_t)(v13 - v14) >> 11;
    v8[3] = (unint64_t)(v11 + 0x7FFFFFFD2BELL * v12) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 3);
  v15 = 0;
  v16 = v6 - 384;
  do
  {
    v17 = *a4++;
    v18 = (_BYTE *)(v17 + a5);
    v19 = (*(_DWORD *)((char *)v25 + v15) << 13) + 134348800;
    v20 = *(_DWORD *)((char *)v25 + v15 + 8);
    v21 = v19 + 5793 * v20;
    v22 = (v19 + 268423870 * v20);
    v23 = 10033 * *(_DWORD *)((char *)v25 + v15 + 4);
    *v18 = *(_BYTE *)(v16 + (((unint64_t)(v21 + v23) >> 18) & 0x3FF));
    result = *(unsigned __int8 *)(v16 + (((unint64_t)(v21 - v23) >> 18) & 0x3FF));
    v18[2] = result;
    v18[1] = *(_BYTE *)(v16 + ((v22 >> 18) & 0x3FF));
    v15 += 12;
  }
  while (v15 != 36);
  return result;
}

uint64_t _cg_jpeg_idct_2x2(uint64_t result, uint64_t a2, unsigned __int16 *a3, _QWORD *a4, unsigned int a5)
{
  uint64_t v5;
  _DWORD *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  _BYTE *v13;
  _BYTE *v14;

  v5 = *(_QWORD *)(result + 440) - 384;
  v6 = *(_DWORD **)(a2 + 88);
  v7 = *v6 * *a3 + 4100;
  v8 = v6[8] * a3[8];
  v9 = v8 + v7;
  v10 = v7 - v8;
  v11 = v6[1] * a3[1];
  LODWORD(v6) = v6[9] * a3[9];
  v12 = (_DWORD)v6 + v11;
  LODWORD(v6) = v11 - (_DWORD)v6;
  v13 = (_BYTE *)(*a4 + a5);
  *v13 = *(_BYTE *)(v5 + (((unint64_t)(v12 + v9) >> 3) & 0x3FF));
  v13[1] = *(_BYTE *)(v5 + (((unint64_t)(v9 - v12) >> 3) & 0x3FF));
  v14 = (_BYTE *)(a4[1] + a5);
  *v14 = *(_BYTE *)(v5 + (((unint64_t)((_DWORD)v6 + v10) >> 3) & 0x3FF));
  v14[1] = *(_BYTE *)(v5 + (((unint64_t)(v10 - (_DWORD)v6) >> 3) & 0x3FF));
  return result;
}

uint64_t _cg_jpeg_idct_1x1(uint64_t result, uint64_t a2, unsigned __int16 *a3, _QWORD *a4, unsigned int a5)
{
  *(_BYTE *)(*a4 + a5) = *(_BYTE *)(*(_QWORD *)(result + 440)
                                  + (((unint64_t)(**(_DWORD **)(a2 + 88) * *a3 + 4100) >> 3) & 0x3FF)
                                  - 384);
  return result;
}

uint64_t jpeg_idct_9x9(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t result;
  _DWORD *v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  unint64_t v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  _BYTE *v67;
  int v68;
  int v69;
  _OWORD v72[18];
  uint64_t v73;

  v5 = 0;
  v73 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  memset(v72, 0, sizeof(v72));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)(v7 + 4 * v5);
    v9 = (__int16 *)(a3 + 2 * v5);
    v10 = (int)v8[16] * (uint64_t)v9[16];
    v11 = ((uint64_t)(*v8 * *v9) << 13) | 0x400;
    v12 = v8[32];
    v13 = (int)v8[48] * (uint64_t)v9[48];
    v14 = v11 + 5793 * v13;
    v15 = v11 - 11586 * v13;
    v16 = (int)v8[8] * (uint64_t)v9[8];
    v17 = (int)v8[40] * (uint64_t)v9[40];
    v18 = v16 + v17;
    v19 = v16 - v17;
    v20 = v8[56];
    v21 = v16 + v20 * (uint64_t)v9[56];
    v22 = v17 - v20 * (uint64_t)v9[56];
    v23 = v19 - v20 * (uint64_t)v9[56];
    v24 = v10 - v12 * (uint64_t)v9[32];
    v25 = v15 + 5793 * v24;
    v26 = v15 + 0x7FFFFFFD2BELL * v24;
    v27 = v12 * (uint64_t)v9[32];
    v28 = 10887 * (v10 + v27);
    v10 *= 8875;
    v29 = 2012 * v27;
    v30 = v28 - 2012 * v27 + v14;
    v31 = v14 - v28 + v10;
    v32 = v14 - v10 + v29;
    v33 = -10033 * (int)v8[24] * (uint64_t)v9[24];
    v22 *= 11409;
    v18 *= 7447;
    v34 = v33 - v22 + v18;
    v35 = v18 - v33;
    v36 = v22 + v33;
    v37 = (_DWORD *)v72 + v5;
    v38 = v35 + 3962 * v21;
    v39 = v36 + 3962 * v21;
    *v37 = (unint64_t)(v38 + v30) >> 11;
    v23 *= 10033;
    v37[64] = (unint64_t)(v30 - v38) >> 11;
    v37[8] = (unint64_t)(v23 + v25) >> 11;
    v37[56] = (unint64_t)(v25 - v23) >> 11;
    v37[16] = (unint64_t)(v34 + v31) >> 11;
    v37[48] = (unint64_t)(v31 - v34) >> 11;
    v37[24] = (unint64_t)(v39 + v32) >> 11;
    v37[40] = (unint64_t)(v32 - v39) >> 11;
    v37[32] = v26 >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v40 = 0;
  v41 = v6 - 384;
  result = 4294957263;
  do
  {
    v43 = &v72[v40];
    v44 = v43[1];
    v45 = v43[6];
    v46 = v43[7];
    v47 = (*v43 << 13) + 134348800;
    v48 = v47 + 5793 * v45;
    v49 = v43[2];
    v50 = v43[3];
    v51 = v43[4];
    LODWORD(v43) = v43[5];
    v52 = v47 - 11586 * v45;
    v53 = v49 - v51;
    v54 = v52 + 5793 * (v49 - v51);
    v55 = 10887 * (v51 + v49);
    v49 *= 8875;
    v56 = (v52 + 268423870 * v53);
    v57 = 2012 * v51;
    v58 = v55 - 2012 * v51 + v48;
    v59 = v48 - v55;
    v60 = v48 - v49;
    v61 = v59 + v49;
    v50 *= -10033;
    v62 = 7447 * ((_DWORD)v43 + v44);
    v63 = 3962 * (v46 + v44);
    v64 = v60 + v57;
    v65 = v62 - v50 + v63;
    v66 = (_DWORD)v43 - v46;
    LODWORD(v43) = v44 - ((_DWORD)v43 + v46);
    v67 = (_BYTE *)(*(_QWORD *)(a4 + v40 * 4) + a5);
    *v67 = *(_BYTE *)(v41 + (((unint64_t)(v65 + v58) >> 18) & 0x3FF));
    LODWORD(v43) = 10033 * (_DWORD)v43;
    v67[8] = *(_BYTE *)(v41 + (((unint64_t)(v58 - v65) >> 18) & 0x3FF));
    v67[1] = *(_BYTE *)(v41 + (((unint64_t)((_DWORD)v43 + v54) >> 18) & 0x3FF));
    v66 *= 11409;
    v68 = v50 - v66 + v62;
    v67[7] = *(_BYTE *)(v41 + (((unint64_t)(v54 - (_DWORD)v43) >> 18) & 0x3FF));
    v67[2] = *(_BYTE *)(v41 + (((unint64_t)(v68 + v61) >> 18) & 0x3FF));
    v69 = v66 + v50 + v63;
    v67[6] = *(_BYTE *)(v41 + (((unint64_t)(v61 - v68) >> 18) & 0x3FF));
    v67[3] = *(_BYTE *)(v41 + (((unint64_t)(v69 + v64) >> 18) & 0x3FF));
    v67[5] = *(_BYTE *)(v41 + (((unint64_t)(v64 - v69) >> 18) & 0x3FF));
    v67[4] = *(_BYTE *)(v41 + ((v56 >> 18) & 0x3FF));
    v40 += 2;
  }
  while (v40 != 18);
  return result;
}

uint64_t jpeg_idct_10x10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t result;
  _DWORD *v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  _BYTE *v63;
  int v64;
  int v65;
  unint64_t v66;
  unint64_t v67;
  int v68;
  int v69;
  int v70;
  unint64_t v71;
  uint64_t v72;
  _OWORD v74[20];
  uint64_t v75;

  v5 = 0;
  v75 = *MEMORY[0x1E0C80C00];
  v72 = *(_QWORD *)(a1 + 440);
  memset(v74, 0, sizeof(v74));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)(v6 + 4 * v5);
    v8 = (__int16 *)(a3 + 2 * v5);
    v9 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    v10 = (int)v7[32] * (uint64_t)v8[32];
    v11 = v9 + 9373 * v10;
    v12 = v9 - 3580 * v10;
    v13 = v9 - 11586 * v10;
    v14 = (int)v7[16] * (uint64_t)v8[16];
    v15 = (int)v7[48] * (uint64_t)v8[48];
    v16 = 6810 * (v14 + v15);
    v17 = v16 + 4209 * v14;
    v18 = v16 - 17828 * v15;
    v19 = v17 + v11;
    v20 = v11 - v17;
    v21 = v18 + v12;
    v22 = v12 - v18;
    v23 = (int)v7[8] * (uint64_t)v8[8];
    v24 = (int)v7[24] * (uint64_t)v8[24];
    v25 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    v26 = v24 + (int)v7 * (uint64_t)(int)v8;
    v27 = v24 - (int)v7 * (uint64_t)(int)v8;
    v28 = 2531 * v27 + (v25 << 13);
    v29 = 7791 * v26 + 11443 * v23 + v28;
    v30 = 1812 * v23 - 7791 * v26 + v28;
    v31 = 4815 * v26;
    v32 = -6627 * v27 + (v25 << 13);
    LODWORD(v27) = v23 - v25 - v27;
    v33 = 10323 * v23 - (v31 + v32);
    v34 = 5260 * v23 - v31;
    v35 = (_DWORD *)v74 + v5;
    v36 = v34 + v32;
    *v35 = (unint64_t)(v29 + v19) >> 11;
    v35[72] = (unint64_t)(v19 - v29) >> 11;
    v35[8] = (unint64_t)(v33 + v21) >> 11;
    v35[64] = (unint64_t)(v21 - v33) >> 11;
    v35[16] = (v13 >> 11) + 4 * v27;
    v35[56] = (v13 >> 11) - 4 * v27;
    v35[24] = (unint64_t)(v36 + v22) >> 11;
    v35[48] = (unint64_t)(v22 - v36) >> 11;
    v35[32] = (unint64_t)(v30 + v20) >> 11;
    v35[40] = (unint64_t)(v20 - v30) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v37 = 0;
  v38 = v72 - 384;
  result = 2531;
  do
  {
    v40 = &v74[v37];
    v41 = *(_QWORD *)(a4 + v37 * 4);
    v42 = v40[1];
    v43 = v40[4];
    v44 = v40[5];
    v45 = (*v40 << 13) + 134348800;
    v46 = v45 + 9373 * v43;
    v47 = v45 - 3580 * v43;
    v49 = v40[2];
    v48 = v40[3];
    v50 = v45 - 11586 * v43;
    v51 = a4;
    v53 = v40[6];
    v52 = v40[7];
    LODWORD(v40) = 6810 * (v53 + v49);
    v54 = (_DWORD)v40 + 4209 * v49;
    v55 = (_DWORD)v40 - 17828 * v53;
    v56 = v54 + v46;
    LODWORD(v40) = v46 - v54;
    v57 = v55 + v47;
    v58 = v52 + v48;
    v59 = v48 - v52;
    v60 = v47 - v55;
    v61 = 2531 * v59 + (v44 << 13);
    v62 = 7791 * v58 + 11443 * v42 + v61;
    v63 = (_BYTE *)(v41 + a5);
    v64 = 1812 * v42 - 7791 * v58 + v61;
    v65 = 4815 * v58;
    v66 = (v62 + v56);
    v67 = (v56 - v62);
    v68 = -6627 * v59 + (v44 << 13);
    *v63 = *(_BYTE *)(v38 + ((v66 >> 18) & 0x3FF));
    LODWORD(v66) = 10323 * v42 - (v65 + v68);
    v63[9] = *(_BYTE *)(v38 + ((v67 >> 18) & 0x3FF));
    v69 = v42 - v44 - v59;
    v63[1] = *(_BYTE *)(v38 + (((unint64_t)(v66 + v57) >> 18) & 0x3FF));
    v63[8] = *(_BYTE *)(v38 + (((unint64_t)(v57 - v66) >> 18) & 0x3FF));
    v70 = 5260 * v42 - v65;
    v63[2] = *(_BYTE *)(v38 + (((unint64_t)(v50 + (v69 << 13)) >> 18) & 0x3FF));
    v63[7] = *(_BYTE *)(v38 + (((unint64_t)(v50 - (v69 << 13)) >> 18) & 0x3FF));
    v63[3] = *(_BYTE *)(v38 + (((unint64_t)(v70 + v68 + v60) >> 18) & 0x3FF));
    v71 = (v60 - (v70 + v68));
    a4 = v51;
    v63[6] = *(_BYTE *)(v38 + ((v71 >> 18) & 0x3FF));
    v63[4] = *(_BYTE *)(v38 + (((unint64_t)(v64 + (_DWORD)v40) >> 18) & 0x3FF));
    v63[5] = *(_BYTE *)(v38 + (((unint64_t)((_DWORD)v40 - v64) >> 18) & 0x3FF));
    v37 += 2;
  }
  while (v37 != 20);
  return result;
}

uint64_t jpeg_idct_11x11(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  __int16 *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _DWORD *v47;
  int v48;
  _BYTE *v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  unint64_t v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  uint64_t result;
  int v78;
  uint64_t v79;
  _OWORD v82[22];
  uint64_t v83;

  v5 = 0;
  v83 = *MEMORY[0x1E0C80C00];
  v79 = *(_QWORD *)(a1 + 440);
  memset(v82, 0, sizeof(v82));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)(v6 + 4 * v5);
    v8 = (__int16 *)(a3 + 2 * v5);
    v9 = *v7 * *v8;
    v10 = (int)v7[16] * (uint64_t)v8[16];
    v11 = (int)v7[32] * (uint64_t)v8[32];
    v12 = (int)v7[48] * (uint64_t)v8[48];
    v13 = (int)v7[8] * (uint64_t)v8[8];
    v14 = (int)v7[24] * (uint64_t)v8[24];
    v15 = (int)v7[40] * (uint64_t)v8[40];
    v16 = (int)v7[56] * (uint64_t)v8[56];
    v17 = v10 + v12 - v11;
    v18 = v13 + v16;
    v19 = 3264 * (v13 + v14 + v15 + v16);
    v20 = 7274 * (v13 + v14);
    v21 = 5492 * (v13 + v15);
    v22 = v20 - 7562 * v13 + v21;
    v23 = v19 - 9527 * (v14 + v15);
    v24 = v21 - 9766 * v15 + v23;
    v25 = v20 + 16984 * v14 - 14731 * (v14 + v16) + v23;
    v26 = v19 + 3000 * v18;
    v27 = v22 + v26;
    v28 = -14731 * (v14 + v16) + 17223 * v16 + v26;
    v29 = (_DWORD *)v82 + v5;
    v30 = ((uint64_t)v9 << 13) | 0x400;
    v31 = -12019 * v14 + 8203 * v15;
    v32 = v30 + 11116 * v17;
    v33 = 20862 * (v11 - v12);
    v34 = v32 + 3529 * (v11 - v10);
    v35 = v32 + v33;
    v36 = v31 - 13802 * v16 + v19;
    v37 = v34 - 14924 * v11 + v33;
    v38 = v35 + 17333 * v12;
    *v29 = (unint64_t)(v27 + v38) >> 11;
    v29[80] = (unint64_t)(v38 - v27) >> 11;
    v39 = v25 + v37;
    v40 = v37 - v25;
    v41 = v32 - 9467 * (v10 + v12);
    v29[8] = v39 >> 11;
    v42 = -11395 * v10 + 15929 * v11 + v41;
    v43 = v41 - 6461 * v12;
    v29[16] = (unint64_t)(v24 + v43) >> 11;
    v29[64] = (unint64_t)(v43 - v24) >> 11;
    v29[72] = v40 >> 11;
    v44 = v34 - 12399 * v10;
    v29[24] = (unint64_t)(v28 + v44) >> 11;
    v29[56] = (unint64_t)(v44 - v28) >> 11;
    v29[32] = (unint64_t)(v36 + v42) >> 11;
    v29[48] = (unint64_t)(v42 - v36) >> 11;
    v29[40] = (unint64_t)(v30 + 0x7FFFFFFD2BFLL * v17) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v45 = 0;
  v46 = v79 - 384;
  do
  {
    v47 = &v82[v45];
    v48 = v47[1];
    v49 = (_BYTE *)(*(_QWORD *)(a4 + v45 * 4) + a5);
    v50 = (*v47 << 13) + 134348800;
    v51 = v47[4];
    v52 = v47[5];
    v54 = v47[6];
    v53 = v47[7];
    v55 = 20862 * (v51 - v54);
    v56 = v47[2];
    v57 = v47[3];
    v58 = v54 + v56 - v51;
    v59 = v50 + 11116 * v58;
    LODWORD(v47) = v59 + 3529 * (v51 - v56);
    v60 = (_DWORD)v47 - 14924 * v51;
    v61 = v59 + v55 + 17333 * v54;
    v62 = (_DWORD)v47 - 12399 * v56;
    v63 = v59 - 9467 * (v54 + v56);
    v64 = -11395 * v56 + 15929 * v51;
    v65 = (v50 + 268423871 * v58);
    v66 = v63 - 6461 * v54;
    v67 = 3264 * (v57 + v48 + v52 + v53);
    v68 = 7274 * (v57 + v48);
    v69 = v64 + v63;
    v70 = 5492 * (v52 + v48);
    v71 = v67 + 3000 * (v53 + v48);
    v72 = v60 + v55;
    v73 = v68 - 7562 * v48 + v70 + v71;
    *v49 = *(_BYTE *)(v46 + (((unint64_t)(v73 + v61) >> 18) & 0x3FF));
    v74 = v67 - 9527 * (v52 + v57);
    v75 = v70 - 9766 * v52 + v74;
    v76 = v68 + 16984 * v57 - 14731 * (v53 + v57) + v74;
    v49[10] = *(_BYTE *)(v46 + (((unint64_t)(v61 - v73) >> 18) & 0x3FF));
    v49[1] = *(_BYTE *)(v46 + (((unint64_t)(v76 + v72) >> 18) & 0x3FF));
    LOBYTE(v73) = *(_BYTE *)(v46 + (((unint64_t)(v72 - v76) >> 18) & 0x3FF));
    result = (-14731 * (v53 + v57) + 17223 * v53 + v71);
    v49[9] = v73;
    v49[2] = *(_BYTE *)(v46 + (((unint64_t)(v75 + v66) >> 18) & 0x3FF));
    v49[8] = *(_BYTE *)(v46 + (((unint64_t)(v66 - v75) >> 18) & 0x3FF));
    v49[3] = *(_BYTE *)(v46 + (((unint64_t)(result + v62) >> 18) & 0x3FF));
    v78 = -12019 * v57 + 8203 * v52 - 13802 * v53 + v67;
    v49[7] = *(_BYTE *)(v46 + (((unint64_t)(v62 - result) >> 18) & 0x3FF));
    v49[4] = *(_BYTE *)(v46 + (((unint64_t)(v78 + v69) >> 18) & 0x3FF));
    v49[6] = *(_BYTE *)(v46 + (((unint64_t)(v69 - v78) >> 18) & 0x3FF));
    v49[5] = *(_BYTE *)(v46 + ((v65 >> 18) & 0x3FF));
    v45 += 2;
  }
  while (v45 != 22);
  return result;
}

_BYTE *jpeg_idct_12x12(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  _BYTE *result;
  unint64_t v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  uint64_t v78;
  _OWORD v81[24];
  uint64_t v82;

  v5 = 0;
  v82 = *MEMORY[0x1E0C80C00];
  v78 = *(_QWORD *)(a1 + 440);
  memset(v81, 0, sizeof(v81));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)(v6 + 4 * v5);
    v8 = (__int16 *)(a3 + 2 * v5);
    v9 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    v10 = 10033 * (int)v7[32] * (uint64_t)v8[32];
    v11 = v10 + v9;
    v12 = v9 - v10;
    v13 = (int)v7[16] * (uint64_t)v8[16];
    v14 = (int)v7[48] * (uint64_t)v8[48];
    v15 = v9 + ((v13 - v14) << 13);
    v16 = v9 - ((v13 - v14) << 13);
    v17 = 11190 * v13 + (v14 << 13);
    v18 = v17 + v11;
    v19 = v11 - v17;
    v20 = 2998 * v13 - (v14 << 13);
    v21 = v20 + v12;
    v22 = v12 - v20;
    v23 = (int)v7[8] * (uint64_t)v8[8];
    v24 = (int)v7[24] * (uint64_t)v8[24];
    v25 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    v26 = 10703 * v24;
    v27 = -4433 * v24;
    v28 = 7053 * (v23 + v25 + (int)v7 * (uint64_t)(int)v8);
    v29 = v28 + 2139 * (v23 + v25);
    v30 = v24 - v25;
    v31 = v26 + 2295 * v23 + v29;
    v32 = -8565 * (v25 + (int)v7 * (uint64_t)(int)v8);
    v33 = v27 - 12112 * v25 - 8565 * (v25 + (int)v7 * (uint64_t)(int)v8) + v29;
    v34 = (int)v7 * (uint64_t)(int)v8;
    v35 = v23 - v34;
    v36 = v27 - 5540 * v23 - 16244 * v34;
    v37 = (_DWORD *)v81 + v5;
    v38 = 12998 * v34 - v26 + v32 + v28;
    v39 = v36 + v28;
    v40 = 4433 * (v35 + v30);
    v41 = v40 + 6270 * v35;
    v42 = v40 - 15137 * v30;
    *v37 = (unint64_t)(v31 + v18) >> 11;
    v37[88] = (unint64_t)(v18 - v31) >> 11;
    v37[8] = (unint64_t)(v41 + v15) >> 11;
    v37[80] = (unint64_t)(v15 - v41) >> 11;
    v37[16] = (unint64_t)(v33 + v21) >> 11;
    v37[72] = (unint64_t)(v21 - v33) >> 11;
    v37[24] = (unint64_t)(v38 + v22) >> 11;
    v37[64] = (unint64_t)(v22 - v38) >> 11;
    v37[32] = (unint64_t)(v42 + v16) >> 11;
    v37[56] = (unint64_t)(v16 - v42) >> 11;
    v37[40] = (unint64_t)(v39 + v19) >> 11;
    v37[48] = (unint64_t)(v19 - v39) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v43 = 0;
  v44 = v78 - 384;
  do
  {
    v45 = &v81[v43];
    v46 = v45[1];
    v47 = (*v45 << 13) + 134348800;
    v48 = v45[5];
    v49 = 10033 * v45[4];
    v50 = v47 + v49;
    v51 = v45[2];
    v52 = v45[3];
    v53 = v45[6];
    LODWORD(v45) = v45[7];
    v54 = v47 - v49;
    v55 = v47 + ((v51 - v53) << 13);
    v56 = v47 - ((v51 - v53) << 13);
    v57 = 11190 * v51 + (v53 << 13);
    v58 = v57 + v50;
    v59 = v50 - v57;
    v60 = 2998 * v51 - (v53 << 13);
    v61 = 10703 * v52;
    v62 = -4433 * v52;
    v63 = v60 + v54;
    v64 = 7053 * (v48 + v46 + (_DWORD)v45);
    v65 = v64 + 2139 * (v48 + v46);
    v66 = v54 - v60;
    v67 = 10703 * v52 + 2295 * v46 + v65;
    v68 = -8565 * ((_DWORD)v45 + v48);
    v69 = -4433 * v52 - 12112 * v48 - 8565 * ((_DWORD)v45 + v48) + v65;
    v70 = v52 - v48;
    result = (_BYTE *)(*(_QWORD *)(a4 + v43 * 4) + a5);
    *result = *(_BYTE *)(v44 + (((unint64_t)(v67 + v58) >> 18) & 0x3FF));
    v72 = (v58 - v67);
    v73 = 4433 * (v46 - (_DWORD)v45 + v70);
    v74 = v73 + 6270 * (v46 - (_DWORD)v45);
    result[11] = *(_BYTE *)(v44 + ((v72 >> 18) & 0x3FF));
    result[1] = *(_BYTE *)(v44 + (((unint64_t)(v74 + v55) >> 18) & 0x3FF));
    v75 = 12998 * (_DWORD)v45 - v61 + v64 + v68;
    result[10] = *(_BYTE *)(v44 + (((unint64_t)(v55 - v74) >> 18) & 0x3FF));
    result[2] = *(_BYTE *)(v44 + (((unint64_t)(v69 + v63) >> 18) & 0x3FF));
    result[9] = *(_BYTE *)(v44 + (((unint64_t)(v63 - v69) >> 18) & 0x3FF));
    v76 = v62 - 5540 * v46 - 16244 * (_DWORD)v45 + v64;
    result[3] = *(_BYTE *)(v44 + (((unint64_t)(v75 + v66) >> 18) & 0x3FF));
    LOBYTE(v66) = *(_BYTE *)(v44 + (((unint64_t)(v66 - v75) >> 18) & 0x3FF));
    v77 = v73 - 15137 * v70;
    result[8] = v66;
    result[4] = *(_BYTE *)(v44 + (((unint64_t)(v77 + v56) >> 18) & 0x3FF));
    result[7] = *(_BYTE *)(v44 + (((unint64_t)(v56 - v77) >> 18) & 0x3FF));
    result[5] = *(_BYTE *)(v44 + (((unint64_t)(v76 + v59) >> 18) & 0x3FF));
    result[6] = *(_BYTE *)(v44 + (((unint64_t)(v59 - v76) >> 18) & 0x3FF));
    v43 += 2;
  }
  while (v43 != 24);
  return result;
}

uint64_t jpeg_idct_13x13(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  __int16 *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _DWORD *v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  unint64_t v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  _BYTE *v78;
  int v79;
  unint64_t v80;
  int v81;
  int v82;
  int v83;
  uint64_t result;
  uint64_t v85;
  _OWORD v88[26];
  uint64_t v89;

  v5 = 0;
  v89 = *MEMORY[0x1E0C80C00];
  v85 = *(_QWORD *)(a1 + 440);
  memset(v88, 0, sizeof(v88));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)(v6 + 4 * v5);
    v8 = (__int16 *)(a3 + 2 * v5);
    v9 = v8[16];
    v10 = v7[16];
    v11 = v10 * (uint64_t)v8[16];
    v12 = (int)v7[32] * (uint64_t)v8[32];
    v13 = v7[48];
    v14 = v12 + v13 * (uint64_t)v8[48];
    v15 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    v16 = v12 - v13 * (uint64_t)v8[48];
    v17 = v15 + 793 * v16;
    v18 = (int)v7[8] * (uint64_t)v8[8];
    v19 = (int)v7[24] * (uint64_t)v8[24];
    v20 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    v21 = 10832 * (v18 + v19);
    v22 = 9534 * (v18 + v20);
    v23 = v18 + (int)v7 * (uint64_t)(int)v8;
    v24 = 9465 * v14 + 11249 * v11 + v17;
    v25 = -2773 * (v19 + v20);
    v26 = v21 - 16549 * v18 + v22 + 7682 * v23;
    v27 = -9534 * (v19 + (int)v7 * (uint64_t)(int)v8);
    v28 = v21 + 6859 * v19 + v25 - 9534 * (v19 + (int)v7 * (uint64_t)(int)v8);
    v29 = -9465 * v14 + 4108 * v11 + v17;
    v30 = (int)v7 * (uint64_t)(int)v8;
    v31 = v15 + 3989 * v16;
    v32 = v25 - 12879 * v20 + v22 - 5384 * (v20 + v30);
    v33 = 2592 * v14 - 10258 * v11 + v31;
    v34 = -2592 * v14 + 8672 * v11 + v31;
    v14 *= 3570;
    v35 = v27 + 18068 * v30 + 7682 * v23 - 5384 * (v20 + v30);
    v36 = -v14 - 1396 * v11;
    v37 = v16 - v10 * (uint64_t)v9;
    v38 = (_DWORD *)v88 + v5;
    v39 = v15 - 7678 * v16;
    v40 = v14 - 6581 * v11 + v39;
    v41 = v36 + v39;
    *v38 = (unint64_t)(v26 + v24) >> 11;
    v38[96] = (unint64_t)(v24 - v26) >> 11;
    v38[8] = (unint64_t)(v28 + v34) >> 11;
    v38[88] = (unint64_t)(v34 - v28) >> 11;
    v38[16] = (unint64_t)(v32 + v29) >> 11;
    v42 = 7682 * (v20 - v19) + 2773 * v23;
    v38[80] = (unint64_t)(v29 - v32) >> 11;
    v38[24] = (unint64_t)(v35 + v41) >> 11;
    v38[72] = (unint64_t)(v41 - v35) >> 11;
    v43 = v42 + 2611 * v18 - 3818 * v19;
    v38[32] = (unint64_t)(v43 + v40) >> 11;
    v38[64] = (unint64_t)(v40 - v43) >> 11;
    v44 = v42 + 3150 * v20 - 14273 * v30;
    v38[40] = (unint64_t)(v44 + v33) >> 11;
    v38[56] = (unint64_t)(v33 - v44) >> 11;
    v38[48] = (unint64_t)(v15 + 11585 * v37) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v45 = 0;
  v46 = v85 - 384;
  do
  {
    v47 = &v88[v45];
    v48 = v47[1];
    v50 = v47[4];
    v49 = v47[5];
    v51 = (*v47 << 13) + 134348800;
    v52 = v47[6];
    v53 = v47[7];
    v54 = v52 + v50;
    v55 = v50 - v52;
    v56 = 9465 * (v52 + v50);
    v57 = v51 + 793 * v55;
    v59 = v47[2];
    v58 = v47[3];
    v60 = 4108 * v59 - v56;
    v61 = v56 + 11249 * v59 + v57;
    v62 = v51 + 3989 * v55;
    v63 = -2592 * v54 + 8672 * v59;
    LODWORD(v47) = 2592 * v54 - 10258 * v59;
    v54 *= 3570;
    v64 = (_DWORD)v47 + v62;
    v65 = v51 - 7678 * v55;
    v66 = -v54 - 1396 * v59;
    v67 = v54 - 6581 * v59 + v65;
    v68 = v60 + v57;
    v69 = (v51 + 11585 * (v55 - v59));
    v70 = 10832 * (v58 + v48);
    v71 = v63 + v62;
    v72 = 9534 * (v49 + v48);
    v73 = v66 + v65;
    v74 = v70 - 16549 * v48 + v72 + 7682 * (v53 + v48);
    v75 = -2773 * (v49 + v58);
    v76 = v70 + 6859 * v58 + v75 - 9534 * (v53 + v58);
    v77 = v75 - 12879 * v49 + v72 - 5384 * (v53 + v49);
    v78 = (_BYTE *)(*(_QWORD *)(a4 + v45 * 4) + a5);
    *v78 = *(_BYTE *)(v46 + (((unint64_t)(v74 + v61) >> 18) & 0x3FF));
    v78[12] = *(_BYTE *)(v46 + (((unint64_t)(v61 - v74) >> 18) & 0x3FF));
    v79 = -9534 * (v53 + v58) + 18068 * v53 + 7682 * (v53 + v48) - 5384 * (v53 + v49);
    v78[1] = *(_BYTE *)(v46 + (((unint64_t)(v76 + v71) >> 18) & 0x3FF));
    v78[11] = *(_BYTE *)(v46 + (((unint64_t)(v71 - v76) >> 18) & 0x3FF));
    v78[2] = *(_BYTE *)(v46 + (((unint64_t)(v77 + v68) >> 18) & 0x3FF));
    v80 = (v68 - v77);
    v81 = 7682 * (v49 - v58) + 2773 * (v53 + v48);
    v78[10] = *(_BYTE *)(v46 + ((v80 >> 18) & 0x3FF));
    v78[3] = *(_BYTE *)(v46 + (((unint64_t)(v79 + v73) >> 18) & 0x3FF));
    v82 = v81 + 2611 * v48 - 3818 * v58;
    v78[9] = *(_BYTE *)(v46 + (((unint64_t)(v73 - v79) >> 18) & 0x3FF));
    v78[4] = *(_BYTE *)(v46 + (((unint64_t)(v82 + v67) >> 18) & 0x3FF));
    v83 = v81 + 3150 * v49 - 14273 * v53;
    v78[8] = *(_BYTE *)(v46 + (((unint64_t)(v67 - v82) >> 18) & 0x3FF));
    result = *(unsigned __int8 *)(v46 + (((unint64_t)(v83 + v64) >> 18) & 0x3FF));
    v78[5] = result;
    v78[7] = *(_BYTE *)(v46 + (((unint64_t)(v64 - v83) >> 18) & 0x3FF));
    v78[6] = *(_BYTE *)(v46 + ((v69 >> 18) & 0x3FF));
    v45 += 2;
  }
  while (v45 != 26);
  return result;
}

uint64_t jpeg_idct_14x14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _DWORD *v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  _BYTE *v80;
  int v81;
  int v82;
  uint64_t result;
  int v84;
  int v85;
  int v86;
  int v87;
  uint64_t v88;
  _OWORD v91[28];
  uint64_t v92;

  v5 = 0;
  v92 = *MEMORY[0x1E0C80C00];
  v88 = *(_QWORD *)(a1 + 440);
  memset(v91, 0, sizeof(v91));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)(v6 + 4 * v5);
    v8 = (__int16 *)(a3 + 2 * v5);
    v9 = (int)v7[32] * (uint64_t)v8[32];
    v10 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    v11 = v10 + 10438 * v9;
    v12 = v10 + 2578 * v9;
    v13 = v10 - 7223 * v9;
    v14 = (int)v7[16] * (uint64_t)v8[16];
    v15 = (int)v7[48] * (uint64_t)v8[48];
    v16 = 9058 * (v14 + v15);
    v17 = v16 + 2237 * v14;
    v18 = v16 - 14084 * v15;
    v19 = 5027 * v14 - 11295 * v15;
    v20 = v17 + v11;
    v21 = v11 - v17;
    v22 = v18 + v12;
    v23 = v12 - v18;
    v24 = v19 + v13;
    v25 = v13 - v19;
    v26 = (int)v7[8] * (uint64_t)v8[8];
    v27 = (int)v7[24] * (uint64_t)v8[24];
    v28 = (int)v7[40] * (uint64_t)v8[40];
    v29 = (int)v7[56] * (uint64_t)v8[56];
    v30 = 10935 * (v26 + v27);
    v31 = 9810 * (v26 + v28);
    v32 = v30 - 9232 * v26 + v31;
    v33 = -1297 * (v27 + v28) - (v29 << 13);
    v34 = v30 - 3474 * v27 + v33;
    v35 = v31 - 19447 * v28 + v33;
    v36 = 6164 * (v26 + v28);
    v37 = v26 - v27;
    v38 = 11512 * (v28 - v27);
    v39 = v38 - 13850 * v28 + v36;
    v40 = v36 - 8693 * v26;
    v41 = v38 + 5529 * v27;
    v42 = 3826 * v37 - (v29 << 13);
    v43 = v40 + v42;
    v44 = v41 + v42;
    v45 = (_DWORD *)v91 + v5;
    v46 = v32 + (v29 << 13);
    v47 = v39 + (v29 << 13);
    LODWORD(v29) = v37 - v28 + v29;
    *v45 = (unint64_t)(v46 + v20) >> 11;
    v45[104] = (unint64_t)(v20 - v46) >> 11;
    v45[8] = (unint64_t)(v34 + v22) >> 11;
    v45[96] = (unint64_t)(v22 - v34) >> 11;
    v45[16] = (unint64_t)(v35 + v24) >> 11;
    v48 = (unint64_t)(v10 - 11586 * v9) >> 11;
    v45[88] = (unint64_t)(v24 - v35) >> 11;
    v45[24] = v48 + 4 * v29;
    v45[80] = v48 - 4 * v29;
    v45[32] = (unint64_t)(v47 + v25) >> 11;
    v45[72] = (unint64_t)(v25 - v47) >> 11;
    v45[40] = (unint64_t)(v44 + v23) >> 11;
    v45[64] = (unint64_t)(v23 - v44) >> 11;
    v45[48] = (unint64_t)(v43 + v21) >> 11;
    v45[56] = (unint64_t)(v21 - v43) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v49 = 0;
  v50 = v88 - 384;
  do
  {
    v51 = &v91[v49];
    v52 = v51[1];
    v53 = (*v51 << 13) + 134348800;
    v55 = v51[4];
    v54 = v51[5];
    v56 = v53 + 10438 * v55;
    v57 = v53 + 2578 * v55;
    v58 = v53 - 7223 * v55;
    v60 = v51[2];
    v59 = v51[3];
    v61 = v51[6];
    v62 = v51[7];
    v63 = v53 - 11586 * v55;
    LODWORD(v51) = 9058 * (v61 + v60);
    v64 = (_DWORD)v51 + 2237 * v60;
    v65 = (_DWORD)v51 - 14084 * v61;
    LODWORD(v51) = 5027 * v60 - 11295 * v61;
    v66 = v64 + v56;
    v67 = v56 - v64;
    v68 = (_DWORD)v51 + v58;
    LODWORD(v51) = v58 - (_DWORD)v51;
    v69 = v65 + v57;
    v70 = 10935 * (v59 + v52);
    v71 = 9810 * (v54 + v52);
    v72 = v70 - 9232 * v52 + v71 + (v62 << 13);
    v73 = v57 - v65;
    v74 = -1297 * (v54 + v59) - (v62 << 13);
    v75 = v70 - 3474 * v59 + v74;
    v76 = v71 - 19447 * v54 + v74;
    v77 = -13850 * v54 + (v62 << 13);
    v78 = 3826 * (v52 - v59) - (v62 << 13);
    v79 = v52 - v59 - v54 + v62;
    v80 = (_BYTE *)(*(_QWORD *)(a4 + v49 * 4) + a5);
    *v80 = *(_BYTE *)(v50 + (((unint64_t)(v72 + v66) >> 18) & 0x3FF));
    v80[13] = *(_BYTE *)(v50 + (((unint64_t)(v66 - v72) >> 18) & 0x3FF));
    v80[1] = *(_BYTE *)(v50 + (((unint64_t)(v75 + v69) >> 18) & 0x3FF));
    v80[12] = *(_BYTE *)(v50 + (((unint64_t)(v69 - v75) >> 18) & 0x3FF));
    v80[2] = *(_BYTE *)(v50 + (((unint64_t)(v76 + v68) >> 18) & 0x3FF));
    v81 = 6164 * (v54 + v52);
    v82 = 11512 * (v54 - v59);
    LOBYTE(v66) = *(_BYTE *)(v50 + (((unint64_t)(v68 - v76) >> 18) & 0x3FF));
    result = 4294958603;
    v84 = v81 - 8693 * v52;
    v80[11] = v66;
    v85 = v77 + v82 + v81;
    v80[3] = *(_BYTE *)(v50 + (((unint64_t)(v63 + (v79 << 13)) >> 18) & 0x3FF));
    v80[10] = *(_BYTE *)(v50 + (((unint64_t)(v63 - (v79 << 13)) >> 18) & 0x3FF));
    v80[4] = *(_BYTE *)(v50 + (((unint64_t)(v85 + (_DWORD)v51) >> 18) & 0x3FF));
    v86 = v84 + v78;
    v87 = v82 + 5529 * v59 + v78;
    v80[9] = *(_BYTE *)(v50 + (((unint64_t)((_DWORD)v51 - v85) >> 18) & 0x3FF));
    v80[5] = *(_BYTE *)(v50 + (((unint64_t)(v87 + v73) >> 18) & 0x3FF));
    v80[8] = *(_BYTE *)(v50 + (((unint64_t)(v73 - v87) >> 18) & 0x3FF));
    v80[6] = *(_BYTE *)(v50 + (((unint64_t)(v86 + v67) >> 18) & 0x3FF));
    v80[7] = *(_BYTE *)(v50 + (((unint64_t)(v67 - v86) >> 18) & 0x3FF));
    v49 += 2;
  }
  while (v49 != 28);
  return result;
}

uint64_t jpeg_idct_15x15(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  _BYTE *v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  unint64_t v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  int v83;
  unint64_t v84;
  int v85;
  int v86;
  uint64_t result;
  int v88;
  int v89;
  uint64_t v90;
  _OWORD v93[30];
  uint64_t v94;

  v5 = 0;
  v94 = *MEMORY[0x1E0C80C00];
  v90 = *(_QWORD *)(a1 + 440);
  memset(v93, 0, sizeof(v93));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)(v6 + 4 * v5);
    v8 = (__int16 *)(a3 + 2 * v5);
    v9 = (int)v7[16] * (uint64_t)v8[16];
    v10 = (int)v7[48] * (uint64_t)v8[48];
    v11 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    v12 = v7[32];
    v13 = v11 - 3580 * v10;
    v14 = v11 + 9373 * v10;
    v15 = v9 - v12 * (uint64_t)v8[32];
    v16 = v9 + v12 * (uint64_t)v8[32];
    v17 = 11795 * v9;
    v18 = 374 * v15 + 10958 * v16 + v14;
    v19 = 11795 * v9 - 10958 * v16 + 374 * v15 + v13;
    v20 = -3271 * v15 - 4482 * v16 + v14;
    v21 = 4482 * v16 - v17 + -3271 * v15 + v13;
    v22 = 6476 * v16;
    v23 = 2896 * v15 + 6476 * v16 + v13;
    v24 = v14 - v22 + 2896 * v15;
    v25 = (int)v7[8] * (uint64_t)v8[8];
    v26 = (int)v7[24] * (uint64_t)v8[24];
    v27 = v8[40];
    v28 = v7[40];
    v29 = 10033 * v28 * (uint64_t)v8[40];
    v30 = (int)v7[56] * (uint64_t)v8[56];
    v31 = -11018 * v26;
    v32 = v29 + 11522 * (v25 - v30);
    v33 = 11018 * v26 + 20131 * v30 + v32;
    v34 = -6810 * v26 - 9113 * v25 + v32;
    v35 = v26 - v30;
    v36 = -6810 * v26 + 3897 * v25 - v29;
    v37 = (_DWORD *)v93 + v5;
    v38 = 4712 * (v25 + v30);
    v39 = v36 + v38;
    v40 = v29 + v31 - 7121 * v30 + v38;
    *v37 = (unint64_t)(v33 + v18) >> 11;
    v37[112] = (unint64_t)(v18 - v33) >> 11;
    v41 = 6810 * (v35 + v25);
    v42 = v41 + 4209 * v25;
    v37[8] = (unint64_t)(v42 + v23) >> 11;
    v37[104] = (unint64_t)(v23 - v42) >> 11;
    v43 = v11 - 11586 * v10;
    v44 = v43 + 5792 * v15;
    v45 = 10033 * (v25 - v30 - v28 * (uint64_t)v27);
    v37[16] = (unint64_t)(v45 + v44) >> 11;
    v37[96] = (unint64_t)(v44 - v45) >> 11;
    v37[24] = (unint64_t)(v39 + v19) >> 11;
    v37[88] = (unint64_t)(v19 - v39) >> 11;
    v46 = v41 - 17828 * v35;
    v37[32] = (unint64_t)(v46 + v24) >> 11;
    v37[80] = (unint64_t)(v24 - v46) >> 11;
    v37[40] = (unint64_t)(v40 + v20) >> 11;
    v37[72] = (unint64_t)(v20 - v40) >> 11;
    v37[48] = (unint64_t)(v34 + v21) >> 11;
    v37[64] = (unint64_t)(v21 - v34) >> 11;
    v37[56] = (unint64_t)(v43 + 0x7FFFFFFD2C0 * v15) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v47 = 0;
  v48 = v90 - 384;
  do
  {
    v49 = &v93[v47];
    v50 = (_BYTE *)(*(_QWORD *)(a4 + v47 * 4) + a5);
    v51 = v49[1];
    v52 = (*v49 << 13) + 134348800;
    v53 = v49[6];
    v54 = v49[7];
    v55 = v52 - 3580 * v53;
    v56 = v52 + 9373 * v53;
    v57 = v49[2];
    v58 = v49[3];
    v59 = v49[4];
    v60 = v49[5];
    LODWORD(v49) = v52 - 11586 * v53;
    v61 = v57 - v59;
    v62 = v59 + v57;
    v57 *= 11795;
    v63 = 374 * v61 + 10958 * v62 + v56;
    v64 = v57 - 10958 * v62 + 374 * v61;
    v65 = -3271 * v61 - 4482 * v62 + v56;
    v66 = 4482 * v62 - v57 - 3271 * v61;
    v62 *= 6476;
    v67 = 2896 * v61;
    v68 = v64 + v55;
    v69 = 2896 * v61 + v62 + v55;
    v70 = v56 - v62;
    v71 = (_DWORD)v49 + 5792 * v61;
    v72 = ((_DWORD)v49 + 268423872 * v61);
    v73 = v66 + v55;
    v74 = 10033 * v60;
    v75 = v58 - v54;
    v76 = -11018 * v58;
    v77 = 10033 * v60 + 11522 * (v51 - v54);
    v78 = v70 + v67;
    v79 = 11018 * v58 + 20131 * v54 + v77;
    v80 = (v79 + v63);
    v81 = (v63 - v79);
    v82 = 6810 * (v58 - v54 + v51);
    *v50 = *(_BYTE *)(v48 + ((v80 >> 18) & 0x3FF));
    LODWORD(v80) = v82 + 4209 * v51;
    v50[14] = *(_BYTE *)(v48 + ((v81 >> 18) & 0x3FF));
    v50[1] = *(_BYTE *)(v48 + (((unint64_t)(v80 + v69) >> 18) & 0x3FF));
    v83 = 10033 * (v51 - v54 - v60);
    v50[13] = *(_BYTE *)(v48 + (((unint64_t)(v69 - v80) >> 18) & 0x3FF));
    v58 *= -6810;
    v50[2] = *(_BYTE *)(v48 + (((unint64_t)(v83 + v71) >> 18) & 0x3FF));
    LODWORD(v81) = 4712 * (v54 + v51);
    v84 = (v71 - v83);
    v85 = v58 + 3897 * v51 - v74 + v81;
    v50[12] = *(_BYTE *)(v48 + ((v84 >> 18) & 0x3FF));
    v86 = v82 - 17828 * v75;
    v50[3] = *(_BYTE *)(v48 + (((unint64_t)(v85 + v68) >> 18) & 0x3FF));
    result = (v74 + v76);
    v50[11] = *(_BYTE *)(v48 + (((unint64_t)(v68 - v85) >> 18) & 0x3FF));
    v50[4] = *(_BYTE *)(v48 + (((unint64_t)(v86 + v78) >> 18) & 0x3FF));
    v88 = result - 7121 * v54 + v81;
    v50[10] = *(_BYTE *)(v48 + (((unint64_t)(v78 - v86) >> 18) & 0x3FF));
    v50[5] = *(_BYTE *)(v48 + (((unint64_t)(v88 + v65) >> 18) & 0x3FF));
    v89 = v58 - 9113 * v51 + v77;
    v50[9] = *(_BYTE *)(v48 + (((unint64_t)(v65 - v88) >> 18) & 0x3FF));
    v50[6] = *(_BYTE *)(v48 + (((unint64_t)(v89 + v73) >> 18) & 0x3FF));
    v50[8] = *(_BYTE *)(v48 + (((unint64_t)(v73 - v89) >> 18) & 0x3FF));
    v50[7] = *(_BYTE *)(v48 + ((v72 >> 18) & 0x3FF));
    v47 += 2;
  }
  while (v47 != 30);
  return result;
}

uint64_t jpeg_idct_16x16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  _DWORD *v6;
  __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _DWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _DWORD *v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  uint64_t result;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  _BYTE *v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  uint64_t v110;
  uint64_t v113;
  uint64_t v115;
  _OWORD v116[32];
  uint64_t v117;

  v5 = 0;
  v117 = *MEMORY[0x1E0C80C00];
  v110 = *(_QWORD *)(a1 + 440);
  memset(v116, 0, sizeof(v116));
  v113 = *(_QWORD *)(a2 + 88);
  do
  {
    v6 = (_DWORD *)(v113 + 4 * v5);
    v7 = (__int16 *)(a3 + 2 * v5);
    v8 = (int)v6[32] * (uint64_t)v7[32];
    v9 = 10703 * v8;
    v10 = ((uint64_t)(*v6 * *v7) << 13) | 0x400;
    v8 *= 4433;
    v11 = v9 + v10;
    v12 = v10 - v9;
    v13 = v8 + v10;
    v14 = v10 - v8;
    v15 = (int)v6[16] * (uint64_t)v7[16];
    v16 = (int)v6[48] * (uint64_t)v7[48];
    v17 = 2260 * (v15 - v16);
    v18 = 11363 * (v15 - v16);
    v19 = v18 + 20995 * v16;
    v20 = v17 + 7373 * v15;
    v21 = v18 - 4926 * v15;
    v22 = v17 - 4176 * v16;
    v23 = v19 + v11;
    v115 = v11 - v19;
    v24 = v20 + v13;
    v25 = v13 - v20;
    v26 = v21 + v14;
    v27 = v14 - v21;
    v28 = v22 + v12;
    v29 = v12 - v22;
    v30 = (int)v6[8] * (uint64_t)v7[8];
    v31 = (int)v6[24] * (uint64_t)v7[24];
    v32 = v7[40];
    v33 = v6[40];
    v34 = v7[56];
    v35 = v6[56];
    v36 = v30 + v33 * (uint64_t)v7[40];
    v37 = 11086 * (v30 + v31);
    v38 = 10217 * v36;
    v39 = 8956 * (v30 + v35 * (uint64_t)v34);
    v40 = 7350 * (v30 - v35 * (uint64_t)v34);
    v41 = 5461 * v36;
    v42 = 3363 * (v30 - v31);
    v43 = v37 - 18730 * v30 + 10217 * v36 + v39;
    v44 = v42 - 15038 * v30 + 5461 * v36 + v40;
    v45 = 1136 * (v31 + v33 * (uint64_t)v32);
    v46 = v31 + v35 * (uint64_t)v34;
    v47 = -5461 * v46;
    v48 = v37 + 589 * v31 + v45 - 5461 * v46;
    v49 = v33 * (uint64_t)v32;
    v50 = 11529 * (v49 - v31);
    v46 *= -10217;
    v51 = v42 + 16154 * v31 + v50 + v46;
    v52 = v45 - 9222 * v49 + v38 - 11086 * (v49 + v35 * (uint64_t)v34);
    v53 = v35 * (uint64_t)v34;
    v54 = v47 + 8728 * v53 + v39 - 11086 * (v49 + v53);
    v55 = v53 - v49;
    v56 = v46 + 25733 * v53 + v40 + 3363 * (v53 - v49);
    v57 = v41 + 3363 * v55;
    v58 = (_DWORD *)v116 + v5;
    v59 = v50 - 6278 * v49 + v57;
    *v58 = (unint64_t)(v43 + v23) >> 11;
    v58[120] = (unint64_t)(v23 - v43) >> 11;
    v58[8] = (unint64_t)(v48 + v24) >> 11;
    v58[112] = (unint64_t)(v24 - v48) >> 11;
    v58[16] = (unint64_t)(v52 + v26) >> 11;
    v58[104] = (unint64_t)(v26 - v52) >> 11;
    v58[24] = (unint64_t)(v54 + v28) >> 11;
    v58[96] = (unint64_t)(v28 - v54) >> 11;
    v58[32] = (unint64_t)(v56 + v29) >> 11;
    v58[88] = (unint64_t)(v29 - v56) >> 11;
    v58[40] = (unint64_t)(v59 + v27) >> 11;
    v58[80] = (unint64_t)(v27 - v59) >> 11;
    v58[48] = (unint64_t)(v51 + v25) >> 11;
    v58[72] = (unint64_t)(v25 - v51) >> 11;
    v58[56] = (unint64_t)(v44 + v115) >> 11;
    v58[64] = (unint64_t)(v115 - v44) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v60 = 0;
  v61 = v110 - 384;
  do
  {
    v62 = &v116[v60];
    v63 = v62[1];
    v64 = v62[4];
    v65 = v62[5];
    v66 = (*v62 << 13) + 134348800;
    v67 = 10703 * v64;
    v64 *= 4433;
    v68 = v66 + v67;
    v69 = v66 - v67;
    v71 = v62[2];
    v70 = v62[3];
    v72 = v66 + v64;
    v73 = v62[6];
    v74 = v62[7];
    v75 = 2260 * (v71 - v73);
    v76 = v66 - v64;
    LODWORD(v62) = 11363 * (v71 - v73);
    v77 = (_DWORD)v62 + 20995 * v73;
    v78 = v75 + 7373 * v71;
    v79 = (_DWORD)v62 - 4926 * v71;
    v80 = v75 - 4176 * v73;
    v81 = v77 + v68;
    LODWORD(v62) = v68 - v77;
    v82 = v78 + v72;
    v83 = v72 - v78;
    v84 = v79 + v76;
    result = (v76 - v79);
    v86 = 11086 * (v70 + v63);
    v87 = 10217 * (v65 + v63);
    v88 = 8956 * (v74 + v63);
    v89 = v80 + v69;
    v90 = 7350 * (v63 - v74);
    v91 = 5461 * (v65 + v63);
    v92 = 3363 * (v63 - v70);
    v93 = v69 - v80;
    v94 = v86 - 18730 * v63 + v87 + v88;
    v95 = v92 - 15038 * v63 + v91 + v90;
    v96 = 1136 * (v65 + v70);
    v97 = v96 - 9222 * v65;
    v98 = v86 + 589 * v70 + v96 - 5461 * (v74 + v70);
    v99 = v97 + v87 - 11086 * (v74 + v65);
    v100 = -5461 * (v74 + v70) + 8728 * v74 + v88 - 11086 * (v74 + v65);
    v101 = (_BYTE *)(*(_QWORD *)(a4 + v60 * 4) + a5);
    *v101 = *(_BYTE *)(v61 + (((unint64_t)(v94 + v81) >> 18) & 0x3FF));
    v101[15] = *(_BYTE *)(v61 + (((unint64_t)(v81 - v94) >> 18) & 0x3FF));
    v101[1] = *(_BYTE *)(v61 + (((unint64_t)(v98 + v82) >> 18) & 0x3FF));
    v102 = -10217 * (v74 + v70);
    v103 = v102 + 25733 * v74;
    v104 = 3363 * (v74 - v65);
    v105 = v103 + v90 + v104;
    v101[14] = *(_BYTE *)(v61 + (((unint64_t)(v82 - v98) >> 18) & 0x3FF));
    v101[2] = *(_BYTE *)(v61 + (((unint64_t)(v99 + v84) >> 18) & 0x3FF));
    v101[13] = *(_BYTE *)(v61 + (((unint64_t)(v84 - v99) >> 18) & 0x3FF));
    v101[3] = *(_BYTE *)(v61 + (((unint64_t)(v100 + v89) >> 18) & 0x3FF));
    v101[12] = *(_BYTE *)(v61 + (((unint64_t)(v89 - v100) >> 18) & 0x3FF));
    v101[4] = *(_BYTE *)(v61 + (((unint64_t)(v105 + v93) >> 18) & 0x3FF));
    v106 = v92 + 16154 * v70;
    v107 = 11529 * (v65 - v70);
    v108 = v107 - 6278 * v65 + v91 + v104;
    v101[11] = *(_BYTE *)(v61 + (((unint64_t)(v93 - v105) >> 18) & 0x3FF));
    v101[5] = *(_BYTE *)(v61 + (((unint64_t)(v108 + result) >> 18) & 0x3FF));
    v109 = v106 + v107 + v102;
    v101[10] = *(_BYTE *)(v61 + (((unint64_t)(result - v108) >> 18) & 0x3FF));
    v101[6] = *(_BYTE *)(v61 + (((unint64_t)(v109 + v83) >> 18) & 0x3FF));
    v101[9] = *(_BYTE *)(v61 + (((unint64_t)(v83 - v109) >> 18) & 0x3FF));
    v101[7] = *(_BYTE *)(v61 + (((unint64_t)(v95 + (_DWORD)v62) >> 18) & 0x3FF));
    v101[8] = *(_BYTE *)(v61 + (((unint64_t)((_DWORD)v62 - v95) >> 18) & 0x3FF));
    v60 += 2;
  }
  while (v60 != 32);
  return result;
}

uint64_t jpeg_idct_16x8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  __int16 *v6;
  uint64_t v7;
  unsigned int v8;
  _DWORD *v9;
  unsigned __int16 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  unint64_t v38;
  uint64_t v39;
  _DWORD *v40;
  uint64_t v41;
  uint64_t v42;
  _DWORD *v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t result;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  _BYTE *v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  uint64_t v91;
  _OWORD v94[16];
  uint64_t v95;

  v5 = 0;
  v95 = *MEMORY[0x1E0C80C00];
  v91 = *(_QWORD *)(a1 + 440);
  v6 = (__int16 *)(a3 + 64);
  v7 = *(_QWORD *)(a2 + 88) + 128;
  v8 = 9;
  memset(v94, 0, sizeof(v94));
  do
  {
    v9 = (_DWORD *)(v7 + v5);
    v10 = *(v6 - 16);
    if ((unsigned __int16)*(v6 - 24) | v10)
      goto LABEL_9;
    if (*(v6 - 8) || *v6 || v6[8] || v6[16] || v6[24])
    {
      v10 = 0;
LABEL_9:
      v11 = *v9 * *v6;
      v12 = ((uint64_t)(*(v9 - 32) * *(v6 - 32)) << 13) | 0x400;
      v13 = v12 + (v11 << 13);
      v14 = v12 - (v11 << 13);
      v15 = (int)*(v9 - 16) * (uint64_t)(__int16)v10;
      v16 = (int)v9[16] * (uint64_t)v6[16];
      v17 = 4433 * (v15 + v16);
      v18 = v17 + 6270 * v15;
      v19 = v17 - 15137 * v16;
      v20 = v18 + v13;
      v21 = v13 - v18;
      v22 = v19 + v14;
      v23 = v14 - v19;
      v24 = (int)v9[24] * (uint64_t)v6[24];
      v25 = (int)v9[8] * (uint64_t)v6[8];
      v26 = (int)*(v9 - 8) * (uint64_t)*(v6 - 8);
      v27 = (int)*(v9 - 24) * (uint64_t)*(v6 - 24);
      v28 = 9633 * (v25 + v27 + v24 + v26);
      v29 = v28 - 16069 * (v24 + v26);
      v30 = v28 - 3196 * (v25 + v27);
      v31 = -7373 * (v24 + v27);
      v32 = v31 + 2446 * v24 + v29;
      v33 = v31 + 12299 * v27 + v30;
      v34 = -20995 * (v25 + v26);
      v35 = v34 + 16819 * v25 + v30;
      v36 = v34 + 25172 * v26 + v29;
      v37 = (_DWORD *)((char *)v94 + v5);
      *v37 = (unint64_t)(v33 + v20) >> 11;
      v37[56] = (unint64_t)(v20 - v33) >> 11;
      v37[8] = (unint64_t)(v36 + v22) >> 11;
      v37[48] = (unint64_t)(v22 - v36) >> 11;
      v37[16] = (unint64_t)(v35 + v23) >> 11;
      v37[40] = (unint64_t)(v23 - v35) >> 11;
      v37[24] = (unint64_t)(v32 + v21) >> 11;
      v38 = (unint64_t)(v21 - v32) >> 11;
      v39 = 8;
      goto LABEL_10;
    }
    LODWORD(v38) = 4 * *(v6 - 32) * *(v9 - 32);
    v40 = (_DWORD *)((char *)v94 + v5);
    *v40 = v38;
    v40[8] = v38;
    v40[16] = v38;
    v40[24] = v38;
    v40[32] = v38;
    v40[40] = v38;
    v40[48] = v38;
    v39 = 14;
LABEL_10:
    *(_DWORD *)((char *)&v94[v39] + v5) = v38;
    --v8;
    v5 += 4;
    ++v6;
  }
  while (v8 > 1);
  v41 = 0;
  v42 = v91 - 384;
  do
  {
    v43 = &v94[v41];
    v44 = v43[1];
    v45 = v43[4];
    v46 = v43[5];
    v47 = (*v43 << 13) + 134348800;
    v48 = 10703 * v45;
    v45 *= 4433;
    v49 = v47 + v48;
    v50 = v47 - v48;
    v52 = v43[2];
    v51 = v43[3];
    v53 = v47 + v45;
    v54 = v43[6];
    v55 = v43[7];
    v56 = 2260 * (v52 - v54);
    v57 = v47 - v45;
    LODWORD(v43) = 11363 * (v52 - v54);
    v58 = (_DWORD)v43 + 20995 * v54;
    v59 = v56 + 7373 * v52;
    v60 = (_DWORD)v43 - 4926 * v52;
    v61 = v56 - 4176 * v54;
    v62 = v58 + v49;
    LODWORD(v43) = v49 - v58;
    v63 = v59 + v53;
    v64 = v53 - v59;
    v65 = v60 + v57;
    result = (v57 - v60);
    v67 = 11086 * (v51 + v44);
    v68 = 10217 * (v46 + v44);
    v69 = 8956 * (v55 + v44);
    v70 = v61 + v50;
    v71 = 7350 * (v44 - v55);
    v72 = 5461 * (v46 + v44);
    v73 = 3363 * (v44 - v51);
    v74 = v50 - v61;
    v75 = v67 - 18730 * v44 + v68 + v69;
    v76 = v73 - 15038 * v44 + v72 + v71;
    v77 = 1136 * (v46 + v51);
    v78 = v77 - 9222 * v46;
    v79 = v67 + 589 * v51 + v77 - 5461 * (v55 + v51);
    v80 = v78 + v68 - 11086 * (v55 + v46);
    v81 = -5461 * (v55 + v51) + 8728 * v55 + v69 - 11086 * (v55 + v46);
    v82 = (_BYTE *)(*(_QWORD *)(a4 + v41 * 4) + a5);
    *v82 = *(_BYTE *)(v42 + (((unint64_t)(v75 + v62) >> 18) & 0x3FF));
    v82[15] = *(_BYTE *)(v42 + (((unint64_t)(v62 - v75) >> 18) & 0x3FF));
    v82[1] = *(_BYTE *)(v42 + (((unint64_t)(v79 + v63) >> 18) & 0x3FF));
    v83 = -10217 * (v55 + v51);
    v84 = v83 + 25733 * v55;
    v85 = 3363 * (v55 - v46);
    v86 = v84 + v71 + v85;
    v82[14] = *(_BYTE *)(v42 + (((unint64_t)(v63 - v79) >> 18) & 0x3FF));
    v82[2] = *(_BYTE *)(v42 + (((unint64_t)(v80 + v65) >> 18) & 0x3FF));
    v82[13] = *(_BYTE *)(v42 + (((unint64_t)(v65 - v80) >> 18) & 0x3FF));
    v82[3] = *(_BYTE *)(v42 + (((unint64_t)(v81 + v70) >> 18) & 0x3FF));
    v82[12] = *(_BYTE *)(v42 + (((unint64_t)(v70 - v81) >> 18) & 0x3FF));
    v82[4] = *(_BYTE *)(v42 + (((unint64_t)(v86 + v74) >> 18) & 0x3FF));
    v87 = v73 + 16154 * v51;
    v88 = 11529 * (v46 - v51);
    v89 = v88 - 6278 * v46 + v72 + v85;
    v82[11] = *(_BYTE *)(v42 + (((unint64_t)(v74 - v86) >> 18) & 0x3FF));
    v82[5] = *(_BYTE *)(v42 + (((unint64_t)(v89 + result) >> 18) & 0x3FF));
    v90 = v87 + v88 + v83;
    v82[10] = *(_BYTE *)(v42 + (((unint64_t)(result - v89) >> 18) & 0x3FF));
    v82[6] = *(_BYTE *)(v42 + (((unint64_t)(v90 + v64) >> 18) & 0x3FF));
    v82[9] = *(_BYTE *)(v42 + (((unint64_t)(v64 - v90) >> 18) & 0x3FF));
    v82[7] = *(_BYTE *)(v42 + (((unint64_t)(v76 + (_DWORD)v43) >> 18) & 0x3FF));
    v82[8] = *(_BYTE *)(v42 + (((unint64_t)((_DWORD)v43 - v76) >> 18) & 0x3FF));
    v41 += 2;
  }
  while (v41 != 16);
  return result;
}

uint64_t jpeg_idct_14x7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  _BYTE *v62;
  int v63;
  int v64;
  uint64_t result;
  int v66;
  int v67;
  int v68;
  uint64_t v69;
  _OWORD v72[14];
  uint64_t v73;

  v5 = 0;
  v73 = *MEMORY[0x1E0C80C00];
  v69 = *(_QWORD *)(a1 + 440);
  memset(v72, 0, sizeof(v72));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)v72 + v5;
    v8 = (_DWORD *)(v6 + 4 * v5);
    v9 = (__int16 *)(a3 + 2 * v5);
    v10 = ((uint64_t)(*v8 * *v9) << 13) | 0x400;
    v11 = (int)v8[16] * (uint64_t)v9[16];
    v12 = (int)v8[32] * (uint64_t)v9[32];
    v13 = (int)v8[48] * (uint64_t)v9[48];
    v14 = 7223 * (v12 - v13);
    v15 = 2578 * (v11 - v12);
    v16 = v10 - 15083 * v12 + v15 + v14;
    v17 = v10 + 10438 * (v11 + v13);
    v18 = v14 - 637 * v13 + v17;
    v19 = v15 - 20239 * v11 + v17;
    v20 = v10 + 11585 * (v12 - (v11 + v13));
    v21 = (int)v8[8] * (uint64_t)v9[8];
    v22 = (int)v8[24] * (uint64_t)v9[24];
    v23 = (int)v8[40] * (uint64_t)v9[40];
    v24 = 7663 * (v21 + v22);
    v25 = 1395 * (v21 - v22);
    v26 = v24 - v25;
    v27 = v24 + v25 - 11295 * (v22 + v23);
    v28 = 5027 * (v21 + v23);
    v29 = v28 + v26;
    v30 = v28 + 15326 * v23 - 11295 * (v22 + v23);
    *v7 = (unint64_t)(v29 + v18) >> 11;
    v7[48] = (unint64_t)(v18 - v29) >> 11;
    v7[8] = (unint64_t)(v27 + v16) >> 11;
    v7[40] = (unint64_t)(v16 - v27) >> 11;
    v7[16] = (unint64_t)(v30 + v19) >> 11;
    v7[32] = (unint64_t)(v19 - v30) >> 11;
    v7[24] = v20 >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v31 = 0;
  v32 = v69 - 384;
  do
  {
    v33 = &v72[v31];
    v34 = v33[1];
    v35 = (*v33 << 13) + 134348800;
    v36 = v33[4];
    v37 = v33[5];
    v38 = v35 + 10438 * v36;
    v39 = v35 + 2578 * v36;
    v40 = v35 - 7223 * v36;
    v42 = v33[2];
    v41 = v33[3];
    v43 = v33[6];
    v44 = v33[7];
    v45 = v35 - 11586 * v36;
    LODWORD(v33) = 9058 * (v43 + v42);
    v46 = (_DWORD)v33 + 2237 * v42;
    v47 = (_DWORD)v33 - 14084 * v43;
    LODWORD(v33) = 5027 * v42 - 11295 * v43;
    v48 = v46 + v38;
    v49 = v38 - v46;
    v50 = (_DWORD)v33 + v40;
    LODWORD(v33) = v40 - (_DWORD)v33;
    v51 = v47 + v39;
    v52 = 10935 * (v41 + v34);
    v53 = 9810 * (v37 + v34);
    v54 = v52 - 9232 * v34 + v53 + (v44 << 13);
    v55 = v39 - v47;
    v56 = -1297 * (v37 + v41) - (v44 << 13);
    v57 = v52 - 3474 * v41 + v56;
    v58 = v53 - 19447 * v37 + v56;
    v59 = -13850 * v37 + (v44 << 13);
    v60 = 3826 * (v34 - v41) - (v44 << 13);
    v61 = v34 - v41 - v37 + v44;
    v62 = (_BYTE *)(*(_QWORD *)(a4 + v31 * 4) + a5);
    *v62 = *(_BYTE *)(v32 + (((unint64_t)(v54 + v48) >> 18) & 0x3FF));
    v62[13] = *(_BYTE *)(v32 + (((unint64_t)(v48 - v54) >> 18) & 0x3FF));
    v62[1] = *(_BYTE *)(v32 + (((unint64_t)(v57 + v51) >> 18) & 0x3FF));
    v62[12] = *(_BYTE *)(v32 + (((unint64_t)(v51 - v57) >> 18) & 0x3FF));
    v62[2] = *(_BYTE *)(v32 + (((unint64_t)(v58 + v50) >> 18) & 0x3FF));
    v63 = 6164 * (v37 + v34);
    v64 = 11512 * (v37 - v41);
    LOBYTE(v48) = *(_BYTE *)(v32 + (((unint64_t)(v50 - v58) >> 18) & 0x3FF));
    result = 4294958603;
    v66 = v63 - 8693 * v34;
    v62[11] = v48;
    v67 = v59 + v64 + v63;
    v62[3] = *(_BYTE *)(v32 + (((unint64_t)(v45 + (v61 << 13)) >> 18) & 0x3FF));
    v62[10] = *(_BYTE *)(v32 + (((unint64_t)(v45 - (v61 << 13)) >> 18) & 0x3FF));
    v62[4] = *(_BYTE *)(v32 + (((unint64_t)(v67 + (_DWORD)v33) >> 18) & 0x3FF));
    v68 = v64 + 5529 * v41 + v60;
    v62[9] = *(_BYTE *)(v32 + (((unint64_t)((_DWORD)v33 - v67) >> 18) & 0x3FF));
    v62[5] = *(_BYTE *)(v32 + (((unint64_t)(v68 + v55) >> 18) & 0x3FF));
    v62[8] = *(_BYTE *)(v32 + (((unint64_t)(v55 - v68) >> 18) & 0x3FF));
    v62[6] = *(_BYTE *)(v32 + (((unint64_t)(v66 + v60 + v49) >> 18) & 0x3FF));
    v62[7] = *(_BYTE *)(v32 + (((unint64_t)(v49 - (v66 + v60)) >> 18) & 0x3FF));
    v31 += 2;
  }
  while (v31 != 14);
  return result;
}

uint64_t jpeg_idct_12x6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  _BYTE *v52;
  unint64_t v53;
  uint64_t result;
  int v55;
  int v56;
  int v57;
  int v58;
  _OWORD v59[12];
  uint64_t v60;

  v5 = 0;
  v60 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  memset(v59, 0, sizeof(v59));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)v59 + v5;
    v9 = (_DWORD *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    v12 = (int)v9[32] * (uint64_t)v10[32];
    v13 = v11 + 5793 * v12;
    v14 = (unint64_t)(v11 - 11586 * v12) >> 11;
    v15 = 10033 * (int)v9[16] * (uint64_t)v10[16];
    v16 = v15 + v13;
    v17 = v13 - v15;
    v18 = (int)v9[8] * (uint64_t)v10[8];
    v19 = (int)v9[24] * (uint64_t)v10[24];
    v20 = (int)v9[40] * (uint64_t)v10[40];
    v21 = 2998 * (v18 + v20);
    v22 = v21 + ((v18 + v19) << 13);
    v23 = v21 + ((v20 - v19) << 13);
    LODWORD(v18) = v18 - (v19 + v20);
    *v8 = (unint64_t)(v22 + v16) >> 11;
    v8[40] = (unint64_t)(v16 - v22) >> 11;
    v8[8] = v14 + 4 * v18;
    v8[32] = v14 - 4 * v18;
    v8[16] = (unint64_t)(v23 + v17) >> 11;
    v8[24] = (unint64_t)(v17 - v23) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v24 = 0;
  v25 = v6 - 384;
  do
  {
    v26 = &v59[v24];
    v27 = v26[1];
    v28 = (*v26 << 13) + 134348800;
    v29 = v26[5];
    v30 = 10033 * v26[4];
    v31 = v28 + v30;
    v33 = v26[2];
    v32 = v26[3];
    v34 = v26[6];
    v35 = v26[7];
    v36 = v28 - v30;
    v37 = v28 + ((v33 - v34) << 13);
    v38 = v28 - ((v33 - v34) << 13);
    v39 = 11190 * v33 + (v34 << 13);
    v40 = v39 + v31;
    LODWORD(v26) = v31 - v39;
    v41 = 2998 * v33 - (v34 << 13);
    v42 = 10703 * v32;
    v43 = -4433 * v32;
    v44 = v41 + v36;
    v45 = 7053 * (v29 + v27 + v35);
    v46 = v45 + 2139 * (v29 + v27);
    v47 = v36 - v41;
    v48 = 10703 * v32 + 2295 * v27 + v46;
    v49 = -8565 * (v35 + v29);
    v50 = -4433 * v32 - 12112 * v29 - 8565 * (v35 + v29) + v46;
    v51 = v32 - v29;
    v52 = (_BYTE *)(*(_QWORD *)(a4 + v24 * 4) + a5);
    *v52 = *(_BYTE *)(v25 + (((unint64_t)(v48 + v40) >> 18) & 0x3FF));
    v53 = (v40 - v48);
    result = (4433 * (v27 - v35 + v51));
    v55 = result + 6270 * (v27 - v35);
    v52[11] = *(_BYTE *)(v25 + ((v53 >> 18) & 0x3FF));
    v52[1] = *(_BYTE *)(v25 + (((unint64_t)(v55 + v37) >> 18) & 0x3FF));
    v56 = 12998 * v35 - v42 + v45 + v49;
    v52[10] = *(_BYTE *)(v25 + (((unint64_t)(v37 - v55) >> 18) & 0x3FF));
    v52[2] = *(_BYTE *)(v25 + (((unint64_t)(v50 + v44) >> 18) & 0x3FF));
    v52[9] = *(_BYTE *)(v25 + (((unint64_t)(v44 - v50) >> 18) & 0x3FF));
    v57 = v43 - 5540 * v27 - 16244 * v35 + v45;
    v52[3] = *(_BYTE *)(v25 + (((unint64_t)(v56 + v47) >> 18) & 0x3FF));
    v58 = result - 15137 * v51;
    v52[8] = *(_BYTE *)(v25 + (((unint64_t)(v47 - v56) >> 18) & 0x3FF));
    v52[4] = *(_BYTE *)(v25 + (((unint64_t)(v58 + v38) >> 18) & 0x3FF));
    v52[7] = *(_BYTE *)(v25 + (((unint64_t)(v38 - v58) >> 18) & 0x3FF));
    v52[5] = *(_BYTE *)(v25 + (((unint64_t)(v57 + (_DWORD)v26) >> 18) & 0x3FF));
    v52[6] = *(_BYTE *)(v25 + (((unint64_t)((_DWORD)v26 - v57) >> 18) & 0x3FF));
    v24 += 2;
  }
  while (v24 != 12);
  return result;
}

uint64_t jpeg_idct_10x5(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t result;
  _DWORD *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  _BYTE *v49;
  int v50;
  int v51;
  unint64_t v52;
  unint64_t v53;
  int v54;
  int v55;
  _OWORD v56[10];
  uint64_t v57;

  v5 = 0;
  v57 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  memset(v56, 0, sizeof(v56));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)v56 + v5;
    v9 = (_DWORD *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    v12 = (int)v9[16] * (uint64_t)v10[16];
    v13 = v9[32];
    v14 = 6476 * (v12 + v13 * (uint64_t)v10[32]);
    v15 = v12 - v13 * (uint64_t)v10[32];
    v16 = v11 + 2896 * v15;
    v17 = v16 + v14;
    v18 = v16 - v14;
    v19 = v11 + 0x7FFFFFFD2C0 * v15;
    v20 = (int)v9[8] * (uint64_t)v10[8];
    v21 = (int)v9[24] * (uint64_t)v10[24];
    v22 = 6810 * (v20 + v21);
    v23 = v22 + 4209 * v20;
    v24 = v22 - 17828 * v21;
    *v8 = (unint64_t)(v23 + v17) >> 11;
    v8[32] = (unint64_t)(v17 - v23) >> 11;
    v8[8] = (unint64_t)(v24 + v18) >> 11;
    v8[24] = (unint64_t)(v18 - v24) >> 11;
    v8[16] = v19 >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v25 = 0;
  v26 = v6 - 384;
  result = 2531;
  do
  {
    v28 = &v56[v25];
    v29 = v28[1];
    v30 = v28[4];
    v31 = v28[5];
    v32 = (*v28 << 13) + 134348800;
    v33 = v32 + 9373 * v30;
    v34 = v32 - 3580 * v30;
    v36 = v28[2];
    v35 = v28[3];
    v37 = v32 - 11586 * v30;
    v39 = v28[6];
    v38 = v28[7];
    LODWORD(v28) = 6810 * (v39 + v36);
    v40 = (_DWORD)v28 + 4209 * v36;
    v41 = (_DWORD)v28 - 17828 * v39;
    v42 = v40 + v33;
    LODWORD(v28) = v33 - v40;
    v43 = v41 + v34;
    v44 = v38 + v35;
    v45 = v35 - v38;
    v46 = v34 - v41;
    v47 = 2531 * v45 + (v31 << 13);
    v48 = 7791 * v44 + 11443 * v29 + v47;
    v49 = (_BYTE *)(*(_QWORD *)(a4 + v25 * 4) + a5);
    v50 = 1812 * v29 - 7791 * v44 + v47;
    v51 = 4815 * v44;
    v52 = (v48 + v42);
    v53 = (v42 - v48);
    v54 = -6627 * v45 + (v31 << 13);
    *v49 = *(_BYTE *)(v26 + ((v52 >> 18) & 0x3FF));
    LODWORD(v52) = 10323 * v29 - (v51 + v54);
    v49[9] = *(_BYTE *)(v26 + ((v53 >> 18) & 0x3FF));
    v55 = v29 - v31 - v45;
    v49[1] = *(_BYTE *)(v26 + (((unint64_t)(v52 + v43) >> 18) & 0x3FF));
    v49[8] = *(_BYTE *)(v26 + (((unint64_t)(v43 - v52) >> 18) & 0x3FF));
    v49[2] = *(_BYTE *)(v26 + (((unint64_t)(v37 + (v55 << 13)) >> 18) & 0x3FF));
    LODWORD(v53) = 5260 * v29 - v51 + v54;
    v49[7] = *(_BYTE *)(v26 + (((unint64_t)(v37 - (v55 << 13)) >> 18) & 0x3FF));
    v49[3] = *(_BYTE *)(v26 + (((unint64_t)(v53 + v46) >> 18) & 0x3FF));
    v49[6] = *(_BYTE *)(v26 + (((unint64_t)(v46 - v53) >> 18) & 0x3FF));
    v49[4] = *(_BYTE *)(v26 + (((unint64_t)(v50 + (_DWORD)v28) >> 18) & 0x3FF));
    v49[5] = *(_BYTE *)(v26 + (((unint64_t)((_DWORD)v28 - v50) >> 18) & 0x3FF));
    v25 += 2;
  }
  while (v25 != 10);
  return result;
}

uint64_t jpeg_idct_8x4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t result;
  _DWORD *v24;
  _BYTE *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  unint64_t v48;
  int v49;
  unint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  _OWORD v56[8];
  uint64_t v57;

  v5 = 0;
  v57 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  memset(v56, 0, sizeof(v56));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)v56 + v5;
    v9 = (_DWORD *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = *v9 * *v10;
    v12 = v9[16] * v10[16];
    v13 = v12 + v11;
    v14 = 4 * (v12 + v11);
    v15 = v11 - v12;
    v16 = (int)v9[8] * (uint64_t)v10[8];
    v17 = (int)v9[24] * (uint64_t)v10[24];
    v18 = 4433 * (v16 + v17) + 1024;
    v19 = (unint64_t)(v18 + 6270 * v16) >> 11;
    v20 = (unint64_t)(v18 - 15137 * v17) >> 11;
    *v8 = v19 + 4 * v13;
    v8[24] = v14 - v19;
    v8[8] = v20 + 4 * v15;
    v8[16] = 4 * v15 - v20;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v21 = 0;
  v22 = v6 - 384;
  result = 4294959923;
  do
  {
    v24 = &v56[v21];
    v25 = (_BYTE *)(*(_QWORD *)(a4 + v21 * 4) + a5);
    v26 = v24[1];
    v27 = *v24 + 16400;
    v28 = v24[4];
    v29 = v24[5];
    v30 = v27 + v28;
    v31 = v27 - v28;
    v32 = v24[6];
    v33 = v24[7];
    v34 = v30 << 13;
    v35 = v24[2];
    LODWORD(v24) = v24[3];
    v36 = 4433 * (v32 + v35);
    v37 = v36 + 6270 * v35;
    v38 = v36 - 15137 * v32;
    v39 = (_DWORD)v24 + v33;
    v40 = 9633 * (v26 + v29 + (_DWORD)v24 + v33);
    v41 = v37 + (v30 << 13);
    v42 = v40 - 3196 * (v26 + v29);
    v43 = -7373 * (v26 + v33);
    v44 = v43 + 12299 * v26 + v42;
    v45 = v43 + 2446 * v33;
    v46 = -20995 * ((_DWORD)v24 + v29);
    v47 = v46 + 16819 * v29;
    LODWORD(v24) = v46 + 25172 * (_DWORD)v24;
    v48 = (v44 + v41);
    v49 = v40 - 16069 * v39;
    v50 = (v41 - v44);
    v51 = v31 << 13;
    *v25 = *(_BYTE *)(v22 + ((v48 >> 18) & 0x3FF));
    v52 = v38 + (v31 << 13);
    LODWORD(v24) = (_DWORD)v24 + v49;
    v53 = v51 - v38;
    v25[7] = *(_BYTE *)(v22 + ((v50 >> 18) & 0x3FF));
    v54 = v47 + v42;
    v25[1] = *(_BYTE *)(v22 + (((unint64_t)((_DWORD)v24 + v52) >> 18) & 0x3FF));
    v25[6] = *(_BYTE *)(v22 + (((unint64_t)(v52 - (_DWORD)v24) >> 18) & 0x3FF));
    v55 = v45 + v49;
    v25[2] = *(_BYTE *)(v22 + (((unint64_t)(v54 + v53) >> 18) & 0x3FF));
    v25[5] = *(_BYTE *)(v22 + (((unint64_t)(v53 - v54) >> 18) & 0x3FF));
    v25[3] = *(_BYTE *)(v22 + (((unint64_t)(v55 + v34 - v37) >> 18) & 0x3FF));
    v25[4] = *(_BYTE *)(v22 + (((unint64_t)(v34 - v37 - v55) >> 18) & 0x3FF));
    v21 += 2;
  }
  while (v21 != 8);
  return result;
}

uint64_t jpeg_idct_6x3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t result;
  _OWORD v34[4];
  uint64_t v35;
  uint64_t v36;

  v5 = 0;
  v36 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  v35 = 0;
  memset(v34, 0, sizeof(v34));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)v34 + v5;
    v9 = (_DWORD *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    v12 = (int)v9[16] * (uint64_t)v10[16];
    v13 = v11 + 5793 * v12;
    v14 = 10033 * (int)v9[8] * (uint64_t)v10[8];
    *v8 = (unint64_t)(v14 + v13) >> 11;
    v8[12] = (unint64_t)(v13 - v14) >> 11;
    v8[6] = (unint64_t)(v11 + 0x7FFFFFFD2BELL * v12) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 6);
  v15 = 0;
  v16 = v6 - 384;
  v17 = a5;
  do
  {
    v18 = *a4++;
    v19 = (_BYTE *)(v18 + v17);
    v20 = *(_DWORD *)((char *)v34 + v15 + 4);
    v21 = *(_DWORD *)((char *)&v34[1] + v15);
    v22 = *(_DWORD *)((char *)&v34[1] + v15 + 4);
    v23 = (*(_DWORD *)((char *)v34 + v15) << 13) + 134348800;
    v24 = v23 + 5793 * v21;
    v25 = *(_DWORD *)((char *)v34 + v15 + 12);
    v26 = 10033 * *(_DWORD *)((char *)v34 + v15 + 8);
    v27 = 2998 * (v22 + v20);
    v28 = v27 + ((v25 + v20) << 13);
    v29 = v22 - v25;
    v30 = v20 - (v25 + v22);
    v31 = v23 - 11586 * v21;
    *v19 = *(_BYTE *)(v16 + (((unint64_t)(v28 + v24 + v26) >> 18) & 0x3FF));
    v32 = v27 + (v29 << 13);
    v19[5] = *(_BYTE *)(v16 + (((unint64_t)(v24 + v26 - v28) >> 18) & 0x3FF));
    v19[1] = *(_BYTE *)(v16 + (((unint64_t)(v31 + (v30 << 13)) >> 18) & 0x3FF));
    v19[4] = *(_BYTE *)(v16 + (((unint64_t)(v31 - (v30 << 13)) >> 18) & 0x3FF));
    v19[2] = *(_BYTE *)(v16 + (((unint64_t)(v32 + v24 - v26) >> 18) & 0x3FF));
    result = *(unsigned __int8 *)(v16 + (((unint64_t)(v24 - v26 - v32) >> 18) & 0x3FF));
    v19[3] = result;
    v15 += 24;
  }
  while (v15 != 72);
  return result;
}

uint64_t jpeg_idct_4x2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  int *v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unint64_t v25;
  int v26;
  uint64_t result;
  _OWORD v28[4];
  uint64_t v29;

  v5 = 0;
  v29 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  memset(v28, 0, sizeof(v28));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_QWORD *)v28 + v5;
    v9 = (int *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = *v9 * (uint64_t)*v10;
    LODWORD(v10) = v10[8];
    LODWORD(v9) = v9[8];
    *v8 = v11 + (int)v9 * (uint64_t)(int)v10;
    v8[4] = v11 - (int)v9 * (uint64_t)(int)v10;
    ++v5;
  }
  while ((_DWORD)v5 != 4);
  v12 = 0;
  v13 = v6 - 384;
  v14 = v28;
  v15 = 1;
  v16 = a5;
  do
  {
    v17 = (_BYTE *)(*(_QWORD *)(a4 + 8 * v12) + v16);
    v18 = *v14 + 4100;
    v19 = v14[4];
    v20 = v14[2];
    v21 = v14[6];
    v22 = 4433 * (v21 + v20);
    v23 = v22 + 6270 * v20;
    v24 = v22 - 15137 * v21;
    *v17 = *(_BYTE *)(v13 + (((unint64_t)(v23 + ((v18 + v19) << 13)) >> 16) & 0x3FF));
    v25 = ((unint64_t)(((v18 + v19) << 13) - v23) >> 16) & 0x3FF;
    v26 = v18 - v19;
    v17[3] = *(_BYTE *)(v13 + v25);
    v17[1] = *(_BYTE *)(v13 + (((unint64_t)(v24 + (v26 << 13)) >> 16) & 0x3FF));
    result = v15;
    v17[2] = *(_BYTE *)(v13 + (((unint64_t)((v26 << 13) - v24) >> 16) & 0x3FF));
    v14 += 8;
    v12 = 1;
    v15 = 0;
  }
  while ((result & 1) != 0);
  return result;
}

uint64_t jpeg_idct_2x1(uint64_t result, uint64_t a2, unsigned __int16 *a3, _QWORD *a4, unsigned int a5)
{
  uint64_t v5;
  _DWORD *v6;
  _BYTE *v7;
  int v8;

  v5 = *(_QWORD *)(result + 440) - 384;
  v6 = *(_DWORD **)(a2 + 88);
  v7 = (_BYTE *)(*a4 + a5);
  v8 = *v6 * *a3 + 4100;
  LODWORD(v6) = v6[1] * a3[1];
  *v7 = *(_BYTE *)(v5 + (((unint64_t)((_DWORD)v6 + v8) >> 3) & 0x3FF));
  v7[1] = *(_BYTE *)(v5 + (((unint64_t)(v8 - (_DWORD)v6) >> 3) & 0x3FF));
  return result;
}

uint64_t jpeg_idct_8x16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  _DWORD *v6;
  __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _DWORD *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t result;
  _DWORD *v62;
  _BYTE *v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  unint64_t v86;
  int v87;
  unint64_t v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  uint64_t v94;
  uint64_t v97;
  uint64_t v99;
  _OWORD v100[32];
  uint64_t v101;

  v5 = 0;
  v101 = *MEMORY[0x1E0C80C00];
  v94 = *(_QWORD *)(a1 + 440);
  memset(v100, 0, sizeof(v100));
  v97 = *(_QWORD *)(a2 + 88);
  do
  {
    v6 = (_DWORD *)(v97 + 4 * v5);
    v7 = (__int16 *)(a3 + 2 * v5);
    v8 = (int)v6[32] * (uint64_t)v7[32];
    v9 = 10703 * v8;
    v10 = ((uint64_t)(*v6 * *v7) << 13) | 0x400;
    v8 *= 4433;
    v11 = v9 + v10;
    v12 = v10 - v9;
    v13 = v8 + v10;
    v14 = v10 - v8;
    v15 = (int)v6[16] * (uint64_t)v7[16];
    v16 = (int)v6[48] * (uint64_t)v7[48];
    v17 = 2260 * (v15 - v16);
    v18 = 11363 * (v15 - v16);
    v19 = v18 + 20995 * v16;
    v20 = v17 + 7373 * v15;
    v21 = v18 - 4926 * v15;
    v22 = v17 - 4176 * v16;
    v23 = v19 + v11;
    v99 = v11 - v19;
    v24 = v20 + v13;
    v25 = v13 - v20;
    v26 = v21 + v14;
    v27 = v14 - v21;
    v28 = v22 + v12;
    v29 = v12 - v22;
    v30 = (int)v6[8] * (uint64_t)v7[8];
    v31 = (int)v6[24] * (uint64_t)v7[24];
    LODWORD(v22) = v7[40];
    v32 = v6[40];
    v33 = v7[56];
    v34 = v6[56];
    v35 = v30 + v32 * (uint64_t)v7[40];
    v36 = 11086 * (v30 + v31);
    v37 = 10217 * v35;
    v38 = 8956 * (v30 + v34 * (uint64_t)v33);
    v39 = 7350 * (v30 - v34 * (uint64_t)v33);
    v40 = 5461 * v35;
    v41 = 3363 * (v30 - v31);
    v42 = v36 - 18730 * v30 + 10217 * v35 + v38;
    v43 = v41 - 15038 * v30 + 5461 * v35 + v39;
    v44 = 1136 * (v31 + v32 * (uint64_t)(int)v22);
    v45 = v31 + v34 * (uint64_t)v33;
    v46 = -5461 * v45;
    v47 = v36 + 589 * v31 + v44 - 5461 * v45;
    v48 = v32 * (uint64_t)(int)v22;
    v49 = 11529 * (v48 - v31);
    v45 *= -10217;
    v50 = v41 + 16154 * v31 + v49 + v45;
    v51 = v44 - 9222 * v48 + v37 - 11086 * (v48 + v34 * (uint64_t)v33);
    v52 = v38 - 11086 * (v48 + v34 * (uint64_t)v33);
    v53 = v34 * (uint64_t)v33;
    v54 = v46 + 8728 * v53 + v52;
    v55 = 3363 * (v53 - v48);
    v56 = v45 + 25733 * v53 + v39 + v55;
    v57 = (_DWORD *)v100 + v5;
    v58 = v49 - 6278 * v48 + v40 + v55;
    *v57 = (unint64_t)(v42 + v23) >> 11;
    v57[120] = (unint64_t)(v23 - v42) >> 11;
    v57[8] = (unint64_t)(v47 + v24) >> 11;
    v57[112] = (unint64_t)(v24 - v47) >> 11;
    v57[16] = (unint64_t)(v51 + v26) >> 11;
    v57[104] = (unint64_t)(v26 - v51) >> 11;
    v57[24] = (unint64_t)(v54 + v28) >> 11;
    v57[96] = (unint64_t)(v28 - v54) >> 11;
    v57[32] = (unint64_t)(v56 + v29) >> 11;
    v57[88] = (unint64_t)(v29 - v56) >> 11;
    v57[40] = (unint64_t)(v58 + v27) >> 11;
    v57[80] = (unint64_t)(v27 - v58) >> 11;
    v57[48] = (unint64_t)(v50 + v25) >> 11;
    v57[72] = (unint64_t)(v25 - v50) >> 11;
    v57[56] = (unint64_t)(v43 + v99) >> 11;
    v57[64] = (unint64_t)(v99 - v43) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 8);
  v59 = 0;
  v60 = v94 - 384;
  result = 4294959923;
  do
  {
    v62 = &v100[v59];
    v63 = (_BYTE *)(*(_QWORD *)(a4 + v59 * 4) + a5);
    v64 = v62[1];
    v65 = *v62 + 16400;
    v66 = v62[4];
    v67 = v62[5];
    v68 = v65 + v66;
    v69 = v65 - v66;
    v70 = v62[6];
    v71 = v62[7];
    v72 = v68 << 13;
    v73 = v62[2];
    LODWORD(v62) = v62[3];
    v74 = 4433 * (v70 + v73);
    v75 = v74 + 6270 * v73;
    v76 = v74 - 15137 * v70;
    v77 = (_DWORD)v62 + v71;
    v78 = 9633 * (v64 + v67 + (_DWORD)v62 + v71);
    v79 = v75 + (v68 << 13);
    v80 = v78 - 3196 * (v64 + v67);
    v81 = -7373 * (v64 + v71);
    v82 = v81 + 12299 * v64 + v80;
    v83 = v81 + 2446 * v71;
    v84 = -20995 * ((_DWORD)v62 + v67);
    v85 = v84 + 16819 * v67;
    LODWORD(v62) = v84 + 25172 * (_DWORD)v62;
    v86 = (v82 + v79);
    v87 = v78 - 16069 * v77;
    v88 = (v79 - v82);
    v89 = v69 << 13;
    *v63 = *(_BYTE *)(v60 + ((v86 >> 18) & 0x3FF));
    v90 = v76 + (v69 << 13);
    LODWORD(v62) = (_DWORD)v62 + v87;
    v91 = v89 - v76;
    v63[7] = *(_BYTE *)(v60 + ((v88 >> 18) & 0x3FF));
    v92 = v85 + v80;
    v63[1] = *(_BYTE *)(v60 + (((unint64_t)((_DWORD)v62 + v90) >> 18) & 0x3FF));
    v63[6] = *(_BYTE *)(v60 + (((unint64_t)(v90 - (_DWORD)v62) >> 18) & 0x3FF));
    v93 = v83 + v87;
    v63[2] = *(_BYTE *)(v60 + (((unint64_t)(v92 + v91) >> 18) & 0x3FF));
    v63[5] = *(_BYTE *)(v60 + (((unint64_t)(v91 - v92) >> 18) & 0x3FF));
    v63[3] = *(_BYTE *)(v60 + (((unint64_t)(v93 + v72 - v75) >> 18) & 0x3FF));
    v63[4] = *(_BYTE *)(v60 + (((unint64_t)(v72 - v75 - v93) >> 18) & 0x3FF));
    v59 += 2;
  }
  while (v59 != 32);
  return result;
}

uint64_t jpeg_idct_7x14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t result;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  _BYTE *v75;
  int v76;
  int v77;
  int v78;
  uint64_t v79;
  _OWORD v81[24];
  uint64_t v82;
  uint64_t v83;

  v5 = 0;
  v83 = *MEMORY[0x1E0C80C00];
  v79 = *(_QWORD *)(a1 + 440);
  v82 = 0;
  memset(v81, 0, sizeof(v81));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)(v6 + 4 * v5);
    v8 = (__int16 *)(a3 + 2 * v5);
    v9 = (int)v7[32] * (uint64_t)v8[32];
    v10 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    v11 = v10 + 10438 * v9;
    v12 = v10 + 2578 * v9;
    v13 = v10 - 7223 * v9;
    v14 = (int)v7[16] * (uint64_t)v8[16];
    v15 = (int)v7[48] * (uint64_t)v8[48];
    v16 = 9058 * (v14 + v15);
    v17 = v16 + 2237 * v14;
    v18 = v16 - 14084 * v15;
    v19 = 5027 * v14 - 11295 * v15;
    v20 = v17 + v11;
    v21 = v11 - v17;
    v22 = v18 + v12;
    v23 = v12 - v18;
    v24 = v19 + v13;
    v25 = v13 - v19;
    v26 = (int)v7[8] * (uint64_t)v8[8];
    v27 = (int)v7[24] * (uint64_t)v8[24];
    v28 = (int)v7[40] * (uint64_t)v8[40];
    v29 = (int)v7[56] * (uint64_t)v8[56];
    v30 = 10935 * (v26 + v27);
    v31 = 9810 * (v26 + v28);
    v32 = v30 - 9232 * v26 + v31;
    v33 = -1297 * (v27 + v28) - (v29 << 13);
    v34 = v30 - 3474 * v27 + v33;
    v35 = v31 - 19447 * v28 + v33;
    v36 = 6164 * (v26 + v28);
    v37 = v26 - v27;
    v38 = 11512 * (v28 - v27);
    v39 = v38 - 13850 * v28 + v36;
    v40 = v36 - 8693 * v26;
    v41 = v38 + 5529 * v27;
    v42 = 3826 * v37 - (v29 << 13);
    v43 = v40 + v42;
    v44 = v41 + v42;
    v45 = (_DWORD *)v81 + v5;
    v46 = v32 + (v29 << 13);
    v47 = v39 + (v29 << 13);
    LODWORD(v29) = v37 - v28 + v29;
    *v45 = (unint64_t)(v46 + v20) >> 11;
    v45[91] = (unint64_t)(v20 - v46) >> 11;
    v45[7] = (unint64_t)(v34 + v22) >> 11;
    v45[84] = (unint64_t)(v22 - v34) >> 11;
    v45[14] = (unint64_t)(v35 + v24) >> 11;
    v48 = (unint64_t)(v10 - 11586 * v9) >> 11;
    v45[77] = (unint64_t)(v24 - v35) >> 11;
    v45[21] = v48 + 4 * v29;
    v45[70] = v48 - 4 * v29;
    v45[28] = (unint64_t)(v47 + v25) >> 11;
    v45[63] = (unint64_t)(v25 - v47) >> 11;
    v45[35] = (unint64_t)(v44 + v23) >> 11;
    v45[56] = (unint64_t)(v23 - v44) >> 11;
    v45[42] = (unint64_t)(v43 + v21) >> 11;
    v45[49] = (unint64_t)(v21 - v43) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 7);
  v49 = 0;
  v50 = v79 - 384;
  result = 11585;
  do
  {
    v52 = *a4++;
    v53 = *(_DWORD *)((char *)v81 + v49 + 4);
    v54 = (*(_DWORD *)((char *)v81 + v49) << 13) + 134348800;
    v56 = *(_DWORD *)((char *)&v81[1] + v49 + 4);
    v55 = *(_DWORD *)((char *)&v81[1] + v49 + 8);
    v57 = *(_DWORD *)((char *)&v81[1] + v49);
    v58 = 7223 * (v57 - v55);
    v60 = *(_DWORD *)((char *)v81 + v49 + 8);
    v59 = *(_DWORD *)((char *)v81 + v49 + 12);
    v61 = 2578 * (v60 - v57);
    v62 = v61 + v58;
    v63 = v55 + v60;
    v64 = v58 - 637 * v55;
    v65 = 7663 * (v59 + v53);
    v66 = v61 - 20239 * v60;
    v67 = 1395 * (v53 - v59);
    v68 = v65 - v67;
    v69 = v65 + v67;
    v70 = v54 + 10438 * v63;
    v71 = v64 + v70;
    v72 = 5027 * (v56 + v53);
    v73 = v68 + v72;
    v74 = v54 - 15083 * v57 + v62;
    v75 = (_BYTE *)(v52 + a5);
    *v75 = *(_BYTE *)(v50 + (((unint64_t)(v73 + v71) >> 18) & 0x3FF));
    v76 = -11295 * (v56 + v59);
    v77 = v69 + v76;
    v75[6] = *(_BYTE *)(v50 + (((unint64_t)(v71 - v73) >> 18) & 0x3FF));
    v78 = v72 + 15326 * v56 + v76;
    v75[1] = *(_BYTE *)(v50 + (((unint64_t)(v77 + v74) >> 18) & 0x3FF));
    v75[5] = *(_BYTE *)(v50 + (((unint64_t)(v74 - v77) >> 18) & 0x3FF));
    v75[2] = *(_BYTE *)(v50 + (((unint64_t)(v78 + v66 + v70) >> 18) & 0x3FF));
    v75[4] = *(_BYTE *)(v50 + (((unint64_t)(v66 + v70 - v78) >> 18) & 0x3FF));
    v75[3] = *(_BYTE *)(v50 + (((unint64_t)(v54 + 11585 * (v57 - v63)) >> 18) & 0x3FF));
    v49 += 28;
  }
  while (v49 != 392);
  return result;
}

uint64_t jpeg_idct_6x12(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _BYTE *v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  uint64_t result;
  uint64_t v61;
  _OWORD v63[18];
  uint64_t v64;

  v5 = 0;
  v64 = *MEMORY[0x1E0C80C00];
  v61 = *(_QWORD *)(a1 + 440);
  memset(v63, 0, sizeof(v63));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)(v6 + 4 * v5);
    v8 = (__int16 *)(a3 + 2 * v5);
    v9 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    v10 = 10033 * (int)v7[32] * (uint64_t)v8[32];
    v11 = v10 + v9;
    v12 = v9 - v10;
    v13 = (int)v7[16] * (uint64_t)v8[16];
    v14 = (int)v7[48] * (uint64_t)v8[48];
    v15 = v9 + ((v13 - v14) << 13);
    v16 = v9 - ((v13 - v14) << 13);
    v17 = 11190 * v13 + (v14 << 13);
    v18 = v17 + v11;
    v19 = v11 - v17;
    v20 = 2998 * v13 - (v14 << 13);
    v21 = v20 + v12;
    v22 = v12 - v20;
    v23 = (int)v7[8] * (uint64_t)v8[8];
    v24 = (int)v7[24] * (uint64_t)v8[24];
    v25 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    v26 = 10703 * v24;
    v27 = -4433 * v24;
    v28 = 7053 * (v23 + v25 + (int)v7 * (uint64_t)(int)v8);
    v29 = v28 + 2139 * (v23 + v25);
    v30 = v24 - v25;
    v31 = v26 + 2295 * v23 + v29;
    v32 = -8565 * (v25 + (int)v7 * (uint64_t)(int)v8);
    v33 = v27 - 12112 * v25 - 8565 * (v25 + (int)v7 * (uint64_t)(int)v8) + v29;
    v34 = (int)v7 * (uint64_t)(int)v8;
    v35 = 12998 * v34 - v26 + v32;
    v36 = v23 - v34;
    v37 = (_DWORD *)v63 + v5;
    v38 = v35 + v28;
    v39 = v27 - 5540 * v23 - 16244 * v34 + v28;
    v40 = 4433 * (v36 + v30);
    v41 = v40 + 6270 * v36;
    v42 = v40 - 15137 * v30;
    *v37 = (unint64_t)(v31 + v18) >> 11;
    v37[66] = (unint64_t)(v18 - v31) >> 11;
    v37[6] = (unint64_t)(v41 + v15) >> 11;
    v37[60] = (unint64_t)(v15 - v41) >> 11;
    v37[12] = (unint64_t)(v33 + v21) >> 11;
    v37[54] = (unint64_t)(v21 - v33) >> 11;
    v37[18] = (unint64_t)(v38 + v22) >> 11;
    v37[48] = (unint64_t)(v22 - v38) >> 11;
    v37[24] = (unint64_t)(v42 + v16) >> 11;
    v37[42] = (unint64_t)(v16 - v42) >> 11;
    v37[30] = (unint64_t)(v39 + v19) >> 11;
    v37[36] = (unint64_t)(v19 - v39) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 6);
  v43 = 0;
  v44 = v61 - 384;
  do
  {
    v45 = *a4++;
    v46 = (_BYTE *)(v45 + a5);
    v47 = *(_DWORD *)((char *)v63 + v43 + 4);
    v48 = *(_DWORD *)((char *)&v63[1] + v43);
    v49 = *(_DWORD *)((char *)&v63[1] + v43 + 4);
    v50 = (*(_DWORD *)((char *)v63 + v43) << 13) + 134348800;
    v51 = v50 + 5793 * v48;
    v52 = *(_DWORD *)((char *)v63 + v43 + 12);
    v53 = 10033 * *(_DWORD *)((char *)v63 + v43 + 8);
    v54 = 2998 * (v49 + v47);
    v55 = v54 + ((v52 + v47) << 13);
    v56 = v49 - v52;
    v57 = v47 - (v52 + v49);
    v58 = v50 - 11586 * v48;
    *v46 = *(_BYTE *)(v44 + (((unint64_t)(v55 + v51 + v53) >> 18) & 0x3FF));
    v59 = v54 + (v56 << 13);
    v46[5] = *(_BYTE *)(v44 + (((unint64_t)(v51 + v53 - v55) >> 18) & 0x3FF));
    v46[1] = *(_BYTE *)(v44 + (((unint64_t)(v58 + (v57 << 13)) >> 18) & 0x3FF));
    v46[4] = *(_BYTE *)(v44 + (((unint64_t)(v58 - (v57 << 13)) >> 18) & 0x3FF));
    v46[2] = *(_BYTE *)(v44 + (((unint64_t)(v59 + v51 - v53) >> 18) & 0x3FF));
    result = *(unsigned __int8 *)(v44 + (((unint64_t)(v51 - v53 - v59) >> 18) & 0x3FF));
    v46[3] = result;
    v43 += 24;
  }
  while (v43 != 288);
  return result;
}

uint64_t jpeg_idct_5x10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t result;
  uint64_t v40;
  int v41;
  _BYTE *v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  _OWORD v57[12];
  uint64_t v58;
  uint64_t v59;

  v5 = 0;
  v59 = *MEMORY[0x1E0C80C00];
  v55 = *(_QWORD *)(a1 + 440);
  v58 = 0;
  memset(v57, 0, sizeof(v57));
  v6 = *(_QWORD *)(a2 + 88);
  do
  {
    v7 = (_DWORD *)(v6 + 4 * v5);
    v8 = (__int16 *)(a3 + 2 * v5);
    v9 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    v10 = (int)v7[32] * (uint64_t)v8[32];
    v11 = v9 + 9373 * v10;
    v12 = v9 - 3580 * v10;
    v13 = v9 - 11586 * v10;
    v14 = (int)v7[16] * (uint64_t)v8[16];
    v15 = (int)v7[48] * (uint64_t)v8[48];
    v16 = 6810 * (v14 + v15);
    v17 = v16 + 4209 * v14;
    v18 = v16 - 17828 * v15;
    v19 = v17 + v11;
    v20 = v11 - v17;
    v21 = v18 + v12;
    v22 = v12 - v18;
    v23 = (int)v7[8] * (uint64_t)v8[8];
    v24 = (int)v7[24] * (uint64_t)v8[24];
    v25 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    v26 = v24 + (int)v7 * (uint64_t)(int)v8;
    v27 = v24 - (int)v7 * (uint64_t)(int)v8;
    v28 = 2531 * v27 + (v25 << 13);
    v29 = 7791 * v26 + 11443 * v23 + v28;
    v30 = 1812 * v23 - 7791 * v26 + v28;
    v31 = 4815 * v26;
    v32 = -6627 * v27 + (v25 << 13);
    LODWORD(v27) = v23 - v25 - v27;
    v33 = 10323 * v23 - (v31 + v32);
    v34 = 5260 * v23 - v31;
    v35 = (_DWORD *)v57 + v5;
    v36 = v34 + v32;
    *v35 = (unint64_t)(v29 + v19) >> 11;
    v35[45] = (unint64_t)(v19 - v29) >> 11;
    v35[5] = (unint64_t)(v33 + v21) >> 11;
    v35[40] = (unint64_t)(v21 - v33) >> 11;
    v35[10] = (v13 >> 11) + 4 * v27;
    v35[35] = (v13 >> 11) - 4 * v27;
    v35[15] = (unint64_t)(v36 + v22) >> 11;
    v35[30] = (unint64_t)(v22 - v36) >> 11;
    v35[20] = (unint64_t)(v30 + v20) >> 11;
    v35[25] = (unint64_t)(v20 - v30) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 5);
  v37 = 0;
  v38 = v55 - 384;
  result = a5;
  do
  {
    v40 = *a4++;
    v41 = *(_DWORD *)((char *)v57 + v37 + 4);
    v42 = (_BYTE *)(v40 + a5);
    v43 = (*(_DWORD *)((char *)v57 + v37) << 13) + 134348800;
    v44 = *(_DWORD *)((char *)v57 + v37 + 8);
    v45 = *(_DWORD *)((char *)v57 + v37 + 12);
    v46 = *(_DWORD *)((char *)&v57[1] + v37);
    v47 = 6476 * (v46 + v44);
    v48 = v44 - v46;
    v49 = v43 + 2896 * v48;
    v50 = 6810 * (v45 + v41);
    v51 = v49 + v47;
    v52 = v50 + 4209 * v41;
    v53 = v50 - 17828 * v45;
    *v42 = *(_BYTE *)(v38 + (((unint64_t)(v52 + v49 + v47) >> 18) & 0x3FF));
    v54 = v49 - v47;
    v42[4] = *(_BYTE *)(v38 + (((unint64_t)(v51 - v52) >> 18) & 0x3FF));
    v42[1] = *(_BYTE *)(v38 + (((unint64_t)(v53 + v54) >> 18) & 0x3FF));
    v42[3] = *(_BYTE *)(v38 + (((unint64_t)(v54 - v53) >> 18) & 0x3FF));
    v42[2] = *(_BYTE *)(v38 + (((unint64_t)(v43 + 268423872 * v48) >> 18) & 0x3FF));
    v37 += 20;
  }
  while (v37 != 200);
  return result;
}

uint64_t jpeg_idct_4x8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  __int16 *v6;
  uint64_t v7;
  unsigned int v8;
  _DWORD *v9;
  unsigned __int16 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  unint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE *v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  uint64_t result;
  uint64_t v58;
  _OWORD v60[8];
  uint64_t v61;

  v5 = 0;
  v61 = *MEMORY[0x1E0C80C00];
  v58 = *(_QWORD *)(a1 + 440);
  v6 = (__int16 *)(a3 + 64);
  v7 = *(_QWORD *)(a2 + 88) + 128;
  v8 = 5;
  memset(v60, 0, sizeof(v60));
  do
  {
    v9 = (_DWORD *)(v7 + v5);
    v10 = *(v6 - 16);
    if ((unsigned __int16)*(v6 - 24) | v10)
      goto LABEL_9;
    if (*(v6 - 8) || *v6 || v6[8] || v6[16] || v6[24])
    {
      v10 = 0;
LABEL_9:
      v11 = *v9 * *v6;
      v12 = ((uint64_t)(*(v9 - 32) * *(v6 - 32)) << 13) | 0x400;
      v13 = v12 + (v11 << 13);
      v14 = v12 - (v11 << 13);
      v15 = (int)*(v9 - 16) * (uint64_t)(__int16)v10;
      v16 = (int)v9[16] * (uint64_t)v6[16];
      v17 = 4433 * (v15 + v16);
      v18 = v17 + 6270 * v15;
      v19 = v17 - 15137 * v16;
      v20 = v18 + v13;
      v21 = v13 - v18;
      v22 = v19 + v14;
      v23 = v14 - v19;
      v24 = (int)v9[24] * (uint64_t)v6[24];
      v25 = (int)v9[8] * (uint64_t)v6[8];
      v26 = *(v9 - 8);
      v27 = (int)*(v9 - 24) * (uint64_t)*(v6 - 24);
      v28 = v24 + v26 * (uint64_t)*(v6 - 8);
      v29 = 9633 * (v25 + v27 + v28);
      v30 = v29 - 16069 * v28;
      v31 = v29 - 3196 * (v25 + v27);
      v32 = -7373 * (v24 + v27);
      v33 = v32 + 2446 * v24 + v30;
      v34 = v32 + 12299 * v27 + v31;
      v35 = -20995 * (v25 + v26 * (uint64_t)*(v6 - 8));
      v36 = v35 + 16819 * v25 + v31;
      v37 = v35 + 25172 * v26 * (uint64_t)*(v6 - 8) + v30;
      v38 = (_DWORD *)((char *)v60 + v5);
      *v38 = (unint64_t)(v34 + v20) >> 11;
      v38[28] = (unint64_t)(v20 - v34) >> 11;
      v38[4] = (unint64_t)(v37 + v22) >> 11;
      v38[24] = (unint64_t)(v22 - v37) >> 11;
      v38[8] = (unint64_t)(v36 + v23) >> 11;
      v38[20] = (unint64_t)(v23 - v36) >> 11;
      v38[12] = (unint64_t)(v33 + v21) >> 11;
      v39 = (unint64_t)(v21 - v33) >> 11;
      v40 = 4;
      goto LABEL_10;
    }
    LODWORD(v39) = 4 * *(v6 - 32) * *(v9 - 32);
    v41 = (_DWORD *)((char *)v60 + v5);
    *v41 = v39;
    v41[4] = v39;
    v41[8] = v39;
    v41[12] = v39;
    v41[16] = v39;
    v41[20] = v39;
    v41[24] = v39;
    v40 = 7;
LABEL_10:
    *(_DWORD *)((char *)&v60[v40] + v5) = v39;
    --v8;
    v5 += 4;
    ++v6;
  }
  while (v8 > 1);
  v42 = 0;
  v43 = v58 - 384;
  do
  {
    v44 = *a4++;
    v45 = (_BYTE *)(v44 + a5);
    v46 = DWORD1(v60[v42]);
    v47 = DWORD2(v60[v42]);
    v48 = HIDWORD(v60[v42]);
    v49 = LODWORD(v60[v42]) + 16400;
    v50 = v49 + v47;
    v51 = (v49 + v47) << 13;
    v52 = v49 - v47;
    v53 = 4433 * (v48 + v46);
    v54 = v52 << 13;
    v55 = v53 + 6270 * v46;
    v56 = v53 - 15137 * v48;
    *v45 = *(_BYTE *)(v43 + (((unint64_t)(v55 + (v50 << 13)) >> 18) & 0x3FF));
    v45[3] = *(_BYTE *)(v43 + (((unint64_t)(v51 - v55) >> 18) & 0x3FF));
    result = *(unsigned __int8 *)(v43 + (((unint64_t)(v56 + (v52 << 13)) >> 18) & 0x3FF));
    v45[1] = result;
    v45[2] = *(_BYTE *)(v43 + (((unint64_t)(v54 - v56) >> 18) & 0x3FF));
    ++v42;
  }
  while (v42 != 8);
  return result;
}

uint64_t jpeg_idct_3x6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  int v28;
  int v29;
  int v30;
  unint64_t v31;
  int v32;
  uint64_t result;
  _OWORD v34[4];
  uint64_t v35;
  uint64_t v36;

  v5 = 0;
  v36 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 440);
  v35 = 0;
  memset(v34, 0, sizeof(v34));
  v7 = *(_QWORD *)(a2 + 88);
  do
  {
    v8 = (_DWORD *)v34 + v5;
    v9 = (_DWORD *)(v7 + 4 * v5);
    v10 = (__int16 *)(a3 + 2 * v5);
    v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    v12 = (int)v9[32] * (uint64_t)v10[32];
    v13 = v11 + 5793 * v12;
    v14 = (unint64_t)(v11 - 11586 * v12) >> 11;
    v15 = 10033 * (int)v9[16] * (uint64_t)v10[16];
    v16 = v15 + v13;
    v17 = v13 - v15;
    v18 = (int)v9[8] * (uint64_t)v10[8];
    v19 = (int)v9[24] * (uint64_t)v10[24];
    v20 = (int)v9[40] * (uint64_t)v10[40];
    v21 = 2998 * (v18 + v20);
    v22 = v21 + ((v18 + v19) << 13);
    v23 = v21 + ((v20 - v19) << 13);
    LODWORD(v18) = v18 - (v19 + v20);
    *v8 = (unint64_t)(v22 + v16) >> 11;
    v8[15] = (unint64_t)(v16 - v22) >> 11;
    v8[3] = v14 + 4 * v18;
    v8[12] = v14 - 4 * v18;
    v8[6] = (unint64_t)(v23 + v17) >> 11;
    v8[9] = (unint64_t)(v17 - v23) >> 11;
    ++v5;
  }
  while ((_DWORD)v5 != 3);
  v24 = 0;
  v25 = v6 - 384;
  do
  {
    v26 = *a4++;
    v27 = (_BYTE *)(v26 + a5);
    v28 = (*(_DWORD *)((char *)v34 + v24) << 13) + 134348800;
    v29 = *(_DWORD *)((char *)v34 + v24 + 8);
    v30 = v28 + 5793 * v29;
    v31 = (v28 + 268423870 * v29);
    v32 = 10033 * *(_DWORD *)((char *)v34 + v24 + 4);
    *v27 = *(_BYTE *)(v25 + (((unint64_t)(v30 + v32) >> 18) & 0x3FF));
    result = *(unsigned __int8 *)(v25 + (((unint64_t)(v30 - v32) >> 18) & 0x3FF));
    v27[2] = result;
    v27[1] = *(_BYTE *)(v25 + ((v31 >> 18) & 0x3FF));
    v24 += 12;
  }
  while (v24 != 72);
  return result;
}

uint64_t jpeg_idct_2x4(uint64_t a1, uint64_t a2, __int16 *a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5;
  _QWORD *v6;
  int *v7;
  char v8;
  char v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  int v24;
  int v25;
  _OWORD v26[4];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 440);
  memset(v26, 0, sizeof(v26));
  v6 = v26;
  v7 = *(int **)(a2 + 88);
  v8 = 1;
  do
  {
    v9 = v8;
    v10 = *v7 * (uint64_t)*a3;
    v11 = v7[16];
    v12 = (v10 + v11 * (uint64_t)a3[16]) << 13;
    v13 = v10 - v11 * (uint64_t)a3[16];
    v14 = v7[8] * (uint64_t)a3[8];
    v15 = v7[24] * (uint64_t)a3[24];
    v16 = 4433 * (v14 + v15);
    v17 = v16 + 6270 * v14;
    v18 = v16 - 15137 * v15;
    result = v17 + v12;
    *v6 = v17 + v12;
    v6[6] = v12 - v17;
    v6[2] = v18 + (v13 << 13);
    v6[4] = (v13 << 13) - v18;
    ++a3;
    ++v7;
    ++v6;
    v8 = 0;
  }
  while ((v9 & 1) != 0);
  v20 = 0;
  v21 = v5 - 384;
  do
  {
    v22 = *a4++;
    v23 = (_BYTE *)(v22 + a5);
    v24 = LODWORD(v26[v20]) + 33587200;
    v25 = DWORD2(v26[v20]);
    *v23 = *(_BYTE *)(v21 + (((unint64_t)(v24 + v25) >> 16) & 0x3FF));
    v23[1] = *(_BYTE *)(v21 + (((unint64_t)(v24 - v25) >> 16) & 0x3FF));
    ++v20;
  }
  while (v20 != 4);
  return result;
}

uint64_t jpeg_idct_1x2(uint64_t result, uint64_t a2, unsigned __int16 *a3, _QWORD *a4, unsigned int a5)
{
  uint64_t v5;
  _DWORD *v6;
  int v7;

  v5 = *(_QWORD *)(result + 440) - 384;
  v6 = *(_DWORD **)(a2 + 88);
  v7 = *v6 * *a3 + 4100;
  LODWORD(v6) = v6[8] * a3[8];
  *(_BYTE *)(*a4 + a5) = *(_BYTE *)(v5 + (((unint64_t)((_DWORD)v6 + v7) >> 3) & 0x3FF));
  *(_BYTE *)(a4[1] + a5) = *(_BYTE *)(v5 + (((unint64_t)(v7 - (_DWORD)v6) >> 3) & 0x3FF));
  return result;
}

double _cg_jpeg_CreateCompress(char *a1, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double result;

  *((_QWORD *)a1 + 1) = 0;
  if (a2 != 90)
  {
    v5 = *(_QWORD *)a1;
    *(_DWORD *)(v5 + 40) = 13;
    *(_DWORD *)(v5 + 48) = 90;
    *(_DWORD *)(*(_QWORD *)a1 + 52) = a2;
    (**(void (***)(char *))a1)(a1);
  }
  if (a3 != 584)
  {
    v6 = *(_QWORD *)a1;
    *(_DWORD *)(v6 + 40) = 22;
    *(_DWORD *)(v6 + 48) = 584;
    *(_DWORD *)(*(_QWORD *)a1 + 52) = a3;
    (**(void (***)(char *))a1)(a1);
  }
  v7 = *(_QWORD *)a1;
  v8 = *((_QWORD *)a1 + 3);
  bzero(a1, 0x248uLL);
  *(_QWORD *)a1 = v7;
  *((_QWORD *)a1 + 3) = v8;
  *((_DWORD *)a1 + 8) = 0;
  _cg_jinit_memory_mgr(a1);
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 5) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *((_QWORD *)a1 + 17) = 0;
  memset_pattern16(a1 + 144, &unk_18820C540, 0x10uLL);
  result = 0.0;
  *((_OWORD *)a1 + 12) = 0u;
  *((_OWORD *)a1 + 13) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 11) = 0u;
  *((_DWORD *)a1 + 119) = 8;
  *((_QWORD *)a1 + 60) = _cg_jpeg_natural_order;
  *((_DWORD *)a1 + 122) = 63;
  *((_QWORD *)a1 + 71) = 0;
  *((_QWORD *)a1 + 8) = 0x3FF0000000000000;
  *((_DWORD *)a1 + 9) = 100;
  return result;
}

uint64_t _cg_jpeg_suppress_tables(uint64_t result, int a2)
{
  uint64_t i;
  uint64_t v3;
  uint64_t j;
  uint64_t v5;
  uint64_t v6;

  for (i = 0; i != 32; i += 8)
  {
    v3 = *(_QWORD *)(result + 112 + i);
    if (v3)
      *(_DWORD *)(v3 + 128) = a2;
  }
  for (j = 0; j != 32; j += 8)
  {
    v5 = *(_QWORD *)(result + j + 160);
    if (v5)
      *(_DWORD *)(v5 + 276) = a2;
    v6 = *(_QWORD *)(result + j + 192);
    if (v6)
      *(_DWORD *)(v6 + 276) = a2;
  }
  return result;
}

uint64_t _cg_jpeg_finish_compress(uint64_t a1)
{
  int v2;
  void (**v3)(uint64_t);
  void (**v4)(uint64_t);
  void (**v5)(uint64_t);
  uint64_t i;
  unint64_t v7;
  unint64_t j;
  uint64_t v9;
  void (**v10)(uint64_t);

  v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 101) >= 2)
  {
    if (v2 == 103)
      goto LABEL_8;
    v5 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v2;
    v4 = *(void (***)(uint64_t))a1;
  }
  else
  {
    if (*(_DWORD *)(a1 + 344) < *(_DWORD *)(a1 + 52))
    {
      v3 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v3 + 10) = 69;
      (*v3)(a1);
    }
    v4 = (void (**)(uint64_t))(*(_QWORD *)(a1 + 496) + 16);
  }
  (*v4)(a1);
LABEL_8:
  for (i = *(_QWORD *)(a1 + 496); !*(_DWORD *)(i + 28); i = *(_QWORD *)(a1 + 496))
  {
    (*(void (**)(uint64_t))i)(a1);
    v7 = *(unsigned int *)(a1 + 368);
    if ((_DWORD)v7)
    {
      for (j = 0; j < v7; ++j)
      {
        v9 = *(_QWORD *)(a1 + 16);
        if (v9)
        {
          *(_QWORD *)(v9 + 8) = j;
          *(_QWORD *)(v9 + 16) = v7;
          (*(void (**)(uint64_t))v9)(a1);
        }
        if (!(*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 520) + 8))(a1, 0))
        {
          v10 = *(void (***)(uint64_t))a1;
          *((_DWORD *)v10 + 10) = 25;
          (*v10)(a1);
        }
        v7 = *(unsigned int *)(a1 + 368);
      }
    }
    (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 496) + 16))(a1);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 528) + 24))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 40) + 32))(a1);
  return _cg_jpeg_abort(a1);
}

uint64_t _cg_jpeg_write_tables(uint64_t a1)
{
  int v2;
  void (**v3)(_QWORD);

  v2 = *(_DWORD *)(a1 + 36);
  if (v2 != 100)
  {
    v3 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 40) + 16))(a1);
  _cg_jinit_marker_writer(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 528) + 32))(a1);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 40) + 32))(a1);
}

double mq_encoder::start(mq_encoder *this, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v8;
  int v9;
  double result;

  if (!*((_BYTE *)this + 56))
  {
    v3 = 0;
    v4 = &dword_1EDF09908;
    do
    {
      v5 = dword_18820C570[v3 >> 1];
      *(v4 - 4) = mq_encoder::p_bar_table[v5] + ((_DWORD)v3 << 31);
      *((_QWORD *)v4 - 1) = (char *)&mq_encoder::transition_table + 32 * (v3 & 1 | (2 * v5));
      v6 = dword_18820C62C[v3 >> 1];
      v8 = v3 >> 1 != 46 && mq_encoder::p_bar_table[v3 >> 1] == 22017;
      v9 = v3 & 1 ^ v8;
      *v4 = mq_encoder::p_bar_table[v6] + (v9 << 31);
      *((_QWORD *)v4 + 1) = (char *)&mq_encoder::transition_table + 32 * (v9 | (2 * v6));
      ++v3;
      v4 += 8;
    }
    while (v3 != 94);
    *((_BYTE *)this + 56) = 1;
  }
  if (*((_BYTE *)this + 35))
    mq_encoder::start();
  if (*((_QWORD *)this + 2))
    mq_encoder::start();
  if (*((_QWORD *)this + 5) || *((_QWORD *)this + 6))
    mq_encoder::start();
  if (!a2)
    mq_encoder::start();
  *(_WORD *)((char *)this + 35) = 1;
  *((_BYTE *)this + 34) = a3;
  *((_QWORD *)this + 2) = a2;
  *((_BYTE *)this + 33) = 0;
  if (a3)
  {
    *(_QWORD *)&result = 0x8000;
    *(_OWORD *)this = xmmword_18820C560;
    *((_QWORD *)this + 3) = a2 - 1;
    *((_BYTE *)this + 32) = *(a2 - 1);
  }
  else
  {
    *((_QWORD *)this + 3) = a2;
    *(_QWORD *)&result = 8;
    *((_QWORD *)this + 1) = 8;
  }
  return result;
}

unsigned __int8 *mq_encoder::terminate(mq_encoder *this, int a2)
{
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  BOOL v9;
  unsigned __int8 *v10;
  int v11;
  int v12;
  _BYTE *v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  _BYTE *v20;
  mq_encoder *v21;
  uint64_t v22;
  uint64_t v24;

  if (!*((_BYTE *)this + 35))
    mq_encoder::terminate();
  if (*((_BYTE *)this + 33))
    mq_encoder::terminate();
  if (!*((_BYTE *)this + 34))
  {
    v11 = *((_DWORD *)this + 2);
    v12 = *((_DWORD *)this + 3);
    v13 = (_BYTE *)*((_QWORD *)this + 3);
    if (a2)
    {
      v10 = (unsigned __int8 *)*((_QWORD *)this + 3);
      if (v11 == 8)
      {
LABEL_29:
        *((_DWORD *)this + 2) = v11;
        *((_DWORD *)this + 3) = v12;
        *((_QWORD *)this + 3) = v13;
        goto LABEL_30;
      }
      v14 = *((_DWORD *)this + 3);
      if (v11 >= 1)
      {
        v15 = v11 + 1;
        v14 = *((_DWORD *)this + 3);
        do
        {
          v14 = (2 * v14) | 1;
          --v15;
        }
        while (v15 > 1);
        *((_DWORD *)this + 2) = 0;
        *((_DWORD *)this + 3) = v14;
      }
      *((_QWORD *)this + 3) = v13 + 1;
      *v13 = v14;
LABEL_28:
      v10 = (unsigned __int8 *)*((_QWORD *)this + 3);
      if (!a2)
        goto LABEL_30;
      goto LABEL_29;
    }
    if (v12 == 255)
    {
      if (v11)
        mq_encoder::terminate();
      v16 = 0;
      *((_QWORD *)this + 3) = v13 + 1;
      *v13 = -1;
      v17 = 7;
    }
    else
    {
      if (v11 == 8)
      {
        v10 = (unsigned __int8 *)*((_QWORD *)this + 3);
        goto LABEL_30;
      }
      v16 = *((_DWORD *)this + 3);
      v17 = *((_DWORD *)this + 2);
      if (v11 < 1)
        goto LABEL_27;
    }
    v18 = 0;
    v19 = v17 + 1;
    do
    {
      v16 = v18 + 2 * v16;
      v18 = 1 - v18;
      --v19;
    }
    while (v19 > 1);
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 3) = v16;
LABEL_27:
    v20 = (_BYTE *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = v20 + 1;
    *v20 = v16;
    goto LABEL_28;
  }
  v5 = *(_DWORD *)this;
  v4 = *((_DWORD *)this + 1);
  v6 = *((_QWORD *)this + 3);
  v24 = *((_QWORD *)this + 1);
  *((_DWORD *)this + 1) = v4 << v24;
  if ((int)v24 <= 11)
  {
    v7 = 12 - v24;
    do
    {
      mq_encoder::transfer_byte((uint64_t)this);
      v8 = *((_DWORD *)this + 2);
      *((_DWORD *)this + 1) <<= v8;
      v9 = __OFSUB__(v7, v8);
      v7 -= v8;
    }
    while (!((v7 < 0) ^ v9 | (v7 == 0)));
  }
  mq_encoder::transfer_byte((uint64_t)this);
  v10 = (unsigned __int8 *)*((_QWORD *)this + 3);
  if (a2)
  {
    *(_DWORD *)this = v5;
    *((_DWORD *)this + 1) = v4;
    *((_QWORD *)this + 1) = v24;
    *((_QWORD *)this + 3) = v6;
  }
  *(_BYTE *)(*((_QWORD *)this + 2) - 1) = *((_BYTE *)this + 32);
LABEL_30:
  v21 = this;
  do
  {
    v22 = (uint64_t)v21;
    v21 = (mq_encoder *)*((_QWORD *)v21 + 5);
  }
  while (v21);
  while ((mq_encoder *)v22 != this)
  {
    if (!*(_BYTE *)(v22 + 36))
      mq_encoder::find_truncation_point(v22, v10);
    v22 = *(_QWORD *)(v22 + 48);
  }
  *((_BYTE *)this + 35) = 0;
  if (a2)
  {
    mq_encoder::find_truncation_point((uint64_t)this, v10);
    return (unsigned __int8 *)*((_QWORD *)this + 3);
  }
  else
  {
    if (*((unsigned __int8 **)this + 3) != v10)
      mq_encoder::terminate();
    if ((unint64_t)v10 > *((_QWORD *)this + 2) && *(v10 - 1) == 255)
      *((_QWORD *)this + 3) = --v10;
    *((_BYTE *)this + 36) = 1;
  }
  return v10;
}

uint64_t mq_encoder::transfer_byte(uint64_t this)
{
  int v1;
  _BYTE *v2;
  int v3;
  unsigned int v4;
  int v5;
  _BYTE *v6;
  int v7;
  int v8;

  if (*(_BYTE *)(this + 33))
    mq_encoder::transfer_byte();
  v1 = *(_DWORD *)(this + 12);
  if (v1 == 255)
  {
    v2 = *(_BYTE **)(this + 24);
    *(_QWORD *)(this + 24) = v2 + 1;
    *v2 = -1;
    v3 = *(_DWORD *)(this + 4);
  }
  else
  {
    v4 = *(_DWORD *)(this + 4);
    v5 = ((v4 >> 27) & 1) + v1;
    *(_DWORD *)(this + 12) = v5;
    *(_DWORD *)(this + 4) = v4 & 0xF7FFFFFF;
    v6 = *(_BYTE **)(this + 24);
    *(_QWORD *)(this + 24) = v6 + 1;
    *v6 = v5;
    v3 = *(_DWORD *)(this + 4);
    if (*(_DWORD *)(this + 12) != 255)
    {
      *(_DWORD *)(this + 12) = v3 >> 19;
      v7 = v3 & 0x7FFFF;
      v8 = 8;
      goto LABEL_7;
    }
  }
  *(_DWORD *)(this + 12) = v3 >> 20;
  v7 = v3 & 0xFFFFF;
  v8 = 7;
LABEL_7:
  *(_DWORD *)(this + 4) = v7;
  *(_DWORD *)(this + 8) = v8;
  return this;
}

uint64_t mq_encoder::find_truncation_point(uint64_t this, unsigned __int8 *a2)
{
  uint64_t v2;
  char v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  unsigned __int8 *v10;
  unsigned int v11;
  char v12;
  unsigned __int8 *v13;
  int v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;

  if (*(_BYTE *)(this + 35))
    mq_encoder::find_truncation_point();
  if (*(_BYTE *)(this + 36))
    mq_encoder::find_truncation_point();
  if (*(_BYTE *)(this + 34))
  {
    v2 = *(_QWORD *)(this + 16);
    v3 = *(_BYTE *)(v2 - 1);
    *(_BYTE *)(v2 - 1) = 0;
    LODWORD(v2) = *(_DWORD *)(this + 4);
    v4 = *(_DWORD *)(this + 8);
    v5 = *(_DWORD *)(this + 12);
    v6 = (_DWORD)v2 << v4;
    v7 = (*(_DWORD *)this + (_DWORD)v2) << v4;
    if ((v6 & 0x8000000) != 0)
      v8 = v5 + 1;
    else
      v8 = *(_DWORD *)(this + 12);
    if ((v7 & 0x8000000) != 0)
      v9 = v5 + 1;
    else
      v9 = *(_DWORD *)(this + 12);
    if (v8 > 255 || v9 <= 255)
    {
      if ((v7 & 0x8000000) != 0)
        v7 -= 0x8000000;
      if ((v6 & 0x8000000) != 0)
        v6 -= 0x8000000;
      v10 = *(unsigned __int8 **)(this + 24);
      v11 = -1;
      v12 = 8;
      while (1)
      {
        if (v10 >= a2)
          mq_encoder::find_truncation_point();
        v13 = v10 + 1;
        *(_QWORD *)(this + 24) = v10 + 1;
        v14 = *v10;
        v15 = v14 << (8 - v12);
        *(_DWORD *)(this + 12) = v14;
        v8 = ((v8 - v15) << v12) + (v6 >> (27 - v12));
        v6 = (v6 << v12) & 0x7FFFFFE;
        v9 = ((v9 - v15) << v12) + (v7 >> (27 - v12));
        v7 = (v7 << v12) & 0x7FFFFFE;
        if (v14 == 255)
          v12 = 7;
        else
          v12 = 8;
        ++v11;
        v10 = v13;
        if (v8 <= 255)
        {
          v10 = v13;
          if (v9 >= 256)
            break;
        }
      }
      if (v11 >= 5)
        mq_encoder::find_truncation_point();
    }
    *(_BYTE *)(*(_QWORD *)(this + 16) - 1) = v3;
  }
  else if (*(_DWORD *)(this + 8) != 8)
  {
    ++*(_QWORD *)(this + 24);
  }
  v16 = *(_QWORD *)(this + 16);
  v17 = *(_QWORD *)(this + 24);
  if (v17 > v16 && *(unsigned __int8 *)(v17 - 1) == 255)
    *(_QWORD *)(this + 24) = --v17;
  v18 = v17 - v16;
  if (v18 >= 2)
  {
    v19 = (unsigned __int8 *)(v17 - 2);
    do
    {
      if (v19[1] != 127)
        break;
      if (*v19 != 255)
        break;
      *(_QWORD *)(this + 24) = v19;
      v18 -= 2;
      v19 -= 2;
    }
    while (v18 > 1);
  }
  *(_BYTE *)(this + 36) = 1;
  return this;
}

void mq_encoder::mq_encode(mq_encode *this, int a2, int *a3)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  if (!*((_BYTE *)this + 34) || !*((_BYTE *)this + 35) || (a2 & 0x7FFFFFFF) != 0 || *((_BYTE *)this + 33))
    mq_encoder::mq_encode();
  v4 = *a3;
  v5 = *a3 & 0x7FFF;
  v6 = *(_DWORD *)this - v5;
  *(_DWORD *)this = v6;
  if ((v4 ^ a2) < 0)
  {
    if (v6 >= v5)
      *(_DWORD *)this = v5;
    else
      *((_DWORD *)this + 1) += v5;
    *(_OWORD *)a3 = *(_OWORD *)(*((_QWORD *)a3 + 1) + 16);
    v7 = *(_DWORD *)this;
    do
    {
      v7 *= 2;
      v8 = *((_DWORD *)this + 2);
      v9 = 2 * *((_DWORD *)this + 1);
      *(_DWORD *)this = v7;
      *((_DWORD *)this + 1) = v9;
      *((_DWORD *)this + 2) = v8 - 1;
      if (v8 == 1)
      {
        mq_encoder::transfer_byte((uint64_t)this);
        v7 = *(_DWORD *)this;
      }
    }
    while (v7 < 0x8000);
  }
  else if (v6 < 0x8000)
  {
    if (v6 >= v5)
      *((_DWORD *)this + 1) += v5;
    else
      *(_DWORD *)this = v5;
    *(_OWORD *)a3 = *(_OWORD *)*((_QWORD *)a3 + 1);
    v10 = *(_DWORD *)this;
    do
    {
      v10 *= 2;
      v11 = *((_DWORD *)this + 2);
      v12 = 2 * *((_DWORD *)this + 1);
      *(_DWORD *)this = v10;
      *((_DWORD *)this + 1) = v12;
      *((_DWORD *)this + 2) = v11 - 1;
      if (v11 == 1)
      {
        mq_encoder::transfer_byte((uint64_t)this);
        v10 = *(_DWORD *)this;
      }
    }
    while (v10 < 0x8000);
  }
  else
  {
    *((_DWORD *)this + 1) += v5;
  }
}

void mq_encoder::mq_encode_run(mq_encoder *this, int a2)
{
  _QWORD v4[2];

  if (!*((_BYTE *)this + 34) || !*((_BYTE *)this + 35) || *((_BYTE *)this + 33))
    mq_encoder::mq_encode_run();
  v4[1] = &unk_1EDF0A478;
  v4[0] = dword_1EDF011D0;
  mq_encoder::mq_encode(this, (a2 << 30) & 0x80000000, (int *)v4);
  mq_encoder::mq_encode(this, a2 << 31, (int *)v4);
}

uint64_t (**_cg_jinit_d_main_controller(uint64_t *a1, int a2))(uint64_t result, int a2)
{
  uint64_t (**result)(uint64_t, int);
  uint64_t (**v5)(uint64_t, int);
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  int v15;
  int v16;
  uint64_t (**v17)(uint64_t, int);
  uint64_t v18;
  uint64_t (**v19)(uint64_t, int);
  _DWORD *v20;

  result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(void))a1[1])();
  v5 = result;
  a1[73] = (uint64_t)result;
  *result = start_pass_main;
  if (a2)
  {
    v6 = *a1;
    *(_DWORD *)(v6 + 40) = 3;
    result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(uint64_t *))v6)(a1);
  }
  v7 = *((_DWORD *)a1 + 107);
  if (*(_DWORD *)(a1[80] + 16))
  {
    if (v7 <= 1)
    {
      v8 = *a1;
      *(_DWORD *)(v8 + 40) = 48;
      (*(void (**)(uint64_t *))v8)(a1);
      v7 = *((_DWORD *)a1 + 107);
    }
    v9 = a1[73];
    result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 16 * *((int *)a1 + 14));
    v10 = *((int *)a1 + 14);
    *(_QWORD *)(v9 + 112) = result;
    *(_QWORD *)(v9 + 120) = &result[v10];
    if ((int)v10 >= 1)
    {
      v11 = 0;
      v12 = v7 + 4;
      v13 = (int *)(a1[38] + 40);
      do
      {
        v14 = *(v13 - 7);
        v15 = *v13;
        v13 += 24;
        v16 = v15 * v14 / *((_DWORD *)a1 + 107);
        result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 16 * v16 * v12);
        v17 = &result[v16];
        *(_QWORD *)(*(_QWORD *)(v9 + 112) + 8 * v11) = v17;
        *(_QWORD *)(*(_QWORD *)(v9 + 120) + 8 * v11++) = &v17[v16 * v12];
        v10 = *((int *)a1 + 14);
      }
      while (v11 < v10);
    }
    v7 = *((_DWORD *)a1 + 107) + 2;
  }
  else
  {
    *((_DWORD *)v5 + 25) = v7;
    LODWORD(v10) = *((_DWORD *)a1 + 14);
  }
  if ((int)v10 >= 1)
  {
    v18 = 0;
    v19 = v5 + 2;
    v20 = (_DWORD *)(a1[38] + 40);
    do
    {
      result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(uint64_t *, uint64_t, _QWORD, _QWORD))(a1[1] + 16))(a1, 1, (*(v20 - 1) * *(v20 - 3)), (*v20 * *(v20 - 7) / *((_DWORD *)a1 + 107) * v7));
      v19[v18++] = (uint64_t (*)(uint64_t, int))result;
      v20 += 24;
    }
    while (v18 < *((int *)a1 + 14));
  }
  return result;
}

uint64_t start_pass_main(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;

  v2 = *(_QWORD *)(result + 584);
  if (a2 == 2)
  {
    *(_QWORD *)(v2 + 8) = process_data_crank_post;
  }
  else if (a2)
  {
    v20 = *(_QWORD *)result;
    *(_DWORD *)(v20 + 40) = 3;
    return (*(uint64_t (**)(uint64_t))v20)(result);
  }
  else if (*(_DWORD *)(*(_QWORD *)(result + 640) + 16))
  {
    *(_QWORD *)(v2 + 8) = process_data_context_main;
    v3 = *(unsigned int *)(result + 56);
    if ((int)v3 >= 1)
    {
      v4 = 0;
      v5 = *(_DWORD *)(result + 428);
      v6 = *(_QWORD *)(result + 304);
      do
      {
        v7 = *(_DWORD *)(v6 + 40) * *(_DWORD *)(v6 + 12) / v5;
        v8 = *(_QWORD **)(*(_QWORD *)(v2 + 112) + 8 * v4);
        v9 = *(_QWORD *)(*(_QWORD *)(v2 + 120) + 8 * v4);
        result = *(_QWORD *)(v2 + 8 * v4 + 16);
        v10 = (v7 * (v5 + 2));
        if ((int)v10 >= 1)
        {
          v11 = *(uint64_t **)(v2 + 8 * v4 + 16);
          v12 = *(_QWORD **)(*(_QWORD *)(v2 + 120) + 8 * v4);
          v13 = *(_QWORD **)(*(_QWORD *)(v2 + 112) + 8 * v4);
          do
          {
            v14 = *v11++;
            *v12++ = v14;
            *v13++ = v14;
            --v10;
          }
          while (v10);
        }
        if (v7 >= 1)
        {
          LODWORD(v15) = 2 * v7;
          v16 = v7 * v5;
          v17 = v7 * (v5 - 2);
          if (2 * v7 <= 1)
            v15 = 1;
          else
            v15 = v15;
          do
          {
            *(_QWORD *)(v9 + 8 * v17) = *(_QWORD *)(result + 8 * v16);
            *(_QWORD *)(v9 + 8 * v16) = *(_QWORD *)(result + 8 * v17);
            result += 8;
            v9 += 8;
            --v15;
          }
          while (v15);
          v18 = -(uint64_t)v7;
          do
            v8[v18] = *v8;
          while (!__CFADD__(v18++, 1));
        }
        ++v4;
        v6 += 96;
      }
      while (v4 != v3);
    }
    *(_QWORD *)(v2 + 128) = 0;
    *(_DWORD *)(v2 + 136) = 0;
    *(_DWORD *)(v2 + 104) = 0;
  }
  else
  {
    *(_QWORD *)(v2 + 8) = process_data_simple_main;
    *(_DWORD *)(v2 + 96) = *(_DWORD *)(v2 + 100);
  }
  return result;
}

int32x2_t process_data_context_main(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  int32x2_t *v8;
  int32x2_t result;
  __int32 v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  signed int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;

  v8 = *(int32x2_t **)(a1 + 584);
  if (!v8[13].i32[0])
  {
    if (!(*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 592) + 24))(a1, *(_QWORD *)&v8[v8[16].i32[0] + 14]))return result;
    v8[13].i32[0] = 1;
    ++v8[17].i32[0];
  }
  v10 = v8[16].i32[1];
  if (!v10)
  {
LABEL_9:
    v11 = *(_DWORD *)(a1 + 428);
    v8[12].i32[0] = 0;
    v8[12].i32[1] = v11 - 1;
    if (v8[17].i32[0] == *(_DWORD *)(a1 + 432))
    {
      v12 = *(unsigned int *)(a1 + 56);
      if ((int)v12 >= 1)
      {
        v13 = 0;
        v14 = *(_DWORD **)(a1 + 304);
        v15 = *(_QWORD *)(a1 + 584);
        v16 = (_QWORD *)(v15 + 8 * *(int *)(v15 + 128) + 112);
        do
        {
          v17 = v14[10] * v14[3];
          v18 = v17 / v11;
          v19 = v14[12] % v17;
          if (!v19)
            v19 = v14[10] * v14[3];
          if (!v13)
            *(_DWORD *)(v15 + 100) = (v19 - 1) / v18 + 1;
          if (v18 >= 1)
          {
            v20 = *(_QWORD *)(*v16 + 8 * v13);
            LODWORD(v21) = 2 * v18;
            v22 = v19 - 1;
            if ((int)v21 <= 1)
              v21 = 1;
            else
              v21 = v21;
            v23 = (_QWORD *)(v20 + 8 * v19);
            do
            {
              *v23++ = *(_QWORD *)(v20 + 8 * v22);
              --v21;
            }
            while (v21);
          }
          ++v13;
          v14 += 24;
        }
        while (v13 != v12);
      }
    }
    v8[16].i32[1] = 1;
    goto LABEL_24;
  }
  if (v10 != 1)
  {
    if (v10 != 2)
      return result;
    (*(void (**)(uint64_t, _QWORD, int32x2_t *, _QWORD, uint64_t, _DWORD *, uint64_t))(*(_QWORD *)(a1 + 600)
                                                                                             + 8))(a1, *(_QWORD *)&v8[v8[16].i32[0] + 14], v8 + 12, v8[12].u32[1], a2, a3, a4);
    if (v8[12].i32[0] < (unsigned __int32)v8[12].i32[1])
      return result;
    v8[16].i32[1] = 0;
    if (*a3 >= a4)
      return result;
    goto LABEL_9;
  }
LABEL_24:
  (*(void (**)(uint64_t, _QWORD, int32x2_t *, _QWORD, uint64_t, _DWORD *, uint64_t))(*(_QWORD *)(a1 + 600) + 8))(a1, *(_QWORD *)&v8[v8[16].i32[0] + 14], v8 + 12, v8[12].u32[1], a2, a3, a4);
  if (v8[12].i32[0] >= (unsigned __int32)v8[12].i32[1])
  {
    v24 = *(_DWORD *)(a1 + 428);
    if (v8[17].i32[0] == 1)
    {
      v25 = *(unsigned int *)(a1 + 56);
      if ((int)v25 >= 1)
      {
        v26 = 0;
        v27 = *(_QWORD *)(a1 + 304);
        v28 = *(_QWORD *)(a1 + 584);
        v29 = v24 + 2;
        do
        {
          v30 = *(_DWORD *)(v27 + 40) * *(_DWORD *)(v27 + 12) / v24;
          if (v30 >= 1)
          {
            v31 = 0;
            v32 = *(_QWORD *)(*(_QWORD *)(v28 + 112) + 8 * v26);
            v33 = *(_QWORD *)(*(_QWORD *)(v28 + 120) + 8 * v26);
            v34 = 8 * (*(_DWORD *)(v27 + 40) * *(_DWORD *)(v27 + 12) / v24);
            v35 = v30 * (v24 + 1);
            v36 = v33 + 8 * v30 * v29;
            v37 = v32 + 8 * v30 * v29;
            v38 = v33 - 8 * v30;
            v39 = v32 - 8 * v30;
            v40 = v33 + 8 * v35;
            v41 = v32 + 8 * v35;
            do
            {
              *(_QWORD *)(v39 + v31) = *(_QWORD *)(v41 + v31);
              *(_QWORD *)(v38 + v31) = *(_QWORD *)(v40 + v31);
              *(_QWORD *)(v37 + v31) = *(_QWORD *)(v32 + v31);
              *(_QWORD *)(v36 + v31) = *(_QWORD *)(v33 + v31);
              v31 += 8;
            }
            while (v34 != v31);
          }
          ++v26;
          v27 += 96;
        }
        while (v26 != v25);
      }
    }
    v42 = v8[16].i32[0] ^ 1;
    v8[13].i32[0] = 0;
    result = vadd_s32(vdup_n_s32(v24), (int32x2_t)0x200000001);
    v8[12] = result;
    v8[16].i32[0] = v42;
    v8[16].i32[1] = 2;
  }
  return result;
}

uint64_t process_data_simple_main(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v8 = a1[73];
  v9 = *(unsigned int *)(v8 + 100);
  if (*(_DWORD *)(v8 + 96) >= v9)
  {
    result = (*(uint64_t (**)(_QWORD *, uint64_t))(a1[74] + 24))(a1, v8 + 16);
    if (!(_DWORD)result)
      return result;
    *(_DWORD *)(v8 + 96) = 0;
    v9 = *(unsigned int *)(v8 + 100);
  }
  return (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1[75] + 8))(a1, v8 + 16, v8 + 96, v9, a2, a3, a4);
}

uint64_t process_data_crank_post(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 600) + 8))();
}

__n128 _cg_jinit_inverse_dct(uint64_t a1)
{
  uint64_t (**v2)(uint64_t);
  __n128 result;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _OWORD *v7;

  v2 = (uint64_t (**)(uint64_t))(**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 632) = v2;
  *v2 = start_pass;
  if (*(int *)(a1 + 56) >= 1)
  {
    v4 = 0;
    v5 = v2 + 11;
    v6 = (_QWORD *)(*(_QWORD *)(a1 + 304) + 88);
    do
    {
      v7 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 256);
      *v6 = v7;
      v6 += 12;
      result = 0uLL;
      *v7 = 0u;
      v7[1] = 0u;
      v7[2] = 0u;
      v7[3] = 0u;
      v7[4] = 0u;
      v7[5] = 0u;
      v7[6] = 0u;
      v7[7] = 0u;
      v7[8] = 0u;
      v7[9] = 0u;
      v7[10] = 0u;
      v7[11] = 0u;
      v7[12] = 0u;
      v7[13] = 0u;
      v7[14] = 0u;
      v7[15] = 0u;
      *((_DWORD *)v5 + v4++) = -1;
    }
    while (v4 < *(int *)(a1 + 56));
  }
  return result;
}

uint64_t start_pass(uint64_t result)
{
  int *v1;
  uint64_t v2;
  uint64_t (*v3)();
  int v4;
  uint64_t v5;
  uint64_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  int v16;
  int v17;
  unsigned int v18;
  uint64_t (**v19)(int *);
  uint64_t (**v20)(int *);
  uint64_t v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint32x4_t *v26;
  uint16x8_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  double v31;
  int v32;
  uint16x8_t v33;
  uint32x4_t v34;
  uint64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  uint32x4_t v38;
  float64x2_t v39;
  float32x4_t *v40;
  uint64_t v41;
  int32x4_t *v42;
  uint16x8_t v43;
  int32x4_t v44;
  int32x4_t v45;
  int16x8_t v46;
  int32x4_t v47;
  int32x4_t v48;
  uint64_t (**v49)(int *);
  float64x2_t v50;

  if (*(int *)(result + 56) >= 1)
  {
    v1 = (int *)result;
    v2 = 0;
    v3 = 0;
    v4 = 0;
    v5 = *(_QWORD *)(result + 632);
    v6 = *(_QWORD *)(result + 304);
    v8 = (float64x2_t)xmmword_18820C7A0;
    v7 = (float64x2_t)unk_18820C7B0;
    v10 = (float64x2_t)start_pass_aanscalefactor;
    v9 = (float64x2_t)unk_18820C790;
    __asm { FMOV            V17.2D, #0.125 }
    v50 = _Q17;
    do
    {
      v16 = *(_DWORD *)(v6 + 36);
      v17 = *(_DWORD *)(v6 + 40) + (v16 << 8);
      if (v17 > 1805)
      {
        if (v17 > 3077)
        {
          if (v17 > 3597)
          {
            if (v17 > 4103)
            {
              if (v17 == 4104)
              {
                v4 = 0;
                v3 = (uint64_t (*)())jpeg_idct_16x8;
                goto LABEL_86;
              }
              if (v17 == 4112)
              {
                v4 = 0;
                v3 = (uint64_t (*)())jpeg_idct_16x16;
                goto LABEL_86;
              }
            }
            else
            {
              if (v17 == 3598)
              {
                v4 = 0;
                v3 = (uint64_t (*)())jpeg_idct_14x14;
                goto LABEL_86;
              }
              if (v17 == 3855)
              {
                v4 = 0;
                v3 = (uint64_t (*)())jpeg_idct_15x15;
                goto LABEL_86;
              }
            }
          }
          else if (v17 > 3340)
          {
            if (v17 == 3341)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_13x13;
              goto LABEL_86;
            }
            if (v17 == 3591)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_14x7;
              goto LABEL_86;
            }
          }
          else
          {
            if (v17 == 3078)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_12x6;
              goto LABEL_86;
            }
            if (v17 == 3084)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_12x12;
              goto LABEL_86;
            }
          }
        }
        else if (v17 > 2312)
        {
          if (v17 > 2569)
          {
            if (v17 == 2570)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_10x10;
              goto LABEL_86;
            }
            if (v17 == 2827)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_11x11;
              goto LABEL_86;
            }
          }
          else
          {
            if (v17 == 2313)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_9x9;
              goto LABEL_86;
            }
            if (v17 == 2565)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_10x5;
              goto LABEL_86;
            }
          }
        }
        else if (v17 > 2055)
        {
          if (v17 == 2056)
          {
            v18 = v1[24];
            if (v18 < 3)
            {
              v3 = off_1E1BBE4A0[v18];
              v4 = v1[24];
              goto LABEL_86;
            }
            v20 = *(uint64_t (***)(int *))v1;
            *(_DWORD *)(*(_QWORD *)v1 + 40) = 49;
            goto LABEL_85;
          }
          if (v17 == 2064)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_8x16;
            goto LABEL_86;
          }
        }
        else
        {
          if (v17 == 1806)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_7x14;
            goto LABEL_86;
          }
          if (v17 == 2052)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_8x4;
            goto LABEL_86;
          }
        }
      }
      else if (v17 > 1027)
      {
        if (v17 > 1538)
        {
          if (v17 > 1547)
          {
            if (v17 == 1548)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_6x12;
              goto LABEL_86;
            }
            if (v17 == 1799)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_7x7;
              goto LABEL_86;
            }
          }
          else
          {
            if (v17 == 1539)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_6x3;
              goto LABEL_86;
            }
            if (v17 == 1542)
            {
              v4 = 0;
              v3 = (uint64_t (*)())jpeg_idct_6x6;
              goto LABEL_86;
            }
          }
        }
        else if (v17 > 1284)
        {
          if (v17 == 1285)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_5x5;
            goto LABEL_86;
          }
          if (v17 == 1290)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_5x10;
            goto LABEL_86;
          }
        }
        else
        {
          if (v17 == 1028)
          {
            v4 = 0;
            v3 = (uint64_t (*)())_cg_jpeg_idct_4x4;
            goto LABEL_86;
          }
          if (v17 == 1032)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_4x8;
            goto LABEL_86;
          }
        }
      }
      else if (v17 > 515)
      {
        if (v17 > 773)
        {
          if (v17 == 774)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_3x6;
            goto LABEL_86;
          }
          if (v17 == 1026)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_4x2;
            goto LABEL_86;
          }
        }
        else
        {
          if (v17 == 516)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_2x4;
            goto LABEL_86;
          }
          if (v17 == 771)
          {
            v4 = 0;
            v3 = (uint64_t (*)())jpeg_idct_3x3;
            goto LABEL_86;
          }
        }
      }
      else if (v17 > 512)
      {
        if (v17 == 513)
        {
          v4 = 0;
          v3 = (uint64_t (*)())jpeg_idct_2x1;
          goto LABEL_86;
        }
        if (v17 == 514)
        {
          v4 = 0;
          v3 = (uint64_t (*)())_cg_jpeg_idct_2x2;
          goto LABEL_86;
        }
      }
      else
      {
        if (v17 == 257)
        {
          v4 = 0;
          v3 = (uint64_t (*)())_cg_jpeg_idct_1x1;
          goto LABEL_86;
        }
        if (v17 == 258)
        {
          v4 = 0;
          v3 = (uint64_t (*)())jpeg_idct_1x2;
          goto LABEL_86;
        }
      }
      v19 = *(uint64_t (***)(int *))v1;
      *((_DWORD *)v19 + 10) = 7;
      *((_DWORD *)v19 + 12) = v16;
      *(_DWORD *)(*(_QWORD *)v1 + 52) = *(_DWORD *)(v6 + 40);
      v20 = *(uint64_t (***)(int *))v1;
LABEL_85:
      result = (*v20)(v1);
      _Q17 = v50;
      v10 = (float64x2_t)start_pass_aanscalefactor;
      v9 = (float64x2_t)unk_18820C790;
      v8 = (float64x2_t)xmmword_18820C7A0;
      v7 = (float64x2_t)unk_18820C7B0;
LABEL_86:
      *(_QWORD *)(v5 + 8 * v2 + 8) = v3;
      if (*(_DWORD *)(v6 + 52))
      {
        v21 = v5 + 4 * v2;
        v23 = *(_DWORD *)(v21 + 88);
        v22 = (int *)(v21 + 88);
        if (v23 != v4)
        {
          v24 = *(_QWORD *)(v6 + 80);
          if (v24)
          {
            *v22 = v4;
            if (v4 == 2)
            {
              v28 = 0;
              v29 = 0;
              v30 = *(_QWORD *)(v6 + 88);
              do
              {
                v31 = *(double *)((char *)&start_pass_aanscalefactor + v28);
                v32 = v29 + 8;
                v33 = *(uint16x8_t *)(v24 + 2 * v29);
                v34 = vmovl_u16(*(uint16x4_t *)v33.i8);
                v35.i64[0] = v34.u32[0];
                v35.i64[1] = v34.u32[1];
                v36 = vcvtq_f64_u64(v35);
                v35.i64[0] = v34.u32[2];
                v35.i64[1] = v34.u32[3];
                v37 = vcvtq_f64_u64(v35);
                v38 = vmovl_high_u16(v33);
                v35.i64[0] = v38.u32[0];
                v35.i64[1] = v38.u32[1];
                v39 = vcvtq_f64_u64(v35);
                v35.i64[0] = v38.u32[2];
                v35.i64[1] = v38.u32[3];
                v40 = (float32x4_t *)(v30 + 4 * v29);
                *v40 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(vmulq_f64(vmulq_n_f64(v36, v31), v10), _Q17)), vmulq_f64(vmulq_f64(vmulq_n_f64(v37, v31), v9), _Q17));
                v40[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(vmulq_f64(vmulq_n_f64(v39, v31), v8), _Q17)), vmulq_f64(vmulq_f64(vmulq_n_f64(vcvtq_f64_u64(v35), v31), v7), _Q17));
                v28 += 8;
                v29 = v32;
              }
              while (v28 != 64);
            }
            else if (v4 == 1)
            {
              v41 = 0;
              v42 = *(int32x4_t **)(v6 + 88);
              do
              {
                v43 = *(uint16x8_t *)(v24 + v41 * 16);
                v44 = (int32x4_t)vmovl_u16(*(uint16x4_t *)v43.i8);
                v45 = (int32x4_t)vmovl_high_u16(v43);
                v46 = (int16x8_t)start_pass_aanscales[v41];
                v47 = vmovl_s16(*(int16x4_t *)v46.i8);
                v48 = vmovl_high_s16(v46);
                *v42 = vrshrn_high_n_s64(vrshrn_n_s64(vmull_s32(*(int32x2_t *)v47.i8, *(int32x2_t *)v44.i8), 0xCuLL), vmull_high_s32(v47, v44), 0xCuLL);
                v42[1] = vrshrn_high_n_s64(vrshrn_n_s64(vmull_s32(*(int32x2_t *)v48.i8, *(int32x2_t *)v45.i8), 0xCuLL), vmull_high_s32(v48, v45), 0xCuLL);
                v42 += 2;
                ++v41;
              }
              while (v41 != 8);
            }
            else if (v4)
            {
              v49 = *(uint64_t (***)(int *))v1;
              *((_DWORD *)v49 + 10) = 49;
              result = (*v49)(v1);
              _Q17 = v50;
              v10 = (float64x2_t)start_pass_aanscalefactor;
              v9 = (float64x2_t)unk_18820C790;
              v8 = (float64x2_t)xmmword_18820C7A0;
              v7 = (float64x2_t)unk_18820C7B0;
            }
            else
            {
              v25 = 0;
              v26 = *(uint32x4_t **)(v6 + 88);
              do
              {
                v27 = *(uint16x8_t *)(v24 + v25);
                *v26 = vmovl_u16(*(uint16x4_t *)v27.i8);
                v26[1] = vmovl_high_u16(v27);
                v26 += 2;
                v25 += 16;
              }
              while (v25 != 128);
            }
          }
        }
      }
      ++v2;
      v6 += 96;
    }
    while (v2 < v1[14]);
  }
  return result;
}

uint64_t jdiv_round_up(uint64_t a1, uint64_t a2)
{
  return (a1 + a2 - 1) / a2;
}

uint64_t _cg_jround_up(uint64_t a1, uint64_t a2)
{
  return (a1 + a2 - 1) / a2 * a2;
}

char *_cg_jcopy_sample_rows(char *result, int a2, uint64_t a3, int a4, int a5, size_t __n)
{
  size_t v6;
  void **v7;
  unsigned int v8;
  const void **v9;
  const void *v10;
  const void *v11;
  void *v12;

  if (a5 >= 1)
  {
    v6 = __n;
    v7 = (void **)(a3 + 8 * a4);
    v8 = a5 + 1;
    v9 = (const void **)&result[8 * a2];
    do
    {
      v11 = *v9++;
      v10 = v11;
      v12 = *v7++;
      result = (char *)memcpy(v12, v10, v6);
      --v8;
    }
    while (v8 > 1);
  }
  return result;
}

void *_cg_jcopy_block_row(void *__src, void *__dst, unsigned int a3)
{
  return memcpy(__dst, __src, (unint64_t)a3 << 7);
}

_OWORD *kd_create_dwt_description(int a1, int a2, kdu_params *this, int a4, BOOL *a5, BOOL *a6, BOOL *a7, unsigned int *a8, _QWORD *a9, _QWORD *a10)
{
  unsigned int *v10;
  _OWORD *v14;
  _OWORD *result;
  uint64_t v16;
  kdu_params *v19;
  kdu_params *v20;
  kdu_params *v21;
  unsigned int v22;
  int v23;
  void *v24;
  void *v25;
  uint64_t v26;
  int v27;
  unsigned int *v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  _OWORD *v34;
  uint64_t v35;
  _DWORD *v36;
  int v37;
  int v38;
  int v39[4];
  __int128 v40;
  uint64_t v41;

  v10 = a8;
  *a9 = 0;
  *a10 = 0;
  *a8 = 0;
  if (a1 == -1)
  {
    v19 = (kdu_params *)kdu_params::access_cluster(this, "ATK");
    if (!v19 || (v20 = (kdu_params *)kdu_params::access_relation(v19, a4, -1, a2, 1), (v21 = v20) == 0))
    {
      v41 = 0;
      *(_OWORD *)v39 = 0u;
      v40 = 0u;
      kdu_error::kdu_error((kdu_error *)v39, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(_QWORD *)v39 + 16))(v39, "Unable to find ATK marker segment referenced from within an COD/COC or MCC marker segment.");
      kdu_error::~kdu_error((kdu_error *)v39);
    }
    v39[0] = 0;
    if (!kdu_params::get(v20, "Ksymmetric", 0, 0, a6, 1, 1, 1)
      || !kdu_params::get(v21, "Kextension", 0, 0, v39, 1, 1, 1)
      || (kdu_params::get(v21, "Kreversible", 0, 0, a5, 1, 1, 1) & 1) == 0)
    {
      kd_create_dwt_description();
    }
    *a7 = v39[0] == 1;
    v38 = 0;
    v22 = 0;
    v23 = 0;
    if (kdu_params::get(v21, "Ksteps", 0, 0, &v38, 1, 1, 1))
    {
      v23 = 0;
      v22 = 0;
      do
      {
        v23 += v38;
        ++v22;
      }
      while ((kdu_params::get(v21, "Ksteps", v22, 0, &v38, 1, 1, 1) & 1) != 0);
    }
    *v10 = v22;
    v24 = (void *)operator new[]();
    v25 = v24;
    if (v22)
      bzero(v24, 16 * v22);
    *a9 = v25;
    v37 = v23;
    result = (_OWORD *)operator new[]();
    *a10 = result;
    if ((int)*v10 < 1)
    {
      v27 = 0;
    }
    else
    {
      v26 = 0;
      v27 = 0;
      do
      {
        v28 = v10;
        v29 = *a9;
        v30 = (int *)(*a9 + 16 * v26);
        if (!kdu_params::get(v21, "Ksteps", v26, 0, v30, 1, 1, 1)
          || !kdu_params::get(v21, "Ksteps", v26, 1, v30 + 1, 1, 1, 1)
          || (v31 = v29 + 16 * v26, !kdu_params::get(v21, "Ksteps", v26, 2, (int *)(v31 + 8), 1, 1, 1))
          || (result = (_OWORD *)kdu_params::get(v21, "Ksteps", v26, 3, (int *)(v31 + 12), 1, 1, 1), !(_DWORD)result))
        {
          kd_create_dwt_description();
        }
        if (*v30 >= 1)
        {
          v32 = 0;
          v33 = 4 * v27;
          do
          {
            result = (_OWORD *)kdu_params::get(v21, "Kcoeffs", v27 + v32++, 0, (float *)(*a10 + v33), 1, 1, 1);
            v33 += 4;
          }
          while (v32 < *v30);
          v27 += v32;
        }
        ++v26;
        v10 = v28;
      }
      while (v26 < (int)*v28);
    }
    if (v27 != v37)
      kd_create_dwt_description();
  }
  else
  {
    *a6 = 1;
    *a7 = 1;
    if (a1)
    {
      if (a1 != 1)
        kd_create_dwt_description();
      *a5 = 1;
      *a8 = 2;
      v14 = (_OWORD *)operator new[]();
      *v14 = 0u;
      v14[1] = 0u;
      *a9 = v14;
      result = (_OWORD *)operator new[]();
      *a10 = result;
      *result = xmmword_18820CCD0;
      v16 = *a9;
      *(_QWORD *)(v16 + 8) = 0x100000001;
      *(_QWORD *)(v16 + 24) = 0x200000002;
    }
    else
    {
      *a5 = 0;
      *a8 = 4;
      v34 = (_OWORD *)operator new[]();
      *v34 = 0u;
      v34[1] = 0u;
      v34[2] = 0u;
      v34[3] = 0u;
      *a9 = v34;
      result = (_OWORD *)operator new[]();
      *a10 = result;
      *result = xmmword_18820CCB0;
      result[1] = xmmword_18820CCC0;
    }
    if ((int)*v10 >= 1)
    {
      v35 = 0;
      v36 = (_DWORD *)(*a9 + 4);
      do
      {
        *(v36 - 1) = 2;
        *v36 = -(((v35++ & 1) + 1) >> 1);
        v36 += 4;
      }
      while (v35 < (int)*v10);
    }
  }
  return result;
}

void sub_187F0BDB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F0BDC0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t print_marker_code(int a1, kdu_message *a2)
{
  const char *v3;
  char v4;
  uint64_t result;
  char v6[16];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = "SOC";
  switch(a1)
  {
    case 65359:
      goto LABEL_34;
    case 65360:
    case 65364:
    case 65366:
    case 65369:
    case 65370:
    case 65371:
    case 65378:
    case 65381:
    case 65382:
    case 65383:
    case 65384:
    case 65385:
    case 65386:
    case 65387:
    case 65388:
    case 65389:
    case 65390:
    case 65391:
    case 65392:
    case 65393:
    case 65398:
LABEL_7:
      v4 = *((_BYTE *)a2 + 8);
      *((_BYTE *)a2 + 8) = 1;
      (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "0x");
      v9 = 0u;
      v10 = 0u;
      v7 = 0u;
      v8 = 0u;
      *(_OWORD *)v6 = 0u;
      if (*((_BYTE *)a2 + 8))
        sprintf(v6, "%x");
      else
        sprintf(v6, "%u");
      result = (*(uint64_t (**)(kdu_message *, char *))(*(_QWORD *)a2 + 16))(a2, v6);
      *((_BYTE *)a2 + 8) = v4;
      return result;
    case 65361:
      v3 = "SIZ";
      goto LABEL_34;
    case 65362:
      v3 = "COD";
      goto LABEL_34;
    case 65363:
      v3 = "COC";
      goto LABEL_34;
    case 65365:
      v3 = "TLM";
      goto LABEL_34;
    case 65367:
      v3 = "PLM";
      goto LABEL_34;
    case 65368:
      v3 = "PLT";
      goto LABEL_34;
    case 65372:
      v3 = "QCD";
      goto LABEL_34;
    case 65373:
      v3 = "QCC";
      goto LABEL_34;
    case 65374:
      v3 = "RGN";
      goto LABEL_34;
    case 65375:
      v3 = "POC";
      goto LABEL_34;
    case 65376:
      v3 = "PPM";
      goto LABEL_34;
    case 65377:
      v3 = "PPT";
      goto LABEL_34;
    case 65379:
      v3 = "CRG";
      goto LABEL_34;
    case 65380:
      v3 = "COM";
      goto LABEL_34;
    case 65394:
      v3 = "DFS";
      goto LABEL_34;
    case 65395:
      v3 = "ADS";
      goto LABEL_34;
    case 65396:
      v3 = "MCT";
      goto LABEL_34;
    case 65397:
      v3 = "MCC";
      goto LABEL_34;
    case 65399:
      v3 = "MCO";
      goto LABEL_34;
    case 65400:
      v3 = "CBD";
      goto LABEL_34;
    case 65401:
      v3 = "ATK";
      goto LABEL_34;
    default:
      switch(a1)
      {
        case 65424:
          v3 = "SOT";
          break;
        case 65425:
          v3 = "SOP";
          break;
        case 65426:
          v3 = "EPH";
          break;
        case 65427:
          v3 = "SOD";
          break;
        default:
          if (a1 != 65497)
            goto LABEL_7;
          v3 = "EOC";
          break;
      }
LABEL_34:
      (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, "<");
      (*(void (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, v3);
      return (*(uint64_t (**)(kdu_message *, const char *))(*(_QWORD *)a2 + 16))(a2, ">");
  }
}

unsigned __int8 *kd_input::process_unexpected_marker(unsigned __int8 *this, int a2)
{
  unsigned __int8 *v3;
  int v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  _WORD *exception;
  unsigned __int8 v10;

  if (!this[545])
    kd_input::process_unexpected_marker();
  v3 = this;
  this[545] = 0;
  v4 = this[544];
  if (this[544])
    this[546] = 0;
  v5 = a2 | 0xFFFFFF00;
  if (this[547])
  {
LABEL_13:
    if (!v4)
    {
      kd_input::putback((kd_input *)v3, v5);
      exception = __cxa_allocate_exception(2uLL);
      *exception = v5;
      __cxa_throw(exception, MEMORY[0x1E0DE4F18], 0);
    }
    kd_input::process_unexpected_marker();
  }
  if ((a2 & 0xFE) == 0x90)
  {
    v10 = 0;
    this = (unsigned __int8 *)kd_input::get((kd_input *)this, &v10);
    if ((this & 1) != 0)
    {
      v6 = v10;
      if ((kd_input::get((kd_input *)v3, &v10) & 1) != 0)
      {
        v7 = v10 | (v6 << 8);
        if (v5 == -111)
          v8 = 4;
        else
          v8 = 10;
        kd_input::putback((uint64_t)v3, v10);
        this = (unsigned __int8 *)kd_input::putback((uint64_t)v3, v6);
        if (v7 == v8)
        {
          v4 = v3[544];
          goto LABEL_13;
        }
      }
      else
      {
        v3[544] = 0;
        this = (unsigned __int8 *)kd_input::putback((uint64_t)v3, a2);
      }
    }
    else
    {
      v3[544] = 0;
    }
  }
  v3[545] = 1;
  v3[546] = a2 == 255;
  return this;
}

uint64_t kd_input::putback(kd_input *this, __int16 a2)
{
  char v2;

  v2 = HIBYTE(a2);
  kd_input::putback((uint64_t)this, a2);
  return kd_input::putback((uint64_t)this, v2);
}

uint64_t kd_input::read(kd_input *this, unsigned __int8 *a2, int a3)
{
  BOOL v3;
  int v4;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned __int8 *v12;
  unsigned int v13;
  unsigned __int8 *v14;
  BOOL v15;

  if (*((_BYTE *)this + 544))
    v3 = 1;
  else
    v3 = a3 < 1;
  if (v3)
    return 0;
  v4 = a3;
  v7 = 0;
  do
  {
    v8 = *((_DWORD *)this + 134) - *((_DWORD *)this + 132);
    if (!v8)
    {
      if (!(*(unsigned int (**)(kd_input *))(*(_QWORD *)this + 24))(this))
        return v7;
      v8 = *((_DWORD *)this + 134) - *((_DWORD *)this + 132);
      if (v8 <= 0)
        kd_input::read();
    }
    if (v8 >= v4)
      v9 = v4;
    else
      v9 = v8;
    v10 = v9;
    v11 = v9;
    if (*((_BYTE *)this + 545))
    {
      do
      {
        v12 = (unsigned __int8 *)*((_QWORD *)this + 66);
        *((_QWORD *)this + 66) = v12 + 1;
        v13 = *v12;
        *a2++ = v13;
        if (*((_BYTE *)this + 546) && v13 >= 0x90)
          kd_input::process_unexpected_marker((unsigned __int8 *)this, v13);
        *((_BYTE *)this + 546) = v13 == 255;
        --v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        v14 = (unsigned __int8 *)*((_QWORD *)this + 66);
        *((_QWORD *)this + 66) = v14 + 1;
        *a2++ = *v14;
        --v11;
      }
      while (v11);
    }
    v7 = (v9 + v7);
    v15 = __OFSUB__(v4, v9);
    v4 -= v9;
  }
  while (!((v4 < 0) ^ v15 | (v4 == 0)));
  return v7;
}

uint64_t kd_input::ignore(kd_input *this, uint64_t a2)
{
  BOOL v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  char v9;
  int v10;
  unsigned __int8 *v11;
  unsigned int v12;

  if (*((_BYTE *)this + 544))
    v2 = 1;
  else
    v2 = a2 < 1;
  if (v2)
    return 0;
  v3 = a2;
  v5 = 0;
  do
  {
    v6 = *((_QWORD *)this + 66);
    v7 = *((_DWORD *)this + 134) - v6;
    if (!v7)
    {
      if (!(*(unsigned int (**)(kd_input *))(*(_QWORD *)this + 24))(this))
        return v5;
      v6 = *((_QWORD *)this + 66);
      v7 = *((_DWORD *)this + 134) - v6;
      if (v7 <= 0)
        kd_input::ignore();
    }
    if (v3 >= v7)
      v8 = v7;
    else
      v8 = v3;
    if (*((_BYTE *)this + 545))
    {
      if (v8)
      {
        v9 = *((_BYTE *)this + 546);
        v10 = v8;
        do
        {
          v11 = (unsigned __int8 *)*((_QWORD *)this + 66);
          *((_QWORD *)this + 66) = v11 + 1;
          v12 = *v11;
          if (v9 && v12 >= 0x90)
            kd_input::process_unexpected_marker((unsigned __int8 *)this, *v11);
          v9 = v12 == 255;
          *((_BYTE *)this + 546) = v12 == 255;
          --v10;
        }
        while (v10);
      }
    }
    else
    {
      *((_QWORD *)this + 66) = v6 + v8;
    }
    v5 += v8;
    v3 -= v8;
  }
  while (v3 > 0);
  return v5;
}

uint64_t kd_compressed_input::set_max_bytes(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;

  if (!*(_BYTE *)(this + 608) && *(_QWORD *)(this + 568) > a2)
  {
    v2 = 0x3FFFFFFFFFFFFFFFLL;
    if (a2 < 0x3FFFFFFFFFFFFFFFLL)
      v2 = a2;
    *(_QWORD *)(this + 568) = v2;
    if (!*(_QWORD *)(this + 592))
    {
      v3 = *(_QWORD *)(this + 584) + v2;
      v4 = *(_QWORD *)(this + 536);
      v5 = v4 - this - 14;
      v6 = v3 - *(_QWORD *)(this + 560);
      v7 = v6 < v5;
      v8 = v6 - v5;
      if (v7)
      {
        v9 = v4 + v8;
        *(_QWORD *)(this + 536) = v9;
        v10 = *(_QWORD *)(this + 528);
        if (v9 < v10)
        {
          *(_BYTE *)(this + 544) = 1;
          *(_QWORD *)(this + 536) = v10;
        }
      }
    }
  }
  return this;
}

BOOL kd_compressed_input::load_buf(kd_compressed_input *this)
{
  unint64_t v1;
  char *v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t (*v8)(void);
  uint64_t v9;
  _BOOL8 result;

  v1 = *((_QWORD *)this + 67);
  if (v1 != *((_QWORD *)this + 66))
    kd_compressed_input::load_buf();
  v3 = (char *)this + 14;
  *((_QWORD *)this + 66) = (char *)this + 14;
  v4 = *((_QWORD *)this + 70) + v1 - ((_QWORD)this + 14);
  *((_QWORD *)this + 70) = v4;
  if (*((_BYTE *)this + 608))
  {
    v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 69) + 32))(*((_QWORD *)this + 69));
    v6 = *((_QWORD *)this + 66);
  }
  else
  {
    v7 = *((_QWORD *)this + 74);
    if (v7)
    {
      if (*((_QWORD *)this + 75))
        kd_compressed_input::load_buf();
      if (v7 < (unint64_t)v3 || v7 > v1)
        kd_compressed_input::load_buf();
      *((_QWORD *)this + 73) += v1 - v7;
      *((_QWORD *)this + 67) = v3;
      *((_QWORD *)this + 74) = v3;
      v8 = *(uint64_t (**)(void))(**((_QWORD **)this + 69) + 32);
    }
    else
    {
      *((_QWORD *)this + 75) = 0;
      v9 = *((_QWORD *)this + 71) - v4 + *((_QWORD *)this + 73);
      *((_QWORD *)this + 67) = v3;
      if (v9 < 1)
      {
        result = 0;
        *((_BYTE *)this + 544) = 1;
        return result;
      }
      v8 = *(uint64_t (**)(void))(**((_QWORD **)this + 69) + 32);
    }
    v5 = v8();
    v6 = *((_QWORD *)this + 67);
  }
  *((_QWORD *)this + 67) = v6 + v5;
  if (!v5)
    *((_BYTE *)this + 544) = 1;
  return *((_BYTE *)this + 544) == 0;
}

uint64_t kd_compressed_input::set_tileheader_scope(kd_compressed_input *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  BOOL v5;
  _OWORD v7[2];
  uint64_t v8;

  *((_BYTE *)this + 608) = 1;
  *((_QWORD *)this + 66) = (char *)this + 14;
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 69) + 56))(*((_QWORD *)this + 69));
  v3 = *((_QWORD *)this + 69);
  if ((v2 & 1) != 0)
  {
    v4 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v3 + 32))(v3, *((_QWORD *)this + 66), 512);
    *((_QWORD *)this + 67) = *((_QWORD *)this + 66) + v4;
    if (v4 < 0)
      kd_compressed_input::set_tileheader_scope();
    v5 = v4 == 0;
  }
  else
  {
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3) & 4) == 0)
    {
      v8 = 0;
      memset(v7, 0, sizeof(v7));
      kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v7[0] + 16))(v7, "Attempting to load cached tile header data from a compressed data source which does not appear to support caching.  It is possible that the source has been incorrectly implemented.");
      kdu_error::~kdu_error((kdu_error *)v7);
    }
    *((_QWORD *)this + 67) = *((_QWORD *)this + 66);
    v5 = 1;
  }
  *((_BYTE *)this + 544) = v5;
  return v2;
}

void sub_187F0C6B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F0C6BC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_compressed_input::seek(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  if (*(_BYTE *)(this + 545))
    kd_compressed_input::seek();
  v2 = this;
  if (a2 < 0)
  {
    *(_BYTE *)(this + 608) = 1;
    *(_QWORD *)(this + 536) = this + 14;
    *(_QWORD *)(this + 528) = this + 14;
    if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(this + 552) + 64))(*(_QWORD *)(this + 552), ~a2) & 1) == 0)
    {
      v16 = 0;
      v14 = 0u;
      v15 = 0u;
      kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Attempting to load cached precinct packets from a compressed data source which does not appear to support caching.  It is possible that the source has been incorrectly implemented.");
      kdu_error::~kdu_error((kdu_error *)&v14);
    }
    this = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(v2 + 552) + 32))(*(_QWORD *)(v2 + 552), *(_QWORD *)(v2 + 528), 512);
    *(_QWORD *)(v2 + 536) = *(_QWORD *)(v2 + 528) + (int)this;
    v12 = (_DWORD)this == 0;
    goto LABEL_13;
  }
  v3 = this + 14;
  v4 = *(_QWORD *)(this + 560);
  v5 = *(_QWORD *)(this + 528);
  v6 = v4 - (this + 14);
  if (v6 + v5 == a2)
    return this;
  v7 = ~v3 + v5 + v4;
  if (v7 > *(_QWORD *)(this + 576))
    *(_QWORD *)(this + 576) = v7;
  v8 = *(_QWORD *)(this + 568);
  if (v8 <= a2)
  {
    *(_BYTE *)(this + 544) = 1;
    *(_QWORD *)(this + 560) = v8;
    *(_QWORD *)(this + 536) = v3;
    goto LABEL_15;
  }
  v9 = *(_QWORD *)(this + 536);
  *(_BYTE *)(this + 544) = 0;
  v10 = __OFSUB__(a2, v4);
  v11 = a2 - v4;
  if (v11 < 0 == v10 && v6 + v9 > a2)
  {
    v3 += v11;
LABEL_15:
    *(_QWORD *)(this + 528) = v3;
    return this;
  }
  *(_QWORD *)(this + 560) = a2;
  *(_QWORD *)(this + 536) = v3;
  *(_QWORD *)(this + 528) = v3;
  if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 552) + 40))(*(_QWORD *)(this + 552)) & 1) == 0)
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Attempting to seek inside a compressed data source which does not appear to support seeking.  The source may have been implemented incorrectly.");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  if ((uint64_t)(*(_QWORD *)(v2 + 568) - *(_QWORD *)(v2 + 560)) >= 512)
    v13 = 512;
  else
    v13 = *(_QWORD *)(v2 + 568) - *(_QWORD *)(v2 + 560);
  this = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)(v2 + 552) + 32))(*(_QWORD *)(v2 + 552), *(_QWORD *)(v2 + 528), v13);
  *(_QWORD *)(v2 + 536) = *(_QWORD *)(v2 + 528) + (int)this;
  if (!(_DWORD)this)
  {
    v12 = 1;
LABEL_13:
    *(_BYTE *)(v2 + 544) = v12;
  }
  return this;
}

void sub_187F0C8B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F0C8C0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_compressed_input::ignore(kd_compressed_input *this, uint64_t a2)
{
  uint64_t v5;
  uint64_t v6;

  if (((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 69) + 24))(*((_QWORD *)this + 69)) & 2) == 0)
    return kd_input::ignore(this, a2);
  v5 = a2 - (_QWORD)this;
  v6 = *((_QWORD *)this + 70) + *((_QWORD *)this + 66);
  kd_compressed_input::seek((uint64_t)this, v5 + v6 - 14);
  return *((_QWORD *)this + 70) - v6 + *((_QWORD *)this + 66);
}

void kd_pph_input::~kd_pph_input(kd_pph_input *this)
{
  _QWORD *v2;

  *(_QWORD *)this = &off_1E1BAC4D0;
  *((_QWORD *)this + 70) = 0;
  while (1)
  {
    v2 = (_QWORD *)*((_QWORD *)this + 69);
    *((_QWORD *)this + 71) = v2;
    if (!v2)
      break;
    *((_QWORD *)this + 69) = *v2;
    kd_buf_server::release(*((_QWORD *)this + 73), (uint64_t)v2);
  }
  *(_QWORD *)this = off_1E1BB2F10;
}

{
  kd_pph_input::~kd_pph_input(this);
  JUMPOUT(0x18D761C30);
}

uint64_t kd_buf_server::release(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t v4;

  v2 = 0;
  v3 = *(_BYTE *)(a2 + 8);
  do
  {
    if ((*(char *)(a2 - ((unint64_t)(v3 & 0x3F) << 6) + 8 + v2) & 0x80000000) == 0)
    {
      *(_QWORD *)a2 = 0;
      *(_BYTE *)(a2 + 8) = v3 & 0x7F;
      return result;
    }
    v2 += 64;
  }
  while (v2 != 256);
  v4 = *(_QWORD *)(result + 24);
  if (v4 <= 0)
    kd_buf_server::release();
  *(_QWORD *)a2 = *(_QWORD *)(result + 8);
  *(_BYTE *)(a2 + 8) = v3 & 0x7F;
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 24) = v4 - 1;
  return result;
}

uint64_t kd_pph_input::add_bytes(uint64_t this, char *a2, int a3)
{
  int v3;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  char v9;
  uint64_t v10;
  uint64_t v11;

  if (a3 >= 1)
  {
    v3 = a3;
    v5 = this;
    while (*(_QWORD *)(v5 + 568))
    {
      v6 = *(_DWORD *)(v5 + 580);
      if (v6 == 55)
      {
        this = kd_buf_server::get(*(kd_buf_server **)(v5 + 584));
        **(_QWORD **)(v5 + 568) = this;
        *(_QWORD *)(v5 + 568) = this;
LABEL_7:
        v6 = 0;
        *(_DWORD *)(v5 + 580) = 0;
      }
      v7 = 55 - v6;
      if (v7 >= v3)
        v7 = v3;
      if (v7)
      {
        v8 = v7;
        do
        {
          v9 = *a2++;
          v10 = *(_QWORD *)(v5 + 568);
          v11 = *(int *)(v5 + 580);
          *(_DWORD *)(v5 + 580) = v11 + 1;
          *(_BYTE *)(v10 + v11 + 9) = v9;
          --v8;
        }
        while (v8);
      }
      v3 -= v7;
      if (v3 < 1)
        return this;
    }
    this = kd_buf_server::get(*(kd_buf_server **)(v5 + 584));
    *(_QWORD *)(v5 + 552) = this;
    *(_QWORD *)(v5 + 560) = this;
    *(_QWORD *)(v5 + 568) = this;
    *(_DWORD *)(v5 + 576) = 0;
    goto LABEL_7;
  }
  return this;
}

uint64_t kd_buf_server::get(kd_buf_server *this)
{
  uint64_t v2;
  char v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = *((_QWORD *)this + 1);
  if (!v2)
  {
    if (*((_QWORD *)this + 3) != *((_QWORD *)this + 2))
      kd_buf_server::get();
    kd_buf_server::alloc_pages(this);
    v2 = *((_QWORD *)this + 1);
  }
  v3 = *(_BYTE *)(v2 + 8);
  v4 = v3 & 0x3F;
  v5 = v2 - ((unint64_t)(v3 & 0x3F) << 6);
  if ((v3 & 0x3F) != 0)
  {
    v6 = v3 & 0x3F;
    result = v2 - (v6 << 6);
    do
    {
      v8 = *(char *)(result + 8);
      if ((v8 & 0x80000000) == 0)
      {
        *(_BYTE *)(result + 8) = v8 | 0x80;
        return result;
      }
      result += 64;
      --v6;
    }
    while (v6);
    *(_BYTE *)(v2 + 8) = v3 | 0x80;
    if (v4 <= 2)
      goto LABEL_11;
LABEL_14:
    *((_QWORD *)this + 1) = *(_QWORD *)v2;
    *(_QWORD *)v2 = 0;
    v12 = *((_QWORD *)this + 3);
    v11 = *((_QWORD *)this + 4);
    *((_QWORD *)this + 3) = v12 + 1;
    if (v12 >= v11)
      *((_QWORD *)this + 4) = v11 + 1;
  }
  else
  {
    *(_BYTE *)(v2 + 8) = v3 | 0x80;
LABEL_11:
    v9 = 3;
    while (1)
    {
      v10 = v5 + ((unint64_t)v9 << 6);
      if ((*(char *)(v10 + 8) & 0x80000000) == 0)
        break;
      if (--v9 <= v4)
        goto LABEL_14;
    }
    *((_QWORD *)this + 1) = v10;
    *(_QWORD *)v10 = *(_QWORD *)v2;
    *(_QWORD *)v2 = 0;
  }
  return v2;
}

uint64_t kd_pph_input::load_buf(kd_pph_input *this)
{
  int i;
  int v2;
  _QWORD *v3;
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;

  if (!*((_QWORD *)this + 70))
    goto LABEL_20;
  *((_QWORD *)this + 67) = (char *)this + 14;
  *((_QWORD *)this + 66) = (char *)this + 14;
  for (i = 506; i >= 1; i -= v6)
  {
    v2 = *((_DWORD *)this + 144);
    v3 = (_QWORD *)*((_QWORD *)this + 70);
    v4 = (_QWORD *)*((_QWORD *)this + 71);
    if (v2 == 55)
    {
      if (v3 == v4)
      {
        v2 = 55;
      }
      else
      {
        v3 = (_QWORD *)*v3;
        *((_QWORD *)this + 70) = v3;
        *((_DWORD *)this + 144) = 0;
        if (!v3)
          kd_pph_input::load_buf();
        v2 = 0;
      }
    }
    if (v3 == v4)
      v5 = *((_DWORD *)this + 145);
    else
      v5 = 55;
    v6 = v5 - v2;
    if (v6 < 0)
      kd_pph_input::load_buf();
    if (!v6)
      break;
    if (v6 >= i)
      v6 = i;
    v7 = v6;
    do
    {
      v8 = *((_QWORD *)this + 70);
      v9 = *((int *)this + 144);
      *((_DWORD *)this + 144) = v9 + 1;
      LOBYTE(v8) = *(_BYTE *)(v8 + v9 + 9);
      v10 = (_BYTE *)*((_QWORD *)this + 67);
      *((_QWORD *)this + 67) = v10 + 1;
      *v10 = v8;
      --v7;
    }
    while (v7);
  }
  if (*((_QWORD *)this + 66) != *((_QWORD *)this + 67))
    return 1;
LABEL_20:
  v11 = 0;
  *((_BYTE *)this + 544) = 1;
  return v11;
}

uint64_t kd_marker::kd_marker(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;
  size_t v6;

  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = v4;
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  LODWORD(v4) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 20) = v4;
  *(_DWORD *)(a1 + 24) = v4;
  if ((_DWORD)v4)
  {
    v5 = (void *)operator new[]();
    v6 = *(int *)(a1 + 20);
  }
  else
  {
    v6 = 0;
    v5 = 0;
  }
  *(_QWORD *)(a1 + 32) = v5;
  memcpy(v5, *(const void **)(a2 + 32), v6);
  *(_BYTE *)(a1 + 40) = 0;
  return a1;
}

uint64_t kd_marker::read(kd_marker *this, char a2, int a3)
{
  kd_input *v3;
  int v6;
  char v7;
  kd_input *v8;
  unsigned int v9;
  char v10;
  int v11;
  int v12;
  kd_input *v13;
  uint64_t result;
  int v15;
  BOOL v16;
  char v17;
  kd_input *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  unsigned __int8 *v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  unsigned __int8 v27;

  v3 = *(kd_input **)this;
  if (!*(_QWORD *)this)
    kd_marker::read();
  v27 = 0;
  if (*((_BYTE *)v3 + 545))
  {
    *((_BYTE *)v3 + 545) = 0;
    if (*((_BYTE *)v3 + 544))
      *((_BYTE *)v3 + 546) = 0;
  }
  v6 = 0;
  v7 = a2 ^ 1;
  while (1)
  {
    v8 = *(kd_input **)this;
    if (v6 != 255)
    {
      if ((kd_input::get(v8, &v27) & 1) == 0)
        goto LABEL_70;
      if (a3 && v27 != 255)
      {
        while ((kd_input::get(*(kd_input **)this, &v27) & 1) != 0)
        {
          if (v27 == 255)
          {
            v8 = *(kd_input **)this;
            goto LABEL_14;
          }
        }
        goto LABEL_70;
      }
      v8 = *(kd_input **)this;
      if (v27 != 255)
      {
        kd_input::putback((uint64_t)v8, v27);
        goto LABEL_70;
      }
    }
LABEL_14:
    if ((kd_input::get(v8, &v27) & 1) == 0)
      goto LABEL_70;
    v9 = v27;
    *((_WORD *)this + 8) = v27 | 0xFF00;
    if (v9 > 0x8F)
      v10 = 1;
    else
      v10 = v7;
    if (v9 - 144 < 2)
    {
      if ((v10 & 1) == 0)
        kd_marker::read();
      if ((kd_input::get(*(kd_input **)this, &v27) & 1) == 0)
        goto LABEL_70;
      *((_DWORD *)this + 5) = v27 << 8;
      if ((kd_input::get(*(kd_input **)this, &v27) & 1) == 0)
        goto LABEL_70;
      v11 = *((_DWORD *)this + 5) + v27;
      *((_DWORD *)this + 5) = v11;
      v12 = *((unsigned __int16 *)this + 8);
      if (v12 != 65425 || v11 == 4)
      {
        v10 = 1;
        if (v12 != 65424 || v11 == 10)
          goto LABEL_39;
        v18 = *(kd_input **)this;
        kd_input::putback(*(_QWORD *)this, v11);
        kd_input::putback((uint64_t)v18, SBYTE1(v11));
        v26 = 0;
        v24 = 0u;
        v25 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v24, "Kakadu Core Warning:\n");
        (*(void (**)(__int128 *, const char *))(v24 + 16))(&v24, "Skipping over corrupt SOT marker code!");
      }
      else
      {
        v13 = *(kd_input **)this;
        kd_input::putback(*(_QWORD *)this, v11);
        kd_input::putback((uint64_t)v13, SBYTE1(v11));
        v26 = 0;
        v24 = 0u;
        v25 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v24, "Kakadu Core Warning:\n");
        (*(void (**)(__int128 *, const char *))(v24 + 16))(&v24, "Skipping over corrupt SOP marker code!");
      }
      kdu_warning::~kdu_warning((kdu_warning *)&v24);
      v10 = 0;
LABEL_39:
      v27 = *((_BYTE *)this + 16);
      goto LABEL_40;
    }
    if (v9 == 217)
    {
      result = kd_input::get(*(kd_input **)this, &v27);
      if (!(_DWORD)result)
        goto LABEL_62;
      v15 = *(unsigned __int8 *)(*((_QWORD *)this + 1) + 412);
      kd_input::putback(*(_QWORD *)this, v27);
      if (!v15)
      {
        result = 0;
        *(_BYTE *)(*(_QWORD *)this + 544) = 1;
LABEL_62:
        *((_DWORD *)this + 5) = 0;
LABEL_63:
        *((_WORD *)this + 8) = 0;
        return result;
      }
      v27 = *((_BYTE *)this + 16);
      v26 = 0;
      v24 = 0u;
      v25 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v24, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v24 + 16))(&v24, "Disregarding non-terminal EOC marker.");
      kdu_warning::~kdu_warning((kdu_warning *)&v24);
      v10 = 0;
    }
    else
    {
      v16 = (v9 & 0xF0) == 48;
      v17 = v10 ^ 1;
      if (!v16)
        v17 = 1;
      if ((v17 & 1) == 0)
      {
        v27 = 0;
        if (!*((_BYTE *)this + 40))
        {
          v26 = 0;
          v24 = 0u;
          v25 = 0u;
          kdu_warning::kdu_warning((kdu_warning *)&v24, "Kakadu Core Warning:\n");
          (*(void (**)(__int128 *, const char *))(v24 + 16))(&v24, "Encountered one or more marker codes in the range 0xFF30 to 0xFF3F.  These are to be ignored.");
          kdu_warning::~kdu_warning((kdu_warning *)&v24);
        }
        *((_BYTE *)this + 40) = 1;
        goto LABEL_42;
      }
    }
LABEL_40:
    if ((a3 & 1) == 0)
    {
      v19 = *((unsigned __int16 *)this + 8);
      if ((v10 & 1) != 0)
        goto LABEL_46;
      kd_input::putback(*(kd_input **)this, v19);
      goto LABEL_70;
    }
    if ((v10 & 1) != 0)
      break;
LABEL_42:
    v6 = v27;
  }
  v19 = *((unsigned __int16 *)this + 8);
LABEL_46:
  result = 1;
  if (v19 > 65423)
  {
    if ((v19 - 65424) < 2)
      goto LABEL_49;
    if ((v19 - 65426) >= 2 && v19 != 65497)
      goto LABEL_74;
  }
  else
  {
    if ((v19 - 65359) > 0x2A)
      goto LABEL_74;
    if (((1 << (v19 - 79)) & 0x7780037E35CLL) != 0)
      goto LABEL_49;
    if (v19 != 65359)
    {
LABEL_74:
      v26 = 0;
      v24 = 0u;
      v25 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v24, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v24 + 16))(&v24, "Unrecognized/unimplemented marker code, ");
      print_marker_code(*((unsigned __int16 *)this + 8), (kdu_message *)&v24);
      (*(void (**)(__int128 *, const char *))(v24 + 16))(&v24, ", found in code-stream.");
      kdu_warning::~kdu_warning((kdu_warning *)&v24);
      LOWORD(v19) = *((_WORD *)this + 8);
LABEL_49:
      if ((v19 & 0xFFFE) == 0xFF90)
      {
        v20 = *((_DWORD *)this + 5);
      }
      else
      {
        if ((kd_input::get(*(kd_input **)this, &v27) & 1) == 0)
        {
          result = 0;
          goto LABEL_63;
        }
        *((_DWORD *)this + 5) = v27 << 8;
        if ((kd_input::get(*(kd_input **)this, &v27) & 1) == 0)
          goto LABEL_70;
        v20 = *((_DWORD *)this + 5) + v27;
        *((_DWORD *)this + 5) = v20;
      }
      v21 = v20 - 2;
      *((_DWORD *)this + 5) = v20 - 2;
      if (v20 <= 1)
        goto LABEL_70;
      if (v21 <= *((_DWORD *)this + 6))
      {
        v23 = (unsigned __int8 *)*((_QWORD *)this + 4);
      }
      else
      {
        *((_DWORD *)this + 6) = 2 * v21;
        v22 = *((_QWORD *)this + 4);
        if (v22)
          MEMORY[0x18D761C18](v22, 0x1000C8077774924);
        v23 = (unsigned __int8 *)operator new[]();
        *((_QWORD *)this + 4) = v23;
        v21 = *((_DWORD *)this + 5);
      }
      if ((int)kd_input::read(*(kd_input **)this, v23, v21) < *((_DWORD *)this + 5))
      {
LABEL_70:
        result = 0;
        *((_WORD *)this + 8) = 0;
        *((_DWORD *)this + 5) = 0;
        return result;
      }
      return 1;
    }
  }
  return result;
}

void sub_187F0D2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_warning::~kdu_warning((kdu_warning *)&a9);
  _Unwind_Resume(a1);
}

void kd_pp_markers::~kd_pp_markers(kd_pp_markers *this)
{
  uint64_t i;
  uint64_t v3;

  for (i = *((_QWORD *)this + 1); i; i = *((_QWORD *)this + 1))
  {
    *((_QWORD *)this + 1) = *(_QWORD *)(i + 48);
    v3 = *(_QWORD *)(i + 32);
    if (v3)
      MEMORY[0x18D761C18](v3, 0x1000C8077774924);
    MEMORY[0x18D761C30](i, 0x1030C406C6F31B6);
  }
}

uint64_t kd_pp_markers::add_marker(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  int v6;
  int v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  char v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  if (*(int *)(a2 + 20) <= 0)
  {
    v14 = 0;
    v12 = 0u;
    v13 = 0u;
    kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "PPM/PPT marker segments must be at least 3 bytes long!");
    kdu_error::~kdu_error((kdu_error *)&v12);
  }
  v4 = operator new();
  result = kd_marker::kd_marker(v4, a2);
  *(_QWORD *)(v4 + 48) = 0;
  v6 = **(unsigned __int8 **)(v4 + 32);
  *(_DWORD *)(v4 + 56) = v6;
  *(_DWORD *)(v4 + 60) = 1;
  v7 = *(unsigned __int16 *)(v4 + 16);
  if (v7 == 65376)
  {
    v8 = *(_QWORD *)(a1 + 8);
    if (v8)
    {
      if (!*(_BYTE *)a1)
        kd_pp_markers::add_marker();
      v9 = 1;
      goto LABEL_10;
    }
    v11 = 1;
LABEL_18:
    *(_BYTE *)a1 = v11;
    *(_QWORD *)(v4 + 48) = 0;
LABEL_19:
    *(_QWORD *)(a1 + 8) = v4;
    return result;
  }
  if (v7 != 65377)
    kd_pp_markers::add_marker();
  v8 = *(_QWORD *)(a1 + 8);
  if (!v8)
  {
    v11 = 0;
    goto LABEL_18;
  }
  v9 = *(_BYTE *)a1;
  if (*(_BYTE *)a1)
    kd_pp_markers::add_marker();
LABEL_10:
  *(_BYTE *)a1 = v9;
  if (*(_DWORD *)(v8 + 56) <= v6)
  {
    while (1)
    {
      v10 = v8;
      v8 = *(_QWORD *)(v8 + 48);
      if (!v8)
        break;
      if (*(_DWORD *)(v8 + 56) > v6)
        goto LABEL_14;
    }
    *(_QWORD *)(v4 + 48) = 0;
  }
  else
  {
    v10 = 0;
LABEL_14:
    *(_QWORD *)(v4 + 48) = v8;
    if (!v10)
      goto LABEL_19;
  }
  *(_QWORD *)(v10 + 48) = v4;
  if (*(_DWORD *)(v10 + 56) == v6)
  {
    v14 = 0;
    v12 = 0u;
    v13 = 0u;
    kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v12 + 16))(&v12, "Found multiple PPM/PPT marker segments with identical Zppt/Zppm indices within the same header scope (main or tile-part header)!");
    kdu_error::~kdu_error((kdu_error *)&v12);
  }
  return result;
}

void sub_187F0D520(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F0D52C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

kd_pp_markers *kd_pp_markers::transfer_tpart(kd_pp_markers *this, kd_pph_input *a2)
{
  kd_pp_markers *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _BOOL4 v13;
  BOOL v14;
  uint64_t v15;
  int v16;
  int v17;
  BOOL v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v3 = this;
  v4 = *((_QWORD *)this + 1);
  if (*(_BYTE *)this)
  {
    if (!v4)
    {
      v21 = 0;
      v19 = 0u;
      v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Insufficient packet header data in PPM marker segments!");
      kdu_error::~kdu_error((kdu_error *)&v19);
    }
    v5 = *(_DWORD *)(v4 + 60);
    v6 = *(_DWORD *)(v4 + 20);
    if (v5 == v6)
      kd_pp_markers::advance_list(this);
    if (v6 - v5 <= 3)
    {
      v21 = 0;
      v19 = 0u;
      v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Encountered malformed PPM marker: 4-byte Nppm values may not straddle multiple PPM marker segments.  Problem is most likely due to a previously incorrect Nppm value.");
      kdu_error::~kdu_error((kdu_error *)&v19);
    }
    v7 = *(_QWORD *)(v4 + 32);
    v8 = v5 + 1;
    *(_DWORD *)(v4 + 60) = v8;
    v9 = *(unsigned __int8 *)(v7 + v5);
    v10 = v5 + 2;
    *(_DWORD *)(v4 + 60) = v10;
    LODWORD(v8) = (v9 << 16) | (*(unsigned __int8 *)(v7 + v8) << 8);
    v11 = v5 + 3;
    *(_DWORD *)(v4 + 60) = v11;
    LODWORD(v8) = v8 | *(unsigned __int8 *)(v7 + v10);
    *(_DWORD *)(v4 + 60) = v5 + 4;
    v12 = *(unsigned __int8 *)(v7 + v11) | ((_DWORD)v8 << 8);
  }
  else
  {
    v12 = 0x7FFFFFFF;
  }
  v13 = v12 > 0;
  if (v4)
    v14 = v12 < 1;
  else
    v14 = 1;
  if (!v14)
  {
    do
    {
      v15 = *(int *)(v4 + 60);
      if (*(_DWORD *)(v4 + 20) - (int)v15 >= v12)
        v16 = v12;
      else
        v16 = *(_DWORD *)(v4 + 20) - v15;
      this = (kd_pp_markers *)kd_pph_input::add_bytes((uint64_t)a2, (char *)(*(_QWORD *)(v4 + 32) + v15), v16);
      v4 = *((_QWORD *)v3 + 1);
      v17 = *(_DWORD *)(v4 + 60) + v16;
      *(_DWORD *)(v4 + 60) = v17;
      if (v17 == *(_DWORD *)(v4 + 20))
        kd_pp_markers::advance_list(v3);
      v12 -= v16;
      v13 = v12 > 0;
    }
    while (v4 && v12 > 0);
  }
  if (*(_BYTE *)v3)
    v18 = !v13;
  else
    v18 = 1;
  if (!v18)
  {
    v21 = 0;
    v19 = 0u;
    v20 = 0u;
    kdu_error::kdu_error((kdu_error *)&v19, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v19 + 16))(&v19, "Insufficient packet header data in PPM marker segments, or else Nppm values must be incorrect!");
    kdu_error::~kdu_error((kdu_error *)&v19);
  }
  return this;
}

void sub_187F0D774(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F0D780()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kd_pp_markers::advance_list(kd_pp_markers *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 1);
  if (v1 && *(_DWORD *)(v1 + 60) == *(_DWORD *)(v1 + 20))
  {
    *((_QWORD *)this + 1) = *(_QWORD *)(v1 + 48);
    v2 = *(_QWORD *)(v1 + 32);
    if (v2)
      MEMORY[0x18D761C18](v2, 0x1000C8077774924);
    JUMPOUT(0x18D761C30);
  }
  kd_pp_markers::advance_list();
}

kd_pp_markers *kd_pp_markers::ignore_tpart(kd_pp_markers *this)
{
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  BOOL v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  if (*(_BYTE *)this)
  {
    v1 = 0;
    v2 = 0x7FFFFFFF;
    do
    {
      v3 = *((_QWORD *)this + 1);
      if (!v3)
      {
        v16 = 0;
        v14 = 0u;
        v15 = 0u;
        kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Insufficient packet header data in PPM marker segments!");
        kdu_error::~kdu_error((kdu_error *)&v14);
      }
      v4 = *(int *)(v3 + 60);
      if ((_DWORD)v4 == *(_DWORD *)(v3 + 20))
        kd_pp_markers::advance_list(this);
      v5 = *(_QWORD *)(v3 + 32);
      *(_DWORD *)(v3 + 60) = v4 + 1;
      v2 = *(unsigned __int8 *)(v5 + v4) | (v2 << 8);
      ++v1;
    }
    while (v1 != 4);
  }
  else
  {
    v2 = 0x7FFFFFFF;
  }
  v6 = *((_QWORD *)this + 1);
  v7 = v2 > 0;
  if (v6)
    v8 = v2 < 1;
  else
    v8 = 1;
  if (!v8)
  {
    do
    {
      v9 = *(_DWORD *)(v6 + 20);
      v10 = *(_DWORD *)(v6 + 60);
      if (v9 - v10 >= v2)
        v11 = v2;
      else
        v11 = v9 - v10;
      v12 = v11 + v10;
      *(_DWORD *)(v6 + 60) = v12;
      if (v12 == v9)
        kd_pp_markers::advance_list(this);
      v2 -= v11;
      v7 = v2 > 0;
    }
    while (v6 && v2 > 0);
  }
  if (*(_BYTE *)this)
    v13 = !v7;
  else
    v13 = 1;
  if (!v13)
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v14 + 16))(&v14, "Insufficient packet header data in PPM marker segments, or else Nppm values must be incorrect!");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  return this;
}

void sub_187F0D9AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F0D9B8()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL kd_tlm_generator::init(kd_tlm_generator *this, int a2, int a3)
{
  uint64_t v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  uint64_t v14;

  *((_DWORD *)this + 3) = 0;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 3) = 0;
  v6 = *((_QWORD *)this + 4);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x1000C80CE7E837CLL);
  v7 = 0;
  v8 = 0;
  if (a3 >= 255)
    v9 = 255;
  else
    v9 = a3;
  if (a3 < 0)
    v9 = 1;
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = v9;
  v10 = v9 * a2;
  *(_QWORD *)((char *)this + 12) = v10;
  *((_QWORD *)this + 3) = 0;
  v11 = v10;
  do
  {
    if (v11 >= 10921)
      v12 = 10921;
    else
      v12 = v11;
    v11 -= v12;
    v7 += 6 * v12 + 6;
    if (v11 < 1)
      break;
  }
  while (v8++ < 0xFE);
  *((_DWORD *)this + 2) = v7;
  if (v11 < 1)
  {
    *((_QWORD *)this + 4) = operator new[]();
  }
  else
  {
    *((_DWORD *)this + 3) = 0;
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 3) = 0;
    v14 = *((_QWORD *)this + 4);
    if (v14)
      MEMORY[0x18D761C18](v14, 0x1000C80CE7E837CLL);
  }
  return v11 < 1;
}

uint64_t kd_tlm_generator::add_tpart_length(uint64_t this, unsigned int a2, unint64_t a3)
{
  int v3;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  if (*(int *)this >= 1)
  {
    v3 = *(_DWORD *)(this + 16);
    if (v3 >= *(_DWORD *)(this + 12))
      kd_tlm_generator::add_tpart_length();
    if ((a2 & 0x80000000) != 0 || *(_DWORD *)this <= a2)
      kd_tlm_generator::add_tpart_length();
    v4 = *(_QWORD *)(this + 32) + 8 * v3;
    *(_WORD *)v4 = a2;
    *(_DWORD *)(v4 + 4) = a3;
    if (HIDWORD(a3))
    {
      v6 = 0;
      memset(v5, 0, sizeof(v5));
      kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v5[0] + 16))(v5, "Attempting to write TLM (tile-part length) data where one tile-part's length cannot be represented as an unsigned 32-bit value.");
      kdu_error::~kdu_error((kdu_error *)v5);
    }
    *(_DWORD *)(this + 16) = v3 + 1;
    *(_QWORD *)(this + 24) += a3;
  }
  return this;
}

void sub_187F0DBB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F0DBC0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

int *kd_tlm_generator::write_dummy_tlms(int *this, kd_compressed_output *a2)
{
  int *v3;
  int v4;
  void *v5;
  int v6;
  int v7;
  int v8;
  int v9;

  if (*this >= 1)
  {
    v3 = this;
    v4 = this[3];
    v5 = (void *)operator new[]();
    bzero(v5, 0xFFFFuLL);
    v6 = 0;
    v7 = 0;
    while (v6 != 256)
    {
      if (v4 >= 10921)
        v8 = 10921;
      else
        v8 = v4;
      v4 -= v8;
      v9 = 6 * v8;
      v7 += 6 * v8 + 6;
      kdu_output::put(a2, 255);
      kdu_output::put(a2, 85);
      kdu_output::put(a2, (unsigned __int16)(v9 + 4) >> 8);
      kdu_output::put(a2, (v9 + 4) & 0xFE);
      kdu_output::put(a2, v6);
      kdu_output::put(a2, 96);
      ++v6;
      kdu_output::write(a2, (char *)v5, v9);
      if (v4 <= 0)
      {
        if (v7 == v3[2])
          JUMPOUT(0x18D761C18);
        kd_tlm_generator::write_dummy_tlms();
      }
    }
    kd_tlm_generator::write_dummy_tlms();
  }
  return this;
}

void kd_tlm_generator::write_tlms(kd_tlm_generator *this, kdu_compressed_target *a2, int a3, uint64_t a4)
{
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  BOOL v12;
  int v13;
  int v14;
  __int16 *v15;
  int v16;
  int v17;
  unsigned __int16 v18;
  int v19;
  int v20;
  const char *v21;
  uint64_t v22;
  _BYTE v23[520];
  _QWORD v24[7];

  v24[4] = *MEMORY[0x1E0C80C00];
  if (*(int *)this >= 1)
  {
    v7 = *((_QWORD *)this + 3) + a4 + *((int *)this + 2);
    v8 = *((_DWORD *)this + 1) * a3;
    if (v8 < 1)
    {
      v10 = 0;
      v9 = 0;
    }
    else
    {
      v9 = 0;
      v10 = 0;
      do
      {
        if (!v9)
        {
          if (v10 >= 256)
            kd_tlm_generator::write_tlms();
          v7 -= 6;
          ++v10;
          v9 = 10921;
        }
        if (v8 >= v9)
          v11 = v9;
        else
          v11 = v8;
        v9 -= v11;
        v7 -= 6 * v11;
        v12 = __OFSUB__(v8, v11);
        v8 -= v11;
      }
      while (!((v8 < 0) ^ v12 | (v8 == 0)));
    }
    if (((*(uint64_t (**)(kdu_compressed_target *, uint64_t))(*(_QWORD *)a2 + 24))(a2, v7) & 1) == 0)
    {
      memset(v23, 0, 40);
      kdu_error::kdu_error((kdu_error *)v23, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v23);
    }
    v13 = *((_DWORD *)this + 3);
    v14 = *((_DWORD *)this + 1);
    v15 = (__int16 *)*((_QWORD *)this + 4);
    v22 = operator new[]();
    memset(&v23[8], 0, 512);
    v24[0] = &v23[8];
    v24[1] = v24;
    *(_QWORD *)v23 = &off_1E1BB2150;
    v24[2] = a2;
    v24[3] = 0;
    if (*((int *)this + 4) >= 1)
    {
      v16 = v13 - v14 * a3;
      if (v9 >= v16)
        v17 = v16;
      else
        v17 = v9;
      while (v16 > 0)
      {
        if (!v17)
        {
          if (v10 > 255)
          {
            v20 = 1262;
            v21 = "z_tlm <= 255";
LABEL_34:
            __assert_rtn("write_tlms", "codestream.cpp", v20, v21);
          }
          if (v16 >= 0x2AA9)
            v17 = 10921;
          else
            v17 = v16;
          kdu_output::put((kdu_output *)v23, 255);
          kdu_output::put((kdu_output *)v23, 85);
          kdu_output::put((kdu_output *)v23, (unsigned __int16)(6 * v17 + 4) >> 8);
          kdu_output::put((kdu_output *)v23, 6 * v17 + 4);
          kdu_output::put((kdu_output *)v23, v10);
          kdu_output::put((kdu_output *)v23, 96);
          ++v10;
        }
        v18 = *v15;
        kdu_output::put((kdu_output *)v23, HIBYTE(*v15));
        kdu_output::put((kdu_output *)v23, v18);
        kdu_output::put((kdu_output *)v23, *((_DWORD *)v15 + 1));
        v19 = *((_DWORD *)this + 4);
        --v17;
        --v16;
        v15 += 4;
        v12 = __OFSUB__(v19--, 1);
        *((_DWORD *)this + 4) = v19;
        if ((v19 < 0) ^ v12 | (v19 == 0))
          goto LABEL_29;
      }
      v20 = 1259;
      v21 = "elts_left > 0";
      goto LABEL_34;
    }
LABEL_29:
    MEMORY[0x18D761C18](v22, 0x1000C8077774924);
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 16))((uint64_t)v23);
    (*(void (**)(kdu_compressed_target *))(*(_QWORD *)a2 + 32))(a2);
    kd_compressed_output::~kd_compressed_output((kd_compressed_output *)v23);
  }
}

void sub_187F0E064(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F0E070(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

void kd_tpart_pointer_server::~kd_tpart_pointer_server(kd_tpart_pointer_server *this)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  for (i = *(_QWORD *)this; *(_QWORD *)this; i = *(_QWORD *)this)
  {
    *(_QWORD *)this = *(_QWORD *)(i + 48);
    v3 = *(_QWORD *)(i + 32);
    if (v3)
      MEMORY[0x18D761C18](v3, 0x1000C8077774924);
    MEMORY[0x18D761C30](i, 0x1030C40DF1BA421);
  }
  while (1)
  {
    v4 = *((_QWORD *)this + 1);
    if (!v4)
      break;
    *((_QWORD *)this + 1) = *(_QWORD *)(v4 + 512);
    MEMORY[0x18D761C30]();
  }
}

uint64_t kd_tpart_pointer_server::add_tlm_marker(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  int v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  *((_BYTE *)a1 + 24) = 0;
  if (*(__int16 *)(a2 + 16) != -171)
    kd_tpart_pointer_server::add_tlm_marker();
  if (*(int *)(a2 + 20) <= 3)
  {
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "TLM marker segments must be at least 6 bytes long!");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  v4 = operator new();
  result = kd_marker::kd_marker(v4, a2);
  *(_QWORD *)(v4 + 48) = 0;
  v6 = **(unsigned __int8 **)(v4 + 32);
  *(_DWORD *)(v4 + 56) = v6;
  v7 = *a1;
  if (!*a1)
  {
    *(_QWORD *)(v4 + 48) = 0;
LABEL_12:
    *a1 = v4;
    return result;
  }
  if (*(_DWORD *)(v7 + 56) <= v6)
  {
    while (1)
    {
      v8 = v7;
      v7 = *(_QWORD *)(v7 + 48);
      if (!v7)
        break;
      if (*(_DWORD *)(v7 + 56) > v6)
        goto LABEL_9;
    }
    *(_QWORD *)(v4 + 48) = 0;
  }
  else
  {
    v8 = 0;
LABEL_9:
    *(_QWORD *)(v4 + 48) = v7;
    if (!v8)
      goto LABEL_12;
  }
  *(_QWORD *)(v8 + 48) = v4;
  if (*(_DWORD *)(v8 + 56) == v6)
  {
    v11 = 0;
    v9 = 0u;
    v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v9 + 16))(&v9, "Found multiple TLM marker segments with identical Ztlm indices within the main header!");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  return result;
}

void sub_187F0E298(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F0E2A4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

_QWORD *kd_tpart_pointer_server::add_tpart(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;
  _QWORD *v7;
  unsigned int i;
  _QWORD *v9;
  _QWORD *v10;

  result = *(_QWORD **)(a1 + 16);
  if (!result)
  {
    result = (_QWORD *)operator new();
    result[64] = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 8) = result;
    v7 = result + 2;
    for (i = 32; i > 1; --i)
    {
      *(v7 - 1) = v7;
      v7 += 2;
    }
    *(v7 - 1) = *(_QWORD *)(a1 + 16);
  }
  *(_QWORD *)(a1 + 16) = result[1];
  *result = a3;
  result[1] = 0;
  v9 = a2 + 1;
  if (*a2)
  {
    if (!*v9)
      kd_tpart_pointer_server::add_tpart();
    v10 = (_QWORD *)(*v9 + 8);
  }
  else
  {
    v10 = a2 + 1;
    v9 = a2;
  }
  *v10 = result;
  *v9 = result;
  return result;
}

uint64_t *kd_tpart_pointer_server::translate_markers(uint64_t *result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  char v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  if (result[1])
    kd_tpart_pointer_server::translate_markers();
  v4 = (uint64_t)result;
  v5 = *result;
  if (*result)
  {
    v9 = -1;
    do
    {
      v10 = *(_QWORD *)(v5 + 32);
      v11 = *(unsigned __int8 *)(v10 + 1);
      v12 = (v11 >> 4) & 3;
      v32 = v5;
      if (v12)
      {
        if (v12 == 2)
        {
          v14 = 0;
          v13 = 0;
        }
        else
        {
          if (v12 != 1)
          {
            v35 = 0;
            v33 = 0u;
            v34 = 0u;
            kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, "Illegal Stlm field encountered in TLM marker segment!");
            kdu_error::~kdu_error((kdu_error *)&v33);
          }
          v13 = 0;
          v14 = 1;
        }
      }
      else
      {
        v14 = 0;
        v13 = 1;
      }
      v15 = (unsigned __int8 *)(v10 + 2);
      v16 = *(_DWORD *)(v5 + 20) - 2;
      if ((v11 & 0x40) != 0)
        v17 = 4;
      else
        v17 = 2;
      v18 = v12 + v17;
      v19 = v16 / v18;
      v20 = v16 / v18 * v18;
      if (v19 < 1 || v16 != v20)
      {
        v35 = 0;
        v33 = 0u;
        v34 = 0u;
        kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, "Malformed TLM marker segment encountered in main header.  Segment length is inconsistent with the number of bytes used to represent pointer info for each tile-part.");
        kdu_error::~kdu_error((kdu_error *)&v33);
      }
      while (1)
      {
        if (v13)
        {
          ++v9;
        }
        else
        {
          v9 = *v15;
          if ((v14 & 1) != 0)
          {
            ++v15;
          }
          else
          {
            v22 = v15[1];
            v15 += 2;
            v9 = v22 | (v9 << 8);
          }
        }
        if (v9 >= a3)
        {
          v35 = 0;
          v33 = 0u;
          v34 = 0u;
          kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, "Illegal TLM marker segment data encountered in main header.  An illegal tile number has been identified, either explicitly or implicitly (through the rule that missing tile identifiers are legal only when tiles appear in order with only one tile-part each).");
          kdu_error::~kdu_error((kdu_error *)&v33);
        }
        kd_tpart_pointer_server::add_tpart(v4, (_QWORD *)(a4 + 24 * v9), a2);
        v23 = __rev16(*(unsigned __int16 *)v15);
        if ((v11 & 0x40) != 0)
        {
          v24 = (v23 << 16) | ((unint64_t)v15[2] << 8);
          v25 = v15[3];
          v15 += 4;
          v23 = v24 | v25;
        }
        else
        {
          v15 += 2;
        }
        if (v23 <= 0xD)
          break;
        a2 += v23;
        if (!--v19)
        {
          v26 = 0;
          v27 = v32;
          goto LABEL_33;
        }
      }
      v35 = 0;
      v33 = 0u;
      v34 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v33, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v33 + 16))(&v33, "TLM marker segments contain one or more illegal lengths (< 14 bytes).  Proceeding with incomplete tile-part length information.");
      v27 = v32;
      kdu_warning::~kdu_warning((kdu_warning *)&v33);
      v26 = 1;
LABEL_33:
      *(_QWORD *)v4 = *(_QWORD *)(v27 + 48);
      v28 = *(_QWORD *)(v27 + 32);
      if (v28)
        MEMORY[0x18D761C18](v28, 0x1000C8077774924);
      result = (uint64_t *)MEMORY[0x18D761C30](v27, 0x1030C40DF1BA421);
      v5 = *(_QWORD *)v4;
      if (*(_QWORD *)v4)
        v29 = v26;
      else
        v29 = 1;
    }
    while ((v29 & 1) == 0);
    *(_BYTE *)(v4 + 24) = 1;
    if (a3 >= 1)
    {
      v30 = a3;
      v31 = (_QWORD *)(a4 + 8);
      do
      {
        *v31 = 0;
        v31 += 3;
        --v30;
      }
      while (v30);
    }
  }
  return result;
}

void sub_187F0E68C(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F0E698(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t kd_precinct_pointer_server::add_plt_marker(uint64_t result, uint64_t a2, kdu_params *this, kdu_params *a4)
{
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  unint64_t v14;
  char v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  BOOL v22;
  _DWORD *exception;
  int v24;
  int v25[2];
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  if (*(_QWORD *)result)
  {
    v6 = result;
    v7 = *(unsigned __int8 **)(a2 + 32);
    v8 = *(_DWORD *)(a2 + 20);
    v9 = v8 - 1;
    if (v8 < 1 || (v10 = *v7, v10 != *(unsigned __int8 *)(result + 61)))
    {
      v28 = 0;
      v26 = 0u;
      v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, "PLT marker segments appear out of order within one or more tile-part headers.  While this is not illegal, it is highly inadvisable since it prevents immediate condensation of the pointer information by efficient parsers.  To process this code-stream, you will have to open it again, with file seeking disabled.");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
    *(_BYTE *)(result + 61) = v10 + 1;
    if (*(_DWORD *)(result + 48))
    {
      v28 = 0;
      v26 = 0u;
      v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, "There appears to be a problem with the PLT marker segments included in the input code-stream.  The PLT marker segments encountered so far do not have sufficient length information to describe the lengths of all packets in the tile-parts encountered so far.  To process this code-stream, you will have to open it again, with file seeking disabled.");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
    *(_QWORD *)v25 = 0;
    v24 = 0;
    if (!kdu_params::get(this, "Clayers", 0, 0, v25, 1, 1, 1)
      || (result = kdu_params::get(this, "Corder", 0, 0, &v24, 1, 1, 1), (result & 1) == 0))
    {
      exception = __cxa_allocate_exception(4uLL);
      *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    v11 = *(_DWORD *)(v6 + 56);
    v12 = v25[0];
    if (v11)
    {
      if (v11 != v25[0])
      {
LABEL_16:
        result = (uint64_t)kd_precinct_pointer_server::disable((uint64_t *)v6);
        if (*(_BYTE *)(v6 + 60))
        {
          v28 = 0;
          v26 = 0u;
          v27 = 0u;
          kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
          (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, "Unexpected change in coding parameters or packet sequencing detected while parsing packet length information in PLT marker segments.  While this is not illegal, it is highly inadvisable.  To process this code-stream, open it again with file seeking disabled!");
          kdu_error::~kdu_error((kdu_error *)&v26);
        }
        return result;
      }
    }
    else
    {
      *(_DWORD *)(v6 + 56) = v25[0];
    }
    if (v12 >= 2)
    {
      if (v24 < 2)
        goto LABEL_16;
      result = kdu_params::get(a4, "Porder", 0, 0, &v25[1], 1, 1, 1);
      if ((_DWORD)result)
        goto LABEL_16;
    }
    if (!*(_QWORD *)(v6 + 8))
    {
      result = *(_QWORD *)v6;
      if (*(_QWORD *)v6)
      {
        result = kd_buf_server::get((kd_buf_server *)result);
        *(_QWORD *)(v6 + 8) = result;
        *(_QWORD *)(v6 + 16) = result;
      }
    }
    if (v8 >= 2)
    {
      v13 = (char *)(v7 + 1);
      do
      {
        if (!*(_DWORD *)(v6 + 72))
        {
          *(_DWORD *)(v6 + 72) = *(_DWORD *)(v6 + 56);
          *(_QWORD *)(v6 + 64) = 0;
        }
        v14 = 0;
        do
        {
          if (!v9)
          {
            v28 = 0;
            v26 = 0u;
            v27 = 0u;
            kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v26 + 16))(&v26, "Malformed PLT marker segment encountered in tile-part header.  Segment terminates part of the way through a multi-byte packet length specification!");
            kdu_error::~kdu_error((kdu_error *)&v26);
          }
          v15 = *v13++;
          --v9;
          v16 = v15 & 0x7F | (v14 << 7);
          v14 = v16;
        }
        while (v15 < 0);
        v17 = *(_QWORD *)(v6 + 64) + v16;
        *(_QWORD *)(v6 + 64) = v17;
        v18 = *(_DWORD *)(v6 + 72) - 1;
        *(_DWORD *)(v6 + 72) = v18;
        if (!v18)
        {
          v19 = 0;
          do
          {
            v20 = v17 >> v19;
            v19 += 7;
          }
          while (v20 > 127);
          v21 = v19 - 7;
          do
          {
            result = kd_precinct_pointer_server::record_byte((kd_precinct_pointer_server *)v6, (*(uint64_t *)(v6 + 64) >> v21) & 0x7Fu | ((v21 != 0) << 7));
            v22 = v21 <= 6;
            v21 -= 7;
          }
          while (!v22);
          ++*(_DWORD *)(v6 + 32);
        }
      }
      while (v9 + 1 > 1);
    }
  }
  return result;
}

void sub_187F0EA08(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F0EA14(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

uint64_t kd_precinct_pointer_server::record_byte(kd_precinct_pointer_server *this, char a2)
{
  uint64_t result;
  int v5;

  result = *((_QWORD *)this + 2);
  if (!result)
    kd_precinct_pointer_server::record_byte();
  v5 = *((_DWORD *)this + 7);
  if (v5 == 55)
  {
    result = kd_buf_server::get(*(kd_buf_server **)this);
    v5 = 0;
    **((_QWORD **)this + 2) = result;
    *((_QWORD *)this + 2) = result;
  }
  *((_DWORD *)this + 7) = v5 + 1;
  *(_BYTE *)(result + v5 + 9) = a2;
  return result;
}

uint64_t *kd_precinct_pointer_server::start_tpart_body(uint64_t *this, uint64_t a2, int a3, kdu_params *a4, kdu_params *a5, char a6, char a7)
{
  char v7;
  uint64_t *v8;
  _OWORD v14[2];
  uint64_t v15;
  int v16;
  int v17;
  int v18;

  v7 = a7 ^ 1;
  *((_BYTE *)this + 61) = 0;
  if (a3)
    v7 = 0;
  if ((v7 & 1) == 0)
  {
    v8 = this;
    if (*this)
    {
      if (this[1] || *((_BYTE *)this + 60))
      {
        v18 = 0;
        v16 = 0;
        v17 = 0;
        if ((a6 & 1) != 0
          || (this = (uint64_t *)kdu_params::get(a4, "Clayers", 0, 0, &v17, 1, 1, 1), !(_DWORD)this)
          || v17 != *((_DWORD *)v8 + 14)
          || v17 >= 2
          && ((kdu_params::get(a5, "Porder", 0, 0, &v18, 1, 1, 1) & 1) != 0
           || (this = (uint64_t *)kdu_params::get(a4, "Corder", 0, 0, &v16, 1, 1, 1), !(_DWORD)this)
           || v16 <= 1))
        {
          this = kd_precinct_pointer_server::disable(v8);
          if (*((_BYTE *)v8 + 60))
          {
            v15 = 0;
            memset(v14, 0, sizeof(v14));
            kdu_error::kdu_error((kdu_error *)v14, "Kakadu Core Error:\n");
            (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v14[0] + 16))(v14, "Unexpected change in coding parameters or packet sequencing detected after parsing packet length information in PLT marker segments.  While this is not illegal, it is highly inadvisable.  To process this code-stream, open it again with file seeking disabled!");
            kdu_error::~kdu_error((kdu_error *)v14);
          }
        }
        v8[5] = a2;
        *((_DWORD *)v8 + 12) = a3;
        *((_BYTE *)v8 + 52) = a7;
      }
      else
      {
        return kd_precinct_pointer_server::disable(this);
      }
    }
  }
  return this;
}

void sub_187F0EC50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F0EC5C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_precinct_pointer_server::pop_address(kd_precinct_pointer_server *this)
{
  int64_t v2;
  char byte;
  uint64_t v4;
  uint64_t result;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  if (!*(_QWORD *)this)
    return 0;
  if (!*((_DWORD *)this + 8) && !*((_BYTE *)this + 52) && *((_DWORD *)this + 12))
  {
    v8 = 0;
    v6 = 0u;
    v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "Unexpectedly ran out of packet length information while processing tile-parts.  Most likely cause is that PLT marker segments are malformed, incomplete, or do not appear until after the packets whose lengths they describe.  All of these conditions are violations of the standard!");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (!*((_DWORD *)this + 12) && !*((_BYTE *)this + 52))
    return -1;
  v2 = 0;
  do
  {
    if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2) && *((_DWORD *)this + 6) >= *((_DWORD *)this + 7))
    {
      v8 = 0;
      v6 = 0u;
      v7 = 0u;
      kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "kd_precinct_pointer_server runs into file corruption");
      kdu_error::~kdu_error((kdu_error *)&v6);
    }
    byte = kd_precinct_pointer_server::retrieve_byte(this);
    v2 = byte & 0x7F | (unint64_t)(v2 << 7);
  }
  while (byte < 0);
  --*((_DWORD *)this + 8);
  if (!*((_BYTE *)this + 52))
  {
    v4 = *((unsigned int *)this + 12);
    if (v2 > v4)
    {
      v8 = 0;
      v6 = 0u;
      v7 = 0u;
      kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v6 + 16))(&v6, "Tile-part holds some but not all the packets of a precinct for which PLT information is being used to extract precinct addresses for random access.  In particular, the current tile has its packets sequenced so that all packets of any given precinct appear consecutively and yet a tile-part boundary has been inserted between the packets of a precinct.  While this is not illegal, it indicates very poor judgement in the placement of tile-part boundaries.  To process this code-stream, you will have to open it again with file seeking disabled.");
      kdu_error::~kdu_error((kdu_error *)&v6);
    }
    *((_DWORD *)this + 12) = v4 - v2;
  }
  *((_BYTE *)this + 60) = 1;
  result = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = result + v2;
  return result;
}

void sub_187F0EE0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F0EE18()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_precinct_pointer_server::retrieve_byte(kd_precinct_pointer_server *this)
{
  _QWORD *v2;
  int v3;

  v2 = (_QWORD *)*((_QWORD *)this + 1);
  v3 = *((_DWORD *)this + 6);
  if (v2 != *((_QWORD **)this + 2))
  {
    if (v3 != 55)
      goto LABEL_7;
    goto LABEL_6;
  }
  if (v3 == 55 && *((int *)this + 7) > 55)
  {
LABEL_6:
    *((_QWORD *)this + 1) = *v2;
    *((_DWORD *)this + 6) = 0;
    kd_buf_server::release(*(_QWORD *)this, (uint64_t)v2);
    v2 = (_QWORD *)*((_QWORD *)this + 1);
    v3 = *((_DWORD *)this + 6);
  }
LABEL_7:
  *((_DWORD *)this + 6) = v3 + 1;
  return *((unsigned __int8 *)v2 + v3 + 9);
}

void kd_buf_server::~kd_buf_server(kd_buf_server *this)
{
  _QWORD *v2;
  __int128 v3;
  __int128 v4;
  uint64_t v5;

  if (*((_DWORD *)this + 16))
    __assert_rtn("~kd_buf_server", "codestream.cpp", 1690, "num_users == 0");
  if (*((_QWORD *)this + 3))
  {
    v5 = 0;
    v3 = 0u;
    v4 = 0u;
    kdu_warning::kdu_warning((kdu_warning *)&v3, "Kakadu Core Warning:\n");
    (*(void (**)(__int128 *, const char *))(v3 + 16))(&v3, "The compressed data buffer server is being destroyed before all allocated buffers have been returned.  The problem is most likely connected with a bug in the code-block destruction code.");
    kdu_warning::~kdu_warning((kdu_warning *)&v3);
  }
  if (*((_QWORD *)this + 5))
  {
    v5 = 0;
    v3 = 0u;
    v4 = 0u;
    kdu_warning::kdu_warning((kdu_warning *)&v3, "Kakadu Core Warning:\n");
    (*(void (**)(__int128 *, const char *))(v3 + 16))(&v3, "The compressed data buffer server is being destroyed before all size accounting associated with fixed data structures has been completed.  This is most likely due to a bug in the memory accounting logic used for dynamic cache management.");
    kdu_warning::~kdu_warning((kdu_warning *)&v3);
  }
  while (1)
  {
    v2 = *(_QWORD **)this;
    if (!*(_QWORD *)this)
      break;
    *(_QWORD *)this = *v2;
    free(v2);
  }
}

_QWORD *kd_buf_server::alloc_pages(kd_buf_server *this)
{
  _QWORD *result;
  _QWORD *v3;
  uint64_t v4;
  unsigned int v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _BYTE *v11;
  BOOL v12;

  result = malloc_type_malloc(0x4108uLL, 0xA483F4B5uLL);
  v3 = (_QWORD *)*((_QWORD *)this + 1);
  *result = *(_QWORD *)this;
  *(_QWORD *)this = result;
  v4 = -(char)((_BYTE)result + 8);
  v5 = 16640 - -(char)((_BYTE)result + 8);
  v6 = (_QWORD *)((char *)result + v4 + 8);
  v7 = *((_QWORD *)this + 2);
  v8 = (uint64_t)result + v4 + 16;
  do
  {
    v9 = 0;
    v10 = v6;
    v11 = (_BYTE *)v8;
    do
    {
      *((_QWORD *)v11 - 1) = 0;
      *v11 = v9;
      v11 += 64;
      ++v9;
    }
    while (v9 != 4);
    *v10 = v3;
    ++v7;
    v6 = v10 + 32;
    v8 += 256;
    v3 = v10;
    v12 = v5 > 0x1FF;
    v5 -= 256;
  }
  while (v12);
  *((_QWORD *)this + 1) = v10;
  *((_QWORD *)this + 2) = v7;
  return result;
}

uint64_t *kd_buf_server::get_page_block(kd_buf_server *this, int a2, uint64_t **a3)
{
  int v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *result;
  uint64_t v19;

  *a3 = 0;
  if (a2 < 1)
  {
    result = 0;
  }
  else
  {
    v5 = a2;
    v6 = 0;
    v7 = 0;
    v8 = (uint64_t *)*((_QWORD *)this + 1);
    do
    {
      v9 = v8;
      if (!v8)
      {
        kd_buf_server::alloc_pages(this);
        v7 = 0;
        v9 = (uint64_t *)*((_QWORD *)this + 1);
      }
      v10 = 0;
      v8 = (uint64_t *)*v9;
      v11 = v9[1] & 0x7F;
      v12 = &v9[-8 * v11];
      do
      {
        if (SLOBYTE(v9[v10 + 1 + -8 * v11]) < 0)
        {
          v7 = v9;
          result = (uint64_t *)v6;
          goto LABEL_17;
        }
        v10 += 8;
      }
      while (v10 != 32);
      v13 = 0;
      v14 = 0;
      if (v7)
        v15 = v7;
      else
        v15 = (_QWORD *)((char *)this + 8);
      *v15 = v8;
      ++*((_QWORD *)this + 3);
      v16 = *a3;
      do
      {
        v17 = &v12[v13];
        LOBYTE(v12[v13 + 1]) |= 0x80u;
        result = &v12[v13];
        if (v16)
        {
          *v16 = (uint64_t)v17;
          result = (uint64_t *)v6;
        }
        v16 = &v12[8 * v14];
        *a3 = v17;
        ++v14;
        v13 += 8;
        v6 = (uint64_t)result;
      }
      while (v13 != 32);
      --v5;
      v12[24] = 0;
      v6 = (uint64_t)result;
LABEL_17:
      ;
    }
    while (v5 > 0);
  }
  v19 = *((_QWORD *)this + 3);
  if (v19 > *((_QWORD *)this + 4))
    *((_QWORD *)this + 4) = v19;
  return result;
}

int32x2_t kd_thread_buf_server::augment_local_store(kd_thread_buf_server *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  uint64_t *page_block;
  uint64_t **v11;
  int32x2_t result;
  uint64_t *v13;

  *((_BYTE *)this + 40) = 1;
  v2 = *(_QWORD *)this;
  v3 = *(_QWORD *)(*(_QWORD *)this + 128);
  if (!v3)
    kd_thread_buf_server::augment_local_store();
  v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    v6 = v5 - *((_DWORD *)this + 3);
    if (v6 < 1)
      return result;
  }
  else
  {
    v6 = 4 * *((_DWORD *)this + 4) + 4;
    if (v6 <= 32)
      v6 = 32;
  }
  v7 = (v6 - 1) >> 2;
  v8 = v7 + 1;
  v9 = 4 * (v7 + 1);
  v13 = 0;
  if (a2)
  {
    page_block = kd_buf_server::get_page_block(*(kd_buf_server **)(v3 + 48), v7 + 1, &v13);
  }
  else
  {
    kdu_thread_entity::acquire_lock(*(kdu_thread_entity **)(v2 + 136), 0, 1);
    page_block = kd_buf_server::get_page_block(*(kd_buf_server **)(*(_QWORD *)(*(_QWORD *)this + 128) + 48), v8, &v13);
    kdu_thread_entity::release_lock(*(kdu_thread_entity **)(*(_QWORD *)this + 136), 0);
  }
  v11 = (uint64_t **)*((_QWORD *)this + 4);
  if (!v11)
    v11 = (uint64_t **)((char *)this + 24);
  *v11 = page_block;
  *((_QWORD *)this + 4) = v13;
  result = vadd_s32(*(int32x2_t *)((char *)this + 12), vdup_n_s32(v9));
  *(int32x2_t *)((char *)this + 12) = result;
  return result;
}

uint64_t kd_thread_env::flush(uint64_t this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v6;
  int updated;
  uint64_t v8;
  _BOOL4 v9;
  char v10;
  _QWORD *v11;
  unsigned int i;
  uint64_t v13;
  int v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t *v21;
  unsigned int j;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  kdu_thread_entity *v27;

  v2 = this + 33168;
  v3 = *(_QWORD *)(this + 128);
  v4 = *(_DWORD *)(this + 33208);
  if (v3)
  {
    if (v4 < 1)
      return this;
    v6 = this;
    if (*(_QWORD *)(v3 + 64) && *(_QWORD *)(this + 360))
    {
      kdu_thread_entity::acquire_lock(*(kdu_thread_entity **)(this + 136), 1, 1);
      updated = kd_compressed_stats::update_stats(*(kd_compressed_stats **)(*(_QWORD *)(v6 + 128) + 64), (kd_compressed_stats *)(v6 + 328));
      v8 = *(_QWORD *)(v6 + 128);
      if (updated)
        v9 = *(_BYTE *)(v8 + 422) == 0;
      else
        v9 = 0;
      kd_compressed_stats::update_quant_slope_thresholds(*(_QWORD *)(v8 + 64));
      this = kdu_thread_entity::release_lock(*(kdu_thread_entity **)(v6 + 136), 1);
      if (*(int *)(v2 + 40) < 1)
      {
        if (!v9)
          return this;
        v9 = 1;
        goto LABEL_35;
      }
    }
    else
    {
      v9 = 0;
    }
    kdu_thread_entity::acquire_lock(*(kdu_thread_entity **)(v6 + 136), 2, 1);
    v10 = 0;
    v11 = (_QWORD *)(v2 + 96);
    for (i = 9; i > 1; --i)
    {
      v13 = *(v11 - 1);
      if (v13)
      {
        v14 = *(_DWORD *)(v13 + 36);
        if (v14 <= 0)
          kd_thread_env::flush();
        if (v14 == 1)
        {
          v10 = 1;
        }
        else
        {
          if (!*(_QWORD *)(*(_QWORD *)(v6 + 128) + 8))
          {
            v15 = v11 - 6;
            v16 = *v11;
            v17 = *(v11 - 6);
            *(_QWORD *)v16 = v17;
            *(_QWORD *)(v16 + 8) = v17;
            *(_DWORD *)(v16 + 16) = *((_DWORD *)v11 - 8);
            *v15 = 0;
            v15[1] = 0;
            v13 = *(v11 - 1);
            v14 = *(_DWORD *)(v13 + 36);
          }
          *(_DWORD *)(v13 + 36) = v14 - 1;
          *(v11 - 1) = 0;
          *v11 = 0;
          --*(_DWORD *)(v2 + 40);
        }
      }
      v11 += 7;
    }
    this = kdu_thread_entity::release_lock(*(kdu_thread_entity **)(v6 + 136), 2);
    if (*(_DWORD *)(v2 + 40))
    {
      if ((v10 & 1) == 0)
        kd_thread_env::flush();
      v18 = 1;
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(v6 + 136) + 88) = 0;
      v18 = v10 & 1;
    }
    if (*(_BYTE *)(v2 + 32))
    {
      v19 = *(_DWORD *)(v2 + 4);
      v20 = 4 * (*(_DWORD *)(v2 + 8) - v19);
      if (v20 > *(_DWORD *)v2)
        *(_DWORD *)v2 = v20;
      *(_DWORD *)(v2 + 8) = v19;
    }
    if (((v9 | v18) & 1) != 0)
    {
      if ((v9 | a2) != 1)
      {
        this = kdu_thread_entity::try_lock(*(kdu_thread_entity **)(v6 + 136), 0, 1);
        v9 = 0;
        if (!(_DWORD)this)
          return this;
        goto LABEL_36;
      }
LABEL_35:
      kdu_thread_entity::acquire_lock(*(kdu_thread_entity **)(v6 + 136), 0, 1);
LABEL_36:
      v21 = (uint64_t *)(v2 + 48);
      for (j = 9; j > 1; --j)
      {
        v23 = v21[5];
        if (v23)
        {
          if (!*(_QWORD *)(*(_QWORD *)(v6 + 128) + 8))
          {
            v24 = v21[6];
            v25 = *v21;
            *(_QWORD *)v24 = *v21;
            *(_QWORD *)(v24 + 8) = v25;
            *(_DWORD *)(v24 + 16) = *((_DWORD *)v21 + 4);
            *v21 = 0;
            v21[1] = 0;
          }
          if (*(_DWORD *)(v23 + 36) != 1)
            kd_thread_env::flush();
          *(_DWORD *)(v23 + 36) = 0;
          v21[5] = 0;
          v21[6] = 0;
          --*(_DWORD *)(v2 + 40);
          v26 = *(_QWORD *)(v6 + 128);
          if (*(_QWORD *)(v26 + 8))
          {
            kd_precinct::release((uint64_t *)v23);
          }
          else if (*(_QWORD *)(v26 + 16))
          {
            kd_global_rescomp::add_ready_precinct(*(_QWORD *)(*(_QWORD *)v23 + 16), (_QWORD *)v23);
          }
        }
        v21 += 7;
      }
      v27 = *(kdu_thread_entity **)(v6 + 136);
      *((_BYTE *)v27 + 88) = 0;
      if (v9)
      {
        kdu_thread_entity::acquire_lock(v27, 2, 1);
        kd_codestream::trim_compressed_data(*(_QWORD *)(v6 + 128));
        kdu_thread_entity::release_lock(*(kdu_thread_entity **)(v6 + 136), 2);
      }
      if (*(_BYTE *)(v2 + 32))
        kd_thread_buf_server::augment_local_store((kd_thread_buf_server *)(v6 + 33160), 1);
      this = kdu_thread_entity::release_lock(*(kdu_thread_entity **)(v6 + 136), 0);
      if (*(_DWORD *)(v2 + 40))
        kd_thread_env::flush();
    }
  }
  else if (v4)
  {
    kd_thread_env::flush();
  }
  return this;
}

uint64_t kd_compressed_stats::update_stats(kd_compressed_stats *this, kd_compressed_stats *a2)
{
  int *v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  int v9;
  uint64_t v10;

  v2 = (int *)((char *)a2 + 32808);
  *((_QWORD *)this + 4) += *((_QWORD *)a2 + 4);
  *((_QWORD *)a2 + 4) = 0;
  v3 = *((_DWORD *)a2 + 8202);
  if (v3 < *((_DWORD *)this + 8202))
    *((_DWORD *)this + 8202) = v3;
  v4 = *((_DWORD *)a2 + 8203);
  if (v4 > *((_DWORD *)this + 8203))
  {
    *((_DWORD *)this + 8203) = v4;
    v4 = *((_DWORD *)a2 + 8203);
  }
  v5 = *v2;
  if ((int)v5 <= v4)
  {
    v6 = 8 * v5 + 40;
    v7 = (_QWORD *)((char *)a2 + v6);
    v8 = (_QWORD *)((char *)this + v6);
    v9 = v4 - v5 + 1;
    do
    {
      *v8++ += *v7;
      *v7++ = 0;
      --v9;
    }
    while (v9);
  }
  *(_QWORD *)v2 = 4095;
  if (!*((_BYTE *)this + 32824))
    return 0;
  v10 = *((_QWORD *)this + 2);
  if (*((_QWORD *)this + 4) <= v10)
    return 0;
  *((_QWORD *)this + 2) = v10 + ((*((_QWORD *)this + 1) + 7) >> 4);
  return 1;
}

uint64_t kdu_thread_entity::try_lock(kdu_thread_entity *this, int a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  kdu_thread_entity *v7;
  uint64_t v8;
  _DWORD *exception;

  if (a2 < 0
    || *((_DWORD *)this + 12) <= a2
    || (v4 = *((_QWORD *)this + 7),
        v5 = v4 + 80 * a2,
        v7 = *(kdu_thread_entity **)(v5 + 72),
        v6 = (_QWORD *)(v5 + 72),
        v7 == this))
  {
    kdu_thread_entity::try_lock();
  }
  if (a3 && **((_BYTE **)this + 5))
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = *(_DWORD *)(*((_QWORD *)this + 5) + 4);
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v8 = v4 + 80 * a2;
  if (!*(_BYTE *)(v8 + 64) || pthread_mutex_trylock((pthread_mutex_t *)v8))
    return 0;
  *v6 = this;
  return 1;
}

__n128 kd_global_rescomp::add_ready_precinct(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  __n128 result;
  __int128 v15;

  if (a2[8] || a2[7] || (v3 = (_QWORD *)(a1 + 48), *(_QWORD **)(a1 + 48) == a2))
    kd_global_rescomp::add_ready_precinct();
  v4 = *(_QWORD *)(a1 + 56);
  a2[8] = v4;
  if (v4)
    v3 = (_QWORD *)(v4 + 56);
  *v3 = a2;
  *(_QWORD *)(a1 + 56) = a2;
  v5 = *a2;
  v6 = (a2[1] - *(_QWORD *)(*a2 + 232)) >> 3;
  v7 = *(_DWORD *)(*a2 + 196);
  v8 = (int)v6 / v7;
  v9 = *(_DWORD *)(*a2 + 184);
  LODWORD(v6) = *(_DWORD *)(*a2 + 188) - (int)v6 / v7 * v7 + v6;
  v15 = *(_OWORD *)(*a2 + 168);
  LODWORD(v15) = v15 + DWORD2(v15) * (v9 + v8);
  DWORD1(v15) += HIDWORD(v15) * v6;
  kdu_dims::operator&=(&v15, (int *)(v5 + 48));
  *(_QWORD *)(a1 + 64) += SDWORD2(v15) * (uint64_t)SHIDWORD(v15);
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)(a1 + 72) = result;
  return result;
}

uint64_t kd_codestream::trim_compressed_data(uint64_t this)
{
  uint64_t v1;
  int v2;
  unsigned __int16 v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  int i;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  int v19;
  uint64_t v20;

  v1 = *(_QWORD *)(this + 64);
  if (v1)
  {
    v2 = 16 * *(_DWORD *)(v1 + 32820);
    v3 = v2 < 2 ? 1 : v2 - 1;
    if (v2 >= 2)
    {
      v4 = this;
      v5 = *(_DWORD *)(this + 168);
      v6 = *(_QWORD *)(this + 352) + 2816 * v5;
      v7 = 32;
      v8 = v3;
      do
      {
        v19 = v7;
        if (v5 >= 1)
        {
          for (i = 0; i < v5; ++i)
          {
            v10 = *(_QWORD **)(v6 + 48);
            if (v10)
            {
              v20 = v6;
              do
              {
                v11 = *v10;
                if (*(_BYTE *)(*v10 + 222))
                {
                  v12 = 0;
                  do
                  {
                    v13 = v10[6] + 32 * v12;
                    v15 = *(_DWORD *)(v13 + 20);
                    v14 = (_DWORD *)(v13 + 20);
                    if (*(v14 - 1) * v15 >= 1)
                    {
                      v16 = 0;
                      v17 = 0;
                      v18 = (_QWORD *)(v10[6] + 32 * v12 + 24);
                      do
                      {
                        this = kd_block::trim_data((kd_block *)(*v18 + v16), v8, *(kd_buf_server **)(v4 + 48));
                        ++v17;
                        v16 += 40;
                      }
                      while (v17 < *(v14 - 1) * *v14);
                      v11 = *v10;
                    }
                    ++v12;
                  }
                  while (v12 < *(unsigned __int8 *)(v11 + 222));
                }
                v10 = (_QWORD *)v10[7];
              }
              while (v10);
              v5 = *(_DWORD *)(v4 + 168);
              v6 = v20;
            }
            v6 += 88;
          }
        }
        v7 = v19 - 1;
        v6 -= 176 * v5;
      }
      while (v19);
    }
  }
  return this;
}

uint64_t kd_packet_sequencer::init(kd_packet_sequencer *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int *v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  int *v29;
  int *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;

  v1 = *(_QWORD *)this;
  if (!*(_BYTE *)(*(_QWORD *)this + 292))
    kd_packet_sequencer::init();
  *((_DWORD *)this + 2) = 0;
  *((_BYTE *)this + 12) = 1;
  if (*(int *)(v1 + 188) >= 1)
  {
    v2 = 0;
    while (1)
    {
      v3 = *(_QWORD *)(v1 + 272);
      v4 = *(_DWORD *)(v3 + 224 * v2 + 68);
      if ((signed int)v4 > *((_DWORD *)this + 2))
        *((_DWORD *)this + 2) = v4;
      v5 = v3 + 224 * v2;
      v6 = (unsigned int *)(v5 + 28);
      v7 = *(_DWORD *)(v5 + 32);
      if (v7 >= 2)
        break;
      v9 = v7;
LABEL_12:
      if (v9 != 1)
        goto LABEL_19;
      v11 = *v6;
      if ((int)*v6 >= 2)
      {
        while ((v11 & 1) == 0)
        {
          v12 = v11 >> 1;
          v10 = v11 > 3;
          v11 >>= 1;
          if (!v10)
            goto LABEL_18;
        }
LABEL_19:
        *((_BYTE *)this + 12) = 0;
        goto LABEL_20;
      }
      v12 = *v6;
LABEL_18:
      if (v12 != 1)
        goto LABEL_19;
LABEL_20:
      if ((v4 & 0x80000000) == 0)
      {
        v13 = 0;
        v14 = v3 + 224 * v2;
        v15 = *(_QWORD *)(v14 + 176);
        v16 = (int *)(v14 + 200);
        v17 = (int *)(v14 + 196);
        v18 = 704 * v4 + 704;
        while (1)
        {
          v19 = v15 + v13;
          v20 = (*(_DWORD *)(v15 + v13 + 180) << *(_BYTE *)(v15 + v13 + 26)) * v7;
          if (v13)
          {
            v21 = *v16;
            if (v20 < *v16)
            {
              *v16 = v20;
              v21 = v20;
            }
            v22 = (*(_DWORD *)(v19 + 176) << *(_BYTE *)(v15 + v13 + 27)) * *v6;
            if (v22 >= *v17)
              goto LABEL_29;
          }
          else
          {
            v23 = *v6;
            *v16 = v20;
            v22 = (*(_DWORD *)(v19 + 176) << *(_BYTE *)(v19 + 27)) * v23;
            v21 = v20;
          }
          *v17 = v22;
LABEL_29:
          v13 += 704;
          if (v18 == v13)
            goto LABEL_32;
        }
      }
      v21 = *(_DWORD *)(v3 + 224 * v2 + 200);
LABEL_32:
      v24 = *(_DWORD *)(v1 + 216);
      v25 = *(_DWORD *)(v1 + 248);
      v26 = (*(_DWORD *)(v1 + 212) - *(_DWORD *)(v1 + 244));
      v27 = v26 | ((unint64_t)(v24 - v25) << 32);
      v28 = v3 + 224 * v2;
      *(_QWORD *)(v28 + 188) = v27;
      v29 = (int *)(v28 + 188);
      v32 = *(_DWORD *)(v28 + 192);
      v30 = (int *)(v28 + 192);
      v31 = v32;
      if (v21 <= 1)
        v33 = 1;
      else
        v33 = v21;
      if ((v31 & 0x80000000) != 0)
        v34 = ~(~v31 / v33);
      else
        v34 = v31 / v33;
      v35 = v34 * v21;
      *v30 = v35;
      v36 = v30[1];
      if (v36 <= 1)
        v37 = 1;
      else
        v37 = v30[1];
      v38 = v26 / v37;
      v39 = ~(_DWORD)v26 / v37;
      if ((int)v26 < 0)
        v40 = ~v39;
      else
        v40 = v38;
      v41 = v40 * v36;
      *v29 = v41;
      v1 = *(_QWORD *)this;
      v42 = *(_DWORD *)(*(_QWORD *)this + 244);
      *v30 = v35 + *(_DWORD *)(*(_QWORD *)this + 248);
      *v29 = v42 + v41;
      if (++v2 >= *(int *)(v1 + 188))
        goto LABEL_45;
    }
    v8 = v7;
    while ((v8 & 1) == 0)
    {
      v9 = v8 >> 1;
      v10 = v8 > 3;
      v8 >>= 1;
      if (!v10)
        goto LABEL_12;
    }
    goto LABEL_19;
  }
LABEL_45:
  *((_QWORD *)this + 2) = (*(_DWORD *)(v1 + 220) + *(_DWORD *)(v1 + 212)) | ((unint64_t)(*(_DWORD *)(v1 + 224) + *(_DWORD *)(v1 + 216)) << 32);
  *((_BYTE *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  return kd_packet_sequencer::next_progression(this);
}

uint64_t kd_packet_sequencer::next_progression(kd_packet_sequencer *this)
{
  int *v2;
  kdu_params *v3;
  int v4;
  kdu_params *v5;
  int v6;
  uint64_t v7;
  int v8;
  kdu_params *v9;
  kdu_params *v10;
  int v11;
  kdu_params *v12;
  kdu_params *v14;
  kdu_params *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  _DWORD *v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  _OWORD v36[2];
  uint64_t v37;
  char v38[16];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v2 = (int *)((char *)this + 32);
  v3 = (kdu_params *)*((_QWORD *)this + 13);
  if (v3)
  {
LABEL_2:
    v4 = kdu_params::get(v3, "Porder", *((_DWORD *)this + 28), 0, (int *)this + 9, 1, 1, 1);
    v5 = (kdu_params *)*((_QWORD *)this + 13);
    if (v4)
    {
      v6 = *((_DWORD *)this + 28);
LABEL_4:
      kdu_params::get(v5, "Porder", v6, 1, (int *)this + 10, 1, 1, 1);
      kdu_params::get(*((kdu_params **)this + 13), "Porder", *((_DWORD *)this + 28), 2, (int *)this + 11, 1, 1, 1);
      kdu_params::get(*((kdu_params **)this + 13), "Porder", *((_DWORD *)this + 28), 3, (int *)this + 12, 1, 1, 1);
      kdu_params::get(*((kdu_params **)this + 13), "Porder", *((_DWORD *)this + 28), 4, (int *)this + 13, 1, 1, 1);
      kdu_params::get(*((kdu_params **)this + 13), "Porder", *((_DWORD *)this + 28), 5, v2, 1, 1, 1);
      if ((*((_DWORD *)this + 10) || *((_DWORD *)this + 9))
        && !*((_DWORD *)this + 28)
        && !*(_DWORD *)(*((_QWORD *)this + 13) + 24)
        && !*(_DWORD *)(**(_QWORD **)this + 160))
      {
        *(_QWORD *)&v40 = 0;
        *(_OWORD *)v38 = 0u;
        v39 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)v38, "Kakadu Core Warning:\n");
        (*(void (**)(char *, const char *))(*(_QWORD *)v38 + 16))(v38, "Profile violation detected (code-stream is technically illegal).  In a Profile-0 code-stream, the first progression specification found in the first POC marker segment of the main or any tile header may not describe a progression which starts from resolution or component indices other than 0.");
        *(_DWORD *)(**(_QWORD **)this + 160) = 2;
        kdu_warning::~kdu_warning((kdu_warning *)v38);
      }
      ++*((_DWORD *)this + 28);
      v7 = *(_QWORD *)this;
      v8 = *(_DWORD *)(*(_QWORD *)this + 192);
      if (*((_DWORD *)this + 11) > v8)
        *((_DWORD *)this + 11) = v8;
      goto LABEL_30;
    }
    v11 = *((_DWORD *)v5 + 6) + 1;
    v12 = (kdu_params *)kdu_params::access_relation(*((kdu_params **)this + 13), *(_DWORD *)(*(_QWORD *)this + 8), -1, v11, 1);
    if (v12 && (v5 = v12, (kdu_params::get(v12, "Porder", 0, 0, (int *)this + 9, 1, 1, 1) & 1) != 0))
    {
      if (v11 < *(_DWORD *)(*(_QWORD *)this + 304))
      {
        v6 = 0;
        *((_QWORD *)this + 13) = v5;
        *((_DWORD *)this + 28) = 0;
        goto LABEL_4;
      }
    }
    else if (!*(_QWORD *)(**(_QWORD **)this + 8))
    {
      v37 = 0;
      memset(v36, 0, sizeof(v36));
      kdu_error::kdu_error((kdu_error *)v36, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v36[0] + 16))(v36, "Supplied progression order attributes for tile ");
      v41 = 0u;
      v42 = 0u;
      v39 = 0u;
      v40 = 0u;
      *(_OWORD *)v38 = 0u;
      if (BYTE8(v36[0]))
        sprintf(v38, "%x");
      else
        sprintf(v38, "%d");
      (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v36[0] + 16))(v36, v38);
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v36[0] + 16))(v36, " are insuffient to cover all packets for the tile!");
      kdu_error::~kdu_error((kdu_error *)v36);
    }
    return 0;
  }
  v9 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(**(_QWORD **)this + 24), "POC");
  *((_QWORD *)this + 13) = v9;
  if (!v9)
    kd_packet_sequencer::next_progression();
  v10 = (kdu_params *)kdu_params::access_relation(v9, *(_DWORD *)(*(_QWORD *)this + 8), -1, 0, 1);
  *((_QWORD *)this + 13) = v10;
  if (!v10)
    kd_packet_sequencer::next_progression();
  if ((kdu_params::get(v10, "Porder", 0, 0, (int *)this + 9, 1, 1, 1) & 1) != 0)
  {
    v3 = (kdu_params *)*((_QWORD *)this + 13);
    if (v3)
      goto LABEL_2;
  }
  else
  {
    *((_QWORD *)this + 13) = 0;
  }
  v14 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(**(_QWORD **)this + 24), "COD");
  v15 = (kdu_params *)kdu_params::access_relation(v14, *(_DWORD *)(*(_QWORD *)this + 8), -1, 0, 1);
  if ((kdu_params::get(v15, "Corder", 0, 0, v2, 1, 1, 1) & 1) == 0)
    kd_packet_sequencer::next_progression();
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  v7 = *(_QWORD *)this;
  *((_DWORD *)this + 11) = *(_DWORD *)(*(_QWORD *)this + 192);
  v16 = *(_DWORD *)(v7 + 188);
  *((_DWORD *)this + 12) = *((_DWORD *)this + 2) + 1;
  *((_DWORD *)this + 13) = v16;
LABEL_30:
  v17 = *((_DWORD *)this + 13);
  v18 = *(_DWORD *)(v7 + 188);
  if (v17 > v18)
  {
    *((_DWORD *)this + 13) = v18;
    v17 = v18;
  }
  v19 = *((_DWORD *)this + 2);
  if (*((_DWORD *)this + 12) > v19)
    *((_DWORD *)this + 12) = v19 + 1;
  v20 = *((_DWORD *)this + 9);
  v21 = *((int *)this + 10);
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = v21;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 0;
  v22 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 16) = v20;
  if ((v22 - 2) < 2)
  {
    if (!*((_BYTE *)this + 12))
    {
      *(_QWORD *)&v40 = 0;
      *(_OWORD *)v38 = 0u;
      v39 = 0u;
      kdu_error::kdu_error((kdu_error *)v38, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v38 + 16))(v38, "Attempting to use a spatially progressive packet sequence where position order dominates component order. This is illegal when the component sub-sampling factors are not exact powers of 2!");
      kdu_error::~kdu_error((kdu_error *)v38);
    }
    if (v18 >= 1)
    {
      v23 = 0;
      v24 = *(_DWORD **)(v7 + 272);
      v25 = 224 * v18;
      do
      {
        if (v23)
        {
          v26 = &v24[v23 / 4];
          v27 = v24[v23 / 4 + 50];
          if (v27 < *((_DWORD *)this + 22))
          {
            *((_DWORD *)this + 22) = v27;
            *((_DWORD *)this + 20) = v26[48];
          }
          v28 = v26[49];
          if (v28 >= *((_DWORD *)this + 21))
            goto LABEL_46;
        }
        else
        {
          *((_DWORD *)this + 22) = v24[50];
          *((_DWORD *)this + 20) = v24[48];
          v28 = v24[49];
        }
        *((_DWORD *)this + 21) = v28;
        *((_DWORD *)this + 19) = v24[v23 / 4 + 47];
LABEL_46:
        v23 += 224;
      }
      while (v25 != v23);
    }
    v29 = *(_QWORD *)((char *)this + 76);
    goto LABEL_51;
  }
  if (v22 == 4 && (int)v21 < v17)
  {
    v29 = *(_QWORD *)(*(_QWORD *)(v7 + 272) + 224 * v21 + 188);
    *(_QWORD *)((char *)this + 76) = v29;
    *(_QWORD *)((char *)this + 84) = *(_QWORD *)(*(_QWORD *)(v7 + 272) + 224 * v21 + 196);
LABEL_51:
    *(_QWORD *)((char *)this + 92) = v29;
    v30 = *(unsigned int *)(v7 + 188);
    if ((int)v30 >= 1)
    {
      v31 = 0;
      v32 = *(_QWORD *)(v7 + 272);
      do
      {
        v33 = *(unsigned int *)(v32 + 224 * v31 + 68);
        if ((v33 & 0x80000000) == 0)
        {
          v34 = v33 + 1;
          v35 = (_QWORD *)(*(_QWORD *)(v32 + 224 * v31 + 176) + 688);
          do
          {
            *v35 = 0;
            v35 += 88;
            --v34;
          }
          while (v34);
        }
        ++v31;
      }
      while (v31 != v30);
    }
  }
  return 1;
}

void sub_187F10174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

_BYTE *kd_packet_sequencer::save_state(_BYTE *this)
{
  __int128 v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v1 = *((_OWORD *)this + 3);
  *(_OWORD *)(this + 120) = *((_OWORD *)this + 2);
  *(_OWORD *)(this + 136) = v1;
  *(_OWORD *)(this + 184) = *((_OWORD *)this + 6);
  v2 = *((_OWORD *)this + 4);
  *(_OWORD *)(this + 168) = *((_OWORD *)this + 5);
  *((_DWORD *)this + 50) = *((_DWORD *)this + 28);
  *(_OWORD *)(this + 152) = v2;
  v3 = *(_QWORD *)this;
  *(_DWORD *)(v3 + 324) = *(_DWORD *)(*(_QWORD *)this + 308);
  if (*(int *)(v3 + 188) >= 1)
  {
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(v3 + 272);
      v6 = v5 + 224 * v4;
      v8 = *(_DWORD *)(v6 + 68);
      v7 = (int *)(v6 + 68);
      *(_OWORD *)(v7 + 34) = *(_OWORD *)(v7 + 30);
      if ((v8 & 0x80000000) == 0)
      {
        v9 = 0;
        v10 = (uint64_t *)(v5 + 224 * v4 + 176);
        do
        {
          v11 = *v10;
          v12 = *v10 + 704 * v9;
          *(_QWORD *)(v12 + 696) = *(_QWORD *)(v12 + 688);
          v13 = *(_DWORD *)(v12 + 192) * *(_DWORD *)(v12 + 196);
          if (v13 >= 1)
          {
            v14 = 0;
            v15 = (_QWORD *)(v11 + 704 * v9 + 232);
            v16 = 8 * v13;
            do
            {
              v17 = *(_QWORD *)(*v15 + v14);
              if (v17)
                v18 = (*(_QWORD *)(*v15 + v14) & 1) == 0;
              else
                v18 = 0;
              if (v18)
                *(_DWORD *)(v17 + 32) = *(_DWORD *)(v17 + 28);
              v14 += 8;
            }
            while (v16 != v14);
          }
        }
        while (v9++ < *v7);
      }
      ++v4;
      v3 = *(_QWORD *)this;
    }
    while (v4 < *(int *)(*(_QWORD *)this + 188));
  }
  this[24] = 1;
  return this;
}

uint64_t *kd_packet_sequencer::restore_state(uint64_t *this)
{
  __int128 v1;
  __int128 v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;

  if (!*((_BYTE *)this + 24))
    kd_packet_sequencer::restore_state();
  v1 = *(_OWORD *)(this + 17);
  *((_OWORD *)this + 2) = *(_OWORD *)(this + 15);
  *((_OWORD *)this + 3) = v1;
  *((_DWORD *)this + 28) = *((_DWORD *)this + 50);
  v2 = *(_OWORD *)(this + 23);
  v3 = *(_OWORD *)(this + 19);
  *((_OWORD *)this + 5) = *(_OWORD *)(this + 21);
  *((_OWORD *)this + 6) = v2;
  *((_OWORD *)this + 4) = v3;
  v4 = *this;
  *(_DWORD *)(v4 + 308) = *(_DWORD *)(*this + 324);
  if (*(int *)(v4 + 188) >= 1)
  {
    v5 = 0;
    do
    {
      v6 = *(_QWORD *)(v4 + 272);
      v7 = v6 + 224 * v5;
      v9 = *(_DWORD *)(v7 + 68);
      v8 = (int *)(v7 + 68);
      *(_OWORD *)(v8 + 30) = *(_OWORD *)(v8 + 34);
      if ((v9 & 0x80000000) == 0)
      {
        v10 = 0;
        v11 = (uint64_t *)(v6 + 224 * v5 + 176);
        do
        {
          v12 = *v11;
          v13 = *v11 + 704 * v10;
          *(_QWORD *)(v13 + 688) = *(_QWORD *)(v13 + 696);
          v14 = (*(_DWORD *)(v13 + 192) * *(_DWORD *)(v13 + 196));
          if ((int)v14 >= 1)
          {
            v15 = *(uint64_t **)(v12 + 704 * v10 + 232);
            do
            {
              v17 = *v15++;
              v16 = v17;
              v18 = v17 & 1;
              if (v17)
                v19 = v18 == 0;
              else
                v19 = 0;
              if (v19)
                *(_DWORD *)(v16 + 28) = *(_DWORD *)(v16 + 32);
              --v14;
            }
            while (v14);
          }
        }
        while (v10++ < *v8);
      }
      ++v5;
      v4 = *this;
    }
    while (v5 < *(int *)(*this + 188));
  }
  return this;
}

uint64_t *kd_packet_sequencer::next_in_sequence(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v9;
  uint64_t v10;
  kd_precinct_pointer_server *v11;
  uint64_t v12;
  uint64_t v13;

  if (*(_DWORD *)(*a1 + 308) == *(_DWORD *)(*a1 + 208))
    return 0;
  while (1)
  {
    switch(*((_DWORD *)a1 + 8))
    {
      case 0:
        v6 = kd_packet_sequencer::next_in_lrcp(a1, a2, a3);
        break;
      case 1:
        v6 = kd_packet_sequencer::next_in_rlcp(a1, a2, a3);
        break;
      case 2:
        v6 = (uint64_t *)kd_packet_sequencer::next_in_rpcl(a1, a2, a3);
        break;
      case 3:
        v6 = (uint64_t *)kd_packet_sequencer::next_in_pcrl(a1, a2, a3);
        break;
      case 4:
        v6 = (uint64_t *)kd_packet_sequencer::next_in_cprl((uint64_t)a1, a2, a3);
        break;
      default:
        kd_packet_sequencer::next_in_sequence();
    }
    v7 = v6;
    if (v6)
      break;
    if ((kd_packet_sequencer::next_progression((kd_packet_sequencer *)a1) & 1) == 0)
      return 0;
  }
  v9 = *v6;
  if ((*v6 & 1) != 0)
    v9 = 0;
  v10 = *a1;
  if (*(_QWORD *)(*(_QWORD *)*a1 + 8) && (!v9 || !*(_DWORD *)(v9 + 28)))
  {
    v12 = *(_QWORD *)(v10 + 104);
    v11 = (kd_precinct_pointer_server *)(v10 + 104);
    if (v12)
    {
      v13 = kd_precinct_pointer_server::pop_address(v11);
      if (v13 >= 1)
      {
        if (!kd_precinct_ref::set_address(v7, *a2, *a3, v13))
          return 0;
        return v7;
      }
      if ((v13 & 0x8000000000000000) == 0)
        return v7;
      return 0;
    }
  }
  return v7;
}

uint64_t *kd_packet_sequencer::next_in_lrcp(_DWORD *a1, _QWORD *a2, _QWORD *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;

  v3 = a1[11];
  v4 = a1[14];
  if (v4 >= v3)
    return 0;
  v5 = a1[12];
  v6 = a1[16];
  while (v6 >= v5)
  {
LABEL_25:
    a1[14] = ++v4;
    v6 = a1[9];
    a1[16] = v6;
    if (v4 == v3)
      return 0;
  }
  v7 = a1[13];
  LODWORD(v8) = a1[15];
  v9 = v6;
  while ((int)v8 >= v7)
  {
LABEL_24:
    ++v9;
    LODWORD(v8) = a1[10];
    a1[15] = v8;
    a1[16] = v9;
    if (v5 == (_DWORD)v9)
      goto LABEL_25;
  }
  v10 = *(_QWORD *)(*(_QWORD *)a1 + 272);
  v8 = (int)v8;
  while (1)
  {
    if (v9 <= *(int *)(v10 + 224 * v8 + 68))
    {
      v11 = *(_QWORD *)(v10 + 224 * v8 + 176);
      v12 = *(_DWORD *)(v11 + 704 * v9 + 192);
      v13 = (int)a1[17];
      if ((int)v13 < v12)
        break;
    }
LABEL_23:
    a1[15] = ++v8;
    a1[17] = 0;
    if (v7 == (_DWORD)v8)
      goto LABEL_24;
  }
  v14 = v11 + 704 * v9;
  v15 = *(int *)(v14 + 196);
  v16 = (_QWORD *)(v14 + 232);
  v17 = a1[18];
  v18 = 8 * (int)v13 * (uint64_t)(int)v15;
  while (v17 >= (int)v15)
  {
LABEL_22:
    v17 = 0;
    *(_QWORD *)(a1 + 17) = ++v13;
    v18 += 8 * v15;
    if (v12 == (_DWORD)v13)
      goto LABEL_23;
  }
  v19 = (uint64_t *)(*v16 + v18 + 8 * v17);
  while (1)
  {
    v20 = *v19;
    if (!*v19)
      break;
    if ((v20 & 1) == 0 && !*(_BYTE *)(v20 + 17))
    {
      v21 = *(_DWORD *)(v20 + 28);
      if (v21 < v4 && v4 != 0)
        goto LABEL_30;
      if (v21 == v4)
        goto LABEL_28;
    }
    a1[18] = ++v17;
    ++v19;
    if ((_DWORD)v15 == v17)
      goto LABEL_22;
  }
  if (v4)
LABEL_30:
    kd_packet_sequencer::next_in_lrcp();
LABEL_28:
  *a2 = v11 + 704 * v9;
  *a3 = *(_QWORD *)(a1 + 17);
  return v19;
}

uint64_t *kd_packet_sequencer::next_in_rlcp(_DWORD *a1, _QWORD *a2, _QWORD *a3)
{
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;

  v3 = a1[12];
  v4 = (int)a1[16];
  if ((int)v4 >= v3)
    return 0;
  v5 = a1[11];
  v6 = a1[14];
  while (v6 >= v5)
  {
LABEL_25:
    v6 = 0;
    a1[16] = ++v4;
    a1[14] = 0;
    if (v3 == (_DWORD)v4)
      return 0;
  }
  v7 = a1[13];
  v8 = a1[15];
  while (v8 >= v7)
  {
LABEL_24:
    ++v6;
    v8 = a1[10];
    a1[14] = v6;
    a1[15] = v8;
    if (v6 == v5)
      goto LABEL_25;
  }
  v9 = *(_QWORD *)(*(_QWORD *)a1 + 272);
  v10 = v8;
  while (1)
  {
    if (v4 <= *(int *)(v9 + 224 * v10 + 68))
    {
      v11 = *(_QWORD *)(v9 + 224 * v10 + 176);
      v12 = *(_DWORD *)(v11 + 704 * v4 + 192);
      v13 = (int)a1[17];
      if ((int)v13 < v12)
        break;
    }
LABEL_23:
    a1[15] = ++v10;
    a1[17] = 0;
    if (v7 == (_DWORD)v10)
      goto LABEL_24;
  }
  v14 = v11 + 704 * v4;
  v15 = *(int *)(v14 + 196);
  v16 = (_QWORD *)(v14 + 232);
  v17 = a1[18];
  v18 = 8 * (int)v13 * (uint64_t)(int)v15;
  while (v17 >= (int)v15)
  {
LABEL_22:
    v17 = 0;
    *(_QWORD *)(a1 + 17) = ++v13;
    v18 += 8 * v15;
    if (v12 == (_DWORD)v13)
      goto LABEL_23;
  }
  v19 = (uint64_t *)(*v16 + v18 + 8 * v17);
  while (1)
  {
    v20 = *v19;
    if (!*v19)
      break;
    if ((v20 & 1) == 0 && !*(_BYTE *)(v20 + 17))
    {
      v21 = *(_DWORD *)(v20 + 28);
      if (v21 < v6 && v6 != 0)
        goto LABEL_30;
      if (v21 == v6)
        goto LABEL_28;
    }
    a1[18] = ++v17;
    ++v19;
    if ((_DWORD)v15 == v17)
      goto LABEL_22;
  }
  if (v6)
LABEL_30:
    kd_packet_sequencer::next_in_rlcp();
LABEL_28:
  *a2 = v11 + 704 * v4;
  *a3 = *(_QWORD *)(a1 + 17);
  return v19;
}

uint64_t kd_packet_sequencer::next_in_rpcl(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;

  if (*((int *)a1 + 11) >= 1)
  {
    v3 = *((_DWORD *)a1 + 16);
    v4 = *((_DWORD *)a1 + 12);
    if (v3 < v4)
    {
      v5 = *((_DWORD *)a1 + 23);
      v6 = *((_DWORD *)a1 + 4);
      while (1)
      {
        if (v5 < v6)
        {
          v7 = *((_DWORD *)a1 + 24);
          v8 = *((_DWORD *)a1 + 5);
          do
          {
            if (v7 < v8)
            {
              v9 = *((_DWORD *)a1 + 15);
              v10 = *((_DWORD *)a1 + 13);
              do
              {
                if (v9 < v10)
                {
                  while (1)
                  {
                    v11 = *a1;
                    v12 = *(_QWORD *)(*a1 + 272);
                    v13 = *((_DWORD *)a1 + 16);
                    if (v13 <= *(_DWORD *)(v12 + 224 * v9 + 68))
                    {
                      v14 = *(_QWORD *)(v12 + 224 * v9 + 176);
                      v15 = v14 + 704 * v13;
                      v16 = *(_QWORD *)(v15 + 688);
                      *(uint64_t *)((char *)a1 + 68) = v16;
                      v17 = HIDWORD(v16);
                      v18 = *(_DWORD *)(v15 + 196);
                      if (v18 > SHIDWORD(v16) && *(_DWORD *)(v14 + 704 * v13 + 192) > (int)v16)
                      {
                        v19 = *(_QWORD *)(v14 + 704 * v13 + 232) + 8 * (v16 >> 32);
                        v20 = v18 * v16;
                        v21 = *(_QWORD *)(v19 + 8 * v18 * (int)v16);
                        if (v21
                          && ((v21 & 1) != 0 || *(_BYTE *)(v21 + 17) || *(_DWORD *)(v21 + 28) >= *((_DWORD *)a1 + 11)))
                        {
                          *((_DWORD *)a1 + 18) = HIDWORD(v16) + 1;
                          if (HIDWORD(v16) + 1 >= v18)
                            *(uint64_t *)((char *)a1 + 68) = (v16 + 1);
                          *(_QWORD *)(v15 + 688) = *(uint64_t *)((char *)a1 + 68);
                          v9 = *((_DWORD *)a1 + 15);
                          v10 = *((_DWORD *)a1 + 13);
                        }
                        else
                        {
                          v23 = *(_DWORD *)(v15 + 184);
                          v22 = v15 + 184;
                          v24 = *(_DWORD *)(v11 + 244)
                              + (((v23 + (_DWORD)v16) * *(_DWORD *)(v14 + 704 * v13 + 176)) << *(_BYTE *)(v14 + 704 * v13 + 27))
                              * *(_DWORD *)(v12 + 224 * v9 + 28);
                          if (v24 < *((_DWORD *)a1 + 19) || v24 == *((_DWORD *)a1 + 23))
                          {
                            v25 = *(_DWORD *)(v11 + 248)
                                + (((*(_DWORD *)(v22 + 4) + (_DWORD)v17) * *(_DWORD *)(v14 + 704 * v13 + 180)) << *(_BYTE *)(v14 + 704 * v13 + 26))
                                * *(_DWORD *)(v12 + 224 * v9 + 32);
                            if (v25 < *((_DWORD *)a1 + 20) || v25 == *((_DWORD *)a1 + 24))
                            {
                              v26 = v19 + 8 * v20;
                              *a2 = v14 + 704 * v13;
                              *a3 = *(uint64_t *)((char *)a1 + 68);
                              return v26;
                            }
                          }
                        }
                      }
                    }
                    *((_DWORD *)a1 + 15) = ++v9;
                    if (v9 >= v10)
                    {
                      v7 = *((_DWORD *)a1 + 24);
                      v8 = *((_DWORD *)a1 + 5);
                      break;
                    }
                  }
                }
                v7 += *((_DWORD *)a1 + 22);
                *((_DWORD *)a1 + 24) = v7;
                v9 = *((_DWORD *)a1 + 10);
                *((_DWORD *)a1 + 15) = v9;
              }
              while (v7 < v8);
              v5 = *((_DWORD *)a1 + 23);
              v6 = *((_DWORD *)a1 + 4);
            }
            v7 = *((_DWORD *)a1 + 20);
            v5 += *((_DWORD *)a1 + 21);
            *((_DWORD *)a1 + 23) = v5;
            *((_DWORD *)a1 + 24) = v7;
          }
          while (v5 < v6);
          v3 = *((_DWORD *)a1 + 16);
          v4 = *((_DWORD *)a1 + 12);
        }
        v26 = 0;
        *((_DWORD *)a1 + 16) = ++v3;
        v5 = *((_DWORD *)a1 + 19);
        *((_DWORD *)a1 + 23) = v5;
        if (v3 >= v4)
          return v26;
      }
    }
  }
  return 0;
}

uint64_t kd_packet_sequencer::next_in_pcrl(uint64_t *a1, _QWORD *a2, _QWORD *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  uint64_t v26;

  if (*((int *)a1 + 11) >= 1)
  {
    v3 = *((_DWORD *)a1 + 23);
    v4 = *((_DWORD *)a1 + 4);
    if (v3 < v4)
    {
      v5 = *((_DWORD *)a1 + 24);
      v6 = *((_DWORD *)a1 + 5);
      while (1)
      {
        if (v5 < v6)
        {
          LODWORD(v7) = *((_DWORD *)a1 + 15);
          v8 = *((_DWORD *)a1 + 13);
          do
          {
            if ((int)v7 < v8)
            {
              v9 = *((_DWORD *)a1 + 16);
              v10 = *((_DWORD *)a1 + 12);
              do
              {
                if (v9 < v10)
                {
                  v11 = *a1;
                  v12 = *(_QWORD *)(*a1 + 272);
                  LODWORD(v7) = *((_DWORD *)a1 + 15);
                  if (v9 <= *(_DWORD *)(v12 + 224 * (int)v7 + 68))
                  {
                    v7 = (int)v7;
                    while (1)
                    {
                      v13 = *(_QWORD *)(v12 + 224 * v7 + 176);
                      v14 = v13 + 704 * v9;
                      v15 = *(_QWORD *)(v14 + 688);
                      *(uint64_t *)((char *)a1 + 68) = v15;
                      v16 = HIDWORD(v15);
                      v17 = *(_DWORD *)(v14 + 196);
                      if (v17 > SHIDWORD(v15) && *(_DWORD *)(v13 + 704 * v9 + 192) > (int)v15)
                      {
                        v18 = *(_QWORD *)(v13 + 704 * v9 + 232) + 8 * (v15 >> 32);
                        v19 = v17 * v15;
                        v20 = *(_QWORD *)(v18 + 8 * v17 * (int)v15);
                        if (v20
                          && ((v20 & 1) != 0 || *(_BYTE *)(v20 + 17) || *(_DWORD *)(v20 + 28) >= *((_DWORD *)a1 + 11)))
                        {
                          *((_DWORD *)a1 + 18) = HIDWORD(v15) + 1;
                          if (HIDWORD(v15) + 1 >= v17)
                            *(uint64_t *)((char *)a1 + 68) = (v15 + 1);
                          *(_QWORD *)(v14 + 688) = *(uint64_t *)((char *)a1 + 68);
                          v9 = *((_DWORD *)a1 + 16);
                          v10 = *((_DWORD *)a1 + 12);
                        }
                        else
                        {
                          v22 = *(_DWORD *)(v14 + 184);
                          v21 = v14 + 184;
                          v23 = *(_DWORD *)(v11 + 244)
                              + (((v22 + (_DWORD)v15) * *(_DWORD *)(v13 + 704 * v9 + 176)) << *(_BYTE *)(v13 + 704 * v9 + 27))
                              * *(_DWORD *)(v12 + 224 * v7 + 28);
                          if (v23 < *((_DWORD *)a1 + 19) || v23 == *((_DWORD *)a1 + 23))
                          {
                            v24 = *(_DWORD *)(v11 + 248)
                                + (((*(_DWORD *)(v21 + 4) + (_DWORD)v16) * *(_DWORD *)(v13 + 704 * v9 + 180)) << *(_BYTE *)(v13 + 704 * v9 + 26))
                                * *(_DWORD *)(v12 + 224 * v7 + 32);
                            if (v24 < *((_DWORD *)a1 + 20) || v24 == *((_DWORD *)a1 + 24))
                            {
                              v26 = v18 + 8 * v19;
                              *a2 = v13 + 704 * v9;
                              *a3 = *(uint64_t *)((char *)a1 + 68);
                              return v26;
                            }
                          }
                        }
                      }
                      *((_DWORD *)a1 + 16) = v9 + 1;
                      if (v9 + 1 >= v10)
                      {
                        LODWORD(v7) = *((_DWORD *)a1 + 15);
                        break;
                      }
                      v11 = *a1;
                      v12 = *(_QWORD *)(*a1 + 272);
                      v7 = *((int *)a1 + 15);
                      if (v9++ >= *(_DWORD *)(v12 + 224 * v7 + 68))
                      {
                        LODWORD(v7) = *((_DWORD *)a1 + 15);
                        break;
                      }
                    }
                  }
                  v8 = *((_DWORD *)a1 + 13);
                }
                LODWORD(v7) = v7 + 1;
                v9 = *((_DWORD *)a1 + 9);
                *((_DWORD *)a1 + 15) = v7;
                *((_DWORD *)a1 + 16) = v9;
              }
              while ((int)v7 < v8);
              v5 = *((_DWORD *)a1 + 24);
              v6 = *((_DWORD *)a1 + 5);
            }
            v5 += *((_DWORD *)a1 + 22);
            *((_DWORD *)a1 + 24) = v5;
            LODWORD(v7) = *((_DWORD *)a1 + 10);
            *((_DWORD *)a1 + 15) = v7;
          }
          while (v5 < v6);
          v3 = *((_DWORD *)a1 + 23);
          v4 = *((_DWORD *)a1 + 4);
        }
        v26 = 0;
        v5 = *((_DWORD *)a1 + 20);
        v3 += *((_DWORD *)a1 + 21);
        *((_DWORD *)a1 + 23) = v3;
        *((_DWORD *)a1 + 24) = v5;
        if (v3 >= v4)
          return v26;
      }
    }
  }
  return 0;
}

uint64_t kd_packet_sequencer::next_in_cprl(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t *v9;
  _DWORD *v10;
  _DWORD *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  uint64_t v28;
  uint64_t v29;

  if (*(int *)(a1 + 44) >= 1)
  {
    LODWORD(v3) = *(_DWORD *)(a1 + 60);
    v4 = *(_DWORD *)(a1 + 52);
    if ((int)v3 < v4)
    {
      LODWORD(v5) = *(_DWORD *)(a1 + 92);
      v6 = *(_DWORD *)(a1 + 16);
      while (1)
      {
        if ((int)v5 < v6)
        {
          v7 = *(_QWORD *)(*(_QWORD *)a1 + 272) + 224 * (int)v3;
          v8 = (_DWORD *)(v7 + 68);
          v9 = (uint64_t *)(v7 + 176);
          v10 = (_DWORD *)(v7 + 28);
          v11 = (_DWORD *)(v7 + 32);
          v12 = *(_DWORD *)(a1 + 96);
          v13 = *(_DWORD *)(a1 + 20);
          do
          {
            if (v12 < v13)
            {
              v14 = *(_DWORD *)(a1 + 64);
              v15 = *(_DWORD *)(a1 + 48);
              do
              {
                if (v14 < v15)
                {
                  if (v14 <= *v8)
                  {
                    while (1)
                    {
                      v16 = *v9;
                      v17 = *v9 + 704 * v14;
                      v18 = *(_QWORD *)(v17 + 688);
                      *(_QWORD *)(a1 + 68) = v18;
                      v19 = *(_DWORD *)(v17 + 196);
                      if (v19 > SHIDWORD(v18) && *(_DWORD *)(v16 + 704 * v14 + 192) > (int)v18)
                      {
                        v20 = *(_QWORD *)(v16 + 704 * v14 + 232) + 8 * (v18 >> 32);
                        v21 = v19 * v18;
                        v22 = *(_QWORD *)(v20 + 8 * v19 * (int)v18);
                        if (v22
                          && ((v22 & 1) != 0 || *(_BYTE *)(v22 + 17) || *(_DWORD *)(v22 + 28) >= *(_DWORD *)(a1 + 44)))
                        {
                          *(_DWORD *)(a1 + 72) = HIDWORD(v18) + 1;
                          if (HIDWORD(v18) + 1 >= v19)
                            *(_QWORD *)(a1 + 68) = (v18 + 1);
                          *(_QWORD *)(v17 + 688) = *(_QWORD *)(a1 + 68);
                          v14 = *(_DWORD *)(a1 + 64);
                          v15 = *(_DWORD *)(a1 + 48);
                        }
                        else
                        {
                          v24 = *(_DWORD *)(v17 + 184);
                          v23 = v17 + 184;
                          v25 = *(_DWORD *)(*(_QWORD *)a1 + 244)
                              + (((v24 + (_DWORD)v18) * *(_DWORD *)(v16 + 704 * v14 + 176)) << *(_BYTE *)(v16 + 704 * v14 + 27))
                              * *v10;
                          if (v25 < *(_DWORD *)(a1 + 76) || v25 == *(_DWORD *)(a1 + 92))
                          {
                            v26 = *(_DWORD *)(*(_QWORD *)a1 + 248)
                                + (((*(_DWORD *)(v23 + 4) + HIDWORD(v18)) * *(_DWORD *)(v16 + 704 * v14 + 180)) << *(_BYTE *)(v16 + 704 * v14 + 26))
                                * *v11;
                            if (v26 < *(_DWORD *)(a1 + 80) || v26 == *(_DWORD *)(a1 + 96))
                            {
                              v29 = v20 + 8 * v21;
                              *a2 = v16 + 704 * v14;
                              *a3 = *(_QWORD *)(a1 + 68);
                              return v29;
                            }
                          }
                        }
                      }
                      *(_DWORD *)(a1 + 64) = v14 + 1;
                      if (v14 + 1 < v15 && v14++ < *v8)
                        continue;
                      break;
                    }
                  }
                  v12 = *(_DWORD *)(a1 + 96);
                  v13 = *(_DWORD *)(a1 + 20);
                }
                v12 += *(_DWORD *)(a1 + 88);
                *(_DWORD *)(a1 + 96) = v12;
                v14 = *(_DWORD *)(a1 + 36);
                *(_DWORD *)(a1 + 64) = v14;
              }
              while (v12 < v13);
              LODWORD(v5) = *(_DWORD *)(a1 + 92);
              v6 = *(_DWORD *)(a1 + 16);
            }
            v12 = *(_DWORD *)(a1 + 80);
            LODWORD(v5) = v5 + *(_DWORD *)(a1 + 84);
            *(_DWORD *)(a1 + 92) = v5;
            *(_DWORD *)(a1 + 96) = v12;
          }
          while ((int)v5 < v6);
          LODWORD(v3) = *(_DWORD *)(a1 + 60);
          v4 = *(_DWORD *)(a1 + 52);
        }
        v3 = (int)v3 + 1;
        *(_DWORD *)(a1 + 60) = v3;
        if ((int)v3 >= v4)
          break;
        v28 = *(_QWORD *)(*(_QWORD *)a1 + 272) + 224 * v3;
        v5 = *(_QWORD *)(v28 + 188);
        *(_QWORD *)(a1 + 76) = v5;
        *(_QWORD *)(a1 + 84) = *(_QWORD *)(v28 + 196);
        *(_QWORD *)(a1 + 92) = v5;
      }
    }
  }
  return 0;
}

uint64_t *kd_global_rescomp::close_all(uint64_t *this)
{
  uint64_t v1;
  uint64_t *v2;

  v1 = this[6];
  this[7] = v1;
  if (v1)
  {
    v2 = this;
    do
    {
      v2[6] = *(_QWORD *)(v1 + 56);
      *(_QWORD *)(v1 + 56) = 0;
      *(_QWORD *)(v1 + 64) = 0;
      this = kd_precinct_ref::close(*(uint64_t **)(v1 + 8));
      v1 = v2[6];
      v2[7] = v1;
    }
    while (v1);
  }
  return this;
}

__n128 kd_global_rescomp::initialize(kd_global_rescomp *this, kd_codestream *a2, int a3, int a4)
{
  int v8;
  int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  signed int v13;
  int v14;
  unsigned int v15;
  signed int v16;
  int v17;
  signed int v18;
  signed int v19;
  uint64_t v20;
  uint64_t v21;
  __n128 result;

  kd_global_rescomp::close_all((uint64_t *)this);
  *(_QWORD *)this = a2;
  *((_DWORD *)this + 2) = a3;
  *((_DWORD *)this + 3) = a4;
  v8 = *((_DWORD *)a2 + 66);
  v9 = *((_DWORD *)a2 + 67);
  v10 = *((_QWORD *)a2 + 39);
  v11 = (unsigned int *)(v10 + 104 * a4);
  if ((int)v11[1] <= 1)
    v12 = 1;
  else
    v12 = v11[1];
  if (v9 <= 0)
    v13 = ~(-v9 / v12);
  else
    v13 = (v9 - 1) / v12;
  v14 = *((_DWORD *)a2 + 69) + v9;
  if ((int)*v11 <= 1)
    v15 = 1;
  else
    v15 = *v11;
  if (v8 <= 0)
    v16 = ~(-v8 / v15);
  else
    v16 = (v8 - 1) / v15;
  v17 = *((_DWORD *)a2 + 68) + v8;
  if (v14 <= 0)
    v18 = ~(-v14 / v12);
  else
    v18 = (v14 - 1) / v12;
  if (v17 <= 0)
    v19 = ~(-v17 / v15);
  else
    v19 = (v17 - 1) / v15;
  v20 = v10 + 104 * a4 + a3;
  v21 = ((v19 >> *(_BYTE *)(v20 + 54)) - (v16 >> *(_BYTE *)(v20 + 54)))
      * (uint64_t)((v18 >> *(_BYTE *)(v20 + 21)) - (v13 >> *(_BYTE *)(v20 + 21)));
  *((_QWORD *)this + 2) = v21;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = v21;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)((char *)this + 72) = result;
  return result;
}

__n128 kd_global_rescomp::notify_tile_status(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  unsigned int *v6;
  unsigned int v7;
  signed int v8;
  int v9;
  unsigned int v10;
  signed int v11;
  int v12;
  signed int v13;
  signed int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __n128 result;

  v4 = *(_QWORD *)(*(_QWORD *)a1 + 312);
  v5 = *(_DWORD *)(a1 + 12);
  v6 = (unsigned int *)(v4 + 104 * v5);
  if ((int)v6[1] <= 1)
    v7 = 1;
  else
    v7 = v6[1];
  if (a2 <= 0)
    v8 = ~(-HIDWORD(a2) / v7);
  else
    v8 = (HIDWORD(a2) - 1) / v7;
  v9 = HIDWORD(a3) + HIDWORD(a2);
  if ((int)*v6 <= 1)
    v10 = 1;
  else
    v10 = *v6;
  if ((int)a2 <= 0)
    v11 = ~(-(int)a2 / v10);
  else
    v11 = ((int)a2 - 1) / v10;
  v12 = a3 + a2;
  if (v9 <= 0)
    v13 = ~(-v9 / v7);
  else
    v13 = (v9 - 1) / v7;
  if (v12 <= 0)
    v14 = ~(-v12 / v10);
  else
    v14 = (v12 - 1) / v10;
  v15 = v4 + 104 * v5 + *(int *)(a1 + 8);
  v16 = ((v14 >> *(_BYTE *)(v15 + 54)) - (v11 >> *(_BYTE *)(v15 + 54)))
      * (uint64_t)((v13 >> *(_BYTE *)(v15 + 21)) - (v8 >> *(_BYTE *)(v15 + 21)));
  v17 = *(_QWORD *)(a1 + 32) + v16;
  *(_QWORD *)(a1 + 32) = v17;
  if (a4)
    *(_QWORD *)(a1 + 24) += v16;
  else
    *(_QWORD *)(a1 + 40) -= v16;
  if (v17 > *(_QWORD *)(a1 + 16) || (*(_QWORD *)(a1 + 40) & 0x8000000000000000) != 0)
    kd_global_rescomp::notify_tile_status();
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)(a1 + 72) = result;
  return result;
}

uint64_t *kd_global_rescomp::close_ready_precinct(kd_global_rescomp *this, kd_precinct *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  __int128 v20;

  v4 = *((_QWORD *)a2 + 8);
  if (v4)
  {
    *(_QWORD *)(v4 + 56) = *((_QWORD *)a2 + 7);
    v5 = *((_QWORD *)a2 + 7);
    if (v5)
    {
LABEL_3:
      v6 = (_QWORD *)(v5 + 64);
      goto LABEL_7;
    }
  }
  else
  {
    if (*((kd_precinct **)this + 6) != a2)
      kd_global_rescomp::close_ready_precinct();
    v5 = *((_QWORD *)a2 + 7);
    *((_QWORD *)this + 6) = v5;
    if (v5)
      goto LABEL_3;
  }
  v6 = (_QWORD *)((char *)this + 56);
  if (*((kd_precinct **)this + 7) != a2)
    kd_global_rescomp::close_ready_precinct();
LABEL_7:
  *v6 = v4;
  *((_QWORD *)a2 + 7) = 0;
  *((_QWORD *)a2 + 8) = 0;
  v7 = *(_QWORD *)a2;
  v8 = (*((_QWORD *)a2 + 1) - *(_QWORD *)(*(_QWORD *)a2 + 232)) >> 3;
  v9 = *(_DWORD *)(*(_QWORD *)a2 + 196);
  v10 = (int)v8 / v9;
  v11 = *(_DWORD *)(*(_QWORD *)a2 + 184);
  LODWORD(v8) = *(_DWORD *)(*(_QWORD *)a2 + 188) - (int)v8 / v9 * v9 + v8;
  v20 = *(_OWORD *)(*(_QWORD *)a2 + 168);
  LODWORD(v20) = v20 + DWORD2(v20) * (v11 + v10);
  DWORD1(v20) += HIDWORD(v20) * v8;
  kdu_dims::operator&=(&v20, (int *)(v7 + 48));
  v13 = DWORD2(v20);
  v12 = HIDWORD(v20);
  *((_QWORD *)this + 8) -= SDWORD2(v20) * (uint64_t)SHIDWORD(v20);
  *((_QWORD *)this + 5) -= v13 * (uint64_t)v12;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)((char *)this + 72) = _Q0;
  return kd_precinct_ref::close(*((uint64_t **)a2 + 1));
}

_BYTE *kd_codestream_comment::set_text(_BYTE *this, int a2, unsigned __int8 *a3)
{
  _QWORD *v4;
  unsigned int v5;
  uint64_t v7;
  void *v8;
  uint64_t v9;

  if (*this)
    kd_codestream_comment::set_text();
  v4 = this;
  *this = 1;
  v5 = a2 - 1;
  if (a2 >= 1)
  {
    if (*((_DWORD *)this + 1) >= a2)
    {
      v8 = (void *)*((_QWORD *)this + 2);
    }
    else
    {
      *((_DWORD *)this + 1) = a2;
      v7 = *((_QWORD *)this + 2);
      if (v7)
        MEMORY[0x18D761C18](v7, 0x1000C8077774924);
      v8 = (void *)operator new[]();
      v4[2] = v8;
    }
    *((_DWORD *)v4 + 2) = a2;
    this = memcpy(v8, a3, a2);
    v9 = v4[2];
    if (*(_BYTE *)(v9 + v5))
      *(_BYTE *)(v9 + a2) = 0;
    else
      --*((_DWORD *)v4 + 2);
  }
  return this;
}

uint64_t kd_codestream_comment::write_marker(kd_codestream_comment *this, kdu_output *a2, int a3)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;

  *(_BYTE *)this = 1;
  if (!a3)
  {
    v8 = 0;
    if (!a2)
      return (v8 + *((_DWORD *)this + 2) + 6);
    goto LABEL_10;
  }
  if (a3 <= 6)
    v5 = 6;
  else
    v5 = a3;
  v6 = v5 - 6;
  v7 = *((_DWORD *)this + 2);
  v8 = v6 - v7;
  if (v6 < v7)
  {
    v8 = 0;
    *((_DWORD *)this + 2) = v6;
    *(_BYTE *)(*((_QWORD *)this + 2) + v6) = 0;
  }
  if (a2)
  {
LABEL_10:
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 100);
    v9 = v8 + *((_DWORD *)this + 2) + 4;
    kdu_output::put(a2, (unsigned __int16)(v8 + *((_WORD *)this + 4) + 4) >> 8);
    kdu_output::put(a2, v9);
    kdu_output::put(a2, 0);
    kdu_output::put(a2, 1);
    kdu_output::write(a2, *((char **)this + 2), *((_DWORD *)this + 2));
    if (v8 >= 1)
    {
      v10 = v8;
      do
      {
        kdu_output::put(a2, 0);
        --v10;
      }
      while (v10);
    }
  }
  return (v8 + *((_DWORD *)this + 2) + 6);
}

uint64_t kdu_codestream_comment::put_text(kdu_codestream_comment *this, const char *__s)
{
  uint64_t v2;
  int v6;
  int v7;
  const char *v8;
  char *v9;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this || *(_BYTE *)v2)
    return 0;
  v6 = *(_DWORD *)(v2 + 8) + strlen(__s);
  v7 = *(_DWORD *)(v2 + 4);
  if (v6 > v7)
  {
    *(_DWORD *)(v2 + 4) = v6 + v7 + 80;
    v8 = *(const char **)(v2 + 16);
    v9 = (char *)operator new[]();
    v2 = *(_QWORD *)this;
    *(_QWORD *)(*(_QWORD *)this + 16) = v9;
    if (v8)
    {
      strcpy(v9, v8);
      MEMORY[0x18D761C18](v8, 0x1000C8077774924);
      v2 = *(_QWORD *)this;
    }
    else
    {
      *v9 = 0;
    }
  }
  *(_DWORD *)(v2 + 8) = v6;
  strcat(*(char **)(v2 + 16), __s);
  return 1;
}

void kd_mct_stage::create_stages(int **a1, int **a2, kdu_params *this, int a4, int a5, uint64_t a6, int a7, uint64_t a8)
{
  kdu_params *v9;
  int v10;
  int v11;
  int v12;
  kdu_params *v17;
  int *v18;
  int *v19;
  int **v21;
  int **v22;
  unsigned int v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  int *v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  int **v32;
  int *v33;
  int *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  _BYTE *v44;
  kdu_params *v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  int v50;
  int v51;
  kdu_params *v52;
  char v53;
  char v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  kdu_params *v60;
  char v61;
  char v62;
  int v63;
  uint64_t v64;
  int v65;
  char *v66;
  char *v67;
  char *v68;
  int *v69;
  uint64_t *v70;
  int **v71;
  uint64_t v72;
  _QWORD *v73;
  int v74;
  float v75;
  float v76;
  float *v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  __int128 *v86;
  _OWORD *v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;
  void *v91;
  uint64_t v92;
  signed int v93;
  uint64_t v94;
  uint64_t v95;
  int *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int *v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  _QWORD *v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  _QWORD *v125;
  uint64_t v126;
  int v127;
  int *v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  int *v132;
  int v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  kdu_params *v139;
  kdu_params *v142;
  int v145;
  kdu_params *v146;
  int v147;
  uint64_t v148;
  _QWORD *v150;
  kdu_params *v151;
  int *v152;
  int v153;
  int v154;
  int v155[2];
  int v156[2];
  int v157;
  int v158;
  int v159;
  int v160;
  __int128 v161;
  __int128 v162;
  uint64_t v163;
  int v164;
  int v165;
  int v166;
  char v167[16];
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  *a1 = 0;
  v9 = (kdu_params *)kdu_params::access_cluster(this, "MCO");
  v166 = 0;
  if (v9)
  {
    v139 = (kdu_params *)kdu_params::access_relation(v9, a4, -1, 0, 1);
    if (v139)
    {
      v147 = a4;
      v10 = kdu_params::get(v139, "Mnum_stages", 0, 0, &v166, 1, 1, 1);
      v11 = v166 ? v10 : 0;
      if (v11 == 1)
      {
        v142 = (kdu_params *)kdu_params::access_cluster(this, "MCC");
        v146 = (kdu_params *)kdu_params::access_cluster(this, "MCT");
        if (v166 >= 1)
        {
          v12 = 0;
          __asm { FMOV            V10.2S, #1.0 }
          while (1)
          {
            v164 = 0;
            v165 = 0;
            v145 = v12;
            if ((kdu_params::get(v139, "Mstages", v12, 0, &v165, 1, 1, 1) & (v142 != 0)) != 1
              || (v17 = (kdu_params *)kdu_params::access_relation(v142, v147, -1, v165, 1), (v151 = v17) == 0)
              || !kdu_params::get(v17, "Mstage_collections", 0, 0, &v164, 1, 1, 1)
              || (kdu_params::get(v151, "Mstage_collections", 0, 1, &v164, 1, 1, 1) & 1) == 0)
            {
              v163 = 0;
              v161 = 0u;
              v162 = 0u;
              kdu_error::kdu_error((kdu_error *)&v161, "Kakadu Core Error:\n");
              (*(void (**)(__int128 *, const char *))(v161 + 16))(&v161, "Unable to access the description of stage ");
              v170 = 0u;
              v171 = 0u;
              v169 = 0u;
              *(_OWORD *)v167 = 0u;
              v168 = 0u;
              if (BYTE8(v161))
                sprintf(v167, "%x");
              else
                sprintf(v167, "%d");
              (*(void (**)(__int128 *, char *))(v161 + 16))(&v161, v167);
              kdu_error::~kdu_error((kdu_error *)&v161);
            }
            v18 = (int *)operator new();
            v152 = v18;
            *((_OWORD *)v18 + 2) = 0u;
            *((_OWORD *)v18 + 3) = 0u;
            *(_OWORD *)v18 = 0u;
            *((_OWORD *)v18 + 1) = 0u;
            v19 = *a2;
            *((_QWORD *)v18 + 6) = *a2;
            _ZF = v19 == 0;
            if (v19)
              v21 = (int **)(v19 + 14);
            else
              v21 = a2;
            v22 = a1;
            if (!_ZF)
              v22 = a2;
            *v21 = v18;
            *v22 = v18;
            v23 = 1;
            if (kdu_params::get(v151, "Mstage_collections", 1, 0, &v164, 1, 1, 1))
            {
              do
              {
                if (!kdu_params::get(v151, "Mstage_collections", v23, 1, &v164, 1, 1, 1))
                  break;
                ++v23;
              }
              while ((kdu_params::get(v151, "Mstage_collections", v23, 0, &v164, 1, 1, 1) & 1) != 0);
            }
            v152[8] = v23;
            v24 = 152 * v23;
            v25 = (_QWORD *)operator new[]();
            *v25 = 152;
            v25[1] = v23;
            v26 = v25 + 2;
            bzero(v25 + 2, 152 * ((v24 - 152) / 0x98uLL) + 152);
            v27 = v152;
            *((_QWORD *)v152 + 5) = v26;
            v159 = -1;
            v160 = 0;
            v157 = -1;
            v158 = 0;
            if (v152[8] >= 1)
              break;
LABEL_128:
            v78 = *((_QWORD *)v27 + 6);
            v79 = *v27;
            if (v78 && v79 > *(_DWORD *)(v78 + 16))
            {
              is_mul_ok(v79, 0x30uLL);
              v80 = operator new[]();
              v81 = v80;
              if (v79)
              {
                v82 = v80;
                do
                {
                  *(_DWORD *)v82 = 0;
                  *(_BYTE *)(v82 + 4) = 0;
                  *(_QWORD *)(v82 + 8) = 0;
                  *(_DWORD *)(v82 + 16) = -1;
                  *(_DWORD *)(v82 + 44) = 0;
                  *(_QWORD *)(v82 + 28) = 0;
                  *(_QWORD *)(v82 + 20) = 0;
                  *(_QWORD *)(v82 + 33) = 0;
                  v82 += 48;
                }
                while (v82 != v80 + 48 * v79);
              }
              v83 = *((_QWORD *)v152 + 6);
              if (*(int *)(v83 + 16) >= 1)
              {
                v84 = 0;
                v85 = 0;
                do
                {
                  v86 = (__int128 *)(*(_QWORD *)(v83 + 24) + v84);
                  v87 = (_OWORD *)(v80 + v84);
                  v88 = *v86;
                  v89 = v86[2];
                  v87[1] = v86[1];
                  v87[2] = v89;
                  *v87 = v88;
                  ++v85;
                  v84 += 48;
                }
                while (v85 < *(int *)(v83 + 16));
              }
              *(_DWORD *)(v83 + 16) = *v152;
              v90 = *(_QWORD *)(v83 + 24);
              if (v90)
              {
                MEMORY[0x18D761C18](v90, 0x1020C806B39A6A2);
                v83 = *((_QWORD *)v152 + 6);
              }
              *(_QWORD *)(v83 + 24) = v81;
            }
            v91 = (void *)operator new[]();
            *((_QWORD *)v152 + 1) = v91;
            v92 = *v152;
            if ((int)v92 >= 1)
              memset(v91, 255, 4 * v92);
            v93 = v152[4];
            if (v145 == v166 - 1 && v93 < a7)
            {
              v152[4] = a7;
              v93 = a7;
            }
            is_mul_ok(v93, 0x30uLL);
            v94 = operator new[]();
            if (v93)
            {
              v95 = v94;
              do
              {
                *(_DWORD *)v95 = 0;
                *(_BYTE *)(v95 + 4) = 0;
                *(_QWORD *)(v95 + 8) = 0;
                *(_DWORD *)(v95 + 16) = -1;
                *(_DWORD *)(v95 + 44) = 0;
                *(_QWORD *)(v95 + 28) = 0;
                *(_QWORD *)(v95 + 20) = 0;
                *(_QWORD *)(v95 + 33) = 0;
                v95 += 48;
              }
              while (v95 != v94 + 48 * v93);
            }
            v96 = v152;
            *((_QWORD *)v152 + 3) = v94;
            if (v152[8] >= 1)
            {
              v97 = 0;
              do
              {
                v98 = *((_QWORD *)v96 + 5);
                v148 = v97;
                v99 = v98 + 152 * v97;
                v100 = operator new[]();
                *(_QWORD *)(v98 + 152 * v148 + 24) = v100;
                LODWORD(v101) = *(_DWORD *)(v99 + 8);
                if ((int)v101 < 1)
                {
                  v96 = v152;
                }
                else
                {
                  v102 = 0;
                  v103 = *(_QWORD *)(v98 + 152 * v148 + 16);
                  v96 = v152;
                  v104 = *((_QWORD *)v152 + 1);
                  do
                  {
                    *(_BYTE *)(v100 + v102) = 0;
                    *(_DWORD *)(v104 + 4 * *(int *)(v103 + 4 * v102)) = *(_DWORD *)(v103 + 4 * v102);
                    ++v102;
                    v101 = *(int *)(v99 + 8);
                  }
                  while (v102 < v101);
                }
                v105 = v98 + 152 * v148;
                v107 = *(_DWORD *)(v105 + 32);
                v106 = (int *)(v105 + 32);
                if (v107 >= 1)
                {
                  v108 = 0;
                  v109 = 0;
                  v110 = v98 + 152 * v148;
                  v111 = (uint64_t *)(v110 + 40);
                  v150 = (_QWORD *)(v110 + 16);
                  v112 = 1;
                  do
                  {
                    v113 = *((_QWORD *)v96 + 3);
                    v114 = *(_DWORD *)(*v111 + 4 * v108);
                    v115 = v113 + 48 * v114;
                    v117 = *(_QWORD *)(v115 + 24);
                    v116 = (_QWORD *)(v115 + 24);
                    if (v117)
                    {
                      *(_QWORD *)&v169 = 0;
                      *(_OWORD *)v167 = 0u;
                      v168 = 0u;
                      kdu_error::kdu_error((kdu_error *)v167, "Kakadu Core Error:\n");
                      (*(void (**)(char *, const char *))(*(_QWORD *)v167 + 16))(v167, "Multi-component transform stage contains multiple transform blocks which provide different definitions for the same stage output component.");
                      kdu_error::~kdu_error((kdu_error *)v167);
                    }
                    *v116 = v99;
                    *(_DWORD *)(v113 + 48 * v114 + 32) = v108;
                    if (v108 < (int)v101)
                    {
                      v118 = *((_QWORD *)v152 + 6);
                      v119 = *(_DWORD *)(*v150 + 4 * v108);
                      if (v118)
                      {
                        v120 = *(_QWORD *)(*(_QWORD *)(v118 + 24) + 48 * v119 + 8);
                        if (v120)
                          v109 = v120;
                      }
                      else
                      {
                        v109 = a6 + 104 * v119;
                      }
                    }
                    *(_QWORD *)(v113 + 48 * v114 + 8) = v109;
                    v96 = v152;
                    if (v109 && v108)
                    {
                      v121 = *((_QWORD *)v152 + 3);
                      v122 = *v111;
                      v123 = v112;
                      do
                      {
                        v124 = v121 + 48 * *(int *)(v122 + 4 * (v123 - 2));
                        v126 = *(_QWORD *)(v124 + 8);
                        v125 = (_QWORD *)(v124 + 8);
                        if (v126)
                          break;
                        *v125 = v109;
                        --v123;
                      }
                      while (v123 > 1);
                    }
                    ++v108;
                    ++v112;
                  }
                  while (v108 < *v106);
                }
                v97 = v148 + 1;
              }
              while (v148 + 1 < v96[8]);
            }
            v127 = *v96;
            if (*v96 >= 1)
            {
              v128 = (int *)*((_QWORD *)v96 + 1);
              v129 = *v96;
              while (1)
              {
                v130 = *v128++;
                if (v130 < 0)
                  break;
                if (!--v129)
                  goto LABEL_175;
              }
LABEL_179:
              *(_QWORD *)&v169 = 0;
              *(_OWORD *)v167 = 0u;
              v168 = 0u;
              kdu_error::kdu_error((kdu_error *)v167, "Kakadu Core Error:\n");
              (*(void (**)(char *, const char *))(*(_QWORD *)v167 + 16))(v167, "Multi-component transform does not satisfy the constraints imposed by Part 2 of the JPEG2000 standard.  The first transform stage must touch every codestream image component (no more and no less), while subsequent stages must touch every component produced by the previous stage.");
              kdu_error::~kdu_error((kdu_error *)v167);
            }
LABEL_175:
            v131 = *((_QWORD *)v96 + 6);
            if (v127 != a5 && !v131 || v131 && v127 < *(_DWORD *)(v131 + 16))
              goto LABEL_179;
            v12 = v145 + 1;
            if (v145 + 1 >= v166)
              goto LABEL_181;
          }
          v28 = 0;
          v29 = 0;
          v30 = 0;
          while (1)
          {
            v31 = *((_QWORD *)v27 + 5);
            v32 = (int **)(v31 + 152 * v28);
            *v32 = v27;
            v33 = (int *)(v32 + 1);
            kdu_params::get(v151, "Mstage_collections", v28, 0, v33, 1, 1, 1);
            v34 = (int *)(v31 + 152 * v28 + 32);
            kdu_params::get(v151, "Mstage_collections", v28, 1, v34, 1, 1, 1);
            if (*v33 < 1 || *v34 <= 0)
            {
              *(_QWORD *)&v169 = 0;
              *(_OWORD *)v167 = 0u;
              v168 = 0u;
              kdu_error::kdu_error((kdu_error *)v167, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)v167);
            }
            v35 = v31 + 152 * v28;
            *(_QWORD *)(v35 + 16) = operator new[]();
            v36 = (_QWORD *)(v35 + 16);
            v37 = v31 + 152 * v28;
            *(_QWORD *)(v37 + 40) = operator new[]();
            v38 = (_QWORD *)(v37 + 40);
            if (*v33 >= 1)
            {
              v39 = 0;
              v40 = v160;
              do
              {
                if (v159 < v40)
                {
                  if (!kdu_params::get(v151, "Mstage_inputs", v30, 0, &v160, 1, 1, 1)
                    || !kdu_params::get(v151, "Mstage_inputs", v30, 1, &v159, 1, 1, 1)
                    || (v40 = v160, v159 < v160)
                    || v160 < 0)
                  {
                    kd_mct_stage::create_stages();
                  }
                  ++v30;
                }
                *(_DWORD *)(*v36 + 4 * v39) = v40;
                v40 = v160 + 1;
                if (v160 >= *v152)
                  *v152 = v40;
                v160 = v40;
                ++v39;
              }
              while (v39 < *v33);
            }
            if (*v34 >= 1)
            {
              v41 = 0;
              v42 = v158;
              do
              {
                if (v157 < v42)
                {
                  if (!kdu_params::get(v151, "Mstage_outputs", v29, 0, &v158, 1, 1, 1)
                    || !kdu_params::get(v151, "Mstage_outputs", v29, 1, &v157, 1, 1, 1)
                    || (v42 = v158, v157 < v158)
                    || v158 < 0)
                  {
                    kd_mct_stage::create_stages();
                  }
                  ++v29;
                }
                *(_DWORD *)(*v38 + 4 * v41) = v42;
                v42 = v158 + 1;
                if (v158 >= v152[4])
                  v152[4] = v42;
                v158 = v42;
                ++v41;
              }
              while (v41 < *v34);
            }
            v43 = v31 + 152 * v28;
            *(_BYTE *)(v43 + 57) = 1;
            v44 = (_BYTE *)(v43 + 57);
            if (v147 < 0)
              goto LABEL_127;
            *(_QWORD *)v155 = 0;
            *(_QWORD *)v156 = 0;
            v154 = 0;
            if (!kdu_params::get(v151, "Mstage_xforms", v28, 0, &v156[1], 1, 1, 1)
              || !kdu_params::get(v151, "Mstage_xforms", v28, 1, v156, 1, 1, 1)
              || !kdu_params::get(v151, "Mstage_xforms", v28, 2, &v155[1], 1, 1, 1)
              || !kdu_params::get(v151, "Mstage_xforms", v28, 3, v155, 1, 1, 1)
              || (kdu_params::get(v151, "Mstage_xforms", v28, 4, &v154, 1, 1, 1) & 1) == 0)
            {
              kd_mct_stage::create_stages();
            }
            if (v155[1])
            {
              if (!v146
                || (v45 = (kdu_params *)kdu_params::access_relation(v146, v147, -1, v155[1], 1),
                    (*(_QWORD *)(v31 + 152 * v28 + 64) = v45) == 0)
                || !kdu_params::get(v45, "Mvector_size", 0, 0, &v164, 1, 1, 1)
                || v164 != *v34)
              {
                v163 = 0;
                v161 = 0u;
                v162 = 0u;
                kdu_error::kdu_error((kdu_error *)&v161, "Kakadu Core Error:\n");
                v170 = 0u;
                v171 = 0u;
                v169 = 0u;
                *(_OWORD *)v167 = 0u;
                v168 = 0u;
                if (BYTE8(v161))
                  sprintf(v167, "%x");
                else
                  sprintf(v167, "%d");
                (*(void (**)(__int128 *, char *))(v161 + 16))(&v161, v167);
                (*(void (**)(__int128 *, const char *))(v161 + 16))(&v161, " and value ");
                v170 = 0u;
                v171 = 0u;
                v169 = 0u;
                *(_OWORD *)v167 = 0u;
                v168 = 0u;
                if (BYTE8(v161))
                  sprintf(v167, "%x");
                else
                  sprintf(v167, "%d");
                (*(void (**)(__int128 *, char *))(v161 + 16))(&v161, v167);
                (*(void (**)(__int128 *, const char *))(v161 + 16))(&v161, ", corresponding to the number of output components produced by the multi-component transform block in question.");
                kdu_error::~kdu_error((kdu_error *)&v161);
              }
            }
            v46 = *v33;
            v47 = *v34;
            if (*v33 != *v34)
              break;
            v49 = v31;
            if (v156[1])
            {
              if (v156[1] != 1)
              {
                if (v156[1] == 3)
                {
                  v63 = v155[0];
                  if (v155[0] >= 1)
                  {
                    *v44 = 0;
                    v64 = v31 + 152 * v28;
                    *(_DWORD *)(v64 + 92) = v63;
                    *(_DWORD *)(v64 + 96) = v154;
                    if (v156[0] >= 2)
                      v65 = -1;
                    else
                      v65 = v156[0];
                    v66 = (char *)(v64 + 56);
                    v67 = (char *)(v64 + 100);
                    v68 = (char *)(v64 + 101);
                    v69 = (int *)(v64 + 88);
                    v70 = (uint64_t *)(v64 + 104);
                    v71 = (int **)(v64 + 112);
                    kd_create_dwt_description(v65, v156[0], this, v147, (BOOL *)(v64 + 56), (BOOL *)(v64 + 100), (BOOL *)(v64 + 101), (unsigned int *)(v64 + 88), (_QWORD *)(v64 + 104), (_QWORD *)(v64 + 112));
                    bzero(v167, 0x288uLL);
                    kdu_kernels::clear((uint64_t)v167);
                    kdu_kernels::init((uint64_t)v167, *v69, *v70, *v71, *v67, *v68, *v66);
                    LODWORD(v161) = 0;
                    v153 = 0;
                    kdu_kernels::get_impulse_response(v167, 2, &v161, (_DWORD *)(v31 + 152 * v28 + 120), (_DWORD *)(v31 + 152 * v28 + 124));
                    kdu_kernels::get_impulse_response(v167, 3, &v153, (_DWORD *)(v31 + 152 * v28 + 128), (_DWORD *)(v31 + 152 * v28 + 132));
                    v72 = v31 + 152 * v28;
                    v73 = (_QWORD *)(v72 + 136);
                    if (*v66)
                    {
                      *v73 = _D10;
                    }
                    else
                    {
                      v74 = *(_DWORD *)&v167[8];
                      v75 = *(float *)&v169;
                      *(_DWORD *)v73 = v169;
                      v76 = *((float *)&v169 + 1);
                      *(_DWORD *)(v72 + 140) = DWORD1(v169);
                      v77 = (float *)(v72 + 140);
                      if (v74 != *v69)
                        __assert_rtn("create_stages", "codestream.cpp", 3258, "nstps == block->dwt_num_steps");
                      *(float *)v73 = 1.0 / v75;
                      *v77 = 0.5 / v76;
                    }
                    kdu_kernels::reset((kdu_kernels *)v167);
                  }
                }
                goto LABEL_127;
              }
              v48 = v155[0];
              v46 = *v33;
              v47 = *v34;
LABEL_79:
              *(_BYTE *)(v49 + 152 * v28 + 56) = v48 != 0;
              if (v48)
                v50 = v46;
              else
                v50 = 0;
              if (v156[0])
              {
                if ((v51 = v50 + v47 * v46, !v146)
                  || (v52 = (kdu_params *)kdu_params::access_relation(v146, v147, -1, v156[0], 1),
                      (*(_QWORD *)(v31 + 152 * v28 + 72) = v52) == 0)
                  || ((v53 = kdu_params::get(v52, "Mmatrix_size", 0, 0, &v164, 1, 1, 1), v164 == v51)
                    ? (v54 = v53)
                    : (v54 = 0),
                      v49 = v31,
                      (v54 & 1) == 0))
                {
                  v163 = 0;
                  v161 = 0u;
                  v162 = 0u;
                  kdu_error::kdu_error((kdu_error *)&v161, "Kakadu Core Error:\n");
                  v170 = 0u;
                  v171 = 0u;
                  v169 = 0u;
                  *(_OWORD *)v167 = 0u;
                  v168 = 0u;
                  if (BYTE8(v161))
                    sprintf(v167, "%x");
                  else
                    sprintf(v167, "%d");
                  (*(void (**)(__int128 *, char *))(v161 + 16))(&v161, v167);
                  (*(void (**)(__int128 *, const char *))(v161 + 16))(&v161, " and value ");
                  v170 = 0u;
                  v171 = 0u;
                  v169 = 0u;
                  *(_OWORD *)v167 = 0u;
                  v168 = 0u;
                  if (BYTE8(v161))
                    sprintf(v167, "%x");
                  else
                    sprintf(v167, "%d");
                  (*(void (**)(__int128 *, char *))(v161 + 16))(&v161, v167);
                  (*(void (**)(__int128 *, const char *))(v161 + 16))(&v161, ", corresponding to the total number of coefficients required to describe the irreversible decorrelation transform or reversible SERM transform in question -- note that reversible transforms are described by M*(M+1) coefficients, where M is the number of input (or output) components.");
                  kdu_error::~kdu_error((kdu_error *)&v161);
                }
              }
              if (!*(_QWORD *)(v49 + 152 * v28 + 72))
                goto LABEL_127;
              goto LABEL_116;
            }
            v55 = v155[0];
            v56 = *v34 - 1;
            v57 = v56 * *v34 + (v56 * *v34 < 0);
            *(_BYTE *)(v31 + 152 * v28 + 56) = v155[0] != 0;
            if (v55)
              v58 = v56;
            else
              v58 = 0;
            if (v156[0])
            {
              if ((v59 = v58 + (v57 >> 1), !v146)
                || (v60 = (kdu_params *)kdu_params::access_relation(v146, v147, -1, v156[0], 1),
                    (*(_QWORD *)(v31 + 152 * v28 + 80) = v60) == 0)
                || ((v61 = kdu_params::get(v60, "Mtriang_size", 0, 0, &v164, 1, 1, 1), v164 == v59)
                  ? (v62 = v61)
                  : (v62 = 0),
                    v49 = v31,
                    (v62 & 1) == 0))
              {
                v163 = 0;
                v161 = 0u;
                v162 = 0u;
                kdu_error::kdu_error((kdu_error *)&v161, "Kakadu Core Error:\n");
                v170 = 0u;
                v171 = 0u;
                v169 = 0u;
                *(_OWORD *)v167 = 0u;
                v168 = 0u;
                if (BYTE8(v161))
                  sprintf(v167, "%x");
                else
                  sprintf(v167, "%d");
                (*(void (**)(__int128 *, char *))(v161 + 16))(&v161, v167);
                (*(void (**)(__int128 *, const char *))(v161 + 16))(&v161, " and value ");
                v170 = 0u;
                v171 = 0u;
                v169 = 0u;
                *(_OWORD *)v167 = 0u;
                v168 = 0u;
                if (BYTE8(v161))
                  sprintf(v167, "%x");
                else
                  sprintf(v167, "%d");
                (*(void (**)(__int128 *, char *))(v161 + 16))(&v161, v167);
                (*(void (**)(__int128 *, const char *))(v161 + 16))(&v161, ", corresponding to the total number of coefficients in the lower triangular matrix which describes the dependency transform in question.  For irreversible dependency transforms, the matrix should not contain any diagonal entries.  For reversible dependency transforms, however, all but the first diagonal entries should also be included, as normalization factors for the integer predictors.");
                kdu_error::~kdu_error((kdu_error *)&v161);
              }
            }
            if (!*(_QWORD *)(v49 + 152 * v28 + 80))
              goto LABEL_127;
LABEL_116:
            *v44 = 0;
LABEL_127:
            ++v28;
            v27 = v152;
            if (v28 >= v152[8])
              goto LABEL_128;
          }
          if (v156[1] != 1 || (v48 = v155[0]) != 0)
          {
            *(_QWORD *)&v169 = 0;
            *(_OWORD *)v167 = 0u;
            v168 = 0u;
            kdu_error::kdu_error((kdu_error *)v167, "Kakadu Core Error:\n");
            kdu_error::~kdu_error((kdu_error *)v167);
          }
          v49 = v31;
          goto LABEL_79;
        }
LABEL_181:
        v132 = *a2;
        v133 = (*a2)[4];
        if (v133 > a7)
        {
          *(_QWORD *)&v169 = 0;
          *(_OWORD *)v167 = 0u;
          v168 = 0u;
          kdu_error::kdu_error((kdu_error *)v167, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)v167);
        }
        if (v133 >= 1)
        {
          v134 = 0;
          v135 = 0;
          do
          {
            v136 = *((_QWORD *)v132 + 3) + v134;
            *(_BYTE *)(v136 + 4) = *(_BYTE *)(a8 + v134 + 4);
            *(_DWORD *)v136 = *(_DWORD *)(a8 + v134);
            if (v147 < 0 && !*(_QWORD *)(v136 + 8))
            {
              *(_QWORD *)&v169 = 0;
              *(_OWORD *)v167 = 0u;
              v168 = 0u;
              kdu_error::kdu_error((kdu_error *)v167, "Kakadu Core Error:\n");
              (*(void (**)(char *, const char *))(*(_QWORD *)v167 + 16))(v167, "Although not strictly illegal, the present Part-2 codestream contains insufficient information to determine the dimensions of all image components output by the multi-component transform, based on main header marker segments.  The fact that this is not illegal is almost certainly an oversight in the development of the Part-2 syntax, but Kakadu cannot work with such codestreams.");
              kdu_error::~kdu_error((kdu_error *)v167);
            }
            ++v135;
            v134 += 48;
          }
          while (v135 < v132[4]);
        }
        kd_mct_stage::apply_output_restrictions(v132, a8, 0, 0);
      }
    }
  }
}

void sub_187F12A6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  kdu_error::~kdu_error((kdu_error *)&a41);
}

void sub_187F12A78(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  _Unwind_Exception *v41;

  _Unwind_Resume(v41);
}

void kd_mct_stage::apply_output_restrictions(int *a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  int v15;
  uint64_t *v16;
  BOOL *v17;
  uint64_t v18;
  BOOL v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  _DWORD *v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int *v39;
  int **v40;
  int *v41;
  uint64_t v42;
  int v43;
  int v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  size_t v51;
  uint64_t v52;
  uint64_t v53;
  int *v54;
  _DWORD *v56;
  uint64_t v57;
  int v58;
  uint64_t i;
  uint64_t v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  int *v65;
  size_t v66;
  _BYTE *v67;
  int v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  int v73;
  char *v74;
  uint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  BOOL v83;
  int v84;
  int v85;
  int v87;
  int v88;
  BOOL v89;
  int v90;
  int v91;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  _BYTE *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  _QWORD *v105;
  _DWORD *v106;
  _DWORD *v107;
  _DWORD *v108;
  _DWORD *v109;
  char *v110;
  int v111;
  uint64_t v112;
  uint64_t v113;
  _DWORD *v114;
  int v115;

  v5 = a3;
  do
  {
    a1[5] = 0;
    v6 = *((_QWORD *)a1 + 7);
    if (v6)
    {
      if (a2 || (v7 = a1[4], (_DWORD)v7 != *(_DWORD *)v6))
        kd_mct_stage::apply_output_restrictions();
      if ((int)v7 < 1)
      {
        v8 = 0;
      }
      else
      {
        v8 = 0;
        v9 = 0;
        v10 = *((_QWORD *)a1 + 3);
        v11 = *(_QWORD *)(v6 + 8);
        v12 = v10 + 20;
        do
        {
          *(_DWORD *)v12 = 0;
          if ((*(_DWORD *)(v11 + 4 * v9) & 0x80000000) != 0)
          {
            *(_DWORD *)(v12 - 4) = -1;
            *(_BYTE *)(v12 + 20) = 0;
          }
          else
          {
            *(_DWORD *)(v10 + 48 * v8 + 20) = v9;
            *(_DWORD *)(v12 - 4) = v8;
            a1[5] = v8 + 1;
            *(_BYTE *)(v12 + 20) = 1;
            if (*(_DWORD *)(v11 + 4 * v9) != v8++)
              kd_mct_stage::apply_output_restrictions();
          }
          ++v9;
          v12 += 48;
        }
        while (v7 != v9);
      }
      if (v8 != *(_DWORD *)(v6 + 4))
        kd_mct_stage::apply_output_restrictions();
      goto LABEL_35;
    }
    if (!a2)
      kd_mct_stage::apply_output_restrictions();
    v14 = a1[4];
    if ((int)v14 < 1)
    {
      v15 = 0;
      if (!a4)
        goto LABEL_35;
      goto LABEL_29;
    }
    v15 = 0;
    v16 = (uint64_t *)(a2 + 16);
    v17 = (BOOL *)(*((_QWORD *)a1 + 3) + 40);
    do
    {
      v18 = *v16;
      *((_QWORD *)v17 - 3) = *v16;
      *v17 = 0;
      if ((v18 & 0x80000000) != 0)
        goto LABEL_22;
      a1[5] = ++v15;
      if (v5)
      {
        if (a4)
          goto LABEL_22;
        v19 = (int)v18 < (int)v5;
      }
      else
      {
        v19 = 1;
      }
      *v17 = v19;
LABEL_22:
      v16 += 6;
      v17 += 48;
      --v14;
    }
    while (v14);
    if (!a4)
      goto LABEL_35;
LABEL_29:
    if ((int)v5 >= 1)
    {
      do
      {
        v21 = *a4++;
        v20 = v21;
        if ((v21 & 0x80000000) == 0 && (int)v20 < v15)
        {
          v22 = *((_QWORD *)a1 + 3);
          v23 = *(_DWORD *)(v22 + 48 * v20 + 20);
          if (*(_DWORD *)(v22 + 48 * v23 + 16) != v20)
            kd_mct_stage::apply_output_restrictions();
          *(_BYTE *)(v22 + 48 * v23 + 40) = 1;
        }
        --v5;
      }
      while (v5);
    }
LABEL_35:
    a1[1] = 0;
    if (*a1 >= 1)
    {
      v24 = 0;
      v25 = *((_QWORD *)a1 + 1);
      do
        *(_DWORD *)(v25 + 4 * v24++) = -1;
      while (v24 < *a1);
    }
    if (a1[8] >= 1)
    {
      v26 = 0;
      while (1)
      {
        v27 = *((_QWORD *)a1 + 5);
        v28 = v27 + 152 * v26;
        *(_DWORD *)(v28 + 12) = 0;
        v29 = (_DWORD *)(v28 + 12);
        v30 = (_DWORD *)(v28 + 8);
        v31 = *(unsigned int *)(v28 + 8);
        if (*(int *)(v28 + 8) >= 1)
        {
          v32 = v27;
          bzero(*(void **)(v27 + 152 * v26 + 24), v31);
          v27 = v32;
          v30 = (_DWORD *)(v28 + 8);
        }
        v33 = v27 + 152 * v26;
        *(_DWORD *)(v33 + 36) = 0;
        v34 = (_DWORD *)(v33 + 36);
        v35 = *(v34 - 1);
        if ((int)v35 < 1)
          goto LABEL_58;
        v36 = 0;
        v37 = *((_QWORD *)a1 + 3);
        v38 = v27 + 152 * v26;
        v41 = *(int **)(v38 + 40);
        v40 = (int **)(v38 + 40);
        v39 = v41;
        v42 = *(v34 - 1);
        do
        {
          v44 = *v39++;
          v43 = v44;
          if (*(_BYTE *)(v37 + 48 * v44 + 40))
          {
            if ((*(_DWORD *)(v37 + 48 * v43 + 16) & 0x80000000) != 0 || *(_QWORD *)(v37 + 48 * v43 + 24) != v28)
              kd_mct_stage::apply_output_restrictions();
            *(_DWORD *)(v37 + 48 * v43 + 36) = v36++;
            *v34 = v36;
          }
          --v42;
        }
        while (v42);
        if (!v36)
          goto LABEL_58;
        if (v36 != (_DWORD)v31 && !*(_QWORD *)(v27 + 152 * v26 + 72))
          break;
        if ((int)v31 >= 1)
        {
          v45 = v30;
          v46 = v27;
          memset(*(void **)(v27 + 152 * v26 + 24), 1, v31);
          v27 = v46;
          v30 = v45;
          *v29 = v31;
LABEL_54:
          v47 = 0;
          v48 = v27 + 152 * v26;
          v49 = *(_QWORD *)(v48 + 24);
          v50 = (_QWORD *)(v48 + 16);
          do
          {
            if (*(_BYTE *)(v49 + v47))
            {
              *(_DWORD *)(*((_QWORD *)a1 + 1) + 4 * *(int *)(*v50 + 4 * v47)) = 0;
              LODWORD(v31) = *v30;
            }
            ++v47;
          }
          while (v47 < (int)v31);
        }
LABEL_58:
        if (++v26 >= a1[8])
          goto LABEL_129;
      }
      if (*(_QWORD *)(v27 + 152 * v26 + 80))
      {
        v51 = 0;
        v52 = 0;
        v53 = *((_QWORD *)a1 + 3);
        v54 = *v40;
        do
        {
          if (*(unsigned __int8 *)(v53 + 48 * v54[v52++] + 40))
          {
            *v29 = v52;
            v51 = v52;
          }
        }
        while (v35 != v52);
        if ((int)v51 >= 1)
        {
          v56 = v30;
          v57 = v27;
          memset(*(void **)(v27 + 152 * v26 + 24), 1, v51);
          v27 = v57;
          v30 = v56;
        }
      }
      else if (*(_BYTE *)(v27 + 152 * v26 + 57))
      {
        v58 = 0;
        for (i = 0; i != v35; ++i)
        {
          if (i < (int)v31 && *(_BYTE *)(*((_QWORD *)a1 + 3) + 48 * (*v40)[i] + 40))
          {
            *(_BYTE *)(*(_QWORD *)(v27 + 152 * v26 + 24) + i) = 1;
            *v29 = ++v58;
          }
        }
      }
      else
      {
        v60 = v27 + 152 * v26;
        v63 = *(_QWORD *)(v60 + 144);
        v62 = (uint64_t *)(v60 + 144);
        v61 = v63;
        v113 = v27;
        v114 = v30;
        if (!v63)
        {
          v61 = operator new[]();
          v27 = v113;
          v30 = v114;
          *v62 = v61;
        }
        if ((int)v31 >= 1)
        {
          v64 = *((_QWORD *)a1 + 3);
          v65 = *v40;
          v66 = v31;
          v67 = (_BYTE *)v61;
          do
          {
            v68 = *v65++;
            *v67++ = *(_BYTE *)(v64 + 48 * v68 + 40);
            --v66;
          }
          while (v66);
        }
        v69 = v27 + 152 * v26;
        v70 = *(_DWORD *)(v69 + 92);
        v71 = *(_DWORD *)(v69 + 96);
        v72 = v71 + v31;
        if (v70 >= 1)
        {
          v73 = 0;
          v74 = (char *)(v61 + (int)v31);
          v75 = v27 + 152 * v26;
          v76 = (_QWORD *)(v75 + 24);
          v112 = v61;
          v111 = v70;
          v109 = (_DWORD *)(v75 + 124);
          v110 = v74;
          v107 = (_DWORD *)(v75 + 132);
          v108 = (_DWORD *)(v75 + 120);
          v105 = (_QWORD *)(v75 + 24);
          v106 = (_DWORD *)(v75 + 128);
          do
          {
            v77 = v71;
            v78 = &v74[-v71];
            if (v71 < v72)
            {
              v79 = v61 - v71;
              v115 = v73;
              bzero(v74, (v72 + ~v71) + 1);
              v76 = v105;
              v74 = v110;
              v73 = v115;
              v70 = v111;
              v61 = v112;
              v27 = v113;
              v30 = v114;
              v80 = v77;
              do
              {
                if (*(_BYTE *)(v79 + v80))
                {
                  v81 = ((v80 - *v109) & 1) + v80 - *v109;
                  v82 = (v80 - *v108) & 0xFFFFFFFE;
                  while (v81 <= v82)
                  {
                    v83 = v81 < (int)v77;
                    if (v81 < (int)v77 || (v84 = v81, v81 >= v72))
                    {
                      v84 = v81;
                      do
                      {
                        if (v83)
                          v85 = 2 * v77;
                        else
                          v85 = 2 * v72 - 2;
                        v84 = v85 - v84;
                        v83 = v84 < (int)v77;
                      }
                      while (v84 < (int)v77 || v84 >= v72);
                    }
                    v78[v84] = 1;
                    v81 += 2;
                  }
                  v87 = (v80 - *v107) | 1;
                  v88 = v80 - *v106 + ((v80 - *v106) | 0xFFFFFFFE) + 1;
                  while (v87 <= v88)
                  {
                    v89 = v87 < (int)v77;
                    if (v87 < (int)v77 || (v90 = v87, v87 >= v72))
                    {
                      v90 = v87;
                      do
                      {
                        if (v89)
                          v91 = 2 * v77;
                        else
                          v91 = 2 * v72 - 2;
                        v90 = v91 - v90;
                        v89 = v90 < (int)v77;
                      }
                      while (v90 < (int)v77 || v90 >= v72);
                    }
                    v78[v90] = 1;
                    v87 += 2;
                  }
                }
                ++v80;
              }
              while (v80 != v72);
            }
            LODWORD(v93) = v72 + (~(_BYTE)v72 | 0xFFFFFFFE);
            if ((int)v93 >= (int)(v77 | 1))
            {
              v93 = (int)v93;
              v94 = v31 - 1;
              do
              {
                if ((int)v31 <= 0)
                  kd_mct_stage::apply_output_restrictions();
                *(_BYTE *)(*v76 + v94) = v78[v93];
                *v29 += v78[v93];
                v93 -= 2;
                LODWORD(v31) = v31 - 1;
                --v94;
              }
              while (v93 >= (int)(v77 | 1));
            }
            v71 = ((int)v77 + 1) >> 1;
            v72 = (v72 + 1) >> 1;
            if (v71 < v72)
            {
              v95 = 2 * v71;
              v96 = v72 - (uint64_t)v71;
              v97 = (_BYTE *)v61;
              do
              {
                *v97++ = v78[v95];
                v95 += 2;
                --v96;
              }
              while (v96);
            }
            ++v73;
          }
          while (v73 != v70);
        }
        if (v72 > v71)
        {
          v98 = v72;
          v99 = v31 - 1;
          v100 = v61 - v71 - 1;
          do
          {
            if ((int)v31 <= 0)
              kd_mct_stage::apply_output_restrictions();
            *(_BYTE *)(*(_QWORD *)(v27 + 152 * v26 + 24) + v99) = *(_BYTE *)(v100 + v98);
            *v29 += *(unsigned __int8 *)(v100 + v98);
            LODWORD(v31) = v31 - 1;
            --v99;
            --v98;
          }
          while (v98 > v71);
        }
        if ((_DWORD)v31)
          kd_mct_stage::apply_output_restrictions();
        LODWORD(v31) = *v30;
      }
      if ((int)v31 < 1)
        goto LABEL_58;
      goto LABEL_54;
    }
LABEL_129:
    if (a1[1])
      kd_mct_stage::apply_output_restrictions();
    v101 = *a1;
    if (*a1 >= 1)
    {
      v102 = 0;
      v103 = *((_QWORD *)a1 + 1);
      do
      {
        if ((*(_DWORD *)(v103 + 4 * v102) & 0x80000000) == 0)
        {
          v104 = a1[1];
          a1[1] = v104 + 1;
          *(_DWORD *)(v103 + 4 * v102) = v104;
          v101 = *a1;
        }
        ++v102;
      }
      while (v102 < v101);
    }
    a2 = 0;
    v5 = 0;
    a4 = 0;
    a1 = (int *)*((_QWORD *)a1 + 6);
  }
  while (a1);
}

uint64_t kd_mct_block::analyze_sensitivity(uint64_t this, int a2, float a3, int *a4, int *a5, char a6)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int16 *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  _DWORD *v28;
  uint64_t v29;
  _DWORD *v30;
  _DWORD *v31;
  uint64_t v32;
  _DWORD *v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;

  v11 = this;
  if (*(_BYTE *)(this + 57))
  {
    v12 = *(_DWORD *)(*(_QWORD *)(this + 40) + 4 * a2);
    v13 = *(_QWORD *)(*(_QWORD *)this + 24);
    if (*(_BYTE *)(v13 + 48 * v12 + 40) || (a6 & 1) == 0)
    {
      v14 = *a4;
      v15 = *a5;
      if ((int)v14 <= *a5)
      {
        if ((int)v14 > v12)
        {
          v31 = (_DWORD *)(v13 + 48 * (int)v14 - 4);
          do
          {
            --v14;
            *v31 = 0;
            v31 -= 12;
          }
          while (v14 > v12);
          *a4 = v14;
          v15 = *a5;
        }
        if (v15 < v12)
        {
          v32 = v12 - (uint64_t)v15;
          v33 = (_DWORD *)(v13 + 48 * v15 + 92);
          do
          {
            *v33 = 0;
            v33 += 12;
            --v32;
          }
          while (v32);
          *a5 = v12;
        }
      }
      else
      {
        *a5 = v12;
        *a4 = v12;
        *(_DWORD *)(v13 + 48 * v12 + 44) = 0;
      }
      *(float *)(v13 + 48 * v12 + 44) = *(float *)(v13 + 48 * v12 + 44) + a3;
    }
  }
  else
  {
    if (!*(_QWORD *)(this + 48))
    {
      v34 = *(int *)(this + 8);
      is_mul_ok(v34, 0x18uLL);
      v35 = 24 * v34;
      v36 = (_QWORD *)operator new[]();
      *v36 = 24;
      v36[1] = v34;
      if ((_DWORD)v34)
      {
        v37 = v36 + 3;
        do
        {
          *v37 = 0;
          v37[1] = 0;
          v37 += 3;
          v35 -= 24;
        }
        while (v35);
      }
      *(_QWORD *)(v11 + 48) = v36 + 2;
      if (*(_QWORD *)(v11 + 72))
      {
        if (*(_BYTE *)(v11 + 56))
          this = kd_mct_block::create_rxform_ss_model((kd_mct_block *)v11);
        else
          this = kd_mct_block::create_matrix_ss_model((kd_mct_block *)v11);
      }
      else if (*(_QWORD *)(v11 + 80))
      {
        this = kd_mct_block::create_dependency_ss_model((kd_mct_block *)v11);
      }
      else
      {
        if (*(int *)(v11 + 92) < 1)
          kd_mct_block::analyze_sensitivity();
        this = kd_mct_block::create_dwt_ss_model((kd_mct_block *)v11);
      }
    }
    v16 = *(_QWORD *)(v11 + 48);
    if (*(__int16 *)(v16 + 24 * a2 + 2) >= 1)
    {
      v17 = 0;
      v18 = *(unsigned __int16 *)(v16 + 24 * a2 + 2);
      v19 = (__int16 *)(v16 + 24 * a2);
      v22 = *v19;
      v20 = (uint64_t *)(v19 + 4);
      v21 = v22;
      v23 = *(_QWORD *)(v11 + 40);
      v24 = *(_QWORD *)(*(_QWORD *)v11 + 24);
      do
      {
        this = *(unsigned int *)(v23 + 4 * (v17 + v21));
        if (*(_BYTE *)(v24 + 48 * (int)this + 40) || (a6 & 1) == 0)
        {
          v25 = *(_DWORD *)(v23 + 4 * (v17 + v21));
          v26 = *a4;
          v27 = *a5;
          if ((int)v26 <= *a5)
          {
            if ((int)v26 > (int)this)
            {
              v28 = (_DWORD *)(v24 - 4 + 48 * (int)v26);
              do
              {
                --v26;
                *v28 = 0;
                v28 -= 12;
              }
              while (v26 > (int)this);
              *a4 = v26;
              v27 = *a5;
            }
            if (v27 < (int)this)
            {
              v29 = (int)this - (uint64_t)v27;
              v30 = (_DWORD *)(v24 + 92 + 48 * v27);
              do
              {
                *v30 = 0;
                v30 += 12;
                --v29;
              }
              while (v29);
              *a5 = this;
            }
          }
          else
          {
            *a5 = this;
            *a4 = this;
            *(_DWORD *)(v24 + 48 * (int)this + 44) = 0;
          }
          this = *v20;
          *(float *)(v24 + 48 * v25 + 44) = *(float *)(v24 + 48 * v25 + 44)
                                            + (float)(a3 * *(float *)(*v20 + 4 * v17));
        }
        ++v17;
      }
      while (v17 != v18);
    }
  }
  return this;
}

uint64_t kd_mct_block::create_matrix_ss_model(kd_mct_block *this)
{
  uint64_t v2;
  uint64_t result;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;

  v2 = *((_QWORD *)this + 6);
  result = operator new[]();
  *(_QWORD *)(v2 + 16) = result;
  v4 = *((_DWORD *)this + 2);
  if (v4 >= 1)
  {
    v5 = result;
    v6 = 0;
    v7 = *((_DWORD *)this + 8);
    do
    {
      *(_QWORD *)(v2 + 8) = v5;
      *(_WORD *)v2 = 0;
      *(_WORD *)(v2 + 2) = v7;
      if (v7 < 1)
      {
        v11 = v7;
      }
      else
      {
        v8 = 0;
        v9 = 0;
        do
        {
          v10 = (float *)(*(_QWORD *)(v2 + 8) + v8);
          *v10 = 0.0;
          result = kdu_params::get(*((kdu_params **)this + 9), "Mmatrix_coeffs", v6 + *((_DWORD *)this + 2) * (int)v9++, 0, v10, 1, 1, 1);
          v7 = *((_DWORD *)this + 8);
          v8 += 4;
        }
        while (v9 < v7);
        v11 = v7;
        v4 = *((_DWORD *)this + 2);
      }
      ++v6;
      v2 += 24;
      v5 += 4 * v11;
    }
    while (v6 < v4);
  }
  return result;
}

uint64_t kd_mct_block::create_rxform_ss_model(kd_mct_block *this)
{
  uint64_t v1;
  int v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64x2_t v9;
  int64x2_t v10;
  uint64_t v11;
  int64x2_t v12;
  int32x2_t v13;
  float v14;
  float v15;
  int v16;
  int v17;
  uint64_t v18;
  float v19;
  float v20;
  uint64_t i;
  uint64_t *v22;
  int v23;
  uint64_t v24;
  float v26;
  float v27;

  v1 = *((unsigned int *)this + 2);
  if ((_DWORD)v1 != *((_DWORD *)this + 8))
    kd_mct_block::create_rxform_ss_model();
  v3 = v1 + 1;
  v4 = *((_QWORD *)this + 6);
  result = operator new[]();
  *(_QWORD *)(v4 + 16) = result;
  v6 = *((unsigned int *)this + 2);
  if ((int)v6 >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = (uint64x2_t)vdupq_n_s64(v1 - 1);
    v10 = vdupq_n_s64(2uLL);
    do
    {
      *(_QWORD *)(v4 + 8) = result;
      *(_WORD *)v4 = 0;
      *(_WORD *)(v4 + 2) = v1;
      if ((int)v1 >= 1)
      {
        v11 = 0;
        v12 = (int64x2_t)xmmword_18820C490;
        do
        {
          v13 = vmovn_s64((int64x2_t)vcgeq_u64(v9, (uint64x2_t)v12));
          if ((v13.i8[0] & 1) != 0)
          {
            if (v7 == v11)
              v14 = 1.0;
            else
              v14 = 0.0;
            *(float *)(result + v11) = v14;
          }
          if ((v13.i8[4] & 1) != 0)
          {
            if (v7 - 4 == v11)
              v15 = 1.0;
            else
              v15 = 0.0;
            *(float *)(result + v11 + 4) = v15;
          }
          v12 = vaddq_s64(v12, v10);
          v11 += 8;
        }
        while (((4 * v1 + 4) & 0x7FFFFFFF8) != v11);
      }
      ++v8;
      v4 += 24;
      result += 4 * (int)v1;
      v7 += 4;
    }
    while (v8 != v6);
  }
  if ((v1 & 0x80000000) == 0)
  {
    v16 = 0;
    do
    {
      if (v16 == (_DWORD)v1)
        v17 = -1;
      else
        v17 = ~v16;
      v18 = (v17 + v1);
      v27 = 1.0;
      result = kdu_params::get(*((kdu_params **)this + 9), "Mmatrix_coeffs", v16 + (int)v18 * v3, 0, &v27, 1, 1, 1);
      v19 = 1.0;
      v20 = 1.0 / v27;
      v27 = v20;
      if (v20 < 0.0)
      {
        if (v16 != (_DWORD)v1)
          kd_mct_block::create_rxform_ss_model();
        v27 = -v20;
        v19 = -1.0;
      }
      if ((_DWORD)v1)
      {
        for (i = 0; i != v1; ++i)
        {
          if (i != v18)
          {
            v26 = 0.0;
            result = kdu_params::get(*((kdu_params **)this + 9), "Mmatrix_coeffs", v16 + v3 * (int)i, 0, &v26, 1, 1, 1);
            v26 = v27 * v26;
            v22 = (uint64_t *)(*((_QWORD *)this + 6) + 8);
            v23 = v1;
            do
            {
              v24 = *v22;
              v22 += 3;
              *(float *)(v24 + 4 * (int)v18) = v19
                                               * (float)(*(float *)(v24 + 4 * (int)v18)
                                                       - (float)(v26 * *(float *)(v24 + 4 * i)));
              --v23;
            }
            while (v23);
          }
        }
      }
    }
    while (v16++ != (_DWORD)v1);
  }
  return result;
}

uint64_t kd_mct_block::create_dependency_ss_model(kd_mct_block *this)
{
  uint64_t v2;
  uint64_t result;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  unsigned int v14;
  int v15;
  int v16;
  _QWORD *v17;
  int v18;
  float v19;
  float v20;

  if (*((_DWORD *)this + 2) != *((_DWORD *)this + 8))
    kd_mct_block::create_dependency_ss_model();
  v2 = *((_QWORD *)this + 6);
  result = operator new[]();
  *(_QWORD *)(v2 + 16) = result;
  v4 = *((_DWORD *)this + 2);
  v5 = *((_DWORD *)this + 8);
  if (v4 >= 1)
  {
    v6 = 0;
    v7 = v5 << 16;
    v8 = *((_DWORD *)this + 8);
    do
    {
      *(_WORD *)v2 = v6;
      *(_QWORD *)(v2 + 8) = result;
      result += 4 * (v7 >> 16);
      ++v6;
      *(_WORD *)(v2 + 2) = v8;
      v7 -= 0x10000;
      --v8;
      v2 += 24;
    }
    while (v4 != v6);
  }
  if (v5 >= 1)
  {
    v9 = 0;
    v10 = 0;
    v11 = *((_QWORD *)this + 6);
    do
    {
      if (v10 <= 1)
        v12 = 1;
      else
        v12 = v10;
      if (v10)
      {
        v13 = (_QWORD *)(v11 + 8);
        v14 = v10;
        do
        {
          *(_DWORD *)(*v13 + 4 * (int)(v10 - *((__int16 *)v13 - 4))) = 0;
          v13 += 3;
          --v14;
        }
        while (v14);
        if (v10 != *((__int16 *)v13 - 4))
LABEL_25:
          kd_mct_block::create_dependency_ss_model();
        *(_DWORD *)*v13 = 1065353216;
        v20 = 1.0;
        if (*((_BYTE *)this + 56))
        {
          kdu_params::get(*((kdu_params **)this + 10), "Mtriang_coeffs", v9 + v10, 0, &v20, 1, 1, 1);
          v20 = 1.0 / v20;
        }
        v15 = 0;
        v16 = 1;
        do
        {
          v19 = 0.0;
          result = kdu_params::get(*((kdu_params **)this + 10), "Mtriang_coeffs", v15 + v9, 0, &v19, 1, 1, 1);
          v19 = v20 * v19;
          v11 = *((_QWORD *)this + 6);
          v17 = (_QWORD *)(v11 + 8);
          v18 = v16;
          do
          {
            *(float *)(*v17 + 4 * (int)(v10 - *((__int16 *)v17 - 4))) = *(float *)(*v17
                                                                                   + 4
                                                                                   * (int)(v10 - *((__int16 *)v17 - 4)))
                                                                        + (float)(v19
                                                                                * *(float *)(*v17
                                                                                           + 4
                                                                                           * (v15 - *((__int16 *)v17 - 4))));
            v17 += 3;
            --v18;
          }
          while (v18);
          ++v15;
          ++v16;
        }
        while (v15 != v12);
        v9 += v10 + *((unsigned __int8 *)this + 56);
        v5 = *((_DWORD *)this + 8);
      }
      else
      {
        if (*(_WORD *)v11)
          goto LABEL_25;
        **(_DWORD **)(v11 + 8) = 1065353216;
      }
      ++v10;
    }
    while ((int)v10 < v5);
  }
  return result;
}

uint64_t kd_mct_block::create_dwt_ss_model(kd_mct_block *this)
{
  kd_mct_block *v1;
  uint64_t result;
  uint64_t v3;
  _BOOL8 v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  BOOL v18;
  int v19;
  int v20;
  _DWORD *v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  float *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  char v32;
  int *v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  _BOOL8 v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  float *v53;
  int v54;
  BOOL v55;
  int v57;
  uint64_t v58;
  unsigned __int16 *v59;
  _DWORD *v60;
  int *v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  uint64_t v67;
  BOOL v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  _BOOL4 v75;
  int v76;
  __int16 v77;
  int v78;
  char *v79;
  char *v80;
  float *v81;
  int v82;
  int v83;
  uint64_t v84;
  kd_mct_block *v85;
  float *v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;
  int v91;
  char v92;
  uint64_t v93;
  uint64_t v94;
  _DWORD v95[2];
  _DWORD v96[2];
  uint64_t v97;

  v97 = *MEMORY[0x1E0C80C00];
  v71 = *((_DWORD *)this + 2);
  if (v71 != *((_DWORD *)this + 8))
    kd_mct_block::create_dwt_ss_model();
  v1 = this;
  result = *((_QWORD *)this + 18);
  v85 = v1;
  if (!result)
  {
    result = operator new[]();
    v1 = v85;
    *((_QWORD *)v85 + 18) = result;
  }
  v76 = *((_DWORD *)v1 + 23);
  if (v76 >= 1)
  {
    v70 = 0;
    v3 = result - 4 * *((int *)v1 + 24);
    v74 = v71 - 1;
    while (1)
    {
      v4 = v76 != *((_DWORD *)v1 + 23);
      v5 = v76 - 1;
      v72 = 1 << v76;
      do
      {
        result = v4;
        v75 = v4 << v5;
        v6 = *((_DWORD *)v1 + 24) + ~(v4 << v5);
        v7 = (v6 + v71) >> v76;
        v69 = v6 >> v76;
        if (v6 >> v76 >= v7)
          goto LABEL_98;
        v8 = v69 + 1;
        v9 = (4 * result) ^ 4;
        v80 = (char *)&v95[-2] + v9;
        v81 = (float *)((char *)v1 + 4 * result + 136);
        v79 = (char *)&v93 + v9;
        v73 = v7;
        v84 = result;
        do
        {
          LODWORD(v10) = (v8 << v76) + v75;
          *(_DWORD *)(v3 + 4 * (int)v10) = 1065353216;
          v11 = *((_DWORD *)v1 + 24);
          v12 = v11 - 1;
          v77 = v11;
          v78 = v8;
          v13 = v74 + v11;
          v14 = v10;
          v15 = v5;
          v82 = v74 + v11;
          v83 = v11 - 1;
          do
          {
            v16 = ((v12 >> v15) + 1) << v15;
            v17 = v13 & (-1 << v15);
            v18 = v14 >= v16 && (int)v10 <= (int)v17;
            if (!v18)
              kd_mct_block::create_dwt_ss_model();
            if (v16 == (_DWORD)v17)
            {
              if (v14 != (_DWORD)v10)
                kd_mct_block::create_dwt_ss_model();
              if (result && v15 == v5)
                *(float *)(v3 + 4 * (int)v10) = *(float *)(v3 + 4 * (int)v10) * 0.5;
              v14 = v10;
              goto LABEL_85;
            }
            v19 = 1 << v15;
            v96[0] = (v16 & (1 << v15)) + v16;
            v96[1] = v16 | (1 << v15);
            v95[0] = v17 - (v17 & (1 << v15));
            v95[1] = v17 - v19 + (v17 & v19);
            v93 = 0;
            v94 = 0;
            v20 = 2 << v15;
            if (v15 == v5)
            {
              if (v14 != (_DWORD)v10)
                kd_mct_block::create_dwt_ss_model();
              *(float *)(v3 + 4 * (int)v10) = *v81 * *(float *)(v3 + 4 * (int)v10);
              *((_DWORD *)&v93 + result) = v10;
              v95[result - 2] = v10;
              v22 = v79;
              v21 = v80;
            }
            else
            {
              if (((v10 | v14) & v19) != 0)
                kd_mct_block::create_dwt_ss_model();
              if (v14 <= (int)v10)
              {
                v23 = v14;
                do
                {
                  *(float *)(v3 + 4 * v23) = *((float *)v1 + 34) * *(float *)(v3 + 4 * v23);
                  v23 += v20;
                }
                while (v23 <= (int)v10);
              }
              LODWORD(v24) = v14 + v19;
              if (v14 + v19 < (int)v10)
              {
                v24 = (int)v24;
                do
                {
                  *(_DWORD *)(v3 + 4 * v24) = 0;
                  v24 += v20;
                }
                while (v24 < (int)v10);
              }
              LODWORD(v94) = v14;
              LODWORD(v93) = v10;
              v22 = (_DWORD *)&v93 + 1;
              v21 = (_DWORD *)&v94 + 1;
            }
            *v21 = 0;
            *v22 = -1;
            v25 = *((unsigned int *)v1 + 22);
            if ((int)v25 >= 1)
            {
              v26 = (int *)*((_QWORD *)v1 + 13);
              v27 = (float *)*((_QWORD *)v1 + 14);
              v28 = *((unsigned int *)v1 + 22);
              v86 = v27;
              do
              {
                v29 = *v26;
                v26 += 4;
                v27 += v29;
                --v28;
              }
              while (v28);
              v30 = *((_QWORD *)v1 + 13);
              v87 = v15;
              v92 = v15 + 1;
              v89 = 2 * v16;
              v31 = *((unsigned __int8 *)v1 + 101);
              v88 = 2 * v17;
              v91 = v16;
              v90 = v30;
              while (1)
              {
                v32 = v25 - 1;
                v33 = (int *)(v30 + 16 * (v25 - 1));
                v34 = *v33;
                v27 -= v34;
                v35 = (((_DWORD)v25 - 1) & 1) != 0 ? v19 : -v19;
                v36 = *(_DWORD *)((unint64_t)&v94 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v32 & 1)));
                v37 = *(_DWORD *)((unint64_t)&v93 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v32 & 1)));
                if (v36 <= v37)
                  break;
LABEL_82:
                v18 = v25-- <= 1;
                if (v18)
                {
                  v1 = v85;
                  v12 = v83;
                  v5 = v76 - 1;
                  result = v84;
                  v13 = v82;
                  v15 = v87;
                  if (v27 != v86)
                    kd_mct_block::create_dwt_ss_model();
                  goto LABEL_85;
                }
              }
              v38 = v33[1];
              v39 = (v38 << v92) + v35;
              v40 = (((_DWORD)v34 + v38 - 1) << v92) + v35;
              v41 = !(((_BYTE)v25 - 1) & 1);
              LODWORD(v42) = v36 - v40;
              v43 = v96[v41];
              if (v36 - v40 < v43 || v89 - v43 - v39 >= v36)
                LODWORD(v42) = v96[v41];
              v44 = v37 - v39;
              v45 = v95[v41];
              if (v37 - v39 > v45 || v88 - v45 - v40 <= v37)
                v44 = v95[v41];
              v46 = v95[v41 - 2];
              v47 = *((_DWORD *)&v93 + v41);
              if (v46 > v47)
              {
                v95[v41 - 2] = v42;
                goto LABEL_48;
              }
              if ((int)v42 >= v46)
              {
                if (v44 > v47)
LABEL_48:
                  *((_DWORD *)&v93 + v41) = v44;
              }
              else
              {
                v95[v41 - 2] = v42;
              }
              for (; v14 > (int)v42; v14 -= v19)
                *(_DWORD *)(v3 + 4 * (v14 - v19)) = 0;
              if ((int)v10 < v44)
              {
                v48 = (int)v10;
                do
                {
                  v10 = v48 + v19;
                  *(_DWORD *)(v3 + 4 * v19 + 4 * v48) = 0;
                  v48 = v10;
                }
                while (v10 < v44);
              }
              v49 = v16;
              v50 = v17;
              if (!v31)
              {
                v49 = *(_DWORD *)((unint64_t)v96 | (4 * (v32 & 1)));
                v50 = *(_DWORD *)((unint64_t)v95 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v32 & 1)));
              }
              if ((int)v42 <= v44)
              {
                v51 = v17;
                v42 = (int)v42;
                do
                {
                  if (v39 <= v40)
                  {
                    v52 = v39;
                    v53 = v27;
                    do
                    {
                      v54 = v52 + v42;
                      v55 = v52 + (int)v42 < v49;
                      if (v52 + (int)v42 < v49 || v54 > v50)
                      {
                        do
                        {
                          if (v31)
                          {
                            v57 = 2 * v50 - v54;
                            v54 = 2 * v49 - v54;
                            if (!v55)
                              v54 = v57;
                          }
                          else if (v55)
                          {
                            v54 = v49;
                          }
                          else
                          {
                            v54 = v50;
                          }
                          v55 = v54 < v49;
                        }
                        while (v54 < v49 || v54 > v50);
                      }
                      if (v54 >= v36 && v54 <= v37)
                        *(float *)(v3 + 4 * v42) = *(float *)(v3 + 4 * v42) - (float)(*(float *)(v3 + 4 * v54) * *v53);
                      v52 += v20;
                      ++v53;
                    }
                    while (v52 <= v40);
                  }
                  v42 += v20;
                }
                while (v42 <= v44);
                v16 = v91;
                v17 = v51;
                v30 = v90;
              }
              goto LABEL_82;
            }
LABEL_85:
            v18 = v15-- <= 0;
          }
          while (!v18);
          v58 = *((_QWORD *)v1 + 6);
          v59 = (unsigned __int16 *)(v58 + 24 * v70 + 24 * (v78 - (v69 + 1)));
          *v59 = v14 - v77;
          v59[1] = v10 - v14 + 1;
          v60 = (_DWORD *)operator new[]();
          *(int64x2_t *)(v59 + 4) = vdupq_n_s64((unint64_t)v60);
          if ((int)v10 >= v14)
          {
            v61 = (int *)(v3 + 4 * v14);
            v62 = v10 - v14 + 1;
            do
            {
              v63 = *v61++;
              *v60++ = v63;
              --v62;
            }
            while (v62);
          }
          v7 = v73;
          if ((__int16)*v59 < 1)
          {
            result = v84;
            v1 = v85;
            v5 = v76 - 1;
            v66 = v78;
          }
          else
          {
            v64 = *v59;
            v65 = v71 - (v64 + (__int16)v59[1]);
            v66 = v78;
            v67 = v58 + 24 * v70 - 24 * (v69 + 1) + 24 * v78 + 24;
            result = v84;
            v1 = v85;
            v5 = v76 - 1;
            do
            {
              v68 = __OFSUB__(v65, v72);
              v65 -= v72;
              if ((v65 < 0) ^ v68 | (v65 == 0))
                break;
              if (v66 > v73)
                break;
              v64 += v72;
              *(_QWORD *)(v67 + 8) = *(_QWORD *)(v67 - 16);
              *(_WORD *)v67 = v64;
              *(_WORD *)(v67 + 2) = *(_WORD *)(v67 - 22);
              ++v66;
              v67 += 24;
            }
            while (v64 > 0);
          }
          v8 = v66 + 1;
        }
        while (v66 < v73);
LABEL_98:
        v70 = v70 + v7 - v69;
        v4 = 1;
      }
      while (!result);
      v18 = v76 <= 1;
      v76 = v5;
      if (v18)
        goto LABEL_103;
    }
  }
  v70 = 0;
LABEL_103:
  if (v70 != *((_DWORD *)v1 + 2))
    kd_mct_block::create_dwt_ss_model();
  return result;
}

clock_t kd_codestream::construct_common(kd_codestream *this)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  signed int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  void *v27;
  int v28;
  int v29;
  uint64_t v30;
  _DWORD *v31;
  mct_params *v32;
  mcc_params *v33;
  mco_params *v34;
  atk_params *v35;
  cod_params *v36;
  dfs_params *v37;
  ads_params *v38;
  qcd_params *v39;
  rgn_params *v40;
  poc_params *v41;
  org_params *v42;
  crg_params *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  kdu_block *v47;
  uint64_t v48;
  uint64_t v49;
  clock_t result;
  uint64_t v51;
  _DWORD *v52;
  unsigned int v54;
  BOOL v55;
  int v56;
  int *v58;
  _DWORD *v59;
  int *v60;
  int *v61;
  _DWORD *v62;
  unsigned int *v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;

  *(_WORD *)((char *)this + 281) = 257;
  *((_BYTE *)this + 420) = 0;
  *((_QWORD *)this + 36) = 0x3FF0000000000000;
  (*(void (**)(_QWORD, BOOL))(**((_QWORD **)this + 3) + 72))(*((_QWORD *)this + 3), *((_QWORD *)this + 2) == 0);
  if (!kdu_params::get(*((kdu_params **)this + 3), "Sprofile", 0, 0, (int *)this + 40, 1, 1, 1)
    || (v63 = (unsigned int *)((char *)this + 168),
        !kdu_params::get(*((kdu_params **)this + 3), "Scomponents", 0, 0, (int *)this + 42, 1, 1, 1))
    || !kdu_params::get(*((kdu_params **)this + 3), "Ssize", 0, 0, (int *)this + 49, 1, 1, 1)
    || !kdu_params::get(*((kdu_params **)this + 3), "Ssize", 0, 1, (int *)this + 50, 1, 1, 1)
    || !kdu_params::get(*((kdu_params **)this + 3), "Sorigin", 0, 0, (int *)this + 47, 1, 1, 1)
    || !kdu_params::get(*((kdu_params **)this + 3), "Sorigin", 0, 1, (int *)this + 48, 1, 1, 1)
    || !kdu_params::get(*((kdu_params **)this + 3), "Stiles", 0, 0, (int *)this + 53, 1, 1, 1)
    || (v61 = (int *)((char *)this + 216),
        !kdu_params::get(*((kdu_params **)this + 3), "Stiles", 0, 1, (int *)this + 54, 1, 1, 1))
    || (v58 = (int *)((char *)this + 204),
        !kdu_params::get(*((kdu_params **)this + 3), "Stile_origin", 0, 0, (int *)this + 51, 1, 1, 1))
    || (v60 = (int *)((char *)this + 208),
        (kdu_params::get(*((kdu_params **)this + 3), "Stile_origin", 0, 1, (int *)this + 52, 1, 1, 1) & 1) == 0))
  {
    kd_codestream::construct_common();
  }
  if (*((_DWORD *)this + 40))
    v2 = -1;
  else
    v2 = 0;
  *((_DWORD *)this + 114) = v2;
  v3 = *((_DWORD *)this + 47);
  v4 = *((_DWORD *)this + 48);
  v5 = *((_DWORD *)this + 50) - v4;
  v6 = *((_DWORD *)this + 49) - v3;
  *((_DWORD *)this + 49) = v6;
  *((_DWORD *)this + 50) = v5;
  if (v6 < 1 || v5 < 1 || *v60 > v4 || *v58 > v3 || *v61 + *v60 <= v4 || *((_DWORD *)this + 53) + *v58 <= v3)
  {
    v66 = 0;
    v64 = 0u;
    v65 = 0u;
    kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Illegal canvas coordinates: the first tile is required to have a non-empty intersection with the image on the high resolution grid.");
    kdu_error::~kdu_error((kdu_error *)&v64);
  }
  v59 = (_DWORD *)((char *)this + 212);
  v62 = (_DWORD *)((char *)this + 188);
  v7 = (int)*v63;
  is_mul_ok(v7, 0x68uLL);
  v8 = operator new[]();
  if ((_DWORD)v7)
  {
    v9 = 104 * (int)v7;
    v10 = (_QWORD *)v8;
    do
    {
      *v10 = 0;
      v10 += 13;
      v9 -= 104;
    }
    while (v9);
  }
  *((_QWORD *)this + 39) = v8;
  if (*((int *)this + 42) >= 1)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *((_QWORD *)this + 39);
      v14 = v13 + 104 * v12;
      if ((kdu_params::get(*((kdu_params **)this + 3), "Sprecision", v12, 0, (int *)(v14 + 16), 1, 1, 1) & 1) == 0)
      {
        v66 = 0;
        v64 = 0u;
        v65 = 0u;
        kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "No information available concerning component sample bit-depths (i.e., sample precision).");
        kdu_error::~kdu_error((kdu_error *)&v64);
      }
      if ((kdu_params::get(*((kdu_params **)this + 3), "Ssigned", v12, 0, (BOOL *)(v13 + 104 * v12 + 20), 1, 1, 1) & 1) == 0)
      {
        v66 = 0;
        v64 = 0u;
        v65 = 0u;
        kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "No information available regarding whether components are signed or unsigned.");
        kdu_error::~kdu_error((kdu_error *)&v64);
      }
      if (!kdu_params::get(*((kdu_params **)this + 3), "Ssampling", v12, 0, (int *)(v13 + 104 * v12), 1, 1, 1)|| (kdu_params::get(*((kdu_params **)this + 3), "Ssampling", v12, 1, (int *)(v14 + 4), 1, 1, 1) & 1) == 0)
      {
        v66 = 0;
        v64 = 0u;
        v65 = 0u;
        kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
        (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "No information available concerning component sub-sampling factors.");
        kdu_error::~kdu_error((kdu_error *)&v64);
      }
      v15 = 0;
      v16 = v13 + 104 * v12;
      *(_DWORD *)(v16 + 88) = v12;
      *(_QWORD *)(v16 + 96) = v14;
      *(_QWORD *)(v16 + 8) = 0;
      do
      {
        v17 = v13 + v11 + v15;
        *(_BYTE *)(v17 + 54) = v15;
        *(_BYTE *)(v17 + 21) = v15++;
      }
      while (v15 != 33);
      ++v12;
      v11 += 104;
    }
    while (v12 < (int)*v63);
  }
  *((_QWORD *)this + 42) = 0;
  *((_QWORD *)this + 43) = 0;
  v18 = *((_DWORD *)this + 47) + *((_DWORD *)this + 49) - *((_DWORD *)this + 51);
  v19 = *((_DWORD *)this + 53);
  if (v19 <= 1)
    v19 = 1;
  if (v18 <= 0)
    v20 = -(int)((*((_DWORD *)this + 51) - (*((_DWORD *)this + 47) + *((_DWORD *)this + 49))) / v19);
  else
    v20 = (v18 - 1) / v19 + 1;
  v21 = *((_DWORD *)this + 48) + *((_DWORD *)this + 50) - *((_DWORD *)this + 52);
  v22 = *((_DWORD *)this + 54);
  if (v22 <= 1)
    v22 = 1;
  v23 = (v21 - 1) / v22;
  v24 = -(int)((*((_DWORD *)this + 52) - (*((_DWORD *)this + 48) + *((_DWORD *)this + 50))) / v22);
  if (v21 > 0)
    v25 = v23 + 1;
  else
    v25 = v24;
  *((_DWORD *)this + 55) = v20;
  *((_DWORD *)this + 56) = v25;
  v26 = v25 * v20;
  if (!v20 || v25 > 0x7FFFFFFF / v20 || v26 < 1 || v26 >= 0x10000)
  {
    v66 = 0;
    v64 = 0u;
    v65 = 0u;
    kdu_error::kdu_error((kdu_error *)&v64, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Maximum number of allowable tiles is 65535 for any JPEG2000 code-stream (corrupt JP2 data?)");
    kdu_error::~kdu_error((kdu_error *)&v64);
  }
  *(_QWORD *)((char *)this + 228) = 0;
  *(_QWORD *)((char *)this + 236) = *(_QWORD *)((char *)this + 220);
  is_mul_ok(v26, 0x18uLL);
  v27 = (void *)operator new[]();
  *((_QWORD *)this + 41) = v27;
  bzero(v27, 24 * v26);
  v28 = *((_DWORD *)this + 40);
  if (!v28)
  {
    if (*v61 == 128)
    {
      if (*v59 != 128 && v26 > 1)
        goto LABEL_64;
    }
    else if (v26 >= 2)
    {
LABEL_64:
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v64, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Profile violation detected (code-stream is technically illegal).  Profile-0 code-streams must either be untiled or else the tile dimensions must be exactly 128x128.  Try setting \"Sprofile\" to 1 or 2 or avoid using tiles.");
      goto LABEL_73;
    }
    if (*v60 || *v58 || *((_DWORD *)this + 48) || *v62)
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v64, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Profile violation detected (code-stream is technically illegal).  Profile-0 code-streams must have image and tiling origins (anchor points) set to zero.  Try setting \"Sprofile\" to 1 or 2.");
    }
    else
    {
      v51 = *v63;
      if ((int)v51 < 1)
        goto LABEL_74;
      v52 = (_DWORD *)(*((_QWORD *)this + 39) + 4);
      while (*v52 <= 4u && ((1 << *v52) & 0x16) != 0)
      {
        v54 = *(v52 - 1);
        v55 = v54 > 4;
        v56 = (1 << v54) & 0x16;
        if (v55 || v56 == 0)
          break;
        v52 += 26;
        if (!--v51)
          goto LABEL_74;
      }
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v64, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Profile violation detected (code-stream is technically illegal).  Component sub-sampling factors for Profile-0 code-streams are restricted to the values 1, 2 and 4.  Try setting \"Sprofile\" to 1 or 2.");
    }
LABEL_73:
    *((_DWORD *)this + 40) = 2;
    kdu_warning::~kdu_warning((kdu_warning *)&v64);
    goto LABEL_74;
  }
  if (v28 == 1 && v26 >= 2)
  {
    v29 = *v61;
    if (*v61 == *v59)
    {
      v30 = *v63;
      if ((int)v30 < 1)
        goto LABEL_74;
      v31 = (_DWORD *)(*((_QWORD *)this + 39) + 4);
      while (v29 <= *v31 << 10 && v29 <= *(v31 - 1) << 10)
      {
        v31 += 26;
        if (!--v30)
          goto LABEL_74;
      }
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v64, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Profile violation detected (code-stream is technically illegal).  If a Profile-1 code-stream is tiled (has multiple tiles), the width and height of its tiles, projected onto any given image component, may not exceed 1024.  You might like to set \"Sprofile\" to 2 or avoid using tiles.");
    }
    else
    {
      v66 = 0;
      v64 = 0u;
      v65 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v64, "Kakadu Core Warning:\n");
      (*(void (**)(__int128 *, const char *))(v64 + 16))(&v64, "Profile violation detected (code-stream is technically illegal).  Profile-1 code-streams must either be untiled or else the horizontal and vertical tile dimensions must be identical (square tiles on the hi-res canvas).  You might like to set \"Sprofile\" to 2 or avoid using tiles.");
    }
    goto LABEL_73;
  }
LABEL_74:
  v32 = (mct_params *)operator new();
  mct_params::mct_params(v32);
  kdu_params::link(v32, *((kdu_params **)this + 3), -1, -1, v26, 0);
  v33 = (mcc_params *)operator new();
  mcc_params::mcc_params(v33);
  kdu_params::link(v33, *((kdu_params **)this + 3), -1, -1, v26, 0);
  v34 = (mco_params *)operator new();
  mco_params::mco_params(v34);
  kdu_params::link(v34, *((kdu_params **)this + 3), -1, -1, v26, 0);
  v35 = (atk_params *)operator new();
  atk_params::atk_params(v35);
  kdu_params::link(v35, *((kdu_params **)this + 3), -1, -1, v26, 0);
  v36 = (cod_params *)operator new();
  cod_params::cod_params(v36);
  kdu_params::link(v36, *((kdu_params **)this + 3), -1, -1, v26, *((_DWORD *)this + 42));
  v37 = (dfs_params *)operator new();
  dfs_params::dfs_params(v37);
  kdu_params::link(v37, *((kdu_params **)this + 3), -1, -1, 0, 0);
  v38 = (ads_params *)operator new();
  ads_params::ads_params(v38);
  kdu_params::link(v38, *((kdu_params **)this + 3), -1, -1, v26, 0);
  v39 = (qcd_params *)operator new();
  qcd_params::qcd_params(v39);
  kdu_params::link(v39, *((kdu_params **)this + 3), -1, -1, v26, *((_DWORD *)this + 42));
  v40 = (rgn_params *)operator new();
  rgn_params::rgn_params(v40);
  kdu_params::link(v40, *((kdu_params **)this + 3), -1, -1, v26, *((_DWORD *)this + 42));
  v41 = (poc_params *)operator new();
  poc_params::poc_params(v41);
  kdu_params::link(v41, *((kdu_params **)this + 3), -1, -1, v26, 0);
  v42 = (org_params *)operator new();
  org_params::org_params(v42);
  kdu_params::link(v42, *((kdu_params **)this + 3), -1, -1, v26, 0);
  v43 = (crg_params *)operator new();
  crg_params::crg_params(v43);
  kdu_params::link(v43, *((kdu_params **)this + 3), -1, -1, 0, 0);
  v44 = operator new();
  *(_OWORD *)v44 = 0u;
  *(_OWORD *)(v44 + 16) = 0u;
  *(_OWORD *)(v44 + 32) = 0u;
  *(_OWORD *)(v44 + 48) = 0u;
  *(_DWORD *)(v44 + 64) = 0;
  *((_QWORD *)this + 6) = v44;
  v45 = operator new();
  v46 = *((_QWORD *)this + 6);
  *(_OWORD *)v45 = 0u;
  *(_OWORD *)(v45 + 16) = 0u;
  *(_QWORD *)(v45 + 32) = v46;
  *((_QWORD *)this + 10) = v45;
  ++*(_DWORD *)(v46 + 64);
  v47 = (kdu_block *)operator new();
  kdu_block::kdu_block(v47);
  *((_QWORD *)this + 7) = v47;
  v48 = *((_QWORD *)this + 1);
  if (v48)
  {
    if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v48 + 552) + 24))(*(_QWORD *)(v48 + 552)) & 2) != 0)
    {
      v49 = operator new();
      *(_QWORD *)(v49 + 8) = 0;
      *(_QWORD *)(v49 + 16) = 0;
      *(_QWORD *)v49 = 0;
      *(_BYTE *)(v49 + 24) = 0;
      *((_QWORD *)this + 9) = v49;
    }
    kd_codestream::read_main_header(this);
  }
  if (!*((_QWORD *)this + 40))
    kd_codestream::construct_output_comp_info(this);
  *(_OWORD *)((char *)this + 264) = *(_OWORD *)v62;
  *((_DWORD *)this + 43) = *((_DWORD *)this + 42);
  *(_OWORD *)((char *)this + 244) = xmmword_18820CCE0;
  *((_BYTE *)this + 419) = 0;
  *((_QWORD *)this + 8) = 0;
  result = clock();
  *((_QWORD *)this + 59) = result;
  *((_BYTE *)this + 280) = 0;
  return result;
}

void sub_187F14FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

void kd_codestream::read_main_header(kd_codestream *this)
{
  char v2;
  __int16 *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t *v7;
  int v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  kd_tpart_pointer_server *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  if (*((_QWORD *)this + 1))
  {
    v2 = 0;
    v20 = (uint64_t *)((char *)this + 88);
    v3 = (__int16 *)*((_QWORD *)this + 4);
    while ((kd_marker::read((kd_marker *)v3, 0, 0) & 1) != 0)
    {
      v4 = *((_QWORD *)this + 4);
      v5 = *(unsigned __int16 *)(v4 + 16);
      switch(v5)
      {
        case 65365:
          v7 = (uint64_t *)*((_QWORD *)this + 9);
          if (v7)
            kd_tpart_pointer_server::add_tlm_marker(v7, v4);
          v2 = 1;
          break;
        case 65380:
          v8 = *(_DWORD *)(v4 + 20);
          if (v8 >= 3)
          {
            v9 = *(_BYTE **)(v4 + 32);
            if (!*v9 && v9[1] == 1)
            {
              v10 = *((_QWORD *)this + 12);
              v11 = operator new();
              *(_BYTE *)v11 = 0;
              *(_DWORD *)(v11 + 4) = 0;
              *(_DWORD *)(v11 + 8) = 0;
              v12 = v20;
              *(_QWORD *)(v11 + 16) = 0;
              *(_QWORD *)(v11 + 24) = 0;
              if (v10)
                v12 = (uint64_t *)(*((_QWORD *)this + 12) + 24);
              *v12 = v11;
              *((_QWORD *)this + 12) = v11;
              kd_codestream_comment::set_text((_BYTE *)v11, v8 - 2, v9 + 2);
            }
          }
          break;
        case 65376:
          if (*((_BYTE *)this + 418))
          {
            v23 = 0;
            v21 = 0u;
            v22 = 0u;
            kdu_error::kdu_error((kdu_error *)&v21, "Kakadu Core Error:\n");
            (*(void (**)(__int128 *, const char *))(v21 + 16))(&v21, "You cannot use PPM or PPT marker segments (packed packet headers) with cached compressed data sources.");
            kdu_error::~kdu_error((kdu_error *)&v21);
          }
          if (!*((_DWORD *)this + 40))
          {
            v23 = 0;
            v21 = 0u;
            v22 = 0u;
            kdu_warning::kdu_warning((kdu_warning *)&v21, "Kakadu Core Warning:\n");
            (*(void (**)(__int128 *, const char *))(v21 + 16))(&v21, "Profile violation detected (code-stream is technically illegal).  PPM marker segments may not appear within a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.");
            *((_DWORD *)this + 40) = 2;
            kdu_warning::~kdu_warning((kdu_warning *)&v21);
          }
          v6 = *((_QWORD *)this + 5);
          if (!v6)
          {
            v6 = operator new();
            *(_QWORD *)(v6 + 8) = 0;
            *((_QWORD *)this + 5) = v6;
          }
          kd_pp_markers::add_marker(v6, *((_QWORD *)this + 4));
          break;
        default:
          kdu_params::translate_marker_segment(*((kdu_params **)this + 3), *(unsigned __int16 *)(v4 + 16), *(unsigned int *)(v4 + 20), *(unsigned __int8 **)(v4 + 32), -1, 0);
          break;
      }
      v3 = (__int16 *)*((_QWORD *)this + 4);
      if (v3[8] == -112)
        goto LABEL_27;
    }
    if (!*(_BYTE *)(*((_QWORD *)this + 1) + 544))
    {
      v23 = 0;
      v21 = 0u;
      v22 = 0u;
      kdu_error::kdu_error((kdu_error *)&v21, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v21 + 16))(&v21, "Main code-stream header appears corrupt!");
      kdu_error::~kdu_error((kdu_error *)&v21);
    }
LABEL_27:
    kdu_params::finalize_all(*((kdu_params **)this + 3), -1, 1);
    v13 = (kd_tpart_pointer_server *)*((_QWORD *)this + 9);
    if (v13)
    {
      if (*((_QWORD *)this + 5))
      {
        kd_tpart_pointer_server::~kd_tpart_pointer_server(v13);
        MEMORY[0x18D761C30]();
        *((_QWORD *)this + 9) = 0;
        if ((v2 & 1) != 0)
        {
          v23 = 0;
          v21 = 0u;
          v22 = 0u;
          kdu_warning::kdu_warning((kdu_warning *)&v21, "Kakadu Core Warning:\n");
          (*(void (**)(__int128 *, const char *))(v21 + 16))(&v21, "Dynamic indexing of tile-parts, whether by TLM (tile-part length) marker segments or otherwise, cannot be used by the current implementation when PPM (packed packet header) marker segments are also used.");
          kdu_warning::~kdu_warning((kdu_warning *)&v21);
        }
      }
      else
      {
        v14 = *((_DWORD *)this + 56);
        if (v14 != *((_DWORD *)this + 60) || (v15 = *((_DWORD *)this + 55), v15 != *((_DWORD *)this + 59)))
          kd_codestream::read_main_header();
        v16 = *((_QWORD *)this + 1);
        if (*(_BYTE *)(v16 + 608))
        {
          v17 = -12;
        }
        else
        {
          v18 = ~(v16 + 14) + *(_QWORD *)(v16 + 528) + *(_QWORD *)(v16 + 560);
          v19 = *(_QWORD *)(v16 + 576);
          if (v18 > v19)
          {
            *(_QWORD *)(v16 + 576) = v18;
            v19 = v18;
          }
          v17 = v19 - 11;
        }
        kd_tpart_pointer_server::translate_markers((uint64_t *)v13, v17, v15 * v14, *((_QWORD *)this + 41));
      }
    }
    kd_codestream::finalize_construction(this);
  }
}

void sub_187F15428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

uint64_t kd_codestream::construct_output_comp_info(kd_codestream *this)
{
  int *v2;
  int v3;
  int v4;
  uint64_t result;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int32x2_t *v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  int v18;

  if (*((_QWORD *)this + 40))
    kd_codestream::construct_output_comp_info();
  v18 = 0;
  kdu_params::get(*((kdu_params **)this + 3), "Sextensions", 0, 0, &v18, 1, 1, 1);
  *((_BYTE *)this + 164) = BYTE1(v18) & 1;
  v2 = (int *)((char *)this + 176);
  v3 = 0;
  if (kdu_params::get(*((kdu_params **)this + 3), "Mcomponents", 0, 0, (int *)this + 44, 1, 1, 1))
    v3 = *v2 > 0;
  if (*((unsigned __int8 *)this + 164) != v3)
  {
    v17 = 0;
    v15 = 0u;
    v16 = 0u;
    kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v15);
  }
  if ((v3 & 1) != 0)
  {
    v4 = *v2;
  }
  else
  {
    v4 = *((_DWORD *)this + 42);
    *((_DWORD *)this + 44) = v4;
  }
  if (v4 >= 17)
  {
    v17 = 0;
    v15 = 0u;
    v16 = 0u;
    kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "num_output_components too big.");
    kdu_error::~kdu_error((kdu_error *)&v15);
  }
  *((_DWORD *)this + 45) = v4;
  is_mul_ok(v4, 0x30uLL);
  result = operator new[]();
  if (v4)
  {
    v6 = result;
    do
    {
      *(_DWORD *)v6 = 0;
      *(_BYTE *)(v6 + 4) = 0;
      *(_QWORD *)(v6 + 8) = 0;
      *(_DWORD *)(v6 + 16) = -1;
      *(_DWORD *)(v6 + 44) = 0;
      *(_QWORD *)(v6 + 28) = 0;
      *(_QWORD *)(v6 + 20) = 0;
      *(_QWORD *)(v6 + 33) = 0;
      v6 += 48;
    }
    while (v6 != result + 48 * v4);
  }
  *((_QWORD *)this + 40) = result;
  v7 = *((_DWORD *)this + 44);
  if (v7 >= 1)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = *((_QWORD *)this + 40);
      v12 = v11 + v8;
      if ((v3 & 1) != 0)
      {
        if (!kdu_params::get(*((kdu_params **)this + 3), "Mprecision", v10, 0, (int *)v12, 1, 1, 1)
          || (result = kdu_params::get(*((kdu_params **)this + 3), "Msigned", v10, 0, (BOOL *)(v11 + v8 + 4), 1, 1, 1),
              !(_DWORD)result))
        {
          kd_codestream::construct_output_comp_info();
        }
        v13 = *((_QWORD *)this + 39);
        v7 = *((_DWORD *)this + 44);
      }
      else
      {
        v13 = *((_QWORD *)this + 39);
        *(_DWORD *)v12 = *(_DWORD *)(v13 + v9 + 16);
        *(_BYTE *)(v12 + 4) = *(_BYTE *)(v13 + v9 + 20);
      }
      v14 = (int32x2_t *)(v11 + v8);
      v14[1] = (int32x2_t)(v13 + v9);
      v14[2] = vdup_n_s32(v10++);
      v14[3] = 0;
      v14[4] = 0;
      v9 += 104;
      v8 += 48;
    }
    while (v10 < v7);
  }
  *((_DWORD *)this + 46) = 0;
  return result;
}

void sub_187F1572C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F15738()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kd_codestream::finalize_construction(kd_codestream *this)
{
  uint64_t v2;
  kdu_params *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  kdu_params *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  kdu_params *v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  kd_global_rescomp *v17;
  unint64_t v18;
  _QWORD *v19;
  _OWORD *v20;
  uint64_t v21;
  int i;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  _QWORD *v32;
  uint64_t v33;
  int v34;

  if (!*((_QWORD *)this + 40))
    kd_codestream::construct_output_comp_info(this);
  if (!*((_BYTE *)this + 420))
  {
    *((_BYTE *)this + 420) = 1;
    v2 = kdu_params::access_cluster(*((kdu_params **)this + 3), "CRG");
    if (*((int *)this + 42) >= 1)
    {
      v3 = (kdu_params *)v2;
      v4 = 0;
      v5 = 8;
      do
      {
        v6 = *((_QWORD *)this + 39);
        if (!v3
          || !kdu_params::get(v3, "CRGoffset", v4, 0, (float *)(v6 + v5 + 4), 1, 1, 1)
          || (kdu_params::get(v3, "CRGoffset", v4, 1, (float *)(v6 + v5), 1, 1, 1) & 1) == 0)
        {
          *(_QWORD *)(v6 + v5) = 0;
        }
        ++v4;
        v5 += 104;
      }
      while (v4 < *((int *)this + 42));
    }
    v7 = kdu_params::access_cluster(*((kdu_params **)this + 3), "COD");
    LODWORD(v8) = *((_DWORD *)this + 42);
    if ((int)v8 >= 1)
    {
      v9 = (kdu_params *)v7;
      v10 = 0;
      v11 = 55;
      do
      {
        v12 = *((_QWORD *)this + 39);
        v13 = (kdu_params *)kdu_params::access_relation(v9, -1, v10, 0, 1);
        v14 = 0;
        v15 = v12 + v11;
        do
        {
          v34 = 3;
          kdu_params::get(v13, "Cdecomp", v14, 0, &v34, 1, 1, 1);
          v16 = (_BYTE *)(v15 + v14);
          *(v16 - 33) = (v34 & 1) + *(_BYTE *)(v15 + v14 - 34);
          *v16 = ((v34 & 2) != 0) + *(_BYTE *)(v15 + v14++ - 1);
        }
        while (v14 != 32);
        ++v10;
        v8 = *((int *)this + 42);
        v11 += 104;
      }
      while (v10 < v8);
    }
    if (*((_QWORD *)this + 2))
    {
      v17 = (kd_global_rescomp *)*((_QWORD *)this + 44);
      if (!v17)
      {
        v18 = 33 * (int)v8;
        is_mul_ok(v18, 0x58uLL);
        v19 = (_QWORD *)operator new[]();
        *v19 = 88;
        v19[1] = v18;
        v17 = (kd_global_rescomp *)(v19 + 2);
        if ((_DWORD)v8)
        {
          v20 = v19 + 11;
          v21 = 88 * (int)v18;
          __asm { FMOV            V1.2D, #-1.0 }
          do
          {
            *(_OWORD *)((char *)v20 - 72) = 0uLL;
            *(_OWORD *)((char *)v20 - 56) = 0uLL;
            *(_OWORD *)((char *)v20 - 40) = 0uLL;
            *v20 = _Q1;
            *((_QWORD *)v20 - 2) = 0;
            *((_QWORD *)v20 - 1) = 0;
            *((_QWORD *)v20 - 3) = 0;
            v20 = (_OWORD *)((char *)v20 + 88);
            v21 -= 88;
          }
          while (v21);
        }
        *((_QWORD *)this + 44) = v17;
        LODWORD(v8) = *((_DWORD *)this + 42);
      }
      for (i = 0; i != 33; ++i)
      {
        if ((int)v8 >= 1)
        {
          v28 = 0;
          do
          {
            kd_global_rescomp::initialize(v17, this, i, v28++);
            v17 = (kd_global_rescomp *)((char *)v17 + 88);
            LODWORD(v8) = *((_DWORD *)this + 42);
          }
          while (v28 < (int)v8);
        }
      }
    }
    if (*((_BYTE *)this + 164))
    {
      kd_mct_stage::create_stages((int **)this + 18, (int **)this + 19, *((kdu_params **)this + 3), -1, v8, *((_QWORD *)this + 39), *((_DWORD *)this + 44), *((_QWORD *)this + 40));
      v29 = *((_QWORD *)this + 19);
      if (v29)
      {
        v30 = *((unsigned int *)this + 44);
        if ((int)v30 >= 1)
        {
          v31 = (uint64_t *)(*(_QWORD *)(v29 + 24) + 8);
          v32 = (_QWORD *)(*((_QWORD *)this + 40) + 8);
          do
          {
            v33 = *v31;
            v31 += 6;
            *v32 = v33;
            v32 += 6;
            --v30;
          }
          while (v30);
        }
      }
    }
  }
}

void kd_codestream::restrict_to_fragment(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  _DWORD *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  __int128 v26;
  void *v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;

  *(_QWORD *)&v31 = a2;
  *((_QWORD *)&v31 + 1) = a3;
  if (!*(_QWORD *)(a1 + 16))
    kd_codestream::restrict_to_fragment();
  v8 = (_DWORD *)(a1 + 188);
  kdu_dims::operator&=(&v31, (int *)(a1 + 188));
  v10 = DWORD2(v31);
  v9 = HIDWORD(v31);
  *(double *)(a1 + 288) = (double)(SDWORD2(v31) * (uint64_t)SHIDWORD(v31))
                        / (double)(*(int *)(a1 + 196) * (uint64_t)*(int *)(a1 + 200));
  *(_DWORD *)(a1 + 296) = a4;
  *(_QWORD *)(a1 + 304) = a5;
  v11 = *(_DWORD *)(a1 + 212);
  v12 = *(_DWORD *)(a1 + 216);
  v13 = DWORD1(v31) - *(_DWORD *)(a1 + 208);
  v14 = v31 - *(_DWORD *)(a1 + 204);
  v15 = (v13 / v12);
  v16 = (v14 / v11);
  v17 = (v9 + v13) / v12;
  v18 = (v14 + v10) / v11;
  if (v13 != (_DWORD)v15 * v12 || v14 != (_DWORD)v16 * v11 || v17 * v12 != v9 + v13 || v18 * v11 != v14 + v10)
  {
    v30 = 0;
    v28 = 0u;
    v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  v19 = __OFSUB__(v17, (_DWORD)v15);
  v20 = (v17 - v15);
  if (((int)v20 < 0) ^ v19 | ((_DWORD)v20 == 0) || v18 <= (int)v16)
  {
    v30 = 0;
    v28 = 0u;
    v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  v21 = (v18 - v16);
  v22 = v21 * v20;
  if ((int)v21 * (int)v20 <= 0)
    kd_codestream::restrict_to_fragment();
  v23 = *(_DWORD *)(a1 + 220) * *(_DWORD *)(a1 + 224);
  v24 = v22 + a4;
  if (v23 < (int)(v22 + a4))
  {
    v30 = 0;
    v28 = 0u;
    v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  *(_BYTE *)(a1 + 281) = a4 == 0;
  *(_BYTE *)(a1 + 282) = v23 == v24;
  if ((_DWORD)v20 == *(_DWORD *)(a1 + 240) && (_DWORD)v21 == *(_DWORD *)(a1 + 236))
  {
    if (__PAIR64__(v15, v16) != *(_QWORD *)(a1 + 228)
      || __PAIR64__(*(_DWORD *)(a1 + 192), *v8) != (_QWORD)v31
      || *(_DWORD *)(a1 + 200) != HIDWORD(v31)
      || a4
      || v23 != v24
      || *(_DWORD *)(a1 + 196) != DWORD2(v31))
    {
      kd_codestream::restrict_to_fragment();
    }
  }
  else
  {
    v25 = *(_QWORD *)(a1 + 328);
    if (v25)
      MEMORY[0x18D761C18](v25, 0x20C80960023A9);
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 228) = v16 | (v15 << 32);
    *(_QWORD *)(a1 + 236) = (v20 << 32) | v21;
    v26 = v31;
    *(_OWORD *)v8 = v31;
    *(_OWORD *)(a1 + 264) = v26;
    v27 = (void *)operator new[]();
    *(_QWORD *)(a1 + 328) = v27;
    bzero(v27, 24 * v22);
  }
}

void sub_187F15D54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F15D60()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kd_codestream::restart(kd_codestream *this)
{
  kd_pp_markers *v2;
  kd_tpart_pointer_server *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  int v12;
  int v13;
  int i;
  kd_tile *v15;
  kd_tile *v16;
  uint64_t v17;
  uint64_t v18;
  _OWORD v19[2];
  uint64_t v20;

  v2 = (kd_pp_markers *)*((_QWORD *)this + 5);
  if (v2)
  {
    kd_pp_markers::~kd_pp_markers(v2);
    MEMORY[0x18D761C30]();
  }
  *((_QWORD *)this + 5) = 0;
  v3 = (kd_tpart_pointer_server *)*((_QWORD *)this + 9);
  if (v3)
  {
    kd_tpart_pointer_server::~kd_tpart_pointer_server(v3);
    MEMORY[0x18D761C30]();
  }
  *((_QWORD *)this + 9) = 0;
  v4 = *((_QWORD *)this + 8);
  if (v4)
    MEMORY[0x18D761C30](v4, 0x1000C404E6BD753);
  *((_QWORD *)this + 8) = 0;
  *((_DWORD *)this + 29) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 16) = 0;
  v5 = *((_QWORD *)this + 17);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C80CE7E837CLL);
  *((_BYTE *)this + 420) = 0;
  *((_QWORD *)this + 49) = 0;
  *((_QWORD *)this + 50) = 0;
  v6 = *((_QWORD *)this + 46);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x1000C8000313F17);
  v7 = *((_QWORD *)this + 47);
  if (v7)
    MEMORY[0x18D761C18](v7, 0x1000C8000313F17);
  v8 = *((_QWORD *)this + 48);
  if (v8)
    MEMORY[0x18D761C18](v8, 0x1000C80BDFB0063);
  *((_DWORD *)this + 97) = 0;
  *(_QWORD *)((char *)this + 372) = 0;
  *(_QWORD *)((char *)this + 364) = 0;
  *(_QWORD *)((char *)this + 380) = 0;
  v9 = *((_QWORD *)this + 40);
  if (v9)
    MEMORY[0x18D761C18](v9, 0x1020C806B39A6A2);
  *((_QWORD *)this + 40) = 0;
  *((_QWORD *)this + 22) = 0;
  v10 = (_QWORD *)*((_QWORD *)this + 41);
  if (!v10)
    kd_codestream::restart();
  v11 = *((_DWORD *)this + 59);
  if (v11 >= 1)
  {
    v12 = 0;
    v13 = *((_DWORD *)this + 60);
    do
    {
      if (v13 >= 1)
      {
        for (i = 0; i < v13; ++i)
        {
          *v10 = 0;
          v10[1] = 0;
          v15 = (kd_tile *)v10[2];
          if (v15)
          {
            if (v15 == (kd_tile *)-1)
              kd_codestream::restart();
            if (*((_BYTE *)v15 + 289))
            {
              v20 = 0;
              memset(v19, 0, sizeof(v19));
              kdu_error::kdu_error((kdu_error *)v19, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)v19);
            }
            kd_tile::restart(v15);
            v13 = *((_DWORD *)this + 60);
          }
          v10 += 3;
        }
        v11 = *((_DWORD *)this + 59);
      }
      ++v12;
    }
    while (v12 < v11);
  }
  while (1)
  {
    v16 = (kd_tile *)*((_QWORD *)this + 64);
    if (!v16)
      break;
    *((_QWORD *)this + 64) = *((_QWORD *)v16 + 9);
    if (*((_QWORD *)v16 + 3))
      kd_codestream::restart();
    kd_tile::~kd_tile(v16);
    MEMORY[0x18D761C30]();
  }
  while (1)
  {
    v18 = *((_QWORD *)this + 11);
    *((_QWORD *)this + 12) = v18;
    if (!v18)
      break;
    *((_QWORD *)this + 11) = *(_QWORD *)(v18 + 24);
    v17 = *(_QWORD *)(v18 + 16);
    if (v17)
      MEMORY[0x18D761C18](v17, 0x1000C8077774924);
    MEMORY[0x18D761C30](v18, 0x1030C40D4B01E93);
  }
  *(_WORD *)((char *)this + 421) = 0;
  *((_QWORD *)this + 53) = 0;
  kdu_params::clear_marks(*((_QWORD *)this + 3));
  if (*((_QWORD *)this + 1))
    kd_codestream::read_main_header(this);
  if (!*((_QWORD *)this + 40))
    kd_codestream::construct_output_comp_info(this);
  *((_BYTE *)this + 419) = 0;
  *((_DWORD *)this + 65) = 0;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 56) = 0;
  *((_QWORD *)this + 57) = 0;
  *((_QWORD *)this + 55) = 0;
}

void sub_187F16070(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1607C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kd_codestream::set_reserved_layer_info_bytes(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  BOOL v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  _QWORD *v11;

  v3 = this;
  v5 = (_QWORD *)(this + 88);
  v4 = *(_QWORD *)(this + 88);
  if (v4)
  {
    v6 = *(_QWORD *)(v4 + 16);
    v7 = v6 == 0;
    if (v6)
      v8 = *(const char **)(v4 + 16);
    else
      v8 = "";
    this = strncmp(v8, "Kdu-Layer-Info: ", 0x10uLL);
    if ((_DWORD)this)
    {
      while (1)
      {
        v9 = v4;
        v4 = *(_QWORD *)(v4 + 24);
        if (!v4)
          break;
        v6 = *(_QWORD *)(v4 + 16);
        v7 = v6 == 0;
        if (v6)
          v10 = *(const char **)(v4 + 16);
        else
          v10 = "";
        this = strncmp(v10, "Kdu-Layer-Info: ", 0x10uLL);
        if (!(_DWORD)this)
          goto LABEL_13;
      }
    }
    else
    {
      v9 = 0;
LABEL_13:
      v11 = (_QWORD *)(v9 + 24);
      if (!v9)
        v11 = v5;
      *v11 = *(_QWORD *)(v4 + 24);
      if (!v7)
        MEMORY[0x18D761C18](v6, 0x1000C8077774924);
      this = MEMORY[0x18D761C30](v4, 0x1030C40D4B01E93);
      if (v4 == *(_QWORD *)(v3 + 96))
        *(_QWORD *)(v3 + 96) = v9;
    }
  }
  *(_DWORD *)(v3 + 432) = 17 * a2 + 74;
  return this;
}

uint64_t kd_codestream::gen_layer_info_comment(uint64_t this, int a2, uint64_t *a3, unsigned __int16 *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  double v12;
  uint64_t v13;
  double v14;
  int v15;
  int v16;
  uint64_t v17;
  char __s[8];
  uint64_t v19;
  __int16 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(this + 432))
  {
    v7 = this;
    v8 = operator new();
    v9 = v8;
    *(_BYTE *)v8 = 0;
    *(_DWORD *)(v8 + 4) = 0;
    *(_DWORD *)(v8 + 8) = 0;
    *(_QWORD *)(v8 + 16) = 0;
    *(_QWORD *)(v8 + 24) = 0;
    v10 = (uint64_t *)(v7 + 96);
    if (*(_QWORD *)(v7 + 88))
    {
      v11 = (uint64_t *)(*v10 + 24);
    }
    else
    {
      v11 = (uint64_t *)(v7 + 96);
      v10 = (uint64_t *)(v7 + 88);
    }
    *v11 = v8;
    *v10 = v8;
    v17 = v8;
    this = kdu_codestream_comment::put_text((kdu_codestream_comment *)&v17, "Kdu-Layer-Info: log_2{Delta-D(MSE)/[2^16*Delta-L(bytes)]}, L(bytes)\n");
    v12 = *(double *)(v7 + 288);
    *(_QWORD *)__s = 0;
    v19 = 0;
    v20 = 0;
    if (a2 >= 1)
    {
      v13 = a2;
      v14 = 1.0 / v12;
      do
      {
        LOWORD(v12) = *a4;
        sprintf(__s, "%6.1f, %8.1e\n", ((double)*(unint64_t *)&v12 + -65536.0) * 0.00390625, v14 * (double)*a3);
        this = kdu_codestream_comment::put_text((kdu_codestream_comment *)&v17, __s);
        ++a3;
        ++a4;
        --v13;
      }
      while (v13);
    }
    v15 = *(_DWORD *)(v7 + 432);
    *(_BYTE *)v9 = 1;
    if (v15)
    {
      if (v15 <= 6)
        v15 = 6;
      v16 = v15 - 6;
      if (v16 < *(_DWORD *)(v9 + 8))
      {
        *(_DWORD *)(v9 + 8) = v16;
        *(_BYTE *)(*(_QWORD *)(v9 + 16) + v16) = 0;
      }
    }
  }
  return this;
}

uint64_t kd_codestream::freeze_comments(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;

  if (!*(_BYTE *)(this + 421))
  {
    v1 = this;
    v2 = *(_QWORD *)(this + 88);
    if (v2)
    {
      while (1)
      {
        v3 = *(_QWORD *)(v2 + 16) ? *(const char **)(v2 + 16) : "";
        this = strcmp(v3, "Kakadu-v5.2.1");
        if (!(_DWORD)this)
          break;
        v2 = *(_QWORD *)(v2 + 24);
        if (!v2)
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      v4 = operator new();
      *(_BYTE *)v4 = 0;
      *(_DWORD *)(v4 + 4) = 0;
      *(_DWORD *)(v4 + 8) = 0;
      *(_QWORD *)(v4 + 16) = 0;
      *(_QWORD *)(v4 + 24) = 0;
      this = (uint64_t)kd_codestream_comment::set_text((_BYTE *)v4, 13, "Kakadu-v5.2.1");
      v5 = (uint64_t *)(v1 + 96);
      v6 = *(_QWORD *)(v1 + 96);
      v7 = v6 == 0;
      if (v6)
        v5 = (uint64_t *)(v6 + 24);
      v8 = 96;
      if (v7)
        v8 = 88;
      *v5 = v4;
      *(_QWORD *)(v1 + v8) = v4;
    }
    *(_BYTE *)(v1 + 421) = 1;
  }
  return this;
}

void kd_codestream::~kd_codestream(kd_codestream *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  const char *v11;
  const char *v12;
  const char *v13;
  int i;
  kd_tile *v15;
  kd_tile *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  kd_pp_markers *v22;
  kd_precinct_size_class **v23;
  kdu_block *v24;
  uint64_t v25;
  kd_tpart_pointer_server *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  kd_buf_server *v33;
  int v34;
  int v35;
  kd_mct_stage *v36;
  uint64_t v37;

  v2 = *((_QWORD *)this + 39);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1020C8091F5070ALL);
  v3 = *((_QWORD *)this + 40);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1020C806B39A6A2);
  v4 = *((_QWORD *)this + 44);
  if (v4)
  {
    v5 = *(_QWORD *)(v4 - 8);
    if (v5)
    {
      v6 = 88 * v5;
      do
      {
        kd_global_rescomp::close_all((uint64_t *)(v4 - 88 + v6));
        v6 -= 88;
      }
      while (v6);
    }
    MEMORY[0x18D761C18](v4 - 16, 0x1020C8067899110);
  }
  *((_QWORD *)this + 55) = 0;
  v7 = *((_QWORD *)this + 41);
  if (!v7)
    goto LABEL_24;
  v8 = *((_DWORD *)this + 59);
  if (v8 < 1)
    goto LABEL_23;
  v9 = 0;
  v10 = *((_DWORD *)this + 60);
  v11 = "abs_idx == tref->tile->t_idx";
  v12 = "codestream.cpp";
  v13 = "~kd_codestream";
  do
  {
    if (v10 < 1)
      goto LABEL_21;
    for (i = 0; i < v10; ++i)
    {
      v15 = *(kd_tile **)(v7 + 16);
      if ((unint64_t)v15 + 1 >= 2)
      {
        if (i + *((_DWORD *)this + 58) != *((_DWORD *)v15 + 4) || *((_DWORD *)this + 57) + v9 != *((_DWORD *)v15 + 3))
        {
          v27 = 4732;
          goto LABEL_50;
        }
        kd_tile::~kd_tile(v15);
        MEMORY[0x18D761C30]();
        if ((unint64_t)(*(_QWORD *)(v7 + 16) + 1) > 1)
        {
          v27 = 4735;
          v11 = "(tref->tile == NULL) || (tref->tile == KD_EXPIRED_TILE)";
          goto LABEL_50;
        }
      }
      v7 += 24;
      v10 = *((_DWORD *)this + 60);
    }
    v8 = *((_DWORD *)this + 59);
LABEL_21:
    ++v9;
  }
  while (v9 < v8);
  v7 = *((_QWORD *)this + 41);
  if (v7)
LABEL_23:
    MEMORY[0x18D761C18](v7, 0x20C80960023A9);
LABEL_24:
  v16 = (kd_tile *)*((_QWORD *)this + 64);
  if (v16)
  {
    v11 = "typ->tile_ref == NULL";
    v12 = "codestream.cpp";
    v13 = "~kd_codestream";
    while (1)
    {
      *((_QWORD *)this + 64) = *((_QWORD *)v16 + 9);
      if (*((_QWORD *)v16 + 3))
        break;
      kd_tile::~kd_tile(v16);
      MEMORY[0x18D761C30]();
      v16 = (kd_tile *)*((_QWORD *)this + 64);
      if (!v16)
        goto LABEL_28;
    }
    v27 = 4745;
LABEL_50:
    __assert_rtn(v13, v12, v27, v11);
  }
LABEL_28:
  v17 = *((_QWORD *)this + 1);
  if (v17)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
    *((_QWORD *)this + 1) = 0;
  }
  v18 = *((_QWORD *)this + 2);
  if (v18)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
    *((_QWORD *)this + 2) = 0;
  }
  v19 = *((_QWORD *)this + 3);
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 16))(v19);
  v20 = *((_QWORD *)this + 4);
  if (v20)
  {
    v21 = *(_QWORD *)(v20 + 32);
    if (v21)
      MEMORY[0x18D761C18](v21, 0x1000C8077774924);
    MEMORY[0x18D761C30](v20, 0x1030C40051CB91CLL);
  }
  v22 = (kd_pp_markers *)*((_QWORD *)this + 5);
  if (v22)
  {
    kd_pp_markers::~kd_pp_markers(v22);
    MEMORY[0x18D761C30]();
  }
  v23 = (kd_precinct_size_class **)*((_QWORD *)this + 10);
  if (v23)
  {
    kd_precinct_server::~kd_precinct_server(v23);
    MEMORY[0x18D761C30]();
  }
  v24 = (kdu_block *)*((_QWORD *)this + 7);
  if (v24)
  {
    kdu_block::~kdu_block(v24);
    MEMORY[0x18D761C30]();
  }
  v25 = *((_QWORD *)this + 8);
  if (v25)
    MEMORY[0x18D761C30](v25, 0x1000C404E6BD753);
  v26 = (kd_tpart_pointer_server *)*((_QWORD *)this + 9);
  if (!v26)
    goto LABEL_53;
  kd_tpart_pointer_server::~kd_tpart_pointer_server(v26);
  while (1)
  {
    MEMORY[0x18D761C30]();
LABEL_53:
    v28 = *((_QWORD *)this + 11);
    *((_QWORD *)this + 12) = v28;
    if (!v28)
      break;
    v29 = *(_QWORD *)(v28 + 16);
    *((_QWORD *)this + 11) = *(_QWORD *)(v28 + 24);
    if (v29)
      MEMORY[0x18D761C18](v29, 0x1000C8077774924);
  }
  v30 = *((_QWORD *)this + 46);
  if (v30)
    MEMORY[0x18D761C18](v30, 0x1000C8000313F17);
  v31 = *((_QWORD *)this + 47);
  if (v31)
    MEMORY[0x18D761C18](v31, 0x1000C8000313F17);
  v32 = *((_QWORD *)this + 48);
  if (v32)
    MEMORY[0x18D761C18](v32, 0x1000C80BDFB0063);
  v33 = (kd_buf_server *)*((_QWORD *)this + 6);
  if (!v33)
    goto LABEL_70;
  v34 = *((_DWORD *)v33 + 16);
  if (v34 <= 0)
  {
    v11 = "num_users > 0";
    v27 = 216;
    v12 = "compressed_local.h";
    v13 = "detach";
    goto LABEL_50;
  }
  v35 = v34 - 1;
  *((_DWORD *)v33 + 16) = v35;
  if (v35)
    goto LABEL_70;
  kd_buf_server::~kd_buf_server(v33);
  while (1)
  {
    MEMORY[0x18D761C30]();
LABEL_70:
    v36 = (kd_mct_stage *)*((_QWORD *)this + 18);
    *((_QWORD *)this + 19) = v36;
    if (!v36)
      break;
    *((_QWORD *)this + 18) = *((_QWORD *)v36 + 7);
    kd_mct_stage::~kd_mct_stage(v36);
  }
  v37 = *((_QWORD *)this + 17);
  if (v37)
    MEMORY[0x18D761C18](v37, 0x1000C80CE7E837CLL);
}

uint64_t kd_codestream::create_tile(uint64_t a1, uint64_t a2)
{
  int v2;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  kd_tile *v9;
  kd_tile *v10;
  uint64_t result;
  _DWORD *exception;
  __int128 v13;

  v2 = HIDWORD(a2) - *(_DWORD *)(a1 + 232);
  if (v2 < 0
    || (v5 = a2 - *(_DWORD *)(a1 + 228), v5 < 0)
    || (v6 = *(_DWORD *)(a1 + 240), v6 <= v2)
    || *(_DWORD *)(a1 + 236) <= v5)
  {
    kd_codestream::create_tile();
  }
  v7 = *(_QWORD *)(a1 + 328) + 24 * v2 + 24 * v6 * v5;
  v8 = v7 + 16;
  if (*(_QWORD *)(v7 + 16))
    kd_codestream::create_tile();
  v13 = *(_OWORD *)(a1 + 204);
  LODWORD(v13) = v13 + DWORD2(v13) * a2;
  DWORD1(v13) += HIDWORD(v13) * HIDWORD(a2);
  kdu_dims::operator&=(&v13, (int *)(a1 + 188));
  if (SHIDWORD(v13) < 1 || *(uint64_t *)((char *)&v13 + 4) <= 0)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  if (!*(_QWORD *)(a1 + 8)
    || *(_BYTE *)(a1 + 417)
    || *(_BYTE *)(a1 + 408)
    || kdu_dims::intersects(&v13, (_DWORD *)(a1 + 264)))
  {
    v9 = *(kd_tile **)(a1 + 512);
    if (v9)
    {
      *(_QWORD *)v8 = v9;
      *(_QWORD *)(a1 + 512) = *((_QWORD *)v9 + 9);
      kd_tile::recycle(v9, v7, a2, v13, *((uint64_t *)&v13 + 1));
    }
    else
    {
      v10 = (kd_tile *)operator new();
      kd_tile::kd_tile(v10, a1, v7, a2, v13, *((_QWORD *)&v13 + 1));
      *(_QWORD *)v8 = v10;
      kd_tile::initialize(v10);
    }
    return *(_QWORD *)v8;
  }
  else
  {
    result = -1;
    *(_QWORD *)v8 = -1;
  }
  return result;
}

void sub_187F16A24(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1020C403DE16A90);
  _Unwind_Resume(a1);
}

uint64_t kd_codestream::simulate_output(kdu_params **this, uint64_t *a2, int a3, unsigned int a4, int a5, int a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v13;
  kdu_params *i;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  double v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  double v48;
  uint64_t v49;
  kdu_params *v50;
  int v51;
  __int128 v52;
  kdu_params **v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _OWORD v62[2];
  uint64_t v63;
  uint64_t v64[2];

  v13 = 0;
  *a2 = 0;
  if (a3)
  {
    if (!a6)
      goto LABEL_18;
  }
  else if (*((_BYTE *)this + 281) && !*((_BYTE *)this + 422))
  {
    v49 = (int)(kdu_params::generate_marker_segments(this[3], 0, -1, 0) + 2);
    *a2 = v49;
    if (!*((_BYTE *)this + 421))
    {
      kd_codestream::freeze_comments((uint64_t)this);
      v49 = *a2;
    }
    v50 = this[11];
    if (v50)
    {
      do
      {
        *(_BYTE *)v50 = 1;
        v49 += *((_DWORD *)v50 + 2) + 6;
        v50 = (kdu_params *)*((_QWORD *)v50 + 3);
      }
      while (v50);
      *a2 = v49;
    }
    v13 = v49 + *((int *)this + 108);
    *a2 = v13;
  }
  else
  {
    v13 = 0;
  }
  for (i = this[42]; i; i = (kdu_params *)*((_QWORD *)i + 5))
  {
    if (a3)
      v15 = 0;
    else
      v15 = (int)(kdu_params::generate_marker_segments(this[3], 0, *((_DWORD *)i + 2), *((unsigned int *)i + 76)) + 14);
    if (a6)
    {
      v16 = *((_DWORD *)i + 48);
      if (v16 > a3 + 1)
      {
        v17 = *((_DWORD *)i + 51) * (v16 + ~a3);
        if (*((_BYTE *)i + 285))
          v18 = 3;
        else
          v18 = 1;
        v15 += v17 * v18;
      }
    }
    *a2 += v15;
    v13 += v15;
  }
LABEL_18:
  if (v13 <= a7)
  {
    v53 = this;
    v54 = a2;
    v20 = *((_DWORD *)this + 42);
    v21 = (uint64_t)this[44] + 2816 * v20;
    v22 = 32;
    __asm { FMOV            V0.2D, #1.0 }
    v52 = _Q0;
    v28 = a8;
    v55 = a7;
    while (1)
    {
      v51 = v22;
      if (v20 >= 1)
        break;
LABEL_80:
      v22 = v51 - 1;
      v21 -= 176 * v20;
      if (!v51)
        return v13;
    }
    v29 = 0;
    while (1)
    {
      v30 = *(_QWORD *)(v21 + 48);
      if (v30)
        break;
LABEL_79:
      ++v29;
      v21 += 88;
      if (v29 >= v20)
        goto LABEL_80;
    }
    v31 = *(_QWORD *)(v21 + 40);
    v32 = *(_QWORD *)(v21 + 64);
    v33 = *(double *)(v21 + 72);
    if (v33 < 0.0)
    {
      v34 = v31 < 1 || v31 < v32;
      if (v34)
        kd_codestream::simulate_output();
      if (v31 != v32)
      {
        v36 = *(_QWORD *)(v21 + 32);
        v37 = *(_QWORD *)(v21 + 16) - v36;
        if (v37 < 1)
        {
          v38 = (double)v31;
        }
        else
        {
          if (v37 > v32 + v31)
            kd_codestream::simulate_output();
          v38 = (double)v37 * (double)*(uint64_t *)(v21 + 24) / (double)v36 + (double)(v31 - v37);
        }
        v33 = (double)v32 / v38;
        if (v33 > 1.0)
          v33 = 1.0;
        *(double *)(v21 + 72) = v33;
        *(double *)(v21 + 80) = 1.0 / v33;
        if (a8)
          goto LABEL_33;
        goto LABEL_41;
      }
      *(_OWORD *)(v21 + 72) = v52;
      v33 = 1.0;
    }
    if (a8)
    {
LABEL_33:
      v35 = *a8;
LABEL_42:
      v39 = 0;
      v40 = 0;
      v41 = (uint64_t)(v33 * (double)v35);
      if (v41 <= 1)
        v41 = 1;
      v57 = v32;
      v58 = v31;
      if (v31 == v32)
        v42 = a7 - v13;
      else
        v42 = (uint64_t)(v33 * (double)(a7 - v13));
      if (v31 == v32)
        v43 = v35;
      else
        v43 = v41 - 1;
      v64[0] = 0;
      v56 = v43;
      while (1)
      {
        if (*(_DWORD *)(v30 + 28))
        {
          v63 = 0;
          memset(v62, 0, sizeof(v62));
          kdu_error::kdu_error((kdu_error *)v62, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v62[0] + 16))(v62, "Attempting to run rate-control simulation on a precinct for which one or more packets have already been written to the code-stream.  Problem is most likely caused by trying to use the incremental code-stream flushing feature with one of the progression orders, LRCP or RLCP.");
          kdu_error::~kdu_error((kdu_error *)v62);
        }
        if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v30 + 8) + 8) + 192) > a3)
        {
          v64[0] = 0;
          if (v28)
          {
            v44 = a5 & a6;
            if (v43 < 0)
              v44 = 0;
            if ((v44 & 1) == 0)
              kd_codestream::simulate_output();
            if (a4 == 0xFFFF)
              kd_codestream::simulate_output();
            v45 = kd_precinct::simulate_packet((kd_precinct *)v30, v64, a3, (unsigned __int16)(a4 + 1), 0, 1, 0x10000000000000, 0);
            if (v45 + v43 >= v42 - v39)
              v46 = v42 - v39;
            else
              v46 = v45 + v43;
            if (v46 < v45)
              kd_codestream::simulate_output();
            v47 = kd_precinct::simulate_packet((kd_precinct *)v30, v64, a3, a4, 1, 1, v46, 1);
            v34 = v46 < v47;
            v43 = v46 - v47;
            if (v34)
              kd_codestream::simulate_output();
          }
          else
          {
            v47 = kd_precinct::simulate_packet((kd_precinct *)v30, v64, a3, a4, a5, a6, v42 - v39, 0);
          }
          v39 += v47;
          v40 += v64[0];
          if (v39 > v42)
            break;
        }
        v30 = *(_QWORD *)(v30 + 56);
        if (!v30)
          goto LABEL_71;
      }
      if (a5)
        kd_codestream::simulate_output();
LABEL_71:
      if (v58 == v57)
      {
        *v54 += v40;
        a8 = v28;
        if (!v28)
          goto LABEL_77;
      }
      else
      {
        v48 = *(double *)(v21 + 80);
        *v54 += (uint64_t)(v48 * (double)v40) + 1;
        v39 = (uint64_t)(v48 * (double)v39) + 1;
        a8 = v28;
        if (!v28)
        {
LABEL_77:
          v13 += v39;
          a7 = v55;
          if (v13 > v55)
            return v13;
          v20 = *((_DWORD *)v53 + 42);
          goto LABEL_79;
        }
        v43 = (*v28 + ~(uint64_t)(v48 * (double)(v56 - v43))) & ~((*v28 + ~(uint64_t)(v48 * (double)(v56 - v43))) >> 63);
      }
      *a8 = v43;
      goto LABEL_77;
    }
LABEL_41:
    v35 = 0;
    goto LABEL_42;
  }
  if (a5)
    kd_codestream::simulate_output();
  return v13;
}

void sub_187F16F6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F16F78()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

double kd_codestream::calculate_min_header_cost(kd_codestream *this)
{
  double result;
  uint64_t v3;
  uint64_t i;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int j;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (*((_QWORD *)this + 49))
    kd_codestream::calculate_min_header_cost();
  *((_QWORD *)this + 49) = 0;
  *((_QWORD *)this + 50) = 0;
  if (*((_BYTE *)this + 281))
    *((_QWORD *)this + 49) += (int)(kdu_params::generate_marker_segments(*((kdu_params **)this + 3), 0, -1, 0) + 2);
  if (!*((_BYTE *)this + 421))
    kd_codestream::freeze_comments((uint64_t)this);
  if (*((_BYTE *)this + 281))
  {
    v3 = *((_QWORD *)this + 11);
    for (i = *((_QWORD *)this + 49); v3; v3 = *(_QWORD *)(v3 + 24))
    {
      *(_BYTE *)v3 = 1;
      i += *(_DWORD *)(v3 + 8) + 6;
    }
    *((_QWORD *)this + 49) = i + *((int *)this + 108);
  }
  v5 = *((_DWORD *)this + 59);
  if (v5 < 1)
  {
    if (((*((int *)this + 49) * (uint64_t)*((int *)this + 50)) & 0x8000000000000000) == 0)
      return result;
LABEL_32:
    kd_codestream::calculate_min_header_cost();
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = *((_QWORD *)this + 41);
  v10 = *((_DWORD *)this + 60);
  do
  {
    if (v10 >= 1)
    {
      for (j = 0; j < v10; ++j)
      {
        v12 = *((_DWORD *)this + 58);
        v13 = *((_DWORD *)this + 56);
        if (j + v12 >= v13 || (v14 = *((_DWORD *)this + 57), v14 + v8 >= *((_DWORD *)this + 55)))
          kd_codestream::calculate_min_header_cost();
        *((_QWORD *)this + 49) += (int)(kdu_params::generate_marker_segments(*((kdu_params **)this + 3), 0, j + v12 + v13 * (v8 + v14), 0)+ 14);
        v15 = *(_QWORD *)(v9 + 16);
        if ((unint64_t)(v15 + 1) >= 2)
        {
          v6 += *(int *)(v15 + 220) * (uint64_t)*(int *)(v15 + 224);
          v16 = *(int *)(v15 + 204);
          if (*(_BYTE *)(v15 + 285))
            v17 = 2 * v16;
          else
            v17 = 0;
          v7 += v16 + v17;
          if (*(_BYTE *)(v15 + 284))
            v7 += 6 * (int)v16;
        }
        v9 += 24;
        v10 = *((_DWORD *)this + 60);
      }
      v5 = *((_DWORD *)this + 59);
    }
    ++v8;
  }
  while (v8 < v5);
  v18 = *((int *)this + 49) * (uint64_t)*((int *)this + 50);
  if (v18 < v6)
    goto LABEL_32;
  if (v6 >= 1)
  {
    result = (double)v18 / (double)v6 * (double)v7;
    *((_QWORD *)this + 50) = (uint64_t)result;
  }
  return result;
}

void kd_codestream::pcrd_opt(kd_codestream *this, int a2, double a3)
{
  double v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  long double v24;
  double v25;
  double v26;
  double v27;
  uint64_t v28;
  double v29;
  _QWORD *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  double v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;

  if (a3 <= 0.5)
    v4 = a3;
  else
    v4 = 0.5;
  if (!*((_QWORD *)this + 49))
    kd_codestream::calculate_min_header_cost(this);
  v60 = 0;
  LODWORD(v5) = *((_DWORD *)this + 91);
  if (*(_QWORD *)(*((_QWORD *)this + 47) + 8 * ((int)v5 - 1)))
  {
    v55 = 0;
  }
  else
  {
    v55 = kd_codestream::simulate_output((kdu_params **)this, &v60, 0, 0, 0, 0, 0x10000000000000, 0);
    LODWORD(v5) = *((_DWORD *)this + 91);
  }
  v6 = v5 - 1;
  if ((int)v5 < 1)
  {
    LODWORD(v7) = 0;
  }
  else
  {
    v7 = 0;
    while (*(_QWORD *)(*((_QWORD *)this + 47) + 8 * v7))
    {
      if (v5 == ++v7)
        goto LABEL_45;
    }
  }
  if ((int)v7 < v6)
  {
    v8 = (_QWORD *)*((_QWORD *)this + 47);
    v9 = *v8;
    if (*v8)
    {
      v10 = 0;
      do
      {
        v11 = &v8[v10++];
        v12 = *((_QWORD *)this + 49) + v9 + *((_QWORD *)this + 50) * v10;
        *v11 = v12;
        v9 = v11[1];
      }
      while (v9);
    }
    else
    {
      LODWORD(v10) = 0;
      v12 = 0;
    }
    if ((int)v10 < v6)
    {
      v13 = v6;
      v57 = v8 + 1;
      v54 = v8;
      do
      {
        v14 = (int)v10;
        v15 = v8[(int)v10];
        if (v15)
        {
          LODWORD(v10) = v10 + 1;
          v12 = v15;
        }
        else
        {
          v16 = 0;
          v17 = v10;
          do
          {
            v10 = v16;
            v18 = v57[v14 + v16];
            if (v18)
            {
              v19 = v17 + v16;
              goto LABEL_30;
            }
            ++v16;
          }
          while (v14 + v10 + 1 < v13);
          v19 = v5 - 2;
          v18 = v55;
          if (1 - (_DWORD)v5 + (_DWORD)v14 + (_DWORD)v16)
            kd_codestream::pcrd_opt();
LABEL_30:
          v20 = *((_QWORD *)this + 49);
          v21 = *((_QWORD *)this + 50);
          v22 = v18 - (v20 + v21 * (v19 + 2));
          if (v22 <= 1)
            v22 = 1;
          v23 = (double)v22;
          if (v12)
          {
            v24 = (double)(v12 - (v20 + v21 * v14));
          }
          else
          {
            if (v17)
              kd_codestream::pcrd_opt();
            v24 = exp2((double)((int)v10 + 2) * -0.5) * v23;
          }
          if (v24 <= 0.0)
            kd_codestream::pcrd_opt();
          v25 = log(v24);
          v26 = log(v23);
          if ((int)v14 <= v19)
          {
            v27 = v26;
            v28 = 0;
            v29 = (double)((int)v10 + 2);
            LODWORD(v10) = v19 + 1;
            v30 = &v8[v14];
            v31 = v10 - v17;
            v32 = v14 + 1;
            do
            {
              v30[v28] = *((_QWORD *)this + 49)
                       + (uint64_t)exp(v27 * ((double)((int)v28 + 1) / v29) + (1.0 - (double)((int)v28 + 1) / v29) * v25)
                       + *((_QWORD *)this + 50) * (v32 + v28);
              ++v28;
            }
            while (v31 != (_DWORD)v28);
            v8 = v54;
            v6 = v5 - 1;
          }
          else
          {
            LODWORD(v10) = v17;
          }
        }
      }
      while ((int)v10 < v6);
    }
  }
LABEL_45:
  if ((int)v5 >= 1)
  {
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = *((_QWORD *)this + 47);
    v37 = 0x10000;
    do
    {
      v38 = (v5 - 1);
      v39 = *(_QWORD *)(*((_QWORD *)this + 46) + 8 * v33) + v34;
      v40 = *(_QWORD *)(v36 + 8 * v33);
      v58 = v39;
      if (v40)
      {
        if (*((_BYTE *)this + 282))
          v40 -= 2;
        v41 = (double)*((uint64_t *)this + 50);
        if (!v33)
          v41 = v41 + (double)*((uint64_t *)this + 49);
        if (v39 >= 1 && v4 > 0.0 && v39 < v40)
          v41 = v41 - (double)(uint64_t)((double)v39 / (double)v40 * v41);
        v42 = v40 - v35 - v39;
        v43 = v35;
        if (v4 <= 0.0 || v42 <= (uint64_t)v41)
          v44 = v42;
        else
          v44 = v42 - (uint64_t)(v4 * ((double)v42 - v41));
      }
      else
      {
        if (v33 != v38)
          kd_codestream::pcrd_opt();
        v43 = v35;
        v42 = 0x10000000000000;
        v37 = 1;
        v44 = 0x10000000000000;
      }
      v45 = 0;
      if (v37 <= 1)
        v46 = 1;
      else
        v46 = v37;
      v47 = v46 - 1;
      do
      {
        v48 = v46 + v45;
        if (v46 + v45 >= 0x20000)
          kd_codestream::pcrd_opt();
        v49 = v48 >> 1;
        v50 = kd_codestream::simulate_output((kdu_params **)this, &v60, v33, (unsigned __int16)(v48 >> 1), 0, v33 == v38, v42, 0);
        if (v50 <= v42)
        {
          if (v50 >= v44)
            goto LABEL_73;
          v46 = v49;
          v47 = v49;
        }
        else
        {
          v45 = v49 + 1;
        }
      }
      while (v46 > v45);
      v49 = v47;
LABEL_73:
      v51 = v43;
      v34 = v58;
      v52 = v42
          - kd_codestream::simulate_output((kdu_params **)this, &v60, v33, (unsigned __int16)v49, 0, v33 == v38, 0x10000000000000, 0);
      v59 = v52;
      if (v49 >= 1 && v33 == v38 && v52 >= 1 && a2)
        v53 = kd_codestream::simulate_output((kdu_params **)this, &v60, v33, (unsigned __int16)--v49, 1, 1, v42, &v59);
      else
        v53 = kd_codestream::simulate_output((kdu_params **)this, &v60, v33, (unsigned __int16)v49, 1, v33 == v38, 0x10000000000000, 0);
      *(_WORD *)(*((_QWORD *)this + 48) + 2 * v33) = v49;
      v35 = v53 + v51;
      v36 = *((_QWORD *)this + 47);
      if (!*(_QWORD *)(v36 + 8 * v33))
      {
        if (v33 != v38)
          kd_codestream::pcrd_opt();
        *(_QWORD *)(v36 + 8 * v33) = v35 + v58 + 2 * *((unsigned __int8 *)this + 282);
      }
      v37 = v49 + 1;
      ++v33;
      v5 = *((int *)this + 91);
    }
    while (v33 < v5);
  }
}

BOOL kd_codestream::generate_codestream(kd_codestream *this, int a2)
{
  kdu_output *v4;
  kd_codestream_comment *i;
  kdu_params *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  kd_tile *v10;
  char v11;
  kd_tile *v12;
  uint64_t v13;
  uint64_t tile_part;
  BOOL v16;
  int v17;
  kdu_compressed_target **v18;
  int v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  if (!*((_QWORD *)this + 2))
    kd_codestream::generate_codestream();
  if (!*((_QWORD *)this + 46) || !*((_QWORD *)this + 48))
    kd_codestream::generate_codestream();
  if (*((_DWORD *)this + 91) < a2)
  {
    v23 = 0;
    v21 = 0u;
    v22 = 0u;
    kdu_error::kdu_error((kdu_error *)&v21, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v21);
  }
  if (!*((_BYTE *)this + 422))
  {
    *((_BYTE *)this + 422) = 1;
    if (*((_BYTE *)this + 281))
    {
      v4 = (kdu_output *)*((_QWORD *)this + 2);
      kdu_output::put(v4, 255);
      kdu_output::put(v4, 79);
      **((_QWORD **)this + 46) += 2;
      **((_QWORD **)this + 46) += (int)kdu_params::generate_marker_segments(*((kdu_params **)this + 3), *((kdu_output **)this + 2), -1, 0);
      if (!*((_BYTE *)this + 421))
        kd_codestream::freeze_comments((uint64_t)this);
      for (i = (kd_codestream_comment *)*((_QWORD *)this + 11); i; i = (kd_codestream_comment *)*((_QWORD *)i + 3))
        **((_QWORD **)this + 46) += (int)kd_codestream_comment::write_marker(i, *((kdu_output **)this + 2), 0);
    }
    if (*((_DWORD *)this + 26))
      kd_codestream::generate_codestream();
    v6 = (kdu_params *)kdu_params::access_cluster(*((kdu_params **)this + 3), "ORG");
    if (!v6)
      kd_codestream::generate_codestream();
    v20 = 0;
    if (!kdu_params::get(v6, "ORGgen_tlm", 0, 0, &v20, 1, 1, 1) || v20 < 1)
      goto LABEL_25;
    if (v20 >= 0x100)
      v20 = 255;
    v7 = (_QWORD *)*((_QWORD *)this + 2);
    (*(void (**)(_QWORD *))(*v7 + 16))(v7);
    v8 = v7[67];
    if ((*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 24))(v8, 0))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
      if (kd_tlm_generator::init((kd_codestream *)((char *)this + 104), *((_DWORD *)this + 55) * *((_DWORD *)this + 56), v20))
      {
        if (*((_BYTE *)this + 281))
          kd_tlm_generator::write_dummy_tlms((int *)this + 26, *((kd_compressed_output **)this + 2));
        goto LABEL_25;
      }
      v23 = 0;
      v21 = 0u;
      v22 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v21, "Kakadu Core Warning:\n");
    }
    else
    {
      v23 = 0;
      v21 = 0u;
      v22 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v21, "Kakadu Core Warning:\n");
    }
    kdu_warning::~kdu_warning((kdu_warning *)&v21);
LABEL_25:
    if (*((_QWORD *)this + 53))
      kd_codestream::generate_codestream();
    v9 = *(_QWORD *)(*((_QWORD *)this + 2) + 544)
       - *((_QWORD *)this + 2)
       + *(_QWORD *)(*((_QWORD *)this + 2) + 520)
       - 8;
    *((_QWORD *)this + 53) = v9;
    if (!*((_BYTE *)this + 281) && v9)
      kd_codestream::generate_codestream();
    goto LABEL_28;
  }
  do
  {
LABEL_28:
    v10 = (kd_tile *)*((_QWORD *)this + 42);
    if (!v10)
      break;
    v11 = 1;
    do
    {
      v12 = (kd_tile *)*((_QWORD *)v10 + 5);
      v13 = *((_QWORD *)v10 + 3);
      tile_part = kd_tile::generate_tile_part(v10, a2, *((unsigned __int16 **)this + 48));
      v16 = *(_QWORD *)(v13 + 16) == -1 || tile_part < 1;
      v11 &= v16;
      v10 = v12;
    }
    while (v12);
  }
  while ((v11 & 1) == 0);
  v17 = *((_DWORD *)this + 90);
  if (!v17)
  {
    v18 = (kdu_compressed_target **)*((_QWORD *)this + 2);
    if (*((int *)this + 26) >= 1)
    {
      (*((void (**)(_QWORD))*v18 + 2))(*((_QWORD *)this + 2));
      kd_tlm_generator::write_tlms((kd_codestream *)((char *)this + 104), v18[67], *((_DWORD *)this + 74), *((_QWORD *)this + 38));
      v18 = (kdu_compressed_target **)*((_QWORD *)this + 2);
    }
    if (*((_BYTE *)this + 282))
    {
      kdu_output::put((kdu_output *)v18, 255);
      kdu_output::put((kdu_output *)v18, 217);
      **((_QWORD **)this + 46) += 2;
      v18 = (kdu_compressed_target **)*((_QWORD *)this + 2);
    }
    (*((void (**)(kdu_compressed_target **))*v18 + 2))(v18);
    v17 = *((_DWORD *)this + 90);
  }
  return v17 == 0;
}

void sub_187F17A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

uint64_t kd_codestream::unload_tiles_to_cache_threshold(uint64_t this)
{
  int v1;
  uint64_t v2;
  _DWORD *v3;
  uint64_t v4;
  _BOOL4 v5;
  uint64_t v6;

  v1 = *(_DWORD *)(this + 504);
  if (v1 >= 1)
  {
    v2 = this;
    v3 = (_DWORD *)(this + 264);
    do
    {
      if (v1 <= *(_DWORD *)(v2 + 508)
        && *(_QWORD *)(*(_QWORD *)(v2 + 48) + 56) >= *(_QWORD *)(*(_QWORD *)(v2 + 48) + 40)
                                                     + 220 * *(_QWORD *)(*(_QWORD *)(v2 + 48) + 24))
      {
        break;
      }
      v4 = *(_QWORD *)(v2 + 496);
      if (!v4)
        goto LABEL_12;
      while (1)
      {
        v5 = kdu_dims::intersects((_DWORD *)(v4 + 212), v3);
        v6 = *(_QWORD *)(v2 + 496);
        if (!v5)
          break;
        v4 = *(_QWORD *)(v6 + 56);
        *(_QWORD *)(v2 + 496) = v4;
        if (!v4)
          goto LABEL_12;
      }
      if (v6)
      {
        if (!*(_BYTE *)(v6 + 290))
          kd_codestream::unload_tiles_to_cache_threshold();
      }
      else
      {
LABEL_12:
        v6 = *(_QWORD *)(v2 + 480);
      }
      this = kd_tile::release((kd_tile *)v6);
      v1 = *(_DWORD *)(v2 + 504);
    }
    while (v1 > 0);
  }
  return this;
}

void kdu_codestream::create(kd_codestream **this, siz_params *a2, kdu_compressed_target *a3, kdu_dims *a4, int a5, uint64_t a6)
{
  _DWORD *v12;
  _QWORD *v13;
  siz_params *v14;

  if (!a3 || *this)
    kdu_codestream::create();
  v12 = (_DWORD *)operator new();
  bzero(v12, 0x208uLL);
  v12[127] = 64;
  *this = (kd_codestream *)v12;
  v13 = (_QWORD *)operator new();
  v13[65] = v13 + 1;
  v13[66] = v13 + 65;
  *v13 = &off_1E1BB2150;
  v13[67] = a3;
  v13[68] = 0;
  *((_QWORD *)*this + 2) = v13;
  v14 = (siz_params *)operator new();
  siz_params::siz_params(v14);
  *((_QWORD *)*this + 3) = v14;
  kdu_params::copy_from((uint64_t)v14, a2, -1, -1, -1, 0, 0, 0, 0, 0);
  kd_codestream::construct_common(*this);
  if (a4)
    kd_codestream::restrict_to_fragment((uint64_t)*this, *(_QWORD *)a4, *((_QWORD *)a4 + 1), a5, a6);
  *((_DWORD *)*this + 90) = *((_DWORD *)*this + 59) * *((_DWORD *)*this + 60);
}

void sub_187F17C84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

clock_t kdu_codestream::create(kd_codestream **this, kdu_compressed_source *a2)
{
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  kd_codestream *v7;
  siz_params *v8;
  kd_codestream *v9;
  clock_t result;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  if (*this)
    kdu_codestream::create();
  v4 = (_DWORD *)operator new();
  bzero(v4, 0x208uLL);
  v4[127] = 64;
  *this = (kd_codestream *)v4;
  v5 = operator new();
  *(_QWORD *)(v5 + 536) = v5 + 14;
  *(_QWORD *)(v5 + 528) = v5 + 14;
  *(_WORD *)(v5 + 544) = 0;
  *(_QWORD *)v5 = &off_1E1BB1D38;
  *(_QWORD *)(v5 + 552) = a2;
  *(_OWORD *)(v5 + 560) = xmmword_18820CCF0;
  *(_OWORD *)(v5 + 576) = 0u;
  *(_OWORD *)(v5 + 592) = 0u;
  *(_BYTE *)(v5 + 608) = 0;
  *((_QWORD *)*this + 1) = v5;
  *((_BYTE *)*this + 418) = ((*(uint64_t (**)(kdu_compressed_source *))(*(_QWORD *)a2 + 24))(a2) & 4) != 0;
  v6 = operator new();
  v7 = *this;
  *(_QWORD *)v6 = *((_QWORD *)*this + 1);
  *(_QWORD *)(v6 + 8) = v7;
  *(_WORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 20) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  *(_QWORD *)(v6 + 32) = 0;
  *(_WORD *)(v6 + 40) = 0;
  *((_QWORD *)v7 + 4) = v6;
  if (!kd_marker::read((kd_marker *)v6, 0, 0) || *(__int16 *)(*((_QWORD *)*this + 4) + 16) != -177)
  {
    v13 = 0;
    v11 = 0u;
    v12 = 0u;
    kdu_error::kdu_error((kdu_error *)&v11, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v11 + 16))(&v11, "Code-stream must start with an SOC marker!");
    kdu_error::~kdu_error((kdu_error *)&v11);
  }
  v8 = (siz_params *)operator new();
  siz_params::siz_params(v8);
  v9 = *this;
  *((_QWORD *)v9 + 3) = v8;
  if (!kd_marker::read(*((kd_marker **)v9 + 4), 0, 0)
    || (kdu_params::translate_marker_segment(*((kdu_params **)*this + 3), *(unsigned __int16 *)(*((_QWORD *)*this + 4) + 16), *(unsigned int *)(*((_QWORD *)*this + 4) + 20), *(unsigned __int8 **)(*((_QWORD *)*this + 4) + 32), -1, 0) & 1) == 0)
  {
    v13 = 0;
    v11 = 0u;
    v12 = 0u;
    kdu_error::kdu_error((kdu_error *)&v11, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v11 + 16))(&v11, "Code-stream must contain a valid SIZ marker segment, immediately after the SOC marker!");
    kdu_error::~kdu_error((kdu_error *)&v11);
  }
  result = kd_codestream::construct_common(*this);
  *((_BYTE *)*this + 421) = 1;
  return result;
}

void sub_187F17ED0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F17EDC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kdu_codestream::restart(kd_codestream **this, kdu_compressed_source *a2)
{
  uint64_t v4;
  uint64_t v5;
  kd_codestream *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  kd_codestream *v10;
  char v11;
  kd_codestream *v12;
  int v13;
  kd_codestream *v14;
  uint64_t v15;
  siz_params *v16;
  kd_codestream *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  _QWORD *v26;
  uint64_t v27;
  kd_codestream *v28;
  _OWORD v29[2];
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  if (!*((_BYTE *)*this + 408))
  {
    *(_QWORD *)&v33 = 0;
    v31 = 0u;
    v32 = 0u;
    kdu_error::kdu_error((kdu_error *)&v31, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v31);
  }
  v4 = *((_QWORD *)*this + 1);
  if (!v4)
  {
    *(_QWORD *)&v33 = 0;
    v31 = 0u;
    v32 = 0u;
    kdu_error::kdu_error((kdu_error *)&v31, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v31);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = operator new();
  *(_QWORD *)(v5 + 536) = v5 + 14;
  *(_QWORD *)(v5 + 528) = v5 + 14;
  *(_WORD *)(v5 + 544) = 0;
  *(_QWORD *)v5 = &off_1E1BB1D38;
  *(_QWORD *)(v5 + 552) = a2;
  *(_OWORD *)(v5 + 560) = xmmword_18820CCF0;
  *(_OWORD *)(v5 + 576) = 0u;
  *(_OWORD *)(v5 + 592) = 0u;
  *(_BYTE *)(v5 + 608) = 0;
  v6 = *this;
  *((_QWORD *)v6 + 1) = v5;
  v7 = *((_QWORD *)v6 + 4);
  if (v7)
  {
    v8 = *(_QWORD *)(v7 + 32);
    if (v8)
      MEMORY[0x18D761C18](v8, 0x1000C8077774924);
    MEMORY[0x18D761C30](v7, 0x1030C40051CB91CLL);
  }
  v9 = operator new();
  v10 = *this;
  *(_QWORD *)v9 = *((_QWORD *)*this + 1);
  *(_QWORD *)(v9 + 8) = v10;
  *(_WORD *)(v9 + 16) = 0;
  *(_DWORD *)(v9 + 20) = 0;
  *(_DWORD *)(v9 + 24) = 0;
  *(_QWORD *)(v9 + 32) = 0;
  *(_WORD *)(v9 + 40) = 0;
  *((_QWORD *)v10 + 4) = v9;
  v11 = (*(uint64_t (**)(kdu_compressed_source *))(*(_QWORD *)a2 + 24))(a2);
  v12 = *this;
  *((_BYTE *)v12 + 418) = (v11 & 4) != 0;
  if (!kd_marker::read(*((kd_marker **)v12 + 4), 0, 0)
    || *(__int16 *)(*((_QWORD *)*this + 4) + 16) != -177)
  {
    *(_QWORD *)&v33 = 0;
    v31 = 0u;
    v32 = 0u;
    kdu_error::kdu_error((kdu_error *)&v31, "Kakadu Core Error:\n");
    (*(void (**)(__int128 *, const char *))(v31 + 16))(&v31, "Code-stream must start with an SOC marker!");
    kdu_error::~kdu_error((kdu_error *)&v31);
  }
  v40 = 0;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v31 = 0u;
  siz_params::siz_params((siz_params *)&v31);
  kdu_params::copy_from((uint64_t)&v31, *((kdu_params **)*this + 3), -1, -1, -1, 0, 0, 0, 0, 0);
  kdu_params::clear_marks((uint64_t)&v31);
  if (!kd_marker::read(*((kd_marker **)*this + 4), 0, 0)
    || (kdu_params::translate_marker_segment((kdu_params *)&v31, *(unsigned __int16 *)(*((_QWORD *)*this + 4) + 16), *(unsigned int *)(*((_QWORD *)*this + 4) + 20), *(unsigned __int8 **)(*((_QWORD *)*this + 4) + 32), -1, 0) & 1) == 0)
  {
    v30 = 0;
    memset(v29, 0, sizeof(v29));
    kdu_error::kdu_error((kdu_error *)v29, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v29[0] + 16))(v29, "Code-stream must contain a valid SIZ marker segment, immediately after the SOC marker!");
    kdu_error::~kdu_error((kdu_error *)v29);
  }
  v13 = kdu_params::any_changes((kdu_params *)&v31);
  v14 = *this;
  if (v13)
  {
    v15 = operator new();
    bzero((void *)v15, 0x208uLL);
    *(_DWORD *)(v15 + 508) = 64;
    *this = (kd_codestream *)v15;
    *(_QWORD *)(v15 + 8) = *((_QWORD *)v14 + 1);
    *((_QWORD *)v14 + 1) = 0;
    *(_QWORD *)(v15 + 32) = *((_QWORD *)v14 + 4);
    *((_QWORD *)v14 + 4) = 0;
    v16 = (siz_params *)operator new();
    siz_params::siz_params(v16);
    *((_QWORD *)*this + 3) = v16;
    kdu_params::copy_from((uint64_t)v16, (kdu_params *)&v31, -1, -1, -1, 0, 0, 0, 0, 0);
    kd_codestream::construct_common(*this);
    v17 = *this;
    *((_DWORD *)v17 + 61) = *((_DWORD *)v14 + 61);
    *((_DWORD *)v17 + 63) = *((_DWORD *)v14 + 63);
    v18 = *((unsigned int *)v17 + 42);
    if ((_DWORD)v18 == *((_DWORD *)v14 + 42))
    {
      *((_DWORD *)v17 + 43) = *((_DWORD *)v14 + 43);
      if ((int)v18 >= 1)
      {
        v19 = *((_QWORD *)v14 + 39);
        v20 = *((_QWORD *)v17 + 39);
        v21 = (_QWORD *)(v19 + 96);
        v22 = (_QWORD *)(v20 + 96);
        do
        {
          *((_DWORD *)v22 - 2) = *((_DWORD *)v21 - 2);
          v23 = *v21;
          v21 += 13;
          *v22 = v20 + v23 - v19;
          v22 += 13;
          --v18;
        }
        while (v18);
      }
    }
    v24 = *((unsigned int *)v17 + 44);
    if ((_DWORD)v24 == *((_DWORD *)v14 + 44))
    {
      *((_DWORD *)v17 + 45) = *((_DWORD *)v14 + 45);
      if ((int)v24 >= 1)
      {
        v25 = (uint64_t *)(*((_QWORD *)v14 + 40) + 16);
        v26 = (_QWORD *)(*((_QWORD *)v17 + 40) + 16);
        do
        {
          v27 = *v25;
          v25 += 6;
          *v26 = v27;
          v26 += 6;
          --v24;
        }
        while (v24);
      }
    }
    *((_DWORD *)v17 + 46) = *((_DWORD *)v14 + 46);
    *((_DWORD *)v17 + 102) = *((_DWORD *)v14 + 102);
    *((_WORD *)v17 + 206) = *((_WORD *)v14 + 206);
    *((_BYTE *)v17 + 414) = *((_BYTE *)v14 + 414);
    *(_WORD *)((char *)v17 + 417) = *(_WORD *)((char *)v14 + 417);
    *((_WORD *)v17 + 232) = *((_WORD *)v14 + 232);
    kd_codestream::~kd_codestream(v14);
    MEMORY[0x18D761C30]();
  }
  else
  {
    kd_codestream::restart(*this);
  }
  v28 = *this;
  *((_BYTE *)v28 + 421) = 1;
  *((_QWORD *)v28 + 62) = *((_QWORD *)v28 + 60);
  kdu_params::~kdu_params((kdu_params *)&v31);
}

void sub_187F183E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F183EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Exception *v17;

  _Unwind_Resume(v17);
}

uint64_t kdu_codestream::destroy(kd_codestream **this)
{
  kd_codestream *v2;
  uint64_t result;

  v2 = *this;
  if (!v2)
    kdu_codestream::destroy();
  kd_codestream::~kd_codestream(v2);
  result = MEMORY[0x18D761C30]();
  *this = 0;
  return result;
}

uint64_t kdu_codestream::augment_cache_threshold(kdu_codestream *this, int a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(*(_QWORD *)this + 48);
  result = *(_QWORD *)(v2 + 56) + a2;
  *(_QWORD *)(v2 + 56) = result;
  return result;
}

uint64_t *kdu_codestream::enable_restart(uint64_t *this)
{
  uint64_t v1;
  _OWORD v2[2];
  uint64_t v3;

  v1 = *this;
  if (!*(_BYTE *)(*this + 408))
  {
    if (*(_BYTE *)(v1 + 419))
    {
      v3 = 0;
      memset(v2, 0, sizeof(v2));
      kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v2);
    }
    *(_BYTE *)(v1 + 408) = 1;
  }
  return this;
}

void sub_187F1853C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F18548()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t *kdu_codestream::set_persistent(uint64_t *this)
{
  uint64_t v1;
  _OWORD v2[2];
  uint64_t v3;

  v1 = *this;
  if (*(_QWORD *)(*this + 8))
  {
    if (*(_BYTE *)(v1 + 419))
    {
      v3 = 0;
      memset(v2, 0, sizeof(v2));
      kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v2[0] + 16))(v2, "You may only set the codestream object into its \"persistent\" mode prior to opening the first tile.");
      kdu_error::~kdu_error((kdu_error *)v2);
    }
    *(_BYTE *)(v1 + 417) = 1;
  }
  return this;
}

void sub_187F185D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F185E0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_codestream::access_siz(kdu_codestream *this)
{
  return *(_QWORD *)(*(_QWORD *)this + 24);
}

void kdu_codestream::set_max_bytes(kdu_codestream *this, uint64_t a2, char a3, char a4)
{
  uint64_t v4;
  uint64_t v7;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  _OWORD v13[2];
  uint64_t v14;
  char v15[16];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)this;
  if (*(_BYTE *)(*(_QWORD *)this + 419))
    kdu_codestream::set_max_bytes();
  v7 = *(_QWORD *)(v4 + 8);
  if (v7)
  {
    *(_BYTE *)(v4 + 416) = a3;
    kd_compressed_input::set_max_bytes(v7, a2);
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)this + 8) + 544))
    {
      v14 = 0;
      memset(v13, 0, sizeof(v13));
      kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v13[0] + 16))(v13, "Attempting to impose too small a limit on the number of code-stream bytes. ");
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      *(_OWORD *)v15 = 0u;
      if (BYTE8(v13[0]))
        sprintf(v15, "%x");
      else
        sprintf(v15, "%d");
      (*(void (**)(_OWORD *, char *))(*(_QWORD *)&v13[0] + 16))(v13, v15);
      (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v13[0] + 16))(v13, " bytes is insufficient to accomodate even the main header!");
      kdu_error::~kdu_error((kdu_error *)v13);
    }
  }
  else if (*(_QWORD *)(v4 + 16))
  {
    if (*(_QWORD *)(v4 + 64))
    {
      *(_QWORD *)&v17 = 0;
      *(_OWORD *)v15 = 0u;
      v16 = 0u;
      kdu_error::kdu_error((kdu_error *)v15, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(_QWORD *)v15 + 16))(v15, "\"kdu_codestream::set_max_bytes\" may not be called multiple times.");
      kdu_error::~kdu_error((kdu_error *)v15);
    }
    if (*(int *)(v4 + 168) < 1)
    {
      v10 = 0;
    }
    else
    {
      v9 = 0;
      v10 = 0;
      do
      {
        memset(v15, 0, sizeof(v15));
        kdu_codestream::get_dims(this, v9, (int32x4_t *)v15, 0);
        v10 += *(int *)&v15[8] * (uint64_t)*(int *)&v15[12];
        ++v9;
      }
      while (v9 < *(_DWORD *)(*(_QWORD *)this + 168));
    }
    v11 = operator new();
    *(_QWORD *)(v11 + 32) = 0;
    *(_DWORD *)(v11 + 32808) = 4095;
    bzero((void *)(v11 + 40), 0x8000uLL);
    *(_DWORD *)(v11 + 32820) = 0;
    *(_QWORD *)(v11 + 32812) = 0;
    *(_QWORD *)(v11 + 8) = v10;
    *(_QWORD *)(v11 + 16) = (v10 + 7) >> 3;
    *(_QWORD *)(v11 + 24) = (v10 >> 4) + 4096;
    if (v10)
      v12 = (double)a2 / (double)v10;
    else
      v12 = 1.0;
    *(double *)v11 = v12;
    *(_BYTE *)(v11 + 32824) = a4;
    *(_QWORD *)(*(_QWORD *)this + 64) = v11;
  }
}

void sub_187F18870(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F1887C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Exception *v11;

  _Unwind_Resume(v11);
}

int32x4_t *kdu_codestream::get_dims(kdu_codestream *this, unsigned int a2, int32x4_t *a3, int a4)
{
  uint64_t v6;
  int **v9;
  int *v10;
  int v11;
  int v12;
  char *v13;
  char v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;

  v6 = *(_QWORD *)this;
  if ((a2 & 0x80000000) != 0)
  {
    *a3 = *(int32x4_t *)(v6 + 264);
    return kdu_dims::to_apparent(a3, *(unsigned __int8 *)(*(_QWORD *)this + 409), *(unsigned __int8 *)(*(_QWORD *)this + 410), *(unsigned __int8 *)(*(_QWORD *)this + 411));
  }
  if (*(_BYTE *)(v6 + 420))
  {
    if (!a4)
      goto LABEL_8;
  }
  else
  {
    kd_codestream::finalize_construction((kd_codestream *)v6);
    v6 = *(_QWORD *)this;
    if (!a4)
      goto LABEL_8;
  }
  if (!*(_DWORD *)(v6 + 184))
  {
    v9 = (int **)(*(_QWORD *)(v6 + 320) + 48 * *(int *)(*(_QWORD *)(v6 + 320) + 48 * a2 + 20) + 8);
    goto LABEL_10;
  }
LABEL_8:
  v9 = (int **)(*(_QWORD *)(v6 + 312) + 104 * a2 + 96);
LABEL_10:
  v10 = *v9;
  v11 = *(_DWORD *)(v6 + 268);
  v12 = *(_DWORD *)(v6 + 276) + v11;
  v13 = (char *)v10 + *(int *)(v6 + 244);
  v14 = v13[54];
  v15 = *v10;
  v16 = v10[1] << v13[21];
  if (v16 <= 1)
    v17 = 1;
  else
    v17 = v16;
  if (v11 <= 0)
    v18 = -(int)(-v11 / v17);
  else
    v18 = (v11 - 1) / v17 + 1;
  v19 = *(_DWORD *)(v6 + 264);
  v20 = v15 << v14;
  if (v12 <= 0)
    v21 = -(int)(-v12 / v17);
  else
    v21 = (v12 - 1) / v17 + 1;
  v22 = *(_DWORD *)(v6 + 272) + v19;
  if ((int)v20 <= 1)
    v20 = 1;
  if (v19 <= 0)
    v23 = -(int)(-v19 / v20);
  else
    v23 = (v19 - 1) / v20 + 1;
  if (v22 <= 0)
    v24 = -(int)(-v22 / v20);
  else
    v24 = (v22 - 1) / v20 + 1;
  a3->i64[0] = v23 | (unint64_t)(v18 << 32);
  a3->i64[1] = (v24 - v23) | ((unint64_t)(v21 - v18) << 32);
  return kdu_dims::to_apparent(a3, *(unsigned __int8 *)(*(_QWORD *)this + 409), *(unsigned __int8 *)(*(_QWORD *)this + 410), *(unsigned __int8 *)(*(_QWORD *)this + 411));
}

_QWORD *kdu_codestream::set_resilient(_QWORD *this, char a2)
{
  _BYTE *v2;

  v2 = (_BYTE *)*this;
  v2[412] = 1;
  v2[413] = a2;
  v2[414] = 0;
  return this;
}

uint64_t *kdu_codestream::set_fussy(uint64_t *this)
{
  uint64_t v1;

  v1 = *this;
  *(_BYTE *)(v1 + 412) = 0;
  *(_BYTE *)(v1 + 414) = 1;
  return this;
}

uint64_t *kdu_codestream::set_fast(uint64_t *this)
{
  uint64_t v1;

  v1 = *this;
  *(_BYTE *)(v1 + 412) = 0;
  *(_BYTE *)(v1 + 414) = 0;
  return this;
}

uint64_t kdu_codestream::apply_input_restrictions(uint64_t result, int a2, int a3, int a4, int a5, int *a6, int a7)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;

  v10 = result;
  v11 = *(_QWORD *)result;
  if (*(_QWORD *)(*(_QWORD *)result + 16))
  {
    v39 = 0;
    v37 = 0u;
    v38 = 0u;
    kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v37);
  }
  if (*(_BYTE *)(v11 + 419))
  {
    if (*(_DWORD *)(v11 + 260))
    {
      v39 = 0;
      v37 = 0u;
      v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v37 + 16))(&v37, "You may apply restrictions to the resolution or number of image components only after closing all open tiles.");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
    if (!*(_BYTE *)(v11 + 417))
    {
      v39 = 0;
      v37 = 0u;
      v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v37 + 16))(&v37, "You may not apply restrictions to the resolution or number of image components after the first tile access, unless the codestream object is set up to be persistent.");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
  }
  *(_DWORD *)(v11 + 244) = a4;
  if (a5 >= 1)
    v12 = a5;
  else
    v12 = 0xFFFF;
  *(_DWORD *)(v11 + 252) = v12;
  *(_OWORD *)(v11 + 264) = *(_OWORD *)(v11 + 188);
  if (a6)
    result = kdu_dims::operator&=((_DWORD *)(*(_QWORD *)result + 264), a6);
  v13 = *(_QWORD *)v10;
  *(_QWORD *)(v13 + 496) = *(_QWORD *)(*(_QWORD *)v10 + 480);
  *(_DWORD *)(v13 + 184) = a7;
  if (a7)
  {
    if (a7 != 1)
      kdu_codestream::apply_input_restrictions();
    if (a2 < 0 || (v14 = *(_DWORD *)(v13 + 168), v14 <= a2))
    {
      v39 = 0;
      v37 = 0u;
      v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
    *(_DWORD *)(v13 + 180) = 0;
    v15 = v14 - a2;
    if (v15 > a3 && a3 > 0)
      v15 = a3;
    *(_DWORD *)(v13 + 172) = v15;
    v17 = *(_QWORD *)v10;
    if (*(int *)(*(_QWORD *)v10 + 168) >= 1)
    {
      v18 = 0;
      v19 = 0;
      v20 = 0;
      do
      {
        v21 = v19 - a2;
        v22 = *(_QWORD *)(v17 + 312) + v18;
        if ((int)v19 - a2 >= *(_DWORD *)(v17 + 172))
          v21 = -1;
        *(_DWORD *)(v22 + 88) = v21;
        *(_QWORD *)(v22 + 96) = 0;
        v17 = *(_QWORD *)v10;
        if ((v21 & 0x80000000) == 0)
        {
          v23 = *(_QWORD *)(v17 + 312) + 104 * v20++;
          *(_QWORD *)(v23 + 96) = v22;
        }
        ++v19;
        v18 += 104;
      }
      while (v19 < *(int *)(v17 + 168));
    }
  }
  else
  {
    v24 = *(unsigned int *)(v13 + 168);
    *(_DWORD *)(v13 + 172) = v24;
    if ((int)v24 >= 1)
    {
      v25 = 0;
      v26 = *(_QWORD *)(v13 + 312);
      do
      {
        *(_DWORD *)(v26 + 88) = v25;
        *(_QWORD *)(v26 + 96) = v26;
        ++v25;
        v26 += 104;
      }
      while (v24 != v25);
    }
    if (a2 < 0 || (v27 = *(_DWORD *)(v13 + 176), v27 <= a2))
    {
      v39 = 0;
      v37 = 0u;
      v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
    v28 = v27 - a2;
    if (v28 > a3 && a3 > 0)
      v28 = a3;
    *(_DWORD *)(v13 + 180) = v28;
    v30 = *(_QWORD *)v10;
    if (*(int *)(*(_QWORD *)v10 + 176) >= 1)
    {
      v31 = 0;
      v32 = 0;
      v33 = 0;
      do
      {
        v34 = v32 - a2;
        v35 = *(_QWORD *)(v30 + 320) + v31;
        if ((int)v32 - a2 >= *(_DWORD *)(v30 + 180))
          v34 = -1;
        *(_DWORD *)(v35 + 16) = v34;
        *(_DWORD *)(v35 + 20) = 0;
        v30 = *(_QWORD *)v10;
        if ((v34 & 0x80000000) == 0)
        {
          v36 = *(_QWORD *)(v30 + 320) + 48 * v33++;
          *(_DWORD *)(v36 + 20) = v32;
        }
        ++v32;
        v31 += 48;
      }
      while (v32 < *(int *)(v30 + 176));
    }
  }
  return result;
}

void sub_187F18DFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F18E08()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_codestream::apply_input_restrictions(uint64_t a1, int a2, uint64_t a3, int a4, int a5, int *a6, int a7)
{
  uint64_t result;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  unsigned int v33;

  result = kdu_codestream::apply_input_restrictions(a1, 0, 0, a4, a5, a6, a7);
  if (a7 == 1)
  {
    v23 = *(_QWORD *)a1;
    v24 = *(_DWORD *)(*(_QWORD *)a1 + 168);
    if (v24 >= 1)
    {
      v25 = (_QWORD *)(*(_QWORD *)(v23 + 312) + 96);
      v26 = *(unsigned int *)(*(_QWORD *)a1 + 168);
      do
      {
        *v25 = 0;
        *((_DWORD *)v25 - 2) = -1;
        v25 += 13;
        --v26;
      }
      while (v26);
    }
    *(_DWORD *)(v23 + 172) = a2;
    if (a2 >= 1)
    {
      v27 = 0;
      v28 = 0;
      do
      {
        if (v27 < v24)
        {
          v29 = *(_DWORD *)(a3 + 4 * v27);
          if (v29 < v24)
          {
            v30 = *(_QWORD *)(v23 + 312);
            v31 = v30 + 104 * v29;
            v33 = *(_DWORD *)(v31 + 88);
            v32 = (_DWORD *)(v31 + 88);
            result = v33;
            if ((v33 & 0x80000000) != 0)
            {
              *v32 = v28;
              *(_QWORD *)(v30 + 104 * v28++ + 96) = v30 + 104 * v29;
            }
          }
        }
        ++v27;
      }
      while (a2 != v27);
    }
  }
  else
  {
    if (a7)
      kdu_codestream::apply_input_restrictions();
    v12 = *(_QWORD *)a1;
    v13 = *(_DWORD *)(*(_QWORD *)a1 + 176);
    if (v13 >= 1)
    {
      v14 = (_QWORD *)(*(_QWORD *)(v12 + 320) + 16);
      v15 = *(unsigned int *)(*(_QWORD *)a1 + 176);
      do
      {
        *v14 = 0xFFFFFFFFLL;
        v14 += 6;
        --v15;
      }
      while (v15);
    }
    *(_DWORD *)(v12 + 180) = a2;
    if (a2 >= 1)
    {
      v16 = 0;
      v17 = 0;
      do
      {
        if (v16 < v13)
        {
          v18 = *(_DWORD *)(a3 + 4 * v16);
          if (v18 < v13)
          {
            v19 = *(_QWORD *)(v12 + 320);
            v20 = v19 + 48 * v18;
            v22 = *(_DWORD *)(v20 + 16);
            v21 = (_DWORD *)(v20 + 16);
            result = v22;
            if ((v22 & 0x80000000) != 0)
            {
              *v21 = v17;
              *(_DWORD *)(v19 + 48 * v17++ + 20) = v18;
            }
          }
        }
        ++v16;
      }
      while (a2 != v16);
    }
  }
  return result;
}

uint64_t *kdu_codestream::change_appearance(uint64_t *this, char a2, char a3, char a4)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v4 = *this;
  if (*(_BYTE *)(*this + 419))
  {
    if (*(_DWORD *)(v4 + 260))
    {
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "You may change the apparent geometry of the code-stream only after closing all open tiles.");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    if (!*(_BYTE *)(v4 + 417))
    {
      v7 = 0;
      v5 = 0u;
      v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v5 + 16))(&v5, "You may not change the apparent geometry of the code-stream after the first tile access, unless the codestream object is set up to be persistent.");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
  }
  *(_BYTE *)(v4 + 409) = a2;
  *(_BYTE *)(v4 + 410) = a3;
  *(_BYTE *)(v4 + 411) = a4;
  return this;
}

void sub_187F190B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F190C4()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

int32x4_t *kdu_codestream::get_tile_dims(uint64_t *a1, uint64_t a2, unsigned int a3, int32x4_t *a4, int a5)
{
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v14;
  int v15;
  int v16;
  __int32 v17;
  __int32 v18;
  uint64_t v19;
  int v20;
  int v21;
  int **v22;
  int *v23;
  int v24;
  char *v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;

  v5 = *a1;
  if (*(_BYTE *)(*a1 + 411))
    v6 = -HIDWORD(a2);
  else
    v6 = HIDWORD(a2);
  if (*(_BYTE *)(*a1 + 410))
    v7 = -(int)a2;
  else
    v7 = a2;
  if (*(_BYTE *)(*a1 + 409))
    v8 = v7;
  else
    v8 = v6;
  if (*(_BYTE *)(*a1 + 409))
    v9 = v6;
  else
    v9 = v7;
  if (v8 < 0 || v8 >= *(_DWORD *)(v5 + 224) || v9 < 0 || v9 >= *(_DWORD *)(v5 + 220))
    kdu_codestream::get_tile_dims();
  *a4 = *(int32x4_t *)(v5 + 204);
  v14 = a4->i32[1] + a4->i32[3] * v8;
  a4->i32[0] += a4->i32[2] * v9;
  a4->i32[1] = v14;
  kdu_dims::operator&=(a4, (int *)(*a1 + 188));
  if (!*(_QWORD *)(*a1 + 16))
    kdu_dims::operator&=(a4, (int *)(*a1 + 264));
  v15 = a4->i32[0];
  v16 = a4->i32[1];
  v17 = a4->i32[2];
  v18 = a4->i32[3];
  if ((a3 & 0x80000000) != 0)
  {
    v20 = 1;
    v21 = 1;
    goto LABEL_28;
  }
  v19 = *a1;
  if (*(_BYTE *)(*a1 + 420))
  {
    if (!a5)
      goto LABEL_26;
  }
  else
  {
    kd_codestream::finalize_construction((kd_codestream *)v19);
    v19 = *a1;
    if (!a5)
      goto LABEL_26;
  }
  if (!*(_DWORD *)(v19 + 184))
  {
    v22 = (int **)(*(_QWORD *)(v19 + 320) + 48 * *(int *)(*(_QWORD *)(v19 + 320) + 48 * a3 + 20) + 8);
    goto LABEL_27;
  }
LABEL_26:
  v22 = (int **)(*(_QWORD *)(v19 + 312) + 104 * a3 + 96);
LABEL_27:
  v23 = *v22;
  v24 = *v23;
  v25 = (char *)v23 + *(int *)(v19 + 244);
  v20 = v23[1] << v25[21];
  v21 = v24 << v25[54];
LABEL_28:
  if (v20 <= 1)
    v26 = 1;
  else
    v26 = v20;
  if (v16 <= 0)
    v27 = -(int)(-v16 / v26);
  else
    v27 = (v16 - 1) / v26 + 1;
  v28 = v18 + v16;
  if (v21 <= 1)
    v29 = 1;
  else
    v29 = v21;
  if (v15 <= 0)
    v30 = -(int)(-v15 / v29);
  else
    v30 = (v15 - 1) / v29 + 1;
  v31 = v17 + v15;
  if (v28 <= 0)
    v32 = -(int)(-v28 / v26);
  else
    v32 = (v28 - 1) / v26 + 1;
  if (v31 <= 0)
    v33 = -(int)(-v31 / v29);
  else
    v33 = (v31 - 1) / v29 + 1;
  a4->i64[0] = v30 | (unint64_t)(v27 << 32);
  a4->i64[1] = (v33 - v30) | ((unint64_t)(v32 - v27) << 32);
  return kdu_dims::to_apparent(a4, *(unsigned __int8 *)(*a1 + 409), *(unsigned __int8 *)(*a1 + 410), *(unsigned __int8 *)(*a1 + 411));
}

uint64_t kdu_codestream::get_num_components(unsigned int **this, int a2)
{
  unsigned int *v2;
  unsigned int *v3;

  v2 = *this;
  if (a2 && !v2[46])
    v3 = v2 + 45;
  else
    v3 = v2 + 43;
  return *v3;
}

uint64_t kdu_codestream::get_bit_depth(kdu_codestream *this, unsigned int a2, int a3)
{
  uint64_t v3;
  unsigned int *v4;

  if ((a2 & 0x80000000) == 0)
  {
    v3 = *(_QWORD *)this;
    if (a3 && !*(_DWORD *)(v3 + 184))
    {
      if (*(_DWORD *)(v3 + 180) > (signed int)a2)
      {
        v4 = (unsigned int *)(*(_QWORD *)(v3 + 320) + 48 * *(int *)(*(_QWORD *)(v3 + 320) + 48 * a2 + 20));
        return *v4;
      }
    }
    else if (*(_DWORD *)(v3 + 172) > (signed int)a2)
    {
      v4 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(v3 + 312) + 104 * a2 + 96) + 16);
      return *v4;
    }
  }
  return 0;
}

BOOL kdu_codestream::get_signed(kdu_codestream *this, unsigned int a2, int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;

  if ((a2 & 0x80000000) == 0)
  {
    v3 = *(_QWORD *)this;
    if (a3 && !*(_DWORD *)(v3 + 184))
    {
      if (*(_DWORD *)(v3 + 180) > (signed int)a2)
      {
        v4 = (unsigned __int8 *)(*(_QWORD *)(v3 + 320) + 48 * *(int *)(*(_QWORD *)(v3 + 320) + 48 * a2 + 20) + 4);
        return *v4 != 0;
      }
    }
    else if (*(_DWORD *)(v3 + 172) > (signed int)a2)
    {
      v4 = (unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(v3 + 312) + 104 * a2 + 96) + 20);
      return *v4 != 0;
    }
  }
  return 0;
}

void kdu_codestream::get_subsampling(kd_codestream **a1, int a2, uint64_t a3, int a4)
{
  kd_codestream *v8;
  kd_codestream *v9;
  uint64_t **v10;
  uint64_t *v11;
  uint64_t v12;
  kd_codestream *v13;
  char *v14;
  int v15;
  int v16;
  int v17;

  v8 = *a1;
  if (*((_BYTE *)v8 + 420))
  {
    if (a2 < 0)
      goto LABEL_14;
  }
  else
  {
    kd_codestream::finalize_construction(v8);
    if (a2 < 0)
      goto LABEL_14;
  }
  v9 = *a1;
  if (!a4 || *((_DWORD *)v9 + 46))
  {
    if (*((_DWORD *)v9 + 43) > a2)
    {
      v10 = (uint64_t **)(*((_QWORD *)v9 + 39) + 104 * a2 + 96);
      goto LABEL_9;
    }
LABEL_14:
    *(_QWORD *)a3 = 0;
    return;
  }
  v17 = *((_DWORD *)v9 + 45);
  if (v17 >= 5 || v17 <= a2)
    goto LABEL_14;
  v10 = (uint64_t **)(*((_QWORD *)v9 + 40) + 48 * *(int *)(*((_QWORD *)v9 + 40) + 48 * a2 + 20) + 8);
LABEL_9:
  v11 = *v10;
  v12 = *v11;
  *(_QWORD *)a3 = *v11;
  v13 = *a1;
  v14 = (char *)v11 + *((int *)*a1 + 61);
  v15 = HIDWORD(v12) << v14[21];
  *(_DWORD *)(a3 + 4) = v15;
  v16 = (_DWORD)v12 << v14[54];
  *(_DWORD *)a3 = v16;
  if (*((_BYTE *)v13 + 409))
  {
    *(_DWORD *)a3 = v15;
    *(_DWORD *)(a3 + 4) = v16;
  }
}

void kdu_codestream::get_registration(kd_codestream **a1, unsigned int a2, uint64_t a3, int8x8_t *a4, int a5)
{
  kd_codestream *v10;
  kd_codestream *v11;
  int32x2_t **v12;
  int8x8_t v13;
  int8x8_t v19;
  int8x8_t v20;

  v10 = *a1;
  if (*((_BYTE *)v10 + 420))
  {
    if ((a2 & 0x80000000) != 0)
      goto LABEL_12;
  }
  else
  {
    kd_codestream::finalize_construction(v10);
    if ((a2 & 0x80000000) != 0)
      goto LABEL_12;
  }
  v11 = *a1;
  if (a5 && !*((_DWORD *)v11 + 46))
  {
    if (*((_DWORD *)v11 + 45) > (signed int)a2)
    {
      v12 = (int32x2_t **)(*((_QWORD *)v11 + 40) + 48 * *(int *)(*((_QWORD *)v11 + 40) + 48 * a2 + 20) + 8);
      goto LABEL_9;
    }
  }
  else if (*((_DWORD *)v11 + 43) > (signed int)a2)
  {
    v12 = (int32x2_t **)(*((_QWORD *)v11 + 39) + 104 * a2 + 96);
LABEL_9:
    v13 = (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(*((_BYTE *)v11 + 409) == 0), 0x1FuLL));
    __asm { FMOV            V2.2D, #0.5 }
    v19 = (int8x8_t)vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32((float32x2_t)vrev64_s32((*v12)[1]), vcvt_f32_s32((int32x2_t)vbsl_s8(v13, (int8x8_t)a3, (int8x8_t)vrev64_s32((int32x2_t)a3))))), _Q2))));
    LODWORD(_Q2.f64[0]) = *((unsigned __int8 *)v11 + 410);
    HIDWORD(_Q2.f64[0]) = *((unsigned __int8 *)v11 + 411);
    v20 = vbsl_s8(v13, v19, (int8x8_t)vrev64_s32((int32x2_t)v19));
    *a4 = vbsl_s8((int8x8_t)vceqz_s32(*(int32x2_t *)&_Q2.f64[0]), v20, (int8x8_t)vneg_s32((int32x2_t)v20));
    return;
  }
LABEL_12:
  *a4 = 0;
}

uint64_t kdu_codestream::get_min_dwt_levels(kdu_codestream *this)
{
  uint64_t v2;
  uint64_t result;
  kdu_params *v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v2 = *(_QWORD *)this;
  result = *(unsigned int *)(*(_QWORD *)this + 248);
  if ((int)result >= 33)
  {
    v8 = 0;
    v4 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(v2 + 24), "COD");
    v5 = kdu_params::get(v4, "Clevels", 0, 0, &v8, 1, 1, 1);
    v6 = *(_QWORD *)this;
    if ((v5 & 1) != 0)
    {
      v7 = v8;
      result = *(unsigned int *)(v6 + 248);
      if (v8 < (int)result)
      {
        *(_DWORD *)(v6 + 248) = v8;
        result = v7;
      }
    }
    else
    {
      result = *(unsigned int *)(v6 + 248);
    }
    if ((int)result >= 33)
    {
      result = 32;
      *(_DWORD *)(v6 + 248) = 32;
    }
  }
  return result;
}

BOOL kdu_codestream::can_flip(kdu_codestream *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (!*(_BYTE *)(*(_QWORD *)this + 280))
    return 1;
  if (*(_BYTE *)(v1 + 411))
    return 0;
  return *(_BYTE *)(v1 + 410) == 0;
}

uint64_t kdu_codestream::map_region(uint64_t *a1, unsigned int a2, unint64_t a3, unint64_t a4, uint64_t a5, int a6)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  _DWORD **v19;
  _DWORD *v20;
  char *v21;
  int v22;

  v8 = HIDWORD(a3);
  v9 = HIDWORD(a4);
  v10 = *a1;
  if (*(_BYTE *)(v10 + 411))
    LODWORD(v8) = 1 - (HIDWORD(a4) + HIDWORD(a3));
  if (*(_BYTE *)(v10 + 410))
    v11 = 1 - (a4 + a3);
  else
    v11 = a3;
  if (*(_BYTE *)(v10 + 409))
    v12 = a4;
  else
    v12 = HIDWORD(a4);
  if (*(_BYTE *)(v10 + 409))
  {
    v13 = v11;
  }
  else
  {
    LODWORD(v9) = a4;
    v13 = v8;
  }
  if (*(_BYTE *)(v10 + 409))
    v14 = v8;
  else
    v14 = v11;
  v15 = v13 + v12;
  v16 = v14 + v9;
  if ((a2 & 0x80000000) == 0)
  {
    if (*(_BYTE *)(v10 + 420))
    {
      if (!a6)
        goto LABEL_21;
    }
    else
    {
      kd_codestream::finalize_construction((kd_codestream *)v10);
      v10 = *a1;
      if (!a6)
        goto LABEL_21;
    }
    if (!*(_DWORD *)(v10 + 184))
    {
      v19 = (_DWORD **)(*(_QWORD *)(v10 + 320) + 48 * *(int *)(*(_QWORD *)(v10 + 320) + 48 * a2 + 20) + 8);
      goto LABEL_23;
    }
LABEL_21:
    v19 = (_DWORD **)(*(_QWORD *)(v10 + 312) + 104 * a2 + 96);
LABEL_23:
    v20 = *v19;
    v21 = (char *)v20 + *(int *)(v10 + 244);
    v22 = v20[1] << v21[21];
    v13 = (v22 * v13);
    LODWORD(v20) = *v20 << v21[54];
    v14 *= (_DWORD)v20;
    v15 *= v22;
    v16 *= (_DWORD)v20;
  }
  *(_QWORD *)a5 = v14 | (unint64_t)(v13 << 32);
  *(_QWORD *)(a5 + 8) = (v16 - v14) | ((unint64_t)(v15 - v13) << 32);
  return kdu_dims::operator&=((_DWORD *)a5, (int *)(*a1 + 188));
}

int32x4_t *kdu_codestream::get_valid_tiles(kdu_codestream *this, int32x4_t *a2)
{
  unsigned int v2;
  unsigned int v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  __int32 v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  __int32 v17;

  v2 = *(_DWORD *)(*(_QWORD *)this + 268) - *(_DWORD *)(*(_QWORD *)this + 208);
  v3 = *(_DWORD *)(*(_QWORD *)this + 264) - *(_DWORD *)(*(_QWORD *)this + 204);
  v4 = *(_DWORD *)(*(_QWORD *)this + 276);
  v5 = v4 + v2;
  v6 = *(_DWORD *)(*(_QWORD *)this + 216);
  if ((int)v6 <= 1)
    v6 = 1;
  if ((v2 & 0x80000000) != 0)
    v7 = ~(~v2 / v6);
  else
    v7 = v2 / v6;
  v8 = *(_DWORD *)(*(_QWORD *)this + 272);
  a2->i32[1] = v7;
  if (v5 <= 0)
    v9 = -(int)(-v5 / v6);
  else
    v9 = (v5 - 1) / v6 + 1;
  v10 = v8 + v3;
  v11 = v9 - v7;
  if (v4 <= 0)
    v12 = 0;
  else
    v12 = v11;
  a2->i32[3] = v12;
  v13 = *(_DWORD *)(*(_QWORD *)this + 212);
  if ((int)v13 <= 1)
    v13 = 1;
  if ((v3 & 0x80000000) != 0)
    v14 = ~(~v3 / v13);
  else
    v14 = v3 / v13;
  a2->i32[0] = v14;
  if (v10 <= 0)
    v15 = -(int)(-v10 / v13);
  else
    v15 = (v10 - 1) / v13 + 1;
  v16 = v15 - v14;
  if (v8 <= 0)
    v17 = 0;
  else
    v17 = v16;
  a2->i32[2] = v17;
  return kdu_dims::to_apparent(a2, *(unsigned __int8 *)(*(_QWORD *)this + 409), *(unsigned __int8 *)(*(_QWORD *)this + 410), *(unsigned __int8 *)(*(_QWORD *)this + 411));
}

uint64_t kdu_codestream::open_tile(uint64_t *a1, unint64_t a2, kdu_thread_entity *this)
{
  int v4;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t tile;
  _OWORD v17[2];
  uint64_t v18;

  v4 = a2;
  v6 = HIDWORD(a2);
  if (this)
    kdu_thread_entity::acquire_lock(this, 0, 1);
  v7 = *a1;
  *(_BYTE *)(v7 + 419) = 1;
  if (!*(_BYTE *)(v7 + 420))
  {
    kd_codestream::finalize_construction((kd_codestream *)v7);
    v7 = *a1;
  }
  if (*(_BYTE *)(v7 + 411))
    v8 = -(int)v6;
  else
    v8 = v6;
  if (*(_BYTE *)(v7 + 410))
    LODWORD(v9) = -v4;
  else
    LODWORD(v9) = v4;
  if (*(_BYTE *)(v7 + 409))
    v10 = v9;
  else
    v10 = v8;
  if (*(_BYTE *)(v7 + 409))
    v9 = v8;
  else
    v9 = v9;
  if ((v10 & 0x80000000) != 0
    || (int)v10 >= *(_DWORD *)(v7 + 224)
    || (v9 & 0x80000000) != 0
    || (int)v9 >= *(_DWORD *)(v7 + 220))
  {
    kdu_codestream::open_tile();
  }
  v11 = v10 - *(_DWORD *)(v7 + 232);
  if ((v11 & 0x80000000) != 0
    || (v12 = v9 - *(_DWORD *)(v7 + 228), v12 < 0)
    || (v13 = *(_DWORD *)(v7 + 240), v13 <= (int)v11)
    || *(_DWORD *)(v7 + 236) <= v12)
  {
    kdu_codestream::open_tile();
  }
  v14 = *(_QWORD *)(v7 + 328) + 24 * v11 + 24 * v13 * v12;
  tile = *(_QWORD *)(v14 + 16);
  if (tile == -1)
    goto LABEL_34;
  if (tile)
  {
    if (*(_BYTE *)(tile + 293))
    {
      if (!*(_BYTE *)(v7 + 408) || *(_QWORD *)v14)
        kdu_codestream::open_tile();
      kd_tile::reinitialize(*(kd_tile **)(v14 + 16));
    }
  }
  else
  {
    tile = kd_codestream::create_tile(v7, v9 | (v10 << 32));
  }
  if (tile == -1 || *(_BYTE *)(tile + 291))
  {
LABEL_34:
    v18 = 0;
    memset(v17, 0, sizeof(v17));
    kdu_error::kdu_error((kdu_error *)v17, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v17[0] + 16))(v17, "Attempting to access a tile which has already been discarded or closed!");
    kdu_error::~kdu_error((kdu_error *)v17);
  }
  if (*(_QWORD *)(tile + 24) != v14)
    kdu_codestream::open_tile();
  kd_tile::open((kd_tile *)tile);
  if (this)
    kdu_thread_entity::release_lock(this, 0);
  return tile;
}

void sub_187F19B04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F19B10()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void kdu_codestream::flush(uint64_t *a1, _QWORD *a2, unsigned int a3, __int16 *a4, int a5, int a6, kdu_thread_entity *this, double a8)
{
  kdu_thread_entity *v8;
  signed int v16;
  uint64_t v17;
  _WORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  BOOL v25;
  char v26;
  uint64_t v27;
  __int16 *v28;
  __int16 v29;
  kdu_thread_entity *v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  _BOOL4 v41;
  uint64_t v42;
  uint64_t v43;
  __int16 *v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51[2];
  __int128 v52;
  uint64_t v53;

  v8 = this;
  if (this)
    kdu_thread_entity::acquire_lock(this, 0, 1);
  v16 = a3 - 1;
  if ((int)a3 < 1 || (v17 = *a1, !*(_QWORD *)(*a1 + 16)))
    kdu_codestream::flush();
  if (!*(_BYTE *)(v17 + 420))
  {
    kd_codestream::finalize_construction((kd_codestream *)v17);
    v17 = *a1;
  }
  v18 = *(_WORD **)(v17 + 384);
  if (*(_QWORD *)(v17 + 376))
  {
    if (!v18 || !*(_QWORD *)(v17 + 368))
      kdu_codestream::flush();
    if (*(_DWORD *)(v17 + 364) != a3)
    {
      v53 = 0;
      *(_OWORD *)v51 = 0u;
      v52 = 0u;
      kdu_error::kdu_error((kdu_error *)v51, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v51);
    }
  }
  else
  {
    if (v18 || *(_QWORD *)(v17 + 368))
      kdu_codestream::flush();
    *(_DWORD *)(v17 + 364) = a3;
    *(_QWORD *)(*a1 + 368) = operator new[]();
    *(_QWORD *)(*a1 + 376) = operator new[]();
    v18 = (_WORD *)operator new[]();
    v19 = 0;
    v17 = *a1;
    *(_QWORD *)(v17 + 384) = v18;
    v20 = *(_QWORD *)(v17 + 368);
    v21 = *(_QWORD *)(v17 + 376);
    do
    {
      *(_QWORD *)(v20 + 8 * v19) = 0;
      if (a2)
        v22 = a2[v19];
      else
        v22 = 0;
      *(_QWORD *)(v21 + 8 * v19) = v22;
      if (a4)
        v23 = a4[v19];
      else
        v23 = 0;
      v18[v19++] = v23;
    }
    while (a3 != v19);
  }
  v24 = (unsigned __int16)*v18;
  if (*v18)
    v25 = 0;
  else
    v25 = *(_QWORD *)(*(_QWORD *)(v17 + 376) + 8 * v16) == 0;
  v26 = !v25;
  if (a4 && *v18 && *a4)
  {
    v27 = a3;
    v28 = a4;
    do
    {
      v29 = *v28++;
      *v18++ = v29;
      --v27;
    }
    while (v27);
  }
  *(_DWORD *)(v17 + 432) = 0;
  if (a6 && !*(_BYTE *)(v17 + 422) && *(_BYTE *)(v17 + 281))
    kd_codestream::set_reserved_layer_info_bytes(v17, a3);
  v50 = v16;
  if (v24)
  {
    v30 = v8;
    v31 = v26;
    v32 = 0;
    v33 = 0;
    v51[0] = 0;
    v34 = *a1;
    do
    {
      v33 += kd_codestream::simulate_output((kdu_params **)v34, v51, v32, *(unsigned __int16 *)(*(_QWORD *)(v34 + 384) + 2 * v32), 1, a3 - 1 == v32, 0x10000000000000, 0);
      v34 = *a1;
      *(_QWORD *)(*(_QWORD *)(*a1 + 376) + 8 * v32++) = v33;
    }
    while (a3 != v32);
    v26 = v31;
    v8 = v30;
  }
  else
  {
    v35 = *a1;
    if (a5)
    {
      v36 = *(_DWORD *)(v35 + 168);
      if (v36 < 1)
      {
        v41 = 1;
      }
      else
      {
        v37 = 33 * v36;
        v38 = (uint64_t *)(*(_QWORD *)(v35 + 352) + 64);
        do
        {
          v39 = *v38;
          v40 = *(v38 - 3);
          v41 = *v38 >= v40;
          if (v37 < 2)
            break;
          --v37;
          v38 += 11;
        }
        while (v39 >= v40);
      }
    }
    else
    {
      v41 = 0;
    }
    kd_codestream::pcrd_opt((kd_codestream *)v35, v41, a8);
  }
  v42 = *a1;
  if (*(_DWORD *)(*a1 + 432) && *(_BYTE *)(v42 + 281) && !*(_BYTE *)(v42 + 422))
  {
    kd_codestream::gen_layer_info_comment(v42, a3, *(uint64_t **)(v42 + 376), *(unsigned __int16 **)(v42 + 384));
    v42 = *a1;
  }
  kd_codestream::generate_codestream((kd_codestream *)v42, a3);
  v43 = a3;
  if (a4)
  {
    v44 = *(__int16 **)(*a1 + 384);
    v45 = a3;
    do
    {
      v46 = *v44++;
      *a4++ = v46;
      --v45;
    }
    while (v45);
  }
  if (a2)
  {
    v47 = 0;
    v48 = *(uint64_t **)(*a1 + 368);
    do
    {
      v49 = *v48++;
      v47 += v49;
      *a2++ = v47;
      --v43;
    }
    while (v43);
  }
  if (!v24)
  {
    bzero(*(void **)(*a1 + 384), 2 * a3);
    if ((v26 & 1) == 0)
      *(_QWORD *)(*(_QWORD *)(*a1 + 376) + 8 * v50) = 0;
  }
  if (v8)
    kdu_thread_entity::release_lock(v8, 0);
}

void sub_187F19EFC(uint64_t a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F19F08()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_codestream::ready_for_flush(uint64_t *a1, kdu_thread_entity *this)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  v2 = *a1;
  if (!*a1 || !*(_QWORD *)(v2 + 16))
    return 0;
  if (this)
  {
    kdu_thread_entity::acquire_lock(this, 0, 1);
    v2 = *a1;
  }
  v5 = *(_QWORD *)(v2 + 336);
  if (!v5)
  {
LABEL_18:
    if (this)
      kdu_thread_entity::release_lock(this, 0);
    return 0;
  }
  while (1)
  {
    v9 = 0;
    v10 = 0;
    v6 = kd_packet_sequencer::next_in_sequence(*(uint64_t **)(v5 + 96), &v10, &v9);
    if (v6)
      break;
LABEL_17:
    v5 = *(_QWORD *)(v5 + 40);
    if (!v5)
      goto LABEL_18;
  }
  v7 = *v6;
  if (!*v6)
    goto LABEL_12;
  if (v7 == 3)
    goto LABEL_24;
  if ((v7 & 1) != 0)
  {
LABEL_12:
    v7 = kd_precinct_ref::instantiate_precinct(v6, v10, v9);
    if (!v7)
LABEL_24:
      kdu_codestream::ready_for_flush();
  }
  else
  {
    if (*(_BYTE *)(v7 + 20))
    {
      kd_precinct_size_class::withdraw_from_inactive_list(*(_QWORD *)(v7 + 72), (kd_precinct *)v7);
    }
    else if (!*(_BYTE *)(v7 + 19))
    {
      goto LABEL_16;
    }
    kd_precinct::activate(v7);
  }
LABEL_16:
  if (*(_DWORD *)(v7 + 36))
    goto LABEL_17;
  if (this)
    kdu_thread_entity::release_lock(this, 0);
  return 1;
}

void kd_compressed_input::~kd_compressed_input(kd_compressed_input *this)
{
  *(_QWORD *)this = off_1E1BB2F10;
}

{
  *(_QWORD *)this = off_1E1BB2F10;
  JUMPOUT(0x18D761C30);
}

void kd_compressed_output::~kd_compressed_output(kd_compressed_output *this)
{
  kd_compressed_output::~kd_compressed_output(this);
  JUMPOUT(0x18D761C30);
}

{
  *(_QWORD *)this = &off_1E1BB2150;
  kd_compressed_output::flush_buf((uint64_t)this);
  *(_QWORD *)this = off_1E1BAB9F0;
}

uint64_t kd_compressed_output::flush_buf(uint64_t this)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;

  v1 = this;
  v2 = *(_QWORD *)(this + 520);
  v3 = this + 8;
  if (v2 > this + 8)
  {
    this = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(this + 536) + 40))(*(_QWORD *)(this + 536), v3, (v2 - v3));
    v2 = *(_QWORD *)(v1 + 520);
  }
  *(_QWORD *)(v1 + 544) += v2 - v3;
  *(_QWORD *)(v1 + 520) = v3;
  return this;
}

void kd_precinct_server::~kd_precinct_server(kd_precinct_size_class **this)
{
  kd_precinct_size_class *v2;

  v2 = *this;
  if (v2)
  {
    do
    {
      *this = (kd_precinct_size_class *)*((_QWORD *)v2 + 5);
      kd_precinct_size_class::~kd_precinct_size_class(v2);
      MEMORY[0x18D761C30]();
      v2 = *this;
    }
    while (*this);
  }
}

void kd_precinct_size_class::~kd_precinct_size_class(kd_precinct_size_class *this)
{
  _QWORD *i;

  for (i = (_QWORD *)*((_QWORD *)this + 4); i; i = (_QWORD *)*((_QWORD *)this + 4))
  {
    *((_QWORD *)this + 4) = i[7];
    free(i);
    --*((_DWORD *)this + 7);
  }
}

void _cg_jinit_d_coef_controller(uint64_t a1, int a2)
{
  uint64_t (**v4)(uint64_t);
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  int64x2_t v15;
  int64x2_t v16;
  int64x2_t v17;

  v4 = (uint64_t (**)(uint64_t))(**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 592) = v4;
  *v4 = start_input_pass;
  v4[2] = start_output_pass;
  v4[27] = 0;
  if (a2)
  {
    if (*(int *)(a1 + 56) >= 1)
    {
      v5 = 0;
      v6 = (unsigned int *)(*(_QWORD *)(a1 + 304) + 28);
      do
      {
        v7 = *(v6 - 4);
        if (*(_DWORD *)(a1 + 316))
          v8 = 3 * v7;
        else
          v8 = v7;
        v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 40);
        v10 = _cg_jround_up(*v6, (int)*(v6 - 5));
        v11 = _cg_jround_up(v6[1], (int)*(v6 - 4));
        v4[v5++ + 17] = (uint64_t (*)(uint64_t))v9(a1, 1, 1, v10, v11, v8);
        v6 += 24;
      }
      while (v5 < *(int *)(a1 + 56));
    }
    v4[1] = consume_data;
    v4[3] = (uint64_t (*)(uint64_t))decompress_data;
    v12 = (uint64_t (*)(uint64_t))(v4 + 17);
  }
  else
  {
    v13 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 8) + 8))(a1, 1, 1280);
    v14 = 0;
    v15 = (int64x2_t)xmmword_18820C490;
    v16 = vdupq_n_s64((unint64_t)v13);
    v17 = vdupq_n_s64(2uLL);
    do
    {
      *(int64x2_t *)&v4[v14 + 7] = vaddq_s64(v16, vshlq_n_s64(v15, 7uLL));
      v15 = vaddq_s64(v15, v17);
      v14 += 2;
    }
    while (v14 != 10);
    if (!*(_DWORD *)(a1 + 568))
      bzero(v13, 0x500uLL);
    v12 = 0;
    v4[1] = (uint64_t (*)(uint64_t))dummy_consume_data;
    v4[3] = (uint64_t (*)(uint64_t))decompress_onepass;
  }
  v4[4] = v12;
}

uint64_t start_input_pass(uint64_t result)
{
  *(_DWORD *)(result + 176) = 0;
  return start_iMCU_row(result);
}

uint64_t start_output_pass(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  _WORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t (*v11)(uint64_t, uint64_t);

  v1 = result;
  v2 = *(_QWORD **)(result + 592);
  if (v2[4])
  {
    if (*(_DWORD *)(result + 104) && *(_DWORD *)(result + 316) && *(_QWORD *)(result + 192))
    {
      result = v2[27];
      if (!result)
      {
        result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(v1 + 8))(v1, 1, 24 * *(int *)(v1 + 56));
        v2[27] = result;
      }
      if (*(int *)(v1 + 56) >= 1)
      {
        v3 = 0;
        v4 = 0;
        v5 = 0;
        v6 = *(_QWORD *)(v1 + 304);
        while (1)
        {
          v7 = *(_WORD **)(v6 + 80);
          if (!v7)
            break;
          if (!*v7)
            break;
          if (!v7[1])
            break;
          if (!v7[8])
            break;
          if (!v7[16])
            break;
          if (!v7[9])
            break;
          if (!v7[2])
            break;
          v8 = *(_QWORD *)(v1 + 192);
          if ((*(_DWORD *)(v8 + (v4 << 8)) & 0x80000000) != 0)
            break;
          v9 = v8 + v3;
          for (i = 4; i != 24; i += 4)
          {
            *(_DWORD *)(result + i) = *(_DWORD *)(v9 + i);
            if (*(_DWORD *)(v9 + i))
              v5 = 1;
          }
          result += 24;
          ++v4;
          v6 += 96;
          v3 += 256;
          if (v4 >= *(int *)(v1 + 56))
          {
            if (!v5)
              break;
            v11 = decompress_smooth_data;
            goto LABEL_25;
          }
        }
      }
    }
    v11 = decompress_data;
LABEL_25:
    v2[3] = v11;
  }
  *(_DWORD *)(v1 + 184) = 0;
  return result;
}

uint64_t consume_data(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  int v18;
  uint64_t result;
  unsigned int v20;
  _OWORD v21[2];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD **)(a1 + 592);
  memset(v21, 0, sizeof(v21));
  if (*(int *)(a1 + 448) >= 1)
  {
    v3 = 0;
    do
    {
      *((_QWORD *)v21 + v3) = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 8)
                                                                                                  + 64))(a1, *(_QWORD *)&v2[2 * *(int *)(*(_QWORD *)(a1 + 8 * v3 + 456) + 4) + 34], (*(_DWORD *)(*(_QWORD *)(a1 + 8 * v3 + 456) + 12) * *(_DWORD *)(a1 + 176)), *(unsigned int *)(*(_QWORD *)(a1 + 8 * v3 + 456) + 12), 1);
      ++v3;
    }
    while (v3 < *(int *)(a1 + 448));
  }
  v4 = v2[12];
  v5 = (int)v2[11];
  if ((int)v5 >= v4)
  {
LABEL_20:
    v20 = *(_DWORD *)(a1 + 176) + 1;
    *(_DWORD *)(a1 + 176) = v20;
    if (v20 >= *(_DWORD *)(a1 + 432))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 608) + 24))(a1);
      return 4;
    }
    else
    {
      start_iMCU_row(a1);
      return 3;
    }
  }
  else
  {
    v6 = v2[10];
    v7 = *(_DWORD *)(a1 + 488);
    while (v6 >= v7)
    {
LABEL_19:
      v6 = 0;
      v2[10] = 0;
      if (++v5 >= v4)
        goto LABEL_20;
    }
    while (1)
    {
      v8 = *(unsigned int *)(a1 + 448);
      if ((int)v8 >= 1)
      {
        v9 = 0;
        v10 = 0;
        do
        {
          v11 = *(_QWORD *)(a1 + 8 * v9 + 456);
          v12 = *(unsigned int *)(v11 + 60);
          if ((int)v12 >= 1)
          {
            v13 = 0;
            v14 = *(_DWORD *)(v11 + 56);
            v15 = *((_QWORD *)v21 + v9);
            do
            {
              if (v14 >= 1)
              {
                v16 = *(_QWORD *)(v15 + 8 * (v13 + v5)) + ((unint64_t)(v14 * v6) << 7);
                v17 = (unint64_t *)&v2[2 * v10 + 14];
                v10 += v14;
                v18 = v14;
                do
                {
                  *v17++ = v16;
                  v16 += 128;
                  --v18;
                }
                while (v18);
              }
              ++v13;
            }
            while (v13 != v12);
          }
          ++v9;
        }
        while (v9 != v8);
      }
      result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)(a1 + 624) + 8))(a1, v2 + 14);
      if (!(_DWORD)result)
        break;
      ++v6;
      v7 = *(_DWORD *)(a1 + 488);
      if (v6 >= v7)
      {
        v4 = v2[12];
        goto LABEL_19;
      }
    }
    v2[10] = v6;
    v2[11] = v5;
  }
  return result;
}

uint64_t decompress_data(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;
  uint64_t result;
  _DWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, _DWORD *, uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;

  v19 = *(_QWORD *)(a1 + 592);
  v18 = *(_DWORD *)(a1 + 432) - 1;
  while (1)
  {
    v3 = *(_DWORD *)(a1 + 172);
    v4 = *(_DWORD *)(a1 + 180);
    if (v3 >= v4 && (v3 != v4 || *(_DWORD *)(a1 + 176) > *(_DWORD *)(a1 + 184)))
      break;
    result = (**(uint64_t (***)(uint64_t))(a1 + 608))(a1);
    if (!(_DWORD)result)
      return result;
  }
  if (*(int *)(a1 + 56) >= 1)
  {
    v20 = 0;
    v6 = *(_DWORD **)(a1 + 304);
    do
    {
      if (v6[13])
      {
        v7 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 8) + 64))(a1, *(_QWORD *)(v19 + 8 * v20 + 136), (v6[3] * *(_DWORD *)(a1 + 184)), v6[3], 0);
        if (*(_DWORD *)(a1 + 184) >= v18)
          v8 = v6[8] == (v6[8] / v6[3]) * (unint64_t)v6[3]
             ? v6[3]
             : v6[8] - (v6[8] / v6[3]) * (unint64_t)v6[3];
        else
          v8 = v6[3];
        if ((int)v8 >= 1)
        {
          v9 = 0;
          v10 = *(void (**)(uint64_t, _DWORD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 632) + 8 * v20 + 8);
          v11 = *(_QWORD *)(a2 + 8 * v20);
          v12 = v6[7];
          do
          {
            if (v12)
            {
              v13 = 0;
              v14 = 0;
              v15 = *(_QWORD *)(v7 + 8 * v9);
              do
              {
                v10(a1, v6, v15, v11, v13);
                v15 += 128;
                v13 = (v6[9] + v13);
                ++v14;
                v12 = v6[7];
              }
              while (v14 < v12);
            }
            v11 += 8 * (int)v6[10];
            ++v9;
          }
          while (v9 != v8);
        }
      }
      v6 += 24;
      ++v20;
    }
    while (v20 < *(int *)(a1 + 56));
  }
  v16 = *(_DWORD *)(a1 + 184) + 1;
  *(_DWORD *)(a1 + 184) = v16;
  if (v16 < *(_DWORD *)(a1 + 432))
    return 3;
  else
    return 4;
}

uint64_t dummy_consume_data()
{
  return 0;
}

uint64_t decompress_onepass(uint64_t a1, uint64_t a2)
{
  _DWORD *v3;
  unsigned int v4;
  int v5;
  void **v6;
  unsigned int v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  int v11;
  int *v12;
  int v13;
  int v14;
  uint64_t v15;
  void (*v16)(uint64_t, int *, uint64_t, uint64_t, uint64_t);
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  void **v23;
  void **v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  _DWORD *v29;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  int v38;

  v3 = *(_DWORD **)(a1 + 592);
  v4 = *(_DWORD *)(a1 + 432);
  v5 = v3[12];
  v34 = v3[11];
  if (v34 < v5)
  {
    v32 = *(_DWORD *)(a1 + 488) - 1;
    v37 = v4 - 1;
    v6 = (void **)(v3 + 14);
    v7 = v3[10];
    v29 = *(_DWORD **)(a1 + 592);
    while (1)
    {
      if (v7 > v32)
        goto LABEL_33;
      do
      {
        if (*(_DWORD *)(a1 + 568))
          bzero(*v6, (uint64_t)*(int *)(a1 + 496) << 7);
        result = (*(uint64_t (**)(uint64_t, void **))(*(_QWORD *)(a1 + 624) + 8))(a1, v6);
        if (!(_DWORD)result)
        {
          v29[10] = v7;
          v29[11] = v34;
          return result;
        }
        v9 = *(_DWORD *)(a1 + 448);
        if (v9 >= 1)
        {
          v10 = 0;
          v11 = 0;
          v31 = v7;
          while (1)
          {
            v12 = *(int **)(a1 + 8 * v10 + 456);
            if (v12[13])
              break;
            v11 += v12[16];
LABEL_30:
            if (++v10 >= v9)
              goto LABEL_31;
          }
          v13 = v12[15];
          if (v13 < 1)
            goto LABEL_30;
          v33 = v10;
          v14 = 0;
          v15 = v12[1];
          v16 = *(void (**)(uint64_t, int *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 632) + 8 * v15 + 8);
          v17 = 18;
          if (v7 < v32)
            v17 = 14;
          v18 = v12[v17];
          v36 = v12[17] * v7;
          v19 = v12[10];
          v20 = *(_QWORD *)(a2 + 8 * v15) + 8 * v19 * v34;
          v38 = v18;
          if (v18 <= 1)
            v21 = 1;
          else
            v21 = v18;
          v35 = v21;
          while (2)
          {
            if (*(_DWORD *)(a1 + 176) >= v37)
            {
              if (v14 + v34 < v12[19] && v38 >= 1)
                goto LABEL_24;
            }
            else
            {
              if (v38 < 1)
                goto LABEL_27;
LABEL_24:
              v23 = v6;
              v24 = &v6[v11];
              v25 = v35;
              v26 = v36;
              do
              {
                v27 = (uint64_t)*v24++;
                v16(a1, v12, v27, v20, v26);
                v26 = (v12[9] + v26);
                --v25;
              }
              while (v25);
              v19 = v12[10];
              v13 = v12[15];
              v6 = v23;
            }
LABEL_27:
            v11 += v12[14];
            v20 += 8 * v19;
            if (++v14 >= v13)
            {
              v9 = *(_DWORD *)(a1 + 448);
              v7 = v31;
              v10 = v33;
              goto LABEL_30;
            }
            continue;
          }
        }
LABEL_31:
        ++v7;
      }
      while (v7 <= v32);
      v3 = v29;
      v5 = v29[12];
LABEL_33:
      v7 = 0;
      v3[10] = 0;
      if (++v34 >= v5)
      {
        v4 = *(_DWORD *)(a1 + 432);
        break;
      }
    }
  }
  ++*(_DWORD *)(a1 + 184);
  v28 = *(_DWORD *)(a1 + 176) + 1;
  *(_DWORD *)(a1 + 176) = v28;
  if (v28 >= v4)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 608) + 24))(a1);
    return 4;
  }
  else
  {
    start_iMCU_row(a1);
    return 3;
  }
}

uint64_t start_iMCU_row(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v3;

  v1 = *(_QWORD *)(result + 592);
  if (*(int *)(result + 448) < 2)
  {
    v3 = *(_QWORD *)(result + 456);
    if (*(_DWORD *)(result + 176) >= (*(_DWORD *)(result + 432) - 1))
      v2 = *(_DWORD *)(v3 + 76);
    else
      v2 = *(_DWORD *)(v3 + 12);
  }
  else
  {
    v2 = 1;
  }
  *(_DWORD *)(v1 + 48) = v2;
  *(_QWORD *)(v1 + 40) = 0;
  return result;
}

uint64_t decompress_smooth_data(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t result;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int16 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  __int16 *v23;
  __int16 *v24;
  __int16 *v25;
  uint64_t v26;
  unsigned int v27;
  __int16 *v28;
  int v29;
  int v30;
  __int16 *v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  BOOL v38;
  uint64_t v39;
  unint64_t v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  unint64_t v52;
  int v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  unint64_t v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t v63;
  unint64_t v64;
  int v65;
  int v66;
  int v67;
  unsigned int v68;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  int v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  _DWORD *v90;
  int v91;
  int v92;
  void (*v93)(uint64_t, uint64_t, __int128 *, uint64_t, uint64_t);
  uint64_t v94;
  uint64_t v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  __int128 __dst;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;

  v2 = a1;
  v110 = *MEMORY[0x1E0C80C00];
  v70 = *(_QWORD *)(a1 + 592);
  v76 = *(_DWORD *)(a1 + 432) - 1;
  v108 = 0u;
  v109 = 0u;
  v106 = 0u;
  v107 = 0u;
  v104 = 0u;
  v105 = 0u;
  __dst = 0u;
  v103 = 0u;
  while (1)
  {
    v3 = *(_DWORD *)(v2 + 172);
    v4 = *(_DWORD *)(v2 + 180);
    if (v3 > v4)
      break;
    v5 = *(_QWORD *)(v2 + 608);
    if (*(_DWORD *)(v5 + 36))
      break;
    if (v3 == v4)
    {
      v6 = *(_DWORD *)(v2 + 184);
      if (!*(_DWORD *)(v2 + 540))
        ++v6;
      if (*(_DWORD *)(v2 + 176) > v6)
        break;
    }
    result = (*(uint64_t (**)(uint64_t))v5)(v2);
    if (!(_DWORD)result)
      return result;
  }
  if (*(int *)(v2 + 56) >= 1)
  {
    v71 = 0;
    v8 = *(_QWORD *)(v2 + 304);
    v89 = v2;
    while (!*(_DWORD *)(v8 + 52))
    {
LABEL_116:
      v8 += 96;
      if (++v71 >= *(int *)(v2 + 56))
        goto LABEL_117;
    }
    v9 = *(_DWORD *)(v2 + 184);
    if (v9 < v76)
    {
      v10 = *(_DWORD *)(v8 + 12);
      v13 = 2 * v10;
      LODWORD(v12) = v10;
      if (v9)
      {
LABEL_18:
        v14 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(v2 + 8) + 64))(v2, *(_QWORD *)(v70 + 8 * v71 + 136), v10 * (v9 - 1), v10 + v13, 0)+ 8 * *(int *)(v8 + 12);
        goto LABEL_21;
      }
    }
    else
    {
      v10 = *(_DWORD *)(v8 + 12);
      v11 = *(_DWORD *)(v8 + 32) % v10;
      if (v11)
        v12 = v11;
      else
        v12 = v10;
      v13 = v12;
      if (v9)
        goto LABEL_18;
    }
    v14 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(v2 + 8) + 64))(v2, *(_QWORD *)(v70 + 8 * v71 + 136), 0, v13, 0);
LABEL_21:
    v72 = (v12 - 1);
    if ((int)v12 >= 1)
    {
      v15 = 0;
      v93 = *(void (**)(uint64_t, uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)(v2 + 632) + 8 * v71 + 8);
      v95 = *(_QWORD *)(a2 + 8 * v71);
      v16 = *(unsigned __int16 **)(v8 + 80);
      v17 = v16[2];
      v18 = v16[9];
      v19 = v16[16];
      v90 = (_DWORD *)(*(_QWORD *)(v70 + 216) + 4 * (6 * v71));
      v20 = v16[8];
      v21 = *v16;
      v22 = v16[1];
      v92 = 9 * v21;
      v91 = 36 * v21;
      v87 = v22 << 8;
      v88 = v22 << 7;
      v86 = v20 << 7;
      v85 = v20 << 8;
      v83 = v19 << 8;
      v84 = v19 << 7;
      v81 = v18 << 7;
      v82 = 5 * v21;
      v79 = v17 << 7;
      v80 = v18 << 8;
      v78 = v17 << 8;
      v73 = v12;
      v74 = v14;
      v94 = v8;
      v75 = v9;
      do
      {
        v23 = *(__int16 **)(v14 + 8 * v15);
        v24 = v23;
        if (v9 | v15)
          v24 = *(__int16 **)(v14 + 8 * v15 - 8);
        if (v9 < v76 || (v25 = *(__int16 **)(v14 + 8 * v15), v15 != v72))
          v25 = *(__int16 **)(v14 + 8 * v15 + 8);
        v77 = v15;
        v26 = 0;
        v27 = 0;
        v30 = *v24;
        v28 = v24 + 64;
        v29 = v30;
        v33 = *v25;
        v31 = v25 + 64;
        v32 = v33;
        v34 = *(_DWORD *)(v8 + 28) - 1;
        v35 = v33;
        v99 = *v23;
        v101 = v99;
        v98 = v29;
        v100 = v29;
        do
        {
          v97 = v100;
          v100 = v98;
          v36 = v101;
          v101 = v99;
          v96 = v35;
          v35 = v32;
          _cg_jcopy_block_row(v23, &__dst, 1u);
          if (v27 < v34)
          {
            v98 = *v28;
            v99 = v23[64];
            v32 = *v31;
          }
          v37 = v90[1];
          if (v37)
            v38 = WORD1(__dst) == 0;
          else
            v38 = 0;
          if (v38)
          {
            v39 = v91 * (uint64_t)(v36 - v99);
            v40 = (v88 - v39) / v87;
            if (1 << v37 <= (int)v40)
              v41 = (1 << v37) - 1;
            else
              v41 = (v88 - v39) / v87;
            if (v37 > 0)
              LODWORD(v40) = v41;
            if (1 << v37 <= (int)((v39 + v88) / v87))
              v42 = (1 << v37) - 1;
            else
              LOWORD(v42) = (v39 + v88) / v87;
            if (v37 >= 1)
              LOWORD(v43) = v42;
            else
              LOWORD(v43) = (v39 + v88) / v87;
            if (v39 < 0)
              v43 = -(int)v40;
            WORD1(__dst) = v43;
          }
          v44 = v90[2];
          if (v44 && !(_WORD)v103)
          {
            v45 = v91 * (uint64_t)(v100 - v35);
            v46 = (v86 - v45) / v85;
            if (1 << v44 <= (int)v46)
              v47 = (1 << v44) - 1;
            else
              v47 = (v86 - v45) / v85;
            if (v44 > 0)
              LODWORD(v46) = v47;
            if (1 << v44 <= (int)((v45 + v86) / v85))
              v48 = (1 << v44) - 1;
            else
              LOWORD(v48) = (v45 + v86) / v85;
            if (v44 >= 1)
              LOWORD(v49) = v48;
            else
              LOWORD(v49) = (v45 + v86) / v85;
            if (v45 < 0)
              v49 = -(int)v46;
            LOWORD(v103) = v49;
          }
          v50 = v90[3];
          if (v50 && !(_WORD)v104)
          {
            v51 = v92 * (uint64_t)(v100 - 2 * v101 + v35);
            v52 = (v84 - v51) / v83;
            if (1 << v50 <= (int)v52)
              v53 = (1 << v50) - 1;
            else
              v53 = (v84 - v51) / v83;
            if (v50 > 0)
              LODWORD(v52) = v53;
            if (1 << v50 <= (int)((v51 + v84) / v83))
              v54 = (1 << v50) - 1;
            else
              LOWORD(v54) = (v51 + v84) / v83;
            if (v50 >= 1)
              LOWORD(v55) = v54;
            else
              LOWORD(v55) = (v51 + v84) / v83;
            if (v51 < 0)
              v55 = -(int)v52;
            LOWORD(v104) = v55;
          }
          v56 = v90[4];
          if (v56 && !WORD1(v103))
          {
            v57 = v82 * (uint64_t)(v97 - (v96 + v98) + v32);
            v58 = (v81 - v57) / v80;
            if (1 << v56 <= (int)v58)
              v59 = (1 << v56) - 1;
            else
              v59 = (v81 - v57) / v80;
            if (v56 > 0)
              LODWORD(v58) = v59;
            if (1 << v56 <= (int)((v57 + v81) / v80))
              v60 = (1 << v56) - 1;
            else
              LOWORD(v60) = (v57 + v81) / v80;
            if (v56 >= 1)
              LOWORD(v61) = v60;
            else
              LOWORD(v61) = (v57 + v81) / v80;
            if (v57 < 0)
              v61 = -(int)v58;
            WORD1(v103) = v61;
          }
          v62 = v90[5];
          if (v62 && !WORD2(__dst))
          {
            v63 = v92 * (uint64_t)(v36 - 2 * v101 + v99);
            v64 = (v79 - v63) / v78;
            if (1 << v62 <= (int)v64)
              v65 = (1 << v62) - 1;
            else
              v65 = (v79 - v63) / v78;
            if (v62 > 0)
              LODWORD(v64) = v65;
            if (1 << v62 <= (int)((v63 + v79) / v78))
              v66 = (1 << v62) - 1;
            else
              LOWORD(v66) = (v63 + v79) / v78;
            if (v62 >= 1)
              LOWORD(v67) = v66;
            else
              LOWORD(v67) = (v63 + v79) / v78;
            if (v63 < 0)
              v67 = -(int)v64;
            WORD2(__dst) = v67;
          }
          v2 = v89;
          v93(v89, v94, &__dst, v95, v26);
          v23 += 64;
          v26 = (*(_DWORD *)(v94 + 36) + v26);
          ++v27;
          v31 += 64;
          v28 += 64;
        }
        while (v27 <= v34);
        v8 = v94;
        v95 += 8 * *(int *)(v94 + 40);
        v15 = v77 + 1;
        v14 = v74;
        v9 = v75;
      }
      while (v77 + 1 != v73);
    }
    goto LABEL_116;
  }
LABEL_117:
  v68 = *(_DWORD *)(v2 + 184) + 1;
  *(_DWORD *)(v2 + 184) = v68;
  if (v68 < *(_DWORD *)(v2 + 432))
    return 3;
  else
    return 4;
}

uint64_t kdu_kernels::clear(uint64_t this)
{
  uint64_t v1;
  uint64_t v7;

  v1 = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(this + 32) = _D0;
  *(_DWORD *)this = -1;
  *(_WORD *)(this + 4) = 0;
  *(_BYTE *)(this + 6) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_QWORD *)(this + 40) = 0;
  *(_QWORD *)(this + 56) = 0;
  *(_QWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_QWORD *)(this + 80) = 0;
  *(_QWORD *)(this + 88) = 0;
  *(_DWORD *)(this + 96) = 0;
  *(_DWORD *)(this + 120) = 0;
  *(_QWORD *)(this + 104) = 0;
  *(_QWORD *)(this + 112) = 0;
  *(_QWORD *)(this + 128) = 0;
  *(_QWORD *)(this + 136) = 0;
  *(_QWORD *)(this + 144) = 0xFFFFFFFF00000004;
  *(_QWORD *)(this + 152) = 0;
  *(_QWORD *)(this + 160) = 0;
  do
  {
    v7 = this + v1;
    *(_DWORD *)(v7 + 168) = -1;
    *(_QWORD *)(v7 + 176) = 0;
    *(_DWORD *)(v7 + 408) = -1;
    *(_QWORD *)(v7 + 416) = 0;
    v1 += 16;
  }
  while (v1 != 240);
  return this;
}

uint64_t kdu_kernels::reset(kdu_kernels *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *((_QWORD *)this + 2);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C80451B5BE8);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C8052888210);
  v4 = *((_QWORD *)this + 7);
  if (v4)
    MEMORY[0x18D761C18](v4 - 4 * *((int *)this + 10), 0x1000C8052888210);
  v5 = *((_QWORD *)this + 10);
  if (v5)
    MEMORY[0x18D761C18](v5 - 4 * *((int *)this + 16), 0x1000C8052888210);
  v6 = *((_QWORD *)this + 13);
  if (v6)
    MEMORY[0x18D761C18](v6 - 4 * *((int *)this + 22), 0x1000C8052888210);
  v7 = *((_QWORD *)this + 16);
  if (v7)
    MEMORY[0x18D761C18](v7 - 4 * *((int *)this + 28), 0x1000C8052888210);
  v8 = *((_QWORD *)this + 19);
  if (v8)
    MEMORY[0x18D761C18](v8 - 4 * *((int *)this + 37), 0x1000C8052888210);
  v9 = *((_QWORD *)this + 20);
  if (v9)
    MEMORY[0x18D761C18](v9 - 4 * *((int *)this + 37), 0x1000C8052888210);
  v10 = *((_QWORD *)this + 17);
  if (v10)
    MEMORY[0x18D761C18](v10, 0x1000C8000313F17);
  return kdu_kernels::clear((uint64_t)this);
}

uint64_t kdu_kernels::enlarge_work_buffers(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;

  if (*(_DWORD *)(this + 148) < a2)
  {
    v3 = this;
    v4 = operator new[]() + 4 * a2;
    this = operator new[]();
    v5 = this + 4 * a2;
    v6 = *(_QWORD *)(v3 + 152);
    if (v6)
    {
      v7 = *(int *)(v3 + 148);
      v8 = (const void *)(v6 - 4 * v7);
      memcpy((void *)(v4 - 4 * v7), v8, (8 * v7) | 4);
      this = MEMORY[0x18D761C18](v8, 0x1000C8052888210);
      *(_QWORD *)(v3 + 152) = 0;
    }
    v9 = *(_QWORD *)(v3 + 160);
    if (v9)
    {
      v10 = *(int *)(v3 + 148);
      v11 = (const void *)(v9 - 4 * v10);
      memcpy((void *)(v5 - 4 * v10), v11, (8 * v10) | 4);
      this = MEMORY[0x18D761C18](v11, 0x1000C8052888210);
    }
    *(_QWORD *)(v3 + 152) = v4;
    *(_QWORD *)(v3 + 160) = v5;
    *(_DWORD *)(v3 + 148) = a2;
  }
  return this;
}

uint64_t kdu_kernels::expand_and_convolve(kdu_kernels *this, float **a2, int a3, float *a4, int a5, float **a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  float v20;
  int v21;
  float *v22;
  float *v23;
  float v24;

  v12 = (a5 + 2 * a3);
  kdu_kernels::enlarge_work_buffers((uint64_t)this, a5 + 2 * a3);
  v13 = (uint64_t)*a2;
  v14 = (uint64_t)*a6;
  v15 = *((_QWORD *)this + 19);
  if (v13 != v15 && v13 != *((_QWORD *)this + 20))
    kdu_kernels::expand_and_convolve();
  if (v14 != v15 && v14 != *((_QWORD *)this + 20))
    kdu_kernels::expand_and_convolve();
  if ((int)v12 > *((_DWORD *)this + 37))
    kdu_kernels::expand_and_convolve();
  if ((v12 & 0x80000000) == 0)
    bzero((void *)(v14 + 4 * -(int)v12), 4 * (v12 + a5 + 2 * a3) + 4);
  if ((a3 & 0x80000000) == 0)
  {
    v16 = -a3;
    if (a5 >= 0)
      v17 = a5;
    else
      v17 = -a5;
    v18 = -2 * a3;
    v19 = a5 + v17 + 1;
    do
    {
      if ((a5 & 0x80000000) == 0)
      {
        v20 = *(float *)(v13 + 4 * v16);
        v21 = v19;
        v22 = &a4[-a5];
        v23 = (float *)(v14 + 4 * -a5 + 4 * v18);
        do
        {
          v24 = *v22++;
          *v23 = *v23 + (float)(v20 * v24);
          ++v23;
          --v21;
        }
        while (v21);
      }
      ++v16;
      v18 += 2;
    }
    while (a3 + 1 != (_DWORD)v16);
  }
  return v12;
}

uint64_t kdu_kernels::init(kdu_kernels *this, int a2, int a3)
{
  uint64_t v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  kdu_kernels::reset(this);
  *(_DWORD *)this = a2;
  *((_BYTE *)this + 4) = a3;
  *(_WORD *)((char *)this + 5) = 257;
  if (a2)
  {
    if (a2 != 1)
    {
      v17 = 0;
      v15 = 0u;
      v16 = 0u;
      kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v15);
    }
    *((_QWORD *)this + 1) = 0x200000002;
    v6 = operator new[]();
    *(_QWORD *)(v6 + 12) = 0;
    *(_QWORD *)(v6 + 4) = 0;
    *(_QWORD *)(v6 + 20) = 0;
    *(_DWORD *)(v6 + 28) = 0;
    *((_QWORD *)this + 2) = v6;
    *(_DWORD *)(v6 + 16) = 2;
    *(_DWORD *)v6 = 2;
    v7 = (_OWORD *)operator new[]();
    *((_QWORD *)this + 3) = v7;
    *v7 = xmmword_18820CDA0;
    if (a3)
    {
      v8 = *((_QWORD *)this + 2);
      *(_QWORD *)(v8 + 8) = 0x100000001;
      *(_QWORD *)(v8 + 24) = 0x200000002;
    }
  }
  else
  {
    *((_QWORD *)this + 1) = 0x200000004;
    v9 = operator new[]();
    *(_OWORD *)(v9 + 36) = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    *(_OWORD *)(v9 + 20) = 0u;
    *(_OWORD *)(v9 + 4) = 0u;
    *((_QWORD *)this + 2) = v9;
    *(_DWORD *)(v9 + 48) = 2;
    *(_DWORD *)(v9 + 32) = 2;
    *(_DWORD *)(v9 + 16) = 2;
    *(_DWORD *)v9 = 2;
    v10 = (_OWORD *)operator new[]();
    *((_QWORD *)this + 3) = v10;
    if (a3)
    {
      v17 = 0;
      v15 = 0u;
      v16 = 0u;
      kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
      (*(void (**)(__int128 *, const char *))(v15 + 16))(&v15, "The W9X7 kernel may not be used for reversible compression!");
      kdu_error::~kdu_error((kdu_error *)&v15);
    }
    *v10 = xmmword_18820CD90;
    v10[1] = xmmword_18820CD90;
  }
  v11 = *((unsigned int *)this + 2);
  if ((int)v11 >= 1)
  {
    v12 = 0;
    v13 = (_DWORD *)(*((_QWORD *)this + 2) + 4);
    do
    {
      *v13 = -((int)((v12 & 1) + *(v13 - 1) - 1) >> 1);
      v13 += 4;
      ++v12;
    }
    while (v11 != v12);
  }
  return kdu_kernels::derive_taps_and_gains(this);
}

void sub_187F1B778(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1B784()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t kdu_kernels::derive_taps_and_gains(kdu_kernels *this)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _BOOL8 v16;
  int v17;
  int *v18;
  int v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  float v42;
  float *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  char v49;
  char v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  char v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  int v66;
  int *v67;
  int v68;
  int v69;
  uint64_t result;
  uint64_t v71;
  uint64_t v72;
  float v73;
  int v79;
  uint64_t v80;
  float *v81;
  int v82;
  float v83;
  float v84;
  float *v85;
  int v86;
  uint64_t v87;
  float *v88;
  int v89;
  int v90;
  int v91;
  float v92;
  uint64_t v93;
  float v94;
  float *v95;
  int v96;
  uint64_t v97;
  float *v98;
  int v99;
  _DWORD *exception;
  char v101;
  __int128 v102;
  uint64_t v103;
  _QWORD v104[2];

  v104[1] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 17) = operator new[]();
  kdu_kernels::enlarge_work_buffers((uint64_t)this, *((_DWORD *)this + 2) * *((_DWORD *)this + 3));
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v103 = 0;
  v104[0] = 0;
  v102 = *(_OWORD *)((char *)this + 152);
  v101 = 1;
  while (1)
  {
    **((_DWORD **)&v102 + v3) = 1065353216;
    *((_DWORD *)&v104[-1] + v3) = 0;
    *((_DWORD *)v104 + v3) = 0;
    v5 = (4 * v3) ^ 4;
    *(_DWORD *)((char *)v104 + v5) = 1;
    *(_DWORD *)((char *)&v104[-1] + v5) = -1;
    v6 = *((unsigned int *)this + 2);
    if ((int)v6 >= 1)
    {
      v7 = v6 - 1;
      v8 = 4 * v6;
      do
      {
        v9 = v6--;
        v10 = *(_DWORD *)((unint64_t)&v103 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v6 & 1)));
        v11 = *(_DWORD *)((unint64_t)v104 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v6 & 1)));
        if (v10 >= v11)
        {
          v12 = (int *)(*((_QWORD *)this + 2) + 16 * v6);
          v13 = *v12;
          if (*v12 <= 0)
          {
            exception = __cxa_allocate_exception(4uLL);
            *exception = -1;
            __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
          }
          v14 = v6 & 1;
          v15 = v12[1];
          v16 = !(v6 & 1);
          v17 = v10 - v15;
          v18 = (int *)((unint64_t)&v103 | (4 * v16));
          v19 = *v18;
          v20 = (_QWORD *)((unint64_t)&v102 | (8 * v16));
          LODWORD(v21) = *v18;
          if (v17 > *v18)
          {
            v22 = v19;
            v23 = *((int *)this + 37);
            v24 = v19 + 1;
            v21 = v22 + 1;
            while (v21 < v23 && v24 >= -(int)v23)
            {
              *(_DWORD *)(*v20 + 4 * v21) = 0;
              v35 = v21++ < v17;
              if (!v35)
              {
                LODWORD(v21) = v17;
                break;
              }
            }
            *v18 = v21;
          }
          v25 = v15 + v13 - 1;
          v26 = v11 - v25;
          v27 = (int *)((unint64_t)v104 | (4 * v16));
          v28 = *v27;
          if (v11 - v25 < *v27)
          {
            v29 = v28;
            v30 = *((int *)this + 37);
            v31 = v11 - (v15 + v13) + 1;
            v32 = v28 - 1;
            while (v28 <= (int)v30 && v29 > -v30)
            {
              *(_DWORD *)(*v20 + 4 * v29 - 4) = 0;
              --v32;
              if (--v29 <= v26)
              {
                v32 = v31;
                break;
              }
            }
            *v27 = v32;
            v28 = v32;
          }
          v33 = *((_DWORD *)this + 37);
          v34 = -(uint64_t)v33;
          v35 = v28 >= (int)v34 && (int)v21 <= v33;
          if (!v35)
            kdu_kernels::derive_taps_and_gains();
          v36 = *(int *)((unint64_t)v104 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v6 & 1)));
          v37 = *(_DWORD *)((unint64_t)&v103 | (4 * v14));
          if ((int)v36 <= v37)
          {
            v38 = *(_QWORD *)((unint64_t)&v102 | (8 * v14));
            v39 = v36 - v15;
            v40 = v37 + 1;
            v41 = *((_QWORD *)this + 3) + 4 * v7;
            do
            {
              if ((int)v15 <= v25)
              {
                v42 = -*(float *)(v38 + 4 * v36);
                v43 = (float *)v41;
                v44 = v13;
                v45 = v39;
                do
                {
                  if (v39 >= v33)
                    break;
                  if (v45 < v34)
                    break;
                  *(float *)(*v20 + 4 * v45) = *(float *)(*v20 + 4 * v45) + (float)(v42 * *v43);
                  --v45;
                  v43 = (float *)((char *)v43 + v8);
                  --v44;
                }
                while (v44);
              }
              ++v36;
              ++v39;
            }
            while (v40 != (_DWORD)v36);
          }
        }
        --v7;
      }
      while (v9 > 1);
    }
    v46 = 0;
    v47 = 100;
    v48 = -100;
    v49 = 1;
    do
    {
      v50 = v49;
      v51 = *((_DWORD *)&v104[-1] + v46);
      v52 = *((_DWORD *)v104 + v46);
      if (v51 >= v52)
      {
        v53 = v46 + v4;
        v54 = v53 + 2 * v51;
        if (v54 > v48)
          v48 = v54;
        v55 = v53 + 2 * v52;
        if (v55 < v47)
          v47 = v55;
      }
      v49 = 0;
      v46 = 1;
    }
    while ((v50 & 1) != 0);
    if (v48 + v47 < 0 != __OFADD__(v48, v47))
      v56 = -v47;
    else
      v56 = v48;
    v57 = operator new[]();
    v58 = v57;
    if ((v56 & 0x80000000) == 0)
      bzero((void *)(v57 + 4 * (v56 + (uint64_t)-v56)), 4 * (v56 + ((v48 + v47) & ~((v48 + v47) >> 31)) - v47) + 4);
    v59 = 0;
    v60 = v58 + 4 * v56;
    v61 = 1;
    do
    {
      v62 = v61;
      v63 = *((int *)v104 + v59);
      v64 = *((_DWORD *)&v104[-1] + v59);
      if ((int)v63 <= v64)
      {
        v65 = *((_QWORD *)&v102 + v59);
        v66 = v2 + 2 * v63 + v59;
        v67 = (int *)(v65 + 4 * v63);
        v68 = v64 - v63 + 1;
        do
        {
          v69 = *v67++;
          *(_DWORD *)(v60 + 4 * v66) = v69;
          v66 += 2;
          --v68;
        }
        while (v68);
      }
      v61 = 0;
      v59 = 1;
    }
    while ((v62 & 1) != 0);
    result = operator new[]();
    v71 = result + 4 * v56;
    if ((v56 & 0x80000000) == 0)
    {
      v72 = -v56;
      do
      {
        v73 = *(float *)(v60 + 4 * v72);
        if ((v72 & 1) != 0)
          v73 = -v73;
        *(float *)(v71 + 4 * v72) = v73;
        v35 = v72++ < v56;
      }
      while (v35);
    }
    if ((v101 & 1) == 0)
      break;
    v101 = 0;
    *((_DWORD *)this + 17) = v47;
    *((_DWORD *)this + 18) = v48;
    *((_DWORD *)this + 23) = v47;
    *((_DWORD *)this + 24) = v48;
    *((_DWORD *)this + 16) = v56;
    *((_DWORD *)this + 22) = v56;
    *((_QWORD *)this + 13) = v60;
    --v4;
    --v2;
    v3 = 1;
    *((_QWORD *)this + 10) = v71;
  }
  *((_DWORD *)this + 11) = v47;
  *((_DWORD *)this + 12) = v48;
  *((_DWORD *)this + 29) = v47;
  *((_DWORD *)this + 30) = v48;
  *((_DWORD *)this + 10) = v56;
  *((_DWORD *)this + 28) = v56;
  *((_QWORD *)this + 16) = v60;
  *((_QWORD *)this + 7) = v71;
  if (*((_BYTE *)this + 4))
  {
    __asm { FMOV            V0.2S, #1.0 }
    *((_QWORD *)this + 4) = _D0;
  }
  else
  {
    v79 = *((_DWORD *)this + 10);
    if (v79 < 0)
    {
      *((_DWORD *)this + 8) = 2139095040;
      v83 = 0.0;
    }
    else
    {
      v80 = -v79;
      v81 = (float *)(result + 4 * v80 + 4 * (((v48 + v47) & ~((v48 + v47) >> 31)) - v47));
      v82 = (2 * v79) | 1;
      v83 = 0.0;
      do
      {
        v84 = *v81++;
        v83 = v83 + v84;
        --v82;
      }
      while (v82);
      *((float *)this + 8) = 1.0 / v83;
      v85 = (float *)(*((_QWORD *)this + 7) + 4 * v80);
      v86 = (2 * v79) | 1;
      do
      {
        *v85 = *((float *)this + 8) * *v85;
        ++v85;
        --v86;
      }
      while (v86);
    }
    v87 = *((int *)this + 22);
    if ((v87 & 0x80000000) == 0)
    {
      v88 = (float *)(*((_QWORD *)this + 13) - 4 * v87);
      v89 = (2 * v87) | 1;
      do
      {
        *v88 = v83 * *v88;
        ++v88;
        --v89;
      }
      while (v89);
    }
    v90 = *((_DWORD *)this + 16);
    if (v90 < 0)
    {
      *((_DWORD *)this + 9) = 2139095040;
      v92 = 0.0;
    }
    else
    {
      v91 = (2 * v90) | 1;
      v92 = 0.0;
      v93 = -v90;
      do
      {
        v94 = *(float *)(*((_QWORD *)this + 10) + 4 * v93);
        if ((v93 & 1) != 0)
          v94 = -v94;
        v92 = v92 + v94;
        ++v93;
        --v91;
      }
      while (v91);
      *((float *)this + 9) = 1.0 / v92;
      v95 = (float *)(*((_QWORD *)this + 10) + 4 * -v90);
      v96 = (2 * v90) | 1;
      do
      {
        *v95 = *((float *)this + 9) * *v95;
        ++v95;
        --v96;
      }
      while (v96);
    }
    v97 = *((int *)this + 28);
    if ((v97 & 0x80000000) == 0)
    {
      v98 = (float *)(*((_QWORD *)this + 16) - 4 * v97);
      v99 = (2 * v97) | 1;
      do
      {
        *v98 = v92 * *v98;
        ++v98;
        --v99;
      }
      while (v99);
    }
  }
  return result;
}

uint64_t kdu_kernels::init(uint64_t a1, int a2, uint64_t a3, int *a4, char a5, char a6, char a7)
{
  void *v14;
  void *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;

  kdu_kernels::reset((kdu_kernels *)a1);
  *(_DWORD *)a1 = -1;
  *(_BYTE *)(a1 + 4) = a7;
  *(_BYTE *)(a1 + 5) = a5;
  *(_BYTE *)(a1 + 6) = a6;
  *(_QWORD *)(a1 + 8) = a2;
  v14 = (void *)operator new[]();
  v15 = v14;
  if (!a2)
  {
    *(_QWORD *)(a1 + 16) = v14;
    goto LABEL_9;
  }
  bzero(v14, 16 * a2);
  *(_QWORD *)(a1 + 16) = v15;
  if (a2 <= 0)
  {
LABEL_9:
    v18 = 0;
    goto LABEL_10;
  }
  v16 = 0;
  do
  {
    *(_OWORD *)(*(_QWORD *)(a1 + 16) + v16) = *(_OWORD *)(a3 + v16);
    v17 = *(_DWORD *)(a3 + v16);
    if (v17 > *(_DWORD *)(a1 + 12))
      *(_DWORD *)(a1 + 12) = v17;
    v16 += 16;
  }
  while (16 * a2 != v16);
  v18 = 1;
LABEL_10:
  v19 = operator new[]();
  *(_QWORD *)(a1 + 24) = v19;
  if (v18)
  {
    v20 = 0;
    v21 = *(_QWORD *)(a1 + 16);
    v22 = *(unsigned int *)(a1 + 12);
    v23 = 4 * a2;
    do
    {
      v24 = *(unsigned int *)(v21 + 16 * v20);
      if ((int)v24 < 1)
      {
        v24 = 0;
      }
      else
      {
        v25 = *(unsigned int *)(v21 + 16 * v20);
        v26 = (_DWORD *)v19;
        do
        {
          v27 = *a4++;
          *v26 = v27;
          v26 = (_DWORD *)((char *)v26 + v23);
          --v25;
        }
        while (v25);
      }
      if ((int)v24 < (int)v22)
      {
        v28 = v23 * v24;
        v29 = v22 - v24;
        do
        {
          *(_DWORD *)(v19 + v28) = 0;
          v28 += v23;
          --v29;
        }
        while (v29);
      }
      ++v20;
      v19 += 4;
    }
    while (v20 != a2);
  }
  return kdu_kernels::derive_taps_and_gains((kdu_kernels *)a1);
}

uint64_t kdu_kernels::get_impulse_response(_DWORD *a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  _DWORD *v5;

  switch(a2)
  {
    case 0:
      if (a4)
        *a4 = a1[11];
      if (a5)
        *a5 = a1[12];
      *a3 = a1[10];
      v5 = a1 + 14;
      break;
    case 1:
      if (a4)
        *a4 = a1[17];
      if (a5)
        *a5 = a1[18];
      *a3 = a1[16];
      v5 = a1 + 20;
      break;
    case 2:
      if (a4)
        *a4 = a1[23];
      if (a5)
        *a5 = a1[24];
      *a3 = a1[22];
      v5 = a1 + 26;
      break;
    case 3:
      if (a4)
        *a4 = a1[29];
      if (a5)
        *a5 = a1[30];
      *a3 = a1[28];
      v5 = a1 + 32;
      break;
    default:
      kdu_kernels::get_impulse_response();
  }
  return *(_QWORD *)v5;
}

double kdu_kernels::get_energy_gain(kdu_kernels *this, int a2, int a3, BOOL *a4)
{
  int v5;
  int v7;
  uint64_t i;
  int v9;
  char *v10;
  int v11;
  double v12;
  double v13;
  float **v14;
  float **v15;
  int v16;
  unint64_t v17;
  float **v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  float **v22;
  float *v23;
  int v24;
  char *v25;
  uint64_t v26;
  float v27;
  int *v29;
  uint64_t v30;
  char *v31;

  if (a3 >= 4)
    kdu_kernels::get_energy_gain();
  v5 = a2;
  v7 = ~(-1 << a3);
  if (a3)
  {
    for (i = 0; i != a3; ++i)
    {
      if (a4[i])
        v9 = 1 << i;
      else
        v9 = 0;
      v7 += v9;
    }
  }
  v10 = (char *)this + 168;
  v11 = *((_DWORD *)this + 36);
  v12 = 1.0;
  if (v11 < a2)
  {
    do
    {
      --v5;
      v12 = v12 + v12;
    }
    while (v5 > v11);
    v5 = *((_DWORD *)this + 36);
  }
  if (v7 <= 14 && *(_DWORD *)&v10[16 * v7] == v5)
  {
    v13 = *(double *)&v10[16 * v7 + 8];
  }
  else
  {
    v29 = (int *)&v10[16 * v7];
    v30 = v7;
    v31 = (char *)this + 168;
    v14 = (float **)((char *)this + 152);
    v15 = (float **)((char *)this + 160);
    **((_DWORD **)this + 19) = 1065353216;
    if (a3 < 1)
    {
      v16 = 0;
    }
    else
    {
      v16 = 0;
      v17 = a3 + 1;
      v18 = (float **)((char *)this + 152);
      do
      {
        v14 = v15;
        if (a4[(v17 - 2)])
          v19 = 128;
        else
          v19 = 104;
        if (a4[(v17 - 2)])
          v20 = 112;
        else
          v20 = 88;
        v16 = kdu_kernels::expand_and_convolve(this, v18, v16, *(float **)((char *)this + v19), *(_DWORD *)((char *)this + v20), v14);
        --v17;
        v15 = v18;
        v18 = v14;
      }
      while (v17 > 1);
    }
    if (v5 < 1)
    {
      v22 = v14;
    }
    else
    {
      v21 = v5 + 1;
      do
      {
        v22 = v15;
        v16 = kdu_kernels::expand_and_convolve(this, v14, v16, *((float **)this + 13), *((_DWORD *)this + 22), v15);
        --v21;
        v15 = v14;
        v14 = v22;
      }
      while (v21 > 1);
    }
    if (v16 > *((_DWORD *)this + 37))
      kdu_kernels::get_energy_gain();
    if (v16 < 0)
    {
      v13 = 0.0;
      v26 = v30;
      v25 = v31;
    }
    else
    {
      v23 = &(*v22)[-v16];
      v24 = (2 * v16) | 1;
      v13 = 0.0;
      v26 = v30;
      v25 = v31;
      do
      {
        v27 = *v23++;
        v13 = v13 + v27 * v27;
        --v24;
      }
      while (v24);
    }
    if ((int)v26 <= 14 && *v29 < v5)
    {
      *v29 = v5;
      *(double *)&v25[16 * v26 + 8] = v13;
    }
  }
  return v12 * v13;
}

double kdu_kernels::get_bibo_gain(kdu_kernels *this, int a2, int a3, BOOL *a4)
{
  int v5;
  uint64_t i;
  int v7;
  char *v8;
  uint64_t v9;
  int *v10;
  int v11;
  double *v12;
  double result;
  int v14;
  uint64_t v15;
  int *v16;
  double v17;
  int *v18;
  double v19;
  double v20;

  if (a3 >= 4)
    kdu_kernels::get_bibo_gain();
  v5 = ~(-1 << a3);
  if (a3)
  {
    for (i = 0; i != a3; ++i)
    {
      if (a4[i])
        v7 = 1 << i;
      else
        v7 = 0;
      v5 += v7;
    }
  }
  v8 = (char *)this + 408;
  v9 = v5;
  v10 = (int *)((char *)this + 16 * v5 + 408);
  if (*((_DWORD *)this + 36) >= a2)
    v11 = a2;
  else
    v11 = *((_DWORD *)this + 36);
  if (v5 <= 14)
    v12 = (double *)((char *)this + 16 * v5 + 408);
  else
    v12 = 0;
  if (v5 <= 14 && *v10 == v11)
    return *(double *)&v8[16 * v5 + 8];
  v19 = 0.0;
  v20 = 0.0;
  v14 = a3 - 1;
  if (a3 < 1)
  {
    if (v11 < 1)
    {
      return 1.0;
    }
    else
    {
      kdu_kernels::get_bibo_gains(this, v11 - 1, 0, 0, &v20, &v19);
      if ((_DWORD)v9)
        kdu_kernels::get_bibo_gain();
      result = v20;
      if (*(_DWORD *)v12 < v11)
      {
        *(_DWORD *)v12 = v11;
        v12[1] = result;
      }
    }
  }
  else
  {
    kdu_kernels::get_bibo_gains(this, v11, a3 - 1, a4, &v20, &v19);
    if (a4[v14])
    {
      result = v19;
      if ((int)v9 <= 14)
      {
        if (*v10 < v11)
        {
          *v10 = v11;
          *(double *)&v8[16 * v9 + 8] = result;
        }
        v15 = -(uint64_t)(1 << v14);
        v16 = &v10[-4 * (1 << v14)];
        if (*v16 < v11)
        {
          *v16 = v11;
          v17 = v20;
LABEL_33:
          *(double *)&v10[4 * v15 + 2] = v17;
          return result;
        }
        if (*v16 == v11 && *(double *)&v10[-4 * (1 << v14) + 2] != v20)
          kdu_kernels::get_bibo_gain();
      }
    }
    else
    {
      result = v20;
      if ((int)v9 <= 14)
      {
        if (*v10 < v11)
        {
          *v10 = v11;
          *(double *)&v8[16 * v9 + 8] = result;
        }
        v15 = 1 << v14;
        v18 = &v10[4 * v15];
        if (*v18 < v11)
        {
          *v18 = v11;
          v17 = v19;
          goto LABEL_33;
        }
        if (*v18 == v11 && *(double *)&v10[4 * v15 + 2] != v19)
          kdu_kernels::get_bibo_gain();
      }
    }
  }
  return result;
}

uint64_t kdu_kernels::get_bibo_gains(kdu_kernels *this, int a2, int a3, BOOL *a4, double *a5, double *a6)
{
  int v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  int v19;
  int *v20;
  _DWORD *v21;
  int v22;
  int v23;
  int *v24;
  _DWORD *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  float *v50;
  int v51;
  float *v52;
  int v53;
  float *v54;
  float v55;
  double v56;
  float *v57;
  int v58;
  float v59;
  BOOL v60;
  uint64_t v61;
  uint64_t v62;
  int *v63;
  uint64_t v64;
  int v65;
  int v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  _DWORD *v74;
  float *v75;
  int v76;
  float *v77;
  int v78;
  float *v79;
  float v80;
  double v81;
  float *v82;
  int v83;
  float v84;
  float *v85;
  int v86;
  float *v87;
  int v88;
  _DWORD *exception;
  int v91;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;

  if (*((_DWORD *)this + 36) >= a2)
    v10 = a2;
  else
    v10 = *((_DWORD *)this + 36);
  kdu_kernels::enlarge_work_buffers((uint64_t)this, 1);
  v11 = (_DWORD *)*((_QWORD *)this + 19);
  v12 = *((_QWORD *)this + 20);
  *v11 = 1065353216;
  *a6 = 1.0;
  *a5 = 1.0;
  if (v10 + a3 >= 0)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v91 = ~v10;
    v93 = (v10 + a3 + 1);
    v94 = v10;
    v18 = 1.0;
    v19 = 1;
    do
    {
      v95 = v13;
      if (v13 > v94 && a4[(int)v13 + v91])
      {
        if ((int)v15 <= (int)v14)
        {
          v20 = (int *)(v12 + 4 * (int)v15);
          v21 = &v11[(int)v15];
          v22 = v14 - v15 + 1;
          do
          {
            v23 = *v20++;
            *v21++ = v23;
            --v22;
          }
          while (v22);
        }
        *a5 = *a6;
        v17 = v15;
        v16 = v14;
      }
      else
      {
        if ((int)v17 <= (int)v16)
        {
          v24 = &v11[(int)v17];
          v25 = (_DWORD *)(v12 + 4 * (int)v17);
          v26 = v16 - v17 + 1;
          do
          {
            v27 = *v24++;
            *v25++ = v27;
            --v26;
          }
          while (v26);
        }
        *a6 = v18;
      }
      if (((int)v16 + (int)v17 < 0) ^ __OFADD__((_DWORD)v16, (_DWORD)v17) | ((_DWORD)v16 + (_DWORD)v17 == 0))
        v28 = -(int)v17;
      else
        v28 = v16;
      v29 = *((_DWORD *)this + 2);
      v30 = v28 + *((_DWORD *)this + 3) * v19 * v29;
      if (v30 > *((_DWORD *)this + 37))
      {
        kdu_kernels::enlarge_work_buffers((uint64_t)this, v30);
        v11 = (_DWORD *)*((_QWORD *)this + 19);
        v12 = *((_QWORD *)this + 20);
        v29 = *((_DWORD *)this + 2);
      }
      v31 = 2 * v19;
      if (v29 < 1)
      {
        v15 = v17;
        v14 = v16;
      }
      else
      {
        v32 = 0;
        v14 = v16;
        v15 = v17;
        do
        {
          if ((int)v17 <= (int)v16)
          {
            v33 = *((_QWORD *)this + 3);
            v34 = (int *)(*((_QWORD *)this + 2) + 16 * v32);
            v36 = *v34;
            v35 = v34[1];
            v37 = (2 * v35 - 1) * v19;
            if (v37 + (int)v17 < (int)v15)
            {
              v38 = *((_DWORD *)this + 37);
              v39 = (int)v15;
              v40 = 1 - v15;
              do
              {
                v41 = v39 - 1;
                v42 = v39 - 1;
                if (v39 < 1)
                  v41 = v40;
                if (v41 > v38)
                  goto LABEL_89;
                *(_DWORD *)(v12 - 4 + 4 * v39) = 0;
                ++v40;
                --v39;
              }
              while (v42 > v37 + (int)v17);
              v15 = v42;
            }
            v43 = v35 + v36 - 1;
            v44 = v16 + (2 * v43 - 1) * v19;
            if (v44 > (int)v14)
            {
              v45 = *((_DWORD *)this + 37);
              v46 = (int)v14;
              v47 = ~(_DWORD)v14;
              v48 = v14 + 1;
              do
              {
                if (v46 >= -1)
                  v49 = v48;
                else
                  v49 = v47;
                if (v49 > v45)
                  goto LABEL_89;
                *(_DWORD *)(v12 + 4 + 4 * v46) = 0;
                --v47;
                ++v48;
                ++v46;
              }
              while (v44 != v46);
              v14 = (v16 + (2 * v43 - 1) * v19);
            }
            if ((int)v35 <= v43)
            {
              v50 = (float *)(v33 + 4 * v32);
              v51 = v35 + v36;
              do
              {
                v52 = (float *)(v12 + 4 * ((int)v17 + (uint64_t)v37));
                v53 = v16 - v17 + 1;
                v54 = (float *)&v11[(int)v17];
                do
                {
                  v55 = *v54++;
                  *v52 = *v52 + (float)(v55 * *v50);
                  ++v52;
                  --v53;
                }
                while (v53);
                ++v35;
                v50 += v29;
                v37 += v31;
              }
              while (v51 != (_DWORD)v35);
            }
            *a6 = 0.0;
            v56 = 0.0;
            if ((int)v15 <= (int)v14)
            {
              v57 = (float *)(v12 + 4 * (int)v15);
              v58 = ~(_DWORD)v14 + v15;
              do
              {
                v59 = *v57++;
                v56 = v56 + fabsf(v59);
                v60 = __CFADD__(v58++, 1);
              }
              while (!v60);
              *a6 = v56;
            }
            *(double *)(*((_QWORD *)this + 17) + 8 * v32) = v56;
          }
          if ((int)v15 <= (int)v14)
          {
            v61 = v32 | 1;
            if ((v32 | 1) < v29)
            {
              v62 = *((_QWORD *)this + 3);
              v63 = (int *)(*((_QWORD *)this + 2) + 16 * v61);
              v65 = *v63;
              v64 = v63[1];
              v66 = ((2 * v64) | 1) * v19;
              if (v66 + (int)v15 < (int)v17)
              {
                v67 = (int)v17;
                while (1)
                {
                  v68 = (int)v67 >= 0 ? v67 : -(int)v67;
                  if (v68 >= v30)
                    break;
                  v17 = v67 - 1;
                  v11[v67 - 1] = 0;
                  v67 = v17;
                  if (v17 <= v66 + (int)v15)
                    goto LABEL_59;
                }
LABEL_89:
                exception = __cxa_allocate_exception(4uLL);
                *exception = -1;
                __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
              }
LABEL_59:
              v69 = v64 + v65 - 1;
              v70 = v14 + ((2 * v69) | 1) * v19;
              if (v70 > (int)v16)
              {
                v71 = *((_DWORD *)this + 37);
                if ((int)v16 > v71)
                  v71 = v16;
                v72 = v71 - (uint64_t)(int)v16;
                v73 = (int)v16 - (uint64_t)v70;
                v74 = &v11[(int)v16 + 1];
                do
                {
                  if (!v72)
                    goto LABEL_89;
                  *v74++ = 0;
                  --v72;
                  v60 = __CFADD__(v73++, 1);
                }
                while (!v60);
                v16 = v14 + ((2 * v69) | 1) * v19;
              }
              if ((int)v64 <= v69)
              {
                v75 = (float *)(v62 + 4 * v61);
                v76 = v64 + v65;
                do
                {
                  v77 = (float *)&v11[(int)v15 + (uint64_t)v66];
                  v78 = v14 - v15 + 1;
                  v79 = (float *)(v12 + 4 * (int)v15);
                  do
                  {
                    v80 = *v79++;
                    *v77 = *v77 + (float)(v80 * *v75);
                    ++v77;
                    --v78;
                  }
                  while (v78);
                  ++v64;
                  v75 += v29;
                  v66 += v31;
                }
                while (v76 != (_DWORD)v64);
              }
              *a5 = 0.0;
              v81 = 0.0;
              if ((int)v17 <= (int)v16)
              {
                v82 = (float *)&v11[(int)v17];
                v83 = ~(_DWORD)v16 + v17;
                do
                {
                  v84 = *v82++;
                  v81 = v81 + fabsf(v84);
                  v60 = __CFADD__(v83++, 1);
                }
                while (!v60);
                *a5 = v81;
              }
              *(double *)(*((_QWORD *)this + 17) + 8 * v61) = v81;
            }
          }
          v32 += 2;
        }
        while (v29 > (int)v32);
      }
      if ((int)v15 <= (int)v14)
      {
        v85 = (float *)(v12 + 4 * (int)v15);
        v86 = v14 - v15 + 1;
        do
        {
          *v85 = *((float *)this + 9) * *v85;
          ++v85;
          --v86;
        }
        while (v86);
      }
      *a6 = *a6 * *((float *)this + 9);
      if ((int)v17 <= (int)v16)
      {
        v87 = (float *)&v11[(int)v17];
        v88 = v16 - v17 + 1;
        do
        {
          *v87 = *((float *)this + 8) * *v87;
          ++v87;
          --v88;
        }
        while (v88);
      }
      v18 = *a5 * *((float *)this + 8);
      *a5 = v18;
      v13 = v95 + 1;
      v19 *= 2;
    }
    while (v95 + 1 != v93);
  }
  return *((_QWORD *)this + 17);
}

uint64_t _cg_jpeg_fdct_float(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t i;
  unsigned __int8 *v4;
  int v5;
  int v6;
  float v7;
  int v8;
  int v9;
  int v10;
  float v11;
  float v12;
  float v13;
  int v14;
  int v15;
  float v16;
  int v17;
  int v18;
  int v19;
  float v20;
  float *v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  uint64_t v40;
  uint64_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t *v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;

  for (i = 0; i != 64; i += 8)
  {
    v4 = (unsigned __int8 *)(*(_QWORD *)(a2 + i) + a3);
    v5 = *v4;
    v6 = v4[7];
    v7 = (float)(v6 + v5);
    v8 = v5 - v6;
    v9 = v4[1];
    v10 = v4[6];
    v11 = (float)v8;
    v12 = (float)(v10 + v9);
    v13 = (float)(v9 - v10);
    v14 = v4[2];
    v15 = v4[5];
    v16 = (float)(v15 + v14);
    v17 = v14 - v15;
    v18 = v4[3];
    LODWORD(v4) = v4[4];
    v19 = (_DWORD)v4 + v18;
    v20 = (float)(v18 - (int)v4);
    v21 = (float *)(result + 4 * i);
    v22 = v7 + (float)v19;
    v23 = v7 - (float)v19;
    v24 = v12 + v16;
    v25 = v12 - v16;
    v26 = (float)(v24 + v22) + -1024.0;
    v27 = v22 - v24;
    v28 = (float)(v25 + v23) * 0.70711;
    v29 = v23 + v28;
    v30 = v23 - v28;
    v31 = (float)v17 + v20;
    v32 = v13 + (float)v17;
    v33 = v11 + v13;
    v34 = (float)(v31 - v33) * 0.38268;
    v35 = v34 + (float)(v31 * 0.5412);
    v36 = v34 + (float)(v33 * 1.3066);
    v37 = v32 * 0.70711;
    v38 = v37 + v11;
    v39 = v11 - v37;
    *v21 = v26;
    v21[1] = v38 + v36;
    v21[4] = v27;
    v21[5] = v39 + v35;
    v21[2] = v29;
    v21[3] = v39 - v35;
    v21[6] = v30;
    v21[7] = v38 - v36;
  }
  v40 = result + 224;
  v41 = -32;
  v42 = (float32x4_t)vdupq_n_s32(0x3F3504F3u);
  v43 = (float32x4_t)vdupq_n_s32(0x3EC3EF15u);
  v44 = (float32x4_t)vdupq_n_s32(0x3F0A8BD4u);
  v45 = (float32x4_t)vdupq_n_s32(0x3FA73D75u);
  do
  {
    v46 = (float32x4_t *)(v40 + v41);
    v47 = *(float32x4_t *)(v40 + v41 - 192);
    v48 = *(float32x4_t *)(v40 + v41 + 32);
    v49 = vaddq_f32(v47, v48);
    v50 = vsubq_f32(v47, v48);
    v51 = *(float32x4_t *)(v40 + v41 - 160);
    v52 = *(float32x4_t *)(v40 + v41);
    v53 = vaddq_f32(v51, v52);
    v54 = vsubq_f32(v51, v52);
    v55 = *(float32x4_t *)(v40 + v41 - 128);
    v56 = *(float32x4_t *)(v40 + v41 - 32);
    v57 = vaddq_f32(v55, v56);
    v58 = vsubq_f32(v55, v56);
    v59 = *(float32x4_t *)(v40 + v41 - 96);
    v60 = *(float32x4_t *)(v40 + v41 - 64);
    v61 = vaddq_f32(v59, v60);
    v62 = vsubq_f32(v59, v60);
    v63 = vaddq_f32(v49, v61);
    v64 = vsubq_f32(v49, v61);
    v65 = vaddq_f32(v53, v57);
    v46[-12] = vaddq_f32(v65, v63);
    v46[-4] = vsubq_f32(v63, v65);
    v66 = vmulq_f32(vaddq_f32(vsubq_f32(v53, v57), v64), v42);
    v46[-8] = vaddq_f32(v64, v66);
    *v46 = vsubq_f32(v64, v66);
    v67 = vaddq_f32(v58, v62);
    v68 = vaddq_f32(v54, v58);
    v69 = vaddq_f32(v50, v54);
    v70 = vmulq_f32(vsubq_f32(v67, v69), v43);
    v71 = vmlaq_f32(v70, v44, v67);
    v72 = vmlaq_f32(v70, v45, v69);
    v73 = vmulq_f32(v68, v42);
    v74 = vaddq_f32(v50, v73);
    v75 = vsubq_f32(v50, v73);
    v46[-2] = vaddq_f32(v75, v71);
    v46[-6] = vsubq_f32(v75, v71);
    v46[-10] = vaddq_f32(v74, v72);
    v46[2] = vsubq_f32(v74, v72);
    v41 += 16;
  }
  while (v41);
  return result;
}

uint64_t jp2_family_src::open(jp2_family_src *this, kdu_compressed_source *a2)
{
  uint64_t result;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  if (*((_OWORD *)this + 1) != 0 || *((_QWORD *)this + 4))
  {
    v7 = 0;
    v5 = 0u;
    v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  if (*((_QWORD *)this + 1))
    jp2_family_src::open();
  ++*((_DWORD *)this + 18);
  result = (*(uint64_t (**)(kdu_compressed_source *))(*(_QWORD *)a2 + 24))(a2);
  if ((result & 1) == 0)
  {
    v7 = 0;
    v5 = 0u;
    v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  *((_QWORD *)this + 3) = a2;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = -1;
  *((_QWORD *)this + 7) = -1;
  *((_DWORD *)this + 16) = -1;
  *((_BYTE *)this + 68) = (result & 2) != 0;
  return result;
}

void sub_187F1CD34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1CD40()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_family_src::close(jp2_family_src *this)
{
  FILE *v2;
  uint64_t result;

  v2 = (FILE *)*((_QWORD *)this + 2);
  if (v2)
    fclose(v2);
  *((_QWORD *)this + 2) = 0;
  result = *((_QWORD *)this + 1);
  if (result)
    result = MEMORY[0x18D761C18](result, 0x1000C8077774924);
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = -1;
  *((_QWORD *)this + 6) = -1;
  *((_QWORD *)this + 7) = -1;
  *((_DWORD *)this + 16) = -1;
  return result;
}

void jp2_input_box::jp2_input_box(jp2_input_box *this)
{
  *(_QWORD *)this = &off_1E1BADD80;
  *(_OWORD *)((char *)this + 8) = xmmword_18820CDD0;
  *((_DWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = -1;
  *((_QWORD *)this + 13) = -1;
  *((_QWORD *)this + 14) = -1;
  *((_DWORD *)this + 30) = -1;
  *(_DWORD *)((char *)this + 125) = 0;
  *((_DWORD *)this + 32) = 0;
  *(_OWORD *)((char *)this + 136) = xmmword_18820CDD0;
  *((_DWORD *)this + 44) = 0;
}

void jp2_input_box::~jp2_input_box(jp2_input_box *this)
{
  *(_QWORD *)this = &off_1E1BADD80;
  jp2_input_box::close(this);
  *(_QWORD *)this = off_1E1BB2340;
}

{
  jp2_input_box::~jp2_input_box(this);
  JUMPOUT(0x18D761C30);
}

uint64_t jp2_input_box::read_box_header(jp2_input_box *this, int a2)
{
  uint64_t v4;
  unint64_t *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned __int8 *v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  unsigned int v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned __int8 *v35;
  unsigned int v36;
  uint64_t v37;
  unint64_t v38;
  unsigned int v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int v42;
  uint64_t v43;
  int v44;
  unsigned int v45;
  uint64_t v46;
  unsigned int v47;
  unsigned __int8 *v48;
  unsigned int v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unsigned int v55;
  uint64_t v56;
  unsigned int v57;
  unsigned int i;
  int v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v4 = -1;
  *((_QWORD *)this + 13) = -1;
  v5 = (unint64_t *)((char *)this + 104);
  *((_DWORD *)this + 12) = 0;
  *(_WORD *)((char *)this + 125) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 18) = -1;
  *((_QWORD *)this + 14) = -1;
  v6 = *((_QWORD *)this + 1);
  *((_BYTE *)this + 124) = v6 >= 0;
  if (*(_QWORD *)(*((_QWORD *)this + 5) + 32))
  {
    v6 = *((int *)this + 6);
    v4 = *((_QWORD *)this + 2);
    v7 = 4;
  }
  else
  {
    v7 = -1;
  }
  *((_QWORD *)this + 17) = v6;
  *((_QWORD *)this + 12) = v4;
  *((_DWORD *)this + 30) = v7;
  *((_BYTE *)this + 126) = 1;
  *((_QWORD *)this + 10) = v6;
  *((_QWORD *)this + 11) = 0x7FFFFFFFFFFFFFFFLL;
  v8 = *((_QWORD *)this + 4);
  if (v8 && !*(_BYTE *)(v8 + 125))
    *((_QWORD *)this + 11) = *(_QWORD *)(v8 + 88);
  *((_DWORD *)this + 44) = 0;
  v9 = (unsigned __int8 *)this + 152;
  if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)this + 32))(this, (char *)this + 152, 8) < 8)
    goto LABEL_8;
  v11 = 0;
  v12 = 5;
  v13 = 152;
  do
  {
    v11 = *((unsigned __int8 *)this + v13) | (unint64_t)(v11 << 8);
    --v12;
    ++v13;
  }
  while (v12 > 1);
  v14 = 0;
  *((_QWORD *)this + 7) = v11;
  v15 = 5;
  v16 = 156;
  do
  {
    v14 = *((unsigned __int8 *)this + v16) | (v14 << 8);
    --v15;
    ++v16;
  }
  while (v15 > 1);
  *((_DWORD *)this + 12) = v14;
  if (v14 == 1885891684)
  {
    *((_QWORD *)this + 11) = 0x7FFFFFFFFFFFFFFFLL;
    v17 = *((_QWORD *)this + 4);
    if (v17)
      *(_QWORD *)(v17 + 88) = 0x7FFFFFFFFFFFFFFFLL;
    if (v11 < 28)
    {
      *((_DWORD *)this + 12) = 0;
      *(_WORD *)((char *)this + 125) = 0;
      *((_QWORD *)this + 9) = 0;
      *((_QWORD *)this + 7) = 0;
      *((_QWORD *)this + 18) = -1;
      *v5 = -1;
      v5[1] = -1;
      v62 = 0;
      v60 = 0u;
      v61 = 0u;
      kdu_error::kdu_error((kdu_error *)&v60, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v60 + 16))(&v60, "Illegal placeholder box encountered.  Placeholders must not use the extended length field and must have a length of at least 28 bytes!");
      kdu_error::~kdu_error((kdu_error *)&v60);
    }
    v18 = 8;
    *((_QWORD *)this + 8) = 8;
  }
  else
  {
    v18 = 8;
    *((_QWORD *)this + 8) = 8;
    if (v11 == 1)
    {
      *((_QWORD *)this + 8) = 16;
      if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)this + 32))(this, (char *)this + 152, 8) < 8)goto LABEL_8;
      v11 = 0;
      v19 = 9;
      v20 = (unsigned __int8 *)this + 152;
      do
      {
        v21 = *v20++;
        v11 = v21 | (unint64_t)(v11 << 8);
        --v19;
      }
      while (v19 > 1);
      *((_QWORD *)this + 7) = v11;
      v18 = *((_QWORD *)this + 8);
    }
  }
  *((_BYTE *)this + 125) = v11 == 0;
  v22 = v11 - v18;
  if (v11 && v22 < 0)
  {
    *((_DWORD *)this + 12) = 0;
    *(_WORD *)((char *)this + 125) = 0;
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 18) = -1;
    *v5 = -1;
    v5[1] = -1;
    v62 = 0;
    v60 = 0u;
    v61 = 0u;
    kdu_error::kdu_error((kdu_error *)&v60, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v60 + 16))(&v60, "Illegal box length field encountered in JP2 file.");
    kdu_error::~kdu_error((kdu_error *)&v60);
  }
  *((_QWORD *)this + 9) = v11;
  if (v11 || *((_DWORD *)this + 12))
  {
    if (v14 != 1885891684)
    {
      v51 = *((_QWORD *)this + 17);
      v52 = v51 + v22;
      if (v22 < 0)
        v52 = 0x7FFFFFFFFFFFFFFFLL;
      *((_QWORD *)this + 10) = v51;
      *((_QWORD *)this + 11) = v52;
      return 1;
    }
    if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)this + 32))(this, (char *)this + 152, 20) >= 20)
    {
      v23 = 0;
      v24 = *((unsigned __int8 *)this + 155);
      v25 = 9;
      v26 = 156;
      do
      {
        v23 = *((unsigned __int8 *)this + v26) | (v23 << 8);
        --v25;
        ++v26;
      }
      while (v25 > 1);
      v27 = 0;
      v28 = 5;
      v29 = 164;
      do
      {
        v27 = *((unsigned __int8 *)this + v29) | (v27 << 8);
        --v28;
        ++v29;
      }
      while (v28 > 1);
      v30 = 0;
      *((_QWORD *)this + 7) = v27;
      v31 = 5;
      v32 = 168;
      do
      {
        v30 = *((unsigned __int8 *)this + v32) | (v30 << 8);
        --v31;
        ++v32;
      }
      while (v31 > 1);
      *((_DWORD *)this + 12) = v30;
      v33 = 8;
      *((_QWORD *)this + 8) = 8;
      if (v27 == 1)
      {
        *((_QWORD *)this + 8) = 16;
        if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)this + 32))(this, (char *)this + 152, 8) < 8)goto LABEL_8;
        v27 = 0;
        v34 = 9;
        v35 = (unsigned __int8 *)this + 152;
        do
        {
          v36 = *v35++;
          v27 = v36 | (v27 << 8);
          --v34;
        }
        while (v34 > 1);
        *((_QWORD *)this + 7) = v27;
        v33 = *((_QWORD *)this + 8);
      }
      *((_BYTE *)this + 125) = v27 == 0;
      v37 = v27 - v33;
      if (v27 && v37 < 0)
      {
        *((_DWORD *)this + 12) = 0;
        *(_WORD *)((char *)this + 125) = 0;
        *((_QWORD *)this + 9) = 0;
        *((_QWORD *)this + 7) = 0;
        *((_QWORD *)this + 18) = -1;
        *v5 = -1;
        v5[1] = -1;
        v62 = 0;
        v60 = 0u;
        v61 = 0u;
        kdu_error::kdu_error((kdu_error *)&v60, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v60 + 16))(&v60, "Illegal box length field encountered in JP2 file.");
        kdu_error::~kdu_error((kdu_error *)&v60);
      }
      if ((a2 & v24 & 1) != 0 || (v24 & 6) == 0)
      {
        *((_QWORD *)this + 12) = v23;
        *((_QWORD *)this + 17) = 0;
        *((_QWORD *)this + 10) = 0;
        if ((v24 & 1) == 0)
        {
          *((_DWORD *)this + 12) = 0;
          *((_QWORD *)this + 11) = 0;
          return 1;
        }
        v53 = 0x7FFFFFFFFFFFFFFFLL;
        if (v37 >= 0)
          v53 = v37;
LABEL_80:
        *((_QWORD *)this + 11) = v53;
        return 1;
      }
      *((_BYTE *)this + 124) = 0;
      if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)this + 32))(this, (char *)this + 152, 16) >= 16)
      {
        v38 = 0;
        v39 = 9;
        v40 = 152;
        do
        {
          v38 = *((unsigned __int8 *)this + v40) | (v38 << 8);
          --v39;
          ++v40;
        }
        while (v39 > 1);
        v41 = 0;
        v42 = 5;
        v43 = 160;
        do
        {
          v41 = *((unsigned __int8 *)this + v43) | (v41 << 8);
          --v42;
          ++v43;
        }
        while (v42 > 1);
        v44 = 0;
        v45 = 5;
        v46 = 164;
        do
        {
          v44 = *((unsigned __int8 *)this + v46) | (v44 << 8);
          --v45;
          ++v46;
        }
        while (v45 > 1);
        *((_DWORD *)this + 12) = v44;
        if (v41 == 1)
        {
          if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)this + 32))(this, (char *)this + 152, 8) < 8)goto LABEL_8;
          v41 = 0;
          v47 = 9;
          v48 = (unsigned __int8 *)this + 152;
          do
          {
            v49 = *v48++;
            v41 = v49 | (v41 << 8);
            --v47;
          }
          while (v47 > 1);
          v50 = v41 - 16;
        }
        else
        {
          v50 = v41 - 8;
        }
        if ((v24 & 2) != 0)
        {
          if (v41 && (v50 & 0x8000000000000000) != 0)
          {
            *((_DWORD *)this + 12) = 0;
            *(_WORD *)((char *)this + 125) = 0;
            *((_QWORD *)this + 9) = 0;
            *((_QWORD *)this + 7) = 0;
            *((_QWORD *)this + 18) = -1;
            *v5 = -1;
            v5[1] = -1;
            v62 = 0;
            v60 = 0u;
            v61 = 0u;
            kdu_error::kdu_error((kdu_error *)&v60, "Error in Kakadu File Format Support:\n");
            (*(void (**)(__int128 *, const char *))(v60 + 16))(&v60, "Illegal box length field encountered in stream equivalent box header embedded within a JP2 placeholder box.");
            kdu_error::~kdu_error((kdu_error *)&v60);
          }
        }
        else
        {
          *((_DWORD *)this + 12) = 0;
        }
        if ((v24 & 4) == 0)
        {
          *((_QWORD *)this + 12) = v38;
          *((_QWORD *)this + 17) = 0;
          v53 = 0x7FFFFFFFFFFFFFFFLL;
          if (v50 < 0x7FFFFFFFFFFFFFFFLL)
            v53 = v50;
          *((_QWORD *)this + 10) = 0;
          goto LABEL_80;
        }
        if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)this + 32))(this, (char *)this + 152, 8) >= 8)
        {
          v54 = 0;
          v55 = 9;
          v56 = 152;
          do
          {
            v54 = *((unsigned __int8 *)this + v56) | (v54 << 8);
            --v55;
            ++v56;
          }
          while (v55 > 1);
          *((_QWORD *)this + 13) = v54;
          *((_QWORD *)this + 14) = v54 + 1;
          if ((v24 & 8) == 0)
            goto LABEL_89;
          if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(_QWORD *)this + 32))(this, (char *)this + 152, 4) > 3)
          {
            v57 = 0;
            v54 = *v5;
            for (i = 5; i > 1; --i)
            {
              v59 = *v9++;
              v57 = v59 | (v57 << 8);
            }
            *((_QWORD *)this + 14) = v54 + v57;
LABEL_89:
            *((_DWORD *)this + 12) = 1785737827;
            *((_DWORD *)this + 30) = 3;
            *((_QWORD *)this + 12) = 0;
            *((_QWORD *)this + 17) = 0;
            *((_QWORD *)this + 18) = v54;
            *((_OWORD *)this + 5) = xmmword_18820CDE0;
            return 1;
          }
        }
      }
    }
LABEL_8:
    result = 0;
    *((_DWORD *)this + 12) = 0;
    *(_WORD *)((char *)this + 125) = 0;
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 18) = -1;
    *v5 = -1;
    v5[1] = -1;
    return result;
  }
  return 0;
}

void sub_187F1D578(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1D584()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::open(jp2_input_box *this, uint64_t a2, __int128 *a3)
{
  __int128 v5;
  int box_header;
  uint64_t result;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  if (*((_BYTE *)this + 126))
  {
    v17 = 0;
    v15 = 0u;
    v16 = 0u;
    kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v15);
  }
  *((_BYTE *)this + 127) = 0;
  v5 = *a3;
  *((_DWORD *)this + 6) = *((_DWORD *)a3 + 4);
  *(_OWORD *)((char *)this + 8) = v5;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = a2;
  if (!*(_QWORD *)(a2 + 32) || (*((_QWORD *)this + 2) & 0x8000000000000000) == 0)
    goto LABEL_5;
  v10 = *((_QWORD *)this + 1);
  if (v10 < 0)
    jp2_input_box::open();
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  if (v10)
  {
    while (1)
    {
      result = jp2_input_box::read_box_header(this, 1);
      if (!(_DWORD)result)
        break;
      *((_BYTE *)this + 126) = 0;
      v11 = *((_QWORD *)this + 1);
      v12 = *((_QWORD *)this + 7);
      v13 = v12 + v11;
      if (v10 >= v12 + v11)
      {
        if (v12 <= 0)
        {
          v17 = 0;
          v15 = 0u;
          v16 = 0u;
          kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v15);
        }
        *((_QWORD *)this + 1) = v13;
        *((_DWORD *)this + 6) += *((_DWORD *)this + 18);
      }
      else
      {
        v13 = *((_QWORD *)this + 8) + v11;
        if (v10 < v13)
        {
          v17 = 0;
          v15 = 0u;
          v16 = 0u;
          kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v15);
        }
        v14 = *((_QWORD *)this + 12);
        *((_QWORD *)this + 1) = v13;
        *((_QWORD *)this + 2) = v14;
        *((_DWORD *)this + 6) = *((_QWORD *)this + 10);
        if (!*((_DWORD *)this + 12) || !*((_BYTE *)this + 124))
        {
          v17 = 0;
          v15 = 0u;
          v16 = 0u;
          kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v15);
        }
      }
      if (v13 == v10)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    box_header = jp2_input_box::read_box_header(this, 0);
    result = 0;
    if (box_header)
    {
      if (!*((_DWORD *)this + 12))
      {
        *((_BYTE *)this + 126) = 0;
        v17 = 0;
        v15 = 0u;
        v16 = 0u;
        kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v15);
      }
      if (*(_QWORD *)(a2 + 32) && *((_DWORD *)this + 12) == 1785737827)
      {
        v8 = 6;
        v9 = 4;
      }
      else
      {
        v8 = 3;
        v9 = 1;
      }
      *((_DWORD *)this + 32) = v9;
      if (*(_BYTE *)(a2 + 68))
        *((_DWORD *)this + 32) = v8;
      return 1;
    }
  }
  return result;
}

void sub_187F1D884(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1D890()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::open(jp2_input_box *this, jp2_input_box *a2)
{
  uint64_t v4;
  int v5;
  uint64_t box_header;
  uint64_t v7;
  int v8;
  int v9;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  if (*((_BYTE *)this + 126))
  {
    v13 = 0;
    v11 = 0u;
    v12 = 0u;
    kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v11);
  }
  if (*((_BYTE *)a2 + 127) || !*((_BYTE *)a2 + 126))
  {
    v13 = 0;
    v11 = 0u;
    v12 = 0u;
    kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v11 + 16))(&v11, "Attempting to open a sub-box of a box which is not itself open, or which has already been locked by another open sub-box which has not yet been closed.");
    kdu_error::~kdu_error((kdu_error *)&v11);
  }
  *((_QWORD *)this + 4) = a2;
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  if (*((_BYTE *)a2 + 124))
    v4 = *((_QWORD *)a2 + 8) + *((_QWORD *)a2 + 1) + *((_QWORD *)a2 + 17) - *((_QWORD *)a2 + 10);
  else
    v4 = -1;
  *((_QWORD *)this + 1) = v4;
  while (1)
  {
    if (*(_QWORD *)(*((_QWORD *)this + 5) + 32))
    {
      if (*((_DWORD *)a2 + 30) != 4)
      {
        v13 = 0;
        v11 = 0u;
        v12 = 0u;
        kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v11 + 16))(&v11, "Attempting to open a sub-box of a contiguous codestream box (may be a stream equivalent contiguous codestream for a real original box, which might have had sub-boxes), but you should have checked.");
        kdu_error::~kdu_error((kdu_error *)&v11);
      }
      *((_QWORD *)this + 2) = *((_QWORD *)a2 + 12);
      v5 = *((_DWORD *)a2 + 34);
    }
    else
    {
      *((_QWORD *)this + 2) = -1;
      v5 = -1;
    }
    *((_DWORD *)this + 6) = v5;
    box_header = jp2_input_box::read_box_header(this, 0);
    if (!(_DWORD)box_header)
      break;
    if (!*((_DWORD *)this + 12))
    {
      (*(void (**)(jp2_input_box *))(*(_QWORD *)this + 16))(this);
      if (v4 != *((_QWORD *)this + 1) && !*((_DWORD *)this + 12))
        continue;
    }
    v7 = *((_QWORD *)this + 5);
    if (*(_QWORD *)(v7 + 32) && *((_DWORD *)this + 12) == 1785737827)
    {
      v8 = 6;
      v9 = 4;
    }
    else
    {
      v8 = 3;
      v9 = 1;
    }
    *((_DWORD *)this + 32) = v9;
    if (*(_BYTE *)(v7 + 68))
      *((_DWORD *)this + 32) = v8;
    *((_BYTE *)a2 + 127) = 1;
    return box_header;
  }
  return box_header;
}

void sub_187F1DAF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1DB04()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::open_next(jp2_input_box *this)
{
  uint64_t result;
  uint64_t v3;
  int v4;
  uint64_t v5;
  BOOL v6;
  int v7;
  _OWORD v8[2];
  uint64_t v9;

  if (!*((_QWORD *)this + 5) || *((_BYTE *)this + 126))
  {
    v9 = 0;
    memset(v8, 0, sizeof(v8));
    kdu_error::kdu_error((kdu_error *)v8, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v8);
  }
  if (*((_QWORD *)this + 4))
    return (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)this + 80))(this);
  do
  {
    if (*((_BYTE *)this + 125))
      return 0;
    v3 = *((_QWORD *)this + 1);
    if ((v3 & 0x8000000000000000) == 0)
      *((_QWORD *)this + 1) = *((_QWORD *)this + 7) + v3;
    if (*(_QWORD *)(*((_QWORD *)this + 5) + 32))
    {
      if ((*((_QWORD *)this + 2) & 0x8000000000000000) != 0)
        jp2_input_box::open_next();
      *((_DWORD *)this + 6) += *((_DWORD *)this + 18);
    }
    result = jp2_input_box::read_box_header(this, 0);
    if (!(_DWORD)result)
      return result;
    v4 = *((_DWORD *)this + 12);
    if (v4)
      break;
    (*(void (**)(jp2_input_box *))(*(_QWORD *)this + 16))(this);
    v4 = *((_DWORD *)this + 12);
  }
  while (!v4);
  v5 = *((_QWORD *)this + 5);
  if (*(_QWORD *)(v5 + 32))
    v6 = v4 == 1785737827;
  else
    v6 = 0;
  if (v6)
    v7 = 4;
  else
    v7 = 1;
  *((_DWORD *)this + 32) = v7;
  if (*(_BYTE *)(v5 + 68))
    *((_DWORD *)this + 32) = v7 | 2;
  return 1;
}

void sub_187F1DC70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1DC7C()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::close(jp2_input_box *this)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  if (!*((_BYTE *)this + 126))
    return 1;
  v2 = *((_QWORD *)this + 5);
  if (v2 && *(_QWORD *)(v2 + 32))
    jp2_input_box::is_complete(this);
  *((_BYTE *)this + 126) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 32) = 0;
  v3 = *((unsigned __int8 *)this + 125);
  if (*((_BYTE *)this + 125) || (v4 = *((_QWORD *)this + 11), *((_QWORD *)this + 17) >= v4))
  {
    result = 1;
  }
  else
  {
    result = 0;
    *((_QWORD *)this + 17) = v4;
  }
  v6 = *((_QWORD *)this + 4);
  if (v6)
  {
    *(_BYTE *)(v6 + 127) = 0;
    v7 = *((_QWORD *)this + 9);
    *(_QWORD *)(v6 + 136) += v7;
    if (v3)
    {
      if (!v7)
        *(_QWORD *)(v6 + 136) = *((_QWORD *)this + 17);
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
    }
  }
  return result;
}

BOOL jp2_input_box::is_complete(jp2_input_box *this)
{
  uint64_t v2;
  uint64_t v3;
  int v5;

  if (!*((_BYTE *)this + 126))
    return 0;
  v2 = *((_QWORD *)this + 5);
  if (!v2)
    return 0;
  v3 = *(_QWORD *)(v2 + 32);
  if (!v3)
    return 1;
  if ((*((_QWORD *)this + 12) & 0x8000000000000000) != 0 || (*((_DWORD *)this + 30) & 0x80000000) != 0)
    jp2_input_box::is_complete();
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 80))(v3);
  return *((_DWORD *)this + 30) == 4 && !*((_BYTE *)this + 125) && *((_QWORD *)this + 11) <= v5;
}

uint64_t jp2_input_box::transplant(jp2_input_box *this, jp2_input_box *a2)
{
  BOOL v2;
  __int128 v3;
  int v4;
  uint64_t v5;
  _OWORD v7[2];
  uint64_t v8;

  if (*((_BYTE *)this + 126))
    v2 = 1;
  else
    v2 = *((_BYTE *)a2 + 126) == 0;
  if (v2)
  {
    v8 = 0;
    memset(v7, 0, sizeof(v7));
    kdu_error::kdu_error((kdu_error *)v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v7);
  }
  v3 = *(_OWORD *)((char *)a2 + 8);
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  *(_OWORD *)((char *)this + 8) = v3;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
  *(_OWORD *)((char *)this + 88) = *(_OWORD *)((char *)a2 + 88);
  *(_OWORD *)((char *)this + 104) = *(_OWORD *)((char *)a2 + 104);
  *((_DWORD *)this + 30) = *((_DWORD *)a2 + 30);
  *((_BYTE *)this + 124) = *((_BYTE *)a2 + 124);
  *((_BYTE *)this + 125) = *((_BYTE *)a2 + 125);
  *((_WORD *)this + 63) = 1;
  *((_DWORD *)this + 32) = *((_DWORD *)a2 + 32);
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)a2 + 136);
  v4 = *((_DWORD *)a2 + 44);
  *((_DWORD *)this + 44) = v4;
  if (v4 >= 1)
  {
    v5 = 0;
    do
    {
      *((_BYTE *)this + v5 + 152) = *((_BYTE *)a2 + v5 + 152);
      ++v5;
    }
    while (v5 < *((int *)this + 44));
  }
  return (*(uint64_t (**)(jp2_input_box *))(*(_QWORD *)a2 + 16))(a2);
}

void sub_187F1DF44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1DF50()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

BOOL jp2_input_box::seek(jp2_input_box *this, uint64_t a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  _OWORD v6[2];
  uint64_t v7;

  if (!*((_BYTE *)this + 126) || *((_BYTE *)this + 127))
  {
    v7 = 0;
    memset(v6, 0, sizeof(v6));
    kdu_error::kdu_error((kdu_error *)v6, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v6[0] + 16))(v6, "Attempting to seek inside a JP2 box which is not open, or is sharing its read pointer with an open sub-box.");
    kdu_error::~kdu_error((kdu_error *)v6);
  }
  v2 = *(unsigned __int8 *)(*((_QWORD *)this + 5) + 68);
  if (*(_BYTE *)(*((_QWORD *)this + 5) + 68))
  {
    v3 = *((_QWORD *)this + 10);
    v4 = *((_QWORD *)this + 11);
    if (v3 + a2 < v4)
      v4 = v3 + a2;
    if (v4 > v3)
      v3 = v4;
    *((_QWORD *)this + 17) = v3;
    *((_DWORD *)this + 44) = 0;
  }
  return v2 != 0;
}

void sub_187F1E004(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F1E010()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::set_tileheader_scope(jp2_input_box *this, int a2)
{
  uint64_t v3;
  uint64_t result;

  if (!*((_BYTE *)this + 126))
    return 0;
  v3 = *((_QWORD *)this + 5);
  if (!v3)
    return 0;
  result = *(_QWORD *)(v3 + 32);
  if (!result)
    return result;
  if ((*((_QWORD *)this + 18) & 0x8000000000000000) != 0)
    return 0;
  *((_DWORD *)this + 30) = 1;
  *((_QWORD *)this + 12) = a2;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 17) = 0;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)result + 80))(result, 1);
  *((_QWORD *)this + 11) = 0x7FFFFFFFFFFFFFFFLL;
  return 0;
}

uint64_t jp2_input_box::set_precinct_scope(jp2_input_box *this, uint64_t a2)
{
  uint64_t v2;

  if (!*((_BYTE *)this + 126))
    return 0;
  v2 = *((_QWORD *)this + 5);
  if (!v2 || !*(_QWORD *)(v2 + 32) || (*((_QWORD *)this + 18) & 0x8000000000000000) != 0)
    return 0;
  *((_DWORD *)this + 30) = 0;
  *((_QWORD *)this + 12) = a2;
  *((_QWORD *)this + 17) = 0;
  *((_OWORD *)this + 5) = xmmword_18820CDE0;
  return 1;
}

BOOL jp2_input_box::set_codestream_scope(jp2_input_box *this, uint64_t a2, int a3)
{
  uint64_t v3;
  char v5;

  if (!*((_BYTE *)this + 126))
    return 0;
  v3 = *((_QWORD *)this + 5);
  if (!v3 || *((_QWORD *)this + 13) > a2 || *((_QWORD *)this + 14) <= a2)
    return 0;
  *((_DWORD *)this + 30) = 3;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = a2;
  *((_OWORD *)this + 5) = xmmword_18820CDE0;
  if (!a3)
    return 1;
  v5 = 0;
  (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD, char *))(**(_QWORD **)(v3 + 32) + 80))(*(_QWORD *)(v3 + 32), 3, a2, 0, &v5);
  return v5 != 0;
}

size_t jp2_input_box::read(jp2_input_box *this, unsigned __int8 *a2, int64_t a3)
{
  uint64_t v6;
  int64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  _QWORD *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  FILE *v26;
  uint64_t v27;
  uint64_t v28;
  FILE *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  char v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  if (!*((_QWORD *)this + 5) || !*((_BYTE *)this + 126) || *((_BYTE *)this + 127))
  {
    v37 = 0;
    v35 = 0u;
    v36 = 0u;
    kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Illegal attempt to read from a JP2 box which is either not open or else has an open sub-box.");
    kdu_error::~kdu_error((kdu_error *)&v35);
  }
  v6 = *((_QWORD *)this + 11) - *((_QWORD *)this + 17);
  if (v6 < (int)a3 && *((_BYTE *)this + 125) == 0)
    v8 = v6;
  else
    v8 = a3;
  if ((int)v8 < 1)
    return 0;
  if (v8 > (int)a3)
  {
    v37 = 0;
    v35 = 0u;
    v36 = 0u;
    kdu_warning::kdu_warning((kdu_warning *)&v35, "Warning in Kakadu File Format Support:\n");
    (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Corrupt JP2 Data");
    kdu_warning::~kdu_warning((kdu_warning *)&v35);
    v8 = a3;
  }
  (*(void (**)(_QWORD))(**((_QWORD **)this + 5) + 16))(*((_QWORD *)this + 5));
  v9 = *((_QWORD *)this + 5);
  v10 = *(_QWORD *)(v9 + 32);
  if (v10)
  {
    if (!*(_BYTE *)(v9 + 68))
      jp2_input_box::read();
    v11 = *((_DWORD *)this + 30);
    if (v11 == 4)
      v12 = 0;
    else
      v12 = *((_QWORD *)this + 18);
    v16 = *((_QWORD *)this + 12);
    if (*(_QWORD *)(v9 + 48) != v16 || *(_DWORD *)(v9 + 64) != v11 || *(_QWORD *)(v9 + 56) != v12)
    {
      *(_DWORD *)(v9 + 64) = v11;
      *(_QWORD *)(v9 + 48) = v16;
      *(_QWORD *)(v9 + 56) = v12;
      *(_QWORD *)(v9 + 40) = 0;
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 160))(v10);
      v9 = *((_QWORD *)this + 5);
    }
    if (*(_QWORD *)(v9 + 40) != *((_QWORD *)this + 17))
    {
      v17 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v9 + 32) + 40))(*(_QWORD *)(v9 + 32));
      v9 = *((_QWORD *)this + 5);
      if ((v17 & 1) == 0)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
        v37 = 0;
        v35 = 0u;
        v36 = 0u;
        kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Caching source does not appear to support seeking!");
        kdu_error::~kdu_error((kdu_error *)&v35);
      }
    }
    v13 = (*(uint64_t (**)(_QWORD, unsigned __int8 *, int64_t))(**(_QWORD **)(v9 + 32) + 32))(*(_QWORD *)(v9 + 32), a2, v8);
    v18 = *((_QWORD *)this + 17) + (int)v13;
    *((_QWORD *)this + 17) = v18;
    v19 = (_QWORD *)*((_QWORD *)this + 5);
    v19[5] = v18;
    if ((int)v13 >= (int)v8)
    {
      (*(void (**)(_QWORD *))(*v19 + 24))(v19);
      return v13;
    }
    v19[6] = -1;
    (*(void (**)(_QWORD *))(*v19 + 24))(v19);
    v34 = 0;
    v20 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD, char *))(**(_QWORD **)(*((_QWORD *)this + 5) + 32)
                                                                             + 80))(*(_QWORD *)(*((_QWORD *)this + 5) + 32), *((unsigned int *)this + 30), v12, *((_QWORD *)this + 12), &v34);
    if (v34 && *((_QWORD *)this + 17) == v20)
    {
      v21 = v20;
      if (!*((_BYTE *)this + 125) && *((_DWORD *)this + 30) == 4)
      {
        v22 = *((_QWORD *)this + 11);
        if (v22 != v20 && v22 != 0x7FFFFFFFFFFFFFFFLL)
        {
          v37 = 0;
          v35 = 0u;
          v36 = 0u;
          kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Cached data-bin appears to be complete yet terminates prior to the end of the current JP2 box.");
          kdu_error::~kdu_error((kdu_error *)&v35);
        }
        *((_QWORD *)this + 11) = v20;
        return v13;
      }
LABEL_59:
      *((_QWORD *)this + 11) = v21;
      *((_BYTE *)this + 125) = 0;
    }
  }
  else
  {
    v14 = *(_QWORD *)(v9 + 40);
    v15 = *((_QWORD *)this + 17);
    if (*(_BYTE *)(v9 + 68))
    {
      if (v14 != v15)
      {
        if (*(_QWORD *)(v9 + 16))
        {
          fseek(*(FILE **)(v9 + 16), v15, 0);
        }
        else
        {
          v27 = *(_QWORD *)(v9 + 24);
          if (v27)
            (*(void (**)(uint64_t))(*(_QWORD *)v27 + 40))(v27);
        }
      }
    }
    else
    {
      for (; v14 < v15; v15 = *((_QWORD *)this + 17))
      {
        v23 = v14 + 24;
        v24 = v15 - v14;
        if (v23 <= v15)
          v25 = 24;
        else
          v25 = v24;
        v26 = *(FILE **)(v9 + 16);
        if (v26)
        {
          v25 = (int)v25;
          fread((char *)this + 152, 1uLL, (int)v25, v26);
        }
        else
        {
          (*(void (**)(_QWORD, char *, uint64_t))(**(_QWORD **)(v9 + 24) + 32))(*(_QWORD *)(v9 + 24), (char *)this + 152, v25);
          v25 = (int)v25;
        }
        v9 = *((_QWORD *)this + 5);
        v14 = *(_QWORD *)(v9 + 40) + v25;
        *(_QWORD *)(v9 + 40) = v14;
      }
      if (v14 != v15)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
        v37 = 0;
        v35 = 0u;
        v36 = 0u;
        kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
        (*(void (**)(__int128 *, const char *))(v35 + 16))(&v35, "Non-seekable JP2 sources must be read sequentially.  You are attempting to read from multiple boxes simultaneously.");
        kdu_error::~kdu_error((kdu_error *)&v35);
      }
    }
    v28 = *((_QWORD *)this + 5);
    v29 = *(FILE **)(v28 + 16);
    if (v29)
    {
      v13 = fread(a2, 1uLL, (int)v8, v29);
    }
    else
    {
      v30 = *(_QWORD *)(v28 + 24);
      v13 = v8;
      if (v30)
        v13 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, int64_t))(*(_QWORD *)v30 + 32))(v30, a2, v8);
    }
    v31 = *((_QWORD *)this + 17) + (int)v13;
    *((_QWORD *)this + 17) = v31;
    v32 = (_QWORD *)*((_QWORD *)this + 5);
    v32[5] = v31;
    (*(void (**)(_QWORD *))(*v32 + 24))(v32);
    if ((int)v13 < (int)v8 && *((_BYTE *)this + 125))
    {
      v21 = *((_QWORD *)this + 17);
      goto LABEL_59;
    }
  }
  return v13;
}

